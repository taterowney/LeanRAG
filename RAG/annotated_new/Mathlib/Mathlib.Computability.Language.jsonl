{"name":"Language.zero_def","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\n⊢ Eq 0 EmptyCollection.emptyCollection","decl":"theorem zero_def : (0 : Language α) = (∅ : Set _) :=\n  rfl\n\n"}
{"name":"Language.one_def","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\n⊢ Eq 1 (Singleton.singleton List.nil)","decl":"theorem one_def : (1 : Language α) = ({[]} : Set (List α)) :=\n  rfl\n\n"}
{"name":"Language.add_def","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl m : Language α\n⊢ Eq (HAdd.hAdd l m) (Union.union l m)","decl":"theorem add_def (l m : Language α) : l + m = (l ∪ m : Set (List α)) :=\n  rfl\n\n"}
{"name":"Language.mul_def","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl m : Language α\n⊢ Eq (HMul.hMul l m) (Set.image2 (fun x1 x2 => HAppend.hAppend x1 x2) l m)","decl":"theorem mul_def (l m : Language α) : l * m = image2 (· ++ ·) l m :=\n  rfl\n\n"}
{"name":"Language.kstar_def","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\n⊢ Eq (KStar.kstar l) (setOf fun x => Exists fun L => And (Eq x L.flatten) (∀ (y : List α), Membership.mem L y → Membership.mem l y))","decl":"lemma kstar_def (l : Language α) : l∗ = {x | ∃ L : List (List α), x = L.flatten ∧ ∀ y ∈ L, y ∈ l} :=\n  rfl\n\n"}
{"name":"Language.ext","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl m : Language α\nh : ∀ (x : List α), Iff (Membership.mem l x) (Membership.mem m x)\n⊢ Eq l m","decl":"@[ext]\ntheorem ext {l m : Language α} (h : ∀ (x : List α), x ∈ l ↔ x ∈ m) : l = m :=\n  Set.ext h\n\n"}
{"name":"Language.ext_iff","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl m : Language α\n⊢ Iff (Eq l m) (∀ (x : List α), Iff (Membership.mem l x) (Membership.mem m x))","decl":"@[ext]\ntheorem ext {l m : Language α} (h : ∀ (x : List α), x ∈ l ↔ x ∈ m) : l = m :=\n  Set.ext h\n\n"}
{"name":"Language.not_mem_zero","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nx : List α\n⊢ Not (Membership.mem 0 x)","decl":"@[simp]\ntheorem not_mem_zero (x : List α) : x ∉ (0 : Language α) :=\n  id\n\n"}
{"name":"Language.mem_one","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nx : List α\n⊢ Iff (Membership.mem 1 x) (Eq x List.nil)","decl":"@[simp]\ntheorem mem_one (x : List α) : x ∈ (1 : Language α) ↔ x = [] := by rfl\n\n"}
{"name":"Language.nil_mem_one","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\n⊢ Membership.mem 1 List.nil","decl":"theorem nil_mem_one : [] ∈ (1 : Language α) :=\n  Set.mem_singleton _\n\n"}
{"name":"Language.mem_add","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl m : Language α\nx : List α\n⊢ Iff (Membership.mem (HAdd.hAdd l m) x) (Or (Membership.mem l x) (Membership.mem m x))","decl":"theorem mem_add (l m : Language α) (x : List α) : x ∈ l + m ↔ x ∈ l ∨ x ∈ m :=\n  Iff.rfl\n\n"}
{"name":"Language.mem_mul","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl m : Language α\nx : List α\n⊢ Iff (Membership.mem (HMul.hMul l m) x) (Exists fun a => And (Membership.mem l a) (Exists fun b => And (Membership.mem m b) (Eq (HAppend.hAppend a b) x)))","decl":"theorem mem_mul : x ∈ l * m ↔ ∃ a ∈ l, ∃ b ∈ m, a ++ b = x :=\n  mem_image2\n\n"}
{"name":"Language.append_mem_mul","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl m : Language α\na b : List α\na✝¹ : Membership.mem l a\na✝ : Membership.mem m b\n⊢ Membership.mem (HMul.hMul l m) (HAppend.hAppend a b)","decl":"theorem append_mem_mul : a ∈ l → b ∈ m → a ++ b ∈ l * m :=\n  mem_image2_of_mem\n\n"}
{"name":"Language.mem_kstar","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\nx : List α\n⊢ Iff (Membership.mem (KStar.kstar l) x) (Exists fun L => And (Eq x L.flatten) (∀ (y : List α), Membership.mem L y → Membership.mem l y))","decl":"theorem mem_kstar : x ∈ l∗ ↔ ∃ L : List (List α), x = L.flatten ∧ ∀ y ∈ L, y ∈ l :=\n  Iff.rfl\n\n"}
{"name":"Language.join_mem_kstar","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\nL : List (List α)\nh : ∀ (y : List α), Membership.mem L y → Membership.mem l y\n⊢ Membership.mem (KStar.kstar l) L.flatten","decl":"theorem join_mem_kstar {L : List (List α)} (h : ∀ y ∈ L, y ∈ l) : L.flatten ∈ l∗ :=\n  ⟨L, rfl, h⟩\n\n"}
{"name":"Language.nil_mem_kstar","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\n⊢ Membership.mem (KStar.kstar l) List.nil","decl":"theorem nil_mem_kstar (l : Language α) : [] ∈ l∗ :=\n  ⟨[], rfl, fun _ h ↦ by contradiction⟩\n\n"}
{"name":"Language.add_self","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\n⊢ Eq (HAdd.hAdd l l) l","decl":"@[simp]\ntheorem add_self (l : Language α) : l + l = l :=\n  sup_idem _\n\n"}
{"name":"Language.map_id","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\n⊢ Eq ((Language.map id) l) l","decl":"@[simp]\ntheorem map_id (l : Language α) : map id l = l := by simp [map]\n\n"}
{"name":"Language.map_map","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ng : β → γ\nf : α → β\nl : Language α\n⊢ Eq ((Language.map g) ((Language.map f) l)) ((Language.map (Function.comp g f)) l)","decl":"@[simp]\ntheorem map_map (g : β → γ) (f : α → β) (l : Language α) : map g (map f l) = map (g ∘ f) l := by\n  simp [map, image_image]\n\n"}
{"name":"Language.mem_kstar_iff_exists_nonempty","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\nx : List α\n⊢ Iff (Membership.mem (KStar.kstar l) x) (Exists fun S => And (Eq x S.flatten) (∀ (y : List α), Membership.mem S y → And (Membership.mem l y) (Ne y List.nil)))","decl":"lemma mem_kstar_iff_exists_nonempty {x : List α} :\n    x ∈ l∗ ↔ ∃ S : List (List α), x = S.flatten ∧ ∀ y ∈ S, y ∈ l ∧ y ≠ [] := by\n  constructor\n  · rintro ⟨S, rfl, h⟩\n    refine ⟨S.filter fun l ↦ !List.isEmpty l,\n      by simp [List.flatten_filter_not_isEmpty], fun y hy ↦ ?_⟩\n    simp only [mem_filter, Bool.not_eq_eq_eq_not, Bool.not_true, isEmpty_eq_false, ne_eq] at hy\n    exact ⟨h y hy.1, hy.2⟩\n  · rintro ⟨S, hx, h⟩\n    exact ⟨S, hx, fun y hy ↦ (h y hy).1⟩\n\n"}
{"name":"Language.kstar_def_nonempty","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\n⊢ Eq (KStar.kstar l) (setOf fun x => Exists fun S => And (Eq x S.flatten) (∀ (y : List α), Membership.mem S y → And (Membership.mem l y) (Ne y List.nil)))","decl":"theorem kstar_def_nonempty (l : Language α) :\n    l∗ = { x | ∃ S : List (List α), x = S.flatten ∧ ∀ y ∈ S, y ∈ l ∧ y ≠ [] } := by\n  ext x; apply mem_kstar_iff_exists_nonempty\n\n"}
{"name":"Language.le_iff","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl m : Language α\n⊢ Iff (LE.le l m) (Eq (HAdd.hAdd l m) m)","decl":"theorem le_iff (l m : Language α) : l ≤ m ↔ l + m = m :=\n  sup_eq_right.symm\n\n"}
{"name":"Language.le_mul_congr","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl₁ l₂ m₁ m₂ : Language α\na✝¹ : LE.le l₁ m₁\na✝ : LE.le l₂ m₂\n⊢ LE.le (HMul.hMul l₁ l₂) (HMul.hMul m₁ m₂)","decl":"theorem le_mul_congr {l₁ l₂ m₁ m₂ : Language α} : l₁ ≤ m₁ → l₂ ≤ m₂ → l₁ * l₂ ≤ m₁ * m₂ := by\n  intro h₁ h₂ x hx\n  simp only [mul_def, exists_and_left, mem_image2, image_prod] at hx ⊢\n  tauto\n\n"}
{"name":"Language.le_add_congr","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl₁ l₂ m₁ m₂ : Language α\na✝¹ : LE.le l₁ m₁\na✝ : LE.le l₂ m₂\n⊢ LE.le (HAdd.hAdd l₁ l₂) (HAdd.hAdd m₁ m₂)","decl":"theorem le_add_congr {l₁ l₂ m₁ m₂ : Language α} : l₁ ≤ m₁ → l₂ ≤ m₂ → l₁ + l₂ ≤ m₁ + m₂ :=\n  sup_le_sup\n\n"}
{"name":"Language.mem_iSup","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nι : Sort v\nl : ι → Language α\nx : List α\n⊢ Iff (Membership.mem (iSup fun i => l i) x) (Exists fun i => Membership.mem (l i) x)","decl":"theorem mem_iSup {ι : Sort v} {l : ι → Language α} {x : List α} : (x ∈ ⨆ i, l i) ↔ ∃ i, x ∈ l i :=\n  mem_iUnion\n\n"}
{"name":"Language.iSup_mul","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nι : Sort v\nl : ι → Language α\nm : Language α\n⊢ Eq (HMul.hMul (iSup fun i => l i) m) (iSup fun i => HMul.hMul (l i) m)","decl":"theorem iSup_mul {ι : Sort v} (l : ι → Language α) (m : Language α) :\n    (⨆ i, l i) * m = ⨆ i, l i * m :=\n  image2_iUnion_left _ _ _\n\n"}
{"name":"Language.mul_iSup","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nι : Sort v\nl : ι → Language α\nm : Language α\n⊢ Eq (HMul.hMul m (iSup fun i => l i)) (iSup fun i => HMul.hMul m (l i))","decl":"theorem mul_iSup {ι : Sort v} (l : ι → Language α) (m : Language α) :\n    (m * ⨆ i, l i) = ⨆ i, m * l i :=\n  image2_iUnion_right _ _ _\n\n"}
{"name":"Language.iSup_add","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nι : Sort v\ninst✝ : Nonempty ι\nl : ι → Language α\nm : Language α\n⊢ Eq (HAdd.hAdd (iSup fun i => l i) m) (iSup fun i => HAdd.hAdd (l i) m)","decl":"theorem iSup_add {ι : Sort v} [Nonempty ι] (l : ι → Language α) (m : Language α) :\n    (⨆ i, l i) + m = ⨆ i, l i + m :=\n  iSup_sup\n\n"}
{"name":"Language.add_iSup","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nι : Sort v\ninst✝ : Nonempty ι\nl : ι → Language α\nm : Language α\n⊢ Eq (HAdd.hAdd m (iSup fun i => l i)) (iSup fun i => HAdd.hAdd m (l i))","decl":"theorem add_iSup {ι : Sort v} [Nonempty ι] (l : ι → Language α) (m : Language α) :\n    (m + ⨆ i, l i) = ⨆ i, m + l i :=\n  sup_iSup\n\n"}
{"name":"Language.mem_pow","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\nx : List α\nn : Nat\n⊢ Iff (Membership.mem (HPow.hPow l n) x) (Exists fun S => And (Eq x S.flatten) (And (Eq S.length n) (∀ (y : List α), Membership.mem S y → Membership.mem l y)))","decl":"theorem mem_pow {l : Language α} {x : List α} {n : ℕ} :\n    x ∈ l ^ n ↔ ∃ S : List (List α), x = S.flatten ∧ S.length = n ∧ ∀ y ∈ S, y ∈ l := by\n  induction' n with n ihn generalizing x\n  · simp only [mem_one, pow_zero, length_eq_zero]\n    constructor\n    · rintro rfl\n      exact ⟨[], rfl, rfl, fun _ h ↦ by contradiction⟩\n    · rintro ⟨_, rfl, rfl, _⟩\n      rfl\n  · simp only [pow_succ', mem_mul, ihn]\n    constructor\n    · rintro ⟨a, ha, b, ⟨S, rfl, rfl, hS⟩, rfl⟩\n      exact ⟨a :: S, rfl, rfl, forall_mem_cons.2 ⟨ha, hS⟩⟩\n    · rintro ⟨_ | ⟨a, S⟩, rfl, hn, hS⟩ <;> cases hn\n      rw [forall_mem_cons] at hS\n      exact ⟨a, hS.1, _, ⟨S, rfl, rfl, hS.2⟩, rfl⟩\n\n"}
{"name":"Language.kstar_eq_iSup_pow","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\n⊢ Eq (KStar.kstar l) (iSup fun i => HPow.hPow l i)","decl":"theorem kstar_eq_iSup_pow (l : Language α) : l∗ = ⨆ i : ℕ, l ^ i := by\n  ext x\n  simp only [mem_kstar, mem_iSup, mem_pow]\n  constructor\n  · rintro ⟨S, rfl, hS⟩\n    exact ⟨_, S, rfl, rfl, hS⟩\n  · rintro ⟨_, S, rfl, rfl, hS⟩\n    exact ⟨S, rfl, hS⟩\n\n"}
{"name":"Language.map_kstar","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nl : Language α\n⊢ Eq ((Language.map f) (KStar.kstar l)) (KStar.kstar ((Language.map f) l))","decl":"@[simp]\ntheorem map_kstar (f : α → β) (l : Language α) : map f l∗ = (map f l)∗ := by\n  rw [kstar_eq_iSup_pow, kstar_eq_iSup_pow]\n  simp_rw [← map_pow]\n  exact image_iUnion\n\n"}
{"name":"Language.mul_self_kstar_comm","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\n⊢ Eq (HMul.hMul (KStar.kstar l) l) (HMul.hMul l (KStar.kstar l))","decl":"theorem mul_self_kstar_comm (l : Language α) : l∗ * l = l * l∗ := by\n  simp only [kstar_eq_iSup_pow, mul_iSup, iSup_mul, ← pow_succ, ← pow_succ']\n\n"}
{"name":"Language.one_add_self_mul_kstar_eq_kstar","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\n⊢ Eq (HAdd.hAdd 1 (HMul.hMul l (KStar.kstar l))) (KStar.kstar l)","decl":"@[simp]\ntheorem one_add_self_mul_kstar_eq_kstar (l : Language α) : 1 + l * l∗ = l∗ := by\n  simp only [kstar_eq_iSup_pow, mul_iSup, ← pow_succ', ← pow_zero l]\n  exact sup_iSup_nat_succ _\n\n"}
{"name":"Language.one_add_kstar_mul_self_eq_kstar","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\n⊢ Eq (HAdd.hAdd 1 (HMul.hMul (KStar.kstar l) l)) (KStar.kstar l)","decl":"@[simp]\ntheorem one_add_kstar_mul_self_eq_kstar (l : Language α) : 1 + l∗ * l = l∗ := by\n  rw [mul_self_kstar_comm, one_add_self_mul_kstar_eq_kstar]\n\n"}
{"name":"Language.mem_reverse","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\na : List α\n⊢ Iff (Membership.mem l.reverse a) (Membership.mem l a.reverse)","decl":"@[simp]\nlemma mem_reverse : a ∈ l.reverse ↔ a.reverse ∈ l := Iff.rfl\n\n"}
{"name":"Language.reverse_mem_reverse","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\na : List α\n⊢ Iff (Membership.mem l.reverse a.reverse) (Membership.mem l a)","decl":"lemma reverse_mem_reverse : a.reverse ∈ l.reverse ↔ a ∈ l := by\n  rw [mem_reverse, List.reverse_reverse]\n\n"}
{"name":"Language.reverse_eq_image","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\n⊢ Eq l.reverse (Set.image List.reverse l)","decl":"lemma reverse_eq_image (l : Language α) : l.reverse = List.reverse '' l :=\n  ((List.reverse_involutive.toPerm _).image_eq_preimage _).symm\n\n"}
{"name":"Language.reverse_zero","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\n⊢ Eq (Language.reverse 0) 0","decl":"@[simp]\nlemma reverse_zero : (0 : Language α).reverse = 0 := rfl\n\n"}
{"name":"Language.reverse_one","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\n⊢ Eq (Language.reverse 1) 1","decl":"@[simp]\nlemma reverse_one : (1 : Language α).reverse = 1 := by\n  simp [reverse, ← one_def]\n\n"}
{"name":"Language.reverse_involutive","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\n⊢ Function.Involutive Language.reverse","decl":"lemma reverse_involutive : Function.Involutive (reverse : Language α → _) :=\n  List.reverse_involutive.preimage\n\n"}
{"name":"Language.reverse_bijective","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\n⊢ Function.Bijective Language.reverse","decl":"lemma reverse_bijective : Function.Bijective (reverse : Language α → _) :=\n  reverse_involutive.bijective\n\n"}
{"name":"Language.reverse_injective","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\n⊢ Function.Injective Language.reverse","decl":"lemma reverse_injective : Function.Injective (reverse : Language α → _) :=\n  reverse_involutive.injective\n\n"}
{"name":"Language.reverse_surjective","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\n⊢ Function.Surjective Language.reverse","decl":"lemma reverse_surjective : Function.Surjective (reverse : Language α → _) :=\n  reverse_involutive.surjective\n\n"}
{"name":"Language.reverse_reverse","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\n⊢ Eq l.reverse.reverse l","decl":"@[simp]\nlemma reverse_reverse (l : Language α) : l.reverse.reverse = l := reverse_involutive l\n\n"}
{"name":"Language.reverse_add","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl m : Language α\n⊢ Eq (HAdd.hAdd l m).reverse (HAdd.hAdd l.reverse m.reverse)","decl":"@[simp]\nlemma reverse_add (l m : Language α) : (l + m).reverse = l.reverse + m.reverse := rfl\n\n"}
{"name":"Language.reverse_mul","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl m : Language α\n⊢ Eq (HMul.hMul l m).reverse (HMul.hMul m.reverse l.reverse)","decl":"@[simp]\nlemma reverse_mul (l m : Language α) : (l * m).reverse = m.reverse * l.reverse := by\n  simp only [mul_def, reverse_eq_image, image2_image_left, image2_image_right, image_image2,\n    List.reverse_append]\n  apply image2_swap\n\n"}
{"name":"Language.reverse_iSup","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nι : Sort u_4\nl : ι → Language α\n⊢ Eq (iSup fun i => l i).reverse (iSup fun i => (l i).reverse)","decl":"@[simp]\nlemma reverse_iSup {ι : Sort*} (l : ι → Language α) : (⨆ i, l i).reverse = ⨆ i, (l i).reverse :=\n  preimage_iUnion\n\n"}
{"name":"Language.reverse_iInf","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nι : Sort u_4\nl : ι → Language α\n⊢ Eq (iInf fun i => l i).reverse (iInf fun i => (l i).reverse)","decl":"@[simp]\nlemma reverse_iInf {ι : Sort*} (l : ι → Language α) : (⨅ i, l i).reverse = ⨅ i, (l i).reverse :=\n  preimage_iInter\n\n"}
{"name":"Language.reverseIso_apply","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\n⊢ Eq ((Language.reverseIso α) l) (MulOpposite.op l.reverse)","decl":"variable (α) in\n/-- `Language.reverse` as a ring isomorphism to the opposite ring. -/\n@[simps]\ndef reverseIso : Language α ≃+* (Language α)ᵐᵒᵖ where\n  toFun l := .op l.reverse\n  invFun l' := l'.unop.reverse\n  left_inv := reverse_reverse\n  right_inv l' := MulOpposite.unop_injective <| reverse_reverse l'.unop\n  map_mul' l₁ l₂ := MulOpposite.unop_injective <| reverse_mul l₁ l₂\n  map_add' l₁ l₂ := MulOpposite.unop_injective <| reverse_add l₁ l₂\n\n"}
{"name":"Language.reverseIso_symm_apply","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl' : MulOpposite (Language α)\n⊢ Eq ((Language.reverseIso α).symm l') (MulOpposite.unop l').reverse","decl":"variable (α) in\n/-- `Language.reverse` as a ring isomorphism to the opposite ring. -/\n@[simps]\ndef reverseIso : Language α ≃+* (Language α)ᵐᵒᵖ where\n  toFun l := .op l.reverse\n  invFun l' := l'.unop.reverse\n  left_inv := reverse_reverse\n  right_inv l' := MulOpposite.unop_injective <| reverse_reverse l'.unop\n  map_mul' l₁ l₂ := MulOpposite.unop_injective <| reverse_mul l₁ l₂\n  map_add' l₁ l₂ := MulOpposite.unop_injective <| reverse_add l₁ l₂\n\n"}
{"name":"Language.reverse_pow","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\nn : Nat\n⊢ Eq (HPow.hPow l n).reverse (HPow.hPow l.reverse n)","decl":"@[simp]\nlemma reverse_pow (l : Language α) (n : ℕ) : (l ^ n).reverse = l.reverse ^ n :=\n  MulOpposite.op_injective (map_pow (reverseIso α) l n)\n\n"}
{"name":"Language.reverse_kstar","module":"Mathlib.Computability.Language","initialProofState":"α : Type u_1\nl : Language α\n⊢ Eq (KStar.kstar l).reverse (KStar.kstar l.reverse)","decl":"@[simp]\nlemma reverse_kstar (l : Language α) : l∗.reverse = l.reverse∗ := by\n  simp only [kstar_eq_iSup_pow, reverse_iSup, reverse_pow]\n\n"}
{"name":"Symbol.terminal.sizeOf_spec","module":"Mathlib.Computability.Language","initialProofState":"T : Type u_4\nN : Type u_5\ninst✝¹ : SizeOf T\ninst✝ : SizeOf N\nt : T\n⊢ Eq (SizeOf.sizeOf (Symbol.terminal t)) (HAdd.hAdd 1 (SizeOf.sizeOf t))","decl":"/-- Symbols for use by all kinds of grammars. -/\ninductive Symbol (T N : Type*)\n  /-- Terminal symbols (of the same type as the language) -/\n  | terminal    (t : T) : Symbol T N\n  /-- Nonterminal symbols (must not be present at the end of word being generated) -/\n  | nonterminal (n : N) : Symbol T N\nderiving\n  DecidableEq, Repr, Fintype\n\n"}
{"name":"Symbol.nonterminal.sizeOf_spec","module":"Mathlib.Computability.Language","initialProofState":"T : Type u_4\nN : Type u_5\ninst✝¹ : SizeOf T\ninst✝ : SizeOf N\nn : N\n⊢ Eq (SizeOf.sizeOf (Symbol.nonterminal n)) (HAdd.hAdd 1 (SizeOf.sizeOf n))","decl":"/-- Symbols for use by all kinds of grammars. -/\ninductive Symbol (T N : Type*)\n  /-- Terminal symbols (of the same type as the language) -/\n  | terminal    (t : T) : Symbol T N\n  /-- Nonterminal symbols (must not be present at the end of word being generated) -/\n  | nonterminal (n : N) : Symbol T N\nderiving\n  DecidableEq, Repr, Fintype\n\n"}
{"name":"Symbol.nonterminal.inj","module":"Mathlib.Computability.Language","initialProofState":"T : Type u_4\nN : Type u_5\nn✝ n : N\nx✝ : Eq (Symbol.nonterminal n✝) (Symbol.nonterminal n)\n⊢ Eq n✝ n","decl":"/-- Symbols for use by all kinds of grammars. -/\ninductive Symbol (T N : Type*)\n  /-- Terminal symbols (of the same type as the language) -/\n  | terminal    (t : T) : Symbol T N\n  /-- Nonterminal symbols (must not be present at the end of word being generated) -/\n  | nonterminal (n : N) : Symbol T N\nderiving\n  DecidableEq, Repr, Fintype\n\n"}
{"name":"Symbol.terminal.inj","module":"Mathlib.Computability.Language","initialProofState":"T : Type u_4\nN : Type u_5\nt✝ t : T\nx✝ : Eq (Symbol.terminal t✝) (Symbol.terminal t)\n⊢ Eq t✝ t","decl":"/-- Symbols for use by all kinds of grammars. -/\ninductive Symbol (T N : Type*)\n  /-- Terminal symbols (of the same type as the language) -/\n  | terminal    (t : T) : Symbol T N\n  /-- Nonterminal symbols (must not be present at the end of word being generated) -/\n  | nonterminal (n : N) : Symbol T N\nderiving\n  DecidableEq, Repr, Fintype\n\n"}
{"name":"Symbol.nonterminal.injEq","module":"Mathlib.Computability.Language","initialProofState":"T : Type u_4\nN : Type u_5\nn✝ n : N\n⊢ Eq (Eq (Symbol.nonterminal n✝) (Symbol.nonterminal n)) (Eq n✝ n)","decl":"/-- Symbols for use by all kinds of grammars. -/\ninductive Symbol (T N : Type*)\n  /-- Terminal symbols (of the same type as the language) -/\n  | terminal    (t : T) : Symbol T N\n  /-- Nonterminal symbols (must not be present at the end of word being generated) -/\n  | nonterminal (n : N) : Symbol T N\nderiving\n  DecidableEq, Repr, Fintype\n\n"}
{"name":"Symbol.terminal.injEq","module":"Mathlib.Computability.Language","initialProofState":"T : Type u_4\nN : Type u_5\nt✝ t : T\n⊢ Eq (Eq (Symbol.terminal t✝) (Symbol.terminal t)) (Eq t✝ t)","decl":"/-- Symbols for use by all kinds of grammars. -/\ninductive Symbol (T N : Type*)\n  /-- Terminal symbols (of the same type as the language) -/\n  | terminal    (t : T) : Symbol T N\n  /-- Nonterminal symbols (must not be present at the end of word being generated) -/\n  | nonterminal (n : N) : Symbol T N\nderiving\n  DecidableEq, Repr, Fintype\n\n"}
