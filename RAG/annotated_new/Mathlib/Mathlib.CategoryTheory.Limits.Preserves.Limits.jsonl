{"name":"CategoryTheory.preserves_lift_mapCone","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.PreservesLimit F G\nc₁ c₂ : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.IsLimit c₁\n⊢ Eq ((CategoryTheory.Limits.isLimitOfPreserves G t).lift (G.mapCone c₂)) (G.map (t.lift c₂))","decl":"@[simp]\ntheorem preserves_lift_mapCone (c₁ c₂ : Cone F) (t : IsLimit c₁) :\n    (isLimitOfPreserves G t).lift (G.mapCone c₂) = G.map (t.lift c₂) :=\n  ((isLimitOfPreserves G t).uniq (G.mapCone c₂) _ (by simp [← G.map_comp])).symm\n\n"}
{"name":"CategoryTheory.preservesLimitIso_hom_π_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesLimit F G\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\nZ : D\nh : Quiver.Hom (G.obj (F.obj j)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesLimitIso G F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp G) j) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.limit.π F j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem preservesLimitIso_hom_π (j) :\n    (preservesLimitIso G F).hom ≫ limit.π _ j = G.map (limit.π F j) :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ j\n\n"}
{"name":"CategoryTheory.preservesLimitIso_hom_π","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesLimit F G\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesLimitIso G F).hom (CategoryTheory.Limits.limit.π (F.comp G) j)) (G.map (CategoryTheory.Limits.limit.π F j))","decl":"@[reassoc (attr := simp)]\ntheorem preservesLimitIso_hom_π (j) :\n    (preservesLimitIso G F).hom ≫ limit.π _ j = G.map (limit.π F j) :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ j\n\n"}
{"name":"CategoryTheory.preservesLimitsIso_hom_π","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesLimit F G\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesLimitIso G F).hom (CategoryTheory.Limits.limit.π (F.comp G) j)) (G.map (CategoryTheory.Limits.limit.π F j))","decl":"@[deprecated (since := \"2024-10-27\")] alias preservesLimitsIso_hom_π := preservesLimitIso_hom_π\n\n"}
{"name":"CategoryTheory.preservesLimitIso_inv_π","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesLimit F G\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesLimitIso G F).inv (G.map (CategoryTheory.Limits.limit.π F j))) (CategoryTheory.Limits.limit.π (F.comp G) j)","decl":"@[reassoc (attr := simp)]\ntheorem preservesLimitIso_inv_π (j) :\n    (preservesLimitIso G F).inv ≫ G.map (limit.π F j) = limit.π _ j :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ j\n\n"}
{"name":"CategoryTheory.preservesLimitIso_inv_π_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesLimit F G\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\nZ : D\nh : Quiver.Hom (G.obj (F.obj j)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesLimitIso G F).inv (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.limit.π F j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp G) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem preservesLimitIso_inv_π (j) :\n    (preservesLimitIso G F).inv ≫ G.map (limit.π F j) = limit.π _ j :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ j\n\n"}
{"name":"CategoryTheory.preservesLimitsIso_inv_π","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesLimit F G\ninst✝ : CategoryTheory.Limits.HasLimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesLimitIso G F).inv (G.map (CategoryTheory.Limits.limit.π F j))) (CategoryTheory.Limits.limit.π (F.comp G) j)","decl":"@[deprecated (since := \"2024-10-27\")] alias preservesLimitsIso_inv_π := preservesLimitIso_inv_π\n\n"}
{"name":"CategoryTheory.lift_comp_preservesLimitIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesLimit F G\ninst✝ : CategoryTheory.Limits.HasLimit F\nt : CategoryTheory.Limits.Cone F\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.limit (F.comp G)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.limit.lift F t)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesLimitIso G F).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift (F.comp G) (G.mapCone t)) h)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_preservesLimitIso_hom (t : Cone F) :\n    G.map (limit.lift _ t) ≫ (preservesLimitIso G F).hom =\n    limit.lift (F ⋙ G) (G.mapCone _) := by\n  ext\n  simp [← G.map_comp]\n\n"}
{"name":"CategoryTheory.lift_comp_preservesLimitIso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesLimit F G\ninst✝ : CategoryTheory.Limits.HasLimit F\nt : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.limit.lift F t)) (CategoryTheory.preservesLimitIso G F).hom) (CategoryTheory.Limits.limit.lift (F.comp G) (G.mapCone t))","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_preservesLimitIso_hom (t : Cone F) :\n    G.map (limit.lift _ t) ≫ (preservesLimitIso G F).hom =\n    limit.lift (F ⋙ G) (G.mapCone _) := by\n  ext\n  simp [← G.map_comp]\n\n"}
{"name":"CategoryTheory.lift_comp_preservesLimitsIso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesLimit F G\ninst✝ : CategoryTheory.Limits.HasLimit F\nt : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.limit.lift F t)) (CategoryTheory.preservesLimitIso G F).hom) (CategoryTheory.Limits.limit.lift (F.comp G) (G.mapCone t))","decl":"@[deprecated (since := \"2024-10-27\")]\nalias lift_comp_preservesLimitsIso_hom := lift_comp_preservesLimitIso_hom\n\n"}
{"name":"CategoryTheory.instIsIsoPost","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesLimit F G\ninst✝ : CategoryTheory.Limits.HasLimit F\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.limit.post F G)","decl":"instance : IsIso (limit.post F G) :=\n  show IsIso (preservesLimitIso G F).hom from inferInstance\n\n"}
{"name":"CategoryTheory.preservesLimitNatIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\ninst✝² : CategoryTheory.Limits.PreservesLimitsOfShape J G\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J D\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nX : CategoryTheory.Functor J C\n⊢ Eq ((CategoryTheory.preservesLimitNatIso G).inv.app X) (CategoryTheory.preservesLimitIso G X).inv","decl":"/-- If `C, D` has all limits of shape `J`, and `G` preserves them, then `preservesLimitsIso` is\nfunctorial wrt `F`. -/\n@[simps!]\ndef preservesLimitNatIso : lim ⋙ G ≅ (whiskeringRight J C D).obj G ⋙ lim :=\n  NatIso.ofComponents (fun F => preservesLimitIso G F)\n    (by\n      intro _ _ f\n      apply limit.hom_ext; intro j\n      dsimp\n      simp only [preservesLimitIso_hom_π, whiskerRight_app, limMap_π, Category.assoc,\n        preservesLimitIso_hom_π_assoc, ← G.map_comp])\n\n"}
{"name":"CategoryTheory.preservesLimitNatIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\ninst✝² : CategoryTheory.Limits.PreservesLimitsOfShape J G\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J D\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nX : CategoryTheory.Functor J C\n⊢ Eq ((CategoryTheory.preservesLimitNatIso G).hom.app X) (CategoryTheory.preservesLimitIso G X).hom","decl":"/-- If `C, D` has all limits of shape `J`, and `G` preserves them, then `preservesLimitsIso` is\nfunctorial wrt `F`. -/\n@[simps!]\ndef preservesLimitNatIso : lim ⋙ G ≅ (whiskeringRight J C D).obj G ⋙ lim :=\n  NatIso.ofComponents (fun F => preservesLimitIso G F)\n    (by\n      intro _ _ f\n      apply limit.hom_ext; intro j\n      dsimp\n      simp only [preservesLimitIso_hom_π, whiskerRight_app, limMap_π, Category.assoc,\n        preservesLimitIso_hom_π_assoc, ← G.map_comp])\n\n"}
{"name":"CategoryTheory.preservesLimit_of_isIso_post","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.HasLimit F\ninst✝¹ : CategoryTheory.Limits.HasLimit (F.comp G)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.limit.post F G)\n⊢ CategoryTheory.Limits.PreservesLimit F G","decl":"/-- If the comparison morphism `G.obj (limit F) ⟶ limit (F ⋙ G)` is an isomorphism, then `G`\n    preserves limits of `F`. -/\nlemma preservesLimit_of_isIso_post [IsIso (limit.post F G)] : PreservesLimit F G :=\n  preservesLimit_of_preserves_limit_cone (limit.isLimit F) (by\n    convert IsLimit.ofPointIso (limit.isLimit (F ⋙ G))\n    assumption)\n\n"}
{"name":"CategoryTheory.preserves_desc_mapCocone","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.PreservesColimit F G\nc₁ c₂ : CategoryTheory.Limits.Cocone F\nt : CategoryTheory.Limits.IsColimit c₁\n⊢ Eq ((CategoryTheory.Limits.isColimitOfPreserves G t).desc (G.mapCocone c₂)) (G.map (t.desc c₂))","decl":"@[simp]\ntheorem preserves_desc_mapCocone (c₁ c₂ : Cocone F) (t : IsColimit c₁) :\n    (isColimitOfPreserves G t).desc (G.mapCocone _) = G.map (t.desc c₂) :=\n  ((isColimitOfPreserves G t).uniq (G.mapCocone _) _ (by simp [← G.map_comp])).symm\n\n"}
{"name":"CategoryTheory.ι_preservesColimitIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit F G\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.colimit F)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp G) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesColimitIso G F).inv h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.colimit.ι F j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem ι_preservesColimitIso_inv (j : J) :\n    colimit.ι _ j ≫ (preservesColimitIso G F).inv = G.map (colimit.ι F j) :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ (colimit.isColimit (F ⋙ G)) j\n\n"}
{"name":"CategoryTheory.ι_preservesColimitIso_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit F G\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp G) j) (CategoryTheory.preservesColimitIso G F).inv) (G.map (CategoryTheory.Limits.colimit.ι F j))","decl":"@[reassoc (attr := simp)]\ntheorem ι_preservesColimitIso_inv (j : J) :\n    colimit.ι _ j ≫ (preservesColimitIso G F).inv = G.map (colimit.ι F j) :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ (colimit.isColimit (F ⋙ G)) j\n\n"}
{"name":"CategoryTheory.ι_preservesColimitsIso_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit F G\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp G) j) (CategoryTheory.preservesColimitIso G F).inv) (G.map (CategoryTheory.Limits.colimit.ι F j))","decl":"@[deprecated (since := \"2024-10-27\")]\nalias ι_preservesColimitsIso_inv := ι_preservesColimitIso_inv\n\n"}
{"name":"CategoryTheory.ι_preservesColimitIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit F G\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.colimit (F.comp G)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.colimit.ι F j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesColimitIso G F).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp G) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem ι_preservesColimitIso_hom (j : J) :\n    G.map (colimit.ι F j) ≫ (preservesColimitIso G F).hom = colimit.ι (F ⋙ G) j :=\n  (isColimitOfPreserves G (colimit.isColimit _)).comp_coconePointUniqueUpToIso_hom _ j\n\n"}
{"name":"CategoryTheory.ι_preservesColimitIso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit F G\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.colimit.ι F j)) (CategoryTheory.preservesColimitIso G F).hom) (CategoryTheory.Limits.colimit.ι (F.comp G) j)","decl":"@[reassoc (attr := simp)]\ntheorem ι_preservesColimitIso_hom (j : J) :\n    G.map (colimit.ι F j) ≫ (preservesColimitIso G F).hom = colimit.ι (F ⋙ G) j :=\n  (isColimitOfPreserves G (colimit.isColimit _)).comp_coconePointUniqueUpToIso_hom _ j\n\n"}
{"name":"CategoryTheory.ι_preservesColimitsIso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit F G\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.colimit.ι F j)) (CategoryTheory.preservesColimitIso G F).hom) (CategoryTheory.Limits.colimit.ι (F.comp G) j)","decl":"@[deprecated (since := \"2024-10-27\")]\nalias ι_preservesColimitsIso_hom := ι_preservesColimitIso_hom\n\n"}
{"name":"CategoryTheory.preservesColimitIso_inv_comp_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit F G\ninst✝ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.Cocone F\nZ : D\nh : Quiver.Hom (G.obj t.pt) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesColimitIso G F).inv (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.colimit.desc F t)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.desc (F.comp G) (G.mapCocone t)) h)","decl":"@[reassoc (attr := simp)]\ntheorem preservesColimitIso_inv_comp_desc (t : Cocone F) :\n    (preservesColimitIso G F).inv ≫ G.map (colimit.desc _ t) =\n    colimit.desc _ (G.mapCocone t) := by\n  ext\n  simp [← G.map_comp]\n\n"}
{"name":"CategoryTheory.preservesColimitIso_inv_comp_desc","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit F G\ninst✝ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesColimitIso G F).inv (G.map (CategoryTheory.Limits.colimit.desc F t))) (CategoryTheory.Limits.colimit.desc (F.comp G) (G.mapCocone t))","decl":"@[reassoc (attr := simp)]\ntheorem preservesColimitIso_inv_comp_desc (t : Cocone F) :\n    (preservesColimitIso G F).inv ≫ G.map (colimit.desc _ t) =\n    colimit.desc _ (G.mapCocone t) := by\n  ext\n  simp [← G.map_comp]\n\n"}
{"name":"CategoryTheory.preservesColimitsIso_inv_comp_desc","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit F G\ninst✝ : CategoryTheory.Limits.HasColimit F\nt : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.preservesColimitIso G F).inv (G.map (CategoryTheory.Limits.colimit.desc F t))) (CategoryTheory.Limits.colimit.desc (F.comp G) (G.mapCocone t))","decl":"@[deprecated (since := \"2024-10-27\")]\nalias preservesColimitsIso_inv_comp_desc := preservesColimitIso_inv_comp_desc\n\n"}
{"name":"CategoryTheory.instIsIsoPost_1","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝² : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit F G\ninst✝ : CategoryTheory.Limits.HasColimit F\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.colimit.post F G)","decl":"instance : IsIso (colimit.post F G) :=\n  show IsIso (preservesColimitIso G F).inv from inferInstance\n\n"}
{"name":"CategoryTheory.preservesColimitNatIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\ninst✝² : CategoryTheory.Limits.PreservesColimitsOfShape J G\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J D\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nX : CategoryTheory.Functor J C\n⊢ Eq ((CategoryTheory.preservesColimitNatIso G).inv.app X) (CategoryTheory.preservesColimitIso G X).inv","decl":"/-- If `C, D` has all colimits of shape `J`, and `G` preserves them, then `preservesColimitIso`\nis functorial wrt `F`. -/\n@[simps!]\ndef preservesColimitNatIso : colim ⋙ G ≅ (whiskeringRight J C D).obj G ⋙ colim :=\n  NatIso.ofComponents (fun F => preservesColimitIso G F)\n    (by\n      intro _ _ f\n      rw [← Iso.inv_comp_eq, ← Category.assoc, ← Iso.eq_comp_inv]\n      apply colimit.hom_ext; intro j\n      dsimp\n      rw [ι_colimMap_assoc]\n      simp only [ι_preservesColimitIso_inv, whiskerRight_app, Category.assoc,\n        ι_preservesColimitIso_inv_assoc, ← G.map_comp]\n      rw [ι_colimMap])\n\n"}
{"name":"CategoryTheory.preservesColimitNatIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\ninst✝² : CategoryTheory.Limits.PreservesColimitsOfShape J G\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J D\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nX : CategoryTheory.Functor J C\n⊢ Eq ((CategoryTheory.preservesColimitNatIso G).hom.app X) (CategoryTheory.preservesColimitIso G X).hom","decl":"/-- If `C, D` has all colimits of shape `J`, and `G` preserves them, then `preservesColimitIso`\nis functorial wrt `F`. -/\n@[simps!]\ndef preservesColimitNatIso : colim ⋙ G ≅ (whiskeringRight J C D).obj G ⋙ colim :=\n  NatIso.ofComponents (fun F => preservesColimitIso G F)\n    (by\n      intro _ _ f\n      rw [← Iso.inv_comp_eq, ← Category.assoc, ← Iso.eq_comp_inv]\n      apply colimit.hom_ext; intro j\n      dsimp\n      rw [ι_colimMap_assoc]\n      simp only [ι_preservesColimitIso_inv, whiskerRight_app, Category.assoc,\n        ι_preservesColimitIso_inv_assoc, ← G.map_comp]\n      rw [ι_colimMap])\n\n"}
{"name":"CategoryTheory.preservesColimit_of_isIso_post","module":"Mathlib.CategoryTheory.Limits.Preserves.Limits","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nJ : Type w\ninst✝³ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.HasColimit F\ninst✝¹ : CategoryTheory.Limits.HasColimit (F.comp G)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.colimit.post F G)\n⊢ CategoryTheory.Limits.PreservesColimit F G","decl":"/-- If the comparison morphism `colimit (F ⋙ G) ⟶ G.obj (colimit F)` is an isomorphism, then `G`\n    preserves colimits of `F`. -/\nlemma preservesColimit_of_isIso_post [IsIso (colimit.post F G)] : PreservesColimit F G :=\n  preservesColimit_of_preserves_colimit_cocone (colimit.isColimit F) (by\n    convert IsColimit.ofPointIso (colimit.isColimit (F ⋙ G))\n    assumption)\n\n"}
