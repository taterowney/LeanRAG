{"name":"CategoryTheory.Functor.IsCartesian.universal_property","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nself : p.IsCartesian f φ\na' : 𝒳\nφ' : Quiver.Hom a' b\ninst✝ : p.IsHomLift f φ'\n⊢ ExistsUnique fun χ => And (p.IsHomLift (CategoryTheory.CategoryStruct.id R) χ) (Eq (CategoryTheory.CategoryStruct.comp χ φ) φ')","decl":"/-- A morphism `φ : a ⟶ b` in `𝒳` lying over `f : R ⟶ S` in `𝒮` is cartesian if for all\nmorphisms `φ' : a' ⟶ b`, also lying over `f`, there exists a unique morphism `χ : a' ⟶ a` lifting\n`𝟙 R` such that `φ' = χ ≫ φ`.\n\nSee SGA 1 VI 5.1. -/\nclass IsCartesian extends IsHomLift p f φ : Prop where\n  universal_property {a' : 𝒳} (φ' : a' ⟶ b) [IsHomLift p f φ'] :\n      ∃! χ : a' ⟶ a, IsHomLift p (𝟙 R) χ ∧ χ ≫ φ = φ'\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.toIsHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nself : p.IsCartesian f φ\n⊢ p.IsHomLift f φ","decl":"/-- A morphism `φ : a ⟶ b` in `𝒳` lying over `f : R ⟶ S` in `𝒮` is cartesian if for all\nmorphisms `φ' : a' ⟶ b`, also lying over `f`, there exists a unique morphism `χ : a' ⟶ a` lifting\n`𝟙 R` such that `φ' = χ ≫ φ`.\n\nSee SGA 1 VI 5.1. -/\nclass IsCartesian extends IsHomLift p f φ : Prop where\n  universal_property {a' : 𝒳} (φ' : a' ⟶ b) [IsHomLift p f φ'] :\n      ∃! χ : a' ⟶ a, IsHomLift p (𝟙 R) χ ∧ χ ≫ φ = φ'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.universal_property'","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nself : p.IsStronglyCartesian f φ\na' : 𝒳\ng : Quiver.Hom (p.obj a') R\nφ' : Quiver.Hom a' b\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.comp g f) φ'\n⊢ ExistsUnique fun χ => And (p.IsHomLift g χ) (Eq (CategoryTheory.CategoryStruct.comp χ φ) φ')","decl":"/-- A morphism `φ : a ⟶ b` in `𝒳` lying over `f : R ⟶ S` in `𝒮` is strongly cartesian if for\nall morphisms `φ' : a' ⟶ b` and all diagrams of the form\n```\na'        a --φ--> b\n|         |        |\nv         v        v\nR' --g--> R --f--> S\n```\nsuch that `φ'` lifts `g ≫ f`, there exists a lift `χ` of `g` such that `φ' = χ ≫ φ`. -/\n@[stacks 02XK]\nclass IsStronglyCartesian extends IsHomLift p f φ : Prop where\n  universal_property' {a' : 𝒳} (g : p.obj a' ⟶ R) (φ' : a' ⟶ b) [IsHomLift p (g ≫ f) φ'] :\n      ∃! χ : a' ⟶ a, IsHomLift p g χ ∧ χ ≫ φ = φ'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.toIsHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\nself : p.IsStronglyCartesian f φ\n⊢ p.IsHomLift f φ","decl":"/-- A morphism `φ : a ⟶ b` in `𝒳` lying over `f : R ⟶ S` in `𝒮` is strongly cartesian if for\nall morphisms `φ' : a' ⟶ b` and all diagrams of the form\n```\na'        a --φ--> b\n|         |        |\nv         v        v\nR' --g--> R --f--> S\n```\nsuch that `φ'` lifts `g ≫ f`, there exists a lift `χ` of `g` such that `φ' = χ ≫ φ`. -/\n@[stacks 02XK]\nclass IsStronglyCartesian extends IsHomLift p f φ : Prop where\n  universal_property' {a' : 𝒳} (g : p.obj a' ⟶ R) (φ' : a' ⟶ b) [IsHomLift p (g ≫ f) φ'] :\n      ∃! χ : a' ⟶ a, IsHomLift p g χ ∧ χ ≫ φ = φ'\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.map_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCartesian f φ\na' : 𝒳\nφ' : Quiver.Hom a' b\ninst✝ : p.IsHomLift f φ'\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.id R) (CategoryTheory.Functor.IsCartesian.map p f φ φ')","decl":"instance map_isHomLift : IsHomLift p (𝟙 R) (IsCartesian.map p f φ φ') :=\n  (Classical.choose_spec <| IsCartesian.universal_property (p := p) (f := f) (φ := φ) φ').1.1\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.fac","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCartesian f φ\na' : 𝒳\nφ' : Quiver.Hom a' b\ninst✝ : p.IsHomLift f φ'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsCartesian.map p f φ φ') φ) φ'","decl":"@[reassoc (attr := simp)]\nlemma fac : IsCartesian.map p f φ φ' ≫ φ = φ' :=\n  (Classical.choose_spec <| IsCartesian.universal_property (p := p) (f := f) (φ := φ) φ').1.2\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.fac_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCartesian f φ\na' : 𝒳\nφ' : Quiver.Hom a' b\ninst✝ : p.IsHomLift f φ'\nZ : 𝒳\nh : Quiver.Hom b Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsCartesian.map p f φ φ') (CategoryTheory.CategoryStruct.comp φ h)) (CategoryTheory.CategoryStruct.comp φ' h)","decl":"@[reassoc (attr := simp)]\nlemma fac : IsCartesian.map p f φ φ' ≫ φ = φ' :=\n  (Classical.choose_spec <| IsCartesian.universal_property (p := p) (f := f) (φ := φ) φ').1.2\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.map_uniq","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝² : p.IsCartesian f φ\na' : 𝒳\nφ' : Quiver.Hom a' b\ninst✝¹ : p.IsHomLift f φ'\nψ : Quiver.Hom a' a\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) ψ\nhψ : Eq (CategoryTheory.CategoryStruct.comp ψ φ) φ'\n⊢ Eq ψ (CategoryTheory.Functor.IsCartesian.map p f φ φ')","decl":"/-- Given a cartesian morphism `φ : a ⟶ b` lying over `f : R ⟶ S` in `𝒳`, and another morphism\n`φ' : a' ⟶ b` which also lifts `f`. Then any morphism `ψ : a' ⟶ a` lifting `𝟙 R` such that\n`g ≫ ψ = φ'` must equal the map induced from the universal property of `φ`. -/\nlemma map_uniq (ψ : a' ⟶ a) [IsHomLift p (𝟙 R) ψ] (hψ : ψ ≫ φ = φ') :\n    ψ = IsCartesian.map p f φ φ' :=\n  (Classical.choose_spec <| IsCartesian.universal_property (p := p) (f := f) (φ := φ) φ').2\n    ψ ⟨inferInstance, hψ⟩\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.ext","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝² : p.IsCartesian f φ\na' : 𝒳\nψ ψ' : Quiver.Hom a' a\ninst✝¹ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) ψ\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) ψ'\nh : Eq (CategoryTheory.CategoryStruct.comp ψ φ) (CategoryTheory.CategoryStruct.comp ψ' φ)\n⊢ Eq ψ ψ'","decl":"/-- Given a cartesian morphism `φ : a ⟶ b` lying over `f : R ⟶ S` in `𝒳`, and two morphisms\n`ψ ψ' : a' ⟶ a` such that `ψ ≫ φ = ψ' ≫ φ`. Then we must have `ψ = ψ'`. -/\nprotected lemma ext (φ : a ⟶ b) [IsCartesian p f φ] {a' : 𝒳} (ψ ψ' : a' ⟶ a)\n    [IsHomLift p (𝟙 R) ψ] [IsHomLift p (𝟙 R) ψ'] (h : ψ ≫ φ = ψ' ≫ φ) : ψ = ψ' := by\n  rw [map_uniq p f φ (ψ ≫ φ) ψ rfl, map_uniq p f φ (ψ ≫ φ) ψ' h.symm]\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.map_self","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝ : p.IsCartesian f φ\n⊢ Eq (CategoryTheory.Functor.IsCartesian.map p f φ φ) (CategoryTheory.CategoryStruct.id a)","decl":"@[simp]\nlemma map_self : IsCartesian.map p f φ φ = 𝟙 a := by\n  subst_hom_lift p f φ; symm\n  apply map_uniq\n  simp only [id_comp]\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso_hom","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCartesian f φ\na' : 𝒳\nφ' : Quiver.Hom a' b\ninst✝ : p.IsCartesian f φ'\n⊢ Eq (CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso p f φ φ').hom (CategoryTheory.Functor.IsCartesian.map p f φ φ')","decl":"/-- The canonical isomorphism between the domains of two cartesian morphisms\nlying over the same object. -/\n@[simps]\nnoncomputable def domainUniqueUpToIso {a' : 𝒳} (φ' : a' ⟶ b) [IsCartesian p f φ'] : a' ≅ a where\n  hom := IsCartesian.map p f φ φ'\n  inv := IsCartesian.map p f φ' φ\n  hom_inv_id := by\n    subst_hom_lift p f φ'\n    apply IsCartesian.ext p (p.map φ') φ'\n    simp only [assoc, fac, id_comp]\n  inv_hom_id := by\n    subst_hom_lift p f φ\n    apply IsCartesian.ext p (p.map φ) φ\n    simp only [assoc, fac, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso_inv","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCartesian f φ\na' : 𝒳\nφ' : Quiver.Hom a' b\ninst✝ : p.IsCartesian f φ'\n⊢ Eq (CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso p f φ φ').inv (CategoryTheory.Functor.IsCartesian.map p f φ' φ)","decl":"/-- The canonical isomorphism between the domains of two cartesian morphisms\nlying over the same object. -/\n@[simps]\nnoncomputable def domainUniqueUpToIso {a' : 𝒳} (φ' : a' ⟶ b) [IsCartesian p f φ'] : a' ≅ a where\n  hom := IsCartesian.map p f φ φ'\n  inv := IsCartesian.map p f φ' φ\n  hom_inv_id := by\n    subst_hom_lift p f φ'\n    apply IsCartesian.ext p (p.map φ') φ'\n    simp only [assoc, fac, id_comp]\n  inv_hom_id := by\n    subst_hom_lift p f φ\n    apply IsCartesian.ext p (p.map φ) φ\n    simp only [assoc, fac, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso_inv_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCartesian f φ\na' : 𝒳\nφ' : Quiver.Hom a' b\ninst✝ : p.IsCartesian f φ'\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.id R) (CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso p f φ φ').hom","decl":"instance domainUniqueUpToIso_inv_isHomLift {a' : 𝒳} (φ' : a' ⟶ b) [IsCartesian p f φ'] :\n    IsHomLift p (𝟙 R) (domainUniqueUpToIso p f φ φ').hom :=\n  domainUniqueUpToIso_hom p f φ φ' ▸ IsCartesian.map_isHomLift p f φ φ'\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso_hom_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCartesian f φ\na' : 𝒳\nφ' : Quiver.Hom a' b\ninst✝ : p.IsCartesian f φ'\n⊢ p.IsHomLift (CategoryTheory.CategoryStruct.id R) (CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso p f φ φ').inv","decl":"instance domainUniqueUpToIso_hom_isHomLift {a' : 𝒳} (φ' : a' ⟶ b) [IsCartesian p f φ'] :\n    IsHomLift p (𝟙 R) (domainUniqueUpToIso p f φ φ').inv :=\n  domainUniqueUpToIso_inv p f φ φ' ▸ IsCartesian.map_isHomLift p f φ' φ\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.of_iso_comp","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCartesian f φ\na' : 𝒳\nφ' : CategoryTheory.Iso a' a\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) φ'.hom\n⊢ p.IsCartesian f (CategoryTheory.CategoryStruct.comp φ'.hom φ)","decl":"/-- Precomposing a cartesian morphism with an isomorphism lifting the identity is cartesian. -/\ninstance of_iso_comp {a' : 𝒳} (φ' : a' ≅ a) [IsHomLift p (𝟙 R) φ'.hom] :\n    IsCartesian p f (φ'.hom ≫ φ) where\n  universal_property := by\n    intro c ψ hψ\n    use IsCartesian.map p f φ ψ ≫ φ'.inv\n    refine ⟨⟨inferInstance, by simp⟩, ?_⟩\n    rintro τ ⟨hτ₁, hτ₂⟩\n    rw [Iso.eq_comp_inv]\n    apply map_uniq\n    simp only [assoc, hτ₂]\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.of_comp_iso","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsCartesian f φ\nb' : 𝒳\nφ' : CategoryTheory.Iso b b'\ninst✝ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) φ'.hom\n⊢ p.IsCartesian f (CategoryTheory.CategoryStruct.comp φ φ'.hom)","decl":"/-- Postcomposing a cartesian morphism with an isomorphism lifting the identity is cartesian. -/\ninstance of_comp_iso {b' : 𝒳} (φ' : b ≅ b') [IsHomLift p (𝟙 S) φ'.hom] :\n    IsCartesian p f (φ ≫ φ'.hom) where\n  universal_property := by\n    intro c ψ hψ\n    use IsCartesian.map p f φ (ψ ≫ φ'.inv)\n    refine ⟨⟨inferInstance, by simp⟩, ?_⟩\n    rintro τ ⟨hτ₁, hτ₂⟩\n    apply map_uniq\n    simp only [Iso.eq_comp_inv, assoc, hτ₂]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.universal_property","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsStronglyCartesian f φ\nR' : 𝒮\na' : 𝒳\ng : Quiver.Hom R' R\nf' : Quiver.Hom R' S\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nφ' : Quiver.Hom a' b\ninst✝ : p.IsHomLift f' φ'\n⊢ ExistsUnique fun χ => And (p.IsHomLift g χ) (Eq (CategoryTheory.CategoryStruct.comp χ φ) φ')","decl":"/-- The universal property of a strongly cartesian morphism.\n\nThis lemma is more flexible with respect to non-definitional equalities than the field\n`universal_property'` of `IsStronglyCartesian`. -/\nlemma universal_property {R' : 𝒮} {a' : 𝒳} (g : R' ⟶ R) (f' : R' ⟶ S) (hf' : f' = g ≫ f)\n    (φ' : a' ⟶ b) [IsHomLift p f' φ'] : ∃! χ : a' ⟶ a, IsHomLift p g χ ∧ χ ≫ φ = φ' := by\n  subst_hom_lift p f' φ'; clear a b R S\n  have : p.IsHomLift (g ≫ f) φ' := (hf' ▸ inferInstance)\n  apply IsStronglyCartesian.universal_property' f\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.isCartesian_of_isStronglyCartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝ : p.IsStronglyCartesian f φ\n⊢ p.IsCartesian f φ","decl":"instance isCartesian_of_isStronglyCartesian [p.IsStronglyCartesian f φ] : p.IsCartesian f φ where\n  universal_property := fun φ' => universal_property p f φ (𝟙 R) f (by simp) φ'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.map_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsStronglyCartesian f φ\nR' : 𝒮\na' : 𝒳\ng : Quiver.Hom R' R\nf' : Quiver.Hom R' S\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nφ' : Quiver.Hom a' b\ninst✝ : p.IsHomLift f' φ'\n⊢ p.IsHomLift g (CategoryTheory.Functor.IsStronglyCartesian.map p f φ hf' φ')","decl":"instance map_isHomLift : IsHomLift p g (map p f φ hf' φ') :=\n  (Classical.choose_spec <| universal_property p f φ _ _ hf' φ').1.1\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.fac","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsStronglyCartesian f φ\nR' : 𝒮\na' : 𝒳\ng : Quiver.Hom R' R\nf' : Quiver.Hom R' S\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nφ' : Quiver.Hom a' b\ninst✝ : p.IsHomLift f' φ'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCartesian.map p f φ hf' φ') φ) φ'","decl":"@[reassoc (attr := simp)]\nlemma fac : (map p f φ hf' φ') ≫ φ = φ' :=\n  (Classical.choose_spec <| universal_property p f φ _ _ hf' φ').1.2\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.fac_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsStronglyCartesian f φ\nR' : 𝒮\na' : 𝒳\ng : Quiver.Hom R' R\nf' : Quiver.Hom R' S\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nφ' : Quiver.Hom a' b\ninst✝ : p.IsHomLift f' φ'\nZ : 𝒳\nh : Quiver.Hom b Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCartesian.map p f φ hf' φ') (CategoryTheory.CategoryStruct.comp φ h)) (CategoryTheory.CategoryStruct.comp φ' h)","decl":"@[reassoc (attr := simp)]\nlemma fac : (map p f φ hf' φ') ≫ φ = φ' :=\n  (Classical.choose_spec <| universal_property p f φ _ _ hf' φ').1.2\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.map_uniq","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝² : p.IsStronglyCartesian f φ\nR' : 𝒮\na' : 𝒳\ng : Quiver.Hom R' R\nf' : Quiver.Hom R' S\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nφ' : Quiver.Hom a' b\ninst✝¹ : p.IsHomLift f' φ'\nψ : Quiver.Hom a' a\ninst✝ : p.IsHomLift g ψ\nhψ : Eq (CategoryTheory.CategoryStruct.comp ψ φ) φ'\n⊢ Eq ψ (CategoryTheory.Functor.IsStronglyCartesian.map p f φ hf' φ')","decl":"/-- Given a diagram\n```\na'        a --φ--> b\n|         |        |\nv         v        v\nR' --g--> R --f--> S\n```\nsuch that `φ` is strongly cartesian, and morphisms `φ' : a' ⟶ b`, `ψ : a' ⟶ a` such that\n`ψ ≫ φ = φ'`. Then `ψ` is the map induced by the universal property. -/\nlemma map_uniq (ψ : a' ⟶ a) [IsHomLift p g ψ] (hψ : ψ ≫ φ = φ') : ψ = map p f φ hf' φ' :=\n  (Classical.choose_spec <| universal_property p f φ _ _ hf' φ').2 ψ ⟨inferInstance, hψ⟩\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.ext","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝² : p.IsStronglyCartesian f φ\nR' : 𝒮\na' : 𝒳\ng : Quiver.Hom R' R\nψ ψ' : Quiver.Hom a' a\ninst✝¹ : p.IsHomLift g ψ\ninst✝ : p.IsHomLift g ψ'\nh : Eq (CategoryTheory.CategoryStruct.comp ψ φ) (CategoryTheory.CategoryStruct.comp ψ' φ)\n⊢ Eq ψ ψ'","decl":"/-- Given a diagram\n```\na'        a --φ--> b\n|         |        |\nv         v        v\nR' --g--> R --f--> S\n```\nsuch that `φ` is strongly cartesian, and morphisms `ψ ψ' : a' ⟶ a` such that\n`g ≫ ψ = φ' = g ≫ ψ'`. Then we have that `ψ = ψ'`. -/\nprotected lemma ext (φ : a ⟶ b) [IsStronglyCartesian p f φ] {R' : 𝒮} {a' : 𝒳} (g : R' ⟶ R)\n    {ψ ψ' : a' ⟶ a} [IsHomLift p g ψ] [IsHomLift p g ψ'] (h : ψ ≫ φ = ψ' ≫ φ) : ψ = ψ' := by\n  rw [map_uniq p f φ (g := g) rfl (ψ ≫ φ) ψ rfl, map_uniq p f φ (g := g) rfl (ψ ≫ φ) ψ' h.symm]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.map_self","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝ : p.IsStronglyCartesian f φ\n⊢ Eq (CategoryTheory.Functor.IsStronglyCartesian.map p f φ ⋯ φ) (CategoryTheory.CategoryStruct.id a)","decl":"@[simp]\nlemma map_self : map p f φ (id_comp f).symm φ = 𝟙 a := by\n  subst_hom_lift p f φ; symm\n  apply map_uniq\n  simp only [id_comp]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.map_comp_map","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝² : p.IsStronglyCartesian f φ\nR' R'' : 𝒮\na' a'' : 𝒳\nf' : Quiver.Hom R' S\nf'' : Quiver.Hom R'' S\ng : Quiver.Hom R' R\ng' : Quiver.Hom R'' R'\nH : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nH' : Eq f'' (CategoryTheory.CategoryStruct.comp g' f')\nφ' : Quiver.Hom a' b\nφ'' : Quiver.Hom a'' b\ninst✝¹ : p.IsStronglyCartesian f' φ'\ninst✝ : p.IsHomLift f'' φ''\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCartesian.map p f' φ' H' φ'') (CategoryTheory.Functor.IsStronglyCartesian.map p f φ H φ')) (CategoryTheory.Functor.IsStronglyCartesian.map p f φ ⋯ φ'')","decl":"/-- When its possible to compare the two, the composition of two `IsStronglyCartesian.map` will also\nbe given by a `IsStronglyCartesian.map`. In other words, given diagrams\n```\na''         a'        a --φ--> b\n|           |         |        |\nv           v         v        v\nR'' --g'--> R' --g--> R --f--> S\n```\nand\n```\na' --φ'--> b\n|          |\nv          v\nR' --f'--> S\n```\nand\n```\na'' --φ''--> b\n|            |\nv            v\nR'' --f''--> S\n```\nsuch that `φ` and `φ'` are strongly cartesian morphisms, and such that `f' = g ≫ f` and\n`f'' = g' ≫ f'`. Then composing the induced map from `a'' ⟶ a'` with the induced map from\n`a' ⟶ a` gives the induced map from `a'' ⟶ a`. -/\n@[reassoc (attr := simp)]\nlemma map_comp_map {R' R'' : 𝒮} {a' a'' : 𝒳} {f' : R' ⟶ S} {f'' : R'' ⟶ S} {g : R' ⟶ R}\n    {g' : R'' ⟶ R'} (H : f' = g ≫ f) (H' : f'' = g' ≫ f') (φ' : a' ⟶ b) (φ'' : a'' ⟶ b)\n    [IsStronglyCartesian p f' φ'] [IsHomLift p f'' φ''] :\n    map p f' φ' H' φ'' ≫ map p f φ H φ' =\n      map p f φ (show f'' = (g' ≫ g) ≫ f by rwa [assoc, ← H]) φ'' := by\n  apply map_uniq p f φ\n  simp only [assoc, fac]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.map_comp_map_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝² : p.IsStronglyCartesian f φ\nR' R'' : 𝒮\na' a'' : 𝒳\nf' : Quiver.Hom R' S\nf'' : Quiver.Hom R'' S\ng : Quiver.Hom R' R\ng' : Quiver.Hom R'' R'\nH : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nH' : Eq f'' (CategoryTheory.CategoryStruct.comp g' f')\nφ' : Quiver.Hom a' b\nφ'' : Quiver.Hom a'' b\ninst✝¹ : p.IsStronglyCartesian f' φ'\ninst✝ : p.IsHomLift f'' φ''\nZ : 𝒳\nh : Quiver.Hom a Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCartesian.map p f' φ' H' φ'') (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCartesian.map p f φ H φ') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCartesian.map p f φ ⋯ φ'') h)","decl":"/-- When its possible to compare the two, the composition of two `IsStronglyCartesian.map` will also\nbe given by a `IsStronglyCartesian.map`. In other words, given diagrams\n```\na''         a'        a --φ--> b\n|           |         |        |\nv           v         v        v\nR'' --g'--> R' --g--> R --f--> S\n```\nand\n```\na' --φ'--> b\n|          |\nv          v\nR' --f'--> S\n```\nand\n```\na'' --φ''--> b\n|            |\nv            v\nR'' --f''--> S\n```\nsuch that `φ` and `φ'` are strongly cartesian morphisms, and such that `f' = g ≫ f` and\n`f'' = g' ≫ f'`. Then composing the induced map from `a'' ⟶ a'` with the induced map from\n`a' ⟶ a` gives the induced map from `a'' ⟶ a`. -/\n@[reassoc (attr := simp)]\nlemma map_comp_map {R' R'' : 𝒮} {a' a'' : 𝒳} {f' : R' ⟶ S} {f'' : R'' ⟶ S} {g : R' ⟶ R}\n    {g' : R'' ⟶ R'} (H : f' = g ≫ f) (H' : f'' = g' ≫ f') (φ' : a' ⟶ b) (φ'' : a'' ⟶ b)\n    [IsStronglyCartesian p f' φ'] [IsHomLift p f'' φ''] :\n    map p f' φ' H' φ'' ≫ map p f φ H φ' =\n      map p f φ (show f'' = (g' ≫ g) ≫ f by rwa [assoc, ← H]) φ'' := by\n  apply map_uniq p f φ\n  simp only [assoc, fac]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.comp","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S T : 𝒮\na b c : 𝒳\nf : Quiver.Hom R S\ng : Quiver.Hom S T\nφ : Quiver.Hom a b\nψ : Quiver.Hom b c\ninst✝¹ : p.IsStronglyCartesian f φ\ninst✝ : p.IsStronglyCartesian g ψ\n⊢ p.IsStronglyCartesian (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp φ ψ)","decl":"/-- Given two strongly cartesian morphisms `φ`, `ψ` as follows\n```\na --φ--> b --ψ--> c\n|        |        |\nv        v        v\nR --f--> S --g--> T\n```\nThen the composite `φ ≫ ψ` is also strongly cartesian. -/\ninstance comp [IsStronglyCartesian p f φ] [IsStronglyCartesian p g ψ] :\n    IsStronglyCartesian p (f ≫ g) (φ ≫ ψ) where\n  universal_property' := by\n    intro a' h τ hτ\n    use map p f φ (f' := h ≫ f) rfl (map p g ψ (assoc h f g).symm τ)\n    refine ⟨⟨inferInstance, ?_⟩, ?_⟩\n    · rw [← assoc, fac, fac]\n    · intro π' ⟨hπ'₁, hπ'₂⟩\n      apply map_uniq\n      apply map_uniq\n      simp only [assoc, hπ'₂]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.of_comp","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝³ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S T : 𝒮\na b c : 𝒳\nf : Quiver.Hom R S\ng : Quiver.Hom S T\nφ : Quiver.Hom a b\nψ : Quiver.Hom b c\ninst✝² : p.IsStronglyCartesian g ψ\ninst✝¹ : p.IsStronglyCartesian (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp φ ψ)\ninst✝ : p.IsHomLift f φ\n⊢ p.IsStronglyCartesian f φ","decl":"/-- Given two commutative squares\n```\na --φ--> b --ψ--> c\n|        |        |\nv        v        v\nR --f--> S --g--> T\n```\nsuch that `φ ≫ ψ` and `ψ` are strongly cartesian, then so is `φ`. -/\nprotected lemma of_comp [IsStronglyCartesian p g ψ] [IsStronglyCartesian p (f ≫ g) (φ ≫ ψ)]\n    [IsHomLift p f φ] : IsStronglyCartesian p f φ where\n  universal_property' := by\n    intro a' h τ hτ\n    have h₁ : IsHomLift p (h ≫ f ≫ g) (τ ≫ ψ) := by simpa using IsHomLift.comp p (h ≫ f) _ τ ψ\n    /- We get a morphism `π : a' ⟶ a` such that `π ≫ φ ≫ ψ = τ ≫ ψ` from the universal property\n    of `φ ≫ ψ`. This will be the morphism induced by `φ`. -/\n    use map p (f ≫ g) (φ ≫ ψ) (f' := h ≫ f ≫ g) rfl (τ ≫ ψ)\n    refine ⟨⟨inferInstance, ?_⟩, ?_⟩\n    /- The fact that `π ≫ φ = τ` follows from `π ≫ φ ≫ ψ = τ ≫ ψ` and the universal property of\n    `ψ`. -/\n    · apply IsStronglyCartesian.ext p g ψ (h ≫ f) (by simp)\n    -- Finally, the uniqueness of `π` comes from the universal property of `φ ≫ ψ`.\n    · intro π' ⟨hπ'₁, hπ'₂⟩\n      apply map_uniq\n      simp [hπ'₂.symm]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.of_iso","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : CategoryTheory.Iso a b\ninst✝ : p.IsHomLift f φ.hom\n⊢ p.IsStronglyCartesian f φ.hom","decl":"instance of_iso (φ : a ≅ b) [IsHomLift p f φ.hom] : IsStronglyCartesian p f φ.hom where\n  universal_property' := by\n    intro a' g τ hτ\n    use τ ≫ φ.inv\n    refine ⟨?_, by aesop_cat⟩\n    simpa using (IsHomLift.comp p (g ≫ f) (isoOfIsoLift p f φ).inv τ φ.inv)\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.of_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsHomLift f φ\ninst✝ : CategoryTheory.IsIso φ\n⊢ p.IsStronglyCartesian f φ","decl":"instance of_isIso (φ : a ⟶ b) [IsHomLift p f φ] [IsIso φ] : IsStronglyCartesian p f φ :=\n  @IsStronglyCartesian.of_iso _ _ _ _ p _ _ _ _ f (asIso φ) (by aesop)\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.isIso_of_base_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR S : 𝒮\na b : 𝒳\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝¹ : p.IsStronglyCartesian f φ\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.IsIso φ","decl":"/-- A strongly cartesian morphism lying over an isomorphism is an isomorphism. -/\nlemma isIso_of_base_isIso (φ : a ⟶ b) [IsStronglyCartesian p f φ] [IsIso f] : IsIso φ := by\n  subst_hom_lift p f φ; clear a b R S\n  -- Let `φ` be the morphism induced by applying universal property to `𝟙 b` lying over `f⁻¹ ≫ f`.\n  let φ' := map p (p.map φ) φ (IsIso.inv_hom_id (p.map φ)).symm (𝟙 b)\n  use φ'\n  -- `φ' ≫ φ = 𝟙 b` follows immediately from the universal property.\n  have inv_hom : φ' ≫ φ = 𝟙 b := fac p (p.map φ) φ _ (𝟙 b)\n  refine ⟨?_, inv_hom⟩\n  -- We will now show that `φ ≫ φ' = 𝟙 a` by showing that `(φ ≫ φ') ≫ φ = 𝟙 a ≫ φ`.\n  have h₁ : IsHomLift p (𝟙 (p.obj a)) (φ  ≫ φ') := by\n    rw [← IsIso.hom_inv_id (p.map φ)]\n    apply IsHomLift.comp\n  apply IsStronglyCartesian.ext p (p.map φ) φ (𝟙 (p.obj a))\n  simp only [assoc, inv_hom, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.domainIsoOfBaseIso_hom","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR R' S : 𝒮\na a' b : 𝒳\nf : Quiver.Hom R S\nf' : Quiver.Hom R' S\ng : CategoryTheory.Iso R' R\nh : Eq f' (CategoryTheory.CategoryStruct.comp g.hom f)\nφ : Quiver.Hom a b\nφ' : Quiver.Hom a' b\ninst✝¹ : p.IsStronglyCartesian f φ\ninst✝ : p.IsStronglyCartesian f' φ'\n⊢ Eq (CategoryTheory.Functor.IsStronglyCartesian.domainIsoOfBaseIso p h φ φ').hom (CategoryTheory.Functor.IsStronglyCartesian.map p f φ h φ')","decl":"/-- The canonical isomorphism between the domains of two strongly cartesian morphisms lying over\nisomorphic objects. -/\n@[simps]\nnoncomputable def domainIsoOfBaseIso (h : f' = g.hom ≫ f) (φ : a ⟶ b) (φ' : a' ⟶ b)\n    [IsStronglyCartesian p f φ] [IsStronglyCartesian p f' φ'] : a' ≅ a where\n  hom := map p f φ h φ'\n  inv :=\n    haveI : p.IsHomLift ((fun x ↦ g.inv ≫ x) (g.hom ≫ f)) φ := by\n      simpa using IsCartesian.toIsHomLift\n    map p f' φ' (congrArg (g.inv ≫ ·) h.symm) φ\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.domainIsoOfBaseIso_inv","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR R' S : 𝒮\na a' b : 𝒳\nf : Quiver.Hom R S\nf' : Quiver.Hom R' S\ng : CategoryTheory.Iso R' R\nh : Eq f' (CategoryTheory.CategoryStruct.comp g.hom f)\nφ : Quiver.Hom a b\nφ' : Quiver.Hom a' b\ninst✝¹ : p.IsStronglyCartesian f φ\ninst✝ : p.IsStronglyCartesian f' φ'\n⊢ Eq (CategoryTheory.Functor.IsStronglyCartesian.domainIsoOfBaseIso p h φ φ').inv (CategoryTheory.Functor.IsStronglyCartesian.map p f' φ' ⋯ φ)","decl":"/-- The canonical isomorphism between the domains of two strongly cartesian morphisms lying over\nisomorphic objects. -/\n@[simps]\nnoncomputable def domainIsoOfBaseIso (h : f' = g.hom ≫ f) (φ : a ⟶ b) (φ' : a' ⟶ b)\n    [IsStronglyCartesian p f φ] [IsStronglyCartesian p f' φ'] : a' ≅ a where\n  hom := map p f φ h φ'\n  inv :=\n    haveI : p.IsHomLift ((fun x ↦ g.inv ≫ x) (g.hom ≫ f)) φ := by\n      simpa using IsCartesian.toIsHomLift\n    map p f' φ' (congrArg (g.inv ≫ ·) h.symm) φ\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.domainUniqueUpToIso_inv_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR R' S : 𝒮\na a' b : 𝒳\nf : Quiver.Hom R S\nf' : Quiver.Hom R' S\ng : CategoryTheory.Iso R' R\nh : Eq f' (CategoryTheory.CategoryStruct.comp g.hom f)\nφ : Quiver.Hom a b\nφ' : Quiver.Hom a' b\ninst✝¹ : p.IsStronglyCartesian f φ\ninst✝ : p.IsStronglyCartesian f' φ'\n⊢ p.IsHomLift g.hom (CategoryTheory.Functor.IsStronglyCartesian.domainIsoOfBaseIso p h φ φ').hom","decl":"instance domainUniqueUpToIso_inv_isHomLift (h : f' = g.hom ≫ f) (φ : a ⟶ b) (φ' : a' ⟶ b)\n    [IsStronglyCartesian p f φ] [IsStronglyCartesian p f' φ'] :\n    IsHomLift p g.hom (domainIsoOfBaseIso p h φ φ').hom :=\n  domainIsoOfBaseIso_hom p h φ φ' ▸ IsStronglyCartesian.map_isHomLift p f φ h φ'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.domainUniqueUpToIso_hom_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"𝒮 : Type u₁\n𝒳 : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝² : CategoryTheory.Category.{v₂, u₂} 𝒳\np : CategoryTheory.Functor 𝒳 𝒮\nR R' S : 𝒮\na a' b : 𝒳\nf : Quiver.Hom R S\nf' : Quiver.Hom R' S\ng : CategoryTheory.Iso R' R\nh : Eq f' (CategoryTheory.CategoryStruct.comp g.hom f)\nφ : Quiver.Hom a b\nφ' : Quiver.Hom a' b\ninst✝¹ : p.IsStronglyCartesian f φ\ninst✝ : p.IsStronglyCartesian f' φ'\n⊢ p.IsHomLift g.inv (CategoryTheory.Functor.IsStronglyCartesian.domainIsoOfBaseIso p h φ φ').inv","decl":"instance domainUniqueUpToIso_hom_isHomLift (h : f' = g.hom ≫ f) (φ : a ⟶ b) (φ' : a' ⟶ b)\n    [IsStronglyCartesian p f φ] [IsStronglyCartesian p f' φ'] :\n    IsHomLift p g.inv (domainIsoOfBaseIso p h φ φ').inv := by\n  haveI : p.IsHomLift ((fun x ↦ g.inv ≫ x) (g.hom ≫ f)) φ := by\n    simpa using IsCartesian.toIsHomLift\n  simpa using IsStronglyCartesian.map_isHomLift p f' φ' (congrArg (g.inv ≫ ·) h.symm) φ\n\n"}
