{"name":"CategoryTheory.Functor.IsCartesian.universal_property","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nself : p.IsCartesian f Ï†\na' : ğ’³\nÏ†' : Quiver.Hom a' b\ninstâœ : p.IsHomLift f Ï†'\nâŠ¢ ExistsUnique fun Ï‡ => And (p.IsHomLift (CategoryTheory.CategoryStruct.id R) Ï‡) (Eq (CategoryTheory.CategoryStruct.comp Ï‡ Ï†) Ï†')","decl":"/-- A morphism `Ï† : a âŸ¶ b` in `ğ’³` lying over `f : R âŸ¶ S` in `ğ’®` is cartesian if for all\nmorphisms `Ï†' : a' âŸ¶ b`, also lying over `f`, there exists a unique morphism `Ï‡ : a' âŸ¶ a` lifting\n`ğŸ™ R` such that `Ï†' = Ï‡ â‰« Ï†`.\n\nSee SGA 1 VI 5.1. -/\nclass IsCartesian extends IsHomLift p f Ï† : Prop where\n  universal_property {a' : ğ’³} (Ï†' : a' âŸ¶ b) [IsHomLift p f Ï†'] :\n      âˆƒ! Ï‡ : a' âŸ¶ a, IsHomLift p (ğŸ™ R) Ï‡ âˆ§ Ï‡ â‰« Ï† = Ï†'\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.toIsHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nself : p.IsCartesian f Ï†\nâŠ¢ p.IsHomLift f Ï†","decl":"/-- A morphism `Ï† : a âŸ¶ b` in `ğ’³` lying over `f : R âŸ¶ S` in `ğ’®` is cartesian if for all\nmorphisms `Ï†' : a' âŸ¶ b`, also lying over `f`, there exists a unique morphism `Ï‡ : a' âŸ¶ a` lifting\n`ğŸ™ R` such that `Ï†' = Ï‡ â‰« Ï†`.\n\nSee SGA 1 VI 5.1. -/\nclass IsCartesian extends IsHomLift p f Ï† : Prop where\n  universal_property {a' : ğ’³} (Ï†' : a' âŸ¶ b) [IsHomLift p f Ï†'] :\n      âˆƒ! Ï‡ : a' âŸ¶ a, IsHomLift p (ğŸ™ R) Ï‡ âˆ§ Ï‡ â‰« Ï† = Ï†'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.universal_property'","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nself : p.IsStronglyCartesian f Ï†\na' : ğ’³\ng : Quiver.Hom (p.obj a') R\nÏ†' : Quiver.Hom a' b\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.comp g f) Ï†'\nâŠ¢ ExistsUnique fun Ï‡ => And (p.IsHomLift g Ï‡) (Eq (CategoryTheory.CategoryStruct.comp Ï‡ Ï†) Ï†')","decl":"/-- A morphism `Ï† : a âŸ¶ b` in `ğ’³` lying over `f : R âŸ¶ S` in `ğ’®` is strongly cartesian if for\nall morphisms `Ï†' : a' âŸ¶ b` and all diagrams of the form\n```\na'        a --Ï†--> b\n|         |        |\nv         v        v\nR' --g--> R --f--> S\n```\nsuch that `Ï†'` lifts `g â‰« f`, there exists a lift `Ï‡` of `g` such that `Ï†' = Ï‡ â‰« Ï†`. -/\n@[stacks 02XK]\nclass IsStronglyCartesian extends IsHomLift p f Ï† : Prop where\n  universal_property' {a' : ğ’³} (g : p.obj a' âŸ¶ R) (Ï†' : a' âŸ¶ b) [IsHomLift p (g â‰« f) Ï†'] :\n      âˆƒ! Ï‡ : a' âŸ¶ a, IsHomLift p g Ï‡ âˆ§ Ï‡ â‰« Ï† = Ï†'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.toIsHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nself : p.IsStronglyCartesian f Ï†\nâŠ¢ p.IsHomLift f Ï†","decl":"/-- A morphism `Ï† : a âŸ¶ b` in `ğ’³` lying over `f : R âŸ¶ S` in `ğ’®` is strongly cartesian if for\nall morphisms `Ï†' : a' âŸ¶ b` and all diagrams of the form\n```\na'        a --Ï†--> b\n|         |        |\nv         v        v\nR' --g--> R --f--> S\n```\nsuch that `Ï†'` lifts `g â‰« f`, there exists a lift `Ï‡` of `g` such that `Ï†' = Ï‡ â‰« Ï†`. -/\n@[stacks 02XK]\nclass IsStronglyCartesian extends IsHomLift p f Ï† : Prop where\n  universal_property' {a' : ğ’³} (g : p.obj a' âŸ¶ R) (Ï†' : a' âŸ¶ b) [IsHomLift p (g â‰« f) Ï†'] :\n      âˆƒ! Ï‡ : a' âŸ¶ a, IsHomLift p g Ï‡ âˆ§ Ï‡ â‰« Ï† = Ï†'\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.map_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCartesian f Ï†\na' : ğ’³\nÏ†' : Quiver.Hom a' b\ninstâœ : p.IsHomLift f Ï†'\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.id R) (CategoryTheory.Functor.IsCartesian.map p f Ï† Ï†')","decl":"instance map_isHomLift : IsHomLift p (ğŸ™ R) (IsCartesian.map p f Ï† Ï†') :=\n  (Classical.choose_spec <| IsCartesian.universal_property (p := p) (f := f) (Ï† := Ï†) Ï†').1.1\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.fac","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCartesian f Ï†\na' : ğ’³\nÏ†' : Quiver.Hom a' b\ninstâœ : p.IsHomLift f Ï†'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsCartesian.map p f Ï† Ï†') Ï†) Ï†'","decl":"@[reassoc (attr := simp)]\nlemma fac : IsCartesian.map p f Ï† Ï†' â‰« Ï† = Ï†' :=\n  (Classical.choose_spec <| IsCartesian.universal_property (p := p) (f := f) (Ï† := Ï†) Ï†').1.2\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.fac_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCartesian f Ï†\na' : ğ’³\nÏ†' : Quiver.Hom a' b\ninstâœ : p.IsHomLift f Ï†'\nZ : ğ’³\nh : Quiver.Hom b Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsCartesian.map p f Ï† Ï†') (CategoryTheory.CategoryStruct.comp Ï† h)) (CategoryTheory.CategoryStruct.comp Ï†' h)","decl":"@[reassoc (attr := simp)]\nlemma fac : IsCartesian.map p f Ï† Ï†' â‰« Ï† = Ï†' :=\n  (Classical.choose_spec <| IsCartesian.universal_property (p := p) (f := f) (Ï† := Ï†) Ï†').1.2\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.map_uniq","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ² : p.IsCartesian f Ï†\na' : ğ’³\nÏ†' : Quiver.Hom a' b\ninstâœÂ¹ : p.IsHomLift f Ï†'\nÏˆ : Quiver.Hom a' a\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) Ïˆ\nhÏˆ : Eq (CategoryTheory.CategoryStruct.comp Ïˆ Ï†) Ï†'\nâŠ¢ Eq Ïˆ (CategoryTheory.Functor.IsCartesian.map p f Ï† Ï†')","decl":"/-- Given a cartesian morphism `Ï† : a âŸ¶ b` lying over `f : R âŸ¶ S` in `ğ’³`, and another morphism\n`Ï†' : a' âŸ¶ b` which also lifts `f`. Then any morphism `Ïˆ : a' âŸ¶ a` lifting `ğŸ™ R` such that\n`g â‰« Ïˆ = Ï†'` must equal the map induced from the universal property of `Ï†`. -/\nlemma map_uniq (Ïˆ : a' âŸ¶ a) [IsHomLift p (ğŸ™ R) Ïˆ] (hÏˆ : Ïˆ â‰« Ï† = Ï†') :\n    Ïˆ = IsCartesian.map p f Ï† Ï†' :=\n  (Classical.choose_spec <| IsCartesian.universal_property (p := p) (f := f) (Ï† := Ï†) Ï†').2\n    Ïˆ âŸ¨inferInstance, hÏˆâŸ©\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.ext","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ² : p.IsCartesian f Ï†\na' : ğ’³\nÏˆ Ïˆ' : Quiver.Hom a' a\ninstâœÂ¹ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) Ïˆ\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) Ïˆ'\nh : Eq (CategoryTheory.CategoryStruct.comp Ïˆ Ï†) (CategoryTheory.CategoryStruct.comp Ïˆ' Ï†)\nâŠ¢ Eq Ïˆ Ïˆ'","decl":"/-- Given a cartesian morphism `Ï† : a âŸ¶ b` lying over `f : R âŸ¶ S` in `ğ’³`, and two morphisms\n`Ïˆ Ïˆ' : a' âŸ¶ a` such that `Ïˆ â‰« Ï† = Ïˆ' â‰« Ï†`. Then we must have `Ïˆ = Ïˆ'`. -/\nprotected lemma ext (Ï† : a âŸ¶ b) [IsCartesian p f Ï†] {a' : ğ’³} (Ïˆ Ïˆ' : a' âŸ¶ a)\n    [IsHomLift p (ğŸ™ R) Ïˆ] [IsHomLift p (ğŸ™ R) Ïˆ'] (h : Ïˆ â‰« Ï† = Ïˆ' â‰« Ï†) : Ïˆ = Ïˆ' := by\n  rw [map_uniq p f Ï† (Ïˆ â‰« Ï†) Ïˆ rfl, map_uniq p f Ï† (Ïˆ â‰« Ï†) Ïˆ' h.symm]\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.map_self","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœ : p.IsCartesian f Ï†\nâŠ¢ Eq (CategoryTheory.Functor.IsCartesian.map p f Ï† Ï†) (CategoryTheory.CategoryStruct.id a)","decl":"@[simp]\nlemma map_self : IsCartesian.map p f Ï† Ï† = ğŸ™ a := by\n  subst_hom_lift p f Ï†; symm\n  apply map_uniq\n  simp only [id_comp]\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso_hom","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCartesian f Ï†\na' : ğ’³\nÏ†' : Quiver.Hom a' b\ninstâœ : p.IsCartesian f Ï†'\nâŠ¢ Eq (CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso p f Ï† Ï†').hom (CategoryTheory.Functor.IsCartesian.map p f Ï† Ï†')","decl":"/-- The canonical isomorphism between the domains of two cartesian morphisms\nlying over the same object. -/\n@[simps]\nnoncomputable def domainUniqueUpToIso {a' : ğ’³} (Ï†' : a' âŸ¶ b) [IsCartesian p f Ï†'] : a' â‰… a where\n  hom := IsCartesian.map p f Ï† Ï†'\n  inv := IsCartesian.map p f Ï†' Ï†\n  hom_inv_id := by\n    subst_hom_lift p f Ï†'\n    apply IsCartesian.ext p (p.map Ï†') Ï†'\n    simp only [assoc, fac, id_comp]\n  inv_hom_id := by\n    subst_hom_lift p f Ï†\n    apply IsCartesian.ext p (p.map Ï†) Ï†\n    simp only [assoc, fac, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso_inv","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCartesian f Ï†\na' : ğ’³\nÏ†' : Quiver.Hom a' b\ninstâœ : p.IsCartesian f Ï†'\nâŠ¢ Eq (CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso p f Ï† Ï†').inv (CategoryTheory.Functor.IsCartesian.map p f Ï†' Ï†)","decl":"/-- The canonical isomorphism between the domains of two cartesian morphisms\nlying over the same object. -/\n@[simps]\nnoncomputable def domainUniqueUpToIso {a' : ğ’³} (Ï†' : a' âŸ¶ b) [IsCartesian p f Ï†'] : a' â‰… a where\n  hom := IsCartesian.map p f Ï† Ï†'\n  inv := IsCartesian.map p f Ï†' Ï†\n  hom_inv_id := by\n    subst_hom_lift p f Ï†'\n    apply IsCartesian.ext p (p.map Ï†') Ï†'\n    simp only [assoc, fac, id_comp]\n  inv_hom_id := by\n    subst_hom_lift p f Ï†\n    apply IsCartesian.ext p (p.map Ï†) Ï†\n    simp only [assoc, fac, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso_inv_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCartesian f Ï†\na' : ğ’³\nÏ†' : Quiver.Hom a' b\ninstâœ : p.IsCartesian f Ï†'\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.id R) (CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso p f Ï† Ï†').hom","decl":"instance domainUniqueUpToIso_inv_isHomLift {a' : ğ’³} (Ï†' : a' âŸ¶ b) [IsCartesian p f Ï†'] :\n    IsHomLift p (ğŸ™ R) (domainUniqueUpToIso p f Ï† Ï†').hom :=\n  domainUniqueUpToIso_hom p f Ï† Ï†' â–¸ IsCartesian.map_isHomLift p f Ï† Ï†'\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso_hom_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCartesian f Ï†\na' : ğ’³\nÏ†' : Quiver.Hom a' b\ninstâœ : p.IsCartesian f Ï†'\nâŠ¢ p.IsHomLift (CategoryTheory.CategoryStruct.id R) (CategoryTheory.Functor.IsCartesian.domainUniqueUpToIso p f Ï† Ï†').inv","decl":"instance domainUniqueUpToIso_hom_isHomLift {a' : ğ’³} (Ï†' : a' âŸ¶ b) [IsCartesian p f Ï†'] :\n    IsHomLift p (ğŸ™ R) (domainUniqueUpToIso p f Ï† Ï†').inv :=\n  domainUniqueUpToIso_inv p f Ï† Ï†' â–¸ IsCartesian.map_isHomLift p f Ï†' Ï†\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.of_iso_comp","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCartesian f Ï†\na' : ğ’³\nÏ†' : CategoryTheory.Iso a' a\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id R) Ï†'.hom\nâŠ¢ p.IsCartesian f (CategoryTheory.CategoryStruct.comp Ï†'.hom Ï†)","decl":"/-- Precomposing a cartesian morphism with an isomorphism lifting the identity is cartesian. -/\ninstance of_iso_comp {a' : ğ’³} (Ï†' : a' â‰… a) [IsHomLift p (ğŸ™ R) Ï†'.hom] :\n    IsCartesian p f (Ï†'.hom â‰« Ï†) where\n  universal_property := by\n    intro c Ïˆ hÏˆ\n    use IsCartesian.map p f Ï† Ïˆ â‰« Ï†'.inv\n    refine âŸ¨âŸ¨inferInstance, by simpâŸ©, ?_âŸ©\n    rintro Ï„ âŸ¨hÏ„â‚, hÏ„â‚‚âŸ©\n    rw [Iso.eq_comp_inv]\n    apply map_uniq\n    simp only [assoc, hÏ„â‚‚]\n\n"}
{"name":"CategoryTheory.Functor.IsCartesian.of_comp_iso","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsCartesian f Ï†\nb' : ğ’³\nÏ†' : CategoryTheory.Iso b b'\ninstâœ : p.IsHomLift (CategoryTheory.CategoryStruct.id S) Ï†'.hom\nâŠ¢ p.IsCartesian f (CategoryTheory.CategoryStruct.comp Ï† Ï†'.hom)","decl":"/-- Postcomposing a cartesian morphism with an isomorphism lifting the identity is cartesian. -/\ninstance of_comp_iso {b' : ğ’³} (Ï†' : b â‰… b') [IsHomLift p (ğŸ™ S) Ï†'.hom] :\n    IsCartesian p f (Ï† â‰« Ï†'.hom) where\n  universal_property := by\n    intro c Ïˆ hÏˆ\n    use IsCartesian.map p f Ï† (Ïˆ â‰« Ï†'.inv)\n    refine âŸ¨âŸ¨inferInstance, by simpâŸ©, ?_âŸ©\n    rintro Ï„ âŸ¨hÏ„â‚, hÏ„â‚‚âŸ©\n    apply map_uniq\n    simp only [Iso.eq_comp_inv, assoc, hÏ„â‚‚]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.universal_property","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsStronglyCartesian f Ï†\nR' : ğ’®\na' : ğ’³\ng : Quiver.Hom R' R\nf' : Quiver.Hom R' S\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nÏ†' : Quiver.Hom a' b\ninstâœ : p.IsHomLift f' Ï†'\nâŠ¢ ExistsUnique fun Ï‡ => And (p.IsHomLift g Ï‡) (Eq (CategoryTheory.CategoryStruct.comp Ï‡ Ï†) Ï†')","decl":"/-- The universal property of a strongly cartesian morphism.\n\nThis lemma is more flexible with respect to non-definitional equalities than the field\n`universal_property'` of `IsStronglyCartesian`. -/\nlemma universal_property {R' : ğ’®} {a' : ğ’³} (g : R' âŸ¶ R) (f' : R' âŸ¶ S) (hf' : f' = g â‰« f)\n    (Ï†' : a' âŸ¶ b) [IsHomLift p f' Ï†'] : âˆƒ! Ï‡ : a' âŸ¶ a, IsHomLift p g Ï‡ âˆ§ Ï‡ â‰« Ï† = Ï†' := by\n  subst_hom_lift p f' Ï†'; clear a b R S\n  have : p.IsHomLift (g â‰« f) Ï†' := (hf' â–¸ inferInstance)\n  apply IsStronglyCartesian.universal_property' f\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.isCartesian_of_isStronglyCartesian","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœ : p.IsStronglyCartesian f Ï†\nâŠ¢ p.IsCartesian f Ï†","decl":"instance isCartesian_of_isStronglyCartesian [p.IsStronglyCartesian f Ï†] : p.IsCartesian f Ï† where\n  universal_property := fun Ï†' => universal_property p f Ï† (ğŸ™ R) f (by simp) Ï†'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.map_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsStronglyCartesian f Ï†\nR' : ğ’®\na' : ğ’³\ng : Quiver.Hom R' R\nf' : Quiver.Hom R' S\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nÏ†' : Quiver.Hom a' b\ninstâœ : p.IsHomLift f' Ï†'\nâŠ¢ p.IsHomLift g (CategoryTheory.Functor.IsStronglyCartesian.map p f Ï† hf' Ï†')","decl":"instance map_isHomLift : IsHomLift p g (map p f Ï† hf' Ï†') :=\n  (Classical.choose_spec <| universal_property p f Ï† _ _ hf' Ï†').1.1\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.fac","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsStronglyCartesian f Ï†\nR' : ğ’®\na' : ğ’³\ng : Quiver.Hom R' R\nf' : Quiver.Hom R' S\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nÏ†' : Quiver.Hom a' b\ninstâœ : p.IsHomLift f' Ï†'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCartesian.map p f Ï† hf' Ï†') Ï†) Ï†'","decl":"@[reassoc (attr := simp)]\nlemma fac : (map p f Ï† hf' Ï†') â‰« Ï† = Ï†' :=\n  (Classical.choose_spec <| universal_property p f Ï† _ _ hf' Ï†').1.2\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.fac_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsStronglyCartesian f Ï†\nR' : ğ’®\na' : ğ’³\ng : Quiver.Hom R' R\nf' : Quiver.Hom R' S\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nÏ†' : Quiver.Hom a' b\ninstâœ : p.IsHomLift f' Ï†'\nZ : ğ’³\nh : Quiver.Hom b Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCartesian.map p f Ï† hf' Ï†') (CategoryTheory.CategoryStruct.comp Ï† h)) (CategoryTheory.CategoryStruct.comp Ï†' h)","decl":"@[reassoc (attr := simp)]\nlemma fac : (map p f Ï† hf' Ï†') â‰« Ï† = Ï†' :=\n  (Classical.choose_spec <| universal_property p f Ï† _ _ hf' Ï†').1.2\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.map_uniq","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ² : p.IsStronglyCartesian f Ï†\nR' : ğ’®\na' : ğ’³\ng : Quiver.Hom R' R\nf' : Quiver.Hom R' S\nhf' : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nÏ†' : Quiver.Hom a' b\ninstâœÂ¹ : p.IsHomLift f' Ï†'\nÏˆ : Quiver.Hom a' a\ninstâœ : p.IsHomLift g Ïˆ\nhÏˆ : Eq (CategoryTheory.CategoryStruct.comp Ïˆ Ï†) Ï†'\nâŠ¢ Eq Ïˆ (CategoryTheory.Functor.IsStronglyCartesian.map p f Ï† hf' Ï†')","decl":"/-- Given a diagram\n```\na'        a --Ï†--> b\n|         |        |\nv         v        v\nR' --g--> R --f--> S\n```\nsuch that `Ï†` is strongly cartesian, and morphisms `Ï†' : a' âŸ¶ b`, `Ïˆ : a' âŸ¶ a` such that\n`Ïˆ â‰« Ï† = Ï†'`. Then `Ïˆ` is the map induced by the universal property. -/\nlemma map_uniq (Ïˆ : a' âŸ¶ a) [IsHomLift p g Ïˆ] (hÏˆ : Ïˆ â‰« Ï† = Ï†') : Ïˆ = map p f Ï† hf' Ï†' :=\n  (Classical.choose_spec <| universal_property p f Ï† _ _ hf' Ï†').2 Ïˆ âŸ¨inferInstance, hÏˆâŸ©\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.ext","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ² : p.IsStronglyCartesian f Ï†\nR' : ğ’®\na' : ğ’³\ng : Quiver.Hom R' R\nÏˆ Ïˆ' : Quiver.Hom a' a\ninstâœÂ¹ : p.IsHomLift g Ïˆ\ninstâœ : p.IsHomLift g Ïˆ'\nh : Eq (CategoryTheory.CategoryStruct.comp Ïˆ Ï†) (CategoryTheory.CategoryStruct.comp Ïˆ' Ï†)\nâŠ¢ Eq Ïˆ Ïˆ'","decl":"/-- Given a diagram\n```\na'        a --Ï†--> b\n|         |        |\nv         v        v\nR' --g--> R --f--> S\n```\nsuch that `Ï†` is strongly cartesian, and morphisms `Ïˆ Ïˆ' : a' âŸ¶ a` such that\n`g â‰« Ïˆ = Ï†' = g â‰« Ïˆ'`. Then we have that `Ïˆ = Ïˆ'`. -/\nprotected lemma ext (Ï† : a âŸ¶ b) [IsStronglyCartesian p f Ï†] {R' : ğ’®} {a' : ğ’³} (g : R' âŸ¶ R)\n    {Ïˆ Ïˆ' : a' âŸ¶ a} [IsHomLift p g Ïˆ] [IsHomLift p g Ïˆ'] (h : Ïˆ â‰« Ï† = Ïˆ' â‰« Ï†) : Ïˆ = Ïˆ' := by\n  rw [map_uniq p f Ï† (g := g) rfl (Ïˆ â‰« Ï†) Ïˆ rfl, map_uniq p f Ï† (g := g) rfl (Ïˆ â‰« Ï†) Ïˆ' h.symm]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.map_self","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœ : p.IsStronglyCartesian f Ï†\nâŠ¢ Eq (CategoryTheory.Functor.IsStronglyCartesian.map p f Ï† â‹¯ Ï†) (CategoryTheory.CategoryStruct.id a)","decl":"@[simp]\nlemma map_self : map p f Ï† (id_comp f).symm Ï† = ğŸ™ a := by\n  subst_hom_lift p f Ï†; symm\n  apply map_uniq\n  simp only [id_comp]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.map_comp_map","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ² : p.IsStronglyCartesian f Ï†\nR' R'' : ğ’®\na' a'' : ğ’³\nf' : Quiver.Hom R' S\nf'' : Quiver.Hom R'' S\ng : Quiver.Hom R' R\ng' : Quiver.Hom R'' R'\nH : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nH' : Eq f'' (CategoryTheory.CategoryStruct.comp g' f')\nÏ†' : Quiver.Hom a' b\nÏ†'' : Quiver.Hom a'' b\ninstâœÂ¹ : p.IsStronglyCartesian f' Ï†'\ninstâœ : p.IsHomLift f'' Ï†''\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCartesian.map p f' Ï†' H' Ï†'') (CategoryTheory.Functor.IsStronglyCartesian.map p f Ï† H Ï†')) (CategoryTheory.Functor.IsStronglyCartesian.map p f Ï† â‹¯ Ï†'')","decl":"/-- When its possible to compare the two, the composition of two `IsStronglyCartesian.map` will also\nbe given by a `IsStronglyCartesian.map`. In other words, given diagrams\n```\na''         a'        a --Ï†--> b\n|           |         |        |\nv           v         v        v\nR'' --g'--> R' --g--> R --f--> S\n```\nand\n```\na' --Ï†'--> b\n|          |\nv          v\nR' --f'--> S\n```\nand\n```\na'' --Ï†''--> b\n|            |\nv            v\nR'' --f''--> S\n```\nsuch that `Ï†` and `Ï†'` are strongly cartesian morphisms, and such that `f' = g â‰« f` and\n`f'' = g' â‰« f'`. Then composing the induced map from `a'' âŸ¶ a'` with the induced map from\n`a' âŸ¶ a` gives the induced map from `a'' âŸ¶ a`. -/\n@[reassoc (attr := simp)]\nlemma map_comp_map {R' R'' : ğ’®} {a' a'' : ğ’³} {f' : R' âŸ¶ S} {f'' : R'' âŸ¶ S} {g : R' âŸ¶ R}\n    {g' : R'' âŸ¶ R'} (H : f' = g â‰« f) (H' : f'' = g' â‰« f') (Ï†' : a' âŸ¶ b) (Ï†'' : a'' âŸ¶ b)\n    [IsStronglyCartesian p f' Ï†'] [IsHomLift p f'' Ï†''] :\n    map p f' Ï†' H' Ï†'' â‰« map p f Ï† H Ï†' =\n      map p f Ï† (show f'' = (g' â‰« g) â‰« f by rwa [assoc, â† H]) Ï†'' := by\n  apply map_uniq p f Ï†\n  simp only [assoc, fac]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.map_comp_map_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ² : p.IsStronglyCartesian f Ï†\nR' R'' : ğ’®\na' a'' : ğ’³\nf' : Quiver.Hom R' S\nf'' : Quiver.Hom R'' S\ng : Quiver.Hom R' R\ng' : Quiver.Hom R'' R'\nH : Eq f' (CategoryTheory.CategoryStruct.comp g f)\nH' : Eq f'' (CategoryTheory.CategoryStruct.comp g' f')\nÏ†' : Quiver.Hom a' b\nÏ†'' : Quiver.Hom a'' b\ninstâœÂ¹ : p.IsStronglyCartesian f' Ï†'\ninstâœ : p.IsHomLift f'' Ï†''\nZ : ğ’³\nh : Quiver.Hom a Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCartesian.map p f' Ï†' H' Ï†'') (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCartesian.map p f Ï† H Ï†') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsStronglyCartesian.map p f Ï† â‹¯ Ï†'') h)","decl":"/-- When its possible to compare the two, the composition of two `IsStronglyCartesian.map` will also\nbe given by a `IsStronglyCartesian.map`. In other words, given diagrams\n```\na''         a'        a --Ï†--> b\n|           |         |        |\nv           v         v        v\nR'' --g'--> R' --g--> R --f--> S\n```\nand\n```\na' --Ï†'--> b\n|          |\nv          v\nR' --f'--> S\n```\nand\n```\na'' --Ï†''--> b\n|            |\nv            v\nR'' --f''--> S\n```\nsuch that `Ï†` and `Ï†'` are strongly cartesian morphisms, and such that `f' = g â‰« f` and\n`f'' = g' â‰« f'`. Then composing the induced map from `a'' âŸ¶ a'` with the induced map from\n`a' âŸ¶ a` gives the induced map from `a'' âŸ¶ a`. -/\n@[reassoc (attr := simp)]\nlemma map_comp_map {R' R'' : ğ’®} {a' a'' : ğ’³} {f' : R' âŸ¶ S} {f'' : R'' âŸ¶ S} {g : R' âŸ¶ R}\n    {g' : R'' âŸ¶ R'} (H : f' = g â‰« f) (H' : f'' = g' â‰« f') (Ï†' : a' âŸ¶ b) (Ï†'' : a'' âŸ¶ b)\n    [IsStronglyCartesian p f' Ï†'] [IsHomLift p f'' Ï†''] :\n    map p f' Ï†' H' Ï†'' â‰« map p f Ï† H Ï†' =\n      map p f Ï† (show f'' = (g' â‰« g) â‰« f by rwa [assoc, â† H]) Ï†'' := by\n  apply map_uniq p f Ï†\n  simp only [assoc, fac]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.comp","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S T : ğ’®\na b c : ğ’³\nf : Quiver.Hom R S\ng : Quiver.Hom S T\nÏ† : Quiver.Hom a b\nÏˆ : Quiver.Hom b c\ninstâœÂ¹ : p.IsStronglyCartesian f Ï†\ninstâœ : p.IsStronglyCartesian g Ïˆ\nâŠ¢ p.IsStronglyCartesian (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)","decl":"/-- Given two strongly cartesian morphisms `Ï†`, `Ïˆ` as follows\n```\na --Ï†--> b --Ïˆ--> c\n|        |        |\nv        v        v\nR --f--> S --g--> T\n```\nThen the composite `Ï† â‰« Ïˆ` is also strongly cartesian. -/\ninstance comp [IsStronglyCartesian p f Ï†] [IsStronglyCartesian p g Ïˆ] :\n    IsStronglyCartesian p (f â‰« g) (Ï† â‰« Ïˆ) where\n  universal_property' := by\n    intro a' h Ï„ hÏ„\n    use map p f Ï† (f' := h â‰« f) rfl (map p g Ïˆ (assoc h f g).symm Ï„)\n    refine âŸ¨âŸ¨inferInstance, ?_âŸ©, ?_âŸ©\n    Â· rw [â† assoc, fac, fac]\n    Â· intro Ï€' âŸ¨hÏ€'â‚, hÏ€'â‚‚âŸ©\n      apply map_uniq\n      apply map_uniq\n      simp only [assoc, hÏ€'â‚‚]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.of_comp","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S T : ğ’®\na b c : ğ’³\nf : Quiver.Hom R S\ng : Quiver.Hom S T\nÏ† : Quiver.Hom a b\nÏˆ : Quiver.Hom b c\ninstâœÂ² : p.IsStronglyCartesian g Ïˆ\ninstâœÂ¹ : p.IsStronglyCartesian (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)\ninstâœ : p.IsHomLift f Ï†\nâŠ¢ p.IsStronglyCartesian f Ï†","decl":"/-- Given two commutative squares\n```\na --Ï†--> b --Ïˆ--> c\n|        |        |\nv        v        v\nR --f--> S --g--> T\n```\nsuch that `Ï† â‰« Ïˆ` and `Ïˆ` are strongly cartesian, then so is `Ï†`. -/\nprotected lemma of_comp [IsStronglyCartesian p g Ïˆ] [IsStronglyCartesian p (f â‰« g) (Ï† â‰« Ïˆ)]\n    [IsHomLift p f Ï†] : IsStronglyCartesian p f Ï† where\n  universal_property' := by\n    intro a' h Ï„ hÏ„\n    have hâ‚ : IsHomLift p (h â‰« f â‰« g) (Ï„ â‰« Ïˆ) := by simpa using IsHomLift.comp p (h â‰« f) _ Ï„ Ïˆ\n    /- We get a morphism `Ï€ : a' âŸ¶ a` such that `Ï€ â‰« Ï† â‰« Ïˆ = Ï„ â‰« Ïˆ` from the universal property\n    of `Ï† â‰« Ïˆ`. This will be the morphism induced by `Ï†`. -/\n    use map p (f â‰« g) (Ï† â‰« Ïˆ) (f' := h â‰« f â‰« g) rfl (Ï„ â‰« Ïˆ)\n    refine âŸ¨âŸ¨inferInstance, ?_âŸ©, ?_âŸ©\n    /- The fact that `Ï€ â‰« Ï† = Ï„` follows from `Ï€ â‰« Ï† â‰« Ïˆ = Ï„ â‰« Ïˆ` and the universal property of\n    `Ïˆ`. -/\n    Â· apply IsStronglyCartesian.ext p g Ïˆ (h â‰« f) (by simp)\n    -- Finally, the uniqueness of `Ï€` comes from the universal property of `Ï† â‰« Ïˆ`.\n    Â· intro Ï€' âŸ¨hÏ€'â‚, hÏ€'â‚‚âŸ©\n      apply map_uniq\n      simp [hÏ€'â‚‚.symm]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.of_iso","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : CategoryTheory.Iso a b\ninstâœ : p.IsHomLift f Ï†.hom\nâŠ¢ p.IsStronglyCartesian f Ï†.hom","decl":"instance of_iso (Ï† : a â‰… b) [IsHomLift p f Ï†.hom] : IsStronglyCartesian p f Ï†.hom where\n  universal_property' := by\n    intro a' g Ï„ hÏ„\n    use Ï„ â‰« Ï†.inv\n    refine âŸ¨?_, by aesop_catâŸ©\n    simpa using (IsHomLift.comp p (g â‰« f) (isoOfIsoLift p f Ï†).inv Ï„ Ï†.inv)\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.of_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsHomLift f Ï†\ninstâœ : CategoryTheory.IsIso Ï†\nâŠ¢ p.IsStronglyCartesian f Ï†","decl":"instance of_isIso (Ï† : a âŸ¶ b) [IsHomLift p f Ï†] [IsIso Ï†] : IsStronglyCartesian p f Ï† :=\n  @IsStronglyCartesian.of_iso _ _ _ _ p _ _ _ _ f (asIso Ï†) (by aesop)\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.isIso_of_base_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR S : ğ’®\na b : ğ’³\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœÂ¹ : p.IsStronglyCartesian f Ï†\ninstâœ : CategoryTheory.IsIso f\nâŠ¢ CategoryTheory.IsIso Ï†","decl":"/-- A strongly cartesian morphism lying over an isomorphism is an isomorphism. -/\nlemma isIso_of_base_isIso (Ï† : a âŸ¶ b) [IsStronglyCartesian p f Ï†] [IsIso f] : IsIso Ï† := by\n  subst_hom_lift p f Ï†; clear a b R S\n  -- Let `Ï†` be the morphism induced by applying universal property to `ğŸ™ b` lying over `fâ»Â¹ â‰« f`.\n  let Ï†' := map p (p.map Ï†) Ï† (IsIso.inv_hom_id (p.map Ï†)).symm (ğŸ™ b)\n  use Ï†'\n  -- `Ï†' â‰« Ï† = ğŸ™ b` follows immediately from the universal property.\n  have inv_hom : Ï†' â‰« Ï† = ğŸ™ b := fac p (p.map Ï†) Ï† _ (ğŸ™ b)\n  refine âŸ¨?_, inv_homâŸ©\n  -- We will now show that `Ï† â‰« Ï†' = ğŸ™ a` by showing that `(Ï† â‰« Ï†') â‰« Ï† = ğŸ™ a â‰« Ï†`.\n  have hâ‚ : IsHomLift p (ğŸ™ (p.obj a)) (Ï†  â‰« Ï†') := by\n    rw [â† IsIso.hom_inv_id (p.map Ï†)]\n    apply IsHomLift.comp\n  apply IsStronglyCartesian.ext p (p.map Ï†) Ï† (ğŸ™ (p.obj a))\n  simp only [assoc, inv_hom, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.domainIsoOfBaseIso_hom","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR R' S : ğ’®\na a' b : ğ’³\nf : Quiver.Hom R S\nf' : Quiver.Hom R' S\ng : CategoryTheory.Iso R' R\nh : Eq f' (CategoryTheory.CategoryStruct.comp g.hom f)\nÏ† : Quiver.Hom a b\nÏ†' : Quiver.Hom a' b\ninstâœÂ¹ : p.IsStronglyCartesian f Ï†\ninstâœ : p.IsStronglyCartesian f' Ï†'\nâŠ¢ Eq (CategoryTheory.Functor.IsStronglyCartesian.domainIsoOfBaseIso p h Ï† Ï†').hom (CategoryTheory.Functor.IsStronglyCartesian.map p f Ï† h Ï†')","decl":"/-- The canonical isomorphism between the domains of two strongly cartesian morphisms lying over\nisomorphic objects. -/\n@[simps]\nnoncomputable def domainIsoOfBaseIso (h : f' = g.hom â‰« f) (Ï† : a âŸ¶ b) (Ï†' : a' âŸ¶ b)\n    [IsStronglyCartesian p f Ï†] [IsStronglyCartesian p f' Ï†'] : a' â‰… a where\n  hom := map p f Ï† h Ï†'\n  inv :=\n    haveI : p.IsHomLift ((fun x â†¦ g.inv â‰« x) (g.hom â‰« f)) Ï† := by\n      simpa using IsCartesian.toIsHomLift\n    map p f' Ï†' (congrArg (g.inv â‰« Â·) h.symm) Ï†\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.domainIsoOfBaseIso_inv","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR R' S : ğ’®\na a' b : ğ’³\nf : Quiver.Hom R S\nf' : Quiver.Hom R' S\ng : CategoryTheory.Iso R' R\nh : Eq f' (CategoryTheory.CategoryStruct.comp g.hom f)\nÏ† : Quiver.Hom a b\nÏ†' : Quiver.Hom a' b\ninstâœÂ¹ : p.IsStronglyCartesian f Ï†\ninstâœ : p.IsStronglyCartesian f' Ï†'\nâŠ¢ Eq (CategoryTheory.Functor.IsStronglyCartesian.domainIsoOfBaseIso p h Ï† Ï†').inv (CategoryTheory.Functor.IsStronglyCartesian.map p f' Ï†' â‹¯ Ï†)","decl":"/-- The canonical isomorphism between the domains of two strongly cartesian morphisms lying over\nisomorphic objects. -/\n@[simps]\nnoncomputable def domainIsoOfBaseIso (h : f' = g.hom â‰« f) (Ï† : a âŸ¶ b) (Ï†' : a' âŸ¶ b)\n    [IsStronglyCartesian p f Ï†] [IsStronglyCartesian p f' Ï†'] : a' â‰… a where\n  hom := map p f Ï† h Ï†'\n  inv :=\n    haveI : p.IsHomLift ((fun x â†¦ g.inv â‰« x) (g.hom â‰« f)) Ï† := by\n      simpa using IsCartesian.toIsHomLift\n    map p f' Ï†' (congrArg (g.inv â‰« Â·) h.symm) Ï†\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.domainUniqueUpToIso_inv_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR R' S : ğ’®\na a' b : ğ’³\nf : Quiver.Hom R S\nf' : Quiver.Hom R' S\ng : CategoryTheory.Iso R' R\nh : Eq f' (CategoryTheory.CategoryStruct.comp g.hom f)\nÏ† : Quiver.Hom a b\nÏ†' : Quiver.Hom a' b\ninstâœÂ¹ : p.IsStronglyCartesian f Ï†\ninstâœ : p.IsStronglyCartesian f' Ï†'\nâŠ¢ p.IsHomLift g.hom (CategoryTheory.Functor.IsStronglyCartesian.domainIsoOfBaseIso p h Ï† Ï†').hom","decl":"instance domainUniqueUpToIso_inv_isHomLift (h : f' = g.hom â‰« f) (Ï† : a âŸ¶ b) (Ï†' : a' âŸ¶ b)\n    [IsStronglyCartesian p f Ï†] [IsStronglyCartesian p f' Ï†'] :\n    IsHomLift p g.hom (domainIsoOfBaseIso p h Ï† Ï†').hom :=\n  domainIsoOfBaseIso_hom p h Ï† Ï†' â–¸ IsStronglyCartesian.map_isHomLift p f Ï† h Ï†'\n\n"}
{"name":"CategoryTheory.Functor.IsStronglyCartesian.domainUniqueUpToIso_hom_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.Cartesian","initialProofState":"ğ’® : Type uâ‚\nğ’³ : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³\np : CategoryTheory.Functor ğ’³ ğ’®\nR R' S : ğ’®\na a' b : ğ’³\nf : Quiver.Hom R S\nf' : Quiver.Hom R' S\ng : CategoryTheory.Iso R' R\nh : Eq f' (CategoryTheory.CategoryStruct.comp g.hom f)\nÏ† : Quiver.Hom a b\nÏ†' : Quiver.Hom a' b\ninstâœÂ¹ : p.IsStronglyCartesian f Ï†\ninstâœ : p.IsStronglyCartesian f' Ï†'\nâŠ¢ p.IsHomLift g.inv (CategoryTheory.Functor.IsStronglyCartesian.domainIsoOfBaseIso p h Ï† Ï†').inv","decl":"instance domainUniqueUpToIso_hom_isHomLift (h : f' = g.hom â‰« f) (Ï† : a âŸ¶ b) (Ï†' : a' âŸ¶ b)\n    [IsStronglyCartesian p f Ï†] [IsStronglyCartesian p f' Ï†'] :\n    IsHomLift p g.inv (domainIsoOfBaseIso p h Ï† Ï†').inv := by\n  haveI : p.IsHomLift ((fun x â†¦ g.inv â‰« x) (g.hom â‰« f)) Ï† := by\n    simpa using IsCartesian.toIsHomLift\n  simpa using IsStronglyCartesian.map_isHomLift p f' Ï†' (congrArg (g.inv â‰« Â·) h.symm) Ï†\n\n"}
