{"name":"LinearMap.IsReflective.regular","module":"Mathlib.LinearAlgebra.RootSystem.OfBilinear","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\nx : M\nself : B.IsReflective x\n⊢ IsRegular ((B x) x)","decl":"/-- A vector `x` is reflective with respect to a bilinear form if multiplication by its norm is\ninjective, and for any vector `y`, the norm of `x` divides twice the inner product of `x` and `y`.\nThese conditions are what we need when describing reflection as a map taking `y` to\n`y - 2 • (B x y) / (B x x) • x`. -/\nstructure IsReflective (B : M →ₗ[R] M →ₗ[R] R) (x : M) : Prop where\n  regular : IsRegular (B x x)\n  dvd_two_mul : ∀ y, B x x ∣ 2 * B x y\n\n"}
{"name":"LinearMap.IsReflective.dvd_two_mul","module":"Mathlib.LinearAlgebra.RootSystem.OfBilinear","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\nx : M\nself : B.IsReflective x\ny : M\n⊢ Dvd.dvd ((B x) x) (HMul.hMul 2 ((B x) y))","decl":"/-- A vector `x` is reflective with respect to a bilinear form if multiplication by its norm is\ninjective, and for any vector `y`, the norm of `x` divides twice the inner product of `x` and `y`.\nThese conditions are what we need when describing reflection as a map taking `y` to\n`y - 2 • (B x y) / (B x x) • x`. -/\nstructure IsReflective (B : M →ₗ[R] M →ₗ[R] R) (x : M) : Prop where\n  regular : IsRegular (B x x)\n  dvd_two_mul : ∀ y, B x x ∣ 2 * B x y\n\n"}
{"name":"LinearMap.IsReflective.of_dvd_two","module":"Mathlib.LinearAlgebra.RootSystem.OfBilinear","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\nx : M\ninst✝¹ : IsDomain R\ninst✝ : NeZero 2\nhx : Dvd.dvd ((B x) x) 2\n⊢ B.IsReflective x","decl":"lemma of_dvd_two [IsDomain R] [NeZero (2 : R)] (hx : B x x ∣ 2) :\n    IsReflective B x where\n  regular := isRegular_of_ne_zero <| fun contra ↦ by simp [contra, two_ne_zero (α := R)] at hx\n  dvd_two_mul y := hx.mul_right (B x y)\n\n"}
{"name":"LinearMap.IsReflective.apply_self_mul_coroot_apply","module":"Mathlib.LinearAlgebra.RootSystem.OfBilinear","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\nx : M\nhx : B.IsReflective x\ny : M\n⊢ Eq (HMul.hMul ((B x) x) ((LinearMap.IsReflective.coroot B hx) y)) (HMul.hMul 2 ((B x) y))","decl":"@[simp]\nlemma apply_self_mul_coroot_apply {y : M} : B x x * coroot B hx y = 2 * B x y :=\n  (hx.dvd_two_mul y).choose_spec.symm\n\n"}
{"name":"LinearMap.IsReflective.smul_coroot","module":"Mathlib.LinearAlgebra.RootSystem.OfBilinear","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\nx : M\nhx : B.IsReflective x\n⊢ Eq (HSMul.hSMul ((B x) x) (LinearMap.IsReflective.coroot B hx)) (HSMul.hSMul 2 (B x))","decl":"@[simp]\nlemma smul_coroot : B x x • coroot B hx = 2 • B x := by\n  ext y\n  simp [smul_apply, smul_eq_mul, nsmul_eq_mul, Nat.cast_ofNat, apply_self_mul_coroot_apply]\n\n"}
{"name":"LinearMap.IsReflective.coroot_apply_self","module":"Mathlib.LinearAlgebra.RootSystem.OfBilinear","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\nx : M\nhx : B.IsReflective x\n⊢ Eq ((LinearMap.IsReflective.coroot B hx) x) 2","decl":"@[simp]\nlemma coroot_apply_self : coroot B hx x = 2 :=\n  hx.regular.left <| by simp [mul_comm _ (B x x)]\n\n"}
{"name":"LinearMap.IsReflective.isOrthogonal_reflection","module":"Mathlib.LinearAlgebra.RootSystem.OfBilinear","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\nx : M\nhx : B.IsReflective x\nhSB : B.IsSymm\n⊢ B.IsOrthogonal ⇑(Module.reflection ⋯)","decl":"lemma isOrthogonal_reflection (hSB : LinearMap.IsSymm B) :\n    B.IsOrthogonal (Module.reflection (coroot_apply_self B hx)) := by\n  intro y z\n  simp only [LinearEquiv.coe_coe, reflection_apply, LinearMap.map_sub, map_smul, sub_apply,\n    smul_apply, smul_eq_mul]\n  refine hx.1.1 ?_\n  simp only [mul_sub, ← mul_assoc, apply_self_mul_coroot_apply]\n  rw [sub_eq_iff_eq_add, ← hSB x y, RingHom.id_apply, mul_assoc _ _ (B x x), mul_comm _ (B x x),\n    apply_self_mul_coroot_apply]\n  ring\n\n"}
{"name":"LinearMap.IsReflective.reflective_reflection","module":"Mathlib.LinearAlgebra.RootSystem.OfBilinear","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\nx : M\nhSB : B.IsSymm\ny : M\nhx : B.IsReflective x\nhy : B.IsReflective y\n⊢ B.IsReflective ((Module.reflection ⋯) y)","decl":"lemma reflective_reflection (hSB : LinearMap.IsSymm B) {y : M}\n    (hx : IsReflective B x) (hy : IsReflective B y) :\n    IsReflective B (Module.reflection (coroot_apply_self B hx) y) := by\n  constructor\n  · rw [isOrthogonal_reflection B hx hSB]\n    exact hy.1\n  · intro z\n    have hz : Module.reflection (coroot_apply_self B hx)\n        (Module.reflection (coroot_apply_self B hx) z) = z := by\n      exact (LinearEquiv.eq_symm_apply (Module.reflection (coroot_apply_self B hx))).mp rfl\n    rw [← hz, isOrthogonal_reflection B hx hSB,\n      isOrthogonal_reflection B hx hSB]\n    exact hy.2 _\n\n"}
