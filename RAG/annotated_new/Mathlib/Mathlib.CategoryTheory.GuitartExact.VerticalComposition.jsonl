{"name":"CategoryTheory.TwoSquare.whiskerVertical_app","module":"Mathlib.CategoryTheory.GuitartExact.VerticalComposition","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_4\nD₂ : Type u_5\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_9, u_4} D₁\ninst✝ : CategoryTheory.Category.{u_10, u_5} D₂\nT : CategoryTheory.Functor C₁ D₁\nL : CategoryTheory.Functor C₁ C₂\nR : CategoryTheory.Functor D₁ D₂\nB : CategoryTheory.Functor C₂ D₂\nw : CategoryTheory.TwoSquare T L R B\nL' : CategoryTheory.Functor C₁ C₂\nR' : CategoryTheory.Functor D₁ D₂\nα : Quiver.Hom L L'\nβ : Quiver.Hom R' R\nX : C₁\n⊢ Eq ((w.whiskerVertical α β).app X) (CategoryTheory.CategoryStruct.comp (β.app (T.obj X)) (CategoryTheory.CategoryStruct.comp (w.app X) (B.map (α.app X))))","decl":"/-- Given `w : TwoSquare T L R B`, one may obtain a 2-square `TwoSquare T L' R' B` if we\nprovide natural transformations `α : L ⟶ L'` and `β : R' ⟶ R`. -/\n@[simps!]\ndef whiskerVertical (α : L ⟶ L') (β : R' ⟶ R) :\n    TwoSquare T L' R' B :=\n  whiskerLeft _ β ≫ w ≫ whiskerRight α _\n\n"}
{"name":"CategoryTheory.TwoSquare.GuitartExact.whiskerVertical","module":"Mathlib.CategoryTheory.GuitartExact.VerticalComposition","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_4\nD₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_8, u_4} D₁\ninst✝¹ : CategoryTheory.Category.{u_10, u_5} D₂\nT : CategoryTheory.Functor C₁ D₁\nL : CategoryTheory.Functor C₁ C₂\nR : CategoryTheory.Functor D₁ D₂\nB : CategoryTheory.Functor C₂ D₂\nw : CategoryTheory.TwoSquare T L R B\nL' : CategoryTheory.Functor C₁ C₂\nR' : CategoryTheory.Functor D₁ D₂\ninst✝ : w.GuitartExact\nα : CategoryTheory.Iso L L'\nβ : CategoryTheory.Iso R R'\n⊢ (w.whiskerVertical α.hom β.inv).GuitartExact","decl":"/-- A 2-square stays Guitart exact if we replace the left and right functors\nby isomorphic functors. See also `whiskerVertical_iff`. -/\nlemma whiskerVertical [w.GuitartExact] (α : L ≅ L') (β : R ≅ R') :\n    (w.whiskerVertical α.hom β.inv).GuitartExact := by\n  rw [guitartExact_iff_initial]\n  intro X₂\n  let e : structuredArrowDownwards (w.whiskerVertical α.hom β.inv) X₂ ≅\n      w.structuredArrowDownwards X₂ ⋙ (StructuredArrow.mapIso (β.app X₂) ).functor :=\n    NatIso.ofComponents (fun f => StructuredArrow.isoMk (α.symm.app f.right) (by\n      dsimp\n      simp only [NatTrans.naturality_assoc, assoc, NatIso.cancel_natIso_inv_left, ← B.map_comp,\n        Iso.hom_inv_id_app, B.map_id, comp_id]))\n  rw [Functor.initial_natIso_iff e]\n  infer_instance\n\n"}
{"name":"CategoryTheory.TwoSquare.GuitartExact.whiskerVertical_iff","module":"Mathlib.CategoryTheory.GuitartExact.VerticalComposition","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_4\nD₂ : Type u_5\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_7, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} D₁\ninst✝ : CategoryTheory.Category.{u_9, u_5} D₂\nT : CategoryTheory.Functor C₁ D₁\nL : CategoryTheory.Functor C₁ C₂\nR : CategoryTheory.Functor D₁ D₂\nB : CategoryTheory.Functor C₂ D₂\nw : CategoryTheory.TwoSquare T L R B\nL' : CategoryTheory.Functor C₁ C₂\nR' : CategoryTheory.Functor D₁ D₂\nα : CategoryTheory.Iso L L'\nβ : CategoryTheory.Iso R R'\n⊢ Iff (w.whiskerVertical α.hom β.inv).GuitartExact w.GuitartExact","decl":"/-- A 2-square is Guitart exact iff it is so after replacing the left and right functors by\nisomorphic functors. -/\n@[simp]\nlemma whiskerVertical_iff (α : L ≅ L') (β : R ≅ R') :\n    (w.whiskerVertical α.hom β.inv).GuitartExact ↔ w.GuitartExact := by\n  constructor\n  · intro h\n    have : w = TwoSquare.whiskerVertical\n        (TwoSquare.whiskerVertical w α.hom β.inv) α.inv β.hom := by\n      ext X₁\n      simp only [Functor.comp_obj, whiskerVertical_app, assoc, Iso.hom_inv_id_app_assoc,\n        ← B.map_comp, Iso.hom_inv_id_app, B.map_id, comp_id]\n    rw [this]\n    exact whiskerVertical (w.whiskerVertical α.hom β.inv) α.symm β.symm\n  · intro h\n    exact whiskerVertical w α β\n\n"}
{"name":"CategoryTheory.TwoSquare.GuitartExact.instWhiskerVerticalOfIsIsoFunctor","module":"Mathlib.CategoryTheory.GuitartExact.VerticalComposition","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_4\nD₂ : Type u_5\ninst✝⁶ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_8, u_4} D₁\ninst✝³ : CategoryTheory.Category.{u_10, u_5} D₂\nT : CategoryTheory.Functor C₁ D₁\nL : CategoryTheory.Functor C₁ C₂\nR : CategoryTheory.Functor D₁ D₂\nB : CategoryTheory.Functor C₂ D₂\nw : CategoryTheory.TwoSquare T L R B\nL' : CategoryTheory.Functor C₁ C₂\nR' : CategoryTheory.Functor D₁ D₂\ninst✝² : w.GuitartExact\nα : Quiver.Hom L L'\nβ : Quiver.Hom R' R\ninst✝¹ : CategoryTheory.IsIso α\ninst✝ : CategoryTheory.IsIso β\n⊢ (w.whiskerVertical α β).GuitartExact","decl":"instance [w.GuitartExact] (α : L ⟶ L') (β : R' ⟶ R)\n    [IsIso α] [IsIso β] : (w.whiskerVertical α β).GuitartExact :=\n  whiskerVertical w (asIso α) (asIso β).symm\n\n"}
{"name":"CategoryTheory.TwoSquare.vComp_app","module":"Mathlib.CategoryTheory.GuitartExact.VerticalComposition","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝² : CategoryTheory.Category.{u_10, u_4} D₁\ninst✝¹ : CategoryTheory.Category.{u_11, u_5} D₂\ninst✝ : CategoryTheory.Category.{u_12, u_6} D₃\nH₁ : CategoryTheory.Functor C₁ D₁\nL₁ : CategoryTheory.Functor C₁ C₂\nR₁ : CategoryTheory.Functor D₁ D₂\nH₂ : CategoryTheory.Functor C₂ D₂\nw : CategoryTheory.TwoSquare H₁ L₁ R₁ H₂\nL₂ : CategoryTheory.Functor C₂ C₃\nR₂ : CategoryTheory.Functor D₂ D₃\nH₃ : CategoryTheory.Functor C₃ D₃\nw' : CategoryTheory.TwoSquare H₂ L₂ R₂ H₃\nX : C₁\n⊢ Eq ((w.vComp w').app X) (CategoryTheory.CategoryStruct.comp (R₂.map (w.app X)) (w'.app (L₁.obj X)))","decl":"/-- The vertical composition of 2-squares. -/\n@[simps!]\ndef vComp : TwoSquare H₁ (L₁ ⋙ L₂) (R₁ ⋙ R₂) H₃ :=\n  (Functor.associator _ _ _).inv ≫ whiskerRight w R₂ ≫\n    (Functor.associator _ _ _).hom ≫ whiskerLeft L₁ w' ≫ (Functor.associator _ _ _).inv\n\n"}
{"name":"CategoryTheory.TwoSquare.vComp'_app","module":"Mathlib.CategoryTheory.GuitartExact.VerticalComposition","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝² : CategoryTheory.Category.{u_10, u_4} D₁\ninst✝¹ : CategoryTheory.Category.{u_11, u_5} D₂\ninst✝ : CategoryTheory.Category.{u_12, u_6} D₃\nH₁ : CategoryTheory.Functor C₁ D₁\nL₁ : CategoryTheory.Functor C₁ C₂\nR₁ : CategoryTheory.Functor D₁ D₂\nH₂ : CategoryTheory.Functor C₂ D₂\nw : CategoryTheory.TwoSquare H₁ L₁ R₁ H₂\nL₂ : CategoryTheory.Functor C₂ C₃\nR₂ : CategoryTheory.Functor D₂ D₃\nH₃ : CategoryTheory.Functor C₃ D₃\nw' : CategoryTheory.TwoSquare H₂ L₂ R₂ H₃\nL₁₂ : CategoryTheory.Functor C₁ C₃\nR₁₂ : CategoryTheory.Functor D₁ D₃\neL : CategoryTheory.Iso (L₁.comp L₂) L₁₂\neR : CategoryTheory.Iso (R₁.comp R₂) R₁₂\nX : C₁\n⊢ Eq ((w.vComp' w' eL eR).app X) (CategoryTheory.CategoryStruct.comp (eR.inv.app (H₁.obj X)) (CategoryTheory.CategoryStruct.comp (R₂.map (w.app X)) (CategoryTheory.CategoryStruct.comp (w'.app (L₁.obj X)) (H₃.map (eL.hom.app X)))))","decl":"/-- The vertical composition of 2-squares. (Variant where we allow the replacement of\nthe vertical compositions by isomorphic functors.) -/\n@[simps!]\ndef vComp' {L₁₂ : C₁ ⥤ C₃} {R₁₂ : D₁ ⥤ D₃} (eL : L₁ ⋙ L₂ ≅ L₁₂)\n    (eR : R₁ ⋙ R₂ ≅ R₁₂) : TwoSquare H₁ L₁₂ R₁₂ H₃ :=\n  (w.vComp w').whiskerVertical eL.hom eR.inv\n\n"}
{"name":"CategoryTheory.TwoSquare.GuitartExact.vComp","module":"Mathlib.CategoryTheory.GuitartExact.VerticalComposition","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_11, u_3} C₃\ninst✝² : CategoryTheory.Category.{u_8, u_4} D₁\ninst✝¹ : CategoryTheory.Category.{u_10, u_5} D₂\ninst✝ : CategoryTheory.Category.{u_12, u_6} D₃\nH₁ : CategoryTheory.Functor C₁ D₁\nL₁ : CategoryTheory.Functor C₁ C₂\nR₁ : CategoryTheory.Functor D₁ D₂\nH₂ : CategoryTheory.Functor C₂ D₂\nw : CategoryTheory.TwoSquare H₁ L₁ R₁ H₂\nL₂ : CategoryTheory.Functor C₂ C₃\nR₂ : CategoryTheory.Functor D₂ D₃\nH₃ : CategoryTheory.Functor C₃ D₃\nw' : CategoryTheory.TwoSquare H₂ L₂ R₂ H₃\nhw : w.GuitartExact\nhw' : w'.GuitartExact\n⊢ (w.vComp w').GuitartExact","decl":"instance vComp [hw : w.GuitartExact] [hw' : w'.GuitartExact] :\n    (w.vComp w').GuitartExact := by\n  simp only [TwoSquare.guitartExact_iff_initial]\n  intro Y₁\n  rw [← Functor.initial_natIso_iff (structuredArrowDownwardsComp w w' Y₁)]\n  infer_instance\n\n"}
{"name":"CategoryTheory.TwoSquare.GuitartExact.vComp'","module":"Mathlib.CategoryTheory.GuitartExact.VerticalComposition","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_11, u_3} C₃\ninst✝⁴ : CategoryTheory.Category.{u_8, u_4} D₁\ninst✝³ : CategoryTheory.Category.{u_10, u_5} D₂\ninst✝² : CategoryTheory.Category.{u_12, u_6} D₃\nH₁ : CategoryTheory.Functor C₁ D₁\nL₁ : CategoryTheory.Functor C₁ C₂\nR₁ : CategoryTheory.Functor D₁ D₂\nH₂ : CategoryTheory.Functor C₂ D₂\nw : CategoryTheory.TwoSquare H₁ L₁ R₁ H₂\nL₂ : CategoryTheory.Functor C₂ C₃\nR₂ : CategoryTheory.Functor D₂ D₃\nH₃ : CategoryTheory.Functor C₃ D₃\nw' : CategoryTheory.TwoSquare H₂ L₂ R₂ H₃\ninst✝¹ : w.GuitartExact\ninst✝ : w'.GuitartExact\nL₁₂ : CategoryTheory.Functor C₁ C₃\nR₁₂ : CategoryTheory.Functor D₁ D₃\neL : CategoryTheory.Iso (L₁.comp L₂) L₁₂\neR : CategoryTheory.Iso (R₁.comp R₂) R₁₂\n⊢ (w.vComp' w' eL eR).GuitartExact","decl":"instance vComp' [GuitartExact w] [GuitartExact w'] {L₁₂ : C₁ ⥤ C₃}\n    {R₁₂ : D₁ ⥤ D₃} (eL : L₁ ⋙ L₂ ≅ L₁₂)\n    (eR : R₁ ⋙ R₂ ≅ R₁₂) : (w.vComp' w' eL eR).GuitartExact := by\n  dsimp only [TwoSquare.vComp']\n  infer_instance\n\n"}
{"name":"CategoryTheory.TwoSquare.GuitartExact.vComp_iff_of_equivalences","module":"Mathlib.CategoryTheory.GuitartExact.VerticalComposition","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁵ : CategoryTheory.Category.{u_11, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_8, u_3} C₃\ninst✝² : CategoryTheory.Category.{u_12, u_4} D₁\ninst✝¹ : CategoryTheory.Category.{u_9, u_5} D₂\ninst✝ : CategoryTheory.Category.{u_10, u_6} D₃\nH₁ : CategoryTheory.Functor C₁ D₁\nL₁ : CategoryTheory.Functor C₁ C₂\nR₁ : CategoryTheory.Functor D₁ D₂\nH₂ : CategoryTheory.Functor C₂ D₂\nw : CategoryTheory.TwoSquare H₁ L₁ R₁ H₂\nH₃ : CategoryTheory.Functor C₃ D₃\neL : CategoryTheory.Equivalence C₂ C₃\neR : CategoryTheory.Equivalence D₂ D₃\nw' : CategoryTheory.Iso (H₂.comp eR.functor) (eL.functor.comp H₃)\n⊢ Iff (w.vComp w'.hom).GuitartExact w.GuitartExact","decl":"lemma vComp_iff_of_equivalences (eL : C₂ ≌ C₃) (eR : D₂ ≌ D₃)\n    (w' : H₂ ⋙ eR.functor ≅ eL.functor ⋙ H₃) :\n    (w.vComp w'.hom).GuitartExact ↔ w.GuitartExact := by\n  constructor\n  · intro hww'\n    letI : CatCommSq H₂ eL.functor eR.functor H₃ := ⟨w'⟩\n    have hw' : CatCommSq.iso H₂ eL.functor eR.functor H₃ = w' := rfl\n    letI : CatCommSq H₃ eL.inverse eR.inverse H₂ := CatCommSq.vInvEquiv _ _ _ _ inferInstance\n    let w'' := CatCommSq.iso H₃ eL.inverse eR.inverse H₂\n    let α : (L₁ ⋙ eL.functor) ⋙ eL.inverse ≅ L₁ :=\n      Functor.associator _ _ _ ≪≫ isoWhiskerLeft L₁ eL.unitIso.symm ≪≫ L₁.rightUnitor\n    let β : (R₁ ⋙ eR.functor) ⋙ eR.inverse ≅ R₁ :=\n      Functor.associator _ _ _ ≪≫ isoWhiskerLeft R₁ eR.unitIso.symm ≪≫ R₁.rightUnitor\n    have : w = (w.vComp w'.hom).vComp' w''.hom α β := by\n      ext X₁\n      dsimp\n      simp? [w'', β, α] says\n        simp only [vComp'_app, Functor.comp_obj, Iso.trans_inv, isoWhiskerLeft_inv, Iso.symm_inv,\n          assoc, NatTrans.comp_app, Functor.id_obj, Functor.rightUnitor_inv_app, whiskerLeft_app,\n          Functor.associator_inv_app, comp_id, id_comp, vComp_app, Functor.map_comp,\n          Equivalence.inv_fun_map, Iso.trans_hom, isoWhiskerLeft_hom, Iso.symm_hom,\n          Functor.associator_hom_app, Functor.rightUnitor_hom_app, Iso.hom_inv_id_app_assoc,\n          w'', α, β]\n      erw [CatCommSq.vInv_iso'_hom_app]\n      simp only [hw', assoc, ← eR.inverse.map_comp_assoc]\n      rw [Equivalence.counitInv_app_functor]\n      erw [← NatTrans.naturality_assoc]\n      simp [← H₂.map_comp]\n    rw [this]\n    infer_instance\n  · intro\n    exact vComp w w'.hom\n\n"}
{"name":"CategoryTheory.TwoSquare.GuitartExact.vComp'_iff_of_equivalences","module":"Mathlib.CategoryTheory.GuitartExact.VerticalComposition","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁵ : CategoryTheory.Category.{u_11, u_1} C₁\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} C₂\ninst✝³ : CategoryTheory.Category.{u_8, u_3} C₃\ninst✝² : CategoryTheory.Category.{u_12, u_4} D₁\ninst✝¹ : CategoryTheory.Category.{u_9, u_5} D₂\ninst✝ : CategoryTheory.Category.{u_10, u_6} D₃\nH₁ : CategoryTheory.Functor C₁ D₁\nL₁ : CategoryTheory.Functor C₁ C₂\nR₁ : CategoryTheory.Functor D₁ D₂\nH₂ : CategoryTheory.Functor C₂ D₂\nw : CategoryTheory.TwoSquare H₁ L₁ R₁ H₂\nH₃ : CategoryTheory.Functor C₃ D₃\nE : CategoryTheory.Equivalence C₂ C₃\nE' : CategoryTheory.Equivalence D₂ D₃\nw' : CategoryTheory.Iso (H₂.comp E'.functor) (E.functor.comp H₃)\nL₁₂ : CategoryTheory.Functor C₁ C₃\nR₁₂ : CategoryTheory.Functor D₁ D₃\neL : CategoryTheory.Iso (L₁.comp E.functor) L₁₂\neR : CategoryTheory.Iso (R₁.comp E'.functor) R₁₂\n⊢ Iff (w.vComp' w'.hom eL eR).GuitartExact w.GuitartExact","decl":"lemma vComp'_iff_of_equivalences (E : C₂ ≌ C₃) (E' : D₂ ≌ D₃)\n    (w' : H₂ ⋙ E'.functor ≅ E.functor ⋙ H₃) {L₁₂ : C₁ ⥤ C₃}\n    {R₁₂ : D₁ ⥤ D₃} (eL : L₁ ⋙ E.functor ≅ L₁₂)\n    (eR : R₁ ⋙ E'.functor ≅ R₁₂) :\n    (w.vComp' w'.hom eL eR).GuitartExact ↔ w.GuitartExact := by\n  rw [← vComp_iff_of_equivalences w E E' w', TwoSquare.vComp', whiskerVertical_iff]\n\n"}
