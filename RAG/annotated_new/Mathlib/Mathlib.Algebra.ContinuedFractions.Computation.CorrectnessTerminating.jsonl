{"name":"GenContFract.compExactValue_correctness_of_stream_eq_some_aux_comp","module":"Mathlib.Algebra.ContinuedFractions.Computation.CorrectnessTerminating","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\na b c : K\nfract_a_ne_zero : Ne (Int.fract a) 0\n⊢ Eq (HAdd.hAdd (HDiv.hDiv (HAdd.hAdd (HMul.hMul (↑(Int.floor a)) b) c) (Int.fract a)) b) (HDiv.hDiv (HAdd.hAdd (HMul.hMul b a) c) (Int.fract a))","decl":"/-- Just a computational lemma we need for the next main proof. -/\nprotected theorem compExactValue_correctness_of_stream_eq_some_aux_comp {a : K} (b c : K)\n    (fract_a_ne_zero : Int.fract a ≠ 0) :\n    ((⌊a⌋ : K) * b + c) / Int.fract a + b = (b * a + c) / Int.fract a := by\n  field_simp [fract_a_ne_zero]\n  rw [Int.fract]\n  ring\n\n"}
{"name":"GenContFract.compExactValue_correctness_of_stream_eq_some","module":"Mathlib.Algebra.ContinuedFractions.Computation.CorrectnessTerminating","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\nv : K\nn : Nat\ninst✝ : FloorRing K\nifp_n : GenContFract.IntFractPair K\na✝ : Eq (GenContFract.IntFractPair.stream v n) (Option.some ifp_n)\n⊢ Eq v (GenContFract.compExactValue ((GenContFract.of v).contsAux n) ((GenContFract.of v).contsAux (HAdd.hAdd n 1)) ifp_n.fr)","decl":"/-- Shows the correctness of `compExactValue` in case the continued fraction\n`GenContFract.of v` did not terminate at position `n`. That is, we obtain the\nvalue `v` if we pass the two successive (auxiliary) continuants at positions `n` and `n + 1` as well\nas the fractional part at `IntFractPair.stream n` to `compExactValue`.\n\nThe correctness might be seen more readily if one uses `convs'` to evaluate the continued\nfraction. Here is an example to illustrate the idea:\n\nLet `(v : ℚ) := 3.4`. We have\n- `GenContFract.IntFractPair.stream v 0 = some ⟨3, 0.4⟩`, and\n- `GenContFract.IntFractPair.stream v 1 = some ⟨2, 0.5⟩`.\nNow `(GenContFract.of v).convs' 1 = 3 + 1/2`, and our fractional term at position `2` is `0.5`.\nWe hence have `v = 3 + 1/(2 + 0.5) = 3 + 1/2.5 = 3.4`.\nThis computation corresponds exactly to the one using the recurrence equation in `compExactValue`.\n-/\ntheorem compExactValue_correctness_of_stream_eq_some :\n    ∀ {ifp_n : IntFractPair K}, IntFractPair.stream v n = some ifp_n →\n      v = compExactValue ((of v).contsAux n) ((of v).contsAux <| n + 1) ifp_n.fr := by\n  let g := of v\n  induction n with\n  | zero =>\n    intro ifp_zero stream_zero_eq\n    obtain rfl : IntFractPair.of v = ifp_zero := by\n      have : IntFractPair.stream v 0 = some (IntFractPair.of v) := rfl\n      simpa only [this, Option.some.injEq] using stream_zero_eq\n    cases eq_or_ne (Int.fract v) 0 with\n    | inl fract_eq_zero =>\n      -- Int.fract v = 0; we must then have `v = ⌊v⌋`\n      suffices v = ⌊v⌋ by\n        -- Porting note: was `simpa [contsAux, fract_eq_zero, compExactValue]`\n        field_simp [nextConts, nextNum, nextDen, compExactValue]\n        have : (IntFractPair.of v).fr = Int.fract v := rfl\n        rwa [this, if_pos fract_eq_zero]\n      calc\n        v = Int.fract v + ⌊v⌋ := by rw [Int.fract_add_floor]\n        _ = ⌊v⌋ := by simp [fract_eq_zero]\n    | inr fract_ne_zero =>\n      -- Int.fract v ≠ 0; the claim then easily follows by unfolding a single computation step\n      field_simp [contsAux, nextConts, nextNum, nextDen, of_h_eq_floor, compExactValue]\n      -- Porting note: this and the if_neg rewrite are needed\n      have : (IntFractPair.of v).fr = Int.fract v := rfl\n      rw [this, if_neg fract_ne_zero, Int.floor_add_fract]\n  | succ n IH =>\n    intro ifp_succ_n succ_nth_stream_eq\n    obtain ⟨ifp_n, nth_stream_eq, nth_fract_ne_zero, -⟩ :\n      ∃ ifp_n, IntFractPair.stream v n = some ifp_n ∧\n        ifp_n.fr ≠ 0 ∧ IntFractPair.of ifp_n.fr⁻¹ = ifp_succ_n :=\n      IntFractPair.succ_nth_stream_eq_some_iff.1 succ_nth_stream_eq\n    -- introduce some notation\n    let conts := g.contsAux (n + 2)\n    set pconts := g.contsAux (n + 1) with pconts_eq\n    set ppconts := g.contsAux n with ppconts_eq\n    cases eq_or_ne ifp_succ_n.fr 0 with\n    | inl ifp_succ_n_fr_eq_zero =>\n      -- ifp_succ_n.fr = 0\n      suffices v = conts.a / conts.b by simpa [compExactValue, ifp_succ_n_fr_eq_zero]\n      -- use the IH and the fact that ifp_n.fr⁻¹ = ⌊ifp_n.fr⁻¹⌋ to prove this case\n      obtain ⟨ifp_n', nth_stream_eq', ifp_n_fract_inv_eq_floor⟩ :\n          ∃ ifp_n, IntFractPair.stream v n = some ifp_n ∧ ifp_n.fr⁻¹ = ⌊ifp_n.fr⁻¹⌋ :=\n        IntFractPair.exists_succ_nth_stream_of_fr_zero succ_nth_stream_eq ifp_succ_n_fr_eq_zero\n      have : ifp_n' = ifp_n := by injection Eq.trans nth_stream_eq'.symm nth_stream_eq\n      cases this\n      have s_nth_eq : g.s.get? n = some ⟨1, ⌊ifp_n.fr⁻¹⌋⟩ :=\n        get?_of_eq_some_of_get?_intFractPair_stream_fr_ne_zero nth_stream_eq nth_fract_ne_zero\n      rw [← ifp_n_fract_inv_eq_floor] at s_nth_eq\n      suffices v = compExactValue ppconts pconts ifp_n.fr by\n        simpa [conts, contsAux, s_nth_eq, compExactValue, nth_fract_ne_zero] using this\n      exact IH nth_stream_eq\n    | inr ifp_succ_n_fr_ne_zero =>\n      -- ifp_succ_n.fr ≠ 0\n      -- use the IH to show that the following equality suffices\n      suffices\n        compExactValue ppconts pconts ifp_n.fr = compExactValue pconts conts ifp_succ_n.fr by\n        have : v = compExactValue ppconts pconts ifp_n.fr := IH nth_stream_eq\n        conv_lhs => rw [this]\n        assumption\n      -- get the correspondence between ifp_n and ifp_succ_n\n      obtain ⟨ifp_n', nth_stream_eq', ifp_n_fract_ne_zero, ⟨refl⟩⟩ :\n        ∃ ifp_n, IntFractPair.stream v n = some ifp_n ∧\n          ifp_n.fr ≠ 0 ∧ IntFractPair.of ifp_n.fr⁻¹ = ifp_succ_n :=\n        IntFractPair.succ_nth_stream_eq_some_iff.1 succ_nth_stream_eq\n      have : ifp_n' = ifp_n := by injection Eq.trans nth_stream_eq'.symm nth_stream_eq\n      cases this\n      -- get the correspondence between ifp_n and g.s.nth n\n      have s_nth_eq : g.s.get? n = some ⟨1, (⌊ifp_n.fr⁻¹⌋ : K)⟩ :=\n        get?_of_eq_some_of_get?_intFractPair_stream_fr_ne_zero nth_stream_eq ifp_n_fract_ne_zero\n      -- the claim now follows by unfolding the definitions and tedious calculations\n      -- some shorthand notation\n      let ppA := ppconts.a\n      let ppB := ppconts.b\n      let pA := pconts.a\n      let pB := pconts.b\n      have : compExactValue ppconts pconts ifp_n.fr =\n          (ppA + ifp_n.fr⁻¹ * pA) / (ppB + ifp_n.fr⁻¹ * pB) := by\n        -- unfold compExactValue and the convergent computation once\n        field_simp [ifp_n_fract_ne_zero, compExactValue, nextConts, nextNum, nextDen, ppA, ppB]\n        ac_rfl\n      rw [this]\n      -- two calculations needed to show the claim\n      have tmp_calc :=\n        compExactValue_correctness_of_stream_eq_some_aux_comp pA ppA ifp_succ_n_fr_ne_zero\n      have tmp_calc' :=\n        compExactValue_correctness_of_stream_eq_some_aux_comp pB ppB ifp_succ_n_fr_ne_zero\n      let f := Int.fract (1 / ifp_n.fr)\n      have f_ne_zero : f ≠ 0 := by simpa [f] using ifp_succ_n_fr_ne_zero\n      rw [inv_eq_one_div] at tmp_calc tmp_calc'\n      -- Porting note: the `tmp_calc`s need to be massaged, and some processing after `ac_rfl` done,\n      -- because `field_simp` is not as powerful\n      have hA : (↑⌊1 / ifp_n.fr⌋ * pA + ppA) + pA * f = pA * (1 / ifp_n.fr) + ppA := by\n        have := congrFun (congrArg HMul.hMul tmp_calc) f\n        rwa [right_distrib, div_mul_cancel₀ (h := f_ne_zero),\n          div_mul_cancel₀ (h := f_ne_zero)] at this\n      have hB : (↑⌊1 / ifp_n.fr⌋ * pB + ppB) + pB * f = pB * (1 / ifp_n.fr) + ppB := by\n        have := congrFun (congrArg HMul.hMul tmp_calc') f\n        rwa [right_distrib, div_mul_cancel₀ (h := f_ne_zero),\n          div_mul_cancel₀ (h := f_ne_zero)] at this\n      -- now unfold the recurrence one step and simplify both sides to arrive at the conclusion\n      dsimp only [conts, pconts, ppconts]\n      field_simp [compExactValue, contsAux_recurrence s_nth_eq ppconts_eq pconts_eq,\n        nextConts, nextNum, nextDen]\n      have hfr : (IntFractPair.of (1 / ifp_n.fr)).fr = f := rfl\n      rw [one_div, if_neg _, ← one_div, hfr]\n      · field_simp [pA, pB, ppA, ppB, pconts, ppconts, hA, hB]\n        ac_rfl\n      · rwa [inv_eq_one_div, hfr]\n\n"}
{"name":"GenContFract.of_correctness_of_nth_stream_eq_none","module":"Mathlib.Algebra.ContinuedFractions.Computation.CorrectnessTerminating","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\nv : K\nn : Nat\ninst✝ : FloorRing K\nnth_stream_eq_none : Eq (GenContFract.IntFractPair.stream v n) Option.none\n⊢ Eq v ((GenContFract.of v).convs (HSub.hSub n 1))","decl":"/-- The convergent of `GenContFract.of v` at step `n - 1` is exactly `v` if the\n`IntFractPair.stream` of the corresponding continued fraction terminated at step `n`. -/\ntheorem of_correctness_of_nth_stream_eq_none (nth_stream_eq_none : IntFractPair.stream v n = none) :\n    v = (of v).convs (n - 1) := by\n  induction n with\n  | zero => contradiction\n  -- IntFractPair.stream v 0 ≠ none\n  | succ n IH =>\n    let g := of v\n    change v = g.convs n\n    obtain ⟨nth_stream_eq_none⟩ | ⟨ifp_n, nth_stream_eq, nth_stream_fr_eq_zero⟩ :\n      IntFractPair.stream v n = none ∨ ∃ ifp, IntFractPair.stream v n = some ifp ∧ ifp.fr = 0 :=\n      IntFractPair.succ_nth_stream_eq_none_iff.1 nth_stream_eq_none\n    · cases n with\n      | zero => contradiction\n      | succ n' =>\n        -- IntFractPair.stream v 0 ≠ none\n        have : g.TerminatedAt n' :=\n          of_terminatedAt_n_iff_succ_nth_intFractPair_stream_eq_none.2\n            nth_stream_eq_none\n        have : g.convs (n' + 1) = g.convs n' :=\n          convs_stable_of_terminated n'.le_succ this\n        rw [this]\n        exact IH nth_stream_eq_none\n    · simpa [nth_stream_fr_eq_zero, compExactValue] using\n        compExactValue_correctness_of_stream_eq_some nth_stream_eq\n\n"}
{"name":"GenContFract.of_correctness_of_terminatedAt","module":"Mathlib.Algebra.ContinuedFractions.Computation.CorrectnessTerminating","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\nv : K\nn : Nat\ninst✝ : FloorRing K\nterminatedAt_n : (GenContFract.of v).TerminatedAt n\n⊢ Eq v ((GenContFract.of v).convs n)","decl":"/-- If `GenContFract.of v` terminated at step `n`, then the `n`th convergent is exactly `v`. -/\ntheorem of_correctness_of_terminatedAt (terminatedAt_n : (of v).TerminatedAt n) :\n    v = (of v).convs n :=\n  have : IntFractPair.stream v (n + 1) = none :=\n    of_terminatedAt_n_iff_succ_nth_intFractPair_stream_eq_none.1 terminatedAt_n\n  of_correctness_of_nth_stream_eq_none this\n\n"}
{"name":"GenContFract.of_correctness_of_terminates","module":"Mathlib.Algebra.ContinuedFractions.Computation.CorrectnessTerminating","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\nv : K\ninst✝ : FloorRing K\nterminates : (GenContFract.of v).Terminates\n⊢ Exists fun n => Eq v ((GenContFract.of v).convs n)","decl":"/-- If `GenContFract.of v` terminates, then there is `n : ℕ` such that the `n`th convergent is\nexactly `v`.\n-/\ntheorem of_correctness_of_terminates (terminates : (of v).Terminates) :\n    ∃ n : ℕ, v = (of v).convs n :=\n  Exists.elim terminates fun n terminatedAt_n =>\n    Exists.intro n (of_correctness_of_terminatedAt terminatedAt_n)\n\n"}
{"name":"GenContFract.of_correctness_atTop_of_terminates","module":"Mathlib.Algebra.ContinuedFractions.Computation.CorrectnessTerminating","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\nv : K\ninst✝ : FloorRing K\nterminates : (GenContFract.of v).Terminates\n⊢ Filter.Eventually (fun n => Eq v ((GenContFract.of v).convs n)) Filter.atTop","decl":"/-- If `GenContFract.of v` terminates, then its convergents will eventually always be `v`. -/\ntheorem of_correctness_atTop_of_terminates (terminates : (of v).Terminates) :\n    ∀ᶠ n in atTop, v = (of v).convs n := by\n  rw [eventually_atTop]\n  obtain ⟨n, terminatedAt_n⟩ : ∃ n, (of v).TerminatedAt n := terminates\n  use n\n  intro m m_geq_n\n  rw [convs_stable_of_terminated m_geq_n terminatedAt_n]\n  exact of_correctness_of_terminatedAt terminatedAt_n\n\n"}
