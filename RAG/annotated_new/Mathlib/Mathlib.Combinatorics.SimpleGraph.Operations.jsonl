{"name":"SimpleGraph.Iso.card_edgeFinset_eq","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\nW : Type u_2\nG' : SimpleGraph W\nf : G.Iso G'\ninst✝¹ : Fintype ↑G.edgeSet\ninst✝ : Fintype ↑G'.edgeSet\n⊢ Eq G.edgeFinset.card G'.edgeFinset.card","decl":"include f in\ntheorem card_edgeFinset_eq [Fintype G.edgeSet] [Fintype G'.edgeSet] :\n    #G.edgeFinset = #G'.edgeFinset := by\n  apply Finset.card_eq_of_equiv\n  simp only [Set.mem_toFinset]\n  exact f.mapEdgeSet\n\n"}
{"name":"SimpleGraph.not_adj_replaceVertex_same","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst✝ : DecidableEq V\n⊢ Not ((G.replaceVertex s t).Adj s t)","decl":"/-- There is never an `s-t` edge in `G.replaceVertex s t`. -/\nlemma not_adj_replaceVertex_same : ¬(G.replaceVertex s t).Adj s t := by simp [replaceVertex]\n\n"}
{"name":"SimpleGraph.replaceVertex_self","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns : V\ninst✝ : DecidableEq V\n⊢ Eq (G.replaceVertex s s) G","decl":"@[simp] lemma replaceVertex_self : G.replaceVertex s s = G := by\n  ext; unfold replaceVertex; aesop (add simp or_iff_not_imp_left)\n\n"}
{"name":"SimpleGraph.adj_replaceVertex_iff_of_ne_left","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst✝ : DecidableEq V\nw : V\nhw : Ne w t\n⊢ Iff ((G.replaceVertex s t).Adj s w) (G.Adj s w)","decl":"/-- Except possibly for `t`, the neighbours of `s` in `G.replaceVertex s t` are its neighbours in\n`G`. -/\nlemma adj_replaceVertex_iff_of_ne_left {w : V} (hw : w ≠ t) :\n    (G.replaceVertex s t).Adj s w ↔ G.Adj s w := by simp [replaceVertex, hw]\n\n"}
{"name":"SimpleGraph.adj_replaceVertex_iff_of_ne_right","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst✝ : DecidableEq V\nw : V\nhw : Ne w t\n⊢ Iff ((G.replaceVertex s t).Adj t w) (G.Adj s w)","decl":"/-- Except possibly for itself, the neighbours of `t` in `G.replaceVertex s t` are the neighbours of\n`s` in `G`. -/\nlemma adj_replaceVertex_iff_of_ne_right {w : V} (hw : w ≠ t) :\n    (G.replaceVertex s t).Adj t w ↔ G.Adj s w := by simp [replaceVertex, hw]\n\n"}
{"name":"SimpleGraph.adj_replaceVertex_iff_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst✝ : DecidableEq V\nv w : V\nhv : Ne v t\nhw : Ne w t\n⊢ Iff ((G.replaceVertex s t).Adj v w) (G.Adj v w)","decl":"/-- Adjacency in `G.replaceVertex s t` which does not involve `t` is the same as that of `G`. -/\nlemma adj_replaceVertex_iff_of_ne {v w : V} (hv : v ≠ t) (hw : w ≠ t) :\n    (G.replaceVertex s t).Adj v w ↔ G.Adj v w := by simp [replaceVertex, hv, hw]\n\n"}
{"name":"SimpleGraph.edgeSet_replaceVertex_of_not_adj","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst✝ : DecidableEq V\nhn : Not (G.Adj s t)\n⊢ Eq (G.replaceVertex s t).edgeSet (Union.union (SDiff.sdiff G.edgeSet (G.incidenceSet t)) (Set.image (fun x => Sym2.mk { fst := x, snd := t }) (G.neighborSet s)))","decl":"theorem edgeSet_replaceVertex_of_not_adj (hn : ¬G.Adj s t) : (G.replaceVertex s t).edgeSet =\n    G.edgeSet \\ G.incidenceSet t ∪ (s(·, t)) '' (G.neighborSet s) := by\n  ext e; refine e.inductionOn ?_\n  simp only [replaceVertex, mem_edgeSet, Set.mem_union, Set.mem_diff, mk'_mem_incidenceSet_iff]\n  intros; split_ifs; exacts [by simp_all, by aesop, by rw [adj_comm]; aesop, by aesop]\n\n"}
{"name":"SimpleGraph.edgeSet_replaceVertex_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst✝ : DecidableEq V\nha : G.Adj s t\n⊢ Eq (G.replaceVertex s t).edgeSet (SDiff.sdiff (Union.union (SDiff.sdiff G.edgeSet (G.incidenceSet t)) (Set.image (fun x => Sym2.mk { fst := x, snd := t }) (G.neighborSet s))) (Singleton.singleton (Sym2.mk { fst := t, snd := t })))","decl":"theorem edgeSet_replaceVertex_of_adj (ha : G.Adj s t) : (G.replaceVertex s t).edgeSet =\n    (G.edgeSet \\ G.incidenceSet t ∪ (s(·, t)) '' (G.neighborSet s)) \\ {s(t, t)} := by\n  ext e; refine e.inductionOn ?_\n  simp only [replaceVertex, mem_edgeSet, Set.mem_union, Set.mem_diff, mk'_mem_incidenceSet_iff]\n  intros; split_ifs; exacts [by simp_all, by aesop, by rw [adj_comm]; aesop, by aesop]\n\n"}
{"name":"SimpleGraph.edgeFinset_replaceVertex_of_not_adj","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst✝² : DecidableEq V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nhn : Not (G.Adj s t)\n⊢ Eq (G.replaceVertex s t).edgeFinset (Union.union (SDiff.sdiff G.edgeFinset (G.incidenceFinset t)) (Finset.image (fun x => Sym2.mk { fst := x, snd := t }) (G.neighborFinset s)))","decl":"theorem edgeFinset_replaceVertex_of_not_adj (hn : ¬G.Adj s t) : (G.replaceVertex s t).edgeFinset =\n    G.edgeFinset \\ G.incidenceFinset t ∪ (G.neighborFinset s).image (s(·, t)) := by\n  simp only [incidenceFinset, neighborFinset, ← Set.toFinset_diff, ← Set.toFinset_image,\n    ← Set.toFinset_union]\n  exact Set.toFinset_congr (G.edgeSet_replaceVertex_of_not_adj hn)\n\n"}
{"name":"SimpleGraph.edgeFinset_replaceVertex_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst✝² : DecidableEq V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nha : G.Adj s t\n⊢ Eq (G.replaceVertex s t).edgeFinset (SDiff.sdiff (Union.union (SDiff.sdiff G.edgeFinset (G.incidenceFinset t)) (Finset.image (fun x => Sym2.mk { fst := x, snd := t }) (G.neighborFinset s))) (Singleton.singleton (Sym2.mk { fst := t, snd := t })))","decl":"theorem edgeFinset_replaceVertex_of_adj (ha : G.Adj s t) : (G.replaceVertex s t).edgeFinset =\n    (G.edgeFinset \\ G.incidenceFinset t ∪ (G.neighborFinset s).image (s(·, t))) \\ {s(t, t)} := by\n  simp only [incidenceFinset, neighborFinset, ← Set.toFinset_diff, ← Set.toFinset_image,\n    ← Set.toFinset_union, ← Set.toFinset_singleton]\n  exact Set.toFinset_congr (G.edgeSet_replaceVertex_of_adj ha)\n\n"}
{"name":"SimpleGraph.disjoint_sdiff_neighborFinset_image","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst✝² : DecidableEq V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\n⊢ Disjoint (SDiff.sdiff G.edgeFinset (G.incidenceFinset t)) (Finset.image (fun x => Sym2.mk { fst := x, snd := t }) (G.neighborFinset s))","decl":"lemma disjoint_sdiff_neighborFinset_image :\n    Disjoint (G.edgeFinset \\ G.incidenceFinset t) ((G.neighborFinset s).image (s(·, t))) := by\n  rw [disjoint_iff_ne]\n  intro e he\n  have : t ∉ e := by\n    rw [mem_sdiff, mem_incidenceFinset] at he\n    obtain ⟨_, h⟩ := he\n    contrapose! h\n    simp_all [incidenceSet]\n  aesop\n\n"}
{"name":"SimpleGraph.card_edgeFinset_replaceVertex_of_not_adj","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst✝² : DecidableEq V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nhn : Not (G.Adj s t)\n⊢ Eq (G.replaceVertex s t).edgeFinset.card (HSub.hSub (HAdd.hAdd G.edgeFinset.card (G.degree s)) (G.degree t))","decl":"theorem card_edgeFinset_replaceVertex_of_not_adj (hn : ¬G.Adj s t) :\n    #(G.replaceVertex s t).edgeFinset = #G.edgeFinset + G.degree s - G.degree t := by\n  have inc : G.incidenceFinset t ⊆ G.edgeFinset := by simp [incidenceFinset, incidenceSet_subset]\n  rw [G.edgeFinset_replaceVertex_of_not_adj hn,\n    card_union_of_disjoint G.disjoint_sdiff_neighborFinset_image, card_sdiff inc,\n    ← Nat.sub_add_comm <| card_le_card inc, card_incidenceFinset_eq_degree]\n  congr 2\n  rw [card_image_of_injective, card_neighborFinset_eq_degree]\n  unfold Function.Injective\n  aesop\n\n"}
{"name":"SimpleGraph.card_edgeFinset_replaceVertex_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst✝² : DecidableEq V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nha : G.Adj s t\n⊢ Eq (G.replaceVertex s t).edgeFinset.card (HSub.hSub (HSub.hSub (HAdd.hAdd G.edgeFinset.card (G.degree s)) (G.degree t)) 1)","decl":"theorem card_edgeFinset_replaceVertex_of_adj (ha : G.Adj s t) :\n    #(G.replaceVertex s t).edgeFinset = #G.edgeFinset + G.degree s - G.degree t - 1 := by\n  have inc : G.incidenceFinset t ⊆ G.edgeFinset := by simp [incidenceFinset, incidenceSet_subset]\n  rw [G.edgeFinset_replaceVertex_of_adj ha, card_sdiff (by simp [ha]),\n    card_union_of_disjoint G.disjoint_sdiff_neighborFinset_image, card_sdiff inc,\n    ← Nat.sub_add_comm <| card_le_card inc, card_incidenceFinset_eq_degree]\n  congr 2\n  rw [card_image_of_injective, card_neighborFinset_eq_degree]\n  unfold Function.Injective\n  aesop\n\n"}
{"name":"SimpleGraph.edge_adj","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\ns t v w : V\n⊢ Iff ((SimpleGraph.edge s t).Adj v w) (And (Or (And (Eq v s) (Eq w t)) (And (Eq v t) (Eq w s))) (Ne v w))","decl":"lemma edge_adj (v w : V) : (edge s t).Adj v w ↔ (v = s ∧ w = t ∨ v = t ∧ w = s) ∧ v ≠ w := by\n  rw [edge, fromEdgeSet_adj, Set.mem_singleton_iff, Sym2.eq_iff]\n\n"}
{"name":"SimpleGraph.edge_comm","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\ns t : V\n⊢ Eq (SimpleGraph.edge s t) (SimpleGraph.edge t s)","decl":"lemma edge_comm : edge s t = edge t s := by\n  rw [edge, edge, Sym2.eq_swap]\n\n"}
{"name":"SimpleGraph.edge_self_eq_bot","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\ns : V\n⊢ Eq (SimpleGraph.edge s s) Bot.bot","decl":"lemma edge_self_eq_bot : edge s s = ⊥ := by\n  ext; rw [edge_adj]; aesop\n\n"}
{"name":"SimpleGraph.sup_edge_self","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns : V\n⊢ Eq (Max.max G (SimpleGraph.edge s s)) G","decl":"@[simp]\nlemma sup_edge_self : G ⊔ edge s s = G := by\n  rw [edge_self_eq_bot, sup_of_le_left bot_le]\n\n"}
{"name":"SimpleGraph.lt_sup_edge","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\nhne : Ne s t\nhn : Not (G.Adj s t)\n⊢ LT.lt G (Max.max G (SimpleGraph.edge s t))","decl":"lemma lt_sup_edge (hne : s ≠ t) (hn : ¬ G.Adj s t) : G < G ⊔ edge s t :=\n  left_lt_sup.2 fun h ↦ hn <| h <| (edge_adj ..).mpr ⟨Or.inl ⟨rfl, rfl⟩, hne⟩\n\n"}
{"name":"SimpleGraph.edge_edgeSet_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\ns t : V\nh : Ne s t\n⊢ Eq (SimpleGraph.edge s t).edgeSet (Singleton.singleton (Sym2.mk { fst := s, snd := t }))","decl":"lemma edge_edgeSet_of_ne (h : s ≠ t) : (edge s t).edgeSet = {s(s, t)} := by\n  rwa [edge, edgeSet_fromEdgeSet, sdiff_eq_left, Set.disjoint_singleton_left, Set.mem_setOf_eq,\n    Sym2.isDiag_iff_proj_eq]\n\n"}
{"name":"SimpleGraph.sup_edge_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\nh : G.Adj s t\n⊢ Eq (Max.max G (SimpleGraph.edge s t)) G","decl":"lemma sup_edge_of_adj (h : G.Adj s t) : G ⊔ edge s t = G := by\n  rwa [sup_eq_left, ← edgeSet_subset_edgeSet, edge_edgeSet_of_ne h.ne, Set.singleton_subset_iff,\n    mem_edgeSet]\n\n"}
{"name":"SimpleGraph.Subgraph.spanningCoe_sup_edge_le","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\nH : (Max.max G (SimpleGraph.edge s t)).Subgraph\nh : Not (H.Adj s t)\n⊢ LE.le H.spanningCoe G","decl":"theorem Subgraph.spanningCoe_sup_edge_le {H : Subgraph (G ⊔ edge s t)} (h : ¬ H.Adj s t) :\n    H.spanningCoe ≤ G := by\n  intro v w hvw\n  have := hvw.adj_sub\n  simp only [Subgraph.spanningCoe_adj, SimpleGraph.sup_adj, SimpleGraph.edge_adj] at *\n  by_cases hs : s(v, w) = s(s, t)\n  · exact (h ((Subgraph.adj_congr_of_sym2 hs).mp hvw)).elim\n  · aesop\n\n"}
{"name":"SimpleGraph.edgeFinset_sup_edge","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst✝² : Fintype V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : Fintype ↑(Max.max G (SimpleGraph.edge s t)).edgeSet\nhn : Not (G.Adj s t)\nh : Ne s t\n⊢ Eq (Max.max G (SimpleGraph.edge s t)).edgeFinset (Finset.cons (Sym2.mk { fst := s, snd := t }) G.edgeFinset ⋯)","decl":"theorem edgeFinset_sup_edge [Fintype (edgeSet (G ⊔ edge s t))] (hn : ¬G.Adj s t) (h : s ≠ t) :\n    (G ⊔ edge s t).edgeFinset = G.edgeFinset.cons s(s, t) (by simp_all) := by\n  letI := Classical.decEq V\n  rw [edgeFinset_sup, cons_eq_insert, insert_eq, union_comm]\n  simp_rw [edgeFinset, edge_edgeSet_of_ne h]; rfl\n\n"}
{"name":"SimpleGraph.card_edgeFinset_sup_edge","module":"Mathlib.Combinatorics.SimpleGraph.Operations","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns t : V\ninst✝² : Fintype V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : Fintype ↑(Max.max G (SimpleGraph.edge s t)).edgeSet\nhn : Not (G.Adj s t)\nh : Ne s t\n⊢ Eq (Max.max G (SimpleGraph.edge s t)).edgeFinset.card (HAdd.hAdd G.edgeFinset.card 1)","decl":"theorem card_edgeFinset_sup_edge [Fintype (edgeSet (G ⊔ edge s t))] (hn : ¬G.Adj s t) (h : s ≠ t) :\n    #(G ⊔ edge s t).edgeFinset = #G.edgeFinset + 1 := by\n  rw [G.edgeFinset_sup_edge hn h, card_cons]\n\n"}
