{"name":"Submodule.map_coe","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective σ₁₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\np : Submodule R M\n⊢ Eq (↑(Submodule.map f p)) (Set.image ⇑f ↑p)","decl":"@[simp]\ntheorem map_coe (f : F) (p : Submodule R M) : (map f p : Set M₂) = f '' p :=\n  rfl\n\n"}
{"name":"Submodule.map_toAddSubmonoid","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective σ₁₂\nf : LinearMap σ₁₂ M M₂\np : Submodule R M\n⊢ Eq (Submodule.map f p).toAddSubmonoid (AddSubmonoid.map (↑f) p.toAddSubmonoid)","decl":"theorem map_toAddSubmonoid (f : M →ₛₗ[σ₁₂] M₂) (p : Submodule R M) :\n    (p.map f).toAddSubmonoid = p.toAddSubmonoid.map (f : M →+ M₂) :=\n  SetLike.coe_injective rfl\n\n"}
{"name":"Submodule.map_toAddSubmonoid'","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective σ₁₂\nf : LinearMap σ₁₂ M M₂\np : Submodule R M\n⊢ Eq (Submodule.map f p).toAddSubmonoid (AddSubmonoid.map f p.toAddSubmonoid)","decl":"theorem map_toAddSubmonoid' (f : M →ₛₗ[σ₁₂] M₂) (p : Submodule R M) :\n    (p.map f).toAddSubmonoid = p.toAddSubmonoid.map f :=\n  SetLike.coe_injective rfl\n\n"}
{"name":"AddMonoidHom.coe_toIntLinearMap_map","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"A : Type u_10\nA₂ : Type u_11\ninst✝¹ : AddCommGroup A\ninst✝ : AddCommGroup A₂\nf : AddMonoidHom A A₂\ns : AddSubgroup A\n⊢ Eq (Submodule.map f.toIntLinearMap (AddSubgroup.toIntSubmodule s)) (AddSubgroup.toIntSubmodule (AddSubgroup.map f s))","decl":"@[simp]\ntheorem _root_.AddMonoidHom.coe_toIntLinearMap_map {A A₂ : Type*} [AddCommGroup A] [AddCommGroup A₂]\n    (f : A →+ A₂) (s : AddSubgroup A) :\n    (AddSubgroup.toIntSubmodule s).map f.toIntLinearMap =\n      AddSubgroup.toIntSubmodule (s.map f) := rfl\n\n"}
{"name":"MonoidHom.coe_toAdditive_map","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"G : Type u_10\nG₂ : Type u_11\ninst✝¹ : Group G\ninst✝ : Group G₂\nf : MonoidHom G G₂\ns : Subgroup G\n⊢ Eq (AddSubgroup.map (MonoidHom.toAdditive f) (Subgroup.toAddSubgroup s)) (Subgroup.toAddSubgroup (Subgroup.map f s))","decl":"@[simp]\ntheorem _root_.MonoidHom.coe_toAdditive_map {G G₂ : Type*} [Group G] [Group G₂] (f : G →* G₂)\n    (s : Subgroup G) :\n    s.toAddSubgroup.map (MonoidHom.toAdditive f) = Subgroup.toAddSubgroup (s.map f) := rfl\n\n"}
{"name":"AddMonoidHom.coe_toMultiplicative_map","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"G : Type u_10\nG₂ : Type u_11\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G₂\nf : AddMonoidHom G G₂\ns : AddSubgroup G\n⊢ Eq (Subgroup.map (AddMonoidHom.toMultiplicative f) (AddSubgroup.toSubgroup s)) (AddSubgroup.toSubgroup (AddSubgroup.map f s))","decl":"@[simp]\ntheorem _root_.AddMonoidHom.coe_toMultiplicative_map {G G₂ : Type*} [AddGroup G] [AddGroup G₂]\n    (f : G →+ G₂) (s : AddSubgroup G) :\n    s.toSubgroup.map (AddMonoidHom.toMultiplicative f) = AddSubgroup.toSubgroup (s.map f) := rfl\n\n"}
{"name":"Submodule.mem_map","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective σ₁₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\np : Submodule R M\nx : M₂\n⊢ Iff (Membership.mem (Submodule.map f p) x) (Exists fun y => And (Membership.mem p y) (Eq (f y) x))","decl":"@[simp]\ntheorem mem_map {f : F} {p : Submodule R M} {x : M₂} : x ∈ map f p ↔ ∃ y, y ∈ p ∧ f y = x :=\n  Iff.rfl\n\n"}
{"name":"Submodule.mem_map_of_mem","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective σ₁₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\np : Submodule R M\nr : M\nh : Membership.mem p r\n⊢ Membership.mem (Submodule.map f p) (f r)","decl":"theorem mem_map_of_mem {f : F} {p : Submodule R M} {r} (h : r ∈ p) : f r ∈ map f p :=\n  Set.mem_image_of_mem _ h\n\n"}
{"name":"Submodule.apply_coe_mem_map","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective σ₁₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\np : Submodule R M\nr : Subtype fun x => Membership.mem p x\n⊢ Membership.mem (Submodule.map f p) (f ↑r)","decl":"theorem apply_coe_mem_map (f : F) {p : Submodule R M} (r : p) : f r ∈ map f p :=\n  mem_map_of_mem r.prop\n\n"}
{"name":"Submodule.map_id","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (Submodule.map LinearMap.id p) p","decl":"@[simp]\ntheorem map_id : map (LinearMap.id : M →ₗ[R] M) p = p :=\n  Submodule.ext fun a => by simp\n\n"}
{"name":"Submodule.map_comp","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nR₃ : Type u_4\nM : Type u_5\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝¹² : Semiring R\ninst✝¹¹ : Semiring R₂\ninst✝¹⁰ : Semiring R₃\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : AddCommMonoid M₃\ninst✝⁶ : Module R M\ninst✝⁵ : Module R₂ M₂\ninst✝⁴ : Module R₃ M₃\nσ₁₂ : RingHom R R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R R₃\ninst✝³ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝² : RingHomSurjective σ₁₂\ninst✝¹ : RingHomSurjective σ₂₃\ninst✝ : RingHomSurjective σ₁₃\nf : LinearMap σ₁₂ M M₂\ng : LinearMap σ₂₃ M₂ M₃\np : Submodule R M\n⊢ Eq (Submodule.map (g.comp f) p) (Submodule.map g (Submodule.map f p))","decl":"theorem map_comp [RingHomSurjective σ₂₃] [RingHomSurjective σ₁₃] (f : M →ₛₗ[σ₁₂] M₂)\n    (g : M₂ →ₛₗ[σ₂₃] M₃) (p : Submodule R M) : map (g.comp f : M →ₛₗ[σ₁₃] M₃) p = map g (map f p) :=\n  SetLike.coe_injective <| by simp only [← image_comp, map_coe, LinearMap.coe_comp, comp_apply]\n\n"}
{"name":"Submodule.map_mono","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective σ₁₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\np p' : Submodule R M\na✝ : LE.le p p'\n⊢ LE.le (Submodule.map f p) (Submodule.map f p')","decl":"@[gcongr]\ntheorem map_mono {f : F} {p p' : Submodule R M} : p ≤ p' → map f p ≤ map f p' :=\n  image_subset _\n\n"}
{"name":"Submodule.map_zero","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\np : Submodule R M\ninst✝ : RingHomSurjective σ₁₂\n⊢ Eq (Submodule.map 0 p) Bot.bot","decl":"@[simp]\nprotected theorem map_zero : map (0 : M →ₛₗ[σ₁₂] M₂) p = ⊥ :=\n  have : ∃ x : M, x ∈ p := ⟨0, p.zero_mem⟩\n  ext <| by simp [this, eq_comm]\n\n"}
{"name":"Submodule.map_add_le","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\np : Submodule R M\ninst✝ : RingHomSurjective σ₁₂\nf g : LinearMap σ₁₂ M M₂\n⊢ LE.le (Submodule.map (HAdd.hAdd f g) p) (Max.max (Submodule.map f p) (Submodule.map g p))","decl":"theorem map_add_le (f g : M →ₛₗ[σ₁₂] M₂) : map (f + g) p ≤ map f p ⊔ map g p := by\n  rintro x ⟨m, hm, rfl⟩\n  exact add_mem_sup (mem_map_of_mem hm) (mem_map_of_mem hm)\n\n"}
{"name":"Submodule.map_inf_le","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective σ₁₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\np q : Submodule R M\n⊢ LE.le (Submodule.map f (Min.min p q)) (Min.min (Submodule.map f p) (Submodule.map f q))","decl":"theorem map_inf_le (f : F) {p q : Submodule R M} :\n    (p ⊓ q).map f ≤ p.map f ⊓ q.map f :=\n  image_inter_subset f p q\n\n"}
{"name":"Submodule.map_inf","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective σ₁₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\np q : Submodule R M\nhf : Function.Injective ⇑f\n⊢ Eq (Submodule.map f (Min.min p q)) (Min.min (Submodule.map f p) (Submodule.map f q))","decl":"theorem map_inf (f : F) {p q : Submodule R M} (hf : Injective f) :\n    (p ⊓ q).map f = p.map f ⊓ q.map f :=\n  SetLike.coe_injective <| Set.image_inter hf\n\n"}
{"name":"Submodule.map_iInf","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M\ninst✝⁴ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝³ : RingHomSurjective σ₁₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\nι : Type u_10\ninst✝ : Nonempty ι\np : ι → Submodule R M\nf : F\nhf : Function.Injective ⇑f\n⊢ Eq (Submodule.map f (iInf fun i => p i)) (iInf fun i => Submodule.map f (p i))","decl":"lemma map_iInf {ι : Type*} [Nonempty ι] {p : ι → Submodule R M} (f : F) (hf : Injective f) :\n    (⨅ i, p i).map f = ⨅ i, (p i).map f :=\n  SetLike.coe_injective <| by simpa only [map_coe, iInf_coe] using hf.injOn.image_iInter_eq\n\n"}
{"name":"Submodule.range_map_nonempty","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring R₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝ : RingHomSurjective σ₁₂\nN : Submodule R M\n⊢ (Set.range fun ϕ => Submodule.map ϕ N).Nonempty","decl":"theorem range_map_nonempty (N : Submodule R M) :\n    (Set.range (fun ϕ => Submodule.map ϕ N : (M →ₛₗ[σ₁₂] M₂) → Submodule R₂ M₂)).Nonempty :=\n  ⟨_, Set.mem_range.mpr ⟨0, rfl⟩⟩\n\n"}
{"name":"Submodule.coe_equivMapOfInjective_apply","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M\ninst✝⁴ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\ninst✝³ : RingHomInvPair σ₁₂ σ₂₁\ninst✝² : RingHomInvPair σ₂₁ σ₁₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\ni : Function.Injective ⇑f\np : Submodule R M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑((Submodule.equivMapOfInjective f i p) x)) (f ↑x)","decl":"@[simp]\ntheorem coe_equivMapOfInjective_apply (f : F) (i : Injective f) (p : Submodule R M) (x : p) :\n    (equivMapOfInjective f i p x : M₂) = f x :=\n  rfl\n\n"}
{"name":"Submodule.map_equivMapOfInjective_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M\ninst✝⁴ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\ninst✝³ : RingHomInvPair σ₁₂ σ₂₁\ninst✝² : RingHomInvPair σ₂₁ σ₁₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\ni : Function.Injective ⇑f\np : Submodule R M\nx : Subtype fun x => Membership.mem (Submodule.map f p) x\n⊢ Eq (f ↑((Submodule.equivMapOfInjective f i p).symm x)) ↑x","decl":"@[simp]\ntheorem map_equivMapOfInjective_symm_apply (f : F) (i : Injective f) (p : Submodule R M)\n    (x : p.map f) : f ((equivMapOfInjective f i p).symm x) = x := by\n  rw [← LinearEquiv.apply_symm_apply (equivMapOfInjective f i p) x, coe_equivMapOfInjective_apply,\n    i.eq_iff, LinearEquiv.apply_symm_apply]\n\n"}
{"name":"Submodule.comap_coe","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\np : Submodule R₂ M₂\n⊢ Eq (↑(Submodule.comap f p)) (Set.preimage ⇑f ↑p)","decl":"@[simp]\ntheorem comap_coe (f : F) (p : Submodule R₂ M₂) : (comap f p : Set M) = f ⁻¹' p :=\n  rfl\n\n"}
{"name":"Submodule.AddMonoidHom.coe_toIntLinearMap_comap","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"A : Type u_10\nA₂ : Type u_11\ninst✝¹ : AddCommGroup A\ninst✝ : AddCommGroup A₂\nf : AddMonoidHom A A₂\ns : AddSubgroup A₂\n⊢ Eq (Submodule.comap f.toIntLinearMap (AddSubgroup.toIntSubmodule s)) (AddSubgroup.toIntSubmodule (AddSubgroup.comap f s))","decl":"@[simp]\ntheorem AddMonoidHom.coe_toIntLinearMap_comap {A A₂ : Type*} [AddCommGroup A] [AddCommGroup A₂]\n    (f : A →+ A₂) (s : AddSubgroup A₂) :\n    (AddSubgroup.toIntSubmodule s).comap f.toIntLinearMap =\n      AddSubgroup.toIntSubmodule (s.comap f) := rfl\n\n"}
{"name":"Submodule.mem_comap","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nx : M\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\np : Submodule R₂ M₂\n⊢ Iff (Membership.mem (Submodule.comap f p) x) (Membership.mem p (f x))","decl":"@[simp]\ntheorem mem_comap {f : F} {p : Submodule R₂ M₂} : x ∈ comap f p ↔ f x ∈ p :=\n  Iff.rfl\n\n"}
{"name":"Submodule.comap_id","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\n⊢ Eq (Submodule.comap LinearMap.id p) p","decl":"@[simp]\ntheorem comap_id : comap (LinearMap.id : M →ₗ[R] M) p = p :=\n  SetLike.coe_injective rfl\n\n"}
{"name":"Submodule.comap_comp","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nR₃ : Type u_4\nM : Type u_5\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\ninst✝¹ : Module R₃ M₃\nσ₁₂ : RingHom R R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R R₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nf : LinearMap σ₁₂ M M₂\ng : LinearMap σ₂₃ M₂ M₃\np : Submodule R₃ M₃\n⊢ Eq (Submodule.comap (g.comp f) p) (Submodule.comap f (Submodule.comap g p))","decl":"theorem comap_comp (f : M →ₛₗ[σ₁₂] M₂) (g : M₂ →ₛₗ[σ₂₃] M₃) (p : Submodule R₃ M₃) :\n    comap (g.comp f : M →ₛₗ[σ₁₃] M₃) p = comap f (comap g p) :=\n  rfl\n\n"}
{"name":"Submodule.comap_mono","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\nq q' : Submodule R₂ M₂\na✝ : LE.le q q'\n⊢ LE.le (Submodule.comap f q) (Submodule.comap f q')","decl":"@[gcongr]\ntheorem comap_mono {f : F} {q q' : Submodule R₂ M₂} : q ≤ q' → comap f q ≤ comap f q' :=\n  preimage_mono\n\n"}
{"name":"Submodule.le_comap_pow_of_le_comap","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\nf : LinearMap (RingHom.id R) M M\nh : LE.le p (Submodule.comap f p)\nk : Nat\n⊢ LE.le p (Submodule.comap (HPow.hPow f k) p)","decl":"theorem le_comap_pow_of_le_comap (p : Submodule R M) {f : M →ₗ[R] M} (h : p ≤ p.comap f) (k : ℕ) :\n    p ≤ p.comap (f ^ k) := by\n  induction k with\n  | zero => simp [LinearMap.one_eq_id]\n  | succ k ih => simp [LinearMap.iterate_succ, comap_comp, h.trans (comap_mono ih)]\n\n"}
{"name":"Submodule.map_le_iff_le_comap","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\np : Submodule R M\nq : Submodule R₂ M₂\n⊢ Iff (LE.le (Submodule.map f p) q) (LE.le p (Submodule.comap f q))","decl":"theorem map_le_iff_le_comap {f : F} {p : Submodule R M} {q : Submodule R₂ M₂} :\n    map f p ≤ q ↔ p ≤ comap f q :=\n  image_subset_iff\n\n"}
{"name":"Submodule.gc_map_comap","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\n⊢ GaloisConnection (Submodule.map f) (Submodule.comap f)","decl":"theorem gc_map_comap (f : F) : GaloisConnection (map f) (comap f)\n  | _, _ => map_le_iff_le_comap\n\n"}
{"name":"Submodule.map_bot","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\n⊢ Eq (Submodule.map f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem map_bot (f : F) : map f ⊥ = ⊥ :=\n  (gc_map_comap f).l_bot\n\n"}
{"name":"Submodule.map_sup","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\np p' : Submodule R M\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\n⊢ Eq (Submodule.map f (Max.max p p')) (Max.max (Submodule.map f p) (Submodule.map f p'))","decl":"@[simp]\ntheorem map_sup (f : F) : map f (p ⊔ p') = map f p ⊔ map f p' :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_sup\n\n"}
{"name":"Submodule.map_iSup","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nι : Sort u_10\nf : F\np : ι → Submodule R M\n⊢ Eq (Submodule.map f (iSup fun i => p i)) (iSup fun i => Submodule.map f (p i))","decl":"@[simp]\ntheorem map_iSup {ι : Sort*} (f : F) (p : ι → Submodule R M) :\n    map f (⨆ i, p i) = ⨆ i, map f (p i) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_iSup\n\n"}
{"name":"Submodule.comap_top","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\n⊢ Eq (Submodule.comap f Top.top) Top.top","decl":"@[simp]\ntheorem comap_top (f : F) : comap f ⊤ = ⊤ :=\n  rfl\n\n"}
{"name":"Submodule.comap_inf","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nq q' : Submodule R₂ M₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\n⊢ Eq (Submodule.comap f (Min.min q q')) (Min.min (Submodule.comap f q) (Submodule.comap f q'))","decl":"@[simp]\ntheorem comap_inf (f : F) : comap f (q ⊓ q') = comap f q ⊓ comap f q' :=\n  rfl\n\n"}
{"name":"Submodule.comap_iInf","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nι : Sort u_10\nf : F\np : ι → Submodule R₂ M₂\n⊢ Eq (Submodule.comap f (iInf fun i => p i)) (iInf fun i => Submodule.comap f (p i))","decl":"@[simp]\ntheorem comap_iInf [RingHomSurjective σ₁₂] {ι : Sort*} (f : F) (p : ι → Submodule R₂ M₂) :\n    comap f (⨅ i, p i) = ⨅ i, comap f (p i) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_iInf\n\n"}
{"name":"Submodule.comap_zero","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nq : Submodule R₂ M₂\n⊢ Eq (Submodule.comap 0 q) Top.top","decl":"@[simp]\ntheorem comap_zero : comap (0 : M →ₛₗ[σ₁₂] M₂) q = ⊤ :=\n  ext <| by simp\n\n"}
{"name":"Submodule.map_comap_le","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nq : Submodule R₂ M₂\n⊢ LE.le (Submodule.map f (Submodule.comap f q)) q","decl":"theorem map_comap_le [RingHomSurjective σ₁₂] (f : F) (q : Submodule R₂ M₂) :\n    map f (comap f q) ≤ q :=\n  (gc_map_comap f).l_u_le _\n\n"}
{"name":"Submodule.le_comap_map","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\np : Submodule R M\n⊢ LE.le p (Submodule.comap f (Submodule.map f p))","decl":"theorem le_comap_map [RingHomSurjective σ₁₂] (f : F) (p : Submodule R M) : p ≤ comap f (map f p) :=\n  (gc_map_comap f).le_u_l _\n\n"}
{"name":"Submodule.map_comap_eq_of_surjective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Surjective ⇑f\np : Submodule R₂ M₂\n⊢ Eq (Submodule.map f (Submodule.comap f p)) p","decl":"theorem map_comap_eq_of_surjective (p : Submodule R₂ M₂) : (p.comap f).map f = p :=\n  (giMapComap hf).l_u_eq _\n\n"}
{"name":"Submodule.map_surjective_of_surjective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective (Submodule.map f)","decl":"theorem map_surjective_of_surjective : Function.Surjective (map f) :=\n  (giMapComap hf).l_surjective\n\n"}
{"name":"Submodule.comap_injective_of_surjective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Surjective ⇑f\n⊢ Function.Injective (Submodule.comap f)","decl":"theorem comap_injective_of_surjective : Function.Injective (comap f) :=\n  (giMapComap hf).u_injective\n\n"}
{"name":"Submodule.map_sup_comap_of_surjective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Surjective ⇑f\np q : Submodule R₂ M₂\n⊢ Eq (Submodule.map f (Max.max (Submodule.comap f p) (Submodule.comap f q))) (Max.max p q)","decl":"theorem map_sup_comap_of_surjective (p q : Submodule R₂ M₂) :\n    (p.comap f ⊔ q.comap f).map f = p ⊔ q :=\n  (giMapComap hf).l_sup_u _ _\n\n"}
{"name":"Submodule.map_iSup_comap_of_sujective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Surjective ⇑f\nι : Sort u_10\nS : ι → Submodule R₂ M₂\n⊢ Eq (Submodule.map f (iSup fun i => Submodule.comap f (S i))) (iSup S)","decl":"theorem map_iSup_comap_of_sujective {ι : Sort*} (S : ι → Submodule R₂ M₂) :\n    (⨆ i, (S i).comap f).map f = iSup S :=\n  (giMapComap hf).l_iSup_u _\n\n"}
{"name":"Submodule.map_inf_comap_of_surjective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Surjective ⇑f\np q : Submodule R₂ M₂\n⊢ Eq (Submodule.map f (Min.min (Submodule.comap f p) (Submodule.comap f q))) (Min.min p q)","decl":"theorem map_inf_comap_of_surjective (p q : Submodule R₂ M₂) :\n    (p.comap f ⊓ q.comap f).map f = p ⊓ q :=\n  (giMapComap hf).l_inf_u _ _\n\n"}
{"name":"Submodule.map_iInf_comap_of_surjective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Surjective ⇑f\nι : Sort u_10\nS : ι → Submodule R₂ M₂\n⊢ Eq (Submodule.map f (iInf fun i => Submodule.comap f (S i))) (iInf S)","decl":"theorem map_iInf_comap_of_surjective {ι : Sort*} (S : ι → Submodule R₂ M₂) :\n    (⨅ i, (S i).comap f).map f = iInf S :=\n  (giMapComap hf).l_iInf_u _\n\n"}
{"name":"Submodule.comap_le_comap_iff_of_surjective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Surjective ⇑f\np q : Submodule R₂ M₂\n⊢ Iff (LE.le (Submodule.comap f p) (Submodule.comap f q)) (LE.le p q)","decl":"theorem comap_le_comap_iff_of_surjective {p q : Submodule R₂ M₂} : p.comap f ≤ q.comap f ↔ p ≤ q :=\n  (giMapComap hf).u_le_u_iff\n\n"}
{"name":"Submodule.comap_lt_comap_iff_of_surjective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Surjective ⇑f\np q : Submodule R₂ M₂\n⊢ Iff (LT.lt (Submodule.comap f p) (Submodule.comap f q)) (LT.lt p q)","decl":"lemma comap_lt_comap_iff_of_surjective {p q : Submodule R₂ M₂} : p.comap f < q.comap f ↔ p < q := by\n  apply lt_iff_lt_of_le_iff_le' <;> exact comap_le_comap_iff_of_surjective hf\n\n"}
{"name":"Submodule.comap_strictMono_of_surjective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Surjective ⇑f\n⊢ StrictMono (Submodule.comap f)","decl":"theorem comap_strictMono_of_surjective : StrictMono (comap f) :=\n  (giMapComap hf).strictMono_u\n\n"}
{"name":"Submodule.comap_map_eq_of_injective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Injective ⇑f\np : Submodule R M\n⊢ Eq (Submodule.comap f (Submodule.map f p)) p","decl":"theorem comap_map_eq_of_injective (p : Submodule R M) : (p.map f).comap f = p :=\n  (gciMapComap hf).u_l_eq _\n\n"}
{"name":"Submodule.comap_surjective_of_injective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Injective ⇑f\n⊢ Function.Surjective (Submodule.comap f)","decl":"theorem comap_surjective_of_injective : Function.Surjective (comap f) :=\n  (gciMapComap hf).u_surjective\n\n"}
{"name":"Submodule.map_injective_of_injective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Injective ⇑f\n⊢ Function.Injective (Submodule.map f)","decl":"theorem map_injective_of_injective : Function.Injective (map f) :=\n  (gciMapComap hf).l_injective\n\n"}
{"name":"Submodule.comap_inf_map_of_injective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Injective ⇑f\np q : Submodule R M\n⊢ Eq (Submodule.comap f (Min.min (Submodule.map f p) (Submodule.map f q))) (Min.min p q)","decl":"theorem comap_inf_map_of_injective (p q : Submodule R M) : (p.map f ⊓ q.map f).comap f = p ⊓ q :=\n  (gciMapComap hf).u_inf_l _ _\n\n"}
{"name":"Submodule.comap_iInf_map_of_injective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Injective ⇑f\nι : Sort u_10\nS : ι → Submodule R M\n⊢ Eq (Submodule.comap f (iInf fun i => Submodule.map f (S i))) (iInf S)","decl":"theorem comap_iInf_map_of_injective {ι : Sort*} (S : ι → Submodule R M) :\n    (⨅ i, (S i).map f).comap f = iInf S :=\n  (gciMapComap hf).u_iInf_l _\n\n"}
{"name":"Submodule.comap_sup_map_of_injective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Injective ⇑f\np q : Submodule R M\n⊢ Eq (Submodule.comap f (Max.max (Submodule.map f p) (Submodule.map f q))) (Max.max p q)","decl":"theorem comap_sup_map_of_injective (p q : Submodule R M) : (p.map f ⊔ q.map f).comap f = p ⊔ q :=\n  (gciMapComap hf).u_sup_l _ _\n\n"}
{"name":"Submodule.comap_iSup_map_of_injective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Injective ⇑f\nι : Sort u_10\nS : ι → Submodule R M\n⊢ Eq (Submodule.comap f (iSup fun i => Submodule.map f (S i))) (iSup S)","decl":"theorem comap_iSup_map_of_injective {ι : Sort*} (S : ι → Submodule R M) :\n    (⨆ i, (S i).map f).comap f = iSup S :=\n  (gciMapComap hf).u_iSup_l _\n\n"}
{"name":"Submodule.map_le_map_iff_of_injective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Injective ⇑f\np q : Submodule R M\n⊢ Iff (LE.le (Submodule.map f p) (Submodule.map f q)) (LE.le p q)","decl":"theorem map_le_map_iff_of_injective (p q : Submodule R M) : p.map f ≤ q.map f ↔ p ≤ q :=\n  (gciMapComap hf).l_le_l_iff\n\n"}
{"name":"Submodule.map_strictMono_of_injective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\nhf : Function.Injective ⇑f\n⊢ StrictMono (Submodule.map f)","decl":"theorem map_strictMono_of_injective : StrictMono (map f) :=\n  (gciMapComap hf).strictMono_l\n\n"}
{"name":"Submodule.orderIsoMapComapOfBijective_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective σ₁₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\nhf : Function.Bijective ⇑f\np : Submodule R₂ M₂\n⊢ Eq ((RelIso.symm (Submodule.orderIsoMapComapOfBijective f hf)) p) (Submodule.comap f p)","decl":"/-- A linear isomorphism induces an order isomorphism of submodules. -/\n@[simps symm_apply apply]\ndef orderIsoMapComapOfBijective [FunLike F M M₂] [SemilinearMapClass F σ₁₂ M M₂]\n    (f : F) (hf : Bijective f) : Submodule R M ≃o Submodule R₂ M₂ where\n  toFun := map f\n  invFun := comap f\n  left_inv := comap_map_eq_of_injective hf.injective\n  right_inv := map_comap_eq_of_surjective hf.surjective\n  map_rel_iff' := map_le_map_iff_of_injective hf.injective _ _\n\n"}
{"name":"Submodule.orderIsoMapComapOfBijective_apply","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective σ₁₂\nF : Type u_9\ninst✝¹ : FunLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\nhf : Function.Bijective ⇑f\np : Submodule R M\n⊢ Eq ((Submodule.orderIsoMapComapOfBijective f hf) p) (Submodule.map f p)","decl":"/-- A linear isomorphism induces an order isomorphism of submodules. -/\n@[simps symm_apply apply]\ndef orderIsoMapComapOfBijective [FunLike F M M₂] [SemilinearMapClass F σ₁₂ M M₂]\n    (f : F) (hf : Bijective f) : Submodule R M ≃o Submodule R₂ M₂ where\n  toFun := map f\n  invFun := comap f\n  left_inv := comap_map_eq_of_injective hf.injective\n  right_inv := map_comap_eq_of_surjective hf.surjective\n  map_rel_iff' := map_le_map_iff_of_injective hf.injective _ _\n\n"}
{"name":"Submodule.orderIsoMapComap_apply","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective σ₁₂\nF : Type u_9\ninst✝¹ : EquivLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\np : Submodule R M\n⊢ Eq ((Submodule.orderIsoMapComap f) p) (Submodule.map f p)","decl":"/-- A linear isomorphism induces an order isomorphism of submodules. -/\n@[simps! apply]\ndef orderIsoMapComap [EquivLike F M M₂] [SemilinearMapClass F σ₁₂ M M₂] (f : F) :\n    Submodule R M ≃o Submodule R₂ M₂ := orderIsoMapComapOfBijective f (EquivLike.bijective f)\n\n"}
{"name":"Submodule.orderIsoMapComap_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\ninst✝² : RingHomSurjective σ₁₂\nF : Type u_9\ninst✝¹ : EquivLike F M M₂\ninst✝ : SemilinearMapClass F σ₁₂ M M₂\nf : F\np : Submodule R₂ M₂\n⊢ Eq ((Submodule.orderIsoMapComap f).symm p) (Submodule.comap f p)","decl":"@[simp]\nlemma orderIsoMapComap_symm_apply [EquivLike F M M₂] [SemilinearMapClass F σ₁₂ M M₂]\n    (f : F) (p : Submodule R₂ M₂) :\n    (orderIsoMapComap f).symm p = comap f p :=\n  rfl\n\n"}
{"name":"Submodule.map_inf_eq_map_inf_comap","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nF : Type u_9\ninst✝² : FunLike F M M₂\ninst✝¹ : SemilinearMapClass F σ₁₂ M M₂\ninst✝ : RingHomSurjective σ₁₂\nf : F\np : Submodule R M\np' : Submodule R₂ M₂\n⊢ Eq (Min.min (Submodule.map f p) p') (Submodule.map f (Min.min p (Submodule.comap f p')))","decl":"theorem map_inf_eq_map_inf_comap [RingHomSurjective σ₁₂] {f : F} {p : Submodule R M}\n    {p' : Submodule R₂ M₂} : map f p ⊓ p' = map f (p ⊓ comap f p') :=\n  le_antisymm (by rintro _ ⟨⟨x, h₁, rfl⟩, h₂⟩; exact ⟨_, ⟨h₁, h₂⟩, rfl⟩)\n    (le_inf (map_mono inf_le_left) (map_le_iff_le_comap.2 inf_le_right))\n\n"}
{"name":"Submodule.map_comap_subtype","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np p' : Submodule R M\n⊢ Eq (Submodule.map p.subtype (Submodule.comap p.subtype p')) (Min.min p p')","decl":"@[simp]\ntheorem map_comap_subtype : map p.subtype (comap p.subtype p') = p ⊓ p' :=\n  ext fun x => ⟨by rintro ⟨⟨_, h₁⟩, h₂, rfl⟩; exact ⟨h₁, h₂⟩, fun ⟨h₁, h₂⟩ => ⟨⟨_, h₁⟩, h₂, rfl⟩⟩\n\n"}
{"name":"Submodule.eq_zero_of_bot_submodule","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Subtype fun x => Membership.mem Bot.bot x\n⊢ Eq b 0","decl":"theorem eq_zero_of_bot_submodule : ∀ b : (⊥ : Submodule R M), b = 0\n  | ⟨b', hb⟩ => Subtype.eq <| show b' = 0 from (mem_bot R).1 hb\n\n"}
{"name":"LinearMap.iInf_invariant","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nσ : RingHom R R\ninst✝ : RingHomSurjective σ\nι : Sort u_10\nf : LinearMap σ M M\np : ι → Submodule R M\nhf : ∀ (i : ι) (v : M), Membership.mem (p i) v → Membership.mem (p i) (f v)\nv : M\na✝ : Membership.mem (iInf p) v\n⊢ Membership.mem (iInf p) (f v)","decl":"/-- The infimum of a family of invariant submodule of an endomorphism is also an invariant\nsubmodule. -/\ntheorem _root_.LinearMap.iInf_invariant {σ : R →+* R} [RingHomSurjective σ] {ι : Sort*}\n    (f : M →ₛₗ[σ] M) {p : ι → Submodule R M} (hf : ∀ i, ∀ v ∈ p i, f v ∈ p i) :\n    ∀ v ∈ iInf p, f v ∈ iInf p := by\n  have : ∀ i, (p i).map f ≤ p i := by\n    rintro i - ⟨v, hv, rfl⟩\n    exact hf i v hv\n  suffices (iInf p).map f ≤ iInf p by exact fun v hv => this ⟨v, hv, rfl⟩\n  exact le_iInf fun i => (Submodule.map_mono (iInf_le p i)).trans (this i)\n\n"}
{"name":"Submodule.disjoint_iff_comap_eq_bot","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\n⊢ Iff (Disjoint p q) (Eq (Submodule.comap p.subtype q) Bot.bot)","decl":"theorem disjoint_iff_comap_eq_bot {p q : Submodule R M} : Disjoint p q ↔ comap p.subtype q = ⊥ := by\n  rw [← (map_injective_of_injective (show Injective p.subtype from Subtype.coe_injective)).eq_iff,\n    map_comap_subtype, map_bot, disjoint_iff]\n\n"}
{"name":"Submodule.map_neg","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\np : Submodule R M\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M M₂\n⊢ Eq (Submodule.map (Neg.neg f) p) (Submodule.map f p)","decl":"@[simp]\nprotected theorem map_neg (f : M →ₗ[R] M₂) : map (-f) p = map f p :=\n  ext fun _ =>\n    ⟨fun ⟨x, hx, hy⟩ => hy ▸ ⟨-x, show -x ∈ p from neg_mem hx, map_neg f x⟩, fun ⟨x, hx, hy⟩ =>\n      hy ▸ ⟨-x, show -x ∈ p from neg_mem hx, (map_neg (-f) _).trans (neg_neg (f x))⟩⟩\n\n"}
{"name":"Submodule.comap_neg","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M M₂\np : Submodule R M₂\n⊢ Eq (Submodule.comap (Neg.neg f) p) (Submodule.comap f p)","decl":"@[simp]\nlemma comap_neg {f : M →ₗ[R] M₂} {p : Submodule R M₂} :\n    p.comap (-f) = p.comap f := by\n  ext; simp\n\n"}
{"name":"Submodule.map_toAddSubgroup","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M M₂\np : Submodule R M\n⊢ Eq (Submodule.map f p).toAddSubgroup (AddSubgroup.map (↑f) p.toAddSubgroup)","decl":"lemma map_toAddSubgroup (f : M →ₗ[R] M₂) (p : Submodule R M) :\n    (p.map f).toAddSubgroup = p.toAddSubgroup.map (f : M →+ M₂) :=\n  rfl\n\n"}
{"name":"Submodule.comap_smul","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"K : Type u_9\nV : Type u_10\nV₂ : Type u_11\ninst✝⁴ : Semifield K\ninst✝³ : AddCommMonoid V\ninst✝² : Module K V\ninst✝¹ : AddCommMonoid V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V V₂\np : Submodule K V₂\na : K\nh : Ne a 0\n⊢ Eq (Submodule.comap (HSMul.hSMul a f) p) (Submodule.comap f p)","decl":"theorem comap_smul (f : V →ₗ[K] V₂) (p : Submodule K V₂) (a : K) (h : a ≠ 0) :\n    p.comap (a • f) = p.comap f := by\n  ext b; simp only [Submodule.mem_comap, p.smul_mem_iff h, LinearMap.smul_apply]\n\n"}
{"name":"Submodule.map_smul","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"K : Type u_9\nV : Type u_10\nV₂ : Type u_11\ninst✝⁴ : Semifield K\ninst✝³ : AddCommMonoid V\ninst✝² : Module K V\ninst✝¹ : AddCommMonoid V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V V₂\np : Submodule K V\na : K\nh : Ne a 0\n⊢ Eq (Submodule.map (HSMul.hSMul a f) p) (Submodule.map f p)","decl":"protected theorem map_smul (f : V →ₗ[K] V₂) (p : Submodule K V) (a : K) (h : a ≠ 0) :\n    p.map (a • f) = p.map f :=\n  le_antisymm (by rw [map_le_iff_le_comap, comap_smul f _ a h, ← map_le_iff_le_comap])\n    (by rw [map_le_iff_le_comap, ← comap_smul f _ a h, ← map_le_iff_le_comap])\n\n"}
{"name":"Submodule.comap_smul'","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"K : Type u_9\nV : Type u_10\nV₂ : Type u_11\ninst✝⁴ : Semifield K\ninst✝³ : AddCommMonoid V\ninst✝² : Module K V\ninst✝¹ : AddCommMonoid V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V V₂\np : Submodule K V₂\na : K\n⊢ Eq (Submodule.comap (HSMul.hSMul a f) p) (iInf fun x => Submodule.comap f p)","decl":"theorem comap_smul' (f : V →ₗ[K] V₂) (p : Submodule K V₂) (a : K) :\n    p.comap (a • f) = ⨅ _ : a ≠ 0, p.comap f := by\n  classical by_cases h : a = 0 <;> simp [h, comap_smul]\n\n"}
{"name":"Submodule.map_smul'","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"K : Type u_9\nV : Type u_10\nV₂ : Type u_11\ninst✝⁴ : Semifield K\ninst✝³ : AddCommMonoid V\ninst✝² : Module K V\ninst✝¹ : AddCommMonoid V₂\ninst✝ : Module K V₂\nf : LinearMap (RingHom.id K) V V₂\np : Submodule K V\na : K\n⊢ Eq (Submodule.map (HSMul.hSMul a f) p) (iSup fun x => Submodule.map f p)","decl":"theorem map_smul' (f : V →ₗ[K] V₂) (p : Submodule K V) (a : K) :\n    p.map (a • f) = ⨆ _ : a ≠ 0, map f p := by\n  classical by_cases h : a = 0 <;> simp [h, Submodule.map_smul]\n\n"}
{"name":"Submodule.comapSubtypeEquivOfLe_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\nhpq : LE.le p q\nx : Subtype fun x => Membership.mem p x\n⊢ Eq ((Submodule.comapSubtypeEquivOfLe hpq).symm x) ⟨⟨↑x, ⋯⟩, ⋯⟩","decl":"/-- If `s ≤ t`, then we can view `s` as a submodule of `t` by taking the comap\nof `t.subtype`. -/\n@[simps apply_coe symm_apply]\ndef comapSubtypeEquivOfLe {p q : Submodule R M} (hpq : p ≤ q) : comap q.subtype p ≃ₗ[R] p where\n  toFun x := ⟨x, x.2⟩\n  invFun x := ⟨⟨x, hpq x.2⟩, x.2⟩\n  left_inv x := by simp only [coe_mk, SetLike.eta, LinearEquiv.coe_coe]\n  right_inv x := by simp only [Subtype.coe_mk, SetLike.eta, LinearEquiv.coe_coe]\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"Submodule.comapSubtypeEquivOfLe_apply_coe","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\nhpq : LE.le p q\nx : Subtype fun x => Membership.mem (Submodule.comap q.subtype p) x\n⊢ Eq ↑((Submodule.comapSubtypeEquivOfLe hpq) x) ↑↑x","decl":"/-- If `s ≤ t`, then we can view `s` as a submodule of `t` by taking the comap\nof `t.subtype`. -/\n@[simps apply_coe symm_apply]\ndef comapSubtypeEquivOfLe {p q : Submodule R M} (hpq : p ≤ q) : comap q.subtype p ≃ₗ[R] p where\n  toFun x := ⟨x, x.2⟩\n  invFun x := ⟨⟨x, hpq x.2⟩, x.2⟩\n  left_inv x := by simp only [coe_mk, SetLike.eta, LinearEquiv.coe_coe]\n  right_inv x := by simp only [Subtype.coe_mk, SetLike.eta, LinearEquiv.coe_coe]\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"Submodule.mem_map_equiv","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nτ₂₁ : RingHom R₂ R\ninst✝¹ : RingHomInvPair τ₁₂ τ₂₁\ninst✝ : RingHomInvPair τ₂₁ τ₁₂\np : Submodule R M\ne : LinearEquiv τ₁₂ M M₂\nx : M₂\n⊢ Iff (Membership.mem (Submodule.map (↑e) p) x) (Membership.mem p (e.symm x))","decl":"@[simp high]\ntheorem mem_map_equiv {e : M ≃ₛₗ[τ₁₂] M₂} {x : M₂} :\n    x ∈ p.map (e : M →ₛₗ[τ₁₂] M₂) ↔ e.symm x ∈ p := by\n  rw [Submodule.mem_map]; constructor\n  · rintro ⟨y, hy, hx⟩\n    simp [← hx, hy]\n  · intro hx\n    exact ⟨e.symm x, hx, by simp⟩\n\n"}
{"name":"Submodule.map_equiv_eq_comap_symm","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nτ₂₁ : RingHom R₂ R\ninst✝¹ : RingHomInvPair τ₁₂ τ₂₁\ninst✝ : RingHomInvPair τ₂₁ τ₁₂\ne : LinearEquiv τ₁₂ M M₂\nK : Submodule R M\n⊢ Eq (Submodule.map (↑e) K) (Submodule.comap (↑e.symm) K)","decl":"theorem map_equiv_eq_comap_symm (e : M ≃ₛₗ[τ₁₂] M₂) (K : Submodule R M) :\n    K.map (e : M →ₛₗ[τ₁₂] M₂) = K.comap (e.symm : M₂ →ₛₗ[τ₂₁] M) :=\n  Submodule.ext fun _ => by rw [mem_map_equiv, mem_comap, LinearEquiv.coe_coe]\n\n"}
{"name":"Submodule.comap_equiv_eq_map_symm","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nτ₂₁ : RingHom R₂ R\ninst✝¹ : RingHomInvPair τ₁₂ τ₂₁\ninst✝ : RingHomInvPair τ₂₁ τ₁₂\ne : LinearEquiv τ₁₂ M M₂\nK : Submodule R₂ M₂\n⊢ Eq (Submodule.comap (↑e) K) (Submodule.map (↑e.symm) K)","decl":"theorem comap_equiv_eq_map_symm (e : M ≃ₛₗ[τ₁₂] M₂) (K : Submodule R₂ M₂) :\n    K.comap (e : M →ₛₗ[τ₁₂] M₂) = K.map (e.symm : M₂ →ₛₗ[τ₂₁] M) :=\n  (map_equiv_eq_comap_symm e.symm K).symm\n\n"}
{"name":"Submodule.map_symm_eq_iff","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nτ₂₁ : RingHom R₂ R\ninst✝¹ : RingHomInvPair τ₁₂ τ₂₁\ninst✝ : RingHomInvPair τ₂₁ τ₁₂\np : Submodule R M\ne : LinearEquiv τ₁₂ M M₂\nK : Submodule R₂ M₂\n⊢ Iff (Eq (Submodule.map e.symm K) p) (Eq (Submodule.map e p) K)","decl":"theorem map_symm_eq_iff (e : M ≃ₛₗ[τ₁₂] M₂) {K : Submodule R₂ M₂} :\n    K.map e.symm = p ↔ p.map e = K := by\n  constructor <;> rintro rfl\n  · calc\n      map e (map e.symm K) = comap e.symm (map e.symm K) := map_equiv_eq_comap_symm _ _\n      _ = K := comap_map_eq_of_injective e.symm.injective _\n  · calc\n      map e.symm (map e p) = comap e (map e p) := (comap_equiv_eq_map_symm _ _).symm\n      _ = p := comap_map_eq_of_injective e.injective _\n\n"}
{"name":"Submodule.orderIsoMapComap_apply'","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nτ₂₁ : RingHom R₂ R\ninst✝¹ : RingHomInvPair τ₁₂ τ₂₁\ninst✝ : RingHomInvPair τ₂₁ τ₁₂\ne : LinearEquiv τ₁₂ M M₂\np : Submodule R M\n⊢ Eq ((Submodule.orderIsoMapComap e) p) (Submodule.comap e.symm p)","decl":"theorem orderIsoMapComap_apply' (e : M ≃ₛₗ[τ₁₂] M₂) (p : Submodule R M) :\n    orderIsoMapComap e p = comap e.symm p :=\n  p.map_equiv_eq_comap_symm _\n\n"}
{"name":"Submodule.orderIsoMapComap_symm_apply'","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nτ₂₁ : RingHom R₂ R\ninst✝¹ : RingHomInvPair τ₁₂ τ₂₁\ninst✝ : RingHomInvPair τ₂₁ τ₁₂\ne : LinearEquiv τ₁₂ M M₂\np : Submodule R₂ M₂\n⊢ Eq ((Submodule.orderIsoMapComap e).symm p) (Submodule.map e.symm p)","decl":"theorem orderIsoMapComap_symm_apply' (e : M ≃ₛₗ[τ₁₂] M₂) (p : Submodule R₂ M₂) :\n    (orderIsoMapComap e).symm p = map e.symm p :=\n  p.comap_equiv_eq_map_symm _\n\n"}
{"name":"Submodule.inf_comap_le_comap_add","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nτ₁₂ : RingHom R R₂\nq : Submodule R₂ M₂\nf₁ f₂ : LinearMap τ₁₂ M M₂\n⊢ LE.le (Min.min (Submodule.comap f₁ q) (Submodule.comap f₂ q)) (Submodule.comap (HAdd.hAdd f₁ f₂) q)","decl":"theorem inf_comap_le_comap_add (f₁ f₂ : M →ₛₗ[τ₁₂] M₂) :\n    comap f₁ q ⊓ comap f₂ q ≤ comap (f₁ + f₂) q := by\n  rw [SetLike.le_def]\n  intro m h\n  change f₁ m + f₂ m ∈ q\n  change f₁ m ∈ q ∧ f₂ m ∈ q at h\n  apply q.add_mem h.1 h.2\n\n"}
{"name":"Submodule.comap_le_comap_smul","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nN : Type u_9\nN₂ : Type u_10\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid N\ninst✝² : AddCommMonoid N₂\ninst✝¹ : Module R N\ninst✝ : Module R N₂\nqₗ : Submodule R N₂\nfₗ : LinearMap (RingHom.id R) N N₂\nc : R\n⊢ LE.le (Submodule.comap fₗ qₗ) (Submodule.comap (HSMul.hSMul c fₗ) qₗ)","decl":"theorem comap_le_comap_smul (fₗ : N →ₗ[R] N₂) (c : R) : comap fₗ qₗ ≤ comap (c • fₗ) qₗ := by\n  rw [SetLike.le_def]\n  intro m h\n  change c • fₗ m ∈ qₗ\n  change fₗ m ∈ qₗ at h\n  apply qₗ.smul_mem _ h\n\n"}
{"name":"LinearMap.submoduleMap_coe_apply","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₁\ninst✝¹ : Module R M\ninst✝ : Module R M₁\nf : LinearMap (RingHom.id R) M M₁\np : Submodule R M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑((f.submoduleMap p) x)) (f ↑x)","decl":"@[simp]\ntheorem submoduleMap_coe_apply (f : M →ₗ[R] M₁) {p : Submodule R M} (x : p) :\n    ↑(f.submoduleMap p x) = f x := rfl\n\n"}
{"name":"LinearMap.submoduleMap_surjective","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₁\ninst✝¹ : Module R M\ninst✝ : Module R M₁\nf : LinearMap (RingHom.id R) M M₁\np : Submodule R M\n⊢ Function.Surjective ⇑(f.submoduleMap p)","decl":"theorem submoduleMap_surjective (f : M →ₗ[R] M₁) (p : Submodule R M) :\n    Function.Surjective (f.submoduleMap p) := f.toAddMonoidHom.addSubmonoidMap_surjective _\n\n"}
{"name":"LinearMap.map_codRestrict","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Semiring R₂\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R₂ M₂\nσ₂₁ : RingHom R₂ R\ninst✝ : RingHomSurjective σ₂₁\np : Submodule R M\nf : LinearMap σ₂₁ M₂ M\nh : ∀ (c : M₂), Membership.mem p (f c)\np' : Submodule R₂ M₂\n⊢ Eq (Submodule.map (LinearMap.codRestrict p f h) p') (Submodule.comap p.subtype (Submodule.map f p'))","decl":"theorem map_codRestrict [RingHomSurjective σ₂₁] (p : Submodule R M) (f : M₂ →ₛₗ[σ₂₁] M) (h p') :\n    Submodule.map (codRestrict p f h) p' = comap p.subtype (p'.map f) :=\n  Submodule.ext fun ⟨x, hx⟩ => by simp [Subtype.ext_iff_val]\n\n"}
{"name":"LinearMap.comap_codRestrict","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R₂ M₂\nσ₂₁ : RingHom R₂ R\np : Submodule R M\nf : LinearMap σ₂₁ M₂ M\nhf : ∀ (c : M₂), Membership.mem p (f c)\np' : Submodule R (Subtype fun x => Membership.mem p x)\n⊢ Eq (Submodule.comap (LinearMap.codRestrict p f hf) p') (Submodule.comap f (Submodule.map p.subtype p'))","decl":"theorem comap_codRestrict (p : Submodule R M) (f : M₂ →ₛₗ[σ₂₁] M) (hf p') :\n    Submodule.comap (codRestrict p f hf) p' = Submodule.comap f (map p.subtype p') :=\n  Submodule.ext fun x => ⟨fun h => ⟨⟨_, hf x⟩, h, rfl⟩, by rintro ⟨⟨_, _⟩, h, ⟨⟩⟩; exact h⟩\n\n"}
{"name":"LinearEquiv.map_eq_comap","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝³ : Semiring R\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne : LinearEquiv σ₁₂ M M₂\np : Submodule R M\n⊢ Eq (Submodule.map (↑e) p) (Submodule.comap (↑e.symm) p)","decl":"theorem map_eq_comap {p : Submodule R M} :\n    (p.map (e : M →ₛₗ[σ₁₂] M₂) : Submodule R₂ M₂) = p.comap (e.symm : M₂ →ₛₗ[σ₂₁] M) :=\n  SetLike.coe_injective <| by simp [e.image_eq_preimage]\n\n"}
{"name":"LinearEquiv.submoduleMap_apply","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝³ : Semiring R\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne : LinearEquiv σ₁₂ M M₂\np : Submodule R M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑((e.submoduleMap p) x)) (e ↑x)","decl":"@[simp]\ntheorem submoduleMap_apply (p : Submodule R M) (x : p) : ↑(e.submoduleMap p x) = e x :=\n  rfl\n\n"}
{"name":"LinearEquiv.submoduleMap_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Map","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝³ : Semiring R\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne : LinearEquiv σ₁₂ M M₂\np : Submodule R M\nx : Subtype fun x => Membership.mem (Submodule.map (↑e) p) x\n⊢ Eq (↑((e.submoduleMap p).symm x)) (e.symm ↑x)","decl":"@[simp]\ntheorem submoduleMap_symm_apply (p : Submodule R M)\n    (x : (p.map (e : M →ₛₗ[σ₁₂] M₂) : Submodule R₂ M₂)) : ↑((e.submoduleMap p).symm x) = e.symm x :=\n  rfl\n\n"}
