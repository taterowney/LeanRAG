{"name":"IsIntegral.isAlgebraic","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u\nA : Type v\ninst✝³ : CommRing R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : Nontrivial R\nx : A\na✝ : IsIntegral R x\n⊢ IsAlgebraic R x","decl":"/-- An integral element of an algebra is algebraic. -/\ntheorem IsIntegral.isAlgebraic [Nontrivial R] {x : A} : IsIntegral R x → IsAlgebraic R x :=\n  fun ⟨p, hp, hpx⟩ => ⟨p, hp.ne_zero, hpx⟩\n\n"}
{"name":"Algebra.IsIntegral.isAlgebraic","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u\nA : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Algebra R A\ninst✝¹ : Nontrivial R\ninst✝ : Algebra.IsIntegral R A\n⊢ Algebra.IsAlgebraic R A","decl":"instance Algebra.IsIntegral.isAlgebraic [Nontrivial R] [Algebra.IsIntegral R A] :\n    Algebra.IsAlgebraic R A := ⟨fun a ↦ (Algebra.IsIntegral.isIntegral a).isAlgebraic⟩\n\n"}
{"name":"isAlgebraic_iff_isIntegral","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"K : Type u\nA : Type v\ninst✝² : Field K\ninst✝¹ : Ring A\ninst✝ : Algebra K A\nx : A\n⊢ Iff (IsAlgebraic K x) (IsIntegral K x)","decl":"/-- An element of an algebra over a field is algebraic if and only if it is integral. -/\ntheorem isAlgebraic_iff_isIntegral {x : A} : IsAlgebraic K x ↔ IsIntegral K x := by\n  refine ⟨?_, IsIntegral.isAlgebraic⟩\n  rintro ⟨p, hp, hpx⟩\n  refine ⟨_, monic_mul_leadingCoeff_inv hp, ?_⟩\n  rw [← aeval_def, map_mul, hpx, zero_mul]\n\n"}
{"name":"Algebra.isAlgebraic_iff_isIntegral","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"K : Type u\nA : Type v\ninst✝² : Field K\ninst✝¹ : Ring A\ninst✝ : Algebra K A\n⊢ Iff (Algebra.IsAlgebraic K A) (Algebra.IsIntegral K A)","decl":"protected theorem Algebra.isAlgebraic_iff_isIntegral :\n    Algebra.IsAlgebraic K A ↔ Algebra.IsIntegral K A := by\n  rw [Algebra.isAlgebraic_def, Algebra.isIntegral_def,\n      forall_congr' fun _ ↦ isAlgebraic_iff_isIntegral]\n\n"}
{"name":"IsAlgebraic.isIntegral","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"K : Type u\nA : Type v\ninst✝² : Field K\ninst✝¹ : Ring A\ninst✝ : Algebra K A\nx : A\na✝ : IsAlgebraic K x\n⊢ IsIntegral K x","decl":"alias ⟨IsAlgebraic.isIntegral, _⟩ := isAlgebraic_iff_isIntegral\n\n"}
{"name":"Algebra.IsAlgebraic.isIntegral","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"K : Type u\nA : Type v\ninst✝³ : Field K\ninst✝² : Ring A\ninst✝¹ : Algebra K A\ninst✝ : Algebra.IsAlgebraic K A\n⊢ Algebra.IsIntegral K A","decl":"/-- This used to be an `alias` of `Algebra.isAlgebraic_iff_isIntegral` but that would make\n`Algebra.IsAlgebraic K A` an explicit parameter instead of instance implicit. -/\nprotected instance Algebra.IsAlgebraic.isIntegral [Algebra.IsAlgebraic K A] :\n    Algebra.IsIntegral K A := Algebra.isAlgebraic_iff_isIntegral.mp ‹_›\n\n"}
{"name":"Algebra.IsAlgebraic.of_isIntegralClosure","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : Nontrivial R\ninst✝⁶ : CommRing B\ninst✝⁵ : CommRing C\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra R C\ninst✝² : Algebra B C\ninst✝¹ : IsScalarTower R B C\ninst✝ : IsIntegralClosure B R C\n⊢ Algebra.IsAlgebraic R B","decl":"theorem Algebra.IsAlgebraic.of_isIntegralClosure (R B C : Type*) [CommRing R] [Nontrivial R]\n    [CommRing B] [CommRing C] [Algebra R B] [Algebra R C] [Algebra B C]\n    [IsScalarTower R B C] [IsIntegralClosure B R C] : Algebra.IsAlgebraic R B :=\n  have := IsIntegralClosure.isIntegral_algebra R (A := B) C\n  inferInstance\n\n"}
{"name":"IsAlgebraic.of_finite","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"K : Type u_1\nA : Type u_5\ninst✝³ : Field K\ninst✝² : Ring A\ninst✝¹ : Algebra K A\ne : A\ninst✝ : FiniteDimensional K A\n⊢ IsAlgebraic K e","decl":"theorem IsAlgebraic.of_finite (e : A) [FiniteDimensional K A] : IsAlgebraic K e :=\n  (IsIntegral.of_finite K e).isAlgebraic\n\n"}
{"name":"Algebra.IsAlgebraic.of_finite","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"K : Type u_1\nA : Type u_5\ninst✝³ : Field K\ninst✝² : Ring A\ninst✝¹ : Algebra K A\ninst✝ : FiniteDimensional K A\n⊢ Algebra.IsAlgebraic K A","decl":"/-- A field extension is algebraic if it is finite. -/\n@[stacks 09GG \"first part\"]\ninstance Algebra.IsAlgebraic.of_finite [FiniteDimensional K A] : Algebra.IsAlgebraic K A :=\n  (IsIntegral.of_finite K A).isAlgebraic\n\n"}
{"name":"Algebra.IsAlgebraic.trans","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"K : Type u_1\nL : Type u_2\nA : Type u_5\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Ring A\ninst✝³ : Algebra K L\ninst✝² : Algebra L A\ninst✝¹ : Algebra K A\ninst✝ : IsScalarTower K L A\nL_alg : Algebra.IsAlgebraic K L\nA_alg : Algebra.IsAlgebraic L A\n⊢ Algebra.IsAlgebraic K A","decl":"/-- If L is an algebraic field extension of K and A is an algebraic algebra over L,\nthen A is algebraic over K. -/\n@[stacks 09GJ]\nprotected theorem Algebra.IsAlgebraic.trans\n    [L_alg : Algebra.IsAlgebraic K L] [A_alg : Algebra.IsAlgebraic L A] :\n    Algebra.IsAlgebraic K A := by\n  rw [Algebra.isAlgebraic_iff_isIntegral] at L_alg A_alg ⊢\n  exact Algebra.IsIntegral.trans L\n\n"}
{"name":"transcendental_aeval_iff","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"K : Type u_1\nA : Type u_5\ninst✝² : Field K\ninst✝¹ : Ring A\ninst✝ : Algebra K A\nr : A\nf : Polynomial K\n⊢ Iff (Transcendental K ((Polynomial.aeval r) f)) (And (Transcendental K r) (Transcendental K f))","decl":"/-- If `K` is a field, `r : A` and `f : K[X]`, then `Polynomial.aeval r f` is\ntranscendental over `K` if and only if `r` and `f` are both transcendental over `K`.\nSee also `Transcendental.aeval_of_transcendental` and `Transcendental.of_aeval`. -/\n@[simp]\ntheorem transcendental_aeval_iff {r : A} {f : K[X]} :\n    Transcendental K (Polynomial.aeval r f) ↔ Transcendental K r ∧ Transcendental K f := by\n  refine ⟨fun h ↦ ⟨?_, h.of_aeval⟩, fun ⟨h1, h2⟩ ↦ h1.aeval_of_transcendental h2⟩\n  rw [Transcendental] at h ⊢\n  contrapose! h\n  rw [isAlgebraic_iff_isIntegral] at h ⊢\n  exact .of_mem_of_fg _ h.fg_adjoin_singleton _ (aeval_mem_adjoin_singleton _ _)\n\n"}
{"name":"AlgHom.bijective","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : FiniteDimensional K L\nϕ : AlgHom K L L\n⊢ Function.Bijective ⇑ϕ","decl":"theorem AlgHom.bijective [FiniteDimensional K L] (ϕ : L →ₐ[K] L) : Function.Bijective ϕ :=\n  (Algebra.IsAlgebraic.of_finite K L).algHom_bijective ϕ\n\n"}
{"name":"IsAlgebraic.exists_integral_multiple","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nA : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nz : A\nhz : IsAlgebraic R z\ninj : Function.Injective ⇑(algebraMap R A)\n⊢ Exists fun y => And (Ne y 0) (IsIntegral R (HSMul.hSMul y z))","decl":"theorem exists_integral_multiple (hz : IsAlgebraic R z)\n    (inj : Function.Injective (algebraMap R A)) :\n    ∃ y ≠ (0 : R), IsIntegral R (y • z) := by\n  have ⟨p, p_ne_zero, px⟩ := hz\n  set a := p.leadingCoeff\n  have a_ne_zero : a ≠ 0 := mt Polynomial.leadingCoeff_eq_zero.mp p_ne_zero\n  have x_integral : IsIntegral R (algebraMap R A a * z) :=\n    ⟨p.integralNormalization, monic_integralNormalization p_ne_zero,\n      integralNormalization_aeval_eq_zero px fun _ ↦ (map_eq_zero_iff _ inj).mp⟩\n  exact ⟨_, a_ne_zero, Algebra.smul_def a z ▸ x_integral⟩\n\n"}
{"name":"exists_integral_multiple","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nA : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nz : A\nhz : IsAlgebraic R z\ninj : Function.Injective ⇑(algebraMap R A)\n⊢ Exists fun y => And (Ne y 0) (IsIntegral R (HSMul.hSMul y z))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias _root_.exists_integral_multiple := exists_integral_multiple\n\n"}
{"name":"Algebra.IsAlgebraic.exists_integral_multiples","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nA : Type u_3\ninst✝³ : CommRing R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : NoZeroDivisors R\nalg : Algebra.IsAlgebraic R A\ninj : Function.Injective ⇑(algebraMap R A)\ns : Finset A\n⊢ Exists fun y => And (Ne y 0) (∀ (z : A), Membership.mem s z → IsIntegral R (HSMul.hSMul y z))","decl":"theorem _root_.Algebra.IsAlgebraic.exists_integral_multiples [NoZeroDivisors R]\n    [alg : Algebra.IsAlgebraic R A] (inj : Function.Injective (algebraMap R A)) (s : Finset A) :\n    ∃ y ≠ (0 : R), ∀ z ∈ s, IsIntegral R (y • z) := by\n  have := Algebra.IsAlgebraic.nontrivial R A\n  choose r hr int using fun x ↦ (alg.1 x).exists_integral_multiple inj\n  refine ⟨∏ x ∈ s, r x, Finset.prod_ne_zero_iff.mpr fun _ _ ↦ hr _, fun _ h ↦ ?_⟩\n  classical rw [← Finset.prod_erase_mul _ _ h, mul_smul]\n  exact (int _).smul _\n\n"}
{"name":"IsAlgebraic.of_smul_isIntegral","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nA : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nz : A\ny : R\nhy : Not (IsNilpotent y)\nh : IsIntegral R (HSMul.hSMul y z)\n⊢ IsAlgebraic R z","decl":"theorem of_smul_isIntegral {y : R} (hy : ¬ IsNilpotent y)\n    (h : IsIntegral R (y • z)) : IsAlgebraic R z := by\n  have ⟨p, monic, eval0⟩ := h\n  refine ⟨p.comp (C y * X), fun h ↦ ?_, by simpa [aeval_comp, Algebra.smul_def] using eval0⟩\n  apply_fun (coeff · p.natDegree) at h\n  have hy0 : y ≠ 0 := by rintro rfl; exact hy .zero\n  rw [coeff_zero, ← mul_one p.natDegree, ← natDegree_C_mul_X y hy0,\n    coeff_comp_degree_mul_degree, monic, one_mul, leadingCoeff_C_mul_X] at h\n  · exact hy ⟨_, h⟩\n  · rw [natDegree_C_mul_X _ hy0]; rintro ⟨⟩\n\n"}
{"name":"IsAlgebraic.of_smul","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nA : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nz : A\ny : R\nhy : Membership.mem (nonZeroDivisors R) y\nh : IsAlgebraic R (HSMul.hSMul y z)\n⊢ IsAlgebraic R z","decl":"theorem of_smul {y : R} (hy : y ∈ nonZeroDivisors R)\n    (h : IsAlgebraic R (y • z)) : IsAlgebraic R z :=\n  have ⟨p, hp, eval0⟩ := h\n  ⟨_, mt (comp_C_mul_X_eq_zero_iff hy).mp hp, by simpa [aeval_comp, Algebra.smul_def] using eval0⟩\n\n"}
{"name":"IsAlgebraic.iff_exists_smul_integral","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nA : Type u_3\ninst✝³ : CommRing R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\nz : A\ninst✝ : IsReduced R\ninj : Function.Injective ⇑(algebraMap R A)\n⊢ Iff (IsAlgebraic R z) (Exists fun y => And (Ne y 0) (IsIntegral R (HSMul.hSMul y z)))","decl":"theorem iff_exists_smul_integral [IsReduced R] (inj : Function.Injective (algebraMap R A)) :\n    IsAlgebraic R z ↔ ∃ y ≠ (0 : R), IsIntegral R (y • z) :=\n  ⟨(exists_integral_multiple · inj), fun ⟨_, hy, int⟩ ↦\n    of_smul_isIntegral (by rwa [isNilpotent_iff_eq_zero]) int⟩\n\n"}
{"name":"IsAlgebraic.restrictScalars_of_isIntegral","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Ring A\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra R A\ninst✝² : Algebra S A\ninst✝¹ : IsScalarTower R S A\ninst✝ : NoZeroDivisors S\ninj : Function.Injective ⇑(algebraMap S A)\nint : Algebra.IsIntegral R S\na : A\nh : IsAlgebraic S a\n⊢ IsAlgebraic R a","decl":"theorem restrictScalars_of_isIntegral [int : Algebra.IsIntegral R S]\n    {a : A} (h : IsAlgebraic S a) : IsAlgebraic R a := by\n  by_cases hRS : Function.Injective (algebraMap R S)\n  on_goal 2 => exact (Algebra.isAlgebraic_of_not_injective\n    fun h ↦ hRS <| .of_comp (IsScalarTower.algebraMap_eq R S A ▸ h)).1 _\n  have := hRS.noZeroDivisors _ (map_zero _) (map_mul _)\n  have ⟨s, hs, int_s⟩ := h.exists_integral_multiple inj\n  cases subsingleton_or_nontrivial R\n  · have := Module.subsingleton R S\n    exact (is_transcendental_of_subsingleton _ _ h).elim\n  have ⟨r, hr, _, e⟩ := (int.1 s).isAlgebraic.exists_nonzero_dvd (mem_nonZeroDivisors_of_ne_zero hs)\n  refine .of_smul_isIntegral (y := r) (by rwa [isNilpotent_iff_eq_zero]) ?_\n  rw [Algebra.smul_def, IsScalarTower.algebraMap_apply R S,\n    e, ← Algebra.smul_def, mul_comm, mul_smul]\n  exact isIntegral_trans _ (int_s.smul _)\n\n"}
{"name":"IsAlgebraic.restrictScalars","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Ring A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra S A\ninst✝² : IsScalarTower R S A\ninst✝¹ : NoZeroDivisors S\ninj : Function.Injective ⇑(algebraMap S A)\ninst✝ : Algebra.IsAlgebraic R S\na : A\nh : IsAlgebraic S a\n⊢ IsAlgebraic R a","decl":"theorem restrictScalars [Algebra.IsAlgebraic R S]\n    {a : A} (h : IsAlgebraic S a) : IsAlgebraic R a := by\n  have ⟨p, hp, eval0⟩ := h\n  by_cases hRS : Function.Injective (algebraMap R S)\n  on_goal 2 => exact (Algebra.isAlgebraic_of_not_injective\n    fun h ↦ hRS <| .of_comp (IsScalarTower.algebraMap_eq R S A ▸ h)).1 _\n  have := hRS.noZeroDivisors _ (map_zero _) (map_mul _)\n  classical\n  have ⟨r, hr, int⟩ := Algebra.IsAlgebraic.exists_integral_multiples hRS (p.support.image (coeff p))\n  let p := (r • p).toSubring (integralClosure R S).toSubring fun s hs ↦ by\n    obtain ⟨n, hn, rfl⟩ := mem_coeffs_iff.mp hs\n    exact int _ (Finset.mem_image_of_mem _ <| support_smul _ _ hn)\n  have : IsAlgebraic (integralClosure R S) a := by\n    refine ⟨p, ?_, ?_⟩\n    · have := NoZeroSMulDivisors.of_algebraMap_injective hRS\n      simpa only [← Polynomial.map_ne_zero_iff (f := Subring.subtype _) Subtype.val_injective,\n        p, map_toSubring, smul_ne_zero_iff] using And.intro hr hp\n    rw [← eval_map_algebraMap, Subalgebra.algebraMap_eq, ← map_map, ← Subalgebra.toSubring_subtype,\n      map_toSubring, eval_map_algebraMap, ← AlgHom.restrictScalars_apply R,\n      map_smul, AlgHom.restrictScalars_apply, eval0, smul_zero]\n  exact restrictScalars_of_isIntegral _ (by exact inj.comp Subtype.val_injective) this\n\n"}
{"name":"IsIntegral.trans_isAlgebraic","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Ring A\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra R A\ninst✝² : Algebra S A\ninst✝¹ : IsScalarTower R S A\ninst✝ : NoZeroDivisors S\ninj : Function.Injective ⇑(algebraMap S A)\nalg : Algebra.IsAlgebraic R S\na : A\nh : IsIntegral S a\n⊢ IsAlgebraic R a","decl":"theorem _root_.IsIntegral.trans_isAlgebraic [alg : Algebra.IsAlgebraic R S]\n    {a : A} (h : IsIntegral S a) : IsAlgebraic R a := by\n  cases subsingleton_or_nontrivial A\n  · have := Algebra.IsAlgebraic.nontrivial R S\n    exact Subsingleton.elim a 0 ▸ isAlgebraic_zero\n  · have := Module.nontrivial S A\n    exact h.isAlgebraic.restrictScalars _ inj\n\n"}
{"name":"IsAlgebraic.neg","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\na : S\nha : IsAlgebraic R a\n⊢ IsAlgebraic R (Neg.neg a)","decl":"protected lemma neg : IsAlgebraic R (-a) :=\n  have ⟨p, h, eval0⟩ := ha\n  ⟨algEquivAevalNegX p, EmbeddingLike.map_ne_zero_iff.mpr h, by simpa [← comp_eq_aeval, aeval_comp]⟩\n\n"}
{"name":"IsAlgebraic.smul","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\na : S\nha : IsAlgebraic R a\nr : R\n⊢ IsAlgebraic R (HSMul.hSMul r a)","decl":"protected lemma smul (r : R) : IsAlgebraic R (r • a) :=\n  have ⟨_, hp, eval0⟩ := ha\n  ⟨_, scaleRoots_ne_zero hp r, Algebra.smul_def r a ▸ scaleRoots_aeval_eq_zero eval0⟩\n\n"}
{"name":"IsAlgebraic.nsmul","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\na : S\nha : IsAlgebraic R a\nn : Nat\n⊢ IsAlgebraic R (HSMul.hSMul n a)","decl":"protected lemma nsmul (n : ℕ) : IsAlgebraic R (n • a) :=\n  Nat.cast_smul_eq_nsmul R n a ▸ ha.smul _\n\n"}
{"name":"IsAlgebraic.zsmul","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\na : S\nha : IsAlgebraic R a\nn : Int\n⊢ IsAlgebraic R (HSMul.hSMul n a)","decl":"protected lemma zsmul (n : ℤ) : IsAlgebraic R (n • a) :=\n  Int.cast_smul_eq_zsmul R n a ▸ ha.smul _\n\n"}
{"name":"IsAlgebraic.mul","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nnzd : NoZeroDivisors R\na b : S\nha : IsAlgebraic R a\nhb : IsAlgebraic R b\n⊢ IsAlgebraic R (HMul.hMul a b)","decl":"protected lemma mul : IsAlgebraic R (a * b) := by\n  refine (em _).elim (fun h ↦ ?_) fun h ↦ (Algebra.isAlgebraic_of_not_injective h).1 _\n  have ⟨ra, a0, int_a⟩ := ha.exists_integral_multiple h\n  have ⟨rb, b0, int_b⟩ := hb.exists_integral_multiple h\n  refine (IsAlgebraic.iff_exists_smul_integral h).mpr ⟨_, mul_ne_zero a0 b0, ?_⟩\n  simp_rw [Algebra.smul_def, map_mul, mul_mul_mul_comm, ← Algebra.smul_def]\n  exact int_a.mul int_b\n\n"}
{"name":"IsAlgebraic.add","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nnzd : NoZeroDivisors R\na b : S\nha : IsAlgebraic R a\nhb : IsAlgebraic R b\n⊢ IsAlgebraic R (HAdd.hAdd a b)","decl":"protected lemma add : IsAlgebraic R (a + b) := by\n  refine (em _).elim (fun h ↦ ?_) fun h ↦ (Algebra.isAlgebraic_of_not_injective h).1 _\n  have ⟨ra, a0, int_a⟩ := ha.exists_integral_multiple h\n  have ⟨rb, b0, int_b⟩ := hb.exists_integral_multiple h\n  refine (IsAlgebraic.iff_exists_smul_integral h).mpr ⟨_, mul_ne_zero b0 a0, ?_⟩\n  rw [smul_add, mul_smul, mul_comm, mul_smul]\n  exact (int_a.smul _).add (int_b.smul _)\n\n"}
{"name":"IsAlgebraic.sub","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nnzd : NoZeroDivisors R\na b : S\nha : IsAlgebraic R a\nhb : IsAlgebraic R b\n⊢ IsAlgebraic R (HSub.hSub a b)","decl":"protected lemma sub : IsAlgebraic R (a - b) :=\n  sub_eq_add_neg a b ▸ ha.add hb.neg\n\n"}
{"name":"IsAlgebraic.pow","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nnzd : NoZeroDivisors R\na : S\nha : IsAlgebraic R a\nn : Nat\n⊢ IsAlgebraic R (HPow.hPow a n)","decl":"protected lemma pow (n : ℕ) : IsAlgebraic R (a ^ n) :=\n  have := ha.nontrivial\n  n.rec (pow_zero a ▸ isAlgebraic_one) fun _ h ↦ pow_succ a _ ▸ h.mul ha\n\n"}
{"name":"Algebra.IsAlgebraic.trans'","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Ring A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra S A\ninst✝² : IsScalarTower R S A\ninst✝¹ : NoZeroDivisors S\ninj : Function.Injective ⇑(algebraMap S A)\ninst✝ : Algebra.IsAlgebraic R S\nalg : Algebra.IsAlgebraic S A\n⊢ Algebra.IsAlgebraic R A","decl":"/-- Transitivity of algebraicity for algebras over domains. -/\ntheorem IsAlgebraic.trans' [Algebra.IsAlgebraic R S] [alg : Algebra.IsAlgebraic S A] :\n    Algebra.IsAlgebraic R A :=\n  ⟨fun _ ↦ (alg.1 _).restrictScalars _ inj⟩\n\n"}
{"name":"Algebra.IsIntegral.trans_isAlgebraic","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Ring A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra S A\ninst✝² : IsScalarTower R S A\ninst✝¹ : NoZeroDivisors S\ninj : Function.Injective ⇑(algebraMap S A)\ninst✝ : Algebra.IsIntegral R S\nalg : Algebra.IsAlgebraic S A\n⊢ Algebra.IsAlgebraic R A","decl":"theorem IsIntegral.trans_isAlgebraic [Algebra.IsIntegral R S] [alg : Algebra.IsAlgebraic S A] :\n    Algebra.IsAlgebraic R A :=\n  ⟨fun _ ↦ (alg.1 _).restrictScalars_of_isIntegral _ inj⟩\n\n"}
{"name":"Algebra.IsAlgebraic.trans_isIntegral","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Ring A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra S A\ninst✝² : IsScalarTower R S A\ninst✝¹ : NoZeroDivisors S\ninj : Function.Injective ⇑(algebraMap S A)\ninst✝ : Algebra.IsAlgebraic R S\nint : Algebra.IsIntegral S A\n⊢ Algebra.IsAlgebraic R A","decl":"theorem IsAlgebraic.trans_isIntegral [Algebra.IsAlgebraic R S] [int : Algebra.IsIntegral S A] :\n    Algebra.IsAlgebraic R A :=\n  ⟨fun _ ↦ (int.1 _).trans_isAlgebraic _ inj⟩\n\n"}
{"name":"integralClosure_le_algebraicClosure","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsDomain R\n⊢ LE.le (integralClosure R S) (Subalgebra.algebraicClosure R S)","decl":"theorem integralClosure_le_algebraicClosure [IsDomain R] :\n    integralClosure R S ≤ Subalgebra.algebraicClosure R S :=\n  fun _ ↦ IsIntegral.isAlgebraic\n\n"}
{"name":"Subalgebra.algebraicClosure_eq_integralClosure","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"S : Type u_2\ninst✝² : CommRing S\nK : Type u_4\ninst✝¹ : Field K\ninst✝ : Algebra K S\n⊢ Eq (Subalgebra.algebraicClosure K S) (integralClosure K S)","decl":"theorem Subalgebra.algebraicClosure_eq_integralClosure {K} [Field K] [Algebra K S] :\n    algebraicClosure K S = integralClosure K S :=\n  SetLike.ext fun _ ↦ isAlgebraic_iff_isIntegral\n\n"}
{"name":"instIsAlgebraicSubtypeMemSubalgebraAlgebraicClosure","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsDomain R\n⊢ Algebra.IsAlgebraic R (Subtype fun x => Membership.mem (Subalgebra.algebraicClosure R S) x)","decl":"instance [IsDomain R] : Algebra.IsAlgebraic R (Subalgebra.algebraicClosure R S) :=\n  (Subalgebra.isAlgebraic_iff _).mp fun _ ↦ id\n\n"}
{"name":"Algebra.isAlgebraic_adjoin_iff","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsDomain R\ns : Set S\n⊢ Iff (Algebra.adjoin R s).IsAlgebraic (∀ (x : S), Membership.mem s x → IsAlgebraic R x)","decl":"theorem Algebra.isAlgebraic_adjoin_iff [IsDomain R] {s : Set S} :\n    (adjoin R s).IsAlgebraic ↔ ∀ x ∈ s, IsAlgebraic R x :=\n  Algebra.adjoin_le_iff (S := Subalgebra.algebraicClosure R S)\n\n"}
{"name":"Algebra.isAlgebraic_adjoin_of_nonempty","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : NoZeroDivisors R\ns : Set S\nhs : s.Nonempty\n⊢ Iff (Algebra.adjoin R s).IsAlgebraic (∀ (x : S), Membership.mem s x → IsAlgebraic R x)","decl":"theorem Algebra.isAlgebraic_adjoin_of_nonempty [NoZeroDivisors R] {s : Set S} (hs : s.Nonempty) :\n    (adjoin R s).IsAlgebraic ↔ ∀ x ∈ s, IsAlgebraic R x :=\n  ⟨fun h x hx ↦ h _ (subset_adjoin hx), fun h ↦\n    have ⟨x, hx⟩ := hs\n    have := (isDomain_iff_noZeroDivisors_and_nontrivial _).mpr ⟨‹_›, (h x hx).nontrivial⟩\n    isAlgebraic_adjoin_iff.mpr h⟩\n\n"}
{"name":"Algebra.isAlgebraic_adjoin_singleton_iff","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : NoZeroDivisors R\ns : S\n⊢ Iff (Algebra.adjoin R (Singleton.singleton s)).IsAlgebraic (IsAlgebraic R s)","decl":"/-- In an algebra generated by a single algebraic element over a domain `R`, every element is\nalgebraic. This may fail when `R` is not a domain: see https://mathoverflow.net/a/132192/ for\nan example. -/\ntheorem Algebra.isAlgebraic_adjoin_singleton_iff [NoZeroDivisors R] {s : S} :\n    (adjoin R {s}).IsAlgebraic ↔ IsAlgebraic R s :=\n  (isAlgebraic_adjoin_of_nonempty <| Set.singleton_nonempty s).trans forall_eq\n\n"}
{"name":"IsAlgebraic.of_mul","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : NoZeroDivisors R\ny z : S\nhy : Membership.mem (nonZeroDivisors S) y\nalg_y : IsAlgebraic R y\nalg_yz : IsAlgebraic R (HMul.hMul y z)\n⊢ IsAlgebraic R z","decl":"theorem IsAlgebraic.of_mul [NoZeroDivisors R] {y z : S} (hy : y ∈ nonZeroDivisors S)\n    (alg_y : IsAlgebraic R y) (alg_yz : IsAlgebraic R (y * z)) : IsAlgebraic R z := by\n  have ⟨t, ht, r, hr, eq⟩ := alg_y.exists_nonzero_eq_adjoin_mul hy\n  have := alg_yz.mul (Algebra.isAlgebraic_adjoin_singleton_iff.mpr alg_y _ ht)\n  rw [mul_right_comm, eq, ← Algebra.smul_def] at this\n  exact this.of_smul (mem_nonZeroDivisors_of_ne_zero hr)\n\n"}
{"name":"Transcendental.extendScalars_of_isIntegral","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Ring A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra S A\ninst✝² : IsScalarTower R S A\na : A\nha : Transcendental R a\ninst✝¹ : NoZeroDivisors S\ninst✝ : Algebra.IsIntegral R S\ninj : Function.Injective ⇑(algebraMap S A)\n⊢ Transcendental S a","decl":"lemma extendScalars_of_isIntegral [NoZeroDivisors S] [Algebra.IsIntegral R S]\n    (inj : Function.Injective (algebraMap S A)) : Transcendental S a := by\n  contrapose ha\n  rw [Transcendental, not_not] at ha ⊢\n  exact ha.restrictScalars_of_isIntegral _ inj\n\n"}
{"name":"Transcendental.extendScalars","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Ring A\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra S A\ninst✝² : IsScalarTower R S A\na : A\nha : Transcendental R a\ninst✝¹ : NoZeroDivisors S\ninst✝ : Algebra.IsAlgebraic R S\ninj : Function.Injective ⇑(algebraMap S A)\n⊢ Transcendental S a","decl":"lemma extendScalars [NoZeroDivisors S] [Algebra.IsAlgebraic R S]\n    (inj : Function.Injective (algebraMap S A)) : Transcendental S a := by\n  contrapose ha\n  rw [Transcendental, not_not] at ha ⊢\n  exact ha.restrictScalars _ inj\n\n"}
{"name":"Transcendental.integralClosure","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\na : S\nha : Transcendental R a\ninst✝ : NoZeroDivisors S\n⊢ Transcendental (Subtype fun x => Membership.mem (integralClosure R S) x) a","decl":"protected lemma integralClosure [NoZeroDivisors S] :\n    Transcendental (integralClosure R S) a :=\n  ha.extendScalars_of_isIntegral Subtype.val_injective\n\n"}
{"name":"Transcendental.subalgebraAlgebraicClosure","module":"Mathlib.RingTheory.Algebraic.Integral","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\na : S\nha : Transcendental R a\ninst✝¹ : IsDomain R\ninst✝ : NoZeroDivisors S\n⊢ Transcendental (Subtype fun x => Membership.mem (Subalgebra.algebraicClosure R S) x) a","decl":"lemma subalgebraAlgebraicClosure [IsDomain R] [NoZeroDivisors S] :\n    Transcendental (Subalgebra.algebraicClosure R S) a :=\n  ha.extendScalars Subtype.val_injective\n\n"}
