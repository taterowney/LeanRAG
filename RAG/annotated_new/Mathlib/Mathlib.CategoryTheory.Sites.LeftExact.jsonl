{"name":"CategoryTheory.GrothendieckTopology.coneCompEvaluationOfConeCompDiagramFunctorCompEvaluation_π_app","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nK : Type (max v u)\ninst✝ : CategoryTheory.SmallCategory K\nF : CategoryTheory.Functor K (CategoryTheory.Functor (Opposite C) D)\nW : J.Cover X\ni : W.Arrow\nE : CategoryTheory.Limits.Cone (F.comp ((J.diagramFunctor D X).comp ((CategoryTheory.evaluation (Opposite (J.Cover X)) D).obj { unop := W })))\nk : K\n⊢ Eq ((CategoryTheory.GrothendieckTopology.coneCompEvaluationOfConeCompDiagramFunctorCompEvaluation i E).π.app k) (CategoryTheory.CategoryStruct.comp (E.π.app k) (CategoryTheory.Limits.Multiequalizer.ι (W.index (F.obj k)) i))","decl":"/-- An auxiliary definition to be used in the proof of the fact that\n`J.diagramFunctor D X` preserves limits. -/\n@[simps]\ndef coneCompEvaluationOfConeCompDiagramFunctorCompEvaluation {X : C} {K : Type max v u}\n    [SmallCategory K] {F : K ⥤ Cᵒᵖ ⥤ D} {W : J.Cover X} (i : W.Arrow)\n    (E : Cone (F ⋙ J.diagramFunctor D X ⋙ (evaluation (J.Cover X)ᵒᵖ D).obj (op W))) :\n    Cone (F ⋙ (evaluation _ _).obj (op i.Y)) where\n  pt := E.pt\n  π :=\n    { app := fun k => E.π.app k ≫ Multiequalizer.ι (W.index (F.obj k)) i\n      naturality := by\n        intro a b f\n        dsimp\n        rw [Category.id_comp, Category.assoc, ← E.w f]\n        dsimp [diagramNatTrans]\n        simp only [Multiequalizer.lift_ι, Category.assoc] }\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.coneCompEvaluationOfConeCompDiagramFunctorCompEvaluation_pt","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nK : Type (max v u)\ninst✝ : CategoryTheory.SmallCategory K\nF : CategoryTheory.Functor K (CategoryTheory.Functor (Opposite C) D)\nW : J.Cover X\ni : W.Arrow\nE : CategoryTheory.Limits.Cone (F.comp ((J.diagramFunctor D X).comp ((CategoryTheory.evaluation (Opposite (J.Cover X)) D).obj { unop := W })))\n⊢ Eq (CategoryTheory.GrothendieckTopology.coneCompEvaluationOfConeCompDiagramFunctorCompEvaluation i E).pt E.pt","decl":"/-- An auxiliary definition to be used in the proof of the fact that\n`J.diagramFunctor D X` preserves limits. -/\n@[simps]\ndef coneCompEvaluationOfConeCompDiagramFunctorCompEvaluation {X : C} {K : Type max v u}\n    [SmallCategory K] {F : K ⥤ Cᵒᵖ ⥤ D} {W : J.Cover X} (i : W.Arrow)\n    (E : Cone (F ⋙ J.diagramFunctor D X ⋙ (evaluation (J.Cover X)ᵒᵖ D).obj (op W))) :\n    Cone (F ⋙ (evaluation _ _).obj (op i.Y)) where\n  pt := E.pt\n  π :=\n    { app := fun k => E.π.app k ≫ Multiequalizer.ι (W.index (F.obj k)) i\n      naturality := by\n        intro a b f\n        dsimp\n        rw [Category.id_comp, Category.assoc, ← E.w f]\n        dsimp [diagramNatTrans]\n        simp only [Multiequalizer.lift_ι, Category.assoc] }\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.liftToDiagramLimitObjAux_fac","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝³ : CategoryTheory.Category.{max v u, w} D\ninst✝² : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nK : Type (max v u)\ninst✝¹ : CategoryTheory.SmallCategory K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape K D\nW : Opposite (J.Cover X)\nF : CategoryTheory.Functor K (CategoryTheory.Functor (Opposite C) D)\nE : CategoryTheory.Limits.Cone (F.comp ((J.diagramFunctor D X).comp ((CategoryTheory.evaluation (Opposite (J.Cover X)) D).obj W)))\ni : (Opposite.unop W).Arrow\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GrothendieckTopology.liftToDiagramLimitObjAux F E i) ((CategoryTheory.Limits.limit.π F k).app { unop := i.Y })) (CategoryTheory.CategoryStruct.comp (E.π.app k) (CategoryTheory.Limits.Multiequalizer.ι ((Opposite.unop W).index (F.obj k)) i))","decl":"@[reassoc (attr := simp)]\nlemma liftToDiagramLimitObjAux_fac {X : C} {K : Type max v u} [SmallCategory K]\n    [HasLimitsOfShape K D] {W : (J.Cover X)ᵒᵖ} (F : K ⥤ Cᵒᵖ ⥤ D)\n    (E : Cone (F ⋙ J.diagramFunctor D X ⋙ (evaluation (J.Cover X)ᵒᵖ D).obj W))\n    (i : (unop W).Arrow) (k : K) :\n    liftToDiagramLimitObjAux F E i ≫ (limit.π F k).app (op i.Y) = E.π.app k ≫\n      Multiequalizer.ι ((unop W).index (F.obj k)) i :=\n  IsLimit.fac _ _ _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.liftToDiagramLimitObjAux_fac_assoc","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝³ : CategoryTheory.Category.{max v u, w} D\ninst✝² : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nK : Type (max v u)\ninst✝¹ : CategoryTheory.SmallCategory K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape K D\nW : Opposite (J.Cover X)\nF : CategoryTheory.Functor K (CategoryTheory.Functor (Opposite C) D)\nE : CategoryTheory.Limits.Cone (F.comp ((J.diagramFunctor D X).comp ((CategoryTheory.evaluation (Opposite (J.Cover X)) D).obj W)))\ni : (Opposite.unop W).Arrow\nk : K\nZ : D\nh : Quiver.Hom ((F.obj k).obj { unop := i.Y }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GrothendieckTopology.liftToDiagramLimitObjAux F E i) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.π F k).app { unop := i.Y }) h)) (CategoryTheory.CategoryStruct.comp (E.π.app k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.ι ((Opposite.unop W).index (F.obj k)) i) h))","decl":"@[reassoc (attr := simp)]\nlemma liftToDiagramLimitObjAux_fac {X : C} {K : Type max v u} [SmallCategory K]\n    [HasLimitsOfShape K D] {W : (J.Cover X)ᵒᵖ} (F : K ⥤ Cᵒᵖ ⥤ D)\n    (E : Cone (F ⋙ J.diagramFunctor D X ⋙ (evaluation (J.Cover X)ᵒᵖ D).obj W))\n    (i : (unop W).Arrow) (k : K) :\n    liftToDiagramLimitObjAux F E i ≫ (limit.π F k).app (op i.Y) = E.π.app k ≫\n      Multiequalizer.ι ((unop W).index (F.obj k)) i :=\n  IsLimit.fac _ _ _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.preservesLimit_diagramFunctor","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝³ : CategoryTheory.Category.{max v u, w} D\ninst✝² : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nK : Type (max v u)\ninst✝¹ : CategoryTheory.SmallCategory K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape K D\nF : CategoryTheory.Functor K (CategoryTheory.Functor (Opposite C) D)\n⊢ CategoryTheory.Limits.PreservesLimit F (J.diagramFunctor D X)","decl":"instance preservesLimit_diagramFunctor\n    (X : C) (K : Type max v u) [SmallCategory K] [HasLimitsOfShape K D] (F : K ⥤ Cᵒᵖ ⥤ D) :\n    PreservesLimit F (J.diagramFunctor D X) :=\n  preservesLimit_of_evaluation _ _ fun W =>\n    preservesLimit_of_preserves_limit_cone (limit.isLimit _)\n      { lift := fun E => liftToDiagramLimitObj.{w, v, u} F E\n        fac := by\n          intro E k\n          dsimp [diagramNatTrans]\n          refine Multiequalizer.hom_ext _ _ _ (fun a => ?_)\n          simp only [Multiequalizer.lift_ι, Multiequalizer.lift_ι_assoc, Category.assoc,\n            liftToDiagramLimitObjAux_fac]\n        uniq := by\n          intro E m hm\n          refine Multiequalizer.hom_ext _ _ _ (fun a => limit_obj_ext (fun j => ?_))\n          dsimp [liftToDiagramLimitObj]\n          rw [Multiequalizer.lift_ι, Category.assoc, liftToDiagramLimitObjAux_fac, ← hm,\n            Category.assoc]\n          dsimp\n          rw [limit.lift_π]\n          dsimp }\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.preservesLimitsOfShape_diagramFunctor","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝³ : CategoryTheory.Category.{max v u, w} D\ninst✝² : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nK : Type (max v u)\ninst✝¹ : CategoryTheory.SmallCategory K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape K D\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape K (J.diagramFunctor D X)","decl":"instance preservesLimitsOfShape_diagramFunctor\n    (X : C) (K : Type max v u) [SmallCategory K] [HasLimitsOfShape K D] :\n    PreservesLimitsOfShape K (J.diagramFunctor D X) :=\n  ⟨by apply preservesLimit_diagramFunctor.{w, v, u}⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.preservesLimits_diagramFunctor","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝² : CategoryTheory.Category.{max v u, w} D\ninst✝¹ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\ninst✝ : CategoryTheory.Limits.HasLimits D\n⊢ CategoryTheory.Limits.PreservesLimits (J.diagramFunctor D X)","decl":"instance preservesLimits_diagramFunctor (X : C) [HasLimits D] :\n    PreservesLimits (J.diagramFunctor D X) := by\n  constructor\n  intro _ _\n  apply preservesLimitsOfShape_diagramFunctor.{w, v, u}\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj_fac","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝¹⁰ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁹ : CategoryTheory.Category.{max v u, w} D\ninst✝⁸ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝⁷ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝⁶ : CategoryTheory.HasForget D\ninst✝⁵ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\nK : Type (max v u)\ninst✝⁴ : CategoryTheory.SmallCategory K\ninst✝³ : CategoryTheory.FinCategory K\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K D\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape K (CategoryTheory.forget D)\ninst✝ : CategoryTheory.Limits.ReflectsLimitsOfShape K (CategoryTheory.forget D)\nF : CategoryTheory.Functor K (CategoryTheory.Functor (Opposite C) D)\nX : C\nS : CategoryTheory.Limits.Cone (F.comp ((J.plusFunctor D).comp ((CategoryTheory.evaluation (Opposite C) D).obj { unop := X })))\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GrothendieckTopology.liftToPlusObjLimitObj F X S) ((J.plusMap (CategoryTheory.Limits.limit.π F k)).app { unop := X })) (S.π.app k)","decl":"theorem liftToPlusObjLimitObj_fac {K : Type max v u} [SmallCategory K] [FinCategory K]\n    [HasLimitsOfShape K D] [PreservesLimitsOfShape K (forget D)]\n    [ReflectsLimitsOfShape K (forget D)] (F : K ⥤ Cᵒᵖ ⥤ D) (X : C)\n    (S : Cone (F ⋙ J.plusFunctor D ⋙ (evaluation Cᵒᵖ D).obj (op X))) (k) :\n    liftToPlusObjLimitObj.{w, v, u} F X S ≫ (J.plusMap (limit.π F k)).app (op X) = S.π.app k := by\n  dsimp only [liftToPlusObjLimitObj]\n  rw [← (limit.isLimit (F ⋙ J.plusFunctor D ⋙ (evaluation Cᵒᵖ D).obj (op X))).fac S k,\n    Category.assoc]\n  congr 1\n  dsimp\n  rw [Category.assoc, Category.assoc, ← Iso.eq_inv_comp, Iso.inv_comp_eq, Iso.inv_comp_eq]\n  refine colimit.hom_ext (fun j => ?_)\n  dsimp [plusMap]\n  simp only [HasColimit.isoOfNatIso_ι_hom_assoc, ι_colimMap]\n  dsimp [IsLimit.conePointUniqueUpToIso, HasLimit.isoOfNatIso, IsLimit.map]\n  rw [limit.lift_π]\n  dsimp\n  rw [ι_colimitLimitIso_limit_π_assoc]\n  simp_rw [← Category.assoc, ← NatTrans.comp_app]\n  rw [limit.lift_π, Category.assoc]\n  congr 1\n  rw [← Iso.comp_inv_eq]\n  erw [colimit.ι_desc]\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.preservesLimitsOfShape_plusFunctor","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁸ : CategoryTheory.Category.{max v u, w} D\ninst✝⁷ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝⁶ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝⁵ : CategoryTheory.HasForget D\nK : Type (max v u)\ninst✝⁴ : CategoryTheory.SmallCategory K\ninst✝³ : CategoryTheory.FinCategory K\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K D\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape K (CategoryTheory.forget D)\ninst✝ : CategoryTheory.Limits.ReflectsLimitsOfShape K (CategoryTheory.forget D)\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape K (J.plusFunctor D)","decl":"instance preservesLimitsOfShape_plusFunctor\n    (K : Type max v u) [SmallCategory K] [FinCategory K] [HasLimitsOfShape K D]\n    [PreservesLimitsOfShape K (forget D)] [ReflectsLimitsOfShape K (forget D)] :\n    PreservesLimitsOfShape K (J.plusFunctor D) := by\n  constructor; intro F; apply preservesLimit_of_evaluation; intro X\n  apply preservesLimit_of_preserves_limit_cone (limit.isLimit F)\n  refine ⟨fun S => liftToPlusObjLimitObj.{w, v, u} F X.unop S, ?_, ?_⟩\n  · intro S k\n    apply liftToPlusObjLimitObj_fac\n  · intro S m hm\n    dsimp [liftToPlusObjLimitObj]\n    simp_rw [← Category.assoc, Iso.eq_comp_inv, ← Iso.comp_inv_eq]\n    refine limit.hom_ext (fun k => ?_)\n    simp only [limit.lift_π, Category.assoc, ← hm]\n    congr 1\n    refine colimit.hom_ext (fun k => ?_)\n    dsimp [plusMap, plusObj]\n    erw [colimit.ι_map, colimit.ι_desc_assoc, limit.lift_π]\n    conv_lhs => dsimp\n    simp only [Category.assoc]\n    rw [ι_colimitLimitIso_limit_π_assoc]\n    simp only [NatIso.ofComponents_inv_app, colimitObjIsoColimitCompEvaluation_ι_app_hom,\n      Iso.symm_inv]\n    conv_lhs =>\n      dsimp [IsLimit.conePointUniqueUpToIso]\n    rw [← Category.assoc, ← NatTrans.comp_app, limit.lift_π]\n    rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.preserveFiniteLimits_plusFunctor","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁶ : CategoryTheory.Category.{max v u, w} D\ninst✝⁵ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝⁴ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝³ : CategoryTheory.HasForget D\ninst✝² : CategoryTheory.Limits.HasFiniteLimits D\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.forget D)\ninst✝ : (CategoryTheory.forget D).ReflectsIsomorphisms\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (J.plusFunctor D)","decl":"instance preserveFiniteLimits_plusFunctor\n    [HasFiniteLimits D] [PreservesFiniteLimits (forget D)] [(forget D).ReflectsIsomorphisms] :\n    PreservesFiniteLimits (J.plusFunctor D) := by\n  apply preservesFiniteLimits_of_preservesFiniteLimitsOfSize.{max v u}\n  intro K _ _\n  have : ReflectsLimitsOfShape K (forget D) := reflectsLimitsOfShape_of_reflectsIsomorphisms\n  apply preservesLimitsOfShape_plusFunctor.{w, v, u}\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.preservesLimitsOfShape_sheafification","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁸ : CategoryTheory.Category.{max v u, w} D\ninst✝⁷ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝⁶ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝⁵ : CategoryTheory.HasForget D\nK : Type (max v u)\ninst✝⁴ : CategoryTheory.SmallCategory K\ninst✝³ : CategoryTheory.FinCategory K\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K D\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape K (CategoryTheory.forget D)\ninst✝ : CategoryTheory.Limits.ReflectsLimitsOfShape K (CategoryTheory.forget D)\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape K (J.sheafification D)","decl":"instance preservesLimitsOfShape_sheafification\n    (K : Type max v u) [SmallCategory K] [FinCategory K] [HasLimitsOfShape K D]\n    [PreservesLimitsOfShape K (forget D)] [ReflectsLimitsOfShape K (forget D)] :\n    PreservesLimitsOfShape K (J.sheafification D) :=\n  Limits.comp_preservesLimitsOfShape _ _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.preservesFiniteLimits_sheafification","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁶ : CategoryTheory.Category.{max v u, w} D\ninst✝⁵ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝⁴ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝³ : CategoryTheory.HasForget D\ninst✝² : CategoryTheory.Limits.HasFiniteLimits D\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.forget D)\ninst✝ : (CategoryTheory.forget D).ReflectsIsomorphisms\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (J.sheafification D)","decl":"instance preservesFiniteLimits_sheafification\n    [HasFiniteLimits D] [PreservesFiniteLimits (forget D)] [(forget D).ReflectsIsomorphisms] :\n    PreservesFiniteLimits (J.sheafification D) :=\n  Limits.comp_preservesFiniteLimits _ _\n\n"}
{"name":"CategoryTheory.preservesLimitsOfShape_presheafToSheaf","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁷ : CategoryTheory.Category.{max v u, w} D\ninst✝⁶ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝⁵ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝⁴ : CategoryTheory.HasForget D\ninst✝³ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝² : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝¹ : (CategoryTheory.forget D).ReflectsIsomorphisms\nK : Type w'\ninst✝ : CategoryTheory.SmallCategory K\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape K (CategoryTheory.plusPlusSheaf J D)","decl":"instance preservesLimitsOfShape_presheafToSheaf :\n    PreservesLimitsOfShape K (plusPlusSheaf J D) := by\n  let e := (FinCategory.equivAsType K).symm.trans (AsSmall.equiv.{0, 0, max v u})\n  haveI : HasLimitsOfShape (AsSmall.{max v u} (FinCategory.AsType K)) D :=\n    Limits.hasLimitsOfShape_of_equivalence e\n  haveI : FinCategory (AsSmall.{max v u} (FinCategory.AsType K)) := by\n    constructor\n    · show Fintype (ULift _)\n      infer_instance\n    · intro j j'\n      show Fintype (ULift _)\n      infer_instance\n  refine @preservesLimitsOfShape_of_equiv _ _ _ _ _ _ _ _ e.symm _ (show _ from ?_)\n  constructor; intro F; constructor; intro S hS; constructor\n  apply isLimitOfReflects (sheafToPresheaf J D)\n  have : ReflectsLimitsOfShape (AsSmall.{max v u} (FinCategory.AsType K)) (forget D) :=\n    reflectsLimitsOfShape_of_reflectsIsomorphisms\n  apply isLimitOfPreserves (J.sheafification D) hS\n\n"}
{"name":"CategoryTheory.preservesfiniteLimits_presheafToSheaf","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁷ : CategoryTheory.Category.{max v u, w} D\ninst✝⁶ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝⁵ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝⁴ : CategoryTheory.HasForget D\ninst✝³ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝² : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝¹ : (CategoryTheory.forget D).ReflectsIsomorphisms\ninst✝ : CategoryTheory.Limits.HasFiniteLimits D\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.plusPlusSheaf J D)","decl":"instance preservesfiniteLimits_presheafToSheaf [HasFiniteLimits D] :\n    PreservesFiniteLimits (plusPlusSheaf J D) := by\n  apply preservesFiniteLimits_of_preservesFiniteLimitsOfSize.{max v u}\n  intros\n  infer_instance\n\n"}
{"name":"CategoryTheory.toSheafify_plusPlusIsoSheafify_hom","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁶ : CategoryTheory.Category.{max v u, w} D\ninst✝⁵ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝⁴ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝³ : CategoryTheory.HasForget D\ninst✝² : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝¹ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝ : (CategoryTheory.forget D).ReflectsIsomorphisms\nP : CategoryTheory.Functor (Opposite C) D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (J.toSheafify P) (CategoryTheory.plusPlusIsoSheafify J D P).hom) (CategoryTheory.toSheafify J P)","decl":"@[reassoc (attr := simp)]\nlemma toSheafify_plusPlusIsoSheafify_hom (P : Cᵒᵖ ⥤ D) :\n    J.toSheafify P ≫ (plusPlusIsoSheafify J D P).hom = toSheafify J P := by\n  convert Adjunction.unit_leftAdjointUniq_hom_app\n    (plusPlusAdjunction J D) (sheafificationAdjunction J D) P\n  ext1 P\n  dsimp [GrothendieckTopology.toSheafify, plusPlusAdjunction]\n  rw [Category.comp_id]\n\n"}
{"name":"CategoryTheory.toSheafify_plusPlusIsoSheafify_hom_assoc","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁶ : CategoryTheory.Category.{max v u, w} D\ninst✝⁵ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝⁴ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝³ : CategoryTheory.HasForget D\ninst✝² : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝¹ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝ : (CategoryTheory.forget D).ReflectsIsomorphisms\nP Z : CategoryTheory.Functor (Opposite C) D\nh : Quiver.Hom (CategoryTheory.sheafify J P) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (J.toSheafify P) (CategoryTheory.CategoryStruct.comp (CategoryTheory.plusPlusIsoSheafify J D P).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J P) h)","decl":"@[reassoc (attr := simp)]\nlemma toSheafify_plusPlusIsoSheafify_hom (P : Cᵒᵖ ⥤ D) :\n    J.toSheafify P ≫ (plusPlusIsoSheafify J D P).hom = toSheafify J P := by\n  convert Adjunction.unit_leftAdjointUniq_hom_app\n    (plusPlusAdjunction J D) (sheafificationAdjunction J D) P\n  ext1 P\n  dsimp [GrothendieckTopology.toSheafify, plusPlusAdjunction]\n  rw [Category.comp_id]\n\n"}
{"name":"CategoryTheory.instHasSheafifyOfHasFiniteLimits","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁸ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁷ : CategoryTheory.Category.{max v u, w} D\ninst✝⁶ : ∀ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst✝⁵ : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst✝⁴ : CategoryTheory.HasForget D\ninst✝³ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (Opposite (J.Cover X)) (CategoryTheory.forget D)\ninst✝² : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)\ninst✝¹ : (CategoryTheory.forget D).ReflectsIsomorphisms\ninst✝ : CategoryTheory.Limits.HasFiniteLimits D\n⊢ CategoryTheory.HasSheafify J D","decl":"instance [HasFiniteLimits D] : HasSheafify J D := HasSheafify.mk' J D (plusPlusAdjunction J D)\n\n"}
{"name":"CategoryTheory.instFinitaryExtensiveSheafOfHasPullbacksOfHasSheafify","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝³ : CategoryTheory.Category.{w', w} D\ninst✝² : CategoryTheory.FinitaryExtensive D\ninst✝¹ : CategoryTheory.Limits.HasPullbacks D\ninst✝ : CategoryTheory.HasSheafify J D\n⊢ CategoryTheory.FinitaryExtensive (CategoryTheory.Sheaf J D)","decl":"instance [FinitaryExtensive D] [HasPullbacks D] [HasSheafify J D] :\n    FinitaryExtensive (Sheaf J D) :=\n  finitaryExtensive_of_reflective (sheafificationAdjunction _ _)\n\n"}
{"name":"CategoryTheory.instAdhesiveSheafOfHasPullbacksOfHasPushoutsOfHasSheafify","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst✝⁴ : CategoryTheory.Category.{w', w} D\ninst✝³ : CategoryTheory.Adhesive D\ninst✝² : CategoryTheory.Limits.HasPullbacks D\ninst✝¹ : CategoryTheory.Limits.HasPushouts D\ninst✝ : CategoryTheory.HasSheafify J D\n⊢ CategoryTheory.Adhesive (CategoryTheory.Sheaf J D)","decl":"instance [Adhesive D] [HasPullbacks D] [HasPushouts D] [HasSheafify J D] :\n    Adhesive (Sheaf J D) :=\n  adhesive_of_reflective (sheafificationAdjunction _ _)\n\n"}
{"name":"CategoryTheory.SheafOfTypes.finitary_extensive","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝ : CategoryTheory.HasSheafify J (Type w)\n⊢ CategoryTheory.FinitaryExtensive (CategoryTheory.Sheaf J (Type w))","decl":"instance SheafOfTypes.finitary_extensive [HasSheafify J (Type w)] :\n    FinitaryExtensive (Sheaf J (Type w)) :=\n  inferInstance\n\n"}
{"name":"CategoryTheory.SheafOfTypes.adhesive","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝ : CategoryTheory.HasSheafify J (Type w)\n⊢ CategoryTheory.Adhesive (CategoryTheory.Sheaf J (Type w))","decl":"instance SheafOfTypes.adhesive [HasSheafify J (Type w)] :\n    Adhesive (Sheaf J (Type w)) :=\n  inferInstance\n\n"}
{"name":"CategoryTheory.SheafOfTypes.balanced","module":"Mathlib.CategoryTheory.Sites.LeftExact","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\ninst✝ : CategoryTheory.HasSheafify J (Type w)\n⊢ CategoryTheory.Balanced (CategoryTheory.Sheaf J (Type w))","decl":"instance SheafOfTypes.balanced [HasSheafify J (Type w)] :\n    Balanced (Sheaf J (Type w)) :=\n  inferInstance\n\n"}
