{"name":"IsPGroup.iff_orderOf","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nhp : Fact (Nat.Prime p)\n⊢ Iff (IsPGroup p G) (∀ (g : G), Exists fun k => Eq (orderOf g) (HPow.hPow p k))","decl":"theorem iff_orderOf [hp : Fact p.Prime] : IsPGroup p G ↔ ∀ g : G, ∃ k : ℕ, orderOf g = p ^ k :=\n  forall_congr' fun g =>\n    ⟨fun ⟨_, hk⟩ =>\n      Exists.imp (fun _ h => h.right)\n        ((Nat.dvd_prime_pow hp.out).mp (orderOf_dvd_of_pow_eq_one hk)),\n      Exists.imp fun k hk => by rw [← hk, pow_orderOf_eq_one]⟩\n\n"}
{"name":"IsPGroup.of_card","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nn : Nat\nhG : Eq (Nat.card G) (HPow.hPow p n)\n⊢ IsPGroup p G","decl":"theorem of_card {n : ℕ} (hG : Nat.card G = p ^ n) : IsPGroup p G := fun g =>\n  ⟨n, by rw [← hG, pow_card_eq_one']⟩\n\n"}
{"name":"IsPGroup.of_bot","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\n⊢ IsPGroup p (Subtype fun x => Membership.mem Bot.bot x)","decl":"theorem of_bot : IsPGroup p (⊥ : Subgroup G) :=\n  of_card (n := 0) (by rw [Subgroup.card_bot, pow_zero])\n\n"}
{"name":"IsPGroup.iff_card","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite G\n⊢ Iff (IsPGroup p G) (Exists fun n => Eq (Nat.card G) (HPow.hPow p n))","decl":"theorem iff_card [Fact p.Prime] [Finite G] : IsPGroup p G ↔ ∃ n : ℕ, Nat.card G = p ^ n := by\n  have hG : Nat.card G ≠ 0 := Nat.card_pos.ne'\n  refine ⟨fun h => ?_, fun ⟨n, hn⟩ => of_card hn⟩\n  suffices ∀ q ∈ (Nat.card G).primeFactorsList, q = p by\n    use (Nat.card G).primeFactorsList.length\n    rw [← List.prod_replicate, ← List.eq_replicate_of_mem this, Nat.prod_primeFactorsList hG]\n  intro q hq\n  obtain ⟨hq1, hq2⟩ := (Nat.mem_primeFactorsList hG).mp hq\n  haveI : Fact q.Prime := ⟨hq1⟩\n  obtain ⟨g, hg⟩ := exists_prime_orderOf_dvd_card' q hq2\n  obtain ⟨k, hk⟩ := (iff_orderOf.mp h) g\n  exact (hq1.pow_eq_iff.mp (hg.symm.trans hk).symm).1.symm\n\n"}
{"name":"IsPGroup.exists_card_eq","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite G\na✝ : IsPGroup p G\n⊢ Exists fun n => Eq (Nat.card G) (HPow.hPow p n)","decl":"alias ⟨exists_card_eq, _⟩ := iff_card\n\n"}
{"name":"IsPGroup.of_injective","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nhG : IsPGroup p G\nH : Type u_2\ninst✝ : Group H\nϕ : MonoidHom H G\nhϕ : Function.Injective ⇑ϕ\n⊢ IsPGroup p H","decl":"theorem of_injective {H : Type*} [Group H] (ϕ : H →* G) (hϕ : Function.Injective ϕ) :\n    IsPGroup p H := by\n  simp_rw [IsPGroup, ← hϕ.eq_iff, ϕ.map_pow, ϕ.map_one]\n  exact fun h => hG (ϕ h)\n\n"}
{"name":"IsPGroup.to_subgroup","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nhG : IsPGroup p G\nH : Subgroup G\n⊢ IsPGroup p (Subtype fun x => Membership.mem H x)","decl":"theorem to_subgroup (H : Subgroup G) : IsPGroup p H :=\n  hG.of_injective H.subtype Subtype.coe_injective\n\n"}
{"name":"IsPGroup.of_surjective","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nhG : IsPGroup p G\nH : Type u_2\ninst✝ : Group H\nϕ : MonoidHom G H\nhϕ : Function.Surjective ⇑ϕ\n⊢ IsPGroup p H","decl":"theorem of_surjective {H : Type*} [Group H] (ϕ : G →* H) (hϕ : Function.Surjective ϕ) :\n    IsPGroup p H := by\n  refine fun h => Exists.elim (hϕ h) fun g hg => Exists.imp (fun k hk => ?_) (hG g)\n  rw [← hg, ← ϕ.map_pow, hk, ϕ.map_one]\n\n"}
{"name":"IsPGroup.to_quotient","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nhG : IsPGroup p G\nH : Subgroup G\ninst✝ : H.Normal\n⊢ IsPGroup p (HasQuotient.Quotient G H)","decl":"theorem to_quotient (H : Subgroup G) [H.Normal] : IsPGroup p (G ⧸ H) :=\n  hG.of_surjective (QuotientGroup.mk' H) Quotient.mk''_surjective\n\n"}
{"name":"IsPGroup.of_equiv","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nhG : IsPGroup p G\nH : Type u_2\ninst✝ : Group H\nϕ : MulEquiv G H\n⊢ IsPGroup p H","decl":"theorem of_equiv {H : Type*} [Group H] (ϕ : G ≃* H) : IsPGroup p H :=\n  hG.of_surjective ϕ.toMonoidHom ϕ.surjective\n\n"}
{"name":"IsPGroup.orderOf_coprime","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nhG : IsPGroup p G\nn : Nat\nhn : p.Coprime n\ng : G\n⊢ (orderOf g).Coprime n","decl":"theorem orderOf_coprime {n : ℕ} (hn : p.Coprime n) (g : G) : (orderOf g).Coprime n :=\n  let ⟨k, hk⟩ := hG g\n  (hn.pow_left k).coprime_dvd_left (orderOf_dvd_of_pow_eq_one hk)\n\n"}
{"name":"IsPGroup.powEquiv_apply","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nhG : IsPGroup p G\nn : Nat\nhn : p.Coprime n\ng : G\n⊢ Eq ((hG.powEquiv hn) g) (HPow.hPow g n)","decl":"@[simp]\ntheorem powEquiv_apply {n : ℕ} (hn : p.Coprime n) (g : G) : hG.powEquiv hn g = g ^ n :=\n  rfl\n\n"}
{"name":"IsPGroup.powEquiv_symm_apply","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nhG : IsPGroup p G\nn : Nat\nhn : p.Coprime n\ng : G\n⊢ Eq ((hG.powEquiv hn).symm g) (HPow.hPow g ((orderOf g).gcdB n))","decl":"@[simp]\ntheorem powEquiv_symm_apply {n : ℕ} (hn : p.Coprime n) (g : G) :\n    (hG.powEquiv hn).symm g = g ^ (orderOf g).gcdB n := by rw [← Nat.card_zpowers]; rfl\n\n"}
{"name":"IsPGroup.index","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nhG : IsPGroup p G\nhp : Fact (Nat.Prime p)\nH : Subgroup G\ninst✝ : H.FiniteIndex\n⊢ Exists fun n => Eq H.index (HPow.hPow p n)","decl":"theorem index (H : Subgroup G) [H.FiniteIndex] : ∃ n : ℕ, H.index = p ^ n := by\n  obtain ⟨n, hn⟩ := iff_card.mp (hG.to_quotient H.normalCore)\n  obtain ⟨k, _, hk2⟩ :=\n    (Nat.dvd_prime_pow hp.out).mp\n      ((congr_arg _ (H.normalCore.index_eq_card.trans hn)).mp\n        (Subgroup.index_dvd_of_le H.normalCore_le))\n  exact ⟨k, hk2⟩\n\n"}
{"name":"IsPGroup.card_eq_or_dvd","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nhG : IsPGroup p G\nhp : Fact (Nat.Prime p)\n⊢ Or (Eq (Nat.card G) 1) (Dvd.dvd p (Nat.card G))","decl":"theorem card_eq_or_dvd : Nat.card G = 1 ∨ p ∣ Nat.card G := by\n  cases finite_or_infinite G\n  · obtain ⟨n, hn⟩ := iff_card.mp hG\n    rw [hn]\n    cases' n with n n\n    · exact Or.inl rfl\n    · exact Or.inr ⟨p ^ n, by rw [pow_succ']⟩\n  · rw [Nat.card_eq_zero_of_infinite]\n    exact Or.inr ⟨0, rfl⟩\n\n"}
{"name":"IsPGroup.nontrivial_iff_card","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nhG : IsPGroup p G\nhp : Fact (Nat.Prime p)\ninst✝ : Finite G\n⊢ Iff (Nontrivial G) (Exists fun n => And (GT.gt n 0) (Eq (Nat.card G) (HPow.hPow p n)))","decl":"theorem nontrivial_iff_card [Finite G] : Nontrivial G ↔ ∃ n > 0, Nat.card G = p ^ n :=\n  ⟨fun hGnt =>\n    let ⟨k, hk⟩ := iff_card.1 hG\n    ⟨k,\n      Nat.pos_of_ne_zero fun hk0 => by\n        rw [hk0, pow_zero] at hk; exact Finite.one_lt_card.ne' hk,\n      hk⟩,\n    fun ⟨_, hk0, hk⟩ =>\n    Finite.one_lt_card_iff_nontrivial.1 <|\n      hk.symm ▸ one_lt_pow₀ (Fact.out (p := p.Prime)).one_lt (ne_of_gt hk0)⟩\n\n"}
{"name":"IsPGroup.card_orbit","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\nhG : IsPGroup p G\nhp : Fact (Nat.Prime p)\nα : Type u_2\ninst✝¹ : MulAction G α\na : α\ninst✝ : Finite ↑(MulAction.orbit G a)\n⊢ Exists fun n => Eq (Nat.card ↑(MulAction.orbit G a)) (HPow.hPow p n)","decl":"theorem card_orbit (a : α) [Finite (orbit G a)] : ∃ n : ℕ, Nat.card (orbit G a) = p ^ n := by\n  let ϕ := orbitEquivQuotientStabilizer G a\n  haveI := Finite.of_equiv (orbit G a) ϕ\n  haveI := (stabilizer G a).finiteIndex_of_finite_quotient\n  rw [Nat.card_congr ϕ]\n  exact hG.index (stabilizer G a)\n\n"}
{"name":"IsPGroup.card_modEq_card_fixedPoints","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\nhG : IsPGroup p G\nhp : Fact (Nat.Prime p)\nα : Type u_2\ninst✝¹ : MulAction G α\ninst✝ : Finite α\n⊢ p.ModEq (Nat.card α) (Nat.card ↑(MulAction.fixedPoints G α))","decl":"/-- If `G` is a `p`-group acting on a finite set `α`, then the number of fixed points\n  of the action is congruent mod `p` to the cardinality of `α` -/\ntheorem card_modEq_card_fixedPoints : Nat.card α ≡ Nat.card (fixedPoints G α) [MOD p] := by\n  have := Fintype.ofFinite α\n  have := Fintype.ofFinite (fixedPoints G α)\n  rw [Nat.card_eq_fintype_card, Nat.card_eq_fintype_card]\n  classical\n    calc\n      card α = card (Σy : Quotient (orbitRel G α), { x // Quotient.mk'' x = y }) :=\n        card_congr (Equiv.sigmaFiberEquiv (@Quotient.mk'' _ (orbitRel G α))).symm\n      _ = ∑ a : Quotient (orbitRel G α), card { x // Quotient.mk'' x = a } := card_sigma\n      _ ≡ ∑ _a : fixedPoints G α, 1 [MOD p] := ?_\n      _ = _ := by simp\n    rw [← ZMod.eq_iff_modEq_nat p, Nat.cast_sum, Nat.cast_sum]\n    have key :\n      ∀ x,\n        card { y // (Quotient.mk'' y : Quotient (orbitRel G α)) = Quotient.mk'' x } =\n          card (orbit G x) :=\n      fun x => by simp only [Quotient.eq'']; congr\n    refine\n      Eq.symm\n        (Finset.sum_bij_ne_zero (fun a _ _ => Quotient.mk'' a.1) (fun _ _ _ => Finset.mem_univ _)\n          (fun a₁ _ _ a₂ _ _ h =>\n            Subtype.eq (mem_fixedPoints'.mp a₂.2 a₁.1 (Quotient.exact' h)))\n          (fun b => Quotient.inductionOn' b fun b _ hb => ?_) fun a ha _ => by\n          rw [key, mem_fixedPoints_iff_card_orbit_eq_one.mp a.2])\n    obtain ⟨k, hk⟩ := hG.card_orbit b\n    rw [Nat.card_eq_fintype_card] at hk\n    have : k = 0 := by\n      contrapose! hb\n      simp [-Quotient.eq, key, hk, hb]\n    exact\n      ⟨⟨b, mem_fixedPoints_iff_card_orbit_eq_one.2 <| by rw [hk, this, pow_zero]⟩,\n        Finset.mem_univ _, ne_of_eq_of_ne Nat.cast_one one_ne_zero, rfl⟩\n\n"}
{"name":"IsPGroup.nonempty_fixed_point_of_prime_not_dvd_card","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nhG : IsPGroup p G\nhp : Fact (Nat.Prime p)\nα : Type u_3\ninst✝ : MulAction G α\nhpα : Not (Dvd.dvd p (Nat.card α))\n⊢ (MulAction.fixedPoints G α).Nonempty","decl":"/-- If a p-group acts on `α` and the cardinality of `α` is not a multiple\n  of `p` then the action has a fixed point. -/\ntheorem nonempty_fixed_point_of_prime_not_dvd_card (α) [MulAction G α] (hpα : ¬p ∣ Nat.card α) :\n    (fixedPoints G α).Nonempty :=\n  have : Finite α := Nat.finite_of_card_ne_zero (fun h ↦ (h ▸ hpα) (dvd_zero p))\n  @Set.Nonempty.of_subtype _ _\n    (by\n      rw [← Finite.card_pos_iff, pos_iff_ne_zero]\n      contrapose! hpα\n      rw [← Nat.modEq_zero_iff_dvd, ← hpα]\n      exact hG.card_modEq_card_fixedPoints α)\n\n"}
{"name":"IsPGroup.exists_fixed_point_of_prime_dvd_card_of_fixed_point","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\nhG : IsPGroup p G\nhp : Fact (Nat.Prime p)\nα : Type u_2\ninst✝¹ : MulAction G α\ninst✝ : Finite α\nhpα : Dvd.dvd p (Nat.card α)\na : α\nha : Membership.mem (MulAction.fixedPoints G α) a\n⊢ Exists fun b => And (Membership.mem (MulAction.fixedPoints G α) b) (Ne a b)","decl":"/-- If a p-group acts on `α` and the cardinality of `α` is a multiple\n  of `p`, and the action has one fixed point, then it has another fixed point. -/\ntheorem exists_fixed_point_of_prime_dvd_card_of_fixed_point (hpα : p ∣ Nat.card α) {a : α}\n    (ha : a ∈ fixedPoints G α) : ∃ b, b ∈ fixedPoints G α ∧ a ≠ b := by\n  have hpf : p ∣ Nat.card (fixedPoints G α) :=\n    Nat.modEq_zero_iff_dvd.mp ((hG.card_modEq_card_fixedPoints α).symm.trans hpα.modEq_zero_nat)\n  have hα : 1 < Nat.card (fixedPoints G α) :=\n    (Fact.out (p := p.Prime)).one_lt.trans_le (Nat.le_of_dvd (Finite.card_pos_iff.2 ⟨⟨a, ha⟩⟩) hpf)\n  rw [Finite.one_lt_card_iff_nontrivial] at hα\n  exact\n    let ⟨⟨b, hb⟩, hba⟩ := exists_ne (⟨a, ha⟩ : fixedPoints G α)\n    ⟨b, hb, fun hab => hba (by simp_rw [hab])⟩\n\n"}
{"name":"IsPGroup.center_nontrivial","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\nhG : IsPGroup p G\nhp : Fact (Nat.Prime p)\ninst✝¹ : Nontrivial G\ninst✝ : Finite G\n⊢ Nontrivial (Subtype fun x => Membership.mem (Subgroup.center G) x)","decl":"theorem center_nontrivial [Nontrivial G] [Finite G] : Nontrivial (Subgroup.center G) := by\n  classical\n    have := (hG.of_equiv ConjAct.toConjAct).exists_fixed_point_of_prime_dvd_card_of_fixed_point G\n    rw [ConjAct.fixedPoints_eq_center] at this\n    have dvd : p ∣ Nat.card G := by\n      obtain ⟨n, hn0, hn⟩ := hG.nontrivial_iff_card.mp inferInstance\n      exact hn.symm ▸ dvd_pow_self _ (ne_of_gt hn0)\n    obtain ⟨g, hg⟩ := this dvd (Subgroup.center G).one_mem\n    exact ⟨⟨1, ⟨g, hg.1⟩, mt Subtype.ext_iff.mp hg.2⟩⟩\n\n"}
{"name":"IsPGroup.bot_lt_center","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝² : Group G\nhG : IsPGroup p G\nhp : Fact (Nat.Prime p)\ninst✝¹ : Nontrivial G\ninst✝ : Finite G\n⊢ LT.lt Bot.bot (Subgroup.center G)","decl":"theorem bot_lt_center [Nontrivial G] [Finite G] : ⊥ < Subgroup.center G := by\n  haveI := center_nontrivial hG\n  classical exact\n      bot_lt_iff_ne_bot.mpr ((Subgroup.center G).one_lt_card_iff_ne_bot.mp Finite.one_lt_card)\n\n"}
{"name":"IsPGroup.to_le","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nhK : IsPGroup p (Subtype fun x => Membership.mem K x)\nhHK : LE.le H K\n⊢ IsPGroup p (Subtype fun x => Membership.mem H x)","decl":"theorem to_le {H K : Subgroup G} (hK : IsPGroup p K) (hHK : H ≤ K) : IsPGroup p H :=\n  hK.of_injective (Subgroup.inclusion hHK) fun a b h =>\n    Subtype.ext (by\n      change ((Subgroup.inclusion hHK) a : G) = (Subgroup.inclusion hHK) b\n      apply Subtype.ext_iff.mp h)\n\n"}
{"name":"IsPGroup.to_inf_left","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nhH : IsPGroup p (Subtype fun x => Membership.mem H x)\n⊢ IsPGroup p (Subtype fun x => Membership.mem (Min.min H K) x)","decl":"theorem to_inf_left {H K : Subgroup G} (hH : IsPGroup p H) : IsPGroup p (H ⊓ K : Subgroup G) :=\n  hH.to_le inf_le_left\n\n"}
{"name":"IsPGroup.to_inf_right","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nhK : IsPGroup p (Subtype fun x => Membership.mem K x)\n⊢ IsPGroup p (Subtype fun x => Membership.mem (Min.min H K) x)","decl":"theorem to_inf_right {H K : Subgroup G} (hK : IsPGroup p K) : IsPGroup p (H ⊓ K : Subgroup G) :=\n  hK.to_le inf_le_right\n\n"}
{"name":"IsPGroup.map","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\nhH : IsPGroup p (Subtype fun x => Membership.mem H x)\nK : Type u_2\ninst✝ : Group K\nϕ : MonoidHom G K\n⊢ IsPGroup p (Subtype fun x => Membership.mem (Subgroup.map ϕ H) x)","decl":"theorem map {H : Subgroup G} (hH : IsPGroup p H) {K : Type*} [Group K] (ϕ : G →* K) :\n    IsPGroup p (H.map ϕ) := by\n  rw [← H.range_subtype, MonoidHom.map_range]\n  exact hH.of_surjective (ϕ.restrict H).rangeRestrict (ϕ.restrict H).rangeRestrict_surjective\n\n"}
{"name":"IsPGroup.comap_of_ker_isPGroup","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\nhH : IsPGroup p (Subtype fun x => Membership.mem H x)\nK : Type u_2\ninst✝ : Group K\nϕ : MonoidHom K G\nhϕ : IsPGroup p (Subtype fun x => Membership.mem ϕ.ker x)\n⊢ IsPGroup p (Subtype fun x => Membership.mem (Subgroup.comap ϕ H) x)","decl":"theorem comap_of_ker_isPGroup {H : Subgroup G} (hH : IsPGroup p H) {K : Type*} [Group K]\n    (ϕ : K →* G) (hϕ : IsPGroup p ϕ.ker) : IsPGroup p (H.comap ϕ) := by\n  intro g\n  obtain ⟨j, hj⟩ := hH ⟨ϕ g.1, g.2⟩\n  rw [Subtype.ext_iff, H.coe_pow, Subtype.coe_mk, ← ϕ.map_pow] at hj\n  obtain ⟨k, hk⟩ := hϕ ⟨g.1 ^ p ^ j, hj⟩\n  rw [Subtype.ext_iff, ϕ.ker.coe_pow, Subtype.coe_mk, ← pow_mul, ← pow_add] at hk\n  exact ⟨j + k, by rwa [Subtype.ext_iff, (H.comap ϕ).coe_pow]⟩\n\n"}
{"name":"IsPGroup.ker_isPGroup_of_injective","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nK : Type u_2\ninst✝ : Group K\nϕ : MonoidHom K G\nhϕ : Function.Injective ⇑ϕ\n⊢ IsPGroup p (Subtype fun x => Membership.mem ϕ.ker x)","decl":"theorem ker_isPGroup_of_injective {K : Type*} [Group K] {ϕ : K →* G} (hϕ : Function.Injective ϕ) :\n    IsPGroup p ϕ.ker :=\n  (congr_arg (fun Q : Subgroup K => IsPGroup p Q) (ϕ.ker_eq_bot_iff.mpr hϕ)).mpr IsPGroup.of_bot\n\n"}
{"name":"IsPGroup.comap_of_injective","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\nhH : IsPGroup p (Subtype fun x => Membership.mem H x)\nK : Type u_2\ninst✝ : Group K\nϕ : MonoidHom K G\nhϕ : Function.Injective ⇑ϕ\n⊢ IsPGroup p (Subtype fun x => Membership.mem (Subgroup.comap ϕ H) x)","decl":"theorem comap_of_injective {H : Subgroup G} (hH : IsPGroup p H) {K : Type*} [Group K] (ϕ : K →* G)\n    (hϕ : Function.Injective ϕ) : IsPGroup p (H.comap ϕ) :=\n  hH.comap_of_ker_isPGroup ϕ (ker_isPGroup_of_injective hϕ)\n\n"}
{"name":"IsPGroup.comap_subtype","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nH : Subgroup G\nhH : IsPGroup p (Subtype fun x => Membership.mem H x)\nK : Subgroup G\n⊢ IsPGroup p (Subtype fun x => Membership.mem (Subgroup.comap K.subtype H) x)","decl":"theorem comap_subtype {H : Subgroup G} (hH : IsPGroup p H) {K : Subgroup G} :\n    IsPGroup p (H.comap K.subtype) :=\n  hH.comap_of_injective K.subtype Subtype.coe_injective\n\n"}
{"name":"IsPGroup.to_sup_of_normal_right","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\nhH : IsPGroup p (Subtype fun x => Membership.mem H x)\nhK : IsPGroup p (Subtype fun x => Membership.mem K x)\ninst✝ : K.Normal\n⊢ IsPGroup p (Subtype fun x => Membership.mem (Max.max H K) x)","decl":"theorem to_sup_of_normal_right {H K : Subgroup G} (hH : IsPGroup p H) (hK : IsPGroup p K)\n    [K.Normal] : IsPGroup p (H ⊔ K : Subgroup G) := by\n  rw [← QuotientGroup.ker_mk' K, ← Subgroup.comap_map_eq]\n  apply (hH.map (QuotientGroup.mk' K)).comap_of_ker_isPGroup\n  rwa [QuotientGroup.ker_mk']\n\n"}
{"name":"IsPGroup.to_sup_of_normal_left","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\nhH : IsPGroup p (Subtype fun x => Membership.mem H x)\nhK : IsPGroup p (Subtype fun x => Membership.mem K x)\ninst✝ : H.Normal\n⊢ IsPGroup p (Subtype fun x => Membership.mem (Max.max H K) x)","decl":"theorem to_sup_of_normal_left {H K : Subgroup G} (hH : IsPGroup p H) (hK : IsPGroup p K)\n    [H.Normal] : IsPGroup p (H ⊔ K : Subgroup G) := sup_comm H K ▸ to_sup_of_normal_right hK hH\n\n"}
{"name":"IsPGroup.to_sup_of_normal_right'","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nhH : IsPGroup p (Subtype fun x => Membership.mem H x)\nhK : IsPGroup p (Subtype fun x => Membership.mem K x)\nhHK : LE.le H K.normalizer\n⊢ IsPGroup p (Subtype fun x => Membership.mem (Max.max H K) x)","decl":"theorem to_sup_of_normal_right' {H K : Subgroup G} (hH : IsPGroup p H) (hK : IsPGroup p K)\n    (hHK : H ≤ K.normalizer) : IsPGroup p (H ⊔ K : Subgroup G) :=\n  let hHK' :=\n    to_sup_of_normal_right (hH.of_equiv (Subgroup.subgroupOfEquivOfLe hHK).symm)\n      (hK.of_equiv (Subgroup.subgroupOfEquivOfLe Subgroup.le_normalizer).symm)\n  ((congr_arg (fun H : Subgroup K.normalizer => IsPGroup p H)\n            (Subgroup.sup_subgroupOf_eq hHK Subgroup.le_normalizer)).mp\n        hHK').of_equiv\n    (Subgroup.subgroupOfEquivOfLe (sup_le hHK Subgroup.le_normalizer))\n\n"}
{"name":"IsPGroup.to_sup_of_normal_left'","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nhH : IsPGroup p (Subtype fun x => Membership.mem H x)\nhK : IsPGroup p (Subtype fun x => Membership.mem K x)\nhHK : LE.le K H.normalizer\n⊢ IsPGroup p (Subtype fun x => Membership.mem (Max.max H K) x)","decl":"theorem to_sup_of_normal_left' {H K : Subgroup G} (hH : IsPGroup p H) (hK : IsPGroup p K)\n    (hHK : K ≤ H.normalizer) : IsPGroup p (H ⊔ K : Subgroup G) :=\n  sup_comm H K ▸ to_sup_of_normal_right' hK hH hHK\n\n"}
{"name":"IsPGroup.coprime_card_of_ne","module":"Mathlib.GroupTheory.PGroup","initialProofState":"G : Type u_1\ninst✝³ : Group G\nG₂ : Type u_2\ninst✝² : Group G₂\np₁ p₂ : Nat\nhp₁ : Fact (Nat.Prime p₁)\nhp₂ : Fact (Nat.Prime p₂)\nhne : Ne p₁ p₂\nH₁ : Subgroup G\nH₂ : Subgroup G₂\ninst✝¹ : Finite (Subtype fun x => Membership.mem H₁ x)\ninst✝ : Finite (Subtype fun x => Membership.mem H₂ x)\nhH₁ : IsPGroup p₁ (Subtype fun x => Membership.mem H₁ x)\nhH₂ : IsPGroup p₂ (Subtype fun x => Membership.mem H₂ x)\n⊢ (Nat.card (Subtype fun x => Membership.mem H₁ x)).Coprime (Nat.card (Subtype fun x => Membership.mem H₂ x))","decl":"/-- finite p-groups with different p have coprime orders -/\ntheorem coprime_card_of_ne {G₂ : Type*} [Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact p₁.Prime]\n    [hp₂ : Fact p₂.Prime] (hne : p₁ ≠ p₂) (H₁ : Subgroup G) (H₂ : Subgroup G₂) [Finite H₁]\n    [Finite H₂] (hH₁ : IsPGroup p₁ H₁) (hH₂ : IsPGroup p₂ H₂) :\n    Nat.Coprime (Nat.card H₁) (Nat.card H₂) := by\n  obtain ⟨n₁, heq₁⟩ := iff_card.mp hH₁; rw [heq₁]; clear heq₁\n  obtain ⟨n₂, heq₂⟩ := iff_card.mp hH₂; rw [heq₂]; clear heq₂\n  exact Nat.coprime_pow_primes _ _ hp₁.elim hp₂.elim hne\n\n"}
{"name":"IsPGroup.disjoint_of_ne","module":"Mathlib.GroupTheory.PGroup","initialProofState":"G : Type u_1\ninst✝ : Group G\np₁ p₂ : Nat\nhp₁ : Fact (Nat.Prime p₁)\nhp₂ : Fact (Nat.Prime p₂)\nhne : Ne p₁ p₂\nH₁ H₂ : Subgroup G\nhH₁ : IsPGroup p₁ (Subtype fun x => Membership.mem H₁ x)\nhH₂ : IsPGroup p₂ (Subtype fun x => Membership.mem H₂ x)\n⊢ Disjoint H₁ H₂","decl":"/-- p-groups with different p are disjoint -/\ntheorem disjoint_of_ne (p₁ p₂ : ℕ) [hp₁ : Fact p₁.Prime] [hp₂ : Fact p₂.Prime] (hne : p₁ ≠ p₂)\n    (H₁ H₂ : Subgroup G) (hH₁ : IsPGroup p₁ H₁) (hH₂ : IsPGroup p₂ H₂) : Disjoint H₁ H₂ := by\n  rw [Subgroup.disjoint_def]\n  intro x hx₁ hx₂\n  obtain ⟨n₁, hn₁⟩ := iff_orderOf.mp hH₁ ⟨x, hx₁⟩\n  obtain ⟨n₂, hn₂⟩ := iff_orderOf.mp hH₂ ⟨x, hx₂⟩\n  rw [Subgroup.orderOf_mk] at hn₁ hn₂\n  have : p₁ ^ n₁ = p₂ ^ n₂ := by rw [← hn₁, ← hn₂]\n  rcases n₁.eq_zero_or_pos with (rfl | hn₁)\n  · simpa using hn₁\n  · exact absurd (eq_of_prime_pow_eq hp₁.out.prime hp₂.out.prime hn₁ this) hne\n\n"}
{"name":"IsPGroup.le_or_disjoint_of_coprime","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\nhp : Fact (Nat.Prime p)\nP : Subgroup G\nhP : IsPGroup p (Subtype fun x => Membership.mem P x)\nH : Subgroup G\ninst✝ : H.Normal\nh_cop : (Nat.card (Subtype fun x => Membership.mem H x)).Coprime H.index\n⊢ Or (LE.le P H) (Disjoint H P)","decl":"theorem le_or_disjoint_of_coprime [hp : Fact p.Prime] {P : Subgroup G} (hP : IsPGroup p P)\n    {H : Subgroup G} [H.Normal] (h_cop : (Nat.card H).Coprime H.index) :\n    P ≤ H ∨ Disjoint H P := by\n  by_cases h1 : Nat.card H = 0\n  · rw [h1, Nat.coprime_zero_left, Subgroup.index_eq_one] at h_cop\n    rw [h_cop]\n    exact Or.inl le_top\n  by_cases h2 : H.index = 0\n  · rw [h2, Nat.coprime_zero_right, Subgroup.card_eq_one] at h_cop\n    rw [h_cop]\n    exact Or.inr disjoint_bot_left\n  have : Finite G := by\n    apply Nat.finite_of_card_ne_zero\n    rw [← H.card_mul_index]\n    exact mul_ne_zero h1 h2\n  have h3 : (Nat.card H).Coprime (Nat.card P) ∨ H.index.Coprime (Nat.card P) := by\n    obtain ⟨k, hk⟩ := hP.exists_card_eq\n    refine hk ▸ Or.imp hp.out.coprime_pow_of_not_dvd hp.out.coprime_pow_of_not_dvd ?_\n    contrapose! h_cop\n    exact Nat.Prime.not_coprime_iff_dvd.mpr ⟨p, hp.out, h_cop⟩\n  refine h3.symm.imp (fun h4 ↦ ?_) (fun h4 ↦ ?_)\n  · rw [← Subgroup.relindex_eq_one]\n    exact Nat.eq_one_of_dvd_coprimes h4 (H.relindex_dvd_index_of_normal P)\n      (Subgroup.relindex_dvd_card H P)\n  · exact disjoint_iff.mpr (Subgroup.inf_eq_bot_of_coprime h4)\n\n"}
{"name":"IsPGroup.card_center_eq_prime_pow","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : Fact (Nat.Prime p)\nn : Nat\nhGpn : Eq (Nat.card G) (HPow.hPow p n)\nhn : LT.lt 0 n\n⊢ Exists fun k => And (GT.gt k 0) (Eq (Nat.card (Subtype fun x => Membership.mem (Subgroup.center G) x)) (HPow.hPow p k))","decl":"/-- The cardinality of the `center` of a `p`-group is `p ^ k` where `k` is positive. -/\ntheorem card_center_eq_prime_pow (hGpn : Nat.card G = p ^ n) (hn : 0 < n) :\n    ∃ k > 0, Nat.card (center G) = p ^ k := by\n  have : Finite G := Nat.finite_of_card_ne_zero (hGpn ▸ pow_ne_zero n (NeZero.ne p))\n  have hcG := to_subgroup (of_card hGpn) (center G)\n  rcases iff_card.1 hcG with _\n  haveI : Nontrivial G := (nontrivial_iff_card <| of_card hGpn).2 ⟨n, hn, hGpn⟩\n  exact (nontrivial_iff_card hcG).mp (center_nontrivial (of_card hGpn))\n\n"}
{"name":"IsPGroup.cyclic_center_quotient_of_card_eq_prime_sq","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : Fact (Nat.Prime p)\nhG : Eq (Nat.card G) (HPow.hPow p 2)\n⊢ IsCyclic (HasQuotient.Quotient G (Subgroup.center G))","decl":"/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem cyclic_center_quotient_of_card_eq_prime_sq (hG : Nat.card G = p ^ 2) :\n    IsCyclic (G ⧸ center G) := by\n  apply isCyclic_of_card_dvd_prime (p := p)\n  rw [← mul_dvd_mul_iff_left (NeZero.ne p), ← sq, ← hG, ← (center G).card_mul_index]\n  apply mul_dvd_mul_right\n  rcases card_center_eq_prime_pow hG zero_lt_two with ⟨k, hk0, hk⟩\n  rw [hk]\n  exact dvd_pow_self p hk0.ne'\n\n"}
{"name":"IsPGroup.commutative_of_card_eq_prime_sq","module":"Mathlib.GroupTheory.PGroup","initialProofState":"p : Nat\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : Fact (Nat.Prime p)\nhG : Eq (Nat.card G) (HPow.hPow p 2)\na b : G\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A group of order `p ^ 2` is commutative. See also `IsPGroup.commGroupOfCardEqPrimeSq`\nfor the `CommGroup` instance. -/\ntheorem commutative_of_card_eq_prime_sq (hG : Nat.card G = p ^ 2) : ∀ a b : G, a * b = b * a :=\n  (commGroupOfCardEqPrimeSq hG).mul_comm\n\n"}
{"name":"ZModModule.isPGroup_multiplicative","module":"Mathlib.GroupTheory.PGroup","initialProofState":"n : Nat\nG : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : Module (ZMod n) G\n⊢ IsPGroup n (Multiplicative G)","decl":"lemma isPGroup_multiplicative : IsPGroup n (Multiplicative G) := by\n  simpa [IsPGroup, Multiplicative.forall] using\n    fun _ ↦ ⟨1, by simp [← ofAdd_nsmul, ZModModule.char_nsmul_eq_zero]⟩\n\n"}
