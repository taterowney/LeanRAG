{"name":"WfDvdMonoid.of_wfDvdMonoid_associates","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CommMonoidWithZero α\nx✝ : WfDvdMonoid (Associates α)\n⊢ WfDvdMonoid α","decl":"theorem of_wfDvdMonoid_associates (_ : WfDvdMonoid (Associates α)) : WfDvdMonoid α :=\n  ⟨(mk_surjective.wellFounded_iff mk_dvdNotUnit_mk_iff.symm).2 wellFounded_dvdNotUnit⟩\n\n"}
{"name":"WfDvdMonoid.wfDvdMonoid_associates","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoidWithZero α\ninst✝ : WfDvdMonoid α\n⊢ WfDvdMonoid (Associates α)","decl":"instance wfDvdMonoid_associates : WfDvdMonoid (Associates α) :=\n  ⟨(mk_surjective.wellFounded_iff mk_dvdNotUnit_mk_iff.symm).1 wellFounded_dvdNotUnit⟩\n\n"}
{"name":"WfDvdMonoid.wellFoundedLT_associates","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoidWithZero α\ninst✝ : WfDvdMonoid α\n⊢ WellFoundedLT (Associates α)","decl":"theorem wellFoundedLT_associates : WellFoundedLT (Associates α) :=\n  ⟨Subrelation.wf dvdNotUnit_of_lt wellFounded_dvdNotUnit⟩\n\n"}
{"name":"WfDvdMonoid.wellFounded_associates","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoidWithZero α\ninst✝ : WfDvdMonoid α\n⊢ WellFounded fun x1 x2 => LT.lt x1 x2","decl":"@[deprecated wellFoundedLT_associates (since := \"2024-09-02\")]\ntheorem wellFounded_associates : WellFounded ((· < ·) : Associates α → Associates α → Prop) :=\n  Subrelation.wf dvdNotUnit_of_lt wellFounded_dvdNotUnit\n\n"}
{"name":"WfDvdMonoid.of_wellFoundedLT_associates","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\nh : WellFoundedLT (Associates α)\n⊢ WfDvdMonoid α","decl":"theorem WfDvdMonoid.of_wellFoundedLT_associates [CancelCommMonoidWithZero α]\n    (h : WellFoundedLT (Associates α)) : WfDvdMonoid α :=\n  WfDvdMonoid.of_wfDvdMonoid_associates\n    ⟨by\n      convert h.wf\n      ext\n      exact Associates.dvdNotUnit_iff_lt⟩\n\n"}
{"name":"WfDvdMonoid.of_wellFounded_associates","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\nh : WellFounded fun x1 x2 => LT.lt x1 x2\n⊢ WfDvdMonoid α","decl":"@[deprecated WfDvdMonoid.of_wellFoundedLT_associates (since := \"2024-09-02\")]\ntheorem WfDvdMonoid.of_wellFounded_associates [CancelCommMonoidWithZero α]\n    (h : WellFounded ((· < ·) : Associates α → Associates α → Prop)) : WfDvdMonoid α :=\n  WfDvdMonoid.of_wfDvdMonoid_associates\n    ⟨by\n      convert h\n      ext\n      exact Associates.dvdNotUnit_iff_lt⟩\n\n"}
{"name":"WfDvdMonoid.iff_wellFounded_associates","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\n⊢ Iff (WfDvdMonoid α) (WellFoundedLT (Associates α))","decl":"theorem WfDvdMonoid.iff_wellFounded_associates [CancelCommMonoidWithZero α] :\n    WfDvdMonoid α ↔ WellFoundedLT (Associates α) :=\n  ⟨by apply WfDvdMonoid.wellFoundedLT_associates, WfDvdMonoid.of_wellFoundedLT_associates⟩\n\n"}
{"name":"Associates.ufm","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\n⊢ UniqueFactorizationMonoid (Associates α)","decl":"instance Associates.ufm [CancelCommMonoidWithZero α] [UniqueFactorizationMonoid α] :\n    UniqueFactorizationMonoid (Associates α) :=\n  { (WfDvdMonoid.wfDvdMonoid_associates : WfDvdMonoid (Associates α)) with\n    irreducible_iff_prime := by\n      rw [← Associates.irreducible_iff_prime_iff]\n      apply UniqueFactorizationMonoid.irreducible_iff_prime }\n\n"}
{"name":"prime_factors_unique","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\nf g : Multiset α\na✝² : ∀ (x : α), Membership.mem f x → Prime x\na✝¹ : ∀ (x : α), Membership.mem g x → Prime x\na✝ : Associated f.prod g.prod\n⊢ Multiset.Rel Associated f g","decl":"theorem prime_factors_unique [CancelCommMonoidWithZero α] :\n    ∀ {f g : Multiset α},\n      (∀ x ∈ f, Prime x) → (∀ x ∈ g, Prime x) → f.prod ~ᵤ g.prod → Multiset.Rel Associated f g := by\n  classical\n  intro f\n  induction' f using Multiset.induction_on with p f ih\n  · intros g _ hg h\n    exact Multiset.rel_zero_left.2 <|\n      Multiset.eq_zero_of_forall_not_mem fun x hx =>\n        have : IsUnit g.prod := by simpa [associated_one_iff_isUnit] using h.symm\n        (hg x hx).not_unit <|\n          isUnit_iff_dvd_one.2 <| (Multiset.dvd_prod hx).trans (isUnit_iff_dvd_one.1 this)\n  · intros g hf hg hfg\n    let ⟨b, hbg, hb⟩ :=\n      (exists_associated_mem_of_dvd_prod (hf p (by simp)) fun q hq => hg _ hq) <|\n        hfg.dvd_iff_dvd_right.1 (show p ∣ (p ::ₘ f).prod by simp)\n    haveI := Classical.decEq α\n    rw [← Multiset.cons_erase hbg]\n    exact\n      Multiset.Rel.cons hb\n        (ih (fun q hq => hf _ (by simp [hq]))\n          (fun {q} (hq : q ∈ g.erase b) => hg q (Multiset.mem_of_mem_erase hq))\n          (Associated.of_mul_left\n            (by rwa [← Multiset.prod_cons, ← Multiset.prod_cons, Multiset.cons_erase hbg]) hb\n            (hf p (by simp)).ne_zero))\n\n"}
{"name":"UniqueFactorizationMonoid.factors_unique","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\nf g : Multiset α\nhf : ∀ (x : α), Membership.mem f x → Irreducible x\nhg : ∀ (x : α), Membership.mem g x → Irreducible x\nh : Associated f.prod g.prod\n⊢ Multiset.Rel Associated f g","decl":"theorem factors_unique {f g : Multiset α} (hf : ∀ x ∈ f, Irreducible x)\n    (hg : ∀ x ∈ g, Irreducible x) (h : f.prod ~ᵤ g.prod) : Multiset.Rel Associated f g :=\n  prime_factors_unique (fun x hx => UniqueFactorizationMonoid.irreducible_iff_prime.mp (hf x hx))\n    (fun x hx => UniqueFactorizationMonoid.irreducible_iff_prime.mp (hg x hx)) h\n\n"}
{"name":"prime_factors_irreducible","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\na : α\nf : Multiset α\nha : Irreducible a\npfa : And (∀ (b : α), Membership.mem f b → Prime b) (Associated f.prod a)\n⊢ Exists fun p => And (Associated a p) (Eq f (Singleton.singleton p))","decl":"/-- If an irreducible has a prime factorization,\n  then it is an associate of one of its prime factors. -/\ntheorem prime_factors_irreducible [CancelCommMonoidWithZero α] {a : α} {f : Multiset α}\n    (ha : Irreducible a) (pfa : (∀ b ∈ f, Prime b) ∧ f.prod ~ᵤ a) : ∃ p, a ~ᵤ p ∧ f = {p} := by\n  haveI := Classical.decEq α\n  refine @Multiset.induction_on _\n    (fun g => (g.prod ~ᵤ a) → (∀ b ∈ g, Prime b) → ∃ p, a ~ᵤ p ∧ g = {p}) f ?_ ?_ pfa.2 pfa.1\n  · intro h; exact (ha.not_unit (associated_one_iff_isUnit.1 (Associated.symm h))).elim\n  · rintro p s _ ⟨u, hu⟩ hs\n    use p\n    have hs0 : s = 0 := by\n      by_contra hs0\n      obtain ⟨q, hq⟩ := Multiset.exists_mem_of_ne_zero hs0\n      apply (hs q (by simp [hq])).2.1\n      refine (ha.isUnit_or_isUnit (?_ : _ = p * ↑u * (s.erase q).prod * _)).resolve_left ?_\n      · rw [mul_right_comm _ _ q, mul_assoc, ← Multiset.prod_cons, Multiset.cons_erase hq, ← hu,\n          mul_comm, mul_comm p _, mul_assoc]\n        simp\n      apply mt isUnit_of_mul_isUnit_left (mt isUnit_of_mul_isUnit_left _)\n      apply (hs p (Multiset.mem_cons_self _ _)).2.1\n    simp only [mul_one, Multiset.prod_cons, Multiset.prod_zero, hs0] at *\n    exact ⟨Associated.symm ⟨u, hu⟩, rfl⟩\n\n"}
{"name":"irreducible_iff_prime_of_existsUnique_irreducible_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\neif : ∀ (a : α), Ne a 0 → Exists fun f => And (∀ (b : α), Membership.mem f b → Irreducible b) (Associated f.prod a)\nuif : ∀ (f g : Multiset α), (∀ (x : α), Membership.mem f x → Irreducible x) → (∀ (x : α), Membership.mem g x → Irreducible x) → Associated f.prod g.prod → Multiset.Rel Associated f g\np : α\n⊢ Iff (Irreducible p) (Prime p)","decl":"theorem irreducible_iff_prime_of_existsUnique_irreducible_factors [CancelCommMonoidWithZero α]\n    (eif : ∀ a : α, a ≠ 0 → ∃ f : Multiset α, (∀ b ∈ f, Irreducible b) ∧ f.prod ~ᵤ a)\n    (uif :\n      ∀ f g : Multiset α,\n        (∀ x ∈ f, Irreducible x) →\n          (∀ x ∈ g, Irreducible x) → f.prod ~ᵤ g.prod → Multiset.Rel Associated f g)\n    (p : α) : Irreducible p ↔ Prime p :=\n  letI := Classical.decEq α\n  ⟨ fun hpi =>\n    ⟨hpi.ne_zero, hpi.1, fun a b ⟨x, hx⟩ =>\n      if hab0 : a * b = 0 then\n        (eq_zero_or_eq_zero_of_mul_eq_zero hab0).elim (fun ha0 => by simp [ha0]) fun hb0 => by\n          simp [hb0]\n      else by\n        have hx0 : x ≠ 0 := fun hx0 => by simp_all\n        have ha0 : a ≠ 0 := left_ne_zero_of_mul hab0\n        have hb0 : b ≠ 0 := right_ne_zero_of_mul hab0\n        cases' eif x hx0 with fx hfx\n        cases' eif a ha0 with fa hfa\n        cases' eif b hb0 with fb hfb\n        have h : Multiset.Rel Associated (p ::ₘ fx) (fa + fb) := by\n          apply uif\n          · exact fun i hi => (Multiset.mem_cons.1 hi).elim (fun hip => hip.symm ▸ hpi) (hfx.1 _)\n          · exact fun i hi => (Multiset.mem_add.1 hi).elim (hfa.1 _) (hfb.1 _)\n          calc\n            Multiset.prod (p ::ₘ fx) ~ᵤ a * b := by\n              rw [hx, Multiset.prod_cons]; exact hfx.2.mul_left _\n            _ ~ᵤ fa.prod * fb.prod := hfa.2.symm.mul_mul hfb.2.symm\n            _ = _ := by rw [Multiset.prod_add]\n\n        exact\n          let ⟨q, hqf, hq⟩ := Multiset.exists_mem_of_rel_of_mem h (Multiset.mem_cons_self p _)\n          (Multiset.mem_add.1 hqf).elim\n            (fun hqa =>\n              Or.inl <| hq.dvd_iff_dvd_left.2 <| hfa.2.dvd_iff_dvd_right.1 (Multiset.dvd_prod hqa))\n            fun hqb =>\n            Or.inr <| hq.dvd_iff_dvd_left.2 <| hfb.2.dvd_iff_dvd_right.1 (Multiset.dvd_prod hqb)⟩,\n    Prime.irreducible⟩\n\n"}
{"name":"irreducible_iff_prime_of_exists_unique_irreducible_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\neif : ∀ (a : α), Ne a 0 → Exists fun f => And (∀ (b : α), Membership.mem f b → Irreducible b) (Associated f.prod a)\nuif : ∀ (f g : Multiset α), (∀ (x : α), Membership.mem f x → Irreducible x) → (∀ (x : α), Membership.mem g x → Irreducible x) → Associated f.prod g.prod → Multiset.Rel Associated f g\np : α\n⊢ Iff (Irreducible p) (Prime p)","decl":"@[deprecated (since := \"2024-12-17\")]\nalias irreducible_iff_prime_of_exists_unique_irreducible_factors :=\n  irreducible_iff_prime_of_existsUnique_irreducible_factors\n\n"}
{"name":"UniqueFactorizationMonoid.factors_one","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\n⊢ Eq (UniqueFactorizationMonoid.factors 1) 0","decl":"@[simp]\ntheorem factors_one : factors (1 : α) = 0 := by\n  nontriviality α using factors\n  rw [← Multiset.rel_zero_right]\n  refine factors_unique irreducible_of_factor (fun x hx => (Multiset.not_mem_zero x hx).elim) ?_\n  rw [Multiset.prod_zero]\n  exact factors_prod one_ne_zero\n\n"}
{"name":"UniqueFactorizationMonoid.exists_mem_factors_of_dvd","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na p : α\nha0 : Ne a 0\nhp : Irreducible p\na✝ : Dvd.dvd p a\n⊢ Exists fun q => And (Membership.mem (UniqueFactorizationMonoid.factors a) q) (Associated p q)","decl":"theorem exists_mem_factors_of_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) :\n    p ∣ a → ∃ q ∈ factors a, p ~ᵤ q := fun ⟨b, hb⟩ =>\n  have hb0 : b ≠ 0 := fun hb0 => by simp_all\n  have : Multiset.Rel Associated (p ::ₘ factors b) (factors a) :=\n    factors_unique\n      (fun _ hx => (Multiset.mem_cons.1 hx).elim (fun h => h.symm ▸ hp) (irreducible_of_factor _))\n      irreducible_of_factor\n      (Associated.symm <|\n        calc\n          Multiset.prod (factors a) ~ᵤ a := factors_prod ha0\n          _ = p * b := hb\n          _ ~ᵤ Multiset.prod (p ::ₘ factors b) := by\n            rw [Multiset.prod_cons]; exact (factors_prod hb0).symm.mul_left _\n          )\n  Multiset.exists_mem_of_rel_of_mem this (by simp)\n\n"}
{"name":"UniqueFactorizationMonoid.exists_mem_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\nx : α\nhx : Ne x 0\nh : Not (IsUnit x)\n⊢ Exists fun p => Membership.mem (UniqueFactorizationMonoid.factors x) p","decl":"theorem exists_mem_factors {x : α} (hx : x ≠ 0) (h : ¬IsUnit x) : ∃ p, p ∈ factors x := by\n  obtain ⟨p', hp', hp'x⟩ := WfDvdMonoid.exists_irreducible_factor h hx\n  obtain ⟨p, hp, _⟩ := exists_mem_factors_of_dvd hx hp' hp'x\n  exact ⟨p, hp⟩\n\n"}
{"name":"UniqueFactorizationMonoid.factors_mul","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\nx y : α\nhx : Ne x 0\nhy : Ne y 0\n⊢ Multiset.Rel Associated (UniqueFactorizationMonoid.factors (HMul.hMul x y)) (HAdd.hAdd (UniqueFactorizationMonoid.factors x) (UniqueFactorizationMonoid.factors y))","decl":"open Classical in\ntheorem factors_mul {x y : α} (hx : x ≠ 0) (hy : y ≠ 0) :\n    Multiset.Rel Associated (factors (x * y)) (factors x + factors y) := by\n  refine\n    factors_unique irreducible_of_factor\n      (fun a ha =>\n        (Multiset.mem_add.mp ha).by_cases (irreducible_of_factor _) (irreducible_of_factor _))\n      ((factors_prod (mul_ne_zero hx hy)).trans ?_)\n  rw [Multiset.prod_add]\n  exact (Associated.mul_mul (factors_prod hx) (factors_prod hy)).symm\n\n"}
{"name":"UniqueFactorizationMonoid.factors_pow","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\nx : α\nn : Nat\n⊢ Multiset.Rel Associated (UniqueFactorizationMonoid.factors (HPow.hPow x n)) (HSMul.hSMul n (UniqueFactorizationMonoid.factors x))","decl":"theorem factors_pow {x : α} (n : ℕ) :\n    Multiset.Rel Associated (factors (x ^ n)) (n • factors x) := by\n  match n with\n  | 0 => rw [zero_smul, pow_zero, factors_one, Multiset.rel_zero_right]\n  | n+1 =>\n    by_cases h0 : x = 0\n    · simp [h0, zero_pow n.succ_ne_zero, smul_zero]\n    · rw [pow_succ', succ_nsmul']\n      refine Multiset.Rel.trans _ (factors_mul h0 (pow_ne_zero n h0)) ?_\n      refine Multiset.Rel.add ?_ <| factors_pow n\n      exact Multiset.rel_refl_of_refl_on fun y _ => Associated.refl _\n\n"}
{"name":"UniqueFactorizationMonoid.factors_pos","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\nx : α\nhx : Ne x 0\n⊢ Iff (LT.lt 0 (UniqueFactorizationMonoid.factors x)) (Not (IsUnit x))","decl":"@[simp]\ntheorem factors_pos (x : α) (hx : x ≠ 0) : 0 < factors x ↔ ¬IsUnit x := by\n  constructor\n  · intro h hx\n    obtain ⟨p, hp⟩ := Multiset.exists_mem_of_ne_zero h.ne'\n    exact (prime_of_factor _ hp).not_unit (isUnit_of_dvd_unit (dvd_of_mem_factors hp) hx)\n  · intro h\n    obtain ⟨p, hp⟩ := exists_mem_factors hx h\n    exact\n      bot_lt_iff_ne_bot.mpr\n        (mt Multiset.eq_zero_iff_forall_not_mem.mp (not_forall.mpr ⟨p, not_not.mpr hp⟩))\n\n"}
{"name":"UniqueFactorizationMonoid.factors_pow_count_prod","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : DecidableEq α\nx : α\nhx : Ne x 0\n⊢ Associated ((UniqueFactorizationMonoid.factors x).toFinset.prod fun p => HPow.hPow p (Multiset.count p (UniqueFactorizationMonoid.factors x))) x","decl":"open Multiset in\ntheorem factors_pow_count_prod [DecidableEq α] {x : α} (hx : x ≠ 0) :\n    (∏ p ∈ (factors x).toFinset, p ^ (factors x).count p) ~ᵤ x :=\n  calc\n  _ = prod (∑ a ∈ toFinset (factors x), count a (factors x) • {a}) := by\n    simp only [prod_sum, prod_nsmul, prod_singleton]\n  _ = prod (factors x) := by rw [toFinset_sum_count_nsmul_eq (factors x)]\n  _ ~ᵤ x := factors_prod hx\n\n"}
{"name":"UniqueFactorizationMonoid.factors_rel_of_associated","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na b : α\nh : Associated a b\n⊢ Multiset.Rel Associated (UniqueFactorizationMonoid.factors a) (UniqueFactorizationMonoid.factors b)","decl":"theorem factors_rel_of_associated {a b : α} (h : Associated a b) :\n    Multiset.Rel Associated (factors a) (factors b) := by\n  rcases iff_iff_and_or_not_and_not.mp h.eq_zero_iff with (⟨rfl, rfl⟩ | ⟨ha, hb⟩)\n  · simp\n  · refine factors_unique irreducible_of_factor irreducible_of_factor ?_\n    exact ((factors_prod ha).trans h).trans (factors_prod hb).symm\n\n"}
{"name":"Associates.unique'","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\np q : Multiset (Associates α)\na✝² : ∀ (a : Associates α), Membership.mem p a → Irreducible a\na✝¹ : ∀ (a : Associates α), Membership.mem q a → Irreducible a\na✝ : Eq p.prod q.prod\n⊢ Eq p q","decl":"theorem unique' {p q : Multiset (Associates α)} :\n    (∀ a ∈ p, Irreducible a) → (∀ a ∈ q, Irreducible a) → p.prod = q.prod → p = q := by\n  apply Multiset.induction_on_multiset_quot p\n  apply Multiset.induction_on_multiset_quot q\n  intro s t hs ht eq\n  refine Multiset.map_mk_eq_map_mk_of_rel (UniqueFactorizationMonoid.factors_unique ?_ ?_ ?_)\n  · exact fun a ha => irreducible_mk.1 <| hs _ <| Multiset.mem_map_of_mem _ ha\n  · exact fun a ha => irreducible_mk.1 <| ht _ <| Multiset.mem_map_of_mem _ ha\n  have eq' : (Quot.mk Setoid.r : α → Associates α) = Associates.mk := funext quot_mk_eq_mk\n  rwa [eq', prod_mk, prod_mk, mk_eq_mk_iff_associated] at eq\n\n"}
{"name":"Associates.prod_le_prod_iff_le","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : Nontrivial α\np q : Multiset (Associates α)\nhp : ∀ (a : Associates α), Membership.mem p a → Irreducible a\nhq : ∀ (a : Associates α), Membership.mem q a → Irreducible a\n⊢ Iff (LE.le p.prod q.prod) (LE.le p q)","decl":"theorem prod_le_prod_iff_le [Nontrivial α] {p q : Multiset (Associates α)}\n    (hp : ∀ a ∈ p, Irreducible a) (hq : ∀ a ∈ q, Irreducible a) : p.prod ≤ q.prod ↔ p ≤ q := by\n  refine ⟨?_, prod_le_prod⟩\n  rintro ⟨c, eqc⟩\n  refine Multiset.le_iff_exists_add.2 ⟨factors c, unique' hq (fun x hx ↦ ?_) ?_⟩\n  · obtain h | h := Multiset.mem_add.1 hx\n    · exact hp x h\n    · exact irreducible_of_factor _ h\n  · rw [eqc, Multiset.prod_add]\n    congr\n    refine associated_iff_eq.mp (factors_prod fun hc => ?_).symm\n    refine not_irreducible_zero (hq _ ?_)\n    rw [← prod_eq_zero_iff, eqc, hc, mul_zero]\n\n"}
{"name":"WfDvdMonoid.of_exists_prime_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\npf : ∀ (a : α), Ne a 0 → Exists fun f => And (∀ (b : α), Membership.mem f b → Prime b) (Associated f.prod a)\n⊢ WfDvdMonoid α","decl":"theorem WfDvdMonoid.of_exists_prime_factors : WfDvdMonoid α :=\n  ⟨by\n    classical\n      refine RelHomClass.wellFounded\n        (RelHom.mk ?_ ?_ : (DvdNotUnit : α → α → Prop) →r ((· < ·) : ℕ∞ → ℕ∞ → Prop)) wellFounded_lt\n      · intro a\n        by_cases h : a = 0\n        · exact ⊤\n        exact ↑(Multiset.card (Classical.choose (pf a h)))\n      rintro a b ⟨ane0, ⟨c, hc, b_eq⟩⟩\n      rw [dif_neg ane0]\n      by_cases h : b = 0\n      · simp [h, lt_top_iff_ne_top]\n      · rw [dif_neg h, Nat.cast_lt]\n        have cne0 : c ≠ 0 := by\n          refine mt (fun con => ?_) h\n          rw [b_eq, con, mul_zero]\n        calc\n          Multiset.card (Classical.choose (pf a ane0)) <\n              _ + Multiset.card (Classical.choose (pf c cne0)) :=\n            lt_add_of_pos_right _\n              (Multiset.card_pos.mpr fun con => hc (associated_one_iff_isUnit.mp ?_))\n          _ = Multiset.card (Classical.choose (pf a ane0) + Classical.choose (pf c cne0)) :=\n            (Multiset.card_add _ _).symm\n          _ = Multiset.card (Classical.choose (pf b h)) :=\n            Multiset.card_eq_card_of_rel\n            (prime_factors_unique ?_ (Classical.choose_spec (pf _ h)).1 ?_)\n\n        · convert (Classical.choose_spec (pf c cne0)).2.symm\n          rw [con, Multiset.prod_zero]\n        · intro x hadd\n          rw [Multiset.mem_add] at hadd\n          cases' hadd with h h <;> apply (Classical.choose_spec (pf _ _)).1 _ h <;> assumption\n        · rw [Multiset.prod_add]\n          trans a * c\n          · apply Associated.mul_mul <;> apply (Classical.choose_spec (pf _ _)).2 <;> assumption\n          · rw [← b_eq]\n            apply (Classical.choose_spec (pf _ _)).2.symm; assumption⟩\n\n"}
{"name":"irreducible_iff_prime_of_exists_prime_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\npf : ∀ (a : α), Ne a 0 → Exists fun f => And (∀ (b : α), Membership.mem f b → Prime b) (Associated f.prod a)\np : α\n⊢ Iff (Irreducible p) (Prime p)","decl":"theorem irreducible_iff_prime_of_exists_prime_factors {p : α} : Irreducible p ↔ Prime p := by\n  by_cases hp0 : p = 0\n  · simp [hp0]\n  refine ⟨fun h => ?_, Prime.irreducible⟩\n  obtain ⟨f, hf⟩ := pf p hp0\n  obtain ⟨q, hq, rfl⟩ := prime_factors_irreducible h hf\n  rw [hq.prime_iff]\n  exact hf.1 q (Multiset.mem_singleton_self _)\n\n"}
{"name":"UniqueFactorizationMonoid.of_exists_prime_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\npf : ∀ (a : α), Ne a 0 → Exists fun f => And (∀ (b : α), Membership.mem f b → Prime b) (Associated f.prod a)\n⊢ UniqueFactorizationMonoid α","decl":"theorem UniqueFactorizationMonoid.of_exists_prime_factors : UniqueFactorizationMonoid α :=\n  { WfDvdMonoid.of_exists_prime_factors pf with\n    irreducible_iff_prime := irreducible_iff_prime_of_exists_prime_factors pf }\n\n"}
{"name":"UniqueFactorizationMonoid.iff_exists_prime_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\n⊢ Iff (UniqueFactorizationMonoid α) (∀ (a : α), Ne a 0 → Exists fun f => And (∀ (b : α), Membership.mem f b → Prime b) (Associated f.prod a))","decl":"theorem UniqueFactorizationMonoid.iff_exists_prime_factors [CancelCommMonoidWithZero α] :\n    UniqueFactorizationMonoid α ↔\n      ∀ a : α, a ≠ 0 → ∃ f : Multiset α, (∀ b ∈ f, Prime b) ∧ f.prod ~ᵤ a :=\n  ⟨fun h => @UniqueFactorizationMonoid.exists_prime_factors _ _ h,\n    UniqueFactorizationMonoid.of_exists_prime_factors⟩\n\n"}
{"name":"MulEquiv.uniqueFactorizationMonoid","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : CancelCommMonoidWithZero β\ne : MulEquiv α β\nhα : UniqueFactorizationMonoid α\n⊢ UniqueFactorizationMonoid β","decl":"theorem MulEquiv.uniqueFactorizationMonoid (e : α ≃* β) (hα : UniqueFactorizationMonoid α) :\n    UniqueFactorizationMonoid β := by\n  rw [UniqueFactorizationMonoid.iff_exists_prime_factors] at hα ⊢\n  intro a ha\n  obtain ⟨w, hp, u, h⟩ :=\n    hα (e.symm a) fun h =>\n      ha <| by\n        convert← map_zero e\n        simp [← h]\n  exact\n    ⟨w.map e, fun b hb =>\n        let ⟨c, hc, he⟩ := Multiset.mem_map.1 hb\n        he ▸ e.prime_iff.2 (hp c hc),\n        Units.map e.toMonoidHom u,\n      by\n        rw [Multiset.prod_hom, toMonoidHom_eq_coe, Units.coe_map, MonoidHom.coe_coe, ← map_mul e, h,\n          apply_symm_apply]⟩\n\n"}
{"name":"MulEquiv.uniqueFactorizationMonoid_iff","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : CancelCommMonoidWithZero β\ne : MulEquiv α β\n⊢ Iff (UniqueFactorizationMonoid α) (UniqueFactorizationMonoid β)","decl":"theorem MulEquiv.uniqueFactorizationMonoid_iff (e : α ≃* β) :\n    UniqueFactorizationMonoid α ↔ UniqueFactorizationMonoid β :=\n  ⟨e.uniqueFactorizationMonoid, e.symm.uniqueFactorizationMonoid⟩\n\n"}
{"name":"UniqueFactorizationMonoid.of_existsUnique_irreducible_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\neif : ∀ (a : α), Ne a 0 → Exists fun f => And (∀ (b : α), Membership.mem f b → Irreducible b) (Associated f.prod a)\nuif : ∀ (f g : Multiset α), (∀ (x : α), Membership.mem f x → Irreducible x) → (∀ (x : α), Membership.mem g x → Irreducible x) → Associated f.prod g.prod → Multiset.Rel Associated f g\n⊢ UniqueFactorizationMonoid α","decl":"theorem of_existsUnique_irreducible_factors [CancelCommMonoidWithZero α]\n    (eif : ∀ a : α, a ≠ 0 → ∃ f : Multiset α, (∀ b ∈ f, Irreducible b) ∧ f.prod ~ᵤ a)\n    (uif :\n      ∀ f g : Multiset α,\n        (∀ x ∈ f, Irreducible x) →\n          (∀ x ∈ g, Irreducible x) → f.prod ~ᵤ g.prod → Multiset.Rel Associated f g) :\n    UniqueFactorizationMonoid α :=\n  UniqueFactorizationMonoid.of_exists_prime_factors\n    (by\n      convert eif using 7\n      simp_rw [irreducible_iff_prime_of_existsUnique_irreducible_factors eif uif])\n\n"}
{"name":"UniqueFactorizationMonoid.of_exists_unique_irreducible_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\neif : ∀ (a : α), Ne a 0 → Exists fun f => And (∀ (b : α), Membership.mem f b → Irreducible b) (Associated f.prod a)\nuif : ∀ (f g : Multiset α), (∀ (x : α), Membership.mem f x → Irreducible x) → (∀ (x : α), Membership.mem g x → Irreducible x) → Associated f.prod g.prod → Multiset.Rel Associated f g\n⊢ UniqueFactorizationMonoid α","decl":"@[deprecated (since := \"2024-12-17\")]\nalias of_exists_unique_irreducible_factors := of_existsUnique_irreducible_factors\n\n"}
{"name":"UniqueFactorizationMonoid.isRelPrime_iff_no_prime_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"R : Type u_2\ninst✝¹ : CancelCommMonoidWithZero R\ninst✝ : UniqueFactorizationMonoid R\na b : R\nha : Ne a 0\n⊢ Iff (IsRelPrime a b) (∀ ⦃d : R⦄, Dvd.dvd d a → Dvd.dvd d b → Not (Prime d))","decl":"theorem isRelPrime_iff_no_prime_factors {a b : R} (ha : a ≠ 0) :\n    IsRelPrime a b ↔ ∀ ⦃d⦄, d ∣ a → d ∣ b → ¬Prime d :=\n  ⟨fun h _ ha hb ↦ (·.not_unit <| h ha hb), fun h ↦ WfDvdMonoid.isRelPrime_of_no_irreducible_factors\n    (ha ·.1) fun _ irr ha hb ↦ h ha hb (UniqueFactorizationMonoid.irreducible_iff_prime.mp irr)⟩\n\n"}
{"name":"UniqueFactorizationMonoid.dvd_of_dvd_mul_left_of_no_prime_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"R : Type u_2\ninst✝¹ : CancelCommMonoidWithZero R\ninst✝ : UniqueFactorizationMonoid R\na b c : R\nha : Ne a 0\nh : ∀ ⦃d : R⦄, Dvd.dvd d a → Dvd.dvd d c → Not (Prime d)\na✝ : Dvd.dvd a (HMul.hMul b c)\n⊢ Dvd.dvd a b","decl":"/-- Euclid's lemma: if `a ∣ b * c` and `a` and `c` have no common prime factors, `a ∣ b`.\nCompare `IsCoprime.dvd_of_dvd_mul_left`. -/\ntheorem dvd_of_dvd_mul_left_of_no_prime_factors {a b c : R} (ha : a ≠ 0)\n    (h : ∀ ⦃d⦄, d ∣ a → d ∣ c → ¬Prime d) : a ∣ b * c → a ∣ b :=\n  ((isRelPrime_iff_no_prime_factors ha).mpr h).dvd_of_dvd_mul_right\n\n"}
{"name":"UniqueFactorizationMonoid.dvd_of_dvd_mul_right_of_no_prime_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"R : Type u_2\ninst✝¹ : CancelCommMonoidWithZero R\ninst✝ : UniqueFactorizationMonoid R\na b c : R\nha : Ne a 0\nno_factors : ∀ {d : R}, Dvd.dvd d a → Dvd.dvd d b → Not (Prime d)\na✝ : Dvd.dvd a (HMul.hMul b c)\n⊢ Dvd.dvd a c","decl":"/-- Euclid's lemma: if `a ∣ b * c` and `a` and `b` have no common prime factors, `a ∣ c`.\nCompare `IsCoprime.dvd_of_dvd_mul_right`. -/\ntheorem dvd_of_dvd_mul_right_of_no_prime_factors {a b c : R} (ha : a ≠ 0)\n    (no_factors : ∀ {d}, d ∣ a → d ∣ b → ¬Prime d) : a ∣ b * c → a ∣ c := by\n  simpa [mul_comm b c] using dvd_of_dvd_mul_left_of_no_prime_factors ha @no_factors\n\n"}
{"name":"UniqueFactorizationMonoid.exists_reduced_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"R : Type u_2\ninst✝¹ : CancelCommMonoidWithZero R\ninst✝ : UniqueFactorizationMonoid R\na : R\na✝ : Ne a 0\nb : R\n⊢ Exists fun a' => Exists fun b' => Exists fun c' => And (IsRelPrime a' b') (And (Eq (HMul.hMul c' a') a) (Eq (HMul.hMul c' b') b))","decl":"/-- If `a ≠ 0, b` are elements of a unique factorization domain, then dividing\nout their common factor `c'` gives `a'` and `b'` with no factors in common. -/\ntheorem exists_reduced_factors :\n    ∀ a ≠ (0 : R), ∀ b,\n      ∃ a' b' c', IsRelPrime a' b' ∧ c' * a' = a ∧ c' * b' = b := by\n  intro a\n  refine induction_on_prime a ?_ ?_ ?_\n  · intros\n    contradiction\n  · intro a a_unit _ b\n    use a, b, 1\n    constructor\n    · intro p p_dvd_a _\n      exact isUnit_of_dvd_unit p_dvd_a a_unit\n    · simp\n  · intro a p a_ne_zero p_prime ih_a pa_ne_zero b\n    by_cases h : p ∣ b\n    · rcases h with ⟨b, rfl⟩\n      obtain ⟨a', b', c', no_factor, ha', hb'⟩ := ih_a a_ne_zero b\n      refine ⟨a', b', p * c', @no_factor, ?_, ?_⟩\n      · rw [mul_assoc, ha']\n      · rw [mul_assoc, hb']\n    · obtain ⟨a', b', c', coprime, rfl, rfl⟩ := ih_a a_ne_zero b\n      refine ⟨p * a', b', c', ?_, mul_left_comm _ _ _, rfl⟩\n      intro q q_dvd_pa' q_dvd_b'\n      cases' p_prime.left_dvd_or_dvd_right_of_dvd_mul q_dvd_pa' with p_dvd_q q_dvd_a'\n      · have : p ∣ c' * b' := dvd_mul_of_dvd_right (p_dvd_q.trans q_dvd_b') _\n        contradiction\n      exact coprime q_dvd_a' q_dvd_b'\n\n"}
{"name":"UniqueFactorizationMonoid.exists_reduced_factors'","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"R : Type u_2\ninst✝¹ : CancelCommMonoidWithZero R\ninst✝ : UniqueFactorizationMonoid R\na b : R\nhb : Ne b 0\n⊢ Exists fun a' => Exists fun b' => Exists fun c' => And (IsRelPrime a' b') (And (Eq (HMul.hMul c' a') a) (Eq (HMul.hMul c' b') b))","decl":"theorem exists_reduced_factors' (a b : R) (hb : b ≠ 0) :\n    ∃ a' b' c', IsRelPrime a' b' ∧ c' * a' = a ∧ c' * b' = b :=\n  let ⟨b', a', c', no_factor, hb, ha⟩ := exists_reduced_factors b hb a\n  ⟨a', b', c', fun _ hpb hpa => no_factor hpa hpb, ha, hb⟩\n\n"}
{"name":"UniqueFactorizationMonoid.pow_right_injective","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\nq : M\nhq : Not (IsUnit q)\nhq' : Ne q 0\n⊢ Function.Injective fun n => HPow.hPow q n","decl":"@[deprecated (since := \"2024-09-21\")] alias pow_right_injective := pow_injective_of_not_isUnit\n"}
{"name":"UniqueFactorizationMonoid.pow_eq_pow_iff","module":"Mathlib.RingTheory.UniqueFactorizationDomain.Basic","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\nq : M\nhq : Not (IsUnit q)\nhq' : Ne q 0\nm n : Nat\n⊢ Iff (Eq (HPow.hPow q m) (HPow.hPow q n)) (Eq m n)","decl":"@[deprecated (since := \"2024-09-21\")] alias pow_eq_pow_iff := pow_inj_of_not_isUnit\n\n"}
