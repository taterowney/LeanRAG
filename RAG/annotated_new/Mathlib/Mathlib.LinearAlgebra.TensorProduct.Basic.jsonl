{"name":"TensorProduct.induction_on","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nmotive : TensorProduct R M N → Prop\nz : TensorProduct R M N\nzero : motive 0\ntmul : ∀ (x : M) (y : N), motive (TensorProduct.tmul R x y)\nadd : ∀ (x y : TensorProduct R M N), motive x → motive y → motive (HAdd.hAdd x y)\n⊢ motive z","decl":"@[elab_as_elim, induction_eliminator]\nprotected theorem induction_on {motive : M ⊗[R] N → Prop} (z : M ⊗[R] N)\n    (zero : motive 0)\n    (tmul : ∀ x y, motive <| x ⊗ₜ[R] y)\n    (add : ∀ x y, motive x → motive y → motive (x + y)) : motive z :=\n  AddCon.induction_on z fun x =>\n    FreeAddMonoid.recOn x zero fun ⟨m, n⟩ y ih => by\n      rw [AddCon.coe_add]\n      exact add _ _ (tmul ..) ih\n\n"}
{"name":"TensorProduct.liftAddHom_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : AddCommMonoid P\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : AddMonoidHom M (AddMonoidHom N P)\nhf : ∀ (r : R) (m : M) (n : N), Eq ((f (HSMul.hSMul r m)) n) ((f m) (HSMul.hSMul r n))\nm : M\nn : N\n⊢ Eq ((TensorProduct.liftAddHom f hf) (TensorProduct.tmul R m n)) ((f m) n)","decl":"@[simp]\ntheorem liftAddHom_tmul (f : M →+ N →+ P)\n    (hf : ∀ (r : R) (m : M) (n : N), f (r • m) n = f m (r • n)) (m : M) (n : N) :\n    liftAddHom f hf (m ⊗ₜ n) = f m n :=\n  rfl\n\n"}
{"name":"TensorProduct.zero_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nn : N\n⊢ Eq (TensorProduct.tmul R 0 n) 0","decl":"@[simp]\ntheorem zero_tmul (n : N) : (0 : M) ⊗ₜ[R] n = 0 :=\n  Quotient.sound' <| AddConGen.Rel.of _ _ <| Eqv.of_zero_left _\n\n"}
{"name":"TensorProduct.add_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nm₁ m₂ : M\nn : N\n⊢ Eq (TensorProduct.tmul R (HAdd.hAdd m₁ m₂) n) (HAdd.hAdd (TensorProduct.tmul R m₁ n) (TensorProduct.tmul R m₂ n))","decl":"theorem add_tmul (m₁ m₂ : M) (n : N) : (m₁ + m₂) ⊗ₜ n = m₁ ⊗ₜ n + m₂ ⊗ₜ[R] n :=\n  Eq.symm <| Quotient.sound' <| AddConGen.Rel.of _ _ <| Eqv.of_add_left _ _ _\n\n"}
{"name":"TensorProduct.tmul_zero","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nm : M\n⊢ Eq (TensorProduct.tmul R m 0) 0","decl":"@[simp]\ntheorem tmul_zero (m : M) : m ⊗ₜ[R] (0 : N) = 0 :=\n  Quotient.sound' <| AddConGen.Rel.of _ _ <| Eqv.of_zero_right _\n\n"}
{"name":"TensorProduct.tmul_add","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nm : M\nn₁ n₂ : N\n⊢ Eq (TensorProduct.tmul R m (HAdd.hAdd n₁ n₂)) (HAdd.hAdd (TensorProduct.tmul R m n₁) (TensorProduct.tmul R m n₂))","decl":"theorem tmul_add (m : M) (n₁ n₂ : N) : m ⊗ₜ (n₁ + n₂) = m ⊗ₜ n₁ + m ⊗ₜ[R] n₂ :=\n  Eq.symm <| Quotient.sound' <| AddConGen.Rel.of _ _ <| Eqv.of_add_right _ _ _\n\n"}
{"name":"TensorProduct.CompatibleSMul.smul_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nR' : Type u_2\ninst✝⁶ : Monoid R'\nM : Type u_5\nN : Type u_6\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : DistribMulAction R' M\ninst✝ : DistribMulAction R' N\nself : TensorProduct.CompatibleSMul R R' M N\nr : R'\nm : M\nn : N\n⊢ Eq (TensorProduct.tmul R (HSMul.hSMul r m) n) (TensorProduct.tmul R m (HSMul.hSMul r n))","decl":"/-- A typeclass for `SMul` structures which can be moved across a tensor product.\n\nThis typeclass is generated automatically from an `IsScalarTower` instance, but exists so that\nwe can also add an instance for `AddCommGroup.toIntModule`, allowing `z •` to be moved even if\n`R` does not support negation.\n\nNote that `Module R' (M ⊗[R] N)` is available even without this typeclass on `R'`; it's only\nneeded if `TensorProduct.smul_tmul`, `TensorProduct.smul_tmul'`, or `TensorProduct.tmul_smul` is\nused.\n-/\nclass CompatibleSMul [DistribMulAction R' N] : Prop where\n  smul_tmul : ∀ (r : R') (m : M) (n : N), (r • m) ⊗ₜ n = m ⊗ₜ[R] (r • n)\n\n"}
{"name":"TensorProduct.CompatibleSMul.isScalarTower","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nR' : Type u_2\ninst✝⁹ : Monoid R'\nM : Type u_5\nN : Type u_6\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R M\ninst✝⁵ : Module R N\ninst✝⁴ : DistribMulAction R' M\ninst✝³ : SMul R' R\ninst✝² : IsScalarTower R' R M\ninst✝¹ : DistribMulAction R' N\ninst✝ : IsScalarTower R' R N\n⊢ TensorProduct.CompatibleSMul R R' M N","decl":"/-- Note that this provides the default `CompatibleSMul R R M N` instance through\n`IsScalarTower.left`. -/\ninstance (priority := 100) CompatibleSMul.isScalarTower [SMul R' R] [IsScalarTower R' R M]\n    [DistribMulAction R' N] [IsScalarTower R' R N] : CompatibleSMul R R' M N :=\n  ⟨fun r m n => by\n    conv_lhs => rw [← one_smul R m]\n    conv_rhs => rw [← one_smul R n]\n    rw [← smul_assoc, ← smul_assoc]\n    exact Quotient.sound' <| AddConGen.Rel.of _ _ <| Eqv.of_smul _ _ _⟩\n\n"}
{"name":"TensorProduct.smul_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nR' : Type u_2\ninst✝⁷ : Monoid R'\nM : Type u_5\nN : Type u_6\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : DistribMulAction R' M\ninst✝¹ : DistribMulAction R' N\ninst✝ : TensorProduct.CompatibleSMul R R' M N\nr : R'\nm : M\nn : N\n⊢ Eq (TensorProduct.tmul R (HSMul.hSMul r m) n) (TensorProduct.tmul R m (HSMul.hSMul r n))","decl":"/-- `smul` can be moved from one side of the product to the other . -/\ntheorem smul_tmul [DistribMulAction R' N] [CompatibleSMul R R' M N] (r : R') (m : M) (n : N) :\n    (r • m) ⊗ₜ n = m ⊗ₜ[R] (r • n) :=\n  CompatibleSMul.smul_tmul _ _ _\n\n-- Porting note: This is added as a local instance for `SMul.aux`.\n-- For some reason type-class inference in Lean 3 unfolded this definition.\n"}
{"name":"TensorProduct.SMul.aux_of","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R M\ninst✝¹ : Module R N\nR' : Type u_11\ninst✝ : SMul R' M\nr : R'\nm : M\nn : N\n⊢ Eq ((TensorProduct.SMul.aux r) (FreeAddMonoid.of { fst := m, snd := n })) (TensorProduct.tmul R (HSMul.hSMul r m) n)","decl":"theorem SMul.aux_of {R' : Type*} [SMul R' M] (r : R') (m : M) (n : N) :\n    SMul.aux r (.of (m, n)) = (r • m) ⊗ₜ[R] n :=\n  rfl\n\n"}
{"name":"TensorProduct.smul_zero","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nR' : Type u_2\ninst✝⁶ : Monoid R'\nM : Type u_5\nN : Type u_6\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : DistribMulAction R' M\ninst✝ : SMulCommClass R R' M\nr : R'\n⊢ Eq (HSMul.hSMul r 0) 0","decl":"protected theorem smul_zero (r : R') : r • (0 : M ⊗[R] N) = 0 :=\n  AddMonoidHom.map_zero _\n\n"}
{"name":"TensorProduct.smul_add","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nR' : Type u_2\ninst✝⁶ : Monoid R'\nM : Type u_5\nN : Type u_6\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : DistribMulAction R' M\ninst✝ : SMulCommClass R R' M\nr : R'\nx y : TensorProduct R M N\n⊢ Eq (HSMul.hSMul r (HAdd.hAdd x y)) (HAdd.hAdd (HSMul.hSMul r x) (HSMul.hSMul r y))","decl":"protected theorem smul_add (r : R') (x y : M ⊗[R] N) : r • (x + y) = r • x + r • y :=\n  AddMonoidHom.map_add _ _ _\n\n"}
{"name":"TensorProduct.zero_smul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nR'' : Type u_3\ninst✝⁶ : Semiring R''\nM : Type u_5\nN : Type u_6\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R'' M\ninst✝ : SMulCommClass R R'' M\nx : TensorProduct R M N\n⊢ Eq (HSMul.hSMul 0 x) 0","decl":"protected theorem zero_smul (x : M ⊗[R] N) : (0 : R'') • x = 0 :=\n  have : ∀ (r : R'') (m : M) (n : N), r • m ⊗ₜ[R] n = (r • m) ⊗ₜ n := fun _ _ _ => rfl\n  x.induction_on (by rw [TensorProduct.smul_zero])\n    (fun m n => by rw [this, zero_smul, zero_tmul]) fun x y ihx ihy => by\n    rw [TensorProduct.smul_add, ihx, ihy, add_zero]\n\n"}
{"name":"TensorProduct.one_smul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nR' : Type u_2\ninst✝⁶ : Monoid R'\nM : Type u_5\nN : Type u_6\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : DistribMulAction R' M\ninst✝ : SMulCommClass R R' M\nx : TensorProduct R M N\n⊢ Eq (HSMul.hSMul 1 x) x","decl":"protected theorem one_smul (x : M ⊗[R] N) : (1 : R') • x = x :=\n  have : ∀ (r : R') (m : M) (n : N), r • m ⊗ₜ[R] n = (r • m) ⊗ₜ n := fun _ _ _ => rfl\n  x.induction_on (by rw [TensorProduct.smul_zero])\n    (fun m n => by rw [this, one_smul])\n    fun x y ihx ihy => by rw [TensorProduct.smul_add, ihx, ihy]\n\n"}
{"name":"TensorProduct.add_smul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nR'' : Type u_3\ninst✝⁶ : Semiring R''\nM : Type u_5\nN : Type u_6\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R'' M\ninst✝ : SMulCommClass R R'' M\nr s : R''\nx : TensorProduct R M N\n⊢ Eq (HSMul.hSMul (HAdd.hAdd r s) x) (HAdd.hAdd (HSMul.hSMul r x) (HSMul.hSMul s x))","decl":"protected theorem add_smul (r s : R'') (x : M ⊗[R] N) : (r + s) • x = r • x + s • x :=\n  have : ∀ (r : R'') (m : M) (n : N), r • m ⊗ₜ[R] n = (r • m) ⊗ₜ n := fun _ _ _ => rfl\n  x.induction_on (by simp_rw [TensorProduct.smul_zero, add_zero])\n    (fun m n => by simp_rw [this, add_smul, add_tmul]) fun x y ihx ihy => by\n    simp_rw [TensorProduct.smul_add]\n    rw [ihx, ihy, add_add_add_comm]\n\n"}
{"name":"TensorProduct.smul_tmul'","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nR' : Type u_2\ninst✝⁶ : Monoid R'\nM : Type u_5\nN : Type u_6\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : DistribMulAction R' M\ninst✝ : SMulCommClass R R' M\nr : R'\nm : M\nn : N\n⊢ Eq (HSMul.hSMul r (TensorProduct.tmul R m n)) (TensorProduct.tmul R (HSMul.hSMul r m) n)","decl":"theorem smul_tmul' (r : R') (m : M) (n : N) : r • m ⊗ₜ[R] n = (r • m) ⊗ₜ n :=\n  rfl\n\n"}
{"name":"TensorProduct.tmul_smul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁹ : CommSemiring R\nR' : Type u_2\ninst✝⁸ : Monoid R'\nM : Type u_5\nN : Type u_6\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : DistribMulAction R' M\ninst✝² : SMulCommClass R R' M\ninst✝¹ : DistribMulAction R' N\ninst✝ : TensorProduct.CompatibleSMul R R' M N\nr : R'\nx : M\ny : N\n⊢ Eq (TensorProduct.tmul R x (HSMul.hSMul r y)) (HSMul.hSMul r (TensorProduct.tmul R x y))","decl":"@[simp]\ntheorem tmul_smul [DistribMulAction R' N] [CompatibleSMul R R' M N] (r : R') (x : M) (y : N) :\n    x ⊗ₜ (r • y) = r • x ⊗ₜ[R] y :=\n  (smul_tmul _ _ _).symm\n\n"}
{"name":"TensorProduct.smul_tmul_smul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nr s : R\nm : M\nn : N\n⊢ Eq (TensorProduct.tmul R (HSMul.hSMul r m) (HSMul.hSMul s n)) (HSMul.hSMul (HMul.hMul r s) (TensorProduct.tmul R m n))","decl":"theorem smul_tmul_smul (r s : R) (m : M) (n : N) : (r • m) ⊗ₜ[R] (s • n) = (r * s) • m ⊗ₜ[R] n := by\n  simp_rw [smul_tmul, tmul_smul, mul_smul]\n\n"}
{"name":"TensorProduct.instIsCentralScalar","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nR'' : Type u_3\ninst✝⁷ : Semiring R''\nM : Type u_5\nN : Type u_6\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R'' M\ninst✝¹ : Module (MulOpposite R'') M\ninst✝ : IsCentralScalar R'' M\n⊢ IsCentralScalar R'' (TensorProduct R M N)","decl":"instance [Module R''ᵐᵒᵖ M] [IsCentralScalar R'' M] : IsCentralScalar R'' (M ⊗[R] N) where\n  op_smul_eq_smul r x :=\n    x.induction_on (by rw [smul_zero, smul_zero])\n      (fun x y => by rw [smul_tmul', smul_tmul', op_smul_eq_smul]) fun x y hx hy => by\n      rw [smul_add, smul_add, hx, hy]\n\n"}
{"name":"TensorProduct.smulCommClass_left","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁹ : CommSemiring R\nR' : Type u_2\ninst✝⁸ : Monoid R'\nM : Type u_5\nN : Type u_6\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : DistribMulAction R' M\nR'₂ : Type u_11\ninst✝² : Monoid R'₂\ninst✝¹ : DistribMulAction R'₂ M\ninst✝ : SMulCommClass R' R'₂ M\n⊢ SMulCommClass R' R'₂ (TensorProduct R M N)","decl":"/-- `SMulCommClass R' R'₂ M` implies `SMulCommClass R' R'₂ (M ⊗[R] N)` -/\ninstance smulCommClass_left [SMulCommClass R' R'₂ M] : SMulCommClass R' R'₂ (M ⊗[R] N) where\n  smul_comm r' r'₂ x :=\n    TensorProduct.induction_on x (by simp_rw [TensorProduct.smul_zero])\n      (fun m n => by simp_rw [smul_tmul', smul_comm]) fun x y ihx ihy => by\n      simp_rw [TensorProduct.smul_add]; rw [ihx, ihy]\n\n"}
{"name":"TensorProduct.isScalarTower_left","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nR' : Type u_2\ninst✝⁹ : Monoid R'\nM : Type u_5\nN : Type u_6\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R M\ninst✝⁵ : Module R N\ninst✝⁴ : DistribMulAction R' M\nR'₂ : Type u_11\ninst✝³ : Monoid R'₂\ninst✝² : DistribMulAction R'₂ M\ninst✝¹ : SMul R'₂ R'\ninst✝ : IsScalarTower R'₂ R' M\n⊢ IsScalarTower R'₂ R' (TensorProduct R M N)","decl":"/-- `IsScalarTower R'₂ R' M` implies `IsScalarTower R'₂ R' (M ⊗[R] N)` -/\ninstance isScalarTower_left [IsScalarTower R'₂ R' M] : IsScalarTower R'₂ R' (M ⊗[R] N) :=\n  ⟨fun s r x =>\n    x.induction_on (by simp)\n      (fun m n => by rw [smul_tmul', smul_tmul', smul_tmul', smul_assoc]) fun x y ihx ihy => by\n      rw [smul_add, smul_add, smul_add, ihx, ihy]⟩\n\n"}
{"name":"TensorProduct.isScalarTower_right","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹² : CommSemiring R\nR' : Type u_2\ninst✝¹¹ : Monoid R'\nM : Type u_5\nN : Type u_6\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : AddCommMonoid N\ninst✝⁸ : Module R M\ninst✝⁷ : Module R N\ninst✝⁶ : DistribMulAction R' M\nR'₂ : Type u_11\ninst✝⁵ : Monoid R'₂\ninst✝⁴ : DistribMulAction R'₂ M\ninst✝³ : SMul R'₂ R'\ninst✝² : DistribMulAction R'₂ N\ninst✝¹ : DistribMulAction R' N\ninst✝ : IsScalarTower R'₂ R' N\n⊢ IsScalarTower R'₂ R' (TensorProduct R M N)","decl":"/-- `IsScalarTower R'₂ R' N` implies `IsScalarTower R'₂ R' (M ⊗[R] N)` -/\ninstance isScalarTower_right [IsScalarTower R'₂ R' N] : IsScalarTower R'₂ R' (M ⊗[R] N) :=\n  ⟨fun s r x =>\n    x.induction_on (by simp)\n      (fun m n => by rw [← tmul_smul, ← tmul_smul, ← tmul_smul, smul_assoc]) fun x y ihx ihy => by\n      rw [smul_add, smul_add, smul_add, ihx, ihy]⟩\n\n"}
{"name":"TensorProduct.isScalarTower","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nR' : Type u_2\ninst✝⁷ : Monoid R'\nM : Type u_5\nN : Type u_6\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : DistribMulAction R' M\ninst✝¹ : SMul R' R\ninst✝ : IsScalarTower R' R M\n⊢ IsScalarTower R' R (TensorProduct R M N)","decl":"/-- A short-cut instance for the common case, where the requirements for the `compatible_smul`\ninstances are sufficient. -/\ninstance isScalarTower [SMul R' R] [IsScalarTower R' R M] : IsScalarTower R' R (M ⊗[R] N) :=\n  TensorProduct.isScalarTower_left\n\n-- or right\n"}
{"name":"TensorProduct.mk_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nm : M\nn : N\n⊢ Eq (((TensorProduct.mk R M N) m) n) (TensorProduct.tmul R m n)","decl":"@[simp]\ntheorem mk_apply (m : M) (n : N) : mk R M N m n = m ⊗ₜ n :=\n  rfl\n\n"}
{"name":"TensorProduct.ite_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R M\ninst✝¹ : Module R N\nx₁ : M\nx₂ : N\nP : Prop\ninst✝ : Decidable P\n⊢ Eq (TensorProduct.tmul R (ite P x₁ 0) x₂) (ite P (TensorProduct.tmul R x₁ x₂) 0)","decl":"theorem ite_tmul (x₁ : M) (x₂ : N) (P : Prop) [Decidable P] :\n    (if P then x₁ else 0) ⊗ₜ[R] x₂ = if P then x₁ ⊗ₜ x₂ else 0 := by split_ifs <;> simp\n\n"}
{"name":"TensorProduct.tmul_ite","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R M\ninst✝¹ : Module R N\nx₁ : M\nx₂ : N\nP : Prop\ninst✝ : Decidable P\n⊢ Eq (TensorProduct.tmul R x₁ (ite P x₂ 0)) (ite P (TensorProduct.tmul R x₁ x₂) 0)","decl":"theorem tmul_ite (x₁ : M) (x₂ : N) (P : Prop) [Decidable P] :\n    (x₁ ⊗ₜ[R] if P then x₂ else 0) = if P then x₁ ⊗ₜ x₂ else 0 := by split_ifs <;> simp\n\n"}
{"name":"TensorProduct.tmul_single","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nN : Type u_6\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\nι : Type u_11\ninst✝² : DecidableEq ι\nM : ι → Type u_12\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\ni : ι\nx : N\nm : M i\nj : ι\n⊢ Eq (TensorProduct.tmul R x (Pi.single i m j)) (Pi.single i (TensorProduct.tmul R x m) j)","decl":"lemma tmul_single {ι : Type*} [DecidableEq ι] {M : ι → Type*} [∀ i, AddCommMonoid (M i)]\n    [∀ i, Module R (M i)] (i : ι) (x : N) (m : M i) (j : ι) :\n    x ⊗ₜ[R] Pi.single i m j = (Pi.single i (x ⊗ₜ[R] m) : ∀ i, N ⊗[R] M i) j := by\n  by_cases h : i = j <;> aesop\n\n"}
{"name":"TensorProduct.single_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nN : Type u_6\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\nι : Type u_11\ninst✝² : DecidableEq ι\nM : ι → Type u_12\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\ni : ι\nx : N\nm : M i\nj : ι\n⊢ Eq (TensorProduct.tmul R (Pi.single i m j) x) (Pi.single i (TensorProduct.tmul R m x) j)","decl":"lemma single_tmul {ι : Type*} [DecidableEq ι] {M : ι → Type*} [∀ i, AddCommMonoid (M i)]\n    [∀ i, Module R (M i)] (i : ι) (x : N) (m : M i) (j : ι) :\n    Pi.single i m j ⊗ₜ[R] x = (Pi.single i (m ⊗ₜ[R] x) : ∀ i, M i ⊗[R] N) j := by\n  by_cases h : i = j <;> aesop\n\n"}
{"name":"TensorProduct.sum_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nα : Type u_11\ns : Finset α\nm : α → M\nn : N\n⊢ Eq (TensorProduct.tmul R (s.sum fun a => m a) n) (s.sum fun a => TensorProduct.tmul R (m a) n)","decl":"theorem sum_tmul {α : Type*} (s : Finset α) (m : α → M) (n : N) :\n    (∑ a ∈ s, m a) ⊗ₜ[R] n = ∑ a ∈ s, m a ⊗ₜ[R] n := by\n  classical\n    induction' s using Finset.induction with a s has ih h\n    · simp\n    · simp [Finset.sum_insert has, add_tmul, ih]\n\n"}
{"name":"TensorProduct.tmul_sum","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nm : M\nα : Type u_11\ns : Finset α\nn : α → N\n⊢ Eq (TensorProduct.tmul R m (s.sum fun a => n a)) (s.sum fun a => TensorProduct.tmul R m (n a))","decl":"theorem tmul_sum (m : M) {α : Type*} (s : Finset α) (n : α → N) :\n    (m ⊗ₜ[R] ∑ a ∈ s, n a) = ∑ a ∈ s, m ⊗ₜ[R] n a := by\n  classical\n    induction' s using Finset.induction with a s has ih h\n    · simp\n    · simp [Finset.sum_insert has, tmul_add, ih]\n\n"}
{"name":"TensorProduct.span_tmul_eq_top","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ Eq (Submodule.span R (setOf fun t => Exists fun m => Exists fun n => Eq (TensorProduct.tmul R m n) t)) Top.top","decl":"/-- The simple (aka pure) elements span the tensor product. -/\ntheorem span_tmul_eq_top : Submodule.span R { t : M ⊗[R] N | ∃ m n, m ⊗ₜ n = t } = ⊤ := by\n  ext t; simp only [Submodule.mem_top, iff_true]\n  refine t.induction_on ?_ ?_ ?_\n  · exact Submodule.zero_mem _\n  · intro m n\n    apply Submodule.subset_span\n    use m, n\n  · intro t₁ t₂ ht₁ ht₂\n    exact Submodule.add_mem _ ht₁ ht₂\n\n"}
{"name":"TensorProduct.map₂_mk_top_top_eq_top","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ Eq (Submodule.map₂ (TensorProduct.mk R M N) Top.top Top.top) Top.top","decl":"@[simp]\ntheorem map₂_mk_top_top_eq_top : Submodule.map₂ (mk R M N) ⊤ ⊤ = ⊤ := by\n  rw [← top_le_iff, ← span_tmul_eq_top, Submodule.map₂_eq_span_image2]\n  exact Submodule.span_mono fun _ ⟨m, n, h⟩ => ⟨m, trivial, n, trivial, h⟩\n\n"}
{"name":"TensorProduct.exists_eq_tmul_of_forall","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nx : TensorProduct R M N\nh : ∀ (m₁ m₂ : M) (n₁ n₂ : N), Exists fun m => Exists fun n => Eq (HAdd.hAdd (TensorProduct.tmul R m₁ n₁) (TensorProduct.tmul R m₂ n₂)) (TensorProduct.tmul R m n)\n⊢ Exists fun m => Exists fun n => Eq x (TensorProduct.tmul R m n)","decl":"theorem exists_eq_tmul_of_forall (x : TensorProduct R M N)\n    (h : ∀ (m₁ m₂ : M) (n₁ n₂ : N), ∃ m n, m₁ ⊗ₜ n₁ + m₂ ⊗ₜ n₂ = m ⊗ₜ[R] n) :\n    ∃ m n, x = m ⊗ₜ n := by\n  induction x with\n  | zero =>\n    use 0, 0\n    rw [TensorProduct.zero_tmul]\n  | tmul m n => use m, n\n  | add x y h₁ h₂ =>\n    obtain ⟨m₁, n₁, rfl⟩ := h₁\n    obtain ⟨m₂, n₂, rfl⟩ := h₂\n    apply h\n\n"}
{"name":"TensorProduct.liftAux_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\nm : M\nn : N\n⊢ Eq ((TensorProduct.liftAux f) (TensorProduct.tmul R m n)) ((f m) n)","decl":"theorem liftAux_tmul (m n) : liftAux f (m ⊗ₜ n) = f m n :=\n  rfl\n\n"}
{"name":"TensorProduct.liftAux.smul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\nr : R\nx : TensorProduct R M N\n⊢ Eq ((TensorProduct.liftAux f) (HSMul.hSMul r x)) (HSMul.hSMul r ((TensorProduct.liftAux f) x))","decl":"@[simp]\ntheorem liftAux.smul (r : R) (x) : liftAux f (r • x) = r • liftAux f x :=\n  TensorProduct.induction_on x (smul_zero _).symm\n    (fun p q => by simp_rw [← tmul_smul, liftAux_tmul, (f p).map_smul])\n    fun p q ih1 ih2 => by simp_rw [smul_add, (liftAux f).map_add, ih1, ih2, smul_add]\n\n"}
{"name":"TensorProduct.lift.tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\nx : M\ny : N\n⊢ Eq ((TensorProduct.lift f) (TensorProduct.tmul R x y)) ((f x) y)","decl":"@[simp]\ntheorem lift.tmul (x y) : lift f (x ⊗ₜ y) = f x y :=\n  rfl\n\n"}
{"name":"TensorProduct.lift.tmul'","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\nx : M\ny : N\n⊢ Eq ((TensorProduct.lift f).toAddHom (TensorProduct.tmul R x y)) ((f x) y)","decl":"@[simp]\ntheorem lift.tmul' (x y) : (lift f).1 (x ⊗ₜ y) = f x y :=\n  rfl\n\n"}
{"name":"TensorProduct.ext'","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\ng h : LinearMap (RingHom.id R) (TensorProduct R M N) P\nH : ∀ (x : M) (y : N), Eq (g (TensorProduct.tmul R x y)) (h (TensorProduct.tmul R x y))\n⊢ Eq g h","decl":"theorem ext' {g h : M ⊗[R] N →ₗ[R] P} (H : ∀ x y, g (x ⊗ₜ y) = h (x ⊗ₜ y)) : g = h :=\n  LinearMap.ext fun z =>\n    TensorProduct.induction_on z (by simp_rw [LinearMap.map_zero]) H fun x y ihx ihy => by\n      rw [g.map_add, h.map_add, ihx, ihy]\n\n"}
{"name":"TensorProduct.lift.unique","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\ng : LinearMap (RingHom.id R) (TensorProduct R M N) P\nH : ∀ (x : M) (y : N), Eq (g (TensorProduct.tmul R x y)) ((f x) y)\n⊢ Eq g (TensorProduct.lift f)","decl":"theorem lift.unique {g : M ⊗[R] N →ₗ[R] P} (H : ∀ x y, g (x ⊗ₜ y) = f x y) : g = lift f :=\n  ext' fun m n => by rw [H, lift.tmul]\n\n"}
{"name":"TensorProduct.lift_mk","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ Eq (TensorProduct.lift (TensorProduct.mk R M N)) LinearMap.id","decl":"theorem lift_mk : lift (mk R M N) = LinearMap.id :=\n  Eq.symm <| lift.unique fun _ _ => rfl\n\n"}
{"name":"TensorProduct.lift_compr₂","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\ng : LinearMap (RingHom.id R) P Q\n⊢ Eq (TensorProduct.lift (f.compr₂ g)) (g.comp (TensorProduct.lift f))","decl":"theorem lift_compr₂ (g : P →ₗ[R] Q) : lift (f.compr₂ g) = g.comp (lift f) :=\n  Eq.symm <| lift.unique fun _ _ => by simp\n\n"}
{"name":"TensorProduct.lift_mk_compr₂","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) (TensorProduct R M N) P\n⊢ Eq (TensorProduct.lift ((TensorProduct.mk R M N).compr₂ f)) f","decl":"theorem lift_mk_compr₂ (f : M ⊗ N →ₗ[R] P) : lift ((mk R M N).compr₂ f) = f := by\n  rw [lift_compr₂ f, lift_mk, LinearMap.comp_id]\n\n"}
{"name":"TensorProduct.ext","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\ng h : LinearMap (RingHom.id R) (TensorProduct R M N) P\nH : Eq ((TensorProduct.mk R M N).compr₂ g) ((TensorProduct.mk R M N).compr₂ h)\n⊢ Eq g h","decl":"/-- This used to be an `@[ext]` lemma, but it fails very slowly when the `ext` tactic tries to apply\nit in some cases, notably when one wants to show equality of two linear maps. The `@[ext]`\nattribute is now added locally where it is needed. Using this as the `@[ext]` lemma instead of\n`TensorProduct.ext'` allows `ext` to apply lemmas specific to `M →ₗ _` and `N →ₗ _`.\n\nSee note [partially-applied ext lemmas]. -/\ntheorem ext {g h : M ⊗ N →ₗ[R] P} (H : (mk R M N).compr₂ g = (mk R M N).compr₂ h) : g = h := by\n  rw [← lift_mk_compr₂ g, H, lift_mk_compr₂]\n\n"}
{"name":"TensorProduct.ext_iff","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\ng h : LinearMap (RingHom.id R) (TensorProduct R M N) P\n⊢ Iff (Eq g h) (Eq ((TensorProduct.mk R M N).compr₂ g) ((TensorProduct.mk R M N).compr₂ h))","decl":"attribute [local ext high] ext\n\n"}
{"name":"TensorProduct.uncurry_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\nm : M\nn : N\n⊢ Eq (((TensorProduct.uncurry R M N P) f) (TensorProduct.tmul R m n)) ((f m) n)","decl":"@[simp]\ntheorem uncurry_apply (f : M →ₗ[R] N →ₗ[R] P) (m : M) (n : N) :\n    uncurry R M N P f (m ⊗ₜ n) = f m n := by rw [uncurry, LinearMap.flip_apply, lift.tmul]; rfl\n\n"}
{"name":"TensorProduct.lift.equiv_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\nm : M\nn : N\n⊢ Eq (((TensorProduct.lift.equiv R M N P) f) (TensorProduct.tmul R m n)) ((f m) n)","decl":"@[simp]\ntheorem lift.equiv_apply (f : M →ₗ[R] N →ₗ[R] P) (m : M) (n : N) :\n    lift.equiv R M N P f (m ⊗ₜ n) = f m n :=\n  uncurry_apply f m n\n\n"}
{"name":"TensorProduct.lift.equiv_symm_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) (TensorProduct R M N) P\nm : M\nn : N\n⊢ Eq ((((TensorProduct.lift.equiv R M N P).symm f) m) n) (f (TensorProduct.tmul R m n))","decl":"@[simp]\ntheorem lift.equiv_symm_apply (f : M ⊗[R] N →ₗ[R] P) (m : M) (n : N) :\n    (lift.equiv R M N P).symm f m n = f (m ⊗ₜ n) :=\n  rfl\n\n"}
{"name":"TensorProduct.lcurry_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) (TensorProduct R M N) P\nm : M\nn : N\n⊢ Eq ((((TensorProduct.lcurry R M N P) f) m) n) (f (TensorProduct.tmul R m n))","decl":"@[simp]\ntheorem lcurry_apply (f : M ⊗[R] N →ₗ[R] P) (m : M) (n : N) : lcurry R M N P f m n = f (m ⊗ₜ n) :=\n  rfl\n\n"}
{"name":"TensorProduct.curry_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) (TensorProduct R M N) P\nm : M\nn : N\n⊢ Eq (((TensorProduct.curry f) m) n) (f (TensorProduct.tmul R m n))","decl":"@[simp]\ntheorem curry_apply (f : M ⊗ N →ₗ[R] P) (m : M) (n : N) : curry f m n = f (m ⊗ₜ n) :=\n  rfl\n\n"}
{"name":"TensorProduct.curry_injective","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\n⊢ Function.Injective TensorProduct.curry","decl":"theorem curry_injective : Function.Injective (curry : (M ⊗[R] N →ₗ[R] P) → M →ₗ[R] N →ₗ[R] P) :=\n  fun _ _ H => ext H\n\n"}
{"name":"TensorProduct.ext_threefold","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng h : LinearMap (RingHom.id R) (TensorProduct R (TensorProduct R M N) P) Q\nH : ∀ (x : M) (y : N) (z : P), Eq (g (TensorProduct.tmul R (TensorProduct.tmul R x y) z)) (h (TensorProduct.tmul R (TensorProduct.tmul R x y) z))\n⊢ Eq g h","decl":"theorem ext_threefold {g h : (M ⊗[R] N) ⊗[R] P →ₗ[R] Q}\n    (H : ∀ x y z, g (x ⊗ₜ y ⊗ₜ z) = h (x ⊗ₜ y ⊗ₜ z)) : g = h := by\n  ext x y z\n  exact H x y z\n\n"}
{"name":"TensorProduct.ext₃","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng h : LinearMap (RingHom.id R) (TensorProduct R (TensorProduct R M N) P) Q\nH : ∀ (x : M) (y : N) (z : P), Eq (g (TensorProduct.tmul R (TensorProduct.tmul R x y) z)) (h (TensorProduct.tmul R (TensorProduct.tmul R x y) z))\n⊢ Eq g h","decl":"@[deprecated (since := \"2024-10-18\")] alias ext₃ := ext_threefold\n\n-- We'll need this one for checking the pentagon identity!\n"}
{"name":"TensorProduct.ext_fourfold","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : AddCommMonoid Q\ninst✝⁵ : AddCommMonoid S\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R Q\ninst✝¹ : Module R S\ninst✝ : Module R P\ng h : LinearMap (RingHom.id R) (TensorProduct R (TensorProduct R (TensorProduct R M N) P) Q) S\nH : ∀ (w : M) (x : N) (y : P) (z : Q), Eq (g (TensorProduct.tmul R (TensorProduct.tmul R (TensorProduct.tmul R w x) y) z)) (h (TensorProduct.tmul R (TensorProduct.tmul R (TensorProduct.tmul R w x) y) z))\n⊢ Eq g h","decl":"theorem ext_fourfold {g h : ((M ⊗[R] N) ⊗[R] P) ⊗[R] Q →ₗ[R] S}\n    (H : ∀ w x y z, g (w ⊗ₜ x ⊗ₜ y ⊗ₜ z) = h (w ⊗ₜ x ⊗ₜ y ⊗ₜ z)) : g = h := by\n  ext w x y z\n  exact H w x y z\n\n"}
{"name":"TensorProduct.ext_fourfold'","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : AddCommMonoid Q\ninst✝⁵ : AddCommMonoid S\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R Q\ninst✝¹ : Module R S\ninst✝ : Module R P\nφ ψ : LinearMap (RingHom.id R) (TensorProduct R (TensorProduct R M N) (TensorProduct R P Q)) S\nH : ∀ (w : M) (x : N) (y : P) (z : Q), Eq (φ (TensorProduct.tmul R (TensorProduct.tmul R w x) (TensorProduct.tmul R y z))) (ψ (TensorProduct.tmul R (TensorProduct.tmul R w x) (TensorProduct.tmul R y z)))\n⊢ Eq φ ψ","decl":"/-- Two linear maps (M ⊗ N) ⊗ (P ⊗ Q) → S which agree on all elements of the\nform (m ⊗ₜ n) ⊗ₜ (p ⊗ₜ q) are equal. -/\ntheorem ext_fourfold' {φ ψ : (M ⊗[R] N) ⊗[R] P ⊗[R] Q →ₗ[R] S}\n    (H : ∀ w x y z, φ (w ⊗ₜ x ⊗ₜ (y ⊗ₜ z)) = ψ (w ⊗ₜ x ⊗ₜ (y ⊗ₜ z))) : φ = ψ := by\n  ext m n p q\n  exact H m n p q\n\n"}
{"name":"TensorProduct.lid_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : M\nr : R\n⊢ Eq ((TensorProduct.lid R M) (TensorProduct.tmul R r m)) (HSMul.hSMul r m)","decl":"@[simp]\ntheorem lid_tmul (m : M) (r : R) : (TensorProduct.lid R M : R ⊗ M → M) (r ⊗ₜ m) = r • m :=\n  rfl\n\n"}
{"name":"TensorProduct.lid_symm_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : M\n⊢ Eq ((TensorProduct.lid R M).symm m) (TensorProduct.tmul R 1 m)","decl":"@[simp]\ntheorem lid_symm_apply (m : M) : (TensorProduct.lid R M).symm m = 1 ⊗ₜ m :=\n  rfl\n\n"}
{"name":"TensorProduct.comm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nm : M\nn : N\n⊢ Eq ((TensorProduct.comm R M N) (TensorProduct.tmul R m n)) (TensorProduct.tmul R n m)","decl":"@[simp]\ntheorem comm_tmul (m : M) (n : N) : (TensorProduct.comm R M N) (m ⊗ₜ n) = n ⊗ₜ m :=\n  rfl\n\n"}
{"name":"TensorProduct.comm_symm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nm : M\nn : N\n⊢ Eq ((TensorProduct.comm R M N).symm (TensorProduct.tmul R n m)) (TensorProduct.tmul R m n)","decl":"@[simp]\ntheorem comm_symm_tmul (m : M) (n : N) : (TensorProduct.comm R M N).symm (n ⊗ₜ m) = m ⊗ₜ n :=\n  rfl\n\n"}
{"name":"TensorProduct.lift_comp_comm_eq","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N P)\n⊢ Eq ((TensorProduct.lift f).comp ↑(TensorProduct.comm R N M)) (TensorProduct.lift f.flip)","decl":"lemma lift_comp_comm_eq (f : M →ₗ[R] N →ₗ[R] P) :\n    lift f ∘ₗ TensorProduct.comm R N M = lift f.flip :=\n  ext rfl\n"}
{"name":"TensorProduct.rid_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : M\nr : R\n⊢ Eq ((TensorProduct.rid R M) (TensorProduct.tmul R m r)) (HSMul.hSMul r m)","decl":"@[simp]\ntheorem rid_tmul (m : M) (r : R) : (TensorProduct.rid R M) (m ⊗ₜ r) = r • m :=\n  rfl\n\n"}
{"name":"TensorProduct.rid_symm_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : M\n⊢ Eq ((TensorProduct.rid R M).symm m) (TensorProduct.tmul R m 1)","decl":"@[simp]\ntheorem rid_symm_apply (m : M) : (TensorProduct.rid R M).symm m = m ⊗ₜ 1 :=\n  rfl\n\n"}
{"name":"TensorProduct.lid_eq_rid","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (TensorProduct.lid R R) (TensorProduct.rid R R)","decl":"variable (R) in\ntheorem lid_eq_rid : TensorProduct.lid R R = TensorProduct.rid R R :=\n  LinearEquiv.toLinearMap_injective <| ext' mul_comm\n\n"}
{"name":"TensorProduct.mapOfCompatibleSMul_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁹ : CommSemiring R\nA : Type u_4\nM : Type u_5\nN : Type u_6\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R M\ninst✝⁵ : Module R N\ninst✝⁴ : CommSemiring A\ninst✝³ : Module A M\ninst✝² : Module A N\ninst✝¹ : SMulCommClass R A M\ninst✝ : TensorProduct.CompatibleSMul R A M N\nm : M\nn : N\n⊢ Eq ((TensorProduct.mapOfCompatibleSMul R A M N) (TensorProduct.tmul A m n)) (TensorProduct.tmul R m n)","decl":"@[simp] theorem mapOfCompatibleSMul_tmul (m n) : mapOfCompatibleSMul R A M N (m ⊗ₜ n) = m ⊗ₜ n :=\n  rfl\n\n"}
{"name":"TensorProduct.mapOfCompatibleSMul_surjective","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁹ : CommSemiring R\nA : Type u_4\nM : Type u_5\nN : Type u_6\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R M\ninst✝⁵ : Module R N\ninst✝⁴ : CommSemiring A\ninst✝³ : Module A M\ninst✝² : Module A N\ninst✝¹ : SMulCommClass R A M\ninst✝ : TensorProduct.CompatibleSMul R A M N\n⊢ Function.Surjective ⇑(TensorProduct.mapOfCompatibleSMul R A M N)","decl":"theorem mapOfCompatibleSMul_surjective : Function.Surjective (mapOfCompatibleSMul R A M N) :=\n  fun x ↦ x.induction_on (⟨0, map_zero _⟩) (fun m n ↦ ⟨_, mapOfCompatibleSMul_tmul ..⟩)\n    fun _ _ ⟨x, hx⟩ ⟨y, hy⟩ ↦ ⟨x + y, by simpa using congr($hx + $hy)⟩\n\n"}
{"name":"TensorProduct.lidOfCompatibleSMul_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nA : Type u_4\nM : Type u_5\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : CommSemiring A\ninst✝⁴ : Module A M\ninst✝³ : Module R A\ninst✝² : SMulCommClass R A A\ninst✝¹ : TensorProduct.CompatibleSMul R A A M\ninst✝ : TensorProduct.CompatibleSMul A R A M\na : A\nm : M\n⊢ Eq ((TensorProduct.lidOfCompatibleSMul R A M) (TensorProduct.tmul R a m)) (HSMul.hSMul a m)","decl":"theorem lidOfCompatibleSMul_tmul (a m) : lidOfCompatibleSMul R A M (a ⊗ₜ[R] m) = a • m := rfl\n\n"}
{"name":"TensorProduct.assoc_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nm : M\nn : N\np : P\n⊢ Eq ((TensorProduct.assoc R M N P) (TensorProduct.tmul R (TensorProduct.tmul R m n) p)) (TensorProduct.tmul R m (TensorProduct.tmul R n p))","decl":"@[simp]\ntheorem assoc_tmul (m : M) (n : N) (p : P) :\n    (TensorProduct.assoc R M N P) (m ⊗ₜ n ⊗ₜ p) = m ⊗ₜ (n ⊗ₜ p) :=\n  rfl\n\n"}
{"name":"TensorProduct.assoc_symm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nm : M\nn : N\np : P\n⊢ Eq ((TensorProduct.assoc R M N P).symm (TensorProduct.tmul R m (TensorProduct.tmul R n p))) (TensorProduct.tmul R (TensorProduct.tmul R m n) p)","decl":"@[simp]\ntheorem assoc_symm_tmul (m : M) (n : N) (p : P) :\n    (TensorProduct.assoc R M N P).symm (m ⊗ₜ (n ⊗ₜ p)) = m ⊗ₜ n ⊗ₜ p :=\n  rfl\n\n"}
{"name":"TensorProduct.map_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\nm : M\nn : N\n⊢ Eq ((TensorProduct.map f g) (TensorProduct.tmul R m n)) (TensorProduct.tmul R (f m) (g n))","decl":"@[simp]\ntheorem map_tmul (f : M →ₗ[R] P) (g : N →ₗ[R] Q) (m : M) (n : N) : map f g (m ⊗ₜ n) = f m ⊗ₜ g n :=\n  rfl\n\n"}
{"name":"TensorProduct.map_comp_comm_eq","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq ((TensorProduct.map f g).comp ↑(TensorProduct.comm R N M)) ((↑(TensorProduct.comm R Q P)).comp (TensorProduct.map g f))","decl":"/-- Given linear maps `f : M → P`, `g : N → Q`, if we identify `M ⊗ N` with `N ⊗ M` and `P ⊗ Q`\nwith `Q ⊗ P`, then this lemma states that `f ⊗ g = g ⊗ f`. -/\nlemma map_comp_comm_eq (f : M →ₗ[R] P) (g : N →ₗ[R] Q) :\n    map f g ∘ₗ TensorProduct.comm R N M = TensorProduct.comm R Q P ∘ₗ map g f :=\n  ext rfl\n\n"}
{"name":"TensorProduct.map_comm","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\nx : TensorProduct R N M\n⊢ Eq ((TensorProduct.map f g) ((TensorProduct.comm R N M) x)) ((TensorProduct.comm R Q P) ((TensorProduct.map g f) x))","decl":"lemma map_comm (f : M →ₗ[R] P) (g : N →ₗ[R] Q) (x : N ⊗[R] M) :\n    map f g (TensorProduct.comm R N M x) = TensorProduct.comm R Q P (map g f x) :=\n  DFunLike.congr_fun (map_comp_comm_eq _ _) _\n\n"}
{"name":"TensorProduct.map_map_comp_assoc_eq","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹² : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\nT : Type u_10\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : AddCommMonoid P\ninst✝⁸ : AddCommMonoid Q\ninst✝⁷ : AddCommMonoid S\ninst✝⁶ : AddCommMonoid T\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module R Q\ninst✝² : Module R S\ninst✝¹ : Module R T\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M Q\ng : LinearMap (RingHom.id R) N S\nh : LinearMap (RingHom.id R) P T\n⊢ Eq ((TensorProduct.map f (TensorProduct.map g h)).comp ↑(TensorProduct.assoc R M N P)) ((↑(TensorProduct.assoc R Q S T)).comp (TensorProduct.map (TensorProduct.map f g) h))","decl":"/-- Given linear maps `f : M → Q`, `g : N → S`, and `h : P → T`, if we identify `(M ⊗ N) ⊗ P`\nwith `M ⊗ (N ⊗ P)` and `(Q ⊗ S) ⊗ T` with `Q ⊗ (S ⊗ T)`, then this lemma states that\n`f ⊗ (g ⊗ h) = (f ⊗ g) ⊗ h`. -/\nlemma map_map_comp_assoc_eq (f : M →ₗ[R] Q) (g : N →ₗ[R] S) (h : P →ₗ[R] T) :\n    map f (map g h) ∘ₗ TensorProduct.assoc R M N P =\n      TensorProduct.assoc R Q S T ∘ₗ map (map f g) h :=\n  ext <| ext <| LinearMap.ext fun _ => LinearMap.ext fun _ => LinearMap.ext fun _ => rfl\n\n"}
{"name":"TensorProduct.map_map_assoc","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹² : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\nT : Type u_10\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : AddCommMonoid P\ninst✝⁸ : AddCommMonoid Q\ninst✝⁷ : AddCommMonoid S\ninst✝⁶ : AddCommMonoid T\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module R Q\ninst✝² : Module R S\ninst✝¹ : Module R T\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M Q\ng : LinearMap (RingHom.id R) N S\nh : LinearMap (RingHom.id R) P T\nx : TensorProduct R (TensorProduct R M N) P\n⊢ Eq ((TensorProduct.map f (TensorProduct.map g h)) ((TensorProduct.assoc R M N P) x)) ((TensorProduct.assoc R Q S T) ((TensorProduct.map (TensorProduct.map f g) h) x))","decl":"lemma map_map_assoc (f : M →ₗ[R] Q) (g : N →ₗ[R] S) (h : P →ₗ[R] T) (x : (M ⊗[R] N) ⊗[R] P) :\n    map f (map g h) (TensorProduct.assoc R M N P x) =\n      TensorProduct.assoc R Q S T (map (map f g) h x) :=\n  DFunLike.congr_fun (map_map_comp_assoc_eq _ _ _) _\n\n"}
{"name":"TensorProduct.map_map_comp_assoc_symm_eq","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹² : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\nT : Type u_10\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : AddCommMonoid P\ninst✝⁸ : AddCommMonoid Q\ninst✝⁷ : AddCommMonoid S\ninst✝⁶ : AddCommMonoid T\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module R Q\ninst✝² : Module R S\ninst✝¹ : Module R T\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M Q\ng : LinearMap (RingHom.id R) N S\nh : LinearMap (RingHom.id R) P T\n⊢ Eq ((TensorProduct.map (TensorProduct.map f g) h).comp ↑(TensorProduct.assoc R M N P).symm) ((↑(TensorProduct.assoc R Q S T).symm).comp (TensorProduct.map f (TensorProduct.map g h)))","decl":"/-- Given linear maps `f : M → Q`, `g : N → S`, and `h : P → T`, if we identify `M ⊗ (N ⊗ P)`\nwith `(M ⊗ N) ⊗ P` and `Q ⊗ (S ⊗ T)` with `(Q ⊗ S) ⊗ T`, then this lemma states that\n`(f ⊗ g) ⊗ h = f ⊗ (g ⊗ h)`. -/\nlemma map_map_comp_assoc_symm_eq (f : M →ₗ[R] Q) (g : N →ₗ[R] S) (h : P →ₗ[R] T) :\n    map (map f g) h ∘ₗ (TensorProduct.assoc R M N P).symm =\n      (TensorProduct.assoc R Q S T).symm ∘ₗ map f (map g h) :=\n  ext <| LinearMap.ext fun _ => ext <| LinearMap.ext fun _ => LinearMap.ext fun _ => rfl\n\n"}
{"name":"TensorProduct.map_map_assoc_symm","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹² : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\nT : Type u_10\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : AddCommMonoid P\ninst✝⁸ : AddCommMonoid Q\ninst✝⁷ : AddCommMonoid S\ninst✝⁶ : AddCommMonoid T\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module R Q\ninst✝² : Module R S\ninst✝¹ : Module R T\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M Q\ng : LinearMap (RingHom.id R) N S\nh : LinearMap (RingHom.id R) P T\nx : TensorProduct R M (TensorProduct R N P)\n⊢ Eq ((TensorProduct.map (TensorProduct.map f g) h) ((TensorProduct.assoc R M N P).symm x)) ((TensorProduct.assoc R Q S T).symm ((TensorProduct.map f (TensorProduct.map g h)) x))","decl":"lemma map_map_assoc_symm (f : M →ₗ[R] Q) (g : N →ₗ[R] S) (h : P →ₗ[R] T) (x : M ⊗[R] (N ⊗[R] P)) :\n    map (map f g) h ((TensorProduct.assoc R M N P).symm x) =\n      (TensorProduct.assoc R Q S T).symm (map f (map g h) x) :=\n  DFunLike.congr_fun (map_map_comp_assoc_symm_eq _ _ _) _\n\n"}
{"name":"TensorProduct.map_range_eq_span_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq (LinearMap.range (TensorProduct.map f g)) (Submodule.span R (setOf fun t => Exists fun m => Exists fun n => Eq (TensorProduct.tmul R (f m) (g n)) t))","decl":"theorem map_range_eq_span_tmul (f : M →ₗ[R] P) (g : N →ₗ[R] Q) :\n    range (map f g) = Submodule.span R { t | ∃ m n, f m ⊗ₜ g n = t } := by\n  simp only [← Submodule.map_top, ← span_tmul_eq_top, Submodule.map_span, Set.mem_image,\n    Set.mem_setOf_eq]\n  congr; ext t\n  constructor\n  · rintro ⟨_, ⟨⟨m, n, rfl⟩, rfl⟩⟩\n    use m, n\n    simp only [map_tmul]\n  · rintro ⟨m, n, rfl⟩\n    refine ⟨_, ⟨⟨m, n, rfl⟩, ?_⟩⟩\n    simp only [map_tmul]\n\n"}
{"name":"TensorProduct.range_mapIncl","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nP : Type u_7\nQ : Type u_8\ninst✝³ : AddCommMonoid P\ninst✝² : AddCommMonoid Q\ninst✝¹ : Module R Q\ninst✝ : Module R P\np : Submodule R P\nq : Submodule R Q\n⊢ Eq (LinearMap.range (TensorProduct.mapIncl p q)) (Submodule.span R (Set.image2 (fun x1 x2 => TensorProduct.tmul R x1 x2) ↑p ↑q))","decl":"lemma range_mapIncl (p : Submodule R P) (q : Submodule R Q) :\n    LinearMap.range (mapIncl p q) = Submodule.span R (Set.image2 (· ⊗ₜ ·) p q) := by\n  rw [mapIncl, map_range_eq_span_tmul]\n  congr; ext; simp\n\n"}
{"name":"TensorProduct.map₂_eq_range_lift_comp_mapIncl","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nP : Type u_7\nQ : Type u_8\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R M\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) P (LinearMap (RingHom.id R) Q M)\np : Submodule R P\nq : Submodule R Q\n⊢ Eq (Submodule.map₂ f p q) (LinearMap.range ((TensorProduct.lift f).comp (TensorProduct.mapIncl p q)))","decl":"theorem map₂_eq_range_lift_comp_mapIncl (f : P →ₗ[R] Q →ₗ[R] M)\n    (p : Submodule R P) (q : Submodule R Q) :\n    Submodule.map₂ f p q = LinearMap.range (lift f ∘ₗ mapIncl p q) := by\n  simp_rw [LinearMap.range_comp, range_mapIncl, Submodule.map_span,\n    Set.image_image2, Submodule.map₂_eq_span_image2, lift.tmul]\n\n"}
{"name":"TensorProduct.map_comp","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹² : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : AddCommMonoid P\ninst✝⁸ : AddCommMonoid Q\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\ninst✝⁵ : Module R Q\ninst✝⁴ : Module R P\nP' : Type u_11\nQ' : Type u_12\ninst✝³ : AddCommMonoid P'\ninst✝² : Module R P'\ninst✝¹ : AddCommMonoid Q'\ninst✝ : Module R Q'\nf₂ : LinearMap (RingHom.id R) P P'\nf₁ : LinearMap (RingHom.id R) M P\ng₂ : LinearMap (RingHom.id R) Q Q'\ng₁ : LinearMap (RingHom.id R) N Q\n⊢ Eq (TensorProduct.map (f₂.comp f₁) (g₂.comp g₁)) ((TensorProduct.map f₂ g₂).comp (TensorProduct.map f₁ g₁))","decl":"theorem map_comp (f₂ : P →ₗ[R] P') (f₁ : M →ₗ[R] P) (g₂ : Q →ₗ[R] Q') (g₁ : N →ₗ[R] Q) :\n    map (f₂.comp f₁) (g₂.comp g₁) = (map f₂ g₂).comp (map f₁ g₁) :=\n  ext' fun _ _ => rfl\n\n"}
{"name":"TensorProduct.range_mapIncl_mono","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nP : Type u_7\nQ : Type u_8\ninst✝³ : AddCommMonoid P\ninst✝² : AddCommMonoid Q\ninst✝¹ : Module R Q\ninst✝ : Module R P\np p' : Submodule R P\nq q' : Submodule R Q\nhp : LE.le p p'\nhq : LE.le q q'\n⊢ LE.le (LinearMap.range (TensorProduct.mapIncl p q)) (LinearMap.range (TensorProduct.mapIncl p' q'))","decl":"lemma range_mapIncl_mono {p p' : Submodule R P} {q q' : Submodule R Q} (hp : p ≤ p') (hq : q ≤ q') :\n    LinearMap.range (mapIncl p q) ≤ LinearMap.range (mapIncl p' q') := by\n  simp_rw [range_mapIncl]\n  exact Submodule.span_mono (Set.image2_subset hp hq)\n\n"}
{"name":"TensorProduct.lift_comp_map","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : AddCommMonoid Q\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module R Q\ninst✝² : Module R P\nQ' : Type u_12\ninst✝¹ : AddCommMonoid Q'\ninst✝ : Module R Q'\ni : LinearMap (RingHom.id R) P (LinearMap (RingHom.id R) Q Q')\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq ((TensorProduct.lift i).comp (TensorProduct.map f g)) (TensorProduct.lift ((i.comp f).compl₂ g))","decl":"theorem lift_comp_map (i : P →ₗ[R] Q →ₗ[R] Q') (f : M →ₗ[R] P) (g : N →ₗ[R] Q) :\n    (lift i).comp (map f g) = lift ((i.comp f).compl₂ g) :=\n  ext' fun _ _ => rfl\n\n"}
{"name":"TensorProduct.map_id","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ Eq (TensorProduct.map LinearMap.id LinearMap.id) LinearMap.id","decl":"@[simp]\ntheorem map_id : map (id : M →ₗ[R] M) (id : N →ₗ[R] N) = .id := by\n  ext\n  simp only [mk_apply, id_coe, compr₂_apply, _root_.id, map_tmul]\n\n"}
{"name":"TensorProduct.map_one","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ Eq (TensorProduct.map 1 1) 1","decl":"@[simp]\nprotected theorem map_one : map (1 : M →ₗ[R] M) (1 : N →ₗ[R] N) = 1 :=\n  map_id\n\n"}
{"name":"TensorProduct.map_mul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf₁ f₂ : LinearMap (RingHom.id R) M M\ng₁ g₂ : LinearMap (RingHom.id R) N N\n⊢ Eq (TensorProduct.map (HMul.hMul f₁ f₂) (HMul.hMul g₁ g₂)) (HMul.hMul (TensorProduct.map f₁ g₁) (TensorProduct.map f₂ g₂))","decl":"protected theorem map_mul (f₁ f₂ : M →ₗ[R] M) (g₁ g₂ : N →ₗ[R] N) :\n    map (f₁ * f₂) (g₁ * g₂) = map f₁ g₁ * map f₂ g₂ :=\n  map_comp f₁ f₂ g₁ g₂\n\n"}
{"name":"TensorProduct.map_pow","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M M\ng : LinearMap (RingHom.id R) N N\nn : Nat\n⊢ Eq (HPow.hPow (TensorProduct.map f g) n) (TensorProduct.map (HPow.hPow f n) (HPow.hPow g n))","decl":"@[simp]\nprotected theorem map_pow (f : M →ₗ[R] M) (g : N →ₗ[R] N) (n : ℕ) :\n    map f g ^ n = map (f ^ n) (g ^ n) := by\n  induction n with\n  | zero => simp only [pow_zero, TensorProduct.map_one]\n  | succ n ih => simp only [pow_succ', ih, TensorProduct.map_mul]\n\n"}
{"name":"TensorProduct.map_add_left","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf₁ f₂ : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq (TensorProduct.map (HAdd.hAdd f₁ f₂) g) (HAdd.hAdd (TensorProduct.map f₁ g) (TensorProduct.map f₂ g))","decl":"theorem map_add_left (f₁ f₂ : M →ₗ[R] P) (g : N →ₗ[R] Q) :\n    map (f₁ + f₂) g = map f₁ g + map f₂ g := by\n  ext\n  simp only [add_tmul, compr₂_apply, mk_apply, map_tmul, add_apply]\n\n"}
{"name":"TensorProduct.map_add_right","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\ng₁ g₂ : LinearMap (RingHom.id R) N Q\n⊢ Eq (TensorProduct.map f (HAdd.hAdd g₁ g₂)) (HAdd.hAdd (TensorProduct.map f g₁) (TensorProduct.map f g₂))","decl":"theorem map_add_right (f : M →ₗ[R] P) (g₁ g₂ : N →ₗ[R] Q) :\n    map f (g₁ + g₂) = map f g₁ + map f g₂ := by\n  ext\n  simp only [tmul_add, compr₂_apply, mk_apply, map_tmul, add_apply]\n\n"}
{"name":"TensorProduct.map_smul_left","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nr : R\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq (TensorProduct.map (HSMul.hSMul r f) g) (HSMul.hSMul r (TensorProduct.map f g))","decl":"theorem map_smul_left (r : R) (f : M →ₗ[R] P) (g : N →ₗ[R] Q) : map (r • f) g = r • map f g := by\n  ext\n  simp only [smul_tmul, compr₂_apply, mk_apply, map_tmul, smul_apply, tmul_smul]\n\n"}
{"name":"TensorProduct.map_smul_right","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nr : R\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq (TensorProduct.map f (HSMul.hSMul r g)) (HSMul.hSMul r (TensorProduct.map f g))","decl":"theorem map_smul_right (r : R) (f : M →ₗ[R] P) (g : N →ₗ[R] Q) : map f (r • g) = r • map f g := by\n  ext\n  simp only [smul_tmul, compr₂_apply, mk_apply, map_tmul, smul_apply, tmul_smul]\n\n"}
{"name":"TensorProduct.mapBilinear_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq (((TensorProduct.mapBilinear R M N P Q) f) g) (TensorProduct.map f g)","decl":"@[simp]\ntheorem mapBilinear_apply (f : M →ₗ[R] P) (g : N →ₗ[R] Q) : mapBilinear R M N P Q f g = map f g :=\n  rfl\n\n"}
{"name":"TensorProduct.lTensorHomToHomLTensor_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nP : Type u_7\nQ : Type u_8\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R M\ninst✝¹ : Module R Q\ninst✝ : Module R P\np : P\nf : LinearMap (RingHom.id R) M Q\nm : M\n⊢ Eq (((TensorProduct.lTensorHomToHomLTensor R M P Q) (TensorProduct.tmul R p f)) m) (TensorProduct.tmul R p (f m))","decl":"@[simp]\ntheorem lTensorHomToHomLTensor_apply (p : P) (f : M →ₗ[R] Q) (m : M) :\n    lTensorHomToHomLTensor R M P Q (p ⊗ₜ f) m = p ⊗ₜ f m :=\n  rfl\n\n"}
{"name":"TensorProduct.rTensorHomToHomRTensor_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nP : Type u_7\nQ : Type u_8\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R M\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\nq : Q\nm : M\n⊢ Eq (((TensorProduct.rTensorHomToHomRTensor R M P Q) (TensorProduct.tmul R f q)) m) (TensorProduct.tmul R (f m) q)","decl":"@[simp]\ntheorem rTensorHomToHomRTensor_apply (f : M →ₗ[R] P) (q : Q) (m : M) :\n    rTensorHomToHomRTensor R M P Q (f ⊗ₜ q) m = f m ⊗ₜ q :=\n  rfl\n\n"}
{"name":"TensorProduct.homTensorHomMap_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq ((TensorProduct.homTensorHomMap R M N P Q) (TensorProduct.tmul R f g)) (TensorProduct.map f g)","decl":"@[simp]\ntheorem homTensorHomMap_apply (f : M →ₗ[R] P) (g : N →ₗ[R] Q) :\n    homTensorHomMap R M N P Q (f ⊗ₜ g) = map f g :=\n  rfl\n\n"}
{"name":"TensorProduct.map₂_apply_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹² : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\nT : Type u_10\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : AddCommMonoid P\ninst✝⁸ : AddCommMonoid Q\ninst✝⁷ : AddCommMonoid S\ninst✝⁶ : AddCommMonoid T\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module R Q\ninst✝² : Module R S\ninst✝¹ : Module R T\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) P Q)\ng : LinearMap (RingHom.id R) N (LinearMap (RingHom.id R) S T)\nm : M\nn : N\n⊢ Eq ((TensorProduct.map₂ f g) (TensorProduct.tmul R m n)) (TensorProduct.map (f m) (g n))","decl":"@[simp]\ntheorem map₂_apply_tmul (f : M →ₗ[R] P →ₗ[R] Q) (g : N →ₗ[R] S →ₗ[R] T) (m : M) (n : N) :\n    map₂ f g (m ⊗ₜ n) = map (f m) (g n) := rfl\n\n"}
{"name":"TensorProduct.map_zero_left","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq (TensorProduct.map 0 g) 0","decl":"@[simp]\ntheorem map_zero_left (g : N →ₗ[R] Q) : map (0 : M →ₗ[R] P) g = 0 :=\n  (mapBilinear R M N P Q).map_zero₂ _\n\n"}
{"name":"TensorProduct.map_zero_right","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\n⊢ Eq (TensorProduct.map f 0) 0","decl":"@[simp]\ntheorem map_zero_right (f : M →ₗ[R] P) : map f (0 : N →ₗ[R] Q) = 0 :=\n  (mapBilinear R M N P Q _).map_zero\n\n"}
{"name":"TensorProduct.congr_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) M P\ng : LinearEquiv (RingHom.id R) N Q\nm : M\nn : N\n⊢ Eq ((TensorProduct.congr f g) (TensorProduct.tmul R m n)) (TensorProduct.tmul R (f m) (g n))","decl":"@[simp]\ntheorem congr_tmul (f : M ≃ₗ[R] P) (g : N ≃ₗ[R] Q) (m : M) (n : N) :\n    congr f g (m ⊗ₜ n) = f m ⊗ₜ g n :=\n  rfl\n\n"}
{"name":"TensorProduct.congr_symm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) M P\ng : LinearEquiv (RingHom.id R) N Q\np : P\nq : Q\n⊢ Eq ((TensorProduct.congr f g).symm (TensorProduct.tmul R p q)) (TensorProduct.tmul R (f.symm p) (g.symm q))","decl":"@[simp]\ntheorem congr_symm_tmul (f : M ≃ₗ[R] P) (g : N ≃ₗ[R] Q) (p : P) (q : Q) :\n    (congr f g).symm (p ⊗ₜ q) = f.symm p ⊗ₜ g.symm q :=\n  rfl\n\n"}
{"name":"TensorProduct.congr_symm","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) M P\ng : LinearEquiv (RingHom.id R) N Q\n⊢ Eq (TensorProduct.congr f g).symm (TensorProduct.congr f.symm g.symm)","decl":"theorem congr_symm (f : M ≃ₗ[R] P) (g : N ≃ₗ[R] Q) : (congr f g).symm = congr f.symm g.symm := rfl\n\n"}
{"name":"TensorProduct.congr_refl_refl","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ Eq (TensorProduct.congr (LinearEquiv.refl R M) (LinearEquiv.refl R N)) (LinearEquiv.refl R (TensorProduct R M N))","decl":"@[simp] theorem congr_refl_refl : congr (.refl R M) (.refl R N) = .refl R _ :=\n  LinearEquiv.toLinearMap_injective <| ext' fun _ _ ↦ rfl\n\n"}
{"name":"TensorProduct.congr_trans","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹² : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\nT : Type u_10\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : AddCommMonoid P\ninst✝⁸ : AddCommMonoid Q\ninst✝⁷ : AddCommMonoid S\ninst✝⁶ : AddCommMonoid T\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module R Q\ninst✝² : Module R S\ninst✝¹ : Module R T\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) M P\ng : LinearEquiv (RingHom.id R) N Q\nf' : LinearEquiv (RingHom.id R) P S\ng' : LinearEquiv (RingHom.id R) Q T\n⊢ Eq (TensorProduct.congr (f.trans f') (g.trans g')) ((TensorProduct.congr f g).trans (TensorProduct.congr f' g'))","decl":"theorem congr_trans (f : M ≃ₗ[R] P) (g : N ≃ₗ[R] Q) (f' : P ≃ₗ[R] S) (g' : Q ≃ₗ[R] T) :\n    congr (f ≪≫ₗ f') (g ≪≫ₗ g') = congr f g ≪≫ₗ congr f' g' :=\n  LinearEquiv.toLinearMap_injective <| map_comp _ _ _ _\n\n"}
{"name":"TensorProduct.congr_mul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) M M\ng : LinearEquiv (RingHom.id R) N N\nf' : LinearEquiv (RingHom.id R) M M\ng' : LinearEquiv (RingHom.id R) N N\n⊢ Eq (TensorProduct.congr (HMul.hMul f f') (HMul.hMul g g')) (HMul.hMul (TensorProduct.congr f g) (TensorProduct.congr f' g'))","decl":"theorem congr_mul (f : M ≃ₗ[R] M) (g : N ≃ₗ[R] N) (f' : M ≃ₗ[R] M) (g' : N ≃ₗ[R] N) :\n    congr (f * f') (g * g') = congr f g * congr f' g' := congr_trans _ _ _ _\n\n"}
{"name":"TensorProduct.congr_pow","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) M M\ng : LinearEquiv (RingHom.id R) N N\nn : Nat\n⊢ Eq (HPow.hPow (TensorProduct.congr f g) n) (TensorProduct.congr (HPow.hPow f n) (HPow.hPow g n))","decl":"@[simp] theorem congr_pow (f : M ≃ₗ[R] M) (g : N ≃ₗ[R] N) (n : ℕ) :\n    congr f g ^ n = congr (f ^ n) (g ^ n) := by\n  induction n with\n  | zero => exact congr_refl_refl.symm\n  | succ n ih => simp_rw [pow_succ, ih, congr_mul]\n\n"}
{"name":"TensorProduct.congr_zpow","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) M M\ng : LinearEquiv (RingHom.id R) N N\nn : Int\n⊢ Eq (HPow.hPow (TensorProduct.congr f g) n) (TensorProduct.congr (HPow.hPow f n) (HPow.hPow g n))","decl":"@[simp] theorem congr_zpow (f : M ≃ₗ[R] M) (g : N ≃ₗ[R] N) (n : ℤ) :\n    congr f g ^ n = congr (f ^ n) (g ^ n) := by\n  induction n with\n  | ofNat n => exact congr_pow _ _ _\n  | negSucc n => simp_rw [zpow_negSucc, congr_pow]; exact congr_symm _ _\n\n"}
{"name":"TensorProduct.leftComm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nm : M\nn : N\np : P\n⊢ Eq ((TensorProduct.leftComm R M N P) (TensorProduct.tmul R m (TensorProduct.tmul R n p))) (TensorProduct.tmul R n (TensorProduct.tmul R m p))","decl":"@[simp]\ntheorem leftComm_tmul (m : M) (n : N) (p : P) : leftComm R M N P (m ⊗ₜ (n ⊗ₜ p)) = n ⊗ₜ (m ⊗ₜ p) :=\n  rfl\n\n"}
{"name":"TensorProduct.leftComm_symm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nm : M\nn : N\np : P\n⊢ Eq ((TensorProduct.leftComm R M N P).symm (TensorProduct.tmul R n (TensorProduct.tmul R m p))) (TensorProduct.tmul R m (TensorProduct.tmul R n p))","decl":"@[simp]\ntheorem leftComm_symm_tmul (m : M) (n : N) (p : P) :\n    (leftComm R M N P).symm (n ⊗ₜ (m ⊗ₜ p)) = m ⊗ₜ (n ⊗ₜ p) :=\n  rfl\n\n"}
{"name":"TensorProduct.tensorTensorTensorComm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nm : M\nn : N\np : P\nq : Q\n⊢ Eq ((TensorProduct.tensorTensorTensorComm R M N P Q) (TensorProduct.tmul R (TensorProduct.tmul R m n) (TensorProduct.tmul R p q))) (TensorProduct.tmul R (TensorProduct.tmul R m p) (TensorProduct.tmul R n q))","decl":"@[simp]\ntheorem tensorTensorTensorComm_tmul (m : M) (n : N) (p : P) (q : Q) :\n    tensorTensorTensorComm R M N P Q (m ⊗ₜ n ⊗ₜ (p ⊗ₜ q)) = m ⊗ₜ p ⊗ₜ (n ⊗ₜ q) :=\n  rfl\n\n-- Porting note: the proof here was `rfl` but that caused a timeout.\n"}
{"name":"TensorProduct.tensorTensorTensorComm_symm","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\n⊢ Eq (TensorProduct.tensorTensorTensorComm R M N P Q).symm (TensorProduct.tensorTensorTensorComm R M P N Q)","decl":"@[simp]\ntheorem tensorTensorTensorComm_symm :\n    (tensorTensorTensorComm R M N P Q).symm = tensorTensorTensorComm R M P N Q := by\n  ext; rfl\n\n"}
{"name":"TensorProduct.tensorTensorTensorAssoc_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nm : M\nn : N\np : P\nq : Q\n⊢ Eq ((TensorProduct.tensorTensorTensorAssoc R M N P Q) (TensorProduct.tmul R (TensorProduct.tmul R m n) (TensorProduct.tmul R p q))) (TensorProduct.tmul R (TensorProduct.tmul R m (TensorProduct.tmul R n p)) q)","decl":"@[simp]\ntheorem tensorTensorTensorAssoc_tmul (m : M) (n : N) (p : P) (q : Q) :\n    tensorTensorTensorAssoc R M N P Q (m ⊗ₜ n ⊗ₜ (p ⊗ₜ q)) = m ⊗ₜ (n ⊗ₜ p) ⊗ₜ q :=\n  rfl\n\n"}
{"name":"TensorProduct.tensorTensorTensorAssoc_symm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nm : M\nn : N\np : P\nq : Q\n⊢ Eq ((TensorProduct.tensorTensorTensorAssoc R M N P Q).symm (TensorProduct.tmul R (TensorProduct.tmul R m (TensorProduct.tmul R n p)) q)) (TensorProduct.tmul R (TensorProduct.tmul R m n) (TensorProduct.tmul R p q))","decl":"@[simp]\ntheorem tensorTensorTensorAssoc_symm_tmul (m : M) (n : N) (p : P) (q : Q) :\n    (tensorTensorTensorAssoc R M N P Q).symm (m ⊗ₜ (n ⊗ₜ p) ⊗ₜ q) = m ⊗ₜ n ⊗ₜ (p ⊗ₜ q) :=\n  rfl\n\n"}
{"name":"LinearMap.lTensor_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\nm : M\nn : N\n⊢ Eq ((LinearMap.lTensor M f) (TensorProduct.tmul R m n)) (TensorProduct.tmul R m (f n))","decl":"@[simp]\ntheorem lTensor_tmul (m : M) (n : N) : f.lTensor M (m ⊗ₜ n) = m ⊗ₜ f n :=\n  rfl\n\n"}
{"name":"LinearMap.rTensor_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\nm : M\nn : N\n⊢ Eq ((LinearMap.rTensor M f) (TensorProduct.tmul R n m)) (TensorProduct.tmul R (f n) m)","decl":"@[simp]\ntheorem rTensor_tmul (m : M) (n : N) : f.rTensor M (n ⊗ₜ m) = f n ⊗ₜ m :=\n  rfl\n\n"}
{"name":"LinearMap.lTensor_comp_mk","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\nm : M\n⊢ Eq ((LinearMap.lTensor M f).comp ((TensorProduct.mk R M N) m)) (((TensorProduct.mk R M P) m).comp f)","decl":"@[simp]\ntheorem lTensor_comp_mk (m : M) :\n    f.lTensor M ∘ₗ TensorProduct.mk R M N m = TensorProduct.mk R M P m ∘ₗ f :=\n  rfl\n\n"}
{"name":"LinearMap.rTensor_comp_flip_mk","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\nm : M\n⊢ Eq ((LinearMap.rTensor M f).comp ((TensorProduct.mk R N M).flip m)) (((TensorProduct.mk R P M).flip m).comp f)","decl":"@[simp]\ntheorem rTensor_comp_flip_mk (m : M) :\n    f.rTensor M ∘ₗ (TensorProduct.mk R N M).flip m = (TensorProduct.mk R P M).flip m ∘ₗ f :=\n  rfl\n\n"}
{"name":"LinearMap.comm_comp_rTensor_comp_comm_eq","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : AddCommMonoid P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearMap (RingHom.id R) N P\n⊢ Eq ((↑(TensorProduct.comm R P Q)).comp ((LinearMap.rTensor Q g).comp ↑(TensorProduct.comm R Q N))) (LinearMap.lTensor Q g)","decl":"lemma comm_comp_rTensor_comp_comm_eq (g : N →ₗ[R] P) :\n    TensorProduct.comm R P Q ∘ₗ rTensor Q g ∘ₗ TensorProduct.comm R Q N =\n      lTensor Q g :=\n  TensorProduct.ext rfl\n\n"}
{"name":"LinearMap.rTensor_tensor","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearMap (RingHom.id R) P Q\n⊢ Eq (LinearMap.rTensor (TensorProduct R M N) g) ((↑(TensorProduct.assoc R Q M N)).comp ((LinearMap.rTensor N (LinearMap.rTensor M g)).comp ↑(TensorProduct.assoc R P M N).symm))","decl":"theorem rTensor_tensor : rTensor (M ⊗[R] N) g =\n    TensorProduct.assoc R Q M N ∘ₗ rTensor N (rTensor M g) ∘ₗ (TensorProduct.assoc R P M N).symm :=\n  TensorProduct.ext <| LinearMap.ext fun _ ↦ TensorProduct.ext rfl\n\n"}
{"name":"LinearMap.comm_comp_lTensor_comp_comm_eq","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : AddCommMonoid P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearMap (RingHom.id R) N P\n⊢ Eq ((↑(TensorProduct.comm R Q P)).comp ((LinearMap.lTensor Q g).comp ↑(TensorProduct.comm R N Q))) (LinearMap.rTensor Q g)","decl":"lemma comm_comp_lTensor_comp_comm_eq (g : N →ₗ[R] P) :\n    TensorProduct.comm R Q P ∘ₗ lTensor Q g ∘ₗ TensorProduct.comm R N Q =\n      rTensor Q g :=\n  TensorProduct.ext rfl\n\n"}
{"name":"LinearMap.lTensor_inj_iff_rTensor_inj","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\n⊢ Iff (Function.Injective ⇑(LinearMap.lTensor M f)) (Function.Injective ⇑(LinearMap.rTensor M f))","decl":"/-- Given a linear map `f : N → P`, `f ⊗ M` is injective if and only if `M ⊗ f` is injective. -/\ntheorem lTensor_inj_iff_rTensor_inj :\n    Function.Injective (lTensor M f) ↔ Function.Injective (rTensor M f) := by\n  simp [← comm_comp_rTensor_comp_comm_eq]\n\n"}
{"name":"LinearMap.lTensor_surj_iff_rTensor_surj","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\n⊢ Iff (Function.Surjective ⇑(LinearMap.lTensor M f)) (Function.Surjective ⇑(LinearMap.rTensor M f))","decl":"/-- Given a linear map `f : N → P`, `f ⊗ M` is surjective if and only if `M ⊗ f` is surjective. -/\ntheorem lTensor_surj_iff_rTensor_surj :\n    Function.Surjective (lTensor M f) ↔ Function.Surjective (rTensor M f) := by\n  simp [← comm_comp_rTensor_comp_comm_eq]\n\n"}
{"name":"LinearMap.lTensor_bij_iff_rTensor_bij","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\n⊢ Iff (Function.Bijective ⇑(LinearMap.lTensor M f)) (Function.Bijective ⇑(LinearMap.rTensor M f))","decl":"/-- Given a linear map `f : N → P`, `f ⊗ M` is bijective if and only if `M ⊗ f` is bijective. -/\ntheorem lTensor_bij_iff_rTensor_bij :\n    Function.Bijective (lTensor M f) ↔ Function.Bijective (rTensor M f) := by\n  simp [← comm_comp_rTensor_comp_comm_eq]\n\n"}
{"name":"LinearMap.coe_lTensorHom","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\n⊢ Eq (⇑(LinearMap.lTensorHom M)) (LinearMap.lTensor M)","decl":"@[simp]\ntheorem coe_lTensorHom : (lTensorHom M : (N →ₗ[R] P) → M ⊗[R] N →ₗ[R] M ⊗[R] P) = lTensor M :=\n  rfl\n\n"}
{"name":"LinearMap.coe_rTensorHom","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\n⊢ Eq (⇑(LinearMap.rTensorHom M)) (LinearMap.rTensor M)","decl":"@[simp]\ntheorem coe_rTensorHom : (rTensorHom M : (N →ₗ[R] P) → N ⊗[R] M →ₗ[R] P ⊗[R] M) = rTensor M :=\n  rfl\n\n"}
{"name":"LinearMap.lTensor_add","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf g : LinearMap (RingHom.id R) N P\n⊢ Eq (LinearMap.lTensor M (HAdd.hAdd f g)) (HAdd.hAdd (LinearMap.lTensor M f) (LinearMap.lTensor M g))","decl":"@[simp]\ntheorem lTensor_add (f g : N →ₗ[R] P) : (f + g).lTensor M = f.lTensor M + g.lTensor M :=\n  (lTensorHom M).map_add f g\n\n"}
{"name":"LinearMap.rTensor_add","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf g : LinearMap (RingHom.id R) N P\n⊢ Eq (LinearMap.rTensor M (HAdd.hAdd f g)) (HAdd.hAdd (LinearMap.rTensor M f) (LinearMap.rTensor M g))","decl":"@[simp]\ntheorem rTensor_add (f g : N →ₗ[R] P) : (f + g).rTensor M = f.rTensor M + g.rTensor M :=\n  (rTensorHom M).map_add f g\n\n"}
{"name":"LinearMap.lTensor_zero","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\n⊢ Eq (LinearMap.lTensor M 0) 0","decl":"@[simp]\ntheorem lTensor_zero : lTensor M (0 : N →ₗ[R] P) = 0 :=\n  (lTensorHom M).map_zero\n\n"}
{"name":"LinearMap.rTensor_zero","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\n⊢ Eq (LinearMap.rTensor M 0) 0","decl":"@[simp]\ntheorem rTensor_zero : rTensor M (0 : N →ₗ[R] P) = 0 :=\n  (rTensorHom M).map_zero\n\n"}
{"name":"LinearMap.lTensor_smul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nr : R\nf : LinearMap (RingHom.id R) N P\n⊢ Eq (LinearMap.lTensor M (HSMul.hSMul r f)) (HSMul.hSMul r (LinearMap.lTensor M f))","decl":"@[simp]\ntheorem lTensor_smul (r : R) (f : N →ₗ[R] P) : (r • f).lTensor M = r • f.lTensor M :=\n  (lTensorHom M).map_smul r f\n\n"}
{"name":"LinearMap.rTensor_smul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nr : R\nf : LinearMap (RingHom.id R) N P\n⊢ Eq (LinearMap.rTensor M (HSMul.hSMul r f)) (HSMul.hSMul r (LinearMap.rTensor M f))","decl":"@[simp]\ntheorem rTensor_smul (r : R) (f : N →ₗ[R] P) : (r • f).rTensor M = r • f.rTensor M :=\n  (rTensorHom M).map_smul r f\n\n"}
{"name":"LinearMap.lTensor_comp","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearMap (RingHom.id R) P Q\nf : LinearMap (RingHom.id R) N P\n⊢ Eq (LinearMap.lTensor M (g.comp f)) ((LinearMap.lTensor M g).comp (LinearMap.lTensor M f))","decl":"theorem lTensor_comp : (g.comp f).lTensor M = (g.lTensor M).comp (f.lTensor M) := by\n  ext m n\n  simp only [compr₂_apply, mk_apply, comp_apply, lTensor_tmul]\n\n"}
{"name":"LinearMap.lTensor_comp_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearMap (RingHom.id R) P Q\nf : LinearMap (RingHom.id R) N P\nx : TensorProduct R M N\n⊢ Eq ((LinearMap.lTensor M (g.comp f)) x) ((LinearMap.lTensor M g) ((LinearMap.lTensor M f) x))","decl":"theorem lTensor_comp_apply (x : M ⊗[R] N) :\n    (g.comp f).lTensor M x = (g.lTensor M) ((f.lTensor M) x) := by rw [lTensor_comp, coe_comp]; rfl\n\n"}
{"name":"LinearMap.rTensor_comp","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearMap (RingHom.id R) P Q\nf : LinearMap (RingHom.id R) N P\n⊢ Eq (LinearMap.rTensor M (g.comp f)) ((LinearMap.rTensor M g).comp (LinearMap.rTensor M f))","decl":"theorem rTensor_comp : (g.comp f).rTensor M = (g.rTensor M).comp (f.rTensor M) := by\n  ext m n\n  simp only [compr₂_apply, mk_apply, comp_apply, rTensor_tmul]\n\n"}
{"name":"LinearMap.rTensor_comp_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearMap (RingHom.id R) P Q\nf : LinearMap (RingHom.id R) N P\nx : TensorProduct R N M\n⊢ Eq ((LinearMap.rTensor M (g.comp f)) x) ((LinearMap.rTensor M g) ((LinearMap.rTensor M f) x))","decl":"theorem rTensor_comp_apply (x : N ⊗[R] M) :\n    (g.comp f).rTensor M x = (g.rTensor M) ((f.rTensor M) x) := by rw [rTensor_comp, coe_comp]; rfl\n\n"}
{"name":"LinearMap.lTensor_mul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf g : Module.End R N\n⊢ Eq (LinearMap.lTensor M (HMul.hMul f g)) (HMul.hMul (LinearMap.lTensor M f) (LinearMap.lTensor M g))","decl":"theorem lTensor_mul (f g : Module.End R N) : (f * g).lTensor M = f.lTensor M * g.lTensor M :=\n  lTensor_comp M f g\n\n"}
{"name":"LinearMap.rTensor_mul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf g : Module.End R N\n⊢ Eq (LinearMap.rTensor M (HMul.hMul f g)) (HMul.hMul (LinearMap.rTensor M f) (LinearMap.rTensor M g))","decl":"theorem rTensor_mul (f g : Module.End R N) : (f * g).rTensor M = f.rTensor M * g.rTensor M :=\n  rTensor_comp M f g\n\n"}
{"name":"LinearMap.lTensor_id","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ Eq (LinearMap.lTensor M LinearMap.id) LinearMap.id","decl":"@[simp]\ntheorem lTensor_id : (id : N →ₗ[R] N).lTensor M = id :=\n  map_id\n\n-- `simp` can prove this.\n"}
{"name":"LinearMap.lTensor_id_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nx : TensorProduct R M N\n⊢ Eq ((LinearMap.lTensor M LinearMap.id) x) x","decl":"theorem lTensor_id_apply (x : M ⊗[R] N) : (LinearMap.id : N →ₗ[R] N).lTensor M x = x := by\n  rw [lTensor_id, id_coe, _root_.id]\n\n"}
{"name":"LinearMap.rTensor_id","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ Eq (LinearMap.rTensor M LinearMap.id) LinearMap.id","decl":"@[simp]\ntheorem rTensor_id : (id : N →ₗ[R] N).rTensor M = id :=\n  map_id\n\n-- `simp` can prove this.\n"}
{"name":"LinearMap.rTensor_id_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nx : TensorProduct R N M\n⊢ Eq ((LinearMap.rTensor M LinearMap.id) x) x","decl":"theorem rTensor_id_apply (x : N ⊗[R] M) : (LinearMap.id : N →ₗ[R] N).rTensor M x = x := by\n  rw [rTensor_id, id_coe, _root_.id]\n\n"}
{"name":"LinearMap.lTensor_smul_action","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nr : R\n⊢ Eq (LinearMap.lTensor M (DistribMulAction.toLinearMap R N r)) (DistribMulAction.toLinearMap R (TensorProduct R M N) r)","decl":"@[simp]\ntheorem lTensor_smul_action (r : R) :\n    (DistribMulAction.toLinearMap R N r).lTensor M =\n      DistribMulAction.toLinearMap R (M ⊗[R] N) r :=\n  (lTensor_smul M r LinearMap.id).trans (congrArg _ (lTensor_id M N))\n\n"}
{"name":"LinearMap.rTensor_smul_action","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nr : R\n⊢ Eq (LinearMap.rTensor M (DistribMulAction.toLinearMap R N r)) (DistribMulAction.toLinearMap R (TensorProduct R N M) r)","decl":"@[simp]\ntheorem rTensor_smul_action (r : R) :\n    (DistribMulAction.toLinearMap R N r).rTensor M =\n      DistribMulAction.toLinearMap R (N ⊗[R] M) r :=\n  (rTensor_smul M r LinearMap.id).trans (congrArg _ (rTensor_id M N))\n\n"}
{"name":"LinearMap.lid_comp_rTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) N R\n⊢ Eq ((↑(TensorProduct.lid R M)).comp (LinearMap.rTensor M f)) (TensorProduct.lift ((LinearMap.lsmul R M).comp f))","decl":"theorem lid_comp_rTensor (f : N →ₗ[R] R) :\n    (TensorProduct.lid R M).comp (rTensor M f) = lift ((lsmul R M).comp f) := ext' fun _ _ ↦ rfl\n\n"}
{"name":"LinearMap.lTensor_comp_rTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq ((LinearMap.lTensor P g).comp (LinearMap.rTensor N f)) (TensorProduct.map f g)","decl":"@[simp]\ntheorem lTensor_comp_rTensor (f : M →ₗ[R] P) (g : N →ₗ[R] Q) :\n    (g.lTensor P).comp (f.rTensor N) = map f g := by\n  simp only [lTensor, rTensor, ← map_comp, id_comp, comp_id]\n\n"}
{"name":"LinearMap.rTensor_comp_lTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq ((LinearMap.rTensor Q f).comp (LinearMap.lTensor M g)) (TensorProduct.map f g)","decl":"@[simp]\ntheorem rTensor_comp_lTensor (f : M →ₗ[R] P) (g : N →ₗ[R] Q) :\n    (f.rTensor Q).comp (g.lTensor M) = map f g := by\n  simp only [lTensor, rTensor, ← map_comp, id_comp, comp_id]\n\n"}
{"name":"LinearMap.map_comp_rTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : AddCommMonoid Q\ninst✝⁵ : AddCommMonoid S\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R Q\ninst✝¹ : Module R S\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\nf' : LinearMap (RingHom.id R) S M\n⊢ Eq ((TensorProduct.map f g).comp (LinearMap.rTensor N f')) (TensorProduct.map (f.comp f') g)","decl":"@[simp]\ntheorem map_comp_rTensor (f : M →ₗ[R] P) (g : N →ₗ[R] Q) (f' : S →ₗ[R] M) :\n    (map f g).comp (f'.rTensor _) = map (f.comp f') g := by\n  simp only [lTensor, rTensor, ← map_comp, id_comp, comp_id]\n\n"}
{"name":"LinearMap.map_comp_lTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : AddCommMonoid Q\ninst✝⁵ : AddCommMonoid S\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R Q\ninst✝¹ : Module R S\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\ng' : LinearMap (RingHom.id R) S N\n⊢ Eq ((TensorProduct.map f g).comp (LinearMap.lTensor M g')) (TensorProduct.map f (g.comp g'))","decl":"@[simp]\ntheorem map_comp_lTensor (f : M →ₗ[R] P) (g : N →ₗ[R] Q) (g' : S →ₗ[R] N) :\n    (map f g).comp (g'.lTensor _) = map f (g.comp g') := by\n  simp only [lTensor, rTensor, ← map_comp, id_comp, comp_id]\n\n"}
{"name":"LinearMap.rTensor_comp_map","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : AddCommMonoid Q\ninst✝⁵ : AddCommMonoid S\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R Q\ninst✝¹ : Module R S\ninst✝ : Module R P\nf' : LinearMap (RingHom.id R) P S\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq ((LinearMap.rTensor Q f').comp (TensorProduct.map f g)) (TensorProduct.map (f'.comp f) g)","decl":"@[simp]\ntheorem rTensor_comp_map (f' : P →ₗ[R] S) (f : M →ₗ[R] P) (g : N →ₗ[R] Q) :\n    (f'.rTensor _).comp (map f g) = map (f'.comp f) g := by\n  simp only [lTensor, rTensor, ← map_comp, id_comp, comp_id]\n\n"}
{"name":"LinearMap.lTensor_comp_map","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : AddCommMonoid Q\ninst✝⁵ : AddCommMonoid S\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R Q\ninst✝¹ : Module R S\ninst✝ : Module R P\ng' : LinearMap (RingHom.id R) Q S\nf : LinearMap (RingHom.id R) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq ((LinearMap.lTensor P g').comp (TensorProduct.map f g)) (TensorProduct.map f (g'.comp g))","decl":"@[simp]\ntheorem lTensor_comp_map (g' : Q →ₗ[R] S) (f : M →ₗ[R] P) (g : N →ₗ[R] Q) :\n    (g'.lTensor _).comp (map f g) = map f (g'.comp g) := by\n  simp only [lTensor, rTensor, ← map_comp, id_comp, comp_id]\n\n"}
{"name":"LinearMap.rTensor_pow","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M M\nn : Nat\n⊢ Eq (HPow.hPow (LinearMap.rTensor N f) n) (LinearMap.rTensor N (HPow.hPow f n))","decl":"@[simp]\ntheorem rTensor_pow (f : M →ₗ[R] M) (n : ℕ) : f.rTensor N ^ n = (f ^ n).rTensor N := by\n  have h := TensorProduct.map_pow f (id : N →ₗ[R] N) n\n  rwa [id_pow] at h\n\n"}
{"name":"LinearMap.lTensor_pow","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) N N\nn : Nat\n⊢ Eq (HPow.hPow (LinearMap.lTensor M f) n) (LinearMap.lTensor M (HPow.hPow f n))","decl":"@[simp]\ntheorem lTensor_pow (f : N →ₗ[R] N) (n : ℕ) : f.lTensor M ^ n = (f ^ n).lTensor M := by\n  have h := TensorProduct.map_pow (id : M →ₗ[R] M) f n\n  rwa [id_pow] at h\n\n"}
{"name":"LinearEquiv.coe_lTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) N P\n⊢ Eq (↑(LinearEquiv.lTensor M f)) (LinearMap.lTensor M ↑f)","decl":"@[simp] theorem coe_lTensor : lTensor M f = (f : N →ₗ[R] P).lTensor M := rfl\n\n"}
{"name":"LinearEquiv.coe_lTensor_symm","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) N P\n⊢ Eq (↑(LinearEquiv.lTensor M f).symm) (LinearMap.lTensor M ↑f.symm)","decl":"@[simp] theorem coe_lTensor_symm : (lTensor M f).symm = (f.symm : P →ₗ[R] N).lTensor M := rfl\n\n"}
{"name":"LinearEquiv.coe_rTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) N P\n⊢ Eq (↑(LinearEquiv.rTensor M f)) (LinearMap.rTensor M ↑f)","decl":"@[simp] theorem coe_rTensor : rTensor M f = (f : N →ₗ[R] P).rTensor M := rfl\n\n"}
{"name":"LinearEquiv.coe_rTensor_symm","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) N P\n⊢ Eq (↑(LinearEquiv.rTensor M f).symm) (LinearMap.rTensor M ↑f.symm)","decl":"@[simp] theorem coe_rTensor_symm : (rTensor M f).symm = (f.symm : P →ₗ[R] N).rTensor M := rfl\n\n"}
{"name":"LinearEquiv.lTensor_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) N P\nm : M\nn : N\n⊢ Eq ((LinearEquiv.lTensor M f) (TensorProduct.tmul R m n)) (TensorProduct.tmul R m (f n))","decl":"@[simp] theorem lTensor_tmul : f.lTensor M (m ⊗ₜ n) = m ⊗ₜ f n := rfl\n\n"}
{"name":"LinearEquiv.lTensor_symm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) N P\nm : M\np : P\n⊢ Eq ((LinearEquiv.lTensor M f).symm (TensorProduct.tmul R m p)) (TensorProduct.tmul R m (f.symm p))","decl":"@[simp] theorem lTensor_symm_tmul : (f.lTensor M).symm (m ⊗ₜ p) = m ⊗ₜ f.symm p := rfl\n\n"}
{"name":"LinearEquiv.rTensor_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) N P\nm : M\nn : N\n⊢ Eq ((LinearEquiv.rTensor M f) (TensorProduct.tmul R n m)) (TensorProduct.tmul R (f n) m)","decl":"@[simp] theorem rTensor_tmul : f.rTensor M (n ⊗ₜ m) = f n ⊗ₜ m := rfl\n\n"}
{"name":"LinearEquiv.rTensor_symm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) N P\nm : M\np : P\n⊢ Eq ((LinearEquiv.rTensor M f).symm (TensorProduct.tmul R p m)) (TensorProduct.tmul R (f.symm p) m)","decl":"@[simp] theorem rTensor_symm_tmul : (f.rTensor M).symm (p ⊗ₜ m) = f.symm p ⊗ₜ m := rfl\n\n"}
{"name":"LinearEquiv.comm_trans_rTensor_trans_comm_eq","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : AddCommMonoid P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearEquiv (RingHom.id R) N P\n⊢ Eq (((TensorProduct.comm R Q N).trans (LinearEquiv.rTensor Q g)).trans (TensorProduct.comm R P Q)) (LinearEquiv.lTensor Q g)","decl":"lemma comm_trans_rTensor_trans_comm_eq (g : N ≃ₗ[R] P) :\n    TensorProduct.comm R Q N ≪≫ₗ rTensor Q g ≪≫ₗ TensorProduct.comm R P Q = lTensor Q g :=\n  toLinearMap_injective <| TensorProduct.ext rfl\n\n"}
{"name":"LinearEquiv.comm_trans_lTensor_trans_comm_eq","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : AddCommMonoid P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearEquiv (RingHom.id R) N P\n⊢ Eq (((TensorProduct.comm R N Q).trans (LinearEquiv.lTensor Q g)).trans (TensorProduct.comm R Q P)) (LinearEquiv.rTensor Q g)","decl":"lemma comm_trans_lTensor_trans_comm_eq (g : N ≃ₗ[R] P) :\n    TensorProduct.comm R N Q ≪≫ₗ lTensor Q g ≪≫ₗ TensorProduct.comm R Q P = rTensor Q g :=\n  toLinearMap_injective <| TensorProduct.ext rfl\n\n"}
{"name":"LinearEquiv.lTensor_trans","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearEquiv (RingHom.id R) P Q\nf : LinearEquiv (RingHom.id R) N P\n⊢ Eq (LinearEquiv.lTensor M (f.trans g)) ((LinearEquiv.lTensor M f).trans (LinearEquiv.lTensor M g))","decl":"theorem lTensor_trans : (f ≪≫ₗ g).lTensor M = f.lTensor M ≪≫ₗ g.lTensor M :=\n  toLinearMap_injective <| LinearMap.lTensor_comp M _ _\n\n"}
{"name":"LinearEquiv.lTensor_trans_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearEquiv (RingHom.id R) P Q\nf : LinearEquiv (RingHom.id R) N P\nx : TensorProduct R M N\n⊢ Eq ((LinearEquiv.lTensor M (f.trans g)) x) ((LinearEquiv.lTensor M g) ((LinearEquiv.lTensor M f) x))","decl":"theorem lTensor_trans_apply : (f ≪≫ₗ g).lTensor M x = g.lTensor M (f.lTensor M x) :=\n  LinearMap.lTensor_comp_apply M _ _ x\n\n"}
{"name":"LinearEquiv.rTensor_trans","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearEquiv (RingHom.id R) P Q\nf : LinearEquiv (RingHom.id R) N P\n⊢ Eq (LinearEquiv.rTensor M (f.trans g)) ((LinearEquiv.rTensor M f).trans (LinearEquiv.rTensor M g))","decl":"theorem rTensor_trans : (f ≪≫ₗ g).rTensor M = f.rTensor M ≪≫ₗ g.rTensor M :=\n  toLinearMap_injective <| LinearMap.rTensor_comp M _ _\n\n"}
{"name":"LinearEquiv.rTensor_trans_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\ng : LinearEquiv (RingHom.id R) P Q\nf : LinearEquiv (RingHom.id R) N P\ny : TensorProduct R N M\n⊢ Eq ((LinearEquiv.rTensor M (f.trans g)) y) ((LinearEquiv.rTensor M g) ((LinearEquiv.rTensor M f) y))","decl":"theorem rTensor_trans_apply : (f ≪≫ₗ g).rTensor M y = g.rTensor M (f.rTensor M y) :=\n  LinearMap.rTensor_comp_apply M _ _ y\n\n"}
{"name":"LinearEquiv.lTensor_mul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf g : LinearEquiv (RingHom.id R) N N\n⊢ Eq (LinearEquiv.lTensor M (HMul.hMul f g)) (HMul.hMul (LinearEquiv.lTensor M f) (LinearEquiv.lTensor M g))","decl":"theorem lTensor_mul (f g : N ≃ₗ[R] N) : (f * g).lTensor M = f.lTensor M * g.lTensor M :=\n  lTensor_trans M f g\n\n"}
{"name":"LinearEquiv.rTensor_mul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf g : LinearEquiv (RingHom.id R) N N\n⊢ Eq (LinearEquiv.rTensor M (HMul.hMul f g)) (HMul.hMul (LinearEquiv.rTensor M f) (LinearEquiv.rTensor M g))","decl":"theorem rTensor_mul (f g : N ≃ₗ[R] N) : (f * g).rTensor M = f.rTensor M * g.rTensor M :=\n  rTensor_trans M f g\n\n"}
{"name":"LinearEquiv.lTensor_refl","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ Eq (LinearEquiv.lTensor M (LinearEquiv.refl R N)) (LinearEquiv.refl R (TensorProduct R M N))","decl":"@[simp] theorem lTensor_refl : (refl R N).lTensor M = refl R _ := TensorProduct.congr_refl_refl\n\n"}
{"name":"LinearEquiv.lTensor_refl_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nx : TensorProduct R M N\n⊢ Eq ((LinearEquiv.lTensor M (LinearEquiv.refl R N)) x) x","decl":"theorem lTensor_refl_apply : (refl R N).lTensor M x = x := by rw [lTensor_refl, refl_apply]\n\n"}
{"name":"LinearEquiv.rTensor_refl","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ Eq (LinearEquiv.rTensor M (LinearEquiv.refl R N)) (LinearEquiv.refl R (TensorProduct R N M))","decl":"@[simp] theorem rTensor_refl : (refl R N).rTensor M = refl R _ := TensorProduct.congr_refl_refl\n\n"}
{"name":"LinearEquiv.rTensor_refl_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\ny : TensorProduct R N M\n⊢ Eq ((LinearEquiv.rTensor M (LinearEquiv.refl R N)) y) y","decl":"theorem rTensor_refl_apply : (refl R N).rTensor M y = y := by rw [rTensor_refl, refl_apply]\n\n"}
{"name":"LinearEquiv.rTensor_trans_lTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) M P\ng : LinearEquiv (RingHom.id R) N Q\n⊢ Eq ((LinearEquiv.rTensor N f).trans (LinearEquiv.lTensor P g)) (TensorProduct.congr f g)","decl":"@[simp] theorem rTensor_trans_lTensor (f : M ≃ₗ[R] P) (g : N ≃ₗ[R] Q) :\n    f.rTensor N ≪≫ₗ g.lTensor P = TensorProduct.congr f g :=\n  toLinearMap_injective <| LinearMap.lTensor_comp_rTensor M _ _\n\n"}
{"name":"LinearEquiv.lTensor_trans_rTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R Q\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) M P\ng : LinearEquiv (RingHom.id R) N Q\n⊢ Eq ((LinearEquiv.lTensor M g).trans (LinearEquiv.rTensor Q f)) (TensorProduct.congr f g)","decl":"@[simp] theorem lTensor_trans_rTensor (f : M ≃ₗ[R] P) (g : N ≃ₗ[R] Q) :\n    g.lTensor M ≪≫ₗ f.rTensor Q = TensorProduct.congr f g :=\n  toLinearMap_injective <| LinearMap.rTensor_comp_lTensor M _ _\n\n"}
{"name":"LinearEquiv.rTensor_trans_congr","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : AddCommMonoid Q\ninst✝⁵ : AddCommMonoid S\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R Q\ninst✝¹ : Module R S\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) M P\ng : LinearEquiv (RingHom.id R) N Q\nf' : LinearEquiv (RingHom.id R) S M\n⊢ Eq ((LinearEquiv.rTensor N f').trans (TensorProduct.congr f g)) (TensorProduct.congr (f'.trans f) g)","decl":"@[simp] theorem rTensor_trans_congr (f : M ≃ₗ[R] P) (g : N ≃ₗ[R] Q) (f' : S ≃ₗ[R] M) :\n    f'.rTensor _ ≪≫ₗ TensorProduct.congr f g = TensorProduct.congr (f' ≪≫ₗ f) g :=\n  toLinearMap_injective <| LinearMap.map_comp_rTensor M _ _ _\n\n"}
{"name":"LinearEquiv.lTensor_trans_congr","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : AddCommMonoid Q\ninst✝⁵ : AddCommMonoid S\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R Q\ninst✝¹ : Module R S\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) M P\ng : LinearEquiv (RingHom.id R) N Q\ng' : LinearEquiv (RingHom.id R) S N\n⊢ Eq ((LinearEquiv.lTensor M g').trans (TensorProduct.congr f g)) (TensorProduct.congr f (g'.trans g))","decl":"@[simp] theorem lTensor_trans_congr (f : M ≃ₗ[R] P) (g : N ≃ₗ[R] Q) (g' : S ≃ₗ[R] N) :\n    g'.lTensor _ ≪≫ₗ TensorProduct.congr f g = TensorProduct.congr f (g' ≪≫ₗ g) :=\n  toLinearMap_injective <| LinearMap.map_comp_lTensor M _ _ _\n\n"}
{"name":"LinearEquiv.congr_trans_rTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : AddCommMonoid Q\ninst✝⁵ : AddCommMonoid S\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R Q\ninst✝¹ : Module R S\ninst✝ : Module R P\nf' : LinearEquiv (RingHom.id R) P S\nf : LinearEquiv (RingHom.id R) M P\ng : LinearEquiv (RingHom.id R) N Q\n⊢ Eq ((TensorProduct.congr f g).trans (LinearEquiv.rTensor Q f')) (TensorProduct.congr (f.trans f') g)","decl":"@[simp] theorem congr_trans_rTensor (f' : P ≃ₗ[R] S) (f : M ≃ₗ[R] P) (g : N ≃ₗ[R] Q) :\n    TensorProduct.congr f g ≪≫ₗ f'.rTensor _ = TensorProduct.congr (f ≪≫ₗ f') g :=\n  toLinearMap_injective <| LinearMap.rTensor_comp_map M _ _ _\n\n"}
{"name":"LinearEquiv.congr_trans_lTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nM : Type u_5\nN : Type u_6\nP : Type u_7\nQ : Type u_8\nS : Type u_9\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : AddCommMonoid Q\ninst✝⁵ : AddCommMonoid S\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R Q\ninst✝¹ : Module R S\ninst✝ : Module R P\ng' : LinearEquiv (RingHom.id R) Q S\nf : LinearEquiv (RingHom.id R) M P\ng : LinearEquiv (RingHom.id R) N Q\n⊢ Eq ((TensorProduct.congr f g).trans (LinearEquiv.lTensor P g')) (TensorProduct.congr f (g.trans g'))","decl":"@[simp] theorem congr_trans_lTensor (g' : Q ≃ₗ[R] S) (f : M ≃ₗ[R] P) (g : N ≃ₗ[R] Q) :\n    TensorProduct.congr f g ≪≫ₗ g'.lTensor _ = TensorProduct.congr f (g ≪≫ₗ g') :=\n  toLinearMap_injective <| LinearMap.lTensor_comp_map M _ _ _\n\n"}
{"name":"LinearEquiv.rTensor_pow","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) M M\nn : Nat\n⊢ Eq (HPow.hPow (LinearEquiv.rTensor N f) n) (LinearEquiv.rTensor N (HPow.hPow f n))","decl":"@[simp] theorem rTensor_pow (f : M ≃ₗ[R] M) (n : ℕ) : f.rTensor N ^ n = (f ^ n).rTensor N := by\n  simpa only [one_pow] using TensorProduct.congr_pow f (1 : N ≃ₗ[R] N) n\n\n"}
{"name":"LinearEquiv.rTensor_zpow","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) M M\nn : Int\n⊢ Eq (HPow.hPow (LinearEquiv.rTensor N f) n) (LinearEquiv.rTensor N (HPow.hPow f n))","decl":"@[simp] theorem rTensor_zpow (f : M ≃ₗ[R] M) (n : ℤ) : f.rTensor N ^ n = (f ^ n).rTensor N := by\n  simpa only [one_zpow] using TensorProduct.congr_zpow f (1 : N ≃ₗ[R] N) n\n\n"}
{"name":"LinearEquiv.lTensor_pow","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) N N\nn : Nat\n⊢ Eq (HPow.hPow (LinearEquiv.lTensor M f) n) (LinearEquiv.lTensor M (HPow.hPow f n))","decl":"@[simp] theorem lTensor_pow (f : N ≃ₗ[R] N) (n : ℕ) : f.lTensor M ^ n = (f ^ n).lTensor M := by\n  simpa only [one_pow] using TensorProduct.congr_pow (1 : M ≃ₗ[R] M) f n\n\n"}
{"name":"LinearEquiv.lTensor_zpow","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_5\nN : Type u_6\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) N N\nn : Int\n⊢ Eq (HPow.hPow (LinearEquiv.lTensor M f) n) (LinearEquiv.lTensor M (HPow.hPow f n))","decl":"@[simp] theorem lTensor_zpow (f : N ≃ₗ[R] N) (n : ℤ) : f.lTensor M ^ n = (f ^ n).lTensor M := by\n  simpa only [one_zpow] using TensorProduct.congr_zpow (1 : M ≃ₗ[R] M) f n\n\n"}
{"name":"TensorProduct.neg_add_cancel","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\nN : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nx : TensorProduct R M N\n⊢ Eq (HAdd.hAdd (Neg.neg x) x) 0","decl":"protected theorem neg_add_cancel (x : M ⊗[R] N) : -x + x = 0 :=\n  x.induction_on\n    (by rw [add_zero]; apply (Neg.aux R).map_zero)\n    (fun x y => by convert (add_tmul (R := R) (-x) x y).symm; rw [neg_add_cancel, zero_tmul])\n    fun x y hx hy => by\n    suffices -x + x + (-y + y) = 0 by\n      rw [← this]\n      unfold Neg.neg neg\n      simp only\n      rw [map_add]\n      abel\n    rw [hx, hy, add_zero]\n\n"}
{"name":"TensorProduct.neg_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\nN : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nm : M\nn : N\n⊢ Eq (TensorProduct.tmul R (Neg.neg m) n) (Neg.neg (TensorProduct.tmul R m n))","decl":"theorem neg_tmul (m : M) (n : N) : (-m) ⊗ₜ n = -m ⊗ₜ[R] n :=\n  rfl\n\n"}
{"name":"TensorProduct.tmul_neg","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\nN : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nm : M\nn : N\n⊢ Eq (TensorProduct.tmul R m (Neg.neg n)) (Neg.neg (TensorProduct.tmul R m n))","decl":"theorem tmul_neg (m : M) (n : N) : m ⊗ₜ (-n) = -m ⊗ₜ[R] n :=\n  (mk R M N _).map_neg _\n\n"}
{"name":"TensorProduct.tmul_sub","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\nN : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nm : M\nn₁ n₂ : N\n⊢ Eq (TensorProduct.tmul R m (HSub.hSub n₁ n₂)) (HSub.hSub (TensorProduct.tmul R m n₁) (TensorProduct.tmul R m n₂))","decl":"theorem tmul_sub (m : M) (n₁ n₂ : N) : m ⊗ₜ (n₁ - n₂) = m ⊗ₜ[R] n₁ - m ⊗ₜ[R] n₂ :=\n  (mk R M N _).map_sub _ _\n\n"}
{"name":"TensorProduct.sub_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\nN : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nm₁ m₂ : M\nn : N\n⊢ Eq (TensorProduct.tmul R (HSub.hSub m₁ m₂) n) (HSub.hSub (TensorProduct.tmul R m₁ n) (TensorProduct.tmul R m₂ n))","decl":"theorem sub_tmul (m₁ m₂ : M) (n : N) : (m₁ - m₂) ⊗ₜ n = m₁ ⊗ₜ[R] n - m₂ ⊗ₜ[R] n :=\n  (mk R M N).map_sub₂ _ _ _\n\n"}
{"name":"TensorProduct.CompatibleSMul.int","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_2\nN : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ TensorProduct.CompatibleSMul R Int M N","decl":"/-- While the tensor product will automatically inherit a ℤ-module structure from\n`AddCommGroup.toIntModule`, that structure won't be compatible with lemmas like `tmul_smul` unless\nwe use a `ℤ-Module` instance provided by `TensorProduct.left_module`.\n\nWhen `R` is a `Ring` we get the required `TensorProduct.compatible_smul` instance through\n`IsScalarTower`, but when it is only a `Semiring` we need to build it from scratch.\nThe instance diamond in `compatible_smul` doesn't matter because it's in `Prop`.\n-/\ninstance CompatibleSMul.int : CompatibleSMul R ℤ M N :=\n  ⟨fun r m n =>\n    Int.induction_on r (by simp) (fun r ih => by simpa [add_smul, tmul_add, add_tmul] using ih)\n      fun r ih => by simpa [sub_smul, tmul_sub, sub_tmul] using ih⟩\n\n"}
{"name":"TensorProduct.CompatibleSMul.unit","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_2\nN : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\nS : Type u_7\ninst✝³ : Monoid S\ninst✝² : DistribMulAction S M\ninst✝¹ : DistribMulAction S N\ninst✝ : TensorProduct.CompatibleSMul R S M N\n⊢ TensorProduct.CompatibleSMul R (Units S) M N","decl":"instance CompatibleSMul.unit {S} [Monoid S] [DistribMulAction S M] [DistribMulAction S N]\n    [CompatibleSMul R S M N] : CompatibleSMul R Sˣ M N :=\n  ⟨fun s m n => CompatibleSMul.smul_tmul (s : S) m n⟩\n\n"}
{"name":"LinearMap.lTensor_sub","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf g : LinearMap (RingHom.id R) N P\n⊢ Eq (LinearMap.lTensor M (HSub.hSub f g)) (HSub.hSub (LinearMap.lTensor M f) (LinearMap.lTensor M g))","decl":"@[simp]\ntheorem lTensor_sub (f g : N →ₗ[R] P) : (f - g).lTensor M = f.lTensor M - g.lTensor M := by\n  simp_rw [← coe_lTensorHom]\n  exact (lTensorHom (R := R) (N := N) (P := P) M).map_sub f g\n\n"}
{"name":"LinearMap.rTensor_sub","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf g : LinearMap (RingHom.id R) N P\n⊢ Eq (LinearMap.rTensor M (HSub.hSub f g)) (HSub.hSub (LinearMap.rTensor M f) (LinearMap.rTensor M g))","decl":"@[simp]\ntheorem rTensor_sub (f g : N →ₗ[R] P) : (f - g).rTensor M = f.rTensor M - g.rTensor M := by\n  simp only [← coe_rTensorHom]\n  exact (rTensorHom (R := R) (N := N) (P := P) M).map_sub f g\n\n"}
{"name":"LinearMap.lTensor_neg","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\n⊢ Eq (LinearMap.lTensor M (Neg.neg f)) (Neg.neg (LinearMap.lTensor M f))","decl":"@[simp]\ntheorem lTensor_neg (f : N →ₗ[R] P) : (-f).lTensor M = -f.lTensor M := by\n  simp only [← coe_lTensorHom]\n  exact (lTensorHom (R := R) (N := N) (P := P) M).map_neg f\n\n"}
{"name":"LinearMap.rTensor_neg","module":"Mathlib.LinearAlgebra.TensorProduct.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\n⊢ Eq (LinearMap.rTensor M (Neg.neg f)) (Neg.neg (LinearMap.rTensor M f))","decl":"@[simp]\ntheorem rTensor_neg (f : N →ₗ[R] P) : (-f).rTensor M = -f.rTensor M := by\n  simp only [← coe_rTensorHom]\n  exact (rTensorHom (R := R) (N := N) (P := P) M).map_neg f\n\n"}
