{"name":"commutatorElement_eq_one_iff_mul_comm","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng₁ g₂ : G\n⊢ Iff (Eq (Bracket.bracket g₁ g₂) 1) (Eq (HMul.hMul g₁ g₂) (HMul.hMul g₂ g₁))","decl":"theorem commutatorElement_eq_one_iff_mul_comm : ⁅g₁, g₂⁆ = 1 ↔ g₁ * g₂ = g₂ * g₁ := by\n  rw [commutatorElement_def, mul_inv_eq_one, mul_inv_eq_iff_eq_mul]\n\n"}
{"name":"commutatorElement_eq_one_iff_commute","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng₁ g₂ : G\n⊢ Iff (Eq (Bracket.bracket g₁ g₂) 1) (Commute g₁ g₂)","decl":"theorem commutatorElement_eq_one_iff_commute : ⁅g₁, g₂⁆ = 1 ↔ Commute g₁ g₂ :=\n  commutatorElement_eq_one_iff_mul_comm\n\n"}
{"name":"Commute.commutator_eq","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng₁ g₂ : G\nh : Commute g₁ g₂\n⊢ Eq (Bracket.bracket g₁ g₂) 1","decl":"theorem Commute.commutator_eq (h : Commute g₁ g₂) : ⁅g₁, g₂⁆ = 1 :=\n  commutatorElement_eq_one_iff_commute.mpr h\n\n"}
{"name":"commutatorElement_one_right","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\n⊢ Eq (Bracket.bracket g 1) 1","decl":"@[simp]\ntheorem commutatorElement_one_right : ⁅g, (1 : G)⁆ = 1 :=\n  (Commute.one_right g).commutator_eq\n\n"}
{"name":"commutatorElement_one_left","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\n⊢ Eq (Bracket.bracket 1 g) 1","decl":"@[simp]\ntheorem commutatorElement_one_left : ⁅(1 : G), g⁆ = 1 :=\n  (Commute.one_left g).commutator_eq\n\n"}
{"name":"commutatorElement_self","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\n⊢ Eq (Bracket.bracket g g) 1","decl":"@[simp]\ntheorem commutatorElement_self : ⁅g, g⁆ = 1 :=\n  (Commute.refl g).commutator_eq\n\n"}
{"name":"commutatorElement_inv","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng₁ g₂ : G\n⊢ Eq (Inv.inv (Bracket.bracket g₁ g₂)) (Bracket.bracket g₂ g₁)","decl":"@[simp]\ntheorem commutatorElement_inv : ⁅g₁, g₂⁆⁻¹ = ⁅g₂, g₁⁆ := by\n  simp_rw [commutatorElement_def, mul_inv_rev, inv_inv, mul_assoc]\n\n"}
{"name":"map_commutatorElement","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\nG' : Type u_2\nF : Type u_3\ninst✝³ : Group G\ninst✝² : Group G'\ninst✝¹ : FunLike F G G'\ninst✝ : MonoidHomClass F G G'\nf : F\ng₁ g₂ : G\n⊢ Eq (f (Bracket.bracket g₁ g₂)) (Bracket.bracket (f g₁) (f g₂))","decl":"theorem map_commutatorElement : (f ⁅g₁, g₂⁆ : G') = ⁅f g₁, f g₂⁆ := by\n  simp_rw [commutatorElement_def, map_mul f, map_inv f]\n\n"}
{"name":"conjugate_commutatorElement","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng₁ g₂ g₃ : G\n⊢ Eq (HMul.hMul (HMul.hMul g₃ (Bracket.bracket g₁ g₂)) (Inv.inv g₃)) (Bracket.bracket (HMul.hMul (HMul.hMul g₃ g₁) (Inv.inv g₃)) (HMul.hMul (HMul.hMul g₃ g₂) (Inv.inv g₃)))","decl":"theorem conjugate_commutatorElement : g₃ * ⁅g₁, g₂⁆ * g₃⁻¹ = ⁅g₃ * g₁ * g₃⁻¹, g₃ * g₂ * g₃⁻¹⁆ :=\n  map_commutatorElement (MulAut.conj g₃).toMonoidHom g₁ g₂\n\n"}
{"name":"Subgroup.commutator_def","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ : Subgroup G\n⊢ Eq (Bracket.bracket H₁ H₂) (Subgroup.closure (setOf fun g => Exists fun g₁ => And (Membership.mem H₁ g₁) (Exists fun g₂ => And (Membership.mem H₂ g₂) (Eq (Bracket.bracket g₁ g₂) g))))","decl":"theorem commutator_def (H₁ H₂ : Subgroup G) :\n    ⁅H₁, H₂⁆ = closure { g | ∃ g₁ ∈ H₁, ∃ g₂ ∈ H₂, ⁅g₁, g₂⁆ = g } :=\n  rfl\n\n"}
{"name":"Subgroup.commutator_mem_commutator","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng₁ g₂ : G\nH₁ H₂ : Subgroup G\nh₁ : Membership.mem H₁ g₁\nh₂ : Membership.mem H₂ g₂\n⊢ Membership.mem (Bracket.bracket H₁ H₂) (Bracket.bracket g₁ g₂)","decl":"theorem commutator_mem_commutator (h₁ : g₁ ∈ H₁) (h₂ : g₂ ∈ H₂) : ⁅g₁, g₂⁆ ∈ ⁅H₁, H₂⁆ :=\n  subset_closure ⟨g₁, h₁, g₂, h₂, rfl⟩\n\n"}
{"name":"Subgroup.commutator_le","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ H₃ : Subgroup G\n⊢ Iff (LE.le (Bracket.bracket H₁ H₂) H₃) (∀ (g₁ : G), Membership.mem H₁ g₁ → ∀ (g₂ : G), Membership.mem H₂ g₂ → Membership.mem H₃ (Bracket.bracket g₁ g₂))","decl":"theorem commutator_le : ⁅H₁, H₂⁆ ≤ H₃ ↔ ∀ g₁ ∈ H₁, ∀ g₂ ∈ H₂, ⁅g₁, g₂⁆ ∈ H₃ :=\n  H₃.closure_le.trans\n    ⟨fun h a b c d => h ⟨a, b, c, d, rfl⟩, fun h _g ⟨a, b, c, d, h_eq⟩ => h_eq ▸ h a b c d⟩\n\n"}
{"name":"Subgroup.commutator_mono","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ K₁ K₂ : Subgroup G\nh₁ : LE.le H₁ K₁\nh₂ : LE.le H₂ K₂\n⊢ LE.le (Bracket.bracket H₁ H₂) (Bracket.bracket K₁ K₂)","decl":"theorem commutator_mono (h₁ : H₁ ≤ K₁) (h₂ : H₂ ≤ K₂) : ⁅H₁, H₂⁆ ≤ ⁅K₁, K₂⁆ :=\n  commutator_le.mpr fun _g₁ hg₁ _g₂ hg₂ => commutator_mem_commutator (h₁ hg₁) (h₂ hg₂)\n\n"}
{"name":"Subgroup.commutator_eq_bot_iff_le_centralizer","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ : Subgroup G\n⊢ Iff (Eq (Bracket.bracket H₁ H₂) Bot.bot) (LE.le H₁ (Subgroup.centralizer ↑H₂))","decl":"theorem commutator_eq_bot_iff_le_centralizer : ⁅H₁, H₂⁆ = ⊥ ↔ H₁ ≤ centralizer H₂ := by\n  rw [eq_bot_iff, commutator_le]\n  refine forall_congr' fun p =>\n    forall_congr' fun _hp => forall_congr' fun q => forall_congr' fun hq => ?_\n  rw [mem_bot, commutatorElement_eq_one_iff_mul_comm, eq_comm]\n\n"}
{"name":"Subgroup.commutator_commutator_eq_bot_of_rotate","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ H₃ : Subgroup G\nh1 : Eq (Bracket.bracket (Bracket.bracket H₂ H₃) H₁) Bot.bot\nh2 : Eq (Bracket.bracket (Bracket.bracket H₃ H₁) H₂) Bot.bot\n⊢ Eq (Bracket.bracket (Bracket.bracket H₁ H₂) H₃) Bot.bot","decl":"/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/\ntheorem commutator_commutator_eq_bot_of_rotate (h1 : ⁅⁅H₂, H₃⁆, H₁⁆ = ⊥) (h2 : ⁅⁅H₃, H₁⁆, H₂⁆ = ⊥) :\n    ⁅⁅H₁, H₂⁆, H₃⁆ = ⊥ := by\n  simp_rw [commutator_eq_bot_iff_le_centralizer, commutator_le,\n    mem_centralizer_iff_commutator_eq_one, ← commutatorElement_def] at h1 h2 ⊢\n  intro x hx y hy z hz\n  trans x * z * ⁅y, ⁅z⁻¹, x⁻¹⁆⁆⁻¹ * z⁻¹ * y * ⁅x⁻¹, ⁅y⁻¹, z⁆⁆⁻¹ * y⁻¹ * x⁻¹\n  · group\n  · rw [h1 _ (H₂.inv_mem hy) _ hz _ (H₁.inv_mem hx), h2 _ (H₃.inv_mem hz) _ (H₁.inv_mem hx) _ hy]\n    group\n\n"}
{"name":"Subgroup.commutator_comm_le","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ : Subgroup G\n⊢ LE.le (Bracket.bracket H₁ H₂) (Bracket.bracket H₂ H₁)","decl":"theorem commutator_comm_le : ⁅H₁, H₂⁆ ≤ ⁅H₂, H₁⁆ :=\n  commutator_le.mpr fun g₁ h₁ g₂ h₂ =>\n    commutatorElement_inv g₂ g₁ ▸ ⁅H₂, H₁⁆.inv_mem_iff.mpr (commutator_mem_commutator h₂ h₁)\n\n"}
{"name":"Subgroup.commutator_comm","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ : Subgroup G\n⊢ Eq (Bracket.bracket H₁ H₂) (Bracket.bracket H₂ H₁)","decl":"theorem commutator_comm : ⁅H₁, H₂⁆ = ⁅H₂, H₁⁆ :=\n  le_antisymm (commutator_comm_le H₁ H₂) (commutator_comm_le H₂ H₁)\n\n"}
{"name":"Subgroup.commutator_normal","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ : Subgroup G\nh₁ : H₁.Normal\nh₂ : H₂.Normal\n⊢ (Bracket.bracket H₁ H₂).Normal","decl":"instance commutator_normal [h₁ : H₁.Normal] [h₂ : H₂.Normal] : Normal ⁅H₁, H₂⁆ := by\n  let base : Set G := { x | ∃ g₁ ∈ H₁, ∃ g₂ ∈ H₂, ⁅g₁, g₂⁆ = x }\n  change (closure base).Normal\n  suffices h_base : base = Group.conjugatesOfSet base by\n    rw [h_base]\n    exact Subgroup.normalClosure_normal\n  refine Set.Subset.antisymm Group.subset_conjugatesOfSet fun a h => ?_\n  simp_rw [Group.mem_conjugatesOfSet_iff, isConj_iff] at h\n  rcases h with ⟨b, ⟨c, hc, e, he, rfl⟩, d, rfl⟩\n  exact ⟨_, h₁.conj_mem c hc d, _, h₂.conj_mem e he d, (conjugate_commutatorElement c e d).symm⟩\n\n"}
{"name":"Subgroup.commutator_def'","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\nH₁ H₂ : Subgroup G\ninst✝¹ : H₁.Normal\ninst✝ : H₂.Normal\n⊢ Eq (Bracket.bracket H₁ H₂) (Subgroup.normalClosure (setOf fun g => Exists fun g₁ => And (Membership.mem H₁ g₁) (Exists fun g₂ => And (Membership.mem H₂ g₂) (Eq (Bracket.bracket g₁ g₂) g))))","decl":"theorem commutator_def' [H₁.Normal] [H₂.Normal] :\n    ⁅H₁, H₂⁆ = normalClosure { g | ∃ g₁ ∈ H₁, ∃ g₂ ∈ H₂, ⁅g₁, g₂⁆ = g } :=\n  le_antisymm closure_le_normalClosure (normalClosure_le_normal subset_closure)\n\n"}
{"name":"Subgroup.commutator_le_right","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ : Subgroup G\nh : H₂.Normal\n⊢ LE.le (Bracket.bracket H₁ H₂) H₂","decl":"theorem commutator_le_right [h : H₂.Normal] : ⁅H₁, H₂⁆ ≤ H₂ :=\n  commutator_le.mpr fun g₁ _h₁ g₂ h₂ => H₂.mul_mem (h.conj_mem g₂ h₂ g₁) (H₂.inv_mem h₂)\n\n"}
{"name":"Subgroup.commutator_le_left","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH₁ H₂ : Subgroup G\ninst✝ : H₁.Normal\n⊢ LE.le (Bracket.bracket H₁ H₂) H₁","decl":"theorem commutator_le_left [H₁.Normal] : ⁅H₁, H₂⁆ ≤ H₁ :=\n  commutator_comm H₂ H₁ ▸ commutator_le_right H₂ H₁\n\n"}
{"name":"Subgroup.commutator_bot_left","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ : Subgroup G\n⊢ Eq (Bracket.bracket Bot.bot H₁) Bot.bot","decl":"@[simp]\ntheorem commutator_bot_left : ⁅(⊥ : Subgroup G), H₁⁆ = ⊥ :=\n  le_bot_iff.mp (commutator_le_left ⊥ H₁)\n\n"}
{"name":"Subgroup.commutator_bot_right","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ : Subgroup G\n⊢ Eq (Bracket.bracket H₁ Bot.bot) Bot.bot","decl":"@[simp]\ntheorem commutator_bot_right : ⁅H₁, ⊥⁆ = (⊥ : Subgroup G) :=\n  le_bot_iff.mp (commutator_le_right H₁ ⊥)\n\n"}
{"name":"Subgroup.commutator_le_inf","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\nH₁ H₂ : Subgroup G\ninst✝¹ : H₁.Normal\ninst✝ : H₂.Normal\n⊢ LE.le (Bracket.bracket H₁ H₂) (Min.min H₁ H₂)","decl":"theorem commutator_le_inf [Normal H₁] [Normal H₂] : ⁅H₁, H₂⁆ ≤ H₁ ⊓ H₂ :=\n  le_inf (commutator_le_left H₁ H₂) (commutator_le_right H₁ H₂)\n\n"}
{"name":"Subgroup.map_commutator","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH₁ H₂ : Subgroup G\nf : MonoidHom G G'\n⊢ Eq (Subgroup.map f (Bracket.bracket H₁ H₂)) (Bracket.bracket (Subgroup.map f H₁) (Subgroup.map f H₂))","decl":"theorem map_commutator (f : G →* G') : map f ⁅H₁, H₂⁆ = ⁅map f H₁, map f H₂⁆ := by\n  simp_rw [le_antisymm_iff, map_le_iff_le_comap, commutator_le, mem_comap, map_commutatorElement]\n  constructor\n  · intro p hp q hq\n    exact commutator_mem_commutator (mem_map_of_mem _ hp) (mem_map_of_mem _ hq)\n  · rintro _ ⟨p, hp, rfl⟩ _ ⟨q, hq, rfl⟩\n    rw [← map_commutatorElement]\n    exact mem_map_of_mem _ (commutator_mem_commutator hp hq)\n\n"}
{"name":"Subgroup.commutator_le_map_commutator","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH₁ H₂ : Subgroup G\nf : MonoidHom G G'\nK₁ K₂ : Subgroup G'\nh₁ : LE.le K₁ (Subgroup.map f H₁)\nh₂ : LE.le K₂ (Subgroup.map f H₂)\n⊢ LE.le (Bracket.bracket K₁ K₂) (Subgroup.map f (Bracket.bracket H₁ H₂))","decl":"theorem commutator_le_map_commutator {f : G →* G'} {K₁ K₂ : Subgroup G'} (h₁ : K₁ ≤ H₁.map f)\n    (h₂ : K₂ ≤ H₂.map f) : ⁅K₁, K₂⁆ ≤ ⁅H₁, H₂⁆.map f :=\n  (commutator_mono h₁ h₂).trans (ge_of_eq (map_commutator H₁ H₂ f))\n\n"}
{"name":"Subgroup.commutator_characteristic","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ : Subgroup G\nh₁ : H₁.Characteristic\nh₂ : H₂.Characteristic\n⊢ (Bracket.bracket H₁ H₂).Characteristic","decl":"instance commutator_characteristic [h₁ : Characteristic H₁] [h₂ : Characteristic H₂] :\n    Characteristic ⁅H₁, H₂⁆ :=\n  characteristic_iff_le_map.mpr fun ϕ =>\n    commutator_le_map_commutator (characteristic_iff_le_map.mp h₁ ϕ)\n      (characteristic_iff_le_map.mp h₂ ϕ)\n\n"}
{"name":"Subgroup.commutator_prod_prod","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH₁ H₂ : Subgroup G\nK₁ K₂ : Subgroup G'\n⊢ Eq (Bracket.bracket (H₁.prod K₁) (H₂.prod K₂)) ((Bracket.bracket H₁ H₂).prod (Bracket.bracket K₁ K₂))","decl":"theorem commutator_prod_prod (K₁ K₂ : Subgroup G') :\n    ⁅H₁.prod K₁, H₂.prod K₂⁆ = ⁅H₁, H₂⁆.prod ⁅K₁, K₂⁆ := by\n  apply le_antisymm\n  · rw [commutator_le]\n    rintro ⟨p₁, p₂⟩ ⟨hp₁, hp₂⟩ ⟨q₁, q₂⟩ ⟨hq₁, hq₂⟩\n    exact ⟨commutator_mem_commutator hp₁ hq₁, commutator_mem_commutator hp₂ hq₂⟩\n  · rw [prod_le_iff]\n    constructor <;>\n      · rw [map_commutator]\n        apply commutator_mono <;>\n          simp [le_prod_iff, map_map, MonoidHom.fst_comp_inl, MonoidHom.snd_comp_inl,\n            MonoidHom.fst_comp_inr, MonoidHom.snd_comp_inr]\n\n"}
{"name":"Subgroup.commutator_pi_pi_le","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"η : Type u_4\nGs : η → Type u_5\ninst✝ : (i : η) → Group (Gs i)\nH K : (i : η) → Subgroup (Gs i)\n⊢ LE.le (Bracket.bracket (Subgroup.pi Set.univ H) (Subgroup.pi Set.univ K)) (Subgroup.pi Set.univ fun i => Bracket.bracket (H i) (K i))","decl":"/-- The commutator of direct product is contained in the direct product of the commutators.\n\nSee `commutator_pi_pi_of_finite` for equality given `Fintype η`.\n-/\ntheorem commutator_pi_pi_le {η : Type*} {Gs : η → Type*} [∀ i, Group (Gs i)]\n    (H K : ∀ i, Subgroup (Gs i)) :\n    ⁅Subgroup.pi Set.univ H, Subgroup.pi Set.univ K⁆ ≤ Subgroup.pi Set.univ fun i => ⁅H i, K i⁆ :=\n  commutator_le.mpr fun _p hp _q hq i hi => commutator_mem_commutator (hp i hi) (hq i hi)\n\n"}
{"name":"commutatorSet_def","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (commutatorSet G) (setOf fun g => Exists fun g₁ => Exists fun g₂ => Eq (Bracket.bracket g₁ g₂) g)","decl":"theorem commutatorSet_def : commutatorSet G = { g | ∃ g₁ g₂ : G, ⁅g₁, g₂⁆ = g } :=\n  rfl\n\n"}
{"name":"one_mem_commutatorSet","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Membership.mem (commutatorSet G) 1","decl":"theorem one_mem_commutatorSet : (1 : G) ∈ commutatorSet G :=\n  ⟨1, 1, commutatorElement_self 1⟩\n\n"}
{"name":"instNonemptyElemCommutatorSet","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Nonempty ↑(commutatorSet G)","decl":"instance : Nonempty (commutatorSet G) :=\n  ⟨⟨1, one_mem_commutatorSet G⟩⟩\n\n"}
{"name":"mem_commutatorSet_iff","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\n⊢ Iff (Membership.mem (commutatorSet G) g) (Exists fun g₁ => Exists fun g₂ => Eq (Bracket.bracket g₁ g₂) g)","decl":"theorem mem_commutatorSet_iff : g ∈ commutatorSet G ↔ ∃ g₁ g₂ : G, ⁅g₁, g₂⁆ = g :=\n  Iff.rfl\n\n"}
{"name":"commutator_mem_commutatorSet","module":"Mathlib.GroupTheory.Commutator.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng₁ g₂ : G\n⊢ Membership.mem (commutatorSet G) (Bracket.bracket g₁ g₂)","decl":"theorem commutator_mem_commutatorSet : ⁅g₁, g₂⁆ ∈ commutatorSet G :=\n  ⟨g₁, g₂, rfl⟩\n"}
