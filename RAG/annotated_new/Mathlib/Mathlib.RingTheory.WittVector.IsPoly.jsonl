{"name":"WittVector.poly_eq_of_wittPolynomial_bind_eq'","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\nidx : Type u_1\ninst‚úù : Fact (Nat.Prime p)\nf g : Nat ‚Üí MvPolynomial (Prod idx Nat) Int\nh : ‚àÄ (n : Nat), Eq ((MvPolynomial.bind‚ÇÅ f) (wittPolynomial p Int n)) ((MvPolynomial.bind‚ÇÅ g) (wittPolynomial p Int n))\n‚ä¢ Eq f g","decl":"theorem poly_eq_of_wittPolynomial_bind_eq' [Fact p.Prime] (f g : ‚Ñï ‚Üí MvPolynomial (idx √ó ‚Ñï) ‚Ñ§)\n    (h : ‚àÄ n, bind‚ÇÅ f (wittPolynomial p _ n) = bind‚ÇÅ g (wittPolynomial p _ n)) : f = g := by\n  ext1 n\n  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective\n  rw [‚Üê funext_iff] at h\n  replace h :=\n    congr_arg (fun fam => bind‚ÇÅ (MvPolynomial.map (Int.castRingHom ‚Ñö) ‚àò fam) (xInTermsOfW p ‚Ñö n)) h\n  simpa only [Function.comp_def, map_bind‚ÇÅ, map_wittPolynomial, ‚Üê bind‚ÇÅ_bind‚ÇÅ,\n    bind‚ÇÅ_wittPolynomial_xInTermsOfW, bind‚ÇÅ_X_right] using h\n\n"}
{"name":"WittVector.poly_eq_of_wittPolynomial_bind_eq","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\ninst‚úù : Fact (Nat.Prime p)\nf g : Nat ‚Üí MvPolynomial Nat Int\nh : ‚àÄ (n : Nat), Eq ((MvPolynomial.bind‚ÇÅ f) (wittPolynomial p Int n)) ((MvPolynomial.bind‚ÇÅ g) (wittPolynomial p Int n))\n‚ä¢ Eq f g","decl":"theorem poly_eq_of_wittPolynomial_bind_eq [Fact p.Prime] (f g : ‚Ñï ‚Üí MvPolynomial ‚Ñï ‚Ñ§)\n    (h : ‚àÄ n, bind‚ÇÅ f (wittPolynomial p _ n) = bind‚ÇÅ g (wittPolynomial p _ n)) : f = g := by\n  ext1 n\n  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective\n  rw [‚Üê funext_iff] at h\n  replace h :=\n    congr_arg (fun fam => bind‚ÇÅ (MvPolynomial.map (Int.castRingHom ‚Ñö) ‚àò fam) (xInTermsOfW p ‚Ñö n)) h\n  simpa only [Function.comp_def, map_bind‚ÇÅ, map_wittPolynomial, ‚Üê bind‚ÇÅ_bind‚ÇÅ,\n    bind‚ÇÅ_wittPolynomial_xInTermsOfW, bind‚ÇÅ_X_right] using h\n\n-- Ideally, we would generalise this to n-ary functions\n-- But we don't have a good theory of n-ary compositions in mathlib\n"}
{"name":"WittVector.IsPoly.poly","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\nf : ‚¶ÉR : Type u_2‚¶Ñ ‚Üí [inst : CommRing R] ‚Üí WittVector p R ‚Üí WittVector p R\nself : WittVector.IsPoly p f\n‚ä¢ Exists fun œÜ => ‚àÄ ‚¶ÉR : Type u_2‚¶Ñ [inst : CommRing R] (x : WittVector p R), Eq (f x).coeff fun n => (MvPolynomial.aeval x.coeff) (œÜ n)","decl":"/--\nA function `f : Œ† R, ùïé R ‚Üí ùïé R` that maps Witt vectors to Witt vectors over arbitrary base rings\nis said to be *polynomial* if there is a family of polynomials `œÜ‚Çô` over `‚Ñ§` such that the `n`th\ncoefficient of `f x` is given by evaluating `œÜ‚Çô` at the coefficients of `x`.\n\nSee also `WittVector.IsPoly‚ÇÇ` for the binary variant.\n\nThe `ghost_calc` tactic makes use of the `IsPoly` and `IsPoly‚ÇÇ` typeclass and its instances.\n(In Lean 3, there was an `@[is_poly]` attribute to manage these instances,\nbecause typeclass resolution did not play well with function composition.\nThis no longer seems to be an issue, so that such instances can be defined directly.)\n-/\nclass IsPoly (f : ‚àÄ ‚¶ÉR‚¶Ñ [CommRing R], WittVector p R ‚Üí ùïé R) : Prop where mk' ::\n  poly :\n    ‚àÉ œÜ : ‚Ñï ‚Üí MvPolynomial ‚Ñï ‚Ñ§,\n      ‚àÄ ‚¶ÉR‚¶Ñ [CommRing R] (x : ùïé R), (f x).coeff = fun n => aeval x.coeff (œÜ n)\n\n"}
{"name":"WittVector.idIsPoly","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\n‚ä¢ WittVector.IsPoly p fun x x_1 => id","decl":"/-- The identity function on Witt vectors is a polynomial function. -/\ninstance idIsPoly : IsPoly p fun _ _ => id :=\n  ‚ü®‚ü®X, by intros; simp only [aeval_X, id]‚ü©‚ü©\n\n"}
{"name":"WittVector.idIsPolyI'","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\n‚ä¢ WittVector.IsPoly p fun x x_1 a => a","decl":"instance idIsPolyI' : IsPoly p fun _ _ a => a :=\n  WittVector.idIsPoly _\n\n"}
{"name":"WittVector.IsPoly.ext","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\ninst‚úù : Fact (Nat.Prime p)\nf g : ‚¶ÉR : Type u‚¶Ñ ‚Üí [inst : CommRing R] ‚Üí WittVector p R ‚Üí WittVector p R\nhf : WittVector.IsPoly p f\nhg : WittVector.IsPoly p g\nh : ‚àÄ (R : Type u) [_Rcr : CommRing R] (x : WittVector p R) (n : Nat), Eq ((WittVector.ghostComponent n) (f x)) ((WittVector.ghostComponent n) (g x))\nR : Type u\n_Rcr : CommRing R\nx : WittVector p R\n‚ä¢ Eq (f x) (g x)","decl":"theorem ext [Fact p.Prime] {f g} (hf : IsPoly p f) (hg : IsPoly p g)\n    (h : ‚àÄ (R : Type u) [_Rcr : CommRing R] (x : ùïé R) (n : ‚Ñï),\n        ghostComponent n (f x) = ghostComponent n (g x)) :\n    ‚àÄ (R : Type u) [_Rcr : CommRing R] (x : ùïé R), f x = g x := by\n  obtain ‚ü®œÜ, hf‚ü© := hf\n  obtain ‚ü®œà, hg‚ü© := hg\n  intros\n  ext n\n  rw [hf, hg, poly_eq_of_wittPolynomial_bind_eq p œÜ œà]\n  intro k\n  apply MvPolynomial.funext\n  intro x\n  simp only [hom_bind‚ÇÅ]\n  specialize h (ULift ‚Ñ§) (mk p fun i => ‚ü®x i‚ü©) k\n  simp only [ghostComponent_apply, aeval_eq_eval‚ÇÇHom] at h\n  apply (ULift.ringEquiv.symm : ‚Ñ§ ‚âÉ+* _).injective\n  simp only [‚Üê RingEquiv.coe_toRingHom, map_eval‚ÇÇHom]\n  convert h using 1\n  all_goals\n    simp only [hf, hg, MvPolynomial.eval, map_eval‚ÇÇHom]\n    apply eval‚ÇÇHom_congr (RingHom.ext_int _ _) _ rfl\n    ext1\n    apply eval‚ÇÇHom_congr (RingHom.ext_int _ _) _ rfl\n    simp only [coeff_mk]; rfl\n\n"}
{"name":"WittVector.IsPoly.comp","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\ng f : ‚¶ÉR : Type u_2‚¶Ñ ‚Üí [inst : CommRing R] ‚Üí WittVector p R ‚Üí WittVector p R\nhg : WittVector.IsPoly p g\nhf : WittVector.IsPoly p f\n‚ä¢ WittVector.IsPoly p fun R _Rcr => Function.comp g f","decl":"/-- The composition of polynomial functions is polynomial. -/\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10754): made this an instance\ninstance comp {g f} [hg : IsPoly p g] [hf : IsPoly p f] :\n    IsPoly p fun R _Rcr => @g R _Rcr ‚àò @f R _Rcr := by\n  obtain ‚ü®œÜ, hf‚ü© := hf\n  obtain ‚ü®œà, hg‚ü© := hg\n  use fun n => bind‚ÇÅ œÜ (œà n)\n  intros\n  simp only [aeval_bind‚ÇÅ, Function.comp, hg, hf]\n\n"}
{"name":"WittVector.IsPoly‚ÇÇ.poly","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\nf : ‚¶ÉR : Type u_2‚¶Ñ ‚Üí [inst : CommRing R] ‚Üí WittVector p R ‚Üí WittVector p R ‚Üí WittVector p R\nself : WittVector.IsPoly‚ÇÇ p f\n‚ä¢ Exists fun œÜ => ‚àÄ ‚¶ÉR : Type u_2‚¶Ñ [inst : CommRing R] (x y : WittVector p R), Eq (f x y).coeff fun n => WittVector.peval (œÜ n) (Matrix.vecCons x.coeff (Matrix.vecCons y.coeff Matrix.vecEmpty))","decl":"/-- A binary function `f : Œ† R, ùïé R ‚Üí ùïé R ‚Üí ùïé R` on Witt vectors\nis said to be *polynomial* if there is a family of polynomials `œÜ‚Çô` over `‚Ñ§` such that the `n`th\ncoefficient of `f x y` is given by evaluating `œÜ‚Çô` at the coefficients of `x` and `y`.\n\nSee also `WittVector.IsPoly` for the unary variant.\n\nThe `ghost_calc` tactic makes use of the `IsPoly` and `IsPoly‚ÇÇ` typeclass and its instances.\n(In Lean 3, there was an `@[is_poly]` attribute to manage these instances,\nbecause typeclass resolution did not play well with function composition.\nThis no longer seems to be an issue, so that such instances can be defined directly.)\n-/\nclass IsPoly‚ÇÇ (f : ‚àÄ ‚¶ÉR‚¶Ñ [CommRing R], WittVector p R ‚Üí ùïé R ‚Üí ùïé R) : Prop where mk' ::\n  poly :\n    ‚àÉ œÜ : ‚Ñï ‚Üí MvPolynomial (Fin 2 √ó ‚Ñï) ‚Ñ§,\n      ‚àÄ ‚¶ÉR‚¶Ñ [CommRing R] (x y : ùïé R), (f x y).coeff = fun n => peval (œÜ n) ![x.coeff, y.coeff]\n\n"}
{"name":"WittVector.IsPoly‚ÇÇ.comp","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\nh : ‚¶ÉR : Type u_2‚¶Ñ ‚Üí [inst : CommRing R] ‚Üí WittVector p R ‚Üí WittVector p R ‚Üí WittVector p R\nf g : ‚¶ÉR : Type u_2‚¶Ñ ‚Üí [inst : CommRing R] ‚Üí WittVector p R ‚Üí WittVector p R\nhh : WittVector.IsPoly‚ÇÇ p h\nhf : WittVector.IsPoly p f\nhg : WittVector.IsPoly p g\n‚ä¢ WittVector.IsPoly‚ÇÇ p fun x _Rcr x_1 y => h (f x_1) (g y)","decl":"/-- The composition of polynomial functions is polynomial. -/\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10754): made this an instance\ninstance IsPoly‚ÇÇ.comp {h f g} [hh : IsPoly‚ÇÇ p h] [hf : IsPoly p f] [hg : IsPoly p g] :\n    IsPoly‚ÇÇ p fun _ _Rcr x y => h (f x) (g y) := by\n  obtain ‚ü®œÜ, hf‚ü© := hf\n  obtain ‚ü®œà, hg‚ü© := hg\n  obtain ‚ü®œá, hh‚ü© := hh\n  refine ‚ü®‚ü®fun n ‚Ü¶ bind‚ÇÅ (uncurry <|\n    ![fun k ‚Ü¶ rename (Prod.mk (0 : Fin 2)) (œÜ k),\n      fun k ‚Ü¶ rename (Prod.mk (1 : Fin 2)) (œà k)]) (œá n), ?_‚ü©‚ü©\n  intros\n  funext n\n  simp (config := { unfoldPartialApp := true }) only [peval, aeval_bind‚ÇÅ, Function.comp, hh, hf, hg,\n    uncurry]\n  apply eval‚ÇÇHom_congr rfl _ rfl\n  ext ‚ü®i, n‚ü©\n  fin_cases i <;> simp [aeval_eq_eval‚ÇÇHom, eval‚ÇÇHom_rename, Function.comp_def]\n\n"}
{"name":"WittVector.IsPoly.comp‚ÇÇ","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\ng : ‚¶ÉR : Type u_2‚¶Ñ ‚Üí [inst : CommRing R] ‚Üí WittVector p R ‚Üí WittVector p R\nf : ‚¶ÉR : Type u_2‚¶Ñ ‚Üí [inst : CommRing R] ‚Üí WittVector p R ‚Üí WittVector p R ‚Üí WittVector p R\nhg : WittVector.IsPoly p g\nhf : WittVector.IsPoly‚ÇÇ p f\n‚ä¢ WittVector.IsPoly‚ÇÇ p fun x _Rcr x_1 y => g (f x_1 y)","decl":"/-- The composition of a polynomial function with a binary polynomial function is polynomial. -/\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10754): made this an instance\ninstance IsPoly.comp‚ÇÇ {g f} [hg : IsPoly p g] [hf : IsPoly‚ÇÇ p f] :\n    IsPoly‚ÇÇ p fun _ _Rcr x y => g (f x y) := by\n  obtain ‚ü®œÜ, hf‚ü© := hf\n  obtain ‚ü®œà, hg‚ü© := hg\n  use fun n => bind‚ÇÅ œÜ (œà n)\n  intros\n  simp only [peval, aeval_bind‚ÇÅ, Function.comp, hg, hf]\n\n"}
{"name":"WittVector.IsPoly‚ÇÇ.diag","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\nf : ‚¶ÉR : Type u_2‚¶Ñ ‚Üí [inst : CommRing R] ‚Üí WittVector p R ‚Üí WittVector p R ‚Üí WittVector p R\nhf : WittVector.IsPoly‚ÇÇ p f\n‚ä¢ WittVector.IsPoly p fun x _Rcr x_1 => f x_1 x_1","decl":"/-- The diagonal `fun x ‚Ü¶ f x x` of a polynomial function `f` is polynomial. -/\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10754): made this an instance\ninstance IsPoly‚ÇÇ.diag {f} [hf : IsPoly‚ÇÇ p f] : IsPoly p fun _ _Rcr x => f x x := by\n  obtain ‚ü®œÜ, hf‚ü© := hf\n  refine ‚ü®‚ü®fun n => bind‚ÇÅ (uncurry ![X, X]) (œÜ n), ?_‚ü©‚ü©\n  intros; funext n\n  simp (config := { unfoldPartialApp := true }) only [hf, peval, uncurry, aeval_bind‚ÇÅ]\n  apply eval‚ÇÇHom_congr rfl _ rfl\n  ext ‚ü®i, k‚ü©\n  fin_cases i <;> simp\n\n-- Porting note: Lean 4's typeclass inference is sufficiently more powerful that we no longer\n-- need the `@[is_poly]` attribute. Use of the attribute should just be replaced by changing the\n-- theorem to an `instance`.\n\n"}
{"name":"WittVector.negIsPoly","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\ninst‚úù : Fact (Nat.Prime p)\n‚ä¢ WittVector.IsPoly p fun R x => Neg.neg","decl":"/-- The additive negation is a polynomial function on Witt vectors. -/\n-- Porting note: replaced `@[is_poly]` with `instance`.\ninstance negIsPoly [Fact p.Prime] : IsPoly p fun R _ => @Neg.neg (ùïé R) _ :=\n  ‚ü®‚ü®fun n => rename Prod.snd (wittNeg p n), by\n      intros; funext n\n      rw [neg_coeff, aeval_eq_eval‚ÇÇHom, eval‚ÇÇHom_rename]\n      apply eval‚ÇÇHom_congr rfl _ rfl\n      ext ‚ü®i, k‚ü©; fin_cases i; rfl‚ü©‚ü©\n\n"}
{"name":"WittVector.zeroIsPoly","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\ninst‚úù : Fact (Nat.Prime p)\n‚ä¢ WittVector.IsPoly p fun x x_1 x_2 => 0","decl":"/-- The function that is constantly zero on Witt vectors is a polynomial function. -/\ninstance zeroIsPoly [Fact p.Prime] : IsPoly p fun _ _ _ => 0 :=\n  ‚ü®‚ü®0, by intros; funext n; simp only [Pi.zero_apply, map_zero, zero_coeff]‚ü©‚ü©\n\n"}
{"name":"WittVector.bind‚ÇÅ_zero_wittPolynomial","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\nR : Type u\ninst‚úù¬π : CommRing R\ninst‚úù : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq ((MvPolynomial.bind‚ÇÅ 0) (wittPolynomial p R n)) 0","decl":"@[simp]\ntheorem bind‚ÇÅ_zero_wittPolynomial [Fact p.Prime] (n : ‚Ñï) :\n    bind‚ÇÅ (0 : ‚Ñï ‚Üí MvPolynomial ‚Ñï R) (wittPolynomial p R n) = 0 := by\n  rw [‚Üê aeval_eq_bind‚ÇÅ, aeval_zero, constantCoeff_wittPolynomial, RingHom.map_zero]\n\n"}
{"name":"WittVector.bind‚ÇÅ_onePoly_wittPolynomial","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq ((MvPolynomial.bind‚ÇÅ WittVector.onePoly) (wittPolynomial p Int n)) 1","decl":"@[simp]\ntheorem bind‚ÇÅ_onePoly_wittPolynomial [hp : Fact p.Prime] (n : ‚Ñï) :\n    bind‚ÇÅ onePoly (wittPolynomial p ‚Ñ§ n) = 1 := by\n  rw [wittPolynomial_eq_sum_C_mul_X_pow, map_sum, Finset.sum_eq_single 0]\n  ¬∑ simp only [onePoly, one_pow, one_mul, map_pow, C_1, pow_zero, bind‚ÇÅ_X_right, if_true,\n      eq_self_iff_true]\n  ¬∑ intro i _hi hi0\n    simp only [onePoly, if_neg hi0, zero_pow (pow_ne_zero _ hp.1.ne_zero), mul_zero, map_pow,\n      bind‚ÇÅ_X_right, map_mul]\n  ¬∑ simp\n\n"}
{"name":"WittVector.oneIsPoly","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\ninst‚úù : Fact (Nat.Prime p)\n‚ä¢ WittVector.IsPoly p fun x x_1 x_2 => 1","decl":"/-- The function that is constantly one on Witt vectors is a polynomial function. -/\ninstance oneIsPoly [Fact p.Prime] : IsPoly p fun _ _ _ => 1 :=\n  ‚ü®‚ü®onePoly, by\n      intros; funext n; cases n\n      ¬∑ simp only [lt_self_iff_false, one_coeff_zero, onePoly, ite_true, map_one]\n      ¬∑ simp only [Nat.succ_pos', one_coeff_eq_of_pos, onePoly, Nat.succ_ne_zero, ite_false,\n          map_zero]\n  ‚ü©‚ü©\n\n"}
{"name":"WittVector.addIsPoly‚ÇÇ","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\ninst‚úù : Fact (Nat.Prime p)\n‚ä¢ WittVector.IsPoly‚ÇÇ p fun x x_1 x1 x2 => HAdd.hAdd x1 x2","decl":"/-- Addition of Witt vectors is a polynomial function. -/\n-- Porting note: replaced `@[is_poly]` with `instance`.\ninstance addIsPoly‚ÇÇ [Fact p.Prime] : IsPoly‚ÇÇ p fun _ _ => (¬∑ + ¬∑) :=\n  ‚ü®‚ü®wittAdd p, by intros; ext; exact add_coeff _ _ _‚ü©‚ü©\n\n"}
{"name":"WittVector.mulIsPoly‚ÇÇ","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\ninst‚úù : Fact (Nat.Prime p)\n‚ä¢ WittVector.IsPoly‚ÇÇ p fun x x_1 x1 x2 => HMul.hMul x1 x2","decl":"/-- Multiplication of Witt vectors is a polynomial function. -/\n-- Porting note: replaced `@[is_poly]` with `instance`.\ninstance mulIsPoly‚ÇÇ [Fact p.Prime] : IsPoly‚ÇÇ p fun _ _ => (¬∑ * ¬∑) :=\n  ‚ü®‚ü®wittMul p, by intros; ext; exact mul_coeff _ _ _‚ü©‚ü©\n\n-- unfortunately this is not universe polymorphic, merely because `f` isn't\n"}
{"name":"WittVector.IsPoly.map","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\nR S : Type u\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : CommRing S\ninst‚úù : Fact (Nat.Prime p)\nf : ‚¶ÉR : Type u‚¶Ñ ‚Üí [inst : CommRing R] ‚Üí WittVector p R ‚Üí WittVector p R\nhf : WittVector.IsPoly p f\ng : RingHom R S\nx : WittVector p R\n‚ä¢ Eq ((WittVector.map g) (f x)) (f ((WittVector.map g) x))","decl":"theorem IsPoly.map [Fact p.Prime] {f} (hf : IsPoly p f) (g : R ‚Üí+* S) (x : ùïé R) :\n    map g (f x) = f (map g x) := by\n  -- this could be turned into a tactic ‚Äúmacro‚Äù (taking `hf` as parameter)\n  -- so that applications do not have to worry about the universe issue\n  -- see `IsPoly‚ÇÇ.map` for a slightly more general proof strategy\n  obtain ‚ü®œÜ, hf‚ü© := hf\n  ext n\n  simp only [map_coeff, hf, map_aeval]\n  apply eval‚ÇÇHom_congr (RingHom.ext_int _ _) _ rfl\n  ext  -- Porting note: this `ext` was not present in the mathport output\n  simp only [map_coeff]\n\n"}
{"name":"WittVector.IsPoly‚ÇÇ.ext","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\ninst‚úù : Fact (Nat.Prime p)\nf g : ‚¶ÉR : Type u‚¶Ñ ‚Üí [inst : CommRing R] ‚Üí WittVector p R ‚Üí WittVector p R ‚Üí WittVector p R\nhf : WittVector.IsPoly‚ÇÇ p f\nhg : WittVector.IsPoly‚ÇÇ p g\nh : ‚àÄ (R : Type u) [_Rcr : CommRing R] (x y : WittVector p R) (n : Nat), Eq ((WittVector.ghostComponent n) (f x y)) ((WittVector.ghostComponent n) (g x y))\nR : Type u\n_Rcr : CommRing R\nx y : WittVector p R\n‚ä¢ Eq (f x y) (g x y)","decl":"theorem ext [Fact p.Prime] {f g} (hf : IsPoly‚ÇÇ p f) (hg : IsPoly‚ÇÇ p g)\n    (h : ‚àÄ (R : Type u) [_Rcr : CommRing R] (x y : ùïé R) (n : ‚Ñï),\n        ghostComponent n (f x y) = ghostComponent n (g x y)) :\n    ‚àÄ (R) [_Rcr : CommRing R] (x y : ùïé R), f x y = g x y := by\n  obtain ‚ü®œÜ, hf‚ü© := hf\n  obtain ‚ü®œà, hg‚ü© := hg\n  intros\n  ext n\n  rw [hf, hg, poly_eq_of_wittPolynomial_bind_eq' p œÜ œà]\n  intro k\n  apply MvPolynomial.funext\n  intro x\n  simp only [hom_bind‚ÇÅ]\n  specialize h (ULift ‚Ñ§) (mk p fun i => ‚ü®x (0, i)‚ü©) (mk p fun i => ‚ü®x (1, i)‚ü©) k\n  simp only [ghostComponent_apply, aeval_eq_eval‚ÇÇHom] at h\n  apply (ULift.ringEquiv.symm : ‚Ñ§ ‚âÉ+* _).injective\n  simp only [‚Üê RingEquiv.coe_toRingHom, map_eval‚ÇÇHom]\n  convert h using 1\n  all_goals\n    simp only [hf, hg, MvPolynomial.eval, map_eval‚ÇÇHom]\n    apply eval‚ÇÇHom_congr (RingHom.ext_int _ _) _ rfl\n    ext1\n    apply eval‚ÇÇHom_congr (RingHom.ext_int _ _) _ rfl\n    ext ‚ü®b, _‚ü©\n    fin_cases b <;> simp only [coeff_mk, uncurry] <;> rfl\n\n-- unfortunately this is not universe polymorphic, merely because `f` isn't\n"}
{"name":"WittVector.IsPoly‚ÇÇ.map","module":"Mathlib.RingTheory.WittVector.IsPoly","initialProofState":"p : Nat\nR S : Type u\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : CommRing S\ninst‚úù : Fact (Nat.Prime p)\nf : ‚¶ÉR : Type u‚¶Ñ ‚Üí [inst : CommRing R] ‚Üí WittVector p R ‚Üí WittVector p R ‚Üí WittVector p R\nhf : WittVector.IsPoly‚ÇÇ p f\ng : RingHom R S\nx y : WittVector p R\n‚ä¢ Eq ((WittVector.map g) (f x y)) (f ((WittVector.map g) x) ((WittVector.map g) y))","decl":"theorem map [Fact p.Prime] {f} (hf : IsPoly‚ÇÇ p f) (g : R ‚Üí+* S) (x y : ùïé R) :\n    map g (f x y) = f (map g x) (map g y) := by\n  -- this could be turned into a tactic ‚Äúmacro‚Äù (taking `hf` as parameter)\n  -- so that applications do not have to worry about the universe issue\n  obtain ‚ü®œÜ, hf‚ü© := hf\n  ext n\n  simp (config := { unfoldPartialApp := true }) only [map_coeff, hf, map_aeval, peval, uncurry]\n  apply eval‚ÇÇHom_congr (RingHom.ext_int _ _) _ rfl\n  ext ‚ü®i, k‚ü©\n  fin_cases i <;> simp\n\n"}
