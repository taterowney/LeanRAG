{"name":"Equiv.Perm.OnCycleFactors.Subgroup.Centralizer.toConjAct_smul_mem_cycleFactorsFinset","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng k c : Equiv.Perm α\nk_mem : Membership.mem (Subgroup.centralizer (Singleton.singleton g)) k\nc_mem : Membership.mem g.cycleFactorsFinset c\n⊢ Membership.mem g.cycleFactorsFinset (HSMul.hSMul (ConjAct.toConjAct k) c)","decl":"variable {g} in\nlemma Subgroup.Centralizer.toConjAct_smul_mem_cycleFactorsFinset {k c : Perm α}\n    (k_mem : k ∈ centralizer {g}) (c_mem : c ∈ g.cycleFactorsFinset) :\n    ConjAct.toConjAct k • c ∈ g.cycleFactorsFinset := by\n  suffices (g.cycleFactorsFinset : Set (Perm α)) =\n    (ConjAct.toConjAct k) • g.cycleFactorsFinset by\n    rw [← Finset.mem_coe, this]\n    simp only [Set.smul_mem_smul_set_iff, Finset.mem_coe, Finset.coe_mem, c_mem]\n  have this := cycleFactorsFinset_conj_eq (ConjAct.toConjAct (k : Perm α)) g\n  rw [ConjAct.toConjAct_smul, mem_centralizer_singleton_iff.mp k_mem, mul_assoc] at this\n  simp only [mul_inv_cancel, mul_one] at this\n  conv_lhs => rw [this]\n  simp only [Finset.coe_smul_finset]\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.centralizer_smul_def","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nk : Subtype fun x => Membership.mem (Subgroup.centralizer (Singleton.singleton g)) x\nc : Subtype fun x => Membership.mem g.cycleFactorsFinset x\n⊢ Eq (HSMul.hSMul k c) ⟨HMul.hMul (HMul.hMul ↑k ↑c) ↑(Inv.inv k), ⋯⟩","decl":"theorem centralizer_smul_def (k : centralizer {g}) (c : g.cycleFactorsFinset) :\n    k • c = ⟨k * c * k⁻¹,\n      Subgroup.Centralizer.toConjAct_smul_mem_cycleFactorsFinset k.prop c.prop⟩ :=\n  rfl\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.val_centralizer_smul","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nk : Subtype fun x => Membership.mem (Subgroup.centralizer (Singleton.singleton g)) x\nc : Subtype fun x => Membership.mem g.cycleFactorsFinset x\n⊢ Eq (↑(HSMul.hSMul k c)) (HMul.hMul (HMul.hMul ↑k ↑c) ↑(Inv.inv k))","decl":"@[simp]\ntheorem val_centralizer_smul (k : Subgroup.centralizer {g}) (c : g.cycleFactorsFinset) :\n    ((k • c :) : Perm α) = k * c * k⁻¹ :=\n  rfl\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.toPermHom_apply","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nk : Subtype fun x => Membership.mem (Subgroup.centralizer (Singleton.singleton g)) x\nc : Subtype fun x => Membership.mem g.cycleFactorsFinset x\n⊢ Eq (((Equiv.Perm.OnCycleFactors.toPermHom g) k) c) (HSMul.hSMul k c)","decl":"theorem toPermHom_apply (k : centralizer {g}) (c : g.cycleFactorsFinset) :\n    (toPermHom g k c) = k • c := rfl\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.coe_toPermHom","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nk : Subtype fun x => Membership.mem (Subgroup.centralizer (Singleton.singleton g)) x\nc : Subtype fun x => Membership.mem g.cycleFactorsFinset x\n⊢ Eq (↑(((Equiv.Perm.OnCycleFactors.toPermHom g) k) c)) (HMul.hMul (HMul.hMul ↑k ↑c) (Inv.inv ↑k))","decl":"theorem coe_toPermHom (k : centralizer {g}) (c : g.cycleFactorsFinset) :\n    (toPermHom g k c : Perm α) = k * c * (k : Perm α)⁻¹ := rfl\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.mem_range_toPermHom'_iff","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nτ : Equiv.Perm (Subtype fun x => Membership.mem g.cycleFactorsFinset x)\n⊢ Iff (Membership.mem (Equiv.Perm.OnCycleFactors.range_toPermHom' g) τ) (∀ (c : Subtype fun x => Membership.mem g.cycleFactorsFinset x), Eq (↑(τ c)).support.card (↑c).support.card)","decl":"variable {g} in\ntheorem mem_range_toPermHom'_iff {τ : Perm g.cycleFactorsFinset} :\n    τ ∈ range_toPermHom' g ↔\n      ∀ c, (τ c : Perm α).support.card = (c : Perm α).support.card :=\n  Iff.rfl\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.mem_ker_toPermHom_iff","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nk : Subtype fun x => Membership.mem (Subgroup.centralizer (Singleton.singleton g)) x\n⊢ Iff (Membership.mem (Equiv.Perm.OnCycleFactors.toPermHom g).ker k) (∀ (c : Equiv.Perm α), Membership.mem g.cycleFactorsFinset c → Commute (↑k) c)","decl":"/-- `k : Subgroup.centralizer {g}` belongs to the kernel of `toPermHom g`\n  iff it commutes with each cycle of `g` -/\ntheorem mem_ker_toPermHom_iff :\n    k ∈ (toPermHom g).ker ↔ ∀ c ∈ g.cycleFactorsFinset, Commute (k : Perm α) c := by\n  simp only [toPermHom, MonoidHom.mem_ker, DFunLike.ext_iff, Subtype.forall]\n  refine forall₂_congr (fun _ _ ↦ ?_)\n  simp [← Subtype.coe_inj, commute_iff_eq, mul_inv_eq_iff_eq_mul]\n\n"}
{"name":"Equiv.Perm.Basis.mk.sizeOf_spec","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\ng : Equiv.Perm α\ninst✝ : SizeOf α\ntoFun : (Subtype fun x => Membership.mem g.cycleFactorsFinset x) → α\nmem_support_self' : ∀ (c : Subtype fun x => Membership.mem g.cycleFactorsFinset x), Membership.mem (↑c).support (toFun c)\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, mem_support_self' := mem_support_self' }) 1","decl":"/-- A `Basis` of a permutation is a choice of an element in each of its cycles -/\nstructure Basis (g : Equiv.Perm α) where\n  /-- A choice of elements in each cycle -/\n  (toFun : g.cycleFactorsFinset → α)\n  /-- For each cycle, the chosen element belongs to the cycle -/\n  (mem_support_self' : ∀ (c : g.cycleFactorsFinset), toFun c ∈ (c : Perm α).support)\n\n"}
{"name":"Equiv.Perm.Basis.mem_support_self'","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nself : g.Basis\nc : Subtype fun x => Membership.mem g.cycleFactorsFinset x\n⊢ Membership.mem (↑c).support (self.toFun c)","decl":"/-- A `Basis` of a permutation is a choice of an element in each of its cycles -/\nstructure Basis (g : Equiv.Perm α) where\n  /-- A choice of elements in each cycle -/\n  (toFun : g.cycleFactorsFinset → α)\n  /-- For each cycle, the chosen element belongs to the cycle -/\n  (mem_support_self' : ∀ (c : g.cycleFactorsFinset), toFun c ∈ (c : Perm α).support)\n\n"}
{"name":"Equiv.Perm.Basis.mk.injEq","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\ntoFun✝ : (Subtype fun x => Membership.mem g.cycleFactorsFinset x) → α\nmem_support_self'✝ : ∀ (c : Subtype fun x => Membership.mem g.cycleFactorsFinset x), Membership.mem (↑c).support (toFun✝ c)\ntoFun : (Subtype fun x => Membership.mem g.cycleFactorsFinset x) → α\nmem_support_self' : ∀ (c : Subtype fun x => Membership.mem g.cycleFactorsFinset x), Membership.mem (↑c).support (toFun c)\n⊢ Eq (Eq { toFun := toFun✝, mem_support_self' := mem_support_self'✝ } { toFun := toFun, mem_support_self' := mem_support_self' }) (Eq toFun✝ toFun)","decl":"/-- A `Basis` of a permutation is a choice of an element in each of its cycles -/\nstructure Basis (g : Equiv.Perm α) where\n  /-- A choice of elements in each cycle -/\n  (toFun : g.cycleFactorsFinset → α)\n  /-- For each cycle, the chosen element belongs to the cycle -/\n  (mem_support_self' : ∀ (c : g.cycleFactorsFinset), toFun c ∈ (c : Perm α).support)\n\n"}
{"name":"Equiv.Perm.Basis.mk.inj","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\ntoFun✝ : (Subtype fun x => Membership.mem g.cycleFactorsFinset x) → α\nmem_support_self'✝ : ∀ (c : Subtype fun x => Membership.mem g.cycleFactorsFinset x), Membership.mem (↑c).support (toFun✝ c)\ntoFun : (Subtype fun x => Membership.mem g.cycleFactorsFinset x) → α\nmem_support_self' : ∀ (c : Subtype fun x => Membership.mem g.cycleFactorsFinset x), Membership.mem (↑c).support (toFun c)\nx✝ : Eq { toFun := toFun✝, mem_support_self' := mem_support_self'✝ } { toFun := toFun, mem_support_self' := mem_support_self' }\n⊢ Eq toFun✝ toFun","decl":"/-- A `Basis` of a permutation is a choice of an element in each of its cycles -/\nstructure Basis (g : Equiv.Perm α) where\n  /-- A choice of elements in each cycle -/\n  (toFun : g.cycleFactorsFinset → α)\n  /-- For each cycle, the chosen element belongs to the cycle -/\n  (mem_support_self' : ∀ (c : g.cycleFactorsFinset), toFun c ∈ (c : Perm α).support)\n\n"}
{"name":"Equiv.Perm.Basis.nonempty","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\n⊢ Nonempty g.Basis","decl":"theorem nonempty (g : Perm α) : Nonempty (Basis g) := by\n  have (c : g.cycleFactorsFinset) : (c : Perm α).support.Nonempty :=\n    IsCycle.nonempty_support (mem_cycleFactorsFinset_iff.mp c.prop).1\n  exact ⟨fun c ↦ (this c).choose, fun c ↦ (this c).choose_spec⟩\n\n"}
{"name":"Equiv.Perm.Basis.mem_support_self","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nc : Subtype fun x => Membership.mem g.cycleFactorsFinset x\n⊢ Membership.mem (↑c).support (a c)","decl":"theorem mem_support_self :\n    a c ∈ (c : Perm α).support := a.mem_support_self' c\n\n"}
{"name":"Equiv.Perm.Basis.injective","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\n⊢ Function.Injective ⇑a","decl":"theorem injective : Function.Injective a := by\n  intro c d h\n  rw [← Subtype.coe_inj]\n  apply g.cycleFactorsFinset_pairwise_disjoint.eq c.prop d.prop\n  simp only [Disjoint, not_forall, not_or]\n  use a c\n  conv_rhs => rw [h]\n  simp only [← Perm.mem_support, a.mem_support_self c, a.mem_support_self d, and_self]\n\n"}
{"name":"Equiv.Perm.Basis.cycleOf_eq","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nc : Subtype fun x => Membership.mem g.cycleFactorsFinset x\n⊢ Eq (g.cycleOf (a c)) ↑c","decl":"theorem cycleOf_eq : g.cycleOf (a c) = c :=\n  (cycle_is_cycleOf (a.mem_support_self c) c.prop).symm\n\n"}
{"name":"Equiv.Perm.Basis.sameCycle","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nx : α\nhx : Membership.mem g.cycleFactorsFinset (g.cycleOf x)\n⊢ g.SameCycle (a ⟨g.cycleOf x, hx⟩) x","decl":"theorem sameCycle {x : α} (hx : g.cycleOf x ∈ g.cycleFactorsFinset) :\n    g.SameCycle (a ⟨g.cycleOf x, hx⟩) x :=\n  (mem_support_cycleOf_iff.mp (a.mem_support_self ⟨g.cycleOf x, hx⟩)).1.symm\n\n"}
{"name":"Equiv.Perm.Basis.mem_fixedPoints_or_exists_zpow_eq","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nx : α\n⊢ Or (Membership.mem (Function.fixedPoints ⇑g) x) (Exists fun c => Exists fun x_1 => Exists fun m => Eq ((HPow.hPow g m) (a c)) x)","decl":"theorem mem_fixedPoints_or_exists_zpow_eq (x : α) :\n    x ∈ Function.fixedPoints g ∨\n      ∃ (c : g.cycleFactorsFinset) (_ : x ∈ (c : Perm α).support) (m : ℤ), (g ^ m) (a c) = x := by\n  rw [Classical.or_iff_not_imp_left]\n  intro hx\n  rw [Function.mem_fixedPoints_iff, ← ne_eq, ← mem_support,\n    ← cycleOf_mem_cycleFactorsFinset_iff] at hx\n  refine ⟨⟨g.cycleOf x, hx⟩, ?_, (a.sameCycle hx)⟩\n  rw [mem_support_cycleOf_iff, ← cycleOf_mem_cycleFactorsFinset_iff]\n  simp [SameCycle.rfl, hx, and_self]\n\n"}
{"name":"Equiv.Perm.Basis.ofPermHomFun_apply_of_cycleOf_mem","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nτ : Subtype fun x => Membership.mem (Equiv.Perm.OnCycleFactors.range_toPermHom' g) x\nx : α\nc : Subtype fun x => Membership.mem g.cycleFactorsFinset x\nhx : Membership.mem (↑c).support x\nm : Int\nhm : Eq ((HPow.hPow g m) (a c)) x\n⊢ Eq (a.ofPermHomFun τ x) ((HPow.hPow g m) (a (↑τ c)))","decl":"theorem ofPermHomFun_apply_of_cycleOf_mem {x : α} {c : g.cycleFactorsFinset}\n    (hx : x ∈ (c : Perm α).support) {m : ℤ} (hm : (g ^ m) (a c) = x) :\n    ofPermHomFun a τ x = (g ^ m) (a ((τ : Perm g.cycleFactorsFinset) c)) := by\n  have hx' : c = g.cycleOf x := cycle_is_cycleOf hx (Subtype.prop c)\n  have hx'' : g.cycleOf x ∈ g.cycleFactorsFinset := hx' ▸ c.prop\n  set n := Nat.find (a.sameCycle hx'').exists_nat_pow_eq\n  have hn : (g ^ (n : ℤ)) (a c) = x := by\n    rw [← Nat.find_spec (a.sameCycle hx'').exists_nat_pow_eq, zpow_natCast]\n    congr\n    rw [← Subtype.coe_inj, hx']\n  suffices ofPermHomFun a τ x = (g ^ (n : ℤ)) (a ((τ : Perm g.cycleFactorsFinset) c)) by\n    rw [this, IsCycleOn.zpow_apply_eq_zpow_apply\n      (isCycleOn_support_of_mem_cycleFactorsFinset ((τ : Perm g.cycleFactorsFinset) c).prop)\n      (mem_support_self a ((τ : Perm g.cycleFactorsFinset) c))]\n    simp only [τ.prop c]\n    rw [← IsCycleOn.zpow_apply_eq_zpow_apply\n      (isCycleOn_support_of_mem_cycleFactorsFinset c.prop) (mem_support_self a c)]\n    rw [hn, hm]\n  simp only [ofPermHomFun, dif_pos hx'']\n  congr\n  exact hx'.symm\n\n"}
{"name":"Equiv.Perm.Basis.ofPermHomFun_apply_of_mem_fixedPoints","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nτ : Subtype fun x => Membership.mem (Equiv.Perm.OnCycleFactors.range_toPermHom' g) x\nx : α\nhx : Membership.mem (Function.fixedPoints ⇑g) x\n⊢ Eq (a.ofPermHomFun τ x) x","decl":"theorem ofPermHomFun_apply_of_mem_fixedPoints {x : α} (hx : x ∈ Function.fixedPoints g) :\n    ofPermHomFun a τ x = x := by\n  rw [ofPermHomFun, dif_neg]\n  rw [cycleOf_mem_cycleFactorsFinset_iff, not_mem_support]\n  exact hx\n\n"}
{"name":"Equiv.Perm.Basis.ofPermHomFun_apply_mem_support_cycle_iff","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nτ : Subtype fun x => Membership.mem (Equiv.Perm.OnCycleFactors.range_toPermHom' g) x\nx : α\nc : Subtype fun x => Membership.mem g.cycleFactorsFinset x\n⊢ Iff (Membership.mem (↑(↑τ c)).support (a.ofPermHomFun τ x)) (Membership.mem (↑c).support x)","decl":"theorem ofPermHomFun_apply_mem_support_cycle_iff {x : α} {c : g.cycleFactorsFinset} :\n    ofPermHomFun a τ x ∈ ((τ : Perm g.cycleFactorsFinset) c : Perm α).support ↔\n      x ∈ (c : Perm α).support := by\n  rcases mem_fixedPoints_or_exists_zpow_eq a x with (hx | ⟨d, hd, m, hm⟩)\n  · simp only [ofPermHomFun_apply_of_mem_fixedPoints a τ hx]\n    suffices ∀ (d : g.cycleFactorsFinset), x ∉ (d : Perm α).support by\n      simp only [this]\n    intro d hx'\n    rw [Function.mem_fixedPoints_iff, ← not_mem_support] at hx\n    apply hx\n    exact mem_cycleFactorsFinset_support_le d.prop hx'\n  · rw [ofPermHomFun_apply_of_cycleOf_mem a τ hd hm] --\n    rw [zpow_apply_mem_support_of_mem_cycleFactorsFinset_iff]\n    by_cases h : c = d\n    · simp only [h, hd, iff_true, mem_support_self]\n    · have H : Disjoint (c : Perm α) (d : Perm α) :=\n        cycleFactorsFinset_pairwise_disjoint g c.prop d.prop (Subtype.coe_ne_coe.mpr h)\n      have H' : Disjoint ((τ : Perm g.cycleFactorsFinset) c : Perm α)\n        ((τ : Perm g.cycleFactorsFinset) d : Perm α) :=\n        cycleFactorsFinset_pairwise_disjoint g ((τ : Perm g.cycleFactorsFinset) c).prop\n          ((τ : Perm g.cycleFactorsFinset) d).prop (by\n          intro h'; apply h\n          simpa only [Subtype.coe_inj, EmbeddingLike.apply_eq_iff_eq] using h')\n      rw [disjoint_iff_disjoint_support, Finset.disjoint_right] at H H'\n      simp only [H hd, H' (mem_support_self a _)]\n\n"}
{"name":"Equiv.Perm.Basis.ofPermHomFun_commute_zpow_apply","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nτ : Subtype fun x => Membership.mem (Equiv.Perm.OnCycleFactors.range_toPermHom' g) x\nx : α\nj : Int\n⊢ Eq (a.ofPermHomFun τ ((HPow.hPow g j) x)) ((HPow.hPow g j) (a.ofPermHomFun τ x))","decl":"theorem ofPermHomFun_commute_zpow_apply (x : α) (j : ℤ) :\n    ofPermHomFun a τ ((g ^ j) x) = (g ^ j) (ofPermHomFun a τ x) := by\n  rcases mem_fixedPoints_or_exists_zpow_eq a x with (hx | hx)\n  · rw [ofPermHomFun_apply_of_mem_fixedPoints a τ hx, ofPermHomFun_apply_of_mem_fixedPoints]\n    rw [Function.mem_fixedPoints_iff]\n    simp only [← mul_apply, ← zpow_one_add, add_comm]\n    conv_rhs => rw [← hx, ← mul_apply, ← zpow_add_one]\n  · obtain ⟨c, hc, m, hm⟩ := hx\n    have hm' : (g ^ (j + m)) (a c) = (g ^ j) x := by rw [zpow_add, mul_apply, hm]\n    rw [ofPermHomFun_apply_of_cycleOf_mem a τ hc hm, ofPermHomFun_apply_of_cycleOf_mem a τ _ hm',\n      ← mul_apply, ← zpow_add]\n    exact zpow_apply_mem_support_of_mem_cycleFactorsFinset_iff.mpr hc\n\n"}
{"name":"Equiv.Perm.Basis.ofPermHomFun_mul","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nσ τ : Subtype fun x => Membership.mem (Equiv.Perm.OnCycleFactors.range_toPermHom' g) x\nx : α\n⊢ Eq (a.ofPermHomFun (HMul.hMul σ τ) x) (a.ofPermHomFun σ (a.ofPermHomFun τ x))","decl":"theorem ofPermHomFun_mul (σ τ : range_toPermHom' g) (x) :\n    ofPermHomFun a (σ * τ) x = (ofPermHomFun a σ) (ofPermHomFun a τ x) := by\n  rcases mem_fixedPoints_or_exists_zpow_eq a x with (hx | ⟨c, hc, m, hm⟩)\n  · simp only [ofPermHomFun_apply_of_mem_fixedPoints a _ hx]\n  · simp only [ofPermHomFun_apply_of_cycleOf_mem a _ hc hm]\n    rw [ofPermHomFun_apply_of_cycleOf_mem a _ _ rfl]\n    · rfl\n    · rw [zpow_apply_mem_support_of_mem_cycleFactorsFinset_iff]\n      apply mem_support_self\n\n"}
{"name":"Equiv.Perm.Basis.ofPermHomFun_one","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nx : α\n⊢ Eq (a.ofPermHomFun 1 x) x","decl":"theorem ofPermHomFun_one (x : α) : (ofPermHomFun a 1) x = x := by\n  rcases mem_fixedPoints_or_exists_zpow_eq a x with (hx | ⟨c, hc, m, hm⟩)\n  · rw [ofPermHomFun_apply_of_mem_fixedPoints a _ hx]\n  · rw [ofPermHomFun_apply_of_cycleOf_mem a _ hc hm, OneMemClass.coe_one, coe_one, id_eq, hm]\n\n"}
{"name":"Equiv.Perm.Basis.ofPermHom_mem_centralizer","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nτ : Subtype fun x => Membership.mem (Equiv.Perm.OnCycleFactors.range_toPermHom' g) x\n⊢ Membership.mem (Subgroup.centralizer (Singleton.singleton g)) (a.ofPermHom τ)","decl":"theorem ofPermHom_mem_centralizer :\n    a.ofPermHom τ ∈ centralizer {g} := by\n  rw [mem_centralizer_singleton_iff]\n  ext x\n  simp only [mul_apply]\n  exact ofPermHomFun_commute_zpow_apply a τ x 1\n\n"}
{"name":"Equiv.Perm.Basis.toCentralizer_apply","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nτ : Subtype fun x => Membership.mem (Equiv.Perm.OnCycleFactors.range_toPermHom' g) x\nx : α\n⊢ Eq (↑(a.toCentralizer τ) x) (a.ofPermHomFun τ x)","decl":"theorem toCentralizer_apply (x) : (toCentralizer a τ : Perm α) x = ofPermHomFun a τ x := rfl\n\n"}
{"name":"Equiv.Perm.Basis.toCentralizer_equivariant","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nc : Subtype fun x => Membership.mem g.cycleFactorsFinset x\nτ : Subtype fun x => Membership.mem (Equiv.Perm.OnCycleFactors.range_toPermHom' g) x\n⊢ Eq (HSMul.hSMul (a.toCentralizer τ) c) (↑τ c)","decl":"theorem toCentralizer_equivariant :\n    (toCentralizer a τ) • c = (τ : Perm g.cycleFactorsFinset) c := by\n  simp only [← Subtype.coe_inj, val_centralizer_smul, InvMemClass.coe_inv, mul_inv_eq_iff_eq_mul]\n  ext x\n  simp only [mul_apply, toCentralizer_apply]\n  by_cases hx : x ∈ (c : Perm α).support\n  · rw [(mem_cycleFactorsFinset_iff.mp c.prop).2 x hx]\n    have := ofPermHomFun_commute_zpow_apply a τ x 1\n    simp only [zpow_one] at this\n    rw [this, ← (mem_cycleFactorsFinset_iff.mp ((τ : Perm g.cycleFactorsFinset) c).prop).2]\n    rw [ofPermHomFun_apply_mem_support_cycle_iff]\n    exact hx\n  · rw [not_mem_support.mp hx, eq_comm, ← not_mem_support,\n      ofPermHomFun_apply_mem_support_cycle_iff]\n    exact hx\n\n"}
{"name":"Equiv.Perm.Basis.toPermHom_apply_toCentralizer","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\na : g.Basis\nτ : Subtype fun x => Membership.mem (Equiv.Perm.OnCycleFactors.range_toPermHom' g) x\n⊢ Eq ((Equiv.Perm.OnCycleFactors.toPermHom g) (a.toCentralizer τ)) ↑τ","decl":"theorem toPermHom_apply_toCentralizer :\n    (toPermHom g) (toCentralizer a τ) = (τ : Perm g.cycleFactorsFinset) := by\n  apply ext\n  intro c\n  rw [OnCycleFactors.toPermHom_apply, toCentralizer_equivariant]\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.mem_range_toPermHom_iff","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nτ : Equiv.Perm (Subtype fun x => Membership.mem g.cycleFactorsFinset x)\n⊢ Iff (Membership.mem (Equiv.Perm.OnCycleFactors.toPermHom g).range τ) (∀ (c : Subtype fun x => Membership.mem g.cycleFactorsFinset x), Eq (↑(τ c)).support.card (↑c).support.card)","decl":"theorem mem_range_toPermHom_iff {τ} : τ ∈ (toPermHom g).range ↔\n    ∀ c, (τ c : Perm α).support.card = (c : Perm α).support.card := by\n  constructor\n  · rintro ⟨k, rfl⟩ c\n    rw [coe_toPermHom, Equiv.Perm.support_conj]\n    apply Finset.card_map\n  · obtain ⟨a⟩ := Basis.nonempty g\n    exact fun hτ ↦ ⟨toCentralizer a ⟨τ, hτ⟩, toPermHom_apply_toCentralizer a ⟨τ, hτ⟩⟩\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.mem_range_toPermHom_iff'","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nτ : Equiv.Perm (Subtype fun x => Membership.mem g.cycleFactorsFinset x)\n⊢ Iff (Membership.mem (Equiv.Perm.OnCycleFactors.toPermHom g).range τ) (Eq (Function.comp (fun c => (↑c).support.card) ⇑τ) fun c => (↑c).support.card)","decl":"/-- Unapplied variant of `Equiv.Perm.mem_range_toPermHom_iff` -/\ntheorem mem_range_toPermHom_iff' {τ} : τ ∈ (toPermHom g).range ↔\n    (fun (c : g.cycleFactorsFinset) ↦ (c : Perm α).support.card) ∘ τ =\n      fun (c : g.cycleFactorsFinset) ↦ (c : Perm α).support.card := by\n  rw [mem_range_toPermHom_iff, funext_iff]\n  simp only [Finset.coe_sort_coe, Subtype.forall, Function.comp_apply]\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.range_toPermHom_eq_range_toPermHom'","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\n⊢ Eq (Equiv.Perm.OnCycleFactors.toPermHom g).range (Equiv.Perm.OnCycleFactors.range_toPermHom' g)","decl":"/-- Computes the range of `Equiv.Perm.toPermHom g` -/\ntheorem range_toPermHom_eq_range_toPermHom' :\n    (toPermHom g).range = range_toPermHom' g := by\n  ext τ\n  rw [mem_range_toPermHom_iff, mem_range_toPermHom'_iff]\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.nat_card_range_toPermHom","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (Equiv.Perm.OnCycleFactors.toPermHom g).range x)) (g.cycleType.toFinset.prod fun n => (Multiset.count n g.cycleType).factorial)","decl":"theorem nat_card_range_toPermHom :\n    Nat.card (toPermHom g).range =\n      ∏ n ∈ g.cycleType.toFinset, (g.cycleType.count n)! := by\n  classical\n  set sc : (c : g.cycleFactorsFinset) → ℕ := fun c ↦ (c : Perm α).support.card with hsc\n  suffices Fintype.card (toPermHom g).range =\n    Fintype.card { k : Perm g.cycleFactorsFinset | sc ∘ k = sc } by\n    simp only [Nat.card_eq_fintype_card, this, Set.coe_setOf, DomMulAct.stabilizer_card', hsc,\n      Finset.univ_eq_attach]\n    simp_rw [← CycleType.count_def]\n    apply Finset.prod_congr _ (fun _ _ => rfl)\n    ext n\n    simp only [Finset.univ_eq_attach, Finset.mem_image, Finset.mem_attach,\n        hsc, true_and, Subtype.exists, exists_prop, Multiset.mem_toFinset]\n    simp only [cycleType_def, Function.comp_apply, Multiset.mem_map, Finset.mem_val]\n  simp only [← SetLike.coe_sort_coe, Fintype.card_eq_nat_card]\n  congr\n  ext\n  rw [SetLike.mem_coe, mem_range_toPermHom_iff', Set.mem_setOf_eq, ← beq_eq_beq]\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.kerParam_apply","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\nu : Equiv.Perm ↑(Function.fixedPoints ⇑g)\nv : (c : Subtype fun x => Membership.mem g.cycleFactorsFinset x) → Subtype fun x => Membership.mem (Subgroup.zpowers ↑c) x\nx : α\n⊢ Eq (((Equiv.Perm.OnCycleFactors.kerParam g) { fst := u, snd := v }) x) (dite (Membership.mem g.cycleFactorsFinset (g.cycleOf x)) (fun hx => ↑(v ⟨g.cycleOf x, hx⟩) x) fun hx => (Equiv.Perm.ofSubtype u) x)","decl":"theorem kerParam_apply {u : Perm (Function.fixedPoints g)}\n    {v : (c : g.cycleFactorsFinset) → Subgroup.zpowers (c : Perm α)} {x : α} :\n    kerParam g (u,v) x =\n    if hx : g.cycleOf x ∈ g.cycleFactorsFinset\n    then (v ⟨g.cycleOf x, hx⟩ : Perm α) x\n    else ofSubtype u x := by\n  split_ifs with hx\n  · have hx' := hx\n    rw [cycleOf_mem_cycleFactorsFinset_iff, mem_support, Ne, ← Function.mem_fixedPoints_iff] at hx'\n    rw [kerParam, MonoidHom.noncommCoprod_apply', mul_apply, ofSubtype_apply_of_not_mem u hx',\n      noncommPiCoprod_apply, ← Finset.noncommProd_erase_mul _ (Finset.mem_univ ⟨g.cycleOf x, hx⟩),\n      mul_apply, ← not_mem_support]\n    contrapose! hx'\n    obtain ⟨a, ha1, ha2⟩ := mem_support_of_mem_noncommProd_support hx'\n    simp only [Finset.mem_erase, Finset.mem_univ, and_true, Ne, Subtype.ext_iff] at ha1\n    have key := cycleFactorsFinset_pairwise_disjoint g a.2 hx ha1\n    rw [disjoint_iff_disjoint_support, Finset.disjoint_left] at key\n    obtain ⟨k, hk⟩ := mem_zpowers_iff.mp (v a).2\n    replace ha2 := key (support_zpow_le a.1 k (hk ▸ ha2))\n    obtain ⟨k, hk⟩ := mem_zpowers_iff.mp (v ⟨g.cycleOf x, hx⟩).2\n    rwa [← hk, zpow_apply_mem_support, not_mem_support, cycleOf_apply_self] at ha2\n  · rw [cycleOf_mem_cycleFactorsFinset_iff] at hx\n    rw [kerParam, MonoidHom.noncommCoprod_apply, mul_apply, Equiv.apply_eq_iff_eq,\n      ← not_mem_support]\n    contrapose! hx\n    obtain ⟨a, -, ha⟩ := mem_support_of_mem_noncommProd_support\n      (comm := fun a ha b hb h ↦ g.pairwise_commute_of_mem_zpowers h (v a) (v b) (v a).2 (v b).2) hx\n    exact support_zpowers_of_mem_cycleFactorsFinset_le (v a) ha\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.kerParam_injective","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\n⊢ Function.Injective ⇑(Equiv.Perm.OnCycleFactors.kerParam g)","decl":"theorem kerParam_injective (g : Perm α) : Function.Injective (kerParam g) := by\n  rw [kerParam, MonoidHom.noncommCoprod_injective]\n  refine ⟨ofSubtype_injective, ?_, ?_⟩\n  · apply MonoidHom.injective_noncommPiCoprod_of_iSupIndep\n    · intro a\n      simp only [range_subtype, ne_eq]\n      simp only [zpowers_eq_closure, ← closure_iUnion]\n      apply disjoint_closure_of_disjoint_support\n      rintro - ⟨-⟩ - ⟨-, ⟨b, rfl⟩, -, ⟨h, rfl⟩, ⟨-⟩⟩\n      rw [← disjoint_iff_disjoint_support]\n      apply cycleFactorsFinset_pairwise_disjoint g a.2 b.2\n      simp only [ne_eq, ← Subtype.ext_iff]\n      exact ne_comm.mp h\n    · exact fun i ↦ subtype_injective _\n  · rw [noncommPiCoprod_range, ← ofSubtype.range.closure_eq]\n    simp only [zpowers_eq_closure, ← closure_iUnion]\n    apply disjoint_closure_of_disjoint_support\n    rintro - ⟨a, rfl⟩ - ⟨-, ⟨b, rfl⟩, ⟨-⟩⟩\n    exact (ofSubtype_support_disjoint a).mono_right (mem_cycleFactorsFinset_support_le b.2)\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.kerParam_range_eq","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\n⊢ Eq (Equiv.Perm.OnCycleFactors.kerParam g).range (Subgroup.map (Subgroup.centralizer (Singleton.singleton g)).subtype (Equiv.Perm.OnCycleFactors.toPermHom g).ker)","decl":"theorem kerParam_range_eq :\n    (kerParam g).range = (toPermHom g).ker.map (Subgroup.subtype _) := by\n  apply le_antisymm\n  · rw [kerParam, MonoidHom.noncommCoprod_range, sup_le_iff, noncommPiCoprod_range, iSup_le_iff]\n    simp only [zpowers_le]\n    constructor\n    · rintro - ⟨a, rfl⟩\n      refine ⟨⟨ofSubtype a, ?_⟩, ?_, rfl⟩\n      · rw [mem_centralizer_singleton_iff]\n        exact Disjoint.commute (disjoint_iff_disjoint_support.mpr (ofSubtype_support_disjoint a))\n      · exact Perm.ext fun x ↦ Subtype.ext (disjoint_iff_disjoint_support.mpr\n          ((ofSubtype_support_disjoint a).mono_right\n            (mem_cycleFactorsFinset_support_le x.2))).commute.mul_inv_cancel\n    · intro i\n      refine ⟨⟨i, mem_centralizer_singleton_iff.mpr (self_mem_cycle_factors_commute i.2)⟩, ?_, rfl⟩\n      exact Perm.ext fun x ↦ Subtype.ext (cycleFactorsFinset_mem_commute' g i.2 x.2).mul_inv_cancel\n  · rintro - ⟨p, hp, rfl⟩\n    simp only [coeSubtype]\n    set u : Perm (Function.fixedPoints g) :=\n      subtypePerm p (fun x ↦ mem_fixedPoints_iff_apply_mem_of_mem_centralizer p.2)\n    simp only [SetLike.mem_coe, mem_ker_toPermHom_iff, IsCycle.forall_commute_iff] at hp\n    set v : (c : g.cycleFactorsFinset) → (Subgroup.zpowers (c : Perm α)) :=\n      fun c => ⟨ofSubtype\n          (p.1.subtypePerm (Classical.choose (hp c.val c.prop))),\n            Classical.choose_spec (hp c.val c.prop)⟩\n    use (u, v)\n    ext x\n    rw [kerParam_apply]\n    split_ifs with hx\n    · rw [cycleOf_mem_cycleFactorsFinset_iff, mem_support] at hx\n      rw [ofSubtype_apply_of_mem, subtypePerm_apply]\n      rwa [mem_support, cycleOf_apply_self, ne_eq]\n    · rw [cycleOf_mem_cycleFactorsFinset_iff, not_mem_support] at hx\n      rwa [ofSubtype_apply_of_mem, subtypePerm_apply]\n\n"}
{"name":"Equiv.Perm.OnCycleFactors.kerParam_range_card","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\n⊢ Eq (Fintype.card (Subtype fun x => Membership.mem (Equiv.Perm.OnCycleFactors.kerParam g).range x)) (HMul.hMul (HSub.hSub (Fintype.card α) g.cycleType.sum).factorial g.cycleType.prod)","decl":"theorem kerParam_range_card (g : Equiv.Perm α) :\n    Fintype.card (kerParam g).range = (Fintype.card α - g.cycleType.sum)! * g.cycleType.prod := by\n  rw [Fintype.card_coeSort_range (kerParam_injective g)]\n  rw [Fintype.card_prod, Fintype.card_perm, Fintype.card_pi, card_fixedPoints]\n  apply congr_arg\n  rw [Finset.univ_eq_attach, g.cycleFactorsFinset.prod_attach (fun i ↦ Fintype.card (zpowers i)),\n    cycleType, Finset.prod_map_val]\n  refine Finset.prod_congr rfl (fun x hx ↦ ?_)\n  rw [Fintype.card_zpowers, (mem_cycleFactorsFinset_iff.mp hx).1.orderOf, Function.comp_apply]\n\n"}
{"name":"Equiv.Perm.nat_card_centralizer","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (Subgroup.centralizer (Singleton.singleton g)) x)) (HMul.hMul (HMul.hMul (HSub.hSub (Fintype.card α) g.cycleType.sum).factorial g.cycleType.prod) (g.cycleType.toFinset.prod fun n => (Multiset.count n g.cycleType).factorial))","decl":"/-- Cardinality of the centralizer in `Equiv.Perm α` of a permutation given `cycleType` -/\ntheorem nat_card_centralizer :\n    Nat.card (centralizer {g}) =\n      (Fintype.card α - g.cycleType.sum)! * g.cycleType.prod *\n        (∏ n ∈ g.cycleType.toFinset, (g.cycleType.count n)!) := by\n  rw [← (toPermHom g).ker.card_mul_index, index_ker, nat_card_range_toPermHom,\n    ← kerParam_range_card, ← Nat.card_eq_fintype_card, kerParam_range_eq, card_subtype]\n\n"}
{"name":"Equiv.Perm.card_isConj_mul_eq","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\n⊢ Eq (HMul.hMul (Nat.card ↑(setOf fun h => IsConj g h)) (HMul.hMul (HMul.hMul (HSub.hSub (Fintype.card α) g.cycleType.sum).factorial g.cycleType.prod) (g.cycleType.toFinset.prod fun n => (Multiset.count n g.cycleType).factorial))) (Fintype.card α).factorial","decl":"theorem card_isConj_mul_eq :\n    Nat.card {h : Perm α | IsConj g h} *\n      ((Fintype.card α - g.cycleType.sum)! *\n      g.cycleType.prod *\n      (∏ n ∈ g.cycleType.toFinset, (g.cycleType.count n)!)) =\n    (Fintype.card α)! := by\n  classical\n  rw [Nat.card_eq_fintype_card, ← nat_card_centralizer g]\n  rw [Subgroup.nat_card_centralizer_nat_card_stabilizer, Nat.card_eq_fintype_card]\n  convert MulAction.card_orbit_mul_card_stabilizer_eq_card_group (ConjAct (Perm α)) g\n  · ext h\n    simp only [Set.mem_setOf_eq, ConjAct.mem_orbit_conjAct, isConj_comm]\n  · rw [ConjAct.card, Fintype.card_perm]\n\n"}
{"name":"Equiv.Perm.card_isConj_eq","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ng : Equiv.Perm α\n⊢ Eq (Nat.card ↑(setOf fun h => IsConj g h)) (HDiv.hDiv (Fintype.card α).factorial (HMul.hMul (HMul.hMul (HSub.hSub (Fintype.card α) g.cycleType.sum).factorial g.cycleType.prod) (g.cycleType.toFinset.prod fun n => (Multiset.count n g.cycleType).factorial)))","decl":"/-- Cardinality of a conjugacy class in `Equiv.Perm α` of a given `cycleType` -/\ntheorem card_isConj_eq :\n    Nat.card {h : Perm α | IsConj g h} =\n      (Fintype.card α)! /\n        ((Fintype.card α - g.cycleType.sum)! *\n          g.cycleType.prod *\n          (∏ n ∈ g.cycleType.toFinset, (g.cycleType.count n)!)) := by\n  rw [← card_isConj_mul_eq g, Nat.div_eq_of_eq_mul_left _]\n  · rfl\n  -- This is the cardinal of the centralizer\n  · rw [← nat_card_centralizer g]\n    apply Nat.card_pos\n\n"}
{"name":"Equiv.Perm.card_of_cycleType_eq_zero_iff","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nm : Multiset Nat\n⊢ Iff (Eq (Finset.filter (fun g => Eq g.cycleType m) Finset.univ).card 0) (Not (And (LE.le m.sum (Fintype.card α)) (∀ (a : Nat), Membership.mem m a → LE.le 2 a)))","decl":"theorem card_of_cycleType_eq_zero_iff {m : Multiset ℕ} :\n    ({g | g.cycleType = m} : Finset (Perm α)).card = 0\n      ↔ ¬ ((m.sum ≤ Fintype.card α ∧ ∀ a ∈ m, 2 ≤ a)) := by\n  rw [Finset.card_eq_zero, Finset.filter_eq_empty_iff,\n    ← exists_with_cycleType_iff, not_exists]\n  aesop\n\n"}
{"name":"Equiv.Perm.card_of_cycleType_mul_eq","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nm : Multiset Nat\n⊢ Eq (HMul.hMul (Finset.filter (fun g => Eq g.cycleType m) Finset.univ).card (HMul.hMul (HMul.hMul (HSub.hSub (Fintype.card α) m.sum).factorial m.prod) (m.toFinset.prod fun n => (Multiset.count n m).factorial))) (ite (And (LE.le m.sum (Fintype.card α)) (∀ (a : Nat), Membership.mem m a → LE.le 2 a)) (Fintype.card α).factorial 0)","decl":"theorem card_of_cycleType_mul_eq (m : Multiset ℕ) :\n    ({g | g.cycleType = m} : Finset (Perm α)).card *\n        ((Fintype.card α - m.sum)! * m.prod *\n          (∏ n ∈ m.toFinset, (m.count n)!)) =\n      if (m.sum ≤ Fintype.card α ∧ ∀ a ∈ m, 2 ≤ a) then (Fintype.card α)! else 0 := by\n  split_ifs with hm\n  · -- nonempty case\n    classical\n    obtain ⟨g, rfl⟩ := (exists_with_cycleType_iff α).mpr hm\n    convert card_isConj_mul_eq g\n    simp_rw [Set.coe_setOf, Nat.card_eq_fintype_card, ← Fintype.card_coe, Finset.mem_filter,\n      Finset.mem_univ, true_and, ← isConj_iff_cycleType_eq, isConj_comm (g := g)]\n  · -- empty case\n    convert MulZeroClass.zero_mul _\n    exact (card_of_cycleType_eq_zero_iff α).mpr hm\n\n"}
{"name":"Equiv.Perm.card_of_cycleType","module":"Mathlib.GroupTheory.Perm.Centralizer","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nm : Multiset Nat\n⊢ Eq (Finset.filter (fun g => Eq g.cycleType m) Finset.univ).card (ite (And (LE.le m.sum (Fintype.card α)) (∀ (a : Nat), Membership.mem m a → LE.le 2 a)) (HDiv.hDiv (Fintype.card α).factorial (HMul.hMul (HMul.hMul (HSub.hSub (Fintype.card α) m.sum).factorial m.prod) (m.toFinset.prod fun n => (Multiset.count n m).factorial))) 0)","decl":"/-- Cardinality of the `Finset` of `Equiv.Perm α` of given `cycleType` -/\ntheorem card_of_cycleType (m : Multiset ℕ) :\n    ({g | g.cycleType = m} : Finset (Perm α)).card =\n      if m.sum ≤ Fintype.card α ∧ ∀ a ∈ m, 2 ≤ a then\n        (Fintype.card α)! /\n          ((Fintype.card α - m.sum)! * m.prod * (∏ n ∈ m.toFinset, (m.count n)!))\n      else 0 := by\n  split_ifs with hm\n  · -- nonempty case\n    apply symm\n    apply Nat.div_eq_of_eq_mul_left\n    · apply Nat.mul_pos\n      · apply Nat.mul_pos\n        · apply Nat.factorial_pos\n        · apply Multiset.prod_pos\n          exact fun a ha ↦ lt_of_lt_of_le (zero_lt_two) (hm.2 a ha)\n      · exact Finset.prod_pos (fun _ _ ↦ Nat.factorial_pos _)\n    rw [card_of_cycleType_mul_eq, if_pos hm]\n  · -- empty case\n    exact (card_of_cycleType_eq_zero_iff α).mpr hm\n\n"}
