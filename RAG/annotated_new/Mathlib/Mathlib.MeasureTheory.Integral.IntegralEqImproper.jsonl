{"name":"MeasureTheory.AECover.ae_eventually_mem","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\nÏ† : Î¹ â†’ Set Î±\nself : MeasureTheory.AECover Î¼ l Ï†\nâŠ¢ Filter.Eventually (fun x => Filter.Eventually (fun i => Membership.mem (Ï† i) x) l) (MeasureTheory.ae Î¼)","decl":"/-- A sequence `Ï†` of subsets of `Î±` is a `MeasureTheory.AECover` w.r.t. a measure `Î¼` and a filter\n    `l` if almost every point (w.r.t. `Î¼`) of `Î±` eventually belongs to `Ï† n` (w.r.t. `l`), and if\n    each `Ï† n` is measurable.  This definition is a technical way to avoid duplicating a lot of\n    proofs.  It should be thought of as a sufficient condition for being able to interpret\n    `âˆ« x, f x âˆ‚Î¼` (if it exists) as the limit of `âˆ« x in Ï† n, f x âˆ‚Î¼` as `n` tends to `l`.\n\n    See for example `MeasureTheory.AECover.lintegral_tendsto_of_countably_generated`,\n    `MeasureTheory.AECover.integrable_of_integral_norm_tendsto` and\n    `MeasureTheory.AECover.integral_tendsto_of_countably_generated`. -/\nstructure AECover (Ï† : Î¹ â†’ Set Î±) : Prop where\n  ae_eventually_mem : âˆ€áµ x âˆ‚Î¼, âˆ€á¶  i in l, x âˆˆ Ï† i\n  protected measurableSet : âˆ€ i, MeasurableSet <| Ï† i\n\n"}
{"name":"MeasureTheory.AECover.measurableSet","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\nÏ† : Î¹ â†’ Set Î±\nself : MeasureTheory.AECover Î¼ l Ï†\ni : Î¹\nâŠ¢ MeasurableSet (Ï† i)","decl":"/-- A sequence `Ï†` of subsets of `Î±` is a `MeasureTheory.AECover` w.r.t. a measure `Î¼` and a filter\n    `l` if almost every point (w.r.t. `Î¼`) of `Î±` eventually belongs to `Ï† n` (w.r.t. `l`), and if\n    each `Ï† n` is measurable.  This definition is a technical way to avoid duplicating a lot of\n    proofs.  It should be thought of as a sufficient condition for being able to interpret\n    `âˆ« x, f x âˆ‚Î¼` (if it exists) as the limit of `âˆ« x in Ï† n, f x âˆ‚Î¼` as `n` tends to `l`.\n\n    See for example `MeasureTheory.AECover.lintegral_tendsto_of_countably_generated`,\n    `MeasureTheory.AECover.integrable_of_integral_norm_tendsto` and\n    `MeasureTheory.AECover.integral_tendsto_of_countably_generated`. -/\nstructure AECover (Ï† : Î¹ â†’ Set Î±) : Prop where\n  ae_eventually_mem : âˆ€áµ x âˆ‚Î¼, âˆ€á¶  i in l, x âˆˆ Ï† i\n  protected measurableSet : âˆ€ i, MeasurableSet <| Ï† i\n\n"}
{"name":"MeasureTheory.AECover.inter","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\nÏ† Ïˆ : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nhÏˆ : MeasureTheory.AECover Î¼ l Ïˆ\nâŠ¢ MeasureTheory.AECover Î¼ l fun i => Inter.inter (Ï† i) (Ïˆ i)","decl":"/-- Elementwise intersection of two `AECover`s is an `AECover`. -/\ntheorem inter {Ï† Ïˆ : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) (hÏˆ : AECover Î¼ l Ïˆ) :\n    AECover Î¼ l (fun i â†¦ Ï† i âˆ© Ïˆ i) where\n  ae_eventually_mem := hÏˆ.1.mp <| hÏ†.1.mono fun _ â†¦ Eventually.and\n  measurableSet _ := (hÏ†.2 _).inter (hÏˆ.2 _)\n\n"}
{"name":"MeasureTheory.AECover.superset","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\nÏ† Ïˆ : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nhsub : âˆ€ (i : Î¹), HasSubset.Subset (Ï† i) (Ïˆ i)\nhmeas : âˆ€ (i : Î¹), MeasurableSet (Ïˆ i)\nâŠ¢ MeasureTheory.AECover Î¼ l Ïˆ","decl":"theorem superset {Ï† Ïˆ : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) (hsub : âˆ€ i, Ï† i âŠ† Ïˆ i)\n    (hmeas : âˆ€ i, MeasurableSet (Ïˆ i)) : AECover Î¼ l Ïˆ :=\n  âŸ¨hÏ†.1.mono fun _x hx â†¦ hx.mono fun i hi â†¦ hsub i hi, hmeasâŸ©\n\n"}
{"name":"MeasureTheory.AECover.mono_ac","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\nÎ½ : MeasureTheory.Measure Î±\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nhle : Î½.AbsolutelyContinuous Î¼\nâŠ¢ MeasureTheory.AECover Î½ l Ï†","decl":"theorem mono_ac {Î½ : Measure Î±} {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) (hle : Î½ â‰ª Î¼) :\n    AECover Î½ l Ï† := âŸ¨hle hÏ†.1, hÏ†.2âŸ©\n\n"}
{"name":"MeasureTheory.AECover.mono","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\nÎ½ : MeasureTheory.Measure Î±\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nhle : LE.le Î½ Î¼\nâŠ¢ MeasureTheory.AECover Î½ l Ï†","decl":"theorem mono {Î½ : Measure Î±} {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) (hle : Î½ â‰¤ Î¼) :\n    AECover Î½ l Ï† := hÏ†.mono_ac hle.absolutelyContinuous\n\n"}
{"name":"MeasureTheory.aecover_ball","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : OpensMeasurableSpace Î±\nx : Î±\nr : Î¹ â†’ Real\nhr : Filter.Tendsto r l Filter.atTop\nâŠ¢ MeasureTheory.AECover Î¼ l fun i => Metric.ball x (r i)","decl":"theorem aecover_ball {x : Î±} {r : Î¹ â†’ â„} (hr : Tendsto r l atTop) :\n    AECover Î¼ l (fun i â†¦ Metric.ball x (r i)) where\n  measurableSet _ := Metric.isOpen_ball.measurableSet\n  ae_eventually_mem := by\n    filter_upwards with y\n    filter_upwards [hr (Ioi_mem_atTop (dist x y))] with a ha using by simpa [dist_comm] using ha\n\n"}
{"name":"MeasureTheory.aecover_closedBall","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : OpensMeasurableSpace Î±\nx : Î±\nr : Î¹ â†’ Real\nhr : Filter.Tendsto r l Filter.atTop\nâŠ¢ MeasureTheory.AECover Î¼ l fun i => Metric.closedBall x (r i)","decl":"theorem aecover_closedBall {x : Î±} {r : Î¹ â†’ â„} (hr : Tendsto r l atTop) :\n    AECover Î¼ l (fun i â†¦ Metric.closedBall x (r i)) where\n  measurableSet _ := Metric.isClosed_ball.measurableSet\n  ae_eventually_mem := by\n    filter_upwards with y\n    filter_upwards [hr (Ici_mem_atTop (dist x y))] with a ha using by simpa [dist_comm] using ha\n\n"}
{"name":"MeasureTheory.aecover_Ici","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : OpensMeasurableSpace Î±\na : Î¹ â†’ Î±\nha : Filter.Tendsto a l Filter.atBot\nâŠ¢ MeasureTheory.AECover Î¼ l fun i => Set.Ici (a i)","decl":"theorem aecover_Ici (ha : Tendsto a l atBot) : AECover Î¼ l fun i => Ici (a i) where\n  ae_eventually_mem := ae_of_all Î¼ ha.eventually_le_atBot\n  measurableSet _ := measurableSet_Ici\n\n"}
{"name":"MeasureTheory.aecover_Iic","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : OpensMeasurableSpace Î±\nb : Î¹ â†’ Î±\nhb : Filter.Tendsto b l Filter.atTop\nâŠ¢ MeasureTheory.AECover Î¼ l fun i => Set.Iic (b i)","decl":"theorem aecover_Iic (hb : Tendsto b l atTop) : AECover Î¼ l fun i => Iic <| b i :=\n  aecover_Ici (Î± := Î±áµ’áµˆ) hb\n\n"}
{"name":"MeasureTheory.aecover_Icc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\nâŠ¢ MeasureTheory.AECover Î¼ l fun i => Set.Icc (a i) (b i)","decl":"theorem aecover_Icc (ha : Tendsto a l atBot) (hb : Tendsto b l atTop) :\n    AECover Î¼ l fun i => Icc (a i) (b i) :=\n  (aecover_Ici ha).inter (aecover_Iic hb)\n\n"}
{"name":"MeasureTheory.aecover_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na : Î¹ â†’ Î±\nha : Filter.Tendsto a l Filter.atBot\ninstâœ : NoMinOrder Î±\nâŠ¢ MeasureTheory.AECover Î¼ l fun i => Set.Ioi (a i)","decl":"include ha in\ntheorem aecover_Ioi [NoMinOrder Î±] : AECover Î¼ l fun i => Ioi (a i) where\n  ae_eventually_mem := ae_of_all Î¼ ha.eventually_lt_atBot\n  measurableSet _ := measurableSet_Ioi\n\n"}
{"name":"MeasureTheory.aecover_Iio","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\nb : Î¹ â†’ Î±\nhb : Filter.Tendsto b l Filter.atTop\ninstâœ : NoMaxOrder Î±\nâŠ¢ MeasureTheory.AECover Î¼ l fun i => Set.Iio (b i)","decl":"include hb in\ntheorem aecover_Iio [NoMaxOrder Î±] : AECover Î¼ l fun i => Iio (b i) := aecover_Ioi (Î± := Î±áµ’áµˆ) hb\n\n"}
{"name":"MeasureTheory.aecover_Ioo","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâ¶ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâµ : LinearOrder Î±\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : OrderClosedTopology Î±\ninstâœÂ² : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\ninstâœÂ¹ : NoMinOrder Î±\ninstâœ : NoMaxOrder Î±\nâŠ¢ MeasureTheory.AECover Î¼ l fun i => Set.Ioo (a i) (b i)","decl":"theorem aecover_Ioo [NoMinOrder Î±] [NoMaxOrder Î±] : AECover Î¼ l fun i => Ioo (a i) (b i) :=\n  (aecover_Ioi ha).inter (aecover_Iio hb)\n\n"}
{"name":"MeasureTheory.aecover_Ioc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\ninstâœ : NoMinOrder Î±\nâŠ¢ MeasureTheory.AECover Î¼ l fun i => Set.Ioc (a i) (b i)","decl":"theorem aecover_Ioc [NoMinOrder Î±] : AECover Î¼ l fun i => Ioc (a i) (b i) :=\n  (aecover_Ioi ha).inter (aecover_Iic hb)\n\n"}
{"name":"MeasureTheory.aecover_Ico","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\ninstâœ : NoMaxOrder Î±\nâŠ¢ MeasureTheory.AECover Î¼ l fun i => Set.Ico (a i) (b i)","decl":"theorem aecover_Ico [NoMaxOrder Î±] : AECover Î¼ l fun i => Ico (a i) (b i) :=\n  (aecover_Ici ha).inter (aecover_Iio hb)\n\n"}
{"name":"MeasureTheory.aecover_Ioi_of_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : OpensMeasurableSpace Î±\na : Î¹ â†’ Î±\nA : Î±\nha : Filter.Tendsto a l (nhds A)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ioi A)) l fun i => Set.Ioi (a i)","decl":"include ha in\ntheorem aecover_Ioi_of_Ioi : AECover (Î¼.restrict (Ioi A)) l fun i â†¦ Ioi (a i) where\n  ae_eventually_mem := (ae_restrict_mem measurableSet_Ioi).mono fun _x hx â†¦ ha.eventually <|\n    eventually_lt_nhds hx\n  measurableSet _ := measurableSet_Ioi\n\n"}
{"name":"MeasureTheory.aecover_Iio_of_Iio","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : OpensMeasurableSpace Î±\nb : Î¹ â†’ Î±\nB : Î±\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Iio B)) l fun i => Set.Iio (b i)","decl":"include hb in\ntheorem aecover_Iio_of_Iio : AECover (Î¼.restrict (Iio B)) l fun i â†¦ Iio (b i) :=\n  aecover_Ioi_of_Ioi (Î± := Î±áµ’áµˆ) hb\n\n"}
{"name":"MeasureTheory.aecover_Ioi_of_Ici","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : OpensMeasurableSpace Î±\na : Î¹ â†’ Î±\nA : Î±\nha : Filter.Tendsto a l (nhds A)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ioi A)) l fun i => Set.Ici (a i)","decl":"include ha in\ntheorem aecover_Ioi_of_Ici : AECover (Î¼.restrict (Ioi A)) l fun i â†¦ Ici (a i) :=\n  (aecover_Ioi_of_Ioi ha).superset (fun _ â†¦ Ioi_subset_Ici_self) fun _ â†¦ measurableSet_Ici\n\n"}
{"name":"MeasureTheory.aecover_Iio_of_Iic","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : OpensMeasurableSpace Î±\nb : Î¹ â†’ Î±\nB : Î±\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Iio B)) l fun i => Set.Iic (b i)","decl":"include hb in\ntheorem aecover_Iio_of_Iic : AECover (Î¼.restrict (Iio B)) l fun i â†¦ Iic (b i) :=\n  aecover_Ioi_of_Ici (Î± := Î±áµ’áµˆ) hb\n\n"}
{"name":"MeasureTheory.aecover_Ioo_of_Ioo","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ioo A B)) l fun i => Set.Ioo (a i) (b i)","decl":"include ha hb in\ntheorem aecover_Ioo_of_Ioo : AECover (Î¼.restrict <| Ioo A B) l fun i => Ioo (a i) (b i) :=\n  ((aecover_Ioi_of_Ioi ha).mono <| Measure.restrict_mono Ioo_subset_Ioi_self le_rfl).inter\n    ((aecover_Iio_of_Iio hb).mono <| Measure.restrict_mono Ioo_subset_Iio_self le_rfl)\n\n"}
{"name":"MeasureTheory.aecover_Ioo_of_Icc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ioo A B)) l fun i => Set.Icc (a i) (b i)","decl":"include ha hb in\ntheorem aecover_Ioo_of_Icc : AECover (Î¼.restrict <| Ioo A B) l fun i => Icc (a i) (b i) :=\n  (aecover_Ioo_of_Ioo ha hb).superset (fun _ â†¦ Ioo_subset_Icc_self) fun _ â†¦ measurableSet_Icc\n\n"}
{"name":"MeasureTheory.aecover_Ioo_of_Ico","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ioo A B)) l fun i => Set.Ico (a i) (b i)","decl":"include ha hb in\ntheorem aecover_Ioo_of_Ico : AECover (Î¼.restrict <| Ioo A B) l fun i => Ico (a i) (b i) :=\n  (aecover_Ioo_of_Ioo ha hb).superset (fun _ â†¦ Ioo_subset_Ico_self) fun _ â†¦ measurableSet_Ico\n\n"}
{"name":"MeasureTheory.aecover_Ioo_of_Ioc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ioo A B)) l fun i => Set.Ioc (a i) (b i)","decl":"include ha hb in\ntheorem aecover_Ioo_of_Ioc : AECover (Î¼.restrict <| Ioo A B) l fun i => Ioc (a i) (b i) :=\n  (aecover_Ioo_of_Ioo ha hb).superset (fun _ â†¦ Ioo_subset_Ioc_self) fun _ â†¦ measurableSet_Ioc\n\n"}
{"name":"MeasureTheory.aecover_Ioc_of_Icc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\ninstâœ : MeasureTheory.NoAtoms Î¼\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ioc A B)) l fun i => Set.Icc (a i) (b i)","decl":"theorem aecover_Ioc_of_Icc (ha : Tendsto a l (ğ“ A)) (hb : Tendsto b l (ğ“ B)) :\n    AECover (Î¼.restrict <| Ioc A B) l fun i => Icc (a i) (b i) :=\n  (aecover_Ioo_of_Icc ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ioc).ge\n\n"}
{"name":"MeasureTheory.aecover_Ioc_of_Ico","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\ninstâœ : MeasureTheory.NoAtoms Î¼\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ioc A B)) l fun i => Set.Ico (a i) (b i)","decl":"theorem aecover_Ioc_of_Ico (ha : Tendsto a l (ğ“ A)) (hb : Tendsto b l (ğ“ B)) :\n    AECover (Î¼.restrict <| Ioc A B) l fun i => Ico (a i) (b i) :=\n  (aecover_Ioo_of_Ico ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ioc).ge\n\n"}
{"name":"MeasureTheory.aecover_Ioc_of_Ioc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\ninstâœ : MeasureTheory.NoAtoms Î¼\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ioc A B)) l fun i => Set.Ioc (a i) (b i)","decl":"theorem aecover_Ioc_of_Ioc (ha : Tendsto a l (ğ“ A)) (hb : Tendsto b l (ğ“ B)) :\n    AECover (Î¼.restrict <| Ioc A B) l fun i => Ioc (a i) (b i) :=\n  (aecover_Ioo_of_Ioc ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ioc).ge\n\n"}
{"name":"MeasureTheory.aecover_Ioc_of_Ioo","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\ninstâœ : MeasureTheory.NoAtoms Î¼\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ioc A B)) l fun i => Set.Ioo (a i) (b i)","decl":"theorem aecover_Ioc_of_Ioo (ha : Tendsto a l (ğ“ A)) (hb : Tendsto b l (ğ“ B)) :\n    AECover (Î¼.restrict <| Ioc A B) l fun i => Ioo (a i) (b i) :=\n  (aecover_Ioo_of_Ioo ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ioc).ge\n\n"}
{"name":"MeasureTheory.aecover_Ico_of_Icc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\ninstâœ : MeasureTheory.NoAtoms Î¼\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ico A B)) l fun i => Set.Icc (a i) (b i)","decl":"theorem aecover_Ico_of_Icc (ha : Tendsto a l (ğ“ A)) (hb : Tendsto b l (ğ“ B)) :\n    AECover (Î¼.restrict <| Ico A B) l fun i => Icc (a i) (b i) :=\n  (aecover_Ioo_of_Icc ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ico).ge\n\n"}
{"name":"MeasureTheory.aecover_Ico_of_Ico","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\ninstâœ : MeasureTheory.NoAtoms Î¼\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ico A B)) l fun i => Set.Ico (a i) (b i)","decl":"theorem aecover_Ico_of_Ico (ha : Tendsto a l (ğ“ A)) (hb : Tendsto b l (ğ“ B)) :\n    AECover (Î¼.restrict <| Ico A B) l fun i => Ico (a i) (b i) :=\n  (aecover_Ioo_of_Ico ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ico).ge\n\n"}
{"name":"MeasureTheory.aecover_Ico_of_Ioc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\ninstâœ : MeasureTheory.NoAtoms Î¼\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ico A B)) l fun i => Set.Ioc (a i) (b i)","decl":"theorem aecover_Ico_of_Ioc (ha : Tendsto a l (ğ“ A)) (hb : Tendsto b l (ğ“ B)) :\n    AECover (Î¼.restrict <| Ico A B) l fun i => Ioc (a i) (b i) :=\n  (aecover_Ioo_of_Ioc ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ico).ge\n\n"}
{"name":"MeasureTheory.aecover_Ico_of_Ioo","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\ninstâœ : MeasureTheory.NoAtoms Î¼\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Ico A B)) l fun i => Set.Ioo (a i) (b i)","decl":"theorem aecover_Ico_of_Ioo (ha : Tendsto a l (ğ“ A)) (hb : Tendsto b l (ğ“ B)) :\n    AECover (Î¼.restrict <| Ico A B) l fun i => Ioo (a i) (b i) :=\n  (aecover_Ioo_of_Ioo ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ico).ge\n\n"}
{"name":"MeasureTheory.aecover_Icc_of_Icc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\ninstâœ : MeasureTheory.NoAtoms Î¼\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Icc A B)) l fun i => Set.Icc (a i) (b i)","decl":"theorem aecover_Icc_of_Icc (ha : Tendsto a l (ğ“ A)) (hb : Tendsto b l (ğ“ B)) :\n    AECover (Î¼.restrict <| Icc A B) l fun i => Icc (a i) (b i) :=\n  (aecover_Ioo_of_Icc ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Icc).ge\n\n"}
{"name":"MeasureTheory.aecover_Icc_of_Ico","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\ninstâœ : MeasureTheory.NoAtoms Î¼\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Icc A B)) l fun i => Set.Ico (a i) (b i)","decl":"theorem aecover_Icc_of_Ico (ha : Tendsto a l (ğ“ A)) (hb : Tendsto b l (ğ“ B)) :\n    AECover (Î¼.restrict <| Icc A B) l fun i => Ico (a i) (b i) :=\n  (aecover_Ioo_of_Ico ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Icc).ge\n\n"}
{"name":"MeasureTheory.aecover_Icc_of_Ioc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\ninstâœ : MeasureTheory.NoAtoms Î¼\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Icc A B)) l fun i => Set.Ioc (a i) (b i)","decl":"theorem aecover_Icc_of_Ioc (ha : Tendsto a l (ğ“ A)) (hb : Tendsto b l (ğ“ B)) :\n    AECover (Î¼.restrict <| Icc A B) l fun i => Ioc (a i) (b i) :=\n  (aecover_Ioo_of_Ioc ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Icc).ge\n\n"}
{"name":"MeasureTheory.aecover_Icc_of_Ioo","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâµ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderClosedTopology Î±\ninstâœÂ¹ : OpensMeasurableSpace Î±\na b : Î¹ â†’ Î±\nA B : Î±\ninstâœ : MeasureTheory.NoAtoms Î¼\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict (Set.Icc A B)) l fun i => Set.Ioo (a i) (b i)","decl":"theorem aecover_Icc_of_Ioo (ha : Tendsto a l (ğ“ A)) (hb : Tendsto b l (ğ“ B)) :\n    AECover (Î¼.restrict <| Icc A B) l fun i => Ioo (a i) (b i) :=\n  (aecover_Ioo_of_Ioo ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Icc).ge\n\n"}
{"name":"MeasureTheory.AECover.restrict","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\ns : Set Î±\nâŠ¢ MeasureTheory.AECover (Î¼.restrict s) l Ï†","decl":"protected theorem AECover.restrict {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) {s : Set Î±} :\n    AECover (Î¼.restrict s) l Ï† :=\n  hÏ†.mono Measure.restrict_le_self\n\n"}
{"name":"MeasureTheory.aecover_restrict_of_ae_imp","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ns : Set Î±\nÏ† : Î¹ â†’ Set Î±\nhs : MeasurableSet s\nae_eventually_mem : Filter.Eventually (fun x => Membership.mem s x â†’ Filter.Eventually (fun n => Membership.mem (Ï† n) x) l) (MeasureTheory.ae Î¼)\nmeasurable : âˆ€ (n : Î¹), MeasurableSet (Ï† n)\nâŠ¢ MeasureTheory.AECover (Î¼.restrict s) l Ï†","decl":"theorem aecover_restrict_of_ae_imp {s : Set Î±} {Ï† : Î¹ â†’ Set Î±} (hs : MeasurableSet s)\n    (ae_eventually_mem : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ âˆ€á¶  n in l, x âˆˆ Ï† n)\n    (measurable : âˆ€ n, MeasurableSet <| Ï† n) : AECover (Î¼.restrict s) l Ï† where\n  ae_eventually_mem := by rwa [ae_restrict_iff' hs]\n  measurableSet := measurable\n\n"}
{"name":"MeasureTheory.AECover.inter_restrict","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ MeasureTheory.AECover (Î¼.restrict s) l fun i => Inter.inter (Ï† i) s","decl":"theorem AECover.inter_restrict {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) {s : Set Î±}\n    (hs : MeasurableSet s) : AECover (Î¼.restrict s) l fun i => Ï† i âˆ© s :=\n  aecover_restrict_of_ae_imp hs\n    (hÏ†.ae_eventually_mem.mono fun _x hx hxs => hx.mono fun _i hi => âŸ¨hi, hxsâŸ©) fun i =>\n    (hÏ†.measurableSet i).inter hs\n\n"}
{"name":"MeasureTheory.AECover.ae_tendsto_indicator","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\nÎ² : Type u_3\ninstâœÂ¹ : Zero Î²\ninstâœ : TopologicalSpace Î²\nf : Î± â†’ Î²\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nâŠ¢ Filter.Eventually (fun x => Filter.Tendsto (fun i => (Ï† i).indicator f x) l (nhds (f x))) (MeasureTheory.ae Î¼)","decl":"theorem AECover.ae_tendsto_indicator {Î² : Type*} [Zero Î²] [TopologicalSpace Î²] (f : Î± â†’ Î²)\n    {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) :\n    âˆ€áµ x âˆ‚Î¼, Tendsto (fun i => (Ï† i).indicator f x) l (ğ“ <| f x) :=\n  hÏ†.ae_eventually_mem.mono fun _x hx =>\n    tendsto_const_nhds.congr' <| hx.mono fun _n hn => (indicator_of_mem hn _).symm\n\n"}
{"name":"MeasureTheory.AECover.aemeasurable","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\nÎ² : Type u_3\ninstâœÂ² : MeasurableSpace Î²\ninstâœÂ¹ : l.IsCountablyGenerated\ninstâœ : l.NeBot\nf : Î± â†’ Î²\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nhfm : âˆ€ (i : Î¹), AEMeasurable f (Î¼.restrict (Ï† i))\nâŠ¢ AEMeasurable f Î¼","decl":"theorem AECover.aemeasurable {Î² : Type*} [MeasurableSpace Î²] [l.IsCountablyGenerated] [l.NeBot]\n    {f : Î± â†’ Î²} {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†)\n    (hfm : âˆ€ i, AEMeasurable f (Î¼.restrict <| Ï† i)) : AEMeasurable f Î¼ := by\n  obtain âŸ¨u, huâŸ© := l.exists_seq_tendsto\n  have := aemeasurable_iUnion_iff.mpr fun n : â„• => hfm (u n)\n  rwa [Measure.restrict_eq_self_of_ae_mem] at this\n  filter_upwards [hÏ†.ae_eventually_mem] with x hx using\n    mem_iUnion.mpr (hu.eventually hx).exists\n\n"}
{"name":"MeasureTheory.AECover.aestronglyMeasurable","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\nÎ² : Type u_3\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ¹ : l.IsCountablyGenerated\ninstâœ : l.NeBot\nf : Î± â†’ Î²\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nhfm : âˆ€ (i : Î¹), MeasureTheory.AEStronglyMeasurable f (Î¼.restrict (Ï† i))\nâŠ¢ MeasureTheory.AEStronglyMeasurable f Î¼","decl":"theorem AECover.aestronglyMeasurable {Î² : Type*} [TopologicalSpace Î²] [PseudoMetrizableSpace Î²]\n    [l.IsCountablyGenerated] [l.NeBot] {f : Î± â†’ Î²} {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†)\n    (hfm : âˆ€ i, AEStronglyMeasurable f (Î¼.restrict <| Ï† i)) : AEStronglyMeasurable f Î¼ := by\n  obtain âŸ¨u, huâŸ© := l.exists_seq_tendsto\n  have := aestronglyMeasurable_iUnion_iff.mpr fun n : â„• => hfm (u n)\n  rwa [Measure.restrict_eq_self_of_ae_mem] at this\n  filter_upwards [hÏ†.ae_eventually_mem] with x hx using mem_iUnion.mpr (hu.eventually hx).exists\n\n"}
{"name":"MeasureTheory.AECover.comp_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nÎ¹' : Type u_3\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\nl' : Filter Î¹'\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nu : Î¹' â†’ Î¹\nhu : Filter.Tendsto u l' l\nâŠ¢ MeasureTheory.AECover Î¼ l' (Function.comp Ï† u)","decl":"theorem AECover.comp_tendsto {Î± Î¹ Î¹' : Type*} [MeasurableSpace Î±] {Î¼ : Measure Î±} {l : Filter Î¹}\n    {l' : Filter Î¹'} {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) {u : Î¹' â†’ Î¹} (hu : Tendsto u l' l) :\n    AECover Î¼ l' (Ï† âˆ˜ u) where\n  ae_eventually_mem := hÏ†.ae_eventually_mem.mono fun _x hx => hu.eventually hx\n  measurableSet i := hÏ†.measurableSet (u i)\n\n"}
{"name":"MeasureTheory.AECover.biUnion_Iic_aecover","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ² : Countable Î¹\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Preorder Î¹\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ Filter.atTop Ï†\nâŠ¢ MeasureTheory.AECover Î¼ Filter.atTop fun n => Set.iUnion fun k => Set.iUnion fun _h => Ï† k","decl":"theorem AECover.biUnion_Iic_aecover [Preorder Î¹] {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ atTop Ï†) :\n    AECover Î¼ atTop fun n : Î¹ => â‹ƒ (k) (_h : k âˆˆ Iic n), Ï† k :=\n  hÏ†.superset (fun _ â†¦ subset_biUnion_of_mem right_mem_Iic) fun _ â†¦ .biUnion (to_countable _)\n    fun _ _ â†¦ (hÏ†.2 _)\n\n-- Porting note: generalized from `[SemilatticeSup Î¹] [Nonempty Î¹]` to `[Preorder Î¹]`\n"}
{"name":"MeasureTheory.AECover.biInter_Ici_aecover","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ² : Countable Î¹\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Preorder Î¹\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ Filter.atTop Ï†\nâŠ¢ MeasureTheory.AECover Î¼ Filter.atTop fun n => Set.iInter fun k => Set.iInter fun _h => Ï† k","decl":"theorem AECover.biInter_Ici_aecover [Preorder Î¹] {Ï† : Î¹ â†’ Set Î±}\n    (hÏ† : AECover Î¼ atTop Ï†) : AECover Î¼ atTop fun n : Î¹ => â‹‚ (k) (_h : k âˆˆ Ici n), Ï† k where\n  ae_eventually_mem := hÏ†.ae_eventually_mem.mono fun x h â†¦ by\n    simpa only [mem_iInter, mem_Ici, eventually_forall_ge_atTop]\n  measurableSet _ := .biInter (to_countable _) fun n _ => hÏ†.measurableSet n\n\n"}
{"name":"MeasureTheory.AECover.lintegral_tendsto_of_nat","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÏ† : Nat â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ Filter.atTop Ï†\nf : Î± â†’ ENNReal\nhfm : AEMeasurable f Î¼\nâŠ¢ Filter.Tendsto (fun x => MeasureTheory.lintegral (Î¼.restrict (Ï† x)) fun x => f x) Filter.atTop (nhds (MeasureTheory.lintegral Î¼ fun x => f x))","decl":"theorem AECover.lintegral_tendsto_of_nat {Ï† : â„• â†’ Set Î±} (hÏ† : AECover Î¼ atTop Ï†) {f : Î± â†’ â„â‰¥0âˆ}\n    (hfm : AEMeasurable f Î¼) : Tendsto (âˆ«â» x in Ï† Â·, f x âˆ‚Î¼) atTop (ğ“ <| âˆ«â» x, f x âˆ‚Î¼) := by\n  have limâ‚ := lintegral_tendsto_of_monotone_of_nat hÏ†.biInter_Ici_aecover\n    (fun i j hij => biInter_subset_biInter_left (Ici_subset_Ici.mpr hij)) hfm\n  have limâ‚‚ := lintegral_tendsto_of_monotone_of_nat hÏ†.biUnion_Iic_aecover\n    (fun i j hij => biUnion_subset_biUnion_left (Iic_subset_Iic.mpr hij)) hfm\n  refine tendsto_of_tendsto_of_tendsto_of_le_of_le limâ‚ limâ‚‚ (fun n â†¦ ?_) fun n â†¦ ?_\n  exacts [lintegral_mono_set (biInter_subset_of_mem left_mem_Ici),\n    lintegral_mono_set (subset_biUnion_of_mem right_mem_Iic)]\n\n"}
{"name":"MeasureTheory.AECover.lintegral_tendsto_of_countably_generated","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ ENNReal\nhfm : AEMeasurable f Î¼\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.lintegral (Î¼.restrict (Ï† i)) fun x => f x) l (nhds (MeasureTheory.lintegral Î¼ fun x => f x))","decl":"theorem AECover.lintegral_tendsto_of_countably_generated [l.IsCountablyGenerated] {Ï† : Î¹ â†’ Set Î±}\n    (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ â„â‰¥0âˆ} (hfm : AEMeasurable f Î¼) :\n    Tendsto (fun i => âˆ«â» x in Ï† i, f x âˆ‚Î¼) l (ğ“ <| âˆ«â» x, f x âˆ‚Î¼) :=\n  tendsto_of_seq_tendsto fun _u hu => (hÏ†.comp_tendsto hu).lintegral_tendsto_of_nat hfm\n\n"}
{"name":"MeasureTheory.AECover.lintegral_eq_of_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ ENNReal\nI : ENNReal\nhfm : AEMeasurable f Î¼\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral (Î¼.restrict (Ï† i)) fun x => f x) l (nhds I)\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => f x) I","decl":"theorem AECover.lintegral_eq_of_tendsto [l.NeBot] [l.IsCountablyGenerated] {Ï† : Î¹ â†’ Set Î±}\n    (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ â„â‰¥0âˆ} (I : â„â‰¥0âˆ) (hfm : AEMeasurable f Î¼)\n    (htendsto : Tendsto (fun i => âˆ«â» x in Ï† i, f x âˆ‚Î¼) l (ğ“ I)) : âˆ«â» x, f x âˆ‚Î¼ = I :=\n  tendsto_nhds_unique (hÏ†.lintegral_tendsto_of_countably_generated hfm) htendsto\n\n"}
{"name":"MeasureTheory.AECover.iSup_lintegral_eq_of_countably_generated","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ² : Nonempty Î¹\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ ENNReal\nhfm : AEMeasurable f Î¼\nâŠ¢ Eq (iSup fun i => MeasureTheory.lintegral (Î¼.restrict (Ï† i)) fun x => f x) (MeasureTheory.lintegral Î¼ fun x => f x)","decl":"theorem AECover.iSup_lintegral_eq_of_countably_generated [Nonempty Î¹] [l.NeBot]\n    [l.IsCountablyGenerated] {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ â„â‰¥0âˆ}\n    (hfm : AEMeasurable f Î¼) : â¨† i : Î¹, âˆ«â» x in Ï† i, f x âˆ‚Î¼ = âˆ«â» x, f x âˆ‚Î¼ := by\n  have := hÏ†.lintegral_tendsto_of_countably_generated hfm\n  refine ciSup_eq_of_forall_le_of_forall_lt_exists_gt\n    (fun i => lintegral_mono' Measure.restrict_le_self le_rfl) fun w hw => ?_\n  exact (this.eventually_const_lt hw).exists\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_enorm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ E\nI : Real\nhfm : MeasureTheory.AEStronglyMeasurable f Î¼\nhbounded : Filter.Eventually (fun i => LE.le (MeasureTheory.lintegral (Î¼.restrict (Ï† i)) fun x => ENorm.enorm (f x)) (ENNReal.ofReal I)) l\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem AECover.integrable_of_lintegral_enorm_bounded [l.NeBot] [l.IsCountablyGenerated]\n    {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ E} (I : â„) (hfm : AEStronglyMeasurable f Î¼)\n    (hbounded : âˆ€á¶  i in l, âˆ«â» x in Ï† i, â€–f xâ€–â‚‘ âˆ‚Î¼ â‰¤ ENNReal.ofReal I) : Integrable f Î¼ := by\n  refine âŸ¨hfm, (le_of_tendsto ?_ hbounded).trans_lt ENNReal.ofReal_lt_topâŸ©\n  exact hÏ†.lintegral_tendsto_of_countably_generated hfm.enorm\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_nnnorm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ E\nI : Real\nhfm : MeasureTheory.AEStronglyMeasurable f Î¼\nhbounded : Filter.Eventually (fun i => LE.le (MeasureTheory.lintegral (Î¼.restrict (Ï† i)) fun x => ENorm.enorm (f x)) (ENNReal.ofReal I)) l\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"@[deprecated (since := \"2025-01-22\")]\nalias AECover.integrable_of_lintegral_nnnorm_bounded :=\n AECover.integrable_of_lintegral_enorm_bounded\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_enorm_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ E\nI : Real\nhfm : MeasureTheory.AEStronglyMeasurable f Î¼\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral (Î¼.restrict (Ï† i)) fun x => ENorm.enorm (f x)) l (nhds (ENNReal.ofReal I))\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem AECover.integrable_of_lintegral_enorm_tendsto [l.NeBot] [l.IsCountablyGenerated]\n    {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ E} (I : â„) (hfm : AEStronglyMeasurable f Î¼)\n    (htendsto : Tendsto (fun i => âˆ«â» x in Ï† i, â€–f xâ€–â‚‘ âˆ‚Î¼) l (ğ“ <| .ofReal I)) :\n    Integrable f Î¼ := by\n  refine hÏ†.integrable_of_lintegral_enorm_bounded (max 1 (I + 1)) hfm ?_\n  refine htendsto.eventually (ge_mem_nhds ?_)\n  refine (ENNReal.ofReal_lt_ofReal_iff (lt_max_of_lt_left zero_lt_one)).2 ?_\n  exact lt_max_of_lt_right (lt_add_one I)\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_nnnorm_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ E\nI : Real\nhfm : MeasureTheory.AEStronglyMeasurable f Î¼\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral (Î¼.restrict (Ï† i)) fun x => ENorm.enorm (f x)) l (nhds (ENNReal.ofReal I))\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"@[deprecated (since := \"2025-01-22\")]\nalias AECover.integrable_of_lintegral_nnnorm_tendsto :=\n AECover.integrable_of_lintegral_enorm_tendsto\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_enorm_bounded'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ E\nI : NNReal\nhfm : MeasureTheory.AEStronglyMeasurable f Î¼\nhbounded : Filter.Eventually (fun i => LE.le (MeasureTheory.lintegral (Î¼.restrict (Ï† i)) fun x => ENorm.enorm (f x)) â†‘I) l\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem AECover.integrable_of_lintegral_enorm_bounded' [l.NeBot] [l.IsCountablyGenerated]\n    {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ E} (I : â„â‰¥0) (hfm : AEStronglyMeasurable f Î¼)\n    (hbounded : âˆ€á¶  i in l, âˆ«â» x in Ï† i, â€–f xâ€–â‚‘ âˆ‚Î¼ â‰¤ I) : Integrable f Î¼ :=\n  hÏ†.integrable_of_lintegral_enorm_bounded I hfm\n    (by simpa only [ENNReal.ofReal_coe_nnreal] using hbounded)\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_nnnorm_bounded'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ E\nI : NNReal\nhfm : MeasureTheory.AEStronglyMeasurable f Î¼\nhbounded : Filter.Eventually (fun i => LE.le (MeasureTheory.lintegral (Î¼.restrict (Ï† i)) fun x => ENorm.enorm (f x)) â†‘I) l\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"@[deprecated (since := \"2025-01-22\")]\nalias AECover.integrable_of_lintegral_nnnorm_bounded' :=\n AECover.integrable_of_lintegral_enorm_bounded'\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_enorm_tendsto'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ E\nI : NNReal\nhfm : MeasureTheory.AEStronglyMeasurable f Î¼\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral (Î¼.restrict (Ï† i)) fun x => ENorm.enorm (f x)) l (nhds â†‘I)\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem AECover.integrable_of_lintegral_enorm_tendsto' [l.NeBot] [l.IsCountablyGenerated]\n    {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ E} (I : â„â‰¥0) (hfm : AEStronglyMeasurable f Î¼)\n    (htendsto : Tendsto (fun i => âˆ«â» x in Ï† i, â€–f xâ€–â‚‘ âˆ‚Î¼) l (ğ“ I)) : Integrable f Î¼ :=\n  hÏ†.integrable_of_lintegral_enorm_tendsto I hfm\n    (by simpa only [ENNReal.ofReal_coe_nnreal] using htendsto)\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_nnnorm_tendsto'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ E\nI : NNReal\nhfm : MeasureTheory.AEStronglyMeasurable f Î¼\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral (Î¼.restrict (Ï† i)) fun x => ENorm.enorm (f x)) l (nhds â†‘I)\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"@[deprecated (since := \"2025-01-22\")]\nalias AECover.integrable_of_lintegral_nnnorm_tendsto' :=\n AECover.integrable_of_lintegral_enorm_tendsto'\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_integral_norm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ E\nI : Real\nhfi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (Ï† i) Î¼\nhbounded : Filter.Eventually (fun i => LE.le (MeasureTheory.integral (Î¼.restrict (Ï† i)) fun x => Norm.norm (f x)) I) l\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem AECover.integrable_of_integral_norm_bounded [l.NeBot] [l.IsCountablyGenerated]\n    {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ E} (I : â„) (hfi : âˆ€ i, IntegrableOn f (Ï† i) Î¼)\n    (hbounded : âˆ€á¶  i in l, (âˆ« x in Ï† i, â€–f xâ€– âˆ‚Î¼) â‰¤ I) : Integrable f Î¼ := by\n  have hfm : AEStronglyMeasurable f Î¼ :=\n    hÏ†.aestronglyMeasurable fun i => (hfi i).aestronglyMeasurable\n  refine hÏ†.integrable_of_lintegral_enorm_bounded I hfm ?_\n  conv at hbounded in integral _ _ =>\n    rw [integral_eq_lintegral_of_nonneg_ae (ae_of_all _ fun x => @norm_nonneg E _ (f x))\n        hfm.norm.restrict]\n  conv at hbounded in ENNReal.ofReal _ =>\n    rw [â† coe_nnnorm, ENNReal.ofReal_coe_nnreal]\n  refine hbounded.mono fun i hi => ?_\n  rw [â† ENNReal.ofReal_toReal <| ne_top_of_lt <| hasFiniteIntegral_iff_enorm.mp (hfi i).2]\n  apply ENNReal.ofReal_le_ofReal hi\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_integral_norm_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ E\nI : Real\nhfi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (Ï† i) Î¼\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict (Ï† i)) fun x => Norm.norm (f x)) l (nhds I)\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem AECover.integrable_of_integral_norm_tendsto [l.NeBot] [l.IsCountablyGenerated]\n    {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ E} (I : â„) (hfi : âˆ€ i, IntegrableOn f (Ï† i) Î¼)\n    (htendsto : Tendsto (fun i => âˆ« x in Ï† i, â€–f xâ€– âˆ‚Î¼) l (ğ“ I)) : Integrable f Î¼ :=\n  let âŸ¨I', hI'âŸ© := htendsto.isBoundedUnder_le\n  hÏ†.integrable_of_integral_norm_bounded I' hfi hI'\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_integral_bounded_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ Real\nI : Real\nhfi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (Ï† i) Î¼\nhnng : Filter.Eventually (fun x => LE.le 0 (f x)) (MeasureTheory.ae Î¼)\nhbounded : Filter.Eventually (fun i => LE.le (MeasureTheory.integral (Î¼.restrict (Ï† i)) fun x => f x) I) l\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem AECover.integrable_of_integral_bounded_of_nonneg_ae [l.NeBot] [l.IsCountablyGenerated]\n    {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ â„} (I : â„) (hfi : âˆ€ i, IntegrableOn f (Ï† i) Î¼)\n    (hnng : âˆ€áµ x âˆ‚Î¼, 0 â‰¤ f x) (hbounded : âˆ€á¶  i in l, (âˆ« x in Ï† i, f x âˆ‚Î¼) â‰¤ I) : Integrable f Î¼ :=\n  hÏ†.integrable_of_integral_norm_bounded I hfi <| hbounded.mono fun _i hi =>\n    (integral_congr_ae <| ae_restrict_of_ae <| hnng.mono fun _ => Real.norm_of_nonneg).le.trans hi\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_integral_tendsto_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ Real\nI : Real\nhfi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (Ï† i) Î¼\nhnng : Filter.Eventually (fun x => LE.le 0 (f x)) (MeasureTheory.ae Î¼)\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict (Ï† i)) fun x => f x) l (nhds I)\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem AECover.integrable_of_integral_tendsto_of_nonneg_ae [l.NeBot] [l.IsCountablyGenerated]\n    {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ â„} (I : â„) (hfi : âˆ€ i, IntegrableOn f (Ï† i) Î¼)\n    (hnng : âˆ€áµ x âˆ‚Î¼, 0 â‰¤ f x) (htendsto : Tendsto (fun i => âˆ« x in Ï† i, f x âˆ‚Î¼) l (ğ“ I)) :\n    Integrable f Î¼ :=\n  let âŸ¨I', hI'âŸ© := htendsto.isBoundedUnder_le\n  hÏ†.integrable_of_integral_bounded_of_nonneg_ae I' hfi hnng hI'\n\n"}
{"name":"MeasureTheory.AECover.integral_tendsto_of_countably_generated","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ E\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict (Ï† i)) fun x => f x) l (nhds (MeasureTheory.integral Î¼ fun x => f x))","decl":"theorem AECover.integral_tendsto_of_countably_generated [l.IsCountablyGenerated] {Ï† : Î¹ â†’ Set Î±}\n    (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ E} (hfi : Integrable f Î¼) :\n    Tendsto (fun i => âˆ« x in Ï† i, f x âˆ‚Î¼) l (ğ“ <| âˆ« x, f x âˆ‚Î¼) :=\n  suffices h : Tendsto (fun i => âˆ« x : Î±, (Ï† i).indicator f x âˆ‚Î¼) l (ğ“ (âˆ« x : Î±, f x âˆ‚Î¼)) from by\n    convert h using 2; rw [integral_indicator (hÏ†.measurableSet _)]\n  tendsto_integral_filter_of_dominated_convergence (fun x => â€–f xâ€–)\n    (Eventually.of_forall fun i => hfi.aestronglyMeasurable.indicator <| hÏ†.measurableSet i)\n    (Eventually.of_forall fun _ => ae_of_all _ fun _ => norm_indicator_le_norm_self _ _) hfi.norm\n    (hÏ†.ae_tendsto_indicator f)\n\n"}
{"name":"MeasureTheory.AECover.integral_eq_of_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\nE : Type u_3\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ E\nI : E\nhfi : MeasureTheory.Integrable f Î¼\nh : Filter.Tendsto (fun n => MeasureTheory.integral (Î¼.restrict (Ï† n)) fun x => f x) l (nhds I)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) I","decl":"/-- Slight reformulation of\n    `MeasureTheory.AECover.integral_tendsto_of_countably_generated`. -/\ntheorem AECover.integral_eq_of_tendsto [l.NeBot] [l.IsCountablyGenerated] {Ï† : Î¹ â†’ Set Î±}\n    (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ E} (I : E) (hfi : Integrable f Î¼)\n    (h : Tendsto (fun n => âˆ« x in Ï† n, f x âˆ‚Î¼) l (ğ“ I)) : âˆ« x, f x âˆ‚Î¼ = I :=\n  tendsto_nhds_unique (hÏ†.integral_tendsto_of_countably_generated hfi) h\n\n"}
{"name":"MeasureTheory.AECover.integral_eq_of_tendsto_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î± : Type u_1\nÎ¹ : Type u_2\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nl : Filter Î¹\ninstâœÂ¹ : l.NeBot\ninstâœ : l.IsCountablyGenerated\nÏ† : Î¹ â†’ Set Î±\nhÏ† : MeasureTheory.AECover Î¼ l Ï†\nf : Î± â†’ Real\nI : Real\nhnng : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nhfi : âˆ€ (n : Î¹), MeasureTheory.IntegrableOn f (Ï† n) Î¼\nhtendsto : Filter.Tendsto (fun n => MeasureTheory.integral (Î¼.restrict (Ï† n)) fun x => f x) l (nhds I)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) I","decl":"theorem AECover.integral_eq_of_tendsto_of_nonneg_ae [l.NeBot] [l.IsCountablyGenerated]\n    {Ï† : Î¹ â†’ Set Î±} (hÏ† : AECover Î¼ l Ï†) {f : Î± â†’ â„} (I : â„) (hnng : 0 â‰¤áµ[Î¼] f)\n    (hfi : âˆ€ n, IntegrableOn f (Ï† n) Î¼) (htendsto : Tendsto (fun n => âˆ« x in Ï† n, f x âˆ‚Î¼) l (ğ“ I)) :\n    âˆ« x, f x âˆ‚Î¼ = I :=\n  have hfi' : Integrable f Î¼ := hÏ†.integrable_of_integral_tendsto_of_nonneg_ae I hfi hnng htendsto\n  hÏ†.integral_eq_of_tendsto I hfi' htendsto\n\n"}
{"name":"MeasureTheory.integrable_of_intervalIntegral_norm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nÎ¼ : MeasureTheory.Measure Real\nl : Filter Î¹\ninstâœÂ² : l.NeBot\ninstâœÂ¹ : l.IsCountablyGenerated\ninstâœ : NormedAddCommGroup E\na b : Î¹ â†’ Real\nf : Real â†’ E\nI : Real\nhfi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (Set.Ioc (a i) (b i)) Î¼\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\nh : Filter.Eventually (fun i => LE.le (intervalIntegral (fun x => Norm.norm (f x)) (a i) (b i) Î¼) I) l\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem integrable_of_intervalIntegral_norm_bounded (I : â„)\n    (hfi : âˆ€ i, IntegrableOn f (Ioc (a i) (b i)) Î¼) (ha : Tendsto a l atBot)\n    (hb : Tendsto b l atTop) (h : âˆ€á¶  i in l, (âˆ« x in a i..b i, â€–f xâ€– âˆ‚Î¼) â‰¤ I) : Integrable f Î¼ := by\n  have hÏ† : AECover Î¼ l _ := aecover_Ioc ha hb\n  refine hÏ†.integrable_of_integral_norm_bounded I hfi (h.mp ?_)\n  filter_upwards [ha.eventually (eventually_le_atBot 0),\n    hb.eventually (eventually_ge_atTop 0)] with i hai hbi ht\n  rwa [â† intervalIntegral.integral_of_le (hai.trans hbi)]\n\n"}
{"name":"MeasureTheory.integrable_of_intervalIntegral_norm_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nÎ¼ : MeasureTheory.Measure Real\nl : Filter Î¹\ninstâœÂ² : l.NeBot\ninstâœÂ¹ : l.IsCountablyGenerated\ninstâœ : NormedAddCommGroup E\na b : Î¹ â†’ Real\nf : Real â†’ E\nI : Real\nhfi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (Set.Ioc (a i) (b i)) Î¼\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\nh : Filter.Tendsto (fun i => intervalIntegral (fun x => Norm.norm (f x)) (a i) (b i) Î¼) l (nhds I)\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"/-- If `f` is integrable on intervals `Ioc (a i) (b i)`,\nwhere `a i` tends to -âˆ and `b i` tends to âˆ, and\n`âˆ« x in a i .. b i, â€–f xâ€– âˆ‚Î¼` converges to `I : â„` along a filter `l`,\nthen `f` is integrable on the interval (-âˆ, âˆ) -/\ntheorem integrable_of_intervalIntegral_norm_tendsto (I : â„)\n    (hfi : âˆ€ i, IntegrableOn f (Ioc (a i) (b i)) Î¼) (ha : Tendsto a l atBot)\n    (hb : Tendsto b l atTop) (h : Tendsto (fun i => âˆ« x in a i..b i, â€–f xâ€– âˆ‚Î¼) l (ğ“ I)) :\n    Integrable f Î¼ :=\n  let âŸ¨I', hI'âŸ© := h.isBoundedUnder_le\n  integrable_of_intervalIntegral_norm_bounded I' hfi ha hb hI'\n\n"}
{"name":"MeasureTheory.integrableOn_Iic_of_intervalIntegral_norm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nÎ¼ : MeasureTheory.Measure Real\nl : Filter Î¹\ninstâœÂ² : l.NeBot\ninstâœÂ¹ : l.IsCountablyGenerated\ninstâœ : NormedAddCommGroup E\na : Î¹ â†’ Real\nf : Real â†’ E\nI b : Real\nhfi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (Set.Ioc (a i) b) Î¼\nha : Filter.Tendsto a l Filter.atBot\nh : Filter.Eventually (fun i => LE.le (intervalIntegral (fun x => Norm.norm (f x)) (a i) b Î¼) I) l\nâŠ¢ MeasureTheory.IntegrableOn f (Set.Iic b) Î¼","decl":"theorem integrableOn_Iic_of_intervalIntegral_norm_bounded (I b : â„)\n    (hfi : âˆ€ i, IntegrableOn f (Ioc (a i) b) Î¼) (ha : Tendsto a l atBot)\n    (h : âˆ€á¶  i in l, (âˆ« x in a i..b, â€–f xâ€– âˆ‚Î¼) â‰¤ I) : IntegrableOn f (Iic b) Î¼ := by\n  have hÏ† : AECover (Î¼.restrict <| Iic b) l _ := aecover_Ioi ha\n  have hfi : âˆ€ i, IntegrableOn f (Ioi (a i)) (Î¼.restrict <| Iic b) := by\n    intro i\n    rw [IntegrableOn, Measure.restrict_restrict (hÏ†.measurableSet i)]\n    exact hfi i\n  refine hÏ†.integrable_of_integral_norm_bounded I hfi (h.mp ?_)\n  filter_upwards [ha.eventually (eventually_le_atBot b)] with i hai\n  rw [intervalIntegral.integral_of_le hai, Measure.restrict_restrict (hÏ†.measurableSet i)]\n  exact id\n\n"}
{"name":"MeasureTheory.integrableOn_Iic_of_intervalIntegral_norm_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nÎ¼ : MeasureTheory.Measure Real\nl : Filter Î¹\ninstâœÂ² : l.NeBot\ninstâœÂ¹ : l.IsCountablyGenerated\ninstâœ : NormedAddCommGroup E\na : Î¹ â†’ Real\nf : Real â†’ E\nI b : Real\nhfi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (Set.Ioc (a i) b) Î¼\nha : Filter.Tendsto a l Filter.atBot\nh : Filter.Tendsto (fun i => intervalIntegral (fun x => Norm.norm (f x)) (a i) b Î¼) l (nhds I)\nâŠ¢ MeasureTheory.IntegrableOn f (Set.Iic b) Î¼","decl":"/-- If `f` is integrable on intervals `Ioc (a i) b`,\nwhere `a i` tends to -âˆ, and\n`âˆ« x in a i .. b, â€–f xâ€– âˆ‚Î¼` converges to `I : â„` along a filter `l`,\nthen `f` is integrable on the interval (-âˆ, b) -/\ntheorem integrableOn_Iic_of_intervalIntegral_norm_tendsto (I b : â„)\n    (hfi : âˆ€ i, IntegrableOn f (Ioc (a i) b) Î¼) (ha : Tendsto a l atBot)\n    (h : Tendsto (fun i => âˆ« x in a i..b, â€–f xâ€– âˆ‚Î¼) l (ğ“ I)) : IntegrableOn f (Iic b) Î¼ :=\n  let âŸ¨I', hI'âŸ© := h.isBoundedUnder_le\n  integrableOn_Iic_of_intervalIntegral_norm_bounded I' b hfi ha hI'\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_of_intervalIntegral_norm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nÎ¼ : MeasureTheory.Measure Real\nl : Filter Î¹\ninstâœÂ² : l.NeBot\ninstâœÂ¹ : l.IsCountablyGenerated\ninstâœ : NormedAddCommGroup E\nb : Î¹ â†’ Real\nf : Real â†’ E\nI a : Real\nhfi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (Set.Ioc a (b i)) Î¼\nhb : Filter.Tendsto b l Filter.atTop\nh : Filter.Eventually (fun i => LE.le (intervalIntegral (fun x => Norm.norm (f x)) a (b i) Î¼) I) l\nâŠ¢ MeasureTheory.IntegrableOn f (Set.Ioi a) Î¼","decl":"theorem integrableOn_Ioi_of_intervalIntegral_norm_bounded (I a : â„)\n    (hfi : âˆ€ i, IntegrableOn f (Ioc a (b i)) Î¼) (hb : Tendsto b l atTop)\n    (h : âˆ€á¶  i in l, (âˆ« x in a..b i, â€–f xâ€– âˆ‚Î¼) â‰¤ I) : IntegrableOn f (Ioi a) Î¼ := by\n  have hÏ† : AECover (Î¼.restrict <| Ioi a) l _ := aecover_Iic hb\n  have hfi : âˆ€ i, IntegrableOn f (Iic (b i)) (Î¼.restrict <| Ioi a) := by\n    intro i\n    rw [IntegrableOn, Measure.restrict_restrict (hÏ†.measurableSet i), inter_comm]\n    exact hfi i\n  refine hÏ†.integrable_of_integral_norm_bounded I hfi (h.mp ?_)\n  filter_upwards [hb.eventually (eventually_ge_atTop a)] with i hbi\n  rw [intervalIntegral.integral_of_le hbi, Measure.restrict_restrict (hÏ†.measurableSet i),\n    inter_comm]\n  exact id\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_of_intervalIntegral_norm_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nÎ¼ : MeasureTheory.Measure Real\nl : Filter Î¹\ninstâœÂ² : l.NeBot\ninstâœÂ¹ : l.IsCountablyGenerated\ninstâœ : NormedAddCommGroup E\nb : Î¹ â†’ Real\nf : Real â†’ E\nI a : Real\nhfi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (Set.Ioc a (b i)) Î¼\nhb : Filter.Tendsto b l Filter.atTop\nh : Filter.Tendsto (fun i => intervalIntegral (fun x => Norm.norm (f x)) a (b i) Î¼) l (nhds I)\nâŠ¢ MeasureTheory.IntegrableOn f (Set.Ioi a) Î¼","decl":"/-- If `f` is integrable on intervals `Ioc a (b i)`,\nwhere `b i` tends to âˆ, and\n`âˆ« x in a .. b i, â€–f xâ€– âˆ‚Î¼` converges to `I : â„` along a filter `l`,\nthen `f` is integrable on the interval (a, âˆ) -/\ntheorem integrableOn_Ioi_of_intervalIntegral_norm_tendsto (I a : â„)\n    (hfi : âˆ€ i, IntegrableOn f (Ioc a (b i)) Î¼) (hb : Tendsto b l atTop)\n    (h : Tendsto (fun i => âˆ« x in a..b i, â€–f xâ€– âˆ‚Î¼) l (ğ“ <| I)) : IntegrableOn f (Ioi a) Î¼ :=\n  let âŸ¨I', hI'âŸ© := h.isBoundedUnder_le\n  integrableOn_Ioi_of_intervalIntegral_norm_bounded I' a hfi hb hI'\n\n"}
{"name":"MeasureTheory.integrableOn_Ioc_of_intervalIntegral_norm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nl : Filter Î¹\ninstâœÂ² : l.NeBot\ninstâœÂ¹ : l.IsCountablyGenerated\ninstâœ : NormedAddCommGroup E\na b : Î¹ â†’ Real\nf : Real â†’ E\nI aâ‚€ bâ‚€ : Real\nhfi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (Set.Ioc (a i) (b i)) MeasureTheory.MeasureSpace.volume\nha : Filter.Tendsto a l (nhds aâ‚€)\nhb : Filter.Tendsto b l (nhds bâ‚€)\nh : Filter.Eventually (fun i => LE.le (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc (a i) (b i))) fun x => Norm.norm (f x)) I) l\nâŠ¢ MeasureTheory.IntegrableOn f (Set.Ioc aâ‚€ bâ‚€) MeasureTheory.MeasureSpace.volume","decl":"theorem integrableOn_Ioc_of_intervalIntegral_norm_bounded {I aâ‚€ bâ‚€ : â„}\n    (hfi : âˆ€ i, IntegrableOn f <| Ioc (a i) (b i)) (ha : Tendsto a l <| ğ“ aâ‚€)\n    (hb : Tendsto b l <| ğ“ bâ‚€) (h : âˆ€á¶  i in l, (âˆ« x in Ioc (a i) (b i), â€–f xâ€–) â‰¤ I) :\n    IntegrableOn f (Ioc aâ‚€ bâ‚€) := by\n  refine (aecover_Ioc_of_Ioc ha hb).integrable_of_integral_norm_bounded I\n    (fun i => (hfi i).restrict measurableSet_Ioc) (h.mono fun i hi â†¦ ?_)\n  rw [Measure.restrict_restrict measurableSet_Ioc]\n  refine le_trans (setIntegral_mono_set (hfi i).norm ?_ ?_) hi <;> apply ae_of_all\n  Â· simp only [Pi.zero_apply, norm_nonneg, forall_const]\n  Â· intro c hc; exact hc.1\n\n"}
{"name":"MeasureTheory.integrableOn_Ioc_of_intervalIntegral_norm_bounded_left","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nl : Filter Î¹\ninstâœÂ² : l.NeBot\ninstâœÂ¹ : l.IsCountablyGenerated\ninstâœ : NormedAddCommGroup E\na : Î¹ â†’ Real\nf : Real â†’ E\nI aâ‚€ b : Real\nhfi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (Set.Ioc (a i) b) MeasureTheory.MeasureSpace.volume\nha : Filter.Tendsto a l (nhds aâ‚€)\nh : Filter.Eventually (fun i => LE.le (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc (a i) b)) fun x => Norm.norm (f x)) I) l\nâŠ¢ MeasureTheory.IntegrableOn f (Set.Ioc aâ‚€ b) MeasureTheory.MeasureSpace.volume","decl":"theorem integrableOn_Ioc_of_intervalIntegral_norm_bounded_left {I aâ‚€ b : â„}\n    (hfi : âˆ€ i, IntegrableOn f <| Ioc (a i) b) (ha : Tendsto a l <| ğ“ aâ‚€)\n    (h : âˆ€á¶  i in l, (âˆ« x in Ioc (a i) b, â€–f xâ€–) â‰¤ I) : IntegrableOn f (Ioc aâ‚€ b) :=\n  integrableOn_Ioc_of_intervalIntegral_norm_bounded hfi ha tendsto_const_nhds h\n\n"}
{"name":"MeasureTheory.integrableOn_Ioc_of_intervalIntegral_norm_bounded_right","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nl : Filter Î¹\ninstâœÂ² : l.NeBot\ninstâœÂ¹ : l.IsCountablyGenerated\ninstâœ : NormedAddCommGroup E\nb : Î¹ â†’ Real\nf : Real â†’ E\nI a bâ‚€ : Real\nhfi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (Set.Ioc a (b i)) MeasureTheory.MeasureSpace.volume\nhb : Filter.Tendsto b l (nhds bâ‚€)\nh : Filter.Eventually (fun i => LE.le (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc a (b i))) fun x => Norm.norm (f x)) I) l\nâŠ¢ MeasureTheory.IntegrableOn f (Set.Ioc a bâ‚€) MeasureTheory.MeasureSpace.volume","decl":"theorem integrableOn_Ioc_of_intervalIntegral_norm_bounded_right {I a bâ‚€ : â„}\n    (hfi : âˆ€ i, IntegrableOn f <| Ioc a (b i)) (hb : Tendsto b l <| ğ“ bâ‚€)\n    (h : âˆ€á¶  i in l, (âˆ« x in Ioc a (b i), â€–f xâ€–) â‰¤ I) : IntegrableOn f (Ioc a bâ‚€) :=\n  integrableOn_Ioc_of_intervalIntegral_norm_bounded hfi tendsto_const_nhds hb h\n\n"}
{"name":"MeasureTheory.intervalIntegral_tendsto_integral","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nÎ¼ : MeasureTheory.Measure Real\nl : Filter Î¹\ninstâœÂ² : l.IsCountablyGenerated\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na b : Î¹ â†’ Real\nf : Real â†’ E\nhfi : MeasureTheory.Integrable f Î¼\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\nâŠ¢ Filter.Tendsto (fun i => intervalIntegral (fun x => f x) (a i) (b i) Î¼) l (nhds (MeasureTheory.integral Î¼ fun x => f x))","decl":"theorem intervalIntegral_tendsto_integral (hfi : Integrable f Î¼) (ha : Tendsto a l atBot)\n    (hb : Tendsto b l atTop) : Tendsto (fun i => âˆ« x in a i..b i, f x âˆ‚Î¼) l (ğ“ <| âˆ« x, f x âˆ‚Î¼) := by\n  let Ï† i := Ioc (a i) (b i)\n  have hÏ† : AECover Î¼ l Ï† := aecover_Ioc ha hb\n  refine (hÏ†.integral_tendsto_of_countably_generated hfi).congr' ?_\n  filter_upwards [ha.eventually (eventually_le_atBot 0),\n    hb.eventually (eventually_ge_atTop 0)] with i hai hbi\n  exact (intervalIntegral.integral_of_le (hai.trans hbi)).symm\n\n"}
{"name":"MeasureTheory.intervalIntegral_tendsto_integral_Iic","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nÎ¼ : MeasureTheory.Measure Real\nl : Filter Î¹\ninstâœÂ² : l.IsCountablyGenerated\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\na : Î¹ â†’ Real\nf : Real â†’ E\nb : Real\nhfi : MeasureTheory.IntegrableOn f (Set.Iic b) Î¼\nha : Filter.Tendsto a l Filter.atBot\nâŠ¢ Filter.Tendsto (fun i => intervalIntegral (fun x => f x) (a i) b Î¼) l (nhds (MeasureTheory.integral (Î¼.restrict (Set.Iic b)) fun x => f x))","decl":"theorem intervalIntegral_tendsto_integral_Iic (b : â„) (hfi : IntegrableOn f (Iic b) Î¼)\n    (ha : Tendsto a l atBot) :\n    Tendsto (fun i => âˆ« x in a i..b, f x âˆ‚Î¼) l (ğ“ <| âˆ« x in Iic b, f x âˆ‚Î¼) := by\n  let Ï† i := Ioi (a i)\n  have hÏ† : AECover (Î¼.restrict <| Iic b) l Ï† := aecover_Ioi ha\n  refine (hÏ†.integral_tendsto_of_countably_generated hfi).congr' ?_\n  filter_upwards [ha.eventually (eventually_le_atBot <| b)] with i hai\n  rw [intervalIntegral.integral_of_le hai, Measure.restrict_restrict (hÏ†.measurableSet i)]\n  rfl\n\n"}
{"name":"MeasureTheory.intervalIntegral_tendsto_integral_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"Î¹ : Type u_1\nE : Type u_2\nÎ¼ : MeasureTheory.Measure Real\nl : Filter Î¹\ninstâœÂ² : l.IsCountablyGenerated\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nb : Î¹ â†’ Real\nf : Real â†’ E\na : Real\nhfi : MeasureTheory.IntegrableOn f (Set.Ioi a) Î¼\nhb : Filter.Tendsto b l Filter.atTop\nâŠ¢ Filter.Tendsto (fun i => intervalIntegral (fun x => f x) a (b i) Î¼) l (nhds (MeasureTheory.integral (Î¼.restrict (Set.Ioi a)) fun x => f x))","decl":"theorem intervalIntegral_tendsto_integral_Ioi (a : â„) (hfi : IntegrableOn f (Ioi a) Î¼)\n    (hb : Tendsto b l atTop) :\n    Tendsto (fun i => âˆ« x in a..b i, f x âˆ‚Î¼) l (ğ“ <| âˆ« x in Ioi a, f x âˆ‚Î¼) := by\n  let Ï† i := Iic (b i)\n  have hÏ† : AECover (Î¼.restrict <| Ioi a) l Ï† := aecover_Iic hb\n  refine (hÏ†.integral_tendsto_of_countably_generated hfi).congr' ?_\n  filter_upwards [hb.eventually (eventually_ge_atTop <| a)] with i hbi\n  rw [intervalIntegral.integral_of_le hbi, Measure.restrict_restrict (hÏ†.measurableSet i),\n    inter_comm]\n  rfl\n\n"}
{"name":"MeasureTheory.tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real â†’ E\na : Real\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nâŠ¢ Filter.Tendsto f Filter.atTop (nhds (limUnder Filter.atTop f))","decl":"/-- If the derivative of a function defined on the real line is integrable close to `+âˆ`, then\nthe function has a limit at `+âˆ`. -/\ntheorem tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi [CompleteSpace E]\n    (hderiv : âˆ€ x âˆˆ Ioi a, HasDerivAt f (f' x) x) (f'int : IntegrableOn f' (Ioi a)) :\n    Tendsto f atTop (ğ“ (limUnder atTop f)) := by\n  suffices âˆƒ a, Tendsto f atTop (ğ“ a) from tendsto_nhds_limUnder this\n  suffices CauchySeq f from cauchySeq_tendsto_of_complete this\n  apply Metric.cauchySeq_iff'.2 (fun Îµ Îµpos â†¦ ?_)\n  have A : âˆ€á¶  (n : â„•) in atTop, âˆ« (x : â„) in Ici â†‘n, â€–f' xâ€– < Îµ := by\n    have L : Tendsto (fun (n : â„•) â†¦ âˆ« x in Ici (n : â„), â€–f' xâ€–) atTop\n        (ğ“ (âˆ« x in â‹‚ (n : â„•), Ici (n : â„), â€–f' xâ€–)) := by\n      apply tendsto_setIntegral_of_antitone (fun n â†¦ measurableSet_Ici)\n      Â· intro m n hmn\n        exact Ici_subset_Ici.2 (Nat.cast_le.mpr hmn)\n      Â· rcases exists_nat_gt a with âŸ¨n, hnâŸ©\n        exact âŸ¨n, IntegrableOn.mono_set f'int.norm (Ici_subset_Ioi.2 hn)âŸ©\n    have B : â‹‚ (n : â„•), Ici (n : â„) = âˆ… := by\n      apply eq_empty_of_forall_not_mem (fun x â†¦ ?_)\n      simpa only [mem_iInter, mem_Ici, not_forall, not_le] using exists_nat_gt x\n    simp only [B, Measure.restrict_empty, integral_zero_measure] at L\n    exact (tendsto_order.1 L).2 _ Îµpos\n  have B : âˆ€á¶  (n : â„•) in atTop, a < n := by\n    rcases exists_nat_gt a with âŸ¨n, hnâŸ©\n    filter_upwards [Ioi_mem_atTop n] with m (hm : n < m) using hn.trans (Nat.cast_lt.mpr hm)\n  rcases (A.and B).exists with âŸ¨N, hN, h'NâŸ©\n  refine âŸ¨N, fun x hx â†¦ ?_âŸ©\n  calc\n  dist (f x) (f â†‘N)\n    = â€–f x - f Nâ€– := dist_eq_norm _ _\n  _ = â€–âˆ« t in Ioc â†‘N x, f' tâ€– := by\n      rw [â† intervalIntegral.integral_of_le hx, intervalIntegral.integral_eq_sub_of_hasDerivAt]\n      Â· intro y hy\n        simp only [hx, uIcc_of_le, mem_Icc] at hy\n        exact hderiv _ (h'N.trans_le hy.1)\n      Â· rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hx]\n        exact f'int.mono_set (Ioc_subset_Ioi_self.trans (Ioi_subset_Ioi h'N.le))\n  _ â‰¤ âˆ« t in Ioc â†‘N x, â€–f' tâ€– := norm_integral_le_integral_norm fun a â†¦ f' a\n  _ â‰¤ âˆ« t in Ici â†‘N, â€–f' tâ€– := by\n      apply setIntegral_mono_set\n      Â· apply IntegrableOn.mono_set f'int.norm (Ici_subset_Ioi.2 h'N)\n      Â· filter_upwards with x using norm_nonneg _\n      Â· have : Ioc (â†‘N) x âŠ† Ici â†‘N := Ioc_subset_Ioi_self.trans Ioi_subset_Ici_self\n        exact this.eventuallyLE\n  _ < Îµ := hN\n\n"}
{"name":"MeasureTheory.tendsto_zero_of_hasDerivAt_of_integrableOn_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real â†’ E\na : Real\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nfint : MeasureTheory.IntegrableOn f (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nâŠ¢ Filter.Tendsto f Filter.atTop (nhds 0)","decl":"open UniformSpace in\n/-- If a function and its derivative are integrable on `(a, +âˆ)`, then the function tends to zero\nat `+âˆ`. -/\ntheorem tendsto_zero_of_hasDerivAt_of_integrableOn_Ioi\n    (hderiv : âˆ€ x âˆˆ Ioi a, HasDerivAt f (f' x) x)\n    (f'int : IntegrableOn f' (Ioi a)) (fint : IntegrableOn f (Ioi a)) :\n    Tendsto f atTop (ğ“ 0) := by\n  let F : E â†’L[â„] Completion E := Completion.toComplL\n  have Fderiv : âˆ€ x âˆˆ Ioi a, HasDerivAt (F âˆ˜ f) (F (f' x)) x :=\n    fun x hx â†¦ F.hasFDerivAt.comp_hasDerivAt _ (hderiv x hx)\n  have Fint : IntegrableOn (F âˆ˜ f) (Ioi a) := by apply F.integrable_comp fint\n  have F'int : IntegrableOn (F âˆ˜ f') (Ioi a) := by apply F.integrable_comp f'int\n  have A : Tendsto (F âˆ˜ f) atTop (ğ“ (limUnder atTop (F âˆ˜ f))) := by\n    apply tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi Fderiv F'int\n  have B : limUnder atTop (F âˆ˜ f) = F 0 := by\n    have : IntegrableAtFilter (F âˆ˜ f) atTop := by exact âŸ¨Ioi a, Ioi_mem_atTop _, FintâŸ©\n    apply IntegrableAtFilter.eq_zero_of_tendsto this ?_ A\n    intro s hs\n    rcases mem_atTop_sets.1 hs with âŸ¨b, hbâŸ©\n    rw [â† top_le_iff, â† volume_Ici (a := b)]\n    exact measure_mono hb\n  rwa [B, â† IsEmbedding.tendsto_nhds_iff] at A\n  exact (Completion.isUniformEmbedding_coe E).isEmbedding\n\n"}
{"name":"MeasureTheory.integral_Ioi_of_hasDerivAt_of_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real â†’ E\na : Real\nm : E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhcont : ContinuousWithinAt f (Set.Ici a) a\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nhf : Filter.Tendsto f Filter.atTop (nhds m)\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => f' x) (HSub.hSub m (f a))","decl":"/-- **Fundamental theorem of calculus-2**, on semi-infinite intervals `(a, +âˆ)`.\nWhen a function has a limit at infinity `m`, and its derivative is integrable, then the\nintegral of the derivative on `(a, +âˆ)` is `m - f a`. Version assuming differentiability\non `(a, +âˆ)` and continuity at `aâº`.\n\nNote that such a function always has a limit at infinity,\nsee `tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi`. -/\ntheorem integral_Ioi_of_hasDerivAt_of_tendsto (hcont : ContinuousWithinAt f (Ici a) a)\n    (hderiv : âˆ€ x âˆˆ Ioi a, HasDerivAt f (f' x) x) (f'int : IntegrableOn f' (Ioi a))\n    (hf : Tendsto f atTop (ğ“ m)) : âˆ« x in Ioi a, f' x = m - f a := by\n  have hcont : ContinuousOn f (Ici a) := by\n    intro x hx\n    rcases hx.out.eq_or_lt with rfl|hx\n    Â· exact hcont\n    Â· exact (hderiv x hx).continuousAt.continuousWithinAt\n  refine tendsto_nhds_unique (intervalIntegral_tendsto_integral_Ioi a f'int tendsto_id) ?_\n  apply Tendsto.congr' _ (hf.sub_const _)\n  filter_upwards [Ioi_mem_atTop a] with x hx\n  have h'x : a â‰¤ id x := le_of_lt hx\n  symm\n  apply\n    intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le h'x (hcont.mono Icc_subset_Ici_self)\n      fun y hy => hderiv y hy.1\n  rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x]\n  exact f'int.mono (fun y hy => hy.1) le_rfl\n\n"}
{"name":"MeasureTheory.integral_Ioi_of_hasDerivAt_of_tendsto'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real â†’ E\na : Real\nm : E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Ici a) x â†’ HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nhf : Filter.Tendsto f Filter.atTop (nhds m)\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => f' x) (HSub.hSub m (f a))","decl":"/-- **Fundamental theorem of calculus-2**, on semi-infinite intervals `(a, +âˆ)`.\nWhen a function has a limit at infinity `m`, and its derivative is integrable, then the\nintegral of the derivative on `(a, +âˆ)` is `m - f a`. Version assuming differentiability\non `[a, +âˆ)`.\n\nNote that such a function always has a limit at infinity,\nsee `tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi`. -/\ntheorem integral_Ioi_of_hasDerivAt_of_tendsto' (hderiv : âˆ€ x âˆˆ Ici a, HasDerivAt f (f' x) x)\n    (f'int : IntegrableOn f' (Ioi a)) (hf : Tendsto f atTop (ğ“ m)) :\n    âˆ« x in Ioi a, f' x = m - f a := by\n  refine integral_Ioi_of_hasDerivAt_of_tendsto ?_ (fun x hx => hderiv x hx.out.le)\n    f'int hf\n  exact (hderiv a left_mem_Ici).continuousAt.continuousWithinAt\n\n"}
{"name":"HasCompactSupport.integral_Ioi_deriv_eq","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf : Real â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhf : ContDiff Real 1 f\nh2f : HasCompactSupport f\nb : Real\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi b)) fun x => deriv f x) (Neg.neg (f b))","decl":"/-- A special case of `integral_Ioi_of_hasDerivAt_of_tendsto` where we assume that `f` is C^1 with\ncompact support. -/\ntheorem _root_.HasCompactSupport.integral_Ioi_deriv_eq (hf : ContDiff â„ 1 f)\n    (h2f : HasCompactSupport f) (b : â„) : âˆ« x in Ioi b, deriv f x = - f b := by\n  have := fun x (_ : x âˆˆ Ioi b) â†¦ hf.differentiable le_rfl x |>.hasDerivAt\n  rw [integral_Ioi_of_hasDerivAt_of_tendsto hf.continuous.continuousWithinAt this, zero_sub]\n  Â· refine hf.continuous_deriv le_rfl |>.integrable_of_hasCompactSupport h2f.deriv |>.integrableOn\n  rw [hasCompactSupport_iff_eventuallyEq, Filter.coclosedCompact_eq_cocompact] at h2f\n  exact h2f.filter_mono _root_.atTop_le_cocompact |>.tendsto\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_deriv_of_nonneg","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real â†’ Real\na l : Real\nhcont : ContinuousWithinAt g (Set.Ici a) a\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivAt g (g' x) x\ng'pos : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ LE.le 0 (g' x)\nhg : Filter.Tendsto g Filter.atTop (nhds l)\nâŠ¢ MeasureTheory.IntegrableOn g' (Set.Ioi a) MeasureTheory.MeasureSpace.volume","decl":"/-- When a function has a limit at infinity, and its derivative is nonnegative, then the derivative\nis automatically integrable on `(a, +âˆ)`. Version assuming differentiability\non `(a, +âˆ)` and continuity at `aâº`. -/\ntheorem integrableOn_Ioi_deriv_of_nonneg (hcont : ContinuousWithinAt g (Ici a) a)\n    (hderiv : âˆ€ x âˆˆ Ioi a, HasDerivAt g (g' x) x) (g'pos : âˆ€ x âˆˆ Ioi a, 0 â‰¤ g' x)\n    (hg : Tendsto g atTop (ğ“ l)) : IntegrableOn g' (Ioi a) := by\n  have hcont : ContinuousOn g (Ici a) := by\n    intro x hx\n    rcases hx.out.eq_or_lt with rfl|hx\n    Â· exact hcont\n    Â· exact (hderiv x hx).continuousAt.continuousWithinAt\n  refine integrableOn_Ioi_of_intervalIntegral_norm_tendsto (l - g a) a (fun x => ?_) tendsto_id ?_\n  Â· exact intervalIntegral.integrableOn_deriv_of_nonneg (hcont.mono Icc_subset_Ici_self)\n      (fun y hy => hderiv y hy.1) fun y hy => g'pos y hy.1\n  apply Tendsto.congr' _ (hg.sub_const _)\n  filter_upwards [Ioi_mem_atTop a] with x hx\n  have h'x : a â‰¤ id x := le_of_lt hx\n  calc\n    g x - g a = âˆ« y in a..id x, g' y := by\n      symm\n      apply intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le h'x\n        (hcont.mono Icc_subset_Ici_self) fun y hy => hderiv y hy.1\n      rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x]\n      exact intervalIntegral.integrableOn_deriv_of_nonneg (hcont.mono Icc_subset_Ici_self)\n        (fun y hy => hderiv y hy.1) fun y hy => g'pos y hy.1\n    _ = âˆ« y in a..id x, â€–g' yâ€– := by\n      simp_rw [intervalIntegral.integral_of_le h'x]\n      refine setIntegral_congr_fun measurableSet_Ioc fun y hy => ?_\n      dsimp\n      rw [abs_of_nonneg]\n      exact g'pos _ hy.1\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_deriv_of_nonneg'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real â†’ Real\na l : Real\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Ici a) x â†’ HasDerivAt g (g' x) x\ng'pos : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ LE.le 0 (g' x)\nhg : Filter.Tendsto g Filter.atTop (nhds l)\nâŠ¢ MeasureTheory.IntegrableOn g' (Set.Ioi a) MeasureTheory.MeasureSpace.volume","decl":"/-- When a function has a limit at infinity, and its derivative is nonnegative, then the derivative\nis automatically integrable on `(a, +âˆ)`. Version assuming differentiability\non `[a, +âˆ)`. -/\ntheorem integrableOn_Ioi_deriv_of_nonneg' (hderiv : âˆ€ x âˆˆ Ici a, HasDerivAt g (g' x) x)\n    (g'pos : âˆ€ x âˆˆ Ioi a, 0 â‰¤ g' x) (hg : Tendsto g atTop (ğ“ l)) : IntegrableOn g' (Ioi a) := by\n  refine integrableOn_Ioi_deriv_of_nonneg ?_ (fun x hx => hderiv x hx.out.le) g'pos hg\n  exact (hderiv a left_mem_Ici).continuousAt.continuousWithinAt\n\n"}
{"name":"MeasureTheory.integral_Ioi_of_hasDerivAt_of_nonneg","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real â†’ Real\na l : Real\nhcont : ContinuousWithinAt g (Set.Ici a) a\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivAt g (g' x) x\ng'pos : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ LE.le 0 (g' x)\nhg : Filter.Tendsto g Filter.atTop (nhds l)\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => g' x) (HSub.hSub l (g a))","decl":"/-- When a function has a limit at infinity `l`, and its derivative is nonnegative, then the\nintegral of the derivative on `(a, +âˆ)` is `l - g a` (and the derivative is integrable, see\n`integrable_on_Ioi_deriv_of_nonneg`). Version assuming differentiability on `(a, +âˆ)` and\ncontinuity at `aâº`. -/\ntheorem integral_Ioi_of_hasDerivAt_of_nonneg (hcont : ContinuousWithinAt g (Ici a) a)\n    (hderiv : âˆ€ x âˆˆ Ioi a, HasDerivAt g (g' x) x) (g'pos : âˆ€ x âˆˆ Ioi a, 0 â‰¤ g' x)\n    (hg : Tendsto g atTop (ğ“ l)) : âˆ« x in Ioi a, g' x = l - g a :=\n  integral_Ioi_of_hasDerivAt_of_tendsto hcont hderiv\n    (integrableOn_Ioi_deriv_of_nonneg hcont hderiv g'pos hg) hg\n\n"}
{"name":"MeasureTheory.integral_Ioi_of_hasDerivAt_of_nonneg'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real â†’ Real\na l : Real\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Ici a) x â†’ HasDerivAt g (g' x) x\ng'pos : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ LE.le 0 (g' x)\nhg : Filter.Tendsto g Filter.atTop (nhds l)\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => g' x) (HSub.hSub l (g a))","decl":"/-- When a function has a limit at infinity `l`, and its derivative is nonnegative, then the\nintegral of the derivative on `(a, +âˆ)` is `l - g a` (and the derivative is integrable, see\n`integrable_on_Ioi_deriv_of_nonneg'`). Version assuming differentiability on `[a, +âˆ)`. -/\ntheorem integral_Ioi_of_hasDerivAt_of_nonneg' (hderiv : âˆ€ x âˆˆ Ici a, HasDerivAt g (g' x) x)\n    (g'pos : âˆ€ x âˆˆ Ioi a, 0 â‰¤ g' x) (hg : Tendsto g atTop (ğ“ l)) : âˆ« x in Ioi a, g' x = l - g a :=\n  integral_Ioi_of_hasDerivAt_of_tendsto' hderiv (integrableOn_Ioi_deriv_of_nonneg' hderiv g'pos hg)\n    hg\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_deriv_of_nonpos","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real â†’ Real\na l : Real\nhcont : ContinuousWithinAt g (Set.Ici a) a\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivAt g (g' x) x\ng'neg : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ LE.le (g' x) 0\nhg : Filter.Tendsto g Filter.atTop (nhds l)\nâŠ¢ MeasureTheory.IntegrableOn g' (Set.Ioi a) MeasureTheory.MeasureSpace.volume","decl":"/-- When a function has a limit at infinity, and its derivative is nonpositive, then the derivative\nis automatically integrable on `(a, +âˆ)`. Version assuming differentiability\non `(a, +âˆ)` and continuity at `aâº`. -/\ntheorem integrableOn_Ioi_deriv_of_nonpos (hcont : ContinuousWithinAt g (Ici a) a)\n    (hderiv : âˆ€ x âˆˆ Ioi a, HasDerivAt g (g' x) x) (g'neg : âˆ€ x âˆˆ Ioi a, g' x â‰¤ 0)\n    (hg : Tendsto g atTop (ğ“ l)) : IntegrableOn g' (Ioi a) := by\n  apply integrable_neg_iff.1\n  exact integrableOn_Ioi_deriv_of_nonneg hcont.neg (fun x hx => (hderiv x hx).neg)\n    (fun x hx => neg_nonneg_of_nonpos (g'neg x hx)) hg.neg\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_deriv_of_nonpos'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real â†’ Real\na l : Real\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Ici a) x â†’ HasDerivAt g (g' x) x\ng'neg : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ LE.le (g' x) 0\nhg : Filter.Tendsto g Filter.atTop (nhds l)\nâŠ¢ MeasureTheory.IntegrableOn g' (Set.Ioi a) MeasureTheory.MeasureSpace.volume","decl":"/-- When a function has a limit at infinity, and its derivative is nonpositive, then the derivative\nis automatically integrable on `(a, +âˆ)`. Version assuming differentiability\non `[a, +âˆ)`. -/\ntheorem integrableOn_Ioi_deriv_of_nonpos' (hderiv : âˆ€ x âˆˆ Ici a, HasDerivAt g (g' x) x)\n    (g'neg : âˆ€ x âˆˆ Ioi a, g' x â‰¤ 0) (hg : Tendsto g atTop (ğ“ l)) : IntegrableOn g' (Ioi a) := by\n  refine integrableOn_Ioi_deriv_of_nonpos ?_ (fun x hx â†¦ hderiv x hx.out.le) g'neg hg\n  exact (hderiv a left_mem_Ici).continuousAt.continuousWithinAt\n\n"}
{"name":"MeasureTheory.integral_Ioi_of_hasDerivAt_of_nonpos","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real â†’ Real\na l : Real\nhcont : ContinuousWithinAt g (Set.Ici a) a\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivAt g (g' x) x\ng'neg : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ LE.le (g' x) 0\nhg : Filter.Tendsto g Filter.atTop (nhds l)\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => g' x) (HSub.hSub l (g a))","decl":"/-- When a function has a limit at infinity `l`, and its derivative is nonpositive, then the\nintegral of the derivative on `(a, +âˆ)` is `l - g a` (and the derivative is integrable, see\n`integrable_on_Ioi_deriv_of_nonneg`). Version assuming differentiability on `(a, +âˆ)` and\ncontinuity at `aâº`. -/\ntheorem integral_Ioi_of_hasDerivAt_of_nonpos (hcont : ContinuousWithinAt g (Ici a) a)\n    (hderiv : âˆ€ x âˆˆ Ioi a, HasDerivAt g (g' x) x) (g'neg : âˆ€ x âˆˆ Ioi a, g' x â‰¤ 0)\n    (hg : Tendsto g atTop (ğ“ l)) : âˆ« x in Ioi a, g' x = l - g a :=\n  integral_Ioi_of_hasDerivAt_of_tendsto hcont hderiv\n    (integrableOn_Ioi_deriv_of_nonpos hcont hderiv g'neg hg) hg\n\n"}
{"name":"MeasureTheory.integral_Ioi_of_hasDerivAt_of_nonpos'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real â†’ Real\na l : Real\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Ici a) x â†’ HasDerivAt g (g' x) x\ng'neg : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ LE.le (g' x) 0\nhg : Filter.Tendsto g Filter.atTop (nhds l)\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => g' x) (HSub.hSub l (g a))","decl":"/-- When a function has a limit at infinity `l`, and its derivative is nonpositive, then the\nintegral of the derivative on `(a, +âˆ)` is `l - g a` (and the derivative is integrable, see\n`integrable_on_Ioi_deriv_of_nonneg'`). Version assuming differentiability on `[a, +âˆ)`. -/\ntheorem integral_Ioi_of_hasDerivAt_of_nonpos' (hderiv : âˆ€ x âˆˆ Ici a, HasDerivAt g (g' x) x)\n    (g'neg : âˆ€ x âˆˆ Ioi a, g' x â‰¤ 0) (hg : Tendsto g atTop (ğ“ l)) : âˆ« x in Ioi a, g' x = l - g a :=\n  integral_Ioi_of_hasDerivAt_of_tendsto' hderiv (integrableOn_Ioi_deriv_of_nonpos' hderiv g'neg hg)\n    hg\n\n"}
{"name":"MeasureTheory.tendsto_limUnder_of_hasDerivAt_of_integrableOn_Iic","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real â†’ E\na : Real\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Iic a) x â†’ HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Iic a) MeasureTheory.MeasureSpace.volume\nâŠ¢ Filter.Tendsto f Filter.atBot (nhds (limUnder Filter.atBot f))","decl":"/-- If the derivative of a function defined on the real line is integrable close to `-âˆ`, then\nthe function has a limit at `-âˆ`. -/\ntheorem tendsto_limUnder_of_hasDerivAt_of_integrableOn_Iic [CompleteSpace E]\n    (hderiv : âˆ€ x âˆˆ Iic a, HasDerivAt f (f' x) x) (f'int : IntegrableOn f' (Iic a)) :\n    Tendsto f atBot (ğ“ (limUnder atBot f)) := by\n  suffices âˆƒ a, Tendsto f atBot (ğ“ a) from tendsto_nhds_limUnder this\n  let g := f âˆ˜ (fun x â†¦ -x)\n  have hdg : âˆ€ x âˆˆ Ioi (-a), HasDerivAt g (-f' (-x)) x := by\n    intro x hx\n    have : -x âˆˆ Iic a := by simp only [mem_Iic, mem_Ioi, neg_le] at *; exact hx.le\n    simpa using HasDerivAt.scomp x (hderiv (-x) this) (hasDerivAt_neg' x)\n  have L : Tendsto g atTop (ğ“ (limUnder atTop g)) := by\n    apply tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi hdg\n    exact ((MeasurePreserving.integrableOn_comp_preimage (Measure.measurePreserving_neg _)\n      (Homeomorph.neg â„).measurableEmbedding).2 f'int.neg).mono_set (by simp)\n  refine âŸ¨limUnder atTop g, ?_âŸ©\n  have : Tendsto (fun x â†¦ g (-x)) atBot (ğ“ (limUnder atTop g)) := L.comp tendsto_neg_atBot_atTop\n  simpa [g] using this\n\n"}
{"name":"MeasureTheory.tendsto_zero_of_hasDerivAt_of_integrableOn_Iic","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real â†’ E\na : Real\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Iic a) x â†’ HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Iic a) MeasureTheory.MeasureSpace.volume\nfint : MeasureTheory.IntegrableOn f (Set.Iic a) MeasureTheory.MeasureSpace.volume\nâŠ¢ Filter.Tendsto f Filter.atBot (nhds 0)","decl":"open UniformSpace in\n/-- If a function and its derivative are integrable on `(-âˆ, a]`, then the function tends to zero\nat `-âˆ`. -/\ntheorem tendsto_zero_of_hasDerivAt_of_integrableOn_Iic\n    (hderiv : âˆ€ x âˆˆ Iic a, HasDerivAt f (f' x) x)\n    (f'int : IntegrableOn f' (Iic a)) (fint : IntegrableOn f (Iic a)) :\n    Tendsto f atBot (ğ“ 0) := by\n  let F : E â†’L[â„] Completion E := Completion.toComplL\n  have Fderiv : âˆ€ x âˆˆ Iic a, HasDerivAt (F âˆ˜ f) (F (f' x)) x :=\n    fun x hx â†¦ F.hasFDerivAt.comp_hasDerivAt _ (hderiv x hx)\n  have Fint : IntegrableOn (F âˆ˜ f) (Iic a) := by apply F.integrable_comp fint\n  have F'int : IntegrableOn (F âˆ˜ f') (Iic a) := by apply F.integrable_comp f'int\n  have A : Tendsto (F âˆ˜ f) atBot (ğ“ (limUnder atBot (F âˆ˜ f))) := by\n    apply tendsto_limUnder_of_hasDerivAt_of_integrableOn_Iic Fderiv F'int\n  have B : limUnder atBot (F âˆ˜ f) = F 0 := by\n    have : IntegrableAtFilter (F âˆ˜ f) atBot := by exact âŸ¨Iic a, Iic_mem_atBot _, FintâŸ©\n    apply IntegrableAtFilter.eq_zero_of_tendsto this ?_ A\n    intro s hs\n    rcases mem_atBot_sets.1 hs with âŸ¨b, hbâŸ©\n    apply le_antisymm (le_top)\n    rw [â† volume_Iic (a := b)]\n    exact measure_mono hb\n  rwa [B, â† IsEmbedding.tendsto_nhds_iff] at A\n  exact (Completion.isUniformEmbedding_coe E).isEmbedding\n\n"}
{"name":"MeasureTheory.integral_Iic_of_hasDerivAt_of_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real â†’ E\na : Real\nm : E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhcont : ContinuousWithinAt f (Set.Iic a) a\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Iio a) x â†’ HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Iic a) MeasureTheory.MeasureSpace.volume\nhf : Filter.Tendsto f Filter.atBot (nhds m)\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic a)) fun x => f' x) (HSub.hSub (f a) m)","decl":"/-- **Fundamental theorem of calculus-2**, on semi-infinite intervals `(-âˆ, a)`.\nWhen a function has a limit `m` at `-âˆ`, and its derivative is integrable, then the\nintegral of the derivative on `(-âˆ, a)` is `f a - m`. Version assuming differentiability\non `(-âˆ, a)` and continuity at `aâ»`.\n\nNote that such a function always has a limit at minus infinity,\nsee `tendsto_limUnder_of_hasDerivAt_of_integrableOn_Iic`. -/\ntheorem integral_Iic_of_hasDerivAt_of_tendsto (hcont : ContinuousWithinAt f (Iic a) a)\n    (hderiv : âˆ€ x âˆˆ Iio a, HasDerivAt f (f' x) x) (f'int : IntegrableOn f' (Iic a))\n    (hf : Tendsto f atBot (ğ“ m)) : âˆ« x in Iic a, f' x = f a - m := by\n  have hcont : ContinuousOn f (Iic a) := by\n    intro x hx\n    rcases hx.out.eq_or_lt with rfl|hx\n    Â· exact hcont\n    Â· exact (hderiv x hx).continuousAt.continuousWithinAt\n  refine tendsto_nhds_unique (intervalIntegral_tendsto_integral_Iic a f'int tendsto_id) ?_\n  apply Tendsto.congr' _ (hf.const_sub _)\n  filter_upwards [Iic_mem_atBot a] with x hx\n  symm\n  apply intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le hx\n    (hcont.mono Icc_subset_Iic_self) fun y hy => hderiv y hy.2\n  rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hx]\n  exact f'int.mono (fun y hy => hy.2) le_rfl\n\n"}
{"name":"MeasureTheory.integral_Iic_of_hasDerivAt_of_tendsto'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real â†’ E\na : Real\nm : E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhderiv : âˆ€ (x : Real), Membership.mem (Set.Iic a) x â†’ HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Iic a) MeasureTheory.MeasureSpace.volume\nhf : Filter.Tendsto f Filter.atBot (nhds m)\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic a)) fun x => f' x) (HSub.hSub (f a) m)","decl":"/-- **Fundamental theorem of calculus-2**, on semi-infinite intervals `(-âˆ, a)`.\nWhen a function has a limit `m` at `-âˆ`, and its derivative is integrable, then the\nintegral of the derivative on `(-âˆ, a)` is `f a - m`. Version assuming differentiability\non `(-âˆ, a]`.\n\nNote that such a function always has a limit at minus infinity,\nsee `tendsto_limUnder_of_hasDerivAt_of_integrableOn_Iic`. -/\ntheorem integral_Iic_of_hasDerivAt_of_tendsto'\n    (hderiv : âˆ€ x âˆˆ Iic a, HasDerivAt f (f' x) x) (f'int : IntegrableOn f' (Iic a))\n    (hf : Tendsto f atBot (ğ“ m)) : âˆ« x in Iic a, f' x = f a - m := by\n  refine integral_Iic_of_hasDerivAt_of_tendsto ?_ (fun x hx => hderiv x hx.out.le)\n    f'int hf\n  exact (hderiv a right_mem_Iic).continuousAt.continuousWithinAt\n\n"}
{"name":"HasCompactSupport.integral_Iic_deriv_eq","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf : Real â†’ E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhf : ContDiff Real 1 f\nh2f : HasCompactSupport f\nb : Real\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic b)) fun x => deriv f x) (f b)","decl":"/-- A special case of `integral_Iic_of_hasDerivAt_of_tendsto` where we assume that `f` is C^1 with\ncompact support. -/\ntheorem _root_.HasCompactSupport.integral_Iic_deriv_eq (hf : ContDiff â„ 1 f)\n    (h2f : HasCompactSupport f) (b : â„) : âˆ« x in Iic b, deriv f x = f b := by\n  have := fun x (_ : x âˆˆ Iio b) â†¦ hf.differentiable le_rfl x |>.hasDerivAt\n  rw [integral_Iic_of_hasDerivAt_of_tendsto hf.continuous.continuousWithinAt this, sub_zero]\n  Â· refine hf.continuous_deriv le_rfl |>.integrable_of_hasCompactSupport h2f.deriv |>.integrableOn\n  rw [hasCompactSupport_iff_eventuallyEq, Filter.coclosedCompact_eq_cocompact] at h2f\n  exact h2f.filter_mono _root_.atBot_le_cocompact |>.tendsto\n\n"}
{"name":"HasCompactSupport.enorm_le_lintegral_Ici_deriv","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"F : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Real â†’ F\nhf : ContDiff Real 1 f\nh'f : HasCompactSupport f\nx : Real\nâŠ¢ LE.le (ENorm.enorm (f x)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic x)) fun y => ENorm.enorm (deriv f y))","decl":"open UniformSpace in\nlemma _root_.HasCompactSupport.enorm_le_lintegral_Ici_deriv\n    {F : Type*} [NormedAddCommGroup F] [NormedSpace â„ F]\n    {f : â„ â†’ F} (hf : ContDiff â„ 1 f) (h'f : HasCompactSupport f) (x : â„) :\n    â€–f xâ€–â‚‘ â‰¤ âˆ«â» y in Iic x, â€–deriv f yâ€–â‚‘ := by\n  let I : F â†’L[â„] Completion F := Completion.toComplL\n  let f' : â„ â†’ Completion F := I âˆ˜ f\n  have hf' : ContDiff â„ 1 f' := hf.continuousLinearMap_comp I\n  have h'f' : HasCompactSupport f' := h'f.comp_left rfl\n  have : â€–f' xâ€–â‚‘ â‰¤ âˆ«â» y in Iic x, â€–deriv f' yâ€–â‚‘ := by\n    rw [â† HasCompactSupport.integral_Iic_deriv_eq hf' h'f' x]\n    exact enorm_integral_le_lintegral_enorm _\n  convert this with y\n  Â· simp [f', I, Completion.enorm_coe]\n  Â· rw [fderiv_comp_deriv _ I.differentiableAt (hf.differentiable le_rfl _)]\n    simp only [ContinuousLinearMap.fderiv]\n    simp [I]\n\n"}
{"name":"HasCompactSupport.ennnorm_le_lintegral_Ici_deriv","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"F : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Real â†’ F\nhf : ContDiff Real 1 f\nh'f : HasCompactSupport f\nx : Real\nâŠ¢ LE.le (ENorm.enorm (f x)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic x)) fun y => ENorm.enorm (deriv f y))","decl":"@[deprecated (since := \"2025-01-22\")]\nalias _root_.HasCompactSupport.ennnorm_le_lintegral_Ici_deriv :=\n  HasCompactSupport.enorm_le_lintegral_Ici_deriv\n\n"}
{"name":"MeasureTheory.integral_of_hasDerivAt_of_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real â†’ E\nm n : E\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhderiv : âˆ€ (x : Real), HasDerivAt f (f' x) x\nhf' : MeasureTheory.Integrable f' MeasureTheory.MeasureSpace.volume\nhbot : Filter.Tendsto f Filter.atBot (nhds m)\nhtop : Filter.Tendsto f Filter.atTop (nhds n)\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f' x) (HSub.hSub n m)","decl":"/-- **Fundamental theorem of calculus-2**, on the whole real line\nWhen a function has a limit `m` at `-âˆ` and `n` at `+âˆ`, and its derivative is integrable, then the\nintegral of the derivative is `n - m`.\n\nNote that such a function always has a limit at `-âˆ` and `+âˆ`,\nsee `tendsto_limUnder_of_hasDerivAt_of_integrableOn_Iic` and\n`tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi`. -/\ntheorem integral_of_hasDerivAt_of_tendsto [CompleteSpace E]\n    (hderiv : âˆ€ x, HasDerivAt f (f' x) x) (hf' : Integrable f')\n    (hbot : Tendsto f atBot (ğ“ m)) (htop : Tendsto f atTop (ğ“ n)) : âˆ« x, f' x = n - m := by\n  rw [â† setIntegral_univ, â† Set.Iic_union_Ioi (a := 0),\n    setIntegral_union (Iic_disjoint_Ioi le_rfl) measurableSet_Ioi hf'.integrableOn hf'.integrableOn,\n    integral_Iic_of_hasDerivAt_of_tendsto' (fun x _ â†¦ hderiv x) hf'.integrableOn hbot,\n    integral_Ioi_of_hasDerivAt_of_tendsto' (fun x _ â†¦ hderiv x) hf'.integrableOn htop]\n  abel\n\n"}
{"name":"MeasureTheory.integral_eq_zero_of_hasDerivAt_of_integrable","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real â†’ E\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nhderiv : âˆ€ (x : Real), HasDerivAt f (f' x) x\nhf' : MeasureTheory.Integrable f' MeasureTheory.MeasureSpace.volume\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f' x) 0","decl":"/-- If a function and its derivative are integrable on the real line, then the integral of the\nderivative is zero. -/\ntheorem integral_eq_zero_of_hasDerivAt_of_integrable\n    (hderiv : âˆ€ x, HasDerivAt f (f' x) x) (hf' : Integrable f') (hf : Integrable f) :\n    âˆ« x, f' x = 0 := by\n  by_cases hE : CompleteSpace E; swap\n  Â· simp [integral, hE]\n  have A : Tendsto f atBot (ğ“ 0) :=\n    tendsto_zero_of_hasDerivAt_of_integrableOn_Iic (a := 0) (fun x _hx â†¦ hderiv x)\n      hf'.integrableOn hf.integrableOn\n  have B : Tendsto f atTop (ğ“ 0) :=\n    tendsto_zero_of_hasDerivAt_of_integrableOn_Ioi (a := 0) (fun x _hx â†¦ hderiv x)\n      hf'.integrableOn hf.integrableOn\n  simpa using integral_of_hasDerivAt_of_tendsto hderiv hf' A B\n\n"}
{"name":"MeasureTheory.integral_comp_smul_deriv_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf f' : Real â†’ Real\ng : Real â†’ E\na : Real\nhf : ContinuousOn f (Set.Ici a)\nhft : Filter.Tendsto f Filter.atTop Filter.atTop\nhff' : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivWithinAt f (f' x) (Set.Ioi x) x\nhg_cont : ContinuousOn g (Set.image f (Set.Ioi a))\nhg1 : MeasureTheory.IntegrableOn g (Set.image f (Set.Ici a)) MeasureTheory.MeasureSpace.volume\nhg2 : MeasureTheory.IntegrableOn (fun x => HSMul.hSMul (f' x) (Function.comp g f x)) (Set.Ici a) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => HSMul.hSMul (f' x) (Function.comp g f x)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi (f a))) fun u => g u)","decl":"/-- Change-of-variables formula for `Ioi` integrals of vector-valued functions, proved by taking\nlimits from the result for finite intervals. -/\ntheorem integral_comp_smul_deriv_Ioi {f f' : â„ â†’ â„} {g : â„ â†’ E} {a : â„}\n    (hf : ContinuousOn f <| Ici a) (hft : Tendsto f atTop atTop)\n    (hff' : âˆ€ x âˆˆ Ioi a, HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hg_cont : ContinuousOn g <| f '' Ioi a) (hg1 : IntegrableOn g <| f '' Ici a)\n    (hg2 : IntegrableOn (fun x => f' x â€¢ (g âˆ˜ f) x) (Ici a)) :\n    (âˆ« x in Ioi a, f' x â€¢ (g âˆ˜ f) x) = âˆ« u in Ioi (f a), g u := by\n  have eq : âˆ€ b : â„, a < b â†’ (âˆ« x in a..b, f' x â€¢ (g âˆ˜ f) x) = âˆ« u in f a..f b, g u := fun b hb â†¦ by\n    have i1 : Ioo (min a b) (max a b) âŠ† Ioi a := by\n      rw [min_eq_left hb.le]\n      exact Ioo_subset_Ioi_self\n    have i2 : [[a, b]] âŠ† Ici a := by rw [uIcc_of_le hb.le]; exact Icc_subset_Ici_self\n    refine\n      intervalIntegral.integral_comp_smul_deriv''' (hf.mono i2)\n        (fun x hx => hff' x <| mem_of_mem_of_subset hx i1) (hg_cont.mono <| image_subset _ ?_)\n        (hg1.mono_set <| image_subset _ ?_) (hg2.mono_set i2)\n    Â· rw [min_eq_left hb.le]; exact Ioo_subset_Ioi_self\n    Â· rw [uIcc_of_le hb.le]; exact Icc_subset_Ici_self\n  rw [integrableOn_Ici_iff_integrableOn_Ioi] at hg2\n  have t2 := intervalIntegral_tendsto_integral_Ioi _ hg2 tendsto_id\n  have : Ioi (f a) âŠ† f '' Ici a :=\n    Ioi_subset_Ici_self.trans <|\n      IsPreconnected.intermediate_value_Ici isPreconnected_Ici left_mem_Ici\n        (le_principal_iff.mpr <| Ici_mem_atTop _) hf hft\n  have t1 := (intervalIntegral_tendsto_integral_Ioi _ (hg1.mono_set this) tendsto_id).comp hft\n  exact tendsto_nhds_unique (Tendsto.congr' (eventuallyEq_of_mem (Ioi_mem_atTop a) eq) t2) t1\n\n"}
{"name":"MeasureTheory.integral_comp_mul_deriv_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"f f' g : Real â†’ Real\na : Real\nhf : ContinuousOn f (Set.Ici a)\nhft : Filter.Tendsto f Filter.atTop Filter.atTop\nhff' : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivWithinAt f (f' x) (Set.Ioi x) x\nhg_cont : ContinuousOn g (Set.image f (Set.Ioi a))\nhg1 : MeasureTheory.IntegrableOn g (Set.image f (Set.Ici a)) MeasureTheory.MeasureSpace.volume\nhg2 : MeasureTheory.IntegrableOn (fun x => HMul.hMul (Function.comp g f x) (f' x)) (Set.Ici a) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => HMul.hMul (Function.comp g f x) (f' x)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi (f a))) fun u => g u)","decl":"/-- Change-of-variables formula for `Ioi` integrals of scalar-valued functions -/\ntheorem integral_comp_mul_deriv_Ioi {f f' : â„ â†’ â„} {g : â„ â†’ â„} {a : â„}\n    (hf : ContinuousOn f <| Ici a) (hft : Tendsto f atTop atTop)\n    (hff' : âˆ€ x âˆˆ Ioi a, HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hg_cont : ContinuousOn g <| f '' Ioi a) (hg1 : IntegrableOn g <| f '' Ici a)\n    (hg2 : IntegrableOn (fun x => (g âˆ˜ f) x * f' x) (Ici a)) :\n    (âˆ« x in Ioi a, (g âˆ˜ f) x * f' x) = âˆ« u in Ioi (f a), g u := by\n  have hg2' : IntegrableOn (fun x => f' x â€¢ (g âˆ˜ f) x) (Ici a) := by simpa [mul_comm] using hg2\n  simpa [mul_comm] using integral_comp_smul_deriv_Ioi hf hft hff' hg_cont hg1 hg2'\n\n"}
{"name":"MeasureTheory.integral_comp_rpow_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\ng : Real â†’ E\np : Real\nhp : Ne p 0\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun x => HSMul.hSMul (HMul.hMul (abs p) (HPow.hPow x (HSub.hSub p 1))) (g (HPow.hPow x p))) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun y => g y)","decl":"/-- Substitution `y = x ^ p` in integrals over `Ioi 0` -/\ntheorem integral_comp_rpow_Ioi (g : â„ â†’ E) {p : â„} (hp : p â‰  0) :\n    (âˆ« x in Ioi 0, (|p| * x ^ (p - 1)) â€¢ g (x ^ p)) = âˆ« y in Ioi 0, g y := by\n  let S := Ioi (0 : â„)\n  have a1 : âˆ€ x : â„, x âˆˆ S â†’ HasDerivWithinAt (fun t : â„ => t ^ p) (p * x ^ (p - 1)) S x :=\n    fun x hx => (hasDerivAt_rpow_const (Or.inl (mem_Ioi.mp hx).ne')).hasDerivWithinAt\n  have a2 : InjOn (fun x : â„ => x ^ p) S := by\n    rcases lt_or_gt_of_ne hp with (h | h)\n    Â· apply StrictAntiOn.injOn\n      intro x hx y hy hxy\n      rw [â† inv_lt_invâ‚€ (rpow_pos_of_pos hx p) (rpow_pos_of_pos hy p), â† rpow_neg (le_of_lt hx),\n        â† rpow_neg (le_of_lt hy)]\n      exact rpow_lt_rpow (le_of_lt hx) hxy (neg_pos.mpr h)\n    exact StrictMonoOn.injOn fun x hx y _ hxy => rpow_lt_rpow (mem_Ioi.mp hx).le hxy h\n  have a3 : (fun t : â„ => t ^ p) '' S = S := by\n    ext1 x; rw [mem_image]; constructor\n    Â· rintro âŸ¨y, hy, rflâŸ©; exact rpow_pos_of_pos hy p\n    Â· intro hx; refine âŸ¨x ^ (1 / p), rpow_pos_of_pos hx _, ?_âŸ©\n      rw [â† rpow_mul (le_of_lt hx), one_div_mul_cancel hp, rpow_one]\n  have := integral_image_eq_integral_abs_deriv_smul measurableSet_Ioi a1 a2 g\n  rw [a3] at this; rw [this]\n  refine setIntegral_congr_fun measurableSet_Ioi ?_\n  intro x hx; dsimp only\n  rw [abs_mul, abs_of_nonneg (rpow_nonneg (le_of_lt hx) _)]\n\n"}
{"name":"MeasureTheory.integral_comp_rpow_Ioi_of_pos","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\ng : Real â†’ E\np : Real\nhp : LT.lt 0 p\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun x => HSMul.hSMul (HMul.hMul p (HPow.hPow x (HSub.hSub p 1))) (g (HPow.hPow x p))) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun y => g y)","decl":"theorem integral_comp_rpow_Ioi_of_pos {g : â„ â†’ E} {p : â„} (hp : 0 < p) :\n    (âˆ« x in Ioi 0, (p * x ^ (p - 1)) â€¢ g (x ^ p)) = âˆ« y in Ioi 0, g y := by\n  convert integral_comp_rpow_Ioi g hp.ne'\n  rw [abs_of_nonneg hp.le]\n\n"}
{"name":"MeasureTheory.integral_comp_mul_left_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\ng : Real â†’ E\na b : Real\nhb : LT.lt 0 b\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => g (HMul.hMul b x)) (HSMul.hSMul (Inv.inv b) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi (HMul.hMul b a))) fun x => g x))","decl":"theorem integral_comp_mul_left_Ioi (g : â„ â†’ E) (a : â„) {b : â„} (hb : 0 < b) :\n    (âˆ« x in Ioi a, g (b * x)) = bâ»Â¹ â€¢ âˆ« x in Ioi (b * a), g x := by\n  have : âˆ€ c : â„, MeasurableSet (Ioi c) := fun c => measurableSet_Ioi\n  rw [â† integral_indicator (this a), â† integral_indicator (this (b * a)),\n    â† abs_of_pos (inv_pos.mpr hb), â† Measure.integral_comp_mul_left]\n  congr\n  ext1 x\n  rw [â† indicator_comp_right, preimage_const_mul_Ioi _ hb, mul_div_cancel_leftâ‚€ _ hb.ne']\n  rfl\n\n"}
{"name":"MeasureTheory.integral_comp_mul_right_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\ng : Real â†’ E\na b : Real\nhb : LT.lt 0 b\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => g (HMul.hMul x b)) (HSMul.hSMul (Inv.inv b) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi (HMul.hMul a b))) fun x => g x))","decl":"theorem integral_comp_mul_right_Ioi (g : â„ â†’ E) (a : â„) {b : â„} (hb : 0 < b) :\n    (âˆ« x in Ioi a, g (x * b)) = bâ»Â¹ â€¢ âˆ« x in Ioi (a * b), g x := by\n  simpa only [mul_comm] using integral_comp_mul_left_Ioi g a hb\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_comp_rpow_iff","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\np : Real\nhp : Ne p 0\nâŠ¢ Iff (MeasureTheory.IntegrableOn (fun x => HSMul.hSMul (HMul.hMul (abs p) (HPow.hPow x (HSub.hSub p 1))) (f (HPow.hPow x p))) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume) (MeasureTheory.IntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume)","decl":"/-- The substitution `y = x ^ p` in integrals over `Ioi 0` preserves integrability. -/\ntheorem integrableOn_Ioi_comp_rpow_iff [NormedSpace â„ E] (f : â„ â†’ E) {p : â„} (hp : p â‰  0) :\n    IntegrableOn (fun x => (|p| * x ^ (p - 1)) â€¢ f (x ^ p)) (Ioi 0) â†” IntegrableOn f (Ioi 0) := by\n  let S := Ioi (0 : â„)\n  have a1 : âˆ€ x : â„, x âˆˆ S â†’ HasDerivWithinAt (fun t : â„ => t ^ p) (p * x ^ (p - 1)) S x :=\n    fun x hx => (hasDerivAt_rpow_const (Or.inl (mem_Ioi.mp hx).ne')).hasDerivWithinAt\n  have a2 : InjOn (fun x : â„ => x ^ p) S := by\n    rcases lt_or_gt_of_ne hp with (h | h)\n    Â· apply StrictAntiOn.injOn\n      intro x hx y hy hxy\n      rw [â† inv_lt_invâ‚€ (rpow_pos_of_pos hx p) (rpow_pos_of_pos hy p), â† rpow_neg (le_of_lt hx), â†\n        rpow_neg (le_of_lt hy)]\n      exact rpow_lt_rpow (le_of_lt hx) hxy (neg_pos.mpr h)\n    exact StrictMonoOn.injOn fun x hx y _hy hxy => rpow_lt_rpow (mem_Ioi.mp hx).le hxy h\n  have a3 : (fun t : â„ => t ^ p) '' S = S := by\n    ext1 x; rw [mem_image]; constructor\n    Â· rintro âŸ¨y, hy, rflâŸ©; exact rpow_pos_of_pos hy p\n    Â· intro hx; refine âŸ¨x ^ (1 / p), rpow_pos_of_pos hx _, ?_âŸ©\n      rw [â† rpow_mul (le_of_lt hx), one_div_mul_cancel hp, rpow_one]\n  have := integrableOn_image_iff_integrableOn_abs_deriv_smul measurableSet_Ioi a1 a2 f\n  rw [a3] at this\n  rw [this]\n  refine integrableOn_congr_fun (fun x hx => ?_) measurableSet_Ioi\n  simp_rw [abs_mul, abs_of_nonneg (rpow_nonneg (le_of_lt hx) _)]\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_comp_rpow_iff'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Real â†’ E\np : Real\nhp : Ne p 0\nâŠ¢ Iff (MeasureTheory.IntegrableOn (fun x => HSMul.hSMul (HPow.hPow x (HSub.hSub p 1)) (f (HPow.hPow x p))) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume) (MeasureTheory.IntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume)","decl":"/-- The substitution `y = x ^ p` in integrals over `Ioi 0` preserves integrability (version\nwithout `|p|` factor) -/\ntheorem integrableOn_Ioi_comp_rpow_iff' [NormedSpace â„ E] (f : â„ â†’ E) {p : â„} (hp : p â‰  0) :\n    IntegrableOn (fun x => x ^ (p - 1) â€¢ f (x ^ p)) (Ioi 0) â†” IntegrableOn f (Ioi 0) := by\n  simpa only [â† integrableOn_Ioi_comp_rpow_iff f hp, mul_smul] using\n    (integrable_smul_iff (abs_pos.mpr hp).ne' _).symm\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_comp_mul_left_iff","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\nc a : Real\nha : LT.lt 0 a\nâŠ¢ Iff (MeasureTheory.IntegrableOn (fun x => f (HMul.hMul a x)) (Set.Ioi c) MeasureTheory.MeasureSpace.volume) (MeasureTheory.IntegrableOn f (Set.Ioi (HMul.hMul a c)) MeasureTheory.MeasureSpace.volume)","decl":"theorem integrableOn_Ioi_comp_mul_left_iff (f : â„ â†’ E) (c : â„) {a : â„} (ha : 0 < a) :\n    IntegrableOn (fun x => f (a * x)) (Ioi c) â†” IntegrableOn f (Ioi <| a * c) := by\n  rw [â† integrable_indicator_iff (measurableSet_Ioi : MeasurableSet <| Ioi c)]\n  rw [â† integrable_indicator_iff (measurableSet_Ioi : MeasurableSet <| Ioi <| a * c)]\n  convert integrable_comp_mul_left_iff ((Ioi (a * c)).indicator f) ha.ne' using 2\n  ext1 x\n  rw [â† indicator_comp_right, preimage_const_mul_Ioi _ ha, mul_comm a c,\n    mul_div_cancel_rightâ‚€ _ ha.ne']\n  rfl\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_comp_mul_right_iff","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninstâœ : NormedAddCommGroup E\nf : Real â†’ E\nc a : Real\nha : LT.lt 0 a\nâŠ¢ Iff (MeasureTheory.IntegrableOn (fun x => f (HMul.hMul x a)) (Set.Ioi c) MeasureTheory.MeasureSpace.volume) (MeasureTheory.IntegrableOn f (Set.Ioi (HMul.hMul c a)) MeasureTheory.MeasureSpace.volume)","decl":"theorem integrableOn_Ioi_comp_mul_right_iff (f : â„ â†’ E) (c : â„) {a : â„} (ha : 0 < a) :\n    IntegrableOn (fun x => f (x * a)) (Ioi c) â†” IntegrableOn f (Ioi <| c * a) := by\n  simpa only [mul_comm, mul_zero] using integrableOn_Ioi_comp_mul_left_iff f c ha\n\n"}
{"name":"MeasureTheory.integral_bilinear_hasDerivAt_eq_sub","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace Real G\nL : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) F G)\nu : Real â†’ E\nv : Real â†’ F\nu' : Real â†’ E\nv' : Real â†’ F\nm n : G\ninstâœ : CompleteSpace G\nhu : âˆ€ (x : Real), HasDerivAt u (u' x) x\nhv : âˆ€ (x : Real), HasDerivAt v (v' x) x\nhuv : MeasureTheory.Integrable (fun x => HAdd.hAdd ((L (u x)) (v' x)) ((L (u' x)) (v x))) MeasureTheory.MeasureSpace.volume\nh_bot : Filter.Tendsto (fun x => (L (u x)) (v x)) Filter.atBot (nhds m)\nh_top : Filter.Tendsto (fun x => (L (u x)) (v x)) Filter.atTop (nhds n)\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HAdd.hAdd ((L (u x)) (v' x)) ((L (u' x)) (v x))) (HSub.hSub n m)","decl":"theorem integral_bilinear_hasDerivAt_eq_sub [CompleteSpace G]\n    (hu : âˆ€ x, HasDerivAt u (u' x) x) (hv : âˆ€ x, HasDerivAt v (v' x) x)\n    (huv : Integrable (fun x â†¦ L (u x) (v' x) + L (u' x) (v x)))\n    (h_bot : Tendsto (fun x â†¦ L (u x) (v x)) atBot (ğ“ m))\n    (h_top : Tendsto (fun x â†¦ L (u x) (v x)) atTop (ğ“ n)) :\n    âˆ« (x : â„), L (u x) (v' x) + L (u' x) (v x) = n - m :=\n  integral_of_hasDerivAt_of_tendsto (fun x â†¦ L.hasDerivAt_of_bilinear (hu x) (hv x))\n    huv h_bot h_top\n\n"}
{"name":"MeasureTheory.integral_bilinear_hasDerivAt_right_eq_sub","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace Real G\nL : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) F G)\nu : Real â†’ E\nv : Real â†’ F\nu' : Real â†’ E\nv' : Real â†’ F\nm n : G\ninstâœ : CompleteSpace G\nhu : âˆ€ (x : Real), HasDerivAt u (u' x) x\nhv : âˆ€ (x : Real), HasDerivAt v (v' x) x\nhuv' : MeasureTheory.Integrable (fun x => (L (u x)) (v' x)) MeasureTheory.MeasureSpace.volume\nhu'v : MeasureTheory.Integrable (fun x => (L (u' x)) (v x)) MeasureTheory.MeasureSpace.volume\nh_bot : Filter.Tendsto (fun x => (L (u x)) (v x)) Filter.atBot (nhds m)\nh_top : Filter.Tendsto (fun x => (L (u x)) (v x)) Filter.atTop (nhds n)\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => (L (u x)) (v' x)) (HSub.hSub (HSub.hSub n m) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => (L (u' x)) (v x)))","decl":"/-- **Integration by parts on (-âˆ, âˆ).**\nWith respect to a general bilinear form. For the specific case of multiplication, see\n`integral_mul_deriv_eq_deriv_mul`. -/\ntheorem integral_bilinear_hasDerivAt_right_eq_sub [CompleteSpace G]\n    (hu : âˆ€ x, HasDerivAt u (u' x) x) (hv : âˆ€ x, HasDerivAt v (v' x) x)\n    (huv' : Integrable (fun x â†¦ L (u x) (v' x))) (hu'v : Integrable (fun x â†¦ L (u' x) (v x)))\n    (h_bot : Tendsto (fun x â†¦ L (u x) (v x)) atBot (ğ“ m))\n    (h_top : Tendsto (fun x â†¦ L (u x) (v x)) atTop (ğ“ n)) :\n    âˆ« (x : â„), L (u x) (v' x) = n - m - âˆ« (x : â„), L (u' x) (v x) := by\n  rw [eq_sub_iff_add_eq, â† integral_add huv' hu'v]\n  exact integral_bilinear_hasDerivAt_eq_sub hu hv (huv'.add hu'v) h_bot h_top\n\n"}
{"name":"MeasureTheory.integral_bilinear_hasDerivAt_right_eq_neg_left_of_integrable","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nL : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) F G)\nu : Real â†’ E\nv : Real â†’ F\nu' : Real â†’ E\nv' : Real â†’ F\nhu : âˆ€ (x : Real), HasDerivAt u (u' x) x\nhv : âˆ€ (x : Real), HasDerivAt v (v' x) x\nhuv' : MeasureTheory.Integrable (fun x => (L (u x)) (v' x)) MeasureTheory.MeasureSpace.volume\nhu'v : MeasureTheory.Integrable (fun x => (L (u' x)) (v x)) MeasureTheory.MeasureSpace.volume\nhuv : MeasureTheory.Integrable (fun x => (L (u x)) (v x)) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => (L (u x)) (v' x)) (Neg.neg (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => (L (u' x)) (v x)))","decl":"/-- **Integration by parts on (-âˆ, âˆ).**\nWith respect to a general bilinear form, assuming moreover that the total function is integrable.\n-/\ntheorem integral_bilinear_hasDerivAt_right_eq_neg_left_of_integrable\n    (hu : âˆ€ x, HasDerivAt u (u' x) x) (hv : âˆ€ x, HasDerivAt v (v' x) x)\n    (huv' : Integrable (fun x â†¦ L (u x) (v' x))) (hu'v : Integrable (fun x â†¦ L (u' x) (v x)))\n    (huv : Integrable (fun x â†¦ L (u x) (v x))) :\n    âˆ« (x : â„), L (u x) (v' x) = - âˆ« (x : â„), L (u' x) (v x) := by\n  by_cases hG : CompleteSpace G; swap\n  Â· simp [integral, hG]\n  have I : Tendsto (fun x â†¦ L (u x) (v x)) atBot (ğ“ 0) :=\n    tendsto_zero_of_hasDerivAt_of_integrableOn_Iic (a := 0)\n      (fun x _hx â†¦ L.hasDerivAt_of_bilinear (hu x) (hv x))\n      (huv'.add hu'v).integrableOn huv.integrableOn\n  have J : Tendsto (fun x â†¦ L (u x) (v x)) atTop (ğ“ 0) :=\n    tendsto_zero_of_hasDerivAt_of_integrableOn_Ioi (a := 0)\n      (fun x _hx â†¦ L.hasDerivAt_of_bilinear (hu x) (hv x))\n      (huv'.add hu'v).integrableOn huv.integrableOn\n  simp [integral_bilinear_hasDerivAt_right_eq_sub hu hv huv' hu'v I J]\n\n"}
{"name":"MeasureTheory.integral_deriv_mul_eq_sub","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Real A\na' b' : A\nu v u' v' : Real â†’ A\ninstâœ : CompleteSpace A\nhu : âˆ€ (x : Real), HasDerivAt u (u' x) x\nhv : âˆ€ (x : Real), HasDerivAt v (v' x) x\nhuv : MeasureTheory.Integrable (HAdd.hAdd (HMul.hMul u' v) (HMul.hMul u v')) MeasureTheory.MeasureSpace.volume\nh_bot : Filter.Tendsto (HMul.hMul u v) Filter.atBot (nhds a')\nh_top : Filter.Tendsto (HMul.hMul u v) Filter.atTop (nhds b')\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HAdd.hAdd (HMul.hMul (u' x) (v x)) (HMul.hMul (u x) (v' x))) (HSub.hSub b' a')","decl":"/-- For finite intervals, see: `intervalIntegral.integral_deriv_mul_eq_sub`. -/\ntheorem integral_deriv_mul_eq_sub [CompleteSpace A]\n    (hu : âˆ€ x, HasDerivAt u (u' x) x) (hv : âˆ€ x, HasDerivAt v (v' x) x)\n    (huv : Integrable (u' * v + u * v'))\n    (h_bot : Tendsto (u * v) atBot (ğ“ a')) (h_top : Tendsto (u * v) atTop (ğ“ b')) :\n    âˆ« (x : â„), u' x * v x + u x * v' x = b' - a' :=\n  integral_of_hasDerivAt_of_tendsto (fun x â†¦ (hu x).mul (hv x)) huv h_bot h_top\n\n"}
{"name":"MeasureTheory.integral_mul_deriv_eq_deriv_mul","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Real A\na' b' : A\nu v u' v' : Real â†’ A\ninstâœ : CompleteSpace A\nhu : âˆ€ (x : Real), HasDerivAt u (u' x) x\nhv : âˆ€ (x : Real), HasDerivAt v (v' x) x\nhuv' : MeasureTheory.Integrable (HMul.hMul u v') MeasureTheory.MeasureSpace.volume\nhu'v : MeasureTheory.Integrable (HMul.hMul u' v) MeasureTheory.MeasureSpace.volume\nh_bot : Filter.Tendsto (HMul.hMul u v) Filter.atBot (nhds a')\nh_top : Filter.Tendsto (HMul.hMul u v) Filter.atTop (nhds b')\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HMul.hMul (u x) (v' x)) (HSub.hSub (HSub.hSub b' a') (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HMul.hMul (u' x) (v x)))","decl":"/-- **Integration by parts on (-âˆ, âˆ).**\nFor finite intervals, see: `intervalIntegral.integral_mul_deriv_eq_deriv_mul`. -/\ntheorem integral_mul_deriv_eq_deriv_mul [CompleteSpace A]\n    (hu : âˆ€ x, HasDerivAt u (u' x) x) (hv : âˆ€ x, HasDerivAt v (v' x) x)\n    (huv' : Integrable (u * v')) (hu'v : Integrable (u' * v))\n    (h_bot : Tendsto (u * v) atBot (ğ“ a')) (h_top : Tendsto (u * v) atTop (ğ“ b')) :\n    âˆ« (x : â„), u x * v' x = b' - a' - âˆ« (x : â„), u' x * v x :=\n  integral_bilinear_hasDerivAt_right_eq_sub (L := ContinuousLinearMap.mul â„ A)\n    hu hv huv' hu'v h_bot h_top\n\n"}
{"name":"MeasureTheory.integral_mul_deriv_eq_deriv_mul_of_integrable","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninstâœÂ¹ : NormedRing A\ninstâœ : NormedAlgebra Real A\nu v u' v' : Real â†’ A\nhu : âˆ€ (x : Real), HasDerivAt u (u' x) x\nhv : âˆ€ (x : Real), HasDerivAt v (v' x) x\nhuv' : MeasureTheory.Integrable (HMul.hMul u v') MeasureTheory.MeasureSpace.volume\nhu'v : MeasureTheory.Integrable (HMul.hMul u' v) MeasureTheory.MeasureSpace.volume\nhuv : MeasureTheory.Integrable (HMul.hMul u v) MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HMul.hMul (u x) (v' x)) (Neg.neg (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HMul.hMul (u' x) (v x)))","decl":"/-- **Integration by parts on (-âˆ, âˆ).**\nVersion assuming that the total function is integrable -/\ntheorem integral_mul_deriv_eq_deriv_mul_of_integrable\n    (hu : âˆ€ x, HasDerivAt u (u' x) x) (hv : âˆ€ x, HasDerivAt v (v' x) x)\n    (huv' : Integrable (u * v')) (hu'v : Integrable (u' * v)) (huv : Integrable (u * v)) :\n    âˆ« (x : â„), u x * v' x = - âˆ« (x : â„), u' x * v x :=\n  integral_bilinear_hasDerivAt_right_eq_neg_left_of_integrable (L := ContinuousLinearMap.mul â„ A)\n    hu hv huv' hu'v huv\n\n"}
{"name":"MeasureTheory.integral_Ioi_deriv_mul_eq_sub","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Real A\na : Real\na' b' : A\nu v u' v' : Real â†’ A\ninstâœ : CompleteSpace A\nhu : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivAt u (u' x) x\nhv : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivAt v (v' x) x\nhuv : MeasureTheory.IntegrableOn (HAdd.hAdd (HMul.hMul u' v) (HMul.hMul u v')) (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nh_zero : Filter.Tendsto (HMul.hMul u v) (nhdsWithin a (Set.Ioi a)) (nhds a')\nh_infty : Filter.Tendsto (HMul.hMul u v) Filter.atTop (nhds b')\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => HAdd.hAdd (HMul.hMul (u' x) (v x)) (HMul.hMul (u x) (v' x))) (HSub.hSub b' a')","decl":"/-- For finite intervals, see: `intervalIntegral.integral_deriv_mul_eq_sub`. -/\ntheorem integral_Ioi_deriv_mul_eq_sub\n    (hu : âˆ€ x âˆˆ Ioi a, HasDerivAt u (u' x) x) (hv : âˆ€ x âˆˆ Ioi a, HasDerivAt v (v' x) x)\n    (huv : IntegrableOn (u' * v + u * v') (Ioi a))\n    (h_zero : Tendsto (u * v) (ğ“[>] a) (ğ“ a')) (h_infty : Tendsto (u * v) atTop (ğ“ b')) :\n    âˆ« (x : â„) in Ioi a, u' x * v x + u x * v' x = b' - a' := by\n  rw [â† Ici_diff_left] at h_zero\n  let f := Function.update (u * v) a a'\n  have hderiv : âˆ€ x âˆˆ Ioi a, HasDerivAt f (u' x * v x + u x * v' x) x := by\n    intro x (hx : a < x)\n    apply ((hu x hx).mul (hv x hx)).congr_of_eventuallyEq\n    filter_upwards [eventually_ne_nhds hx.ne.symm] with y hy\n    exact Function.update_of_ne hy a' (u * v)\n  have htendsto : Tendsto f atTop (ğ“ b') := by\n    apply h_infty.congr'\n    filter_upwards [eventually_ne_atTop a] with x hx\n    exact (Function.update_of_ne hx a' (u * v)).symm\n  simpa using integral_Ioi_of_hasDerivAt_of_tendsto\n    (continuousWithinAt_update_same.mpr h_zero) hderiv huv htendsto\n\n"}
{"name":"MeasureTheory.integral_Ioi_mul_deriv_eq_deriv_mul","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Real A\na : Real\na' b' : A\nu v u' v' : Real â†’ A\ninstâœ : CompleteSpace A\nhu : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivAt u (u' x) x\nhv : âˆ€ (x : Real), Membership.mem (Set.Ioi a) x â†’ HasDerivAt v (v' x) x\nhuv' : MeasureTheory.IntegrableOn (HMul.hMul u v') (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nhu'v : MeasureTheory.IntegrableOn (HMul.hMul u' v) (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nh_zero : Filter.Tendsto (HMul.hMul u v) (nhdsWithin a (Set.Ioi a)) (nhds a')\nh_infty : Filter.Tendsto (HMul.hMul u v) Filter.atTop (nhds b')\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => HMul.hMul (u x) (v' x)) (HSub.hSub (HSub.hSub b' a') (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => HMul.hMul (u' x) (v x)))","decl":"/-- **Integration by parts on (a, âˆ).**\nFor finite intervals, see: `intervalIntegral.integral_mul_deriv_eq_deriv_mul`. -/\ntheorem integral_Ioi_mul_deriv_eq_deriv_mul\n    (hu : âˆ€ x âˆˆ Ioi a, HasDerivAt u (u' x) x) (hv : âˆ€ x âˆˆ Ioi a, HasDerivAt v (v' x) x)\n    (huv' : IntegrableOn (u * v') (Ioi a)) (hu'v : IntegrableOn (u' * v) (Ioi a))\n    (h_zero : Tendsto (u * v) (ğ“[>] a) (ğ“ a')) (h_infty : Tendsto (u * v) atTop (ğ“ b')) :\n    âˆ« (x : â„) in Ioi a, u x * v' x = b' - a' - âˆ« (x : â„) in Ioi a, u' x * v x := by\n  rw [Pi.mul_def] at huv' hu'v\n  rw [eq_sub_iff_add_eq, â† integral_add huv' hu'v]\n  simpa only [add_comm] using integral_Ioi_deriv_mul_eq_sub hu hv (hu'v.add huv') h_zero h_infty\n\n"}
{"name":"MeasureTheory.integral_Iic_deriv_mul_eq_sub","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Real A\na : Real\na' b' : A\nu v u' v' : Real â†’ A\ninstâœ : CompleteSpace A\nhu : âˆ€ (x : Real), Membership.mem (Set.Iio a) x â†’ HasDerivAt u (u' x) x\nhv : âˆ€ (x : Real), Membership.mem (Set.Iio a) x â†’ HasDerivAt v (v' x) x\nhuv : MeasureTheory.IntegrableOn (HAdd.hAdd (HMul.hMul u' v) (HMul.hMul u v')) (Set.Iic a) MeasureTheory.MeasureSpace.volume\nh_zero : Filter.Tendsto (HMul.hMul u v) (nhdsWithin a (Set.Iio a)) (nhds a')\nh_infty : Filter.Tendsto (HMul.hMul u v) Filter.atBot (nhds b')\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic a)) fun x => HAdd.hAdd (HMul.hMul (u' x) (v x)) (HMul.hMul (u x) (v' x))) (HSub.hSub a' b')","decl":"/-- For finite intervals, see: `intervalIntegral.integral_deriv_mul_eq_sub`. -/\ntheorem integral_Iic_deriv_mul_eq_sub\n    (hu : âˆ€ x âˆˆ Iio a, HasDerivAt u (u' x) x) (hv : âˆ€ x âˆˆ Iio a, HasDerivAt v (v' x) x)\n    (huv : IntegrableOn (u' * v + u * v') (Iic a))\n    (h_zero : Tendsto (u * v) (ğ“[<] a) (ğ“ a')) (h_infty : Tendsto (u * v) atBot (ğ“ b')) :\n    âˆ« (x : â„) in Iic a, u' x * v x + u x * v' x = a' - b' := by\n  rw [â† Iic_diff_right] at h_zero\n  let f := Function.update (u * v) a a'\n  have hderiv : âˆ€ x âˆˆ Iio a, HasDerivAt f (u' x * v x + u x * v' x) x := by\n    intro x hx\n    apply ((hu x hx).mul (hv x hx)).congr_of_eventuallyEq\n    filter_upwards [Iio_mem_nhds hx] with x (hx : x < a)\n    exact Function.update_of_ne (ne_of_lt hx) a' (u * v)\n  have htendsto : Tendsto f atBot (ğ“ b') := by\n    apply h_infty.congr'\n    filter_upwards [Iio_mem_atBot a] with x (hx : x < a)\n    exact (Function.update_of_ne (ne_of_lt hx) a' (u * v)).symm\n  simpa using integral_Iic_of_hasDerivAt_of_tendsto\n    (continuousWithinAt_update_same.mpr h_zero) hderiv huv htendsto\n\n"}
{"name":"MeasureTheory.integral_Iic_mul_deriv_eq_deriv_mul","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninstâœÂ² : NormedRing A\ninstâœÂ¹ : NormedAlgebra Real A\na : Real\na' b' : A\nu v u' v' : Real â†’ A\ninstâœ : CompleteSpace A\nhu : âˆ€ (x : Real), Membership.mem (Set.Iio a) x â†’ HasDerivAt u (u' x) x\nhv : âˆ€ (x : Real), Membership.mem (Set.Iio a) x â†’ HasDerivAt v (v' x) x\nhuv' : MeasureTheory.IntegrableOn (HMul.hMul u v') (Set.Iic a) MeasureTheory.MeasureSpace.volume\nhu'v : MeasureTheory.IntegrableOn (HMul.hMul u' v) (Set.Iic a) MeasureTheory.MeasureSpace.volume\nh_zero : Filter.Tendsto (HMul.hMul u v) (nhdsWithin a (Set.Iio a)) (nhds a')\nh_infty : Filter.Tendsto (HMul.hMul u v) Filter.atBot (nhds b')\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic a)) fun x => HMul.hMul (u x) (v' x)) (HSub.hSub (HSub.hSub a' b') (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic a)) fun x => HMul.hMul (u' x) (v x)))","decl":"/-- **Integration by parts on (âˆ, a].**\nFor finite intervals, see: `intervalIntegral.integral_mul_deriv_eq_deriv_mul`. -/\ntheorem integral_Iic_mul_deriv_eq_deriv_mul\n    (hu : âˆ€ x âˆˆ Iio a, HasDerivAt u (u' x) x) (hv : âˆ€ x âˆˆ Iio a, HasDerivAt v (v' x) x)\n    (huv' : IntegrableOn (u * v') (Iic a)) (hu'v : IntegrableOn (u' * v) (Iic a))\n    (h_zero : Tendsto (u * v) (ğ“[<] a) (ğ“ a')) (h_infty : Tendsto (u * v) atBot (ğ“ b')) :\n    âˆ« (x : â„) in Iic a, u x * v' x = a' - b' - âˆ« (x : â„) in Iic a, u' x * v x := by\n  rw [Pi.mul_def] at huv' hu'v\n  rw [eq_sub_iff_add_eq, â† integral_add huv' hu'v]\n  simpa only [add_comm] using integral_Iic_deriv_mul_eq_sub hu hv (hu'v.add huv') h_zero h_infty\n\n"}
