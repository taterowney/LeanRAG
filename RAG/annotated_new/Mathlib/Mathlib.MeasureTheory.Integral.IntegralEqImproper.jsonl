{"name":"MeasureTheory.AECover.ae_eventually_mem","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\nφ : ι → Set α\nself : MeasureTheory.AECover μ l φ\n⊢ Filter.Eventually (fun x => Filter.Eventually (fun i => Membership.mem (φ i) x) l) (MeasureTheory.ae μ)","decl":"/-- A sequence `φ` of subsets of `α` is a `MeasureTheory.AECover` w.r.t. a measure `μ` and a filter\n    `l` if almost every point (w.r.t. `μ`) of `α` eventually belongs to `φ n` (w.r.t. `l`), and if\n    each `φ n` is measurable.  This definition is a technical way to avoid duplicating a lot of\n    proofs.  It should be thought of as a sufficient condition for being able to interpret\n    `∫ x, f x ∂μ` (if it exists) as the limit of `∫ x in φ n, f x ∂μ` as `n` tends to `l`.\n\n    See for example `MeasureTheory.AECover.lintegral_tendsto_of_countably_generated`,\n    `MeasureTheory.AECover.integrable_of_integral_norm_tendsto` and\n    `MeasureTheory.AECover.integral_tendsto_of_countably_generated`. -/\nstructure AECover (φ : ι → Set α) : Prop where\n  ae_eventually_mem : ∀ᵐ x ∂μ, ∀ᶠ i in l, x ∈ φ i\n  protected measurableSet : ∀ i, MeasurableSet <| φ i\n\n"}
{"name":"MeasureTheory.AECover.measurableSet","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\nφ : ι → Set α\nself : MeasureTheory.AECover μ l φ\ni : ι\n⊢ MeasurableSet (φ i)","decl":"/-- A sequence `φ` of subsets of `α` is a `MeasureTheory.AECover` w.r.t. a measure `μ` and a filter\n    `l` if almost every point (w.r.t. `μ`) of `α` eventually belongs to `φ n` (w.r.t. `l`), and if\n    each `φ n` is measurable.  This definition is a technical way to avoid duplicating a lot of\n    proofs.  It should be thought of as a sufficient condition for being able to interpret\n    `∫ x, f x ∂μ` (if it exists) as the limit of `∫ x in φ n, f x ∂μ` as `n` tends to `l`.\n\n    See for example `MeasureTheory.AECover.lintegral_tendsto_of_countably_generated`,\n    `MeasureTheory.AECover.integrable_of_integral_norm_tendsto` and\n    `MeasureTheory.AECover.integral_tendsto_of_countably_generated`. -/\nstructure AECover (φ : ι → Set α) : Prop where\n  ae_eventually_mem : ∀ᵐ x ∂μ, ∀ᶠ i in l, x ∈ φ i\n  protected measurableSet : ∀ i, MeasurableSet <| φ i\n\n"}
{"name":"MeasureTheory.AECover.inter","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\nφ ψ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nhψ : MeasureTheory.AECover μ l ψ\n⊢ MeasureTheory.AECover μ l fun i => Inter.inter (φ i) (ψ i)","decl":"/-- Elementwise intersection of two `AECover`s is an `AECover`. -/\ntheorem inter {φ ψ : ι → Set α} (hφ : AECover μ l φ) (hψ : AECover μ l ψ) :\n    AECover μ l (fun i ↦ φ i ∩ ψ i) where\n  ae_eventually_mem := hψ.1.mp <| hφ.1.mono fun _ ↦ Eventually.and\n  measurableSet _ := (hφ.2 _).inter (hψ.2 _)\n\n"}
{"name":"MeasureTheory.AECover.superset","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\nφ ψ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nhsub : ∀ (i : ι), HasSubset.Subset (φ i) (ψ i)\nhmeas : ∀ (i : ι), MeasurableSet (ψ i)\n⊢ MeasureTheory.AECover μ l ψ","decl":"theorem superset {φ ψ : ι → Set α} (hφ : AECover μ l φ) (hsub : ∀ i, φ i ⊆ ψ i)\n    (hmeas : ∀ i, MeasurableSet (ψ i)) : AECover μ l ψ :=\n  ⟨hφ.1.mono fun _x hx ↦ hx.mono fun i hi ↦ hsub i hi, hmeas⟩\n\n"}
{"name":"MeasureTheory.AECover.mono_ac","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\nν : MeasureTheory.Measure α\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nhle : ν.AbsolutelyContinuous μ\n⊢ MeasureTheory.AECover ν l φ","decl":"theorem mono_ac {ν : Measure α} {φ : ι → Set α} (hφ : AECover μ l φ) (hle : ν ≪ μ) :\n    AECover ν l φ := ⟨hle hφ.1, hφ.2⟩\n\n"}
{"name":"MeasureTheory.AECover.mono","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\nν : MeasureTheory.Measure α\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nhle : LE.le ν μ\n⊢ MeasureTheory.AECover ν l φ","decl":"theorem mono {ν : Measure α} {φ : ι → Set α} (hφ : AECover μ l φ) (hle : ν ≤ μ) :\n    AECover ν l φ := hφ.mono_ac hle.absolutelyContinuous\n\n"}
{"name":"MeasureTheory.aecover_ball","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝¹ : PseudoMetricSpace α\ninst✝ : OpensMeasurableSpace α\nx : α\nr : ι → Real\nhr : Filter.Tendsto r l Filter.atTop\n⊢ MeasureTheory.AECover μ l fun i => Metric.ball x (r i)","decl":"theorem aecover_ball {x : α} {r : ι → ℝ} (hr : Tendsto r l atTop) :\n    AECover μ l (fun i ↦ Metric.ball x (r i)) where\n  measurableSet _ := Metric.isOpen_ball.measurableSet\n  ae_eventually_mem := by\n    filter_upwards with y\n    filter_upwards [hr (Ioi_mem_atTop (dist x y))] with a ha using by simpa [dist_comm] using ha\n\n"}
{"name":"MeasureTheory.aecover_closedBall","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝¹ : PseudoMetricSpace α\ninst✝ : OpensMeasurableSpace α\nx : α\nr : ι → Real\nhr : Filter.Tendsto r l Filter.atTop\n⊢ MeasureTheory.AECover μ l fun i => Metric.closedBall x (r i)","decl":"theorem aecover_closedBall {x : α} {r : ι → ℝ} (hr : Tendsto r l atTop) :\n    AECover μ l (fun i ↦ Metric.closedBall x (r i)) where\n  measurableSet _ := Metric.isClosed_ball.measurableSet\n  ae_eventually_mem := by\n    filter_upwards with y\n    filter_upwards [hr (Ici_mem_atTop (dist x y))] with a ha using by simpa [dist_comm] using ha\n\n"}
{"name":"MeasureTheory.aecover_Ici","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : OpensMeasurableSpace α\na : ι → α\nha : Filter.Tendsto a l Filter.atBot\n⊢ MeasureTheory.AECover μ l fun i => Set.Ici (a i)","decl":"theorem aecover_Ici (ha : Tendsto a l atBot) : AECover μ l fun i => Ici (a i) where\n  ae_eventually_mem := ae_of_all μ ha.eventually_le_atBot\n  measurableSet _ := measurableSet_Ici\n\n"}
{"name":"MeasureTheory.aecover_Iic","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : OpensMeasurableSpace α\nb : ι → α\nhb : Filter.Tendsto b l Filter.atTop\n⊢ MeasureTheory.AECover μ l fun i => Set.Iic (b i)","decl":"theorem aecover_Iic (hb : Tendsto b l atTop) : AECover μ l fun i => Iic <| b i :=\n  aecover_Ici (α := αᵒᵈ) hb\n\n"}
{"name":"MeasureTheory.aecover_Icc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : OpensMeasurableSpace α\na b : ι → α\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\n⊢ MeasureTheory.AECover μ l fun i => Set.Icc (a i) (b i)","decl":"theorem aecover_Icc (ha : Tendsto a l atBot) (hb : Tendsto b l atTop) :\n    AECover μ l fun i => Icc (a i) (b i) :=\n  (aecover_Ici ha).inter (aecover_Iic hb)\n\n"}
{"name":"MeasureTheory.aecover_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na : ι → α\nha : Filter.Tendsto a l Filter.atBot\ninst✝ : NoMinOrder α\n⊢ MeasureTheory.AECover μ l fun i => Set.Ioi (a i)","decl":"include ha in\ntheorem aecover_Ioi [NoMinOrder α] : AECover μ l fun i => Ioi (a i) where\n  ae_eventually_mem := ae_of_all μ ha.eventually_lt_atBot\n  measurableSet _ := measurableSet_Ioi\n\n"}
{"name":"MeasureTheory.aecover_Iio","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\nb : ι → α\nhb : Filter.Tendsto b l Filter.atTop\ninst✝ : NoMaxOrder α\n⊢ MeasureTheory.AECover μ l fun i => Set.Iio (b i)","decl":"include hb in\ntheorem aecover_Iio [NoMaxOrder α] : AECover μ l fun i => Iio (b i) := aecover_Ioi (α := αᵒᵈ) hb\n\n"}
{"name":"MeasureTheory.aecover_Ioo","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁶ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁵ : LinearOrder α\ninst✝⁴ : TopologicalSpace α\ninst✝³ : OrderClosedTopology α\ninst✝² : OpensMeasurableSpace α\na b : ι → α\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\ninst✝¹ : NoMinOrder α\ninst✝ : NoMaxOrder α\n⊢ MeasureTheory.AECover μ l fun i => Set.Ioo (a i) (b i)","decl":"theorem aecover_Ioo [NoMinOrder α] [NoMaxOrder α] : AECover μ l fun i => Ioo (a i) (b i) :=\n  (aecover_Ioi ha).inter (aecover_Iio hb)\n\n"}
{"name":"MeasureTheory.aecover_Ioc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\ninst✝ : NoMinOrder α\n⊢ MeasureTheory.AECover μ l fun i => Set.Ioc (a i) (b i)","decl":"theorem aecover_Ioc [NoMinOrder α] : AECover μ l fun i => Ioc (a i) (b i) :=\n  (aecover_Ioi ha).inter (aecover_Iic hb)\n\n"}
{"name":"MeasureTheory.aecover_Ico","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\ninst✝ : NoMaxOrder α\n⊢ MeasureTheory.AECover μ l fun i => Set.Ico (a i) (b i)","decl":"theorem aecover_Ico [NoMaxOrder α] : AECover μ l fun i => Ico (a i) (b i) :=\n  (aecover_Ici ha).inter (aecover_Iio hb)\n\n"}
{"name":"MeasureTheory.aecover_Ioi_of_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : OpensMeasurableSpace α\na : ι → α\nA : α\nha : Filter.Tendsto a l (nhds A)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ioi A)) l fun i => Set.Ioi (a i)","decl":"include ha in\ntheorem aecover_Ioi_of_Ioi : AECover (μ.restrict (Ioi A)) l fun i ↦ Ioi (a i) where\n  ae_eventually_mem := (ae_restrict_mem measurableSet_Ioi).mono fun _x hx ↦ ha.eventually <|\n    eventually_lt_nhds hx\n  measurableSet _ := measurableSet_Ioi\n\n"}
{"name":"MeasureTheory.aecover_Iio_of_Iio","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : OpensMeasurableSpace α\nb : ι → α\nB : α\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Iio B)) l fun i => Set.Iio (b i)","decl":"include hb in\ntheorem aecover_Iio_of_Iio : AECover (μ.restrict (Iio B)) l fun i ↦ Iio (b i) :=\n  aecover_Ioi_of_Ioi (α := αᵒᵈ) hb\n\n"}
{"name":"MeasureTheory.aecover_Ioi_of_Ici","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : OpensMeasurableSpace α\na : ι → α\nA : α\nha : Filter.Tendsto a l (nhds A)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ioi A)) l fun i => Set.Ici (a i)","decl":"include ha in\ntheorem aecover_Ioi_of_Ici : AECover (μ.restrict (Ioi A)) l fun i ↦ Ici (a i) :=\n  (aecover_Ioi_of_Ioi ha).superset (fun _ ↦ Ioi_subset_Ici_self) fun _ ↦ measurableSet_Ici\n\n"}
{"name":"MeasureTheory.aecover_Iio_of_Iic","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : OpensMeasurableSpace α\nb : ι → α\nB : α\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Iio B)) l fun i => Set.Iic (b i)","decl":"include hb in\ntheorem aecover_Iio_of_Iic : AECover (μ.restrict (Iio B)) l fun i ↦ Iic (b i) :=\n  aecover_Ioi_of_Ici (α := αᵒᵈ) hb\n\n"}
{"name":"MeasureTheory.aecover_Ioo_of_Ioo","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : OpensMeasurableSpace α\na b : ι → α\nA B : α\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ioo A B)) l fun i => Set.Ioo (a i) (b i)","decl":"include ha hb in\ntheorem aecover_Ioo_of_Ioo : AECover (μ.restrict <| Ioo A B) l fun i => Ioo (a i) (b i) :=\n  ((aecover_Ioi_of_Ioi ha).mono <| Measure.restrict_mono Ioo_subset_Ioi_self le_rfl).inter\n    ((aecover_Iio_of_Iio hb).mono <| Measure.restrict_mono Ioo_subset_Iio_self le_rfl)\n\n"}
{"name":"MeasureTheory.aecover_Ioo_of_Icc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : OpensMeasurableSpace α\na b : ι → α\nA B : α\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ioo A B)) l fun i => Set.Icc (a i) (b i)","decl":"include ha hb in\ntheorem aecover_Ioo_of_Icc : AECover (μ.restrict <| Ioo A B) l fun i => Icc (a i) (b i) :=\n  (aecover_Ioo_of_Ioo ha hb).superset (fun _ ↦ Ioo_subset_Icc_self) fun _ ↦ measurableSet_Icc\n\n"}
{"name":"MeasureTheory.aecover_Ioo_of_Ico","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : OpensMeasurableSpace α\na b : ι → α\nA B : α\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ioo A B)) l fun i => Set.Ico (a i) (b i)","decl":"include ha hb in\ntheorem aecover_Ioo_of_Ico : AECover (μ.restrict <| Ioo A B) l fun i => Ico (a i) (b i) :=\n  (aecover_Ioo_of_Ioo ha hb).superset (fun _ ↦ Ioo_subset_Ico_self) fun _ ↦ measurableSet_Ico\n\n"}
{"name":"MeasureTheory.aecover_Ioo_of_Ioc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝³ : LinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderClosedTopology α\ninst✝ : OpensMeasurableSpace α\na b : ι → α\nA B : α\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ioo A B)) l fun i => Set.Ioc (a i) (b i)","decl":"include ha hb in\ntheorem aecover_Ioo_of_Ioc : AECover (μ.restrict <| Ioo A B) l fun i => Ioc (a i) (b i) :=\n  (aecover_Ioo_of_Ioo ha hb).superset (fun _ ↦ Ioo_subset_Ioc_self) fun _ ↦ measurableSet_Ioc\n\n"}
{"name":"MeasureTheory.aecover_Ioc_of_Icc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nA B : α\ninst✝ : MeasureTheory.NoAtoms μ\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ioc A B)) l fun i => Set.Icc (a i) (b i)","decl":"theorem aecover_Ioc_of_Icc (ha : Tendsto a l (𝓝 A)) (hb : Tendsto b l (𝓝 B)) :\n    AECover (μ.restrict <| Ioc A B) l fun i => Icc (a i) (b i) :=\n  (aecover_Ioo_of_Icc ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ioc).ge\n\n"}
{"name":"MeasureTheory.aecover_Ioc_of_Ico","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nA B : α\ninst✝ : MeasureTheory.NoAtoms μ\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ioc A B)) l fun i => Set.Ico (a i) (b i)","decl":"theorem aecover_Ioc_of_Ico (ha : Tendsto a l (𝓝 A)) (hb : Tendsto b l (𝓝 B)) :\n    AECover (μ.restrict <| Ioc A B) l fun i => Ico (a i) (b i) :=\n  (aecover_Ioo_of_Ico ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ioc).ge\n\n"}
{"name":"MeasureTheory.aecover_Ioc_of_Ioc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nA B : α\ninst✝ : MeasureTheory.NoAtoms μ\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ioc A B)) l fun i => Set.Ioc (a i) (b i)","decl":"theorem aecover_Ioc_of_Ioc (ha : Tendsto a l (𝓝 A)) (hb : Tendsto b l (𝓝 B)) :\n    AECover (μ.restrict <| Ioc A B) l fun i => Ioc (a i) (b i) :=\n  (aecover_Ioo_of_Ioc ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ioc).ge\n\n"}
{"name":"MeasureTheory.aecover_Ioc_of_Ioo","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nA B : α\ninst✝ : MeasureTheory.NoAtoms μ\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ioc A B)) l fun i => Set.Ioo (a i) (b i)","decl":"theorem aecover_Ioc_of_Ioo (ha : Tendsto a l (𝓝 A)) (hb : Tendsto b l (𝓝 B)) :\n    AECover (μ.restrict <| Ioc A B) l fun i => Ioo (a i) (b i) :=\n  (aecover_Ioo_of_Ioo ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ioc).ge\n\n"}
{"name":"MeasureTheory.aecover_Ico_of_Icc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nA B : α\ninst✝ : MeasureTheory.NoAtoms μ\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ico A B)) l fun i => Set.Icc (a i) (b i)","decl":"theorem aecover_Ico_of_Icc (ha : Tendsto a l (𝓝 A)) (hb : Tendsto b l (𝓝 B)) :\n    AECover (μ.restrict <| Ico A B) l fun i => Icc (a i) (b i) :=\n  (aecover_Ioo_of_Icc ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ico).ge\n\n"}
{"name":"MeasureTheory.aecover_Ico_of_Ico","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nA B : α\ninst✝ : MeasureTheory.NoAtoms μ\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ico A B)) l fun i => Set.Ico (a i) (b i)","decl":"theorem aecover_Ico_of_Ico (ha : Tendsto a l (𝓝 A)) (hb : Tendsto b l (𝓝 B)) :\n    AECover (μ.restrict <| Ico A B) l fun i => Ico (a i) (b i) :=\n  (aecover_Ioo_of_Ico ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ico).ge\n\n"}
{"name":"MeasureTheory.aecover_Ico_of_Ioc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nA B : α\ninst✝ : MeasureTheory.NoAtoms μ\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ico A B)) l fun i => Set.Ioc (a i) (b i)","decl":"theorem aecover_Ico_of_Ioc (ha : Tendsto a l (𝓝 A)) (hb : Tendsto b l (𝓝 B)) :\n    AECover (μ.restrict <| Ico A B) l fun i => Ioc (a i) (b i) :=\n  (aecover_Ioo_of_Ioc ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ico).ge\n\n"}
{"name":"MeasureTheory.aecover_Ico_of_Ioo","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nA B : α\ninst✝ : MeasureTheory.NoAtoms μ\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Ico A B)) l fun i => Set.Ioo (a i) (b i)","decl":"theorem aecover_Ico_of_Ioo (ha : Tendsto a l (𝓝 A)) (hb : Tendsto b l (𝓝 B)) :\n    AECover (μ.restrict <| Ico A B) l fun i => Ioo (a i) (b i) :=\n  (aecover_Ioo_of_Ioo ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Ico).ge\n\n"}
{"name":"MeasureTheory.aecover_Icc_of_Icc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nA B : α\ninst✝ : MeasureTheory.NoAtoms μ\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Icc A B)) l fun i => Set.Icc (a i) (b i)","decl":"theorem aecover_Icc_of_Icc (ha : Tendsto a l (𝓝 A)) (hb : Tendsto b l (𝓝 B)) :\n    AECover (μ.restrict <| Icc A B) l fun i => Icc (a i) (b i) :=\n  (aecover_Ioo_of_Icc ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Icc).ge\n\n"}
{"name":"MeasureTheory.aecover_Icc_of_Ico","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nA B : α\ninst✝ : MeasureTheory.NoAtoms μ\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Icc A B)) l fun i => Set.Ico (a i) (b i)","decl":"theorem aecover_Icc_of_Ico (ha : Tendsto a l (𝓝 A)) (hb : Tendsto b l (𝓝 B)) :\n    AECover (μ.restrict <| Icc A B) l fun i => Ico (a i) (b i) :=\n  (aecover_Ioo_of_Ico ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Icc).ge\n\n"}
{"name":"MeasureTheory.aecover_Icc_of_Ioc","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nA B : α\ninst✝ : MeasureTheory.NoAtoms μ\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Icc A B)) l fun i => Set.Ioc (a i) (b i)","decl":"theorem aecover_Icc_of_Ioc (ha : Tendsto a l (𝓝 A)) (hb : Tendsto b l (𝓝 B)) :\n    AECover (μ.restrict <| Icc A B) l fun i => Ioc (a i) (b i) :=\n  (aecover_Ioo_of_Ioc ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Icc).ge\n\n"}
{"name":"MeasureTheory.aecover_Icc_of_Ioo","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁵ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝⁴ : LinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderClosedTopology α\ninst✝¹ : OpensMeasurableSpace α\na b : ι → α\nA B : α\ninst✝ : MeasureTheory.NoAtoms μ\nha : Filter.Tendsto a l (nhds A)\nhb : Filter.Tendsto b l (nhds B)\n⊢ MeasureTheory.AECover (μ.restrict (Set.Icc A B)) l fun i => Set.Ioo (a i) (b i)","decl":"theorem aecover_Icc_of_Ioo (ha : Tendsto a l (𝓝 A)) (hb : Tendsto b l (𝓝 B)) :\n    AECover (μ.restrict <| Icc A B) l fun i => Ioo (a i) (b i) :=\n  (aecover_Ioo_of_Ioo ha hb).mono (Measure.restrict_congr_set Ioo_ae_eq_Icc).ge\n\n"}
{"name":"MeasureTheory.AECover.restrict","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\ns : Set α\n⊢ MeasureTheory.AECover (μ.restrict s) l φ","decl":"protected theorem AECover.restrict {φ : ι → Set α} (hφ : AECover μ l φ) {s : Set α} :\n    AECover (μ.restrict s) l φ :=\n  hφ.mono Measure.restrict_le_self\n\n"}
{"name":"MeasureTheory.aecover_restrict_of_ae_imp","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ns : Set α\nφ : ι → Set α\nhs : MeasurableSet s\nae_eventually_mem : Filter.Eventually (fun x => Membership.mem s x → Filter.Eventually (fun n => Membership.mem (φ n) x) l) (MeasureTheory.ae μ)\nmeasurable : ∀ (n : ι), MeasurableSet (φ n)\n⊢ MeasureTheory.AECover (μ.restrict s) l φ","decl":"theorem aecover_restrict_of_ae_imp {s : Set α} {φ : ι → Set α} (hs : MeasurableSet s)\n    (ae_eventually_mem : ∀ᵐ x ∂μ, x ∈ s → ∀ᶠ n in l, x ∈ φ n)\n    (measurable : ∀ n, MeasurableSet <| φ n) : AECover (μ.restrict s) l φ where\n  ae_eventually_mem := by rwa [ae_restrict_iff' hs]\n  measurableSet := measurable\n\n"}
{"name":"MeasureTheory.AECover.inter_restrict","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\ns : Set α\nhs : MeasurableSet s\n⊢ MeasureTheory.AECover (μ.restrict s) l fun i => Inter.inter (φ i) s","decl":"theorem AECover.inter_restrict {φ : ι → Set α} (hφ : AECover μ l φ) {s : Set α}\n    (hs : MeasurableSet s) : AECover (μ.restrict s) l fun i => φ i ∩ s :=\n  aecover_restrict_of_ae_imp hs\n    (hφ.ae_eventually_mem.mono fun _x hx hxs => hx.mono fun _i hi => ⟨hi, hxs⟩) fun i =>\n    (hφ.measurableSet i).inter hs\n\n"}
{"name":"MeasureTheory.AECover.ae_tendsto_indicator","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\nβ : Type u_3\ninst✝¹ : Zero β\ninst✝ : TopologicalSpace β\nf : α → β\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun i => (φ i).indicator f x) l (nhds (f x))) (MeasureTheory.ae μ)","decl":"theorem AECover.ae_tendsto_indicator {β : Type*} [Zero β] [TopologicalSpace β] (f : α → β)\n    {φ : ι → Set α} (hφ : AECover μ l φ) :\n    ∀ᵐ x ∂μ, Tendsto (fun i => (φ i).indicator f x) l (𝓝 <| f x) :=\n  hφ.ae_eventually_mem.mono fun _x hx =>\n    tendsto_const_nhds.congr' <| hx.mono fun _n hn => (indicator_of_mem hn _).symm\n\n"}
{"name":"MeasureTheory.AECover.aemeasurable","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\nβ : Type u_3\ninst✝² : MeasurableSpace β\ninst✝¹ : l.IsCountablyGenerated\ninst✝ : l.NeBot\nf : α → β\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nhfm : ∀ (i : ι), AEMeasurable f (μ.restrict (φ i))\n⊢ AEMeasurable f μ","decl":"theorem AECover.aemeasurable {β : Type*} [MeasurableSpace β] [l.IsCountablyGenerated] [l.NeBot]\n    {f : α → β} {φ : ι → Set α} (hφ : AECover μ l φ)\n    (hfm : ∀ i, AEMeasurable f (μ.restrict <| φ i)) : AEMeasurable f μ := by\n  obtain ⟨u, hu⟩ := l.exists_seq_tendsto\n  have := aemeasurable_iUnion_iff.mpr fun n : ℕ => hfm (u n)\n  rwa [Measure.restrict_eq_self_of_ae_mem] at this\n  filter_upwards [hφ.ae_eventually_mem] with x hx using\n    mem_iUnion.mpr (hu.eventually hx).exists\n\n"}
{"name":"MeasureTheory.AECover.aestronglyMeasurable","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\nβ : Type u_3\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\ninst✝¹ : l.IsCountablyGenerated\ninst✝ : l.NeBot\nf : α → β\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nhfm : ∀ (i : ι), MeasureTheory.AEStronglyMeasurable f (μ.restrict (φ i))\n⊢ MeasureTheory.AEStronglyMeasurable f μ","decl":"theorem AECover.aestronglyMeasurable {β : Type*} [TopologicalSpace β] [PseudoMetrizableSpace β]\n    [l.IsCountablyGenerated] [l.NeBot] {f : α → β} {φ : ι → Set α} (hφ : AECover μ l φ)\n    (hfm : ∀ i, AEStronglyMeasurable f (μ.restrict <| φ i)) : AEStronglyMeasurable f μ := by\n  obtain ⟨u, hu⟩ := l.exists_seq_tendsto\n  have := aestronglyMeasurable_iUnion_iff.mpr fun n : ℕ => hfm (u n)\n  rwa [Measure.restrict_eq_self_of_ae_mem] at this\n  filter_upwards [hφ.ae_eventually_mem] with x hx using mem_iUnion.mpr (hu.eventually hx).exists\n\n"}
{"name":"MeasureTheory.AECover.comp_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\nι' : Type u_3\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\nl' : Filter ι'\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nu : ι' → ι\nhu : Filter.Tendsto u l' l\n⊢ MeasureTheory.AECover μ l' (Function.comp φ u)","decl":"theorem AECover.comp_tendsto {α ι ι' : Type*} [MeasurableSpace α] {μ : Measure α} {l : Filter ι}\n    {l' : Filter ι'} {φ : ι → Set α} (hφ : AECover μ l φ) {u : ι' → ι} (hu : Tendsto u l' l) :\n    AECover μ l' (φ ∘ u) where\n  ae_eventually_mem := hφ.ae_eventually_mem.mono fun _x hx => hu.eventually hx\n  measurableSet i := hφ.measurableSet (u i)\n\n"}
{"name":"MeasureTheory.AECover.biUnion_Iic_aecover","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : Countable ι\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Preorder ι\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ Filter.atTop φ\n⊢ MeasureTheory.AECover μ Filter.atTop fun n => Set.iUnion fun k => Set.iUnion fun _h => φ k","decl":"theorem AECover.biUnion_Iic_aecover [Preorder ι] {φ : ι → Set α} (hφ : AECover μ atTop φ) :\n    AECover μ atTop fun n : ι => ⋃ (k) (_h : k ∈ Iic n), φ k :=\n  hφ.superset (fun _ ↦ subset_biUnion_of_mem right_mem_Iic) fun _ ↦ .biUnion (to_countable _)\n    fun _ _ ↦ (hφ.2 _)\n\n-- Porting note: generalized from `[SemilatticeSup ι] [Nonempty ι]` to `[Preorder ι]`\n"}
{"name":"MeasureTheory.AECover.biInter_Ici_aecover","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : Countable ι\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Preorder ι\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ Filter.atTop φ\n⊢ MeasureTheory.AECover μ Filter.atTop fun n => Set.iInter fun k => Set.iInter fun _h => φ k","decl":"theorem AECover.biInter_Ici_aecover [Preorder ι] {φ : ι → Set α}\n    (hφ : AECover μ atTop φ) : AECover μ atTop fun n : ι => ⋂ (k) (_h : k ∈ Ici n), φ k where\n  ae_eventually_mem := hφ.ae_eventually_mem.mono fun x h ↦ by\n    simpa only [mem_iInter, mem_Ici, eventually_forall_ge_atTop]\n  measurableSet _ := .biInter (to_countable _) fun n _ => hφ.measurableSet n\n\n"}
{"name":"MeasureTheory.AECover.lintegral_tendsto_of_nat","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nφ : Nat → Set α\nhφ : MeasureTheory.AECover μ Filter.atTop φ\nf : α → ENNReal\nhfm : AEMeasurable f μ\n⊢ Filter.Tendsto (fun x => MeasureTheory.lintegral (μ.restrict (φ x)) fun x => f x) Filter.atTop (nhds (MeasureTheory.lintegral μ fun x => f x))","decl":"theorem AECover.lintegral_tendsto_of_nat {φ : ℕ → Set α} (hφ : AECover μ atTop φ) {f : α → ℝ≥0∞}\n    (hfm : AEMeasurable f μ) : Tendsto (∫⁻ x in φ ·, f x ∂μ) atTop (𝓝 <| ∫⁻ x, f x ∂μ) := by\n  have lim₁ := lintegral_tendsto_of_monotone_of_nat hφ.biInter_Ici_aecover\n    (fun i j hij => biInter_subset_biInter_left (Ici_subset_Ici.mpr hij)) hfm\n  have lim₂ := lintegral_tendsto_of_monotone_of_nat hφ.biUnion_Iic_aecover\n    (fun i j hij => biUnion_subset_biUnion_left (Iic_subset_Iic.mpr hij)) hfm\n  refine tendsto_of_tendsto_of_tendsto_of_le_of_le lim₁ lim₂ (fun n ↦ ?_) fun n ↦ ?_\n  exacts [lintegral_mono_set (biInter_subset_of_mem left_mem_Ici),\n    lintegral_mono_set (subset_biUnion_of_mem right_mem_Iic)]\n\n"}
{"name":"MeasureTheory.AECover.lintegral_tendsto_of_countably_generated","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → ENNReal\nhfm : AEMeasurable f μ\n⊢ Filter.Tendsto (fun i => MeasureTheory.lintegral (μ.restrict (φ i)) fun x => f x) l (nhds (MeasureTheory.lintegral μ fun x => f x))","decl":"theorem AECover.lintegral_tendsto_of_countably_generated [l.IsCountablyGenerated] {φ : ι → Set α}\n    (hφ : AECover μ l φ) {f : α → ℝ≥0∞} (hfm : AEMeasurable f μ) :\n    Tendsto (fun i => ∫⁻ x in φ i, f x ∂μ) l (𝓝 <| ∫⁻ x, f x ∂μ) :=\n  tendsto_of_seq_tendsto fun _u hu => (hφ.comp_tendsto hu).lintegral_tendsto_of_nat hfm\n\n"}
{"name":"MeasureTheory.AECover.lintegral_eq_of_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → ENNReal\nI : ENNReal\nhfm : AEMeasurable f μ\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral (μ.restrict (φ i)) fun x => f x) l (nhds I)\n⊢ Eq (MeasureTheory.lintegral μ fun x => f x) I","decl":"theorem AECover.lintegral_eq_of_tendsto [l.NeBot] [l.IsCountablyGenerated] {φ : ι → Set α}\n    (hφ : AECover μ l φ) {f : α → ℝ≥0∞} (I : ℝ≥0∞) (hfm : AEMeasurable f μ)\n    (htendsto : Tendsto (fun i => ∫⁻ x in φ i, f x ∂μ) l (𝓝 I)) : ∫⁻ x, f x ∂μ = I :=\n  tendsto_nhds_unique (hφ.lintegral_tendsto_of_countably_generated hfm) htendsto\n\n"}
{"name":"MeasureTheory.AECover.iSup_lintegral_eq_of_countably_generated","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝² : Nonempty ι\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → ENNReal\nhfm : AEMeasurable f μ\n⊢ Eq (iSup fun i => MeasureTheory.lintegral (μ.restrict (φ i)) fun x => f x) (MeasureTheory.lintegral μ fun x => f x)","decl":"theorem AECover.iSup_lintegral_eq_of_countably_generated [Nonempty ι] [l.NeBot]\n    [l.IsCountablyGenerated] {φ : ι → Set α} (hφ : AECover μ l φ) {f : α → ℝ≥0∞}\n    (hfm : AEMeasurable f μ) : ⨆ i : ι, ∫⁻ x in φ i, f x ∂μ = ∫⁻ x, f x ∂μ := by\n  have := hφ.lintegral_tendsto_of_countably_generated hfm\n  refine ciSup_eq_of_forall_le_of_forall_lt_exists_gt\n    (fun i => lintegral_mono' Measure.restrict_le_self le_rfl) fun w hw => ?_\n  exact (this.eventually_const_lt hw).exists\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_enorm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\nE : Type u_3\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝² : NormedAddCommGroup E\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → E\nI : Real\nhfm : MeasureTheory.AEStronglyMeasurable f μ\nhbounded : Filter.Eventually (fun i => LE.le (MeasureTheory.lintegral (μ.restrict (φ i)) fun x => ENorm.enorm (f x)) (ENNReal.ofReal I)) l\n⊢ MeasureTheory.Integrable f μ","decl":"theorem AECover.integrable_of_lintegral_enorm_bounded [l.NeBot] [l.IsCountablyGenerated]\n    {φ : ι → Set α} (hφ : AECover μ l φ) {f : α → E} (I : ℝ) (hfm : AEStronglyMeasurable f μ)\n    (hbounded : ∀ᶠ i in l, ∫⁻ x in φ i, ‖f x‖ₑ ∂μ ≤ ENNReal.ofReal I) : Integrable f μ := by\n  refine ⟨hfm, (le_of_tendsto ?_ hbounded).trans_lt ENNReal.ofReal_lt_top⟩\n  exact hφ.lintegral_tendsto_of_countably_generated hfm.enorm\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_nnnorm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\nE : Type u_3\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝² : NormedAddCommGroup E\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → E\nI : Real\nhfm : MeasureTheory.AEStronglyMeasurable f μ\nhbounded : Filter.Eventually (fun i => LE.le (MeasureTheory.lintegral (μ.restrict (φ i)) fun x => ENorm.enorm (f x)) (ENNReal.ofReal I)) l\n⊢ MeasureTheory.Integrable f μ","decl":"@[deprecated (since := \"2025-01-22\")]\nalias AECover.integrable_of_lintegral_nnnorm_bounded :=\n AECover.integrable_of_lintegral_enorm_bounded\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_enorm_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\nE : Type u_3\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝² : NormedAddCommGroup E\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → E\nI : Real\nhfm : MeasureTheory.AEStronglyMeasurable f μ\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral (μ.restrict (φ i)) fun x => ENorm.enorm (f x)) l (nhds (ENNReal.ofReal I))\n⊢ MeasureTheory.Integrable f μ","decl":"theorem AECover.integrable_of_lintegral_enorm_tendsto [l.NeBot] [l.IsCountablyGenerated]\n    {φ : ι → Set α} (hφ : AECover μ l φ) {f : α → E} (I : ℝ) (hfm : AEStronglyMeasurable f μ)\n    (htendsto : Tendsto (fun i => ∫⁻ x in φ i, ‖f x‖ₑ ∂μ) l (𝓝 <| .ofReal I)) :\n    Integrable f μ := by\n  refine hφ.integrable_of_lintegral_enorm_bounded (max 1 (I + 1)) hfm ?_\n  refine htendsto.eventually (ge_mem_nhds ?_)\n  refine (ENNReal.ofReal_lt_ofReal_iff (lt_max_of_lt_left zero_lt_one)).2 ?_\n  exact lt_max_of_lt_right (lt_add_one I)\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_nnnorm_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\nE : Type u_3\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝² : NormedAddCommGroup E\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → E\nI : Real\nhfm : MeasureTheory.AEStronglyMeasurable f μ\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral (μ.restrict (φ i)) fun x => ENorm.enorm (f x)) l (nhds (ENNReal.ofReal I))\n⊢ MeasureTheory.Integrable f μ","decl":"@[deprecated (since := \"2025-01-22\")]\nalias AECover.integrable_of_lintegral_nnnorm_tendsto :=\n AECover.integrable_of_lintegral_enorm_tendsto\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_enorm_bounded'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\nE : Type u_3\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝² : NormedAddCommGroup E\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → E\nI : NNReal\nhfm : MeasureTheory.AEStronglyMeasurable f μ\nhbounded : Filter.Eventually (fun i => LE.le (MeasureTheory.lintegral (μ.restrict (φ i)) fun x => ENorm.enorm (f x)) ↑I) l\n⊢ MeasureTheory.Integrable f μ","decl":"theorem AECover.integrable_of_lintegral_enorm_bounded' [l.NeBot] [l.IsCountablyGenerated]\n    {φ : ι → Set α} (hφ : AECover μ l φ) {f : α → E} (I : ℝ≥0) (hfm : AEStronglyMeasurable f μ)\n    (hbounded : ∀ᶠ i in l, ∫⁻ x in φ i, ‖f x‖ₑ ∂μ ≤ I) : Integrable f μ :=\n  hφ.integrable_of_lintegral_enorm_bounded I hfm\n    (by simpa only [ENNReal.ofReal_coe_nnreal] using hbounded)\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_nnnorm_bounded'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\nE : Type u_3\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝² : NormedAddCommGroup E\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → E\nI : NNReal\nhfm : MeasureTheory.AEStronglyMeasurable f μ\nhbounded : Filter.Eventually (fun i => LE.le (MeasureTheory.lintegral (μ.restrict (φ i)) fun x => ENorm.enorm (f x)) ↑I) l\n⊢ MeasureTheory.Integrable f μ","decl":"@[deprecated (since := \"2025-01-22\")]\nalias AECover.integrable_of_lintegral_nnnorm_bounded' :=\n AECover.integrable_of_lintegral_enorm_bounded'\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_enorm_tendsto'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\nE : Type u_3\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝² : NormedAddCommGroup E\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → E\nI : NNReal\nhfm : MeasureTheory.AEStronglyMeasurable f μ\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral (μ.restrict (φ i)) fun x => ENorm.enorm (f x)) l (nhds ↑I)\n⊢ MeasureTheory.Integrable f μ","decl":"theorem AECover.integrable_of_lintegral_enorm_tendsto' [l.NeBot] [l.IsCountablyGenerated]\n    {φ : ι → Set α} (hφ : AECover μ l φ) {f : α → E} (I : ℝ≥0) (hfm : AEStronglyMeasurable f μ)\n    (htendsto : Tendsto (fun i => ∫⁻ x in φ i, ‖f x‖ₑ ∂μ) l (𝓝 I)) : Integrable f μ :=\n  hφ.integrable_of_lintegral_enorm_tendsto I hfm\n    (by simpa only [ENNReal.ofReal_coe_nnreal] using htendsto)\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_lintegral_nnnorm_tendsto'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\nE : Type u_3\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝² : NormedAddCommGroup E\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → E\nI : NNReal\nhfm : MeasureTheory.AEStronglyMeasurable f μ\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.lintegral (μ.restrict (φ i)) fun x => ENorm.enorm (f x)) l (nhds ↑I)\n⊢ MeasureTheory.Integrable f μ","decl":"@[deprecated (since := \"2025-01-22\")]\nalias AECover.integrable_of_lintegral_nnnorm_tendsto' :=\n AECover.integrable_of_lintegral_enorm_tendsto'\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_integral_norm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\nE : Type u_3\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝² : NormedAddCommGroup E\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → E\nI : Real\nhfi : ∀ (i : ι), MeasureTheory.IntegrableOn f (φ i) μ\nhbounded : Filter.Eventually (fun i => LE.le (MeasureTheory.integral (μ.restrict (φ i)) fun x => Norm.norm (f x)) I) l\n⊢ MeasureTheory.Integrable f μ","decl":"theorem AECover.integrable_of_integral_norm_bounded [l.NeBot] [l.IsCountablyGenerated]\n    {φ : ι → Set α} (hφ : AECover μ l φ) {f : α → E} (I : ℝ) (hfi : ∀ i, IntegrableOn f (φ i) μ)\n    (hbounded : ∀ᶠ i in l, (∫ x in φ i, ‖f x‖ ∂μ) ≤ I) : Integrable f μ := by\n  have hfm : AEStronglyMeasurable f μ :=\n    hφ.aestronglyMeasurable fun i => (hfi i).aestronglyMeasurable\n  refine hφ.integrable_of_lintegral_enorm_bounded I hfm ?_\n  conv at hbounded in integral _ _ =>\n    rw [integral_eq_lintegral_of_nonneg_ae (ae_of_all _ fun x => @norm_nonneg E _ (f x))\n        hfm.norm.restrict]\n  conv at hbounded in ENNReal.ofReal _ =>\n    rw [← coe_nnnorm, ENNReal.ofReal_coe_nnreal]\n  refine hbounded.mono fun i hi => ?_\n  rw [← ENNReal.ofReal_toReal <| ne_top_of_lt <| hasFiniteIntegral_iff_enorm.mp (hfi i).2]\n  apply ENNReal.ofReal_le_ofReal hi\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_integral_norm_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\nE : Type u_3\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝² : NormedAddCommGroup E\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → E\nI : Real\nhfi : ∀ (i : ι), MeasureTheory.IntegrableOn f (φ i) μ\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.integral (μ.restrict (φ i)) fun x => Norm.norm (f x)) l (nhds I)\n⊢ MeasureTheory.Integrable f μ","decl":"theorem AECover.integrable_of_integral_norm_tendsto [l.NeBot] [l.IsCountablyGenerated]\n    {φ : ι → Set α} (hφ : AECover μ l φ) {f : α → E} (I : ℝ) (hfi : ∀ i, IntegrableOn f (φ i) μ)\n    (htendsto : Tendsto (fun i => ∫ x in φ i, ‖f x‖ ∂μ) l (𝓝 I)) : Integrable f μ :=\n  let ⟨I', hI'⟩ := htendsto.isBoundedUnder_le\n  hφ.integrable_of_integral_norm_bounded I' hfi hI'\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_integral_bounded_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → Real\nI : Real\nhfi : ∀ (i : ι), MeasureTheory.IntegrableOn f (φ i) μ\nhnng : Filter.Eventually (fun x => LE.le 0 (f x)) (MeasureTheory.ae μ)\nhbounded : Filter.Eventually (fun i => LE.le (MeasureTheory.integral (μ.restrict (φ i)) fun x => f x) I) l\n⊢ MeasureTheory.Integrable f μ","decl":"theorem AECover.integrable_of_integral_bounded_of_nonneg_ae [l.NeBot] [l.IsCountablyGenerated]\n    {φ : ι → Set α} (hφ : AECover μ l φ) {f : α → ℝ} (I : ℝ) (hfi : ∀ i, IntegrableOn f (φ i) μ)\n    (hnng : ∀ᵐ x ∂μ, 0 ≤ f x) (hbounded : ∀ᶠ i in l, (∫ x in φ i, f x ∂μ) ≤ I) : Integrable f μ :=\n  hφ.integrable_of_integral_norm_bounded I hfi <| hbounded.mono fun _i hi =>\n    (integral_congr_ae <| ae_restrict_of_ae <| hnng.mono fun _ => Real.norm_of_nonneg).le.trans hi\n\n"}
{"name":"MeasureTheory.AECover.integrable_of_integral_tendsto_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → Real\nI : Real\nhfi : ∀ (i : ι), MeasureTheory.IntegrableOn f (φ i) μ\nhnng : Filter.Eventually (fun x => LE.le 0 (f x)) (MeasureTheory.ae μ)\nhtendsto : Filter.Tendsto (fun i => MeasureTheory.integral (μ.restrict (φ i)) fun x => f x) l (nhds I)\n⊢ MeasureTheory.Integrable f μ","decl":"theorem AECover.integrable_of_integral_tendsto_of_nonneg_ae [l.NeBot] [l.IsCountablyGenerated]\n    {φ : ι → Set α} (hφ : AECover μ l φ) {f : α → ℝ} (I : ℝ) (hfi : ∀ i, IntegrableOn f (φ i) μ)\n    (hnng : ∀ᵐ x ∂μ, 0 ≤ f x) (htendsto : Tendsto (fun i => ∫ x in φ i, f x ∂μ) l (𝓝 I)) :\n    Integrable f μ :=\n  let ⟨I', hI'⟩ := htendsto.isBoundedUnder_le\n  hφ.integrable_of_integral_bounded_of_nonneg_ae I' hfi hnng hI'\n\n"}
{"name":"MeasureTheory.AECover.integral_tendsto_of_countably_generated","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\nE : Type u_3\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → E\nhfi : MeasureTheory.Integrable f μ\n⊢ Filter.Tendsto (fun i => MeasureTheory.integral (μ.restrict (φ i)) fun x => f x) l (nhds (MeasureTheory.integral μ fun x => f x))","decl":"theorem AECover.integral_tendsto_of_countably_generated [l.IsCountablyGenerated] {φ : ι → Set α}\n    (hφ : AECover μ l φ) {f : α → E} (hfi : Integrable f μ) :\n    Tendsto (fun i => ∫ x in φ i, f x ∂μ) l (𝓝 <| ∫ x, f x ∂μ) :=\n  suffices h : Tendsto (fun i => ∫ x : α, (φ i).indicator f x ∂μ) l (𝓝 (∫ x : α, f x ∂μ)) from by\n    convert h using 2; rw [integral_indicator (hφ.measurableSet _)]\n  tendsto_integral_filter_of_dominated_convergence (fun x => ‖f x‖)\n    (Eventually.of_forall fun i => hfi.aestronglyMeasurable.indicator <| hφ.measurableSet i)\n    (Eventually.of_forall fun _ => ae_of_all _ fun _ => norm_indicator_le_norm_self _ _) hfi.norm\n    (hφ.ae_tendsto_indicator f)\n\n"}
{"name":"MeasureTheory.AECover.integral_eq_of_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\nE : Type u_3\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → E\nI : E\nhfi : MeasureTheory.Integrable f μ\nh : Filter.Tendsto (fun n => MeasureTheory.integral (μ.restrict (φ n)) fun x => f x) l (nhds I)\n⊢ Eq (MeasureTheory.integral μ fun x => f x) I","decl":"/-- Slight reformulation of\n    `MeasureTheory.AECover.integral_tendsto_of_countably_generated`. -/\ntheorem AECover.integral_eq_of_tendsto [l.NeBot] [l.IsCountablyGenerated] {φ : ι → Set α}\n    (hφ : AECover μ l φ) {f : α → E} (I : E) (hfi : Integrable f μ)\n    (h : Tendsto (fun n => ∫ x in φ n, f x ∂μ) l (𝓝 I)) : ∫ x, f x ∂μ = I :=\n  tendsto_nhds_unique (hφ.integral_tendsto_of_countably_generated hfi) h\n\n"}
{"name":"MeasureTheory.AECover.integral_eq_of_tendsto_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\nl : Filter ι\ninst✝¹ : l.NeBot\ninst✝ : l.IsCountablyGenerated\nφ : ι → Set α\nhφ : MeasureTheory.AECover μ l φ\nf : α → Real\nI : Real\nhnng : (MeasureTheory.ae μ).EventuallyLE 0 f\nhfi : ∀ (n : ι), MeasureTheory.IntegrableOn f (φ n) μ\nhtendsto : Filter.Tendsto (fun n => MeasureTheory.integral (μ.restrict (φ n)) fun x => f x) l (nhds I)\n⊢ Eq (MeasureTheory.integral μ fun x => f x) I","decl":"theorem AECover.integral_eq_of_tendsto_of_nonneg_ae [l.NeBot] [l.IsCountablyGenerated]\n    {φ : ι → Set α} (hφ : AECover μ l φ) {f : α → ℝ} (I : ℝ) (hnng : 0 ≤ᵐ[μ] f)\n    (hfi : ∀ n, IntegrableOn f (φ n) μ) (htendsto : Tendsto (fun n => ∫ x in φ n, f x ∂μ) l (𝓝 I)) :\n    ∫ x, f x ∂μ = I :=\n  have hfi' : Integrable f μ := hφ.integrable_of_integral_tendsto_of_nonneg_ae I hfi hnng htendsto\n  hφ.integral_eq_of_tendsto I hfi' htendsto\n\n"}
{"name":"MeasureTheory.integrable_of_intervalIntegral_norm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"ι : Type u_1\nE : Type u_2\nμ : MeasureTheory.Measure Real\nl : Filter ι\ninst✝² : l.NeBot\ninst✝¹ : l.IsCountablyGenerated\ninst✝ : NormedAddCommGroup E\na b : ι → Real\nf : Real → E\nI : Real\nhfi : ∀ (i : ι), MeasureTheory.IntegrableOn f (Set.Ioc (a i) (b i)) μ\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\nh : Filter.Eventually (fun i => LE.le (intervalIntegral (fun x => Norm.norm (f x)) (a i) (b i) μ) I) l\n⊢ MeasureTheory.Integrable f μ","decl":"theorem integrable_of_intervalIntegral_norm_bounded (I : ℝ)\n    (hfi : ∀ i, IntegrableOn f (Ioc (a i) (b i)) μ) (ha : Tendsto a l atBot)\n    (hb : Tendsto b l atTop) (h : ∀ᶠ i in l, (∫ x in a i..b i, ‖f x‖ ∂μ) ≤ I) : Integrable f μ := by\n  have hφ : AECover μ l _ := aecover_Ioc ha hb\n  refine hφ.integrable_of_integral_norm_bounded I hfi (h.mp ?_)\n  filter_upwards [ha.eventually (eventually_le_atBot 0),\n    hb.eventually (eventually_ge_atTop 0)] with i hai hbi ht\n  rwa [← intervalIntegral.integral_of_le (hai.trans hbi)]\n\n"}
{"name":"MeasureTheory.integrable_of_intervalIntegral_norm_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"ι : Type u_1\nE : Type u_2\nμ : MeasureTheory.Measure Real\nl : Filter ι\ninst✝² : l.NeBot\ninst✝¹ : l.IsCountablyGenerated\ninst✝ : NormedAddCommGroup E\na b : ι → Real\nf : Real → E\nI : Real\nhfi : ∀ (i : ι), MeasureTheory.IntegrableOn f (Set.Ioc (a i) (b i)) μ\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\nh : Filter.Tendsto (fun i => intervalIntegral (fun x => Norm.norm (f x)) (a i) (b i) μ) l (nhds I)\n⊢ MeasureTheory.Integrable f μ","decl":"/-- If `f` is integrable on intervals `Ioc (a i) (b i)`,\nwhere `a i` tends to -∞ and `b i` tends to ∞, and\n`∫ x in a i .. b i, ‖f x‖ ∂μ` converges to `I : ℝ` along a filter `l`,\nthen `f` is integrable on the interval (-∞, ∞) -/\ntheorem integrable_of_intervalIntegral_norm_tendsto (I : ℝ)\n    (hfi : ∀ i, IntegrableOn f (Ioc (a i) (b i)) μ) (ha : Tendsto a l atBot)\n    (hb : Tendsto b l atTop) (h : Tendsto (fun i => ∫ x in a i..b i, ‖f x‖ ∂μ) l (𝓝 I)) :\n    Integrable f μ :=\n  let ⟨I', hI'⟩ := h.isBoundedUnder_le\n  integrable_of_intervalIntegral_norm_bounded I' hfi ha hb hI'\n\n"}
{"name":"MeasureTheory.integrableOn_Iic_of_intervalIntegral_norm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"ι : Type u_1\nE : Type u_2\nμ : MeasureTheory.Measure Real\nl : Filter ι\ninst✝² : l.NeBot\ninst✝¹ : l.IsCountablyGenerated\ninst✝ : NormedAddCommGroup E\na : ι → Real\nf : Real → E\nI b : Real\nhfi : ∀ (i : ι), MeasureTheory.IntegrableOn f (Set.Ioc (a i) b) μ\nha : Filter.Tendsto a l Filter.atBot\nh : Filter.Eventually (fun i => LE.le (intervalIntegral (fun x => Norm.norm (f x)) (a i) b μ) I) l\n⊢ MeasureTheory.IntegrableOn f (Set.Iic b) μ","decl":"theorem integrableOn_Iic_of_intervalIntegral_norm_bounded (I b : ℝ)\n    (hfi : ∀ i, IntegrableOn f (Ioc (a i) b) μ) (ha : Tendsto a l atBot)\n    (h : ∀ᶠ i in l, (∫ x in a i..b, ‖f x‖ ∂μ) ≤ I) : IntegrableOn f (Iic b) μ := by\n  have hφ : AECover (μ.restrict <| Iic b) l _ := aecover_Ioi ha\n  have hfi : ∀ i, IntegrableOn f (Ioi (a i)) (μ.restrict <| Iic b) := by\n    intro i\n    rw [IntegrableOn, Measure.restrict_restrict (hφ.measurableSet i)]\n    exact hfi i\n  refine hφ.integrable_of_integral_norm_bounded I hfi (h.mp ?_)\n  filter_upwards [ha.eventually (eventually_le_atBot b)] with i hai\n  rw [intervalIntegral.integral_of_le hai, Measure.restrict_restrict (hφ.measurableSet i)]\n  exact id\n\n"}
{"name":"MeasureTheory.integrableOn_Iic_of_intervalIntegral_norm_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"ι : Type u_1\nE : Type u_2\nμ : MeasureTheory.Measure Real\nl : Filter ι\ninst✝² : l.NeBot\ninst✝¹ : l.IsCountablyGenerated\ninst✝ : NormedAddCommGroup E\na : ι → Real\nf : Real → E\nI b : Real\nhfi : ∀ (i : ι), MeasureTheory.IntegrableOn f (Set.Ioc (a i) b) μ\nha : Filter.Tendsto a l Filter.atBot\nh : Filter.Tendsto (fun i => intervalIntegral (fun x => Norm.norm (f x)) (a i) b μ) l (nhds I)\n⊢ MeasureTheory.IntegrableOn f (Set.Iic b) μ","decl":"/-- If `f` is integrable on intervals `Ioc (a i) b`,\nwhere `a i` tends to -∞, and\n`∫ x in a i .. b, ‖f x‖ ∂μ` converges to `I : ℝ` along a filter `l`,\nthen `f` is integrable on the interval (-∞, b) -/\ntheorem integrableOn_Iic_of_intervalIntegral_norm_tendsto (I b : ℝ)\n    (hfi : ∀ i, IntegrableOn f (Ioc (a i) b) μ) (ha : Tendsto a l atBot)\n    (h : Tendsto (fun i => ∫ x in a i..b, ‖f x‖ ∂μ) l (𝓝 I)) : IntegrableOn f (Iic b) μ :=\n  let ⟨I', hI'⟩ := h.isBoundedUnder_le\n  integrableOn_Iic_of_intervalIntegral_norm_bounded I' b hfi ha hI'\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_of_intervalIntegral_norm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"ι : Type u_1\nE : Type u_2\nμ : MeasureTheory.Measure Real\nl : Filter ι\ninst✝² : l.NeBot\ninst✝¹ : l.IsCountablyGenerated\ninst✝ : NormedAddCommGroup E\nb : ι → Real\nf : Real → E\nI a : Real\nhfi : ∀ (i : ι), MeasureTheory.IntegrableOn f (Set.Ioc a (b i)) μ\nhb : Filter.Tendsto b l Filter.atTop\nh : Filter.Eventually (fun i => LE.le (intervalIntegral (fun x => Norm.norm (f x)) a (b i) μ) I) l\n⊢ MeasureTheory.IntegrableOn f (Set.Ioi a) μ","decl":"theorem integrableOn_Ioi_of_intervalIntegral_norm_bounded (I a : ℝ)\n    (hfi : ∀ i, IntegrableOn f (Ioc a (b i)) μ) (hb : Tendsto b l atTop)\n    (h : ∀ᶠ i in l, (∫ x in a..b i, ‖f x‖ ∂μ) ≤ I) : IntegrableOn f (Ioi a) μ := by\n  have hφ : AECover (μ.restrict <| Ioi a) l _ := aecover_Iic hb\n  have hfi : ∀ i, IntegrableOn f (Iic (b i)) (μ.restrict <| Ioi a) := by\n    intro i\n    rw [IntegrableOn, Measure.restrict_restrict (hφ.measurableSet i), inter_comm]\n    exact hfi i\n  refine hφ.integrable_of_integral_norm_bounded I hfi (h.mp ?_)\n  filter_upwards [hb.eventually (eventually_ge_atTop a)] with i hbi\n  rw [intervalIntegral.integral_of_le hbi, Measure.restrict_restrict (hφ.measurableSet i),\n    inter_comm]\n  exact id\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_of_intervalIntegral_norm_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"ι : Type u_1\nE : Type u_2\nμ : MeasureTheory.Measure Real\nl : Filter ι\ninst✝² : l.NeBot\ninst✝¹ : l.IsCountablyGenerated\ninst✝ : NormedAddCommGroup E\nb : ι → Real\nf : Real → E\nI a : Real\nhfi : ∀ (i : ι), MeasureTheory.IntegrableOn f (Set.Ioc a (b i)) μ\nhb : Filter.Tendsto b l Filter.atTop\nh : Filter.Tendsto (fun i => intervalIntegral (fun x => Norm.norm (f x)) a (b i) μ) l (nhds I)\n⊢ MeasureTheory.IntegrableOn f (Set.Ioi a) μ","decl":"/-- If `f` is integrable on intervals `Ioc a (b i)`,\nwhere `b i` tends to ∞, and\n`∫ x in a .. b i, ‖f x‖ ∂μ` converges to `I : ℝ` along a filter `l`,\nthen `f` is integrable on the interval (a, ∞) -/\ntheorem integrableOn_Ioi_of_intervalIntegral_norm_tendsto (I a : ℝ)\n    (hfi : ∀ i, IntegrableOn f (Ioc a (b i)) μ) (hb : Tendsto b l atTop)\n    (h : Tendsto (fun i => ∫ x in a..b i, ‖f x‖ ∂μ) l (𝓝 <| I)) : IntegrableOn f (Ioi a) μ :=\n  let ⟨I', hI'⟩ := h.isBoundedUnder_le\n  integrableOn_Ioi_of_intervalIntegral_norm_bounded I' a hfi hb hI'\n\n"}
{"name":"MeasureTheory.integrableOn_Ioc_of_intervalIntegral_norm_bounded","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"ι : Type u_1\nE : Type u_2\nl : Filter ι\ninst✝² : l.NeBot\ninst✝¹ : l.IsCountablyGenerated\ninst✝ : NormedAddCommGroup E\na b : ι → Real\nf : Real → E\nI a₀ b₀ : Real\nhfi : ∀ (i : ι), MeasureTheory.IntegrableOn f (Set.Ioc (a i) (b i)) MeasureTheory.MeasureSpace.volume\nha : Filter.Tendsto a l (nhds a₀)\nhb : Filter.Tendsto b l (nhds b₀)\nh : Filter.Eventually (fun i => LE.le (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc (a i) (b i))) fun x => Norm.norm (f x)) I) l\n⊢ MeasureTheory.IntegrableOn f (Set.Ioc a₀ b₀) MeasureTheory.MeasureSpace.volume","decl":"theorem integrableOn_Ioc_of_intervalIntegral_norm_bounded {I a₀ b₀ : ℝ}\n    (hfi : ∀ i, IntegrableOn f <| Ioc (a i) (b i)) (ha : Tendsto a l <| 𝓝 a₀)\n    (hb : Tendsto b l <| 𝓝 b₀) (h : ∀ᶠ i in l, (∫ x in Ioc (a i) (b i), ‖f x‖) ≤ I) :\n    IntegrableOn f (Ioc a₀ b₀) := by\n  refine (aecover_Ioc_of_Ioc ha hb).integrable_of_integral_norm_bounded I\n    (fun i => (hfi i).restrict measurableSet_Ioc) (h.mono fun i hi ↦ ?_)\n  rw [Measure.restrict_restrict measurableSet_Ioc]\n  refine le_trans (setIntegral_mono_set (hfi i).norm ?_ ?_) hi <;> apply ae_of_all\n  · simp only [Pi.zero_apply, norm_nonneg, forall_const]\n  · intro c hc; exact hc.1\n\n"}
{"name":"MeasureTheory.integrableOn_Ioc_of_intervalIntegral_norm_bounded_left","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"ι : Type u_1\nE : Type u_2\nl : Filter ι\ninst✝² : l.NeBot\ninst✝¹ : l.IsCountablyGenerated\ninst✝ : NormedAddCommGroup E\na : ι → Real\nf : Real → E\nI a₀ b : Real\nhfi : ∀ (i : ι), MeasureTheory.IntegrableOn f (Set.Ioc (a i) b) MeasureTheory.MeasureSpace.volume\nha : Filter.Tendsto a l (nhds a₀)\nh : Filter.Eventually (fun i => LE.le (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc (a i) b)) fun x => Norm.norm (f x)) I) l\n⊢ MeasureTheory.IntegrableOn f (Set.Ioc a₀ b) MeasureTheory.MeasureSpace.volume","decl":"theorem integrableOn_Ioc_of_intervalIntegral_norm_bounded_left {I a₀ b : ℝ}\n    (hfi : ∀ i, IntegrableOn f <| Ioc (a i) b) (ha : Tendsto a l <| 𝓝 a₀)\n    (h : ∀ᶠ i in l, (∫ x in Ioc (a i) b, ‖f x‖) ≤ I) : IntegrableOn f (Ioc a₀ b) :=\n  integrableOn_Ioc_of_intervalIntegral_norm_bounded hfi ha tendsto_const_nhds h\n\n"}
{"name":"MeasureTheory.integrableOn_Ioc_of_intervalIntegral_norm_bounded_right","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"ι : Type u_1\nE : Type u_2\nl : Filter ι\ninst✝² : l.NeBot\ninst✝¹ : l.IsCountablyGenerated\ninst✝ : NormedAddCommGroup E\nb : ι → Real\nf : Real → E\nI a b₀ : Real\nhfi : ∀ (i : ι), MeasureTheory.IntegrableOn f (Set.Ioc a (b i)) MeasureTheory.MeasureSpace.volume\nhb : Filter.Tendsto b l (nhds b₀)\nh : Filter.Eventually (fun i => LE.le (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc a (b i))) fun x => Norm.norm (f x)) I) l\n⊢ MeasureTheory.IntegrableOn f (Set.Ioc a b₀) MeasureTheory.MeasureSpace.volume","decl":"theorem integrableOn_Ioc_of_intervalIntegral_norm_bounded_right {I a b₀ : ℝ}\n    (hfi : ∀ i, IntegrableOn f <| Ioc a (b i)) (hb : Tendsto b l <| 𝓝 b₀)\n    (h : ∀ᶠ i in l, (∫ x in Ioc a (b i), ‖f x‖) ≤ I) : IntegrableOn f (Ioc a b₀) :=\n  integrableOn_Ioc_of_intervalIntegral_norm_bounded hfi tendsto_const_nhds hb h\n\n"}
{"name":"MeasureTheory.intervalIntegral_tendsto_integral","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"ι : Type u_1\nE : Type u_2\nμ : MeasureTheory.Measure Real\nl : Filter ι\ninst✝² : l.IsCountablyGenerated\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na b : ι → Real\nf : Real → E\nhfi : MeasureTheory.Integrable f μ\nha : Filter.Tendsto a l Filter.atBot\nhb : Filter.Tendsto b l Filter.atTop\n⊢ Filter.Tendsto (fun i => intervalIntegral (fun x => f x) (a i) (b i) μ) l (nhds (MeasureTheory.integral μ fun x => f x))","decl":"theorem intervalIntegral_tendsto_integral (hfi : Integrable f μ) (ha : Tendsto a l atBot)\n    (hb : Tendsto b l atTop) : Tendsto (fun i => ∫ x in a i..b i, f x ∂μ) l (𝓝 <| ∫ x, f x ∂μ) := by\n  let φ i := Ioc (a i) (b i)\n  have hφ : AECover μ l φ := aecover_Ioc ha hb\n  refine (hφ.integral_tendsto_of_countably_generated hfi).congr' ?_\n  filter_upwards [ha.eventually (eventually_le_atBot 0),\n    hb.eventually (eventually_ge_atTop 0)] with i hai hbi\n  exact (intervalIntegral.integral_of_le (hai.trans hbi)).symm\n\n"}
{"name":"MeasureTheory.intervalIntegral_tendsto_integral_Iic","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"ι : Type u_1\nE : Type u_2\nμ : MeasureTheory.Measure Real\nl : Filter ι\ninst✝² : l.IsCountablyGenerated\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na : ι → Real\nf : Real → E\nb : Real\nhfi : MeasureTheory.IntegrableOn f (Set.Iic b) μ\nha : Filter.Tendsto a l Filter.atBot\n⊢ Filter.Tendsto (fun i => intervalIntegral (fun x => f x) (a i) b μ) l (nhds (MeasureTheory.integral (μ.restrict (Set.Iic b)) fun x => f x))","decl":"theorem intervalIntegral_tendsto_integral_Iic (b : ℝ) (hfi : IntegrableOn f (Iic b) μ)\n    (ha : Tendsto a l atBot) :\n    Tendsto (fun i => ∫ x in a i..b, f x ∂μ) l (𝓝 <| ∫ x in Iic b, f x ∂μ) := by\n  let φ i := Ioi (a i)\n  have hφ : AECover (μ.restrict <| Iic b) l φ := aecover_Ioi ha\n  refine (hφ.integral_tendsto_of_countably_generated hfi).congr' ?_\n  filter_upwards [ha.eventually (eventually_le_atBot <| b)] with i hai\n  rw [intervalIntegral.integral_of_le hai, Measure.restrict_restrict (hφ.measurableSet i)]\n  rfl\n\n"}
{"name":"MeasureTheory.intervalIntegral_tendsto_integral_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"ι : Type u_1\nE : Type u_2\nμ : MeasureTheory.Measure Real\nl : Filter ι\ninst✝² : l.IsCountablyGenerated\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nb : ι → Real\nf : Real → E\na : Real\nhfi : MeasureTheory.IntegrableOn f (Set.Ioi a) μ\nhb : Filter.Tendsto b l Filter.atTop\n⊢ Filter.Tendsto (fun i => intervalIntegral (fun x => f x) a (b i) μ) l (nhds (MeasureTheory.integral (μ.restrict (Set.Ioi a)) fun x => f x))","decl":"theorem intervalIntegral_tendsto_integral_Ioi (a : ℝ) (hfi : IntegrableOn f (Ioi a) μ)\n    (hb : Tendsto b l atTop) :\n    Tendsto (fun i => ∫ x in a..b i, f x ∂μ) l (𝓝 <| ∫ x in Ioi a, f x ∂μ) := by\n  let φ i := Iic (b i)\n  have hφ : AECover (μ.restrict <| Ioi a) l φ := aecover_Iic hb\n  refine (hφ.integral_tendsto_of_countably_generated hfi).congr' ?_\n  filter_upwards [hb.eventually (eventually_ge_atTop <| a)] with i hbi\n  rw [intervalIntegral.integral_of_le hbi, Measure.restrict_restrict (hφ.measurableSet i),\n    inter_comm]\n  rfl\n\n"}
{"name":"MeasureTheory.tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real → E\na : Real\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nhderiv : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Ioi a) MeasureTheory.MeasureSpace.volume\n⊢ Filter.Tendsto f Filter.atTop (nhds (limUnder Filter.atTop f))","decl":"/-- If the derivative of a function defined on the real line is integrable close to `+∞`, then\nthe function has a limit at `+∞`. -/\ntheorem tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi [CompleteSpace E]\n    (hderiv : ∀ x ∈ Ioi a, HasDerivAt f (f' x) x) (f'int : IntegrableOn f' (Ioi a)) :\n    Tendsto f atTop (𝓝 (limUnder atTop f)) := by\n  suffices ∃ a, Tendsto f atTop (𝓝 a) from tendsto_nhds_limUnder this\n  suffices CauchySeq f from cauchySeq_tendsto_of_complete this\n  apply Metric.cauchySeq_iff'.2 (fun ε εpos ↦ ?_)\n  have A : ∀ᶠ (n : ℕ) in atTop, ∫ (x : ℝ) in Ici ↑n, ‖f' x‖ < ε := by\n    have L : Tendsto (fun (n : ℕ) ↦ ∫ x in Ici (n : ℝ), ‖f' x‖) atTop\n        (𝓝 (∫ x in ⋂ (n : ℕ), Ici (n : ℝ), ‖f' x‖)) := by\n      apply tendsto_setIntegral_of_antitone (fun n ↦ measurableSet_Ici)\n      · intro m n hmn\n        exact Ici_subset_Ici.2 (Nat.cast_le.mpr hmn)\n      · rcases exists_nat_gt a with ⟨n, hn⟩\n        exact ⟨n, IntegrableOn.mono_set f'int.norm (Ici_subset_Ioi.2 hn)⟩\n    have B : ⋂ (n : ℕ), Ici (n : ℝ) = ∅ := by\n      apply eq_empty_of_forall_not_mem (fun x ↦ ?_)\n      simpa only [mem_iInter, mem_Ici, not_forall, not_le] using exists_nat_gt x\n    simp only [B, Measure.restrict_empty, integral_zero_measure] at L\n    exact (tendsto_order.1 L).2 _ εpos\n  have B : ∀ᶠ (n : ℕ) in atTop, a < n := by\n    rcases exists_nat_gt a with ⟨n, hn⟩\n    filter_upwards [Ioi_mem_atTop n] with m (hm : n < m) using hn.trans (Nat.cast_lt.mpr hm)\n  rcases (A.and B).exists with ⟨N, hN, h'N⟩\n  refine ⟨N, fun x hx ↦ ?_⟩\n  calc\n  dist (f x) (f ↑N)\n    = ‖f x - f N‖ := dist_eq_norm _ _\n  _ = ‖∫ t in Ioc ↑N x, f' t‖ := by\n      rw [← intervalIntegral.integral_of_le hx, intervalIntegral.integral_eq_sub_of_hasDerivAt]\n      · intro y hy\n        simp only [hx, uIcc_of_le, mem_Icc] at hy\n        exact hderiv _ (h'N.trans_le hy.1)\n      · rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hx]\n        exact f'int.mono_set (Ioc_subset_Ioi_self.trans (Ioi_subset_Ioi h'N.le))\n  _ ≤ ∫ t in Ioc ↑N x, ‖f' t‖ := norm_integral_le_integral_norm fun a ↦ f' a\n  _ ≤ ∫ t in Ici ↑N, ‖f' t‖ := by\n      apply setIntegral_mono_set\n      · apply IntegrableOn.mono_set f'int.norm (Ici_subset_Ioi.2 h'N)\n      · filter_upwards with x using norm_nonneg _\n      · have : Ioc (↑N) x ⊆ Ici ↑N := Ioc_subset_Ioi_self.trans Ioi_subset_Ici_self\n        exact this.eventuallyLE\n  _ < ε := hN\n\n"}
{"name":"MeasureTheory.tendsto_zero_of_hasDerivAt_of_integrableOn_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real → E\na : Real\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nhderiv : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nfint : MeasureTheory.IntegrableOn f (Set.Ioi a) MeasureTheory.MeasureSpace.volume\n⊢ Filter.Tendsto f Filter.atTop (nhds 0)","decl":"open UniformSpace in\n/-- If a function and its derivative are integrable on `(a, +∞)`, then the function tends to zero\nat `+∞`. -/\ntheorem tendsto_zero_of_hasDerivAt_of_integrableOn_Ioi\n    (hderiv : ∀ x ∈ Ioi a, HasDerivAt f (f' x) x)\n    (f'int : IntegrableOn f' (Ioi a)) (fint : IntegrableOn f (Ioi a)) :\n    Tendsto f atTop (𝓝 0) := by\n  let F : E →L[ℝ] Completion E := Completion.toComplL\n  have Fderiv : ∀ x ∈ Ioi a, HasDerivAt (F ∘ f) (F (f' x)) x :=\n    fun x hx ↦ F.hasFDerivAt.comp_hasDerivAt _ (hderiv x hx)\n  have Fint : IntegrableOn (F ∘ f) (Ioi a) := by apply F.integrable_comp fint\n  have F'int : IntegrableOn (F ∘ f') (Ioi a) := by apply F.integrable_comp f'int\n  have A : Tendsto (F ∘ f) atTop (𝓝 (limUnder atTop (F ∘ f))) := by\n    apply tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi Fderiv F'int\n  have B : limUnder atTop (F ∘ f) = F 0 := by\n    have : IntegrableAtFilter (F ∘ f) atTop := by exact ⟨Ioi a, Ioi_mem_atTop _, Fint⟩\n    apply IntegrableAtFilter.eq_zero_of_tendsto this ?_ A\n    intro s hs\n    rcases mem_atTop_sets.1 hs with ⟨b, hb⟩\n    rw [← top_le_iff, ← volume_Ici (a := b)]\n    exact measure_mono hb\n  rwa [B, ← IsEmbedding.tendsto_nhds_iff] at A\n  exact (Completion.isUniformEmbedding_coe E).isEmbedding\n\n"}
{"name":"MeasureTheory.integral_Ioi_of_hasDerivAt_of_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real → E\na : Real\nm : E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nhcont : ContinuousWithinAt f (Set.Ici a) a\nhderiv : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nhf : Filter.Tendsto f Filter.atTop (nhds m)\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => f' x) (HSub.hSub m (f a))","decl":"/-- **Fundamental theorem of calculus-2**, on semi-infinite intervals `(a, +∞)`.\nWhen a function has a limit at infinity `m`, and its derivative is integrable, then the\nintegral of the derivative on `(a, +∞)` is `m - f a`. Version assuming differentiability\non `(a, +∞)` and continuity at `a⁺`.\n\nNote that such a function always has a limit at infinity,\nsee `tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi`. -/\ntheorem integral_Ioi_of_hasDerivAt_of_tendsto (hcont : ContinuousWithinAt f (Ici a) a)\n    (hderiv : ∀ x ∈ Ioi a, HasDerivAt f (f' x) x) (f'int : IntegrableOn f' (Ioi a))\n    (hf : Tendsto f atTop (𝓝 m)) : ∫ x in Ioi a, f' x = m - f a := by\n  have hcont : ContinuousOn f (Ici a) := by\n    intro x hx\n    rcases hx.out.eq_or_lt with rfl|hx\n    · exact hcont\n    · exact (hderiv x hx).continuousAt.continuousWithinAt\n  refine tendsto_nhds_unique (intervalIntegral_tendsto_integral_Ioi a f'int tendsto_id) ?_\n  apply Tendsto.congr' _ (hf.sub_const _)\n  filter_upwards [Ioi_mem_atTop a] with x hx\n  have h'x : a ≤ id x := le_of_lt hx\n  symm\n  apply\n    intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le h'x (hcont.mono Icc_subset_Ici_self)\n      fun y hy => hderiv y hy.1\n  rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x]\n  exact f'int.mono (fun y hy => hy.1) le_rfl\n\n"}
{"name":"MeasureTheory.integral_Ioi_of_hasDerivAt_of_tendsto'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real → E\na : Real\nm : E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nhderiv : ∀ (x : Real), Membership.mem (Set.Ici a) x → HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nhf : Filter.Tendsto f Filter.atTop (nhds m)\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => f' x) (HSub.hSub m (f a))","decl":"/-- **Fundamental theorem of calculus-2**, on semi-infinite intervals `(a, +∞)`.\nWhen a function has a limit at infinity `m`, and its derivative is integrable, then the\nintegral of the derivative on `(a, +∞)` is `m - f a`. Version assuming differentiability\non `[a, +∞)`.\n\nNote that such a function always has a limit at infinity,\nsee `tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi`. -/\ntheorem integral_Ioi_of_hasDerivAt_of_tendsto' (hderiv : ∀ x ∈ Ici a, HasDerivAt f (f' x) x)\n    (f'int : IntegrableOn f' (Ioi a)) (hf : Tendsto f atTop (𝓝 m)) :\n    ∫ x in Ioi a, f' x = m - f a := by\n  refine integral_Ioi_of_hasDerivAt_of_tendsto ?_ (fun x hx => hderiv x hx.out.le)\n    f'int hf\n  exact (hderiv a left_mem_Ici).continuousAt.continuousWithinAt\n\n"}
{"name":"HasCompactSupport.integral_Ioi_deriv_eq","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf : Real → E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nhf : ContDiff Real 1 f\nh2f : HasCompactSupport f\nb : Real\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi b)) fun x => deriv f x) (Neg.neg (f b))","decl":"/-- A special case of `integral_Ioi_of_hasDerivAt_of_tendsto` where we assume that `f` is C^1 with\ncompact support. -/\ntheorem _root_.HasCompactSupport.integral_Ioi_deriv_eq (hf : ContDiff ℝ 1 f)\n    (h2f : HasCompactSupport f) (b : ℝ) : ∫ x in Ioi b, deriv f x = - f b := by\n  have := fun x (_ : x ∈ Ioi b) ↦ hf.differentiable le_rfl x |>.hasDerivAt\n  rw [integral_Ioi_of_hasDerivAt_of_tendsto hf.continuous.continuousWithinAt this, zero_sub]\n  · refine hf.continuous_deriv le_rfl |>.integrable_of_hasCompactSupport h2f.deriv |>.integrableOn\n  rw [hasCompactSupport_iff_eventuallyEq, Filter.coclosedCompact_eq_cocompact] at h2f\n  exact h2f.filter_mono _root_.atTop_le_cocompact |>.tendsto\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_deriv_of_nonneg","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real → Real\na l : Real\nhcont : ContinuousWithinAt g (Set.Ici a) a\nhderiv : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivAt g (g' x) x\ng'pos : ∀ (x : Real), Membership.mem (Set.Ioi a) x → LE.le 0 (g' x)\nhg : Filter.Tendsto g Filter.atTop (nhds l)\n⊢ MeasureTheory.IntegrableOn g' (Set.Ioi a) MeasureTheory.MeasureSpace.volume","decl":"/-- When a function has a limit at infinity, and its derivative is nonnegative, then the derivative\nis automatically integrable on `(a, +∞)`. Version assuming differentiability\non `(a, +∞)` and continuity at `a⁺`. -/\ntheorem integrableOn_Ioi_deriv_of_nonneg (hcont : ContinuousWithinAt g (Ici a) a)\n    (hderiv : ∀ x ∈ Ioi a, HasDerivAt g (g' x) x) (g'pos : ∀ x ∈ Ioi a, 0 ≤ g' x)\n    (hg : Tendsto g atTop (𝓝 l)) : IntegrableOn g' (Ioi a) := by\n  have hcont : ContinuousOn g (Ici a) := by\n    intro x hx\n    rcases hx.out.eq_or_lt with rfl|hx\n    · exact hcont\n    · exact (hderiv x hx).continuousAt.continuousWithinAt\n  refine integrableOn_Ioi_of_intervalIntegral_norm_tendsto (l - g a) a (fun x => ?_) tendsto_id ?_\n  · exact intervalIntegral.integrableOn_deriv_of_nonneg (hcont.mono Icc_subset_Ici_self)\n      (fun y hy => hderiv y hy.1) fun y hy => g'pos y hy.1\n  apply Tendsto.congr' _ (hg.sub_const _)\n  filter_upwards [Ioi_mem_atTop a] with x hx\n  have h'x : a ≤ id x := le_of_lt hx\n  calc\n    g x - g a = ∫ y in a..id x, g' y := by\n      symm\n      apply intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le h'x\n        (hcont.mono Icc_subset_Ici_self) fun y hy => hderiv y hy.1\n      rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x]\n      exact intervalIntegral.integrableOn_deriv_of_nonneg (hcont.mono Icc_subset_Ici_self)\n        (fun y hy => hderiv y hy.1) fun y hy => g'pos y hy.1\n    _ = ∫ y in a..id x, ‖g' y‖ := by\n      simp_rw [intervalIntegral.integral_of_le h'x]\n      refine setIntegral_congr_fun measurableSet_Ioc fun y hy => ?_\n      dsimp\n      rw [abs_of_nonneg]\n      exact g'pos _ hy.1\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_deriv_of_nonneg'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real → Real\na l : Real\nhderiv : ∀ (x : Real), Membership.mem (Set.Ici a) x → HasDerivAt g (g' x) x\ng'pos : ∀ (x : Real), Membership.mem (Set.Ioi a) x → LE.le 0 (g' x)\nhg : Filter.Tendsto g Filter.atTop (nhds l)\n⊢ MeasureTheory.IntegrableOn g' (Set.Ioi a) MeasureTheory.MeasureSpace.volume","decl":"/-- When a function has a limit at infinity, and its derivative is nonnegative, then the derivative\nis automatically integrable on `(a, +∞)`. Version assuming differentiability\non `[a, +∞)`. -/\ntheorem integrableOn_Ioi_deriv_of_nonneg' (hderiv : ∀ x ∈ Ici a, HasDerivAt g (g' x) x)\n    (g'pos : ∀ x ∈ Ioi a, 0 ≤ g' x) (hg : Tendsto g atTop (𝓝 l)) : IntegrableOn g' (Ioi a) := by\n  refine integrableOn_Ioi_deriv_of_nonneg ?_ (fun x hx => hderiv x hx.out.le) g'pos hg\n  exact (hderiv a left_mem_Ici).continuousAt.continuousWithinAt\n\n"}
{"name":"MeasureTheory.integral_Ioi_of_hasDerivAt_of_nonneg","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real → Real\na l : Real\nhcont : ContinuousWithinAt g (Set.Ici a) a\nhderiv : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivAt g (g' x) x\ng'pos : ∀ (x : Real), Membership.mem (Set.Ioi a) x → LE.le 0 (g' x)\nhg : Filter.Tendsto g Filter.atTop (nhds l)\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => g' x) (HSub.hSub l (g a))","decl":"/-- When a function has a limit at infinity `l`, and its derivative is nonnegative, then the\nintegral of the derivative on `(a, +∞)` is `l - g a` (and the derivative is integrable, see\n`integrable_on_Ioi_deriv_of_nonneg`). Version assuming differentiability on `(a, +∞)` and\ncontinuity at `a⁺`. -/\ntheorem integral_Ioi_of_hasDerivAt_of_nonneg (hcont : ContinuousWithinAt g (Ici a) a)\n    (hderiv : ∀ x ∈ Ioi a, HasDerivAt g (g' x) x) (g'pos : ∀ x ∈ Ioi a, 0 ≤ g' x)\n    (hg : Tendsto g atTop (𝓝 l)) : ∫ x in Ioi a, g' x = l - g a :=\n  integral_Ioi_of_hasDerivAt_of_tendsto hcont hderiv\n    (integrableOn_Ioi_deriv_of_nonneg hcont hderiv g'pos hg) hg\n\n"}
{"name":"MeasureTheory.integral_Ioi_of_hasDerivAt_of_nonneg'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real → Real\na l : Real\nhderiv : ∀ (x : Real), Membership.mem (Set.Ici a) x → HasDerivAt g (g' x) x\ng'pos : ∀ (x : Real), Membership.mem (Set.Ioi a) x → LE.le 0 (g' x)\nhg : Filter.Tendsto g Filter.atTop (nhds l)\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => g' x) (HSub.hSub l (g a))","decl":"/-- When a function has a limit at infinity `l`, and its derivative is nonnegative, then the\nintegral of the derivative on `(a, +∞)` is `l - g a` (and the derivative is integrable, see\n`integrable_on_Ioi_deriv_of_nonneg'`). Version assuming differentiability on `[a, +∞)`. -/\ntheorem integral_Ioi_of_hasDerivAt_of_nonneg' (hderiv : ∀ x ∈ Ici a, HasDerivAt g (g' x) x)\n    (g'pos : ∀ x ∈ Ioi a, 0 ≤ g' x) (hg : Tendsto g atTop (𝓝 l)) : ∫ x in Ioi a, g' x = l - g a :=\n  integral_Ioi_of_hasDerivAt_of_tendsto' hderiv (integrableOn_Ioi_deriv_of_nonneg' hderiv g'pos hg)\n    hg\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_deriv_of_nonpos","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real → Real\na l : Real\nhcont : ContinuousWithinAt g (Set.Ici a) a\nhderiv : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivAt g (g' x) x\ng'neg : ∀ (x : Real), Membership.mem (Set.Ioi a) x → LE.le (g' x) 0\nhg : Filter.Tendsto g Filter.atTop (nhds l)\n⊢ MeasureTheory.IntegrableOn g' (Set.Ioi a) MeasureTheory.MeasureSpace.volume","decl":"/-- When a function has a limit at infinity, and its derivative is nonpositive, then the derivative\nis automatically integrable on `(a, +∞)`. Version assuming differentiability\non `(a, +∞)` and continuity at `a⁺`. -/\ntheorem integrableOn_Ioi_deriv_of_nonpos (hcont : ContinuousWithinAt g (Ici a) a)\n    (hderiv : ∀ x ∈ Ioi a, HasDerivAt g (g' x) x) (g'neg : ∀ x ∈ Ioi a, g' x ≤ 0)\n    (hg : Tendsto g atTop (𝓝 l)) : IntegrableOn g' (Ioi a) := by\n  apply integrable_neg_iff.1\n  exact integrableOn_Ioi_deriv_of_nonneg hcont.neg (fun x hx => (hderiv x hx).neg)\n    (fun x hx => neg_nonneg_of_nonpos (g'neg x hx)) hg.neg\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_deriv_of_nonpos'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real → Real\na l : Real\nhderiv : ∀ (x : Real), Membership.mem (Set.Ici a) x → HasDerivAt g (g' x) x\ng'neg : ∀ (x : Real), Membership.mem (Set.Ioi a) x → LE.le (g' x) 0\nhg : Filter.Tendsto g Filter.atTop (nhds l)\n⊢ MeasureTheory.IntegrableOn g' (Set.Ioi a) MeasureTheory.MeasureSpace.volume","decl":"/-- When a function has a limit at infinity, and its derivative is nonpositive, then the derivative\nis automatically integrable on `(a, +∞)`. Version assuming differentiability\non `[a, +∞)`. -/\ntheorem integrableOn_Ioi_deriv_of_nonpos' (hderiv : ∀ x ∈ Ici a, HasDerivAt g (g' x) x)\n    (g'neg : ∀ x ∈ Ioi a, g' x ≤ 0) (hg : Tendsto g atTop (𝓝 l)) : IntegrableOn g' (Ioi a) := by\n  refine integrableOn_Ioi_deriv_of_nonpos ?_ (fun x hx ↦ hderiv x hx.out.le) g'neg hg\n  exact (hderiv a left_mem_Ici).continuousAt.continuousWithinAt\n\n"}
{"name":"MeasureTheory.integral_Ioi_of_hasDerivAt_of_nonpos","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real → Real\na l : Real\nhcont : ContinuousWithinAt g (Set.Ici a) a\nhderiv : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivAt g (g' x) x\ng'neg : ∀ (x : Real), Membership.mem (Set.Ioi a) x → LE.le (g' x) 0\nhg : Filter.Tendsto g Filter.atTop (nhds l)\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => g' x) (HSub.hSub l (g a))","decl":"/-- When a function has a limit at infinity `l`, and its derivative is nonpositive, then the\nintegral of the derivative on `(a, +∞)` is `l - g a` (and the derivative is integrable, see\n`integrable_on_Ioi_deriv_of_nonneg`). Version assuming differentiability on `(a, +∞)` and\ncontinuity at `a⁺`. -/\ntheorem integral_Ioi_of_hasDerivAt_of_nonpos (hcont : ContinuousWithinAt g (Ici a) a)\n    (hderiv : ∀ x ∈ Ioi a, HasDerivAt g (g' x) x) (g'neg : ∀ x ∈ Ioi a, g' x ≤ 0)\n    (hg : Tendsto g atTop (𝓝 l)) : ∫ x in Ioi a, g' x = l - g a :=\n  integral_Ioi_of_hasDerivAt_of_tendsto hcont hderiv\n    (integrableOn_Ioi_deriv_of_nonpos hcont hderiv g'neg hg) hg\n\n"}
{"name":"MeasureTheory.integral_Ioi_of_hasDerivAt_of_nonpos'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"g g' : Real → Real\na l : Real\nhderiv : ∀ (x : Real), Membership.mem (Set.Ici a) x → HasDerivAt g (g' x) x\ng'neg : ∀ (x : Real), Membership.mem (Set.Ioi a) x → LE.le (g' x) 0\nhg : Filter.Tendsto g Filter.atTop (nhds l)\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => g' x) (HSub.hSub l (g a))","decl":"/-- When a function has a limit at infinity `l`, and its derivative is nonpositive, then the\nintegral of the derivative on `(a, +∞)` is `l - g a` (and the derivative is integrable, see\n`integrable_on_Ioi_deriv_of_nonneg'`). Version assuming differentiability on `[a, +∞)`. -/\ntheorem integral_Ioi_of_hasDerivAt_of_nonpos' (hderiv : ∀ x ∈ Ici a, HasDerivAt g (g' x) x)\n    (g'neg : ∀ x ∈ Ioi a, g' x ≤ 0) (hg : Tendsto g atTop (𝓝 l)) : ∫ x in Ioi a, g' x = l - g a :=\n  integral_Ioi_of_hasDerivAt_of_tendsto' hderiv (integrableOn_Ioi_deriv_of_nonpos' hderiv g'neg hg)\n    hg\n\n"}
{"name":"MeasureTheory.tendsto_limUnder_of_hasDerivAt_of_integrableOn_Iic","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real → E\na : Real\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nhderiv : ∀ (x : Real), Membership.mem (Set.Iic a) x → HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Iic a) MeasureTheory.MeasureSpace.volume\n⊢ Filter.Tendsto f Filter.atBot (nhds (limUnder Filter.atBot f))","decl":"/-- If the derivative of a function defined on the real line is integrable close to `-∞`, then\nthe function has a limit at `-∞`. -/\ntheorem tendsto_limUnder_of_hasDerivAt_of_integrableOn_Iic [CompleteSpace E]\n    (hderiv : ∀ x ∈ Iic a, HasDerivAt f (f' x) x) (f'int : IntegrableOn f' (Iic a)) :\n    Tendsto f atBot (𝓝 (limUnder atBot f)) := by\n  suffices ∃ a, Tendsto f atBot (𝓝 a) from tendsto_nhds_limUnder this\n  let g := f ∘ (fun x ↦ -x)\n  have hdg : ∀ x ∈ Ioi (-a), HasDerivAt g (-f' (-x)) x := by\n    intro x hx\n    have : -x ∈ Iic a := by simp only [mem_Iic, mem_Ioi, neg_le] at *; exact hx.le\n    simpa using HasDerivAt.scomp x (hderiv (-x) this) (hasDerivAt_neg' x)\n  have L : Tendsto g atTop (𝓝 (limUnder atTop g)) := by\n    apply tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi hdg\n    exact ((MeasurePreserving.integrableOn_comp_preimage (Measure.measurePreserving_neg _)\n      (Homeomorph.neg ℝ).measurableEmbedding).2 f'int.neg).mono_set (by simp)\n  refine ⟨limUnder atTop g, ?_⟩\n  have : Tendsto (fun x ↦ g (-x)) atBot (𝓝 (limUnder atTop g)) := L.comp tendsto_neg_atBot_atTop\n  simpa [g] using this\n\n"}
{"name":"MeasureTheory.tendsto_zero_of_hasDerivAt_of_integrableOn_Iic","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real → E\na : Real\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nhderiv : ∀ (x : Real), Membership.mem (Set.Iic a) x → HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Iic a) MeasureTheory.MeasureSpace.volume\nfint : MeasureTheory.IntegrableOn f (Set.Iic a) MeasureTheory.MeasureSpace.volume\n⊢ Filter.Tendsto f Filter.atBot (nhds 0)","decl":"open UniformSpace in\n/-- If a function and its derivative are integrable on `(-∞, a]`, then the function tends to zero\nat `-∞`. -/\ntheorem tendsto_zero_of_hasDerivAt_of_integrableOn_Iic\n    (hderiv : ∀ x ∈ Iic a, HasDerivAt f (f' x) x)\n    (f'int : IntegrableOn f' (Iic a)) (fint : IntegrableOn f (Iic a)) :\n    Tendsto f atBot (𝓝 0) := by\n  let F : E →L[ℝ] Completion E := Completion.toComplL\n  have Fderiv : ∀ x ∈ Iic a, HasDerivAt (F ∘ f) (F (f' x)) x :=\n    fun x hx ↦ F.hasFDerivAt.comp_hasDerivAt _ (hderiv x hx)\n  have Fint : IntegrableOn (F ∘ f) (Iic a) := by apply F.integrable_comp fint\n  have F'int : IntegrableOn (F ∘ f') (Iic a) := by apply F.integrable_comp f'int\n  have A : Tendsto (F ∘ f) atBot (𝓝 (limUnder atBot (F ∘ f))) := by\n    apply tendsto_limUnder_of_hasDerivAt_of_integrableOn_Iic Fderiv F'int\n  have B : limUnder atBot (F ∘ f) = F 0 := by\n    have : IntegrableAtFilter (F ∘ f) atBot := by exact ⟨Iic a, Iic_mem_atBot _, Fint⟩\n    apply IntegrableAtFilter.eq_zero_of_tendsto this ?_ A\n    intro s hs\n    rcases mem_atBot_sets.1 hs with ⟨b, hb⟩\n    apply le_antisymm (le_top)\n    rw [← volume_Iic (a := b)]\n    exact measure_mono hb\n  rwa [B, ← IsEmbedding.tendsto_nhds_iff] at A\n  exact (Completion.isUniformEmbedding_coe E).isEmbedding\n\n"}
{"name":"MeasureTheory.integral_Iic_of_hasDerivAt_of_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real → E\na : Real\nm : E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nhcont : ContinuousWithinAt f (Set.Iic a) a\nhderiv : ∀ (x : Real), Membership.mem (Set.Iio a) x → HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Iic a) MeasureTheory.MeasureSpace.volume\nhf : Filter.Tendsto f Filter.atBot (nhds m)\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic a)) fun x => f' x) (HSub.hSub (f a) m)","decl":"/-- **Fundamental theorem of calculus-2**, on semi-infinite intervals `(-∞, a)`.\nWhen a function has a limit `m` at `-∞`, and its derivative is integrable, then the\nintegral of the derivative on `(-∞, a)` is `f a - m`. Version assuming differentiability\non `(-∞, a)` and continuity at `a⁻`.\n\nNote that such a function always has a limit at minus infinity,\nsee `tendsto_limUnder_of_hasDerivAt_of_integrableOn_Iic`. -/\ntheorem integral_Iic_of_hasDerivAt_of_tendsto (hcont : ContinuousWithinAt f (Iic a) a)\n    (hderiv : ∀ x ∈ Iio a, HasDerivAt f (f' x) x) (f'int : IntegrableOn f' (Iic a))\n    (hf : Tendsto f atBot (𝓝 m)) : ∫ x in Iic a, f' x = f a - m := by\n  have hcont : ContinuousOn f (Iic a) := by\n    intro x hx\n    rcases hx.out.eq_or_lt with rfl|hx\n    · exact hcont\n    · exact (hderiv x hx).continuousAt.continuousWithinAt\n  refine tendsto_nhds_unique (intervalIntegral_tendsto_integral_Iic a f'int tendsto_id) ?_\n  apply Tendsto.congr' _ (hf.const_sub _)\n  filter_upwards [Iic_mem_atBot a] with x hx\n  symm\n  apply intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le hx\n    (hcont.mono Icc_subset_Iic_self) fun y hy => hderiv y hy.2\n  rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hx]\n  exact f'int.mono (fun y hy => hy.2) le_rfl\n\n"}
{"name":"MeasureTheory.integral_Iic_of_hasDerivAt_of_tendsto'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real → E\na : Real\nm : E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nhderiv : ∀ (x : Real), Membership.mem (Set.Iic a) x → HasDerivAt f (f' x) x\nf'int : MeasureTheory.IntegrableOn f' (Set.Iic a) MeasureTheory.MeasureSpace.volume\nhf : Filter.Tendsto f Filter.atBot (nhds m)\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic a)) fun x => f' x) (HSub.hSub (f a) m)","decl":"/-- **Fundamental theorem of calculus-2**, on semi-infinite intervals `(-∞, a)`.\nWhen a function has a limit `m` at `-∞`, and its derivative is integrable, then the\nintegral of the derivative on `(-∞, a)` is `f a - m`. Version assuming differentiability\non `(-∞, a]`.\n\nNote that such a function always has a limit at minus infinity,\nsee `tendsto_limUnder_of_hasDerivAt_of_integrableOn_Iic`. -/\ntheorem integral_Iic_of_hasDerivAt_of_tendsto'\n    (hderiv : ∀ x ∈ Iic a, HasDerivAt f (f' x) x) (f'int : IntegrableOn f' (Iic a))\n    (hf : Tendsto f atBot (𝓝 m)) : ∫ x in Iic a, f' x = f a - m := by\n  refine integral_Iic_of_hasDerivAt_of_tendsto ?_ (fun x hx => hderiv x hx.out.le)\n    f'int hf\n  exact (hderiv a right_mem_Iic).continuousAt.continuousWithinAt\n\n"}
{"name":"HasCompactSupport.integral_Iic_deriv_eq","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf : Real → E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nhf : ContDiff Real 1 f\nh2f : HasCompactSupport f\nb : Real\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic b)) fun x => deriv f x) (f b)","decl":"/-- A special case of `integral_Iic_of_hasDerivAt_of_tendsto` where we assume that `f` is C^1 with\ncompact support. -/\ntheorem _root_.HasCompactSupport.integral_Iic_deriv_eq (hf : ContDiff ℝ 1 f)\n    (h2f : HasCompactSupport f) (b : ℝ) : ∫ x in Iic b, deriv f x = f b := by\n  have := fun x (_ : x ∈ Iio b) ↦ hf.differentiable le_rfl x |>.hasDerivAt\n  rw [integral_Iic_of_hasDerivAt_of_tendsto hf.continuous.continuousWithinAt this, sub_zero]\n  · refine hf.continuous_deriv le_rfl |>.integrable_of_hasCompactSupport h2f.deriv |>.integrableOn\n  rw [hasCompactSupport_iff_eventuallyEq, Filter.coclosedCompact_eq_cocompact] at h2f\n  exact h2f.filter_mono _root_.atBot_le_cocompact |>.tendsto\n\n"}
{"name":"HasCompactSupport.enorm_le_lintegral_Ici_deriv","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"F : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : Real → F\nhf : ContDiff Real 1 f\nh'f : HasCompactSupport f\nx : Real\n⊢ LE.le (ENorm.enorm (f x)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic x)) fun y => ENorm.enorm (deriv f y))","decl":"open UniformSpace in\nlemma _root_.HasCompactSupport.enorm_le_lintegral_Ici_deriv\n    {F : Type*} [NormedAddCommGroup F] [NormedSpace ℝ F]\n    {f : ℝ → F} (hf : ContDiff ℝ 1 f) (h'f : HasCompactSupport f) (x : ℝ) :\n    ‖f x‖ₑ ≤ ∫⁻ y in Iic x, ‖deriv f y‖ₑ := by\n  let I : F →L[ℝ] Completion F := Completion.toComplL\n  let f' : ℝ → Completion F := I ∘ f\n  have hf' : ContDiff ℝ 1 f' := hf.continuousLinearMap_comp I\n  have h'f' : HasCompactSupport f' := h'f.comp_left rfl\n  have : ‖f' x‖ₑ ≤ ∫⁻ y in Iic x, ‖deriv f' y‖ₑ := by\n    rw [← HasCompactSupport.integral_Iic_deriv_eq hf' h'f' x]\n    exact enorm_integral_le_lintegral_enorm _\n  convert this with y\n  · simp [f', I, Completion.enorm_coe]\n  · rw [fderiv_comp_deriv _ I.differentiableAt (hf.differentiable le_rfl _)]\n    simp only [ContinuousLinearMap.fderiv]\n    simp [I]\n\n"}
{"name":"HasCompactSupport.ennnorm_le_lintegral_Ici_deriv","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"F : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : Real → F\nhf : ContDiff Real 1 f\nh'f : HasCompactSupport f\nx : Real\n⊢ LE.le (ENorm.enorm (f x)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic x)) fun y => ENorm.enorm (deriv f y))","decl":"@[deprecated (since := \"2025-01-22\")]\nalias _root_.HasCompactSupport.ennnorm_le_lintegral_Ici_deriv :=\n  HasCompactSupport.enorm_le_lintegral_Ici_deriv\n\n"}
{"name":"MeasureTheory.integral_of_hasDerivAt_of_tendsto","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real → E\nm n : E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nhderiv : ∀ (x : Real), HasDerivAt f (f' x) x\nhf' : MeasureTheory.Integrable f' MeasureTheory.MeasureSpace.volume\nhbot : Filter.Tendsto f Filter.atBot (nhds m)\nhtop : Filter.Tendsto f Filter.atTop (nhds n)\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f' x) (HSub.hSub n m)","decl":"/-- **Fundamental theorem of calculus-2**, on the whole real line\nWhen a function has a limit `m` at `-∞` and `n` at `+∞`, and its derivative is integrable, then the\nintegral of the derivative is `n - m`.\n\nNote that such a function always has a limit at `-∞` and `+∞`,\nsee `tendsto_limUnder_of_hasDerivAt_of_integrableOn_Iic` and\n`tendsto_limUnder_of_hasDerivAt_of_integrableOn_Ioi`. -/\ntheorem integral_of_hasDerivAt_of_tendsto [CompleteSpace E]\n    (hderiv : ∀ x, HasDerivAt f (f' x) x) (hf' : Integrable f')\n    (hbot : Tendsto f atBot (𝓝 m)) (htop : Tendsto f atTop (𝓝 n)) : ∫ x, f' x = n - m := by\n  rw [← setIntegral_univ, ← Set.Iic_union_Ioi (a := 0),\n    setIntegral_union (Iic_disjoint_Ioi le_rfl) measurableSet_Ioi hf'.integrableOn hf'.integrableOn,\n    integral_Iic_of_hasDerivAt_of_tendsto' (fun x _ ↦ hderiv x) hf'.integrableOn hbot,\n    integral_Ioi_of_hasDerivAt_of_tendsto' (fun x _ ↦ hderiv x) hf'.integrableOn htop]\n  abel\n\n"}
{"name":"MeasureTheory.integral_eq_zero_of_hasDerivAt_of_integrable","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nf f' : Real → E\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nhderiv : ∀ (x : Real), HasDerivAt f (f' x) x\nhf' : MeasureTheory.Integrable f' MeasureTheory.MeasureSpace.volume\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f' x) 0","decl":"/-- If a function and its derivative are integrable on the real line, then the integral of the\nderivative is zero. -/\ntheorem integral_eq_zero_of_hasDerivAt_of_integrable\n    (hderiv : ∀ x, HasDerivAt f (f' x) x) (hf' : Integrable f') (hf : Integrable f) :\n    ∫ x, f' x = 0 := by\n  by_cases hE : CompleteSpace E; swap\n  · simp [integral, hE]\n  have A : Tendsto f atBot (𝓝 0) :=\n    tendsto_zero_of_hasDerivAt_of_integrableOn_Iic (a := 0) (fun x _hx ↦ hderiv x)\n      hf'.integrableOn hf.integrableOn\n  have B : Tendsto f atTop (𝓝 0) :=\n    tendsto_zero_of_hasDerivAt_of_integrableOn_Ioi (a := 0) (fun x _hx ↦ hderiv x)\n      hf'.integrableOn hf.integrableOn\n  simpa using integral_of_hasDerivAt_of_tendsto hderiv hf' A B\n\n"}
{"name":"MeasureTheory.integral_comp_smul_deriv_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf f' : Real → Real\ng : Real → E\na : Real\nhf : ContinuousOn f (Set.Ici a)\nhft : Filter.Tendsto f Filter.atTop Filter.atTop\nhff' : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivWithinAt f (f' x) (Set.Ioi x) x\nhg_cont : ContinuousOn g (Set.image f (Set.Ioi a))\nhg1 : MeasureTheory.IntegrableOn g (Set.image f (Set.Ici a)) MeasureTheory.MeasureSpace.volume\nhg2 : MeasureTheory.IntegrableOn (fun x => HSMul.hSMul (f' x) (Function.comp g f x)) (Set.Ici a) MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => HSMul.hSMul (f' x) (Function.comp g f x)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi (f a))) fun u => g u)","decl":"/-- Change-of-variables formula for `Ioi` integrals of vector-valued functions, proved by taking\nlimits from the result for finite intervals. -/\ntheorem integral_comp_smul_deriv_Ioi {f f' : ℝ → ℝ} {g : ℝ → E} {a : ℝ}\n    (hf : ContinuousOn f <| Ici a) (hft : Tendsto f atTop atTop)\n    (hff' : ∀ x ∈ Ioi a, HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hg_cont : ContinuousOn g <| f '' Ioi a) (hg1 : IntegrableOn g <| f '' Ici a)\n    (hg2 : IntegrableOn (fun x => f' x • (g ∘ f) x) (Ici a)) :\n    (∫ x in Ioi a, f' x • (g ∘ f) x) = ∫ u in Ioi (f a), g u := by\n  have eq : ∀ b : ℝ, a < b → (∫ x in a..b, f' x • (g ∘ f) x) = ∫ u in f a..f b, g u := fun b hb ↦ by\n    have i1 : Ioo (min a b) (max a b) ⊆ Ioi a := by\n      rw [min_eq_left hb.le]\n      exact Ioo_subset_Ioi_self\n    have i2 : [[a, b]] ⊆ Ici a := by rw [uIcc_of_le hb.le]; exact Icc_subset_Ici_self\n    refine\n      intervalIntegral.integral_comp_smul_deriv''' (hf.mono i2)\n        (fun x hx => hff' x <| mem_of_mem_of_subset hx i1) (hg_cont.mono <| image_subset _ ?_)\n        (hg1.mono_set <| image_subset _ ?_) (hg2.mono_set i2)\n    · rw [min_eq_left hb.le]; exact Ioo_subset_Ioi_self\n    · rw [uIcc_of_le hb.le]; exact Icc_subset_Ici_self\n  rw [integrableOn_Ici_iff_integrableOn_Ioi] at hg2\n  have t2 := intervalIntegral_tendsto_integral_Ioi _ hg2 tendsto_id\n  have : Ioi (f a) ⊆ f '' Ici a :=\n    Ioi_subset_Ici_self.trans <|\n      IsPreconnected.intermediate_value_Ici isPreconnected_Ici left_mem_Ici\n        (le_principal_iff.mpr <| Ici_mem_atTop _) hf hft\n  have t1 := (intervalIntegral_tendsto_integral_Ioi _ (hg1.mono_set this) tendsto_id).comp hft\n  exact tendsto_nhds_unique (Tendsto.congr' (eventuallyEq_of_mem (Ioi_mem_atTop a) eq) t2) t1\n\n"}
{"name":"MeasureTheory.integral_comp_mul_deriv_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"f f' g : Real → Real\na : Real\nhf : ContinuousOn f (Set.Ici a)\nhft : Filter.Tendsto f Filter.atTop Filter.atTop\nhff' : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivWithinAt f (f' x) (Set.Ioi x) x\nhg_cont : ContinuousOn g (Set.image f (Set.Ioi a))\nhg1 : MeasureTheory.IntegrableOn g (Set.image f (Set.Ici a)) MeasureTheory.MeasureSpace.volume\nhg2 : MeasureTheory.IntegrableOn (fun x => HMul.hMul (Function.comp g f x) (f' x)) (Set.Ici a) MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => HMul.hMul (Function.comp g f x) (f' x)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi (f a))) fun u => g u)","decl":"/-- Change-of-variables formula for `Ioi` integrals of scalar-valued functions -/\ntheorem integral_comp_mul_deriv_Ioi {f f' : ℝ → ℝ} {g : ℝ → ℝ} {a : ℝ}\n    (hf : ContinuousOn f <| Ici a) (hft : Tendsto f atTop atTop)\n    (hff' : ∀ x ∈ Ioi a, HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hg_cont : ContinuousOn g <| f '' Ioi a) (hg1 : IntegrableOn g <| f '' Ici a)\n    (hg2 : IntegrableOn (fun x => (g ∘ f) x * f' x) (Ici a)) :\n    (∫ x in Ioi a, (g ∘ f) x * f' x) = ∫ u in Ioi (f a), g u := by\n  have hg2' : IntegrableOn (fun x => f' x • (g ∘ f) x) (Ici a) := by simpa [mul_comm] using hg2\n  simpa [mul_comm] using integral_comp_smul_deriv_Ioi hf hft hff' hg_cont hg1 hg2'\n\n"}
{"name":"MeasureTheory.integral_comp_rpow_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ng : Real → E\np : Real\nhp : Ne p 0\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun x => HSMul.hSMul (HMul.hMul (abs p) (HPow.hPow x (HSub.hSub p 1))) (g (HPow.hPow x p))) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun y => g y)","decl":"/-- Substitution `y = x ^ p` in integrals over `Ioi 0` -/\ntheorem integral_comp_rpow_Ioi (g : ℝ → E) {p : ℝ} (hp : p ≠ 0) :\n    (∫ x in Ioi 0, (|p| * x ^ (p - 1)) • g (x ^ p)) = ∫ y in Ioi 0, g y := by\n  let S := Ioi (0 : ℝ)\n  have a1 : ∀ x : ℝ, x ∈ S → HasDerivWithinAt (fun t : ℝ => t ^ p) (p * x ^ (p - 1)) S x :=\n    fun x hx => (hasDerivAt_rpow_const (Or.inl (mem_Ioi.mp hx).ne')).hasDerivWithinAt\n  have a2 : InjOn (fun x : ℝ => x ^ p) S := by\n    rcases lt_or_gt_of_ne hp with (h | h)\n    · apply StrictAntiOn.injOn\n      intro x hx y hy hxy\n      rw [← inv_lt_inv₀ (rpow_pos_of_pos hx p) (rpow_pos_of_pos hy p), ← rpow_neg (le_of_lt hx),\n        ← rpow_neg (le_of_lt hy)]\n      exact rpow_lt_rpow (le_of_lt hx) hxy (neg_pos.mpr h)\n    exact StrictMonoOn.injOn fun x hx y _ hxy => rpow_lt_rpow (mem_Ioi.mp hx).le hxy h\n  have a3 : (fun t : ℝ => t ^ p) '' S = S := by\n    ext1 x; rw [mem_image]; constructor\n    · rintro ⟨y, hy, rfl⟩; exact rpow_pos_of_pos hy p\n    · intro hx; refine ⟨x ^ (1 / p), rpow_pos_of_pos hx _, ?_⟩\n      rw [← rpow_mul (le_of_lt hx), one_div_mul_cancel hp, rpow_one]\n  have := integral_image_eq_integral_abs_deriv_smul measurableSet_Ioi a1 a2 g\n  rw [a3] at this; rw [this]\n  refine setIntegral_congr_fun measurableSet_Ioi ?_\n  intro x hx; dsimp only\n  rw [abs_mul, abs_of_nonneg (rpow_nonneg (le_of_lt hx) _)]\n\n"}
{"name":"MeasureTheory.integral_comp_rpow_Ioi_of_pos","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ng : Real → E\np : Real\nhp : LT.lt 0 p\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun x => HSMul.hSMul (HMul.hMul p (HPow.hPow x (HSub.hSub p 1))) (g (HPow.hPow x p))) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun y => g y)","decl":"theorem integral_comp_rpow_Ioi_of_pos {g : ℝ → E} {p : ℝ} (hp : 0 < p) :\n    (∫ x in Ioi 0, (p * x ^ (p - 1)) • g (x ^ p)) = ∫ y in Ioi 0, g y := by\n  convert integral_comp_rpow_Ioi g hp.ne'\n  rw [abs_of_nonneg hp.le]\n\n"}
{"name":"MeasureTheory.integral_comp_mul_left_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ng : Real → E\na b : Real\nhb : LT.lt 0 b\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => g (HMul.hMul b x)) (HSMul.hSMul (Inv.inv b) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi (HMul.hMul b a))) fun x => g x))","decl":"theorem integral_comp_mul_left_Ioi (g : ℝ → E) (a : ℝ) {b : ℝ} (hb : 0 < b) :\n    (∫ x in Ioi a, g (b * x)) = b⁻¹ • ∫ x in Ioi (b * a), g x := by\n  have : ∀ c : ℝ, MeasurableSet (Ioi c) := fun c => measurableSet_Ioi\n  rw [← integral_indicator (this a), ← integral_indicator (this (b * a)),\n    ← abs_of_pos (inv_pos.mpr hb), ← Measure.integral_comp_mul_left]\n  congr\n  ext1 x\n  rw [← indicator_comp_right, preimage_const_mul_Ioi _ hb, mul_div_cancel_left₀ _ hb.ne']\n  rfl\n\n"}
{"name":"MeasureTheory.integral_comp_mul_right_Ioi","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ng : Real → E\na b : Real\nhb : LT.lt 0 b\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => g (HMul.hMul x b)) (HSMul.hSMul (Inv.inv b) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi (HMul.hMul a b))) fun x => g x))","decl":"theorem integral_comp_mul_right_Ioi (g : ℝ → E) (a : ℝ) {b : ℝ} (hb : 0 < b) :\n    (∫ x in Ioi a, g (x * b)) = b⁻¹ • ∫ x in Ioi (a * b), g x := by\n  simpa only [mul_comm] using integral_comp_mul_left_Ioi g a hb\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_comp_rpow_iff","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\np : Real\nhp : Ne p 0\n⊢ Iff (MeasureTheory.IntegrableOn (fun x => HSMul.hSMul (HMul.hMul (abs p) (HPow.hPow x (HSub.hSub p 1))) (f (HPow.hPow x p))) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume) (MeasureTheory.IntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume)","decl":"/-- The substitution `y = x ^ p` in integrals over `Ioi 0` preserves integrability. -/\ntheorem integrableOn_Ioi_comp_rpow_iff [NormedSpace ℝ E] (f : ℝ → E) {p : ℝ} (hp : p ≠ 0) :\n    IntegrableOn (fun x => (|p| * x ^ (p - 1)) • f (x ^ p)) (Ioi 0) ↔ IntegrableOn f (Ioi 0) := by\n  let S := Ioi (0 : ℝ)\n  have a1 : ∀ x : ℝ, x ∈ S → HasDerivWithinAt (fun t : ℝ => t ^ p) (p * x ^ (p - 1)) S x :=\n    fun x hx => (hasDerivAt_rpow_const (Or.inl (mem_Ioi.mp hx).ne')).hasDerivWithinAt\n  have a2 : InjOn (fun x : ℝ => x ^ p) S := by\n    rcases lt_or_gt_of_ne hp with (h | h)\n    · apply StrictAntiOn.injOn\n      intro x hx y hy hxy\n      rw [← inv_lt_inv₀ (rpow_pos_of_pos hx p) (rpow_pos_of_pos hy p), ← rpow_neg (le_of_lt hx), ←\n        rpow_neg (le_of_lt hy)]\n      exact rpow_lt_rpow (le_of_lt hx) hxy (neg_pos.mpr h)\n    exact StrictMonoOn.injOn fun x hx y _hy hxy => rpow_lt_rpow (mem_Ioi.mp hx).le hxy h\n  have a3 : (fun t : ℝ => t ^ p) '' S = S := by\n    ext1 x; rw [mem_image]; constructor\n    · rintro ⟨y, hy, rfl⟩; exact rpow_pos_of_pos hy p\n    · intro hx; refine ⟨x ^ (1 / p), rpow_pos_of_pos hx _, ?_⟩\n      rw [← rpow_mul (le_of_lt hx), one_div_mul_cancel hp, rpow_one]\n  have := integrableOn_image_iff_integrableOn_abs_deriv_smul measurableSet_Ioi a1 a2 f\n  rw [a3] at this\n  rw [this]\n  refine integrableOn_congr_fun (fun x hx => ?_) measurableSet_Ioi\n  simp_rw [abs_mul, abs_of_nonneg (rpow_nonneg (le_of_lt hx) _)]\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_comp_rpow_iff'","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : Real → E\np : Real\nhp : Ne p 0\n⊢ Iff (MeasureTheory.IntegrableOn (fun x => HSMul.hSMul (HPow.hPow x (HSub.hSub p 1)) (f (HPow.hPow x p))) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume) (MeasureTheory.IntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume)","decl":"/-- The substitution `y = x ^ p` in integrals over `Ioi 0` preserves integrability (version\nwithout `|p|` factor) -/\ntheorem integrableOn_Ioi_comp_rpow_iff' [NormedSpace ℝ E] (f : ℝ → E) {p : ℝ} (hp : p ≠ 0) :\n    IntegrableOn (fun x => x ^ (p - 1) • f (x ^ p)) (Ioi 0) ↔ IntegrableOn f (Ioi 0) := by\n  simpa only [← integrableOn_Ioi_comp_rpow_iff f hp, mul_smul] using\n    (integrable_smul_iff (abs_pos.mpr hp).ne' _).symm\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_comp_mul_left_iff","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Real → E\nc a : Real\nha : LT.lt 0 a\n⊢ Iff (MeasureTheory.IntegrableOn (fun x => f (HMul.hMul a x)) (Set.Ioi c) MeasureTheory.MeasureSpace.volume) (MeasureTheory.IntegrableOn f (Set.Ioi (HMul.hMul a c)) MeasureTheory.MeasureSpace.volume)","decl":"theorem integrableOn_Ioi_comp_mul_left_iff (f : ℝ → E) (c : ℝ) {a : ℝ} (ha : 0 < a) :\n    IntegrableOn (fun x => f (a * x)) (Ioi c) ↔ IntegrableOn f (Ioi <| a * c) := by\n  rw [← integrable_indicator_iff (measurableSet_Ioi : MeasurableSet <| Ioi c)]\n  rw [← integrable_indicator_iff (measurableSet_Ioi : MeasurableSet <| Ioi <| a * c)]\n  convert integrable_comp_mul_left_iff ((Ioi (a * c)).indicator f) ha.ne' using 2\n  ext1 x\n  rw [← indicator_comp_right, preimage_const_mul_Ioi _ ha, mul_comm a c,\n    mul_div_cancel_right₀ _ ha.ne']\n  rfl\n\n"}
{"name":"MeasureTheory.integrableOn_Ioi_comp_mul_right_iff","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Real → E\nc a : Real\nha : LT.lt 0 a\n⊢ Iff (MeasureTheory.IntegrableOn (fun x => f (HMul.hMul x a)) (Set.Ioi c) MeasureTheory.MeasureSpace.volume) (MeasureTheory.IntegrableOn f (Set.Ioi (HMul.hMul c a)) MeasureTheory.MeasureSpace.volume)","decl":"theorem integrableOn_Ioi_comp_mul_right_iff (f : ℝ → E) (c : ℝ) {a : ℝ} (ha : 0 < a) :\n    IntegrableOn (fun x => f (x * a)) (Ioi c) ↔ IntegrableOn f (Ioi <| c * a) := by\n  simpa only [mul_comm, mul_zero] using integrableOn_Ioi_comp_mul_left_iff f c ha\n\n"}
{"name":"MeasureTheory.integral_bilinear_hasDerivAt_eq_sub","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace Real F\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace Real G\nL : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) F G)\nu : Real → E\nv : Real → F\nu' : Real → E\nv' : Real → F\nm n : G\ninst✝ : CompleteSpace G\nhu : ∀ (x : Real), HasDerivAt u (u' x) x\nhv : ∀ (x : Real), HasDerivAt v (v' x) x\nhuv : MeasureTheory.Integrable (fun x => HAdd.hAdd ((L (u x)) (v' x)) ((L (u' x)) (v x))) MeasureTheory.MeasureSpace.volume\nh_bot : Filter.Tendsto (fun x => (L (u x)) (v x)) Filter.atBot (nhds m)\nh_top : Filter.Tendsto (fun x => (L (u x)) (v x)) Filter.atTop (nhds n)\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HAdd.hAdd ((L (u x)) (v' x)) ((L (u' x)) (v x))) (HSub.hSub n m)","decl":"theorem integral_bilinear_hasDerivAt_eq_sub [CompleteSpace G]\n    (hu : ∀ x, HasDerivAt u (u' x) x) (hv : ∀ x, HasDerivAt v (v' x) x)\n    (huv : Integrable (fun x ↦ L (u x) (v' x) + L (u' x) (v x)))\n    (h_bot : Tendsto (fun x ↦ L (u x) (v x)) atBot (𝓝 m))\n    (h_top : Tendsto (fun x ↦ L (u x) (v x)) atTop (𝓝 n)) :\n    ∫ (x : ℝ), L (u x) (v' x) + L (u' x) (v x) = n - m :=\n  integral_of_hasDerivAt_of_tendsto (fun x ↦ L.hasDerivAt_of_bilinear (hu x) (hv x))\n    huv h_bot h_top\n\n"}
{"name":"MeasureTheory.integral_bilinear_hasDerivAt_right_eq_sub","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace Real F\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace Real G\nL : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) F G)\nu : Real → E\nv : Real → F\nu' : Real → E\nv' : Real → F\nm n : G\ninst✝ : CompleteSpace G\nhu : ∀ (x : Real), HasDerivAt u (u' x) x\nhv : ∀ (x : Real), HasDerivAt v (v' x) x\nhuv' : MeasureTheory.Integrable (fun x => (L (u x)) (v' x)) MeasureTheory.MeasureSpace.volume\nhu'v : MeasureTheory.Integrable (fun x => (L (u' x)) (v x)) MeasureTheory.MeasureSpace.volume\nh_bot : Filter.Tendsto (fun x => (L (u x)) (v x)) Filter.atBot (nhds m)\nh_top : Filter.Tendsto (fun x => (L (u x)) (v x)) Filter.atTop (nhds n)\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => (L (u x)) (v' x)) (HSub.hSub (HSub.hSub n m) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => (L (u' x)) (v x)))","decl":"/-- **Integration by parts on (-∞, ∞).**\nWith respect to a general bilinear form. For the specific case of multiplication, see\n`integral_mul_deriv_eq_deriv_mul`. -/\ntheorem integral_bilinear_hasDerivAt_right_eq_sub [CompleteSpace G]\n    (hu : ∀ x, HasDerivAt u (u' x) x) (hv : ∀ x, HasDerivAt v (v' x) x)\n    (huv' : Integrable (fun x ↦ L (u x) (v' x))) (hu'v : Integrable (fun x ↦ L (u' x) (v x)))\n    (h_bot : Tendsto (fun x ↦ L (u x) (v x)) atBot (𝓝 m))\n    (h_top : Tendsto (fun x ↦ L (u x) (v x)) atTop (𝓝 n)) :\n    ∫ (x : ℝ), L (u x) (v' x) = n - m - ∫ (x : ℝ), L (u' x) (v x) := by\n  rw [eq_sub_iff_add_eq, ← integral_add huv' hu'v]\n  exact integral_bilinear_hasDerivAt_eq_sub hu hv (huv'.add hu'v) h_bot h_top\n\n"}
{"name":"MeasureTheory.integral_bilinear_hasDerivAt_right_eq_neg_left_of_integrable","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"E : Type u_1\nF : Type u_2\nG : Type u_3\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace Real G\nL : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) F G)\nu : Real → E\nv : Real → F\nu' : Real → E\nv' : Real → F\nhu : ∀ (x : Real), HasDerivAt u (u' x) x\nhv : ∀ (x : Real), HasDerivAt v (v' x) x\nhuv' : MeasureTheory.Integrable (fun x => (L (u x)) (v' x)) MeasureTheory.MeasureSpace.volume\nhu'v : MeasureTheory.Integrable (fun x => (L (u' x)) (v x)) MeasureTheory.MeasureSpace.volume\nhuv : MeasureTheory.Integrable (fun x => (L (u x)) (v x)) MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => (L (u x)) (v' x)) (Neg.neg (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => (L (u' x)) (v x)))","decl":"/-- **Integration by parts on (-∞, ∞).**\nWith respect to a general bilinear form, assuming moreover that the total function is integrable.\n-/\ntheorem integral_bilinear_hasDerivAt_right_eq_neg_left_of_integrable\n    (hu : ∀ x, HasDerivAt u (u' x) x) (hv : ∀ x, HasDerivAt v (v' x) x)\n    (huv' : Integrable (fun x ↦ L (u x) (v' x))) (hu'v : Integrable (fun x ↦ L (u' x) (v x)))\n    (huv : Integrable (fun x ↦ L (u x) (v x))) :\n    ∫ (x : ℝ), L (u x) (v' x) = - ∫ (x : ℝ), L (u' x) (v x) := by\n  by_cases hG : CompleteSpace G; swap\n  · simp [integral, hG]\n  have I : Tendsto (fun x ↦ L (u x) (v x)) atBot (𝓝 0) :=\n    tendsto_zero_of_hasDerivAt_of_integrableOn_Iic (a := 0)\n      (fun x _hx ↦ L.hasDerivAt_of_bilinear (hu x) (hv x))\n      (huv'.add hu'v).integrableOn huv.integrableOn\n  have J : Tendsto (fun x ↦ L (u x) (v x)) atTop (𝓝 0) :=\n    tendsto_zero_of_hasDerivAt_of_integrableOn_Ioi (a := 0)\n      (fun x _hx ↦ L.hasDerivAt_of_bilinear (hu x) (hv x))\n      (huv'.add hu'v).integrableOn huv.integrableOn\n  simp [integral_bilinear_hasDerivAt_right_eq_sub hu hv huv' hu'v I J]\n\n"}
{"name":"MeasureTheory.integral_deriv_mul_eq_sub","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Real A\na' b' : A\nu v u' v' : Real → A\ninst✝ : CompleteSpace A\nhu : ∀ (x : Real), HasDerivAt u (u' x) x\nhv : ∀ (x : Real), HasDerivAt v (v' x) x\nhuv : MeasureTheory.Integrable (HAdd.hAdd (HMul.hMul u' v) (HMul.hMul u v')) MeasureTheory.MeasureSpace.volume\nh_bot : Filter.Tendsto (HMul.hMul u v) Filter.atBot (nhds a')\nh_top : Filter.Tendsto (HMul.hMul u v) Filter.atTop (nhds b')\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HAdd.hAdd (HMul.hMul (u' x) (v x)) (HMul.hMul (u x) (v' x))) (HSub.hSub b' a')","decl":"/-- For finite intervals, see: `intervalIntegral.integral_deriv_mul_eq_sub`. -/\ntheorem integral_deriv_mul_eq_sub [CompleteSpace A]\n    (hu : ∀ x, HasDerivAt u (u' x) x) (hv : ∀ x, HasDerivAt v (v' x) x)\n    (huv : Integrable (u' * v + u * v'))\n    (h_bot : Tendsto (u * v) atBot (𝓝 a')) (h_top : Tendsto (u * v) atTop (𝓝 b')) :\n    ∫ (x : ℝ), u' x * v x + u x * v' x = b' - a' :=\n  integral_of_hasDerivAt_of_tendsto (fun x ↦ (hu x).mul (hv x)) huv h_bot h_top\n\n"}
{"name":"MeasureTheory.integral_mul_deriv_eq_deriv_mul","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Real A\na' b' : A\nu v u' v' : Real → A\ninst✝ : CompleteSpace A\nhu : ∀ (x : Real), HasDerivAt u (u' x) x\nhv : ∀ (x : Real), HasDerivAt v (v' x) x\nhuv' : MeasureTheory.Integrable (HMul.hMul u v') MeasureTheory.MeasureSpace.volume\nhu'v : MeasureTheory.Integrable (HMul.hMul u' v) MeasureTheory.MeasureSpace.volume\nh_bot : Filter.Tendsto (HMul.hMul u v) Filter.atBot (nhds a')\nh_top : Filter.Tendsto (HMul.hMul u v) Filter.atTop (nhds b')\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HMul.hMul (u x) (v' x)) (HSub.hSub (HSub.hSub b' a') (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HMul.hMul (u' x) (v x)))","decl":"/-- **Integration by parts on (-∞, ∞).**\nFor finite intervals, see: `intervalIntegral.integral_mul_deriv_eq_deriv_mul`. -/\ntheorem integral_mul_deriv_eq_deriv_mul [CompleteSpace A]\n    (hu : ∀ x, HasDerivAt u (u' x) x) (hv : ∀ x, HasDerivAt v (v' x) x)\n    (huv' : Integrable (u * v')) (hu'v : Integrable (u' * v))\n    (h_bot : Tendsto (u * v) atBot (𝓝 a')) (h_top : Tendsto (u * v) atTop (𝓝 b')) :\n    ∫ (x : ℝ), u x * v' x = b' - a' - ∫ (x : ℝ), u' x * v x :=\n  integral_bilinear_hasDerivAt_right_eq_sub (L := ContinuousLinearMap.mul ℝ A)\n    hu hv huv' hu'v h_bot h_top\n\n"}
{"name":"MeasureTheory.integral_mul_deriv_eq_deriv_mul_of_integrable","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra Real A\nu v u' v' : Real → A\nhu : ∀ (x : Real), HasDerivAt u (u' x) x\nhv : ∀ (x : Real), HasDerivAt v (v' x) x\nhuv' : MeasureTheory.Integrable (HMul.hMul u v') MeasureTheory.MeasureSpace.volume\nhu'v : MeasureTheory.Integrable (HMul.hMul u' v) MeasureTheory.MeasureSpace.volume\nhuv : MeasureTheory.Integrable (HMul.hMul u v) MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HMul.hMul (u x) (v' x)) (Neg.neg (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => HMul.hMul (u' x) (v x)))","decl":"/-- **Integration by parts on (-∞, ∞).**\nVersion assuming that the total function is integrable -/\ntheorem integral_mul_deriv_eq_deriv_mul_of_integrable\n    (hu : ∀ x, HasDerivAt u (u' x) x) (hv : ∀ x, HasDerivAt v (v' x) x)\n    (huv' : Integrable (u * v')) (hu'v : Integrable (u' * v)) (huv : Integrable (u * v)) :\n    ∫ (x : ℝ), u x * v' x = - ∫ (x : ℝ), u' x * v x :=\n  integral_bilinear_hasDerivAt_right_eq_neg_left_of_integrable (L := ContinuousLinearMap.mul ℝ A)\n    hu hv huv' hu'v huv\n\n"}
{"name":"MeasureTheory.integral_Ioi_deriv_mul_eq_sub","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Real A\na : Real\na' b' : A\nu v u' v' : Real → A\ninst✝ : CompleteSpace A\nhu : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivAt u (u' x) x\nhv : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivAt v (v' x) x\nhuv : MeasureTheory.IntegrableOn (HAdd.hAdd (HMul.hMul u' v) (HMul.hMul u v')) (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nh_zero : Filter.Tendsto (HMul.hMul u v) (nhdsWithin a (Set.Ioi a)) (nhds a')\nh_infty : Filter.Tendsto (HMul.hMul u v) Filter.atTop (nhds b')\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => HAdd.hAdd (HMul.hMul (u' x) (v x)) (HMul.hMul (u x) (v' x))) (HSub.hSub b' a')","decl":"/-- For finite intervals, see: `intervalIntegral.integral_deriv_mul_eq_sub`. -/\ntheorem integral_Ioi_deriv_mul_eq_sub\n    (hu : ∀ x ∈ Ioi a, HasDerivAt u (u' x) x) (hv : ∀ x ∈ Ioi a, HasDerivAt v (v' x) x)\n    (huv : IntegrableOn (u' * v + u * v') (Ioi a))\n    (h_zero : Tendsto (u * v) (𝓝[>] a) (𝓝 a')) (h_infty : Tendsto (u * v) atTop (𝓝 b')) :\n    ∫ (x : ℝ) in Ioi a, u' x * v x + u x * v' x = b' - a' := by\n  rw [← Ici_diff_left] at h_zero\n  let f := Function.update (u * v) a a'\n  have hderiv : ∀ x ∈ Ioi a, HasDerivAt f (u' x * v x + u x * v' x) x := by\n    intro x (hx : a < x)\n    apply ((hu x hx).mul (hv x hx)).congr_of_eventuallyEq\n    filter_upwards [eventually_ne_nhds hx.ne.symm] with y hy\n    exact Function.update_of_ne hy a' (u * v)\n  have htendsto : Tendsto f atTop (𝓝 b') := by\n    apply h_infty.congr'\n    filter_upwards [eventually_ne_atTop a] with x hx\n    exact (Function.update_of_ne hx a' (u * v)).symm\n  simpa using integral_Ioi_of_hasDerivAt_of_tendsto\n    (continuousWithinAt_update_same.mpr h_zero) hderiv huv htendsto\n\n"}
{"name":"MeasureTheory.integral_Ioi_mul_deriv_eq_deriv_mul","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Real A\na : Real\na' b' : A\nu v u' v' : Real → A\ninst✝ : CompleteSpace A\nhu : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivAt u (u' x) x\nhv : ∀ (x : Real), Membership.mem (Set.Ioi a) x → HasDerivAt v (v' x) x\nhuv' : MeasureTheory.IntegrableOn (HMul.hMul u v') (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nhu'v : MeasureTheory.IntegrableOn (HMul.hMul u' v) (Set.Ioi a) MeasureTheory.MeasureSpace.volume\nh_zero : Filter.Tendsto (HMul.hMul u v) (nhdsWithin a (Set.Ioi a)) (nhds a')\nh_infty : Filter.Tendsto (HMul.hMul u v) Filter.atTop (nhds b')\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => HMul.hMul (u x) (v' x)) (HSub.hSub (HSub.hSub b' a') (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi a)) fun x => HMul.hMul (u' x) (v x)))","decl":"/-- **Integration by parts on (a, ∞).**\nFor finite intervals, see: `intervalIntegral.integral_mul_deriv_eq_deriv_mul`. -/\ntheorem integral_Ioi_mul_deriv_eq_deriv_mul\n    (hu : ∀ x ∈ Ioi a, HasDerivAt u (u' x) x) (hv : ∀ x ∈ Ioi a, HasDerivAt v (v' x) x)\n    (huv' : IntegrableOn (u * v') (Ioi a)) (hu'v : IntegrableOn (u' * v) (Ioi a))\n    (h_zero : Tendsto (u * v) (𝓝[>] a) (𝓝 a')) (h_infty : Tendsto (u * v) atTop (𝓝 b')) :\n    ∫ (x : ℝ) in Ioi a, u x * v' x = b' - a' - ∫ (x : ℝ) in Ioi a, u' x * v x := by\n  rw [Pi.mul_def] at huv' hu'v\n  rw [eq_sub_iff_add_eq, ← integral_add huv' hu'v]\n  simpa only [add_comm] using integral_Ioi_deriv_mul_eq_sub hu hv (hu'v.add huv') h_zero h_infty\n\n"}
{"name":"MeasureTheory.integral_Iic_deriv_mul_eq_sub","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Real A\na : Real\na' b' : A\nu v u' v' : Real → A\ninst✝ : CompleteSpace A\nhu : ∀ (x : Real), Membership.mem (Set.Iio a) x → HasDerivAt u (u' x) x\nhv : ∀ (x : Real), Membership.mem (Set.Iio a) x → HasDerivAt v (v' x) x\nhuv : MeasureTheory.IntegrableOn (HAdd.hAdd (HMul.hMul u' v) (HMul.hMul u v')) (Set.Iic a) MeasureTheory.MeasureSpace.volume\nh_zero : Filter.Tendsto (HMul.hMul u v) (nhdsWithin a (Set.Iio a)) (nhds a')\nh_infty : Filter.Tendsto (HMul.hMul u v) Filter.atBot (nhds b')\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic a)) fun x => HAdd.hAdd (HMul.hMul (u' x) (v x)) (HMul.hMul (u x) (v' x))) (HSub.hSub a' b')","decl":"/-- For finite intervals, see: `intervalIntegral.integral_deriv_mul_eq_sub`. -/\ntheorem integral_Iic_deriv_mul_eq_sub\n    (hu : ∀ x ∈ Iio a, HasDerivAt u (u' x) x) (hv : ∀ x ∈ Iio a, HasDerivAt v (v' x) x)\n    (huv : IntegrableOn (u' * v + u * v') (Iic a))\n    (h_zero : Tendsto (u * v) (𝓝[<] a) (𝓝 a')) (h_infty : Tendsto (u * v) atBot (𝓝 b')) :\n    ∫ (x : ℝ) in Iic a, u' x * v x + u x * v' x = a' - b' := by\n  rw [← Iic_diff_right] at h_zero\n  let f := Function.update (u * v) a a'\n  have hderiv : ∀ x ∈ Iio a, HasDerivAt f (u' x * v x + u x * v' x) x := by\n    intro x hx\n    apply ((hu x hx).mul (hv x hx)).congr_of_eventuallyEq\n    filter_upwards [Iio_mem_nhds hx] with x (hx : x < a)\n    exact Function.update_of_ne (ne_of_lt hx) a' (u * v)\n  have htendsto : Tendsto f atBot (𝓝 b') := by\n    apply h_infty.congr'\n    filter_upwards [Iio_mem_atBot a] with x (hx : x < a)\n    exact (Function.update_of_ne (ne_of_lt hx) a' (u * v)).symm\n  simpa using integral_Iic_of_hasDerivAt_of_tendsto\n    (continuousWithinAt_update_same.mpr h_zero) hderiv huv htendsto\n\n"}
{"name":"MeasureTheory.integral_Iic_mul_deriv_eq_deriv_mul","module":"Mathlib.MeasureTheory.Integral.IntegralEqImproper","initialProofState":"A : Type u_1\ninst✝² : NormedRing A\ninst✝¹ : NormedAlgebra Real A\na : Real\na' b' : A\nu v u' v' : Real → A\ninst✝ : CompleteSpace A\nhu : ∀ (x : Real), Membership.mem (Set.Iio a) x → HasDerivAt u (u' x) x\nhv : ∀ (x : Real), Membership.mem (Set.Iio a) x → HasDerivAt v (v' x) x\nhuv' : MeasureTheory.IntegrableOn (HMul.hMul u v') (Set.Iic a) MeasureTheory.MeasureSpace.volume\nhu'v : MeasureTheory.IntegrableOn (HMul.hMul u' v) (Set.Iic a) MeasureTheory.MeasureSpace.volume\nh_zero : Filter.Tendsto (HMul.hMul u v) (nhdsWithin a (Set.Iio a)) (nhds a')\nh_infty : Filter.Tendsto (HMul.hMul u v) Filter.atBot (nhds b')\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic a)) fun x => HMul.hMul (u x) (v' x)) (HSub.hSub (HSub.hSub a' b') (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic a)) fun x => HMul.hMul (u' x) (v x)))","decl":"/-- **Integration by parts on (∞, a].**\nFor finite intervals, see: `intervalIntegral.integral_mul_deriv_eq_deriv_mul`. -/\ntheorem integral_Iic_mul_deriv_eq_deriv_mul\n    (hu : ∀ x ∈ Iio a, HasDerivAt u (u' x) x) (hv : ∀ x ∈ Iio a, HasDerivAt v (v' x) x)\n    (huv' : IntegrableOn (u * v') (Iic a)) (hu'v : IntegrableOn (u' * v) (Iic a))\n    (h_zero : Tendsto (u * v) (𝓝[<] a) (𝓝 a')) (h_infty : Tendsto (u * v) atBot (𝓝 b')) :\n    ∫ (x : ℝ) in Iic a, u x * v' x = a' - b' - ∫ (x : ℝ) in Iic a, u' x * v x := by\n  rw [Pi.mul_def] at huv' hu'v\n  rw [eq_sub_iff_add_eq, ← integral_add huv' hu'v]\n  simpa only [add_comm] using integral_Iic_deriv_mul_eq_sub hu hv (hu'v.add huv') h_zero h_infty\n\n"}
