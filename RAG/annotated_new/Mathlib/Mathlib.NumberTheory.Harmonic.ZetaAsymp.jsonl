{"name":"ZetaAsymptotics.term_nonneg","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"n : Nat\ns : Real\n‚ä¢ LE.le 0 (ZetaAsymptotics.term n s)","decl":"lemma term_nonneg (n : ‚Ñï) (s : ‚Ñù) : 0 ‚â§ term n s := by\n  rw [term, intervalIntegral.integral_of_le (by simp)]\n  refine setIntegral_nonneg measurableSet_Ioc (fun x hx ‚Ü¶ ?_)\n  refine div_nonneg ?_ (rpow_nonneg ?_ _)\n  all_goals linarith [hx.1]\n\n"}
{"name":"ZetaAsymptotics.term_welldef","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"n : Nat\nhn : LT.lt 0 n\ns : Real\nhs : LT.lt 0 s\n‚ä¢ IntervalIntegrable (fun x => HDiv.hDiv (HSub.hSub x ‚Üën) (HPow.hPow x (HAdd.hAdd s 1))) MeasureTheory.MeasureSpace.volume (‚Üën) (HAdd.hAdd (‚Üën) 1)","decl":"lemma term_welldef {n : ‚Ñï} (hn : 0 < n) {s : ‚Ñù} (hs : 0 < s) :\n    IntervalIntegrable (fun x : ‚Ñù ‚Ü¶ (x - n) / x ^ (s + 1)) volume n (n + 1) := by\n  rw [intervalIntegrable_iff_integrableOn_Icc_of_le (by linarith)]\n  refine (continuousOn_of_forall_continuousAt fun x hx ‚Ü¶ ContinuousAt.div ?_ ?_ ?_).integrableOn_Icc\n  ¬∑ fun_prop\n  ¬∑ apply continuousAt_id.rpow_const (Or.inr <| by linarith)\n  ¬∑ exact (rpow_pos_of_pos ((Nat.cast_pos.mpr hn).trans_le hx.1) _).ne'\n\n"}
{"name":"ZetaAsymptotics.term_one","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"n : Nat\nhn : LT.lt 0 n\n‚ä¢ Eq (ZetaAsymptotics.term n 1) (HSub.hSub (HSub.hSub (Real.log (HAdd.hAdd (‚Üën) 1)) (Real.log ‚Üën)) (HDiv.hDiv 1 (HAdd.hAdd (‚Üën) 1)))","decl":"lemma term_one {n : ‚Ñï} (hn : 0 < n) :\n    term n 1 = (log (n + 1) - log n) -  1 / (n + 1) := by\n  have hv : ‚àÄ x ‚àà uIcc (n : ‚Ñù) (n + 1), 0 < x := by\n    intro x hx\n    rw [uIcc_of_le (by simp only [le_add_iff_nonneg_right, zero_le_one])] at hx\n    exact (Nat.cast_pos.mpr hn).trans_le hx.1\n  calc term n 1\n    _ = ‚à´ x : ‚Ñù in n..(n + 1), (x - n) / x ^ 2 := by\n      simp_rw [term, one_add_one_eq_two, ‚Üê Nat.cast_two (R := ‚Ñù), rpow_natCast]\n    _ = ‚à´ x : ‚Ñù in n..(n + 1), (1 / x - n / x ^ 2) := by\n      refine intervalIntegral.integral_congr (fun x hx ‚Ü¶ ?_)\n      field_simp [(hv x hx).ne']\n      ring\n    _ = (‚à´ x : ‚Ñù in n..(n + 1), 1 / x) - n * ‚à´ x : ‚Ñù in n..(n + 1), 1 / x ^ 2 := by\n      simp_rw [‚Üê mul_one_div (n : ‚Ñù)]\n      rw [intervalIntegral.integral_sub]\n      ¬∑ simp_rw [intervalIntegral.integral_const_mul]\n      ¬∑ exact intervalIntegral.intervalIntegrable_one_div (fun x hx ‚Ü¶ (hv x hx).ne') (by fun_prop)\n      ¬∑ exact (intervalIntegral.intervalIntegrable_one_div\n          (fun x hx ‚Ü¶ (sq_pos_of_pos (hv x hx)).ne') (by fun_prop)).const_mul _\n    _ = (log (‚Üën + 1) - log ‚Üën) - n * ‚à´ x : ‚Ñù in n..(n + 1), 1 / x ^ 2 := by\n      congr 1\n      rw [integral_one_div_of_pos, log_div]\n      all_goals positivity\n    _ = (log (‚Üën + 1) - log ‚Üën) - n * ‚à´ x : ‚Ñù in n..(n + 1), x ^ (-2 : ‚Ñù) := by\n      congr 2\n      refine intervalIntegral.integral_congr (fun x hx ‚Ü¶ ?_)\n      rw [rpow_neg, one_div, ‚Üê Nat.cast_two (R := ‚Ñù), rpow_natCast]\n      exact (hv x hx).le\n    _ = log (‚Üën + 1) - log ‚Üën - n * (1 / n - 1 / (n + 1)) := by\n      rw [integral_rpow]\n      ¬∑ simp_rw [sub_div, (by norm_num : (-2 : ‚Ñù) + 1 = -1), div_neg, div_one, neg_sub_neg,\n          rpow_neg_one, ‚Üê one_div]\n      ¬∑ refine Or.inr ‚ü®by norm_num, not_mem_uIcc_of_lt ?_ ?_‚ü©\n        all_goals positivity\n    _ = log (‚Üën + 1) - log ‚Üën - 1 / (‚Üën + 1) := by\n      congr 1\n      field_simp\n\n"}
{"name":"ZetaAsymptotics.term_sum_one","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"N : Nat\n‚ä¢ Eq (ZetaAsymptotics.term_sum 1 N) (HAdd.hAdd (HSub.hSub (Real.log (HAdd.hAdd (‚ÜëN) 1)) ‚Üë(harmonic (HAdd.hAdd N 1))) 1)","decl":"lemma term_sum_one (N : ‚Ñï) : term_sum 1 N = log (N + 1) - harmonic (N + 1) + 1 := by\n  induction' N with N hN\n  ¬∑ simp_rw [term_sum, Finset.sum_range_zero, harmonic_succ, harmonic_zero,\n      Nat.cast_zero, zero_add, Nat.cast_one, inv_one, Rat.cast_one, log_one, sub_add_cancel]\n  ¬∑ unfold term_sum at hN ‚ä¢\n    rw [Finset.sum_range_succ, hN, harmonic_succ (N + 1),\n      term_one (by positivity : 0 < N + 1)]\n    push_cast\n    ring_nf\n\n"}
{"name":"ZetaAsymptotics.term_tsum_one","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"‚ä¢ HasSum (fun n => ZetaAsymptotics.term (HAdd.hAdd n 1) 1) (HSub.hSub 1 Real.eulerMascheroniConstant)","decl":"/-- The topological sum of `ZetaAsymptotics.term (n + 1) 1` over all `n : ‚Ñï` is `1 - Œ≥`. This is\nproved by directly evaluating the sum of the first `N` terms and using the limit definition of `Œ≥`.\n-/\nlemma term_tsum_one : HasSum (fun n ‚Ü¶ term (n + 1) 1) (1 - Œ≥) := by\n  rw [hasSum_iff_tendsto_nat_of_nonneg (fun n ‚Ü¶ term_nonneg (n + 1) 1)]\n  show Tendsto (fun N ‚Ü¶ term_sum 1 N) atTop _\n  simp_rw [term_sum_one, sub_eq_neg_add]\n  refine Tendsto.add ?_ tendsto_const_nhds\n  have := (tendsto_eulerMascheroniSeq'.comp (tendsto_add_atTop_nat 1)).neg\n  refine this.congr' (Eventually.of_forall (fun n ‚Ü¶ ?_))\n  simp_rw [Function.comp_apply, eulerMascheroniSeq', reduceCtorEq, if_false]\n  push_cast\n  abel\n\n"}
{"name":"ZetaAsymptotics.term_of_lt","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"n : Nat\nhn : LT.lt 0 n\ns : Real\nhs : LT.lt 1 s\n‚ä¢ Eq (ZetaAsymptotics.term n s) (HSub.hSub (HMul.hMul (HDiv.hDiv 1 (HSub.hSub s 1)) (HSub.hSub (HDiv.hDiv 1 (HPow.hPow (‚Üën) (HSub.hSub s 1))) (HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd (‚Üën) 1) (HSub.hSub s 1))))) (HMul.hMul (HDiv.hDiv (‚Üën) s) (HSub.hSub (HDiv.hDiv 1 (HPow.hPow (‚Üën) s)) (HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd (‚Üën) 1) s)))))","decl":"lemma term_of_lt {n : ‚Ñï} (hn : 0 < n) {s : ‚Ñù} (hs : 1 < s) :\n    term n s = 1 / (s - 1) * (1 / n ^ (s - 1) - 1 / (n + 1) ^ (s - 1))\n    - n / s * (1 / n ^ s - 1 / (n + 1) ^ s) := by\n  have hv : ‚àÄ x ‚àà uIcc (n : ‚Ñù) (n + 1), 0 < x := by\n    intro x hx\n    rw [uIcc_of_le (by simp only [le_add_iff_nonneg_right, zero_le_one])] at hx\n    exact (Nat.cast_pos.mpr hn).trans_le hx.1\n  calc term n s\n    _ = ‚à´ x : ‚Ñù in n..(n + 1), (x - n) / x ^ (s + 1) := by rfl\n    _ = ‚à´ x : ‚Ñù in n..(n + 1), (x ^ (-s) - n * x ^ (-(s + 1))) := by\n      refine intervalIntegral.integral_congr (fun x hx ‚Ü¶ ?_)\n      rw [sub_div, rpow_add_one (hv x hx).ne', mul_comm, ‚Üê div_div, div_self (hv x hx).ne',\n        rpow_neg (hv x hx).le, rpow_neg (hv x hx).le, one_div, rpow_add_one (hv x hx).ne', mul_comm,\n        div_eq_mul_inv]\n    _ = (‚à´ x : ‚Ñù in n..(n + 1), x ^ (-s)) - n * (‚à´ x : ‚Ñù in n..(n + 1), x ^ (-(s + 1))) := by\n      rw [intervalIntegral.integral_sub, intervalIntegral.integral_const_mul] <;>\n      [skip; apply IntervalIntegrable.const_mul] <;>\n      ¬∑ refine intervalIntegral.intervalIntegrable_rpow (Or.inr <| not_mem_uIcc_of_lt ?_ ?_)\n        ¬∑ exact_mod_cast hn\n        ¬∑ linarith\n    _ = 1 / (s - 1) * (1 / n ^ (s - 1) - 1 / (n + 1) ^ (s - 1))\n          - n / s * (1 / n ^ s - 1 / (n + 1) ^ s) := by\n      have : 0 ‚àâ uIcc (n : ‚Ñù) (n + 1) := (lt_irrefl _ <| hv _ ¬∑)\n      rw [integral_rpow (Or.inr ‚ü®by linarith, this‚ü©), integral_rpow (Or.inr ‚ü®by linarith, this‚ü©)]\n      congr 1\n      ¬∑ rw [show -s + 1 = -(s - 1) by ring, div_neg, ‚Üê neg_div, mul_comm, mul_one_div, neg_sub,\n          rpow_neg (Nat.cast_nonneg _), one_div, rpow_neg (by linarith), one_div]\n      ¬∑ rw [show -(s + 1) + 1 = -s by ring, div_neg, ‚Üê neg_div, neg_sub, div_mul_eq_mul_div,\n          mul_div_assoc, rpow_neg (Nat.cast_nonneg _), one_div, rpow_neg (by linarith), one_div]\n\n"}
{"name":"ZetaAsymptotics.term_sum_of_lt","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"N : Nat\ns : Real\nhs : LT.lt 1 s\n‚ä¢ Eq (ZetaAsymptotics.term_sum s N) (HSub.hSub (HMul.hMul (HDiv.hDiv 1 (HSub.hSub s 1)) (HSub.hSub 1 (HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd (‚ÜëN) 1) (HSub.hSub s 1))))) (HMul.hMul (HDiv.hDiv 1 s) (HSub.hSub ((Finset.range N).sum fun n => HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd (‚Üën) 1) s)) (HDiv.hDiv (‚ÜëN) (HPow.hPow (HAdd.hAdd (‚ÜëN) 1) s)))))","decl":"lemma term_sum_of_lt (N : ‚Ñï) {s : ‚Ñù} (hs : 1 < s) :\n    term_sum s N = 1 / (s - 1) * (1 - 1 / (N + 1) ^ (s - 1))\n    - 1 / s * ((‚àë n ‚àà Finset.range N, 1 / (n + 1 : ‚Ñù) ^ s) - N / (N + 1) ^ s) := by\n  simp only [term_sum]\n  conv => enter [1, 2, n]; rw [term_of_lt (by simp) hs]\n  rw [Finset.sum_sub_distrib]\n  congr 1\n  ¬∑ induction' N with N hN\n    ¬∑ simp\n    ¬∑ rw [Finset.sum_range_succ, hN, Nat.cast_add_one]\n      ring_nf\n  ¬∑ simp_rw [mul_comm (_ / _), ‚Üê mul_div_assoc, div_eq_mul_inv _ s, ‚Üê Finset.sum_mul, mul_one]\n    congr 1\n    induction' N with N hN\n    ¬∑ simp\n    ¬∑ simp_rw [Finset.sum_range_succ, hN, Nat.cast_add_one, sub_eq_add_neg, add_assoc]\n      congr 1\n      ring_nf\n\n"}
{"name":"ZetaAsymptotics.term_tsum_of_lt","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"s : Real\nhs : LT.lt 1 s\n‚ä¢ Eq (ZetaAsymptotics.term_tsum s) (HSub.hSub (HDiv.hDiv 1 (HSub.hSub s 1)) (HMul.hMul (HDiv.hDiv 1 s) (tsum fun n => HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd (‚Üën) 1) s))))","decl":"/-- For `1 < s`, the topological sum of `ZetaAsymptotics.term (n + 1) s` over all `n : ‚Ñï` is\n`1 / (s - 1) - Œ∂ s / s`.\n-/\nlemma term_tsum_of_lt {s : ‚Ñù} (hs : 1 < s) :\n    term_tsum s = (1 / (s - 1) - 1 / s * ‚àë' n : ‚Ñï, 1 / (n + 1 : ‚Ñù) ^ s) := by\n  apply HasSum.tsum_eq\n  rw [hasSum_iff_tendsto_nat_of_nonneg (fun n ‚Ü¶ term_nonneg (n + 1) s)]\n  change Tendsto (fun N ‚Ü¶ term_sum s N) atTop _\n  simp_rw [term_sum_of_lt _ hs]\n  apply Tendsto.sub\n  ¬∑ rw [show ùìù (1 / (s - 1)) = ùìù (1 / (s - 1) - 1 / (s - 1) * 0) by simp]\n    simp_rw [mul_sub, mul_one]\n    refine tendsto_const_nhds.sub (Tendsto.const_mul _ ?_)\n    refine tendsto_const_nhds.div_atTop <| (tendsto_rpow_atTop (by linarith)).comp ?_\n    exact tendsto_atTop_add_const_right _ _ tendsto_natCast_atTop_atTop\n  ¬∑ rw [‚Üê sub_zero (tsum _)]\n    apply (((Summable.hasSum ?_).tendsto_sum_nat).sub ?_).const_mul\n    ¬∑ exact_mod_cast (summable_nat_add_iff 1).mpr (summable_one_div_nat_rpow.mpr hs)\n    ¬∑ apply tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds\n      ¬∑ change Tendsto (fun n : ‚Ñï ‚Ü¶ (1 / ‚Üë(n + 1) : ‚Ñù) ^ (s - 1)) ..\n        rw [show ùìù (0 : ‚Ñù) = ùìù (0 ^ (s - 1)) by rw [zero_rpow]; linarith]\n        refine Tendsto.rpow_const ?_ (Or.inr <| by linarith)\n        exact (tendsto_const_div_atTop_nhds_zero_nat _).comp (tendsto_add_atTop_nat _)\n      ¬∑ intro n\n        positivity\n      ¬∑ intro n\n        dsimp only\n        transitivity (n + 1) / (n + 1) ^ s\n        ¬∑ gcongr\n          linarith\n        ¬∑ apply le_of_eq\n          rw [rpow_sub_one, ‚Üê div_mul, div_one, mul_comm, one_div, inv_rpow, ‚Üê div_eq_mul_inv]\n          ¬∑ norm_cast\n          all_goals positivity\n\n"}
{"name":"ZetaAsymptotics.zeta_limit_aux1","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"s : Real\nhs : LT.lt 1 s\n‚ä¢ Eq (HSub.hSub (tsum fun n => HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd (‚Üën) 1) s)) (HDiv.hDiv 1 (HSub.hSub s 1))) (HSub.hSub 1 (HMul.hMul s (ZetaAsymptotics.term_tsum s)))","decl":"/-- Reformulation of `ZetaAsymptotics.term_tsum_of_lt` which is useful for some computations\nbelow. -/\nlemma zeta_limit_aux1 {s : ‚Ñù} (hs : 1 < s) :\n    (‚àë' n : ‚Ñï, 1 / (n + 1 : ‚Ñù) ^ s) - 1 / (s - 1) = 1 - s * term_tsum s := by\n  rw [term_tsum_of_lt hs]\n  generalize (‚àë' n : ‚Ñï, 1 / (n + 1 : ‚Ñù) ^ s) = Z\n  field_simp [(show s - 1 ‚â† 0 by linarith)]\n  ring_nf\n\n"}
{"name":"ZetaAsymptotics.continuousOn_term","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"n : Nat\n‚ä¢ ContinuousOn (fun x => ZetaAsymptotics.term (HAdd.hAdd n 1) x) (Set.Ici 1)","decl":"lemma continuousOn_term (n : ‚Ñï) :\n    ContinuousOn (fun x ‚Ü¶ term (n + 1) x) (Ici 1) := by\n  -- TODO: can this be shortened using the lemma\n  -- `continuous_parametric_intervalIntegral_of_continuous'` from https://github.com/leanprover-community/mathlib4/pull/11185?\n  simp only [term, intervalIntegral.integral_of_le (by linarith : (‚Üë(n + 1) : ‚Ñù) ‚â§ ‚Üë(n + 1) + 1)]\n  apply continuousOn_of_dominated (bound := fun x ‚Ü¶ (x - ‚Üë(n + 1)) / x ^ (2 : ‚Ñù))\n  ¬∑ exact fun s hs ‚Ü¶ (term_welldef (by simp) (zero_lt_one.trans_le hs)).1.1\n  ¬∑ intro s (hs : 1 ‚â§ s)\n    rw [ae_restrict_iff' measurableSet_Ioc]\n    filter_upwards with x hx\n    have : 0 < x := lt_trans (by positivity) hx.1\n    rw [norm_of_nonneg (div_nonneg (sub_nonneg.mpr hx.1.le) (by positivity)), Nat.cast_add_one]\n    apply div_le_div_of_nonneg_left\n    ¬∑ exact_mod_cast sub_nonneg.mpr hx.1.le\n    ¬∑ positivity\n    ¬∑ exact rpow_le_rpow_of_exponent_le (le_trans (by simp) hx.1.le) (by linarith)\n  ¬∑ rw [‚Üê IntegrableOn, ‚Üê intervalIntegrable_iff_integrableOn_Ioc_of_le (by linarith)]\n    exact_mod_cast term_welldef (by omega : 0 < (n + 1)) zero_lt_one\n  ¬∑ rw [ae_restrict_iff' measurableSet_Ioc]\n    filter_upwards with x hx\n    refine continuousOn_of_forall_continuousAt (fun s (hs : 1 ‚â§ s) ‚Ü¶ continuousAt_const.div ?_ ?_)\n    ¬∑ exact continuousAt_const.rpow (continuousAt_id.add continuousAt_const) (Or.inr (by linarith))\n    ¬∑ exact (rpow_pos_of_pos ((Nat.cast_pos.mpr (by simp)).trans hx.1) _).ne'\n\n"}
{"name":"ZetaAsymptotics.continuousOn_term_tsum","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"‚ä¢ ContinuousOn ZetaAsymptotics.term_tsum (Set.Ici 1)","decl":"lemma continuousOn_term_tsum : ContinuousOn term_tsum (Ici 1) := by\n  -- We use dominated convergence, using `fun n ‚Ü¶ term n 1` as our uniform bound (since `term` is\n  -- monotone decreasing in `s`.)\n  refine continuousOn_tsum (fun i ‚Ü¶ continuousOn_term _) term_tsum_one.summable (fun n s hs ‚Ü¶ ?_)\n  rw [term, term, norm_of_nonneg]\n  ¬∑ simp_rw [intervalIntegral.integral_of_le (by linarith : (‚Üë(n + 1) : ‚Ñù) ‚â§ ‚Üë(n + 1) + 1)]\n    refine setIntegral_mono_on ?_ ?_ measurableSet_Ioc (fun x hx ‚Ü¶ ?_)\n    ¬∑ exact (term_welldef n.succ_pos (zero_lt_one.trans_le hs)).1\n    ¬∑ exact (term_welldef n.succ_pos zero_lt_one).1\n    ¬∑ rw [div_le_div_iff_of_pos_left] -- leave side-goals to end and kill them all together\n      ¬∑ apply rpow_le_rpow_of_exponent_le\n        ¬∑ exact (lt_of_le_of_lt (by simp) hx.1).le\n        ¬∑ linarith [mem_Ici.mp hs]\n      ¬∑ linarith [hx.1]\n      all_goals apply rpow_pos_of_pos ((Nat.cast_nonneg _).trans_lt hx.1)\n  ¬∑ rw [intervalIntegral.integral_of_le (by linarith)]\n    refine setIntegral_nonneg measurableSet_Ioc (fun x hx ‚Ü¶ div_nonneg ?_ (rpow_nonneg ?_ _))\n    all_goals linarith [hx.1]\n\n"}
{"name":"ZetaAsymptotics.tendsto_riemannZeta_sub_one_div_nhds_right","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"‚ä¢ Filter.Tendsto (fun s => HSub.hSub (riemannZeta ‚Üës) (HDiv.hDiv 1 (HSub.hSub (‚Üës) 1))) (nhdsWithin 1 (Set.Ioi 1)) (nhds ‚ÜëReal.eulerMascheroniConstant)","decl":"/-- First version of the limit formula, with a limit over real numbers tending to 1 from above. -/\nlemma tendsto_riemannZeta_sub_one_div_nhds_right :\n    Tendsto (fun s : ‚Ñù ‚Ü¶ riemannZeta s - 1 / (s - 1)) (ùìù[>] 1) (ùìù Œ≥) := by\n  suffices Tendsto (fun s : ‚Ñù ‚Ü¶ (‚àë' n : ‚Ñï, 1 / (n + 1 : ‚Ñù) ^ s) - 1 / (s - 1))\n    (ùìù[>] 1) (ùìù Œ≥) by\n    apply ((Complex.continuous_ofReal.tendsto _).comp this).congr'\n    filter_upwards [self_mem_nhdsWithin] with s hs\n    simp only [Function.comp_apply, Complex.ofReal_sub, Complex.ofReal_div,\n      Complex.ofReal_one, sub_left_inj, Complex.ofReal_tsum]\n    rw [zeta_eq_tsum_one_div_nat_add_one_cpow (by simpa using hs)]\n    congr 1 with n\n    rw [Complex.ofReal_cpow (by positivity)]\n    norm_cast\n  suffices aux2 : Tendsto (fun s : ‚Ñù ‚Ü¶ (‚àë' n : ‚Ñï, 1 / (n + 1 : ‚Ñù) ^ s) - 1 / (s - 1))\n    (ùìù[>] 1) (ùìù (1 - term_tsum 1)) by\n    have := term_tsum_one.tsum_eq\n    rw [‚Üê term_tsum, eq_sub_iff_add_eq, ‚Üê eq_sub_iff_add_eq'] at this\n    simpa only [this] using aux2\n  apply Tendsto.congr'\n  ¬∑ filter_upwards [self_mem_nhdsWithin] with s hs using (zeta_limit_aux1 hs).symm\n  ¬∑ apply tendsto_const_nhds.sub\n    rw [‚Üê one_mul (term_tsum 1)]\n    apply (tendsto_id.mono_left nhdsWithin_le_nhds).mul\n    have := continuousOn_term_tsum.continuousWithinAt left_mem_Ici\n    exact Tendsto.mono_left this (nhdsWithin_mono _ Ioi_subset_Ici_self)\n\n"}
{"name":"tendsto_riemannZeta_sub_one_div","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"‚ä¢ Filter.Tendsto (fun s => HSub.hSub (riemannZeta s) (HDiv.hDiv 1 (HSub.hSub s 1))) (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhds ‚ÜëReal.eulerMascheroniConstant)","decl":"/-- The function `Œ∂ s - 1 / (s - 1)` tends to `Œ≥` as `s ‚Üí 1`. -/\ntheorem _root_.tendsto_riemannZeta_sub_one_div :\n    Tendsto (fun s : ‚ÑÇ ‚Ü¶ riemannZeta s - 1 / (s - 1)) (ùìù[‚â†] 1) (ùìù Œ≥) := by\n  -- We use the removable-singularity theorem to show that *some* limit over `ùìù[‚â†] (1 : ‚ÑÇ)` exists,\n  -- and then use the previous result to deduce that this limit must be `Œ≥`.\n  let f (s : ‚ÑÇ) := riemannZeta s - 1 / (s - 1)\n  suffices ‚àÉ C, Tendsto f (ùìù[‚â†] 1) (ùìù C) by\n    cases' this with C hC\n    suffices Tendsto (fun s : ‚Ñù ‚Ü¶ f s) _ _\n      from (tendsto_nhds_unique this tendsto_riemannZeta_sub_one_div_nhds_right) ‚ñ∏ hC\n    refine hC.comp (tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ ?_ ?_)\n    ¬∑ exact (Complex.continuous_ofReal.tendsto 1).mono_left (nhdsWithin_le_nhds ..)\n    ¬∑ filter_upwards [self_mem_nhdsWithin] with a ha\n      rw [mem_compl_singleton_iff, ‚Üê Complex.ofReal_one, Ne, Complex.ofReal_inj]\n      exact ne_of_gt ha\n  refine ‚ü®_, Complex.tendsto_limUnder_of_differentiable_on_punctured_nhds_of_isLittleO ?_ ?_‚ü©\n  ¬∑ filter_upwards [self_mem_nhdsWithin] with s hs\n    refine (differentiableAt_riemannZeta hs).sub ((differentiableAt_const _).div ?_ ?_)\n    ¬∑ fun_prop\n    ¬∑ rwa [mem_compl_singleton_iff, ‚Üê sub_ne_zero] at hs\n  ¬∑ refine Asymptotics.isLittleO_of_tendsto' ?_ ?_\n    ¬∑ filter_upwards [self_mem_nhdsWithin] with t ht ht'\n      rw [inv_eq_zero, sub_eq_zero] at ht'\n      tauto\n    ¬∑ simp_rw [div_eq_mul_inv, inv_inv, sub_mul,\n        (by ring_nf : ùìù (0 : ‚ÑÇ) = ùìù ((1 - 1) - f 1 * (1 - 1)))]\n      apply Tendsto.sub\n      ¬∑ simp_rw [mul_comm (f _), f, mul_sub]\n        apply riemannZeta_residue_one.sub\n        refine Tendsto.congr' ?_ (tendsto_const_nhds.mono_left nhdsWithin_le_nhds)\n        filter_upwards [self_mem_nhdsWithin] with x hx\n        field_simp [sub_ne_zero.mpr <| mem_compl_singleton_iff.mp hx]\n      ¬∑ exact ((tendsto_id.sub tendsto_const_nhds).mono_left nhdsWithin_le_nhds).const_mul _\n\n"}
{"name":"isBigO_riemannZeta_sub_one_div","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"F : Type u_1\ninst‚úù¬≤ : Norm F\ninst‚úù¬π : One F\ninst‚úù : NormOneClass F\n‚ä¢ Asymptotics.IsBigO (nhds 1) (fun s => HSub.hSub (riemannZeta s) (HDiv.hDiv 1 (HSub.hSub s 1))) fun x => 1","decl":"lemma _root_.isBigO_riemannZeta_sub_one_div {F : Type*} [Norm F] [One F] [NormOneClass F] :\n    (fun s : ‚ÑÇ ‚Ü¶ riemannZeta s - 1 / (s - 1)) =O[ùìù 1] (fun _ ‚Ü¶ 1 : ‚ÑÇ ‚Üí F) := by\n  simpa only [Asymptotics.isBigO_one_nhds_ne_iff] using\n     tendsto_riemannZeta_sub_one_div.isBigO_one (F := F)\n\n"}
{"name":"ZetaAsymptotics.tendsto_Gamma_term_aux","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"‚ä¢ Filter.Tendsto (fun s => HSub.hSub (HDiv.hDiv 1 (HSub.hSub s 1)) (HDiv.hDiv (HDiv.hDiv 1 s.Gamma‚Ñù) (HSub.hSub s 1))) (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhds (HDiv.hDiv (Neg.neg (HAdd.hAdd (‚ÜëReal.eulerMascheroniConstant) (Complex.log (HMul.hMul 4 ‚ÜëReal.pi)))) 2))","decl":"lemma tendsto_Gamma_term_aux : Tendsto (fun s ‚Ü¶ 1 / (s - 1) - 1 / Gamma‚Ñù s / (s - 1)) (ùìù[‚â†] 1)\n    (ùìù (-(Œ≥ + Complex.log (4 * ‚ÜëœÄ)) / 2)) := by\n  have h := hasDerivAt_Gamma‚Ñù_one\n  rw [hasDerivAt_iff_tendsto_slope, slope_fun_def_field, Gamma‚Ñù_one] at h\n  have := h.div (hasDerivAt_Gamma‚Ñù_one.continuousAt.tendsto.mono_left nhdsWithin_le_nhds)\n    (Gamma‚Ñù_one.trans_ne one_ne_zero)\n  rw [Gamma‚Ñù_one, div_one] at this\n  refine this.congr' ?_\n  have : {z | 0 < re z} ‚àà ùìù (1 : ‚ÑÇ) := by\n    apply (continuous_re.isOpen_preimage _ isOpen_Ioi).mem_nhds\n    simp only [mem_preimage, one_re, mem_Ioi, zero_lt_one]\n  rw [EventuallyEq, eventually_nhdsWithin_iff]\n  filter_upwards [this] with a ha _\n  rw [Pi.div_apply, ‚Üê sub_div, div_right_comm, sub_div' _ _ _ (Gamma‚Ñù_ne_zero_of_re_pos ha),\n    one_mul]\n\n"}
{"name":"ZetaAsymptotics.tendsto_riemannZeta_sub_one_div_Gamma‚Ñù","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"‚ä¢ Filter.Tendsto (fun s => HSub.hSub (riemannZeta s) (HDiv.hDiv (HDiv.hDiv 1 s.Gamma‚Ñù) (HSub.hSub s 1))) (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhds (HDiv.hDiv (HSub.hSub (‚ÜëReal.eulerMascheroniConstant) (Complex.log (HMul.hMul 4 ‚ÜëReal.pi))) 2))","decl":"lemma tendsto_riemannZeta_sub_one_div_Gamma‚Ñù :\n    Tendsto (fun s ‚Ü¶ riemannZeta s - 1 / Gamma‚Ñù s / (s - 1)) (ùìù[‚â†] 1)\n    (ùìù ((Œ≥ - Complex.log (4 * ‚ÜëœÄ)) / 2)) := by\n  have := tendsto_riemannZeta_sub_one_div.add tendsto_Gamma_term_aux\n  simp_rw [sub_add_sub_cancel] at this\n  convert this using 2\n  ring_nf\n\n"}
{"name":"riemannZeta_one","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"‚ä¢ Eq (riemannZeta 1) (HDiv.hDiv (HSub.hSub (‚ÜëReal.eulerMascheroniConstant) (Complex.log (HMul.hMul 4 ‚ÜëReal.pi))) 2)","decl":"/-- Formula for `Œ∂ 1`. Note that mathematically `Œ∂ 1` is undefined, but our construction ascribes\nthis particular value to it. -/\nlemma _root_.riemannZeta_one : riemannZeta 1 = (Œ≥ - Complex.log (4 * ‚ÜëœÄ)) / 2 := by\n  have := (HurwitzZeta.tendsto_hurwitzZetaEven_sub_one_div_nhds_one 0).mono_left\n    <| nhdsWithin_le_nhds (s := {1}·∂ú)\n  simp only [HurwitzZeta.hurwitzZetaEven_zero, div_right_comm _ _ (Gamma‚Ñù _)] at this\n  exact tendsto_nhds_unique this tendsto_riemannZeta_sub_one_div_Gamma‚Ñù\n\n"}
{"name":"completedRiemannZeta_one","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"‚ä¢ Eq (completedRiemannZeta 1) (HDiv.hDiv (HSub.hSub (‚ÜëReal.eulerMascheroniConstant) (Complex.log (HMul.hMul 4 ‚ÜëReal.pi))) 2)","decl":"/-- Formula for `Œõ 1`. Note that mathematically `Œõ 1` is undefined, but our construction ascribes\nthis particular value to it. -/\nlemma _root_.completedRiemannZeta_one :\n    completedRiemannZeta 1 = (Œ≥ - Complex.log (4 * ‚ÜëœÄ)) / 2 :=\n  (riemannZeta_one ‚ñ∏ div_one (_ : ‚ÑÇ) ‚ñ∏ Gamma‚Ñù_one ‚ñ∏ riemannZeta_def_of_ne_zero one_ne_zero).symm\n\n"}
{"name":"completedRiemannZeta‚ÇÄ_one","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"‚ä¢ Eq (completedRiemannZeta‚ÇÄ 1) (HAdd.hAdd (HDiv.hDiv (HSub.hSub (‚ÜëReal.eulerMascheroniConstant) (Complex.log (HMul.hMul 4 ‚ÜëReal.pi))) 2) 1)","decl":"/-- Formula for `Œõ‚ÇÄ 1`, where `Œõ‚ÇÄ` is the entire function satisfying\n`Œõ‚ÇÄ s = œÄ ^ (-s / 2) Œì(s / 2) Œ∂(s) + 1 / s + 1 / (1 - s)` away from `s = 0, 1`.\n\nNote that `s = 1` is _not_ a pole of `Œõ‚ÇÄ`, so this statement (unlike `riemannZeta_one`) is\na mathematically meaningful statement and is not dependent on Mathlib's particular conventions for\ndivision by zero. -/\nlemma _root_.completedRiemannZeta‚ÇÄ_one :\n    completedRiemannZeta‚ÇÄ 1 = (Œ≥ - Complex.log (4 * ‚ÜëœÄ)) / 2 + 1 := by\n  have := completedRiemannZeta_eq 1\n  rw [sub_self, div_zero, div_one, sub_zero, eq_sub_iff_add_eq] at this\n  rw [‚Üê this, completedRiemannZeta_one]\n\n"}
{"name":"riemannZeta_one_ne_zero","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"‚ä¢ Ne (riemannZeta 1) 0","decl":"/-- With Mathlib's particular conventions, we have `Œ∂ 1 ‚â† 0`. -/\nlemma _root_.riemannZeta_one_ne_zero : riemannZeta 1 ‚â† 0 := by\n  -- This one's for you, Kevin.\n  suffices (Œ≥ - (4 * œÄ).log) / 2 ‚â† 0 by\n    simpa only [riemannZeta_one, ‚Üê ofReal_ne_zero, ofReal_log (by positivity : 0 ‚â§ 4 * œÄ),\n      push_cast]\n  refine div_ne_zero (sub_lt_zero.mpr (lt_trans ?_ ?_ (b := 1))).ne two_ne_zero\n  ¬∑ exact Real.eulerMascheroniConstant_lt_two_thirds.trans (by norm_num)\n  ¬∑ rw [lt_log_iff_exp_lt (by positivity)]\n    exact (lt_trans Real.exp_one_lt_d9 (by norm_num)).trans_le\n      <| mul_le_mul_of_nonneg_left two_le_pi (by norm_num)\n\n"}
