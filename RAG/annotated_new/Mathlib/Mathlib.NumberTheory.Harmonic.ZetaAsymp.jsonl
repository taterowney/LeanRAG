{"name":"ZetaAsymptotics.term_nonneg","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"n : Nat\ns : Real\nâŠ¢ LE.le 0 (ZetaAsymptotics.term n s)","decl":"lemma term_nonneg (n : â„•) (s : â„) : 0 â‰¤ term n s := by\n  rw [term, intervalIntegral.integral_of_le (by simp)]\n  refine setIntegral_nonneg measurableSet_Ioc (fun x hx â†¦ ?_)\n  refine div_nonneg ?_ (rpow_nonneg ?_ _)\n  all_goals linarith [hx.1]\n\n"}
{"name":"ZetaAsymptotics.term_welldef","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"n : Nat\nhn : LT.lt 0 n\ns : Real\nhs : LT.lt 0 s\nâŠ¢ IntervalIntegrable (fun x => HDiv.hDiv (HSub.hSub x â†‘n) (HPow.hPow x (HAdd.hAdd s 1))) MeasureTheory.MeasureSpace.volume (â†‘n) (HAdd.hAdd (â†‘n) 1)","decl":"lemma term_welldef {n : â„•} (hn : 0 < n) {s : â„} (hs : 0 < s) :\n    IntervalIntegrable (fun x : â„ â†¦ (x - n) / x ^ (s + 1)) volume n (n + 1) := by\n  rw [intervalIntegrable_iff_integrableOn_Icc_of_le (by linarith)]\n  refine (continuousOn_of_forall_continuousAt fun x hx â†¦ ContinuousAt.div ?_ ?_ ?_).integrableOn_Icc\n  Â· fun_prop\n  Â· apply continuousAt_id.rpow_const (Or.inr <| by linarith)\n  Â· exact (rpow_pos_of_pos ((Nat.cast_pos.mpr hn).trans_le hx.1) _).ne'\n\n"}
{"name":"ZetaAsymptotics.term_one","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"n : Nat\nhn : LT.lt 0 n\nâŠ¢ Eq (ZetaAsymptotics.term n 1) (HSub.hSub (HSub.hSub (Real.log (HAdd.hAdd (â†‘n) 1)) (Real.log â†‘n)) (HDiv.hDiv 1 (HAdd.hAdd (â†‘n) 1)))","decl":"lemma term_one {n : â„•} (hn : 0 < n) :\n    term n 1 = (log (n + 1) - log n) -  1 / (n + 1) := by\n  have hv : âˆ€ x âˆˆ uIcc (n : â„) (n + 1), 0 < x := by\n    intro x hx\n    rw [uIcc_of_le (by simp only [le_add_iff_nonneg_right, zero_le_one])] at hx\n    exact (Nat.cast_pos.mpr hn).trans_le hx.1\n  calc term n 1\n    _ = âˆ« x : â„ in n..(n + 1), (x - n) / x ^ 2 := by\n      simp_rw [term, one_add_one_eq_two, â† Nat.cast_two (R := â„), rpow_natCast]\n    _ = âˆ« x : â„ in n..(n + 1), (1 / x - n / x ^ 2) := by\n      refine intervalIntegral.integral_congr (fun x hx â†¦ ?_)\n      field_simp [(hv x hx).ne']\n      ring\n    _ = (âˆ« x : â„ in n..(n + 1), 1 / x) - n * âˆ« x : â„ in n..(n + 1), 1 / x ^ 2 := by\n      simp_rw [â† mul_one_div (n : â„)]\n      rw [intervalIntegral.integral_sub]\n      Â· simp_rw [intervalIntegral.integral_const_mul]\n      Â· exact intervalIntegral.intervalIntegrable_one_div (fun x hx â†¦ (hv x hx).ne') (by fun_prop)\n      Â· exact (intervalIntegral.intervalIntegrable_one_div\n          (fun x hx â†¦ (sq_pos_of_pos (hv x hx)).ne') (by fun_prop)).const_mul _\n    _ = (log (â†‘n + 1) - log â†‘n) - n * âˆ« x : â„ in n..(n + 1), 1 / x ^ 2 := by\n      congr 1\n      rw [integral_one_div_of_pos, log_div]\n      all_goals positivity\n    _ = (log (â†‘n + 1) - log â†‘n) - n * âˆ« x : â„ in n..(n + 1), x ^ (-2 : â„) := by\n      congr 2\n      refine intervalIntegral.integral_congr (fun x hx â†¦ ?_)\n      rw [rpow_neg, one_div, â† Nat.cast_two (R := â„), rpow_natCast]\n      exact (hv x hx).le\n    _ = log (â†‘n + 1) - log â†‘n - n * (1 / n - 1 / (n + 1)) := by\n      rw [integral_rpow]\n      Â· simp_rw [sub_div, (by norm_num : (-2 : â„) + 1 = -1), div_neg, div_one, neg_sub_neg,\n          rpow_neg_one, â† one_div]\n      Â· refine Or.inr âŸ¨by norm_num, not_mem_uIcc_of_lt ?_ ?_âŸ©\n        all_goals positivity\n    _ = log (â†‘n + 1) - log â†‘n - 1 / (â†‘n + 1) := by\n      congr 1\n      field_simp\n\n"}
{"name":"ZetaAsymptotics.term_sum_one","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"N : Nat\nâŠ¢ Eq (ZetaAsymptotics.term_sum 1 N) (HAdd.hAdd (HSub.hSub (Real.log (HAdd.hAdd (â†‘N) 1)) â†‘(harmonic (HAdd.hAdd N 1))) 1)","decl":"lemma term_sum_one (N : â„•) : term_sum 1 N = log (N + 1) - harmonic (N + 1) + 1 := by\n  induction' N with N hN\n  Â· simp_rw [term_sum, Finset.sum_range_zero, harmonic_succ, harmonic_zero,\n      Nat.cast_zero, zero_add, Nat.cast_one, inv_one, Rat.cast_one, log_one, sub_add_cancel]\n  Â· unfold term_sum at hN âŠ¢\n    rw [Finset.sum_range_succ, hN, harmonic_succ (N + 1),\n      term_one (by positivity : 0 < N + 1)]\n    push_cast\n    ring_nf\n\n"}
{"name":"ZetaAsymptotics.term_tsum_one","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"âŠ¢ HasSum (fun n => ZetaAsymptotics.term (HAdd.hAdd n 1) 1) (HSub.hSub 1 Real.eulerMascheroniConstant)","decl":"/-- The topological sum of `ZetaAsymptotics.term (n + 1) 1` over all `n : â„•` is `1 - Î³`. This is\nproved by directly evaluating the sum of the first `N` terms and using the limit definition of `Î³`.\n-/\nlemma term_tsum_one : HasSum (fun n â†¦ term (n + 1) 1) (1 - Î³) := by\n  rw [hasSum_iff_tendsto_nat_of_nonneg (fun n â†¦ term_nonneg (n + 1) 1)]\n  show Tendsto (fun N â†¦ term_sum 1 N) atTop _\n  simp_rw [term_sum_one, sub_eq_neg_add]\n  refine Tendsto.add ?_ tendsto_const_nhds\n  have := (tendsto_eulerMascheroniSeq'.comp (tendsto_add_atTop_nat 1)).neg\n  refine this.congr' (Eventually.of_forall (fun n â†¦ ?_))\n  simp_rw [Function.comp_apply, eulerMascheroniSeq', reduceCtorEq, if_false]\n  push_cast\n  abel\n\n"}
{"name":"ZetaAsymptotics.term_of_lt","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"n : Nat\nhn : LT.lt 0 n\ns : Real\nhs : LT.lt 1 s\nâŠ¢ Eq (ZetaAsymptotics.term n s) (HSub.hSub (HMul.hMul (HDiv.hDiv 1 (HSub.hSub s 1)) (HSub.hSub (HDiv.hDiv 1 (HPow.hPow (â†‘n) (HSub.hSub s 1))) (HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd (â†‘n) 1) (HSub.hSub s 1))))) (HMul.hMul (HDiv.hDiv (â†‘n) s) (HSub.hSub (HDiv.hDiv 1 (HPow.hPow (â†‘n) s)) (HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd (â†‘n) 1) s)))))","decl":"lemma term_of_lt {n : â„•} (hn : 0 < n) {s : â„} (hs : 1 < s) :\n    term n s = 1 / (s - 1) * (1 / n ^ (s - 1) - 1 / (n + 1) ^ (s - 1))\n    - n / s * (1 / n ^ s - 1 / (n + 1) ^ s) := by\n  have hv : âˆ€ x âˆˆ uIcc (n : â„) (n + 1), 0 < x := by\n    intro x hx\n    rw [uIcc_of_le (by simp only [le_add_iff_nonneg_right, zero_le_one])] at hx\n    exact (Nat.cast_pos.mpr hn).trans_le hx.1\n  calc term n s\n    _ = âˆ« x : â„ in n..(n + 1), (x - n) / x ^ (s + 1) := by rfl\n    _ = âˆ« x : â„ in n..(n + 1), (x ^ (-s) - n * x ^ (-(s + 1))) := by\n      refine intervalIntegral.integral_congr (fun x hx â†¦ ?_)\n      rw [sub_div, rpow_add_one (hv x hx).ne', mul_comm, â† div_div, div_self (hv x hx).ne',\n        rpow_neg (hv x hx).le, rpow_neg (hv x hx).le, one_div, rpow_add_one (hv x hx).ne', mul_comm,\n        div_eq_mul_inv]\n    _ = (âˆ« x : â„ in n..(n + 1), x ^ (-s)) - n * (âˆ« x : â„ in n..(n + 1), x ^ (-(s + 1))) := by\n      rw [intervalIntegral.integral_sub, intervalIntegral.integral_const_mul] <;>\n      [skip; apply IntervalIntegrable.const_mul] <;>\n      Â· refine intervalIntegral.intervalIntegrable_rpow (Or.inr <| not_mem_uIcc_of_lt ?_ ?_)\n        Â· exact_mod_cast hn\n        Â· linarith\n    _ = 1 / (s - 1) * (1 / n ^ (s - 1) - 1 / (n + 1) ^ (s - 1))\n          - n / s * (1 / n ^ s - 1 / (n + 1) ^ s) := by\n      have : 0 âˆ‰ uIcc (n : â„) (n + 1) := (lt_irrefl _ <| hv _ Â·)\n      rw [integral_rpow (Or.inr âŸ¨by linarith, thisâŸ©), integral_rpow (Or.inr âŸ¨by linarith, thisâŸ©)]\n      congr 1\n      Â· rw [show -s + 1 = -(s - 1) by ring, div_neg, â† neg_div, mul_comm, mul_one_div, neg_sub,\n          rpow_neg (Nat.cast_nonneg _), one_div, rpow_neg (by linarith), one_div]\n      Â· rw [show -(s + 1) + 1 = -s by ring, div_neg, â† neg_div, neg_sub, div_mul_eq_mul_div,\n          mul_div_assoc, rpow_neg (Nat.cast_nonneg _), one_div, rpow_neg (by linarith), one_div]\n\n"}
{"name":"ZetaAsymptotics.term_sum_of_lt","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"N : Nat\ns : Real\nhs : LT.lt 1 s\nâŠ¢ Eq (ZetaAsymptotics.term_sum s N) (HSub.hSub (HMul.hMul (HDiv.hDiv 1 (HSub.hSub s 1)) (HSub.hSub 1 (HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd (â†‘N) 1) (HSub.hSub s 1))))) (HMul.hMul (HDiv.hDiv 1 s) (HSub.hSub ((Finset.range N).sum fun n => HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd (â†‘n) 1) s)) (HDiv.hDiv (â†‘N) (HPow.hPow (HAdd.hAdd (â†‘N) 1) s)))))","decl":"lemma term_sum_of_lt (N : â„•) {s : â„} (hs : 1 < s) :\n    term_sum s N = 1 / (s - 1) * (1 - 1 / (N + 1) ^ (s - 1))\n    - 1 / s * ((âˆ‘ n âˆˆ Finset.range N, 1 / (n + 1 : â„) ^ s) - N / (N + 1) ^ s) := by\n  simp only [term_sum]\n  conv => enter [1, 2, n]; rw [term_of_lt (by simp) hs]\n  rw [Finset.sum_sub_distrib]\n  congr 1\n  Â· induction' N with N hN\n    Â· simp\n    Â· rw [Finset.sum_range_succ, hN, Nat.cast_add_one]\n      ring_nf\n  Â· simp_rw [mul_comm (_ / _), â† mul_div_assoc, div_eq_mul_inv _ s, â† Finset.sum_mul, mul_one]\n    congr 1\n    induction' N with N hN\n    Â· simp\n    Â· simp_rw [Finset.sum_range_succ, hN, Nat.cast_add_one, sub_eq_add_neg, add_assoc]\n      congr 1\n      ring_nf\n\n"}
{"name":"ZetaAsymptotics.term_tsum_of_lt","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"s : Real\nhs : LT.lt 1 s\nâŠ¢ Eq (ZetaAsymptotics.term_tsum s) (HSub.hSub (HDiv.hDiv 1 (HSub.hSub s 1)) (HMul.hMul (HDiv.hDiv 1 s) (tsum fun n => HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd (â†‘n) 1) s))))","decl":"/-- For `1 < s`, the topological sum of `ZetaAsymptotics.term (n + 1) s` over all `n : â„•` is\n`1 / (s - 1) - Î¶ s / s`.\n-/\nlemma term_tsum_of_lt {s : â„} (hs : 1 < s) :\n    term_tsum s = (1 / (s - 1) - 1 / s * âˆ‘' n : â„•, 1 / (n + 1 : â„) ^ s) := by\n  apply HasSum.tsum_eq\n  rw [hasSum_iff_tendsto_nat_of_nonneg (fun n â†¦ term_nonneg (n + 1) s)]\n  change Tendsto (fun N â†¦ term_sum s N) atTop _\n  simp_rw [term_sum_of_lt _ hs]\n  apply Tendsto.sub\n  Â· rw [show ğ“ (1 / (s - 1)) = ğ“ (1 / (s - 1) - 1 / (s - 1) * 0) by simp]\n    simp_rw [mul_sub, mul_one]\n    refine tendsto_const_nhds.sub (Tendsto.const_mul _ ?_)\n    refine tendsto_const_nhds.div_atTop <| (tendsto_rpow_atTop (by linarith)).comp ?_\n    exact tendsto_atTop_add_const_right _ _ tendsto_natCast_atTop_atTop\n  Â· rw [â† sub_zero (tsum _)]\n    apply (((Summable.hasSum ?_).tendsto_sum_nat).sub ?_).const_mul\n    Â· exact_mod_cast (summable_nat_add_iff 1).mpr (summable_one_div_nat_rpow.mpr hs)\n    Â· apply tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds\n      Â· change Tendsto (fun n : â„• â†¦ (1 / â†‘(n + 1) : â„) ^ (s - 1)) ..\n        rw [show ğ“ (0 : â„) = ğ“ (0 ^ (s - 1)) by rw [zero_rpow]; linarith]\n        refine Tendsto.rpow_const ?_ (Or.inr <| by linarith)\n        exact (tendsto_const_div_atTop_nhds_zero_nat _).comp (tendsto_add_atTop_nat _)\n      Â· intro n\n        positivity\n      Â· intro n\n        dsimp only\n        transitivity (n + 1) / (n + 1) ^ s\n        Â· gcongr\n          linarith\n        Â· apply le_of_eq\n          rw [rpow_sub_one, â† div_mul, div_one, mul_comm, one_div, inv_rpow, â† div_eq_mul_inv]\n          Â· norm_cast\n          all_goals positivity\n\n"}
{"name":"ZetaAsymptotics.zeta_limit_aux1","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"s : Real\nhs : LT.lt 1 s\nâŠ¢ Eq (HSub.hSub (tsum fun n => HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd (â†‘n) 1) s)) (HDiv.hDiv 1 (HSub.hSub s 1))) (HSub.hSub 1 (HMul.hMul s (ZetaAsymptotics.term_tsum s)))","decl":"/-- Reformulation of `ZetaAsymptotics.term_tsum_of_lt` which is useful for some computations\nbelow. -/\nlemma zeta_limit_aux1 {s : â„} (hs : 1 < s) :\n    (âˆ‘' n : â„•, 1 / (n + 1 : â„) ^ s) - 1 / (s - 1) = 1 - s * term_tsum s := by\n  rw [term_tsum_of_lt hs]\n  generalize (âˆ‘' n : â„•, 1 / (n + 1 : â„) ^ s) = Z\n  field_simp [(show s - 1 â‰  0 by linarith)]\n  ring_nf\n\n"}
{"name":"ZetaAsymptotics.continuousOn_term","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"n : Nat\nâŠ¢ ContinuousOn (fun x => ZetaAsymptotics.term (HAdd.hAdd n 1) x) (Set.Ici 1)","decl":"lemma continuousOn_term (n : â„•) :\n    ContinuousOn (fun x â†¦ term (n + 1) x) (Ici 1) := by\n  -- TODO: can this be shortened using the lemma\n  -- `continuous_parametric_intervalIntegral_of_continuous'` from https://github.com/leanprover-community/mathlib4/pull/11185?\n  simp only [term, intervalIntegral.integral_of_le (by linarith : (â†‘(n + 1) : â„) â‰¤ â†‘(n + 1) + 1)]\n  apply continuousOn_of_dominated (bound := fun x â†¦ (x - â†‘(n + 1)) / x ^ (2 : â„))\n  Â· exact fun s hs â†¦ (term_welldef (by simp) (zero_lt_one.trans_le hs)).1.1\n  Â· intro s (hs : 1 â‰¤ s)\n    rw [ae_restrict_iff' measurableSet_Ioc]\n    filter_upwards with x hx\n    have : 0 < x := lt_trans (by positivity) hx.1\n    rw [norm_of_nonneg (div_nonneg (sub_nonneg.mpr hx.1.le) (by positivity)), Nat.cast_add_one]\n    apply div_le_div_of_nonneg_left\n    Â· exact_mod_cast sub_nonneg.mpr hx.1.le\n    Â· positivity\n    Â· exact rpow_le_rpow_of_exponent_le (le_trans (by simp) hx.1.le) (by linarith)\n  Â· rw [â† IntegrableOn, â† intervalIntegrable_iff_integrableOn_Ioc_of_le (by linarith)]\n    exact_mod_cast term_welldef (by omega : 0 < (n + 1)) zero_lt_one\n  Â· rw [ae_restrict_iff' measurableSet_Ioc]\n    filter_upwards with x hx\n    refine continuousOn_of_forall_continuousAt (fun s (hs : 1 â‰¤ s) â†¦ continuousAt_const.div ?_ ?_)\n    Â· exact continuousAt_const.rpow (continuousAt_id.add continuousAt_const) (Or.inr (by linarith))\n    Â· exact (rpow_pos_of_pos ((Nat.cast_pos.mpr (by simp)).trans hx.1) _).ne'\n\n"}
{"name":"ZetaAsymptotics.continuousOn_term_tsum","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"âŠ¢ ContinuousOn ZetaAsymptotics.term_tsum (Set.Ici 1)","decl":"lemma continuousOn_term_tsum : ContinuousOn term_tsum (Ici 1) := by\n  -- We use dominated convergence, using `fun n â†¦ term n 1` as our uniform bound (since `term` is\n  -- monotone decreasing in `s`.)\n  refine continuousOn_tsum (fun i â†¦ continuousOn_term _) term_tsum_one.summable (fun n s hs â†¦ ?_)\n  rw [term, term, norm_of_nonneg]\n  Â· simp_rw [intervalIntegral.integral_of_le (by linarith : (â†‘(n + 1) : â„) â‰¤ â†‘(n + 1) + 1)]\n    refine setIntegral_mono_on ?_ ?_ measurableSet_Ioc (fun x hx â†¦ ?_)\n    Â· exact (term_welldef n.succ_pos (zero_lt_one.trans_le hs)).1\n    Â· exact (term_welldef n.succ_pos zero_lt_one).1\n    Â· rw [div_le_div_iff_of_pos_left] -- leave side-goals to end and kill them all together\n      Â· apply rpow_le_rpow_of_exponent_le\n        Â· exact (lt_of_le_of_lt (by simp) hx.1).le\n        Â· linarith [mem_Ici.mp hs]\n      Â· linarith [hx.1]\n      all_goals apply rpow_pos_of_pos ((Nat.cast_nonneg _).trans_lt hx.1)\n  Â· rw [intervalIntegral.integral_of_le (by linarith)]\n    refine setIntegral_nonneg measurableSet_Ioc (fun x hx â†¦ div_nonneg ?_ (rpow_nonneg ?_ _))\n    all_goals linarith [hx.1]\n\n"}
{"name":"ZetaAsymptotics.tendsto_riemannZeta_sub_one_div_nhds_right","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"âŠ¢ Filter.Tendsto (fun s => HSub.hSub (riemannZeta â†‘s) (HDiv.hDiv 1 (HSub.hSub (â†‘s) 1))) (nhdsWithin 1 (Set.Ioi 1)) (nhds â†‘Real.eulerMascheroniConstant)","decl":"/-- First version of the limit formula, with a limit over real numbers tending to 1 from above. -/\nlemma tendsto_riemannZeta_sub_one_div_nhds_right :\n    Tendsto (fun s : â„ â†¦ riemannZeta s - 1 / (s - 1)) (ğ“[>] 1) (ğ“ Î³) := by\n  suffices Tendsto (fun s : â„ â†¦ (âˆ‘' n : â„•, 1 / (n + 1 : â„) ^ s) - 1 / (s - 1))\n    (ğ“[>] 1) (ğ“ Î³) by\n    apply ((Complex.continuous_ofReal.tendsto _).comp this).congr'\n    filter_upwards [self_mem_nhdsWithin] with s hs\n    simp only [Function.comp_apply, Complex.ofReal_sub, Complex.ofReal_div,\n      Complex.ofReal_one, sub_left_inj, Complex.ofReal_tsum]\n    rw [zeta_eq_tsum_one_div_nat_add_one_cpow (by simpa using hs)]\n    congr 1 with n\n    rw [Complex.ofReal_cpow (by positivity)]\n    norm_cast\n  suffices aux2 : Tendsto (fun s : â„ â†¦ (âˆ‘' n : â„•, 1 / (n + 1 : â„) ^ s) - 1 / (s - 1))\n    (ğ“[>] 1) (ğ“ (1 - term_tsum 1)) by\n    have := term_tsum_one.tsum_eq\n    rw [â† term_tsum, eq_sub_iff_add_eq, â† eq_sub_iff_add_eq'] at this\n    simpa only [this] using aux2\n  apply Tendsto.congr'\n  Â· filter_upwards [self_mem_nhdsWithin] with s hs using (zeta_limit_aux1 hs).symm\n  Â· apply tendsto_const_nhds.sub\n    rw [â† one_mul (term_tsum 1)]\n    apply (tendsto_id.mono_left nhdsWithin_le_nhds).mul\n    have := continuousOn_term_tsum.continuousWithinAt left_mem_Ici\n    exact Tendsto.mono_left this (nhdsWithin_mono _ Ioi_subset_Ici_self)\n\n"}
{"name":"tendsto_riemannZeta_sub_one_div","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"âŠ¢ Filter.Tendsto (fun s => HSub.hSub (riemannZeta s) (HDiv.hDiv 1 (HSub.hSub s 1))) (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhds â†‘Real.eulerMascheroniConstant)","decl":"/-- The function `Î¶ s - 1 / (s - 1)` tends to `Î³` as `s â†’ 1`. -/\ntheorem _root_.tendsto_riemannZeta_sub_one_div :\n    Tendsto (fun s : â„‚ â†¦ riemannZeta s - 1 / (s - 1)) (ğ“[â‰ ] 1) (ğ“ Î³) := by\n  -- We use the removable-singularity theorem to show that *some* limit over `ğ“[â‰ ] (1 : â„‚)` exists,\n  -- and then use the previous result to deduce that this limit must be `Î³`.\n  let f (s : â„‚) := riemannZeta s - 1 / (s - 1)\n  suffices âˆƒ C, Tendsto f (ğ“[â‰ ] 1) (ğ“ C) by\n    cases' this with C hC\n    suffices Tendsto (fun s : â„ â†¦ f s) _ _\n      from (tendsto_nhds_unique this tendsto_riemannZeta_sub_one_div_nhds_right) â–¸ hC\n    refine hC.comp (tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ ?_ ?_)\n    Â· exact (Complex.continuous_ofReal.tendsto 1).mono_left (nhdsWithin_le_nhds ..)\n    Â· filter_upwards [self_mem_nhdsWithin] with a ha\n      rw [mem_compl_singleton_iff, â† Complex.ofReal_one, Ne, Complex.ofReal_inj]\n      exact ne_of_gt ha\n  refine âŸ¨_, Complex.tendsto_limUnder_of_differentiable_on_punctured_nhds_of_isLittleO ?_ ?_âŸ©\n  Â· filter_upwards [self_mem_nhdsWithin] with s hs\n    refine (differentiableAt_riemannZeta hs).sub ((differentiableAt_const _).div ?_ ?_)\n    Â· fun_prop\n    Â· rwa [mem_compl_singleton_iff, â† sub_ne_zero] at hs\n  Â· refine Asymptotics.isLittleO_of_tendsto' ?_ ?_\n    Â· filter_upwards [self_mem_nhdsWithin] with t ht ht'\n      rw [inv_eq_zero, sub_eq_zero] at ht'\n      tauto\n    Â· simp_rw [div_eq_mul_inv, inv_inv, sub_mul,\n        (by ring_nf : ğ“ (0 : â„‚) = ğ“ ((1 - 1) - f 1 * (1 - 1)))]\n      apply Tendsto.sub\n      Â· simp_rw [mul_comm (f _), f, mul_sub]\n        apply riemannZeta_residue_one.sub\n        refine Tendsto.congr' ?_ (tendsto_const_nhds.mono_left nhdsWithin_le_nhds)\n        filter_upwards [self_mem_nhdsWithin] with x hx\n        field_simp [sub_ne_zero.mpr <| mem_compl_singleton_iff.mp hx]\n      Â· exact ((tendsto_id.sub tendsto_const_nhds).mono_left nhdsWithin_le_nhds).const_mul _\n\n"}
{"name":"isBigO_riemannZeta_sub_one_div","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"F : Type u_1\ninstâœÂ² : Norm F\ninstâœÂ¹ : One F\ninstâœ : NormOneClass F\nâŠ¢ Asymptotics.IsBigO (nhds 1) (fun s => HSub.hSub (riemannZeta s) (HDiv.hDiv 1 (HSub.hSub s 1))) fun x => 1","decl":"lemma _root_.isBigO_riemannZeta_sub_one_div {F : Type*} [Norm F] [One F] [NormOneClass F] :\n    (fun s : â„‚ â†¦ riemannZeta s - 1 / (s - 1)) =O[ğ“ 1] (fun _ â†¦ 1 : â„‚ â†’ F) := by\n  simpa only [Asymptotics.isBigO_one_nhds_ne_iff] using\n     tendsto_riemannZeta_sub_one_div.isBigO_one (F := F)\n\n"}
{"name":"ZetaAsymptotics.tendsto_Gamma_term_aux","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"âŠ¢ Filter.Tendsto (fun s => HSub.hSub (HDiv.hDiv 1 (HSub.hSub s 1)) (HDiv.hDiv (HDiv.hDiv 1 s.Gammaâ„) (HSub.hSub s 1))) (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhds (HDiv.hDiv (Neg.neg (HAdd.hAdd (â†‘Real.eulerMascheroniConstant) (Complex.log (HMul.hMul 4 â†‘Real.pi)))) 2))","decl":"lemma tendsto_Gamma_term_aux : Tendsto (fun s â†¦ 1 / (s - 1) - 1 / Gammaâ„ s / (s - 1)) (ğ“[â‰ ] 1)\n    (ğ“ (-(Î³ + Complex.log (4 * â†‘Ï€)) / 2)) := by\n  have h := hasDerivAt_Gammaâ„_one\n  rw [hasDerivAt_iff_tendsto_slope, slope_fun_def_field, Gammaâ„_one] at h\n  have := h.div (hasDerivAt_Gammaâ„_one.continuousAt.tendsto.mono_left nhdsWithin_le_nhds)\n    (Gammaâ„_one.trans_ne one_ne_zero)\n  rw [Gammaâ„_one, div_one] at this\n  refine this.congr' ?_\n  have : {z | 0 < re z} âˆˆ ğ“ (1 : â„‚) := by\n    apply (continuous_re.isOpen_preimage _ isOpen_Ioi).mem_nhds\n    simp only [mem_preimage, one_re, mem_Ioi, zero_lt_one]\n  rw [EventuallyEq, eventually_nhdsWithin_iff]\n  filter_upwards [this] with a ha _\n  rw [Pi.div_apply, â† sub_div, div_right_comm, sub_div' _ _ _ (Gammaâ„_ne_zero_of_re_pos ha),\n    one_mul]\n\n"}
{"name":"ZetaAsymptotics.tendsto_riemannZeta_sub_one_div_Gammaâ„","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"âŠ¢ Filter.Tendsto (fun s => HSub.hSub (riemannZeta s) (HDiv.hDiv (HDiv.hDiv 1 s.Gammaâ„) (HSub.hSub s 1))) (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhds (HDiv.hDiv (HSub.hSub (â†‘Real.eulerMascheroniConstant) (Complex.log (HMul.hMul 4 â†‘Real.pi))) 2))","decl":"lemma tendsto_riemannZeta_sub_one_div_Gammaâ„ :\n    Tendsto (fun s â†¦ riemannZeta s - 1 / Gammaâ„ s / (s - 1)) (ğ“[â‰ ] 1)\n    (ğ“ ((Î³ - Complex.log (4 * â†‘Ï€)) / 2)) := by\n  have := tendsto_riemannZeta_sub_one_div.add tendsto_Gamma_term_aux\n  simp_rw [sub_add_sub_cancel] at this\n  convert this using 2\n  ring_nf\n\n"}
{"name":"riemannZeta_one","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"âŠ¢ Eq (riemannZeta 1) (HDiv.hDiv (HSub.hSub (â†‘Real.eulerMascheroniConstant) (Complex.log (HMul.hMul 4 â†‘Real.pi))) 2)","decl":"/-- Formula for `Î¶ 1`. Note that mathematically `Î¶ 1` is undefined, but our construction ascribes\nthis particular value to it. -/\nlemma _root_.riemannZeta_one : riemannZeta 1 = (Î³ - Complex.log (4 * â†‘Ï€)) / 2 := by\n  have := (HurwitzZeta.tendsto_hurwitzZetaEven_sub_one_div_nhds_one 0).mono_left\n    <| nhdsWithin_le_nhds (s := {1}á¶œ)\n  simp only [HurwitzZeta.hurwitzZetaEven_zero, div_right_comm _ _ (Gammaâ„ _)] at this\n  exact tendsto_nhds_unique this tendsto_riemannZeta_sub_one_div_Gammaâ„\n\n"}
{"name":"completedRiemannZeta_one","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"âŠ¢ Eq (completedRiemannZeta 1) (HDiv.hDiv (HSub.hSub (â†‘Real.eulerMascheroniConstant) (Complex.log (HMul.hMul 4 â†‘Real.pi))) 2)","decl":"/-- Formula for `Î› 1`. Note that mathematically `Î› 1` is undefined, but our construction ascribes\nthis particular value to it. -/\nlemma _root_.completedRiemannZeta_one :\n    completedRiemannZeta 1 = (Î³ - Complex.log (4 * â†‘Ï€)) / 2 :=\n  (riemannZeta_one â–¸ div_one (_ : â„‚) â–¸ Gammaâ„_one â–¸ riemannZeta_def_of_ne_zero one_ne_zero).symm\n\n"}
{"name":"completedRiemannZetaâ‚€_one","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"âŠ¢ Eq (completedRiemannZetaâ‚€ 1) (HAdd.hAdd (HDiv.hDiv (HSub.hSub (â†‘Real.eulerMascheroniConstant) (Complex.log (HMul.hMul 4 â†‘Real.pi))) 2) 1)","decl":"/-- Formula for `Î›â‚€ 1`, where `Î›â‚€` is the entire function satisfying\n`Î›â‚€ s = Ï€ ^ (-s / 2) Î“(s / 2) Î¶(s) + 1 / s + 1 / (1 - s)` away from `s = 0, 1`.\n\nNote that `s = 1` is _not_ a pole of `Î›â‚€`, so this statement (unlike `riemannZeta_one`) is\na mathematically meaningful statement and is not dependent on Mathlib's particular conventions for\ndivision by zero. -/\nlemma _root_.completedRiemannZetaâ‚€_one :\n    completedRiemannZetaâ‚€ 1 = (Î³ - Complex.log (4 * â†‘Ï€)) / 2 + 1 := by\n  have := completedRiemannZeta_eq 1\n  rw [sub_self, div_zero, div_one, sub_zero, eq_sub_iff_add_eq] at this\n  rw [â† this, completedRiemannZeta_one]\n\n"}
{"name":"riemannZeta_one_ne_zero","module":"Mathlib.NumberTheory.Harmonic.ZetaAsymp","initialProofState":"âŠ¢ Ne (riemannZeta 1) 0","decl":"/-- With Mathlib's particular conventions, we have `Î¶ 1 â‰  0`. -/\nlemma _root_.riemannZeta_one_ne_zero : riemannZeta 1 â‰  0 := by\n  -- This one's for you, Kevin.\n  suffices (Î³ - (4 * Ï€).log) / 2 â‰  0 by\n    simpa only [riemannZeta_one, â† ofReal_ne_zero, ofReal_log (by positivity : 0 â‰¤ 4 * Ï€),\n      push_cast]\n  refine div_ne_zero (sub_lt_zero.mpr (lt_trans ?_ ?_ (b := 1))).ne two_ne_zero\n  Â· exact Real.eulerMascheroniConstant_lt_two_thirds.trans (by norm_num)\n  Â· rw [lt_log_iff_exp_lt (by positivity)]\n    exact (lt_trans Real.exp_one_lt_d9 (by norm_num)).trans_le\n      <| mul_le_mul_of_nonneg_left two_le_pi (by norm_num)\n\n"}
