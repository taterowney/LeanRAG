{"name":"Function.IsFixedPt.isPeriodicPt","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nhf : Function.IsFixedPt f x\nn : Nat\n⊢ Function.IsPeriodicPt f n x","decl":"/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem IsFixedPt.isPeriodicPt (hf : IsFixedPt f x) (n : ℕ) : IsPeriodicPt f n x :=\n  hf.iterate n\n\n"}
{"name":"Function.is_periodic_id","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nn : Nat\nx : α\n⊢ Function.IsPeriodicPt id n x","decl":"/-- For the identity map, all points are periodic. -/\ntheorem is_periodic_id (n : ℕ) (x : α) : IsPeriodicPt id n x :=\n  (isFixedPt_id x).isPeriodicPt n\n\n"}
{"name":"Function.isPeriodicPt_zero","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ Function.IsPeriodicPt f 0 x","decl":"/-- Any point is a periodic point of period `0`. -/\ntheorem isPeriodicPt_zero (f : α → α) (x : α) : IsPeriodicPt f 0 x :=\n  isFixedPt_id x\n\n"}
{"name":"Function.IsPeriodicPt.isFixedPt","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\nhf : Function.IsPeriodicPt f n x\n⊢ Function.IsFixedPt (Nat.iterate f n) x","decl":"protected theorem isFixedPt (hf : IsPeriodicPt f n x) : IsFixedPt f^[n] x :=\n  hf\n\n"}
{"name":"Function.IsPeriodicPt.map","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nfa : α → α\nfb : β → β\nx : α\nn : Nat\nhx : Function.IsPeriodicPt fa n x\ng : α → β\nhg : Function.Semiconj g fa fb\n⊢ Function.IsPeriodicPt fb n (g x)","decl":"protected theorem map (hx : IsPeriodicPt fa n x) {g : α → β} (hg : Semiconj g fa fb) :\n    IsPeriodicPt fb n (g x) :=\n  IsFixedPt.map hx (hg.iterate_right n)\n\n"}
{"name":"Function.IsPeriodicPt.apply_iterate","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\nhx : Function.IsPeriodicPt f n x\nm : Nat\n⊢ Function.IsPeriodicPt f n (Nat.iterate f m x)","decl":"theorem apply_iterate (hx : IsPeriodicPt f n x) (m : ℕ) : IsPeriodicPt f n (f^[m] x) :=\n  hx.map <| Commute.iterate_self f m\n\n"}
{"name":"Function.IsPeriodicPt.apply","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\nhx : Function.IsPeriodicPt f n x\n⊢ Function.IsPeriodicPt f n (f x)","decl":"protected theorem apply (hx : IsPeriodicPt f n x) : IsPeriodicPt f n (f x) :=\n  hx.apply_iterate 1\n\n"}
{"name":"Function.IsPeriodicPt.add","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nm n : Nat\nhn : Function.IsPeriodicPt f n x\nhm : Function.IsPeriodicPt f m x\n⊢ Function.IsPeriodicPt f (HAdd.hAdd n m) x","decl":"protected theorem add (hn : IsPeriodicPt f n x) (hm : IsPeriodicPt f m x) :\n    IsPeriodicPt f (n + m) x := by\n  rw [IsPeriodicPt, iterate_add]\n  exact hn.comp hm\n\n"}
{"name":"Function.IsPeriodicPt.left_of_add","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nm n : Nat\nhn : Function.IsPeriodicPt f (HAdd.hAdd n m) x\nhm : Function.IsPeriodicPt f m x\n⊢ Function.IsPeriodicPt f n x","decl":"theorem left_of_add (hn : IsPeriodicPt f (n + m) x) (hm : IsPeriodicPt f m x) :\n    IsPeriodicPt f n x := by\n  rw [IsPeriodicPt, iterate_add] at hn\n  exact hn.left_of_comp hm\n\n"}
{"name":"Function.IsPeriodicPt.right_of_add","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nm n : Nat\nhn : Function.IsPeriodicPt f (HAdd.hAdd n m) x\nhm : Function.IsPeriodicPt f n x\n⊢ Function.IsPeriodicPt f m x","decl":"theorem right_of_add (hn : IsPeriodicPt f (n + m) x) (hm : IsPeriodicPt f n x) :\n    IsPeriodicPt f m x := by\n  rw [add_comm] at hn\n  exact hn.left_of_add hm\n\n"}
{"name":"Function.IsPeriodicPt.sub","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nm n : Nat\nhm : Function.IsPeriodicPt f m x\nhn : Function.IsPeriodicPt f n x\n⊢ Function.IsPeriodicPt f (HSub.hSub m n) x","decl":"protected theorem sub (hm : IsPeriodicPt f m x) (hn : IsPeriodicPt f n x) :\n    IsPeriodicPt f (m - n) x := by\n  rcases le_total n m with h | h\n  · refine left_of_add ?_ hn\n    rwa [tsub_add_cancel_of_le h]\n  · rw [tsub_eq_zero_iff_le.mpr h]\n    apply isPeriodicPt_zero\n\n"}
{"name":"Function.IsPeriodicPt.mul_const","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nm : Nat\nhm : Function.IsPeriodicPt f m x\nn : Nat\n⊢ Function.IsPeriodicPt f (HMul.hMul m n) x","decl":"protected theorem mul_const (hm : IsPeriodicPt f m x) (n : ℕ) : IsPeriodicPt f (m * n) x := by\n  simp only [IsPeriodicPt, iterate_mul, hm.isFixedPt.iterate n]\n\n"}
{"name":"Function.IsPeriodicPt.const_mul","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nm : Nat\nhm : Function.IsPeriodicPt f m x\nn : Nat\n⊢ Function.IsPeriodicPt f (HMul.hMul n m) x","decl":"protected theorem const_mul (hm : IsPeriodicPt f m x) (n : ℕ) : IsPeriodicPt f (n * m) x := by\n  simp only [mul_comm n, hm.mul_const n]\n\n"}
{"name":"Function.IsPeriodicPt.trans_dvd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nm : Nat\nhm : Function.IsPeriodicPt f m x\nn : Nat\nhn : Dvd.dvd m n\n⊢ Function.IsPeriodicPt f n x","decl":"theorem trans_dvd (hm : IsPeriodicPt f m x) {n : ℕ} (hn : m ∣ n) : IsPeriodicPt f n x :=\n  let ⟨k, hk⟩ := hn\n  hk.symm ▸ hm.mul_const k\n\n"}
{"name":"Function.IsPeriodicPt.iterate","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\nhf : Function.IsPeriodicPt f n x\nm : Nat\n⊢ Function.IsPeriodicPt (Nat.iterate f m) n x","decl":"protected theorem iterate (hf : IsPeriodicPt f n x) (m : ℕ) : IsPeriodicPt f^[m] n x := by\n  rw [IsPeriodicPt, ← iterate_mul, mul_comm, iterate_mul]\n  exact hf.isFixedPt.iterate m\n\n"}
{"name":"Function.IsPeriodicPt.comp","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\ng : α → α\nhco : Function.Commute f g\nhf : Function.IsPeriodicPt f n x\nhg : Function.IsPeriodicPt g n x\n⊢ Function.IsPeriodicPt (Function.comp f g) n x","decl":"theorem comp {g : α → α} (hco : Commute f g) (hf : IsPeriodicPt f n x) (hg : IsPeriodicPt g n x) :\n    IsPeriodicPt (f ∘ g) n x := by\n  rw [IsPeriodicPt, hco.comp_iterate]\n  exact IsFixedPt.comp hf hg\n\n"}
{"name":"Function.IsPeriodicPt.comp_lcm","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nm n : Nat\ng : α → α\nhco : Function.Commute f g\nhf : Function.IsPeriodicPt f m x\nhg : Function.IsPeriodicPt g n x\n⊢ Function.IsPeriodicPt (Function.comp f g) (m.lcm n) x","decl":"theorem comp_lcm {g : α → α} (hco : Commute f g) (hf : IsPeriodicPt f m x)\n    (hg : IsPeriodicPt g n x) : IsPeriodicPt (f ∘ g) (Nat.lcm m n) x :=\n  (hf.trans_dvd <| Nat.dvd_lcm_left _ _).comp hco (hg.trans_dvd <| Nat.dvd_lcm_right _ _)\n\n"}
{"name":"Function.IsPeriodicPt.left_of_comp","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\ng : α → α\nhco : Function.Commute f g\nhfg : Function.IsPeriodicPt (Function.comp f g) n x\nhg : Function.IsPeriodicPt g n x\n⊢ Function.IsPeriodicPt f n x","decl":"theorem left_of_comp {g : α → α} (hco : Commute f g) (hfg : IsPeriodicPt (f ∘ g) n x)\n    (hg : IsPeriodicPt g n x) : IsPeriodicPt f n x := by\n  rw [IsPeriodicPt, hco.comp_iterate] at hfg\n  exact hfg.left_of_comp hg\n\n"}
{"name":"Function.IsPeriodicPt.iterate_mod_apply","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\nh : Function.IsPeriodicPt f n x\nm : Nat\n⊢ Eq (Nat.iterate f (HMod.hMod m n) x) (Nat.iterate f m x)","decl":"theorem iterate_mod_apply (h : IsPeriodicPt f n x) (m : ℕ) : f^[m % n] x = f^[m] x := by\n  conv_rhs => rw [← Nat.mod_add_div m n, iterate_add_apply, (h.mul_const _).eq]\n\n"}
{"name":"Function.IsPeriodicPt.mod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nm n : Nat\nhm : Function.IsPeriodicPt f m x\nhn : Function.IsPeriodicPt f n x\n⊢ Function.IsPeriodicPt f (HMod.hMod m n) x","decl":"protected theorem mod (hm : IsPeriodicPt f m x) (hn : IsPeriodicPt f n x) :\n    IsPeriodicPt f (m % n) x :=\n  (hn.iterate_mod_apply m).trans hm\n\n"}
{"name":"Function.IsPeriodicPt.gcd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nm n : Nat\nhm : Function.IsPeriodicPt f m x\nhn : Function.IsPeriodicPt f n x\n⊢ Function.IsPeriodicPt f (m.gcd n) x","decl":"protected theorem gcd (hm : IsPeriodicPt f m x) (hn : IsPeriodicPt f n x) :\n    IsPeriodicPt f (m.gcd n) x := by\n  revert hm hn\n  refine Nat.gcd.induction m n (fun n _ hn => ?_) fun m n _ ih hm hn => ?_\n  · rwa [Nat.gcd_zero_left]\n  · rw [Nat.gcd_rec]\n    exact ih (hn.mod hm) hm\n\n"}
{"name":"Function.IsPeriodicPt.eq_of_apply_eq_same","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx y : α\nn : Nat\nhx : Function.IsPeriodicPt f n x\nhy : Function.IsPeriodicPt f n y\nhn : LT.lt 0 n\nh : Eq (f x) (f y)\n⊢ Eq x y","decl":"/-- If `f` sends two periodic points `x` and `y` of the same positive period to the same point,\nthen `x = y`. For a similar statement about points of different periods see `eq_of_apply_eq`. -/\ntheorem eq_of_apply_eq_same (hx : IsPeriodicPt f n x) (hy : IsPeriodicPt f n y) (hn : 0 < n)\n    (h : f x = f y) : x = y := by\n  rw [← hx.eq, ← hy.eq, ← iterate_pred_comp_of_pos f hn, comp_apply, comp_apply, h]\n\n"}
{"name":"Function.IsPeriodicPt.eq_of_apply_eq","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx y : α\nm n : Nat\nhx : Function.IsPeriodicPt f m x\nhy : Function.IsPeriodicPt f n y\nhm : LT.lt 0 m\nhn : LT.lt 0 n\nh : Eq (f x) (f y)\n⊢ Eq x y","decl":"/-- If `f` sends two periodic points `x` and `y` of positive periods to the same point,\nthen `x = y`. -/\ntheorem eq_of_apply_eq (hx : IsPeriodicPt f m x) (hy : IsPeriodicPt f n y) (hm : 0 < m) (hn : 0 < n)\n    (h : f x = f y) : x = y :=\n  (hx.mul_const n).eq_of_apply_eq_same (hy.const_mul m) (Nat.mul_pos hm hn) h\n\n"}
{"name":"Function.mem_ptsOfPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\n⊢ Iff (Membership.mem (Function.ptsOfPeriod f n) x) (Function.IsPeriodicPt f n x)","decl":"@[simp]\ntheorem mem_ptsOfPeriod : x ∈ ptsOfPeriod f n ↔ IsPeriodicPt f n x :=\n  Iff.rfl\n\n"}
{"name":"Function.Semiconj.mapsTo_ptsOfPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nfa : α → α\nfb : β → β\ng : α → β\nh : Function.Semiconj g fa fb\nn : Nat\n⊢ Set.MapsTo g (Function.ptsOfPeriod fa n) (Function.ptsOfPeriod fb n)","decl":"theorem Semiconj.mapsTo_ptsOfPeriod {g : α → β} (h : Semiconj g fa fb) (n : ℕ) :\n    MapsTo g (ptsOfPeriod fa n) (ptsOfPeriod fb n) :=\n  (h.iterate_right n).mapsTo_fixedPoints\n\n"}
{"name":"Function.bijOn_ptsOfPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nn : Nat\nhn : LT.lt 0 n\n⊢ Set.BijOn f (Function.ptsOfPeriod f n) (Function.ptsOfPeriod f n)","decl":"theorem bijOn_ptsOfPeriod (f : α → α) {n : ℕ} (hn : 0 < n) :\n    BijOn f (ptsOfPeriod f n) (ptsOfPeriod f n) :=\n  ⟨(Commute.refl f).mapsTo_ptsOfPeriod n, fun _ hx _ hy hxy => hx.eq_of_apply_eq_same hy hn hxy,\n    fun x hx =>\n    ⟨f^[n.pred] x, hx.apply_iterate _, by\n      rw [← comp_apply (f := f), comp_iterate_pred_of_pos f hn, hx.eq]⟩⟩\n\n"}
{"name":"Function.mk_mem_periodicPts","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\nhn : LT.lt 0 n\nhx : Function.IsPeriodicPt f n x\n⊢ Membership.mem (Function.periodicPts f) x","decl":"theorem mk_mem_periodicPts (hn : 0 < n) (hx : IsPeriodicPt f n x) : x ∈ periodicPts f :=\n  ⟨n, hn, hx⟩\n\n"}
{"name":"Function.mem_periodicPts","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ Iff (Membership.mem (Function.periodicPts f) x) (Exists fun n => And (GT.gt n 0) (Function.IsPeriodicPt f n x))","decl":"theorem mem_periodicPts : x ∈ periodicPts f ↔ ∃ n > 0, IsPeriodicPt f n x :=\n  Iff.rfl\n\n"}
{"name":"Function.isPeriodicPt_of_mem_periodicPts_of_isPeriodicPt_iterate","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nm n : Nat\nhx : Membership.mem (Function.periodicPts f) x\nhm : Function.IsPeriodicPt f m (Nat.iterate f n x)\n⊢ Function.IsPeriodicPt f m x","decl":"theorem isPeriodicPt_of_mem_periodicPts_of_isPeriodicPt_iterate (hx : x ∈ periodicPts f)\n    (hm : IsPeriodicPt f m (f^[n] x)) : IsPeriodicPt f m x := by\n  rcases hx with ⟨r, hr, hr'⟩\n  suffices n ≤ (n / r + 1) * r by\n    unfold IsPeriodicPt IsFixedPt\n    convert (hm.apply_iterate ((n / r + 1) * r - n)).eq <;>\n      rw [← iterate_add_apply, Nat.sub_add_cancel this, iterate_mul, (hr'.iterate _).eq]\n  rw [Nat.add_mul, one_mul]\n  exact (Nat.lt_div_mul_add hr).le\n\n"}
{"name":"Function.bUnion_ptsOfPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\n⊢ Eq (Set.iUnion fun n => Set.iUnion fun h => Function.ptsOfPeriod f n) (Function.periodicPts f)","decl":"theorem bUnion_ptsOfPeriod : ⋃ n > 0, ptsOfPeriod f n = periodicPts f :=\n  Set.ext fun x => by simp [mem_periodicPts]\n\n"}
{"name":"Function.iUnion_pNat_ptsOfPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\n⊢ Eq (Set.iUnion fun n => Function.ptsOfPeriod f ↑n) (Function.periodicPts f)","decl":"theorem iUnion_pNat_ptsOfPeriod : ⋃ n : ℕ+, ptsOfPeriod f n = periodicPts f :=\n  iSup_subtype.trans <| bUnion_ptsOfPeriod f\n\n"}
{"name":"Function.Semiconj.mapsTo_periodicPts","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nfa : α → α\nfb : β → β\ng : α → β\nh : Function.Semiconj g fa fb\n⊢ Set.MapsTo g (Function.periodicPts fa) (Function.periodicPts fb)","decl":"theorem Semiconj.mapsTo_periodicPts {g : α → β} (h : Semiconj g fa fb) :\n    MapsTo g (periodicPts fa) (periodicPts fb) := fun _ ⟨n, hn, hx⟩ => ⟨n, hn, hx.map h⟩\n\n"}
{"name":"Function.isPeriodicPt_minimalPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ Function.IsPeriodicPt f (Function.minimalPeriod f x) x","decl":"theorem isPeriodicPt_minimalPeriod (f : α → α) (x : α) : IsPeriodicPt f (minimalPeriod f x) x := by\n  classical\n  delta minimalPeriod\n  split_ifs with hx\n  · exact (Nat.find_spec hx).2\n  · exact isPeriodicPt_zero f x\n\n"}
{"name":"Function.iterate_minimalPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ Eq (Nat.iterate f (Function.minimalPeriod f x) x) x","decl":"@[simp]\ntheorem iterate_minimalPeriod : f^[minimalPeriod f x] x = x :=\n  isPeriodicPt_minimalPeriod f x\n\n"}
{"name":"Function.iterate_add_minimalPeriod_eq","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\n⊢ Eq (Nat.iterate f (HAdd.hAdd n (Function.minimalPeriod f x)) x) (Nat.iterate f n x)","decl":"@[simp]\ntheorem iterate_add_minimalPeriod_eq : f^[n + minimalPeriod f x] x = f^[n] x := by\n  rw [iterate_add_apply]\n  congr\n  exact isPeriodicPt_minimalPeriod f x\n\n"}
{"name":"Function.iterate_mod_minimalPeriod_eq","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\n⊢ Eq (Nat.iterate f (HMod.hMod n (Function.minimalPeriod f x)) x) (Nat.iterate f n x)","decl":"@[simp]\ntheorem iterate_mod_minimalPeriod_eq : f^[n % minimalPeriod f x] x = f^[n] x :=\n  (isPeriodicPt_minimalPeriod f x).iterate_mod_apply n\n\n"}
{"name":"Function.minimalPeriod_pos_of_mem_periodicPts","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nhx : Membership.mem (Function.periodicPts f) x\n⊢ LT.lt 0 (Function.minimalPeriod f x)","decl":"theorem minimalPeriod_pos_of_mem_periodicPts (hx : x ∈ periodicPts f) : 0 < minimalPeriod f x := by\n  classical\n  simp only [minimalPeriod, dif_pos hx, (Nat.find_spec hx).1.lt]\n\n"}
{"name":"Function.minimalPeriod_eq_zero_of_nmem_periodicPts","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nhx : Not (Membership.mem (Function.periodicPts f) x)\n⊢ Eq (Function.minimalPeriod f x) 0","decl":"theorem minimalPeriod_eq_zero_of_nmem_periodicPts (hx : x ∉ periodicPts f) :\n    minimalPeriod f x = 0 := by simp only [minimalPeriod, dif_neg hx]\n\n"}
{"name":"Function.IsPeriodicPt.minimalPeriod_pos","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\nhn : LT.lt 0 n\nhx : Function.IsPeriodicPt f n x\n⊢ LT.lt 0 (Function.minimalPeriod f x)","decl":"theorem IsPeriodicPt.minimalPeriod_pos (hn : 0 < n) (hx : IsPeriodicPt f n x) :\n    0 < minimalPeriod f x :=\n  minimalPeriod_pos_of_mem_periodicPts <| mk_mem_periodicPts hn hx\n\n"}
{"name":"Function.minimalPeriod_pos_iff_mem_periodicPts","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ Iff (LT.lt 0 (Function.minimalPeriod f x)) (Membership.mem (Function.periodicPts f) x)","decl":"theorem minimalPeriod_pos_iff_mem_periodicPts : 0 < minimalPeriod f x ↔ x ∈ periodicPts f :=\n  ⟨not_imp_not.1 fun h => by simp only [minimalPeriod, dif_neg h, lt_irrefl 0, not_false_iff],\n    minimalPeriod_pos_of_mem_periodicPts⟩\n\n"}
{"name":"Function.minimalPeriod_eq_zero_iff_nmem_periodicPts","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ Iff (Eq (Function.minimalPeriod f x) 0) (Not (Membership.mem (Function.periodicPts f) x))","decl":"theorem minimalPeriod_eq_zero_iff_nmem_periodicPts : minimalPeriod f x = 0 ↔ x ∉ periodicPts f := by\n  rw [← minimalPeriod_pos_iff_mem_periodicPts, not_lt, nonpos_iff_eq_zero]\n\n"}
{"name":"Function.IsPeriodicPt.minimalPeriod_le","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\nhn : LT.lt 0 n\nhx : Function.IsPeriodicPt f n x\n⊢ LE.le (Function.minimalPeriod f x) n","decl":"theorem IsPeriodicPt.minimalPeriod_le (hn : 0 < n) (hx : IsPeriodicPt f n x) :\n    minimalPeriod f x ≤ n := by\n  classical\n  rw [minimalPeriod, dif_pos (mk_mem_periodicPts hn hx)]\n  exact Nat.find_min' (mk_mem_periodicPts hn hx) ⟨hn, hx⟩\n\n"}
{"name":"Function.minimalPeriod_apply_iterate","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nhx : Membership.mem (Function.periodicPts f) x\nn : Nat\n⊢ Eq (Function.minimalPeriod f (Nat.iterate f n x)) (Function.minimalPeriod f x)","decl":"theorem minimalPeriod_apply_iterate (hx : x ∈ periodicPts f) (n : ℕ) :\n    minimalPeriod f (f^[n] x) = minimalPeriod f x := by\n  apply\n    (IsPeriodicPt.minimalPeriod_le (minimalPeriod_pos_of_mem_periodicPts hx) _).antisymm\n      ((isPeriodicPt_of_mem_periodicPts_of_isPeriodicPt_iterate hx\n            (isPeriodicPt_minimalPeriod f _)).minimalPeriod_le\n        (minimalPeriod_pos_of_mem_periodicPts _))\n  · exact (isPeriodicPt_minimalPeriod f x).apply_iterate n\n  · rcases hx with ⟨m, hm, hx⟩\n    exact ⟨m, hm, hx.apply_iterate n⟩\n\n"}
{"name":"Function.minimalPeriod_apply","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nhx : Membership.mem (Function.periodicPts f) x\n⊢ Eq (Function.minimalPeriod f (f x)) (Function.minimalPeriod f x)","decl":"theorem minimalPeriod_apply (hx : x ∈ periodicPts f) : minimalPeriod f (f x) = minimalPeriod f x :=\n  minimalPeriod_apply_iterate hx 1\n\n"}
{"name":"Function.le_of_lt_minimalPeriod_of_iterate_eq","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nm n : Nat\nhm : LT.lt m (Function.minimalPeriod f x)\nhmn : Eq (Nat.iterate f m x) (Nat.iterate f n x)\n⊢ LE.le m n","decl":"theorem le_of_lt_minimalPeriod_of_iterate_eq {m n : ℕ} (hm : m < minimalPeriod f x)\n    (hmn : f^[m] x = f^[n] x) : m ≤ n := by\n  by_contra! hmn'\n  rw [← Nat.add_sub_of_le hmn'.le, add_comm, iterate_add_apply] at hmn\n  exact\n    ((IsPeriodicPt.minimalPeriod_le (tsub_pos_of_lt hmn')\n              (isPeriodicPt_of_mem_periodicPts_of_isPeriodicPt_iterate\n                (minimalPeriod_pos_iff_mem_periodicPts.1 ((zero_le m).trans_lt hm)) hmn)).trans\n          (Nat.sub_le m n)).not_lt\n      hm\n\n"}
{"name":"Function.iterate_injOn_Iio_minimalPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ Set.InjOn (fun x_1 => Nat.iterate f x_1 x) (Set.Iio (Function.minimalPeriod f x))","decl":"theorem iterate_injOn_Iio_minimalPeriod : (Iio <| minimalPeriod f x).InjOn (f^[·] x) :=\n  fun _m hm _n hn hmn ↦ (le_of_lt_minimalPeriod_of_iterate_eq hm hmn).antisymm\n    (le_of_lt_minimalPeriod_of_iterate_eq hn hmn.symm)\n\n"}
{"name":"Function.iterate_eq_iterate_iff_of_lt_minimalPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nm n : Nat\nhm : LT.lt m (Function.minimalPeriod f x)\nhn : LT.lt n (Function.minimalPeriod f x)\n⊢ Iff (Eq (Nat.iterate f m x) (Nat.iterate f n x)) (Eq m n)","decl":"theorem iterate_eq_iterate_iff_of_lt_minimalPeriod {m n : ℕ} (hm : m < minimalPeriod f x)\n    (hn : n < minimalPeriod f x) : f^[m] x = f^[n] x ↔ m = n :=\n  iterate_injOn_Iio_minimalPeriod.eq_iff hm hn\n\n"}
{"name":"Function.minimalPeriod_id","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nx : α\n⊢ Eq (Function.minimalPeriod id x) 1","decl":"@[simp] theorem minimalPeriod_id : minimalPeriod id x = 1 :=\n  ((is_periodic_id _ _).minimalPeriod_le Nat.one_pos).antisymm\n    (Nat.succ_le_of_lt ((is_periodic_id _ _).minimalPeriod_pos Nat.one_pos))\n\n"}
{"name":"Function.minimalPeriod_eq_one_iff_isFixedPt","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ Iff (Eq (Function.minimalPeriod f x) 1) (Function.IsFixedPt f x)","decl":"theorem minimalPeriod_eq_one_iff_isFixedPt : minimalPeriod f x = 1 ↔ IsFixedPt f x := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rw [← iterate_one f]\n    refine Function.IsPeriodicPt.isFixedPt ?_\n    rw [← h]\n    exact isPeriodicPt_minimalPeriod f x\n  · exact\n      ((h.isPeriodicPt 1).minimalPeriod_le Nat.one_pos).antisymm\n        (Nat.succ_le_of_lt ((h.isPeriodicPt 1).minimalPeriod_pos Nat.one_pos))\n\n"}
{"name":"Function.IsPeriodicPt.eq_zero_of_lt_minimalPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\nhx : Function.IsPeriodicPt f n x\nhn : LT.lt n (Function.minimalPeriod f x)\n⊢ Eq n 0","decl":"theorem IsPeriodicPt.eq_zero_of_lt_minimalPeriod (hx : IsPeriodicPt f n x)\n    (hn : n < minimalPeriod f x) : n = 0 :=\n  Eq.symm <|\n    (eq_or_lt_of_le <| n.zero_le).resolve_right fun hn0 => not_lt.2 (hx.minimalPeriod_le hn0) hn\n\n"}
{"name":"Function.not_isPeriodicPt_of_pos_of_lt_minimalPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\nx✝¹ : Ne n 0\nx✝ : LT.lt n (Function.minimalPeriod f x)\n⊢ Not (Function.IsPeriodicPt f n x)","decl":"theorem not_isPeriodicPt_of_pos_of_lt_minimalPeriod :\n    ∀ {n : ℕ} (_ : n ≠ 0) (_ : n < minimalPeriod f x), ¬IsPeriodicPt f n x\n  | 0, n0, _ => (n0 rfl).elim\n  | _ + 1, _, hn => fun hp => Nat.succ_ne_zero _ (hp.eq_zero_of_lt_minimalPeriod hn)\n\n"}
{"name":"Function.IsPeriodicPt.minimalPeriod_dvd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\nhx : Function.IsPeriodicPt f n x\n⊢ Dvd.dvd (Function.minimalPeriod f x) n","decl":"theorem IsPeriodicPt.minimalPeriod_dvd (hx : IsPeriodicPt f n x) : minimalPeriod f x ∣ n :=\n  (eq_or_lt_of_le <| n.zero_le).elim (fun hn0 => hn0 ▸ Nat.dvd_zero _) fun hn0 =>\n    Nat.dvd_iff_mod_eq_zero.2 <|\n      (hx.mod <| isPeriodicPt_minimalPeriod f x).eq_zero_of_lt_minimalPeriod <|\n        Nat.mod_lt _ <| hx.minimalPeriod_pos hn0\n\n"}
{"name":"Function.isPeriodicPt_iff_minimalPeriod_dvd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\n⊢ Iff (Function.IsPeriodicPt f n x) (Dvd.dvd (Function.minimalPeriod f x) n)","decl":"theorem isPeriodicPt_iff_minimalPeriod_dvd : IsPeriodicPt f n x ↔ minimalPeriod f x ∣ n :=\n  ⟨IsPeriodicPt.minimalPeriod_dvd, fun h => (isPeriodicPt_minimalPeriod f x).trans_dvd h⟩\n\n"}
{"name":"Function.minimalPeriod_eq_minimalPeriod_iff","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → α\nx : α\ng : β → β\ny : β\n⊢ Iff (Eq (Function.minimalPeriod f x) (Function.minimalPeriod g y)) (∀ (n : Nat), Iff (Function.IsPeriodicPt f n x) (Function.IsPeriodicPt g n y))","decl":"theorem minimalPeriod_eq_minimalPeriod_iff {g : β → β} {y : β} :\n    minimalPeriod f x = minimalPeriod g y ↔ ∀ n, IsPeriodicPt f n x ↔ IsPeriodicPt g n y := by\n  simp_rw [isPeriodicPt_iff_minimalPeriod_dvd, dvd_right_iff_eq]\n\n"}
{"name":"Function.Commute.minimalPeriod_of_comp_dvd_lcm","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\ng : α → α\nh : Function.Commute f g\n⊢ Dvd.dvd (Function.minimalPeriod (Function.comp f g) x) ((Function.minimalPeriod f x).lcm (Function.minimalPeriod g x))","decl":"theorem Commute.minimalPeriod_of_comp_dvd_lcm {g : α → α} (h : Commute f g) :\n    minimalPeriod (f ∘ g) x ∣ Nat.lcm (minimalPeriod f x) (minimalPeriod g x) := by\n  rw [← isPeriodicPt_iff_minimalPeriod_dvd]\n  exact (isPeriodicPt_minimalPeriod f x).comp_lcm h (isPeriodicPt_minimalPeriod g x)\n\n"}
{"name":"Function.minimalPeriod_iterate_eq_div_gcd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\nh : Ne n 0\n⊢ Eq (Function.minimalPeriod (Nat.iterate f n) x) (HDiv.hDiv (Function.minimalPeriod f x) ((Function.minimalPeriod f x).gcd n))","decl":"theorem minimalPeriod_iterate_eq_div_gcd (h : n ≠ 0) :\n    minimalPeriod f^[n] x = minimalPeriod f x / Nat.gcd (minimalPeriod f x) n :=\n  minimalPeriod_iterate_eq_div_gcd_aux <| gcd_pos_of_pos_right _ (Nat.pos_of_ne_zero h)\n\n"}
{"name":"Function.minimalPeriod_iterate_eq_div_gcd'","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nn : Nat\nh : Membership.mem (Function.periodicPts f) x\n⊢ Eq (Function.minimalPeriod (Nat.iterate f n) x) (HDiv.hDiv (Function.minimalPeriod f x) ((Function.minimalPeriod f x).gcd n))","decl":"theorem minimalPeriod_iterate_eq_div_gcd' (h : x ∈ periodicPts f) :\n    minimalPeriod f^[n] x = minimalPeriod f x / Nat.gcd (minimalPeriod f x) n :=\n  minimalPeriod_iterate_eq_div_gcd_aux <|\n    gcd_pos_of_pos_left n (minimalPeriod_pos_iff_mem_periodicPts.mpr h)\n\n"}
{"name":"Function.periodicOrbit_def","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ Eq (Function.periodicOrbit f x) ↑(List.map (fun n => Nat.iterate f n x) (List.range (Function.minimalPeriod f x)))","decl":"/-- The definition of a periodic orbit, in terms of `List.map`. -/\ntheorem periodicOrbit_def (f : α → α) (x : α) :\n    periodicOrbit f x = (List.range (minimalPeriod f x)).map fun n => f^[n] x :=\n  rfl\n\n"}
{"name":"Function.periodicOrbit_eq_cycle_map","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ Eq (Function.periodicOrbit f x) (Cycle.map (fun n => Nat.iterate f n x) ↑(List.range (Function.minimalPeriod f x)))","decl":"/-- The definition of a periodic orbit, in terms of `Cycle.map`. -/\ntheorem periodicOrbit_eq_cycle_map (f : α → α) (x : α) :\n    periodicOrbit f x = (List.range (minimalPeriod f x) : Cycle ℕ).map fun n => f^[n] x :=\n  rfl\n\n"}
{"name":"Function.periodicOrbit_length","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ Eq (Function.periodicOrbit f x).length (Function.minimalPeriod f x)","decl":"@[simp]\ntheorem periodicOrbit_length : (periodicOrbit f x).length = minimalPeriod f x := by\n  rw [periodicOrbit, Cycle.length_coe, List.length_map, List.length_range]\n\n"}
{"name":"Function.periodicOrbit_eq_nil_iff_not_periodic_pt","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ Iff (Eq (Function.periodicOrbit f x) Cycle.nil) (Not (Membership.mem (Function.periodicPts f) x))","decl":"@[simp]\ntheorem periodicOrbit_eq_nil_iff_not_periodic_pt :\n    periodicOrbit f x = Cycle.nil ↔ x ∉ periodicPts f := by\n  simp only [periodicOrbit.eq_1, Cycle.coe_eq_nil, List.map_eq_nil_iff, List.range_eq_nil]\n  exact minimalPeriod_eq_zero_iff_nmem_periodicPts\n\n"}
{"name":"Function.periodicOrbit_eq_nil_of_not_periodic_pt","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nh : Not (Membership.mem (Function.periodicPts f) x)\n⊢ Eq (Function.periodicOrbit f x) Cycle.nil","decl":"theorem periodicOrbit_eq_nil_of_not_periodic_pt (h : x ∉ periodicPts f) :\n    periodicOrbit f x = Cycle.nil :=\n  periodicOrbit_eq_nil_iff_not_periodic_pt.2 h\n\n"}
{"name":"Function.mem_periodicOrbit_iff","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx y : α\nhx : Membership.mem (Function.periodicPts f) x\n⊢ Iff (Membership.mem (Function.periodicOrbit f x) y) (Exists fun n => Eq (Nat.iterate f n x) y)","decl":"@[simp]\ntheorem mem_periodicOrbit_iff (hx : x ∈ periodicPts f) :\n    y ∈ periodicOrbit f x ↔ ∃ n, f^[n] x = y := by\n  simp only [periodicOrbit, Cycle.mem_coe_iff, List.mem_map, List.mem_range]\n  use fun ⟨a, _, ha'⟩ => ⟨a, ha'⟩\n  rintro ⟨n, rfl⟩\n  use n % minimalPeriod f x, mod_lt _ (minimalPeriod_pos_of_mem_periodicPts hx)\n  rw [iterate_mod_minimalPeriod_eq]\n\n"}
{"name":"Function.iterate_mem_periodicOrbit","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nhx : Membership.mem (Function.periodicPts f) x\nn : Nat\n⊢ Membership.mem (Function.periodicOrbit f x) (Nat.iterate f n x)","decl":"@[simp]\ntheorem iterate_mem_periodicOrbit (hx : x ∈ periodicPts f) (n : ℕ) :\n    f^[n] x ∈ periodicOrbit f x :=\n  (mem_periodicOrbit_iff hx).2 ⟨n, rfl⟩\n\n"}
{"name":"Function.self_mem_periodicOrbit","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nhx : Membership.mem (Function.periodicPts f) x\n⊢ Membership.mem (Function.periodicOrbit f x) x","decl":"@[simp]\ntheorem self_mem_periodicOrbit (hx : x ∈ periodicPts f) : x ∈ periodicOrbit f x :=\n  iterate_mem_periodicOrbit hx 0\n\n"}
{"name":"Function.nodup_periodicOrbit","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ (Function.periodicOrbit f x).Nodup","decl":"theorem nodup_periodicOrbit : (periodicOrbit f x).Nodup := by\n  rw [periodicOrbit, Cycle.nodup_coe_iff, List.nodup_map_iff_inj_on (List.nodup_range _)]\n  intro m hm n hn hmn\n  rw [List.mem_range] at hm hn\n  rwa [iterate_eq_iterate_iff_of_lt_minimalPeriod hm hn] at hmn\n\n"}
{"name":"Function.periodicOrbit_apply_iterate_eq","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nhx : Membership.mem (Function.periodicPts f) x\nn : Nat\n⊢ Eq (Function.periodicOrbit f (Nat.iterate f n x)) (Function.periodicOrbit f x)","decl":"theorem periodicOrbit_apply_iterate_eq (hx : x ∈ periodicPts f) (n : ℕ) :\n    periodicOrbit f (f^[n] x) = periodicOrbit f x :=\n  Eq.symm <| Cycle.coe_eq_coe.2 <| .intro n <|\n    List.ext_get (by simp [minimalPeriod_apply_iterate hx]) fun m _ _ ↦ by\n      simp [List.getElem_rotate, iterate_add_apply]\n\n"}
{"name":"Function.periodicOrbit_apply_eq","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nf : α → α\nx : α\nhx : Membership.mem (Function.periodicPts f) x\n⊢ Eq (Function.periodicOrbit f (f x)) (Function.periodicOrbit f x)","decl":"theorem periodicOrbit_apply_eq (hx : x ∈ periodicPts f) :\n    periodicOrbit f (f x) = periodicOrbit f x :=\n  periodicOrbit_apply_iterate_eq hx 1\n\n"}
{"name":"Function.periodicOrbit_chain","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nr : α → α → Prop\nf : α → α\nx : α\n⊢ Iff (Cycle.Chain r (Function.periodicOrbit f x)) (∀ (n : Nat), LT.lt n (Function.minimalPeriod f x) → r (Nat.iterate f n x) (Nat.iterate f (HAdd.hAdd n 1) x))","decl":"theorem periodicOrbit_chain (r : α → α → Prop) {f : α → α} {x : α} :\n    (periodicOrbit f x).Chain r ↔ ∀ n < minimalPeriod f x, r (f^[n] x) (f^[n + 1] x) := by\n  by_cases hx : x ∈ periodicPts f\n  · have hx' := minimalPeriod_pos_of_mem_periodicPts hx\n    have hM := Nat.sub_add_cancel (succ_le_iff.2 hx')\n    rw [periodicOrbit, ← Cycle.map_coe, Cycle.chain_map, ← hM, Cycle.chain_range_succ]\n    refine ⟨?_, fun H => ⟨?_, fun m hm => H _ (hm.trans (Nat.lt_succ_self _))⟩⟩\n    · rintro ⟨hr, H⟩ n hn\n      cases' eq_or_lt_of_le (Nat.lt_succ_iff.1 hn) with hM' hM'\n      · rwa [hM', hM, iterate_minimalPeriod]\n      · exact H _ hM'\n    · rw [iterate_zero_apply]\n      nth_rw 3 [← @iterate_minimalPeriod α f x]\n      nth_rw 2 [← hM]\n      exact H _ (Nat.lt_succ_self _)\n  · rw [periodicOrbit_eq_nil_of_not_periodic_pt hx, minimalPeriod_eq_zero_of_nmem_periodicPts hx]\n    simp\n\n"}
{"name":"Function.periodicOrbit_chain'","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nr : α → α → Prop\nf : α → α\nx : α\nhx : Membership.mem (Function.periodicPts f) x\n⊢ Iff (Cycle.Chain r (Function.periodicOrbit f x)) (∀ (n : Nat), r (Nat.iterate f n x) (Nat.iterate f (HAdd.hAdd n 1) x))","decl":"theorem periodicOrbit_chain' (r : α → α → Prop) {f : α → α} {x : α} (hx : x ∈ periodicPts f) :\n    (periodicOrbit f x).Chain r ↔ ∀ n, r (f^[n] x) (f^[n + 1] x) := by\n  rw [periodicOrbit_chain r]\n  refine ⟨fun H n => ?_, fun H n _ => H n⟩\n  rw [iterate_succ_apply, ← iterate_mod_minimalPeriod_eq, ← iterate_mod_minimalPeriod_eq (n := n),\n    ← iterate_succ_apply, minimalPeriod_apply hx]\n  exact H _ (mod_lt _ (minimalPeriod_pos_of_mem_periodicPts hx))\n\n"}
{"name":"Function.isFixedPt_prod_map","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → α\ng : β → β\nx : Prod α β\n⊢ Iff (Function.IsFixedPt (Prod.map f g) x) (And (Function.IsFixedPt f x.1) (Function.IsFixedPt g x.2))","decl":"@[simp]\ntheorem isFixedPt_prod_map (x : α × β) :\n    IsFixedPt (Prod.map f g) x ↔ IsFixedPt f x.1 ∧ IsFixedPt g x.2 :=\n  Prod.ext_iff\n\n"}
{"name":"Function.isPeriodicPt_prod_map","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → α\ng : β → β\nn : Nat\nx : Prod α β\n⊢ Iff (Function.IsPeriodicPt (Prod.map f g) n x) (And (Function.IsPeriodicPt f n x.1) (Function.IsPeriodicPt g n x.2))","decl":"@[simp]\ntheorem isPeriodicPt_prod_map (x : α × β) :\n    IsPeriodicPt (Prod.map f g) n x ↔ IsPeriodicPt f n x.1 ∧ IsPeriodicPt g n x.2 := by\n  simp [IsPeriodicPt]\n\n"}
{"name":"AddAction.period_eq_minimalPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nm : M\na : α\n⊢ Eq (AddAction.period m a) (Function.minimalPeriod (fun x => HVAdd.hVAdd m x) a)","decl":"/-- `MulAction.period m a` is definitionally equal to `Function.minimalPeriod (m • ·) a`. -/\n@[to_additive \"`AddAction.period m a` is definitionally equal to\n`Function.minimalPeriod (m +ᵥ ·) a`\"]\ntheorem period_eq_minimalPeriod {m : M} {a : α} :\n    MulAction.period m a = minimalPeriod (fun x => m • x) a := rfl\n\n"}
{"name":"MulAction.period_eq_minimalPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nm : M\na : α\n⊢ Eq (MulAction.period m a) (Function.minimalPeriod (fun x => HSMul.hSMul m x) a)","decl":"/-- `MulAction.period m a` is definitionally equal to `Function.minimalPeriod (m • ·) a`. -/\n@[to_additive \"`AddAction.period m a` is definitionally equal to\n`Function.minimalPeriod (m +ᵥ ·) a`\"]\ntheorem period_eq_minimalPeriod {m : M} {a : α} :\n    MulAction.period m a = minimalPeriod (fun x => m • x) a := rfl\n\n"}
{"name":"MulAction.pow_period_smul","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nm : M\na : α\n⊢ Eq (HSMul.hSMul (HPow.hPow m (MulAction.period m a)) a) a","decl":"/-- `m ^ (period m a)` fixes `a`. -/\n@[to_additive (attr := simp) \"`(period m a) • m` fixes `a`.\"]\ntheorem pow_period_smul (m : M) (a : α) : m ^ (period m a) • a = a := by\n  rw [period_eq_minimalPeriod, ← smul_iterate_apply, iterate_minimalPeriod]\n\n"}
{"name":"AddAction.nsmul_period_vadd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nm : M\na : α\n⊢ Eq (HVAdd.hVAdd (HSMul.hSMul (AddAction.period m a) m) a) a","decl":"/-- `m ^ (period m a)` fixes `a`. -/\n@[to_additive (attr := simp) \"`(period m a) • m` fixes `a`.\"]\ntheorem pow_period_smul (m : M) (a : α) : m ^ (period m a) • a = a := by\n  rw [period_eq_minimalPeriod, ← smul_iterate_apply, iterate_minimalPeriod]\n\n"}
{"name":"MulAction.isPeriodicPt_smul_iff","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nm : M\na : α\nn : Nat\n⊢ Iff (Function.IsPeriodicPt (fun x => HSMul.hSMul m x) n a) (Eq (HSMul.hSMul (HPow.hPow m n) a) a)","decl":"@[to_additive]\nlemma isPeriodicPt_smul_iff {m : M} {a : α} {n : ℕ} :\n    IsPeriodicPt (m • ·) n a ↔ m ^ n • a = a := by\n  rw [← smul_iterate_apply, IsPeriodicPt, IsFixedPt]\n\n"}
{"name":"AddAction.isPeriodicPt_vadd_iff","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nm : M\na : α\nn : Nat\n⊢ Iff (Function.IsPeriodicPt (fun x => HVAdd.hVAdd m x) n a) (Eq (HVAdd.hVAdd (HSMul.hSMul n m) a) a)","decl":"@[to_additive]\nlemma isPeriodicPt_smul_iff {m : M} {a : α} {n : ℕ} :\n    IsPeriodicPt (m • ·) n a ↔ m ^ n • a = a := by\n  rw [← smul_iterate_apply, IsPeriodicPt, IsFixedPt]\n\n"}
{"name":"AddAction.nsmul_vadd_eq_iff_period_dvd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nn : Nat\nm : M\na : α\n⊢ Iff (Eq (HVAdd.hVAdd (HSMul.hSMul n m) a) a) (Dvd.dvd (AddAction.period m a) n)","decl":"@[to_additive]\ntheorem pow_smul_eq_iff_period_dvd {n : ℕ} {m : M} {a : α} :\n    m ^ n • a = a ↔ period m a ∣ n := by\n  rw [period_eq_minimalPeriod, ← isPeriodicPt_iff_minimalPeriod_dvd, isPeriodicPt_smul_iff]\n\n"}
{"name":"MulAction.pow_smul_eq_iff_period_dvd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nn : Nat\nm : M\na : α\n⊢ Iff (Eq (HSMul.hSMul (HPow.hPow m n) a) a) (Dvd.dvd (MulAction.period m a) n)","decl":"@[to_additive]\ntheorem pow_smul_eq_iff_period_dvd {n : ℕ} {m : M} {a : α} :\n    m ^ n • a = a ↔ period m a ∣ n := by\n  rw [period_eq_minimalPeriod, ← isPeriodicPt_iff_minimalPeriod_dvd, isPeriodicPt_smul_iff]\n\n"}
{"name":"AddAction.zsmul_vadd_eq_iff_period_dvd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nj : Int\ng : G\na : α\n⊢ Iff (Eq (HVAdd.hVAdd (HSMul.hSMul j g) a) a) (Dvd.dvd (↑(AddAction.period g a)) j)","decl":"@[to_additive]\ntheorem zpow_smul_eq_iff_period_dvd {j : ℤ} {g : G} {a : α} :\n    g ^ j • a = a ↔ (period g a : ℤ) ∣ j := by\n  rcases j with n | n\n  · rw [Int.ofNat_eq_coe, zpow_natCast, Int.natCast_dvd_natCast, pow_smul_eq_iff_period_dvd]\n  · rw [Int.negSucc_coe, zpow_neg, zpow_natCast, inv_smul_eq_iff, eq_comm, Int.dvd_neg,\n      Int.natCast_dvd_natCast, pow_smul_eq_iff_period_dvd]\n\n"}
{"name":"MulAction.zpow_smul_eq_iff_period_dvd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : Group G\ninst✝ : MulAction G α\nj : Int\ng : G\na : α\n⊢ Iff (Eq (HSMul.hSMul (HPow.hPow g j) a) a) (Dvd.dvd (↑(MulAction.period g a)) j)","decl":"@[to_additive]\ntheorem zpow_smul_eq_iff_period_dvd {j : ℤ} {g : G} {a : α} :\n    g ^ j • a = a ↔ (period g a : ℤ) ∣ j := by\n  rcases j with n | n\n  · rw [Int.ofNat_eq_coe, zpow_natCast, Int.natCast_dvd_natCast, pow_smul_eq_iff_period_dvd]\n  · rw [Int.negSucc_coe, zpow_neg, zpow_natCast, inv_smul_eq_iff, eq_comm, Int.dvd_neg,\n      Int.natCast_dvd_natCast, pow_smul_eq_iff_period_dvd]\n\n"}
{"name":"MulAction.pow_mod_period_smul","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nn : Nat\nm : M\na : α\n⊢ Eq (HSMul.hSMul (HPow.hPow m (HMod.hMod n (MulAction.period m a))) a) (HSMul.hSMul (HPow.hPow m n) a)","decl":"@[to_additive (attr := simp)]\ntheorem pow_mod_period_smul (n : ℕ) {m : M} {a : α} :\n    m ^ (n % period m a) • a = m ^ n • a := by\n  conv_rhs => rw [← Nat.mod_add_div n (period m a), pow_add, mul_smul,\n    pow_smul_eq_iff_period_dvd.mpr (dvd_mul_right _ _)]\n\n"}
{"name":"AddAction.nsmul_mod_period_vadd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nn : Nat\nm : M\na : α\n⊢ Eq (HVAdd.hVAdd (HSMul.hSMul (HMod.hMod n (AddAction.period m a)) m) a) (HVAdd.hVAdd (HSMul.hSMul n m) a)","decl":"@[to_additive (attr := simp)]\ntheorem pow_mod_period_smul (n : ℕ) {m : M} {a : α} :\n    m ^ (n % period m a) • a = m ^ n • a := by\n  conv_rhs => rw [← Nat.mod_add_div n (period m a), pow_add, mul_smul,\n    pow_smul_eq_iff_period_dvd.mpr (dvd_mul_right _ _)]\n\n"}
{"name":"MulAction.zpow_mod_period_smul","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : Group G\ninst✝ : MulAction G α\nj : Int\ng : G\na : α\n⊢ Eq (HSMul.hSMul (HPow.hPow g (HMod.hMod j ↑(MulAction.period g a))) a) (HSMul.hSMul (HPow.hPow g j) a)","decl":"@[to_additive (attr := simp)]\ntheorem zpow_mod_period_smul (j : ℤ) {g : G} {a : α} :\n    g ^ (j % (period g a : ℤ)) • a = g ^ j • a := by\n  conv_rhs => rw [← Int.emod_add_ediv j (period g a), zpow_add, mul_smul,\n    zpow_smul_eq_iff_period_dvd.mpr (dvd_mul_right _ _)]\n\n"}
{"name":"AddAction.zsmul_mod_period_vadd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nj : Int\ng : G\na : α\n⊢ Eq (HVAdd.hVAdd (HSMul.hSMul (HMod.hMod j ↑(AddAction.period g a)) g) a) (HVAdd.hVAdd (HSMul.hSMul j g) a)","decl":"@[to_additive (attr := simp)]\ntheorem zpow_mod_period_smul (j : ℤ) {g : G} {a : α} :\n    g ^ (j % (period g a : ℤ)) • a = g ^ j • a := by\n  conv_rhs => rw [← Int.emod_add_ediv j (period g a), zpow_add, mul_smul,\n    zpow_smul_eq_iff_period_dvd.mpr (dvd_mul_right _ _)]\n\n"}
{"name":"AddAction.nsmul_add_period_vadd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nn : Nat\nm : M\na : α\n⊢ Eq (HVAdd.hVAdd (HSMul.hSMul (HAdd.hAdd n (AddAction.period m a)) m) a) (HVAdd.hVAdd (HSMul.hSMul n m) a)","decl":"@[to_additive (attr := simp)]\ntheorem pow_add_period_smul (n : ℕ) (m : M) (a : α) :\n    m ^ (n + period m a) • a = m ^ n • a := by\n  rw [← pow_mod_period_smul, Nat.add_mod_right, pow_mod_period_smul]\n\n"}
{"name":"MulAction.pow_add_period_smul","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nn : Nat\nm : M\na : α\n⊢ Eq (HSMul.hSMul (HPow.hPow m (HAdd.hAdd n (MulAction.period m a))) a) (HSMul.hSMul (HPow.hPow m n) a)","decl":"@[to_additive (attr := simp)]\ntheorem pow_add_period_smul (n : ℕ) (m : M) (a : α) :\n    m ^ (n + period m a) • a = m ^ n • a := by\n  rw [← pow_mod_period_smul, Nat.add_mod_right, pow_mod_period_smul]\n\n"}
{"name":"MulAction.pow_period_add_smul","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nn : Nat\nm : M\na : α\n⊢ Eq (HSMul.hSMul (HPow.hPow m (HAdd.hAdd (MulAction.period m a) n)) a) (HSMul.hSMul (HPow.hPow m n) a)","decl":"@[to_additive (attr := simp)]\ntheorem pow_period_add_smul (n : ℕ) (m : M) (a : α) :\n    m ^ (period m a + n) • a = m ^ n • a := by\n  rw [← pow_mod_period_smul, Nat.add_mod_left, pow_mod_period_smul]\n\n"}
{"name":"AddAction.nsmul_period_add_vadd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nM : Type u\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nn : Nat\nm : M\na : α\n⊢ Eq (HVAdd.hVAdd (HSMul.hSMul (HAdd.hAdd (AddAction.period m a) n) m) a) (HVAdd.hVAdd (HSMul.hSMul n m) a)","decl":"@[to_additive (attr := simp)]\ntheorem pow_period_add_smul (n : ℕ) (m : M) (a : α) :\n    m ^ (period m a + n) • a = m ^ n • a := by\n  rw [← pow_mod_period_smul, Nat.add_mod_left, pow_mod_period_smul]\n\n"}
{"name":"MulAction.zpow_add_period_smul","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : Group G\ninst✝ : MulAction G α\ni : Int\ng : G\na : α\n⊢ Eq (HSMul.hSMul (HPow.hPow g (HAdd.hAdd i ↑(MulAction.period g a))) a) (HSMul.hSMul (HPow.hPow g i) a)","decl":"@[to_additive (attr := simp)]\ntheorem zpow_add_period_smul (i : ℤ) (g : G) (a : α) :\n    g ^ (i + period g a) • a = g ^ i • a := by\n  rw [← zpow_mod_period_smul, Int.add_emod_self, zpow_mod_period_smul]\n\n"}
{"name":"AddAction.zsmul_add_period_vadd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ni : Int\ng : G\na : α\n⊢ Eq (HVAdd.hVAdd (HSMul.hSMul (HAdd.hAdd i ↑(AddAction.period g a)) g) a) (HVAdd.hVAdd (HSMul.hSMul i g) a)","decl":"@[to_additive (attr := simp)]\ntheorem zpow_add_period_smul (i : ℤ) (g : G) (a : α) :\n    g ^ (i + period g a) • a = g ^ i • a := by\n  rw [← zpow_mod_period_smul, Int.add_emod_self, zpow_mod_period_smul]\n\n"}
{"name":"AddAction.zsmul_period_add_vadd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ni : Int\ng : G\na : α\n⊢ Eq (HVAdd.hVAdd (HSMul.hSMul (HAdd.hAdd (↑(AddAction.period g a)) i) g) a) (HVAdd.hVAdd (HSMul.hSMul i g) a)","decl":"@[to_additive (attr := simp)]\ntheorem zpow_period_add_smul (i : ℤ) (g : G) (a : α) :\n    g ^ (period g a + i) • a = g ^ i • a := by\n  rw [← zpow_mod_period_smul, Int.add_emod_self_left, zpow_mod_period_smul]\n\n"}
{"name":"MulAction.zpow_period_add_smul","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : Group G\ninst✝ : MulAction G α\ni : Int\ng : G\na : α\n⊢ Eq (HSMul.hSMul (HPow.hPow g (HAdd.hAdd (↑(MulAction.period g a)) i)) a) (HSMul.hSMul (HPow.hPow g i) a)","decl":"@[to_additive (attr := simp)]\ntheorem zpow_period_add_smul (i : ℤ) (g : G) (a : α) :\n    g ^ (period g a + i) • a = g ^ i • a := by\n  rw [← zpow_mod_period_smul, Int.add_emod_self_left, zpow_mod_period_smul]\n\n"}
{"name":"MulAction.pow_smul_eq_iff_minimalPeriod_dvd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : G\nb : α\nn : Nat\n⊢ Iff (Eq (HSMul.hSMul (HPow.hPow a n) b) b) (Dvd.dvd (Function.minimalPeriod (fun x => HSMul.hSMul a x) b) n)","decl":"@[to_additive]\ntheorem pow_smul_eq_iff_minimalPeriod_dvd {n : ℕ} :\n    a ^ n • b = b ↔ minimalPeriod (a • ·) b ∣ n := by\n  rw [← period_eq_minimalPeriod, pow_smul_eq_iff_period_dvd]\n\n"}
{"name":"AddAction.nsmul_vadd_eq_iff_minimalPeriod_dvd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : G\nb : α\nn : Nat\n⊢ Iff (Eq (HVAdd.hVAdd (HSMul.hSMul n a) b) b) (Dvd.dvd (Function.minimalPeriod (fun x => HVAdd.hVAdd a x) b) n)","decl":"@[to_additive]\ntheorem pow_smul_eq_iff_minimalPeriod_dvd {n : ℕ} :\n    a ^ n • b = b ↔ minimalPeriod (a • ·) b ∣ n := by\n  rw [← period_eq_minimalPeriod, pow_smul_eq_iff_period_dvd]\n\n"}
{"name":"MulAction.zpow_smul_eq_iff_minimalPeriod_dvd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : G\nb : α\nn : Int\n⊢ Iff (Eq (HSMul.hSMul (HPow.hPow a n) b) b) (Dvd.dvd (↑(Function.minimalPeriod (fun x => HSMul.hSMul a x) b)) n)","decl":"@[to_additive]\ntheorem zpow_smul_eq_iff_minimalPeriod_dvd {n : ℤ} :\n    a ^ n • b = b ↔ (minimalPeriod (a • ·) b : ℤ) ∣ n := by\n  rw [← period_eq_minimalPeriod, zpow_smul_eq_iff_period_dvd]\n\n"}
{"name":"AddAction.zsmul_vadd_eq_iff_minimalPeriod_dvd","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : G\nb : α\nn : Int\n⊢ Iff (Eq (HVAdd.hVAdd (HSMul.hSMul n a) b) b) (Dvd.dvd (↑(Function.minimalPeriod (fun x => HVAdd.hVAdd a x) b)) n)","decl":"@[to_additive]\ntheorem zpow_smul_eq_iff_minimalPeriod_dvd {n : ℤ} :\n    a ^ n • b = b ↔ (minimalPeriod (a • ·) b : ℤ) ∣ n := by\n  rw [← period_eq_minimalPeriod, zpow_smul_eq_iff_period_dvd]\n\n"}
{"name":"AddAction.nsmul_vadd_mod_minimalPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : G\nb : α\nn : Nat\n⊢ Eq (HVAdd.hVAdd (HSMul.hSMul (HMod.hMod n (Function.minimalPeriod (fun x => HVAdd.hVAdd a x) b)) a) b) (HVAdd.hVAdd (HSMul.hSMul n a) b)","decl":"@[to_additive (attr := simp)]\ntheorem pow_smul_mod_minimalPeriod (n : ℕ) :\n    a ^ (n % minimalPeriod (a • ·) b) • b = a ^ n • b := by\n  rw [← period_eq_minimalPeriod, pow_mod_period_smul]\n\n"}
{"name":"MulAction.pow_smul_mod_minimalPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : G\nb : α\nn : Nat\n⊢ Eq (HSMul.hSMul (HPow.hPow a (HMod.hMod n (Function.minimalPeriod (fun x => HSMul.hSMul a x) b))) b) (HSMul.hSMul (HPow.hPow a n) b)","decl":"@[to_additive (attr := simp)]\ntheorem pow_smul_mod_minimalPeriod (n : ℕ) :\n    a ^ (n % minimalPeriod (a • ·) b) • b = a ^ n • b := by\n  rw [← period_eq_minimalPeriod, pow_mod_period_smul]\n\n"}
{"name":"AddAction.zsmul_vadd_mod_minimalPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : G\nb : α\nn : Int\n⊢ Eq (HVAdd.hVAdd (HSMul.hSMul (HMod.hMod n ↑(Function.minimalPeriod (fun x => HVAdd.hVAdd a x) b)) a) b) (HVAdd.hVAdd (HSMul.hSMul n a) b)","decl":"@[to_additive (attr := simp)]\ntheorem zpow_smul_mod_minimalPeriod (n : ℤ) :\n    a ^ (n % (minimalPeriod (a • ·) b : ℤ)) • b = a ^ n • b := by\n  rw [← period_eq_minimalPeriod, zpow_mod_period_smul]\n\n"}
{"name":"MulAction.zpow_smul_mod_minimalPeriod","module":"Mathlib.Dynamics.PeriodicPts.Defs","initialProofState":"α : Type v\nG : Type u\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : G\nb : α\nn : Int\n⊢ Eq (HSMul.hSMul (HPow.hPow a (HMod.hMod n ↑(Function.minimalPeriod (fun x => HSMul.hSMul a x) b))) b) (HSMul.hSMul (HPow.hPow a n) b)","decl":"@[to_additive (attr := simp)]\ntheorem zpow_smul_mod_minimalPeriod (n : ℤ) :\n    a ^ (n % (minimalPeriod (a • ·) b : ℤ)) • b = a ^ n • b := by\n  rw [← period_eq_minimalPeriod, zpow_mod_period_smul]\n\n"}
