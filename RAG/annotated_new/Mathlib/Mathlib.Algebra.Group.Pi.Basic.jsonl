{"name":"Pi.one_apply","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ni : I\ninst✝ : (i : I) → One (f i)\n⊢ Eq (1 i) 1","decl":"@[to_additive (attr := simp)]\ntheorem one_apply [∀ i, One <| f i] : (1 : ∀ i, f i) i = 1 :=\n  rfl\n\n"}
{"name":"Pi.zero_apply","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ni : I\ninst✝ : (i : I) → Zero (f i)\n⊢ Eq (0 i) 0","decl":"@[to_additive (attr := simp)]\ntheorem one_apply [∀ i, One <| f i] : (1 : ∀ i, f i) i = 1 :=\n  rfl\n\n"}
{"name":"Pi.zero_def","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝ : (i : I) → Zero (f i)\n⊢ Eq 0 fun x => 0","decl":"@[to_additive]\ntheorem one_def [∀ i, One <| f i] : (1 : ∀ i, f i) = fun _ => 1 :=\n  rfl\n\n"}
{"name":"Pi.one_def","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝ : (i : I) → One (f i)\n⊢ Eq 1 fun x => 1","decl":"@[to_additive]\ntheorem one_def [∀ i, One <| f i] : (1 : ∀ i, f i) = fun _ => 1 :=\n  rfl\n\n"}
{"name":"Function.const_zero","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Zero β\n⊢ Eq (Function.const α 0) 0","decl":"@[to_additive (attr := simp)] lemma _root_.Function.const_one [One β] : const α (1 : β) = 1 := rfl\n\n"}
{"name":"Function.const_one","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : One β\n⊢ Eq (Function.const α 1) 1","decl":"@[to_additive (attr := simp)] lemma _root_.Function.const_one [One β] : const α (1 : β) = 1 := rfl\n\n"}
{"name":"Pi.one_comp","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : One γ\nx : α → β\n⊢ Eq (Function.comp 1 x) 1","decl":"@[to_additive (attr := simp)]\ntheorem one_comp [One γ] (x : α → β) : (1 : β → γ) ∘ x = 1 :=\n  rfl\n\n"}
{"name":"Pi.zero_comp","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Zero γ\nx : α → β\n⊢ Eq (Function.comp 0 x) 0","decl":"@[to_additive (attr := simp)]\ntheorem one_comp [One γ] (x : α → β) : (1 : β → γ) ∘ x = 1 :=\n  rfl\n\n"}
{"name":"Pi.comp_zero","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Zero β\nx : β → γ\n⊢ Eq (Function.comp x 0) (Function.const α (x 0))","decl":"@[to_additive (attr := simp)]\ntheorem comp_one [One β] (x : β → γ) : x ∘ (1 : α → β) = const α (x 1) :=\n  rfl\n\n"}
{"name":"Pi.comp_one","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : One β\nx : β → γ\n⊢ Eq (Function.comp x 1) (Function.const α (x 1))","decl":"@[to_additive (attr := simp)]\ntheorem comp_one [One β] (x : β → γ) : x ∘ (1 : α → β) = const α (x 1) :=\n  rfl\n\n"}
{"name":"Pi.mul_apply","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\nx y : (i : I) → f i\ni : I\ninst✝ : (i : I) → Mul (f i)\n⊢ Eq (HMul.hMul x y i) (HMul.hMul (x i) (y i))","decl":"@[to_additive (attr := simp)]\ntheorem mul_apply [∀ i, Mul <| f i] : (x * y) i = x i * y i :=\n  rfl\n\n"}
{"name":"Pi.add_apply","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\nx y : (i : I) → f i\ni : I\ninst✝ : (i : I) → Add (f i)\n⊢ Eq (HAdd.hAdd x y i) (HAdd.hAdd (x i) (y i))","decl":"@[to_additive (attr := simp)]\ntheorem mul_apply [∀ i, Mul <| f i] : (x * y) i = x i * y i :=\n  rfl\n\n"}
{"name":"Pi.add_def","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\nx y : (i : I) → f i\ninst✝ : (i : I) → Add (f i)\n⊢ Eq (HAdd.hAdd x y) fun i => HAdd.hAdd (x i) (y i)","decl":"@[to_additive]\ntheorem mul_def [∀ i, Mul <| f i] : x * y = fun i => x i * y i :=\n  rfl\n\n"}
{"name":"Pi.mul_def","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\nx y : (i : I) → f i\ninst✝ : (i : I) → Mul (f i)\n⊢ Eq (HMul.hMul x y) fun i => HMul.hMul (x i) (y i)","decl":"@[to_additive]\ntheorem mul_def [∀ i, Mul <| f i] : x * y = fun i => x i * y i :=\n  rfl\n\n"}
{"name":"Function.const_mul","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Mul β\na b : β\n⊢ Eq (HMul.hMul (Function.const α a) (Function.const α b)) (Function.const α (HMul.hMul a b))","decl":"@[to_additive (attr := simp)]\nlemma _root_.Function.const_mul [Mul β] (a b : β) : const α a * const α b = const α (a * b) := rfl\n\n"}
{"name":"Function.const_add","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Add β\na b : β\n⊢ Eq (HAdd.hAdd (Function.const α a) (Function.const α b)) (Function.const α (HAdd.hAdd a b))","decl":"@[to_additive (attr := simp)]\nlemma _root_.Function.const_mul [Mul β] (a b : β) : const α a * const α b = const α (a * b) := rfl\n\n"}
{"name":"Pi.mul_comp","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Mul γ\nx y : β → γ\nz : α → β\n⊢ Eq (Function.comp (HMul.hMul x y) z) (HMul.hMul (Function.comp x z) (Function.comp y z))","decl":"@[to_additive]\ntheorem mul_comp [Mul γ] (x y : β → γ) (z : α → β) : (x * y) ∘ z = x ∘ z * y ∘ z :=\n  rfl\n\n"}
{"name":"Pi.add_comp","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Add γ\nx y : β → γ\nz : α → β\n⊢ Eq (Function.comp (HAdd.hAdd x y) z) (HAdd.hAdd (Function.comp x z) (Function.comp y z))","decl":"@[to_additive]\ntheorem mul_comp [Mul γ] (x y : β → γ) (z : α → β) : (x * y) ∘ z = x ∘ z * y ∘ z :=\n  rfl\n\n"}
{"name":"Pi.pow_apply","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nβ : Type u_2\nf : I → Type v₁\ninst✝ : (i : I) → Pow (f i) β\nx : (i : I) → f i\nb : β\ni : I\n⊢ Eq (HPow.hPow x b i) (HPow.hPow (x i) b)","decl":"@[to_additive (attr := simp, to_additive) (reorder := 5 6) smul_apply]\ntheorem pow_apply [∀ i, Pow (f i) β] (x : ∀ i, f i) (b : β) (i : I) : (x ^ b) i = x i ^ b :=\n  rfl\n\n"}
{"name":"Pi.smul_apply","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nβ : Type u_2\nf : I → Type v₁\ninst✝ : (i : I) → SMul β (f i)\nb : β\nx : (i : I) → f i\ni : I\n⊢ Eq (HSMul.hSMul b x i) (HSMul.hSMul b (x i))","decl":"@[to_additive (attr := simp, to_additive) (reorder := 5 6) smul_apply]\ntheorem pow_apply [∀ i, Pow (f i) β] (x : ∀ i, f i) (b : β) (i : I) : (x ^ b) i = x i ^ b :=\n  rfl\n\n"}
{"name":"Pi.vadd_apply","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nβ : Type u_2\nf : I → Type v₁\ninst✝ : (i : I) → VAdd β (f i)\nb : β\nx : (i : I) → f i\ni : I\n⊢ Eq (HVAdd.hVAdd b x i) (HVAdd.hVAdd b (x i))","decl":"@[to_additive (attr := simp, to_additive) (reorder := 5 6) smul_apply]\ntheorem pow_apply [∀ i, Pow (f i) β] (x : ∀ i, f i) (b : β) (i : I) : (x ^ b) i = x i ^ b :=\n  rfl\n\n"}
{"name":"Pi.pow_def","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nβ : Type u_2\nf : I → Type v₁\ninst✝ : (i : I) → Pow (f i) β\nx : (i : I) → f i\nb : β\n⊢ Eq (HPow.hPow x b) fun i => HPow.hPow (x i) b","decl":"@[to_additive (attr := to_additive) (reorder := 5 6) smul_def]\ntheorem pow_def [∀ i, Pow (f i) β] (x : ∀ i, f i) (b : β) : x ^ b = fun i => x i ^ b :=\n  rfl\n\n"}
{"name":"Pi.smul_def","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nβ : Type u_2\nf : I → Type v₁\ninst✝ : (i : I) → SMul β (f i)\nb : β\nx : (i : I) → f i\n⊢ Eq (HSMul.hSMul b x) fun i => HSMul.hSMul b (x i)","decl":"@[to_additive (attr := to_additive) (reorder := 5 6) smul_def]\ntheorem pow_def [∀ i, Pow (f i) β] (x : ∀ i, f i) (b : β) : x ^ b = fun i => x i ^ b :=\n  rfl\n\n"}
{"name":"Pi.vadd_def","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nβ : Type u_2\nf : I → Type v₁\ninst✝ : (i : I) → VAdd β (f i)\nb : β\nx : (i : I) → f i\n⊢ Eq (HVAdd.hVAdd b x) fun i => HVAdd.hVAdd b (x i)","decl":"@[to_additive (attr := to_additive) (reorder := 5 6) smul_def]\ntheorem pow_def [∀ i, Pow (f i) β] (x : ∀ i, f i) (b : β) : x ^ b = fun i => x i ^ b :=\n  rfl\n\n"}
{"name":"Function.vadd_const","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nβ : Type u_2\nα : Type u_1\ninst✝ : VAdd β α\nb : β\na : α\n⊢ Eq (HVAdd.hVAdd b (Function.const I a)) (Function.const I (HVAdd.hVAdd b a))","decl":"@[to_additive (attr := simp, to_additive) (reorder := 2 3, 5 6) smul_const]\nlemma _root_.Function.const_pow [Pow α β] (a : α) (b : β) : const I a ^ b = const I (a ^ b) := rfl\n\n"}
{"name":"Function.const_pow","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nα : Type u_1\nβ : Type u_2\ninst✝ : Pow α β\na : α\nb : β\n⊢ Eq (HPow.hPow (Function.const I a) b) (Function.const I (HPow.hPow a b))","decl":"@[to_additive (attr := simp, to_additive) (reorder := 2 3, 5 6) smul_const]\nlemma _root_.Function.const_pow [Pow α β] (a : α) (b : β) : const I a ^ b = const I (a ^ b) := rfl\n\n"}
{"name":"Function.smul_const","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nβ : Type u_2\nα : Type u_1\ninst✝ : SMul β α\nb : β\na : α\n⊢ Eq (HSMul.hSMul b (Function.const I a)) (Function.const I (HSMul.hSMul b a))","decl":"@[to_additive (attr := simp, to_additive) (reorder := 2 3, 5 6) smul_const]\nlemma _root_.Function.const_pow [Pow α β] (a : α) (b : β) : const I a ^ b = const I (a ^ b) := rfl\n\n"}
{"name":"Pi.pow_comp","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nα : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Pow γ α\nx : β → γ\na : α\ny : I → β\n⊢ Eq (Function.comp (HPow.hPow x a) y) (HPow.hPow (Function.comp x y) a)","decl":"@[to_additive (attr := to_additive) (reorder := 6 7) smul_comp]\ntheorem pow_comp [Pow γ α] (x : β → γ) (a : α) (y : I → β) : (x ^ a) ∘ y = x ∘ y ^ a :=\n  rfl\n\n-- Use `Pi.ofNat_apply` instead\n\n"}
{"name":"Pi.vadd_comp","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nα : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : VAdd α γ\na : α\nx : β → γ\ny : I → β\n⊢ Eq (Function.comp (HVAdd.hVAdd a x) y) (HVAdd.hVAdd a (Function.comp x y))","decl":"@[to_additive (attr := to_additive) (reorder := 6 7) smul_comp]\ntheorem pow_comp [Pow γ α] (x : β → γ) (a : α) (y : I → β) : (x ^ a) ∘ y = x ∘ y ^ a :=\n  rfl\n\n-- Use `Pi.ofNat_apply` instead\n\n"}
{"name":"Pi.smul_comp","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nα : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : SMul α γ\na : α\nx : β → γ\ny : I → β\n⊢ Eq (Function.comp (HSMul.hSMul a x) y) (HSMul.hSMul a (Function.comp x y))","decl":"@[to_additive (attr := to_additive) (reorder := 6 7) smul_comp]\ntheorem pow_comp [Pow γ α] (x : β → γ) (a : α) (y : I → β) : (x ^ a) ∘ y = x ∘ y ^ a :=\n  rfl\n\n-- Use `Pi.ofNat_apply` instead\n\n"}
{"name":"Pi.neg_apply","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\nx : (i : I) → f i\ni : I\ninst✝ : (i : I) → Neg (f i)\n⊢ Eq (Neg.neg x i) (Neg.neg (x i))","decl":"@[to_additive (attr := simp)]\ntheorem inv_apply [∀ i, Inv <| f i] : x⁻¹ i = (x i)⁻¹ :=\n  rfl\n\n"}
{"name":"Pi.inv_apply","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\nx : (i : I) → f i\ni : I\ninst✝ : (i : I) → Inv (f i)\n⊢ Eq (Inv.inv x i) (Inv.inv (x i))","decl":"@[to_additive (attr := simp)]\ntheorem inv_apply [∀ i, Inv <| f i] : x⁻¹ i = (x i)⁻¹ :=\n  rfl\n\n"}
{"name":"Pi.neg_def","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\nx : (i : I) → f i\ninst✝ : (i : I) → Neg (f i)\n⊢ Eq (Neg.neg x) fun i => Neg.neg (x i)","decl":"@[to_additive]\ntheorem inv_def [∀ i, Inv <| f i] : x⁻¹ = fun i => (x i)⁻¹ :=\n  rfl\n\n"}
{"name":"Pi.inv_def","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\nx : (i : I) → f i\ninst✝ : (i : I) → Inv (f i)\n⊢ Eq (Inv.inv x) fun i => Inv.inv (x i)","decl":"@[to_additive]\ntheorem inv_def [∀ i, Inv <| f i] : x⁻¹ = fun i => (x i)⁻¹ :=\n  rfl\n\n"}
{"name":"Function.const_neg","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Neg β\na : β\n⊢ Eq (Neg.neg (Function.const α a)) (Function.const α (Neg.neg a))","decl":"@[to_additive]\nlemma _root_.Function.const_inv [Inv β] (a : β) : (const α a)⁻¹ = const α a⁻¹ := rfl\n\n"}
{"name":"Function.const_inv","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Inv β\na : β\n⊢ Eq (Inv.inv (Function.const α a)) (Function.const α (Inv.inv a))","decl":"@[to_additive]\nlemma _root_.Function.const_inv [Inv β] (a : β) : (const α a)⁻¹ = const α a⁻¹ := rfl\n\n"}
{"name":"Pi.neg_comp","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Neg γ\nx : β → γ\ny : α → β\n⊢ Eq (Function.comp (Neg.neg x) y) (Neg.neg (Function.comp x y))","decl":"@[to_additive]\ntheorem inv_comp [Inv γ] (x : β → γ) (y : α → β) : x⁻¹ ∘ y = (x ∘ y)⁻¹ :=\n  rfl\n\n"}
{"name":"Pi.inv_comp","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Inv γ\nx : β → γ\ny : α → β\n⊢ Eq (Function.comp (Inv.inv x) y) (Inv.inv (Function.comp x y))","decl":"@[to_additive]\ntheorem inv_comp [Inv γ] (x : β → γ) (y : α → β) : x⁻¹ ∘ y = (x ∘ y)⁻¹ :=\n  rfl\n\n"}
{"name":"Pi.sub_apply","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\nx y : (i : I) → f i\ni : I\ninst✝ : (i : I) → Sub (f i)\n⊢ Eq (HSub.hSub x y i) (HSub.hSub (x i) (y i))","decl":"@[to_additive (attr := simp)]\ntheorem div_apply [∀ i, Div <| f i] : (x / y) i = x i / y i :=\n  rfl\n\n"}
{"name":"Pi.div_apply","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\nx y : (i : I) → f i\ni : I\ninst✝ : (i : I) → Div (f i)\n⊢ Eq (HDiv.hDiv x y i) (HDiv.hDiv (x i) (y i))","decl":"@[to_additive (attr := simp)]\ntheorem div_apply [∀ i, Div <| f i] : (x / y) i = x i / y i :=\n  rfl\n\n"}
{"name":"Pi.sub_def","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\nx y : (i : I) → f i\ninst✝ : (i : I) → Sub (f i)\n⊢ Eq (HSub.hSub x y) fun i => HSub.hSub (x i) (y i)","decl":"@[to_additive]\ntheorem div_def [∀ i, Div <| f i] : x / y = fun i => x i / y i :=\n  rfl\n\n"}
{"name":"Pi.div_def","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\nx y : (i : I) → f i\ninst✝ : (i : I) → Div (f i)\n⊢ Eq (HDiv.hDiv x y) fun i => HDiv.hDiv (x i) (y i)","decl":"@[to_additive]\ntheorem div_def [∀ i, Div <| f i] : x / y = fun i => x i / y i :=\n  rfl\n\n"}
{"name":"Pi.div_comp","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Div γ\nx y : β → γ\nz : α → β\n⊢ Eq (Function.comp (HDiv.hDiv x y) z) (HDiv.hDiv (Function.comp x z) (Function.comp y z))","decl":"@[to_additive]\ntheorem div_comp [Div γ] (x y : β → γ) (z : α → β) : (x / y) ∘ z = x ∘ z / y ∘ z :=\n  rfl\n\n"}
{"name":"Pi.sub_comp","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Sub γ\nx y : β → γ\nz : α → β\n⊢ Eq (Function.comp (HSub.hSub x y) z) (HSub.hSub (Function.comp x z) (Function.comp y z))","decl":"@[to_additive]\ntheorem div_comp [Div γ] (x y : β → γ) (z : α → β) : (x / y) ∘ z = x ∘ z / y ∘ z :=\n  rfl\n\n"}
{"name":"Function.const_sub","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Sub β\na b : β\n⊢ Eq (HSub.hSub (Function.const α a) (Function.const α b)) (Function.const α (HSub.hSub a b))","decl":"@[to_additive (attr := simp)]\nlemma _root_.Function.const_div [Div β] (a b : β) : const α a / const α b = const α (a / b) := rfl\n\n"}
{"name":"Function.const_div","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Div β\na b : β\n⊢ Eq (HDiv.hDiv (Function.const α a) (Function.const α b)) (Function.const α (HDiv.hDiv a b))","decl":"@[to_additive (attr := simp)]\nlemma _root_.Function.const_div [Div β] (a b : β) : const α a / const α b = const α (a / b) := rfl\n\n"}
{"name":"Pi.instIsAddLeftCancel","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : (i : I) → Add (f i)\ninst✝ : ∀ (i : I), IsLeftCancelAdd (f i)\n⊢ IsLeftCancelAdd ((i : I) → f i)","decl":"@[to_additive] instance instIsLeftCancelMul [∀ i, Mul (f i)] [∀ i, IsLeftCancelMul (f i)] :\n    IsLeftCancelMul (∀ i, f i) where\n  mul_left_cancel  _ _ _ h := funext fun _ ↦ mul_left_cancel (congr_fun h _)\n\n"}
{"name":"Pi.instIsLeftCancelMul","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : (i : I) → Mul (f i)\ninst✝ : ∀ (i : I), IsLeftCancelMul (f i)\n⊢ IsLeftCancelMul ((i : I) → f i)","decl":"@[to_additive] instance instIsLeftCancelMul [∀ i, Mul (f i)] [∀ i, IsLeftCancelMul (f i)] :\n    IsLeftCancelMul (∀ i, f i) where\n  mul_left_cancel  _ _ _ h := funext fun _ ↦ mul_left_cancel (congr_fun h _)\n\n"}
{"name":"Pi.instIsAddRightCancel","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : (i : I) → Add (f i)\ninst✝ : ∀ (i : I), IsRightCancelAdd (f i)\n⊢ IsRightCancelAdd ((i : I) → f i)","decl":"@[to_additive] instance instIsRightCancelMul [∀ i, Mul (f i)] [∀ i, IsRightCancelMul (f i)] :\n    IsRightCancelMul (∀ i, f i) where\n  mul_right_cancel  _ _ _ h := funext fun _ ↦ mul_right_cancel (congr_fun h _)\n\n"}
{"name":"Pi.instIsRightCancelMul","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : (i : I) → Mul (f i)\ninst✝ : ∀ (i : I), IsRightCancelMul (f i)\n⊢ IsRightCancelMul ((i : I) → f i)","decl":"@[to_additive] instance instIsRightCancelMul [∀ i, Mul (f i)] [∀ i, IsRightCancelMul (f i)] :\n    IsRightCancelMul (∀ i, f i) where\n  mul_right_cancel  _ _ _ h := funext fun _ ↦ mul_right_cancel (congr_fun h _)\n\n"}
{"name":"Pi.instIsAddCancel","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : (i : I) → Add (f i)\ninst✝ : ∀ (i : I), IsCancelAdd (f i)\n⊢ IsCancelAdd ((i : I) → f i)","decl":"@[to_additive] instance instIsCancelMul [∀ i, Mul (f i)] [∀ i, IsCancelMul (f i)] :\n    IsCancelMul (∀ i, f i) where\n\n"}
{"name":"Pi.instIsCancelMul","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : (i : I) → Mul (f i)\ninst✝ : ∀ (i : I), IsCancelMul (f i)\n⊢ IsCancelMul ((i : I) → f i)","decl":"@[to_additive] instance instIsCancelMul [∀ i, Mul (f i)] [∀ i, IsCancelMul (f i)] :\n    IsCancelMul (∀ i, f i) where\n\n"}
{"name":"Pi.single_eq_same","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → Zero (f i)\ni : I\nx : f i\n⊢ Eq (Pi.single i x i) x","decl":"@[to_additive (attr := simp)]\ntheorem mulSingle_eq_same (i : I) (x : f i) : mulSingle i x i = x :=\n  Function.update_self i x _\n\n"}
{"name":"Pi.mulSingle_eq_same","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → One (f i)\ni : I\nx : f i\n⊢ Eq (Pi.mulSingle i x i) x","decl":"@[to_additive (attr := simp)]\ntheorem mulSingle_eq_same (i : I) (x : f i) : mulSingle i x i = x :=\n  Function.update_self i x _\n\n"}
{"name":"Pi.mulSingle_eq_of_ne","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → One (f i)\ni i' : I\nh : Ne i' i\nx : f i\n⊢ Eq (Pi.mulSingle i x i') 1","decl":"@[to_additive (attr := simp)]\ntheorem mulSingle_eq_of_ne {i i' : I} (h : i' ≠ i) (x : f i) : mulSingle i x i' = 1 :=\n  Function.update_of_ne h x _\n\n"}
{"name":"Pi.single_eq_of_ne","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → Zero (f i)\ni i' : I\nh : Ne i' i\nx : f i\n⊢ Eq (Pi.single i x i') 0","decl":"@[to_additive (attr := simp)]\ntheorem mulSingle_eq_of_ne {i i' : I} (h : i' ≠ i) (x : f i) : mulSingle i x i' = 1 :=\n  Function.update_of_ne h x _\n\n"}
{"name":"Pi.mulSingle_eq_of_ne'","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → One (f i)\ni i' : I\nh : Ne i i'\nx : f i\n⊢ Eq (Pi.mulSingle i x i') 1","decl":"/-- Abbreviation for `mulSingle_eq_of_ne h.symm`, for ease of use by `simp`. -/\n@[to_additive (attr := simp)\n  \"Abbreviation for `single_eq_of_ne h.symm`, for ease of use by `simp`.\"]\ntheorem mulSingle_eq_of_ne' {i i' : I} (h : i ≠ i') (x : f i) : mulSingle i x i' = 1 :=\n  mulSingle_eq_of_ne h.symm x\n\n"}
{"name":"Pi.single_eq_of_ne'","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → Zero (f i)\ni i' : I\nh : Ne i i'\nx : f i\n⊢ Eq (Pi.single i x i') 0","decl":"/-- Abbreviation for `mulSingle_eq_of_ne h.symm`, for ease of use by `simp`. -/\n@[to_additive (attr := simp)\n  \"Abbreviation for `single_eq_of_ne h.symm`, for ease of use by `simp`.\"]\ntheorem mulSingle_eq_of_ne' {i i' : I} (h : i ≠ i') (x : f i) : mulSingle i x i' = 1 :=\n  mulSingle_eq_of_ne h.symm x\n\n"}
{"name":"Pi.mulSingle_one","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → One (f i)\ni : I\n⊢ Eq (Pi.mulSingle i 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem mulSingle_one (i : I) : mulSingle i (1 : f i) = 1 :=\n  Function.update_eq_self _ _\n\n-- Porting note:\n-- 1) Why do I have to specify the type of `mulSingle i x` explicitly?\n-- 2) Why do I have to specify the type of `(1 : I → β)`?\n-- 3) Removed `{β : Sort*}` as `[One β]` converts it to a type anyways.\n"}
{"name":"Pi.single_zero","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → Zero (f i)\ni : I\n⊢ Eq (Pi.single i 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem mulSingle_one (i : I) : mulSingle i (1 : f i) = 1 :=\n  Function.update_eq_self _ _\n\n-- Porting note:\n-- 1) Why do I have to specify the type of `mulSingle i x` explicitly?\n-- 2) Why do I have to specify the type of `(1 : I → β)`?\n-- 3) Removed `{β : Sort*}` as `[One β]` converts it to a type anyways.\n"}
{"name":"Pi.single_apply","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nβ : Type u_2\ninst✝¹ : DecidableEq I\ninst✝ : Zero β\ni : I\nx : β\ni' : I\n⊢ Eq (Pi.single i x i') (ite (Eq i' i) x 0)","decl":"/-- On non-dependent functions, `Pi.mulSingle` can be expressed as an `ite` -/\n@[to_additive \"On non-dependent functions, `Pi.single` can be expressed as an `ite`\"]\ntheorem mulSingle_apply [One β] (i : I) (x : β) (i' : I) :\n    (mulSingle i x : I → β) i' = if i' = i then x else 1 :=\n  Function.update_apply (1 : I → β) i x i'\n\n-- Porting note: Same as above.\n"}
{"name":"Pi.mulSingle_apply","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nβ : Type u_2\ninst✝¹ : DecidableEq I\ninst✝ : One β\ni : I\nx : β\ni' : I\n⊢ Eq (Pi.mulSingle i x i') (ite (Eq i' i) x 1)","decl":"/-- On non-dependent functions, `Pi.mulSingle` can be expressed as an `ite` -/\n@[to_additive \"On non-dependent functions, `Pi.single` can be expressed as an `ite`\"]\ntheorem mulSingle_apply [One β] (i : I) (x : β) (i' : I) :\n    (mulSingle i x : I → β) i' = if i' = i then x else 1 :=\n  Function.update_apply (1 : I → β) i x i'\n\n-- Porting note: Same as above.\n"}
{"name":"Pi.mulSingle_comm","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nβ : Type u_2\ninst✝¹ : DecidableEq I\ninst✝ : One β\ni : I\nx : β\ni' : I\n⊢ Eq (Pi.mulSingle i x i') (Pi.mulSingle i' x i)","decl":"/-- On non-dependent functions, `Pi.mulSingle` is symmetric in the two indices. -/\n@[to_additive \"On non-dependent functions, `Pi.single` is symmetric in the two indices.\"]\ntheorem mulSingle_comm [One β] (i : I) (x : β) (i' : I) :\n    (mulSingle i x : I → β) i' = (mulSingle i' x : I → β) i := by\n  simp [mulSingle_apply, eq_comm]\n\n"}
{"name":"Pi.single_comm","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nβ : Type u_2\ninst✝¹ : DecidableEq I\ninst✝ : Zero β\ni : I\nx : β\ni' : I\n⊢ Eq (Pi.single i x i') (Pi.single i' x i)","decl":"/-- On non-dependent functions, `Pi.mulSingle` is symmetric in the two indices. -/\n@[to_additive \"On non-dependent functions, `Pi.single` is symmetric in the two indices.\"]\ntheorem mulSingle_comm [One β] (i : I) (x : β) (i' : I) :\n    (mulSingle i x : I → β) i' = (mulSingle i' x : I → β) i := by\n  simp [mulSingle_apply, eq_comm]\n\n"}
{"name":"Pi.apply_mulSingle","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ng : I → Type v₂\ninst✝² : DecidableEq I\ninst✝¹ : (i : I) → One (f i)\ninst✝ : (i : I) → One (g i)\nf' : (i : I) → f i → g i\nhf' : ∀ (i : I), Eq (f' i 1) 1\ni : I\nx : f i\nj : I\n⊢ Eq (f' j (Pi.mulSingle i x j)) (Pi.mulSingle i (f' i x) j)","decl":"@[to_additive]\ntheorem apply_mulSingle (f' : ∀ i, f i → g i) (hf' : ∀ i, f' i 1 = 1) (i : I) (x : f i) (j : I) :\n    f' j (mulSingle i x j) = mulSingle i (f' i x) j := by\n  simpa only [Pi.one_apply, hf', mulSingle] using Function.apply_update f' 1 i x j\n\n"}
{"name":"Pi.apply_single","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ng : I → Type v₂\ninst✝² : DecidableEq I\ninst✝¹ : (i : I) → Zero (f i)\ninst✝ : (i : I) → Zero (g i)\nf' : (i : I) → f i → g i\nhf' : ∀ (i : I), Eq (f' i 0) 0\ni : I\nx : f i\nj : I\n⊢ Eq (f' j (Pi.single i x j)) (Pi.single i (f' i x) j)","decl":"@[to_additive]\ntheorem apply_mulSingle (f' : ∀ i, f i → g i) (hf' : ∀ i, f' i 1 = 1) (i : I) (x : f i) (j : I) :\n    f' j (mulSingle i x j) = mulSingle i (f' i x) j := by\n  simpa only [Pi.one_apply, hf', mulSingle] using Function.apply_update f' 1 i x j\n\n"}
{"name":"Pi.apply_single₂","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ng : I → Type v₂\nh : I → Type v₃\ninst✝³ : DecidableEq I\ninst✝² : (i : I) → Zero (f i)\ninst✝¹ : (i : I) → Zero (g i)\ninst✝ : (i : I) → Zero (h i)\nf' : (i : I) → f i → g i → h i\nhf' : ∀ (i : I), Eq (f' i 0 0) 0\ni : I\nx : f i\ny : g i\nj : I\n⊢ Eq (f' j (Pi.single i x j) (Pi.single i y j)) (Pi.single i (f' i x y) j)","decl":"@[to_additive apply_single₂]\ntheorem apply_mulSingle₂ (f' : ∀ i, f i → g i → h i) (hf' : ∀ i, f' i 1 1 = 1) (i : I)\n    (x : f i) (y : g i) (j : I) :\n    f' j (mulSingle i x j) (mulSingle i y j) = mulSingle i (f' i x y) j := by\n  by_cases h : j = i\n  · subst h\n    simp only [mulSingle_eq_same]\n  · simp only [mulSingle_eq_of_ne h, hf']\n\n"}
{"name":"Pi.apply_mulSingle₂","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ng : I → Type v₂\nh : I → Type v₃\ninst✝³ : DecidableEq I\ninst✝² : (i : I) → One (f i)\ninst✝¹ : (i : I) → One (g i)\ninst✝ : (i : I) → One (h i)\nf' : (i : I) → f i → g i → h i\nhf' : ∀ (i : I), Eq (f' i 1 1) 1\ni : I\nx : f i\ny : g i\nj : I\n⊢ Eq (f' j (Pi.mulSingle i x j) (Pi.mulSingle i y j)) (Pi.mulSingle i (f' i x y) j)","decl":"@[to_additive apply_single₂]\ntheorem apply_mulSingle₂ (f' : ∀ i, f i → g i → h i) (hf' : ∀ i, f' i 1 1 = 1) (i : I)\n    (x : f i) (y : g i) (j : I) :\n    f' j (mulSingle i x j) (mulSingle i y j) = mulSingle i (f' i x y) j := by\n  by_cases h : j = i\n  · subst h\n    simp only [mulSingle_eq_same]\n  · simp only [mulSingle_eq_of_ne h, hf']\n\n"}
{"name":"Pi.mulSingle_op","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝² : DecidableEq I\ninst✝¹ : (i : I) → One (f i)\ng : I → Type u_4\ninst✝ : (i : I) → One (g i)\nop : (i : I) → f i → g i\nh : ∀ (i : I), Eq (op i 1) 1\ni : I\nx : f i\n⊢ Eq (Pi.mulSingle i (op i x)) fun j => op j (Pi.mulSingle i x j)","decl":"@[to_additive]\ntheorem mulSingle_op {g : I → Type*} [∀ i, One (g i)] (op : ∀ i, f i → g i)\n    (h : ∀ i, op i 1 = 1) (i : I) (x : f i) :\n    mulSingle i (op i x) = fun j => op j (mulSingle i x j) :=\n  Eq.symm <| funext <| apply_mulSingle op h i x\n\n"}
{"name":"Pi.single_op","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝² : DecidableEq I\ninst✝¹ : (i : I) → Zero (f i)\ng : I → Type u_4\ninst✝ : (i : I) → Zero (g i)\nop : (i : I) → f i → g i\nh : ∀ (i : I), Eq (op i 0) 0\ni : I\nx : f i\n⊢ Eq (Pi.single i (op i x)) fun j => op j (Pi.single i x j)","decl":"@[to_additive]\ntheorem mulSingle_op {g : I → Type*} [∀ i, One (g i)] (op : ∀ i, f i → g i)\n    (h : ∀ i, op i 1 = 1) (i : I) (x : f i) :\n    mulSingle i (op i x) = fun j => op j (mulSingle i x j) :=\n  Eq.symm <| funext <| apply_mulSingle op h i x\n\n"}
{"name":"Pi.single_op₂","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝³ : DecidableEq I\ninst✝² : (i : I) → Zero (f i)\ng₁ : I → Type u_4\ng₂ : I → Type u_5\ninst✝¹ : (i : I) → Zero (g₁ i)\ninst✝ : (i : I) → Zero (g₂ i)\nop : (i : I) → g₁ i → g₂ i → f i\nh : ∀ (i : I), Eq (op i 0 0) 0\ni : I\nx₁ : g₁ i\nx₂ : g₂ i\n⊢ Eq (Pi.single i (op i x₁ x₂)) fun j => op j (Pi.single i x₁ j) (Pi.single i x₂ j)","decl":"@[to_additive]\ntheorem mulSingle_op₂ {g₁ g₂ : I → Type*} [∀ i, One (g₁ i)] [∀ i, One (g₂ i)]\n    (op : ∀ i, g₁ i → g₂ i → f i) (h : ∀ i, op i 1 1 = 1) (i : I) (x₁ : g₁ i) (x₂ : g₂ i) :\n    mulSingle i (op i x₁ x₂) = fun j => op j (mulSingle i x₁ j) (mulSingle i x₂ j) :=\n  Eq.symm <| funext <| apply_mulSingle₂ op h i x₁ x₂\n\n"}
{"name":"Pi.mulSingle_op₂","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝³ : DecidableEq I\ninst✝² : (i : I) → One (f i)\ng₁ : I → Type u_4\ng₂ : I → Type u_5\ninst✝¹ : (i : I) → One (g₁ i)\ninst✝ : (i : I) → One (g₂ i)\nop : (i : I) → g₁ i → g₂ i → f i\nh : ∀ (i : I), Eq (op i 1 1) 1\ni : I\nx₁ : g₁ i\nx₂ : g₂ i\n⊢ Eq (Pi.mulSingle i (op i x₁ x₂)) fun j => op j (Pi.mulSingle i x₁ j) (Pi.mulSingle i x₂ j)","decl":"@[to_additive]\ntheorem mulSingle_op₂ {g₁ g₂ : I → Type*} [∀ i, One (g₁ i)] [∀ i, One (g₂ i)]\n    (op : ∀ i, g₁ i → g₂ i → f i) (h : ∀ i, op i 1 1 = 1) (i : I) (x₁ : g₁ i) (x₂ : g₂ i) :\n    mulSingle i (op i x₁ x₂) = fun j => op j (mulSingle i x₁ j) (mulSingle i x₂ j) :=\n  Eq.symm <| funext <| apply_mulSingle₂ op h i x₁ x₂\n\n"}
{"name":"Pi.mulSingle_injective","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → One (f i)\ni : I\n⊢ Function.Injective (Pi.mulSingle i)","decl":"@[to_additive]\ntheorem mulSingle_injective (i : I) : Function.Injective (mulSingle i : f i → ∀ i, f i) :=\n  Function.update_injective _ i\n\n"}
{"name":"Pi.single_injective","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → Zero (f i)\ni : I\n⊢ Function.Injective (Pi.single i)","decl":"@[to_additive]\ntheorem mulSingle_injective (i : I) : Function.Injective (mulSingle i : f i → ∀ i, f i) :=\n  Function.update_injective _ i\n\n"}
{"name":"Pi.mulSingle_inj","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → One (f i)\ni : I\nx y : f i\n⊢ Iff (Eq (Pi.mulSingle i x) (Pi.mulSingle i y)) (Eq x y)","decl":"@[to_additive (attr := simp)]\ntheorem mulSingle_inj (i : I) {x y : f i} : mulSingle i x = mulSingle i y ↔ x = y :=\n  (Pi.mulSingle_injective _ _).eq_iff\n\n"}
{"name":"Pi.single_inj","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nf : I → Type v₁\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → Zero (f i)\ni : I\nx y : f i\n⊢ Iff (Eq (Pi.single i x) (Pi.single i y)) (Eq x y)","decl":"@[to_additive (attr := simp)]\ntheorem mulSingle_inj (i : I) {x y : f i} : mulSingle i x = mulSingle i y ↔ x = y :=\n  (Pi.mulSingle_injective _ _).eq_iff\n\n"}
{"name":"Pi.prod_fst_snd","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (Pi.prod Prod.fst Prod.snd) id","decl":"theorem prod_fst_snd : Pi.prod (Prod.fst : α × β → α) (Prod.snd : α × β → β) = id :=\n  rfl\n\n-- Porting note: simp now unfolds the lhs, so we are not marking these as simp.\n-- @[simp]\n"}
{"name":"Pi.prod_snd_fst","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (Pi.prod Prod.snd Prod.fst) Prod.swap","decl":"theorem prod_snd_fst : Pi.prod (Prod.snd : α × β → β) (Prod.fst : α × β → α) = Prod.swap :=\n  rfl\n\n"}
{"name":"Function.extend_one","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : One γ\nf : α → β\n⊢ Eq (Function.extend f 1 1) 1","decl":"@[to_additive]\ntheorem extend_one [One γ] (f : α → β) : Function.extend f (1 : α → γ) (1 : β → γ) = 1 :=\n  funext fun _ => by apply ite_self\n\n"}
{"name":"Function.extend_zero","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Zero γ\nf : α → β\n⊢ Eq (Function.extend f 0 0) 0","decl":"@[to_additive]\ntheorem extend_one [One γ] (f : α → β) : Function.extend f (1 : α → γ) (1 : β → γ) = 1 :=\n  funext fun _ => by apply ite_self\n\n"}
{"name":"Function.extend_mul","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Mul γ\nf : α → β\ng₁ g₂ : α → γ\ne₁ e₂ : β → γ\n⊢ Eq (Function.extend f (HMul.hMul g₁ g₂) (HMul.hMul e₁ e₂)) (HMul.hMul (Function.extend f g₁ e₁) (Function.extend f g₂ e₂))","decl":"@[to_additive]\ntheorem extend_mul [Mul γ] (f : α → β) (g₁ g₂ : α → γ) (e₁ e₂ : β → γ) :\n    Function.extend f (g₁ * g₂) (e₁ * e₂) = Function.extend f g₁ e₁ * Function.extend f g₂ e₂ := by\n  classical\n  funext x\n  simp only [not_exists, extend_def, Pi.mul_apply, apply_dite₂, dite_eq_ite, ite_self]\n-- Porting note: The Lean3 statement was\n-- `funext <| λ _, by convert (apply_dite2 (*) _ _ _ _ _).symm`\n-- which converts to\n-- `funext fun _ => by convert (apply_dite₂ (· * ·) _ _ _ _ _).symm`\n-- However this does not work, and we're not sure why.\n\n"}
{"name":"Function.extend_add","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Add γ\nf : α → β\ng₁ g₂ : α → γ\ne₁ e₂ : β → γ\n⊢ Eq (Function.extend f (HAdd.hAdd g₁ g₂) (HAdd.hAdd e₁ e₂)) (HAdd.hAdd (Function.extend f g₁ e₁) (Function.extend f g₂ e₂))","decl":"@[to_additive]\ntheorem extend_mul [Mul γ] (f : α → β) (g₁ g₂ : α → γ) (e₁ e₂ : β → γ) :\n    Function.extend f (g₁ * g₂) (e₁ * e₂) = Function.extend f g₁ e₁ * Function.extend f g₂ e₂ := by\n  classical\n  funext x\n  simp only [not_exists, extend_def, Pi.mul_apply, apply_dite₂, dite_eq_ite, ite_self]\n-- Porting note: The Lean3 statement was\n-- `funext <| λ _, by convert (apply_dite2 (*) _ _ _ _ _).symm`\n-- which converts to\n-- `funext fun _ => by convert (apply_dite₂ (· * ·) _ _ _ _ _).symm`\n-- However this does not work, and we're not sure why.\n\n"}
{"name":"Function.extend_inv","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Inv γ\nf : α → β\ng : α → γ\ne : β → γ\n⊢ Eq (Function.extend f (Inv.inv g) (Inv.inv e)) (Inv.inv (Function.extend f g e))","decl":"@[to_additive]\ntheorem extend_inv [Inv γ] (f : α → β) (g : α → γ) (e : β → γ) :\n    Function.extend f g⁻¹ e⁻¹ = (Function.extend f g e)⁻¹ := by\n  classical\n  funext x\n  simp only [not_exists, extend_def, Pi.inv_apply, apply_dite Inv.inv]\n-- Porting note: The Lean3 statement was\n-- `funext <| λ _, by convert (apply_dite has_inv.inv _ _ _).symm`\n-- which converts to\n-- `funext fun _ => by convert (apply_dite Inv.inv _ _ _).symm`\n-- However this does not work, and we're not sure why.\n\n"}
{"name":"Function.extend_neg","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Neg γ\nf : α → β\ng : α → γ\ne : β → γ\n⊢ Eq (Function.extend f (Neg.neg g) (Neg.neg e)) (Neg.neg (Function.extend f g e))","decl":"@[to_additive]\ntheorem extend_inv [Inv γ] (f : α → β) (g : α → γ) (e : β → γ) :\n    Function.extend f g⁻¹ e⁻¹ = (Function.extend f g e)⁻¹ := by\n  classical\n  funext x\n  simp only [not_exists, extend_def, Pi.inv_apply, apply_dite Inv.inv]\n-- Porting note: The Lean3 statement was\n-- `funext <| λ _, by convert (apply_dite has_inv.inv _ _ _).symm`\n-- which converts to\n-- `funext fun _ => by convert (apply_dite Inv.inv _ _ _).symm`\n-- However this does not work, and we're not sure why.\n\n"}
{"name":"Function.extend_div","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Div γ\nf : α → β\ng₁ g₂ : α → γ\ne₁ e₂ : β → γ\n⊢ Eq (Function.extend f (HDiv.hDiv g₁ g₂) (HDiv.hDiv e₁ e₂)) (HDiv.hDiv (Function.extend f g₁ e₁) (Function.extend f g₂ e₂))","decl":"@[to_additive]\ntheorem extend_div [Div γ] (f : α → β) (g₁ g₂ : α → γ) (e₁ e₂ : β → γ) :\n    Function.extend f (g₁ / g₂) (e₁ / e₂) = Function.extend f g₁ e₁ / Function.extend f g₂ e₂ := by\n  classical\n  funext x\n  simp [Function.extend_def, apply_dite₂]\n-- Porting note: The Lean3 statement was\n-- `funext <| λ _, by convert (apply_dite2 (/) _ _ _ _ _).symm`\n-- which converts to\n-- `funext fun _ => by convert (apply_dite₂ (· / ·) _ _ _ _ _).symm`\n-- However this does not work, and we're not sure why.\n\n"}
{"name":"Function.extend_sub","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Sub γ\nf : α → β\ng₁ g₂ : α → γ\ne₁ e₂ : β → γ\n⊢ Eq (Function.extend f (HSub.hSub g₁ g₂) (HSub.hSub e₁ e₂)) (HSub.hSub (Function.extend f g₁ e₁) (Function.extend f g₂ e₂))","decl":"@[to_additive]\ntheorem extend_div [Div γ] (f : α → β) (g₁ g₂ : α → γ) (e₁ e₂ : β → γ) :\n    Function.extend f (g₁ / g₂) (e₁ / e₂) = Function.extend f g₁ e₁ / Function.extend f g₂ e₂ := by\n  classical\n  funext x\n  simp [Function.extend_def, apply_dite₂]\n-- Porting note: The Lean3 statement was\n-- `funext <| λ _, by convert (apply_dite2 (/) _ _ _ _ _).symm`\n-- which converts to\n-- `funext fun _ => by convert (apply_dite₂ (· / ·) _ _ _ _ _).symm`\n-- However this does not work, and we're not sure why.\n\n"}
{"name":"Function.comp_eq_const_iff","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nb : β\nf : α → β\ng : β → γ\nhg : Function.Injective g\n⊢ Iff (Eq (Function.comp g f) (Function.const α (g b))) (Eq f (Function.const α b))","decl":"lemma comp_eq_const_iff (b : β) (f : α → β) {g : β → γ} (hg : Injective g) :\n    g ∘ f = Function.const _ (g b) ↔ f = Function.const _ b :=\n  hg.comp_left.eq_iff' rfl\n\n"}
{"name":"Function.comp_eq_one_iff","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : One β\ninst✝ : One γ\nf : α → β\ng : β → γ\nhg : Function.Injective g\nhg0 : Eq (g 1) 1\n⊢ Iff (Eq (Function.comp g f) 1) (Eq f 1)","decl":"@[to_additive]\nlemma comp_eq_one_iff [One β] [One γ] (f : α → β) {g : β → γ} (hg : Injective g) (hg0 : g 1 = 1) :\n    g ∘ f = 1 ↔ f = 1 := by\n  simpa [hg0, const_one] using comp_eq_const_iff 1 f hg\n\n"}
{"name":"Function.comp_eq_zero_iff","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : Zero β\ninst✝ : Zero γ\nf : α → β\ng : β → γ\nhg : Function.Injective g\nhg0 : Eq (g 0) 0\n⊢ Iff (Eq (Function.comp g f) 0) (Eq f 0)","decl":"@[to_additive]\nlemma comp_eq_one_iff [One β] [One γ] (f : α → β) {g : β → γ} (hg : Injective g) (hg0 : g 1 = 1) :\n    g ∘ f = 1 ↔ f = 1 := by\n  simpa [hg0, const_one] using comp_eq_const_iff 1 f hg\n\n"}
{"name":"Function.comp_ne_one_iff","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : One β\ninst✝ : One γ\nf : α → β\ng : β → γ\nhg : Function.Injective g\nhg0 : Eq (g 1) 1\n⊢ Iff (Ne (Function.comp g f) 1) (Ne f 1)","decl":"@[to_additive]\nlemma comp_ne_one_iff [One β] [One γ] (f : α → β) {g : β → γ} (hg : Injective g) (hg0 : g 1 = 1) :\n    g ∘ f ≠ 1 ↔ f ≠ 1 :=\n  (comp_eq_one_iff f hg hg0).ne\n\n"}
{"name":"Function.comp_ne_zero_iff","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : Zero β\ninst✝ : Zero γ\nf : α → β\ng : β → γ\nhg : Function.Injective g\nhg0 : Eq (g 0) 0\n⊢ Iff (Ne (Function.comp g f) 0) (Ne f 0)","decl":"@[to_additive]\nlemma comp_ne_one_iff [One β] [One γ] (f : α → β) {g : β → γ} (hg : Injective g) (hg0 : g 1 = 1) :\n    g ∘ f ≠ 1 ↔ f ≠ 1 :=\n  (comp_eq_one_iff f hg hg0).ne\n\n"}
{"name":"Subsingleton.pi_single_eq","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nα : Type u_4\ninst✝² : DecidableEq I\ninst✝¹ : Subsingleton I\ninst✝ : Zero α\ni : I\nx : α\n⊢ Eq (Pi.single i x) fun x_1 => x","decl":"@[to_additive]\ntheorem Subsingleton.pi_mulSingle_eq {α : Type*} [DecidableEq I] [Subsingleton I] [One α]\n    (i : I) (x : α) : Pi.mulSingle i x = fun _ => x :=\n  funext fun j => by rw [Subsingleton.elim j i, Pi.mulSingle_eq_same]\n\n"}
{"name":"Subsingleton.pi_mulSingle_eq","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"I : Type u\nα : Type u_4\ninst✝² : DecidableEq I\ninst✝¹ : Subsingleton I\ninst✝ : One α\ni : I\nx : α\n⊢ Eq (Pi.mulSingle i x) fun x_1 => x","decl":"@[to_additive]\ntheorem Subsingleton.pi_mulSingle_eq {α : Type*} [DecidableEq I] [Subsingleton I] [One α]\n    (i : I) (x : α) : Pi.mulSingle i x = fun _ => x :=\n  funext fun j => by rw [Subsingleton.elim j i, Pi.mulSingle_eq_same]\n\n"}
{"name":"Sum.elim_one_one","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : One γ\n⊢ Eq (Sum.elim 1 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem elim_one_one [One γ] : Sum.elim (1 : α → γ) (1 : β → γ) = 1 :=\n  Sum.elim_const_const 1\n\n"}
{"name":"Sum.elim_zero_zero","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Zero γ\n⊢ Eq (Sum.elim 0 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem elim_one_one [One γ] : Sum.elim (1 : α → γ) (1 : β → γ) = 1 :=\n  Sum.elim_const_const 1\n\n"}
{"name":"Sum.elim_single_zero","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : DecidableEq α\ninst✝¹ : DecidableEq β\ninst✝ : Zero γ\ni : α\nc : γ\n⊢ Eq (Sum.elim (Pi.single i c) 0) (Pi.single (Sum.inl i) c)","decl":"@[to_additive (attr := simp)]\ntheorem elim_mulSingle_one [DecidableEq α] [DecidableEq β] [One γ] (i : α) (c : γ) :\n    Sum.elim (Pi.mulSingle i c) (1 : β → γ) = Pi.mulSingle (Sum.inl i) c := by\n  simp only [Pi.mulSingle, Sum.elim_update_left, elim_one_one]\n\n"}
{"name":"Sum.elim_mulSingle_one","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : DecidableEq α\ninst✝¹ : DecidableEq β\ninst✝ : One γ\ni : α\nc : γ\n⊢ Eq (Sum.elim (Pi.mulSingle i c) 1) (Pi.mulSingle (Sum.inl i) c)","decl":"@[to_additive (attr := simp)]\ntheorem elim_mulSingle_one [DecidableEq α] [DecidableEq β] [One γ] (i : α) (c : γ) :\n    Sum.elim (Pi.mulSingle i c) (1 : β → γ) = Pi.mulSingle (Sum.inl i) c := by\n  simp only [Pi.mulSingle, Sum.elim_update_left, elim_one_one]\n\n"}
{"name":"Sum.elim_one_mulSingle","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : DecidableEq α\ninst✝¹ : DecidableEq β\ninst✝ : One γ\ni : β\nc : γ\n⊢ Eq (Sum.elim 1 (Pi.mulSingle i c)) (Pi.mulSingle (Sum.inr i) c)","decl":"@[to_additive (attr := simp)]\ntheorem elim_one_mulSingle [DecidableEq α] [DecidableEq β] [One γ] (i : β) (c : γ) :\n    Sum.elim (1 : α → γ) (Pi.mulSingle i c) = Pi.mulSingle (Sum.inr i) c := by\n  simp only [Pi.mulSingle, Sum.elim_update_right, elim_one_one]\n\n"}
{"name":"Sum.elim_zero_single","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : DecidableEq α\ninst✝¹ : DecidableEq β\ninst✝ : Zero γ\ni : β\nc : γ\n⊢ Eq (Sum.elim 0 (Pi.single i c)) (Pi.single (Sum.inr i) c)","decl":"@[to_additive (attr := simp)]\ntheorem elim_one_mulSingle [DecidableEq α] [DecidableEq β] [One γ] (i : β) (c : γ) :\n    Sum.elim (1 : α → γ) (Pi.mulSingle i c) = Pi.mulSingle (Sum.inr i) c := by\n  simp only [Pi.mulSingle, Sum.elim_update_right, elim_one_one]\n\n"}
{"name":"Sum.elim_neg_neg","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\na : α → γ\nb : β → γ\ninst✝ : Neg γ\n⊢ Eq (Sum.elim (Neg.neg a) (Neg.neg b)) (Neg.neg (Sum.elim a b))","decl":"@[to_additive]\ntheorem elim_inv_inv [Inv γ] : Sum.elim a⁻¹ b⁻¹ = (Sum.elim a b)⁻¹ :=\n  (Sum.comp_elim Inv.inv a b).symm\n\n"}
{"name":"Sum.elim_inv_inv","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\na : α → γ\nb : β → γ\ninst✝ : Inv γ\n⊢ Eq (Sum.elim (Inv.inv a) (Inv.inv b)) (Inv.inv (Sum.elim a b))","decl":"@[to_additive]\ntheorem elim_inv_inv [Inv γ] : Sum.elim a⁻¹ b⁻¹ = (Sum.elim a b)⁻¹ :=\n  (Sum.comp_elim Inv.inv a b).symm\n\n"}
{"name":"Sum.elim_mul_mul","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\na a' : α → γ\nb b' : β → γ\ninst✝ : Mul γ\n⊢ Eq (Sum.elim (HMul.hMul a a') (HMul.hMul b b')) (HMul.hMul (Sum.elim a b) (Sum.elim a' b'))","decl":"@[to_additive]\ntheorem elim_mul_mul [Mul γ] : Sum.elim (a * a') (b * b') = Sum.elim a b * Sum.elim a' b' := by\n  ext x\n  cases x <;> rfl\n\n"}
{"name":"Sum.elim_add_add","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\na a' : α → γ\nb b' : β → γ\ninst✝ : Add γ\n⊢ Eq (Sum.elim (HAdd.hAdd a a') (HAdd.hAdd b b')) (HAdd.hAdd (Sum.elim a b) (Sum.elim a' b'))","decl":"@[to_additive]\ntheorem elim_mul_mul [Mul γ] : Sum.elim (a * a') (b * b') = Sum.elim a b * Sum.elim a' b' := by\n  ext x\n  cases x <;> rfl\n\n"}
{"name":"Sum.elim_sub_sub","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\na a' : α → γ\nb b' : β → γ\ninst✝ : Sub γ\n⊢ Eq (Sum.elim (HSub.hSub a a') (HSub.hSub b b')) (HSub.hSub (Sum.elim a b) (Sum.elim a' b'))","decl":"@[to_additive]\ntheorem elim_div_div [Div γ] : Sum.elim (a / a') (b / b') = Sum.elim a b / Sum.elim a' b' := by\n  ext x\n  cases x <;> rfl\n\n"}
{"name":"Sum.elim_div_div","module":"Mathlib.Algebra.Group.Pi.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\na a' : α → γ\nb b' : β → γ\ninst✝ : Div γ\n⊢ Eq (Sum.elim (HDiv.hDiv a a') (HDiv.hDiv b b')) (HDiv.hDiv (Sum.elim a b) (Sum.elim a' b'))","decl":"@[to_additive]\ntheorem elim_div_div [Div γ] : Sum.elim (a / a') (b / b') = Sum.elim a b / Sum.elim a' b' := by\n  ext x\n  cases x <;> rfl\n\n"}
