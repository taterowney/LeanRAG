{"name":"edist_le_Ico_sum_edist","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf : Nat → α\nm n : Nat\nh : LE.le m n\n⊢ LE.le (EDist.edist (f m) (f n)) ((Finset.Ico m n).sum fun i => EDist.edist (f i) (f (HAdd.hAdd i 1)))","decl":"/-- The triangle (polygon) inequality for sequences of points; `Finset.Ico` version. -/\ntheorem edist_le_Ico_sum_edist (f : ℕ → α) {m n} (h : m ≤ n) :\n    edist (f m) (f n) ≤ ∑ i ∈ Finset.Ico m n, edist (f i) (f (i + 1)) := by\n  induction n, h using Nat.le_induction with\n  | base => rw [Finset.Ico_self, Finset.sum_empty, edist_self]\n  | succ n hle ihn =>\n    calc\n      edist (f m) (f (n + 1)) ≤ edist (f m) (f n) + edist (f n) (f (n + 1)) := edist_triangle _ _ _\n      _ ≤ (∑ i ∈ Finset.Ico m n, _) + _ := add_le_add ihn le_rfl\n      _ = ∑ i ∈ Finset.Ico m (n + 1), _ := by\n      { rw [Nat.Ico_succ_right_eq_insert_Ico hle, Finset.sum_insert, add_comm]; simp }\n\n"}
{"name":"edist_le_range_sum_edist","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf : Nat → α\nn : Nat\n⊢ LE.le (EDist.edist (f 0) (f n)) ((Finset.range n).sum fun i => EDist.edist (f i) (f (HAdd.hAdd i 1)))","decl":"/-- The triangle (polygon) inequality for sequences of points; `Finset.range` version. -/\ntheorem edist_le_range_sum_edist (f : ℕ → α) (n : ℕ) :\n    edist (f 0) (f n) ≤ ∑ i ∈ Finset.range n, edist (f i) (f (i + 1)) :=\n  Nat.Ico_zero_eq_range ▸ edist_le_Ico_sum_edist f (Nat.zero_le n)\n\n"}
{"name":"edist_le_Ico_sum_of_edist_le","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf : Nat → α\nm n : Nat\nhmn : LE.le m n\nd : Nat → ENNReal\nhd : ∀ {k : Nat}, LE.le m k → LT.lt k n → LE.le (EDist.edist (f k) (f (HAdd.hAdd k 1))) (d k)\n⊢ LE.le (EDist.edist (f m) (f n)) ((Finset.Ico m n).sum fun i => d i)","decl":"/-- A version of `edist_le_Ico_sum_edist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem edist_le_Ico_sum_of_edist_le {f : ℕ → α} {m n} (hmn : m ≤ n) {d : ℕ → ℝ≥0∞}\n    (hd : ∀ {k}, m ≤ k → k < n → edist (f k) (f (k + 1)) ≤ d k) :\n    edist (f m) (f n) ≤ ∑ i ∈ Finset.Ico m n, d i :=\n  le_trans (edist_le_Ico_sum_edist f hmn) <|\n    Finset.sum_le_sum fun _k hk => hd (Finset.mem_Ico.1 hk).1 (Finset.mem_Ico.1 hk).2\n\n"}
{"name":"edist_le_range_sum_of_edist_le","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf : Nat → α\nn : Nat\nd : Nat → ENNReal\nhd : ∀ {k : Nat}, LT.lt k n → LE.le (EDist.edist (f k) (f (HAdd.hAdd k 1))) (d k)\n⊢ LE.le (EDist.edist (f 0) (f n)) ((Finset.range n).sum fun i => d i)","decl":"/-- A version of `edist_le_range_sum_edist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem edist_le_range_sum_of_edist_le {f : ℕ → α} (n : ℕ) {d : ℕ → ℝ≥0∞}\n    (hd : ∀ {k}, k < n → edist (f k) (f (k + 1)) ≤ d k) :\n    edist (f 0) (f n) ≤ ∑ i ∈ Finset.range n, d i :=\n  Nat.Ico_zero_eq_range ▸ edist_le_Ico_sum_of_edist_le (zero_le n) fun _ => hd\n\n"}
{"name":"EMetric.isUniformInducing_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : α → β\n⊢ Iff (IsUniformInducing f) (And (UniformContinuous f) (∀ (δ : ENNReal), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : α}, LT.lt (EDist.edist (f a) (f b)) ε → LT.lt (EDist.edist a b) δ)))","decl":"theorem isUniformInducing_iff [PseudoEMetricSpace β] {f : α → β} :\n    IsUniformInducing f ↔ UniformContinuous f ∧\n      ∀ δ > 0, ∃ ε > 0, ∀ {a b : α}, edist (f a) (f b) < ε → edist a b < δ :=\n  isUniformInducing_iff'.trans <| Iff.rfl.and <|\n    ((uniformity_basis_edist.comap _).le_basis_iff uniformity_basis_edist).trans <| by\n      simp only [subset_def, Prod.forall]; rfl\n\n"}
{"name":"EMetric.uniformInducing_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : α → β\n⊢ Iff (IsUniformInducing f) (And (UniformContinuous f) (∀ (δ : ENNReal), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : α}, LT.lt (EDist.edist (f a) (f b)) ε → LT.lt (EDist.edist a b) δ)))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_iff := isUniformInducing_iff\n\n"}
{"name":"EMetric.isUniformEmbedding_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : α → β\n⊢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (∀ (δ : ENNReal), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : α}, LT.lt (EDist.edist (f a) (f b)) ε → LT.lt (EDist.edist a b) δ))))","decl":"/-- ε-δ characterization of uniform embeddings on pseudoemetric spaces -/\nnonrec theorem isUniformEmbedding_iff [PseudoEMetricSpace β] {f : α → β} :\n    IsUniformEmbedding f ↔ Function.Injective f ∧ UniformContinuous f ∧\n      ∀ δ > 0, ∃ ε > 0, ∀ {a b : α}, edist (f a) (f b) < ε → edist a b < δ :=\n  (isUniformEmbedding_iff _).trans <| and_comm.trans <| Iff.rfl.and isUniformInducing_iff\n\n"}
{"name":"EMetric.uniformEmbedding_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : α → β\n⊢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (∀ (δ : ENNReal), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : α}, LT.lt (EDist.edist (f a) (f b)) ε → LT.lt (EDist.edist a b) δ))))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_iff := isUniformEmbedding_iff\n\n"}
{"name":"EMetric.controlled_of_isUniformEmbedding","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : α → β\nh : IsUniformEmbedding f\n⊢ And (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ {a b : α}, LT.lt (EDist.edist a b) δ → LT.lt (EDist.edist (f a) (f b)) ε)) (∀ (δ : ENNReal), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : α}, LT.lt (EDist.edist (f a) (f b)) ε → LT.lt (EDist.edist a b) δ))","decl":"/-- If a map between pseudoemetric spaces is a uniform embedding then the edistance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y`.\n\nIn fact, this lemma holds for a `IsUniformInducing` map.\nTODO: generalize? -/\ntheorem controlled_of_isUniformEmbedding [PseudoEMetricSpace β] {f : α → β}\n    (h : IsUniformEmbedding f) :\n    (∀ ε > 0, ∃ δ > 0, ∀ {a b : α}, edist a b < δ → edist (f a) (f b) < ε) ∧\n      ∀ δ > 0, ∃ ε > 0, ∀ {a b : α}, edist (f a) (f b) < ε → edist a b < δ :=\n  ⟨uniformContinuous_iff.1 h.uniformContinuous, (isUniformEmbedding_iff.1 h).2.2⟩\n\n"}
{"name":"EMetric.controlled_of_uniformEmbedding","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : α → β\nh : IsUniformEmbedding f\n⊢ And (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ {a b : α}, LT.lt (EDist.edist a b) δ → LT.lt (EDist.edist (f a) (f b)) ε)) (∀ (δ : ENNReal), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : α}, LT.lt (EDist.edist (f a) (f b)) ε → LT.lt (EDist.edist a b) δ))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias controlled_of_uniformEmbedding := controlled_of_isUniformEmbedding\n\n"}
{"name":"EMetric.cauchy_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf : Filter α\n⊢ Iff (Cauchy f) (And (Ne f Bot.bot) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun t => And (Membership.mem f t) (∀ (x : α), Membership.mem t x → ∀ (y : α), Membership.mem t y → LT.lt (EDist.edist x y) ε)))","decl":"/-- ε-δ characterization of Cauchy sequences on pseudoemetric spaces -/\nprotected theorem cauchy_iff {f : Filter α} :\n    Cauchy f ↔ f ≠ ⊥ ∧ ∀ ε > 0, ∃ t ∈ f, ∀ x, x ∈ t → ∀ y, y ∈ t → edist x y < ε := by\n  rw [← neBot_iff]; exact uniformity_basis_edist.cauchy_iff\n\n"}
{"name":"EMetric.complete_of_convergent_controlled_sequences","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nB : Nat → ENNReal\nhB : ∀ (n : Nat), LT.lt 0 (B n)\nH : ∀ (u : Nat → α), (∀ (N n m : Nat), LE.le N n → LE.le N m → LT.lt (EDist.edist (u n) (u m)) (B N)) → Exists fun x => Filter.Tendsto u Filter.atTop (nhds x)\n⊢ CompleteSpace α","decl":"/-- A very useful criterion to show that a space is complete is to show that all sequences\nwhich satisfy a bound of the form `edist (u n) (u m) < B N` for all `n m ≥ N` are\nconverging. This is often applied for `B N = 2^{-N}`, i.e., with a very fast convergence to\n`0`, which makes it possible to use arguments of converging series, while this is impossible\nto do in general for arbitrary Cauchy sequences. -/\ntheorem complete_of_convergent_controlled_sequences (B : ℕ → ℝ≥0∞) (hB : ∀ n, 0 < B n)\n    (H : ∀ u : ℕ → α, (∀ N n m : ℕ, N ≤ n → N ≤ m → edist (u n) (u m) < B N) →\n      ∃ x, Tendsto u atTop (𝓝 x)) :\n    CompleteSpace α :=\n  UniformSpace.complete_of_convergent_controlled_sequences\n    (fun n => { p : α × α | edist p.1 p.2 < B n }) (fun n => edist_mem_uniformity <| hB n) H\n\n"}
{"name":"EMetric.complete_of_cauchySeq_tendsto","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\na✝ : ∀ (u : Nat → α), CauchySeq u → Exists fun a => Filter.Tendsto u Filter.atTop (nhds a)\n⊢ CompleteSpace α","decl":"/-- A sequentially complete pseudoemetric space is complete. -/\ntheorem complete_of_cauchySeq_tendsto :\n    (∀ u : ℕ → α, CauchySeq u → ∃ a, Tendsto u atTop (𝓝 a)) → CompleteSpace α :=\n  UniformSpace.complete_of_cauchySeq_tendsto\n\n"}
{"name":"EMetric.tendstoLocallyUniformlyOn_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\nι : Type u_2\ninst✝ : TopologicalSpace β\nF : ι → β → α\nf : β → α\np : Filter ι\ns : Set β\n⊢ Iff (TendstoLocallyUniformlyOn F f p s) (∀ (ε : ENNReal), GT.gt ε 0 → ∀ (x : β), Membership.mem s x → Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Filter.Eventually (fun n => ∀ (y : β), Membership.mem t y → LT.lt (EDist.edist (f y) (F n y)) ε) p))","decl":"/-- Expressing locally uniform convergence on a set using `edist`. -/\ntheorem tendstoLocallyUniformlyOn_iff {ι : Type*} [TopologicalSpace β] {F : ι → β → α} {f : β → α}\n    {p : Filter ι} {s : Set β} :\n    TendstoLocallyUniformlyOn F f p s ↔\n      ∀ ε > 0, ∀ x ∈ s, ∃ t ∈ 𝓝[s] x, ∀ᶠ n in p, ∀ y ∈ t, edist (f y) (F n y) < ε := by\n  refine ⟨fun H ε hε => H _ (edist_mem_uniformity hε), fun H u hu x hx => ?_⟩\n  rcases mem_uniformity_edist.1 hu with ⟨ε, εpos, hε⟩\n  rcases H ε εpos x hx with ⟨t, ht, Ht⟩\n  exact ⟨t, ht, Ht.mono fun n hs x hx => hε (hs x hx)⟩\n\n"}
{"name":"EMetric.tendstoUniformlyOn_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoEMetricSpace α\nι : Type u_2\nF : ι → β → α\nf : β → α\np : Filter ι\ns : Set β\n⊢ Iff (TendstoUniformlyOn F f p s) (∀ (ε : ENNReal), GT.gt ε 0 → Filter.Eventually (fun n => ∀ (x : β), Membership.mem s x → LT.lt (EDist.edist (f x) (F n x)) ε) p)","decl":"/-- Expressing uniform convergence on a set using `edist`. -/\ntheorem tendstoUniformlyOn_iff {ι : Type*} {F : ι → β → α} {f : β → α} {p : Filter ι} {s : Set β} :\n    TendstoUniformlyOn F f p s ↔ ∀ ε > 0, ∀ᶠ n in p, ∀ x ∈ s, edist (f x) (F n x) < ε := by\n  refine ⟨fun H ε hε => H _ (edist_mem_uniformity hε), fun H u hu => ?_⟩\n  rcases mem_uniformity_edist.1 hu with ⟨ε, εpos, hε⟩\n  exact (H ε εpos).mono fun n hs x hx => hε (hs x hx)\n\n"}
{"name":"EMetric.tendstoLocallyUniformly_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\nι : Type u_2\ninst✝ : TopologicalSpace β\nF : ι → β → α\nf : β → α\np : Filter ι\n⊢ Iff (TendstoLocallyUniformly F f p) (∀ (ε : ENNReal), GT.gt ε 0 → ∀ (x : β), Exists fun t => And (Membership.mem (nhds x) t) (Filter.Eventually (fun n => ∀ (y : β), Membership.mem t y → LT.lt (EDist.edist (f y) (F n y)) ε) p))","decl":"/-- Expressing locally uniform convergence using `edist`. -/\ntheorem tendstoLocallyUniformly_iff {ι : Type*} [TopologicalSpace β] {F : ι → β → α} {f : β → α}\n    {p : Filter ι} :\n    TendstoLocallyUniformly F f p ↔\n      ∀ ε > 0, ∀ x : β, ∃ t ∈ 𝓝 x, ∀ᶠ n in p, ∀ y ∈ t, edist (f y) (F n y) < ε := by\n  simp only [← tendstoLocallyUniformlyOn_univ, tendstoLocallyUniformlyOn_iff, mem_univ,\n    forall_const, exists_prop, nhdsWithin_univ]\n\n"}
{"name":"EMetric.tendstoUniformly_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoEMetricSpace α\nι : Type u_2\nF : ι → β → α\nf : β → α\np : Filter ι\n⊢ Iff (TendstoUniformly F f p) (∀ (ε : ENNReal), GT.gt ε 0 → Filter.Eventually (fun n => ∀ (x : β), LT.lt (EDist.edist (f x) (F n x)) ε) p)","decl":"/-- Expressing uniform convergence using `edist`. -/\ntheorem tendstoUniformly_iff {ι : Type*} {F : ι → β → α} {f : β → α} {p : Filter ι} :\n    TendstoUniformly F f p ↔ ∀ ε > 0, ∀ᶠ n in p, ∀ x, edist (f x) (F n x) < ε := by\n  simp only [← tendstoUniformlyOn_univ, tendstoUniformlyOn_iff, mem_univ, forall_const]\n\n"}
{"name":"EMetric.inseparable_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\n⊢ Iff (Inseparable x y) (Eq (EDist.edist x y) 0)","decl":"theorem inseparable_iff : Inseparable x y ↔ edist x y = 0 := by\n  simp [inseparable_iff_mem_closure, mem_closure_iff, edist_comm, forall_lt_iff_le']\n\n"}
{"name":"Inseparable.edist_eq_zero","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\na✝ : Inseparable x y\n⊢ Eq (EDist.edist x y) 0","decl":"alias ⟨_root_.Inseparable.edist_eq_zero, _⟩ := EMetric.inseparable_iff\n\n-- see Note [nolint_ge]\n"}
{"name":"EMetric.cauchySeq_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : PseudoEMetricSpace α\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\nu : β → α\n⊢ Iff (CauchySeq u) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun N => ∀ (m : β), LE.le N m → ∀ (n : β), LE.le N n → LT.lt (EDist.edist (u m) (u n)) ε)","decl":"/-- In a pseudoemetric space, Cauchy sequences are characterized by the fact that, eventually,\nthe pseudoedistance between its elements is arbitrarily small -/\ntheorem cauchySeq_iff [Nonempty β] [SemilatticeSup β] {u : β → α} :\n    CauchySeq u ↔ ∀ ε > 0, ∃ N, ∀ m, N ≤ m → ∀ n, N ≤ n → edist (u m) (u n) < ε :=\n  uniformity_basis_edist.cauchySeq_iff\n\n"}
{"name":"EMetric.cauchySeq_iff'","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : PseudoEMetricSpace α\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\nu : β → α\n⊢ Iff (CauchySeq u) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun N => ∀ (n : β), GE.ge n N → LT.lt (EDist.edist (u n) (u N)) ε)","decl":"/-- A variation around the emetric characterization of Cauchy sequences -/\ntheorem cauchySeq_iff' [Nonempty β] [SemilatticeSup β] {u : β → α} :\n    CauchySeq u ↔ ∀ ε > (0 : ℝ≥0∞), ∃ N, ∀ n ≥ N, edist (u n) (u N) < ε :=\n  uniformity_basis_edist.cauchySeq_iff'\n\n"}
{"name":"EMetric.cauchySeq_iff_NNReal","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : PseudoEMetricSpace α\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\nu : β → α\n⊢ Iff (CauchySeq u) (∀ (ε : NNReal), LT.lt 0 ε → Exists fun N => ∀ (n : β), LE.le N n → LT.lt (EDist.edist (u n) (u N)) ↑ε)","decl":"/-- A variation of the emetric characterization of Cauchy sequences that deals with\n`ℝ≥0` upper bounds. -/\ntheorem cauchySeq_iff_NNReal [Nonempty β] [SemilatticeSup β] {u : β → α} :\n    CauchySeq u ↔ ∀ ε : ℝ≥0, 0 < ε → ∃ N, ∀ n, N ≤ n → edist (u n) (u N) < ε :=\n  uniformity_basis_edist_nnreal.cauchySeq_iff'\n\n"}
{"name":"EMetric.totallyBounded_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns : Set α\n⊢ Iff (TotallyBounded s) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun t => And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => EMetric.ball y ε)))","decl":"theorem totallyBounded_iff {s : Set α} :\n    TotallyBounded s ↔ ∀ ε > 0, ∃ t : Set α, t.Finite ∧ s ⊆ ⋃ y ∈ t, ball y ε :=\n  ⟨fun H _ε ε0 => H _ (edist_mem_uniformity ε0), fun H _r ru =>\n    let ⟨ε, ε0, hε⟩ := mem_uniformity_edist.1 ru\n    let ⟨t, ft, h⟩ := H ε ε0\n    ⟨t, ft, h.trans <| iUnion₂_mono fun _ _ _ => hε⟩⟩\n\n"}
{"name":"EMetric.totallyBounded_iff'","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns : Set α\n⊢ Iff (TotallyBounded s) (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun t => And (HasSubset.Subset t s) (And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => EMetric.ball y ε))))","decl":"theorem totallyBounded_iff' {s : Set α} :\n    TotallyBounded s ↔ ∀ ε > 0, ∃ t, t ⊆ s ∧ Set.Finite t ∧ s ⊆ ⋃ y ∈ t, ball y ε :=\n  ⟨fun H _ε ε0 => (totallyBounded_iff_subset.1 H) _ (edist_mem_uniformity ε0), fun H _r ru =>\n    let ⟨ε, ε0, hε⟩ := mem_uniformity_edist.1 ru\n    let ⟨t, _, ft, h⟩ := H ε ε0\n    ⟨t, ft, h.trans <| iUnion₂_mono fun _ _ _ => hε⟩⟩\n\n"}
{"name":"EMetric.subset_countable_closure_of_compact","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns : Set α\nhs : IsCompact s\n⊢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (HasSubset.Subset s (closure t)))","decl":"/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem subset_countable_closure_of_compact {s : Set α} (hs : IsCompact s) :\n    ∃ t, t ⊆ s ∧ t.Countable ∧ s ⊆ closure t := by\n  refine subset_countable_closure_of_almost_dense_set s fun ε hε => ?_\n  rcases totallyBounded_iff'.1 hs.totallyBounded ε hε with ⟨t, -, htf, hst⟩\n  exact ⟨t, htf.countable, hst.trans <| iUnion₂_mono fun _ _ => ball_subset_closedBall⟩\n\n"}
{"name":"EMetric.secondCountable_of_sigmaCompact","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : SigmaCompactSpace α\n⊢ SecondCountableTopology α","decl":"/-- A sigma compact pseudo emetric space has second countable topology. -/\ninstance (priority := 90) secondCountable_of_sigmaCompact [SigmaCompactSpace α] :\n    SecondCountableTopology α := by\n  suffices SeparableSpace α by exact UniformSpace.secondCountable_of_separable α\n  choose T _ hTc hsubT using fun n =>\n    subset_countable_closure_of_compact (isCompact_compactCovering α n)\n  refine ⟨⟨⋃ n, T n, countable_iUnion hTc, fun x => ?_⟩⟩\n  rcases iUnion_eq_univ_iff.1 (iUnion_compactCovering α) x with ⟨n, hn⟩\n  exact closure_mono (subset_iUnion _ n) (hsubT _ hn)\n\n"}
{"name":"EMetric.secondCountable_of_almost_dense_set","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nhs : ∀ (ε : ENNReal), GT.gt ε 0 → Exists fun t => And t.Countable (Eq (Set.iUnion fun x => Set.iUnion fun h => EMetric.closedBall x ε) Set.univ)\n⊢ SecondCountableTopology α","decl":"theorem secondCountable_of_almost_dense_set\n    (hs : ∀ ε > 0, ∃ t : Set α, t.Countable ∧ ⋃ x ∈ t, closedBall x ε = univ) :\n    SecondCountableTopology α := by\n  suffices SeparableSpace α from UniformSpace.secondCountable_of_separable α\n  have : ∀ ε > 0, ∃ t : Set α, Set.Countable t ∧ univ ⊆ ⋃ x ∈ t, closedBall x ε := by\n    simpa only [univ_subset_iff] using hs\n  rcases subset_countable_closure_of_almost_dense_set (univ : Set α) this with ⟨t, -, htc, ht⟩\n  exact ⟨⟨t, htc, fun x => ht (mem_univ x)⟩⟩\n\n"}
{"name":"EMetricSpace.instT0Space","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"γ : Type w\ninst✝ : EMetricSpace γ\n⊢ T0Space γ","decl":"/-- An emetric space is separated -/\ninstance (priority := 100) EMetricSpace.instT0Space : T0Space γ where\n  t0 _ _ h := eq_of_edist_eq_zero <| inseparable_iff.1 h\n\n"}
{"name":"EMetric.isUniformEmbedding_iff'","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"β : Type v\nγ : Type w\ninst✝¹ : EMetricSpace γ\ninst✝ : EMetricSpace β\nf : γ → β\n⊢ Iff (IsUniformEmbedding f) (And (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ {a b : γ}, LT.lt (EDist.edist a b) δ → LT.lt (EDist.edist (f a) (f b)) ε)) (∀ (δ : ENNReal), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : γ}, LT.lt (EDist.edist (f a) (f b)) ε → LT.lt (EDist.edist a b) δ)))","decl":"/-- A map between emetric spaces is a uniform embedding if and only if the edistance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y` and conversely. -/\ntheorem EMetric.isUniformEmbedding_iff' [EMetricSpace β] {f : γ → β} :\n    IsUniformEmbedding f ↔\n      (∀ ε > 0, ∃ δ > 0, ∀ {a b : γ}, edist a b < δ → edist (f a) (f b) < ε) ∧\n        ∀ δ > 0, ∃ ε > 0, ∀ {a b : γ}, edist (f a) (f b) < ε → edist a b < δ := by\n  rw [isUniformEmbedding_iff_isUniformInducing, isUniformInducing_iff, uniformContinuous_iff]\n\n"}
{"name":"EMetric.uniformEmbedding_iff'","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"β : Type v\nγ : Type w\ninst✝¹ : EMetricSpace γ\ninst✝ : EMetricSpace β\nf : γ → β\n⊢ Iff (IsUniformEmbedding f) (And (∀ (ε : ENNReal), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ {a b : γ}, LT.lt (EDist.edist a b) δ → LT.lt (EDist.edist (f a) (f b)) ε)) (∀ (δ : ENNReal), GT.gt δ 0 → Exists fun ε => And (GT.gt ε 0) (∀ {a b : γ}, LT.lt (EDist.edist (f a) (f b)) ε → LT.lt (EDist.edist a b) δ)))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias EMetric.uniformEmbedding_iff' := EMetric.isUniformEmbedding_iff'\n\n"}
{"name":"EMetric.countable_closure_of_compact","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"γ : Type w\ninst✝ : EMetricSpace γ\ns : Set γ\nhs : IsCompact s\n⊢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (Eq s (closure t)))","decl":"/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem countable_closure_of_compact {s : Set γ} (hs : IsCompact s) :\n    ∃ t, t ⊆ s ∧ t.Countable ∧ s = closure t := by\n  rcases subset_countable_closure_of_compact hs with ⟨t, hts, htc, hsub⟩\n  exact ⟨t, hts, htc, hsub.antisymm (closure_minimal hts hs.isClosed)⟩\n\n"}
{"name":"SeparationQuotient.edist_mk","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"X : Type u_1\ninst✝ : PseudoEMetricSpace X\nx y : X\n⊢ Eq (EDist.edist (SeparationQuotient.mk x) (SeparationQuotient.mk y)) (EDist.edist x y)","decl":"@[simp] theorem SeparationQuotient.edist_mk [PseudoEMetricSpace X] (x y : X) :\n    edist (mk x) (mk y) = edist x y :=\n  rfl\n\n"}
