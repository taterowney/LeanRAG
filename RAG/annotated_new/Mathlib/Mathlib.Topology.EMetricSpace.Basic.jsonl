{"name":"edist_le_Ico_sum_edist","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoEMetricSpace Î±\nf : Nat â†’ Î±\nm n : Nat\nh : LE.le m n\nâŠ¢ LE.le (EDist.edist (f m) (f n)) ((Finset.Ico m n).sum fun i => EDist.edist (f i) (f (HAdd.hAdd i 1)))","decl":"/-- The triangle (polygon) inequality for sequences of points; `Finset.Ico` version. -/\ntheorem edist_le_Ico_sum_edist (f : â„• â†’ Î±) {m n} (h : m â‰¤ n) :\n    edist (f m) (f n) â‰¤ âˆ‘ i âˆˆ Finset.Ico m n, edist (f i) (f (i + 1)) := by\n  induction n, h using Nat.le_induction with\n  | base => rw [Finset.Ico_self, Finset.sum_empty, edist_self]\n  | succ n hle ihn =>\n    calc\n      edist (f m) (f (n + 1)) â‰¤ edist (f m) (f n) + edist (f n) (f (n + 1)) := edist_triangle _ _ _\n      _ â‰¤ (âˆ‘ i âˆˆ Finset.Ico m n, _) + _ := add_le_add ihn le_rfl\n      _ = âˆ‘ i âˆˆ Finset.Ico m (n + 1), _ := by\n      { rw [Nat.Ico_succ_right_eq_insert_Ico hle, Finset.sum_insert, add_comm]; simp }\n\n"}
{"name":"edist_le_range_sum_edist","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoEMetricSpace Î±\nf : Nat â†’ Î±\nn : Nat\nâŠ¢ LE.le (EDist.edist (f 0) (f n)) ((Finset.range n).sum fun i => EDist.edist (f i) (f (HAdd.hAdd i 1)))","decl":"/-- The triangle (polygon) inequality for sequences of points; `Finset.range` version. -/\ntheorem edist_le_range_sum_edist (f : â„• â†’ Î±) (n : â„•) :\n    edist (f 0) (f n) â‰¤ âˆ‘ i âˆˆ Finset.range n, edist (f i) (f (i + 1)) :=\n  Nat.Ico_zero_eq_range â–¸ edist_le_Ico_sum_edist f (Nat.zero_le n)\n\n"}
{"name":"edist_le_Ico_sum_of_edist_le","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoEMetricSpace Î±\nf : Nat â†’ Î±\nm n : Nat\nhmn : LE.le m n\nd : Nat â†’ ENNReal\nhd : âˆ€ {k : Nat}, LE.le m k â†’ LT.lt k n â†’ LE.le (EDist.edist (f k) (f (HAdd.hAdd k 1))) (d k)\nâŠ¢ LE.le (EDist.edist (f m) (f n)) ((Finset.Ico m n).sum fun i => d i)","decl":"/-- A version of `edist_le_Ico_sum_edist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem edist_le_Ico_sum_of_edist_le {f : â„• â†’ Î±} {m n} (hmn : m â‰¤ n) {d : â„• â†’ â„â‰¥0âˆ}\n    (hd : âˆ€ {k}, m â‰¤ k â†’ k < n â†’ edist (f k) (f (k + 1)) â‰¤ d k) :\n    edist (f m) (f n) â‰¤ âˆ‘ i âˆˆ Finset.Ico m n, d i :=\n  le_trans (edist_le_Ico_sum_edist f hmn) <|\n    Finset.sum_le_sum fun _k hk => hd (Finset.mem_Ico.1 hk).1 (Finset.mem_Ico.1 hk).2\n\n"}
{"name":"edist_le_range_sum_of_edist_le","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoEMetricSpace Î±\nf : Nat â†’ Î±\nn : Nat\nd : Nat â†’ ENNReal\nhd : âˆ€ {k : Nat}, LT.lt k n â†’ LE.le (EDist.edist (f k) (f (HAdd.hAdd k 1))) (d k)\nâŠ¢ LE.le (EDist.edist (f 0) (f n)) ((Finset.range n).sum fun i => d i)","decl":"/-- A version of `edist_le_range_sum_edist` with each intermediate distance replaced\nwith an upper estimate. -/\ntheorem edist_le_range_sum_of_edist_le {f : â„• â†’ Î±} (n : â„•) {d : â„• â†’ â„â‰¥0âˆ}\n    (hd : âˆ€ {k}, k < n â†’ edist (f k) (f (k + 1)) â‰¤ d k) :\n    edist (f 0) (f n) â‰¤ âˆ‘ i âˆˆ Finset.range n, d i :=\n  Nat.Ico_zero_eq_range â–¸ edist_le_Ico_sum_of_edist_le (zero_le n) fun _ => hd\n\n"}
{"name":"EMetric.isUniformInducing_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformInducing f) (And (UniformContinuous f) (âˆ€ (Î´ : ENNReal), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î±}, LT.lt (EDist.edist (f a) (f b)) Îµ â†’ LT.lt (EDist.edist a b) Î´)))","decl":"theorem isUniformInducing_iff [PseudoEMetricSpace Î²] {f : Î± â†’ Î²} :\n    IsUniformInducing f â†” UniformContinuous f âˆ§\n      âˆ€ Î´ > 0, âˆƒ Îµ > 0, âˆ€ {a b : Î±}, edist (f a) (f b) < Îµ â†’ edist a b < Î´ :=\n  isUniformInducing_iff'.trans <| Iff.rfl.and <|\n    ((uniformity_basis_edist.comap _).le_basis_iff uniformity_basis_edist).trans <| by\n      simp only [subset_def, Prod.forall]; rfl\n\n"}
{"name":"EMetric.uniformInducing_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformInducing f) (And (UniformContinuous f) (âˆ€ (Î´ : ENNReal), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î±}, LT.lt (EDist.edist (f a) (f b)) Îµ â†’ LT.lt (EDist.edist a b) Î´)))","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_iff := isUniformInducing_iff\n\n"}
{"name":"EMetric.isUniformEmbedding_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (âˆ€ (Î´ : ENNReal), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î±}, LT.lt (EDist.edist (f a) (f b)) Îµ â†’ LT.lt (EDist.edist a b) Î´))))","decl":"/-- Îµ-Î´ characterization of uniform embeddings on pseudoemetric spaces -/\nnonrec theorem isUniformEmbedding_iff [PseudoEMetricSpace Î²] {f : Î± â†’ Î²} :\n    IsUniformEmbedding f â†” Function.Injective f âˆ§ UniformContinuous f âˆ§\n      âˆ€ Î´ > 0, âˆƒ Îµ > 0, âˆ€ {a b : Î±}, edist (f a) (f b) < Îµ â†’ edist a b < Î´ :=\n  (isUniformEmbedding_iff _).trans <| and_comm.trans <| Iff.rfl.and isUniformInducing_iff\n\n"}
{"name":"EMetric.uniformEmbedding_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (And (Function.Injective f) (And (UniformContinuous f) (âˆ€ (Î´ : ENNReal), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î±}, LT.lt (EDist.edist (f a) (f b)) Îµ â†’ LT.lt (EDist.edist a b) Î´))))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_iff := isUniformEmbedding_iff\n\n"}
{"name":"EMetric.controlled_of_isUniformEmbedding","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Î± â†’ Î²\nh : IsUniformEmbedding f\nâŠ¢ And (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ {a b : Î±}, LT.lt (EDist.edist a b) Î´ â†’ LT.lt (EDist.edist (f a) (f b)) Îµ)) (âˆ€ (Î´ : ENNReal), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î±}, LT.lt (EDist.edist (f a) (f b)) Îµ â†’ LT.lt (EDist.edist a b) Î´))","decl":"/-- If a map between pseudoemetric spaces is a uniform embedding then the edistance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y`.\n\nIn fact, this lemma holds for a `IsUniformInducing` map.\nTODO: generalize? -/\ntheorem controlled_of_isUniformEmbedding [PseudoEMetricSpace Î²] {f : Î± â†’ Î²}\n    (h : IsUniformEmbedding f) :\n    (âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ {a b : Î±}, edist a b < Î´ â†’ edist (f a) (f b) < Îµ) âˆ§\n      âˆ€ Î´ > 0, âˆƒ Îµ > 0, âˆ€ {a b : Î±}, edist (f a) (f b) < Îµ â†’ edist a b < Î´ :=\n  âŸ¨uniformContinuous_iff.1 h.uniformContinuous, (isUniformEmbedding_iff.1 h).2.2âŸ©\n\n"}
{"name":"EMetric.controlled_of_uniformEmbedding","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : Î± â†’ Î²\nh : IsUniformEmbedding f\nâŠ¢ And (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ {a b : Î±}, LT.lt (EDist.edist a b) Î´ â†’ LT.lt (EDist.edist (f a) (f b)) Îµ)) (âˆ€ (Î´ : ENNReal), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î±}, LT.lt (EDist.edist (f a) (f b)) Îµ â†’ LT.lt (EDist.edist a b) Î´))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias controlled_of_uniformEmbedding := controlled_of_isUniformEmbedding\n\n"}
{"name":"EMetric.cauchy_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoEMetricSpace Î±\nf : Filter Î±\nâŠ¢ Iff (Cauchy f) (And (Ne f Bot.bot) (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Exists fun t => And (Membership.mem f t) (âˆ€ (x : Î±), Membership.mem t x â†’ âˆ€ (y : Î±), Membership.mem t y â†’ LT.lt (EDist.edist x y) Îµ)))","decl":"/-- Îµ-Î´ characterization of Cauchy sequences on pseudoemetric spaces -/\nprotected theorem cauchy_iff {f : Filter Î±} :\n    Cauchy f â†” f â‰  âŠ¥ âˆ§ âˆ€ Îµ > 0, âˆƒ t âˆˆ f, âˆ€ x, x âˆˆ t â†’ âˆ€ y, y âˆˆ t â†’ edist x y < Îµ := by\n  rw [â† neBot_iff]; exact uniformity_basis_edist.cauchy_iff\n\n"}
{"name":"EMetric.complete_of_convergent_controlled_sequences","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoEMetricSpace Î±\nB : Nat â†’ ENNReal\nhB : âˆ€ (n : Nat), LT.lt 0 (B n)\nH : âˆ€ (u : Nat â†’ Î±), (âˆ€ (N n m : Nat), LE.le N n â†’ LE.le N m â†’ LT.lt (EDist.edist (u n) (u m)) (B N)) â†’ Exists fun x => Filter.Tendsto u Filter.atTop (nhds x)\nâŠ¢ CompleteSpace Î±","decl":"/-- A very useful criterion to show that a space is complete is to show that all sequences\nwhich satisfy a bound of the form `edist (u n) (u m) < B N` for all `n m â‰¥ N` are\nconverging. This is often applied for `B N = 2^{-N}`, i.e., with a very fast convergence to\n`0`, which makes it possible to use arguments of converging series, while this is impossible\nto do in general for arbitrary Cauchy sequences. -/\ntheorem complete_of_convergent_controlled_sequences (B : â„• â†’ â„â‰¥0âˆ) (hB : âˆ€ n, 0 < B n)\n    (H : âˆ€ u : â„• â†’ Î±, (âˆ€ N n m : â„•, N â‰¤ n â†’ N â‰¤ m â†’ edist (u n) (u m) < B N) â†’\n      âˆƒ x, Tendsto u atTop (ğ“ x)) :\n    CompleteSpace Î± :=\n  UniformSpace.complete_of_convergent_controlled_sequences\n    (fun n => { p : Î± Ã— Î± | edist p.1 p.2 < B n }) (fun n => edist_mem_uniformity <| hB n) H\n\n"}
{"name":"EMetric.complete_of_cauchySeq_tendsto","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoEMetricSpace Î±\naâœ : âˆ€ (u : Nat â†’ Î±), CauchySeq u â†’ Exists fun a => Filter.Tendsto u Filter.atTop (nhds a)\nâŠ¢ CompleteSpace Î±","decl":"/-- A sequentially complete pseudoemetric space is complete. -/\ntheorem complete_of_cauchySeq_tendsto :\n    (âˆ€ u : â„• â†’ Î±, CauchySeq u â†’ âˆƒ a, Tendsto u atTop (ğ“ a)) â†’ CompleteSpace Î± :=\n  UniformSpace.complete_of_cauchySeq_tendsto\n\n"}
{"name":"EMetric.tendstoLocallyUniformlyOn_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoEMetricSpace Î±\nÎ¹ : Type u_2\ninstâœ : TopologicalSpace Î²\nF : Î¹ â†’ Î² â†’ Î±\nf : Î² â†’ Î±\np : Filter Î¹\ns : Set Î²\nâŠ¢ Iff (TendstoLocallyUniformlyOn F f p s) (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ âˆ€ (x : Î²), Membership.mem s x â†’ Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Filter.Eventually (fun n => âˆ€ (y : Î²), Membership.mem t y â†’ LT.lt (EDist.edist (f y) (F n y)) Îµ) p))","decl":"/-- Expressing locally uniform convergence on a set using `edist`. -/\ntheorem tendstoLocallyUniformlyOn_iff {Î¹ : Type*} [TopologicalSpace Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±}\n    {p : Filter Î¹} {s : Set Î²} :\n    TendstoLocallyUniformlyOn F f p s â†”\n      âˆ€ Îµ > 0, âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, âˆ€á¶  n in p, âˆ€ y âˆˆ t, edist (f y) (F n y) < Îµ := by\n  refine âŸ¨fun H Îµ hÎµ => H _ (edist_mem_uniformity hÎµ), fun H u hu x hx => ?_âŸ©\n  rcases mem_uniformity_edist.1 hu with âŸ¨Îµ, Îµpos, hÎµâŸ©\n  rcases H Îµ Îµpos x hx with âŸ¨t, ht, HtâŸ©\n  exact âŸ¨t, ht, Ht.mono fun n hs x hx => hÎµ (hs x hx)âŸ©\n\n"}
{"name":"EMetric.tendstoUniformlyOn_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : PseudoEMetricSpace Î±\nÎ¹ : Type u_2\nF : Î¹ â†’ Î² â†’ Î±\nf : Î² â†’ Î±\np : Filter Î¹\ns : Set Î²\nâŠ¢ Iff (TendstoUniformlyOn F f p s) (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Filter.Eventually (fun n => âˆ€ (x : Î²), Membership.mem s x â†’ LT.lt (EDist.edist (f x) (F n x)) Îµ) p)","decl":"/-- Expressing uniform convergence on a set using `edist`. -/\ntheorem tendstoUniformlyOn_iff {Î¹ : Type*} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : Filter Î¹} {s : Set Î²} :\n    TendstoUniformlyOn F f p s â†” âˆ€ Îµ > 0, âˆ€á¶  n in p, âˆ€ x âˆˆ s, edist (f x) (F n x) < Îµ := by\n  refine âŸ¨fun H Îµ hÎµ => H _ (edist_mem_uniformity hÎµ), fun H u hu => ?_âŸ©\n  rcases mem_uniformity_edist.1 hu with âŸ¨Îµ, Îµpos, hÎµâŸ©\n  exact (H Îµ Îµpos).mono fun n hs x hx => hÎµ (hs x hx)\n\n"}
{"name":"EMetric.tendstoLocallyUniformly_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : PseudoEMetricSpace Î±\nÎ¹ : Type u_2\ninstâœ : TopologicalSpace Î²\nF : Î¹ â†’ Î² â†’ Î±\nf : Î² â†’ Î±\np : Filter Î¹\nâŠ¢ Iff (TendstoLocallyUniformly F f p) (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ âˆ€ (x : Î²), Exists fun t => And (Membership.mem (nhds x) t) (Filter.Eventually (fun n => âˆ€ (y : Î²), Membership.mem t y â†’ LT.lt (EDist.edist (f y) (F n y)) Îµ) p))","decl":"/-- Expressing locally uniform convergence using `edist`. -/\ntheorem tendstoLocallyUniformly_iff {Î¹ : Type*} [TopologicalSpace Î²] {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±}\n    {p : Filter Î¹} :\n    TendstoLocallyUniformly F f p â†”\n      âˆ€ Îµ > 0, âˆ€ x : Î², âˆƒ t âˆˆ ğ“ x, âˆ€á¶  n in p, âˆ€ y âˆˆ t, edist (f y) (F n y) < Îµ := by\n  simp only [â† tendstoLocallyUniformlyOn_univ, tendstoLocallyUniformlyOn_iff, mem_univ,\n    forall_const, exists_prop, nhdsWithin_univ]\n\n"}
{"name":"EMetric.tendstoUniformly_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœ : PseudoEMetricSpace Î±\nÎ¹ : Type u_2\nF : Î¹ â†’ Î² â†’ Î±\nf : Î² â†’ Î±\np : Filter Î¹\nâŠ¢ Iff (TendstoUniformly F f p) (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Filter.Eventually (fun n => âˆ€ (x : Î²), LT.lt (EDist.edist (f x) (F n x)) Îµ) p)","decl":"/-- Expressing uniform convergence using `edist`. -/\ntheorem tendstoUniformly_iff {Î¹ : Type*} {F : Î¹ â†’ Î² â†’ Î±} {f : Î² â†’ Î±} {p : Filter Î¹} :\n    TendstoUniformly F f p â†” âˆ€ Îµ > 0, âˆ€á¶  n in p, âˆ€ x, edist (f x) (F n x) < Îµ := by\n  simp only [â† tendstoUniformlyOn_univ, tendstoUniformlyOn_iff, mem_univ, forall_const]\n\n"}
{"name":"EMetric.inseparable_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoEMetricSpace Î±\nx y : Î±\nâŠ¢ Iff (Inseparable x y) (Eq (EDist.edist x y) 0)","decl":"theorem inseparable_iff : Inseparable x y â†” edist x y = 0 := by\n  simp [inseparable_iff_mem_closure, mem_closure_iff, edist_comm, forall_lt_iff_le']\n\n"}
{"name":"Inseparable.edist_eq_zero","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoEMetricSpace Î±\nx y : Î±\naâœ : Inseparable x y\nâŠ¢ Eq (EDist.edist x y) 0","decl":"alias âŸ¨_root_.Inseparable.edist_eq_zero, _âŸ© := EMetric.inseparable_iff\n\n-- see Note [nolint_ge]\n"}
{"name":"EMetric.cauchySeq_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : PseudoEMetricSpace Î±\ninstâœÂ¹ : Nonempty Î²\ninstâœ : SemilatticeSup Î²\nu : Î² â†’ Î±\nâŠ¢ Iff (CauchySeq u) (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Exists fun N => âˆ€ (m : Î²), LE.le N m â†’ âˆ€ (n : Î²), LE.le N n â†’ LT.lt (EDist.edist (u m) (u n)) Îµ)","decl":"/-- In a pseudoemetric space, Cauchy sequences are characterized by the fact that, eventually,\nthe pseudoedistance between its elements is arbitrarily small -/\ntheorem cauchySeq_iff [Nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} :\n    CauchySeq u â†” âˆ€ Îµ > 0, âˆƒ N, âˆ€ m, N â‰¤ m â†’ âˆ€ n, N â‰¤ n â†’ edist (u m) (u n) < Îµ :=\n  uniformity_basis_edist.cauchySeq_iff\n\n"}
{"name":"EMetric.cauchySeq_iff'","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : PseudoEMetricSpace Î±\ninstâœÂ¹ : Nonempty Î²\ninstâœ : SemilatticeSup Î²\nu : Î² â†’ Î±\nâŠ¢ Iff (CauchySeq u) (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Exists fun N => âˆ€ (n : Î²), GE.ge n N â†’ LT.lt (EDist.edist (u n) (u N)) Îµ)","decl":"/-- A variation around the emetric characterization of Cauchy sequences -/\ntheorem cauchySeq_iff' [Nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} :\n    CauchySeq u â†” âˆ€ Îµ > (0 : â„â‰¥0âˆ), âˆƒ N, âˆ€ n â‰¥ N, edist (u n) (u N) < Îµ :=\n  uniformity_basis_edist.cauchySeq_iff'\n\n"}
{"name":"EMetric.cauchySeq_iff_NNReal","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : PseudoEMetricSpace Î±\ninstâœÂ¹ : Nonempty Î²\ninstâœ : SemilatticeSup Î²\nu : Î² â†’ Î±\nâŠ¢ Iff (CauchySeq u) (âˆ€ (Îµ : NNReal), LT.lt 0 Îµ â†’ Exists fun N => âˆ€ (n : Î²), LE.le N n â†’ LT.lt (EDist.edist (u n) (u N)) â†‘Îµ)","decl":"/-- A variation of the emetric characterization of Cauchy sequences that deals with\n`â„â‰¥0` upper bounds. -/\ntheorem cauchySeq_iff_NNReal [Nonempty Î²] [SemilatticeSup Î²] {u : Î² â†’ Î±} :\n    CauchySeq u â†” âˆ€ Îµ : â„â‰¥0, 0 < Îµ â†’ âˆƒ N, âˆ€ n, N â‰¤ n â†’ edist (u n) (u N) < Îµ :=\n  uniformity_basis_edist_nnreal.cauchySeq_iff'\n\n"}
{"name":"EMetric.totallyBounded_iff","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoEMetricSpace Î±\ns : Set Î±\nâŠ¢ Iff (TotallyBounded s) (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Exists fun t => And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => EMetric.ball y Îµ)))","decl":"theorem totallyBounded_iff {s : Set Î±} :\n    TotallyBounded s â†” âˆ€ Îµ > 0, âˆƒ t : Set Î±, t.Finite âˆ§ s âŠ† â‹ƒ y âˆˆ t, ball y Îµ :=\n  âŸ¨fun H _Îµ Îµ0 => H _ (edist_mem_uniformity Îµ0), fun H _r ru =>\n    let âŸ¨Îµ, Îµ0, hÎµâŸ© := mem_uniformity_edist.1 ru\n    let âŸ¨t, ft, hâŸ© := H Îµ Îµ0\n    âŸ¨t, ft, h.trans <| iUnionâ‚‚_mono fun _ _ _ => hÎµâŸ©âŸ©\n\n"}
{"name":"EMetric.totallyBounded_iff'","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoEMetricSpace Î±\ns : Set Î±\nâŠ¢ Iff (TotallyBounded s) (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Exists fun t => And (HasSubset.Subset t s) (And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => EMetric.ball y Îµ))))","decl":"theorem totallyBounded_iff' {s : Set Î±} :\n    TotallyBounded s â†” âˆ€ Îµ > 0, âˆƒ t, t âŠ† s âˆ§ Set.Finite t âˆ§ s âŠ† â‹ƒ y âˆˆ t, ball y Îµ :=\n  âŸ¨fun H _Îµ Îµ0 => (totallyBounded_iff_subset.1 H) _ (edist_mem_uniformity Îµ0), fun H _r ru =>\n    let âŸ¨Îµ, Îµ0, hÎµâŸ© := mem_uniformity_edist.1 ru\n    let âŸ¨t, _, ft, hâŸ© := H Îµ Îµ0\n    âŸ¨t, ft, h.trans <| iUnionâ‚‚_mono fun _ _ _ => hÎµâŸ©âŸ©\n\n"}
{"name":"EMetric.subset_countable_closure_of_compact","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoEMetricSpace Î±\ns : Set Î±\nhs : IsCompact s\nâŠ¢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (HasSubset.Subset s (closure t)))","decl":"/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem subset_countable_closure_of_compact {s : Set Î±} (hs : IsCompact s) :\n    âˆƒ t, t âŠ† s âˆ§ t.Countable âˆ§ s âŠ† closure t := by\n  refine subset_countable_closure_of_almost_dense_set s fun Îµ hÎµ => ?_\n  rcases totallyBounded_iff'.1 hs.totallyBounded Îµ hÎµ with âŸ¨t, -, htf, hstâŸ©\n  exact âŸ¨t, htf.countable, hst.trans <| iUnionâ‚‚_mono fun _ _ => ball_subset_closedBallâŸ©\n\n"}
{"name":"EMetric.secondCountable_of_sigmaCompact","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : SigmaCompactSpace Î±\nâŠ¢ SecondCountableTopology Î±","decl":"/-- A sigma compact pseudo emetric space has second countable topology. -/\ninstance (priority := 90) secondCountable_of_sigmaCompact [SigmaCompactSpace Î±] :\n    SecondCountableTopology Î± := by\n  suffices SeparableSpace Î± by exact UniformSpace.secondCountable_of_separable Î±\n  choose T _ hTc hsubT using fun n =>\n    subset_countable_closure_of_compact (isCompact_compactCovering Î± n)\n  refine âŸ¨âŸ¨â‹ƒ n, T n, countable_iUnion hTc, fun x => ?_âŸ©âŸ©\n  rcases iUnion_eq_univ_iff.1 (iUnion_compactCovering Î±) x with âŸ¨n, hnâŸ©\n  exact closure_mono (subset_iUnion _ n) (hsubT _ hn)\n\n"}
{"name":"EMetric.secondCountable_of_almost_dense_set","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î± : Type u\ninstâœ : PseudoEMetricSpace Î±\nhs : âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Exists fun t => And t.Countable (Eq (Set.iUnion fun x => Set.iUnion fun h => EMetric.closedBall x Îµ) Set.univ)\nâŠ¢ SecondCountableTopology Î±","decl":"theorem secondCountable_of_almost_dense_set\n    (hs : âˆ€ Îµ > 0, âˆƒ t : Set Î±, t.Countable âˆ§ â‹ƒ x âˆˆ t, closedBall x Îµ = univ) :\n    SecondCountableTopology Î± := by\n  suffices SeparableSpace Î± from UniformSpace.secondCountable_of_separable Î±\n  have : âˆ€ Îµ > 0, âˆƒ t : Set Î±, Set.Countable t âˆ§ univ âŠ† â‹ƒ x âˆˆ t, closedBall x Îµ := by\n    simpa only [univ_subset_iff] using hs\n  rcases subset_countable_closure_of_almost_dense_set (univ : Set Î±) this with âŸ¨t, -, htc, htâŸ©\n  exact âŸ¨âŸ¨t, htc, fun x => ht (mem_univ x)âŸ©âŸ©\n\n"}
{"name":"EMetricSpace.instT0Space","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î³ : Type w\ninstâœ : EMetricSpace Î³\nâŠ¢ T0Space Î³","decl":"/-- An emetric space is separated -/\ninstance (priority := 100) EMetricSpace.instT0Space : T0Space Î³ where\n  t0 _ _ h := eq_of_edist_eq_zero <| inseparable_iff.1 h\n\n"}
{"name":"EMetric.isUniformEmbedding_iff'","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î² : Type v\nÎ³ : Type w\ninstâœÂ¹ : EMetricSpace Î³\ninstâœ : EMetricSpace Î²\nf : Î³ â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (And (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ {a b : Î³}, LT.lt (EDist.edist a b) Î´ â†’ LT.lt (EDist.edist (f a) (f b)) Îµ)) (âˆ€ (Î´ : ENNReal), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î³}, LT.lt (EDist.edist (f a) (f b)) Îµ â†’ LT.lt (EDist.edist a b) Î´)))","decl":"/-- A map between emetric spaces is a uniform embedding if and only if the edistance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y` and conversely. -/\ntheorem EMetric.isUniformEmbedding_iff' [EMetricSpace Î²] {f : Î³ â†’ Î²} :\n    IsUniformEmbedding f â†”\n      (âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ {a b : Î³}, edist a b < Î´ â†’ edist (f a) (f b) < Îµ) âˆ§\n        âˆ€ Î´ > 0, âˆƒ Îµ > 0, âˆ€ {a b : Î³}, edist (f a) (f b) < Îµ â†’ edist a b < Î´ := by\n  rw [isUniformEmbedding_iff_isUniformInducing, isUniformInducing_iff, uniformContinuous_iff]\n\n"}
{"name":"EMetric.uniformEmbedding_iff'","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î² : Type v\nÎ³ : Type w\ninstâœÂ¹ : EMetricSpace Î³\ninstâœ : EMetricSpace Î²\nf : Î³ â†’ Î²\nâŠ¢ Iff (IsUniformEmbedding f) (And (âˆ€ (Îµ : ENNReal), GT.gt Îµ 0 â†’ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ {a b : Î³}, LT.lt (EDist.edist a b) Î´ â†’ LT.lt (EDist.edist (f a) (f b)) Îµ)) (âˆ€ (Î´ : ENNReal), GT.gt Î´ 0 â†’ Exists fun Îµ => And (GT.gt Îµ 0) (âˆ€ {a b : Î³}, LT.lt (EDist.edist (f a) (f b)) Îµ â†’ LT.lt (EDist.edist a b) Î´)))","decl":"@[deprecated (since := \"2024-10-01\")]\nalias EMetric.uniformEmbedding_iff' := EMetric.isUniformEmbedding_iff'\n\n"}
{"name":"EMetric.countable_closure_of_compact","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"Î³ : Type w\ninstâœ : EMetricSpace Î³\ns : Set Î³\nhs : IsCompact s\nâŠ¢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (Eq s (closure t)))","decl":"/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem countable_closure_of_compact {s : Set Î³} (hs : IsCompact s) :\n    âˆƒ t, t âŠ† s âˆ§ t.Countable âˆ§ s = closure t := by\n  rcases subset_countable_closure_of_compact hs with âŸ¨t, hts, htc, hsubâŸ©\n  exact âŸ¨t, hts, htc, hsub.antisymm (closure_minimal hts hs.isClosed)âŸ©\n\n"}
{"name":"SeparationQuotient.edist_mk","module":"Mathlib.Topology.EMetricSpace.Basic","initialProofState":"X : Type u_1\ninstâœ : PseudoEMetricSpace X\nx y : X\nâŠ¢ Eq (EDist.edist (SeparationQuotient.mk x) (SeparationQuotient.mk y)) (EDist.edist x y)","decl":"@[simp] theorem SeparationQuotient.edist_mk [PseudoEMetricSpace X] (x y : X) :\n    edist (mk x) (mk y) = edist x y :=\n  rfl\n\n"}
