{"name":"AddChar.zmod_intCast","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"n : Nat\ninst✝ : NeZero n\nx y : Int\n⊢ Eq ((AddChar.zmod n ↑x) ↑y) (Circle.exp (HMul.hMul (HMul.hMul 2 Real.pi) (HDiv.hDiv (HMul.hMul ↑x ↑y) ↑n)))","decl":"@[simp] lemma zmod_intCast (x y : ℤ) : zmod n x y = exp (2 * π * (x * y / n)) := by\n  simp [zmod, ← Int.cast_mul x y, -Int.cast_mul, ZMod.toAddCircle_intCast,\n    AddCircle.toCircle_apply_mk]\n\n"}
{"name":"AddChar.zmod_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (AddChar.zmod n 0) 1","decl":"@[simp] lemma zmod_zero : zmod n 0 = 1 :=\n  DFunLike.ext _ _ <| by simp [ZMod.intCast_surjective.forall, zmod]\n\n"}
{"name":"AddChar.zmod_add","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"n : Nat\ninst✝ : NeZero n\nx y : ZMod n\n⊢ Eq (AddChar.zmod n (HAdd.hAdd x y)) (HMul.hMul (AddChar.zmod n x) (AddChar.zmod n y))","decl":"@[simp] lemma zmod_add : ∀ x y : ZMod n, zmod n (x + y) = zmod n x * zmod n y := by\n  simp [DFunLike.ext_iff, ← Int.cast_add, zmod, add_mul, add_div, map_add_eq_mul]\n\n"}
{"name":"AddChar.zmod_injective","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Function.Injective (AddChar.zmod n)","decl":"lemma zmod_injective : Injective (zmod n) := by\n  simp_rw [Injective, ZMod.intCast_surjective.forall]\n  rintro x y h\n  have hn : (n : ℝ) ≠ 0 := NeZero.ne _\n  simpa [pi_ne_zero, exp_inj, hn, CharP.intCast_eq_intCast (ZMod n) n] using\n    (zmod_intCast ..).symm.trans <| (DFunLike.congr_fun h ((1 : ℤ) : ZMod n)).trans <|\n      zmod_intCast ..\n\n"}
{"name":"AddChar.zmod_inj","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"n : Nat\ninst✝ : NeZero n\nx y : ZMod n\n⊢ Iff (Eq (AddChar.zmod n x) (AddChar.zmod n y)) (Eq x y)","decl":"@[simp] lemma zmod_inj {x y : ZMod n} : zmod n x = zmod n y ↔ x = y := zmod_injective.eq_iff\n\n"}
{"name":"AddChar.card_eq","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\ninst✝ : Fintype α\n⊢ Eq (Fintype.card (AddChar α Complex)) (Fintype.card α)","decl":"@[simp] lemma card_eq [Fintype α] : card (AddChar α ℂ) = card α := by\n  obtain ⟨ι, _, n, hn, ⟨e⟩⟩ := AddCommGroup.equiv_directSum_zmod_of_finite' α\n  classical\n  have hn' i : NeZero (n i) := by have := hn i; exact ⟨by positivity⟩\n  let f : α → AddChar α ℂ := fun a ↦ coeHom.compAddChar ((mkZModAux n <| e a).compAddMonoidHom e)\n  have hf : Injective f := circleEquivComplex.injective.comp\n    ((compAddMonoidHom_injective_left _ e.surjective).comp <| mkZModAux_injective.comp <|\n      DFunLike.coe_injective.comp <| e.injective.comp Additive.ofMul.injective)\n  exact (card_addChar_le _ _).antisymm (Fintype.card_le_of_injective _ hf)\n\n"}
{"name":"AddChar.zmodAddEquiv_apply","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"n : Nat\ninst✝ : NeZero n\nx : ZMod n\n⊢ Eq (AddChar.zmodAddEquiv x) (AddChar.circleEquivComplex (AddChar.zmod n x))","decl":"@[simp] lemma zmodAddEquiv_apply (x : ZMod n) :\n    zmodAddEquiv x = circleEquivComplex (zmod n x) := rfl\n\n"}
{"name":"AddChar.coe_complexBasis","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\ninst✝ : Finite α\n⊢ Eq (⇑(AddChar.complexBasis α)) DFunLike.coe","decl":"@[simp, norm_cast]\nlemma coe_complexBasis : ⇑(complexBasis α) = ((⇑) : AddChar α ℂ → α → ℂ) := by\n  rw [complexBasis, coe_basisOfLinearIndependentOfCardEqFinrank]\n\n"}
{"name":"AddChar.complexBasis_apply","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\ninst✝ : Finite α\nψ : AddChar α Complex\n⊢ Eq ((AddChar.complexBasis α) ψ) ⇑ψ","decl":"@[simp]\nlemma complexBasis_apply (ψ : AddChar α ℂ) : complexBasis α ψ = ψ := by rw [coe_complexBasis]\n\n"}
{"name":"AddChar.exists_apply_ne_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\na : α\ninst✝ : Finite α\n⊢ Iff (Exists fun ψ => Ne (ψ a) 1) (Ne a 0)","decl":"lemma exists_apply_ne_zero : (∃ ψ : AddChar α ℂ, ψ a ≠ 1) ↔ a ≠ 0 := by\n  refine ⟨?_, fun ha ↦ ?_⟩\n  · rintro ⟨ψ, hψ⟩ rfl\n    exact hψ ψ.map_zero_eq_one\n  classical\n  by_contra! h\n  let f : α → ℂ := fun b ↦ if a = b then 1 else 0\n  have h₀ := congr_fun ((complexBasis α).sum_repr f) 0\n  have h₁ := congr_fun ((complexBasis α).sum_repr f) a\n  simp only [complexBasis_apply, Fintype.sum_apply, Pi.smul_apply, h, smul_eq_mul, mul_one,\n    map_zero_eq_one, if_pos rfl, if_neg ha, f] at h₀ h₁\n  exact one_ne_zero (h₁.symm.trans h₀)\n\n"}
{"name":"AddChar.forall_apply_eq_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\na : α\ninst✝ : Finite α\n⊢ Iff (∀ (ψ : AddChar α Complex), Eq (ψ a) 1) (Eq a 0)","decl":"lemma forall_apply_eq_zero : (∀ ψ : AddChar α ℂ, ψ a = 1) ↔ a = 0 := by\n  simpa using exists_apply_ne_zero.not\n\n"}
{"name":"AddChar.doubleDualEmb_injective","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\ninst✝ : Finite α\n⊢ Function.Injective ⇑AddChar.doubleDualEmb","decl":"lemma doubleDualEmb_injective : Injective (doubleDualEmb : α → AddChar (AddChar α ℂ) ℂ) :=\n  doubleDualEmb.ker_eq_bot_iff.1 <| eq_bot_iff.2 fun a ha ↦\n    forall_apply_eq_zero.1 fun ψ ↦ by simpa using DFunLike.congr_fun ha (Additive.ofMul ψ)\n\n"}
{"name":"AddChar.doubleDualEmb_bijective","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\ninst✝ : Finite α\n⊢ Function.Bijective ⇑AddChar.doubleDualEmb","decl":"lemma doubleDualEmb_bijective : Bijective (doubleDualEmb : α → AddChar (AddChar α ℂ) ℂ) := by\n  cases nonempty_fintype α\n  exact (Fintype.bijective_iff_injective_and_card _).2\n    ⟨doubleDualEmb_injective, card_eq.symm.trans card_eq.symm⟩\n\n"}
{"name":"AddChar.doubleDualEmb_inj","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\na b : α\ninst✝ : Finite α\n⊢ Iff (Eq (AddChar.doubleDualEmb a) (AddChar.doubleDualEmb b)) (Eq a b)","decl":"@[simp]\nlemma doubleDualEmb_inj : (doubleDualEmb a : AddChar (AddChar α ℂ) ℂ) = doubleDualEmb b ↔ a = b :=\n  doubleDualEmb_injective.eq_iff\n\n"}
{"name":"AddChar.doubleDualEmb_eq_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\na : α\ninst✝ : Finite α\n⊢ Iff (Eq (AddChar.doubleDualEmb a) 0) (Eq a 0)","decl":"@[simp] lemma doubleDualEmb_eq_zero : (doubleDualEmb a : AddChar (AddChar α ℂ) ℂ) = 0 ↔ a = 0 := by\n  rw [← map_zero doubleDualEmb, doubleDualEmb_inj]\n\n"}
{"name":"AddChar.doubleDualEmb_ne_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\na : α\ninst✝ : Finite α\n⊢ Iff (Ne (AddChar.doubleDualEmb a) 0) (Ne a 0)","decl":"lemma doubleDualEmb_ne_zero : (doubleDualEmb a : AddChar (AddChar α ℂ) ℂ) ≠ 0 ↔ a ≠ 0 :=\n  doubleDualEmb_eq_zero.not\n\n"}
{"name":"AddChar.coe_doubleDualEquiv","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\ninst✝ : Finite α\n⊢ Eq ⇑AddChar.doubleDualEquiv ⇑AddChar.doubleDualEmb","decl":"@[simp]\nlemma coe_doubleDualEquiv : ⇑(doubleDualEquiv : α ≃+ AddChar (AddChar α ℂ) ℂ) = doubleDualEmb := rfl\n\n"}
{"name":"AddChar.doubleDualEmb_doubleDualEquiv_symm_apply","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\ninst✝ : Finite α\na : AddChar (AddChar α Complex) Complex\n⊢ Eq (AddChar.doubleDualEmb (AddChar.doubleDualEquiv.symm a)) a","decl":"@[simp] lemma doubleDualEmb_doubleDualEquiv_symm_apply (a : AddChar (AddChar α ℂ) ℂ) :\n    doubleDualEmb (doubleDualEquiv.symm a) = a :=\n  doubleDualEquiv.apply_symm_apply _\n\n"}
{"name":"AddChar.doubleDualEquiv_symm_doubleDualEmb_apply","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\ninst✝ : Finite α\na : AddChar (AddChar α Complex) Complex\n⊢ Eq (AddChar.doubleDualEquiv.symm (AddChar.doubleDualEmb a)) a","decl":"@[simp] lemma doubleDualEquiv_symm_doubleDualEmb_apply (a : AddChar (AddChar α ℂ) ℂ) :\n    doubleDualEquiv.symm (doubleDualEmb a) = a := doubleDualEquiv.symm_apply_apply _\n\n"}
{"name":"AddChar.sum_apply_eq_ite","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝² : AddCommGroup α\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Finset.univ.sum fun ψ => ψ a) (ite (Eq a 0) (↑(Fintype.card α)) 0)","decl":"lemma sum_apply_eq_ite [Fintype α] [DecidableEq α] (a : α) :\n    ∑ ψ : AddChar α ℂ, ψ a = if a = 0 then (Fintype.card α : ℂ) else 0 := by\n  simpa using sum_eq_ite (doubleDualEmb a : AddChar (AddChar α ℂ) ℂ)\n\n"}
{"name":"AddChar.expect_apply_eq_ite","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝² : AddCommGroup α\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Finset.univ.expect fun ψ => ψ a) (ite (Eq a 0) 1 0)","decl":"lemma expect_apply_eq_ite [Fintype α] [DecidableEq α] (a : α) :\n    𝔼 ψ : AddChar α ℂ, ψ a = if a = 0 then 1 else 0 := by\n  simpa using expect_eq_ite (doubleDualEmb a : AddChar (AddChar α ℂ) ℂ)\n\n"}
{"name":"AddChar.sum_apply_eq_zero_iff_ne_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\na : α\ninst✝ : Finite α\n⊢ Iff (Eq (Finset.univ.sum fun ψ => ψ a) 0) (Ne a 0)","decl":"lemma sum_apply_eq_zero_iff_ne_zero [Finite α] : ∑ ψ : AddChar α ℂ, ψ a = 0 ↔ a ≠ 0 := by\n  classical\n  cases nonempty_fintype α\n  rw [sum_apply_eq_ite, Ne.ite_eq_right_iff]\n  exact Nat.cast_ne_zero.2 Fintype.card_ne_zero\n\n"}
{"name":"AddChar.sum_apply_ne_zero_iff_eq_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\na : α\ninst✝ : Finite α\n⊢ Iff (Ne (Finset.univ.sum fun ψ => ψ a) 0) (Eq a 0)","decl":"lemma sum_apply_ne_zero_iff_eq_zero [Finite α] : ∑ ψ : AddChar α ℂ, ψ a ≠ 0 ↔ a = 0 :=\n  sum_apply_eq_zero_iff_ne_zero.not_left\n\n"}
{"name":"AddChar.expect_apply_eq_zero_iff_ne_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\na : α\ninst✝ : Finite α\n⊢ Iff (Eq (Finset.univ.expect fun ψ => ψ a) 0) (Ne a 0)","decl":"lemma expect_apply_eq_zero_iff_ne_zero [Finite α] : 𝔼 ψ : AddChar α ℂ, ψ a = 0 ↔ a ≠ 0 := by\n  classical\n  cases nonempty_fintype α\n  rw [expect_apply_eq_ite, one_ne_zero.ite_eq_right_iff]\n\n"}
{"name":"AddChar.expect_apply_ne_zero_iff_eq_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\na : α\ninst✝ : Finite α\n⊢ Iff (Ne (Finset.univ.expect fun ψ => ψ a) 0) (Eq a 0)","decl":"lemma expect_apply_ne_zero_iff_eq_zero [Finite α] : 𝔼 ψ : AddChar α ℂ, ψ a ≠ 0 ↔ a = 0 :=\n  expect_apply_eq_zero_iff_ne_zero.not_left\n\n"}
