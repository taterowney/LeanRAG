{"name":"AddChar.zmod_intCast","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"n : Nat\ninstâœ : NeZero n\nx y : Int\nâŠ¢ Eq ((AddChar.zmod n â†‘x) â†‘y) (Circle.exp (HMul.hMul (HMul.hMul 2 Real.pi) (HDiv.hDiv (HMul.hMul â†‘x â†‘y) â†‘n)))","decl":"@[simp] lemma zmod_intCast (x y : â„¤) : zmod n x y = exp (2 * Ï€ * (x * y / n)) := by\n  simp [zmod, â† Int.cast_mul x y, -Int.cast_mul, ZMod.toAddCircle_intCast,\n    AddCircle.toCircle_apply_mk]\n\n"}
{"name":"AddChar.zmod_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"n : Nat\ninstâœ : NeZero n\nâŠ¢ Eq (AddChar.zmod n 0) 1","decl":"@[simp] lemma zmod_zero : zmod n 0 = 1 :=\n  DFunLike.ext _ _ <| by simp [ZMod.intCast_surjective.forall, zmod]\n\n"}
{"name":"AddChar.zmod_add","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"n : Nat\ninstâœ : NeZero n\nx y : ZMod n\nâŠ¢ Eq (AddChar.zmod n (HAdd.hAdd x y)) (HMul.hMul (AddChar.zmod n x) (AddChar.zmod n y))","decl":"@[simp] lemma zmod_add : âˆ€ x y : ZMod n, zmod n (x + y) = zmod n x * zmod n y := by\n  simp [DFunLike.ext_iff, â† Int.cast_add, zmod, add_mul, add_div, map_add_eq_mul]\n\n"}
{"name":"AddChar.zmod_injective","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"n : Nat\ninstâœ : NeZero n\nâŠ¢ Function.Injective (AddChar.zmod n)","decl":"lemma zmod_injective : Injective (zmod n) := by\n  simp_rw [Injective, ZMod.intCast_surjective.forall]\n  rintro x y h\n  have hn : (n : â„) â‰  0 := NeZero.ne _\n  simpa [pi_ne_zero, exp_inj, hn, CharP.intCast_eq_intCast (ZMod n) n] using\n    (zmod_intCast ..).symm.trans <| (DFunLike.congr_fun h ((1 : â„¤) : ZMod n)).trans <|\n      zmod_intCast ..\n\n"}
{"name":"AddChar.zmod_inj","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"n : Nat\ninstâœ : NeZero n\nx y : ZMod n\nâŠ¢ Iff (Eq (AddChar.zmod n x) (AddChar.zmod n y)) (Eq x y)","decl":"@[simp] lemma zmod_inj {x y : ZMod n} : zmod n x = zmod n y â†” x = y := zmod_injective.eq_iff\n\n"}
{"name":"AddChar.card_eq","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : Fintype Î±\nâŠ¢ Eq (Fintype.card (AddChar Î± Complex)) (Fintype.card Î±)","decl":"@[simp] lemma card_eq [Fintype Î±] : card (AddChar Î± â„‚) = card Î± := by\n  obtain âŸ¨Î¹, _, n, hn, âŸ¨eâŸ©âŸ© := AddCommGroup.equiv_directSum_zmod_of_finite' Î±\n  classical\n  have hn' i : NeZero (n i) := by have := hn i; exact âŸ¨by positivityâŸ©\n  let f : Î± â†’ AddChar Î± â„‚ := fun a â†¦ coeHom.compAddChar ((mkZModAux n <| e a).compAddMonoidHom e)\n  have hf : Injective f := circleEquivComplex.injective.comp\n    ((compAddMonoidHom_injective_left _ e.surjective).comp <| mkZModAux_injective.comp <|\n      DFunLike.coe_injective.comp <| e.injective.comp Additive.ofMul.injective)\n  exact (card_addChar_le _ _).antisymm (Fintype.card_le_of_injective _ hf)\n\n"}
{"name":"AddChar.zmodAddEquiv_apply","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"n : Nat\ninstâœ : NeZero n\nx : ZMod n\nâŠ¢ Eq (AddChar.zmodAddEquiv x) (AddChar.circleEquivComplex (AddChar.zmod n x))","decl":"@[simp] lemma zmodAddEquiv_apply (x : ZMod n) :\n    zmodAddEquiv x = circleEquivComplex (zmod n x) := rfl\n\n"}
{"name":"AddChar.coe_complexBasis","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : Finite Î±\nâŠ¢ Eq (â‡‘(AddChar.complexBasis Î±)) DFunLike.coe","decl":"@[simp, norm_cast]\nlemma coe_complexBasis : â‡‘(complexBasis Î±) = ((â‡‘) : AddChar Î± â„‚ â†’ Î± â†’ â„‚) := by\n  rw [complexBasis, coe_basisOfLinearIndependentOfCardEqFinrank]\n\n"}
{"name":"AddChar.complexBasis_apply","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : Finite Î±\nÏˆ : AddChar Î± Complex\nâŠ¢ Eq ((AddChar.complexBasis Î±) Ïˆ) â‡‘Ïˆ","decl":"@[simp]\nlemma complexBasis_apply (Ïˆ : AddChar Î± â„‚) : complexBasis Î± Ïˆ = Ïˆ := by rw [coe_complexBasis]\n\n"}
{"name":"AddChar.exists_apply_ne_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\na : Î±\ninstâœ : Finite Î±\nâŠ¢ Iff (Exists fun Ïˆ => Ne (Ïˆ a) 1) (Ne a 0)","decl":"lemma exists_apply_ne_zero : (âˆƒ Ïˆ : AddChar Î± â„‚, Ïˆ a â‰  1) â†” a â‰  0 := by\n  refine âŸ¨?_, fun ha â†¦ ?_âŸ©\n  Â· rintro âŸ¨Ïˆ, hÏˆâŸ© rfl\n    exact hÏˆ Ïˆ.map_zero_eq_one\n  classical\n  by_contra! h\n  let f : Î± â†’ â„‚ := fun b â†¦ if a = b then 1 else 0\n  have hâ‚€ := congr_fun ((complexBasis Î±).sum_repr f) 0\n  have hâ‚ := congr_fun ((complexBasis Î±).sum_repr f) a\n  simp only [complexBasis_apply, Fintype.sum_apply, Pi.smul_apply, h, smul_eq_mul, mul_one,\n    map_zero_eq_one, if_pos rfl, if_neg ha, f] at hâ‚€ hâ‚\n  exact one_ne_zero (hâ‚.symm.trans hâ‚€)\n\n"}
{"name":"AddChar.forall_apply_eq_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\na : Î±\ninstâœ : Finite Î±\nâŠ¢ Iff (âˆ€ (Ïˆ : AddChar Î± Complex), Eq (Ïˆ a) 1) (Eq a 0)","decl":"lemma forall_apply_eq_zero : (âˆ€ Ïˆ : AddChar Î± â„‚, Ïˆ a = 1) â†” a = 0 := by\n  simpa using exists_apply_ne_zero.not\n\n"}
{"name":"AddChar.doubleDualEmb_injective","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : Finite Î±\nâŠ¢ Function.Injective â‡‘AddChar.doubleDualEmb","decl":"lemma doubleDualEmb_injective : Injective (doubleDualEmb : Î± â†’ AddChar (AddChar Î± â„‚) â„‚) :=\n  doubleDualEmb.ker_eq_bot_iff.1 <| eq_bot_iff.2 fun a ha â†¦\n    forall_apply_eq_zero.1 fun Ïˆ â†¦ by simpa using DFunLike.congr_fun ha (Additive.ofMul Ïˆ)\n\n"}
{"name":"AddChar.doubleDualEmb_bijective","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : Finite Î±\nâŠ¢ Function.Bijective â‡‘AddChar.doubleDualEmb","decl":"lemma doubleDualEmb_bijective : Bijective (doubleDualEmb : Î± â†’ AddChar (AddChar Î± â„‚) â„‚) := by\n  cases nonempty_fintype Î±\n  exact (Fintype.bijective_iff_injective_and_card _).2\n    âŸ¨doubleDualEmb_injective, card_eq.symm.trans card_eq.symmâŸ©\n\n"}
{"name":"AddChar.doubleDualEmb_inj","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\na b : Î±\ninstâœ : Finite Î±\nâŠ¢ Iff (Eq (AddChar.doubleDualEmb a) (AddChar.doubleDualEmb b)) (Eq a b)","decl":"@[simp]\nlemma doubleDualEmb_inj : (doubleDualEmb a : AddChar (AddChar Î± â„‚) â„‚) = doubleDualEmb b â†” a = b :=\n  doubleDualEmb_injective.eq_iff\n\n"}
{"name":"AddChar.doubleDualEmb_eq_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\na : Î±\ninstâœ : Finite Î±\nâŠ¢ Iff (Eq (AddChar.doubleDualEmb a) 0) (Eq a 0)","decl":"@[simp] lemma doubleDualEmb_eq_zero : (doubleDualEmb a : AddChar (AddChar Î± â„‚) â„‚) = 0 â†” a = 0 := by\n  rw [â† map_zero doubleDualEmb, doubleDualEmb_inj]\n\n"}
{"name":"AddChar.doubleDualEmb_ne_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\na : Î±\ninstâœ : Finite Î±\nâŠ¢ Iff (Ne (AddChar.doubleDualEmb a) 0) (Ne a 0)","decl":"lemma doubleDualEmb_ne_zero : (doubleDualEmb a : AddChar (AddChar Î± â„‚) â„‚) â‰  0 â†” a â‰  0 :=\n  doubleDualEmb_eq_zero.not\n\n"}
{"name":"AddChar.coe_doubleDualEquiv","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : Finite Î±\nâŠ¢ Eq â‡‘AddChar.doubleDualEquiv â‡‘AddChar.doubleDualEmb","decl":"@[simp]\nlemma coe_doubleDualEquiv : â‡‘(doubleDualEquiv : Î± â‰ƒ+ AddChar (AddChar Î± â„‚) â„‚) = doubleDualEmb := rfl\n\n"}
{"name":"AddChar.doubleDualEmb_doubleDualEquiv_symm_apply","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : Finite Î±\na : AddChar (AddChar Î± Complex) Complex\nâŠ¢ Eq (AddChar.doubleDualEmb (AddChar.doubleDualEquiv.symm a)) a","decl":"@[simp] lemma doubleDualEmb_doubleDualEquiv_symm_apply (a : AddChar (AddChar Î± â„‚) â„‚) :\n    doubleDualEmb (doubleDualEquiv.symm a) = a :=\n  doubleDualEquiv.apply_symm_apply _\n\n"}
{"name":"AddChar.doubleDualEquiv_symm_doubleDualEmb_apply","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : Finite Î±\na : AddChar (AddChar Î± Complex) Complex\nâŠ¢ Eq (AddChar.doubleDualEquiv.symm (AddChar.doubleDualEmb a)) a","decl":"@[simp] lemma doubleDualEquiv_symm_doubleDualEmb_apply (a : AddChar (AddChar Î± â„‚) â„‚) :\n    doubleDualEquiv.symm (doubleDualEmb a) = a := doubleDualEquiv.symm_apply_apply _\n\n"}
{"name":"AddChar.sum_apply_eq_ite","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : Fintype Î±\ninstâœ : DecidableEq Î±\na : Î±\nâŠ¢ Eq (Finset.univ.sum fun Ïˆ => Ïˆ a) (ite (Eq a 0) (â†‘(Fintype.card Î±)) 0)","decl":"lemma sum_apply_eq_ite [Fintype Î±] [DecidableEq Î±] (a : Î±) :\n    âˆ‘ Ïˆ : AddChar Î± â„‚, Ïˆ a = if a = 0 then (Fintype.card Î± : â„‚) else 0 := by\n  simpa using sum_eq_ite (doubleDualEmb a : AddChar (AddChar Î± â„‚) â„‚)\n\n"}
{"name":"AddChar.expect_apply_eq_ite","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ² : AddCommGroup Î±\ninstâœÂ¹ : Fintype Î±\ninstâœ : DecidableEq Î±\na : Î±\nâŠ¢ Eq (Finset.univ.expect fun Ïˆ => Ïˆ a) (ite (Eq a 0) 1 0)","decl":"lemma expect_apply_eq_ite [Fintype Î±] [DecidableEq Î±] (a : Î±) :\n    ğ”¼ Ïˆ : AddChar Î± â„‚, Ïˆ a = if a = 0 then 1 else 0 := by\n  simpa using expect_eq_ite (doubleDualEmb a : AddChar (AddChar Î± â„‚) â„‚)\n\n"}
{"name":"AddChar.sum_apply_eq_zero_iff_ne_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\na : Î±\ninstâœ : Finite Î±\nâŠ¢ Iff (Eq (Finset.univ.sum fun Ïˆ => Ïˆ a) 0) (Ne a 0)","decl":"lemma sum_apply_eq_zero_iff_ne_zero [Finite Î±] : âˆ‘ Ïˆ : AddChar Î± â„‚, Ïˆ a = 0 â†” a â‰  0 := by\n  classical\n  cases nonempty_fintype Î±\n  rw [sum_apply_eq_ite, Ne.ite_eq_right_iff]\n  exact Nat.cast_ne_zero.2 Fintype.card_ne_zero\n\n"}
{"name":"AddChar.sum_apply_ne_zero_iff_eq_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\na : Î±\ninstâœ : Finite Î±\nâŠ¢ Iff (Ne (Finset.univ.sum fun Ïˆ => Ïˆ a) 0) (Eq a 0)","decl":"lemma sum_apply_ne_zero_iff_eq_zero [Finite Î±] : âˆ‘ Ïˆ : AddChar Î± â„‚, Ïˆ a â‰  0 â†” a = 0 :=\n  sum_apply_eq_zero_iff_ne_zero.not_left\n\n"}
{"name":"AddChar.expect_apply_eq_zero_iff_ne_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\na : Î±\ninstâœ : Finite Î±\nâŠ¢ Iff (Eq (Finset.univ.expect fun Ïˆ => Ïˆ a) 0) (Ne a 0)","decl":"lemma expect_apply_eq_zero_iff_ne_zero [Finite Î±] : ğ”¼ Ïˆ : AddChar Î± â„‚, Ïˆ a = 0 â†” a â‰  0 := by\n  classical\n  cases nonempty_fintype Î±\n  rw [expect_apply_eq_ite, one_ne_zero.ite_eq_right_iff]\n\n"}
{"name":"AddChar.expect_apply_ne_zero_iff_eq_zero","module":"Mathlib.Analysis.Fourier.FiniteAbelian.PontryaginDuality","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : AddCommGroup Î±\na : Î±\ninstâœ : Finite Î±\nâŠ¢ Iff (Ne (Finset.univ.expect fun Ïˆ => Ïˆ a) 0) (Eq a 0)","decl":"lemma expect_apply_ne_zero_iff_eq_zero [Finite Î±] : ğ”¼ Ïˆ : AddChar Î± â„‚, Ïˆ a â‰  0 â†” a = 0 :=\n  expect_apply_eq_zero_iff_ne_zero.not_left\n\n"}
