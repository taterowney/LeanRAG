{"name":"QuotientGroup.measurableSMul","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝⁵ : Group G\nΓ : Subgroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalGroup G\ninst✝¹ : BorelSpace G\ninst✝ : BorelSpace (HasQuotient.Quotient G Γ)\n⊢ MeasurableSMul G (HasQuotient.Quotient G Γ)","decl":"/-- Measurability of the action of the topological group `G` on the left-coset space `G / Γ`. -/\n@[to_additive \"Measurability of the action of the additive topological group `G` on the left-coset\n  space `G / Γ`.\"]\ninstance QuotientGroup.measurableSMul {G : Type*} [Group G] {Γ : Subgroup G} [MeasurableSpace G]\n    [TopologicalSpace G] [TopologicalGroup G] [BorelSpace G] [BorelSpace (G ⧸ Γ)] :\n    MeasurableSMul G (G ⧸ Γ) where\n  measurable_const_smul g := (continuous_const_smul g).measurable\n  measurable_smul_const _ := (continuous_id.smul continuous_const).measurable\n\n"}
{"name":"QuotientAddGroup.measurableVAdd","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝⁵ : AddGroup G\nΓ : AddSubgroup G\ninst✝⁴ : MeasurableSpace G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : BorelSpace G\ninst✝ : BorelSpace (HasQuotient.Quotient G Γ)\n⊢ MeasurableVAdd G (HasQuotient.Quotient G Γ)","decl":"/-- Measurability of the action of the topological group `G` on the left-coset space `G / Γ`. -/\n@[to_additive \"Measurability of the action of the additive topological group `G` on the left-coset\n  space `G / Γ`.\"]\ninstance QuotientGroup.measurableSMul {G : Type*} [Group G] {Γ : Subgroup G} [MeasurableSpace G]\n    [TopologicalSpace G] [TopologicalGroup G] [BorelSpace G] [BorelSpace (G ⧸ Γ)] :\n    MeasurableSMul G (G ⧸ Γ) where\n  measurable_const_smul g := (continuous_const_smul g).measurable\n  measurable_smul_const _ := (continuous_id.smul continuous_const).measurable\n\n"}
{"name":"measurePreserving_quotientAddGroup_mk_of_AddQuotientMeasureEqMeasurePreimage","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : MeasurableSpace G\nν : MeasureTheory.Measure G\nΓ : AddSubgroup G\n𝓕 : Set G\nh𝓕 : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) 𝓕 ν\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\ninst✝ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ\n⊢ MeasureTheory.MeasurePreserving QuotientAddGroup.mk (ν.restrict 𝓕) μ","decl":"/-- Given a subgroup `Γ` of a topological group `G` with measure `ν`, and a measure 'μ' on the\n  quotient `G ⧸ Γ` satisfying `QuotientMeasureEqMeasurePreimage`, the restriction\n  of `ν` to a fundamental domain is measure-preserving with respect to `μ`. -/\n@[to_additive]\ntheorem measurePreserving_quotientGroup_mk_of_QuotientMeasureEqMeasurePreimage\n    {𝓕 : Set G} (h𝓕 : IsFundamentalDomain Γ.op 𝓕 ν) (μ : Measure (G ⧸ Γ))\n    [QuotientMeasureEqMeasurePreimage ν μ] :\n    MeasurePreserving (@QuotientGroup.mk G _ Γ) (ν.restrict 𝓕) μ :=\n  h𝓕.measurePreserving_quotient_mk μ\n\n"}
{"name":"measurePreserving_quotientGroup_mk_of_QuotientMeasureEqMeasurePreimage","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : MeasurableSpace G\nν : MeasureTheory.Measure G\nΓ : Subgroup G\n𝓕 : Set G\nh𝓕 : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) 𝓕 ν\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\ninst✝ : MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ\n⊢ MeasureTheory.MeasurePreserving QuotientGroup.mk (ν.restrict 𝓕) μ","decl":"/-- Given a subgroup `Γ` of a topological group `G` with measure `ν`, and a measure 'μ' on the\n  quotient `G ⧸ Γ` satisfying `QuotientMeasureEqMeasurePreimage`, the restriction\n  of `ν` to a fundamental domain is measure-preserving with respect to `μ`. -/\n@[to_additive]\ntheorem measurePreserving_quotientGroup_mk_of_QuotientMeasureEqMeasurePreimage\n    {𝓕 : Set G} (h𝓕 : IsFundamentalDomain Γ.op 𝓕 ν) (μ : Measure (G ⧸ Γ))\n    [QuotientMeasureEqMeasurePreimage ν μ] :\n    MeasurePreserving (@QuotientGroup.mk G _ Γ) (ν.restrict 𝓕) μ :=\n  h𝓕.measurePreserving_quotient_mk μ\n\n"}
{"name":"MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝⁹ : Group G\ninst✝⁸ : MeasurableSpace G\nν : MeasureTheory.Measure G\nΓ : Subgroup G\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\ninst✝⁷ : MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : BorelSpace G\ninst✝³ : PolishSpace G\ninst✝² : T2Space (HasQuotient.Quotient G Γ)\ninst✝¹ : SecondCountableTopology (HasQuotient.Quotient G Γ)\ninst✝ : ν.IsMulLeftInvariant\nhasFun : MeasureTheory.HasFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) G ν\n⊢ MeasureTheory.SMulInvariantMeasure G (HasQuotient.Quotient G Γ) μ","decl":"/-- If `μ` satisfies `QuotientMeasureEqMeasurePreimage` relative to a both left- and right-\n  invariant measure `ν` on `G`, then it is a `G` invariant measure on `G ⧸ Γ`. -/\n@[to_additive]\nlemma MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient\n    [IsMulLeftInvariant ν] [hasFun : HasFundamentalDomain Γ.op G ν] :\n    SMulInvariantMeasure G (G ⧸ Γ) μ where\n  measure_preimage_smul g A hA := by\n    have meas_π : Measurable π := continuous_quotient_mk'.measurable\n    obtain ⟨𝓕, h𝓕⟩ := hasFun.ExistsIsFundamentalDomain\n    have h𝓕_translate_fundom : IsFundamentalDomain Γ.op (g • 𝓕) ν := h𝓕.smul_of_comm g\n    -- TODO: why `rw` fails with both of these rewrites?\n    erw [h𝓕.projection_respects_measure_apply (μ := μ)\n      (meas_π (measurableSet_preimage (measurable_const_smul g) hA)),\n      h𝓕_translate_fundom.projection_respects_measure_apply (μ := μ) hA]\n    change ν ((π ⁻¹' _) ∩ _) = ν ((π ⁻¹' _) ∩ _)\n    set π_preA := π ⁻¹' A\n    have : π ⁻¹' ((fun x : G ⧸ Γ => g • x) ⁻¹' A) = (g * ·) ⁻¹' π_preA := by ext1; simp [π_preA]\n    rw [this]\n    have : ν ((g * ·) ⁻¹' π_preA ∩ 𝓕) = ν (π_preA ∩ (g⁻¹ * ·) ⁻¹' 𝓕) := by\n      trans ν ((g * ·) ⁻¹' (π_preA ∩ (g⁻¹ * ·) ⁻¹' 𝓕))\n      · rw [preimage_inter]\n        congr 2\n        simp [Set.preimage]\n      rw [measure_preimage_mul]\n    rw [this, ← preimage_smul_inv]; rfl\n\n"}
{"name":"MeasureTheory.AddQuotientMeasureEqMeasurePreimage.vaddInvariantMeasure_quotient","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝⁹ : AddGroup G\ninst✝⁸ : MeasurableSpace G\nν : MeasureTheory.Measure G\nΓ : AddSubgroup G\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\ninst✝⁷ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : BorelSpace G\ninst✝³ : PolishSpace G\ninst✝² : T2Space (HasQuotient.Quotient G Γ)\ninst✝¹ : SecondCountableTopology (HasQuotient.Quotient G Γ)\ninst✝ : ν.IsAddLeftInvariant\nhasFun : MeasureTheory.HasAddFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) G ν\n⊢ MeasureTheory.VAddInvariantMeasure G (HasQuotient.Quotient G Γ) μ","decl":"/-- If `μ` satisfies `QuotientMeasureEqMeasurePreimage` relative to a both left- and right-\n  invariant measure `ν` on `G`, then it is a `G` invariant measure on `G ⧸ Γ`. -/\n@[to_additive]\nlemma MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient\n    [IsMulLeftInvariant ν] [hasFun : HasFundamentalDomain Γ.op G ν] :\n    SMulInvariantMeasure G (G ⧸ Γ) μ where\n  measure_preimage_smul g A hA := by\n    have meas_π : Measurable π := continuous_quotient_mk'.measurable\n    obtain ⟨𝓕, h𝓕⟩ := hasFun.ExistsIsFundamentalDomain\n    have h𝓕_translate_fundom : IsFundamentalDomain Γ.op (g • 𝓕) ν := h𝓕.smul_of_comm g\n    -- TODO: why `rw` fails with both of these rewrites?\n    erw [h𝓕.projection_respects_measure_apply (μ := μ)\n      (meas_π (measurableSet_preimage (measurable_const_smul g) hA)),\n      h𝓕_translate_fundom.projection_respects_measure_apply (μ := μ) hA]\n    change ν ((π ⁻¹' _) ∩ _) = ν ((π ⁻¹' _) ∩ _)\n    set π_preA := π ⁻¹' A\n    have : π ⁻¹' ((fun x : G ⧸ Γ => g • x) ⁻¹' A) = (g * ·) ⁻¹' π_preA := by ext1; simp [π_preA]\n    rw [this]\n    have : ν ((g * ·) ⁻¹' π_preA ∩ 𝓕) = ν (π_preA ∩ (g⁻¹ * ·) ⁻¹' 𝓕) := by\n      trans ν ((g * ·) ⁻¹' (π_preA ∩ (g⁻¹ * ·) ⁻¹' 𝓕))\n      · rw [preimage_inter]\n        congr 2\n        simp [Set.preimage]\n      rw [measure_preimage_mul]\n    rw [this, ← preimage_smul_inv]; rfl\n\n"}
{"name":"MeasureTheory.AddQuotientMeasureEqMeasurePreimage.addInvariantMeasure_quotient","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹⁰ : AddGroup G\ninst✝⁹ : MeasurableSpace G\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : TopologicalAddGroup G\ninst✝⁶ : BorelSpace G\ninst✝⁵ : PolishSpace G\nΓ : AddSubgroup G\ninst✝⁴ : Γ.Normal\ninst✝³ : T2Space (HasQuotient.Quotient G Γ)\ninst✝² : SecondCountableTopology (HasQuotient.Quotient G Γ)\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\nν : MeasureTheory.Measure G\ninst✝¹ : ν.IsAddLeftInvariant\nhasFun : MeasureTheory.HasAddFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) G ν\ninst✝ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ\n⊢ μ.IsAddLeftInvariant","decl":"/-- If `μ` on `G ⧸ Γ` satisfies `QuotientMeasureEqMeasurePreimage` relative to a both left- and\n  right-invariant measure on `G` and `Γ` is a normal subgroup, then `μ` is a left-invariant\n  measure. -/\n@[to_additive \"If `μ` on `G ⧸ Γ` satisfies `AddQuotientMeasureEqMeasurePreimage` relative to a both\n  left- and right-invariant measure on `G` and `Γ` is a normal subgroup, then `μ` is a\n  left-invariant measure.\"]\nlemma MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient\n    [hasFun : HasFundamentalDomain Γ.op G ν] [QuotientMeasureEqMeasurePreimage ν μ] :\n    μ.IsMulLeftInvariant where\n  map_mul_left_eq_self x := by\n    ext A hA\n    obtain ⟨x₁, h⟩ := @Quotient.exists_rep _ (QuotientGroup.leftRel Γ) x\n    convert measure_preimage_smul μ x₁ A using 1\n    · rw [← h, Measure.map_apply (measurable_const_mul _) hA]\n      simp [← MulAction.Quotient.coe_smul_out, ← Quotient.mk''_eq_mk]\n    exact smulInvariantMeasure_quotient ν\n\n"}
{"name":"MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹⁰ : Group G\ninst✝⁹ : MeasurableSpace G\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : TopologicalGroup G\ninst✝⁶ : BorelSpace G\ninst✝⁵ : PolishSpace G\nΓ : Subgroup G\ninst✝⁴ : Γ.Normal\ninst✝³ : T2Space (HasQuotient.Quotient G Γ)\ninst✝² : SecondCountableTopology (HasQuotient.Quotient G Γ)\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\nν : MeasureTheory.Measure G\ninst✝¹ : ν.IsMulLeftInvariant\nhasFun : MeasureTheory.HasFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) G ν\ninst✝ : MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ\n⊢ μ.IsMulLeftInvariant","decl":"/-- If `μ` on `G ⧸ Γ` satisfies `QuotientMeasureEqMeasurePreimage` relative to a both left- and\n  right-invariant measure on `G` and `Γ` is a normal subgroup, then `μ` is a left-invariant\n  measure. -/\n@[to_additive \"If `μ` on `G ⧸ Γ` satisfies `AddQuotientMeasureEqMeasurePreimage` relative to a both\n  left- and right-invariant measure on `G` and `Γ` is a normal subgroup, then `μ` is a\n  left-invariant measure.\"]\nlemma MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient\n    [hasFun : HasFundamentalDomain Γ.op G ν] [QuotientMeasureEqMeasurePreimage ν μ] :\n    μ.IsMulLeftInvariant where\n  map_mul_left_eq_self x := by\n    ext A hA\n    obtain ⟨x₁, h⟩ := @Quotient.exists_rep _ (QuotientGroup.leftRel Γ) x\n    convert measure_preimage_smul μ x₁ A using 1\n    · rw [← h, Measure.map_apply (measurable_const_mul _) hA]\n      simp [← MulAction.Quotient.coe_smul_out, ← Quotient.mk''_eq_mk]\n    exact smulInvariantMeasure_quotient ν\n\n"}
{"name":"MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹⁴ : Group G\ninst✝¹³ : MeasurableSpace G\ninst✝¹² : TopologicalSpace G\ninst✝¹¹ : TopologicalGroup G\ninst✝¹⁰ : BorelSpace G\ninst✝⁹ : PolishSpace G\nΓ : Subgroup G\ninst✝⁸ : Γ.Normal\ninst✝⁷ : T2Space (HasQuotient.Quotient G Γ)\ninst✝⁶ : SecondCountableTopology (HasQuotient.Quotient G Γ)\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\nν : MeasureTheory.Measure G\ninst✝⁵ : ν.IsMulLeftInvariant\ninst✝⁴ : Countable (Subtype fun x => Membership.mem Γ x)\ninst✝³ : ν.IsMulRightInvariant\ninst✝² : MeasureTheory.SigmaFinite ν\ninst✝¹ : μ.IsMulLeftInvariant\ninst✝ : MeasureTheory.SigmaFinite μ\ns : Set G\nfund_dom_s : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) s ν\nV : Set (HasQuotient.Quotient G Γ)\nmeas_V : MeasurableSet V\nneZeroV : Ne (μ V) 0\nhV : Eq (μ V) (ν (Inter.inter (Set.preimage QuotientGroup.mk V) s))\nneTopV : Ne (μ V) Top.top\n⊢ MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ","decl":"/-- Assume that a measure `μ` is `IsMulLeftInvariant`, that the action of `Γ` on `G` has a\nmeasurable fundamental domain `s` with positive finite volume, and that there is a single measurable\nset `V ⊆ G ⧸ Γ` along which the pullback of `μ` and `ν` agree (so the scaling is right). Then\n`μ` satisfies `QuotientMeasureEqMeasurePreimage`. The main tool of the proof is the uniqueness of\nleft invariant measures, if normalized by a single positive finite-measured set. -/\n@[to_additive\n\"Assume that a measure `μ` is `IsAddLeftInvariant`, that the action of `Γ` on `G` has a\nmeasurable fundamental domain `s` with positive finite volume, and that there is a single measurable\nset `V ⊆ G ⧸ Γ` along which the pullback of `μ` and `ν` agree (so the scaling is right). Then\n`μ` satisfies `AddQuotientMeasureEqMeasurePreimage`. The main tool of the proof is the uniqueness of\nleft invariant measures, if normalized by a single positive finite-measured set.\"]\ntheorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}\n    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}\n    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))\n    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by\n  apply fund_dom_s.quotientMeasureEqMeasurePreimage\n  ext U _\n  have meas_π : Measurable (QuotientGroup.mk : G → G ⧸ Γ) := continuous_quotient_mk'.measurable\n  let μ' : Measure (G ⧸ Γ) := (ν.restrict s).map π\n  haveI has_fund : HasFundamentalDomain Γ.op G ν := ⟨⟨s, fund_dom_s⟩⟩\n  have i : QuotientMeasureEqMeasurePreimage ν μ' :=\n    fund_dom_s.quotientMeasureEqMeasurePreimage_quotientMeasure\n  have : μ'.IsMulLeftInvariant :=\n    MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient ν\n  suffices μ = μ' by\n    rw [this]\n    rfl\n  have : SigmaFinite μ' := i.sigmaFiniteQuotient\n  rw [measure_eq_div_smul μ' μ neZeroV neTopV, hV]\n  symm\n  suffices (μ' V / ν (QuotientGroup.mk ⁻¹' V ∩ s)) = 1 by rw [this, one_smul]\n  rw [Measure.map_apply meas_π meas_V, Measure.restrict_apply]\n  · convert ENNReal.div_self ..\n    · exact trans hV.symm neZeroV\n    · exact trans hV.symm neTopV\n  exact measurableSet_quotient.mp meas_V\n\n"}
{"name":"MeasureTheory.Measure.IsAddLeftInvariant.addQuotientMeasureEqMeasurePreimage_of_set","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹⁴ : AddGroup G\ninst✝¹³ : MeasurableSpace G\ninst✝¹² : TopologicalSpace G\ninst✝¹¹ : TopologicalAddGroup G\ninst✝¹⁰ : BorelSpace G\ninst✝⁹ : PolishSpace G\nΓ : AddSubgroup G\ninst✝⁸ : Γ.Normal\ninst✝⁷ : T2Space (HasQuotient.Quotient G Γ)\ninst✝⁶ : SecondCountableTopology (HasQuotient.Quotient G Γ)\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\nν : MeasureTheory.Measure G\ninst✝⁵ : ν.IsAddLeftInvariant\ninst✝⁴ : Countable (Subtype fun x => Membership.mem Γ x)\ninst✝³ : ν.IsAddRightInvariant\ninst✝² : MeasureTheory.SigmaFinite ν\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : MeasureTheory.SigmaFinite μ\ns : Set G\nfund_dom_s : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) s ν\nV : Set (HasQuotient.Quotient G Γ)\nmeas_V : MeasurableSet V\nneZeroV : Ne (μ V) 0\nhV : Eq (μ V) (ν (Inter.inter (Set.preimage QuotientAddGroup.mk V) s))\nneTopV : Ne (μ V) Top.top\n⊢ MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ","decl":"/-- Assume that a measure `μ` is `IsMulLeftInvariant`, that the action of `Γ` on `G` has a\nmeasurable fundamental domain `s` with positive finite volume, and that there is a single measurable\nset `V ⊆ G ⧸ Γ` along which the pullback of `μ` and `ν` agree (so the scaling is right). Then\n`μ` satisfies `QuotientMeasureEqMeasurePreimage`. The main tool of the proof is the uniqueness of\nleft invariant measures, if normalized by a single positive finite-measured set. -/\n@[to_additive\n\"Assume that a measure `μ` is `IsAddLeftInvariant`, that the action of `Γ` on `G` has a\nmeasurable fundamental domain `s` with positive finite volume, and that there is a single measurable\nset `V ⊆ G ⧸ Γ` along which the pullback of `μ` and `ν` agree (so the scaling is right). Then\n`μ` satisfies `AddQuotientMeasureEqMeasurePreimage`. The main tool of the proof is the uniqueness of\nleft invariant measures, if normalized by a single positive finite-measured set.\"]\ntheorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}\n    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}\n    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))\n    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by\n  apply fund_dom_s.quotientMeasureEqMeasurePreimage\n  ext U _\n  have meas_π : Measurable (QuotientGroup.mk : G → G ⧸ Γ) := continuous_quotient_mk'.measurable\n  let μ' : Measure (G ⧸ Γ) := (ν.restrict s).map π\n  haveI has_fund : HasFundamentalDomain Γ.op G ν := ⟨⟨s, fund_dom_s⟩⟩\n  have i : QuotientMeasureEqMeasurePreimage ν μ' :=\n    fund_dom_s.quotientMeasureEqMeasurePreimage_quotientMeasure\n  have : μ'.IsMulLeftInvariant :=\n    MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient ν\n  suffices μ = μ' by\n    rw [this]\n    rfl\n  have : SigmaFinite μ' := i.sigmaFiniteQuotient\n  rw [measure_eq_div_smul μ' μ neZeroV neTopV, hV]\n  symm\n  suffices (μ' V / ν (QuotientGroup.mk ⁻¹' V ∩ s)) = 1 by rw [this, one_smul]\n  rw [Measure.map_apply meas_π meas_V, Measure.restrict_apply]\n  · convert ENNReal.div_self ..\n    · exact trans hV.symm neZeroV\n    · exact trans hV.symm neTopV\n  exact measurableSet_quotient.mp meas_V\n\n"}
{"name":"MeasureTheory.leftInvariantIsQuotientMeasureEqMeasurePreimage","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹⁵ : Group G\ninst✝¹⁴ : MeasurableSpace G\ninst✝¹³ : TopologicalSpace G\ninst✝¹² : TopologicalGroup G\ninst✝¹¹ : BorelSpace G\ninst✝¹⁰ : PolishSpace G\nΓ : Subgroup G\ninst✝⁹ : Γ.Normal\ninst✝⁸ : T2Space (HasQuotient.Quotient G Γ)\ninst✝⁷ : SecondCountableTopology (HasQuotient.Quotient G Γ)\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\nν : MeasureTheory.Measure G\ninst✝⁶ : ν.IsMulLeftInvariant\ninst✝⁵ : Countable (Subtype fun x => Membership.mem Γ x)\ninst✝⁴ : ν.IsMulRightInvariant\ninst✝³ : MeasureTheory.SigmaFinite ν\ninst✝² : μ.IsMulLeftInvariant\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhasFun : MeasureTheory.HasFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) G ν\nh : Eq (MeasureTheory.covolume (Subtype fun x => Membership.mem Γ.op x) G ν) (μ Set.univ)\n⊢ MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ","decl":"/-- If a measure `μ` is left-invariant and satisfies the right scaling condition, then it\n  satisfies `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive \"If a measure `μ` is\nleft-invariant and satisfies the right scaling condition, then it satisfies\n`AddQuotientMeasureEqMeasurePreimage`.\"]\ntheorem MeasureTheory.leftInvariantIsQuotientMeasureEqMeasurePreimage [IsFiniteMeasure μ]\n    [hasFun : HasFundamentalDomain Γ.op G ν]\n    (h : covolume Γ.op G ν = μ univ) : QuotientMeasureEqMeasurePreimage ν μ := by\n  obtain ⟨s, fund_dom_s⟩ := hasFun.ExistsIsFundamentalDomain\n  have finiteCovol : μ univ < ⊤ := measure_lt_top μ univ\n  rw [fund_dom_s.covolume_eq_volume] at h\n  by_cases meas_s_ne_zero : ν s = 0\n  · convert fund_dom_s.quotientMeasureEqMeasurePreimage_of_zero meas_s_ne_zero\n    rw [← @measure_univ_eq_zero, ← h, meas_s_ne_zero]\n  apply IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set (fund_dom_s := fund_dom_s)\n    (meas_V := MeasurableSet.univ)\n  · rw [← h]\n    exact meas_s_ne_zero\n  · rw [← h]\n    simp\n  · rw [← h]\n    convert finiteCovol.ne\n\n"}
{"name":"MeasureTheory.leftInvariantIsAddQuotientMeasureEqMeasurePreimage","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹⁵ : AddGroup G\ninst✝¹⁴ : MeasurableSpace G\ninst✝¹³ : TopologicalSpace G\ninst✝¹² : TopologicalAddGroup G\ninst✝¹¹ : BorelSpace G\ninst✝¹⁰ : PolishSpace G\nΓ : AddSubgroup G\ninst✝⁹ : Γ.Normal\ninst✝⁸ : T2Space (HasQuotient.Quotient G Γ)\ninst✝⁷ : SecondCountableTopology (HasQuotient.Quotient G Γ)\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\nν : MeasureTheory.Measure G\ninst✝⁶ : ν.IsAddLeftInvariant\ninst✝⁵ : Countable (Subtype fun x => Membership.mem Γ x)\ninst✝⁴ : ν.IsAddRightInvariant\ninst✝³ : MeasureTheory.SigmaFinite ν\ninst✝² : μ.IsAddLeftInvariant\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhasFun : MeasureTheory.HasAddFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) G ν\nh : Eq (MeasureTheory.addCovolume (Subtype fun x => Membership.mem Γ.op x) G ν) (μ Set.univ)\n⊢ MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ","decl":"/-- If a measure `μ` is left-invariant and satisfies the right scaling condition, then it\n  satisfies `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive \"If a measure `μ` is\nleft-invariant and satisfies the right scaling condition, then it satisfies\n`AddQuotientMeasureEqMeasurePreimage`.\"]\ntheorem MeasureTheory.leftInvariantIsQuotientMeasureEqMeasurePreimage [IsFiniteMeasure μ]\n    [hasFun : HasFundamentalDomain Γ.op G ν]\n    (h : covolume Γ.op G ν = μ univ) : QuotientMeasureEqMeasurePreimage ν μ := by\n  obtain ⟨s, fund_dom_s⟩ := hasFun.ExistsIsFundamentalDomain\n  have finiteCovol : μ univ < ⊤ := measure_lt_top μ univ\n  rw [fund_dom_s.covolume_eq_volume] at h\n  by_cases meas_s_ne_zero : ν s = 0\n  · convert fund_dom_s.quotientMeasureEqMeasurePreimage_of_zero meas_s_ne_zero\n    rw [← @measure_univ_eq_zero, ← h, meas_s_ne_zero]\n  apply IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set (fund_dom_s := fund_dom_s)\n    (meas_V := MeasurableSet.univ)\n  · rw [← h]\n    exact meas_s_ne_zero\n  · rw [← h]\n    simp\n  · rw [← h]\n    convert finiteCovol.ne\n\n"}
{"name":"MeasureTheory.QuotientMeasureEqMeasurePreimage.haarMeasure_quotient","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹⁴ : Group G\ninst✝¹³ : MeasurableSpace G\ninst✝¹² : TopologicalSpace G\ninst✝¹¹ : TopologicalGroup G\ninst✝¹⁰ : BorelSpace G\ninst✝⁹ : PolishSpace G\nΓ : Subgroup G\ninst✝⁸ : Γ.Normal\ninst✝⁷ : T2Space (HasQuotient.Quotient G Γ)\ninst✝⁶ : SecondCountableTopology (HasQuotient.Quotient G Γ)\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\ninst✝⁵ : Countable (Subtype fun x => Membership.mem Γ x)\nν : MeasureTheory.Measure G\ninst✝⁴ : ν.IsHaarMeasure\ninst✝³ : ν.IsMulRightInvariant\ninst✝² : LocallyCompactSpace G\ninst✝¹ : MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ\ni : MeasureTheory.HasFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) G ν\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ μ.IsHaarMeasure","decl":"/-- If a measure `μ` on the quotient `G ⧸ Γ` of a group `G` by a discrete normal subgroup `Γ` having\nfundamental domain, satisfies `QuotientMeasureEqMeasurePreimage` relative to a standardized choice\nof Haar measure on `G`, and assuming `μ` is finite, then `μ` is itself Haar.\nTODO: Is it possible to drop the assumption that `μ` is finite? -/\n@[to_additive \"If a measure `μ` on the quotient `G ⧸ Γ` of an additive group `G` by a discrete\nnormal subgroup `Γ` having fundamental domain, satisfies `AddQuotientMeasureEqMeasurePreimage`\nrelative to a standardized choice of Haar measure on `G`, and assuming `μ` is finite, then `μ` is\nitself Haar.\"]\ntheorem MeasureTheory.QuotientMeasureEqMeasurePreimage.haarMeasure_quotient [LocallyCompactSpace G]\n    [QuotientMeasureEqMeasurePreimage ν μ] [i : HasFundamentalDomain Γ.op G ν]\n    [IsFiniteMeasure μ] : IsHaarMeasure μ := by\n  obtain ⟨K⟩ := PositiveCompacts.nonempty' (α := G)\n  let K' : PositiveCompacts (G ⧸ Γ) :=\n    K.map π QuotientGroup.continuous_mk QuotientGroup.isOpenMap_coe\n  haveI : IsMulLeftInvariant μ :=\n    MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient ν\n  rw [haarMeasure_unique μ K']\n  have finiteCovol : covolume Γ.op G ν ≠ ⊤ :=\n    ne_top_of_lt <| QuotientMeasureEqMeasurePreimage.covolume_ne_top μ (ν := ν)\n  obtain ⟨s, fund_dom_s⟩ := i\n  rw [fund_dom_s.covolume_eq_volume] at finiteCovol\n  -- TODO: why `rw` fails?\n  erw [fund_dom_s.projection_respects_measure_apply μ K'.isCompact.measurableSet]\n  apply IsHaarMeasure.smul\n  · intro h\n    haveI i' : IsOpenPosMeasure (ν : Measure G) := inferInstance\n    apply IsOpenPosMeasure.open_pos (interior K) (μ := ν) (self := i')\n    · exact isOpen_interior\n    · exact K.interior_nonempty\n    rw [← le_zero_iff,\n      ← fund_dom_s.measure_zero_of_invariant _ (fun g ↦ QuotientGroup.sound _ _ g) h]\n    apply measure_mono\n    refine interior_subset.trans ?_\n    rw [QuotientGroup.coe_mk']\n    show (K : Set G) ⊆ π ⁻¹' (π '' K)\n    exact subset_preimage_image π K\n  · show ν (π ⁻¹' (π '' K) ∩ s) ≠ ⊤\n    apply ne_of_lt\n    refine lt_of_le_of_lt ?_ finiteCovol.lt_top\n    apply measure_mono\n    exact inter_subset_right\n\n"}
{"name":"MeasureTheory.AddQuotientMeasureEqMeasurePreimage.addHaarMeasure_quotient","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹⁴ : AddGroup G\ninst✝¹³ : MeasurableSpace G\ninst✝¹² : TopologicalSpace G\ninst✝¹¹ : TopologicalAddGroup G\ninst✝¹⁰ : BorelSpace G\ninst✝⁹ : PolishSpace G\nΓ : AddSubgroup G\ninst✝⁸ : Γ.Normal\ninst✝⁷ : T2Space (HasQuotient.Quotient G Γ)\ninst✝⁶ : SecondCountableTopology (HasQuotient.Quotient G Γ)\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\ninst✝⁵ : Countable (Subtype fun x => Membership.mem Γ x)\nν : MeasureTheory.Measure G\ninst✝⁴ : ν.IsAddHaarMeasure\ninst✝³ : ν.IsAddRightInvariant\ninst✝² : LocallyCompactSpace G\ninst✝¹ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ\ni : MeasureTheory.HasAddFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) G ν\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ μ.IsAddHaarMeasure","decl":"/-- If a measure `μ` on the quotient `G ⧸ Γ` of a group `G` by a discrete normal subgroup `Γ` having\nfundamental domain, satisfies `QuotientMeasureEqMeasurePreimage` relative to a standardized choice\nof Haar measure on `G`, and assuming `μ` is finite, then `μ` is itself Haar.\nTODO: Is it possible to drop the assumption that `μ` is finite? -/\n@[to_additive \"If a measure `μ` on the quotient `G ⧸ Γ` of an additive group `G` by a discrete\nnormal subgroup `Γ` having fundamental domain, satisfies `AddQuotientMeasureEqMeasurePreimage`\nrelative to a standardized choice of Haar measure on `G`, and assuming `μ` is finite, then `μ` is\nitself Haar.\"]\ntheorem MeasureTheory.QuotientMeasureEqMeasurePreimage.haarMeasure_quotient [LocallyCompactSpace G]\n    [QuotientMeasureEqMeasurePreimage ν μ] [i : HasFundamentalDomain Γ.op G ν]\n    [IsFiniteMeasure μ] : IsHaarMeasure μ := by\n  obtain ⟨K⟩ := PositiveCompacts.nonempty' (α := G)\n  let K' : PositiveCompacts (G ⧸ Γ) :=\n    K.map π QuotientGroup.continuous_mk QuotientGroup.isOpenMap_coe\n  haveI : IsMulLeftInvariant μ :=\n    MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient ν\n  rw [haarMeasure_unique μ K']\n  have finiteCovol : covolume Γ.op G ν ≠ ⊤ :=\n    ne_top_of_lt <| QuotientMeasureEqMeasurePreimage.covolume_ne_top μ (ν := ν)\n  obtain ⟨s, fund_dom_s⟩ := i\n  rw [fund_dom_s.covolume_eq_volume] at finiteCovol\n  -- TODO: why `rw` fails?\n  erw [fund_dom_s.projection_respects_measure_apply μ K'.isCompact.measurableSet]\n  apply IsHaarMeasure.smul\n  · intro h\n    haveI i' : IsOpenPosMeasure (ν : Measure G) := inferInstance\n    apply IsOpenPosMeasure.open_pos (interior K) (μ := ν) (self := i')\n    · exact isOpen_interior\n    · exact K.interior_nonempty\n    rw [← le_zero_iff,\n      ← fund_dom_s.measure_zero_of_invariant _ (fun g ↦ QuotientGroup.sound _ _ g) h]\n    apply measure_mono\n    refine interior_subset.trans ?_\n    rw [QuotientGroup.coe_mk']\n    show (K : Set G) ⊆ π ⁻¹' (π '' K)\n    exact subset_preimage_image π K\n  · show ν (π ⁻¹' (π '' K) ∩ s) ≠ ⊤\n    apply ne_of_lt\n    refine lt_of_le_of_lt ?_ finiteCovol.lt_top\n    apply measure_mono\n    exact inter_subset_right\n\n"}
{"name":"IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_HaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹⁴ : Group G\ninst✝¹³ : MeasurableSpace G\ninst✝¹² : TopologicalSpace G\ninst✝¹¹ : TopologicalGroup G\ninst✝¹⁰ : BorelSpace G\ninst✝⁹ : PolishSpace G\nΓ : Subgroup G\ninst✝⁸ : Γ.Normal\ninst✝⁷ : T2Space (HasQuotient.Quotient G Γ)\ninst✝⁶ : SecondCountableTopology (HasQuotient.Quotient G Γ)\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\ninst✝⁵ : Countable (Subtype fun x => Membership.mem Γ x)\nν : MeasureTheory.Measure G\ninst✝⁴ : ν.IsHaarMeasure\ninst✝³ : ν.IsMulRightInvariant\ninst✝² : MeasureTheory.SigmaFinite ν\n𝓕 : Set G\nh𝓕 : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) 𝓕 ν\ninst✝¹ : μ.IsMulLeftInvariant\ninst✝ : MeasureTheory.SigmaFinite μ\nV : Set (HasQuotient.Quotient G Γ)\nhV : (interior V).Nonempty\nmeas_V : MeasurableSet V\nhμK : Eq (μ V) (ν (Inter.inter (Set.preimage QuotientGroup.mk V) 𝓕))\nneTopV : Ne (μ V) Top.top\n⊢ MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ","decl":"/-- Given a normal subgroup `Γ` of a topological group `G` with Haar measure `μ`, which is also\n  right-invariant, and a finite volume fundamental domain `𝓕`, the quotient map to `G ⧸ Γ`,\n  properly normalized, satisfies `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive \"Given a normal\nsubgroup `Γ` of an additive topological group `G` with Haar measure `μ`, which is also\nright-invariant, and a finite volume fundamental domain `𝓕`, the quotient map to `G ⧸ Γ`,\nproperly normalized, satisfies `AddQuotientMeasureEqMeasurePreimage`.\"]\ntheorem IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_HaarMeasure {𝓕 : Set G}\n    (h𝓕 : IsFundamentalDomain Γ.op 𝓕 ν) [IsMulLeftInvariant μ] [SigmaFinite μ]\n    {V : Set (G ⧸ Γ)} (hV : (interior V).Nonempty) (meas_V : MeasurableSet V)\n    (hμK : μ V = ν ((π ⁻¹' V) ∩ 𝓕)) (neTopV : μ V ≠ ⊤) :\n    QuotientMeasureEqMeasurePreimage ν μ := by\n  apply IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set (fund_dom_s := h𝓕)\n    (meas_V := meas_V)\n  · rw [hμK]\n    intro c_eq_zero\n    apply IsOpenPosMeasure.open_pos (interior (π ⁻¹' V)) (μ := ν)\n    · simp\n    · apply Set.Nonempty.mono (preimage_interior_subset_interior_preimage continuous_coinduced_rng)\n      apply hV.preimage'\n      simp\n    · apply measure_mono_null (h := interior_subset)\n      apply h𝓕.measure_zero_of_invariant (ht := fun g ↦ QuotientGroup.sound _ _ g)\n      exact c_eq_zero\n  · exact hμK\n  · exact neTopV\n\n"}
{"name":"IsFundamentalDomain.AddQuotientMeasureEqMeasurePreimage_AddHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹⁴ : AddGroup G\ninst✝¹³ : MeasurableSpace G\ninst✝¹² : TopologicalSpace G\ninst✝¹¹ : TopologicalAddGroup G\ninst✝¹⁰ : BorelSpace G\ninst✝⁹ : PolishSpace G\nΓ : AddSubgroup G\ninst✝⁸ : Γ.Normal\ninst✝⁷ : T2Space (HasQuotient.Quotient G Γ)\ninst✝⁶ : SecondCountableTopology (HasQuotient.Quotient G Γ)\nμ : MeasureTheory.Measure (HasQuotient.Quotient G Γ)\ninst✝⁵ : Countable (Subtype fun x => Membership.mem Γ x)\nν : MeasureTheory.Measure G\ninst✝⁴ : ν.IsAddHaarMeasure\ninst✝³ : ν.IsAddRightInvariant\ninst✝² : MeasureTheory.SigmaFinite ν\n𝓕 : Set G\nh𝓕 : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) 𝓕 ν\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : MeasureTheory.SigmaFinite μ\nV : Set (HasQuotient.Quotient G Γ)\nhV : (interior V).Nonempty\nmeas_V : MeasurableSet V\nhμK : Eq (μ V) (ν (Inter.inter (Set.preimage QuotientAddGroup.mk V) 𝓕))\nneTopV : Ne (μ V) Top.top\n⊢ MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ","decl":"/-- Given a normal subgroup `Γ` of a topological group `G` with Haar measure `μ`, which is also\n  right-invariant, and a finite volume fundamental domain `𝓕`, the quotient map to `G ⧸ Γ`,\n  properly normalized, satisfies `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive \"Given a normal\nsubgroup `Γ` of an additive topological group `G` with Haar measure `μ`, which is also\nright-invariant, and a finite volume fundamental domain `𝓕`, the quotient map to `G ⧸ Γ`,\nproperly normalized, satisfies `AddQuotientMeasureEqMeasurePreimage`.\"]\ntheorem IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_HaarMeasure {𝓕 : Set G}\n    (h𝓕 : IsFundamentalDomain Γ.op 𝓕 ν) [IsMulLeftInvariant μ] [SigmaFinite μ]\n    {V : Set (G ⧸ Γ)} (hV : (interior V).Nonempty) (meas_V : MeasurableSet V)\n    (hμK : μ V = ν ((π ⁻¹' V) ∩ 𝓕)) (neTopV : μ V ≠ ⊤) :\n    QuotientMeasureEqMeasurePreimage ν μ := by\n  apply IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set (fund_dom_s := h𝓕)\n    (meas_V := meas_V)\n  · rw [hμK]\n    intro c_eq_zero\n    apply IsOpenPosMeasure.open_pos (interior (π ⁻¹' V)) (μ := ν)\n    · simp\n    · apply Set.Nonempty.mono (preimage_interior_subset_interior_preimage continuous_coinduced_rng)\n      apply hV.preimage'\n      simp\n    · apply measure_mono_null (h := interior_subset)\n      apply h𝓕.measure_zero_of_invariant (ht := fun g ↦ QuotientGroup.sound _ _ g)\n      exact c_eq_zero\n  · exact hμK\n  · exact neTopV\n\n"}
{"name":"IsFundamentalDomain.AddQuotientMeasureEqMeasurePreimage_vaddAddHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹² : AddGroup G\ninst✝¹¹ : MeasurableSpace G\ninst✝¹⁰ : TopologicalSpace G\ninst✝⁹ : TopologicalAddGroup G\ninst✝⁸ : BorelSpace G\ninst✝⁷ : PolishSpace G\nΓ : AddSubgroup G\ninst✝⁶ : Γ.Normal\ninst✝⁵ : T2Space (HasQuotient.Quotient G Γ)\ninst✝⁴ : SecondCountableTopology (HasQuotient.Quotient G Γ)\ninst✝³ : Countable (Subtype fun x => Membership.mem Γ x)\nν : MeasureTheory.Measure G\ninst✝² : ν.IsAddHaarMeasure\ninst✝¹ : ν.IsAddRightInvariant\ninst✝ : MeasureTheory.SigmaFinite ν\nK : TopologicalSpace.PositiveCompacts (HasQuotient.Quotient G Γ)\n𝓕 : Set G\nh𝓕 : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) 𝓕 ν\nh𝓕_finite : Ne (ν 𝓕) Top.top\n⊢ MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν (HSMul.hSMul (ν (Inter.inter (Set.preimage QuotientAddGroup.mk ↑K) 𝓕)) (MeasureTheory.Measure.addHaarMeasure K))","decl":"/-- Given a normal subgroup `Γ` of a topological group `G` with Haar measure `μ`, which is also\n  right-invariant, and a finite volume fundamental domain `𝓕`, the quotient map to `G ⧸ Γ`,\n  properly normalized, satisfies `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive \"Given a\nnormal subgroup `Γ` of an additive topological group `G` with Haar measure `μ`, which is also\nright-invariant, and a finite volume fundamental domain `𝓕`, the quotient map to `G ⧸ Γ`,\nproperly normalized, satisfies `AddQuotientMeasureEqMeasurePreimage`.\"]\ntheorem IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_smulHaarMeasure {𝓕 : Set G}\n    (h𝓕 : IsFundamentalDomain Γ.op 𝓕 ν) (h𝓕_finite : ν 𝓕 ≠ ⊤) :\n    QuotientMeasureEqMeasurePreimage ν\n      ((ν ((π ⁻¹' (K : Set (G ⧸ Γ))) ∩ 𝓕)) • haarMeasure K) := by\n  set c := ν ((π ⁻¹' (K : Set (G ⧸ Γ))) ∩ 𝓕)\n  have c_ne_top : c ≠ ∞ := by\n    contrapose! h𝓕_finite\n    have : c ≤ ν 𝓕 := measure_mono (Set.inter_subset_right)\n    rw [h𝓕_finite] at this\n    exact top_unique this\n  set μ := c • haarMeasure K\n  have hμK : μ K = c := by simp [μ, haarMeasure_self]\n  haveI : SigmaFinite μ := by\n    clear_value c\n    lift c to NNReal using c_ne_top\n    exact SMul.sigmaFinite c\n  apply IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_HaarMeasure (h𝓕 := h𝓕)\n    (meas_V := K.isCompact.measurableSet) (μ := μ)\n  · exact K.interior_nonempty\n  · exact hμK\n  · rw [hμK]\n    exact c_ne_top\n\n"}
{"name":"IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_smulHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹² : Group G\ninst✝¹¹ : MeasurableSpace G\ninst✝¹⁰ : TopologicalSpace G\ninst✝⁹ : TopologicalGroup G\ninst✝⁸ : BorelSpace G\ninst✝⁷ : PolishSpace G\nΓ : Subgroup G\ninst✝⁶ : Γ.Normal\ninst✝⁵ : T2Space (HasQuotient.Quotient G Γ)\ninst✝⁴ : SecondCountableTopology (HasQuotient.Quotient G Γ)\ninst✝³ : Countable (Subtype fun x => Membership.mem Γ x)\nν : MeasureTheory.Measure G\ninst✝² : ν.IsHaarMeasure\ninst✝¹ : ν.IsMulRightInvariant\ninst✝ : MeasureTheory.SigmaFinite ν\nK : TopologicalSpace.PositiveCompacts (HasQuotient.Quotient G Γ)\n𝓕 : Set G\nh𝓕 : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) 𝓕 ν\nh𝓕_finite : Ne (ν 𝓕) Top.top\n⊢ MeasureTheory.QuotientMeasureEqMeasurePreimage ν (HSMul.hSMul (ν (Inter.inter (Set.preimage QuotientGroup.mk ↑K) 𝓕)) (MeasureTheory.Measure.haarMeasure K))","decl":"/-- Given a normal subgroup `Γ` of a topological group `G` with Haar measure `μ`, which is also\n  right-invariant, and a finite volume fundamental domain `𝓕`, the quotient map to `G ⧸ Γ`,\n  properly normalized, satisfies `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive \"Given a\nnormal subgroup `Γ` of an additive topological group `G` with Haar measure `μ`, which is also\nright-invariant, and a finite volume fundamental domain `𝓕`, the quotient map to `G ⧸ Γ`,\nproperly normalized, satisfies `AddQuotientMeasureEqMeasurePreimage`.\"]\ntheorem IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_smulHaarMeasure {𝓕 : Set G}\n    (h𝓕 : IsFundamentalDomain Γ.op 𝓕 ν) (h𝓕_finite : ν 𝓕 ≠ ⊤) :\n    QuotientMeasureEqMeasurePreimage ν\n      ((ν ((π ⁻¹' (K : Set (G ⧸ Γ))) ∩ 𝓕)) • haarMeasure K) := by\n  set c := ν ((π ⁻¹' (K : Set (G ⧸ Γ))) ∩ 𝓕)\n  have c_ne_top : c ≠ ∞ := by\n    contrapose! h𝓕_finite\n    have : c ≤ ν 𝓕 := measure_mono (Set.inter_subset_right)\n    rw [h𝓕_finite] at this\n    exact top_unique this\n  set μ := c • haarMeasure K\n  have hμK : μ K = c := by simp [μ, haarMeasure_self]\n  haveI : SigmaFinite μ := by\n    clear_value c\n    lift c to NNReal using c_ne_top\n    exact SMul.sigmaFinite c\n  apply IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_HaarMeasure (h𝓕 := h𝓕)\n    (meas_V := K.isCompact.measurableSet) (μ := μ)\n  · exact K.interior_nonempty\n  · exact hμK\n  · rw [hμK]\n    exact c_ne_top\n\n"}
{"name":"essSup_comp_quotientAddGroup_mk","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝⁸ : AddGroup G\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\nΓ : AddSubgroup G\n𝓕 : Set G\nh𝓕 : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) 𝓕 μ\ninst✝³ : Countable (Subtype fun x => Membership.mem Γ x)\ninst✝² : MeasurableSpace (HasQuotient.Quotient G Γ)\ninst✝¹ : BorelSpace (HasQuotient.Quotient G Γ)\ninst✝ : μ.IsAddRightInvariant\ng : HasQuotient.Quotient G Γ → ENNReal\ng_ae_measurable : AEMeasurable g (MeasureTheory.Measure.map QuotientAddGroup.mk (μ.restrict 𝓕))\n⊢ Eq (essSup g (MeasureTheory.Measure.map QuotientAddGroup.mk (μ.restrict 𝓕))) (essSup (fun x => g ↑x) μ)","decl":"/-- The `essSup` of a function `g` on the quotient space `G ⧸ Γ` with respect to the pushforward\n  of the restriction, `μ_𝓕`, of a right-invariant measure `μ` to a fundamental domain `𝓕`, is the\n  same as the `essSup` of `g`'s lift to the universal cover `G` with respect to `μ`. -/\n@[to_additive \"The `essSup` of a function `g` on the additive quotient space `G ⧸ Γ` with respect\n  to the pushforward of the restriction, `μ_𝓕`, of a right-invariant measure `μ` to a fundamental\n  domain `𝓕`, is the same as the `essSup` of `g`'s lift to the universal cover `G` with respect\n  to `μ`.\"]\nlemma essSup_comp_quotientGroup_mk [μ.IsMulRightInvariant] {g : G ⧸ Γ → ℝ≥0∞}\n    (g_ae_measurable : AEMeasurable g μ_𝓕) : essSup g μ_𝓕 = essSup (fun (x : G) ↦ g x) μ := by\n  have hπ : Measurable (QuotientGroup.mk : G → G ⧸ Γ) := continuous_quotient_mk'.measurable\n  rw [essSup_map_measure g_ae_measurable hπ.aemeasurable]\n  refine h𝓕.essSup_measure_restrict ?_\n  intro ⟨γ, hγ⟩ x\n  dsimp\n  congr 1\n  exact QuotientGroup.mk_mul_of_mem x hγ\n\n"}
{"name":"essSup_comp_quotientGroup_mk","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝⁸ : Group G\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\nΓ : Subgroup G\n𝓕 : Set G\nh𝓕 : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) 𝓕 μ\ninst✝³ : Countable (Subtype fun x => Membership.mem Γ x)\ninst✝² : MeasurableSpace (HasQuotient.Quotient G Γ)\ninst✝¹ : BorelSpace (HasQuotient.Quotient G Γ)\ninst✝ : μ.IsMulRightInvariant\ng : HasQuotient.Quotient G Γ → ENNReal\ng_ae_measurable : AEMeasurable g (MeasureTheory.Measure.map QuotientGroup.mk (μ.restrict 𝓕))\n⊢ Eq (essSup g (MeasureTheory.Measure.map QuotientGroup.mk (μ.restrict 𝓕))) (essSup (fun x => g ↑x) μ)","decl":"/-- The `essSup` of a function `g` on the quotient space `G ⧸ Γ` with respect to the pushforward\n  of the restriction, `μ_𝓕`, of a right-invariant measure `μ` to a fundamental domain `𝓕`, is the\n  same as the `essSup` of `g`'s lift to the universal cover `G` with respect to `μ`. -/\n@[to_additive \"The `essSup` of a function `g` on the additive quotient space `G ⧸ Γ` with respect\n  to the pushforward of the restriction, `μ_𝓕`, of a right-invariant measure `μ` to a fundamental\n  domain `𝓕`, is the same as the `essSup` of `g`'s lift to the universal cover `G` with respect\n  to `μ`.\"]\nlemma essSup_comp_quotientGroup_mk [μ.IsMulRightInvariant] {g : G ⧸ Γ → ℝ≥0∞}\n    (g_ae_measurable : AEMeasurable g μ_𝓕) : essSup g μ_𝓕 = essSup (fun (x : G) ↦ g x) μ := by\n  have hπ : Measurable (QuotientGroup.mk : G → G ⧸ Γ) := continuous_quotient_mk'.measurable\n  rw [essSup_map_measure g_ae_measurable hπ.aemeasurable]\n  refine h𝓕.essSup_measure_restrict ?_\n  intro ⟨γ, hγ⟩ x\n  dsimp\n  congr 1\n  exact QuotientGroup.mk_mul_of_mem x hγ\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.absolutelyContinuous_map","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝⁸ : AddGroup G\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\nΓ : AddSubgroup G\n𝓕 : Set G\nh𝓕 : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) 𝓕 μ\ninst✝³ : Countable (Subtype fun x => Membership.mem Γ x)\ninst✝² : MeasurableSpace (HasQuotient.Quotient G Γ)\ninst✝¹ : BorelSpace (HasQuotient.Quotient G Γ)\ninst✝ : μ.IsAddRightInvariant\n⊢ (MeasureTheory.Measure.map QuotientAddGroup.mk μ).AbsolutelyContinuous (MeasureTheory.Measure.map QuotientAddGroup.mk (μ.restrict 𝓕))","decl":"/-- Given a quotient space `G ⧸ Γ` where `Γ` is `Countable`, and the restriction,\n  `μ_𝓕`, of a right-invariant measure `μ` on `G` to a fundamental domain `𝓕`, a set\n  in the quotient which has `μ_𝓕`-measure zero, also has measure zero under the\n  folding of `μ` under the quotient. Note that, if `Γ` is infinite, then the folded map\n  will take the value `∞` on any open set in the quotient! -/\n@[to_additive \"Given an additive quotient space `G ⧸ Γ` where `Γ` is `Countable`, and the\n  restriction, `μ_𝓕`, of a right-invariant measure `μ` on `G` to a fundamental domain `𝓕`, a set\n  in the quotient which has `μ_𝓕`-measure zero, also has measure zero under the\n  folding of `μ` under the quotient. Note that, if `Γ` is infinite, then the folded map\n  will take the value `∞` on any open set in the quotient!\"]\nlemma _root_.MeasureTheory.IsFundamentalDomain.absolutelyContinuous_map\n    [μ.IsMulRightInvariant] :\n    map (QuotientGroup.mk : G → G ⧸ Γ) μ ≪ map (QuotientGroup.mk : G → G ⧸ Γ) (μ.restrict 𝓕) := by\n  set π : G → G ⧸ Γ := QuotientGroup.mk\n  have meas_π : Measurable π := continuous_quotient_mk'.measurable\n  apply AbsolutelyContinuous.mk\n  intro s s_meas hs\n  rw [map_apply meas_π s_meas] at hs ⊢\n  rw [Measure.restrict_apply] at hs\n  · apply h𝓕.measure_zero_of_invariant _ _ hs\n    intro γ\n    ext g\n    rw [Set.mem_smul_set_iff_inv_smul_mem, mem_preimage, mem_preimage]\n    congr! 1\n    convert QuotientGroup.mk_mul_of_mem g (γ⁻¹).2 using 1\n  exact MeasurableSet.preimage s_meas meas_π\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.absolutelyContinuous_map","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝⁸ : Group G\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : BorelSpace G\nμ : MeasureTheory.Measure G\nΓ : Subgroup G\n𝓕 : Set G\nh𝓕 : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) 𝓕 μ\ninst✝³ : Countable (Subtype fun x => Membership.mem Γ x)\ninst✝² : MeasurableSpace (HasQuotient.Quotient G Γ)\ninst✝¹ : BorelSpace (HasQuotient.Quotient G Γ)\ninst✝ : μ.IsMulRightInvariant\n⊢ (MeasureTheory.Measure.map QuotientGroup.mk μ).AbsolutelyContinuous (MeasureTheory.Measure.map QuotientGroup.mk (μ.restrict 𝓕))","decl":"/-- Given a quotient space `G ⧸ Γ` where `Γ` is `Countable`, and the restriction,\n  `μ_𝓕`, of a right-invariant measure `μ` on `G` to a fundamental domain `𝓕`, a set\n  in the quotient which has `μ_𝓕`-measure zero, also has measure zero under the\n  folding of `μ` under the quotient. Note that, if `Γ` is infinite, then the folded map\n  will take the value `∞` on any open set in the quotient! -/\n@[to_additive \"Given an additive quotient space `G ⧸ Γ` where `Γ` is `Countable`, and the\n  restriction, `μ_𝓕`, of a right-invariant measure `μ` on `G` to a fundamental domain `𝓕`, a set\n  in the quotient which has `μ_𝓕`-measure zero, also has measure zero under the\n  folding of `μ` under the quotient. Note that, if `Γ` is infinite, then the folded map\n  will take the value `∞` on any open set in the quotient!\"]\nlemma _root_.MeasureTheory.IsFundamentalDomain.absolutelyContinuous_map\n    [μ.IsMulRightInvariant] :\n    map (QuotientGroup.mk : G → G ⧸ Γ) μ ≪ map (QuotientGroup.mk : G → G ⧸ Γ) (μ.restrict 𝓕) := by\n  set π : G → G ⧸ Γ := QuotientGroup.mk\n  have meas_π : Measurable π := continuous_quotient_mk'.measurable\n  apply AbsolutelyContinuous.mk\n  intro s s_meas hs\n  rw [map_apply meas_π s_meas] at hs ⊢\n  rw [Measure.restrict_apply] at hs\n  · apply h𝓕.measure_zero_of_invariant _ _ hs\n    intro γ\n    ext g\n    rw [Set.mem_smul_set_iff_inv_smul_mem, mem_preimage, mem_preimage]\n    congr! 1\n    convert QuotientGroup.mk_mul_of_mem g (γ⁻¹).2 using 1\n  exact MeasurableSet.preimage s_meas meas_π\n\n"}
{"name":"QuotientGroup.integral_eq_integral_automorphize","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹⁰ : Group G\ninst✝⁹ : MeasurableSpace G\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : TopologicalGroup G\ninst✝⁶ : BorelSpace G\nμ : MeasureTheory.Measure G\nΓ : Subgroup G\n𝓕 : Set G\nh𝓕 : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) 𝓕 μ\ninst✝⁵ : Countable (Subtype fun x => Membership.mem Γ x)\ninst✝⁴ : MeasurableSpace (HasQuotient.Quotient G Γ)\ninst✝³ : BorelSpace (HasQuotient.Quotient G Γ)\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : μ.IsMulRightInvariant\nf : G → E\nhf₁ : MeasureTheory.Integrable f μ\nhf₂ : MeasureTheory.AEStronglyMeasurable (QuotientGroup.automorphize f) (MeasureTheory.Measure.map QuotientGroup.mk (μ.restrict 𝓕))\n⊢ Eq (MeasureTheory.integral μ fun x => f x) (MeasureTheory.integral (MeasureTheory.Measure.map QuotientGroup.mk (μ.restrict 𝓕)) fun x => QuotientGroup.automorphize f x)","decl":"/-- This is a simple version of the **Unfolding Trick**: Given a subgroup `Γ` of a group `G`, the\n  integral of a function `f` on `G` with respect to a right-invariant measure `μ` is equal to the\n  integral over the quotient `G ⧸ Γ` of the automorphization of `f`. -/\n@[to_additive \"This is a simple version of the **Unfolding Trick**: Given a subgroup `Γ` of an\n  additive group `G`, the integral of a function `f` on `G` with respect to a right-invariant\n  measure `μ` is equal to the integral over the quotient `G ⧸ Γ` of the automorphization of `f`.\"]\nlemma QuotientGroup.integral_eq_integral_automorphize {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [μ.IsMulRightInvariant] {f : G → E}\n    (hf₁ : Integrable f μ) (hf₂ : AEStronglyMeasurable (automorphize f) μ_𝓕) :\n    ∫ x : G, f x ∂μ = ∫ x : G ⧸ Γ, automorphize f x ∂μ_𝓕 := by\n  calc ∫ x : G, f x ∂μ = ∑' γ : Γ.op, ∫ x in 𝓕, f (γ • x) ∂μ :=\n    h𝓕.integral_eq_tsum'' f hf₁\n    _ = ∫ x in 𝓕, ∑' γ : Γ.op, f (γ • x) ∂μ := ?_\n    _ = ∫ x : G ⧸ Γ, automorphize f x ∂μ_𝓕 :=\n      (integral_map continuous_quotient_mk'.aemeasurable hf₂).symm\n  rw [integral_tsum]\n  · exact fun i ↦ (hf₁.1.comp_quasiMeasurePreserving\n      (measurePreserving_smul i μ).quasiMeasurePreserving).restrict\n  · rw [← h𝓕.lintegral_eq_tsum'' (‖f ·‖ₑ)]\n    exact ne_of_lt hf₁.2\n\n"}
{"name":"QuotientAddGroup.integral_eq_integral_automorphize","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹⁰ : AddGroup G\ninst✝⁹ : MeasurableSpace G\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : TopologicalAddGroup G\ninst✝⁶ : BorelSpace G\nμ : MeasureTheory.Measure G\nΓ : AddSubgroup G\n𝓕 : Set G\nh𝓕 : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) 𝓕 μ\ninst✝⁵ : Countable (Subtype fun x => Membership.mem Γ x)\ninst✝⁴ : MeasurableSpace (HasQuotient.Quotient G Γ)\ninst✝³ : BorelSpace (HasQuotient.Quotient G Γ)\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : μ.IsAddRightInvariant\nf : G → E\nhf₁ : MeasureTheory.Integrable f μ\nhf₂ : MeasureTheory.AEStronglyMeasurable (QuotientAddGroup.automorphize f) (MeasureTheory.Measure.map QuotientAddGroup.mk (μ.restrict 𝓕))\n⊢ Eq (MeasureTheory.integral μ fun x => f x) (MeasureTheory.integral (MeasureTheory.Measure.map QuotientAddGroup.mk (μ.restrict 𝓕)) fun x => QuotientAddGroup.automorphize f x)","decl":"/-- This is a simple version of the **Unfolding Trick**: Given a subgroup `Γ` of a group `G`, the\n  integral of a function `f` on `G` with respect to a right-invariant measure `μ` is equal to the\n  integral over the quotient `G ⧸ Γ` of the automorphization of `f`. -/\n@[to_additive \"This is a simple version of the **Unfolding Trick**: Given a subgroup `Γ` of an\n  additive group `G`, the integral of a function `f` on `G` with respect to a right-invariant\n  measure `μ` is equal to the integral over the quotient `G ⧸ Γ` of the automorphization of `f`.\"]\nlemma QuotientGroup.integral_eq_integral_automorphize {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [μ.IsMulRightInvariant] {f : G → E}\n    (hf₁ : Integrable f μ) (hf₂ : AEStronglyMeasurable (automorphize f) μ_𝓕) :\n    ∫ x : G, f x ∂μ = ∫ x : G ⧸ Γ, automorphize f x ∂μ_𝓕 := by\n  calc ∫ x : G, f x ∂μ = ∑' γ : Γ.op, ∫ x in 𝓕, f (γ • x) ∂μ :=\n    h𝓕.integral_eq_tsum'' f hf₁\n    _ = ∫ x in 𝓕, ∑' γ : Γ.op, f (γ • x) ∂μ := ?_\n    _ = ∫ x : G ⧸ Γ, automorphize f x ∂μ_𝓕 :=\n      (integral_map continuous_quotient_mk'.aemeasurable hf₂).symm\n  rw [integral_tsum]\n  · exact fun i ↦ (hf₁.1.comp_quasiMeasurePreserving\n      (measurePreserving_smul i μ).quasiMeasurePreserving).restrict\n  · rw [← h𝓕.lintegral_eq_tsum'' (‖f ·‖ₑ)]\n    exact ne_of_lt hf₁.2\n\n"}
{"name":"QuotientGroup.integral_mul_eq_integral_automorphize_mul","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninst✝¹⁰ : Group G\ninst✝⁹ : MeasurableSpace G\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : TopologicalGroup G\ninst✝⁶ : BorelSpace G\nμ : MeasureTheory.Measure G\nΓ : Subgroup G\n𝓕 : Set G\nh𝓕 : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Γ.op x) 𝓕 μ\ninst✝⁵ : Countable (Subtype fun x => Membership.mem Γ x)\ninst✝⁴ : MeasurableSpace (HasQuotient.Quotient G Γ)\ninst✝³ : BorelSpace (HasQuotient.Quotient G Γ)\nK : Type u_2\ninst✝² : NormedField K\ninst✝¹ : NormedSpace Real K\ninst✝ : μ.IsMulRightInvariant\nf : G → K\nf_ℒ_1 : MeasureTheory.Integrable f μ\ng : HasQuotient.Quotient G Γ → K\nhg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map QuotientGroup.mk (μ.restrict 𝓕))\ng_ℒ_infinity : Ne (essSup (fun x => ENorm.enorm (g x)) (MeasureTheory.Measure.map QuotientGroup.mk (μ.restrict 𝓕))) Top.top\nF_ae_measurable : MeasureTheory.AEStronglyMeasurable (QuotientGroup.automorphize f) (MeasureTheory.Measure.map QuotientGroup.mk (μ.restrict 𝓕))\n⊢ Eq (MeasureTheory.integral μ fun x => HMul.hMul (g ↑x) (f x)) (MeasureTheory.integral (MeasureTheory.Measure.map QuotientGroup.mk (μ.restrict 𝓕)) fun x => HMul.hMul (g x) (QuotientGroup.automorphize f x))","decl":"/-- This is the **Unfolding Trick**: Given a subgroup `Γ` of a group `G`, the integral of a\n  function `f` on `G` times the lift to `G` of a function `g` on the quotient `G ⧸ Γ` with respect\n  to a right-invariant measure `μ` on `G`, is equal to the integral over the quotient of the\n  automorphization of `f` times `g`. -/\nlemma QuotientGroup.integral_mul_eq_integral_automorphize_mul {K : Type*} [NormedField K]\n    [NormedSpace ℝ K] [μ.IsMulRightInvariant] {f : G → K}\n    (f_ℒ_1 : Integrable f μ) {g : G ⧸ Γ → K} (hg : AEStronglyMeasurable g μ_𝓕)\n    (g_ℒ_infinity : essSup (fun x ↦ ↑‖g x‖ₑ) μ_𝓕 ≠ ∞)\n    (F_ae_measurable : AEStronglyMeasurable (QuotientGroup.automorphize f) μ_𝓕) :\n    ∫ x : G, g (x : G ⧸ Γ) * (f x) ∂μ\n      = ∫ x : G ⧸ Γ, g x * (QuotientGroup.automorphize f x) ∂μ_𝓕 := by\n  let π : G → G ⧸ Γ := QuotientGroup.mk\n  have meas_π : Measurable π := continuous_quotient_mk'.measurable\n  have H₀ : QuotientGroup.automorphize ((g ∘ π) * f) = g * (QuotientGroup.automorphize f) := by\n    exact QuotientGroup.automorphize_smul_left f g\n  calc ∫ (x : G), g (π x) * (f x) ∂μ =\n        ∫ (x : G ⧸ Γ), QuotientGroup.automorphize ((g ∘ π) * f) x ∂μ_𝓕 := ?_\n    _ = ∫ (x : G ⧸ Γ), g x * (QuotientGroup.automorphize f x) ∂μ_𝓕 := by simp [H₀]\n  have H₁ : Integrable ((g ∘ π) * f) μ := by\n    have : AEStronglyMeasurable (fun (x : G) ↦ g (x : (G ⧸ Γ))) μ :=\n      (hg.mono_ac h𝓕.absolutelyContinuous_map).comp_measurable meas_π\n    refine Integrable.essSup_smul f_ℒ_1 this ?_\n    have hg' : AEStronglyMeasurable (‖g ·‖ₑ) μ_𝓕 := continuous_enorm.comp_aestronglyMeasurable hg\n    rw [← essSup_comp_quotientGroup_mk h𝓕 hg'.aemeasurable]\n    exact g_ℒ_infinity\n  have H₂ : AEStronglyMeasurable (QuotientGroup.automorphize ((g ∘ π) * f)) μ_𝓕 := by\n    simp_rw [H₀]\n    exact hg.mul F_ae_measurable\n  apply QuotientGroup.integral_eq_integral_automorphize h𝓕 H₁ H₂\n\n"}
{"name":"QuotientAddGroup.integral_mul_eq_integral_automorphize_mul","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G' : Type u_1\ninst✝¹⁰ : AddGroup G'\ninst✝⁹ : MeasurableSpace G'\ninst✝⁸ : TopologicalSpace G'\ninst✝⁷ : TopologicalAddGroup G'\ninst✝⁶ : BorelSpace G'\nμ' : MeasureTheory.Measure G'\nΓ' : AddSubgroup G'\ninst✝⁵ : Countable (Subtype fun x => Membership.mem Γ' x)\ninst✝⁴ : MeasurableSpace (HasQuotient.Quotient G' Γ')\ninst✝³ : BorelSpace (HasQuotient.Quotient G' Γ')\n𝓕' : Set G'\nK : Type u_2\ninst✝² : NormedField K\ninst✝¹ : NormedSpace Real K\ninst✝ : μ'.IsAddRightInvariant\nf : G' → K\nf_ℒ_1 : MeasureTheory.Integrable f μ'\ng : HasQuotient.Quotient G' Γ' → K\nhg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map QuotientAddGroup.mk (μ'.restrict 𝓕'))\ng_ℒ_infinity : Ne (essSup (fun x => ENorm.enorm (g x)) (MeasureTheory.Measure.map QuotientAddGroup.mk (μ'.restrict 𝓕'))) Top.top\nF_ae_measurable : MeasureTheory.AEStronglyMeasurable (QuotientAddGroup.automorphize f) (MeasureTheory.Measure.map QuotientAddGroup.mk (μ'.restrict 𝓕'))\nh𝓕 : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Γ'.op x) 𝓕' μ'\n⊢ Eq (MeasureTheory.integral μ' fun x => HMul.hMul (g ↑x) (f x)) (MeasureTheory.integral (MeasureTheory.Measure.map QuotientAddGroup.mk (μ'.restrict 𝓕')) fun x => HMul.hMul (g x) (QuotientAddGroup.automorphize f x))","decl":"/-- This is the **Unfolding Trick**: Given an additive subgroup `Γ'` of an additive group `G'`, the\n  integral of a function `f` on `G'` times the lift to `G'` of a function `g` on the quotient\n  `G' ⧸ Γ'` with respect to a right-invariant measure `μ` on `G'`, is equal to the integral over\n  the quotient of the automorphization of `f` times `g`. -/\nlemma QuotientAddGroup.integral_mul_eq_integral_automorphize_mul {K : Type*} [NormedField K]\n    [NormedSpace ℝ K] [μ'.IsAddRightInvariant] {f : G' → K}\n    (f_ℒ_1 : Integrable f μ') {g : G' ⧸ Γ' → K} (hg : AEStronglyMeasurable g μ_𝓕)\n    (g_ℒ_infinity : essSup (‖g ·‖ₑ) μ_𝓕 ≠ ∞)\n    (F_ae_measurable : AEStronglyMeasurable (QuotientAddGroup.automorphize f) μ_𝓕)\n    (h𝓕 : IsAddFundamentalDomain Γ'.op 𝓕' μ') :\n    ∫ x : G', g (x : G' ⧸ Γ') * (f x) ∂μ'\n      = ∫ x : G' ⧸ Γ', g x * (QuotientAddGroup.automorphize f x) ∂μ_𝓕 := by\n  let π : G' → G' ⧸ Γ' := QuotientAddGroup.mk\n  have meas_π : Measurable π := continuous_quotient_mk'.measurable\n  have H₀ : QuotientAddGroup.automorphize ((g ∘ π) * f) = g * (QuotientAddGroup.automorphize f) :=\n    by exact QuotientAddGroup.automorphize_smul_left f g\n  calc ∫ (x : G'), g (π x) * f x ∂μ' =\n    ∫ (x : G' ⧸ Γ'), QuotientAddGroup.automorphize ((g ∘ π) * f) x ∂μ_𝓕 := ?_\n    _ = ∫ (x : G' ⧸ Γ'), g x * (QuotientAddGroup.automorphize f x) ∂μ_𝓕 := by simp [H₀]\n  have H₁ : Integrable ((g ∘ π) * f) μ' := by\n    have : AEStronglyMeasurable (fun (x : G') ↦ g (x : (G' ⧸ Γ'))) μ' :=\n      (hg.mono_ac h𝓕.absolutelyContinuous_map).comp_measurable meas_π\n    refine Integrable.essSup_smul f_ℒ_1 this ?_\n    have hg' : AEStronglyMeasurable (‖g ·‖ₑ) μ_𝓕 := continuous_enorm.comp_aestronglyMeasurable hg\n    rw [← essSup_comp_quotientAddGroup_mk h𝓕 hg'.aemeasurable]\n    exact g_ℒ_infinity\n  have H₂ : AEStronglyMeasurable (QuotientAddGroup.automorphize ((g ∘ π) * f)) μ_𝓕 := by\n    simp_rw [H₀]\n    exact hg.mul F_ae_measurable\n  apply QuotientAddGroup.integral_eq_integral_automorphize h𝓕 H₁ H₂\n\n"}
