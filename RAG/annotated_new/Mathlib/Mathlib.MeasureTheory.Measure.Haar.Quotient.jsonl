{"name":"QuotientGroup.measurableSMul","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœâµ : Group G\nÎ“ : Subgroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : TopologicalGroup G\ninstâœÂ¹ : BorelSpace G\ninstâœ : BorelSpace (HasQuotient.Quotient G Î“)\nâŠ¢ MeasurableSMul G (HasQuotient.Quotient G Î“)","decl":"/-- Measurability of the action of the topological group `G` on the left-coset space `G / Î“`. -/\n@[to_additive \"Measurability of the action of the additive topological group `G` on the left-coset\n  space `G / Î“`.\"]\ninstance QuotientGroup.measurableSMul {G : Type*} [Group G] {Î“ : Subgroup G} [MeasurableSpace G]\n    [TopologicalSpace G] [TopologicalGroup G] [BorelSpace G] [BorelSpace (G â§¸ Î“)] :\n    MeasurableSMul G (G â§¸ Î“) where\n  measurable_const_smul g := (continuous_const_smul g).measurable\n  measurable_smul_const _ := (continuous_id.smul continuous_const).measurable\n\n"}
{"name":"QuotientAddGroup.measurableVAdd","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœâµ : AddGroup G\nÎ“ : AddSubgroup G\ninstâœâ´ : MeasurableSpace G\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : TopologicalAddGroup G\ninstâœÂ¹ : BorelSpace G\ninstâœ : BorelSpace (HasQuotient.Quotient G Î“)\nâŠ¢ MeasurableVAdd G (HasQuotient.Quotient G Î“)","decl":"/-- Measurability of the action of the topological group `G` on the left-coset space `G / Î“`. -/\n@[to_additive \"Measurability of the action of the additive topological group `G` on the left-coset\n  space `G / Î“`.\"]\ninstance QuotientGroup.measurableSMul {G : Type*} [Group G] {Î“ : Subgroup G} [MeasurableSpace G]\n    [TopologicalSpace G] [TopologicalGroup G] [BorelSpace G] [BorelSpace (G â§¸ Î“)] :\n    MeasurableSMul G (G â§¸ Î“) where\n  measurable_const_smul g := (continuous_const_smul g).measurable\n  measurable_smul_const _ := (continuous_id.smul continuous_const).measurable\n\n"}
{"name":"measurePreserving_quotientAddGroup_mk_of_AddQuotientMeasureEqMeasurePreimage","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : MeasurableSpace G\nÎ½ : MeasureTheory.Measure G\nÎ“ : AddSubgroup G\nğ“• : Set G\nhğ“• : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) ğ“• Î½\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\ninstâœ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage Î½ Î¼\nâŠ¢ MeasureTheory.MeasurePreserving QuotientAddGroup.mk (Î½.restrict ğ“•) Î¼","decl":"/-- Given a subgroup `Î“` of a topological group `G` with measure `Î½`, and a measure 'Î¼' on the\n  quotient `G â§¸ Î“` satisfying `QuotientMeasureEqMeasurePreimage`, the restriction\n  of `Î½` to a fundamental domain is measure-preserving with respect to `Î¼`. -/\n@[to_additive]\ntheorem measurePreserving_quotientGroup_mk_of_QuotientMeasureEqMeasurePreimage\n    {ğ“• : Set G} (hğ“• : IsFundamentalDomain Î“.op ğ“• Î½) (Î¼ : Measure (G â§¸ Î“))\n    [QuotientMeasureEqMeasurePreimage Î½ Î¼] :\n    MeasurePreserving (@QuotientGroup.mk G _ Î“) (Î½.restrict ğ“•) Î¼ :=\n  hğ“•.measurePreserving_quotient_mk Î¼\n\n"}
{"name":"measurePreserving_quotientGroup_mk_of_QuotientMeasureEqMeasurePreimage","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ² : Group G\ninstâœÂ¹ : MeasurableSpace G\nÎ½ : MeasureTheory.Measure G\nÎ“ : Subgroup G\nğ“• : Set G\nhğ“• : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) ğ“• Î½\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\ninstâœ : MeasureTheory.QuotientMeasureEqMeasurePreimage Î½ Î¼\nâŠ¢ MeasureTheory.MeasurePreserving QuotientGroup.mk (Î½.restrict ğ“•) Î¼","decl":"/-- Given a subgroup `Î“` of a topological group `G` with measure `Î½`, and a measure 'Î¼' on the\n  quotient `G â§¸ Î“` satisfying `QuotientMeasureEqMeasurePreimage`, the restriction\n  of `Î½` to a fundamental domain is measure-preserving with respect to `Î¼`. -/\n@[to_additive]\ntheorem measurePreserving_quotientGroup_mk_of_QuotientMeasureEqMeasurePreimage\n    {ğ“• : Set G} (hğ“• : IsFundamentalDomain Î“.op ğ“• Î½) (Î¼ : Measure (G â§¸ Î“))\n    [QuotientMeasureEqMeasurePreimage Î½ Î¼] :\n    MeasurePreserving (@QuotientGroup.mk G _ Î“) (Î½.restrict ğ“•) Î¼ :=\n  hğ“•.measurePreserving_quotient_mk Î¼\n\n"}
{"name":"MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœâ¹ : Group G\ninstâœâ¸ : MeasurableSpace G\nÎ½ : MeasureTheory.Measure G\nÎ“ : Subgroup G\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\ninstâœâ· : MeasureTheory.QuotientMeasureEqMeasurePreimage Î½ Î¼\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalGroup G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : PolishSpace G\ninstâœÂ² : T2Space (HasQuotient.Quotient G Î“)\ninstâœÂ¹ : SecondCountableTopology (HasQuotient.Quotient G Î“)\ninstâœ : Î½.IsMulLeftInvariant\nhasFun : MeasureTheory.HasFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) G Î½\nâŠ¢ MeasureTheory.SMulInvariantMeasure G (HasQuotient.Quotient G Î“) Î¼","decl":"/-- If `Î¼` satisfies `QuotientMeasureEqMeasurePreimage` relative to a both left- and right-\n  invariant measure `Î½` on `G`, then it is a `G` invariant measure on `G â§¸ Î“`. -/\n@[to_additive]\nlemma MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient\n    [IsMulLeftInvariant Î½] [hasFun : HasFundamentalDomain Î“.op G Î½] :\n    SMulInvariantMeasure G (G â§¸ Î“) Î¼ where\n  measure_preimage_smul g A hA := by\n    have meas_Ï€ : Measurable Ï€ := continuous_quotient_mk'.measurable\n    obtain âŸ¨ğ“•, hğ“•âŸ© := hasFun.ExistsIsFundamentalDomain\n    have hğ“•_translate_fundom : IsFundamentalDomain Î“.op (g â€¢ ğ“•) Î½ := hğ“•.smul_of_comm g\n    -- TODO: why `rw` fails with both of these rewrites?\n    erw [hğ“•.projection_respects_measure_apply (Î¼ := Î¼)\n      (meas_Ï€ (measurableSet_preimage (measurable_const_smul g) hA)),\n      hğ“•_translate_fundom.projection_respects_measure_apply (Î¼ := Î¼) hA]\n    change Î½ ((Ï€ â»Â¹' _) âˆ© _) = Î½ ((Ï€ â»Â¹' _) âˆ© _)\n    set Ï€_preA := Ï€ â»Â¹' A\n    have : Ï€ â»Â¹' ((fun x : G â§¸ Î“ => g â€¢ x) â»Â¹' A) = (g * Â·) â»Â¹' Ï€_preA := by ext1; simp [Ï€_preA]\n    rw [this]\n    have : Î½ ((g * Â·) â»Â¹' Ï€_preA âˆ© ğ“•) = Î½ (Ï€_preA âˆ© (gâ»Â¹ * Â·) â»Â¹' ğ“•) := by\n      trans Î½ ((g * Â·) â»Â¹' (Ï€_preA âˆ© (gâ»Â¹ * Â·) â»Â¹' ğ“•))\n      Â· rw [preimage_inter]\n        congr 2\n        simp [Set.preimage]\n      rw [measure_preimage_mul]\n    rw [this, â† preimage_smul_inv]; rfl\n\n"}
{"name":"MeasureTheory.AddQuotientMeasureEqMeasurePreimage.vaddInvariantMeasure_quotient","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœâ¹ : AddGroup G\ninstâœâ¸ : MeasurableSpace G\nÎ½ : MeasureTheory.Measure G\nÎ“ : AddSubgroup G\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\ninstâœâ· : MeasureTheory.AddQuotientMeasureEqMeasurePreimage Î½ Î¼\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalAddGroup G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : PolishSpace G\ninstâœÂ² : T2Space (HasQuotient.Quotient G Î“)\ninstâœÂ¹ : SecondCountableTopology (HasQuotient.Quotient G Î“)\ninstâœ : Î½.IsAddLeftInvariant\nhasFun : MeasureTheory.HasAddFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) G Î½\nâŠ¢ MeasureTheory.VAddInvariantMeasure G (HasQuotient.Quotient G Î“) Î¼","decl":"/-- If `Î¼` satisfies `QuotientMeasureEqMeasurePreimage` relative to a both left- and right-\n  invariant measure `Î½` on `G`, then it is a `G` invariant measure on `G â§¸ Î“`. -/\n@[to_additive]\nlemma MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient\n    [IsMulLeftInvariant Î½] [hasFun : HasFundamentalDomain Î“.op G Î½] :\n    SMulInvariantMeasure G (G â§¸ Î“) Î¼ where\n  measure_preimage_smul g A hA := by\n    have meas_Ï€ : Measurable Ï€ := continuous_quotient_mk'.measurable\n    obtain âŸ¨ğ“•, hğ“•âŸ© := hasFun.ExistsIsFundamentalDomain\n    have hğ“•_translate_fundom : IsFundamentalDomain Î“.op (g â€¢ ğ“•) Î½ := hğ“•.smul_of_comm g\n    -- TODO: why `rw` fails with both of these rewrites?\n    erw [hğ“•.projection_respects_measure_apply (Î¼ := Î¼)\n      (meas_Ï€ (measurableSet_preimage (measurable_const_smul g) hA)),\n      hğ“•_translate_fundom.projection_respects_measure_apply (Î¼ := Î¼) hA]\n    change Î½ ((Ï€ â»Â¹' _) âˆ© _) = Î½ ((Ï€ â»Â¹' _) âˆ© _)\n    set Ï€_preA := Ï€ â»Â¹' A\n    have : Ï€ â»Â¹' ((fun x : G â§¸ Î“ => g â€¢ x) â»Â¹' A) = (g * Â·) â»Â¹' Ï€_preA := by ext1; simp [Ï€_preA]\n    rw [this]\n    have : Î½ ((g * Â·) â»Â¹' Ï€_preA âˆ© ğ“•) = Î½ (Ï€_preA âˆ© (gâ»Â¹ * Â·) â»Â¹' ğ“•) := by\n      trans Î½ ((g * Â·) â»Â¹' (Ï€_preA âˆ© (gâ»Â¹ * Â·) â»Â¹' ğ“•))\n      Â· rw [preimage_inter]\n        congr 2\n        simp [Set.preimage]\n      rw [measure_preimage_mul]\n    rw [this, â† preimage_smul_inv]; rfl\n\n"}
{"name":"MeasureTheory.AddQuotientMeasureEqMeasurePreimage.addInvariantMeasure_quotient","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹â° : AddGroup G\ninstâœâ¹ : MeasurableSpace G\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : TopologicalAddGroup G\ninstâœâ¶ : BorelSpace G\ninstâœâµ : PolishSpace G\nÎ“ : AddSubgroup G\ninstâœâ´ : Î“.Normal\ninstâœÂ³ : T2Space (HasQuotient.Quotient G Î“)\ninstâœÂ² : SecondCountableTopology (HasQuotient.Quotient G Î“)\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\nÎ½ : MeasureTheory.Measure G\ninstâœÂ¹ : Î½.IsAddLeftInvariant\nhasFun : MeasureTheory.HasAddFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) G Î½\ninstâœ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage Î½ Î¼\nâŠ¢ Î¼.IsAddLeftInvariant","decl":"/-- If `Î¼` on `G â§¸ Î“` satisfies `QuotientMeasureEqMeasurePreimage` relative to a both left- and\n  right-invariant measure on `G` and `Î“` is a normal subgroup, then `Î¼` is a left-invariant\n  measure. -/\n@[to_additive \"If `Î¼` on `G â§¸ Î“` satisfies `AddQuotientMeasureEqMeasurePreimage` relative to a both\n  left- and right-invariant measure on `G` and `Î“` is a normal subgroup, then `Î¼` is a\n  left-invariant measure.\"]\nlemma MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient\n    [hasFun : HasFundamentalDomain Î“.op G Î½] [QuotientMeasureEqMeasurePreimage Î½ Î¼] :\n    Î¼.IsMulLeftInvariant where\n  map_mul_left_eq_self x := by\n    ext A hA\n    obtain âŸ¨xâ‚, hâŸ© := @Quotient.exists_rep _ (QuotientGroup.leftRel Î“) x\n    convert measure_preimage_smul Î¼ xâ‚ A using 1\n    Â· rw [â† h, Measure.map_apply (measurable_const_mul _) hA]\n      simp [â† MulAction.Quotient.coe_smul_out, â† Quotient.mk''_eq_mk]\n    exact smulInvariantMeasure_quotient Î½\n\n"}
{"name":"MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹â° : Group G\ninstâœâ¹ : MeasurableSpace G\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : TopologicalGroup G\ninstâœâ¶ : BorelSpace G\ninstâœâµ : PolishSpace G\nÎ“ : Subgroup G\ninstâœâ´ : Î“.Normal\ninstâœÂ³ : T2Space (HasQuotient.Quotient G Î“)\ninstâœÂ² : SecondCountableTopology (HasQuotient.Quotient G Î“)\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\nÎ½ : MeasureTheory.Measure G\ninstâœÂ¹ : Î½.IsMulLeftInvariant\nhasFun : MeasureTheory.HasFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) G Î½\ninstâœ : MeasureTheory.QuotientMeasureEqMeasurePreimage Î½ Î¼\nâŠ¢ Î¼.IsMulLeftInvariant","decl":"/-- If `Î¼` on `G â§¸ Î“` satisfies `QuotientMeasureEqMeasurePreimage` relative to a both left- and\n  right-invariant measure on `G` and `Î“` is a normal subgroup, then `Î¼` is a left-invariant\n  measure. -/\n@[to_additive \"If `Î¼` on `G â§¸ Î“` satisfies `AddQuotientMeasureEqMeasurePreimage` relative to a both\n  left- and right-invariant measure on `G` and `Î“` is a normal subgroup, then `Î¼` is a\n  left-invariant measure.\"]\nlemma MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient\n    [hasFun : HasFundamentalDomain Î“.op G Î½] [QuotientMeasureEqMeasurePreimage Î½ Î¼] :\n    Î¼.IsMulLeftInvariant where\n  map_mul_left_eq_self x := by\n    ext A hA\n    obtain âŸ¨xâ‚, hâŸ© := @Quotient.exists_rep _ (QuotientGroup.leftRel Î“) x\n    convert measure_preimage_smul Î¼ xâ‚ A using 1\n    Â· rw [â† h, Measure.map_apply (measurable_const_mul _) hA]\n      simp [â† MulAction.Quotient.coe_smul_out, â† Quotient.mk''_eq_mk]\n    exact smulInvariantMeasure_quotient Î½\n\n"}
{"name":"MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹â´ : Group G\ninstâœÂ¹Â³ : MeasurableSpace G\ninstâœÂ¹Â² : TopologicalSpace G\ninstâœÂ¹Â¹ : TopologicalGroup G\ninstâœÂ¹â° : BorelSpace G\ninstâœâ¹ : PolishSpace G\nÎ“ : Subgroup G\ninstâœâ¸ : Î“.Normal\ninstâœâ· : T2Space (HasQuotient.Quotient G Î“)\ninstâœâ¶ : SecondCountableTopology (HasQuotient.Quotient G Î“)\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\nÎ½ : MeasureTheory.Measure G\ninstâœâµ : Î½.IsMulLeftInvariant\ninstâœâ´ : Countable (Subtype fun x => Membership.mem Î“ x)\ninstâœÂ³ : Î½.IsMulRightInvariant\ninstâœÂ² : MeasureTheory.SigmaFinite Î½\ninstâœÂ¹ : Î¼.IsMulLeftInvariant\ninstâœ : MeasureTheory.SigmaFinite Î¼\ns : Set G\nfund_dom_s : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) s Î½\nV : Set (HasQuotient.Quotient G Î“)\nmeas_V : MeasurableSet V\nneZeroV : Ne (Î¼ V) 0\nhV : Eq (Î¼ V) (Î½ (Inter.inter (Set.preimage QuotientGroup.mk V) s))\nneTopV : Ne (Î¼ V) Top.top\nâŠ¢ MeasureTheory.QuotientMeasureEqMeasurePreimage Î½ Î¼","decl":"/-- Assume that a measure `Î¼` is `IsMulLeftInvariant`, that the action of `Î“` on `G` has a\nmeasurable fundamental domain `s` with positive finite volume, and that there is a single measurable\nset `V âŠ† G â§¸ Î“` along which the pullback of `Î¼` and `Î½` agree (so the scaling is right). Then\n`Î¼` satisfies `QuotientMeasureEqMeasurePreimage`. The main tool of the proof is the uniqueness of\nleft invariant measures, if normalized by a single positive finite-measured set. -/\n@[to_additive\n\"Assume that a measure `Î¼` is `IsAddLeftInvariant`, that the action of `Î“` on `G` has a\nmeasurable fundamental domain `s` with positive finite volume, and that there is a single measurable\nset `V âŠ† G â§¸ Î“` along which the pullback of `Î¼` and `Î½` agree (so the scaling is right). Then\n`Î¼` satisfies `AddQuotientMeasureEqMeasurePreimage`. The main tool of the proof is the uniqueness of\nleft invariant measures, if normalized by a single positive finite-measured set.\"]\ntheorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}\n    (fund_dom_s : IsFundamentalDomain Î“.op s Î½) {V : Set (G â§¸ Î“)}\n    (meas_V : MeasurableSet V) (neZeroV : Î¼ V â‰  0) (hV : Î¼ V = Î½ (Ï€ â»Â¹' V âˆ© s))\n    (neTopV : Î¼ V â‰  âŠ¤) : QuotientMeasureEqMeasurePreimage Î½ Î¼ := by\n  apply fund_dom_s.quotientMeasureEqMeasurePreimage\n  ext U _\n  have meas_Ï€ : Measurable (QuotientGroup.mk : G â†’ G â§¸ Î“) := continuous_quotient_mk'.measurable\n  let Î¼' : Measure (G â§¸ Î“) := (Î½.restrict s).map Ï€\n  haveI has_fund : HasFundamentalDomain Î“.op G Î½ := âŸ¨âŸ¨s, fund_dom_sâŸ©âŸ©\n  have i : QuotientMeasureEqMeasurePreimage Î½ Î¼' :=\n    fund_dom_s.quotientMeasureEqMeasurePreimage_quotientMeasure\n  have : Î¼'.IsMulLeftInvariant :=\n    MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient Î½\n  suffices Î¼ = Î¼' by\n    rw [this]\n    rfl\n  have : SigmaFinite Î¼' := i.sigmaFiniteQuotient\n  rw [measure_eq_div_smul Î¼' Î¼ neZeroV neTopV, hV]\n  symm\n  suffices (Î¼' V / Î½ (QuotientGroup.mk â»Â¹' V âˆ© s)) = 1 by rw [this, one_smul]\n  rw [Measure.map_apply meas_Ï€ meas_V, Measure.restrict_apply]\n  Â· convert ENNReal.div_self ..\n    Â· exact trans hV.symm neZeroV\n    Â· exact trans hV.symm neTopV\n  exact measurableSet_quotient.mp meas_V\n\n"}
{"name":"MeasureTheory.Measure.IsAddLeftInvariant.addQuotientMeasureEqMeasurePreimage_of_set","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹â´ : AddGroup G\ninstâœÂ¹Â³ : MeasurableSpace G\ninstâœÂ¹Â² : TopologicalSpace G\ninstâœÂ¹Â¹ : TopologicalAddGroup G\ninstâœÂ¹â° : BorelSpace G\ninstâœâ¹ : PolishSpace G\nÎ“ : AddSubgroup G\ninstâœâ¸ : Î“.Normal\ninstâœâ· : T2Space (HasQuotient.Quotient G Î“)\ninstâœâ¶ : SecondCountableTopology (HasQuotient.Quotient G Î“)\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\nÎ½ : MeasureTheory.Measure G\ninstâœâµ : Î½.IsAddLeftInvariant\ninstâœâ´ : Countable (Subtype fun x => Membership.mem Î“ x)\ninstâœÂ³ : Î½.IsAddRightInvariant\ninstâœÂ² : MeasureTheory.SigmaFinite Î½\ninstâœÂ¹ : Î¼.IsAddLeftInvariant\ninstâœ : MeasureTheory.SigmaFinite Î¼\ns : Set G\nfund_dom_s : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) s Î½\nV : Set (HasQuotient.Quotient G Î“)\nmeas_V : MeasurableSet V\nneZeroV : Ne (Î¼ V) 0\nhV : Eq (Î¼ V) (Î½ (Inter.inter (Set.preimage QuotientAddGroup.mk V) s))\nneTopV : Ne (Î¼ V) Top.top\nâŠ¢ MeasureTheory.AddQuotientMeasureEqMeasurePreimage Î½ Î¼","decl":"/-- Assume that a measure `Î¼` is `IsMulLeftInvariant`, that the action of `Î“` on `G` has a\nmeasurable fundamental domain `s` with positive finite volume, and that there is a single measurable\nset `V âŠ† G â§¸ Î“` along which the pullback of `Î¼` and `Î½` agree (so the scaling is right). Then\n`Î¼` satisfies `QuotientMeasureEqMeasurePreimage`. The main tool of the proof is the uniqueness of\nleft invariant measures, if normalized by a single positive finite-measured set. -/\n@[to_additive\n\"Assume that a measure `Î¼` is `IsAddLeftInvariant`, that the action of `Î“` on `G` has a\nmeasurable fundamental domain `s` with positive finite volume, and that there is a single measurable\nset `V âŠ† G â§¸ Î“` along which the pullback of `Î¼` and `Î½` agree (so the scaling is right). Then\n`Î¼` satisfies `AddQuotientMeasureEqMeasurePreimage`. The main tool of the proof is the uniqueness of\nleft invariant measures, if normalized by a single positive finite-measured set.\"]\ntheorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}\n    (fund_dom_s : IsFundamentalDomain Î“.op s Î½) {V : Set (G â§¸ Î“)}\n    (meas_V : MeasurableSet V) (neZeroV : Î¼ V â‰  0) (hV : Î¼ V = Î½ (Ï€ â»Â¹' V âˆ© s))\n    (neTopV : Î¼ V â‰  âŠ¤) : QuotientMeasureEqMeasurePreimage Î½ Î¼ := by\n  apply fund_dom_s.quotientMeasureEqMeasurePreimage\n  ext U _\n  have meas_Ï€ : Measurable (QuotientGroup.mk : G â†’ G â§¸ Î“) := continuous_quotient_mk'.measurable\n  let Î¼' : Measure (G â§¸ Î“) := (Î½.restrict s).map Ï€\n  haveI has_fund : HasFundamentalDomain Î“.op G Î½ := âŸ¨âŸ¨s, fund_dom_sâŸ©âŸ©\n  have i : QuotientMeasureEqMeasurePreimage Î½ Î¼' :=\n    fund_dom_s.quotientMeasureEqMeasurePreimage_quotientMeasure\n  have : Î¼'.IsMulLeftInvariant :=\n    MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient Î½\n  suffices Î¼ = Î¼' by\n    rw [this]\n    rfl\n  have : SigmaFinite Î¼' := i.sigmaFiniteQuotient\n  rw [measure_eq_div_smul Î¼' Î¼ neZeroV neTopV, hV]\n  symm\n  suffices (Î¼' V / Î½ (QuotientGroup.mk â»Â¹' V âˆ© s)) = 1 by rw [this, one_smul]\n  rw [Measure.map_apply meas_Ï€ meas_V, Measure.restrict_apply]\n  Â· convert ENNReal.div_self ..\n    Â· exact trans hV.symm neZeroV\n    Â· exact trans hV.symm neTopV\n  exact measurableSet_quotient.mp meas_V\n\n"}
{"name":"MeasureTheory.leftInvariantIsQuotientMeasureEqMeasurePreimage","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹âµ : Group G\ninstâœÂ¹â´ : MeasurableSpace G\ninstâœÂ¹Â³ : TopologicalSpace G\ninstâœÂ¹Â² : TopologicalGroup G\ninstâœÂ¹Â¹ : BorelSpace G\ninstâœÂ¹â° : PolishSpace G\nÎ“ : Subgroup G\ninstâœâ¹ : Î“.Normal\ninstâœâ¸ : T2Space (HasQuotient.Quotient G Î“)\ninstâœâ· : SecondCountableTopology (HasQuotient.Quotient G Î“)\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\nÎ½ : MeasureTheory.Measure G\ninstâœâ¶ : Î½.IsMulLeftInvariant\ninstâœâµ : Countable (Subtype fun x => Membership.mem Î“ x)\ninstâœâ´ : Î½.IsMulRightInvariant\ninstâœÂ³ : MeasureTheory.SigmaFinite Î½\ninstâœÂ² : Î¼.IsMulLeftInvariant\ninstâœÂ¹ : MeasureTheory.SigmaFinite Î¼\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhasFun : MeasureTheory.HasFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) G Î½\nh : Eq (MeasureTheory.covolume (Subtype fun x => Membership.mem Î“.op x) G Î½) (Î¼ Set.univ)\nâŠ¢ MeasureTheory.QuotientMeasureEqMeasurePreimage Î½ Î¼","decl":"/-- If a measure `Î¼` is left-invariant and satisfies the right scaling condition, then it\n  satisfies `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive \"If a measure `Î¼` is\nleft-invariant and satisfies the right scaling condition, then it satisfies\n`AddQuotientMeasureEqMeasurePreimage`.\"]\ntheorem MeasureTheory.leftInvariantIsQuotientMeasureEqMeasurePreimage [IsFiniteMeasure Î¼]\n    [hasFun : HasFundamentalDomain Î“.op G Î½]\n    (h : covolume Î“.op G Î½ = Î¼ univ) : QuotientMeasureEqMeasurePreimage Î½ Î¼ := by\n  obtain âŸ¨s, fund_dom_sâŸ© := hasFun.ExistsIsFundamentalDomain\n  have finiteCovol : Î¼ univ < âŠ¤ := measure_lt_top Î¼ univ\n  rw [fund_dom_s.covolume_eq_volume] at h\n  by_cases meas_s_ne_zero : Î½ s = 0\n  Â· convert fund_dom_s.quotientMeasureEqMeasurePreimage_of_zero meas_s_ne_zero\n    rw [â† @measure_univ_eq_zero, â† h, meas_s_ne_zero]\n  apply IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set (fund_dom_s := fund_dom_s)\n    (meas_V := MeasurableSet.univ)\n  Â· rw [â† h]\n    exact meas_s_ne_zero\n  Â· rw [â† h]\n    simp\n  Â· rw [â† h]\n    convert finiteCovol.ne\n\n"}
{"name":"MeasureTheory.leftInvariantIsAddQuotientMeasureEqMeasurePreimage","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹âµ : AddGroup G\ninstâœÂ¹â´ : MeasurableSpace G\ninstâœÂ¹Â³ : TopologicalSpace G\ninstâœÂ¹Â² : TopologicalAddGroup G\ninstâœÂ¹Â¹ : BorelSpace G\ninstâœÂ¹â° : PolishSpace G\nÎ“ : AddSubgroup G\ninstâœâ¹ : Î“.Normal\ninstâœâ¸ : T2Space (HasQuotient.Quotient G Î“)\ninstâœâ· : SecondCountableTopology (HasQuotient.Quotient G Î“)\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\nÎ½ : MeasureTheory.Measure G\ninstâœâ¶ : Î½.IsAddLeftInvariant\ninstâœâµ : Countable (Subtype fun x => Membership.mem Î“ x)\ninstâœâ´ : Î½.IsAddRightInvariant\ninstâœÂ³ : MeasureTheory.SigmaFinite Î½\ninstâœÂ² : Î¼.IsAddLeftInvariant\ninstâœÂ¹ : MeasureTheory.SigmaFinite Î¼\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhasFun : MeasureTheory.HasAddFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) G Î½\nh : Eq (MeasureTheory.addCovolume (Subtype fun x => Membership.mem Î“.op x) G Î½) (Î¼ Set.univ)\nâŠ¢ MeasureTheory.AddQuotientMeasureEqMeasurePreimage Î½ Î¼","decl":"/-- If a measure `Î¼` is left-invariant and satisfies the right scaling condition, then it\n  satisfies `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive \"If a measure `Î¼` is\nleft-invariant and satisfies the right scaling condition, then it satisfies\n`AddQuotientMeasureEqMeasurePreimage`.\"]\ntheorem MeasureTheory.leftInvariantIsQuotientMeasureEqMeasurePreimage [IsFiniteMeasure Î¼]\n    [hasFun : HasFundamentalDomain Î“.op G Î½]\n    (h : covolume Î“.op G Î½ = Î¼ univ) : QuotientMeasureEqMeasurePreimage Î½ Î¼ := by\n  obtain âŸ¨s, fund_dom_sâŸ© := hasFun.ExistsIsFundamentalDomain\n  have finiteCovol : Î¼ univ < âŠ¤ := measure_lt_top Î¼ univ\n  rw [fund_dom_s.covolume_eq_volume] at h\n  by_cases meas_s_ne_zero : Î½ s = 0\n  Â· convert fund_dom_s.quotientMeasureEqMeasurePreimage_of_zero meas_s_ne_zero\n    rw [â† @measure_univ_eq_zero, â† h, meas_s_ne_zero]\n  apply IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set (fund_dom_s := fund_dom_s)\n    (meas_V := MeasurableSet.univ)\n  Â· rw [â† h]\n    exact meas_s_ne_zero\n  Â· rw [â† h]\n    simp\n  Â· rw [â† h]\n    convert finiteCovol.ne\n\n"}
{"name":"MeasureTheory.QuotientMeasureEqMeasurePreimage.haarMeasure_quotient","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹â´ : Group G\ninstâœÂ¹Â³ : MeasurableSpace G\ninstâœÂ¹Â² : TopologicalSpace G\ninstâœÂ¹Â¹ : TopologicalGroup G\ninstâœÂ¹â° : BorelSpace G\ninstâœâ¹ : PolishSpace G\nÎ“ : Subgroup G\ninstâœâ¸ : Î“.Normal\ninstâœâ· : T2Space (HasQuotient.Quotient G Î“)\ninstâœâ¶ : SecondCountableTopology (HasQuotient.Quotient G Î“)\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\ninstâœâµ : Countable (Subtype fun x => Membership.mem Î“ x)\nÎ½ : MeasureTheory.Measure G\ninstâœâ´ : Î½.IsHaarMeasure\ninstâœÂ³ : Î½.IsMulRightInvariant\ninstâœÂ² : LocallyCompactSpace G\ninstâœÂ¹ : MeasureTheory.QuotientMeasureEqMeasurePreimage Î½ Î¼\ni : MeasureTheory.HasFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) G Î½\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nâŠ¢ Î¼.IsHaarMeasure","decl":"/-- If a measure `Î¼` on the quotient `G â§¸ Î“` of a group `G` by a discrete normal subgroup `Î“` having\nfundamental domain, satisfies `QuotientMeasureEqMeasurePreimage` relative to a standardized choice\nof Haar measure on `G`, and assuming `Î¼` is finite, then `Î¼` is itself Haar.\nTODO: Is it possible to drop the assumption that `Î¼` is finite? -/\n@[to_additive \"If a measure `Î¼` on the quotient `G â§¸ Î“` of an additive group `G` by a discrete\nnormal subgroup `Î“` having fundamental domain, satisfies `AddQuotientMeasureEqMeasurePreimage`\nrelative to a standardized choice of Haar measure on `G`, and assuming `Î¼` is finite, then `Î¼` is\nitself Haar.\"]\ntheorem MeasureTheory.QuotientMeasureEqMeasurePreimage.haarMeasure_quotient [LocallyCompactSpace G]\n    [QuotientMeasureEqMeasurePreimage Î½ Î¼] [i : HasFundamentalDomain Î“.op G Î½]\n    [IsFiniteMeasure Î¼] : IsHaarMeasure Î¼ := by\n  obtain âŸ¨KâŸ© := PositiveCompacts.nonempty' (Î± := G)\n  let K' : PositiveCompacts (G â§¸ Î“) :=\n    K.map Ï€ QuotientGroup.continuous_mk QuotientGroup.isOpenMap_coe\n  haveI : IsMulLeftInvariant Î¼ :=\n    MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient Î½\n  rw [haarMeasure_unique Î¼ K']\n  have finiteCovol : covolume Î“.op G Î½ â‰  âŠ¤ :=\n    ne_top_of_lt <| QuotientMeasureEqMeasurePreimage.covolume_ne_top Î¼ (Î½ := Î½)\n  obtain âŸ¨s, fund_dom_sâŸ© := i\n  rw [fund_dom_s.covolume_eq_volume] at finiteCovol\n  -- TODO: why `rw` fails?\n  erw [fund_dom_s.projection_respects_measure_apply Î¼ K'.isCompact.measurableSet]\n  apply IsHaarMeasure.smul\n  Â· intro h\n    haveI i' : IsOpenPosMeasure (Î½ : Measure G) := inferInstance\n    apply IsOpenPosMeasure.open_pos (interior K) (Î¼ := Î½) (self := i')\n    Â· exact isOpen_interior\n    Â· exact K.interior_nonempty\n    rw [â† le_zero_iff,\n      â† fund_dom_s.measure_zero_of_invariant _ (fun g â†¦ QuotientGroup.sound _ _ g) h]\n    apply measure_mono\n    refine interior_subset.trans ?_\n    rw [QuotientGroup.coe_mk']\n    show (K : Set G) âŠ† Ï€ â»Â¹' (Ï€ '' K)\n    exact subset_preimage_image Ï€ K\n  Â· show Î½ (Ï€ â»Â¹' (Ï€ '' K) âˆ© s) â‰  âŠ¤\n    apply ne_of_lt\n    refine lt_of_le_of_lt ?_ finiteCovol.lt_top\n    apply measure_mono\n    exact inter_subset_right\n\n"}
{"name":"MeasureTheory.AddQuotientMeasureEqMeasurePreimage.addHaarMeasure_quotient","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹â´ : AddGroup G\ninstâœÂ¹Â³ : MeasurableSpace G\ninstâœÂ¹Â² : TopologicalSpace G\ninstâœÂ¹Â¹ : TopologicalAddGroup G\ninstâœÂ¹â° : BorelSpace G\ninstâœâ¹ : PolishSpace G\nÎ“ : AddSubgroup G\ninstâœâ¸ : Î“.Normal\ninstâœâ· : T2Space (HasQuotient.Quotient G Î“)\ninstâœâ¶ : SecondCountableTopology (HasQuotient.Quotient G Î“)\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\ninstâœâµ : Countable (Subtype fun x => Membership.mem Î“ x)\nÎ½ : MeasureTheory.Measure G\ninstâœâ´ : Î½.IsAddHaarMeasure\ninstâœÂ³ : Î½.IsAddRightInvariant\ninstâœÂ² : LocallyCompactSpace G\ninstâœÂ¹ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage Î½ Î¼\ni : MeasureTheory.HasAddFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) G Î½\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nâŠ¢ Î¼.IsAddHaarMeasure","decl":"/-- If a measure `Î¼` on the quotient `G â§¸ Î“` of a group `G` by a discrete normal subgroup `Î“` having\nfundamental domain, satisfies `QuotientMeasureEqMeasurePreimage` relative to a standardized choice\nof Haar measure on `G`, and assuming `Î¼` is finite, then `Î¼` is itself Haar.\nTODO: Is it possible to drop the assumption that `Î¼` is finite? -/\n@[to_additive \"If a measure `Î¼` on the quotient `G â§¸ Î“` of an additive group `G` by a discrete\nnormal subgroup `Î“` having fundamental domain, satisfies `AddQuotientMeasureEqMeasurePreimage`\nrelative to a standardized choice of Haar measure on `G`, and assuming `Î¼` is finite, then `Î¼` is\nitself Haar.\"]\ntheorem MeasureTheory.QuotientMeasureEqMeasurePreimage.haarMeasure_quotient [LocallyCompactSpace G]\n    [QuotientMeasureEqMeasurePreimage Î½ Î¼] [i : HasFundamentalDomain Î“.op G Î½]\n    [IsFiniteMeasure Î¼] : IsHaarMeasure Î¼ := by\n  obtain âŸ¨KâŸ© := PositiveCompacts.nonempty' (Î± := G)\n  let K' : PositiveCompacts (G â§¸ Î“) :=\n    K.map Ï€ QuotientGroup.continuous_mk QuotientGroup.isOpenMap_coe\n  haveI : IsMulLeftInvariant Î¼ :=\n    MeasureTheory.QuotientMeasureEqMeasurePreimage.mulInvariantMeasure_quotient Î½\n  rw [haarMeasure_unique Î¼ K']\n  have finiteCovol : covolume Î“.op G Î½ â‰  âŠ¤ :=\n    ne_top_of_lt <| QuotientMeasureEqMeasurePreimage.covolume_ne_top Î¼ (Î½ := Î½)\n  obtain âŸ¨s, fund_dom_sâŸ© := i\n  rw [fund_dom_s.covolume_eq_volume] at finiteCovol\n  -- TODO: why `rw` fails?\n  erw [fund_dom_s.projection_respects_measure_apply Î¼ K'.isCompact.measurableSet]\n  apply IsHaarMeasure.smul\n  Â· intro h\n    haveI i' : IsOpenPosMeasure (Î½ : Measure G) := inferInstance\n    apply IsOpenPosMeasure.open_pos (interior K) (Î¼ := Î½) (self := i')\n    Â· exact isOpen_interior\n    Â· exact K.interior_nonempty\n    rw [â† le_zero_iff,\n      â† fund_dom_s.measure_zero_of_invariant _ (fun g â†¦ QuotientGroup.sound _ _ g) h]\n    apply measure_mono\n    refine interior_subset.trans ?_\n    rw [QuotientGroup.coe_mk']\n    show (K : Set G) âŠ† Ï€ â»Â¹' (Ï€ '' K)\n    exact subset_preimage_image Ï€ K\n  Â· show Î½ (Ï€ â»Â¹' (Ï€ '' K) âˆ© s) â‰  âŠ¤\n    apply ne_of_lt\n    refine lt_of_le_of_lt ?_ finiteCovol.lt_top\n    apply measure_mono\n    exact inter_subset_right\n\n"}
{"name":"IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_HaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹â´ : Group G\ninstâœÂ¹Â³ : MeasurableSpace G\ninstâœÂ¹Â² : TopologicalSpace G\ninstâœÂ¹Â¹ : TopologicalGroup G\ninstâœÂ¹â° : BorelSpace G\ninstâœâ¹ : PolishSpace G\nÎ“ : Subgroup G\ninstâœâ¸ : Î“.Normal\ninstâœâ· : T2Space (HasQuotient.Quotient G Î“)\ninstâœâ¶ : SecondCountableTopology (HasQuotient.Quotient G Î“)\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\ninstâœâµ : Countable (Subtype fun x => Membership.mem Î“ x)\nÎ½ : MeasureTheory.Measure G\ninstâœâ´ : Î½.IsHaarMeasure\ninstâœÂ³ : Î½.IsMulRightInvariant\ninstâœÂ² : MeasureTheory.SigmaFinite Î½\nğ“• : Set G\nhğ“• : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) ğ“• Î½\ninstâœÂ¹ : Î¼.IsMulLeftInvariant\ninstâœ : MeasureTheory.SigmaFinite Î¼\nV : Set (HasQuotient.Quotient G Î“)\nhV : (interior V).Nonempty\nmeas_V : MeasurableSet V\nhÎ¼K : Eq (Î¼ V) (Î½ (Inter.inter (Set.preimage QuotientGroup.mk V) ğ“•))\nneTopV : Ne (Î¼ V) Top.top\nâŠ¢ MeasureTheory.QuotientMeasureEqMeasurePreimage Î½ Î¼","decl":"/-- Given a normal subgroup `Î“` of a topological group `G` with Haar measure `Î¼`, which is also\n  right-invariant, and a finite volume fundamental domain `ğ“•`, the quotient map to `G â§¸ Î“`,\n  properly normalized, satisfies `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive \"Given a normal\nsubgroup `Î“` of an additive topological group `G` with Haar measure `Î¼`, which is also\nright-invariant, and a finite volume fundamental domain `ğ“•`, the quotient map to `G â§¸ Î“`,\nproperly normalized, satisfies `AddQuotientMeasureEqMeasurePreimage`.\"]\ntheorem IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_HaarMeasure {ğ“• : Set G}\n    (hğ“• : IsFundamentalDomain Î“.op ğ“• Î½) [IsMulLeftInvariant Î¼] [SigmaFinite Î¼]\n    {V : Set (G â§¸ Î“)} (hV : (interior V).Nonempty) (meas_V : MeasurableSet V)\n    (hÎ¼K : Î¼ V = Î½ ((Ï€ â»Â¹' V) âˆ© ğ“•)) (neTopV : Î¼ V â‰  âŠ¤) :\n    QuotientMeasureEqMeasurePreimage Î½ Î¼ := by\n  apply IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set (fund_dom_s := hğ“•)\n    (meas_V := meas_V)\n  Â· rw [hÎ¼K]\n    intro c_eq_zero\n    apply IsOpenPosMeasure.open_pos (interior (Ï€ â»Â¹' V)) (Î¼ := Î½)\n    Â· simp\n    Â· apply Set.Nonempty.mono (preimage_interior_subset_interior_preimage continuous_coinduced_rng)\n      apply hV.preimage'\n      simp\n    Â· apply measure_mono_null (h := interior_subset)\n      apply hğ“•.measure_zero_of_invariant (ht := fun g â†¦ QuotientGroup.sound _ _ g)\n      exact c_eq_zero\n  Â· exact hÎ¼K\n  Â· exact neTopV\n\n"}
{"name":"IsFundamentalDomain.AddQuotientMeasureEqMeasurePreimage_AddHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹â´ : AddGroup G\ninstâœÂ¹Â³ : MeasurableSpace G\ninstâœÂ¹Â² : TopologicalSpace G\ninstâœÂ¹Â¹ : TopologicalAddGroup G\ninstâœÂ¹â° : BorelSpace G\ninstâœâ¹ : PolishSpace G\nÎ“ : AddSubgroup G\ninstâœâ¸ : Î“.Normal\ninstâœâ· : T2Space (HasQuotient.Quotient G Î“)\ninstâœâ¶ : SecondCountableTopology (HasQuotient.Quotient G Î“)\nÎ¼ : MeasureTheory.Measure (HasQuotient.Quotient G Î“)\ninstâœâµ : Countable (Subtype fun x => Membership.mem Î“ x)\nÎ½ : MeasureTheory.Measure G\ninstâœâ´ : Î½.IsAddHaarMeasure\ninstâœÂ³ : Î½.IsAddRightInvariant\ninstâœÂ² : MeasureTheory.SigmaFinite Î½\nğ“• : Set G\nhğ“• : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) ğ“• Î½\ninstâœÂ¹ : Î¼.IsAddLeftInvariant\ninstâœ : MeasureTheory.SigmaFinite Î¼\nV : Set (HasQuotient.Quotient G Î“)\nhV : (interior V).Nonempty\nmeas_V : MeasurableSet V\nhÎ¼K : Eq (Î¼ V) (Î½ (Inter.inter (Set.preimage QuotientAddGroup.mk V) ğ“•))\nneTopV : Ne (Î¼ V) Top.top\nâŠ¢ MeasureTheory.AddQuotientMeasureEqMeasurePreimage Î½ Î¼","decl":"/-- Given a normal subgroup `Î“` of a topological group `G` with Haar measure `Î¼`, which is also\n  right-invariant, and a finite volume fundamental domain `ğ“•`, the quotient map to `G â§¸ Î“`,\n  properly normalized, satisfies `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive \"Given a normal\nsubgroup `Î“` of an additive topological group `G` with Haar measure `Î¼`, which is also\nright-invariant, and a finite volume fundamental domain `ğ“•`, the quotient map to `G â§¸ Î“`,\nproperly normalized, satisfies `AddQuotientMeasureEqMeasurePreimage`.\"]\ntheorem IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_HaarMeasure {ğ“• : Set G}\n    (hğ“• : IsFundamentalDomain Î“.op ğ“• Î½) [IsMulLeftInvariant Î¼] [SigmaFinite Î¼]\n    {V : Set (G â§¸ Î“)} (hV : (interior V).Nonempty) (meas_V : MeasurableSet V)\n    (hÎ¼K : Î¼ V = Î½ ((Ï€ â»Â¹' V) âˆ© ğ“•)) (neTopV : Î¼ V â‰  âŠ¤) :\n    QuotientMeasureEqMeasurePreimage Î½ Î¼ := by\n  apply IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set (fund_dom_s := hğ“•)\n    (meas_V := meas_V)\n  Â· rw [hÎ¼K]\n    intro c_eq_zero\n    apply IsOpenPosMeasure.open_pos (interior (Ï€ â»Â¹' V)) (Î¼ := Î½)\n    Â· simp\n    Â· apply Set.Nonempty.mono (preimage_interior_subset_interior_preimage continuous_coinduced_rng)\n      apply hV.preimage'\n      simp\n    Â· apply measure_mono_null (h := interior_subset)\n      apply hğ“•.measure_zero_of_invariant (ht := fun g â†¦ QuotientGroup.sound _ _ g)\n      exact c_eq_zero\n  Â· exact hÎ¼K\n  Â· exact neTopV\n\n"}
{"name":"IsFundamentalDomain.AddQuotientMeasureEqMeasurePreimage_vaddAddHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹Â² : AddGroup G\ninstâœÂ¹Â¹ : MeasurableSpace G\ninstâœÂ¹â° : TopologicalSpace G\ninstâœâ¹ : TopologicalAddGroup G\ninstâœâ¸ : BorelSpace G\ninstâœâ· : PolishSpace G\nÎ“ : AddSubgroup G\ninstâœâ¶ : Î“.Normal\ninstâœâµ : T2Space (HasQuotient.Quotient G Î“)\ninstâœâ´ : SecondCountableTopology (HasQuotient.Quotient G Î“)\ninstâœÂ³ : Countable (Subtype fun x => Membership.mem Î“ x)\nÎ½ : MeasureTheory.Measure G\ninstâœÂ² : Î½.IsAddHaarMeasure\ninstâœÂ¹ : Î½.IsAddRightInvariant\ninstâœ : MeasureTheory.SigmaFinite Î½\nK : TopologicalSpace.PositiveCompacts (HasQuotient.Quotient G Î“)\nğ“• : Set G\nhğ“• : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) ğ“• Î½\nhğ“•_finite : Ne (Î½ ğ“•) Top.top\nâŠ¢ MeasureTheory.AddQuotientMeasureEqMeasurePreimage Î½ (HSMul.hSMul (Î½ (Inter.inter (Set.preimage QuotientAddGroup.mk â†‘K) ğ“•)) (MeasureTheory.Measure.addHaarMeasure K))","decl":"/-- Given a normal subgroup `Î“` of a topological group `G` with Haar measure `Î¼`, which is also\n  right-invariant, and a finite volume fundamental domain `ğ“•`, the quotient map to `G â§¸ Î“`,\n  properly normalized, satisfies `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive \"Given a\nnormal subgroup `Î“` of an additive topological group `G` with Haar measure `Î¼`, which is also\nright-invariant, and a finite volume fundamental domain `ğ“•`, the quotient map to `G â§¸ Î“`,\nproperly normalized, satisfies `AddQuotientMeasureEqMeasurePreimage`.\"]\ntheorem IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_smulHaarMeasure {ğ“• : Set G}\n    (hğ“• : IsFundamentalDomain Î“.op ğ“• Î½) (hğ“•_finite : Î½ ğ“• â‰  âŠ¤) :\n    QuotientMeasureEqMeasurePreimage Î½\n      ((Î½ ((Ï€ â»Â¹' (K : Set (G â§¸ Î“))) âˆ© ğ“•)) â€¢ haarMeasure K) := by\n  set c := Î½ ((Ï€ â»Â¹' (K : Set (G â§¸ Î“))) âˆ© ğ“•)\n  have c_ne_top : c â‰  âˆ := by\n    contrapose! hğ“•_finite\n    have : c â‰¤ Î½ ğ“• := measure_mono (Set.inter_subset_right)\n    rw [hğ“•_finite] at this\n    exact top_unique this\n  set Î¼ := c â€¢ haarMeasure K\n  have hÎ¼K : Î¼ K = c := by simp [Î¼, haarMeasure_self]\n  haveI : SigmaFinite Î¼ := by\n    clear_value c\n    lift c to NNReal using c_ne_top\n    exact SMul.sigmaFinite c\n  apply IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_HaarMeasure (hğ“• := hğ“•)\n    (meas_V := K.isCompact.measurableSet) (Î¼ := Î¼)\n  Â· exact K.interior_nonempty\n  Â· exact hÎ¼K\n  Â· rw [hÎ¼K]\n    exact c_ne_top\n\n"}
{"name":"IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_smulHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹Â² : Group G\ninstâœÂ¹Â¹ : MeasurableSpace G\ninstâœÂ¹â° : TopologicalSpace G\ninstâœâ¹ : TopologicalGroup G\ninstâœâ¸ : BorelSpace G\ninstâœâ· : PolishSpace G\nÎ“ : Subgroup G\ninstâœâ¶ : Î“.Normal\ninstâœâµ : T2Space (HasQuotient.Quotient G Î“)\ninstâœâ´ : SecondCountableTopology (HasQuotient.Quotient G Î“)\ninstâœÂ³ : Countable (Subtype fun x => Membership.mem Î“ x)\nÎ½ : MeasureTheory.Measure G\ninstâœÂ² : Î½.IsHaarMeasure\ninstâœÂ¹ : Î½.IsMulRightInvariant\ninstâœ : MeasureTheory.SigmaFinite Î½\nK : TopologicalSpace.PositiveCompacts (HasQuotient.Quotient G Î“)\nğ“• : Set G\nhğ“• : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) ğ“• Î½\nhğ“•_finite : Ne (Î½ ğ“•) Top.top\nâŠ¢ MeasureTheory.QuotientMeasureEqMeasurePreimage Î½ (HSMul.hSMul (Î½ (Inter.inter (Set.preimage QuotientGroup.mk â†‘K) ğ“•)) (MeasureTheory.Measure.haarMeasure K))","decl":"/-- Given a normal subgroup `Î“` of a topological group `G` with Haar measure `Î¼`, which is also\n  right-invariant, and a finite volume fundamental domain `ğ“•`, the quotient map to `G â§¸ Î“`,\n  properly normalized, satisfies `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive \"Given a\nnormal subgroup `Î“` of an additive topological group `G` with Haar measure `Î¼`, which is also\nright-invariant, and a finite volume fundamental domain `ğ“•`, the quotient map to `G â§¸ Î“`,\nproperly normalized, satisfies `AddQuotientMeasureEqMeasurePreimage`.\"]\ntheorem IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_smulHaarMeasure {ğ“• : Set G}\n    (hğ“• : IsFundamentalDomain Î“.op ğ“• Î½) (hğ“•_finite : Î½ ğ“• â‰  âŠ¤) :\n    QuotientMeasureEqMeasurePreimage Î½\n      ((Î½ ((Ï€ â»Â¹' (K : Set (G â§¸ Î“))) âˆ© ğ“•)) â€¢ haarMeasure K) := by\n  set c := Î½ ((Ï€ â»Â¹' (K : Set (G â§¸ Î“))) âˆ© ğ“•)\n  have c_ne_top : c â‰  âˆ := by\n    contrapose! hğ“•_finite\n    have : c â‰¤ Î½ ğ“• := measure_mono (Set.inter_subset_right)\n    rw [hğ“•_finite] at this\n    exact top_unique this\n  set Î¼ := c â€¢ haarMeasure K\n  have hÎ¼K : Î¼ K = c := by simp [Î¼, haarMeasure_self]\n  haveI : SigmaFinite Î¼ := by\n    clear_value c\n    lift c to NNReal using c_ne_top\n    exact SMul.sigmaFinite c\n  apply IsFundamentalDomain.QuotientMeasureEqMeasurePreimage_HaarMeasure (hğ“• := hğ“•)\n    (meas_V := K.isCompact.measurableSet) (Î¼ := Î¼)\n  Â· exact K.interior_nonempty\n  Â· exact hÎ¼K\n  Â· rw [hÎ¼K]\n    exact c_ne_top\n\n"}
{"name":"essSup_comp_quotientAddGroup_mk","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœâ¸ : AddGroup G\ninstâœâ· : MeasurableSpace G\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalAddGroup G\ninstâœâ´ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\nÎ“ : AddSubgroup G\nğ“• : Set G\nhğ“• : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) ğ“• Î¼\ninstâœÂ³ : Countable (Subtype fun x => Membership.mem Î“ x)\ninstâœÂ² : MeasurableSpace (HasQuotient.Quotient G Î“)\ninstâœÂ¹ : BorelSpace (HasQuotient.Quotient G Î“)\ninstâœ : Î¼.IsAddRightInvariant\ng : HasQuotient.Quotient G Î“ â†’ ENNReal\ng_ae_measurable : AEMeasurable g (MeasureTheory.Measure.map QuotientAddGroup.mk (Î¼.restrict ğ“•))\nâŠ¢ Eq (essSup g (MeasureTheory.Measure.map QuotientAddGroup.mk (Î¼.restrict ğ“•))) (essSup (fun x => g â†‘x) Î¼)","decl":"/-- The `essSup` of a function `g` on the quotient space `G â§¸ Î“` with respect to the pushforward\n  of the restriction, `Î¼_ğ“•`, of a right-invariant measure `Î¼` to a fundamental domain `ğ“•`, is the\n  same as the `essSup` of `g`'s lift to the universal cover `G` with respect to `Î¼`. -/\n@[to_additive \"The `essSup` of a function `g` on the additive quotient space `G â§¸ Î“` with respect\n  to the pushforward of the restriction, `Î¼_ğ“•`, of a right-invariant measure `Î¼` to a fundamental\n  domain `ğ“•`, is the same as the `essSup` of `g`'s lift to the universal cover `G` with respect\n  to `Î¼`.\"]\nlemma essSup_comp_quotientGroup_mk [Î¼.IsMulRightInvariant] {g : G â§¸ Î“ â†’ â„â‰¥0âˆ}\n    (g_ae_measurable : AEMeasurable g Î¼_ğ“•) : essSup g Î¼_ğ“• = essSup (fun (x : G) â†¦ g x) Î¼ := by\n  have hÏ€ : Measurable (QuotientGroup.mk : G â†’ G â§¸ Î“) := continuous_quotient_mk'.measurable\n  rw [essSup_map_measure g_ae_measurable hÏ€.aemeasurable]\n  refine hğ“•.essSup_measure_restrict ?_\n  intro âŸ¨Î³, hÎ³âŸ© x\n  dsimp\n  congr 1\n  exact QuotientGroup.mk_mul_of_mem x hÎ³\n\n"}
{"name":"essSup_comp_quotientGroup_mk","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœâ¸ : Group G\ninstâœâ· : MeasurableSpace G\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalGroup G\ninstâœâ´ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\nÎ“ : Subgroup G\nğ“• : Set G\nhğ“• : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) ğ“• Î¼\ninstâœÂ³ : Countable (Subtype fun x => Membership.mem Î“ x)\ninstâœÂ² : MeasurableSpace (HasQuotient.Quotient G Î“)\ninstâœÂ¹ : BorelSpace (HasQuotient.Quotient G Î“)\ninstâœ : Î¼.IsMulRightInvariant\ng : HasQuotient.Quotient G Î“ â†’ ENNReal\ng_ae_measurable : AEMeasurable g (MeasureTheory.Measure.map QuotientGroup.mk (Î¼.restrict ğ“•))\nâŠ¢ Eq (essSup g (MeasureTheory.Measure.map QuotientGroup.mk (Î¼.restrict ğ“•))) (essSup (fun x => g â†‘x) Î¼)","decl":"/-- The `essSup` of a function `g` on the quotient space `G â§¸ Î“` with respect to the pushforward\n  of the restriction, `Î¼_ğ“•`, of a right-invariant measure `Î¼` to a fundamental domain `ğ“•`, is the\n  same as the `essSup` of `g`'s lift to the universal cover `G` with respect to `Î¼`. -/\n@[to_additive \"The `essSup` of a function `g` on the additive quotient space `G â§¸ Î“` with respect\n  to the pushforward of the restriction, `Î¼_ğ“•`, of a right-invariant measure `Î¼` to a fundamental\n  domain `ğ“•`, is the same as the `essSup` of `g`'s lift to the universal cover `G` with respect\n  to `Î¼`.\"]\nlemma essSup_comp_quotientGroup_mk [Î¼.IsMulRightInvariant] {g : G â§¸ Î“ â†’ â„â‰¥0âˆ}\n    (g_ae_measurable : AEMeasurable g Î¼_ğ“•) : essSup g Î¼_ğ“• = essSup (fun (x : G) â†¦ g x) Î¼ := by\n  have hÏ€ : Measurable (QuotientGroup.mk : G â†’ G â§¸ Î“) := continuous_quotient_mk'.measurable\n  rw [essSup_map_measure g_ae_measurable hÏ€.aemeasurable]\n  refine hğ“•.essSup_measure_restrict ?_\n  intro âŸ¨Î³, hÎ³âŸ© x\n  dsimp\n  congr 1\n  exact QuotientGroup.mk_mul_of_mem x hÎ³\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.absolutelyContinuous_map","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœâ¸ : AddGroup G\ninstâœâ· : MeasurableSpace G\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalAddGroup G\ninstâœâ´ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\nÎ“ : AddSubgroup G\nğ“• : Set G\nhğ“• : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) ğ“• Î¼\ninstâœÂ³ : Countable (Subtype fun x => Membership.mem Î“ x)\ninstâœÂ² : MeasurableSpace (HasQuotient.Quotient G Î“)\ninstâœÂ¹ : BorelSpace (HasQuotient.Quotient G Î“)\ninstâœ : Î¼.IsAddRightInvariant\nâŠ¢ (MeasureTheory.Measure.map QuotientAddGroup.mk Î¼).AbsolutelyContinuous (MeasureTheory.Measure.map QuotientAddGroup.mk (Î¼.restrict ğ“•))","decl":"/-- Given a quotient space `G â§¸ Î“` where `Î“` is `Countable`, and the restriction,\n  `Î¼_ğ“•`, of a right-invariant measure `Î¼` on `G` to a fundamental domain `ğ“•`, a set\n  in the quotient which has `Î¼_ğ“•`-measure zero, also has measure zero under the\n  folding of `Î¼` under the quotient. Note that, if `Î“` is infinite, then the folded map\n  will take the value `âˆ` on any open set in the quotient! -/\n@[to_additive \"Given an additive quotient space `G â§¸ Î“` where `Î“` is `Countable`, and the\n  restriction, `Î¼_ğ“•`, of a right-invariant measure `Î¼` on `G` to a fundamental domain `ğ“•`, a set\n  in the quotient which has `Î¼_ğ“•`-measure zero, also has measure zero under the\n  folding of `Î¼` under the quotient. Note that, if `Î“` is infinite, then the folded map\n  will take the value `âˆ` on any open set in the quotient!\"]\nlemma _root_.MeasureTheory.IsFundamentalDomain.absolutelyContinuous_map\n    [Î¼.IsMulRightInvariant] :\n    map (QuotientGroup.mk : G â†’ G â§¸ Î“) Î¼ â‰ª map (QuotientGroup.mk : G â†’ G â§¸ Î“) (Î¼.restrict ğ“•) := by\n  set Ï€ : G â†’ G â§¸ Î“ := QuotientGroup.mk\n  have meas_Ï€ : Measurable Ï€ := continuous_quotient_mk'.measurable\n  apply AbsolutelyContinuous.mk\n  intro s s_meas hs\n  rw [map_apply meas_Ï€ s_meas] at hs âŠ¢\n  rw [Measure.restrict_apply] at hs\n  Â· apply hğ“•.measure_zero_of_invariant _ _ hs\n    intro Î³\n    ext g\n    rw [Set.mem_smul_set_iff_inv_smul_mem, mem_preimage, mem_preimage]\n    congr! 1\n    convert QuotientGroup.mk_mul_of_mem g (Î³â»Â¹).2 using 1\n  exact MeasurableSet.preimage s_meas meas_Ï€\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.absolutelyContinuous_map","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœâ¸ : Group G\ninstâœâ· : MeasurableSpace G\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalGroup G\ninstâœâ´ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\nÎ“ : Subgroup G\nğ“• : Set G\nhğ“• : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) ğ“• Î¼\ninstâœÂ³ : Countable (Subtype fun x => Membership.mem Î“ x)\ninstâœÂ² : MeasurableSpace (HasQuotient.Quotient G Î“)\ninstâœÂ¹ : BorelSpace (HasQuotient.Quotient G Î“)\ninstâœ : Î¼.IsMulRightInvariant\nâŠ¢ (MeasureTheory.Measure.map QuotientGroup.mk Î¼).AbsolutelyContinuous (MeasureTheory.Measure.map QuotientGroup.mk (Î¼.restrict ğ“•))","decl":"/-- Given a quotient space `G â§¸ Î“` where `Î“` is `Countable`, and the restriction,\n  `Î¼_ğ“•`, of a right-invariant measure `Î¼` on `G` to a fundamental domain `ğ“•`, a set\n  in the quotient which has `Î¼_ğ“•`-measure zero, also has measure zero under the\n  folding of `Î¼` under the quotient. Note that, if `Î“` is infinite, then the folded map\n  will take the value `âˆ` on any open set in the quotient! -/\n@[to_additive \"Given an additive quotient space `G â§¸ Î“` where `Î“` is `Countable`, and the\n  restriction, `Î¼_ğ“•`, of a right-invariant measure `Î¼` on `G` to a fundamental domain `ğ“•`, a set\n  in the quotient which has `Î¼_ğ“•`-measure zero, also has measure zero under the\n  folding of `Î¼` under the quotient. Note that, if `Î“` is infinite, then the folded map\n  will take the value `âˆ` on any open set in the quotient!\"]\nlemma _root_.MeasureTheory.IsFundamentalDomain.absolutelyContinuous_map\n    [Î¼.IsMulRightInvariant] :\n    map (QuotientGroup.mk : G â†’ G â§¸ Î“) Î¼ â‰ª map (QuotientGroup.mk : G â†’ G â§¸ Î“) (Î¼.restrict ğ“•) := by\n  set Ï€ : G â†’ G â§¸ Î“ := QuotientGroup.mk\n  have meas_Ï€ : Measurable Ï€ := continuous_quotient_mk'.measurable\n  apply AbsolutelyContinuous.mk\n  intro s s_meas hs\n  rw [map_apply meas_Ï€ s_meas] at hs âŠ¢\n  rw [Measure.restrict_apply] at hs\n  Â· apply hğ“•.measure_zero_of_invariant _ _ hs\n    intro Î³\n    ext g\n    rw [Set.mem_smul_set_iff_inv_smul_mem, mem_preimage, mem_preimage]\n    congr! 1\n    convert QuotientGroup.mk_mul_of_mem g (Î³â»Â¹).2 using 1\n  exact MeasurableSet.preimage s_meas meas_Ï€\n\n"}
{"name":"QuotientGroup.integral_eq_integral_automorphize","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹â° : Group G\ninstâœâ¹ : MeasurableSpace G\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : TopologicalGroup G\ninstâœâ¶ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\nÎ“ : Subgroup G\nğ“• : Set G\nhğ“• : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) ğ“• Î¼\ninstâœâµ : Countable (Subtype fun x => Membership.mem Î“ x)\ninstâœâ´ : MeasurableSpace (HasQuotient.Quotient G Î“)\ninstâœÂ³ : BorelSpace (HasQuotient.Quotient G Î“)\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : Î¼.IsMulRightInvariant\nf : G â†’ E\nhfâ‚ : MeasureTheory.Integrable f Î¼\nhfâ‚‚ : MeasureTheory.AEStronglyMeasurable (QuotientGroup.automorphize f) (MeasureTheory.Measure.map QuotientGroup.mk (Î¼.restrict ğ“•))\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) (MeasureTheory.integral (MeasureTheory.Measure.map QuotientGroup.mk (Î¼.restrict ğ“•)) fun x => QuotientGroup.automorphize f x)","decl":"/-- This is a simple version of the **Unfolding Trick**: Given a subgroup `Î“` of a group `G`, the\n  integral of a function `f` on `G` with respect to a right-invariant measure `Î¼` is equal to the\n  integral over the quotient `G â§¸ Î“` of the automorphization of `f`. -/\n@[to_additive \"This is a simple version of the **Unfolding Trick**: Given a subgroup `Î“` of an\n  additive group `G`, the integral of a function `f` on `G` with respect to a right-invariant\n  measure `Î¼` is equal to the integral over the quotient `G â§¸ Î“` of the automorphization of `f`.\"]\nlemma QuotientGroup.integral_eq_integral_automorphize {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace â„ E] [Î¼.IsMulRightInvariant] {f : G â†’ E}\n    (hfâ‚ : Integrable f Î¼) (hfâ‚‚ : AEStronglyMeasurable (automorphize f) Î¼_ğ“•) :\n    âˆ« x : G, f x âˆ‚Î¼ = âˆ« x : G â§¸ Î“, automorphize f x âˆ‚Î¼_ğ“• := by\n  calc âˆ« x : G, f x âˆ‚Î¼ = âˆ‘' Î³ : Î“.op, âˆ« x in ğ“•, f (Î³ â€¢ x) âˆ‚Î¼ :=\n    hğ“•.integral_eq_tsum'' f hfâ‚\n    _ = âˆ« x in ğ“•, âˆ‘' Î³ : Î“.op, f (Î³ â€¢ x) âˆ‚Î¼ := ?_\n    _ = âˆ« x : G â§¸ Î“, automorphize f x âˆ‚Î¼_ğ“• :=\n      (integral_map continuous_quotient_mk'.aemeasurable hfâ‚‚).symm\n  rw [integral_tsum]\n  Â· exact fun i â†¦ (hfâ‚.1.comp_quasiMeasurePreserving\n      (measurePreserving_smul i Î¼).quasiMeasurePreserving).restrict\n  Â· rw [â† hğ“•.lintegral_eq_tsum'' (â€–f Â·â€–â‚‘)]\n    exact ne_of_lt hfâ‚.2\n\n"}
{"name":"QuotientAddGroup.integral_eq_integral_automorphize","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹â° : AddGroup G\ninstâœâ¹ : MeasurableSpace G\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : TopologicalAddGroup G\ninstâœâ¶ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\nÎ“ : AddSubgroup G\nğ“• : Set G\nhğ“• : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) ğ“• Î¼\ninstâœâµ : Countable (Subtype fun x => Membership.mem Î“ x)\ninstâœâ´ : MeasurableSpace (HasQuotient.Quotient G Î“)\ninstâœÂ³ : BorelSpace (HasQuotient.Quotient G Î“)\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : Î¼.IsAddRightInvariant\nf : G â†’ E\nhfâ‚ : MeasureTheory.Integrable f Î¼\nhfâ‚‚ : MeasureTheory.AEStronglyMeasurable (QuotientAddGroup.automorphize f) (MeasureTheory.Measure.map QuotientAddGroup.mk (Î¼.restrict ğ“•))\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) (MeasureTheory.integral (MeasureTheory.Measure.map QuotientAddGroup.mk (Î¼.restrict ğ“•)) fun x => QuotientAddGroup.automorphize f x)","decl":"/-- This is a simple version of the **Unfolding Trick**: Given a subgroup `Î“` of a group `G`, the\n  integral of a function `f` on `G` with respect to a right-invariant measure `Î¼` is equal to the\n  integral over the quotient `G â§¸ Î“` of the automorphization of `f`. -/\n@[to_additive \"This is a simple version of the **Unfolding Trick**: Given a subgroup `Î“` of an\n  additive group `G`, the integral of a function `f` on `G` with respect to a right-invariant\n  measure `Î¼` is equal to the integral over the quotient `G â§¸ Î“` of the automorphization of `f`.\"]\nlemma QuotientGroup.integral_eq_integral_automorphize {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace â„ E] [Î¼.IsMulRightInvariant] {f : G â†’ E}\n    (hfâ‚ : Integrable f Î¼) (hfâ‚‚ : AEStronglyMeasurable (automorphize f) Î¼_ğ“•) :\n    âˆ« x : G, f x âˆ‚Î¼ = âˆ« x : G â§¸ Î“, automorphize f x âˆ‚Î¼_ğ“• := by\n  calc âˆ« x : G, f x âˆ‚Î¼ = âˆ‘' Î³ : Î“.op, âˆ« x in ğ“•, f (Î³ â€¢ x) âˆ‚Î¼ :=\n    hğ“•.integral_eq_tsum'' f hfâ‚\n    _ = âˆ« x in ğ“•, âˆ‘' Î³ : Î“.op, f (Î³ â€¢ x) âˆ‚Î¼ := ?_\n    _ = âˆ« x : G â§¸ Î“, automorphize f x âˆ‚Î¼_ğ“• :=\n      (integral_map continuous_quotient_mk'.aemeasurable hfâ‚‚).symm\n  rw [integral_tsum]\n  Â· exact fun i â†¦ (hfâ‚.1.comp_quasiMeasurePreserving\n      (measurePreserving_smul i Î¼).quasiMeasurePreserving).restrict\n  Â· rw [â† hğ“•.lintegral_eq_tsum'' (â€–f Â·â€–â‚‘)]\n    exact ne_of_lt hfâ‚.2\n\n"}
{"name":"QuotientGroup.integral_mul_eq_integral_automorphize_mul","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G : Type u_1\ninstâœÂ¹â° : Group G\ninstâœâ¹ : MeasurableSpace G\ninstâœâ¸ : TopologicalSpace G\ninstâœâ· : TopologicalGroup G\ninstâœâ¶ : BorelSpace G\nÎ¼ : MeasureTheory.Measure G\nÎ“ : Subgroup G\nğ“• : Set G\nhğ“• : MeasureTheory.IsFundamentalDomain (Subtype fun x => Membership.mem Î“.op x) ğ“• Î¼\ninstâœâµ : Countable (Subtype fun x => Membership.mem Î“ x)\ninstâœâ´ : MeasurableSpace (HasQuotient.Quotient G Î“)\ninstâœÂ³ : BorelSpace (HasQuotient.Quotient G Î“)\nK : Type u_2\ninstâœÂ² : NormedField K\ninstâœÂ¹ : NormedSpace Real K\ninstâœ : Î¼.IsMulRightInvariant\nf : G â†’ K\nf_â„’_1 : MeasureTheory.Integrable f Î¼\ng : HasQuotient.Quotient G Î“ â†’ K\nhg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map QuotientGroup.mk (Î¼.restrict ğ“•))\ng_â„’_infinity : Ne (essSup (fun x => ENorm.enorm (g x)) (MeasureTheory.Measure.map QuotientGroup.mk (Î¼.restrict ğ“•))) Top.top\nF_ae_measurable : MeasureTheory.AEStronglyMeasurable (QuotientGroup.automorphize f) (MeasureTheory.Measure.map QuotientGroup.mk (Î¼.restrict ğ“•))\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => HMul.hMul (g â†‘x) (f x)) (MeasureTheory.integral (MeasureTheory.Measure.map QuotientGroup.mk (Î¼.restrict ğ“•)) fun x => HMul.hMul (g x) (QuotientGroup.automorphize f x))","decl":"/-- This is the **Unfolding Trick**: Given a subgroup `Î“` of a group `G`, the integral of a\n  function `f` on `G` times the lift to `G` of a function `g` on the quotient `G â§¸ Î“` with respect\n  to a right-invariant measure `Î¼` on `G`, is equal to the integral over the quotient of the\n  automorphization of `f` times `g`. -/\nlemma QuotientGroup.integral_mul_eq_integral_automorphize_mul {K : Type*} [NormedField K]\n    [NormedSpace â„ K] [Î¼.IsMulRightInvariant] {f : G â†’ K}\n    (f_â„’_1 : Integrable f Î¼) {g : G â§¸ Î“ â†’ K} (hg : AEStronglyMeasurable g Î¼_ğ“•)\n    (g_â„’_infinity : essSup (fun x â†¦ â†‘â€–g xâ€–â‚‘) Î¼_ğ“• â‰  âˆ)\n    (F_ae_measurable : AEStronglyMeasurable (QuotientGroup.automorphize f) Î¼_ğ“•) :\n    âˆ« x : G, g (x : G â§¸ Î“) * (f x) âˆ‚Î¼\n      = âˆ« x : G â§¸ Î“, g x * (QuotientGroup.automorphize f x) âˆ‚Î¼_ğ“• := by\n  let Ï€ : G â†’ G â§¸ Î“ := QuotientGroup.mk\n  have meas_Ï€ : Measurable Ï€ := continuous_quotient_mk'.measurable\n  have Hâ‚€ : QuotientGroup.automorphize ((g âˆ˜ Ï€) * f) = g * (QuotientGroup.automorphize f) := by\n    exact QuotientGroup.automorphize_smul_left f g\n  calc âˆ« (x : G), g (Ï€ x) * (f x) âˆ‚Î¼ =\n        âˆ« (x : G â§¸ Î“), QuotientGroup.automorphize ((g âˆ˜ Ï€) * f) x âˆ‚Î¼_ğ“• := ?_\n    _ = âˆ« (x : G â§¸ Î“), g x * (QuotientGroup.automorphize f x) âˆ‚Î¼_ğ“• := by simp [Hâ‚€]\n  have Hâ‚ : Integrable ((g âˆ˜ Ï€) * f) Î¼ := by\n    have : AEStronglyMeasurable (fun (x : G) â†¦ g (x : (G â§¸ Î“))) Î¼ :=\n      (hg.mono_ac hğ“•.absolutelyContinuous_map).comp_measurable meas_Ï€\n    refine Integrable.essSup_smul f_â„’_1 this ?_\n    have hg' : AEStronglyMeasurable (â€–g Â·â€–â‚‘) Î¼_ğ“• := continuous_enorm.comp_aestronglyMeasurable hg\n    rw [â† essSup_comp_quotientGroup_mk hğ“• hg'.aemeasurable]\n    exact g_â„’_infinity\n  have Hâ‚‚ : AEStronglyMeasurable (QuotientGroup.automorphize ((g âˆ˜ Ï€) * f)) Î¼_ğ“• := by\n    simp_rw [Hâ‚€]\n    exact hg.mul F_ae_measurable\n  apply QuotientGroup.integral_eq_integral_automorphize hğ“• Hâ‚ Hâ‚‚\n\n"}
{"name":"QuotientAddGroup.integral_mul_eq_integral_automorphize_mul","module":"Mathlib.MeasureTheory.Measure.Haar.Quotient","initialProofState":"G' : Type u_1\ninstâœÂ¹â° : AddGroup G'\ninstâœâ¹ : MeasurableSpace G'\ninstâœâ¸ : TopologicalSpace G'\ninstâœâ· : TopologicalAddGroup G'\ninstâœâ¶ : BorelSpace G'\nÎ¼' : MeasureTheory.Measure G'\nÎ“' : AddSubgroup G'\ninstâœâµ : Countable (Subtype fun x => Membership.mem Î“' x)\ninstâœâ´ : MeasurableSpace (HasQuotient.Quotient G' Î“')\ninstâœÂ³ : BorelSpace (HasQuotient.Quotient G' Î“')\nğ“•' : Set G'\nK : Type u_2\ninstâœÂ² : NormedField K\ninstâœÂ¹ : NormedSpace Real K\ninstâœ : Î¼'.IsAddRightInvariant\nf : G' â†’ K\nf_â„’_1 : MeasureTheory.Integrable f Î¼'\ng : HasQuotient.Quotient G' Î“' â†’ K\nhg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map QuotientAddGroup.mk (Î¼'.restrict ğ“•'))\ng_â„’_infinity : Ne (essSup (fun x => ENorm.enorm (g x)) (MeasureTheory.Measure.map QuotientAddGroup.mk (Î¼'.restrict ğ“•'))) Top.top\nF_ae_measurable : MeasureTheory.AEStronglyMeasurable (QuotientAddGroup.automorphize f) (MeasureTheory.Measure.map QuotientAddGroup.mk (Î¼'.restrict ğ“•'))\nhğ“• : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem Î“'.op x) ğ“•' Î¼'\nâŠ¢ Eq (MeasureTheory.integral Î¼' fun x => HMul.hMul (g â†‘x) (f x)) (MeasureTheory.integral (MeasureTheory.Measure.map QuotientAddGroup.mk (Î¼'.restrict ğ“•')) fun x => HMul.hMul (g x) (QuotientAddGroup.automorphize f x))","decl":"/-- This is the **Unfolding Trick**: Given an additive subgroup `Î“'` of an additive group `G'`, the\n  integral of a function `f` on `G'` times the lift to `G'` of a function `g` on the quotient\n  `G' â§¸ Î“'` with respect to a right-invariant measure `Î¼` on `G'`, is equal to the integral over\n  the quotient of the automorphization of `f` times `g`. -/\nlemma QuotientAddGroup.integral_mul_eq_integral_automorphize_mul {K : Type*} [NormedField K]\n    [NormedSpace â„ K] [Î¼'.IsAddRightInvariant] {f : G' â†’ K}\n    (f_â„’_1 : Integrable f Î¼') {g : G' â§¸ Î“' â†’ K} (hg : AEStronglyMeasurable g Î¼_ğ“•)\n    (g_â„’_infinity : essSup (â€–g Â·â€–â‚‘) Î¼_ğ“• â‰  âˆ)\n    (F_ae_measurable : AEStronglyMeasurable (QuotientAddGroup.automorphize f) Î¼_ğ“•)\n    (hğ“• : IsAddFundamentalDomain Î“'.op ğ“•' Î¼') :\n    âˆ« x : G', g (x : G' â§¸ Î“') * (f x) âˆ‚Î¼'\n      = âˆ« x : G' â§¸ Î“', g x * (QuotientAddGroup.automorphize f x) âˆ‚Î¼_ğ“• := by\n  let Ï€ : G' â†’ G' â§¸ Î“' := QuotientAddGroup.mk\n  have meas_Ï€ : Measurable Ï€ := continuous_quotient_mk'.measurable\n  have Hâ‚€ : QuotientAddGroup.automorphize ((g âˆ˜ Ï€) * f) = g * (QuotientAddGroup.automorphize f) :=\n    by exact QuotientAddGroup.automorphize_smul_left f g\n  calc âˆ« (x : G'), g (Ï€ x) * f x âˆ‚Î¼' =\n    âˆ« (x : G' â§¸ Î“'), QuotientAddGroup.automorphize ((g âˆ˜ Ï€) * f) x âˆ‚Î¼_ğ“• := ?_\n    _ = âˆ« (x : G' â§¸ Î“'), g x * (QuotientAddGroup.automorphize f x) âˆ‚Î¼_ğ“• := by simp [Hâ‚€]\n  have Hâ‚ : Integrable ((g âˆ˜ Ï€) * f) Î¼' := by\n    have : AEStronglyMeasurable (fun (x : G') â†¦ g (x : (G' â§¸ Î“'))) Î¼' :=\n      (hg.mono_ac hğ“•.absolutelyContinuous_map).comp_measurable meas_Ï€\n    refine Integrable.essSup_smul f_â„’_1 this ?_\n    have hg' : AEStronglyMeasurable (â€–g Â·â€–â‚‘) Î¼_ğ“• := continuous_enorm.comp_aestronglyMeasurable hg\n    rw [â† essSup_comp_quotientAddGroup_mk hğ“• hg'.aemeasurable]\n    exact g_â„’_infinity\n  have Hâ‚‚ : AEStronglyMeasurable (QuotientAddGroup.automorphize ((g âˆ˜ Ï€) * f)) Î¼_ğ“• := by\n    simp_rw [Hâ‚€]\n    exact hg.mul F_ae_measurable\n  apply QuotientAddGroup.integral_eq_integral_automorphize hğ“• Hâ‚ Hâ‚‚\n\n"}
