{"name":"Units.val_neg","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝¹ : Monoid α\ninst✝ : HasDistribNeg α\nu : Units α\n⊢ Eq (↑(Neg.neg u)) (Neg.neg ↑u)","decl":"/-- Representing an element of a ring's unit group as an element of the ring commutes with\n    mapping this element to its additive inverse. -/\n@[simp, norm_cast]\nprotected theorem val_neg (u : αˣ) : (↑(-u) : α) = -u :=\n  rfl\n\n"}
{"name":"Units.coe_neg_one","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝¹ : Monoid α\ninst✝ : HasDistribNeg α\n⊢ Eq (↑(-1)) (-1)","decl":"@[simp, norm_cast]\nprotected theorem coe_neg_one : ((-1 : αˣ) : α) = -1 :=\n  rfl\n\n"}
{"name":"Units.neg_divp","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝¹ : Monoid α\ninst✝ : HasDistribNeg α\na : α\nu : Units α\n⊢ Eq (Neg.neg (divp a u)) (divp (Neg.neg a) u)","decl":"@[field_simps]\ntheorem neg_divp (a : α) (u : αˣ) : -(a /ₚ u) = -a /ₚ u := by simp only [divp, neg_mul]\n\n"}
{"name":"Units.divp_add_divp_same","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝ : Ring α\na b : α\nu : Units α\n⊢ Eq (HAdd.hAdd (divp a u) (divp b u)) (divp (HAdd.hAdd a b) u)","decl":"@[field_simps 1010]\ntheorem divp_add_divp_same (a b : α) (u : αˣ) : a /ₚ u + b /ₚ u = (a + b) /ₚ u := by\n  simp only [divp, add_mul]\n\n-- Needs to have higher simp priority than divp_sub_divp. 1000 is the default priority.\n"}
{"name":"Units.divp_sub_divp_same","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝ : Ring α\na b : α\nu : Units α\n⊢ Eq (HSub.hSub (divp a u) (divp b u)) (divp (HSub.hSub a b) u)","decl":"@[field_simps 1010]\ntheorem divp_sub_divp_same (a b : α) (u : αˣ) : a /ₚ u - b /ₚ u = (a - b) /ₚ u := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, neg_divp, divp_add_divp_same]\n\n"}
{"name":"Units.add_divp","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝ : Ring α\na b : α\nu : Units α\n⊢ Eq (HAdd.hAdd a (divp b u)) (divp (HAdd.hAdd (HMul.hMul a ↑u) b) u)","decl":"@[field_simps]\ntheorem add_divp (a b : α) (u : αˣ) : a + b /ₚ u = (a * u + b) /ₚ u := by\n  simp only [divp, add_mul, Units.mul_inv_cancel_right]\n\n"}
{"name":"Units.sub_divp","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝ : Ring α\na b : α\nu : Units α\n⊢ Eq (HSub.hSub a (divp b u)) (divp (HSub.hSub (HMul.hMul a ↑u) b) u)","decl":"@[field_simps]\ntheorem sub_divp (a b : α) (u : αˣ) : a - b /ₚ u = (a * u - b) /ₚ u := by\n  simp only [divp, sub_mul, Units.mul_inv_cancel_right]\n\n"}
{"name":"Units.divp_add","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝ : Ring α\na b : α\nu : Units α\n⊢ Eq (HAdd.hAdd (divp a u) b) (divp (HAdd.hAdd a (HMul.hMul b ↑u)) u)","decl":"@[field_simps]\ntheorem divp_add (a b : α) (u : αˣ) : a /ₚ u + b = (a + b * u) /ₚ u := by\n  simp only [divp, add_mul, Units.mul_inv_cancel_right]\n\n"}
{"name":"Units.divp_sub","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝ : Ring α\na b : α\nu : Units α\n⊢ Eq (HSub.hSub (divp a u) b) (divp (HSub.hSub a (HMul.hMul b ↑u)) u)","decl":"@[field_simps]\ntheorem divp_sub (a b : α) (u : αˣ) : a /ₚ u - b = (a - b * u) /ₚ u := by\n  simp only [divp, sub_mul, sub_right_inj]\n  rw [mul_assoc, Units.mul_inv, mul_one]\n\n"}
{"name":"Units.map_neg","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Ring α\nF : Type u_1\ninst✝² : Ring β\ninst✝¹ : FunLike F α β\ninst✝ : RingHomClass F α β\nf : F\nu : Units α\n⊢ Eq ((Units.map ↑f) (Neg.neg u)) (Neg.neg ((Units.map ↑f) u))","decl":"@[simp]\nprotected theorem map_neg {F : Type*} [Ring β] [FunLike F α β] [RingHomClass F α β]\n    (f : F) (u : αˣ) : map (f : α →* β) (-u) = -map (f : α →* β) u :=\n  ext (by simp only [coe_map, Units.val_neg, MonoidHom.coe_coe, map_neg])\n\n"}
{"name":"Units.map_neg_one","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Ring α\nF : Type u_1\ninst✝² : Ring β\ninst✝¹ : FunLike F α β\ninst✝ : RingHomClass F α β\nf : F\n⊢ Eq ((Units.map ↑f) (-1)) (-1)","decl":"protected theorem map_neg_one {F : Type*} [Ring β] [FunLike F α β] [RingHomClass F α β]\n    (f : F) : map (f : α →* β) (-1) = -1 := by\n  simp only [Units.map_neg, map_one]\n\n"}
{"name":"IsUnit.neg","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝¹ : Monoid α\ninst✝ : HasDistribNeg α\na : α\na✝ : IsUnit a\n⊢ IsUnit (Neg.neg a)","decl":"theorem IsUnit.neg [Monoid α] [HasDistribNeg α] {a : α} : IsUnit a → IsUnit (-a)\n  | ⟨x, hx⟩ => hx ▸ (-x).isUnit\n\n"}
{"name":"IsUnit.neg_iff","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝¹ : Monoid α\ninst✝ : HasDistribNeg α\na : α\n⊢ Iff (IsUnit (Neg.neg a)) (IsUnit a)","decl":"@[simp]\ntheorem IsUnit.neg_iff [Monoid α] [HasDistribNeg α] (a : α) : IsUnit (-a) ↔ IsUnit a :=\n  ⟨fun h => neg_neg a ▸ h.neg, IsUnit.neg⟩\n\n"}
{"name":"isUnit_neg_one","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝¹ : Monoid α\ninst✝ : HasDistribNeg α\n⊢ IsUnit (-1)","decl":"theorem isUnit_neg_one [Monoid α] [HasDistribNeg α] : IsUnit (-1 : α) := isUnit_one.neg\n\n"}
{"name":"IsUnit.sub_iff","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝ : Ring α\nx y : α\n⊢ Iff (IsUnit (HSub.hSub x y)) (IsUnit (HSub.hSub y x))","decl":"theorem IsUnit.sub_iff [Ring α] {x y : α} : IsUnit (x - y) ↔ IsUnit (y - x) :=\n  (IsUnit.neg_iff _).symm.trans <| neg_sub x y ▸ Iff.rfl\n\n"}
{"name":"Units.divp_add_divp","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝ : CommRing α\na b : α\nu₁ u₂ : Units α\n⊢ Eq (HAdd.hAdd (divp a u₁) (divp b u₂)) (divp (HAdd.hAdd (HMul.hMul a ↑u₂) (HMul.hMul (↑u₁) b)) (HMul.hMul u₁ u₂))","decl":"@[field_simps]\ntheorem divp_add_divp [CommRing α] (a b : α) (u₁ u₂ : αˣ) :\n    a /ₚ u₁ + b /ₚ u₂ = (a * u₂ + u₁ * b) /ₚ (u₁ * u₂) := by\n  simp only [divp, add_mul, mul_inv_rev, val_mul]\n  rw [mul_comm (↑u₁ * b), mul_comm b]\n  rw [← mul_assoc, ← mul_assoc, mul_assoc a, mul_assoc (↑u₂⁻¹ : α), mul_inv, inv_mul, mul_one,\n    mul_one]\n  -- Porting note: `assoc_rw` not ported: `assoc_rw [mul_inv, mul_inv, mul_one, mul_one]`\n\n"}
{"name":"Units.divp_sub_divp","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\ninst✝ : CommRing α\na b : α\nu₁ u₂ : Units α\n⊢ Eq (HSub.hSub (divp a u₁) (divp b u₂)) (divp (HSub.hSub (HMul.hMul a ↑u₂) (HMul.hMul (↑u₁) b)) (HMul.hMul u₁ u₂))","decl":"@[field_simps]\ntheorem divp_sub_divp [CommRing α] (a b : α) (u₁ u₂ : αˣ) :\n    a /ₚ u₁ - b /ₚ u₂ = (a * u₂ - u₁ * b) /ₚ (u₁ * u₂) := by\n  simp only [sub_eq_add_neg, neg_divp, divp_add_divp, mul_neg]\n\n"}
{"name":"Units.add_eq_mul_one_add_div","module":"Mathlib.Algebra.Ring.Units","initialProofState":"R : Type x\ninst✝ : Semiring R\na : Units R\nb : R\n⊢ Eq (HAdd.hAdd (↑a) b) (HMul.hMul (↑a) (HAdd.hAdd 1 (HMul.hMul (↑(Inv.inv a)) b)))","decl":"theorem add_eq_mul_one_add_div [Semiring R] {a : Rˣ} {b : R} : ↑a + b = a * (1 + ↑a⁻¹ * b) := by\n  rw [mul_add, mul_one, ← mul_assoc, Units.mul_inv, one_mul]\n\n"}
{"name":"RingHom.isUnit_map","module":"Mathlib.Algebra.Ring.Units","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Semiring α\ninst✝ : Semiring β\nf : RingHom α β\na : α\na✝ : IsUnit a\n⊢ IsUnit (f a)","decl":"theorem isUnit_map (f : α →+* β) {a : α} : IsUnit a → IsUnit (f a) :=\n  IsUnit.map f\n\n"}
