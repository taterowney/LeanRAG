{"name":"CategoryTheory.Simple.mono_isIso_iff_nonzero","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\nself : CategoryTheory.Simple X\nY : C\nf : Quiver.Hom Y X\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Iff (CategoryTheory.IsIso f) (Ne f 0)","decl":"/-- An object is simple if monomorphisms into it are (exclusively) either isomorphisms or zero. -/\nclass Simple (X : C) : Prop where\n  mono_isIso_iff_nonzero : ‚àÄ {Y : C} (f : Y ‚ü∂ X) [Mono f], IsIso f ‚Üî f ‚â† 0\n\n"}
{"name":"CategoryTheory.isIso_of_mono_of_nonzero","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst‚úù¬π : CategoryTheory.Simple Y\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\nw : Ne f 0\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- A nonzero monomorphism to a simple object is an isomorphism. -/\ntheorem isIso_of_mono_of_nonzero {X Y : C} [Simple Y] {f : X ‚ü∂ Y} [Mono f] (w : f ‚â† 0) : IsIso f :=\n  (Simple.mono_isIso_iff_nonzero f).mpr w\n\n"}
{"name":"CategoryTheory.Simple.of_iso","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst‚úù : CategoryTheory.Simple Y\ni : CategoryTheory.Iso X Y\n‚ä¢ CategoryTheory.Simple X","decl":"theorem Simple.of_iso {X Y : C} [Simple Y] (i : X ‚âÖ Y) : Simple X :=\n  { mono_isIso_iff_nonzero := fun f m => by\n      constructor\n      ¬∑ intro h w\n        have j : IsIso (f ‚â´ i.hom) := by infer_instance\n        rw [Simple.mono_isIso_iff_nonzero] at j\n        subst w\n        simp at j\n      ¬∑ intro h\n        have j : IsIso (f ‚â´ i.hom) := by\n          apply isIso_of_mono_of_nonzero\n          intro w\n          apply h\n          simpa using (cancel_mono i.inv).2 w\n        rw [‚Üê Category.comp_id f, ‚Üê i.hom_inv_id, ‚Üê Category.assoc]\n        infer_instance }\n\n"}
{"name":"CategoryTheory.Simple.iff_of_iso","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ni : CategoryTheory.Iso X Y\n‚ä¢ Iff (CategoryTheory.Simple X) (CategoryTheory.Simple Y)","decl":"theorem Simple.iff_of_iso {X Y : C} (i : X ‚âÖ Y) : Simple X ‚Üî Simple Y :=\n  ‚ü®fun _ => Simple.of_iso i.symm, fun _ => Simple.of_iso i‚ü©\n\n"}
{"name":"CategoryTheory.kernel_zero_of_nonzero_from_simple","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst‚úù¬π : CategoryTheory.Simple X\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nw : Ne f 0\n‚ä¢ Eq (CategoryTheory.Limits.kernel.Œπ f) 0","decl":"theorem kernel_zero_of_nonzero_from_simple {X Y : C} [Simple X] {f : X ‚ü∂ Y} [HasKernel f]\n    (w : f ‚â† 0) : kernel.Œπ f = 0 := by\n  classical\n    by_contra h\n    haveI := isIso_of_mono_of_nonzero h\n    exact w (eq_zero_of_epi_kernel f)\n\n-- See also `mono_of_nonzero_from_simple`, which requires `Preadditive C`.\n"}
{"name":"CategoryTheory.epi_of_nonzero_to_simple","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasEqualizers C\nX Y : C\ninst‚úù¬π : CategoryTheory.Simple Y\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nw : Ne f 0\n‚ä¢ CategoryTheory.Epi f","decl":"/-- A nonzero morphism `f` to a simple object is an epimorphism\n(assuming `f` has an image, and `C` has equalizers).\n-/\ntheorem epi_of_nonzero_to_simple [HasEqualizers C] {X Y : C} [Simple Y] {f : X ‚ü∂ Y} [HasImage f]\n    (w : f ‚â† 0) : Epi f := by\n  rw [‚Üê image.fac f]\n  haveI : IsIso (image.Œπ f) := isIso_of_mono_of_nonzero fun h => w (eq_zero_of_image_eq_zero h)\n  apply epi_comp\n\n"}
{"name":"CategoryTheory.mono_to_simple_zero_of_not_iso","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst‚úù¬π : CategoryTheory.Simple Y\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\nw : CategoryTheory.IsIso f ‚Üí False\n‚ä¢ Eq f 0","decl":"theorem mono_to_simple_zero_of_not_iso {X Y : C} [Simple Y] {f : X ‚ü∂ Y} [Mono f]\n    (w : IsIso f ‚Üí False) : f = 0 := by\n  classical\n    by_contra h\n    exact w (isIso_of_mono_of_nonzero h)\n\n"}
{"name":"CategoryTheory.id_nonzero","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\ninst‚úù : CategoryTheory.Simple X\n‚ä¢ Ne (CategoryTheory.CategoryStruct.id X) 0","decl":"theorem id_nonzero (X : C) [Simple.{v} X] : ùüô X ‚â† 0 :=\n  (Simple.mono_isIso_iff_nonzero (ùüô X)).mp (by infer_instance)\n\n"}
{"name":"CategoryTheory.instNontrivialEndOfSimple","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\ninst‚úù : CategoryTheory.Simple X\n‚ä¢ Nontrivial (CategoryTheory.End X)","decl":"instance (X : C) [Simple.{v} X] : Nontrivial (End X) :=\n  nontrivial_of_ne 1 _ (id_nonzero X)\n\n"}
{"name":"CategoryTheory.Simple.not_isZero","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\ninst‚úù : CategoryTheory.Simple X\n‚ä¢ Not (CategoryTheory.Limits.IsZero X)","decl":"theorem Simple.not_isZero (X : C) [Simple X] : ¬¨IsZero X := by\n  simpa [Limits.IsZero.iff_id_eq_zero] using id_nonzero X\n\n"}
{"name":"CategoryTheory.zero_not_simple","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Simple 0\n‚ä¢ False","decl":"/-- We don't want the definition of 'simple' to include the zero object, so we check that here. -/\ntheorem zero_not_simple [Simple (0 : C)] : False :=\n  (Simple.mono_isIso_iff_nonzero (0 : (0 : C) ‚ü∂ (0 : C))).mp ‚ü®‚ü®0, by simp‚ü©‚ü© rfl\n\n"}
{"name":"CategoryTheory.simple_of_cosimple","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nX : C\nh : ‚àÄ {Z : C} (f : Quiver.Hom X Z) [inst : CategoryTheory.Epi f], Iff (CategoryTheory.IsIso f) (Ne f 0)\n‚ä¢ CategoryTheory.Simple X","decl":"/-- In an abelian category, an object satisfying the dual of the definition of a simple object is\n    simple. -/\ntheorem simple_of_cosimple (X : C) (h : ‚àÄ {Z : C} (f : X ‚ü∂ Z) [Epi f], IsIso f ‚Üî f ‚â† 0) :\n    Simple X :=\n  ‚ü®fun {Y} f I => by\n    classical\n      fconstructor\n      ¬∑ intros\n        have hx := cokernel.œÄ_of_epi f\n        by_contra h\n        subst h\n        exact (h _).mp (cokernel.œÄ_of_zero _ _) hx\n      ¬∑ intro hf\n        suffices Epi f by exact isIso_of_mono_of_epi _\n        apply Preadditive.epi_of_cokernel_zero\n        by_contra h'\n        exact cokernel_not_iso_of_nonzero hf ((h _).mpr h')‚ü©\n\n"}
{"name":"CategoryTheory.isIso_of_epi_of_nonzero","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Abelian C\nX Y : C\ninst‚úù¬π : CategoryTheory.Simple X\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\nw : Ne f 0\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- A nonzero epimorphism from a simple object is an isomorphism. -/\ntheorem isIso_of_epi_of_nonzero {X Y : C} [Simple X] {f : X ‚ü∂ Y} [Epi f] (w : f ‚â† 0) : IsIso f :=\n  -- `f ‚â† 0` means that `kernel.Œπ f` is not an iso, and hence zero, and hence `f` is a mono.\n  haveI : Mono f :=\n    Preadditive.mono_of_kernel_zero (mono_to_simple_zero_of_not_iso (kernel_not_iso_of_nonzero w))\n  isIso_of_mono_of_epi f\n\n"}
{"name":"CategoryTheory.cokernel_zero_of_nonzero_to_simple","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\nX Y : C\ninst‚úù : CategoryTheory.Simple Y\nf : Quiver.Hom X Y\nw : Ne f 0\n‚ä¢ Eq (CategoryTheory.Limits.cokernel.œÄ f) 0","decl":"theorem cokernel_zero_of_nonzero_to_simple {X Y : C} [Simple Y] {f : X ‚ü∂ Y} (w : f ‚â† 0) :\n    cokernel.œÄ f = 0 := by\n  classical\n    by_contra h\n    haveI := isIso_of_epi_of_nonzero h\n    exact w (eq_zero_of_mono_cokernel f)\n\n"}
{"name":"CategoryTheory.epi_from_simple_zero_of_not_iso","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Abelian C\nX Y : C\ninst‚úù¬π : CategoryTheory.Simple X\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\nw : CategoryTheory.IsIso f ‚Üí False\n‚ä¢ Eq f 0","decl":"theorem epi_from_simple_zero_of_not_iso {X Y : C} [Simple X] {f : X ‚ü∂ Y} [Epi f]\n    (w : IsIso f ‚Üí False) : f = 0 := by\n  classical\n    by_contra h\n    exact w (isIso_of_epi_of_nonzero h)\n\n"}
{"name":"CategoryTheory.Biprod.isIso_inl_iff_isZero","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nX Y : C\n‚ä¢ Iff (CategoryTheory.IsIso CategoryTheory.Limits.biprod.inl) (CategoryTheory.Limits.IsZero Y)","decl":"theorem Biprod.isIso_inl_iff_isZero (X Y : C) : IsIso (biprod.inl : X ‚ü∂ X ‚äû Y) ‚Üî IsZero Y := by\n  rw [biprod.isIso_inl_iff_id_eq_fst_comp_inl, ‚Üê biprod.total, add_right_eq_self]\n  constructor\n  ¬∑ intro h\n    replace h := h =‚â´ biprod.snd\n    simpa [‚Üê IsZero.iff_isSplitEpi_eq_zero (biprod.snd : X ‚äû Y ‚ü∂ Y)] using h\n  ¬∑ intro h\n    rw [IsZero.iff_isSplitEpi_eq_zero (biprod.snd : X ‚äû Y ‚ü∂ Y)] at h\n    rw [h, zero_comp]\n\n"}
{"name":"CategoryTheory.indecomposable_of_simple","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproducts C\nX : C\ninst‚úù : CategoryTheory.Simple X\n‚ä¢ CategoryTheory.Indecomposable X","decl":"/-- Any simple object in a preadditive category is indecomposable. -/\ntheorem indecomposable_of_simple (X : C) [Simple X] : Indecomposable X :=\n  ‚ü®Simple.not_isZero X, fun Y Z i => by\n    refine or_iff_not_imp_left.mpr fun h => ?_\n    rw [IsZero.iff_isSplitMono_eq_zero (biprod.inl : Y ‚ü∂ Y ‚äû Z)] at h\n    change biprod.inl ‚â† 0 at h\n    have : Simple (Y ‚äû Z) := Simple.of_iso i.symm -- Porting note: this instance is needed\n    rw [‚Üê Simple.mono_isIso_iff_nonzero biprod.inl] at h\n    rwa [Biprod.isIso_inl_iff_isZero] at h‚ü©\n\n"}
{"name":"CategoryTheory.instNontrivialSubobjectOfSimple","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\nX : C\ninst‚úù : CategoryTheory.Simple X\n‚ä¢ Nontrivial (CategoryTheory.Subobject X)","decl":"instance {X : C} [Simple X] : Nontrivial (Subobject X) :=\n  nontrivial_of_not_isZero (Simple.not_isZero X)\n\n"}
{"name":"CategoryTheory.instIsSimpleOrderSubobjectOfSimple","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\nX : C\ninst‚úù : CategoryTheory.Simple X\n‚ä¢ IsSimpleOrder (CategoryTheory.Subobject X)","decl":"instance {X : C} [Simple X] : IsSimpleOrder (Subobject X) where\n  eq_bot_or_eq_top := by\n    rintro ‚ü®‚ü®‚ü®Y : C, ‚ü®‚ü®‚ü©‚ü©, f : Y ‚ü∂ X‚ü©, m : Mono f‚ü©‚ü©\n    change mk f = ‚ä• ‚à® mk f = ‚ä§\n    by_cases h : f = 0\n    ¬∑ exact Or.inl (mk_eq_bot_iff_zero.mpr h)\n    ¬∑ refine Or.inr ((isIso_iff_mk_eq_top _).mp ((Simple.mono_isIso_iff_nonzero f).mpr h))\n\n"}
{"name":"CategoryTheory.simple_of_isSimpleOrder_subobject","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\nX : C\ninst‚úù : IsSimpleOrder (CategoryTheory.Subobject X)\n‚ä¢ CategoryTheory.Simple X","decl":"/-- If `X` has subobject lattice `{‚ä•, ‚ä§}`, then `X` is simple. -/\ntheorem simple_of_isSimpleOrder_subobject (X : C) [IsSimpleOrder (Subobject X)] : Simple X := by\n  constructor; intros Y f hf; constructor\n  ¬∑ intro i\n    rw [Subobject.isIso_iff_mk_eq_top] at i\n    intro w\n    rw [‚Üê Subobject.mk_eq_bot_iff_zero] at w\n    exact IsSimpleOrder.bot_ne_top (w.symm.trans i)\n  ¬∑ intro i\n    rcases IsSimpleOrder.eq_bot_or_eq_top (Subobject.mk f) with (h | h)\n    ¬∑ rw [Subobject.mk_eq_bot_iff_zero] at h\n      exact False.elim (i h)\n    ¬∑ exact (Subobject.isIso_iff_mk_eq_top _).mpr h\n\n"}
{"name":"CategoryTheory.simple_iff_subobject_isSimpleOrder","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX : C\n‚ä¢ Iff (CategoryTheory.Simple X) (IsSimpleOrder (CategoryTheory.Subobject X))","decl":"/-- `X` is simple iff it has subobject lattice `{‚ä•, ‚ä§}`. -/\ntheorem simple_iff_subobject_isSimpleOrder (X : C) : Simple X ‚Üî IsSimpleOrder (Subobject X) :=\n  ‚ü®by\n    intro h\n    infer_instance, by\n    intro h\n    exact simple_of_isSimpleOrder_subobject X‚ü©\n\n"}
{"name":"CategoryTheory.subobject_simple_iff_isAtom","module":"Mathlib.CategoryTheory.Simple","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX : C\nY : CategoryTheory.Subobject X\n‚ä¢ Iff (CategoryTheory.Simple (CategoryTheory.Subobject.underlying.obj Y)) (IsAtom Y)","decl":"/-- A subobject is simple iff it is an atom in the subobject lattice. -/\ntheorem subobject_simple_iff_isAtom {X : C} (Y : Subobject X) : Simple (Y : C) ‚Üî IsAtom Y :=\n  (simple_iff_subobject_isSimpleOrder _).trans\n    ((OrderIso.isSimpleOrder_iff (subobjectOrderIso Y)).trans Set.isSimpleOrder_Iic_iff_isAtom)\n\n"}
