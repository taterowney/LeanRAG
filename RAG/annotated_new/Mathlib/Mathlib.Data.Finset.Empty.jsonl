{"name":"Finset.coe_nonempty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (↑s).Nonempty s.Nonempty","decl":"@[simp, norm_cast]\ntheorem coe_nonempty {s : Finset α} : (s : Set α).Nonempty ↔ s.Nonempty :=\n  Iff.rfl\n\n-- Porting note: Left-hand side simplifies @[simp]\n"}
{"name":"Finset.nonempty_coe_sort","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Nonempty (Subtype fun x => Membership.mem s x)) s.Nonempty","decl":"theorem nonempty_coe_sort {s : Finset α} : Nonempty (s : Type _) ↔ s.Nonempty :=\n  nonempty_subtype\n\n"}
{"name":"Finset.Nonempty.to_set","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\na✝ : s.Nonempty\n⊢ (↑s).Nonempty","decl":"alias ⟨_, Nonempty.to_set⟩ := coe_nonempty\n\n"}
{"name":"Finset.Nonempty.coe_sort","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\na✝ : s.Nonempty\n⊢ Nonempty (Subtype fun x => Membership.mem s x)","decl":"alias ⟨_, Nonempty.coe_sort⟩ := nonempty_coe_sort\n\n"}
{"name":"Finset.Nonempty.exists_mem","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\nh : s.Nonempty\n⊢ Exists fun x => Membership.mem s x","decl":"theorem Nonempty.exists_mem {s : Finset α} (h : s.Nonempty) : ∃ x : α, x ∈ s :=\n  h\n\n"}
{"name":"Finset.Nonempty.mono","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns t : Finset α\nhst : HasSubset.Subset s t\nhs : s.Nonempty\n⊢ t.Nonempty","decl":"theorem Nonempty.mono {s t : Finset α} (hst : s ⊆ t) (hs : s.Nonempty) : t.Nonempty :=\n  Set.Nonempty.mono hst hs\n\n"}
{"name":"Finset.Nonempty.forall_const","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\nh : s.Nonempty\np : Prop\n⊢ Iff (∀ (x : α), Membership.mem s x → p) p","decl":"theorem Nonempty.forall_const {s : Finset α} (h : s.Nonempty) {p : Prop} : (∀ x ∈ s, p) ↔ p :=\n  let ⟨x, hx⟩ := h\n  ⟨fun h => h x hx, fun h _ _ => h⟩\n\n"}
{"name":"Finset.Nonempty.to_subtype","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\na✝ : s.Nonempty\n⊢ Nonempty (Subtype fun x => Membership.mem s x)","decl":"theorem Nonempty.to_subtype {s : Finset α} : s.Nonempty → Nonempty s :=\n  nonempty_coe_sort.2\n\n"}
{"name":"Finset.Nonempty.to_type","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\na✝ : s.Nonempty\n⊢ Nonempty α","decl":"theorem Nonempty.to_type {s : Finset α} : s.Nonempty → Nonempty α := fun ⟨x, _hx⟩ => ⟨x⟩\n\n"}
{"name":"Finset.empty_val","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\n⊢ Eq EmptyCollection.emptyCollection.val 0","decl":"@[simp]\ntheorem empty_val : (∅ : Finset α).1 = 0 :=\n  rfl\n\n"}
{"name":"Finset.not_mem_empty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\na : α\n⊢ Not (Membership.mem EmptyCollection.emptyCollection a)","decl":"@[simp]\ntheorem not_mem_empty (a : α) : a ∉ (∅ : Finset α) := by\n  -- Porting note: was `id`. `a ∈ List.nil` is no longer definitionally equal to `False`\n  simp only [mem_def, empty_val, not_mem_zero, not_false_iff]\n\n"}
{"name":"Finset.not_nonempty_empty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\n⊢ Not EmptyCollection.emptyCollection.Nonempty","decl":"@[simp]\ntheorem not_nonempty_empty : ¬(∅ : Finset α).Nonempty := fun ⟨x, hx⟩ => not_mem_empty x hx\n\n"}
{"name":"Finset.mk_zero","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\n⊢ Eq { val := 0, nodup := ⋯ } EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem mk_zero : (⟨0, nodup_zero⟩ : Finset α) = ∅ :=\n  rfl\n\n"}
{"name":"Finset.ne_empty_of_mem","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\na : α\ns : Finset α\nh : Membership.mem s a\n⊢ Ne s EmptyCollection.emptyCollection","decl":"theorem ne_empty_of_mem {a : α} {s : Finset α} (h : a ∈ s) : s ≠ ∅ := fun e =>\n  not_mem_empty a <| e ▸ h\n\n"}
{"name":"Finset.Nonempty.ne_empty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\nh : s.Nonempty\n⊢ Ne s EmptyCollection.emptyCollection","decl":"theorem Nonempty.ne_empty {s : Finset α} (h : s.Nonempty) : s ≠ ∅ :=\n  (Exists.elim h) fun _a => ne_empty_of_mem\n\n"}
{"name":"Finset.empty_subset","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\n⊢ HasSubset.Subset EmptyCollection.emptyCollection s","decl":"@[simp]\ntheorem empty_subset (s : Finset α) : ∅ ⊆ s :=\n  zero_subset _\n\n"}
{"name":"Finset.eq_empty_of_forall_not_mem","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\nH : ∀ (x : α), Not (Membership.mem s x)\n⊢ Eq s EmptyCollection.emptyCollection","decl":"theorem eq_empty_of_forall_not_mem {s : Finset α} (H : ∀ x, x ∉ s) : s = ∅ :=\n  eq_of_veq (eq_zero_of_forall_not_mem H)\n\n"}
{"name":"Finset.eq_empty_iff_forall_not_mem","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Eq s EmptyCollection.emptyCollection) (∀ (x : α), Not (Membership.mem s x))","decl":"theorem eq_empty_iff_forall_not_mem {s : Finset α} : s = ∅ ↔ ∀ x, x ∉ s :=\n  -- Porting note: used `id`\n  ⟨by rintro rfl x; apply not_mem_empty, fun h => eq_empty_of_forall_not_mem h⟩\n\n"}
{"name":"Finset.val_eq_zero","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Eq s.val 0) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem val_eq_zero {s : Finset α} : s.1 = 0 ↔ s = ∅ :=\n  @val_inj _ s ∅\n\n"}
{"name":"Finset.subset_empty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (HasSubset.Subset s EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp] lemma subset_empty : s ⊆ ∅ ↔ s = ∅ := subset_zero.trans val_eq_zero\n\n"}
{"name":"Finset.not_ssubset_empty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Not (HasSSubset.SSubset s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem not_ssubset_empty (s : Finset α) : ¬s ⊂ ∅ := fun h =>\n  let ⟨_, he, _⟩ := exists_of_ssubset h\n  -- Porting note: was `he`\n  not_mem_empty _ he\n\n"}
{"name":"Finset.nonempty_of_ne_empty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\nh : Ne s EmptyCollection.emptyCollection\n⊢ s.Nonempty","decl":"theorem nonempty_of_ne_empty {s : Finset α} (h : s ≠ ∅) : s.Nonempty :=\n  exists_mem_of_ne_zero (mt val_eq_zero.1 h)\n\n"}
{"name":"Finset.nonempty_iff_ne_empty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff s.Nonempty (Ne s EmptyCollection.emptyCollection)","decl":"theorem nonempty_iff_ne_empty {s : Finset α} : s.Nonempty ↔ s ≠ ∅ :=\n  ⟨Nonempty.ne_empty, nonempty_of_ne_empty⟩\n\n"}
{"name":"Finset.not_nonempty_iff_eq_empty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Not s.Nonempty) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem not_nonempty_iff_eq_empty {s : Finset α} : ¬s.Nonempty ↔ s = ∅ :=\n  nonempty_iff_ne_empty.not.trans not_not\n\n"}
{"name":"Finset.eq_empty_or_nonempty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Or (Eq s EmptyCollection.emptyCollection) s.Nonempty","decl":"theorem eq_empty_or_nonempty (s : Finset α) : s = ∅ ∨ s.Nonempty :=\n  by_cases Or.inl fun h => Or.inr (nonempty_of_ne_empty h)\n\n"}
{"name":"Finset.coe_empty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\n⊢ Eq (↑EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp, norm_cast]\ntheorem coe_empty : ((∅ : Finset α) : Set α) = ∅ :=\n  Set.ext <| by simp\n\n"}
{"name":"Finset.coe_eq_empty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Eq (↑s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp, norm_cast]\ntheorem coe_eq_empty {s : Finset α} : (s : Set α) = ∅ ↔ s = ∅ := by rw [← coe_empty, coe_inj]\n\n-- Porting note: Left-hand side simplifies @[simp]\n"}
{"name":"Finset.isEmpty_coe_sort","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (IsEmpty (Subtype fun x => Membership.mem s x)) (Eq s EmptyCollection.emptyCollection)","decl":"theorem isEmpty_coe_sort {s : Finset α} : IsEmpty (s : Type _) ↔ s = ∅ := by\n  simpa using @Set.isEmpty_coe_sort α s\n\n"}
{"name":"Finset.instIsEmpty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\n⊢ IsEmpty (Subtype fun x => Membership.mem EmptyCollection.emptyCollection x)","decl":"instance instIsEmpty : IsEmpty (∅ : Finset α) :=\n  isEmpty_coe_sort.2 rfl\n\n"}
{"name":"Finset.eq_empty_of_isEmpty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ninst✝ : IsEmpty α\ns : Finset α\n⊢ Eq s EmptyCollection.emptyCollection","decl":"/-- A `Finset` for an empty type is empty. -/\ntheorem eq_empty_of_isEmpty [IsEmpty α] (s : Finset α) : s = ∅ :=\n  Finset.eq_empty_of_forall_not_mem isEmptyElim\n\n"}
{"name":"Finset.bot_eq_empty","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\n⊢ Eq Bot.bot EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem bot_eq_empty : (⊥ : Finset α) = ∅ :=\n  rfl\n\n"}
{"name":"Finset.empty_ssubset","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (HasSSubset.SSubset EmptyCollection.emptyCollection s) s.Nonempty","decl":"@[simp]\ntheorem empty_ssubset : ∅ ⊂ s ↔ s.Nonempty :=\n  (@bot_lt_iff_ne_bot (Finset α) _ _ _).trans nonempty_iff_ne_empty.symm\n\n"}
{"name":"Finset.Nonempty.empty_ssubset","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\ns : Finset α\na✝ : s.Nonempty\n⊢ HasSSubset.SSubset EmptyCollection.emptyCollection s","decl":"alias ⟨_, Nonempty.empty_ssubset⟩ := empty_ssubset\n\n-- useful rules for calculations with quantifiers\n"}
{"name":"Finset.exists_mem_empty_iff","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\np : α → Prop\n⊢ Iff (Exists fun x => And (Membership.mem EmptyCollection.emptyCollection x) (p x)) False","decl":"theorem exists_mem_empty_iff (p : α → Prop) : (∃ x, x ∈ (∅ : Finset α) ∧ p x) ↔ False := by\n  simp only [not_mem_empty, false_and, exists_false]\n\n"}
{"name":"Finset.forall_mem_empty_iff","module":"Mathlib.Data.Finset.Empty","initialProofState":"α : Type u_1\np : α → Prop\n⊢ Iff (∀ (x : α), Membership.mem EmptyCollection.emptyCollection x → p x) True","decl":"theorem forall_mem_empty_iff (p : α → Prop) : (∀ x, x ∈ (∅ : Finset α) → p x) ↔ True :=\n  iff_true_intro fun _ h => False.elim <| not_mem_empty _ h\n\n"}
