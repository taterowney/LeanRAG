{"name":"Finpartition.supIndep","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nself : Finpartition a\n⊢ self.parts.SupIndep id","decl":"/-- A finite partition of `a : α` is a pairwise disjoint finite set of elements whose supremum is\n`a`. We forbid `⊥` as a part. -/\n@[ext]\nstructure Finpartition [Lattice α] [OrderBot α] (a : α) where\n  -- Porting note: Docstrings added\n  /-- The elements of the finite partition of `a` -/\n  parts : Finset α\n  /-- The partition is supremum-independent -/\n  protected supIndep : parts.SupIndep id\n  /-- The supremum of the partition is `a` -/\n  sup_parts : parts.sup id = a\n  /-- No element of the partition is bottom -/\n  not_bot_mem : ⊥ ∉ parts\n  deriving DecidableEq\n\n"}
{"name":"Finpartition.mk.sizeOf_spec","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : OrderBot α\na : α\ninst✝ : SizeOf α\nparts : Finset α\nsupIndep : parts.SupIndep id\nsup_parts : Eq (parts.sup id) a\nnot_bot_mem : Not (Membership.mem parts Bot.bot)\n⊢ Eq (SizeOf.sizeOf { parts := parts, supIndep := supIndep, sup_parts := sup_parts, not_bot_mem := not_bot_mem }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf parts)) (SizeOf.sizeOf sup_parts))","decl":"/-- A finite partition of `a : α` is a pairwise disjoint finite set of elements whose supremum is\n`a`. We forbid `⊥` as a part. -/\n@[ext]\nstructure Finpartition [Lattice α] [OrderBot α] (a : α) where\n  -- Porting note: Docstrings added\n  /-- The elements of the finite partition of `a` -/\n  parts : Finset α\n  /-- The partition is supremum-independent -/\n  protected supIndep : parts.SupIndep id\n  /-- The supremum of the partition is `a` -/\n  sup_parts : parts.sup id = a\n  /-- No element of the partition is bottom -/\n  not_bot_mem : ⊥ ∉ parts\n  deriving DecidableEq\n\n"}
{"name":"Finpartition.not_bot_mem","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nself : Finpartition a\n⊢ Not (Membership.mem self.parts Bot.bot)","decl":"/-- A finite partition of `a : α` is a pairwise disjoint finite set of elements whose supremum is\n`a`. We forbid `⊥` as a part. -/\n@[ext]\nstructure Finpartition [Lattice α] [OrderBot α] (a : α) where\n  -- Porting note: Docstrings added\n  /-- The elements of the finite partition of `a` -/\n  parts : Finset α\n  /-- The partition is supremum-independent -/\n  protected supIndep : parts.SupIndep id\n  /-- The supremum of the partition is `a` -/\n  sup_parts : parts.sup id = a\n  /-- No element of the partition is bottom -/\n  not_bot_mem : ⊥ ∉ parts\n  deriving DecidableEq\n\n"}
{"name":"Finpartition.mk.inj","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nparts✝ : Finset α\nsupIndep✝ : parts✝.SupIndep id\nsup_parts✝ : Eq (parts✝.sup id) a\nnot_bot_mem✝ : Not (Membership.mem parts✝ Bot.bot)\nparts : Finset α\nsupIndep : parts.SupIndep id\nsup_parts : Eq (parts.sup id) a\nnot_bot_mem : Not (Membership.mem parts Bot.bot)\nx✝ : Eq { parts := parts✝, supIndep := supIndep✝, sup_parts := sup_parts✝, not_bot_mem := not_bot_mem✝ } { parts := parts, supIndep := supIndep, sup_parts := sup_parts, not_bot_mem := not_bot_mem }\n⊢ Eq parts✝ parts","decl":"/-- A finite partition of `a : α` is a pairwise disjoint finite set of elements whose supremum is\n`a`. We forbid `⊥` as a part. -/\n@[ext]\nstructure Finpartition [Lattice α] [OrderBot α] (a : α) where\n  -- Porting note: Docstrings added\n  /-- The elements of the finite partition of `a` -/\n  parts : Finset α\n  /-- The partition is supremum-independent -/\n  protected supIndep : parts.SupIndep id\n  /-- The supremum of the partition is `a` -/\n  sup_parts : parts.sup id = a\n  /-- No element of the partition is bottom -/\n  not_bot_mem : ⊥ ∉ parts\n  deriving DecidableEq\n\n"}
{"name":"Finpartition.ext_iff","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nx y : Finpartition a\n⊢ Iff (Eq x y) (Eq x.parts y.parts)","decl":"/-- A finite partition of `a : α` is a pairwise disjoint finite set of elements whose supremum is\n`a`. We forbid `⊥` as a part. -/\n@[ext]\nstructure Finpartition [Lattice α] [OrderBot α] (a : α) where\n  -- Porting note: Docstrings added\n  /-- The elements of the finite partition of `a` -/\n  parts : Finset α\n  /-- The partition is supremum-independent -/\n  protected supIndep : parts.SupIndep id\n  /-- The supremum of the partition is `a` -/\n  sup_parts : parts.sup id = a\n  /-- No element of the partition is bottom -/\n  not_bot_mem : ⊥ ∉ parts\n  deriving DecidableEq\n\n"}
{"name":"Finpartition.mk.injEq","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nparts✝ : Finset α\nsupIndep✝ : parts✝.SupIndep id\nsup_parts✝ : Eq (parts✝.sup id) a\nnot_bot_mem✝ : Not (Membership.mem parts✝ Bot.bot)\nparts : Finset α\nsupIndep : parts.SupIndep id\nsup_parts : Eq (parts.sup id) a\nnot_bot_mem : Not (Membership.mem parts Bot.bot)\n⊢ Eq (Eq { parts := parts✝, supIndep := supIndep✝, sup_parts := sup_parts✝, not_bot_mem := not_bot_mem✝ } { parts := parts, supIndep := supIndep, sup_parts := sup_parts, not_bot_mem := not_bot_mem }) (Eq parts✝ parts)","decl":"/-- A finite partition of `a : α` is a pairwise disjoint finite set of elements whose supremum is\n`a`. We forbid `⊥` as a part. -/\n@[ext]\nstructure Finpartition [Lattice α] [OrderBot α] (a : α) where\n  -- Porting note: Docstrings added\n  /-- The elements of the finite partition of `a` -/\n  parts : Finset α\n  /-- The partition is supremum-independent -/\n  protected supIndep : parts.SupIndep id\n  /-- The supremum of the partition is `a` -/\n  sup_parts : parts.sup id = a\n  /-- No element of the partition is bottom -/\n  not_bot_mem : ⊥ ∉ parts\n  deriving DecidableEq\n\n"}
{"name":"Finpartition.sup_parts","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nself : Finpartition a\n⊢ Eq (self.parts.sup id) a","decl":"/-- A finite partition of `a : α` is a pairwise disjoint finite set of elements whose supremum is\n`a`. We forbid `⊥` as a part. -/\n@[ext]\nstructure Finpartition [Lattice α] [OrderBot α] (a : α) where\n  -- Porting note: Docstrings added\n  /-- The elements of the finite partition of `a` -/\n  parts : Finset α\n  /-- The partition is supremum-independent -/\n  protected supIndep : parts.SupIndep id\n  /-- The supremum of the partition is `a` -/\n  sup_parts : parts.sup id = a\n  /-- No element of the partition is bottom -/\n  not_bot_mem : ⊥ ∉ parts\n  deriving DecidableEq\n\n"}
{"name":"Finpartition.ext","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nx y : Finpartition a\nparts : Eq x.parts y.parts\n⊢ Eq x y","decl":"/-- A finite partition of `a : α` is a pairwise disjoint finite set of elements whose supremum is\n`a`. We forbid `⊥` as a part. -/\n@[ext]\nstructure Finpartition [Lattice α] [OrderBot α] (a : α) where\n  -- Porting note: Docstrings added\n  /-- The elements of the finite partition of `a` -/\n  parts : Finset α\n  /-- The partition is supremum-independent -/\n  protected supIndep : parts.SupIndep id\n  /-- The supremum of the partition is `a` -/\n  sup_parts : parts.sup id = a\n  /-- No element of the partition is bottom -/\n  not_bot_mem : ⊥ ∉ parts\n  deriving DecidableEq\n\n"}
{"name":"Finpartition.ofErase_parts","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\na : α\nparts : Finset α\nsup_indep : parts.SupIndep id\nsup_parts : Eq (parts.sup id) a\n⊢ Eq (Finpartition.ofErase parts sup_indep sup_parts).parts (parts.erase Bot.bot)","decl":"/-- A `Finpartition` constructor which does not insist on `⊥` not being a part. -/\n@[simps]\ndef ofErase [DecidableEq α] {a : α} (parts : Finset α) (sup_indep : parts.SupIndep id)\n    (sup_parts : parts.sup id = a) : Finpartition a where\n  parts := parts.erase ⊥\n  supIndep := sup_indep.subset (erase_subset _ _)\n  sup_parts := (sup_erase_bot _).trans sup_parts\n  not_bot_mem := not_mem_erase _ _\n\n"}
{"name":"Finpartition.ofSubset_parts","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na b : α\nP : Finpartition a\nparts : Finset α\nsubset : HasSubset.Subset parts P.parts\nsup_parts : Eq (parts.sup id) b\n⊢ Eq (P.ofSubset subset sup_parts).parts parts","decl":"/-- A `Finpartition` constructor from a bigger existing finpartition. -/\n@[simps]\ndef ofSubset {a b : α} (P : Finpartition a) {parts : Finset α} (subset : parts ⊆ P.parts)\n    (sup_parts : parts.sup id = b) : Finpartition b :=\n  { parts := parts\n    supIndep := P.supIndep.subset subset\n    sup_parts := sup_parts\n    not_bot_mem := fun h ↦ P.not_bot_mem (subset h) }\n\n"}
{"name":"Finpartition.copy_parts","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na b : α\nP : Finpartition a\nh : Eq a b\n⊢ Eq (P.copy h).parts P.parts","decl":"/-- Changes the type of a finpartition to an equal one. -/\n@[simps]\ndef copy {a b : α} (P : Finpartition a) (h : a = b) : Finpartition b where\n  parts := P.parts\n  supIndep := P.supIndep\n  sup_parts := h ▸ P.sup_parts\n  not_bot_mem := P.not_bot_mem\n\n"}
{"name":"Finpartition.parts_map","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝³ : Lattice α\ninst✝² : OrderBot α\nβ : Type u_2\ninst✝¹ : Lattice β\ninst✝ : OrderBot β\na : α\ne : OrderIso α β\nP : Finpartition a\n⊢ Eq (Finpartition.map e P).parts (Finset.map (↑e).toEmbedding P.parts)","decl":"@[simp]\ntheorem parts_map {β : Type*} [Lattice β] [OrderBot β] {a : α} {e : α ≃o β} {P : Finpartition a} :\n    (P.map e).parts = P.parts.map e := rfl\n\n"}
{"name":"Finpartition.empty_parts","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\n⊢ Eq (Finpartition.empty α).parts EmptyCollection.emptyCollection","decl":"/-- The empty finpartition. -/\n@[simps]\nprotected def empty : Finpartition (⊥ : α) where\n  parts := ∅\n  supIndep := supIndep_empty _\n  sup_parts := Finset.sup_empty\n  not_bot_mem := not_mem_empty ⊥\n\n"}
{"name":"Finpartition.default_eq_empty","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\n⊢ Eq Inhabited.default (Finpartition.empty α)","decl":"@[simp]\ntheorem default_eq_empty : (default : Finpartition (⊥ : α)) = Finpartition.empty α :=\n  rfl\n\n"}
{"name":"Finpartition.indiscrete_parts","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nha : Ne a Bot.bot\n⊢ Eq (Finpartition.indiscrete ha).parts (Singleton.singleton a)","decl":"/-- The finpartition in one part, aka indiscrete finpartition. -/\n@[simps]\ndef indiscrete (ha : a ≠ ⊥) : Finpartition a where\n  parts := {a}\n  supIndep := supIndep_singleton _ _\n  sup_parts := Finset.sup_singleton\n  not_bot_mem h := ha (mem_singleton.1 h).symm\n\n"}
{"name":"Finpartition.le","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nP : Finpartition a\nb : α\nhb : Membership.mem P.parts b\n⊢ LE.le b a","decl":"protected theorem le {b : α} (hb : b ∈ P.parts) : b ≤ a :=\n  (le_sup hb).trans P.sup_parts.le\n\n"}
{"name":"Finpartition.ne_bot","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nP : Finpartition a\nb : α\nhb : Membership.mem P.parts b\n⊢ Ne b Bot.bot","decl":"theorem ne_bot {b : α} (hb : b ∈ P.parts) : b ≠ ⊥ := by\n  intro h\n  refine P.not_bot_mem (?_)\n  rw [h] at hb\n  exact hb\n\n"}
{"name":"Finpartition.disjoint","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nP : Finpartition a\n⊢ (↑P.parts).PairwiseDisjoint id","decl":"protected theorem disjoint : (P.parts : Set α).PairwiseDisjoint id :=\n  P.supIndep.pairwiseDisjoint\n\n"}
{"name":"Finpartition.parts_eq_empty_iff","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nP : Finpartition a\n⊢ Iff (Eq P.parts EmptyCollection.emptyCollection) (Eq a Bot.bot)","decl":"theorem parts_eq_empty_iff : P.parts = ∅ ↔ a = ⊥ := by\n  simp_rw [← P.sup_parts]\n  refine ⟨fun h ↦ ?_, fun h ↦ eq_empty_iff_forall_not_mem.2 fun b hb ↦ P.not_bot_mem ?_⟩\n  · rw [h]\n    exact Finset.sup_empty\n  · rwa [← le_bot_iff.1 ((le_sup hb).trans h.le)]\n\n"}
{"name":"Finpartition.parts_nonempty_iff","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nP : Finpartition a\n⊢ Iff P.parts.Nonempty (Ne a Bot.bot)","decl":"theorem parts_nonempty_iff : P.parts.Nonempty ↔ a ≠ ⊥ := by\n  rw [nonempty_iff_ne_empty, not_iff_not, parts_eq_empty_iff]\n\n"}
{"name":"Finpartition.parts_nonempty","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\na : α\nP : Finpartition a\nha : Ne a Bot.bot\n⊢ P.parts.Nonempty","decl":"theorem parts_nonempty (P : Finpartition a) (ha : a ≠ ⊥) : P.parts.Nonempty :=\n  parts_nonempty_iff.2 ha\n\n"}
{"name":"Finpartition.parts_top_subset","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : OrderBot α\na : α\ninst✝ : Decidable (Eq a Bot.bot)\n⊢ HasSubset.Subset Top.top.parts (Singleton.singleton a)","decl":"theorem parts_top_subset (a : α) [Decidable (a = ⊥)] : (⊤ : Finpartition a).parts ⊆ {a} := by\n  intro b hb\n  have hb : b ∈ Finpartition.parts (dite _ _ _) := hb\n  split_ifs at hb\n  · simp only [copy_parts, empty_parts, not_mem_empty] at hb\n  · exact hb\n\n"}
{"name":"Finpartition.parts_top_subsingleton","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : OrderBot α\na : α\ninst✝ : Decidable (Eq a Bot.bot)\n⊢ (↑Top.top.parts).Subsingleton","decl":"theorem parts_top_subsingleton (a : α) [Decidable (a = ⊥)] :\n    ((⊤ : Finpartition a).parts : Set α).Subsingleton :=\n  Set.subsingleton_of_subset_singleton fun _ hb ↦ mem_singleton.1 <| parts_top_subset _ hb\n\n-- TODO: this instance takes double-exponential time to generate all partitions, find a faster way\n"}
{"name":"Finpartition.parts_inf","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝² : DistribLattice α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\na : α\nP Q : Finpartition a\n⊢ Eq (Min.min P Q).parts ((Finset.image (fun bc => Min.min bc.1 bc.2) (SProd.sprod P.parts Q.parts)).erase Bot.bot)","decl":"@[simp]\ntheorem parts_inf (P Q : Finpartition a) :\n    (P ⊓ Q).parts = ((P.parts ×ˢ Q.parts).image fun bc : α × α ↦ bc.1 ⊓ bc.2).erase ⊥ :=\n  rfl\n\n"}
{"name":"Finpartition.exists_le_of_le","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\na b : α\nP Q : Finpartition a\nh : LE.le P Q\nhb : Membership.mem Q.parts b\n⊢ Exists fun c => And (Membership.mem P.parts c) (LE.le c b)","decl":"theorem exists_le_of_le {a b : α} {P Q : Finpartition a} (h : P ≤ Q) (hb : b ∈ Q.parts) :\n    ∃ c ∈ P.parts, c ≤ b := by\n  by_contra H\n  refine Q.ne_bot hb (disjoint_self.1 <| Disjoint.mono_right (Q.le hb) ?_)\n  rw [← P.sup_parts, Finset.disjoint_sup_right]\n  rintro c hc\n  obtain ⟨d, hd, hcd⟩ := h hc\n  refine (Q.disjoint hb hd ?_).mono_right hcd\n  rintro rfl\n  simp only [not_exists, not_and] at H\n  exact H _ hc hcd\n\n"}
{"name":"Finpartition.card_mono","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\na : α\nP Q : Finpartition a\nh : LE.le P Q\n⊢ LE.le Q.parts.card P.parts.card","decl":"theorem card_mono {a : α} {P Q : Finpartition a} (h : P ≤ Q) : #Q.parts ≤ #P.parts := by\n  classical\n    have : ∀ b ∈ Q.parts, ∃ c ∈ P.parts, c ≤ b := fun b ↦ exists_le_of_le h\n    choose f hP hf using this\n    rw [← card_attach]\n    refine card_le_card_of_injOn (fun b ↦ f _ b.2) (fun b _ ↦ hP _ b.2) fun b _ c _ h ↦ ?_\n    exact\n      Subtype.coe_injective\n        (Q.disjoint.elim b.2 c.2 fun H ↦\n          P.ne_bot (hP _ b.2) <| disjoint_self.1 <| H.mono (hf _ b.2) <| h.le.trans <| hf _ c.2)\n\n"}
{"name":"Finpartition.bind_parts","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝² : DistribLattice α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\na : α\nP : Finpartition a\nQ : (i : α) → Membership.mem P.parts i → Finpartition i\n⊢ Eq (P.bind Q).parts (P.parts.attach.biUnion fun i => (Q ↑i ⋯).parts)","decl":"/-- Given a finpartition `P` of `a` and finpartitions of each part of `P`, this yields the\nfinpartition of `a` obtained by juxtaposing all the subpartitions. -/\n@[simps]\ndef bind (P : Finpartition a) (Q : ∀ i ∈ P.parts, Finpartition i) : Finpartition a where\n  parts := P.parts.attach.biUnion fun i ↦ (Q i.1 i.2).parts\n  supIndep := by\n    rw [supIndep_iff_pairwiseDisjoint]\n    rintro a ha b hb h\n    rw [Finset.mem_coe, Finset.mem_biUnion] at ha hb\n    obtain ⟨⟨A, hA⟩, -, ha⟩ := ha\n    obtain ⟨⟨B, hB⟩, -, hb⟩ := hb\n    obtain rfl | hAB := eq_or_ne A B\n    · exact (Q A hA).disjoint ha hb h\n    · exact (P.disjoint hA hB hAB).mono ((Q A hA).le ha) ((Q B hB).le hb)\n  sup_parts := by\n    simp_rw [sup_biUnion]\n    trans (sup P.parts id)\n    · rw [eq_comm, ← Finset.sup_attach]\n      exact sup_congr rfl fun b _hb ↦ (Q b.1 b.2).sup_parts.symm\n    · exact P.sup_parts\n  not_bot_mem h := by\n    rw [Finset.mem_biUnion] at h\n    obtain ⟨⟨A, hA⟩, -, h⟩ := h\n    exact (Q A hA).not_bot_mem h\n\n"}
{"name":"Finpartition.mem_bind","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝² : DistribLattice α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\na b : α\nP : Finpartition a\nQ : (i : α) → Membership.mem P.parts i → Finpartition i\n⊢ Iff (Membership.mem (P.bind Q).parts b) (Exists fun A => Exists fun hA => Membership.mem (Q A hA).parts b)","decl":"theorem mem_bind : b ∈ (P.bind Q).parts ↔ ∃ A hA, b ∈ (Q A hA).parts := by\n  rw [bind, mem_biUnion]\n  constructor\n  · rintro ⟨⟨A, hA⟩, -, h⟩\n    exact ⟨A, hA, h⟩\n  · rintro ⟨A, hA, h⟩\n    exact ⟨⟨A, hA⟩, mem_attach _ ⟨A, hA⟩, h⟩\n\n"}
{"name":"Finpartition.card_bind","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝² : DistribLattice α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\na : α\nP : Finpartition a\nQ : (i : α) → Membership.mem P.parts i → Finpartition i\n⊢ Eq (P.bind Q).parts.card (P.parts.attach.sum fun A => (Q ↑A ⋯).parts.card)","decl":"theorem card_bind (Q : ∀ i ∈ P.parts, Finpartition i) :\n    #(P.bind Q).parts = ∑ A ∈ P.parts.attach, #(Q _ A.2).parts := by\n  apply card_biUnion\n  rintro ⟨b, hb⟩ - ⟨c, hc⟩ - hbc\n  rw [Finset.disjoint_left]\n  rintro d hdb hdc\n  rw [Ne, Subtype.mk_eq_mk] at hbc\n  exact\n    (Q b hb).ne_bot hdb\n      (eq_bot_iff.2 <|\n        (le_inf ((Q b hb).le hdb) <| (Q c hc).le hdc).trans <| (P.disjoint hb hc hbc).le_bot)\n\n"}
{"name":"Finpartition.extend_parts","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝² : DistribLattice α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\na b c : α\nP : Finpartition a\nhb : Ne b Bot.bot\nhab : Disjoint a b\nhc : Eq (Max.max a b) c\n⊢ Eq (P.extend hb hab hc).parts (Insert.insert b P.parts)","decl":"/-- Adds `b` to a finpartition of `a` to make a finpartition of `a ⊔ b`. -/\n@[simps]\ndef extend (P : Finpartition a) (hb : b ≠ ⊥) (hab : Disjoint a b) (hc : a ⊔ b = c) :\n    Finpartition c where\n  parts := insert b P.parts\n  supIndep := by\n    rw [supIndep_iff_pairwiseDisjoint, coe_insert]\n    exact P.disjoint.insert fun d hd _ ↦ hab.symm.mono_right <| P.le hd\n  sup_parts := by rwa [sup_insert, P.sup_parts, id, _root_.sup_comm]\n  not_bot_mem h := (mem_insert.1 h).elim hb.symm P.not_bot_mem\n\n"}
{"name":"Finpartition.card_extend","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝² : DistribLattice α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\na : α\nP : Finpartition a\nb c : α\nhb : Ne b Bot.bot\nhab : Disjoint a b\nhc : Eq (Max.max a b) c\n⊢ Eq (P.extend hb hab hc).parts.card (HAdd.hAdd P.parts.card 1)","decl":"theorem card_extend (P : Finpartition a) (b c : α) {hb : b ≠ ⊥} {hab : Disjoint a b}\n    {hc : a ⊔ b = c} : #(P.extend hb hab hc).parts = #P.parts + 1 :=\n  card_insert_of_not_mem fun h ↦ hb <| hab.symm.eq_bot_of_le <| P.le h\n\n"}
{"name":"Finpartition.avoid_parts_val","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : GeneralizedBooleanAlgebra α\ninst✝ : DecidableEq α\na : α\nP : Finpartition a\nb : α\n⊢ Eq (P.avoid b).parts.val ((Multiset.map (fun x => SDiff.sdiff x b) P.parts.val).dedup.erase Bot.bot)","decl":"/-- Restricts a finpartition to avoid a given element. -/\n@[simps!]\ndef avoid (b : α) : Finpartition (a \\ b) :=\n  ofErase\n    (P.parts.image (· \\ b))\n    (P.disjoint.image_finset_of_le fun _ ↦ sdiff_le).supIndep\n    (by rw [sup_image, id_comp, Finset.sup_sdiff_right, ← Function.id_def, P.sup_parts])\n\n"}
{"name":"Finpartition.mem_avoid","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝¹ : GeneralizedBooleanAlgebra α\ninst✝ : DecidableEq α\na b c : α\nP : Finpartition a\n⊢ Iff (Membership.mem (P.avoid b).parts c) (Exists fun d => And (Membership.mem P.parts d) (And (Not (LE.le d b)) (Eq (SDiff.sdiff d b) c)))","decl":"@[simp]\ntheorem mem_avoid : c ∈ (P.avoid b).parts ↔ ∃ d ∈ P.parts, ¬d ≤ b ∧ d \\ b = c := by\n  simp only [avoid, ofErase, mem_erase, Ne, mem_image, exists_prop, ← exists_and_left,\n    @and_left_comm (c ≠ ⊥)]\n  refine exists_congr fun d ↦ and_congr_right' <| and_congr_left ?_\n  rintro rfl\n  rw [sdiff_eq_bot_iff]\n\n"}
{"name":"Finpartition.nonempty_of_mem_parts","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\na : Finset α\nha : Membership.mem P.parts a\n⊢ a.Nonempty","decl":"theorem nonempty_of_mem_parts {a : Finset α} (ha : a ∈ P.parts) : a.Nonempty :=\n  nonempty_iff_ne_empty.2 <| P.ne_bot ha\n\n"}
{"name":"Finpartition.eq_of_mem_parts","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Finset α\nP : Finpartition s\na : α\nht : Membership.mem P.parts t\nhu : Membership.mem P.parts u\nhat : Membership.mem t a\nhau : Membership.mem u a\n⊢ Eq t u","decl":"lemma eq_of_mem_parts (ht : t ∈ P.parts) (hu : u ∈ P.parts) (hat : a ∈ t) (hau : a ∈ u) : t = u :=\n  P.disjoint.elim ht hu <| not_disjoint_iff.2 ⟨a, hat, hau⟩\n\n"}
{"name":"Finpartition.exists_mem","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\na : α\nha : Membership.mem s a\n⊢ Exists fun t => And (Membership.mem P.parts t) (Membership.mem t a)","decl":"theorem exists_mem (ha : a ∈ s) : ∃ t ∈ P.parts, a ∈ t := by\n  simp_rw [← P.sup_parts] at ha\n  exact mem_sup.1 ha\n\n"}
{"name":"Finpartition.biUnion_parts","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\n⊢ Eq (P.parts.biUnion id) s","decl":"theorem biUnion_parts : P.parts.biUnion id = s :=\n  (sup_eq_biUnion _ _).symm.trans P.sup_parts\n\n"}
{"name":"Finpartition.existsUnique_mem","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\na : α\nha : Membership.mem s a\n⊢ ExistsUnique fun t => And (Membership.mem P.parts t) (Membership.mem t a)","decl":"theorem existsUnique_mem (ha : a ∈ s) : ∃! t, t ∈ P.parts ∧ a ∈ t := by\n  obtain ⟨t, ht, ht'⟩ := P.exists_mem ha\n  refine ⟨t, ⟨ht, ht'⟩, ?_⟩\n  rintro u ⟨hu, hu'⟩\n  exact P.eq_of_mem_parts hu ht hu' ht'\n\n"}
{"name":"Finpartition.part_mem","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\na : α\nha : Membership.mem s a\n⊢ Membership.mem P.parts (P.part a)","decl":"lemma part_mem (ha : a ∈ s) : P.part a ∈ P.parts := by simp [part, ha, choose_mem]\n\n"}
{"name":"Finpartition.mem_part","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\na : α\nha : Membership.mem s a\n⊢ Membership.mem (P.part a) a","decl":"lemma mem_part (ha : a ∈ s) : a ∈ P.part a := by\n  simp [part, ha, choose_property (p := fun s => a ∈ s) P.parts (P.existsUnique_mem ha)]\n\n"}
{"name":"Finpartition.part_eq_of_mem","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nP : Finpartition s\na : α\nht : Membership.mem P.parts t\nhat : Membership.mem t a\n⊢ Eq (P.part a) t","decl":"lemma part_eq_of_mem (ht : t ∈ P.parts) (hat : a ∈ t) : P.part a = t := by\n  apply P.eq_of_mem_parts (P.part_mem _) ht (P.mem_part _) hat <;> exact mem_of_subset (P.le ht) hat\n\n"}
{"name":"Finpartition.mem_part_iff_part_eq_part","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Iff (Membership.mem (P.part b) a) (Eq (P.part a) (P.part b))","decl":"lemma mem_part_iff_part_eq_part {b : α} (ha : a ∈ s) (hb : b ∈ s) :\n    a ∈ P.part b ↔ P.part a = P.part b :=\n  ⟨fun c ↦ (P.part_eq_of_mem (P.part_mem hb) c), fun c ↦ c ▸ P.mem_part ha⟩\n\n"}
{"name":"Finpartition.part_surjOn","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\n⊢ Set.SurjOn P.part ↑s ↑P.parts","decl":"theorem part_surjOn : Set.SurjOn P.part s P.parts := fun p hp ↦ by\n  obtain ⟨x, hx⟩ := P.nonempty_of_mem_parts hp\n  have hx' := mem_of_subset (P.le hp) hx\n  use x, hx', (P.existsUnique_mem hx').unique ⟨P.part_mem hx', P.mem_part hx'⟩ ⟨hp, hx⟩\n\n"}
{"name":"Finpartition.exists_subset_part_bijOn","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\n⊢ Exists fun r => And (HasSubset.Subset r s) (Set.BijOn P.part ↑r ↑P.parts)","decl":"theorem exists_subset_part_bijOn : ∃ r ⊆ s, Set.BijOn P.part r P.parts := by\n  obtain ⟨r, hrs, hr⟩ := P.part_surjOn.exists_bijOn_subset\n  lift r to Finset α using s.finite_toSet.subset hrs\n  exact ⟨r, mod_cast hrs, hr⟩\n\n"}
{"name":"Finpartition.exists_enumeration","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\n⊢ Exists fun f => ∀ (a b : Subtype fun x => Membership.mem s x), Iff (Eq (P.part ↑a) (P.part ↑b)) (Eq (f a).fst (f b).fst)","decl":"lemma exists_enumeration : ∃ f : s ≃ Σ t : P.parts, Fin #t.1,\n    ∀ a b : s, P.part a = P.part b ↔ (f a).1 = (f b).1 := by\n  use P.equivSigmaParts.trans ((Equiv.refl _).sigmaCongr (fun t ↦ t.1.equivFin))\n  simp [equivSigmaParts, Equiv.sigmaCongr, Equiv.sigmaCongrLeft]\n\n"}
{"name":"Finpartition.sum_card_parts","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\n⊢ Eq (P.parts.sum fun i => i.card) s.card","decl":"theorem sum_card_parts : ∑ i ∈ P.parts, #i = #s := by\n  convert congr_arg Finset.card P.biUnion_parts\n  rw [card_biUnion P.supIndep.pairwiseDisjoint]\n  rfl\n\n"}
{"name":"Finpartition.parts_bot","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq Bot.bot.parts (Finset.map { toFun := Singleton.singleton, inj' := ⋯ } s)","decl":"@[simp]\ntheorem parts_bot (s : Finset α) :\n    (⊥ : Finpartition s).parts = s.map ⟨singleton, singleton_injective⟩ :=\n  rfl\n\n"}
{"name":"Finpartition.card_bot","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq Bot.bot.parts.card s.card","decl":"theorem card_bot (s : Finset α) : #(⊥ : Finpartition s).parts = #s := Finset.card_map _\n\n"}
{"name":"Finpartition.mem_bot_iff","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Iff (Membership.mem Bot.bot.parts t) (Exists fun a => And (Membership.mem s a) (Eq (Singleton.singleton a) t))","decl":"theorem mem_bot_iff : t ∈ (⊥ : Finpartition s).parts ↔ ∃ a ∈ s, {a} = t :=\n  mem_map\n\n"}
{"name":"Finpartition.card_parts_le_card","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\n⊢ LE.le P.parts.card s.card","decl":"theorem card_parts_le_card : #P.parts ≤ #s := by\n  rw [← card_bot s]\n  exact card_mono bot_le\n\n"}
{"name":"Finpartition.card_mod_card_parts_le","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nP : Finpartition s\n⊢ LE.le (HMod.hMod s.card P.parts.card) P.parts.card","decl":"lemma card_mod_card_parts_le : #s % #P.parts ≤ #P.parts := by\n  obtain h | h := (#P.parts).eq_zero_or_pos\n  · rw [h]\n    rw [Finset.card_eq_zero, parts_eq_empty_iff, bot_eq_empty, ← Finset.card_eq_zero] at h\n    rw [h]\n  · exact (Nat.mod_lt _ h).le\n\n"}
{"name":"Finpartition.mem_part_ofSetoid_iff_rel","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\na : α\ninst✝¹ : Fintype α\ns : Setoid α\ninst✝ : DecidableRel ⇑s\nb : α\n⊢ Iff (Membership.mem ((Finpartition.ofSetoid s).part a) b) (s a b)","decl":"theorem mem_part_ofSetoid_iff_rel {s : Setoid α} [DecidableRel s.r] {b : α} :\n    b ∈ (ofSetoid s).part a ↔ s.r a b := by\n  simp_rw [part, ofSetoid, mem_univ, reduceDIte]\n  generalize_proofs H\n  have := choose_spec _ _ H\n  simp only [mem_univ, mem_image, true_and] at this\n  obtain ⟨⟨_, hc⟩, this⟩ := this\n  simp only [← hc, mem_univ, mem_filter, true_and] at this ⊢\n  exact ⟨s.trans (s.symm this), s.trans this⟩\n\n"}
{"name":"Finpartition.mem_atomise","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nF : Finset (Finset α)\n⊢ Iff (Membership.mem (Finpartition.atomise s F).parts t) (And t.Nonempty (Exists fun Q => And (HasSubset.Subset Q F) (Eq (Finset.filter (fun i => ∀ (u : Finset α), Membership.mem F u → Iff (Membership.mem Q u) (Membership.mem u i)) s) t)))","decl":"theorem mem_atomise :\n    t ∈ (atomise s F).parts ↔\n      t.Nonempty ∧ ∃ Q ⊆ F, {i ∈ s | ∀ u ∈ F, u ∈ Q ↔ i ∈ u} = t := by\n  simp only [atomise, ofErase, bot_eq_empty, mem_erase, mem_image, nonempty_iff_ne_empty,\n    mem_singleton, and_comm, mem_powerset, exists_prop]\n\n"}
{"name":"Finpartition.atomise_empty","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nhs : s.Nonempty\n⊢ Eq (Finpartition.atomise s EmptyCollection.emptyCollection).parts (Singleton.singleton s)","decl":"theorem atomise_empty (hs : s.Nonempty) : (atomise s ∅).parts = {s} := by\n  simp only [atomise, powerset_empty, image_singleton, not_mem_empty, IsEmpty.forall_iff,\n    imp_true_iff, filter_True]\n  exact erase_eq_of_not_mem (not_mem_singleton.2 hs.ne_empty.symm)\n\n"}
{"name":"Finpartition.card_atomise_le","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nF : Finset (Finset α)\n⊢ LE.le (Finpartition.atomise s F).parts.card (HPow.hPow 2 F.card)","decl":"theorem card_atomise_le : #(atomise s F).parts ≤ 2 ^ #F :=\n  (card_le_card <| erase_subset _ _).trans <| Finset.card_image_le.trans (card_powerset _).le\n\n"}
{"name":"Finpartition.biUnion_filter_atomise","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nF : Finset (Finset α)\nht : Membership.mem F t\nhts : HasSubset.Subset t s\n⊢ Eq ((Finset.filter (fun u => And (HasSubset.Subset u t) u.Nonempty) (Finpartition.atomise s F).parts).biUnion id) t","decl":"theorem biUnion_filter_atomise (ht : t ∈ F) (hts : t ⊆ s) :\n    {u ∈ (atomise s F).parts | u ⊆ t ∧ u.Nonempty}.biUnion id = t := by\n  ext a\n  refine mem_biUnion.trans ⟨fun ⟨u, hu, ha⟩ ↦ (mem_filter.1 hu).2.1 ha, fun ha ↦ ?_⟩\n  obtain ⟨u, hu, hau⟩ := (atomise s F).exists_mem (hts ha)\n  refine ⟨u, mem_filter.2 ⟨hu, fun b hb ↦ ?_, _, hau⟩, hau⟩\n  obtain ⟨Q, _hQ, rfl⟩ := (mem_atomise.1 hu).2\n  rw [mem_filter] at hau hb\n  rwa [← hb.2 _ ht, hau.2 _ ht]\n\n"}
{"name":"Finpartition.card_filter_atomise_le_two_pow","module":"Mathlib.Order.Partition.Finpartition","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nF : Finset (Finset α)\nht : Membership.mem F t\n⊢ LE.le (Finset.filter (fun u => And (HasSubset.Subset u t) u.Nonempty) (Finpartition.atomise s F).parts).card (HPow.hPow 2 (HSub.hSub F.card 1))","decl":"theorem card_filter_atomise_le_two_pow (ht : t ∈ F) :\n    #{u ∈ (atomise s F).parts | u ⊆ t ∧ u.Nonempty} ≤ 2 ^ (#F - 1) := by\n  suffices h :\n    {u ∈ (atomise s F).parts | u ⊆ t ∧ u.Nonempty} ⊆\n      (F.erase t).powerset.image fun P ↦ {i ∈ s | ∀ x ∈ F, x ∈ insert t P ↔ i ∈ x} by\n    refine (card_le_card h).trans (card_image_le.trans ?_)\n    rw [card_powerset, card_erase_of_mem ht]\n  rw [subset_iff]\n  simp_rw [mem_image, mem_powerset, mem_filter, and_imp, Finset.Nonempty, exists_imp, mem_atomise,\n    and_imp, Finset.Nonempty, exists_imp, and_imp]\n  rintro P' i hi P PQ rfl hy₂ j _hj\n  refine ⟨P.erase t, erase_subset_erase _ PQ, ?_⟩\n  simp only [insert_erase (((mem_filter.1 hi).2 _ ht).2 <| hy₂ hi)]\n\n"}
