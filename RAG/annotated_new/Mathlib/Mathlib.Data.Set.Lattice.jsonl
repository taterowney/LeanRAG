{"name":"Set.mem_iUnion₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"γ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_8\nx : γ\ns : (i : ι) → κ i → Set γ\n⊢ Iff (Membership.mem (Set.iUnion fun i => Set.iUnion fun j => s i j) x) (Exists fun i => Exists fun j => Membership.mem (s i j) x)","decl":"theorem mem_iUnion₂ {x : γ} {s : ∀ i, κ i → Set γ} : (x ∈ ⋃ (i) (j), s i j) ↔ ∃ i j, x ∈ s i j := by\n  simp_rw [mem_iUnion]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.mem_iInter₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"γ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_8\nx : γ\ns : (i : ι) → κ i → Set γ\n⊢ Iff (Membership.mem (Set.iInter fun i => Set.iInter fun j => s i j) x) (∀ (i : ι) (j : κ i), Membership.mem (s i j) x)","decl":"theorem mem_iInter₂ {x : γ} {s : ∀ i, κ i → Set γ} : (x ∈ ⋂ (i) (j), s i j) ↔ ∀ i j, x ∈ s i j := by\n  simp_rw [mem_iInter]\n\n"}
{"name":"Set.mem_iUnion_of_mem","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set α\na : α\ni : ι\nha : Membership.mem (s i) a\n⊢ Membership.mem (Set.iUnion fun i => s i) a","decl":"theorem mem_iUnion_of_mem {s : ι → Set α} {a : α} (i : ι) (ha : a ∈ s i) : a ∈ ⋃ i, s i :=\n  mem_iUnion.2 ⟨i, ha⟩\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.mem_iUnion₂_of_mem","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\na : α\ni : ι\nj : κ i\nha : Membership.mem (s i j) a\n⊢ Membership.mem (Set.iUnion fun i => Set.iUnion fun j => s i j) a","decl":"theorem mem_iUnion₂_of_mem {s : ∀ i, κ i → Set α} {a : α} {i : ι} (j : κ i) (ha : a ∈ s i j) :\n    a ∈ ⋃ (i) (j), s i j :=\n  mem_iUnion₂.2 ⟨i, j, ha⟩\n\n"}
{"name":"Set.mem_iInter_of_mem","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set α\na : α\nh : ∀ (i : ι), Membership.mem (s i) a\n⊢ Membership.mem (Set.iInter fun i => s i) a","decl":"theorem mem_iInter_of_mem {s : ι → Set α} {a : α} (h : ∀ i, a ∈ s i) : a ∈ ⋂ i, s i :=\n  mem_iInter.2 h\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.mem_iInter₂_of_mem","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\na : α\nh : ∀ (i : ι) (j : κ i), Membership.mem (s i j) a\n⊢ Membership.mem (Set.iInter fun i => Set.iInter fun j => s i j) a","decl":"theorem mem_iInter₂_of_mem {s : ∀ i, κ i → Set α} {a : α} (h : ∀ i j, a ∈ s i j) :\n    a ∈ ⋂ (i) (j), s i j :=\n  mem_iInter₂.2 h\n\n"}
{"name":"Set.image_preimage","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ GaloisConnection (Set.image f) (Set.preimage f)","decl":"protected theorem image_preimage : GaloisConnection (image f) (preimage f) := fun _ _ =>\n  image_subset_iff\n\n"}
{"name":"Set.preimage_kernImage","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ GaloisConnection (Set.preimage f) (Set.kernImage f)","decl":"protected theorem preimage_kernImage : GaloisConnection (preimage f) (kernImage f) := fun _ _ =>\n  subset_kernImage_iff.symm\n\n"}
{"name":"Set.kernImage_mono","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Monotone (Set.kernImage f)","decl":"lemma kernImage_mono : Monotone (kernImage f) :=\n  Set.preimage_kernImage.monotone_u\n\n"}
{"name":"Set.kernImage_eq_compl","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Eq (Set.kernImage f s) (HasCompl.compl (Set.image f (HasCompl.compl s)))","decl":"lemma kernImage_eq_compl {s : Set α} : kernImage f s = (f '' sᶜ)ᶜ :=\n  Set.preimage_kernImage.u_unique (Set.image_preimage.compl)\n    (fun t ↦ compl_compl (f ⁻¹' t) ▸ Set.preimage_compl)\n\n"}
{"name":"Set.kernImage_compl","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Eq (Set.kernImage f (HasCompl.compl s)) (HasCompl.compl (Set.image f s))","decl":"lemma kernImage_compl {s : Set α} : kernImage f (sᶜ) = (f '' s)ᶜ := by\n  rw [kernImage_eq_compl, compl_compl]\n\n"}
{"name":"Set.kernImage_empty","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Set.kernImage f EmptyCollection.emptyCollection) (HasCompl.compl (Set.range f))","decl":"lemma kernImage_empty : kernImage f ∅ = (range f)ᶜ := by\n  rw [kernImage_eq_compl, compl_empty, image_univ]\n\n"}
{"name":"Set.kernImage_preimage_eq_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Iff (Eq (Set.kernImage f (Set.preimage f s)) s) (HasSubset.Subset (HasCompl.compl (Set.range f)) s)","decl":"lemma kernImage_preimage_eq_iff {s : Set β} : kernImage f (f ⁻¹' s) = s ↔ (range f)ᶜ ⊆ s := by\n  rw [kernImage_eq_compl, ← preimage_compl, compl_eq_comm, eq_comm, image_preimage_eq_iff,\n      compl_subset_comm]\n\n"}
{"name":"Set.compl_range_subset_kernImage","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ HasSubset.Subset (HasCompl.compl (Set.range f)) (Set.kernImage f s)","decl":"lemma compl_range_subset_kernImage {s : Set α} : (range f)ᶜ ⊆ kernImage f s := by\n  rw [← kernImage_empty]\n  exact kernImage_mono (empty_subset _)\n\n"}
{"name":"Set.kernImage_union_preimage","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\n⊢ Eq (Set.kernImage f (Union.union s (Set.preimage f t))) (Union.union (Set.kernImage f s) t)","decl":"lemma kernImage_union_preimage {s : Set α} {t : Set β} :\n    kernImage f (s ∪ f ⁻¹' t) = kernImage f s ∪ t := by\n  rw [kernImage_eq_compl, kernImage_eq_compl, compl_union, ← preimage_compl, image_inter_preimage,\n      compl_inter, compl_compl]\n\n"}
{"name":"Set.kernImage_preimage_union","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\n⊢ Eq (Set.kernImage f (Union.union (Set.preimage f t) s)) (Union.union t (Set.kernImage f s))","decl":"lemma kernImage_preimage_union {s : Set α} {t : Set β} :\n    kernImage f (f ⁻¹' t ∪ s) = t ∪ kernImage f s := by\n  rw [union_comm, kernImage_union_preimage, union_comm]\n\n"}
{"name":"Set.iUnion_congr_Prop","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\np q : Prop\nf₁ : p → Set α\nf₂ : q → Set α\npq : Iff p q\nf : ∀ (x : q), Eq (f₁ ⋯) (f₂ x)\n⊢ Eq (Set.iUnion f₁) (Set.iUnion f₂)","decl":"@[congr]\ntheorem iUnion_congr_Prop {p q : Prop} {f₁ : p → Set α} {f₂ : q → Set α} (pq : p ↔ q)\n    (f : ∀ x, f₁ (pq.mpr x) = f₂ x) : iUnion f₁ = iUnion f₂ :=\n  iSup_congr_Prop pq f\n\n"}
{"name":"Set.iInter_congr_Prop","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\np q : Prop\nf₁ : p → Set α\nf₂ : q → Set α\npq : Iff p q\nf : ∀ (x : q), Eq (f₁ ⋯) (f₂ x)\n⊢ Eq (Set.iInter f₁) (Set.iInter f₂)","decl":"@[congr]\ntheorem iInter_congr_Prop {p q : Prop} {f₁ : p → Set α} {f₂ : q → Set α} (pq : p ↔ q)\n    (f : ∀ x, f₁ (pq.mpr x) = f₂ x) : iInter f₁ = iInter f₂ :=\n  iInf_congr_Prop pq f\n\n"}
{"name":"Set.iUnion_plift_up","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nf : PLift ι → Set α\n⊢ Eq (Set.iUnion fun i => f { down := i }) (Set.iUnion fun i => f i)","decl":"theorem iUnion_plift_up (f : PLift ι → Set α) : ⋃ i, f (PLift.up i) = ⋃ i, f i :=\n  iSup_plift_up _\n\n"}
{"name":"Set.iUnion_plift_down","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nf : ι → Set α\n⊢ Eq (Set.iUnion fun i => f i.down) (Set.iUnion fun i => f i)","decl":"theorem iUnion_plift_down (f : ι → Set α) : ⋃ i, f (PLift.down i) = ⋃ i, f i :=\n  iSup_plift_down _\n\n"}
{"name":"Set.iInter_plift_up","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nf : PLift ι → Set α\n⊢ Eq (Set.iInter fun i => f { down := i }) (Set.iInter fun i => f i)","decl":"theorem iInter_plift_up (f : PLift ι → Set α) : ⋂ i, f (PLift.up i) = ⋂ i, f i :=\n  iInf_plift_up _\n\n"}
{"name":"Set.iInter_plift_down","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nf : ι → Set α\n⊢ Eq (Set.iInter fun i => f i.down) (Set.iInter fun i => f i)","decl":"theorem iInter_plift_down (f : ι → Set α) : ⋂ i, f (PLift.down i) = ⋂ i, f i :=\n  iInf_plift_down _\n\n"}
{"name":"Set.iUnion_eq_if","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\np : Prop\ninst✝ : Decidable p\ns : Set α\n⊢ Eq (Set.iUnion fun x => s) (ite p s EmptyCollection.emptyCollection)","decl":"theorem iUnion_eq_if {p : Prop} [Decidable p] (s : Set α) : ⋃ _ : p, s = if p then s else ∅ :=\n  iSup_eq_if _\n\n"}
{"name":"Set.iUnion_eq_dif","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\np : Prop\ninst✝ : Decidable p\ns : p → Set α\n⊢ Eq (Set.iUnion fun h => s h) (dite p (fun h => s h) fun h => EmptyCollection.emptyCollection)","decl":"theorem iUnion_eq_dif {p : Prop} [Decidable p] (s : p → Set α) :\n    ⋃ h : p, s h = if h : p then s h else ∅ :=\n  iSup_eq_dif _\n\n"}
{"name":"Set.iInter_eq_if","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\np : Prop\ninst✝ : Decidable p\ns : Set α\n⊢ Eq (Set.iInter fun x => s) (ite p s Set.univ)","decl":"theorem iInter_eq_if {p : Prop} [Decidable p] (s : Set α) : ⋂ _ : p, s = if p then s else univ :=\n  iInf_eq_if _\n\n"}
{"name":"Set.iInf_eq_dif","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\np : Prop\ninst✝ : Decidable p\ns : p → Set α\n⊢ Eq (Set.iInter fun h => s h) (dite p (fun h => s h) fun h => Set.univ)","decl":"theorem iInf_eq_dif {p : Prop} [Decidable p] (s : p → Set α) :\n    ⋂ h : p, s h = if h : p then s h else univ :=\n  _root_.iInf_eq_dif _\n\n"}
{"name":"Set.exists_set_mem_of_union_eq_top","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Type u_12\nt : Set ι\ns : ι → Set β\nw : Eq (Set.iUnion fun i => Set.iUnion fun h => s i) Top.top\nx : β\n⊢ Exists fun i => And (Membership.mem t i) (Membership.mem (s i) x)","decl":"theorem exists_set_mem_of_union_eq_top {ι : Type*} (t : Set ι) (s : ι → Set β)\n    (w : ⋃ i ∈ t, s i = ⊤) (x : β) : ∃ i ∈ t, x ∈ s i := by\n  have p : x ∈ ⊤ := Set.mem_univ x\n  rw [← w, Set.mem_iUnion] at p\n  simpa using p\n\n"}
{"name":"Set.nonempty_of_union_eq_top_of_nonempty","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Type u_12\nt : Set ι\ns : ι → Set α\nH : Nonempty α\nw : Eq (Set.iUnion fun i => Set.iUnion fun h => s i) Top.top\n⊢ t.Nonempty","decl":"theorem nonempty_of_union_eq_top_of_nonempty {ι : Type*} (t : Set ι) (s : ι → Set α)\n    (H : Nonempty α) (w : ⋃ i ∈ t, s i = ⊤) : t.Nonempty := by\n  obtain ⟨x, m, -⟩ := exists_set_mem_of_union_eq_top t s w H.some\n  exact ⟨x, m⟩\n\n"}
{"name":"Set.nonempty_of_nonempty_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set α\nh_Union : (Set.iUnion fun i => s i).Nonempty\n⊢ Nonempty ι","decl":"theorem nonempty_of_nonempty_iUnion\n    {s : ι → Set α} (h_Union : (⋃ i, s i).Nonempty) : Nonempty ι := by\n  obtain ⟨x, hx⟩ := h_Union\n  exact ⟨Classical.choose <| mem_iUnion.mp hx⟩\n\n"}
{"name":"Set.nonempty_of_nonempty_iUnion_eq_univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set α\ninst✝ : Nonempty α\nh_Union : Eq (Set.iUnion fun i => s i) Set.univ\n⊢ Nonempty ι","decl":"theorem nonempty_of_nonempty_iUnion_eq_univ\n    {s : ι → Set α} [Nonempty α] (h_Union : ⋃ i, s i = univ) : Nonempty ι :=\n  nonempty_of_nonempty_iUnion (s := s) (by simpa only [h_Union] using univ_nonempty)\n\n"}
{"name":"Set.setOf_exists","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\np : ι → β → Prop\n⊢ Eq (setOf fun x => Exists fun i => p i x) (Set.iUnion fun i => setOf fun x => p i x)","decl":"theorem setOf_exists (p : ι → β → Prop) : { x | ∃ i, p i x } = ⋃ i, { x | p i x } :=\n  ext fun _ => mem_iUnion.symm\n\n"}
{"name":"Set.setOf_forall","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\np : ι → β → Prop\n⊢ Eq (setOf fun x => ∀ (i : ι), p i x) (Set.iInter fun i => setOf fun x => p i x)","decl":"theorem setOf_forall (p : ι → β → Prop) : { x | ∀ i, p i x } = ⋂ i, { x | p i x } :=\n  ext fun _ => mem_iInter.symm\n\n"}
{"name":"Set.iUnion_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set α\nt : Set α\nh : ∀ (i : ι), HasSubset.Subset (s i) t\n⊢ HasSubset.Subset (Set.iUnion fun i => s i) t","decl":"theorem iUnion_subset {s : ι → Set α} {t : Set α} (h : ∀ i, s i ⊆ t) : ⋃ i, s i ⊆ t :=\n  iSup_le h\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iUnion₂_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\nt : Set α\nh : ∀ (i : ι) (j : κ i), HasSubset.Subset (s i j) t\n⊢ HasSubset.Subset (Set.iUnion fun i => Set.iUnion fun j => s i j) t","decl":"theorem iUnion₂_subset {s : ∀ i, κ i → Set α} {t : Set α} (h : ∀ i j, s i j ⊆ t) :\n    ⋃ (i) (j), s i j ⊆ t :=\n  iUnion_subset fun x => iUnion_subset (h x)\n\n"}
{"name":"Set.subset_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\nt : Set β\ns : ι → Set β\nh : ∀ (i : ι), HasSubset.Subset t (s i)\n⊢ HasSubset.Subset t (Set.iInter fun i => s i)","decl":"theorem subset_iInter {t : Set β} {s : ι → Set β} (h : ∀ i, t ⊆ s i) : t ⊆ ⋂ i, s i :=\n  le_iInf h\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.subset_iInter₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : Set α\nt : (i : ι) → κ i → Set α\nh : ∀ (i : ι) (j : κ i), HasSubset.Subset s (t i j)\n⊢ HasSubset.Subset s (Set.iInter fun i => Set.iInter fun j => t i j)","decl":"theorem subset_iInter₂ {s : Set α} {t : ∀ i, κ i → Set α} (h : ∀ i j, s ⊆ t i j) :\n    s ⊆ ⋂ (i) (j), t i j :=\n  subset_iInter fun x => subset_iInter <| h x\n\n"}
{"name":"Set.iUnion_subset_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set α\nt : Set α\n⊢ Iff (HasSubset.Subset (Set.iUnion fun i => s i) t) (∀ (i : ι), HasSubset.Subset (s i) t)","decl":"@[simp]\ntheorem iUnion_subset_iff {s : ι → Set α} {t : Set α} : ⋃ i, s i ⊆ t ↔ ∀ i, s i ⊆ t :=\n  ⟨fun h _ => Subset.trans (le_iSup s _) h, iUnion_subset⟩\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iUnion₂_subset_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\nt : Set α\n⊢ Iff (HasSubset.Subset (Set.iUnion fun i => Set.iUnion fun j => s i j) t) (∀ (i : ι) (j : κ i), HasSubset.Subset (s i j) t)","decl":"theorem iUnion₂_subset_iff {s : ∀ i, κ i → Set α} {t : Set α} :\n    ⋃ (i) (j), s i j ⊆ t ↔ ∀ i j, s i j ⊆ t := by simp_rw [iUnion_subset_iff]\n\n"}
{"name":"Set.subset_iInter_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : Set α\nt : ι → Set α\n⊢ Iff (HasSubset.Subset s (Set.iInter fun i => t i)) (∀ (i : ι), HasSubset.Subset s (t i))","decl":"@[simp]\ntheorem subset_iInter_iff {s : Set α} {t : ι → Set α} : (s ⊆ ⋂ i, t i) ↔ ∀ i, s ⊆ t i :=\n  le_iInf_iff\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.subset_iInter₂_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : Set α\nt : (i : ι) → κ i → Set α\n⊢ Iff (HasSubset.Subset s (Set.iInter fun i => Set.iInter fun j => t i j)) (∀ (i : ι) (j : κ i), HasSubset.Subset s (t i j))","decl":"theorem subset_iInter₂_iff {s : Set α} {t : ∀ i, κ i → Set α} :\n    (s ⊆ ⋂ (i) (j), t i j) ↔ ∀ i j, s ⊆ t i j := by simp_rw [subset_iInter_iff]\n\n"}
{"name":"Set.subset_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns : ι → Set β\ni : ι\n⊢ HasSubset.Subset (s i) (Set.iUnion fun i => s i)","decl":"theorem subset_iUnion : ∀ (s : ι → Set β) (i : ι), s i ⊆ ⋃ i, s i :=\n  le_iSup\n\n"}
{"name":"Set.iInter_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns : ι → Set β\ni : ι\n⊢ HasSubset.Subset (Set.iInter fun i => s i) (s i)","decl":"theorem iInter_subset : ∀ (s : ι → Set β) (i : ι), ⋂ i, s i ⊆ s i :=\n  iInf_le\n\n"}
{"name":"Set.iInter_subset_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ninst✝ : Nonempty ι\ns : ι → Set α\n⊢ HasSubset.Subset (Set.iInter fun i => s i) (Set.iUnion fun i => s i)","decl":"lemma iInter_subset_iUnion [Nonempty ι] {s : ι → Set α} : ⋂ i, s i ⊆ ⋃ i, s i := iInf_le_iSup\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.subset_iUnion₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\ni : ι\nj : κ i\n⊢ HasSubset.Subset (s i j) (Set.iUnion fun i' => Set.iUnion fun j' => s i' j')","decl":"theorem subset_iUnion₂ {s : ∀ i, κ i → Set α} (i : ι) (j : κ i) : s i j ⊆ ⋃ (i') (j'), s i' j' :=\n  le_iSup₂ i j\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iInter₂_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\ni : ι\nj : κ i\n⊢ HasSubset.Subset (Set.iInter fun i => Set.iInter fun j => s i j) (s i j)","decl":"theorem iInter₂_subset {s : ∀ i, κ i → Set α} (i : ι) (j : κ i) : ⋂ (i) (j), s i j ⊆ s i j :=\n  iInf₂_le i j\n\n"}
{"name":"Set.subset_iUnion_of_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : Set α\nt : ι → Set α\ni : ι\nh : HasSubset.Subset s (t i)\n⊢ HasSubset.Subset s (Set.iUnion fun i => t i)","decl":"/-- This rather trivial consequence of `subset_iUnion`is convenient with `apply`, and has `i`\nexplicit for this purpose. -/\ntheorem subset_iUnion_of_subset {s : Set α} {t : ι → Set α} (i : ι) (h : s ⊆ t i) : s ⊆ ⋃ i, t i :=\n  le_iSup_of_le i h\n\n"}
{"name":"Set.iInter_subset_of_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set α\nt : Set α\ni : ι\nh : HasSubset.Subset (s i) t\n⊢ HasSubset.Subset (Set.iInter fun i => s i) t","decl":"/-- This rather trivial consequence of `iInter_subset`is convenient with `apply`, and has `i`\nexplicit for this purpose. -/\ntheorem iInter_subset_of_subset {s : ι → Set α} {t : Set α} (i : ι) (h : s i ⊆ t) :\n    ⋂ i, s i ⊆ t :=\n  iInf_le_of_le i h\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.subset_iUnion₂_of_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : Set α\nt : (i : ι) → κ i → Set α\ni : ι\nj : κ i\nh : HasSubset.Subset s (t i j)\n⊢ HasSubset.Subset s (Set.iUnion fun i => Set.iUnion fun j => t i j)","decl":"/-- This rather trivial consequence of `subset_iUnion₂` is convenient with `apply`, and has `i` and\n`j` explicit for this purpose. -/\ntheorem subset_iUnion₂_of_subset {s : Set α} {t : ∀ i, κ i → Set α} (i : ι) (j : κ i)\n    (h : s ⊆ t i j) : s ⊆ ⋃ (i) (j), t i j :=\n  le_iSup₂_of_le i j h\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iInter₂_subset_of_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\nt : Set α\ni : ι\nj : κ i\nh : HasSubset.Subset (s i j) t\n⊢ HasSubset.Subset (Set.iInter fun i => Set.iInter fun j => s i j) t","decl":"/-- This rather trivial consequence of `iInter₂_subset` is convenient with `apply`, and has `i` and\n`j` explicit for this purpose. -/\ntheorem iInter₂_subset_of_subset {s : ∀ i, κ i → Set α} {t : Set α} (i : ι) (j : κ i)\n    (h : s i j ⊆ t) : ⋂ (i) (j), s i j ⊆ t :=\n  iInf₂_le_of_le i j h\n\n"}
{"name":"Set.iUnion_mono","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns t : ι → Set α\nh : ∀ (i : ι), HasSubset.Subset (s i) (t i)\n⊢ HasSubset.Subset (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem iUnion_mono {s t : ι → Set α} (h : ∀ i, s i ⊆ t i) : ⋃ i, s i ⊆ ⋃ i, t i :=\n  iSup_mono h\n\n"}
{"name":"Set.iUnion_mono''","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns t : ι → Set α\nh : ∀ (i : ι), HasSubset.Subset (s i) (t i)\n⊢ HasSubset.Subset (Set.iUnion s) (Set.iUnion t)","decl":"@[gcongr]\ntheorem iUnion_mono'' {s t : ι → Set α} (h : ∀ i, s i ⊆ t i) : iUnion s ⊆ iUnion t :=\n  iSup_mono h\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iUnion₂_mono","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns t : (i : ι) → κ i → Set α\nh : ∀ (i : ι) (j : κ i), HasSubset.Subset (s i j) (t i j)\n⊢ HasSubset.Subset (Set.iUnion fun i => Set.iUnion fun j => s i j) (Set.iUnion fun i => Set.iUnion fun j => t i j)","decl":"theorem iUnion₂_mono {s t : ∀ i, κ i → Set α} (h : ∀ i j, s i j ⊆ t i j) :\n    ⋃ (i) (j), s i j ⊆ ⋃ (i) (j), t i j :=\n  iSup₂_mono h\n\n"}
{"name":"Set.iInter_mono","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns t : ι → Set α\nh : ∀ (i : ι), HasSubset.Subset (s i) (t i)\n⊢ HasSubset.Subset (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"theorem iInter_mono {s t : ι → Set α} (h : ∀ i, s i ⊆ t i) : ⋂ i, s i ⊆ ⋂ i, t i :=\n  iInf_mono h\n\n"}
{"name":"Set.iInter_mono''","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns t : ι → Set α\nh : ∀ (i : ι), HasSubset.Subset (s i) (t i)\n⊢ HasSubset.Subset (Set.iInter s) (Set.iInter t)","decl":"@[gcongr]\ntheorem iInter_mono'' {s t : ι → Set α} (h : ∀ i, s i ⊆ t i) : iInter s ⊆ iInter t :=\n  iInf_mono h\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iInter₂_mono","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns t : (i : ι) → κ i → Set α\nh : ∀ (i : ι) (j : κ i), HasSubset.Subset (s i j) (t i j)\n⊢ HasSubset.Subset (Set.iInter fun i => Set.iInter fun j => s i j) (Set.iInter fun i => Set.iInter fun j => t i j)","decl":"theorem iInter₂_mono {s t : ∀ i, κ i → Set α} (h : ∀ i j, s i j ⊆ t i j) :\n    ⋂ (i) (j), s i j ⊆ ⋂ (i) (j), t i j :=\n  iInf₂_mono h\n\n"}
{"name":"Set.iUnion_mono'","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι₂ : Sort u_7\ns : ι → Set α\nt : ι₂ → Set α\nh : ∀ (i : ι), Exists fun j => HasSubset.Subset (s i) (t j)\n⊢ HasSubset.Subset (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem iUnion_mono' {s : ι → Set α} {t : ι₂ → Set α} (h : ∀ i, ∃ j, s i ⊆ t j) :\n    ⋃ i, s i ⊆ ⋃ i, t i :=\n  iSup_mono' h\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i' j') -/\n"}
{"name":"Set.iUnion₂_mono'","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι' : Sort u_6\nκ : ι → Sort u_8\nκ' : ι' → Sort u_11\ns : (i : ι) → κ i → Set α\nt : (i' : ι') → κ' i' → Set α\nh : ∀ (i : ι) (j : κ i), Exists fun i' => Exists fun j' => HasSubset.Subset (s i j) (t i' j')\n⊢ HasSubset.Subset (Set.iUnion fun i => Set.iUnion fun j => s i j) (Set.iUnion fun i' => Set.iUnion fun j' => t i' j')","decl":"theorem iUnion₂_mono' {s : ∀ i, κ i → Set α} {t : ∀ i', κ' i' → Set α}\n    (h : ∀ i j, ∃ i' j', s i j ⊆ t i' j') : ⋃ (i) (j), s i j ⊆ ⋃ (i') (j'), t i' j' :=\n  iSup₂_mono' h\n\n"}
{"name":"Set.iInter_mono'","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι' : Sort u_6\ns : ι → Set α\nt : ι' → Set α\nh : ∀ (j : ι'), Exists fun i => HasSubset.Subset (s i) (t j)\n⊢ HasSubset.Subset (Set.iInter fun i => s i) (Set.iInter fun j => t j)","decl":"theorem iInter_mono' {s : ι → Set α} {t : ι' → Set α} (h : ∀ j, ∃ i, s i ⊆ t j) :\n    ⋂ i, s i ⊆ ⋂ j, t j :=\n  Set.subset_iInter fun j =>\n    let ⟨i, hi⟩ := h j\n    iInter_subset_of_subset i hi\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i' j') -/\n"}
{"name":"Set.iInter₂_mono'","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι' : Sort u_6\nκ : ι → Sort u_8\nκ' : ι' → Sort u_11\ns : (i : ι) → κ i → Set α\nt : (i' : ι') → κ' i' → Set α\nh : ∀ (i' : ι') (j' : κ' i'), Exists fun i => Exists fun j => HasSubset.Subset (s i j) (t i' j')\n⊢ HasSubset.Subset (Set.iInter fun i => Set.iInter fun j => s i j) (Set.iInter fun i' => Set.iInter fun j' => t i' j')","decl":"theorem iInter₂_mono' {s : ∀ i, κ i → Set α} {t : ∀ i', κ' i' → Set α}\n    (h : ∀ i' j', ∃ i j, s i j ⊆ t i' j') : ⋂ (i) (j), s i j ⊆ ⋂ (i') (j'), t i' j' :=\n  subset_iInter₂_iff.2 fun i' j' =>\n    let ⟨_, _, hst⟩ := h i' j'\n    (iInter₂_subset _ _).trans hst\n\n"}
{"name":"Set.iUnion₂_subset_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_12\ns : ι → Set α\n⊢ HasSubset.Subset (Set.iUnion fun i => Set.iUnion fun x => s i) (Set.iUnion fun i => s i)","decl":"theorem iUnion₂_subset_iUnion (κ : ι → Sort*) (s : ι → Set α) :\n    ⋃ (i) (_ : κ i), s i ⊆ ⋃ i, s i :=\n  iUnion_mono fun _ => iUnion_subset fun _ => Subset.rfl\n\n"}
{"name":"Set.iInter_subset_iInter₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_12\ns : ι → Set α\n⊢ HasSubset.Subset (Set.iInter fun i => s i) (Set.iInter fun i => Set.iInter fun x => s i)","decl":"theorem iInter_subset_iInter₂ (κ : ι → Sort*) (s : ι → Set α) :\n    ⋂ i, s i ⊆ ⋂ (i) (_ : κ i), s i :=\n  iInter_mono fun _ => subset_iInter fun _ => Subset.rfl\n\n"}
{"name":"Set.iUnion_setOf","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nP : ι → α → Prop\n⊢ Eq (Set.iUnion fun i => setOf fun x => P i x) (setOf fun x => Exists fun i => P i x)","decl":"theorem iUnion_setOf (P : ι → α → Prop) : ⋃ i, { x : α | P i x } = { x : α | ∃ i, P i x } := by\n  ext\n  exact mem_iUnion\n\n"}
{"name":"Set.iInter_setOf","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nP : ι → α → Prop\n⊢ Eq (Set.iInter fun i => setOf fun x => P i x) (setOf fun x => ∀ (i : ι), P i x)","decl":"theorem iInter_setOf (P : ι → α → Prop) : ⋂ i, { x : α | P i x } = { x : α | ∀ i, P i x } := by\n  ext\n  exact mem_iInter\n\n"}
{"name":"Set.iUnion_congr_of_surjective","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι₂ : Sort u_7\nf : ι → Set α\ng : ι₂ → Set α\nh : ι → ι₂\nh1 : Function.Surjective h\nh2 : ∀ (x : ι), Eq (g (h x)) (f x)\n⊢ Eq (Set.iUnion fun x => f x) (Set.iUnion fun y => g y)","decl":"theorem iUnion_congr_of_surjective {f : ι → Set α} {g : ι₂ → Set α} (h : ι → ι₂) (h1 : Surjective h)\n    (h2 : ∀ x, g (h x) = f x) : ⋃ x, f x = ⋃ y, g y :=\n  h1.iSup_congr h h2\n\n"}
{"name":"Set.iInter_congr_of_surjective","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι₂ : Sort u_7\nf : ι → Set α\ng : ι₂ → Set α\nh : ι → ι₂\nh1 : Function.Surjective h\nh2 : ∀ (x : ι), Eq (g (h x)) (f x)\n⊢ Eq (Set.iInter fun x => f x) (Set.iInter fun y => g y)","decl":"theorem iInter_congr_of_surjective {f : ι → Set α} {g : ι₂ → Set α} (h : ι → ι₂) (h1 : Surjective h)\n    (h2 : ∀ x, g (h x) = f x) : ⋂ x, f x = ⋂ y, g y :=\n  h1.iInf_congr h h2\n\n"}
{"name":"Set.iUnion_congr","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns t : ι → Set α\nh : ∀ (i : ι), Eq (s i) (t i)\n⊢ Eq (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"lemma iUnion_congr {s t : ι → Set α} (h : ∀ i, s i = t i) : ⋃ i, s i = ⋃ i, t i := iSup_congr h\n"}
{"name":"Set.iInter_congr","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns t : ι → Set α\nh : ∀ (i : ι), Eq (s i) (t i)\n⊢ Eq (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"lemma iInter_congr {s t : ι → Set α} (h : ∀ i, s i = t i) : ⋂ i, s i = ⋂ i, t i := iInf_congr h\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iUnion₂_congr","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns t : (i : ι) → κ i → Set α\nh : ∀ (i : ι) (j : κ i), Eq (s i j) (t i j)\n⊢ Eq (Set.iUnion fun i => Set.iUnion fun j => s i j) (Set.iUnion fun i => Set.iUnion fun j => t i j)","decl":"lemma iUnion₂_congr {s t : ∀ i, κ i → Set α} (h : ∀ i j, s i j = t i j) :\n    ⋃ (i) (j), s i j = ⋃ (i) (j), t i j :=\n  iUnion_congr fun i => iUnion_congr <| h i\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iInter₂_congr","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns t : (i : ι) → κ i → Set α\nh : ∀ (i : ι) (j : κ i), Eq (s i j) (t i j)\n⊢ Eq (Set.iInter fun i => Set.iInter fun j => s i j) (Set.iInter fun i => Set.iInter fun j => t i j)","decl":"lemma iInter₂_congr {s t : ∀ i, κ i → Set α} (h : ∀ i j, s i j = t i j) :\n    ⋂ (i) (j), s i j = ⋂ (i) (j), t i j :=\n  iInter_congr fun i => iInter_congr <| h i\n\n"}
{"name":"Set.iUnion_const","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\ns : Set β\n⊢ Eq (Set.iUnion fun x => s) s","decl":"lemma iUnion_const (s : Set β) : ⋃ _ : ι, s = s := iSup_const\n"}
{"name":"Set.iInter_const","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\ns : Set β\n⊢ Eq (Set.iInter fun x => s) s","decl":"lemma iInter_const (s : Set β) : ⋂ _ : ι, s = s := iInf_const\n\n"}
{"name":"Set.iUnion_eq_const","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ninst✝ : Nonempty ι\nf : ι → Set α\ns : Set α\nhf : ∀ (i : ι), Eq (f i) s\n⊢ Eq (Set.iUnion fun i => f i) s","decl":"lemma iUnion_eq_const (hf : ∀ i, f i = s) : ⋃ i, f i = s :=\n  (iUnion_congr hf).trans <| iUnion_const _\n\n"}
{"name":"Set.iInter_eq_const","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ninst✝ : Nonempty ι\nf : ι → Set α\ns : Set α\nhf : ∀ (i : ι), Eq (f i) s\n⊢ Eq (Set.iInter fun i => f i) s","decl":"lemma iInter_eq_const (hf : ∀ i, f i = s) : ⋂ i, f i = s :=\n  (iInter_congr hf).trans <| iInter_const _\n\n"}
{"name":"Set.compl_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns : ι → Set β\n⊢ Eq (HasCompl.compl (Set.iUnion fun i => s i)) (Set.iInter fun i => HasCompl.compl (s i))","decl":"@[simp]\ntheorem compl_iUnion (s : ι → Set β) : (⋃ i, s i)ᶜ = ⋂ i, (s i)ᶜ :=\n  compl_iSup\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.compl_iUnion₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\n⊢ Eq (HasCompl.compl (Set.iUnion fun i => Set.iUnion fun j => s i j)) (Set.iInter fun i => Set.iInter fun j => HasCompl.compl (s i j))","decl":"theorem compl_iUnion₂ (s : ∀ i, κ i → Set α) : (⋃ (i) (j), s i j)ᶜ = ⋂ (i) (j), (s i j)ᶜ := by\n  simp_rw [compl_iUnion]\n\n"}
{"name":"Set.compl_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns : ι → Set β\n⊢ Eq (HasCompl.compl (Set.iInter fun i => s i)) (Set.iUnion fun i => HasCompl.compl (s i))","decl":"@[simp]\ntheorem compl_iInter (s : ι → Set β) : (⋂ i, s i)ᶜ = ⋃ i, (s i)ᶜ :=\n  compl_iInf\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.compl_iInter₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\n⊢ Eq (HasCompl.compl (Set.iInter fun i => Set.iInter fun j => s i j)) (Set.iUnion fun i => Set.iUnion fun j => HasCompl.compl (s i j))","decl":"theorem compl_iInter₂ (s : ∀ i, κ i → Set α) : (⋂ (i) (j), s i j)ᶜ = ⋃ (i) (j), (s i j)ᶜ := by\n  simp_rw [compl_iInter]\n\n-- classical -- complete_boolean_algebra\n"}
{"name":"Set.iUnion_eq_compl_iInter_compl","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns : ι → Set β\n⊢ Eq (Set.iUnion fun i => s i) (HasCompl.compl (Set.iInter fun i => HasCompl.compl (s i)))","decl":"theorem iUnion_eq_compl_iInter_compl (s : ι → Set β) : ⋃ i, s i = (⋂ i, (s i)ᶜ)ᶜ := by\n  simp only [compl_iInter, compl_compl]\n\n-- classical -- complete_boolean_algebra\n"}
{"name":"Set.iInter_eq_compl_iUnion_compl","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns : ι → Set β\n⊢ Eq (Set.iInter fun i => s i) (HasCompl.compl (Set.iUnion fun i => HasCompl.compl (s i)))","decl":"theorem iInter_eq_compl_iUnion_compl (s : ι → Set β) : ⋂ i, s i = (⋃ i, (s i)ᶜ)ᶜ := by\n  simp only [compl_iUnion, compl_compl]\n\n"}
{"name":"Set.inter_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns : Set β\nt : ι → Set β\n⊢ Eq (Inter.inter s (Set.iUnion fun i => t i)) (Set.iUnion fun i => Inter.inter s (t i))","decl":"theorem inter_iUnion (s : Set β) (t : ι → Set β) : (s ∩ ⋃ i, t i) = ⋃ i, s ∩ t i :=\n  inf_iSup_eq _ _\n\n"}
{"name":"Set.iUnion_inter","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns : Set β\nt : ι → Set β\n⊢ Eq (Inter.inter (Set.iUnion fun i => t i) s) (Set.iUnion fun i => Inter.inter (t i) s)","decl":"theorem iUnion_inter (s : Set β) (t : ι → Set β) : (⋃ i, t i) ∩ s = ⋃ i, t i ∩ s :=\n  iSup_inf_eq _ _\n\n"}
{"name":"Set.iUnion_union_distrib","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns t : ι → Set β\n⊢ Eq (Set.iUnion fun i => Union.union (s i) (t i)) (Union.union (Set.iUnion fun i => s i) (Set.iUnion fun i => t i))","decl":"theorem iUnion_union_distrib (s : ι → Set β) (t : ι → Set β) :\n    ⋃ i, s i ∪ t i = (⋃ i, s i) ∪ ⋃ i, t i :=\n  iSup_sup_eq\n\n"}
{"name":"Set.iInter_inter_distrib","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns t : ι → Set β\n⊢ Eq (Set.iInter fun i => Inter.inter (s i) (t i)) (Inter.inter (Set.iInter fun i => s i) (Set.iInter fun i => t i))","decl":"theorem iInter_inter_distrib (s : ι → Set β) (t : ι → Set β) :\n    ⋂ i, s i ∩ t i = (⋂ i, s i) ∩ ⋂ i, t i :=\n  iInf_inf_eq\n\n"}
{"name":"Set.union_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\ns : Set β\nt : ι → Set β\n⊢ Eq (Union.union s (Set.iUnion fun i => t i)) (Set.iUnion fun i => Union.union s (t i))","decl":"theorem union_iUnion [Nonempty ι] (s : Set β) (t : ι → Set β) : (s ∪ ⋃ i, t i) = ⋃ i, s ∪ t i :=\n  sup_iSup\n\n"}
{"name":"Set.iUnion_union","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\ns : Set β\nt : ι → Set β\n⊢ Eq (Union.union (Set.iUnion fun i => t i) s) (Set.iUnion fun i => Union.union (t i) s)","decl":"theorem iUnion_union [Nonempty ι] (s : Set β) (t : ι → Set β) : (⋃ i, t i) ∪ s = ⋃ i, t i ∪ s :=\n  iSup_sup\n\n"}
{"name":"Set.inter_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\ns : Set β\nt : ι → Set β\n⊢ Eq (Inter.inter s (Set.iInter fun i => t i)) (Set.iInter fun i => Inter.inter s (t i))","decl":"theorem inter_iInter [Nonempty ι] (s : Set β) (t : ι → Set β) : (s ∩ ⋂ i, t i) = ⋂ i, s ∩ t i :=\n  inf_iInf\n\n"}
{"name":"Set.iInter_inter","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\ns : Set β\nt : ι → Set β\n⊢ Eq (Inter.inter (Set.iInter fun i => t i) s) (Set.iInter fun i => Inter.inter (t i) s)","decl":"theorem iInter_inter [Nonempty ι] (s : Set β) (t : ι → Set β) : (⋂ i, t i) ∩ s = ⋂ i, t i ∩ s :=\n  iInf_inf\n\n"}
{"name":"Set.insert_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\nx : β\nt : ι → Set β\n⊢ Eq (Insert.insert x (Set.iUnion fun i => t i)) (Set.iUnion fun i => Insert.insert x (t i))","decl":"theorem insert_iUnion [Nonempty ι] (x : β) (t : ι → Set β) :\n    insert x (⋃ i, t i) = ⋃ i, insert x (t i) := by\n  simp_rw [← union_singleton, iUnion_union]\n\n-- classical\n"}
{"name":"Set.union_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns : Set β\nt : ι → Set β\n⊢ Eq (Union.union s (Set.iInter fun i => t i)) (Set.iInter fun i => Union.union s (t i))","decl":"theorem union_iInter (s : Set β) (t : ι → Set β) : (s ∪ ⋂ i, t i) = ⋂ i, s ∪ t i :=\n  sup_iInf_eq _ _\n\n"}
{"name":"Set.iInter_union","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns : ι → Set β\nt : Set β\n⊢ Eq (Union.union (Set.iInter fun i => s i) t) (Set.iInter fun i => Union.union (s i) t)","decl":"theorem iInter_union (s : ι → Set β) (t : Set β) : (⋂ i, s i) ∪ t = ⋂ i, s i ∪ t :=\n  iInf_sup_eq _ _\n\n"}
{"name":"Set.insert_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\nx : β\nt : ι → Set β\n⊢ Eq (Insert.insert x (Set.iInter fun i => t i)) (Set.iInter fun i => Insert.insert x (t i))","decl":"theorem insert_iInter (x : β) (t : ι → Set β) : insert x (⋂ i, t i) = ⋂ i, insert x (t i) := by\n  simp_rw [← union_singleton, iInter_union]\n\n"}
{"name":"Set.iUnion_diff","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns : Set β\nt : ι → Set β\n⊢ Eq (SDiff.sdiff (Set.iUnion fun i => t i) s) (Set.iUnion fun i => SDiff.sdiff (t i) s)","decl":"theorem iUnion_diff (s : Set β) (t : ι → Set β) : (⋃ i, t i) \\ s = ⋃ i, t i \\ s :=\n  iUnion_inter _ _\n\n"}
{"name":"Set.diff_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\ns : Set β\nt : ι → Set β\n⊢ Eq (SDiff.sdiff s (Set.iUnion fun i => t i)) (Set.iInter fun i => SDiff.sdiff s (t i))","decl":"theorem diff_iUnion [Nonempty ι] (s : Set β) (t : ι → Set β) : (s \\ ⋃ i, t i) = ⋂ i, s \\ t i := by\n  rw [diff_eq, compl_iUnion, inter_iInter]; rfl\n\n"}
{"name":"Set.diff_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns : Set β\nt : ι → Set β\n⊢ Eq (SDiff.sdiff s (Set.iInter fun i => t i)) (Set.iUnion fun i => SDiff.sdiff s (t i))","decl":"theorem diff_iInter (s : Set β) (t : ι → Set β) : (s \\ ⋂ i, t i) = ⋃ i, s \\ t i := by\n  rw [diff_eq, compl_iInter, inter_iUnion]; rfl\n\n"}
{"name":"Set.iUnion_inter_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"ι : Sort u_12\nα : Type u_13\ns t : ι → Set α\n⊢ HasSubset.Subset (Set.iUnion fun i => Inter.inter (s i) (t i)) (Inter.inter (Set.iUnion fun i => s i) (Set.iUnion fun i => t i))","decl":"theorem iUnion_inter_subset {ι α} {s t : ι → Set α} : ⋃ i, s i ∩ t i ⊆ (⋃ i, s i) ∩ ⋃ i, t i :=\n  le_iSup_inf_iSup s t\n\n"}
{"name":"Set.iUnion_inter_of_monotone","module":"Mathlib.Data.Set.Lattice","initialProofState":"ι : Type u_12\nα : Type u_13\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\ns t : ι → Set α\nhs : Monotone s\nht : Monotone t\n⊢ Eq (Set.iUnion fun i => Inter.inter (s i) (t i)) (Inter.inter (Set.iUnion fun i => s i) (Set.iUnion fun i => t i))","decl":"theorem iUnion_inter_of_monotone {ι α} [Preorder ι] [IsDirected ι (· ≤ ·)] {s t : ι → Set α}\n    (hs : Monotone s) (ht : Monotone t) : ⋃ i, s i ∩ t i = (⋃ i, s i) ∩ ⋃ i, t i :=\n  iSup_inf_of_monotone hs ht\n\n"}
{"name":"Set.iUnion_inter_of_antitone","module":"Mathlib.Data.Set.Lattice","initialProofState":"ι : Type u_12\nα : Type u_13\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι (Function.swap fun x1 x2 => LE.le x1 x2)\ns t : ι → Set α\nhs : Antitone s\nht : Antitone t\n⊢ Eq (Set.iUnion fun i => Inter.inter (s i) (t i)) (Inter.inter (Set.iUnion fun i => s i) (Set.iUnion fun i => t i))","decl":"theorem iUnion_inter_of_antitone {ι α} [Preorder ι] [IsDirected ι (swap (· ≤ ·))] {s t : ι → Set α}\n    (hs : Antitone s) (ht : Antitone t) : ⋃ i, s i ∩ t i = (⋃ i, s i) ∩ ⋃ i, t i :=\n  iSup_inf_of_antitone hs ht\n\n"}
{"name":"Set.iInter_union_of_monotone","module":"Mathlib.Data.Set.Lattice","initialProofState":"ι : Type u_12\nα : Type u_13\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι (Function.swap fun x1 x2 => LE.le x1 x2)\ns t : ι → Set α\nhs : Monotone s\nht : Monotone t\n⊢ Eq (Set.iInter fun i => Union.union (s i) (t i)) (Union.union (Set.iInter fun i => s i) (Set.iInter fun i => t i))","decl":"theorem iInter_union_of_monotone {ι α} [Preorder ι] [IsDirected ι (swap (· ≤ ·))] {s t : ι → Set α}\n    (hs : Monotone s) (ht : Monotone t) : ⋂ i, s i ∪ t i = (⋂ i, s i) ∪ ⋂ i, t i :=\n  iInf_sup_of_monotone hs ht\n\n"}
{"name":"Set.iInter_union_of_antitone","module":"Mathlib.Data.Set.Lattice","initialProofState":"ι : Type u_12\nα : Type u_13\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\ns t : ι → Set α\nhs : Antitone s\nht : Antitone t\n⊢ Eq (Set.iInter fun i => Union.union (s i) (t i)) (Union.union (Set.iInter fun i => s i) (Set.iInter fun i => t i))","decl":"theorem iInter_union_of_antitone {ι α} [Preorder ι] [IsDirected ι (· ≤ ·)] {s t : ι → Set α}\n    (hs : Antitone s) (ht : Antitone t) : ⋂ i, s i ∪ t i = (⋂ i, s i) ∪ ⋂ i, t i :=\n  iInf_sup_of_antitone hs ht\n\n"}
{"name":"Set.iUnion_iInter_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι' : Sort u_6\ns : ι → ι' → Set α\n⊢ HasSubset.Subset (Set.iUnion fun j => Set.iInter fun i => s i j) (Set.iInter fun i => Set.iUnion fun j => s i j)","decl":"/-- An equality version of this lemma is `iUnion_iInter_of_monotone` in `Data.Set.Finite`. -/\ntheorem iUnion_iInter_subset {s : ι → ι' → Set α} : (⋃ j, ⋂ i, s i j) ⊆ ⋂ i, ⋃ j, s i j :=\n  iSup_iInf_le_iInf_iSup (flip s)\n\n"}
{"name":"Set.iUnion_option","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Type u_12\ns : Option ι → Set α\n⊢ Eq (Set.iUnion fun o => s o) (Union.union (s Option.none) (Set.iUnion fun i => s (Option.some i)))","decl":"theorem iUnion_option {ι} (s : Option ι → Set α) : ⋃ o, s o = s none ∪ ⋃ i, s (some i) :=\n  iSup_option s\n\n"}
{"name":"Set.iInter_option","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Type u_12\ns : Option ι → Set α\n⊢ Eq (Set.iInter fun o => s o) (Inter.inter (s Option.none) (Set.iInter fun i => s (Option.some i)))","decl":"theorem iInter_option {ι} (s : Option ι → Set α) : ⋂ o, s o = s none ∩ ⋂ i, s (some i) :=\n  iInf_option s\n\n"}
{"name":"Set.iUnion_dite","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\np : ι → Prop\ninst✝ : DecidablePred p\nf : (i : ι) → p i → Set α\ng : (i : ι) → Not (p i) → Set α\n⊢ Eq (Set.iUnion fun i => dite (p i) (fun h => f i h) fun h => g i h) (Union.union (Set.iUnion fun i => Set.iUnion fun h => f i h) (Set.iUnion fun i => Set.iUnion fun h => g i h))","decl":"theorem iUnion_dite (f : ∀ i, p i → Set α) (g : ∀ i, ¬p i → Set α) :\n    ⋃ i, (if h : p i then f i h else g i h) = (⋃ (i) (h : p i), f i h) ∪ ⋃ (i) (h : ¬p i), g i h :=\n  iSup_dite _ _ _\n\n"}
{"name":"Set.iUnion_ite","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\np : ι → Prop\ninst✝ : DecidablePred p\nf g : ι → Set α\n⊢ Eq (Set.iUnion fun i => ite (p i) (f i) (g i)) (Union.union (Set.iUnion fun i => Set.iUnion fun x => f i) (Set.iUnion fun i => Set.iUnion fun x => g i))","decl":"theorem iUnion_ite (f g : ι → Set α) :\n    ⋃ i, (if p i then f i else g i) = (⋃ (i) (_ : p i), f i) ∪ ⋃ (i) (_ : ¬p i), g i :=\n  iUnion_dite _ _ _\n\n"}
{"name":"Set.iInter_dite","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\np : ι → Prop\ninst✝ : DecidablePred p\nf : (i : ι) → p i → Set α\ng : (i : ι) → Not (p i) → Set α\n⊢ Eq (Set.iInter fun i => dite (p i) (fun h => f i h) fun h => g i h) (Inter.inter (Set.iInter fun i => Set.iInter fun h => f i h) (Set.iInter fun i => Set.iInter fun h => g i h))","decl":"theorem iInter_dite (f : ∀ i, p i → Set α) (g : ∀ i, ¬p i → Set α) :\n    ⋂ i, (if h : p i then f i h else g i h) = (⋂ (i) (h : p i), f i h) ∩ ⋂ (i) (h : ¬p i), g i h :=\n  iInf_dite _ _ _\n\n"}
{"name":"Set.iInter_ite","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\np : ι → Prop\ninst✝ : DecidablePred p\nf g : ι → Set α\n⊢ Eq (Set.iInter fun i => ite (p i) (f i) (g i)) (Inter.inter (Set.iInter fun i => Set.iInter fun x => f i) (Set.iInter fun i => Set.iInter fun x => g i))","decl":"theorem iInter_ite (f g : ι → Set α) :\n    ⋂ i, (if p i then f i else g i) = (⋂ (i) (_ : p i), f i) ∩ ⋂ (i) (_ : ¬p i), g i :=\n  iInter_dite _ _ _\n\n"}
{"name":"Set.image_projection_prod","module":"Mathlib.Data.Set.Lattice","initialProofState":"ι : Type u_12\nα : ι → Type u_13\nv : (i : ι) → Set (α i)\nhv : (Set.univ.pi v).Nonempty\ni : ι\n⊢ Eq (Set.image (fun x => x i) (Set.iInter fun k => Set.preimage (fun x => x k) (v k))) (v i)","decl":"theorem image_projection_prod {ι : Type*} {α : ι → Type*} {v : ∀ i : ι, Set (α i)}\n    (hv : (pi univ v).Nonempty) (i : ι) :\n    ((fun x : ∀ i : ι, α i => x i) '' ⋂ k, (fun x : ∀ j : ι, α j => x k) ⁻¹' v k) = v i := by\n  classical\n    apply Subset.antisymm\n    · simp [iInter_subset]\n    · intro y y_in\n      simp only [mem_image, mem_iInter, mem_preimage]\n      rcases hv with ⟨z, hz⟩\n      refine ⟨Function.update z i y, ?_, update_self i y z⟩\n      rw [@forall_update_iff ι α _ z i y fun i t => t ∈ v i]\n      exact ⟨y_in, fun j _ => by simpa using hz j⟩\n\n"}
{"name":"Set.iInter_false","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : False → Set α\n⊢ Eq (Set.iInter s) Set.univ","decl":"theorem iInter_false {s : False → Set α} : iInter s = univ :=\n  iInf_false\n\n"}
{"name":"Set.iUnion_false","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : False → Set α\n⊢ Eq (Set.iUnion s) EmptyCollection.emptyCollection","decl":"theorem iUnion_false {s : False → Set α} : iUnion s = ∅ :=\n  iSup_false\n\n"}
{"name":"Set.iInter_true","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : True → Set α\n⊢ Eq (Set.iInter s) (s trivial)","decl":"@[simp]\ntheorem iInter_true {s : True → Set α} : iInter s = s trivial :=\n  iInf_true\n\n"}
{"name":"Set.iUnion_true","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : True → Set α\n⊢ Eq (Set.iUnion s) (s trivial)","decl":"@[simp]\ntheorem iUnion_true {s : True → Set α} : iUnion s = s trivial :=\n  iSup_true\n\n"}
{"name":"Set.iInter_exists","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\np : ι → Prop\nf : Exists p → Set α\n⊢ Eq (Set.iInter fun x => f x) (Set.iInter fun i => Set.iInter fun h => f ⋯)","decl":"@[simp]\ntheorem iInter_exists {p : ι → Prop} {f : Exists p → Set α} :\n    ⋂ x, f x = ⋂ (i) (h : p i), f ⟨i, h⟩ :=\n  iInf_exists\n\n"}
{"name":"Set.iUnion_exists","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\np : ι → Prop\nf : Exists p → Set α\n⊢ Eq (Set.iUnion fun x => f x) (Set.iUnion fun i => Set.iUnion fun h => f ⋯)","decl":"@[simp]\ntheorem iUnion_exists {p : ι → Prop} {f : Exists p → Set α} :\n    ⋃ x, f x = ⋃ (i) (h : p i), f ⟨i, h⟩ :=\n  iSup_exists\n\n"}
{"name":"Set.iUnion_empty","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\n⊢ Eq (Set.iUnion fun x => EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem iUnion_empty : (⋃ _ : ι, ∅ : Set α) = ∅ :=\n  iSup_bot\n\n"}
{"name":"Set.iInter_univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\n⊢ Eq (Set.iInter fun x => Set.univ) Set.univ","decl":"@[simp]\ntheorem iInter_univ : (⋂ _ : ι, univ : Set α) = univ :=\n  iInf_top\n\n"}
{"name":"Set.iUnion_eq_empty","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set α\n⊢ Iff (Eq (Set.iUnion fun i => s i) EmptyCollection.emptyCollection) (∀ (i : ι), Eq (s i) EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem iUnion_eq_empty : ⋃ i, s i = ∅ ↔ ∀ i, s i = ∅ :=\n  iSup_eq_bot\n\n"}
{"name":"Set.iInter_eq_univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set α\n⊢ Iff (Eq (Set.iInter fun i => s i) Set.univ) (∀ (i : ι), Eq (s i) Set.univ)","decl":"@[simp]\ntheorem iInter_eq_univ : ⋂ i, s i = univ ↔ ∀ i, s i = univ :=\n  iInf_eq_top\n\n"}
{"name":"Set.nonempty_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set α\n⊢ Iff (Set.iUnion fun i => s i).Nonempty (Exists fun i => (s i).Nonempty)","decl":"@[simp]\ntheorem nonempty_iUnion : (⋃ i, s i).Nonempty ↔ ∃ i, (s i).Nonempty := by\n  simp [nonempty_iff_ne_empty]\n\n"}
{"name":"Set.nonempty_biUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set α\ns : α → Set β\n⊢ Iff (Set.iUnion fun i => Set.iUnion fun h => s i).Nonempty (Exists fun i => And (Membership.mem t i) (s i).Nonempty)","decl":"theorem nonempty_biUnion {t : Set α} {s : α → Set β} :\n    (⋃ i ∈ t, s i).Nonempty ↔ ∃ i ∈ t, (s i).Nonempty := by simp\n\n"}
{"name":"Set.iUnion_nonempty_index","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : s.Nonempty → Set β\n⊢ Eq (Set.iUnion fun h => t h) (Set.iUnion fun x => Set.iUnion fun h => t ⋯)","decl":"theorem iUnion_nonempty_index (s : Set α) (t : s.Nonempty → Set β) :\n    ⋃ h, t h = ⋃ x ∈ s, t ⟨x, ‹_›⟩ :=\n  iSup_exists\n\n"}
{"name":"Set.iInter_iInter_eq_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\ns : (x : β) → Eq x b → Set α\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => s x h) (s b ⋯)","decl":"@[simp]\ntheorem iInter_iInter_eq_left {b : β} {s : ∀ x : β, x = b → Set α} :\n    ⋂ (x) (h : x = b), s x h = s b rfl :=\n  iInf_iInf_eq_left\n\n"}
{"name":"Set.iInter_iInter_eq_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\ns : (x : β) → Eq b x → Set α\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => s x h) (s b ⋯)","decl":"@[simp]\ntheorem iInter_iInter_eq_right {b : β} {s : ∀ x : β, b = x → Set α} :\n    ⋂ (x) (h : b = x), s x h = s b rfl :=\n  iInf_iInf_eq_right\n\n"}
{"name":"Set.iUnion_iUnion_eq_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\ns : (x : β) → Eq x b → Set α\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => s x h) (s b ⋯)","decl":"@[simp]\ntheorem iUnion_iUnion_eq_left {b : β} {s : ∀ x : β, x = b → Set α} :\n    ⋃ (x) (h : x = b), s x h = s b rfl :=\n  iSup_iSup_eq_left\n\n"}
{"name":"Set.iUnion_iUnion_eq_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\ns : (x : β) → Eq b x → Set α\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => s x h) (s b ⋯)","decl":"@[simp]\ntheorem iUnion_iUnion_eq_right {b : β} {s : ∀ x : β, b = x → Set α} :\n    ⋃ (x) (h : b = x), s x h = s b rfl :=\n  iSup_iSup_eq_right\n\n"}
{"name":"Set.iInter_or","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\np q : Prop\ns : Or p q → Set α\n⊢ Eq (Set.iInter fun h => s h) (Inter.inter (Set.iInter fun h => s ⋯) (Set.iInter fun h => s ⋯))","decl":"theorem iInter_or {p q : Prop} (s : p ∨ q → Set α) :\n    ⋂ h, s h = (⋂ h : p, s (Or.inl h)) ∩ ⋂ h : q, s (Or.inr h) :=\n  iInf_or\n\n"}
{"name":"Set.iUnion_or","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\np q : Prop\ns : Or p q → Set α\n⊢ Eq (Set.iUnion fun h => s h) (Union.union (Set.iUnion fun i => s ⋯) (Set.iUnion fun j => s ⋯))","decl":"theorem iUnion_or {p q : Prop} (s : p ∨ q → Set α) :\n    ⋃ h, s h = (⋃ i, s (Or.inl i)) ∪ ⋃ j, s (Or.inr j) :=\n  iSup_or\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (hp hq) -/\n"}
{"name":"Set.iUnion_and","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\np q : Prop\ns : And p q → Set α\n⊢ Eq (Set.iUnion fun h => s h) (Set.iUnion fun hp => Set.iUnion fun hq => s ⋯)","decl":"theorem iUnion_and {p q : Prop} (s : p ∧ q → Set α) : ⋃ h, s h = ⋃ (hp) (hq), s ⟨hp, hq⟩ :=\n  iSup_and\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (hp hq) -/\n"}
{"name":"Set.iInter_and","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\np q : Prop\ns : And p q → Set α\n⊢ Eq (Set.iInter fun h => s h) (Set.iInter fun hp => Set.iInter fun hq => s ⋯)","decl":"theorem iInter_and {p q : Prop} (s : p ∧ q → Set α) : ⋂ h, s h = ⋂ (hp) (hq), s ⟨hp, hq⟩ :=\n  iInf_and\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i i') -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i' i) -/\n"}
{"name":"Set.iUnion_comm","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι' : Sort u_6\ns : ι → ι' → Set α\n⊢ Eq (Set.iUnion fun i => Set.iUnion fun i' => s i i') (Set.iUnion fun i' => Set.iUnion fun i => s i i')","decl":"theorem iUnion_comm (s : ι → ι' → Set α) : ⋃ (i) (i'), s i i' = ⋃ (i') (i), s i i' :=\n  iSup_comm\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i i') -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i' i) -/\n"}
{"name":"Set.iInter_comm","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι' : Sort u_6\ns : ι → ι' → Set α\n⊢ Eq (Set.iInter fun i => Set.iInter fun i' => s i i') (Set.iInter fun i' => Set.iInter fun i => s i i')","decl":"theorem iInter_comm (s : ι → ι' → Set α) : ⋂ (i) (i'), s i i' = ⋂ (i') (i), s i i' :=\n  iInf_comm\n\n"}
{"name":"Set.iUnion_sigma","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : α → Type u_12\ns : Sigma γ → Set β\n⊢ Eq (Set.iUnion fun ia => s ia) (Set.iUnion fun i => Set.iUnion fun a => s ⟨i, a⟩)","decl":"theorem iUnion_sigma {γ : α → Type*} (s : Sigma γ → Set β) : ⋃ ia, s ia = ⋃ i, ⋃ a, s ⟨i, a⟩ :=\n  iSup_sigma\n\n"}
{"name":"Set.iUnion_sigma'","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : α → Type u_12\ns : (i : α) → γ i → Set β\n⊢ Eq (Set.iUnion fun i => Set.iUnion fun a => s i a) (Set.iUnion fun ia => s ia.fst ia.snd)","decl":"theorem iUnion_sigma' {γ : α → Type*} (s : ∀ i, γ i → Set β) :\n    ⋃ i, ⋃ a, s i a = ⋃ ia : Sigma γ, s ia.1 ia.2 :=\n  iSup_sigma' _\n\n"}
{"name":"Set.iInter_sigma","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : α → Type u_12\ns : Sigma γ → Set β\n⊢ Eq (Set.iInter fun ia => s ia) (Set.iInter fun i => Set.iInter fun a => s ⟨i, a⟩)","decl":"theorem iInter_sigma {γ : α → Type*} (s : Sigma γ → Set β) : ⋂ ia, s ia = ⋂ i, ⋂ a, s ⟨i, a⟩ :=\n  iInf_sigma\n\n"}
{"name":"Set.iInter_sigma'","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : α → Type u_12\ns : (i : α) → γ i → Set β\n⊢ Eq (Set.iInter fun i => Set.iInter fun a => s i a) (Set.iInter fun ia => s ia.fst ia.snd)","decl":"theorem iInter_sigma' {γ : α → Type*} (s : ∀ i, γ i → Set β) :\n    ⋂ i, ⋂ a, s i a = ⋂ ia : Sigma γ, s ia.1 ia.2 :=\n  iInf_sigma' _\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i₁ j₁ i₂ j₂) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i₂ j₂ i₁ j₁) -/\n"}
{"name":"Set.iUnion₂_comm","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ₁ : ι → Sort u_9\nκ₂ : ι → Sort u_10\ns : (i₁ : ι) → κ₁ i₁ → (i₂ : ι) → κ₂ i₂ → Set α\n⊢ Eq (Set.iUnion fun i₁ => Set.iUnion fun j₁ => Set.iUnion fun i₂ => Set.iUnion fun j₂ => s i₁ j₁ i₂ j₂) (Set.iUnion fun i₂ => Set.iUnion fun j₂ => Set.iUnion fun i₁ => Set.iUnion fun j₁ => s i₁ j₁ i₂ j₂)","decl":"theorem iUnion₂_comm (s : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → Set α) :\n    ⋃ (i₁) (j₁) (i₂) (j₂), s i₁ j₁ i₂ j₂ = ⋃ (i₂) (j₂) (i₁) (j₁), s i₁ j₁ i₂ j₂ :=\n  iSup₂_comm _\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i₁ j₁ i₂ j₂) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i₂ j₂ i₁ j₁) -/\n"}
{"name":"Set.iInter₂_comm","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ₁ : ι → Sort u_9\nκ₂ : ι → Sort u_10\ns : (i₁ : ι) → κ₁ i₁ → (i₂ : ι) → κ₂ i₂ → Set α\n⊢ Eq (Set.iInter fun i₁ => Set.iInter fun j₁ => Set.iInter fun i₂ => Set.iInter fun j₂ => s i₁ j₁ i₂ j₂) (Set.iInter fun i₂ => Set.iInter fun j₂ => Set.iInter fun i₁ => Set.iInter fun j₁ => s i₁ j₁ i₂ j₂)","decl":"theorem iInter₂_comm (s : ∀ i₁, κ₁ i₁ → ∀ i₂, κ₂ i₂ → Set α) :\n    ⋂ (i₁) (j₁) (i₂) (j₂), s i₁ j₁ i₂ j₂ = ⋂ (i₂) (j₂) (i₁) (j₁), s i₁ j₁ i₂ j₂ :=\n  iInf₂_comm _\n\n"}
{"name":"Set.biUnion_and","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι' : Sort u_6\np : ι → Prop\nq : ι → ι' → Prop\ns : (x : ι) → (y : ι') → And (p x) (q x y) → Set α\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun y => Set.iUnion fun h => s x y h) (Set.iUnion fun x => Set.iUnion fun hx => Set.iUnion fun y => Set.iUnion fun hy => s x y ⋯)","decl":"@[simp]\ntheorem biUnion_and (p : ι → Prop) (q : ι → ι' → Prop) (s : ∀ x y, p x ∧ q x y → Set α) :\n    ⋃ (x : ι) (y : ι') (h : p x ∧ q x y), s x y h =\n      ⋃ (x : ι) (hx : p x) (y : ι') (hy : q x y), s x y ⟨hx, hy⟩ := by\n  simp only [iUnion_and, @iUnion_comm _ ι']\n\n"}
{"name":"Set.biUnion_and'","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι' : Sort u_6\np : ι' → Prop\nq : ι → ι' → Prop\ns : (x : ι) → (y : ι') → And (p y) (q x y) → Set α\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun y => Set.iUnion fun h => s x y h) (Set.iUnion fun y => Set.iUnion fun hy => Set.iUnion fun x => Set.iUnion fun hx => s x y ⋯)","decl":"@[simp]\ntheorem biUnion_and' (p : ι' → Prop) (q : ι → ι' → Prop) (s : ∀ x y, p y ∧ q x y → Set α) :\n    ⋃ (x : ι) (y : ι') (h : p y ∧ q x y), s x y h =\n      ⋃ (y : ι') (hy : p y) (x : ι) (hx : q x y), s x y ⟨hy, hx⟩ := by\n  simp only [iUnion_and, @iUnion_comm _ ι]\n\n"}
{"name":"Set.biInter_and","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι' : Sort u_6\np : ι → Prop\nq : ι → ι' → Prop\ns : (x : ι) → (y : ι') → And (p x) (q x y) → Set α\n⊢ Eq (Set.iInter fun x => Set.iInter fun y => Set.iInter fun h => s x y h) (Set.iInter fun x => Set.iInter fun hx => Set.iInter fun y => Set.iInter fun hy => s x y ⋯)","decl":"@[simp]\ntheorem biInter_and (p : ι → Prop) (q : ι → ι' → Prop) (s : ∀ x y, p x ∧ q x y → Set α) :\n    ⋂ (x : ι) (y : ι') (h : p x ∧ q x y), s x y h =\n      ⋂ (x : ι) (hx : p x) (y : ι') (hy : q x y), s x y ⟨hx, hy⟩ := by\n  simp only [iInter_and, @iInter_comm _ ι']\n\n"}
{"name":"Set.biInter_and'","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι' : Sort u_6\np : ι' → Prop\nq : ι → ι' → Prop\ns : (x : ι) → (y : ι') → And (p y) (q x y) → Set α\n⊢ Eq (Set.iInter fun x => Set.iInter fun y => Set.iInter fun h => s x y h) (Set.iInter fun y => Set.iInter fun hy => Set.iInter fun x => Set.iInter fun hx => s x y ⋯)","decl":"@[simp]\ntheorem biInter_and' (p : ι' → Prop) (q : ι → ι' → Prop) (s : ∀ x y, p y ∧ q x y → Set α) :\n    ⋂ (x : ι) (y : ι') (h : p y ∧ q x y), s x y h =\n      ⋂ (y : ι') (hy : p y) (x : ι) (hx : q x y), s x y ⟨hy, hx⟩ := by\n  simp only [iInter_and, @iInter_comm _ ι]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (x h) -/\n"}
{"name":"Set.iUnion_iUnion_eq_or_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\np : β → Prop\ns : (x : β) → Or (Eq x b) (p x) → Set α\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => s x h) (Union.union (s b ⋯) (Set.iUnion fun x => Set.iUnion fun h => s x ⋯))","decl":"@[simp]\ntheorem iUnion_iUnion_eq_or_left {b : β} {p : β → Prop} {s : ∀ x : β, x = b ∨ p x → Set α} :\n    ⋃ (x) (h), s x h = s b (Or.inl rfl) ∪ ⋃ (x) (h : p x), s x (Or.inr h) := by\n  simp only [iUnion_or, iUnion_union_distrib, iUnion_iUnion_eq_left]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (x h) -/\n"}
{"name":"Set.iInter_iInter_eq_or_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\np : β → Prop\ns : (x : β) → Or (Eq x b) (p x) → Set α\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => s x h) (Inter.inter (s b ⋯) (Set.iInter fun x => Set.iInter fun h => s x ⋯))","decl":"@[simp]\ntheorem iInter_iInter_eq_or_left {b : β} {p : β → Prop} {s : ∀ x : β, x = b ∨ p x → Set α} :\n    ⋂ (x) (h), s x h = s b (Or.inl rfl) ∩ ⋂ (x) (h : p x), s x (Or.inr h) := by\n  simp only [iInter_or, iInter_inter_distrib, iInter_iInter_eq_left]\n\n"}
{"name":"Set.iUnion_sum","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Sum α β → Set γ\n⊢ Eq (Set.iUnion fun x => s x) (Union.union (Set.iUnion fun x => s (Sum.inl x)) (Set.iUnion fun x => s (Sum.inr x)))","decl":"lemma iUnion_sum {s : α ⊕ β → Set γ} : ⋃ x, s x = (⋃ x, s (.inl x)) ∪ ⋃ x, s (.inr x) := iSup_sum\n\n"}
{"name":"Set.iInter_sum","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Sum α β → Set γ\n⊢ Eq (Set.iInter fun x => s x) (Inter.inter (Set.iInter fun x => s (Sum.inl x)) (Set.iInter fun x => s (Sum.inr x)))","decl":"lemma iInter_sum {s : α ⊕ β → Set γ} : ⋂ x, s x = (⋂ x, s (.inl x)) ∩ ⋂ x, s (.inr x) := iInf_sum\n\n"}
{"name":"Set.iUnion_psigma","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : α → Type u_12\ns : PSigma γ → Set β\n⊢ Eq (Set.iUnion fun ia => s ia) (Set.iUnion fun i => Set.iUnion fun a => s ⟨i, a⟩)","decl":"theorem iUnion_psigma {γ : α → Type*} (s : PSigma γ → Set β) : ⋃ ia, s ia = ⋃ i, ⋃ a, s ⟨i, a⟩ :=\n  iSup_psigma _\n\n"}
{"name":"Set.iUnion_psigma'","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : α → Type u_12\ns : (i : α) → γ i → Set β\n⊢ Eq (Set.iUnion fun i => Set.iUnion fun a => s i a) (Set.iUnion fun ia => s ia.fst ia.snd)","decl":"/-- A reversed version of `iUnion_psigma` with a curried map. -/\ntheorem iUnion_psigma' {γ : α → Type*} (s : ∀ i, γ i → Set β) :\n    ⋃ i, ⋃ a, s i a = ⋃ ia : PSigma γ, s ia.1 ia.2 :=\n  iSup_psigma' _\n\n"}
{"name":"Set.iInter_psigma","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : α → Type u_12\ns : PSigma γ → Set β\n⊢ Eq (Set.iInter fun ia => s ia) (Set.iInter fun i => Set.iInter fun a => s ⟨i, a⟩)","decl":"theorem iInter_psigma {γ : α → Type*} (s : PSigma γ → Set β) : ⋂ ia, s ia = ⋂ i, ⋂ a, s ⟨i, a⟩ :=\n  iInf_psigma _\n\n"}
{"name":"Set.iInter_psigma'","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : α → Type u_12\ns : (i : α) → γ i → Set β\n⊢ Eq (Set.iInter fun i => Set.iInter fun a => s i a) (Set.iInter fun ia => s ia.fst ia.snd)","decl":"/-- A reversed version of `iInter_psigma` with a curried map. -/\ntheorem iInter_psigma' {γ : α → Type*} (s : ∀ i, γ i → Set β) :\n    ⋂ i, ⋂ a, s i a = ⋂ ia : PSigma γ, s ia.1 ia.2 :=\n  iInf_psigma' _\n\n"}
{"name":"Set.mem_biUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : α → Set β\nx : α\ny : β\nxs : Membership.mem s x\nytx : Membership.mem (t x) y\n⊢ Membership.mem (Set.iUnion fun x => Set.iUnion fun h => t x) y","decl":"/-- A specialization of `mem_iUnion₂`. -/\ntheorem mem_biUnion {s : Set α} {t : α → Set β} {x : α} {y : β} (xs : x ∈ s) (ytx : y ∈ t x) :\n    y ∈ ⋃ x ∈ s, t x :=\n  mem_iUnion₂_of_mem xs ytx\n\n"}
{"name":"Set.mem_biInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : α → Set β\ny : β\nh : ∀ (x : α), Membership.mem s x → Membership.mem (t x) y\n⊢ Membership.mem (Set.iInter fun x => Set.iInter fun h => t x) y","decl":"/-- A specialization of `mem_iInter₂`. -/\ntheorem mem_biInter {s : Set α} {t : α → Set β} {y : β} (h : ∀ x ∈ s, y ∈ t x) :\n    y ∈ ⋂ x ∈ s, t x :=\n  mem_iInter₂_of_mem h\n\n"}
{"name":"Set.subset_biUnion_of_mem","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nu : α → Set β\nx : α\nxs : Membership.mem s x\n⊢ HasSubset.Subset (u x) (Set.iUnion fun x => Set.iUnion fun h => u x)","decl":"/-- A specialization of `subset_iUnion₂`. -/\ntheorem subset_biUnion_of_mem {s : Set α} {u : α → Set β} {x : α} (xs : x ∈ s) :\n    u x ⊆ ⋃ x ∈ s, u x :=\n-- Porting note: Why is this not just `subset_iUnion₂ x xs`?\n  @subset_iUnion₂ β α (· ∈ s) (fun i _ => u i) x xs\n\n"}
{"name":"Set.biInter_subset_of_mem","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : α → Set β\nx : α\nxs : Membership.mem s x\n⊢ HasSubset.Subset (Set.iInter fun x => Set.iInter fun h => t x) (t x)","decl":"/-- A specialization of `iInter₂_subset`. -/\ntheorem biInter_subset_of_mem {s : Set α} {t : α → Set β} {x : α} (xs : x ∈ s) :\n    ⋂ x ∈ s, t x ⊆ t x :=\n  iInter₂_subset x xs\n\n"}
{"name":"Set.biInter_subset_biUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nhs : s.Nonempty\nt : α → Set β\n⊢ HasSubset.Subset (Set.iInter fun x => Set.iInter fun h => t x) (Set.iUnion fun x => Set.iUnion fun h => t x)","decl":"lemma biInter_subset_biUnion {s : Set α} (hs : s.Nonempty) {t : α → Set β} :\n    ⋂ x ∈ s, t x ⊆ ⋃ x ∈ s, t x := biInf_le_biSup hs\n\n"}
{"name":"Set.biUnion_subset_biUnion_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns s' : Set α\nt : α → Set β\nh : HasSubset.Subset s s'\n⊢ HasSubset.Subset (Set.iUnion fun x => Set.iUnion fun h => t x) (Set.iUnion fun x => Set.iUnion fun h => t x)","decl":"theorem biUnion_subset_biUnion_left {s s' : Set α} {t : α → Set β} (h : s ⊆ s') :\n    ⋃ x ∈ s, t x ⊆ ⋃ x ∈ s', t x :=\n  iUnion₂_subset fun _ hx => subset_biUnion_of_mem <| h hx\n\n"}
{"name":"Set.biInter_subset_biInter_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns s' : Set α\nt : α → Set β\nh : HasSubset.Subset s' s\n⊢ HasSubset.Subset (Set.iInter fun x => Set.iInter fun h => t x) (Set.iInter fun x => Set.iInter fun h => t x)","decl":"theorem biInter_subset_biInter_left {s s' : Set α} {t : α → Set β} (h : s' ⊆ s) :\n    ⋂ x ∈ s, t x ⊆ ⋂ x ∈ s', t x :=\n  subset_iInter₂ fun _ hx => biInter_subset_of_mem <| h hx\n\n"}
{"name":"Set.biUnion_mono","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns s' : Set α\nt t' : α → Set β\nhs : HasSubset.Subset s' s\nh : ∀ (x : α), Membership.mem s x → HasSubset.Subset (t x) (t' x)\n⊢ HasSubset.Subset (Set.iUnion fun x => Set.iUnion fun h => t x) (Set.iUnion fun x => Set.iUnion fun h => t' x)","decl":"theorem biUnion_mono {s s' : Set α} {t t' : α → Set β} (hs : s' ⊆ s) (h : ∀ x ∈ s, t x ⊆ t' x) :\n    ⋃ x ∈ s', t x ⊆ ⋃ x ∈ s, t' x :=\n  (biUnion_subset_biUnion_left hs).trans <| iUnion₂_mono h\n\n"}
{"name":"Set.biInter_mono","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns s' : Set α\nt t' : α → Set β\nhs : HasSubset.Subset s s'\nh : ∀ (x : α), Membership.mem s x → HasSubset.Subset (t x) (t' x)\n⊢ HasSubset.Subset (Set.iInter fun x => Set.iInter fun h => t x) (Set.iInter fun x => Set.iInter fun h => t' x)","decl":"theorem biInter_mono {s s' : Set α} {t t' : α → Set β} (hs : s ⊆ s') (h : ∀ x ∈ s, t x ⊆ t' x) :\n    ⋂ x ∈ s', t x ⊆ ⋂ x ∈ s, t' x :=\n  (biInter_subset_biInter_left hs).trans <| iInter₂_mono h\n\n"}
{"name":"Set.biUnion_eq_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : (x : α) → Membership.mem s x → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => t x h) (Set.iUnion fun x => t ↑x ⋯)","decl":"theorem biUnion_eq_iUnion (s : Set α) (t : ∀ x ∈ s, Set β) :\n    ⋃ x ∈ s, t x ‹_› = ⋃ x : s, t x x.2 :=\n  iSup_subtype'\n\n"}
{"name":"Set.biInter_eq_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : (x : α) → Membership.mem s x → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => t x h) (Set.iInter fun x => t ↑x ⋯)","decl":"theorem biInter_eq_iInter (s : Set α) (t : ∀ x ∈ s, Set β) :\n    ⋂ x ∈ s, t x ‹_› = ⋂ x : s, t x x.2 :=\n  iInf_subtype'\n\n"}
{"name":"Set.biUnion_const","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nhs : s.Nonempty\nt : Set β\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => t) t","decl":"@[simp] lemma biUnion_const {s : Set α} (hs : s.Nonempty) (t : Set β) : ⋃ a ∈ s, t = t :=\n  biSup_const hs\n\n"}
{"name":"Set.biInter_const","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nhs : s.Nonempty\nt : Set β\n⊢ Eq (Set.iInter fun a => Set.iInter fun h => t) t","decl":"@[simp] lemma biInter_const {s : Set α} (hs : s.Nonempty) (t : Set β) : ⋂ a ∈ s, t = t :=\n  biInf_const hs\n\n"}
{"name":"Set.iUnion_subtype","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → Prop\ns : (Subtype fun x => p x) → Set β\n⊢ Eq (Set.iUnion fun x => s x) (Set.iUnion fun x => Set.iUnion fun hx => s ⟨x, hx⟩)","decl":"theorem iUnion_subtype (p : α → Prop) (s : { x // p x } → Set β) :\n    ⋃ x : { x // p x }, s x = ⋃ (x) (hx : p x), s ⟨x, hx⟩ :=\n  iSup_subtype\n\n"}
{"name":"Set.iInter_subtype","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → Prop\ns : (Subtype fun x => p x) → Set β\n⊢ Eq (Set.iInter fun x => s x) (Set.iInter fun x => Set.iInter fun hx => s ⟨x, hx⟩)","decl":"theorem iInter_subtype (p : α → Prop) (s : { x // p x } → Set β) :\n    ⋂ x : { x // p x }, s x = ⋂ (x) (hx : p x), s ⟨x, hx⟩ :=\n  iInf_subtype\n\n"}
{"name":"Set.biInter_empty","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nu : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => u x) Set.univ","decl":"theorem biInter_empty (u : α → Set β) : ⋂ x ∈ (∅ : Set α), u x = univ :=\n  iInf_emptyset\n\n"}
{"name":"Set.biInter_univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nu : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => u x) (Set.iInter fun x => u x)","decl":"theorem biInter_univ (u : α → Set β) : ⋂ x ∈ @univ α, u x = ⋂ x, u x :=\n  iInf_univ\n\n"}
{"name":"Set.biUnion_self","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => s) s","decl":"@[simp]\ntheorem biUnion_self (s : Set α) : ⋃ x ∈ s, s = s :=\n  Subset.antisymm (iUnion₂_subset fun _ _ => Subset.refl s) fun _ hx => mem_biUnion hx hx\n\n"}
{"name":"Set.iUnion_nonempty_self","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.iUnion fun x => s) s","decl":"@[simp]\ntheorem iUnion_nonempty_self (s : Set α) : ⋃ _ : s.Nonempty, s = s := by\n  rw [iUnion_nonempty_index, biUnion_self]\n\n"}
{"name":"Set.biInter_singleton","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\ns : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => s x) (s a)","decl":"theorem biInter_singleton (a : α) (s : α → Set β) : ⋂ x ∈ ({a} : Set α), s x = s a :=\n  iInf_singleton\n\n"}
{"name":"Set.biInter_union","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns t : Set α\nu : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => u x) (Inter.inter (Set.iInter fun x => Set.iInter fun h => u x) (Set.iInter fun x => Set.iInter fun h => u x))","decl":"theorem biInter_union (s t : Set α) (u : α → Set β) :\n    ⋂ x ∈ s ∪ t, u x = (⋂ x ∈ s, u x) ∩ ⋂ x ∈ t, u x :=\n  iInf_union\n\n"}
{"name":"Set.biInter_insert","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\ns : Set α\nt : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => t x) (Inter.inter (t a) (Set.iInter fun x => Set.iInter fun h => t x))","decl":"theorem biInter_insert (a : α) (s : Set α) (t : α → Set β) :\n    ⋂ x ∈ insert a s, t x = t a ∩ ⋂ x ∈ s, t x := by simp\n\n"}
{"name":"Set.biInter_pair","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\na b : α\ns : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => s x) (Inter.inter (s a) (s b))","decl":"theorem biInter_pair (a b : α) (s : α → Set β) : ⋂ x ∈ ({a, b} : Set α), s x = s a ∩ s b := by\n  rw [biInter_insert, biInter_singleton]\n\n"}
{"name":"Set.biInter_inter","module":"Mathlib.Data.Set.Lattice","initialProofState":"ι : Type u_12\nα : Type u_13\ns : Set ι\nhs : s.Nonempty\nf : ι → Set α\nt : Set α\n⊢ Eq (Set.iInter fun i => Set.iInter fun h => Inter.inter (f i) t) (Inter.inter (Set.iInter fun i => Set.iInter fun h => f i) t)","decl":"theorem biInter_inter {ι α : Type*} {s : Set ι} (hs : s.Nonempty) (f : ι → Set α) (t : Set α) :\n    ⋂ i ∈ s, f i ∩ t = (⋂ i ∈ s, f i) ∩ t := by\n  haveI : Nonempty s := hs.to_subtype\n  simp [biInter_eq_iInter, ← iInter_inter]\n\n"}
{"name":"Set.inter_biInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"ι : Type u_12\nα : Type u_13\ns : Set ι\nhs : s.Nonempty\nf : ι → Set α\nt : Set α\n⊢ Eq (Set.iInter fun i => Set.iInter fun h => Inter.inter t (f i)) (Inter.inter t (Set.iInter fun i => Set.iInter fun h => f i))","decl":"theorem inter_biInter {ι α : Type*} {s : Set ι} (hs : s.Nonempty) (f : ι → Set α) (t : Set α) :\n    ⋂ i ∈ s, t ∩ f i = t ∩ ⋂ i ∈ s, f i := by\n  rw [inter_comm, ← biInter_inter hs]\n  simp [inter_comm]\n\n"}
{"name":"Set.biUnion_empty","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => s x) EmptyCollection.emptyCollection","decl":"theorem biUnion_empty (s : α → Set β) : ⋃ x ∈ (∅ : Set α), s x = ∅ :=\n  iSup_emptyset\n\n"}
{"name":"Set.biUnion_univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => s x) (Set.iUnion fun x => s x)","decl":"theorem biUnion_univ (s : α → Set β) : ⋃ x ∈ @univ α, s x = ⋃ x, s x :=\n  iSup_univ\n\n"}
{"name":"Set.biUnion_singleton","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\ns : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => s x) (s a)","decl":"theorem biUnion_singleton (a : α) (s : α → Set β) : ⋃ x ∈ ({a} : Set α), s x = s a :=\n  iSup_singleton\n\n"}
{"name":"Set.biUnion_of_singleton","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => Singleton.singleton x) s","decl":"@[simp]\ntheorem biUnion_of_singleton (s : Set α) : ⋃ x ∈ s, {x} = s :=\n  ext <| by simp\n\n"}
{"name":"Set.biUnion_union","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns t : Set α\nu : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => u x) (Union.union (Set.iUnion fun x => Set.iUnion fun h => u x) (Set.iUnion fun x => Set.iUnion fun h => u x))","decl":"theorem biUnion_union (s t : Set α) (u : α → Set β) :\n    ⋃ x ∈ s ∪ t, u x = (⋃ x ∈ s, u x) ∪ ⋃ x ∈ t, u x :=\n  iSup_union\n\n"}
{"name":"Set.iUnion_coe_set","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_12\nβ : Type u_13\ns : Set α\nf : ↑s → Set β\n⊢ Eq (Set.iUnion fun i => f i) (Set.iUnion fun i => Set.iUnion fun h => f ⟨i, ⋯⟩)","decl":"@[simp]\ntheorem iUnion_coe_set {α β : Type*} (s : Set α) (f : s → Set β) :\n    ⋃ i, f i = ⋃ i ∈ s, f ⟨i, ‹i ∈ s›⟩ :=\n  iUnion_subtype _ _\n\n"}
{"name":"Set.iInter_coe_set","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_12\nβ : Type u_13\ns : Set α\nf : ↑s → Set β\n⊢ Eq (Set.iInter fun i => f i) (Set.iInter fun i => Set.iInter fun h => f ⟨i, ⋯⟩)","decl":"@[simp]\ntheorem iInter_coe_set {α β : Type*} (s : Set α) (f : s → Set β) :\n    ⋂ i, f i = ⋂ i ∈ s, f ⟨i, ‹i ∈ s›⟩ :=\n  iInter_subtype _ _\n\n"}
{"name":"Set.biUnion_insert","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\ns : Set α\nt : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => t x) (Union.union (t a) (Set.iUnion fun x => Set.iUnion fun h => t x))","decl":"theorem biUnion_insert (a : α) (s : Set α) (t : α → Set β) :\n    ⋃ x ∈ insert a s, t x = t a ∪ ⋃ x ∈ s, t x := by simp\n\n"}
{"name":"Set.biUnion_pair","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\na b : α\ns : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => s x) (Union.union (s a) (s b))","decl":"theorem biUnion_pair (a b : α) (s : α → Set β) : ⋃ x ∈ ({a, b} : Set α), s x = s a ∪ s b := by\n  simp\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.inter_iUnion₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : Set α\nt : (i : ι) → κ i → Set α\n⊢ Eq (Inter.inter s (Set.iUnion fun i => Set.iUnion fun j => t i j)) (Set.iUnion fun i => Set.iUnion fun j => Inter.inter s (t i j))","decl":"theorem inter_iUnion₂ (s : Set α) (t : ∀ i, κ i → Set α) :\n    (s ∩ ⋃ (i) (j), t i j) = ⋃ (i) (j), s ∩ t i j := by simp only [inter_iUnion]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iUnion₂_inter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\nt : Set α\n⊢ Eq (Inter.inter (Set.iUnion fun i => Set.iUnion fun j => s i j) t) (Set.iUnion fun i => Set.iUnion fun j => Inter.inter (s i j) t)","decl":"theorem iUnion₂_inter (s : ∀ i, κ i → Set α) (t : Set α) :\n    (⋃ (i) (j), s i j) ∩ t = ⋃ (i) (j), s i j ∩ t := by simp_rw [iUnion_inter]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.union_iInter₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : Set α\nt : (i : ι) → κ i → Set α\n⊢ Eq (Union.union s (Set.iInter fun i => Set.iInter fun j => t i j)) (Set.iInter fun i => Set.iInter fun j => Union.union s (t i j))","decl":"theorem union_iInter₂ (s : Set α) (t : ∀ i, κ i → Set α) :\n    (s ∪ ⋂ (i) (j), t i j) = ⋂ (i) (j), s ∪ t i j := by simp_rw [union_iInter]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iInter₂_union","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\nt : Set α\n⊢ Eq (Union.union (Set.iInter fun i => Set.iInter fun j => s i j) t) (Set.iInter fun i => Set.iInter fun j => Union.union (s i j) t)","decl":"theorem iInter₂_union (s : ∀ i, κ i → Set α) (t : Set α) :\n    (⋂ (i) (j), s i j) ∪ t = ⋂ (i) (j), s i j ∪ t := by simp_rw [iInter_union]\n\n"}
{"name":"Set.mem_sUnion_of_mem","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nx : α\nt : Set α\nS : Set (Set α)\nhx : Membership.mem t x\nht : Membership.mem S t\n⊢ Membership.mem S.sUnion x","decl":"theorem mem_sUnion_of_mem {x : α} {t : Set α} {S : Set (Set α)} (hx : x ∈ t) (ht : t ∈ S) :\n    x ∈ ⋃₀ S :=\n  ⟨t, ht, hx⟩\n\n-- is this theorem really necessary?\n"}
{"name":"Set.not_mem_of_not_mem_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nx : α\nt : Set α\nS : Set (Set α)\nhx : Not (Membership.mem S.sUnion x)\nht : Membership.mem S t\n⊢ Not (Membership.mem t x)","decl":"theorem not_mem_of_not_mem_sUnion {x : α} {t : Set α} {S : Set (Set α)} (hx : x ∉ ⋃₀ S)\n    (ht : t ∈ S) : x ∉ t := fun h => hx ⟨t, ht, h⟩\n\n"}
{"name":"Set.sInter_subset_of_mem","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\nt : Set α\ntS : Membership.mem S t\n⊢ HasSubset.Subset S.sInter t","decl":"theorem sInter_subset_of_mem {S : Set (Set α)} {t : Set α} (tS : t ∈ S) : ⋂₀ S ⊆ t :=\n  sInf_le tS\n\n"}
{"name":"Set.subset_sUnion_of_mem","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\nt : Set α\ntS : Membership.mem S t\n⊢ HasSubset.Subset t S.sUnion","decl":"theorem subset_sUnion_of_mem {S : Set (Set α)} {t : Set α} (tS : t ∈ S) : t ⊆ ⋃₀ S :=\n  le_sSup tS\n\n"}
{"name":"Set.subset_sUnion_of_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set α\nt : Set (Set α)\nu : Set α\nh₁ : HasSubset.Subset s u\nh₂ : Membership.mem t u\n⊢ HasSubset.Subset s t.sUnion","decl":"theorem subset_sUnion_of_subset {s : Set α} (t : Set (Set α)) (u : Set α) (h₁ : s ⊆ u)\n    (h₂ : u ∈ t) : s ⊆ ⋃₀ t :=\n  Subset.trans h₁ (subset_sUnion_of_mem h₂)\n\n"}
{"name":"Set.sUnion_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\nt : Set α\nh : ∀ (t' : Set α), Membership.mem S t' → HasSubset.Subset t' t\n⊢ HasSubset.Subset S.sUnion t","decl":"theorem sUnion_subset {S : Set (Set α)} {t : Set α} (h : ∀ t' ∈ S, t' ⊆ t) : ⋃₀ S ⊆ t :=\n  sSup_le h\n\n"}
{"name":"Set.sUnion_subset_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set (Set α)\nt : Set α\n⊢ Iff (HasSubset.Subset s.sUnion t) (∀ (t' : Set α), Membership.mem s t' → HasSubset.Subset t' t)","decl":"@[simp]\ntheorem sUnion_subset_iff {s : Set (Set α)} {t : Set α} : ⋃₀ s ⊆ t ↔ ∀ t' ∈ s, t' ⊆ t :=\n  sSup_le_iff\n\n"}
{"name":"Set.sUnion_mono_subsets","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set (Set α)\nf : Set α → Set α\nhf : ∀ (t : Set α), HasSubset.Subset t (f t)\n⊢ HasSubset.Subset s.sUnion (Set.image f s).sUnion","decl":"/-- `sUnion` is monotone under taking a subset of each set. -/\nlemma sUnion_mono_subsets {s : Set (Set α)} {f : Set α → Set α} (hf : ∀ t : Set α, t ⊆ f t) :\n    ⋃₀ s ⊆ ⋃₀ (f '' s) :=\n  fun _ ⟨t, htx, hxt⟩ ↦ ⟨f t, mem_image_of_mem f htx, hf t hxt⟩\n\n"}
{"name":"Set.sUnion_mono_supsets","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set (Set α)\nf : Set α → Set α\nhf : ∀ (t : Set α), HasSubset.Subset (f t) t\n⊢ HasSubset.Subset (Set.image f s).sUnion s.sUnion","decl":"/-- `sUnion` is monotone under taking a superset of each set. -/\nlemma sUnion_mono_supsets {s : Set (Set α)} {f : Set α → Set α} (hf : ∀ t : Set α, f t ⊆ t) :\n    ⋃₀ (f '' s) ⊆ ⋃₀ s :=\n  -- If t ∈ f '' s is arbitrary; t = f u for some u : Set α.\n  fun _ ⟨_, ⟨u, hus, hut⟩, hxt⟩ ↦ ⟨u, hus, (hut ▸ hf u) hxt⟩\n\n"}
{"name":"Set.subset_sInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\nt : Set α\nh : ∀ (t' : Set α), Membership.mem S t' → HasSubset.Subset t t'\n⊢ HasSubset.Subset t S.sInter","decl":"theorem subset_sInter {S : Set (Set α)} {t : Set α} (h : ∀ t' ∈ S, t ⊆ t') : t ⊆ ⋂₀ S :=\n  le_sInf h\n\n"}
{"name":"Set.subset_sInter_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\nt : Set α\n⊢ Iff (HasSubset.Subset t S.sInter) (∀ (t' : Set α), Membership.mem S t' → HasSubset.Subset t t')","decl":"@[simp]\ntheorem subset_sInter_iff {S : Set (Set α)} {t : Set α} : t ⊆ ⋂₀ S ↔ ∀ t' ∈ S, t ⊆ t' :=\n  le_sInf_iff\n\n"}
{"name":"Set.sUnion_subset_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS T : Set (Set α)\nh : HasSubset.Subset S T\n⊢ HasSubset.Subset S.sUnion T.sUnion","decl":"@[gcongr]\ntheorem sUnion_subset_sUnion {S T : Set (Set α)} (h : S ⊆ T) : ⋃₀ S ⊆ ⋃₀ T :=\n  sUnion_subset fun _ hs => subset_sUnion_of_mem (h hs)\n\n"}
{"name":"Set.sInter_subset_sInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS T : Set (Set α)\nh : HasSubset.Subset S T\n⊢ HasSubset.Subset T.sInter S.sInter","decl":"@[gcongr]\ntheorem sInter_subset_sInter {S T : Set (Set α)} (h : S ⊆ T) : ⋂₀ T ⊆ ⋂₀ S :=\n  subset_sInter fun _ hs => sInter_subset_of_mem (h hs)\n\n"}
{"name":"Set.sUnion_empty","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\n⊢ Eq EmptyCollection.emptyCollection.sUnion EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem sUnion_empty : ⋃₀ ∅ = (∅ : Set α) :=\n  sSup_empty\n\n"}
{"name":"Set.sInter_empty","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\n⊢ Eq EmptyCollection.emptyCollection.sInter Set.univ","decl":"@[simp]\ntheorem sInter_empty : ⋂₀ ∅ = (univ : Set α) :=\n  sInf_empty\n\n"}
{"name":"Set.sUnion_singleton","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Singleton.singleton s).sUnion s","decl":"@[simp]\ntheorem sUnion_singleton (s : Set α) : ⋃₀ {s} = s :=\n  sSup_singleton\n\n"}
{"name":"Set.sInter_singleton","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Singleton.singleton s).sInter s","decl":"@[simp]\ntheorem sInter_singleton (s : Set α) : ⋂₀ {s} = s :=\n  sInf_singleton\n\n"}
{"name":"Set.sUnion_eq_empty","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\n⊢ Iff (Eq S.sUnion EmptyCollection.emptyCollection) (∀ (s : Set α), Membership.mem S s → Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem sUnion_eq_empty {S : Set (Set α)} : ⋃₀ S = ∅ ↔ ∀ s ∈ S, s = ∅ :=\n  sSup_eq_bot\n\n"}
{"name":"Set.sInter_eq_univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\n⊢ Iff (Eq S.sInter Set.univ) (∀ (s : Set α), Membership.mem S s → Eq s Set.univ)","decl":"@[simp]\ntheorem sInter_eq_univ {S : Set (Set α)} : ⋂₀ S = univ ↔ ∀ s ∈ S, s = univ :=\n  sInf_eq_top\n\n"}
{"name":"Set.subset_powerset_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set (Set α)\nt : Set α\n⊢ Iff (HasSubset.Subset s t.powerset) (HasSubset.Subset s.sUnion t)","decl":"theorem subset_powerset_iff {s : Set (Set α)} {t : Set α} : s ⊆ 𝒫 t ↔ ⋃₀ s ⊆ t :=\n  sUnion_subset_iff.symm\n\n"}
{"name":"Set.sUnion_powerset_gc","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\n⊢ GaloisConnection (fun x => x.sUnion) fun x => x.powerset","decl":"/-- `⋃₀` and `𝒫` form a Galois connection. -/\ntheorem sUnion_powerset_gc :\n    GaloisConnection (⋃₀ · : Set (Set α) → Set α) (𝒫 · : Set α → Set (Set α)) :=\n  gc_sSup_Iic\n\n"}
{"name":"Set.sUnion_mem_empty_univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\nh : HasSubset.Subset S (Insert.insert EmptyCollection.emptyCollection (Singleton.singleton Set.univ))\n⊢ Membership.mem (Insert.insert EmptyCollection.emptyCollection (Singleton.singleton Set.univ)) S.sUnion","decl":"/-- If all sets in a collection are either `∅` or `Set.univ`, then so is their union. -/\ntheorem sUnion_mem_empty_univ {S : Set (Set α)} (h : S ⊆ {∅, univ}) :\n    ⋃₀ S ∈ ({∅, univ} : Set (Set α)) := by\n  simp only [mem_insert_iff, mem_singleton_iff, or_iff_not_imp_left, sUnion_eq_empty, not_forall]\n  rintro ⟨s, hs, hne⟩\n  obtain rfl : s = univ := (h hs).resolve_left hne\n  exact univ_subset_iff.1 <| subset_sUnion_of_mem hs\n\n"}
{"name":"Set.nonempty_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\n⊢ Iff S.sUnion.Nonempty (Exists fun s => And (Membership.mem S s) s.Nonempty)","decl":"@[simp]\ntheorem nonempty_sUnion {S : Set (Set α)} : (⋃₀ S).Nonempty ↔ ∃ s ∈ S, Set.Nonempty s := by\n  simp [nonempty_iff_ne_empty]\n\n"}
{"name":"Set.Nonempty.of_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set (Set α)\nh : s.sUnion.Nonempty\n⊢ s.Nonempty","decl":"theorem Nonempty.of_sUnion {s : Set (Set α)} (h : (⋃₀ s).Nonempty) : s.Nonempty :=\n  let ⟨s, hs, _⟩ := nonempty_sUnion.1 h\n  ⟨s, hs⟩\n\n"}
{"name":"Set.Nonempty.of_sUnion_eq_univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\ns : Set (Set α)\nh : Eq s.sUnion Set.univ\n⊢ s.Nonempty","decl":"theorem Nonempty.of_sUnion_eq_univ [Nonempty α] {s : Set (Set α)} (h : ⋃₀ s = univ) : s.Nonempty :=\n  Nonempty.of_sUnion <| h.symm ▸ univ_nonempty\n\n"}
{"name":"Set.sUnion_union","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS T : Set (Set α)\n⊢ Eq (Union.union S T).sUnion (Union.union S.sUnion T.sUnion)","decl":"theorem sUnion_union (S T : Set (Set α)) : ⋃₀ (S ∪ T) = ⋃₀ S ∪ ⋃₀ T :=\n  sSup_union\n\n"}
{"name":"Set.sInter_union","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS T : Set (Set α)\n⊢ Eq (Union.union S T).sInter (Inter.inter S.sInter T.sInter)","decl":"theorem sInter_union (S T : Set (Set α)) : ⋂₀ (S ∪ T) = ⋂₀ S ∩ ⋂₀ T :=\n  sInf_union\n\n"}
{"name":"Set.sUnion_insert","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set α\nT : Set (Set α)\n⊢ Eq (Insert.insert s T).sUnion (Union.union s T.sUnion)","decl":"@[simp]\ntheorem sUnion_insert (s : Set α) (T : Set (Set α)) : ⋃₀ insert s T = s ∪ ⋃₀ T :=\n  sSup_insert\n\n"}
{"name":"Set.sInter_insert","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set α\nT : Set (Set α)\n⊢ Eq (Insert.insert s T).sInter (Inter.inter s T.sInter)","decl":"@[simp]\ntheorem sInter_insert (s : Set α) (T : Set (Set α)) : ⋂₀ insert s T = s ∩ ⋂₀ T :=\n  sInf_insert\n\n"}
{"name":"Set.sUnion_diff_singleton_empty","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set (Set α)\n⊢ Eq (SDiff.sdiff s (Singleton.singleton EmptyCollection.emptyCollection)).sUnion s.sUnion","decl":"@[simp]\ntheorem sUnion_diff_singleton_empty (s : Set (Set α)) : ⋃₀ (s \\ {∅}) = ⋃₀ s :=\n  sSup_diff_singleton_bot s\n\n"}
{"name":"Set.sInter_diff_singleton_univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set (Set α)\n⊢ Eq (SDiff.sdiff s (Singleton.singleton Set.univ)).sInter s.sInter","decl":"@[simp]\ntheorem sInter_diff_singleton_univ (s : Set (Set α)) : ⋂₀ (s \\ {univ}) = ⋂₀ s :=\n  sInf_diff_singleton_top s\n\n"}
{"name":"Set.sUnion_pair","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Eq (Insert.insert s (Singleton.singleton t)).sUnion (Union.union s t)","decl":"theorem sUnion_pair (s t : Set α) : ⋃₀ {s, t} = s ∪ t :=\n  sSup_pair\n\n"}
{"name":"Set.sInter_pair","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Eq (Insert.insert s (Singleton.singleton t)).sInter (Inter.inter s t)","decl":"theorem sInter_pair (s t : Set α) : ⋂₀ {s, t} = s ∩ t :=\n  sInf_pair\n\n"}
{"name":"Set.sUnion_image","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → Set β\ns : Set α\n⊢ Eq (Set.image f s).sUnion (Set.iUnion fun a => Set.iUnion fun h => f a)","decl":"@[simp]\ntheorem sUnion_image (f : α → Set β) (s : Set α) : ⋃₀ (f '' s) = ⋃ a ∈ s, f a :=\n  sSup_image\n\n"}
{"name":"Set.sInter_image","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → Set β\ns : Set α\n⊢ Eq (Set.image f s).sInter (Set.iInter fun a => Set.iInter fun h => f a)","decl":"@[simp]\ntheorem sInter_image (f : α → Set β) (s : Set α) : ⋂₀ (f '' s) = ⋂ a ∈ s, f a :=\n  sInf_image\n\n"}
{"name":"Set.sUnion_image2","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → Set γ\ns : Set α\nt : Set β\n⊢ Eq (Set.image2 f s t).sUnion (Set.iUnion fun a => Set.iUnion fun h => Set.iUnion fun b => Set.iUnion fun h => f a b)","decl":"@[simp]\nlemma sUnion_image2 (f : α → β → Set γ) (s : Set α) (t : Set β) :\n    ⋃₀ (image2 f s t) = ⋃ (a ∈ s) (b ∈ t), f a b := sSup_image2\n\n"}
{"name":"Set.sInter_image2","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → Set γ\ns : Set α\nt : Set β\n⊢ Eq (Set.image2 f s t).sInter (Set.iInter fun a => Set.iInter fun h => Set.iInter fun b => Set.iInter fun h => f a b)","decl":"@[simp]\nlemma sInter_image2 (f : α → β → Set γ) (s : Set α) (t : Set β) :\n    ⋂₀ (image2 f s t) = ⋂ (a ∈ s) (b ∈ t), f a b := sInf_image2\n\n"}
{"name":"Set.sUnion_range","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\nf : ι → Set β\n⊢ Eq (Set.range f).sUnion (Set.iUnion fun x => f x)","decl":"@[simp]\ntheorem sUnion_range (f : ι → Set β) : ⋃₀ range f = ⋃ x, f x :=\n  rfl\n\n"}
{"name":"Set.sInter_range","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\nf : ι → Set β\n⊢ Eq (Set.range f).sInter (Set.iInter fun x => f x)","decl":"@[simp]\ntheorem sInter_range (f : ι → Set β) : ⋂₀ range f = ⋂ x, f x :=\n  rfl\n\n"}
{"name":"Set.iUnion_eq_univ_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nf : ι → Set α\n⊢ Iff (Eq (Set.iUnion fun i => f i) Set.univ) (∀ (x : α), Exists fun i => Membership.mem (f i) x)","decl":"theorem iUnion_eq_univ_iff {f : ι → Set α} : ⋃ i, f i = univ ↔ ∀ x, ∃ i, x ∈ f i := by\n  simp only [eq_univ_iff_forall, mem_iUnion]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iUnion₂_eq_univ_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\n⊢ Iff (Eq (Set.iUnion fun i => Set.iUnion fun j => s i j) Set.univ) (∀ (a : α), Exists fun i => Exists fun j => Membership.mem (s i j) a)","decl":"theorem iUnion₂_eq_univ_iff {s : ∀ i, κ i → Set α} :\n    ⋃ (i) (j), s i j = univ ↔ ∀ a, ∃ i j, a ∈ s i j := by\n  simp only [iUnion_eq_univ_iff, mem_iUnion]\n\n"}
{"name":"Set.sUnion_eq_univ_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nc : Set (Set α)\n⊢ Iff (Eq c.sUnion Set.univ) (∀ (a : α), Exists fun b => And (Membership.mem c b) (Membership.mem b a))","decl":"theorem sUnion_eq_univ_iff {c : Set (Set α)} : ⋃₀ c = univ ↔ ∀ a, ∃ b ∈ c, a ∈ b := by\n  simp only [eq_univ_iff_forall, mem_sUnion]\n\n-- classical\n"}
{"name":"Set.iInter_eq_empty_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nf : ι → Set α\n⊢ Iff (Eq (Set.iInter fun i => f i) EmptyCollection.emptyCollection) (∀ (x : α), Exists fun i => Not (Membership.mem (f i) x))","decl":"theorem iInter_eq_empty_iff {f : ι → Set α} : ⋂ i, f i = ∅ ↔ ∀ x, ∃ i, x ∉ f i := by\n  simp [Set.eq_empty_iff_forall_not_mem]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n-- classical\n"}
{"name":"Set.iInter₂_eq_empty_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\n⊢ Iff (Eq (Set.iInter fun i => Set.iInter fun j => s i j) EmptyCollection.emptyCollection) (∀ (a : α), Exists fun i => Exists fun j => Not (Membership.mem (s i j) a))","decl":"theorem iInter₂_eq_empty_iff {s : ∀ i, κ i → Set α} :\n    ⋂ (i) (j), s i j = ∅ ↔ ∀ a, ∃ i j, a ∉ s i j := by\n  simp only [eq_empty_iff_forall_not_mem, mem_iInter, not_forall]\n\n-- classical\n"}
{"name":"Set.sInter_eq_empty_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nc : Set (Set α)\n⊢ Iff (Eq c.sInter EmptyCollection.emptyCollection) (∀ (a : α), Exists fun b => And (Membership.mem c b) (Not (Membership.mem b a)))","decl":"theorem sInter_eq_empty_iff {c : Set (Set α)} : ⋂₀ c = ∅ ↔ ∀ a, ∃ b ∈ c, a ∉ b := by\n  simp [Set.eq_empty_iff_forall_not_mem]\n\n-- classical\n"}
{"name":"Set.nonempty_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nf : ι → Set α\n⊢ Iff (Set.iInter fun i => f i).Nonempty (Exists fun x => ∀ (i : ι), Membership.mem (f i) x)","decl":"@[simp]\ntheorem nonempty_iInter {f : ι → Set α} : (⋂ i, f i).Nonempty ↔ ∃ x, ∀ i, x ∈ f i := by\n  simp [nonempty_iff_ne_empty, iInter_eq_empty_iff]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n-- classical\n"}
{"name":"Set.nonempty_iInter₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\n⊢ Iff (Set.iInter fun i => Set.iInter fun j => s i j).Nonempty (Exists fun a => ∀ (i : ι) (j : κ i), Membership.mem (s i j) a)","decl":"theorem nonempty_iInter₂ {s : ∀ i, κ i → Set α} :\n    (⋂ (i) (j), s i j).Nonempty ↔ ∃ a, ∀ i j, a ∈ s i j := by\n  simp\n\n-- classical\n"}
{"name":"Set.nonempty_sInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nc : Set (Set α)\n⊢ Iff c.sInter.Nonempty (Exists fun a => ∀ (b : Set α), Membership.mem c b → Membership.mem b a)","decl":"@[simp]\ntheorem nonempty_sInter {c : Set (Set α)} : (⋂₀ c).Nonempty ↔ ∃ a, ∀ b ∈ c, a ∈ b := by\n  simp [nonempty_iff_ne_empty, sInter_eq_empty_iff]\n\n-- classical\n"}
{"name":"Set.compl_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\n⊢ Eq (HasCompl.compl S.sUnion) (Set.image HasCompl.compl S).sInter","decl":"theorem compl_sUnion (S : Set (Set α)) : (⋃₀ S)ᶜ = ⋂₀ (compl '' S) :=\n  ext fun x => by simp\n\n-- classical\n"}
{"name":"Set.sUnion_eq_compl_sInter_compl","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\n⊢ Eq S.sUnion (HasCompl.compl (Set.image HasCompl.compl S).sInter)","decl":"theorem sUnion_eq_compl_sInter_compl (S : Set (Set α)) : ⋃₀ S = (⋂₀ (compl '' S))ᶜ := by\n  rw [← compl_compl (⋃₀ S), compl_sUnion]\n\n-- classical\n"}
{"name":"Set.compl_sInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\n⊢ Eq (HasCompl.compl S.sInter) (Set.image HasCompl.compl S).sUnion","decl":"theorem compl_sInter (S : Set (Set α)) : (⋂₀ S)ᶜ = ⋃₀ (compl '' S) := by\n  rw [sUnion_eq_compl_sInter_compl, compl_compl_image]\n\n-- classical\n"}
{"name":"Set.sInter_eq_compl_sUnion_compl","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\n⊢ Eq S.sInter (HasCompl.compl (Set.image HasCompl.compl S).sUnion)","decl":"theorem sInter_eq_compl_sUnion_compl (S : Set (Set α)) : ⋂₀ S = (⋃₀ (compl '' S))ᶜ := by\n  rw [← compl_compl (⋂₀ S), compl_sInter]\n\n"}
{"name":"Set.inter_empty_of_inter_sUnion_empty","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns t : Set α\nS : Set (Set α)\nhs : Membership.mem S t\nh : Eq (Inter.inter s S.sUnion) EmptyCollection.emptyCollection\n⊢ Eq (Inter.inter s t) EmptyCollection.emptyCollection","decl":"theorem inter_empty_of_inter_sUnion_empty {s t : Set α} {S : Set (Set α)} (hs : t ∈ S)\n    (h : s ∩ ⋃₀ S = ∅) : s ∩ t = ∅ :=\n  eq_empty_of_subset_empty <| by\n    rw [← h]; exact inter_subset_inter_right _ (subset_sUnion_of_mem hs)\n\n"}
{"name":"Set.range_sigma_eq_iUnion_range","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : α → Type u_12\nf : Sigma γ → β\n⊢ Eq (Set.range f) (Set.iUnion fun a => Set.range fun b => f ⟨a, b⟩)","decl":"theorem range_sigma_eq_iUnion_range {γ : α → Type*} (f : Sigma γ → β) :\n    range f = ⋃ a, range fun b => f ⟨a, b⟩ :=\n  Set.ext <| by simp\n\n"}
{"name":"Set.iUnion_eq_range_sigma","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : α → Set β\n⊢ Eq (Set.iUnion fun i => s i) (Set.range fun a => ↑a.snd)","decl":"theorem iUnion_eq_range_sigma (s : α → Set β) : ⋃ i, s i = range fun a : Σi, s i => a.2 := by\n  simp [Set.ext_iff]\n\n"}
{"name":"Set.iUnion_eq_range_psigma","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ns : ι → Set β\n⊢ Eq (Set.iUnion fun i => s i) (Set.range fun a => ↑a.snd)","decl":"theorem iUnion_eq_range_psigma (s : ι → Set β) : ⋃ i, s i = range fun a : Σ'i, s i => a.2 := by\n  simp [Set.ext_iff]\n\n"}
{"name":"Set.iUnion_image_preimage_sigma_mk_eq_self","module":"Mathlib.Data.Set.Lattice","initialProofState":"ι : Type u_12\nσ : ι → Type u_13\ns : Set (Sigma σ)\n⊢ Eq (Set.iUnion fun i => Set.image (Sigma.mk i) (Set.preimage (Sigma.mk i) s)) s","decl":"theorem iUnion_image_preimage_sigma_mk_eq_self {ι : Type*} {σ : ι → Type*} (s : Set (Sigma σ)) :\n    ⋃ i, Sigma.mk i '' (Sigma.mk i ⁻¹' s) = s := by\n  ext x\n  simp only [mem_iUnion, mem_image, mem_preimage]\n  constructor\n  · rintro ⟨i, a, h, rfl⟩\n    exact h\n  · intro h\n    cases' x with i a\n    exact ⟨i, a, h, rfl⟩\n\n"}
{"name":"Set.Sigma.univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nX : α → Type u_12\n⊢ Eq Set.univ (Set.iUnion fun a => Set.range (Sigma.mk a))","decl":"theorem Sigma.univ (X : α → Type*) : (Set.univ : Set (Σa, X a)) = ⋃ a, range (Sigma.mk a) :=\n  Set.ext fun x =>\n    iff_of_true trivial ⟨range (Sigma.mk x.1), Set.mem_range_self _, x.2, Sigma.eta x⟩\n\n"}
{"name":"Set.sUnion_mono","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS T : Set (Set α)\nh : HasSubset.Subset S T\n⊢ HasSubset.Subset S.sUnion T.sUnion","decl":"alias sUnion_mono := sUnion_subset_sUnion\n\n"}
{"name":"Set.sInter_mono","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS T : Set (Set α)\nh : HasSubset.Subset S T\n⊢ HasSubset.Subset T.sInter S.sInter","decl":"alias sInter_mono := sInter_subset_sInter\n\n"}
{"name":"Set.iUnion_subset_iUnion_const","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι₂ : Sort u_7\ns : Set α\nh : ι → ι₂\n⊢ HasSubset.Subset (Set.iUnion fun x => s) (Set.iUnion fun x => s)","decl":"theorem iUnion_subset_iUnion_const {s : Set α} (h : ι → ι₂) : ⋃ _ : ι, s ⊆ ⋃ _ : ι₂, s :=\n  iSup_const_mono (α := Set α) h\n\n"}
{"name":"Set.iUnion_singleton_eq_range","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_12\nβ : Type u_13\nf : α → β\n⊢ Eq (Set.iUnion fun x => Singleton.singleton (f x)) (Set.range f)","decl":"@[simp]\ntheorem iUnion_singleton_eq_range {α β : Type*} (f : α → β) : ⋃ x : α, {f x} = range f := by\n  ext x\n  simp [@eq_comm _ x]\n\n"}
{"name":"Set.iUnion_of_singleton","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_12\n⊢ Eq (Set.iUnion fun x => Singleton.singleton x) Set.univ","decl":"theorem iUnion_of_singleton (α : Type*) : (⋃ x, {x} : Set α) = univ := by simp [Set.ext_iff]\n\n"}
{"name":"Set.iUnion_of_singleton_coe","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Set.iUnion fun i => Singleton.singleton ↑i) s","decl":"theorem iUnion_of_singleton_coe (s : Set α) : ⋃ i : s, ({(i : α)} : Set α) = s := by simp\n\n"}
{"name":"Set.sUnion_eq_biUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set (Set α)\n⊢ Eq s.sUnion (Set.iUnion fun i => Set.iUnion fun x => i)","decl":"theorem sUnion_eq_biUnion {s : Set (Set α)} : ⋃₀ s = ⋃ (i : Set α) (_ : i ∈ s), i := by\n  rw [← sUnion_image, image_id']\n\n"}
{"name":"Set.sInter_eq_biInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set (Set α)\n⊢ Eq s.sInter (Set.iInter fun i => Set.iInter fun x => i)","decl":"theorem sInter_eq_biInter {s : Set (Set α)} : ⋂₀ s = ⋂ (i : Set α) (_ : i ∈ s), i := by\n  rw [← sInter_image, image_id']\n\n"}
{"name":"Set.sUnion_eq_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set (Set α)\n⊢ Eq s.sUnion (Set.iUnion fun i => ↑i)","decl":"theorem sUnion_eq_iUnion {s : Set (Set α)} : ⋃₀ s = ⋃ i : s, i := by\n  simp only [← sUnion_range, Subtype.range_coe]\n\n"}
{"name":"Set.sInter_eq_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set (Set α)\n⊢ Eq s.sInter (Set.iInter fun i => ↑i)","decl":"theorem sInter_eq_iInter {s : Set (Set α)} : ⋂₀ s = ⋂ i : s, i := by\n  simp only [← sInter_range, Subtype.range_coe]\n\n"}
{"name":"Set.iUnion_of_empty","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ninst✝ : IsEmpty ι\ns : ι → Set α\n⊢ Eq (Set.iUnion fun i => s i) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem iUnion_of_empty [IsEmpty ι] (s : ι → Set α) : ⋃ i, s i = ∅ :=\n  iSup_of_empty _\n\n"}
{"name":"Set.iInter_of_empty","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ninst✝ : IsEmpty ι\ns : ι → Set α\n⊢ Eq (Set.iInter fun i => s i) Set.univ","decl":"@[simp]\ntheorem iInter_of_empty [IsEmpty ι] (s : ι → Set α) : ⋂ i, s i = univ :=\n  iInf_of_empty _\n\n"}
{"name":"Set.union_eq_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns₁ s₂ : Set α\n⊢ Eq (Union.union s₁ s₂) (Set.iUnion fun b => cond b s₁ s₂)","decl":"theorem union_eq_iUnion {s₁ s₂ : Set α} : s₁ ∪ s₂ = ⋃ b : Bool, cond b s₁ s₂ :=\n  sup_eq_iSup s₁ s₂\n\n"}
{"name":"Set.inter_eq_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns₁ s₂ : Set α\n⊢ Eq (Inter.inter s₁ s₂) (Set.iInter fun b => cond b s₁ s₂)","decl":"theorem inter_eq_iInter {s₁ s₂ : Set α} : s₁ ∩ s₂ = ⋂ b : Bool, cond b s₁ s₂ :=\n  inf_eq_iInf s₁ s₂\n\n"}
{"name":"Set.sInter_union_sInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS T : Set (Set α)\n⊢ Eq (Union.union S.sInter T.sInter) (Set.iInter fun p => Set.iInter fun h => Union.union p.1 p.2)","decl":"theorem sInter_union_sInter {S T : Set (Set α)} :\n    ⋂₀ S ∪ ⋂₀ T = ⋂ p ∈ S ×ˢ T, (p : Set α × Set α).1 ∪ p.2 :=\n  sInf_sup_sInf\n\n"}
{"name":"Set.sUnion_inter_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns t : Set (Set α)\n⊢ Eq (Inter.inter s.sUnion t.sUnion) (Set.iUnion fun p => Set.iUnion fun h => Inter.inter p.1 p.2)","decl":"theorem sUnion_inter_sUnion {s t : Set (Set α)} :\n    ⋃₀ s ∩ ⋃₀ t = ⋃ p ∈ s ×ˢ t, (p : Set α × Set α).1 ∩ p.2 :=\n  sSup_inf_sSup\n\n"}
{"name":"Set.biUnion_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : ι → Set α\nt : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => t x) (Set.iUnion fun i => Set.iUnion fun x => Set.iUnion fun h => t x)","decl":"theorem biUnion_iUnion (s : ι → Set α) (t : α → Set β) :\n    ⋃ x ∈ ⋃ i, s i, t x = ⋃ (i) (x ∈ s i), t x := by simp [@iUnion_comm _ ι]\n\n"}
{"name":"Set.biInter_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : ι → Set α\nt : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => t x) (Set.iInter fun i => Set.iInter fun x => Set.iInter fun h => t x)","decl":"theorem biInter_iUnion (s : ι → Set α) (t : α → Set β) :\n    ⋂ x ∈ ⋃ i, s i, t x = ⋂ (i) (x ∈ s i), t x := by simp [@iInter_comm _ ι]\n\n"}
{"name":"Set.sUnion_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set (Set α)\n⊢ Eq (Set.iUnion fun i => s i).sUnion (Set.iUnion fun i => (s i).sUnion)","decl":"theorem sUnion_iUnion (s : ι → Set (Set α)) : ⋃₀ ⋃ i, s i = ⋃ i, ⋃₀ s i := by\n  simp only [sUnion_eq_biUnion, biUnion_iUnion]\n\n"}
{"name":"Set.sInter_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set (Set α)\n⊢ Eq (Set.iUnion fun i => s i).sInter (Set.iInter fun i => (s i).sInter)","decl":"theorem sInter_iUnion (s : ι → Set (Set α)) : ⋂₀ ⋃ i, s i = ⋂ i, ⋂₀ s i := by\n  simp only [sInter_eq_biInter, biInter_iUnion]\n\n"}
{"name":"Set.iUnion_range_eq_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_12\nβ : Type u_13\nC : Set (Set α)\nf : (s : ↑C) → β → ↑↑s\nhf : ∀ (s : ↑C), Function.Surjective (f s)\n⊢ Eq (Set.iUnion fun y => Set.range fun s => ↑(f s y)) C.sUnion","decl":"theorem iUnion_range_eq_sUnion {α β : Type*} (C : Set (Set α)) {f : ∀ s : C, β → (s : Type _)}\n    (hf : ∀ s : C, Surjective (f s)) : ⋃ y : β, range (fun s : C => (f s y).val) = ⋃₀ C := by\n  ext x; constructor\n  · rintro ⟨s, ⟨y, rfl⟩, ⟨s, hs⟩, rfl⟩\n    refine ⟨_, hs, ?_⟩\n    exact (f ⟨s, hs⟩ y).2\n  · rintro ⟨s, hs, hx⟩\n    cases' hf ⟨s, hs⟩ ⟨x, hx⟩ with y hy\n    refine ⟨_, ⟨y, rfl⟩, ⟨s, hs⟩, ?_⟩\n    exact congr_arg Subtype.val hy\n\n"}
{"name":"Set.iUnion_range_eq_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nC : ι → Set α\nf : (x : ι) → β → ↑(C x)\nhf : ∀ (x : ι), Function.Surjective (f x)\n⊢ Eq (Set.iUnion fun y => Set.range fun x => ↑(f x y)) (Set.iUnion fun x => C x)","decl":"theorem iUnion_range_eq_iUnion (C : ι → Set α) {f : ∀ x : ι, β → C x}\n    (hf : ∀ x : ι, Surjective (f x)) : ⋃ y : β, range (fun x : ι => (f x y).val) = ⋃ x, C x := by\n  ext x; rw [mem_iUnion, mem_iUnion]; constructor\n  · rintro ⟨y, i, rfl⟩\n    exact ⟨i, (f i y).2⟩\n  · rintro ⟨i, hx⟩\n    cases' hf i ⟨x, hx⟩ with y hy\n    exact ⟨y, i, congr_arg Subtype.val hy⟩\n\n"}
{"name":"Set.union_distrib_iInter_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set α\nt : Set α\n⊢ Eq (Union.union t (Set.iInter fun i => s i)) (Set.iInter fun i => Union.union t (s i))","decl":"theorem union_distrib_iInter_left (s : ι → Set α) (t : Set α) : (t ∪ ⋂ i, s i) = ⋂ i, t ∪ s i :=\n  sup_iInf_eq _ _\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.union_distrib_iInter₂_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : Set α\nt : (i : ι) → κ i → Set α\n⊢ Eq (Union.union s (Set.iInter fun i => Set.iInter fun j => t i j)) (Set.iInter fun i => Set.iInter fun j => Union.union s (t i j))","decl":"theorem union_distrib_iInter₂_left (s : Set α) (t : ∀ i, κ i → Set α) :\n    (s ∪ ⋂ (i) (j), t i j) = ⋂ (i) (j), s ∪ t i j := by simp_rw [union_distrib_iInter_left]\n\n"}
{"name":"Set.union_distrib_iInter_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ns : ι → Set α\nt : Set α\n⊢ Eq (Union.union (Set.iInter fun i => s i) t) (Set.iInter fun i => Union.union (s i) t)","decl":"theorem union_distrib_iInter_right (s : ι → Set α) (t : Set α) : (⋂ i, s i) ∪ t = ⋂ i, s i ∪ t :=\n  iInf_sup_eq _ _\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.union_distrib_iInter₂_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\nt : Set α\n⊢ Eq (Union.union (Set.iInter fun i => Set.iInter fun j => s i j) t) (Set.iInter fun i => Set.iInter fun j => Union.union (s i j) t)","decl":"theorem union_distrib_iInter₂_right (s : ∀ i, κ i → Set α) (t : Set α) :\n    (⋂ (i) (j), s i j) ∪ t = ⋂ (i) (j), s i j ∪ t := by simp_rw [union_distrib_iInter_right]\n\n"}
{"name":"Set.biUnion_lt_eq_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : NoMaxOrder α\ns : α → Set β\n⊢ Eq (Set.iUnion fun n => Set.iUnion fun m => Set.iUnion fun h => s m) (Set.iUnion fun n => s n)","decl":"lemma biUnion_lt_eq_iUnion [LT α] [NoMaxOrder α] {s : α → Set β} :\n    ⋃ (n) (m < n), s m = ⋃ n, s n := biSup_lt_eq_iSup\n\n"}
{"name":"Set.biUnion_le_eq_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\ns : α → Set β\n⊢ Eq (Set.iUnion fun n => Set.iUnion fun m => Set.iUnion fun h => s m) (Set.iUnion fun n => s n)","decl":"lemma biUnion_le_eq_iUnion [Preorder α] {s : α → Set β} :\n    ⋃ (n) (m ≤ n), s m = ⋃ n, s n := biSup_le_eq_iSup\n\n"}
{"name":"Set.biInter_lt_eq_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : NoMaxOrder α\ns : α → Set β\n⊢ Eq (Set.iInter fun n => Set.iInter fun m => Set.iInter fun h => s m) (Set.iInter fun n => s n)","decl":"lemma biInter_lt_eq_iInter [LT α] [NoMaxOrder α] {s : α → Set β} :\n    ⋂ (n) (m < n), s m = ⋂ (n), s n := biInf_lt_eq_iInf\n\n"}
{"name":"Set.biInter_le_eq_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\ns : α → Set β\n⊢ Eq (Set.iInter fun n => Set.iInter fun m => Set.iInter fun h => s m) (Set.iInter fun n => s n)","decl":"lemma biInter_le_eq_iInter [Preorder α] {s : α → Set β} :\n    ⋂ (n) (m ≤ n), s m = ⋂ (n), s n := biInf_le_eq_iInf\n\n"}
{"name":"Set.biUnion_gt_eq_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : NoMinOrder α\ns : α → Set β\n⊢ Eq (Set.iUnion fun n => Set.iUnion fun m => Set.iUnion fun h => s m) (Set.iUnion fun n => s n)","decl":"lemma biUnion_gt_eq_iUnion [LT α] [NoMinOrder α] {s : α → Set β} :\n    ⋃ (n) (m > n), s m = ⋃ n, s n := biSup_gt_eq_iSup\n\n"}
{"name":"Set.biUnion_ge_eq_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\ns : α → Set β\n⊢ Eq (Set.iUnion fun n => Set.iUnion fun m => Set.iUnion fun h => s m) (Set.iUnion fun n => s n)","decl":"lemma biUnion_ge_eq_iUnion [Preorder α] {s : α → Set β} :\n    ⋃ (n) (m ≥ n), s m = ⋃ n, s n := biSup_ge_eq_iSup\n\n"}
{"name":"Set.biInter_gt_eq_iInf","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : NoMinOrder α\ns : α → Set β\n⊢ Eq (Set.iInter fun n => Set.iInter fun m => Set.iInter fun h => s m) (Set.iInter fun n => s n)","decl":"lemma biInter_gt_eq_iInf [LT α] [NoMinOrder α] {s : α → Set β} :\n    ⋂ (n) (m > n), s m = ⋂ n, s n := biInf_gt_eq_iInf\n\n"}
{"name":"Set.biInter_ge_eq_iInf","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\ns : α → Set β\n⊢ Eq (Set.iInter fun n => Set.iInter fun m => Set.iInter fun h => s m) (Set.iInter fun n => s n)","decl":"lemma biInter_ge_eq_iInf [Preorder α] {s : α → Set β} :\n    ⋂ (n) (m ≥ n), s m = ⋂ n, s n := biInf_ge_eq_iInf\n\n"}
{"name":"Set.mapsTo_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nS : Set (Set α)\nt : Set β\nf : α → β\n⊢ Iff (Set.MapsTo f S.sUnion t) (∀ (s : Set α), Membership.mem S s → Set.MapsTo f s t)","decl":"@[simp]\ntheorem mapsTo_sUnion {S : Set (Set α)} {t : Set β} {f : α → β} :\n    MapsTo f (⋃₀ S) t ↔ ∀ s ∈ S, MapsTo f s t :=\n  sUnion_subset_iff\n\n"}
{"name":"Set.mapsTo_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : ι → Set α\nt : Set β\nf : α → β\n⊢ Iff (Set.MapsTo f (Set.iUnion fun i => s i) t) (∀ (i : ι), Set.MapsTo f (s i) t)","decl":"@[simp]\ntheorem mapsTo_iUnion {s : ι → Set α} {t : Set β} {f : α → β} :\n    MapsTo f (⋃ i, s i) t ↔ ∀ i, MapsTo f (s i) t :=\n  iUnion_subset_iff\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.mapsTo_iUnion₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\nt : Set β\nf : α → β\n⊢ Iff (Set.MapsTo f (Set.iUnion fun i => Set.iUnion fun j => s i j) t) (∀ (i : ι) (j : κ i), Set.MapsTo f (s i j) t)","decl":"theorem mapsTo_iUnion₂ {s : ∀ i, κ i → Set α} {t : Set β} {f : α → β} :\n    MapsTo f (⋃ (i) (j), s i j) t ↔ ∀ i j, MapsTo f (s i j) t :=\n  iUnion₂_subset_iff\n\n"}
{"name":"Set.mapsTo_iUnion_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : ι → Set α\nt : ι → Set β\nf : α → β\nH : ∀ (i : ι), Set.MapsTo f (s i) (t i)\n⊢ Set.MapsTo f (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem mapsTo_iUnion_iUnion {s : ι → Set α} {t : ι → Set β} {f : α → β}\n    (H : ∀ i, MapsTo f (s i) (t i)) : MapsTo f (⋃ i, s i) (⋃ i, t i) :=\n  mapsTo_iUnion.2 fun i ↦ (H i).mono_right (subset_iUnion t i)\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.mapsTo_iUnion₂_iUnion₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\nt : (i : ι) → κ i → Set β\nf : α → β\nH : ∀ (i : ι) (j : κ i), Set.MapsTo f (s i j) (t i j)\n⊢ Set.MapsTo f (Set.iUnion fun i => Set.iUnion fun j => s i j) (Set.iUnion fun i => Set.iUnion fun j => t i j)","decl":"theorem mapsTo_iUnion₂_iUnion₂ {s : ∀ i, κ i → Set α} {t : ∀ i, κ i → Set β} {f : α → β}\n    (H : ∀ i j, MapsTo f (s i j) (t i j)) : MapsTo f (⋃ (i) (j), s i j) (⋃ (i) (j), t i j) :=\n  mapsTo_iUnion_iUnion fun i => mapsTo_iUnion_iUnion (H i)\n\n"}
{"name":"Set.mapsTo_sInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nT : Set (Set β)\nf : α → β\n⊢ Iff (Set.MapsTo f s T.sInter) (∀ (t : Set β), Membership.mem T t → Set.MapsTo f s t)","decl":"@[simp]\ntheorem mapsTo_sInter {s : Set α} {T : Set (Set β)} {f : α → β} :\n    MapsTo f s (⋂₀ T) ↔ ∀ t ∈ T, MapsTo f s t :=\n  forall₂_swap\n\n"}
{"name":"Set.mapsTo_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : Set α\nt : ι → Set β\nf : α → β\n⊢ Iff (Set.MapsTo f s (Set.iInter fun i => t i)) (∀ (i : ι), Set.MapsTo f s (t i))","decl":"@[simp]\ntheorem mapsTo_iInter {s : Set α} {t : ι → Set β} {f : α → β} :\n    MapsTo f s (⋂ i, t i) ↔ ∀ i, MapsTo f s (t i) :=\n  mapsTo_sInter.trans forall_mem_range\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.mapsTo_iInter₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nκ : ι → Sort u_8\ns : Set α\nt : (i : ι) → κ i → Set β\nf : α → β\n⊢ Iff (Set.MapsTo f s (Set.iInter fun i => Set.iInter fun j => t i j)) (∀ (i : ι) (j : κ i), Set.MapsTo f s (t i j))","decl":"theorem mapsTo_iInter₂ {s : Set α} {t : ∀ i, κ i → Set β} {f : α → β} :\n    MapsTo f s (⋂ (i) (j), t i j) ↔ ∀ i j, MapsTo f s (t i j) := by\n  simp only [mapsTo_iInter]\n\n"}
{"name":"Set.mapsTo_iInter_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : ι → Set α\nt : ι → Set β\nf : α → β\nH : ∀ (i : ι), Set.MapsTo f (s i) (t i)\n⊢ Set.MapsTo f (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"theorem mapsTo_iInter_iInter {s : ι → Set α} {t : ι → Set β} {f : α → β}\n    (H : ∀ i, MapsTo f (s i) (t i)) : MapsTo f (⋂ i, s i) (⋂ i, t i) :=\n  mapsTo_iInter.2 fun i => (H i).mono_left (iInter_subset s i)\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.mapsTo_iInter₂_iInter₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\nt : (i : ι) → κ i → Set β\nf : α → β\nH : ∀ (i : ι) (j : κ i), Set.MapsTo f (s i j) (t i j)\n⊢ Set.MapsTo f (Set.iInter fun i => Set.iInter fun j => s i j) (Set.iInter fun i => Set.iInter fun j => t i j)","decl":"theorem mapsTo_iInter₂_iInter₂ {s : ∀ i, κ i → Set α} {t : ∀ i, κ i → Set β} {f : α → β}\n    (H : ∀ i j, MapsTo f (s i j) (t i j)) : MapsTo f (⋂ (i) (j), s i j) (⋂ (i) (j), t i j) :=\n  mapsTo_iInter_iInter fun i => mapsTo_iInter_iInter (H i)\n\n"}
{"name":"Set.image_iInter_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : ι → Set α\nf : α → β\n⊢ HasSubset.Subset (Set.image f (Set.iInter fun i => s i)) (Set.iInter fun i => Set.image f (s i))","decl":"theorem image_iInter_subset (s : ι → Set α) (f : α → β) : (f '' ⋂ i, s i) ⊆ ⋂ i, f '' s i :=\n  (mapsTo_iInter_iInter fun i => mapsTo_image f (s i)).image_subset\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.image_iInter₂_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\nf : α → β\n⊢ HasSubset.Subset (Set.image f (Set.iInter fun i => Set.iInter fun j => s i j)) (Set.iInter fun i => Set.iInter fun j => Set.image f (s i j))","decl":"theorem image_iInter₂_subset (s : ∀ i, κ i → Set α) (f : α → β) :\n    (f '' ⋂ (i) (j), s i j) ⊆ ⋂ (i) (j), f '' s i j :=\n  (mapsTo_iInter₂_iInter₂ fun i hi => mapsTo_image f (s i hi)).image_subset\n\n"}
{"name":"Set.image_sInter_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nS : Set (Set α)\nf : α → β\n⊢ HasSubset.Subset (Set.image f S.sInter) (Set.iInter fun s => Set.iInter fun h => Set.image f s)","decl":"theorem image_sInter_subset (S : Set (Set α)) (f : α → β) : f '' ⋂₀ S ⊆ ⋂ s ∈ S, f '' s := by\n  rw [sInter_eq_biInter]\n  apply image_iInter₂_subset\n\n"}
{"name":"Set.image2_sInter_right_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nt : Set α\nS : Set (Set β)\nf : α → β → γ\n⊢ HasSubset.Subset (Set.image2 f t S.sInter) (Set.iInter fun s => Set.iInter fun h => Set.image2 f t s)","decl":"theorem image2_sInter_right_subset (t : Set α) (S : Set (Set β)) (f : α → β → γ) :\n    image2 f t (⋂₀ S) ⊆ ⋂ s ∈ S, image2 f t s := by\n  aesop\n\n"}
{"name":"Set.image2_sInter_left_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nS : Set (Set α)\nt : Set β\nf : α → β → γ\n⊢ HasSubset.Subset (Set.image2 f S.sInter t) (Set.iInter fun s => Set.iInter fun h => Set.image2 f s t)","decl":"theorem image2_sInter_left_subset (S : Set (Set α)) (t : Set β)  (f : α → β → γ) :\n    image2 f (⋂₀ S) t ⊆ ⋂ s ∈ S, image2 f s t := by\n  aesop\n\n"}
{"name":"Set.injective_iff_injective_of_iUnion_eq_univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nf : α → β\nU : ι → Set β\nhU : Eq (Set.iUnion U) Set.univ\n⊢ Iff (Function.Injective f) (∀ (i : ι), Function.Injective ((U i).restrictPreimage f))","decl":"theorem injective_iff_injective_of_iUnion_eq_univ :\n    Injective f ↔ ∀ i, Injective ((U i).restrictPreimage f) := by\n  refine ⟨fun H i => (U i).restrictPreimage_injective H, fun H x y e => ?_⟩\n  obtain ⟨i, hi⟩ := Set.mem_iUnion.mp\n      (show f x ∈ Set.iUnion U by rw [hU]; trivial)\n  injection @H i ⟨x, hi⟩ ⟨y, show f y ∈ U i from e ▸ hi⟩ (Subtype.ext e)\n\n"}
{"name":"Set.surjective_iff_surjective_of_iUnion_eq_univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nf : α → β\nU : ι → Set β\nhU : Eq (Set.iUnion U) Set.univ\n⊢ Iff (Function.Surjective f) (∀ (i : ι), Function.Surjective ((U i).restrictPreimage f))","decl":"theorem surjective_iff_surjective_of_iUnion_eq_univ :\n    Surjective f ↔ ∀ i, Surjective ((U i).restrictPreimage f) := by\n  refine ⟨fun H i => (U i).restrictPreimage_surjective H, fun H x => ?_⟩\n  obtain ⟨i, hi⟩ :=\n    Set.mem_iUnion.mp\n      (show x ∈ Set.iUnion U by rw [hU]; trivial)\n  exact ⟨_, congr_arg Subtype.val (H i ⟨x, hi⟩).choose_spec⟩\n\n"}
{"name":"Set.bijective_iff_bijective_of_iUnion_eq_univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nf : α → β\nU : ι → Set β\nhU : Eq (Set.iUnion U) Set.univ\n⊢ Iff (Function.Bijective f) (∀ (i : ι), Function.Bijective ((U i).restrictPreimage f))","decl":"theorem bijective_iff_bijective_of_iUnion_eq_univ :\n    Bijective f ↔ ∀ i, Bijective ((U i).restrictPreimage f) := by\n  rw [Bijective, injective_iff_injective_of_iUnion_eq_univ hU,\n    surjective_iff_surjective_of_iUnion_eq_univ hU]\n  simp [Bijective, forall_and]\n\n"}
{"name":"Set.InjOn.image_iInter_eq","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\ns : ι → Set α\nf : α → β\nh : Set.InjOn f (Set.iUnion fun i => s i)\n⊢ Eq (Set.image f (Set.iInter fun i => s i)) (Set.iInter fun i => Set.image f (s i))","decl":"theorem InjOn.image_iInter_eq [Nonempty ι] {s : ι → Set α} {f : α → β} (h : InjOn f (⋃ i, s i)) :\n    (f '' ⋂ i, s i) = ⋂ i, f '' s i := by\n  inhabit ι\n  refine Subset.antisymm (image_iInter_subset s f) fun y hy => ?_\n  simp only [mem_iInter, mem_image] at hy\n  choose x hx hy using hy\n  refine ⟨x default, mem_iInter.2 fun i => ?_, hy _⟩\n  suffices x default = x i by\n    rw [this]\n    apply hx\n  replace hx : ∀ i, x i ∈ ⋃ j, s j := fun i => (subset_iUnion _ _) (hx i)\n  apply h (hx _) (hx _)\n  simp only [hy]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i hi) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i hi) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i hi) -/\n"}
{"name":"Set.InjOn.image_biInter_eq","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\np : ι → Prop\ns : (i : ι) → p i → Set α\nhp : Exists fun i => p i\nf : α → β\nh : Set.InjOn f (Set.iUnion fun i => Set.iUnion fun hi => s i hi)\n⊢ Eq (Set.image f (Set.iInter fun i => Set.iInter fun hi => s i hi)) (Set.iInter fun i => Set.iInter fun hi => Set.image f (s i hi))","decl":"theorem InjOn.image_biInter_eq {p : ι → Prop} {s : ∀ i, p i → Set α} (hp : ∃ i, p i)\n    {f : α → β} (h : InjOn f (⋃ (i) (hi), s i hi)) :\n    (f '' ⋂ (i) (hi), s i hi) = ⋂ (i) (hi), f '' s i hi := by\n  simp only [iInter, iInf_subtype']\n  haveI : Nonempty { i // p i } := nonempty_subtype.2 hp\n  apply InjOn.image_iInter_eq\n  simpa only [iUnion, iSup_subtype'] using h\n\n"}
{"name":"Set.image_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nf : α → β\nhf : Function.Bijective f\ns : ι → Set α\n⊢ Eq (Set.image f (Set.iInter fun i => s i)) (Set.iInter fun i => Set.image f (s i))","decl":"theorem image_iInter {f : α → β} (hf : Bijective f) (s : ι → Set α) :\n    (f '' ⋂ i, s i) = ⋂ i, f '' s i := by\n  cases isEmpty_or_nonempty ι\n  · simp_rw [iInter_of_empty, image_univ_of_surjective hf.surjective]\n  · exact hf.injective.injOn.image_iInter_eq\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.image_iInter₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nκ : ι → Sort u_8\nf : α → β\nhf : Function.Bijective f\ns : (i : ι) → κ i → Set α\n⊢ Eq (Set.image f (Set.iInter fun i => Set.iInter fun j => s i j)) (Set.iInter fun i => Set.iInter fun j => Set.image f (s i j))","decl":"theorem image_iInter₂ {f : α → β} (hf : Bijective f) (s : ∀ i, κ i → Set α) :\n    (f '' ⋂ (i) (j), s i j) = ⋂ (i) (j), f '' s i j := by simp_rw [image_iInter hf]\n\n"}
{"name":"Set.inj_on_iUnion_of_directed","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : ι → Set α\nhs : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\nf : α → β\nhf : ∀ (i : ι), Set.InjOn f (s i)\n⊢ Set.InjOn f (Set.iUnion fun i => s i)","decl":"theorem inj_on_iUnion_of_directed {s : ι → Set α} (hs : Directed (· ⊆ ·) s) {f : α → β}\n    (hf : ∀ i, InjOn f (s i)) : InjOn f (⋃ i, s i) := by\n  intro x hx y hy hxy\n  rcases mem_iUnion.1 hx with ⟨i, hx⟩\n  rcases mem_iUnion.1 hy with ⟨j, hy⟩\n  rcases hs i j with ⟨k, hi, hj⟩\n  exact hf k (hi hx) (hj hy) hxy\n\n"}
{"name":"Set.surjOn_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nT : Set (Set β)\nf : α → β\nH : ∀ (t : Set β), Membership.mem T t → Set.SurjOn f s t\n⊢ Set.SurjOn f s T.sUnion","decl":"theorem surjOn_sUnion {s : Set α} {T : Set (Set β)} {f : α → β} (H : ∀ t ∈ T, SurjOn f s t) :\n    SurjOn f s (⋃₀ T) := fun _ ⟨t, ht, hx⟩ => H t ht hx\n\n"}
{"name":"Set.surjOn_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : Set α\nt : ι → Set β\nf : α → β\nH : ∀ (i : ι), Set.SurjOn f s (t i)\n⊢ Set.SurjOn f s (Set.iUnion fun i => t i)","decl":"theorem surjOn_iUnion {s : Set α} {t : ι → Set β} {f : α → β} (H : ∀ i, SurjOn f s (t i)) :\n    SurjOn f s (⋃ i, t i) :=\n  surjOn_sUnion <| forall_mem_range.2 H\n\n"}
{"name":"Set.surjOn_iUnion_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : ι → Set α\nt : ι → Set β\nf : α → β\nH : ∀ (i : ι), Set.SurjOn f (s i) (t i)\n⊢ Set.SurjOn f (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem surjOn_iUnion_iUnion {s : ι → Set α} {t : ι → Set β} {f : α → β}\n    (H : ∀ i, SurjOn f (s i) (t i)) : SurjOn f (⋃ i, s i) (⋃ i, t i) :=\n  surjOn_iUnion fun i => (H i).mono (subset_iUnion _ _) (Subset.refl _)\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.surjOn_iUnion₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nκ : ι → Sort u_8\ns : Set α\nt : (i : ι) → κ i → Set β\nf : α → β\nH : ∀ (i : ι) (j : κ i), Set.SurjOn f s (t i j)\n⊢ Set.SurjOn f s (Set.iUnion fun i => Set.iUnion fun j => t i j)","decl":"theorem surjOn_iUnion₂ {s : Set α} {t : ∀ i, κ i → Set β} {f : α → β}\n    (H : ∀ i j, SurjOn f s (t i j)) : SurjOn f s (⋃ (i) (j), t i j) :=\n  surjOn_iUnion fun i => surjOn_iUnion (H i)\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.surjOn_iUnion₂_iUnion₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\nt : (i : ι) → κ i → Set β\nf : α → β\nH : ∀ (i : ι) (j : κ i), Set.SurjOn f (s i j) (t i j)\n⊢ Set.SurjOn f (Set.iUnion fun i => Set.iUnion fun j => s i j) (Set.iUnion fun i => Set.iUnion fun j => t i j)","decl":"theorem surjOn_iUnion₂_iUnion₂ {s : ∀ i, κ i → Set α} {t : ∀ i, κ i → Set β} {f : α → β}\n    (H : ∀ i j, SurjOn f (s i j) (t i j)) : SurjOn f (⋃ (i) (j), s i j) (⋃ (i) (j), t i j) :=\n  surjOn_iUnion_iUnion fun i => surjOn_iUnion_iUnion (H i)\n\n"}
{"name":"Set.surjOn_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\ns : ι → Set α\nt : Set β\nf : α → β\nH : ∀ (i : ι), Set.SurjOn f (s i) t\nHinj : Set.InjOn f (Set.iUnion fun i => s i)\n⊢ Set.SurjOn f (Set.iInter fun i => s i) t","decl":"theorem surjOn_iInter [Nonempty ι] {s : ι → Set α} {t : Set β} {f : α → β}\n    (H : ∀ i, SurjOn f (s i) t) (Hinj : InjOn f (⋃ i, s i)) : SurjOn f (⋂ i, s i) t := by\n  intro y hy\n  rw [Hinj.image_iInter_eq, mem_iInter]\n  exact fun i => H i hy\n\n"}
{"name":"Set.surjOn_iInter_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\ns : ι → Set α\nt : ι → Set β\nf : α → β\nH : ∀ (i : ι), Set.SurjOn f (s i) (t i)\nHinj : Set.InjOn f (Set.iUnion fun i => s i)\n⊢ Set.SurjOn f (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"theorem surjOn_iInter_iInter [Nonempty ι] {s : ι → Set α} {t : ι → Set β} {f : α → β}\n    (H : ∀ i, SurjOn f (s i) (t i)) (Hinj : InjOn f (⋃ i, s i)) : SurjOn f (⋂ i, s i) (⋂ i, t i) :=\n  surjOn_iInter (fun i => (H i).mono (Subset.refl _) (iInter_subset _ _)) Hinj\n\n"}
{"name":"Set.bijOn_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : ι → Set α\nt : ι → Set β\nf : α → β\nH : ∀ (i : ι), Set.BijOn f (s i) (t i)\nHinj : Set.InjOn f (Set.iUnion fun i => s i)\n⊢ Set.BijOn f (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem bijOn_iUnion {s : ι → Set α} {t : ι → Set β} {f : α → β} (H : ∀ i, BijOn f (s i) (t i))\n    (Hinj : InjOn f (⋃ i, s i)) : BijOn f (⋃ i, s i) (⋃ i, t i) :=\n  ⟨mapsTo_iUnion_iUnion fun i => (H i).mapsTo, Hinj, surjOn_iUnion_iUnion fun i => (H i).surjOn⟩\n\n"}
{"name":"Set.bijOn_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nhi : Nonempty ι\ns : ι → Set α\nt : ι → Set β\nf : α → β\nH : ∀ (i : ι), Set.BijOn f (s i) (t i)\nHinj : Set.InjOn f (Set.iUnion fun i => s i)\n⊢ Set.BijOn f (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"theorem bijOn_iInter [hi : Nonempty ι] {s : ι → Set α} {t : ι → Set β} {f : α → β}\n    (H : ∀ i, BijOn f (s i) (t i)) (Hinj : InjOn f (⋃ i, s i)) : BijOn f (⋂ i, s i) (⋂ i, t i) :=\n  ⟨mapsTo_iInter_iInter fun i => (H i).mapsTo,\n    hi.elim fun i => (H i).injOn.mono (iInter_subset _ _),\n    surjOn_iInter_iInter (fun i => (H i).surjOn) Hinj⟩\n\n"}
{"name":"Set.bijOn_iUnion_of_directed","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : ι → Set α\nhs : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\nt : ι → Set β\nf : α → β\nH : ∀ (i : ι), Set.BijOn f (s i) (t i)\n⊢ Set.BijOn f (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem bijOn_iUnion_of_directed {s : ι → Set α} (hs : Directed (· ⊆ ·) s) {t : ι → Set β}\n    {f : α → β} (H : ∀ i, BijOn f (s i) (t i)) : BijOn f (⋃ i, s i) (⋃ i, t i) :=\n  bijOn_iUnion H <| inj_on_iUnion_of_directed hs fun i => (H i).injOn\n\n"}
{"name":"Set.bijOn_iInter_of_directed","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\ns : ι → Set α\nhs : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\nt : ι → Set β\nf : α → β\nH : ∀ (i : ι), Set.BijOn f (s i) (t i)\n⊢ Set.BijOn f (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"theorem bijOn_iInter_of_directed [Nonempty ι] {s : ι → Set α} (hs : Directed (· ⊆ ·) s)\n    {t : ι → Set β} {f : α → β} (H : ∀ i, BijOn f (s i) (t i)) : BijOn f (⋂ i, s i) (⋂ i, t i) :=\n  bijOn_iInter H <| inj_on_iUnion_of_directed hs fun i => (H i).injOn\n\n"}
{"name":"Set.image_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nf : α → β\ns : ι → Set α\n⊢ Eq (Set.image f (Set.iUnion fun i => s i)) (Set.iUnion fun i => Set.image f (s i))","decl":"theorem image_iUnion {f : α → β} {s : ι → Set α} : (f '' ⋃ i, s i) = ⋃ i, f '' s i := by\n  ext1 x\n  simp only [mem_image, mem_iUnion, ← exists_and_right, ← exists_and_left]\n  -- Porting note: `exists_swap` causes a `simp` loop in Lean4 so we use `rw` instead.\n  rw [exists_swap]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.image_iUnion₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nκ : ι → Sort u_8\nf : α → β\ns : (i : ι) → κ i → Set α\n⊢ Eq (Set.image f (Set.iUnion fun i => Set.iUnion fun j => s i j)) (Set.iUnion fun i => Set.iUnion fun j => Set.image f (s i j))","decl":"theorem image_iUnion₂ (f : α → β) (s : ∀ i, κ i → Set α) :\n    (f '' ⋃ (i) (j), s i j) = ⋃ (i) (j), f '' s i j := by simp_rw [image_iUnion]\n\n"}
{"name":"Set.univ_subtype","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\np : α → Prop\n⊢ Eq Set.univ (Set.iUnion fun x => Set.iUnion fun h => Singleton.singleton ⟨x, h⟩)","decl":"theorem univ_subtype {p : α → Prop} : (univ : Set (Subtype p)) = ⋃ (x) (h : p x), {⟨x, h⟩} :=\n  Set.ext fun ⟨x, h⟩ => by simp [h]\n\n"}
{"name":"Set.range_eq_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_12\nf : ι → α\n⊢ Eq (Set.range f) (Set.iUnion fun i => Singleton.singleton (f i))","decl":"theorem range_eq_iUnion {ι} (f : ι → α) : range f = ⋃ i, {f i} :=\n  Set.ext fun a => by simp [@eq_comm α a]\n\n"}
{"name":"Set.image_eq_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Eq (Set.image f s) (Set.iUnion fun i => Set.iUnion fun h => Singleton.singleton (f i))","decl":"theorem image_eq_iUnion (f : α → β) (s : Set α) : f '' s = ⋃ i ∈ s, {f i} :=\n  Set.ext fun b => by simp [@eq_comm β b]\n\n"}
{"name":"Set.biUnion_range","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nf : ι → α\ng : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => g x) (Set.iUnion fun y => g (f y))","decl":"theorem biUnion_range {f : ι → α} {g : α → Set β} : ⋃ x ∈ range f, g x = ⋃ y, g (f y) :=\n  iSup_range\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (x y) -/\n"}
{"name":"Set.iUnion_iUnion_eq'","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nf : ι → α\ng : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun y => Set.iUnion fun x_1 => g x) (Set.iUnion fun y => g (f y))","decl":"@[simp]\ntheorem iUnion_iUnion_eq' {f : ι → α} {g : α → Set β} :\n    ⋃ (x) (y) (_ : f y = x), g x = ⋃ y, g (f y) := by simpa using biUnion_range\n\n"}
{"name":"Set.biInter_range","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nf : ι → α\ng : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => g x) (Set.iInter fun y => g (f y))","decl":"theorem biInter_range {f : ι → α} {g : α → Set β} : ⋂ x ∈ range f, g x = ⋂ y, g (f y) :=\n  iInf_range\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (x y) -/\n"}
{"name":"Set.iInter_iInter_eq'","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nf : ι → α\ng : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun y => Set.iInter fun x_1 => g x) (Set.iInter fun y => g (f y))","decl":"@[simp]\ntheorem iInter_iInter_eq' {f : ι → α} {g : α → Set β} :\n    ⋂ (x) (y) (_ : f y = x), g x = ⋂ y, g (f y) := by simpa using biInter_range\n\n"}
{"name":"Set.biUnion_image","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set γ\nf : γ → α\ng : α → Set β\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => g x) (Set.iUnion fun y => Set.iUnion fun h => g (f y))","decl":"theorem biUnion_image : ⋃ x ∈ f '' s, g x = ⋃ y ∈ s, g (f y) :=\n  iSup_image\n\n"}
{"name":"Set.biInter_image","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set γ\nf : γ → α\ng : α → Set β\n⊢ Eq (Set.iInter fun x => Set.iInter fun h => g x) (Set.iInter fun y => Set.iInter fun h => g (f y))","decl":"theorem biInter_image : ⋂ x ∈ f '' s, g x = ⋂ y ∈ s, g (f y) :=\n  iInf_image\n\n"}
{"name":"Set.biUnion_image2","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ns : Set α\nt : Set β\nf : α → β → γ\ng : γ → Set δ\n⊢ Eq (Set.iUnion fun c => Set.iUnion fun h => g c) (Set.iUnion fun a => Set.iUnion fun h => Set.iUnion fun b => Set.iUnion fun h => g (f a b))","decl":"lemma biUnion_image2 (s : Set α) (t : Set β) (f : α → β → γ) (g : γ → Set δ) :\n    ⋃ c ∈ image2 f s t, g c = ⋃ a ∈ s, ⋃ b ∈ t, g (f a b) := iSup_image2 ..\n\n"}
{"name":"Set.biInter_image2","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ns : Set α\nt : Set β\nf : α → β → γ\ng : γ → Set δ\n⊢ Eq (Set.iInter fun c => Set.iInter fun h => g c) (Set.iInter fun a => Set.iInter fun h => Set.iInter fun b => Set.iInter fun h => g (f a b))","decl":"lemma biInter_image2 (s : Set α) (t : Set β) (f : α → β → γ) (g : γ → Set δ) :\n    ⋂ c ∈ image2 f s t, g c = ⋂ a ∈ s, ⋂ b ∈ t, g (f a b) := iInf_image2 ..\n\n"}
{"name":"Set.iUnion_inter_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_12\nκ : Sort u_13\nf : ι → Set α\ng : κ → Set α\n⊢ Eq (Inter.inter (Set.iUnion fun i => f i) (Set.iUnion fun j => g j)) (Set.iUnion fun i => Set.iUnion fun j => Inter.inter (f i) (g j))","decl":"lemma iUnion_inter_iUnion {ι κ : Sort*} (f : ι → Set α) (g : κ → Set α) :\n    (⋃ i, f i) ∩ ⋃ j, g j = ⋃ i, ⋃ j, f i ∩ g j := by simp_rw [iUnion_inter, inter_iUnion]\n\n"}
{"name":"Set.iInter_union_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_12\nκ : Sort u_13\nf : ι → Set α\ng : κ → Set α\n⊢ Eq (Union.union (Set.iInter fun i => f i) (Set.iInter fun j => g j)) (Set.iInter fun i => Set.iInter fun j => Union.union (f i) (g j))","decl":"lemma iInter_union_iInter {ι κ : Sort*} (f : ι → Set α) (g : κ → Set α) :\n    (⋂ i, f i) ∪ ⋂ j, g j = ⋂ i, ⋂ j, f i ∪ g j := by simp_rw [iInter_union, union_iInter]\n\n"}
{"name":"Set.iUnion₂_inter_iUnion₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι₁ : Sort u_12\nκ₁ : Sort u_13\nι₂ : ι₁ → Sort u_14\nk₂ : κ₁ → Sort u_15\nf : (i₁ : ι₁) → ι₂ i₁ → Set α\ng : (j₁ : κ₁) → k₂ j₁ → Set α\n⊢ Eq (Inter.inter (Set.iUnion fun i₁ => Set.iUnion fun i₂ => f i₁ i₂) (Set.iUnion fun j₁ => Set.iUnion fun j₂ => g j₁ j₂)) (Set.iUnion fun i₁ => Set.iUnion fun i₂ => Set.iUnion fun j₁ => Set.iUnion fun j₂ => Inter.inter (f i₁ i₂) (g j₁ j₂))","decl":"lemma iUnion₂_inter_iUnion₂ {ι₁ κ₁ : Sort*} {ι₂ : ι₁ → Sort*} {k₂ : κ₁ → Sort*}\n    (f : ∀ i₁, ι₂ i₁ → Set α) (g : ∀ j₁, k₂ j₁ → Set α) :\n    (⋃ i₁, ⋃ i₂, f i₁ i₂) ∩ ⋃ j₁, ⋃ j₂, g j₁ j₂ = ⋃ i₁, ⋃ i₂, ⋃ j₁, ⋃ j₂, f i₁ i₂ ∩ g j₁ j₂ := by\n  simp_rw [iUnion_inter, inter_iUnion]\n\n"}
{"name":"Set.iInter₂_union_iInter₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι₁ : Sort u_12\nκ₁ : Sort u_13\nι₂ : ι₁ → Sort u_14\nk₂ : κ₁ → Sort u_15\nf : (i₁ : ι₁) → ι₂ i₁ → Set α\ng : (j₁ : κ₁) → k₂ j₁ → Set α\n⊢ Eq (Union.union (Set.iInter fun i₁ => Set.iInter fun i₂ => f i₁ i₂) (Set.iInter fun j₁ => Set.iInter fun j₂ => g j₁ j₂)) (Set.iInter fun i₁ => Set.iInter fun i₂ => Set.iInter fun j₁ => Set.iInter fun j₂ => Union.union (f i₁ i₂) (g j₁ j₂))","decl":"lemma iInter₂_union_iInter₂ {ι₁ κ₁ : Sort*} {ι₂ : ι₁ → Sort*} {k₂ : κ₁ → Sort*}\n    (f : ∀ i₁, ι₂ i₁ → Set α) (g : ∀ j₁, k₂ j₁ → Set α) :\n    (⋂ i₁, ⋂ i₂, f i₁ i₂) ∪ ⋂ j₁, ⋂ j₂, g j₁ j₂ = ⋂ i₁, ⋂ i₂, ⋂ j₁, ⋂ j₂, f i₁ i₂ ∪ g j₁ j₂ := by\n  simp_rw [iInter_union, union_iInter]\n\n"}
{"name":"Set.monotone_preimage","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Monotone (Set.preimage f)","decl":"theorem monotone_preimage {f : α → β} : Monotone (preimage f) := fun _ _ h => preimage_mono h\n\n"}
{"name":"Set.preimage_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nf : α → β\ns : ι → Set β\n⊢ Eq (Set.preimage f (Set.iUnion fun i => s i)) (Set.iUnion fun i => Set.preimage f (s i))","decl":"@[simp]\ntheorem preimage_iUnion {f : α → β} {s : ι → Set β} : (f ⁻¹' ⋃ i, s i) = ⋃ i, f ⁻¹' s i :=\n  Set.ext <| by simp [preimage]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.preimage_iUnion₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nκ : ι → Sort u_8\nf : α → β\ns : (i : ι) → κ i → Set β\n⊢ Eq (Set.preimage f (Set.iUnion fun i => Set.iUnion fun j => s i j)) (Set.iUnion fun i => Set.iUnion fun j => Set.preimage f (s i j))","decl":"theorem preimage_iUnion₂ {f : α → β} {s : ∀ i, κ i → Set β} :\n    (f ⁻¹' ⋃ (i) (j), s i j) = ⋃ (i) (j), f ⁻¹' s i j := by simp_rw [preimage_iUnion]\n\n"}
{"name":"Set.image_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set (Set α)\n⊢ Eq (Set.image f s.sUnion) (Set.image (Set.image f) s).sUnion","decl":"theorem image_sUnion {f : α → β} {s : Set (Set α)} : (f '' ⋃₀ s) = ⋃₀ (image f '' s) := by\n  ext b\n  simp only [mem_image, mem_sUnion, exists_prop, sUnion_image, mem_iUnion]\n  constructor\n  · rintro ⟨a, ⟨t, ht₁, ht₂⟩, rfl⟩\n    exact ⟨t, ht₁, a, ht₂, rfl⟩\n  · rintro ⟨t, ht₁, a, ht₂, rfl⟩\n    exact ⟨a, ⟨t, ht₁, ht₂⟩, rfl⟩\n\n"}
{"name":"Set.preimage_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set (Set β)\n⊢ Eq (Set.preimage f s.sUnion) (Set.iUnion fun t => Set.iUnion fun h => Set.preimage f t)","decl":"@[simp]\ntheorem preimage_sUnion {f : α → β} {s : Set (Set β)} : f ⁻¹' ⋃₀ s = ⋃ t ∈ s, f ⁻¹' t := by\n  rw [sUnion_eq_biUnion, preimage_iUnion₂]\n\n"}
{"name":"Set.preimage_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nf : α → β\ns : ι → Set β\n⊢ Eq (Set.preimage f (Set.iInter fun i => s i)) (Set.iInter fun i => Set.preimage f (s i))","decl":"theorem preimage_iInter {f : α → β} {s : ι → Set β} : (f ⁻¹' ⋂ i, s i) = ⋂ i, f ⁻¹' s i := by\n  ext; simp\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.preimage_iInter₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nκ : ι → Sort u_8\nf : α → β\ns : (i : ι) → κ i → Set β\n⊢ Eq (Set.preimage f (Set.iInter fun i => Set.iInter fun j => s i j)) (Set.iInter fun i => Set.iInter fun j => Set.preimage f (s i j))","decl":"theorem preimage_iInter₂ {f : α → β} {s : ∀ i, κ i → Set β} :\n    (f ⁻¹' ⋂ (i) (j), s i j) = ⋂ (i) (j), f ⁻¹' s i j := by simp_rw [preimage_iInter]\n\n"}
{"name":"Set.preimage_sInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set (Set β)\n⊢ Eq (Set.preimage f s.sInter) (Set.iInter fun t => Set.iInter fun h => Set.preimage f t)","decl":"@[simp]\ntheorem preimage_sInter {f : α → β} {s : Set (Set β)} : f ⁻¹' ⋂₀ s = ⋂ t ∈ s, f ⁻¹' t := by\n  rw [sInter_eq_biInter, preimage_iInter₂]\n\n"}
{"name":"Set.biUnion_preimage_singleton","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\n⊢ Eq (Set.iUnion fun y => Set.iUnion fun h => Set.preimage f (Singleton.singleton y)) (Set.preimage f s)","decl":"@[simp]\ntheorem biUnion_preimage_singleton (f : α → β) (s : Set β) : ⋃ y ∈ s, f ⁻¹' {y} = f ⁻¹' s := by\n  rw [← preimage_iUnion₂, biUnion_of_singleton]\n\n"}
{"name":"Set.biUnion_range_preimage_singleton","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Set.iUnion fun y => Set.iUnion fun h => Set.preimage f (Singleton.singleton y)) Set.univ","decl":"theorem biUnion_range_preimage_singleton (f : α → β) : ⋃ y ∈ range f, f ⁻¹' {y} = univ := by\n  rw [biUnion_preimage_singleton, preimage_range]\n\n"}
{"name":"Set.prod_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : Set α\nt : ι → Set β\n⊢ Eq (SProd.sprod s (Set.iUnion fun i => t i)) (Set.iUnion fun i => SProd.sprod s (t i))","decl":"theorem prod_iUnion {s : Set α} {t : ι → Set β} : (s ×ˢ ⋃ i, t i) = ⋃ i, s ×ˢ t i := by\n  ext\n  simp\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.prod_iUnion₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nκ : ι → Sort u_8\ns : Set α\nt : (i : ι) → κ i → Set β\n⊢ Eq (SProd.sprod s (Set.iUnion fun i => Set.iUnion fun j => t i j)) (Set.iUnion fun i => Set.iUnion fun j => SProd.sprod s (t i j))","decl":"theorem prod_iUnion₂ {s : Set α} {t : ∀ i, κ i → Set β} :\n    (s ×ˢ ⋃ (i) (j), t i j) = ⋃ (i) (j), s ×ˢ t i j := by simp_rw [prod_iUnion]\n\n"}
{"name":"Set.prod_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nC : Set (Set β)\n⊢ Eq (SProd.sprod s C.sUnion) (Set.image (fun t => SProd.sprod s t) C).sUnion","decl":"theorem prod_sUnion {s : Set α} {C : Set (Set β)} : s ×ˢ ⋃₀ C = ⋃₀ ((fun t => s ×ˢ t) '' C) := by\n  simp_rw [sUnion_eq_biUnion, biUnion_image, prod_iUnion₂]\n\n"}
{"name":"Set.iUnion_prod_const","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : ι → Set α\nt : Set β\n⊢ Eq (SProd.sprod (Set.iUnion fun i => s i) t) (Set.iUnion fun i => SProd.sprod (s i) t)","decl":"theorem iUnion_prod_const {s : ι → Set α} {t : Set β} : (⋃ i, s i) ×ˢ t = ⋃ i, s i ×ˢ t := by\n  ext\n  simp\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iUnion₂_prod_const","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\nt : Set β\n⊢ Eq (SProd.sprod (Set.iUnion fun i => Set.iUnion fun j => s i j) t) (Set.iUnion fun i => Set.iUnion fun j => SProd.sprod (s i j) t)","decl":"theorem iUnion₂_prod_const {s : ∀ i, κ i → Set α} {t : Set β} :\n    (⋃ (i) (j), s i j) ×ˢ t = ⋃ (i) (j), s i j ×ˢ t := by simp_rw [iUnion_prod_const]\n\n"}
{"name":"Set.sUnion_prod_const","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nC : Set (Set α)\nt : Set β\n⊢ Eq (SProd.sprod C.sUnion t) (Set.image (fun s => SProd.sprod s t) C).sUnion","decl":"theorem sUnion_prod_const {C : Set (Set α)} {t : Set β} :\n    ⋃₀ C ×ˢ t = ⋃₀ ((fun s : Set α => s ×ˢ t) '' C) := by\n  simp only [sUnion_eq_biUnion, iUnion₂_prod_const, biUnion_image]\n\n"}
{"name":"Set.iUnion_prod","module":"Mathlib.Data.Set.Lattice","initialProofState":"ι : Type u_12\nι' : Type u_13\nα : Type u_14\nβ : Type u_15\ns : ι → Set α\nt : ι' → Set β\n⊢ Eq (Set.iUnion fun x => SProd.sprod (s x.1) (t x.2)) (SProd.sprod (Set.iUnion fun i => s i) (Set.iUnion fun i => t i))","decl":"theorem iUnion_prod {ι ι' α β} (s : ι → Set α) (t : ι' → Set β) :\n    ⋃ x : ι × ι', s x.1 ×ˢ t x.2 = (⋃ i : ι, s i) ×ˢ ⋃ i : ι', t i := by\n  ext\n  simp\n\n"}
{"name":"Set.iUnion_prod'","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Prod β γ → Set α\n⊢ Eq (Set.iUnion fun x => f x) (Set.iUnion fun i => Set.iUnion fun j => f { fst := i, snd := j })","decl":"/-- Analogue of `iSup_prod` for sets. -/\nlemma iUnion_prod' (f : β × γ → Set α) : ⋃ x : β × γ, f x = ⋃ (i : β) (j : γ), f (i, j) :=\n  iSup_prod\n\n"}
{"name":"Set.iUnion_prod_of_monotone","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : SemilatticeSup α\ns : α → Set β\nt : α → Set γ\nhs : Monotone s\nht : Monotone t\n⊢ Eq (Set.iUnion fun x => SProd.sprod (s x) (t x)) (SProd.sprod (Set.iUnion fun x => s x) (Set.iUnion fun x => t x))","decl":"theorem iUnion_prod_of_monotone [SemilatticeSup α] {s : α → Set β} {t : α → Set γ} (hs : Monotone s)\n    (ht : Monotone t) : ⋃ x, s x ×ˢ t x = (⋃ x, s x) ×ˢ ⋃ x, t x := by\n  ext ⟨z, w⟩; simp only [mem_prod, mem_iUnion, exists_imp, and_imp, iff_def]; constructor\n  · intro x hz hw\n    exact ⟨⟨x, hz⟩, x, hw⟩\n  · intro x hz x' hw\n    exact ⟨x ⊔ x', hs le_sup_left hz, ht le_sup_right hw⟩\n\n"}
{"name":"Set.sInter_prod_sInter_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nS : Set (Set α)\nT : Set (Set β)\n⊢ HasSubset.Subset (SProd.sprod S.sInter T.sInter) (Set.iInter fun r => Set.iInter fun h => SProd.sprod r.1 r.2)","decl":"theorem sInter_prod_sInter_subset (S : Set (Set α)) (T : Set (Set β)) :\n    ⋂₀ S ×ˢ ⋂₀ T ⊆ ⋂ r ∈ S ×ˢ T, r.1 ×ˢ r.2 :=\n  subset_iInter₂ fun x hx _ hy => ⟨hy.1 x.1 hx.1, hy.2 x.2 hx.2⟩\n\n"}
{"name":"Set.sInter_prod_sInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nS : Set (Set α)\nT : Set (Set β)\nhS : S.Nonempty\nhT : T.Nonempty\n⊢ Eq (SProd.sprod S.sInter T.sInter) (Set.iInter fun r => Set.iInter fun h => SProd.sprod r.1 r.2)","decl":"theorem sInter_prod_sInter {S : Set (Set α)} {T : Set (Set β)} (hS : S.Nonempty) (hT : T.Nonempty) :\n    ⋂₀ S ×ˢ ⋂₀ T = ⋂ r ∈ S ×ˢ T, r.1 ×ˢ r.2 := by\n  obtain ⟨s₁, h₁⟩ := hS\n  obtain ⟨s₂, h₂⟩ := hT\n  refine Set.Subset.antisymm (sInter_prod_sInter_subset S T) fun x hx => ?_\n  rw [mem_iInter₂] at hx\n  exact ⟨fun s₀ h₀ => (hx (s₀, s₂) ⟨h₀, h₂⟩).1, fun s₀ h₀ => (hx (s₁, s₀) ⟨h₁, h₀⟩).2⟩\n\n"}
{"name":"Set.sInter_prod","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nS : Set (Set α)\nhS : S.Nonempty\nt : Set β\n⊢ Eq (SProd.sprod S.sInter t) (Set.iInter fun s => Set.iInter fun h => SProd.sprod s t)","decl":"theorem sInter_prod {S : Set (Set α)} (hS : S.Nonempty) (t : Set β) :\n    ⋂₀ S ×ˢ t = ⋂ s ∈ S, s ×ˢ t := by\n  rw [← sInter_singleton t, sInter_prod_sInter hS (singleton_nonempty t), sInter_singleton]\n  simp_rw [prod_singleton, mem_image, iInter_exists, biInter_and', iInter_iInter_eq_right]\n\n"}
{"name":"Set.prod_sInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nT : Set (Set β)\nhT : T.Nonempty\ns : Set α\n⊢ Eq (SProd.sprod s T.sInter) (Set.iInter fun t => Set.iInter fun h => SProd.sprod s t)","decl":"theorem prod_sInter {T : Set (Set β)} (hT : T.Nonempty) (s : Set α) :\n    s ×ˢ ⋂₀ T = ⋂ t ∈ T, s ×ˢ t := by\n  rw [← sInter_singleton s, sInter_prod_sInter (singleton_nonempty s) hT, sInter_singleton]\n  simp_rw [singleton_prod, mem_image, iInter_exists, biInter_and', iInter_iInter_eq_right]\n\n"}
{"name":"Set.prod_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ns : Set α\nt : ι → Set β\nhι : Nonempty ι\n⊢ Eq (SProd.sprod s (Set.iInter fun i => t i)) (Set.iInter fun i => SProd.sprod s (t i))","decl":"theorem prod_iInter {s : Set α} {t : ι → Set β} [hι : Nonempty ι] :\n    (s ×ˢ ⋂ i, t i) = ⋂ i, s ×ˢ t i := by\n  ext x\n  simp only [mem_prod, mem_iInter]\n  exact ⟨fun h i => ⟨h.1, h.2 i⟩, fun h => ⟨(h hι.some).1, fun i => (h i).2⟩⟩\n\n"}
{"name":"Set.image2_eq_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\ns : Set α\nt : Set β\n⊢ Eq (Set.image2 f s t) (Set.iUnion fun i => Set.iUnion fun h => Set.iUnion fun j => Set.iUnion fun h => Singleton.singleton (f i j))","decl":"/-- The `Set.image2` version of `Set.image_eq_iUnion` -/\ntheorem image2_eq_iUnion (s : Set α) (t : Set β) : image2 f s t = ⋃ (i ∈ s) (j ∈ t), {f i j} := by\n  ext; simp [eq_comm]\n\n"}
{"name":"Set.iUnion_image_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\ns : Set α\nt : Set β\n⊢ Eq (Set.iUnion fun a => Set.iUnion fun h => Set.image (f a) t) (Set.image2 f s t)","decl":"theorem iUnion_image_left : ⋃ a ∈ s, f a '' t = image2 f s t := by\n  simp only [image2_eq_iUnion, image_eq_iUnion]\n\n"}
{"name":"Set.iUnion_image_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\ns : Set α\nt : Set β\n⊢ Eq (Set.iUnion fun b => Set.iUnion fun h => Set.image (fun x => f x b) s) (Set.image2 f s t)","decl":"theorem iUnion_image_right : ⋃ b ∈ t, (f · b) '' s = image2 f s t := by\n  rw [image2_swap, iUnion_image_left]\n\n"}
{"name":"Set.image2_iUnion_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nι : Sort u_5\nf : α → β → γ\ns : ι → Set α\nt : Set β\n⊢ Eq (Set.image2 f (Set.iUnion fun i => s i) t) (Set.iUnion fun i => Set.image2 f (s i) t)","decl":"theorem image2_iUnion_left (s : ι → Set α) (t : Set β) :\n    image2 f (⋃ i, s i) t = ⋃ i, image2 f (s i) t := by\n  simp only [← image_prod, iUnion_prod_const, image_iUnion]\n\n"}
{"name":"Set.image2_iUnion_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nι : Sort u_5\nf : α → β → γ\ns : Set α\nt : ι → Set β\n⊢ Eq (Set.image2 f s (Set.iUnion fun i => t i)) (Set.iUnion fun i => Set.image2 f s (t i))","decl":"theorem image2_iUnion_right (s : Set α) (t : ι → Set β) :\n    image2 f s (⋃ i, t i) = ⋃ i, image2 f s (t i) := by\n  simp only [← image_prod, prod_iUnion, image_iUnion]\n\n"}
{"name":"Set.image2_sUnion_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\nS : Set (Set α)\nt : Set β\n⊢ Eq (Set.image2 f S.sUnion t) (Set.iUnion fun s => Set.iUnion fun h => Set.image2 f s t)","decl":"theorem image2_sUnion_left (S : Set (Set α)) (t : Set β) :\n    image2 f (⋃₀ S) t = ⋃ s ∈ S, image2 f s t := by\n  aesop\n\n"}
{"name":"Set.image2_sUnion_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\ns : Set α\nT : Set (Set β)\n⊢ Eq (Set.image2 f s T.sUnion) (Set.iUnion fun t => Set.iUnion fun h => Set.image2 f s t)","decl":"theorem image2_sUnion_right (s : Set α) (T : Set (Set β)) :\n    image2 f s (⋃₀ T) = ⋃ t ∈ T, image2 f s t := by\n  aesop\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.image2_iUnion₂_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_8\nf : α → β → γ\ns : (i : ι) → κ i → Set α\nt : Set β\n⊢ Eq (Set.image2 f (Set.iUnion fun i => Set.iUnion fun j => s i j) t) (Set.iUnion fun i => Set.iUnion fun j => Set.image2 f (s i j) t)","decl":"theorem image2_iUnion₂_left (s : ∀ i, κ i → Set α) (t : Set β) :\n    image2 f (⋃ (i) (j), s i j) t = ⋃ (i) (j), image2 f (s i j) t := by simp_rw [image2_iUnion_left]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.image2_iUnion₂_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_8\nf : α → β → γ\ns : Set α\nt : (i : ι) → κ i → Set β\n⊢ Eq (Set.image2 f s (Set.iUnion fun i => Set.iUnion fun j => t i j)) (Set.iUnion fun i => Set.iUnion fun j => Set.image2 f s (t i j))","decl":"theorem image2_iUnion₂_right (s : Set α) (t : ∀ i, κ i → Set β) :\n    image2 f s (⋃ (i) (j), t i j) = ⋃ (i) (j), image2 f s (t i j) := by\n  simp_rw [image2_iUnion_right]\n\n"}
{"name":"Set.image2_iInter_subset_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nι : Sort u_5\nf : α → β → γ\ns : ι → Set α\nt : Set β\n⊢ HasSubset.Subset (Set.image2 f (Set.iInter fun i => s i) t) (Set.iInter fun i => Set.image2 f (s i) t)","decl":"theorem image2_iInter_subset_left (s : ι → Set α) (t : Set β) :\n    image2 f (⋂ i, s i) t ⊆ ⋂ i, image2 f (s i) t := by\n  simp_rw [image2_subset_iff, mem_iInter]\n  exact fun x hx y hy i => mem_image2_of_mem (hx _) hy\n\n"}
{"name":"Set.image2_iInter_subset_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nι : Sort u_5\nf : α → β → γ\ns : Set α\nt : ι → Set β\n⊢ HasSubset.Subset (Set.image2 f s (Set.iInter fun i => t i)) (Set.iInter fun i => Set.image2 f s (t i))","decl":"theorem image2_iInter_subset_right (s : Set α) (t : ι → Set β) :\n    image2 f s (⋂ i, t i) ⊆ ⋂ i, image2 f s (t i) := by\n  simp_rw [image2_subset_iff, mem_iInter]\n  exact fun x hx y hy i => mem_image2_of_mem hx (hy _)\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.image2_iInter₂_subset_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_8\nf : α → β → γ\ns : (i : ι) → κ i → Set α\nt : Set β\n⊢ HasSubset.Subset (Set.image2 f (Set.iInter fun i => Set.iInter fun j => s i j) t) (Set.iInter fun i => Set.iInter fun j => Set.image2 f (s i j) t)","decl":"theorem image2_iInter₂_subset_left (s : ∀ i, κ i → Set α) (t : Set β) :\n    image2 f (⋂ (i) (j), s i j) t ⊆ ⋂ (i) (j), image2 f (s i j) t := by\n  simp_rw [image2_subset_iff, mem_iInter]\n  exact fun x hx y hy i j => mem_image2_of_mem (hx _ _) hy\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.image2_iInter₂_subset_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nι : Sort u_5\nκ : ι → Sort u_8\nf : α → β → γ\ns : Set α\nt : (i : ι) → κ i → Set β\n⊢ HasSubset.Subset (Set.image2 f s (Set.iInter fun i => Set.iInter fun j => t i j)) (Set.iInter fun i => Set.iInter fun j => Set.image2 f s (t i j))","decl":"theorem image2_iInter₂_subset_right (s : Set α) (t : ∀ i, κ i → Set β) :\n    image2 f s (⋂ (i) (j), t i j) ⊆ ⋂ (i) (j), image2 f s (t i j) := by\n  simp_rw [image2_subset_iff, mem_iInter]\n  exact fun x hx y hy i j => mem_image2_of_mem hx (hy _ _)\n\n"}
{"name":"Set.image2_sInter_subset_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\nS : Set (Set α)\nt : Set β\n⊢ HasSubset.Subset (Set.image2 f S.sInter t) (Set.iInter fun s => Set.iInter fun h => Set.image2 f s t)","decl":"theorem image2_sInter_subset_left (S : Set (Set α)) (t : Set β) :\n    image2 f (⋂₀ S) t ⊆ ⋂ s ∈ S, image2 f s t := by\n  rw [sInter_eq_biInter]\n  exact image2_iInter₂_subset_left ..\n\n"}
{"name":"Set.image2_sInter_subset_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\ns : Set α\nT : Set (Set β)\n⊢ HasSubset.Subset (Set.image2 f s T.sInter) (Set.iInter fun t => Set.iInter fun h => Set.image2 f s t)","decl":"theorem image2_sInter_subset_right (s : Set α) (T : Set (Set β)) :\n    image2 f s (⋂₀ T) ⊆ ⋂ t ∈ T, image2 f s t := by\n  rw [sInter_eq_biInter]\n  exact image2_iInter₂_subset_right ..\n\n"}
{"name":"Set.prod_eq_biUnion_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Eq (SProd.sprod s t) (Set.iUnion fun a => Set.iUnion fun h => Set.image (fun b => { fst := a, snd := b }) t)","decl":"theorem prod_eq_biUnion_left : s ×ˢ t = ⋃ a ∈ s, (fun b => (a, b)) '' t := by\n  rw [iUnion_image_left, image2_mk_eq_prod]\n\n"}
{"name":"Set.prod_eq_biUnion_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Eq (SProd.sprod s t) (Set.iUnion fun b => Set.iUnion fun h => Set.image (fun a => { fst := a, snd := b }) s)","decl":"theorem prod_eq_biUnion_right : s ×ˢ t = ⋃ b ∈ t, (fun a => (a, b)) '' s := by\n  rw [iUnion_image_right, image2_mk_eq_prod]\n\n"}
{"name":"Set.seq_def","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set (α → β)\nt : Set α\n⊢ Eq (s.seq t) (Set.iUnion fun f => Set.iUnion fun h => Set.image f t)","decl":"theorem seq_def {s : Set (α → β)} {t : Set α} : seq s t = ⋃ f ∈ s, f '' t := by\n  rw [seq_eq_image2, iUnion_image_left]\n\n"}
{"name":"Set.seq_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set (α → β)\nt : Set α\nu : Set β\n⊢ Iff (HasSubset.Subset (s.seq t) u) (∀ (f : α → β), Membership.mem s f → ∀ (a : α), Membership.mem t a → Membership.mem u (f a))","decl":"theorem seq_subset {s : Set (α → β)} {t : Set α} {u : Set β} :\n    seq s t ⊆ u ↔ ∀ f ∈ s, ∀ a ∈ t, (f : α → β) a ∈ u :=\n  image2_subset_iff\n\n"}
{"name":"Set.seq_mono","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns₀ s₁ : Set (α → β)\nt₀ t₁ : Set α\nhs : HasSubset.Subset s₀ s₁\nht : HasSubset.Subset t₀ t₁\n⊢ HasSubset.Subset (s₀.seq t₀) (s₁.seq t₁)","decl":"@[gcongr]\ntheorem seq_mono {s₀ s₁ : Set (α → β)} {t₀ t₁ : Set α} (hs : s₀ ⊆ s₁) (ht : t₀ ⊆ t₁) :\n    seq s₀ t₀ ⊆ seq s₁ t₁ := image2_subset hs ht\n\n"}
{"name":"Set.singleton_seq","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nt : Set α\n⊢ Eq ((Singleton.singleton f).seq t) (Set.image f t)","decl":"theorem singleton_seq {f : α → β} {t : Set α} : Set.seq ({f} : Set (α → β)) t = f '' t :=\n  image2_singleton_left\n\n"}
{"name":"Set.seq_singleton","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set (α → β)\na : α\n⊢ Eq (s.seq (Singleton.singleton a)) (Set.image (fun f => f a) s)","decl":"theorem seq_singleton {s : Set (α → β)} {a : α} : Set.seq s {a} = (fun f : α → β => f a) '' s :=\n  image2_singleton_right\n\n"}
{"name":"Set.seq_seq","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set (β → γ)\nt : Set (α → β)\nu : Set α\n⊢ Eq (s.seq (t.seq u)) (((Set.image (fun x1 x2 => Function.comp x1 x2) s).seq t).seq u)","decl":"theorem seq_seq {s : Set (β → γ)} {t : Set (α → β)} {u : Set α} :\n    seq s (seq t u) = seq (seq ((· ∘ ·) '' s) t) u := by\n  simp only [seq_eq_image2, image2_image_left]\n  exact .symm <| image2_assoc fun _ _ _ ↦ rfl\n\n"}
{"name":"Set.image_seq","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : β → γ\ns : Set (α → β)\nt : Set α\n⊢ Eq (Set.image f (s.seq t)) ((Set.image (fun x => Function.comp f x) s).seq t)","decl":"theorem image_seq {f : β → γ} {s : Set (α → β)} {t : Set α} :\n    f '' seq s t = seq ((f ∘ ·) '' s) t := by\n  simp only [seq, image_image2, image2_image_left, comp_apply]\n\n"}
{"name":"Set.prod_eq_seq","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Eq (SProd.sprod s t) ((Set.image Prod.mk s).seq t)","decl":"theorem prod_eq_seq {s : Set α} {t : Set β} : s ×ˢ t = (Prod.mk '' s).seq t := by\n  rw [seq_eq_image2, image2_image_left, image2_mk_eq_prod]\n\n"}
{"name":"Set.prod_image_seq_comm","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Eq ((Set.image Prod.mk s).seq t) ((Set.image (fun b a => { fst := a, snd := b }) t).seq s)","decl":"theorem prod_image_seq_comm (s : Set α) (t : Set β) :\n    (Prod.mk '' s).seq t = seq ((fun b a => (a, b)) '' t) s := by\n  rw [← prod_eq_seq, ← image_swap_prod, prod_eq_seq, image_seq, ← image_comp]; rfl\n\n"}
{"name":"Set.image2_eq_seq","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\ns : Set α\nt : Set β\n⊢ Eq (Set.image2 f s t) ((Set.image f s).seq t)","decl":"theorem image2_eq_seq (f : α → β → γ) (s : Set α) (t : Set β) : image2 f s t = seq (f '' s) t := by\n  rw [seq_eq_image2, image2_image_left]\n\n"}
{"name":"Set.pi_def","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nπ : α → Type u_12\ni : Set α\ns : (a : α) → Set (π a)\n⊢ Eq (i.pi s) (Set.iInter fun a => Set.iInter fun h => Set.preimage (Function.eval a) (s a))","decl":"theorem pi_def (i : Set α) (s : ∀ a, Set (π a)) : pi i s = ⋂ a ∈ i, eval a ⁻¹' s a := by\n  ext\n  simp\n\n"}
{"name":"Set.univ_pi_eq_iInter","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nπ : α → Type u_12\nt : (i : α) → Set (π i)\n⊢ Eq (Set.univ.pi t) (Set.iInter fun i => Set.preimage (Function.eval i) (t i))","decl":"theorem univ_pi_eq_iInter (t : ∀ i, Set (π i)) : pi univ t = ⋂ i, eval i ⁻¹' t i := by\n  simp only [pi_def, iInter_true, mem_univ]\n\n"}
{"name":"Set.pi_diff_pi_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nπ : α → Type u_12\ni : Set α\ns t : (a : α) → Set (π a)\n⊢ HasSubset.Subset (SDiff.sdiff (i.pi s) (i.pi t)) (Set.iUnion fun a => Set.iUnion fun h => Set.preimage (Function.eval a) (SDiff.sdiff (s a) (t a)))","decl":"theorem pi_diff_pi_subset (i : Set α) (s t : ∀ a, Set (π a)) :\n    pi i s \\ pi i t ⊆ ⋃ a ∈ i, eval a ⁻¹' (s a \\ t a) := by\n  refine diff_subset_comm.2 fun x hx a ha => ?_\n  simp only [mem_diff, mem_pi, mem_iUnion, not_exists, mem_preimage, not_and, not_not,\n    eval_apply] at hx\n  exact hx.2 _ ha (hx.1 _ ha)\n\n"}
{"name":"Set.iUnion_univ_pi","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nπ : α → Type u_12\nι : α → Type u_13\nt : (a : α) → ι a → Set (π a)\n⊢ Eq (Set.iUnion fun x => Set.univ.pi fun a => t a (x a)) (Set.univ.pi fun a => Set.iUnion fun j => t a j)","decl":"theorem iUnion_univ_pi {ι : α → Type*} (t : (a : α) → ι a → Set (π a)) :\n    ⋃ x : (a : α) → ι a, pi univ (fun a => t a (x a)) = pi univ fun a => ⋃ j : ι a, t a j := by\n  ext\n  simp [Classical.skolem]\n\n"}
{"name":"Set.directedOn_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nr : α → α → Prop\nf : ι → Set α\nhd : Directed (fun x1 x2 => HasSubset.Subset x1 x2) f\nh : ∀ (x : ι), DirectedOn r (f x)\n⊢ DirectedOn r (Set.iUnion fun x => f x)","decl":"theorem directedOn_iUnion {r} {f : ι → Set α} (hd : Directed (· ⊆ ·) f)\n    (h : ∀ x, DirectedOn r (f x)) : DirectedOn r (⋃ x, f x) := by\n  simp only [DirectedOn, exists_prop, mem_iUnion, exists_imp]\n  exact fun a₁ b₁ fb₁ a₂ b₂ fb₂ =>\n    let ⟨z, zb₁, zb₂⟩ := hd b₁ b₂\n    let ⟨x, xf, xa₁, xa₂⟩ := h z a₁ (zb₁ fb₁) a₂ (zb₂ fb₂)\n    ⟨x, ⟨z, xf⟩, xa₁, xa₂⟩\n\n"}
{"name":"Set.directedOn_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nr : α → α → Prop\nS : Set (Set α)\nhd : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) S\nh : ∀ (x : Set α), Membership.mem S x → DirectedOn r x\n⊢ DirectedOn r S.sUnion","decl":"theorem directedOn_sUnion {r} {S : Set (Set α)} (hd : DirectedOn (· ⊆ ·) S)\n    (h : ∀ x ∈ S, DirectedOn r x) : DirectedOn r (⋃₀ S) := by\n  rw [sUnion_eq_iUnion]\n  exact directedOn_iUnion (directedOn_iff_directed.mp hd) (fun i ↦ h i.1 i.2)\n\n"}
{"name":"Function.Surjective.iUnion_comp","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι₂ : Sort u_7\nf : ι → ι₂\nhf : Function.Surjective f\ng : ι₂ → Set α\n⊢ Eq (Set.iUnion fun x => g (f x)) (Set.iUnion fun y => g y)","decl":"theorem iUnion_comp {f : ι → ι₂} (hf : Surjective f) (g : ι₂ → Set α) : ⋃ x, g (f x) = ⋃ y, g y :=\n  hf.iSup_comp g\n\n"}
{"name":"Function.Surjective.iInter_comp","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nι₂ : Sort u_7\nf : ι → ι₂\nhf : Function.Surjective f\ng : ι₂ → Set α\n⊢ Eq (Set.iInter fun x => g (f x)) (Set.iInter fun y => g y)","decl":"theorem iInter_comp {f : ι → ι₂} (hf : Surjective f) (g : ι₂ → Set α) : ⋂ x, g (f x) = ⋂ y, g y :=\n  hf.iInf_comp g\n\n"}
{"name":"Set.disjoint_iUnion_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nt : Set α\nι : Sort u_12\ns : ι → Set α\n⊢ Iff (Disjoint (Set.iUnion fun i => s i) t) (∀ (i : ι), Disjoint (s i) t)","decl":"@[simp]\ntheorem disjoint_iUnion_left {ι : Sort*} {s : ι → Set α} :\n    Disjoint (⋃ i, s i) t ↔ ∀ i, Disjoint (s i) t :=\n  iSup_disjoint_iff\n\n"}
{"name":"Set.disjoint_iUnion_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nt : Set α\nι : Sort u_12\ns : ι → Set α\n⊢ Iff (Disjoint t (Set.iUnion fun i => s i)) (∀ (i : ι), Disjoint t (s i))","decl":"@[simp]\ntheorem disjoint_iUnion_right {ι : Sort*} {s : ι → Set α} :\n    Disjoint t (⋃ i, s i) ↔ ∀ i, Disjoint t (s i) :=\n  disjoint_iSup_iff\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.disjoint_iUnion₂_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : (i : ι) → κ i → Set α\nt : Set α\n⊢ Iff (Disjoint (Set.iUnion fun i => Set.iUnion fun j => s i j) t) (∀ (i : ι) (j : κ i), Disjoint (s i j) t)","decl":"theorem disjoint_iUnion₂_left {s : ∀ i, κ i → Set α} {t : Set α} :\n    Disjoint (⋃ (i) (j), s i j) t ↔ ∀ i j, Disjoint (s i j) t :=\n  iSup₂_disjoint_iff\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.disjoint_iUnion₂_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ns : Set α\nt : (i : ι) → κ i → Set α\n⊢ Iff (Disjoint s (Set.iUnion fun i => Set.iUnion fun j => t i j)) (∀ (i : ι) (j : κ i), Disjoint s (t i j))","decl":"theorem disjoint_iUnion₂_right {s : Set α} {t : ∀ i, κ i → Set α} :\n    Disjoint s (⋃ (i) (j), t i j) ↔ ∀ i j, Disjoint s (t i j) :=\n  disjoint_iSup₂_iff\n\n"}
{"name":"Set.disjoint_sUnion_left","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\nt : Set α\n⊢ Iff (Disjoint S.sUnion t) (∀ (s : Set α), Membership.mem S s → Disjoint s t)","decl":"@[simp]\ntheorem disjoint_sUnion_left {S : Set (Set α)} {t : Set α} :\n    Disjoint (⋃₀ S) t ↔ ∀ s ∈ S, Disjoint s t :=\n  sSup_disjoint_iff\n\n"}
{"name":"Set.disjoint_sUnion_right","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ns : Set α\nS : Set (Set α)\n⊢ Iff (Disjoint s S.sUnion) (∀ (t : Set α), Membership.mem S t → Disjoint s t)","decl":"@[simp]\ntheorem disjoint_sUnion_right {s : Set α} {S : Set (Set α)} :\n    Disjoint s (⋃₀ S) ↔ ∀ t ∈ S, Disjoint s t :=\n  disjoint_sSup_iff\n\n"}
{"name":"Set.biUnion_compl_eq_of_pairwise_disjoint_of_iUnion_eq_univ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Type u_12\nEs : ι → Set α\nEs_union : Eq (Set.iUnion fun i => Es i) Set.univ\nEs_disj : Pairwise fun i j => Disjoint (Es i) (Es j)\nI : Set ι\n⊢ Eq (HasCompl.compl (Set.iUnion fun i => Set.iUnion fun h => Es i)) (Set.iUnion fun i => Set.iUnion fun h => Es i)","decl":"lemma biUnion_compl_eq_of_pairwise_disjoint_of_iUnion_eq_univ {ι : Type*} {Es : ι → Set α}\n    (Es_union : ⋃ i, Es i = univ) (Es_disj : Pairwise fun i j ↦ Disjoint (Es i) (Es j))\n    (I : Set ι) :\n    (⋃ i ∈ I, Es i)ᶜ = ⋃ i ∈ Iᶜ, Es i := by\n  ext x\n  obtain ⟨i, hix⟩ : ∃ i, x ∈ Es i := by simp [← mem_iUnion, Es_union]\n  have obs : ∀ (J : Set ι), x ∈ ⋃ j ∈ J, Es j ↔ i ∈ J := by\n    refine fun J ↦ ⟨?_, fun i_in_J ↦ by simpa only [mem_iUnion, exists_prop] using ⟨i, i_in_J, hix⟩⟩\n    intro x_in_U\n    simp only [mem_iUnion, exists_prop] at x_in_U\n    obtain ⟨j, j_in_J, hjx⟩ := x_in_U\n    rwa [show i = j by by_contra i_ne_j; exact Disjoint.ne_of_mem (Es_disj i_ne_j) hix hjx rfl]\n  have obs' : ∀ (J : Set ι), x ∈ (⋃ j ∈ J, Es j)ᶜ ↔ i ∉ J :=\n    fun J ↦ by simpa only [mem_compl_iff, not_iff_not] using obs J\n  rw [obs, obs', mem_compl_iff]\n\n"}
{"name":"Set.nonempty_iInter_Iic_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ninst✝ : Preorder α\nf : ι → α\n⊢ Iff (Set.iInter fun i => Set.Iic (f i)).Nonempty (BddBelow (Set.range f))","decl":"lemma nonempty_iInter_Iic_iff [Preorder α] {f : ι → α} :\n    (⋂ i, Iic (f i)).Nonempty ↔ BddBelow (range f) := by\n  have : (⋂ (i : ι), Iic (f i)) = lowerBounds (range f) := by\n    ext c; simp [lowerBounds]\n  simp [this, BddBelow]\n\n"}
{"name":"Set.nonempty_iInter_Ici_iff","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ninst✝ : Preorder α\nf : ι → α\n⊢ Iff (Set.iInter fun i => Set.Ici (f i)).Nonempty (BddAbove (Set.range f))","decl":"lemma nonempty_iInter_Ici_iff [Preorder α] {f : ι → α} :\n    (⋂ i, Ici (f i)).Nonempty ↔ BddAbove (range f) :=\n  nonempty_iInter_Iic_iff (α := αᵒᵈ)\n\n"}
{"name":"Set.Ici_iSup","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ninst✝ : CompleteLattice α\nf : ι → α\n⊢ Eq (Set.Ici (iSup fun i => f i)) (Set.iInter fun i => Set.Ici (f i))","decl":"theorem Ici_iSup (f : ι → α) : Ici (⨆ i, f i) = ⋂ i, Ici (f i) :=\n  ext fun _ => by simp only [mem_Ici, iSup_le_iff, mem_iInter]\n\n"}
{"name":"Set.Iic_iInf","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\ninst✝ : CompleteLattice α\nf : ι → α\n⊢ Eq (Set.Iic (iInf fun i => f i)) (Set.iInter fun i => Set.Iic (f i))","decl":"theorem Iic_iInf (f : ι → α) : Iic (⨅ i, f i) = ⋂ i, Iic (f i) :=\n  ext fun _ => by simp only [mem_Iic, le_iInf_iff, mem_iInter]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.Ici_iSup₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ninst✝ : CompleteLattice α\nf : (i : ι) → κ i → α\n⊢ Eq (Set.Ici (iSup fun i => iSup fun j => f i j)) (Set.iInter fun i => Set.iInter fun j => Set.Ici (f i j))","decl":"theorem Ici_iSup₂ (f : ∀ i, κ i → α) : Ici (⨆ (i) (j), f i j) = ⋂ (i) (j), Ici (f i j) := by\n  simp_rw [Ici_iSup]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.Iic_iInf₂","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nι : Sort u_5\nκ : ι → Sort u_8\ninst✝ : CompleteLattice α\nf : (i : ι) → κ i → α\n⊢ Eq (Set.Iic (iInf fun i => iInf fun j => f i j)) (Set.iInter fun i => Set.iInter fun j => Set.Iic (f i j))","decl":"theorem Iic_iInf₂ (f : ∀ i, κ i → α) : Iic (⨅ (i) (j), f i j) = ⋂ (i) (j), Iic (f i j) := by\n  simp_rw [Iic_iInf]\n\n"}
{"name":"Set.Ici_sSup","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Eq (Set.Ici (SupSet.sSup s)) (Set.iInter fun a => Set.iInter fun h => Set.Ici a)","decl":"theorem Ici_sSup (s : Set α) : Ici (sSup s) = ⋂ a ∈ s, Ici a := by rw [sSup_eq_iSup, Ici_iSup₂]\n\n"}
{"name":"Set.Iic_sInf","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Eq (Set.Iic (InfSet.sInf s)) (Set.iInter fun a => Set.iInter fun h => Set.Iic a)","decl":"theorem Iic_sInf (s : Set α) : Iic (sInf s) = ⋂ a ∈ s, Iic a := by rw [sInf_eq_iInf, Iic_iInf₂]\n\n"}
{"name":"Set.biUnion_diff_biUnion_subset","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α → Set β\ns₁ s₂ : Set α\n⊢ HasSubset.Subset (SDiff.sdiff (Set.iUnion fun x => Set.iUnion fun h => t x) (Set.iUnion fun x => Set.iUnion fun h => t x)) (Set.iUnion fun x => Set.iUnion fun h => t x)","decl":"theorem biUnion_diff_biUnion_subset (s₁ s₂ : Set α) :\n    ((⋃ x ∈ s₁, t x) \\ ⋃ x ∈ s₂, t x) ⊆ ⋃ x ∈ s₁ \\ s₂, t x := by\n  simp only [diff_subset_iff, ← biUnion_union]\n  apply biUnion_subset_biUnion_left\n  rw [union_diff_self]\n  apply subset_union_right\n\n"}
{"name":"Set.sigmaToiUnion_surjective","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α → Set β\n⊢ Function.Surjective (Set.sigmaToiUnion t)","decl":"theorem sigmaToiUnion_surjective : Surjective (sigmaToiUnion t)\n  | ⟨b, hb⟩ =>\n    have : ∃ a, b ∈ t a := by simpa using hb\n    let ⟨a, hb⟩ := this\n    ⟨⟨a, b, hb⟩, rfl⟩\n\n"}
{"name":"Set.sigmaToiUnion_injective","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α → Set β\nh : Pairwise (Function.onFun Disjoint t)\n⊢ Function.Injective (Set.sigmaToiUnion t)","decl":"theorem sigmaToiUnion_injective (h : Pairwise (Disjoint on t)) :\n    Injective (sigmaToiUnion t)\n  | ⟨a₁, b₁, h₁⟩, ⟨a₂, b₂, h₂⟩, eq =>\n    have b_eq : b₁ = b₂ := congr_arg Subtype.val eq\n    have a_eq : a₁ = a₂ :=\n      by_contradiction fun ne =>\n        have : b₁ ∈ t a₁ ∩ t a₂ := ⟨h₁, b_eq.symm ▸ h₂⟩\n        (h ne).le_bot this\n    Sigma.eq a_eq <| Subtype.eq <| by subst b_eq; subst a_eq; rfl\n\n"}
{"name":"Set.sigmaToiUnion_bijective","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α → Set β\nh : Pairwise (Function.onFun Disjoint t)\n⊢ Function.Bijective (Set.sigmaToiUnion t)","decl":"theorem sigmaToiUnion_bijective (h : Pairwise (Disjoint on t)) :\n    Bijective (sigmaToiUnion t) :=\n  ⟨sigmaToiUnion_injective t h, sigmaToiUnion_surjective t⟩\n\n"}
{"name":"Set.iUnion_ge_eq_iUnion_nat_add","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nu : Nat → Set α\nn : Nat\n⊢ Eq (Set.iUnion fun i => Set.iUnion fun h => u i) (Set.iUnion fun i => u (HAdd.hAdd i n))","decl":"theorem iUnion_ge_eq_iUnion_nat_add (u : ℕ → Set α) (n : ℕ) : ⋃ i ≥ n, u i = ⋃ i, u (i + n) :=\n  iSup_ge_eq_iSup_nat_add u n\n\n"}
{"name":"Set.iInter_ge_eq_iInter_nat_add","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nu : Nat → Set α\nn : Nat\n⊢ Eq (Set.iInter fun i => Set.iInter fun h => u i) (Set.iInter fun i => u (HAdd.hAdd i n))","decl":"theorem iInter_ge_eq_iInter_nat_add (u : ℕ → Set α) (n : ℕ) : ⋂ i ≥ n, u i = ⋂ i, u (i + n) :=\n  iInf_ge_eq_iInf_nat_add u n\n\n"}
{"name":"Monotone.iUnion_nat_add","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nf : Nat → Set α\nhf : Monotone f\nk : Nat\n⊢ Eq (Set.iUnion fun n => f (HAdd.hAdd n k)) (Set.iUnion fun n => f n)","decl":"theorem _root_.Monotone.iUnion_nat_add {f : ℕ → Set α} (hf : Monotone f) (k : ℕ) :\n    ⋃ n, f (n + k) = ⋃ n, f n :=\n  hf.iSup_nat_add k\n\n"}
{"name":"Antitone.iInter_nat_add","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nf : Nat → Set α\nhf : Antitone f\nk : Nat\n⊢ Eq (Set.iInter fun n => f (HAdd.hAdd n k)) (Set.iInter fun n => f n)","decl":"theorem _root_.Antitone.iInter_nat_add {f : ℕ → Set α} (hf : Antitone f) (k : ℕ) :\n    ⋂ n, f (n + k) = ⋂ n, f n :=\n  hf.iInf_nat_add k\n\n/- Porting note: removing `simp`. LHS does not simplify. Possible linter bug. Zulip discussion:\nhttps://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/complete_lattice.20and.20has_sup/near/316497982\n-/\n"}
{"name":"Set.iUnion_iInter_ge_nat_add","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nf : Nat → Set α\nk : Nat\n⊢ Eq (Set.iUnion fun n => Set.iInter fun i => Set.iInter fun h => f (HAdd.hAdd i k)) (Set.iUnion fun n => Set.iInter fun i => Set.iInter fun h => f i)","decl":"theorem iUnion_iInter_ge_nat_add (f : ℕ → Set α) (k : ℕ) :\n    ⋃ n, ⋂ i ≥ n, f (i + k) = ⋃ n, ⋂ i ≥ n, f i :=\n  iSup_iInf_ge_nat_add f k\n\n"}
{"name":"Set.union_iUnion_nat_succ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nu : Nat → Set α\n⊢ Eq (Union.union (u 0) (Set.iUnion fun i => u (HAdd.hAdd i 1))) (Set.iUnion fun i => u i)","decl":"theorem union_iUnion_nat_succ (u : ℕ → Set α) : (u 0 ∪ ⋃ i, u (i + 1)) = ⋃ i, u i :=\n  sup_iSup_nat_succ u\n\n"}
{"name":"Set.inter_iInter_nat_succ","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nu : Nat → Set α\n⊢ Eq (Inter.inter (u 0) (Set.iInter fun i => u (HAdd.hAdd i 1))) (Set.iInter fun i => u i)","decl":"theorem inter_iInter_nat_succ (u : ℕ → Set α) : (u 0 ∩ ⋂ i, u (i + 1)) = ⋂ i, u i :=\n  inf_iInf_nat_succ u\n\n"}
{"name":"iSup_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ninst✝ : CompleteLattice β\ns : ι → Set α\nf : α → β\n⊢ Eq (iSup fun a => iSup fun h => f a) (iSup fun i => iSup fun a => iSup fun h => f a)","decl":"theorem iSup_iUnion (s : ι → Set α) (f : α → β) : ⨆ a ∈ ⋃ i, s i, f a = ⨆ (i) (a ∈ s i), f a := by\n  rw [iSup_comm]\n  simp_rw [mem_iUnion, iSup_exists]\n\n"}
{"name":"iInf_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ninst✝ : CompleteLattice β\ns : ι → Set α\nf : α → β\n⊢ Eq (iInf fun a => iInf fun h => f a) (iInf fun i => iInf fun a => iInf fun h => f a)","decl":"theorem iInf_iUnion (s : ι → Set α) (f : α → β) : ⨅ a ∈ ⋃ i, s i, f a = ⨅ (i) (a ∈ s i), f a :=\n  iSup_iUnion (β := βᵒᵈ) s f\n\n"}
{"name":"sSup_iUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\nι : Sort u_5\ninst✝ : CompleteLattice β\nt : ι → Set β\n⊢ Eq (SupSet.sSup (Set.iUnion fun i => t i)) (iSup fun i => SupSet.sSup (t i))","decl":"theorem sSup_iUnion (t : ι → Set β) : sSup (⋃ i, t i) = ⨆ i, sSup (t i) := by\n  simp_rw [sSup_eq_iSup, iSup_iUnion]\n\n"}
{"name":"sSup_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\ninst✝ : CompleteLattice β\ns : Set (Set β)\n⊢ Eq (SupSet.sSup s.sUnion) (iSup fun t => iSup fun h => SupSet.sSup t)","decl":"theorem sSup_sUnion (s : Set (Set β)) : sSup (⋃₀ s) = ⨆ t ∈ s, sSup t := by\n  simp only [sUnion_eq_biUnion, sSup_eq_iSup, iSup_iUnion]\n\n"}
{"name":"sInf_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"β : Type u_2\ninst✝ : CompleteLattice β\ns : Set (Set β)\n⊢ Eq (InfSet.sInf s.sUnion) (iInf fun t => iInf fun h => InfSet.sInf t)","decl":"theorem sInf_sUnion (s : Set (Set β)) : sInf (⋃₀ s) = ⨅ t ∈ s, sInf t :=\n  sSup_sUnion (β := βᵒᵈ) s\n\n"}
{"name":"iSup_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice β\nS : Set (Set α)\nf : α → β\n⊢ Eq (iSup fun x => iSup fun h => f x) (iSup fun s => iSup fun h => iSup fun x => iSup fun h => f x)","decl":"lemma iSup_sUnion (S : Set (Set α)) (f : α → β) :\n    (⨆ x ∈ ⋃₀ S, f x) = ⨆ (s ∈ S) (x ∈ s), f x := by\n  rw [sUnion_eq_iUnion, iSup_iUnion, ← iSup_subtype'']\n\n"}
{"name":"iInf_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice β\nS : Set (Set α)\nf : α → β\n⊢ Eq (iInf fun x => iInf fun h => f x) (iInf fun s => iInf fun h => iInf fun x => iInf fun h => f x)","decl":"lemma iInf_sUnion (S : Set (Set α)) (f : α → β) :\n    (⨅ x ∈ ⋃₀ S, f x) = ⨅ (s ∈ S) (x ∈ s), f x := by\n  rw [sUnion_eq_iUnion, iInf_iUnion, ← iInf_subtype'']\n\n"}
{"name":"forall_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\np : α → Prop\n⊢ Iff (∀ (x : α), Membership.mem S.sUnion x → p x) (∀ (s : Set α), Membership.mem S s → ∀ (x : α), Membership.mem s x → p x)","decl":"lemma forall_sUnion {S : Set (Set α)} {p : α → Prop} :\n    (∀ x ∈ ⋃₀ S, p x) ↔ ∀ s ∈ S, ∀ x ∈ s, p x := by\n  simp_rw [← iInf_Prop_eq, iInf_sUnion]\n\n"}
{"name":"exists_sUnion","module":"Mathlib.Data.Set.Lattice","initialProofState":"α : Type u_1\nS : Set (Set α)\np : α → Prop\n⊢ Iff (Exists fun x => And (Membership.mem S.sUnion x) (p x)) (Exists fun s => And (Membership.mem S s) (Exists fun x => And (Membership.mem s x) (p x)))","decl":"lemma exists_sUnion {S : Set (Set α)} {p : α → Prop} :\n    (∃ x ∈ ⋃₀ S, p x) ↔ ∃ s ∈ S, ∃ x ∈ s, p x := by\n  simp_rw [← exists_prop, ← iSup_Prop_eq, iSup_sUnion]\n\n"}
