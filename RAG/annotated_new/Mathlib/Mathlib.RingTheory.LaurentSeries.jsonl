{"name":"LaurentSeries.hasseDeriv_coeff","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nV : Type u_2\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\nk : Nat\nf : LaurentSeries V\nn : Int\n⊢ Eq (((LaurentSeries.hasseDeriv R k) f).coeff n) (HSMul.hSMul (Ring.choose (HAdd.hAdd n ↑k) k) (f.coeff (HAdd.hAdd n ↑k)))","decl":"@[simp]\ntheorem hasseDeriv_coeff (k : ℕ) (f : LaurentSeries V) (n : ℤ) :\n    (hasseDeriv R k f).coeff n = Ring.choose (n + k) k • f.coeff (n + k) :=\n  rfl\n\n"}
{"name":"LaurentSeries.hasseDeriv_zero","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nV : Type u_2\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\n⊢ Eq (LaurentSeries.hasseDeriv R 0) LinearMap.id","decl":"@[simp]\ntheorem hasseDeriv_zero : hasseDeriv R 0 = LinearMap.id (M := LaurentSeries V) := by\n  ext f n\n  simp\n\n"}
{"name":"LaurentSeries.hasseDeriv_single_add","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nV : Type u_2\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\nk : Nat\nn : Int\nx : V\n⊢ Eq ((LaurentSeries.hasseDeriv R k) ((HahnSeries.single (HAdd.hAdd n ↑k)) x)) ((HahnSeries.single n) (HSMul.hSMul (Ring.choose (HAdd.hAdd n ↑k) k) x))","decl":"theorem hasseDeriv_single_add (k : ℕ) (n : ℤ) (x : V) :\n    hasseDeriv R k (single (n + k) x) = single n ((Ring.choose (n + k) k) • x) := by\n  ext m\n  dsimp only [hasseDeriv_coeff]\n  by_cases h : m = n\n  · simp [h]\n  · simp [h, show m + k ≠ n + k by omega]\n\n"}
{"name":"LaurentSeries.hasseDeriv_single","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nV : Type u_2\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\nk : Nat\nn : Int\nx : V\n⊢ Eq ((LaurentSeries.hasseDeriv R k) ((HahnSeries.single n) x)) ((HahnSeries.single (HSub.hSub n ↑k)) (HSMul.hSMul (Ring.choose n k) x))","decl":"@[simp]\ntheorem hasseDeriv_single (k : ℕ) (n : ℤ) (x : V) :\n    hasseDeriv R k (single n x) = single (n - k) ((Ring.choose n k) • x) := by\n  rw [← Int.sub_add_cancel n k, hasseDeriv_single_add, Int.sub_add_cancel n k]\n\n"}
{"name":"LaurentSeries.hasseDeriv_comp_coeff","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nV : Type u_2\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\nk l : Nat\nf : LaurentSeries V\nn : Int\n⊢ Eq (((LaurentSeries.hasseDeriv R k) ((LaurentSeries.hasseDeriv R l) f)).coeff n) ((HSMul.hSMul ((HAdd.hAdd k l).choose k) ((LaurentSeries.hasseDeriv R (HAdd.hAdd k l)) f)).coeff n)","decl":"theorem hasseDeriv_comp_coeff (k l : ℕ) (f : LaurentSeries V) (n : ℤ) :\n    (hasseDeriv R k (hasseDeriv R l f)).coeff n =\n      ((Nat.choose (k + l) k) • hasseDeriv R (k + l) f).coeff n := by\n  rw [coeff_nsmul]\n  simp only [hasseDeriv_coeff, Pi.smul_apply, Nat.cast_add]\n  rw [smul_smul, mul_comm, ← Ring.choose_add_smul_choose (n + k), add_assoc, Nat.choose_symm_add,\n    smul_assoc]\n\n"}
{"name":"LaurentSeries.hasseDeriv_comp","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nV : Type u_2\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\nk l : Nat\nf : LaurentSeries V\n⊢ Eq ((LaurentSeries.hasseDeriv R k) ((LaurentSeries.hasseDeriv R l) f)) (HSMul.hSMul ((HAdd.hAdd k l).choose k) ((LaurentSeries.hasseDeriv R (HAdd.hAdd k l)) f))","decl":"@[simp]\ntheorem hasseDeriv_comp (k l : ℕ) (f : LaurentSeries V) :\n    hasseDeriv R k (hasseDeriv R l f) = (k + l).choose k • hasseDeriv R (k + l) f := by\n  ext n\n  simp [hasseDeriv_comp_coeff k l f n]\n\n"}
{"name":"LaurentSeries.derivative_apply","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nV : Type u_2\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\nf : LaurentSeries V\n⊢ Eq ((LaurentSeries.derivative R) f) ((LaurentSeries.hasseDeriv R 1) f)","decl":"@[simp]\ntheorem derivative_apply (f : LaurentSeries V) : derivative R f = hasseDeriv R 1 f := by\n  exact rfl\n\n"}
{"name":"LaurentSeries.derivative_iterate","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nV : Type u_2\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\nk : Nat\nf : LaurentSeries V\n⊢ Eq (Nat.iterate (⇑(LaurentSeries.derivative R)) k f) (HSMul.hSMul k.factorial ((LaurentSeries.hasseDeriv R k) f))","decl":"theorem derivative_iterate (k : ℕ) (f : LaurentSeries V) :\n    (derivative R)^[k] f = k.factorial • (hasseDeriv R k f) := by\n  ext n\n  induction k generalizing f with\n  | zero => simp\n  | succ k ih =>\n    rw [Function.iterate_succ, Function.comp_apply, ih, derivative_apply, hasseDeriv_comp,\n      Nat.choose_symm_add, Nat.choose_one_right, Nat.factorial, mul_nsmul]\n\n"}
{"name":"LaurentSeries.derivative_iterate_coeff","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nV : Type u_2\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\nk : Nat\nf : LaurentSeries V\nn : Int\n⊢ Eq ((Nat.iterate (⇑(LaurentSeries.derivative R)) k f).coeff n) (HSMul.hSMul ((descPochhammer Int k).smeval (HAdd.hAdd n ↑k)) (f.coeff (HAdd.hAdd n ↑k)))","decl":"@[simp]\ntheorem derivative_iterate_coeff (k : ℕ) (f : LaurentSeries V) (n : ℤ) :\n    ((derivative R)^[k] f).coeff n = (descPochhammer ℤ k).smeval (n + k) • f.coeff (n + k) := by\n  rw [derivative_iterate, coeff_nsmul, Pi.smul_apply, hasseDeriv_coeff,\n    Ring.descPochhammer_eq_factorial_smul_choose, smul_assoc]\n\n"}
{"name":"LaurentSeries.coeff_coe_powerSeries","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx : PowerSeries R\nn : Nat\n⊢ Eq (((HahnSeries.ofPowerSeries Int R) x).coeff ↑n) ((PowerSeries.coeff R n) x)","decl":"@[simp]\ntheorem coeff_coe_powerSeries (x : R⟦X⟧) (n : ℕ) :\n    HahnSeries.coeff (x : R⸨X⸩) n = PowerSeries.coeff R n x := by\n  rw [ofPowerSeries_apply_coeff]\n\n"}
{"name":"LaurentSeries.powerSeriesPart_coeff","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx : LaurentSeries R\nn : Nat\n⊢ Eq ((PowerSeries.coeff R n) x.powerSeriesPart) (x.coeff (HAdd.hAdd (HahnSeries.order x) ↑n))","decl":"@[simp]\ntheorem powerSeriesPart_coeff (x : R⸨X⸩) (n : ℕ) :\n    PowerSeries.coeff R n x.powerSeriesPart = x.coeff (x.order + n) :=\n  PowerSeries.coeff_mk _ _\n\n"}
{"name":"LaurentSeries.powerSeriesPart_zero","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (LaurentSeries.powerSeriesPart 0) 0","decl":"@[simp]\ntheorem powerSeriesPart_zero : powerSeriesPart (0 : R⸨X⸩) = 0 := by\n  ext\n  simp [(PowerSeries.coeff _ _).map_zero] -- Note: this doesn't get picked up any more\n\n"}
{"name":"LaurentSeries.powerSeriesPart_eq_zero","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx : LaurentSeries R\n⊢ Iff (Eq x.powerSeriesPart 0) (Eq x 0)","decl":"@[simp]\ntheorem powerSeriesPart_eq_zero (x : R⸨X⸩) : x.powerSeriesPart = 0 ↔ x = 0 := by\n  constructor\n  · contrapose!\n    simp only [ne_eq]\n    intro h\n    rw [PowerSeries.ext_iff, not_forall]\n    refine ⟨0, ?_⟩\n    simp [coeff_order_ne_zero h]\n  · rintro rfl\n    simp\n\n"}
{"name":"LaurentSeries.single_order_mul_powerSeriesPart","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx : LaurentSeries R\n⊢ Eq (HMul.hMul ((HahnSeries.single (HahnSeries.order x)) 1) ((HahnSeries.ofPowerSeries Int R) x.powerSeriesPart)) x","decl":"@[simp]\ntheorem single_order_mul_powerSeriesPart (x : R⸨X⸩) :\n    (single x.order 1 : R⸨X⸩) * x.powerSeriesPart = x := by\n  ext n\n  rw [← sub_add_cancel n x.order, coeff_single_mul_add, sub_add_cancel, one_mul]\n  by_cases h : x.order ≤ n\n  · rw [Int.eq_natAbs_of_zero_le (sub_nonneg_of_le h), coeff_coe_powerSeries,\n      powerSeriesPart_coeff, ← Int.eq_natAbs_of_zero_le (sub_nonneg_of_le h),\n      add_sub_cancel]\n  · rw [ofPowerSeries_apply, embDomain_notin_range]\n    · contrapose! h\n      exact order_le_of_coeff_ne_zero h.symm\n    · contrapose! h\n      simp only [Set.mem_range, RelEmbedding.coe_mk, Function.Embedding.coeFn_mk] at h\n      obtain ⟨m, hm⟩ := h\n      rw [← sub_nonneg, ← hm]\n      simp only [Nat.cast_nonneg]\n\n"}
{"name":"LaurentSeries.ofPowerSeries_powerSeriesPart","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx : LaurentSeries R\n⊢ Eq ((HahnSeries.ofPowerSeries Int R) x.powerSeriesPart) (HMul.hMul ((HahnSeries.single (Neg.neg (HahnSeries.order x))) 1) x)","decl":"theorem ofPowerSeries_powerSeriesPart (x : R⸨X⸩) :\n    ofPowerSeries ℤ R x.powerSeriesPart = single (-x.order) 1 * x := by\n  refine Eq.trans ?_ (congr rfl x.single_order_mul_powerSeriesPart)\n  rw [← mul_assoc, single_mul_single, neg_add_cancel, mul_one, ← C_apply, C_one, one_mul]\n\n"}
{"name":"LaurentSeries.X_order_mul_powerSeriesPart","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\nf : LaurentSeries R\nhn : Eq (↑n) (HahnSeries.order f)\n⊢ Eq ((HahnSeries.ofPowerSeries Int R) (HMul.hMul (HPow.hPow PowerSeries.X n) f.powerSeriesPart)) f","decl":"theorem X_order_mul_powerSeriesPart {n : ℕ} {f : R⸨X⸩} (hn : n = f.order) :\n    (PowerSeries.X ^ n * f.powerSeriesPart : R⟦X⟧) = f := by\n  simp only [map_mul, map_pow, ofPowerSeries_X, single_pow, nsmul_eq_mul, mul_one, one_pow, hn,\n    single_order_mul_powerSeriesPart]\n\n"}
{"name":"LaurentSeries.coe_algebraMap","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq ⇑(algebraMap (PowerSeries R) (LaurentSeries R)) ⇑(HahnSeries.ofPowerSeries Int R)","decl":"@[simp]\ntheorem coe_algebraMap [CommSemiring R] :\n    ⇑(algebraMap R⟦X⟧ R⸨X⸩) = HahnSeries.ofPowerSeries ℤ R :=\n  rfl\n\n"}
{"name":"LaurentSeries.of_powerSeries_localization","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ IsLocalization (Submonoid.powers PowerSeries.X) (LaurentSeries R)","decl":"/-- The localization map from power series to Laurent series. -/\n@[simps (config := { rhsMd := .all, simpRhs := true })]\ninstance of_powerSeries_localization [CommRing R] :\n    IsLocalization (Submonoid.powers (PowerSeries.X : R⟦X⟧)) R⸨X⸩ where\n  map_units' := by\n    rintro ⟨_, n, rfl⟩\n    refine ⟨⟨single (n : ℤ) 1, single (-n : ℤ) 1, ?_, ?_⟩, ?_⟩\n    · simp\n    · simp\n    · dsimp; rw [ofPowerSeries_X_pow]\n  surj' z := by\n    by_cases h : 0 ≤ z.order\n    · refine ⟨⟨PowerSeries.X ^ Int.natAbs z.order * powerSeriesPart z, 1⟩, ?_⟩\n      simp only [RingHom.map_one, mul_one, RingHom.map_mul, coe_algebraMap, ofPowerSeries_X_pow,\n        Submonoid.coe_one]\n      rw [Int.natAbs_of_nonneg h, single_order_mul_powerSeriesPart]\n    · refine ⟨⟨powerSeriesPart z, PowerSeries.X ^ Int.natAbs z.order, ⟨_, rfl⟩⟩, ?_⟩\n      simp only [coe_algebraMap, ofPowerSeries_powerSeriesPart]\n      rw [mul_comm _ z]\n      refine congr rfl ?_\n      rw [ofPowerSeries_X_pow, Int.ofNat_natAbs_of_nonpos]\n      exact le_of_not_ge h\n  exists_of_eq {x y} := by\n    rw [coe_algebraMap, ofPowerSeries_injective.eq_iff]\n    rintro rfl\n    exact ⟨1, rfl⟩\n\n"}
{"name":"LaurentSeries.instIsFractionRingPowerSeries","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ IsFractionRing (PowerSeries K) (LaurentSeries K)","decl":"instance {K : Type*} [Field K] : IsFractionRing K⟦X⟧ K⸨X⸩ :=\n  IsLocalization.of_le (Submonoid.powers (PowerSeries.X : K⟦X⟧)) _\n    (powers_le_nonZeroDivisors_of_noZeroDivisors PowerSeries.X_ne_zero) fun _ hf =>\n    isUnit_of_mem_nonZeroDivisors <| map_mem_nonZeroDivisors _ HahnSeries.ofPowerSeries_injective hf\n\n"}
{"name":"PowerSeries.coe_zero","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq ((HahnSeries.ofPowerSeries Int R) 0) 0","decl":"@[norm_cast]\ntheorem coe_zero : ((0 : R⟦X⟧) : R⸨X⸩) = 0 :=\n  (ofPowerSeries ℤ R).map_zero\n\n"}
{"name":"PowerSeries.coe_one","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq ((HahnSeries.ofPowerSeries Int R) 1) 1","decl":"@[norm_cast]\ntheorem coe_one : ((1 : R⟦X⟧) : R⸨X⸩) = 1 :=\n  (ofPowerSeries ℤ R).map_one\n\n"}
{"name":"PowerSeries.coe_add","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g : PowerSeries R\n⊢ Eq ((HahnSeries.ofPowerSeries Int R) (HAdd.hAdd f g)) (HAdd.hAdd ((HahnSeries.ofPowerSeries Int R) f) ((HahnSeries.ofPowerSeries Int R) g))","decl":"@[norm_cast]\ntheorem coe_add : ((f + g : R⟦X⟧) : R⸨X⸩) = f + g :=\n  (ofPowerSeries ℤ R).map_add _ _\n\n"}
{"name":"PowerSeries.coe_sub","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R' : Type u_2\ninst✝ : Ring R'\nf' g' : PowerSeries R'\n⊢ Eq ((HahnSeries.ofPowerSeries Int R') (HSub.hSub f' g')) (HSub.hSub ((HahnSeries.ofPowerSeries Int R') f') ((HahnSeries.ofPowerSeries Int R') g'))","decl":"@[norm_cast]\ntheorem coe_sub : ((f' - g' : R'⟦X⟧) : R'⸨X⸩) = f' - g' :=\n  (ofPowerSeries ℤ R').map_sub _ _\n\n"}
{"name":"PowerSeries.coe_neg","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R' : Type u_2\ninst✝ : Ring R'\nf' : PowerSeries R'\n⊢ Eq ((HahnSeries.ofPowerSeries Int R') (Neg.neg f')) (Neg.neg ((HahnSeries.ofPowerSeries Int R') f'))","decl":"@[norm_cast]\ntheorem coe_neg : ((-f' : R'⟦X⟧) : R'⸨X⸩) = -f' :=\n  (ofPowerSeries ℤ R').map_neg _\n\n"}
{"name":"PowerSeries.coe_mul","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf g : PowerSeries R\n⊢ Eq ((HahnSeries.ofPowerSeries Int R) (HMul.hMul f g)) (HMul.hMul ((HahnSeries.ofPowerSeries Int R) f) ((HahnSeries.ofPowerSeries Int R) g))","decl":"@[norm_cast]\ntheorem coe_mul : ((f * g : R⟦X⟧) : R⸨X⸩) = f * g :=\n  (ofPowerSeries ℤ R).map_mul _ _\n\n"}
{"name":"PowerSeries.coeff_coe","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : PowerSeries R\ni : Int\n⊢ Eq (((HahnSeries.ofPowerSeries Int R) f).coeff i) (ite (LT.lt i 0) 0 ((PowerSeries.coeff R i.natAbs) f))","decl":"theorem coeff_coe (i : ℤ) :\n    ((f : R⟦X⟧) : R⸨X⸩).coeff i =\n      if i < 0 then 0 else PowerSeries.coeff R i.natAbs f := by\n  cases i\n  · rw [Int.ofNat_eq_coe, coeff_coe_powerSeries, if_neg (Int.natCast_nonneg _).not_lt,\n      Int.natAbs_ofNat]\n  · rw [ofPowerSeries_apply, embDomain_notin_image_support, if_pos (Int.negSucc_lt_zero _)]\n    simp only [not_exists, RelEmbedding.coe_mk, Set.mem_image, not_and, Function.Embedding.coeFn_mk,\n      Ne, toPowerSeries_symm_apply_coeff, mem_support, imp_true_iff,\n      not_false_iff, reduceCtorEq]\n\n"}
{"name":"PowerSeries.coe_C","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\n⊢ Eq ((HahnSeries.ofPowerSeries Int R) ((PowerSeries.C R) r)) (HahnSeries.C r)","decl":"theorem coe_C (r : R) : ((C R r : R⟦X⟧) : R⸨X⸩) = HahnSeries.C r :=\n  ofPowerSeries_C _\n\n"}
{"name":"PowerSeries.coe_X","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq ((HahnSeries.ofPowerSeries Int R) PowerSeries.X) ((HahnSeries.single 1) 1)","decl":"theorem coe_X : ((X : R⟦X⟧) : R⸨X⸩) = single 1 1 :=\n  ofPowerSeries_X\n\n"}
{"name":"PowerSeries.coe_smul","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Type u_3\ninst✝¹ : Semiring S\ninst✝ : Module R S\nr : R\nx : PowerSeries S\n⊢ Eq ((HahnSeries.ofPowerSeries Int S) (HSMul.hSMul r x)) (HSMul.hSMul r ((HahnSeries.ofPowerSeries Int S) x))","decl":"@[simp, norm_cast]\ntheorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : S⟦X⟧) :\n    ((r • x : S⟦X⟧) : S⸨X⸩) = r • (ofPowerSeries ℤ S x) := by\n  ext\n  simp [coeff_coe, coeff_smul, smul_ite]\n\n"}
{"name":"PowerSeries.coe_pow","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : PowerSeries R\nn : Nat\n⊢ Eq ((HahnSeries.ofPowerSeries Int R) (HPow.hPow f n)) (HPow.hPow ((HahnSeries.ofPowerSeries Int R) f) n)","decl":"@[norm_cast]\ntheorem coe_pow (n : ℕ) : ((f ^ n : R⟦X⟧) : R⸨X⸩) = (ofPowerSeries ℤ R f) ^ n :=\n  (ofPowerSeries ℤ R).map_pow _ _\n\n"}
{"name":"RatFunc.coe_def","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nf : RatFunc F\n⊢ Eq (↑f) ((RatFunc.coeAlgHom F) f)","decl":"theorem coe_def : (f : F⸨X⸩) = coeAlgHom F f :=\n  rfl\n\n"}
{"name":"RatFunc.coe_num_denom","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nf : RatFunc F\n⊢ Eq (↑f) (HDiv.hDiv ((HahnSeries.ofPowerSeries Int F) ↑f.num) ((HahnSeries.ofPowerSeries Int F) ↑f.denom))","decl":"attribute [-instance] RatFunc.instCoePolynomial in\n-- avoids a diamond, see https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/compiling.20behaviour.20within.20one.20file\ntheorem coe_num_denom : (f : F⸨X⸩) = f.num / f.denom :=\n  liftAlgHom_apply _ _ f\n\n"}
{"name":"RatFunc.coe_injective","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\n⊢ Function.Injective RatFunc.coeToLaurentSeries_fun","decl":"theorem coe_injective : Function.Injective ((↑) : RatFunc F → F⸨X⸩) :=\n  liftAlgHom_injective _ (Polynomial.algebraMap_hahnSeries_injective _)\n\n-- Porting note: removed the `norm_cast` tag:\n-- `norm_cast: badly shaped lemma, rhs can't start with coe `↑(coeAlgHom F) f`\n"}
{"name":"RatFunc.coe_apply","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nf : RatFunc F\n⊢ Eq ((RatFunc.coeAlgHom F) f) ↑f","decl":"@[simp]\ntheorem coe_apply : coeAlgHom F f = f :=\n  rfl\n\n-- avoids a diamond, see https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/compiling.20behaviour.20within.20one.20file\n"}
{"name":"RatFunc.coe_coe","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nP : Polynomial F\n⊢ Eq ((HahnSeries.ofPowerSeries Int F) ↑P) ↑↑P","decl":"theorem coe_coe (P : Polynomial F) : ((P : F⟦X⟧) : F⸨X⸩) = (P : RatFunc F) := by\n  simp only [coePolynomial, coe_def, AlgHom.commutes, algebraMap_hahnSeries_apply]\n\n"}
{"name":"RatFunc.coe_zero","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ((0 : RatFunc F) : F⸨X⸩) = 0 :=\n  map_zero (coeAlgHom F)\n\n"}
{"name":"RatFunc.coe_ne_zero","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nhf : Ne f 0\n⊢ Ne (↑f) 0","decl":"theorem coe_ne_zero {f : Polynomial F} (hf : f ≠ 0) : (↑f : F⟦X⟧) ≠ 0 := by\n  simp only [ne_eq, Polynomial.coe_eq_zero_iff, hf, not_false_eq_true]\n\n"}
{"name":"RatFunc.coe_one","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coe_one : ((1 : RatFunc F) : F⸨X⸩) = 1 :=\n  map_one (coeAlgHom F)\n\n"}
{"name":"RatFunc.coe_add","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nf g : RatFunc F\n⊢ Eq (↑(HAdd.hAdd f g)) (HAdd.hAdd ↑f ↑g)","decl":"@[simp, norm_cast]\ntheorem coe_add : ((f + g : RatFunc F) : F⸨X⸩) = f + g :=\n  map_add (coeAlgHom F) _ _\n\n"}
{"name":"RatFunc.coe_sub","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nf g : RatFunc F\n⊢ Eq (↑(HSub.hSub f g)) (HSub.hSub ↑f ↑g)","decl":"@[simp, norm_cast]\ntheorem coe_sub : ((f - g : RatFunc F) : F⸨X⸩) = f - g :=\n  map_sub (coeAlgHom F) _ _\n\n"}
{"name":"RatFunc.coe_neg","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nf : RatFunc F\n⊢ Eq (↑(Neg.neg f)) (Neg.neg ↑f)","decl":"@[simp, norm_cast]\ntheorem coe_neg : ((-f : RatFunc F) : F⸨X⸩) = -f :=\n  map_neg (coeAlgHom F) _\n\n"}
{"name":"RatFunc.coe_mul","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nf g : RatFunc F\n⊢ Eq (↑(HMul.hMul f g)) (HMul.hMul ↑f ↑g)","decl":"@[simp, norm_cast]\ntheorem coe_mul : ((f * g : RatFunc F) : F⸨X⸩) = f * g :=\n  map_mul (coeAlgHom F) _ _\n\n"}
{"name":"RatFunc.coe_pow","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nf : RatFunc F\nn : Nat\n⊢ Eq (↑(HPow.hPow f n)) (HPow.hPow (↑f) n)","decl":"@[simp, norm_cast]\ntheorem coe_pow (n : ℕ) : ((f ^ n : RatFunc F) : F⸨X⸩) = (f : F⸨X⸩) ^ n :=\n  map_pow (coeAlgHom F) _ _\n\n"}
{"name":"RatFunc.coe_div","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nf g : RatFunc F\n⊢ Eq (↑(HDiv.hDiv f g)) (HDiv.hDiv ↑f ↑g)","decl":"@[simp, norm_cast]\ntheorem coe_div : ((f / g : RatFunc F) : F⸨X⸩) = (f : F⸨X⸩) / (g : F⸨X⸩) :=\n  map_div₀ (coeAlgHom F) _ _\n\n"}
{"name":"RatFunc.coe_C","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nr : F\n⊢ Eq (↑(RatFunc.C r)) (HahnSeries.C r)","decl":"@[simp, norm_cast]\ntheorem coe_C (r : F) : ((RatFunc.C r : RatFunc F) : F⸨X⸩) = HahnSeries.C r := by\n  rw [coe_num_denom, num_C, denom_C, Polynomial.coe_C, -- Porting note: removed `coe_C`\n    Polynomial.coe_one,\n    PowerSeries.coe_one, div_one]\n  simp only [algebraMap_eq_C, ofPowerSeries_C, C_apply]  -- Porting note: added\n\n-- TODO: generalize over other modules\n"}
{"name":"RatFunc.coe_smul","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nf : RatFunc F\nr : F\n⊢ Eq (↑(HSMul.hSMul r f)) (HSMul.hSMul r ↑f)","decl":"@[simp, norm_cast]\ntheorem coe_smul (r : F) : ((r • f : RatFunc F) : F⸨X⸩) = r • (f : F⸨X⸩) := by\n  rw [RatFunc.smul_eq_C_mul, ← C_mul_eq_smul, coe_mul, coe_C]\n\n-- Porting note: removed `norm_cast` because \"badly shaped lemma, rhs can't start with coe\"\n-- even though `single 1 1` is a bundled function application, not a \"real\" coercion\n"}
{"name":"RatFunc.coe_X","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\n⊢ Eq (↑RatFunc.X) ((HahnSeries.single 1) 1)","decl":"@[simp]\ntheorem coe_X : ((X : RatFunc F) : F⸨X⸩) = single 1 1 := by\n  rw [coe_num_denom, num_X, denom_X, Polynomial.coe_X, -- Porting note: removed `coe_C`\n     Polynomial.coe_one,\n     PowerSeries.coe_one, div_one]\n  simp only [ofPowerSeries_X]  -- Porting note: added\n\n"}
{"name":"RatFunc.single_one_eq_pow","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"R : Type u_2\ninst✝ : Ring R\nn : Nat\n⊢ Eq ((HahnSeries.single ↑n) 1) (HPow.hPow ((HahnSeries.single 1) 1) n)","decl":"theorem single_one_eq_pow {R : Type _} [Ring R] (n : ℕ) :\n    single (n : ℤ) (1 : R) = single (1 : ℤ) 1 ^ n := by\n  induction' n with n h_ind\n  · simp\n  · rw [← Int.ofNat_add_one_out, pow_succ', ← h_ind, HahnSeries.single_mul_single, one_mul,\n      add_comm]\n\n"}
{"name":"RatFunc.single_inv","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nd : Int\nα : F\nhα : Ne α 0\n⊢ Eq ((HahnSeries.single (Neg.neg d)) (Inv.inv α)) (Inv.inv ((HahnSeries.single d) α))","decl":"theorem single_inv (d : ℤ) {α : F} (hα : α ≠ 0) :\n    single (-d) (α⁻¹ : F) = (single (d : ℤ) (α : F))⁻¹ := by\n  apply eq_inv_of_mul_eq_one_right\n  simp [hα]\n\n"}
{"name":"RatFunc.single_zpow","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\nn : Int\n⊢ Eq ((HahnSeries.single n) 1) (HPow.hPow ((HahnSeries.single 1) 1) n)","decl":"theorem single_zpow (n : ℤ) :\n    single (n : ℤ) (1 : F) = single (1 : ℤ) 1 ^ n := by\n  induction' n with n_pos n_neg\n  · apply single_one_eq_pow\n  · rw [Int.negSucc_coe, Int.ofNat_add, Nat.cast_one, ← inv_one,\n      single_inv (n_neg + 1 : ℤ) one_ne_zero, zpow_neg, ← Nat.cast_one, ← Int.ofNat_add,\n      Nat.cast_one, inv_inj, zpow_natCast, single_one_eq_pow, inv_one]\n\n"}
{"name":"RatFunc.algebraMap_apply_div","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\np q : Polynomial F\n⊢ Eq ((algebraMap (RatFunc F) (LaurentSeries F)) (HDiv.hDiv ((algebraMap (Polynomial F) (RatFunc F)) p) ((algebraMap (Polynomial F) (RatFunc F)) q))) (HDiv.hDiv ((algebraMap (Polynomial F) (LaurentSeries F)) p) ((algebraMap (Polynomial F) (LaurentSeries F)) q))","decl":"theorem algebraMap_apply_div :\n    algebraMap (RatFunc F) F⸨X⸩ (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap F[X] F⸨X⸩ p / algebraMap _ _ q := by\n  -- Porting note: had to supply implicit arguments to `convert`\n  convert coe_div (algebraMap F[X] (RatFunc F) p) (algebraMap F[X] (RatFunc F) q) <;>\n    rw [← mk_one, coe_def, coeAlgHom, mk_eq_div, liftAlgHom_apply_div, map_one, div_one,\n      Algebra.ofId_apply]\n\n"}
{"name":"RatFunc.instIsScalarTowerPolynomialLaurentSeries","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"F : Type u\ninst✝ : Field F\n⊢ IsScalarTower (Polynomial F) (RatFunc F) (LaurentSeries F)","decl":"instance : IsScalarTower F[X] (RatFunc F) F⸨X⸩ :=\n  ⟨fun x y z => by\n    ext\n    simp⟩\n\n"}
{"name":"PowerSeries.intValuation_eq_of_coe","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nP : Polynomial K\n⊢ Eq ((Polynomial.idealX K).intValuation P) ((PowerSeries.idealX K).intValuation ↑P)","decl":"theorem intValuation_eq_of_coe (P : K[X]) :\n    (Polynomial.idealX K).intValuation P = (idealX K).intValuation (P : K⟦X⟧) := by\n  by_cases hP : P = 0\n  · rw [hP, Valuation.map_zero, Polynomial.coe_zero, Valuation.map_zero]\n  simp only [intValuation_apply]\n  rw [intValuationDef_if_neg _ hP, intValuationDef_if_neg _ <| coe_ne_zero hP]\n  simp only [idealX_span, ofAdd_neg, inv_inj, WithZero.coe_inj, EmbeddingLike.apply_eq_iff_eq,\n    Nat.cast_inj]\n  have span_ne_zero :\n    (Ideal.span {P} : Ideal K[X]) ≠ 0 ∧ (Ideal.span {Polynomial.X} : Ideal K[X]) ≠ 0 := by\n    simp only [Ideal.zero_eq_bot, ne_eq, Ideal.span_singleton_eq_bot, hP, Polynomial.X_ne_zero,\n      not_false_iff, and_self_iff]\n  have span_ne_zero' :\n    (Ideal.span {↑P} : Ideal K⟦X⟧) ≠ 0 ∧ ((idealX K).asIdeal : Ideal K⟦X⟧) ≠ 0 := by\n    simp only [Ideal.zero_eq_bot, ne_eq, Ideal.span_singleton_eq_bot, coe_eq_zero_iff, hP,\n      not_false_eq_true, true_and, (idealX K).3]\n  classical\n  rw [count_associates_factors_eq  (span_ne_zero).1\n    (Ideal.span_singleton_prime Polynomial.X_ne_zero|>.mpr prime_X) (span_ne_zero).2,\n    count_associates_factors_eq]\n  on_goal 1 => convert (normalized_count_X_eq_of_coe hP).symm\n  exacts [count_span_normalizedFactors_eq_of_normUnit hP Polynomial.normUnit_X prime_X,\n    count_span_normalizedFactors_eq_of_normUnit (coe_ne_zero hP) normUnit_X X_prime,\n    span_ne_zero'.1, (idealX K).isPrime, span_ne_zero'.2]\n\n"}
{"name":"PowerSeries.intValuation_X","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ Eq ((PowerSeries.idealX K).intValuationDef PowerSeries.X) ↑(Multiplicative.ofAdd (-1))","decl":"/-- The integral valuation of the power series `X : K⟦X⟧` equals `(ofAdd -1) : ℤₘ₀`-/\n@[simp]\ntheorem intValuation_X : (idealX K).intValuationDef X = ↑(Multiplicative.ofAdd (-1 : ℤ)) := by\n  rw [← Polynomial.coe_X, ← intValuation_apply, ← intValuation_eq_of_coe]\n  apply intValuation_singleton _ Polynomial.X_ne_zero (by rfl)\n\n"}
{"name":"RatFunc.valuation_eq_LaurentSeries_valuation","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nP : RatFunc K\n⊢ Eq ((Polynomial.idealX K).valuation P) ((PowerSeries.idealX K).valuation ↑P)","decl":"theorem valuation_eq_LaurentSeries_valuation (P : RatFunc K) :\n    (Polynomial.idealX K).valuation P = (PowerSeries.idealX K).valuation (P : K⸨X⸩) := by\n  refine RatFunc.induction_on' P ?_\n  intro f g h\n  rw [Polynomial.valuation_of_mk K f h, RatFunc.mk_eq_mk' f h, Eq.comm]\n  convert @valuation_of_mk' K⟦X⟧ _ _ K⸨X⸩ _ _ _ (PowerSeries.idealX K) f\n        ⟨g, mem_nonZeroDivisors_iff_ne_zero.2 <| coe_ne_zero h⟩\n  · simp only [IsFractionRing.mk'_eq_div, coe_div, LaurentSeries.coe_algebraMap, coe_coe]\n    rfl\n  exacts [intValuation_eq_of_coe _, intValuation_eq_of_coe _]\n\n"}
{"name":"LaurentSeries.valuation_X_pow","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\ns : Nat\n⊢ Eq (Valued.v (HPow.hPow ((HahnSeries.ofPowerSeries Int K) PowerSeries.X) s)) ↑(Multiplicative.ofAdd (Neg.neg ↑s))","decl":"theorem valuation_X_pow (s : ℕ) :\n    Valued.v (((X : K⟦X⟧) : K⸨X⸩) ^ s) = Multiplicative.ofAdd (-(s : ℤ)) := by\n  erw [map_pow, ← one_mul (s : ℤ), ← neg_mul (1 : ℤ) s, Int.ofAdd_mul,\n    WithZero.coe_zpow, ofAdd_neg, WithZero.coe_inv, zpow_natCast, valuation_of_algebraMap,\n    intValuation_toFun, intValuation_X, ofAdd_neg, WithZero.coe_inv, inv_pow]\n\n"}
{"name":"LaurentSeries.valuation_single_zpow","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\ns : Int\n⊢ Eq (Valued.v ((HahnSeries.single s) 1)) ↑(Multiplicative.ofAdd (Neg.neg s))","decl":"theorem valuation_single_zpow (s : ℤ) :\n    Valued.v (HahnSeries.single s (1 : K) : K⸨X⸩) =\n      Multiplicative.ofAdd (-(s : ℤ)) := by\n  have : Valued.v (1 : K⸨X⸩) = (1 : ℤₘ₀) := Valued.v.map_one\n  rw [← single_zero_one, ← add_neg_cancel s, ← mul_one 1, ← single_mul_single, map_mul,\n    mul_eq_one_iff_eq_inv₀] at this\n  · rw [this]\n    induction' s with s s\n    · rw [Int.ofNat_eq_coe, ← HahnSeries.ofPowerSeries_X_pow] at this\n      rw [Int.ofNat_eq_coe, ← this, PowerSeries.coe_pow, valuation_X_pow]\n    · simp only [Int.negSucc_coe, neg_neg, ← HahnSeries.ofPowerSeries_X_pow, PowerSeries.coe_pow,\n        valuation_X_pow, ofAdd_neg, WithZero.coe_inv, inv_inv]\n  · simp only [Valuation.ne_zero_iff, ne_eq, one_ne_zero, not_false_iff, HahnSeries.single_ne_zero]\n\n/- The coefficients of a power series vanish in degree strictly less than its valuation. -/\n"}
{"name":"LaurentSeries.coeff_zero_of_lt_intValuation","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nn d : Nat\nf : PowerSeries K\nH : LE.le (Valued.v ((HahnSeries.ofPowerSeries Int K) f)) ↑(Multiplicative.ofAdd (Neg.neg ↑d))\na✝ : LT.lt n d\n⊢ Eq ((PowerSeries.coeff K n) f) 0","decl":"theorem coeff_zero_of_lt_intValuation {n d : ℕ} {f : K⟦X⟧}\n    (H : Valued.v (f : K⸨X⸩) ≤ Multiplicative.ofAdd (-d : ℤ)) :\n    n < d → coeff K n f = 0 := by\n  intro hnd\n  apply (PowerSeries.X_pow_dvd_iff).mp _ n hnd\n  erw [← span_singleton_dvd_span_singleton_iff_dvd, ← Ideal.span_singleton_pow,\n    ← (intValuation_le_pow_iff_dvd (PowerSeries.idealX K) f d), ← intValuation_apply,\n    ← valuation_of_algebraMap (R := K⟦X⟧) (K := K⸨X⸩)]\n  exact H\n\n/- The valuation of a power series is the order of the first non-zero coefficient. -/\n"}
{"name":"LaurentSeries.intValuation_le_iff_coeff_lt_eq_zero","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nd : Nat\nf : PowerSeries K\n⊢ Iff (LE.le (Valued.v ((HahnSeries.ofPowerSeries Int K) f)) ↑(Multiplicative.ofAdd (Neg.neg ↑d))) (∀ (n : Nat), LT.lt n d → Eq ((PowerSeries.coeff K n) f) 0)","decl":"theorem intValuation_le_iff_coeff_lt_eq_zero {d : ℕ} (f : K⟦X⟧) :\n    Valued.v (f : K⸨X⸩) ≤ Multiplicative.ofAdd (-d : ℤ) ↔\n      ∀ n : ℕ, n < d → coeff K n f = 0 := by\n  have : PowerSeries.X ^ d ∣ f ↔ ∀ n : ℕ, n < d → (PowerSeries.coeff K n) f = 0 :=\n    ⟨PowerSeries.X_pow_dvd_iff.mp, PowerSeries.X_pow_dvd_iff.mpr⟩\n  erw [← this, valuation_of_algebraMap (PowerSeries.idealX K) f, ←\n    span_singleton_dvd_span_singleton_iff_dvd, ← Ideal.span_singleton_pow]\n  apply intValuation_le_pow_iff_dvd\n\n/- The coefficients of a Laurent series vanish in degree strictly less than its valuation. -/\n"}
{"name":"LaurentSeries.coeff_zero_of_lt_valuation","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nn D : Int\nf : LaurentSeries K\nH : LE.le (Valued.v f) ↑(Multiplicative.ofAdd (Neg.neg D))\na✝ : LT.lt n D\n⊢ Eq (f.coeff n) 0","decl":"theorem coeff_zero_of_lt_valuation {n D : ℤ} {f : K⸨X⸩}\n    (H : Valued.v f ≤ Multiplicative.ofAdd (-D)) : n < D → f.coeff n = 0 := by\n  intro hnd\n  by_cases h_n_ord : n < f.order\n  · exact coeff_eq_zero_of_lt_order h_n_ord\n  rw [not_lt] at h_n_ord\n  set F := powerSeriesPart f with hF\n  by_cases ord_nonpos : f.order ≤ 0\n  · obtain ⟨s, hs⟩ := Int.exists_eq_neg_ofNat ord_nonpos\n    obtain ⟨m, hm⟩ := Int.eq_ofNat_of_zero_le (neg_le_iff_add_nonneg.mp (hs ▸ h_n_ord))\n    obtain ⟨d, hd⟩ := Int.eq_ofNat_of_zero_le (a := D + s) (by omega)\n    rw [eq_add_neg_of_add_eq hm, add_comm, ← hs, ← powerSeriesPart_coeff]\n    apply (intValuation_le_iff_coeff_lt_eq_zero K F).mp _ m (by linarith)\n    rwa [hF, ofPowerSeries_powerSeriesPart f, hs, neg_neg, ← hd, neg_add_rev, ofAdd_add, map_mul,\n      ← ofPowerSeries_X_pow s, PowerSeries.coe_pow,  WithZero.coe_mul, valuation_X_pow K s,\n      mul_le_mul_left (by simp only [ne_eq, WithZero.coe_ne_zero, not_false_iff, zero_lt_iff])]\n  · rw [not_le] at ord_nonpos\n    obtain ⟨s, hs⟩ := Int.exists_eq_neg_ofNat (Int.neg_nonpos_of_nonneg (le_of_lt ord_nonpos))\n    obtain ⟨m, hm⟩ := Int.eq_ofNat_of_zero_le (a := n - s) (by omega)\n    obtain ⟨d, hd⟩ := Int.eq_ofNat_of_zero_le (a := D - s) (by omega)\n    rw [(sub_eq_iff_eq_add).mp hm, add_comm, ← neg_neg (s : ℤ), ← hs, neg_neg,\n      ← powerSeriesPart_coeff]\n    apply (intValuation_le_iff_coeff_lt_eq_zero K F).mp _ m (by linarith)\n    rwa [hF, ofPowerSeries_powerSeriesPart f, map_mul, ← hd, hs, neg_sub, sub_eq_add_neg,\n      ofAdd_add, valuation_single_zpow, neg_neg, WithZero.coe_mul,\n      mul_le_mul_left (by simp only [ne_eq, WithZero.coe_ne_zero, not_false_iff, zero_lt_iff])]\n\n/- The valuation of a Laurent series is the order of the first non-zero coefficient. -/\n"}
{"name":"LaurentSeries.valuation_le_iff_coeff_lt_eq_zero","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nD : Int\nf : LaurentSeries K\n⊢ Iff (LE.le (Valued.v f) ↑(Multiplicative.ofAdd (Neg.neg D))) (∀ (n : Int), LT.lt n D → Eq (f.coeff n) 0)","decl":"theorem valuation_le_iff_coeff_lt_eq_zero {D : ℤ} {f : K⸨X⸩} :\n    Valued.v f ≤ ↑(Multiplicative.ofAdd (-D : ℤ)) ↔ ∀ n : ℤ, n < D → f.coeff n = 0 := by\n  refine ⟨fun hnD n hn => coeff_zero_of_lt_valuation K hnD hn, fun h_val_f => ?_⟩\n  let F := powerSeriesPart f\n  by_cases ord_nonpos : f.order ≤ 0\n  · obtain ⟨s, hs⟩ := Int.exists_eq_neg_ofNat ord_nonpos\n    rw [← f.single_order_mul_powerSeriesPart, hs, map_mul, valuation_single_zpow, neg_neg, mul_comm,\n      ← le_mul_inv_iff₀, ofAdd_neg, WithZero.coe_inv, ← mul_inv, ← WithZero.coe_mul, ← ofAdd_add,\n      ← WithZero.coe_inv, ← ofAdd_neg]\n    · by_cases hDs : D + s ≤ 0\n      · apply le_trans ((PowerSeries.idealX K).valuation_le_one F)\n        rwa [← WithZero.coe_one, ← ofAdd_zero, WithZero.coe_le_coe, Multiplicative.ofAdd_le,\n          Left.nonneg_neg_iff]\n      · obtain ⟨d, hd⟩ := Int.eq_ofNat_of_zero_le (le_of_lt <| not_le.mp hDs)\n        rw [hd]\n        apply (intValuation_le_iff_coeff_lt_eq_zero K F).mpr\n        intro n hn\n        rw [powerSeriesPart_coeff f n, hs]\n        apply h_val_f\n        omega\n    · simp only [ne_eq, WithZero.coe_ne_zero, not_false_iff, zero_lt_iff]\n  · obtain ⟨s, hs⟩ := Int.exists_eq_neg_ofNat\n      <| neg_nonpos_of_nonneg <| le_of_lt <| not_le.mp ord_nonpos\n    rw [neg_inj] at hs\n    rw [← f.single_order_mul_powerSeriesPart, hs, map_mul, valuation_single_zpow, mul_comm,\n      ← le_mul_inv_iff₀, ofAdd_neg, WithZero.coe_inv, ← mul_inv, ← WithZero.coe_mul, ← ofAdd_add,\n      ← WithZero.coe_inv, ← ofAdd_neg, neg_add, neg_neg]\n    · by_cases hDs : D - s ≤ 0\n      · apply le_trans ((PowerSeries.idealX K).valuation_le_one F)\n        rw [← WithZero.coe_one, ← ofAdd_zero, WithZero.coe_le_coe, Multiplicative.ofAdd_le]\n        omega\n      · obtain ⟨d, hd⟩ := Int.eq_ofNat_of_zero_le (le_of_lt <| not_le.mp hDs)\n        rw [← neg_neg (-D + ↑s), ← sub_eq_neg_add, neg_sub, hd]\n        apply (intValuation_le_iff_coeff_lt_eq_zero K F).mpr\n        intro n hn\n        rw [powerSeriesPart_coeff f n, hs]\n        apply h_val_f (s + n)\n        omega\n    · simp only [ne_eq, WithZero.coe_ne_zero, not_false_iff, zero_lt_iff]\n\n/- Two Laurent series whose difference has small valuation have the same coefficients for\nsmall enough indices. -/\n"}
{"name":"LaurentSeries.eq_coeff_of_valuation_sub_lt","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nd n : Int\nf g : LaurentSeries K\nH : LE.le (Valued.v (HSub.hSub g f)) ↑(Multiplicative.ofAdd (Neg.neg d))\na✝ : LT.lt n d\n⊢ Eq (g.coeff n) (f.coeff n)","decl":"theorem eq_coeff_of_valuation_sub_lt {d n : ℤ} {f g : K⸨X⸩}\n    (H : Valued.v (g - f) ≤ ↑(Multiplicative.ofAdd (-d))) : n < d → g.coeff n = f.coeff n := by\n  by_cases triv : g = f\n  · exact fun _ => by rw [triv]\n  · intro hn\n    apply eq_of_sub_eq_zero\n    rw [← HahnSeries.coeff_sub]\n    apply coeff_zero_of_lt_valuation K H hn\n\n/- Every Laurent series of valuation less than `(1 : ℤₘ₀)` comes from a power series. -/\n"}
{"name":"LaurentSeries.val_le_one_iff_eq_coe","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nf : LaurentSeries K\n⊢ Iff (LE.le (Valued.v f) 1) (Exists fun F => Eq ((HahnSeries.ofPowerSeries Int K) F) f)","decl":"theorem val_le_one_iff_eq_coe (f : K⸨X⸩) : Valued.v f ≤ (1 : ℤₘ₀) ↔\n    ∃ F : K⟦X⟧, F = f := by\n  rw [← WithZero.coe_one, ← ofAdd_zero, ← neg_zero, valuation_le_iff_coeff_lt_eq_zero]\n  refine ⟨fun h => ⟨PowerSeries.mk fun n => f.coeff n, ?_⟩, ?_⟩\n  on_goal 1 => ext (_ | n)\n  · simp only [Int.ofNat_eq_coe, coeff_coe_powerSeries, coeff_mk]\n  on_goal 1 => simp only [h (Int.negSucc n) (Int.negSucc_lt_zero n)]\n  on_goal 2 => rintro ⟨F, rfl⟩ _ _\n  all_goals\n    apply HahnSeries.embDomain_notin_range\n    simp only [Nat.coe_castAddMonoidHom, RelEmbedding.coe_mk, Function.Embedding.coeFn_mk,\n      Set.mem_range, not_exists, Int.negSucc_lt_zero, reduceCtorEq]\n    intro\n  · simp only [not_false_eq_true]\n  · omega\n\n"}
{"name":"LaurentSeries.uniformContinuous_coeff","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nuK : UniformSpace K\nd : Int\n⊢ UniformContinuous fun f => f.coeff d","decl":"theorem uniformContinuous_coeff {uK : UniformSpace K} (d : ℤ) :\n    UniformContinuous fun f : K⸨X⸩ ↦ f.coeff d := by\n  refine uniformContinuous_iff_eventually.mpr fun S hS ↦ eventually_iff_exists_mem.mpr ?_\n  let γ : ℤₘ₀ˣ := Units.mk0 (↑(Multiplicative.ofAdd (-(d + 1)))) WithZero.coe_ne_zero\n  use {P | Valued.v (P.snd - P.fst) < ↑γ}\n  refine ⟨(Valued.hasBasis_uniformity K⸨X⸩ ℤₘ₀).mem_of_mem (by tauto), fun P hP ↦ ?_⟩\n  rw [eq_coeff_of_valuation_sub_lt K (le_of_lt hP) (lt_add_one _)]\n  exact mem_uniformity_of_eq hS rfl\n\n"}
{"name":"LaurentSeries.Cauchy.coeff_tendsto","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nℱ : Filter (LaurentSeries K)\nhℱ : Cauchy ℱ\nD : Int\n⊢ Filter.Tendsto (fun f => f.coeff D) ℱ (Filter.principal (Singleton.singleton (LaurentSeries.Cauchy.coeff hℱ D)))","decl":"theorem Cauchy.coeff_tendsto {ℱ : Filter K⸨X⸩} (hℱ : Cauchy ℱ) (D : ℤ) :\n    Tendsto (fun f : K⸨X⸩ ↦ f.coeff D) ℱ (𝓟 {coeff hℱ D}) :=\n  let _ : UniformSpace K := ⊥\n  le_of_eq <| UniformSpace.DiscreteUnif.eq_const_of_cauchy (by rfl)\n    (hℱ.map (uniformContinuous_coeff D)) ▸ (principal_singleton _).symm\n\n/- For every Cauchy filter of Laurent series, there is a `N` such that the `n`-th coefficient\nvanishes for all `n ≤ N` and almost all series in the filter. This is an auxiliary lemma used\nto construct the limit of the Cauchy filter as a Laurent series, ensuring that the support of the\nlimit is `PWO`.\nThe result is true also for more general Hahn Series indexed over a partially ordered group `Γ`\nbeyond the special case `Γ = ℤ`, that corresponds to Laurent Series: nevertheless the proof below\ndoes not generalise, as it relies on the study of the `X`-adic valuation attached to the height-one\nprime `X`, and this is peculiar to the one-variable setting. In the future we should prove this\nresult in full generality and deduce the case `Γ = ℤ` from that one.-/\n"}
{"name":"LaurentSeries.Cauchy.exists_lb_eventual_support","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nℱ : Filter (LaurentSeries K)\nhℱ : Cauchy ℱ\n⊢ Exists fun N => Filter.Eventually (fun f => ∀ (n : Int), LT.lt n N → Eq (f.coeff n) 0) ℱ","decl":"lemma Cauchy.exists_lb_eventual_support {ℱ : Filter K⸨X⸩} (hℱ : Cauchy ℱ) :\n    ∃ N, ∀ᶠ f : K⸨X⸩ in ℱ, ∀ n < N, f.coeff n = (0 : K) := by\n  let entourage : Set (K⸨X⸩ × K⸨X⸩) :=\n    {P : K⸨X⸩ × K⸨X⸩ |\n      Valued.v (P.snd - P.fst) < ((Multiplicative.ofAdd 0 : Multiplicative ℤ) : ℤₘ₀)}\n  let ζ := Units.mk0 (G₀ := ℤₘ₀) _ (WithZero.coe_ne_zero (a := (Multiplicative.ofAdd 0)))\n  obtain ⟨S, ⟨hS, ⟨T, ⟨hT, H⟩⟩⟩⟩ := mem_prod_iff.mp <| Filter.le_def.mp hℱ.2 entourage\n    <| (Valued.hasBasis_uniformity K⸨X⸩ ℤₘ₀).mem_of_mem (i := ζ) (by tauto)\n  obtain ⟨f, hf⟩ := forall_mem_nonempty_iff_neBot.mpr hℱ.1 (S ∩ T) (inter_mem_iff.mpr ⟨hS, hT⟩)\n  obtain ⟨N, hN⟩ :  ∃ N : ℤ, ∀ g : K⸨X⸩,\n    Valued.v (g - f) ≤ ↑(Multiplicative.ofAdd (0 : ℤ)) → ∀ n < N, g.coeff n = 0 := by\n    by_cases hf : f = 0\n    · refine ⟨0, fun x hg ↦ ?_⟩\n      rw [hf, sub_zero] at hg\n      exact (valuation_le_iff_coeff_lt_eq_zero K).mp hg\n    · refine ⟨min (f.2.isWF.min (HahnSeries.support_nonempty_iff.mpr hf)) 0 - 1, fun _ hg n hn ↦ ?_⟩\n      rw [eq_coeff_of_valuation_sub_lt K hg (d := 0)]\n      · exact Function.nmem_support.mp fun h ↦\n        f.2.isWF.not_lt_min (HahnSeries.support_nonempty_iff.mpr hf) h\n        <| lt_trans hn <| Int.sub_one_lt_iff.mpr <| min_le_left _ _\n      exact lt_of_lt_of_le hn <| le_of_lt (Int.sub_one_lt_of_le <| min_le_right _ _)\n  use N\n  apply mem_of_superset (inter_mem hS hT)\n  intro g hg\n  have h_prod : (f, g) ∈ entourage := Set.prod_mono (Set.inter_subset_left (t := T))\n    (Set.inter_subset_right (s := S)) |>.trans H <| Set.mem_prod.mpr ⟨hf, hg⟩\n  exact hN g (le_of_lt h_prod)\n\n/- The support of `Cauchy.coeff` has a lower bound. -/\n"}
{"name":"LaurentSeries.Cauchy.exists_lb_support","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nℱ : Filter (LaurentSeries K)\nhℱ : Cauchy ℱ\n⊢ Exists fun N => ∀ (n : Int), LT.lt n N → Eq (LaurentSeries.Cauchy.coeff hℱ n) 0","decl":"theorem Cauchy.exists_lb_support {ℱ : Filter K⸨X⸩} (hℱ : Cauchy ℱ) :\n    ∃ N, ∀ n, n < N → coeff hℱ n = 0 := by\n  let _ : UniformSpace K := ⊥\n  obtain ⟨N, hN⟩ := exists_lb_eventual_support hℱ\n  refine ⟨N, fun n hn ↦ Ultrafilter.eq_of_le_pure (hℱ.map (uniformContinuous_coeff n)).1\n      ((principal_singleton _).symm ▸ coeff_tendsto _ _) ?_⟩\n  simp only [pure_zero, nonpos_iff]\n  apply Filter.mem_of_superset hN (fun _ ha ↦ ha _ hn)\n\n/- The support of `Cauchy.coeff` is bounded below -/\n"}
{"name":"LaurentSeries.Cauchy.coeff_support_bddBelow","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nℱ : Filter (LaurentSeries K)\nhℱ : Cauchy ℱ\n⊢ BddBelow (Function.support (LaurentSeries.Cauchy.coeff hℱ))","decl":"theorem Cauchy.coeff_support_bddBelow {ℱ : Filter K⸨X⸩} (hℱ : Cauchy ℱ) :\n    BddBelow (coeff hℱ).support := by\n  refine ⟨(exists_lb_support hℱ).choose, fun d hd ↦ ?_⟩\n  by_contra hNd\n  exact hd ((exists_lb_support hℱ).choose_spec d (not_le.mp hNd))\n\n"}
{"name":"LaurentSeries.Cauchy.exists_lb_coeff_ne","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nℱ : Filter (LaurentSeries K)\nhℱ : Cauchy ℱ\n⊢ Exists fun N => Filter.Eventually (fun f => ∀ (d : Int), LT.lt d N → Eq (LaurentSeries.Cauchy.coeff hℱ d) (f.coeff d)) ℱ","decl":"theorem Cauchy.exists_lb_coeff_ne {ℱ : Filter K⸨X⸩} (hℱ : Cauchy ℱ) :\n    ∃ N, ∀ᶠ f : K⸨X⸩ in ℱ, ∀ d < N, coeff hℱ d = f.coeff d := by\n  obtain ⟨⟨N₁, hN₁⟩, ⟨N₂, hN₂⟩⟩ := exists_lb_eventual_support hℱ, exists_lb_support hℱ\n  refine ⟨min N₁ N₂, ℱ.3 hN₁ fun _ hf d hd ↦ ?_⟩\n  rw [hf d (lt_of_lt_of_le hd (min_le_left _ _)), hN₂ d (lt_of_lt_of_le hd (min_le_right _ _))]\n\n/- Given a Cauchy filter `ℱ` in the Laurent Series and a bound `D`, for almost all series in the\nfilter the coefficients below `D` coincide with `Caucy.coeff hℱ`-/\n"}
{"name":"LaurentSeries.Cauchy.coeff_eventually_equal","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nℱ : Filter (LaurentSeries K)\nhℱ : Cauchy ℱ\nD : Int\n⊢ Filter.Eventually (fun f => ∀ (d : Int), LT.lt d D → Eq (LaurentSeries.Cauchy.coeff hℱ d) (f.coeff d)) ℱ","decl":"theorem Cauchy.coeff_eventually_equal {ℱ : Filter K⸨X⸩} (hℱ : Cauchy ℱ) {D : ℤ} :\n    ∀ᶠ f : K⸨X⸩ in ℱ, ∀ d, d < D → coeff hℱ d = f.coeff d := by\n  -- `φ` sends `d` to the set of Laurent Series having `d`th coefficient equal to `ℱ.coeff`.\n  let φ : ℤ → Set K⸨X⸩ := fun d ↦ {f | coeff hℱ d = f.coeff d}\n  have intersec₁ :\n    (⋂ n ∈ Set.Iio D, φ n) ⊆ {x : K⸨X⸩ | ∀ d : ℤ, d < D → coeff hℱ d = x.coeff d} := by\n    intro _ hf\n    simpa only [Set.mem_iInter] using hf\n  -- The goal is now to show that the intersection of all `φ d` (for `d < D`) is in `ℱ`.\n  let ℓ := (exists_lb_coeff_ne hℱ).choose\n  let N := max ℓ D\n  have intersec₂ : ⋂ n ∈ Set.Iio D, φ n ⊇ (⋂ n ∈ Set.Iio ℓ, φ n) ∩ (⋂ n ∈ Set.Icc ℓ N, φ n) := by\n    simp only [Set.mem_Iio, Set.mem_Icc, Set.subset_iInter_iff]\n    intro i hi x hx\n    simp only [Set.mem_inter_iff, Set.mem_iInter, and_imp] at hx\n    by_cases H : i < ℓ\n    exacts [hx.1 _ H, hx.2 _ (le_of_not_lt H) <| le_of_lt <| lt_max_of_lt_right hi]\n  suffices (⋂ n ∈ Set.Iio ℓ, φ n) ∩ (⋂ n ∈ Set.Icc ℓ N, φ n) ∈ ℱ by\n    exact ℱ.sets_of_superset this <| intersec₂.trans intersec₁\n  /- To show that the intersection we have in sight is in `ℱ`, we use that it contains a double\n  intersection (an infinite and a finite one): by general properties of filters, we are reduced\n  to show that both terms are in `ℱ`, which is easy in light of their definition. -/\n  · simp only [Set.mem_Iio, Set.mem_Ico, inter_mem_iff]\n    constructor\n    · have := (exists_lb_coeff_ne hℱ).choose_spec\n      rw [Filter.eventually_iff] at this\n      convert this\n      ext\n      simp only [Set.mem_iInter, Set.mem_setOf_eq]; rfl\n    · rw [biInter_mem (Set.finite_Icc ℓ N)]\n      intro _ _\n      apply coeff_tendsto hℱ\n      simp only [principal_singleton, mem_pure]; rfl\n\n"}
{"name":"LaurentSeries.Cauchy.eventually_mem_nhds","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nℱ : Filter (LaurentSeries K)\nhℱ : Cauchy ℱ\nU : Set (LaurentSeries K)\nhU : Membership.mem (nhds (LaurentSeries.Cauchy.limit hℱ)) U\n⊢ Filter.Eventually (fun f => Membership.mem U f) ℱ","decl":"theorem Cauchy.eventually_mem_nhds {ℱ : Filter K⸨X⸩} (hℱ : Cauchy ℱ)\n    {U : Set K⸨X⸩} (hU : U ∈ 𝓝 (Cauchy.limit hℱ)) : ∀ᶠ f in ℱ, f ∈ U := by\n  obtain ⟨γ, hU₁⟩ := Valued.mem_nhds.mp hU\n  suffices ∀ᶠ f in ℱ, f ∈ {y : K⸨X⸩ | Valued.v (y - limit hℱ) < ↑γ} by\n    apply this.mono fun _ hf ↦ hU₁ hf\n  set D := -((WithZero.unzero γ.ne_zero).toAdd - 1) with hD₀\n  have hD : ((Multiplicative.ofAdd (-D) : Multiplicative ℤ) : ℤₘ₀) < γ := by\n    rw [← WithZero.coe_unzero γ.ne_zero, WithZero.coe_lt_coe, hD₀, neg_neg, ofAdd_sub,\n      ofAdd_toAdd, div_lt_comm, div_self', ← ofAdd_zero, Multiplicative.ofAdd_lt]\n    exact zero_lt_one\n  apply coeff_eventually_equal (D := D) hℱ |>.mono\n  intro _ hf\n  apply lt_of_le_of_lt (valuation_le_iff_coeff_lt_eq_zero K |>.mpr _) hD\n  intro n hn\n  rw [HahnSeries.coeff_sub, sub_eq_zero, hf n hn |>.symm]; rfl\n\n/- Laurent Series with coefficients in a field are complete w.r.t. the `X`-adic valuation -/\n"}
{"name":"LaurentSeries.instLaurentSeriesComplete","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ CompleteSpace (LaurentSeries K)","decl":"instance instLaurentSeriesComplete : CompleteSpace K⸨X⸩ :=\n  ⟨fun hℱ ↦ ⟨Cauchy.limit hℱ, fun _ hS ↦ Cauchy.eventually_mem_nhds hℱ hS⟩⟩\n\n"}
{"name":"LaurentSeries.exists_Polynomial_intValuation_lt","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nF : PowerSeries K\nη : Units (WithZero (Multiplicative Int))\n⊢ Exists fun P => LT.lt ((PowerSeries.idealX K).intValuation (HSub.hSub F ↑P)) ↑η","decl":"theorem exists_Polynomial_intValuation_lt (F : K⟦X⟧) (η : ℤₘ₀ˣ) :\n    ∃ P : K[X], (PowerSeries.idealX K).intValuation (F - P) < η := by\n  by_cases h_neg : 1 < η\n  · use 0\n    simpa using (intValuation_le_one (PowerSeries.idealX K) F).trans_lt h_neg\n  · rw [not_lt, ← Units.val_le_val, Units.val_one, ← WithZero.coe_one, ← coe_unzero η.ne_zero,\n      coe_le_coe, ← Multiplicative.toAdd_le, toAdd_one] at h_neg\n    obtain ⟨d, hd⟩ := Int.exists_eq_neg_ofNat h_neg\n    use F.trunc (d + 1)\n    have : Valued.v ((ofPowerSeries ℤ K) (F - (trunc (d + 1) F))) ≤\n      (Multiplicative.ofAdd (-(d + 1 : ℤ))) := by\n      apply (intValuation_le_iff_coeff_lt_eq_zero K _).mpr\n      simpa only [map_sub, sub_eq_zero, Polynomial.coeff_coe, coeff_trunc] using\n        fun _ h ↦ (if_pos h).symm\n    rw [ neg_add, ofAdd_add, ← hd, ofAdd_toAdd, WithZero.coe_mul, coe_unzero,\n      ← coe_algebraMap] at this\n    rw [← valuation_of_algebraMap (K := K⸨X⸩) (PowerSeries.idealX K) (F - F.trunc (d + 1))]\n    apply lt_of_le_of_lt this\n    rw [← mul_one (η : ℤₘ₀), mul_assoc, one_mul]\n    gcongr\n    · exact zero_lt_iff.2 η.ne_zero\n    rw [← WithZero.coe_one, coe_lt_coe, ofAdd_neg, Right.inv_lt_one_iff, ← ofAdd_zero,\n      Multiplicative.ofAdd_lt]\n    exact Int.zero_lt_one\n\n"}
{"name":"LaurentSeries.exists_ratFunc_val_lt","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nf : LaurentSeries K\nγ : Units (WithZero (Multiplicative Int))\n⊢ Exists fun Q => LT.lt (Valued.v (HSub.hSub f ↑Q)) ↑γ","decl":"/-- For every Laurent series `f` and every `γ : ℤₘ₀` one can find a rational function `Q` such\nthat the `X`-adic valuation `v` satisfies `v (f - Q) < γ`. -/\ntheorem exists_ratFunc_val_lt (f : K⸨X⸩) (γ : ℤₘ₀ˣ) :\n    ∃ Q : RatFunc K, Valued.v (f - Q) < γ := by\n  set F := f.powerSeriesPart with hF\n  by_cases ord_nonpos : f.order < 0\n  · set η : ℤₘ₀ˣ := Units.mk0 (Multiplicative.ofAdd f.order : Multiplicative ℤ) coe_ne_zero\n      with hη\n    obtain ⟨P, hP⟩ := exists_Polynomial_intValuation_lt F (η * γ)\n    use RatFunc.X ^ f.order * (P : RatFunc K)\n    have F_mul := f.ofPowerSeries_powerSeriesPart\n    obtain ⟨s, hs⟩ := Int.exists_eq_neg_ofNat (le_of_lt ord_nonpos)\n    rw [← hF, hs, neg_neg, ← ofPowerSeries_X_pow s, ← inv_mul_eq_iff_eq_mul₀] at F_mul\n    · rw [hs, ← F_mul, PowerSeries.coe_pow, PowerSeries.coe_X, RatFunc.coe_mul, zpow_neg,\n        zpow_natCast, inv_eq_one_div (RatFunc.X ^ s), RatFunc.coe_div, RatFunc.coe_pow,\n        RatFunc.coe_X, RatFunc.coe_one, ← inv_eq_one_div, ← mul_sub, map_mul, map_inv₀,\n        ← PowerSeries.coe_X, valuation_X_pow, ← hs, ← RatFunc.coe_coe, ← PowerSeries.coe_sub,\n        ← coe_algebraMap, adicValued_apply, valuation_of_algebraMap,\n        ← Units.val_mk0 (a := ((Multiplicative.ofAdd f.order : Multiplicative ℤ) : ℤₘ₀)), ← hη]\n      apply inv_mul_lt_of_lt_mul₀\n      rwa [← Units.val_mul]\n    · simp only [PowerSeries.coe_pow, pow_ne_zero, PowerSeries.coe_X, ne_eq,\n        single_eq_zero_iff, one_ne_zero, not_false_iff]\n  · obtain ⟨s, hs⟩ := Int.exists_eq_neg_ofNat (Int.neg_nonpos_of_nonneg (not_lt.mp ord_nonpos))\n    obtain ⟨P, hP⟩ := exists_Polynomial_intValuation_lt (PowerSeries.X ^ s * F) γ\n    use P\n    rw [← X_order_mul_powerSeriesPart (neg_inj.1 hs).symm, ← RatFunc.coe_coe,\n      ← PowerSeries.coe_sub, ← coe_algebraMap, adicValued_apply, valuation_of_algebraMap]\n    exact hP\n\n"}
{"name":"LaurentSeries.coe_range_dense","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ DenseRange RatFunc.coeToLaurentSeries_fun","decl":"theorem coe_range_dense : DenseRange ((↑) : RatFunc K → K⸨X⸩) := by\n  rw [denseRange_iff_closure_range]\n  ext f\n  simp only [UniformSpace.mem_closure_iff_symm_ball, Set.mem_univ, iff_true, Set.Nonempty,\n    Set.mem_inter_iff, Set.mem_range, Set.mem_setOf_eq, exists_exists_eq_and]\n  intro V hV h_symm\n  rw [uniformity_eq_comap_neg_add_nhds_zero_swapped] at hV\n  obtain ⟨T, hT₀, hT₁⟩ := hV\n  obtain ⟨γ, hγ⟩ := Valued.mem_nhds_zero.mp hT₀\n  obtain ⟨P, _⟩ := exists_ratFunc_val_lt f γ\n  use P\n  apply hT₁\n  apply hγ\n  simpa only [add_comm, ← sub_eq_add_neg, gt_iff_lt, Set.mem_setOf_eq]\n\n"}
{"name":"LaurentSeries.inducing_coe","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ IsUniformInducing RatFunc.coeToLaurentSeries_fun","decl":"theorem inducing_coe : IsUniformInducing ((↑) : RatFunc K → K⸨X⸩) := by\n  rw [isUniformInducing_iff, Filter.comap]\n  ext S\n  simp only [exists_prop, Filter.mem_mk, Set.mem_setOf_eq, uniformity_eq_comap_nhds_zero,\n    Filter.mem_comap]\n  constructor\n  · rintro ⟨T, ⟨⟨R, ⟨hR, pre_R⟩⟩, pre_T⟩⟩\n    obtain ⟨d, hd⟩ := Valued.mem_nhds.mp hR\n    use {P : RatFunc K | Valued.v P < ↑d}\n    simp only [Valued.mem_nhds, sub_zero]\n    refine ⟨⟨d, by rfl⟩, subset_trans (fun _ _ ↦ pre_R ?_) pre_T⟩\n    apply hd\n    simp only [sub_zero, Set.mem_setOf_eq]\n    erw [← RatFunc.coe_sub, ← valuation_eq_LaurentSeries_valuation]\n    assumption\n  · rintro ⟨_, ⟨hT, pre_T⟩⟩\n    obtain ⟨d, hd⟩ := Valued.mem_nhds.mp hT\n    let X := {f : K⸨X⸩ | Valued.v f < ↑d}\n    refine ⟨(fun x : K⸨X⸩ × K⸨X⸩ ↦ x.snd - x.fst) ⁻¹' X, ⟨X, ?_⟩, ?_⟩\n    · refine ⟨?_, Set.Subset.refl _⟩\n      · simp only [Valued.mem_nhds, sub_zero]\n        use d\n    · refine subset_trans (fun _ _ ↦ ?_) pre_T\n      apply hd\n      erw [Set.mem_setOf_eq, sub_zero, valuation_eq_LaurentSeries_valuation,\n        RatFunc.coe_sub]\n      assumption\n\n"}
{"name":"LaurentSeries.continuous_coe","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ Continuous RatFunc.coeToLaurentSeries_fun","decl":"theorem continuous_coe : Continuous ((↑) : RatFunc K → K⸨X⸩) :=\n  (isUniformInducing_iff'.1 (inducing_coe)).1.continuous\n\n"}
{"name":"LaurentSeries.LaurentSeries_coe","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nx : RatFunc K\n⊢ Eq ((LaurentSeries.LaurentSeriesPkg K).coe x) ↑x","decl":"@[simp]\ntheorem LaurentSeries_coe (x : RatFunc K) : (LaurentSeriesPkg K).coe x = (x : K⸨X⸩) :=\n  rfl\n\n"}
{"name":"LaurentSeries.comparePkg_eq_extension","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nx : UniformSpace.Completion (RatFunc K)\n⊢ Eq ((LaurentSeries.comparePkg K).toFun x) ((↑↑(LaurentSeries.extensionAsRingHom K ⋯)).toFun x)","decl":"lemma comparePkg_eq_extension (x : UniformSpace.Completion (RatFunc K)) :\n    (comparePkg K).toFun x = (extensionAsRingHom K (continuous_coe)).toFun x := rfl\n\n"}
{"name":"LaurentSeries.LaurentSeriesRingEquiv_def","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nf : PowerSeries K\n⊢ Eq ((LaurentSeries.LaurentSeriesRingEquiv K) ((HahnSeries.ofPowerSeries Int K) f)) ((LaurentSeries.LaurentSeriesPkg K).compare LaurentSeries.ratfuncAdicComplPkg ((HahnSeries.ofPowerSeries Int K) f))","decl":"@[simp]\nlemma LaurentSeriesRingEquiv_def (f : K⟦X⟧) :\n    (LaurentSeriesRingEquiv K) f = (LaurentSeriesPkg K).compare ratfuncAdicComplPkg (f : K⸨X⸩) :=\n  rfl\n\n"}
{"name":"LaurentSeries.ratfuncAdicComplRingEquiv_apply","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nx : LaurentSeries.RatFuncAdicCompl K\n⊢ Eq ((LaurentSeries.ratfuncAdicComplRingEquiv K) x) (LaurentSeries.ratfuncAdicComplPkg.compare (LaurentSeries.LaurentSeriesPkg K) x)","decl":"@[simp]\ntheorem ratfuncAdicComplRingEquiv_apply (x : RatFuncAdicCompl K) :\n    ratfuncAdicComplRingEquiv K x = ratfuncAdicComplPkg.compare (LaurentSeriesPkg K) x := rfl\n\n"}
{"name":"LaurentSeries.coe_X_compare","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ Eq ((LaurentSeries.ratfuncAdicComplRingEquiv K) ↑RatFunc.X) ((HahnSeries.ofPowerSeries Int K) PowerSeries.X)","decl":"theorem coe_X_compare :\n    (ratfuncAdicComplRingEquiv K) ((RatFunc.X : RatFunc K) : RatFuncAdicCompl K) =\n      ((PowerSeries.X : K⟦X⟧) : K⸨X⸩) := by\n  rw [PowerSeries.coe_X, ← RatFunc.coe_X, ← LaurentSeries_coe, ← compare_coe]\n  rfl\n\n"}
{"name":"LaurentSeries.algebraMap_apply","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\na : K\n⊢ Eq ((algebraMap K (LaurentSeries K)) a) (HahnSeries.C a)","decl":"theorem algebraMap_apply (a : K) : algebraMap K K⸨X⸩ a = HahnSeries.C a := by\n  simp [RingHom.algebraMap_toAlgebra]\n\n"}
{"name":"LaurentSeries.valuation_LaurentSeries_equal_extension","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ Eq (⋯.extend ⇑Valued.v) ⇑Valued.v","decl":"theorem valuation_LaurentSeries_equal_extension :\n    (LaurentSeriesPkg K).isDenseInducing.extend Valued.v = (Valued.v : K⸨X⸩ → ℤₘ₀) := by\n  apply IsDenseInducing.extend_unique\n  · intro x\n    erw [valuation_eq_LaurentSeries_valuation K x]\n    rfl\n  · exact Valued.continuous_valuation (K := K⸨X⸩)\n\n"}
{"name":"LaurentSeries.tendsto_valuation","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\na : IsDedekindDomain.HeightOneSpectrum.adicCompletion (RatFunc K) (Polynomial.idealX K)\n⊢ Filter.Tendsto (⇑Valued.v) (Filter.comap UniformSpace.Completion.coe' (nhds a)) (nhds (Valued.v a))","decl":"theorem tendsto_valuation (a : (idealX K).adicCompletion (RatFunc K)) :\n    Tendsto (Valued.v : RatFunc K → ℤₘ₀) (comap (↑) (𝓝 a)) (𝓝 (Valued.v a : ℤₘ₀)) := by\n  set ψ := (Valued.v : RatFunc K → ℤₘ₀) with hψ\n  have := Valued.is_topological_valuation (R := (idealX K).adicCompletion (RatFunc K))\n  by_cases ha : a = 0\n  · rw [tendsto_def]\n    intro S hS\n    rw [ha, map_zero, WithZeroTopology.hasBasis_nhds_zero.1 S] at hS\n    obtain ⟨γ, γ_ne_zero, γ_le⟩ := hS\n    use {t | Valued.v t < γ}\n    constructor\n    · rw [ha, this]\n      use Units.mk0 γ γ_ne_zero\n      rw [Units.val_mk0]\n    · refine Set.Subset.trans (fun a _ ↦ ?_) (Set.preimage_mono γ_le)\n      rwa [Set.mem_preimage, Set.mem_Iio, hψ, ← Valued.valuedCompletion_apply a]\n  · rw [WithZeroTopology.tendsto_of_ne_zero ((Valuation.ne_zero_iff Valued.v).mpr ha), hψ,\n      Filter.eventually_comap, Filter.Eventually, Valued.mem_nhds]\n    set γ := Valued.v a / (↑(Multiplicative.ofAdd (1 : ℤ)) : ℤₘ₀) with h_aγ\n    have γ_ne_zero : γ ≠ 0 := by\n      rw [ne_eq, _root_.div_eq_zero_iff, Valuation.zero_iff]\n      simpa only [coe_ne_zero, or_false]\n    use Units.mk0 γ γ_ne_zero\n    intro y val_y b diff_b_y\n    replace val_y : Valued.v y = Valued.v a := by\n      refine Valuation.map_eq_of_sub_lt _ (val_y.trans ?_)\n      rw [Units.val_mk0, h_aγ, ← coe_unzero ((Valuation.ne_zero_iff Valued.v).mpr ha), ←\n        WithZero.coe_div, coe_lt_coe, div_lt_self_iff, ← ofAdd_zero,\n        Multiplicative.ofAdd_lt]\n      exact Int.zero_lt_one\n    rw [← Valued.extension_extends, ← val_y, ← diff_b_y]\n    congr\n\n/- The extension of the `X`-adic valuation from `RatFunc K` up to its abstract completion coincides,\nmodulo the isomorphism with `K⸨X⸩`, with the `X`-adic valuation on `K⸨X⸩`. -/\n"}
{"name":"LaurentSeries.valuation_compare","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nf : LaurentSeries K\n⊢ Eq (Valued.v ((LaurentSeries.LaurentSeriesPkg K).compare LaurentSeries.ratfuncAdicComplPkg f)) (Valued.v f)","decl":"theorem valuation_compare (f : K⸨X⸩) :\n    (Valued.v : (RatFuncAdicCompl K) → ℤₘ₀)\n        (AbstractCompletion.compare (LaurentSeriesPkg K) ratfuncAdicComplPkg f) =\n      Valued.v f := by\n  rw [← valuation_LaurentSeries_equal_extension, ← compare_comp_eq_compare\n    (pkg := ratfuncAdicComplPkg) (cont_f := Valued.continuous_valuation)]\n  · rfl\n  exact (tendsto_valuation K)\n\n"}
{"name":"LaurentSeries.powerSeriesEquivSubring_apply","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nf : PowerSeries K\n⊢ Eq ((LaurentSeries.powerSeriesEquivSubring K) f) ⟨(HahnSeries.ofPowerSeries Int K) f, ⋯⟩","decl":"lemma powerSeriesEquivSubring_apply (f : K⟦X⟧) :\n    powerSeriesEquivSubring K f =\n      ⟨HahnSeries.ofPowerSeries ℤ K f, Subring.mem_map.mpr ⟨f, trivial, rfl⟩⟩ :=\n  rfl\n\n"}
{"name":"LaurentSeries.powerSeriesEquivSubring_coe_apply","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nf : PowerSeries K\n⊢ Eq (↑((LaurentSeries.powerSeriesEquivSubring K) f)) ((HahnSeries.ofPowerSeries Int K) f)","decl":"lemma powerSeriesEquivSubring_coe_apply (f : K⟦X⟧) :\n    (powerSeriesEquivSubring K f : K⸨X⸩) = ofPowerSeries ℤ K f :=\n  rfl\n\n/- Through the isomorphism `LaurentSeriesRingEquiv`, power series land in the unit ball inside the\ncompletion of `RatFunc K`. -/\n"}
{"name":"LaurentSeries.mem_integers_of_powerSeries","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nF : PowerSeries K\n⊢ Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers (RatFunc K) (Polynomial.idealX K)) ((LaurentSeries.LaurentSeriesRingEquiv K) ((HahnSeries.ofPowerSeries Int K) F))","decl":"theorem mem_integers_of_powerSeries (F : K⟦X⟧) :\n    (LaurentSeriesRingEquiv K) F ∈ (idealX K).adicCompletionIntegers (RatFunc K) := by\n  simp only [Subring.mem_map, exists_prop, ValuationSubring.mem_toSubring,\n    mem_adicCompletionIntegers, LaurentSeriesRingEquiv_def,\n    valuation_compare, val_le_one_iff_eq_coe]\n  exact ⟨F, rfl⟩\n\n/- Conversely, all elements in the unit ball inside the completion of `RatFunc K` come from a power\nseries through the isomorphism `LaurentSeriesRingEquiv`. -/\n"}
{"name":"LaurentSeries.exists_powerSeries_of_memIntegers","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nx : LaurentSeries.RatFuncAdicCompl K\nhx : Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers (RatFunc K) (Polynomial.idealX K)) x\n⊢ Exists fun F => Eq ((LaurentSeries.LaurentSeriesRingEquiv K) ((HahnSeries.ofPowerSeries Int K) F)) x","decl":"theorem exists_powerSeries_of_memIntegers {x : RatFuncAdicCompl K}\n    (hx : x ∈ (idealX K).adicCompletionIntegers (RatFunc K)) :\n    ∃ F : K⟦X⟧, (LaurentSeriesRingEquiv K) F = x := by\n  set f := (ratfuncAdicComplRingEquiv K) x with hf\n  have H_x : (LaurentSeriesPkg K).compare ratfuncAdicComplPkg ((ratfuncAdicComplRingEquiv K) x) =\n      x := congr_fun (inverse_compare (LaurentSeriesPkg K) ratfuncAdicComplPkg) x\n  rw [mem_adicCompletionIntegers, ← H_x] at hx\n  obtain ⟨F, hF⟩ := (val_le_one_iff_eq_coe K f).mp (valuation_compare _ f ▸ hx)\n  exact ⟨F, by rw [hF, hf, RingEquiv.symm_apply_apply]⟩\n\n"}
{"name":"LaurentSeries.powerSeries_ext_subring","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ Eq (Subring.map (LaurentSeries.LaurentSeriesRingEquiv K).toRingHom (LaurentSeries.powerSeries_as_subring K)) (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers (RatFunc K) (Polynomial.idealX K)).toSubring","decl":"theorem powerSeries_ext_subring :\n    Subring.map (LaurentSeriesRingEquiv K).toRingHom (powerSeries_as_subring K) =\n      ((idealX K).adicCompletionIntegers (RatFunc K)).toSubring := by\n  ext x\n  refine ⟨fun ⟨f, ⟨F, _, coe_F⟩, hF⟩ ↦ ?_, fun H ↦ ?_⟩\n  · simp only [ValuationSubring.mem_toSubring, ← hF, ← coe_F]\n    apply mem_integers_of_powerSeries\n  · obtain ⟨F, hF⟩ := exists_powerSeries_of_memIntegers K H\n    simp only [Equiv.toFun_as_coe, UniformEquiv.coe_toEquiv, exists_exists_eq_and,\n      UniformEquiv.coe_symm_toEquiv, Subring.mem_map, Equiv.invFun_as_coe]\n    exact ⟨F, ⟨F, trivial, rfl⟩, hF⟩\n\n"}
{"name":"LaurentSeries.powerSeriesRingEquiv_coe_apply","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nf : PowerSeries K\n⊢ Eq (↑((LaurentSeries.powerSeriesRingEquiv K) f)) ((LaurentSeries.LaurentSeriesRingEquiv K) ((HahnSeries.ofPowerSeries Int K) f))","decl":"lemma powerSeriesRingEquiv_coe_apply (f : K⟦X⟧) :\n    powerSeriesRingEquiv K f = LaurentSeriesRingEquiv K (f : K⸨X⸩) :=\n  rfl\n\n"}
{"name":"LaurentSeries.LaurentSeriesRingEquiv_mem_valuationSubring","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nf : PowerSeries K\n⊢ Membership.mem Valued.v.valuationSubring ((LaurentSeries.LaurentSeriesRingEquiv K) ((HahnSeries.ofPowerSeries Int K) f))","decl":"lemma LaurentSeriesRingEquiv_mem_valuationSubring (f : K⟦X⟧) :\n    LaurentSeriesRingEquiv K f ∈ Valued.v.valuationSubring := by\n  simp only [Valuation.mem_valuationSubring_iff]\n  rw [LaurentSeriesRingEquiv_def, valuation_compare, val_le_one_iff_eq_coe]\n  use f\n\n"}
{"name":"LaurentSeries.algebraMap_C_mem_adicCompletionIntegers","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\nx : K\n⊢ Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers (RatFunc K) (Polynomial.idealX K)) (((LaurentSeries.LaurentSeriesRingEquiv K).toRingHom.comp HahnSeries.C) x)","decl":"lemma algebraMap_C_mem_adicCompletionIntegers (x : K) :\n    ((LaurentSeriesRingEquiv K).toRingHom.comp HahnSeries.C) x ∈\n      adicCompletionIntegers (RatFunc K) (idealX K) := by\n  have : HahnSeries.C x = ofPowerSeries ℤ K (PowerSeries.C K x) := by\n    simp [C_apply, ofPowerSeries_C]\n  simp only [RingHom.comp_apply, RingEquiv.toRingHom_eq_coe, RingHom.coe_coe, this]\n  apply LaurentSeriesRingEquiv_mem_valuationSubring\n\n"}
{"name":"LaurentSeries.instIsScalarTowerSubtypeAdicCompletionPolynomialRatFuncIdealXMemValuationSubringAdicCompletionIntegers","module":"Mathlib.RingTheory.LaurentSeries","initialProofState":"K : Type u_2\ninst✝ : Field K\n⊢ IsScalarTower K (Subtype fun x => Membership.mem (IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers (RatFunc K) (Polynomial.idealX K)) x) (IsDedekindDomain.HeightOneSpectrum.adicCompletion (RatFunc K) (Polynomial.idealX K))","decl":"instance : IsScalarTower K ((idealX K).adicCompletionIntegers (RatFunc K))\n    ((idealX K).adicCompletion (RatFunc K)) :=\n  IsScalarTower.of_algebraMap_eq (fun _ ↦ by rfl)\n\n"}
