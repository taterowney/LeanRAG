{"name":"Submodule.mem_traceDual","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁰ : CommRing A\ninst✝⁹ : Field K\ninst✝⁸ : CommRing B\ninst✝⁷ : Field L\ninst✝⁶ : Algebra A K\ninst✝⁵ : Algebra B L\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra K L\ninst✝² : Algebra A L\ninst✝¹ : IsScalarTower A K L\ninst✝ : IsScalarTower A B L\nI : Submodule B L\nx : L\n⊢ Iff (Membership.mem (Submodule.traceDual A K I) x) (∀ (a : L), Membership.mem I a → Membership.mem (algebraMap A K).range (((Algebra.traceForm K L) x) a))","decl":"lemma mem_traceDual {I : Submodule B L} {x} :\n    x ∈ Iᵛ ↔ ∀ a ∈ I, traceForm K L x a ∈ (algebraMap A K).range :=\n  forall₂_congr fun _ _ ↦ mem_one\n\n"}
{"name":"Submodule.le_traceDual_iff_map_le_one","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁰ : CommRing A\ninst✝⁹ : Field K\ninst✝⁸ : CommRing B\ninst✝⁷ : Field L\ninst✝⁶ : Algebra A K\ninst✝⁵ : Algebra B L\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra K L\ninst✝² : Algebra A L\ninst✝¹ : IsScalarTower A K L\ninst✝ : IsScalarTower A B L\nI J : Submodule B L\n⊢ Iff (LE.le I (Submodule.traceDual A K J)) (LE.le (Submodule.map (↑A (Algebra.trace K L)) (Submodule.restrictScalars A (HMul.hMul I J))) 1)","decl":"lemma le_traceDual_iff_map_le_one {I J : Submodule B L} :\n    I ≤ Jᵛ ↔ ((I * J : Submodule B L).restrictScalars A).map\n      ((trace K L).restrictScalars A) ≤ 1 := by\n  rw [Submodule.map_le_iff_le_comap, Submodule.restrictScalars_mul, Submodule.mul_le]\n  simp [SetLike.le_def, mem_traceDual]\n\n"}
{"name":"Submodule.le_traceDual_mul_iff","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁰ : CommRing A\ninst✝⁹ : Field K\ninst✝⁸ : CommRing B\ninst✝⁷ : Field L\ninst✝⁶ : Algebra A K\ninst✝⁵ : Algebra B L\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra K L\ninst✝² : Algebra A L\ninst✝¹ : IsScalarTower A K L\ninst✝ : IsScalarTower A B L\nI J J' : Submodule B L\n⊢ Iff (LE.le I (Submodule.traceDual A K (HMul.hMul J J'))) (LE.le (HMul.hMul I J) (Submodule.traceDual A K J'))","decl":"lemma le_traceDual_mul_iff {I J J' : Submodule B L} :\n    I ≤ (J * J')ᵛ ↔ I * J ≤ J'ᵛ := by\n  simp_rw [le_traceDual_iff_map_le_one, mul_assoc]\n\n"}
{"name":"Submodule.le_traceDual","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁰ : CommRing A\ninst✝⁹ : Field K\ninst✝⁸ : CommRing B\ninst✝⁷ : Field L\ninst✝⁶ : Algebra A K\ninst✝⁵ : Algebra B L\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra K L\ninst✝² : Algebra A L\ninst✝¹ : IsScalarTower A K L\ninst✝ : IsScalarTower A B L\nI J : Submodule B L\n⊢ Iff (LE.le I (Submodule.traceDual A K J)) (LE.le (HMul.hMul I J) (Submodule.traceDual A K 1))","decl":"lemma le_traceDual {I J : Submodule B L} :\n    I ≤ Jᵛ ↔ I * J ≤ 1ᵛ := by\n  rw [← le_traceDual_mul_iff, mul_one]\n\n"}
{"name":"Submodule.le_traceDual_comm","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁰ : CommRing A\ninst✝⁹ : Field K\ninst✝⁸ : CommRing B\ninst✝⁷ : Field L\ninst✝⁶ : Algebra A K\ninst✝⁵ : Algebra B L\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra K L\ninst✝² : Algebra A L\ninst✝¹ : IsScalarTower A K L\ninst✝ : IsScalarTower A B L\nI J : Submodule B L\n⊢ Iff (LE.le I (Submodule.traceDual A K J)) (LE.le J (Submodule.traceDual A K I))","decl":"lemma le_traceDual_comm {I J : Submodule B L} :\n    I ≤ Jᵛ ↔ J ≤ Iᵛ := by rw [le_traceDual, mul_comm, ← le_traceDual]\n\n"}
{"name":"Submodule.le_traceDual_traceDual","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁰ : CommRing A\ninst✝⁹ : Field K\ninst✝⁸ : CommRing B\ninst✝⁷ : Field L\ninst✝⁶ : Algebra A K\ninst✝⁵ : Algebra B L\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra K L\ninst✝² : Algebra A L\ninst✝¹ : IsScalarTower A K L\ninst✝ : IsScalarTower A B L\nI : Submodule B L\n⊢ LE.le I (Submodule.traceDual A K (Submodule.traceDual A K I))","decl":"lemma le_traceDual_traceDual {I : Submodule B L} :\n    I ≤ Iᵛᵛ := le_traceDual_comm.mpr le_rfl\n\n"}
{"name":"Submodule.traceDual_bot","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁰ : CommRing A\ninst✝⁹ : Field K\ninst✝⁸ : CommRing B\ninst✝⁷ : Field L\ninst✝⁶ : Algebra A K\ninst✝⁵ : Algebra B L\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra K L\ninst✝² : Algebra A L\ninst✝¹ : IsScalarTower A K L\ninst✝ : IsScalarTower A B L\n⊢ Eq (Submodule.traceDual A K Bot.bot) Top.top","decl":"@[simp]\nlemma traceDual_bot :\n    (⊥ : Submodule B L)ᵛ = ⊤ := by ext; simpa [mem_traceDual, -RingHom.mem_range] using zero_mem _\n\n"}
{"name":"Submodule.traceDual_top'","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁰ : CommRing A\ninst✝⁹ : Field K\ninst✝⁸ : CommRing B\ninst✝⁷ : Field L\ninst✝⁶ : Algebra A K\ninst✝⁵ : Algebra B L\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra K L\ninst✝² : Algebra A L\ninst✝¹ : IsScalarTower A K L\ninst✝ : IsScalarTower A B L\n⊢ Eq (Submodule.traceDual A K Top.top) (ite (LE.le (Submodule.restrictScalars A (LinearMap.range (Algebra.trace K L))) 1) Top.top Bot.bot)","decl":"open scoped Classical in\nlemma traceDual_top' :\n    (⊤ : Submodule B L)ᵛ =\n      if ((LinearMap.range (Algebra.trace K L)).restrictScalars A ≤ 1) then ⊤ else ⊥ := by\n  classical\n  split_ifs with h\n  · rw [_root_.eq_top_iff]\n    exact fun _ _ _ _ ↦ h ⟨_, rfl⟩\n  · simp only [SetLike.le_def, restrictScalars_mem, LinearMap.mem_range, mem_one,\n      forall_exists_index, forall_apply_eq_imp_iff, not_forall, not_exists] at h\n    obtain ⟨b, hb⟩ := h\n    simp_rw [eq_bot_iff, SetLike.le_def, mem_bot, mem_traceDual, mem_top, true_implies,\n      traceForm_apply, RingHom.mem_range]\n    contrapose! hb with hx'\n    obtain ⟨c, hc, hc0⟩ := hx'\n    simpa [hc0] using hc (c⁻¹ * b)\n\n"}
{"name":"Submodule.traceDual_top","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁵ : CommRing A\ninst✝¹⁴ : Field K\ninst✝¹³ : CommRing B\ninst✝¹² : Field L\ninst✝¹¹ : Algebra A K\ninst✝¹⁰ : Algebra B L\ninst✝⁹ : Algebra A B\ninst✝⁸ : Algebra K L\ninst✝⁷ : Algebra A L\ninst✝⁶ : IsScalarTower A K L\ninst✝⁵ : IsScalarTower A B L\ninst✝⁴ : IsDomain A\ninst✝³ : IsFractionRing A K\ninst✝² : FiniteDimensional K L\ninst✝¹ : Algebra.IsSeparable K L\ninst✝ : Decidable (IsField A)\n⊢ Eq (Submodule.traceDual A K Top.top) (ite (IsField A) Top.top Bot.bot)","decl":"lemma traceDual_top [Decidable (IsField A)] :\n    (⊤ : Submodule B L)ᵛ = if IsField A then ⊤ else ⊥ := by\n  convert traceDual_top'\n  rw [← IsFractionRing.surjective_iff_isField (R := A) (K := K),\n    LinearMap.range_eq_top.mpr (Algebra.trace_surjective K L),\n    ← RingHom.range_eq_top, _root_.eq_top_iff]\n  simp [SetLike.le_def]\n\n"}
{"name":"map_equiv_traceDual","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁵ : CommRing A\ninst✝¹⁴ : Field K\ninst✝¹³ : CommRing B\ninst✝¹² : Field L\ninst✝¹¹ : Algebra A K\ninst✝¹⁰ : Algebra B L\ninst✝⁹ : Algebra A B\ninst✝⁸ : Algebra K L\ninst✝⁷ : Algebra A L\ninst✝⁶ : IsScalarTower A K L\ninst✝⁵ : IsScalarTower A B L\ninst✝⁴ : IsFractionRing A K\ninst✝³ : IsDomain A\ninst✝² : IsFractionRing B L\ninst✝¹ : IsDomain B\ninst✝ : NoZeroSMulDivisors A B\nI : Submodule B (FractionRing B)\n⊢ Eq (Submodule.map (FractionRing.algEquiv B L) (Submodule.traceDual A (FractionRing A) I)) (Submodule.traceDual A K (Submodule.map (FractionRing.algEquiv B L) I))","decl":"variable (A K) in\nlemma map_equiv_traceDual [IsDomain A] [IsFractionRing B L] [IsDomain B]\n    [NoZeroSMulDivisors A B] (I : Submodule B (FractionRing B)) :\n    (traceDual A (FractionRing A) I).map (FractionRing.algEquiv B L) =\n      traceDual A K (I.map (FractionRing.algEquiv B L)) := by\n  show Submodule.map (FractionRing.algEquiv B L).toLinearEquiv.toLinearMap _ =\n    traceDual A K (I.map (FractionRing.algEquiv B L).toLinearEquiv.toLinearMap)\n  rw [Submodule.map_equiv_eq_comap_symm, Submodule.map_equiv_eq_comap_symm]\n  ext x\n  simp only [AlgEquiv.toLinearEquiv_symm, AlgEquiv.toLinearEquiv_toLinearMap,\n    traceDual, traceForm_apply, Submodule.mem_comap, AlgEquiv.toLinearMap_apply,\n    Submodule.mem_mk, AddSubmonoid.mem_mk, AddSubsemigroup.mem_mk, Set.mem_setOf_eq]\n  apply (FractionRing.algEquiv B L).forall_congr\n  simp only [restrictScalars_mem, traceForm_apply, AlgEquiv.toEquiv_eq_coe,\n    EquivLike.coe_coe, mem_comap, AlgEquiv.toLinearMap_apply, AlgEquiv.symm_apply_apply]\n  refine fun {y} ↦ (forall_congr' fun hy ↦ ?_)\n  rw [Algebra.trace_eq_of_equiv_equiv (FractionRing.algEquiv A K).toRingEquiv\n    (FractionRing.algEquiv B L).toRingEquiv]\n  swap\n  · apply IsLocalization.ringHom_ext (M := A⁰); ext\n    simp only [AlgEquiv.toRingEquiv_eq_coe, AlgEquiv.toRingEquiv_toRingHom, RingHom.coe_comp,\n      RingHom.coe_coe, Function.comp_apply, AlgEquiv.commutes, ← IsScalarTower.algebraMap_apply]\n    rw [IsScalarTower.algebraMap_apply A B (FractionRing B), AlgEquiv.commutes,\n      ← IsScalarTower.algebraMap_apply]\n  simp only [AlgEquiv.toRingEquiv_eq_coe, _root_.map_mul, AlgEquiv.coe_ringEquiv,\n    AlgEquiv.apply_symm_apply, ← AlgEquiv.symm_toRingEquiv, mem_one, AlgEquiv.algebraMap_eq_apply]\n\n"}
{"name":"Submodule.mem_traceDual_iff_isIntegral","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹² : CommRing A\ninst✝¹¹ : Field K\ninst✝¹⁰ : CommRing B\ninst✝⁹ : Field L\ninst✝⁸ : Algebra A K\ninst✝⁷ : Algebra B L\ninst✝⁶ : Algebra A B\ninst✝⁵ : Algebra K L\ninst✝⁴ : Algebra A L\ninst✝³ : IsScalarTower A K L\ninst✝² : IsScalarTower A B L\ninst✝¹ : IsFractionRing A K\ninst✝ : IsIntegrallyClosed A\nI : Submodule B L\nx : L\n⊢ Iff (Membership.mem (Submodule.traceDual A K I) x) (∀ (a : L), Membership.mem I a → IsIntegral A (((Algebra.traceForm K L) x) a))","decl":"lemma Submodule.mem_traceDual_iff_isIntegral {I : Submodule B L} {x} :\n    x ∈ Iᵛ ↔ ∀ a ∈ I, IsIntegral A (traceForm K L x a) :=\n  forall₂_congr fun _ _ ↦ mem_one.trans IsIntegrallyClosed.isIntegral_iff.symm\n\n"}
{"name":"Submodule.one_le_traceDual_one","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁴ : CommRing A\ninst✝¹³ : Field K\ninst✝¹² : CommRing B\ninst✝¹¹ : Field L\ninst✝¹⁰ : Algebra A K\ninst✝⁹ : Algebra B L\ninst✝⁸ : Algebra A B\ninst✝⁷ : Algebra K L\ninst✝⁶ : Algebra A L\ninst✝⁵ : IsScalarTower A K L\ninst✝⁴ : IsScalarTower A B L\ninst✝³ : IsFractionRing A K\ninst✝² : IsIntegrallyClosed A\ninst✝¹ : FiniteDimensional K L\ninst✝ : IsIntegralClosure B A L\n⊢ LE.le 1 (Submodule.traceDual A K 1)","decl":"lemma Submodule.one_le_traceDual_one :\n    (1 : Submodule B L) ≤ 1ᵛ := by\n  rw [le_traceDual_iff_map_le_one, mul_one, one_eq_range]\n  rintro _ ⟨x, ⟨x, rfl⟩, rfl⟩\n  rw [mem_one]\n  apply IsIntegrallyClosed.isIntegral_iff.mp\n  apply isIntegral_trace\n  rw [IsIntegralClosure.isIntegral_iff (A := B)]\n  exact ⟨_, rfl⟩\n\n"}
{"name":"isIntegral_discr_mul_of_mem_traceDual","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁷ : CommRing A\ninst✝¹⁶ : Field K\ninst✝¹⁵ : CommRing B\ninst✝¹⁴ : Field L\ninst✝¹³ : Algebra A K\ninst✝¹² : Algebra B L\ninst✝¹¹ : Algebra A B\ninst✝¹⁰ : Algebra K L\ninst✝⁹ : Algebra A L\ninst✝⁸ : IsScalarTower A K L\ninst✝⁷ : IsScalarTower A B L\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : IsIntegrallyClosed A\ninst✝⁴ : FiniteDimensional K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : Algebra.IsSeparable K L\nI : Submodule B L\nι : Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb : Basis ι K L\nhb : ∀ (i : ι), IsIntegral A (b i)\na x : L\nha : Membership.mem I a\nhx : Membership.mem (Submodule.traceDual A K I) x\n⊢ IsIntegral A (HMul.hMul (HSMul.hSMul (Algebra.discr K ⇑b) a) x)","decl":"/-- If `b` is an `A`-integral basis of `L` with discriminant `b`, then `d • a * x` is integral over\n  `A` for all `a ∈ I` and `x ∈ Iᵛ`. -/\nlemma isIntegral_discr_mul_of_mem_traceDual\n    (I : Submodule B L) {ι} [DecidableEq ι] [Fintype ι]\n    {b : Basis ι K L} (hb : ∀ i, IsIntegral A (b i))\n    {a x : L} (ha : a ∈ I) (hx : x ∈ Iᵛ) :\n    IsIntegral A ((discr K b) • a * x) := by\n  have hinv : IsUnit (traceMatrix K b).det := by\n    simpa [← discr_def] using discr_isUnit_of_basis _ b\n  have H := mulVec_cramer (traceMatrix K b) fun i => trace K L (x * a * b i)\n  have : Function.Injective (traceMatrix K b).mulVec := by\n    rwa [mulVec_injective_iff_isUnit, isUnit_iff_isUnit_det]\n  rw [← traceMatrix_of_basis_mulVec, ← mulVec_smul, this.eq_iff,\n    traceMatrix_of_basis_mulVec] at H\n  rw [← b.equivFun.symm_apply_apply (_ * _), b.equivFun_symm_apply]\n  apply IsIntegral.sum\n  intro i _\n  rw [smul_mul_assoc, b.equivFun.map_smul, discr_def, mul_comm, ← H, Algebra.smul_def]\n  refine RingHom.IsIntegralElem.mul _ ?_ (hb _)\n  apply IsIntegral.algebraMap\n  rw [cramer_apply]\n  apply IsIntegral.det\n  intros j k\n  rw [updateCol_apply]\n  split\n  · rw [mul_assoc]\n    rw [mem_traceDual_iff_isIntegral] at hx\n    apply hx\n    have ⟨y, hy⟩ := (IsIntegralClosure.isIntegral_iff (A := B)).mp (hb j)\n    rw [mul_comm, ← hy, ← Algebra.smul_def]\n    exact I.smul_mem _ (ha)\n  · exact isIntegral_trace (RingHom.IsIntegralElem.mul _ (hb j) (hb k))\n\n"}
{"name":"FractionalIdeal.coe_dual","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI : FractionalIdeal (nonZeroDivisors B) L\nhI : Ne I 0\n⊢ Eq (↑(FractionalIdeal.dual A K I)) (Submodule.traceDual A K ↑I)","decl":"lemma coe_dual (hI : I ≠ 0) :\n    (dual A K I : Submodule B L) = Iᵛ := by rw [dual, dif_neg hI, coe_mk]\n\n"}
{"name":"FractionalIdeal.coe_dual_one","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\n⊢ Eq (↑(FractionalIdeal.dual A K 1)) (Submodule.traceDual A K 1)","decl":"@[simp]\nlemma coe_dual_one :\n    (dual A K (1 : FractionalIdeal B⁰ L) : Submodule B L) = 1ᵛ := by\n  rw [← coe_one, coe_dual]\n  exact one_ne_zero\n\n"}
{"name":"FractionalIdeal.dual_zero","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\n⊢ Eq (FractionalIdeal.dual A K 0) 0","decl":"@[simp]\nlemma dual_zero :\n    dual A K (0 : FractionalIdeal B⁰ L) = 0 := by rw [dual, dif_pos rfl]\n\n"}
{"name":"FractionalIdeal.mem_dual","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI : FractionalIdeal (nonZeroDivisors B) L\nhI : Ne I 0\nx : L\n⊢ Iff (Membership.mem (FractionalIdeal.dual A K I) x) (∀ (a : L), Membership.mem I a → Membership.mem (algebraMap A K).range (((Algebra.traceForm K L) x) a))","decl":"lemma mem_dual (hI : I ≠ 0) {x} :\n    x ∈ dual A K I ↔ ∀ a ∈ I, traceForm K L x a ∈ (algebraMap A K).range := by\n  rw [dual, dif_neg hI]; exact forall₂_congr fun _ _ ↦ mem_one\n\n"}
{"name":"FractionalIdeal.dual_ne_zero","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI : FractionalIdeal (nonZeroDivisors B) L\nhI : Ne I 0\n⊢ Ne (FractionalIdeal.dual A K I) 0","decl":"lemma dual_ne_zero (hI : I ≠ 0) :\n    dual A K I ≠ 0 := by\n  obtain ⟨b, hb, hb'⟩ := I.prop\n  suffices algebraMap B L b ∈ dual A K I by\n    intro e\n    rw [e, mem_zero_iff, ← (algebraMap B L).map_zero,\n      (IsIntegralClosure.algebraMap_injective B A L).eq_iff] at this\n    exact mem_nonZeroDivisors_iff_ne_zero.mp hb this\n  rw [mem_dual hI]\n  intro a ha\n  apply IsIntegrallyClosed.isIntegral_iff.mp\n  apply isIntegral_trace\n  dsimp\n  convert hb' a ha using 1\n  · ext w\n    exact IsIntegralClosure.isIntegral_iff (A := B)\n  · exact (Algebra.smul_def _ _).symm\n\n"}
{"name":"FractionalIdeal.dual_eq_zero_iff","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI : FractionalIdeal (nonZeroDivisors B) L\n⊢ Iff (Eq (FractionalIdeal.dual A K I) 0) (Eq I 0)","decl":"@[simp]\nlemma dual_eq_zero_iff :\n    dual A K I = 0 ↔ I = 0 :=\n  ⟨not_imp_not.mp (dual_ne_zero A K), fun e ↦ e.symm ▸ dual_zero A K L B⟩\n\n"}
{"name":"FractionalIdeal.dual_ne_zero_iff","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI : FractionalIdeal (nonZeroDivisors B) L\n⊢ Iff (Ne (FractionalIdeal.dual A K I) 0) (Ne I 0)","decl":"lemma dual_ne_zero_iff :\n    dual A K I ≠ 0 ↔ I ≠ 0 := dual_eq_zero_iff.not\n\n"}
{"name":"FractionalIdeal.le_dual_inv_aux","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI J : FractionalIdeal (nonZeroDivisors B) L\nhI : Ne I 0\nhIJ : LE.le (HMul.hMul I J) 1\n⊢ LE.le J (FractionalIdeal.dual A K I)","decl":"lemma le_dual_inv_aux (hI : I ≠ 0) (hIJ : I * J ≤ 1) :\n    J ≤ dual A K I := by\n  rw [dual, dif_neg hI]\n  intro x hx y hy\n  rw [mem_one]\n  apply IsIntegrallyClosed.isIntegral_iff.mp\n  apply isIntegral_trace\n  rw [IsIntegralClosure.isIntegral_iff (A := B)]\n  have ⟨z, _, hz⟩ := hIJ (FractionalIdeal.mul_mem_mul hy hx)\n  rw [mul_comm] at hz\n  exact ⟨z, hz⟩\n\n"}
{"name":"FractionalIdeal.one_le_dual_one","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\n⊢ LE.le 1 (FractionalIdeal.dual A K 1)","decl":"lemma one_le_dual_one :\n    1 ≤ dual A K (1 : FractionalIdeal B⁰ L) :=\n  le_dual_inv_aux A K one_ne_zero (by rw [one_mul])\n\n"}
{"name":"FractionalIdeal.le_dual_iff","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI J : FractionalIdeal (nonZeroDivisors B) L\nhJ : Ne J 0\n⊢ Iff (LE.le I (FractionalIdeal.dual A K J)) (LE.le (HMul.hMul I J) (FractionalIdeal.dual A K 1))","decl":"lemma le_dual_iff (hJ : J ≠ 0) :\n    I ≤ dual A K J ↔ I * J ≤ dual A K 1 := by\n  by_cases hI : I = 0\n  · simp [hI, zero_le]\n  rw [← coe_le_coe, ← coe_le_coe, coe_mul, coe_dual A K hJ, coe_dual_one, le_traceDual]\n\n"}
{"name":"FractionalIdeal.inv_le_dual","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI : FractionalIdeal (nonZeroDivisors B) L\n⊢ LE.le (Inv.inv I) (FractionalIdeal.dual A K I)","decl":"lemma inv_le_dual :\n    I⁻¹ ≤ dual A K I := by\n  classical\n  exact if hI : I = 0 then by simp [hI] else le_dual_inv_aux A K hI (le_of_eq (mul_inv_cancel₀ hI))\n\n"}
{"name":"FractionalIdeal.dual_inv_le","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI : FractionalIdeal (nonZeroDivisors B) L\n⊢ LE.le (Inv.inv (FractionalIdeal.dual A K I)) I","decl":"lemma dual_inv_le :\n    (dual A K I)⁻¹ ≤ I := by\n  by_cases hI : I = 0; · simp [hI]\n  convert mul_right_mono ((dual A K I)⁻¹)\n    (mul_left_mono I (inv_le_dual A K I)) using 1\n  · simp only [mul_inv_cancel₀ hI, one_mul]\n  · simp only [mul_inv_cancel₀ (dual_ne_zero A K (hI := hI)), mul_assoc, mul_one]\n\n"}
{"name":"FractionalIdeal.dual_eq_mul_inv","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI : FractionalIdeal (nonZeroDivisors B) L\n⊢ Eq (FractionalIdeal.dual A K I) (HMul.hMul (FractionalIdeal.dual A K 1) (Inv.inv I))","decl":"lemma dual_eq_mul_inv :\n    dual A K I = dual A K 1 * I⁻¹ := by\n  by_cases hI : I = 0; · simp [hI]\n  apply le_antisymm\n  · suffices dual A K I * I ≤ dual A K 1 by\n      convert mul_right_mono I⁻¹ this using 1; simp only [mul_inv_cancel₀ hI, mul_one, mul_assoc]\n    rw [← le_dual_iff A K hI]\n  rw [le_dual_iff A K hI, mul_assoc, inv_mul_cancel₀ hI, mul_one]\n\n"}
{"name":"FractionalIdeal.dual_div_dual","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI J : FractionalIdeal (nonZeroDivisors B) L\n⊢ Eq (HDiv.hDiv (FractionalIdeal.dual A K J) (FractionalIdeal.dual A K I)) (HDiv.hDiv I J)","decl":"lemma dual_div_dual :\n    dual A K J / dual A K I = I / J := by\n  rw [dual_eq_mul_inv A K J, dual_eq_mul_inv A K I, mul_div_mul_comm, div_self, one_mul]\n  · exact inv_div_inv J I\n  · simp only [ne_eq, dual_eq_zero_iff, one_ne_zero, not_false_eq_true]\n\n"}
{"name":"FractionalIdeal.dual_mul_self","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI : FractionalIdeal (nonZeroDivisors B) L\nhI : Ne I 0\n⊢ Eq (HMul.hMul (FractionalIdeal.dual A K I) I) (FractionalIdeal.dual A K 1)","decl":"lemma dual_mul_self (hI : I ≠ 0) :\n    dual A K I * I = dual A K 1 := by\n  rw [dual_eq_mul_inv, mul_assoc, inv_mul_cancel₀ hI, mul_one]\n\n"}
{"name":"FractionalIdeal.self_mul_dual","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI : FractionalIdeal (nonZeroDivisors B) L\nhI : Ne I 0\n⊢ Eq (HMul.hMul I (FractionalIdeal.dual A K I)) (FractionalIdeal.dual A K 1)","decl":"lemma self_mul_dual (hI : I ≠ 0) :\n    I * dual A K I = dual A K 1 := by\n  rw [mul_comm, dual_mul_self A K hI]\n\n"}
{"name":"FractionalIdeal.dual_inv","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI : FractionalIdeal (nonZeroDivisors B) L\n⊢ Eq (FractionalIdeal.dual A K (Inv.inv I)) (HMul.hMul (FractionalIdeal.dual A K 1) I)","decl":"lemma dual_inv :\n    dual A K I⁻¹ = dual A K 1 * I := by rw [dual_eq_mul_inv, inv_inv]\n\n"}
{"name":"FractionalIdeal.dual_dual","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI : FractionalIdeal (nonZeroDivisors B) L\n⊢ Eq (FractionalIdeal.dual A K (FractionalIdeal.dual A K I)) I","decl":"@[simp]\nlemma dual_dual :\n    dual A K (dual A K I) = I := by\n  rw [dual_eq_mul_inv, dual_eq_mul_inv A K (I := I), mul_inv, inv_inv, ← mul_assoc, mul_inv_cancel₀,\n    one_mul]\n  rw [dual_ne_zero_iff]\n  exact one_ne_zero\n\n"}
{"name":"FractionalIdeal.dual_le_dual","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\nI J : FractionalIdeal (nonZeroDivisors B) L\nhI : Ne I 0\nhJ : Ne J 0\n⊢ Iff (LE.le (FractionalIdeal.dual A K I) (FractionalIdeal.dual A K J)) (LE.le J I)","decl":"@[simp]\nlemma dual_le_dual (hI : I ≠ 0) (hJ : J ≠ 0) :\n    dual A K I ≤ dual A K J ↔ J ≤ I := by\n  nth_rewrite 2 [← dual_dual A K I]\n  rw [le_dual_iff A K hJ, le_dual_iff A K (I := J) (by rwa [dual_ne_zero_iff]), mul_comm]\n\n"}
{"name":"FractionalIdeal.dual_involutive","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\n⊢ Function.Involutive (FractionalIdeal.dual A K)","decl":"lemma dual_involutive :\n    Function.Involutive (dual A K : FractionalIdeal B⁰ L → FractionalIdeal B⁰ L) := dual_dual A K\n\n"}
{"name":"FractionalIdeal.dual_injective","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsFractionRing B L\ninst✝¹ : IsIntegrallyClosed A\ninst✝ : IsDedekindDomain B\n⊢ Function.Injective (FractionalIdeal.dual A K)","decl":"lemma dual_injective :\n    Function.Injective (dual A K : FractionalIdeal B⁰ L → FractionalIdeal B⁰ L) :=\n  dual_involutive.injective\n\n"}
{"name":"coeSubmodule_differentIdeal_fractionRing","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nB : Type u_3\ninst✝⁹ : CommRing A\ninst✝⁸ : CommRing B\ninst✝⁷ : Algebra A B\ninst✝⁶ : IsDomain A\ninst✝⁵ : IsIntegrallyClosed A\ninst✝⁴ : IsDedekindDomain B\ninst✝³ : NoZeroSMulDivisors A B\ninst✝² : Algebra.IsIntegral A B\ninst✝¹ : Algebra.IsSeparable (FractionRing A) (FractionRing B)\ninst✝ : FiniteDimensional (FractionRing A) (FractionRing B)\n⊢ Eq (IsLocalization.coeSubmodule (FractionRing B) (differentIdeal A B)) (HDiv.hDiv 1 (Submodule.traceDual A (FractionRing A) 1))","decl":"lemma coeSubmodule_differentIdeal_fractionRing\n    [NoZeroSMulDivisors A B] [Algebra.IsIntegral A B]\n    [Algebra.IsSeparable (FractionRing A) (FractionRing B)]\n    [FiniteDimensional (FractionRing A) (FractionRing B)] :\n    coeSubmodule (FractionRing B) (differentIdeal A B) =\n      1 / Submodule.traceDual A (FractionRing A) 1 := by\n  have : IsIntegralClosure B A (FractionRing B) :=\n    IsIntegralClosure.of_isIntegrallyClosed _ _ _\n  rw [coeSubmodule, differentIdeal, Submodule.map_comap_eq, inf_eq_right]\n  have := FractionalIdeal.dual_inv_le (A := A) (K := FractionRing A)\n    (1 : FractionalIdeal B⁰ (FractionRing B))\n  have : _ ≤ ((1 : FractionalIdeal B⁰ (FractionRing B)) : Submodule B (FractionRing B)) := this\n  simp only [← one_div, FractionalIdeal.val_eq_coe] at this\n  rw [FractionalIdeal.coe_div (FractionalIdeal.dual_ne_zero _ _ _),\n    FractionalIdeal.coe_dual] at this\n  · simpa only [FractionalIdeal.coe_one, Submodule.one_eq_range] using this\n  · exact one_ne_zero\n  · exact one_ne_zero\n\n"}
{"name":"coeSubmodule_differentIdeal","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁹ : CommRing A\ninst✝¹⁸ : Field K\ninst✝¹⁷ : CommRing B\ninst✝¹⁶ : Field L\ninst✝¹⁵ : Algebra A K\ninst✝¹⁴ : Algebra B L\ninst✝¹³ : Algebra A B\ninst✝¹² : Algebra K L\ninst✝¹¹ : Algebra A L\ninst✝¹⁰ : IsScalarTower A K L\ninst✝⁹ : IsScalarTower A B L\ninst✝⁸ : IsDomain A\ninst✝⁷ : IsFractionRing A K\ninst✝⁶ : FiniteDimensional K L\ninst✝⁵ : Algebra.IsSeparable K L\ninst✝⁴ : IsIntegralClosure B A L\ninst✝³ : IsIntegrallyClosed A\ninst✝² : IsDedekindDomain B\ninst✝¹ : IsFractionRing B L\ninst✝ : NoZeroSMulDivisors A B\n⊢ Eq (IsLocalization.coeSubmodule L (differentIdeal A B)) (HDiv.hDiv 1 (Submodule.traceDual A K 1))","decl":"lemma coeSubmodule_differentIdeal [NoZeroSMulDivisors A B] :\n    coeSubmodule L (differentIdeal A B) = 1 / Submodule.traceDual A K 1 := by\n  have : (FractionRing.algEquiv B L).toLinearEquiv.comp (Algebra.linearMap B (FractionRing B)) =\n    Algebra.linearMap B L := by ext; simp\n  rw [coeSubmodule, ← this]\n  have H : RingHom.comp (algebraMap (FractionRing A) (FractionRing B))\n      ↑(FractionRing.algEquiv A K).symm.toRingEquiv =\n        RingHom.comp ↑(FractionRing.algEquiv B L).symm.toRingEquiv (algebraMap K L) := by\n    apply IsLocalization.ringHom_ext A⁰\n    ext\n    simp only [AlgEquiv.toRingEquiv_eq_coe, RingHom.coe_comp, RingHom.coe_coe,\n      AlgEquiv.coe_ringEquiv, Function.comp_apply, AlgEquiv.commutes,\n      ← IsScalarTower.algebraMap_apply]\n    rw [IsScalarTower.algebraMap_apply A B L, AlgEquiv.commutes, ← IsScalarTower.algebraMap_apply]\n  have : Algebra.IsSeparable (FractionRing A) (FractionRing B) :=\n    Algebra.IsSeparable.of_equiv_equiv _ _ H\n  have : FiniteDimensional (FractionRing A) (FractionRing B) := Module.Finite.of_equiv_equiv _ _ H\n  have : Algebra.IsIntegral A B := IsIntegralClosure.isIntegral_algebra _ L\n  simp only [AlgEquiv.toLinearEquiv_toLinearMap, Submodule.map_comp]\n  rw [← coeSubmodule, coeSubmodule_differentIdeal_fractionRing _ _,\n    Submodule.map_div, ← AlgEquiv.toAlgHom_toLinearMap, Submodule.map_one]\n  congr 1\n  refine (map_equiv_traceDual A K _).trans ?_\n  congr 1\n  ext\n  simp\n\n"}
{"name":"coeIdeal_differentIdeal","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁹ : CommRing A\ninst✝¹⁸ : Field K\ninst✝¹⁷ : CommRing B\ninst✝¹⁶ : Field L\ninst✝¹⁵ : Algebra A K\ninst✝¹⁴ : Algebra B L\ninst✝¹³ : Algebra A B\ninst✝¹² : Algebra K L\ninst✝¹¹ : Algebra A L\ninst✝¹⁰ : IsScalarTower A K L\ninst✝⁹ : IsScalarTower A B L\ninst✝⁸ : IsDomain A\ninst✝⁷ : IsFractionRing A K\ninst✝⁶ : FiniteDimensional K L\ninst✝⁵ : Algebra.IsSeparable K L\ninst✝⁴ : IsIntegralClosure B A L\ninst✝³ : IsIntegrallyClosed A\ninst✝² : IsDedekindDomain B\ninst✝¹ : IsFractionRing B L\ninst✝ : NoZeroSMulDivisors A B\n⊢ Eq (↑(differentIdeal A B)) (Inv.inv (FractionalIdeal.dual A K 1))","decl":"lemma coeIdeal_differentIdeal [NoZeroSMulDivisors A B] :\n    ↑(differentIdeal A B) = (FractionalIdeal.dual A K (1 : FractionalIdeal B⁰ L))⁻¹ := by\n  apply FractionalIdeal.coeToSubmodule_injective\n  simp only [FractionalIdeal.coe_div\n    (FractionalIdeal.dual_ne_zero _ _ (@one_ne_zero (FractionalIdeal B⁰ L) _ _ _)),\n    FractionalIdeal.coe_coeIdeal, coeSubmodule_differentIdeal A K, inv_eq_one_div,\n    FractionalIdeal.coe_dual_one, FractionalIdeal.coe_one]\n\n"}
{"name":"differentialIdeal_le_fractionalIdeal_iff","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁹ : CommRing A\ninst✝¹⁸ : Field K\ninst✝¹⁷ : CommRing B\ninst✝¹⁶ : Field L\ninst✝¹⁵ : Algebra A K\ninst✝¹⁴ : Algebra B L\ninst✝¹³ : Algebra A B\ninst✝¹² : Algebra K L\ninst✝¹¹ : Algebra A L\ninst✝¹⁰ : IsScalarTower A K L\ninst✝⁹ : IsScalarTower A B L\ninst✝⁸ : IsDomain A\ninst✝⁷ : IsFractionRing A K\ninst✝⁶ : FiniteDimensional K L\ninst✝⁵ : Algebra.IsSeparable K L\ninst✝⁴ : IsIntegralClosure B A L\ninst✝³ : IsIntegrallyClosed A\ninst✝² : IsDedekindDomain B\ninst✝¹ : IsFractionRing B L\nI : FractionalIdeal (nonZeroDivisors B) L\nhI : Ne I 0\ninst✝ : NoZeroSMulDivisors A B\n⊢ Iff (LE.le (↑(differentIdeal A B)) I) (LE.le (Submodule.map (↑A (Algebra.trace K L)) (Submodule.restrictScalars A ↑(Inv.inv I))) 1)","decl":"lemma differentialIdeal_le_fractionalIdeal_iff\n    {I : FractionalIdeal B⁰ L} (hI : I ≠ 0) [NoZeroSMulDivisors A B] :\n    differentIdeal A B ≤ I ↔ (((I⁻¹ :) : Submodule B L).restrictScalars A).map\n      ((Algebra.trace K L).restrictScalars A) ≤ 1 := by\n  rw [coeIdeal_differentIdeal A K L B, FractionalIdeal.inv_le_comm (by simp) hI,\n    ← FractionalIdeal.coe_le_coe, FractionalIdeal.coe_dual_one]\n  refine le_traceDual_iff_map_le_one.trans ?_\n  simp\n\n"}
{"name":"differentialIdeal_le_iff","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁹ : CommRing A\ninst✝¹⁸ : Field K\ninst✝¹⁷ : CommRing B\ninst✝¹⁶ : Field L\ninst✝¹⁵ : Algebra A K\ninst✝¹⁴ : Algebra B L\ninst✝¹³ : Algebra A B\ninst✝¹² : Algebra K L\ninst✝¹¹ : Algebra A L\ninst✝¹⁰ : IsScalarTower A K L\ninst✝⁹ : IsScalarTower A B L\ninst✝⁸ : IsDomain A\ninst✝⁷ : IsFractionRing A K\ninst✝⁶ : FiniteDimensional K L\ninst✝⁵ : Algebra.IsSeparable K L\ninst✝⁴ : IsIntegralClosure B A L\ninst✝³ : IsIntegrallyClosed A\ninst✝² : IsDedekindDomain B\ninst✝¹ : IsFractionRing B L\nI : Ideal B\nhI : Ne I Bot.bot\ninst✝ : NoZeroSMulDivisors A B\n⊢ Iff (LE.le (differentIdeal A B) I) (LE.le (Submodule.map (↑A (Algebra.trace K L)) (Submodule.restrictScalars A ↑(Inv.inv ↑I))) 1)","decl":"lemma differentialIdeal_le_iff {I : Ideal B} (hI : I ≠ ⊥) [NoZeroSMulDivisors A B] :\n    differentIdeal A B ≤ I ↔ (((I⁻¹ : FractionalIdeal B⁰ L) : Submodule B L).restrictScalars A).map\n      ((Algebra.trace K L).restrictScalars A) ≤ 1 :=\n  (FractionalIdeal.coeIdeal_le_coeIdeal _).symm.trans\n    (differentialIdeal_le_fractionalIdeal_iff (I := (I : FractionalIdeal B⁰ L)) (by simpa))\n\n"}
{"name":"traceForm_dualSubmodule_adjoin","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\ninst✝¹¹ : CommRing A\ninst✝¹⁰ : Field K\ninst✝⁹ : Field L\ninst✝⁸ : Algebra A K\ninst✝⁷ : Algebra K L\ninst✝⁶ : Algebra A L\ninst✝⁵ : IsScalarTower A K L\ninst✝⁴ : IsDomain A\ninst✝³ : IsFractionRing A K\ninst✝² : FiniteDimensional K L\ninst✝¹ : Algebra.IsSeparable K L\ninst✝ : IsIntegrallyClosed A\nx : L\nhx : Eq (Algebra.adjoin K (Singleton.singleton x)) Top.top\nhAx : IsIntegral A x\n⊢ Eq ((Algebra.traceForm K L).dualSubmodule (Subalgebra.toSubmodule (Algebra.adjoin A (Singleton.singleton x)))) (HSMul.hSMul (Inv.inv ((Polynomial.aeval x) (Polynomial.derivative (minpoly K x)))) (Subalgebra.toSubmodule (Algebra.adjoin A (Singleton.singleton x))))","decl":"open Pointwise Polynomial in\nlemma traceForm_dualSubmodule_adjoin\n    {x : L} (hx : Algebra.adjoin K {x} = ⊤) (hAx : IsIntegral A x) :\n    (traceForm K L).dualSubmodule (Subalgebra.toSubmodule (Algebra.adjoin A {x})) =\n      (aeval x (derivative <| minpoly K x) : L)⁻¹ •\n        (Subalgebra.toSubmodule (Algebra.adjoin A {x})) := by\n  classical\n  have hKx : IsIntegral K x := Algebra.IsIntegral.isIntegral x\n  let pb := (Algebra.adjoin.powerBasis' hKx).map\n    ((Subalgebra.equivOfEq _ _ hx).trans (Subalgebra.topEquiv))\n  have pbgen : pb.gen = x := by simp [pb]\n  have hpb : ⇑(LinearMap.BilinForm.dualBasis (traceForm K L) _ pb.basis) = _ :=\n    _root_.funext (traceForm_dualBasis_powerBasis_eq pb)\n  have : (Subalgebra.toSubmodule (Algebra.adjoin A {x})) =\n      Submodule.span A (Set.range pb.basis) := by\n    rw [← span_range_natDegree_eq_adjoin (minpoly.monic hAx) (minpoly.aeval _ _)]\n    congr; ext y\n    have : natDegree (minpoly A x) = natDegree (minpoly K x) := by\n      rw [minpoly.isIntegrallyClosed_eq_field_fractions' K hAx, (minpoly.monic hAx).natDegree_map]\n    simp only [Finset.coe_image, Finset.coe_range, Set.mem_image, Set.mem_Iio, Set.mem_range,\n      pb.basis_eq_pow, pbgen]\n    simp only [PowerBasis.map_dim, adjoin.powerBasis'_dim, this]\n    exact ⟨fun ⟨a, b, c⟩ ↦ ⟨⟨a, b⟩, c⟩, fun ⟨⟨a, b⟩, c⟩ ↦ ⟨a, b, c⟩⟩\n  clear_value pb\n  conv_lhs => rw [this]\n  rw [← span_coeff_minpolyDiv hAx, LinearMap.BilinForm.dualSubmodule_span_of_basis,\n    Submodule.smul_span, hpb]\n  show _ = Submodule.span A (_ '' _)\n  simp only [← Set.range_comp, smul_eq_mul, div_eq_inv_mul, pbgen,\n    minpolyDiv_eq_of_isIntegrallyClosed K hAx]\n  apply le_antisymm <;> rw [Submodule.span_le]\n  · rintro _ ⟨i, rfl⟩; exact Submodule.subset_span ⟨i, rfl⟩\n  · rintro _ ⟨i, rfl⟩\n    by_cases hi : i < pb.dim\n    · exact Submodule.subset_span ⟨⟨i, hi⟩, rfl⟩\n    · rw [Function.comp_apply, coeff_eq_zero_of_natDegree_lt, mul_zero]\n      · exact zero_mem _\n      rw [← pb.natDegree_minpoly, pbgen, ← natDegree_minpolyDiv_succ hKx,\n        ← Nat.succ_eq_add_one] at hi\n      exact le_of_not_lt hi\n\n"}
{"name":"conductor_mul_differentIdeal","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsIntegrallyClosed A\ninst✝¹ : IsDedekindDomain B\ninst✝ : NoZeroSMulDivisors A B\nx : B\nhx : Eq (Algebra.adjoin K (Singleton.singleton ((algebraMap B L) x))) Top.top\n⊢ Eq (HMul.hMul (conductor A x) (differentIdeal A B)) (Ideal.span (Singleton.singleton ((Polynomial.aeval x) (Polynomial.derivative (minpoly A x)))))","decl":"open Polynomial Pointwise in\nlemma conductor_mul_differentIdeal [NoZeroSMulDivisors A B]\n    (x : B) (hx : Algebra.adjoin K {algebraMap B L x} = ⊤) :\n    (conductor A x) * differentIdeal A B = Ideal.span {aeval x (derivative (minpoly A x))} := by\n  classical\n  have hAx : IsIntegral A x := IsIntegralClosure.isIntegral A L x\n  haveI := IsIntegralClosure.isFractionRing_of_finite_extension A K L B\n  apply FractionalIdeal.coeIdeal_injective (K := L)\n  simp only [FractionalIdeal.coeIdeal_mul, FractionalIdeal.coeIdeal_span_singleton]\n  rw [coeIdeal_differentIdeal A K L B,\n    mul_inv_eq_iff_eq_mul₀]\n  swap\n  · exact FractionalIdeal.dual_ne_zero A K one_ne_zero\n  apply FractionalIdeal.coeToSubmodule_injective\n  simp only [FractionalIdeal.coe_coeIdeal, FractionalIdeal.coe_mul,\n    FractionalIdeal.coe_spanSingleton, Submodule.span_singleton_mul]\n  ext y\n  have hne₁ : aeval (algebraMap B L x) (derivative (minpoly K (algebraMap B L x))) ≠ 0 :=\n    (Algebra.IsSeparable.isSeparable _ _).aeval_derivative_ne_zero (minpoly.aeval _ _)\n  have : algebraMap B L (aeval x (derivative (minpoly A x))) ≠ 0 := by\n    rwa [minpoly.isIntegrallyClosed_eq_field_fractions K L hAx, derivative_map,\n      aeval_map_algebraMap, aeval_algebraMap_apply] at hne₁\n  rw [Submodule.mem_smul_iff_inv_mul_mem this, FractionalIdeal.mem_coe, FractionalIdeal.mem_dual,\n    mem_coeSubmodule_conductor]\n  swap\n  · exact one_ne_zero\n  have hne₂ : (aeval (algebraMap B L x) (derivative (minpoly K (algebraMap B L x))))⁻¹ ≠ 0 := by\n    rwa [ne_eq, inv_eq_zero]\n  have : IsIntegral A (algebraMap B L x) := IsIntegral.map (IsScalarTower.toAlgHom A B L) hAx\n  simp_rw [← Subalgebra.mem_toSubmodule, ← Submodule.mul_mem_smul_iff (y := y * _)\n    (mem_nonZeroDivisors_of_ne_zero hne₂)]\n  rw [← traceForm_dualSubmodule_adjoin A K hx this]\n  simp only [LinearMap.BilinForm.mem_dualSubmodule, traceForm_apply, Subalgebra.mem_toSubmodule,\n    minpoly.isIntegrallyClosed_eq_field_fractions K L hAx,\n    derivative_map, aeval_map_algebraMap, aeval_algebraMap_apply, mul_assoc,\n    FractionalIdeal.mem_one_iff, forall_exists_index, forall_apply_eq_imp_iff]\n  simp_rw [← IsScalarTower.toAlgHom_apply A B L x, ← AlgHom.map_adjoin_singleton]\n  simp only [Subalgebra.mem_map, IsScalarTower.coe_toAlgHom', Submodule.one_eq_range,\n    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, ← _root_.map_mul]\n  exact ⟨fun H b ↦ (mul_one b) ▸ H b 1 (one_mem _), fun H _ _ _ ↦ H _⟩\n\n"}
{"name":"aeval_derivative_mem_differentIdeal","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝¹⁸ : CommRing A\ninst✝¹⁷ : Field K\ninst✝¹⁶ : CommRing B\ninst✝¹⁵ : Field L\ninst✝¹⁴ : Algebra A K\ninst✝¹³ : Algebra B L\ninst✝¹² : Algebra A B\ninst✝¹¹ : Algebra K L\ninst✝¹⁰ : Algebra A L\ninst✝⁹ : IsScalarTower A K L\ninst✝⁸ : IsScalarTower A B L\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsFractionRing A K\ninst✝⁵ : FiniteDimensional K L\ninst✝⁴ : Algebra.IsSeparable K L\ninst✝³ : IsIntegralClosure B A L\ninst✝² : IsIntegrallyClosed A\ninst✝¹ : IsDedekindDomain B\ninst✝ : NoZeroSMulDivisors A B\nx : B\nhx : Eq (Algebra.adjoin K (Singleton.singleton ((algebraMap B L) x))) Top.top\n⊢ Membership.mem (differentIdeal A B) ((Polynomial.aeval x) (Polynomial.derivative (minpoly A x)))","decl":"open Polynomial Pointwise in\nlemma aeval_derivative_mem_differentIdeal [NoZeroSMulDivisors A B]\n    (x : B) (hx : Algebra.adjoin K {algebraMap B L x} = ⊤) :\n    aeval x (derivative (minpoly A x)) ∈ differentIdeal A B := by\n  refine SetLike.le_def.mp ?_ (Ideal.mem_span_singleton_self _)\n  rw [← conductor_mul_differentIdeal A K L x hx]\n  exact Ideal.mul_le_left\n\n"}
{"name":"pow_sub_one_dvd_differentIdeal_aux","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u\nB : Type u_3\ninst✝²² : CommRing A\ninst✝²¹ : Field K\ninst✝²⁰ : CommRing B\ninst✝¹⁹ : Field L\ninst✝¹⁸ : Algebra A K\ninst✝¹⁷ : Algebra B L\ninst✝¹⁶ : Algebra A B\ninst✝¹⁵ : Algebra K L\ninst✝¹⁴ : Algebra A L\ninst✝¹³ : IsScalarTower A K L\ninst✝¹² : IsScalarTower A B L\ninst✝¹¹ : IsDomain A\ninst✝¹⁰ : IsFractionRing A K\ninst✝⁹ : FiniteDimensional K L\ninst✝⁸ : Algebra.IsSeparable K L\ninst✝⁷ : IsIntegralClosure B A L\ninst✝⁶ : IsIntegrallyClosed A\ninst✝⁵ : IsDedekindDomain B\ninst✝⁴ : IsFractionRing B L\ninst✝³ : IsDedekindDomain A\ninst✝² : NoZeroSMulDivisors A B\ninst✝¹ : Module.Finite A B\np : Ideal A\ninst✝ : p.IsMaximal\nP : Ideal B\ne : Nat\nhe : Ne e 0\nhp : Ne p Bot.bot\nhP : Dvd.dvd (HPow.hPow P e) (Ideal.map (algebraMap A B) p)\n⊢ Dvd.dvd (HPow.hPow P (HSub.hSub e 1)) (differentIdeal A B)","decl":"include K L in\nlemma pow_sub_one_dvd_differentIdeal_aux [IsFractionRing B L] [IsDedekindDomain A]\n    [NoZeroSMulDivisors A B] [Module.Finite A B]\n    {p : Ideal A} [p.IsMaximal] (P : Ideal B) {e : ℕ} (he : e ≠ 0) (hp : p ≠ ⊥)\n    (hP : P ^ e ∣ p.map (algebraMap A B)) : P ^ (e - 1) ∣ differentIdeal A B := by\n  obtain ⟨a, ha⟩ := (pow_dvd_pow _ (Nat.sub_le e 1)).trans hP\n  have hp' := (Ideal.map_eq_bot_iff_of_injective\n    (NoZeroSMulDivisors.algebraMap_injective A B)).not.mpr hp\n  have habot : a ≠ ⊥ := fun ha' ↦ hp' (by simpa [ha'] using ha)\n  have hPbot : P ≠ ⊥ := by\n    rintro rfl; apply hp'\n    rwa [← Ideal.zero_eq_bot, zero_pow he, zero_dvd_iff, Ideal.zero_eq_bot] at hP\n  have : p.map (algebraMap A B) ∣ a ^ e := by\n    obtain ⟨b, hb⟩ := hP\n    apply_fun (· ^ e : Ideal B → _) at ha\n    apply_fun (· ^ (e - 1) : Ideal B → _) at hb\n    simp only [mul_pow, ← pow_mul, mul_comm e] at ha hb\n    conv_lhs at ha => rw [← Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr he)]\n    rw [pow_add, hb, mul_assoc, mul_right_inj' (pow_ne_zero _ hPbot), pow_one, mul_comm] at ha\n    exact ⟨_, ha.symm⟩\n  suffices ∀ x ∈ a, intTrace A B x ∈ p by\n    have hP : ((P ^ (e - 1) :)⁻¹ : FractionalIdeal B⁰ L) = a / p.map (algebraMap A B) := by\n      apply inv_involutive.injective\n      simp only [inv_inv, ha, FractionalIdeal.coeIdeal_mul, inv_div, ne_eq,\n          FractionalIdeal.coeIdeal_eq_zero, mul_div_assoc]\n      rw [div_self (by simpa), mul_one]\n    rw [Ideal.dvd_iff_le, differentialIdeal_le_iff (K := K) (L := L) (pow_ne_zero _ hPbot), hP,\n      Submodule.map_le_iff_le_comap]\n    intro x hx\n    rw [Submodule.restrictScalars_mem, FractionalIdeal.mem_coe,\n      FractionalIdeal.mem_div_iff_of_nonzero (by simpa using hp')] at hx\n    rw [Submodule.mem_comap, LinearMap.coe_restrictScalars, ← FractionalIdeal.coe_one,\n      ← div_self (G₀ := FractionalIdeal A⁰ K) (a := p) (by simpa using hp),\n      FractionalIdeal.mem_coe, FractionalIdeal.mem_div_iff_of_nonzero (by simpa using hp)]\n    simp only [FractionalIdeal.mem_coeIdeal, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iff₂] at hx\n    intro y hy'\n    obtain ⟨y, hy, rfl : algebraMap A K _ = _⟩ := (FractionalIdeal.mem_coeIdeal _).mp hy'\n    obtain ⟨z, hz, hz'⟩ := hx _ (Ideal.mem_map_of_mem _ hy)\n    have : trace K L (algebraMap B L z) ∈ (p : FractionalIdeal A⁰ K) := by\n      rw [← algebraMap_intTrace (A := A)]\n      exact ⟨intTrace A B z, this z hz, rfl⟩\n    rwa [mul_comm, ← smul_eq_mul, ← LinearMap.map_smul, smul_def, mul_comm,\n      ← IsScalarTower.algebraMap_apply, IsScalarTower.algebraMap_apply A B L, ← hz']\n  intros x hx\n  rw [← Ideal.Quotient.eq_zero_iff_mem, ← trace_quotient_eq_of_isDedekindDomain,\n    ← isNilpotent_iff_eq_zero]\n  refine trace_isNilpotent_of_isNilpotent ⟨e, ?_⟩\n  rw [← map_pow, Ideal.Quotient.eq_zero_iff_mem]\n  exact (Ideal.dvd_iff_le.mp this) <| Ideal.pow_mem_pow hx _\n\n"}
{"name":"pow_sub_one_dvd_differentIdeal","module":"Mathlib.RingTheory.DedekindDomain.Different","initialProofState":"A : Type u_1\nB : Type u_3\ninst✝¹⁰ : CommRing A\ninst✝⁹ : CommRing B\ninst✝⁸ : Algebra A B\ninst✝⁷ : IsDomain A\ninst✝⁶ : IsIntegrallyClosed A\ninst✝⁵ : IsDedekindDomain B\ninst✝⁴ : IsDedekindDomain A\ninst✝³ : NoZeroSMulDivisors A B\ninst✝² : Module.Finite A B\ninst✝¹ : Algebra.IsSeparable (FractionRing A) (FractionRing B)\np : Ideal A\ninst✝ : p.IsMaximal\nP : Ideal B\ne : Nat\nhp : Ne p Bot.bot\nhP : Dvd.dvd (HPow.hPow P e) (Ideal.map (algebraMap A B) p)\n⊢ Dvd.dvd (HPow.hPow P (HSub.hSub e 1)) (differentIdeal A B)","decl":"lemma pow_sub_one_dvd_differentIdeal [IsDedekindDomain A] [NoZeroSMulDivisors A B]\n    [Module.Finite A B] [Algebra.IsSeparable (FractionRing A) (FractionRing B)]\n    {p : Ideal A} [p.IsMaximal] (P : Ideal B) (e : ℕ) (hp : p ≠ ⊥)\n    (hP : P ^ e ∣ p.map (algebraMap A B)) : P ^ (e - 1) ∣ differentIdeal A B := by\n  have : IsLocalization (algebraMapSubmonoid B A⁰) (FractionRing B) :=\n    IsIntegralClosure.isLocalization _ (FractionRing A) _ _\n  have : FiniteDimensional (FractionRing A) (FractionRing B) :=\n    Module.Finite_of_isLocalization A B _ _ A⁰\n  by_cases he : e = 0\n  · rw [he, pow_zero]; exact one_dvd _\n  exact pow_sub_one_dvd_differentIdeal_aux A (FractionRing A) (FractionRing B) _ he hp hP\n\n"}
