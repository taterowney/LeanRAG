{"name":"AddGrp.instFaithfulUliftFunctor","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ AddGrp.uliftFunctor.Faithful","decl":"/-- The universe lift functor for groups is faithful.\n-/\n@[to_additive\n  \"The universe lift functor for additive groups is faithful.\"]\ninstance : uliftFunctor.{u, v}.Faithful := uliftFunctorFullyFaithful.faithful\n\n\n"}
{"name":"Grp.instFaithfulUliftFunctor","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ Grp.uliftFunctor.Faithful","decl":"/-- The universe lift functor for groups is faithful.\n-/\n@[to_additive\n  \"The universe lift functor for additive groups is faithful.\"]\ninstance : uliftFunctor.{u, v}.Faithful := uliftFunctorFullyFaithful.faithful\n\n\n"}
{"name":"Grp.instFullUliftFunctor","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ Grp.uliftFunctor.Full","decl":"/-- The universe lift functor for groups is full.\n-/\n@[to_additive\n  \"The universe lift functor for additive groups is full.\"]\ninstance : uliftFunctor.{u, v}.Full := uliftFunctorFullyFaithful.full\n\n"}
{"name":"AddGrp.instFullUliftFunctor","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ AddGrp.uliftFunctor.Full","decl":"/-- The universe lift functor for groups is full.\n-/\n@[to_additive\n  \"The universe lift functor for additive groups is full.\"]\ninstance : uliftFunctor.{u, v}.Full := uliftFunctorFullyFaithful.full\n\n"}
{"name":"Grp.uliftFunctor_preservesLimit","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"J : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J Grp\n⊢ CategoryTheory.Limits.PreservesLimit K Grp.uliftFunctor","decl":"@[to_additive]\nnoncomputable instance uliftFunctor_preservesLimit {J : Type w} [Category.{w'} J]\n    (K : J ⥤ Grp.{u}) : PreservesLimit K uliftFunctor.{v, u} where\n  preserves lc := ⟨isLimitOfReflects (forget Grp.{max u v})\n    (isLimitOfPreserves CategoryTheory.uliftFunctor (isLimitOfPreserves (forget Grp) lc))⟩\n\n"}
{"name":"AddGrp.uliftFunctor_preservesLimit","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"J : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J AddGrp\n⊢ CategoryTheory.Limits.PreservesLimit K AddGrp.uliftFunctor","decl":"@[to_additive]\nnoncomputable instance uliftFunctor_preservesLimit {J : Type w} [Category.{w'} J]\n    (K : J ⥤ Grp.{u}) : PreservesLimit K uliftFunctor.{v, u} where\n  preserves lc := ⟨isLimitOfReflects (forget Grp.{max u v})\n    (isLimitOfPreserves CategoryTheory.uliftFunctor (isLimitOfPreserves (forget Grp) lc))⟩\n\n"}
{"name":"Grp.uliftFunctor_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"J : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J Grp.uliftFunctor","decl":"@[to_additive]\nnoncomputable instance uliftFunctor_preservesLimitsOfShape {J : Type w} [Category.{w'} J] :\n    PreservesLimitsOfShape J uliftFunctor.{v, u} where\n\n"}
{"name":"AddGrp.uliftFunctor_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"J : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J AddGrp.uliftFunctor","decl":"@[to_additive]\nnoncomputable instance uliftFunctor_preservesLimitsOfShape {J : Type w} [Category.{w'} J] :\n    PreservesLimitsOfShape J uliftFunctor.{v, u} where\n\n"}
{"name":"Grp.uliftFunctor_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, u, max u v, u + 1, max (u + 1) (v + 1)} Grp.uliftFunctor","decl":"/--\nThe universe lift for groups preserves limits of arbitrary size.\n-/\n@[to_additive\n  \"The universe lift functor for additive groups preserves limits of arbitrary size.\"]\nnoncomputable instance uliftFunctor_preservesLimitsOfSize :\n    PreservesLimitsOfSize.{w', w} uliftFunctor.{v, u} where\n\n"}
{"name":"AddGrp.uliftFunctor_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, u, max u v, u + 1, max (u + 1) (v + 1)} AddGrp.uliftFunctor","decl":"/--\nThe universe lift for groups preserves limits of arbitrary size.\n-/\n@[to_additive\n  \"The universe lift functor for additive groups preserves limits of arbitrary size.\"]\nnoncomputable instance uliftFunctor_preservesLimitsOfSize :\n    PreservesLimitsOfSize.{w', w} uliftFunctor.{v, u} where\n\n"}
{"name":"AddCommGrp.instFaithfulUliftFunctor","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ AddCommGrp.uliftFunctor.Faithful","decl":"@[to_additive\n  \"The universe lift functor for commutative additive groups is faithful.\"]\ninstance : uliftFunctor.{u, v}.Faithful := uliftFunctorFullyFaithful.faithful\n\n-- The universe lift functor for commutative groups is full. -/\n"}
{"name":"CommGrp.instFaithfulUliftFunctor","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ CommGrp.uliftFunctor.Faithful","decl":"@[to_additive\n  \"The universe lift functor for commutative additive groups is faithful.\"]\ninstance : uliftFunctor.{u, v}.Faithful := uliftFunctorFullyFaithful.faithful\n\n-- The universe lift functor for commutative groups is full. -/\n"}
{"name":"CommGrp.instFullUliftFunctor","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ CommGrp.uliftFunctor.Full","decl":"@[to_additive\n  \"The universe lift functor for commutative additive groups is full.\"]\ninstance : uliftFunctor.{u, v}.Full := uliftFunctorFullyFaithful.full\n\n"}
{"name":"AddCommGrp.instFullUliftFunctor","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ AddCommGrp.uliftFunctor.Full","decl":"@[to_additive\n  \"The universe lift functor for commutative additive groups is full.\"]\ninstance : uliftFunctor.{u, v}.Full := uliftFunctorFullyFaithful.full\n\n"}
{"name":"CommGrp.uliftFunctor_preservesLimit","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"J : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J CommGrp\n⊢ CategoryTheory.Limits.PreservesLimit K CommGrp.uliftFunctor","decl":"@[to_additive]\nnoncomputable instance uliftFunctor_preservesLimit {J : Type w} [Category.{w'} J]\n    (K : J ⥤ CommGrp.{u}) : PreservesLimit K uliftFunctor.{v, u} where\n  preserves lc := ⟨isLimitOfReflects (forget CommGrp.{max u v})\n    (isLimitOfPreserves CategoryTheory.uliftFunctor (isLimitOfPreserves (forget CommGrp) lc))⟩\n\n"}
{"name":"AddCommGrp.uliftFunctor_preservesLimit","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"J : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J AddCommGrp\n⊢ CategoryTheory.Limits.PreservesLimit K AddCommGrp.uliftFunctor","decl":"@[to_additive]\nnoncomputable instance uliftFunctor_preservesLimit {J : Type w} [Category.{w'} J]\n    (K : J ⥤ CommGrp.{u}) : PreservesLimit K uliftFunctor.{v, u} where\n  preserves lc := ⟨isLimitOfReflects (forget CommGrp.{max u v})\n    (isLimitOfPreserves CategoryTheory.uliftFunctor (isLimitOfPreserves (forget CommGrp) lc))⟩\n\n"}
{"name":"AddCommGrp.uliftFunctor_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"J : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J AddCommGrp.uliftFunctor","decl":"@[to_additive]\nnoncomputable instance uliftFunctor_preservesLimitsOfShape {J : Type w} [Category.{w'} J] :\n    PreservesLimitsOfShape J uliftFunctor.{v, u} where\n\n"}
{"name":"CommGrp.uliftFunctor_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"J : Type w\ninst✝ : CategoryTheory.Category.{w', w} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J CommGrp.uliftFunctor","decl":"@[to_additive]\nnoncomputable instance uliftFunctor_preservesLimitsOfShape {J : Type w} [Category.{w'} J] :\n    PreservesLimitsOfShape J uliftFunctor.{v, u} where\n\n"}
{"name":"CommGrp.uliftFunctor_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, u, max u v, u + 1, max (u + 1) (v + 1)} CommGrp.uliftFunctor","decl":"/--\nThe universe lift for commutative groups preserves limits of arbitrary size.\n-/\n@[to_additive\n  \"The universe lift functor for commutative additive groups preserves limits of arbitrary size.\"]\nnoncomputable instance uliftFunctor_preservesLimitsOfSize :\n    PreservesLimitsOfSize.{w', w} uliftFunctor.{v, u} where\n\n"}
{"name":"AddCommGrp.uliftFunctor_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, u, max u v, u + 1, max (u + 1) (v + 1)} AddCommGrp.uliftFunctor","decl":"/--\nThe universe lift for commutative groups preserves limits of arbitrary size.\n-/\n@[to_additive\n  \"The universe lift functor for commutative additive groups preserves limits of arbitrary size.\"]\nnoncomputable instance uliftFunctor_preservesLimitsOfSize :\n    PreservesLimitsOfSize.{w', w} uliftFunctor.{v, u} where\n\n"}
{"name":"AddCommGrp.uliftFunctor_additive","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ AddCommGrp.uliftFunctor.Additive","decl":"/-- The universe lift for commutative additive groups is additive.\n-/\ninstance uliftFunctor_additive :\n    AddCommGrp.uliftFunctor.{u,v}.Additive where\n\n"}
{"name":"AddCommGrp.instPreservesColimitsOfSizeUliftFunctor","module":"Mathlib.Algebra.Category.Grp.Ulift","initialProofState":"⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, u, max u v, u + 1, max (u + 1) (v + 1)} AddCommGrp.uliftFunctor","decl":"open Colimits in\n/--\nThe functor `uliftFunctor : AddCommGrp.{u} ⥤ AddCommGrp.{max u v}` preserves colimits\nof arbitrary size.\n-/\nnoncomputable instance : PreservesColimitsOfSize.{w', w} uliftFunctor.{v, u} where\n  preservesColimitsOfShape {J _} :=\n  { preservesColimit := fun {F} ↦\n    { preserves := fun {c} hc ↦ by\n        classical\n        rw [isColimit_iff_bijective_desc, ← Function.Bijective.of_comp_iff _\n          (quotQuotUliftAddEquiv F).bijective, ← AddEquiv.coe_toAddMonoidHom,\n          ← AddMonoidHom.coe_comp, Quot.desc_quotQuotUliftAddEquiv]\n        exact ULift.up_bijective.comp ((isColimit_iff_bijective_desc c).mp (Nonempty.intro hc)) } }\n\n"}
