{"name":"ZeroAtInftyContinuousMap.zero_at_infty'","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\ninst‚úù : TopologicalSpace Œ≤\nself : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Filter.Tendsto self.toFun (Filter.cocompact Œ±) (nhds 0)","decl":"/-- `C‚ÇÄ(Œ±, Œ≤)` is the type of continuous functions `Œ± ‚Üí Œ≤` which vanish at infinity from a\ntopological space to a metric space with a zero element.\n\nWhen possible, instead of parametrizing results over `(f : C‚ÇÄ(Œ±, Œ≤))`,\nyou should parametrize over `(F : Type*) [ZeroAtInftyContinuousMapClass F Œ± Œ≤] (f : F)`.\n\nWhen you extend this structure, make sure to extend `ZeroAtInftyContinuousMapClass`. -/\nstructure ZeroAtInftyContinuousMap (Œ± : Type u) (Œ≤ : Type v) [TopologicalSpace Œ±] [Zero Œ≤]\n    [TopologicalSpace Œ≤] extends ContinuousMap Œ± Œ≤ : Type max u v where\n  /-- The function tends to zero along the `cocompact` filter. -/\n  zero_at_infty' : Tendsto toFun (cocompact Œ±) (ùìù 0)\n\n"}
{"name":"ZeroAtInftyContinuousMap.mk.inj","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\ninst‚úù : TopologicalSpace Œ≤\ntoContinuousMap‚úù : ContinuousMap Œ± Œ≤\nzero_at_infty'‚úù : Filter.Tendsto toContinuousMap‚úù.toFun (Filter.cocompact Œ±) (nhds 0)\ntoContinuousMap : ContinuousMap Œ± Œ≤\nzero_at_infty' : Filter.Tendsto toContinuousMap.toFun (Filter.cocompact Œ±) (nhds 0)\nx‚úù : Eq { toContinuousMap := toContinuousMap‚úù, zero_at_infty' := zero_at_infty'‚úù } { toContinuousMap := toContinuousMap, zero_at_infty' := zero_at_infty' }\n‚ä¢ Eq toContinuousMap‚úù toContinuousMap","decl":"/-- `C‚ÇÄ(Œ±, Œ≤)` is the type of continuous functions `Œ± ‚Üí Œ≤` which vanish at infinity from a\ntopological space to a metric space with a zero element.\n\nWhen possible, instead of parametrizing results over `(f : C‚ÇÄ(Œ±, Œ≤))`,\nyou should parametrize over `(F : Type*) [ZeroAtInftyContinuousMapClass F Œ± Œ≤] (f : F)`.\n\nWhen you extend this structure, make sure to extend `ZeroAtInftyContinuousMapClass`. -/\nstructure ZeroAtInftyContinuousMap (Œ± : Type u) (Œ≤ : Type v) [TopologicalSpace Œ±] [Zero Œ≤]\n    [TopologicalSpace Œ≤] extends ContinuousMap Œ± Œ≤ : Type max u v where\n  /-- The function tends to zero along the `cocompact` filter. -/\n  zero_at_infty' : Tendsto toFun (cocompact Œ±) (ùìù 0)\n\n"}
{"name":"ZeroAtInftyContinuousMap.mk.sizeOf_spec","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : Zero Œ≤\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : SizeOf Œ±\ninst‚úù : SizeOf Œ≤\ntoContinuousMap : ContinuousMap Œ± Œ≤\nzero_at_infty' : Filter.Tendsto toContinuousMap.toFun (Filter.cocompact Œ±) (nhds 0)\n‚ä¢ Eq (SizeOf.sizeOf { toContinuousMap := toContinuousMap, zero_at_infty' := zero_at_infty' }) (HAdd.hAdd 1 (SizeOf.sizeOf toContinuousMap))","decl":"/-- `C‚ÇÄ(Œ±, Œ≤)` is the type of continuous functions `Œ± ‚Üí Œ≤` which vanish at infinity from a\ntopological space to a metric space with a zero element.\n\nWhen possible, instead of parametrizing results over `(f : C‚ÇÄ(Œ±, Œ≤))`,\nyou should parametrize over `(F : Type*) [ZeroAtInftyContinuousMapClass F Œ± Œ≤] (f : F)`.\n\nWhen you extend this structure, make sure to extend `ZeroAtInftyContinuousMapClass`. -/\nstructure ZeroAtInftyContinuousMap (Œ± : Type u) (Œ≤ : Type v) [TopologicalSpace Œ±] [Zero Œ≤]\n    [TopologicalSpace Œ≤] extends ContinuousMap Œ± Œ≤ : Type max u v where\n  /-- The function tends to zero along the `cocompact` filter. -/\n  zero_at_infty' : Tendsto toFun (cocompact Œ±) (ùìù 0)\n\n"}
{"name":"ZeroAtInftyContinuousMap.mk.injEq","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Zero Œ≤\ninst‚úù : TopologicalSpace Œ≤\ntoContinuousMap‚úù : ContinuousMap Œ± Œ≤\nzero_at_infty'‚úù : Filter.Tendsto toContinuousMap‚úù.toFun (Filter.cocompact Œ±) (nhds 0)\ntoContinuousMap : ContinuousMap Œ± Œ≤\nzero_at_infty' : Filter.Tendsto toContinuousMap.toFun (Filter.cocompact Œ±) (nhds 0)\n‚ä¢ Eq (Eq { toContinuousMap := toContinuousMap‚úù, zero_at_infty' := zero_at_infty'‚úù } { toContinuousMap := toContinuousMap, zero_at_infty' := zero_at_infty' }) (Eq toContinuousMap‚úù toContinuousMap)","decl":"/-- `C‚ÇÄ(Œ±, Œ≤)` is the type of continuous functions `Œ± ‚Üí Œ≤` which vanish at infinity from a\ntopological space to a metric space with a zero element.\n\nWhen possible, instead of parametrizing results over `(f : C‚ÇÄ(Œ±, Œ≤))`,\nyou should parametrize over `(F : Type*) [ZeroAtInftyContinuousMapClass F Œ± Œ≤] (f : F)`.\n\nWhen you extend this structure, make sure to extend `ZeroAtInftyContinuousMapClass`. -/\nstructure ZeroAtInftyContinuousMap (Œ± : Type u) (Œ≤ : Type v) [TopologicalSpace Œ±] [Zero Œ≤]\n    [TopologicalSpace Œ≤] extends ContinuousMap Œ± Œ≤ : Type max u v where\n  /-- The function tends to zero along the `cocompact` filter. -/\n  zero_at_infty' : Tendsto toFun (cocompact Œ±) (ùìù 0)\n\n"}
{"name":"ZeroAtInftyContinuousMapClass.toContinuousMapClass","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"F : Type u_2\nŒ± : outParam (Type u_3)\nŒ≤ : outParam (Type u_4)\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : Zero Œ≤\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : FunLike F Œ± Œ≤\nself : ZeroAtInftyContinuousMapClass F Œ± Œ≤\n‚ä¢ ContinuousMapClass F Œ± Œ≤","decl":"/-- `ZeroAtInftyContinuousMapClass F Œ± Œ≤` states that `F` is a type of continuous maps which\nvanish at infinity.\n\nYou should also extend this typeclass when you extend `ZeroAtInftyContinuousMap`. -/\nclass ZeroAtInftyContinuousMapClass (F : Type*) (Œ± Œ≤ : outParam Type*) [TopologicalSpace Œ±]\n    [Zero Œ≤] [TopologicalSpace Œ≤] [FunLike F Œ± Œ≤] extends ContinuousMapClass F Œ± Œ≤ : Prop where\n  /-- Each member of the class tends to zero along the `cocompact` filter. -/\n  zero_at_infty (f : F) : Tendsto f (cocompact Œ±) (ùìù 0)\n\n"}
{"name":"ZeroAtInftyContinuousMapClass.zero_at_infty","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"F : Type u_2\nŒ± : outParam (Type u_3)\nŒ≤ : outParam (Type u_4)\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : Zero Œ≤\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : FunLike F Œ± Œ≤\nself : ZeroAtInftyContinuousMapClass F Œ± Œ≤\nf : F\n‚ä¢ Filter.Tendsto (‚áëf) (Filter.cocompact Œ±) (nhds 0)","decl":"/-- `ZeroAtInftyContinuousMapClass F Œ± Œ≤` states that `F` is a type of continuous maps which\nvanish at infinity.\n\nYou should also extend this typeclass when you extend `ZeroAtInftyContinuousMap`. -/\nclass ZeroAtInftyContinuousMapClass (F : Type*) (Œ± Œ≤ : outParam Type*) [TopologicalSpace Œ±]\n    [Zero Œ≤] [TopologicalSpace Œ≤] [FunLike F Œ± Œ≤] extends ContinuousMapClass F Œ± Œ≤ : Prop where\n  /-- Each member of the class tends to zero along the `cocompact` filter. -/\n  zero_at_infty (f : F) : Tendsto f (cocompact Œ±) (ùìù 0)\n\n"}
{"name":"ZeroAtInftyContinuousMap.instZeroAtInftyContinuousMapClass","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : Zero Œ≤\n‚ä¢ ZeroAtInftyContinuousMapClass (ZeroAtInftyContinuousMap Œ± Œ≤) Œ± Œ≤","decl":"instance instZeroAtInftyContinuousMapClass : ZeroAtInftyContinuousMapClass C‚ÇÄ(Œ±, Œ≤) Œ± Œ≤ where\n  map_continuous f := f.continuous_toFun\n  zero_at_infty f := f.zero_at_infty'\n\n"}
{"name":"ZeroAtInftyContinuousMap.coe_toContinuousMap","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : Zero Œ≤\nf : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq ‚áëf.toContinuousMap ‚áëf","decl":"@[simp]\ntheorem coe_toContinuousMap (f : C‚ÇÄ(Œ±, Œ≤)) : (f.toContinuousMap : Œ± ‚Üí Œ≤) = f :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.ext","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : Zero Œ≤\nf g : ZeroAtInftyContinuousMap Œ± Œ≤\nh : ‚àÄ (x : Œ±), Eq (f x) (g x)\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem ext {f g : C‚ÇÄ(Œ±, Œ≤)} (h : ‚àÄ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"ZeroAtInftyContinuousMap.ext_iff","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : Zero Œ≤\nf g : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Iff (Eq f g) (‚àÄ (x : Œ±), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : C‚ÇÄ(Œ±, Œ≤)} (h : ‚àÄ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"ZeroAtInftyContinuousMap.coe_mk","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : Zero Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Continuous f\nhf' : Filter.Tendsto f (Filter.cocompact Œ±) (nhds 0)\n‚ä¢ Eq (‚áë{ toFun := f, continuous_toFun := hf, zero_at_infty' := hf' }) f","decl":"@[simp]\nlemma coe_mk {f : Œ± ‚Üí Œ≤} (hf : Continuous f) (hf' : Tendsto f (cocompact Œ±) (ùìù 0)) :\n    { toFun := f,\n      continuous_toFun := hf,\n      zero_at_infty' := hf' : ZeroAtInftyContinuousMap Œ± Œ≤} = f :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.coe_copy","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : Zero Œ≤\nf : ZeroAtInftyContinuousMap Œ± Œ≤\nf' : Œ± ‚Üí Œ≤\nh : Eq f' ‚áëf\n‚ä¢ Eq (‚áë(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : C‚ÇÄ(Œ±, Œ≤)) (f' : Œ± ‚Üí Œ≤) (h : f' = f) : ‚áë(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.copy_eq","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : Zero Œ≤\nf : ZeroAtInftyContinuousMap Œ± Œ≤\nf' : Œ± ‚Üí Œ≤\nh : Eq f' ‚áëf\n‚ä¢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : C‚ÇÄ(Œ±, Œ≤)) (f' : Œ± ‚Üí Œ≤) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"ZeroAtInftyContinuousMap.eq_of_empty","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : Zero Œ≤\ninst‚úù : IsEmpty Œ±\nf g : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq f g","decl":"theorem eq_of_empty [IsEmpty Œ±] (f g : C‚ÇÄ(Œ±, Œ≤)) : f = g :=\n  ext <| IsEmpty.elim ‚Äπ_‚Ä∫\n\n"}
{"name":"ZeroAtInftyContinuousMap.ContinuousMap.liftZeroAtInfty_symm_apply","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : Zero Œ≤\ninst‚úù : CompactSpace Œ±\nf : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq (ZeroAtInftyContinuousMap.ContinuousMap.liftZeroAtInfty.symm f) ‚Üëf","decl":"/-- A continuous function on a compact space is automatically a continuous function vanishing at\ninfinity. -/\n@[simps]\ndef ContinuousMap.liftZeroAtInfty [CompactSpace Œ±] : C(Œ±, Œ≤) ‚âÉ C‚ÇÄ(Œ±, Œ≤) where\n  toFun f :=\n    { toFun := f\n      continuous_toFun := f.continuous\n      zero_at_infty' := by simp }\n  invFun f := f\n  left_inv f := by\n    ext\n    rfl\n  right_inv f := by\n    ext\n    rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.ContinuousMap.liftZeroAtInfty_apply_toFun","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : Zero Œ≤\ninst‚úù : CompactSpace Œ±\nf : ContinuousMap Œ± Œ≤\na : Œ±\n‚ä¢ Eq ((ZeroAtInftyContinuousMap.ContinuousMap.liftZeroAtInfty f) a) (f a)","decl":"/-- A continuous function on a compact space is automatically a continuous function vanishing at\ninfinity. -/\n@[simps]\ndef ContinuousMap.liftZeroAtInfty [CompactSpace Œ±] : C(Œ±, Œ≤) ‚âÉ C‚ÇÄ(Œ±, Œ≤) where\n  toFun f :=\n    { toFun := f\n      continuous_toFun := f.continuous\n      zero_at_infty' := by simp }\n  invFun f := f\n  left_inv f := by\n    ext\n    rfl\n  right_inv f := by\n    ext\n    rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.zeroAtInftyContinuousMapClass.ofCompact","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Åµ : TopologicalSpace Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ≤\ninst‚úù¬≥ : Zero Œ≤\nG : Type u_2\ninst‚úù¬≤ : FunLike G Œ± Œ≤\ninst‚úù¬π : ContinuousMapClass G Œ± Œ≤\ninst‚úù : CompactSpace Œ±\n‚ä¢ ZeroAtInftyContinuousMapClass G Œ± Œ≤","decl":"/-- A continuous function on a compact space is automatically a continuous function vanishing at\ninfinity. This is not an instance to avoid type class loops. -/\nlemma zeroAtInftyContinuousMapClass.ofCompact {G : Type*} [FunLike G Œ± Œ≤]\n    [ContinuousMapClass G Œ± Œ≤] [CompactSpace Œ±] : ZeroAtInftyContinuousMapClass G Œ± Œ≤ where\n  map_continuous := map_continuous\n  zero_at_infty := by simp\n\n"}
{"name":"ZeroAtInftyContinuousMap.coe_zero","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : Zero Œ≤\n‚ä¢ Eq (‚áë0) 0","decl":"@[simp]\ntheorem coe_zero [Zero Œ≤] : ‚áë(0 : C‚ÇÄ(Œ±, Œ≤)) = 0 :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.zero_apply","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\nx : Œ±\ninst‚úù : Zero Œ≤\n‚ä¢ Eq (0 x) 0","decl":"theorem zero_apply [Zero Œ≤] : (0 : C‚ÇÄ(Œ±, Œ≤)) x = 0 :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.coe_mul","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : MulZeroClass Œ≤\ninst‚úù : ContinuousMul Œ≤\nf g : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq (‚áë(HMul.hMul f g)) (HMul.hMul ‚áëf ‚áëg)","decl":"@[simp]\ntheorem coe_mul [MulZeroClass Œ≤] [ContinuousMul Œ≤] (f g : C‚ÇÄ(Œ±, Œ≤)) : ‚áë(f * g) = f * g :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.mul_apply","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\nx : Œ±\ninst‚úù¬π : MulZeroClass Œ≤\ninst‚úù : ContinuousMul Œ≤\nf g : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq ((HMul.hMul f g) x) (HMul.hMul (f x) (g x))","decl":"theorem mul_apply [MulZeroClass Œ≤] [ContinuousMul Œ≤] (f g : C‚ÇÄ(Œ±, Œ≤)) : (f * g) x = f x * g x :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.coe_add","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : AddZeroClass Œ≤\ninst‚úù : ContinuousAdd Œ≤\nf g : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq (‚áë(HAdd.hAdd f g)) (HAdd.hAdd ‚áëf ‚áëg)","decl":"@[simp]\ntheorem coe_add [AddZeroClass Œ≤] [ContinuousAdd Œ≤] (f g : C‚ÇÄ(Œ±, Œ≤)) : ‚áë(f + g) = f + g :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.add_apply","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\nx : Œ±\ninst‚úù¬π : AddZeroClass Œ≤\ninst‚úù : ContinuousAdd Œ≤\nf g : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq ((HAdd.hAdd f g) x) (HAdd.hAdd (f x) (g x))","decl":"theorem add_apply [AddZeroClass Œ≤] [ContinuousAdd Œ≤] (f g : C‚ÇÄ(Œ±, Œ≤)) : (f + g) x = f x + g x :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.coe_smul","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Åµ : TopologicalSpace Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ≤\ninst‚úù¬≥ : Zero Œ≤\nR : Type u_2\ninst‚úù¬≤ : Zero R\ninst‚úù¬π : SMulWithZero R Œ≤\ninst‚úù : ContinuousConstSMul R Œ≤\nr : R\nf : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq (‚áë(HSMul.hSMul r f)) (HSMul.hSMul r ‚áëf)","decl":"@[simp, norm_cast]\ntheorem coe_smul [Zero Œ≤] {R : Type*} [Zero R] [SMulWithZero R Œ≤] [ContinuousConstSMul R Œ≤] (r : R)\n    (f : C‚ÇÄ(Œ±, Œ≤)) : ‚áë(r ‚Ä¢ f) = r ‚Ä¢ ‚áëf :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.smul_apply","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Åµ : TopologicalSpace Œ±\ninst‚úù‚Å¥ : TopologicalSpace Œ≤\ninst‚úù¬≥ : Zero Œ≤\nR : Type u_2\ninst‚úù¬≤ : Zero R\ninst‚úù¬π : SMulWithZero R Œ≤\ninst‚úù : ContinuousConstSMul R Œ≤\nr : R\nf : ZeroAtInftyContinuousMap Œ± Œ≤\nx : Œ±\n‚ä¢ Eq ((HSMul.hSMul r f) x) (HSMul.hSMul r (f x))","decl":"theorem smul_apply [Zero Œ≤] {R : Type*} [Zero R] [SMulWithZero R Œ≤] [ContinuousConstSMul R Œ≤]\n    (r : R) (f : C‚ÇÄ(Œ±, Œ≤)) (x : Œ±) : (r ‚Ä¢ f) x = r ‚Ä¢ f x :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.coe_neg","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : AddGroup Œ≤\ninst‚úù : TopologicalAddGroup Œ≤\nf : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq (‚áë(Neg.neg f)) (Neg.neg ‚áëf)","decl":"@[simp]\ntheorem coe_neg : ‚áë(-f) = -f :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.neg_apply","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\nx : Œ±\ninst‚úù¬π : AddGroup Œ≤\ninst‚úù : TopologicalAddGroup Œ≤\nf : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq ((Neg.neg f) x) (Neg.neg (f x))","decl":"theorem neg_apply : (-f) x = -f x :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.coe_sub","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : AddGroup Œ≤\ninst‚úù : TopologicalAddGroup Œ≤\nf g : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq (‚áë(HSub.hSub f g)) (HSub.hSub ‚áëf ‚áëg)","decl":"@[simp]\ntheorem coe_sub : ‚áë(f - g) = f - g :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.sub_apply","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\nx : Œ±\ninst‚úù¬π : AddGroup Œ≤\ninst‚úù : TopologicalAddGroup Œ≤\nf g : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq ((HSub.hSub f g) x) (HSub.hSub (f x) (g x))","decl":"theorem sub_apply : (f - g) x = f x - g x :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.instIsCentralScalar","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Å∑ : TopologicalSpace Œ±\ninst‚úù‚Å∂ : TopologicalSpace Œ≤\ninst‚úù‚Åµ : Zero Œ≤\nR : Type u_2\ninst‚úù‚Å¥ : Zero R\ninst‚úù¬≥ : SMulWithZero R Œ≤\ninst‚úù¬≤ : SMulWithZero (MulOpposite R) Œ≤\ninst‚úù¬π : ContinuousConstSMul R Œ≤\ninst‚úù : IsCentralScalar R Œ≤\n‚ä¢ IsCentralScalar R (ZeroAtInftyContinuousMap Œ± Œ≤)","decl":"instance instIsCentralScalar [Zero Œ≤] {R : Type*} [Zero R] [SMulWithZero R Œ≤] [SMulWithZero R·µê·µí·µñ Œ≤]\n    [ContinuousConstSMul R Œ≤] [IsCentralScalar R Œ≤] : IsCentralScalar R C‚ÇÄ(Œ±, Œ≤) :=\n  ‚ü®fun _ _ => ext fun _ => op_smul_eq_smul _ _‚ü©\n\n"}
{"name":"ZeroAtInftyContinuousMap.instIsScalarTower","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Å∑ : TopologicalSpace Œ±\ninst‚úù‚Å∂ : TopologicalSpace Œ≤\nR : Type u_2\ninst‚úù‚Åµ : Semiring R\ninst‚úù‚Å¥ : NonUnitalNonAssocSemiring Œ≤\ninst‚úù¬≥ : TopologicalSemiring Œ≤\ninst‚úù¬≤ : Module R Œ≤\ninst‚úù¬π : ContinuousConstSMul R Œ≤\ninst‚úù : IsScalarTower R Œ≤ Œ≤\n‚ä¢ IsScalarTower R (ZeroAtInftyContinuousMap Œ± Œ≤) (ZeroAtInftyContinuousMap Œ± Œ≤)","decl":"instance instIsScalarTower {R : Type*} [Semiring R] [NonUnitalNonAssocSemiring Œ≤]\n    [TopologicalSemiring Œ≤] [Module R Œ≤] [ContinuousConstSMul R Œ≤] [IsScalarTower R Œ≤ Œ≤] :\n    IsScalarTower R C‚ÇÄ(Œ±, Œ≤) C‚ÇÄ(Œ±, Œ≤) where\n  smul_assoc r f g := by\n    ext\n    simp only [smul_eq_mul, coe_mul, coe_smul, Pi.mul_apply, Pi.smul_apply]\n    rw [‚Üê smul_eq_mul, ‚Üê smul_eq_mul, smul_assoc]\n\n"}
{"name":"ZeroAtInftyContinuousMap.instSMulCommClass","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Å∑ : TopologicalSpace Œ±\ninst‚úù‚Å∂ : TopologicalSpace Œ≤\nR : Type u_2\ninst‚úù‚Åµ : Semiring R\ninst‚úù‚Å¥ : NonUnitalNonAssocSemiring Œ≤\ninst‚úù¬≥ : TopologicalSemiring Œ≤\ninst‚úù¬≤ : Module R Œ≤\ninst‚úù¬π : ContinuousConstSMul R Œ≤\ninst‚úù : SMulCommClass R Œ≤ Œ≤\n‚ä¢ SMulCommClass R (ZeroAtInftyContinuousMap Œ± Œ≤) (ZeroAtInftyContinuousMap Œ± Œ≤)","decl":"instance instSMulCommClass {R : Type*} [Semiring R] [NonUnitalNonAssocSemiring Œ≤]\n    [TopologicalSemiring Œ≤] [Module R Œ≤] [ContinuousConstSMul R Œ≤] [SMulCommClass R Œ≤ Œ≤] :\n    SMulCommClass R C‚ÇÄ(Œ±, Œ≤) C‚ÇÄ(Œ±, Œ≤) where\n  smul_comm r f g := by\n    ext\n    simp only [smul_eq_mul, coe_smul, coe_mul, Pi.smul_apply, Pi.mul_apply]\n    rw [‚Üê smul_eq_mul, ‚Üê smul_eq_mul, smul_comm]\n\n"}
{"name":"ZeroAtInftyContinuousMap.uniformContinuous","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"F : Type u_1\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù‚Å¥ : UniformSpace Œ≤\ninst‚úù¬≥ : UniformSpace Œ≥\ninst‚úù¬≤ : Zero Œ≥\ninst‚úù¬π : FunLike F Œ≤ Œ≥\ninst‚úù : ZeroAtInftyContinuousMapClass F Œ≤ Œ≥\nf : F\n‚ä¢ UniformContinuous ‚áëf","decl":"theorem uniformContinuous (f : F) : UniformContinuous (f : Œ≤ ‚Üí Œ≥) :=\n  (map_continuous f).uniformContinuous_of_tendsto_cocompact (zero_at_infty f)\n\n"}
{"name":"ZeroAtInftyContinuousMap.bounded","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"F : Type u_1\nŒ± : Type u\nŒ≤ : Type v\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : PseudoMetricSpace Œ≤\ninst‚úù¬≤ : Zero Œ≤\ninst‚úù¬π : FunLike F Œ± Œ≤\ninst‚úù : ZeroAtInftyContinuousMapClass F Œ± Œ≤\nf : F\n‚ä¢ Exists fun C => ‚àÄ (x y : Œ±), LE.le (Dist.dist (f x) (f y)) C","decl":"protected theorem bounded (f : F) : ‚àÉ C, ‚àÄ x y : Œ±, dist ((f : Œ± ‚Üí Œ≤) x) (f y) ‚â§ C := by\n  obtain ‚ü®K : Set Œ±, hK‚ÇÅ, hK‚ÇÇ‚ü© := mem_cocompact.mp\n    (tendsto_def.mp (zero_at_infty (f : F)) _ (closedBall_mem_nhds (0 : Œ≤) zero_lt_one))\n  obtain ‚ü®C, hC‚ü© := (hK‚ÇÅ.image (map_continuous f)).isBounded.subset_closedBall (0 : Œ≤)\n  refine ‚ü®max C 1 + max C 1, fun x y => ?_‚ü©\n  have : ‚àÄ x, f x ‚àà closedBall (0 : Œ≤) (max C 1) := by\n    intro x\n    by_cases hx : x ‚àà K\n    ¬∑ exact (mem_closedBall.mp <| hC ‚ü®x, hx, rfl‚ü©).trans (le_max_left _ _)\n    ¬∑ exact (mem_closedBall.mp <| mem_preimage.mp (hK‚ÇÇ hx)).trans (le_max_right _ _)\n  exact (dist_triangle (f x) 0 (f y)).trans\n    (add_le_add (mem_closedBall.mp <| this x) (mem_closedBall'.mp <| this y))\n\n"}
{"name":"ZeroAtInftyContinuousMap.isBounded_range","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : PseudoMetricSpace Œ≤\ninst‚úù : Zero Œ≤\nf : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Bornology.IsBounded (Set.range ‚áëf)","decl":"theorem isBounded_range (f : C‚ÇÄ(Œ±, Œ≤)) : IsBounded (range f) :=\n  isBounded_range_iff.2 (ZeroAtInftyContinuousMap.bounded f)\n\n"}
{"name":"ZeroAtInftyContinuousMap.isBounded_image","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : PseudoMetricSpace Œ≤\ninst‚úù : Zero Œ≤\nf : ZeroAtInftyContinuousMap Œ± Œ≤\ns : Set Œ±\n‚ä¢ Bornology.IsBounded (Set.image (‚áëf) s)","decl":"theorem isBounded_image (f : C‚ÇÄ(Œ±, Œ≤)) (s : Set Œ±) : IsBounded (f '' s) :=\n  f.isBounded_range.subset <| image_subset_range _ _\n\n"}
{"name":"ZeroAtInftyContinuousMap.instBoundedContinuousMapClass","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"F : Type u_1\nŒ± : Type u\nŒ≤ : Type v\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : PseudoMetricSpace Œ≤\ninst‚úù¬≤ : Zero Œ≤\ninst‚úù¬π : FunLike F Œ± Œ≤\ninst‚úù : ZeroAtInftyContinuousMapClass F Œ± Œ≤\n‚ä¢ BoundedContinuousMapClass F Œ± Œ≤","decl":"instance (priority := 100) instBoundedContinuousMapClass : BoundedContinuousMapClass F Œ± Œ≤ :=\n  { ‚ÄπZeroAtInftyContinuousMapClass F Œ± Œ≤‚Ä∫ with\n    map_bounded := fun f => ZeroAtInftyContinuousMap.bounded f }\n\n"}
{"name":"ZeroAtInftyContinuousMap.toBCF_apply","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : PseudoMetricSpace Œ≤\ninst‚úù : Zero Œ≤\nf : ZeroAtInftyContinuousMap Œ± Œ≤\na : Œ±\n‚ä¢ Eq (f.toBCF a) (f a)","decl":"/-- Construct a bounded continuous function from a continuous function vanishing at infinity. -/\n@[simps!]\ndef toBCF (f : C‚ÇÄ(Œ±, Œ≤)) : Œ± ‚Üí·µá Œ≤ :=\n  ‚ü®f, map_bounded f‚ü©\n\n"}
{"name":"ZeroAtInftyContinuousMap.toBCF_injective","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : PseudoMetricSpace Œ≤\ninst‚úù : Zero Œ≤\n‚ä¢ Function.Injective ZeroAtInftyContinuousMap.toBCF","decl":"theorem toBCF_injective : Function.Injective (toBCF : C‚ÇÄ(Œ±, Œ≤) ‚Üí Œ± ‚Üí·µá Œ≤) := fun f g h => by\n  ext x\n  simpa only using DFunLike.congr_fun h x\n\n"}
{"name":"ZeroAtInftyContinuousMap.dist_toBCF_eq_dist","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : PseudoMetricSpace Œ≤\ninst‚úù : Zero Œ≤\nf g : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq (Dist.dist f.toBCF g.toBCF) (Dist.dist f g)","decl":"@[simp]\ntheorem dist_toBCF_eq_dist {f g : C‚ÇÄ(Œ±, Œ≤)} : dist f.toBCF g.toBCF = dist f g :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.tendsto_iff_tendstoUniformly","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : PseudoMetricSpace Œ≤\ninst‚úù : Zero Œ≤\nŒπ : Type u_2\nF : Œπ ‚Üí ZeroAtInftyContinuousMap Œ± Œ≤\nf : ZeroAtInftyContinuousMap Œ± Œ≤\nl : Filter Œπ\n‚ä¢ Iff (Filter.Tendsto F l (nhds f)) (TendstoUniformly (fun i => ‚áë(F i)) (‚áëf) l)","decl":"/-- Convergence in the metric on `C‚ÇÄ(Œ±, Œ≤)` is uniform convergence. -/\ntheorem tendsto_iff_tendstoUniformly {Œπ : Type*} {F : Œπ ‚Üí C‚ÇÄ(Œ±, Œ≤)} {f : C‚ÇÄ(Œ±, Œ≤)} {l : Filter Œπ} :\n    Tendsto F l (ùìù f) ‚Üî TendstoUniformly (fun i => F i) f l := by\n  simpa only [Metric.tendsto_nhds] using\n    @BoundedContinuousFunction.tendsto_iff_tendstoUniformly _ _ _ _ _ (fun i => (F i).toBCF)\n      f.toBCF l\n\n"}
{"name":"ZeroAtInftyContinuousMap.isometry_toBCF","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : PseudoMetricSpace Œ≤\ninst‚úù : Zero Œ≤\n‚ä¢ Isometry ZeroAtInftyContinuousMap.toBCF","decl":"theorem isometry_toBCF : Isometry (toBCF : C‚ÇÄ(Œ±, Œ≤) ‚Üí Œ± ‚Üí·µá Œ≤) := by tauto\n\n"}
{"name":"ZeroAtInftyContinuousMap.isClosed_range_toBCF","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : PseudoMetricSpace Œ≤\ninst‚úù : Zero Œ≤\n‚ä¢ IsClosed (Set.range ZeroAtInftyContinuousMap.toBCF)","decl":"theorem isClosed_range_toBCF : IsClosed (range (toBCF : C‚ÇÄ(Œ±, Œ≤) ‚Üí Œ± ‚Üí·µá Œ≤)) := by\n  refine isClosed_iff_clusterPt.mpr fun f hf => ?_\n  rw [clusterPt_principal_iff] at hf\n  have : Tendsto f (cocompact Œ±) (ùìù 0) := by\n    refine Metric.tendsto_nhds.mpr fun Œµ hŒµ => ?_\n    obtain ‚ü®_, hg, g, rfl‚ü© := hf (ball f (Œµ / 2)) (ball_mem_nhds f <| half_pos hŒµ)\n    refine (Metric.tendsto_nhds.mp (zero_at_infty g) (Œµ / 2) (half_pos hŒµ)).mp\n      (Eventually.of_forall fun x hx => ?_)\n    calc\n      dist (f x) 0 ‚â§ dist (g.toBCF x) (f x) + dist (g x) 0 := dist_triangle_left _ _ _\n      _ < dist g.toBCF f + Œµ / 2 := add_lt_add_of_le_of_lt (dist_coe_le_dist x) hx\n      _ < Œµ := by simpa [add_halves Œµ] using add_lt_add_right (mem_ball.1 hg) (Œµ / 2)\n  exact ‚ü®‚ü®f.toContinuousMap, this‚ü©, rfl‚ü©\n\n\n"}
{"name":"ZeroAtInftyContinuousMap.instCompleteSpace","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : PseudoMetricSpace Œ≤\ninst‚úù¬π : Zero Œ≤\ninst‚úù : CompleteSpace Œ≤\n‚ä¢ CompleteSpace (ZeroAtInftyContinuousMap Œ± Œ≤)","decl":"/-- Continuous functions vanishing at infinity taking values in a complete space form a\ncomplete space. -/\ninstance instCompleteSpace [CompleteSpace Œ≤] : CompleteSpace C‚ÇÄ(Œ±, Œ≤) :=\n  (completeSpace_iff_isComplete_range isometry_toBCF.isUniformInducing).mpr\n    isClosed_range_toBCF.isComplete\n\n"}
{"name":"ZeroAtInftyContinuousMap.norm_toBCF_eq_norm","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : SeminormedAddCommGroup Œ≤\nf : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq (Norm.norm f.toBCF) (Norm.norm f)","decl":"@[simp]\ntheorem norm_toBCF_eq_norm {f : C‚ÇÄ(Œ±, Œ≤)} : ‚Äñf.toBCF‚Äñ = ‚Äñf‚Äñ :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.coe_star","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : AddMonoid Œ≤\ninst‚úù¬π : StarAddMonoid Œ≤\ninst‚úù : ContinuousStar Œ≤\nf : ZeroAtInftyContinuousMap Œ± Œ≤\n‚ä¢ Eq (‚áë(Star.star f)) (Star.star ‚áëf)","decl":"@[simp]\ntheorem coe_star (f : C‚ÇÄ(Œ±, Œ≤)) : ‚áë(star f) = star (‚áëf) :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.star_apply","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : AddMonoid Œ≤\ninst‚úù¬π : StarAddMonoid Œ≤\ninst‚úù : ContinuousStar Œ≤\nf : ZeroAtInftyContinuousMap Œ± Œ≤\nx : Œ±\n‚ä¢ Eq ((Star.star f) x) (Star.star (f x))","decl":"theorem star_apply (f : C‚ÇÄ(Œ±, Œ≤)) (x : Œ±) : (star f) x = star (f x) :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.instNormedStarGroup","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : NormedAddCommGroup Œ≤\ninst‚úù¬π : StarAddMonoid Œ≤\ninst‚úù : NormedStarGroup Œ≤\n‚ä¢ NormedStarGroup (ZeroAtInftyContinuousMap Œ± Œ≤)","decl":"instance instNormedStarGroup : NormedStarGroup C‚ÇÄ(Œ±, Œ≤) where\n  norm_star f := (norm_star f.toBCF :)\n\n"}
{"name":"ZeroAtInftyContinuousMap.instStarModule","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Åπ : TopologicalSpace Œ±\nùïú : Type u_2\ninst‚úù‚Å∏ : Zero ùïú\ninst‚úù‚Å∑ : Star ùïú\ninst‚úù‚Å∂ : AddMonoid Œ≤\ninst‚úù‚Åµ : StarAddMonoid Œ≤\ninst‚úù‚Å¥ : TopologicalSpace Œ≤\ninst‚úù¬≥ : ContinuousStar Œ≤\ninst‚úù¬≤ : SMulWithZero ùïú Œ≤\ninst‚úù¬π : ContinuousConstSMul ùïú Œ≤\ninst‚úù : StarModule ùïú Œ≤\n‚ä¢ StarModule ùïú (ZeroAtInftyContinuousMap Œ± Œ≤)","decl":"instance instStarModule : StarModule ùïú C‚ÇÄ(Œ±, Œ≤) where\n  star_smul k f := ext fun x => star_smul k (f x)\n\n"}
{"name":"ZeroAtInftyContinuousMap.instCStarRing","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : NonUnitalNormedRing Œ≤\ninst‚úù¬π : StarRing Œ≤\ninst‚úù : CStarRing Œ≤\n‚ä¢ CStarRing (ZeroAtInftyContinuousMap Œ± Œ≤)","decl":"instance instCStarRing [NonUnitalNormedRing Œ≤] [StarRing Œ≤] [CStarRing Œ≤] : CStarRing C‚ÇÄ(Œ±, Œ≤) where\n  norm_mul_self_le f := CStarRing.norm_mul_self_le (x := f.toBCF)\n\n"}
{"name":"ZeroAtInftyContinuousMap.coe_comp_to_continuous_fun","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ≤ : Type v\nŒ≥ : Type w\nŒ¥ : Type u_2\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : TopologicalSpace Œ≥\ninst‚úù¬π : TopologicalSpace Œ¥\ninst‚úù : Zero Œ¥\nf : ZeroAtInftyContinuousMap Œ≥ Œ¥\ng : CocompactMap Œ≤ Œ≥\n‚ä¢ Eq (‚áë(f.comp g)) (Function.comp ‚áëf ‚áëg)","decl":"@[simp]\ntheorem coe_comp_to_continuous_fun (f : C‚ÇÄ(Œ≥, Œ¥)) (g : Œ≤ ‚Üíco Œ≥) : ((f.comp g) : Œ≤ ‚Üí Œ¥) = f ‚àò g :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.comp_id","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ≥ : Type w\nŒ¥ : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ≥\ninst‚úù¬π : TopologicalSpace Œ¥\ninst‚úù : Zero Œ¥\nf : ZeroAtInftyContinuousMap Œ≥ Œ¥\n‚ä¢ Eq (f.comp (CocompactMap.id Œ≥)) f","decl":"@[simp]\ntheorem comp_id (f : C‚ÇÄ(Œ≥, Œ¥)) : f.comp (CocompactMap.id Œ≥) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.comp_assoc","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù‚Å¥ : TopologicalSpace Œ±\nŒ¥ : Type u_2\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : TopologicalSpace Œ≥\ninst‚úù¬π : TopologicalSpace Œ¥\ninst‚úù : Zero Œ¥\nf : ZeroAtInftyContinuousMap Œ≥ Œ¥\ng : CocompactMap Œ≤ Œ≥\nh : CocompactMap Œ± Œ≤\n‚ä¢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"@[simp]\ntheorem comp_assoc (f : C‚ÇÄ(Œ≥, Œ¥)) (g : Œ≤ ‚Üíco Œ≥) (h : Œ± ‚Üíco Œ≤) :\n    (f.comp g).comp h = f.comp (g.comp h) :=\n  rfl\n\n"}
{"name":"ZeroAtInftyContinuousMap.zero_comp","module":"Mathlib.Topology.ContinuousMap.ZeroAtInfty","initialProofState":"Œ≤ : Type v\nŒ≥ : Type w\nŒ¥ : Type u_2\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : TopologicalSpace Œ≥\ninst‚úù¬π : TopologicalSpace Œ¥\ninst‚úù : Zero Œ¥\ng : CocompactMap Œ≤ Œ≥\n‚ä¢ Eq (ZeroAtInftyContinuousMap.comp 0 g) 0","decl":"@[simp]\ntheorem zero_comp (g : Œ≤ ‚Üíco Œ≥) : (0 : C‚ÇÄ(Œ≥, Œ¥)).comp g = 0 :=\n  rfl\n\n"}
