{"name":"CategoryTheory.Limits.isPullback_equalizer_prod","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Equalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasEqualizer f g\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Y\n⊢ CategoryTheory.IsPullback (CategoryTheory.Limits.equalizer.ι f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.ι f g) f) (CategoryTheory.Limits.prod.lift f g) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Y))","decl":"/-- The equalizer of `f g : X ⟶ Y` is the pullback of the diagonal map `Y ⟶ Y × Y`\nalong the map `(f, g) : X ⟶ Y × Y`. -/\nlemma isPullback_equalizer_prod [HasEqualizer f g] [HasBinaryProduct Y Y] :\n    IsPullback (equalizer.ι f g) (equalizer.ι f g ≫ f) (prod.lift f g) (prod.lift (𝟙 _) (𝟙 _)) := by\n  refine ⟨⟨by ext <;> simp [equalizer.condition f g]⟩, ⟨PullbackCone.IsLimit.mk _ ?_ ?_ ?_ ?_⟩⟩\n  · refine fun s ↦ equalizer.lift s.fst ?_\n    have H₁ : s.fst ≫ f = s.snd := by simpa using congr($s.condition ≫ prod.fst)\n    have H₂ : s.fst ≫ g = s.snd := by simpa using congr($s.condition ≫ prod.snd)\n    exact H₁.trans H₂.symm\n  · exact fun s ↦ by simp\n  · exact fun s ↦ by simpa using congr($s.condition ≫ prod.fst)\n  · exact fun s m hm _ ↦ by ext; simp [*]\n\n"}
{"name":"CategoryTheory.Limits.isPushout_coequalizer_coprod","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Equalizer","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasCoequalizer f g\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X X\n⊢ CategoryTheory.IsPushout (CategoryTheory.Limits.coprod.desc f g) (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.Limits.coequalizer.π f g) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.coequalizer.π f g))","decl":"/-- The coequalizer of `f g : X ⟶ Y` is the pushout of the diagonal map `X ⨿ X ⟶ X`\nalong the map `(f, g) : X ⨿ X ⟶ Y`. -/\nlemma isPushout_coequalizer_coprod [HasCoequalizer f g] [HasBinaryCoproduct X X] :\n    IsPushout (coprod.desc f g) (coprod.desc (𝟙 _) (𝟙 _))\n      (coequalizer.π f g) (f ≫ coequalizer.π f g) := by\n  refine ⟨⟨by ext <;> simp [coequalizer.condition f g]⟩, ⟨PushoutCocone.IsColimit.mk _ ?_ ?_ ?_ ?_⟩⟩\n  · refine fun s ↦ coequalizer.desc s.inl ?_\n    have H₁ : f ≫ s.inl = s.inr := by simpa using congr(coprod.inl ≫ $s.condition)\n    have H₂ : g ≫ s.inl = s.inr := by simpa using congr(coprod.inr ≫ $s.condition)\n    exact H₁.trans H₂.symm\n  · exact fun s ↦ by simp\n  · exact fun s ↦ by simpa using congr(coprod.inl ≫ $s.condition)\n  · exact fun s m hm _ ↦ by ext; simp [*]\n\n"}
