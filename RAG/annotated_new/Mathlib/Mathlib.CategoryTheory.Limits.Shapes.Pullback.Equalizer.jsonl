{"name":"CategoryTheory.Limits.isPullback_equalizer_prod","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Equalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasEqualizer f g\ninstâœ : CategoryTheory.Limits.HasBinaryProduct Y Y\nâŠ¢ CategoryTheory.IsPullback (CategoryTheory.Limits.equalizer.Î¹ f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.Î¹ f g) f) (CategoryTheory.Limits.prod.lift f g) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Y))","decl":"/-- The equalizer of `f g : X âŸ¶ Y` is the pullback of the diagonal map `Y âŸ¶ Y Ã— Y`\nalong the map `(f, g) : X âŸ¶ Y Ã— Y`. -/\nlemma isPullback_equalizer_prod [HasEqualizer f g] [HasBinaryProduct Y Y] :\n    IsPullback (equalizer.Î¹ f g) (equalizer.Î¹ f g â‰« f) (prod.lift f g) (prod.lift (ğŸ™ _) (ğŸ™ _)) := by\n  refine âŸ¨âŸ¨by ext <;> simp [equalizer.condition f g]âŸ©, âŸ¨PullbackCone.IsLimit.mk _ ?_ ?_ ?_ ?_âŸ©âŸ©\n  Â· refine fun s â†¦ equalizer.lift s.fst ?_\n    have Hâ‚ : s.fst â‰« f = s.snd := by simpa using congr($s.condition â‰« prod.fst)\n    have Hâ‚‚ : s.fst â‰« g = s.snd := by simpa using congr($s.condition â‰« prod.snd)\n    exact Hâ‚.trans Hâ‚‚.symm\n  Â· exact fun s â†¦ by simp\n  Â· exact fun s â†¦ by simpa using congr($s.condition â‰« prod.fst)\n  Â· exact fun s m hm _ â†¦ by ext; simp [*]\n\n"}
{"name":"CategoryTheory.Limits.isPushout_coequalizer_coprod","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Equalizer","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizer f g\ninstâœ : CategoryTheory.Limits.HasBinaryCoproduct X X\nâŠ¢ CategoryTheory.IsPushout (CategoryTheory.Limits.coprod.desc f g) (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.Limits.coequalizer.Ï€ f g) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.coequalizer.Ï€ f g))","decl":"/-- The coequalizer of `f g : X âŸ¶ Y` is the pushout of the diagonal map `X â¨¿ X âŸ¶ X`\nalong the map `(f, g) : X â¨¿ X âŸ¶ Y`. -/\nlemma isPushout_coequalizer_coprod [HasCoequalizer f g] [HasBinaryCoproduct X X] :\n    IsPushout (coprod.desc f g) (coprod.desc (ğŸ™ _) (ğŸ™ _))\n      (coequalizer.Ï€ f g) (f â‰« coequalizer.Ï€ f g) := by\n  refine âŸ¨âŸ¨by ext <;> simp [coequalizer.condition f g]âŸ©, âŸ¨PushoutCocone.IsColimit.mk _ ?_ ?_ ?_ ?_âŸ©âŸ©\n  Â· refine fun s â†¦ coequalizer.desc s.inl ?_\n    have Hâ‚ : f â‰« s.inl = s.inr := by simpa using congr(coprod.inl â‰« $s.condition)\n    have Hâ‚‚ : g â‰« s.inl = s.inr := by simpa using congr(coprod.inr â‰« $s.condition)\n    exact Hâ‚.trans Hâ‚‚.symm\n  Â· exact fun s â†¦ by simp\n  Â· exact fun s â†¦ by simpa using congr(coprod.inl â‰« $s.condition)\n  Â· exact fun s m hm _ â†¦ by ext; simp [*]\n\n"}
