{"name":"Finset.map_val","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Finset α\n⊢ Eq (Finset.map f s).val (Multiset.map (⇑f) s.val)","decl":"@[simp]\ntheorem map_val (f : α ↪ β) (s : Finset α) : (map f s).1 = s.1.map f :=\n  rfl\n\n"}
{"name":"Finset.map_empty","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\n⊢ Eq (Finset.map f EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem map_empty (f : α ↪ β) : (∅ : Finset α).map f = ∅ :=\n  rfl\n\n"}
{"name":"Finset.mem_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Finset α\nb : β\n⊢ Iff (Membership.mem (Finset.map f s) b) (Exists fun a => And (Membership.mem s a) (Eq (f a) b))","decl":"@[simp]\ntheorem mem_map {b : β} : b ∈ s.map f ↔ ∃ a ∈ s, f a = b :=\n  Multiset.mem_map\n\n-- Porting note: Higher priority to apply before `mem_map`.\n"}
{"name":"Finset.mem_map_equiv","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nf : Equiv α β\nb : β\n⊢ Iff (Membership.mem (Finset.map f.toEmbedding s) b) (Membership.mem s (f.symm b))","decl":"@[simp 1100]\ntheorem mem_map_equiv {f : α ≃ β} {b : β} : b ∈ s.map f.toEmbedding ↔ f.symm b ∈ s := by\n  rw [mem_map]\n  exact\n    ⟨by\n      rintro ⟨a, H, rfl⟩\n      simpa, fun h => ⟨_, h, by simp⟩⟩\n\n"}
{"name":"Finset.mem_map'","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\na : α\ns : Finset α\n⊢ Iff (Membership.mem (Finset.map f s) (f a)) (Membership.mem s a)","decl":"@[simp 1100]\ntheorem mem_map' (f : α ↪ β) {a} {s : Finset α} : f a ∈ s.map f ↔ a ∈ s :=\n  mem_map_of_injective f.2\n\n"}
{"name":"Finset.mem_map_of_mem","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\na : α\ns : Finset α\na✝ : Membership.mem s a\n⊢ Membership.mem (Finset.map f s) (f a)","decl":"theorem mem_map_of_mem (f : α ↪ β) {a} {s : Finset α} : a ∈ s → f a ∈ s.map f :=\n  (mem_map' _).2\n\n"}
{"name":"Finset.forall_mem_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Finset α\np : (a : β) → Membership.mem (Finset.map f s) a → Prop\n⊢ Iff (∀ (y : β) (H : Membership.mem (Finset.map f s) y), p y H) (∀ (x : α) (H : Membership.mem s x), p (f x) ⋯)","decl":"theorem forall_mem_map {f : α ↪ β} {s : Finset α} {p : ∀ a, a ∈ s.map f → Prop} :\n    (∀ y (H : y ∈ s.map f), p y H) ↔ ∀ x (H : x ∈ s), p (f x) (mem_map_of_mem _ H) :=\n  ⟨fun h y hy => h (f y) (mem_map_of_mem _ hy),\n   fun h x hx => by\n    obtain ⟨y, hy, rfl⟩ := mem_map.1 hx\n    exact h _ hy⟩\n\n"}
{"name":"Finset.apply_coe_mem_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Finset α\nx : Subtype fun x => Membership.mem s x\n⊢ Membership.mem (Finset.map f s) (f ↑x)","decl":"theorem apply_coe_mem_map (f : α ↪ β) (s : Finset α) (x : s) : f x ∈ s.map f :=\n  mem_map_of_mem f x.prop\n\n"}
{"name":"Finset.coe_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Finset α\n⊢ Eq (↑(Finset.map f s)) (Set.image ⇑f ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_map (f : α ↪ β) (s : Finset α) : (s.map f : Set β) = f '' s :=\n  Set.ext (by simp only [mem_coe, mem_map, Set.mem_image, implies_true])\n\n"}
{"name":"Finset.coe_map_subset_range","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Finset α\n⊢ HasSubset.Subset (↑(Finset.map f s)) (Set.range ⇑f)","decl":"theorem coe_map_subset_range (f : α ↪ β) (s : Finset α) : (s.map f : Set β) ⊆ Set.range f :=\n  calc\n    ↑(s.map f) = f '' s := coe_map f s\n    _ ⊆ Set.range f := Set.image_subset_range f ↑s\n\n"}
{"name":"Finset.map_perm","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\ns : Finset α\nσ : Equiv.Perm α\nhs : HasSubset.Subset (setOf fun a => Ne (σ a) a) ↑s\n⊢ Eq (Finset.map (Equiv.toEmbedding σ) s) s","decl":"/-- If the only elements outside `s` are those left fixed by `σ`, then mapping by `σ` has no effect.\n-/\ntheorem map_perm {σ : Equiv.Perm α} (hs : { a | σ a ≠ a } ⊆ s) : s.map (σ : α ↪ α) = s :=\n  coe_injective <| (coe_map _ _).trans <| Set.image_perm hs\n\n"}
{"name":"Finset.map_toFinset","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\ns : Multiset α\n⊢ Eq (Finset.map f s.toFinset) (Multiset.map (⇑f) s).toFinset","decl":"theorem map_toFinset [DecidableEq α] [DecidableEq β] {s : Multiset α} :\n    s.toFinset.map f = (s.map f).toFinset :=\n  ext fun _ => by simp only [mem_map, Multiset.mem_map, exists_prop, Multiset.mem_toFinset]\n\n"}
{"name":"Finset.map_refl","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (Finset.map (Function.Embedding.refl α) s) s","decl":"@[simp]\ntheorem map_refl : s.map (Embedding.refl _) = s :=\n  ext fun _ => by simpa only [mem_map, exists_prop] using exists_eq_right\n\n"}
{"name":"Finset.map_cast_heq","module":"Mathlib.Data.Finset.Image","initialProofState":"α β : Type u_4\nh : Eq α β\ns : Finset α\n⊢ HEq (Finset.map (Equiv.cast h).toEmbedding s) s","decl":"@[simp]\ntheorem map_cast_heq {α β} (h : α = β) (s : Finset α) :\n    HEq (s.map (Equiv.cast h).toEmbedding) s := by\n  subst h\n  simp\n\n"}
{"name":"Finset.map_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Function.Embedding α β\ng : Function.Embedding β γ\ns : Finset α\n⊢ Eq (Finset.map g (Finset.map f s)) (Finset.map (f.trans g) s)","decl":"theorem map_map (f : α ↪ β) (g : β ↪ γ) (s : Finset α) : (s.map f).map g = s.map (f.trans g) :=\n  eq_of_veq <| by simp only [map_val, Multiset.map_map]; rfl\n\n"}
{"name":"Finset.map_comm","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Finset α\nβ' : Type u_4\nf : Function.Embedding β γ\ng : Function.Embedding α β\nf' : Function.Embedding α β'\ng' : Function.Embedding β' γ\nh_comm : ∀ (a : α), Eq (f (g a)) (g' (f' a))\n⊢ Eq (Finset.map f (Finset.map g s)) (Finset.map g' (Finset.map f' s))","decl":"theorem map_comm {β'} {f : β ↪ γ} {g : α ↪ β} {f' : α ↪ β'} {g' : β' ↪ γ}\n    (h_comm : ∀ a, f (g a) = g' (f' a)) : (s.map g).map f = (s.map f').map g' := by\n  simp_rw [map_map, Embedding.trans, Function.comp_def, h_comm]\n\n"}
{"name":"Function.Semiconj.finset_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\nga : Function.Embedding α α\ngb : Function.Embedding β β\nh : Function.Semiconj ⇑f ⇑ga ⇑gb\n⊢ Function.Semiconj (Finset.map f) (Finset.map ga) (Finset.map gb)","decl":"theorem _root_.Function.Semiconj.finset_map {f : α ↪ β} {ga : α ↪ α} {gb : β ↪ β}\n    (h : Function.Semiconj f ga gb) : Function.Semiconj (map f) (map ga) (map gb) := fun _ =>\n  map_comm h\n\n"}
{"name":"Function.Commute.finset_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nf g : Function.Embedding α α\nh : Function.Commute ⇑f ⇑g\n⊢ Function.Commute (Finset.map f) (Finset.map g)","decl":"theorem _root_.Function.Commute.finset_map {f g : α ↪ α} (h : Function.Commute f g) :\n    Function.Commute (map f) (map g) :=\n  Function.Semiconj.finset_map h\n\n"}
{"name":"Finset.map_subset_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns₁ s₂ : Finset α\n⊢ Iff (HasSubset.Subset (Finset.map f s₁) (Finset.map f s₂)) (HasSubset.Subset s₁ s₂)","decl":"@[simp]\ntheorem map_subset_map {s₁ s₂ : Finset α} : s₁.map f ⊆ s₂.map f ↔ s₁ ⊆ s₂ :=\n  ⟨fun h _ xs => (mem_map' _).1 <| h <| (mem_map' f).2 xs,\n   fun h => by simp [subset_def, Multiset.map_subset_map h]⟩\n\n"}
{"name":"GCongr.finsetMap_subset","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns₁ s₂ : Finset α\na✝ : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (Finset.map f s₁) (Finset.map f s₂)","decl":"@[gcongr] alias ⟨_, _root_.GCongr.finsetMap_subset⟩ := map_subset_map\n\n"}
{"name":"Finset.subset_map_symm","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nf : Equiv α β\n⊢ Iff (HasSubset.Subset s (Finset.map f.symm.toEmbedding t)) (HasSubset.Subset (Finset.map f.toEmbedding s) t)","decl":"/-- The `Finset` version of `Equiv.subset_symm_image`. -/\ntheorem subset_map_symm {t : Finset β} {f : α ≃ β} : s ⊆ t.map f.symm ↔ s.map f ⊆ t := by\n  constructor <;> intro h x hx\n  · simp only [mem_map_equiv, Equiv.symm_symm] at hx\n    simpa using h hx\n  · simp only [mem_map_equiv]\n    exact h (by simp [hx])\n\n"}
{"name":"Finset.map_symm_subset","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nf : Equiv α β\n⊢ Iff (HasSubset.Subset (Finset.map f.symm.toEmbedding t) s) (HasSubset.Subset t (Finset.map f.toEmbedding s))","decl":"/-- The `Finset` version of `Equiv.symm_image_subset`. -/\ntheorem map_symm_subset {t : Finset β} {f : α ≃ β} : t.map f.symm ⊆ s ↔ t ⊆ s.map f := by\n  simp only [← subset_map_symm, Equiv.symm_symm]\n\n"}
{"name":"Finset.map_inj","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns₁ s₂ : Finset α\n⊢ Iff (Eq (Finset.map f s₁) (Finset.map f s₂)) (Eq s₁ s₂)","decl":"@[simp]\ntheorem map_inj {s₁ s₂ : Finset α} : s₁.map f = s₂.map f ↔ s₁ = s₂ :=\n  (mapEmbedding f).injective.eq_iff\n\n"}
{"name":"Finset.map_injective","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\n⊢ Function.Injective (Finset.map f)","decl":"theorem map_injective (f : α ↪ β) : Injective (map f) :=\n  (mapEmbedding f).injective\n\n"}
{"name":"Finset.map_ssubset_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns t : Finset α\n⊢ Iff (HasSSubset.SSubset (Finset.map f s) (Finset.map f t)) (HasSSubset.SSubset s t)","decl":"@[simp]\ntheorem map_ssubset_map {s t : Finset α} : s.map f ⊂ t.map f ↔ s ⊂ t := (mapEmbedding f).lt_iff_lt\n\n"}
{"name":"GCongr.finsetMap_ssubset","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns t : Finset α\na✝ : HasSSubset.SSubset s t\n⊢ HasSSubset.SSubset (Finset.map f s) (Finset.map f t)","decl":"@[gcongr] alias ⟨_, _root_.GCongr.finsetMap_ssubset⟩ := map_ssubset_map\n\n"}
{"name":"Finset.mapEmbedding_apply","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Finset α\n⊢ Eq ((Finset.mapEmbedding f) s) (Finset.map f s)","decl":"@[simp]\ntheorem mapEmbedding_apply : mapEmbedding f s = map f s :=\n  rfl\n\n"}
{"name":"Finset.filter_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Finset α\np : β → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finset.filter p (Finset.map f s)) (Finset.map f (Finset.filter (Function.comp p ⇑f) s))","decl":"theorem filter_map {p : β → Prop} [DecidablePred p] :\n    (s.map f).filter p = (s.filter (p ∘ f)).map f :=\n  eq_of_veq (Multiset.filter_map _ _ _)\n\n"}
{"name":"Finset.map_filter'","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → Prop\ninst✝¹ : DecidablePred p\nf : Function.Embedding α β\ns : Finset α\ninst✝ : DecidablePred fun x => Exists fun a => And (p a) (Eq (f a) x)\n⊢ Eq (Finset.map f (Finset.filter p s)) (Finset.filter (fun b => Exists fun a => And (p a) (Eq (f a) b)) (Finset.map f s))","decl":"lemma map_filter' (p : α → Prop) [DecidablePred p] (f : α ↪ β) (s : Finset α)\n    [DecidablePred (∃ a, p a ∧ f a = ·)] :\n    (s.filter p).map f = (s.map f).filter fun b => ∃ a, p a ∧ f a = b := by\n  simp [Function.comp_def, filter_map, f.injective.eq_iff]\n\n"}
{"name":"Finset.filter_attach'","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ns : Finset α\np : (Subtype fun x => Membership.mem s x) → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finset.filter p s.attach) (Finset.map { toFun := Subtype.map id ⋯, inj' := ⋯ } (Finset.filter (fun x => Exists fun h => p ⟨x, h⟩) s).attach)","decl":"lemma filter_attach' [DecidableEq α] (s : Finset α) (p : s → Prop) [DecidablePred p] :\n    s.attach.filter p =\n      (s.filter fun x => ∃ h, p ⟨x, h⟩).attach.map\n        ⟨Subtype.map id <| filter_subset _ _, Subtype.map_injective _ injective_id⟩ :=\n  eq_of_veq <| Multiset.filter_attach' _ _\n\n"}
{"name":"Finset.filter_attach","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\n⊢ Eq (Finset.filter (fun a => p ↑a) s.attach) (Finset.map ((Function.Embedding.refl α).subtypeMap ⋯) (Finset.filter p s).attach)","decl":"lemma filter_attach (p : α → Prop) [DecidablePred p] (s : Finset α) :\n    s.attach.filter (fun a : s ↦ p a) =\n      (s.filter p).attach.map ((Embedding.refl _).subtypeMap mem_of_mem_filter) :=\n  eq_of_veq <| Multiset.filter_attach _ _\n\n"}
{"name":"Finset.map_filter","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nf : Equiv α β\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finset.map f.toEmbedding (Finset.filter p s)) (Finset.filter (Function.comp p ⇑f.symm) (Finset.map f.toEmbedding s))","decl":"theorem map_filter {f : α ≃ β} {p : α → Prop} [DecidablePred p] :\n    (s.filter p).map f.toEmbedding = (s.map f.toEmbedding).filter (p ∘ f.symm) := by\n  simp only [filter_map, Function.comp_def, Equiv.toEmbedding_apply, Equiv.symm_apply_apply]\n\n"}
{"name":"Finset.disjoint_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ns t : Finset α\nf : Function.Embedding α β\n⊢ Iff (Disjoint (Finset.map f s) (Finset.map f t)) (Disjoint s t)","decl":"@[simp]\ntheorem disjoint_map {s t : Finset α} (f : α ↪ β) :\n    Disjoint (s.map f) (t.map f) ↔ Disjoint s t :=\n  mod_cast Set.disjoint_image_iff f.injective (s := s) (t := t)\n\n"}
{"name":"Finset.map_disjUnion","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns₁ s₂ : Finset α\nh : Disjoint s₁ s₂\nh' : optParam (Disjoint (Finset.map f s₁) (Finset.map f s₂)) ⋯\n⊢ Eq (Finset.map f (s₁.disjUnion s₂ h)) ((Finset.map f s₁).disjUnion (Finset.map f s₂) h')","decl":"theorem map_disjUnion {f : α ↪ β} (s₁ s₂ : Finset α) (h) (h' := (disjoint_map _).mpr h) :\n    (s₁.disjUnion s₂ h).map f = (s₁.map f).disjUnion (s₂.map f) h' :=\n  eq_of_veq <| Multiset.map_add _ _ _\n\n"}
{"name":"Finset.map_disjUnion'","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns₁ s₂ : Finset α\nh' : Disjoint (Finset.map f s₁) (Finset.map f s₂)\nh : optParam (Disjoint s₁ s₂) ⋯\n⊢ Eq (Finset.map f (s₁.disjUnion s₂ h)) ((Finset.map f s₁).disjUnion (Finset.map f s₂) h')","decl":"/-- A version of `Finset.map_disjUnion` for writing in the other direction. -/\ntheorem map_disjUnion' {f : α ↪ β} (s₁ s₂ : Finset α) (h') (h := (disjoint_map _).mp h') :\n    (s₁.disjUnion s₂ h).map f = (s₁.map f).disjUnion (s₂.map f) h' :=\n  map_disjUnion _ _ _\n\n"}
{"name":"Finset.map_union","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : Function.Embedding α β\ns₁ s₂ : Finset α\n⊢ Eq (Finset.map f (Union.union s₁ s₂)) (Union.union (Finset.map f s₁) (Finset.map f s₂))","decl":"theorem map_union [DecidableEq α] [DecidableEq β] {f : α ↪ β} (s₁ s₂ : Finset α) :\n    (s₁ ∪ s₂).map f = s₁.map f ∪ s₂.map f :=\n  mod_cast Set.image_union f s₁ s₂\n\n"}
{"name":"Finset.map_inter","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : Function.Embedding α β\ns₁ s₂ : Finset α\n⊢ Eq (Finset.map f (Inter.inter s₁ s₂)) (Inter.inter (Finset.map f s₁) (Finset.map f s₂))","decl":"theorem map_inter [DecidableEq α] [DecidableEq β] {f : α ↪ β} (s₁ s₂ : Finset α) :\n    (s₁ ∩ s₂).map f = s₁.map f ∩ s₂.map f :=\n  mod_cast Set.image_inter f.injective (s := s₁) (t := s₂)\n\n"}
{"name":"Finset.map_singleton","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\na : α\n⊢ Eq (Finset.map f (Singleton.singleton a)) (Singleton.singleton (f a))","decl":"@[simp]\ntheorem map_singleton (f : α ↪ β) (a : α) : map f {a} = {f a} :=\n  coe_injective <| by simp only [coe_map, coe_singleton, Set.image_singleton]\n\n"}
{"name":"Finset.map_insert","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : Function.Embedding α β\na : α\ns : Finset α\n⊢ Eq (Finset.map f (Insert.insert a s)) (Insert.insert (f a) (Finset.map f s))","decl":"@[simp]\ntheorem map_insert [DecidableEq α] [DecidableEq β] (f : α ↪ β) (a : α) (s : Finset α) :\n    (insert a s).map f = insert (f a) (s.map f) := by\n  simp only [insert_eq, map_union, map_singleton]\n\n"}
{"name":"Finset.map_cons","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\na : α\ns : Finset α\nha : Not (Membership.mem s a)\n⊢ Eq (Finset.map f (Finset.cons a s ha)) (Finset.cons (f a) (Finset.map f s) ⋯)","decl":"@[simp]\ntheorem map_cons (f : α ↪ β) (a : α) (s : Finset α) (ha : a ∉ s) :\n    (cons a s ha).map f = cons (f a) (s.map f) (by simpa using ha) :=\n  eq_of_veq <| Multiset.map_cons f a s.val\n\n"}
{"name":"Finset.map_eq_empty","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Finset α\n⊢ Iff (Eq (Finset.map f s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem map_eq_empty : s.map f = ∅ ↔ s = ∅ := (map_injective f).eq_iff' (map_empty f)\n\n"}
{"name":"Finset.map_nonempty","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Finset α\n⊢ Iff (Finset.map f s).Nonempty s.Nonempty","decl":"@[simp]\ntheorem map_nonempty : (s.map f).Nonempty ↔ s.Nonempty :=\n  mod_cast Set.image_nonempty (f := f) (s := s)\n\n"}
{"name":"Finset.Nonempty.map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Finset α\na✝ : s.Nonempty\n⊢ (Finset.map f s).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nprotected alias ⟨_, Nonempty.map⟩ := map_nonempty\n\n"}
{"name":"Finset.map_nontrivial","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Finset α\n⊢ Iff (Finset.map f s).Nontrivial s.Nontrivial","decl":"@[simp]\ntheorem map_nontrivial : (s.map f).Nontrivial ↔ s.Nontrivial :=\n  mod_cast Set.image_nontrivial f.injective (s := s)\n\n"}
{"name":"Finset.attach_map_val","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (Finset.map (Function.Embedding.subtype fun x => Membership.mem s x) s.attach) s","decl":"theorem attach_map_val {s : Finset α} : s.attach.map (Embedding.subtype _) = s :=\n  eq_of_veq <| by rw [map_val, attach_val]; exact Multiset.attach_map_val _\n\n"}
{"name":"Finset.disjoint_range_addLeftEmbedding","module":"Mathlib.Data.Finset.Image","initialProofState":"a : Nat\ns : Finset Nat\n⊢ Disjoint (Finset.range a) (Finset.map (addLeftEmbedding a) s)","decl":"theorem disjoint_range_addLeftEmbedding (a : ℕ) (s : Finset ℕ) :\n    Disjoint (range a) (map (addLeftEmbedding a) s) := by\n  simp_rw [disjoint_left, mem_map, mem_range, addLeftEmbedding_apply]\n  rintro _ h ⟨l, -, rfl⟩\n  omega\n\n"}
{"name":"Finset.disjoint_range_addRightEmbedding","module":"Mathlib.Data.Finset.Image","initialProofState":"a : Nat\ns : Finset Nat\n⊢ Disjoint (Finset.range a) (Finset.map (addRightEmbedding a) s)","decl":"theorem disjoint_range_addRightEmbedding (a : ℕ) (s : Finset ℕ) :\n    Disjoint (range a) (map (addRightEmbedding a) s) := by\n  rw [← addLeftEmbedding_eq_addRightEmbedding]\n  apply disjoint_range_addLeftEmbedding\n\n"}
{"name":"Finset.map_disjiUnion","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Function.Embedding α β\ns : Finset α\nt : β → Finset γ\nh : (↑(Finset.map f s)).PairwiseDisjoint t\n⊢ Eq ((Finset.map f s).disjiUnion t h) (s.disjiUnion (fun a => t (f a)) ⋯)","decl":"theorem map_disjiUnion {f : α ↪ β} {s : Finset α} {t : β → Finset γ} {h} :\n    (s.map f).disjiUnion t h =\n      s.disjiUnion (fun a => t (f a)) fun _ ha _ hb hab =>\n        h (mem_map_of_mem _ ha) (mem_map_of_mem _ hb) (f.injective.ne hab) :=\n  eq_of_veq <| Multiset.bind_map _ _ _\n\n"}
{"name":"Finset.disjiUnion_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Finset α\nt : α → Finset β\nf : Function.Embedding β γ\nh : (↑s).PairwiseDisjoint t\n⊢ Eq (Finset.map f (s.disjiUnion t h)) (s.disjiUnion (fun a => Finset.map f (t a)) ⋯)","decl":"theorem disjiUnion_map {s : Finset α} {t : α → Finset β} {f : β ↪ γ} {h} :\n    (s.disjiUnion t h).map f =\n      s.disjiUnion (fun a => (t a).map f) (h.mono' fun _ _ ↦ (disjoint_map _).2) :=\n  eq_of_veq <| Multiset.map_bind _ _ _\n\n"}
{"name":"Finset.range_add_one'","module":"Mathlib.Data.Finset.Image","initialProofState":"n : Nat\n⊢ Eq (Finset.range (HAdd.hAdd n 1)) (Insert.insert 0 (Finset.map { toFun := fun i => HAdd.hAdd i 1, inj' := ⋯ } (Finset.range n)))","decl":"theorem range_add_one' (n : ℕ) :\n    range (n + 1) = insert 0 ((range n).map ⟨fun i => i + 1, fun i j => by simp⟩) := by\n  ext (⟨⟩ | ⟨n⟩) <;> simp [Nat.zero_lt_succ n]\n\n"}
{"name":"Finset.image_val","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\n⊢ Eq (Finset.image f s).val (Multiset.map f s.val).dedup","decl":"@[simp]\ntheorem image_val (f : α → β) (s : Finset α) : (image f s).1 = (s.1.map f).dedup :=\n  rfl\n\n"}
{"name":"Finset.image_empty","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\n⊢ Eq (Finset.image f EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem image_empty (f : α → β) : (∅ : Finset α).image f = ∅ :=\n  rfl\n\n"}
{"name":"Finset.mem_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\nb : β\n⊢ Iff (Membership.mem (Finset.image f s) b) (Exists fun a => And (Membership.mem s a) (Eq (f a) b))","decl":"@[simp]\ntheorem mem_image : b ∈ s.image f ↔ ∃ a ∈ s, f a = b := by\n  simp only [mem_def, image_val, mem_dedup, Multiset.mem_map, exists_prop]\n\n"}
{"name":"Finset.mem_image_of_mem","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset α\nf : α → β\na : α\nh : Membership.mem s a\n⊢ Membership.mem (Finset.image f s) (f a)","decl":"theorem mem_image_of_mem (f : α → β) {a} (h : a ∈ s) : f a ∈ s.image f :=\n  mem_image.2 ⟨_, h, rfl⟩\n\n"}
{"name":"Finset.forall_mem_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\np : β → Prop\n⊢ Iff (∀ (y : β), Membership.mem (Finset.image f s) y → p y) (∀ ⦃x : α⦄, Membership.mem s x → p (f x))","decl":"lemma forall_mem_image {p : β → Prop} : (∀ y ∈ s.image f, p y) ↔ ∀ ⦃x⦄, x ∈ s → p (f x) := by simp\n"}
{"name":"Finset.exists_mem_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\np : β → Prop\n⊢ Iff (Exists fun y => And (Membership.mem (Finset.image f s) y) (p y)) (Exists fun x => And (Membership.mem s x) (p (f x)))","decl":"lemma exists_mem_image {p : β → Prop} : (∃ y ∈ s.image f, p y) ↔ ∃ x ∈ s, p (f x) := by simp\n\n"}
{"name":"Finset.forall_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\np : β → Prop\n⊢ Iff (∀ (y : β), Membership.mem (Finset.image f s) y → p y) (∀ ⦃x : α⦄, Membership.mem s x → p (f x))","decl":"@[deprecated (since := \"2024-11-23\")] alias forall_image := forall_mem_image\n\n"}
{"name":"Finset.map_eq_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : Function.Embedding α β\ns : Finset α\n⊢ Eq (Finset.map f s) (Finset.image (⇑f) s)","decl":"theorem map_eq_image (f : α ↪ β) (s : Finset α) : s.map f = s.image f :=\n  eq_of_veq (s.map f).2.dedup.symm\n\n--@[simp] Porting note: removing simp, `simp` [Nonempty] can prove it\n"}
{"name":"Finset.mem_image_const","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset α\nb c : β\n⊢ Iff (Membership.mem (Finset.image (Function.const α b) s) c) (And s.Nonempty (Eq b c))","decl":"theorem mem_image_const : c ∈ s.image (const α b) ↔ s.Nonempty ∧ b = c := by\n  rw [mem_image]\n  simp only [exists_prop, const_apply, exists_and_right]\n  rfl\n\n"}
{"name":"Finset.mem_image_const_self","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset α\nb : β\n⊢ Iff (Membership.mem (Finset.image (Function.const α b) s) b) s.Nonempty","decl":"theorem mem_image_const_self : b ∈ s.image (const α b) ↔ s.Nonempty :=\n  mem_image_const.trans <| and_iff_left rfl\n\n"}
{"name":"Finset.canLift","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\nc : α → β\np : β → Prop\ninst✝ : CanLift β α c p\n⊢ CanLift (Finset β) (Finset α) (Finset.image c) fun s => ∀ (x : β), Membership.mem s x → p x","decl":"instance canLift (c) (p) [CanLift β α c p] :\n    CanLift (Finset β) (Finset α) (image c) fun s => ∀ x ∈ s, p x where\n  prf := by\n    rintro ⟨⟨l⟩, hd : l.Nodup⟩ hl\n    lift l to List α using hl\n    exact ⟨⟨l, hd.of_map _⟩, ext fun a => by simp⟩\n\n"}
{"name":"Finset.image_congr","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf g : α → β\ns : Finset α\nh : Set.EqOn f g ↑s\n⊢ Eq (Finset.image f s) (Finset.image g s)","decl":"theorem image_congr (h : (s : Set α).EqOn f g) : Finset.image f s = Finset.image g s := by\n  ext\n  simp_rw [mem_image, ← bex_def]\n  exact exists₂_congr fun x hx => by rw [h hx]\n\n"}
{"name":"Function.Injective.mem_finset_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\na : α\nhf : Function.Injective f\n⊢ Iff (Membership.mem (Finset.image f s) (f a)) (Membership.mem s a)","decl":"theorem _root_.Function.Injective.mem_finset_image (hf : Injective f) :\n    f a ∈ s.image f ↔ a ∈ s := by\n  refine ⟨fun h => ?_, Finset.mem_image_of_mem f⟩\n  obtain ⟨y, hy, heq⟩ := mem_image.1 h\n  exact hf heq ▸ hy\n\n\n"}
{"name":"Finset.coe_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\n⊢ Eq (↑(Finset.image f s)) (Set.image f ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_image : ↑(s.image f) = f '' ↑s :=\n  Set.ext <| by simp only [mem_coe, mem_image, Set.mem_image, implies_true]\n\n"}
{"name":"Finset.image_nonempty","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\n⊢ Iff (Finset.image f s).Nonempty s.Nonempty","decl":"@[simp]\nlemma image_nonempty : (s.image f).Nonempty ↔ s.Nonempty :=\n  mod_cast Set.image_nonempty (f := f) (s := (s : Set α))\n\n"}
{"name":"Finset.Nonempty.image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset α\nh : s.Nonempty\nf : α → β\n⊢ (Finset.image f s).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nprotected theorem Nonempty.image (h : s.Nonempty) (f : α → β) : (s.image f).Nonempty :=\n  image_nonempty.2 h\n\n"}
{"name":"Finset.Nonempty.of_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\na✝ : (Finset.image f s).Nonempty\n⊢ s.Nonempty","decl":"alias ⟨Nonempty.of_image, _⟩ := image_nonempty\n\n"}
{"name":"Finset.image_toFinset","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\nf : α → β\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq (Finset.image f s.toFinset) (Multiset.map f s).toFinset","decl":"theorem image_toFinset [DecidableEq α] {s : Multiset α} :\n    s.toFinset.image f = (s.map f).toFinset :=\n  ext fun _ => by simp only [mem_image, Multiset.mem_toFinset, exists_prop, Multiset.mem_map]\n\n"}
{"name":"Finset.image_val_of_injOn","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\nH : Set.InjOn f ↑s\n⊢ Eq (Finset.image f s).val (Multiset.map f s.val)","decl":"theorem image_val_of_injOn (H : Set.InjOn f s) : (image f s).1 = s.1.map f :=\n  (s.2.map_on H).dedup\n\n"}
{"name":"Finset.image_id","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\n⊢ Eq (Finset.image id s) s","decl":"@[simp]\ntheorem image_id [DecidableEq α] : s.image id = s :=\n  ext fun _ => by simp only [mem_image, exists_prop, id, exists_eq_right]\n\n"}
{"name":"Finset.image_id'","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\n⊢ Eq (Finset.image (fun x => x) s) s","decl":"@[simp]\ntheorem image_id' [DecidableEq α] : (s.image fun x => x) = s :=\n  image_id\n\n"}
{"name":"Finset.image_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : DecidableEq β\nf : α → β\ns : Finset α\ninst✝ : DecidableEq γ\ng : β → γ\n⊢ Eq (Finset.image g (Finset.image f s)) (Finset.image (Function.comp g f) s)","decl":"theorem image_image [DecidableEq γ] {g : β → γ} : (s.image f).image g = s.image (g ∘ f) :=\n  eq_of_veq <| by simp only [image_val, dedup_map_dedup_eq, Multiset.map_map]\n\n"}
{"name":"Finset.image_comm","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : DecidableEq β\ns : Finset α\nβ' : Type u_4\ninst✝¹ : DecidableEq β'\ninst✝ : DecidableEq γ\nf : β → γ\ng : α → β\nf' : α → β'\ng' : β' → γ\nh_comm : ∀ (a : α), Eq (f (g a)) (g' (f' a))\n⊢ Eq (Finset.image f (Finset.image g s)) (Finset.image g' (Finset.image f' s))","decl":"theorem image_comm {β'} [DecidableEq β'] [DecidableEq γ] {f : β → γ} {g : α → β} {f' : α → β'}\n    {g' : β' → γ} (h_comm : ∀ a, f (g a) = g' (f' a)) :\n    (s.image g).image f = (s.image f').image g' := by simp_rw [image_image, comp_def, h_comm]\n\n"}
{"name":"Function.Semiconj.finset_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\nf : α → β\nga : α → α\ngb : β → β\nh : Function.Semiconj f ga gb\n⊢ Function.Semiconj (Finset.image f) (Finset.image ga) (Finset.image gb)","decl":"theorem _root_.Function.Semiconj.finset_image [DecidableEq α] {f : α → β} {ga : α → α} {gb : β → β}\n    (h : Function.Semiconj f ga gb) : Function.Semiconj (image f) (image ga) (image gb) := fun _ =>\n  image_comm h\n\n"}
{"name":"Function.Commute.finset_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nf g : α → α\nh : Function.Commute f g\n⊢ Function.Commute (Finset.image f) (Finset.image g)","decl":"theorem _root_.Function.Commute.finset_image [DecidableEq α] {f g : α → α}\n    (h : Function.Commute f g) : Function.Commute (image f) (image g) :=\n  Function.Semiconj.finset_image h\n\n"}
{"name":"Finset.image_subset_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns₁ s₂ : Finset α\nh : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (Finset.image f s₁) (Finset.image f s₂)","decl":"theorem image_subset_image {s₁ s₂ : Finset α} (h : s₁ ⊆ s₂) : s₁.image f ⊆ s₂.image f := by\n  simp only [subset_def, image_val, subset_dedup', dedup_subset', Multiset.map_subset_map h]\n\n"}
{"name":"Finset.image_subset_iff","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\nt : Finset β\n⊢ Iff (HasSubset.Subset (Finset.image f s) t) (∀ (x : α), Membership.mem s x → Membership.mem t (f x))","decl":"theorem image_subset_iff : s.image f ⊆ t ↔ ∀ x ∈ s, f x ∈ t :=\n  calc\n    s.image f ⊆ t ↔ f '' ↑s ⊆ ↑t := by norm_cast\n    _ ↔ _ := Set.image_subset_iff\n\n"}
{"name":"Finset.image_mono","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\n⊢ Monotone (Finset.image f)","decl":"theorem image_mono (f : α → β) : Monotone (Finset.image f) := fun _ _ => image_subset_image\n\n"}
{"name":"Finset.image_injective","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\nhf : Function.Injective f\n⊢ Function.Injective (Finset.image f)","decl":"lemma image_injective (hf : Injective f) : Injective (image f) := by\n  simpa only [funext (map_eq_image _)] using map_injective ⟨f, hf⟩\n\n"}
{"name":"Finset.image_inj","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns t : Finset α\nhf : Function.Injective f\n⊢ Iff (Eq (Finset.image f s) (Finset.image f t)) (Eq s t)","decl":"lemma image_inj {t : Finset α} (hf : Injective f) : s.image f = t.image f ↔ s = t :=\n  (image_injective hf).eq_iff\n\n"}
{"name":"Finset.image_subset_image_iff","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns t : Finset α\nhf : Function.Injective f\n⊢ Iff (HasSubset.Subset (Finset.image f s) (Finset.image f t)) (HasSubset.Subset s t)","decl":"theorem image_subset_image_iff {t : Finset α} (hf : Injective f) :\n    s.image f ⊆ t.image f ↔ s ⊆ t :=\n  mod_cast Set.image_subset_image_iff hf (s := s) (t := t)\n\n"}
{"name":"Finset.image_ssubset_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns t : Finset α\nhf : Function.Injective f\n⊢ Iff (HasSSubset.SSubset (Finset.image f s) (Finset.image f t)) (HasSSubset.SSubset s t)","decl":"lemma image_ssubset_image {t : Finset α} (hf : Injective f) : s.image f ⊂ t.image f ↔ s ⊂ t := by\n  simp_rw [← lt_iff_ssubset]\n  exact lt_iff_lt_of_le_iff_le' (image_subset_image_iff hf) (image_subset_image_iff hf)\n\n"}
{"name":"Finset.coe_image_subset_range","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\n⊢ HasSubset.Subset (↑(Finset.image f s)) (Set.range f)","decl":"theorem coe_image_subset_range : ↑(s.image f) ⊆ Set.range f :=\n  calc\n    ↑(s.image f) = f '' ↑s := coe_image\n    _ ⊆ Set.range f := Set.image_subset_range f ↑s\n\n"}
{"name":"Finset.filter_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\nf : α → β\ns : Finset α\np : β → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finset.filter p (Finset.image f s)) (Finset.image f (Finset.filter (fun a => p (f a)) s))","decl":"theorem filter_image {p : β → Prop} [DecidablePred p] :\n    (s.image f).filter p = (s.filter fun a ↦ p (f a)).image f :=\n  ext fun b => by\n    simp only [mem_filter, mem_image, exists_prop]\n    exact\n      ⟨by rintro ⟨⟨x, h1, rfl⟩, h2⟩; exact ⟨x, ⟨h1, h2⟩, rfl⟩,\n       by rintro ⟨x, ⟨h1, h2⟩, rfl⟩; exact ⟨⟨x, h1, rfl⟩, h2⟩⟩\n\n"}
{"name":"Finset.filter_mem_image_eq_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\nt : Finset β\nh : ∀ (x : α), Membership.mem s x → Membership.mem t (f x)\n⊢ Eq (Finset.filter (fun y => Membership.mem (Finset.image f s) y) t) (Finset.image f s)","decl":"@[deprecated filter_mem_eq_inter (since := \"2024-09-15\")]\ntheorem filter_mem_image_eq_image (f : α → β) (s : Finset α) (t : Finset β) (h : ∀ x ∈ s, f x ∈ t) :\n    (t.filter fun y => y ∈ s.image f) = s.image f := by\n  rwa [filter_mem_eq_inter, inter_eq_right, image_subset_iff]\n\n"}
{"name":"Finset.fiber_nonempty_iff_mem_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\ny : β\n⊢ Iff (Finset.filter (fun x => Eq (f x) y) s).Nonempty (Membership.mem (Finset.image f s) y)","decl":"theorem fiber_nonempty_iff_mem_image {y : β} : (s.filter (f · = y)).Nonempty ↔ y ∈ s.image f := by\n  simp [Finset.Nonempty]\n\n"}
{"name":"Finset.image_union","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\nf : α → β\ns₁ s₂ : Finset α\n⊢ Eq (Finset.image f (Union.union s₁ s₂)) (Union.union (Finset.image f s₁) (Finset.image f s₂))","decl":"theorem image_union [DecidableEq α] {f : α → β} (s₁ s₂ : Finset α) :\n    (s₁ ∪ s₂).image f = s₁.image f ∪ s₂.image f :=\n  mod_cast Set.image_union f s₁ s₂\n\n"}
{"name":"Finset.image_inter_subset","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\nf : α → β\ns t : Finset α\n⊢ HasSubset.Subset (Finset.image f (Inter.inter s t)) (Inter.inter (Finset.image f s) (Finset.image f t))","decl":"theorem image_inter_subset [DecidableEq α] (f : α → β) (s t : Finset α) :\n    (s ∩ t).image f ⊆ s.image f ∩ t.image f :=\n  (image_mono f).map_inf_le s t\n\n"}
{"name":"Finset.image_inter_of_injOn","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\nf : α → β\ns t : Finset α\nhf : Set.InjOn f (Union.union ↑s ↑t)\n⊢ Eq (Finset.image f (Inter.inter s t)) (Inter.inter (Finset.image f s) (Finset.image f t))","decl":"theorem image_inter_of_injOn [DecidableEq α] {f : α → β} (s t : Finset α)\n    (hf : Set.InjOn f (s ∪ t)) : (s ∩ t).image f = s.image f ∩ t.image f :=\n  coe_injective <| by\n    push_cast\n    exact Set.image_inter_on fun a ha b hb => hf (Or.inr ha) <| Or.inl hb\n\n"}
{"name":"Finset.image_inter","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\nf : α → β\ninst✝ : DecidableEq α\ns₁ s₂ : Finset α\nhf : Function.Injective f\n⊢ Eq (Finset.image f (Inter.inter s₁ s₂)) (Inter.inter (Finset.image f s₁) (Finset.image f s₂))","decl":"theorem image_inter [DecidableEq α] (s₁ s₂ : Finset α) (hf : Injective f) :\n    (s₁ ∩ s₂).image f = s₁.image f ∩ s₂.image f :=\n  image_inter_of_injOn _ _ hf.injOn\n\n"}
{"name":"Finset.image_singleton","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\na : α\n⊢ Eq (Finset.image f (Singleton.singleton a)) (Singleton.singleton (f a))","decl":"@[simp]\ntheorem image_singleton (f : α → β) (a : α) : image f {a} = {f a} :=\n  ext fun x => by simpa only [mem_image, exists_prop, mem_singleton, exists_eq_left] using eq_comm\n\n"}
{"name":"Finset.image_insert","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\nf : α → β\na : α\ns : Finset α\n⊢ Eq (Finset.image f (Insert.insert a s)) (Insert.insert (f a) (Finset.image f s))","decl":"@[simp]\ntheorem image_insert [DecidableEq α] (f : α → β) (a : α) (s : Finset α) :\n    (insert a s).image f = insert (f a) (s.image f) := by\n  simp only [insert_eq, image_singleton, image_union]\n\n"}
{"name":"Finset.erase_image_subset_image_erase","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\nf : α → β\ns : Finset α\na : α\n⊢ HasSubset.Subset ((Finset.image f s).erase (f a)) (Finset.image f (s.erase a))","decl":"theorem erase_image_subset_image_erase [DecidableEq α] (f : α → β) (s : Finset α) (a : α) :\n    (s.image f).erase (f a) ⊆ (s.erase a).image f := by\n  simp only [subset_iff, and_imp, exists_prop, mem_image, exists_imp, mem_erase]\n  rintro b hb x hx rfl\n  exact ⟨_, ⟨ne_of_apply_ne f hb, hx⟩, rfl⟩\n\n"}
{"name":"Finset.image_erase","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\nf : α → β\nhf : Function.Injective f\ns : Finset α\na : α\n⊢ Eq (Finset.image f (s.erase a)) ((Finset.image f s).erase (f a))","decl":"@[simp]\ntheorem image_erase [DecidableEq α] {f : α → β} (hf : Injective f) (s : Finset α) (a : α) :\n    (s.erase a).image f = (s.image f).erase (f a) :=\n  coe_injective <| by push_cast [Set.image_diff hf, Set.image_singleton]; rfl\n\n"}
{"name":"Finset.image_eq_empty","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\n⊢ Iff (Eq (Finset.image f s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem image_eq_empty : s.image f = ∅ ↔ s = ∅ := mod_cast Set.image_eq_empty (f := f) (s := s)\n\n"}
{"name":"Finset.image_sdiff","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\nf : α → β\ns t : Finset α\nhf : Function.Injective f\n⊢ Eq (Finset.image f (SDiff.sdiff s t)) (SDiff.sdiff (Finset.image f s) (Finset.image f t))","decl":"theorem image_sdiff [DecidableEq α] {f : α → β} (s t : Finset α) (hf : Injective f) :\n    (s \\ t).image f = s.image f \\ t.image f :=\n  mod_cast Set.image_diff hf s t\n\n"}
{"name":"Finset.image_sdiff_of_injOn","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\nf : α → β\ns : Finset α\ninst✝ : DecidableEq α\nt : Finset α\nhf : Set.InjOn f ↑s\nhts : HasSubset.Subset t s\n⊢ Eq (Finset.image f (SDiff.sdiff s t)) (SDiff.sdiff (Finset.image f s) (Finset.image f t))","decl":"lemma image_sdiff_of_injOn [DecidableEq α] {t : Finset α} (hf : Set.InjOn f s) (hts : t ⊆ s) :\n    (s \\ t).image f = s.image f \\ t.image f :=\n  mod_cast Set.image_diff_of_injOn hf <| coe_subset.2 hts\n\n"}
{"name":"Finset.image_symmDiff","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\nf : α → β\ns t : Finset α\nhf : Function.Injective f\n⊢ Eq (Finset.image f (symmDiff s t)) (symmDiff (Finset.image f s) (Finset.image f t))","decl":"open scoped symmDiff in\ntheorem image_symmDiff [DecidableEq α] {f : α → β} (s t : Finset α) (hf : Injective f) :\n    (s ∆ t).image f = s.image f ∆ t.image f :=\n  mod_cast Set.image_symmDiff hf s t\n\n"}
{"name":"Disjoint.of_image_finset","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns t : Finset α\nf : α → β\nh : Disjoint (Finset.image f s) (Finset.image f t)\n⊢ Disjoint s t","decl":"theorem _root_.Disjoint.of_image_finset {s t : Finset α} {f : α → β}\n    (h : Disjoint (s.image f) (t.image f)) : Disjoint s t :=\n  disjoint_iff_ne.2 fun _ ha _ hb =>\n    ne_of_apply_ne f <| h.forall_ne_finset (mem_image_of_mem _ ha) (mem_image_of_mem _ hb)\n\n"}
{"name":"Finset.mem_range_iff_mem_finset_range_of_mod_eq'","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nf : Nat → α\na : α\nn : Nat\nhn : LT.lt 0 n\nh : ∀ (i : Nat), Eq (f (HMod.hMod i n)) (f i)\n⊢ Iff (Membership.mem (Set.range f) a) (Membership.mem (Finset.image (fun i => f i) (Finset.range n)) a)","decl":"theorem mem_range_iff_mem_finset_range_of_mod_eq' [DecidableEq α] {f : ℕ → α} {a : α} {n : ℕ}\n    (hn : 0 < n) (h : ∀ i, f (i % n) = f i) :\n    a ∈ Set.range f ↔ a ∈ (Finset.range n).image fun i => f i := by\n  constructor\n  · rintro ⟨i, hi⟩\n    simp only [mem_image, exists_prop, mem_range]\n    exact ⟨i % n, Nat.mod_lt i hn, (rfl.congr hi).mp (h i)⟩\n  · rintro h\n    simp only [mem_image, exists_prop, Set.mem_range, mem_range] at *\n    rcases h with ⟨i, _, ha⟩\n    exact ⟨i, ha⟩\n\n"}
{"name":"Finset.mem_range_iff_mem_finset_range_of_mod_eq","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nf : Int → α\na : α\nn : Nat\nhn : LT.lt 0 n\nh : ∀ (i : Int), Eq (f (HMod.hMod i ↑n)) (f i)\n⊢ Iff (Membership.mem (Set.range f) a) (Membership.mem (Finset.image (fun i => f ↑i) (Finset.range n)) a)","decl":"theorem mem_range_iff_mem_finset_range_of_mod_eq [DecidableEq α] {f : ℤ → α} {a : α} {n : ℕ}\n    (hn : 0 < n) (h : ∀ i, f (i % n) = f i) :\n    a ∈ Set.range f ↔ a ∈ (Finset.range n).image (fun (i : ℕ) => f i) :=\n  suffices (∃ i, f (i % n) = a) ↔ ∃ i, i < n ∧ f ↑i = a by simpa [h]\n  have hn' : 0 < (n : ℤ) := Int.ofNat_lt.mpr hn\n  Iff.intro\n    (fun ⟨i, hi⟩ =>\n      have : 0 ≤ i % ↑n := Int.emod_nonneg _ (ne_of_gt hn')\n      ⟨Int.toNat (i % n), by\n        rw [← Int.ofNat_lt, Int.toNat_of_nonneg this]; exact ⟨Int.emod_lt_of_pos i hn', hi⟩⟩)\n    fun ⟨i, hi, ha⟩ =>\n    ⟨i, by rw [Int.emod_eq_of_lt (Int.ofNat_zero_le _) (Int.ofNat_lt_ofNat_of_lt hi), ha]⟩\n\n"}
{"name":"Finset.range_add","module":"Mathlib.Data.Finset.Image","initialProofState":"a b : Nat\n⊢ Eq (Finset.range (HAdd.hAdd a b)) (Union.union (Finset.range a) (Finset.map (addLeftEmbedding a) (Finset.range b)))","decl":"theorem range_add (a b : ℕ) : range (a + b) = range a ∪ (range b).map (addLeftEmbedding a) := by\n  rw [← val_inj, union_val]\n  exact Multiset.range_add_eq_union a b\n\n"}
{"name":"Finset.attach_image_val","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.image Subtype.val s.attach) s","decl":"@[simp]\ntheorem attach_image_val [DecidableEq α] {s : Finset α} : s.attach.image Subtype.val = s :=\n  eq_of_veq <| by rw [image_val, attach_val, Multiset.attach_map_val, dedup_eq_self]\n\n"}
{"name":"Finset.attach_insert","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Insert.insert a s).attach (Insert.insert ⟨a, ⋯⟩ (Finset.image (fun x => ⟨↑x, ⋯⟩) s.attach))","decl":"@[simp]\ntheorem attach_insert [DecidableEq α] {a : α} {s : Finset α} :\n    attach (insert a s) =\n      insert (⟨a, mem_insert_self a s⟩ : { x // x ∈ insert a s })\n        ((attach s).image fun x => ⟨x.1, mem_insert_of_mem x.2⟩) :=\n  ext fun ⟨x, hx⟩ =>\n    ⟨Or.casesOn (mem_insert.1 hx)\n        (fun h : x = a => fun _ => mem_insert.2 <| Or.inl <| Subtype.eq h) fun h : x ∈ s => fun _ =>\n        mem_insert_of_mem <| mem_image.2 <| ⟨⟨x, h⟩, mem_attach _ _, Subtype.eq rfl⟩,\n      fun _ => Finset.mem_attach _ _⟩\n\n"}
{"name":"Finset.disjoint_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns t : Finset α\nf : α → β\nhf : Function.Injective f\n⊢ Iff (Disjoint (Finset.image f s) (Finset.image f t)) (Disjoint s t)","decl":"@[simp]\ntheorem disjoint_image {s t : Finset α} {f : α → β} (hf : Injective f) :\n    Disjoint (s.image f) (t.image f) ↔ Disjoint s t :=\n  mod_cast Set.disjoint_image_iff hf (s := s) (t := t)\n\n"}
{"name":"Finset.image_const","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset α\nh : s.Nonempty\nb : β\n⊢ Eq (Finset.image (fun x => b) s) (Singleton.singleton b)","decl":"theorem image_const {s : Finset α} (h : s.Nonempty) (b : β) : (s.image fun _ => b) = singleton b :=\n  mod_cast Set.Nonempty.image_const (coe_nonempty.2 h) b\n\n"}
{"name":"Finset.map_erase","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\nf : Function.Embedding α β\ns : Finset α\na : α\n⊢ Eq (Finset.map f (s.erase a)) ((Finset.map f s).erase (f a))","decl":"@[simp]\ntheorem map_erase [DecidableEq α] (f : α ↪ β) (s : Finset α) (a : α) :\n    (s.erase a).map f = (s.map f).erase (f a) := by\n  simp_rw [map_eq_image]\n  exact s.image_erase f.2 a\n\n"}
{"name":"Finset.image_biUnion","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq γ\nf : α → β\ns : Finset α\nt : β → Finset γ\n⊢ Eq ((Finset.image f s).biUnion t) (s.biUnion fun a => t (f a))","decl":"theorem image_biUnion [DecidableEq γ] {f : α → β} {s : Finset α} {t : β → Finset γ} :\n    (s.image f).biUnion t = s.biUnion fun a => t (f a) :=\n  haveI := Classical.decEq α\n  Finset.induction_on s rfl fun a s _ ih => by simp only [image_insert, biUnion_insert, ih]\n\n"}
{"name":"Finset.biUnion_image","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq γ\ns : Finset α\nt : α → Finset β\nf : β → γ\n⊢ Eq (Finset.image f (s.biUnion t)) (s.biUnion fun a => Finset.image f (t a))","decl":"theorem biUnion_image [DecidableEq γ] {s : Finset α} {t : α → Finset β} {f : β → γ} :\n    (s.biUnion t).image f = s.biUnion fun a => (t a).image f :=\n  haveI := Classical.decEq α\n  Finset.induction_on s rfl fun a s _ ih => by simp only [biUnion_insert, image_union, ih]\n\n"}
{"name":"Finset.image_biUnion_filter_eq","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\ns : Finset β\ng : β → α\n⊢ Eq ((Finset.image g s).biUnion fun a => Finset.filter (fun c => Eq (g c) a) s) s","decl":"theorem image_biUnion_filter_eq [DecidableEq α] (s : Finset β) (g : β → α) :\n    ((s.image g).biUnion fun a => s.filter fun c => g c = a) = s :=\n  biUnion_filter_eq_of_maps_to fun _ => mem_image_of_mem g\n\n"}
{"name":"Finset.biUnion_singleton","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset α\nf : α → β\n⊢ Eq (s.biUnion fun a => Singleton.singleton (f a)) (Finset.image f s)","decl":"theorem biUnion_singleton {f : α → β} : (s.biUnion fun a => {f a}) = s.image f :=\n  ext fun x => by simp only [mem_biUnion, mem_image, mem_singleton, eq_comm]\n\n"}
{"name":"Finset.filterMap_val","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → Option β\ns' : Finset α\nf_inj : ∀ (a a' : α) (b : β), Membership.mem (f a) b → Membership.mem (f a') b → Eq a a'\n⊢ Eq (Finset.filterMap f s' f_inj).val (Multiset.filterMap f s'.val)","decl":"@[simp]\ntheorem filterMap_val : (filterMap f s' f_inj).1 = s'.1.filterMap f := rfl\n\n"}
{"name":"Finset.filterMap_empty","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → Option β\nf_inj : ∀ (a a' : α) (b : β), Membership.mem (f a) b → Membership.mem (f a') b → Eq a a'\n⊢ Eq (Finset.filterMap f EmptyCollection.emptyCollection f_inj) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem filterMap_empty : (∅ : Finset α).filterMap f f_inj = ∅ := rfl\n\n"}
{"name":"Finset.mem_filterMap","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → Option β\ns : Finset α\nf_inj : ∀ (a a' : α) (b : β), Membership.mem (f a) b → Membership.mem (f a') b → Eq a a'\nb : β\n⊢ Iff (Membership.mem (Finset.filterMap f s f_inj) b) (Exists fun a => And (Membership.mem s a) (Eq (f a) (Option.some b)))","decl":"@[simp]\ntheorem mem_filterMap {b : β} : b ∈ s.filterMap f f_inj ↔ ∃ a ∈ s, f a = some b :=\n  s.val.mem_filterMap f\n\n"}
{"name":"Finset.coe_filterMap","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → Option β\ns : Finset α\nf_inj : ∀ (a a' : α) (b : β), Membership.mem (f a) b → Membership.mem (f a') b → Eq a a'\n⊢ Eq (↑(Finset.filterMap f s f_inj)) (setOf fun b => Exists fun a => And (Membership.mem s a) (Eq (f a) (Option.some b)))","decl":"@[simp, norm_cast]\ntheorem coe_filterMap : (s.filterMap f f_inj : Set β) = {b | ∃ a ∈ s, f a = some b} :=\n  Set.ext (by simp only [mem_coe, mem_filterMap, Option.mem_def, Set.mem_setOf_eq, implies_true])\n\n"}
{"name":"Finset.filterMap_some","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (Finset.filterMap Option.some s ⋯) s","decl":"@[simp]\ntheorem filterMap_some : s.filterMap some (by simp) = s :=\n  ext fun _ => by simp only [mem_filterMap, Option.some.injEq, exists_eq_right]\n\n"}
{"name":"Finset.filterMap_mono","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → Option β\ns t : Finset α\nf_inj : ∀ (a a' : α) (b : β), Membership.mem (f a) b → Membership.mem (f a') b → Eq a a'\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (Finset.filterMap f s f_inj) (Finset.filterMap f t f_inj)","decl":"theorem filterMap_mono (h : s ⊆ t) :\n    filterMap f s f_inj ⊆ filterMap f t f_inj := by\n  rw [← val_le_iff] at h ⊢\n  exact Multiset.filterMap_le_filterMap f h\n\n"}
{"name":"Finset.mem_subtype","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\na : Subtype p\n⊢ Iff (Membership.mem (Finset.subtype p s) a) (Membership.mem s ↑a)","decl":"@[simp]\ntheorem mem_subtype {p : α → Prop} [DecidablePred p] {s : Finset α} :\n    ∀ {a : Subtype p}, a ∈ s.subtype p ↔ (a : α) ∈ s\n  | ⟨a, ha⟩ => by simp [Finset.subtype, ha]\n\n"}
{"name":"Finset.subtype_eq_empty","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\n⊢ Iff (Eq (Finset.subtype p s) EmptyCollection.emptyCollection) (∀ (x : α), p x → Not (Membership.mem s x))","decl":"theorem subtype_eq_empty {p : α → Prop} [DecidablePred p] {s : Finset α} :\n    s.subtype p = ∅ ↔ ∀ x, p x → x ∉ s := by simp [Finset.ext_iff, Subtype.forall, Subtype.coe_mk]\n\n"}
{"name":"Finset.subtype_mono","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Monotone (Finset.subtype p)","decl":"@[mono]\ntheorem subtype_mono {p : α → Prop} [DecidablePred p] : Monotone (Finset.subtype p) :=\n  fun _ _ h _ hx => mem_subtype.2 <| h <| mem_subtype.1 hx\n\n"}
{"name":"Finset.subtype_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\n⊢ Eq (Finset.map (Function.Embedding.subtype p) (Finset.subtype p s)) (Finset.filter p s)","decl":"/-- `s.subtype p` converts back to `s.filter p` with\n`Embedding.subtype`. -/\n@[simp]\ntheorem subtype_map (p : α → Prop) [DecidablePred p] {s : Finset α} :\n    (s.subtype p).map (Embedding.subtype _) = s.filter p := by\n  ext x\n  simp [@and_comm _ (_ = _), @and_left_comm _ (_ = _), @and_comm (p x) (x ∈ s)]\n\n"}
{"name":"Finset.subtype_map_of_mem","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\nh : ∀ (x : α), Membership.mem s x → p x\n⊢ Eq (Finset.map (Function.Embedding.subtype p) (Finset.subtype p s)) s","decl":"/-- If all elements of a `Finset` satisfy the predicate `p`,\n`s.subtype p` converts back to `s` with `Embedding.subtype`. -/\ntheorem subtype_map_of_mem {p : α → Prop} [DecidablePred p] {s : Finset α} (h : ∀ x ∈ s, p x) :\n    (s.subtype p).map (Embedding.subtype _) = s := ext <| by simpa [subtype_map] using h\n\n"}
{"name":"Finset.property_of_mem_map_subtype","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\np : α → Prop\ns : Finset (Subtype fun x => p x)\na : α\nh : Membership.mem (Finset.map (Function.Embedding.subtype fun x => p x) s) a\n⊢ p a","decl":"/-- If a `Finset` of a subtype is converted to the main type with\n`Embedding.subtype`, all elements of the result have the property of\nthe subtype. -/\ntheorem property_of_mem_map_subtype {p : α → Prop} (s : Finset { x // p x }) {a : α}\n    (h : a ∈ s.map (Embedding.subtype _)) : p a := by\n  rcases mem_map.1 h with ⟨x, _, rfl⟩\n  exact x.2\n\n"}
{"name":"Finset.not_mem_map_subtype_of_not_property","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\np : α → Prop\ns : Finset (Subtype fun x => p x)\na : α\nh : Not (p a)\n⊢ Not (Membership.mem (Finset.map (Function.Embedding.subtype fun x => p x) s) a)","decl":"/-- If a `Finset` of a subtype is converted to the main type with\n`Embedding.subtype`, the result does not contain any value that does\nnot satisfy the property of the subtype. -/\ntheorem not_mem_map_subtype_of_not_property {p : α → Prop} (s : Finset { x // p x }) {a : α}\n    (h : ¬p a) : a ∉ s.map (Embedding.subtype _) :=\n  mt s.property_of_mem_map_subtype h\n\n"}
{"name":"Finset.map_subtype_subset","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nt : Set α\ns : Finset ↑t\n⊢ HasSubset.Subset (↑(Finset.map (Function.Embedding.subtype fun x => Membership.mem t x) s)) t","decl":"/-- If a `Finset` of a subtype is converted to the main type with\n`Embedding.subtype`, the result is a subset of the set giving the\nsubtype. -/\ntheorem map_subtype_subset {t : Set α} (s : Finset t) : ↑(s.map (Embedding.subtype _)) ⊆ t := by\n  intro a ha\n  rw [mem_coe] at ha\n  convert property_of_mem_map_subtype s ha\n\n"}
{"name":"Finset.mem_fin","module":"Mathlib.Data.Finset.Image","initialProofState":"n : Nat\ns : Finset Nat\na : Fin n\n⊢ Iff (Membership.mem (Finset.fin n s) a) (Membership.mem s ↑a)","decl":"@[simp]\ntheorem mem_fin {n} {s : Finset ℕ} : ∀ a : Fin n, a ∈ s.fin n ↔ (a : ℕ) ∈ s\n  | ⟨a, ha⟩ => by simp [Finset.fin, ha, and_comm]\n\n"}
{"name":"Finset.fin_mono","module":"Mathlib.Data.Finset.Image","initialProofState":"n : Nat\n⊢ Monotone (Finset.fin n)","decl":"@[mono]\ntheorem fin_mono {n} : Monotone (Finset.fin n) := fun s t h x => by simpa using @h x\n\n"}
{"name":"Finset.fin_map","module":"Mathlib.Data.Finset.Image","initialProofState":"n : Nat\ns : Finset Nat\n⊢ Eq (Finset.map Fin.valEmbedding (Finset.fin n s)) (Finset.filter (fun x => LT.lt x n) s)","decl":"@[simp]\ntheorem fin_map {n} {s : Finset ℕ} : (s.fin n).map Fin.valEmbedding = s.filter (· < n) := by\n  simp [Finset.fin, Finset.map_map]\n\n"}
{"name":"Finset.subset_image_iff","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\n⊢ Iff (HasSubset.Subset t (Finset.image f s)) (Exists fun s' => And (HasSubset.Subset s' s) (Eq (Finset.image f s') t))","decl":"/--\nIf a finset `t` is a subset of the image of another finset `s` under `f`, then it is equal to the\nimage of a subset of `s`.\n\nFor the version where `s` is a set, see `subset_set_image_iff`.\n-/\ntheorem subset_image_iff [DecidableEq β] {s : Finset α} {t : Finset β} {f : α → β} :\n    t ⊆ s.image f ↔ ∃ s' : Finset α, s' ⊆ s ∧ s'.image f = t := by\n  refine ⟨fun ht => ?_, fun ⟨s', hs', h⟩ => h ▸ image_subset_image hs'⟩\n  refine ⟨s.filter (f · ∈ t), filter_subset _ _, le_antisymm (by simp [image_subset_iff]) ?_⟩\n  intro x hx\n  specialize ht hx\n  aesop\n\n"}
{"name":"Finset.subset_set_image_iff","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Set α\nt : Finset β\nf : α → β\n⊢ Iff (HasSubset.Subset (↑t) (Set.image f s)) (Exists fun s' => And (HasSubset.Subset (↑s') s) (Eq (Finset.image f s') t))","decl":"/-- If a `Finset` is a subset of the image of a `Set` under `f`,\nthen it is equal to the `Finset.image` of a `Finset` subset of that `Set`. -/\ntheorem subset_set_image_iff [DecidableEq β] {s : Set α} {t : Finset β} {f : α → β} :\n    ↑t ⊆ f '' s ↔ ∃ s' : Finset α, ↑s' ⊆ s ∧ s'.image f = t := by\n  constructor; swap\n  · rintro ⟨t, ht, rfl⟩\n    rw [coe_image]\n    exact Set.image_subset f ht\n  intro h\n  letI : CanLift β s (f ∘ (↑)) fun y => y ∈ f '' s := ⟨fun y ⟨x, hxt, hy⟩ => ⟨⟨x, hxt⟩, hy⟩⟩\n  lift t to Finset s using h\n  refine ⟨t.map (Embedding.subtype _), map_subtype_subset _, ?_⟩\n  ext y; simp\n\n"}
{"name":"Finset.range_sdiff_zero","module":"Mathlib.Data.Finset.Image","initialProofState":"n : Nat\n⊢ Eq (SDiff.sdiff (Finset.range (HAdd.hAdd n 1)) (Singleton.singleton 0)) (Finset.image Nat.succ (Finset.range n))","decl":"theorem range_sdiff_zero {n : ℕ} : range (n + 1) \\ {0} = (range n).image Nat.succ := by\n  induction' n with k hk\n  · simp\n  conv_rhs => rw [range_succ]\n  rw [range_succ, image_insert, ← hk, insert_sdiff_of_not_mem]\n  simp\n\n"}
{"name":"Multiset.toFinset_map","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\nm : Multiset α\n⊢ Eq (Multiset.map f m).toFinset (Finset.image f m.toFinset)","decl":"theorem Multiset.toFinset_map [DecidableEq α] [DecidableEq β] (f : α → β) (m : Multiset α) :\n    (m.map f).toFinset = m.toFinset.image f :=\n  Finset.val_inj.1 (Multiset.dedup_map_dedup_eq _ _).symm\n\n"}
{"name":"Equiv.finsetCongr_apply","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Finset α\n⊢ Eq (e.finsetCongr s) (Finset.map e.toEmbedding s)","decl":"@[simp]\ntheorem finsetCongr_apply (e : α ≃ β) (s : Finset α) : e.finsetCongr s = s.map e.toEmbedding :=\n  rfl\n\n"}
{"name":"Equiv.finsetCongr_refl","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\n⊢ Eq (Equiv.refl α).finsetCongr (Equiv.refl (Finset α))","decl":"@[simp]\ntheorem finsetCongr_refl : (Equiv.refl α).finsetCongr = Equiv.refl _ := by\n  ext\n  simp\n\n"}
{"name":"Equiv.finsetCongr_symm","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Eq e.finsetCongr.symm e.symm.finsetCongr","decl":"@[simp]\ntheorem finsetCongr_symm (e : α ≃ β) : e.finsetCongr.symm = e.symm.finsetCongr :=\n  rfl\n\n"}
{"name":"Equiv.finsetCongr_trans","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : Equiv α β\ne' : Equiv β γ\n⊢ Eq (e.finsetCongr.trans e'.finsetCongr) (e.trans e').finsetCongr","decl":"@[simp]\ntheorem finsetCongr_trans (e : α ≃ β) (e' : β ≃ γ) :\n    e.finsetCongr.trans e'.finsetCongr = (e.trans e').finsetCongr := by\n  ext\n  simp [-Finset.mem_map, -Equiv.trans_toEmbedding]\n\n"}
{"name":"Equiv.finsetCongr_toEmbedding","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Eq e.finsetCongr.toEmbedding (Finset.mapEmbedding e.toEmbedding).toEmbedding","decl":"theorem finsetCongr_toEmbedding (e : α ≃ β) :\n    e.finsetCongr.toEmbedding = (Finset.mapEmbedding e.toEmbedding).toEmbedding :=\n  rfl\n\n"}
{"name":"Equiv.finsetSubtypeComm_symm_apply","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\np : α → Prop\ns : Subtype fun s => ∀ (a : α), Membership.mem s a → p a\n⊢ Eq ((Equiv.finsetSubtypeComm p).symm s) (Finset.map (Subtype.impEmbedding (Membership.mem ↑s) p ⋯) (↑s).attach)","decl":"/-- Given a predicate `p : α → Prop`, produces an equivalence between\n  `Finset {a : α // p a}` and `{s : Finset α // ∀ a ∈ s, p a}`. -/\n\n@[simps]\nprotected def finsetSubtypeComm (p : α → Prop) :\n    Finset {a : α // p a} ≃ {s : Finset α // ∀ a ∈ s, p a} where\n  toFun s := ⟨s.map ⟨fun a ↦ a.val, Subtype.val_injective⟩, fun _ h ↦\n    have ⟨v, _, h⟩ := Embedding.coeFn_mk _ _ ▸ mem_map.mp h; h ▸ v.property⟩\n  invFun s := s.val.attach.map (Subtype.impEmbedding _ _ s.property)\n  left_inv s := by\n    ext a; constructor <;> intro h <;>\n    simp only [Finset.mem_map, Finset.mem_attach, true_and, Subtype.exists, Embedding.coeFn_mk,\n      exists_and_right, exists_eq_right, Subtype.impEmbedding, Subtype.mk.injEq] at *\n    · rcases h with ⟨_, ⟨_, h₁⟩, h₂⟩; exact h₂ ▸ h₁\n    · use a, ⟨a.property, h⟩\n  right_inv s := by\n    ext a; constructor <;> intro h <;>\n    simp only [Finset.mem_map, Finset.mem_attach, true_and, Subtype.exists, Embedding.coeFn_mk,\n      exists_and_right, exists_eq_right, Subtype.impEmbedding, Subtype.mk.injEq] at *\n    · rcases h with ⟨_, _, h₁, h₂⟩; exact h₂ ▸ h₁\n    · use s.property _ h, a\n\n"}
{"name":"Equiv.finsetSubtypeComm_apply_coe","module":"Mathlib.Data.Finset.Image","initialProofState":"α : Type u_1\np : α → Prop\ns : Finset (Subtype fun a => p a)\n⊢ Eq (↑((Equiv.finsetSubtypeComm p) s)) (Finset.map { toFun := fun a => ↑a, inj' := ⋯ } s)","decl":"/-- Given a predicate `p : α → Prop`, produces an equivalence between\n  `Finset {a : α // p a}` and `{s : Finset α // ∀ a ∈ s, p a}`. -/\n\n@[simps]\nprotected def finsetSubtypeComm (p : α → Prop) :\n    Finset {a : α // p a} ≃ {s : Finset α // ∀ a ∈ s, p a} where\n  toFun s := ⟨s.map ⟨fun a ↦ a.val, Subtype.val_injective⟩, fun _ h ↦\n    have ⟨v, _, h⟩ := Embedding.coeFn_mk _ _ ▸ mem_map.mp h; h ▸ v.property⟩\n  invFun s := s.val.attach.map (Subtype.impEmbedding _ _ s.property)\n  left_inv s := by\n    ext a; constructor <;> intro h <;>\n    simp only [Finset.mem_map, Finset.mem_attach, true_and, Subtype.exists, Embedding.coeFn_mk,\n      exists_and_right, exists_eq_right, Subtype.impEmbedding, Subtype.mk.injEq] at *\n    · rcases h with ⟨_, ⟨_, h₁⟩, h₂⟩; exact h₂ ▸ h₁\n    · use a, ⟨a.property, h⟩\n  right_inv s := by\n    ext a; constructor <;> intro h <;>\n    simp only [Finset.mem_map, Finset.mem_attach, true_and, Subtype.exists, Embedding.coeFn_mk,\n      exists_and_right, exists_eq_right, Subtype.impEmbedding, Subtype.mk.injEq] at *\n    · rcases h with ⟨_, _, h₁, h₂⟩; exact h₂ ▸ h₁\n    · use s.property _ h, a\n\n"}
