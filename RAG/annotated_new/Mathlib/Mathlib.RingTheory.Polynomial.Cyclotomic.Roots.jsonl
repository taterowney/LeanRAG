{"name":"Polynomial.isRoot_of_unity_of_root_cyclotomic","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nζ : R\ni : Nat\nhi : Membership.mem n.divisors i\nh : (Polynomial.cyclotomic i R).IsRoot ζ\n⊢ Eq (HPow.hPow ζ n) 1","decl":"theorem isRoot_of_unity_of_root_cyclotomic {ζ : R} {i : ℕ} (hi : i ∈ n.divisors)\n    (h : (cyclotomic i R).IsRoot ζ) : ζ ^ n = 1 := by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · exact pow_zero _\n  have := congr_arg (eval ζ) (prod_cyclotomic_eq_X_pow_sub_one hn R).symm\n  rw [eval_sub, eval_pow, eval_X, eval_one] at this\n  convert eq_add_of_sub_eq' this\n  convert (add_zero (M := R) _).symm\n  apply eval_eq_zero_of_dvd_of_eval_eq_zero _ h\n  exact Finset.dvd_prod_of_mem _ hi\n\n"}
{"name":"isRoot_of_unity_iff","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"n : Nat\nh : LT.lt 0 n\nR : Type u_2\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : R\n⊢ Iff (Eq (HPow.hPow ζ n) 1) (Exists fun i => And (Membership.mem n.divisors i) ((Polynomial.cyclotomic i R).IsRoot ζ))","decl":"theorem _root_.isRoot_of_unity_iff (h : 0 < n) (R : Type*) [CommRing R] [IsDomain R] {ζ : R} :\n    ζ ^ n = 1 ↔ ∃ i ∈ n.divisors, (cyclotomic i R).IsRoot ζ := by\n  rw [← mem_nthRoots h, nthRoots, mem_roots <| X_pow_sub_C_ne_zero h _, C_1, ←\n      prod_cyclotomic_eq_X_pow_sub_one h, isRoot_prod]\n\n"}
{"name":"IsPrimitiveRoot.isRoot_cyclotomic","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nn : Nat\ninst✝ : IsDomain R\nhpos : LT.lt 0 n\nμ : R\nh : IsPrimitiveRoot μ n\n⊢ (Polynomial.cyclotomic n R).IsRoot μ","decl":"/-- Any `n`-th primitive root of unity is a root of `cyclotomic n R`. -/\ntheorem _root_.IsPrimitiveRoot.isRoot_cyclotomic (hpos : 0 < n) {μ : R} (h : IsPrimitiveRoot μ n) :\n    IsRoot (cyclotomic n R) μ := by\n  rw [← mem_roots (cyclotomic_ne_zero n R), cyclotomic_eq_prod_X_sub_primitiveRoots h,\n    roots_prod_X_sub_C, ← Finset.mem_def]\n  rwa [← mem_primitiveRoots hpos] at h\n\n"}
{"name":"Polynomial.isRoot_cyclotomic_iff","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nn : Nat\ninst✝¹ : IsDomain R\ninst✝ : NeZero ↑n\nμ : R\n⊢ Iff ((Polynomial.cyclotomic n R).IsRoot μ) (IsPrimitiveRoot μ n)","decl":"theorem isRoot_cyclotomic_iff [NeZero (n : R)] {μ : R} :\n    IsRoot (cyclotomic n R) μ ↔ IsPrimitiveRoot μ n := by\n  have hf : Function.Injective _ := IsFractionRing.injective R (FractionRing R)\n  haveI : NeZero (n : FractionRing R) := NeZero.nat_of_injective hf\n  rw [← isRoot_map_iff hf, ← IsPrimitiveRoot.map_iff_of_injective hf, map_cyclotomic, ←\n    isRoot_cyclotomic_iff']\n\n"}
{"name":"Polynomial.roots_cyclotomic_nodup","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nn : Nat\ninst✝¹ : IsDomain R\ninst✝ : NeZero ↑n\n⊢ (Polynomial.cyclotomic n R).roots.Nodup","decl":"theorem roots_cyclotomic_nodup [NeZero (n : R)] : (cyclotomic n R).roots.Nodup := by\n  obtain h | ⟨ζ, hζ⟩ := (cyclotomic n R).roots.empty_or_exists_mem\n  · exact h.symm ▸ Multiset.nodup_zero\n  rw [mem_roots <| cyclotomic_ne_zero n R, isRoot_cyclotomic_iff] at hζ\n  refine Multiset.nodup_of_le\n    (roots.le_of_dvd (X_pow_sub_C_ne_zero (NeZero.pos_of_neZero_natCast R) 1) <|\n      cyclotomic.dvd_X_pow_sub_one n R) hζ.nthRoots_one_nodup\n\n"}
{"name":"Polynomial.cyclotomic.roots_to_finset_eq_primitiveRoots","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nn : Nat\ninst✝¹ : IsDomain R\ninst✝ : NeZero ↑n\n⊢ Eq { val := (Polynomial.cyclotomic n R).roots, nodup := ⋯ } (primitiveRoots n R)","decl":"theorem cyclotomic.roots_to_finset_eq_primitiveRoots [NeZero (n : R)] :\n    (⟨(cyclotomic n R).roots, roots_cyclotomic_nodup⟩ : Finset _) = primitiveRoots n R := by\n  ext a\n  -- Porting note: was\n  -- `simp [cyclotomic_ne_zero n R, isRoot_cyclotomic_iff, mem_primitiveRoots,`\n  -- `  NeZero.pos_of_neZero_natCast R]`\n  simp only [mem_primitiveRoots, NeZero.pos_of_neZero_natCast R]\n  convert isRoot_cyclotomic_iff (n := n) (μ := a) using 0\n  simp [cyclotomic_ne_zero n R]\n\n"}
{"name":"Polynomial.cyclotomic.roots_eq_primitiveRoots_val","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nn : Nat\ninst✝¹ : IsDomain R\ninst✝ : NeZero ↑n\n⊢ Eq (Polynomial.cyclotomic n R).roots (primitiveRoots n R).val","decl":"theorem cyclotomic.roots_eq_primitiveRoots_val [NeZero (n : R)] :\n    (cyclotomic n R).roots = (primitiveRoots n R).val := by\n  rw [← cyclotomic.roots_to_finset_eq_primitiveRoots]\n\n"}
{"name":"Polynomial.isRoot_cyclotomic_iff_charZero","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"n : Nat\nR : Type u_2\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : CharZero R\nμ : R\nhn : LT.lt 0 n\n⊢ Iff ((Polynomial.cyclotomic n R).IsRoot μ) (IsPrimitiveRoot μ n)","decl":"/-- If `R` is of characteristic zero, then `ζ` is a root of `cyclotomic n R` if and only if it is a\nprimitive `n`-th root of unity. -/\ntheorem isRoot_cyclotomic_iff_charZero {n : ℕ} {R : Type*} [CommRing R] [IsDomain R] [CharZero R]\n    {μ : R} (hn : 0 < n) : (Polynomial.cyclotomic n R).IsRoot μ ↔ IsPrimitiveRoot μ n :=\n  letI := NeZero.of_gt hn\n  isRoot_cyclotomic_iff\n\n"}
{"name":"Polynomial.cyclotomic_injective","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : CharZero R\n⊢ Function.Injective fun n => Polynomial.cyclotomic n R","decl":"/-- Over a ring `R` of characteristic zero, `fun n => cyclotomic n R` is injective. -/\ntheorem cyclotomic_injective [CharZero R] : Function.Injective fun n => cyclotomic n R := by\n  intro n m hnm\n  simp only at hnm\n  rcases eq_or_ne n 0 with (rfl | hzero)\n  · rw [cyclotomic_zero] at hnm\n    replace hnm := congr_arg natDegree hnm\n    rwa [natDegree_one, natDegree_cyclotomic, eq_comm, Nat.totient_eq_zero, eq_comm] at hnm\n  · haveI := NeZero.mk hzero\n    rw [← map_cyclotomic_int _ R, ← map_cyclotomic_int _ R] at hnm\n    replace hnm := map_injective (Int.castRingHom R) Int.cast_injective hnm\n    replace hnm := congr_arg (map (Int.castRingHom ℂ)) hnm\n    rw [map_cyclotomic_int, map_cyclotomic_int] at hnm\n    have hprim := Complex.isPrimitiveRoot_exp _ hzero\n    have hroot := isRoot_cyclotomic_iff (R := ℂ).2 hprim\n    rw [hnm] at hroot\n    haveI hmzero : NeZero m := ⟨fun h => by simp [h] at hroot⟩\n    rw [isRoot_cyclotomic_iff (R := ℂ)] at hroot\n    replace hprim := hprim.eq_orderOf\n    rwa [← IsPrimitiveRoot.eq_orderOf hroot] at hprim\n\n"}
{"name":"IsPrimitiveRoot.minpoly_dvd_cyclotomic","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"n : Nat\nK : Type u_2\ninst✝¹ : Field K\nμ : K\nh : IsPrimitiveRoot μ n\nhpos : LT.lt 0 n\ninst✝ : CharZero K\n⊢ Dvd.dvd (minpoly Int μ) (Polynomial.cyclotomic n Int)","decl":"/-- The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. -/\ntheorem _root_.IsPrimitiveRoot.minpoly_dvd_cyclotomic {n : ℕ} {K : Type*} [Field K] {μ : K}\n    (h : IsPrimitiveRoot μ n) (hpos : 0 < n) [CharZero K] : minpoly ℤ μ ∣ cyclotomic n ℤ := by\n  apply minpoly.isIntegrallyClosed_dvd (h.isIntegral hpos)\n  simpa [aeval_def, eval₂_eq_eval_map, IsRoot.def] using h.isRoot_cyclotomic hpos\n\n"}
{"name":"IsPrimitiveRoot.minpoly_eq_cyclotomic_of_irreducible","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"K : Type u_2\ninst✝⁴ : Field K\nR : Type u_3\ninst✝³ : CommRing R\ninst✝² : IsDomain R\nμ : R\nn : Nat\ninst✝¹ : Algebra K R\nhμ : IsPrimitiveRoot μ n\nh : Irreducible (Polynomial.cyclotomic n K)\ninst✝ : NeZero ↑n\n⊢ Eq (Polynomial.cyclotomic n K) (minpoly K μ)","decl":"theorem _root_.IsPrimitiveRoot.minpoly_eq_cyclotomic_of_irreducible {K : Type*} [Field K]\n    {R : Type*} [CommRing R] [IsDomain R] {μ : R} {n : ℕ} [Algebra K R] (hμ : IsPrimitiveRoot μ n)\n    (h : Irreducible <| cyclotomic n K) [NeZero (n : K)] : cyclotomic n K = minpoly K μ := by\n  haveI := NeZero.of_noZeroSMulDivisors K R n\n  refine minpoly.eq_of_irreducible_of_monic h ?_ (cyclotomic.monic n K)\n  rwa [aeval_def, eval₂_eq_eval_map, map_cyclotomic, ← IsRoot.def, isRoot_cyclotomic_iff]\n\n"}
{"name":"Polynomial.cyclotomic_eq_minpoly","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"n : Nat\nK : Type u_2\ninst✝¹ : Field K\nμ : K\nh : IsPrimitiveRoot μ n\nhpos : LT.lt 0 n\ninst✝ : CharZero K\n⊢ Eq (Polynomial.cyclotomic n Int) (minpoly Int μ)","decl":"/-- `cyclotomic n ℤ` is the minimal polynomial of a primitive `n`-th root of unity `μ`. -/\ntheorem cyclotomic_eq_minpoly {n : ℕ} {K : Type*} [Field K] {μ : K} (h : IsPrimitiveRoot μ n)\n    (hpos : 0 < n) [CharZero K] : cyclotomic n ℤ = minpoly ℤ μ := by\n  refine eq_of_monic_of_dvd_of_natDegree_le (minpoly.monic (IsPrimitiveRoot.isIntegral h hpos))\n    (cyclotomic.monic n ℤ) (h.minpoly_dvd_cyclotomic hpos) ?_\n  simpa [natDegree_cyclotomic n ℤ] using totient_le_degree_minpoly h\n\n"}
{"name":"Polynomial.cyclotomic_eq_minpoly_rat","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"n : Nat\nK : Type u_2\ninst✝¹ : Field K\nμ : K\nh : IsPrimitiveRoot μ n\nhpos : LT.lt 0 n\ninst✝ : CharZero K\n⊢ Eq (Polynomial.cyclotomic n Rat) (minpoly Rat μ)","decl":"/-- `cyclotomic n ℚ` is the minimal polynomial of a primitive `n`-th root of unity `μ`. -/\ntheorem cyclotomic_eq_minpoly_rat {n : ℕ} {K : Type*} [Field K] {μ : K} (h : IsPrimitiveRoot μ n)\n    (hpos : 0 < n) [CharZero K] : cyclotomic n ℚ = minpoly ℚ μ := by\n  rw [← map_cyclotomic_int, cyclotomic_eq_minpoly h hpos]\n  exact (minpoly.isIntegrallyClosed_eq_field_fractions' _ (IsPrimitiveRoot.isIntegral h hpos)).symm\n\n"}
{"name":"Polynomial.cyclotomic.irreducible","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"n : Nat\nhpos : LT.lt 0 n\n⊢ Irreducible (Polynomial.cyclotomic n Int)","decl":"/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem cyclotomic.irreducible {n : ℕ} (hpos : 0 < n) : Irreducible (cyclotomic n ℤ) := by\n  rw [cyclotomic_eq_minpoly (isPrimitiveRoot_exp n hpos.ne') hpos]\n  apply minpoly.irreducible\n  exact (isPrimitiveRoot_exp n hpos.ne').isIntegral hpos\n\n"}
{"name":"Polynomial.cyclotomic.irreducible_rat","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"n : Nat\nhpos : LT.lt 0 n\n⊢ Irreducible (Polynomial.cyclotomic n Rat)","decl":"/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem cyclotomic.irreducible_rat {n : ℕ} (hpos : 0 < n) : Irreducible (cyclotomic n ℚ) := by\n  rw [← map_cyclotomic_int]\n  exact (IsPrimitive.irreducible_iff_irreducible_map_fraction_map (cyclotomic.isPrimitive n ℤ)).1\n    (cyclotomic.irreducible hpos)\n\n"}
{"name":"Polynomial.cyclotomic.isCoprime_rat","module":"Mathlib.RingTheory.Polynomial.Cyclotomic.Roots","initialProofState":"n m : Nat\nh : Ne n m\n⊢ IsCoprime (Polynomial.cyclotomic n Rat) (Polynomial.cyclotomic m Rat)","decl":"/-- If `n ≠ m`, then `(cyclotomic n ℚ)` and `(cyclotomic m ℚ)` are coprime. -/\ntheorem cyclotomic.isCoprime_rat {n m : ℕ} (h : n ≠ m) :\n    IsCoprime (cyclotomic n ℚ) (cyclotomic m ℚ) := by\n  rcases n.eq_zero_or_pos with (rfl | hnzero)\n  · exact isCoprime_one_left\n  rcases m.eq_zero_or_pos with (rfl | hmzero)\n  · exact isCoprime_one_right\n  rw [Irreducible.coprime_iff_not_dvd <| cyclotomic.irreducible_rat <| hnzero]\n  exact fun hdiv => h <| cyclotomic_injective <|\n    eq_of_monic_of_associated (cyclotomic.monic n ℚ) (cyclotomic.monic m ℚ) <|\n      Irreducible.associated_of_dvd (cyclotomic.irreducible_rat hnzero)\n        (cyclotomic.irreducible_rat hmzero) hdiv\n\n"}
