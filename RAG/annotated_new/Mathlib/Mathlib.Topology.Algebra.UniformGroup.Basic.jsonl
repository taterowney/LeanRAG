{"name":"Pi.instUniformAddGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"ι : Type u_3\nG : ι → Type u_4\ninst✝² : (i : ι) → UniformSpace (G i)\ninst✝¹ : (i : ι) → AddGroup (G i)\ninst✝ : ∀ (i : ι), UniformAddGroup (G i)\n⊢ UniformAddGroup ((i : ι) → G i)","decl":"@[to_additive]\ninstance Pi.instUniformGroup {ι : Type*} {G : ι → Type*} [∀ i, UniformSpace (G i)]\n    [∀ i, Group (G i)] [∀ i, UniformGroup (G i)] : UniformGroup (∀ i, G i) where\n  uniformContinuous_div := uniformContinuous_pi.mpr fun i ↦\n    (uniformContinuous_proj G i).comp uniformContinuous_fst |>.div <|\n      (uniformContinuous_proj G i).comp uniformContinuous_snd\n\n"}
{"name":"Pi.instUniformGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"ι : Type u_3\nG : ι → Type u_4\ninst✝² : (i : ι) → UniformSpace (G i)\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : ∀ (i : ι), UniformGroup (G i)\n⊢ UniformGroup ((i : ι) → G i)","decl":"@[to_additive]\ninstance Pi.instUniformGroup {ι : Type*} {G : ι → Type*} [∀ i, UniformSpace (G i)]\n    [∀ i, Group (G i)] [∀ i, UniformGroup (G i)] : UniformGroup (∀ i, G i) where\n  uniformContinuous_div := uniformContinuous_pi.mpr fun i ↦\n    (uniformContinuous_proj G i).comp uniformContinuous_fst |>.div <|\n      (uniformContinuous_proj G i).comp uniformContinuous_snd\n\n"}
{"name":"isUniformEmbedding_translate_add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝² : UniformSpace α\ninst✝¹ : AddGroup α\ninst✝ : UniformAddGroup α\na : α\n⊢ IsUniformEmbedding fun x => HAdd.hAdd x a","decl":"@[to_additive]\ntheorem isUniformEmbedding_translate_mul (a : α) : IsUniformEmbedding fun x : α => x * a :=\n  { comap_uniformity := by\n      nth_rw 1 [← uniformity_translate_mul a, comap_map]\n      rintro ⟨p₁, p₂⟩ ⟨q₁, q₂⟩\n      simp only [Prod.mk.injEq, mul_left_inj, imp_self]\n    injective := mul_left_injective a }\n\n"}
{"name":"isUniformEmbedding_translate_mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝² : UniformSpace α\ninst✝¹ : Group α\ninst✝ : UniformGroup α\na : α\n⊢ IsUniformEmbedding fun x => HMul.hMul x a","decl":"@[to_additive]\ntheorem isUniformEmbedding_translate_mul (a : α) : IsUniformEmbedding fun x : α => x * a :=\n  { comap_uniformity := by\n      nth_rw 1 [← uniformity_translate_mul a, comap_map]\n      rintro ⟨p₁, p₂⟩ ⟨q₁, q₂⟩\n      simp only [Prod.mk.injEq, mul_left_inj, imp_self]\n    injective := mul_left_injective a }\n\n"}
{"name":"uniformEmbedding_translate_mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝² : UniformSpace α\ninst✝¹ : Group α\ninst✝ : UniformGroup α\na : α\n⊢ IsUniformEmbedding fun x => HMul.hMul x a","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_translate_mul := isUniformEmbedding_translate_mul\n\n"}
{"name":"IsUniformInducing.uniformAddGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"β : Type u_2\ninst✝⁶ : AddGroup β\nγ : Type u_3\ninst✝⁵ : AddGroup γ\ninst✝⁴ : UniformSpace γ\ninst✝³ : UniformAddGroup γ\ninst✝² : UniformSpace β\nF : Type u_4\ninst✝¹ : FunLike F β γ\ninst✝ : AddMonoidHomClass F β γ\nf : F\nhf : IsUniformInducing ⇑f\n⊢ UniformAddGroup β","decl":"@[to_additive]\nlemma IsUniformInducing.uniformGroup {γ : Type*} [Group γ] [UniformSpace γ] [UniformGroup γ]\n    [UniformSpace β] {F : Type*} [FunLike F β γ] [MonoidHomClass F β γ]\n    (f : F) (hf : IsUniformInducing f) :\n    UniformGroup β where\n  uniformContinuous_div := by\n    simp_rw [hf.uniformContinuous_iff, Function.comp_def, map_div]\n    exact uniformContinuous_div.comp (hf.uniformContinuous.prodMap hf.uniformContinuous)\n\n"}
{"name":"IsUniformInducing.uniformGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"β : Type u_2\ninst✝⁶ : Group β\nγ : Type u_3\ninst✝⁵ : Group γ\ninst✝⁴ : UniformSpace γ\ninst✝³ : UniformGroup γ\ninst✝² : UniformSpace β\nF : Type u_4\ninst✝¹ : FunLike F β γ\ninst✝ : MonoidHomClass F β γ\nf : F\nhf : IsUniformInducing ⇑f\n⊢ UniformGroup β","decl":"@[to_additive]\nlemma IsUniformInducing.uniformGroup {γ : Type*} [Group γ] [UniformSpace γ] [UniformGroup γ]\n    [UniformSpace β] {F : Type*} [FunLike F β γ] [MonoidHomClass F β γ]\n    (f : F) (hf : IsUniformInducing f) :\n    UniformGroup β where\n  uniformContinuous_div := by\n    simp_rw [hf.uniformContinuous_iff, Function.comp_def, map_div]\n    exact uniformContinuous_div.comp (hf.uniformContinuous.prodMap hf.uniformContinuous)\n\n"}
{"name":"UniformInducing.uniformGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"β : Type u_2\ninst✝⁶ : Group β\nγ : Type u_3\ninst✝⁵ : Group γ\ninst✝⁴ : UniformSpace γ\ninst✝³ : UniformGroup γ\ninst✝² : UniformSpace β\nF : Type u_4\ninst✝¹ : FunLike F β γ\ninst✝ : MonoidHomClass F β γ\nf : F\nhf : IsUniformInducing ⇑f\n⊢ UniformGroup β","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.uniformGroup := IsUniformInducing.uniformGroup\n\n"}
{"name":"UniformAddGroup.comap","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"β : Type u_2\ninst✝⁴ : AddGroup β\nγ : Type u_3\ninst✝³ : AddGroup γ\nu : UniformSpace γ\ninst✝² : UniformAddGroup γ\nF : Type u_4\ninst✝¹ : FunLike F β γ\ninst✝ : AddMonoidHomClass F β γ\nf : F\n⊢ UniformAddGroup β","decl":"@[to_additive]\nprotected theorem UniformGroup.comap {γ : Type*} [Group γ] {u : UniformSpace γ} [UniformGroup γ]\n    {F : Type*} [FunLike F β γ] [MonoidHomClass F β γ] (f : F) : @UniformGroup β (u.comap f) _ :=\n  letI : UniformSpace β := u.comap f; IsUniformInducing.uniformGroup f ⟨rfl⟩\n\n"}
{"name":"UniformGroup.comap","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"β : Type u_2\ninst✝⁴ : Group β\nγ : Type u_3\ninst✝³ : Group γ\nu : UniformSpace γ\ninst✝² : UniformGroup γ\nF : Type u_4\ninst✝¹ : FunLike F β γ\ninst✝ : MonoidHomClass F β γ\nf : F\n⊢ UniformGroup β","decl":"@[to_additive]\nprotected theorem UniformGroup.comap {γ : Type*} [Group γ] {u : UniformSpace γ} [UniformGroup γ]\n    {F : Type*} [FunLike F β γ] [MonoidHomClass F β γ] (f : F) : @UniformGroup β (u.comap f) _ :=\n  letI : UniformSpace β := u.comap f; IsUniformInducing.uniformGroup f ⟨rfl⟩\n\n"}
{"name":"Subgroup.uniformGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝² : UniformSpace α\ninst✝¹ : Group α\ninst✝ : UniformGroup α\nS : Subgroup α\n⊢ UniformGroup (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance uniformGroup (S : Subgroup α) : UniformGroup S := .comap S.subtype\n\n"}
{"name":"AddSubgroup.uniformAddGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝² : UniformSpace α\ninst✝¹ : AddGroup α\ninst✝ : UniformAddGroup α\nS : AddSubgroup α\n⊢ UniformAddGroup (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance uniformGroup (S : Subgroup α) : UniformGroup S := .comap S.subtype\n\n"}
{"name":"CauchySeq.add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝³ : UniformSpace α\ninst✝² : AddGroup α\ninst✝¹ : UniformAddGroup α\nι : Type u_3\ninst✝ : Preorder ι\nu v : ι → α\nhu : CauchySeq u\nhv : CauchySeq v\n⊢ CauchySeq (HAdd.hAdd u v)","decl":"@[to_additive]\ntheorem CauchySeq.mul {ι : Type*} [Preorder ι] {u v : ι → α} (hu : CauchySeq u)\n    (hv : CauchySeq v) : CauchySeq (u * v) :=\n  uniformContinuous_mul.comp_cauchySeq (hu.prod hv)\n\n"}
{"name":"CauchySeq.mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝³ : UniformSpace α\ninst✝² : Group α\ninst✝¹ : UniformGroup α\nι : Type u_3\ninst✝ : Preorder ι\nu v : ι → α\nhu : CauchySeq u\nhv : CauchySeq v\n⊢ CauchySeq (HMul.hMul u v)","decl":"@[to_additive]\ntheorem CauchySeq.mul {ι : Type*} [Preorder ι] {u v : ι → α} (hu : CauchySeq u)\n    (hv : CauchySeq v) : CauchySeq (u * v) :=\n  uniformContinuous_mul.comp_cauchySeq (hu.prod hv)\n\n"}
{"name":"CauchySeq.mul_const","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝³ : UniformSpace α\ninst✝² : Group α\ninst✝¹ : UniformGroup α\nι : Type u_3\ninst✝ : Preorder ι\nu : ι → α\nx : α\nhu : CauchySeq u\n⊢ CauchySeq fun n => HMul.hMul (u n) x","decl":"@[to_additive]\ntheorem CauchySeq.mul_const {ι : Type*} [Preorder ι] {u : ι → α} {x : α} (hu : CauchySeq u) :\n    CauchySeq fun n => u n * x :=\n  (uniformContinuous_id.mul uniformContinuous_const).comp_cauchySeq hu\n\n"}
{"name":"CauchySeq.add_const","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝³ : UniformSpace α\ninst✝² : AddGroup α\ninst✝¹ : UniformAddGroup α\nι : Type u_3\ninst✝ : Preorder ι\nu : ι → α\nx : α\nhu : CauchySeq u\n⊢ CauchySeq fun n => HAdd.hAdd (u n) x","decl":"@[to_additive]\ntheorem CauchySeq.mul_const {ι : Type*} [Preorder ι] {u : ι → α} {x : α} (hu : CauchySeq u) :\n    CauchySeq fun n => u n * x :=\n  (uniformContinuous_id.mul uniformContinuous_const).comp_cauchySeq hu\n\n"}
{"name":"CauchySeq.const_mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝³ : UniformSpace α\ninst✝² : Group α\ninst✝¹ : UniformGroup α\nι : Type u_3\ninst✝ : Preorder ι\nu : ι → α\nx : α\nhu : CauchySeq u\n⊢ CauchySeq fun n => HMul.hMul x (u n)","decl":"@[to_additive]\ntheorem CauchySeq.const_mul {ι : Type*} [Preorder ι] {u : ι → α} {x : α} (hu : CauchySeq u) :\n    CauchySeq fun n => x * u n :=\n  (uniformContinuous_const.mul uniformContinuous_id).comp_cauchySeq hu\n\n"}
{"name":"CauchySeq.const_add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝³ : UniformSpace α\ninst✝² : AddGroup α\ninst✝¹ : UniformAddGroup α\nι : Type u_3\ninst✝ : Preorder ι\nu : ι → α\nx : α\nhu : CauchySeq u\n⊢ CauchySeq fun n => HAdd.hAdd x (u n)","decl":"@[to_additive]\ntheorem CauchySeq.const_mul {ι : Type*} [Preorder ι] {u : ι → α} {x : α} (hu : CauchySeq u) :\n    CauchySeq fun n => x * u n :=\n  (uniformContinuous_const.mul uniformContinuous_id).comp_cauchySeq hu\n\n"}
{"name":"CauchySeq.neg","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝³ : UniformSpace α\ninst✝² : AddGroup α\ninst✝¹ : UniformAddGroup α\nι : Type u_3\ninst✝ : Preorder ι\nu : ι → α\nh : CauchySeq u\n⊢ CauchySeq (Neg.neg u)","decl":"@[to_additive]\ntheorem CauchySeq.inv {ι : Type*} [Preorder ι] {u : ι → α} (h : CauchySeq u) :\n    CauchySeq u⁻¹ :=\n  uniformContinuous_inv.comp_cauchySeq h\n\n"}
{"name":"CauchySeq.inv","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝³ : UniformSpace α\ninst✝² : Group α\ninst✝¹ : UniformGroup α\nι : Type u_3\ninst✝ : Preorder ι\nu : ι → α\nh : CauchySeq u\n⊢ CauchySeq (Inv.inv u)","decl":"@[to_additive]\ntheorem CauchySeq.inv {ι : Type*} [Preorder ι] {u : ι → α} (h : CauchySeq u) :\n    CauchySeq u⁻¹ :=\n  uniformContinuous_inv.comp_cauchySeq h\n\n"}
{"name":"totallyBounded_iff_subset_finite_iUnion_nhds_zero","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝² : UniformSpace α\ninst✝¹ : AddGroup α\ninst✝ : UniformAddGroup α\ns : Set α\n⊢ Iff (TotallyBounded s) (∀ (U : Set α), Membership.mem (nhds 0) U → Exists fun t => And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => HVAdd.hVAdd y U)))","decl":"@[to_additive]\ntheorem totallyBounded_iff_subset_finite_iUnion_nhds_one {s : Set α} :\n    TotallyBounded s ↔ ∀ U ∈ 𝓝 (1 : α), ∃ t : Set α, t.Finite ∧ s ⊆ ⋃ y ∈ t, y • U :=\n  (𝓝 (1 : α)).basis_sets.uniformity_of_nhds_one_inv_mul_swapped.totallyBounded_iff.trans <| by\n    simp [← preimage_smul_inv, preimage]\n\n"}
{"name":"totallyBounded_iff_subset_finite_iUnion_nhds_one","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝² : UniformSpace α\ninst✝¹ : Group α\ninst✝ : UniformGroup α\ns : Set α\n⊢ Iff (TotallyBounded s) (∀ (U : Set α), Membership.mem (nhds 1) U → Exists fun t => And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => HSMul.hSMul y U)))","decl":"@[to_additive]\ntheorem totallyBounded_iff_subset_finite_iUnion_nhds_one {s : Set α} :\n    TotallyBounded s ↔ ∀ U ∈ 𝓝 (1 : α), ∃ t : Set α, t.Finite ∧ s ⊆ ⋃ y ∈ t, y • U :=\n  (𝓝 (1 : α)).basis_sets.uniformity_of_nhds_one_inv_mul_swapped.totallyBounded_iff.trans <| by\n    simp [← preimage_smul_inv, preimage]\n\n"}
{"name":"totallyBounded_inv","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝² : UniformSpace α\ninst✝¹ : Group α\ninst✝ : UniformGroup α\ns : Set α\nhs : TotallyBounded s\n⊢ TotallyBounded (Inv.inv s)","decl":"@[to_additive]\ntheorem totallyBounded_inv {s : Set α} (hs : TotallyBounded s) : TotallyBounded (s⁻¹) := by\n  convert TotallyBounded.image hs uniformContinuous_inv\n  aesop\n\n"}
{"name":"totallyBounded_neg","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\ninst✝² : UniformSpace α\ninst✝¹ : AddGroup α\ninst✝ : UniformAddGroup α\ns : Set α\nhs : TotallyBounded s\n⊢ TotallyBounded (Neg.neg s)","decl":"@[to_additive]\ntheorem totallyBounded_inv {s : Set α} (hs : TotallyBounded s) : TotallyBounded (s⁻¹) := by\n  convert TotallyBounded.image hs uniformContinuous_inv\n  aesop\n\n"}
{"name":"TendstoUniformlyOnFilter.mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : Group α\ninst✝ : UniformGroup α\nι : Type u_3\nl : Filter ι\nl' : Filter β\nf f' : ι → β → α\ng g' : β → α\nhf : TendstoUniformlyOnFilter f g l l'\nhf' : TendstoUniformlyOnFilter f' g' l l'\n⊢ TendstoUniformlyOnFilter (HMul.hMul f f') (HMul.hMul g g') l l'","decl":"@[to_additive]\ntheorem TendstoUniformlyOnFilter.mul (hf : TendstoUniformlyOnFilter f g l l')\n    (hf' : TendstoUniformlyOnFilter f' g' l l') : TendstoUniformlyOnFilter (f * f') (g * g') l l' :=\n  fun u hu =>\n  ((uniformContinuous_mul.comp_tendstoUniformlyOnFilter (hf.prod hf')) u hu).diag_of_prod_left\n\n"}
{"name":"TendstoUniformlyOnFilter.add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : AddGroup α\ninst✝ : UniformAddGroup α\nι : Type u_3\nl : Filter ι\nl' : Filter β\nf f' : ι → β → α\ng g' : β → α\nhf : TendstoUniformlyOnFilter f g l l'\nhf' : TendstoUniformlyOnFilter f' g' l l'\n⊢ TendstoUniformlyOnFilter (HAdd.hAdd f f') (HAdd.hAdd g g') l l'","decl":"@[to_additive]\ntheorem TendstoUniformlyOnFilter.mul (hf : TendstoUniformlyOnFilter f g l l')\n    (hf' : TendstoUniformlyOnFilter f' g' l l') : TendstoUniformlyOnFilter (f * f') (g * g') l l' :=\n  fun u hu =>\n  ((uniformContinuous_mul.comp_tendstoUniformlyOnFilter (hf.prod hf')) u hu).diag_of_prod_left\n\n"}
{"name":"TendstoUniformlyOnFilter.sub","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : AddGroup α\ninst✝ : UniformAddGroup α\nι : Type u_3\nl : Filter ι\nl' : Filter β\nf f' : ι → β → α\ng g' : β → α\nhf : TendstoUniformlyOnFilter f g l l'\nhf' : TendstoUniformlyOnFilter f' g' l l'\n⊢ TendstoUniformlyOnFilter (HSub.hSub f f') (HSub.hSub g g') l l'","decl":"@[to_additive]\ntheorem TendstoUniformlyOnFilter.div (hf : TendstoUniformlyOnFilter f g l l')\n    (hf' : TendstoUniformlyOnFilter f' g' l l') : TendstoUniformlyOnFilter (f / f') (g / g') l l' :=\n  fun u hu =>\n  ((uniformContinuous_div.comp_tendstoUniformlyOnFilter (hf.prod hf')) u hu).diag_of_prod_left\n\n"}
{"name":"TendstoUniformlyOnFilter.div","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : Group α\ninst✝ : UniformGroup α\nι : Type u_3\nl : Filter ι\nl' : Filter β\nf f' : ι → β → α\ng g' : β → α\nhf : TendstoUniformlyOnFilter f g l l'\nhf' : TendstoUniformlyOnFilter f' g' l l'\n⊢ TendstoUniformlyOnFilter (HDiv.hDiv f f') (HDiv.hDiv g g') l l'","decl":"@[to_additive]\ntheorem TendstoUniformlyOnFilter.div (hf : TendstoUniformlyOnFilter f g l l')\n    (hf' : TendstoUniformlyOnFilter f' g' l l') : TendstoUniformlyOnFilter (f / f') (g / g') l l' :=\n  fun u hu =>\n  ((uniformContinuous_div.comp_tendstoUniformlyOnFilter (hf.prod hf')) u hu).diag_of_prod_left\n\n"}
{"name":"TendstoUniformlyOn.add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : AddGroup α\ninst✝ : UniformAddGroup α\nι : Type u_3\nl : Filter ι\nf f' : ι → β → α\ng g' : β → α\ns : Set β\nhf : TendstoUniformlyOn f g l s\nhf' : TendstoUniformlyOn f' g' l s\n⊢ TendstoUniformlyOn (HAdd.hAdd f f') (HAdd.hAdd g g') l s","decl":"@[to_additive]\ntheorem TendstoUniformlyOn.mul (hf : TendstoUniformlyOn f g l s)\n    (hf' : TendstoUniformlyOn f' g' l s) : TendstoUniformlyOn (f * f') (g * g') l s := fun u hu =>\n  ((uniformContinuous_mul.comp_tendstoUniformlyOn (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformlyOn.mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : Group α\ninst✝ : UniformGroup α\nι : Type u_3\nl : Filter ι\nf f' : ι → β → α\ng g' : β → α\ns : Set β\nhf : TendstoUniformlyOn f g l s\nhf' : TendstoUniformlyOn f' g' l s\n⊢ TendstoUniformlyOn (HMul.hMul f f') (HMul.hMul g g') l s","decl":"@[to_additive]\ntheorem TendstoUniformlyOn.mul (hf : TendstoUniformlyOn f g l s)\n    (hf' : TendstoUniformlyOn f' g' l s) : TendstoUniformlyOn (f * f') (g * g') l s := fun u hu =>\n  ((uniformContinuous_mul.comp_tendstoUniformlyOn (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformlyOn.div","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : Group α\ninst✝ : UniformGroup α\nι : Type u_3\nl : Filter ι\nf f' : ι → β → α\ng g' : β → α\ns : Set β\nhf : TendstoUniformlyOn f g l s\nhf' : TendstoUniformlyOn f' g' l s\n⊢ TendstoUniformlyOn (HDiv.hDiv f f') (HDiv.hDiv g g') l s","decl":"@[to_additive]\ntheorem TendstoUniformlyOn.div (hf : TendstoUniformlyOn f g l s)\n    (hf' : TendstoUniformlyOn f' g' l s) : TendstoUniformlyOn (f / f') (g / g') l s := fun u hu =>\n  ((uniformContinuous_div.comp_tendstoUniformlyOn (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformlyOn.sub","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : AddGroup α\ninst✝ : UniformAddGroup α\nι : Type u_3\nl : Filter ι\nf f' : ι → β → α\ng g' : β → α\ns : Set β\nhf : TendstoUniformlyOn f g l s\nhf' : TendstoUniformlyOn f' g' l s\n⊢ TendstoUniformlyOn (HSub.hSub f f') (HSub.hSub g g') l s","decl":"@[to_additive]\ntheorem TendstoUniformlyOn.div (hf : TendstoUniformlyOn f g l s)\n    (hf' : TendstoUniformlyOn f' g' l s) : TendstoUniformlyOn (f / f') (g / g') l s := fun u hu =>\n  ((uniformContinuous_div.comp_tendstoUniformlyOn (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformly.mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : Group α\ninst✝ : UniformGroup α\nι : Type u_3\nl : Filter ι\nf f' : ι → β → α\ng g' : β → α\nhf : TendstoUniformly f g l\nhf' : TendstoUniformly f' g' l\n⊢ TendstoUniformly (HMul.hMul f f') (HMul.hMul g g') l","decl":"@[to_additive]\ntheorem TendstoUniformly.mul (hf : TendstoUniformly f g l) (hf' : TendstoUniformly f' g' l) :\n    TendstoUniformly (f * f') (g * g') l := fun u hu =>\n  ((uniformContinuous_mul.comp_tendstoUniformly (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformly.add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : AddGroup α\ninst✝ : UniformAddGroup α\nι : Type u_3\nl : Filter ι\nf f' : ι → β → α\ng g' : β → α\nhf : TendstoUniformly f g l\nhf' : TendstoUniformly f' g' l\n⊢ TendstoUniformly (HAdd.hAdd f f') (HAdd.hAdd g g') l","decl":"@[to_additive]\ntheorem TendstoUniformly.mul (hf : TendstoUniformly f g l) (hf' : TendstoUniformly f' g' l) :\n    TendstoUniformly (f * f') (g * g') l := fun u hu =>\n  ((uniformContinuous_mul.comp_tendstoUniformly (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformly.sub","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : AddGroup α\ninst✝ : UniformAddGroup α\nι : Type u_3\nl : Filter ι\nf f' : ι → β → α\ng g' : β → α\nhf : TendstoUniformly f g l\nhf' : TendstoUniformly f' g' l\n⊢ TendstoUniformly (HSub.hSub f f') (HSub.hSub g g') l","decl":"@[to_additive]\ntheorem TendstoUniformly.div (hf : TendstoUniformly f g l) (hf' : TendstoUniformly f' g' l) :\n    TendstoUniformly (f / f') (g / g') l := fun u hu =>\n  ((uniformContinuous_div.comp_tendstoUniformly (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformly.div","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : Group α\ninst✝ : UniformGroup α\nι : Type u_3\nl : Filter ι\nf f' : ι → β → α\ng g' : β → α\nhf : TendstoUniformly f g l\nhf' : TendstoUniformly f' g' l\n⊢ TendstoUniformly (HDiv.hDiv f f') (HDiv.hDiv g g') l","decl":"@[to_additive]\ntheorem TendstoUniformly.div (hf : TendstoUniformly f g l) (hf' : TendstoUniformly f' g' l) :\n    TendstoUniformly (f / f') (g / g') l := fun u hu =>\n  ((uniformContinuous_div.comp_tendstoUniformly (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"UniformCauchySeqOn.add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : AddGroup α\ninst✝ : UniformAddGroup α\nι : Type u_3\nl : Filter ι\nf f' : ι → β → α\ns : Set β\nhf : UniformCauchySeqOn f l s\nhf' : UniformCauchySeqOn f' l s\n⊢ UniformCauchySeqOn (HAdd.hAdd f f') l s","decl":"@[to_additive]\ntheorem UniformCauchySeqOn.mul (hf : UniformCauchySeqOn f l s) (hf' : UniformCauchySeqOn f' l s) :\n    UniformCauchySeqOn (f * f') l s := fun u hu => by\n  simpa using (uniformContinuous_mul.comp_uniformCauchySeqOn (hf.prod' hf')) u hu\n\n"}
{"name":"UniformCauchySeqOn.mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : Group α\ninst✝ : UniformGroup α\nι : Type u_3\nl : Filter ι\nf f' : ι → β → α\ns : Set β\nhf : UniformCauchySeqOn f l s\nhf' : UniformCauchySeqOn f' l s\n⊢ UniformCauchySeqOn (HMul.hMul f f') l s","decl":"@[to_additive]\ntheorem UniformCauchySeqOn.mul (hf : UniformCauchySeqOn f l s) (hf' : UniformCauchySeqOn f' l s) :\n    UniformCauchySeqOn (f * f') l s := fun u hu => by\n  simpa using (uniformContinuous_mul.comp_uniformCauchySeqOn (hf.prod' hf')) u hu\n\n"}
{"name":"UniformCauchySeqOn.div","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : Group α\ninst✝ : UniformGroup α\nι : Type u_3\nl : Filter ι\nf f' : ι → β → α\ns : Set β\nhf : UniformCauchySeqOn f l s\nhf' : UniformCauchySeqOn f' l s\n⊢ UniformCauchySeqOn (HDiv.hDiv f f') l s","decl":"@[to_additive]\ntheorem UniformCauchySeqOn.div (hf : UniformCauchySeqOn f l s) (hf' : UniformCauchySeqOn f' l s) :\n    UniformCauchySeqOn (f / f') l s := fun u hu => by\n  simpa using (uniformContinuous_div.comp_uniformCauchySeqOn (hf.prod' hf')) u hu\n\n"}
{"name":"UniformCauchySeqOn.sub","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : AddGroup α\ninst✝ : UniformAddGroup α\nι : Type u_3\nl : Filter ι\nf f' : ι → β → α\ns : Set β\nhf : UniformCauchySeqOn f l s\nhf' : UniformCauchySeqOn f' l s\n⊢ UniformCauchySeqOn (HSub.hSub f f') l s","decl":"@[to_additive]\ntheorem UniformCauchySeqOn.div (hf : UniformCauchySeqOn f l s) (hf' : UniformCauchySeqOn f' l s) :\n    UniformCauchySeqOn (f / f') l s := fun u hu => by\n  simpa using (uniformContinuous_div.comp_uniformCauchySeqOn (hf.prod' hf')) u hu\n\n"}
{"name":"topologicalAddGroup_is_uniform_of_compactSpace","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : CompactSpace G\n⊢ UniformAddGroup G","decl":"@[to_additive]\ntheorem topologicalGroup_is_uniform_of_compactSpace [CompactSpace G] : UniformGroup G :=\n  ⟨by\n    apply CompactSpace.uniformContinuous_of_continuous\n    exact continuous_div'⟩\n\n"}
{"name":"topologicalGroup_is_uniform_of_compactSpace","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalGroup G\ninst✝ : CompactSpace G\n⊢ UniformGroup G","decl":"@[to_additive]\ntheorem topologicalGroup_is_uniform_of_compactSpace [CompactSpace G] : UniformGroup G :=\n  ⟨by\n    apply CompactSpace.uniformContinuous_of_continuous\n    exact continuous_div'⟩\n\n"}
{"name":"Subgroup.isClosed_of_discrete","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\ninst✝¹ : T2Space G\nH : Subgroup G\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem H x)\n⊢ IsClosed ↑H","decl":"@[to_additive]\ninstance Subgroup.isClosed_of_discrete [T2Space G] {H : Subgroup G} [DiscreteTopology H] :\n    IsClosed (H : Set G) := by\n  obtain ⟨V, V_in, VH⟩ : ∃ (V : Set G), V ∈ 𝓝 (1 : G) ∧ V ∩ (H : Set G) = {1} :=\n    nhds_inter_eq_singleton_of_mem_discrete H.one_mem\n  have : (fun p : G × G => p.2 / p.1) ⁻¹' V ∈ 𝓤 G := preimage_mem_comap V_in\n  apply isClosed_of_spaced_out this\n  intro h h_in h' h'_in\n  contrapose!\n  simp only [Set.mem_preimage, not_not]\n  rintro (hyp : h' / h ∈ V)\n  have : h' / h ∈ ({1} : Set G) := VH ▸ Set.mem_inter hyp (H.div_mem h'_in h_in)\n  exact (eq_of_div_eq_one this).symm\n\n"}
{"name":"AddSubgroup.isClosed_of_discrete","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : T2Space G\nH : AddSubgroup G\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem H x)\n⊢ IsClosed ↑H","decl":"@[to_additive]\ninstance Subgroup.isClosed_of_discrete [T2Space G] {H : Subgroup G} [DiscreteTopology H] :\n    IsClosed (H : Set G) := by\n  obtain ⟨V, V_in, VH⟩ : ∃ (V : Set G), V ∈ 𝓝 (1 : G) ∧ V ∩ (H : Set G) = {1} :=\n    nhds_inter_eq_singleton_of_mem_discrete H.one_mem\n  have : (fun p : G × G => p.2 / p.1) ⁻¹' V ∈ 𝓤 G := preimage_mem_comap V_in\n  apply isClosed_of_spaced_out this\n  intro h h_in h' h'_in\n  contrapose!\n  simp only [Set.mem_preimage, not_not]\n  rintro (hyp : h' / h ∈ V)\n  have : h' / h ∈ ({1} : Set G) := VH ▸ Set.mem_inter hyp (H.div_mem h'_in h_in)\n  exact (eq_of_div_eq_one this).symm\n\n"}
{"name":"AddSubgroup.tendsto_coe_cofinite_of_discrete","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : T2Space G\nH : AddSubgroup G\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem H x)\n⊢ Filter.Tendsto Subtype.val Filter.cofinite (Filter.cocompact G)","decl":"@[to_additive]\nlemma Subgroup.tendsto_coe_cofinite_of_discrete [T2Space G] (H : Subgroup G) [DiscreteTopology H] :\n    Tendsto ((↑) : H → G) cofinite (cocompact _) :=\n  IsClosed.tendsto_coe_cofinite_of_discreteTopology inferInstance inferInstance\n\n"}
{"name":"Subgroup.tendsto_coe_cofinite_of_discrete","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : Group G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalGroup G\ninst✝¹ : T2Space G\nH : Subgroup G\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem H x)\n⊢ Filter.Tendsto Subtype.val Filter.cofinite (Filter.cocompact G)","decl":"@[to_additive]\nlemma Subgroup.tendsto_coe_cofinite_of_discrete [T2Space G] (H : Subgroup G) [DiscreteTopology H] :\n    Tendsto ((↑) : H → G) cofinite (cocompact _) :=\n  IsClosed.tendsto_coe_cofinite_of_discreteTopology inferInstance inferInstance\n\n"}
{"name":"AddMonoidHom.tendsto_coe_cofinite_of_discrete","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : T2Space G\nH : Type u_2\ninst✝ : AddGroup H\nf : AddMonoidHom H G\nhf : Function.Injective ⇑f\nhf' : DiscreteTopology (Subtype fun x => Membership.mem f.range x)\n⊢ Filter.Tendsto (⇑f) Filter.cofinite (Filter.cocompact G)","decl":"@[to_additive]\nlemma MonoidHom.tendsto_coe_cofinite_of_discrete [T2Space G] {H : Type*} [Group H] {f : H →* G}\n    (hf : Function.Injective f) (hf' : DiscreteTopology f.range) :\n    Tendsto f cofinite (cocompact _) := by\n  replace hf : Function.Injective f.rangeRestrict := by simpa\n  exact f.range.tendsto_coe_cofinite_of_discrete.comp hf.tendsto_cofinite\n\n"}
{"name":"MonoidHom.tendsto_coe_cofinite_of_discrete","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninst✝⁴ : Group G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalGroup G\ninst✝¹ : T2Space G\nH : Type u_2\ninst✝ : Group H\nf : MonoidHom H G\nhf : Function.Injective ⇑f\nhf' : DiscreteTopology (Subtype fun x => Membership.mem f.range x)\n⊢ Filter.Tendsto (⇑f) Filter.cofinite (Filter.cocompact G)","decl":"@[to_additive]\nlemma MonoidHom.tendsto_coe_cofinite_of_discrete [T2Space G] {H : Type*} [Group H] {f : H →* G}\n    (hf : Function.Injective f) (hf' : DiscreteTopology f.range) :\n    Tendsto f cofinite (cocompact _) := by\n  replace hf : Function.Injective f.rangeRestrict := by simpa\n  exact f.range.tendsto_coe_cofinite_of_discrete.comp hf.tendsto_cofinite\n\n"}
{"name":"TopologicalAddGroup.tendstoUniformly_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\nG : Type u_3\ninst✝¹ : AddGroup G\nu : UniformSpace G\ninst✝ : TopologicalAddGroup G\nF : ι → α → G\nf : α → G\np : Filter ι\nhu : Eq (TopologicalAddGroup.toUniformSpace G) u\n⊢ Iff (TendstoUniformly F f p) (∀ (u_1 : Set G), Membership.mem (nhds 0) u_1 → Filter.Eventually (fun i => ∀ (a : α), Membership.mem u_1 (HSub.hSub (F i a) (f a))) p)","decl":"@[to_additive]\ntheorem tendstoUniformly_iff (F : ι → α → G) (f : α → G) (p : Filter ι)\n    (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoUniformly F f p ↔ ∀ u ∈ 𝓝 (1 : G), ∀ᶠ i in p, ∀ a, F i a / f a ∈ u :=\n  hu ▸ ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩,\n    fun h _ ⟨u, hu, hv⟩ => mem_of_superset (h u hu) fun _ hi a => hv (hi a)⟩\n\n"}
{"name":"TopologicalGroup.tendstoUniformly_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\nG : Type u_3\ninst✝¹ : Group G\nu : UniformSpace G\ninst✝ : TopologicalGroup G\nF : ι → α → G\nf : α → G\np : Filter ι\nhu : Eq (TopologicalGroup.toUniformSpace G) u\n⊢ Iff (TendstoUniformly F f p) (∀ (u_1 : Set G), Membership.mem (nhds 1) u_1 → Filter.Eventually (fun i => ∀ (a : α), Membership.mem u_1 (HDiv.hDiv (F i a) (f a))) p)","decl":"@[to_additive]\ntheorem tendstoUniformly_iff (F : ι → α → G) (f : α → G) (p : Filter ι)\n    (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoUniformly F f p ↔ ∀ u ∈ 𝓝 (1 : G), ∀ᶠ i in p, ∀ a, F i a / f a ∈ u :=\n  hu ▸ ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩,\n    fun h _ ⟨u, hu, hv⟩ => mem_of_superset (h u hu) fun _ hi a => hv (hi a)⟩\n\n"}
{"name":"TopologicalAddGroup.tendstoUniformlyOn_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\nG : Type u_3\ninst✝¹ : AddGroup G\nu : UniformSpace G\ninst✝ : TopologicalAddGroup G\nF : ι → α → G\nf : α → G\np : Filter ι\ns : Set α\nhu : Eq (TopologicalAddGroup.toUniformSpace G) u\n⊢ Iff (TendstoUniformlyOn F f p s) (∀ (u_1 : Set G), Membership.mem (nhds 0) u_1 → Filter.Eventually (fun i => ∀ (a : α), Membership.mem s a → Membership.mem u_1 (HSub.hSub (F i a) (f a))) p)","decl":"@[to_additive]\ntheorem tendstoUniformlyOn_iff (F : ι → α → G) (f : α → G) (p : Filter ι) (s : Set α)\n    (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoUniformlyOn F f p s ↔ ∀ u ∈ 𝓝 (1 : G), ∀ᶠ i in p, ∀ a ∈ s, F i a / f a ∈ u :=\n  hu ▸ ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩,\n    fun h _ ⟨u, hu, hv⟩ => mem_of_superset (h u hu) fun _ hi a ha => hv (hi a ha)⟩\n\n"}
{"name":"TopologicalGroup.tendstoUniformlyOn_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\nG : Type u_3\ninst✝¹ : Group G\nu : UniformSpace G\ninst✝ : TopologicalGroup G\nF : ι → α → G\nf : α → G\np : Filter ι\ns : Set α\nhu : Eq (TopologicalGroup.toUniformSpace G) u\n⊢ Iff (TendstoUniformlyOn F f p s) (∀ (u_1 : Set G), Membership.mem (nhds 1) u_1 → Filter.Eventually (fun i => ∀ (a : α), Membership.mem s a → Membership.mem u_1 (HDiv.hDiv (F i a) (f a))) p)","decl":"@[to_additive]\ntheorem tendstoUniformlyOn_iff (F : ι → α → G) (f : α → G) (p : Filter ι) (s : Set α)\n    (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoUniformlyOn F f p s ↔ ∀ u ∈ 𝓝 (1 : G), ∀ᶠ i in p, ∀ a ∈ s, F i a / f a ∈ u :=\n  hu ▸ ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩,\n    fun h _ ⟨u, hu, hv⟩ => mem_of_superset (h u hu) fun _ hi a ha => hv (hi a ha)⟩\n\n"}
{"name":"TopologicalGroup.tendstoLocallyUniformly_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\nG : Type u_3\ninst✝² : Group G\nu : UniformSpace G\ninst✝¹ : TopologicalGroup G\ninst✝ : TopologicalSpace α\nF : ι → α → G\nf : α → G\np : Filter ι\nhu : Eq (TopologicalGroup.toUniformSpace G) u\n⊢ Iff (TendstoLocallyUniformly F f p) (∀ (u_1 : Set G), Membership.mem (nhds 1) u_1 → ∀ (x : α), Exists fun t => And (Membership.mem (nhds x) t) (Filter.Eventually (fun i => ∀ (a : α), Membership.mem t a → Membership.mem u_1 (HDiv.hDiv (F i a) (f a))) p))","decl":"@[to_additive]\ntheorem tendstoLocallyUniformly_iff [TopologicalSpace α] (F : ι → α → G) (f : α → G)\n    (p : Filter ι) (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoLocallyUniformly F f p ↔\n      ∀ u ∈ 𝓝 (1 : G), ∀ (x : α), ∃ t ∈ 𝓝 x, ∀ᶠ i in p, ∀ a ∈ t, F i a / f a ∈ u :=\n  hu ▸ ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩, fun h _ ⟨u, hu, hv⟩ x =>\n    Exists.imp (fun _ ⟨h, hp⟩ => ⟨h, mem_of_superset hp fun _ hi a ha => hv (hi a ha)⟩)\n      (h u hu x)⟩\n\n"}
{"name":"TopologicalAddGroup.tendstoLocallyUniformly_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\nG : Type u_3\ninst✝² : AddGroup G\nu : UniformSpace G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : TopologicalSpace α\nF : ι → α → G\nf : α → G\np : Filter ι\nhu : Eq (TopologicalAddGroup.toUniformSpace G) u\n⊢ Iff (TendstoLocallyUniformly F f p) (∀ (u_1 : Set G), Membership.mem (nhds 0) u_1 → ∀ (x : α), Exists fun t => And (Membership.mem (nhds x) t) (Filter.Eventually (fun i => ∀ (a : α), Membership.mem t a → Membership.mem u_1 (HSub.hSub (F i a) (f a))) p))","decl":"@[to_additive]\ntheorem tendstoLocallyUniformly_iff [TopologicalSpace α] (F : ι → α → G) (f : α → G)\n    (p : Filter ι) (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoLocallyUniformly F f p ↔\n      ∀ u ∈ 𝓝 (1 : G), ∀ (x : α), ∃ t ∈ 𝓝 x, ∀ᶠ i in p, ∀ a ∈ t, F i a / f a ∈ u :=\n  hu ▸ ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩, fun h _ ⟨u, hu, hv⟩ x =>\n    Exists.imp (fun _ ⟨h, hp⟩ => ⟨h, mem_of_superset hp fun _ hi a ha => hv (hi a ha)⟩)\n      (h u hu x)⟩\n\n"}
{"name":"TopologicalAddGroup.tendstoLocallyUniformlyOn_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\nG : Type u_3\ninst✝² : AddGroup G\nu : UniformSpace G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : TopologicalSpace α\nF : ι → α → G\nf : α → G\np : Filter ι\ns : Set α\nhu : Eq (TopologicalAddGroup.toUniformSpace G) u\n⊢ Iff (TendstoLocallyUniformlyOn F f p s) (∀ (u_1 : Set G), Membership.mem (nhds 0) u_1 → ∀ (x : α), Membership.mem s x → Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Filter.Eventually (fun i => ∀ (a : α), Membership.mem t a → Membership.mem u_1 (HSub.hSub (F i a) (f a))) p))","decl":"@[to_additive]\ntheorem tendstoLocallyUniformlyOn_iff [TopologicalSpace α] (F : ι → α → G) (f : α → G)\n    (p : Filter ι) (s : Set α) (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoLocallyUniformlyOn F f p s ↔\n      ∀ u ∈ 𝓝 (1 : G), ∀ x ∈ s, ∃ t ∈ 𝓝[s] x, ∀ᶠ i in p, ∀ a ∈ t, F i a / f a ∈ u :=\n  hu ▸ ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩, fun h _ ⟨u, hu, hv⟩ x =>\n    (Exists.imp fun _ ⟨h, hp⟩ => ⟨h, mem_of_superset hp fun _ hi a ha => hv (hi a ha)⟩) ∘\n      h u hu x⟩\n\n"}
{"name":"TopologicalGroup.tendstoLocallyUniformlyOn_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\nG : Type u_3\ninst✝² : Group G\nu : UniformSpace G\ninst✝¹ : TopologicalGroup G\ninst✝ : TopologicalSpace α\nF : ι → α → G\nf : α → G\np : Filter ι\ns : Set α\nhu : Eq (TopologicalGroup.toUniformSpace G) u\n⊢ Iff (TendstoLocallyUniformlyOn F f p s) (∀ (u_1 : Set G), Membership.mem (nhds 1) u_1 → ∀ (x : α), Membership.mem s x → Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Filter.Eventually (fun i => ∀ (a : α), Membership.mem t a → Membership.mem u_1 (HDiv.hDiv (F i a) (f a))) p))","decl":"@[to_additive]\ntheorem tendstoLocallyUniformlyOn_iff [TopologicalSpace α] (F : ι → α → G) (f : α → G)\n    (p : Filter ι) (s : Set α) (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoLocallyUniformlyOn F f p s ↔\n      ∀ u ∈ 𝓝 (1 : G), ∀ x ∈ s, ∃ t ∈ 𝓝[s] x, ∀ᶠ i in p, ∀ a ∈ t, F i a / f a ∈ u :=\n  hu ▸ ⟨fun h u hu => h _ ⟨u, hu, fun _ => id⟩, fun h _ ⟨u, hu, hv⟩ x =>\n    (Exists.imp fun _ ⟨h, hp⟩ => ⟨h, mem_of_superset hp fun _ hi a ha => hv (hi a ha)⟩) ∘\n      h u hu x⟩\n\n"}
{"name":"IsDenseInducing.extend_Z_bilin","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nG : Type u_5\ninst✝¹⁴ : TopologicalSpace α\ninst✝¹³ : AddCommGroup α\ninst✝¹² : TopologicalAddGroup α\ninst✝¹¹ : TopologicalSpace β\ninst✝¹⁰ : AddCommGroup β\ninst✝⁹ : TopologicalSpace γ\ninst✝⁸ : AddCommGroup γ\ninst✝⁷ : TopologicalAddGroup γ\ninst✝⁶ : TopologicalSpace δ\ninst✝⁵ : AddCommGroup δ\ninst✝⁴ : UniformSpace G\ninst✝³ : AddCommGroup G\ne : AddMonoidHom β α\nde : IsDenseInducing ⇑e\nf : AddMonoidHom δ γ\ndf : IsDenseInducing ⇑f\nφ : AddMonoidHom β (AddMonoidHom δ G)\nhφ : Continuous fun p => (φ p.1) p.2\ninst✝² : UniformAddGroup G\ninst✝¹ : T0Space G\ninst✝ : CompleteSpace G\n⊢ Continuous (⋯.extend fun p => (φ p.1) p.2)","decl":"/-- Bourbaki GT III.6.5 Theorem I:\nℤ-bilinear continuous maps from dense images into a complete Hausdorff group extend by continuity.\nNote: Bourbaki assumes that α and β are also complete Hausdorff, but this is not necessary. -/\ntheorem extend_Z_bilin : Continuous (extend (de.prodMap df) (fun p : β × δ => φ p.1 p.2)) := by\n  refine continuous_extend_of_cauchy _ ?_\n  rintro ⟨x₀, y₀⟩\n  constructor\n  · apply NeBot.map\n    apply comap_neBot\n    intro U h\n    rcases mem_closure_iff_nhds.1 ((de.prodMap df).dense (x₀, y₀)) U h with ⟨x, x_in, ⟨z, z_x⟩⟩\n    exists z\n    aesop\n  · suffices map (fun p : (β × δ) × β × δ => (fun p : β × δ => φ p.1 p.2) p.2 -\n      (fun p : β × δ => φ p.1 p.2) p.1)\n        (comap (fun p : (β × δ) × β × δ => ((e p.1.1, f p.1.2), (e p.2.1, f p.2.2)))\n        (𝓝 (x₀, y₀) ×ˢ 𝓝 (x₀, y₀))) ≤ 𝓝 0 by\n      rwa [uniformity_eq_comap_nhds_zero G, prod_map_map_eq, ← map_le_iff_le_comap, Filter.map_map,\n        prod_comap_comap_eq]\n    intro W' W'_nhd\n    have key := extend_Z_bilin_key de df hφ W'_nhd x₀ y₀\n    rcases key with ⟨U, U_nhd, V, V_nhd, h⟩\n    rw [mem_comap] at U_nhd\n    rcases U_nhd with ⟨U', U'_nhd, U'_sub⟩\n    rw [mem_comap] at V_nhd\n    rcases V_nhd with ⟨V', V'_nhd, V'_sub⟩\n    rw [mem_map, mem_comap, nhds_prod_eq]\n    exists (U' ×ˢ V') ×ˢ U' ×ˢ V'\n    rw [mem_prod_same_iff]\n    simp only [exists_prop]\n    constructor\n    · have := prod_mem_prod U'_nhd V'_nhd\n      tauto\n    · intro p h'\n      simp only [Set.mem_preimage, Set.prod_mk_mem_set_prod_eq] at h'\n      rcases p with ⟨⟨x, y⟩, ⟨x', y'⟩⟩\n      apply h <;> tauto\n\n"}
{"name":"QuotientAddGroup.completeSpace'","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u\ninst✝⁵ : AddGroup G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : TopologicalAddGroup G\ninst✝² : FirstCountableTopology G\nN : AddSubgroup G\ninst✝¹ : N.Normal\ninst✝ : CompleteSpace G\n⊢ CompleteSpace (HasQuotient.Quotient G N)","decl":"open Classical in\n/-- The quotient `G ⧸ N` of a complete first countable topological group `G` by a normal subgroup\nis itself complete. [N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nBecause a topological group is not equipped with a `UniformSpace` instance by default, we must\nexplicitly provide it in order to consider completeness. See `QuotientGroup.completeSpace` for a\nversion in which `G` is already equipped with a uniform structure. -/\n@[to_additive \"The quotient `G ⧸ N` of a complete first countable topological additive group\n`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by\nsubspaces are complete. [N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nBecause an additive topological group is not equipped with a `UniformSpace` instance by default,\nwe must explicitly provide it in order to consider completeness. See\n`QuotientAddGroup.completeSpace` for a version in which `G` is already equipped with a uniform\nstructure.\"]\ninstance QuotientGroup.completeSpace' (G : Type u) [Group G] [TopologicalSpace G]\n    [TopologicalGroup G] [FirstCountableTopology G] (N : Subgroup G) [N.Normal]\n    [@CompleteSpace G (TopologicalGroup.toUniformSpace G)] :\n    @CompleteSpace (G ⧸ N) (TopologicalGroup.toUniformSpace (G ⧸ N)) := by\n  /- Since `G ⧸ N` is a topological group it is a uniform space, and since `G` is first countable\n    the uniformities of both `G` and `G ⧸ N` are countably generated. Moreover, we may choose a\n    sequential antitone neighborhood basis `u` for `𝓝 (1 : G)` so that `(u (n + 1)) ^ 2 ⊆ u n`, and\n    this descends to an antitone neighborhood basis `v` for `𝓝 (1 : G ⧸ N)`. Since `𝓤 (G ⧸ N)` is\n    countably generated, it suffices to show any Cauchy sequence `x` converges. -/\n  letI : UniformSpace (G ⧸ N) := TopologicalGroup.toUniformSpace (G ⧸ N)\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  haveI : (𝓤 (G ⧸ N)).IsCountablyGenerated := comap.isCountablyGenerated _ _\n  obtain ⟨u, hu, u_mul⟩ := TopologicalGroup.exists_antitone_basis_nhds_one G\n  obtain ⟨hv, v_anti⟩ := hu.map ((↑) : G → G ⧸ N)\n  rw [← QuotientGroup.nhds_eq N 1, QuotientGroup.mk_one] at hv\n  refine UniformSpace.complete_of_cauchySeq_tendsto fun x hx => ?_\n  /- Given `n : ℕ`, for sufficiently large `a b : ℕ`, given any lift of `x b`, we can find a lift\n    of `x a` such that the quotient of the lifts lies in `u n`. -/\n  have key₀ : ∀ i j : ℕ, ∃ M : ℕ, j < M ∧ ∀ a b : ℕ, M ≤ a → M ≤ b →\n      ∀ g : G, x b = g → ∃ g' : G, g / g' ∈ u i ∧ x a = g' := by\n    have h𝓤GN : (𝓤 (G ⧸ N)).HasBasis (fun _ ↦ True) fun i ↦ { x | x.snd / x.fst ∈ (↑) '' u i } := by\n      simpa [uniformity_eq_comap_nhds_one'] using hv.comap _\n    rw [h𝓤GN.cauchySeq_iff] at hx\n    simp only [mem_setOf_eq, forall_true_left, mem_image] at hx\n    intro i j\n    rcases hx i with ⟨M, hM⟩\n    refine ⟨max j M + 1, (le_max_left _ _).trans_lt (lt_add_one _), fun a b ha hb g hg => ?_⟩\n    obtain ⟨y, y_mem, hy⟩ :=\n      hM a (((le_max_right j _).trans (lt_add_one _).le).trans ha) b\n        (((le_max_right j _).trans (lt_add_one _).le).trans hb)\n    refine\n      ⟨y⁻¹ * g, by\n        simpa only [div_eq_mul_inv, mul_inv_rev, inv_inv, mul_inv_cancel_left] using y_mem, ?_⟩\n    rw [QuotientGroup.mk_mul, QuotientGroup.mk_inv, hy, hg, inv_div, div_mul_cancel]\n  /- Inductively construct a subsequence `φ : ℕ → ℕ` using `key₀` so that if `a b : ℕ` exceed\n    `φ (n + 1)`, then we may find lifts whose quotients lie within `u n`. -/\n  set φ : ℕ → ℕ := fun n => Nat.recOn n (choose <| key₀ 0 0) fun k yk => choose <| key₀ (k + 1) yk\n  have hφ :\n    ∀ n : ℕ,\n      φ n < φ (n + 1) ∧\n        ∀ a b : ℕ,\n          φ (n + 1) ≤ a →\n            φ (n + 1) ≤ b → ∀ g : G, x b = g → ∃ g' : G, g / g' ∈ u (n + 1) ∧ x a = g' :=\n    fun n => choose_spec (key₀ (n + 1) (φ n))\n  /- Inductively construct a sequence `x' n : G` of lifts of `x (φ (n + 1))` such that quotients of\n    successive terms lie in `x' n / x' (n + 1) ∈ u (n + 1)`. We actually need the proofs that each\n    term is a lift to construct the next term, so we use a Σ-type. -/\n  set x' : ∀ n, PSigma fun g : G => x (φ (n + 1)) = g := fun n =>\n    Nat.recOn n\n      ⟨choose (QuotientGroup.mk_surjective (x (φ 1))),\n        (choose_spec (QuotientGroup.mk_surjective (x (φ 1)))).symm⟩\n      fun k hk =>\n      ⟨choose <| (hφ k).2 _ _ (hφ (k + 1)).1.le le_rfl hk.fst hk.snd,\n        (choose_spec <| (hφ k).2 _ _ (hφ (k + 1)).1.le le_rfl hk.fst hk.snd).2⟩\n  have hx' : ∀ n : ℕ, (x' n).fst / (x' (n + 1)).fst ∈ u (n + 1) := fun n =>\n    (choose_spec <| (hφ n).2 _ _ (hφ (n + 1)).1.le le_rfl (x' n).fst (x' n).snd).1\n  /- The sequence `x'` is Cauchy. This is where we exploit the condition on `u`. The key idea\n    is to show by decreasing induction that `x' m / x' n ∈ u m` if `m ≤ n`. -/\n  have x'_cauchy : CauchySeq fun n => (x' n).fst := by\n    have h𝓤G : (𝓤 G).HasBasis (fun _ => True) fun i => { x | x.snd / x.fst ∈ u i } := by\n      simpa [uniformity_eq_comap_nhds_one'] using hu.toHasBasis.comap _\n    rw [h𝓤G.cauchySeq_iff']\n    simp only [mem_setOf_eq, forall_true_left]\n    exact fun m =>\n      ⟨m, fun n hmn =>\n        Nat.decreasingInduction'\n          (fun k _ _ hk => u_mul k ⟨_, hx' k, _, hk, div_mul_div_cancel _ _ _⟩) hmn\n          (by simpa only [div_self'] using mem_of_mem_nhds (hu.mem _))⟩\n  /- Since `G` is complete, `x'` converges to some `x₀`, and so the image of this sequence under\n    the quotient map converges to `↑x₀`. The image of `x'` is a convergent subsequence of `x`, and\n    since `x` is Cauchy, this implies it converges. -/\n  rcases cauchySeq_tendsto_of_complete x'_cauchy with ⟨x₀, hx₀⟩\n  refine\n    ⟨↑x₀,\n      tendsto_nhds_of_cauchySeq_of_subseq hx\n        (strictMono_nat_of_lt_succ fun n => (hφ (n + 1)).1).tendsto_atTop ?_⟩\n  convert ((continuous_coinduced_rng : Continuous ((↑) : G → G ⧸ N)).tendsto x₀).comp hx₀\n  exact funext fun n => (x' n).snd\n\n"}
{"name":"QuotientGroup.completeSpace'","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u\ninst✝⁵ : Group G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : TopologicalGroup G\ninst✝² : FirstCountableTopology G\nN : Subgroup G\ninst✝¹ : N.Normal\ninst✝ : CompleteSpace G\n⊢ CompleteSpace (HasQuotient.Quotient G N)","decl":"open Classical in\n/-- The quotient `G ⧸ N` of a complete first countable topological group `G` by a normal subgroup\nis itself complete. [N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nBecause a topological group is not equipped with a `UniformSpace` instance by default, we must\nexplicitly provide it in order to consider completeness. See `QuotientGroup.completeSpace` for a\nversion in which `G` is already equipped with a uniform structure. -/\n@[to_additive \"The quotient `G ⧸ N` of a complete first countable topological additive group\n`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by\nsubspaces are complete. [N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nBecause an additive topological group is not equipped with a `UniformSpace` instance by default,\nwe must explicitly provide it in order to consider completeness. See\n`QuotientAddGroup.completeSpace` for a version in which `G` is already equipped with a uniform\nstructure.\"]\ninstance QuotientGroup.completeSpace' (G : Type u) [Group G] [TopologicalSpace G]\n    [TopologicalGroup G] [FirstCountableTopology G] (N : Subgroup G) [N.Normal]\n    [@CompleteSpace G (TopologicalGroup.toUniformSpace G)] :\n    @CompleteSpace (G ⧸ N) (TopologicalGroup.toUniformSpace (G ⧸ N)) := by\n  /- Since `G ⧸ N` is a topological group it is a uniform space, and since `G` is first countable\n    the uniformities of both `G` and `G ⧸ N` are countably generated. Moreover, we may choose a\n    sequential antitone neighborhood basis `u` for `𝓝 (1 : G)` so that `(u (n + 1)) ^ 2 ⊆ u n`, and\n    this descends to an antitone neighborhood basis `v` for `𝓝 (1 : G ⧸ N)`. Since `𝓤 (G ⧸ N)` is\n    countably generated, it suffices to show any Cauchy sequence `x` converges. -/\n  letI : UniformSpace (G ⧸ N) := TopologicalGroup.toUniformSpace (G ⧸ N)\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  haveI : (𝓤 (G ⧸ N)).IsCountablyGenerated := comap.isCountablyGenerated _ _\n  obtain ⟨u, hu, u_mul⟩ := TopologicalGroup.exists_antitone_basis_nhds_one G\n  obtain ⟨hv, v_anti⟩ := hu.map ((↑) : G → G ⧸ N)\n  rw [← QuotientGroup.nhds_eq N 1, QuotientGroup.mk_one] at hv\n  refine UniformSpace.complete_of_cauchySeq_tendsto fun x hx => ?_\n  /- Given `n : ℕ`, for sufficiently large `a b : ℕ`, given any lift of `x b`, we can find a lift\n    of `x a` such that the quotient of the lifts lies in `u n`. -/\n  have key₀ : ∀ i j : ℕ, ∃ M : ℕ, j < M ∧ ∀ a b : ℕ, M ≤ a → M ≤ b →\n      ∀ g : G, x b = g → ∃ g' : G, g / g' ∈ u i ∧ x a = g' := by\n    have h𝓤GN : (𝓤 (G ⧸ N)).HasBasis (fun _ ↦ True) fun i ↦ { x | x.snd / x.fst ∈ (↑) '' u i } := by\n      simpa [uniformity_eq_comap_nhds_one'] using hv.comap _\n    rw [h𝓤GN.cauchySeq_iff] at hx\n    simp only [mem_setOf_eq, forall_true_left, mem_image] at hx\n    intro i j\n    rcases hx i with ⟨M, hM⟩\n    refine ⟨max j M + 1, (le_max_left _ _).trans_lt (lt_add_one _), fun a b ha hb g hg => ?_⟩\n    obtain ⟨y, y_mem, hy⟩ :=\n      hM a (((le_max_right j _).trans (lt_add_one _).le).trans ha) b\n        (((le_max_right j _).trans (lt_add_one _).le).trans hb)\n    refine\n      ⟨y⁻¹ * g, by\n        simpa only [div_eq_mul_inv, mul_inv_rev, inv_inv, mul_inv_cancel_left] using y_mem, ?_⟩\n    rw [QuotientGroup.mk_mul, QuotientGroup.mk_inv, hy, hg, inv_div, div_mul_cancel]\n  /- Inductively construct a subsequence `φ : ℕ → ℕ` using `key₀` so that if `a b : ℕ` exceed\n    `φ (n + 1)`, then we may find lifts whose quotients lie within `u n`. -/\n  set φ : ℕ → ℕ := fun n => Nat.recOn n (choose <| key₀ 0 0) fun k yk => choose <| key₀ (k + 1) yk\n  have hφ :\n    ∀ n : ℕ,\n      φ n < φ (n + 1) ∧\n        ∀ a b : ℕ,\n          φ (n + 1) ≤ a →\n            φ (n + 1) ≤ b → ∀ g : G, x b = g → ∃ g' : G, g / g' ∈ u (n + 1) ∧ x a = g' :=\n    fun n => choose_spec (key₀ (n + 1) (φ n))\n  /- Inductively construct a sequence `x' n : G` of lifts of `x (φ (n + 1))` such that quotients of\n    successive terms lie in `x' n / x' (n + 1) ∈ u (n + 1)`. We actually need the proofs that each\n    term is a lift to construct the next term, so we use a Σ-type. -/\n  set x' : ∀ n, PSigma fun g : G => x (φ (n + 1)) = g := fun n =>\n    Nat.recOn n\n      ⟨choose (QuotientGroup.mk_surjective (x (φ 1))),\n        (choose_spec (QuotientGroup.mk_surjective (x (φ 1)))).symm⟩\n      fun k hk =>\n      ⟨choose <| (hφ k).2 _ _ (hφ (k + 1)).1.le le_rfl hk.fst hk.snd,\n        (choose_spec <| (hφ k).2 _ _ (hφ (k + 1)).1.le le_rfl hk.fst hk.snd).2⟩\n  have hx' : ∀ n : ℕ, (x' n).fst / (x' (n + 1)).fst ∈ u (n + 1) := fun n =>\n    (choose_spec <| (hφ n).2 _ _ (hφ (n + 1)).1.le le_rfl (x' n).fst (x' n).snd).1\n  /- The sequence `x'` is Cauchy. This is where we exploit the condition on `u`. The key idea\n    is to show by decreasing induction that `x' m / x' n ∈ u m` if `m ≤ n`. -/\n  have x'_cauchy : CauchySeq fun n => (x' n).fst := by\n    have h𝓤G : (𝓤 G).HasBasis (fun _ => True) fun i => { x | x.snd / x.fst ∈ u i } := by\n      simpa [uniformity_eq_comap_nhds_one'] using hu.toHasBasis.comap _\n    rw [h𝓤G.cauchySeq_iff']\n    simp only [mem_setOf_eq, forall_true_left]\n    exact fun m =>\n      ⟨m, fun n hmn =>\n        Nat.decreasingInduction'\n          (fun k _ _ hk => u_mul k ⟨_, hx' k, _, hk, div_mul_div_cancel _ _ _⟩) hmn\n          (by simpa only [div_self'] using mem_of_mem_nhds (hu.mem _))⟩\n  /- Since `G` is complete, `x'` converges to some `x₀`, and so the image of this sequence under\n    the quotient map converges to `↑x₀`. The image of `x'` is a convergent subsequence of `x`, and\n    since `x` is Cauchy, this implies it converges. -/\n  rcases cauchySeq_tendsto_of_complete x'_cauchy with ⟨x₀, hx₀⟩\n  refine\n    ⟨↑x₀,\n      tendsto_nhds_of_cauchySeq_of_subseq hx\n        (strictMono_nat_of_lt_succ fun n => (hφ (n + 1)).1).tendsto_atTop ?_⟩\n  convert ((continuous_coinduced_rng : Continuous ((↑) : G → G ⧸ N)).tendsto x₀).comp hx₀\n  exact funext fun n => (x' n).snd\n\n"}
{"name":"QuotientAddGroup.completeSpace","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u\ninst✝³ : AddGroup G\nus : UniformSpace G\ninst✝² : UniformAddGroup G\ninst✝¹ : FirstCountableTopology G\nN : AddSubgroup G\ninst✝ : N.Normal\nhG : CompleteSpace G\n⊢ CompleteSpace (HasQuotient.Quotient G N)","decl":"/-- The quotient `G ⧸ N` of a complete first countable uniform group `G` by a normal subgroup\nis itself complete. In contrast to `QuotientGroup.completeSpace'`, in this version `G` is\nalready equipped with a uniform structure.\n[N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nEven though `G` is equipped with a uniform structure, the quotient `G ⧸ N` does not inherit a\nuniform structure, so it is still provided manually via `TopologicalGroup.toUniformSpace`.\nIn the most common use cases, this coincides (definitionally) with the uniform structure on the\nquotient obtained via other means. -/\n@[to_additive \"The quotient `G ⧸ N` of a complete first countable uniform additive group\n`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by\nsubspaces are complete. In contrast to `QuotientAddGroup.completeSpace'`, in this version\n`G` is already equipped with a uniform structure.\n[N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nEven though `G` is equipped with a uniform structure, the quotient `G ⧸ N` does not inherit a\nuniform structure, so it is still provided manually via `TopologicalAddGroup.toUniformSpace`.\nIn the most common use case ─ quotients of normed additive commutative groups by subgroups ─\nsignificant care was taken so that the uniform structure inherent in that setting coincides\n(definitionally) with the uniform structure provided here.\"]\ninstance QuotientGroup.completeSpace (G : Type u) [Group G] [us : UniformSpace G] [UniformGroup G]\n    [FirstCountableTopology G] (N : Subgroup G) [N.Normal] [hG : CompleteSpace G] :\n    @CompleteSpace (G ⧸ N) (TopologicalGroup.toUniformSpace (G ⧸ N)) := by\n  rw [← @UniformGroup.toUniformSpace_eq _ us _ _] at hG\n  infer_instance\n\n"}
{"name":"QuotientGroup.completeSpace","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u\ninst✝³ : Group G\nus : UniformSpace G\ninst✝² : UniformGroup G\ninst✝¹ : FirstCountableTopology G\nN : Subgroup G\ninst✝ : N.Normal\nhG : CompleteSpace G\n⊢ CompleteSpace (HasQuotient.Quotient G N)","decl":"/-- The quotient `G ⧸ N` of a complete first countable uniform group `G` by a normal subgroup\nis itself complete. In contrast to `QuotientGroup.completeSpace'`, in this version `G` is\nalready equipped with a uniform structure.\n[N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nEven though `G` is equipped with a uniform structure, the quotient `G ⧸ N` does not inherit a\nuniform structure, so it is still provided manually via `TopologicalGroup.toUniformSpace`.\nIn the most common use cases, this coincides (definitionally) with the uniform structure on the\nquotient obtained via other means. -/\n@[to_additive \"The quotient `G ⧸ N` of a complete first countable uniform additive group\n`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by\nsubspaces are complete. In contrast to `QuotientAddGroup.completeSpace'`, in this version\n`G` is already equipped with a uniform structure.\n[N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nEven though `G` is equipped with a uniform structure, the quotient `G ⧸ N` does not inherit a\nuniform structure, so it is still provided manually via `TopologicalAddGroup.toUniformSpace`.\nIn the most common use case ─ quotients of normed additive commutative groups by subgroups ─\nsignificant care was taken so that the uniform structure inherent in that setting coincides\n(definitionally) with the uniform structure provided here.\"]\ninstance QuotientGroup.completeSpace (G : Type u) [Group G] [us : UniformSpace G] [UniformGroup G]\n    [FirstCountableTopology G] (N : Subgroup G) [N.Normal] [hG : CompleteSpace G] :\n    @CompleteSpace (G ⧸ N) (TopologicalGroup.toUniformSpace (G ⧸ N)) := by\n  rw [← @UniformGroup.toUniformSpace_eq _ us _ _] at hG\n  infer_instance\n\n"}
