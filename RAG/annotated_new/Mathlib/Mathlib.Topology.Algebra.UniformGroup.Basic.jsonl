{"name":"Pi.instUniformAddGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î¹ : Type u_3\nG : Î¹ â†’ Type u_4\ninstâœÂ² : (i : Î¹) â†’ UniformSpace (G i)\ninstâœÂ¹ : (i : Î¹) â†’ AddGroup (G i)\ninstâœ : âˆ€ (i : Î¹), UniformAddGroup (G i)\nâŠ¢ UniformAddGroup ((i : Î¹) â†’ G i)","decl":"@[to_additive]\ninstance Pi.instUniformGroup {Î¹ : Type*} {G : Î¹ â†’ Type*} [âˆ€ i, UniformSpace (G i)]\n    [âˆ€ i, Group (G i)] [âˆ€ i, UniformGroup (G i)] : UniformGroup (âˆ€ i, G i) where\n  uniformContinuous_div := uniformContinuous_pi.mpr fun i â†¦\n    (uniformContinuous_proj G i).comp uniformContinuous_fst |>.div <|\n      (uniformContinuous_proj G i).comp uniformContinuous_snd\n\n"}
{"name":"Pi.instUniformGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î¹ : Type u_3\nG : Î¹ â†’ Type u_4\ninstâœÂ² : (i : Î¹) â†’ UniformSpace (G i)\ninstâœÂ¹ : (i : Î¹) â†’ Group (G i)\ninstâœ : âˆ€ (i : Î¹), UniformGroup (G i)\nâŠ¢ UniformGroup ((i : Î¹) â†’ G i)","decl":"@[to_additive]\ninstance Pi.instUniformGroup {Î¹ : Type*} {G : Î¹ â†’ Type*} [âˆ€ i, UniformSpace (G i)]\n    [âˆ€ i, Group (G i)] [âˆ€ i, UniformGroup (G i)] : UniformGroup (âˆ€ i, G i) where\n  uniformContinuous_div := uniformContinuous_pi.mpr fun i â†¦\n    (uniformContinuous_proj G i).comp uniformContinuous_fst |>.div <|\n      (uniformContinuous_proj G i).comp uniformContinuous_snd\n\n"}
{"name":"isUniformEmbedding_translate_add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : UniformAddGroup Î±\na : Î±\nâŠ¢ IsUniformEmbedding fun x => HAdd.hAdd x a","decl":"@[to_additive]\ntheorem isUniformEmbedding_translate_mul (a : Î±) : IsUniformEmbedding fun x : Î± => x * a :=\n  { comap_uniformity := by\n      nth_rw 1 [â† uniformity_translate_mul a, comap_map]\n      rintro âŸ¨pâ‚, pâ‚‚âŸ© âŸ¨qâ‚, qâ‚‚âŸ©\n      simp only [Prod.mk.injEq, mul_left_inj, imp_self]\n    injective := mul_left_injective a }\n\n"}
{"name":"isUniformEmbedding_translate_mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : UniformGroup Î±\na : Î±\nâŠ¢ IsUniformEmbedding fun x => HMul.hMul x a","decl":"@[to_additive]\ntheorem isUniformEmbedding_translate_mul (a : Î±) : IsUniformEmbedding fun x : Î± => x * a :=\n  { comap_uniformity := by\n      nth_rw 1 [â† uniformity_translate_mul a, comap_map]\n      rintro âŸ¨pâ‚, pâ‚‚âŸ© âŸ¨qâ‚, qâ‚‚âŸ©\n      simp only [Prod.mk.injEq, mul_left_inj, imp_self]\n    injective := mul_left_injective a }\n\n"}
{"name":"uniformEmbedding_translate_mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : UniformGroup Î±\na : Î±\nâŠ¢ IsUniformEmbedding fun x => HMul.hMul x a","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_translate_mul := isUniformEmbedding_translate_mul\n\n"}
{"name":"IsUniformInducing.uniformAddGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î² : Type u_2\ninstâœâ¶ : AddGroup Î²\nÎ³ : Type u_3\ninstâœâµ : AddGroup Î³\ninstâœâ´ : UniformSpace Î³\ninstâœÂ³ : UniformAddGroup Î³\ninstâœÂ² : UniformSpace Î²\nF : Type u_4\ninstâœÂ¹ : FunLike F Î² Î³\ninstâœ : AddMonoidHomClass F Î² Î³\nf : F\nhf : IsUniformInducing â‡‘f\nâŠ¢ UniformAddGroup Î²","decl":"@[to_additive]\nlemma IsUniformInducing.uniformGroup {Î³ : Type*} [Group Î³] [UniformSpace Î³] [UniformGroup Î³]\n    [UniformSpace Î²] {F : Type*} [FunLike F Î² Î³] [MonoidHomClass F Î² Î³]\n    (f : F) (hf : IsUniformInducing f) :\n    UniformGroup Î² where\n  uniformContinuous_div := by\n    simp_rw [hf.uniformContinuous_iff, Function.comp_def, map_div]\n    exact uniformContinuous_div.comp (hf.uniformContinuous.prodMap hf.uniformContinuous)\n\n"}
{"name":"IsUniformInducing.uniformGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î² : Type u_2\ninstâœâ¶ : Group Î²\nÎ³ : Type u_3\ninstâœâµ : Group Î³\ninstâœâ´ : UniformSpace Î³\ninstâœÂ³ : UniformGroup Î³\ninstâœÂ² : UniformSpace Î²\nF : Type u_4\ninstâœÂ¹ : FunLike F Î² Î³\ninstâœ : MonoidHomClass F Î² Î³\nf : F\nhf : IsUniformInducing â‡‘f\nâŠ¢ UniformGroup Î²","decl":"@[to_additive]\nlemma IsUniformInducing.uniformGroup {Î³ : Type*} [Group Î³] [UniformSpace Î³] [UniformGroup Î³]\n    [UniformSpace Î²] {F : Type*} [FunLike F Î² Î³] [MonoidHomClass F Î² Î³]\n    (f : F) (hf : IsUniformInducing f) :\n    UniformGroup Î² where\n  uniformContinuous_div := by\n    simp_rw [hf.uniformContinuous_iff, Function.comp_def, map_div]\n    exact uniformContinuous_div.comp (hf.uniformContinuous.prodMap hf.uniformContinuous)\n\n"}
{"name":"UniformInducing.uniformGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î² : Type u_2\ninstâœâ¶ : Group Î²\nÎ³ : Type u_3\ninstâœâµ : Group Î³\ninstâœâ´ : UniformSpace Î³\ninstâœÂ³ : UniformGroup Î³\ninstâœÂ² : UniformSpace Î²\nF : Type u_4\ninstâœÂ¹ : FunLike F Î² Î³\ninstâœ : MonoidHomClass F Î² Î³\nf : F\nhf : IsUniformInducing â‡‘f\nâŠ¢ UniformGroup Î²","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.uniformGroup := IsUniformInducing.uniformGroup\n\n"}
{"name":"UniformAddGroup.comap","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î² : Type u_2\ninstâœâ´ : AddGroup Î²\nÎ³ : Type u_3\ninstâœÂ³ : AddGroup Î³\nu : UniformSpace Î³\ninstâœÂ² : UniformAddGroup Î³\nF : Type u_4\ninstâœÂ¹ : FunLike F Î² Î³\ninstâœ : AddMonoidHomClass F Î² Î³\nf : F\nâŠ¢ UniformAddGroup Î²","decl":"@[to_additive]\nprotected theorem UniformGroup.comap {Î³ : Type*} [Group Î³] {u : UniformSpace Î³} [UniformGroup Î³]\n    {F : Type*} [FunLike F Î² Î³] [MonoidHomClass F Î² Î³] (f : F) : @UniformGroup Î² (u.comap f) _ :=\n  letI : UniformSpace Î² := u.comap f; IsUniformInducing.uniformGroup f âŸ¨rflâŸ©\n\n"}
{"name":"UniformGroup.comap","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î² : Type u_2\ninstâœâ´ : Group Î²\nÎ³ : Type u_3\ninstâœÂ³ : Group Î³\nu : UniformSpace Î³\ninstâœÂ² : UniformGroup Î³\nF : Type u_4\ninstâœÂ¹ : FunLike F Î² Î³\ninstâœ : MonoidHomClass F Î² Î³\nf : F\nâŠ¢ UniformGroup Î²","decl":"@[to_additive]\nprotected theorem UniformGroup.comap {Î³ : Type*} [Group Î³] {u : UniformSpace Î³} [UniformGroup Î³]\n    {F : Type*} [FunLike F Î² Î³] [MonoidHomClass F Î² Î³] (f : F) : @UniformGroup Î² (u.comap f) _ :=\n  letI : UniformSpace Î² := u.comap f; IsUniformInducing.uniformGroup f âŸ¨rflâŸ©\n\n"}
{"name":"Subgroup.uniformGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : UniformGroup Î±\nS : Subgroup Î±\nâŠ¢ UniformGroup (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance uniformGroup (S : Subgroup Î±) : UniformGroup S := .comap S.subtype\n\n"}
{"name":"AddSubgroup.uniformAddGroup","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : UniformAddGroup Î±\nS : AddSubgroup Î±\nâŠ¢ UniformAddGroup (Subtype fun x => Membership.mem S x)","decl":"@[to_additive]\ninstance uniformGroup (S : Subgroup Î±) : UniformGroup S := .comap S.subtype\n\n"}
{"name":"CauchySeq.add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : AddGroup Î±\ninstâœÂ¹ : UniformAddGroup Î±\nÎ¹ : Type u_3\ninstâœ : Preorder Î¹\nu v : Î¹ â†’ Î±\nhu : CauchySeq u\nhv : CauchySeq v\nâŠ¢ CauchySeq (HAdd.hAdd u v)","decl":"@[to_additive]\ntheorem CauchySeq.mul {Î¹ : Type*} [Preorder Î¹] {u v : Î¹ â†’ Î±} (hu : CauchySeq u)\n    (hv : CauchySeq v) : CauchySeq (u * v) :=\n  uniformContinuous_mul.comp_cauchySeq (hu.prod hv)\n\n"}
{"name":"CauchySeq.mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : Group Î±\ninstâœÂ¹ : UniformGroup Î±\nÎ¹ : Type u_3\ninstâœ : Preorder Î¹\nu v : Î¹ â†’ Î±\nhu : CauchySeq u\nhv : CauchySeq v\nâŠ¢ CauchySeq (HMul.hMul u v)","decl":"@[to_additive]\ntheorem CauchySeq.mul {Î¹ : Type*} [Preorder Î¹] {u v : Î¹ â†’ Î±} (hu : CauchySeq u)\n    (hv : CauchySeq v) : CauchySeq (u * v) :=\n  uniformContinuous_mul.comp_cauchySeq (hu.prod hv)\n\n"}
{"name":"CauchySeq.mul_const","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : Group Î±\ninstâœÂ¹ : UniformGroup Î±\nÎ¹ : Type u_3\ninstâœ : Preorder Î¹\nu : Î¹ â†’ Î±\nx : Î±\nhu : CauchySeq u\nâŠ¢ CauchySeq fun n => HMul.hMul (u n) x","decl":"@[to_additive]\ntheorem CauchySeq.mul_const {Î¹ : Type*} [Preorder Î¹] {u : Î¹ â†’ Î±} {x : Î±} (hu : CauchySeq u) :\n    CauchySeq fun n => u n * x :=\n  (uniformContinuous_id.mul uniformContinuous_const).comp_cauchySeq hu\n\n"}
{"name":"CauchySeq.add_const","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : AddGroup Î±\ninstâœÂ¹ : UniformAddGroup Î±\nÎ¹ : Type u_3\ninstâœ : Preorder Î¹\nu : Î¹ â†’ Î±\nx : Î±\nhu : CauchySeq u\nâŠ¢ CauchySeq fun n => HAdd.hAdd (u n) x","decl":"@[to_additive]\ntheorem CauchySeq.mul_const {Î¹ : Type*} [Preorder Î¹] {u : Î¹ â†’ Î±} {x : Î±} (hu : CauchySeq u) :\n    CauchySeq fun n => u n * x :=\n  (uniformContinuous_id.mul uniformContinuous_const).comp_cauchySeq hu\n\n"}
{"name":"CauchySeq.const_mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : Group Î±\ninstâœÂ¹ : UniformGroup Î±\nÎ¹ : Type u_3\ninstâœ : Preorder Î¹\nu : Î¹ â†’ Î±\nx : Î±\nhu : CauchySeq u\nâŠ¢ CauchySeq fun n => HMul.hMul x (u n)","decl":"@[to_additive]\ntheorem CauchySeq.const_mul {Î¹ : Type*} [Preorder Î¹] {u : Î¹ â†’ Î±} {x : Î±} (hu : CauchySeq u) :\n    CauchySeq fun n => x * u n :=\n  (uniformContinuous_const.mul uniformContinuous_id).comp_cauchySeq hu\n\n"}
{"name":"CauchySeq.const_add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : AddGroup Î±\ninstâœÂ¹ : UniformAddGroup Î±\nÎ¹ : Type u_3\ninstâœ : Preorder Î¹\nu : Î¹ â†’ Î±\nx : Î±\nhu : CauchySeq u\nâŠ¢ CauchySeq fun n => HAdd.hAdd x (u n)","decl":"@[to_additive]\ntheorem CauchySeq.const_mul {Î¹ : Type*} [Preorder Î¹] {u : Î¹ â†’ Î±} {x : Î±} (hu : CauchySeq u) :\n    CauchySeq fun n => x * u n :=\n  (uniformContinuous_const.mul uniformContinuous_id).comp_cauchySeq hu\n\n"}
{"name":"CauchySeq.neg","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : AddGroup Î±\ninstâœÂ¹ : UniformAddGroup Î±\nÎ¹ : Type u_3\ninstâœ : Preorder Î¹\nu : Î¹ â†’ Î±\nh : CauchySeq u\nâŠ¢ CauchySeq (Neg.neg u)","decl":"@[to_additive]\ntheorem CauchySeq.inv {Î¹ : Type*} [Preorder Î¹] {u : Î¹ â†’ Î±} (h : CauchySeq u) :\n    CauchySeq uâ»Â¹ :=\n  uniformContinuous_inv.comp_cauchySeq h\n\n"}
{"name":"CauchySeq.inv","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : Group Î±\ninstâœÂ¹ : UniformGroup Î±\nÎ¹ : Type u_3\ninstâœ : Preorder Î¹\nu : Î¹ â†’ Î±\nh : CauchySeq u\nâŠ¢ CauchySeq (Inv.inv u)","decl":"@[to_additive]\ntheorem CauchySeq.inv {Î¹ : Type*} [Preorder Î¹] {u : Î¹ â†’ Î±} (h : CauchySeq u) :\n    CauchySeq uâ»Â¹ :=\n  uniformContinuous_inv.comp_cauchySeq h\n\n"}
{"name":"totallyBounded_iff_subset_finite_iUnion_nhds_zero","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : UniformAddGroup Î±\ns : Set Î±\nâŠ¢ Iff (TotallyBounded s) (âˆ€ (U : Set Î±), Membership.mem (nhds 0) U â†’ Exists fun t => And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => HVAdd.hVAdd y U)))","decl":"@[to_additive]\ntheorem totallyBounded_iff_subset_finite_iUnion_nhds_one {s : Set Î±} :\n    TotallyBounded s â†” âˆ€ U âˆˆ ğ“ (1 : Î±), âˆƒ t : Set Î±, t.Finite âˆ§ s âŠ† â‹ƒ y âˆˆ t, y â€¢ U :=\n  (ğ“ (1 : Î±)).basis_sets.uniformity_of_nhds_one_inv_mul_swapped.totallyBounded_iff.trans <| by\n    simp [â† preimage_smul_inv, preimage]\n\n"}
{"name":"totallyBounded_iff_subset_finite_iUnion_nhds_one","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : UniformGroup Î±\ns : Set Î±\nâŠ¢ Iff (TotallyBounded s) (âˆ€ (U : Set Î±), Membership.mem (nhds 1) U â†’ Exists fun t => And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => HSMul.hSMul y U)))","decl":"@[to_additive]\ntheorem totallyBounded_iff_subset_finite_iUnion_nhds_one {s : Set Î±} :\n    TotallyBounded s â†” âˆ€ U âˆˆ ğ“ (1 : Î±), âˆƒ t : Set Î±, t.Finite âˆ§ s âŠ† â‹ƒ y âˆˆ t, y â€¢ U :=\n  (ğ“ (1 : Î±)).basis_sets.uniformity_of_nhds_one_inv_mul_swapped.totallyBounded_iff.trans <| by\n    simp [â† preimage_smul_inv, preimage]\n\n"}
{"name":"totallyBounded_inv","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : UniformGroup Î±\ns : Set Î±\nhs : TotallyBounded s\nâŠ¢ TotallyBounded (Inv.inv s)","decl":"@[to_additive]\ntheorem totallyBounded_inv {s : Set Î±} (hs : TotallyBounded s) : TotallyBounded (sâ»Â¹) := by\n  convert TotallyBounded.image hs uniformContinuous_inv\n  aesop\n\n"}
{"name":"totallyBounded_neg","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : UniformAddGroup Î±\ns : Set Î±\nhs : TotallyBounded s\nâŠ¢ TotallyBounded (Neg.neg s)","decl":"@[to_additive]\ntheorem totallyBounded_inv {s : Set Î±} (hs : TotallyBounded s) : TotallyBounded (sâ»Â¹) := by\n  convert TotallyBounded.image hs uniformContinuous_inv\n  aesop\n\n"}
{"name":"TendstoUniformlyOnFilter.mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : UniformGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nl' : Filter Î²\nf f' : Î¹ â†’ Î² â†’ Î±\ng g' : Î² â†’ Î±\nhf : TendstoUniformlyOnFilter f g l l'\nhf' : TendstoUniformlyOnFilter f' g' l l'\nâŠ¢ TendstoUniformlyOnFilter (HMul.hMul f f') (HMul.hMul g g') l l'","decl":"@[to_additive]\ntheorem TendstoUniformlyOnFilter.mul (hf : TendstoUniformlyOnFilter f g l l')\n    (hf' : TendstoUniformlyOnFilter f' g' l l') : TendstoUniformlyOnFilter (f * f') (g * g') l l' :=\n  fun u hu =>\n  ((uniformContinuous_mul.comp_tendstoUniformlyOnFilter (hf.prod hf')) u hu).diag_of_prod_left\n\n"}
{"name":"TendstoUniformlyOnFilter.add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : UniformAddGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nl' : Filter Î²\nf f' : Î¹ â†’ Î² â†’ Î±\ng g' : Î² â†’ Î±\nhf : TendstoUniformlyOnFilter f g l l'\nhf' : TendstoUniformlyOnFilter f' g' l l'\nâŠ¢ TendstoUniformlyOnFilter (HAdd.hAdd f f') (HAdd.hAdd g g') l l'","decl":"@[to_additive]\ntheorem TendstoUniformlyOnFilter.mul (hf : TendstoUniformlyOnFilter f g l l')\n    (hf' : TendstoUniformlyOnFilter f' g' l l') : TendstoUniformlyOnFilter (f * f') (g * g') l l' :=\n  fun u hu =>\n  ((uniformContinuous_mul.comp_tendstoUniformlyOnFilter (hf.prod hf')) u hu).diag_of_prod_left\n\n"}
{"name":"TendstoUniformlyOnFilter.sub","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : UniformAddGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nl' : Filter Î²\nf f' : Î¹ â†’ Î² â†’ Î±\ng g' : Î² â†’ Î±\nhf : TendstoUniformlyOnFilter f g l l'\nhf' : TendstoUniformlyOnFilter f' g' l l'\nâŠ¢ TendstoUniformlyOnFilter (HSub.hSub f f') (HSub.hSub g g') l l'","decl":"@[to_additive]\ntheorem TendstoUniformlyOnFilter.div (hf : TendstoUniformlyOnFilter f g l l')\n    (hf' : TendstoUniformlyOnFilter f' g' l l') : TendstoUniformlyOnFilter (f / f') (g / g') l l' :=\n  fun u hu =>\n  ((uniformContinuous_div.comp_tendstoUniformlyOnFilter (hf.prod hf')) u hu).diag_of_prod_left\n\n"}
{"name":"TendstoUniformlyOnFilter.div","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : UniformGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nl' : Filter Î²\nf f' : Î¹ â†’ Î² â†’ Î±\ng g' : Î² â†’ Î±\nhf : TendstoUniformlyOnFilter f g l l'\nhf' : TendstoUniformlyOnFilter f' g' l l'\nâŠ¢ TendstoUniformlyOnFilter (HDiv.hDiv f f') (HDiv.hDiv g g') l l'","decl":"@[to_additive]\ntheorem TendstoUniformlyOnFilter.div (hf : TendstoUniformlyOnFilter f g l l')\n    (hf' : TendstoUniformlyOnFilter f' g' l l') : TendstoUniformlyOnFilter (f / f') (g / g') l l' :=\n  fun u hu =>\n  ((uniformContinuous_div.comp_tendstoUniformlyOnFilter (hf.prod hf')) u hu).diag_of_prod_left\n\n"}
{"name":"TendstoUniformlyOn.add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : UniformAddGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nf f' : Î¹ â†’ Î² â†’ Î±\ng g' : Î² â†’ Î±\ns : Set Î²\nhf : TendstoUniformlyOn f g l s\nhf' : TendstoUniformlyOn f' g' l s\nâŠ¢ TendstoUniformlyOn (HAdd.hAdd f f') (HAdd.hAdd g g') l s","decl":"@[to_additive]\ntheorem TendstoUniformlyOn.mul (hf : TendstoUniformlyOn f g l s)\n    (hf' : TendstoUniformlyOn f' g' l s) : TendstoUniformlyOn (f * f') (g * g') l s := fun u hu =>\n  ((uniformContinuous_mul.comp_tendstoUniformlyOn (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformlyOn.mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : UniformGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nf f' : Î¹ â†’ Î² â†’ Î±\ng g' : Î² â†’ Î±\ns : Set Î²\nhf : TendstoUniformlyOn f g l s\nhf' : TendstoUniformlyOn f' g' l s\nâŠ¢ TendstoUniformlyOn (HMul.hMul f f') (HMul.hMul g g') l s","decl":"@[to_additive]\ntheorem TendstoUniformlyOn.mul (hf : TendstoUniformlyOn f g l s)\n    (hf' : TendstoUniformlyOn f' g' l s) : TendstoUniformlyOn (f * f') (g * g') l s := fun u hu =>\n  ((uniformContinuous_mul.comp_tendstoUniformlyOn (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformlyOn.div","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : UniformGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nf f' : Î¹ â†’ Î² â†’ Î±\ng g' : Î² â†’ Î±\ns : Set Î²\nhf : TendstoUniformlyOn f g l s\nhf' : TendstoUniformlyOn f' g' l s\nâŠ¢ TendstoUniformlyOn (HDiv.hDiv f f') (HDiv.hDiv g g') l s","decl":"@[to_additive]\ntheorem TendstoUniformlyOn.div (hf : TendstoUniformlyOn f g l s)\n    (hf' : TendstoUniformlyOn f' g' l s) : TendstoUniformlyOn (f / f') (g / g') l s := fun u hu =>\n  ((uniformContinuous_div.comp_tendstoUniformlyOn (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformlyOn.sub","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : UniformAddGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nf f' : Î¹ â†’ Î² â†’ Î±\ng g' : Î² â†’ Î±\ns : Set Î²\nhf : TendstoUniformlyOn f g l s\nhf' : TendstoUniformlyOn f' g' l s\nâŠ¢ TendstoUniformlyOn (HSub.hSub f f') (HSub.hSub g g') l s","decl":"@[to_additive]\ntheorem TendstoUniformlyOn.div (hf : TendstoUniformlyOn f g l s)\n    (hf' : TendstoUniformlyOn f' g' l s) : TendstoUniformlyOn (f / f') (g / g') l s := fun u hu =>\n  ((uniformContinuous_div.comp_tendstoUniformlyOn (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformly.mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : UniformGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nf f' : Î¹ â†’ Î² â†’ Î±\ng g' : Î² â†’ Î±\nhf : TendstoUniformly f g l\nhf' : TendstoUniformly f' g' l\nâŠ¢ TendstoUniformly (HMul.hMul f f') (HMul.hMul g g') l","decl":"@[to_additive]\ntheorem TendstoUniformly.mul (hf : TendstoUniformly f g l) (hf' : TendstoUniformly f' g' l) :\n    TendstoUniformly (f * f') (g * g') l := fun u hu =>\n  ((uniformContinuous_mul.comp_tendstoUniformly (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformly.add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : UniformAddGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nf f' : Î¹ â†’ Î² â†’ Î±\ng g' : Î² â†’ Î±\nhf : TendstoUniformly f g l\nhf' : TendstoUniformly f' g' l\nâŠ¢ TendstoUniformly (HAdd.hAdd f f') (HAdd.hAdd g g') l","decl":"@[to_additive]\ntheorem TendstoUniformly.mul (hf : TendstoUniformly f g l) (hf' : TendstoUniformly f' g' l) :\n    TendstoUniformly (f * f') (g * g') l := fun u hu =>\n  ((uniformContinuous_mul.comp_tendstoUniformly (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformly.sub","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : UniformAddGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nf f' : Î¹ â†’ Î² â†’ Î±\ng g' : Î² â†’ Î±\nhf : TendstoUniformly f g l\nhf' : TendstoUniformly f' g' l\nâŠ¢ TendstoUniformly (HSub.hSub f f') (HSub.hSub g g') l","decl":"@[to_additive]\ntheorem TendstoUniformly.div (hf : TendstoUniformly f g l) (hf' : TendstoUniformly f' g' l) :\n    TendstoUniformly (f / f') (g / g') l := fun u hu =>\n  ((uniformContinuous_div.comp_tendstoUniformly (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"TendstoUniformly.div","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : UniformGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nf f' : Î¹ â†’ Î² â†’ Î±\ng g' : Î² â†’ Î±\nhf : TendstoUniformly f g l\nhf' : TendstoUniformly f' g' l\nâŠ¢ TendstoUniformly (HDiv.hDiv f f') (HDiv.hDiv g g') l","decl":"@[to_additive]\ntheorem TendstoUniformly.div (hf : TendstoUniformly f g l) (hf' : TendstoUniformly f' g' l) :\n    TendstoUniformly (f / f') (g / g') l := fun u hu =>\n  ((uniformContinuous_div.comp_tendstoUniformly (hf.prod hf')) u hu).diag_of_prod\n\n"}
{"name":"UniformCauchySeqOn.add","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : UniformAddGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nf f' : Î¹ â†’ Î² â†’ Î±\ns : Set Î²\nhf : UniformCauchySeqOn f l s\nhf' : UniformCauchySeqOn f' l s\nâŠ¢ UniformCauchySeqOn (HAdd.hAdd f f') l s","decl":"@[to_additive]\ntheorem UniformCauchySeqOn.mul (hf : UniformCauchySeqOn f l s) (hf' : UniformCauchySeqOn f' l s) :\n    UniformCauchySeqOn (f * f') l s := fun u hu => by\n  simpa using (uniformContinuous_mul.comp_uniformCauchySeqOn (hf.prod' hf')) u hu\n\n"}
{"name":"UniformCauchySeqOn.mul","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : UniformGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nf f' : Î¹ â†’ Î² â†’ Î±\ns : Set Î²\nhf : UniformCauchySeqOn f l s\nhf' : UniformCauchySeqOn f' l s\nâŠ¢ UniformCauchySeqOn (HMul.hMul f f') l s","decl":"@[to_additive]\ntheorem UniformCauchySeqOn.mul (hf : UniformCauchySeqOn f l s) (hf' : UniformCauchySeqOn f' l s) :\n    UniformCauchySeqOn (f * f') l s := fun u hu => by\n  simpa using (uniformContinuous_mul.comp_uniformCauchySeqOn (hf.prod' hf')) u hu\n\n"}
{"name":"UniformCauchySeqOn.div","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : Group Î±\ninstâœ : UniformGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nf f' : Î¹ â†’ Î² â†’ Î±\ns : Set Î²\nhf : UniformCauchySeqOn f l s\nhf' : UniformCauchySeqOn f' l s\nâŠ¢ UniformCauchySeqOn (HDiv.hDiv f f') l s","decl":"@[to_additive]\ntheorem UniformCauchySeqOn.div (hf : UniformCauchySeqOn f l s) (hf' : UniformCauchySeqOn f' l s) :\n    UniformCauchySeqOn (f / f') l s := fun u hu => by\n  simpa using (uniformContinuous_div.comp_uniformCauchySeqOn (hf.prod' hf')) u hu\n\n"}
{"name":"UniformCauchySeqOn.sub","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : UniformSpace Î±\ninstâœÂ¹ : AddGroup Î±\ninstâœ : UniformAddGroup Î±\nÎ¹ : Type u_3\nl : Filter Î¹\nf f' : Î¹ â†’ Î² â†’ Î±\ns : Set Î²\nhf : UniformCauchySeqOn f l s\nhf' : UniformCauchySeqOn f' l s\nâŠ¢ UniformCauchySeqOn (HSub.hSub f f') l s","decl":"@[to_additive]\ntheorem UniformCauchySeqOn.div (hf : UniformCauchySeqOn f l s) (hf' : UniformCauchySeqOn f' l s) :\n    UniformCauchySeqOn (f / f') l s := fun u hu => by\n  simpa using (uniformContinuous_div.comp_uniformCauchySeqOn (hf.prod' hf')) u hu\n\n"}
{"name":"topologicalAddGroup_is_uniform_of_compactSpace","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninstâœÂ³ : AddGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : CompactSpace G\nâŠ¢ UniformAddGroup G","decl":"@[to_additive]\ntheorem topologicalGroup_is_uniform_of_compactSpace [CompactSpace G] : UniformGroup G :=\n  âŸ¨by\n    apply CompactSpace.uniformContinuous_of_continuous\n    exact continuous_div'âŸ©\n\n"}
{"name":"topologicalGroup_is_uniform_of_compactSpace","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninstâœÂ³ : Group G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : CompactSpace G\nâŠ¢ UniformGroup G","decl":"@[to_additive]\ntheorem topologicalGroup_is_uniform_of_compactSpace [CompactSpace G] : UniformGroup G :=\n  âŸ¨by\n    apply CompactSpace.uniformContinuous_of_continuous\n    exact continuous_div'âŸ©\n\n"}
{"name":"Subgroup.isClosed_of_discrete","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninstâœÂ³ : Group G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : T2Space G\nH : Subgroup G\ninstâœ : DiscreteTopology (Subtype fun x => Membership.mem H x)\nâŠ¢ IsClosed â†‘H","decl":"@[to_additive]\ninstance Subgroup.isClosed_of_discrete [T2Space G] {H : Subgroup G} [DiscreteTopology H] :\n    IsClosed (H : Set G) := by\n  obtain âŸ¨V, V_in, VHâŸ© : âˆƒ (V : Set G), V âˆˆ ğ“ (1 : G) âˆ§ V âˆ© (H : Set G) = {1} :=\n    nhds_inter_eq_singleton_of_mem_discrete H.one_mem\n  have : (fun p : G Ã— G => p.2 / p.1) â»Â¹' V âˆˆ ğ“¤ G := preimage_mem_comap V_in\n  apply isClosed_of_spaced_out this\n  intro h h_in h' h'_in\n  contrapose!\n  simp only [Set.mem_preimage, not_not]\n  rintro (hyp : h' / h âˆˆ V)\n  have : h' / h âˆˆ ({1} : Set G) := VH â–¸ Set.mem_inter hyp (H.div_mem h'_in h_in)\n  exact (eq_of_div_eq_one this).symm\n\n"}
{"name":"AddSubgroup.isClosed_of_discrete","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninstâœÂ³ : AddGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : T2Space G\nH : AddSubgroup G\ninstâœ : DiscreteTopology (Subtype fun x => Membership.mem H x)\nâŠ¢ IsClosed â†‘H","decl":"@[to_additive]\ninstance Subgroup.isClosed_of_discrete [T2Space G] {H : Subgroup G} [DiscreteTopology H] :\n    IsClosed (H : Set G) := by\n  obtain âŸ¨V, V_in, VHâŸ© : âˆƒ (V : Set G), V âˆˆ ğ“ (1 : G) âˆ§ V âˆ© (H : Set G) = {1} :=\n    nhds_inter_eq_singleton_of_mem_discrete H.one_mem\n  have : (fun p : G Ã— G => p.2 / p.1) â»Â¹' V âˆˆ ğ“¤ G := preimage_mem_comap V_in\n  apply isClosed_of_spaced_out this\n  intro h h_in h' h'_in\n  contrapose!\n  simp only [Set.mem_preimage, not_not]\n  rintro (hyp : h' / h âˆˆ V)\n  have : h' / h âˆˆ ({1} : Set G) := VH â–¸ Set.mem_inter hyp (H.div_mem h'_in h_in)\n  exact (eq_of_div_eq_one this).symm\n\n"}
{"name":"AddSubgroup.tendsto_coe_cofinite_of_discrete","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninstâœâ´ : AddGroup G\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : TopologicalAddGroup G\ninstâœÂ¹ : T2Space G\nH : AddSubgroup G\ninstâœ : DiscreteTopology (Subtype fun x => Membership.mem H x)\nâŠ¢ Filter.Tendsto Subtype.val Filter.cofinite (Filter.cocompact G)","decl":"@[to_additive]\nlemma Subgroup.tendsto_coe_cofinite_of_discrete [T2Space G] (H : Subgroup G) [DiscreteTopology H] :\n    Tendsto ((â†‘) : H â†’ G) cofinite (cocompact _) :=\n  IsClosed.tendsto_coe_cofinite_of_discreteTopology inferInstance inferInstance\n\n"}
{"name":"Subgroup.tendsto_coe_cofinite_of_discrete","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninstâœâ´ : Group G\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : TopologicalGroup G\ninstâœÂ¹ : T2Space G\nH : Subgroup G\ninstâœ : DiscreteTopology (Subtype fun x => Membership.mem H x)\nâŠ¢ Filter.Tendsto Subtype.val Filter.cofinite (Filter.cocompact G)","decl":"@[to_additive]\nlemma Subgroup.tendsto_coe_cofinite_of_discrete [T2Space G] (H : Subgroup G) [DiscreteTopology H] :\n    Tendsto ((â†‘) : H â†’ G) cofinite (cocompact _) :=\n  IsClosed.tendsto_coe_cofinite_of_discreteTopology inferInstance inferInstance\n\n"}
{"name":"AddMonoidHom.tendsto_coe_cofinite_of_discrete","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninstâœâ´ : AddGroup G\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : TopologicalAddGroup G\ninstâœÂ¹ : T2Space G\nH : Type u_2\ninstâœ : AddGroup H\nf : AddMonoidHom H G\nhf : Function.Injective â‡‘f\nhf' : DiscreteTopology (Subtype fun x => Membership.mem f.range x)\nâŠ¢ Filter.Tendsto (â‡‘f) Filter.cofinite (Filter.cocompact G)","decl":"@[to_additive]\nlemma MonoidHom.tendsto_coe_cofinite_of_discrete [T2Space G] {H : Type*} [Group H] {f : H â†’* G}\n    (hf : Function.Injective f) (hf' : DiscreteTopology f.range) :\n    Tendsto f cofinite (cocompact _) := by\n  replace hf : Function.Injective f.rangeRestrict := by simpa\n  exact f.range.tendsto_coe_cofinite_of_discrete.comp hf.tendsto_cofinite\n\n"}
{"name":"MonoidHom.tendsto_coe_cofinite_of_discrete","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u_1\ninstâœâ´ : Group G\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : TopologicalGroup G\ninstâœÂ¹ : T2Space G\nH : Type u_2\ninstâœ : Group H\nf : MonoidHom H G\nhf : Function.Injective â‡‘f\nhf' : DiscreteTopology (Subtype fun x => Membership.mem f.range x)\nâŠ¢ Filter.Tendsto (â‡‘f) Filter.cofinite (Filter.cocompact G)","decl":"@[to_additive]\nlemma MonoidHom.tendsto_coe_cofinite_of_discrete [T2Space G] {H : Type*} [Group H] {f : H â†’* G}\n    (hf : Function.Injective f) (hf' : DiscreteTopology f.range) :\n    Tendsto f cofinite (cocompact _) := by\n  replace hf : Function.Injective f.rangeRestrict := by simpa\n  exact f.range.tendsto_coe_cofinite_of_discrete.comp hf.tendsto_cofinite\n\n"}
{"name":"TopologicalAddGroup.tendstoUniformly_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nG : Type u_3\ninstâœÂ¹ : AddGroup G\nu : UniformSpace G\ninstâœ : TopologicalAddGroup G\nF : Î¹ â†’ Î± â†’ G\nf : Î± â†’ G\np : Filter Î¹\nhu : Eq (TopologicalAddGroup.toUniformSpace G) u\nâŠ¢ Iff (TendstoUniformly F f p) (âˆ€ (u_1 : Set G), Membership.mem (nhds 0) u_1 â†’ Filter.Eventually (fun i => âˆ€ (a : Î±), Membership.mem u_1 (HSub.hSub (F i a) (f a))) p)","decl":"@[to_additive]\ntheorem tendstoUniformly_iff (F : Î¹ â†’ Î± â†’ G) (f : Î± â†’ G) (p : Filter Î¹)\n    (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoUniformly F f p â†” âˆ€ u âˆˆ ğ“ (1 : G), âˆ€á¶  i in p, âˆ€ a, F i a / f a âˆˆ u :=\n  hu â–¸ âŸ¨fun h u hu => h _ âŸ¨u, hu, fun _ => idâŸ©,\n    fun h _ âŸ¨u, hu, hvâŸ© => mem_of_superset (h u hu) fun _ hi a => hv (hi a)âŸ©\n\n"}
{"name":"TopologicalGroup.tendstoUniformly_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nG : Type u_3\ninstâœÂ¹ : Group G\nu : UniformSpace G\ninstâœ : TopologicalGroup G\nF : Î¹ â†’ Î± â†’ G\nf : Î± â†’ G\np : Filter Î¹\nhu : Eq (TopologicalGroup.toUniformSpace G) u\nâŠ¢ Iff (TendstoUniformly F f p) (âˆ€ (u_1 : Set G), Membership.mem (nhds 1) u_1 â†’ Filter.Eventually (fun i => âˆ€ (a : Î±), Membership.mem u_1 (HDiv.hDiv (F i a) (f a))) p)","decl":"@[to_additive]\ntheorem tendstoUniformly_iff (F : Î¹ â†’ Î± â†’ G) (f : Î± â†’ G) (p : Filter Î¹)\n    (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoUniformly F f p â†” âˆ€ u âˆˆ ğ“ (1 : G), âˆ€á¶  i in p, âˆ€ a, F i a / f a âˆˆ u :=\n  hu â–¸ âŸ¨fun h u hu => h _ âŸ¨u, hu, fun _ => idâŸ©,\n    fun h _ âŸ¨u, hu, hvâŸ© => mem_of_superset (h u hu) fun _ hi a => hv (hi a)âŸ©\n\n"}
{"name":"TopologicalAddGroup.tendstoUniformlyOn_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nG : Type u_3\ninstâœÂ¹ : AddGroup G\nu : UniformSpace G\ninstâœ : TopologicalAddGroup G\nF : Î¹ â†’ Î± â†’ G\nf : Î± â†’ G\np : Filter Î¹\ns : Set Î±\nhu : Eq (TopologicalAddGroup.toUniformSpace G) u\nâŠ¢ Iff (TendstoUniformlyOn F f p s) (âˆ€ (u_1 : Set G), Membership.mem (nhds 0) u_1 â†’ Filter.Eventually (fun i => âˆ€ (a : Î±), Membership.mem s a â†’ Membership.mem u_1 (HSub.hSub (F i a) (f a))) p)","decl":"@[to_additive]\ntheorem tendstoUniformlyOn_iff (F : Î¹ â†’ Î± â†’ G) (f : Î± â†’ G) (p : Filter Î¹) (s : Set Î±)\n    (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoUniformlyOn F f p s â†” âˆ€ u âˆˆ ğ“ (1 : G), âˆ€á¶  i in p, âˆ€ a âˆˆ s, F i a / f a âˆˆ u :=\n  hu â–¸ âŸ¨fun h u hu => h _ âŸ¨u, hu, fun _ => idâŸ©,\n    fun h _ âŸ¨u, hu, hvâŸ© => mem_of_superset (h u hu) fun _ hi a ha => hv (hi a ha)âŸ©\n\n"}
{"name":"TopologicalGroup.tendstoUniformlyOn_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nG : Type u_3\ninstâœÂ¹ : Group G\nu : UniformSpace G\ninstâœ : TopologicalGroup G\nF : Î¹ â†’ Î± â†’ G\nf : Î± â†’ G\np : Filter Î¹\ns : Set Î±\nhu : Eq (TopologicalGroup.toUniformSpace G) u\nâŠ¢ Iff (TendstoUniformlyOn F f p s) (âˆ€ (u_1 : Set G), Membership.mem (nhds 1) u_1 â†’ Filter.Eventually (fun i => âˆ€ (a : Î±), Membership.mem s a â†’ Membership.mem u_1 (HDiv.hDiv (F i a) (f a))) p)","decl":"@[to_additive]\ntheorem tendstoUniformlyOn_iff (F : Î¹ â†’ Î± â†’ G) (f : Î± â†’ G) (p : Filter Î¹) (s : Set Î±)\n    (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoUniformlyOn F f p s â†” âˆ€ u âˆˆ ğ“ (1 : G), âˆ€á¶  i in p, âˆ€ a âˆˆ s, F i a / f a âˆˆ u :=\n  hu â–¸ âŸ¨fun h u hu => h _ âŸ¨u, hu, fun _ => idâŸ©,\n    fun h _ âŸ¨u, hu, hvâŸ© => mem_of_superset (h u hu) fun _ hi a ha => hv (hi a ha)âŸ©\n\n"}
{"name":"TopologicalGroup.tendstoLocallyUniformly_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nG : Type u_3\ninstâœÂ² : Group G\nu : UniformSpace G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : TopologicalSpace Î±\nF : Î¹ â†’ Î± â†’ G\nf : Î± â†’ G\np : Filter Î¹\nhu : Eq (TopologicalGroup.toUniformSpace G) u\nâŠ¢ Iff (TendstoLocallyUniformly F f p) (âˆ€ (u_1 : Set G), Membership.mem (nhds 1) u_1 â†’ âˆ€ (x : Î±), Exists fun t => And (Membership.mem (nhds x) t) (Filter.Eventually (fun i => âˆ€ (a : Î±), Membership.mem t a â†’ Membership.mem u_1 (HDiv.hDiv (F i a) (f a))) p))","decl":"@[to_additive]\ntheorem tendstoLocallyUniformly_iff [TopologicalSpace Î±] (F : Î¹ â†’ Î± â†’ G) (f : Î± â†’ G)\n    (p : Filter Î¹) (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoLocallyUniformly F f p â†”\n      âˆ€ u âˆˆ ğ“ (1 : G), âˆ€ (x : Î±), âˆƒ t âˆˆ ğ“ x, âˆ€á¶  i in p, âˆ€ a âˆˆ t, F i a / f a âˆˆ u :=\n  hu â–¸ âŸ¨fun h u hu => h _ âŸ¨u, hu, fun _ => idâŸ©, fun h _ âŸ¨u, hu, hvâŸ© x =>\n    Exists.imp (fun _ âŸ¨h, hpâŸ© => âŸ¨h, mem_of_superset hp fun _ hi a ha => hv (hi a ha)âŸ©)\n      (h u hu x)âŸ©\n\n"}
{"name":"TopologicalAddGroup.tendstoLocallyUniformly_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nG : Type u_3\ninstâœÂ² : AddGroup G\nu : UniformSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : TopologicalSpace Î±\nF : Î¹ â†’ Î± â†’ G\nf : Î± â†’ G\np : Filter Î¹\nhu : Eq (TopologicalAddGroup.toUniformSpace G) u\nâŠ¢ Iff (TendstoLocallyUniformly F f p) (âˆ€ (u_1 : Set G), Membership.mem (nhds 0) u_1 â†’ âˆ€ (x : Î±), Exists fun t => And (Membership.mem (nhds x) t) (Filter.Eventually (fun i => âˆ€ (a : Î±), Membership.mem t a â†’ Membership.mem u_1 (HSub.hSub (F i a) (f a))) p))","decl":"@[to_additive]\ntheorem tendstoLocallyUniformly_iff [TopologicalSpace Î±] (F : Î¹ â†’ Î± â†’ G) (f : Î± â†’ G)\n    (p : Filter Î¹) (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoLocallyUniformly F f p â†”\n      âˆ€ u âˆˆ ğ“ (1 : G), âˆ€ (x : Î±), âˆƒ t âˆˆ ğ“ x, âˆ€á¶  i in p, âˆ€ a âˆˆ t, F i a / f a âˆˆ u :=\n  hu â–¸ âŸ¨fun h u hu => h _ âŸ¨u, hu, fun _ => idâŸ©, fun h _ âŸ¨u, hu, hvâŸ© x =>\n    Exists.imp (fun _ âŸ¨h, hpâŸ© => âŸ¨h, mem_of_superset hp fun _ hi a ha => hv (hi a ha)âŸ©)\n      (h u hu x)âŸ©\n\n"}
{"name":"TopologicalAddGroup.tendstoLocallyUniformlyOn_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nG : Type u_3\ninstâœÂ² : AddGroup G\nu : UniformSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : TopologicalSpace Î±\nF : Î¹ â†’ Î± â†’ G\nf : Î± â†’ G\np : Filter Î¹\ns : Set Î±\nhu : Eq (TopologicalAddGroup.toUniformSpace G) u\nâŠ¢ Iff (TendstoLocallyUniformlyOn F f p s) (âˆ€ (u_1 : Set G), Membership.mem (nhds 0) u_1 â†’ âˆ€ (x : Î±), Membership.mem s x â†’ Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Filter.Eventually (fun i => âˆ€ (a : Î±), Membership.mem t a â†’ Membership.mem u_1 (HSub.hSub (F i a) (f a))) p))","decl":"@[to_additive]\ntheorem tendstoLocallyUniformlyOn_iff [TopologicalSpace Î±] (F : Î¹ â†’ Î± â†’ G) (f : Î± â†’ G)\n    (p : Filter Î¹) (s : Set Î±) (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoLocallyUniformlyOn F f p s â†”\n      âˆ€ u âˆˆ ğ“ (1 : G), âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, âˆ€á¶  i in p, âˆ€ a âˆˆ t, F i a / f a âˆˆ u :=\n  hu â–¸ âŸ¨fun h u hu => h _ âŸ¨u, hu, fun _ => idâŸ©, fun h _ âŸ¨u, hu, hvâŸ© x =>\n    (Exists.imp fun _ âŸ¨h, hpâŸ© => âŸ¨h, mem_of_superset hp fun _ hi a ha => hv (hi a ha)âŸ©) âˆ˜\n      h u hu xâŸ©\n\n"}
{"name":"TopologicalGroup.tendstoLocallyUniformlyOn_iff","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nG : Type u_3\ninstâœÂ² : Group G\nu : UniformSpace G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : TopologicalSpace Î±\nF : Î¹ â†’ Î± â†’ G\nf : Î± â†’ G\np : Filter Î¹\ns : Set Î±\nhu : Eq (TopologicalGroup.toUniformSpace G) u\nâŠ¢ Iff (TendstoLocallyUniformlyOn F f p s) (âˆ€ (u_1 : Set G), Membership.mem (nhds 1) u_1 â†’ âˆ€ (x : Î±), Membership.mem s x â†’ Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Filter.Eventually (fun i => âˆ€ (a : Î±), Membership.mem t a â†’ Membership.mem u_1 (HDiv.hDiv (F i a) (f a))) p))","decl":"@[to_additive]\ntheorem tendstoLocallyUniformlyOn_iff [TopologicalSpace Î±] (F : Î¹ â†’ Î± â†’ G) (f : Î± â†’ G)\n    (p : Filter Î¹) (s : Set Î±) (hu : TopologicalGroup.toUniformSpace G = u) :\n    TendstoLocallyUniformlyOn F f p s â†”\n      âˆ€ u âˆˆ ğ“ (1 : G), âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, âˆ€á¶  i in p, âˆ€ a âˆˆ t, F i a / f a âˆˆ u :=\n  hu â–¸ âŸ¨fun h u hu => h _ âŸ¨u, hu, fun _ => idâŸ©, fun h _ âŸ¨u, hu, hvâŸ© x =>\n    (Exists.imp fun _ âŸ¨h, hpâŸ© => âŸ¨h, mem_of_superset hp fun _ hi a ha => hv (hi a ha)âŸ©) âˆ˜\n      h u hu xâŸ©\n\n"}
{"name":"IsDenseInducing.extend_Z_bilin","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nÎ´ : Type u_4\nG : Type u_5\ninstâœÂ¹â´ : TopologicalSpace Î±\ninstâœÂ¹Â³ : AddCommGroup Î±\ninstâœÂ¹Â² : TopologicalAddGroup Î±\ninstâœÂ¹Â¹ : TopologicalSpace Î²\ninstâœÂ¹â° : AddCommGroup Î²\ninstâœâ¹ : TopologicalSpace Î³\ninstâœâ¸ : AddCommGroup Î³\ninstâœâ· : TopologicalAddGroup Î³\ninstâœâ¶ : TopologicalSpace Î´\ninstâœâµ : AddCommGroup Î´\ninstâœâ´ : UniformSpace G\ninstâœÂ³ : AddCommGroup G\ne : AddMonoidHom Î² Î±\nde : IsDenseInducing â‡‘e\nf : AddMonoidHom Î´ Î³\ndf : IsDenseInducing â‡‘f\nÏ† : AddMonoidHom Î² (AddMonoidHom Î´ G)\nhÏ† : Continuous fun p => (Ï† p.1) p.2\ninstâœÂ² : UniformAddGroup G\ninstâœÂ¹ : T0Space G\ninstâœ : CompleteSpace G\nâŠ¢ Continuous (â‹¯.extend fun p => (Ï† p.1) p.2)","decl":"/-- Bourbaki GT III.6.5 Theorem I:\nâ„¤-bilinear continuous maps from dense images into a complete Hausdorff group extend by continuity.\nNote: Bourbaki assumes that Î± and Î² are also complete Hausdorff, but this is not necessary. -/\ntheorem extend_Z_bilin : Continuous (extend (de.prodMap df) (fun p : Î² Ã— Î´ => Ï† p.1 p.2)) := by\n  refine continuous_extend_of_cauchy _ ?_\n  rintro âŸ¨xâ‚€, yâ‚€âŸ©\n  constructor\n  Â· apply NeBot.map\n    apply comap_neBot\n    intro U h\n    rcases mem_closure_iff_nhds.1 ((de.prodMap df).dense (xâ‚€, yâ‚€)) U h with âŸ¨x, x_in, âŸ¨z, z_xâŸ©âŸ©\n    exists z\n    aesop\n  Â· suffices map (fun p : (Î² Ã— Î´) Ã— Î² Ã— Î´ => (fun p : Î² Ã— Î´ => Ï† p.1 p.2) p.2 -\n      (fun p : Î² Ã— Î´ => Ï† p.1 p.2) p.1)\n        (comap (fun p : (Î² Ã— Î´) Ã— Î² Ã— Î´ => ((e p.1.1, f p.1.2), (e p.2.1, f p.2.2)))\n        (ğ“ (xâ‚€, yâ‚€) Ã—Ë¢ ğ“ (xâ‚€, yâ‚€))) â‰¤ ğ“ 0 by\n      rwa [uniformity_eq_comap_nhds_zero G, prod_map_map_eq, â† map_le_iff_le_comap, Filter.map_map,\n        prod_comap_comap_eq]\n    intro W' W'_nhd\n    have key := extend_Z_bilin_key de df hÏ† W'_nhd xâ‚€ yâ‚€\n    rcases key with âŸ¨U, U_nhd, V, V_nhd, hâŸ©\n    rw [mem_comap] at U_nhd\n    rcases U_nhd with âŸ¨U', U'_nhd, U'_subâŸ©\n    rw [mem_comap] at V_nhd\n    rcases V_nhd with âŸ¨V', V'_nhd, V'_subâŸ©\n    rw [mem_map, mem_comap, nhds_prod_eq]\n    exists (U' Ã—Ë¢ V') Ã—Ë¢ U' Ã—Ë¢ V'\n    rw [mem_prod_same_iff]\n    simp only [exists_prop]\n    constructor\n    Â· have := prod_mem_prod U'_nhd V'_nhd\n      tauto\n    Â· intro p h'\n      simp only [Set.mem_preimage, Set.prod_mk_mem_set_prod_eq] at h'\n      rcases p with âŸ¨âŸ¨x, yâŸ©, âŸ¨x', y'âŸ©âŸ©\n      apply h <;> tauto\n\n"}
{"name":"QuotientAddGroup.completeSpace'","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u\ninstâœâµ : AddGroup G\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : TopologicalAddGroup G\ninstâœÂ² : FirstCountableTopology G\nN : AddSubgroup G\ninstâœÂ¹ : N.Normal\ninstâœ : CompleteSpace G\nâŠ¢ CompleteSpace (HasQuotient.Quotient G N)","decl":"open Classical in\n/-- The quotient `G â§¸ N` of a complete first countable topological group `G` by a normal subgroup\nis itself complete. [N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nBecause a topological group is not equipped with a `UniformSpace` instance by default, we must\nexplicitly provide it in order to consider completeness. See `QuotientGroup.completeSpace` for a\nversion in which `G` is already equipped with a uniform structure. -/\n@[to_additive \"The quotient `G â§¸ N` of a complete first countable topological additive group\n`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by\nsubspaces are complete. [N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nBecause an additive topological group is not equipped with a `UniformSpace` instance by default,\nwe must explicitly provide it in order to consider completeness. See\n`QuotientAddGroup.completeSpace` for a version in which `G` is already equipped with a uniform\nstructure.\"]\ninstance QuotientGroup.completeSpace' (G : Type u) [Group G] [TopologicalSpace G]\n    [TopologicalGroup G] [FirstCountableTopology G] (N : Subgroup G) [N.Normal]\n    [@CompleteSpace G (TopologicalGroup.toUniformSpace G)] :\n    @CompleteSpace (G â§¸ N) (TopologicalGroup.toUniformSpace (G â§¸ N)) := by\n  /- Since `G â§¸ N` is a topological group it is a uniform space, and since `G` is first countable\n    the uniformities of both `G` and `G â§¸ N` are countably generated. Moreover, we may choose a\n    sequential antitone neighborhood basis `u` for `ğ“ (1 : G)` so that `(u (n + 1)) ^ 2 âŠ† u n`, and\n    this descends to an antitone neighborhood basis `v` for `ğ“ (1 : G â§¸ N)`. Since `ğ“¤ (G â§¸ N)` is\n    countably generated, it suffices to show any Cauchy sequence `x` converges. -/\n  letI : UniformSpace (G â§¸ N) := TopologicalGroup.toUniformSpace (G â§¸ N)\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  haveI : (ğ“¤ (G â§¸ N)).IsCountablyGenerated := comap.isCountablyGenerated _ _\n  obtain âŸ¨u, hu, u_mulâŸ© := TopologicalGroup.exists_antitone_basis_nhds_one G\n  obtain âŸ¨hv, v_antiâŸ© := hu.map ((â†‘) : G â†’ G â§¸ N)\n  rw [â† QuotientGroup.nhds_eq N 1, QuotientGroup.mk_one] at hv\n  refine UniformSpace.complete_of_cauchySeq_tendsto fun x hx => ?_\n  /- Given `n : â„•`, for sufficiently large `a b : â„•`, given any lift of `x b`, we can find a lift\n    of `x a` such that the quotient of the lifts lies in `u n`. -/\n  have keyâ‚€ : âˆ€ i j : â„•, âˆƒ M : â„•, j < M âˆ§ âˆ€ a b : â„•, M â‰¤ a â†’ M â‰¤ b â†’\n      âˆ€ g : G, x b = g â†’ âˆƒ g' : G, g / g' âˆˆ u i âˆ§ x a = g' := by\n    have hğ“¤GN : (ğ“¤ (G â§¸ N)).HasBasis (fun _ â†¦ True) fun i â†¦ { x | x.snd / x.fst âˆˆ (â†‘) '' u i } := by\n      simpa [uniformity_eq_comap_nhds_one'] using hv.comap _\n    rw [hğ“¤GN.cauchySeq_iff] at hx\n    simp only [mem_setOf_eq, forall_true_left, mem_image] at hx\n    intro i j\n    rcases hx i with âŸ¨M, hMâŸ©\n    refine âŸ¨max j M + 1, (le_max_left _ _).trans_lt (lt_add_one _), fun a b ha hb g hg => ?_âŸ©\n    obtain âŸ¨y, y_mem, hyâŸ© :=\n      hM a (((le_max_right j _).trans (lt_add_one _).le).trans ha) b\n        (((le_max_right j _).trans (lt_add_one _).le).trans hb)\n    refine\n      âŸ¨yâ»Â¹ * g, by\n        simpa only [div_eq_mul_inv, mul_inv_rev, inv_inv, mul_inv_cancel_left] using y_mem, ?_âŸ©\n    rw [QuotientGroup.mk_mul, QuotientGroup.mk_inv, hy, hg, inv_div, div_mul_cancel]\n  /- Inductively construct a subsequence `Ï† : â„• â†’ â„•` using `keyâ‚€` so that if `a b : â„•` exceed\n    `Ï† (n + 1)`, then we may find lifts whose quotients lie within `u n`. -/\n  set Ï† : â„• â†’ â„• := fun n => Nat.recOn n (choose <| keyâ‚€ 0 0) fun k yk => choose <| keyâ‚€ (k + 1) yk\n  have hÏ† :\n    âˆ€ n : â„•,\n      Ï† n < Ï† (n + 1) âˆ§\n        âˆ€ a b : â„•,\n          Ï† (n + 1) â‰¤ a â†’\n            Ï† (n + 1) â‰¤ b â†’ âˆ€ g : G, x b = g â†’ âˆƒ g' : G, g / g' âˆˆ u (n + 1) âˆ§ x a = g' :=\n    fun n => choose_spec (keyâ‚€ (n + 1) (Ï† n))\n  /- Inductively construct a sequence `x' n : G` of lifts of `x (Ï† (n + 1))` such that quotients of\n    successive terms lie in `x' n / x' (n + 1) âˆˆ u (n + 1)`. We actually need the proofs that each\n    term is a lift to construct the next term, so we use a Î£-type. -/\n  set x' : âˆ€ n, PSigma fun g : G => x (Ï† (n + 1)) = g := fun n =>\n    Nat.recOn n\n      âŸ¨choose (QuotientGroup.mk_surjective (x (Ï† 1))),\n        (choose_spec (QuotientGroup.mk_surjective (x (Ï† 1)))).symmâŸ©\n      fun k hk =>\n      âŸ¨choose <| (hÏ† k).2 _ _ (hÏ† (k + 1)).1.le le_rfl hk.fst hk.snd,\n        (choose_spec <| (hÏ† k).2 _ _ (hÏ† (k + 1)).1.le le_rfl hk.fst hk.snd).2âŸ©\n  have hx' : âˆ€ n : â„•, (x' n).fst / (x' (n + 1)).fst âˆˆ u (n + 1) := fun n =>\n    (choose_spec <| (hÏ† n).2 _ _ (hÏ† (n + 1)).1.le le_rfl (x' n).fst (x' n).snd).1\n  /- The sequence `x'` is Cauchy. This is where we exploit the condition on `u`. The key idea\n    is to show by decreasing induction that `x' m / x' n âˆˆ u m` if `m â‰¤ n`. -/\n  have x'_cauchy : CauchySeq fun n => (x' n).fst := by\n    have hğ“¤G : (ğ“¤ G).HasBasis (fun _ => True) fun i => { x | x.snd / x.fst âˆˆ u i } := by\n      simpa [uniformity_eq_comap_nhds_one'] using hu.toHasBasis.comap _\n    rw [hğ“¤G.cauchySeq_iff']\n    simp only [mem_setOf_eq, forall_true_left]\n    exact fun m =>\n      âŸ¨m, fun n hmn =>\n        Nat.decreasingInduction'\n          (fun k _ _ hk => u_mul k âŸ¨_, hx' k, _, hk, div_mul_div_cancel _ _ _âŸ©) hmn\n          (by simpa only [div_self'] using mem_of_mem_nhds (hu.mem _))âŸ©\n  /- Since `G` is complete, `x'` converges to some `xâ‚€`, and so the image of this sequence under\n    the quotient map converges to `â†‘xâ‚€`. The image of `x'` is a convergent subsequence of `x`, and\n    since `x` is Cauchy, this implies it converges. -/\n  rcases cauchySeq_tendsto_of_complete x'_cauchy with âŸ¨xâ‚€, hxâ‚€âŸ©\n  refine\n    âŸ¨â†‘xâ‚€,\n      tendsto_nhds_of_cauchySeq_of_subseq hx\n        (strictMono_nat_of_lt_succ fun n => (hÏ† (n + 1)).1).tendsto_atTop ?_âŸ©\n  convert ((continuous_coinduced_rng : Continuous ((â†‘) : G â†’ G â§¸ N)).tendsto xâ‚€).comp hxâ‚€\n  exact funext fun n => (x' n).snd\n\n"}
{"name":"QuotientGroup.completeSpace'","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u\ninstâœâµ : Group G\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : TopologicalGroup G\ninstâœÂ² : FirstCountableTopology G\nN : Subgroup G\ninstâœÂ¹ : N.Normal\ninstâœ : CompleteSpace G\nâŠ¢ CompleteSpace (HasQuotient.Quotient G N)","decl":"open Classical in\n/-- The quotient `G â§¸ N` of a complete first countable topological group `G` by a normal subgroup\nis itself complete. [N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nBecause a topological group is not equipped with a `UniformSpace` instance by default, we must\nexplicitly provide it in order to consider completeness. See `QuotientGroup.completeSpace` for a\nversion in which `G` is already equipped with a uniform structure. -/\n@[to_additive \"The quotient `G â§¸ N` of a complete first countable topological additive group\n`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by\nsubspaces are complete. [N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nBecause an additive topological group is not equipped with a `UniformSpace` instance by default,\nwe must explicitly provide it in order to consider completeness. See\n`QuotientAddGroup.completeSpace` for a version in which `G` is already equipped with a uniform\nstructure.\"]\ninstance QuotientGroup.completeSpace' (G : Type u) [Group G] [TopologicalSpace G]\n    [TopologicalGroup G] [FirstCountableTopology G] (N : Subgroup G) [N.Normal]\n    [@CompleteSpace G (TopologicalGroup.toUniformSpace G)] :\n    @CompleteSpace (G â§¸ N) (TopologicalGroup.toUniformSpace (G â§¸ N)) := by\n  /- Since `G â§¸ N` is a topological group it is a uniform space, and since `G` is first countable\n    the uniformities of both `G` and `G â§¸ N` are countably generated. Moreover, we may choose a\n    sequential antitone neighborhood basis `u` for `ğ“ (1 : G)` so that `(u (n + 1)) ^ 2 âŠ† u n`, and\n    this descends to an antitone neighborhood basis `v` for `ğ“ (1 : G â§¸ N)`. Since `ğ“¤ (G â§¸ N)` is\n    countably generated, it suffices to show any Cauchy sequence `x` converges. -/\n  letI : UniformSpace (G â§¸ N) := TopologicalGroup.toUniformSpace (G â§¸ N)\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  haveI : (ğ“¤ (G â§¸ N)).IsCountablyGenerated := comap.isCountablyGenerated _ _\n  obtain âŸ¨u, hu, u_mulâŸ© := TopologicalGroup.exists_antitone_basis_nhds_one G\n  obtain âŸ¨hv, v_antiâŸ© := hu.map ((â†‘) : G â†’ G â§¸ N)\n  rw [â† QuotientGroup.nhds_eq N 1, QuotientGroup.mk_one] at hv\n  refine UniformSpace.complete_of_cauchySeq_tendsto fun x hx => ?_\n  /- Given `n : â„•`, for sufficiently large `a b : â„•`, given any lift of `x b`, we can find a lift\n    of `x a` such that the quotient of the lifts lies in `u n`. -/\n  have keyâ‚€ : âˆ€ i j : â„•, âˆƒ M : â„•, j < M âˆ§ âˆ€ a b : â„•, M â‰¤ a â†’ M â‰¤ b â†’\n      âˆ€ g : G, x b = g â†’ âˆƒ g' : G, g / g' âˆˆ u i âˆ§ x a = g' := by\n    have hğ“¤GN : (ğ“¤ (G â§¸ N)).HasBasis (fun _ â†¦ True) fun i â†¦ { x | x.snd / x.fst âˆˆ (â†‘) '' u i } := by\n      simpa [uniformity_eq_comap_nhds_one'] using hv.comap _\n    rw [hğ“¤GN.cauchySeq_iff] at hx\n    simp only [mem_setOf_eq, forall_true_left, mem_image] at hx\n    intro i j\n    rcases hx i with âŸ¨M, hMâŸ©\n    refine âŸ¨max j M + 1, (le_max_left _ _).trans_lt (lt_add_one _), fun a b ha hb g hg => ?_âŸ©\n    obtain âŸ¨y, y_mem, hyâŸ© :=\n      hM a (((le_max_right j _).trans (lt_add_one _).le).trans ha) b\n        (((le_max_right j _).trans (lt_add_one _).le).trans hb)\n    refine\n      âŸ¨yâ»Â¹ * g, by\n        simpa only [div_eq_mul_inv, mul_inv_rev, inv_inv, mul_inv_cancel_left] using y_mem, ?_âŸ©\n    rw [QuotientGroup.mk_mul, QuotientGroup.mk_inv, hy, hg, inv_div, div_mul_cancel]\n  /- Inductively construct a subsequence `Ï† : â„• â†’ â„•` using `keyâ‚€` so that if `a b : â„•` exceed\n    `Ï† (n + 1)`, then we may find lifts whose quotients lie within `u n`. -/\n  set Ï† : â„• â†’ â„• := fun n => Nat.recOn n (choose <| keyâ‚€ 0 0) fun k yk => choose <| keyâ‚€ (k + 1) yk\n  have hÏ† :\n    âˆ€ n : â„•,\n      Ï† n < Ï† (n + 1) âˆ§\n        âˆ€ a b : â„•,\n          Ï† (n + 1) â‰¤ a â†’\n            Ï† (n + 1) â‰¤ b â†’ âˆ€ g : G, x b = g â†’ âˆƒ g' : G, g / g' âˆˆ u (n + 1) âˆ§ x a = g' :=\n    fun n => choose_spec (keyâ‚€ (n + 1) (Ï† n))\n  /- Inductively construct a sequence `x' n : G` of lifts of `x (Ï† (n + 1))` such that quotients of\n    successive terms lie in `x' n / x' (n + 1) âˆˆ u (n + 1)`. We actually need the proofs that each\n    term is a lift to construct the next term, so we use a Î£-type. -/\n  set x' : âˆ€ n, PSigma fun g : G => x (Ï† (n + 1)) = g := fun n =>\n    Nat.recOn n\n      âŸ¨choose (QuotientGroup.mk_surjective (x (Ï† 1))),\n        (choose_spec (QuotientGroup.mk_surjective (x (Ï† 1)))).symmâŸ©\n      fun k hk =>\n      âŸ¨choose <| (hÏ† k).2 _ _ (hÏ† (k + 1)).1.le le_rfl hk.fst hk.snd,\n        (choose_spec <| (hÏ† k).2 _ _ (hÏ† (k + 1)).1.le le_rfl hk.fst hk.snd).2âŸ©\n  have hx' : âˆ€ n : â„•, (x' n).fst / (x' (n + 1)).fst âˆˆ u (n + 1) := fun n =>\n    (choose_spec <| (hÏ† n).2 _ _ (hÏ† (n + 1)).1.le le_rfl (x' n).fst (x' n).snd).1\n  /- The sequence `x'` is Cauchy. This is where we exploit the condition on `u`. The key idea\n    is to show by decreasing induction that `x' m / x' n âˆˆ u m` if `m â‰¤ n`. -/\n  have x'_cauchy : CauchySeq fun n => (x' n).fst := by\n    have hğ“¤G : (ğ“¤ G).HasBasis (fun _ => True) fun i => { x | x.snd / x.fst âˆˆ u i } := by\n      simpa [uniformity_eq_comap_nhds_one'] using hu.toHasBasis.comap _\n    rw [hğ“¤G.cauchySeq_iff']\n    simp only [mem_setOf_eq, forall_true_left]\n    exact fun m =>\n      âŸ¨m, fun n hmn =>\n        Nat.decreasingInduction'\n          (fun k _ _ hk => u_mul k âŸ¨_, hx' k, _, hk, div_mul_div_cancel _ _ _âŸ©) hmn\n          (by simpa only [div_self'] using mem_of_mem_nhds (hu.mem _))âŸ©\n  /- Since `G` is complete, `x'` converges to some `xâ‚€`, and so the image of this sequence under\n    the quotient map converges to `â†‘xâ‚€`. The image of `x'` is a convergent subsequence of `x`, and\n    since `x` is Cauchy, this implies it converges. -/\n  rcases cauchySeq_tendsto_of_complete x'_cauchy with âŸ¨xâ‚€, hxâ‚€âŸ©\n  refine\n    âŸ¨â†‘xâ‚€,\n      tendsto_nhds_of_cauchySeq_of_subseq hx\n        (strictMono_nat_of_lt_succ fun n => (hÏ† (n + 1)).1).tendsto_atTop ?_âŸ©\n  convert ((continuous_coinduced_rng : Continuous ((â†‘) : G â†’ G â§¸ N)).tendsto xâ‚€).comp hxâ‚€\n  exact funext fun n => (x' n).snd\n\n"}
{"name":"QuotientAddGroup.completeSpace","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u\ninstâœÂ³ : AddGroup G\nus : UniformSpace G\ninstâœÂ² : UniformAddGroup G\ninstâœÂ¹ : FirstCountableTopology G\nN : AddSubgroup G\ninstâœ : N.Normal\nhG : CompleteSpace G\nâŠ¢ CompleteSpace (HasQuotient.Quotient G N)","decl":"/-- The quotient `G â§¸ N` of a complete first countable uniform group `G` by a normal subgroup\nis itself complete. In contrast to `QuotientGroup.completeSpace'`, in this version `G` is\nalready equipped with a uniform structure.\n[N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nEven though `G` is equipped with a uniform structure, the quotient `G â§¸ N` does not inherit a\nuniform structure, so it is still provided manually via `TopologicalGroup.toUniformSpace`.\nIn the most common use cases, this coincides (definitionally) with the uniform structure on the\nquotient obtained via other means. -/\n@[to_additive \"The quotient `G â§¸ N` of a complete first countable uniform additive group\n`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by\nsubspaces are complete. In contrast to `QuotientAddGroup.completeSpace'`, in this version\n`G` is already equipped with a uniform structure.\n[N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nEven though `G` is equipped with a uniform structure, the quotient `G â§¸ N` does not inherit a\nuniform structure, so it is still provided manually via `TopologicalAddGroup.toUniformSpace`.\nIn the most common use case â”€ quotients of normed additive commutative groups by subgroups â”€\nsignificant care was taken so that the uniform structure inherent in that setting coincides\n(definitionally) with the uniform structure provided here.\"]\ninstance QuotientGroup.completeSpace (G : Type u) [Group G] [us : UniformSpace G] [UniformGroup G]\n    [FirstCountableTopology G] (N : Subgroup G) [N.Normal] [hG : CompleteSpace G] :\n    @CompleteSpace (G â§¸ N) (TopologicalGroup.toUniformSpace (G â§¸ N)) := by\n  rw [â† @UniformGroup.toUniformSpace_eq _ us _ _] at hG\n  infer_instance\n\n"}
{"name":"QuotientGroup.completeSpace","module":"Mathlib.Topology.Algebra.UniformGroup.Basic","initialProofState":"G : Type u\ninstâœÂ³ : Group G\nus : UniformSpace G\ninstâœÂ² : UniformGroup G\ninstâœÂ¹ : FirstCountableTopology G\nN : Subgroup G\ninstâœ : N.Normal\nhG : CompleteSpace G\nâŠ¢ CompleteSpace (HasQuotient.Quotient G N)","decl":"/-- The quotient `G â§¸ N` of a complete first countable uniform group `G` by a normal subgroup\nis itself complete. In contrast to `QuotientGroup.completeSpace'`, in this version `G` is\nalready equipped with a uniform structure.\n[N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nEven though `G` is equipped with a uniform structure, the quotient `G â§¸ N` does not inherit a\nuniform structure, so it is still provided manually via `TopologicalGroup.toUniformSpace`.\nIn the most common use cases, this coincides (definitionally) with the uniform structure on the\nquotient obtained via other means. -/\n@[to_additive \"The quotient `G â§¸ N` of a complete first countable uniform additive group\n`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by\nsubspaces are complete. In contrast to `QuotientAddGroup.completeSpace'`, in this version\n`G` is already equipped with a uniform structure.\n[N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nEven though `G` is equipped with a uniform structure, the quotient `G â§¸ N` does not inherit a\nuniform structure, so it is still provided manually via `TopologicalAddGroup.toUniformSpace`.\nIn the most common use case â”€ quotients of normed additive commutative groups by subgroups â”€\nsignificant care was taken so that the uniform structure inherent in that setting coincides\n(definitionally) with the uniform structure provided here.\"]\ninstance QuotientGroup.completeSpace (G : Type u) [Group G] [us : UniformSpace G] [UniformGroup G]\n    [FirstCountableTopology G] (N : Subgroup G) [N.Normal] [hG : CompleteSpace G] :\n    @CompleteSpace (G â§¸ N) (TopologicalGroup.toUniformSpace (G â§¸ N)) := by\n  rw [â† @UniformGroup.toUniformSpace_eq _ us _ _] at hG\n  infer_instance\n\n"}
