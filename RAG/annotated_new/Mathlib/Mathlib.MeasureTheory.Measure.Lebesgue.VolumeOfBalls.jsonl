{"name":"MeasureTheory.measure_unitBall_eq_integral_div_gamma","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"E : Type u_1\np : Real\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : FiniteDimensional Real E\ninst✝² : MeasurableSpace E\ninst✝¹ : BorelSpace E\nμ : MeasureTheory.Measure E\ninst✝ : μ.IsAddHaarMeasure\nhp : LT.lt 0 p\n⊢ Eq (μ (Metric.ball 0 1)) (ENNReal.ofReal (HDiv.hDiv (MeasureTheory.integral μ fun x => Real.exp (Neg.neg (HPow.hPow (Norm.norm x) p))) (Real.Gamma (HAdd.hAdd (HDiv.hDiv (↑(Module.finrank Real E)) p) 1))))","decl":"theorem MeasureTheory.measure_unitBall_eq_integral_div_gamma {E : Type*} {p : ℝ}\n    [NormedAddCommGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E] [MeasurableSpace E]\n    [BorelSpace E] (μ : Measure E) [IsAddHaarMeasure μ] (hp : 0 < p) :\n    μ (Metric.ball 0 1) =\n      .ofReal ((∫ (x : E), Real.exp (- ‖x‖ ^ p) ∂μ) / Real.Gamma (finrank ℝ E / p + 1)) := by\n  obtain hE | hE := subsingleton_or_nontrivial E\n  · rw [(Metric.nonempty_ball.mpr zero_lt_one).eq_zero, ← setIntegral_univ,\n      Set.univ_nonempty.eq_zero, integral_singleton, finrank_zero_of_subsingleton, Nat.cast_zero,\n      zero_div, zero_add, Real.Gamma_one, div_one, norm_zero, Real.zero_rpow hp.ne', neg_zero,\n      Real.exp_zero, smul_eq_mul, mul_one, ofReal_toReal (measure_ne_top μ {0})]\n  · have : (0 : ℝ) < finrank ℝ E := Nat.cast_pos.mpr finrank_pos\n    have : ((∫ y in Set.Ioi (0 : ℝ), y ^ (finrank ℝ E - 1) • Real.exp (-y ^ p)) /\n        Real.Gamma ((finrank ℝ E) / p + 1)) * (finrank ℝ E) = 1 := by\n      simp_rw [← Real.rpow_natCast _ (finrank ℝ E - 1), smul_eq_mul, Nat.cast_sub finrank_pos,\n        Nat.cast_one]\n      rw [integral_rpow_mul_exp_neg_rpow hp (by linarith), sub_add_cancel,\n        Real.Gamma_add_one (ne_of_gt (by positivity))]\n      field_simp; ring\n    rw [integral_fun_norm_addHaar μ (fun x => Real.exp (- x ^ p)), nsmul_eq_mul, smul_eq_mul,\n      mul_div_assoc, mul_div_assoc, mul_comm, mul_assoc, this, mul_one, ofReal_toReal]\n    exact ne_of_lt measure_ball_lt_top\n\n"}
{"name":"MeasureTheory.measure_lt_one_eq_integral_div_gamma","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"E : Type u_1\ninst✝⁷ : AddCommGroup E\ninst✝⁶ : Module Real E\ninst✝⁵ : FiniteDimensional Real E\nmE : MeasurableSpace E\ntE : TopologicalSpace E\ninst✝⁴ : TopologicalAddGroup E\ninst✝³ : BorelSpace E\ninst✝² : T2Space E\ninst✝¹ : ContinuousSMul Real E\nμ : MeasureTheory.Measure E\ninst✝ : μ.IsAddHaarMeasure\ng : E → Real\nh1 : Eq (g 0) 0\nh2 : ∀ (x : E), Eq (g (Neg.neg x)) (g x)\nh3 : ∀ (x y : E), LE.le (g (HAdd.hAdd x y)) (HAdd.hAdd (g x) (g y))\nh4 : ∀ {x : E}, Eq (g x) 0 → Eq x 0\nh5 : ∀ (r : Real) (x : E), LE.le (g (HSMul.hSMul r x)) (HMul.hMul (abs r) (g x))\np : Real\nhp : LT.lt 0 p\n⊢ Eq (μ (setOf fun x => LT.lt (g x) 1)) (ENNReal.ofReal (HDiv.hDiv (MeasureTheory.integral μ fun x => Real.exp (Neg.neg (HPow.hPow (g x) p))) (Real.Gamma (HAdd.hAdd (HDiv.hDiv (↑(Module.finrank Real E)) p) 1))))","decl":"theorem MeasureTheory.measure_lt_one_eq_integral_div_gamma {p : ℝ} (hp : 0 < p) :\n    μ {x : E | g x < 1} =\n      .ofReal ((∫ (x : E), Real.exp (- (g x) ^ p) ∂μ) / Real.Gamma (finrank ℝ E / p + 1)) := by\n  -- We copy `E` to a new type `F` on which we will put the norm defined by `g`\n  letI F : Type _ := E\n  letI : NormedAddCommGroup F :=\n  { norm := g\n    dist := fun x y => g (x - y)\n    dist_self := by simp only [_root_.sub_self, h1, forall_const]\n    dist_comm := fun _ _ => by dsimp [dist]; rw [← h2, neg_sub]\n    dist_triangle := fun x y z => by convert h3 (x - y) (y - z) using 1; simp [F]\n    edist := fun x y => .ofReal (g (x - y))\n    edist_dist := fun _ _ => rfl\n    eq_of_dist_eq_zero := by convert fun _ _ h => eq_of_sub_eq_zero (h4 h) }\n  letI : NormedSpace ℝ F :=\n  { norm_smul_le := fun _ _ ↦ h5 _ _ }\n  -- We put the new topology on F\n  letI : TopologicalSpace F := UniformSpace.toTopologicalSpace\n  letI : MeasurableSpace F := borel F\n  have : BorelSpace F := { measurable_eq := rfl }\n  -- The map between `E` and `F` as a continuous linear equivalence\n  let φ := @LinearEquiv.toContinuousLinearEquiv ℝ _ E _ _ tE _ _ F _ _ _ _ _ _ _ _ _\n    (LinearEquiv.refl ℝ E : E ≃ₗ[ℝ] F)\n  -- The measure `ν` is the measure on `F` defined by `μ`\n  -- Since we have two different topologies, it is necessary to specify the topology of E\n  let ν : Measure F := @Measure.map E F mE _ φ μ\n  have : IsAddHaarMeasure ν :=\n    @ContinuousLinearEquiv.isAddHaarMeasure_map E F ℝ ℝ _ _ _ _ _ _ tE _ _ _ _ _ _ _ mE _ _ _ φ μ _\n  convert (measure_unitBall_eq_integral_div_gamma ν hp) using 1\n  · rw [@Measure.map_apply E F mE _ μ φ _ _ measurableSet_ball]\n    · congr!\n      simp_rw [Metric.ball, dist_zero_right]\n      rfl\n    · refine @Continuous.measurable E F tE mE _ _ _ _ φ ?_\n      exact @ContinuousLinearEquiv.continuous ℝ ℝ _ _ _ _ _ _ E tE _ F _ _ _ _ φ\n  · -- The map between `E` and `F` as a measurable equivalence\n    let ψ := @Homeomorph.toMeasurableEquiv E F tE mE _ _ _ _\n      (@ContinuousLinearEquiv.toHomeomorph ℝ ℝ _ _ _ _ _ _ E tE _ F _ _ _ _ φ)\n    -- The map `ψ` is measure preserving by construction\n    have : @MeasurePreserving E F mE _ ψ μ ν :=\n      @Measurable.measurePreserving E F mE _ ψ (@MeasurableEquiv.measurable E F mE _ ψ) _\n    rw [← this.integral_comp']\n    rfl\n\n"}
{"name":"MeasureTheory.measure_le_eq_lt","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"E : Type u_1\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Real E\ninst✝⁶ : FiniteDimensional Real E\nmE : MeasurableSpace E\ntE : TopologicalSpace E\ninst✝⁵ : TopologicalAddGroup E\ninst✝⁴ : BorelSpace E\ninst✝³ : T2Space E\ninst✝² : ContinuousSMul Real E\nμ : MeasureTheory.Measure E\ninst✝¹ : μ.IsAddHaarMeasure\ng : E → Real\nh1 : Eq (g 0) 0\nh2 : ∀ (x : E), Eq (g (Neg.neg x)) (g x)\nh3 : ∀ (x y : E), LE.le (g (HAdd.hAdd x y)) (HAdd.hAdd (g x) (g y))\nh4 : ∀ {x : E}, Eq (g x) 0 → Eq x 0\nh5 : ∀ (r : Real) (x : E), LE.le (g (HSMul.hSMul r x)) (HMul.hMul (abs r) (g x))\ninst✝ : Nontrivial E\nr : Real\n⊢ Eq (μ (setOf fun x => LE.le (g x) r)) (μ (setOf fun x => LT.lt (g x) r))","decl":"theorem MeasureTheory.measure_le_eq_lt [Nontrivial E] (r : ℝ) :\n    μ {x : E | g x ≤ r} = μ {x : E | g x < r} := by\n  -- We copy `E` to a new type `F` on which we will put the norm defined by `g`\n  letI F : Type _ := E\n  letI : NormedAddCommGroup F :=\n  { norm := g\n    dist := fun x y => g (x - y)\n    dist_self := by simp only [_root_.sub_self, h1, forall_const]\n    dist_comm := fun _ _ => by dsimp [dist]; rw [← h2, neg_sub]\n    dist_triangle := fun x y z => by convert h3 (x - y) (y - z) using 1; simp [F]\n    edist := fun x y => .ofReal (g (x - y))\n    edist_dist := fun _ _ => rfl\n    eq_of_dist_eq_zero := by convert fun _ _ h => eq_of_sub_eq_zero (h4 h) }\n  letI : NormedSpace ℝ F :=\n  { norm_smul_le := fun _ _ ↦ h5 _ _ }\n  -- We put the new topology on F\n  letI : TopologicalSpace F := UniformSpace.toTopologicalSpace\n  letI : MeasurableSpace F := borel F\n  have : BorelSpace F := { measurable_eq := rfl }\n  -- The map between `E` and `F` as a continuous linear equivalence\n  let φ := @LinearEquiv.toContinuousLinearEquiv ℝ _ E _ _ tE _ _ F _ _ _ _ _ _ _ _ _\n    (LinearEquiv.refl ℝ E : E ≃ₗ[ℝ] F)\n  -- The measure `ν` is the measure on `F` defined by `μ`\n  -- Since we have two different topologies, it is necessary to specify the topology of E\n  let ν : Measure F := @Measure.map E F mE _ φ μ\n  have : IsAddHaarMeasure ν :=\n    @ContinuousLinearEquiv.isAddHaarMeasure_map E F ℝ ℝ _ _ _ _ _ _ tE _ _ _ _ _ _ _ mE _ _ _ φ μ _\n  convert addHaar_closedBall_eq_addHaar_ball ν 0 r using 1\n  · rw [@Measure.map_apply E F mE _ μ φ _ _ measurableSet_closedBall]\n    · congr!\n      simp_rw [Metric.closedBall, dist_zero_right]\n      rfl\n    · refine @Continuous.measurable E F tE mE _ _ _ _ φ ?_\n      exact @ContinuousLinearEquiv.continuous ℝ ℝ _ _ _ _ _ _ E tE _ F _ _ _ _ φ\n  · rw [@Measure.map_apply E F mE _ μ φ _ _ measurableSet_ball]\n    · congr!\n      simp_rw [Metric.ball, dist_zero_right]\n      rfl\n    · refine @Continuous.measurable E F tE mE _ _ _ _ φ ?_\n      exact @ContinuousLinearEquiv.continuous ℝ ℝ _ _ _ _ _ _ E tE _ F _ _ _ _ φ\n\n"}
{"name":"MeasureTheory.volume_sum_rpow_lt_one","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\np : Real\nhp : LE.le 1 p\n⊢ Eq (MeasureTheory.MeasureSpace.volume (setOf fun x => LT.lt (Finset.univ.sum fun i => HPow.hPow (abs (x i)) p) 1)) (ENNReal.ofReal (HDiv.hDiv (HPow.hPow (HMul.hMul 2 (Real.Gamma (HAdd.hAdd (HDiv.hDiv 1 p) 1))) (Fintype.card ι)) (Real.Gamma (HAdd.hAdd (HDiv.hDiv (↑(Fintype.card ι)) p) 1))))","decl":"theorem MeasureTheory.volume_sum_rpow_lt_one (hp : 1 ≤ p) :\n    volume {x : ι → ℝ | ∑ i, |x i| ^ p < 1} =\n      .ofReal ((2 * Gamma (1 / p + 1)) ^ card ι / Gamma (card ι / p + 1)) := by\n  have h₁ : 0 < p := by linarith\n  have h₂ : ∀ x : ι → ℝ, 0 ≤ ∑ i, |x i| ^ p := by\n    refine fun _ => Finset.sum_nonneg' ?_\n    exact fun i => (fun _ => rpow_nonneg (abs_nonneg _) _) _\n  -- We collect facts about `Lp` norms that will be used in `measure_lt_one_eq_integral_div_gamma`\n  have eq_norm := fun x : ι → ℝ => (PiLp.norm_eq_sum (p := .ofReal p) (f := x)\n    ((toReal_ofReal (le_of_lt h₁)).symm ▸ h₁))\n  simp_rw [toReal_ofReal (le_of_lt h₁), Real.norm_eq_abs] at eq_norm\n  have : Fact (1 ≤ ENNReal.ofReal p) := fact_iff.mpr (ofReal_one ▸ (ofReal_le_ofReal hp))\n  have nm_zero := norm_zero (E := PiLp (.ofReal p) (fun _ : ι => ℝ))\n  have eq_zero := fun x : ι → ℝ => norm_eq_zero (E := PiLp (.ofReal p) (fun _ : ι => ℝ)) (a := x)\n  have nm_neg := fun x : ι → ℝ => norm_neg (E := PiLp (.ofReal p) (fun _ : ι => ℝ)) x\n  have nm_add := fun x y : ι → ℝ => norm_add_le (E := PiLp (.ofReal p) (fun _ : ι => ℝ)) x y\n  simp_rw [eq_norm] at eq_zero nm_zero nm_neg nm_add\n  have nm_smul := fun (r : ℝ) (x : ι → ℝ) =>\n    norm_smul_le (β := PiLp (.ofReal p) (fun _ : ι => ℝ)) r x\n  simp_rw [eq_norm, norm_eq_abs] at nm_smul\n  -- We use `measure_lt_one_eq_integral_div_gamma` with `g` equals to the norm `L_p`\n  convert (measure_lt_one_eq_integral_div_gamma (volume : Measure (ι → ℝ))\n    (g := fun x => (∑ i, |x i| ^ p) ^ (1 / p)) nm_zero nm_neg nm_add (eq_zero _).mp\n    (fun r x => nm_smul r x) (by linarith : 0 < p)) using 4\n  · rw [rpow_lt_one_iff' _ (one_div_pos.mpr h₁)]\n    exact Finset.sum_nonneg' (fun _ => rpow_nonneg (abs_nonneg _) _)\n  · simp_rw [← rpow_mul (h₂ _), div_mul_cancel₀ _ (ne_of_gt h₁), Real.rpow_one,\n      ← Finset.sum_neg_distrib, exp_sum]\n    rw [integral_fintype_prod_eq_pow ι fun x : ℝ => exp (- |x| ^ p), integral_comp_abs\n      (f := fun x => exp (- x ^ p)), integral_exp_neg_rpow h₁]\n  · rw [finrank_fintype_fun_eq_card]\n\n"}
{"name":"MeasureTheory.volume_sum_rpow_lt","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : Nonempty ι\np : Real\nhp : LE.le 1 p\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (setOf fun x => LT.lt (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (abs (x i)) p) (HDiv.hDiv 1 p)) r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) (Fintype.card ι)) (ENNReal.ofReal (HDiv.hDiv (HPow.hPow (HMul.hMul 2 (Real.Gamma (HAdd.hAdd (HDiv.hDiv 1 p) 1))) (Fintype.card ι)) (Real.Gamma (HAdd.hAdd (HDiv.hDiv (↑(Fintype.card ι)) p) 1)))))","decl":"theorem MeasureTheory.volume_sum_rpow_lt [Nonempty ι] {p : ℝ} (hp : 1 ≤ p) (r : ℝ) :\n    volume {x : ι → ℝ | (∑ i, |x i| ^ p) ^ (1 / p) < r} = (.ofReal r) ^ card ι *\n      .ofReal ((2 * Gamma (1 / p + 1)) ^ card ι / Gamma (card ι / p + 1)) := by\n  have h₁ (x : ι → ℝ) : 0 ≤ ∑ i, |x i| ^ p := by positivity\n  have h₂ : ∀ x : ι → ℝ, 0 ≤ (∑ i, |x i| ^ p) ^ (1 / p) := fun x => rpow_nonneg (h₁ x) _\n  obtain hr | hr := le_or_lt r 0\n  · have : {x : ι → ℝ | (∑ i, |x i| ^ p) ^ (1 / p) < r} = ∅ := by\n      ext x\n      refine ⟨fun hx => ?_, fun hx => hx.elim⟩\n      exact not_le.mpr (lt_of_lt_of_le (Set.mem_setOf.mp hx) hr) (h₂ x)\n    rw [this, measure_empty, ← zero_eq_ofReal.mpr hr, zero_pow Fin.pos'.ne', zero_mul]\n  · rw [← volume_sum_rpow_lt_one _ hp, ← ofReal_pow (le_of_lt hr), ← finrank_pi ℝ]\n    convert addHaar_smul_of_nonneg volume (le_of_lt hr) {x : ι → ℝ | ∑ i, |x i| ^ p < 1} using 2\n    simp_rw [← Set.preimage_smul_inv₀ (ne_of_gt hr), Set.preimage_setOf_eq, Pi.smul_apply,\n      smul_eq_mul, abs_mul, mul_rpow (abs_nonneg _) (abs_nonneg _), abs_inv,\n      inv_rpow (abs_nonneg _), ← Finset.mul_sum, abs_eq_self.mpr (le_of_lt hr),\n      inv_mul_lt_iff₀ (rpow_pos_of_pos hr _), mul_one, ← rpow_lt_rpow_iff\n      (rpow_nonneg (h₁ _) _) (le_of_lt hr) (by linarith : 0 < p), ← rpow_mul\n      (h₁ _), div_mul_cancel₀ _ (ne_of_gt (by linarith) : p ≠ 0), Real.rpow_one]\n\n"}
{"name":"MeasureTheory.volume_sum_rpow_le","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : Nonempty ι\np : Real\nhp : LE.le 1 p\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (setOf fun x => LE.le (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (abs (x i)) p) (HDiv.hDiv 1 p)) r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) (Fintype.card ι)) (ENNReal.ofReal (HDiv.hDiv (HPow.hPow (HMul.hMul 2 (Real.Gamma (HAdd.hAdd (HDiv.hDiv 1 p) 1))) (Fintype.card ι)) (Real.Gamma (HAdd.hAdd (HDiv.hDiv (↑(Fintype.card ι)) p) 1)))))","decl":"theorem MeasureTheory.volume_sum_rpow_le [Nonempty ι] {p : ℝ} (hp : 1 ≤ p) (r : ℝ) :\n    volume {x : ι → ℝ | (∑ i, |x i| ^ p) ^ (1 / p) ≤ r} = (.ofReal r) ^ card ι *\n      .ofReal ((2 * Gamma (1 / p + 1)) ^ card ι / Gamma (card ι / p + 1)) := by\n  have h₁ : 0 < p := by linarith\n  -- We collect facts about `Lp` norms that will be used in `measure_le_one_eq_lt_one`\n  have eq_norm := fun x : ι → ℝ => (PiLp.norm_eq_sum (p := .ofReal p) (f := x)\n    ((toReal_ofReal (le_of_lt h₁)).symm ▸ h₁))\n  simp_rw [toReal_ofReal (le_of_lt h₁), Real.norm_eq_abs] at eq_norm\n  have : Fact (1 ≤ ENNReal.ofReal p) := fact_iff.mpr (ofReal_one ▸ (ofReal_le_ofReal hp))\n  have nm_zero := norm_zero (E := PiLp (.ofReal p) (fun _ : ι => ℝ))\n  have eq_zero := fun x : ι → ℝ => norm_eq_zero (E := PiLp (.ofReal p) (fun _ : ι => ℝ)) (a := x)\n  have nm_neg := fun x : ι → ℝ => norm_neg (E := PiLp (.ofReal p) (fun _ : ι => ℝ)) x\n  have nm_add := fun x y : ι → ℝ => norm_add_le (E := PiLp (.ofReal p) (fun _ : ι => ℝ)) x y\n  simp_rw [eq_norm] at eq_zero nm_zero nm_neg nm_add\n  have nm_smul := fun (r : ℝ) (x : ι → ℝ) =>\n    norm_smul_le (β := PiLp (.ofReal p) (fun _ : ι => ℝ)) r x\n  simp_rw [eq_norm, norm_eq_abs] at nm_smul\n  rw [measure_le_eq_lt _ nm_zero (fun x ↦ nm_neg x) (fun x y ↦ nm_add x y) (eq_zero _).mp\n    (fun r x => nm_smul r x), volume_sum_rpow_lt _ hp]\n\n"}
{"name":"Complex.volume_sum_rpow_lt_one","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\np : Real\nhp : LE.le 1 p\n⊢ Eq (MeasureTheory.MeasureSpace.volume (setOf fun x => LT.lt (Finset.univ.sum fun i => HPow.hPow (Norm.norm (x i)) p) 1)) (ENNReal.ofReal (HDiv.hDiv (HPow.hPow (HMul.hMul Real.pi (Real.Gamma (HAdd.hAdd (HDiv.hDiv 2 p) 1))) (Fintype.card ι)) (Real.Gamma (HAdd.hAdd (HDiv.hDiv (HMul.hMul 2 ↑(Fintype.card ι)) p) 1))))","decl":"theorem Complex.volume_sum_rpow_lt_one {p : ℝ} (hp : 1 ≤ p) :\n    volume {x : ι → ℂ | ∑ i, ‖x i‖ ^ p < 1} =\n      .ofReal ((π * Real.Gamma (2 / p + 1)) ^ card ι / Real.Gamma (2 * card ι / p + 1)) := by\n  have h₁ : 0 < p := by linarith\n  have h₂ : ∀ x : ι → ℂ, 0 ≤ ∑ i, ‖x i‖ ^ p := by\n    refine fun _ => Finset.sum_nonneg' ?_\n    exact fun i => (fun _ => rpow_nonneg (norm_nonneg _) _) _\n  -- We collect facts about `Lp` norms that will be used in `measure_lt_one_eq_integral_div_gamma`\n  have eq_norm := fun x : ι → ℂ => (PiLp.norm_eq_sum (p := .ofReal p) (f := x)\n    ((toReal_ofReal (le_of_lt h₁)).symm ▸ h₁))\n  simp_rw [toReal_ofReal (le_of_lt h₁)] at eq_norm\n  have : Fact (1 ≤ ENNReal.ofReal p) := fact_iff.mpr (ENNReal.ofReal_one ▸ (ofReal_le_ofReal hp))\n  have nm_zero := norm_zero (E := PiLp (.ofReal p) (fun _ : ι => ℂ))\n  have eq_zero := fun x : ι → ℂ => norm_eq_zero (E := PiLp (.ofReal p) (fun _ : ι => ℂ)) (a := x)\n  have nm_neg := fun x : ι → ℂ => norm_neg (E := PiLp (.ofReal p) (fun _ : ι => ℂ)) x\n  have nm_add := fun x y : ι → ℂ => norm_add_le (E := PiLp (.ofReal p) (fun _ : ι => ℂ)) x y\n  simp_rw [eq_norm] at eq_zero nm_zero nm_neg nm_add\n  have nm_smul := fun (r : ℝ) (x : ι → ℂ) =>\n    norm_smul_le (β := PiLp (.ofReal p) (fun _ : ι => ℂ)) r x\n  simp_rw [eq_norm, norm_eq_abs] at nm_smul\n  -- We use `measure_lt_one_eq_integral_div_gamma` with `g` equals to the norm `L_p`\n  convert measure_lt_one_eq_integral_div_gamma (volume : Measure (ι → ℂ))\n    (g := fun x => (∑ i, ‖x i‖ ^ p) ^ (1 / p)) nm_zero nm_neg nm_add (eq_zero _).mp\n    (fun r x => nm_smul r x) (by linarith : 0 < p) using 4\n  · rw [rpow_lt_one_iff' _ (one_div_pos.mpr h₁)]\n    exact Finset.sum_nonneg' (fun _ => rpow_nonneg (norm_nonneg _) _)\n  · simp_rw [← rpow_mul (h₂ _), div_mul_cancel₀ _ (ne_of_gt h₁), Real.rpow_one,\n      ← Finset.sum_neg_distrib, Real.exp_sum]\n    rw [integral_fintype_prod_eq_pow ι fun x : ℂ => Real.exp (- ‖x‖ ^ p),\n      Complex.integral_exp_neg_rpow hp]\n  · rw [finrank_pi_fintype, Complex.finrank_real_complex, Finset.sum_const, smul_eq_mul,\n      Nat.cast_mul, Nat.cast_ofNat, Fintype.card, mul_comm]\n\n"}
{"name":"Complex.volume_sum_rpow_lt","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : Nonempty ι\np : Real\nhp : LE.le 1 p\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (setOf fun x => LT.lt (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (Norm.norm (x i)) p) (HDiv.hDiv 1 p)) r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) (HMul.hMul 2 (Fintype.card ι))) (ENNReal.ofReal (HDiv.hDiv (HPow.hPow (HMul.hMul Real.pi (Real.Gamma (HAdd.hAdd (HDiv.hDiv 2 p) 1))) (Fintype.card ι)) (Real.Gamma (HAdd.hAdd (HDiv.hDiv (HMul.hMul 2 ↑(Fintype.card ι)) p) 1)))))","decl":"theorem Complex.volume_sum_rpow_lt [Nonempty ι] {p : ℝ} (hp : 1 ≤ p) (r : ℝ) :\n    volume {x : ι → ℂ | (∑ i, ‖x i‖ ^ p) ^ (1 / p) < r} = (.ofReal r) ^ (2 * card ι) *\n      .ofReal ((π * Real.Gamma (2 / p + 1)) ^ card ι / Real.Gamma (2 * card ι / p + 1)) := by\n  have h₁ (x : ι → ℂ) : 0 ≤ ∑ i, ‖x i‖ ^ p := by positivity\n  have h₂ : ∀ x : ι → ℂ, 0 ≤ (∑ i, ‖x i‖ ^ p) ^ (1 / p) := fun x => rpow_nonneg (h₁ x) _\n  obtain hr | hr := le_or_lt r 0\n  · have : {x : ι → ℂ | (∑ i, ‖x i‖ ^ p) ^ (1 / p) < r} = ∅ := by\n      ext x\n      refine ⟨fun hx => ?_, fun hx => hx.elim⟩\n      exact not_le.mpr (lt_of_lt_of_le (Set.mem_setOf.mp hx) hr) (h₂ x)\n    rw [this, measure_empty, ← zero_eq_ofReal.mpr hr, zero_pow Fin.pos'.ne', zero_mul]\n  · rw [← Complex.volume_sum_rpow_lt_one _ hp, ← ENNReal.ofReal_pow (le_of_lt hr)]\n    convert addHaar_smul_of_nonneg volume (le_of_lt hr) {x : ι → ℂ |  ∑ i, ‖x i‖ ^ p < 1} using 2\n    · simp_rw [← Set.preimage_smul_inv₀ (ne_of_gt hr), Set.preimage_setOf_eq, Pi.smul_apply,\n        norm_smul, mul_rpow (norm_nonneg _) (norm_nonneg _), Real.norm_eq_abs, abs_inv, inv_rpow\n        (abs_nonneg _), ← Finset.mul_sum, abs_eq_self.mpr (le_of_lt hr), inv_mul_lt_iff₀\n        (rpow_pos_of_pos hr _), mul_one, ← rpow_lt_rpow_iff (rpow_nonneg (h₁ _) _)\n        (le_of_lt hr) (by linarith : 0 < p), ← rpow_mul (h₁ _), div_mul_cancel₀ _\n        (ne_of_gt (by linarith) : p ≠ 0), Real.rpow_one]\n    · simp_rw [finrank_pi_fintype ℝ, Complex.finrank_real_complex, Finset.sum_const, smul_eq_mul,\n        mul_comm, Fintype.card]\n\n"}
{"name":"Complex.volume_sum_rpow_le","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : Nonempty ι\np : Real\nhp : LE.le 1 p\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (setOf fun x => LE.le (HPow.hPow (Finset.univ.sum fun i => HPow.hPow (Norm.norm (x i)) p) (HDiv.hDiv 1 p)) r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) (HMul.hMul 2 (Fintype.card ι))) (ENNReal.ofReal (HDiv.hDiv (HPow.hPow (HMul.hMul Real.pi (Real.Gamma (HAdd.hAdd (HDiv.hDiv 2 p) 1))) (Fintype.card ι)) (Real.Gamma (HAdd.hAdd (HDiv.hDiv (HMul.hMul 2 ↑(Fintype.card ι)) p) 1)))))","decl":"theorem Complex.volume_sum_rpow_le [Nonempty ι] {p : ℝ} (hp : 1 ≤ p) (r : ℝ) :\n    volume {x : ι → ℂ | (∑ i, ‖x i‖ ^ p) ^ (1 / p) ≤ r} = (.ofReal r) ^ (2 * card ι) *\n      .ofReal ((π * Real.Gamma (2 / p + 1)) ^ card ι / Real.Gamma (2 * card ι / p + 1)) := by\n  have h₁ : 0 < p := by linarith\n  -- We collect facts about `Lp` norms that will be used in `measure_lt_one_eq_integral_div_gamma`\n  have eq_norm := fun x : ι → ℂ => (PiLp.norm_eq_sum (p := .ofReal p) (f := x)\n    ((toReal_ofReal (le_of_lt h₁)).symm ▸ h₁))\n  simp_rw [toReal_ofReal (le_of_lt h₁)] at eq_norm\n  have : Fact (1 ≤ ENNReal.ofReal p) := fact_iff.mpr (ENNReal.ofReal_one ▸ (ofReal_le_ofReal hp))\n  have nm_zero := norm_zero (E := PiLp (.ofReal p) (fun _ : ι => ℂ))\n  have eq_zero := fun x : ι → ℂ => norm_eq_zero (E := PiLp (.ofReal p) (fun _ : ι => ℂ)) (a := x)\n  have nm_neg := fun x : ι → ℂ => norm_neg (E := PiLp (.ofReal p) (fun _ : ι => ℂ)) x\n  have nm_add := fun x y : ι → ℂ => norm_add_le (E := PiLp (.ofReal p) (fun _ : ι => ℂ)) x y\n  simp_rw [eq_norm] at eq_zero nm_zero nm_neg nm_add\n  have nm_smul := fun (r : ℝ) (x : ι → ℂ) =>\n    norm_smul_le (β := PiLp (.ofReal p) (fun _ : ι => ℂ)) r x\n  simp_rw [eq_norm, norm_eq_abs] at nm_smul\n  rw [measure_le_eq_lt _ nm_zero (fun x ↦ nm_neg x) (fun x y ↦ nm_add x y) (eq_zero _).mp\n    (fun r x => nm_smul r x), Complex.volume_sum_rpow_lt _ hp]\n\n"}
{"name":"EuclideanSpace.volume_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"ι : Type u_1\ninst✝¹ : Nonempty ι\ninst✝ : Fintype ι\nx : EuclideanSpace Real ι\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.ball x r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) (Fintype.card ι)) (ENNReal.ofReal (HDiv.hDiv (HPow.hPow Real.pi.sqrt (Fintype.card ι)) (Real.Gamma (HAdd.hAdd (HDiv.hDiv (↑(Fintype.card ι)) 2) 1)))))","decl":"theorem volume_ball (x : EuclideanSpace ℝ ι) (r : ℝ) :\n    volume (Metric.ball x r) = (.ofReal r) ^ card ι *\n      .ofReal (Real.sqrt π ^ card ι / Gamma (card ι / 2 + 1)) := by\n  obtain hr | hr := le_total r 0\n  · rw [Metric.ball_eq_empty.mpr hr, measure_empty, ← zero_eq_ofReal.mpr hr, zero_pow card_ne_zero,\n      zero_mul]\n  · suffices volume (Metric.ball (0 : EuclideanSpace ℝ ι) 1) =\n        .ofReal (Real.sqrt π ^ card ι / Gamma (card ι / 2 + 1)) by\n      rw [Measure.addHaar_ball _ _ hr, this, ofReal_pow hr, finrank_euclideanSpace]\n    rw [← ((volume_preserving_measurableEquiv _).symm).measure_preimage\n      measurableSet_ball.nullMeasurableSet]\n    convert (volume_sum_rpow_lt_one ι one_le_two) using 4\n    · simp_rw [ball_zero_eq _ zero_le_one, one_pow, Real.rpow_two, sq_abs,\n        Set.setOf_app_iff]\n    · rw [Gamma_add_one (by norm_num), Gamma_one_half_eq, ← mul_assoc, mul_div_cancel₀ _\n        two_ne_zero, one_mul]\n\n"}
{"name":"EuclideanSpace.volume_closedBall","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"ι : Type u_1\ninst✝¹ : Nonempty ι\ninst✝ : Fintype ι\nx : EuclideanSpace Real ι\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall x r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) (Fintype.card ι)) (ENNReal.ofReal (HDiv.hDiv (HPow.hPow Real.pi.sqrt (Fintype.card ι)) (Real.Gamma (HAdd.hAdd (HDiv.hDiv (↑(Fintype.card ι)) 2) 1)))))","decl":"theorem volume_closedBall (x : EuclideanSpace ℝ ι) (r : ℝ) :\n    volume (Metric.closedBall x r) = (.ofReal r) ^ card ι *\n      .ofReal (sqrt π ^ card ι / Gamma (card ι / 2 + 1)) := by\n  rw [addHaar_closedBall_eq_addHaar_ball, EuclideanSpace.volume_ball]\n\n"}
{"name":"InnerProductSpace.volume_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace Real E\ninst✝³ : FiniteDimensional Real E\ninst✝² : MeasurableSpace E\ninst✝¹ : BorelSpace E\ninst✝ : Nontrivial E\nx : E\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.ball x r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) (Module.finrank Real E)) (ENNReal.ofReal (HDiv.hDiv (HPow.hPow Real.pi.sqrt (Module.finrank Real E)) (Real.Gamma (HAdd.hAdd (HDiv.hDiv (↑(Module.finrank Real E)) 2) 1)))))","decl":"theorem volume_ball (x : E) (r : ℝ) :\n    volume (Metric.ball x r) = (.ofReal r) ^ finrank ℝ E *\n      .ofReal (sqrt π ^ finrank ℝ E / Gamma (finrank ℝ E / 2 + 1)) := by\n  rw [← ((stdOrthonormalBasis ℝ E).measurePreserving_repr_symm).measure_preimage\n      measurableSet_ball.nullMeasurableSet]\n  have : Nonempty (Fin (finrank ℝ E)) := Fin.pos_iff_nonempty.mp finrank_pos\n  have := EuclideanSpace.volume_ball (Fin (finrank ℝ E)) ((stdOrthonormalBasis ℝ E).repr x) r\n  simp_rw [Fintype.card_fin] at this\n  convert this\n  simp only [LinearIsometryEquiv.preimage_ball, LinearIsometryEquiv.symm_symm, _root_.map_zero]\n\n"}
{"name":"InnerProductSpace.volume_closedBall","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace Real E\ninst✝³ : FiniteDimensional Real E\ninst✝² : MeasurableSpace E\ninst✝¹ : BorelSpace E\ninst✝ : Nontrivial E\nx : E\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall x r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) (Module.finrank Real E)) (ENNReal.ofReal (HDiv.hDiv (HPow.hPow Real.pi.sqrt (Module.finrank Real E)) (Real.Gamma (HAdd.hAdd (HDiv.hDiv (↑(Module.finrank Real E)) 2) 1)))))","decl":"theorem volume_closedBall (x : E) (r : ℝ) :\n    volume (Metric.closedBall x r) = (.ofReal r) ^ finrank ℝ E *\n      .ofReal (sqrt π ^ finrank ℝ E / Gamma (finrank ℝ E / 2 + 1)) := by\n  rw [addHaar_closedBall_eq_addHaar_ball, InnerProductSpace.volume_ball _]\n\n"}
{"name":"InnerProductSpace.volume_ball_of_dim_even","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace Real E\ninst✝³ : FiniteDimensional Real E\ninst✝² : MeasurableSpace E\ninst✝¹ : BorelSpace E\ninst✝ : Nontrivial E\nk : Nat\nhk : Eq (Module.finrank Real E) (HMul.hMul 2 k)\nx : E\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.ball x r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) (Module.finrank Real E)) (ENNReal.ofReal (HDiv.hDiv (HPow.hPow Real.pi k) ↑k.factorial)))","decl":"lemma volume_ball_of_dim_even {k : ℕ} (hk : finrank ℝ E = 2 * k) (x : E) (r : ℝ) :\n    volume (ball x r) = .ofReal r ^ finrank ℝ E * .ofReal (π ^ k / (k : ℕ)!) := by\n  rw [volume_ball, hk, pow_mul, pow_mul, sq_sqrt pi_nonneg]\n  congr\n  simp [Gamma_nat_eq_factorial]\n\n"}
{"name":"InnerProductSpace.volume_closedBall_of_dim_even","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace Real E\ninst✝³ : FiniteDimensional Real E\ninst✝² : MeasurableSpace E\ninst✝¹ : BorelSpace E\ninst✝ : Nontrivial E\nk : Nat\nhk : Eq (Module.finrank Real E) (HMul.hMul 2 k)\nx : E\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall x r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) (Module.finrank Real E)) (ENNReal.ofReal (HDiv.hDiv (HPow.hPow Real.pi k) ↑k.factorial)))","decl":"lemma volume_closedBall_of_dim_even {k : ℕ} (hk : finrank ℝ E = 2 * k) (x : E) (r : ℝ) :\n    volume (closedBall x r) = .ofReal r ^ finrank ℝ E * .ofReal (π ^ k / (k : ℕ)!) := by\n  rw [addHaar_closedBall_eq_addHaar_ball, volume_ball_of_dim_even hk x]\n\n"}
{"name":"InnerProductSpace.volume_ball_of_dim_odd","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nk : Nat\nhk : Eq (Module.finrank Real E) (HAdd.hAdd (HMul.hMul 2 k) 1)\nx : E\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.ball x r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) (Module.finrank Real E)) (ENNReal.ofReal (HDiv.hDiv (HMul.hMul (HPow.hPow Real.pi k) (HPow.hPow 2 (HAdd.hAdd k 1))) ↑(Module.finrank Real E).doubleFactorial)))","decl":"lemma volume_ball_of_dim_odd {k : ℕ} (hk : finrank ℝ E = 2 * k + 1) (x : E) (r : ℝ) :\n    volume (ball x r) =\n      .ofReal r ^ finrank ℝ E * .ofReal (π ^ k * 2 ^ (k + 1) / (finrank ℝ E : ℕ)‼) := by\n  have : Nontrivial E := Module.nontrivial_of_finrank_pos (R := ℝ) (hk ▸ (2 * k).succ_pos)\n  rw [volume_ball, hk, pow_succ (√π), pow_mul, sq_sqrt pi_nonneg, mul_div_assoc, mul_div_assoc]\n  congr 3\n  simp? [add_div, add_right_comm, -one_div, Gamma_nat_add_one_add_half] says\n    simp only [Nat.cast_add, Nat.cast_mul, Nat.cast_ofNat, Nat.cast_one, add_div, ne_eq,\n      OfNat.ofNat_ne_zero, not_false_eq_true, mul_div_cancel_left₀, add_right_comm,\n      Gamma_nat_add_one_add_half]\n  field_simp\n  ring\n\n"}
{"name":"InnerProductSpace.volume_closedBall_of_dim_odd","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nk : Nat\nhk : Eq (Module.finrank Real E) (HAdd.hAdd (HMul.hMul 2 k) 1)\nx : E\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall x r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) (Module.finrank Real E)) (ENNReal.ofReal (HDiv.hDiv (HMul.hMul (HPow.hPow Real.pi k) (HPow.hPow 2 (HAdd.hAdd k 1))) ↑(Module.finrank Real E).doubleFactorial)))","decl":"lemma volume_closedBall_of_dim_odd {k : ℕ} (hk : finrank ℝ E = 2 * k + 1) (x : E) (r : ℝ) :\n    volume (closedBall x r) =\n      .ofReal r ^ finrank ℝ E * .ofReal (π ^ k * 2 ^ (k + 1) / (finrank ℝ E : ℕ)‼) := by\n  have : Nontrivial E := Module.nontrivial_of_finrank_pos (R := ℝ) (hk ▸ (2 * k).succ_pos)\n  rw [addHaar_closedBall_eq_addHaar_ball, volume_ball_of_dim_odd hk x r]\n\n"}
{"name":"EuclideanSpace.volume_ball_fin_two","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"x : EuclideanSpace Real (Fin 2)\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.ball x r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) 2) (ENNReal.ofReal Real.pi))","decl":"@[simp]\nlemma volume_ball_fin_two (x : EuclideanSpace ℝ (Fin 2)) (r : ℝ) :\n    volume (ball x r) = .ofReal r ^ 2 * .ofReal π := by\n  norm_num [InnerProductSpace.volume_ball_of_dim_even (k := 1) (by simp) x]\n\n"}
{"name":"EuclideanSpace.volume_closedBall_fin_two","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"x : EuclideanSpace Real (Fin 2)\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall x r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) 2) (ENNReal.ofReal Real.pi))","decl":"@[simp]\nlemma volume_closedBall_fin_two (x : EuclideanSpace ℝ (Fin 2)) (r : ℝ) :\n    volume (closedBall x r) = .ofReal r ^ 2 * .ofReal π := by\n  rw [addHaar_closedBall_eq_addHaar_ball, volume_ball_fin_two x r]\n\n"}
{"name":"EuclideanSpace.volume_ball_fin_three","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"x : EuclideanSpace Real (Fin 3)\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.ball x r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) 3) (ENNReal.ofReal (HDiv.hDiv (HMul.hMul Real.pi 4) 3)))","decl":"@[simp]\nlemma volume_ball_fin_three (x : EuclideanSpace ℝ (Fin 3)) (r : ℝ) :\n    volume (ball x r) = .ofReal r ^ 3 * .ofReal (π * 4 / 3) := by\n  norm_num [InnerProductSpace.volume_ball_of_dim_odd (k := 1) (by simp) x]\n\n"}
{"name":"EuclideanSpace.volume_closedBall_fin_three","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"x : EuclideanSpace Real (Fin 3)\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall x r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) 3) (ENNReal.ofReal (HDiv.hDiv (HMul.hMul Real.pi 4) 3)))","decl":"@[simp]\nlemma volume_closedBall_fin_three (x : EuclideanSpace ℝ (Fin 3)) (r : ℝ) :\n    volume (closedBall x r) = .ofReal r ^ 3 * .ofReal (π * 4 / 3) := by\n  rw [addHaar_closedBall_eq_addHaar_ball, volume_ball_fin_three x]\n\n"}
{"name":"Complex.volume_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"a : Complex\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.ball a r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) 2) ↑NNReal.pi)","decl":"@[simp]\ntheorem Complex.volume_ball (a : ℂ) (r : ℝ) :\n    volume (Metric.ball a r) = .ofReal r ^ 2 * NNReal.pi := by\n  simp [InnerProductSpace.volume_ball_of_dim_even (k := 1) (by simp) a,\n    ← NNReal.coe_real_pi, ofReal_coe_nnreal]\n\n"}
{"name":"Complex.volume_closedBall","module":"Mathlib.MeasureTheory.Measure.Lebesgue.VolumeOfBalls","initialProofState":"a : Complex\nr : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall a r)) (HMul.hMul (HPow.hPow (ENNReal.ofReal r) 2) ↑NNReal.pi)","decl":"@[simp]\ntheorem Complex.volume_closedBall (a : ℂ) (r : ℝ) :\n    volume (Metric.closedBall a r) = .ofReal r ^ 2 * NNReal.pi := by\n  rw [addHaar_closedBall_eq_addHaar_ball, Complex.volume_ball]\n\n"}
