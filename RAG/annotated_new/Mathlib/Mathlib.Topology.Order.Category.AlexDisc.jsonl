{"name":"AlexandrovDiscreteSpace.toAlexandrovDiscrete","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"α : Type u_1\nself : AlexandrovDiscreteSpace α\n⊢ AlexandrovDiscrete α","decl":"/-- Auxiliary typeclass to define the category of Alexandrov-discrete spaces. Do not use this\ndirectly. Use `AlexandrovDiscrete` instead. -/\nclass AlexandrovDiscreteSpace (α : Type*) extends TopologicalSpace α, AlexandrovDiscrete α\n\n"}
{"name":"AlexDisc.instAlexandrovDiscrete","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"α : AlexDisc\n⊢ AlexandrovDiscrete ↑α","decl":"instance instAlexandrovDiscrete (α : AlexDisc) : AlexandrovDiscrete α := α.2.2\n\n"}
{"name":"AlexDisc.instParentProjectionTopologicalSpaceAlexandrovDiscreteSpaceToTopologicalSpace","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"⊢ CategoryTheory.BundledHom.ParentProjection @AlexandrovDiscreteSpace.toTopologicalSpace","decl":"instance : BundledHom.ParentProjection @AlexandrovDiscreteSpace.toTopologicalSpace := ⟨⟩\n\n"}
{"name":"AlexDisc.forgetToTop_full","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"⊢ (CategoryTheory.forget₂ AlexDisc TopCat).Full","decl":"instance forgetToTop_full : (forget₂ AlexDisc TopCat).Full := BundledHom.forget₂_full _ _\n"}
{"name":"AlexDisc.forgetToTop_faithful","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"⊢ (CategoryTheory.forget₂ AlexDisc TopCat).Faithful","decl":"instance forgetToTop_faithful : (forget₂ AlexDisc TopCat).Faithful where\n\n"}
{"name":"AlexDisc.coe_forgetToTop","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"X : AlexDisc\n⊢ Eq ↑((CategoryTheory.forget₂ AlexDisc TopCat).obj X) ↑X","decl":"@[simp] lemma coe_forgetToTop (X : AlexDisc) : ↥((forget₂ _ TopCat).obj X) = X := rfl\n\n"}
{"name":"AlexDisc.coe_of","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\n⊢ Eq (↑(AlexDisc.of α)) α","decl":"@[simp] lemma coe_of (α : Type*) [TopologicalSpace α] [AlexandrovDiscrete α] : ↥(of α) = α := rfl\n"}
{"name":"AlexDisc.forgetToTop_of","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\n⊢ Eq ((CategoryTheory.forget₂ AlexDisc TopCat).obj (AlexDisc.of α)) (TopCat.of α)","decl":"@[simp] lemma forgetToTop_of (α : Type*) [TopologicalSpace α] [AlexandrovDiscrete α] :\n  (forget₂ AlexDisc TopCat).obj (of α) = TopCat.of α := rfl\n\n-- This was a global instance prior to https://github.com/leanprover-community/mathlib4/pull/13170. We may experiment with removing it.\n"}
{"name":"AlexDisc.Iso.mk_hom","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"α β : AlexDisc\ne : Homeomorph ↑α ↑β\n⊢ Eq (AlexDisc.Iso.mk e).hom ↑e","decl":"/-- Constructs an equivalence between preorders from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : AlexDisc} (e : α ≃ₜ β) : α ≅ β where\n  hom := (e : ContinuousMap α β)\n  inv := (e.symm : ContinuousMap β α)\n  hom_inv_id := DFunLike.ext _ _ e.symm_apply_apply\n  inv_hom_id := DFunLike.ext _ _ e.apply_symm_apply\n\n"}
{"name":"AlexDisc.Iso.mk_inv","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"α β : AlexDisc\ne : Homeomorph ↑α ↑β\n⊢ Eq (AlexDisc.Iso.mk e).inv ↑e.symm","decl":"/-- Constructs an equivalence between preorders from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : AlexDisc} (e : α ≃ₜ β) : α ≅ β where\n  hom := (e : ContinuousMap α β)\n  inv := (e.symm : ContinuousMap β α)\n  hom_inv_id := DFunLike.ext _ _ e.symm_apply_apply\n  inv_hom_id := DFunLike.ext _ _ e.apply_symm_apply\n\n"}
{"name":"alexDiscEquivPreord_functor","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"⊢ Eq alexDiscEquivPreord.functor ((CategoryTheory.forget₂ AlexDisc TopCat).comp topToPreord)","decl":"/-- Sends a topological space to its specialisation order. -/\n@[simps]\ndef alexDiscEquivPreord : AlexDisc ≌ Preord where\n  functor := forget₂ _ _ ⋙ topToPreord\n  inverse := { obj := fun X ↦ AlexDisc.of (WithUpperSet X), map := WithUpperSet.map }\n  unitIso := NatIso.ofComponents fun X ↦ AlexDisc.Iso.mk <| by\n    dsimp; exact homeoWithUpperSetTopologyorderIso X\n  counitIso := NatIso.ofComponents fun X ↦ Preord.Iso.mk <| by\n    dsimp; exact (orderIsoSpecializationWithUpperSetTopology X).symm\n"}
{"name":"alexDiscEquivPreord_inverse_map","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"X✝ Y✝ : Preord\nf : OrderHom ↑X✝ ↑Y✝\n⊢ Eq (alexDiscEquivPreord.inverse.map f) (Topology.WithUpperSet.map f)","decl":"/-- Sends a topological space to its specialisation order. -/\n@[simps]\ndef alexDiscEquivPreord : AlexDisc ≌ Preord where\n  functor := forget₂ _ _ ⋙ topToPreord\n  inverse := { obj := fun X ↦ AlexDisc.of (WithUpperSet X), map := WithUpperSet.map }\n  unitIso := NatIso.ofComponents fun X ↦ AlexDisc.Iso.mk <| by\n    dsimp; exact homeoWithUpperSetTopologyorderIso X\n  counitIso := NatIso.ofComponents fun X ↦ Preord.Iso.mk <| by\n    dsimp; exact (orderIsoSpecializationWithUpperSetTopology X).symm\n"}
{"name":"alexDiscEquivPreord_unitIso","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"⊢ Eq alexDiscEquivPreord.unitIso (CategoryTheory.NatIso.ofComponents (fun X => AlexDisc.Iso.mk (id (homeoWithUpperSetTopologyorderIso ↑X))) @alexDiscEquivPreord.proof_4)","decl":"/-- Sends a topological space to its specialisation order. -/\n@[simps]\ndef alexDiscEquivPreord : AlexDisc ≌ Preord where\n  functor := forget₂ _ _ ⋙ topToPreord\n  inverse := { obj := fun X ↦ AlexDisc.of (WithUpperSet X), map := WithUpperSet.map }\n  unitIso := NatIso.ofComponents fun X ↦ AlexDisc.Iso.mk <| by\n    dsimp; exact homeoWithUpperSetTopologyorderIso X\n  counitIso := NatIso.ofComponents fun X ↦ Preord.Iso.mk <| by\n    dsimp; exact (orderIsoSpecializationWithUpperSetTopology X).symm\n"}
{"name":"alexDiscEquivPreord_counitIso","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"⊢ Eq alexDiscEquivPreord.counitIso (CategoryTheory.NatIso.ofComponents (fun X => Preord.Iso.mk (id (orderIsoSpecializationWithUpperSetTopology ↑X).symm)) @alexDiscEquivPreord.proof_5)","decl":"/-- Sends a topological space to its specialisation order. -/\n@[simps]\ndef alexDiscEquivPreord : AlexDisc ≌ Preord where\n  functor := forget₂ _ _ ⋙ topToPreord\n  inverse := { obj := fun X ↦ AlexDisc.of (WithUpperSet X), map := WithUpperSet.map }\n  unitIso := NatIso.ofComponents fun X ↦ AlexDisc.Iso.mk <| by\n    dsimp; exact homeoWithUpperSetTopologyorderIso X\n  counitIso := NatIso.ofComponents fun X ↦ Preord.Iso.mk <| by\n    dsimp; exact (orderIsoSpecializationWithUpperSetTopology X).symm\n"}
{"name":"alexDiscEquivPreord_inverse_obj","module":"Mathlib.Topology.Order.Category.AlexDisc","initialProofState":"X : Preord\n⊢ Eq (alexDiscEquivPreord.inverse.obj X) (AlexDisc.of (Topology.WithUpperSet ↑X))","decl":"/-- Sends a topological space to its specialisation order. -/\n@[simps]\ndef alexDiscEquivPreord : AlexDisc ≌ Preord where\n  functor := forget₂ _ _ ⋙ topToPreord\n  inverse := { obj := fun X ↦ AlexDisc.of (WithUpperSet X), map := WithUpperSet.map }\n  unitIso := NatIso.ofComponents fun X ↦ AlexDisc.Iso.mk <| by\n    dsimp; exact homeoWithUpperSetTopologyorderIso X\n  counitIso := NatIso.ofComponents fun X ↦ Preord.Iso.mk <| by\n    dsimp; exact (orderIsoSpecializationWithUpperSetTopology X).symm\n"}
