{"name":"CategoryTheory.TwoSquare.ext","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw w' : CategoryTheory.TwoSquare T L R B\nh : ∀ (X : C₁), Eq (w.app X) (w'.app X)\n⊢ Eq w w'","decl":"@[ext]\nlemma ext (w w' : TwoSquare T L R B) (h : ∀ (X : C₁), w.app X = w'.app X) :\n    w = w' :=\n  NatTrans.ext (funext h)\n\n"}
{"name":"CategoryTheory.TwoSquare.ext_iff","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw w' : CategoryTheory.TwoSquare T L R B\n⊢ Iff (Eq w w') (∀ (X : C₁), Eq (w.app X) (w'.app X))","decl":"@[ext]\nlemma ext (w w' : TwoSquare T L R B) (h : ∀ (X : C₁), w.app X = w'.app X) :\n    w = w' :=\n  NatTrans.ext (funext h)\n\n"}
{"name":"CategoryTheory.TwoSquare.costructuredArrowRightwards_map","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₃ : C₃\nX✝ Y✝ : CategoryTheory.CostructuredArrow L X₃\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((w.costructuredArrowRightwards X₃).map f) ((CategoryTheory.CostructuredArrow.pre T R (B.obj X₃)).map ((CategoryTheory.Comma.mapLeft (CategoryTheory.Functor.fromPUnit (B.obj X₃)) w).map (CategoryTheory.CostructuredArrow.homMk f.left ⋯)))","decl":"/-- Given `w : TwoSquare T L R B` and `X₃ : C₃`, this is the obvious functor\n`CostructuredArrow L X₃ ⥤ CostructuredArrow R (B.obj X₃)`. -/\n@[simps! obj map]\ndef costructuredArrowRightwards (X₃ : C₃) :\n    CostructuredArrow L X₃ ⥤ CostructuredArrow R (B.obj X₃) :=\n  CostructuredArrow.post L B X₃ ⋙ Comma.mapLeft _ w ⋙\n    CostructuredArrow.pre T R (B.obj X₃)\n\n"}
{"name":"CategoryTheory.TwoSquare.costructuredArrowRightwards_obj","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₃ : C₃\nX : CategoryTheory.CostructuredArrow L X₃\n⊢ Eq ((w.costructuredArrowRightwards X₃).obj X) ((CategoryTheory.CostructuredArrow.pre T R (B.obj X₃)).obj ((CategoryTheory.Comma.mapLeft (CategoryTheory.Functor.fromPUnit (B.obj X₃)) w).obj (CategoryTheory.CostructuredArrow.mk (B.map X.hom))))","decl":"/-- Given `w : TwoSquare T L R B` and `X₃ : C₃`, this is the obvious functor\n`CostructuredArrow L X₃ ⥤ CostructuredArrow R (B.obj X₃)`. -/\n@[simps! obj map]\ndef costructuredArrowRightwards (X₃ : C₃) :\n    CostructuredArrow L X₃ ⥤ CostructuredArrow R (B.obj X₃) :=\n  CostructuredArrow.post L B X₃ ⋙ Comma.mapLeft _ w ⋙\n    CostructuredArrow.pre T R (B.obj X₃)\n\n"}
{"name":"CategoryTheory.TwoSquare.structuredArrowDownwards_obj","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ : C₂\nX : CategoryTheory.StructuredArrow X₂ T\n⊢ Eq ((w.structuredArrowDownwards X₂).obj X) ((CategoryTheory.StructuredArrow.pre (R.obj X₂) L B).obj ((CategoryTheory.Comma.mapRight (CategoryTheory.Functor.fromPUnit (R.obj X₂)) w).obj (CategoryTheory.StructuredArrow.mk (R.map X.hom))))","decl":"/-- Given `w : TwoSquare T L R B` and `X₂ : C₂`, this is the obvious functor\n`StructuredArrow X₂ T ⥤ StructuredArrow (R.obj X₂) B`. -/\n@[simps! obj map]\ndef structuredArrowDownwards (X₂ : C₂) :\n    StructuredArrow X₂ T ⥤ StructuredArrow (R.obj X₂) B :=\n  StructuredArrow.post X₂ T R ⋙ Comma.mapRight _ w ⋙\n    StructuredArrow.pre (R.obj X₂) L B\n\n"}
{"name":"CategoryTheory.TwoSquare.structuredArrowDownwards_map","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ : C₂\nX✝ Y✝ : CategoryTheory.StructuredArrow X₂ T\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((w.structuredArrowDownwards X₂).map f) ((CategoryTheory.StructuredArrow.pre (R.obj X₂) L B).map ((CategoryTheory.Comma.mapRight (CategoryTheory.Functor.fromPUnit (R.obj X₂)) w).map (CategoryTheory.StructuredArrow.homMk f.right ⋯)))","decl":"/-- Given `w : TwoSquare T L R B` and `X₂ : C₂`, this is the obvious functor\n`StructuredArrow X₂ T ⥤ StructuredArrow (R.obj X₂) B`. -/\n@[simps! obj map]\ndef structuredArrowDownwards (X₂ : C₂) :\n    StructuredArrow X₂ T ⥤ StructuredArrow (R.obj X₂) B :=\n  StructuredArrow.post X₂ T R ⋙ Comma.mapRight _ w ⋙\n    StructuredArrow.pre (R.obj X₂) L B\n\n"}
{"name":"CategoryTheory.TwoSquare.StructuredArrowRightwards.mk_surjective","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\nf : w.StructuredArrowRightwards g\n⊢ Exists fun X₁ => Exists fun a => Exists fun b => Exists fun comm => Eq f (CategoryTheory.TwoSquare.StructuredArrowRightwards.mk w g X₁ a b comm)","decl":"lemma StructuredArrowRightwards.mk_surjective\n    (f : w.StructuredArrowRightwards g) :\n    ∃ (X₁ : C₁) (a : X₂ ⟶ T.obj X₁) (b : L.obj X₁ ⟶ X₃)\n      (comm : R.map a ≫ w.app X₁ ≫ B.map b = g), f = mk w g X₁ a b comm := by\n  obtain ⟨g, φ, rfl⟩ := StructuredArrow.mk_surjective f\n  obtain ⟨X₁, b, rfl⟩ := g.mk_surjective\n  obtain ⟨a, ha, rfl⟩ := CostructuredArrow.homMk_surjective φ\n  exact ⟨X₁, a, b, by simpa using ha, rfl⟩\n\n"}
{"name":"CategoryTheory.TwoSquare.CostructuredArrowDownwards.mk_surjective","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\nf : w.CostructuredArrowDownwards g\n⊢ Exists fun X₁ => Exists fun a => Exists fun b => Exists fun comm => Eq f (CategoryTheory.TwoSquare.CostructuredArrowDownwards.mk w g X₁ a b comm)","decl":"lemma CostructuredArrowDownwards.mk_surjective\n    (f : w.CostructuredArrowDownwards g) :\n    ∃ (X₁ : C₁) (a : X₂ ⟶ T.obj X₁) (b : L.obj X₁ ⟶ X₃)\n      (comm : R.map a ≫ w.app X₁ ≫ B.map b = g), f = mk w g X₁ a b comm := by\n  obtain ⟨g, φ, rfl⟩ := CostructuredArrow.mk_surjective f\n  obtain ⟨X₁, a, rfl⟩ := g.mk_surjective\n  obtain ⟨b, hb, rfl⟩ := StructuredArrow.homMk_surjective φ\n  exact ⟨X₁, a, b, by simpa using hb, rfl⟩\n\n"}
{"name":"CategoryTheory.TwoSquare.EquivalenceJ.functor_obj","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\nf : w.StructuredArrowRightwards g\n⊢ Eq ((CategoryTheory.TwoSquare.EquivalenceJ.functor w g).obj f) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.StructuredArrow.homMk f.right.hom ⋯))","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj X₂ ⟶ B.obj X₃`, this is\nthe obvious functor `w.StructuredArrowRightwards g ⥤ w.CostructuredArrowDownwards g`. -/\n@[simps]\ndef functor : w.StructuredArrowRightwards g ⥤ w.CostructuredArrowDownwards g where\n  obj f := CostructuredArrow.mk (Y := StructuredArrow.mk f.hom.left)\n      (StructuredArrow.homMk f.right.hom (by simpa using CostructuredArrow.w f.hom))\n  map {f₁ f₂} φ :=\n    CostructuredArrow.homMk (StructuredArrow.homMk φ.right.left\n      (by dsimp; rw [← StructuredArrow.w φ]; rfl))\n      (by ext; exact CostructuredArrow.w φ.right)\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.TwoSquare.EquivalenceJ.functor_map","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\nf₁ f₂ : w.StructuredArrowRightwards g\nφ : Quiver.Hom f₁ f₂\n⊢ Eq ((CategoryTheory.TwoSquare.EquivalenceJ.functor w g).map φ) (CategoryTheory.CostructuredArrow.homMk (CategoryTheory.StructuredArrow.homMk φ.right.left ⋯) ⋯)","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj X₂ ⟶ B.obj X₃`, this is\nthe obvious functor `w.StructuredArrowRightwards g ⥤ w.CostructuredArrowDownwards g`. -/\n@[simps]\ndef functor : w.StructuredArrowRightwards g ⥤ w.CostructuredArrowDownwards g where\n  obj f := CostructuredArrow.mk (Y := StructuredArrow.mk f.hom.left)\n      (StructuredArrow.homMk f.right.hom (by simpa using CostructuredArrow.w f.hom))\n  map {f₁ f₂} φ :=\n    CostructuredArrow.homMk (StructuredArrow.homMk φ.right.left\n      (by dsimp; rw [← StructuredArrow.w φ]; rfl))\n      (by ext; exact CostructuredArrow.w φ.right)\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.TwoSquare.EquivalenceJ.inverse_obj","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\nf : w.CostructuredArrowDownwards g\n⊢ Eq ((CategoryTheory.TwoSquare.EquivalenceJ.inverse w g).obj f) (CategoryTheory.StructuredArrow.mk (CategoryTheory.CostructuredArrow.homMk f.left.hom ⋯))","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj X₂ ⟶ B.obj X₃`, this is\nthe obvious functor `w.CostructuredArrowDownwards g ⥤ w.StructuredArrowRightwards g`. -/\n@[simps]\ndef inverse : w.CostructuredArrowDownwards g ⥤ w.StructuredArrowRightwards g where\n  obj f := StructuredArrow.mk (Y := CostructuredArrow.mk f.hom.right)\n      (CostructuredArrow.homMk f.left.hom (by simpa using StructuredArrow.w f.hom))\n  map {f₁ f₂} φ :=\n    StructuredArrow.homMk (CostructuredArrow.homMk φ.left.right\n      (by dsimp; rw [← CostructuredArrow.w φ]; rfl))\n      (by ext; exact StructuredArrow.w φ.left)\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.TwoSquare.EquivalenceJ.inverse_map","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\nf₁ f₂ : w.CostructuredArrowDownwards g\nφ : Quiver.Hom f₁ f₂\n⊢ Eq ((CategoryTheory.TwoSquare.EquivalenceJ.inverse w g).map φ) (CategoryTheory.StructuredArrow.homMk (CategoryTheory.CostructuredArrow.homMk φ.left.right ⋯) ⋯)","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj X₂ ⟶ B.obj X₃`, this is\nthe obvious functor `w.CostructuredArrowDownwards g ⥤ w.StructuredArrowRightwards g`. -/\n@[simps]\ndef inverse : w.CostructuredArrowDownwards g ⥤ w.StructuredArrowRightwards g where\n  obj f := StructuredArrow.mk (Y := CostructuredArrow.mk f.hom.right)\n      (CostructuredArrow.homMk f.left.hom (by simpa using StructuredArrow.w f.hom))\n  map {f₁ f₂} φ :=\n    StructuredArrow.homMk (CostructuredArrow.homMk φ.left.right\n      (by dsimp; rw [← CostructuredArrow.w φ]; rfl))\n      (by ext; exact StructuredArrow.w φ.left)\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.TwoSquare.equivalenceJ_unitIso","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\n⊢ Eq (w.equivalenceJ g).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (w.StructuredArrowRightwards g)))","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj X₂ ⟶ B.obj X₃`, this is\nthe obvious equivalence of categories\n`w.StructuredArrowRightwards g ≌ w.CostructuredArrowDownwards g`. -/\n@[simps functor inverse unitIso counitIso]\ndef equivalenceJ : w.StructuredArrowRightwards g ≌ w.CostructuredArrowDownwards g where\n  functor := EquivalenceJ.functor w g\n  inverse := EquivalenceJ.inverse w g\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.TwoSquare.equivalenceJ_functor","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\n⊢ Eq (w.equivalenceJ g).functor (CategoryTheory.TwoSquare.EquivalenceJ.functor w g)","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj X₂ ⟶ B.obj X₃`, this is\nthe obvious equivalence of categories\n`w.StructuredArrowRightwards g ≌ w.CostructuredArrowDownwards g`. -/\n@[simps functor inverse unitIso counitIso]\ndef equivalenceJ : w.StructuredArrowRightwards g ≌ w.CostructuredArrowDownwards g where\n  functor := EquivalenceJ.functor w g\n  inverse := EquivalenceJ.inverse w g\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.TwoSquare.equivalenceJ_inverse","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\n⊢ Eq (w.equivalenceJ g).inverse (CategoryTheory.TwoSquare.EquivalenceJ.inverse w g)","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj X₂ ⟶ B.obj X₃`, this is\nthe obvious equivalence of categories\n`w.StructuredArrowRightwards g ≌ w.CostructuredArrowDownwards g`. -/\n@[simps functor inverse unitIso counitIso]\ndef equivalenceJ : w.StructuredArrowRightwards g ≌ w.CostructuredArrowDownwards g where\n  functor := EquivalenceJ.functor w g\n  inverse := EquivalenceJ.inverse w g\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.TwoSquare.equivalenceJ_counitIso","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\n⊢ Eq (w.equivalenceJ g).counitIso (CategoryTheory.Iso.refl ((CategoryTheory.TwoSquare.EquivalenceJ.inverse w g).comp (CategoryTheory.TwoSquare.EquivalenceJ.functor w g)))","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj X₂ ⟶ B.obj X₃`, this is\nthe obvious equivalence of categories\n`w.StructuredArrowRightwards g ≌ w.CostructuredArrowDownwards g`. -/\n@[simps functor inverse unitIso counitIso]\ndef equivalenceJ : w.StructuredArrowRightwards g ≌ w.CostructuredArrowDownwards g where\n  functor := EquivalenceJ.functor w g\n  inverse := EquivalenceJ.inverse w g\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.TwoSquare.isConnected_rightwards_iff_downwards","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\n⊢ Iff (CategoryTheory.IsConnected (w.StructuredArrowRightwards g)) (CategoryTheory.IsConnected (w.CostructuredArrowDownwards g))","decl":"lemma isConnected_rightwards_iff_downwards :\n    IsConnected (w.StructuredArrowRightwards g) ↔ IsConnected (w.CostructuredArrowDownwards g) :=\n  isConnected_iff_of_equivalence (w.equivalenceJ g)\n\n"}
{"name":"CategoryTheory.TwoSquare.costructuredArrowDownwardsPrecomp_obj","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ X₂' : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\ng' : Quiver.Hom (R.obj X₂') (B.obj X₃)\nγ : Quiver.Hom X₂' X₂\nhγ : Eq (CategoryTheory.CategoryStruct.comp (R.map γ) g) g'\nA : w.CostructuredArrowDownwards g\n⊢ Eq ((w.costructuredArrowDownwardsPrecomp g g' γ hγ).obj A) (CategoryTheory.TwoSquare.CostructuredArrowDownwards.mk w g' A.left.right (CategoryTheory.CategoryStruct.comp γ A.left.hom) A.hom.right ⋯)","decl":"/-- The functor `w.CostructuredArrowDownwards g ⥤ w.CostructuredArrowDownwards g'` induced\nby a morphism `γ` such that `R.map γ ≫ g = g'`. -/\n@[simps]\ndef costructuredArrowDownwardsPrecomp\n    {X₂ X₂' : C₂} {X₃ : C₃} (g : R.obj X₂ ⟶ B.obj X₃) (g' : R.obj X₂' ⟶ B.obj X₃)\n    (γ : X₂' ⟶ X₂) (hγ : R.map γ ≫ g = g') :\n    w.CostructuredArrowDownwards g ⥤ w.CostructuredArrowDownwards g' where\n  obj A := CostructuredArrowDownwards.mk _ _ A.left.right (γ ≫ A.left.hom) A.hom.right\n    (by simpa [← hγ] using R.map γ ≫= StructuredArrow.w A.hom)\n  map {A A'} φ := CostructuredArrow.homMk (StructuredArrow.homMk φ.left.right (by\n      dsimp\n      rw [assoc, StructuredArrow.w])) (by\n    ext\n    dsimp\n    rw [← CostructuredArrow.w φ, structuredArrowDownwards_map]\n    rfl)\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.TwoSquare.costructuredArrowDownwardsPrecomp_map","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nX₂ X₂' : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\ng' : Quiver.Hom (R.obj X₂') (B.obj X₃)\nγ : Quiver.Hom X₂' X₂\nhγ : Eq (CategoryTheory.CategoryStruct.comp (R.map γ) g) g'\nA A' : w.CostructuredArrowDownwards g\nφ : Quiver.Hom A A'\n⊢ Eq ((w.costructuredArrowDownwardsPrecomp g g' γ hγ).map φ) (CategoryTheory.CostructuredArrow.homMk (CategoryTheory.StructuredArrow.homMk φ.left.right ⋯) ⋯)","decl":"/-- The functor `w.CostructuredArrowDownwards g ⥤ w.CostructuredArrowDownwards g'` induced\nby a morphism `γ` such that `R.map γ ≫ g = g'`. -/\n@[simps]\ndef costructuredArrowDownwardsPrecomp\n    {X₂ X₂' : C₂} {X₃ : C₃} (g : R.obj X₂ ⟶ B.obj X₃) (g' : R.obj X₂' ⟶ B.obj X₃)\n    (γ : X₂' ⟶ X₂) (hγ : R.map γ ≫ g = g') :\n    w.CostructuredArrowDownwards g ⥤ w.CostructuredArrowDownwards g' where\n  obj A := CostructuredArrowDownwards.mk _ _ A.left.right (γ ≫ A.left.hom) A.hom.right\n    (by simpa [← hγ] using R.map γ ≫= StructuredArrow.w A.hom)\n  map {A A'} φ := CostructuredArrow.homMk (StructuredArrow.homMk φ.left.right (by\n      dsimp\n      rw [assoc, StructuredArrow.w])) (by\n    ext\n    dsimp\n    rw [← CostructuredArrow.w φ, structuredArrowDownwards_map]\n    rfl)\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.TwoSquare.GuitartExact.isConnected_rightwards","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nself : w.GuitartExact\nX₂ : C₂\nX₃ : C₃\ng : Quiver.Hom (R.obj X₂) (B.obj X₃)\n⊢ CategoryTheory.IsConnected (w.StructuredArrowRightwards g)","decl":"/-- Condition on `w : TwoSquare T L R B` expressing that it is a Guitart exact square.\nIt is equivalent to saying that for any `X₃ : C₃`, the induced functor\n`CostructuredArrow L X₃ ⥤ CostructuredArrow R (B.obj X₃)` is final (see `guitartExact_iff_final`)\nor equivalently that for any `X₂ : C₂`, the induced functor\n`StructuredArrow X₂ T ⥤ StructuredArrow (R.obj X₂) B` is initial (see `guitartExact_iff_initial`).\nSee also  `guitartExact_iff_isConnected_rightwards`, `guitartExact_iff_isConnected_downwards`\nfor characterizations in terms of the connectedness of auxiliary categories. -/\nclass GuitartExact : Prop where\n  isConnected_rightwards {X₂ : C₂} {X₃ : C₃} (g : R.obj X₂ ⟶ B.obj X₃) :\n    IsConnected (w.StructuredArrowRightwards g)\n\n"}
{"name":"CategoryTheory.TwoSquare.guitartExact_iff_isConnected_rightwards","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\n⊢ Iff w.GuitartExact (∀ {X₂ : C₂} {X₃ : C₃} (g : Quiver.Hom (R.obj X₂) (B.obj X₃)), CategoryTheory.IsConnected (w.StructuredArrowRightwards g))","decl":"lemma guitartExact_iff_isConnected_rightwards :\n    w.GuitartExact ↔ ∀ {X₂ : C₂} {X₃ : C₃} (g : R.obj X₂ ⟶ B.obj X₃),\n      IsConnected (w.StructuredArrowRightwards g) :=\n  ⟨fun h => h.isConnected_rightwards, fun h => ⟨h⟩⟩\n\n"}
{"name":"CategoryTheory.TwoSquare.guitartExact_iff_isConnected_downwards","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\n⊢ Iff w.GuitartExact (∀ {X₂ : C₂} {X₃ : C₃} (g : Quiver.Hom (R.obj X₂) (B.obj X₃)), CategoryTheory.IsConnected (w.CostructuredArrowDownwards g))","decl":"lemma guitartExact_iff_isConnected_downwards :\n    w.GuitartExact ↔ ∀ {X₂ : C₂} {X₃ : C₃} (g : R.obj X₂ ⟶ B.obj X₃),\n      IsConnected (w.CostructuredArrowDownwards g) := by\n  simp only [guitartExact_iff_isConnected_rightwards,\n    isConnected_rightwards_iff_downwards]\n\n"}
{"name":"CategoryTheory.TwoSquare.instIsConnectedStructuredArrowCostructuredArrowObjCostructuredArrowRightwardsOfGuitartExact","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nhw : w.GuitartExact\nX₃ : C₃\ng : CategoryTheory.CostructuredArrow R (B.obj X₃)\n⊢ CategoryTheory.IsConnected (CategoryTheory.StructuredArrow g (w.costructuredArrowRightwards X₃))","decl":"instance [hw : w.GuitartExact] {X₃ : C₃} (g : CostructuredArrow R (B.obj X₃)) :\n    IsConnected (StructuredArrow g (w.costructuredArrowRightwards X₃)) := by\n  rw [guitartExact_iff_isConnected_rightwards] at hw\n  apply hw\n\n"}
{"name":"CategoryTheory.TwoSquare.instIsConnectedCostructuredArrowStructuredArrowObjStructuredArrowDownwardsOfGuitartExact","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nhw : w.GuitartExact\nX₂ : C₂\ng : CategoryTheory.StructuredArrow (R.obj X₂) B\n⊢ CategoryTheory.IsConnected (CategoryTheory.CostructuredArrow (w.structuredArrowDownwards X₂) g)","decl":"instance [hw : w.GuitartExact] {X₂ : C₂} (g : StructuredArrow (R.obj X₂) B) :\n    IsConnected (CostructuredArrow (w.structuredArrowDownwards X₂) g) := by\n  rw [guitartExact_iff_isConnected_downwards] at hw\n  apply hw\n\n"}
{"name":"CategoryTheory.TwoSquare.guitartExact_iff_final","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\n⊢ Iff w.GuitartExact (∀ (X₃ : C₃), (w.costructuredArrowRightwards X₃).Final)","decl":"lemma guitartExact_iff_final :\n    w.GuitartExact ↔ ∀ (X₃ : C₃), (w.costructuredArrowRightwards X₃).Final :=\n  ⟨fun _ _ => ⟨fun _ => inferInstance⟩, fun _ => ⟨fun _ => inferInstance⟩⟩\n\n"}
{"name":"CategoryTheory.TwoSquare.instFinalCostructuredArrowObjCostructuredArrowRightwardsOfGuitartExact","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nhw : w.GuitartExact\nX₃ : C₃\n⊢ (w.costructuredArrowRightwards X₃).Final","decl":"instance [hw : w.GuitartExact] (X₃ : C₃) :\n    (w.costructuredArrowRightwards X₃).Final := by\n  rw [guitartExact_iff_final] at hw\n  apply hw\n\n"}
{"name":"CategoryTheory.TwoSquare.guitartExact_iff_initial","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\n⊢ Iff w.GuitartExact (∀ (X₂ : C₂), (w.structuredArrowDownwards X₂).Initial)","decl":"lemma guitartExact_iff_initial :\n    w.GuitartExact ↔ ∀ (X₂ : C₂), (w.structuredArrowDownwards X₂).Initial :=\n  ⟨fun _ _ => ⟨fun _ => inferInstance⟩, by\n    rw [guitartExact_iff_isConnected_downwards]\n    intros\n    infer_instance⟩\n\n"}
{"name":"CategoryTheory.TwoSquare.instInitialStructuredArrowObjStructuredArrowDownwardsOfGuitartExact","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\nhw : w.GuitartExact\nX₂ : C₂\n⊢ (w.structuredArrowDownwards X₂).Initial","decl":"instance [hw : w.GuitartExact] (X₂ : C₂) :\n    (w.structuredArrowDownwards X₂).Initial := by\n  rw [guitartExact_iff_initial] at hw\n  apply hw\n\n"}
{"name":"CategoryTheory.TwoSquare.guitartExact_of_isEquivalence_of_isIso","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nC₃ : Type u₃\nC₄ : Type u₄\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝⁴ : CategoryTheory.Category.{v₃, u₃} C₃\ninst✝³ : CategoryTheory.Category.{v₄, u₄} C₄\nT : CategoryTheory.Functor C₁ C₂\nL : CategoryTheory.Functor C₁ C₃\nR : CategoryTheory.Functor C₂ C₄\nB : CategoryTheory.Functor C₃ C₄\nw : CategoryTheory.TwoSquare T L R B\ninst✝² : L.IsEquivalence\ninst✝¹ : R.IsEquivalence\ninst✝ : CategoryTheory.IsIso w\n⊢ w.GuitartExact","decl":"/-- When the left and right functors of a 2-square are equivalences, and the natural\ntransformation of the 2-square is an isomorphism, then the 2-square is Guitart exact. -/\ninstance (priority := 100) guitartExact_of_isEquivalence_of_isIso\n    [L.IsEquivalence] [R.IsEquivalence] [IsIso w] : GuitartExact w := by\n  rw [guitartExact_iff_initial]\n  intro X₂\n  have := StructuredArrow.isEquivalence_post X₂ T R\n  have : (Comma.mapRight _ w : StructuredArrow (R.obj X₂) _ ⥤ _).IsEquivalence :=\n    (Comma.mapRightIso _ (asIso w)).isEquivalence_functor\n  have := StructuredArrow.isEquivalence_pre (R.obj X₂) L B\n  dsimp only [structuredArrowDownwards]\n  infer_instance\n\n"}
{"name":"CategoryTheory.TwoSquare.guitartExact_id","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝ : CategoryTheory.Category.{v₂, u₂} C₂\nF : CategoryTheory.Functor C₁ C₂\n⊢ (CategoryTheory.TwoSquare.mk (CategoryTheory.Functor.id C₁) F F (CategoryTheory.Functor.id C₂) (CategoryTheory.CategoryStruct.id F)).GuitartExact","decl":"instance guitartExact_id (F : C₁ ⥤ C₂) :\n    GuitartExact (TwoSquare.mk (𝟭 C₁) F F (𝟭 C₂) (𝟙 F)) := by\n  rw [guitartExact_iff_isConnected_rightwards]\n  intro X₂ X₃ (g : F.obj X₂ ⟶ X₃)\n  let Z := StructuredArrowRightwards (TwoSquare.mk (𝟭 C₁) F F (𝟭 C₂) (𝟙 F)) g\n  let X₀ : Z := StructuredArrow.mk (Y := CostructuredArrow.mk g) (CostructuredArrow.homMk (𝟙 _))\n  have φ : ∀ (X : Z), X₀ ⟶ X := fun X =>\n    StructuredArrow.homMk (CostructuredArrow.homMk X.hom.left\n      (by simpa using CostructuredArrow.w X.hom))\n  have : Nonempty Z := ⟨X₀⟩\n  apply zigzag_isConnected\n  intro X Y\n  exact Zigzag.of_inv_hom (φ X) (φ Y)\n\n"}
