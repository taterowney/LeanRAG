{"name":"CategoryTheory.TwoSquare.ext","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw w' : CategoryTheory.TwoSquare T L R B\nh : âˆ€ (X : Câ‚), Eq (w.app X) (w'.app X)\nâŠ¢ Eq w w'","decl":"@[ext]\nlemma ext (w w' : TwoSquare T L R B) (h : âˆ€ (X : Câ‚), w.app X = w'.app X) :\n    w = w' :=\n  NatTrans.ext (funext h)\n\n"}
{"name":"CategoryTheory.TwoSquare.ext_iff","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw w' : CategoryTheory.TwoSquare T L R B\nâŠ¢ Iff (Eq w w') (âˆ€ (X : Câ‚), Eq (w.app X) (w'.app X))","decl":"@[ext]\nlemma ext (w w' : TwoSquare T L R B) (h : âˆ€ (X : Câ‚), w.app X = w'.app X) :\n    w = w' :=\n  NatTrans.ext (funext h)\n\n"}
{"name":"CategoryTheory.TwoSquare.costructuredArrowRightwards_map","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚ƒ : Câ‚ƒ\nXâœ Yâœ : CategoryTheory.CostructuredArrow L Xâ‚ƒ\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((w.costructuredArrowRightwards Xâ‚ƒ).map f) ((CategoryTheory.CostructuredArrow.pre T R (B.obj Xâ‚ƒ)).map ((CategoryTheory.Comma.mapLeft (CategoryTheory.Functor.fromPUnit (B.obj Xâ‚ƒ)) w).map (CategoryTheory.CostructuredArrow.homMk f.left â‹¯)))","decl":"/-- Given `w : TwoSquare T L R B` and `Xâ‚ƒ : Câ‚ƒ`, this is the obvious functor\n`CostructuredArrow L Xâ‚ƒ â¥¤ CostructuredArrow R (B.obj Xâ‚ƒ)`. -/\n@[simps! obj map]\ndef costructuredArrowRightwards (Xâ‚ƒ : Câ‚ƒ) :\n    CostructuredArrow L Xâ‚ƒ â¥¤ CostructuredArrow R (B.obj Xâ‚ƒ) :=\n  CostructuredArrow.post L B Xâ‚ƒ â‹™ Comma.mapLeft _ w â‹™\n    CostructuredArrow.pre T R (B.obj Xâ‚ƒ)\n\n"}
{"name":"CategoryTheory.TwoSquare.costructuredArrowRightwards_obj","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚ƒ : Câ‚ƒ\nX : CategoryTheory.CostructuredArrow L Xâ‚ƒ\nâŠ¢ Eq ((w.costructuredArrowRightwards Xâ‚ƒ).obj X) ((CategoryTheory.CostructuredArrow.pre T R (B.obj Xâ‚ƒ)).obj ((CategoryTheory.Comma.mapLeft (CategoryTheory.Functor.fromPUnit (B.obj Xâ‚ƒ)) w).obj (CategoryTheory.CostructuredArrow.mk (B.map X.hom))))","decl":"/-- Given `w : TwoSquare T L R B` and `Xâ‚ƒ : Câ‚ƒ`, this is the obvious functor\n`CostructuredArrow L Xâ‚ƒ â¥¤ CostructuredArrow R (B.obj Xâ‚ƒ)`. -/\n@[simps! obj map]\ndef costructuredArrowRightwards (Xâ‚ƒ : Câ‚ƒ) :\n    CostructuredArrow L Xâ‚ƒ â¥¤ CostructuredArrow R (B.obj Xâ‚ƒ) :=\n  CostructuredArrow.post L B Xâ‚ƒ â‹™ Comma.mapLeft _ w â‹™\n    CostructuredArrow.pre T R (B.obj Xâ‚ƒ)\n\n"}
{"name":"CategoryTheory.TwoSquare.structuredArrowDownwards_obj","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ : Câ‚‚\nX : CategoryTheory.StructuredArrow Xâ‚‚ T\nâŠ¢ Eq ((w.structuredArrowDownwards Xâ‚‚).obj X) ((CategoryTheory.StructuredArrow.pre (R.obj Xâ‚‚) L B).obj ((CategoryTheory.Comma.mapRight (CategoryTheory.Functor.fromPUnit (R.obj Xâ‚‚)) w).obj (CategoryTheory.StructuredArrow.mk (R.map X.hom))))","decl":"/-- Given `w : TwoSquare T L R B` and `Xâ‚‚ : Câ‚‚`, this is the obvious functor\n`StructuredArrow Xâ‚‚ T â¥¤ StructuredArrow (R.obj Xâ‚‚) B`. -/\n@[simps! obj map]\ndef structuredArrowDownwards (Xâ‚‚ : Câ‚‚) :\n    StructuredArrow Xâ‚‚ T â¥¤ StructuredArrow (R.obj Xâ‚‚) B :=\n  StructuredArrow.post Xâ‚‚ T R â‹™ Comma.mapRight _ w â‹™\n    StructuredArrow.pre (R.obj Xâ‚‚) L B\n\n"}
{"name":"CategoryTheory.TwoSquare.structuredArrowDownwards_map","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ : Câ‚‚\nXâœ Yâœ : CategoryTheory.StructuredArrow Xâ‚‚ T\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((w.structuredArrowDownwards Xâ‚‚).map f) ((CategoryTheory.StructuredArrow.pre (R.obj Xâ‚‚) L B).map ((CategoryTheory.Comma.mapRight (CategoryTheory.Functor.fromPUnit (R.obj Xâ‚‚)) w).map (CategoryTheory.StructuredArrow.homMk f.right â‹¯)))","decl":"/-- Given `w : TwoSquare T L R B` and `Xâ‚‚ : Câ‚‚`, this is the obvious functor\n`StructuredArrow Xâ‚‚ T â¥¤ StructuredArrow (R.obj Xâ‚‚) B`. -/\n@[simps! obj map]\ndef structuredArrowDownwards (Xâ‚‚ : Câ‚‚) :\n    StructuredArrow Xâ‚‚ T â¥¤ StructuredArrow (R.obj Xâ‚‚) B :=\n  StructuredArrow.post Xâ‚‚ T R â‹™ Comma.mapRight _ w â‹™\n    StructuredArrow.pre (R.obj Xâ‚‚) L B\n\n"}
{"name":"CategoryTheory.TwoSquare.StructuredArrowRightwards.mk_surjective","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\nf : w.StructuredArrowRightwards g\nâŠ¢ Exists fun Xâ‚ => Exists fun a => Exists fun b => Exists fun comm => Eq f (CategoryTheory.TwoSquare.StructuredArrowRightwards.mk w g Xâ‚ a b comm)","decl":"lemma StructuredArrowRightwards.mk_surjective\n    (f : w.StructuredArrowRightwards g) :\n    âˆƒ (Xâ‚ : Câ‚) (a : Xâ‚‚ âŸ¶ T.obj Xâ‚) (b : L.obj Xâ‚ âŸ¶ Xâ‚ƒ)\n      (comm : R.map a â‰« w.app Xâ‚ â‰« B.map b = g), f = mk w g Xâ‚ a b comm := by\n  obtain âŸ¨g, Ï†, rflâŸ© := StructuredArrow.mk_surjective f\n  obtain âŸ¨Xâ‚, b, rflâŸ© := g.mk_surjective\n  obtain âŸ¨a, ha, rflâŸ© := CostructuredArrow.homMk_surjective Ï†\n  exact âŸ¨Xâ‚, a, b, by simpa using ha, rflâŸ©\n\n"}
{"name":"CategoryTheory.TwoSquare.CostructuredArrowDownwards.mk_surjective","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\nf : w.CostructuredArrowDownwards g\nâŠ¢ Exists fun Xâ‚ => Exists fun a => Exists fun b => Exists fun comm => Eq f (CategoryTheory.TwoSquare.CostructuredArrowDownwards.mk w g Xâ‚ a b comm)","decl":"lemma CostructuredArrowDownwards.mk_surjective\n    (f : w.CostructuredArrowDownwards g) :\n    âˆƒ (Xâ‚ : Câ‚) (a : Xâ‚‚ âŸ¶ T.obj Xâ‚) (b : L.obj Xâ‚ âŸ¶ Xâ‚ƒ)\n      (comm : R.map a â‰« w.app Xâ‚ â‰« B.map b = g), f = mk w g Xâ‚ a b comm := by\n  obtain âŸ¨g, Ï†, rflâŸ© := CostructuredArrow.mk_surjective f\n  obtain âŸ¨Xâ‚, a, rflâŸ© := g.mk_surjective\n  obtain âŸ¨b, hb, rflâŸ© := StructuredArrow.homMk_surjective Ï†\n  exact âŸ¨Xâ‚, a, b, by simpa using hb, rflâŸ©\n\n"}
{"name":"CategoryTheory.TwoSquare.EquivalenceJ.functor_obj","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\nf : w.StructuredArrowRightwards g\nâŠ¢ Eq ((CategoryTheory.TwoSquare.EquivalenceJ.functor w g).obj f) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.StructuredArrow.homMk f.right.hom â‹¯))","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj Xâ‚‚ âŸ¶ B.obj Xâ‚ƒ`, this is\nthe obvious functor `w.StructuredArrowRightwards g â¥¤ w.CostructuredArrowDownwards g`. -/\n@[simps]\ndef functor : w.StructuredArrowRightwards g â¥¤ w.CostructuredArrowDownwards g where\n  obj f := CostructuredArrow.mk (Y := StructuredArrow.mk f.hom.left)\n      (StructuredArrow.homMk f.right.hom (by simpa using CostructuredArrow.w f.hom))\n  map {fâ‚ fâ‚‚} Ï† :=\n    CostructuredArrow.homMk (StructuredArrow.homMk Ï†.right.left\n      (by dsimp; rw [â† StructuredArrow.w Ï†]; rfl))\n      (by ext; exact CostructuredArrow.w Ï†.right)\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.TwoSquare.EquivalenceJ.functor_map","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\nfâ‚ fâ‚‚ : w.StructuredArrowRightwards g\nÏ† : Quiver.Hom fâ‚ fâ‚‚\nâŠ¢ Eq ((CategoryTheory.TwoSquare.EquivalenceJ.functor w g).map Ï†) (CategoryTheory.CostructuredArrow.homMk (CategoryTheory.StructuredArrow.homMk Ï†.right.left â‹¯) â‹¯)","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj Xâ‚‚ âŸ¶ B.obj Xâ‚ƒ`, this is\nthe obvious functor `w.StructuredArrowRightwards g â¥¤ w.CostructuredArrowDownwards g`. -/\n@[simps]\ndef functor : w.StructuredArrowRightwards g â¥¤ w.CostructuredArrowDownwards g where\n  obj f := CostructuredArrow.mk (Y := StructuredArrow.mk f.hom.left)\n      (StructuredArrow.homMk f.right.hom (by simpa using CostructuredArrow.w f.hom))\n  map {fâ‚ fâ‚‚} Ï† :=\n    CostructuredArrow.homMk (StructuredArrow.homMk Ï†.right.left\n      (by dsimp; rw [â† StructuredArrow.w Ï†]; rfl))\n      (by ext; exact CostructuredArrow.w Ï†.right)\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.TwoSquare.EquivalenceJ.inverse_obj","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\nf : w.CostructuredArrowDownwards g\nâŠ¢ Eq ((CategoryTheory.TwoSquare.EquivalenceJ.inverse w g).obj f) (CategoryTheory.StructuredArrow.mk (CategoryTheory.CostructuredArrow.homMk f.left.hom â‹¯))","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj Xâ‚‚ âŸ¶ B.obj Xâ‚ƒ`, this is\nthe obvious functor `w.CostructuredArrowDownwards g â¥¤ w.StructuredArrowRightwards g`. -/\n@[simps]\ndef inverse : w.CostructuredArrowDownwards g â¥¤ w.StructuredArrowRightwards g where\n  obj f := StructuredArrow.mk (Y := CostructuredArrow.mk f.hom.right)\n      (CostructuredArrow.homMk f.left.hom (by simpa using StructuredArrow.w f.hom))\n  map {fâ‚ fâ‚‚} Ï† :=\n    StructuredArrow.homMk (CostructuredArrow.homMk Ï†.left.right\n      (by dsimp; rw [â† CostructuredArrow.w Ï†]; rfl))\n      (by ext; exact StructuredArrow.w Ï†.left)\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.TwoSquare.EquivalenceJ.inverse_map","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\nfâ‚ fâ‚‚ : w.CostructuredArrowDownwards g\nÏ† : Quiver.Hom fâ‚ fâ‚‚\nâŠ¢ Eq ((CategoryTheory.TwoSquare.EquivalenceJ.inverse w g).map Ï†) (CategoryTheory.StructuredArrow.homMk (CategoryTheory.CostructuredArrow.homMk Ï†.left.right â‹¯) â‹¯)","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj Xâ‚‚ âŸ¶ B.obj Xâ‚ƒ`, this is\nthe obvious functor `w.CostructuredArrowDownwards g â¥¤ w.StructuredArrowRightwards g`. -/\n@[simps]\ndef inverse : w.CostructuredArrowDownwards g â¥¤ w.StructuredArrowRightwards g where\n  obj f := StructuredArrow.mk (Y := CostructuredArrow.mk f.hom.right)\n      (CostructuredArrow.homMk f.left.hom (by simpa using StructuredArrow.w f.hom))\n  map {fâ‚ fâ‚‚} Ï† :=\n    StructuredArrow.homMk (CostructuredArrow.homMk Ï†.left.right\n      (by dsimp; rw [â† CostructuredArrow.w Ï†]; rfl))\n      (by ext; exact StructuredArrow.w Ï†.left)\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.TwoSquare.equivalenceJ_unitIso","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\nâŠ¢ Eq (w.equivalenceJ g).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (w.StructuredArrowRightwards g)))","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj Xâ‚‚ âŸ¶ B.obj Xâ‚ƒ`, this is\nthe obvious equivalence of categories\n`w.StructuredArrowRightwards g â‰Œ w.CostructuredArrowDownwards g`. -/\n@[simps functor inverse unitIso counitIso]\ndef equivalenceJ : w.StructuredArrowRightwards g â‰Œ w.CostructuredArrowDownwards g where\n  functor := EquivalenceJ.functor w g\n  inverse := EquivalenceJ.inverse w g\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.TwoSquare.equivalenceJ_functor","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\nâŠ¢ Eq (w.equivalenceJ g).functor (CategoryTheory.TwoSquare.EquivalenceJ.functor w g)","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj Xâ‚‚ âŸ¶ B.obj Xâ‚ƒ`, this is\nthe obvious equivalence of categories\n`w.StructuredArrowRightwards g â‰Œ w.CostructuredArrowDownwards g`. -/\n@[simps functor inverse unitIso counitIso]\ndef equivalenceJ : w.StructuredArrowRightwards g â‰Œ w.CostructuredArrowDownwards g where\n  functor := EquivalenceJ.functor w g\n  inverse := EquivalenceJ.inverse w g\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.TwoSquare.equivalenceJ_inverse","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\nâŠ¢ Eq (w.equivalenceJ g).inverse (CategoryTheory.TwoSquare.EquivalenceJ.inverse w g)","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj Xâ‚‚ âŸ¶ B.obj Xâ‚ƒ`, this is\nthe obvious equivalence of categories\n`w.StructuredArrowRightwards g â‰Œ w.CostructuredArrowDownwards g`. -/\n@[simps functor inverse unitIso counitIso]\ndef equivalenceJ : w.StructuredArrowRightwards g â‰Œ w.CostructuredArrowDownwards g where\n  functor := EquivalenceJ.functor w g\n  inverse := EquivalenceJ.inverse w g\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.TwoSquare.equivalenceJ_counitIso","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\nâŠ¢ Eq (w.equivalenceJ g).counitIso (CategoryTheory.Iso.refl ((CategoryTheory.TwoSquare.EquivalenceJ.inverse w g).comp (CategoryTheory.TwoSquare.EquivalenceJ.functor w g)))","decl":"/-- Given `w : TwoSquare T L R B` and a morphism `g : R.obj Xâ‚‚ âŸ¶ B.obj Xâ‚ƒ`, this is\nthe obvious equivalence of categories\n`w.StructuredArrowRightwards g â‰Œ w.CostructuredArrowDownwards g`. -/\n@[simps functor inverse unitIso counitIso]\ndef equivalenceJ : w.StructuredArrowRightwards g â‰Œ w.CostructuredArrowDownwards g where\n  functor := EquivalenceJ.functor w g\n  inverse := EquivalenceJ.inverse w g\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.TwoSquare.isConnected_rightwards_iff_downwards","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\nâŠ¢ Iff (CategoryTheory.IsConnected (w.StructuredArrowRightwards g)) (CategoryTheory.IsConnected (w.CostructuredArrowDownwards g))","decl":"lemma isConnected_rightwards_iff_downwards :\n    IsConnected (w.StructuredArrowRightwards g) â†” IsConnected (w.CostructuredArrowDownwards g) :=\n  isConnected_iff_of_equivalence (w.equivalenceJ g)\n\n"}
{"name":"CategoryTheory.TwoSquare.costructuredArrowDownwardsPrecomp_obj","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ Xâ‚‚' : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\ng' : Quiver.Hom (R.obj Xâ‚‚') (B.obj Xâ‚ƒ)\nÎ³ : Quiver.Hom Xâ‚‚' Xâ‚‚\nhÎ³ : Eq (CategoryTheory.CategoryStruct.comp (R.map Î³) g) g'\nA : w.CostructuredArrowDownwards g\nâŠ¢ Eq ((w.costructuredArrowDownwardsPrecomp g g' Î³ hÎ³).obj A) (CategoryTheory.TwoSquare.CostructuredArrowDownwards.mk w g' A.left.right (CategoryTheory.CategoryStruct.comp Î³ A.left.hom) A.hom.right â‹¯)","decl":"/-- The functor `w.CostructuredArrowDownwards g â¥¤ w.CostructuredArrowDownwards g'` induced\nby a morphism `Î³` such that `R.map Î³ â‰« g = g'`. -/\n@[simps]\ndef costructuredArrowDownwardsPrecomp\n    {Xâ‚‚ Xâ‚‚' : Câ‚‚} {Xâ‚ƒ : Câ‚ƒ} (g : R.obj Xâ‚‚ âŸ¶ B.obj Xâ‚ƒ) (g' : R.obj Xâ‚‚' âŸ¶ B.obj Xâ‚ƒ)\n    (Î³ : Xâ‚‚' âŸ¶ Xâ‚‚) (hÎ³ : R.map Î³ â‰« g = g') :\n    w.CostructuredArrowDownwards g â¥¤ w.CostructuredArrowDownwards g' where\n  obj A := CostructuredArrowDownwards.mk _ _ A.left.right (Î³ â‰« A.left.hom) A.hom.right\n    (by simpa [â† hÎ³] using R.map Î³ â‰«= StructuredArrow.w A.hom)\n  map {A A'} Ï† := CostructuredArrow.homMk (StructuredArrow.homMk Ï†.left.right (by\n      dsimp\n      rw [assoc, StructuredArrow.w])) (by\n    ext\n    dsimp\n    rw [â† CostructuredArrow.w Ï†, structuredArrowDownwards_map]\n    rfl)\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.TwoSquare.costructuredArrowDownwardsPrecomp_map","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nXâ‚‚ Xâ‚‚' : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\ng' : Quiver.Hom (R.obj Xâ‚‚') (B.obj Xâ‚ƒ)\nÎ³ : Quiver.Hom Xâ‚‚' Xâ‚‚\nhÎ³ : Eq (CategoryTheory.CategoryStruct.comp (R.map Î³) g) g'\nA A' : w.CostructuredArrowDownwards g\nÏ† : Quiver.Hom A A'\nâŠ¢ Eq ((w.costructuredArrowDownwardsPrecomp g g' Î³ hÎ³).map Ï†) (CategoryTheory.CostructuredArrow.homMk (CategoryTheory.StructuredArrow.homMk Ï†.left.right â‹¯) â‹¯)","decl":"/-- The functor `w.CostructuredArrowDownwards g â¥¤ w.CostructuredArrowDownwards g'` induced\nby a morphism `Î³` such that `R.map Î³ â‰« g = g'`. -/\n@[simps]\ndef costructuredArrowDownwardsPrecomp\n    {Xâ‚‚ Xâ‚‚' : Câ‚‚} {Xâ‚ƒ : Câ‚ƒ} (g : R.obj Xâ‚‚ âŸ¶ B.obj Xâ‚ƒ) (g' : R.obj Xâ‚‚' âŸ¶ B.obj Xâ‚ƒ)\n    (Î³ : Xâ‚‚' âŸ¶ Xâ‚‚) (hÎ³ : R.map Î³ â‰« g = g') :\n    w.CostructuredArrowDownwards g â¥¤ w.CostructuredArrowDownwards g' where\n  obj A := CostructuredArrowDownwards.mk _ _ A.left.right (Î³ â‰« A.left.hom) A.hom.right\n    (by simpa [â† hÎ³] using R.map Î³ â‰«= StructuredArrow.w A.hom)\n  map {A A'} Ï† := CostructuredArrow.homMk (StructuredArrow.homMk Ï†.left.right (by\n      dsimp\n      rw [assoc, StructuredArrow.w])) (by\n    ext\n    dsimp\n    rw [â† CostructuredArrow.w Ï†, structuredArrowDownwards_map]\n    rfl)\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.TwoSquare.GuitartExact.isConnected_rightwards","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nself : w.GuitartExact\nXâ‚‚ : Câ‚‚\nXâ‚ƒ : Câ‚ƒ\ng : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)\nâŠ¢ CategoryTheory.IsConnected (w.StructuredArrowRightwards g)","decl":"/-- Condition on `w : TwoSquare T L R B` expressing that it is a Guitart exact square.\nIt is equivalent to saying that for any `Xâ‚ƒ : Câ‚ƒ`, the induced functor\n`CostructuredArrow L Xâ‚ƒ â¥¤ CostructuredArrow R (B.obj Xâ‚ƒ)` is final (see `guitartExact_iff_final`)\nor equivalently that for any `Xâ‚‚ : Câ‚‚`, the induced functor\n`StructuredArrow Xâ‚‚ T â¥¤ StructuredArrow (R.obj Xâ‚‚) B` is initial (see `guitartExact_iff_initial`).\nSee also  `guitartExact_iff_isConnected_rightwards`, `guitartExact_iff_isConnected_downwards`\nfor characterizations in terms of the connectedness of auxiliary categories. -/\nclass GuitartExact : Prop where\n  isConnected_rightwards {Xâ‚‚ : Câ‚‚} {Xâ‚ƒ : Câ‚ƒ} (g : R.obj Xâ‚‚ âŸ¶ B.obj Xâ‚ƒ) :\n    IsConnected (w.StructuredArrowRightwards g)\n\n"}
{"name":"CategoryTheory.TwoSquare.guitartExact_iff_isConnected_rightwards","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nâŠ¢ Iff w.GuitartExact (âˆ€ {Xâ‚‚ : Câ‚‚} {Xâ‚ƒ : Câ‚ƒ} (g : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)), CategoryTheory.IsConnected (w.StructuredArrowRightwards g))","decl":"lemma guitartExact_iff_isConnected_rightwards :\n    w.GuitartExact â†” âˆ€ {Xâ‚‚ : Câ‚‚} {Xâ‚ƒ : Câ‚ƒ} (g : R.obj Xâ‚‚ âŸ¶ B.obj Xâ‚ƒ),\n      IsConnected (w.StructuredArrowRightwards g) :=\n  âŸ¨fun h => h.isConnected_rightwards, fun h => âŸ¨hâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.TwoSquare.guitartExact_iff_isConnected_downwards","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nâŠ¢ Iff w.GuitartExact (âˆ€ {Xâ‚‚ : Câ‚‚} {Xâ‚ƒ : Câ‚ƒ} (g : Quiver.Hom (R.obj Xâ‚‚) (B.obj Xâ‚ƒ)), CategoryTheory.IsConnected (w.CostructuredArrowDownwards g))","decl":"lemma guitartExact_iff_isConnected_downwards :\n    w.GuitartExact â†” âˆ€ {Xâ‚‚ : Câ‚‚} {Xâ‚ƒ : Câ‚ƒ} (g : R.obj Xâ‚‚ âŸ¶ B.obj Xâ‚ƒ),\n      IsConnected (w.CostructuredArrowDownwards g) := by\n  simp only [guitartExact_iff_isConnected_rightwards,\n    isConnected_rightwards_iff_downwards]\n\n"}
{"name":"CategoryTheory.TwoSquare.instIsConnectedStructuredArrowCostructuredArrowObjCostructuredArrowRightwardsOfGuitartExact","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nhw : w.GuitartExact\nXâ‚ƒ : Câ‚ƒ\ng : CategoryTheory.CostructuredArrow R (B.obj Xâ‚ƒ)\nâŠ¢ CategoryTheory.IsConnected (CategoryTheory.StructuredArrow g (w.costructuredArrowRightwards Xâ‚ƒ))","decl":"instance [hw : w.GuitartExact] {Xâ‚ƒ : Câ‚ƒ} (g : CostructuredArrow R (B.obj Xâ‚ƒ)) :\n    IsConnected (StructuredArrow g (w.costructuredArrowRightwards Xâ‚ƒ)) := by\n  rw [guitartExact_iff_isConnected_rightwards] at hw\n  apply hw\n\n"}
{"name":"CategoryTheory.TwoSquare.instIsConnectedCostructuredArrowStructuredArrowObjStructuredArrowDownwardsOfGuitartExact","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nhw : w.GuitartExact\nXâ‚‚ : Câ‚‚\ng : CategoryTheory.StructuredArrow (R.obj Xâ‚‚) B\nâŠ¢ CategoryTheory.IsConnected (CategoryTheory.CostructuredArrow (w.structuredArrowDownwards Xâ‚‚) g)","decl":"instance [hw : w.GuitartExact] {Xâ‚‚ : Câ‚‚} (g : StructuredArrow (R.obj Xâ‚‚) B) :\n    IsConnected (CostructuredArrow (w.structuredArrowDownwards Xâ‚‚) g) := by\n  rw [guitartExact_iff_isConnected_downwards] at hw\n  apply hw\n\n"}
{"name":"CategoryTheory.TwoSquare.guitartExact_iff_final","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nâŠ¢ Iff w.GuitartExact (âˆ€ (Xâ‚ƒ : Câ‚ƒ), (w.costructuredArrowRightwards Xâ‚ƒ).Final)","decl":"lemma guitartExact_iff_final :\n    w.GuitartExact â†” âˆ€ (Xâ‚ƒ : Câ‚ƒ), (w.costructuredArrowRightwards Xâ‚ƒ).Final :=\n  âŸ¨fun _ _ => âŸ¨fun _ => inferInstanceâŸ©, fun _ => âŸ¨fun _ => inferInstanceâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.TwoSquare.instFinalCostructuredArrowObjCostructuredArrowRightwardsOfGuitartExact","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nhw : w.GuitartExact\nXâ‚ƒ : Câ‚ƒ\nâŠ¢ (w.costructuredArrowRightwards Xâ‚ƒ).Final","decl":"instance [hw : w.GuitartExact] (Xâ‚ƒ : Câ‚ƒ) :\n    (w.costructuredArrowRightwards Xâ‚ƒ).Final := by\n  rw [guitartExact_iff_final] at hw\n  apply hw\n\n"}
{"name":"CategoryTheory.TwoSquare.guitartExact_iff_initial","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nâŠ¢ Iff w.GuitartExact (âˆ€ (Xâ‚‚ : Câ‚‚), (w.structuredArrowDownwards Xâ‚‚).Initial)","decl":"lemma guitartExact_iff_initial :\n    w.GuitartExact â†” âˆ€ (Xâ‚‚ : Câ‚‚), (w.structuredArrowDownwards Xâ‚‚).Initial :=\n  âŸ¨fun _ _ => âŸ¨fun _ => inferInstanceâŸ©, by\n    rw [guitartExact_iff_isConnected_downwards]\n    intros\n    infer_instanceâŸ©\n\n"}
{"name":"CategoryTheory.TwoSquare.instInitialStructuredArrowObjStructuredArrowDownwardsOfGuitartExact","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\nhw : w.GuitartExact\nXâ‚‚ : Câ‚‚\nâŠ¢ (w.structuredArrowDownwards Xâ‚‚).Initial","decl":"instance [hw : w.GuitartExact] (Xâ‚‚ : Câ‚‚) :\n    (w.structuredArrowDownwards Xâ‚‚).Initial := by\n  rw [guitartExact_iff_initial] at hw\n  apply hw\n\n"}
{"name":"CategoryTheory.TwoSquare.guitartExact_of_isEquivalence_of_isIso","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\nCâ‚ƒ : Type uâ‚ƒ\nCâ‚„ : Type uâ‚„\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} Câ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚„, uâ‚„} Câ‚„\nT : CategoryTheory.Functor Câ‚ Câ‚‚\nL : CategoryTheory.Functor Câ‚ Câ‚ƒ\nR : CategoryTheory.Functor Câ‚‚ Câ‚„\nB : CategoryTheory.Functor Câ‚ƒ Câ‚„\nw : CategoryTheory.TwoSquare T L R B\ninstâœÂ² : L.IsEquivalence\ninstâœÂ¹ : R.IsEquivalence\ninstâœ : CategoryTheory.IsIso w\nâŠ¢ w.GuitartExact","decl":"/-- When the left and right functors of a 2-square are equivalences, and the natural\ntransformation of the 2-square is an isomorphism, then the 2-square is Guitart exact. -/\ninstance (priority := 100) guitartExact_of_isEquivalence_of_isIso\n    [L.IsEquivalence] [R.IsEquivalence] [IsIso w] : GuitartExact w := by\n  rw [guitartExact_iff_initial]\n  intro Xâ‚‚\n  have := StructuredArrow.isEquivalence_post Xâ‚‚ T R\n  have : (Comma.mapRight _ w : StructuredArrow (R.obj Xâ‚‚) _ â¥¤ _).IsEquivalence :=\n    (Comma.mapRightIso _ (asIso w)).isEquivalence_functor\n  have := StructuredArrow.isEquivalence_pre (R.obj Xâ‚‚) L B\n  dsimp only [structuredArrowDownwards]\n  infer_instance\n\n"}
{"name":"CategoryTheory.TwoSquare.guitartExact_id","module":"Mathlib.CategoryTheory.GuitartExact.Basic","initialProofState":"Câ‚ : Type uâ‚\nCâ‚‚ : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} Câ‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} Câ‚‚\nF : CategoryTheory.Functor Câ‚ Câ‚‚\nâŠ¢ (CategoryTheory.TwoSquare.mk (CategoryTheory.Functor.id Câ‚) F F (CategoryTheory.Functor.id Câ‚‚) (CategoryTheory.CategoryStruct.id F)).GuitartExact","decl":"instance guitartExact_id (F : Câ‚ â¥¤ Câ‚‚) :\n    GuitartExact (TwoSquare.mk (ðŸ­ Câ‚) F F (ðŸ­ Câ‚‚) (ðŸ™ F)) := by\n  rw [guitartExact_iff_isConnected_rightwards]\n  intro Xâ‚‚ Xâ‚ƒ (g : F.obj Xâ‚‚ âŸ¶ Xâ‚ƒ)\n  let Z := StructuredArrowRightwards (TwoSquare.mk (ðŸ­ Câ‚) F F (ðŸ­ Câ‚‚) (ðŸ™ F)) g\n  let Xâ‚€ : Z := StructuredArrow.mk (Y := CostructuredArrow.mk g) (CostructuredArrow.homMk (ðŸ™ _))\n  have Ï† : âˆ€ (X : Z), Xâ‚€ âŸ¶ X := fun X =>\n    StructuredArrow.homMk (CostructuredArrow.homMk X.hom.left\n      (by simpa using CostructuredArrow.w X.hom))\n  have : Nonempty Z := âŸ¨Xâ‚€âŸ©\n  apply zigzag_isConnected\n  intro X Y\n  exact Zigzag.of_inv_hom (Ï† X) (Ï† Y)\n\n"}
