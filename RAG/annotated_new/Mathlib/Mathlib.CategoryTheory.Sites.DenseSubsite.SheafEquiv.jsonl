{"name":"CategoryTheory.Functor.IsDenseSubsite.isIso_ranCounit_app_of_isDenseSubsite","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.SheafEquiv","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nA : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} A\ninst‚úù¬π : ‚àÄ (X : Opposite D), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.StructuredArrow X G.op) A\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\nY : CategoryTheory.Sheaf J A\nU : C\nX : A\n‚ä¢ CategoryTheory.IsIso ((CategoryTheory.yoneda.map ((G.op.ranCounit.app Y.val).app { unop := U })).app { unop := X })","decl":"include K in\nlemma isIso_ranCounit_app_of_isDenseSubsite (Y : Sheaf J A) (U X) :\n    IsIso ((yoneda.map ((G.op.ranCounit.app Y.val).app (op U))).app (op X)) := by\n  rw [isIso_iff_bijective]\n  constructor\n  ¬∑ intro f‚ÇÅ f‚ÇÇ e\n    apply (isPointwiseRightKanExtensionRanCounit G.op Y.1 (.op (G.obj U))).hom_ext\n    rintro ‚ü®‚ü®‚ü®‚ü©‚ü©, ‚ü®W‚ü©, g‚ü©\n    obtain ‚ü®g, rfl‚ü© : ‚àÉ g' : G.obj W ‚ü∂ G.obj U, g = g'.op := ‚ü®g.unop, rfl‚ü©\n    apply (Y.2 X _ (IsDenseSubsite.imageSieve_mem J K G g)).isSeparatedFor.ext\n    dsimp\n    rintro V iVW ‚ü®iVU, e'‚ü©\n    have := congr($e ‚â´ Y.1.map iVU.op)\n    simp only [comp_obj, yoneda_map_app, Category.assoc, coyoneda_obj_obj, comp_map,\n      coyoneda_obj_map, ‚Üê NatTrans.naturality, op_obj, op_map, Quiver.Hom.unop_op, ‚Üê map_comp_assoc,\n      ‚Üê op_comp, ‚Üê e'] at this ‚ä¢\n    erw [‚Üê NatTrans.naturality] at this\n    exact this\n  ¬∑ intro f\n    have (X Y Z) (f : X ‚ü∂ Y) (g : G.obj Y ‚ü∂ G.obj Z) (hf : G.imageSieve g f) : Exists _ := hf\n    choose l hl using this\n    let c : Limits.Cone (StructuredArrow.proj (op (G.obj U)) G.op ‚ãô Y.val) := by\n      refine ‚ü®X, ‚ü®fun g ‚Ü¶ ?_, ?_‚ü©‚ü©\n      ¬∑ refine Y.2.amalgamate ‚ü®_, IsDenseSubsite.imageSieve_mem J K G g.hom.unop‚ü©\n          (fun I ‚Ü¶ f ‚â´ Y.1.map (l _ _ _ _ _ I.hf).op) fun I‚ÇÅ I‚ÇÇ r ‚Ü¶ ?_\n        apply (Y.2 X _ (IsDenseSubsite.equalizer_mem J K G (r.g‚ÇÅ ‚â´ l _ _ _ _ _ I‚ÇÅ.hf)\n          (r.g‚ÇÇ ‚â´ l _ _ _ _ _ I‚ÇÇ.hf) ?_)).isSeparatedFor.ext fun V iUV (hiUV : _ = _) ‚Ü¶ ?_\n        ¬∑ simp only [const_obj_obj, op_obj, map_comp, hl]\n          simp only [‚Üê map_comp_assoc, r.w]\n        ¬∑ simp [‚Üê map_comp, ‚Üê op_comp, hiUV]\n      ¬∑ dsimp\n        rintro ‚ü®‚ü®‚ü®‚ü©‚ü©, ‚ü®W‚ÇÅ‚ü©, g‚ÇÅ‚ü© ‚ü®‚ü®‚ü®‚ü©‚ü©, ‚ü®W‚ÇÇ‚ü©, g‚ÇÇ‚ü© ‚ü®‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©, i, hi‚ü©\n        dsimp at g‚ÇÅ g‚ÇÇ i hi\n        -- See issue https://github.com/leanprover-community/mathlib4/pull/15781 for tracking performance regressions of `rintro` as here\n        have h : g‚ÇÇ = g‚ÇÅ ‚â´ (G.map i.unop).op := by simpa only [Category.id_comp] using hi\n        rcases h with ‚ü®rfl‚ü©\n        have h : ‚àÉ g' : G.obj W‚ÇÅ ‚ü∂ G.obj U, g‚ÇÅ = g'.op := ‚ü®g‚ÇÅ.unop, rfl‚ü©\n        rcases h with ‚ü®g, rfl‚ü©\n        have h : ‚àÉ i' : W‚ÇÇ ‚ü∂ W‚ÇÅ, i = i'.op := ‚ü®i.unop, rfl‚ü©\n        rcases h with ‚ü®i, rfl‚ü©\n        simp only [const_obj_obj, id_obj, comp_obj, StructuredArrow.proj_obj, const_obj_map, op_obj,\n          unop_comp, Quiver.Hom.unop_op, Category.id_comp, comp_map, StructuredArrow.proj_map]\n        apply Y.2.hom_ext ‚ü®_, IsDenseSubsite.imageSieve_mem J K G (G.map i ‚â´ g)‚ü©\n        intro I\n        simp only [Presheaf.IsSheaf.amalgamate_map, Category.assoc, ‚Üê Functor.map_comp, ‚Üê op_comp]\n        let I' : GrothendieckTopology.Cover.Arrow ‚ü®_, IsDenseSubsite.imageSieve_mem J K G g‚ü© :=\n          ‚ü®_, I.f ‚â´ i, ‚ü®l _ _ _ _ _ I.hf, by simp [hl]‚ü©‚ü©\n        refine Eq.trans ?_ (Y.2.amalgamate_map _ _ _ I').symm\n        apply (Y.2 X _ (IsDenseSubsite.equalizer_mem J K G (l _ _ _ _ _ I.hf)\n          (l _ _ _ _ _ I'.hf) (by simp [I', hl]))).isSeparatedFor.ext\n            fun V iUV (hiUV : _ = _) ‚Ü¶ ?_\n        simp [I', ‚Üê Functor.map_comp, ‚Üê op_comp, hiUV]\n    refine ‚ü®(isPointwiseRightKanExtensionRanCounit G.op Y.1 (.op (G.obj U))).lift c, ?_‚ü©\n    ¬∑ have := (isPointwiseRightKanExtensionRanCounit G.op Y.1 (.op (G.obj U))).fac c (.mk (ùüô _))\n      simp only [id_obj, comp_obj, StructuredArrow.proj_obj, StructuredArrow.mk_right,\n        RightExtension.coneAt_pt, RightExtension.mk_left, RightExtension.coneAt_œÄ_app,\n        const_obj_obj, op_obj, StructuredArrow.mk_hom_eq_self, map_id, whiskeringLeft_obj_obj,\n        RightExtension.mk_hom, Category.id_comp, StructuredArrow.mk_left, unop_id] at this\n      simp only [c, id_obj, yoneda_map_app, this]\n      apply Y.2.hom_ext ‚ü®_, IsDenseSubsite.imageSieve_mem J K G (ùüô (G.obj U))‚ü© _ _ fun I ‚Ü¶ ?_\n      apply (Y.2 X _ (IsDenseSubsite.equalizer_mem J K G (l _ _ _ _ _ I.hf)\n        I.f (by simp [hl]))).isSeparatedFor.ext fun V iUV (hiUV : _ = _) ‚Ü¶ ?_\n      simp [‚Üê Functor.map_comp, ‚Üê op_comp, hiUV]\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.instIsIsoSheafAppCounitSheafAdjunctionCocontinuous","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.SheafEquiv","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nA : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} A\ninst‚úù¬π : ‚àÄ (X : Opposite D), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.StructuredArrow X G.op) A\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\nY : CategoryTheory.Sheaf J A\n‚ä¢ CategoryTheory.IsIso ((G.sheafAdjunctionCocontinuous A J K).counit.app Y)","decl":"instance (Y : Sheaf J A) : IsIso ((G.sheafAdjunctionCocontinuous A J K).counit.app Y) := by\n  apply (config := { allowSynthFailures := true })\n    ReflectsIsomorphisms.reflects (sheafToPresheaf J A)\n  rw [NatTrans.isIso_iff_isIso_app]\n  intro ‚ü®U‚ü©\n  apply (config := { allowSynthFailures := true }) ReflectsIsomorphisms.reflects yoneda\n  rw [NatTrans.isIso_iff_isIso_app]\n  intro ‚ü®X‚ü©\n  simp only [comp_obj, sheafToPresheaf_obj, sheafPushforwardContinuous_obj_val_obj, yoneda_obj_obj,\n    id_obj, sheafToPresheaf_map, sheafAdjunctionCocontinuous_counit_app_val, ranAdjunction_counit]\n  exact isIso_ranCounit_app_of_isDenseSubsite G J K Y U X\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.sheafEquiv_functor","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.SheafEquiv","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nA : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} A\ninst‚úù¬π : ‚àÄ (X : Opposite D), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.StructuredArrow X G.op) A\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ Eq (CategoryTheory.Functor.IsDenseSubsite.sheafEquiv G J K A).functor (G.sheafPushforwardCocontinuous A J K)","decl":"/--\nIf `G : C ‚•§ D` exhibits `(C, J)` as a dense subsite of `(D, K)`,\nit induces an equivalence of category of sheaves valued in a category with suitable limits.\n-/\n@[simps! functor inverse]\nnoncomputable def sheafEquiv : Sheaf J A ‚âå Sheaf K A :=\n  (G.sheafAdjunctionCocontinuous A J K).toEquivalence.symm\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.sheafEquiv_inverse","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.SheafEquiv","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nA : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} A\ninst‚úù¬π : ‚àÄ (X : Opposite D), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.StructuredArrow X G.op) A\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ Eq (CategoryTheory.Functor.IsDenseSubsite.sheafEquiv G J K A).inverse (G.sheafPushforwardContinuous A J K)","decl":"/--\nIf `G : C ‚•§ D` exhibits `(C, J)` as a dense subsite of `(D, K)`,\nit induces an equivalence of category of sheaves valued in a category with suitable limits.\n-/\n@[simps! functor inverse]\nnoncomputable def sheafEquiv : Sheaf J A ‚âå Sheaf K A :=\n  (G.sheafAdjunctionCocontinuous A J K).toEquivalence.symm\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.instIsEquivalenceSheafSheafPushforwardContinuous","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.SheafEquiv","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_2} D\nG : CategoryTheory.Functor C D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nA : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{w', w} A\ninst‚úù¬π : ‚àÄ (X : Opposite D), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.StructuredArrow X G.op) A\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ (G.sheafPushforwardContinuous A J K).IsEquivalence","decl":"instance : (G.sheafPushforwardContinuous A J K).IsEquivalence :=\n  inferInstanceAs (IsDenseSubsite.sheafEquiv G _ _ _).inverse.IsEquivalence\n\n"}
