{"name":"UpperHalfPlane.ext","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"a b : UpperHalfPlane\nh : Eq ↑a ↑b\n⊢ Eq a b","decl":"@[ext] theorem ext {a b : ℍ} (h : (a : ℂ) = b) : a = b := Subtype.eq h\n\n"}
{"name":"UpperHalfPlane.ext_iff","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"a b : UpperHalfPlane\n⊢ Iff (Eq a b) (Eq ↑a ↑b)","decl":"@[ext] theorem ext {a b : ℍ} (h : (a : ℂ) = b) : a = b := Subtype.eq h\n\n"}
{"name":"UpperHalfPlane.ext_iff'","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"a b : UpperHalfPlane\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"@[simp, norm_cast] theorem ext_iff' {a b : ℍ} : (a : ℂ) = b ↔ a = b := UpperHalfPlane.ext_iff.symm\n\n"}
{"name":"UpperHalfPlane.canLift","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"⊢ CanLift Complex UpperHalfPlane UpperHalfPlane.coe fun z => LT.lt 0 z.im","decl":"instance canLift : CanLift ℂ ℍ ((↑) : ℍ → ℂ) fun z => 0 < z.im :=\n  Subtype.canLift fun (z : ℂ) => 0 < z.im\n\n"}
{"name":"UpperHalfPlane.ext'","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"a b : UpperHalfPlane\nhre : Eq a.re b.re\nhim : Eq a.im b.im\n⊢ Eq a b","decl":"/-- Extensionality lemma in terms of `UpperHalfPlane.re` and `UpperHalfPlane.im`. -/\ntheorem ext' {a b : ℍ} (hre : a.re = b.re) (him : a.im = b.im) : a = b :=\n  ext <| Complex.ext hre him\n\n"}
{"name":"UpperHalfPlane.coe_im","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\n⊢ Eq (↑z).im z.im","decl":"@[simp]\ntheorem coe_im (z : ℍ) : (z : ℂ).im = z.im :=\n  rfl\n\n"}
{"name":"UpperHalfPlane.coe_re","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\n⊢ Eq (↑z).re z.re","decl":"@[simp]\ntheorem coe_re (z : ℍ) : (z : ℂ).re = z.re :=\n  rfl\n\n"}
{"name":"UpperHalfPlane.mk_re","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : Complex\nh : LT.lt 0 z.im\n⊢ Eq (UpperHalfPlane.mk z h).re z.re","decl":"@[simp]\ntheorem mk_re (z : ℂ) (h : 0 < z.im) : (mk z h).re = z.re :=\n  rfl\n\n"}
{"name":"UpperHalfPlane.mk_im","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : Complex\nh : LT.lt 0 z.im\n⊢ Eq (UpperHalfPlane.mk z h).im z.im","decl":"@[simp]\ntheorem mk_im (z : ℂ) (h : 0 < z.im) : (mk z h).im = z.im :=\n  rfl\n\n"}
{"name":"UpperHalfPlane.coe_mk","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : Complex\nh : LT.lt 0 z.im\n⊢ Eq (↑(UpperHalfPlane.mk z h)) z","decl":"@[simp]\ntheorem coe_mk (z : ℂ) (h : 0 < z.im) : (mk z h : ℂ) = z :=\n  rfl\n\n"}
{"name":"UpperHalfPlane.coe_mk_subtype","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : Complex\nhz : LT.lt 0 z.im\n⊢ Eq (↑⟨z, hz⟩) z","decl":"@[simp]\nlemma coe_mk_subtype {z : ℂ} (hz : 0 < z.im) :\n    UpperHalfPlane.coe ⟨z, hz⟩ = z := by\n  rfl\n\n"}
{"name":"UpperHalfPlane.mk_coe","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\nh : optParam (LT.lt 0 (↑z).im) ⋯\n⊢ Eq (UpperHalfPlane.mk (↑z) h) z","decl":"@[simp]\ntheorem mk_coe (z : ℍ) (h : 0 < (z : ℂ).im := z.2) : mk z h = z :=\n  rfl\n\n"}
{"name":"UpperHalfPlane.re_add_im","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\n⊢ Eq (HAdd.hAdd (↑z.re) (HMul.hMul (↑z.im) Complex.I)) ↑z","decl":"theorem re_add_im (z : ℍ) : (z.re + z.im * Complex.I : ℂ) = z :=\n  Complex.re_add_im z\n\n"}
{"name":"UpperHalfPlane.im_pos","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\n⊢ LT.lt 0 z.im","decl":"theorem im_pos (z : ℍ) : 0 < z.im :=\n  z.2\n\n"}
{"name":"UpperHalfPlane.im_ne_zero","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\n⊢ Ne z.im 0","decl":"theorem im_ne_zero (z : ℍ) : z.im ≠ 0 :=\n  z.im_pos.ne'\n\n"}
{"name":"UpperHalfPlane.ne_zero","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\n⊢ Ne (↑z) 0","decl":"theorem ne_zero (z : ℍ) : (z : ℂ) ≠ 0 :=\n  mt (congr_arg Complex.im) z.im_ne_zero\n\n"}
{"name":"UpperHalfPlane.I_im","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"⊢ Eq UpperHalfPlane.I.im 1","decl":"@[simp]\nlemma I_im : I.im = 1 := rfl\n\n"}
{"name":"UpperHalfPlane.I_re","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"⊢ Eq UpperHalfPlane.I.re 0","decl":"@[simp]\nlemma I_re : I.re = 0 := rfl\n\n"}
{"name":"UpperHalfPlane.coe_I","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"⊢ Eq (↑UpperHalfPlane.I) Complex.I","decl":"@[simp, norm_cast]\nlemma coe_I : I = Complex.I := rfl\n\n"}
{"name":"UpperHalfPlane.normSq_pos","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\n⊢ LT.lt 0 (Complex.normSq ↑z)","decl":"theorem normSq_pos (z : ℍ) : 0 < Complex.normSq (z : ℂ) := by\n  rw [Complex.normSq_pos]; exact z.ne_zero\n\n"}
{"name":"UpperHalfPlane.normSq_ne_zero","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\n⊢ Ne (Complex.normSq ↑z) 0","decl":"theorem normSq_ne_zero (z : ℍ) : Complex.normSq (z : ℂ) ≠ 0 :=\n  (normSq_pos z).ne'\n\n"}
{"name":"UpperHalfPlane.im_inv_neg_coe_pos","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\n⊢ LT.lt 0 (Inv.inv (Neg.neg ↑z)).im","decl":"theorem im_inv_neg_coe_pos (z : ℍ) : 0 < (-z : ℂ)⁻¹.im := by\n  simpa using div_pos z.property (normSq_pos z)\n\n"}
{"name":"UpperHalfPlane.ne_nat","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\nn : Nat\n⊢ Ne ↑z ↑n","decl":"lemma ne_nat (z : ℍ) : ∀ n : ℕ, z.1 ≠ n := by\n  intro n\n  have h1 := z.2\n  aesop\n\n"}
{"name":"UpperHalfPlane.ne_int","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\nn : Int\n⊢ Ne ↑z ↑n","decl":"lemma ne_int (z : ℍ) : ∀ n : ℤ, z.1 ≠ n := by\n  intro n\n  have h1 := z.2\n  aesop\n\n-- Porting note: removed `@[simp]` because it broke `field_simp` calls below.\n"}
{"name":"UpperHalfPlane.linear_ne_zero","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"cd : Fin 2 → Real\nz : UpperHalfPlane\nh : Ne cd 0\n⊢ Ne (HAdd.hAdd (HMul.hMul ↑(cd 0) ↑z) ↑(cd 1)) 0","decl":"theorem linear_ne_zero (cd : Fin 2 → ℝ) (z : ℍ) (h : cd ≠ 0) : (cd 0 : ℂ) * z + cd 1 ≠ 0 := by\n  contrapose! h\n  have : cd 0 = 0 := by\n    -- we will need this twice\n    apply_fun Complex.im at h\n    simpa only [z.im_ne_zero, Complex.add_im, add_zero, coe_im, zero_mul, or_false,\n      Complex.ofReal_im, Complex.zero_im, Complex.mul_im, mul_eq_zero] using h\n  simp only [this, zero_mul, Complex.ofReal_zero, zero_add, Complex.ofReal_eq_zero]\n    at h\n  ext i\n  fin_cases i <;> assumption\n\n"}
{"name":"UpperHalfPlane.denom_ne_zero","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nz : UpperHalfPlane\n⊢ Ne (UpperHalfPlane.denom g z) 0","decl":"theorem denom_ne_zero (g : GL(2, ℝ)⁺) (z : ℍ) : denom g z ≠ 0 := by\n  intro H\n  have DET := (mem_glpos _).1 g.prop\n  simp only [GeneralLinearGroup.val_det_apply] at DET\n  obtain hg | hz : g 1 0 = 0 ∨ z.im = 0 := by simpa [num, denom] using congr_arg Complex.im H\n  · simp only [hg, Complex.ofReal_zero, denom, zero_mul, zero_add, Complex.ofReal_eq_zero] at H\n    simp only [Matrix.det_fin_two g.1.1, H, hg, mul_zero, sub_zero, lt_self_iff_false] at DET\n  · exact z.prop.ne' hz\n\n"}
{"name":"UpperHalfPlane.normSq_denom_pos","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nz : UpperHalfPlane\n⊢ LT.lt 0 (Complex.normSq (UpperHalfPlane.denom g z))","decl":"theorem normSq_denom_pos (g : GL(2, ℝ)⁺) (z : ℍ) : 0 < Complex.normSq (denom g z) :=\n  Complex.normSq_pos.mpr (denom_ne_zero g z)\n\n"}
{"name":"UpperHalfPlane.normSq_denom_ne_zero","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nz : UpperHalfPlane\n⊢ Ne (Complex.normSq (UpperHalfPlane.denom g z)) 0","decl":"theorem normSq_denom_ne_zero (g : GL(2, ℝ)⁺) (z : ℍ) : Complex.normSq (denom g z) ≠ 0 :=\n  ne_of_gt (normSq_denom_pos g z)\n\n"}
{"name":"UpperHalfPlane.smulAux'_im","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nz : UpperHalfPlane\n⊢ Eq (UpperHalfPlane.smulAux' g z).im (HDiv.hDiv (HMul.hMul (↑↑g).det z.im) (Complex.normSq (UpperHalfPlane.denom g z)))","decl":"theorem smulAux'_im (g : GL(2, ℝ)⁺) (z : ℍ) :\n    (smulAux' g z).im = det ↑ₘg * z.im / Complex.normSq (denom g z) := by\n  simp only [smulAux', num, denom, Complex.div_im, Complex.add_im, Complex.mul_im,\n    Complex.ofReal_re, coe_im, Complex.ofReal_im, coe_re, zero_mul, add_zero, Complex.add_re,\n    Complex.mul_re, sub_zero, ← sub_div, g.1.1.det_fin_two]\n  ring\n\n"}
{"name":"UpperHalfPlane.denom_cocycle","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"x y : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nz : UpperHalfPlane\n⊢ Eq (UpperHalfPlane.denom (HMul.hMul x y) z) (HMul.hMul (UpperHalfPlane.denom x (UpperHalfPlane.smulAux y z)) (UpperHalfPlane.denom y z))","decl":"theorem denom_cocycle (x y : GL(2, ℝ)⁺) (z : ℍ) :\n    denom (x * y) z = denom x (smulAux y z) * denom y z := by\n  change _ = (_ * (_ / _) + _) * _\n  field_simp [denom_ne_zero]\n  simp only [denom, Subgroup.coe_mul, Fin.isValue, Units.val_mul, mul_apply, Fin.sum_univ_succ,\n    Finset.univ_unique, Fin.default_eq_zero, Finset.sum_singleton, Fin.succ_zero_eq_one,\n    Complex.ofReal_add, Complex.ofReal_mul, num]\n  ring\n\n"}
{"name":"UpperHalfPlane.mul_smul'","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"x y : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nz : UpperHalfPlane\n⊢ Eq (UpperHalfPlane.smulAux (HMul.hMul x y) z) (UpperHalfPlane.smulAux x (UpperHalfPlane.smulAux y z))","decl":"theorem mul_smul' (x y : GL(2, ℝ)⁺) (z : ℍ) : smulAux (x * y) z = smulAux x (smulAux y z) := by\n  ext1\n  -- Porting note: was `change _ / _ = (_ * (_ / _) + _) * _`\n  change _ / _ = (_ * (_ / _) + _) / _\n  rw [denom_cocycle]\n  field_simp [denom_ne_zero]\n  simp only [num, Subgroup.coe_mul, Fin.isValue, Units.val_mul, mul_apply, Fin.sum_univ_succ,\n    Finset.univ_unique, Fin.default_eq_zero, Finset.sum_singleton, Fin.succ_zero_eq_one,\n    Complex.ofReal_add, Complex.ofReal_mul, denom]\n  ring\n\n"}
{"name":"UpperHalfPlane.specialLinearGroup_apply","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Algebra R Real\ng : Matrix.SpecialLinearGroup (Fin 2) R\nz : UpperHalfPlane\n⊢ Eq (HSMul.hSMul g z) (UpperHalfPlane.mk (HDiv.hDiv (HAdd.hAdd (HMul.hMul ↑((algebraMap R Real) (↑g 0 0)) ↑z) ↑((algebraMap R Real) (↑g 0 1))) (HAdd.hAdd (HMul.hMul ↑((algebraMap R Real) (↑g 1 0)) ↑z) ↑((algebraMap R Real) (↑g 1 1)))) ⋯)","decl":"theorem specialLinearGroup_apply {R : Type*} [CommRing R] [Algebra R ℝ] (g : SL(2, R)) (z : ℍ) :\n    g • z =\n      mk\n        (((algebraMap R ℝ (g 0 0) : ℂ) * z + (algebraMap R ℝ (g 0 1) : ℂ)) /\n          ((algebraMap R ℝ (g 1 0) : ℂ) * z + (algebraMap R ℝ (g 1 1) : ℂ)))\n        (g • z).property :=\n  rfl\n\n"}
{"name":"UpperHalfPlane.coe_smul","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nz : UpperHalfPlane\n⊢ Eq (↑(HSMul.hSMul g z)) (HDiv.hDiv (UpperHalfPlane.num g z) (UpperHalfPlane.denom g z))","decl":"@[simp]\ntheorem coe_smul : ↑(g • z) = num g z / denom g z :=\n  rfl\n\n"}
{"name":"UpperHalfPlane.re_smul","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nz : UpperHalfPlane\n⊢ Eq (HSMul.hSMul g z).re (HDiv.hDiv (UpperHalfPlane.num g z) (UpperHalfPlane.denom g z)).re","decl":"@[simp]\ntheorem re_smul : (g • z).re = (num g z / denom g z).re :=\n  rfl\n\n"}
{"name":"UpperHalfPlane.im_smul","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nz : UpperHalfPlane\n⊢ Eq (HSMul.hSMul g z).im (HDiv.hDiv (UpperHalfPlane.num g z) (UpperHalfPlane.denom g z)).im","decl":"theorem im_smul : (g • z).im = (num g z / denom g z).im :=\n  rfl\n\n"}
{"name":"UpperHalfPlane.im_smul_eq_div_normSq","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nz : UpperHalfPlane\n⊢ Eq (HSMul.hSMul g z).im (HDiv.hDiv (HMul.hMul (↑↑g).det z.im) (Complex.normSq (UpperHalfPlane.denom g z)))","decl":"theorem im_smul_eq_div_normSq : (g • z).im = det ↑ₘg * z.im / Complex.normSq (denom g z) :=\n  smulAux'_im g z\n\n"}
{"name":"UpperHalfPlane.c_mul_im_sq_le_normSq_denom","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nz : UpperHalfPlane\n⊢ LE.le (HPow.hPow (HMul.hMul (↑↑g 1 0) z.im) 2) (Complex.normSq (UpperHalfPlane.denom g z))","decl":"theorem c_mul_im_sq_le_normSq_denom : (g 1 0 * z.im) ^ 2 ≤ Complex.normSq (denom g z) := by\n  set c := g 1 0\n  set d := g 1 1\n  calc\n    (c * z.im) ^ 2 ≤ (c * z.im) ^ 2 + (c * z.re + d) ^ 2 := by nlinarith\n    _ = Complex.normSq (denom g z) := by dsimp [c, d, denom, Complex.normSq]; ring\n\n"}
{"name":"UpperHalfPlane.neg_smul","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nz : UpperHalfPlane\n⊢ Eq (HSMul.hSMul (Neg.neg g) z) (HSMul.hSMul g z)","decl":"@[simp]\ntheorem neg_smul : -g • z = g • z := by\n  ext1\n  change _ / _ = _ / _\n  field_simp [denom_ne_zero]\n  simp only [num, denom, Complex.ofReal_neg, neg_mul, GLPos.coe_neg_GL, Units.val_neg, neg_apply]\n  ring_nf\n\n"}
{"name":"UpperHalfPlane.denom_one","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\n⊢ Eq (UpperHalfPlane.denom 1 z) 1","decl":"lemma denom_one : denom 1 z = 1 := by\n  simp [denom]\n\n"}
{"name":"UpperHalfPlane.coe_pos_real_smul","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"x : Subtype fun x => LT.lt 0 x\nz : UpperHalfPlane\n⊢ Eq (↑(HSMul.hSMul x z)) (HSMul.hSMul ↑x ↑z)","decl":"@[simp]\ntheorem coe_pos_real_smul : ↑(x • z) = (x : ℝ) • (z : ℂ) :=\n  rfl\n\n"}
{"name":"UpperHalfPlane.pos_real_im","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"x : Subtype fun x => LT.lt 0 x\nz : UpperHalfPlane\n⊢ Eq (HSMul.hSMul x z).im (HMul.hMul (↑x) z.im)","decl":"@[simp]\ntheorem pos_real_im : (x • z).im = x * z.im :=\n  Complex.smul_im _ _\n\n"}
{"name":"UpperHalfPlane.pos_real_re","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"x : Subtype fun x => LT.lt 0 x\nz : UpperHalfPlane\n⊢ Eq (HSMul.hSMul x z).re (HMul.hMul (↑x) z.re)","decl":"@[simp]\ntheorem pos_real_re : (x • z).re = x * z.re :=\n  Complex.smul_re _ _\n\n"}
{"name":"UpperHalfPlane.coe_vadd","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"x : Real\nz : UpperHalfPlane\n⊢ Eq (↑(HVAdd.hVAdd x z)) (HAdd.hAdd ↑x ↑z)","decl":"@[simp]\ntheorem coe_vadd : ↑(x +ᵥ z) = (x + z : ℂ) :=\n  rfl\n\n"}
{"name":"UpperHalfPlane.vadd_re","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"x : Real\nz : UpperHalfPlane\n⊢ Eq (HVAdd.hVAdd x z).re (HAdd.hAdd x z.re)","decl":"@[simp]\ntheorem vadd_re : (x +ᵥ z).re = x + z.re :=\n  rfl\n\n"}
{"name":"UpperHalfPlane.vadd_im","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"x : Real\nz : UpperHalfPlane\n⊢ Eq (HVAdd.hVAdd x z).im z.im","decl":"@[simp]\ntheorem vadd_im : (x +ᵥ z).im = z.im :=\n  zero_add _\n\n"}
{"name":"UpperHalfPlane.modular_S_smul","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\n⊢ Eq (HSMul.hSMul ModularGroup.S z) (UpperHalfPlane.mk (Inv.inv (Neg.neg ↑z)) ⋯)","decl":"theorem modular_S_smul (z : ℍ) : ModularGroup.S • z = mk (-z : ℂ)⁻¹ z.im_inv_neg_coe_pos := by\n  rw [specialLinearGroup_apply]; simp [ModularGroup.S, neg_div, inv_neg, toGL]\n\n"}
{"name":"UpperHalfPlane.modular_T_zpow_smul","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\nn : Int\n⊢ Eq (HSMul.hSMul (HPow.hPow ModularGroup.T n) z) (HVAdd.hVAdd (↑n) z)","decl":"theorem modular_T_zpow_smul (z : ℍ) (n : ℤ) : ModularGroup.T ^ n • z = (n : ℝ) +ᵥ z := by\n  rw [UpperHalfPlane.ext_iff, coe_vadd, add_comm, specialLinearGroup_apply, coe_mk]\n  -- Porting note: added `coeToGL` and merged `rw` and `simp`\n  simp [toGL, ModularGroup.coe_T_zpow,\n    of_apply, cons_val_zero, algebraMap.coe_one, Complex.ofReal_one, one_mul, cons_val_one,\n    head_cons, algebraMap.coe_zero, zero_mul, zero_add, div_one]\n\n"}
{"name":"UpperHalfPlane.modular_T_smul","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\n⊢ Eq (HSMul.hSMul ModularGroup.T z) (HVAdd.hVAdd 1 z)","decl":"theorem modular_T_smul (z : ℍ) : ModularGroup.T • z = (1 : ℝ) +ᵥ z := by\n  simpa only [Int.cast_one] using modular_T_zpow_smul z 1\n\n"}
{"name":"UpperHalfPlane.exists_SL2_smul_eq_of_apply_zero_one_eq_zero","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Real\nhc : Eq (↑g 1 0) 0\n⊢ Exists fun u => Exists fun v => Eq (fun x => HSMul.hSMul g x) (Function.comp (fun x => HVAdd.hVAdd v x) fun x => HSMul.hSMul u x)","decl":"theorem exists_SL2_smul_eq_of_apply_zero_one_eq_zero (g : SL(2, ℝ)) (hc : g 1 0 = 0) :\n    ∃ (u : { x : ℝ // 0 < x }) (v : ℝ), (g • · : ℍ → ℍ) = (v +ᵥ ·) ∘ (u • ·) := by\n  obtain ⟨a, b, ha, rfl⟩ := g.fin_two_exists_eq_mk_of_apply_zero_one_eq_zero hc\n  refine ⟨⟨_, mul_self_pos.mpr ha⟩, b * a, ?_⟩\n  ext1 ⟨z, hz⟩; ext1\n  suffices ↑a * z * a + b * a = b * a + a * a * z by\n    -- Porting note: added `coeToGL` and merged `rw` and `simpa`\n    simpa [toGL, specialLinearGroup_apply, add_mul]\n  ring\n\n"}
{"name":"UpperHalfPlane.exists_SL2_smul_eq_of_apply_zero_one_ne_zero","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Real\nhc : Ne (↑g 1 0) 0\n⊢ Exists fun u => Exists fun v => Exists fun w => Eq (fun x => HSMul.hSMul g x) (Function.comp (fun x => HVAdd.hVAdd w x) (Function.comp (fun x => HSMul.hSMul ModularGroup.S x) (Function.comp (fun x => HVAdd.hVAdd v x) fun x => HSMul.hSMul u x)))","decl":"theorem exists_SL2_smul_eq_of_apply_zero_one_ne_zero (g : SL(2, ℝ)) (hc : g 1 0 ≠ 0) :\n    ∃ (u : { x : ℝ // 0 < x }) (v w : ℝ),\n      (g • · : ℍ → ℍ) =\n        (w +ᵥ ·) ∘ (ModularGroup.S • · : ℍ → ℍ) ∘ (v +ᵥ · : ℍ → ℍ) ∘ (u • · : ℍ → ℍ) := by\n  have h_denom := denom_ne_zero g\n  induction' g using Matrix.SpecialLinearGroup.fin_two_induction with a b c d h\n  replace hc : c ≠ 0 := by simpa using hc\n  refine ⟨⟨_, mul_self_pos.mpr hc⟩, c * d, a / c, ?_⟩\n  ext1 ⟨z, hz⟩; ext1\n  suffices (↑a * z + b) / (↑c * z + d) = a / c - (c * d + ↑c * ↑c * z)⁻¹ by\n    -- Porting note: golfed broken proof\n    simpa only [modular_S_smul, inv_neg, Function.comp_apply, coe_vadd, Complex.ofReal_mul,\n      coe_pos_real_smul, Complex.real_smul, Complex.ofReal_div, coe_mk]\n  replace hc : (c : ℂ) ≠ 0 := by norm_cast\n  replace h_denom : ↑c * z + d ≠ 0 := by simpa using h_denom ⟨z, hz⟩\n  have h_aux : (c : ℂ) * d + ↑c * ↑c * z ≠ 0 := by\n    rw [mul_assoc, ← mul_add, add_comm]\n    exact mul_ne_zero hc h_denom\n  replace h : (a * d - b * c : ℂ) = (1 : ℂ) := by norm_cast\n  field_simp\n  linear_combination (-(z * (c : ℂ) ^ 2) - c * d) * h\n\n"}
{"name":"ModularGroup.coe_apply_complex","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\ni j : Fin 2\n⊢ Eq ↑(↑↑↑g i j) ↑(↑g i j)","decl":"@[simp]\ntheorem coe_apply_complex {g : SL(2, ℤ)} {i j : Fin 2} :\n    (Units.val <| Subtype.val <| coe g) i j = (Subtype.val g i j : ℂ) :=\n  rfl\n\n"}
{"name":"ModularGroup.coe'_apply_complex","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\ni j : Fin 2\n⊢ Eq ↑(↑↑↑g i j) ↑(↑g i j)","decl":"@[deprecated (since := \"2024-11-19\")] alias coe'_apply_complex := coe_apply_complex\n\n"}
{"name":"ModularGroup.det_coe","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\n⊢ Eq (↑↑↑g).det 1","decl":"@[simp]\ntheorem det_coe {g : SL(2, ℤ)} : det (Units.val <| Subtype.val <| coe g) = 1 := by\n  simp only [SpecialLinearGroup.coe_GLPos_coe_GL_coe_matrix, SpecialLinearGroup.det_coe, coe]\n\n"}
{"name":"ModularGroup.det_coe'","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\n⊢ Eq (↑↑↑g).det 1","decl":"@[deprecated (since := \"2024-11-19\")] alias det_coe' := det_coe\n\n"}
{"name":"ModularGroup.coe_one","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"⊢ Eq (↑1) 1","decl":"lemma coe_one : coe 1 = 1 := by\n  simp only [coe, _root_.map_one]\n\n"}
{"name":"ModularGroup.SLOnGLPos_smul_apply","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"s : Matrix.SpecialLinearGroup (Fin 2) Int\ng : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nz : UpperHalfPlane\n⊢ Eq (HSMul.hSMul (HSMul.hSMul s g) z) (HSMul.hSMul (HMul.hMul (↑s) g) z)","decl":"theorem SLOnGLPos_smul_apply (s : SL(2, ℤ)) (g : GL(2, ℝ)⁺) (z : ℍ) :\n    (s • g) • z = ((s : GL(2, ℝ)⁺) * g) • z :=\n  rfl\n\n"}
{"name":"ModularGroup.SL_to_GL_tower","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"⊢ IsScalarTower (Matrix.SpecialLinearGroup (Fin 2) Int) (Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x) UpperHalfPlane","decl":"instance SL_to_GL_tower : IsScalarTower SL(2, ℤ) GL(2, ℝ)⁺ ℍ where\n  smul_assoc s g z := by\n    simp only [SLOnGLPos_smul_apply]\n    apply mul_smul'\n\n"}
{"name":"ModularGroup.sl_moeb","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"A : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\n⊢ Eq (HSMul.hSMul A z) (HSMul.hSMul (↑A) z)","decl":"@[simp]\ntheorem sl_moeb (A : SL(2, ℤ)) (z : ℍ) : A • z = (A : GL(2, ℝ)⁺) • z :=\n  rfl\n\n"}
{"name":"ModularGroup.SL_neg_smul","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\n⊢ Eq (HSMul.hSMul (Neg.neg g) z) (HSMul.hSMul g z)","decl":"@[simp high]\ntheorem SL_neg_smul (g : SL(2, ℤ)) (z : ℍ) : -g • z = g • z := by\n  simp only [coe_GLPos_neg, sl_moeb, coe_int_neg, neg_smul, coe]\n\n"}
{"name":"ModularGroup.im_smul_eq_div_normSq","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\n⊢ Eq (HSMul.hSMul g z).im (HDiv.hDiv z.im (Complex.normSq (UpperHalfPlane.denom (↑g) z)))","decl":"theorem im_smul_eq_div_normSq : (g • z).im = z.im / Complex.normSq (denom g z) := by\n  simpa only [coe, coe_GLPos_coe_GL_coe_matrix, (g : SL(2, ℝ)).prop, one_mul] using\n    z.im_smul_eq_div_normSq g\n\n"}
{"name":"ModularGroup.denom_apply","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\n⊢ Eq (UpperHalfPlane.denom (↑g) z) (HAdd.hAdd (HMul.hMul ↑(↑g 1 0) ↑z) ↑(↑g 1 1))","decl":"theorem denom_apply (g : SL(2, ℤ)) (z : ℍ) :\n    denom g z = g 1 0 * z + g 1 1 := by\n  simp [denom, coe]\n\n"}
{"name":"ModularGroup.denom_S","module":"Mathlib.Analysis.Complex.UpperHalfPlane.Basic","initialProofState":"z : UpperHalfPlane\n⊢ Eq (UpperHalfPlane.denom (↑ModularGroup.S) z) ↑z","decl":"@[simp]\nlemma denom_S (z : ℍ) : denom S z = z := by\n  simp only [S, denom_apply, of_apply, cons_val', cons_val_zero, empty_val', cons_val_fin_one,\n    cons_val_one, head_fin_const, Int.cast_one, one_mul, head_cons, Int.cast_zero, add_zero]\n\n"}
