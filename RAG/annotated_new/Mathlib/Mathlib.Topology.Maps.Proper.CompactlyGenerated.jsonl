{"name":"isProperMap_iff_isCompact_preimage","module":"Mathlib.Topology.Maps.Proper.CompactlyGenerated","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : T2Space Y\ninst✝ : CompactlyGeneratedSpace Y\nf : X → Y\n⊢ Iff (IsProperMap f) (And (Continuous f) (∀ ⦃K : Set Y⦄, IsCompact K → IsCompact (Set.preimage f K)))","decl":"/-- If `Y` is Hausdorff and compactly generated, then proper maps `X → Y` are exactly\ncontinuous maps such that the preimage of any compact set is compact. This is in particular true\nif `Y` is Hausdorff and sequential or locally compact.\n\nThere was an older version of this theorem which was changed to this one to make use\nof the `CompactlyGeneratedSpace` typeclass. (since 2024-11-10) -/\ntheorem isProperMap_iff_isCompact_preimage :\n    IsProperMap f ↔ Continuous f ∧ ∀ ⦃K⦄, IsCompact K → IsCompact (f ⁻¹' K) where\n  mp hf := ⟨hf.continuous, fun _ ↦ hf.isCompact_preimage⟩\n  mpr := fun ⟨hf, h⟩ ↦ isProperMap_iff_isClosedMap_and_compact_fibers.2\n    ⟨hf, fun _ hs ↦ CompactlyGeneratedSpace.isClosed\n      fun _ hK ↦ image_inter_preimage .. ▸ (((h hK).inter_left hs).image hf).isClosed,\n      fun _ ↦ h isCompact_singleton⟩\n\n"}
{"name":"isProperMap_iff_tendsto_cocompact","module":"Mathlib.Topology.Maps.Proper.CompactlyGenerated","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : T2Space Y\ninst✝ : CompactlyGeneratedSpace Y\nf : X → Y\n⊢ Iff (IsProperMap f) (And (Continuous f) (Filter.Tendsto f (Filter.cocompact X) (Filter.cocompact Y)))","decl":"/-- Version of `isProperMap_iff_isCompact_preimage` in terms of `cocompact`.\n\nThere was an older version of this theorem which was changed to this one to make use\nof the `CompactlyGeneratedSpace` typeclass. (since 2024-11-10) -/\nlemma isProperMap_iff_tendsto_cocompact :\n    IsProperMap f ↔ Continuous f ∧ Tendsto f (cocompact X) (cocompact Y) := by\n  simp_rw [isProperMap_iff_isCompact_preimage,\n    hasBasis_cocompact.tendsto_right_iff, ← mem_preimage, eventually_mem_set, preimage_compl]\n  refine and_congr_right fun f_cont ↦\n    ⟨fun H K hK ↦ (H hK).compl_mem_cocompact, fun H K hK ↦ ?_⟩\n  rcases mem_cocompact.mp (H K hK) with ⟨K', hK', hK'y⟩\n  exact hK'.of_isClosed_subset (hK.isClosed.preimage f_cont)\n    (compl_le_compl_iff_le.mp hK'y)\n"}
