{"name":"Set.accumulate_def","module":"Mathlib.Data.Set.Accumulate","initialProofState":"α : Type u_1\nβ : Type u_2\ns : α → Set β\ninst✝ : LE α\nx : α\n⊢ Eq (Set.Accumulate s x) (Set.iUnion fun y => Set.iUnion fun h => s y)","decl":"theorem accumulate_def [LE α] {x : α} : Accumulate s x = ⋃ y ≤ x, s y :=\n  rfl\n\n"}
{"name":"Set.mem_accumulate","module":"Mathlib.Data.Set.Accumulate","initialProofState":"α : Type u_1\nβ : Type u_2\ns : α → Set β\ninst✝ : LE α\nx : α\nz : β\n⊢ Iff (Membership.mem (Set.Accumulate s x) z) (Exists fun y => And (LE.le y x) (Membership.mem (s y) z))","decl":"@[simp]\ntheorem mem_accumulate [LE α] {x : α} {z : β} : z ∈ Accumulate s x ↔ ∃ y ≤ x, z ∈ s y := by\n  simp_rw [accumulate_def, mem_iUnion₂, exists_prop]\n\n"}
{"name":"Set.subset_accumulate","module":"Mathlib.Data.Set.Accumulate","initialProofState":"α : Type u_1\nβ : Type u_2\ns : α → Set β\ninst✝ : Preorder α\nx : α\n⊢ HasSubset.Subset (s x) (Set.Accumulate s x)","decl":"theorem subset_accumulate [Preorder α] {x : α} : s x ⊆ Accumulate s x := fun _ => mem_biUnion le_rfl\n\n"}
{"name":"Set.accumulate_subset_iUnion","module":"Mathlib.Data.Set.Accumulate","initialProofState":"α : Type u_1\nβ : Type u_2\ns : α → Set β\ninst✝ : Preorder α\nx : α\n⊢ HasSubset.Subset (Set.Accumulate s x) (Set.iUnion fun i => s i)","decl":"theorem accumulate_subset_iUnion [Preorder α] (x : α) : Accumulate s x ⊆ ⋃ i, s i :=\n  (biUnion_subset_biUnion_left (subset_univ _)).trans_eq (biUnion_univ _)\n\n"}
{"name":"Set.monotone_accumulate","module":"Mathlib.Data.Set.Accumulate","initialProofState":"α : Type u_1\nβ : Type u_2\ns : α → Set β\ninst✝ : Preorder α\n⊢ Monotone (Set.Accumulate s)","decl":"theorem monotone_accumulate [Preorder α] : Monotone (Accumulate s) := fun _ _ hxy =>\n  biUnion_subset_biUnion_left fun _ hz => le_trans hz hxy\n\n"}
{"name":"Set.accumulate_subset_accumulate","module":"Mathlib.Data.Set.Accumulate","initialProofState":"α : Type u_1\nβ : Type u_2\ns : α → Set β\ninst✝ : Preorder α\nx y : α\nh : LE.le x y\n⊢ HasSubset.Subset (Set.Accumulate s x) (Set.Accumulate s y)","decl":"@[gcongr]\ntheorem accumulate_subset_accumulate [Preorder α] {x y} (h : x ≤ y) :\n    Accumulate s x ⊆ Accumulate s y :=\n  monotone_accumulate h\n\n"}
{"name":"Set.biUnion_accumulate","module":"Mathlib.Data.Set.Accumulate","initialProofState":"α : Type u_1\nβ : Type u_2\ns : α → Set β\ninst✝ : Preorder α\nx : α\n⊢ Eq (Set.iUnion fun y => Set.iUnion fun h => Set.Accumulate s y) (Set.iUnion fun y => Set.iUnion fun h => s y)","decl":"theorem biUnion_accumulate [Preorder α] (x : α) : ⋃ y ≤ x, Accumulate s y = ⋃ y ≤ x, s y := by\n  apply Subset.antisymm\n  · exact iUnion₂_subset fun y hy => monotone_accumulate hy\n  · exact iUnion₂_mono fun y _ => subset_accumulate\n\n"}
{"name":"Set.iUnion_accumulate","module":"Mathlib.Data.Set.Accumulate","initialProofState":"α : Type u_1\nβ : Type u_2\ns : α → Set β\ninst✝ : Preorder α\n⊢ Eq (Set.iUnion fun x => Set.Accumulate s x) (Set.iUnion fun x => s x)","decl":"theorem iUnion_accumulate [Preorder α] : ⋃ x, Accumulate s x = ⋃ x, s x := by\n  apply Subset.antisymm\n  · simp only [subset_def, mem_iUnion, exists_imp, mem_accumulate]\n    intro z x x' ⟨_, hz⟩\n    exact ⟨x', hz⟩\n  · exact iUnion_mono fun i => subset_accumulate\n\n"}
{"name":"Set.accumulate_bot","module":"Mathlib.Data.Set.Accumulate","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns : α → Set β\n⊢ Eq (Set.Accumulate s Bot.bot) (s Bot.bot)","decl":"@[simp]\nlemma accumulate_bot [PartialOrder α] [OrderBot α] (s : α → Set β) : Accumulate s ⊥ = s ⊥ := by\n  simp [Set.accumulate_def]\n\n"}
{"name":"Set.accumulate_zero_nat","module":"Mathlib.Data.Set.Accumulate","initialProofState":"β : Type u_2\ns : Nat → Set β\n⊢ Eq (Set.Accumulate s 0) (s 0)","decl":"@[simp]\nlemma accumulate_zero_nat (s : ℕ → Set β) : Accumulate s 0 = s 0 := by\n  simp [accumulate_def]\n\n"}
{"name":"Set.disjoint_accumulate","module":"Mathlib.Data.Set.Accumulate","initialProofState":"α : Type u_1\nβ : Type u_2\ns : α → Set β\ninst✝ : Preorder α\nhs : Pairwise (Function.onFun Disjoint s)\ni j : α\nhij : LT.lt i j\n⊢ Disjoint (Set.Accumulate s i) (s j)","decl":"open Function in\ntheorem disjoint_accumulate [Preorder α] (hs : Pairwise (Disjoint on s)) {i j : α} (hij : i < j) :\n    Disjoint (Accumulate s i) (s j) := by\n  apply disjoint_left.2 (fun x hx ↦ ?_)\n  simp only [Accumulate, mem_iUnion, exists_prop] at hx\n  rcases hx with ⟨k, hk, hx⟩\n  exact disjoint_left.1 (hs (hk.trans_lt hij).ne) hx\n\n"}
