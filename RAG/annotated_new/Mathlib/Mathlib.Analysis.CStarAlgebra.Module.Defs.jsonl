{"name":"CStarModule.inner_add_right","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : outParam (Type u_1)\nE : Type u_2\ninst✝⁸ : NonUnitalSemiring A\ninst✝⁷ : StarRing A\ninst✝⁶ : Module Complex A\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Complex E\ninst✝³ : PartialOrder A\ninst✝² : SMul (MulOpposite A) E\ninst✝¹ : Norm A\ninst✝ : Norm E\nself : CStarModule A E\nx y z : E\n⊢ Eq (Inner.inner x (HAdd.hAdd y z)) (HAdd.hAdd (Inner.inner x y) (Inner.inner x z))","decl":"/-- A *Hilbert C⋆-module* is a complex module `E` endowed with a right `A`-module structure\n(where `A` is typically a C⋆-algebra) and an inner product `⟪x, y⟫_A` which satisfies the\nfollowing properties. -/\nclass CStarModule (A : outParam <| Type*) (E : Type*) [NonUnitalSemiring A] [StarRing A]\n    [Module ℂ A] [AddCommGroup E] [Module ℂ E] [PartialOrder A] [SMul Aᵐᵒᵖ E] [Norm A] [Norm E]\n    extends Inner A E where\n  inner_add_right {x} {y} {z} : inner x (y + z) = inner x y + inner x z\n  inner_self_nonneg {x} : 0 ≤ inner x x\n  inner_self {x} : inner x x = 0 ↔ x = 0\n  inner_op_smul_right {a : A} {x y : E} : inner x (y <• a) = inner x y * a\n  inner_smul_right_complex {z : ℂ} {x} {y} : inner x (z • y) = z • inner x y\n  star_inner x y : star (inner x y) = inner y x\n  norm_eq_sqrt_norm_inner_self x : ‖x‖ = √‖inner x x‖\n\n"}
{"name":"CStarModule.norm_eq_sqrt_norm_inner_self","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : outParam (Type u_1)\nE : Type u_2\ninst✝⁸ : NonUnitalSemiring A\ninst✝⁷ : StarRing A\ninst✝⁶ : Module Complex A\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Complex E\ninst✝³ : PartialOrder A\ninst✝² : SMul (MulOpposite A) E\ninst✝¹ : Norm A\ninst✝ : Norm E\nself : CStarModule A E\nx : E\n⊢ Eq (Norm.norm x) (Norm.norm (Inner.inner x x)).sqrt","decl":"/-- A *Hilbert C⋆-module* is a complex module `E` endowed with a right `A`-module structure\n(where `A` is typically a C⋆-algebra) and an inner product `⟪x, y⟫_A` which satisfies the\nfollowing properties. -/\nclass CStarModule (A : outParam <| Type*) (E : Type*) [NonUnitalSemiring A] [StarRing A]\n    [Module ℂ A] [AddCommGroup E] [Module ℂ E] [PartialOrder A] [SMul Aᵐᵒᵖ E] [Norm A] [Norm E]\n    extends Inner A E where\n  inner_add_right {x} {y} {z} : inner x (y + z) = inner x y + inner x z\n  inner_self_nonneg {x} : 0 ≤ inner x x\n  inner_self {x} : inner x x = 0 ↔ x = 0\n  inner_op_smul_right {a : A} {x y : E} : inner x (y <• a) = inner x y * a\n  inner_smul_right_complex {z : ℂ} {x} {y} : inner x (z • y) = z • inner x y\n  star_inner x y : star (inner x y) = inner y x\n  norm_eq_sqrt_norm_inner_self x : ‖x‖ = √‖inner x x‖\n\n"}
{"name":"CStarModule.inner_op_smul_right","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : outParam (Type u_1)\nE : Type u_2\ninst✝⁸ : NonUnitalSemiring A\ninst✝⁷ : StarRing A\ninst✝⁶ : Module Complex A\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Complex E\ninst✝³ : PartialOrder A\ninst✝² : SMul (MulOpposite A) E\ninst✝¹ : Norm A\ninst✝ : Norm E\nself : CStarModule A E\na : A\nx y : E\n⊢ Eq (Inner.inner x (HSMul.hSMul (MulOpposite.op a) y)) (HMul.hMul (Inner.inner x y) a)","decl":"/-- A *Hilbert C⋆-module* is a complex module `E` endowed with a right `A`-module structure\n(where `A` is typically a C⋆-algebra) and an inner product `⟪x, y⟫_A` which satisfies the\nfollowing properties. -/\nclass CStarModule (A : outParam <| Type*) (E : Type*) [NonUnitalSemiring A] [StarRing A]\n    [Module ℂ A] [AddCommGroup E] [Module ℂ E] [PartialOrder A] [SMul Aᵐᵒᵖ E] [Norm A] [Norm E]\n    extends Inner A E where\n  inner_add_right {x} {y} {z} : inner x (y + z) = inner x y + inner x z\n  inner_self_nonneg {x} : 0 ≤ inner x x\n  inner_self {x} : inner x x = 0 ↔ x = 0\n  inner_op_smul_right {a : A} {x y : E} : inner x (y <• a) = inner x y * a\n  inner_smul_right_complex {z : ℂ} {x} {y} : inner x (z • y) = z • inner x y\n  star_inner x y : star (inner x y) = inner y x\n  norm_eq_sqrt_norm_inner_self x : ‖x‖ = √‖inner x x‖\n\n"}
{"name":"CStarModule.inner_self","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : outParam (Type u_1)\nE : Type u_2\ninst✝⁸ : NonUnitalSemiring A\ninst✝⁷ : StarRing A\ninst✝⁶ : Module Complex A\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Complex E\ninst✝³ : PartialOrder A\ninst✝² : SMul (MulOpposite A) E\ninst✝¹ : Norm A\ninst✝ : Norm E\nself : CStarModule A E\nx : E\n⊢ Iff (Eq (Inner.inner x x) 0) (Eq x 0)","decl":"/-- A *Hilbert C⋆-module* is a complex module `E` endowed with a right `A`-module structure\n(where `A` is typically a C⋆-algebra) and an inner product `⟪x, y⟫_A` which satisfies the\nfollowing properties. -/\nclass CStarModule (A : outParam <| Type*) (E : Type*) [NonUnitalSemiring A] [StarRing A]\n    [Module ℂ A] [AddCommGroup E] [Module ℂ E] [PartialOrder A] [SMul Aᵐᵒᵖ E] [Norm A] [Norm E]\n    extends Inner A E where\n  inner_add_right {x} {y} {z} : inner x (y + z) = inner x y + inner x z\n  inner_self_nonneg {x} : 0 ≤ inner x x\n  inner_self {x} : inner x x = 0 ↔ x = 0\n  inner_op_smul_right {a : A} {x y : E} : inner x (y <• a) = inner x y * a\n  inner_smul_right_complex {z : ℂ} {x} {y} : inner x (z • y) = z • inner x y\n  star_inner x y : star (inner x y) = inner y x\n  norm_eq_sqrt_norm_inner_self x : ‖x‖ = √‖inner x x‖\n\n"}
{"name":"CStarModule.inner_self_nonneg","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : outParam (Type u_1)\nE : Type u_2\ninst✝⁸ : NonUnitalSemiring A\ninst✝⁷ : StarRing A\ninst✝⁶ : Module Complex A\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Complex E\ninst✝³ : PartialOrder A\ninst✝² : SMul (MulOpposite A) E\ninst✝¹ : Norm A\ninst✝ : Norm E\nself : CStarModule A E\nx : E\n⊢ LE.le 0 (Inner.inner x x)","decl":"/-- A *Hilbert C⋆-module* is a complex module `E` endowed with a right `A`-module structure\n(where `A` is typically a C⋆-algebra) and an inner product `⟪x, y⟫_A` which satisfies the\nfollowing properties. -/\nclass CStarModule (A : outParam <| Type*) (E : Type*) [NonUnitalSemiring A] [StarRing A]\n    [Module ℂ A] [AddCommGroup E] [Module ℂ E] [PartialOrder A] [SMul Aᵐᵒᵖ E] [Norm A] [Norm E]\n    extends Inner A E where\n  inner_add_right {x} {y} {z} : inner x (y + z) = inner x y + inner x z\n  inner_self_nonneg {x} : 0 ≤ inner x x\n  inner_self {x} : inner x x = 0 ↔ x = 0\n  inner_op_smul_right {a : A} {x y : E} : inner x (y <• a) = inner x y * a\n  inner_smul_right_complex {z : ℂ} {x} {y} : inner x (z • y) = z • inner x y\n  star_inner x y : star (inner x y) = inner y x\n  norm_eq_sqrt_norm_inner_self x : ‖x‖ = √‖inner x x‖\n\n"}
{"name":"CStarModule.inner_smul_right_complex","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : outParam (Type u_1)\nE : Type u_2\ninst✝⁸ : NonUnitalSemiring A\ninst✝⁷ : StarRing A\ninst✝⁶ : Module Complex A\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Complex E\ninst✝³ : PartialOrder A\ninst✝² : SMul (MulOpposite A) E\ninst✝¹ : Norm A\ninst✝ : Norm E\nself : CStarModule A E\nz : Complex\nx y : E\n⊢ Eq (Inner.inner x (HSMul.hSMul z y)) (HSMul.hSMul z (Inner.inner x y))","decl":"/-- A *Hilbert C⋆-module* is a complex module `E` endowed with a right `A`-module structure\n(where `A` is typically a C⋆-algebra) and an inner product `⟪x, y⟫_A` which satisfies the\nfollowing properties. -/\nclass CStarModule (A : outParam <| Type*) (E : Type*) [NonUnitalSemiring A] [StarRing A]\n    [Module ℂ A] [AddCommGroup E] [Module ℂ E] [PartialOrder A] [SMul Aᵐᵒᵖ E] [Norm A] [Norm E]\n    extends Inner A E where\n  inner_add_right {x} {y} {z} : inner x (y + z) = inner x y + inner x z\n  inner_self_nonneg {x} : 0 ≤ inner x x\n  inner_self {x} : inner x x = 0 ↔ x = 0\n  inner_op_smul_right {a : A} {x y : E} : inner x (y <• a) = inner x y * a\n  inner_smul_right_complex {z : ℂ} {x} {y} : inner x (z • y) = z • inner x y\n  star_inner x y : star (inner x y) = inner y x\n  norm_eq_sqrt_norm_inner_self x : ‖x‖ = √‖inner x x‖\n\n"}
{"name":"CStarModule.star_inner","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : outParam (Type u_1)\nE : Type u_2\ninst✝⁸ : NonUnitalSemiring A\ninst✝⁷ : StarRing A\ninst✝⁶ : Module Complex A\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Complex E\ninst✝³ : PartialOrder A\ninst✝² : SMul (MulOpposite A) E\ninst✝¹ : Norm A\ninst✝ : Norm E\nself : CStarModule A E\nx y : E\n⊢ Eq (Star.star (Inner.inner x y)) (Inner.inner y x)","decl":"/-- A *Hilbert C⋆-module* is a complex module `E` endowed with a right `A`-module structure\n(where `A` is typically a C⋆-algebra) and an inner product `⟪x, y⟫_A` which satisfies the\nfollowing properties. -/\nclass CStarModule (A : outParam <| Type*) (E : Type*) [NonUnitalSemiring A] [StarRing A]\n    [Module ℂ A] [AddCommGroup E] [Module ℂ E] [PartialOrder A] [SMul Aᵐᵒᵖ E] [Norm A] [Norm E]\n    extends Inner A E where\n  inner_add_right {x} {y} {z} : inner x (y + z) = inner x y + inner x z\n  inner_self_nonneg {x} : 0 ≤ inner x x\n  inner_self {x} : inner x x = 0 ↔ x = 0\n  inner_op_smul_right {a : A} {x y : E} : inner x (y <• a) = inner x y * a\n  inner_smul_right_complex {z : ℂ} {x} {y} : inner x (z • y) = z • inner x y\n  star_inner x y : star (inner x y) = inner y x\n  norm_eq_sqrt_norm_inner_self x : ‖x‖ = √‖inner x x‖\n\n"}
{"name":"CStarModule.inner_add_left","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁹ : NonUnitalRing A\ninst✝⁸ : StarRing A\ninst✝⁷ : AddCommGroup E\ninst✝⁶ : Module Complex A\ninst✝⁵ : Module Complex E\ninst✝⁴ : PartialOrder A\ninst✝³ : SMul (MulOpposite A) E\ninst✝² : Norm A\ninst✝¹ : Norm E\ninst✝ : CStarModule A E\nx y z : E\n⊢ Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))","decl":"@[simp]\nlemma inner_add_left {x y z : E} : ⟪x + y, z⟫ = ⟪x, z⟫ + ⟪y, z⟫ := by\n  rw [← star_star (r := ⟪x + y, z⟫)]\n  simp only [inner_add_right, star_add, star_inner]\n\n"}
{"name":"CStarModule.inner_op_smul_left","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁹ : NonUnitalRing A\ninst✝⁸ : StarRing A\ninst✝⁷ : AddCommGroup E\ninst✝⁶ : Module Complex A\ninst✝⁵ : Module Complex E\ninst✝⁴ : PartialOrder A\ninst✝³ : SMul (MulOpposite A) E\ninst✝² : Norm A\ninst✝¹ : Norm E\ninst✝ : CStarModule A E\na : A\nx y : E\n⊢ Eq (Inner.inner (HSMul.hSMul (MulOpposite.op a) x) y) (HMul.hMul (Star.star a) (Inner.inner x y))","decl":"@[simp]\nlemma inner_op_smul_left {a : A} {x y : E} : ⟪x <• a, y⟫ = star a * ⟪x, y⟫ := by\n  rw [← star_inner]; simp\n\n"}
{"name":"CStarModule.inner_smul_left_complex","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : StarRing A\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Complex A\ninst✝⁶ : Module Complex E\ninst✝⁵ : PartialOrder A\ninst✝⁴ : SMul (MulOpposite A) E\ninst✝³ : Norm A\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarModule Complex A\nz : Complex\nx y : E\n⊢ Eq (Inner.inner (HSMul.hSMul z x) y) (HSMul.hSMul (Star.star z) (Inner.inner x y))","decl":"@[simp]\nlemma inner_smul_left_complex {z : ℂ} {x y : E} : ⟪z • x, y⟫ = star z • ⟪x, y⟫ := by\n  rw [← star_inner]\n  simp\n\n"}
{"name":"CStarModule.inner_smul_left_real","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : StarRing A\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Complex A\ninst✝⁶ : Module Complex E\ninst✝⁵ : PartialOrder A\ninst✝⁴ : SMul (MulOpposite A) E\ninst✝³ : Norm A\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarModule Complex A\nz : Real\nx y : E\n⊢ Eq (Inner.inner (HSMul.hSMul z x) y) (HSMul.hSMul z (Inner.inner x y))","decl":"@[simp]\nlemma inner_smul_left_real {z : ℝ} {x y : E} : ⟪z • x, y⟫ = z • ⟪x, y⟫ := by\n  have h₁ : z • x = (z : ℂ) • x := by simp\n  rw [h₁, ← star_inner, inner_smul_right_complex]\n  simp\n\n"}
{"name":"CStarModule.inner_smul_right_real","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : StarRing A\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Complex A\ninst✝⁶ : Module Complex E\ninst✝⁵ : PartialOrder A\ninst✝⁴ : SMul (MulOpposite A) E\ninst✝³ : Norm A\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarModule Complex A\nz : Real\nx y : E\n⊢ Eq (Inner.inner x (HSMul.hSMul z y)) (HSMul.hSMul z (Inner.inner x y))","decl":"@[simp]\nlemma inner_smul_right_real {z : ℝ} {x y : E} : ⟪x, z • y⟫ = z • ⟪x, y⟫ := by\n  have h₁ : z • y = (z : ℂ) • y := by simp\n  rw [h₁, ← star_inner, inner_smul_left_complex]\n  simp\n\n"}
{"name":"CStarModule.innerₛₗ_apply","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : StarRing A\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Complex A\ninst✝⁶ : Module Complex E\ninst✝⁵ : PartialOrder A\ninst✝⁴ : SMul (MulOpposite A) E\ninst✝³ : Norm A\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarModule Complex A\nx y : E\n⊢ Eq ((CStarModule.innerₛₗ x) y) (Inner.inner x y)","decl":"lemma innerₛₗ_apply {x y : E} : innerₛₗ x y = ⟪x, y⟫ := rfl\n\n"}
{"name":"CStarModule.inner_zero_right","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : StarRing A\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Complex A\ninst✝⁶ : Module Complex E\ninst✝⁵ : PartialOrder A\ninst✝⁴ : SMul (MulOpposite A) E\ninst✝³ : Norm A\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarModule Complex A\nx : E\n⊢ Eq (Inner.inner x 0) 0","decl":"@[simp] lemma inner_zero_right {x : E} : ⟪x, 0⟫ = 0 := by simp [← innerₛₗ_apply]\n"}
{"name":"CStarModule.inner_zero_left","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : StarRing A\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Complex A\ninst✝⁶ : Module Complex E\ninst✝⁵ : PartialOrder A\ninst✝⁴ : SMul (MulOpposite A) E\ninst✝³ : Norm A\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarModule Complex A\nx : E\n⊢ Eq (Inner.inner 0 x) 0","decl":"@[simp] lemma inner_zero_left {x : E} : ⟪0, x⟫ = 0 := by simp [← innerₛₗ_apply]\n"}
{"name":"CStarModule.inner_neg_right","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : StarRing A\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Complex A\ninst✝⁶ : Module Complex E\ninst✝⁵ : PartialOrder A\ninst✝⁴ : SMul (MulOpposite A) E\ninst✝³ : Norm A\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarModule Complex A\nx y : E\n⊢ Eq (Inner.inner x (Neg.neg y)) (Neg.neg (Inner.inner x y))","decl":"@[simp] lemma inner_neg_right {x y : E} : ⟪x, -y⟫ = -⟪x, y⟫ := by simp [← innerₛₗ_apply]\n"}
{"name":"CStarModule.inner_neg_left","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : StarRing A\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Complex A\ninst✝⁶ : Module Complex E\ninst✝⁵ : PartialOrder A\ninst✝⁴ : SMul (MulOpposite A) E\ninst✝³ : Norm A\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarModule Complex A\nx y : E\n⊢ Eq (Inner.inner (Neg.neg x) y) (Neg.neg (Inner.inner x y))","decl":"@[simp] lemma inner_neg_left {x y : E} : ⟪-x, y⟫ = -⟪x, y⟫ := by simp [← innerₛₗ_apply]\n"}
{"name":"CStarModule.inner_sub_right","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : StarRing A\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Complex A\ninst✝⁶ : Module Complex E\ninst✝⁵ : PartialOrder A\ninst✝⁴ : SMul (MulOpposite A) E\ninst✝³ : Norm A\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarModule Complex A\nx y z : E\n⊢ Eq (Inner.inner x (HSub.hSub y z)) (HSub.hSub (Inner.inner x y) (Inner.inner x z))","decl":"@[simp] lemma inner_sub_right {x y z : E} : ⟪x, y - z⟫ = ⟪x, y⟫ - ⟪x, z⟫ := by\n  simp [← innerₛₗ_apply]\n"}
{"name":"CStarModule.inner_sub_left","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : StarRing A\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Complex A\ninst✝⁶ : Module Complex E\ninst✝⁵ : PartialOrder A\ninst✝⁴ : SMul (MulOpposite A) E\ninst✝³ : Norm A\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarModule Complex A\nx y z : E\n⊢ Eq (Inner.inner (HSub.hSub x y) z) (HSub.hSub (Inner.inner x z) (Inner.inner y z))","decl":"@[simp] lemma inner_sub_left {x y z : E} : ⟪x - y, z⟫ = ⟪x, z⟫ - ⟪y, z⟫ := by\n  simp [← innerₛₗ_apply]\n\n"}
{"name":"CStarModule.inner_sum_right","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : StarRing A\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Complex A\ninst✝⁶ : Module Complex E\ninst✝⁵ : PartialOrder A\ninst✝⁴ : SMul (MulOpposite A) E\ninst✝³ : Norm A\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarModule Complex A\nι : Type u_3\ns : Finset ι\nx : E\ny : ι → E\n⊢ Eq (Inner.inner x (s.sum fun i => y i)) (s.sum fun i => Inner.inner x (y i))","decl":"@[simp]\nlemma inner_sum_right {ι : Type*} {s : Finset ι} {x : E} {y : ι → E} :\n    ⟪x, ∑ i ∈ s, y i⟫ = ∑ i ∈ s, ⟪x, y i⟫ :=\n  map_sum (innerₛₗ x) ..\n\n"}
{"name":"CStarModule.inner_sum_left","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : StarRing A\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Complex A\ninst✝⁶ : Module Complex E\ninst✝⁵ : PartialOrder A\ninst✝⁴ : SMul (MulOpposite A) E\ninst✝³ : Norm A\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarModule Complex A\nι : Type u_3\ns : Finset ι\nx : ι → E\ny : E\n⊢ Eq (Inner.inner (s.sum fun i => x i) y) (s.sum fun i => Inner.inner (x i) y)","decl":"@[simp]\nlemma inner_sum_left {ι : Type*} {s : Finset ι} {x : ι → E} {y : E} :\n    ⟪∑ i ∈ s, x i, y⟫ = ∑ i ∈ s, ⟪x i, y⟫ :=\n  map_sum (innerₛₗ.flip y) ..\n\n"}
{"name":"CStarModule.isSelfAdjoint_inner_self","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁹ : NonUnitalRing A\ninst✝⁸ : StarRing A\ninst✝⁷ : AddCommGroup E\ninst✝⁶ : Module Complex A\ninst✝⁵ : Module Complex E\ninst✝⁴ : PartialOrder A\ninst✝³ : SMul (MulOpposite A) E\ninst✝² : Norm A\ninst✝¹ : Norm E\ninst✝ : CStarModule A E\nx : E\n⊢ IsSelfAdjoint (Inner.inner x x)","decl":"@[simp]\nlemma isSelfAdjoint_inner_self {x : E} : IsSelfAdjoint ⟪x, x⟫ := star_inner _ _\n\n"}
{"name":"CStarModule.norm_sq_eq","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁶ : NonUnitalCStarAlgebra A\ninst✝⁵ : PartialOrder A\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Complex E\ninst✝² : SMul (MulOpposite A) E\ninst✝¹ : Norm E\ninst✝ : CStarModule A E\nx : E\n⊢ Eq (HPow.hPow (Norm.norm x) 2) (Norm.norm (Inner.inner x x))","decl":"lemma norm_sq_eq {x : E} : ‖x‖ ^ 2 = ‖⟪x, x⟫‖ := by simp [norm_eq_sqrt_norm_inner_self]\n\n"}
{"name":"CStarModule.norm_nonneg","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁶ : NonUnitalCStarAlgebra A\ninst✝⁵ : PartialOrder A\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Complex E\ninst✝² : SMul (MulOpposite A) E\ninst✝¹ : Norm E\ninst✝ : CStarModule A E\nx : E\n⊢ LE.le 0 (Norm.norm x)","decl":"protected lemma norm_nonneg {x : E} : 0 ≤ ‖x‖ := by simp [norm_eq_sqrt_norm_inner_self]\n\n"}
{"name":"CStarModule.norm_pos","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁶ : NonUnitalCStarAlgebra A\ninst✝⁵ : PartialOrder A\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Complex E\ninst✝² : SMul (MulOpposite A) E\ninst✝¹ : Norm E\ninst✝ : CStarModule A E\nx : E\nhx : Ne x 0\n⊢ LT.lt 0 (Norm.norm x)","decl":"protected lemma norm_pos {x : E} (hx : x ≠ 0) : 0 < ‖x‖ := by\n  simp only [norm_eq_sqrt_norm_inner_self, Real.sqrt_pos, norm_pos_iff]\n  intro H\n  rw [inner_self] at H\n  exact hx H\n\n"}
{"name":"CStarModule.norm_zero","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁶ : NonUnitalCStarAlgebra A\ninst✝⁵ : PartialOrder A\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Complex E\ninst✝² : SMul (MulOpposite A) E\ninst✝¹ : Norm E\ninst✝ : CStarModule A E\n⊢ Eq (Norm.norm 0) 0","decl":"protected lemma norm_zero : ‖(0 : E)‖ = 0 := by simp [norm_eq_sqrt_norm_inner_self]\n\n"}
{"name":"CStarModule.norm_zero_iff","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁶ : NonUnitalCStarAlgebra A\ninst✝⁵ : PartialOrder A\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Complex E\ninst✝² : SMul (MulOpposite A) E\ninst✝¹ : Norm E\ninst✝ : CStarModule A E\nx : E\n⊢ Iff (Eq (Norm.norm x) 0) (Eq x 0)","decl":"lemma norm_zero_iff (x : E) : ‖x‖ = 0 ↔ x = 0 :=\n  ⟨fun h => by simpa [norm_eq_sqrt_norm_inner_self, inner_self] using h,\n    fun h => by simp [norm, h, norm_eq_sqrt_norm_inner_self]⟩\n\n"}
{"name":"CStarModule.inner_mul_inner_swap_le","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁷ : NonUnitalCStarAlgebra A\ninst✝⁶ : PartialOrder A\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Complex E\ninst✝³ : SMul (MulOpposite A) E\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarOrderedRing A\nx y : E\n⊢ LE.le (HMul.hMul (Inner.inner y x) (Inner.inner x y)) (HSMul.hSMul (HPow.hPow (Norm.norm x) 2) (Inner.inner y y))","decl":"open scoped InnerProductSpace in\n/-- The C⋆-algebra-valued Cauchy-Schwarz inequality for Hilbert C⋆-modules. -/\nlemma inner_mul_inner_swap_le {x y : E} : ⟪y, x⟫ * ⟪x, y⟫ ≤ ‖x‖ ^ 2 • ⟪y, y⟫ := by\n  rcases eq_or_ne x 0 with h|h\n  · simp [h, CStarModule.norm_zero (E := E)]\n  · have h₁ : ∀ (a : A),\n        (0 : A) ≤ ‖x‖ ^ 2 • (star a * a) - ‖x‖ ^ 2 • (⟪y, x⟫ * a)\n                  - ‖x‖ ^ 2 • (star a * ⟪x, y⟫) + ‖x‖ ^ 2 • (‖x‖ ^ 2 • ⟪y, y⟫) := fun a => by\n      calc (0 : A) ≤ ⟪x <• a - ‖x‖ ^ 2 • y, x <• a - ‖x‖ ^ 2 • y⟫_A := by\n                      exact inner_self_nonneg\n            _ = star a * ⟪x, x⟫ * a - ‖x‖ ^ 2 • (⟪y, x⟫ * a)\n                  - ‖x‖ ^ 2 • (star a * ⟪x, y⟫) + ‖x‖ ^ 2 • (‖x‖ ^ 2 • ⟪y, y⟫) := by\n                      simp only [inner_sub_right, inner_op_smul_right, inner_sub_left,\n                        inner_op_smul_left, inner_smul_left_real, sub_mul, smul_mul_assoc,\n                        inner_smul_right_real, smul_sub]\n                      abel\n            _ ≤ ‖x‖ ^ 2 • (star a * a) - ‖x‖ ^ 2 • (⟪y, x⟫ * a)\n                  - ‖x‖ ^ 2 • (star a * ⟪x, y⟫) + ‖x‖ ^ 2 • (‖x‖ ^ 2 • ⟪y, y⟫) := by\n                      gcongr\n                      calc _ ≤ ‖⟪x, x⟫_A‖ • (star a * a) := CStarAlgebra.conjugate_le_norm_smul\n                        _ = (Real.sqrt ‖⟪x, x⟫_A‖) ^ 2 • (star a * a) := by\n                                  congr\n                                  have : 0 ≤ ‖⟪x, x⟫_A‖ := by positivity\n                                  rw [Real.sq_sqrt this]\n                        _ = ‖x‖ ^ 2 • (star a * a) := by rw [← norm_eq_sqrt_norm_inner_self]\n    specialize h₁ ⟪x, y⟫\n    simp only [star_inner, sub_self, zero_sub, le_neg_add_iff_add_le, add_zero] at h₁\n    rwa [smul_le_smul_iff_of_pos_left (pow_pos (CStarModule.norm_pos h) _)] at h₁\n\n"}
{"name":"CStarModule.norm_inner_le","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁷ : NonUnitalCStarAlgebra A\ninst✝⁶ : PartialOrder A\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Complex E\ninst✝³ : SMul (MulOpposite A) E\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarOrderedRing A\nx y : E\n⊢ LE.le (Norm.norm (Inner.inner x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"open scoped InnerProductSpace in\nvariable (E) in\n/-- The Cauchy-Schwarz inequality for Hilbert C⋆-modules. -/\nlemma norm_inner_le {x y : E} : ‖⟪x, y⟫‖ ≤ ‖x‖ * ‖y‖ := by\n  have := calc ‖⟪x, y⟫‖ ^ 2 = ‖⟪y, x⟫ * ⟪x, y⟫‖ := by\n                rw [← star_inner x, CStarRing.norm_star_mul_self, pow_two]\n    _ ≤ ‖‖x‖^ 2 • ⟪y, y⟫‖ := by\n                refine CStarAlgebra.norm_le_norm_of_nonneg_of_le ?_ inner_mul_inner_swap_le\n                rw [← star_inner x]\n                exact star_mul_self_nonneg ⟪x, y⟫_A\n    _ = ‖x‖ ^ 2 * ‖⟪y, y⟫‖ := by simp [norm_smul]\n    _ = ‖x‖ ^ 2 * ‖y‖ ^ 2 := by\n                simp only [norm_eq_sqrt_norm_inner_self, norm_nonneg, Real.sq_sqrt]\n    _ = (‖x‖ * ‖y‖) ^ 2 := by simp only [mul_pow]\n  refine (pow_le_pow_iff_left₀ (norm_nonneg ⟪x, y⟫_A) ?_ (by norm_num)).mp this\n  exact mul_nonneg CStarModule.norm_nonneg CStarModule.norm_nonneg\n\n"}
{"name":"CStarModule.norm_triangle","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁷ : NonUnitalCStarAlgebra A\ninst✝⁶ : PartialOrder A\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Complex E\ninst✝³ : SMul (MulOpposite A) E\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarOrderedRing A\nx y : E\n⊢ LE.le (Norm.norm (HAdd.hAdd x y)) (HAdd.hAdd (Norm.norm x) (Norm.norm y))","decl":"include A in\nprotected lemma norm_triangle (x y : E) : ‖x + y‖ ≤ ‖x‖ + ‖y‖ := by\n  have h : ‖x + y‖ ^ 2 ≤ (‖x‖ + ‖y‖) ^ 2 := by\n    calc _ ≤ ‖⟪x, x⟫ + ⟪y, x⟫‖ + ‖⟪x, y⟫‖ + ‖⟪y, y⟫‖ := by\n          simp only [norm_eq_sqrt_norm_inner_self, inner_add_right, inner_add_left, ← add_assoc,\n            norm_nonneg, Real.sq_sqrt]\n          exact norm_add₃_le\n      _ ≤ ‖⟪x, x⟫‖ + ‖⟪y, x⟫‖ + ‖⟪x, y⟫‖ + ‖⟪y, y⟫‖ := by gcongr; exact norm_add_le _ _\n      _ ≤ ‖⟪x, x⟫‖ + ‖y‖ * ‖x‖ + ‖x‖ * ‖y‖ + ‖⟪y, y⟫‖ := by gcongr <;> exact norm_inner_le E\n      _ = ‖x‖ ^ 2 + ‖y‖ * ‖x‖ + ‖x‖ * ‖y‖ + ‖y‖ ^ 2 := by\n          simp [norm_eq_sqrt_norm_inner_self]\n      _ = (‖x‖ + ‖y‖) ^ 2 := by simp only [add_pow_two, add_left_inj]; ring\n  refine (pow_le_pow_iff_left₀ CStarModule.norm_nonneg ?_ (by norm_num)).mp h\n  exact add_nonneg CStarModule.norm_nonneg CStarModule.norm_nonneg\n\n"}
{"name":"CStarModule.normedSpaceCore","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁷ : NonUnitalCStarAlgebra A\ninst✝⁶ : PartialOrder A\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Complex E\ninst✝³ : SMul (MulOpposite A) E\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarOrderedRing A\n⊢ NormedSpace.Core Complex E","decl":"include A in\n/-- This allows us to get `NormedAddCommGroup` and `NormedSpace` instances on `E` via\n`NormedAddCommGroup.ofCore` and `NormedSpace.ofCore`. -/\nlemma normedSpaceCore : NormedSpace.Core ℂ E where\n  norm_nonneg _ := CStarModule.norm_nonneg\n  norm_eq_zero_iff x := norm_zero_iff x\n  norm_smul c x := by simp [norm_eq_sqrt_norm_inner_self, norm_smul, ← mul_assoc]\n  norm_triangle x y := CStarModule.norm_triangle x y\n\n"}
{"name":"CStarModule.norm_eq_csSup","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁷ : NonUnitalCStarAlgebra A\ninst✝⁶ : PartialOrder A\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Complex E\ninst✝³ : SMul (MulOpposite A) E\ninst✝² : Norm E\ninst✝¹ : CStarModule A E\ninst✝ : StarOrderedRing A\nv : E\n⊢ Eq (Norm.norm v) (SupSet.sSup (setOf fun x => Exists fun w => Exists fun x_1 => Eq (Norm.norm (Inner.inner w v)) x))","decl":"open scoped InnerProductSpace in\nlemma norm_eq_csSup (v : E) :\n    ‖v‖ = sSup { ‖⟪w, v⟫_A‖ | (w : E) (_ : ‖w‖ ≤ 1) } := by\n  let instNACG : NormedAddCommGroup E := NormedAddCommGroup.ofCore normedSpaceCore\n  let instNS : NormedSpace ℂ E := .ofCore normedSpaceCore\n  refine Eq.symm <| IsGreatest.csSup_eq ⟨⟨‖v‖⁻¹ • v, ?_, ?_⟩, ?_⟩\n  · simpa only [norm_smul, norm_inv, norm_norm] using inv_mul_le_one_of_le₀ le_rfl (by positivity)\n  · simp [norm_smul, ← norm_sq_eq, pow_two, ← mul_assoc]\n  · rintro - ⟨w, hw, rfl⟩\n    calc _ ≤ ‖w‖ * ‖v‖ := norm_inner_le E\n      _ ≤ 1 * ‖v‖ := by gcongr\n      _ = ‖v‖ := by simp\n\n"}
{"name":"CStarModule.innerSL_apply","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁶ : NonUnitalCStarAlgebra A\ninst✝⁵ : PartialOrder A\ninst✝⁴ : StarOrderedRing A\ninst✝³ : SMul (MulOpposite A) E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CStarModule A E\nx y : E\n⊢ Eq ((CStarModule.innerSL x) y) (Inner.inner x y)","decl":"lemma innerSL_apply {x y : E} : innerSL x y = ⟪x, y⟫_A := rfl\n\n"}
{"name":"CStarModule.continuous_inner","module":"Mathlib.Analysis.CStarAlgebra.Module.Defs","initialProofState":"A : Type u_1\nE : Type u_2\ninst✝⁶ : NonUnitalCStarAlgebra A\ninst✝⁵ : PartialOrder A\ninst✝⁴ : StarOrderedRing A\ninst✝³ : SMul (MulOpposite A) E\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CStarModule A E\n⊢ Continuous fun x => Inner.inner x.1 x.2","decl":"@[continuity, fun_prop]\nlemma continuous_inner : Continuous (fun x : E × E => ⟪x.1, x.2⟫_A) := by\n  simp_rw [← innerSL_apply]\n  fun_prop\n\n"}
