{"name":"CategoryTheory.Endofunctor.Algebra.mk.inj","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\na‚úù : C\nstr‚úù : Quiver.Hom (F.obj a‚úù) a‚úù\na : C\nstr : Quiver.Hom (F.obj a) a\nx‚úù : Eq { a := a‚úù, str := str‚úù } { a := a, str := str }\n‚ä¢ And (Eq a‚úù a) (HEq str‚úù str)","decl":"/-- An algebra of an endofunctor; `str` stands for \"structure morphism\" -/\nstructure Algebra (F : C ‚•§ C) where\n  /-- carrier of the algebra -/\n  a : C\n  /-- structure morphism of the algebra -/\n  str : F.obj a ‚ü∂ a\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\ninst‚úù : SizeOf C\na : C\nstr : Quiver.Hom (F.obj a) a\n‚ä¢ Eq (SizeOf.sizeOf { a := a, str := str }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf str))","decl":"/-- An algebra of an endofunctor; `str` stands for \"structure morphism\" -/\nstructure Algebra (F : C ‚•§ C) where\n  /-- carrier of the algebra -/\n  a : C\n  /-- structure morphism of the algebra -/\n  str : F.obj a ‚ü∂ a\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.mk.injEq","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\na‚úù : C\nstr‚úù : Quiver.Hom (F.obj a‚úù) a‚úù\na : C\nstr : Quiver.Hom (F.obj a) a\n‚ä¢ Eq (Eq { a := a‚úù, str := str‚úù } { a := a, str := str }) (And (Eq a‚úù a) (HEq str‚úù str))","decl":"/-- An algebra of an endofunctor; `str` stands for \"structure morphism\" -/\nstructure Algebra (F : C ‚•§ C) where\n  /-- carrier of the algebra -/\n  a : C\n  /-- structure morphism of the algebra -/\n  str : F.obj a ‚ü∂ a\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.Hom.mk.inj","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA‚ÇÄ A‚ÇÅ : CategoryTheory.Endofunctor.Algebra F\nf‚úù : Quiver.Hom A‚ÇÄ.a A‚ÇÅ.a\nh‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map f‚úù) A‚ÇÅ.str) (CategoryTheory.CategoryStruct.comp A‚ÇÄ.str f‚úù)) _auto‚úù\nf : Quiver.Hom A‚ÇÄ.a A‚ÇÅ.a\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map f) A‚ÇÅ.str) (CategoryTheory.CategoryStruct.comp A‚ÇÄ.str f)) _auto‚úù\nx‚úù : Eq { f := f‚úù, h := h‚úù } { f := f, h := h }\n‚ä¢ Eq f‚úù f","decl":"/-- A morphism between algebras of endofunctor `F` -/\n@[ext]\nstructure Hom (A‚ÇÄ A‚ÇÅ : Algebra F) where\n  /-- underlying morphism between the carriers -/\n  f : A‚ÇÄ.1 ‚ü∂ A‚ÇÅ.1\n  /-- compatibility condition -/\n  h : F.map f ‚â´ A‚ÇÅ.str = A‚ÇÄ.str ‚â´ f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA‚ÇÄ A‚ÇÅ : CategoryTheory.Endofunctor.Algebra F\ninst‚úù : SizeOf C\nf : Quiver.Hom A‚ÇÄ.a A‚ÇÅ.a\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map f) A‚ÇÅ.str) (CategoryTheory.CategoryStruct.comp A‚ÇÄ.str f)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { f := f, h := h }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f)) (SizeOf.sizeOf h))","decl":"/-- A morphism between algebras of endofunctor `F` -/\n@[ext]\nstructure Hom (A‚ÇÄ A‚ÇÅ : Algebra F) where\n  /-- underlying morphism between the carriers -/\n  f : A‚ÇÄ.1 ‚ü∂ A‚ÇÅ.1\n  /-- compatibility condition -/\n  h : F.map f ‚â´ A‚ÇÅ.str = A‚ÇÄ.str ‚â´ f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA‚ÇÄ A‚ÇÅ : CategoryTheory.Endofunctor.Algebra F\nf‚úù : Quiver.Hom A‚ÇÄ.a A‚ÇÅ.a\nh‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map f‚úù) A‚ÇÅ.str) (CategoryTheory.CategoryStruct.comp A‚ÇÄ.str f‚úù)) _auto‚úù\nf : Quiver.Hom A‚ÇÄ.a A‚ÇÅ.a\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map f) A‚ÇÅ.str) (CategoryTheory.CategoryStruct.comp A‚ÇÄ.str f)) _auto‚úù\n‚ä¢ Eq (Eq { f := f‚úù, h := h‚úù } { f := f, h := h }) (Eq f‚úù f)","decl":"/-- A morphism between algebras of endofunctor `F` -/\n@[ext]\nstructure Hom (A‚ÇÄ A‚ÇÅ : Algebra F) where\n  /-- underlying morphism between the carriers -/\n  f : A‚ÇÄ.1 ‚ü∂ A‚ÇÅ.1\n  /-- compatibility condition -/\n  h : F.map f ‚â´ A‚ÇÅ.str = A‚ÇÄ.str ‚â´ f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.Hom.ext_iff","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA‚ÇÄ A‚ÇÅ : CategoryTheory.Endofunctor.Algebra F\nx y : A‚ÇÄ.Hom A‚ÇÅ\n‚ä¢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- A morphism between algebras of endofunctor `F` -/\n@[ext]\nstructure Hom (A‚ÇÄ A‚ÇÅ : Algebra F) where\n  /-- underlying morphism between the carriers -/\n  f : A‚ÇÄ.1 ‚ü∂ A‚ÇÅ.1\n  /-- compatibility condition -/\n  h : F.map f ‚â´ A‚ÇÅ.str = A‚ÇÄ.str ‚â´ f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.Hom.h","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA‚ÇÄ A‚ÇÅ : CategoryTheory.Endofunctor.Algebra F\nself : A‚ÇÄ.Hom A‚ÇÅ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map self.f) A‚ÇÅ.str) (CategoryTheory.CategoryStruct.comp A‚ÇÄ.str self.f)","decl":"/-- A morphism between algebras of endofunctor `F` -/\n@[ext]\nstructure Hom (A‚ÇÄ A‚ÇÅ : Algebra F) where\n  /-- underlying morphism between the carriers -/\n  f : A‚ÇÄ.1 ‚ü∂ A‚ÇÅ.1\n  /-- compatibility condition -/\n  h : F.map f ‚â´ A‚ÇÅ.str = A‚ÇÄ.str ‚â´ f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.Hom.ext","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA‚ÇÄ A‚ÇÅ : CategoryTheory.Endofunctor.Algebra F\nx y : A‚ÇÄ.Hom A‚ÇÅ\nf : Eq x.f y.f\n‚ä¢ Eq x y","decl":"/-- A morphism between algebras of endofunctor `F` -/\n@[ext]\nstructure Hom (A‚ÇÄ A‚ÇÅ : Algebra F) where\n  /-- underlying morphism between the carriers -/\n  f : A‚ÇÄ.1 ‚ü∂ A‚ÇÅ.1\n  /-- compatibility condition -/\n  h : F.map f ‚â´ A‚ÇÅ.str = A‚ÇÄ.str ‚â´ f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.Hom.h_assoc","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA‚ÇÄ A‚ÇÅ : CategoryTheory.Endofunctor.Algebra F\nself : A‚ÇÄ.Hom A‚ÇÅ\nZ : C\nh : Quiver.Hom A‚ÇÅ.a Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map self.f) (CategoryTheory.CategoryStruct.comp A‚ÇÅ.str h)) (CategoryTheory.CategoryStruct.comp A‚ÇÄ.str (CategoryTheory.CategoryStruct.comp self.f h))","decl":"attribute [reassoc (attr := simp)] Hom.h\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.ext","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA B : CategoryTheory.Endofunctor.Algebra F\nf g : Quiver.Hom A B\nw : autoParam (Eq f.f g.f) _auto‚úù\n‚ä¢ Eq f g","decl":"@[ext]\nlemma ext {A B : Algebra F} {f g : A ‚ü∂ B} (w : f.f = g.f := by aesop_cat) : f = g :=\n  Hom.ext w\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.ext_iff","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA B : CategoryTheory.Endofunctor.Algebra F\nf g : Quiver.Hom A B\n‚ä¢ Iff (Eq f g) (autoParam (Eq f.f g.f) _auto‚úù)","decl":"@[ext]\nlemma ext {A B : Algebra F} {f g : A ‚ü∂ B} (w : f.f = g.f := by aesop_cat) : f = g :=\n  Hom.ext w\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.id_eq_id","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA : CategoryTheory.Endofunctor.Algebra F\n‚ä¢ Eq (CategoryTheory.Endofunctor.Algebra.Hom.id A) (CategoryTheory.CategoryStruct.id A)","decl":"@[simp]\ntheorem id_eq_id : Algebra.Hom.id A = ùüô A :=\n  rfl\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.id_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA : CategoryTheory.Endofunctor.Algebra F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id A).f (CategoryTheory.CategoryStruct.id A.a)","decl":"@[simp]\ntheorem id_f : (ùüô _ : A ‚ü∂ A).1 = ùüô A.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.comp_eq_comp","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA‚ÇÄ A‚ÇÅ A‚ÇÇ : CategoryTheory.Endofunctor.Algebra F\nf : Quiver.Hom A‚ÇÄ A‚ÇÅ\ng : Quiver.Hom A‚ÇÅ A‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Endofunctor.Algebra.Hom.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"@[simp]\ntheorem comp_eq_comp : Algebra.Hom.comp f g = f ‚â´ g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.comp_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA‚ÇÄ A‚ÇÅ A‚ÇÇ : CategoryTheory.Endofunctor.Algebra F\nf : Quiver.Hom A‚ÇÄ A‚ÇÅ\ng : Quiver.Hom A‚ÇÅ A‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).f (CategoryTheory.CategoryStruct.comp f.f g.f)","decl":"@[simp]\ntheorem comp_f : (f ‚â´ g).1 = f.1 ‚â´ g.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.isoMk_hom_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA‚ÇÄ A‚ÇÅ : CategoryTheory.Endofunctor.Algebra F\nh : CategoryTheory.Iso A‚ÇÄ.a A‚ÇÅ.a\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map h.hom) A‚ÇÅ.str) (CategoryTheory.CategoryStruct.comp A‚ÇÄ.str h.hom)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Endofunctor.Algebra.isoMk h w).hom.f h.hom","decl":"/-- To construct an isomorphism of algebras, it suffices to give an isomorphism of the As which\ncommutes with the structure morphisms.\n-/\n@[simps!]\ndef isoMk (h : A‚ÇÄ.1 ‚âÖ A‚ÇÅ.1) (w : F.map h.hom ‚â´ A‚ÇÅ.str = A‚ÇÄ.str ‚â´ h.hom := by aesop_cat) :\n    A‚ÇÄ ‚âÖ A‚ÇÅ where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_comp_inv, Category.assoc, ‚Üê w, ‚Üê Functor.map_comp_assoc]\n        simp }\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.isoMk_inv_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA‚ÇÄ A‚ÇÅ : CategoryTheory.Endofunctor.Algebra F\nh : CategoryTheory.Iso A‚ÇÄ.a A‚ÇÅ.a\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map h.hom) A‚ÇÅ.str) (CategoryTheory.CategoryStruct.comp A‚ÇÄ.str h.hom)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Endofunctor.Algebra.isoMk h w).inv.f h.inv","decl":"/-- To construct an isomorphism of algebras, it suffices to give an isomorphism of the As which\ncommutes with the structure morphisms.\n-/\n@[simps!]\ndef isoMk (h : A‚ÇÄ.1 ‚âÖ A‚ÇÅ.1) (w : F.map h.hom ‚â´ A‚ÇÅ.str = A‚ÇÄ.str ‚â´ h.hom := by aesop_cat) :\n    A‚ÇÄ ‚âÖ A‚ÇÅ where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_comp_inv, Category.assoc, ‚Üê w, ‚Üê Functor.map_comp_assoc]\n        simp }\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.forget_map","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX‚úù Y‚úù : CategoryTheory.Endofunctor.Algebra F\nself : X‚úù.Hom Y‚úù\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Algebra.forget F).map self) self.f","decl":"/-- The forgetful functor from the category of algebras, forgetting the algebraic structure. -/\n@[simps]\ndef forget (F : C ‚•§ C) : Algebra F ‚•§ C where\n  obj A := A.1\n  map := Hom.f\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.forget_obj","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA : CategoryTheory.Endofunctor.Algebra F\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Algebra.forget F).obj A) A.a","decl":"/-- The forgetful functor from the category of algebras, forgetting the algebraic structure. -/\n@[simps]\ndef forget (F : C ‚•§ C) : Algebra F ‚•§ C where\n  obj A := A.1\n  map := Hom.f\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.iso_of_iso","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA‚ÇÄ A‚ÇÅ : CategoryTheory.Endofunctor.Algebra F\nf : Quiver.Hom A‚ÇÄ A‚ÇÅ\ninst‚úù : CategoryTheory.IsIso f.f\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- An algebra morphism with an underlying isomorphism hom in `C` is an algebra isomorphism. -/\ntheorem iso_of_iso (f : A‚ÇÄ ‚ü∂ A‚ÇÅ) [IsIso f.1] : IsIso f :=\n  ‚ü®‚ü®{ f := inv f.1\n      h := by\n        rw [IsIso.eq_comp_inv f.1, Category.assoc, ‚Üê f.h]\n        simp }, by aesop_cat, by aesop_cat‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.forget_reflects_iso","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\n‚ä¢ (CategoryTheory.Endofunctor.Algebra.forget F).ReflectsIsomorphisms","decl":"instance forget_reflects_iso : (forget F).ReflectsIsomorphisms where reflects := iso_of_iso\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.forget_faithful","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\n‚ä¢ (CategoryTheory.Endofunctor.Algebra.forget F).Faithful","decl":"instance forget_faithful : (forget F).Faithful := { }\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.epi_of_epi","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX Y : CategoryTheory.Endofunctor.Algebra F\nf : Quiver.Hom X Y\nh : CategoryTheory.Epi f.f\n‚ä¢ CategoryTheory.Epi f","decl":"/-- An algebra morphism with an underlying epimorphism hom in `C` is an algebra epimorphism. -/\ntheorem epi_of_epi {X Y : Algebra F} (f : X ‚ü∂ Y) [h : Epi f.1] : Epi f :=\n  (forget F).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.mono_of_mono","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX Y : CategoryTheory.Endofunctor.Algebra F\nf : Quiver.Hom X Y\nh : CategoryTheory.Mono f.f\n‚ä¢ CategoryTheory.Mono f","decl":"/-- An algebra morphism with an underlying monomorphism hom in `C` is an algebra monomorphism. -/\ntheorem mono_of_mono {X Y : Algebra F} (f : X ‚ü∂ Y) [h : Mono f.1] : Mono f :=\n  (forget F).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.functorOfNatTrans_obj_str","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : Quiver.Hom G F\nA : CategoryTheory.Endofunctor.Algebra F\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Algebra.functorOfNatTrans Œ±).obj A).str (CategoryTheory.CategoryStruct.comp (Œ±.app A.a) A.str)","decl":"/-- From a natural transformation `Œ± : G ‚Üí F` we get a functor from\nalgebras of `F` to algebras of `G`.\n-/\n@[simps]\ndef functorOfNatTrans {F G : C ‚•§ C} (Œ± : G ‚ü∂ F) : Algebra F ‚•§ Algebra G where\n  obj A :=\n    { a := A.1\n      str := Œ±.app _ ‚â´ A.str }\n  map f := { f := f.1 }\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.functorOfNatTrans_obj_a","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : Quiver.Hom G F\nA : CategoryTheory.Endofunctor.Algebra F\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Algebra.functorOfNatTrans Œ±).obj A).a A.a","decl":"/-- From a natural transformation `Œ± : G ‚Üí F` we get a functor from\nalgebras of `F` to algebras of `G`.\n-/\n@[simps]\ndef functorOfNatTrans {F G : C ‚•§ C} (Œ± : G ‚ü∂ F) : Algebra F ‚•§ Algebra G where\n  obj A :=\n    { a := A.1\n      str := Œ±.app _ ‚â´ A.str }\n  map f := { f := f.1 }\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.functorOfNatTrans_map_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : Quiver.Hom G F\nX‚úù Y‚úù : CategoryTheory.Endofunctor.Algebra F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Algebra.functorOfNatTrans Œ±).map f).f f.f","decl":"/-- From a natural transformation `Œ± : G ‚Üí F` we get a functor from\nalgebras of `F` to algebras of `G`.\n-/\n@[simps]\ndef functorOfNatTrans {F G : C ‚•§ C} (Œ± : G ‚ü∂ F) : Algebra F ‚•§ Algebra G where\n  obj A :=\n    { a := A.1\n      str := Œ±.app _ ‚â´ A.str }\n  map f := { f := f.1 }\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.functorOfNatTransId_hom_app_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX : CategoryTheory.Endofunctor.Algebra F\n‚ä¢ Eq (CategoryTheory.Endofunctor.Algebra.functorOfNatTransId.hom.app X).f (CategoryTheory.CategoryStruct.id X.a)","decl":"/-- The identity transformation induces the identity endofunctor on the category of algebras. -/\n@[simps!]\ndef functorOfNatTransId : functorOfNatTrans (ùüô F) ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.functorOfNatTransId_inv_app_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX : CategoryTheory.Endofunctor.Algebra F\n‚ä¢ Eq (CategoryTheory.Endofunctor.Algebra.functorOfNatTransId.inv.app X).f (CategoryTheory.CategoryStruct.id X.a)","decl":"/-- The identity transformation induces the identity endofunctor on the category of algebras. -/\n@[simps!]\ndef functorOfNatTransId : functorOfNatTrans (ùüô F) ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.functorOfNatTransComp_inv_app_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÄ F‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C C\nŒ± : Quiver.Hom F‚ÇÄ F‚ÇÅ\nŒ≤ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nX : CategoryTheory.Endofunctor.Algebra F‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Algebra.functorOfNatTransComp Œ± Œ≤).inv.app X).f (CategoryTheory.CategoryStruct.id X.a)","decl":"/-- A composition of natural transformations gives the composition of corresponding functors. -/\n@[simps!]\ndef functorOfNatTransComp {F‚ÇÄ F‚ÇÅ F‚ÇÇ : C ‚•§ C} (Œ± : F‚ÇÄ ‚ü∂ F‚ÇÅ) (Œ≤ : F‚ÇÅ ‚ü∂ F‚ÇÇ) :\n    functorOfNatTrans (Œ± ‚â´ Œ≤) ‚âÖ functorOfNatTrans Œ≤ ‚ãô functorOfNatTrans Œ± :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.functorOfNatTransComp_hom_app_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÄ F‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C C\nŒ± : Quiver.Hom F‚ÇÄ F‚ÇÅ\nŒ≤ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nX : CategoryTheory.Endofunctor.Algebra F‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Algebra.functorOfNatTransComp Œ± Œ≤).hom.app X).f (CategoryTheory.CategoryStruct.id X.a)","decl":"/-- A composition of natural transformations gives the composition of corresponding functors. -/\n@[simps!]\ndef functorOfNatTransComp {F‚ÇÄ F‚ÇÅ F‚ÇÇ : C ‚•§ C} (Œ± : F‚ÇÄ ‚ü∂ F‚ÇÅ) (Œ≤ : F‚ÇÅ ‚ü∂ F‚ÇÇ) :\n    functorOfNatTrans (Œ± ‚â´ Œ≤) ‚âÖ functorOfNatTrans Œ≤ ‚ãô functorOfNatTrans Œ± :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.functorOfNatTransEq_inv_app_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± Œ≤ : Quiver.Hom F G\nh : Eq Œ± Œ≤\nX : CategoryTheory.Endofunctor.Algebra G\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Algebra.functorOfNatTransEq h).inv.app X).f (CategoryTheory.CategoryStruct.id X.a)","decl":"/--\nIf `Œ±` and `Œ≤` are two equal natural transformations, then the functors of algebras induced by them\nare isomorphic.\nWe define it like this as opposed to using `eq_to_iso` so that the components are nicer to prove\nlemmas about.\n-/\n@[simps!]\ndef functorOfNatTransEq {F G : C ‚•§ C} {Œ± Œ≤ : F ‚ü∂ G} (h : Œ± = Œ≤) :\n    functorOfNatTrans Œ± ‚âÖ functorOfNatTrans Œ≤ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.functorOfNatTransEq_hom_app_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± Œ≤ : Quiver.Hom F G\nh : Eq Œ± Œ≤\nX : CategoryTheory.Endofunctor.Algebra G\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Algebra.functorOfNatTransEq h).hom.app X).f (CategoryTheory.CategoryStruct.id X.a)","decl":"/--\nIf `Œ±` and `Œ≤` are two equal natural transformations, then the functors of algebras induced by them\nare isomorphic.\nWe define it like this as opposed to using `eq_to_iso` so that the components are nicer to prove\nlemmas about.\n-/\n@[simps!]\ndef functorOfNatTransEq {F G : C ‚•§ C} {Œ± Œ≤ : F ‚ü∂ G} (h : Œ± = Œ≤) :\n    functorOfNatTrans Œ± ‚âÖ functorOfNatTrans Œ≤ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.equivOfNatIso_counitIso","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.Endofunctor.Algebra.equivOfNatIso Œ±).counitIso ((CategoryTheory.Endofunctor.Algebra.functorOfNatTransComp Œ±.inv Œ±.hom).symm.trans ((CategoryTheory.Endofunctor.Algebra.functorOfNatTransEq ‚ãØ).trans CategoryTheory.Endofunctor.Algebra.functorOfNatTransId))","decl":"/-- Naturally isomorphic endofunctors give equivalent categories of algebras.\nFurthermore, they are equivalent as categories over `C`, that is,\nwe have `equiv_of_nat_iso h ‚ãô forget = forget`.\n-/\n@[simps]\ndef equivOfNatIso {F G : C ‚•§ C} (Œ± : F ‚âÖ G) : Algebra F ‚âå Algebra G where\n  functor := functorOfNatTrans Œ±.inv\n  inverse := functorOfNatTrans Œ±.hom\n  unitIso := functorOfNatTransId.symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransComp _ _\n  counitIso :=\n    (functorOfNatTransComp _ _).symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransId\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.equivOfNatIso_unitIso","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.Endofunctor.Algebra.equivOfNatIso Œ±).unitIso (CategoryTheory.Endofunctor.Algebra.functorOfNatTransId.symm.trans ((CategoryTheory.Endofunctor.Algebra.functorOfNatTransEq ‚ãØ).trans (CategoryTheory.Endofunctor.Algebra.functorOfNatTransComp Œ±.hom Œ±.inv)))","decl":"/-- Naturally isomorphic endofunctors give equivalent categories of algebras.\nFurthermore, they are equivalent as categories over `C`, that is,\nwe have `equiv_of_nat_iso h ‚ãô forget = forget`.\n-/\n@[simps]\ndef equivOfNatIso {F G : C ‚•§ C} (Œ± : F ‚âÖ G) : Algebra F ‚âå Algebra G where\n  functor := functorOfNatTrans Œ±.inv\n  inverse := functorOfNatTrans Œ±.hom\n  unitIso := functorOfNatTransId.symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransComp _ _\n  counitIso :=\n    (functorOfNatTransComp _ _).symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransId\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.equivOfNatIso_functor","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.Endofunctor.Algebra.equivOfNatIso Œ±).functor (CategoryTheory.Endofunctor.Algebra.functorOfNatTrans Œ±.inv)","decl":"/-- Naturally isomorphic endofunctors give equivalent categories of algebras.\nFurthermore, they are equivalent as categories over `C`, that is,\nwe have `equiv_of_nat_iso h ‚ãô forget = forget`.\n-/\n@[simps]\ndef equivOfNatIso {F G : C ‚•§ C} (Œ± : F ‚âÖ G) : Algebra F ‚âå Algebra G where\n  functor := functorOfNatTrans Œ±.inv\n  inverse := functorOfNatTrans Œ±.hom\n  unitIso := functorOfNatTransId.symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransComp _ _\n  counitIso :=\n    (functorOfNatTransComp _ _).symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransId\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.equivOfNatIso_inverse","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.Endofunctor.Algebra.equivOfNatIso Œ±).inverse (CategoryTheory.Endofunctor.Algebra.functorOfNatTrans Œ±.hom)","decl":"/-- Naturally isomorphic endofunctors give equivalent categories of algebras.\nFurthermore, they are equivalent as categories over `C`, that is,\nwe have `equiv_of_nat_iso h ‚ãô forget = forget`.\n-/\n@[simps]\ndef equivOfNatIso {F G : C ‚•§ C} (Œ± : F ‚âÖ G) : Algebra F ‚âå Algebra G where\n  functor := functorOfNatTrans Œ±.inv\n  inverse := functorOfNatTrans Œ±.hom\n  unitIso := functorOfNatTransId.symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransComp _ _\n  counitIso :=\n    (functorOfNatTransComp _ _).symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransId\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.Initial.left_inv'","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA : CategoryTheory.Endofunctor.Algebra F\nh : CategoryTheory.Limits.IsInitial A\n‚ä¢ Eq { f := CategoryTheory.CategoryStruct.comp (CategoryTheory.Endofunctor.Algebra.Initial.strInv h) A.str, h := ‚ãØ } (CategoryTheory.CategoryStruct.id A)","decl":"theorem left_inv' :\n    ‚ü®strInv h ‚â´ A.str, by rw [‚Üê Category.assoc, F.map_comp, strInv, ‚Üê Hom.h]‚ü© = ùüô A :=\n  Limits.IsInitial.hom_ext h _ (ùüô A)\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.Initial.left_inv","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA : CategoryTheory.Endofunctor.Algebra F\nh : CategoryTheory.Limits.IsInitial A\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Endofunctor.Algebra.Initial.strInv h) A.str) (CategoryTheory.CategoryStruct.id A.a)","decl":"theorem left_inv : strInv h ‚â´ A.str = ùüô _ :=\n  congr_arg Hom.f (left_inv' h)\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.Initial.right_inv","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA : CategoryTheory.Endofunctor.Algebra F\nh : CategoryTheory.Limits.IsInitial A\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.str (CategoryTheory.Endofunctor.Algebra.Initial.strInv h)) (CategoryTheory.CategoryStruct.id (F.obj A.a))","decl":"theorem right_inv : A.str ‚â´ strInv h = ùüô _ := by\n  rw [strInv, ‚Üê (h.to ‚ü®F.obj A.1, F.map A.str‚ü©).h, ‚Üê F.map_id, ‚Üê F.map_comp]\n  congr\n  exact left_inv h\n\n"}
{"name":"CategoryTheory.Endofunctor.Algebra.Initial.str_isIso","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA : CategoryTheory.Endofunctor.Algebra F\nh : CategoryTheory.Limits.IsInitial A\n‚ä¢ CategoryTheory.IsIso A.str","decl":"/-- The structure map of the initial algebra is an isomorphism,\nhence endofunctors preserve their initial algebras\n-/\ntheorem str_isIso (h : Limits.IsInitial A) : IsIso A.str :=\n  { out := ‚ü®strInv h, right_inv _, left_inv _‚ü© }\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\ninst‚úù : SizeOf C\nV : C\nstr : Quiver.Hom V (F.obj V)\n‚ä¢ Eq (SizeOf.sizeOf { V := V, str := str }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf V)) (SizeOf.sizeOf str))","decl":"/-- A coalgebra of an endofunctor; `str` stands for \"structure morphism\" -/\nstructure Coalgebra (F : C ‚•§ C) where\n  /-- carrier of the coalgebra -/\n  V : C\n  /-- structure morphism of the coalgebra -/\n  str : V ‚ü∂ F.obj V\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.mk.inj","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚úù : C\nstr‚úù : Quiver.Hom V‚úù (F.obj V‚úù)\nV : C\nstr : Quiver.Hom V (F.obj V)\nx‚úù : Eq { V := V‚úù, str := str‚úù } { V := V, str := str }\n‚ä¢ And (Eq V‚úù V) (HEq str‚úù str)","decl":"/-- A coalgebra of an endofunctor; `str` stands for \"structure morphism\" -/\nstructure Coalgebra (F : C ‚•§ C) where\n  /-- carrier of the coalgebra -/\n  V : C\n  /-- structure morphism of the coalgebra -/\n  str : V ‚ü∂ F.obj V\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.mk.injEq","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚úù : C\nstr‚úù : Quiver.Hom V‚úù (F.obj V‚úù)\nV : C\nstr : Quiver.Hom V (F.obj V)\n‚ä¢ Eq (Eq { V := V‚úù, str := str‚úù } { V := V, str := str }) (And (Eq V‚úù V) (HEq str‚úù str))","decl":"/-- A coalgebra of an endofunctor; `str` stands for \"structure morphism\" -/\nstructure Coalgebra (F : C ‚•§ C) where\n  /-- carrier of the coalgebra -/\n  V : C\n  /-- structure morphism of the coalgebra -/\n  str : V ‚ü∂ F.obj V\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚ÇÄ V‚ÇÅ : CategoryTheory.Endofunctor.Coalgebra F\nf‚úù : Quiver.Hom V‚ÇÄ.V V‚ÇÅ.V\nh‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp V‚ÇÄ.str (F.map f‚úù)) (CategoryTheory.CategoryStruct.comp f‚úù V‚ÇÅ.str)) _auto‚úù\nf : Quiver.Hom V‚ÇÄ.V V‚ÇÅ.V\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp V‚ÇÄ.str (F.map f)) (CategoryTheory.CategoryStruct.comp f V‚ÇÅ.str)) _auto‚úù\n‚ä¢ Eq (Eq { f := f‚úù, h := h‚úù } { f := f, h := h }) (Eq f‚úù f)","decl":"/-- A morphism between coalgebras of an endofunctor `F` -/\n@[ext]\nstructure Hom (V‚ÇÄ V‚ÇÅ : Coalgebra F) where\n  /-- underlying morphism between two carriers -/\n  f : V‚ÇÄ.1 ‚ü∂ V‚ÇÅ.1\n  /-- compatibility condition -/\n  h : V‚ÇÄ.str ‚â´ F.map f = f ‚â´ V‚ÇÅ.str := by aesop_cat\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.Hom.h","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚ÇÄ V‚ÇÅ : CategoryTheory.Endofunctor.Coalgebra F\nself : V‚ÇÄ.Hom V‚ÇÅ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp V‚ÇÄ.str (F.map self.f)) (CategoryTheory.CategoryStruct.comp self.f V‚ÇÅ.str)","decl":"/-- A morphism between coalgebras of an endofunctor `F` -/\n@[ext]\nstructure Hom (V‚ÇÄ V‚ÇÅ : Coalgebra F) where\n  /-- underlying morphism between two carriers -/\n  f : V‚ÇÄ.1 ‚ü∂ V‚ÇÅ.1\n  /-- compatibility condition -/\n  h : V‚ÇÄ.str ‚â´ F.map f = f ‚â´ V‚ÇÅ.str := by aesop_cat\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.Hom.ext_iff","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚ÇÄ V‚ÇÅ : CategoryTheory.Endofunctor.Coalgebra F\nx y : V‚ÇÄ.Hom V‚ÇÅ\n‚ä¢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- A morphism between coalgebras of an endofunctor `F` -/\n@[ext]\nstructure Hom (V‚ÇÄ V‚ÇÅ : Coalgebra F) where\n  /-- underlying morphism between two carriers -/\n  f : V‚ÇÄ.1 ‚ü∂ V‚ÇÅ.1\n  /-- compatibility condition -/\n  h : V‚ÇÄ.str ‚â´ F.map f = f ‚â´ V‚ÇÅ.str := by aesop_cat\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚ÇÄ V‚ÇÅ : CategoryTheory.Endofunctor.Coalgebra F\ninst‚úù : SizeOf C\nf : Quiver.Hom V‚ÇÄ.V V‚ÇÅ.V\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp V‚ÇÄ.str (F.map f)) (CategoryTheory.CategoryStruct.comp f V‚ÇÅ.str)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { f := f, h := h }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f)) (SizeOf.sizeOf h))","decl":"/-- A morphism between coalgebras of an endofunctor `F` -/\n@[ext]\nstructure Hom (V‚ÇÄ V‚ÇÅ : Coalgebra F) where\n  /-- underlying morphism between two carriers -/\n  f : V‚ÇÄ.1 ‚ü∂ V‚ÇÅ.1\n  /-- compatibility condition -/\n  h : V‚ÇÄ.str ‚â´ F.map f = f ‚â´ V‚ÇÅ.str := by aesop_cat\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.Hom.ext","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚ÇÄ V‚ÇÅ : CategoryTheory.Endofunctor.Coalgebra F\nx y : V‚ÇÄ.Hom V‚ÇÅ\nf : Eq x.f y.f\n‚ä¢ Eq x y","decl":"/-- A morphism between coalgebras of an endofunctor `F` -/\n@[ext]\nstructure Hom (V‚ÇÄ V‚ÇÅ : Coalgebra F) where\n  /-- underlying morphism between two carriers -/\n  f : V‚ÇÄ.1 ‚ü∂ V‚ÇÅ.1\n  /-- compatibility condition -/\n  h : V‚ÇÄ.str ‚â´ F.map f = f ‚â´ V‚ÇÅ.str := by aesop_cat\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.Hom.mk.inj","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚ÇÄ V‚ÇÅ : CategoryTheory.Endofunctor.Coalgebra F\nf‚úù : Quiver.Hom V‚ÇÄ.V V‚ÇÅ.V\nh‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp V‚ÇÄ.str (F.map f‚úù)) (CategoryTheory.CategoryStruct.comp f‚úù V‚ÇÅ.str)) _auto‚úù\nf : Quiver.Hom V‚ÇÄ.V V‚ÇÅ.V\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp V‚ÇÄ.str (F.map f)) (CategoryTheory.CategoryStruct.comp f V‚ÇÅ.str)) _auto‚úù\nx‚úù : Eq { f := f‚úù, h := h‚úù } { f := f, h := h }\n‚ä¢ Eq f‚úù f","decl":"/-- A morphism between coalgebras of an endofunctor `F` -/\n@[ext]\nstructure Hom (V‚ÇÄ V‚ÇÅ : Coalgebra F) where\n  /-- underlying morphism between two carriers -/\n  f : V‚ÇÄ.1 ‚ü∂ V‚ÇÅ.1\n  /-- compatibility condition -/\n  h : V‚ÇÄ.str ‚â´ F.map f = f ‚â´ V‚ÇÅ.str := by aesop_cat\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.Hom.h_assoc","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚ÇÄ V‚ÇÅ : CategoryTheory.Endofunctor.Coalgebra F\nself : V‚ÇÄ.Hom V‚ÇÅ\nZ : C\nh : Quiver.Hom (F.obj V‚ÇÅ.V) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp V‚ÇÄ.str (CategoryTheory.CategoryStruct.comp (F.map self.f) h)) (CategoryTheory.CategoryStruct.comp self.f (CategoryTheory.CategoryStruct.comp V‚ÇÅ.str h))","decl":"attribute [reassoc (attr := simp)] Hom.h\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.ext","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA B : CategoryTheory.Endofunctor.Coalgebra F\nf g : Quiver.Hom A B\nw : autoParam (Eq f.f g.f) _auto‚úù\n‚ä¢ Eq f g","decl":"@[ext]\nlemma ext {A B : Coalgebra F} {f g : A ‚ü∂ B} (w : f.f = g.f := by aesop_cat) : f = g :=\n  Hom.ext w\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.ext_iff","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA B : CategoryTheory.Endofunctor.Coalgebra F\nf g : Quiver.Hom A B\n‚ä¢ Iff (Eq f g) (autoParam (Eq f.f g.f) _auto‚úù)","decl":"@[ext]\nlemma ext {A B : Coalgebra F} {f g : A ‚ü∂ B} (w : f.f = g.f := by aesop_cat) : f = g :=\n  Hom.ext w\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.id_eq_id","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV : CategoryTheory.Endofunctor.Coalgebra F\n‚ä¢ Eq (CategoryTheory.Endofunctor.Coalgebra.Hom.id V) (CategoryTheory.CategoryStruct.id V)","decl":"@[simp]\ntheorem id_eq_id : Coalgebra.Hom.id V = ùüô V :=\n  rfl\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.id_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV : CategoryTheory.Endofunctor.Coalgebra F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id V).f (CategoryTheory.CategoryStruct.id V.V)","decl":"@[simp]\ntheorem id_f : (ùüô _ : V ‚ü∂ V).1 = ùüô V.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.comp_eq_comp","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚ÇÄ V‚ÇÅ V‚ÇÇ : CategoryTheory.Endofunctor.Coalgebra F\nf : Quiver.Hom V‚ÇÄ V‚ÇÅ\ng : Quiver.Hom V‚ÇÅ V‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Endofunctor.Coalgebra.Hom.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"@[simp]\ntheorem comp_eq_comp : Coalgebra.Hom.comp f g = f ‚â´ g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.comp_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚ÇÄ V‚ÇÅ V‚ÇÇ : CategoryTheory.Endofunctor.Coalgebra F\nf : Quiver.Hom V‚ÇÄ V‚ÇÅ\ng : Quiver.Hom V‚ÇÅ V‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).f (CategoryTheory.CategoryStruct.comp f.f g.f)","decl":"@[simp]\ntheorem comp_f : (f ‚â´ g).1 = f.1 ‚â´ g.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.isoMk_inv_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚ÇÄ V‚ÇÅ : CategoryTheory.Endofunctor.Coalgebra F\nh : CategoryTheory.Iso V‚ÇÄ.V V‚ÇÅ.V\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp V‚ÇÄ.str (F.map h.hom)) (CategoryTheory.CategoryStruct.comp h.hom V‚ÇÅ.str)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Endofunctor.Coalgebra.isoMk h w).inv.f h.inv","decl":"/-- To construct an isomorphism of coalgebras, it suffices to give an isomorphism of the Vs which\ncommutes with the structure morphisms.\n-/\n@[simps]\ndef isoMk (h : V‚ÇÄ.1 ‚âÖ V‚ÇÅ.1) (w : V‚ÇÄ.str ‚â´ F.map h.hom = h.hom ‚â´ V‚ÇÅ.str := by aesop_cat) :\n    V‚ÇÄ ‚âÖ V‚ÇÅ where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_inv_comp, ‚Üê Category.assoc, ‚Üê w, Category.assoc, ‚Üê F.map_comp]\n        simp only [Iso.hom_inv_id, Functor.map_id, Category.comp_id] }\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.isoMk_hom_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚ÇÄ V‚ÇÅ : CategoryTheory.Endofunctor.Coalgebra F\nh : CategoryTheory.Iso V‚ÇÄ.V V‚ÇÅ.V\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp V‚ÇÄ.str (F.map h.hom)) (CategoryTheory.CategoryStruct.comp h.hom V‚ÇÅ.str)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Endofunctor.Coalgebra.isoMk h w).hom.f h.hom","decl":"/-- To construct an isomorphism of coalgebras, it suffices to give an isomorphism of the Vs which\ncommutes with the structure morphisms.\n-/\n@[simps]\ndef isoMk (h : V‚ÇÄ.1 ‚âÖ V‚ÇÅ.1) (w : V‚ÇÄ.str ‚â´ F.map h.hom = h.hom ‚â´ V‚ÇÅ.str := by aesop_cat) :\n    V‚ÇÄ ‚âÖ V‚ÇÅ where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_inv_comp, ‚Üê Category.assoc, ‚Üê w, Category.assoc, ‚Üê F.map_comp]\n        simp only [Iso.hom_inv_id, Functor.map_id, Category.comp_id] }\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.forget_obj","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA : CategoryTheory.Endofunctor.Coalgebra F\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Coalgebra.forget F).obj A) A.V","decl":"/-- The forgetful functor from the category of coalgebras, forgetting the coalgebraic structure. -/\n@[simps]\ndef forget (F : C ‚•§ C) : Coalgebra F ‚•§ C where\n  obj A := A.1\n  map f := f.1\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.forget_map","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX‚úù Y‚úù : CategoryTheory.Endofunctor.Coalgebra F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Coalgebra.forget F).map f) f.f","decl":"/-- The forgetful functor from the category of coalgebras, forgetting the coalgebraic structure. -/\n@[simps]\ndef forget (F : C ‚•§ C) : Coalgebra F ‚•§ C where\n  obj A := A.1\n  map f := f.1\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.iso_of_iso","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nV‚ÇÄ V‚ÇÅ : CategoryTheory.Endofunctor.Coalgebra F\nf : Quiver.Hom V‚ÇÄ V‚ÇÅ\ninst‚úù : CategoryTheory.IsIso f.f\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- A coalgebra morphism with an underlying isomorphism hom in `C` is a coalgebra isomorphism. -/\ntheorem iso_of_iso (f : V‚ÇÄ ‚ü∂ V‚ÇÅ) [IsIso f.1] : IsIso f :=\n  ‚ü®‚ü®{ f := inv f.1\n      h := by\n        rw [IsIso.eq_inv_comp f.1, ‚Üê Category.assoc, ‚Üê f.h, Category.assoc]\n        simp }, by aesop_cat, by aesop_cat‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.forget_reflects_iso","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\n‚ä¢ (CategoryTheory.Endofunctor.Coalgebra.forget F).ReflectsIsomorphisms","decl":"instance forget_reflects_iso : (forget F).ReflectsIsomorphisms where reflects := iso_of_iso\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.forget_faithful","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\n‚ä¢ (CategoryTheory.Endofunctor.Coalgebra.forget F).Faithful","decl":"instance forget_faithful : (forget F).Faithful := { }\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.epi_of_epi","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX Y : CategoryTheory.Endofunctor.Coalgebra F\nf : Quiver.Hom X Y\nh : CategoryTheory.Epi f.f\n‚ä¢ CategoryTheory.Epi f","decl":"/-- An algebra morphism with an underlying epimorphism hom in `C` is an algebra epimorphism. -/\ntheorem epi_of_epi {X Y : Coalgebra F} (f : X ‚ü∂ Y) [h : Epi f.1] : Epi f :=\n  (forget F).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.mono_of_mono","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX Y : CategoryTheory.Endofunctor.Coalgebra F\nf : Quiver.Hom X Y\nh : CategoryTheory.Mono f.f\n‚ä¢ CategoryTheory.Mono f","decl":"/-- An algebra morphism with an underlying monomorphism hom in `C` is an algebra monomorphism. -/\ntheorem mono_of_mono {X Y : Coalgebra F} (f : X ‚ü∂ Y) [h : Mono f.1] : Mono f :=\n  (forget F).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.functorOfNatTrans_map_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : Quiver.Hom F G\nX‚úù Y‚úù : CategoryTheory.Endofunctor.Coalgebra F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Coalgebra.functorOfNatTrans Œ±).map f).f f.f","decl":"/-- From a natural transformation `Œ± : F ‚Üí G` we get a functor from\ncoalgebras of `F` to coalgebras of `G`.\n-/\n@[simps]\ndef functorOfNatTrans {F G : C ‚•§ C} (Œ± : F ‚ü∂ G) : Coalgebra F ‚•§ Coalgebra G where\n  obj V :=\n    { V := V.1\n      str := V.str ‚â´ Œ±.app V.1 }\n  map f :=\n    { f := f.1\n      h := by rw [Category.assoc, ‚Üê Œ±.naturality, ‚Üê Category.assoc, f.h, Category.assoc] }\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.functorOfNatTrans_obj_str","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : Quiver.Hom F G\nV : CategoryTheory.Endofunctor.Coalgebra F\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Coalgebra.functorOfNatTrans Œ±).obj V).str (CategoryTheory.CategoryStruct.comp V.str (Œ±.app V.V))","decl":"/-- From a natural transformation `Œ± : F ‚Üí G` we get a functor from\ncoalgebras of `F` to coalgebras of `G`.\n-/\n@[simps]\ndef functorOfNatTrans {F G : C ‚•§ C} (Œ± : F ‚ü∂ G) : Coalgebra F ‚•§ Coalgebra G where\n  obj V :=\n    { V := V.1\n      str := V.str ‚â´ Œ±.app V.1 }\n  map f :=\n    { f := f.1\n      h := by rw [Category.assoc, ‚Üê Œ±.naturality, ‚Üê Category.assoc, f.h, Category.assoc] }\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.functorOfNatTrans_obj_V","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : Quiver.Hom F G\nV : CategoryTheory.Endofunctor.Coalgebra F\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Coalgebra.functorOfNatTrans Œ±).obj V).V V.V","decl":"/-- From a natural transformation `Œ± : F ‚Üí G` we get a functor from\ncoalgebras of `F` to coalgebras of `G`.\n-/\n@[simps]\ndef functorOfNatTrans {F G : C ‚•§ C} (Œ± : F ‚ü∂ G) : Coalgebra F ‚•§ Coalgebra G where\n  obj V :=\n    { V := V.1\n      str := V.str ‚â´ Œ±.app V.1 }\n  map f :=\n    { f := f.1\n      h := by rw [Category.assoc, ‚Üê Œ±.naturality, ‚Üê Category.assoc, f.h, Category.assoc] }\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransId_inv_app_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX : CategoryTheory.Endofunctor.Coalgebra F\n‚ä¢ Eq (CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransId.inv.app X).f (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- The identity transformation induces the identity endofunctor on the category of coalgebras. -/\n@[simps!]\ndef functorOfNatTransId : functorOfNatTrans (ùüô F) ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransId_hom_app_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nX : CategoryTheory.Endofunctor.Coalgebra F\n‚ä¢ Eq (CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransId.hom.app X).f (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- The identity transformation induces the identity endofunctor on the category of coalgebras. -/\n@[simps!]\ndef functorOfNatTransId : functorOfNatTrans (ùüô F) ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransComp_hom_app_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÄ F‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C C\nŒ± : Quiver.Hom F‚ÇÄ F‚ÇÅ\nŒ≤ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nX : CategoryTheory.Endofunctor.Coalgebra F‚ÇÄ\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransComp Œ± Œ≤).hom.app X).f (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- A composition of natural transformations gives the composition of corresponding functors. -/\n@[simps!]\ndef functorOfNatTransComp {F‚ÇÄ F‚ÇÅ F‚ÇÇ : C ‚•§ C} (Œ± : F‚ÇÄ ‚ü∂ F‚ÇÅ) (Œ≤ : F‚ÇÅ ‚ü∂ F‚ÇÇ) :\n    functorOfNatTrans (Œ± ‚â´ Œ≤) ‚âÖ functorOfNatTrans Œ± ‚ãô functorOfNatTrans Œ≤ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransComp_inv_app_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÄ F‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C C\nŒ± : Quiver.Hom F‚ÇÄ F‚ÇÅ\nŒ≤ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nX : CategoryTheory.Endofunctor.Coalgebra F‚ÇÄ\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransComp Œ± Œ≤).inv.app X).f (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- A composition of natural transformations gives the composition of corresponding functors. -/\n@[simps!]\ndef functorOfNatTransComp {F‚ÇÄ F‚ÇÅ F‚ÇÇ : C ‚•§ C} (Œ± : F‚ÇÄ ‚ü∂ F‚ÇÅ) (Œ≤ : F‚ÇÅ ‚ü∂ F‚ÇÇ) :\n    functorOfNatTrans (Œ± ‚â´ Œ≤) ‚âÖ functorOfNatTrans Œ± ‚ãô functorOfNatTrans Œ≤ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransEq_hom_app_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± Œ≤ : Quiver.Hom F G\nh : Eq Œ± Œ≤\nX : CategoryTheory.Endofunctor.Coalgebra F\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransEq h).hom.app X).f (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- If `Œ±` and `Œ≤` are two equal natural transformations, then the functors of coalgebras induced by\nthem are isomorphic.\nWe define it like this as opposed to using `eq_to_iso` so that the components are nicer to prove\nlemmas about.\n-/\n@[simps!]\ndef functorOfNatTransEq {F G : C ‚•§ C} {Œ± Œ≤ : F ‚ü∂ G} (h : Œ± = Œ≤) :\n    functorOfNatTrans Œ± ‚âÖ functorOfNatTrans Œ≤ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransEq_inv_app_f","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± Œ≤ : Quiver.Hom F G\nh : Eq Œ± Œ≤\nX : CategoryTheory.Endofunctor.Coalgebra F\n‚ä¢ Eq ((CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransEq h).inv.app X).f (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- If `Œ±` and `Œ≤` are two equal natural transformations, then the functors of coalgebras induced by\nthem are isomorphic.\nWe define it like this as opposed to using `eq_to_iso` so that the components are nicer to prove\nlemmas about.\n-/\n@[simps!]\ndef functorOfNatTransEq {F G : C ‚•§ C} {Œ± Œ≤ : F ‚ü∂ G} (h : Œ± = Œ≤) :\n    functorOfNatTrans Œ± ‚âÖ functorOfNatTrans Œ≤ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.equivOfNatIso_unitIso","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.Endofunctor.Coalgebra.equivOfNatIso Œ±).unitIso (CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransId.symm.trans ((CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransEq ‚ãØ).trans (CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransComp Œ±.hom Œ±.inv)))","decl":"/-- Naturally isomorphic endofunctors give equivalent categories of coalgebras.\nFurthermore, they are equivalent as categories over `C`, that is,\nwe have `equiv_of_nat_iso h ‚ãô forget = forget`.\n-/\n@[simps]\ndef equivOfNatIso {F G : C ‚•§ C} (Œ± : F ‚âÖ G) : Coalgebra F ‚âå Coalgebra G where\n  functor := functorOfNatTrans Œ±.hom\n  inverse := functorOfNatTrans Œ±.inv\n  unitIso := functorOfNatTransId.symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransComp _ _\n  counitIso :=\n    (functorOfNatTransComp _ _).symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransId\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.equivOfNatIso_inverse","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.Endofunctor.Coalgebra.equivOfNatIso Œ±).inverse (CategoryTheory.Endofunctor.Coalgebra.functorOfNatTrans Œ±.inv)","decl":"/-- Naturally isomorphic endofunctors give equivalent categories of coalgebras.\nFurthermore, they are equivalent as categories over `C`, that is,\nwe have `equiv_of_nat_iso h ‚ãô forget = forget`.\n-/\n@[simps]\ndef equivOfNatIso {F G : C ‚•§ C} (Œ± : F ‚âÖ G) : Coalgebra F ‚âå Coalgebra G where\n  functor := functorOfNatTrans Œ±.hom\n  inverse := functorOfNatTrans Œ±.inv\n  unitIso := functorOfNatTransId.symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransComp _ _\n  counitIso :=\n    (functorOfNatTransComp _ _).symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransId\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.equivOfNatIso_functor","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.Endofunctor.Coalgebra.equivOfNatIso Œ±).functor (CategoryTheory.Endofunctor.Coalgebra.functorOfNatTrans Œ±.hom)","decl":"/-- Naturally isomorphic endofunctors give equivalent categories of coalgebras.\nFurthermore, they are equivalent as categories over `C`, that is,\nwe have `equiv_of_nat_iso h ‚ãô forget = forget`.\n-/\n@[simps]\ndef equivOfNatIso {F G : C ‚•§ C} (Œ± : F ‚âÖ G) : Coalgebra F ‚âå Coalgebra G where\n  functor := functorOfNatTrans Œ±.hom\n  inverse := functorOfNatTrans Œ±.inv\n  unitIso := functorOfNatTransId.symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransComp _ _\n  counitIso :=\n    (functorOfNatTransComp _ _).symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransId\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.equivOfNatIso_counitIso","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nŒ± : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.Endofunctor.Coalgebra.equivOfNatIso Œ±).counitIso ((CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransComp Œ±.inv Œ±.hom).symm.trans ((CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransEq ‚ãØ).trans CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransId))","decl":"/-- Naturally isomorphic endofunctors give equivalent categories of coalgebras.\nFurthermore, they are equivalent as categories over `C`, that is,\nwe have `equiv_of_nat_iso h ‚ãô forget = forget`.\n-/\n@[simps]\ndef equivOfNatIso {F G : C ‚•§ C} (Œ± : F ‚âÖ G) : Coalgebra F ‚âå Coalgebra G where\n  functor := functorOfNatTrans Œ±.hom\n  inverse := functorOfNatTrans Œ±.inv\n  unitIso := functorOfNatTransId.symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransComp _ _\n  counitIso :=\n    (functorOfNatTransComp _ _).symm ‚â™‚â´ functorOfNatTransEq (by simp) ‚â™‚â´ functorOfNatTransId\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.Terminal.right_inv'","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA : CategoryTheory.Endofunctor.Coalgebra F\nh : CategoryTheory.Limits.IsTerminal A\n‚ä¢ Eq { f := CategoryTheory.CategoryStruct.comp A.str (CategoryTheory.Endofunctor.Coalgebra.Terminal.strInv h), h := ‚ãØ } (CategoryTheory.CategoryStruct.id A)","decl":"theorem right_inv' :\n    ‚ü®A.str ‚â´ strInv h, by rw [Category.assoc, F.map_comp, strInv, ‚Üê Hom.h] ‚ü© = ùüô A :=\n  Limits.IsTerminal.hom_ext h _ (ùüô A)\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.Terminal.right_inv","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA : CategoryTheory.Endofunctor.Coalgebra F\nh : CategoryTheory.Limits.IsTerminal A\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.str (CategoryTheory.Endofunctor.Coalgebra.Terminal.strInv h)) (CategoryTheory.CategoryStruct.id A.V)","decl":"theorem right_inv : A.str ‚â´ strInv h = ùüô _ :=\n  congr_arg Hom.f (right_inv' h)\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.Terminal.left_inv","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA : CategoryTheory.Endofunctor.Coalgebra F\nh : CategoryTheory.Limits.IsTerminal A\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Endofunctor.Coalgebra.Terminal.strInv h) A.str) (CategoryTheory.CategoryStruct.id (F.obj A.V))","decl":"theorem left_inv : strInv h ‚â´ A.str = ùüô _ := by\n  rw [strInv, ‚Üê (h.from ‚ü®F.obj A.V, F.map A.str‚ü©).h, ‚Üê F.map_id, ‚Üê F.map_comp]\n  congr\n  exact right_inv h\n\n"}
{"name":"CategoryTheory.Endofunctor.Coalgebra.Terminal.str_isIso","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C C\nA : CategoryTheory.Endofunctor.Coalgebra F\nh : CategoryTheory.Limits.IsTerminal A\n‚ä¢ CategoryTheory.IsIso A.str","decl":"/-- The structure map of the terminal coalgebra is an isomorphism,\nhence endofunctors preserve their terminal coalgebras\n-/\ntheorem str_isIso (h : Limits.IsTerminal A) : IsIso A.str :=\n  { out := ‚ü®strInv h, right_inv _, left_inv _‚ü©  }\n\n"}
{"name":"CategoryTheory.Endofunctor.Adjunction.Algebra.homEquiv_naturality_str","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nadj : CategoryTheory.Adjunction F G\nA‚ÇÅ A‚ÇÇ : CategoryTheory.Endofunctor.Algebra F\nf : Quiver.Hom A‚ÇÅ A‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((adj.homEquiv A‚ÇÅ.a A‚ÇÅ.a) A‚ÇÅ.str) (G.map f.f)) (CategoryTheory.CategoryStruct.comp f.f ((adj.homEquiv A‚ÇÇ.a A‚ÇÇ.a) A‚ÇÇ.str))","decl":"theorem Algebra.homEquiv_naturality_str (adj : F ‚ä£ G) (A‚ÇÅ A‚ÇÇ : Algebra F) (f : A‚ÇÅ ‚ü∂ A‚ÇÇ) :\n    (adj.homEquiv A‚ÇÅ.a A‚ÇÅ.a) A‚ÇÅ.str ‚â´ G.map f.f = f.f ‚â´ (adj.homEquiv A‚ÇÇ.a A‚ÇÇ.a) A‚ÇÇ.str := by\n  rw [‚Üê Adjunction.homEquiv_naturality_right, ‚Üê Adjunction.homEquiv_naturality_left, f.h]\n\n"}
{"name":"CategoryTheory.Endofunctor.Adjunction.Coalgebra.homEquiv_naturality_str_symm","module":"Mathlib.CategoryTheory.Endofunctor.Algebra","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C C\nadj : CategoryTheory.Adjunction F G\nV‚ÇÅ V‚ÇÇ : CategoryTheory.Endofunctor.Coalgebra G\nf : Quiver.Hom V‚ÇÅ V‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f.f) ((adj.homEquiv V‚ÇÇ.V V‚ÇÇ.V).symm V‚ÇÇ.str)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv V‚ÇÅ.V V‚ÇÅ.V).symm V‚ÇÅ.str) f.f)","decl":"theorem Coalgebra.homEquiv_naturality_str_symm (adj : F ‚ä£ G) (V‚ÇÅ V‚ÇÇ : Coalgebra G) (f : V‚ÇÅ ‚ü∂ V‚ÇÇ) :\n    F.map f.f ‚â´ (adj.homEquiv V‚ÇÇ.V V‚ÇÇ.V).symm V‚ÇÇ.str =\n    (adj.homEquiv V‚ÇÅ.V V‚ÇÅ.V).symm V‚ÇÅ.str ‚â´ f.f := by\n  rw [‚Üê Adjunction.homEquiv_naturality_left_symm, ‚Üê Adjunction.homEquiv_naturality_right_symm,\n    f.h]\n\n"}
