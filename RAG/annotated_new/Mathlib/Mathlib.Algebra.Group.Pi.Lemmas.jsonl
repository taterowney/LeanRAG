{"name":"Set.range_zero","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Zero β\ninst✝ : Nonempty α\n⊢ Eq (Set.range 0) (Singleton.singleton 0)","decl":"@[to_additive (attr := simp)]\ntheorem Set.range_one {α β : Type*} [One β] [Nonempty α] : Set.range (1 : α → β) = {1} :=\n  range_const\n\n"}
{"name":"Set.range_one","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : One β\ninst✝ : Nonempty α\n⊢ Eq (Set.range 1) (Singleton.singleton 1)","decl":"@[to_additive (attr := simp)]\ntheorem Set.range_one {α β : Type*} [One β] [Nonempty α] : Set.range (1 : α → β) = {1} :=\n  range_const\n\n"}
{"name":"Set.preimage_one","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : One β\ns : Set β\ninst✝ : Decidable (Membership.mem s 1)\n⊢ Eq (Set.preimage 1 s) (ite (Membership.mem s 1) Set.univ EmptyCollection.emptyCollection)","decl":"@[to_additive]\ntheorem Set.preimage_one {α β : Type*} [One β] (s : Set β) [Decidable ((1 : β) ∈ s)] :\n    (1 : α → β) ⁻¹' s = if (1 : β) ∈ s then Set.univ else ∅ :=\n  Set.preimage_const 1 s\n\n"}
{"name":"Set.preimage_zero","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Zero β\ns : Set β\ninst✝ : Decidable (Membership.mem s 0)\n⊢ Eq (Set.preimage 0 s) (ite (Membership.mem s 0) Set.univ EmptyCollection.emptyCollection)","decl":"@[to_additive]\ntheorem Set.preimage_one {α β : Type*} [One β] (s : Set β) [Decidable ((1 : β) ∈ s)] :\n    (1 : α → β) ⁻¹' s = if (1 : β) ∈ s then Set.univ else ∅ :=\n  Set.preimage_const 1 s\n\n"}
{"name":"Pi.zero_mono","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Zero β\n⊢ Monotone 0","decl":"@[to_additive] lemma one_mono [One β] : Monotone (1 : α → β) := monotone_const\n"}
{"name":"Pi.one_mono","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : One β\n⊢ Monotone 1","decl":"@[to_additive] lemma one_mono [One β] : Monotone (1 : α → β) := monotone_const\n"}
{"name":"Pi.one_anti","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : One β\n⊢ Antitone 1","decl":"@[to_additive] lemma one_anti [One β] : Antitone (1 : α → β) := antitone_const\n\n"}
{"name":"Pi.zero_anti","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Zero β\n⊢ Antitone 0","decl":"@[to_additive] lemma one_anti [One β] : Antitone (1 : α → β) := antitone_const\n\n"}
{"name":"MulHom.coe_mul","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"M : Type u_3\nN : Type u_4\nx✝¹ : Mul M\nx✝ : CommSemigroup N\nf g : MulHom M N\n⊢ Eq (HMul.hMul ⇑f ⇑g) fun x => HMul.hMul (f x) (g x)","decl":"@[to_additive]\ntheorem coe_mul {M N} {_ : Mul M} {_ : CommSemigroup N} (f g : M →ₙ* N) : (f * g : M → N) =\n    fun x => f x * g x := rfl\n\n"}
{"name":"AddHom.coe_add","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"M : Type u_3\nN : Type u_4\nx✝¹ : Add M\nx✝ : AddCommSemigroup N\nf g : AddHom M N\n⊢ Eq (HAdd.hAdd ⇑f ⇑g) fun x => HAdd.hAdd (f x) (g x)","decl":"@[to_additive]\ntheorem coe_mul {M N} {_ : Mul M} {_ : CommSemigroup N} (f g : M →ₙ* N) : (f * g : M → N) =\n    fun x => f x * g x := rfl\n\n"}
{"name":"Pi.mulHom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\nγ : Type w\ninst✝¹ : (i : I) → Mul (f i)\ninst✝ : Mul γ\ng : (i : I) → MulHom γ (f i)\nx : γ\ni : I\n⊢ Eq ((Pi.mulHom g) x i) ((g i) x)","decl":"/-- A family of MulHom's `f a : γ →ₙ* β a` defines a MulHom `Pi.mulHom f : γ →ₙ* Π a, β a`\ngiven by `Pi.mulHom f x b = f b x`. -/\n@[to_additive (attr := simps)\n  \"A family of AddHom's `f a : γ → β a` defines an AddHom `Pi.addHom f : γ → Π a, β a` given by\n  `Pi.addHom f x b = f b x`.\"]\ndef Pi.mulHom {γ : Type w} [∀ i, Mul (f i)] [Mul γ] (g : ∀ i, γ →ₙ* f i) : γ →ₙ* ∀ i, f i where\n  toFun x i := g i x\n  map_mul' x y := funext fun i => (g i).map_mul x y\n\n"}
{"name":"Pi.addHom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\nγ : Type w\ninst✝¹ : (i : I) → Add (f i)\ninst✝ : Add γ\ng : (i : I) → AddHom γ (f i)\nx : γ\ni : I\n⊢ Eq ((Pi.addHom g) x i) ((g i) x)","decl":"/-- A family of MulHom's `f a : γ →ₙ* β a` defines a MulHom `Pi.mulHom f : γ →ₙ* Π a, β a`\ngiven by `Pi.mulHom f x b = f b x`. -/\n@[to_additive (attr := simps)\n  \"A family of AddHom's `f a : γ → β a` defines an AddHom `Pi.addHom f : γ → Π a, β a` given by\n  `Pi.addHom f x b = f b x`.\"]\ndef Pi.mulHom {γ : Type w} [∀ i, Mul (f i)] [Mul γ] (g : ∀ i, γ →ₙ* f i) : γ →ₙ* ∀ i, f i where\n  toFun x i := g i x\n  map_mul' x y := funext fun i => (g i).map_mul x y\n\n"}
{"name":"Pi.addHom_injective","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\nγ : Type w\ninst✝² : Nonempty I\ninst✝¹ : (i : I) → Add (f i)\ninst✝ : Add γ\ng : (i : I) → AddHom γ (f i)\nhg : ∀ (i : I), Function.Injective ⇑(g i)\n⊢ Function.Injective ⇑(Pi.addHom g)","decl":"@[to_additive]\ntheorem Pi.mulHom_injective {γ : Type w} [Nonempty I] [∀ i, Mul (f i)] [Mul γ] (g : ∀ i, γ →ₙ* f i)\n    (hg : ∀ i, Function.Injective (g i)) : Function.Injective (Pi.mulHom g) := fun _ _ h =>\n  let ⟨i⟩ := ‹Nonempty I›\n  hg i ((funext_iff.mp h :) i)\n\n"}
{"name":"Pi.mulHom_injective","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\nγ : Type w\ninst✝² : Nonempty I\ninst✝¹ : (i : I) → Mul (f i)\ninst✝ : Mul γ\ng : (i : I) → MulHom γ (f i)\nhg : ∀ (i : I), Function.Injective ⇑(g i)\n⊢ Function.Injective ⇑(Pi.mulHom g)","decl":"@[to_additive]\ntheorem Pi.mulHom_injective {γ : Type w} [Nonempty I] [∀ i, Mul (f i)] [Mul γ] (g : ∀ i, γ →ₙ* f i)\n    (hg : ∀ i, Function.Injective (g i)) : Function.Injective (Pi.mulHom g) := fun _ _ h =>\n  let ⟨i⟩ := ‹Nonempty I›\n  hg i ((funext_iff.mp h :) i)\n\n"}
{"name":"Pi.addMonoidHom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\nγ : Type w\ninst✝¹ : (i : I) → AddZeroClass (f i)\ninst✝ : AddZeroClass γ\ng : (i : I) → AddMonoidHom γ (f i)\nx : γ\ni : I\n⊢ Eq ((Pi.addMonoidHom g) x i) ((g i) x)","decl":"/-- A family of monoid homomorphisms `f a : γ →* β a` defines a monoid homomorphism\n`Pi.monoidHom f : γ →* Π a, β a` given by `Pi.monoidHom f x b = f b x`. -/\n@[to_additive (attr := simps)\n  \"A family of additive monoid homomorphisms `f a : γ →+ β a` defines a monoid homomorphism\n  `Pi.addMonoidHom f : γ →+ Π a, β a` given by `Pi.addMonoidHom f x b = f b x`.\"]\ndef Pi.monoidHom {γ : Type w} [∀ i, MulOneClass (f i)] [MulOneClass γ] (g : ∀ i, γ →* f i) :\n    γ →* ∀ i, f i :=\n  { Pi.mulHom fun i => (g i).toMulHom with\n    toFun := fun x i => g i x\n    map_one' := funext fun i => (g i).map_one }\n\n"}
{"name":"Pi.monoidHom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\nγ : Type w\ninst✝¹ : (i : I) → MulOneClass (f i)\ninst✝ : MulOneClass γ\ng : (i : I) → MonoidHom γ (f i)\nx : γ\ni : I\n⊢ Eq ((Pi.monoidHom g) x i) ((g i) x)","decl":"/-- A family of monoid homomorphisms `f a : γ →* β a` defines a monoid homomorphism\n`Pi.monoidHom f : γ →* Π a, β a` given by `Pi.monoidHom f x b = f b x`. -/\n@[to_additive (attr := simps)\n  \"A family of additive monoid homomorphisms `f a : γ →+ β a` defines a monoid homomorphism\n  `Pi.addMonoidHom f : γ →+ Π a, β a` given by `Pi.addMonoidHom f x b = f b x`.\"]\ndef Pi.monoidHom {γ : Type w} [∀ i, MulOneClass (f i)] [MulOneClass γ] (g : ∀ i, γ →* f i) :\n    γ →* ∀ i, f i :=\n  { Pi.mulHom fun i => (g i).toMulHom with\n    toFun := fun x i => g i x\n    map_one' := funext fun i => (g i).map_one }\n\n"}
{"name":"Pi.monoidHom_injective","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\nγ : Type w\ninst✝² : Nonempty I\ninst✝¹ : (i : I) → MulOneClass (f i)\ninst✝ : MulOneClass γ\ng : (i : I) → MonoidHom γ (f i)\nhg : ∀ (i : I), Function.Injective ⇑(g i)\n⊢ Function.Injective ⇑(Pi.monoidHom g)","decl":"@[to_additive]\ntheorem Pi.monoidHom_injective {γ : Type w} [Nonempty I] [∀ i, MulOneClass (f i)] [MulOneClass γ]\n    (g : ∀ i, γ →* f i) (hg : ∀ i, Function.Injective (g i)) :\n    Function.Injective (Pi.monoidHom g) :=\n  Pi.mulHom_injective (fun i => (g i).toMulHom) hg\n\n"}
{"name":"Pi.addMonoidHom_injective","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\nγ : Type w\ninst✝² : Nonempty I\ninst✝¹ : (i : I) → AddZeroClass (f i)\ninst✝ : AddZeroClass γ\ng : (i : I) → AddMonoidHom γ (f i)\nhg : ∀ (i : I), Function.Injective ⇑(g i)\n⊢ Function.Injective ⇑(Pi.addMonoidHom g)","decl":"@[to_additive]\ntheorem Pi.monoidHom_injective {γ : Type w} [Nonempty I] [∀ i, MulOneClass (f i)] [MulOneClass γ]\n    (g : ∀ i, γ →* f i) (hg : ∀ i, Function.Injective (g i)) :\n    Function.Injective (Pi.monoidHom g) :=\n  Pi.mulHom_injective (fun i => (g i).toMulHom) hg\n\n"}
{"name":"Pi.evalAddHom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → Add (f i)\ni : I\ng : (i : I) → f i\n⊢ Eq ((Pi.evalAddHom f i) g) (g i)","decl":"/-- Evaluation of functions into an indexed collection of semigroups at a point is a semigroup\nhomomorphism.\nThis is `Function.eval i` as a `MulHom`. -/\n@[to_additive (attr := simps)\n  \"Evaluation of functions into an indexed collection of additive semigroups at a point is an\n  additive semigroup homomorphism. This is `Function.eval i` as an `AddHom`.\"]\ndef Pi.evalMulHom (i : I) : (∀ i, f i) →ₙ* f i where\n  toFun g := g i\n  map_mul' _ _ := Pi.mul_apply _ _ i\n\n"}
{"name":"Pi.evalMulHom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → Mul (f i)\ni : I\ng : (i : I) → f i\n⊢ Eq ((Pi.evalMulHom f i) g) (g i)","decl":"/-- Evaluation of functions into an indexed collection of semigroups at a point is a semigroup\nhomomorphism.\nThis is `Function.eval i` as a `MulHom`. -/\n@[to_additive (attr := simps)\n  \"Evaluation of functions into an indexed collection of additive semigroups at a point is an\n  additive semigroup homomorphism. This is `Function.eval i` as an `AddHom`.\"]\ndef Pi.evalMulHom (i : I) : (∀ i, f i) →ₙ* f i where\n  toFun g := g i\n  map_mul' _ _ := Pi.mul_apply _ _ i\n\n"}
{"name":"Pi.constAddHom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Add β\na : β\na✝ : α\n⊢ Eq ((Pi.constAddHom α β) a a✝) (Function.const α a a✝)","decl":"/-- `Function.const` as a `MulHom`. -/\n@[to_additive (attr := simps) \"`Function.const` as an `AddHom`.\"]\ndef Pi.constMulHom (α β : Type*) [Mul β] :\n    β →ₙ* α → β where\n  toFun := Function.const α\n  map_mul' _ _ := rfl\n\n"}
{"name":"Pi.constMulHom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Mul β\na : β\na✝ : α\n⊢ Eq ((Pi.constMulHom α β) a a✝) (Function.const α a a✝)","decl":"/-- `Function.const` as a `MulHom`. -/\n@[to_additive (attr := simps) \"`Function.const` as an `AddHom`.\"]\ndef Pi.constMulHom (α β : Type*) [Mul β] :\n    β →ₙ* α → β where\n  toFun := Function.const α\n  map_mul' _ _ := rfl\n\n"}
{"name":"MulHom.coeFn_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Mul α\ninst✝ : CommSemigroup β\ng : MulHom α β\na : α\n⊢ Eq ((MulHom.coeFn α β) g a) (g a)","decl":"/-- Coercion of a `MulHom` into a function is itself a `MulHom`.\n\nSee also `MulHom.eval`. -/\n@[to_additive (attr := simps) \"Coercion of an `AddHom` into a function is itself an `AddHom`.\n\nSee also `AddHom.eval`.\"]\ndef MulHom.coeFn (α β : Type*) [Mul α] [CommSemigroup β] :\n    (α →ₙ* β) →ₙ* α → β where\n  toFun g := g\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddHom.coeFn_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Add α\ninst✝ : AddCommSemigroup β\ng : AddHom α β\na : α\n⊢ Eq ((AddHom.coeFn α β) g a) (g a)","decl":"/-- Coercion of a `MulHom` into a function is itself a `MulHom`.\n\nSee also `MulHom.eval`. -/\n@[to_additive (attr := simps) \"Coercion of an `AddHom` into a function is itself an `AddHom`.\n\nSee also `AddHom.eval`.\"]\ndef MulHom.coeFn (α β : Type*) [Mul α] [CommSemigroup β] :\n    (α →ₙ* β) →ₙ* α → β where\n  toFun g := g\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddHom.compLeft_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Add α\ninst✝ : Add β\nf : AddHom α β\nI : Type u_5\nh : I → α\na✝ : I\n⊢ Eq ((f.compLeft I) h a✝) (Function.comp (⇑f) h a✝)","decl":"/-- Semigroup homomorphism between the function spaces `I → α` and `I → β`, induced by a semigroup\nhomomorphism `f` between `α` and `β`. -/\n@[to_additive (attr := simps) \"Additive semigroup homomorphism between the function spaces `I → α`\nand `I → β`, induced by an additive semigroup homomorphism `f` between `α` and `β`\"]\nprotected def MulHom.compLeft {α β : Type*} [Mul α] [Mul β] (f : α →ₙ* β) (I : Type*) :\n    (I → α) →ₙ* I → β where\n  toFun h := f ∘ h\n  map_mul' _ _ := by ext; simp\n\n"}
{"name":"MulHom.compLeft_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : MulHom α β\nI : Type u_5\nh : I → α\na✝ : I\n⊢ Eq ((f.compLeft I) h a✝) (Function.comp (⇑f) h a✝)","decl":"/-- Semigroup homomorphism between the function spaces `I → α` and `I → β`, induced by a semigroup\nhomomorphism `f` between `α` and `β`. -/\n@[to_additive (attr := simps) \"Additive semigroup homomorphism between the function spaces `I → α`\nand `I → β`, induced by an additive semigroup homomorphism `f` between `α` and `β`\"]\nprotected def MulHom.compLeft {α β : Type*} [Mul α] [Mul β] (f : α →ₙ* β) (I : Type*) :\n    (I → α) →ₙ* I → β where\n  toFun h := f ∘ h\n  map_mul' _ _ := by ext; simp\n\n"}
{"name":"Pi.evalAddMonoidHom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → AddZeroClass (f i)\ni : I\ng : (i : I) → f i\n⊢ Eq ((Pi.evalAddMonoidHom f i) g) (g i)","decl":"/-- Evaluation of functions into an indexed collection of monoids at a point is a monoid\nhomomorphism.\nThis is `Function.eval i` as a `MonoidHom`. -/\n@[to_additive (attr := simps) \"Evaluation of functions into an indexed collection of additive\nmonoids at a point is an additive monoid homomorphism. This is `Function.eval i` as an\n`AddMonoidHom`.\"]\ndef Pi.evalMonoidHom (i : I) : (∀ i, f i) →* f i where\n  toFun g := g i\n  map_one' := Pi.one_apply i\n  map_mul' _ _ := Pi.mul_apply _ _ i\n\n"}
{"name":"Pi.evalMonoidHom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → MulOneClass (f i)\ni : I\ng : (i : I) → f i\n⊢ Eq ((Pi.evalMonoidHom f i) g) (g i)","decl":"/-- Evaluation of functions into an indexed collection of monoids at a point is a monoid\nhomomorphism.\nThis is `Function.eval i` as a `MonoidHom`. -/\n@[to_additive (attr := simps) \"Evaluation of functions into an indexed collection of additive\nmonoids at a point is an additive monoid homomorphism. This is `Function.eval i` as an\n`AddMonoidHom`.\"]\ndef Pi.evalMonoidHom (i : I) : (∀ i, f i) →* f i where\n  toFun g := g i\n  map_one' := Pi.one_apply i\n  map_mul' _ _ := Pi.mul_apply _ _ i\n\n"}
{"name":"Pi.constAddMonoidHom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddZeroClass β\na : β\na✝ : α\n⊢ Eq ((Pi.constAddMonoidHom α β) a a✝) (Function.const α a a✝)","decl":"/-- `Function.const` as a `MonoidHom`. -/\n@[to_additive (attr := simps) \"`Function.const` as an `AddMonoidHom`.\"]\ndef Pi.constMonoidHom (α β : Type*) [MulOneClass β] : β →* α → β where\n  toFun := Function.const α\n  map_one' := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"Pi.constMonoidHom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : MulOneClass β\na : β\na✝ : α\n⊢ Eq ((Pi.constMonoidHom α β) a a✝) (Function.const α a a✝)","decl":"/-- `Function.const` as a `MonoidHom`. -/\n@[to_additive (attr := simps) \"`Function.const` as an `AddMonoidHom`.\"]\ndef Pi.constMonoidHom (α β : Type*) [MulOneClass β] : β →* α → β where\n  toFun := Function.const α\n  map_one' := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"MonoidHom.coeFn_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : MulOneClass α\ninst✝ : CommMonoid β\ng : MonoidHom α β\na : α\n⊢ Eq ((MonoidHom.coeFn α β) g a) (g a)","decl":"/-- Coercion of a `MonoidHom` into a function is itself a `MonoidHom`.\n\nSee also `MonoidHom.eval`. -/\n@[to_additive (attr := simps) \"Coercion of an `AddMonoidHom` into a function is itself\nan `AddMonoidHom`.\n\nSee also `AddMonoidHom.eval`.\"]\ndef MonoidHom.coeFn (α β : Type*) [MulOneClass α] [CommMonoid β] : (α →* β) →* α → β where\n  toFun g := g\n  map_one' := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddMonoidHom.coeFn_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddZeroClass α\ninst✝ : AddCommMonoid β\ng : AddMonoidHom α β\na : α\n⊢ Eq ((AddMonoidHom.coeFn α β) g a) (g a)","decl":"/-- Coercion of a `MonoidHom` into a function is itself a `MonoidHom`.\n\nSee also `MonoidHom.eval`. -/\n@[to_additive (attr := simps) \"Coercion of an `AddMonoidHom` into a function is itself\nan `AddMonoidHom`.\n\nSee also `AddMonoidHom.eval`.\"]\ndef MonoidHom.coeFn (α β : Type*) [MulOneClass α] [CommMonoid β] : (α →* β) →* α → β where\n  toFun g := g\n  map_one' := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddMonoidHom.compLeft_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf : AddMonoidHom α β\nI : Type u_5\nh : I → α\na✝ : I\n⊢ Eq ((f.compLeft I) h a✝) (Function.comp (⇑f) h a✝)","decl":"/-- Monoid homomorphism between the function spaces `I → α` and `I → β`, induced by a monoid\nhomomorphism `f` between `α` and `β`. -/\n@[to_additive (attr := simps)\n  \"Additive monoid homomorphism between the function spaces `I → α` and `I → β`, induced by an\n  additive monoid homomorphism `f` between `α` and `β`\"]\nprotected def MonoidHom.compLeft {α β : Type*} [MulOneClass α] [MulOneClass β] (f : α →* β)\n    (I : Type*) : (I → α) →* I → β where\n  toFun h := f ∘ h\n  map_one' := by ext; dsimp; simp\n  map_mul' _ _ := by ext; simp\n\n"}
{"name":"MonoidHom.compLeft_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf : MonoidHom α β\nI : Type u_5\nh : I → α\na✝ : I\n⊢ Eq ((f.compLeft I) h a✝) (Function.comp (⇑f) h a✝)","decl":"/-- Monoid homomorphism between the function spaces `I → α` and `I → β`, induced by a monoid\nhomomorphism `f` between `α` and `β`. -/\n@[to_additive (attr := simps)\n  \"Additive monoid homomorphism between the function spaces `I → α` and `I → β`, induced by an\n  additive monoid homomorphism `f` between `α` and `β`\"]\nprotected def MonoidHom.compLeft {α β : Type*} [MulOneClass α] [MulOneClass β] (f : α →* β)\n    (I : Type*) : (I → α) →* I → β where\n  toFun h := f ∘ h\n  map_one' := by ext; dsimp; simp\n  map_mul' _ _ := by ext; simp\n\n"}
{"name":"OneHom.mulSingle_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → One (f i)\ni : I\nx : f i\n⊢ Eq ((OneHom.mulSingle f i) x) (Pi.mulSingle i x)","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.mulSingle_apply [∀ i, One <| f i] (i : I) (x : f i) :\n    mulSingle f i x = Pi.mulSingle i x := rfl\n\n"}
{"name":"ZeroHom.single_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → Zero (f i)\ni : I\nx : f i\n⊢ Eq ((ZeroHom.single f i) x) (Pi.single i x)","decl":"@[to_additive (attr := simp)]\ntheorem OneHom.mulSingle_apply [∀ i, One <| f i] (i : I) (x : f i) :\n    mulSingle f i x = Pi.mulSingle i x := rfl\n\n"}
{"name":"AddMonoidHom.single_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → AddZeroClass (f i)\ni : I\nx : f i\n⊢ Eq ((AddMonoidHom.single f i) x) (Pi.single i x)","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.mulSingle_apply [∀ i, MulOneClass <| f i] (i : I) (x : f i) :\n    mulSingle f i x = Pi.mulSingle i x :=\n  rfl\n\n"}
{"name":"MonoidHom.mulSingle_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → MulOneClass (f i)\ni : I\nx : f i\n⊢ Eq ((MonoidHom.mulSingle f i) x) (Pi.mulSingle i x)","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.mulSingle_apply [∀ i, MulOneClass <| f i] (i : I) (x : f i) :\n    mulSingle f i x = Pi.mulSingle i x :=\n  rfl\n\n"}
{"name":"Pi.single_sup","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝² : DecidableEq I\ninst✝¹ : (i : I) → SemilatticeSup (f i)\ninst✝ : (i : I) → Zero (f i)\ni : I\nx y : f i\n⊢ Eq (Pi.single i (Max.max x y)) (Max.max (Pi.single i x) (Pi.single i y))","decl":"@[to_additive]\ntheorem Pi.mulSingle_sup [∀ i, SemilatticeSup (f i)] [∀ i, One (f i)] (i : I) (x y : f i) :\n    Pi.mulSingle i (x ⊔ y) = Pi.mulSingle i x ⊔ Pi.mulSingle i y :=\n  Function.update_sup _ _ _ _\n\n"}
{"name":"Pi.mulSingle_sup","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝² : DecidableEq I\ninst✝¹ : (i : I) → SemilatticeSup (f i)\ninst✝ : (i : I) → One (f i)\ni : I\nx y : f i\n⊢ Eq (Pi.mulSingle i (Max.max x y)) (Max.max (Pi.mulSingle i x) (Pi.mulSingle i y))","decl":"@[to_additive]\ntheorem Pi.mulSingle_sup [∀ i, SemilatticeSup (f i)] [∀ i, One (f i)] (i : I) (x y : f i) :\n    Pi.mulSingle i (x ⊔ y) = Pi.mulSingle i x ⊔ Pi.mulSingle i y :=\n  Function.update_sup _ _ _ _\n\n"}
{"name":"Pi.mulSingle_inf","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝² : DecidableEq I\ninst✝¹ : (i : I) → SemilatticeInf (f i)\ninst✝ : (i : I) → One (f i)\ni : I\nx y : f i\n⊢ Eq (Pi.mulSingle i (Min.min x y)) (Min.min (Pi.mulSingle i x) (Pi.mulSingle i y))","decl":"@[to_additive]\ntheorem Pi.mulSingle_inf [∀ i, SemilatticeInf (f i)] [∀ i, One (f i)] (i : I) (x y : f i) :\n    Pi.mulSingle i (x ⊓ y) = Pi.mulSingle i x ⊓ Pi.mulSingle i y :=\n  Function.update_inf _ _ _ _\n\n"}
{"name":"Pi.single_inf","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝² : DecidableEq I\ninst✝¹ : (i : I) → SemilatticeInf (f i)\ninst✝ : (i : I) → Zero (f i)\ni : I\nx y : f i\n⊢ Eq (Pi.single i (Min.min x y)) (Min.min (Pi.single i x) (Pi.single i y))","decl":"@[to_additive]\ntheorem Pi.mulSingle_inf [∀ i, SemilatticeInf (f i)] [∀ i, One (f i)] (i : I) (x y : f i) :\n    Pi.mulSingle i (x ⊓ y) = Pi.mulSingle i x ⊓ Pi.mulSingle i y :=\n  Function.update_inf _ _ _ _\n\n"}
{"name":"Pi.single_add","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → AddZeroClass (f i)\ni : I\nx y : f i\n⊢ Eq (Pi.single i (HAdd.hAdd x y)) (HAdd.hAdd (Pi.single i x) (Pi.single i y))","decl":"@[to_additive]\ntheorem Pi.mulSingle_mul [∀ i, MulOneClass <| f i] (i : I) (x y : f i) :\n    mulSingle i (x * y) = mulSingle i x * mulSingle i y :=\n  (MonoidHom.mulSingle f i).map_mul x y\n\n"}
{"name":"Pi.mulSingle_mul","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → MulOneClass (f i)\ni : I\nx y : f i\n⊢ Eq (Pi.mulSingle i (HMul.hMul x y)) (HMul.hMul (Pi.mulSingle i x) (Pi.mulSingle i y))","decl":"@[to_additive]\ntheorem Pi.mulSingle_mul [∀ i, MulOneClass <| f i] (i : I) (x y : f i) :\n    mulSingle i (x * y) = mulSingle i x * mulSingle i y :=\n  (MonoidHom.mulSingle f i).map_mul x y\n\n"}
{"name":"Pi.mulSingle_inv","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → Group (f i)\ni : I\nx : f i\n⊢ Eq (Pi.mulSingle i (Inv.inv x)) (Inv.inv (Pi.mulSingle i x))","decl":"@[to_additive]\ntheorem Pi.mulSingle_inv [∀ i, Group <| f i] (i : I) (x : f i) :\n    mulSingle i x⁻¹ = (mulSingle i x)⁻¹ :=\n  (MonoidHom.mulSingle f i).map_inv x\n\n"}
{"name":"Pi.single_neg","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → AddGroup (f i)\ni : I\nx : f i\n⊢ Eq (Pi.single i (Neg.neg x)) (Neg.neg (Pi.single i x))","decl":"@[to_additive]\ntheorem Pi.mulSingle_inv [∀ i, Group <| f i] (i : I) (x : f i) :\n    mulSingle i x⁻¹ = (mulSingle i x)⁻¹ :=\n  (MonoidHom.mulSingle f i).map_inv x\n\n"}
{"name":"Pi.mulSingle_div","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → Group (f i)\ni : I\nx y : f i\n⊢ Eq (Pi.mulSingle i (HDiv.hDiv x y)) (HDiv.hDiv (Pi.mulSingle i x) (Pi.mulSingle i y))","decl":"@[to_additive]\ntheorem Pi.mulSingle_div [∀ i, Group <| f i] (i : I) (x y : f i) :\n    mulSingle i (x / y) = mulSingle i x / mulSingle i y :=\n  (MonoidHom.mulSingle f i).map_div x y\n\n"}
{"name":"Pi.single_sub","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → AddGroup (f i)\ni : I\nx y : f i\n⊢ Eq (Pi.single i (HSub.hSub x y)) (HSub.hSub (Pi.single i x) (Pi.single i y))","decl":"@[to_additive]\ntheorem Pi.mulSingle_div [∀ i, Group <| f i] (i : I) (x y : f i) :\n    mulSingle i (x / y) = mulSingle i x / mulSingle i y :=\n  (MonoidHom.mulSingle f i).map_div x y\n\n"}
{"name":"Pi.single_nsmul","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → AddMonoid (f i)\ni : I\nx : f i\nn : Nat\n⊢ Eq (Pi.single i (HSMul.hSMul n x)) (HSMul.hSMul n (Pi.single i x))","decl":"@[to_additive]\ntheorem Pi.mulSingle_pow [∀ i, Monoid (f i)] (i : I) (x : f i) (n : ℕ) :\n    mulSingle i (x ^ n) = mulSingle i x ^ n :=\n  (MonoidHom.mulSingle f i).map_pow x n\n\n"}
{"name":"Pi.mulSingle_pow","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → Monoid (f i)\ni : I\nx : f i\nn : Nat\n⊢ Eq (Pi.mulSingle i (HPow.hPow x n)) (HPow.hPow (Pi.mulSingle i x) n)","decl":"@[to_additive]\ntheorem Pi.mulSingle_pow [∀ i, Monoid (f i)] (i : I) (x : f i) (n : ℕ) :\n    mulSingle i (x ^ n) = mulSingle i x ^ n :=\n  (MonoidHom.mulSingle f i).map_pow x n\n\n"}
{"name":"Pi.mulSingle_zpow","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → Group (f i)\ni : I\nx : f i\nn : Int\n⊢ Eq (Pi.mulSingle i (HPow.hPow x n)) (HPow.hPow (Pi.mulSingle i x) n)","decl":"@[to_additive]\ntheorem Pi.mulSingle_zpow [∀ i, Group (f i)] (i : I) (x : f i) (n : ℤ) :\n    mulSingle i (x ^ n) = mulSingle i x ^ n :=\n  (MonoidHom.mulSingle f i).map_zpow x n\n\n"}
{"name":"Pi.single_zsmul","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → AddGroup (f i)\ni : I\nx : f i\nn : Int\n⊢ Eq (Pi.single i (HSMul.hSMul n x)) (HSMul.hSMul n (Pi.single i x))","decl":"@[to_additive]\ntheorem Pi.mulSingle_zpow [∀ i, Group (f i)] (i : I) (x : f i) (n : ℤ) :\n    mulSingle i (x ^ n) = mulSingle i x ^ n :=\n  (MonoidHom.mulSingle f i).map_zpow x n\n\n"}
{"name":"Pi.single_addCommute","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → AddZeroClass (f i)\n⊢ Pairwise fun i j => ∀ (x : f i) (y : f j), AddCommute (Pi.single i x) (Pi.single j y)","decl":"/-- The injection into a pi group at different indices commutes.\n\nFor injections of commuting elements at the same index, see `Commute.map` -/\n@[to_additive\n      \"The injection into an additive pi group at different indices commutes.\n\n      For injections of commuting elements at the same index, see `AddCommute.map`\"]\ntheorem Pi.mulSingle_commute [∀ i, MulOneClass <| f i] :\n    Pairwise fun i j => ∀ (x : f i) (y : f j), Commute (mulSingle i x) (mulSingle j y) := by\n  intro i j hij x y; ext k\n  by_cases h1 : i = k\n  · subst h1\n    simp [hij]\n  by_cases h2 : j = k\n  · subst h2\n    simp [hij]\n  simp [h1, h2]\n\n"}
{"name":"Pi.mulSingle_commute","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → MulOneClass (f i)\n⊢ Pairwise fun i j => ∀ (x : f i) (y : f j), Commute (Pi.mulSingle i x) (Pi.mulSingle j y)","decl":"/-- The injection into a pi group at different indices commutes.\n\nFor injections of commuting elements at the same index, see `Commute.map` -/\n@[to_additive\n      \"The injection into an additive pi group at different indices commutes.\n\n      For injections of commuting elements at the same index, see `AddCommute.map`\"]\ntheorem Pi.mulSingle_commute [∀ i, MulOneClass <| f i] :\n    Pairwise fun i j => ∀ (x : f i) (y : f j), Commute (mulSingle i x) (mulSingle j y) := by\n  intro i j hij x y; ext k\n  by_cases h1 : i = k\n  · subst h1\n    simp [hij]\n  by_cases h2 : j = k\n  · subst h2\n    simp [hij]\n  simp [h1, h2]\n\n"}
{"name":"Pi.single_apply_addCommute","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → AddZeroClass (f i)\nx : (i : I) → f i\ni j : I\n⊢ AddCommute (Pi.single i (x i)) (Pi.single j (x j))","decl":"/-- The injection into a pi group with the same values commutes. -/\n@[to_additive \"The injection into an additive pi group with the same values commutes.\"]\ntheorem Pi.mulSingle_apply_commute [∀ i, MulOneClass <| f i] (x : ∀ i, f i) (i j : I) :\n    Commute (mulSingle i (x i)) (mulSingle j (x j)) := by\n  obtain rfl | hij := Decidable.eq_or_ne i j\n  · rfl\n  · exact Pi.mulSingle_commute hij _ _\n\n"}
{"name":"Pi.mulSingle_apply_commute","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → MulOneClass (f i)\nx : (i : I) → f i\ni j : I\n⊢ Commute (Pi.mulSingle i (x i)) (Pi.mulSingle j (x j))","decl":"/-- The injection into a pi group with the same values commutes. -/\n@[to_additive \"The injection into an additive pi group with the same values commutes.\"]\ntheorem Pi.mulSingle_apply_commute [∀ i, MulOneClass <| f i] (x : ∀ i, f i) (i j : I) :\n    Commute (mulSingle i (x i)) (mulSingle j (x j)) := by\n  obtain rfl | hij := Decidable.eq_or_ne i j\n  · rfl\n  · exact Pi.mulSingle_commute hij _ _\n\n"}
{"name":"Pi.update_eq_sub_add_single","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ni : I\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → AddGroup (f i)\ng : (i : I) → f i\nx : f i\n⊢ Eq (Function.update g i x) (HAdd.hAdd (HSub.hSub g (Pi.single i (g i))) (Pi.single i x))","decl":"@[to_additive]\ntheorem Pi.update_eq_div_mul_mulSingle [∀ i, Group <| f i] (g : ∀ i : I, f i) (x : f i) :\n    Function.update g i x = g / mulSingle i (g i) * mulSingle i x := by\n  ext j\n  rcases eq_or_ne i j with (rfl | h)\n  · simp\n  · simp [Function.update_of_ne h.symm, h]\n\n"}
{"name":"Pi.update_eq_div_mul_mulSingle","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ni : I\ninst✝¹ : DecidableEq I\ninst✝ : (i : I) → Group (f i)\ng : (i : I) → f i\nx : f i\n⊢ Eq (Function.update g i x) (HMul.hMul (HDiv.hDiv g (Pi.mulSingle i (g i))) (Pi.mulSingle i x))","decl":"@[to_additive]\ntheorem Pi.update_eq_div_mul_mulSingle [∀ i, Group <| f i] (g : ∀ i : I, f i) (x : f i) :\n    Function.update g i x = g / mulSingle i (g i) * mulSingle i x := by\n  ext j\n  rcases eq_or_ne i j with (rfl | h)\n  · simp\n  · simp [Function.update_of_ne h.symm, h]\n\n"}
{"name":"Pi.single_add_single_eq_single_add_single","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\ninst✝¹ : DecidableEq I\nM : Type u_3\ninst✝ : AddCommMonoid M\nk l m n : I\nu v : M\nhu : Ne u 0\nhv : Ne v 0\n⊢ Iff (Eq (HAdd.hAdd (Pi.single k u) (Pi.single l v)) (HAdd.hAdd (Pi.single m u) (Pi.single n v))) (Or (And (Eq k m) (Eq l n)) (Or (And (Eq u v) (And (Eq k n) (Eq l m))) (And (Eq (HAdd.hAdd u v) 0) (And (Eq k l) (Eq m n)))))","decl":"@[to_additive]\ntheorem Pi.mulSingle_mul_mulSingle_eq_mulSingle_mul_mulSingle {M : Type*} [CommMonoid M]\n    {k l m n : I} {u v : M} (hu : u ≠ 1) (hv : v ≠ 1) :\n    (mulSingle k u : I → M) * mulSingle l v = mulSingle m u * mulSingle n v ↔\n      k = m ∧ l = n ∨ u = v ∧ k = n ∧ l = m ∨ u * v = 1 ∧ k = l ∧ m = n := by\n  refine ⟨fun h => ?_, ?_⟩\n  · have hk := congr_fun h k\n    have hl := congr_fun h l\n    have hm := (congr_fun h m).symm\n    have hn := (congr_fun h n).symm\n    simp only [mul_apply, mulSingle_apply, if_pos rfl] at hk hl hm hn\n    rcases eq_or_ne k m with (rfl | hkm)\n    · refine Or.inl ⟨rfl, not_ne_iff.mp fun hln => (hv ?_).elim⟩\n      rcases eq_or_ne k l with (rfl | hkl)\n      · rwa [if_neg hln.symm, if_neg hln.symm, one_mul, one_mul] at hn\n      · rwa [if_neg hkl.symm, if_neg hln, one_mul, one_mul] at hl\n    · rcases eq_or_ne m n with (rfl | hmn)\n      · rcases eq_or_ne k l with (rfl | hkl)\n        · rw [if_neg hkm.symm, if_neg hkm.symm, one_mul, if_pos rfl] at hm\n          exact Or.inr (Or.inr ⟨hm, rfl, rfl⟩)\n        · simp only [if_neg hkm, if_neg hkl, mul_one] at hk\n          dsimp at hk\n          contradiction\n      · rw [if_neg hkm.symm, if_neg hmn, one_mul, mul_one] at hm\n        obtain rfl := (ite_ne_right_iff.mp (ne_of_eq_of_ne hm.symm hu)).1\n        rw [if_neg hkm, if_neg hkm, one_mul, mul_one] at hk\n        obtain rfl := (ite_ne_right_iff.mp (ne_of_eq_of_ne hk.symm hu)).1\n        exact Or.inr (Or.inl ⟨hk.trans (if_pos rfl), rfl, rfl⟩)\n  · rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl, rfl⟩ | ⟨h, rfl, rfl⟩)\n    · rfl\n    · apply mul_comm\n    · simp_rw [← Pi.mulSingle_mul, h, mulSingle_one]\n\n"}
{"name":"Pi.mulSingle_mul_mulSingle_eq_mulSingle_mul_mulSingle","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\ninst✝¹ : DecidableEq I\nM : Type u_3\ninst✝ : CommMonoid M\nk l m n : I\nu v : M\nhu : Ne u 1\nhv : Ne v 1\n⊢ Iff (Eq (HMul.hMul (Pi.mulSingle k u) (Pi.mulSingle l v)) (HMul.hMul (Pi.mulSingle m u) (Pi.mulSingle n v))) (Or (And (Eq k m) (Eq l n)) (Or (And (Eq u v) (And (Eq k n) (Eq l m))) (And (Eq (HMul.hMul u v) 1) (And (Eq k l) (Eq m n)))))","decl":"@[to_additive]\ntheorem Pi.mulSingle_mul_mulSingle_eq_mulSingle_mul_mulSingle {M : Type*} [CommMonoid M]\n    {k l m n : I} {u v : M} (hu : u ≠ 1) (hv : v ≠ 1) :\n    (mulSingle k u : I → M) * mulSingle l v = mulSingle m u * mulSingle n v ↔\n      k = m ∧ l = n ∨ u = v ∧ k = n ∧ l = m ∨ u * v = 1 ∧ k = l ∧ m = n := by\n  refine ⟨fun h => ?_, ?_⟩\n  · have hk := congr_fun h k\n    have hl := congr_fun h l\n    have hm := (congr_fun h m).symm\n    have hn := (congr_fun h n).symm\n    simp only [mul_apply, mulSingle_apply, if_pos rfl] at hk hl hm hn\n    rcases eq_or_ne k m with (rfl | hkm)\n    · refine Or.inl ⟨rfl, not_ne_iff.mp fun hln => (hv ?_).elim⟩\n      rcases eq_or_ne k l with (rfl | hkl)\n      · rwa [if_neg hln.symm, if_neg hln.symm, one_mul, one_mul] at hn\n      · rwa [if_neg hkl.symm, if_neg hln, one_mul, one_mul] at hl\n    · rcases eq_or_ne m n with (rfl | hmn)\n      · rcases eq_or_ne k l with (rfl | hkl)\n        · rw [if_neg hkm.symm, if_neg hkm.symm, one_mul, if_pos rfl] at hm\n          exact Or.inr (Or.inr ⟨hm, rfl, rfl⟩)\n        · simp only [if_neg hkm, if_neg hkl, mul_one] at hk\n          dsimp at hk\n          contradiction\n      · rw [if_neg hkm.symm, if_neg hmn, one_mul, mul_one] at hm\n        obtain rfl := (ite_ne_right_iff.mp (ne_of_eq_of_ne hm.symm hu)).1\n        rw [if_neg hkm, if_neg hkm, one_mul, mul_one] at hk\n        obtain rfl := (ite_ne_right_iff.mp (ne_of_eq_of_ne hk.symm hu)).1\n        exact Or.inr (Or.inl ⟨hk.trans (if_pos rfl), rfl, rfl⟩)\n  · rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl, rfl⟩ | ⟨h, rfl, rfl⟩)\n    · rfl\n    · apply mul_comm\n    · simp_rw [← Pi.mulSingle_mul, h, mulSingle_one]\n\n"}
{"name":"AddSemiconjBy.pi","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → Add (f i)\nx y z : (i : I) → f i\nh : ∀ (i : I), AddSemiconjBy (x i) (y i) (z i)\n⊢ AddSemiconjBy x y z","decl":"@[to_additive]\ntheorem SemiconjBy.pi {x y z : ∀ i, f i} (h : ∀ i, SemiconjBy (x i) (y i) (z i)) :\n    SemiconjBy x y z :=\n  funext h\n\n"}
{"name":"SemiconjBy.pi","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → Mul (f i)\nx y z : (i : I) → f i\nh : ∀ (i : I), SemiconjBy (x i) (y i) (z i)\n⊢ SemiconjBy x y z","decl":"@[to_additive]\ntheorem SemiconjBy.pi {x y z : ∀ i, f i} (h : ∀ i, SemiconjBy (x i) (y i) (z i)) :\n    SemiconjBy x y z :=\n  funext h\n\n"}
{"name":"Pi.semiconjBy_iff","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → Mul (f i)\nx y z : (i : I) → f i\n⊢ Iff (SemiconjBy x y z) (∀ (i : I), SemiconjBy (x i) (y i) (z i))","decl":"@[to_additive]\ntheorem Pi.semiconjBy_iff {x y z : ∀ i, f i} :\n    SemiconjBy x y z ↔ ∀ i, SemiconjBy (x i) (y i) (z i) := funext_iff\n\n"}
{"name":"Pi.addSemiconjBy_iff","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → Add (f i)\nx y z : (i : I) → f i\n⊢ Iff (AddSemiconjBy x y z) (∀ (i : I), AddSemiconjBy (x i) (y i) (z i))","decl":"@[to_additive]\ntheorem Pi.semiconjBy_iff {x y z : ∀ i, f i} :\n    SemiconjBy x y z ↔ ∀ i, SemiconjBy (x i) (y i) (z i) := funext_iff\n\n"}
{"name":"AddCommute.pi","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → Add (f i)\nx y : (i : I) → f i\nh : ∀ (i : I), AddCommute (x i) (y i)\n⊢ AddCommute x y","decl":"@[to_additive]\ntheorem Commute.pi {x y : ∀ i, f i} (h : ∀ i, Commute (x i) (y i)) : Commute x y := SemiconjBy.pi h\n\n"}
{"name":"Commute.pi","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → Mul (f i)\nx y : (i : I) → f i\nh : ∀ (i : I), Commute (x i) (y i)\n⊢ Commute x y","decl":"@[to_additive]\ntheorem Commute.pi {x y : ∀ i, f i} (h : ∀ i, Commute (x i) (y i)) : Commute x y := SemiconjBy.pi h\n\n"}
{"name":"Pi.addCommute_iff","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → Add (f i)\nx y : (i : I) → f i\n⊢ Iff (AddCommute x y) (∀ (i : I), AddCommute (x i) (y i))","decl":"@[to_additive]\ntheorem Pi.commute_iff {x y : ∀ i, f i} : Commute x y ↔ ∀ i, Commute (x i) (y i) := semiconjBy_iff\n\n"}
{"name":"Pi.commute_iff","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → Mul (f i)\nx y : (i : I) → f i\n⊢ Iff (Commute x y) (∀ (i : I), Commute (x i) (y i))","decl":"@[to_additive]\ntheorem Pi.commute_iff {x y : ∀ i, f i} : Commute x y ↔ ∀ i, Commute (x i) (y i) := semiconjBy_iff\n\n"}
{"name":"Function.update_one","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → One (f i)\ninst✝ : DecidableEq I\ni : I\n⊢ Eq (Function.update 1 i 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem update_one [∀ i, One (f i)] [DecidableEq I] (i : I) : update (1 : ∀ i, f i) i 1 = 1 :=\n  update_eq_self i (1 : (a : I) → f a)\n\n"}
{"name":"Function.update_zero","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → Zero (f i)\ninst✝ : DecidableEq I\ni : I\n⊢ Eq (Function.update 0 i 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem update_one [∀ i, One (f i)] [DecidableEq I] (i : I) : update (1 : ∀ i, f i) i 1 = 1 :=\n  update_eq_self i (1 : (a : I) → f a)\n\n"}
{"name":"Function.update_mul","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → Mul (f i)\ninst✝ : DecidableEq I\nf₁ f₂ : (i : I) → f i\ni : I\nx₁ x₂ : f i\n⊢ Eq (Function.update (HMul.hMul f₁ f₂) i (HMul.hMul x₁ x₂)) (HMul.hMul (Function.update f₁ i x₁) (Function.update f₂ i x₂))","decl":"@[to_additive]\ntheorem update_mul [∀ i, Mul (f i)] [DecidableEq I] (f₁ f₂ : ∀ i, f i) (i : I) (x₁ : f i)\n    (x₂ : f i) : update (f₁ * f₂) i (x₁ * x₂) = update f₁ i x₁ * update f₂ i x₂ :=\n  funext fun j => (apply_update₂ (fun _ => (· * ·)) f₁ f₂ i x₁ x₂ j).symm\n\n"}
{"name":"Function.update_add","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → Add (f i)\ninst✝ : DecidableEq I\nf₁ f₂ : (i : I) → f i\ni : I\nx₁ x₂ : f i\n⊢ Eq (Function.update (HAdd.hAdd f₁ f₂) i (HAdd.hAdd x₁ x₂)) (HAdd.hAdd (Function.update f₁ i x₁) (Function.update f₂ i x₂))","decl":"@[to_additive]\ntheorem update_mul [∀ i, Mul (f i)] [DecidableEq I] (f₁ f₂ : ∀ i, f i) (i : I) (x₁ : f i)\n    (x₂ : f i) : update (f₁ * f₂) i (x₁ * x₂) = update f₁ i x₁ * update f₂ i x₂ :=\n  funext fun j => (apply_update₂ (fun _ => (· * ·)) f₁ f₂ i x₁ x₂ j).symm\n\n"}
{"name":"Function.update_neg","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → Neg (f i)\ninst✝ : DecidableEq I\nf₁ : (i : I) → f i\ni : I\nx₁ : f i\n⊢ Eq (Function.update (Neg.neg f₁) i (Neg.neg x₁)) (Neg.neg (Function.update f₁ i x₁))","decl":"@[to_additive]\ntheorem update_inv [∀ i, Inv (f i)] [DecidableEq I] (f₁ : ∀ i, f i) (i : I) (x₁ : f i) :\n    update f₁⁻¹ i x₁⁻¹ = (update f₁ i x₁)⁻¹ :=\n  funext fun j => (apply_update (fun _ => Inv.inv) f₁ i x₁ j).symm\n\n"}
{"name":"Function.update_inv","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → Inv (f i)\ninst✝ : DecidableEq I\nf₁ : (i : I) → f i\ni : I\nx₁ : f i\n⊢ Eq (Function.update (Inv.inv f₁) i (Inv.inv x₁)) (Inv.inv (Function.update f₁ i x₁))","decl":"@[to_additive]\ntheorem update_inv [∀ i, Inv (f i)] [DecidableEq I] (f₁ : ∀ i, f i) (i : I) (x₁ : f i) :\n    update f₁⁻¹ i x₁⁻¹ = (update f₁ i x₁)⁻¹ :=\n  funext fun j => (apply_update (fun _ => Inv.inv) f₁ i x₁ j).symm\n\n"}
{"name":"Function.update_sub","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → Sub (f i)\ninst✝ : DecidableEq I\nf₁ f₂ : (i : I) → f i\ni : I\nx₁ x₂ : f i\n⊢ Eq (Function.update (HSub.hSub f₁ f₂) i (HSub.hSub x₁ x₂)) (HSub.hSub (Function.update f₁ i x₁) (Function.update f₂ i x₂))","decl":"@[to_additive]\ntheorem update_div [∀ i, Div (f i)] [DecidableEq I] (f₁ f₂ : ∀ i, f i) (i : I) (x₁ : f i)\n    (x₂ : f i) : update (f₁ / f₂) i (x₁ / x₂) = update f₁ i x₁ / update f₂ i x₂ :=\n  funext fun j => (apply_update₂ (fun _ => (· / ·)) f₁ f₂ i x₁ x₂ j).symm\n\n"}
{"name":"Function.update_div","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → Div (f i)\ninst✝ : DecidableEq I\nf₁ f₂ : (i : I) → f i\ni : I\nx₁ x₂ : f i\n⊢ Eq (Function.update (HDiv.hDiv f₁ f₂) i (HDiv.hDiv x₁ x₂)) (HDiv.hDiv (Function.update f₁ i x₁) (Function.update f₂ i x₂))","decl":"@[to_additive]\ntheorem update_div [∀ i, Div (f i)] [DecidableEq I] (f₁ f₂ : ∀ i, f i) (i : I) (x₁ : f i)\n    (x₂ : f i) : update (f₁ / f₂) i (x₁ / x₂) = update f₁ i x₁ / update f₂ i x₂ :=\n  funext fun j => (apply_update₂ (fun _ => (· / ·)) f₁ f₂ i x₁ x₂ j).symm\n\n"}
{"name":"Function.const_eq_one","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : One α\ninst✝ : Nonempty ι\na : α\n⊢ Iff (Eq (Function.const ι a) 1) (Eq a 1)","decl":"@[to_additive (attr := simp)]\ntheorem const_eq_one : const ι a = 1 ↔ a = 1 :=\n  @const_inj _ _ _ _ 1\n\n"}
{"name":"Function.const_eq_zero","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : Zero α\ninst✝ : Nonempty ι\na : α\n⊢ Iff (Eq (Function.const ι a) 0) (Eq a 0)","decl":"@[to_additive (attr := simp)]\ntheorem const_eq_one : const ι a = 1 ↔ a = 1 :=\n  @const_inj _ _ _ _ 1\n\n"}
{"name":"Function.const_ne_zero","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : Zero α\ninst✝ : Nonempty ι\na : α\n⊢ Iff (Ne (Function.const ι a) 0) (Ne a 0)","decl":"@[to_additive]\ntheorem const_ne_one : const ι a ≠ 1 ↔ a ≠ 1 :=\n  Iff.not const_eq_one\n\n"}
{"name":"Function.const_ne_one","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : One α\ninst✝ : Nonempty ι\na : α\n⊢ Iff (Ne (Function.const ι a) 1) (Ne a 1)","decl":"@[to_additive]\ntheorem const_ne_one : const ι a ≠ 1 ↔ a ≠ 1 :=\n  Iff.not const_eq_one\n\n"}
{"name":"Set.piecewise_add","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → Add (f i)\ns : Set I\ninst✝ : (i : I) → Decidable (Membership.mem s i)\nf₁ f₂ g₁ g₂ : (i : I) → f i\n⊢ Eq (s.piecewise (HAdd.hAdd f₁ f₂) (HAdd.hAdd g₁ g₂)) (HAdd.hAdd (s.piecewise f₁ g₁) (s.piecewise f₂ g₂))","decl":"@[to_additive]\ntheorem Set.piecewise_mul [∀ i, Mul (f i)] (s : Set I) [∀ i, Decidable (i ∈ s)]\n    (f₁ f₂ g₁ g₂ : ∀ i, f i) :\n    s.piecewise (f₁ * f₂) (g₁ * g₂) = s.piecewise f₁ g₁ * s.piecewise f₂ g₂ :=\n  s.piecewise_op₂ f₁ _ _ _ fun _ => (· * ·)\n\n"}
{"name":"Set.piecewise_mul","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → Mul (f i)\ns : Set I\ninst✝ : (i : I) → Decidable (Membership.mem s i)\nf₁ f₂ g₁ g₂ : (i : I) → f i\n⊢ Eq (s.piecewise (HMul.hMul f₁ f₂) (HMul.hMul g₁ g₂)) (HMul.hMul (s.piecewise f₁ g₁) (s.piecewise f₂ g₂))","decl":"@[to_additive]\ntheorem Set.piecewise_mul [∀ i, Mul (f i)] (s : Set I) [∀ i, Decidable (i ∈ s)]\n    (f₁ f₂ g₁ g₂ : ∀ i, f i) :\n    s.piecewise (f₁ * f₂) (g₁ * g₂) = s.piecewise f₁ g₁ * s.piecewise f₂ g₂ :=\n  s.piecewise_op₂ f₁ _ _ _ fun _ => (· * ·)\n\n"}
{"name":"Set.piecewise_inv","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → Inv (f i)\ns : Set I\ninst✝ : (i : I) → Decidable (Membership.mem s i)\nf₁ g₁ : (i : I) → f i\n⊢ Eq (s.piecewise (Inv.inv f₁) (Inv.inv g₁)) (Inv.inv (s.piecewise f₁ g₁))","decl":"@[to_additive]\ntheorem Set.piecewise_inv [∀ i, Inv (f i)] (s : Set I) [∀ i, Decidable (i ∈ s)] (f₁ g₁ : ∀ i, f i) :\n    s.piecewise f₁⁻¹ g₁⁻¹ = (s.piecewise f₁ g₁)⁻¹ :=\n  s.piecewise_op f₁ g₁ fun _ x => x⁻¹\n\n"}
{"name":"Set.piecewise_neg","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → Neg (f i)\ns : Set I\ninst✝ : (i : I) → Decidable (Membership.mem s i)\nf₁ g₁ : (i : I) → f i\n⊢ Eq (s.piecewise (Neg.neg f₁) (Neg.neg g₁)) (Neg.neg (s.piecewise f₁ g₁))","decl":"@[to_additive]\ntheorem Set.piecewise_inv [∀ i, Inv (f i)] (s : Set I) [∀ i, Decidable (i ∈ s)] (f₁ g₁ : ∀ i, f i) :\n    s.piecewise f₁⁻¹ g₁⁻¹ = (s.piecewise f₁ g₁)⁻¹ :=\n  s.piecewise_op f₁ g₁ fun _ x => x⁻¹\n\n"}
{"name":"Set.piecewise_div","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → Div (f i)\ns : Set I\ninst✝ : (i : I) → Decidable (Membership.mem s i)\nf₁ f₂ g₁ g₂ : (i : I) → f i\n⊢ Eq (s.piecewise (HDiv.hDiv f₁ f₂) (HDiv.hDiv g₁ g₂)) (HDiv.hDiv (s.piecewise f₁ g₁) (s.piecewise f₂ g₂))","decl":"@[to_additive]\ntheorem Set.piecewise_div [∀ i, Div (f i)] (s : Set I) [∀ i, Decidable (i ∈ s)]\n    (f₁ f₂ g₁ g₂ : ∀ i, f i) :\n    s.piecewise (f₁ / f₂) (g₁ / g₂) = s.piecewise f₁ g₁ / s.piecewise f₂ g₂ :=\n  s.piecewise_op₂ f₁ _ _ _ fun _ => (· / ·)\n\n"}
{"name":"Set.piecewise_sub","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ninst✝¹ : (i : I) → Sub (f i)\ns : Set I\ninst✝ : (i : I) → Decidable (Membership.mem s i)\nf₁ f₂ g₁ g₂ : (i : I) → f i\n⊢ Eq (s.piecewise (HSub.hSub f₁ f₂) (HSub.hSub g₁ g₂)) (HSub.hSub (s.piecewise f₁ g₁) (s.piecewise f₂ g₂))","decl":"@[to_additive]\ntheorem Set.piecewise_div [∀ i, Div (f i)] (s : Set I) [∀ i, Decidable (i ∈ s)]\n    (f₁ f₂ g₁ g₂ : ∀ i, f i) :\n    s.piecewise (f₁ / f₂) (g₁ / g₂) = s.piecewise f₁ g₁ / s.piecewise f₂ g₂ :=\n  s.piecewise_op₂ f₁ _ _ _ fun _ => (· / ·)\n\n"}
{"name":"Function.ExtendByOne.hom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"ι : Type u_1\nη : Type v\nR : Type w\ns : ι → η\ninst✝ : MulOneClass R\nf : ι → R\na✝ : η\n⊢ Eq ((Function.ExtendByOne.hom R s) f a✝) (Function.extend s f 1 a✝)","decl":"/-- `Function.extend s f 1` as a bundled hom. -/\n@[to_additive (attr := simps) Function.ExtendByZero.hom \"`Function.extend s f 0` as a bundled hom.\"]\nnoncomputable def Function.ExtendByOne.hom [MulOneClass R] :\n    (ι → R) →* η → R where\n  toFun f := Function.extend s f 1\n  map_one' := Function.extend_one s\n  map_mul' f g := by simpa using Function.extend_mul s f g 1 1\n\n"}
{"name":"Function.ExtendByZero.hom_apply","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"ι : Type u_1\nη : Type v\nR : Type w\ns : ι → η\ninst✝ : AddZeroClass R\nf : ι → R\na✝ : η\n⊢ Eq ((Function.ExtendByZero.hom R s) f a✝) (Function.extend s f 0 a✝)","decl":"/-- `Function.extend s f 1` as a bundled hom. -/\n@[to_additive (attr := simps) Function.ExtendByZero.hom \"`Function.extend s f 0` as a bundled hom.\"]\nnoncomputable def Function.ExtendByOne.hom [MulOneClass R] :\n    (ι → R) →* η → R where\n  toFun f := Function.extend s f 1\n  map_one' := Function.extend_one s\n  map_mul' f g := by simpa using Function.extend_mul s f g 1 1\n\n"}
{"name":"Pi.mulSingle_mono","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ni : I\ninst✝² : DecidableEq I\ninst✝¹ : (i : I) → Preorder (f i)\ninst✝ : (i : I) → One (f i)\n⊢ Monotone (Pi.mulSingle i)","decl":"@[to_additive]\ntheorem mulSingle_mono : Monotone (Pi.mulSingle i : f i → ∀ i, f i) :=\n  Function.update_mono\n\n"}
{"name":"Pi.single_mono","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ni : I\ninst✝² : DecidableEq I\ninst✝¹ : (i : I) → Preorder (f i)\ninst✝ : (i : I) → Zero (f i)\n⊢ Monotone (Pi.single i)","decl":"@[to_additive]\ntheorem mulSingle_mono : Monotone (Pi.mulSingle i : f i → ∀ i, f i) :=\n  Function.update_mono\n\n"}
{"name":"Pi.mulSingle_strictMono","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ni : I\ninst✝² : DecidableEq I\ninst✝¹ : (i : I) → Preorder (f i)\ninst✝ : (i : I) → One (f i)\n⊢ StrictMono (Pi.mulSingle i)","decl":"@[to_additive]\ntheorem mulSingle_strictMono : StrictMono (Pi.mulSingle i : f i → ∀ i, f i) :=\n  Function.update_strictMono\n\n"}
{"name":"Pi.single_strictMono","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"I : Type u\nf : I → Type v\ni : I\ninst✝² : DecidableEq I\ninst✝¹ : (i : I) → Preorder (f i)\ninst✝ : (i : I) → Zero (f i)\n⊢ StrictMono (Pi.single i)","decl":"@[to_additive]\ntheorem mulSingle_strictMono : StrictMono (Pi.mulSingle i : f i → ∀ i, f i) :=\n  Function.update_strictMono\n\n"}
{"name":"Sigma.curry_zero","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝ : (a : α) → (b : β a) → Zero (γ a b)\n⊢ Eq (Sigma.curry 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem curry_one [∀ a b, One (γ a b)] : Sigma.curry (1 : (i : Σ a, β a) → γ i.1 i.2) = 1 :=\n  rfl\n\n"}
{"name":"Sigma.curry_one","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝ : (a : α) → (b : β a) → One (γ a b)\n⊢ Eq (Sigma.curry 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem curry_one [∀ a b, One (γ a b)] : Sigma.curry (1 : (i : Σ a, β a) → γ i.1 i.2) = 1 :=\n  rfl\n\n"}
{"name":"Sigma.uncurry_zero","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝ : (a : α) → (b : β a) → Zero (γ a b)\n⊢ Eq (Sigma.uncurry 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem uncurry_one [∀ a b, One (γ a b)] : Sigma.uncurry (1 : ∀ a b, γ a b) = 1 :=\n  rfl\n\n"}
{"name":"Sigma.uncurry_one","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝ : (a : α) → (b : β a) → One (γ a b)\n⊢ Eq (Sigma.uncurry 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem uncurry_one [∀ a b, One (γ a b)] : Sigma.uncurry (1 : ∀ a b, γ a b) = 1 :=\n  rfl\n\n"}
{"name":"Sigma.curry_add","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝ : (a : α) → (b : β a) → Add (γ a b)\nx y : (i : Sigma fun a => β a) → γ i.fst i.snd\n⊢ Eq (Sigma.curry (HAdd.hAdd x y)) (HAdd.hAdd (Sigma.curry x) (Sigma.curry y))","decl":"@[to_additive (attr := simp)]\ntheorem curry_mul [∀ a b, Mul (γ a b)] (x y : (i : Σ a, β a) → γ i.1 i.2) :\n    Sigma.curry (x * y) = Sigma.curry x * Sigma.curry y :=\n  rfl\n\n"}
{"name":"Sigma.curry_mul","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝ : (a : α) → (b : β a) → Mul (γ a b)\nx y : (i : Sigma fun a => β a) → γ i.fst i.snd\n⊢ Eq (Sigma.curry (HMul.hMul x y)) (HMul.hMul (Sigma.curry x) (Sigma.curry y))","decl":"@[to_additive (attr := simp)]\ntheorem curry_mul [∀ a b, Mul (γ a b)] (x y : (i : Σ a, β a) → γ i.1 i.2) :\n    Sigma.curry (x * y) = Sigma.curry x * Sigma.curry y :=\n  rfl\n\n"}
{"name":"Sigma.uncurry_mul","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝ : (a : α) → (b : β a) → Mul (γ a b)\nx y : (a : α) → (b : β a) → γ a b\n⊢ Eq (Sigma.uncurry (HMul.hMul x y)) (HMul.hMul (Sigma.uncurry x) (Sigma.uncurry y))","decl":"@[to_additive (attr := simp)]\ntheorem uncurry_mul [∀ a b, Mul (γ a b)] (x y : ∀ a b, γ a b) :\n    Sigma.uncurry (x * y) = Sigma.uncurry x * Sigma.uncurry y :=\n  rfl\n\n"}
{"name":"Sigma.uncurry_add","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝ : (a : α) → (b : β a) → Add (γ a b)\nx y : (a : α) → (b : β a) → γ a b\n⊢ Eq (Sigma.uncurry (HAdd.hAdd x y)) (HAdd.hAdd (Sigma.uncurry x) (Sigma.uncurry y))","decl":"@[to_additive (attr := simp)]\ntheorem uncurry_mul [∀ a b, Mul (γ a b)] (x y : ∀ a b, γ a b) :\n    Sigma.uncurry (x * y) = Sigma.uncurry x * Sigma.uncurry y :=\n  rfl\n\n"}
{"name":"Sigma.curry_inv","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝ : (a : α) → (b : β a) → Inv (γ a b)\nx : (i : Sigma fun a => β a) → γ i.fst i.snd\n⊢ Eq (Sigma.curry (Inv.inv x)) (Inv.inv (Sigma.curry x))","decl":"@[to_additive (attr := simp)]\ntheorem curry_inv [∀ a b, Inv (γ a b)] (x : (i : Σ a, β a) → γ i.1 i.2) :\n    Sigma.curry (x⁻¹) = (Sigma.curry x)⁻¹ :=\n  rfl\n\n"}
{"name":"Sigma.curry_neg","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝ : (a : α) → (b : β a) → Neg (γ a b)\nx : (i : Sigma fun a => β a) → γ i.fst i.snd\n⊢ Eq (Sigma.curry (Neg.neg x)) (Neg.neg (Sigma.curry x))","decl":"@[to_additive (attr := simp)]\ntheorem curry_inv [∀ a b, Inv (γ a b)] (x : (i : Σ a, β a) → γ i.1 i.2) :\n    Sigma.curry (x⁻¹) = (Sigma.curry x)⁻¹ :=\n  rfl\n\n"}
{"name":"Sigma.uncurry_inv","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝ : (a : α) → (b : β a) → Inv (γ a b)\nx : (a : α) → (b : β a) → γ a b\n⊢ Eq (Sigma.uncurry (Inv.inv x)) (Inv.inv (Sigma.uncurry x))","decl":"@[to_additive (attr := simp)]\ntheorem uncurry_inv [∀ a b, Inv (γ a b)] (x : ∀ a b, γ a b) :\n    Sigma.uncurry (x⁻¹) = (Sigma.uncurry x)⁻¹ :=\n  rfl\n\n"}
{"name":"Sigma.uncurry_neg","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝ : (a : α) → (b : β a) → Neg (γ a b)\nx : (a : α) → (b : β a) → γ a b\n⊢ Eq (Sigma.uncurry (Neg.neg x)) (Neg.neg (Sigma.uncurry x))","decl":"@[to_additive (attr := simp)]\ntheorem uncurry_inv [∀ a b, Inv (γ a b)] (x : ∀ a b, γ a b) :\n    Sigma.uncurry (x⁻¹) = (Sigma.uncurry x)⁻¹ :=\n  rfl\n\n"}
{"name":"Sigma.curry_mulSingle","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (β a)\ninst✝ : (a : α) → (b : β a) → One (γ a b)\ni : Sigma fun a => β a\nx : γ i.fst i.snd\n⊢ Eq (Sigma.curry (Pi.mulSingle i x)) (Pi.mulSingle i.fst (Pi.mulSingle i.snd x))","decl":"@[to_additive (attr := simp)]\ntheorem curry_mulSingle [DecidableEq α] [∀ a, DecidableEq (β a)] [∀ a b, One (γ a b)]\n    (i : Σ a, β a) (x : γ i.1 i.2) :\n    Sigma.curry (Pi.mulSingle i x) = Pi.mulSingle i.1 (Pi.mulSingle i.2 x) := by\n  simp only [Pi.mulSingle, Sigma.curry_update, Sigma.curry_one, Pi.one_apply]\n\n"}
{"name":"Sigma.curry_single","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (β a)\ninst✝ : (a : α) → (b : β a) → Zero (γ a b)\ni : Sigma fun a => β a\nx : γ i.fst i.snd\n⊢ Eq (Sigma.curry (Pi.single i x)) (Pi.single i.fst (Pi.single i.snd x))","decl":"@[to_additive (attr := simp)]\ntheorem curry_mulSingle [DecidableEq α] [∀ a, DecidableEq (β a)] [∀ a b, One (γ a b)]\n    (i : Σ a, β a) (x : γ i.1 i.2) :\n    Sigma.curry (Pi.mulSingle i x) = Pi.mulSingle i.1 (Pi.mulSingle i.2 x) := by\n  simp only [Pi.mulSingle, Sigma.curry_update, Sigma.curry_one, Pi.one_apply]\n\n"}
{"name":"Sigma.uncurry_single_single","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (β a)\ninst✝ : (a : α) → (b : β a) → Zero (γ a b)\na : α\nb : β a\nx : γ a b\n⊢ Eq (Sigma.uncurry (Pi.single a (Pi.single b x))) (Pi.single ⟨a, b⟩ x)","decl":"@[to_additive (attr := simp)]\ntheorem uncurry_mulSingle_mulSingle [DecidableEq α] [∀ a, DecidableEq (β a)] [∀ a b, One (γ a b)]\n    (a : α) (b : β a) (x : γ a b) :\n    Sigma.uncurry (Pi.mulSingle a (Pi.mulSingle b x)) = Pi.mulSingle (Sigma.mk a b) x := by\n  rw [← curry_mulSingle ⟨a, b⟩, uncurry_curry]\n\n"}
{"name":"Sigma.uncurry_mulSingle_mulSingle","module":"Mathlib.Algebra.Group.Pi.Lemmas","initialProofState":"α : Type u_3\nβ : α → Type u_4\nγ : (a : α) → β a → Type u_5\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (β a)\ninst✝ : (a : α) → (b : β a) → One (γ a b)\na : α\nb : β a\nx : γ a b\n⊢ Eq (Sigma.uncurry (Pi.mulSingle a (Pi.mulSingle b x))) (Pi.mulSingle ⟨a, b⟩ x)","decl":"@[to_additive (attr := simp)]\ntheorem uncurry_mulSingle_mulSingle [DecidableEq α] [∀ a, DecidableEq (β a)] [∀ a b, One (γ a b)]\n    (a : α) (b : β a) (x : γ a b) :\n    Sigma.uncurry (Pi.mulSingle a (Pi.mulSingle b x)) = Pi.mulSingle (Sigma.mk a b) x := by\n  rw [← curry_mulSingle ⟨a, b⟩, uncurry_curry]\n\n"}
