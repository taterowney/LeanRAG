{"name":"EMetric.infEdist_empty","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\n⊢ Eq (EMetric.infEdist x EmptyCollection.emptyCollection) Top.top","decl":"@[simp]\ntheorem infEdist_empty : infEdist x ∅ = ∞ :=\n  iInf_emptyset\n\n"}
{"name":"EMetric.le_infEdist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\nd : ENNReal\n⊢ Iff (LE.le d (EMetric.infEdist x s)) (∀ (y : α), Membership.mem s y → LE.le d (EDist.edist x y))","decl":"theorem le_infEdist {d} : d ≤ infEdist x s ↔ ∀ y ∈ s, d ≤ edist x y := by\n  simp only [infEdist, le_iInf_iff]\n\n"}
{"name":"EMetric.infEdist_union","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns t : Set α\n⊢ Eq (EMetric.infEdist x (Union.union s t)) (Min.min (EMetric.infEdist x s) (EMetric.infEdist x t))","decl":"/-- The edist to a union is the minimum of the edists -/\n@[simp]\ntheorem infEdist_union : infEdist x (s ∪ t) = infEdist x s ⊓ infEdist x t :=\n  iInf_union\n\n"}
{"name":"EMetric.infEdist_iUnion","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"ι : Sort u_1\nα : Type u\ninst✝ : PseudoEMetricSpace α\nf : ι → Set α\nx : α\n⊢ Eq (EMetric.infEdist x (Set.iUnion fun i => f i)) (iInf fun i => EMetric.infEdist x (f i))","decl":"@[simp]\ntheorem infEdist_iUnion (f : ι → Set α) (x : α) : infEdist x (⋃ i, f i) = ⨅ i, infEdist x (f i) :=\n  iInf_iUnion f _\n\n"}
{"name":"EMetric.infEdist_biUnion","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nι : Type u_2\nf : ι → Set α\nI : Set ι\nx : α\n⊢ Eq (EMetric.infEdist x (Set.iUnion fun i => Set.iUnion fun h => f i)) (iInf fun i => iInf fun h => EMetric.infEdist x (f i))","decl":"lemma infEdist_biUnion {ι : Type*} (f : ι → Set α) (I : Set ι) (x : α) :\n    infEdist x (⋃ i ∈ I, f i) = ⨅ i ∈ I, infEdist x (f i) := by simp only [infEdist_iUnion]\n\n"}
{"name":"EMetric.infEdist_singleton","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\n⊢ Eq (EMetric.infEdist x (Singleton.singleton y)) (EDist.edist x y)","decl":"/-- The edist to a singleton is the edistance to the single point of this singleton -/\n@[simp]\ntheorem infEdist_singleton : infEdist x {y} = edist x y :=\n  iInf_singleton\n\n"}
{"name":"EMetric.infEdist_le_edist_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\ns : Set α\nh : Membership.mem s y\n⊢ LE.le (EMetric.infEdist x s) (EDist.edist x y)","decl":"/-- The edist to a set is bounded above by the edist to any of its points -/\ntheorem infEdist_le_edist_of_mem (h : y ∈ s) : infEdist x s ≤ edist x y :=\n  iInf₂_le y h\n\n"}
{"name":"EMetric.infEdist_zero_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\nh : Membership.mem s x\n⊢ Eq (EMetric.infEdist x s) 0","decl":"/-- If a point `x` belongs to `s`, then its edist to `s` vanishes -/\ntheorem infEdist_zero_of_mem (h : x ∈ s) : infEdist x s = 0 :=\n  nonpos_iff_eq_zero.1 <| @edist_self _ _ x ▸ infEdist_le_edist_of_mem h\n\n"}
{"name":"EMetric.infEdist_anti","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns t : Set α\nh : HasSubset.Subset s t\n⊢ LE.le (EMetric.infEdist x t) (EMetric.infEdist x s)","decl":"/-- The edist is antitone with respect to inclusion. -/\ntheorem infEdist_anti (h : s ⊆ t) : infEdist x t ≤ infEdist x s :=\n  iInf_le_iInf_of_subset h\n\n"}
{"name":"EMetric.infEdist_lt_iff","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\nr : ENNReal\n⊢ Iff (LT.lt (EMetric.infEdist x s) r) (Exists fun y => And (Membership.mem s y) (LT.lt (EDist.edist x y) r))","decl":"/-- The edist to a set is `< r` iff there exists a point in the set at edistance `< r` -/\ntheorem infEdist_lt_iff {r : ℝ≥0∞} : infEdist x s < r ↔ ∃ y ∈ s, edist x y < r := by\n  simp_rw [infEdist, iInf_lt_iff, exists_prop]\n\n"}
{"name":"EMetric.infEdist_le_infEdist_add_edist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\ns : Set α\n⊢ LE.le (EMetric.infEdist x s) (HAdd.hAdd (EMetric.infEdist y s) (EDist.edist x y))","decl":"/-- The edist of `x` to `s` is bounded by the sum of the edist of `y` to `s` and\nthe edist from `x` to `y` -/\ntheorem infEdist_le_infEdist_add_edist : infEdist x s ≤ infEdist y s + edist x y :=\n  calc\n    ⨅ z ∈ s, edist x z ≤ ⨅ z ∈ s, edist y z + edist x y :=\n      iInf₂_mono fun _ _ => (edist_triangle _ _ _).trans_eq (add_comm _ _)\n    _ = (⨅ z ∈ s, edist y z) + edist x y := by simp only [ENNReal.iInf_add]\n\n"}
{"name":"EMetric.infEdist_le_edist_add_infEdist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\ns : Set α\n⊢ LE.le (EMetric.infEdist x s) (HAdd.hAdd (EDist.edist x y) (EMetric.infEdist y s))","decl":"theorem infEdist_le_edist_add_infEdist : infEdist x s ≤ edist x y + infEdist y s := by\n  rw [add_comm]\n  exact infEdist_le_infEdist_add_edist\n\n"}
{"name":"EMetric.edist_le_infEdist_add_ediam","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx y : α\ns : Set α\nhy : Membership.mem s y\n⊢ LE.le (EDist.edist x y) (HAdd.hAdd (EMetric.infEdist x s) (EMetric.diam s))","decl":"theorem edist_le_infEdist_add_ediam (hy : y ∈ s) : edist x y ≤ infEdist x s + diam s := by\n  simp_rw [infEdist, ENNReal.iInf_add]\n  refine le_iInf₂ fun i hi => ?_\n  calc\n    edist x y ≤ edist x i + edist i y := edist_triangle _ _ _\n    _ ≤ edist x i + diam s := add_le_add le_rfl (edist_le_diam_of_mem hi hy)\n\n"}
{"name":"EMetric.continuous_infEdist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns : Set α\n⊢ Continuous fun x => EMetric.infEdist x s","decl":"/-- The edist to a set depends continuously on the point -/\n@[continuity]\ntheorem continuous_infEdist : Continuous fun x => infEdist x s :=\n  continuous_of_le_add_edist 1 (by simp) <| by\n    simp only [one_mul, infEdist_le_infEdist_add_edist, forall₂_true_iff]\n\n"}
{"name":"EMetric.infEdist_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\n⊢ Eq (EMetric.infEdist x (closure s)) (EMetric.infEdist x s)","decl":"/-- The edist to a set and to its closure coincide -/\ntheorem infEdist_closure : infEdist x (closure s) = infEdist x s := by\n  refine le_antisymm (infEdist_anti subset_closure) ?_\n  refine ENNReal.le_of_forall_pos_le_add fun ε εpos h => ?_\n  have ε0 : 0 < (ε / 2 : ℝ≥0∞) := by simpa [pos_iff_ne_zero] using εpos\n  have : infEdist x (closure s) < infEdist x (closure s) + ε / 2 :=\n    ENNReal.lt_add_right h.ne ε0.ne'\n  obtain ⟨y : α, ycs : y ∈ closure s, hy : edist x y < infEdist x (closure s) + ↑ε / 2⟩ :=\n    infEdist_lt_iff.mp this\n  obtain ⟨z : α, zs : z ∈ s, dyz : edist y z < ↑ε / 2⟩ := EMetric.mem_closure_iff.1 ycs (ε / 2) ε0\n  calc\n    infEdist x s ≤ edist x z := infEdist_le_edist_of_mem zs\n    _ ≤ edist x y + edist y z := edist_triangle _ _ _\n    _ ≤ infEdist x (closure s) + ε / 2 + ε / 2 := add_le_add (le_of_lt hy) (le_of_lt dyz)\n    _ = infEdist x (closure s) + ↑ε := by rw [add_assoc, ENNReal.add_halves]\n\n"}
{"name":"EMetric.mem_closure_iff_infEdist_zero","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\n⊢ Iff (Membership.mem (closure s) x) (Eq (EMetric.infEdist x s) 0)","decl":"/-- A point belongs to the closure of `s` iff its infimum edistance to this set vanishes -/\ntheorem mem_closure_iff_infEdist_zero : x ∈ closure s ↔ infEdist x s = 0 :=\n  ⟨fun h => by\n    rw [← infEdist_closure]\n    exact infEdist_zero_of_mem h,\n   fun h =>\n    EMetric.mem_closure_iff.2 fun ε εpos => infEdist_lt_iff.mp <| by rwa [h]⟩\n\n"}
{"name":"EMetric.mem_iff_infEdist_zero_of_closed","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\nh : IsClosed s\n⊢ Iff (Membership.mem s x) (Eq (EMetric.infEdist x s) 0)","decl":"/-- Given a closed set `s`, a point belongs to `s` iff its infimum edistance to this set vanishes -/\ntheorem mem_iff_infEdist_zero_of_closed (h : IsClosed s) : x ∈ s ↔ infEdist x s = 0 := by\n  rw [← mem_closure_iff_infEdist_zero, h.closure_eq]\n\n"}
{"name":"EMetric.infEdist_pos_iff_not_mem_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\nE : Set α\n⊢ Iff (LT.lt 0 (EMetric.infEdist x E)) (Not (Membership.mem (closure E) x))","decl":"/-- The infimum edistance of a point to a set is positive if and only if the point is not in the\nclosure of the set. -/\ntheorem infEdist_pos_iff_not_mem_closure {x : α} {E : Set α} :\n    0 < infEdist x E ↔ x ∉ closure E := by\n  rw [mem_closure_iff_infEdist_zero, pos_iff_ne_zero]\n\n"}
{"name":"EMetric.infEdist_closure_pos_iff_not_mem_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\nE : Set α\n⊢ Iff (LT.lt 0 (EMetric.infEdist x (closure E))) (Not (Membership.mem (closure E) x))","decl":"theorem infEdist_closure_pos_iff_not_mem_closure {x : α} {E : Set α} :\n    0 < infEdist x (closure E) ↔ x ∉ closure E := by\n  rw [infEdist_closure, infEdist_pos_iff_not_mem_closure]\n\n"}
{"name":"EMetric.exists_real_pos_lt_infEdist_of_not_mem_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\nE : Set α\nh : Not (Membership.mem (closure E) x)\n⊢ Exists fun ε => And (LT.lt 0 ε) (LT.lt (ENNReal.ofReal ε) (EMetric.infEdist x E))","decl":"theorem exists_real_pos_lt_infEdist_of_not_mem_closure {x : α} {E : Set α} (h : x ∉ closure E) :\n    ∃ ε : ℝ, 0 < ε ∧ ENNReal.ofReal ε < infEdist x E := by\n  rw [← infEdist_pos_iff_not_mem_closure, ENNReal.lt_iff_exists_real_btwn] at h\n  rcases h with ⟨ε, ⟨_, ⟨ε_pos, ε_lt⟩⟩⟩\n  exact ⟨ε, ⟨ENNReal.ofReal_pos.mp ε_pos, ε_lt⟩⟩\n\n"}
{"name":"EMetric.disjoint_closedBall_of_lt_infEdist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns : Set α\nr : ENNReal\nh : LT.lt r (EMetric.infEdist x s)\n⊢ Disjoint (EMetric.closedBall x r) s","decl":"theorem disjoint_closedBall_of_lt_infEdist {r : ℝ≥0∞} (h : r < infEdist x s) :\n    Disjoint (closedBall x r) s := by\n  rw [disjoint_left]\n  intro y hy h'y\n  apply lt_irrefl (infEdist x s)\n  calc\n    infEdist x s ≤ edist x y := infEdist_le_edist_of_mem h'y\n    _ ≤ r := by rwa [mem_closedBall, edist_comm] at hy\n    _ < infEdist x s := h\n\n"}
{"name":"EMetric.infEdist_image","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nx : α\nt : Set α\nΦ : α → β\nhΦ : Isometry Φ\n⊢ Eq (EMetric.infEdist (Φ x) (Set.image Φ t)) (EMetric.infEdist x t)","decl":"/-- The infimum edistance is invariant under isometries -/\ntheorem infEdist_image (hΦ : Isometry Φ) : infEdist (Φ x) (Φ '' t) = infEdist x t := by\n  simp only [infEdist, iInf_image, hΦ.edist_eq]\n\n"}
{"name":"EMetric.infEdist_smul","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝² : PseudoEMetricSpace α\nM : Type u_2\ninst✝¹ : SMul M α\ninst✝ : IsometricSMul M α\nc : M\nx : α\ns : Set α\n⊢ Eq (EMetric.infEdist (HSMul.hSMul c x) (HSMul.hSMul c s)) (EMetric.infEdist x s)","decl":"@[to_additive (attr := simp)]\ntheorem infEdist_smul {M} [SMul M α] [IsometricSMul M α] (c : M) (x : α) (s : Set α) :\n    infEdist (c • x) (c • s) = infEdist x s :=\n  infEdist_image (isometry_smul _ _)\n\n"}
{"name":"EMetric.infEdist_vadd","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝² : PseudoEMetricSpace α\nM : Type u_2\ninst✝¹ : VAdd M α\ninst✝ : IsometricVAdd M α\nc : M\nx : α\ns : Set α\n⊢ Eq (EMetric.infEdist (HVAdd.hVAdd c x) (HVAdd.hVAdd c s)) (EMetric.infEdist x s)","decl":"@[to_additive (attr := simp)]\ntheorem infEdist_smul {M} [SMul M α] [IsometricSMul M α] (c : M) (x : α) (s : Set α) :\n    infEdist (c • x) (c • s) = infEdist x s :=\n  infEdist_image (isometry_smul _ _)\n\n"}
{"name":"IsOpen.exists_iUnion_isClosed","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nU : Set α\nhU : IsOpen U\n⊢ Exists fun F => And (∀ (n : Nat), IsClosed (F n)) (And (∀ (n : Nat), HasSubset.Subset (F n) U) (And (Eq (Set.iUnion fun n => F n) U) (Monotone F)))","decl":"theorem _root_.IsOpen.exists_iUnion_isClosed {U : Set α} (hU : IsOpen U) :\n    ∃ F : ℕ → Set α, (∀ n, IsClosed (F n)) ∧ (∀ n, F n ⊆ U) ∧ ⋃ n, F n = U ∧ Monotone F := by\n  obtain ⟨a, a_pos, a_lt_one⟩ : ∃ a : ℝ≥0∞, 0 < a ∧ a < 1 := exists_between zero_lt_one\n  let F := fun n : ℕ => (fun x => infEdist x Uᶜ) ⁻¹' Ici (a ^ n)\n  have F_subset : ∀ n, F n ⊆ U := fun n x hx ↦ by\n    by_contra h\n    have : infEdist x Uᶜ ≠ 0 := ((ENNReal.pow_pos a_pos _).trans_le hx).ne'\n    exact this (infEdist_zero_of_mem h)\n  refine ⟨F, fun n => IsClosed.preimage continuous_infEdist isClosed_Ici, F_subset, ?_, ?_⟩\n  · show ⋃ n, F n = U\n    refine Subset.antisymm (by simp only [iUnion_subset_iff, F_subset, forall_const]) fun x hx => ?_\n    have : ¬x ∈ Uᶜ := by simpa using hx\n    rw [mem_iff_infEdist_zero_of_closed hU.isClosed_compl] at this\n    have B : 0 < infEdist x Uᶜ := by simpa [pos_iff_ne_zero] using this\n    have : Filter.Tendsto (fun n => a ^ n) atTop (𝓝 0) :=\n      ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one a_lt_one\n    rcases ((tendsto_order.1 this).2 _ B).exists with ⟨n, hn⟩\n    simp only [mem_iUnion, mem_Ici, mem_preimage]\n    exact ⟨n, hn.le⟩\n  show Monotone F\n  intro m n hmn x hx\n  simp only [F, mem_Ici, mem_preimage] at hx ⊢\n  apply le_trans (pow_le_pow_right_of_le_one' a_lt_one.le hmn) hx\n\n"}
{"name":"IsCompact.exists_infEdist_eq_edist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns : Set α\nhs : IsCompact s\nhne : s.Nonempty\nx : α\n⊢ Exists fun y => And (Membership.mem s y) (Eq (EMetric.infEdist x s) (EDist.edist x y))","decl":"theorem _root_.IsCompact.exists_infEdist_eq_edist (hs : IsCompact s) (hne : s.Nonempty) (x : α) :\n    ∃ y ∈ s, infEdist x s = edist x y := by\n  have A : Continuous fun y => edist x y := continuous_const.edist continuous_id\n  obtain ⟨y, ys, hy⟩ := hs.exists_isMinOn hne A.continuousOn\n  exact ⟨y, ys, le_antisymm (infEdist_le_edist_of_mem ys) (by rwa [le_infEdist])⟩\n\n"}
{"name":"EMetric.exists_pos_forall_lt_edist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns t : Set α\nhs : IsCompact s\nht : IsClosed t\nhst : Disjoint s t\n⊢ Exists fun r => And (LT.lt 0 r) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem t y → LT.lt (↑r) (EDist.edist x y))","decl":"theorem exists_pos_forall_lt_edist (hs : IsCompact s) (ht : IsClosed t) (hst : Disjoint s t) :\n    ∃ r : ℝ≥0, 0 < r ∧ ∀ x ∈ s, ∀ y ∈ t, (r : ℝ≥0∞) < edist x y := by\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  · use 1\n    simp\n  obtain ⟨x, hx, h⟩ := hs.exists_isMinOn hne continuous_infEdist.continuousOn\n  have : 0 < infEdist x t :=\n    pos_iff_ne_zero.2 fun H => hst.le_bot ⟨hx, (mem_iff_infEdist_zero_of_closed ht).mpr H⟩\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 this with ⟨r, h₀, hr⟩\n  exact ⟨r, ENNReal.coe_pos.mp h₀, fun y hy z hz => hr.trans_le <| le_infEdist.1 (h hy) z hz⟩\n\n"}
{"name":"EMetric.hausdorffEdist_def","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u_2\ninst✝ : PseudoEMetricSpace α\ns t : Set α\n⊢ Eq (EMetric.hausdorffEdist s t) (Max.max (iSup fun x => iSup fun h => EMetric.infEdist x t) (iSup fun y => iSup fun h => EMetric.infEdist y s))","decl":"/-- The Hausdorff edistance between two sets is the smallest `r` such that each set\nis contained in the `r`-neighborhood of the other one -/\nirreducible_def hausdorffEdist {α : Type u} [PseudoEMetricSpace α] (s t : Set α) : ℝ≥0∞ :=\n  (⨆ x ∈ s, infEdist x t) ⊔ ⨆ y ∈ t, infEdist y s\n\n"}
{"name":"EMetric.hausdorffEdist_self","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns : Set α\n⊢ Eq (EMetric.hausdorffEdist s s) 0","decl":"/-- The Hausdorff edistance of a set to itself vanishes. -/\n@[simp]\ntheorem hausdorffEdist_self : hausdorffEdist s s = 0 := by\n  simp only [hausdorffEdist_def, sup_idem, ENNReal.iSup_eq_zero]\n  exact fun x hx => infEdist_zero_of_mem hx\n\n"}
{"name":"EMetric.hausdorffEdist_comm","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns t : Set α\n⊢ Eq (EMetric.hausdorffEdist s t) (EMetric.hausdorffEdist t s)","decl":"/-- The Haudorff edistances of `s` to `t` and of `t` to `s` coincide. -/\ntheorem hausdorffEdist_comm : hausdorffEdist s t = hausdorffEdist t s := by\n  simp only [hausdorffEdist_def]; apply sup_comm\n\n"}
{"name":"EMetric.hausdorffEdist_le_of_infEdist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns t : Set α\nr : ENNReal\nH1 : ∀ (x : α), Membership.mem s x → LE.le (EMetric.infEdist x t) r\nH2 : ∀ (x : α), Membership.mem t x → LE.le (EMetric.infEdist x s) r\n⊢ LE.le (EMetric.hausdorffEdist s t) r","decl":"/-- Bounding the Hausdorff edistance by bounding the edistance of any point\nin each set to the other set -/\ntheorem hausdorffEdist_le_of_infEdist {r : ℝ≥0∞} (H1 : ∀ x ∈ s, infEdist x t ≤ r)\n    (H2 : ∀ x ∈ t, infEdist x s ≤ r) : hausdorffEdist s t ≤ r := by\n  simp only [hausdorffEdist_def, sup_le_iff, iSup_le_iff]\n  exact ⟨H1, H2⟩\n\n"}
{"name":"EMetric.hausdorffEdist_le_of_mem_edist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns t : Set α\nr : ENNReal\nH1 : ∀ (x : α), Membership.mem s x → Exists fun y => And (Membership.mem t y) (LE.le (EDist.edist x y) r)\nH2 : ∀ (x : α), Membership.mem t x → Exists fun y => And (Membership.mem s y) (LE.le (EDist.edist x y) r)\n⊢ LE.le (EMetric.hausdorffEdist s t) r","decl":"/-- Bounding the Hausdorff edistance by exhibiting, for any point in each set,\nanother point in the other set at controlled distance -/\ntheorem hausdorffEdist_le_of_mem_edist {r : ℝ≥0∞} (H1 : ∀ x ∈ s, ∃ y ∈ t, edist x y ≤ r)\n    (H2 : ∀ x ∈ t, ∃ y ∈ s, edist x y ≤ r) : hausdorffEdist s t ≤ r := by\n  refine hausdorffEdist_le_of_infEdist (fun x xs ↦ ?_) (fun x xt ↦ ?_)\n  · rcases H1 x xs with ⟨y, yt, hy⟩\n    exact le_trans (infEdist_le_edist_of_mem yt) hy\n  · rcases H2 x xt with ⟨y, ys, hy⟩\n    exact le_trans (infEdist_le_edist_of_mem ys) hy\n\n"}
{"name":"EMetric.infEdist_le_hausdorffEdist_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns t : Set α\nh : Membership.mem s x\n⊢ LE.le (EMetric.infEdist x t) (EMetric.hausdorffEdist s t)","decl":"/-- The distance to a set is controlled by the Hausdorff distance. -/\ntheorem infEdist_le_hausdorffEdist_of_mem (h : x ∈ s) : infEdist x t ≤ hausdorffEdist s t := by\n  rw [hausdorffEdist_def]\n  refine le_trans ?_ le_sup_left\n  exact le_iSup₂ (α := ℝ≥0∞) x h\n\n"}
{"name":"EMetric.exists_edist_lt_of_hausdorffEdist_lt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns t : Set α\nr : ENNReal\nh : Membership.mem s x\nH : LT.lt (EMetric.hausdorffEdist s t) r\n⊢ Exists fun y => And (Membership.mem t y) (LT.lt (EDist.edist x y) r)","decl":"/-- If the Hausdorff distance is `< r`, then any point in one of the sets has\na corresponding point at distance `< r` in the other set. -/\ntheorem exists_edist_lt_of_hausdorffEdist_lt {r : ℝ≥0∞} (h : x ∈ s) (H : hausdorffEdist s t < r) :\n    ∃ y ∈ t, edist x y < r :=\n  infEdist_lt_iff.mp <|\n    calc\n      infEdist x t ≤ hausdorffEdist s t := infEdist_le_hausdorffEdist_of_mem h\n      _ < r := H\n\n"}
{"name":"EMetric.infEdist_le_infEdist_add_hausdorffEdist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nx : α\ns t : Set α\n⊢ LE.le (EMetric.infEdist x t) (HAdd.hAdd (EMetric.infEdist x s) (EMetric.hausdorffEdist s t))","decl":"/-- The distance from `x` to `s` or `t` is controlled in terms of the Hausdorff distance\nbetween `s` and `t`. -/\ntheorem infEdist_le_infEdist_add_hausdorffEdist :\n    infEdist x t ≤ infEdist x s + hausdorffEdist s t :=\n  ENNReal.le_of_forall_pos_le_add fun ε εpos h => by\n    have ε0 : (ε / 2 : ℝ≥0∞) ≠ 0 := by simpa [pos_iff_ne_zero] using εpos\n    have : infEdist x s < infEdist x s + ε / 2 :=\n      ENNReal.lt_add_right (ENNReal.add_lt_top.1 h).1.ne ε0\n    obtain ⟨y : α, ys : y ∈ s, dxy : edist x y < infEdist x s + ↑ε / 2⟩ := infEdist_lt_iff.mp this\n    have : hausdorffEdist s t < hausdorffEdist s t + ε / 2 :=\n      ENNReal.lt_add_right (ENNReal.add_lt_top.1 h).2.ne ε0\n    obtain ⟨z : α, zt : z ∈ t, dyz : edist y z < hausdorffEdist s t + ↑ε / 2⟩ :=\n      exists_edist_lt_of_hausdorffEdist_lt ys this\n    calc\n      infEdist x t ≤ edist x z := infEdist_le_edist_of_mem zt\n      _ ≤ edist x y + edist y z := edist_triangle _ _ _\n      _ ≤ infEdist x s + ε / 2 + (hausdorffEdist s t + ε / 2) := add_le_add dxy.le dyz.le\n      _ = infEdist x s + hausdorffEdist s t + ε := by\n        simp [ENNReal.add_halves, add_comm, add_left_comm]\n\n"}
{"name":"EMetric.hausdorffEdist_image","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\ns t : Set α\nΦ : α → β\nh : Isometry Φ\n⊢ Eq (EMetric.hausdorffEdist (Set.image Φ s) (Set.image Φ t)) (EMetric.hausdorffEdist s t)","decl":"/-- The Hausdorff edistance is invariant under isometries. -/\ntheorem hausdorffEdist_image (h : Isometry Φ) :\n    hausdorffEdist (Φ '' s) (Φ '' t) = hausdorffEdist s t := by\n  simp only [hausdorffEdist_def, iSup_image, infEdist_image h]\n\n"}
{"name":"EMetric.hausdorffEdist_le_ediam","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns t : Set α\nhs : s.Nonempty\nht : t.Nonempty\n⊢ LE.le (EMetric.hausdorffEdist s t) (EMetric.diam (Union.union s t))","decl":"/-- The Hausdorff distance is controlled by the diameter of the union. -/\ntheorem hausdorffEdist_le_ediam (hs : s.Nonempty) (ht : t.Nonempty) :\n    hausdorffEdist s t ≤ diam (s ∪ t) := by\n  rcases hs with ⟨x, xs⟩\n  rcases ht with ⟨y, yt⟩\n  refine hausdorffEdist_le_of_mem_edist ?_ ?_\n  · intro z hz\n    exact ⟨y, yt, edist_le_diam_of_mem (subset_union_left hz) (subset_union_right yt)⟩\n  · intro z hz\n    exact ⟨x, xs, edist_le_diam_of_mem (subset_union_right hz) (subset_union_left xs)⟩\n\n"}
{"name":"EMetric.hausdorffEdist_triangle","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns t u : Set α\n⊢ LE.le (EMetric.hausdorffEdist s u) (HAdd.hAdd (EMetric.hausdorffEdist s t) (EMetric.hausdorffEdist t u))","decl":"/-- The Hausdorff distance satisfies the triangle inequality. -/\ntheorem hausdorffEdist_triangle : hausdorffEdist s u ≤ hausdorffEdist s t + hausdorffEdist t u := by\n  rw [hausdorffEdist_def]\n  simp only [sup_le_iff, iSup_le_iff]\n  constructor\n  · show ∀ x ∈ s, infEdist x u ≤ hausdorffEdist s t + hausdorffEdist t u\n    exact fun x xs =>\n      calc\n        infEdist x u ≤ infEdist x t + hausdorffEdist t u :=\n          infEdist_le_infEdist_add_hausdorffEdist\n        _ ≤ hausdorffEdist s t + hausdorffEdist t u :=\n          add_le_add_right (infEdist_le_hausdorffEdist_of_mem xs) _\n  · show ∀ x ∈ u, infEdist x s ≤ hausdorffEdist s t + hausdorffEdist t u\n    exact fun x xu =>\n      calc\n        infEdist x s ≤ infEdist x t + hausdorffEdist t s :=\n          infEdist_le_infEdist_add_hausdorffEdist\n        _ ≤ hausdorffEdist u t + hausdorffEdist t s :=\n          add_le_add_right (infEdist_le_hausdorffEdist_of_mem xu) _\n        _ = hausdorffEdist s t + hausdorffEdist t u := by simp [hausdorffEdist_comm, add_comm]\n\n"}
{"name":"EMetric.hausdorffEdist_zero_iff_closure_eq_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns t : Set α\n⊢ Iff (Eq (EMetric.hausdorffEdist s t) 0) (Eq (closure s) (closure t))","decl":"/-- Two sets are at zero Hausdorff edistance if and only if they have the same closure. -/\ntheorem hausdorffEdist_zero_iff_closure_eq_closure :\n    hausdorffEdist s t = 0 ↔ closure s = closure t := by\n  simp only [hausdorffEdist_def, ENNReal.sup_eq_zero, ENNReal.iSup_eq_zero, ← subset_def,\n    ← mem_closure_iff_infEdist_zero, subset_antisymm_iff, isClosed_closure.closure_subset_iff]\n\n"}
{"name":"EMetric.hausdorffEdist_self_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns : Set α\n⊢ Eq (EMetric.hausdorffEdist s (closure s)) 0","decl":"/-- The Hausdorff edistance between a set and its closure vanishes. -/\n@[simp]\ntheorem hausdorffEdist_self_closure : hausdorffEdist s (closure s) = 0 := by\n  rw [hausdorffEdist_zero_iff_closure_eq_closure, closure_closure]\n\n"}
{"name":"EMetric.hausdorffEdist_closure₁","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns t : Set α\n⊢ Eq (EMetric.hausdorffEdist (closure s) t) (EMetric.hausdorffEdist s t)","decl":"/-- Replacing a set by its closure does not change the Hausdorff edistance. -/\n@[simp]\ntheorem hausdorffEdist_closure₁ : hausdorffEdist (closure s) t = hausdorffEdist s t := by\n  refine le_antisymm ?_ ?_\n  · calc\n      _ ≤ hausdorffEdist (closure s) s + hausdorffEdist s t := hausdorffEdist_triangle\n      _ = hausdorffEdist s t := by simp [hausdorffEdist_comm]\n  · calc\n      _ ≤ hausdorffEdist s (closure s) + hausdorffEdist (closure s) t := hausdorffEdist_triangle\n      _ = hausdorffEdist (closure s) t := by simp\n\n"}
{"name":"EMetric.hausdorffEdist_closure₂","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns t : Set α\n⊢ Eq (EMetric.hausdorffEdist s (closure t)) (EMetric.hausdorffEdist s t)","decl":"/-- Replacing a set by its closure does not change the Hausdorff edistance. -/\n@[simp]\ntheorem hausdorffEdist_closure₂ : hausdorffEdist s (closure t) = hausdorffEdist s t := by\n  simp [@hausdorffEdist_comm _ _ s _]\n\n"}
{"name":"EMetric.hausdorffEdist_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns t : Set α\n⊢ Eq (EMetric.hausdorffEdist (closure s) (closure t)) (EMetric.hausdorffEdist s t)","decl":"/-- The Hausdorff edistance between sets or their closures is the same. -/\ntheorem hausdorffEdist_closure : hausdorffEdist (closure s) (closure t) = hausdorffEdist s t := by\n  simp\n\n"}
{"name":"EMetric.hausdorffEdist_zero_iff_eq_of_closed","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns t : Set α\nhs : IsClosed s\nht : IsClosed t\n⊢ Iff (Eq (EMetric.hausdorffEdist s t) 0) (Eq s t)","decl":"/-- Two closed sets are at zero Hausdorff edistance if and only if they coincide. -/\ntheorem hausdorffEdist_zero_iff_eq_of_closed (hs : IsClosed s) (ht : IsClosed t) :\n    hausdorffEdist s t = 0 ↔ s = t := by\n  rw [hausdorffEdist_zero_iff_closure_eq_closure, hs.closure_eq, ht.closure_eq]\n\n"}
{"name":"EMetric.hausdorffEdist_empty","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns : Set α\nne : s.Nonempty\n⊢ Eq (EMetric.hausdorffEdist s EmptyCollection.emptyCollection) Top.top","decl":"/-- The Haudorff edistance to the empty set is infinite. -/\ntheorem hausdorffEdist_empty (ne : s.Nonempty) : hausdorffEdist s ∅ = ∞ := by\n  rcases ne with ⟨x, xs⟩\n  have : infEdist x ∅ ≤ hausdorffEdist s ∅ := infEdist_le_hausdorffEdist_of_mem xs\n  simpa using this\n\n"}
{"name":"EMetric.nonempty_of_hausdorffEdist_ne_top","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns t : Set α\nhs : s.Nonempty\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n⊢ t.Nonempty","decl":"/-- If a set is at finite Hausdorff edistance of a nonempty set, it is nonempty. -/\ntheorem nonempty_of_hausdorffEdist_ne_top (hs : s.Nonempty) (fin : hausdorffEdist s t ≠ ⊤) :\n    t.Nonempty :=\n  t.eq_empty_or_nonempty.resolve_left fun ht ↦ fin (ht.symm ▸ hausdorffEdist_empty hs)\n\n"}
{"name":"EMetric.empty_or_nonempty_of_hausdorffEdist_ne_top","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\ns t : Set α\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n⊢ Or (And (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection)) (And s.Nonempty t.Nonempty)","decl":"theorem empty_or_nonempty_of_hausdorffEdist_ne_top (fin : hausdorffEdist s t ≠ ⊤) :\n    (s = ∅ ∧ t = ∅) ∨ (s.Nonempty ∧ t.Nonempty) := by\n  rcases s.eq_empty_or_nonempty with hs | hs\n  · rcases t.eq_empty_or_nonempty with ht | ht\n    · exact Or.inl ⟨hs, ht⟩\n    · rw [hausdorffEdist_comm] at fin\n      exact Or.inr ⟨nonempty_of_hausdorffEdist_ne_top ht fin, ht⟩\n  · exact Or.inr ⟨hs, nonempty_of_hausdorffEdist_ne_top hs fin⟩\n\n"}
{"name":"Metric.infDist_eq_iInf","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\n⊢ Eq (Metric.infDist x s) (iInf fun y => Dist.dist x ↑y)","decl":"theorem infDist_eq_iInf : infDist x s = ⨅ y : s, dist x y := by\n  rw [infDist, infEdist, iInf_subtype', ENNReal.toReal_iInf]\n  · simp only [dist_edist]\n  · exact fun _ ↦ edist_ne_top _ _\n\n"}
{"name":"Metric.infDist_nonneg","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\n⊢ LE.le 0 (Metric.infDist x s)","decl":"/-- The minimal distance is always nonnegative -/\ntheorem infDist_nonneg : 0 ≤ infDist x s := toReal_nonneg\n\n"}
{"name":"Metric.infDist_empty","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ Eq (Metric.infDist x EmptyCollection.emptyCollection) 0","decl":"/-- The minimal distance to the empty set is 0 (if you want to have the more reasonable\nvalue `∞` instead, use `EMetric.infEdist`, which takes values in `ℝ≥0∞`) -/\n@[simp]\ntheorem infDist_empty : infDist x ∅ = 0 := by simp [infDist]\n\n"}
{"name":"Metric.infEdist_ne_top","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\nh : s.Nonempty\n⊢ Ne (EMetric.infEdist x s) Top.top","decl":"/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem infEdist_ne_top (h : s.Nonempty) : infEdist x s ≠ ⊤ := by\n  rcases h with ⟨y, hy⟩\n  exact ne_top_of_le_ne_top (edist_ne_top _ _) (infEdist_le_edist_of_mem hy)\n\n"}
{"name":"Metric.infEdist_eq_top_iff","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\n⊢ Iff (Eq (EMetric.infEdist x s) Top.top) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem infEdist_eq_top_iff : infEdist x s = ∞ ↔ s = ∅ := by\n  rcases s.eq_empty_or_nonempty with rfl | hs <;> simp [*, Nonempty.ne_empty, infEdist_ne_top]\n\n"}
{"name":"Metric.infDist_zero_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\nh : Membership.mem s x\n⊢ Eq (Metric.infDist x s) 0","decl":"/-- The minimal distance of a point to a set containing it vanishes. -/\ntheorem infDist_zero_of_mem (h : x ∈ s) : infDist x s = 0 := by\n  simp [infEdist_zero_of_mem h, infDist]\n\n"}
{"name":"Metric.infDist_singleton","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Eq (Metric.infDist x (Singleton.singleton y)) (Dist.dist x y)","decl":"/-- The minimal distance to a singleton is the distance to the unique point in this singleton. -/\n@[simp]\ntheorem infDist_singleton : infDist x {y} = dist x y := by simp [infDist, dist_edist]\n\n"}
{"name":"Metric.infDist_le_dist_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx y : α\nh : Membership.mem s y\n⊢ LE.le (Metric.infDist x s) (Dist.dist x y)","decl":"/-- The minimal distance to a set is bounded by the distance to any point in this set. -/\ntheorem infDist_le_dist_of_mem (h : y ∈ s) : infDist x s ≤ dist x y := by\n  rw [dist_edist, infDist]\n  exact ENNReal.toReal_mono (edist_ne_top _ _) (infEdist_le_edist_of_mem h)\n\n"}
{"name":"Metric.infDist_le_infDist_of_subset","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\nx : α\nh : HasSubset.Subset s t\nhs : s.Nonempty\n⊢ LE.le (Metric.infDist x t) (Metric.infDist x s)","decl":"/-- The minimal distance is monotone with respect to inclusion. -/\ntheorem infDist_le_infDist_of_subset (h : s ⊆ t) (hs : s.Nonempty) : infDist x t ≤ infDist x s :=\n  ENNReal.toReal_mono (infEdist_ne_top hs) (infEdist_anti h)\n\n"}
{"name":"Metric.infDist_lt_iff","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\nr : Real\nhs : s.Nonempty\n⊢ Iff (LT.lt (Metric.infDist x s) r) (Exists fun y => And (Membership.mem s y) (LT.lt (Dist.dist x y) r))","decl":"/-- The minimal distance to a set `s` is `< r` iff there exists a point in `s` at distance `< r`. -/\ntheorem infDist_lt_iff {r : ℝ} (hs : s.Nonempty) : infDist x s < r ↔ ∃ y ∈ s, dist x y < r := by\n  simp_rw [infDist, ← ENNReal.lt_ofReal_iff_toReal_lt (infEdist_ne_top hs), infEdist_lt_iff,\n    ENNReal.lt_ofReal_iff_toReal_lt (edist_ne_top _ _), ← dist_edist]\n\n"}
{"name":"Metric.infDist_le_infDist_add_dist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx y : α\n⊢ LE.le (Metric.infDist x s) (HAdd.hAdd (Metric.infDist y s) (Dist.dist x y))","decl":"/-- The minimal distance from `x` to `s` is bounded by the distance from `y` to `s`, modulo\nthe distance between `x` and `y`. -/\ntheorem infDist_le_infDist_add_dist : infDist x s ≤ infDist y s + dist x y := by\n  rw [infDist, infDist, dist_edist]\n  refine ENNReal.toReal_le_add' infEdist_le_infEdist_add_edist ?_ (flip absurd (edist_ne_top _ _))\n  simp only [infEdist_eq_top_iff, imp_self]\n\n"}
{"name":"Metric.not_mem_of_dist_lt_infDist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx y : α\nh : LT.lt (Dist.dist x y) (Metric.infDist x s)\n⊢ Not (Membership.mem s y)","decl":"theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ∉ s := fun hy =>\n  h.not_le <| infDist_le_dist_of_mem hy\n\n"}
{"name":"Metric.disjoint_ball_infDist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\n⊢ Disjoint (Metric.ball x (Metric.infDist x s)) s","decl":"theorem disjoint_ball_infDist : Disjoint (ball x (infDist x s)) s :=\n  disjoint_left.2 fun _y hy => not_mem_of_dist_lt_infDist <| mem_ball'.1 hy\n\n"}
{"name":"Metric.ball_infDist_subset_compl","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\n⊢ HasSubset.Subset (Metric.ball x (Metric.infDist x s)) (HasCompl.compl s)","decl":"theorem ball_infDist_subset_compl : ball x (infDist x s) ⊆ sᶜ :=\n  (disjoint_ball_infDist (s := s)).subset_compl_right\n\n"}
{"name":"Metric.ball_infDist_compl_subset","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\n⊢ HasSubset.Subset (Metric.ball x (Metric.infDist x (HasCompl.compl s))) s","decl":"theorem ball_infDist_compl_subset : ball x (infDist x sᶜ) ⊆ s :=\n  ball_infDist_subset_compl.trans_eq (compl_compl s)\n\n"}
{"name":"Metric.disjoint_closedBall_of_lt_infDist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\nr : Real\nh : LT.lt r (Metric.infDist x s)\n⊢ Disjoint (Metric.closedBall x r) s","decl":"theorem disjoint_closedBall_of_lt_infDist {r : ℝ} (h : r < infDist x s) :\n    Disjoint (closedBall x r) s :=\n  disjoint_ball_infDist.mono_left <| closedBall_subset_ball h\n\n"}
{"name":"Metric.dist_le_infDist_add_diam","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx y : α\nhs : Bornology.IsBounded s\nhy : Membership.mem s y\n⊢ LE.le (Dist.dist x y) (HAdd.hAdd (Metric.infDist x s) (Metric.diam s))","decl":"theorem dist_le_infDist_add_diam (hs : IsBounded s) (hy : y ∈ s) :\n    dist x y ≤ infDist x s + diam s := by\n  rw [infDist, diam, dist_edist]\n  exact toReal_le_add (edist_le_infEdist_add_ediam hy) (infEdist_ne_top ⟨y, hy⟩) hs.ediam_ne_top\n\n"}
{"name":"Metric.lipschitz_infDist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ LipschitzWith 1 fun x => Metric.infDist x s","decl":"/-- The minimal distance to a set is Lipschitz in point with constant 1 -/\ntheorem lipschitz_infDist_pt : LipschitzWith 1 (infDist · s) :=\n  LipschitzWith.of_le_add fun _ _ => infDist_le_infDist_add_dist\n\n"}
{"name":"Metric.uniformContinuous_infDist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ UniformContinuous fun x => Metric.infDist x s","decl":"/-- The minimal distance to a set is uniformly continuous in point -/\ntheorem uniformContinuous_infDist_pt : UniformContinuous (infDist · s) :=\n  (lipschitz_infDist_pt s).uniformContinuous\n\n"}
{"name":"Metric.continuous_infDist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Continuous fun x => Metric.infDist x s","decl":"/-- The minimal distance to a set is continuous in point -/\n@[continuity]\ntheorem continuous_infDist_pt : Continuous (infDist · s) :=\n  (uniformContinuous_infDist_pt s).continuous\n\n"}
{"name":"Metric.infDist_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\n⊢ Eq (Metric.infDist x (closure s)) (Metric.infDist x s)","decl":"/-- The minimal distances to a set and its closure coincide. -/\ntheorem infDist_closure : infDist x (closure s) = infDist x s := by\n  simp [infDist, infEdist_closure]\n\n"}
{"name":"Metric.infDist_zero_of_mem_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\nhx : Membership.mem (closure s) x\n⊢ Eq (Metric.infDist x s) 0","decl":"/-- If a point belongs to the closure of `s`, then its infimum distance to `s` equals zero.\nThe converse is true provided that `s` is nonempty, see `Metric.mem_closure_iff_infDist_zero`. -/\ntheorem infDist_zero_of_mem_closure (hx : x ∈ closure s) : infDist x s = 0 := by\n  rw [← infDist_closure]\n  exact infDist_zero_of_mem hx\n\n"}
{"name":"Metric.mem_closure_iff_infDist_zero","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\nh : s.Nonempty\n⊢ Iff (Membership.mem (closure s) x) (Eq (Metric.infDist x s) 0)","decl":"/-- A point belongs to the closure of `s` iff its infimum distance to this set vanishes. -/\ntheorem mem_closure_iff_infDist_zero (h : s.Nonempty) : x ∈ closure s ↔ infDist x s = 0 := by\n  simp [mem_closure_iff_infEdist_zero, infDist, ENNReal.toReal_eq_zero_iff, infEdist_ne_top h]\n\n"}
{"name":"Metric.infDist_pos_iff_not_mem_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\nhs : s.Nonempty\n⊢ Iff (Not (Membership.mem (closure s) x)) (LT.lt 0 (Metric.infDist x s))","decl":"theorem infDist_pos_iff_not_mem_closure (hs : s.Nonempty) :\n    x ∉ closure s ↔ 0 < infDist x s :=\n  (mem_closure_iff_infDist_zero hs).not.trans infDist_nonneg.gt_iff_ne.symm\n\n"}
{"name":"IsClosed.mem_iff_infDist_zero","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\nh : IsClosed s\nhs : s.Nonempty\n⊢ Iff (Membership.mem s x) (Eq (Metric.infDist x s) 0)","decl":"/-- Given a closed set `s`, a point belongs to `s` iff its infimum distance to this set vanishes -/\ntheorem _root_.IsClosed.mem_iff_infDist_zero (h : IsClosed s) (hs : s.Nonempty) :\n    x ∈ s ↔ infDist x s = 0 := by rw [← mem_closure_iff_infDist_zero hs, h.closure_eq]\n\n"}
{"name":"IsClosed.not_mem_iff_infDist_pos","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\nh : IsClosed s\nhs : s.Nonempty\n⊢ Iff (Not (Membership.mem s x)) (LT.lt 0 (Metric.infDist x s))","decl":"/-- Given a closed set `s`, a point belongs to `s` iff its infimum distance to this set vanishes. -/\ntheorem _root_.IsClosed.not_mem_iff_infDist_pos (h : IsClosed s) (hs : s.Nonempty) :\n    x ∉ s ↔ 0 < infDist x s := by\n  simp [h.mem_iff_infDist_zero hs, infDist_nonneg.gt_iff_ne]\n\n"}
{"name":"Metric.continuousAt_inv_infDist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\nh : Not (Membership.mem (closure s) x)\n⊢ ContinuousAt (fun x => Inv.inv (Metric.infDist x s)) x","decl":"theorem continuousAt_inv_infDist_pt (h : x ∉ closure s) :\n    ContinuousAt (fun x ↦ (infDist x s)⁻¹) x := by\n  rcases s.eq_empty_or_nonempty with (rfl | hs)\n  · simp only [infDist_empty, continuousAt_const]\n  · refine (continuous_infDist_pt s).continuousAt.inv₀ ?_\n    rwa [Ne, ← mem_closure_iff_infDist_zero hs]\n\n"}
{"name":"Metric.infDist_image","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nt : Set α\nx : α\nΦ : α → β\nhΦ : Isometry Φ\n⊢ Eq (Metric.infDist (Φ x) (Set.image Φ t)) (Metric.infDist x t)","decl":"/-- The infimum distance is invariant under isometries. -/\ntheorem infDist_image (hΦ : Isometry Φ) : infDist (Φ x) (Φ '' t) = infDist x t := by\n  simp [infDist, infEdist_image hΦ]\n\n"}
{"name":"Metric.infDist_inter_closedBall_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx y : α\nh : Membership.mem s y\n⊢ Eq (Metric.infDist x (Inter.inter s (Metric.closedBall x (Dist.dist y x)))) (Metric.infDist x s)","decl":"theorem infDist_inter_closedBall_of_mem (h : y ∈ s) :\n    infDist x (s ∩ closedBall x (dist y x)) = infDist x s := by\n  replace h : y ∈ s ∩ closedBall x (dist y x) := ⟨h, mem_closedBall.2 le_rfl⟩\n  refine le_antisymm ?_ (infDist_le_infDist_of_subset inter_subset_left ⟨y, h⟩)\n  refine not_lt.1 fun hlt => ?_\n  rcases (infDist_lt_iff ⟨y, h.1⟩).mp hlt with ⟨z, hzs, hz⟩\n  rcases le_or_lt (dist z x) (dist y x) with hle | hlt\n  · exact hz.not_le (infDist_le_dist_of_mem ⟨hzs, hle⟩)\n  · rw [dist_comm z, dist_comm y] at hlt\n    exact (hlt.trans hz).not_le (infDist_le_dist_of_mem h)\n\n"}
{"name":"IsCompact.exists_infDist_eq_dist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nh : IsCompact s\nhne : s.Nonempty\nx : α\n⊢ Exists fun y => And (Membership.mem s y) (Eq (Metric.infDist x s) (Dist.dist x y))","decl":"theorem _root_.IsCompact.exists_infDist_eq_dist (h : IsCompact s) (hne : s.Nonempty) (x : α) :\n    ∃ y ∈ s, infDist x s = dist x y :=\n  let ⟨y, hys, hy⟩ := h.exists_infEdist_eq_edist hne x\n  ⟨y, hys, by rw [infDist, dist_edist, hy]⟩\n\n"}
{"name":"IsClosed.exists_infDist_eq_dist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : ProperSpace α\nh : IsClosed s\nhne : s.Nonempty\nx : α\n⊢ Exists fun y => And (Membership.mem s y) (Eq (Metric.infDist x s) (Dist.dist x y))","decl":"theorem _root_.IsClosed.exists_infDist_eq_dist [ProperSpace α] (h : IsClosed s) (hne : s.Nonempty)\n    (x : α) : ∃ y ∈ s, infDist x s = dist x y := by\n  rcases hne with ⟨z, hz⟩\n  rw [← infDist_inter_closedBall_of_mem hz]\n  set t := s ∩ closedBall x (dist z x)\n  have htc : IsCompact t := (isCompact_closedBall x (dist z x)).inter_left h\n  have htne : t.Nonempty := ⟨z, hz, mem_closedBall.2 le_rfl⟩\n  obtain ⟨y, ⟨hys, -⟩, hyd⟩ : ∃ y ∈ t, infDist x t = dist x y := htc.exists_infDist_eq_dist htne x\n  exact ⟨y, hys, hyd⟩\n\n"}
{"name":"Metric.exists_mem_closure_infDist_eq_dist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : ProperSpace α\nhne : s.Nonempty\nx : α\n⊢ Exists fun y => And (Membership.mem (closure s) y) (Eq (Metric.infDist x s) (Dist.dist x y))","decl":"theorem exists_mem_closure_infDist_eq_dist [ProperSpace α] (hne : s.Nonempty) (x : α) :\n    ∃ y ∈ closure s, infDist x s = dist x y := by\n  simpa only [infDist_closure] using isClosed_closure.exists_infDist_eq_dist hne.closure x\n\n"}
{"name":"Metric.coe_infNndist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\n⊢ Eq (↑(Metric.infNndist x s)) (Metric.infDist x s)","decl":"@[simp]\ntheorem coe_infNndist : (infNndist x s : ℝ) = infDist x s :=\n  rfl\n\n"}
{"name":"Metric.lipschitz_infNndist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ LipschitzWith 1 fun x => Metric.infNndist x s","decl":"/-- The minimal distance to a set (as `ℝ≥0`) is Lipschitz in point with constant 1 -/\ntheorem lipschitz_infNndist_pt (s : Set α) : LipschitzWith 1 fun x => infNndist x s :=\n  LipschitzWith.of_le_add fun _ _ => infDist_le_infDist_add_dist\n\n"}
{"name":"Metric.uniformContinuous_infNndist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ UniformContinuous fun x => Metric.infNndist x s","decl":"/-- The minimal distance to a set (as `ℝ≥0`) is uniformly continuous in point -/\ntheorem uniformContinuous_infNndist_pt (s : Set α) : UniformContinuous fun x => infNndist x s :=\n  (lipschitz_infNndist_pt s).uniformContinuous\n\n"}
{"name":"Metric.continuous_infNndist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Continuous fun x => Metric.infNndist x s","decl":"/-- The minimal distance to a set (as `ℝ≥0`) is continuous in point -/\ntheorem continuous_infNndist_pt (s : Set α) : Continuous fun x => infNndist x s :=\n  (uniformContinuous_infNndist_pt s).continuous\n\n"}
{"name":"Metric.hausdorffDist_nonneg","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\n⊢ LE.le 0 (Metric.hausdorffDist s t)","decl":"/-- The Hausdorff distance is nonnegative. -/\ntheorem hausdorffDist_nonneg : 0 ≤ hausdorffDist s t := by simp [hausdorffDist]\n\n"}
{"name":"Metric.hausdorffEdist_ne_top_of_nonempty_of_bounded","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\nhs : s.Nonempty\nht : t.Nonempty\nbs : Bornology.IsBounded s\nbt : Bornology.IsBounded t\n⊢ Ne (EMetric.hausdorffEdist s t) Top.top","decl":"/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem hausdorffEdist_ne_top_of_nonempty_of_bounded (hs : s.Nonempty) (ht : t.Nonempty)\n    (bs : IsBounded s) (bt : IsBounded t) : hausdorffEdist s t ≠ ⊤ := by\n  rcases hs with ⟨cs, hcs⟩\n  rcases ht with ⟨ct, hct⟩\n  rcases bs.subset_closedBall ct with ⟨rs, hrs⟩\n  rcases bt.subset_closedBall cs with ⟨rt, hrt⟩\n  have : hausdorffEdist s t ≤ ENNReal.ofReal (max rs rt) := by\n    apply hausdorffEdist_le_of_mem_edist\n    · intro x xs\n      exists ct, hct\n      have : dist x ct ≤ max rs rt := le_trans (hrs xs) (le_max_left _ _)\n      rwa [edist_dist, ENNReal.ofReal_le_ofReal_iff]\n      exact le_trans dist_nonneg this\n    · intro x xt\n      exists cs, hcs\n      have : dist x cs ≤ max rs rt := le_trans (hrt xt) (le_max_right _ _)\n      rwa [edist_dist, ENNReal.ofReal_le_ofReal_iff]\n      exact le_trans dist_nonneg this\n  exact ne_top_of_le_ne_top ENNReal.ofReal_ne_top this\n\n"}
{"name":"Metric.hausdorffDist_self_zero","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Eq (Metric.hausdorffDist s s) 0","decl":"/-- The Hausdorff distance between a set and itself is zero. -/\n@[simp]\ntheorem hausdorffDist_self_zero : hausdorffDist s s = 0 := by simp [hausdorffDist]\n\n"}
{"name":"Metric.hausdorffDist_comm","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\n⊢ Eq (Metric.hausdorffDist s t) (Metric.hausdorffDist t s)","decl":"/-- The Hausdorff distances from `s` to `t` and from `t` to `s` coincide. -/\ntheorem hausdorffDist_comm : hausdorffDist s t = hausdorffDist t s := by\n  simp [hausdorffDist, hausdorffEdist_comm]\n\n"}
{"name":"Metric.hausdorffDist_empty","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Eq (Metric.hausdorffDist s EmptyCollection.emptyCollection) 0","decl":"/-- The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable\nvalue `∞` instead, use `EMetric.hausdorffEdist`, which takes values in `ℝ≥0∞`). -/\n@[simp]\ntheorem hausdorffDist_empty : hausdorffDist s ∅ = 0 := by\n  rcases s.eq_empty_or_nonempty with h | h\n  · simp [h]\n  · simp [hausdorffDist, hausdorffEdist_empty h]\n\n"}
{"name":"Metric.hausdorffDist_empty'","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Eq (Metric.hausdorffDist EmptyCollection.emptyCollection s) 0","decl":"/-- The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable\nvalue `∞` instead, use `EMetric.hausdorffEdist`, which takes values in `ℝ≥0∞`). -/\n@[simp]\ntheorem hausdorffDist_empty' : hausdorffDist ∅ s = 0 := by simp [hausdorffDist_comm]\n\n"}
{"name":"Metric.hausdorffDist_le_of_infDist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\nr : Real\nhr : LE.le 0 r\nH1 : ∀ (x : α), Membership.mem s x → LE.le (Metric.infDist x t) r\nH2 : ∀ (x : α), Membership.mem t x → LE.le (Metric.infDist x s) r\n⊢ LE.le (Metric.hausdorffDist s t) r","decl":"/-- Bounding the Hausdorff distance by bounding the distance of any point\nin each set to the other set -/\ntheorem hausdorffDist_le_of_infDist {r : ℝ} (hr : 0 ≤ r) (H1 : ∀ x ∈ s, infDist x t ≤ r)\n    (H2 : ∀ x ∈ t, infDist x s ≤ r) : hausdorffDist s t ≤ r := by\n  rcases s.eq_empty_or_nonempty with hs | hs\n  · rwa [hs, hausdorffDist_empty']\n  rcases t.eq_empty_or_nonempty with ht | ht\n  · rwa [ht, hausdorffDist_empty]\n  have : hausdorffEdist s t ≤ ENNReal.ofReal r := by\n    apply hausdorffEdist_le_of_infEdist _ _\n    · simpa only [infDist, ← ENNReal.le_ofReal_iff_toReal_le (infEdist_ne_top ht) hr] using H1\n    · simpa only [infDist, ← ENNReal.le_ofReal_iff_toReal_le (infEdist_ne_top hs) hr] using H2\n  exact ENNReal.toReal_le_of_le_ofReal hr this\n\n"}
{"name":"Metric.hausdorffDist_le_of_mem_dist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\nr : Real\nhr : LE.le 0 r\nH1 : ∀ (x : α), Membership.mem s x → Exists fun y => And (Membership.mem t y) (LE.le (Dist.dist x y) r)\nH2 : ∀ (x : α), Membership.mem t x → Exists fun y => And (Membership.mem s y) (LE.le (Dist.dist x y) r)\n⊢ LE.le (Metric.hausdorffDist s t) r","decl":"/-- Bounding the Hausdorff distance by exhibiting, for any point in each set,\nanother point in the other set at controlled distance -/\ntheorem hausdorffDist_le_of_mem_dist {r : ℝ} (hr : 0 ≤ r) (H1 : ∀ x ∈ s, ∃ y ∈ t, dist x y ≤ r)\n    (H2 : ∀ x ∈ t, ∃ y ∈ s, dist x y ≤ r) : hausdorffDist s t ≤ r := by\n  apply hausdorffDist_le_of_infDist hr\n  · intro x xs\n    rcases H1 x xs with ⟨y, yt, hy⟩\n    exact le_trans (infDist_le_dist_of_mem yt) hy\n  · intro x xt\n    rcases H2 x xt with ⟨y, ys, hy⟩\n    exact le_trans (infDist_le_dist_of_mem ys) hy\n\n"}
{"name":"Metric.hausdorffDist_le_diam","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\nhs : s.Nonempty\nbs : Bornology.IsBounded s\nht : t.Nonempty\nbt : Bornology.IsBounded t\n⊢ LE.le (Metric.hausdorffDist s t) (Metric.diam (Union.union s t))","decl":"/-- The Hausdorff distance is controlled by the diameter of the union. -/\ntheorem hausdorffDist_le_diam (hs : s.Nonempty) (bs : IsBounded s) (ht : t.Nonempty)\n    (bt : IsBounded t) : hausdorffDist s t ≤ diam (s ∪ t) := by\n  rcases hs with ⟨x, xs⟩\n  rcases ht with ⟨y, yt⟩\n  refine hausdorffDist_le_of_mem_dist diam_nonneg ?_ ?_\n  · exact fun z hz => ⟨y, yt, dist_le_diam_of_mem (bs.union bt) (subset_union_left hz)\n      (subset_union_right yt)⟩\n  · exact fun z hz => ⟨x, xs, dist_le_diam_of_mem (bs.union bt) (subset_union_right hz)\n      (subset_union_left xs)⟩\n\n"}
{"name":"Metric.infDist_le_hausdorffDist_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\nx : α\nhx : Membership.mem s x\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n⊢ LE.le (Metric.infDist x t) (Metric.hausdorffDist s t)","decl":"/-- The distance to a set is controlled by the Hausdorff distance. -/\ntheorem infDist_le_hausdorffDist_of_mem (hx : x ∈ s) (fin : hausdorffEdist s t ≠ ⊤) :\n    infDist x t ≤ hausdorffDist s t :=\n  toReal_mono fin (infEdist_le_hausdorffEdist_of_mem hx)\n\n"}
{"name":"Metric.exists_dist_lt_of_hausdorffDist_lt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\nx : α\nr : Real\nh : Membership.mem s x\nH : LT.lt (Metric.hausdorffDist s t) r\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n⊢ Exists fun y => And (Membership.mem t y) (LT.lt (Dist.dist x y) r)","decl":"/-- If the Hausdorff distance is `< r`, any point in one of the sets is at distance\n`< r` of a point in the other set. -/\ntheorem exists_dist_lt_of_hausdorffDist_lt {r : ℝ} (h : x ∈ s) (H : hausdorffDist s t < r)\n    (fin : hausdorffEdist s t ≠ ⊤) : ∃ y ∈ t, dist x y < r := by\n  have r0 : 0 < r := lt_of_le_of_lt hausdorffDist_nonneg H\n  have : hausdorffEdist s t < ENNReal.ofReal r := by\n    rwa [hausdorffDist, ← ENNReal.toReal_ofReal (le_of_lt r0),\n      ENNReal.toReal_lt_toReal fin ENNReal.ofReal_ne_top] at H\n  rcases exists_edist_lt_of_hausdorffEdist_lt h this with ⟨y, hy, yr⟩\n  rw [edist_dist, ENNReal.ofReal_lt_ofReal_iff r0] at yr\n  exact ⟨y, hy, yr⟩\n\n"}
{"name":"Metric.exists_dist_lt_of_hausdorffDist_lt'","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\ny : α\nr : Real\nh : Membership.mem t y\nH : LT.lt (Metric.hausdorffDist s t) r\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n⊢ Exists fun x => And (Membership.mem s x) (LT.lt (Dist.dist x y) r)","decl":"/-- If the Hausdorff distance is `< r`, any point in one of the sets is at distance\n`< r` of a point in the other set. -/\ntheorem exists_dist_lt_of_hausdorffDist_lt' {r : ℝ} (h : y ∈ t) (H : hausdorffDist s t < r)\n    (fin : hausdorffEdist s t ≠ ⊤) : ∃ x ∈ s, dist x y < r := by\n  rw [hausdorffDist_comm] at H\n  rw [hausdorffEdist_comm] at fin\n  simpa [dist_comm] using exists_dist_lt_of_hausdorffDist_lt h H fin\n\n"}
{"name":"Metric.infDist_le_infDist_add_hausdorffDist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\nx : α\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n⊢ LE.le (Metric.infDist x t) (HAdd.hAdd (Metric.infDist x s) (Metric.hausdorffDist s t))","decl":"/-- The infimum distance to `s` and `t` are the same, up to the Hausdorff distance\nbetween `s` and `t` -/\ntheorem infDist_le_infDist_add_hausdorffDist (fin : hausdorffEdist s t ≠ ⊤) :\n    infDist x t ≤ infDist x s + hausdorffDist s t := by\n  refine toReal_le_add' infEdist_le_infEdist_add_hausdorffEdist (fun h ↦ ?_) (flip absurd fin)\n  rw [infEdist_eq_top_iff, ← not_nonempty_iff_eq_empty] at h ⊢\n  rw [hausdorffEdist_comm] at fin\n  exact mt (nonempty_of_hausdorffEdist_ne_top · fin) h\n\n"}
{"name":"Metric.hausdorffDist_image","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\ns t : Set α\nΦ : α → β\nh : Isometry Φ\n⊢ Eq (Metric.hausdorffDist (Set.image Φ s) (Set.image Φ t)) (Metric.hausdorffDist s t)","decl":"/-- The Hausdorff distance is invariant under isometries. -/\ntheorem hausdorffDist_image (h : Isometry Φ) :\n    hausdorffDist (Φ '' s) (Φ '' t) = hausdorffDist s t := by\n  simp [hausdorffDist, hausdorffEdist_image h]\n\n"}
{"name":"Metric.hausdorffDist_triangle","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t u : Set α\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n⊢ LE.le (Metric.hausdorffDist s u) (HAdd.hAdd (Metric.hausdorffDist s t) (Metric.hausdorffDist t u))","decl":"/-- The Hausdorff distance satisfies the triangle inequality. -/\ntheorem hausdorffDist_triangle (fin : hausdorffEdist s t ≠ ⊤) :\n    hausdorffDist s u ≤ hausdorffDist s t + hausdorffDist t u := by\n  refine toReal_le_add' hausdorffEdist_triangle (flip absurd fin) (not_imp_not.1 fun h ↦ ?_)\n  rw [hausdorffEdist_comm] at fin\n  exact ne_top_of_le_ne_top (add_ne_top.2 ⟨fin, h⟩) hausdorffEdist_triangle\n\n"}
{"name":"Metric.hausdorffDist_triangle'","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t u : Set α\nfin : Ne (EMetric.hausdorffEdist t u) Top.top\n⊢ LE.le (Metric.hausdorffDist s u) (HAdd.hAdd (Metric.hausdorffDist s t) (Metric.hausdorffDist t u))","decl":"/-- The Hausdorff distance satisfies the triangle inequality. -/\ntheorem hausdorffDist_triangle' (fin : hausdorffEdist t u ≠ ⊤) :\n    hausdorffDist s u ≤ hausdorffDist s t + hausdorffDist t u := by\n  rw [hausdorffEdist_comm] at fin\n  have I : hausdorffDist u s ≤ hausdorffDist u t + hausdorffDist t s :=\n    hausdorffDist_triangle fin\n  simpa [add_comm, hausdorffDist_comm] using I\n\n"}
{"name":"Metric.hausdorffDist_self_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Eq (Metric.hausdorffDist s (closure s)) 0","decl":"/-- The Hausdorff distance between a set and its closure vanishes. -/\n@[simp]\ntheorem hausdorffDist_self_closure : hausdorffDist s (closure s) = 0 := by simp [hausdorffDist]\n\n"}
{"name":"Metric.hausdorffDist_closure₁","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\n⊢ Eq (Metric.hausdorffDist (closure s) t) (Metric.hausdorffDist s t)","decl":"/-- Replacing a set by its closure does not change the Hausdorff distance. -/\n@[simp]\ntheorem hausdorffDist_closure₁ : hausdorffDist (closure s) t = hausdorffDist s t := by\n  simp [hausdorffDist]\n\n"}
{"name":"Metric.hausdorffDist_closure₂","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\n⊢ Eq (Metric.hausdorffDist s (closure t)) (Metric.hausdorffDist s t)","decl":"/-- Replacing a set by its closure does not change the Hausdorff distance. -/\n@[simp]\ntheorem hausdorffDist_closure₂ : hausdorffDist s (closure t) = hausdorffDist s t := by\n  simp [hausdorffDist]\n\n"}
{"name":"Metric.hausdorffDist_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\n⊢ Eq (Metric.hausdorffDist (closure s) (closure t)) (Metric.hausdorffDist s t)","decl":"/-- The Hausdorff distances between two sets and their closures coincide. -/\ntheorem hausdorffDist_closure : hausdorffDist (closure s) (closure t) = hausdorffDist s t := by\n  simp [hausdorffDist]\n\n"}
{"name":"Metric.hausdorffDist_zero_iff_closure_eq_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n⊢ Iff (Eq (Metric.hausdorffDist s t) 0) (Eq (closure s) (closure t))","decl":"/-- Two sets are at zero Hausdorff distance if and only if they have the same closures. -/\ntheorem hausdorffDist_zero_iff_closure_eq_closure (fin : hausdorffEdist s t ≠ ⊤) :\n    hausdorffDist s t = 0 ↔ closure s = closure t := by\n  simp [← hausdorffEdist_zero_iff_closure_eq_closure, hausdorffDist,\n    ENNReal.toReal_eq_zero_iff, fin]\n\n"}
{"name":"IsClosed.hausdorffDist_zero_iff_eq","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\nhs : IsClosed s\nht : IsClosed t\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n⊢ Iff (Eq (Metric.hausdorffDist s t) 0) (Eq s t)","decl":"/-- Two closed sets are at zero Hausdorff distance if and only if they coincide. -/\ntheorem _root_.IsClosed.hausdorffDist_zero_iff_eq (hs : IsClosed s) (ht : IsClosed t)\n    (fin : hausdorffEdist s t ≠ ⊤) : hausdorffDist s t = 0 ↔ s = t := by\n  simp [← hausdorffEdist_zero_iff_eq_of_closed hs ht, hausdorffDist, ENNReal.toReal_eq_zero_iff,\n    fin]\n\n"}
