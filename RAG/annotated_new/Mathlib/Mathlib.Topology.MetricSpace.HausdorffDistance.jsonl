{"name":"EMetric.infEdist_empty","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (EMetric.infEdist x EmptyCollection.emptyCollection) Top.top","decl":"@[simp]\ntheorem infEdist_empty : infEdist x ‚àÖ = ‚àû :=\n  iInf_emptyset\n\n"}
{"name":"EMetric.le_infEdist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns : Set Œ±\nd : ENNReal\n‚ä¢ Iff (LE.le d (EMetric.infEdist x s)) (‚àÄ (y : Œ±), Membership.mem s y ‚Üí LE.le d (EDist.edist x y))","decl":"theorem le_infEdist {d} : d ‚â§ infEdist x s ‚Üî ‚àÄ y ‚àà s, d ‚â§ edist x y := by\n  simp only [infEdist, le_iInf_iff]\n\n"}
{"name":"EMetric.infEdist_union","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns t : Set Œ±\n‚ä¢ Eq (EMetric.infEdist x (Union.union s t)) (Min.min (EMetric.infEdist x s) (EMetric.infEdist x t))","decl":"/-- The edist to a union is the minimum of the edists -/\n@[simp]\ntheorem infEdist_union : infEdist x (s ‚à™ t) = infEdist x s ‚äì infEdist x t :=\n  iInf_union\n\n"}
{"name":"EMetric.infEdist_iUnion","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œπ : Sort u_1\nŒ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nf : Œπ ‚Üí Set Œ±\nx : Œ±\n‚ä¢ Eq (EMetric.infEdist x (Set.iUnion fun i => f i)) (iInf fun i => EMetric.infEdist x (f i))","decl":"@[simp]\ntheorem infEdist_iUnion (f : Œπ ‚Üí Set Œ±) (x : Œ±) : infEdist x (‚ãÉ i, f i) = ‚®Ö i, infEdist x (f i) :=\n  iInf_iUnion f _\n\n"}
{"name":"EMetric.infEdist_biUnion","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nŒπ : Type u_2\nf : Œπ ‚Üí Set Œ±\nI : Set Œπ\nx : Œ±\n‚ä¢ Eq (EMetric.infEdist x (Set.iUnion fun i => Set.iUnion fun h => f i)) (iInf fun i => iInf fun h => EMetric.infEdist x (f i))","decl":"lemma infEdist_biUnion {Œπ : Type*} (f : Œπ ‚Üí Set Œ±) (I : Set Œπ) (x : Œ±) :\n    infEdist x (‚ãÉ i ‚àà I, f i) = ‚®Ö i ‚àà I, infEdist x (f i) := by simp only [infEdist_iUnion]\n\n"}
{"name":"EMetric.infEdist_singleton","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (EMetric.infEdist x (Singleton.singleton y)) (EDist.edist x y)","decl":"/-- The edist to a singleton is the edistance to the single point of this singleton -/\n@[simp]\ntheorem infEdist_singleton : infEdist x {y} = edist x y :=\n  iInf_singleton\n\n"}
{"name":"EMetric.infEdist_le_edist_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\ns : Set Œ±\nh : Membership.mem s y\n‚ä¢ LE.le (EMetric.infEdist x s) (EDist.edist x y)","decl":"/-- The edist to a set is bounded above by the edist to any of its points -/\ntheorem infEdist_le_edist_of_mem (h : y ‚àà s) : infEdist x s ‚â§ edist x y :=\n  iInf‚ÇÇ_le y h\n\n"}
{"name":"EMetric.infEdist_zero_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns : Set Œ±\nh : Membership.mem s x\n‚ä¢ Eq (EMetric.infEdist x s) 0","decl":"/-- If a point `x` belongs to `s`, then its edist to `s` vanishes -/\ntheorem infEdist_zero_of_mem (h : x ‚àà s) : infEdist x s = 0 :=\n  nonpos_iff_eq_zero.1 <| @edist_self _ _ x ‚ñ∏ infEdist_le_edist_of_mem h\n\n"}
{"name":"EMetric.infEdist_anti","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns t : Set Œ±\nh : HasSubset.Subset s t\n‚ä¢ LE.le (EMetric.infEdist x t) (EMetric.infEdist x s)","decl":"/-- The edist is antitone with respect to inclusion. -/\ntheorem infEdist_anti (h : s ‚äÜ t) : infEdist x t ‚â§ infEdist x s :=\n  iInf_le_iInf_of_subset h\n\n"}
{"name":"EMetric.infEdist_lt_iff","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns : Set Œ±\nr : ENNReal\n‚ä¢ Iff (LT.lt (EMetric.infEdist x s) r) (Exists fun y => And (Membership.mem s y) (LT.lt (EDist.edist x y) r))","decl":"/-- The edist to a set is `< r` iff there exists a point in the set at edistance `< r` -/\ntheorem infEdist_lt_iff {r : ‚Ñù‚â•0‚àû} : infEdist x s < r ‚Üî ‚àÉ y ‚àà s, edist x y < r := by\n  simp_rw [infEdist, iInf_lt_iff, exists_prop]\n\n"}
{"name":"EMetric.infEdist_le_infEdist_add_edist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\ns : Set Œ±\n‚ä¢ LE.le (EMetric.infEdist x s) (HAdd.hAdd (EMetric.infEdist y s) (EDist.edist x y))","decl":"/-- The edist of `x` to `s` is bounded by the sum of the edist of `y` to `s` and\nthe edist from `x` to `y` -/\ntheorem infEdist_le_infEdist_add_edist : infEdist x s ‚â§ infEdist y s + edist x y :=\n  calc\n    ‚®Ö z ‚àà s, edist x z ‚â§ ‚®Ö z ‚àà s, edist y z + edist x y :=\n      iInf‚ÇÇ_mono fun _ _ => (edist_triangle _ _ _).trans_eq (add_comm _ _)\n    _ = (‚®Ö z ‚àà s, edist y z) + edist x y := by simp only [ENNReal.iInf_add]\n\n"}
{"name":"EMetric.infEdist_le_edist_add_infEdist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\ns : Set Œ±\n‚ä¢ LE.le (EMetric.infEdist x s) (HAdd.hAdd (EDist.edist x y) (EMetric.infEdist y s))","decl":"theorem infEdist_le_edist_add_infEdist : infEdist x s ‚â§ edist x y + infEdist y s := by\n  rw [add_comm]\n  exact infEdist_le_infEdist_add_edist\n\n"}
{"name":"EMetric.edist_le_infEdist_add_ediam","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx y : Œ±\ns : Set Œ±\nhy : Membership.mem s y\n‚ä¢ LE.le (EDist.edist x y) (HAdd.hAdd (EMetric.infEdist x s) (EMetric.diam s))","decl":"theorem edist_le_infEdist_add_ediam (hy : y ‚àà s) : edist x y ‚â§ infEdist x s + diam s := by\n  simp_rw [infEdist, ENNReal.iInf_add]\n  refine le_iInf‚ÇÇ fun i hi => ?_\n  calc\n    edist x y ‚â§ edist x i + edist i y := edist_triangle _ _ _\n    _ ‚â§ edist x i + diam s := add_le_add le_rfl (edist_le_diam_of_mem hi hy)\n\n"}
{"name":"EMetric.continuous_infEdist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Continuous fun x => EMetric.infEdist x s","decl":"/-- The edist to a set depends continuously on the point -/\n@[continuity]\ntheorem continuous_infEdist : Continuous fun x => infEdist x s :=\n  continuous_of_le_add_edist 1 (by simp) <| by\n    simp only [one_mul, infEdist_le_infEdist_add_edist, forall‚ÇÇ_true_iff]\n\n"}
{"name":"EMetric.infEdist_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ Eq (EMetric.infEdist x (closure s)) (EMetric.infEdist x s)","decl":"/-- The edist to a set and to its closure coincide -/\ntheorem infEdist_closure : infEdist x (closure s) = infEdist x s := by\n  refine le_antisymm (infEdist_anti subset_closure) ?_\n  refine ENNReal.le_of_forall_pos_le_add fun Œµ Œµpos h => ?_\n  have Œµ0 : 0 < (Œµ / 2 : ‚Ñù‚â•0‚àû) := by simpa [pos_iff_ne_zero] using Œµpos\n  have : infEdist x (closure s) < infEdist x (closure s) + Œµ / 2 :=\n    ENNReal.lt_add_right h.ne Œµ0.ne'\n  obtain ‚ü®y : Œ±, ycs : y ‚àà closure s, hy : edist x y < infEdist x (closure s) + ‚ÜëŒµ / 2‚ü© :=\n    infEdist_lt_iff.mp this\n  obtain ‚ü®z : Œ±, zs : z ‚àà s, dyz : edist y z < ‚ÜëŒµ / 2‚ü© := EMetric.mem_closure_iff.1 ycs (Œµ / 2) Œµ0\n  calc\n    infEdist x s ‚â§ edist x z := infEdist_le_edist_of_mem zs\n    _ ‚â§ edist x y + edist y z := edist_triangle _ _ _\n    _ ‚â§ infEdist x (closure s) + Œµ / 2 + Œµ / 2 := add_le_add (le_of_lt hy) (le_of_lt dyz)\n    _ = infEdist x (closure s) + ‚ÜëŒµ := by rw [add_assoc, ENNReal.add_halves]\n\n"}
{"name":"EMetric.mem_closure_iff_infEdist_zero","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (closure s) x) (Eq (EMetric.infEdist x s) 0)","decl":"/-- A point belongs to the closure of `s` iff its infimum edistance to this set vanishes -/\ntheorem mem_closure_iff_infEdist_zero : x ‚àà closure s ‚Üî infEdist x s = 0 :=\n  ‚ü®fun h => by\n    rw [‚Üê infEdist_closure]\n    exact infEdist_zero_of_mem h,\n   fun h =>\n    EMetric.mem_closure_iff.2 fun Œµ Œµpos => infEdist_lt_iff.mp <| by rwa [h]‚ü©\n\n"}
{"name":"EMetric.mem_iff_infEdist_zero_of_closed","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns : Set Œ±\nh : IsClosed s\n‚ä¢ Iff (Membership.mem s x) (Eq (EMetric.infEdist x s) 0)","decl":"/-- Given a closed set `s`, a point belongs to `s` iff its infimum edistance to this set vanishes -/\ntheorem mem_iff_infEdist_zero_of_closed (h : IsClosed s) : x ‚àà s ‚Üî infEdist x s = 0 := by\n  rw [‚Üê mem_closure_iff_infEdist_zero, h.closure_eq]\n\n"}
{"name":"EMetric.infEdist_pos_iff_not_mem_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\nE : Set Œ±\n‚ä¢ Iff (LT.lt 0 (EMetric.infEdist x E)) (Not (Membership.mem (closure E) x))","decl":"/-- The infimum edistance of a point to a set is positive if and only if the point is not in the\nclosure of the set. -/\ntheorem infEdist_pos_iff_not_mem_closure {x : Œ±} {E : Set Œ±} :\n    0 < infEdist x E ‚Üî x ‚àâ closure E := by\n  rw [mem_closure_iff_infEdist_zero, pos_iff_ne_zero]\n\n"}
{"name":"EMetric.infEdist_closure_pos_iff_not_mem_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\nE : Set Œ±\n‚ä¢ Iff (LT.lt 0 (EMetric.infEdist x (closure E))) (Not (Membership.mem (closure E) x))","decl":"theorem infEdist_closure_pos_iff_not_mem_closure {x : Œ±} {E : Set Œ±} :\n    0 < infEdist x (closure E) ‚Üî x ‚àâ closure E := by\n  rw [infEdist_closure, infEdist_pos_iff_not_mem_closure]\n\n"}
{"name":"EMetric.exists_real_pos_lt_infEdist_of_not_mem_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\nE : Set Œ±\nh : Not (Membership.mem (closure E) x)\n‚ä¢ Exists fun Œµ => And (LT.lt 0 Œµ) (LT.lt (ENNReal.ofReal Œµ) (EMetric.infEdist x E))","decl":"theorem exists_real_pos_lt_infEdist_of_not_mem_closure {x : Œ±} {E : Set Œ±} (h : x ‚àâ closure E) :\n    ‚àÉ Œµ : ‚Ñù, 0 < Œµ ‚àß ENNReal.ofReal Œµ < infEdist x E := by\n  rw [‚Üê infEdist_pos_iff_not_mem_closure, ENNReal.lt_iff_exists_real_btwn] at h\n  rcases h with ‚ü®Œµ, ‚ü®_, ‚ü®Œµ_pos, Œµ_lt‚ü©‚ü©‚ü©\n  exact ‚ü®Œµ, ‚ü®ENNReal.ofReal_pos.mp Œµ_pos, Œµ_lt‚ü©‚ü©\n\n"}
{"name":"EMetric.disjoint_closedBall_of_lt_infEdist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns : Set Œ±\nr : ENNReal\nh : LT.lt r (EMetric.infEdist x s)\n‚ä¢ Disjoint (EMetric.closedBall x r) s","decl":"theorem disjoint_closedBall_of_lt_infEdist {r : ‚Ñù‚â•0‚àû} (h : r < infEdist x s) :\n    Disjoint (closedBall x r) s := by\n  rw [disjoint_left]\n  intro y hy h'y\n  apply lt_irrefl (infEdist x s)\n  calc\n    infEdist x s ‚â§ edist x y := infEdist_le_edist_of_mem h'y\n    _ ‚â§ r := by rwa [mem_closedBall, edist_comm] at hy\n    _ < infEdist x s := h\n\n"}
{"name":"EMetric.infEdist_image","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nx : Œ±\nt : Set Œ±\nŒ¶ : Œ± ‚Üí Œ≤\nhŒ¶ : Isometry Œ¶\n‚ä¢ Eq (EMetric.infEdist (Œ¶ x) (Set.image Œ¶ t)) (EMetric.infEdist x t)","decl":"/-- The infimum edistance is invariant under isometries -/\ntheorem infEdist_image (hŒ¶ : Isometry Œ¶) : infEdist (Œ¶ x) (Œ¶ '' t) = infEdist x t := by\n  simp only [infEdist, iInf_image, hŒ¶.edist_eq]\n\n"}
{"name":"EMetric.infEdist_smul","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\nM : Type u_2\ninst‚úù¬π : SMul M Œ±\ninst‚úù : IsometricSMul M Œ±\nc : M\nx : Œ±\ns : Set Œ±\n‚ä¢ Eq (EMetric.infEdist (HSMul.hSMul c x) (HSMul.hSMul c s)) (EMetric.infEdist x s)","decl":"@[to_additive (attr := simp)]\ntheorem infEdist_smul {M} [SMul M Œ±] [IsometricSMul M Œ±] (c : M) (x : Œ±) (s : Set Œ±) :\n    infEdist (c ‚Ä¢ x) (c ‚Ä¢ s) = infEdist x s :=\n  infEdist_image (isometry_smul _ _)\n\n"}
{"name":"EMetric.infEdist_vadd","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\nM : Type u_2\ninst‚úù¬π : VAdd M Œ±\ninst‚úù : IsometricVAdd M Œ±\nc : M\nx : Œ±\ns : Set Œ±\n‚ä¢ Eq (EMetric.infEdist (HVAdd.hVAdd c x) (HVAdd.hVAdd c s)) (EMetric.infEdist x s)","decl":"@[to_additive (attr := simp)]\ntheorem infEdist_smul {M} [SMul M Œ±] [IsometricSMul M Œ±] (c : M) (x : Œ±) (s : Set Œ±) :\n    infEdist (c ‚Ä¢ x) (c ‚Ä¢ s) = infEdist x s :=\n  infEdist_image (isometry_smul _ _)\n\n"}
{"name":"IsOpen.exists_iUnion_isClosed","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nU : Set Œ±\nhU : IsOpen U\n‚ä¢ Exists fun F => And (‚àÄ (n : Nat), IsClosed (F n)) (And (‚àÄ (n : Nat), HasSubset.Subset (F n) U) (And (Eq (Set.iUnion fun n => F n) U) (Monotone F)))","decl":"theorem _root_.IsOpen.exists_iUnion_isClosed {U : Set Œ±} (hU : IsOpen U) :\n    ‚àÉ F : ‚Ñï ‚Üí Set Œ±, (‚àÄ n, IsClosed (F n)) ‚àß (‚àÄ n, F n ‚äÜ U) ‚àß ‚ãÉ n, F n = U ‚àß Monotone F := by\n  obtain ‚ü®a, a_pos, a_lt_one‚ü© : ‚àÉ a : ‚Ñù‚â•0‚àû, 0 < a ‚àß a < 1 := exists_between zero_lt_one\n  let F := fun n : ‚Ñï => (fun x => infEdist x U·∂ú) ‚Åª¬π' Ici (a ^ n)\n  have F_subset : ‚àÄ n, F n ‚äÜ U := fun n x hx ‚Ü¶ by\n    by_contra h\n    have : infEdist x U·∂ú ‚â† 0 := ((ENNReal.pow_pos a_pos _).trans_le hx).ne'\n    exact this (infEdist_zero_of_mem h)\n  refine ‚ü®F, fun n => IsClosed.preimage continuous_infEdist isClosed_Ici, F_subset, ?_, ?_‚ü©\n  ¬∑ show ‚ãÉ n, F n = U\n    refine Subset.antisymm (by simp only [iUnion_subset_iff, F_subset, forall_const]) fun x hx => ?_\n    have : ¬¨x ‚àà U·∂ú := by simpa using hx\n    rw [mem_iff_infEdist_zero_of_closed hU.isClosed_compl] at this\n    have B : 0 < infEdist x U·∂ú := by simpa [pos_iff_ne_zero] using this\n    have : Filter.Tendsto (fun n => a ^ n) atTop (ùìù 0) :=\n      ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one a_lt_one\n    rcases ((tendsto_order.1 this).2 _ B).exists with ‚ü®n, hn‚ü©\n    simp only [mem_iUnion, mem_Ici, mem_preimage]\n    exact ‚ü®n, hn.le‚ü©\n  show Monotone F\n  intro m n hmn x hx\n  simp only [F, mem_Ici, mem_preimage] at hx ‚ä¢\n  apply le_trans (pow_le_pow_right_of_le_one' a_lt_one.le hmn) hx\n\n"}
{"name":"IsCompact.exists_infEdist_eq_edist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns : Set Œ±\nhs : IsCompact s\nhne : s.Nonempty\nx : Œ±\n‚ä¢ Exists fun y => And (Membership.mem s y) (Eq (EMetric.infEdist x s) (EDist.edist x y))","decl":"theorem _root_.IsCompact.exists_infEdist_eq_edist (hs : IsCompact s) (hne : s.Nonempty) (x : Œ±) :\n    ‚àÉ y ‚àà s, infEdist x s = edist x y := by\n  have A : Continuous fun y => edist x y := continuous_const.edist continuous_id\n  obtain ‚ü®y, ys, hy‚ü© := hs.exists_isMinOn hne A.continuousOn\n  exact ‚ü®y, ys, le_antisymm (infEdist_le_edist_of_mem ys) (by rwa [le_infEdist])‚ü©\n\n"}
{"name":"EMetric.exists_pos_forall_lt_edist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns t : Set Œ±\nhs : IsCompact s\nht : IsClosed t\nhst : Disjoint s t\n‚ä¢ Exists fun r => And (LT.lt 0 r) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí ‚àÄ (y : Œ±), Membership.mem t y ‚Üí LT.lt (‚Üër) (EDist.edist x y))","decl":"theorem exists_pos_forall_lt_edist (hs : IsCompact s) (ht : IsClosed t) (hst : Disjoint s t) :\n    ‚àÉ r : ‚Ñù‚â•0, 0 < r ‚àß ‚àÄ x ‚àà s, ‚àÄ y ‚àà t, (r : ‚Ñù‚â•0‚àû) < edist x y := by\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  ¬∑ use 1\n    simp\n  obtain ‚ü®x, hx, h‚ü© := hs.exists_isMinOn hne continuous_infEdist.continuousOn\n  have : 0 < infEdist x t :=\n    pos_iff_ne_zero.2 fun H => hst.le_bot ‚ü®hx, (mem_iff_infEdist_zero_of_closed ht).mpr H‚ü©\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 this with ‚ü®r, h‚ÇÄ, hr‚ü©\n  exact ‚ü®r, ENNReal.coe_pos.mp h‚ÇÄ, fun y hy z hz => hr.trans_le <| le_infEdist.1 (h hy) z hz‚ü©\n\n"}
{"name":"EMetric.hausdorffEdist_def","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u_2\ninst‚úù : PseudoEMetricSpace Œ±\ns t : Set Œ±\n‚ä¢ Eq (EMetric.hausdorffEdist s t) (Max.max (iSup fun x => iSup fun h => EMetric.infEdist x t) (iSup fun y => iSup fun h => EMetric.infEdist y s))","decl":"/-- The Hausdorff edistance between two sets is the smallest `r` such that each set\nis contained in the `r`-neighborhood of the other one -/\nirreducible_def hausdorffEdist {Œ± : Type u} [PseudoEMetricSpace Œ±] (s t : Set Œ±) : ‚Ñù‚â•0‚àû :=\n  (‚®Ü x ‚àà s, infEdist x t) ‚äî ‚®Ü y ‚àà t, infEdist y s\n\n"}
{"name":"EMetric.hausdorffEdist_self","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Eq (EMetric.hausdorffEdist s s) 0","decl":"/-- The Hausdorff edistance of a set to itself vanishes. -/\n@[simp]\ntheorem hausdorffEdist_self : hausdorffEdist s s = 0 := by\n  simp only [hausdorffEdist_def, sup_idem, ENNReal.iSup_eq_zero]\n  exact fun x hx => infEdist_zero_of_mem hx\n\n"}
{"name":"EMetric.hausdorffEdist_comm","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns t : Set Œ±\n‚ä¢ Eq (EMetric.hausdorffEdist s t) (EMetric.hausdorffEdist t s)","decl":"/-- The Haudorff edistances of `s` to `t` and of `t` to `s` coincide. -/\ntheorem hausdorffEdist_comm : hausdorffEdist s t = hausdorffEdist t s := by\n  simp only [hausdorffEdist_def]; apply sup_comm\n\n"}
{"name":"EMetric.hausdorffEdist_le_of_infEdist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns t : Set Œ±\nr : ENNReal\nH1 : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí LE.le (EMetric.infEdist x t) r\nH2 : ‚àÄ (x : Œ±), Membership.mem t x ‚Üí LE.le (EMetric.infEdist x s) r\n‚ä¢ LE.le (EMetric.hausdorffEdist s t) r","decl":"/-- Bounding the Hausdorff edistance by bounding the edistance of any point\nin each set to the other set -/\ntheorem hausdorffEdist_le_of_infEdist {r : ‚Ñù‚â•0‚àû} (H1 : ‚àÄ x ‚àà s, infEdist x t ‚â§ r)\n    (H2 : ‚àÄ x ‚àà t, infEdist x s ‚â§ r) : hausdorffEdist s t ‚â§ r := by\n  simp only [hausdorffEdist_def, sup_le_iff, iSup_le_iff]\n  exact ‚ü®H1, H2‚ü©\n\n"}
{"name":"EMetric.hausdorffEdist_le_of_mem_edist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns t : Set Œ±\nr : ENNReal\nH1 : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí Exists fun y => And (Membership.mem t y) (LE.le (EDist.edist x y) r)\nH2 : ‚àÄ (x : Œ±), Membership.mem t x ‚Üí Exists fun y => And (Membership.mem s y) (LE.le (EDist.edist x y) r)\n‚ä¢ LE.le (EMetric.hausdorffEdist s t) r","decl":"/-- Bounding the Hausdorff edistance by exhibiting, for any point in each set,\nanother point in the other set at controlled distance -/\ntheorem hausdorffEdist_le_of_mem_edist {r : ‚Ñù‚â•0‚àû} (H1 : ‚àÄ x ‚àà s, ‚àÉ y ‚àà t, edist x y ‚â§ r)\n    (H2 : ‚àÄ x ‚àà t, ‚àÉ y ‚àà s, edist x y ‚â§ r) : hausdorffEdist s t ‚â§ r := by\n  refine hausdorffEdist_le_of_infEdist (fun x xs ‚Ü¶ ?_) (fun x xt ‚Ü¶ ?_)\n  ¬∑ rcases H1 x xs with ‚ü®y, yt, hy‚ü©\n    exact le_trans (infEdist_le_edist_of_mem yt) hy\n  ¬∑ rcases H2 x xt with ‚ü®y, ys, hy‚ü©\n    exact le_trans (infEdist_le_edist_of_mem ys) hy\n\n"}
{"name":"EMetric.infEdist_le_hausdorffEdist_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns t : Set Œ±\nh : Membership.mem s x\n‚ä¢ LE.le (EMetric.infEdist x t) (EMetric.hausdorffEdist s t)","decl":"/-- The distance to a set is controlled by the Hausdorff distance. -/\ntheorem infEdist_le_hausdorffEdist_of_mem (h : x ‚àà s) : infEdist x t ‚â§ hausdorffEdist s t := by\n  rw [hausdorffEdist_def]\n  refine le_trans ?_ le_sup_left\n  exact le_iSup‚ÇÇ (Œ± := ‚Ñù‚â•0‚àû) x h\n\n"}
{"name":"EMetric.exists_edist_lt_of_hausdorffEdist_lt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns t : Set Œ±\nr : ENNReal\nh : Membership.mem s x\nH : LT.lt (EMetric.hausdorffEdist s t) r\n‚ä¢ Exists fun y => And (Membership.mem t y) (LT.lt (EDist.edist x y) r)","decl":"/-- If the Hausdorff distance is `< r`, then any point in one of the sets has\na corresponding point at distance `< r` in the other set. -/\ntheorem exists_edist_lt_of_hausdorffEdist_lt {r : ‚Ñù‚â•0‚àû} (h : x ‚àà s) (H : hausdorffEdist s t < r) :\n    ‚àÉ y ‚àà t, edist x y < r :=\n  infEdist_lt_iff.mp <|\n    calc\n      infEdist x t ‚â§ hausdorffEdist s t := infEdist_le_hausdorffEdist_of_mem h\n      _ < r := H\n\n"}
{"name":"EMetric.infEdist_le_infEdist_add_hausdorffEdist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nx : Œ±\ns t : Set Œ±\n‚ä¢ LE.le (EMetric.infEdist x t) (HAdd.hAdd (EMetric.infEdist x s) (EMetric.hausdorffEdist s t))","decl":"/-- The distance from `x` to `s` or `t` is controlled in terms of the Hausdorff distance\nbetween `s` and `t`. -/\ntheorem infEdist_le_infEdist_add_hausdorffEdist :\n    infEdist x t ‚â§ infEdist x s + hausdorffEdist s t :=\n  ENNReal.le_of_forall_pos_le_add fun Œµ Œµpos h => by\n    have Œµ0 : (Œµ / 2 : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa [pos_iff_ne_zero] using Œµpos\n    have : infEdist x s < infEdist x s + Œµ / 2 :=\n      ENNReal.lt_add_right (ENNReal.add_lt_top.1 h).1.ne Œµ0\n    obtain ‚ü®y : Œ±, ys : y ‚àà s, dxy : edist x y < infEdist x s + ‚ÜëŒµ / 2‚ü© := infEdist_lt_iff.mp this\n    have : hausdorffEdist s t < hausdorffEdist s t + Œµ / 2 :=\n      ENNReal.lt_add_right (ENNReal.add_lt_top.1 h).2.ne Œµ0\n    obtain ‚ü®z : Œ±, zt : z ‚àà t, dyz : edist y z < hausdorffEdist s t + ‚ÜëŒµ / 2‚ü© :=\n      exists_edist_lt_of_hausdorffEdist_lt ys this\n    calc\n      infEdist x t ‚â§ edist x z := infEdist_le_edist_of_mem zt\n      _ ‚â§ edist x y + edist y z := edist_triangle _ _ _\n      _ ‚â§ infEdist x s + Œµ / 2 + (hausdorffEdist s t + Œµ / 2) := add_le_add dxy.le dyz.le\n      _ = infEdist x s + hausdorffEdist s t + Œµ := by\n        simp [ENNReal.add_halves, add_comm, add_left_comm]\n\n"}
{"name":"EMetric.hausdorffEdist_image","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\ns t : Set Œ±\nŒ¶ : Œ± ‚Üí Œ≤\nh : Isometry Œ¶\n‚ä¢ Eq (EMetric.hausdorffEdist (Set.image Œ¶ s) (Set.image Œ¶ t)) (EMetric.hausdorffEdist s t)","decl":"/-- The Hausdorff edistance is invariant under isometries. -/\ntheorem hausdorffEdist_image (h : Isometry Œ¶) :\n    hausdorffEdist (Œ¶ '' s) (Œ¶ '' t) = hausdorffEdist s t := by\n  simp only [hausdorffEdist_def, iSup_image, infEdist_image h]\n\n"}
{"name":"EMetric.hausdorffEdist_le_ediam","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns t : Set Œ±\nhs : s.Nonempty\nht : t.Nonempty\n‚ä¢ LE.le (EMetric.hausdorffEdist s t) (EMetric.diam (Union.union s t))","decl":"/-- The Hausdorff distance is controlled by the diameter of the union. -/\ntheorem hausdorffEdist_le_ediam (hs : s.Nonempty) (ht : t.Nonempty) :\n    hausdorffEdist s t ‚â§ diam (s ‚à™ t) := by\n  rcases hs with ‚ü®x, xs‚ü©\n  rcases ht with ‚ü®y, yt‚ü©\n  refine hausdorffEdist_le_of_mem_edist ?_ ?_\n  ¬∑ intro z hz\n    exact ‚ü®y, yt, edist_le_diam_of_mem (subset_union_left hz) (subset_union_right yt)‚ü©\n  ¬∑ intro z hz\n    exact ‚ü®x, xs, edist_le_diam_of_mem (subset_union_right hz) (subset_union_left xs)‚ü©\n\n"}
{"name":"EMetric.hausdorffEdist_triangle","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns t u : Set Œ±\n‚ä¢ LE.le (EMetric.hausdorffEdist s u) (HAdd.hAdd (EMetric.hausdorffEdist s t) (EMetric.hausdorffEdist t u))","decl":"/-- The Hausdorff distance satisfies the triangle inequality. -/\ntheorem hausdorffEdist_triangle : hausdorffEdist s u ‚â§ hausdorffEdist s t + hausdorffEdist t u := by\n  rw [hausdorffEdist_def]\n  simp only [sup_le_iff, iSup_le_iff]\n  constructor\n  ¬∑ show ‚àÄ x ‚àà s, infEdist x u ‚â§ hausdorffEdist s t + hausdorffEdist t u\n    exact fun x xs =>\n      calc\n        infEdist x u ‚â§ infEdist x t + hausdorffEdist t u :=\n          infEdist_le_infEdist_add_hausdorffEdist\n        _ ‚â§ hausdorffEdist s t + hausdorffEdist t u :=\n          add_le_add_right (infEdist_le_hausdorffEdist_of_mem xs) _\n  ¬∑ show ‚àÄ x ‚àà u, infEdist x s ‚â§ hausdorffEdist s t + hausdorffEdist t u\n    exact fun x xu =>\n      calc\n        infEdist x s ‚â§ infEdist x t + hausdorffEdist t s :=\n          infEdist_le_infEdist_add_hausdorffEdist\n        _ ‚â§ hausdorffEdist u t + hausdorffEdist t s :=\n          add_le_add_right (infEdist_le_hausdorffEdist_of_mem xu) _\n        _ = hausdorffEdist s t + hausdorffEdist t u := by simp [hausdorffEdist_comm, add_comm]\n\n"}
{"name":"EMetric.hausdorffEdist_zero_iff_closure_eq_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns t : Set Œ±\n‚ä¢ Iff (Eq (EMetric.hausdorffEdist s t) 0) (Eq (closure s) (closure t))","decl":"/-- Two sets are at zero Hausdorff edistance if and only if they have the same closure. -/\ntheorem hausdorffEdist_zero_iff_closure_eq_closure :\n    hausdorffEdist s t = 0 ‚Üî closure s = closure t := by\n  simp only [hausdorffEdist_def, ENNReal.sup_eq_zero, ENNReal.iSup_eq_zero, ‚Üê subset_def,\n    ‚Üê mem_closure_iff_infEdist_zero, subset_antisymm_iff, isClosed_closure.closure_subset_iff]\n\n"}
{"name":"EMetric.hausdorffEdist_self_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Eq (EMetric.hausdorffEdist s (closure s)) 0","decl":"/-- The Hausdorff edistance between a set and its closure vanishes. -/\n@[simp]\ntheorem hausdorffEdist_self_closure : hausdorffEdist s (closure s) = 0 := by\n  rw [hausdorffEdist_zero_iff_closure_eq_closure, closure_closure]\n\n"}
{"name":"EMetric.hausdorffEdist_closure‚ÇÅ","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns t : Set Œ±\n‚ä¢ Eq (EMetric.hausdorffEdist (closure s) t) (EMetric.hausdorffEdist s t)","decl":"/-- Replacing a set by its closure does not change the Hausdorff edistance. -/\n@[simp]\ntheorem hausdorffEdist_closure‚ÇÅ : hausdorffEdist (closure s) t = hausdorffEdist s t := by\n  refine le_antisymm ?_ ?_\n  ¬∑ calc\n      _ ‚â§ hausdorffEdist (closure s) s + hausdorffEdist s t := hausdorffEdist_triangle\n      _ = hausdorffEdist s t := by simp [hausdorffEdist_comm]\n  ¬∑ calc\n      _ ‚â§ hausdorffEdist s (closure s) + hausdorffEdist (closure s) t := hausdorffEdist_triangle\n      _ = hausdorffEdist (closure s) t := by simp\n\n"}
{"name":"EMetric.hausdorffEdist_closure‚ÇÇ","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns t : Set Œ±\n‚ä¢ Eq (EMetric.hausdorffEdist s (closure t)) (EMetric.hausdorffEdist s t)","decl":"/-- Replacing a set by its closure does not change the Hausdorff edistance. -/\n@[simp]\ntheorem hausdorffEdist_closure‚ÇÇ : hausdorffEdist s (closure t) = hausdorffEdist s t := by\n  simp [@hausdorffEdist_comm _ _ s _]\n\n"}
{"name":"EMetric.hausdorffEdist_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns t : Set Œ±\n‚ä¢ Eq (EMetric.hausdorffEdist (closure s) (closure t)) (EMetric.hausdorffEdist s t)","decl":"/-- The Hausdorff edistance between sets or their closures is the same. -/\ntheorem hausdorffEdist_closure : hausdorffEdist (closure s) (closure t) = hausdorffEdist s t := by\n  simp\n\n"}
{"name":"EMetric.hausdorffEdist_zero_iff_eq_of_closed","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns t : Set Œ±\nhs : IsClosed s\nht : IsClosed t\n‚ä¢ Iff (Eq (EMetric.hausdorffEdist s t) 0) (Eq s t)","decl":"/-- Two closed sets are at zero Hausdorff edistance if and only if they coincide. -/\ntheorem hausdorffEdist_zero_iff_eq_of_closed (hs : IsClosed s) (ht : IsClosed t) :\n    hausdorffEdist s t = 0 ‚Üî s = t := by\n  rw [hausdorffEdist_zero_iff_closure_eq_closure, hs.closure_eq, ht.closure_eq]\n\n"}
{"name":"EMetric.hausdorffEdist_empty","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns : Set Œ±\nne : s.Nonempty\n‚ä¢ Eq (EMetric.hausdorffEdist s EmptyCollection.emptyCollection) Top.top","decl":"/-- The Haudorff edistance to the empty set is infinite. -/\ntheorem hausdorffEdist_empty (ne : s.Nonempty) : hausdorffEdist s ‚àÖ = ‚àû := by\n  rcases ne with ‚ü®x, xs‚ü©\n  have : infEdist x ‚àÖ ‚â§ hausdorffEdist s ‚àÖ := infEdist_le_hausdorffEdist_of_mem xs\n  simpa using this\n\n"}
{"name":"EMetric.nonempty_of_hausdorffEdist_ne_top","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns t : Set Œ±\nhs : s.Nonempty\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n‚ä¢ t.Nonempty","decl":"/-- If a set is at finite Hausdorff edistance of a nonempty set, it is nonempty. -/\ntheorem nonempty_of_hausdorffEdist_ne_top (hs : s.Nonempty) (fin : hausdorffEdist s t ‚â† ‚ä§) :\n    t.Nonempty :=\n  t.eq_empty_or_nonempty.resolve_left fun ht ‚Ü¶ fin (ht.symm ‚ñ∏ hausdorffEdist_empty hs)\n\n"}
{"name":"EMetric.empty_or_nonempty_of_hausdorffEdist_ne_top","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns t : Set Œ±\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n‚ä¢ Or (And (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection)) (And s.Nonempty t.Nonempty)","decl":"theorem empty_or_nonempty_of_hausdorffEdist_ne_top (fin : hausdorffEdist s t ‚â† ‚ä§) :\n    (s = ‚àÖ ‚àß t = ‚àÖ) ‚à® (s.Nonempty ‚àß t.Nonempty) := by\n  rcases s.eq_empty_or_nonempty with hs | hs\n  ¬∑ rcases t.eq_empty_or_nonempty with ht | ht\n    ¬∑ exact Or.inl ‚ü®hs, ht‚ü©\n    ¬∑ rw [hausdorffEdist_comm] at fin\n      exact Or.inr ‚ü®nonempty_of_hausdorffEdist_ne_top ht fin, ht‚ü©\n  ¬∑ exact Or.inr ‚ü®hs, nonempty_of_hausdorffEdist_ne_top hs fin‚ü©\n\n"}
{"name":"Metric.infDist_eq_iInf","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\n‚ä¢ Eq (Metric.infDist x s) (iInf fun y => Dist.dist x ‚Üëy)","decl":"theorem infDist_eq_iInf : infDist x s = ‚®Ö y : s, dist x y := by\n  rw [infDist, infEdist, iInf_subtype', ENNReal.toReal_iInf]\n  ¬∑ simp only [dist_edist]\n  ¬∑ exact fun _ ‚Ü¶ edist_ne_top _ _\n\n"}
{"name":"Metric.infDist_nonneg","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\n‚ä¢ LE.le 0 (Metric.infDist x s)","decl":"/-- The minimal distance is always nonnegative -/\ntheorem infDist_nonneg : 0 ‚â§ infDist x s := toReal_nonneg\n\n"}
{"name":"Metric.infDist_empty","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (Metric.infDist x EmptyCollection.emptyCollection) 0","decl":"/-- The minimal distance to the empty set is 0 (if you want to have the more reasonable\nvalue `‚àû` instead, use `EMetric.infEdist`, which takes values in `‚Ñù‚â•0‚àû`) -/\n@[simp]\ntheorem infDist_empty : infDist x ‚àÖ = 0 := by simp [infDist]\n\n"}
{"name":"Metric.infEdist_ne_top","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\nh : s.Nonempty\n‚ä¢ Ne (EMetric.infEdist x s) Top.top","decl":"/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem infEdist_ne_top (h : s.Nonempty) : infEdist x s ‚â† ‚ä§ := by\n  rcases h with ‚ü®y, hy‚ü©\n  exact ne_top_of_le_ne_top (edist_ne_top _ _) (infEdist_le_edist_of_mem hy)\n\n"}
{"name":"Metric.infEdist_eq_top_iff","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\n‚ä¢ Iff (Eq (EMetric.infEdist x s) Top.top) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem infEdist_eq_top_iff : infEdist x s = ‚àû ‚Üî s = ‚àÖ := by\n  rcases s.eq_empty_or_nonempty with rfl | hs <;> simp [*, Nonempty.ne_empty, infEdist_ne_top]\n\n"}
{"name":"Metric.infDist_zero_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\nh : Membership.mem s x\n‚ä¢ Eq (Metric.infDist x s) 0","decl":"/-- The minimal distance of a point to a set containing it vanishes. -/\ntheorem infDist_zero_of_mem (h : x ‚àà s) : infDist x s = 0 := by\n  simp [infEdist_zero_of_mem h, infDist]\n\n"}
{"name":"Metric.infDist_singleton","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (Metric.infDist x (Singleton.singleton y)) (Dist.dist x y)","decl":"/-- The minimal distance to a singleton is the distance to the unique point in this singleton. -/\n@[simp]\ntheorem infDist_singleton : infDist x {y} = dist x y := by simp [infDist, dist_edist]\n\n"}
{"name":"Metric.infDist_le_dist_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx y : Œ±\nh : Membership.mem s y\n‚ä¢ LE.le (Metric.infDist x s) (Dist.dist x y)","decl":"/-- The minimal distance to a set is bounded by the distance to any point in this set. -/\ntheorem infDist_le_dist_of_mem (h : y ‚àà s) : infDist x s ‚â§ dist x y := by\n  rw [dist_edist, infDist]\n  exact ENNReal.toReal_mono (edist_ne_top _ _) (infEdist_le_edist_of_mem h)\n\n"}
{"name":"Metric.infDist_le_infDist_of_subset","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\nx : Œ±\nh : HasSubset.Subset s t\nhs : s.Nonempty\n‚ä¢ LE.le (Metric.infDist x t) (Metric.infDist x s)","decl":"/-- The minimal distance is monotone with respect to inclusion. -/\ntheorem infDist_le_infDist_of_subset (h : s ‚äÜ t) (hs : s.Nonempty) : infDist x t ‚â§ infDist x s :=\n  ENNReal.toReal_mono (infEdist_ne_top hs) (infEdist_anti h)\n\n"}
{"name":"Metric.infDist_lt_iff","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\nr : Real\nhs : s.Nonempty\n‚ä¢ Iff (LT.lt (Metric.infDist x s) r) (Exists fun y => And (Membership.mem s y) (LT.lt (Dist.dist x y) r))","decl":"/-- The minimal distance to a set `s` is `< r` iff there exists a point in `s` at distance `< r`. -/\ntheorem infDist_lt_iff {r : ‚Ñù} (hs : s.Nonempty) : infDist x s < r ‚Üî ‚àÉ y ‚àà s, dist x y < r := by\n  simp_rw [infDist, ‚Üê ENNReal.lt_ofReal_iff_toReal_lt (infEdist_ne_top hs), infEdist_lt_iff,\n    ENNReal.lt_ofReal_iff_toReal_lt (edist_ne_top _ _), ‚Üê dist_edist]\n\n"}
{"name":"Metric.infDist_le_infDist_add_dist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx y : Œ±\n‚ä¢ LE.le (Metric.infDist x s) (HAdd.hAdd (Metric.infDist y s) (Dist.dist x y))","decl":"/-- The minimal distance from `x` to `s` is bounded by the distance from `y` to `s`, modulo\nthe distance between `x` and `y`. -/\ntheorem infDist_le_infDist_add_dist : infDist x s ‚â§ infDist y s + dist x y := by\n  rw [infDist, infDist, dist_edist]\n  refine ENNReal.toReal_le_add' infEdist_le_infEdist_add_edist ?_ (flip absurd (edist_ne_top _ _))\n  simp only [infEdist_eq_top_iff, imp_self]\n\n"}
{"name":"Metric.not_mem_of_dist_lt_infDist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx y : Œ±\nh : LT.lt (Dist.dist x y) (Metric.infDist x s)\n‚ä¢ Not (Membership.mem s y)","decl":"theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y ‚àâ s := fun hy =>\n  h.not_le <| infDist_le_dist_of_mem hy\n\n"}
{"name":"Metric.disjoint_ball_infDist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\n‚ä¢ Disjoint (Metric.ball x (Metric.infDist x s)) s","decl":"theorem disjoint_ball_infDist : Disjoint (ball x (infDist x s)) s :=\n  disjoint_left.2 fun _y hy => not_mem_of_dist_lt_infDist <| mem_ball'.1 hy\n\n"}
{"name":"Metric.ball_infDist_subset_compl","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\n‚ä¢ HasSubset.Subset (Metric.ball x (Metric.infDist x s)) (HasCompl.compl s)","decl":"theorem ball_infDist_subset_compl : ball x (infDist x s) ‚äÜ s·∂ú :=\n  (disjoint_ball_infDist (s := s)).subset_compl_right\n\n"}
{"name":"Metric.ball_infDist_compl_subset","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\n‚ä¢ HasSubset.Subset (Metric.ball x (Metric.infDist x (HasCompl.compl s))) s","decl":"theorem ball_infDist_compl_subset : ball x (infDist x s·∂ú) ‚äÜ s :=\n  ball_infDist_subset_compl.trans_eq (compl_compl s)\n\n"}
{"name":"Metric.disjoint_closedBall_of_lt_infDist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\nr : Real\nh : LT.lt r (Metric.infDist x s)\n‚ä¢ Disjoint (Metric.closedBall x r) s","decl":"theorem disjoint_closedBall_of_lt_infDist {r : ‚Ñù} (h : r < infDist x s) :\n    Disjoint (closedBall x r) s :=\n  disjoint_ball_infDist.mono_left <| closedBall_subset_ball h\n\n"}
{"name":"Metric.dist_le_infDist_add_diam","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx y : Œ±\nhs : Bornology.IsBounded s\nhy : Membership.mem s y\n‚ä¢ LE.le (Dist.dist x y) (HAdd.hAdd (Metric.infDist x s) (Metric.diam s))","decl":"theorem dist_le_infDist_add_diam (hs : IsBounded s) (hy : y ‚àà s) :\n    dist x y ‚â§ infDist x s + diam s := by\n  rw [infDist, diam, dist_edist]\n  exact toReal_le_add (edist_le_infEdist_add_ediam hy) (infEdist_ne_top ‚ü®y, hy‚ü©) hs.ediam_ne_top\n\n"}
{"name":"Metric.lipschitz_infDist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ LipschitzWith 1 fun x => Metric.infDist x s","decl":"/-- The minimal distance to a set is Lipschitz in point with constant 1 -/\ntheorem lipschitz_infDist_pt : LipschitzWith 1 (infDist ¬∑ s) :=\n  LipschitzWith.of_le_add fun _ _ => infDist_le_infDist_add_dist\n\n"}
{"name":"Metric.uniformContinuous_infDist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ UniformContinuous fun x => Metric.infDist x s","decl":"/-- The minimal distance to a set is uniformly continuous in point -/\ntheorem uniformContinuous_infDist_pt : UniformContinuous (infDist ¬∑ s) :=\n  (lipschitz_infDist_pt s).uniformContinuous\n\n"}
{"name":"Metric.continuous_infDist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Continuous fun x => Metric.infDist x s","decl":"/-- The minimal distance to a set is continuous in point -/\n@[continuity]\ntheorem continuous_infDist_pt : Continuous (infDist ¬∑ s) :=\n  (uniformContinuous_infDist_pt s).continuous\n\n"}
{"name":"Metric.infDist_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\n‚ä¢ Eq (Metric.infDist x (closure s)) (Metric.infDist x s)","decl":"/-- The minimal distances to a set and its closure coincide. -/\ntheorem infDist_closure : infDist x (closure s) = infDist x s := by\n  simp [infDist, infEdist_closure]\n\n"}
{"name":"Metric.infDist_zero_of_mem_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\nhx : Membership.mem (closure s) x\n‚ä¢ Eq (Metric.infDist x s) 0","decl":"/-- If a point belongs to the closure of `s`, then its infimum distance to `s` equals zero.\nThe converse is true provided that `s` is nonempty, see `Metric.mem_closure_iff_infDist_zero`. -/\ntheorem infDist_zero_of_mem_closure (hx : x ‚àà closure s) : infDist x s = 0 := by\n  rw [‚Üê infDist_closure]\n  exact infDist_zero_of_mem hx\n\n"}
{"name":"Metric.mem_closure_iff_infDist_zero","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\nh : s.Nonempty\n‚ä¢ Iff (Membership.mem (closure s) x) (Eq (Metric.infDist x s) 0)","decl":"/-- A point belongs to the closure of `s` iff its infimum distance to this set vanishes. -/\ntheorem mem_closure_iff_infDist_zero (h : s.Nonempty) : x ‚àà closure s ‚Üî infDist x s = 0 := by\n  simp [mem_closure_iff_infEdist_zero, infDist, ENNReal.toReal_eq_zero_iff, infEdist_ne_top h]\n\n"}
{"name":"Metric.infDist_pos_iff_not_mem_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\nhs : s.Nonempty\n‚ä¢ Iff (Not (Membership.mem (closure s) x)) (LT.lt 0 (Metric.infDist x s))","decl":"theorem infDist_pos_iff_not_mem_closure (hs : s.Nonempty) :\n    x ‚àâ closure s ‚Üî 0 < infDist x s :=\n  (mem_closure_iff_infDist_zero hs).not.trans infDist_nonneg.gt_iff_ne.symm\n\n"}
{"name":"IsClosed.mem_iff_infDist_zero","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\nh : IsClosed s\nhs : s.Nonempty\n‚ä¢ Iff (Membership.mem s x) (Eq (Metric.infDist x s) 0)","decl":"/-- Given a closed set `s`, a point belongs to `s` iff its infimum distance to this set vanishes -/\ntheorem _root_.IsClosed.mem_iff_infDist_zero (h : IsClosed s) (hs : s.Nonempty) :\n    x ‚àà s ‚Üî infDist x s = 0 := by rw [‚Üê mem_closure_iff_infDist_zero hs, h.closure_eq]\n\n"}
{"name":"IsClosed.not_mem_iff_infDist_pos","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\nh : IsClosed s\nhs : s.Nonempty\n‚ä¢ Iff (Not (Membership.mem s x)) (LT.lt 0 (Metric.infDist x s))","decl":"/-- Given a closed set `s`, a point belongs to `s` iff its infimum distance to this set vanishes. -/\ntheorem _root_.IsClosed.not_mem_iff_infDist_pos (h : IsClosed s) (hs : s.Nonempty) :\n    x ‚àâ s ‚Üî 0 < infDist x s := by\n  simp [h.mem_iff_infDist_zero hs, infDist_nonneg.gt_iff_ne]\n\n"}
{"name":"Metric.continuousAt_inv_infDist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\nh : Not (Membership.mem (closure s) x)\n‚ä¢ ContinuousAt (fun x => Inv.inv (Metric.infDist x s)) x","decl":"theorem continuousAt_inv_infDist_pt (h : x ‚àâ closure s) :\n    ContinuousAt (fun x ‚Ü¶ (infDist x s)‚Åª¬π) x := by\n  rcases s.eq_empty_or_nonempty with (rfl | hs)\n  ¬∑ simp only [infDist_empty, continuousAt_const]\n  ¬∑ refine (continuous_infDist_pt s).continuousAt.inv‚ÇÄ ?_\n    rwa [Ne, ‚Üê mem_closure_iff_infDist_zero hs]\n\n"}
{"name":"Metric.infDist_image","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nt : Set Œ±\nx : Œ±\nŒ¶ : Œ± ‚Üí Œ≤\nhŒ¶ : Isometry Œ¶\n‚ä¢ Eq (Metric.infDist (Œ¶ x) (Set.image Œ¶ t)) (Metric.infDist x t)","decl":"/-- The infimum distance is invariant under isometries. -/\ntheorem infDist_image (hŒ¶ : Isometry Œ¶) : infDist (Œ¶ x) (Œ¶ '' t) = infDist x t := by\n  simp [infDist, infEdist_image hŒ¶]\n\n"}
{"name":"Metric.infDist_inter_closedBall_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx y : Œ±\nh : Membership.mem s y\n‚ä¢ Eq (Metric.infDist x (Inter.inter s (Metric.closedBall x (Dist.dist y x)))) (Metric.infDist x s)","decl":"theorem infDist_inter_closedBall_of_mem (h : y ‚àà s) :\n    infDist x (s ‚à© closedBall x (dist y x)) = infDist x s := by\n  replace h : y ‚àà s ‚à© closedBall x (dist y x) := ‚ü®h, mem_closedBall.2 le_rfl‚ü©\n  refine le_antisymm ?_ (infDist_le_infDist_of_subset inter_subset_left ‚ü®y, h‚ü©)\n  refine not_lt.1 fun hlt => ?_\n  rcases (infDist_lt_iff ‚ü®y, h.1‚ü©).mp hlt with ‚ü®z, hzs, hz‚ü©\n  rcases le_or_lt (dist z x) (dist y x) with hle | hlt\n  ¬∑ exact hz.not_le (infDist_le_dist_of_mem ‚ü®hzs, hle‚ü©)\n  ¬∑ rw [dist_comm z, dist_comm y] at hlt\n    exact (hlt.trans hz).not_le (infDist_le_dist_of_mem h)\n\n"}
{"name":"IsCompact.exists_infDist_eq_dist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nh : IsCompact s\nhne : s.Nonempty\nx : Œ±\n‚ä¢ Exists fun y => And (Membership.mem s y) (Eq (Metric.infDist x s) (Dist.dist x y))","decl":"theorem _root_.IsCompact.exists_infDist_eq_dist (h : IsCompact s) (hne : s.Nonempty) (x : Œ±) :\n    ‚àÉ y ‚àà s, infDist x s = dist x y :=\n  let ‚ü®y, hys, hy‚ü© := h.exists_infEdist_eq_edist hne x\n  ‚ü®y, hys, by rw [infDist, dist_edist, hy]‚ü©\n\n"}
{"name":"IsClosed.exists_infDist_eq_dist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù¬π : PseudoMetricSpace Œ±\ns : Set Œ±\ninst‚úù : ProperSpace Œ±\nh : IsClosed s\nhne : s.Nonempty\nx : Œ±\n‚ä¢ Exists fun y => And (Membership.mem s y) (Eq (Metric.infDist x s) (Dist.dist x y))","decl":"theorem _root_.IsClosed.exists_infDist_eq_dist [ProperSpace Œ±] (h : IsClosed s) (hne : s.Nonempty)\n    (x : Œ±) : ‚àÉ y ‚àà s, infDist x s = dist x y := by\n  rcases hne with ‚ü®z, hz‚ü©\n  rw [‚Üê infDist_inter_closedBall_of_mem hz]\n  set t := s ‚à© closedBall x (dist z x)\n  have htc : IsCompact t := (isCompact_closedBall x (dist z x)).inter_left h\n  have htne : t.Nonempty := ‚ü®z, hz, mem_closedBall.2 le_rfl‚ü©\n  obtain ‚ü®y, ‚ü®hys, -‚ü©, hyd‚ü© : ‚àÉ y ‚àà t, infDist x t = dist x y := htc.exists_infDist_eq_dist htne x\n  exact ‚ü®y, hys, hyd‚ü©\n\n"}
{"name":"Metric.exists_mem_closure_infDist_eq_dist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù¬π : PseudoMetricSpace Œ±\ns : Set Œ±\ninst‚úù : ProperSpace Œ±\nhne : s.Nonempty\nx : Œ±\n‚ä¢ Exists fun y => And (Membership.mem (closure s) y) (Eq (Metric.infDist x s) (Dist.dist x y))","decl":"theorem exists_mem_closure_infDist_eq_dist [ProperSpace Œ±] (hne : s.Nonempty) (x : Œ±) :\n    ‚àÉ y ‚àà closure s, infDist x s = dist x y := by\n  simpa only [infDist_closure] using isClosed_closure.exists_infDist_eq_dist hne.closure x\n\n"}
{"name":"Metric.coe_infNndist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\n‚ä¢ Eq (‚Üë(Metric.infNndist x s)) (Metric.infDist x s)","decl":"@[simp]\ntheorem coe_infNndist : (infNndist x s : ‚Ñù) = infDist x s :=\n  rfl\n\n"}
{"name":"Metric.lipschitz_infNndist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ LipschitzWith 1 fun x => Metric.infNndist x s","decl":"/-- The minimal distance to a set (as `‚Ñù‚â•0`) is Lipschitz in point with constant 1 -/\ntheorem lipschitz_infNndist_pt (s : Set Œ±) : LipschitzWith 1 fun x => infNndist x s :=\n  LipschitzWith.of_le_add fun _ _ => infDist_le_infDist_add_dist\n\n"}
{"name":"Metric.uniformContinuous_infNndist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ UniformContinuous fun x => Metric.infNndist x s","decl":"/-- The minimal distance to a set (as `‚Ñù‚â•0`) is uniformly continuous in point -/\ntheorem uniformContinuous_infNndist_pt (s : Set Œ±) : UniformContinuous fun x => infNndist x s :=\n  (lipschitz_infNndist_pt s).uniformContinuous\n\n"}
{"name":"Metric.continuous_infNndist_pt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Continuous fun x => Metric.infNndist x s","decl":"/-- The minimal distance to a set (as `‚Ñù‚â•0`) is continuous in point -/\ntheorem continuous_infNndist_pt (s : Set Œ±) : Continuous fun x => infNndist x s :=\n  (uniformContinuous_infNndist_pt s).continuous\n\n"}
{"name":"Metric.hausdorffDist_nonneg","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\n‚ä¢ LE.le 0 (Metric.hausdorffDist s t)","decl":"/-- The Hausdorff distance is nonnegative. -/\ntheorem hausdorffDist_nonneg : 0 ‚â§ hausdorffDist s t := by simp [hausdorffDist]\n\n"}
{"name":"Metric.hausdorffEdist_ne_top_of_nonempty_of_bounded","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\nhs : s.Nonempty\nht : t.Nonempty\nbs : Bornology.IsBounded s\nbt : Bornology.IsBounded t\n‚ä¢ Ne (EMetric.hausdorffEdist s t) Top.top","decl":"/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem hausdorffEdist_ne_top_of_nonempty_of_bounded (hs : s.Nonempty) (ht : t.Nonempty)\n    (bs : IsBounded s) (bt : IsBounded t) : hausdorffEdist s t ‚â† ‚ä§ := by\n  rcases hs with ‚ü®cs, hcs‚ü©\n  rcases ht with ‚ü®ct, hct‚ü©\n  rcases bs.subset_closedBall ct with ‚ü®rs, hrs‚ü©\n  rcases bt.subset_closedBall cs with ‚ü®rt, hrt‚ü©\n  have : hausdorffEdist s t ‚â§ ENNReal.ofReal (max rs rt) := by\n    apply hausdorffEdist_le_of_mem_edist\n    ¬∑ intro x xs\n      exists ct, hct\n      have : dist x ct ‚â§ max rs rt := le_trans (hrs xs) (le_max_left _ _)\n      rwa [edist_dist, ENNReal.ofReal_le_ofReal_iff]\n      exact le_trans dist_nonneg this\n    ¬∑ intro x xt\n      exists cs, hcs\n      have : dist x cs ‚â§ max rs rt := le_trans (hrt xt) (le_max_right _ _)\n      rwa [edist_dist, ENNReal.ofReal_le_ofReal_iff]\n      exact le_trans dist_nonneg this\n  exact ne_top_of_le_ne_top ENNReal.ofReal_ne_top this\n\n"}
{"name":"Metric.hausdorffDist_self_zero","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Eq (Metric.hausdorffDist s s) 0","decl":"/-- The Hausdorff distance between a set and itself is zero. -/\n@[simp]\ntheorem hausdorffDist_self_zero : hausdorffDist s s = 0 := by simp [hausdorffDist]\n\n"}
{"name":"Metric.hausdorffDist_comm","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\n‚ä¢ Eq (Metric.hausdorffDist s t) (Metric.hausdorffDist t s)","decl":"/-- The Hausdorff distances from `s` to `t` and from `t` to `s` coincide. -/\ntheorem hausdorffDist_comm : hausdorffDist s t = hausdorffDist t s := by\n  simp [hausdorffDist, hausdorffEdist_comm]\n\n"}
{"name":"Metric.hausdorffDist_empty","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Eq (Metric.hausdorffDist s EmptyCollection.emptyCollection) 0","decl":"/-- The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable\nvalue `‚àû` instead, use `EMetric.hausdorffEdist`, which takes values in `‚Ñù‚â•0‚àû`). -/\n@[simp]\ntheorem hausdorffDist_empty : hausdorffDist s ‚àÖ = 0 := by\n  rcases s.eq_empty_or_nonempty with h | h\n  ¬∑ simp [h]\n  ¬∑ simp [hausdorffDist, hausdorffEdist_empty h]\n\n"}
{"name":"Metric.hausdorffDist_empty'","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Eq (Metric.hausdorffDist EmptyCollection.emptyCollection s) 0","decl":"/-- The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable\nvalue `‚àû` instead, use `EMetric.hausdorffEdist`, which takes values in `‚Ñù‚â•0‚àû`). -/\n@[simp]\ntheorem hausdorffDist_empty' : hausdorffDist ‚àÖ s = 0 := by simp [hausdorffDist_comm]\n\n"}
{"name":"Metric.hausdorffDist_le_of_infDist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\nr : Real\nhr : LE.le 0 r\nH1 : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí LE.le (Metric.infDist x t) r\nH2 : ‚àÄ (x : Œ±), Membership.mem t x ‚Üí LE.le (Metric.infDist x s) r\n‚ä¢ LE.le (Metric.hausdorffDist s t) r","decl":"/-- Bounding the Hausdorff distance by bounding the distance of any point\nin each set to the other set -/\ntheorem hausdorffDist_le_of_infDist {r : ‚Ñù} (hr : 0 ‚â§ r) (H1 : ‚àÄ x ‚àà s, infDist x t ‚â§ r)\n    (H2 : ‚àÄ x ‚àà t, infDist x s ‚â§ r) : hausdorffDist s t ‚â§ r := by\n  rcases s.eq_empty_or_nonempty with hs | hs\n  ¬∑ rwa [hs, hausdorffDist_empty']\n  rcases t.eq_empty_or_nonempty with ht | ht\n  ¬∑ rwa [ht, hausdorffDist_empty]\n  have : hausdorffEdist s t ‚â§ ENNReal.ofReal r := by\n    apply hausdorffEdist_le_of_infEdist _ _\n    ¬∑ simpa only [infDist, ‚Üê ENNReal.le_ofReal_iff_toReal_le (infEdist_ne_top ht) hr] using H1\n    ¬∑ simpa only [infDist, ‚Üê ENNReal.le_ofReal_iff_toReal_le (infEdist_ne_top hs) hr] using H2\n  exact ENNReal.toReal_le_of_le_ofReal hr this\n\n"}
{"name":"Metric.hausdorffDist_le_of_mem_dist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\nr : Real\nhr : LE.le 0 r\nH1 : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí Exists fun y => And (Membership.mem t y) (LE.le (Dist.dist x y) r)\nH2 : ‚àÄ (x : Œ±), Membership.mem t x ‚Üí Exists fun y => And (Membership.mem s y) (LE.le (Dist.dist x y) r)\n‚ä¢ LE.le (Metric.hausdorffDist s t) r","decl":"/-- Bounding the Hausdorff distance by exhibiting, for any point in each set,\nanother point in the other set at controlled distance -/\ntheorem hausdorffDist_le_of_mem_dist {r : ‚Ñù} (hr : 0 ‚â§ r) (H1 : ‚àÄ x ‚àà s, ‚àÉ y ‚àà t, dist x y ‚â§ r)\n    (H2 : ‚àÄ x ‚àà t, ‚àÉ y ‚àà s, dist x y ‚â§ r) : hausdorffDist s t ‚â§ r := by\n  apply hausdorffDist_le_of_infDist hr\n  ¬∑ intro x xs\n    rcases H1 x xs with ‚ü®y, yt, hy‚ü©\n    exact le_trans (infDist_le_dist_of_mem yt) hy\n  ¬∑ intro x xt\n    rcases H2 x xt with ‚ü®y, ys, hy‚ü©\n    exact le_trans (infDist_le_dist_of_mem ys) hy\n\n"}
{"name":"Metric.hausdorffDist_le_diam","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\nhs : s.Nonempty\nbs : Bornology.IsBounded s\nht : t.Nonempty\nbt : Bornology.IsBounded t\n‚ä¢ LE.le (Metric.hausdorffDist s t) (Metric.diam (Union.union s t))","decl":"/-- The Hausdorff distance is controlled by the diameter of the union. -/\ntheorem hausdorffDist_le_diam (hs : s.Nonempty) (bs : IsBounded s) (ht : t.Nonempty)\n    (bt : IsBounded t) : hausdorffDist s t ‚â§ diam (s ‚à™ t) := by\n  rcases hs with ‚ü®x, xs‚ü©\n  rcases ht with ‚ü®y, yt‚ü©\n  refine hausdorffDist_le_of_mem_dist diam_nonneg ?_ ?_\n  ¬∑ exact fun z hz => ‚ü®y, yt, dist_le_diam_of_mem (bs.union bt) (subset_union_left hz)\n      (subset_union_right yt)‚ü©\n  ¬∑ exact fun z hz => ‚ü®x, xs, dist_le_diam_of_mem (bs.union bt) (subset_union_right hz)\n      (subset_union_left xs)‚ü©\n\n"}
{"name":"Metric.infDist_le_hausdorffDist_of_mem","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\nx : Œ±\nhx : Membership.mem s x\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n‚ä¢ LE.le (Metric.infDist x t) (Metric.hausdorffDist s t)","decl":"/-- The distance to a set is controlled by the Hausdorff distance. -/\ntheorem infDist_le_hausdorffDist_of_mem (hx : x ‚àà s) (fin : hausdorffEdist s t ‚â† ‚ä§) :\n    infDist x t ‚â§ hausdorffDist s t :=\n  toReal_mono fin (infEdist_le_hausdorffEdist_of_mem hx)\n\n"}
{"name":"Metric.exists_dist_lt_of_hausdorffDist_lt","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\nx : Œ±\nr : Real\nh : Membership.mem s x\nH : LT.lt (Metric.hausdorffDist s t) r\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n‚ä¢ Exists fun y => And (Membership.mem t y) (LT.lt (Dist.dist x y) r)","decl":"/-- If the Hausdorff distance is `< r`, any point in one of the sets is at distance\n`< r` of a point in the other set. -/\ntheorem exists_dist_lt_of_hausdorffDist_lt {r : ‚Ñù} (h : x ‚àà s) (H : hausdorffDist s t < r)\n    (fin : hausdorffEdist s t ‚â† ‚ä§) : ‚àÉ y ‚àà t, dist x y < r := by\n  have r0 : 0 < r := lt_of_le_of_lt hausdorffDist_nonneg H\n  have : hausdorffEdist s t < ENNReal.ofReal r := by\n    rwa [hausdorffDist, ‚Üê ENNReal.toReal_ofReal (le_of_lt r0),\n      ENNReal.toReal_lt_toReal fin ENNReal.ofReal_ne_top] at H\n  rcases exists_edist_lt_of_hausdorffEdist_lt h this with ‚ü®y, hy, yr‚ü©\n  rw [edist_dist, ENNReal.ofReal_lt_ofReal_iff r0] at yr\n  exact ‚ü®y, hy, yr‚ü©\n\n"}
{"name":"Metric.exists_dist_lt_of_hausdorffDist_lt'","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\ny : Œ±\nr : Real\nh : Membership.mem t y\nH : LT.lt (Metric.hausdorffDist s t) r\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n‚ä¢ Exists fun x => And (Membership.mem s x) (LT.lt (Dist.dist x y) r)","decl":"/-- If the Hausdorff distance is `< r`, any point in one of the sets is at distance\n`< r` of a point in the other set. -/\ntheorem exists_dist_lt_of_hausdorffDist_lt' {r : ‚Ñù} (h : y ‚àà t) (H : hausdorffDist s t < r)\n    (fin : hausdorffEdist s t ‚â† ‚ä§) : ‚àÉ x ‚àà s, dist x y < r := by\n  rw [hausdorffDist_comm] at H\n  rw [hausdorffEdist_comm] at fin\n  simpa [dist_comm] using exists_dist_lt_of_hausdorffDist_lt h H fin\n\n"}
{"name":"Metric.infDist_le_infDist_add_hausdorffDist","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\nx : Œ±\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n‚ä¢ LE.le (Metric.infDist x t) (HAdd.hAdd (Metric.infDist x s) (Metric.hausdorffDist s t))","decl":"/-- The infimum distance to `s` and `t` are the same, up to the Hausdorff distance\nbetween `s` and `t` -/\ntheorem infDist_le_infDist_add_hausdorffDist (fin : hausdorffEdist s t ‚â† ‚ä§) :\n    infDist x t ‚â§ infDist x s + hausdorffDist s t := by\n  refine toReal_le_add' infEdist_le_infEdist_add_hausdorffEdist (fun h ‚Ü¶ ?_) (flip absurd fin)\n  rw [infEdist_eq_top_iff, ‚Üê not_nonempty_iff_eq_empty] at h ‚ä¢\n  rw [hausdorffEdist_comm] at fin\n  exact mt (nonempty_of_hausdorffEdist_ne_top ¬∑ fin) h\n\n"}
{"name":"Metric.hausdorffDist_image","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\ns t : Set Œ±\nŒ¶ : Œ± ‚Üí Œ≤\nh : Isometry Œ¶\n‚ä¢ Eq (Metric.hausdorffDist (Set.image Œ¶ s) (Set.image Œ¶ t)) (Metric.hausdorffDist s t)","decl":"/-- The Hausdorff distance is invariant under isometries. -/\ntheorem hausdorffDist_image (h : Isometry Œ¶) :\n    hausdorffDist (Œ¶ '' s) (Œ¶ '' t) = hausdorffDist s t := by\n  simp [hausdorffDist, hausdorffEdist_image h]\n\n"}
{"name":"Metric.hausdorffDist_triangle","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t u : Set Œ±\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n‚ä¢ LE.le (Metric.hausdorffDist s u) (HAdd.hAdd (Metric.hausdorffDist s t) (Metric.hausdorffDist t u))","decl":"/-- The Hausdorff distance satisfies the triangle inequality. -/\ntheorem hausdorffDist_triangle (fin : hausdorffEdist s t ‚â† ‚ä§) :\n    hausdorffDist s u ‚â§ hausdorffDist s t + hausdorffDist t u := by\n  refine toReal_le_add' hausdorffEdist_triangle (flip absurd fin) (not_imp_not.1 fun h ‚Ü¶ ?_)\n  rw [hausdorffEdist_comm] at fin\n  exact ne_top_of_le_ne_top (add_ne_top.2 ‚ü®fin, h‚ü©) hausdorffEdist_triangle\n\n"}
{"name":"Metric.hausdorffDist_triangle'","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t u : Set Œ±\nfin : Ne (EMetric.hausdorffEdist t u) Top.top\n‚ä¢ LE.le (Metric.hausdorffDist s u) (HAdd.hAdd (Metric.hausdorffDist s t) (Metric.hausdorffDist t u))","decl":"/-- The Hausdorff distance satisfies the triangle inequality. -/\ntheorem hausdorffDist_triangle' (fin : hausdorffEdist t u ‚â† ‚ä§) :\n    hausdorffDist s u ‚â§ hausdorffDist s t + hausdorffDist t u := by\n  rw [hausdorffEdist_comm] at fin\n  have I : hausdorffDist u s ‚â§ hausdorffDist u t + hausdorffDist t s :=\n    hausdorffDist_triangle fin\n  simpa [add_comm, hausdorffDist_comm] using I\n\n"}
{"name":"Metric.hausdorffDist_self_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Eq (Metric.hausdorffDist s (closure s)) 0","decl":"/-- The Hausdorff distance between a set and its closure vanishes. -/\n@[simp]\ntheorem hausdorffDist_self_closure : hausdorffDist s (closure s) = 0 := by simp [hausdorffDist]\n\n"}
{"name":"Metric.hausdorffDist_closure‚ÇÅ","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\n‚ä¢ Eq (Metric.hausdorffDist (closure s) t) (Metric.hausdorffDist s t)","decl":"/-- Replacing a set by its closure does not change the Hausdorff distance. -/\n@[simp]\ntheorem hausdorffDist_closure‚ÇÅ : hausdorffDist (closure s) t = hausdorffDist s t := by\n  simp [hausdorffDist]\n\n"}
{"name":"Metric.hausdorffDist_closure‚ÇÇ","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\n‚ä¢ Eq (Metric.hausdorffDist s (closure t)) (Metric.hausdorffDist s t)","decl":"/-- Replacing a set by its closure does not change the Hausdorff distance. -/\n@[simp]\ntheorem hausdorffDist_closure‚ÇÇ : hausdorffDist s (closure t) = hausdorffDist s t := by\n  simp [hausdorffDist]\n\n"}
{"name":"Metric.hausdorffDist_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\n‚ä¢ Eq (Metric.hausdorffDist (closure s) (closure t)) (Metric.hausdorffDist s t)","decl":"/-- The Hausdorff distances between two sets and their closures coincide. -/\ntheorem hausdorffDist_closure : hausdorffDist (closure s) (closure t) = hausdorffDist s t := by\n  simp [hausdorffDist]\n\n"}
{"name":"Metric.hausdorffDist_zero_iff_closure_eq_closure","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n‚ä¢ Iff (Eq (Metric.hausdorffDist s t) 0) (Eq (closure s) (closure t))","decl":"/-- Two sets are at zero Hausdorff distance if and only if they have the same closures. -/\ntheorem hausdorffDist_zero_iff_closure_eq_closure (fin : hausdorffEdist s t ‚â† ‚ä§) :\n    hausdorffDist s t = 0 ‚Üî closure s = closure t := by\n  simp [‚Üê hausdorffEdist_zero_iff_closure_eq_closure, hausdorffDist,\n    ENNReal.toReal_eq_zero_iff, fin]\n\n"}
{"name":"IsClosed.hausdorffDist_zero_iff_eq","module":"Mathlib.Topology.MetricSpace.HausdorffDistance","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns t : Set Œ±\nhs : IsClosed s\nht : IsClosed t\nfin : Ne (EMetric.hausdorffEdist s t) Top.top\n‚ä¢ Iff (Eq (Metric.hausdorffDist s t) 0) (Eq s t)","decl":"/-- Two closed sets are at zero Hausdorff distance if and only if they coincide. -/\ntheorem _root_.IsClosed.hausdorffDist_zero_iff_eq (hs : IsClosed s) (ht : IsClosed t)\n    (fin : hausdorffEdist s t ‚â† ‚ä§) : hausdorffDist s t = 0 ‚Üî s = t := by\n  simp [‚Üê hausdorffEdist_zero_iff_eq_of_closed hs ht, hausdorffDist, ENNReal.toReal_eq_zero_iff,\n    fin]\n\n"}
