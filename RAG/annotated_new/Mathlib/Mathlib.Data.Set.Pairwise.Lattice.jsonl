{"name":"Set.pairwise_iUnion","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\nκ : Sort u_4\nr : α → α → Prop\nf : κ → Set α\nh : Directed (fun x1 x2 => HasSubset.Subset x1 x2) f\n⊢ Iff ((Set.iUnion fun n => f n).Pairwise r) (∀ (n : κ), (f n).Pairwise r)","decl":"theorem pairwise_iUnion {f : κ → Set α} (h : Directed (· ⊆ ·) f) :\n    (⋃ n, f n).Pairwise r ↔ ∀ n, (f n).Pairwise r := by\n  constructor\n  · intro H n\n    exact Pairwise.mono (subset_iUnion _ _) H\n  · intro H i hi j hj hij\n    rcases mem_iUnion.1 hi with ⟨m, hm⟩\n    rcases mem_iUnion.1 hj with ⟨n, hn⟩\n    rcases h m n with ⟨p, mp, np⟩\n    exact H p (mp hm) (np hn) hij\n\n"}
{"name":"Set.pairwise_sUnion","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set (Set α)\nh : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) s\n⊢ Iff (s.sUnion.Pairwise r) (∀ (a : Set α), Membership.mem s a → a.Pairwise r)","decl":"theorem pairwise_sUnion {r : α → α → Prop} {s : Set (Set α)} (h : DirectedOn (· ⊆ ·) s) :\n    (⋃₀ s).Pairwise r ↔ ∀ a ∈ s, Set.Pairwise a r := by\n  rw [sUnion_eq_iUnion, pairwise_iUnion h.directed_val, SetCoe.forall]\n\n"}
{"name":"Set.pairwiseDisjoint_iUnion","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\nι : Type u_2\nι' : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\nf : ι → α\ng : ι' → Set ι\nh : Directed (fun x1 x2 => HasSubset.Subset x1 x2) g\n⊢ Iff ((Set.iUnion fun n => g n).PairwiseDisjoint f) (∀ ⦃n : ι'⦄, (g n).PairwiseDisjoint f)","decl":"theorem pairwiseDisjoint_iUnion {g : ι' → Set ι} (h : Directed (· ⊆ ·) g) :\n    (⋃ n, g n).PairwiseDisjoint f ↔ ∀ ⦃n⦄, (g n).PairwiseDisjoint f :=\n  pairwise_iUnion h\n\n"}
{"name":"Set.pairwiseDisjoint_sUnion","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\nf : ι → α\ns : Set (Set ι)\nh : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) s\n⊢ Iff (s.sUnion.PairwiseDisjoint f) (∀ ⦃a : Set ι⦄, Membership.mem s a → a.PairwiseDisjoint f)","decl":"theorem pairwiseDisjoint_sUnion {s : Set (Set ι)} (h : DirectedOn (· ⊆ ·) s) :\n    (⋃₀ s).PairwiseDisjoint f ↔ ∀ ⦃a⦄, a ∈ s → Set.PairwiseDisjoint a f :=\n  pairwise_sUnion h\n\n"}
{"name":"Set.PairwiseDisjoint.biUnion","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\nι : Type u_2\nι' : Type u_3\ninst✝ : CompleteLattice α\ns : Set ι'\ng : ι' → Set ι\nf : ι → α\nhs : s.PairwiseDisjoint fun i' => iSup fun i => iSup fun h => f i\nhg : ∀ (i : ι'), Membership.mem s i → (g i).PairwiseDisjoint f\n⊢ (Set.iUnion fun i => Set.iUnion fun h => g i).PairwiseDisjoint f","decl":"/-- Bind operation for `Set.PairwiseDisjoint`. If you want to only consider finsets of indices, you\ncan use `Set.PairwiseDisjoint.biUnion_finset`. -/\ntheorem PairwiseDisjoint.biUnion {s : Set ι'} {g : ι' → Set ι} {f : ι → α}\n    (hs : s.PairwiseDisjoint fun i' : ι' => ⨆ i ∈ g i', f i)\n    (hg : ∀ i ∈ s, (g i).PairwiseDisjoint f) : (⋃ i ∈ s, g i).PairwiseDisjoint f := by\n  rintro a ha b hb hab\n  simp_rw [Set.mem_iUnion] at ha hb\n  obtain ⟨c, hc, ha⟩ := ha\n  obtain ⟨d, hd, hb⟩ := hb\n  obtain hcd | hcd := eq_or_ne (g c) (g d)\n  · exact hg d hd (hcd ▸ ha) hb hab\n  -- Porting note: the elaborator couldn't figure out `f` here.\n  · exact (hs hc hd <| ne_of_apply_ne _ hcd).mono\n      (le_iSup₂ (f := fun i (_ : i ∈ g c) => f i) a ha)\n      (le_iSup₂ (f := fun i (_ : i ∈ g d) => f i) b hb)\n\n"}
{"name":"Set.PairwiseDisjoint.prod_left","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\nι : Type u_2\nι' : Type u_3\ninst✝ : CompleteLattice α\ns : Set ι\nt : Set ι'\nf : Prod ι ι' → α\nhs : s.PairwiseDisjoint fun i => iSup fun i' => iSup fun h => f { fst := i, snd := i' }\nht : t.PairwiseDisjoint fun i' => iSup fun i => iSup fun h => f { fst := i, snd := i' }\n⊢ (SProd.sprod s t).PairwiseDisjoint f","decl":"/-- If the suprema of columns are pairwise disjoint and suprema of rows as well, then everything is\npairwise disjoint. Not to be confused with `Set.PairwiseDisjoint.prod`. -/\ntheorem PairwiseDisjoint.prod_left {f : ι × ι' → α}\n    (hs : s.PairwiseDisjoint fun i => ⨆ i' ∈ t, f (i, i'))\n    (ht : t.PairwiseDisjoint fun i' => ⨆ i ∈ s, f (i, i')) :\n    (s ×ˢ t : Set (ι × ι')).PairwiseDisjoint f := by\n  rintro ⟨i, i'⟩ hi ⟨j, j'⟩ hj h\n  rw [mem_prod] at hi hj\n  obtain rfl | hij := eq_or_ne i j\n  · refine (ht hi.2 hj.2 <| (Prod.mk.inj_left _).ne_iff.1 h).mono ?_ ?_\n    · convert le_iSup₂ (α := α) i hi.1; rfl\n    · convert le_iSup₂ (α := α) i hj.1; rfl\n  · refine (hs hi.1 hj.1 hij).mono ?_ ?_\n    · convert le_iSup₂ (α := α) i' hi.2; rfl\n    · convert le_iSup₂ (α := α) j' hj.2; rfl\n\n"}
{"name":"Set.pairwiseDisjoint_prod_left","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\nι : Type u_2\nι' : Type u_3\ninst✝ : Order.Frame α\ns : Set ι\nt : Set ι'\nf : Prod ι ι' → α\n⊢ Iff ((SProd.sprod s t).PairwiseDisjoint f) (And (s.PairwiseDisjoint fun i => iSup fun i' => iSup fun h => f { fst := i, snd := i' }) (t.PairwiseDisjoint fun i' => iSup fun i => iSup fun h => f { fst := i, snd := i' }))","decl":"theorem pairwiseDisjoint_prod_left {s : Set ι} {t : Set ι'} {f : ι × ι' → α} :\n    (s ×ˢ t : Set (ι × ι')).PairwiseDisjoint f ↔\n      (s.PairwiseDisjoint fun i => ⨆ i' ∈ t, f (i, i')) ∧\n        t.PairwiseDisjoint fun i' => ⨆ i ∈ s, f (i, i') := by\n  refine\n      ⟨fun h => ⟨fun i hi j hj hij => ?_, fun i hi j hj hij => ?_⟩, fun h => h.1.prod_left h.2⟩ <;>\n    simp_rw [Function.onFun, iSup_disjoint_iff, disjoint_iSup_iff] <;>\n    intro i' hi' j' hj'\n  · exact h (mk_mem_prod hi hi') (mk_mem_prod hj hj') (ne_of_apply_ne Prod.fst hij)\n  · exact h (mk_mem_prod hi' hi) (mk_mem_prod hj' hj) (ne_of_apply_ne Prod.snd hij)\n\n"}
{"name":"Set.biUnion_diff_biUnion_eq","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\nι : Type u_2\ns t : Set ι\nf : ι → Set α\nh : (Union.union s t).PairwiseDisjoint f\n⊢ Eq (SDiff.sdiff (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => f i)) (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem biUnion_diff_biUnion_eq {s t : Set ι} {f : ι → Set α} (h : (s ∪ t).PairwiseDisjoint f) :\n    ((⋃ i ∈ s, f i) \\ ⋃ i ∈ t, f i) = ⋃ i ∈ s \\ t, f i := by\n  refine\n    (biUnion_diff_biUnion_subset f s t).antisymm\n      (iUnion₂_subset fun i hi a ha => (mem_diff _).2 ⟨mem_biUnion hi.1 ha, ?_⟩)\n  rw [mem_iUnion₂]; rintro ⟨j, hj, haj⟩\n  exact (h (Or.inl hi.1) (Or.inr hj) (ne_of_mem_of_not_mem hj hi.2).symm).le_bot ⟨ha, haj⟩\n\n\n"}
{"name":"Set.pairwiseDisjoint_iff","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\nι : Type u_2\nf : ι → Set α\ns : Set ι\n⊢ Iff (s.PairwiseDisjoint f) (∀ ⦃i : ι⦄, Membership.mem s i → ∀ ⦃j : ι⦄, Membership.mem s j → (Inter.inter (f i) (f j)).Nonempty → Eq i j)","decl":"lemma Set.pairwiseDisjoint_iff :\n    s.PairwiseDisjoint f ↔ ∀ ⦃i⦄, i ∈ s → ∀ ⦃j⦄, j ∈ s → (f i ∩ f j).Nonempty → i = j := by\n  simp [Set.PairwiseDisjoint, Set.Pairwise, Function.onFun, not_imp_comm (a := _ = _),\n    not_disjoint_iff_nonempty_inter]\n\n"}
{"name":"Set.pairwiseDisjoint_pair_insert","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\ns : Set α\na : α\nha : Not (Membership.mem s a)\n⊢ s.powerset.PairwiseDisjoint fun t => Insert.insert t (Singleton.singleton (Insert.insert a t))","decl":"lemma Set.pairwiseDisjoint_pair_insert {s : Set α} {a : α} (ha : a ∉ s) :\n    s.powerset.PairwiseDisjoint fun t ↦ ({t, insert a t} : Set (Set α)) := by\n  rw [pairwiseDisjoint_iff]\n  rintro i hi j hj\n  have := insert_erase_invOn.2.injOn (not_mem_subset hi ha) (not_mem_subset hj ha)\n  aesop (add simp [Set.Nonempty, Set.subset_def])\n\n"}
{"name":"Set.PairwiseDisjoint.subset_of_biUnion_subset_biUnion","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\nι : Type u_2\nf : ι → Set α\ns t : Set ι\nh₀ : (Union.union s t).PairwiseDisjoint f\nh₁ : ∀ (i : ι), Membership.mem s i → (f i).Nonempty\nh : HasSubset.Subset (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => f i)\n⊢ HasSubset.Subset s t","decl":"theorem Set.PairwiseDisjoint.subset_of_biUnion_subset_biUnion (h₀ : (s ∪ t).PairwiseDisjoint f)\n    (h₁ : ∀ i ∈ s, (f i).Nonempty) (h : ⋃ i ∈ s, f i ⊆ ⋃ i ∈ t, f i) : s ⊆ t := by\n  rintro i hi\n  obtain ⟨a, hai⟩ := h₁ i hi\n  obtain ⟨j, hj, haj⟩ := mem_iUnion₂.1 (h <| mem_iUnion₂_of_mem hi hai)\n  rwa [h₀.eq (subset_union_left hi) (subset_union_right hj)\n      (not_disjoint_iff.2 ⟨a, hai, haj⟩)]\n\n"}
{"name":"Pairwise.subset_of_biUnion_subset_biUnion","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\nι : Type u_2\nf : ι → Set α\ns t : Set ι\nh₀ : Pairwise (Function.onFun Disjoint f)\nh₁ : ∀ (i : ι), Membership.mem s i → (f i).Nonempty\nh : HasSubset.Subset (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => f i)\n⊢ HasSubset.Subset s t","decl":"theorem Pairwise.subset_of_biUnion_subset_biUnion (h₀ : Pairwise (Disjoint on f))\n    (h₁ : ∀ i ∈ s, (f i).Nonempty) (h : ⋃ i ∈ s, f i ⊆ ⋃ i ∈ t, f i) : s ⊆ t :=\n  Set.PairwiseDisjoint.subset_of_biUnion_subset_biUnion (h₀.set_pairwise _) h₁ h\n\n"}
{"name":"Pairwise.biUnion_injective","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\nι : Type u_2\nf : ι → Set α\nh₀ : Pairwise (Function.onFun Disjoint f)\nh₁ : ∀ (i : ι), (f i).Nonempty\n⊢ Function.Injective fun s => Set.iUnion fun i => Set.iUnion fun h => f i","decl":"theorem Pairwise.biUnion_injective (h₀ : Pairwise (Disjoint on f)) (h₁ : ∀ i, (f i).Nonempty) :\n    Injective fun s : Set ι => ⋃ i ∈ s, f i := fun _s _t h =>\n  ((h₀.subset_of_biUnion_subset_biUnion fun _ _ => h₁ _) <| h.subset).antisymm <|\n    (h₀.subset_of_biUnion_subset_biUnion fun _ _ => h₁ _) <| h.superset\n\n"}
{"name":"pairwiseDisjoint_unique","module":"Mathlib.Data.Set.Pairwise.Lattice","initialProofState":"α : Type u_1\nι : Type u_2\nf : ι → Set α\ns : Set ι\ny : α\nh_disjoint : s.PairwiseDisjoint f\nhy : Membership.mem (Set.iUnion fun i => Set.iUnion fun h => f i) y\n⊢ ExistsUnique fun i => And (Membership.mem s i) (Membership.mem (f i) y)","decl":"/-- In a disjoint union we can identify the unique set an element belongs to. -/\ntheorem pairwiseDisjoint_unique {y : α}\n    (h_disjoint : PairwiseDisjoint s f)\n    (hy : y ∈ (⋃ i ∈ s, f i)) : ∃! i, i ∈ s ∧ y ∈ f i := by\n  refine existsUnique_of_exists_of_unique ?ex ?unique\n  · simpa only [mem_iUnion, exists_prop] using hy\n  · rintro i j ⟨his, hi⟩ ⟨hjs, hj⟩\n    exact h_disjoint.elim his hjs <| not_disjoint_iff.mpr ⟨y, ⟨hi, hj⟩⟩\n\n"}
