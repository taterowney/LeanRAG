{"name":"Module.End.eigenspace_aeval_polynomial_degree_1","module":"Mathlib.LinearAlgebra.Eigenspace.Minpoly","initialProofState":"K : Type v\nV : Type w\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : Module.End K V\nq : Polynomial K\nhq : Eq q.degree 1\n⊢ Eq (f.eigenspace (HDiv.hDiv (Neg.neg (q.coeff 0)) q.leadingCoeff)) (LinearMap.ker ((Polynomial.aeval f) q))","decl":"theorem eigenspace_aeval_polynomial_degree_1 (f : End K V) (q : K[X]) (hq : degree q = 1) :\n    eigenspace f (-q.coeff 0 / q.leadingCoeff) = LinearMap.ker (aeval f q) :=\n  calc\n    eigenspace f (-q.coeff 0 / q.leadingCoeff)\n    _ = LinearMap.ker (q.leadingCoeff • f - algebraMap K (End K V) (-q.coeff 0)) := by\n          rw [eigenspace_div]\n          intro h\n          rw [leadingCoeff_eq_zero_iff_deg_eq_bot.1 h] at hq\n          cases hq\n    _ = LinearMap.ker (aeval f (C q.leadingCoeff * X + C (q.coeff 0))) := by\n          rw [C_mul', aeval_def]; simp [algebraMap, Algebra.algebraMap]\n    _ = LinearMap.ker (aeval f q) := by rwa [← eq_X_add_C_of_degree_eq_one]\n\n"}
{"name":"Module.End.ker_aeval_ring_hom'_unit_polynomial","module":"Mathlib.LinearAlgebra.Eigenspace.Minpoly","initialProofState":"K : Type v\nV : Type w\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : Module.End K V\nc : Units (Polynomial K)\n⊢ Eq (LinearMap.ker ((Polynomial.aeval f) ↑c)) Bot.bot","decl":"theorem ker_aeval_ring_hom'_unit_polynomial (f : End K V) (c : K[X]ˣ) :\n    LinearMap.ker (aeval f (c : K[X])) = ⊥ := by\n  rw [Polynomial.eq_C_of_degree_eq_zero (degree_coe_units c)]\n  simp only [aeval_def, eval₂_C]\n  apply ker_algebraMap_end\n  apply coeff_coe_units_zero_ne_zero c\n\n"}
{"name":"Module.End.aeval_apply_of_hasEigenvector","module":"Mathlib.LinearAlgebra.Eigenspace.Minpoly","initialProofState":"K : Type v\nV : Type w\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : Module.End K V\np : Polynomial K\nμ : K\nx : V\nh : f.HasEigenvector μ x\n⊢ Eq (((Polynomial.aeval f) p) x) (HSMul.hSMul (Polynomial.eval μ p) x)","decl":"theorem aeval_apply_of_hasEigenvector {f : End K V} {p : K[X]} {μ : K} {x : V}\n    (h : f.HasEigenvector μ x) : aeval f p x = p.eval μ • x := by\n  refine p.induction_on ?_ ?_ ?_\n  · intro a; simp [Module.algebraMap_end_apply]\n  · intro p q hp hq; simp [hp, hq, add_smul]\n  · intro n a hna\n    rw [mul_comm, pow_succ', mul_assoc, map_mul, LinearMap.mul_apply, mul_comm, hna]\n    simp only [mem_eigenspace_iff.1 h.1, smul_smul, aeval_X, eval_mul, eval_C, eval_pow, eval_X,\n      LinearMap.map_smulₛₗ, RingHom.id_apply, mul_comm]\n\n"}
{"name":"Module.End.isRoot_of_hasEigenvalue","module":"Mathlib.LinearAlgebra.Eigenspace.Minpoly","initialProofState":"K : Type v\nV : Type w\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : Module.End K V\nμ : K\nh : f.HasEigenvalue μ\n⊢ (minpoly K f).IsRoot μ","decl":"theorem isRoot_of_hasEigenvalue {f : End K V} {μ : K} (h : f.HasEigenvalue μ) :\n    (minpoly K f).IsRoot μ := by\n  rcases (Submodule.ne_bot_iff _).1 h with ⟨w, ⟨H, ne0⟩⟩\n  refine Or.resolve_right (smul_eq_zero.1 ?_) ne0\n  simp [← aeval_apply_of_hasEigenvector ⟨H, ne0⟩, minpoly.aeval K f]\n\n"}
{"name":"Module.End.hasEigenvalue_of_isRoot","module":"Mathlib.LinearAlgebra.Eigenspace.Minpoly","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nμ : K\nh : (minpoly K f).IsRoot μ\n⊢ f.HasEigenvalue μ","decl":"theorem hasEigenvalue_of_isRoot (h : (minpoly K f).IsRoot μ) : f.HasEigenvalue μ := by\n  cases' dvd_iff_isRoot.2 h with p hp\n  rw [hasEigenvalue_iff, eigenspace_def]\n  intro con\n  cases' (LinearMap.isUnit_iff_ker_eq_bot _).2 con with u hu\n  have p_ne_0 : p ≠ 0 := by\n    intro con\n    apply minpoly.ne_zero (Algebra.IsIntegral.isIntegral (R := K) f)\n    rw [hp, con, mul_zero]\n  have : (aeval f) p = 0 := by\n    have h_aeval := minpoly.aeval K f\n    revert h_aeval\n    simp [hp, ← hu, Algebra.algebraMap_eq_smul_one]\n  have h_deg := minpoly.degree_le_of_ne_zero K f p_ne_0 this\n  rw [hp, degree_mul, degree_X_sub_C, Polynomial.degree_eq_natDegree p_ne_0] at h_deg\n  norm_cast at h_deg\n  omega\n\n"}
{"name":"Module.End.hasEigenvalue_iff_isRoot","module":"Mathlib.LinearAlgebra.Eigenspace.Minpoly","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\nμ : K\n⊢ Iff (f.HasEigenvalue μ) ((minpoly K f).IsRoot μ)","decl":"theorem hasEigenvalue_iff_isRoot : f.HasEigenvalue μ ↔ (minpoly K f).IsRoot μ :=\n  ⟨isRoot_of_hasEigenvalue, hasEigenvalue_of_isRoot⟩\n\n"}
{"name":"Module.End.finite_hasEigenvalue","module":"Mathlib.LinearAlgebra.Eigenspace.Minpoly","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\n⊢ Set.Finite f.HasEigenvalue","decl":"lemma finite_hasEigenvalue : Set.Finite f.HasEigenvalue := by\n  have h : minpoly K f ≠ 0 := minpoly.ne_zero (Algebra.IsIntegral.isIntegral (R := K) f)\n  convert (minpoly K f).rootSet_finite K\n  ext μ\n  change f.HasEigenvalue μ ↔ _\n  rw [hasEigenvalue_iff_isRoot, mem_rootSet_of_ne h, IsRoot, coe_aeval_eq_eval]\n\n"}
{"name":"Module.End.finite_spectrum","module":"Mathlib.LinearAlgebra.Eigenspace.Minpoly","initialProofState":"K : Type v\nV : Type w\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : Module.End K V\n⊢ (spectrum K f).Finite","decl":"/-- An endomorphism of a finite-dimensional vector space has a finite spectrum. -/\ntheorem Module.End.finite_spectrum {K : Type v} {V : Type w} [Field K] [AddCommGroup V]\n    [Module K V] [FiniteDimensional K V] (f : Module.End K V) :\n    Set.Finite (spectrum K f) := by\n  convert f.finite_hasEigenvalue\n  ext f x\n  exact Module.End.hasEigenvalue_iff_mem_spectrum.symm\n\n"}
{"name":"Matrix.finite_spectrum","module":"Mathlib.LinearAlgebra.Eigenspace.Minpoly","initialProofState":"n : Type u_1\nR : Type u_2\ninst✝² : Field R\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n R\n⊢ (spectrum R A).Finite","decl":"/-- An n x n matrix over a field has a finite spectrum. -/\ntheorem Matrix.finite_spectrum (A : Matrix n n R) : Set.Finite (spectrum R A) := by\n  rw [← AlgEquiv.spectrum_eq (Matrix.toLinAlgEquiv <| Pi.basisFun R n) A]\n  exact Module.End.finite_spectrum _\n\n"}
{"name":"Matrix.instFiniteSpectrum","module":"Mathlib.LinearAlgebra.Eigenspace.Minpoly","initialProofState":"n : Type u_1\nR : Type u_2\ninst✝² : Field R\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nA : Matrix n n R\n⊢ Finite ↑(spectrum R A)","decl":"instance Matrix.instFiniteSpectrum (A : Matrix n n R) : Finite (spectrum R A) :=\n  Set.finite_coe_iff.mpr (Matrix.finite_spectrum A)\n\n"}
