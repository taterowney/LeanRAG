{"name":"Finpartition.equitabilise_aux","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Equitabilise","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nm a b : Nat\nP : Finpartition s\nhs : Eq (HAdd.hAdd (HMul.hMul a m) (HMul.hMul b (HAdd.hAdd m 1))) s.card\n⊢ Exists fun Q => And (∀ (x : Finset α), Membership.mem Q.parts x → Or (Eq x.card m) (Eq x.card (HAdd.hAdd m 1))) (And (∀ (x : Finset α), Membership.mem P.parts x → LE.le (SDiff.sdiff x ((Finset.filter (fun y => HasSubset.Subset y x) Q.parts).biUnion id)).card m) (Eq (Finset.filter (fun i => Eq i.card (HAdd.hAdd m 1)) Q.parts).card b))","decl":"/-- Given a partition `P` of `s`, as well as a proof that `a * m + b * (m + 1) = #s`, we can\nfind a new partition `Q` of `s` where each part has size `m` or `m + 1`, every part of `P` is the\nunion of parts of `Q` plus at most `m` extra elements, there are `b` parts of size `m + 1` and\n(provided `m > 0`, because a partition does not have parts of size `0`) there are `a` parts of size\n`m` and hence `a + b` parts in total. -/\ntheorem equitabilise_aux (hs : a * m + b * (m + 1) = #s) :\n    ∃ Q : Finpartition s,\n      (∀ x : Finset α, x ∈ Q.parts → #x = m ∨ #x = m + 1) ∧\n        (∀ x, x ∈ P.parts → #(x \\ {y ∈ Q.parts | y ⊆ x}.biUnion id) ≤ m) ∧\n          #{i ∈ Q.parts | #i = m + 1} = b := by\n  -- Get rid of the easy case `m = 0`\n  obtain rfl | m_pos := m.eq_zero_or_pos\n  · refine ⟨⊥, by simp, ?_, by simpa [Finset.filter_true_of_mem] using hs.symm⟩\n    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id,\n      and_assoc, sdiff_eq_empty_iff_subset, subset_iff]\n    exact fun x hx a ha =>\n      ⟨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _⟩\n  -- Prove the case `m > 0` by strong induction on `s`\n  induction' s using Finset.strongInduction with s ih generalizing a b\n  -- If `a = b = 0`, then `s = ∅` and we can partition into zero parts\n  by_cases hab : a = 0 ∧ b = 0\n  · simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs\n    subst hs\n    -- Porting note: to synthesize `Finpartition ∅`, `have` is required\n    have : P = Finpartition.empty _ := Unique.eq_default (α := Finpartition ⊥) P\n    exact ⟨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]⟩\n  simp_rw [not_and_or, ← Ne.eq_def, ← pos_iff_ne_zero] at hab\n  -- `n` will be the size of the smallest part\n  set n := if 0 < a then m else m + 1 with hn\n  -- Some easy facts about it\n  obtain ⟨hn₀, hn₁, hn₂, hn₃⟩ : 0 < n ∧ n ≤ m + 1 ∧ n ≤ a * m + b * (m + 1) ∧\n      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = #s - n := by\n    rw [hn, ← hs]\n    split_ifs with h <;> rw [tsub_mul, one_mul]\n    · refine ⟨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ ‹0 < a›), ?_⟩\n      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]\n    · refine ⟨succ_pos', le_rfl,\n        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left ‹¬0 < a›), ?_⟩\n      rw [← add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left ‹¬0 < a›)]\n  /- We will call the inductive hypothesis on a partition of `s \\ t` for a carefully chosen `t ⊆ s`.\n    To decide which, however, we must distinguish the case where all parts of `P` have size `m` (in\n    which case we take `t` to be an arbitrary subset of `s` of size `n`) from the case where at\n    least one part `u` of `P` has size `m + 1` (in which case we take `t` to be an arbitrary subset\n    of `u` of size `n`). The rest of each branch is just tedious calculations to satisfy the\n    induction hypothesis. -/\n  by_cases h : ∀ u ∈ P.parts, #u < m + 1\n  · obtain ⟨t, hts, htn⟩ := exists_subset_card_eq (hn₂.trans_eq hs)\n    have ht : t.Nonempty := by rwa [← card_pos, htn]\n    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = #(s \\ t) := by\n      rw [card_sdiff ‹t ⊆ s›, htn, hn₃]\n    obtain ⟨R, hR₁, _, hR₃⟩ :=\n      @ih (s \\ t) (sdiff_ssubset hts ‹t.Nonempty›) (if 0 < a then a - 1 else a)\n        (if 0 < a then b else b - 1) (P.avoid t) hcard\n    refine ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_⟩\n    · simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hR₁, htn, hn]\n      exact ite_eq_or_eq _ _ _\n    · exact fun x hx => (card_le_card sdiff_subset).trans (Nat.lt_succ_iff.1 <| h _ hx)\n    simp_rw [extend_parts, filter_insert, htn, n, m.succ_ne_self.symm.ite_eq_right_iff]\n    split_ifs with ha\n    · rw [hR₃, if_pos ha]\n    rw [card_insert_of_not_mem, hR₃, if_neg ha, tsub_add_cancel_of_le]\n    · exact hab.resolve_left ha\n    · intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)\n  push_neg at h\n  obtain ⟨u, hu₁, hu₂⟩ := h\n  obtain ⟨t, htu, htn⟩ := exists_subset_card_eq (hn₁.trans hu₂)\n  have ht : t.Nonempty := by rwa [← card_pos, htn]\n  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = #(s \\ t) := by\n    rw [card_sdiff (htu.trans <| P.le hu₁), htn, hn₃]\n  obtain ⟨R, hR₁, hR₂, hR₃⟩ :=\n    @ih (s \\ t) (sdiff_ssubset (htu.trans <| P.le hu₁) ht) (if 0 < a then a - 1 else a)\n      (if 0 < a then b else b - 1) (P.avoid t) hcard\n  refine\n    ⟨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le hu₁), ?_, ?_, ?_⟩\n  · simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hR₁, htn, hn]\n    exact ite_eq_or_eq _ _ _\n  · conv in _ ∈ _ => rw [← insert_erase hu₁]\n    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne, extend_parts]\n    refine ⟨?_, fun x hx => (card_le_card ?_).trans <| hR₂ x ?_⟩\n    · simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id]\n      obtain rfl | hut := eq_or_ne u t\n      · rw [sdiff_eq_empty_iff_subset.2 subset_union_left]\n        exact bot_le\n      refine\n        (card_le_card fun i => ?_).trans\n          (hR₂ (u \\ t) <| P.mem_avoid.2 ⟨u, hu₁, fun i => hut <| i.antisymm htu, rfl⟩)\n      simpa using fun hi₁ hi₂ hi₃ =>\n        ⟨⟨hi₁, hi₂⟩, fun x hx hx' => hi₃ _ hx <| hx'.trans sdiff_subset⟩\n    · apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)\n      exact filter_subset_filter _ (subset_insert _ _)\n    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]\n    exact\n      ⟨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,\n        (disjoint_of_subset_right htu <|\n            P.disjoint (mem_of_mem_erase hx) hu₁ <| ne_of_mem_erase hx).sdiff_eq_left⟩\n  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]\n  split_ifs with h\n  · rw [hR₃, if_pos h]\n  · rw [card_insert_of_not_mem, hR₃, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]\n    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)\n\n"}
{"name":"Finpartition.card_eq_of_mem_parts_equitabilise","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Equitabilise","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm a b : Nat\nP : Finpartition s\nh : Eq (HAdd.hAdd (HMul.hMul a m) (HMul.hMul b (HAdd.hAdd m 1))) s.card\na✝ : Membership.mem (Finpartition.equitabilise h).parts t\n⊢ Or (Eq t.card m) (Eq t.card (HAdd.hAdd m 1))","decl":"theorem card_eq_of_mem_parts_equitabilise :\n    t ∈ (P.equitabilise h).parts → #t = m ∨ #t = m + 1 :=\n  (P.equitabilise_aux h).choose_spec.1 _\n\n"}
{"name":"Finpartition.equitabilise_isEquipartition","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Equitabilise","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nm a b : Nat\nP : Finpartition s\nh : Eq (HAdd.hAdd (HMul.hMul a m) (HMul.hMul b (HAdd.hAdd m 1))) s.card\n⊢ (Finpartition.equitabilise h).IsEquipartition","decl":"theorem equitabilise_isEquipartition : (P.equitabilise h).IsEquipartition :=\n  Set.equitableOn_iff_exists_eq_eq_add_one.2 ⟨m, fun _ => card_eq_of_mem_parts_equitabilise⟩\n\n"}
{"name":"Finpartition.card_filter_equitabilise_big","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Equitabilise","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nm a b : Nat\nP : Finpartition s\nh : Eq (HAdd.hAdd (HMul.hMul a m) (HMul.hMul b (HAdd.hAdd m 1))) s.card\n⊢ Eq (Finset.filter (fun u => Eq u.card (HAdd.hAdd m 1)) (Finpartition.equitabilise h).parts).card b","decl":"theorem card_filter_equitabilise_big : #{u ∈ (P.equitabilise h).parts | #u = m + 1} = b :=\n  (P.equitabilise_aux h).choose_spec.2.2\n\n"}
{"name":"Finpartition.card_filter_equitabilise_small","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Equitabilise","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nm a b : Nat\nP : Finpartition s\nh : Eq (HAdd.hAdd (HMul.hMul a m) (HMul.hMul b (HAdd.hAdd m 1))) s.card\nhm : Ne m 0\n⊢ Eq (Finset.filter (fun u => Eq u.card m) (Finpartition.equitabilise h).parts).card a","decl":"theorem card_filter_equitabilise_small (hm : m ≠ 0) :\n    #{u ∈ (P.equitabilise h).parts | #u = m} = a := by\n  refine (mul_eq_mul_right_iff.1 <| (add_left_inj (b * (m + 1))).1 ?_).resolve_right hm\n  rw [h, ← (P.equitabilise h).sum_card_parts]\n  have hunion :\n    (P.equitabilise h).parts =\n      {u ∈ (P.equitabilise h).parts | #u = m} ∪ {u ∈ (P.equitabilise h).parts | #u = m + 1} := by\n    rw [← filter_or, filter_true_of_mem]\n    exact fun x => card_eq_of_mem_parts_equitabilise\n  nth_rw 2 [hunion]\n  rw [sum_union, sum_const_nat fun x hx => (mem_filter.1 hx).2,\n    sum_const_nat fun x hx => (mem_filter.1 hx).2, P.card_filter_equitabilise_big]\n  refine disjoint_filter_filter' _ _ ?_\n  intro x ha hb i h\n  apply succ_ne_self m _\n  exact (hb i h).symm.trans (ha i h)\n\n"}
{"name":"Finpartition.card_parts_equitabilise","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Equitabilise","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nm a b : Nat\nP : Finpartition s\nh : Eq (HAdd.hAdd (HMul.hMul a m) (HMul.hMul b (HAdd.hAdd m 1))) s.card\nhm : Ne m 0\n⊢ Eq (Finpartition.equitabilise h).parts.card (HAdd.hAdd a b)","decl":"theorem card_parts_equitabilise (hm : m ≠ 0) : #(P.equitabilise h).parts = a + b := by\n  rw [← filter_true_of_mem fun x => card_eq_of_mem_parts_equitabilise, filter_or,\n    card_union_of_disjoint, P.card_filter_equitabilise_small _ hm, P.card_filter_equitabilise_big]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11187): was `infer_instance`\n  exact disjoint_filter.2 fun x _ h₀ h₁ => Nat.succ_ne_self m <| h₁.symm.trans h₀\n\n"}
{"name":"Finpartition.card_parts_equitabilise_subset_le","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Equitabilise","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nm a b : Nat\nP : Finpartition s\nh : Eq (HAdd.hAdd (HMul.hMul a m) (HMul.hMul b (HAdd.hAdd m 1))) s.card\na✝ : Membership.mem P.parts t\n⊢ LE.le (SDiff.sdiff t ((Finset.filter (fun u => HasSubset.Subset u t) (Finpartition.equitabilise h).parts).biUnion id)).card m","decl":"theorem card_parts_equitabilise_subset_le :\n    t ∈ P.parts → #(t \\ {u ∈ (P.equitabilise h).parts | u ⊆ t}.biUnion id) ≤ m :=\n  (Classical.choose_spec <| P.equitabilise_aux h).2.1 t\n\n"}
{"name":"Finpartition.exists_equipartition_card_eq","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Equitabilise","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nn : Nat\nhn : Ne n 0\nhs : LE.le n s.card\n⊢ Exists fun P => And P.IsEquipartition (Eq P.parts.card n)","decl":"/-- We can find equipartitions of arbitrary size. -/\ntheorem exists_equipartition_card_eq (hn : n ≠ 0) (hs : n ≤ #s) :\n    ∃ P : Finpartition s, P.IsEquipartition ∧ #P.parts = n := by\n  rw [← pos_iff_ne_zero] at hn\n  have : (n - #s % n) * (#s / n) + #s % n * (#s / n + 1) = #s := by\n    rw [tsub_mul, mul_add, ← add_assoc,\n      tsub_add_cancel_of_le (Nat.mul_le_mul_right _ (mod_lt _ hn).le), mul_one, add_comm,\n      mod_add_div]\n  refine\n    ⟨(indiscrete (card_pos.1 <| hn.trans_le hs).ne_empty).equitabilise this,\n      equitabilise_isEquipartition, ?_⟩\n  rw [card_parts_equitabilise _ _ (Nat.div_pos hs hn).ne', tsub_add_cancel_of_le (mod_lt _ hn).le]\n\n"}
