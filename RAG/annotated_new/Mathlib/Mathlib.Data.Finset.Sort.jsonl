{"name":"Finset.sort_val","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\ns : Finset α\n⊢ Eq (Multiset.sort r s.val) (Finset.sort r s)","decl":"@[simp]\ntheorem sort_val (s : Finset α) : Multiset.sort r s.val = sort r s :=\n  rfl\n\n"}
{"name":"Finset.sort_sorted","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\ns : Finset α\n⊢ List.Sorted r (Finset.sort r s)","decl":"@[simp]\ntheorem sort_sorted (s : Finset α) : List.Sorted r (sort r s) :=\n  Multiset.sort_sorted _ _\n\n"}
{"name":"Finset.sort_eq","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\ns : Finset α\n⊢ Eq (↑(Finset.sort r s)) s.val","decl":"@[simp]\ntheorem sort_eq (s : Finset α) : ↑(sort r s) = s.1 :=\n  Multiset.sort_eq _ _\n\n"}
{"name":"Finset.sort_nodup","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\ns : Finset α\n⊢ (Finset.sort r s).Nodup","decl":"@[simp]\ntheorem sort_nodup (s : Finset α) : (sort r s).Nodup :=\n  (by rw [sort_eq]; exact s.2 : @Multiset.Nodup α (sort r s))\n\n"}
{"name":"Finset.sort_toFinset","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝⁴ : DecidableRel r\ninst✝³ : IsTrans α r\ninst✝² : IsAntisymm α r\ninst✝¹ : IsTotal α r\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.sort r s).toFinset s","decl":"@[simp]\ntheorem sort_toFinset [DecidableEq α] (s : Finset α) : (sort r s).toFinset = s :=\n  List.toFinset_eq (sort_nodup r s) ▸ eq_of_veq (sort_eq r s)\n\n"}
{"name":"Finset.mem_sort","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\ns : Finset α\na : α\n⊢ Iff (Membership.mem (Finset.sort r s) a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_sort {s : Finset α} {a : α} : a ∈ sort r s ↔ a ∈ s :=\n  Multiset.mem_sort _\n\n"}
{"name":"Finset.length_sort","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\ns : Finset α\n⊢ Eq (Finset.sort r s).length s.card","decl":"@[simp]\ntheorem length_sort {s : Finset α} : (sort r s).length = s.card :=\n  Multiset.length_sort _\n\n"}
{"name":"Finset.sort_empty","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\n⊢ Eq (Finset.sort r EmptyCollection.emptyCollection) List.nil","decl":"@[simp]\ntheorem sort_empty : sort r ∅ = [] :=\n  Multiset.sort_zero r\n\n"}
{"name":"Finset.sort_singleton","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\na : α\n⊢ Eq (Finset.sort r (Singleton.singleton a)) (List.cons a List.nil)","decl":"@[simp]\ntheorem sort_singleton (a : α) : sort r {a} = [a] :=\n  Multiset.sort_singleton r a\n\n"}
{"name":"Finset.sort_cons","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\na : α\ns : Finset α\nh₁ : ∀ (b : α), Membership.mem s b → r a b\nh₂ : Not (Membership.mem s a)\n⊢ Eq (Finset.sort r (Finset.cons a s h₂)) (List.cons a (Finset.sort r s))","decl":"theorem sort_cons {a : α} {s : Finset α} (h₁ : ∀ b ∈ s, r a b) (h₂ : a ∉ s) :\n    sort r (cons a s h₂) = a :: sort r s := by\n  rw [sort, cons_val, Multiset.sort_cons r a _ h₁, sort_val]\n\n"}
{"name":"Finset.sort_insert","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝⁴ : DecidableRel r\ninst✝³ : IsTrans α r\ninst✝² : IsAntisymm α r\ninst✝¹ : IsTotal α r\ninst✝ : DecidableEq α\na : α\ns : Finset α\nh₁ : ∀ (b : α), Membership.mem s b → r a b\nh₂ : Not (Membership.mem s a)\n⊢ Eq (Finset.sort r (Insert.insert a s)) (List.cons a (Finset.sort r s))","decl":"theorem sort_insert [DecidableEq α] {a : α} {s : Finset α} (h₁ : ∀ b ∈ s, r a b) (h₂ : a ∉ s) :\n    sort r (insert a s) = a :: sort r s := by\n  rw [← cons_eq_insert _ _ h₂, sort_cons r h₁]\n\n"}
{"name":"Finset.sort_range","module":"Mathlib.Data.Finset.Sort","initialProofState":"n : Nat\n⊢ Eq (Finset.sort (fun x1 x2 => LE.le x1 x2) (Finset.range n)) (List.range n)","decl":"@[simp]\ntheorem sort_range (n : ℕ) : sort (· ≤ ·) (range n) = List.range n :=\n  Multiset.sort_range n\n\n"}
{"name":"Finset.sort_perm_toList","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝³ : DecidableRel r\ninst✝² : IsTrans α r\ninst✝¹ : IsAntisymm α r\ninst✝ : IsTotal α r\ns : Finset α\n⊢ (Finset.sort r s).Perm s.toList","decl":"open scoped List in\ntheorem sort_perm_toList (s : Finset α) : sort r s ~ s.toList := by\n  rw [← Multiset.coe_eq_coe]\n  simp only [coe_toList, sort_eq]\n\n"}
{"name":"List.toFinset_sort","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝⁴ : DecidableRel r\ninst✝³ : IsTrans α r\ninst✝² : IsAntisymm α r\ninst✝¹ : IsTotal α r\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\n⊢ Iff (Eq (Finset.sort r l.toFinset) l) (List.Sorted r l)","decl":"theorem _root_.List.toFinset_sort [DecidableEq α] {l : List α} (hl : l.Nodup) :\n    sort r l.toFinset = l ↔ l.Sorted r := by\n  refine ⟨?_, List.eq_of_perm_of_sorted ((sort_perm_toList r _).trans (List.toFinset_toList hl))\n    (sort_sorted r _)⟩\n  intro h\n  rw [← h]\n  exact sort_sorted r _\n\n"}
{"name":"Finset.sort_sorted_lt","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\n⊢ List.Sorted (fun x1 x2 => LT.lt x1 x2) (Finset.sort (fun x1 x2 => LE.le x1 x2) s)","decl":"theorem sort_sorted_lt (s : Finset α) : List.Sorted (· < ·) (sort (· ≤ ·) s) :=\n  (sort_sorted _ _).lt_of_le (sort_nodup _ _)\n\n"}
{"name":"Finset.sort_sorted_gt","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\n⊢ List.Sorted (fun x1 x2 => GT.gt x1 x2) (Finset.sort (fun x1 x2 => GE.ge x1 x2) s)","decl":"theorem sort_sorted_gt (s : Finset α) : List.Sorted (· > ·) (sort (· ≥ ·) s) :=\n  (sort_sorted _ _).gt_of_ge (sort_nodup _ _)\n\n"}
{"name":"Finset.sorted_zero_eq_min'_aux","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nh : LT.lt 0 (Finset.sort (fun x1 x2 => LE.le x1 x2) s).length\nH : s.Nonempty\n⊢ Eq ((Finset.sort (fun x1 x2 => LE.le x1 x2) s).get ⟨0, h⟩) (s.min' H)","decl":"theorem sorted_zero_eq_min'_aux (s : Finset α) (h : 0 < (s.sort (· ≤ ·)).length) (H : s.Nonempty) :\n    (s.sort (· ≤ ·)).get ⟨0, h⟩ = s.min' H := by\n  let l := s.sort (· ≤ ·)\n  apply le_antisymm\n  · have : s.min' H ∈ l := (Finset.mem_sort (α := α) (· ≤ ·)).mpr (s.min'_mem H)\n    obtain ⟨i, hi⟩ : ∃ i, l.get i = s.min' H := List.mem_iff_get.1 this\n    rw [← hi]\n    exact (s.sort_sorted (· ≤ ·)).rel_get_of_le (Nat.zero_le i)\n  · have : l.get ⟨0, h⟩ ∈ s := (Finset.mem_sort (α := α) (· ≤ ·)).1 (List.get_mem l _)\n    exact s.min'_le _ this\n\n"}
{"name":"Finset.sorted_zero_eq_min'","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nh : LT.lt 0 (Finset.sort (fun x1 x2 => LE.le x1 x2) s).length\n⊢ Eq (GetElem.getElem (Finset.sort (fun x1 x2 => LE.le x1 x2) s) 0 ⋯) (s.min' ⋯)","decl":"theorem sorted_zero_eq_min' {s : Finset α} {h : 0 < (s.sort (· ≤ ·)).length} :\n    (s.sort (· ≤ ·))[0] = s.min' (card_pos.1 <| by rwa [length_sort] at h) :=\n  sorted_zero_eq_min'_aux _ _ _\n\n"}
{"name":"Finset.min'_eq_sorted_zero","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nh : s.Nonempty\n⊢ Eq (s.min' h) (GetElem.getElem (Finset.sort (fun x1 x2 => LE.le x1 x2) s) 0 ⋯)","decl":"theorem min'_eq_sorted_zero {s : Finset α} {h : s.Nonempty} :\n    s.min' h = (s.sort (· ≤ ·))[0]'(by rw [length_sort]; exact card_pos.2 h) :=\n  (sorted_zero_eq_min'_aux _ _ _).symm\n\n"}
{"name":"Finset.sorted_last_eq_max'_aux","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nh : LT.lt (HSub.hSub (Finset.sort (fun x1 x2 => LE.le x1 x2) s).length 1) (Finset.sort (fun x1 x2 => LE.le x1 x2) s).length\nH : s.Nonempty\n⊢ Eq (GetElem.getElem (Finset.sort (fun x1 x2 => LE.le x1 x2) s) (HSub.hSub (Finset.sort (fun x1 x2 => LE.le x1 x2) s).length 1) ⋯) (s.max' H)","decl":"theorem sorted_last_eq_max'_aux (s : Finset α)\n    (h : (s.sort (· ≤ ·)).length - 1 < (s.sort (· ≤ ·)).length) (H : s.Nonempty) :\n    (s.sort (· ≤ ·))[(s.sort (· ≤ ·)).length - 1] = s.max' H := by\n  let l := s.sort (· ≤ ·)\n  apply le_antisymm\n  · have : l.get ⟨(s.sort (· ≤ ·)).length - 1, h⟩ ∈ s :=\n      (Finset.mem_sort (α := α) (· ≤ ·)).1 (List.get_mem l _)\n    exact s.le_max' _ this\n  · have : s.max' H ∈ l := (Finset.mem_sort (α := α) (· ≤ ·)).mpr (s.max'_mem H)\n    obtain ⟨i, hi⟩ : ∃ i, l.get i = s.max' H := List.mem_iff_get.1 this\n    rw [← hi]\n    exact (s.sort_sorted (· ≤ ·)).rel_get_of_le (Nat.le_sub_one_of_lt i.prop)\n\n"}
{"name":"Finset.sorted_last_eq_max'","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nh : LT.lt (HSub.hSub (Finset.sort (fun x1 x2 => LE.le x1 x2) s).length 1) (Finset.sort (fun x1 x2 => LE.le x1 x2) s).length\n⊢ Eq (GetElem.getElem (Finset.sort (fun x1 x2 => LE.le x1 x2) s) (HSub.hSub (Finset.sort (fun x1 x2 => LE.le x1 x2) s).length 1) ⋯) (s.max' ⋯)","decl":"theorem sorted_last_eq_max' {s : Finset α}\n    {h : (s.sort (· ≤ ·)).length - 1 < (s.sort (· ≤ ·)).length} :\n    (s.sort (· ≤ ·))[(s.sort (· ≤ ·)).length - 1] =\n      s.max' (by rw [length_sort] at h; exact card_pos.1 (lt_of_le_of_lt bot_le h)) :=\n  sorted_last_eq_max'_aux _ h _\n\n"}
{"name":"Finset.max'_eq_sorted_last","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nh : s.Nonempty\n⊢ Eq (s.max' h) (GetElem.getElem (Finset.sort (fun x1 x2 => LE.le x1 x2) s) (HSub.hSub (Finset.sort (fun x1 x2 => LE.le x1 x2) s).length 1) ⋯)","decl":"theorem max'_eq_sorted_last {s : Finset α} {h : s.Nonempty} :\n    s.max' h =\n      (s.sort (· ≤ ·))[(s.sort (· ≤ ·)).length - 1]'\n        (by simpa using Nat.sub_lt (card_pos.mpr h) Nat.zero_lt_one) :=\n  (sorted_last_eq_max'_aux _ (by simpa using Nat.sub_lt (card_pos.mpr h) Nat.zero_lt_one) _).symm\n\n"}
{"name":"Finset.coe_orderIsoOfFin_apply","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nk : Nat\nh : Eq s.card k\ni : Fin k\n⊢ Eq (↑((s.orderIsoOfFin h) i)) ((s.orderEmbOfFin h) i)","decl":"@[simp]\ntheorem coe_orderIsoOfFin_apply (s : Finset α) {k : ℕ} (h : s.card = k) (i : Fin k) :\n    ↑(orderIsoOfFin s h i) = orderEmbOfFin s h i :=\n  rfl\n\n"}
{"name":"Finset.orderIsoOfFin_symm_apply","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nk : Nat\nh : Eq s.card k\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑((s.orderIsoOfFin h).symm x)) (List.indexOf (↑x) (Finset.sort (fun x1 x2 => LE.le x1 x2) s))","decl":"theorem orderIsoOfFin_symm_apply (s : Finset α) {k : ℕ} (h : s.card = k) (x : s) :\n    ↑((s.orderIsoOfFin h).symm x) = (s.sort (· ≤ ·)).indexOf ↑x :=\n  rfl\n\n"}
{"name":"Finset.orderEmbOfFin_apply","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nk : Nat\nh : Eq s.card k\ni : Fin k\n⊢ Eq ((s.orderEmbOfFin h) i) (GetElem.getElem (Finset.sort (fun x1 x2 => LE.le x1 x2) s) i ⋯)","decl":"theorem orderEmbOfFin_apply (s : Finset α) {k : ℕ} (h : s.card = k) (i : Fin k) :\n    s.orderEmbOfFin h i = (s.sort (· ≤ ·))[i]'(by rw [length_sort, h]; exact i.2) :=\n  rfl\n\n"}
{"name":"Finset.orderEmbOfFin_mem","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nk : Nat\nh : Eq s.card k\ni : Fin k\n⊢ Membership.mem s ((s.orderEmbOfFin h) i)","decl":"@[simp]\ntheorem orderEmbOfFin_mem (s : Finset α) {k : ℕ} (h : s.card = k) (i : Fin k) :\n    s.orderEmbOfFin h i ∈ s :=\n  (s.orderIsoOfFin h i).2\n\n"}
{"name":"Finset.range_orderEmbOfFin","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nk : Nat\nh : Eq s.card k\n⊢ Eq (Set.range ⇑(s.orderEmbOfFin h)) ↑s","decl":"@[simp]\ntheorem range_orderEmbOfFin (s : Finset α) {k : ℕ} (h : s.card = k) :\n    Set.range (s.orderEmbOfFin h) = s := by\n  simp only [orderEmbOfFin, Set.range_comp ((↑) : _ → α) (s.orderIsoOfFin h),\n  RelEmbedding.coe_trans, Set.image_univ, Finset.orderEmbOfFin, RelIso.range_eq,\n    OrderEmbedding.subtype_apply, OrderIso.coe_toOrderEmbedding, eq_self_iff_true,\n    Subtype.range_coe_subtype, Finset.setOf_mem, Finset.coe_inj]\n\n"}
{"name":"Finset.orderEmbOfFin_zero","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nk : Nat\nh : Eq s.card k\nhz : LT.lt 0 k\n⊢ Eq ((s.orderEmbOfFin h) ⟨0, hz⟩) (s.min' ⋯)","decl":"/-- The bijection `orderEmbOfFin s h` sends `0` to the minimum of `s`. -/\ntheorem orderEmbOfFin_zero {s : Finset α} {k : ℕ} (h : s.card = k) (hz : 0 < k) :\n    orderEmbOfFin s h ⟨0, hz⟩ = s.min' (card_pos.mp (h.symm ▸ hz)) := by\n  simp only [orderEmbOfFin_apply, Fin.getElem_fin, sorted_zero_eq_min']\n\n"}
{"name":"Finset.orderEmbOfFin_last","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nk : Nat\nh : Eq s.card k\nhz : LT.lt 0 k\n⊢ Eq ((s.orderEmbOfFin h) ⟨HSub.hSub k 1, ⋯⟩) (s.max' ⋯)","decl":"/-- The bijection `orderEmbOfFin s h` sends `k-1` to the maximum of `s`. -/\ntheorem orderEmbOfFin_last {s : Finset α} {k : ℕ} (h : s.card = k) (hz : 0 < k) :\n    orderEmbOfFin s h ⟨k - 1, Nat.sub_lt hz (Nat.succ_pos 0)⟩ =\n      s.max' (card_pos.mp (h.symm ▸ hz)) := by\n  simp [orderEmbOfFin_apply, max'_eq_sorted_last, h]\n\n"}
{"name":"Finset.orderEmbOfFin_singleton","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\ni : Fin 1\n⊢ Eq (((Singleton.singleton a).orderEmbOfFin ⋯) i) a","decl":"/-- `orderEmbOfFin {a} h` sends any argument to `a`. -/\n@[simp]\ntheorem orderEmbOfFin_singleton (a : α) (i : Fin 1) :\n    orderEmbOfFin {a} (card_singleton a) i = a := by\n  rw [Subsingleton.elim i ⟨0, Nat.zero_lt_one⟩, orderEmbOfFin_zero _ Nat.zero_lt_one,\n    min'_singleton]\n\n"}
{"name":"Finset.orderEmbOfFin_unique","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nk : Nat\nh : Eq s.card k\nf : Fin k → α\nhfs : ∀ (x : Fin k), Membership.mem s (f x)\nhmono : StrictMono f\n⊢ Eq f ⇑(s.orderEmbOfFin h)","decl":"/-- Any increasing map `f` from `Fin k` to a finset of cardinality `k` has to coincide with\nthe increasing bijection `orderEmbOfFin s h`. -/\ntheorem orderEmbOfFin_unique {s : Finset α} {k : ℕ} (h : s.card = k) {f : Fin k → α}\n    (hfs : ∀ x, f x ∈ s) (hmono : StrictMono f) : f = s.orderEmbOfFin h := by\n  rw [← hmono.range_inj (s.orderEmbOfFin h).strictMono, range_orderEmbOfFin, ← Set.image_univ,\n    ← coe_univ, ← coe_image, coe_inj]\n  refine eq_of_subset_of_card_le (fun x hx => ?_) ?_\n  · rcases mem_image.1 hx with ⟨x, _, rfl⟩\n    exact hfs x\n  · rw [h, card_image_of_injective _ hmono.injective, card_univ, Fintype.card_fin]\n\n"}
{"name":"Finset.orderEmbOfFin_unique'","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nk : Nat\nh : Eq s.card k\nf : OrderEmbedding (Fin k) α\nhfs : ∀ (x : Fin k), Membership.mem s (f x)\n⊢ Eq f (s.orderEmbOfFin h)","decl":"/-- An order embedding `f` from `Fin k` to a finset of cardinality `k` has to coincide with\nthe increasing bijection `orderEmbOfFin s h`. -/\ntheorem orderEmbOfFin_unique' {s : Finset α} {k : ℕ} (h : s.card = k) {f : Fin k ↪o α}\n    (hfs : ∀ x, f x ∈ s) : f = s.orderEmbOfFin h :=\n  RelEmbedding.ext <| funext_iff.1 <| orderEmbOfFin_unique h hfs f.strictMono\n\n"}
{"name":"Finset.orderEmbOfFin_eq_orderEmbOfFin_iff","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nk l : Nat\ns : Finset α\ni : Fin k\nj : Fin l\nh : Eq s.card k\nh' : Eq s.card l\n⊢ Iff (Eq ((s.orderEmbOfFin h) i) ((s.orderEmbOfFin h') j)) (Eq ↑i ↑j)","decl":"/-- Two parametrizations `orderEmbOfFin` of the same set take the same value on `i` and `j` if\nand only if `i = j`. Since they can be defined on a priori not defeq types `Fin k` and `Fin l`\n(although necessarily `k = l`), the conclusion is rather written `(i : ℕ) = (j : ℕ)`. -/\n@[simp]\ntheorem orderEmbOfFin_eq_orderEmbOfFin_iff {k l : ℕ} {s : Finset α} {i : Fin k} {j : Fin l}\n    {h : s.card = k} {h' : s.card = l} :\n    s.orderEmbOfFin h i = s.orderEmbOfFin h' j ↔ (i : ℕ) = (j : ℕ) := by\n  substs k l\n  exact (s.orderEmbOfFin rfl).eq_iff_eq.trans Fin.ext_iff\n\n"}
{"name":"Finset.orderEmbOfCardLe_mem","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Finset α\nk : Nat\nh : LE.le k s.card\na : Fin k\n⊢ Membership.mem s ((s.orderEmbOfCardLe h) a)","decl":"theorem orderEmbOfCardLe_mem (s : Finset α) {k : ℕ} (h : k ≤ s.card) (a) :\n    orderEmbOfCardLe s h a ∈ s := by\n  simp only [orderEmbOfCardLe, RelEmbedding.coe_trans, Finset.orderEmbOfFin_mem,\n    Function.comp_apply]\n\n"}
{"name":"Fin.sort_univ","module":"Mathlib.Data.Finset.Sort","initialProofState":"n : Nat\n⊢ Eq (Finset.sort (fun x y => LE.le x y) Finset.univ) (List.finRange n)","decl":"theorem sort_univ (n : ℕ) : Finset.univ.sort (fun x y : Fin n => x ≤ y) = List.finRange n :=\n  List.eq_of_perm_of_sorted\n    (List.perm_of_nodup_nodup_toFinset_eq\n      (Finset.univ.sort_nodup _) (List.nodup_finRange n) (by simp))\n    (Finset.univ.sort_sorted LE.le)\n    (List.pairwise_le_finRange n)\n\n"}
{"name":"nonempty_orderEmbedding_of_finite_infinite","module":"Mathlib.Data.Finset.Sort","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nhα : Finite α\nβ : Type u_2\ninst✝ : LinearOrder β\nhβ : Infinite β\n⊢ Nonempty (OrderEmbedding α β)","decl":"/-- Any finite linear order order-embeds into any infinite linear order. -/\nlemma nonempty_orderEmbedding_of_finite_infinite\n    (α : Type*) [LinearOrder α] [hα : Finite α]\n    (β : Type*) [LinearOrder β] [hβ : Infinite β] : Nonempty (α ↪o β) := by\n  haveI := Fintype.ofFinite α\n  obtain ⟨s, hs⟩ := Infinite.exists_subset_card_eq β (Fintype.card α)\n  exact ⟨((Fintype.orderIsoFinOfCardEq α rfl).symm.toOrderEmbedding).trans (s.orderEmbOfFin hs)⟩\n"}
