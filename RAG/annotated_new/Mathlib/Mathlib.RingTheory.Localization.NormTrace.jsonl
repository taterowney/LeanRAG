{"name":"Algebra.map_leftMulMatrix_localization","module":"Mathlib.RingTheory.Localization.NormTrace","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁴ : CommRing R\ninst✝¹³ : CommRing S\ninst✝¹² : Algebra R S\nRₘ : Type u_3\nSₘ : Type u_4\ninst✝¹¹ : CommRing Rₘ\ninst✝¹⁰ : Algebra R Rₘ\ninst✝⁹ : CommRing Sₘ\ninst✝⁸ : Algebra S Sₘ\nM : Submonoid R\ninst✝⁷ : IsLocalization M Rₘ\ninst✝⁶ : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\ninst✝⁵ : Algebra Rₘ Sₘ\ninst✝⁴ : Algebra R Sₘ\ninst✝³ : IsScalarTower R Rₘ Sₘ\ninst✝² : IsScalarTower R S Sₘ\nι : Type u_5\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι R S\na : S\n⊢ Eq ((algebraMap R Rₘ).mapMatrix ((Algebra.leftMulMatrix b) a)) ((Algebra.leftMulMatrix (Basis.localizationLocalization Rₘ M Sₘ b)) ((algebraMap S Sₘ) a))","decl":"theorem Algebra.map_leftMulMatrix_localization {ι : Type*} [Fintype ι] [DecidableEq ι]\n    (b : Basis ι R S) (a : S) :\n    (algebraMap R Rₘ).mapMatrix (leftMulMatrix b a) =\n    leftMulMatrix (b.localizationLocalization Rₘ M Sₘ) (algebraMap S Sₘ a) := by\n  ext i j\n  simp only [Matrix.map_apply, RingHom.mapMatrix_apply, leftMulMatrix_eq_repr_mul, ← map_mul,\n    Basis.localizationLocalization_apply, Basis.localizationLocalization_repr_algebraMap]\n\n"}
{"name":"Algebra.norm_localization","module":"Mathlib.RingTheory.Localization.NormTrace","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁴ : CommRing R\ninst✝¹³ : CommRing S\ninst✝¹² : Algebra R S\nRₘ : Type u_3\nSₘ : Type u_4\ninst✝¹¹ : CommRing Rₘ\ninst✝¹⁰ : Algebra R Rₘ\ninst✝⁹ : CommRing Sₘ\ninst✝⁸ : Algebra S Sₘ\nM : Submonoid R\ninst✝⁷ : IsLocalization M Rₘ\ninst✝⁶ : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\ninst✝⁵ : Algebra Rₘ Sₘ\ninst✝⁴ : Algebra R Sₘ\ninst✝³ : IsScalarTower R Rₘ Sₘ\ninst✝² : IsScalarTower R S Sₘ\ninst✝¹ : Module.Free R S\ninst✝ : Module.Finite R S\na : S\n⊢ Eq ((Algebra.norm Rₘ) ((algebraMap S Sₘ) a)) ((algebraMap R Rₘ) ((Algebra.norm R) a))","decl":"/-- Let `S` be an extension of `R` and `Rₘ Sₘ` be localizations at `M` of `R S` respectively.\nThen the norm of `a : Sₘ` over `Rₘ` is the norm of `a : S` over `R` if `S` is free as `R`-module.\n-/\ntheorem Algebra.norm_localization [Module.Free R S] [Module.Finite R S] (a : S) :\n    Algebra.norm Rₘ (algebraMap S Sₘ a) = algebraMap R Rₘ (Algebra.norm R a) := by\n  cases subsingleton_or_nontrivial R\n  · haveI : Subsingleton Rₘ := Module.subsingleton R Rₘ\n    simp [eq_iff_true_of_subsingleton]\n  let b := Module.Free.chooseBasis R S\n  letI := Classical.decEq (Module.Free.ChooseBasisIndex R S)\n  rw [Algebra.norm_eq_matrix_det (b.localizationLocalization Rₘ M Sₘ),\n    Algebra.norm_eq_matrix_det b, RingHom.map_det, ← Algebra.map_leftMulMatrix_localization]\n\n"}
{"name":"Algebra.norm_eq_iff","module":"Mathlib.RingTheory.Localization.NormTrace","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁴ : CommRing R\ninst✝¹³ : CommRing S\ninst✝¹² : Algebra R S\nRₘ : Type u_3\nSₘ : Type u_4\ninst✝¹¹ : CommRing Rₘ\ninst✝¹⁰ : Algebra R Rₘ\ninst✝⁹ : CommRing Sₘ\ninst✝⁸ : Algebra S Sₘ\nM : Submonoid R\ninst✝⁷ : IsLocalization M Rₘ\ninst✝⁶ : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\ninst✝⁵ : Algebra Rₘ Sₘ\ninst✝⁴ : Algebra R Sₘ\ninst✝³ : IsScalarTower R Rₘ Sₘ\ninst✝² : IsScalarTower R S Sₘ\ninst✝¹ : Module.Free R S\ninst✝ : Module.Finite R S\na : S\nb : R\nhM : LE.le M (nonZeroDivisors R)\n⊢ Iff (Eq ((Algebra.norm R) a) b) (Eq ((Algebra.norm Rₘ) ((algebraMap S Sₘ) a)) ((algebraMap R Rₘ) b))","decl":"variable {M} in\n/-- The norm of `a : S` in `R` can be computed in `Sₘ`. -/\nlemma Algebra.norm_eq_iff [Module.Free R S] [Module.Finite R S] {a : S} {b : R}\n    (hM : M ≤ nonZeroDivisors R) : Algebra.norm R a = b ↔\n      (Algebra.norm Rₘ) ((algebraMap S Sₘ) a) = algebraMap R Rₘ b :=\n  ⟨fun h ↦ h.symm ▸ Algebra.norm_localization _ M _, fun h ↦\n    IsLocalization.injective Rₘ hM <| h.symm ▸ (Algebra.norm_localization R M a).symm⟩\n\n"}
{"name":"Algebra.trace_localization","module":"Mathlib.RingTheory.Localization.NormTrace","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁴ : CommRing R\ninst✝¹³ : CommRing S\ninst✝¹² : Algebra R S\nRₘ : Type u_3\nSₘ : Type u_4\ninst✝¹¹ : CommRing Rₘ\ninst✝¹⁰ : Algebra R Rₘ\ninst✝⁹ : CommRing Sₘ\ninst✝⁸ : Algebra S Sₘ\nM : Submonoid R\ninst✝⁷ : IsLocalization M Rₘ\ninst✝⁶ : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\ninst✝⁵ : Algebra Rₘ Sₘ\ninst✝⁴ : Algebra R Sₘ\ninst✝³ : IsScalarTower R Rₘ Sₘ\ninst✝² : IsScalarTower R S Sₘ\ninst✝¹ : Module.Free R S\ninst✝ : Module.Finite R S\na : S\n⊢ Eq ((Algebra.trace Rₘ Sₘ) ((algebraMap S Sₘ) a)) ((algebraMap R Rₘ) ((Algebra.trace R S) a))","decl":"/-- Let `S` be an extension of `R` and `Rₘ Sₘ` be localizations at `M` of `R S` respectively.\nThen the trace of `a : Sₘ` over `Rₘ` is the trace of `a : S` over `R` if `S` is free as `R`-module.\n-/\ntheorem Algebra.trace_localization [Module.Free R S] [Module.Finite R S] (a : S) :\n    Algebra.trace Rₘ Sₘ (algebraMap S Sₘ a) = algebraMap R Rₘ (Algebra.trace R S a) := by\n  cases subsingleton_or_nontrivial R\n  · haveI : Subsingleton Rₘ := Module.subsingleton R Rₘ\n    simp [eq_iff_true_of_subsingleton]\n  let b := Module.Free.chooseBasis R S\n  letI := Classical.decEq (Module.Free.ChooseBasisIndex R S)\n  rw [Algebra.trace_eq_matrix_trace (b.localizationLocalization Rₘ M Sₘ),\n    Algebra.trace_eq_matrix_trace b, ← Algebra.map_leftMulMatrix_localization]\n  exact (AddMonoidHom.map_trace (algebraMap R Rₘ).toAddMonoidHom _).symm\n\n"}
{"name":"Algebra.traceMatrix_localizationLocalization","module":"Mathlib.RingTheory.Localization.NormTrace","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁴ : CommRing R\ninst✝¹³ : CommRing S\ninst✝¹² : Algebra R S\nRₘ : Type u_3\ninst✝¹¹ : CommRing Rₘ\ninst✝¹⁰ : Algebra R Rₘ\nM : Submonoid R\ninst✝⁹ : IsLocalization M Rₘ\nSₘ : Type u_5\ninst✝⁸ : CommRing Sₘ\ninst✝⁷ : Algebra S Sₘ\ninst✝⁶ : Algebra Rₘ Sₘ\ninst✝⁵ : Algebra R Sₘ\ninst✝⁴ : IsScalarTower R Rₘ Sₘ\ninst✝³ : IsScalarTower R S Sₘ\ninst✝² : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\nι : Type u_6\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι R S\n⊢ Eq (Algebra.traceMatrix Rₘ ⇑(Basis.localizationLocalization Rₘ M Sₘ b)) ((algebraMap R Rₘ).mapMatrix (Algebra.traceMatrix R ⇑b))","decl":"theorem Algebra.traceMatrix_localizationLocalization (b : Basis ι R S) :\n    Algebra.traceMatrix Rₘ (b.localizationLocalization Rₘ M Sₘ) =\n      (algebraMap R Rₘ).mapMatrix (Algebra.traceMatrix R b) := by\n  have : Module.Finite R S := Module.Finite.of_basis b\n  have : Module.Free R S := Module.Free.of_basis b\n  ext i j : 2\n  simp_rw [RingHom.mapMatrix_apply, Matrix.map_apply, traceMatrix_apply, traceForm_apply,\n    Basis.localizationLocalization_apply, ← map_mul]\n  exact Algebra.trace_localization R M _\n\n"}
{"name":"Algebra.discr_localizationLocalization","module":"Mathlib.RingTheory.Localization.NormTrace","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁴ : CommRing R\ninst✝¹³ : CommRing S\ninst✝¹² : Algebra R S\nRₘ : Type u_3\ninst✝¹¹ : CommRing Rₘ\ninst✝¹⁰ : Algebra R Rₘ\nM : Submonoid R\ninst✝⁹ : IsLocalization M Rₘ\nSₘ : Type u_5\ninst✝⁸ : CommRing Sₘ\ninst✝⁷ : Algebra S Sₘ\ninst✝⁶ : Algebra Rₘ Sₘ\ninst✝⁵ : Algebra R Sₘ\ninst✝⁴ : IsScalarTower R Rₘ Sₘ\ninst✝³ : IsScalarTower R S Sₘ\ninst✝² : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ\nι : Type u_6\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι R S\n⊢ Eq (Algebra.discr Rₘ ⇑(Basis.localizationLocalization Rₘ M Sₘ b)) ((algebraMap R Rₘ) (Algebra.discr R ⇑b))","decl":"/-- Let `S` be an extension of `R` and `Rₘ Sₘ` be localizations at `M` of `R S` respectively. Let\n`b` be a `R`-basis of `S`. Then discriminant of the `Rₘ`-basis of `Sₘ` induced by `b` is the\ndiscriminant of `b`.\n-/\ntheorem Algebra.discr_localizationLocalization (b : Basis ι R S) :\n    Algebra.discr Rₘ (b.localizationLocalization Rₘ M Sₘ) =\n    algebraMap R Rₘ (Algebra.discr R b) := by\n  rw [Algebra.discr_def, Algebra.discr_def, RingHom.map_det,\n    Algebra.traceMatrix_localizationLocalization]\n\n"}
