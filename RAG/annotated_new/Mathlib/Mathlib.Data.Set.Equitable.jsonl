{"name":"Set.equitableOn_empty","module":"Mathlib.Data.Set.Equitable","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LE β\ninst✝¹ : Add β\ninst✝ : One β\nf : α → β\n⊢ EmptyCollection.emptyCollection.EquitableOn f","decl":"@[simp]\ntheorem equitableOn_empty [LE β] [Add β] [One β] (f : α → β) : EquitableOn ∅ f := fun a _ ha =>\n  (Set.not_mem_empty a ha).elim\n\n"}
{"name":"Set.equitableOn_iff_exists_le_le_add_one","module":"Mathlib.Data.Set.Equitable","initialProofState":"α : Type u_1\ns : Set α\nf : α → Nat\n⊢ Iff (s.EquitableOn f) (Exists fun b => ∀ (a : α), Membership.mem s a → And (LE.le b (f a)) (LE.le (f a) (HAdd.hAdd b 1)))","decl":"theorem equitableOn_iff_exists_le_le_add_one {s : Set α} {f : α → ℕ} :\n    s.EquitableOn f ↔ ∃ b, ∀ a ∈ s, b ≤ f a ∧ f a ≤ b + 1 := by\n  refine ⟨?_, fun ⟨b, hb⟩ x y hx hy => (hb x hx).2.trans (add_le_add_right (hb y hy).1 _)⟩\n  obtain rfl | ⟨x, hx⟩ := s.eq_empty_or_nonempty\n  · simp\n  intro hs\n  by_cases h : ∀ y ∈ s, f x ≤ f y\n  · exact ⟨f x, fun y hy => ⟨h _ hy, hs hy hx⟩⟩\n  push_neg at h\n  obtain ⟨w, hw, hwx⟩ := h\n  refine ⟨f w, fun y hy => ⟨Nat.le_of_succ_le_succ ?_, hs hy hw⟩⟩\n  rw [(Nat.succ_le_of_lt hwx).antisymm (hs hx hw)]\n  exact hs hx hy\n\n"}
{"name":"Set.equitableOn_iff_exists_image_subset_icc","module":"Mathlib.Data.Set.Equitable","initialProofState":"α : Type u_1\ns : Set α\nf : α → Nat\n⊢ Iff (s.EquitableOn f) (Exists fun b => HasSubset.Subset (Set.image f s) (Set.Icc b (HAdd.hAdd b 1)))","decl":"theorem equitableOn_iff_exists_image_subset_icc {s : Set α} {f : α → ℕ} :\n    s.EquitableOn f ↔ ∃ b, f '' s ⊆ Icc b (b + 1) := by\n  simpa only [image_subset_iff] using equitableOn_iff_exists_le_le_add_one\n\n"}
{"name":"Set.equitableOn_iff_exists_eq_eq_add_one","module":"Mathlib.Data.Set.Equitable","initialProofState":"α : Type u_1\ns : Set α\nf : α → Nat\n⊢ Iff (s.EquitableOn f) (Exists fun b => ∀ (a : α), Membership.mem s a → Or (Eq (f a) b) (Eq (f a) (HAdd.hAdd b 1)))","decl":"theorem equitableOn_iff_exists_eq_eq_add_one {s : Set α} {f : α → ℕ} :\n    s.EquitableOn f ↔ ∃ b, ∀ a ∈ s, f a = b ∨ f a = b + 1 := by\n  simp_rw [equitableOn_iff_exists_le_le_add_one, Nat.le_and_le_add_one_iff]\n\n"}
{"name":"Set.not_equitableOn","module":"Mathlib.Data.Set.Equitable","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrder β\ninst✝¹ : Add β\ninst✝ : One β\ns : Set α\nf : α → β\n⊢ Iff (Not (s.EquitableOn f)) (Exists fun a => And (Membership.mem s a) (Exists fun b => And (Membership.mem s b) (LT.lt (HAdd.hAdd (f b) 1) (f a))))","decl":"@[simp]\nlemma not_equitableOn : ¬s.EquitableOn f ↔ ∃ a ∈ s, ∃ b ∈ s, f b + 1 < f a := by\n  simp [EquitableOn]\n\n"}
{"name":"Set.Subsingleton.equitableOn","module":"Mathlib.Data.Set.Equitable","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : OrderedSemiring β\ns : Set α\nhs : s.Subsingleton\nf : α → β\n⊢ s.EquitableOn f","decl":"theorem Subsingleton.equitableOn {s : Set α} (hs : s.Subsingleton) (f : α → β) : s.EquitableOn f :=\n  fun i j hi hj => by\n  rw [hs hi hj]\n  exact le_add_of_nonneg_right zero_le_one\n\n"}
{"name":"Set.equitableOn_singleton","module":"Mathlib.Data.Set.Equitable","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : OrderedSemiring β\na : α\nf : α → β\n⊢ (Singleton.singleton a).EquitableOn f","decl":"theorem equitableOn_singleton (a : α) (f : α → β) : Set.EquitableOn {a} f :=\n  Set.subsingleton_singleton.equitableOn f\n\n"}
{"name":"Finset.equitableOn_iff_le_le_add_one","module":"Mathlib.Data.Set.Equitable","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Nat\n⊢ Iff ((↑s).EquitableOn f) (∀ (a : α), Membership.mem s a → And (LE.le (HDiv.hDiv (s.sum fun i => f i) s.card) (f a)) (LE.le (f a) (HAdd.hAdd (HDiv.hDiv (s.sum fun i => f i) s.card) 1)))","decl":"theorem equitableOn_iff_le_le_add_one :\n    EquitableOn (s : Set α) f ↔\n      ∀ a ∈ s, (∑ i ∈ s, f i) / s.card ≤ f a ∧ f a ≤ (∑ i ∈ s, f i) / s.card + 1 := by\n  rw [Set.equitableOn_iff_exists_le_le_add_one]\n  refine ⟨?_, fun h => ⟨_, h⟩⟩\n  rintro ⟨b, hb⟩\n  by_cases h : ∀ a ∈ s, f a = b + 1\n  · intro a ha\n    rw [h _ ha, sum_const_nat h, Nat.mul_div_cancel_left _ (card_pos.2 ⟨a, ha⟩)]\n    exact ⟨le_rfl, Nat.le_succ _⟩\n  push_neg at h\n  obtain ⟨x, hx₁, hx₂⟩ := h\n  suffices h : b = (∑ i ∈ s, f i) / s.card by\n    simp_rw [← h]\n    apply hb\n  symm\n  refine\n    Nat.div_eq_of_lt_le (le_trans (by simp [mul_comm]) (sum_le_sum fun a ha => (hb a ha).1))\n      ((sum_lt_sum (fun a ha => (hb a ha).2) ⟨_, hx₁, (hb _ hx₁).2.lt_of_ne hx₂⟩).trans_le ?_)\n  rw [mul_comm, sum_const_nat]\n  exact fun _ _ => rfl\n\n"}
{"name":"Finset.EquitableOn.le","module":"Mathlib.Data.Set.Equitable","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Nat\na : α\nh : (↑s).EquitableOn f\nha : Membership.mem s a\n⊢ LE.le (HDiv.hDiv (s.sum fun i => f i) s.card) (f a)","decl":"theorem EquitableOn.le (h : EquitableOn (s : Set α) f) (ha : a ∈ s) :\n    (∑ i ∈ s, f i) / s.card ≤ f a :=\n  (equitableOn_iff_le_le_add_one.1 h a ha).1\n\n"}
{"name":"Finset.EquitableOn.le_add_one","module":"Mathlib.Data.Set.Equitable","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Nat\na : α\nh : (↑s).EquitableOn f\nha : Membership.mem s a\n⊢ LE.le (f a) (HAdd.hAdd (HDiv.hDiv (s.sum fun i => f i) s.card) 1)","decl":"theorem EquitableOn.le_add_one (h : EquitableOn (s : Set α) f) (ha : a ∈ s) :\n    f a ≤ (∑ i ∈ s, f i) / s.card + 1 :=\n  (equitableOn_iff_le_le_add_one.1 h a ha).2\n\n"}
{"name":"Finset.equitableOn_iff","module":"Mathlib.Data.Set.Equitable","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Nat\n⊢ Iff ((↑s).EquitableOn f) (∀ (a : α), Membership.mem s a → Or (Eq (f a) (HDiv.hDiv (s.sum fun i => f i) s.card)) (Eq (f a) (HAdd.hAdd (HDiv.hDiv (s.sum fun i => f i) s.card) 1)))","decl":"theorem equitableOn_iff :\n    EquitableOn (s : Set α) f ↔\n      ∀ a ∈ s, f a = (∑ i ∈ s, f i) / s.card ∨ f a = (∑ i ∈ s, f i) / s.card + 1 := by\n  simp_rw [equitableOn_iff_le_le_add_one, Nat.le_and_le_add_one_iff]\n\n"}
