{"name":"Int.Icc_eq_finset_map","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Finset.Icc a b) (Finset.map (Nat.castEmbedding.trans (addLeftEmbedding a)) (Finset.range (HSub.hSub (HAdd.hAdd b 1) a).toNat))","decl":"theorem Icc_eq_finset_map :\n    Icc a b =\n      (Finset.range (b + 1 - a).toNat).map (Nat.castEmbedding.trans <| addLeftEmbedding a) :=\n  rfl\n\n"}
{"name":"Int.Ico_eq_finset_map","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Finset.Ico a b) (Finset.map (Nat.castEmbedding.trans (addLeftEmbedding a)) (Finset.range (HSub.hSub b a).toNat))","decl":"theorem Ico_eq_finset_map :\n    Ico a b = (Finset.range (b - a).toNat).map (Nat.castEmbedding.trans <| addLeftEmbedding a) :=\n  rfl\n\n"}
{"name":"Int.Ioc_eq_finset_map","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Finset.Ioc a b) (Finset.map (Nat.castEmbedding.trans (addLeftEmbedding (HAdd.hAdd a 1))) (Finset.range (HSub.hSub b a).toNat))","decl":"theorem Ioc_eq_finset_map :\n    Ioc a b =\n      (Finset.range (b - a).toNat).map (Nat.castEmbedding.trans <| addLeftEmbedding (a + 1)) :=\n  rfl\n\n"}
{"name":"Int.Ioo_eq_finset_map","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Finset.Ioo a b) (Finset.map (Nat.castEmbedding.trans (addLeftEmbedding (HAdd.hAdd a 1))) (Finset.range (HSub.hSub (HSub.hSub b a) 1).toNat))","decl":"theorem Ioo_eq_finset_map :\n    Ioo a b =\n      (Finset.range (b - a - 1).toNat).map (Nat.castEmbedding.trans <| addLeftEmbedding (a + 1)) :=\n  rfl\n\n"}
{"name":"Int.uIcc_eq_finset_map","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Finset.uIcc a b) (Finset.map (Nat.castEmbedding.trans (addLeftEmbedding (Min.min a b))) (Finset.range (HSub.hSub (HAdd.hAdd (Max.max a b) 1) (Min.min a b)).toNat))","decl":"theorem uIcc_eq_finset_map :\n    uIcc a b = (range (max a b + 1 - min a b).toNat).map\n      (Nat.castEmbedding.trans <| addLeftEmbedding <| min a b) := rfl\n\n"}
{"name":"Int.card_Icc","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Finset.Icc a b).card (HSub.hSub (HAdd.hAdd b 1) a).toNat","decl":"@[simp]\ntheorem card_Icc : #(Icc a b) = (b + 1 - a).toNat := (card_map _).trans <| card_range _\n\n"}
{"name":"Int.card_Ico","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Finset.Ico a b).card (HSub.hSub b a).toNat","decl":"@[simp]\ntheorem card_Ico : #(Ico a b) = (b - a).toNat := (card_map _).trans <| card_range _\n\n"}
{"name":"Int.card_Ioc","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Finset.Ioc a b).card (HSub.hSub b a).toNat","decl":"@[simp]\ntheorem card_Ioc : #(Ioc a b) = (b - a).toNat := (card_map _).trans <| card_range _\n\n"}
{"name":"Int.card_Ioo","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Finset.Ioo a b).card (HSub.hSub (HSub.hSub b a) 1).toNat","decl":"@[simp]\ntheorem card_Ioo : #(Ioo a b) = (b - a - 1).toNat := (card_map _).trans <| card_range _\n\n"}
{"name":"Int.card_uIcc","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Finset.uIcc a b).card (HAdd.hAdd (HSub.hSub b a).natAbs 1)","decl":"@[simp]\ntheorem card_uIcc : #(uIcc a b) = (b - a).natAbs + 1 :=\n  (card_map _).trans <|\n    (Nat.cast_inj (R := ℤ)).mp <| by\n      rw [card_range,\n        Int.toNat_of_nonneg (sub_nonneg_of_le <| le_add_one min_le_max), Int.ofNat_add,\n        Int.natCast_natAbs, add_comm, add_sub_assoc, max_sub_min_eq_abs, add_comm, Int.ofNat_one]\n\n"}
{"name":"Int.card_Icc_of_le","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\nh : LE.le a (HAdd.hAdd b 1)\n⊢ Eq (↑(Finset.Icc a b).card) (HSub.hSub (HAdd.hAdd b 1) a)","decl":"theorem card_Icc_of_le (h : a ≤ b + 1) : (#(Icc a b) : ℤ) = b + 1 - a := by\n  rw [card_Icc, toNat_sub_of_le h]\n\n"}
{"name":"Int.card_Ico_of_le","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\nh : LE.le a b\n⊢ Eq (↑(Finset.Ico a b).card) (HSub.hSub b a)","decl":"theorem card_Ico_of_le (h : a ≤ b) : (#(Ico a b) : ℤ) = b - a := by\n  rw [card_Ico, toNat_sub_of_le h]\n\n"}
{"name":"Int.card_Ioc_of_le","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\nh : LE.le a b\n⊢ Eq (↑(Finset.Ioc a b).card) (HSub.hSub b a)","decl":"theorem card_Ioc_of_le (h : a ≤ b) : (#(Ioc a b) : ℤ) = b - a := by\n  rw [card_Ioc, toNat_sub_of_le h]\n\n"}
{"name":"Int.card_Ioo_of_lt","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\nh : LT.lt a b\n⊢ Eq (↑(Finset.Ioo a b).card) (HSub.hSub (HSub.hSub b a) 1)","decl":"theorem card_Ioo_of_lt (h : a < b) : (#(Ioo a b) : ℤ) = b - a - 1 := by\n  rw [card_Ioo, sub_sub, toNat_sub_of_le h]\n\n"}
{"name":"Int.Icc_eq_pair","module":"Mathlib.Data.Int.Interval","initialProofState":"a : Int\n⊢ Eq (Finset.Icc a (HAdd.hAdd a 1)) (Insert.insert a (Singleton.singleton (HAdd.hAdd a 1)))","decl":"theorem Icc_eq_pair : Finset.Icc a (a + 1) = {a, a + 1} := by\n  ext\n  simp\n  omega\n\n"}
{"name":"Int.card_fintype_Icc","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Fintype.card ↑(Set.Icc a b)) (HSub.hSub (HAdd.hAdd b 1) a).toNat","decl":"theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat := by\n  simp\n\n"}
{"name":"Int.card_fintype_Ico","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Fintype.card ↑(Set.Ico a b)) (HSub.hSub b a).toNat","decl":"theorem card_fintype_Ico : Fintype.card (Set.Ico a b) = (b - a).toNat := by\n  simp\n\n"}
{"name":"Int.card_fintype_Ioc","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Fintype.card ↑(Set.Ioc a b)) (HSub.hSub b a).toNat","decl":"theorem card_fintype_Ioc : Fintype.card (Set.Ioc a b) = (b - a).toNat := by\n  simp\n\n"}
{"name":"Int.card_fintype_Ioo","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Fintype.card ↑(Set.Ioo a b)) (HSub.hSub (HSub.hSub b a) 1).toNat","decl":"theorem card_fintype_Ioo : Fintype.card (Set.Ioo a b) = (b - a - 1).toNat := by\n  simp\n\n"}
{"name":"Int.card_fintype_uIcc","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\n⊢ Eq (Fintype.card ↑(Set.uIcc a b)) (HAdd.hAdd (HSub.hSub b a).natAbs 1)","decl":"theorem card_fintype_uIcc : Fintype.card (Set.uIcc a b) = (b - a).natAbs + 1 := by\n  simp\n\n"}
{"name":"Int.card_fintype_Icc_of_le","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\nh : LE.le a (HAdd.hAdd b 1)\n⊢ Eq (↑(Fintype.card ↑(Set.Icc a b))) (HSub.hSub (HAdd.hAdd b 1) a)","decl":"theorem card_fintype_Icc_of_le (h : a ≤ b + 1) : (Fintype.card (Set.Icc a b) : ℤ) = b + 1 - a := by\n  rw [card_fintype_Icc, toNat_sub_of_le h]\n\n"}
{"name":"Int.card_fintype_Ico_of_le","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\nh : LE.le a b\n⊢ Eq (↑(Fintype.card ↑(Set.Ico a b))) (HSub.hSub b a)","decl":"theorem card_fintype_Ico_of_le (h : a ≤ b) : (Fintype.card (Set.Ico a b) : ℤ) = b - a := by\n  rw [card_fintype_Ico, toNat_sub_of_le h]\n\n"}
{"name":"Int.card_fintype_Ioc_of_le","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\nh : LE.le a b\n⊢ Eq (↑(Fintype.card ↑(Set.Ioc a b))) (HSub.hSub b a)","decl":"theorem card_fintype_Ioc_of_le (h : a ≤ b) : (Fintype.card (Set.Ioc a b) : ℤ) = b - a := by\n  rw [card_fintype_Ioc, toNat_sub_of_le h]\n\n"}
{"name":"Int.card_fintype_Ioo_of_lt","module":"Mathlib.Data.Int.Interval","initialProofState":"a b : Int\nh : LT.lt a b\n⊢ Eq (↑(Fintype.card ↑(Set.Ioo a b))) (HSub.hSub (HSub.hSub b a) 1)","decl":"theorem card_fintype_Ioo_of_lt (h : a < b) : (Fintype.card (Set.Ioo a b) : ℤ) = b - a - 1 := by\n  rw [card_fintype_Ioo, sub_sub, toNat_sub_of_le h]\n\n"}
{"name":"Int.image_Ico_emod","module":"Mathlib.Data.Int.Interval","initialProofState":"n a : Int\nh : LE.le 0 a\n⊢ Eq (Finset.image (fun x => HMod.hMod x a) (Finset.Ico n (HAdd.hAdd n a))) (Finset.Ico 0 a)","decl":"theorem image_Ico_emod (n a : ℤ) (h : 0 ≤ a) : (Ico n (n + a)).image (· % a) = Ico 0 a := by\n  obtain rfl | ha := eq_or_lt_of_le h\n  · simp\n  ext i\n  simp only [mem_image, mem_range, mem_Ico]\n  constructor\n  · rintro ⟨i, _, rfl⟩\n    exact ⟨emod_nonneg i ha.ne', emod_lt_of_pos i ha⟩\n  intro hia\n  have hn := Int.emod_add_ediv n a\n  obtain hi | hi := lt_or_le i (n % a)\n  · refine ⟨i + a * (n / a + 1), ⟨?_, ?_⟩, ?_⟩\n    · rw [add_comm (n / a), mul_add, mul_one, ← add_assoc]\n      refine hn.symm.le.trans (add_le_add_right ?_ _)\n      simpa only [zero_add] using add_le_add hia.left (Int.emod_lt_of_pos n ha).le\n    · refine lt_of_lt_of_le (add_lt_add_right hi (a * (n / a + 1))) ?_\n      rw [mul_add, mul_one, ← add_assoc, hn]\n    · rw [Int.add_mul_emod_self_left, Int.emod_eq_of_lt hia.left hia.right]\n  · refine ⟨i + a * (n / a), ⟨?_, ?_⟩, ?_⟩\n    · exact hn.symm.le.trans (add_le_add_right hi _)\n    · rw [add_comm n a]\n      refine add_lt_add_of_lt_of_le hia.right (le_trans ?_ hn.le)\n      simp only [Nat.zero_le, le_add_iff_nonneg_left]\n      exact Int.emod_nonneg n (ne_of_gt ha)\n    · rw [Int.add_mul_emod_self_left, Int.emod_eq_of_lt hia.left hia.right]\n\n"}
