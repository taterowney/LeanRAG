{"name":"CategoryTheory.Limits.Types.isLimit_iff","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nc : CategoryTheory.Limits.Cone F\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsLimit c)) (∀ (s : (j : J) → F.obj j), Membership.mem F.sections s → ExistsUnique fun x => ∀ (j : J), Eq (c.π.app j x) (s j))","decl":"theorem isLimit_iff (c : Cone F) :\n    Nonempty (IsLimit c) ↔ ∀ s ∈ F.sections, ∃! x : c.pt, ∀ j, c.π.app j x = s j := by\n  refine ⟨fun ⟨t⟩ s hs ↦ ?_, fun h ↦ ⟨?_⟩⟩\n  · let cs := coneOfSection hs\n    exact ⟨t.lift cs ⟨⟩, fun j ↦ congr_fun (t.fac cs j) ⟨⟩,\n      fun x hx ↦ congr_fun (t.uniq cs (fun _ ↦ x) fun j ↦ funext fun _ ↦ hx j) ⟨⟩⟩\n  · choose x hx using fun c y ↦ h _ (sectionOfCone c y).2\n    exact ⟨x, fun c j ↦ funext fun y ↦ (hx c y).1 j,\n      fun c f hf ↦ funext fun y ↦ (hx c y).2 (f y) (fun j ↦ congr_fun (hf j) y)⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.isLimit_iff_bijective_sectionOfCone","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nc : CategoryTheory.Limits.Cone F\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsLimit c)) (Function.Bijective (CategoryTheory.Limits.Types.sectionOfCone c))","decl":"theorem isLimit_iff_bijective_sectionOfCone (c : Cone F) :\n    Nonempty (IsLimit c) ↔ (Types.sectionOfCone c).Bijective := by\n  simp_rw [isLimit_iff, Function.bijective_iff_existsUnique, Subtype.forall, F.sections_ext_iff,\n    sectionOfCone]\n\n"}
{"name":"CategoryTheory.Limits.Types.isLimitEquivSections_apply","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nc : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.IsLimit c\nj : J\nx : c.pt\n⊢ Eq (↑((CategoryTheory.Limits.Types.isLimitEquivSections t) x) j) (c.π.app j x)","decl":"@[simp]\ntheorem isLimitEquivSections_apply {c : Cone F} (t : IsLimit c) (j : J)\n    (x : c.pt) : (isLimitEquivSections t x : ∀ j, F.obj j) j = c.π.app j x := rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.isLimitEquivSections_symm_apply","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nc : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.IsLimit c\nx : ↑F.sections\nj : J\n⊢ Eq (c.π.app j ((CategoryTheory.Limits.Types.isLimitEquivSections t).symm x)) (↑x j)","decl":"@[simp]\ntheorem isLimitEquivSections_symm_apply {c : Cone F} (t : IsLimit c)\n    (x : F.sections) (j : J) :\n    c.π.app j ((isLimitEquivSections t).symm x) = (x : ∀ j, F.obj j) j := by\n  conv_rhs => rw [← (isLimitEquivSections t).right_inv x]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.Small.limitCone_π_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : Small.{u, max u v} ↑F.sections\nj : J\nu : ((CategoryTheory.Functor.const J).obj (Shrink.{u, max u v} ↑F.sections)).obj j\n⊢ Eq ((CategoryTheory.Limits.Types.Small.limitCone F).π.app j u) (↑((equivShrink ↑F.sections).symm u) j)","decl":"/-- (internal implementation) the limit cone of a functor,\nimplemented as flat sections of a pi type\n-/\n@[simps]\nnoncomputable def limitCone : Cone F where\n  pt := Shrink F.sections\n  π :=\n    { app := fun j u => ((equivShrink F.sections).symm u).val j\n      naturality := fun j j' f => by\n        funext x\n        simp }\n\n"}
{"name":"CategoryTheory.Limits.Types.Small.limitCone_pt","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : Small.{u, max u v} ↑F.sections\n⊢ Eq (CategoryTheory.Limits.Types.Small.limitCone F).pt (Shrink.{u, max u v} ↑F.sections)","decl":"/-- (internal implementation) the limit cone of a functor,\nimplemented as flat sections of a pi type\n-/\n@[simps]\nnoncomputable def limitCone : Cone F where\n  pt := Shrink F.sections\n  π :=\n    { app := fun j u => ((equivShrink F.sections).symm u).val j\n      naturality := fun j j' f => by\n        funext x\n        simp }\n\n"}
{"name":"CategoryTheory.Limits.Types.Small.limitCone_pt_ext_iff","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : Small.{u, max u v} ↑F.sections\nx y : (CategoryTheory.Limits.Types.Small.limitCone F).pt\n⊢ Iff (Eq x y) (Eq ((equivShrink ↑F.sections).symm x) ((equivShrink ↑F.sections).symm y))","decl":"@[ext]\nlemma limitCone_pt_ext {x y : (limitCone F).pt}\n    (w : (equivShrink F.sections).symm x = (equivShrink F.sections).symm y) : x = y := by\n  aesop\n\n"}
{"name":"CategoryTheory.Limits.Types.Small.limitCone_pt_ext","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : Small.{u, max u v} ↑F.sections\nx y : (CategoryTheory.Limits.Types.Small.limitCone F).pt\nw : Eq ((equivShrink ↑F.sections).symm x) ((equivShrink ↑F.sections).symm y)\n⊢ Eq x y","decl":"@[ext]\nlemma limitCone_pt_ext {x y : (limitCone F).pt}\n    (w : (equivShrink F.sections).symm x = (equivShrink F.sections).symm y) : x = y := by\n  aesop\n\n"}
{"name":"CategoryTheory.Limits.Types.Small.limitConeIsLimit_lift","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : Small.{u, max u v} ↑F.sections\ns : CategoryTheory.Limits.Cone F\nv : s.pt\n⊢ Eq ((CategoryTheory.Limits.Types.Small.limitConeIsLimit F).lift s v) ((equivShrink ↑F.sections) ⟨fun j => s.π.app j v, ⋯⟩)","decl":"/-- (internal implementation) the fact that the proposed limit cone is the limit -/\n@[simps]\nnoncomputable def limitConeIsLimit : IsLimit (limitCone.{v, u} F) where\n  lift s v := equivShrink F.sections\n    { val := fun j => s.π.app j v\n      property := fun f => congr_fun (Cone.w s f) _ }\n  uniq := fun _ _ w => by\n    ext x j\n    simpa using congr_fun (w j) x\n\n"}
{"name":"CategoryTheory.Limits.Types.hasLimit_iff_small_sections","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\n⊢ Iff (CategoryTheory.Limits.HasLimit F) (Small.{u, max u v} ↑F.sections)","decl":"theorem hasLimit_iff_small_sections (F : J ⥤ Type u) : HasLimit F ↔ Small.{u} F.sections :=\n  ⟨fun _ => .mk ⟨_, ⟨(Equiv.ofBijective _\n    ((isLimit_iff_bijective_sectionOfCone (limit.cone F)).mp ⟨limit.isLimit _⟩)).symm⟩⟩,\n   fun _ => ⟨_, Small.limitConeIsLimit F⟩⟩\n\n-- TODO: If `UnivLE` works out well, we will eventually want to deprecate these\n-- definitions, and probably as a first step put them in namespace or otherwise rename them.\n"}
{"name":"CategoryTheory.Limits.Types.limitCone_pt","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J TypeMax\n⊢ Eq (CategoryTheory.Limits.Types.limitCone F).pt ↑F.sections","decl":"/-- (internal implementation) the limit cone of a functor,\nimplemented as flat sections of a pi type\n-/\n@[simps]\nnoncomputable def limitCone (F : J ⥤ TypeMax.{v, u}) : Cone F where\n  pt := F.sections\n  π :=\n    { app := fun j u => u.val j\n      naturality := fun j j' f => by\n        funext x\n        simp }\n\n"}
{"name":"CategoryTheory.Limits.Types.limitCone_π_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J TypeMax\nj : J\nu : ((CategoryTheory.Functor.const J).obj ↑F.sections).obj j\n⊢ Eq ((CategoryTheory.Limits.Types.limitCone F).π.app j u) (↑u j)","decl":"/-- (internal implementation) the limit cone of a functor,\nimplemented as flat sections of a pi type\n-/\n@[simps]\nnoncomputable def limitCone (F : J ⥤ TypeMax.{v, u}) : Cone F where\n  pt := F.sections\n  π :=\n    { app := fun j u => u.val j\n      naturality := fun j j' f => by\n        funext x\n        simp }\n\n"}
{"name":"CategoryTheory.Limits.Types.limitConeIsLimit_lift_coe","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J TypeMax\ns : CategoryTheory.Limits.Cone F\nv : s.pt\nj : J\n⊢ Eq (↑((CategoryTheory.Limits.Types.limitConeIsLimit F).lift s v) j) (s.π.app j v)","decl":"/-- (internal implementation) the fact that the proposed limit cone is the limit -/\n@[simps]\nnoncomputable def limitConeIsLimit (F : J ⥤ TypeMax.{v, u}) : IsLimit (limitCone F) where\n  lift s v :=\n    { val := fun j => s.π.app j v\n      property := fun f => congr_fun (Cone.w s f) _ }\n  uniq := fun _ _ w => by\n    funext x\n    apply Subtype.ext\n    funext j\n    exact congr_fun (w j) x\n\n"}
{"name":"CategoryTheory.Limits.Types.hasLimit","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\nF : CategoryTheory.Functor J (Type u)\n⊢ CategoryTheory.Limits.HasLimit F","decl":"instance hasLimit [Small.{u} J] (F : J ⥤ Type u) : HasLimit F :=\n  (hasLimit_iff_small_sections F).mpr inferInstance\n\n"}
{"name":"CategoryTheory.Limits.Types.hasLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (Type u)","decl":"instance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J (Type u) where\n\n"}
{"name":"CategoryTheory.Limits.Types.hasLimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} (Type u)","decl":"/--\nThe category of types has all limits.\n\nMore specifically, when `UnivLE.{v, u}`, the category `Type u` has all `v`-small limits. -/\n@[stacks 002U]\ninstance (priority := 1300) hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} (Type u) where\n  has_limits_of_shape _ := { }\n\n"}
{"name":"CategoryTheory.Limits.Types.limitEquivSections_apply","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasLimit F\nx : CategoryTheory.Limits.limit F\nj : J\n⊢ Eq (↑((CategoryTheory.Limits.Types.limitEquivSections F) x) j) (CategoryTheory.Limits.limit.π F j x)","decl":"@[simp]\ntheorem limitEquivSections_apply (x : limit F) (j : J) :\n    ((limitEquivSections F) x : ∀ j, F.obj j) j = limit.π F j x :=\n  isLimitEquivSections_apply _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Types.limitEquivSections_symm_apply","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasLimit F\nx : ↑F.sections\nj : J\n⊢ Eq (CategoryTheory.Limits.limit.π F j ((CategoryTheory.Limits.Types.limitEquivSections F).symm x)) (↑x j)","decl":"@[simp]\ntheorem limitEquivSections_symm_apply (x : F.sections) (j : J) :\n    limit.π F j ((limitEquivSections F).symm x) = (x : ∀ j, F.obj j) j :=\n  isLimitEquivSections_symm_apply _ _ _\n\n-- Porting note: `limitEquivSections_symm_apply'` was removed because the linter\n--   complains it is unnecessary\n--@[simp]\n--theorem limitEquivSections_symm_apply' (F : J ⥤ Type v) (x : F.sections) (j : J) :\n--    limit.π F j ((limitEquivSections.{v, v} F).symm x) = (x : ∀ j, F.obj j) j :=\n--  isLimitEquivSections_symm_apply _ _ _\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11182): removed @[ext]\n"}
{"name":"CategoryTheory.Limits.Types.Limit.π_mk","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasLimit F\nx : (j : J) → F.obj j\nh : ∀ (j j' : J) (f : Quiver.Hom j j'), Eq (F.map f (x j)) (x j')\nj : J\n⊢ Eq (CategoryTheory.Limits.limit.π F j (CategoryTheory.Limits.Types.Limit.mk F x h)) (x j)","decl":"@[simp]\ntheorem Limit.π_mk (x : ∀ j, F.obj j) (h : ∀ (j j') (f : j ⟶ j'), F.map f (x j) = x j') (j) :\n    limit.π F j (Limit.mk F x h) = x j := by\n  dsimp [Limit.mk]\n  simp\n\n-- Porting note: `Limit.π_mk'` was removed because the linter complains it is unnecessary\n--@[simp]\n--theorem Limit.π_mk' (F : J ⥤ Type v) (x : ∀ j, F.obj j)\n--    (h : ∀ (j j') (f : j ⟶ j'), F.map f (x j) = x j') (j) :\n--    limit.π F j (Limit.mk.{v, v} F x h) = x j := by\n--  dsimp [Limit.mk]\n--  simp\n\n-- PROJECT: prove this for concrete categories where the forgetful functor preserves limits\n"}
{"name":"CategoryTheory.Limits.Types.limit_ext","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasLimit F\nx y : CategoryTheory.Limits.limit F\nw : ∀ (j : J), Eq (CategoryTheory.Limits.limit.π F j x) (CategoryTheory.Limits.limit.π F j y)\n⊢ Eq x y","decl":"@[ext]\ntheorem limit_ext (x y : limit F) (w : ∀ j, limit.π F j x = limit.π F j y) : x = y := by\n  apply (limitEquivSections F).injective\n  ext j\n  simp [w j]\n\n"}
{"name":"CategoryTheory.Limits.Types.limit_ext_iff","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasLimit F\nx y : CategoryTheory.Limits.limit F\n⊢ Iff (Eq x y) (∀ (j : J), Eq (CategoryTheory.Limits.limit.π F j x) (CategoryTheory.Limits.limit.π F j y))","decl":"@[ext]\ntheorem limit_ext (x y : limit F) (w : ∀ j, limit.π F j x = limit.π F j y) : x = y := by\n  apply (limitEquivSections F).injective\n  ext j\n  simp [w j]\n\n"}
{"name":"CategoryTheory.Limits.Types.limit_ext'","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type v)\nx y : CategoryTheory.Limits.limit F\nw : ∀ (j : J), Eq (CategoryTheory.Limits.limit.π F j x) (CategoryTheory.Limits.limit.π F j y)\n⊢ Eq x y","decl":"@[ext]\ntheorem limit_ext' (F : J ⥤ Type v) (x y : limit F) (w : ∀ j, limit.π F j x = limit.π F j y) :\n    x = y :=\n  limit_ext F x y w\n\n"}
{"name":"CategoryTheory.Limits.Types.limit_ext'_iff","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type v)\nx y : CategoryTheory.Limits.limit F\n⊢ Iff (Eq x y) (∀ (j : J), Eq (CategoryTheory.Limits.limit.π F j x) (CategoryTheory.Limits.limit.π F j y))","decl":"@[ext]\ntheorem limit_ext' (F : J ⥤ Type v) (x y : limit F) (w : ∀ j, limit.π F j x = limit.π F j y) :\n    x = y :=\n  limit_ext F x y w\n\n"}
{"name":"CategoryTheory.Limits.Types.limit_ext_iff'","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type v)\nx y : CategoryTheory.Limits.limit F\n⊢ Iff (Eq x y) (∀ (j : J), Eq (CategoryTheory.Limits.limit.π F j x) (CategoryTheory.Limits.limit.π F j y))","decl":"theorem limit_ext_iff' (F : J ⥤ Type v) (x y : limit F) :\n    x = y ↔ ∀ j, limit.π F j x = limit.π F j y :=\n  ⟨fun t _ => t ▸ rfl, limit_ext' _ _ _⟩\n\n-- TODO: are there other limits lemmas that should have `_apply` versions?\n-- Can we generate these like with `@[reassoc]`?\n-- PROJECT: prove these for any concrete category where the forgetful functor preserves limits?\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): @[simp] was removed because the linter said it was useless\n--@[simp]\n"}
{"name":"CategoryTheory.Limits.Types.Limit.w_apply","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasLimit F\nj j' : J\nx : CategoryTheory.Limits.limit F\nf : Quiver.Hom j j'\n⊢ Eq (F.map f (CategoryTheory.Limits.limit.π F j x)) (CategoryTheory.Limits.limit.π F j' x)","decl":"variable {F} in\ntheorem Limit.w_apply {j j' : J} {x : limit F} (f : j ⟶ j') :\n    F.map f (limit.π F j x) = limit.π F j' x :=\n  congr_fun (limit.w F f) x\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): @[simp] was removed because the linter said it was useless\n"}
{"name":"CategoryTheory.Limits.Types.Limit.lift_π_apply","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasLimit F\ns : CategoryTheory.Limits.Cone F\nj : J\nx : s.pt\n⊢ Eq (CategoryTheory.Limits.limit.π F j (CategoryTheory.Limits.limit.lift F s x)) (s.π.app j x)","decl":"theorem Limit.lift_π_apply (s : Cone F) (j : J) (x : s.pt) :\n    limit.π F j (limit.lift F s x) = s.π.app j x :=\n  congr_fun (limit.lift_π s j) x\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): @[simp] was removed because the linter said it was useless\n"}
{"name":"CategoryTheory.Limits.Types.Limit.map_π_apply","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝² : CategoryTheory.Category.{w, v} J\nF G : CategoryTheory.Functor J (Type u)\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit G\nα : Quiver.Hom F G\nj : J\nx : CategoryTheory.Limits.limit F\n⊢ Eq (CategoryTheory.Limits.limit.π G j (CategoryTheory.Limits.limMap α x)) (α.app j (CategoryTheory.Limits.limit.π F j x))","decl":"theorem Limit.map_π_apply {F G : J ⥤ Type u} [HasLimit F] [HasLimit G] (α : F ⟶ G) (j : J)\n    (x : limit F) : limit.π G j (limMap α x) = α.app j (limit.π F j x) :=\n  congr_fun (limMap_π α j) x\n\n"}
{"name":"CategoryTheory.Limits.Types.Limit.w_apply'","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type v)\nj j' : J\nx : CategoryTheory.Limits.limit F\nf : Quiver.Hom j j'\n⊢ Eq (F.map f (CategoryTheory.Limits.limit.π F j x)) (CategoryTheory.Limits.limit.π F j' x)","decl":"@[simp]\ntheorem Limit.w_apply' {F : J ⥤ Type v} {j j' : J} {x : limit F} (f : j ⟶ j') :\n    F.map f (limit.π F j x) = limit.π F j' x :=\n  congr_fun (limit.w F f) x\n\n"}
{"name":"CategoryTheory.Limits.Types.Limit.lift_π_apply'","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type v)\ns : CategoryTheory.Limits.Cone F\nj : J\nx : s.pt\n⊢ Eq (CategoryTheory.Limits.limit.π F j (CategoryTheory.Limits.limit.lift F s x)) (s.π.app j x)","decl":"@[simp]\ntheorem Limit.lift_π_apply' (F : J ⥤ Type v) (s : Cone F) (j : J) (x : s.pt) :\n    limit.π F j (limit.lift F s x) = s.π.app j x :=\n  congr_fun (limit.lift_π s j) x\n\n"}
{"name":"CategoryTheory.Limits.Types.Limit.map_π_apply'","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF G : CategoryTheory.Functor J (Type v)\nα : Quiver.Hom F G\nj : J\nx : CategoryTheory.Limits.limit F\n⊢ Eq (CategoryTheory.Limits.limit.π G j (CategoryTheory.Limits.limMap α x)) (α.app j (CategoryTheory.Limits.limit.π F j x))","decl":"@[simp]\ntheorem Limit.map_π_apply' {F G : J ⥤ Type v} (α : F ⟶ G) (j : J) (x : limit F) :\n    limit.π G j (limMap α x) = α.app j (limit.π F j x) :=\n  congr_fun (limMap_π α j) x\n\n"}
{"name":"CategoryTheory.Limits.Types.instSmallQuot","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\nF : CategoryTheory.Functor J (Type u)\n⊢ Small.{u, max u v} (CategoryTheory.Limits.Types.Quot F)","decl":"instance [Small.{u} J] (F : J ⥤ Type u) : Small.{u} (Quot F) :=\n  small_of_surjective Quot.mk_surjective\n\n"}
{"name":"CategoryTheory.Limits.Types.Quot.jointly_surjective","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nx : CategoryTheory.Limits.Types.Quot F\n⊢ Exists fun j => Exists fun y => Eq x (CategoryTheory.Limits.Types.Quot.ι F j y)","decl":"lemma Quot.jointly_surjective {F : J ⥤ Type u} (x : Quot F) : ∃ j y, x = Quot.ι F j y :=\n  Quot.ind (β := fun x => ∃ j y, x = Quot.ι F j y) (fun ⟨j, y⟩ => ⟨j, y, rfl⟩) x\n\n"}
{"name":"CategoryTheory.Limits.Types.Quot.ι_desc","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nc : CategoryTheory.Limits.Cocone F\nj : J\nx : F.obj j\n⊢ Eq (CategoryTheory.Limits.Types.Quot.desc c (CategoryTheory.Limits.Types.Quot.ι F j x)) (c.ι.app j x)","decl":"@[simp]\nlemma Quot.ι_desc (j : J) (x : F.obj j) : Quot.desc c (Quot.ι F j x) = c.ι.app j x := rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.Quot.map_ι","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nj j' : J\nf : Quiver.Hom j j'\nx : F.obj j\n⊢ Eq (CategoryTheory.Limits.Types.Quot.ι F j' (F.map f x)) (CategoryTheory.Limits.Types.Quot.ι F j x)","decl":"@[simp]\nlemma Quot.map_ι {j j' : J} {f : j ⟶ j'} (x : F.obj j) : Quot.ι F j' (F.map f x) = Quot.ι F j x :=\n  (Quot.sound ⟨f, rfl⟩).symm\n\n"}
{"name":"CategoryTheory.Limits.Types.quotToQuotUlift_ι","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nj : J\nx : F.obj j\n⊢ Eq (CategoryTheory.Limits.Types.quotToQuotUlift F (CategoryTheory.Limits.Types.Quot.ι F j x)) (CategoryTheory.Limits.Types.Quot.ι (F.comp CategoryTheory.uliftFunctor.{u_1, u}) j { down := x })","decl":"@[simp]\nlemma quotToQuotUlift_ι (F : J ⥤ Type u) (j : J) (x : F.obj j) :\n    quotToQuotUlift F (Quot.ι F j x) = Quot.ι _ j (ULift.up x) := by\n  dsimp [quotToQuotUlift, Quot.ι]\n\n"}
{"name":"CategoryTheory.Limits.Types.quotUliftToQuot_ι","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nj : J\nx : (F.comp CategoryTheory.uliftFunctor.{u', u}).obj j\n⊢ Eq (CategoryTheory.Limits.Types.quotUliftToQuot F (CategoryTheory.Limits.Types.Quot.ι (F.comp CategoryTheory.uliftFunctor.{u', u}) j x)) (CategoryTheory.Limits.Types.Quot.ι F j x.down)","decl":"@[simp]\nlemma quotUliftToQuot_ι (F : J ⥤ Type u) (j : J) (x : (F ⋙ uliftFunctor.{u'}).obj j) :\n    quotUliftToQuot F (Quot.ι _ j x) = Quot.ι F j x.down := by\n  dsimp [quotUliftToQuot, Quot.ι]\n\n"}
{"name":"CategoryTheory.Limits.Types.Quot.desc_quotQuotUliftEquiv","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (Function.comp (CategoryTheory.Limits.Types.Quot.desc (CategoryTheory.uliftFunctor.{u', u}.mapCocone c)) ⇑(CategoryTheory.Limits.Types.quotQuotUliftEquiv F)) (Function.comp ULift.up (CategoryTheory.Limits.Types.Quot.desc c))","decl":"lemma Quot.desc_quotQuotUliftEquiv {F : J ⥤ Type u} (c : Cocone F) :\n    Quot.desc (uliftFunctor.{u'}.mapCocone c) ∘ quotQuotUliftEquiv F = ULift.up ∘ Quot.desc c := by\n  ext x\n  obtain ⟨_, _, rfl⟩ := Quot.jointly_surjective x\n  dsimp\n\n"}
{"name":"CategoryTheory.Limits.Types.toCocone_ι_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nα : Type u\nf : CategoryTheory.Limits.Types.Quot F → α\nj : J\na✝ : F.obj j\n⊢ Eq ((CategoryTheory.Limits.Types.toCocone f).ι.app j a✝) (Function.comp f (CategoryTheory.Limits.Types.Quot.ι F j) a✝)","decl":"/-- (implementation detail) A function `Quot F → α` induces a cocone on `F` as long as the universes\n    work out. -/\n@[simps]\ndef toCocone {α : Type u} (f : Quot F → α) : Cocone F where\n  pt := α\n  ι := { app := fun j => f ∘ Quot.ι F j }\n\n"}
{"name":"CategoryTheory.Limits.Types.toCocone_pt","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nα : Type u\nf : CategoryTheory.Limits.Types.Quot F → α\n⊢ Eq (CategoryTheory.Limits.Types.toCocone f).pt α","decl":"/-- (implementation detail) A function `Quot F → α` induces a cocone on `F` as long as the universes\n    work out. -/\n@[simps]\ndef toCocone {α : Type u} (f : Quot F → α) : Cocone F where\n  pt := α\n  ι := { app := fun j => f ∘ Quot.ι F j }\n\n"}
{"name":"CategoryTheory.Limits.Types.Quot.desc_toCocone_desc","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nc : CategoryTheory.Limits.Cocone F\nα : Type u\nf : CategoryTheory.Limits.Types.Quot F → α\nhc : CategoryTheory.Limits.IsColimit c\nx : CategoryTheory.Limits.Types.Quot F\n⊢ Eq (hc.desc (CategoryTheory.Limits.Types.toCocone f) (CategoryTheory.Limits.Types.Quot.desc c x)) (f x)","decl":"lemma Quot.desc_toCocone_desc {α : Type u} (f : Quot F → α) (hc : IsColimit c) (x : Quot F) :\n    hc.desc (toCocone f) (Quot.desc c x) = f x := by\n  obtain ⟨j, y, rfl⟩ := Quot.jointly_surjective x\n  simpa using congrFun (hc.fac _ j) y\n\n"}
{"name":"CategoryTheory.Limits.Types.isColimit_iff_bijective_desc","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nc : CategoryTheory.Limits.Cocone F\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsColimit c)) (Function.Bijective (CategoryTheory.Limits.Types.Quot.desc c))","decl":"theorem isColimit_iff_bijective_desc : Nonempty (IsColimit c) ↔ (Quot.desc c).Bijective := by\n  classical\n  refine ⟨?_, ?_⟩\n  · refine fun ⟨hc⟩ => ⟨fun x y h => ?_, fun x => ?_⟩\n    · let f : Quot F → ULift.{u} Bool := fun z => ULift.up (x = z)\n      suffices f x = f y by simpa [f] using this\n      rw [← Quot.desc_toCocone_desc c f hc x, h, Quot.desc_toCocone_desc]\n    · let f₁ : c.pt ⟶ ULift.{u} Bool := fun _ => ULift.up true\n      let f₂ : c.pt ⟶ ULift.{u} Bool := fun x => ULift.up (∃ a, Quot.desc c a = x)\n      suffices f₁ = f₂ by simpa [f₁, f₂] using congrFun this x\n      refine hc.hom_ext fun j => funext fun x => ?_\n      simpa [f₁, f₂] using ⟨Quot.ι F j x, by simp⟩\n  · refine fun h => ⟨?_⟩\n    let e := Equiv.ofBijective _ h\n    have h : ∀ j x, e.symm (c.ι.app j x) = Quot.ι F j x :=\n      fun j x => e.injective (Equiv.ofBijective_apply_symm_apply _ _ _)\n    exact\n      { desc := fun s => Quot.desc s ∘ e.symm\n        fac := fun s j => by\n          ext x\n          simp [h]\n        uniq := fun s m hm => by\n          ext x\n          obtain ⟨x, rfl⟩ := e.surjective x\n          obtain ⟨j, x, rfl⟩ := Quot.jointly_surjective x\n          rw [← h, Equiv.apply_symm_apply]\n          simpa [h] using congrFun (hm j) x }\n\n"}
{"name":"CategoryTheory.Limits.Types.colimitCocone_pt","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : Small.{u, max u v} (CategoryTheory.Limits.Types.Quot F)\n⊢ Eq (CategoryTheory.Limits.Types.colimitCocone F).pt (Shrink.{u, max u v} (CategoryTheory.Limits.Types.Quot F))","decl":"/-- (internal implementation) the colimit cocone of a functor,\nimplemented as a quotient of a sigma type\n-/\n@[simps]\nnoncomputable def colimitCocone (F : J ⥤ Type u) [Small.{u} (Quot F)] : Cocone F where\n  pt := Shrink (Quot F)\n  ι :=\n    { app := fun j x => equivShrink.{u} _ (Quot.mk _ ⟨j, x⟩)\n      naturality := fun _ _ f => funext fun _ => congrArg _ (Quot.sound ⟨f, rfl⟩).symm }\n\n"}
{"name":"CategoryTheory.Limits.Types.colimitCocone_ι_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : Small.{u, max u v} (CategoryTheory.Limits.Types.Quot F)\nj : J\nx : F.obj j\n⊢ Eq ((CategoryTheory.Limits.Types.colimitCocone F).ι.app j x) ((equivShrink (CategoryTheory.Limits.Types.Quot F)) (Quot.mk (CategoryTheory.Limits.Types.Quot.Rel F) ⟨j, x⟩))","decl":"/-- (internal implementation) the colimit cocone of a functor,\nimplemented as a quotient of a sigma type\n-/\n@[simps]\nnoncomputable def colimitCocone (F : J ⥤ Type u) [Small.{u} (Quot F)] : Cocone F where\n  pt := Shrink (Quot F)\n  ι :=\n    { app := fun j x => equivShrink.{u} _ (Quot.mk _ ⟨j, x⟩)\n      naturality := fun _ _ f => funext fun _ => congrArg _ (Quot.sound ⟨f, rfl⟩).symm }\n\n"}
{"name":"CategoryTheory.Limits.Types.Quot.desc_colimitCocone","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : Small.{u, max u v} (CategoryTheory.Limits.Types.Quot F)\n⊢ Eq (CategoryTheory.Limits.Types.Quot.desc (CategoryTheory.Limits.Types.colimitCocone F)) ⇑(equivShrink (CategoryTheory.Limits.Types.Quot F))","decl":"@[simp]\ntheorem Quot.desc_colimitCocone (F : J ⥤ Type u) [Small.{u} (Quot F)] :\n    Quot.desc (colimitCocone F) = equivShrink.{u} (Quot F) := by\n  ext ⟨j, x⟩\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.hasColimit_iff_small_quot","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\n⊢ Iff (CategoryTheory.Limits.HasColimit F) (Small.{u, max u v} (CategoryTheory.Limits.Types.Quot F))","decl":"theorem hasColimit_iff_small_quot (F : J ⥤ Type u) : HasColimit F ↔ Small.{u} (Quot F) :=\n  ⟨fun _ => .mk ⟨_, ⟨(Equiv.ofBijective _\n    ((isColimit_iff_bijective_desc (colimit.cocone F)).mp ⟨colimit.isColimit _⟩))⟩⟩,\n   fun _ => ⟨_, colimitCoconeIsColimit F⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.small_quot_of_hasColimit","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasColimit F\n⊢ Small.{u, max u v} (CategoryTheory.Limits.Types.Quot F)","decl":"theorem small_quot_of_hasColimit (F : J ⥤ Type u) [HasColimit F] : Small.{u} (Quot F) :=\n  (hasColimit_iff_small_quot F).mp inferInstance\n\n"}
{"name":"CategoryTheory.Limits.Types.hasColimit","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\nF : CategoryTheory.Functor J (Type u)\n⊢ CategoryTheory.Limits.HasColimit F","decl":"instance hasColimit [Small.{u} J] (F : J ⥤ Type u) : HasColimit F :=\n  (hasColimit_iff_small_quot F).mpr inferInstance\n\n"}
{"name":"CategoryTheory.Limits.Types.hasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (Type u)","decl":"instance hasColimitsOfShape [Small.{u} J] : HasColimitsOfShape J (Type u) where\n\n"}
{"name":"CategoryTheory.Limits.Types.hasColimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{w, v, u, u + 1} (Type u)","decl":"/-- The category of types has all colimits. -/\n@[stacks 002U]\ninstance (priority := 1300) hasColimitsOfSize [UnivLE.{v, u}] :\n    HasColimitsOfSize.{w, v} (Type u) where\n\n"}
{"name":"CategoryTheory.Limits.Types.TypeMax.colimitCocone_ι_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J TypeMax\nj : J\nx : F.obj j\n⊢ Eq ((CategoryTheory.Limits.Types.TypeMax.colimitCocone F).ι.app j x) (Quot.mk (CategoryTheory.Limits.Types.Quot.Rel F) ⟨j, x⟩)","decl":"/-- (internal implementation) the colimit cocone of a functor,\nimplemented as a quotient of a sigma type\n-/\n@[simps]\ndef colimitCocone (F : J ⥤ TypeMax.{v, u}) : Cocone F where\n  pt := Quot F\n  ι :=\n    { app := fun j x => Quot.mk (Quot.Rel F) ⟨j, x⟩\n      naturality := fun _ _ f => funext fun _ => (Quot.sound ⟨f, rfl⟩).symm }\n\n"}
{"name":"CategoryTheory.Limits.Types.TypeMax.colimitCocone_pt","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J TypeMax\n⊢ Eq (CategoryTheory.Limits.Types.TypeMax.colimitCocone F).pt (CategoryTheory.Limits.Types.Quot F)","decl":"/-- (internal implementation) the colimit cocone of a functor,\nimplemented as a quotient of a sigma type\n-/\n@[simps]\ndef colimitCocone (F : J ⥤ TypeMax.{v, u}) : Cocone F where\n  pt := Quot F\n  ι :=\n    { app := fun j x => Quot.mk (Quot.Rel F) ⟨j, x⟩\n      naturality := fun _ _ f => funext fun _ => (Quot.sound ⟨f, rfl⟩).symm }\n\n"}
{"name":"CategoryTheory.Limits.Types.colimitEquivQuot_symm_apply","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\nx : F.obj j\n⊢ Eq ((CategoryTheory.Limits.Types.colimitEquivQuot F).symm (Quot.mk (CategoryTheory.Limits.Types.Quot.Rel F) ⟨j, x⟩)) (CategoryTheory.Limits.colimit.ι F j x)","decl":"@[simp]\ntheorem colimitEquivQuot_symm_apply (j : J) (x : F.obj j) :\n    (colimitEquivQuot F).symm (Quot.mk _ ⟨j, x⟩) = colimit.ι F j x :=\n  congrFun (IsColimit.comp_coconePointUniqueUpToIso_inv (colimit.isColimit F) _ _) x\n\n"}
{"name":"CategoryTheory.Limits.Types.colimitEquivQuot_apply","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj : J\nx : F.obj j\n⊢ Eq ((CategoryTheory.Limits.Types.colimitEquivQuot F) (CategoryTheory.Limits.colimit.ι F j x)) (Quot.mk (CategoryTheory.Limits.Types.Quot.Rel F) ⟨j, x⟩)","decl":"@[simp]\ntheorem colimitEquivQuot_apply (j : J) (x : F.obj j) :\n    (colimitEquivQuot F) (colimit.ι F j x) = Quot.mk _ ⟨j, x⟩ := by\n  apply (colimitEquivQuot F).symm.injective\n  simp\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): @[simp] was removed because the linter said it was useless\n"}
{"name":"CategoryTheory.Limits.Types.Colimit.w_apply","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj j' : J\nx : F.obj j\nf : Quiver.Hom j j'\n⊢ Eq (CategoryTheory.Limits.colimit.ι F j' (F.map f x)) (CategoryTheory.Limits.colimit.ι F j x)","decl":"variable {F} in\ntheorem Colimit.w_apply {j j' : J} {x : F.obj j} (f : j ⟶ j') :\n    colimit.ι F j' (F.map f x) = colimit.ι F j x :=\n  congr_fun (colimit.w F f) x\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): @[simp] was removed because the linter said it was useless\n"}
{"name":"CategoryTheory.Limits.Types.Colimit.ι_desc_apply","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasColimit F\ns : CategoryTheory.Limits.Cocone F\nj : J\nx : F.obj j\n⊢ Eq (CategoryTheory.Limits.colimit.desc F s (CategoryTheory.Limits.colimit.ι F j x)) (s.ι.app j x)","decl":"theorem Colimit.ι_desc_apply (s : Cocone F) (j : J) (x : F.obj j) :\n    colimit.desc F s (colimit.ι F j x) = s.ι.app j x :=\n   congr_fun (colimit.ι_desc s j) x\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): @[simp] was removed because the linter said it was useless\n"}
{"name":"CategoryTheory.Limits.Types.Colimit.ι_map_apply","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF G : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J (Type u)\nα : Quiver.Hom F G\nj : J\nx : F.obj j\n⊢ Eq (CategoryTheory.Limits.colim.map α (CategoryTheory.Limits.colimit.ι F j x)) (CategoryTheory.Limits.colimit.ι G j (α.app j x))","decl":"theorem Colimit.ι_map_apply {F G : J ⥤ Type u} [HasColimitsOfShape J (Type u)] (α : F ⟶ G) (j : J)\n    (x : F.obj j) : colim.map α (colimit.ι F j x) = colimit.ι G j (α.app j x) :=\n  congr_fun (colimit.ι_map α j) x\n\n"}
{"name":"CategoryTheory.Limits.Types.Colimit.w_apply'","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type v)\nj j' : J\nx : F.obj j\nf : Quiver.Hom j j'\n⊢ Eq (CategoryTheory.Limits.colimit.ι F j' (F.map f x)) (CategoryTheory.Limits.colimit.ι F j x)","decl":"@[simp]\ntheorem Colimit.w_apply' {F : J ⥤ Type v} {j j' : J} {x : F.obj j} (f : j ⟶ j') :\n    colimit.ι F j' (F.map f x) = colimit.ι F j x :=\n  congr_fun (colimit.w F f) x\n\n"}
{"name":"CategoryTheory.Limits.Types.Colimit.ι_desc_apply'","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type v)\ns : CategoryTheory.Limits.Cocone F\nj : J\nx : F.obj j\n⊢ Eq (CategoryTheory.Limits.colimit.desc F s (CategoryTheory.Limits.colimit.ι F j x)) (s.ι.app j x)","decl":"@[simp]\ntheorem Colimit.ι_desc_apply' (F : J ⥤ Type v) (s : Cocone F) (j : J) (x : F.obj j) :\n    colimit.desc F s (colimit.ι F j x) = s.ι.app j x :=\n  congr_fun (colimit.ι_desc s j) x\n\n"}
{"name":"CategoryTheory.Limits.Types.Colimit.ι_map_apply'","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF G : CategoryTheory.Functor J (Type v)\nα : Quiver.Hom F G\nj : J\nx : F.obj j\n⊢ Eq (CategoryTheory.Limits.colim.map α (CategoryTheory.Limits.colimit.ι F j x)) (CategoryTheory.Limits.colimit.ι G j (α.app j x))","decl":"@[simp]\ntheorem Colimit.ι_map_apply' {F G : J ⥤ Type v} (α : F ⟶ G) (j : J) (x) :\n    colim.map α (colimit.ι F j x) = colimit.ι G j (α.app j x) :=\n  congr_fun (colimit.ι_map α j) x\n\n"}
{"name":"CategoryTheory.Limits.Types.colimit_sound","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj j' : J\nx : F.obj j\nx' : F.obj j'\nf : Quiver.Hom j j'\nw : Eq (F.map f x) x'\n⊢ Eq (CategoryTheory.Limits.colimit.ι F j x) (CategoryTheory.Limits.colimit.ι F j' x')","decl":"variable {F} in\ntheorem colimit_sound {j j' : J} {x : F.obj j} {x' : F.obj j'} (f : j ⟶ j')\n    (w : F.map f x = x') : colimit.ι F j x = colimit.ι F j' x' := by\n  rw [← w, Colimit.w_apply]\n\n"}
{"name":"CategoryTheory.Limits.Types.colimit_sound'","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj j' : J\nx : F.obj j\nx' : F.obj j'\nj'' : J\nf : Quiver.Hom j j''\nf' : Quiver.Hom j' j''\nw : Eq (F.map f x) (F.map f' x')\n⊢ Eq (CategoryTheory.Limits.colimit.ι F j x) (CategoryTheory.Limits.colimit.ι F j' x')","decl":"variable {F} in\ntheorem colimit_sound' {j j' : J} {x : F.obj j} {x' : F.obj j'} {j'' : J}\n    (f : j ⟶ j'') (f' : j' ⟶ j'') (w : F.map f x = F.map f' x') :\n    colimit.ι F j x = colimit.ι F j' x' := by\n  rw [← colimit.w _ f, ← colimit.w _ f']\n  rw [types_comp_apply, types_comp_apply, w]\n\n"}
{"name":"CategoryTheory.Limits.Types.colimit_eq","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasColimit F\nj j' : J\nx : F.obj j\nx' : F.obj j'\nw : Eq (CategoryTheory.Limits.colimit.ι F j x) (CategoryTheory.Limits.colimit.ι F j' x')\n⊢ Relation.EqvGen (CategoryTheory.Limits.Types.Quot.Rel F) ⟨j, x⟩ ⟨j', x'⟩","decl":"variable {F} in\ntheorem colimit_eq {j j' : J} {x : F.obj j} {x' : F.obj j'}\n    (w : colimit.ι F j x = colimit.ι F j' x') :\n      Relation.EqvGen (Quot.Rel F) ⟨j, x⟩ ⟨j', x'⟩ := by\n  apply Quot.eq.1\n  simpa using congr_arg (colimitEquivQuot F) w\n\n"}
{"name":"CategoryTheory.Limits.Types.jointly_surjective_of_isColimit","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nx : t.pt\n⊢ Exists fun j => Exists fun y => Eq (t.ι.app j y) x","decl":"theorem jointly_surjective_of_isColimit {F : J ⥤ Type u} {t : Cocone F} (h : IsColimit t)\n    (x : t.pt) : ∃ j y, t.ι.app j y = x := by\n  by_contra hx\n  simp_rw [not_exists] at hx\n  apply (_ : (fun _ ↦ ULift.up True) ≠ (⟨· ≠ x⟩))\n  · refine h.hom_ext fun j ↦ ?_\n    ext y\n    exact (true_iff _).mpr (hx j y)\n  · exact fun he ↦ of_eq_true (congr_arg ULift.down <| congr_fun he x).symm rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.jointly_surjective","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nx : t.pt\n⊢ Exists fun j => Exists fun y => Eq (t.ι.app j y) x","decl":"theorem jointly_surjective (F : J ⥤ Type u) {t : Cocone F} (h : IsColimit t) (x : t.pt) :\n    ∃ j y, t.ι.app j y = x := jointly_surjective_of_isColimit h x\n\n"}
{"name":"CategoryTheory.Limits.Types.jointly_surjective'","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasColimit F\nx : CategoryTheory.Limits.colimit F\n⊢ Exists fun j => Exists fun y => Eq (CategoryTheory.Limits.colimit.ι F j y) x","decl":"variable {F} in\n/-- A variant of `jointly_surjective` for `x : colimit F`. -/\ntheorem jointly_surjective' (x : colimit F) :\n    ∃ j y, colimit.ι F j y = x :=\n  jointly_surjective F (colimit.isColimit F) x\n\n"}
{"name":"CategoryTheory.Limits.Types.nonempty_of_nonempty_colimit","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J (Type u)\ninst✝ : CategoryTheory.Limits.HasColimit F\na✝ : Nonempty (CategoryTheory.Limits.colimit F)\n⊢ Nonempty J","decl":"/-- If a colimit is nonempty, also its index category is nonempty. -/\ntheorem nonempty_of_nonempty_colimit {F : J ⥤ Type u} [HasColimit F] :\n    Nonempty (colimit F) → Nonempty J :=\n  Nonempty.map <| Sigma.fst ∘ Quot.out ∘ (colimitEquivQuot F).toFun\n\n"}
{"name":"CategoryTheory.Limits.Types.instMonoImageι","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"α β : Type u\nf : Quiver.Hom α β\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.Types.Image.ι f)","decl":"instance : Mono (Image.ι f) :=\n  (mono_iff_injective _).2 Subtype.val_injective\n\n"}
{"name":"CategoryTheory.Limits.Types.Image.lift_fac","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"α β : Type u\nf : Quiver.Hom α β\nF' : CategoryTheory.Limits.MonoFactorisation f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Types.Image.lift F') F'.m) (CategoryTheory.Limits.Types.Image.ι f)","decl":"theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ≫ F'.m = Image.ι f := by\n  funext x\n  change (F'.e ≫ F'.m) _ = _\n  rw [F'.fac, (Classical.indefiniteDescription _ x.2).2]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.instHasImage","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"α β : Type u\nf : Quiver.Hom α β\n⊢ CategoryTheory.Limits.HasImage f","decl":"instance : HasImage f :=\n  HasImage.mk ⟨_, isImage f⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.instHasImagesType","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"⊢ CategoryTheory.Limits.HasImages (Type u)","decl":"instance : HasImages (Type u) where\n  has_image := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.Types.instHasImageMapsType","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"⊢ CategoryTheory.Limits.HasImageMaps (Type u)","decl":"instance : HasImageMaps (Type u) where\n  has_image_map {f g} st :=\n    HasImageMap.transport st (monoFactorisation f.hom) (isImage g.hom)\n      (fun x => ⟨st.right x.1, ⟨st.left (Classical.choose x.2), by\n        have p := st.w\n        replace p := congr_fun p (Classical.choose x.2)\n        simp only [Functor.id_obj, Functor.id_map, types_comp_apply] at p\n        rw [p, Classical.choose_spec x.2]⟩⟩) rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.surjective_π_app_zero_of_surjective_map_aux","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"F : CategoryTheory.Functor (Opposite Nat) (Type u)\nhF : ∀ (n : Nat), Function.Surjective (F.map (CategoryTheory.homOfLE ⋯).op)\n⊢ Function.Surjective ((CategoryTheory.Limits.Types.limitCone F).π.app { unop := 0 })","decl":"include hF in\nopen limitOfSurjectionsSurjective in\n/-- Auxiliary lemma. Use `limit_of_surjections_surjective` instead. -/\nlemma surjective_π_app_zero_of_surjective_map_aux :\n    Function.Surjective ((limitCone F).π.app ⟨0⟩) := by\n  intro a\n  refine ⟨⟨fun ⟨n⟩ ↦ preimage hF a n, ?_⟩, rfl⟩\n  intro ⟨n⟩ ⟨m⟩ ⟨⟨⟨(h : m ≤ n)⟩⟩⟩\n  induction h with\n  | refl =>\n    erw [CategoryTheory.Functor.map_id, types_id_apply]\n  | @step p h ih =>\n    rw [← ih]\n    have h' : m ≤ p := h\n    erw [CategoryTheory.Functor.map_comp (f := (homOfLE (Nat.le_succ p)).op) (g := (homOfLE h').op),\n      types_comp_apply, (hF p _).choose_spec]\n    rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.surjective_π_app_zero_of_surjective_map","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"F : CategoryTheory.Functor (Opposite Nat) (Type u)\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nhF : ∀ (n : Nat), Function.Surjective (F.map (CategoryTheory.homOfLE ⋯).op)\n⊢ Function.Surjective (c.π.app { unop := 0 })","decl":"/--\nGiven surjections `⋯ ⟶ Xₙ₊₁ ⟶ Xₙ ⟶ ⋯ ⟶ X₀`, the projection map `lim Xₙ ⟶ X₀` is surjective.\n-/\nlemma surjective_π_app_zero_of_surjective_map\n    (hc : IsLimit c)\n    (hF : ∀ n, Function.Surjective (F.map (homOfLE (Nat.le_succ n)).op)) :\n    Function.Surjective (c.π.app ⟨0⟩) := by\n  let i := hc.conePointUniqueUpToIso (limitConeIsLimit F)\n  have : c.π.app ⟨0⟩ = i.hom ≫ (limitCone F).π.app ⟨0⟩ := by simp [i]\n  rw [this]\n  apply Function.Surjective.comp\n  · exact surjective_π_app_zero_of_surjective_map_aux hF\n  · rw [← epi_iff_surjective]\n    infer_instance\n\n"}
{"name":"CategoryTheory.Limits.compCoyonedaSectionsEquiv_apply_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\nX : C\ns : ↑(F.comp (CategoryTheory.coyoneda.obj { unop := X })).sections\nj : J\n⊢ Eq (((CategoryTheory.Limits.compCoyonedaSectionsEquiv F X) s).app j) (↑s j)","decl":"/-- Sections of `F ⋙ coyoneda.obj (op X)` identify to natural\ntransformations `(const J).obj X ⟶ F`. -/\n@[simps]\ndef compCoyonedaSectionsEquiv (F : J ⥤ C) (X : C) :\n    (F ⋙ coyoneda.obj (op X)).sections ≃ ((const J).obj X ⟶ F) where\n  toFun s :=\n    { app := fun j => s.val j\n      naturality := fun j j' f => by\n        dsimp\n        rw [Category.id_comp]\n        exact (s.property f).symm }\n  invFun τ := ⟨τ.app, fun {j j'} f => by simpa using (τ.naturality f).symm⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Limits.compCoyonedaSectionsEquiv_symm_apply_coe","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\nX✝ : C\nτ : Quiver.Hom ((CategoryTheory.Functor.const J).obj X✝) F\nX : J\n⊢ Eq (↑((CategoryTheory.Limits.compCoyonedaSectionsEquiv F X✝).symm τ) X) (τ.app X)","decl":"/-- Sections of `F ⋙ coyoneda.obj (op X)` identify to natural\ntransformations `(const J).obj X ⟶ F`. -/\n@[simps]\ndef compCoyonedaSectionsEquiv (F : J ⥤ C) (X : C) :\n    (F ⋙ coyoneda.obj (op X)).sections ≃ ((const J).obj X ⟶ F) where\n  toFun s :=\n    { app := fun j => s.val j\n      naturality := fun j j' f => by\n        dsimp\n        rw [Category.id_comp]\n        exact (s.property f).symm }\n  invFun τ := ⟨τ.app, fun {j j'} f => by simpa using (τ.naturality f).symm⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Limits.opCompYonedaSectionsEquiv_apply_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\nX : C\ns : ↑(F.op.comp (CategoryTheory.yoneda.obj X)).sections\nj : J\n⊢ Eq (((CategoryTheory.Limits.opCompYonedaSectionsEquiv F X) s).app j) (↑s { unop := j })","decl":"/-- Sections of `F.op ⋙ yoneda.obj X` identify to natural\ntransformations `F ⟶ (const J).obj X`. -/\n@[simps]\ndef opCompYonedaSectionsEquiv (F : J ⥤ C) (X : C) :\n    (F.op ⋙ yoneda.obj X).sections ≃ (F ⟶ (const J).obj X) where\n  toFun s :=\n    { app := fun j => s.val (op j)\n      naturality := fun j j' f => by\n        dsimp\n        rw [Category.comp_id]\n        exact (s.property f.op) }\n  invFun τ := ⟨fun j => τ.app j.unop, fun {j j'} f => by simp [τ.naturality f.unop]⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Limits.opCompYonedaSectionsEquiv_symm_apply_coe","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J C\nX : C\nτ : Quiver.Hom F ((CategoryTheory.Functor.const J).obj X)\nj : Opposite J\n⊢ Eq (↑((CategoryTheory.Limits.opCompYonedaSectionsEquiv F X).symm τ) j) (τ.app (Opposite.unop j))","decl":"/-- Sections of `F.op ⋙ yoneda.obj X` identify to natural\ntransformations `F ⟶ (const J).obj X`. -/\n@[simps]\ndef opCompYonedaSectionsEquiv (F : J ⥤ C) (X : C) :\n    (F.op ⋙ yoneda.obj X).sections ≃ (F ⟶ (const J).obj X) where\n  toFun s :=\n    { app := fun j => s.val (op j)\n      naturality := fun j j' f => by\n        dsimp\n        rw [Category.comp_id]\n        exact (s.property f.op) }\n  invFun τ := ⟨fun j => τ.app j.unop, fun {j j'} f => by simp [τ.naturality f.unop]⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Limits.compYonedaSectionsEquiv_apply_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J (Opposite C)\nX : C\ns : ↑(F.comp (CategoryTheory.yoneda.obj X)).sections\nj : J\n⊢ Eq (((CategoryTheory.Limits.compYonedaSectionsEquiv F X) s).app j) (Quiver.Hom.op (↑s j))","decl":"/-- Sections of `F ⋙ yoneda.obj X` identify to natural\ntransformations `(const J).obj X ⟶ F`. -/\n@[simps]\ndef compYonedaSectionsEquiv (F : J ⥤ Cᵒᵖ) (X : C) :\n    (F ⋙ yoneda.obj X).sections ≃ ((const J).obj (op X) ⟶ F) where\n  toFun s :=\n    { app := fun j => (s.val j).op\n      naturality := fun j j' f => by\n        dsimp\n        rw [Category.id_comp]\n        exact Quiver.Hom.unop_inj (s.property f).symm }\n  invFun τ := ⟨fun j => (τ.app j).unop,\n    fun {j j'} f => Quiver.Hom.op_inj (by simpa using (τ.naturality f).symm)⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Limits.compYonedaSectionsEquiv_symm_apply_coe","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} J\ninst✝ : CategoryTheory.Category.{u_4, u_2} C\nF : CategoryTheory.Functor J (Opposite C)\nX : C\nτ : Quiver.Hom ((CategoryTheory.Functor.const J).obj { unop := X }) F\nj : J\n⊢ Eq (↑((CategoryTheory.Limits.compYonedaSectionsEquiv F X).symm τ) j) (τ.app j).unop","decl":"/-- Sections of `F ⋙ yoneda.obj X` identify to natural\ntransformations `(const J).obj X ⟶ F`. -/\n@[simps]\ndef compYonedaSectionsEquiv (F : J ⥤ Cᵒᵖ) (X : C) :\n    (F ⋙ yoneda.obj X).sections ≃ ((const J).obj (op X) ⟶ F) where\n  toFun s :=\n    { app := fun j => (s.val j).op\n      naturality := fun j j' f => by\n        dsimp\n        rw [Category.id_comp]\n        exact Quiver.Hom.unop_inj (s.property f).symm }\n  invFun τ := ⟨fun j => (τ.app j).unop,\n    fun {j j'} f => Quiver.Hom.op_inj (by simpa using (τ.naturality f).symm)⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.Limits.limitCompCoyonedaIsoCone_inv","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nX : C\na✝ : Quiver.Hom ((CategoryTheory.Functor.const J).obj X) F\n⊢ Eq ((CategoryTheory.Limits.limitCompCoyonedaIsoCone F X).inv a✝) ((CategoryTheory.Limits.Types.limitEquivSections (F.comp (CategoryTheory.coyoneda.obj { unop := X }))).symm ((CategoryTheory.Limits.compCoyonedaSectionsEquiv F X).symm a✝))","decl":"/-- A cone on `F` with cone point `X` is the same as an element of `lim Hom(X, F·)`. -/\n@[simps!]\nnoncomputable def limitCompCoyonedaIsoCone (F : J ⥤ C) (X : C) :\n    limit (F ⋙ coyoneda.obj (op X)) ≅ ((const J).obj X ⟶ F) :=\n  ((Types.limitEquivSections _).trans (compCoyonedaSectionsEquiv F X)).toIso\n\n"}
{"name":"CategoryTheory.Limits.limitCompCoyonedaIsoCone_hom_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nX : C\na✝ : CategoryTheory.Limits.limit (F.comp (CategoryTheory.coyoneda.obj { unop := X }))\nj : J\n⊢ Eq (((CategoryTheory.Limits.limitCompCoyonedaIsoCone F X).hom a✝).app j) (CategoryTheory.Limits.limit.π (F.comp (CategoryTheory.coyoneda.obj { unop := X })) j a✝)","decl":"/-- A cone on `F` with cone point `X` is the same as an element of `lim Hom(X, F·)`. -/\n@[simps!]\nnoncomputable def limitCompCoyonedaIsoCone (F : J ⥤ C) (X : C) :\n    limit (F ⋙ coyoneda.obj (op X)) ≅ ((const J).obj X ⟶ F) :=\n  ((Types.limitEquivSections _).trans (compCoyonedaSectionsEquiv F X)).toIso\n\n"}
{"name":"CategoryTheory.Limits.coyonedaCompLimIsoCones_inv_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nX : Opposite C\na✝ : F.cones.obj X\n⊢ Eq ((CategoryTheory.Limits.coyonedaCompLimIsoCones F).inv.app X a✝) ((CategoryTheory.Limits.Types.limitEquivSections (F.comp (CategoryTheory.coyoneda.obj X))).symm ((CategoryTheory.Limits.compCoyonedaSectionsEquiv F (Opposite.unop X)).symm a✝))","decl":"/-- A cone on `F` with cone point `X` is the same as an element of `lim Hom(X, F·)`,\n    naturally in `X`. -/\n@[simps!]\nnoncomputable def coyonedaCompLimIsoCones (F : J ⥤ C) :\n    coyoneda ⋙ (whiskeringLeft _ _ _).obj F ⋙ lim ≅ F.cones :=\n  NatIso.ofComponents (fun X => limitCompCoyonedaIsoCone F X.unop)\n\n"}
{"name":"CategoryTheory.Limits.coyonedaCompLimIsoCones_hom_app_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nX : Opposite C\na✝ : (CategoryTheory.coyoneda.comp (((CategoryTheory.whiskeringLeft J C (Type v)).obj F).comp CategoryTheory.Limits.lim)).obj X\nj : J\n⊢ Eq (((CategoryTheory.Limits.coyonedaCompLimIsoCones F).hom.app X a✝).app j) (CategoryTheory.Limits.limit.π (F.comp (CategoryTheory.coyoneda.obj X)) j a✝)","decl":"/-- A cone on `F` with cone point `X` is the same as an element of `lim Hom(X, F·)`,\n    naturally in `X`. -/\n@[simps!]\nnoncomputable def coyonedaCompLimIsoCones (F : J ⥤ C) :\n    coyoneda ⋙ (whiskeringLeft _ _ _).obj F ⋙ lim ≅ F.cones :=\n  NatIso.ofComponents (fun X => limitCompCoyonedaIsoCone F X.unop)\n\n"}
{"name":"CategoryTheory.Limits.whiskeringLimYonedaIsoCones_hom_app_app_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.Functor J C\nX : Opposite C\na✝ : (CategoryTheory.coyoneda.comp (((CategoryTheory.whiskeringLeft J C (Type v)).obj X✝).comp CategoryTheory.Limits.lim)).obj X\nj : J\n⊢ Eq ((((CategoryTheory.Limits.whiskeringLimYonedaIsoCones J C).hom.app X✝).app X a✝).app j) (CategoryTheory.Limits.limit.π (X✝.comp (CategoryTheory.coyoneda.obj X)) j a✝)","decl":"variable (J) (C) in\n/-- A cone on `F` with cone point `X` is the same as an element of `lim Hom(X, F·)`,\n    naturally in `F` and `X`. -/\n@[simps!]\nnoncomputable def whiskeringLimYonedaIsoCones : whiskeringLeft _ _ _ ⋙\n    (whiskeringRight _ _ _).obj lim ⋙ (whiskeringLeft _ _ _).obj coyoneda ≅ cones J C :=\n  NatIso.ofComponents coyonedaCompLimIsoCones\n\n"}
{"name":"CategoryTheory.Limits.whiskeringLimYonedaIsoCones_inv_app_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.Functor J C\nX : Opposite C\na✝ : X✝.cones.obj X\n⊢ Eq (((CategoryTheory.Limits.whiskeringLimYonedaIsoCones J C).inv.app X✝).app X a✝) ((CategoryTheory.Limits.Types.limitEquivSections (X✝.comp (CategoryTheory.coyoneda.obj X))).symm ((CategoryTheory.Limits.compCoyonedaSectionsEquiv X✝ (Opposite.unop X)).symm a✝))","decl":"variable (J) (C) in\n/-- A cone on `F` with cone point `X` is the same as an element of `lim Hom(X, F·)`,\n    naturally in `F` and `X`. -/\n@[simps!]\nnoncomputable def whiskeringLimYonedaIsoCones : whiskeringLeft _ _ _ ⋙\n    (whiskeringRight _ _ _).obj lim ⋙ (whiskeringLeft _ _ _).obj coyoneda ≅ cones J C :=\n  NatIso.ofComponents coyonedaCompLimIsoCones\n\n"}
{"name":"CategoryTheory.Limits.limitCompYonedaIsoCocone_inv","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nX : C\na✝ : Quiver.Hom F ((CategoryTheory.Functor.const J).obj X)\n⊢ Eq ((CategoryTheory.Limits.limitCompYonedaIsoCocone F X).inv a✝) ((CategoryTheory.Limits.Types.limitEquivSections (F.op.comp (CategoryTheory.yoneda.obj X))).symm ((CategoryTheory.Limits.opCompYonedaSectionsEquiv F X).symm a✝))","decl":"/-- A cocone on `F` with cocone point `X` is the same as an element of `lim Hom(F·, X)`. -/\n@[simps!]\nnoncomputable def limitCompYonedaIsoCocone (F : J ⥤ C) (X : C) :\n    limit (F.op ⋙ yoneda.obj X) ≅ (F ⟶ (const J).obj X) :=\n  ((Types.limitEquivSections _).trans (opCompYonedaSectionsEquiv F X)).toIso\n\n"}
{"name":"CategoryTheory.Limits.limitCompYonedaIsoCocone_hom_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nX : C\na✝ : CategoryTheory.Limits.limit (F.op.comp (CategoryTheory.yoneda.obj X))\nj : J\n⊢ Eq (((CategoryTheory.Limits.limitCompYonedaIsoCocone F X).hom a✝).app j) (CategoryTheory.Limits.limit.π (F.op.comp (CategoryTheory.yoneda.obj X)) { unop := j } a✝)","decl":"/-- A cocone on `F` with cocone point `X` is the same as an element of `lim Hom(F·, X)`. -/\n@[simps!]\nnoncomputable def limitCompYonedaIsoCocone (F : J ⥤ C) (X : C) :\n    limit (F.op ⋙ yoneda.obj X) ≅ (F ⟶ (const J).obj X) :=\n  ((Types.limitEquivSections _).trans (opCompYonedaSectionsEquiv F X)).toIso\n\n"}
{"name":"CategoryTheory.Limits.yonedaCompLimIsoCocones_hom_app_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nX : C\na✝ : (CategoryTheory.yoneda.comp (((CategoryTheory.whiskeringLeft (Opposite J) (Opposite C) (Type v)).obj F.op).comp CategoryTheory.Limits.lim)).obj X\nj : J\n⊢ Eq (((CategoryTheory.Limits.yonedaCompLimIsoCocones F).hom.app X a✝).app j) (CategoryTheory.Limits.limit.π (F.op.comp (CategoryTheory.yoneda.obj X)) { unop := j } a✝)","decl":"/-- A cocone on `F` with cocone point `X` is the same as an element of `lim Hom(F·, X)`,\n    naturally in `X`. -/\n@[simps!]\nnoncomputable def yonedaCompLimIsoCocones (F : J ⥤ C) :\n    yoneda ⋙ (whiskeringLeft _ _ _).obj F.op ⋙ lim ≅ F.cocones :=\n  NatIso.ofComponents (limitCompYonedaIsoCocone F)\n\n"}
{"name":"CategoryTheory.Limits.yonedaCompLimIsoCocones_inv_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\nX : C\na✝ : F.cocones.obj X\n⊢ Eq ((CategoryTheory.Limits.yonedaCompLimIsoCocones F).inv.app X a✝) ((CategoryTheory.Limits.Types.limitEquivSections (F.op.comp (CategoryTheory.yoneda.obj X))).symm ((CategoryTheory.Limits.opCompYonedaSectionsEquiv F X).symm a✝))","decl":"/-- A cocone on `F` with cocone point `X` is the same as an element of `lim Hom(F·, X)`,\n    naturally in `X`. -/\n@[simps!]\nnoncomputable def yonedaCompLimIsoCocones (F : J ⥤ C) :\n    yoneda ⋙ (whiskeringLeft _ _ _).obj F.op ⋙ lim ≅ F.cocones :=\n  NatIso.ofComponents (limitCompYonedaIsoCocone F)\n\n"}
{"name":"CategoryTheory.Limits.opHomCompWhiskeringLimYonedaIsoCocones_inv_app_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : Opposite (CategoryTheory.Functor J C)\nX : C\na✝ : (Opposite.unop X✝).cocones.obj X\n⊢ Eq (((CategoryTheory.Limits.opHomCompWhiskeringLimYonedaIsoCocones J C).inv.app X✝).app X a✝) ((CategoryTheory.Limits.Types.limitEquivSections ((Opposite.unop X✝).op.comp (CategoryTheory.yoneda.obj X))).symm ((CategoryTheory.Limits.opCompYonedaSectionsEquiv (Opposite.unop X✝) X).symm a✝))","decl":"variable (J) (C) in\n/-- A cocone on `F` with cocone point `X` is the same as an element of `lim Hom(F·, X)`,\n    naturally in `F` and `X`. -/\n@[simps!]\nnoncomputable def opHomCompWhiskeringLimYonedaIsoCocones : opHom _ _ ⋙ whiskeringLeft _ _ _ ⋙\n      (whiskeringRight _ _ _).obj lim ⋙ (whiskeringLeft _ _ _).obj yoneda ≅ cocones J C :=\n  NatIso.ofComponents (fun F => yonedaCompLimIsoCocones F.unop)\n\n"}
{"name":"CategoryTheory.Limits.opHomCompWhiskeringLimYonedaIsoCocones_hom_app_app_app","module":"Mathlib.CategoryTheory.Limits.Types","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : Opposite (CategoryTheory.Functor J C)\nX : C\na✝ : (CategoryTheory.yoneda.comp (((CategoryTheory.whiskeringLeft (Opposite J) (Opposite C) (Type v)).obj (Opposite.unop X✝).op).comp CategoryTheory.Limits.lim)).obj X\nj : J\n⊢ Eq ((((CategoryTheory.Limits.opHomCompWhiskeringLimYonedaIsoCocones J C).hom.app X✝).app X a✝).app j) (CategoryTheory.Limits.limit.π ((Opposite.unop X✝).op.comp (CategoryTheory.yoneda.obj X)) { unop := j } a✝)","decl":"variable (J) (C) in\n/-- A cocone on `F` with cocone point `X` is the same as an element of `lim Hom(F·, X)`,\n    naturally in `F` and `X`. -/\n@[simps!]\nnoncomputable def opHomCompWhiskeringLimYonedaIsoCocones : opHom _ _ ⋙ whiskeringLeft _ _ _ ⋙\n      (whiskeringRight _ _ _).obj lim ⋙ (whiskeringLeft _ _ _).obj yoneda ≅ cocones J C :=\n  NatIso.ofComponents (fun F => yonedaCompLimIsoCocones F.unop)\n\n"}
