{"name":"CategoryTheory.GrothendieckTopology.OneHypercoverFamily.IsGenerating.le","module":"Mathlib.CategoryTheory.Sites.IsSheafOneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nH : J.OneHypercoverFamily\nself : H.IsGenerating\nX : C\nS : CategoryTheory.Sieve X\nhS : Membership.mem (J X) S\n⊢ Exists fun E => Exists fun x => LE.le E.sieve₀ S","decl":"/-- A family of 1-hypercovers generates the topology if any covering sieve\ncontains the sieve generated by the underlying covering of one of these 1-hypercovers.\nSee `OneHypercoverFamily.isSheaf_iff` for the characterization of sheaves. -/\nclass IsGenerating : Prop where\n  le {X : C} (S : Sieve X) (hS : S ∈ J X) :\n    ∃ (E : J.OneHypercover X) (_ : H E), E.sieve₀ ≤ S\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercoverFamily.exists_oneHypercover","module":"Mathlib.CategoryTheory.Sites.IsSheafOneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nH : J.OneHypercoverFamily\ninst✝ : H.IsGenerating\nX : C\nS : CategoryTheory.Sieve X\nhS : Membership.mem (J X) S\n⊢ Exists fun E => Exists fun x => LE.le E.sieve₀ S","decl":"lemma exists_oneHypercover [H.IsGenerating] {X : C} (S : Sieve X) (hS : S ∈ J X) :\n    ∃ (E : J.OneHypercover X) (_ : H E), E.sieve₀ ≤ S :=\n  IsGenerating.le _ hS\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercoverFamily.IsSheafIff.hom_ext","module":"Mathlib.CategoryTheory.Sites.IsSheafOneHypercover","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\nH : J.OneHypercoverFamily\nP : CategoryTheory.Functor (Opposite C) A\nhP : ∀ ⦃X : C⦄ (E : J.OneHypercover X), H E → Nonempty (CategoryTheory.Limits.IsLimit (E.multifork P))\ninst✝ : H.IsGenerating\nX : C\nS : CategoryTheory.Sieve X\nhS : Membership.mem (J X) S\nT : A\nx y : Quiver.Hom T (P.obj { unop := X })\nh : ∀ ⦃Y : C⦄ (f : Quiver.Hom Y X), S.arrows f → Eq (CategoryTheory.CategoryStruct.comp x (P.map f.op)) (CategoryTheory.CategoryStruct.comp y (P.map f.op))\n⊢ Eq x y","decl":"include hP in\nlemma hom_ext [H.IsGenerating] {X : C} (S : Sieve X) (hS : S ∈ J X) {T : A}\n    {x y : T ⟶ P.obj (Opposite.op X)}\n    (h : ∀ ⦃Y : C⦄ (f : Y ⟶ X) (_ : S f), x ≫ P.map f.op = y ≫ P.map f.op) :\n    x = y := by\n  obtain ⟨E, hE, le⟩ := H.exists_oneHypercover S hS\n  exact Multifork.IsLimit.hom_ext (hP E hE).some (fun j => h _ (le _ (Sieve.ofArrows_mk _ _ _)))\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercoverFamily.IsSheafIff.fac'_assoc","module":"Mathlib.CategoryTheory.Sites.IsSheafOneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} A\nH : J.OneHypercoverFamily\nP : CategoryTheory.Functor (Opposite C) A\nhP : ∀ ⦃X : C⦄ (E : J.OneHypercover X), H E → Nonempty (CategoryTheory.Limits.IsLimit (E.multifork P))\nX : C\nS : CategoryTheory.Sieve X\nE : J.OneHypercover X\nhE : H E\nle : LE.le E.sieve₀ S\nF : CategoryTheory.Limits.Multifork (CategoryTheory.GrothendieckTopology.Cover.index ⟨S, ⋯⟩ P)\ni : E.I₀\nZ : A\nh : Quiver.Hom (P.obj { unop := E.X i }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GrothendieckTopology.OneHypercoverFamily.IsSheafIff.lift hP hE le F) (CategoryTheory.CategoryStruct.comp (P.map (E.f i).op) h)) (CategoryTheory.CategoryStruct.comp (F.ι { Y := E.X i, f := E.f i, hf := ⋯ }) h)","decl":"@[reassoc]\nlemma fac' (i : E.I₀) :\n    lift hP hE le F ≫ P.map (E.f i).op =\n      F.ι ⟨_, E.f i, le _ (Sieve.ofArrows_mk _ _ _)⟩ :=\n  Multifork.IsLimit.fac (hP E hE).some _ _ i\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercoverFamily.IsSheafIff.fac'","module":"Mathlib.CategoryTheory.Sites.IsSheafOneHypercover","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} A\nH : J.OneHypercoverFamily\nP : CategoryTheory.Functor (Opposite C) A\nhP : ∀ ⦃X : C⦄ (E : J.OneHypercover X), H E → Nonempty (CategoryTheory.Limits.IsLimit (E.multifork P))\nX : C\nS : CategoryTheory.Sieve X\nE : J.OneHypercover X\nhE : H E\nle : LE.le E.sieve₀ S\nF : CategoryTheory.Limits.Multifork (CategoryTheory.GrothendieckTopology.Cover.index ⟨S, ⋯⟩ P)\ni : E.I₀\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GrothendieckTopology.OneHypercoverFamily.IsSheafIff.lift hP hE le F) (P.map (E.f i).op)) (F.ι { Y := E.X i, f := E.f i, hf := ⋯ })","decl":"@[reassoc]\nlemma fac' (i : E.I₀) :\n    lift hP hE le F ≫ P.map (E.f i).op =\n      F.ι ⟨_, E.f i, le _ (Sieve.ofArrows_mk _ _ _)⟩ :=\n  Multifork.IsLimit.fac (hP E hE).some _ _ i\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercoverFamily.IsSheafIff.fac","module":"Mathlib.CategoryTheory.Sites.IsSheafOneHypercover","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\nH : J.OneHypercoverFamily\nP : CategoryTheory.Functor (Opposite C) A\nhP : ∀ ⦃X : C⦄ (E : J.OneHypercover X), H E → Nonempty (CategoryTheory.Limits.IsLimit (E.multifork P))\nX : C\nS : CategoryTheory.Sieve X\nE : J.OneHypercover X\nhE : H E\nle : LE.le E.sieve₀ S\nF : CategoryTheory.Limits.Multifork (CategoryTheory.GrothendieckTopology.Cover.index ⟨S, ⋯⟩ P)\ninst✝ : H.IsGenerating\nY : C\nf : Quiver.Hom Y X\nhf : S.arrows f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GrothendieckTopology.OneHypercoverFamily.IsSheafIff.lift hP hE le F) (P.map f.op)) (F.ι { Y := Y, f := f, hf := hf })","decl":"lemma fac [H.IsGenerating] {Y : C} (f : Y ⟶ X) (hf : S f) :\n    lift hP hE le F ≫ P.map f.op = F.ι ⟨Y, f, hf⟩ := by\n  apply hom_ext H P hP _ (J.pullback_stable f E.mem₀)\n  intro Z g\n  rintro ⟨T, a, b, hb, fac⟩\n  cases' hb with i\n  rw [assoc, ← P.map_comp, ← op_comp, ← fac,\n    op_comp, P.map_comp, fac'_assoc]\n  exact F.condition (Cover.Relation.mk { hf := le _ (Sieve.ofArrows_mk _ _ _) }\n    { hf := hf } { w := fac })\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.OneHypercoverFamily.isSheaf_iff","module":"Mathlib.CategoryTheory.Sites.IsSheafOneHypercover","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\nH : J.OneHypercoverFamily\nP : CategoryTheory.Functor (Opposite C) A\ninst✝ : H.IsGenerating\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (∀ ⦃X : C⦄ (E : J.OneHypercover X), H E → Nonempty (CategoryTheory.Limits.IsLimit (E.multifork P)))","decl":"lemma isSheaf_iff [H.IsGenerating] :\n    Presheaf.IsSheaf J P ↔ ∀ ⦃X : C⦄ (E : J.OneHypercover X)\n      (_ : H E), Nonempty (IsLimit (E.multifork P)) := by\n  constructor\n  · intro hP X E _\n    exact ⟨E.isLimitMultifork ⟨_, hP⟩⟩\n  · intro hP\n    rw [Presheaf.isSheaf_iff_multifork]\n    rintro X ⟨S, hS⟩\n    obtain ⟨E, hE, le⟩ := H.exists_oneHypercover S hS\n    exact ⟨IsSheafIff.isLimit hP hE le⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.instIsGeneratedByOneHypercovers","module":"Mathlib.CategoryTheory.Sites.IsSheafOneHypercover","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\n⊢ J.IsGeneratedByOneHypercovers","decl":"instance : IsGeneratedByOneHypercovers.{max u v} J where\n  le S hS := ⟨Cover.oneHypercover ⟨S, hS⟩, by simp, by simp⟩\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_of_isGeneratedByOneHypercovers","module":"Mathlib.CategoryTheory.Sites.IsSheafOneHypercover","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} A\ninst✝ : J.IsGeneratedByOneHypercovers\nP : CategoryTheory.Functor (Opposite C) A\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (∀ ⦃X : C⦄ (E : J.OneHypercover X), Nonempty (CategoryTheory.Limits.IsLimit (E.multifork P)))","decl":"lemma isSheaf_iff_of_isGeneratedByOneHypercovers\n    [GrothendieckTopology.IsGeneratedByOneHypercovers.{w} J] (P : Cᵒᵖ ⥤ A) :\n    IsSheaf J P ↔ ∀ ⦃X : C⦄ (E : GrothendieckTopology.OneHypercover.{w} J X),\n        Nonempty (IsLimit (E.multifork P)) := by\n  simpa using GrothendieckTopology.OneHypercoverFamily.isSheaf_iff.{w} ⊤ P\n\n"}
