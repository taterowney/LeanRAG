{"name":"Turing.reaches₁_eq","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b c : σ\nh : Eq (f a) (f b)\n⊢ Iff (Turing.Reaches₁ f a c) (Turing.Reaches₁ f b c)","decl":"theorem reaches₁_eq {σ} {f : σ → Option σ} {a b c} (h : f a = f b) :\n    Reaches₁ f a c ↔ Reaches₁ f b c :=\n  TransGen.head'_iff.trans (TransGen.head'_iff.trans <| by rw [h]).symm\n\n"}
{"name":"Turing.reaches_total","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b c : σ\nhab : Turing.Reaches f a b\nhac : Turing.Reaches f a c\n⊢ Or (Turing.Reaches f b c) (Turing.Reaches f c b)","decl":"theorem reaches_total {σ} {f : σ → Option σ} {a b c} (hab : Reaches f a b) (hac : Reaches f a c) :\n    Reaches f b c ∨ Reaches f c b :=\n  ReflTransGen.total_of_right_unique (fun _ _ _ ↦ Option.mem_unique) hab hac\n\n"}
{"name":"Turing.reaches₁_fwd","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b c : σ\nh₁ : Turing.Reaches₁ f a c\nh₂ : Membership.mem (f a) b\n⊢ Turing.Reaches f b c","decl":"theorem reaches₁_fwd {σ} {f : σ → Option σ} {a b c} (h₁ : Reaches₁ f a c) (h₂ : b ∈ f a) :\n    Reaches f b c := by\n  rcases TransGen.head'_iff.1 h₁ with ⟨b', hab, hbc⟩\n  cases Option.mem_unique hab h₂; exact hbc\n\n"}
{"name":"Turing.Reaches₀.trans","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b c : σ\nh₁ : Turing.Reaches₀ f a b\nh₂ : Turing.Reaches₀ f b c\n⊢ Turing.Reaches₀ f a c","decl":"theorem Reaches₀.trans {σ} {f : σ → Option σ} {a b c : σ} (h₁ : Reaches₀ f a b)\n    (h₂ : Reaches₀ f b c) : Reaches₀ f a c\n  | _, h₃ => h₁ _ (h₂ _ h₃)\n\n"}
{"name":"Turing.Reaches₀.refl","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na : σ\n⊢ Turing.Reaches₀ f a a","decl":"@[refl]\ntheorem Reaches₀.refl {σ} {f : σ → Option σ} (a : σ) : Reaches₀ f a a\n  | _, h => h\n\n"}
{"name":"Turing.Reaches₀.single","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b : σ\nh : Membership.mem (f a) b\n⊢ Turing.Reaches₀ f a b","decl":"theorem Reaches₀.single {σ} {f : σ → Option σ} {a b : σ} (h : b ∈ f a) : Reaches₀ f a b\n  | _, h₂ => h₂.head h\n\n"}
{"name":"Turing.Reaches₀.head","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b c : σ\nh : Membership.mem (f a) b\nh₂ : Turing.Reaches₀ f b c\n⊢ Turing.Reaches₀ f a c","decl":"theorem Reaches₀.head {σ} {f : σ → Option σ} {a b c : σ} (h : b ∈ f a) (h₂ : Reaches₀ f b c) :\n    Reaches₀ f a c :=\n  (Reaches₀.single h).trans h₂\n\n"}
{"name":"Turing.Reaches₀.tail","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b c : σ\nh₁ : Turing.Reaches₀ f a b\nh : Membership.mem (f b) c\n⊢ Turing.Reaches₀ f a c","decl":"theorem Reaches₀.tail {σ} {f : σ → Option σ} {a b c : σ} (h₁ : Reaches₀ f a b) (h : c ∈ f b) :\n    Reaches₀ f a c :=\n  h₁.trans (Reaches₀.single h)\n\n"}
{"name":"Turing.reaches₀_eq","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b : σ\ne : Eq (f a) (f b)\n⊢ Turing.Reaches₀ f a b","decl":"theorem reaches₀_eq {σ} {f : σ → Option σ} {a b} (e : f a = f b) : Reaches₀ f a b\n  | _, h => (reaches₁_eq e).2 h\n\n"}
{"name":"Turing.Reaches₁.to₀","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b : σ\nh : Turing.Reaches₁ f a b\n⊢ Turing.Reaches₀ f a b","decl":"theorem Reaches₁.to₀ {σ} {f : σ → Option σ} {a b : σ} (h : Reaches₁ f a b) : Reaches₀ f a b\n  | _, h₂ => h.trans h₂\n\n"}
{"name":"Turing.Reaches.to₀","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b : σ\nh : Turing.Reaches f a b\n⊢ Turing.Reaches₀ f a b","decl":"theorem Reaches.to₀ {σ} {f : σ → Option σ} {a b : σ} (h : Reaches f a b) : Reaches₀ f a b\n  | _, h₂ => h₂.trans_right h\n\n"}
{"name":"Turing.Reaches₀.tail'","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b c : σ\nh : Turing.Reaches₀ f a b\nh₂ : Membership.mem (f b) c\n⊢ Turing.Reaches₁ f a c","decl":"theorem Reaches₀.tail' {σ} {f : σ → Option σ} {a b c : σ} (h : Reaches₀ f a b) (h₂ : c ∈ f b) :\n    Reaches₁ f a c :=\n  h _ (TransGen.single h₂)\n\n"}
{"name":"Turing.mem_eval","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b : σ\n⊢ Iff (Membership.mem (Turing.eval f a) b) (And (Turing.Reaches f a b) (Eq (f b) Option.none))","decl":"theorem mem_eval {σ} {f : σ → Option σ} {a b} : b ∈ eval f a ↔ Reaches f a b ∧ f b = none := by\n  refine ⟨fun h ↦ ?_, fun ⟨h₁, h₂⟩ ↦ ?_⟩\n  · refine evalInduction h fun a h IH ↦ ?_\n    cases' e : f a with a'\n    · rw [Part.mem_unique h\n          (PFun.mem_fix_iff.2 <| Or.inl <| Part.mem_some_iff.2 <| by rw [e]; rfl)]\n      exact ⟨ReflTransGen.refl, e⟩\n    · rcases PFun.mem_fix_iff.1 h with (h | ⟨_, h, _⟩) <;> rw [e] at h <;>\n        cases Part.mem_some_iff.1 h\n      cases' IH a' e with h₁ h₂\n      exact ⟨ReflTransGen.head e h₁, h₂⟩\n  · refine ReflTransGen.head_induction_on h₁ ?_ fun h _ IH ↦ ?_\n    · refine PFun.mem_fix_iff.2 (Or.inl ?_)\n      rw [h₂]\n      apply Part.mem_some\n    · refine PFun.mem_fix_iff.2 (Or.inr ⟨_, ?_, IH⟩)\n      rw [h]\n      apply Part.mem_some\n\n"}
{"name":"Turing.eval_maximal₁","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b : σ\nh : Membership.mem (Turing.eval f a) b\nc : σ\n⊢ Not (Turing.Reaches₁ f b c)","decl":"theorem eval_maximal₁ {σ} {f : σ → Option σ} {a b} (h : b ∈ eval f a) (c) : ¬Reaches₁ f b c\n  | bc => by\n    let ⟨_, b0⟩ := mem_eval.1 h\n    let ⟨b', h', _⟩ := TransGen.head'_iff.1 bc\n    cases b0.symm.trans h'\n\n"}
{"name":"Turing.eval_maximal","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b : σ\nh : Membership.mem (Turing.eval f a) b\nc : σ\n⊢ Iff (Turing.Reaches f b c) (Eq c b)","decl":"theorem eval_maximal {σ} {f : σ → Option σ} {a b} (h : b ∈ eval f a) {c} : Reaches f b c ↔ c = b :=\n  let ⟨_, b0⟩ := mem_eval.1 h\n  reflTransGen_iff_eq fun b' h' ↦ by cases b0.symm.trans h'\n\n"}
{"name":"Turing.reaches_eval","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ : Type u_1\nf : σ → Option σ\na b : σ\nab : Turing.Reaches f a b\n⊢ Eq (Turing.eval f a) (Turing.eval f b)","decl":"theorem reaches_eval {σ} {f : σ → Option σ} {a b} (ab : Reaches f a b) : eval f a = eval f b := by\n  refine Part.ext fun _ ↦ ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · have ⟨ac, c0⟩ := mem_eval.1 h\n    exact mem_eval.2 ⟨(or_iff_left_of_imp fun cb ↦ (eval_maximal h).1 cb ▸ ReflTransGen.refl).1\n      (reaches_total ab ac), c0⟩\n  · have ⟨bc, c0⟩ := mem_eval.1 h\n    exact mem_eval.2 ⟨ab.trans bc, c0⟩\n\n"}
{"name":"Turing.tr_reaches₁","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ₁ : Type u_1\nσ₂ : Type u_2\nf₁ : σ₁ → Option σ₁\nf₂ : σ₂ → Option σ₂\ntr : σ₁ → σ₂ → Prop\nH : Turing.Respects f₁ f₂ tr\na₁ : σ₁\na₂ : σ₂\naa : tr a₁ a₂\nb₁ : σ₁\nab : Turing.Reaches₁ f₁ a₁ b₁\n⊢ Exists fun b₂ => And (tr b₁ b₂) (Turing.Reaches₁ f₂ a₂ b₂)","decl":"theorem tr_reaches₁ {σ₁ σ₂ f₁ f₂} {tr : σ₁ → σ₂ → Prop} (H : Respects f₁ f₂ tr) {a₁ a₂}\n    (aa : tr a₁ a₂) {b₁} (ab : Reaches₁ f₁ a₁ b₁) : ∃ b₂, tr b₁ b₂ ∧ Reaches₁ f₂ a₂ b₂ := by\n  induction' ab with c₁ ac c₁ d₁ _ cd IH\n  · have := H aa\n    rwa [show f₁ a₁ = _ from ac] at this\n  · rcases IH with ⟨c₂, cc, ac₂⟩\n    have := H cc\n    rw [show f₁ c₁ = _ from cd] at this\n    rcases this with ⟨d₂, dd, cd₂⟩\n    exact ⟨_, dd, ac₂.trans cd₂⟩\n\n"}
{"name":"Turing.tr_reaches","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ₁ : Type u_1\nσ₂ : Type u_2\nf₁ : σ₁ → Option σ₁\nf₂ : σ₂ → Option σ₂\ntr : σ₁ → σ₂ → Prop\nH : Turing.Respects f₁ f₂ tr\na₁ : σ₁\na₂ : σ₂\naa : tr a₁ a₂\nb₁ : σ₁\nab : Turing.Reaches f₁ a₁ b₁\n⊢ Exists fun b₂ => And (tr b₁ b₂) (Turing.Reaches f₂ a₂ b₂)","decl":"theorem tr_reaches {σ₁ σ₂ f₁ f₂} {tr : σ₁ → σ₂ → Prop} (H : Respects f₁ f₂ tr) {a₁ a₂}\n    (aa : tr a₁ a₂) {b₁} (ab : Reaches f₁ a₁ b₁) : ∃ b₂, tr b₁ b₂ ∧ Reaches f₂ a₂ b₂ := by\n  rcases reflTransGen_iff_eq_or_transGen.1 ab with (rfl | ab)\n  · exact ⟨_, aa, ReflTransGen.refl⟩\n  · have ⟨b₂, bb, h⟩ := tr_reaches₁ H aa ab\n    exact ⟨b₂, bb, h.to_reflTransGen⟩\n\n"}
{"name":"Turing.tr_reaches_rev","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ₁ : Type u_1\nσ₂ : Type u_2\nf₁ : σ₁ → Option σ₁\nf₂ : σ₂ → Option σ₂\ntr : σ₁ → σ₂ → Prop\nH : Turing.Respects f₁ f₂ tr\na₁ : σ₁\na₂ : σ₂\naa : tr a₁ a₂\nb₂ : σ₂\nab : Turing.Reaches f₂ a₂ b₂\n⊢ Exists fun c₁ => Exists fun c₂ => And (Turing.Reaches f₂ b₂ c₂) (And (tr c₁ c₂) (Turing.Reaches f₁ a₁ c₁))","decl":"theorem tr_reaches_rev {σ₁ σ₂ f₁ f₂} {tr : σ₁ → σ₂ → Prop} (H : Respects f₁ f₂ tr) {a₁ a₂}\n    (aa : tr a₁ a₂) {b₂} (ab : Reaches f₂ a₂ b₂) :\n    ∃ c₁ c₂, Reaches f₂ b₂ c₂ ∧ tr c₁ c₂ ∧ Reaches f₁ a₁ c₁ := by\n  induction' ab with c₂ d₂ _ cd IH\n  · exact ⟨_, _, ReflTransGen.refl, aa, ReflTransGen.refl⟩\n  · rcases IH with ⟨e₁, e₂, ce, ee, ae⟩\n    rcases ReflTransGen.cases_head ce with (rfl | ⟨d', cd', de⟩)\n    · have := H ee\n      revert this\n      cases' eg : f₁ e₁ with g₁ <;> simp only [Respects, and_imp, exists_imp]\n      · intro c0\n        cases cd.symm.trans c0\n      · intro g₂ gg cg\n        rcases TransGen.head'_iff.1 cg with ⟨d', cd', dg⟩\n        cases Option.mem_unique cd cd'\n        exact ⟨_, _, dg, gg, ae.tail eg⟩\n    · cases Option.mem_unique cd cd'\n      exact ⟨_, _, de, ee, ae⟩\n\n"}
{"name":"Turing.tr_eval","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ₁ : Type u_1\nσ₂ : Type u_2\nf₁ : σ₁ → Option σ₁\nf₂ : σ₂ → Option σ₂\ntr : σ₁ → σ₂ → Prop\nH : Turing.Respects f₁ f₂ tr\na₁ b₁ : σ₁\na₂ : σ₂\naa : tr a₁ a₂\nab : Membership.mem (Turing.eval f₁ a₁) b₁\n⊢ Exists fun b₂ => And (tr b₁ b₂) (Membership.mem (Turing.eval f₂ a₂) b₂)","decl":"theorem tr_eval {σ₁ σ₂ f₁ f₂} {tr : σ₁ → σ₂ → Prop} (H : Respects f₁ f₂ tr) {a₁ b₁ a₂}\n    (aa : tr a₁ a₂) (ab : b₁ ∈ eval f₁ a₁) : ∃ b₂, tr b₁ b₂ ∧ b₂ ∈ eval f₂ a₂ := by\n  cases' mem_eval.1 ab with ab b0\n  rcases tr_reaches H aa ab with ⟨b₂, bb, ab⟩\n  refine ⟨_, bb, mem_eval.2 ⟨ab, ?_⟩⟩\n  have := H bb; rwa [b0] at this\n\n"}
{"name":"Turing.tr_eval_rev","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ₁ : Type u_1\nσ₂ : Type u_2\nf₁ : σ₁ → Option σ₁\nf₂ : σ₂ → Option σ₂\ntr : σ₁ → σ₂ → Prop\nH : Turing.Respects f₁ f₂ tr\na₁ : σ₁\nb₂ a₂ : σ₂\naa : tr a₁ a₂\nab : Membership.mem (Turing.eval f₂ a₂) b₂\n⊢ Exists fun b₁ => And (tr b₁ b₂) (Membership.mem (Turing.eval f₁ a₁) b₁)","decl":"theorem tr_eval_rev {σ₁ σ₂ f₁ f₂} {tr : σ₁ → σ₂ → Prop} (H : Respects f₁ f₂ tr) {a₁ b₂ a₂}\n    (aa : tr a₁ a₂) (ab : b₂ ∈ eval f₂ a₂) : ∃ b₁, tr b₁ b₂ ∧ b₁ ∈ eval f₁ a₁ := by\n  cases' mem_eval.1 ab with ab b0\n  rcases tr_reaches_rev H aa ab with ⟨c₁, c₂, bc, cc, ac⟩\n  cases (reflTransGen_iff_eq (Option.eq_none_iff_forall_not_mem.1 b0)).1 bc\n  refine ⟨_, cc, mem_eval.2 ⟨ac, ?_⟩⟩\n  have := H cc\n  cases' hfc : f₁ c₁ with d₁\n  · rfl\n  rw [hfc] at this\n  rcases this with ⟨d₂, _, bd⟩\n  rcases TransGen.head'_iff.1 bd with ⟨e, h, _⟩\n  cases b0.symm.trans h\n\n"}
{"name":"Turing.tr_eval_dom","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ₁ : Type u_1\nσ₂ : Type u_2\nf₁ : σ₁ → Option σ₁\nf₂ : σ₂ → Option σ₂\ntr : σ₁ → σ₂ → Prop\nH : Turing.Respects f₁ f₂ tr\na₁ : σ₁\na₂ : σ₂\naa : tr a₁ a₂\n⊢ Iff (Turing.eval f₂ a₂).Dom (Turing.eval f₁ a₁).Dom","decl":"theorem tr_eval_dom {σ₁ σ₂ f₁ f₂} {tr : σ₁ → σ₂ → Prop} (H : Respects f₁ f₂ tr) {a₁ a₂}\n    (aa : tr a₁ a₂) : (eval f₂ a₂).Dom ↔ (eval f₁ a₁).Dom :=\n  ⟨fun h ↦\n    let ⟨_, _, h, _⟩ := tr_eval_rev H aa ⟨h, rfl⟩\n    h,\n    fun h ↦\n    let ⟨_, _, h, _⟩ := tr_eval H aa ⟨h, rfl⟩\n    h⟩\n\n"}
{"name":"Turing.frespects_eq","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ₁ : Type u_1\nσ₂ : Type u_2\nf₂ : σ₂ → Option σ₂\ntr : σ₁ → σ₂\na₂ b₂ : σ₂\nh : Eq (f₂ a₂) (f₂ b₂)\nb₁ : Option σ₁\n⊢ Iff (Turing.FRespects f₂ tr a₂ b₁) (Turing.FRespects f₂ tr b₂ b₁)","decl":"theorem frespects_eq {σ₁ σ₂} {f₂ : σ₂ → Option σ₂} {tr : σ₁ → σ₂} {a₂ b₂} (h : f₂ a₂ = f₂ b₂) :\n    ∀ {b₁}, FRespects f₂ tr a₂ b₁ ↔ FRespects f₂ tr b₂ b₁\n  | some _ => reaches₁_eq h\n  | none => by unfold FRespects; rw [h]\n\n"}
{"name":"Turing.fun_respects","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ₁ : Type u_1\nσ₂ : Type u_2\nf₁ : σ₁ → Option σ₁\nf₂ : σ₂ → Option σ₂\ntr : σ₁ → σ₂\n⊢ Iff (Turing.Respects f₁ f₂ fun a b => Eq (tr a) b) (∀ ⦃a₁ : σ₁⦄, Turing.FRespects f₂ tr (tr a₁) (f₁ a₁))","decl":"theorem fun_respects {σ₁ σ₂ f₁ f₂} {tr : σ₁ → σ₂} :\n    (Respects f₁ f₂ fun a b ↦ tr a = b) ↔ ∀ ⦃a₁⦄, FRespects f₂ tr (tr a₁) (f₁ a₁) :=\n  forall_congr' fun a₁ ↦ by\n    cases f₁ a₁ <;> simp only [FRespects, Respects, exists_eq_left', forall_eq']\n\n"}
{"name":"Turing.tr_eval'","module":"Mathlib.Computability.TuringMachine","initialProofState":"σ₁ σ₂ : Type u_1\nf₁ : σ₁ → Option σ₁\nf₂ : σ₂ → Option σ₂\ntr : σ₁ → σ₂\nH : Turing.Respects f₁ f₂ fun a b => Eq (tr a) b\na₁ : σ₁\n⊢ Eq (Turing.eval f₂ (tr a₁)) (Functor.map tr (Turing.eval f₁ a₁))","decl":"theorem tr_eval' {σ₁ σ₂} (f₁ : σ₁ → Option σ₁) (f₂ : σ₂ → Option σ₂) (tr : σ₁ → σ₂)\n    (H : Respects f₁ f₂ fun a b ↦ tr a = b) (a₁) : eval f₂ (tr a₁) = tr <$> eval f₁ a₁ :=\n  Part.ext fun b₂ ↦\n    ⟨fun h ↦\n      let ⟨b₁, bb, hb⟩ := tr_eval_rev H rfl h\n      (Part.mem_map_iff _).2 ⟨b₁, hb, bb⟩,\n      fun h ↦ by\n      rcases (Part.mem_map_iff _).1 h with ⟨b₁, ab, bb⟩\n      rcases tr_eval H rfl ab with ⟨_, rfl, h⟩\n      rwa [bb] at h⟩\n\n"}
{"name":"Turing.TM0.Stmt.move.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\ninst✝ : SizeOf Γ\na✝ : Turing.Dir\n⊢ Eq (SizeOf.sizeOf (Turing.TM0.Stmt.move a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- A Turing machine \"statement\" is just a command to either move\n  left or right, or write a symbol on the tape. -/\ninductive Stmt\n  | move : Dir → Stmt\n  | write : Γ → Stmt\n\n"}
{"name":"Turing.TM0.Stmt.move.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\na✝¹ a✝ : Turing.Dir\n⊢ Eq (Eq (Turing.TM0.Stmt.move a✝¹) (Turing.TM0.Stmt.move a✝)) (Eq a✝¹ a✝)","decl":"/-- A Turing machine \"statement\" is just a command to either move\n  left or right, or write a symbol on the tape. -/\ninductive Stmt\n  | move : Dir → Stmt\n  | write : Γ → Stmt\n\n"}
{"name":"Turing.TM0.Stmt.move.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\na✝¹ a✝ : Turing.Dir\nx✝ : Eq (Turing.TM0.Stmt.move a✝¹) (Turing.TM0.Stmt.move a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- A Turing machine \"statement\" is just a command to either move\n  left or right, or write a symbol on the tape. -/\ninductive Stmt\n  | move : Dir → Stmt\n  | write : Γ → Stmt\n\n"}
{"name":"Turing.TM0.Stmt.write.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\na✝¹ a✝ : Γ\n⊢ Eq (Eq (Turing.TM0.Stmt.write a✝¹) (Turing.TM0.Stmt.write a✝)) (Eq a✝¹ a✝)","decl":"/-- A Turing machine \"statement\" is just a command to either move\n  left or right, or write a symbol on the tape. -/\ninductive Stmt\n  | move : Dir → Stmt\n  | write : Γ → Stmt\n\n"}
{"name":"Turing.TM0.Stmt.write.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\ninst✝ : SizeOf Γ\na✝ : Γ\n⊢ Eq (SizeOf.sizeOf (Turing.TM0.Stmt.write a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- A Turing machine \"statement\" is just a command to either move\n  left or right, or write a symbol on the tape. -/\ninductive Stmt\n  | move : Dir → Stmt\n  | write : Γ → Stmt\n\n"}
{"name":"Turing.TM0.Stmt.write.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\na✝¹ a✝ : Γ\nx✝ : Eq (Turing.TM0.Stmt.write a✝¹) (Turing.TM0.Stmt.write a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- A Turing machine \"statement\" is just a command to either move\n  left or right, or write a symbol on the tape. -/\ninductive Stmt\n  | move : Dir → Stmt\n  | write : Γ → Stmt\n\n"}
{"name":"Turing.TM0.Cfg.mk.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\ninst✝ : Inhabited Γ\nq✝ : Λ\nTape✝ : Turing.Tape Γ\nq : Λ\nTape : Turing.Tape Γ\n⊢ Eq (Eq { q := q✝, Tape := Tape✝ } { q := q, Tape := Tape }) (And (Eq q✝ q) (Eq Tape✝ Tape))","decl":"/-- The configuration state of a Turing machine during operation\n  consists of a label (machine state), and a tape.\n  The tape is represented in the form `(a, L, R)`, meaning the tape looks like `L.rev ++ [a] ++ R`\n  with the machine currently reading the `a`. The lists are\n  automatically extended with blanks as the machine moves around. -/\nstructure Cfg [Inhabited Γ] where\n  /-- The current machine state. -/\n  q : Λ\n  /-- The current state of the tape: current symbol, left and right parts. -/\n  Tape : Tape Γ\n\n"}
{"name":"Turing.TM0.Cfg.mk.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\ninst✝ : Inhabited Γ\nq✝ : Λ\nTape✝ : Turing.Tape Γ\nq : Λ\nTape : Turing.Tape Γ\nx✝ : Eq { q := q✝, Tape := Tape✝ } { q := q, Tape := Tape }\n⊢ And (Eq q✝ q) (Eq Tape✝ Tape)","decl":"/-- The configuration state of a Turing machine during operation\n  consists of a label (machine state), and a tape.\n  The tape is represented in the form `(a, L, R)`, meaning the tape looks like `L.rev ++ [a] ++ R`\n  with the machine currently reading the `a`. The lists are\n  automatically extended with blanks as the machine moves around. -/\nstructure Cfg [Inhabited Γ] where\n  /-- The current machine state. -/\n  q : Λ\n  /-- The current state of the tape: current symbol, left and right parts. -/\n  Tape : Tape Γ\n\n"}
{"name":"Turing.TM0.Cfg.mk.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\ninst✝² : Inhabited Γ\ninst✝¹ : SizeOf Γ\ninst✝ : SizeOf Λ\nq : Λ\nTape : Turing.Tape Γ\n⊢ Eq (SizeOf.sizeOf { q := q, Tape := Tape }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf q)) (SizeOf.sizeOf Tape))","decl":"/-- The configuration state of a Turing machine during operation\n  consists of a label (machine state), and a tape.\n  The tape is represented in the form `(a, L, R)`, meaning the tape looks like `L.rev ++ [a] ++ R`\n  with the machine currently reading the `a`. The lists are\n  automatically extended with blanks as the machine moves around. -/\nstructure Cfg [Inhabited Γ] where\n  /-- The current machine state. -/\n  q : Λ\n  /-- The current state of the tape: current symbol, left and right parts. -/\n  Tape : Tape Γ\n\n"}
{"name":"Turing.TM0.step_supports","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\ninst✝¹ : Inhabited Λ\ninst✝ : Inhabited Γ\nM : Turing.TM0.Machine Γ Λ\nS : Set Λ\nss : Turing.TM0.Supports M S\nc c' : Turing.TM0.Cfg Γ Λ\na✝¹ : Membership.mem (Turing.TM0.step M c) c'\na✝ : Membership.mem S c.q\n⊢ Membership.mem S c'.q","decl":"theorem step_supports (M : Machine₀) {S : Set Λ} (ss : Supports M S) :\n    ∀ {c c' : Cfg₀}, c' ∈ step M c → c.q ∈ S → c'.q ∈ S := by\n  intro ⟨q, T⟩ c' h₁ h₂\n  rcases Option.map_eq_some'.1 h₁ with ⟨⟨q', a⟩, h, rfl⟩\n  exact ss.2 h h₂\n\n"}
{"name":"Turing.TM0.univ_supports","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\ninst✝ : Inhabited Λ\nM : Turing.TM0.Machine Γ Λ\n⊢ Turing.TM0.Supports M Set.univ","decl":"theorem univ_supports (M : Machine₀) : Supports M Set.univ := by\n  constructor <;> intros <;> apply Set.mem_univ\n\n"}
{"name":"Turing.TM0.Machine.map_step","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\ninst✝³ : Inhabited Γ\nΓ' : Type u_2\ninst✝² : Inhabited Γ'\nΛ : Type u_3\ninst✝¹ : Inhabited Λ\nΛ' : Type u_4\ninst✝ : Inhabited Λ'\nM : Turing.TM0.Machine Γ Λ\nf₁ : Turing.PointedMap Γ Γ'\nf₂ : Turing.PointedMap Γ' Γ\ng₁ : Λ → Λ'\ng₂ : Λ' → Λ\nS : Set Λ\nf₂₁ : Function.RightInverse f₁.f f₂.f\ng₂₁ : ∀ (q : Λ), Membership.mem S q → Eq (g₂ (g₁ q)) q\nc : Turing.TM0.Cfg Γ Λ\na✝ : Membership.mem S c.q\n⊢ Eq (Option.map (Turing.TM0.Cfg.map f₁ g₁) (Turing.TM0.step M c)) (Turing.TM0.step (M.map f₁ f₂ g₁ g₂) (Turing.TM0.Cfg.map f₁ g₁ c))","decl":"theorem Machine.map_step {S : Set Λ} (f₂₁ : Function.RightInverse f₁ f₂)\n    (g₂₁ : ∀ q ∈ S, g₂ (g₁ q) = q) :\n    ∀ c : Cfg Γ Λ,\n      c.q ∈ S → (step M c).map (Cfg.map f₁ g₁) = step (M.map f₁ f₂ g₁ g₂) (Cfg.map f₁ g₁ c)\n  | ⟨q, T⟩, h => by\n    unfold step Machine.map Cfg.map\n    simp only [Turing.Tape.map_fst, g₂₁ q h, f₂₁ _]\n    rcases M q T.1 with (_ | ⟨q', d | a⟩); · rfl\n    · simp only [step, Cfg.map, Option.map_some', Tape.map_move f₁]\n      rfl\n    · simp only [step, Cfg.map, Option.map_some', Tape.map_write]\n      rfl\n\n"}
{"name":"Turing.TM0.map_init","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\ninst✝³ : Inhabited Γ\nΓ' : Type u_2\ninst✝² : Inhabited Γ'\nΛ : Type u_3\ninst✝¹ : Inhabited Λ\nΛ' : Type u_4\ninst✝ : Inhabited Λ'\nf₁ : Turing.PointedMap Γ Γ'\ng₁ : Turing.PointedMap Λ Λ'\nl : List Γ\n⊢ Eq (Turing.TM0.Cfg.map f₁ g₁.f (Turing.TM0.init l)) (Turing.TM0.init (List.map f₁.f l))","decl":"theorem map_init (g₁ : PointedMap Λ Λ') (l : List Γ) : (init l).map f₁ g₁ = init (l.map f₁) :=\n  congr (congr_arg Cfg.mk g₁.map_pt) (Tape.map_mk₁ _ _)\n\n"}
{"name":"Turing.TM0.Machine.map_respects","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\ninst✝³ : Inhabited Γ\nΓ' : Type u_2\ninst✝² : Inhabited Γ'\nΛ : Type u_3\ninst✝¹ : Inhabited Λ\nΛ' : Type u_4\ninst✝ : Inhabited Λ'\nM : Turing.TM0.Machine Γ Λ\nf₁ : Turing.PointedMap Γ Γ'\nf₂ : Turing.PointedMap Γ' Γ\ng₁ : Turing.PointedMap Λ Λ'\ng₂ : Λ' → Λ\nS : Set Λ\nss : Turing.TM0.Supports M S\nf₂₁ : Function.RightInverse f₁.f f₂.f\ng₂₁ : ∀ (q : Λ), Membership.mem S q → Eq (g₂ (g₁.f q)) q\n⊢ Turing.Respects (Turing.TM0.step M) (Turing.TM0.step (M.map f₁ f₂ g₁.f g₂)) fun a b => And (Membership.mem S a.q) (Eq (Turing.TM0.Cfg.map f₁ g₁.f a) b)","decl":"theorem Machine.map_respects (g₁ : PointedMap Λ Λ') (g₂ : Λ' → Λ) {S} (ss : Supports M S)\n    (f₂₁ : Function.RightInverse f₁ f₂) (g₂₁ : ∀ q ∈ S, g₂ (g₁ q) = q) :\n    Respects (step M) (step (M.map f₁ f₂ g₁ g₂)) fun a b ↦ a.q ∈ S ∧ Cfg.map f₁ g₁ a = b := by\n  intro c _ ⟨cs, rfl⟩\n  cases e : step M c\n  · rw [← M.map_step f₁ f₂ g₁ g₂ f₂₁ g₂₁ _ cs, e]\n    rfl\n  · refine ⟨_, ⟨step_supports M ss e cs, rfl⟩, TransGen.single ?_⟩\n    rw [← M.map_step f₁ f₂ g₁ g₂ f₂₁ g₂₁ _ cs, e]\n    rfl\n\n"}
{"name":"Turing.TM1.Stmt.write.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\ninst✝² : SizeOf Γ\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\na✝¹ : Γ → σ → Γ\na✝ : Turing.TM1.Stmt Γ Λ σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM1.Stmt.write a✝¹ a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.move.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝³ : Turing.Dir\na✝² : Turing.TM1.Stmt Γ Λ σ\na✝¹ : Turing.Dir\na✝ : Turing.TM1.Stmt Γ Λ σ\nx✝ : Eq (Turing.TM1.Stmt.move a✝³ a✝²) (Turing.TM1.Stmt.move a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.branch.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝⁵ : Γ → σ → Bool\na✝⁴ a✝³ : Turing.TM1.Stmt Γ Λ σ\na✝² : Γ → σ → Bool\na✝¹ a✝ : Turing.TM1.Stmt Γ Λ σ\n⊢ Eq (Eq (Turing.TM1.Stmt.branch a✝⁵ a✝⁴ a✝³) (Turing.TM1.Stmt.branch a✝² a✝¹ a✝)) (And (Eq a✝⁵ a✝²) (And (Eq a✝⁴ a✝¹) (Eq a✝³ a✝)))","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.load.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\ninst✝² : SizeOf Γ\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\na✝¹ : Γ → σ → σ\na✝ : Turing.TM1.Stmt Γ Λ σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM1.Stmt.load a✝¹ a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.write.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝³ : Γ → σ → Γ\na✝² : Turing.TM1.Stmt Γ Λ σ\na✝¹ : Γ → σ → Γ\na✝ : Turing.TM1.Stmt Γ Λ σ\nx✝ : Eq (Turing.TM1.Stmt.write a✝³ a✝²) (Turing.TM1.Stmt.write a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.move.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\ninst✝² : SizeOf Γ\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\na✝¹ : Turing.Dir\na✝ : Turing.TM1.Stmt Γ Λ σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM1.Stmt.move a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.move.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝³ : Turing.Dir\na✝² : Turing.TM1.Stmt Γ Λ σ\na✝¹ : Turing.Dir\na✝ : Turing.TM1.Stmt Γ Λ σ\n⊢ Eq (Eq (Turing.TM1.Stmt.move a✝³ a✝²) (Turing.TM1.Stmt.move a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.branch.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝⁵ : Γ → σ → Bool\na✝⁴ a✝³ : Turing.TM1.Stmt Γ Λ σ\na✝² : Γ → σ → Bool\na✝¹ a✝ : Turing.TM1.Stmt Γ Λ σ\nx✝ : Eq (Turing.TM1.Stmt.branch a✝⁵ a✝⁴ a✝³) (Turing.TM1.Stmt.branch a✝² a✝¹ a✝)\n⊢ And (Eq a✝⁵ a✝²) (And (Eq a✝⁴ a✝¹) (Eq a✝³ a✝))","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.write.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝³ : Γ → σ → Γ\na✝² : Turing.TM1.Stmt Γ Λ σ\na✝¹ : Γ → σ → Γ\na✝ : Turing.TM1.Stmt Γ Λ σ\n⊢ Eq (Eq (Turing.TM1.Stmt.write a✝³ a✝²) (Turing.TM1.Stmt.write a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.load.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝³ : Γ → σ → σ\na✝² : Turing.TM1.Stmt Γ Λ σ\na✝¹ : Γ → σ → σ\na✝ : Turing.TM1.Stmt Γ Λ σ\nx✝ : Eq (Turing.TM1.Stmt.load a✝³ a✝²) (Turing.TM1.Stmt.load a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.goto.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝¹ a✝ : Γ → σ → Λ\nx✝ : Eq (Turing.TM1.Stmt.goto a✝¹) (Turing.TM1.Stmt.goto a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.load.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝³ : Γ → σ → σ\na✝² : Turing.TM1.Stmt Γ Λ σ\na✝¹ : Γ → σ → σ\na✝ : Turing.TM1.Stmt Γ Λ σ\n⊢ Eq (Eq (Turing.TM1.Stmt.load a✝³ a✝²) (Turing.TM1.Stmt.load a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.branch.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\ninst✝² : SizeOf Γ\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\na✝² : Γ → σ → Bool\na✝¹ a✝ : Turing.TM1.Stmt Γ Λ σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM1.Stmt.branch a✝² a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.goto.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\ninst✝² : SizeOf Γ\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\na✝ : Γ → σ → Λ\n⊢ Eq (SizeOf.sizeOf (Turing.TM1.Stmt.goto a✝)) 1","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.halt.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\ninst✝² : SizeOf Γ\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\n⊢ Eq (SizeOf.sizeOf Turing.TM1.Stmt.halt) 1","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Stmt.goto.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝¹ a✝ : Γ → σ → Λ\n⊢ Eq (Eq (Turing.TM1.Stmt.goto a✝¹) (Turing.TM1.Stmt.goto a✝)) (Eq a✝¹ a✝)","decl":"/-- The TM1 model is a simplification and extension of TM0\n  (Post-Turing model) in the direction of Wang B-machines. The machine's\n  internal state is extended with a (finite) store `σ` of variables\n  that may be accessed and updated at any time.\n  A machine is given by a `Λ` indexed set of procedures or functions.\n  Each function has a body which is a `Stmt`, which can either be a\n  `move` or `write` command, a `branch` (if statement based on the\n  current tape value), a `load` (set the variable value),\n  a `goto` (call another function), or `halt`. Note that here\n  most statements do not have labels; `goto` commands can only\n  go to a new function. All commands have access to the variable value\n  and current tape value. -/\ninductive Stmt\n  | move : Dir → Stmt → Stmt\n  | write : (Γ → σ → Γ) → Stmt → Stmt\n  | load : (Γ → σ → σ) → Stmt → Stmt\n  | branch : (Γ → σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (Γ → σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM1.Cfg.mk.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\ninst✝³ : Inhabited Γ\ninst✝² : SizeOf Γ\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\nl : Option Λ\nvar : σ\nTape : Turing.Tape Γ\n⊢ Eq (SizeOf.sizeOf { l := l, var := var, Tape := Tape }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf l)) (SizeOf.sizeOf var)) (SizeOf.sizeOf Tape))","decl":"/-- The configuration of a TM1 machine is given by the currently\n  evaluating statement, the variable store value, and the tape. -/\nstructure Cfg [Inhabited Γ] where\n  /-- The statement (if any) which is currently evaluated -/\n  l : Option Λ\n  /-- The current value of the variable store -/\n  var : σ\n  /-- The current state of the tape -/\n  Tape : Tape Γ\n\n"}
{"name":"Turing.TM1.Cfg.mk.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\ninst✝ : Inhabited Γ\nl✝ : Option Λ\nvar✝ : σ\nTape✝ : Turing.Tape Γ\nl : Option Λ\nvar : σ\nTape : Turing.Tape Γ\nx✝ : Eq { l := l✝, var := var✝, Tape := Tape✝ } { l := l, var := var, Tape := Tape }\n⊢ And (Eq l✝ l) (And (Eq var✝ var) (Eq Tape✝ Tape))","decl":"/-- The configuration of a TM1 machine is given by the currently\n  evaluating statement, the variable store value, and the tape. -/\nstructure Cfg [Inhabited Γ] where\n  /-- The statement (if any) which is currently evaluated -/\n  l : Option Λ\n  /-- The current value of the variable store -/\n  var : σ\n  /-- The current state of the tape -/\n  Tape : Tape Γ\n\n"}
{"name":"Turing.TM1.Cfg.mk.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\ninst✝ : Inhabited Γ\nl✝ : Option Λ\nvar✝ : σ\nTape✝ : Turing.Tape Γ\nl : Option Λ\nvar : σ\nTape : Turing.Tape Γ\n⊢ Eq (Eq { l := l✝, var := var✝, Tape := Tape✝ } { l := l, var := var, Tape := Tape }) (And (Eq l✝ l) (And (Eq var✝ var) (Eq Tape✝ Tape)))","decl":"/-- The configuration of a TM1 machine is given by the currently\n  evaluating statement, the variable store value, and the tape. -/\nstructure Cfg [Inhabited Γ] where\n  /-- The statement (if any) which is currently evaluated -/\n  l : Option Λ\n  /-- The current value of the variable store -/\n  var : σ\n  /-- The current state of the tape -/\n  Tape : Tape Γ\n\n"}
{"name":"Turing.TM1.stmts₁_self","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\nq : Turing.TM1.Stmt Γ Λ σ\n⊢ Membership.mem (Turing.TM1.stmts₁ q) q","decl":"theorem stmts₁_self {q : Stmt₁} : q ∈ stmts₁ q := by\n  cases q <;> simp only [stmts₁, Finset.mem_insert_self, Finset.mem_singleton_self]\n\n"}
{"name":"Turing.TM1.stmts₁_trans","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\nq₁ q₂ : Turing.TM1.Stmt Γ Λ σ\na✝ : Membership.mem (Turing.TM1.stmts₁ q₂) q₁\n⊢ HasSubset.Subset (Turing.TM1.stmts₁ q₁) (Turing.TM1.stmts₁ q₂)","decl":"theorem stmts₁_trans {q₁ q₂ : Stmt₁} : q₁ ∈ stmts₁ q₂ → stmts₁ q₁ ⊆ stmts₁ q₂ := by\n  classical\n  intro h₁₂ q₀ h₀₁\n  induction q₂ with (\n    simp only [stmts₁] at h₁₂ ⊢\n    simp only [Finset.mem_insert, Finset.mem_union, Finset.mem_singleton] at h₁₂)\n  | branch p q₁ q₂ IH₁ IH₂ =>\n    rcases h₁₂ with (rfl | h₁₂ | h₁₂)\n    · unfold stmts₁ at h₀₁\n      exact h₀₁\n    · exact Finset.mem_insert_of_mem (Finset.mem_union_left _ <| IH₁ h₁₂)\n    · exact Finset.mem_insert_of_mem (Finset.mem_union_right _ <| IH₂ h₁₂)\n  | goto l => subst h₁₂; exact h₀₁\n  | halt => subst h₁₂; exact h₀₁\n  | _ _ q IH =>\n    rcases h₁₂ with rfl | h₁₂\n    · exact h₀₁\n    · exact Finset.mem_insert_of_mem (IH h₁₂)\n\n"}
{"name":"Turing.TM1.stmts₁_supportsStmt_mono","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\nS : Finset Λ\nq₁ q₂ : Turing.TM1.Stmt Γ Λ σ\nh : Membership.mem (Turing.TM1.stmts₁ q₂) q₁\nhs : Turing.TM1.SupportsStmt S q₂\n⊢ Turing.TM1.SupportsStmt S q₁","decl":"theorem stmts₁_supportsStmt_mono {S : Finset Λ} {q₁ q₂ : Stmt₁} (h : q₁ ∈ stmts₁ q₂)\n    (hs : SupportsStmt S q₂) : SupportsStmt S q₁ := by\n  induction q₂ with\n    simp only [stmts₁, SupportsStmt, Finset.mem_insert, Finset.mem_union, Finset.mem_singleton]\n      at h hs\n  | branch p q₁ q₂ IH₁ IH₂ => rcases h with (rfl | h | h); exacts [hs, IH₁ h hs.1, IH₂ h hs.2]\n  | goto l => subst h; exact hs\n  | halt => subst h; trivial\n  | _ _ q IH => rcases h with (rfl | h) <;> [exact hs; exact IH h hs]\n\n"}
{"name":"Turing.TM1.stmts_trans","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\nM : Λ → Turing.TM1.Stmt Γ Λ σ\nS : Finset Λ\nq₁ q₂ : Turing.TM1.Stmt Γ Λ σ\nh₁ : Membership.mem (Turing.TM1.stmts₁ q₂) q₁\na✝ : Membership.mem (Turing.TM1.stmts M S) (Option.some q₂)\n⊢ Membership.mem (Turing.TM1.stmts M S) (Option.some q₁)","decl":"theorem stmts_trans {M : Λ → Stmt₁} {S : Finset Λ} {q₁ q₂ : Stmt₁} (h₁ : q₁ ∈ stmts₁ q₂) :\n    some q₂ ∈ stmts M S → some q₁ ∈ stmts M S := by\n  simp only [stmts, Finset.mem_insertNone, Finset.mem_biUnion, Option.mem_def, Option.some.injEq,\n    forall_eq', exists_imp, and_imp]\n  exact fun l ls h₂ ↦ ⟨_, ls, stmts₁_trans h₂ h₁⟩\n\n"}
{"name":"Turing.TM1.stmts_supportsStmt","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\ninst✝ : Inhabited Λ\nM : Λ → Turing.TM1.Stmt Γ Λ σ\nS : Finset Λ\nq : Turing.TM1.Stmt Γ Λ σ\nss : Turing.TM1.Supports M S\na✝ : Membership.mem (Turing.TM1.stmts M S) (Option.some q)\n⊢ Turing.TM1.SupportsStmt S q","decl":"theorem stmts_supportsStmt {M : Λ → Stmt₁} {S : Finset Λ} {q : Stmt₁} (ss : Supports M S) :\n    some q ∈ stmts M S → SupportsStmt S q := by\n  simp only [stmts, Finset.mem_insertNone, Finset.mem_biUnion, Option.mem_def, Option.some.injEq,\n    forall_eq', exists_imp, and_imp]\n  exact fun l ls h ↦ stmts₁_supportsStmt_mono h (ss.2 _ ls)\n\n"}
{"name":"Turing.TM1.step_supports","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\ninst✝¹ : Inhabited Λ\ninst✝ : Inhabited Γ\nM : Λ → Turing.TM1.Stmt Γ Λ σ\nS : Finset Λ\nss : Turing.TM1.Supports M S\nc c' : Turing.TM1.Cfg Γ Λ σ\na✝¹ : Membership.mem (Turing.TM1.step M c) c'\na✝ : Membership.mem (Finset.insertNone S) c.l\n⊢ Membership.mem (Finset.insertNone S) c'.l","decl":"theorem step_supports (M : Λ → Stmt₁) {S : Finset Λ} (ss : Supports M S) :\n    ∀ {c c' : Cfg₁}, c' ∈ step M c → c.l ∈ Finset.insertNone S → c'.l ∈ Finset.insertNone S\n  | ⟨some l₁, v, T⟩, c', h₁, h₂ => by\n    replace h₂ := ss.2 _ (Finset.some_mem_insertNone.1 h₂)\n    simp only [step, Option.mem_def, Option.some.injEq] at h₁; subst c'\n    revert h₂; induction M l₁ generalizing v T with intro hs\n    | branch p q₁' q₂' IH₁ IH₂ =>\n      unfold stepAux; cases p T.1 v\n      · exact IH₂ _ _ hs.2\n      · exact IH₁ _ _ hs.1\n    | goto => exact Finset.some_mem_insertNone.2 (hs _ _)\n    | halt => apply Multiset.mem_cons_self\n    | _ _ q IH => exact IH _ _ hs\n\n"}
{"name":"Turing.TM1to0.tr_respects","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\ninst✝² : Inhabited Λ\nσ : Type u_3\ninst✝¹ : Inhabited σ\nM : Λ → Turing.TM1.Stmt Γ Λ σ\ninst✝ : Inhabited Γ\n⊢ Turing.Respects (Turing.TM1.step M) (Turing.TM0.step (Turing.TM1to0.tr M)) fun c₁ c₂ => Eq (Turing.TM1to0.trCfg M c₁) c₂","decl":"theorem tr_respects [Inhabited Γ] :\n    Respects (TM1.step M) (TM0.step (tr M)) fun (c₁ : Cfg₁) (c₂ : Cfg₁₀) ↦ trCfg M c₁ = c₂ :=\n  fun_respects.2 fun ⟨l₁, v, T⟩ ↦ by\n    cases' l₁ with l₁; · exact rfl\n    simp only [trCfg, TM1.step, FRespects, Option.map]\n    induction M l₁ generalizing v T with\n    | move _ _ IH => exact TransGen.head rfl (IH _ _)\n    | write _ _ IH => exact TransGen.head rfl (IH _ _)\n    | load _ _ IH => exact (reaches₁_eq (by rfl)).2 (IH _ _)\n    | branch p _ _ IH₁ IH₂ =>\n      unfold TM1.stepAux; cases e : p T.1 v\n      · exact (reaches₁_eq (by simp only [TM0.step, tr, trAux, e]; rfl)).2 (IH₂ _ _)\n      · exact (reaches₁_eq (by simp only [TM0.step, tr, trAux, e]; rfl)).2 (IH₁ _ _)\n    | _ =>\n      exact TransGen.single (congr_arg some (congr (congr_arg TM0.Cfg.mk rfl) (Tape.write_self T)))\n\n"}
{"name":"Turing.TM1to0.tr_eval","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\ninst✝² : Inhabited Λ\nσ : Type u_3\ninst✝¹ : Inhabited σ\nM : Λ → Turing.TM1.Stmt Γ Λ σ\ninst✝ : Inhabited Γ\nl : List Γ\n⊢ Eq (Turing.TM0.eval (Turing.TM1to0.tr M) l) (Turing.TM1.eval M l)","decl":"theorem tr_eval [Inhabited Γ] (l : List Γ) : TM0.eval (tr M) l = TM1.eval M l :=\n  (congr_arg _ (tr_eval' _ _ _ (tr_respects M) ⟨some _, _, _⟩)).trans\n    (by\n      rw [Part.map_eq_map, Part.map_map, TM1.eval]\n      congr with ⟨⟩)\n\n"}
{"name":"Turing.TM1to0.tr_supports","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\ninst✝² : Inhabited Λ\nσ : Type u_3\ninst✝¹ : Inhabited σ\nM : Λ → Turing.TM1.Stmt Γ Λ σ\ninst✝ : Fintype σ\nS : Finset Λ\nss : Turing.TM1.Supports M S\n⊢ Turing.TM0.Supports (Turing.TM1to0.tr M) ↑(Turing.TM1to0.trStmts M S)","decl":"theorem tr_supports {S : Finset Λ} (ss : TM1.Supports M S) :\n    TM0.Supports (tr M) ↑(trStmts M S) := by\n  classical\n  constructor\n  · apply Finset.mem_product.2\n    constructor\n    · simp only [default, TM1.stmts, Finset.mem_insertNone, Option.mem_def, Option.some_inj,\n        forall_eq', Finset.mem_biUnion]\n      exact ⟨_, ss.1, TM1.stmts₁_self⟩\n    · apply Finset.mem_univ\n  · intro q a q' s h₁ h₂\n    rcases q with ⟨_ | q, v⟩; · cases h₁\n    cases' q' with q' v'\n    simp only [trStmts, Finset.mem_coe] at h₂ ⊢\n    rw [Finset.mem_product] at h₂ ⊢\n    simp only [Finset.mem_univ, and_true] at h₂ ⊢\n    cases q'; · exact Multiset.mem_cons_self _ _\n    simp only [tr, Option.mem_def] at h₁\n    have := TM1.stmts_supportsStmt ss h₂\n    revert this; induction q generalizing v with intro hs\n    | move d q =>\n      cases h₁; refine TM1.stmts_trans ?_ h₂\n      unfold TM1.stmts₁\n      exact Finset.mem_insert_of_mem TM1.stmts₁_self\n    | write b q =>\n      cases h₁; refine TM1.stmts_trans ?_ h₂\n      unfold TM1.stmts₁\n      exact Finset.mem_insert_of_mem TM1.stmts₁_self\n    | load b q IH =>\n      refine IH _ (TM1.stmts_trans ?_ h₂) h₁ hs\n      unfold TM1.stmts₁\n      exact Finset.mem_insert_of_mem TM1.stmts₁_self\n    | branch p q₁ q₂ IH₁ IH₂ =>\n      cases h : p a v <;> rw [trAux, h] at h₁\n      · refine IH₂ _ (TM1.stmts_trans ?_ h₂) h₁ hs.2\n        unfold TM1.stmts₁\n        exact Finset.mem_insert_of_mem (Finset.mem_union_right _ TM1.stmts₁_self)\n      · refine IH₁ _ (TM1.stmts_trans ?_ h₂) h₁ hs.1\n        unfold TM1.stmts₁\n        exact Finset.mem_insert_of_mem (Finset.mem_union_left _ TM1.stmts₁_self)\n    | goto l =>\n      cases h₁\n      exact Finset.some_mem_insertNone.2 (Finset.mem_biUnion.2 ⟨_, hs _ _, TM1.stmts₁_self⟩)\n    | halt => cases h₁\n\n"}
{"name":"Turing.TM1to1.exists_enc_dec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\ninst✝¹ : Inhabited Γ\ninst✝ : Finite Γ\n⊢ Exists fun n => Exists fun enc => Exists fun dec => And (Eq (enc Inhabited.default) (List.Vector.replicate n Bool.false)) (∀ (a : Γ), Eq (dec (enc a)) a)","decl":"theorem exists_enc_dec [Inhabited Γ] [Finite Γ] :\n    ∃ (n : ℕ) (enc : Γ → List.Vector Bool n) (dec : List.Vector Bool n → Γ),\n      enc default = Vector.replicate n false ∧ ∀ a, dec (enc a) = a := by\n  rcases Finite.exists_equiv_fin Γ with ⟨n, ⟨e⟩⟩\n  letI : DecidableEq Γ := e.decidableEq\n  let G : Fin n ↪ Fin n → Bool :=\n    ⟨fun a b ↦ a = b, fun a b h ↦\n      Bool.of_decide_true <| (congr_fun h b).trans <| Bool.decide_true rfl⟩\n  let H := (e.toEmbedding.trans G).trans (Equiv.vectorEquivFin _ _).symm.toEmbedding\n  let enc := H.setValue default (Vector.replicate n false)\n  exact ⟨_, enc, Function.invFun enc, H.setValue_eq _ _, Function.leftInverse_invFun enc.2⟩\n\n"}
{"name":"Turing.TM1to1.Λ'.write.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\ninst✝² : SizeOf Γ\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\na✝¹ : Γ\na✝ : Turing.TM1.Stmt Γ Λ σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM1to1.Λ'.write a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The configuration state of the TM. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | write : Γ → Stmt₁ → Λ'\n\n"}
{"name":"Turing.TM1to1.Λ'.normal.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\ninst✝² : SizeOf Γ\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\na✝ : Λ\n⊢ Eq (SizeOf.sizeOf (Turing.TM1to1.Λ'.normal a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The configuration state of the TM. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | write : Γ → Stmt₁ → Λ'\n\n"}
{"name":"Turing.TM1to1.Λ'.write.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝³ : Γ\na✝² : Turing.TM1.Stmt Γ Λ σ\na✝¹ : Γ\na✝ : Turing.TM1.Stmt Γ Λ σ\nx✝ : Eq (Turing.TM1to1.Λ'.write a✝³ a✝²) (Turing.TM1to1.Λ'.write a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- The configuration state of the TM. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | write : Γ → Stmt₁ → Λ'\n\n"}
{"name":"Turing.TM1to1.Λ'.normal.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝¹ a✝ : Λ\n⊢ Eq (Eq (Turing.TM1to1.Λ'.normal a✝¹) (Turing.TM1to1.Λ'.normal a✝)) (Eq a✝¹ a✝)","decl":"/-- The configuration state of the TM. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | write : Γ → Stmt₁ → Λ'\n\n"}
{"name":"Turing.TM1to1.Λ'.write.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝³ : Γ\na✝² : Turing.TM1.Stmt Γ Λ σ\na✝¹ : Γ\na✝ : Turing.TM1.Stmt Γ Λ σ\n⊢ Eq (Eq (Turing.TM1to1.Λ'.write a✝³ a✝²) (Turing.TM1to1.Λ'.write a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The configuration state of the TM. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | write : Γ → Stmt₁ → Λ'\n\n"}
{"name":"Turing.TM1to1.Λ'.normal.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\na✝¹ a✝ : Λ\nx✝ : Eq (Turing.TM1to1.Λ'.normal a✝¹) (Turing.TM1to1.Λ'.normal a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The configuration state of the TM. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | write : Γ → Stmt₁ → Λ'\n\n"}
{"name":"Turing.TM1to1.stepAux_move","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\nn : Nat\nd : Turing.Dir\nq : Turing.TM1.Stmt Bool Turing.TM1to1.Λ' σ\nv : σ\nT : Turing.Tape Bool\n⊢ Eq (Turing.TM1.stepAux (Turing.TM1to1.move d q) v T) (Turing.TM1.stepAux q v (Nat.iterate (Turing.Tape.move d) n T))","decl":"theorem stepAux_move (d : Dir) (q : Stmt'₁) (v : σ) (T : Tape Bool) :\n    stepAux (moveₙ d q) v T = stepAux q v ((Tape.move d)^[n] T) := by\n  suffices ∀ i, stepAux ((Stmt.move d)^[i] q) v T = stepAux q v ((Tape.move d)^[i] T) from this n\n  intro i; induction' i with i IH generalizing T; · rfl\n  rw [iterate_succ', iterate_succ]\n  simp only [stepAux, Function.comp_apply]\n  rw [IH]\n\n"}
{"name":"Turing.TM1to1.supportsStmt_move","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\nn : Nat\nS : Finset Turing.TM1to1.Λ'\nd : Turing.Dir\nq : Turing.TM1.Stmt Bool Turing.TM1to1.Λ' σ\n⊢ Eq (Turing.TM1.SupportsStmt S (Turing.TM1to1.move d q)) (Turing.TM1.SupportsStmt S q)","decl":"theorem supportsStmt_move {S : Finset Λ'₁} {d : Dir} {q : Stmt'₁} :\n    SupportsStmt S (moveₙ d q) = SupportsStmt S q := by\n  suffices ∀ {i}, SupportsStmt S ((Stmt.move d)^[i] q) = _ from this\n  intro i; induction i generalizing q <;> simp only [*, iterate]; rfl\n\n"}
{"name":"Turing.TM1to1.supportsStmt_write","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\nS : Finset Turing.TM1to1.Λ'\nl : List Bool\nq : Turing.TM1.Stmt Bool Turing.TM1to1.Λ' σ\n⊢ Eq (Turing.TM1.SupportsStmt S (Turing.TM1to1.write l q)) (Turing.TM1.SupportsStmt S q)","decl":"theorem supportsStmt_write {S : Finset Λ'₁} {l : List Bool} {q : Stmt'₁} :\n    SupportsStmt S (write l q) = SupportsStmt S q := by\n  induction' l with _ l IH <;> simp only [write, SupportsStmt, *]\n\n"}
{"name":"Turing.TM1to1.supportsStmt_read","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\nn : Nat\ndec : List.Vector Bool n → Γ\nS : Finset Turing.TM1to1.Λ'\nf : Γ → Turing.TM1.Stmt Bool Turing.TM1to1.Λ' σ\na✝ : ∀ (a : Γ), Turing.TM1.SupportsStmt S (f a)\n⊢ Turing.TM1.SupportsStmt S (Turing.TM1to1.read dec f)","decl":"theorem supportsStmt_read {S : Finset Λ'₁} :\n    ∀ {f : Γ → Stmt'₁}, (∀ a, SupportsStmt S (f a)) → SupportsStmt S (read dec f) :=\n  suffices\n    ∀ (i) (f : List.Vector Bool i → Stmt'₁),\n      (∀ v, SupportsStmt S (f v)) → SupportsStmt S (readAux i f)\n    from fun hf ↦ this n _ (by intro; simp only [supportsStmt_move, hf])\n  fun i f hf ↦ by\n  induction' i with i IH; · exact hf _\n  constructor <;> apply IH <;> intro <;> apply hf\n\n"}
{"name":"Turing.TM1to1.trTape_mk'","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nn : Nat\nenc : Γ → List.Vector Bool n\ninst✝ : Inhabited Γ\nenc0 : Eq (enc Inhabited.default) (List.Vector.replicate n Bool.false)\nL R : Turing.ListBlank Γ\n⊢ Eq (Turing.TM1to1.trTape enc0 (Turing.Tape.mk' L R)) (Turing.TM1to1.trTape' enc0 L R)","decl":"theorem trTape_mk' (L R : ListBlank Γ) : trTape enc0 (Tape.mk' L R) = trTape' enc0 L R := by\n  simp only [trTape, Tape.mk'_left, Tape.mk'_right₀]\n\n"}
{"name":"Turing.TM1to1.trTape'_move_left","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nn : Nat\nenc : Γ → List.Vector Bool n\ninst✝ : Inhabited Γ\nenc0 : Eq (enc Inhabited.default) (List.Vector.replicate n Bool.false)\nL R : Turing.ListBlank Γ\n⊢ Eq (Nat.iterate (Turing.Tape.move Turing.Dir.left) n (Turing.TM1to1.trTape' enc0 L R)) (Turing.TM1to1.trTape' enc0 L.tail (Turing.ListBlank.cons L.head R))","decl":"theorem trTape'_move_left (L R : ListBlank Γ) :\n    (Tape.move Dir.left)^[n] (trTape' enc0 L R) = trTape' enc0 L.tail (R.cons L.head) := by\n  obtain ⟨a, L, rfl⟩ := L.exists_cons\n  simp only [trTape', ListBlank.cons_flatMap, ListBlank.head_cons, ListBlank.tail_cons]\n  suffices ∀ {L' R' l₁ l₂} (_ : Vector.toList (enc a) = List.reverseAux l₁ l₂),\n      (Tape.move Dir.left)^[l₁.length]\n      (Tape.mk' (ListBlank.append l₁ L') (ListBlank.append l₂ R')) =\n      Tape.mk' L' (ListBlank.append (Vector.toList (enc a)) R') by\n    simpa only [List.length_reverse, Vector.toList_length] using this (List.reverse_reverse _).symm\n  intro _ _ l₁ l₂ e\n  induction' l₁ with b l₁ IH generalizing l₂\n  · cases e\n    rfl\n  simp only [List.length, List.cons_append, iterate_succ_apply]\n  convert IH e\n  simp only [ListBlank.tail_cons, ListBlank.append, Tape.move_left_mk', ListBlank.head_cons]\n\n"}
{"name":"Turing.TM1to1.trTape'_move_right","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nn : Nat\nenc : Γ → List.Vector Bool n\ninst✝ : Inhabited Γ\nenc0 : Eq (enc Inhabited.default) (List.Vector.replicate n Bool.false)\nL R : Turing.ListBlank Γ\n⊢ Eq (Nat.iterate (Turing.Tape.move Turing.Dir.right) n (Turing.TM1to1.trTape' enc0 L R)) (Turing.TM1to1.trTape' enc0 (Turing.ListBlank.cons R.head L) R.tail)","decl":"theorem trTape'_move_right (L R : ListBlank Γ) :\n    (Tape.move Dir.right)^[n] (trTape' enc0 L R) = trTape' enc0 (L.cons R.head) R.tail := by\n  suffices ∀ i L, (Tape.move Dir.right)^[i] ((Tape.move Dir.left)^[i] L) = L by\n    refine (Eq.symm ?_).trans (this n _)\n    simp only [trTape'_move_left, ListBlank.cons_head_tail, ListBlank.head_cons,\n      ListBlank.tail_cons]\n  intro i _\n  induction' i with i IH\n  · rfl\n  rw [iterate_succ_apply, iterate_succ_apply', Tape.move_left_right, IH]\n\n"}
{"name":"Turing.TM1to1.stepAux_write","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\nn : Nat\nenc : Γ → List.Vector Bool n\ninst✝ : Inhabited Γ\nenc0 : Eq (enc Inhabited.default) (List.Vector.replicate n Bool.false)\nq : Turing.TM1.Stmt Bool Turing.TM1to1.Λ' σ\nv : σ\na b : Γ\nL R : Turing.ListBlank Γ\n⊢ Eq (Turing.TM1.stepAux (Turing.TM1to1.write (enc a).toList q) v (Turing.TM1to1.trTape' enc0 L (Turing.ListBlank.cons b R))) (Turing.TM1.stepAux q v (Turing.TM1to1.trTape' enc0 (Turing.ListBlank.cons a L) R))","decl":"theorem stepAux_write (q : Stmt'₁) (v : σ) (a b : Γ) (L R : ListBlank Γ) :\n    stepAux (write (enc a).toList q) v (trTape' enc0 L (ListBlank.cons b R)) =\n      stepAux q v (trTape' enc0 (ListBlank.cons a L) R) := by\n  simp only [trTape', ListBlank.cons_flatMap]\n  suffices ∀ {L' R'} (l₁ l₂ l₂' : List Bool) (_ : l₂'.length = l₂.length),\n      stepAux (write l₂ q) v (Tape.mk' (ListBlank.append l₁ L') (ListBlank.append l₂' R')) =\n      stepAux q v (Tape.mk' (L'.append (List.reverseAux l₂ l₁)) R') by\n    exact this [] _ _ ((enc b).2.trans (enc a).2.symm)\n  clear a b L R\n  intro L' R' l₁ l₂ l₂' e\n  induction' l₂ with a l₂ IH generalizing l₁ l₂'\n  · cases List.length_eq_zero.1 e\n    rfl\n  cases' l₂' with b l₂' <;>\n    simp only [List.length_nil, List.length_cons, Nat.succ_inj', reduceCtorEq] at e\n  rw [List.reverseAux, ← IH (a :: l₁) l₂' e]\n  simp [stepAux, ListBlank.append, write]\n\n"}
{"name":"Turing.TM1to1.stepAux_read","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\nn : Nat\nenc : Γ → List.Vector Bool n\ndec : List.Vector Bool n → Γ\ninst✝ : Inhabited Γ\nenc0 : Eq (enc Inhabited.default) (List.Vector.replicate n Bool.false)\nencdec : ∀ (a : Γ), Eq (dec (enc a)) a\nf : Γ → Turing.TM1.Stmt Bool Turing.TM1to1.Λ' σ\nv : σ\nL R : Turing.ListBlank Γ\n⊢ Eq (Turing.TM1.stepAux (Turing.TM1to1.read dec f) v (Turing.TM1to1.trTape' enc0 L R)) (Turing.TM1.stepAux (f R.head) v (Turing.TM1to1.trTape' enc0 L R))","decl":"theorem stepAux_read (f : Γ → Stmt'₁) (v : σ) (L R : ListBlank Γ) :\n    stepAux (read dec f) v (trTape' enc0 L R) = stepAux (f R.head) v (trTape' enc0 L R) := by\n  suffices ∀ f, stepAux (readAux n f) v (trTape' enc0 L R) =\n      stepAux (f (enc R.head)) v (trTape' enc0 (L.cons R.head) R.tail) by\n    rw [read, this, stepAux_move, encdec, trTape'_move_left enc0]\n    simp only [ListBlank.head_cons, ListBlank.cons_head_tail, ListBlank.tail_cons]\n  obtain ⟨a, R, rfl⟩ := R.exists_cons\n  simp only [ListBlank.head_cons, ListBlank.tail_cons, trTape', ListBlank.cons_flatMap,\n    ListBlank.append_assoc]\n  suffices ∀ i f L' R' l₁ l₂ h,\n      stepAux (readAux i f) v (Tape.mk' (ListBlank.append l₁ L') (ListBlank.append l₂ R')) =\n      stepAux (f ⟨l₂, h⟩) v (Tape.mk' (ListBlank.append (l₂.reverseAux l₁) L') R') by\n    intro f\n    -- Porting note: Here was `change`.\n    exact this n f (L.flatMap (fun x => (enc x).1.reverse) _)\n      (R.flatMap (fun x => (enc x).1) _) [] _ (enc a).2\n  clear f L a R\n  intro i f L' R' l₁ l₂ _\n  subst i\n  induction' l₂ with a l₂ IH generalizing l₁\n  · rfl\n  trans\n    stepAux (readAux l₂.length fun v ↦ f (a ::ᵥ v)) v\n      (Tape.mk' ((L'.append l₁).cons a) (R'.append l₂))\n  · dsimp [readAux, stepAux]\n    simp only [ListBlank.head_cons, Tape.move_right_mk', ListBlank.tail_cons]\n    cases a <;> rfl\n  rw [← ListBlank.append, IH]\n  rfl\n\n"}
{"name":"Turing.TM1to1.tr_respects","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\nn : Nat\nenc : Γ → List.Vector Bool n\ndec : List.Vector Bool n → Γ\nM : Λ → Turing.TM1.Stmt Γ Λ σ\ninst✝ : Inhabited Γ\nenc0 : Eq (enc Inhabited.default) (List.Vector.replicate n Bool.false)\nencdec : ∀ (a : Γ), Eq (dec (enc a)) a\n⊢ Turing.Respects (Turing.TM1.step M) (Turing.TM1.step (Turing.TM1to1.tr enc dec M)) fun c₁ c₂ => Eq (Turing.TM1to1.trCfg enc enc0 c₁) c₂","decl":"variable {enc0} in\ntheorem tr_respects :\n    Respects (step M) (step (tr enc dec M)) fun c₁ c₂ ↦ trCfg enc enc0 c₁ = c₂ :=\n  fun_respects.2 fun ⟨l₁, v, T⟩ ↦ by\n    obtain ⟨L, R, rfl⟩ := T.exists_mk'\n    cases' l₁ with l₁\n    · exact rfl\n    suffices ∀ q R, Reaches (step (tr enc dec M)) (stepAux (trNormal dec q) v (trTape' enc0 L R))\n        (trCfg enc enc0 (stepAux q v (Tape.mk' L R))) by\n      refine TransGen.head' rfl ?_\n      rw [trTape_mk']\n      exact this _ R\n    clear R l₁\n    intro q R\n    induction q generalizing v L R with\n    | move d q IH =>\n      cases d <;>\n          simp only [trNormal, iterate, stepAux_move, stepAux, ListBlank.head_cons,\n            Tape.move_left_mk', ListBlank.cons_head_tail, ListBlank.tail_cons,\n            trTape'_move_left enc0, trTape'_move_right enc0] <;>\n        apply IH\n    | write f q IH =>\n      simp only [trNormal, stepAux_read dec enc0 encdec, stepAux]\n      refine ReflTransGen.head rfl ?_\n      obtain ⟨a, R, rfl⟩ := R.exists_cons\n      rw [tr, Tape.mk'_head, stepAux_write, ListBlank.head_cons, stepAux_move,\n        trTape'_move_left enc0, ListBlank.head_cons, ListBlank.tail_cons, Tape.write_mk']\n      apply IH\n    | load a q IH =>\n      simp only [trNormal, stepAux_read dec enc0 encdec]\n      apply IH\n    | branch p q₁ q₂ IH₁ IH₂ =>\n      simp only [trNormal, stepAux_read dec enc0 encdec, stepAux, Tape.mk'_head]\n      cases p R.head v <;> [apply IH₂; apply IH₁]\n    | goto l =>\n      simp only [trNormal, stepAux_read dec enc0 encdec, stepAux, trCfg, trTape_mk']\n      apply ReflTransGen.refl\n    | halt =>\n      simp only [trNormal, stepAux, trCfg, stepAux_move, trTape'_move_left enc0,\n        trTape'_move_right enc0, trTape_mk']\n      apply ReflTransGen.refl\n\n"}
{"name":"Turing.TM1to1.tr_supports","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\nσ : Type u_3\nn : Nat\nenc : Γ → List.Vector Bool n\ndec : List.Vector Bool n → Γ\nM : Λ → Turing.TM1.Stmt Γ Λ σ\ninst✝¹ : Fintype Γ\ninst✝ : Inhabited Λ\nS : Finset Λ\nss : Turing.TM1.Supports M S\n⊢ Turing.TM1.Supports (Turing.TM1to1.tr enc dec M) (Turing.TM1to1.trSupp M S)","decl":"open scoped Classical in\ntheorem tr_supports [Inhabited Λ] {S : Finset Λ} (ss : Supports M S) :\n    Supports (tr enc dec M) (trSupp M S) :=\n  ⟨Finset.mem_biUnion.2 ⟨_, ss.1, Finset.mem_insert_self _ _⟩, fun q h ↦ by\n    suffices ∀ q, SupportsStmt S q → (∀ q' ∈ writes q, q' ∈ trSupp M S) →\n        SupportsStmt (trSupp M S) (trNormal dec q) ∧\n        ∀ q' ∈ writes q, SupportsStmt (trSupp M S) (tr enc dec M q') by\n      rcases Finset.mem_biUnion.1 h with ⟨l, hl, h⟩\n      have :=\n        this _ (ss.2 _ hl) fun q' hq ↦ Finset.mem_biUnion.2 ⟨_, hl, Finset.mem_insert_of_mem hq⟩\n      rcases Finset.mem_insert.1 h with (rfl | h)\n      exacts [this.1, this.2 _ h]\n    intro q hs hw\n    induction q with\n    | move d q IH =>\n      unfold writes at hw ⊢\n      replace IH := IH hs hw; refine ⟨?_, IH.2⟩\n      cases d <;> simp only [trNormal, iterate, supportsStmt_move, IH]\n    | write f q IH =>\n      unfold writes at hw ⊢\n      simp only [Finset.mem_image, Finset.mem_union, Finset.mem_univ, exists_prop, true_and]\n        at hw ⊢\n      replace IH := IH hs fun q hq ↦ hw q (Or.inr hq)\n      refine ⟨supportsStmt_read _ fun a _ s ↦ hw _ (Or.inl ⟨_, rfl⟩), fun q' hq ↦ ?_⟩\n      rcases hq with (⟨a, q₂, rfl⟩ | hq)\n      · simp only [tr, supportsStmt_write, supportsStmt_move, IH.1]\n      · exact IH.2 _ hq\n    | load a q IH =>\n      unfold writes at hw ⊢\n      replace IH := IH hs hw\n      exact ⟨supportsStmt_read _ fun _ ↦ IH.1, IH.2⟩\n    | branch p q₁ q₂ IH₁ IH₂ =>\n      unfold writes at hw ⊢\n      simp only [Finset.mem_union] at hw ⊢\n      replace IH₁ := IH₁ hs.1 fun q hq ↦ hw q (Or.inl hq)\n      replace IH₂ := IH₂ hs.2 fun q hq ↦ hw q (Or.inr hq)\n      exact ⟨supportsStmt_read _ fun _ ↦ ⟨IH₁.1, IH₂.1⟩, fun q ↦ Or.rec (IH₁.2 _) (IH₂.2 _)⟩\n    | goto l =>\n      simp only [writes, Finset.not_mem_empty]; refine ⟨?_, fun _ ↦ False.elim⟩\n      refine supportsStmt_read _ fun a _ s ↦ ?_\n      exact Finset.mem_biUnion.2 ⟨_, hs _ _, Finset.mem_insert_self _ _⟩\n    | halt =>\n      simp only [writes, Finset.not_mem_empty]; refine ⟨?_, fun _ ↦ False.elim⟩\n      simp only [SupportsStmt, supportsStmt_move, trNormal]⟩\n\n"}
{"name":"Turing.TM0to1.Λ'.normal.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\ninst✝¹ : SizeOf Γ\ninst✝ : SizeOf Λ\na✝ : Λ\n⊢ Eq (SizeOf.sizeOf (Turing.TM0to1.Λ'.normal a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The machine states for a TM1 emulating a TM0 machine. States of the TM0 machine are embedded\nas `normal q` states, but the actual operation is split into two parts, a jump to `act s q`\nfollowed by the action and a jump to the next `normal` state. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | act : TM0.Stmt Γ → Λ → Λ'\n\n"}
{"name":"Turing.TM0to1.Λ'.act.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\na✝³ : Turing.TM0.Stmt Γ\na✝² : Λ\na✝¹ : Turing.TM0.Stmt Γ\na✝ : Λ\nx✝ : Eq (Turing.TM0to1.Λ'.act a✝³ a✝²) (Turing.TM0to1.Λ'.act a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- The machine states for a TM1 emulating a TM0 machine. States of the TM0 machine are embedded\nas `normal q` states, but the actual operation is split into two parts, a jump to `act s q`\nfollowed by the action and a jump to the next `normal` state. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | act : TM0.Stmt Γ → Λ → Λ'\n\n"}
{"name":"Turing.TM0to1.Λ'.act.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\ninst✝¹ : SizeOf Γ\ninst✝ : SizeOf Λ\na✝¹ : Turing.TM0.Stmt Γ\na✝ : Λ\n⊢ Eq (SizeOf.sizeOf (Turing.TM0to1.Λ'.act a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The machine states for a TM1 emulating a TM0 machine. States of the TM0 machine are embedded\nas `normal q` states, but the actual operation is split into two parts, a jump to `act s q`\nfollowed by the action and a jump to the next `normal` state. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | act : TM0.Stmt Γ → Λ → Λ'\n\n"}
{"name":"Turing.TM0to1.Λ'.act.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\na✝³ : Turing.TM0.Stmt Γ\na✝² : Λ\na✝¹ : Turing.TM0.Stmt Γ\na✝ : Λ\n⊢ Eq (Eq (Turing.TM0to1.Λ'.act a✝³ a✝²) (Turing.TM0to1.Λ'.act a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The machine states for a TM1 emulating a TM0 machine. States of the TM0 machine are embedded\nas `normal q` states, but the actual operation is split into two parts, a jump to `act s q`\nfollowed by the action and a jump to the next `normal` state. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | act : TM0.Stmt Γ → Λ → Λ'\n\n"}
{"name":"Turing.TM0to1.Λ'.normal.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\na✝¹ a✝ : Λ\nx✝ : Eq (Turing.TM0to1.Λ'.normal a✝¹) (Turing.TM0to1.Λ'.normal a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The machine states for a TM1 emulating a TM0 machine. States of the TM0 machine are embedded\nas `normal q` states, but the actual operation is split into two parts, a jump to `act s q`\nfollowed by the action and a jump to the next `normal` state. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | act : TM0.Stmt Γ → Λ → Λ'\n\n"}
{"name":"Turing.TM0to1.Λ'.normal.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\nΛ : Type u_2\na✝¹ a✝ : Λ\n⊢ Eq (Eq (Turing.TM0to1.Λ'.normal a✝¹) (Turing.TM0to1.Λ'.normal a✝)) (Eq a✝¹ a✝)","decl":"/-- The machine states for a TM1 emulating a TM0 machine. States of the TM0 machine are embedded\nas `normal q` states, but the actual operation is split into two parts, a jump to `act s q`\nfollowed by the action and a jump to the next `normal` state. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | act : TM0.Stmt Γ → Λ → Λ'\n\n"}
{"name":"Turing.TM0to1.tr_respects","module":"Mathlib.Computability.TuringMachine","initialProofState":"Γ : Type u_1\ninst✝¹ : Inhabited Γ\nΛ : Type u_2\ninst✝ : Inhabited Λ\nM : Turing.TM0.Machine Γ Λ\n⊢ Turing.Respects (Turing.TM0.step M) (Turing.TM1.step (Turing.TM0to1.tr M)) fun a b => Eq (Turing.TM0to1.trCfg M a) b","decl":"theorem tr_respects : Respects (TM0.step M) (TM1.step (tr M)) fun a b ↦ trCfg M a = b :=\n  fun_respects.2 fun ⟨q, T⟩ ↦ by\n    cases' e : M q T.1 with val\n    · simp only [TM0.step, trCfg, e]; exact Eq.refl none\n    cases' val with q' s\n    simp only [FRespects, TM0.step, trCfg, e, Option.isSome, cond, Option.map_some']\n    revert e  -- Porting note: Added this so that `e` doesn't get into the `match`.\n    have : TM1.step (tr M) ⟨some (Λ'.act s q'), (), T⟩ = some ⟨some (Λ'.normal q'), (), match s with\n        | TM0.Stmt.move d => T.move d\n        | TM0.Stmt.write a => T.write a⟩ := by\n      cases' s with d a <;> rfl\n    intro e\n    refine TransGen.head ?_ (TransGen.head' this ?_)\n    · simp only [TM1.step, TM1.stepAux, tr]\n      rw [e]\n      rfl\n    cases e' : M q' _\n    · apply ReflTransGen.single\n      simp only [TM1.step, TM1.stepAux, tr]\n      rw [e']\n      rfl\n    · rfl\n\n"}
{"name":"Turing.TM2.Stmt.goto.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝³ : SizeOf K\ninst✝² : (a : K) → SizeOf (Γ a)\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\na✝ : σ → Λ\n⊢ Eq (SizeOf.sizeOf (Turing.TM2.Stmt.goto a✝)) 1","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.halt.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝³ : SizeOf K\ninst✝² : (a : K) → SizeOf (Γ a)\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\n⊢ Eq (SizeOf.sizeOf Turing.TM2.Stmt.halt) 1","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.goto.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\na✝¹ a✝ : σ → Λ\nx✝ : Eq (Turing.TM2.Stmt.goto a✝¹) (Turing.TM2.Stmt.goto a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.load.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\na✝³ : σ → σ\na✝² : Turing.TM2.Stmt Γ Λ σ\na✝¹ : σ → σ\na✝ : Turing.TM2.Stmt Γ Λ σ\nx✝ : Eq (Turing.TM2.Stmt.load a✝³ a✝²) (Turing.TM2.Stmt.load a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.goto.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\na✝¹ a✝ : σ → Λ\n⊢ Eq (Eq (Turing.TM2.Stmt.goto a✝¹) (Turing.TM2.Stmt.goto a✝)) (Eq a✝¹ a✝)","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.branch.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\na✝⁵ : σ → Bool\na✝⁴ a✝³ : Turing.TM2.Stmt Γ Λ σ\na✝² : σ → Bool\na✝¹ a✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (Eq (Turing.TM2.Stmt.branch a✝⁵ a✝⁴ a✝³) (Turing.TM2.Stmt.branch a✝² a✝¹ a✝)) (And (Eq a✝⁵ a✝²) (And (Eq a✝⁴ a✝¹) (Eq a✝³ a✝)))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.peek.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝³ : SizeOf K\ninst✝² : (a : K) → SizeOf (Γ a)\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\nk : K\na✝¹ : σ → Option (Γ k) → σ\na✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM2.Stmt.peek k a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf k)) (SizeOf.sizeOf a✝))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.pop.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nk✝ : K\na✝³ : σ → Option (Γ k✝) → σ\na✝² : Turing.TM2.Stmt Γ Λ σ\nk : K\na✝¹ : σ → Option (Γ k) → σ\na✝ : Turing.TM2.Stmt Γ Λ σ\nx✝ : Eq (Turing.TM2.Stmt.pop k✝ a✝³ a✝²) (Turing.TM2.Stmt.pop k a✝¹ a✝)\n⊢ And (Eq k✝ k) (And (HEq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.load.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\na✝³ : σ → σ\na✝² : Turing.TM2.Stmt Γ Λ σ\na✝¹ : σ → σ\na✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (Eq (Turing.TM2.Stmt.load a✝³ a✝²) (Turing.TM2.Stmt.load a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.peek.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nk✝ : K\na✝³ : σ → Option (Γ k✝) → σ\na✝² : Turing.TM2.Stmt Γ Λ σ\nk : K\na✝¹ : σ → Option (Γ k) → σ\na✝ : Turing.TM2.Stmt Γ Λ σ\nx✝ : Eq (Turing.TM2.Stmt.peek k✝ a✝³ a✝²) (Turing.TM2.Stmt.peek k a✝¹ a✝)\n⊢ And (Eq k✝ k) (And (HEq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.push.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nk✝ : K\na✝³ : σ → Γ k✝\na✝² : Turing.TM2.Stmt Γ Λ σ\nk : K\na✝¹ : σ → Γ k\na✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (Eq (Turing.TM2.Stmt.push k✝ a✝³ a✝²) (Turing.TM2.Stmt.push k a✝¹ a✝)) (And (Eq k✝ k) (And (HEq a✝³ a✝¹) (Eq a✝² a✝)))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.pop.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝³ : SizeOf K\ninst✝² : (a : K) → SizeOf (Γ a)\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\nk : K\na✝¹ : σ → Option (Γ k) → σ\na✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM2.Stmt.pop k a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf k)) (SizeOf.sizeOf a✝))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.branch.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\na✝⁵ : σ → Bool\na✝⁴ a✝³ : Turing.TM2.Stmt Γ Λ σ\na✝² : σ → Bool\na✝¹ a✝ : Turing.TM2.Stmt Γ Λ σ\nx✝ : Eq (Turing.TM2.Stmt.branch a✝⁵ a✝⁴ a✝³) (Turing.TM2.Stmt.branch a✝² a✝¹ a✝)\n⊢ And (Eq a✝⁵ a✝²) (And (Eq a✝⁴ a✝¹) (Eq a✝³ a✝))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.push.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝³ : SizeOf K\ninst✝² : (a : K) → SizeOf (Γ a)\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\nk : K\na✝¹ : σ → Γ k\na✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM2.Stmt.push k a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf k)) (SizeOf.sizeOf a✝))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.pop.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nk✝ : K\na✝³ : σ → Option (Γ k✝) → σ\na✝² : Turing.TM2.Stmt Γ Λ σ\nk : K\na✝¹ : σ → Option (Γ k) → σ\na✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (Eq (Turing.TM2.Stmt.pop k✝ a✝³ a✝²) (Turing.TM2.Stmt.pop k a✝¹ a✝)) (And (Eq k✝ k) (And (HEq a✝³ a✝¹) (Eq a✝² a✝)))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.load.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝³ : SizeOf K\ninst✝² : (a : K) → SizeOf (Γ a)\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\na✝¹ : σ → σ\na✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM2.Stmt.load a✝¹ a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.push.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nk✝ : K\na✝³ : σ → Γ k✝\na✝² : Turing.TM2.Stmt Γ Λ σ\nk : K\na✝¹ : σ → Γ k\na✝ : Turing.TM2.Stmt Γ Λ σ\nx✝ : Eq (Turing.TM2.Stmt.push k✝ a✝³ a✝²) (Turing.TM2.Stmt.push k a✝¹ a✝)\n⊢ And (Eq k✝ k) (And (HEq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.peek.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nk✝ : K\na✝³ : σ → Option (Γ k✝) → σ\na✝² : Turing.TM2.Stmt Γ Λ σ\nk : K\na✝¹ : σ → Option (Γ k) → σ\na✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (Eq (Turing.TM2.Stmt.peek k✝ a✝³ a✝²) (Turing.TM2.Stmt.peek k a✝¹ a✝)) (And (Eq k✝ k) (And (HEq a✝³ a✝¹) (Eq a✝² a✝)))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Stmt.branch.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝³ : SizeOf K\ninst✝² : (a : K) → SizeOf (Γ a)\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\na✝² : σ → Bool\na✝¹ a✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM2.Stmt.branch a✝² a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The TM2 model removes the tape entirely from the TM1 model,\n  replacing it with an arbitrary (finite) collection of stacks.\n  The operation `push` puts an element on one of the stacks,\n  and `pop` removes an element from a stack (and modifying the\n  internal state based on the result). `peek` modifies the\n  internal state but does not remove an element. -/\ninductive Stmt\n  | push : ∀ k, (σ → Γ k) → Stmt → Stmt\n  | peek : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | pop : ∀ k, (σ → Option (Γ k) → σ) → Stmt → Stmt\n  | load : (σ → σ) → Stmt → Stmt\n  | branch : (σ → Bool) → Stmt → Stmt → Stmt\n  | goto : (σ → Λ) → Stmt\n  | halt : Stmt\n\n"}
{"name":"Turing.TM2.Cfg.mk.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nl✝ : Option Λ\nvar✝ : σ\nstk✝ : (k : K) → List (Γ k)\nl : Option Λ\nvar : σ\nstk : (k : K) → List (Γ k)\nx✝ : Eq { l := l✝, var := var✝, stk := stk✝ } { l := l, var := var, stk := stk }\n⊢ And (Eq l✝ l) (And (Eq var✝ var) (Eq stk✝ stk))","decl":"/-- A configuration in the TM2 model is a label (or `none` for the halt state), the state of\nlocal variables, and the stacks. (Note that the stacks are not `ListBlank`s, they have a definite\nsize.) -/\nstructure Cfg where\n  /-- The current label to run (or `none` for the halting state) -/\n  l : Option Λ\n  /-- The internal state -/\n  var : σ\n  /-- The (finite) collection of internal stacks -/\n  stk : ∀ k, List (Γ k)\n\n"}
{"name":"Turing.TM2.Cfg.mk.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nl✝ : Option Λ\nvar✝ : σ\nstk✝ : (k : K) → List (Γ k)\nl : Option Λ\nvar : σ\nstk : (k : K) → List (Γ k)\n⊢ Eq (Eq { l := l✝, var := var✝, stk := stk✝ } { l := l, var := var, stk := stk }) (And (Eq l✝ l) (And (Eq var✝ var) (Eq stk✝ stk)))","decl":"/-- A configuration in the TM2 model is a label (or `none` for the halt state), the state of\nlocal variables, and the stacks. (Note that the stacks are not `ListBlank`s, they have a definite\nsize.) -/\nstructure Cfg where\n  /-- The current label to run (or `none` for the halting state) -/\n  l : Option Λ\n  /-- The internal state -/\n  var : σ\n  /-- The (finite) collection of internal stacks -/\n  stk : ∀ k, List (Γ k)\n\n"}
{"name":"Turing.TM2.Cfg.mk.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝³ : SizeOf K\ninst✝² : (a : K) → SizeOf (Γ a)\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\nl : Option Λ\nvar : σ\nstk : (k : K) → List (Γ k)\n⊢ Eq (SizeOf.sizeOf { l := l, var := var, stk := stk }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf l)) (SizeOf.sizeOf var))","decl":"/-- A configuration in the TM2 model is a label (or `none` for the halt state), the state of\nlocal variables, and the stacks. (Note that the stacks are not `ListBlank`s, they have a definite\nsize.) -/\nstructure Cfg where\n  /-- The current label to run (or `none` for the halting state) -/\n  l : Option Λ\n  /-- The internal state -/\n  var : σ\n  /-- The (finite) collection of internal stacks -/\n  stk : ∀ k, List (Γ k)\n\n"}
{"name":"Turing.TM2.stmts₁_self","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nq : Turing.TM2.Stmt Γ Λ σ\n⊢ Membership.mem (Turing.TM2.stmts₁ q) q","decl":"theorem stmts₁_self {q : Stmt₂} : q ∈ stmts₁ q := by\n  cases q <;> simp only [Finset.mem_insert_self, Finset.mem_singleton_self, stmts₁]\n\n"}
{"name":"Turing.TM2.stmts₁_trans","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nq₁ q₂ : Turing.TM2.Stmt Γ Λ σ\na✝ : Membership.mem (Turing.TM2.stmts₁ q₂) q₁\n⊢ HasSubset.Subset (Turing.TM2.stmts₁ q₁) (Turing.TM2.stmts₁ q₂)","decl":"theorem stmts₁_trans {q₁ q₂ : Stmt₂} : q₁ ∈ stmts₁ q₂ → stmts₁ q₁ ⊆ stmts₁ q₂ := by\n  classical\n  intro h₁₂ q₀ h₀₁\n  induction q₂ with (\n    simp only [stmts₁] at h₁₂ ⊢\n    simp only [Finset.mem_insert, Finset.mem_singleton, Finset.mem_union] at h₁₂)\n  | branch f q₁ q₂ IH₁ IH₂ =>\n    rcases h₁₂ with (rfl | h₁₂ | h₁₂)\n    · unfold stmts₁ at h₀₁\n      exact h₀₁\n    · exact Finset.mem_insert_of_mem (Finset.mem_union_left _ (IH₁ h₁₂))\n    · exact Finset.mem_insert_of_mem (Finset.mem_union_right _ (IH₂ h₁₂))\n  | goto l => subst h₁₂; exact h₀₁\n  | halt => subst h₁₂; exact h₀₁\n  | load  _ q IH | _ _ _ q IH =>\n    rcases h₁₂ with (rfl | h₁₂)\n    · unfold stmts₁ at h₀₁\n      exact h₀₁\n    · exact Finset.mem_insert_of_mem (IH h₁₂)\n\n"}
{"name":"Turing.TM2.stmts₁_supportsStmt_mono","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nS : Finset Λ\nq₁ q₂ : Turing.TM2.Stmt Γ Λ σ\nh : Membership.mem (Turing.TM2.stmts₁ q₂) q₁\nhs : Turing.TM2.SupportsStmt S q₂\n⊢ Turing.TM2.SupportsStmt S q₁","decl":"theorem stmts₁_supportsStmt_mono {S : Finset Λ} {q₁ q₂ : Stmt₂} (h : q₁ ∈ stmts₁ q₂)\n    (hs : SupportsStmt S q₂) : SupportsStmt S q₁ := by\n  induction q₂ with\n    simp only [stmts₁, SupportsStmt, Finset.mem_insert, Finset.mem_union, Finset.mem_singleton]\n      at h hs\n  | branch f q₁ q₂ IH₁ IH₂ => rcases h with (rfl | h | h); exacts [hs, IH₁ h hs.1, IH₂ h hs.2]\n  | goto l => subst h; exact hs\n  | halt => subst h; trivial\n  | load _ _ IH | _ _ _ _ IH => rcases h with (rfl | h) <;> [exact hs; exact IH h hs]\n\n"}
{"name":"Turing.TM2.stmts_trans","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nM : Λ → Turing.TM2.Stmt Γ Λ σ\nS : Finset Λ\nq₁ q₂ : Turing.TM2.Stmt Γ Λ σ\nh₁ : Membership.mem (Turing.TM2.stmts₁ q₂) q₁\na✝ : Membership.mem (Turing.TM2.stmts M S) (Option.some q₂)\n⊢ Membership.mem (Turing.TM2.stmts M S) (Option.some q₁)","decl":"theorem stmts_trans {M : Λ → Stmt₂} {S : Finset Λ} {q₁ q₂ : Stmt₂} (h₁ : q₁ ∈ stmts₁ q₂) :\n    some q₂ ∈ stmts M S → some q₁ ∈ stmts M S := by\n  simp only [stmts, Finset.mem_insertNone, Finset.mem_biUnion, Option.mem_def, Option.some.injEq,\n    forall_eq', exists_imp, and_imp]\n  exact fun l ls h₂ ↦ ⟨_, ls, stmts₁_trans h₂ h₁⟩\n\n"}
{"name":"Turing.TM2.stmts_supportsStmt","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝ : Inhabited Λ\nM : Λ → Turing.TM2.Stmt Γ Λ σ\nS : Finset Λ\nq : Turing.TM2.Stmt Γ Λ σ\nss : Turing.TM2.Supports M S\na✝ : Membership.mem (Turing.TM2.stmts M S) (Option.some q)\n⊢ Turing.TM2.SupportsStmt S q","decl":"theorem stmts_supportsStmt {M : Λ → Stmt₂} {S : Finset Λ} {q : Stmt₂} (ss : Supports M S) :\n    some q ∈ stmts M S → SupportsStmt S q := by\n  simp only [stmts, Finset.mem_insertNone, Finset.mem_biUnion, Option.mem_def, Option.some.injEq,\n    forall_eq', exists_imp, and_imp]\n  exact fun l ls h ↦ stmts₁_supportsStmt_mono h (ss.2 _ ls)\n\n"}
{"name":"Turing.TM2.step_supports","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝¹ : Inhabited Λ\ninst✝ : DecidableEq K\nM : Λ → Turing.TM2.Stmt Γ Λ σ\nS : Finset Λ\nss : Turing.TM2.Supports M S\nc c' : Turing.TM2.Cfg Γ Λ σ\na✝¹ : Membership.mem (Turing.TM2.step M c) c'\na✝ : Membership.mem (Finset.insertNone S) c.l\n⊢ Membership.mem (Finset.insertNone S) c'.l","decl":"theorem step_supports (M : Λ → Stmt₂) {S : Finset Λ} (ss : Supports M S) :\n    ∀ {c c' : Cfg₂}, c' ∈ step M c → c.l ∈ Finset.insertNone S → c'.l ∈ Finset.insertNone S\n  | ⟨some l₁, v, T⟩, c', h₁, h₂ => by\n    replace h₂ := ss.2 _ (Finset.some_mem_insertNone.1 h₂)\n    simp only [step, Option.mem_def, Option.some.injEq] at h₁; subst c'\n    revert h₂; induction M l₁ generalizing v T with intro hs\n    | branch p q₁' q₂' IH₁ IH₂ =>\n      unfold stepAux; cases p v\n      · exact IH₂ _ _ hs.2\n      · exact IH₁ _ _ hs.1\n    | goto => exact Finset.some_mem_insertNone.2 (hs _)\n    | halt => apply Multiset.mem_cons_self\n    | load _ _ IH | _ _ _ _ IH => exact IH _ _ hs\n\n"}
{"name":"Turing.TM2to1.stk_nth_val","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nL : Turing.ListBlank ((k : K) → Option (Γ k))\nk : K\nS : List (Γ k)\nn : Nat\nhL : Eq (Turing.ListBlank.map (Turing.proj k) L) (Turing.ListBlank.mk (List.map Option.some S).reverse)\n⊢ Eq (L.nth n k) (GetElem?.getElem? S.reverse n)","decl":"theorem stk_nth_val {K : Type*} {Γ : K → Type*} {L : ListBlank (∀ k, Option (Γ k))} {k S} (n)\n    (hL : ListBlank.map (proj k) L = ListBlank.mk (List.map some S).reverse) :\n    L.nth n k = S.reverse[n]? := by\n  rw [← proj_map_nth, hL, ← List.map_reverse, ListBlank.nth_mk,\n    List.getI_eq_iget_getElem?, List.getElem?_map]\n  cases S.reverse[n]? <;> rfl\n\n"}
{"name":"Turing.TM2to1.addBottom_map","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nL : Turing.ListBlank ((k : K) → Option (Γ k))\n⊢ Eq (Turing.ListBlank.map { f := Prod.snd, map_pt' := ⋯ } (Turing.TM2to1.addBottom L)) L","decl":"theorem addBottom_map (L : ListBlank (∀ k, Option (Γ k))) :\n    (addBottom L).map ⟨Prod.snd, by rfl⟩ = L := by\n  simp only [addBottom, ListBlank.map_cons]\n  convert ListBlank.cons_head_tail L\n  generalize ListBlank.tail L = L'\n  refine L'.induction_on fun l ↦ ?_; simp\n\n"}
{"name":"Turing.TM2to1.addBottom_modifyNth","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nf : ((k : K) → Option (Γ k)) → (k : K) → Option (Γ k)\nL : Turing.ListBlank ((k : K) → Option (Γ k))\nn : Nat\n⊢ Eq (Turing.ListBlank.modifyNth (fun a => { fst := a.1, snd := f a.2 }) n (Turing.TM2to1.addBottom L)) (Turing.TM2to1.addBottom (Turing.ListBlank.modifyNth f n L))","decl":"theorem addBottom_modifyNth (f : (∀ k, Option (Γ k)) → ∀ k, Option (Γ k))\n    (L : ListBlank (∀ k, Option (Γ k))) (n : ℕ) :\n    (addBottom L).modifyNth (fun a ↦ (a.1, f a.2)) n = addBottom (L.modifyNth f n) := by\n  cases n <;>\n    simp only [addBottom, ListBlank.head_cons, ListBlank.modifyNth, ListBlank.tail_cons]\n  congr; symm; apply ListBlank.map_modifyNth; intro; rfl\n\n"}
{"name":"Turing.TM2to1.addBottom_nth_snd","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nL : Turing.ListBlank ((k : K) → Option (Γ k))\nn : Nat\n⊢ Eq ((Turing.TM2to1.addBottom L).nth n).2 (L.nth n)","decl":"theorem addBottom_nth_snd (L : ListBlank (∀ k, Option (Γ k))) (n : ℕ) :\n    ((addBottom L).nth n).2 = L.nth n := by\n  conv => rhs; rw [← addBottom_map L, ListBlank.nth_map]\n\n"}
{"name":"Turing.TM2to1.addBottom_nth_succ_fst","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nL : Turing.ListBlank ((k : K) → Option (Γ k))\nn : Nat\n⊢ Eq ((Turing.TM2to1.addBottom L).nth (HAdd.hAdd n 1)).1 Bool.false","decl":"theorem addBottom_nth_succ_fst (L : ListBlank (∀ k, Option (Γ k))) (n : ℕ) :\n    ((addBottom L).nth (n + 1)).1 = false := by\n  rw [ListBlank.nth_succ, addBottom, ListBlank.tail_cons, ListBlank.nth_map]\n\n"}
{"name":"Turing.TM2to1.addBottom_head_fst","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nL : Turing.ListBlank ((k : K) → Option (Γ k))\n⊢ Eq (Turing.TM2to1.addBottom L).head.1 Bool.true","decl":"theorem addBottom_head_fst (L : ListBlank (∀ k, Option (Γ k))) : (addBottom L).head.1 = true := by\n  rw [addBottom, ListBlank.head_cons]\n\n"}
{"name":"Turing.TM2to1.StAct.peek.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nσ : Type u_4\nk : K\na✝¹ a✝ : σ → Option (Γ k) → σ\n⊢ Eq (Eq (Turing.TM2to1.StAct.peek a✝¹) (Turing.TM2to1.StAct.peek a✝)) (Eq a✝¹ a✝)","decl":"/-- A stack action is a command that interacts with the top of a stack. Our default position\nis at the bottom of all the stacks, so we have to hold on to this action while going to the end\nto modify the stack. -/\ninductive StAct (k : K)\n  | push : (σ → Γ k) → StAct k\n  | peek : (σ → Option (Γ k) → σ) → StAct k\n  | pop : (σ → Option (Γ k) → σ) → StAct k\n\n"}
{"name":"Turing.TM2to1.StAct.pop.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nσ : Type u_4\nk : K\na✝¹ a✝ : σ → Option (Γ k) → σ\nx✝ : Eq (Turing.TM2to1.StAct.pop a✝¹) (Turing.TM2to1.StAct.pop a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- A stack action is a command that interacts with the top of a stack. Our default position\nis at the bottom of all the stacks, so we have to hold on to this action while going to the end\nto modify the stack. -/\ninductive StAct (k : K)\n  | push : (σ → Γ k) → StAct k\n  | peek : (σ → Option (Γ k) → σ) → StAct k\n  | pop : (σ → Option (Γ k) → σ) → StAct k\n\n"}
{"name":"Turing.TM2to1.StAct.peek.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nσ : Type u_4\nk : K\na✝¹ a✝ : σ → Option (Γ k) → σ\nx✝ : Eq (Turing.TM2to1.StAct.peek a✝¹) (Turing.TM2to1.StAct.peek a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- A stack action is a command that interacts with the top of a stack. Our default position\nis at the bottom of all the stacks, so we have to hold on to this action while going to the end\nto modify the stack. -/\ninductive StAct (k : K)\n  | push : (σ → Γ k) → StAct k\n  | peek : (σ → Option (Γ k) → σ) → StAct k\n  | pop : (σ → Option (Γ k) → σ) → StAct k\n\n"}
{"name":"Turing.TM2to1.StAct.peek.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nσ : Type u_4\nk : K\ninst✝² : SizeOf K\ninst✝¹ : (a : K) → SizeOf (Γ a)\ninst✝ : SizeOf σ\na✝ : σ → Option (Γ k) → σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM2to1.StAct.peek a✝)) 1","decl":"/-- A stack action is a command that interacts with the top of a stack. Our default position\nis at the bottom of all the stacks, so we have to hold on to this action while going to the end\nto modify the stack. -/\ninductive StAct (k : K)\n  | push : (σ → Γ k) → StAct k\n  | peek : (σ → Option (Γ k) → σ) → StAct k\n  | pop : (σ → Option (Γ k) → σ) → StAct k\n\n"}
{"name":"Turing.TM2to1.StAct.push.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nσ : Type u_4\nk : K\ninst✝² : SizeOf K\ninst✝¹ : (a : K) → SizeOf (Γ a)\ninst✝ : SizeOf σ\na✝ : σ → Γ k\n⊢ Eq (SizeOf.sizeOf (Turing.TM2to1.StAct.push a✝)) 1","decl":"/-- A stack action is a command that interacts with the top of a stack. Our default position\nis at the bottom of all the stacks, so we have to hold on to this action while going to the end\nto modify the stack. -/\ninductive StAct (k : K)\n  | push : (σ → Γ k) → StAct k\n  | peek : (σ → Option (Γ k) → σ) → StAct k\n  | pop : (σ → Option (Γ k) → σ) → StAct k\n\n"}
{"name":"Turing.TM2to1.StAct.pop.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nσ : Type u_4\nk : K\ninst✝² : SizeOf K\ninst✝¹ : (a : K) → SizeOf (Γ a)\ninst✝ : SizeOf σ\na✝ : σ → Option (Γ k) → σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM2to1.StAct.pop a✝)) 1","decl":"/-- A stack action is a command that interacts with the top of a stack. Our default position\nis at the bottom of all the stacks, so we have to hold on to this action while going to the end\nto modify the stack. -/\ninductive StAct (k : K)\n  | push : (σ → Γ k) → StAct k\n  | peek : (σ → Option (Γ k) → σ) → StAct k\n  | pop : (σ → Option (Γ k) → σ) → StAct k\n\n"}
{"name":"Turing.TM2to1.StAct.push.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nσ : Type u_4\nk : K\na✝¹ a✝ : σ → Γ k\nx✝ : Eq (Turing.TM2to1.StAct.push a✝¹) (Turing.TM2to1.StAct.push a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- A stack action is a command that interacts with the top of a stack. Our default position\nis at the bottom of all the stacks, so we have to hold on to this action while going to the end\nto modify the stack. -/\ninductive StAct (k : K)\n  | push : (σ → Γ k) → StAct k\n  | peek : (σ → Option (Γ k) → σ) → StAct k\n  | pop : (σ → Option (Γ k) → σ) → StAct k\n\n"}
{"name":"Turing.TM2to1.StAct.pop.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nσ : Type u_4\nk : K\na✝¹ a✝ : σ → Option (Γ k) → σ\n⊢ Eq (Eq (Turing.TM2to1.StAct.pop a✝¹) (Turing.TM2to1.StAct.pop a✝)) (Eq a✝¹ a✝)","decl":"/-- A stack action is a command that interacts with the top of a stack. Our default position\nis at the bottom of all the stacks, so we have to hold on to this action while going to the end\nto modify the stack. -/\ninductive StAct (k : K)\n  | push : (σ → Γ k) → StAct k\n  | peek : (σ → Option (Γ k) → σ) → StAct k\n  | pop : (σ → Option (Γ k) → σ) → StAct k\n\n"}
{"name":"Turing.TM2to1.StAct.push.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nσ : Type u_4\nk : K\na✝¹ a✝ : σ → Γ k\n⊢ Eq (Eq (Turing.TM2to1.StAct.push a✝¹) (Turing.TM2to1.StAct.push a✝)) (Eq a✝¹ a✝)","decl":"/-- A stack action is a command that interacts with the top of a stack. Our default position\nis at the bottom of all the stacks, so we have to hold on to this action while going to the end\nto modify the stack. -/\ninductive StAct (k : K)\n  | push : (σ → Γ k) → StAct k\n  | peek : (σ → Option (Γ k) → σ) → StAct k\n  | pop : (σ → Option (Γ k) → σ) → StAct k\n\n"}
{"name":"Turing.TM2to1.supports_run","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nS : Finset Λ\nk : K\ns : Turing.TM2to1.StAct k\nq : Turing.TM2.Stmt Γ Λ σ\n⊢ Iff (Turing.TM2.SupportsStmt S (Turing.TM2to1.stRun s q)) (Turing.TM2.SupportsStmt S q)","decl":"theorem supports_run (S : Finset Λ) {k : K} (s : StAct₂ k) (q : Stmt₂) :\n    TM2.SupportsStmt S (stRun s q) ↔ TM2.SupportsStmt S q := by\n  cases s <;> rfl\n\n"}
{"name":"Turing.TM2to1.Λ'.normal.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝³ : SizeOf K\ninst✝² : (a : K) → SizeOf (Γ a)\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\na✝ : Λ\n⊢ Eq (SizeOf.sizeOf (Turing.TM2to1.Λ'.normal a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The machine states of the TM2 emulator. We can either be in a normal state when waiting for the\nnext TM2 action, or we can be in the \"go\" and \"return\" states to go to the top of the stack and\nreturn to the bottom, respectively. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | go (k : K) : StAct₂ k → Stmt₂ → Λ'\n  | ret : Stmt₂ → Λ'\n\n"}
{"name":"Turing.TM2to1.Λ'.ret.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝³ : SizeOf K\ninst✝² : (a : K) → SizeOf (Γ a)\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\na✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM2to1.Λ'.ret a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The machine states of the TM2 emulator. We can either be in a normal state when waiting for the\nnext TM2 action, or we can be in the \"go\" and \"return\" states to go to the top of the stack and\nreturn to the bottom, respectively. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | go (k : K) : StAct₂ k → Stmt₂ → Λ'\n  | ret : Stmt₂ → Λ'\n\n"}
{"name":"Turing.TM2to1.Λ'.normal.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\na✝¹ a✝ : Λ\nx✝ : Eq (Turing.TM2to1.Λ'.normal a✝¹) (Turing.TM2to1.Λ'.normal a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The machine states of the TM2 emulator. We can either be in a normal state when waiting for the\nnext TM2 action, or we can be in the \"go\" and \"return\" states to go to the top of the stack and\nreturn to the bottom, respectively. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | go (k : K) : StAct₂ k → Stmt₂ → Λ'\n  | ret : Stmt₂ → Λ'\n\n"}
{"name":"Turing.TM2to1.Λ'.normal.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\na✝¹ a✝ : Λ\n⊢ Eq (Eq (Turing.TM2to1.Λ'.normal a✝¹) (Turing.TM2to1.Λ'.normal a✝)) (Eq a✝¹ a✝)","decl":"/-- The machine states of the TM2 emulator. We can either be in a normal state when waiting for the\nnext TM2 action, or we can be in the \"go\" and \"return\" states to go to the top of the stack and\nreturn to the bottom, respectively. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | go (k : K) : StAct₂ k → Stmt₂ → Λ'\n  | ret : Stmt₂ → Λ'\n\n"}
{"name":"Turing.TM2to1.Λ'.ret.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\na✝¹ a✝ : Turing.TM2.Stmt Γ Λ σ\nx✝ : Eq (Turing.TM2to1.Λ'.ret a✝¹) (Turing.TM2to1.Λ'.ret a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The machine states of the TM2 emulator. We can either be in a normal state when waiting for the\nnext TM2 action, or we can be in the \"go\" and \"return\" states to go to the top of the stack and\nreturn to the bottom, respectively. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | go (k : K) : StAct₂ k → Stmt₂ → Λ'\n  | ret : Stmt₂ → Λ'\n\n"}
{"name":"Turing.TM2to1.Λ'.go.sizeOf_spec","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝³ : SizeOf K\ninst✝² : (a : K) → SizeOf (Γ a)\ninst✝¹ : SizeOf Λ\ninst✝ : SizeOf σ\nk : K\na✝¹ : Turing.TM2to1.StAct k\na✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (SizeOf.sizeOf (Turing.TM2to1.Λ'.go k a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf k)) (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The machine states of the TM2 emulator. We can either be in a normal state when waiting for the\nnext TM2 action, or we can be in the \"go\" and \"return\" states to go to the top of the stack and\nreturn to the bottom, respectively. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | go (k : K) : StAct₂ k → Stmt₂ → Λ'\n  | ret : Stmt₂ → Λ'\n\n"}
{"name":"Turing.TM2to1.Λ'.ret.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\na✝¹ a✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (Eq (Turing.TM2to1.Λ'.ret a✝¹) (Turing.TM2to1.Λ'.ret a✝)) (Eq a✝¹ a✝)","decl":"/-- The machine states of the TM2 emulator. We can either be in a normal state when waiting for the\nnext TM2 action, or we can be in the \"go\" and \"return\" states to go to the top of the stack and\nreturn to the bottom, respectively. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | go (k : K) : StAct₂ k → Stmt₂ → Λ'\n  | ret : Stmt₂ → Λ'\n\n"}
{"name":"Turing.TM2to1.Λ'.go.injEq","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nk✝ : K\na✝³ : Turing.TM2to1.StAct k✝\na✝² : Turing.TM2.Stmt Γ Λ σ\nk : K\na✝¹ : Turing.TM2to1.StAct k\na✝ : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (Eq (Turing.TM2to1.Λ'.go k✝ a✝³ a✝²) (Turing.TM2to1.Λ'.go k a✝¹ a✝)) (And (Eq k✝ k) (And (HEq a✝³ a✝¹) (Eq a✝² a✝)))","decl":"/-- The machine states of the TM2 emulator. We can either be in a normal state when waiting for the\nnext TM2 action, or we can be in the \"go\" and \"return\" states to go to the top of the stack and\nreturn to the bottom, respectively. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | go (k : K) : StAct₂ k → Stmt₂ → Λ'\n  | ret : Stmt₂ → Λ'\n\n"}
{"name":"Turing.TM2to1.Λ'.go.inj","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nk✝ : K\na✝³ : Turing.TM2to1.StAct k✝\na✝² : Turing.TM2.Stmt Γ Λ σ\nk : K\na✝¹ : Turing.TM2to1.StAct k\na✝ : Turing.TM2.Stmt Γ Λ σ\nx✝ : Eq (Turing.TM2to1.Λ'.go k✝ a✝³ a✝²) (Turing.TM2to1.Λ'.go k a✝¹ a✝)\n⊢ And (Eq k✝ k) (And (HEq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The machine states of the TM2 emulator. We can either be in a normal state when waiting for the\nnext TM2 action, or we can be in the \"go\" and \"return\" states to go to the top of the stack and\nreturn to the bottom, respectively. -/\ninductive Λ'\n  | normal : Λ → Λ'\n  | go (k : K) : StAct₂ k → Stmt₂ → Λ'\n  | ret : Stmt₂ → Λ'\n\n"}
{"name":"Turing.TM2to1.step_run","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝ : DecidableEq K\nk : K\nq : Turing.TM2.Stmt Γ Λ σ\nv : σ\nS : (k : K) → List (Γ k)\ns : Turing.TM2to1.StAct k\n⊢ Eq (Turing.TM2.stepAux (Turing.TM2to1.stRun s q) v S) (Turing.TM2.stepAux q (Turing.TM2to1.stVar v (S k) s) (Function.update S k (Turing.TM2to1.stWrite v (S k) s)))","decl":"theorem step_run {k : K} (q : Stmt₂) (v : σ) (S : ∀ k, List (Γ k)) : ∀ s : StAct₂ k,\n    TM2.stepAux (stRun s q) v S = TM2.stepAux q (stVar v (S k) s) (update S k (stWrite v (S k) s))\n  | StAct.push _ => rfl\n  | StAct.peek f => by unfold stWrite; rw [Function.update_eq_self]; rfl\n  | StAct.pop _ => rfl\n\n"}
{"name":"Turing.TM2to1.trNormal_run","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nk : K\ns : Turing.TM2to1.StAct k\nq : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (Turing.TM2to1.trNormal (Turing.TM2to1.stRun s q)) (Turing.TM1.Stmt.goto fun x x => Turing.TM2to1.Λ'.go k s q)","decl":"theorem trNormal_run {k : K} (s : StAct₂ k) (q : Stmt₂) :\n    trNormal (stRun s q) = goto fun _ _ ↦ go k s q := by\n  cases s <;> rfl\n\n"}
{"name":"Turing.TM2to1.trStmts₁_run","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\nk : K\ns : Turing.TM2to1.StAct k\nq : Turing.TM2.Stmt Γ Λ σ\n⊢ Eq (Turing.TM2to1.trStmts₁ (Turing.TM2to1.stRun s q)) (Union.union (Insert.insert (Turing.TM2to1.Λ'.go k s q) (Singleton.singleton (Turing.TM2to1.Λ'.ret q))) (Turing.TM2to1.trStmts₁ q))","decl":"open scoped Classical in\ntheorem trStmts₁_run {k : K} {s : StAct₂ k} {q : Stmt₂} :\n    trStmts₁ (stRun s q) = {go k s q, ret q} ∪ trStmts₁ q := by\n  cases s <;> simp only [trStmts₁, stRun]\n\n"}
{"name":"Turing.TM2to1.tr_respects_aux₂","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝ : DecidableEq K\nk : K\nq : Turing.TM1.Stmt Turing.TM2to1.Γ' Turing.TM2to1.Λ' σ\nv : σ\nS : (k : K) → List (Γ k)\nL : Turing.ListBlank ((k : K) → Option (Γ k))\nhL : ∀ (k : K), Eq (Turing.ListBlank.map (Turing.proj k) L) (Turing.ListBlank.mk (List.map Option.some (S k)).reverse)\no : Turing.TM2to1.StAct k\n⊢ let v' := Turing.TM2to1.stVar v (S k) o;\n  let Sk' := Turing.TM2to1.stWrite v (S k) o;\n  let S' := Function.update S k Sk';\n  Exists fun L' => And (∀ (k : K), Eq (Turing.ListBlank.map (Turing.proj k) L') (Turing.ListBlank.mk (List.map Option.some (S' k)).reverse)) (Eq (Turing.TM1.stepAux (Turing.TM2to1.trStAct q o) v (Nat.iterate (Turing.Tape.move Turing.Dir.right) (S k).length (Turing.Tape.mk' EmptyCollection.emptyCollection (Turing.TM2to1.addBottom L)))) (Turing.TM1.stepAux q v' (Nat.iterate (Turing.Tape.move Turing.Dir.right) (S' k).length (Turing.Tape.mk' EmptyCollection.emptyCollection (Turing.TM2to1.addBottom L')))))","decl":"theorem tr_respects_aux₂ [DecidableEq K] {k : K} {q : Stmt₂₁} {v : σ} {S : ∀ k, List (Γ k)}\n    {L : ListBlank (∀ k, Option (Γ k))}\n    (hL : ∀ k, L.map (proj k) = ListBlank.mk ((S k).map some).reverse) (o : StAct₂ k) :\n    let v' := stVar v (S k) o\n    let Sk' := stWrite v (S k) o\n    let S' := update S k Sk'\n    ∃ L' : ListBlank (∀ k, Option (Γ k)),\n      (∀ k, L'.map (proj k) = ListBlank.mk ((S' k).map some).reverse) ∧\n        TM1.stepAux (trStAct q o) v\n            ((Tape.move Dir.right)^[(S k).length] (Tape.mk' ∅ (addBottom L))) =\n          TM1.stepAux q v' ((Tape.move Dir.right)^[(S' k).length] (Tape.mk' ∅ (addBottom L'))) := by\n  simp only [Function.update_self]; cases o with simp only [stWrite, stVar, trStAct, TM1.stepAux]\n  | push f =>\n    have := Tape.write_move_right_n fun a : Γ' ↦ (a.1, update a.2 k (some (f v)))\n    refine\n      ⟨_, fun k' ↦ ?_, by\n        -- Porting note: `rw [...]` to `erw [...]; rfl`.\n        -- https://github.com/leanprover-community/mathlib4/issues/5164\n        erw [Tape.move_right_n_head, List.length, Tape.mk'_nth_nat, this,\n          addBottom_modifyNth fun a ↦ update a k (some (f v)), Nat.add_one, iterate_succ']\n        rfl⟩\n    refine ListBlank.ext fun i ↦ ?_\n    rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]\n    by_cases h' : k' = k\n    · subst k'\n      split_ifs with h\n        <;> simp only [List.reverse_cons, Function.update_self, ListBlank.nth_mk, List.map]\n      · rw [List.getI_eq_getElem _, List.getElem_append_right] <;>\n        simp only [List.length_append, List.length_reverse, List.length_map, ← h,\n          Nat.sub_self, List.length_singleton, List.getElem_singleton,\n          le_refl, Nat.lt_succ_self]\n      rw [← proj_map_nth, hL, ListBlank.nth_mk]\n      cases' lt_or_gt_of_ne h with h h\n      · rw [List.getI_append]\n        simpa only [List.length_map, List.length_reverse] using h\n      · rw [gt_iff_lt] at h\n        rw [List.getI_eq_default, List.getI_eq_default] <;>\n          simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,\n            List.length_append, List.length_map]\n    · split_ifs <;> rw [Function.update_of_ne h', ← proj_map_nth, hL]\n      rw [Function.update_of_ne h']\n  | peek f =>\n    rw [Function.update_eq_self]\n    use L, hL; rw [Tape.move_left_right]; congr\n    cases e : S k; · rfl\n    rw [List.length_cons, iterate_succ', Function.comp, Tape.move_right_left,\n      Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_snd, stk_nth_val _ (hL k), e,\n      List.reverse_cons, ← List.length_reverse, List.getElem?_concat_length]\n    rfl\n  | pop f =>\n    cases' e : S k with hd tl\n    · simp only [Tape.mk'_head, ListBlank.head_cons, Tape.move_left_mk', List.length,\n        Tape.write_mk', List.head?, iterate_zero_apply, List.tail_nil]\n      rw [← e, Function.update_eq_self]\n      exact ⟨L, hL, by rw [addBottom_head_fst, cond]⟩\n    · refine\n        ⟨_, fun k' ↦ ?_, by\n          erw [List.length_cons, Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_succ_fst,\n            cond_false, iterate_succ', Function.comp, Tape.move_right_left, Tape.move_right_n_head,\n            Tape.mk'_nth_nat, Tape.write_move_right_n fun a : Γ' ↦ (a.1, update a.2 k none),\n            addBottom_modifyNth fun a ↦ update a k none, addBottom_nth_snd,\n            stk_nth_val _ (hL k), e,\n            show (List.cons hd tl).reverse[tl.length]? = some hd by\n              rw [List.reverse_cons, ← List.length_reverse, List.getElem?_concat_length],\n            List.head?, List.tail]⟩\n      refine ListBlank.ext fun i ↦ ?_\n      rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]\n      by_cases h' : k' = k\n      · subst k'\n        split_ifs with h <;> simp only [Function.update_self, ListBlank.nth_mk, List.tail]\n        · rw [List.getI_eq_default]\n          · rfl\n          rw [h, List.length_reverse, List.length_map]\n        rw [← proj_map_nth, hL, ListBlank.nth_mk, e, List.map, List.reverse_cons]\n        cases' lt_or_gt_of_ne h with h h\n        · rw [List.getI_append]\n          simpa only [List.length_map, List.length_reverse] using h\n        · rw [gt_iff_lt] at h\n          rw [List.getI_eq_default, List.getI_eq_default] <;>\n            simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,\n              List.length_append, List.length_map]\n      · split_ifs <;> rw [Function.update_of_ne h', ← proj_map_nth, hL]\n        rw [Function.update_of_ne h']\n\n"}
{"name":"Turing.TM2to1.tr_respects_aux₁","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝ : DecidableEq K\nM : Λ → Turing.TM2.Stmt Γ Λ σ\nk : K\no : Turing.TM2to1.StAct k\nq : Turing.TM2.Stmt Γ Λ σ\nv : σ\nS : List (Γ k)\nL : Turing.ListBlank ((k : K) → Option (Γ k))\nhL : Eq (Turing.ListBlank.map (Turing.proj k) L) (Turing.ListBlank.mk (List.map Option.some S).reverse)\nn : Nat\nH : LE.le n S.length\n⊢ Turing.Reaches₀ (Turing.TM1.step (Turing.TM2to1.tr M)) { l := Option.some (Turing.TM2to1.Λ'.go k o q), var := v, Tape := Turing.Tape.mk' EmptyCollection.emptyCollection (Turing.TM2to1.addBottom L) } { l := Option.some (Turing.TM2to1.Λ'.go k o q), var := v, Tape := Nat.iterate (Turing.Tape.move Turing.Dir.right) n (Turing.Tape.mk' EmptyCollection.emptyCollection (Turing.TM2to1.addBottom L)) }","decl":"theorem tr_respects_aux₁ {k} (o q v) {S : List (Γ k)} {L : ListBlank (∀ k, Option (Γ k))}\n    (hL : L.map (proj k) = ListBlank.mk (S.map some).reverse) (n) (H : n ≤ S.length) :\n    Reaches₀ (TM1.step (tr M)) ⟨some (go k o q), v, Tape.mk' ∅ (addBottom L)⟩\n      ⟨some (go k o q), v, (Tape.move Dir.right)^[n] (Tape.mk' ∅ (addBottom L))⟩ := by\n  induction' n with n IH; · rfl\n  apply (IH (le_of_lt H)).tail\n  rw [iterate_succ_apply']\n  simp only [TM1.step, TM1.stepAux, tr, Tape.mk'_nth_nat, Tape.move_right_n_head,\n    addBottom_nth_snd, Option.mem_def]\n  rw [stk_nth_val _ hL, List.getElem?_eq_getElem]\n  · rfl\n  · rwa [List.length_reverse]\n\n"}
{"name":"Turing.TM2to1.tr_respects_aux₃","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝ : DecidableEq K\nM : Λ → Turing.TM2.Stmt Γ Λ σ\nq : Turing.TM2.Stmt Γ Λ σ\nv : σ\nL : Turing.ListBlank ((k : K) → Option (Γ k))\nn : Nat\n⊢ Turing.Reaches₀ (Turing.TM1.step (Turing.TM2to1.tr M)) { l := Option.some (Turing.TM2to1.Λ'.ret q), var := v, Tape := Nat.iterate (Turing.Tape.move Turing.Dir.right) n (Turing.Tape.mk' EmptyCollection.emptyCollection (Turing.TM2to1.addBottom L)) } { l := Option.some (Turing.TM2to1.Λ'.ret q), var := v, Tape := Turing.Tape.mk' EmptyCollection.emptyCollection (Turing.TM2to1.addBottom L) }","decl":"theorem tr_respects_aux₃ {q v} {L : ListBlank (∀ k, Option (Γ k))} (n) : Reaches₀ (TM1.step (tr M))\n    ⟨some (ret q), v, (Tape.move Dir.right)^[n] (Tape.mk' ∅ (addBottom L))⟩\n    ⟨some (ret q), v, Tape.mk' ∅ (addBottom L)⟩ := by\n  induction' n with n IH; · rfl\n  refine Reaches₀.head ?_ IH\n  simp only [Option.mem_def, TM1.step]\n  rw [Option.some_inj, tr, TM1.stepAux, Tape.move_right_n_head, Tape.mk'_nth_nat,\n    addBottom_nth_succ_fst, TM1.stepAux, iterate_succ', Function.comp_apply, Tape.move_right_left]\n  rfl\n\n"}
{"name":"Turing.TM2to1.tr_respects_aux","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝ : DecidableEq K\nM : Λ → Turing.TM2.Stmt Γ Λ σ\nq : Turing.TM2.Stmt Γ Λ σ\nv : σ\nT : Turing.ListBlank ((i : K) → Option (Γ i))\nk : K\nS : (k : K) → List (Γ k)\nhT : ∀ (k : K), Eq (Turing.ListBlank.map (Turing.proj k) T) (Turing.ListBlank.mk (List.map Option.some (S k)).reverse)\no : Turing.TM2to1.StAct k\nIH : ∀ {v : σ} {S : (k : K) → List (Γ k)} {T : Turing.ListBlank ((k : K) → Option (Γ k))}, (∀ (k : K), Eq (Turing.ListBlank.map (Turing.proj k) T) (Turing.ListBlank.mk (List.map Option.some (S k)).reverse)) → Exists fun b => And (Turing.TM2to1.TrCfg (Turing.TM2.stepAux q v S) b) (Turing.Reaches (Turing.TM1.step (Turing.TM2to1.tr M)) (Turing.TM1.stepAux (Turing.TM2to1.trNormal q) v (Turing.Tape.mk' EmptyCollection.emptyCollection (Turing.TM2to1.addBottom T))) b)\n⊢ Exists fun b => And (Turing.TM2to1.TrCfg (Turing.TM2.stepAux (Turing.TM2to1.stRun o q) v S) b) (Turing.Reaches (Turing.TM1.step (Turing.TM2to1.tr M)) (Turing.TM1.stepAux (Turing.TM2to1.trNormal (Turing.TM2to1.stRun o q)) v (Turing.Tape.mk' EmptyCollection.emptyCollection (Turing.TM2to1.addBottom T))) b)","decl":"theorem tr_respects_aux {q v T k} {S : ∀ k, List (Γ k)}\n    (hT : ∀ k, ListBlank.map (proj k) T = ListBlank.mk ((S k).map some).reverse) (o : StAct₂ k)\n    (IH : ∀ {v : σ} {S : ∀ k : K, List (Γ k)} {T : ListBlank (∀ k, Option (Γ k))},\n      (∀ k, ListBlank.map (proj k) T = ListBlank.mk ((S k).map some).reverse) →\n      ∃ b, TrCfg (TM2.stepAux q v S) b ∧\n        Reaches (TM1.step (tr M)) (TM1.stepAux (trNormal q) v (Tape.mk' ∅ (addBottom T))) b) :\n    ∃ b, TrCfg (TM2.stepAux (stRun o q) v S) b ∧ Reaches (TM1.step (tr M))\n      (TM1.stepAux (trNormal (stRun o q)) v (Tape.mk' ∅ (addBottom T))) b := by\n  simp only [trNormal_run, step_run]\n  have hgo := tr_respects_aux₁ M o q v (hT k) _ le_rfl\n  obtain ⟨T', hT', hrun⟩ := tr_respects_aux₂ (Λ := Λ) hT o\n  have := hgo.tail' rfl\n  rw [tr, TM1.stepAux, Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_snd,\n    stk_nth_val _ (hT k), List.getElem?_eq_none (le_of_eq (List.length_reverse _)),\n    Option.isNone, cond, hrun, TM1.stepAux] at this\n  obtain ⟨c, gc, rc⟩ := IH hT'\n  refine ⟨c, gc, (this.to₀.trans (tr_respects_aux₃ M _) c (TransGen.head' rfl ?_)).to_reflTransGen⟩\n  rw [tr, TM1.stepAux, Tape.mk'_head, addBottom_head_fst]\n  exact rc\n\n"}
{"name":"Turing.TM2to1.tr_respects","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝ : DecidableEq K\nM : Λ → Turing.TM2.Stmt Γ Λ σ\n⊢ Turing.Respects (Turing.TM2.step M) (Turing.TM1.step (Turing.TM2to1.tr M)) Turing.TM2to1.TrCfg","decl":"theorem tr_respects : Respects (TM2.step M) (TM1.step (tr M)) TrCfg := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/12129): additional beta reduction needed\n  intro c₁ c₂ h\n  cases' h with l v S L hT\n  cases' l with l; · constructor\n  rsuffices ⟨b, c, r⟩ : ∃ b, _ ∧ Reaches (TM1.step (tr M)) _ _\n  · exact ⟨b, c, TransGen.head' rfl r⟩\n  simp only [tr]\n  -- Porting note: `refine'` failed because of implicit lambda, so `induction` is used.\n  generalize M l = N\n  induction N using stmtStRec generalizing v S L hT with\n  | H₁ k s q IH => exact tr_respects_aux M hT s @IH\n  | H₂ a _ IH => exact IH _ hT\n  | H₃ p q₁ q₂ IH₁ IH₂ =>\n    unfold TM2.stepAux trNormal TM1.stepAux\n    beta_reduce\n    cases p v <;> [exact IH₂ _ hT; exact IH₁ _ hT]\n  | H₄ => exact ⟨_, ⟨_, hT⟩, ReflTransGen.refl⟩\n  | H₅ => exact ⟨_, ⟨_, hT⟩, ReflTransGen.refl⟩\n\n"}
{"name":"Turing.TM2to1.trCfg_init","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝² : DecidableEq K\ninst✝¹ : Inhabited Λ\ninst✝ : Inhabited σ\nk : K\nL : List (Γ k)\n⊢ Turing.TM2to1.TrCfg (Turing.TM2.init k L) (Turing.TM1.init (Turing.TM2to1.trInit k L))","decl":"theorem trCfg_init (k) (L : List (Γ k)) : TrCfg (TM2.init k L) (TM1.init (trInit k L) : Cfg₂₁) := by\n  rw [(_ : TM1.init _ = _)]\n  · refine ⟨ListBlank.mk (L.reverse.map fun a ↦ update default k (some a)), fun k' ↦ ?_⟩\n    refine ListBlank.ext fun i ↦ ?_\n    rw [ListBlank.map_mk, ListBlank.nth_mk, List.getI_eq_iget_getElem?, List.map_map]\n    have : ((proj k').f ∘ fun a => update (β := fun k => Option (Γ k)) default k (some a))\n      = fun a => (proj k').f (update (β := fun k => Option (Γ k)) default k (some a)) := rfl\n    rw [this, List.getElem?_map, proj, PointedMap.mk_val]\n    simp only []\n    by_cases h : k' = k\n    · subst k'\n      simp only [Function.update_self]\n      rw [ListBlank.nth_mk, List.getI_eq_iget_getElem?, ← List.map_reverse, List.getElem?_map]\n    · simp only [Function.update_of_ne h]\n      rw [ListBlank.nth_mk, List.getI_eq_iget_getElem?, List.map, List.reverse_nil]\n      cases L.reverse[i]? <;> rfl\n  · rw [trInit, TM1.init]\n    congr <;> cases L.reverse <;> try rfl\n    simp only [List.map_map, List.tail_cons, List.map]\n    rfl\n\n"}
{"name":"Turing.TM2to1.tr_eval_dom","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝² : DecidableEq K\nM : Λ → Turing.TM2.Stmt Γ Λ σ\ninst✝¹ : Inhabited Λ\ninst✝ : Inhabited σ\nk : K\nL : List (Γ k)\n⊢ Iff (Turing.TM1.eval (Turing.TM2to1.tr M) (Turing.TM2to1.trInit k L)).Dom (Turing.TM2.eval M k L).Dom","decl":"theorem tr_eval_dom (k) (L : List (Γ k)) :\n    (TM1.eval (tr M) (trInit k L)).Dom ↔ (TM2.eval M k L).Dom :=\n  Turing.tr_eval_dom (tr_respects M) (trCfg_init k L)\n\n"}
{"name":"Turing.TM2to1.tr_eval","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝² : DecidableEq K\nM : Λ → Turing.TM2.Stmt Γ Λ σ\ninst✝¹ : Inhabited Λ\ninst✝ : Inhabited σ\nk : K\nL : List (Γ k)\nL₁ : Turing.ListBlank Turing.TM2to1.Γ'\nL₂ : List (Γ k)\nH₁ : Membership.mem (Turing.TM1.eval (Turing.TM2to1.tr M) (Turing.TM2to1.trInit k L)) L₁\nH₂ : Membership.mem (Turing.TM2.eval M k L) L₂\n⊢ Exists fun S => Exists fun L' => And (Eq (Turing.TM2to1.addBottom L') L₁) (And (∀ (k : K), Eq (Turing.ListBlank.map (Turing.proj k) L') (Turing.ListBlank.mk (List.map Option.some (S k)).reverse)) (Eq (S k) L₂))","decl":"theorem tr_eval (k) (L : List (Γ k)) {L₁ L₂} (H₁ : L₁ ∈ TM1.eval (tr M) (trInit k L))\n    (H₂ : L₂ ∈ TM2.eval M k L) :\n    ∃ (S : ∀ k, List (Γ k)) (L' : ListBlank (∀ k, Option (Γ k))),\n      addBottom L' = L₁ ∧\n        (∀ k, L'.map (proj k) = ListBlank.mk ((S k).map some).reverse) ∧ S k = L₂ := by\n  obtain ⟨c₁, h₁, rfl⟩ := (Part.mem_map_iff _).1 H₁\n  obtain ⟨c₂, h₂, rfl⟩ := (Part.mem_map_iff _).1 H₂\n  obtain ⟨_, ⟨L', hT⟩, h₃⟩ := Turing.tr_eval (tr_respects M) (trCfg_init k L) h₂\n  cases Part.mem_unique h₁ h₃\n  exact ⟨_, L', by simp only [Tape.mk'_right₀], hT, rfl⟩\n\n"}
{"name":"Turing.TM2to1.tr_supports","module":"Mathlib.Computability.TuringMachine","initialProofState":"K : Type u_1\nΓ : K → Type u_2\nΛ : Type u_3\nσ : Type u_4\ninst✝¹ : DecidableEq K\nM : Λ → Turing.TM2.Stmt Γ Λ σ\ninst✝ : Inhabited Λ\nS : Finset Λ\nss : Turing.TM2.Supports M S\n⊢ Turing.TM1.Supports (Turing.TM2to1.tr M) (Turing.TM2to1.trSupp M S)","decl":"open scoped Classical in\ntheorem tr_supports {S} (ss : TM2.Supports M S) : TM1.Supports (tr M) (trSupp M S) :=\n  ⟨Finset.mem_biUnion.2 ⟨_, ss.1, Finset.mem_insert.2 <| Or.inl rfl⟩, fun l' h ↦ by\n    suffices ∀ (q) (_ : TM2.SupportsStmt S q) (_ : ∀ x ∈ trStmts₁ q, x ∈ trSupp M S),\n        TM1.SupportsStmt (trSupp M S) (trNormal q) ∧\n        ∀ l' ∈ trStmts₁ q, TM1.SupportsStmt (trSupp M S) (tr M l') by\n      rcases Finset.mem_biUnion.1 h with ⟨l, lS, h⟩\n      have :=\n        this _ (ss.2 l lS) fun x hx ↦ Finset.mem_biUnion.2 ⟨_, lS, Finset.mem_insert_of_mem hx⟩\n      rcases Finset.mem_insert.1 h with (rfl | h) <;> [exact this.1; exact this.2 _ h]\n    clear h l'\n    refine stmtStRec ?_ ?_ ?_ ?_ ?_\n    · intro _ s _ IH ss' sub -- stack op\n      rw [TM2to1.supports_run] at ss'\n      simp only [TM2to1.trStmts₁_run, Finset.mem_union, Finset.mem_insert, Finset.mem_singleton]\n        at sub\n      have hgo := sub _ (Or.inl <| Or.inl rfl)\n      have hret := sub _ (Or.inl <| Or.inr rfl)\n      cases' IH ss' fun x hx ↦ sub x <| Or.inr hx with IH₁ IH₂\n      refine ⟨by simp only [trNormal_run, TM1.SupportsStmt]; intros; exact hgo, fun l h ↦ ?_⟩\n      rw [trStmts₁_run] at h\n      simp only [TM2to1.trStmts₁_run, Finset.mem_union, Finset.mem_insert, Finset.mem_singleton]\n        at h\n      rcases h with (⟨rfl | rfl⟩ | h)\n      · cases s\n        · exact ⟨fun _ _ ↦ hret, fun _ _ ↦ hgo⟩\n        · exact ⟨fun _ _ ↦ hret, fun _ _ ↦ hgo⟩\n        · exact ⟨⟨fun _ _ ↦ hret, fun _ _ ↦ hret⟩, fun _ _ ↦ hgo⟩\n      · unfold TM1.SupportsStmt TM2to1.tr\n        exact ⟨IH₁, fun _ _ ↦ hret⟩\n      · exact IH₂ _ h\n    · intro _ _ IH ss' sub -- load\n      unfold TM2to1.trStmts₁ at sub ⊢\n      exact IH ss' sub\n    · intro _ _ _ IH₁ IH₂ ss' sub -- branch\n      unfold TM2to1.trStmts₁ at sub\n      cases' IH₁ ss'.1 fun x hx ↦ sub x <| Finset.mem_union_left _ hx with IH₁₁ IH₁₂\n      cases' IH₂ ss'.2 fun x hx ↦ sub x <| Finset.mem_union_right _ hx with IH₂₁ IH₂₂\n      refine ⟨⟨IH₁₁, IH₂₁⟩, fun l h ↦ ?_⟩\n      rw [trStmts₁] at h\n      rcases Finset.mem_union.1 h with (h | h) <;> [exact IH₁₂ _ h; exact IH₂₂ _ h]\n    · intro _ ss' _ -- goto\n      simp only [trStmts₁, Finset.not_mem_empty]; refine ⟨?_, fun _ ↦ False.elim⟩\n      exact fun _ v ↦ Finset.mem_biUnion.2 ⟨_, ss' v, Finset.mem_insert_self _ _⟩\n    · intro _ _ -- halt\n      simp only [trStmts₁, Finset.not_mem_empty]\n      exact ⟨trivial, fun _ ↦ False.elim⟩⟩\n\n"}
