{"name":"Module.Finite.of_isLocalizedModule","module":"Mathlib.RingTheory.Localization.Finiteness","initialProofState":"R : Type u\ninst✝¹¹ : CommSemiring R\nS : Submonoid R\nRₚ : Type v\ninst✝¹⁰ : CommSemiring Rₚ\ninst✝⁹ : Algebra R Rₚ\ninst✝⁸ : IsLocalization S Rₚ\nM : Type w\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nMₚ : Type t\ninst✝⁵ : AddCommMonoid Mₚ\ninst✝⁴ : Module R Mₚ\ninst✝³ : Module Rₚ Mₚ\ninst✝² : IsScalarTower R Rₚ Mₚ\nf : LinearMap (RingHom.id R) M Mₚ\ninst✝¹ : IsLocalizedModule S f\ninst✝ : Module.Finite R M\n⊢ Module.Finite Rₚ Mₚ","decl":"include S f in\nlemma of_isLocalizedModule [Module.Finite R M] : Module.Finite Rₚ Mₚ := by\n  classical\n  obtain ⟨T, hT⟩ := ‹Module.Finite R M›\n  use T.image f\n  rw [eq_top_iff]\n  rintro x -\n  obtain ⟨⟨y, m⟩, (hyx : IsLocalizedModule.mk' f y m = x)⟩ :=\n    IsLocalizedModule.mk'_surjective S f x\n  have hy : y ∈ Submodule.span R T := by rw [hT]; trivial\n  have : f y ∈ Submodule.map f (Submodule.span R T) := Submodule.mem_map_of_mem hy\n  rw [Submodule.map_span] at this\n  have H : Submodule.span R (f '' T) ≤\n      (Submodule.span Rₚ (f '' T)).restrictScalars R := by\n    rw [Submodule.span_le]; exact Submodule.subset_span\n  convert (Submodule.span Rₚ (f '' T)).smul_mem\n    (IsLocalization.mk' Rₚ (1 : R) m) (H this) using 0\n  · rw [← hyx, ← IsLocalizedModule.mk'_one S, IsLocalizedModule.mk'_smul_mk']\n    simp\n\n"}
{"name":"Module.Finite.of_localizationSpan_finite'","module":"Mathlib.RingTheory.Localization.Finiteness","initialProofState":"R : Type u\ninst✝¹⁰ : CommRing R\nM : Type w\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\nt : Finset R\nht : Eq (Ideal.span ↑t) Top.top\nMₚ : (Subtype fun x => Membership.mem t x) → Type u_1\ninst✝⁷ : (g : Subtype fun x => Membership.mem t x) → AddCommMonoid (Mₚ g)\ninst✝⁶ : (g : Subtype fun x => Membership.mem t x) → Module R (Mₚ g)\nRₚ : (Subtype fun x => Membership.mem t x) → Type u\ninst✝⁵ : (g : Subtype fun x => Membership.mem t x) → CommRing (Rₚ g)\ninst✝⁴ : (g : Subtype fun x => Membership.mem t x) → Algebra R (Rₚ g)\ninst✝³ : ∀ (g : Subtype fun x => Membership.mem t x), IsLocalization.Away (↑g) (Rₚ g)\ninst✝² : (g : Subtype fun x => Membership.mem t x) → Module (Rₚ g) (Mₚ g)\ninst✝¹ : ∀ (g : Subtype fun x => Membership.mem t x), IsScalarTower R (Rₚ g) (Mₚ g)\nf : (g : Subtype fun x => Membership.mem t x) → LinearMap (RingHom.id R) M (Mₚ g)\ninst✝ : ∀ (g : Subtype fun x => Membership.mem t x), IsLocalizedModule (Submonoid.powers ↑g) (f g)\nH : ∀ (g : Subtype fun x => Membership.mem t x), Module.Finite (Rₚ g) (Mₚ g)\n⊢ Module.Finite R M","decl":"/--\nIf there exists a finite set `{ r }` of `R` such that `Mᵣ` is `Rᵣ`-finite for each `r`,\nthen `M` is a finite `R`-module.\n\nGeneral version for any modules `Mᵣ` and rings `Rᵣ` satisfying the correct universal properties.\nSee `Module.Finite.of_localizationSpan_finite` for the specialized version.\n\nSee `of_localizationSpan'` for a version without the finite set assumption.\n-/\ntheorem of_localizationSpan_finite' (t : Finset R) (ht : Ideal.span (t : Set R) = ⊤)\n    {Mₚ : ∀ (_ : t), Type*} [∀ (g : t), AddCommMonoid (Mₚ g)] [∀ (g : t), Module R (Mₚ g)]\n    {Rₚ : ∀ (_ : t), Type u} [∀ (g : t), CommRing (Rₚ g)] [∀ (g : t), Algebra R (Rₚ g)]\n    [∀ (g : t), IsLocalization.Away g.val (Rₚ g)]\n    [∀ (g : t), Module (Rₚ g) (Mₚ g)] [∀ (g : t), IsScalarTower R (Rₚ g) (Mₚ g)]\n    (f : ∀ (g : t), M →ₗ[R] Mₚ g) [∀ (g : t), IsLocalizedModule (Submonoid.powers g.val) (f g)]\n    (H : ∀ (g : t), Module.Finite (Rₚ g) (Mₚ g)) :\n    Module.Finite R M := by\n  classical\n  constructor\n  choose s₁ s₂ using (fun g ↦ (H g).1)\n  let sf := fun x : t ↦\n    IsLocalizedModule.finsetIntegerMultiple (Submonoid.powers x.val) (f x) (s₁ x)\n  use t.attach.biUnion sf\n  rw [Submodule.span_attach_biUnion, eq_top_iff]\n  rintro x -\n  refine Submodule.mem_of_span_eq_top_of_smul_pow_mem _ (t : Set R) ht _ (fun r ↦ ?_)\n  set S : Submonoid R := Submonoid.powers r.val\n  obtain ⟨⟨_, n₁, rfl⟩, hn₁⟩ := multiple_mem_span_of_mem_localization_span S (Rₚ r)\n    (s₁ r : Set (Mₚ r)) (IsLocalizedModule.mk' (f r) x (1 : S)) (by rw [s₂ r]; trivial)\n  rw [Submonoid.smul_def, ← IsLocalizedModule.mk'_smul, IsLocalizedModule.mk'_one] at hn₁\n  obtain ⟨⟨_, n₂, rfl⟩, hn₂⟩ := IsLocalizedModule.smul_mem_finsetIntegerMultiple_span\n    S (f r) _ (s₁ r) hn₁\n  rw [Submonoid.smul_def] at hn₂\n  use n₂ + n₁\n  apply le_iSup (fun x : t ↦ Submodule.span R (sf x : Set M)) r\n  rw [pow_add, mul_smul]\n  exact hn₂\n\n"}
{"name":"Module.Finite.of_localizationSpan'","module":"Mathlib.RingTheory.Localization.Finiteness","initialProofState":"R : Type u\ninst✝⁸ : CommRing R\nM : Type w\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nt : Set R\nht : Eq (Ideal.span t) Top.top\nMₚ : ↑t → Type u_1\ninst✝⁵ : (g : ↑t) → AddCommMonoid (Mₚ g)\ninst✝⁴ : (g : ↑t) → Module R (Mₚ g)\nRₚ : ↑t → Type u\ninst✝³ : (g : ↑t) → CommRing (Rₚ g)\ninst✝² : (g : ↑t) → Algebra R (Rₚ g)\nh₁ : ∀ (g : ↑t), IsLocalization.Away (↑g) (Rₚ g)\ninst✝¹ : (g : ↑t) → Module (Rₚ g) (Mₚ g)\ninst✝ : ∀ (g : ↑t), IsScalarTower R (Rₚ g) (Mₚ g)\nf : (g : ↑t) → LinearMap (RingHom.id R) M (Mₚ g)\nh₂ : ∀ (g : ↑t), IsLocalizedModule (Submonoid.powers ↑g) (f g)\nH : ∀ (g : ↑t), Module.Finite (Rₚ g) (Mₚ g)\n⊢ Module.Finite R M","decl":"/--\nIf there exists a set `{ r }` of `R` such that `Mᵣ` is `Rᵣ`-finite for each `r`,\nthen `M` is a finite `R`-module.\n\nGeneral version for any modules `Mᵣ` and rings `Rᵣ` satisfying the correct universal properties.\nSee `Module.Finite.of_localizationSpan_finite` for the specialized version.\n-/\ntheorem of_localizationSpan' (t : Set R) (ht : Ideal.span t = ⊤)\n    {Mₚ : ∀ (_ : t), Type*} [∀ (g : t), AddCommMonoid (Mₚ g)] [∀ (g : t), Module R (Mₚ g)]\n    {Rₚ : ∀ (_ : t), Type u} [∀ (g : t), CommRing (Rₚ g)] [∀ (g : t), Algebra R (Rₚ g)]\n    [h₁ : ∀ (g : t), IsLocalization.Away g.val (Rₚ g)]\n    [∀ (g : t), Module (Rₚ g) (Mₚ g)] [∀ (g : t), IsScalarTower R (Rₚ g) (Mₚ g)]\n    (f : ∀ (g : t), M →ₗ[R] Mₚ g) [h₂ : ∀ (g : t), IsLocalizedModule (Submonoid.powers g.val) (f g)]\n    (H : ∀ (g : t), Module.Finite (Rₚ g) (Mₚ g)) :\n    Module.Finite R M := by\n  rw [Ideal.span_eq_top_iff_finite] at ht\n  obtain ⟨t', hc, ht'⟩ := ht\n  have (g : t') : IsLocalization.Away g.val (Rₚ ⟨g.val, hc g.property⟩) :=\n    h₁ ⟨g.val, hc g.property⟩\n  have (g : t') : IsLocalizedModule (Submonoid.powers g.val)\n    ((fun g ↦ f ⟨g.val, hc g.property⟩) g) := h₂ ⟨g.val, hc g.property⟩\n  apply of_localizationSpan_finite' t' ht' (fun g ↦ f ⟨g.val, hc g.property⟩)\n    (fun g ↦ H ⟨g.val, hc g.property⟩)\n\n"}
{"name":"Module.Finite.of_localizationSpan_finite","module":"Mathlib.RingTheory.Localization.Finiteness","initialProofState":"R : Type u\ninst✝² : CommRing R\nM : Type w\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nt : Finset R\nht : Eq (Ideal.span ↑t) Top.top\nH : ∀ (g : Subtype fun x => Membership.mem t x), Module.Finite (Localization.Away ↑g) (LocalizedModule (Submonoid.powers ↑g) M)\n⊢ Module.Finite R M","decl":"/--\nIf there exists a finite set `{ r }` of `R` such that `Mᵣ` is `Rᵣ`-finite for each `r`,\nthen `M` is a finite `R`-module.\n\nSee `of_localizationSpan` for a version without the finite set assumption.\n-/\ntheorem of_localizationSpan_finite (t : Finset R) (ht : Ideal.span (t : Set R) = ⊤)\n    (H : ∀ (g : t), Module.Finite (Localization.Away g.val)\n      (LocalizedModule (Submonoid.powers g.val) M)) :\n    Module.Finite R M :=\n  let f (g : t) : M →ₗ[R] LocalizedModule (Submonoid.powers g.val) M :=\n    LocalizedModule.mkLinearMap (Submonoid.powers g.val) M\n  of_localizationSpan_finite' t ht f H\n\n"}
{"name":"Module.Finite.of_localizationSpan","module":"Mathlib.RingTheory.Localization.Finiteness","initialProofState":"R : Type u\ninst✝² : CommRing R\nM : Type w\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nt : Set R\nht : Eq (Ideal.span t) Top.top\nH : ∀ (g : ↑t), Module.Finite (Localization.Away ↑g) (LocalizedModule (Submonoid.powers ↑g) M)\n⊢ Module.Finite R M","decl":"/-- If there exists a set `{ r }` of `R` such that `Mᵣ` is `Rᵣ`-finite for each `r`,\nthen `M` is a finite `R`-module. -/\ntheorem of_localizationSpan (t : Set R) (ht : Ideal.span t = ⊤)\n    (H : ∀ (g : t), Module.Finite (Localization.Away g.val)\n      (LocalizedModule (Submonoid.powers g.val) M)) :\n    Module.Finite R M :=\n  let f (g : t) : M →ₗ[R] LocalizedModule (Submonoid.powers g.val) M :=\n    LocalizedModule.mkLinearMap (Submonoid.powers g.val) M\n  of_localizationSpan' t ht f H\n\n"}
{"name":"Ideal.fg_of_localizationSpan","module":"Mathlib.RingTheory.Localization.Finiteness","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nt : Set R\nht : Eq (Ideal.span t) Top.top\nH : ∀ (g : ↑t), (Ideal.map (algebraMap R (Localization.Away ↑g)) I).FG\n⊢ I.FG","decl":"/-- If `I` is an ideal such that there exists a set `{ r }` of `R` such\nthat the image of `I` in `Rᵣ` is finitely generated for each `r`, then `I` is finitely\ngenerated. -/\nlemma fg_of_localizationSpan {I : Ideal R} (t : Set R) (ht : Ideal.span t = ⊤)\n    (H : ∀ (g : t), (I.map (algebraMap R (Localization.Away g.val))).FG) : I.FG := by\n  apply Module.Finite.iff_fg.mp\n  let k (g : t) : I →ₗ[R] (I.map (algebraMap R (Localization.Away g.val))) :=\n    Algebra.idealMap I (S := Localization.Away g.val)\n  exact Module.Finite.of_localizationSpan' t ht k (fun g ↦ Module.Finite.iff_fg.mpr (H g))\n\n"}
{"name":"RingHom.ker_fg_of_localizationSpan","module":"Mathlib.RingTheory.Localization.Finiteness","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\nt : Set R\nht : Eq (Ideal.span t) Top.top\nH : ∀ (g : ↑t), (RingHom.ker (Localization.awayMap f ↑g)).FG\n⊢ (RingHom.ker f).FG","decl":"/--\nTo check that the kernel of a ring homomorphism is finitely generated,\nit suffices to check this after localizing at a spanning set of the source.\n-/\nlemma RingHom.ker_fg_of_localizationSpan (t : Set R) (ht : Ideal.span t = ⊤)\n    (H : ∀ g : t, (RingHom.ker (Localization.awayMap f g.val)).FG) :\n    (RingHom.ker f).FG := by\n  apply Ideal.fg_of_localizationSpan t ht\n  intro g\n  rw [← IsLocalization.ker_map (Localization.Away (f g.val)) f (Submonoid.map_powers f g.val)]\n  exact H g\n"}
