{"name":"HahnSeries.coeff_one","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝³ : Zero Γ\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : One R\na : Γ\n⊢ Eq (HahnSeries.coeff 1 a) (ite (Eq a 0) 1 0)","decl":"open Classical in\n@[simp]\ntheorem coeff_one [Zero R] [One R] {a : Γ} :\n    (1 : HahnSeries Γ R).coeff a = if a = 0 then 1 else 0 :=\n  coeff_single\n\n"}
{"name":"HahnSeries.one_coeff","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝³ : Zero Γ\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : One R\na : Γ\n⊢ Eq (HahnSeries.coeff 1 a) (ite (Eq a 0) 1 0)","decl":"@[deprecated (since := \"2025-01-31\")] alias one_coeff := coeff_one\n\n"}
{"name":"HahnSeries.single_zero_one","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝³ : Zero Γ\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : One R\n⊢ Eq ((HahnSeries.single 0) 1) 1","decl":"@[simp]\ntheorem single_zero_one [Zero R] [One R] : single (0 : Γ) (1 : R) = 1 :=\n  rfl\n\n"}
{"name":"HahnSeries.support_one","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝³ : Zero Γ\ninst✝² : PartialOrder Γ\ninst✝¹ : MulZeroOneClass R\ninst✝ : Nontrivial R\n⊢ Eq (HahnSeries.support 1) (Singleton.singleton 0)","decl":"@[simp]\ntheorem support_one [MulZeroOneClass R] [Nontrivial R] : support (1 : HahnSeries Γ R) = {0} :=\n  support_single_of_ne one_ne_zero\n\n"}
{"name":"HahnSeries.orderTop_one","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝³ : Zero Γ\ninst✝² : PartialOrder Γ\ninst✝¹ : MulZeroOneClass R\ninst✝ : Nontrivial R\n⊢ Eq (HahnSeries.orderTop 1) 0","decl":"@[simp]\ntheorem orderTop_one [MulZeroOneClass R] [Nontrivial R] : orderTop (1 : HahnSeries Γ R) = 0 := by\n  rw [← single_zero_one, orderTop_single one_ne_zero, WithTop.coe_eq_zero]\n\n"}
{"name":"HahnSeries.order_one","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : Zero Γ\ninst✝¹ : PartialOrder Γ\ninst✝ : MulZeroOneClass R\n⊢ Eq (HahnSeries.order 1) 0","decl":"@[simp]\ntheorem order_one [MulZeroOneClass R] : order (1 : HahnSeries Γ R) = 0 := by\n  cases subsingleton_or_nontrivial R\n  · rw [Subsingleton.elim (1 : HahnSeries Γ R) 0, order_zero]\n  · exact order_single one_ne_zero\n\n"}
{"name":"HahnSeries.leadingCoeff_one","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : Zero Γ\ninst✝¹ : PartialOrder Γ\ninst✝ : MulZeroOneClass R\n⊢ Eq (HahnSeries.leadingCoeff 1) 1","decl":"@[simp]\ntheorem leadingCoeff_one [MulZeroOneClass R] : (1 : HahnSeries Γ R).leadingCoeff = 1 := by\n  simp [leadingCoeff_eq]\n\n"}
{"name":"HahnSeries.map_one","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝³ : Zero Γ\ninst✝² : PartialOrder Γ\ninst✝¹ : MonoidWithZero R\ninst✝ : MonoidWithZero S\nf : MonoidWithZeroHom R S\n⊢ Eq (HahnSeries.map 1 f) 1","decl":"@[simp]\nprotected lemma map_one [MonoidWithZero R] [MonoidWithZero S] (f : R →*₀ S) :\n    (1 : HahnSeries Γ R).map f = (1 : HahnSeries Γ S) := by\n  ext g\n  by_cases h : g = 0 <;> simp [h]\n\n"}
{"name":"HahnModule.ext","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_5\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero V\ninst✝ : SMul R V\nx y : HahnModule Γ R V\nh : Eq ((HahnModule.of R).symm x).coeff ((HahnModule.of R).symm y).coeff\n⊢ Eq x y","decl":"@[ext]\ntheorem ext (x y : HahnModule Γ R V) (h : ((of R).symm x).coeff = ((of R).symm y).coeff) : x = y :=\n  (of R).symm.injective <| HahnSeries.coeff_inj.1 h\n\n"}
{"name":"HahnModule.ext_iff","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_5\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero V\ninst✝ : SMul R V\nx y : HahnModule Γ R V\n⊢ Iff (Eq x y) (Eq ((HahnModule.of R).symm x).coeff ((HahnModule.of R).symm y).coeff)","decl":"@[ext]\ntheorem ext (x y : HahnModule Γ R V) (h : ((of R).symm x).coeff = ((of R).symm y).coeff) : x = y :=\n  (of R).symm.injective <| HahnSeries.coeff_inj.1 h\n\n"}
{"name":"HahnModule.of_zero","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_5\ninst✝² : PartialOrder Γ\ninst✝¹ : AddCommMonoid V\ninst✝ : SMul R V\n⊢ Eq ((HahnModule.of R) 0) 0","decl":"@[simp] theorem of_zero : of R (0 : HahnSeries Γ V) = 0 := rfl\n"}
{"name":"HahnModule.of_add","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_5\ninst✝² : PartialOrder Γ\ninst✝¹ : AddCommMonoid V\ninst✝ : SMul R V\nx y : HahnSeries Γ V\n⊢ Eq ((HahnModule.of R) (HAdd.hAdd x y)) (HAdd.hAdd ((HahnModule.of R) x) ((HahnModule.of R) y))","decl":"@[simp] theorem of_add (x y : HahnSeries Γ V) : of R (x + y) = of R x + of R y := rfl\n\n"}
{"name":"HahnModule.of_symm_zero","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_5\ninst✝² : PartialOrder Γ\ninst✝¹ : AddCommMonoid V\ninst✝ : SMul R V\n⊢ Eq ((HahnModule.of R).symm 0) 0","decl":"@[simp] theorem of_symm_zero : (of R).symm (0 : HahnModule Γ R V) = 0 := rfl\n"}
{"name":"HahnModule.of_symm_add","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_5\ninst✝² : PartialOrder Γ\ninst✝¹ : AddCommMonoid V\ninst✝ : SMul R V\nx y : HahnModule Γ R V\n⊢ Eq ((HahnModule.of R).symm (HAdd.hAdd x y)) (HAdd.hAdd ((HahnModule.of R).symm x) ((HahnModule.of R).symm y))","decl":"@[simp] theorem of_symm_add (x y : HahnModule Γ R V) :\n  (of R).symm (x + y) = (of R).symm x + (of R).symm y := rfl\n\n"}
{"name":"HahnModule.coeff_smul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : AddCommMonoid V\ninst✝⁴ : SMul R V\ninst✝³ : PartialOrder Γ'\ninst✝² : VAdd Γ Γ'\ninst✝¹ : IsOrderedCancelVAdd Γ Γ'\ninst✝ : Zero R\nx : HahnSeries Γ R\ny : HahnModule Γ' R V\na : Γ'\n⊢ Eq (((HahnModule.of R).symm (HSMul.hSMul x y)).coeff a) ((Finset.VAddAntidiagonal ⋯ ⋯ a).sum fun ij => HSMul.hSMul (x.coeff ij.1) (((HahnModule.of R).symm y).coeff ij.2))","decl":"theorem coeff_smul [Zero R] (x : HahnSeries Γ R) (y : HahnModule Γ' R V) (a : Γ') :\n    ((of R).symm <| x • y).coeff a =\n      ∑ ij ∈ VAddAntidiagonal x.isPWO_support ((of R).symm y).isPWO_support a,\n        x.coeff ij.fst • ((of R).symm y).coeff ij.snd :=\n  rfl\n\n"}
{"name":"HahnModule.smul_coeff","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : AddCommMonoid V\ninst✝⁴ : SMul R V\ninst✝³ : PartialOrder Γ'\ninst✝² : VAdd Γ Γ'\ninst✝¹ : IsOrderedCancelVAdd Γ Γ'\ninst✝ : Zero R\nx : HahnSeries Γ R\ny : HahnModule Γ' R V\na : Γ'\n⊢ Eq (((HahnModule.of R).symm (HSMul.hSMul x y)).coeff a) ((Finset.VAddAntidiagonal ⋯ ⋯ a).sum fun ij => HSMul.hSMul (x.coeff ij.1) (((HahnModule.of R).symm y).coeff ij.2))","decl":"@[deprecated (since := \"2025-01-31\")] alias smul_coeff := coeff_smul\n\n"}
{"name":"HahnModule.of_smul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_5\ninst✝² : PartialOrder Γ\ninst✝¹ : AddCommMonoid V\ninst✝ : SMulZeroClass R V\nr : R\nx : HahnSeries Γ V\n⊢ Eq ((HahnModule.of R) (HSMul.hSMul r x)) (HSMul.hSMul r ((HahnModule.of R) x))","decl":"@[simp] theorem of_smul [SMulZeroClass R V] (r : R) (x : HahnSeries Γ V) :\n  (of R) (r • x) = r • (of R) x := rfl\n"}
{"name":"HahnModule.of_symm_smul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\nV : Type u_5\ninst✝² : PartialOrder Γ\ninst✝¹ : AddCommMonoid V\ninst✝ : SMulZeroClass R V\nr : R\nx : HahnModule Γ R V\n⊢ Eq ((HahnModule.of R).symm (HSMul.hSMul r x)) (HSMul.hSMul r ((HahnModule.of R).symm x))","decl":"@[simp] theorem of_symm_smul [SMulZeroClass R V] (r : R) (x : HahnModule Γ R V) :\n  (of R).symm (r • x) = r • (of R).symm x := rfl\n\n"}
{"name":"HahnModule.coeff_smul_right","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\ninst✝² : AddCommMonoid V\ninst✝¹ : Zero R\ninst✝ : SMulZeroClass R V\nx : HahnSeries Γ R\ny : HahnModule Γ' R V\na : Γ'\ns : Set Γ'\nhs : s.IsPWO\nhys : HasSubset.Subset ((HahnModule.of R).symm y).support s\n⊢ Eq (((HahnModule.of R).symm (HSMul.hSMul x y)).coeff a) ((Finset.VAddAntidiagonal ⋯ hs a).sum fun ij => HSMul.hSMul (x.coeff ij.1) (((HahnModule.of R).symm y).coeff ij.2))","decl":"theorem coeff_smul_right [SMulZeroClass R V] {x : HahnSeries Γ R} {y : HahnModule Γ' R V} {a : Γ'}\n    {s : Set Γ'} (hs : s.IsPWO) (hys : ((of R).symm y).support ⊆ s) :\n    ((of R).symm <| x • y).coeff a =\n      ∑ ij ∈ VAddAntidiagonal x.isPWO_support hs a,\n        x.coeff ij.fst • ((of R).symm y).coeff ij.snd := by\n  classical\n  rw [coeff_smul]\n  apply sum_subset_zero_on_sdiff (vaddAntidiagonal_mono_right hys) _ fun _ _ => rfl\n  intro b hb\n  simp only [not_and, mem_sdiff, mem_vaddAntidiagonal, HahnSeries.mem_support, not_imp_not] at hb\n  rw [hb.2 hb.1.1 hb.1.2.2, smul_zero]\n\n"}
{"name":"HahnModule.smul_coeff_right","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\ninst✝² : AddCommMonoid V\ninst✝¹ : Zero R\ninst✝ : SMulZeroClass R V\nx : HahnSeries Γ R\ny : HahnModule Γ' R V\na : Γ'\ns : Set Γ'\nhs : s.IsPWO\nhys : HasSubset.Subset ((HahnModule.of R).symm y).support s\n⊢ Eq (((HahnModule.of R).symm (HSMul.hSMul x y)).coeff a) ((Finset.VAddAntidiagonal ⋯ hs a).sum fun ij => HSMul.hSMul (x.coeff ij.1) (((HahnModule.of R).symm y).coeff ij.2))","decl":"@[deprecated (since := \"2025-01-31\")] alias smul_coeff_right := coeff_smul_right\n\n"}
{"name":"HahnModule.coeff_smul_left","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\ninst✝² : AddCommMonoid V\ninst✝¹ : Zero R\ninst✝ : SMulWithZero R V\nx : HahnSeries Γ R\ny : HahnModule Γ' R V\na : Γ'\ns : Set Γ\nhs : s.IsPWO\nhxs : HasSubset.Subset x.support s\n⊢ Eq (((HahnModule.of R).symm (HSMul.hSMul x y)).coeff a) ((Finset.VAddAntidiagonal hs ⋯ a).sum fun ij => HSMul.hSMul (x.coeff ij.1) (((HahnModule.of R).symm y).coeff ij.2))","decl":"theorem coeff_smul_left [SMulWithZero R V] {x : HahnSeries Γ R}\n    {y : HahnModule Γ' R V} {a : Γ'} {s : Set Γ}\n    (hs : s.IsPWO) (hxs : x.support ⊆ s) :\n    ((of R).symm <| x • y).coeff a =\n      ∑ ij ∈ VAddAntidiagonal hs ((of R).symm y).isPWO_support a,\n        x.coeff ij.fst • ((of R).symm y).coeff ij.snd := by\n  classical\n  rw [coeff_smul]\n  apply sum_subset_zero_on_sdiff (vaddAntidiagonal_mono_left hxs) _ fun _ _ => rfl\n  intro b hb\n  simp only [not_and', mem_sdiff, mem_vaddAntidiagonal, HahnSeries.mem_support, not_ne_iff] at hb\n  rw [hb.2 ⟨hb.1.2.1, hb.1.2.2⟩, zero_smul]\n\n"}
{"name":"HahnModule.smul_coeff_left","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\ninst✝² : AddCommMonoid V\ninst✝¹ : Zero R\ninst✝ : SMulWithZero R V\nx : HahnSeries Γ R\ny : HahnModule Γ' R V\na : Γ'\ns : Set Γ\nhs : s.IsPWO\nhxs : HasSubset.Subset x.support s\n⊢ Eq (((HahnModule.of R).symm (HSMul.hSMul x y)).coeff a) ((Finset.VAddAntidiagonal hs ⋯ a).sum fun ij => HSMul.hSMul (x.coeff ij.1) (((HahnModule.of R).symm y).coeff ij.2))","decl":"@[deprecated (since := \"2025-01-31\")] alias smul_coeff_left := coeff_smul_left\n\n"}
{"name":"HahnModule.smul_add","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\ninst✝² : AddCommMonoid V\ninst✝¹ : Zero R\ninst✝ : DistribSMul R V\nx : HahnSeries Γ R\ny z : HahnModule Γ' R V\n⊢ Eq (HSMul.hSMul x (HAdd.hAdd y z)) (HAdd.hAdd (HSMul.hSMul x y) (HSMul.hSMul x z))","decl":"theorem smul_add [Zero R] [DistribSMul R V] (x : HahnSeries Γ R) (y z : HahnModule Γ' R V) :\n    x • (y + z) = x • y + x • z := by\n  ext k\n  have hwf := ((of R).symm y).isPWO_support.union ((of R).symm z).isPWO_support\n  rw [coeff_smul_right hwf, of_symm_add]\n  · simp_all only [HahnSeries.coeff_add', Pi.add_apply, smul_add, of_symm_add]\n    rw [coeff_smul_right hwf Set.subset_union_right,\n      coeff_smul_right hwf Set.subset_union_left]\n    simp_all [sum_add_distrib]\n  · intro b\n    simp_all only [Set.isPWO_union, HahnSeries.isPWO_support, and_self, of_symm_add,\n      HahnSeries.coeff_add', Pi.add_apply, ne_eq, Set.mem_union, HahnSeries.mem_support]\n    contrapose!\n    intro h\n    rw [h.1, h.2, add_zero]\n\n"}
{"name":"HahnModule.add_smul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\ninst✝² : AddCommMonoid V\ninst✝¹ : AddCommMonoid R\ninst✝ : SMulWithZero R V\nx y : HahnSeries Γ R\nz : HahnModule Γ' R V\nh : ∀ (r s : R) (u : V), Eq (HSMul.hSMul (HAdd.hAdd r s) u) (HAdd.hAdd (HSMul.hSMul r u) (HSMul.hSMul s u))\n⊢ Eq (HSMul.hSMul (HAdd.hAdd x y) z) (HAdd.hAdd (HSMul.hSMul x z) (HSMul.hSMul y z))","decl":"theorem add_smul [AddCommMonoid R] [SMulWithZero R V] {x y : HahnSeries Γ R}\n    {z : HahnModule Γ' R V} (h : ∀ (r s : R) (u : V), (r + s) • u = r • u + s • u) :\n    (x + y) • z = x • z + y • z := by\n  ext a\n  have hwf := x.isPWO_support.union y.isPWO_support\n  rw [coeff_smul_left hwf, HahnSeries.coeff_add', of_symm_add]\n  · simp_all only [Pi.add_apply, HahnSeries.coeff_add']\n    rw [coeff_smul_left hwf Set.subset_union_right,\n      coeff_smul_left hwf Set.subset_union_left]\n    simp only [HahnSeries.coeff_add, h, sum_add_distrib]\n  · intro b\n    simp_all only [Set.isPWO_union, HahnSeries.isPWO_support, and_self, HahnSeries.mem_support,\n      HahnSeries.coeff_add, ne_eq, Set.mem_union, Set.mem_setOf_eq, mem_support]\n    contrapose!\n    intro h\n    rw [h.1, h.2, add_zero]\n\n"}
{"name":"HahnModule.coeff_single_smul_vadd","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\ninst✝² : AddCommMonoid V\ninst✝¹ : MulZeroClass R\ninst✝ : SMulWithZero R V\nr : R\nx : HahnModule Γ' R V\na : Γ'\nb : Γ\n⊢ Eq (((HahnModule.of R).symm (HSMul.hSMul ((HahnSeries.single b) r) x)).coeff (HVAdd.hVAdd b a)) (HSMul.hSMul r (((HahnModule.of R).symm x).coeff a))","decl":"theorem coeff_single_smul_vadd [MulZeroClass R] [SMulWithZero R V] {r : R} {x : HahnModule Γ' R V}\n    {a : Γ'} {b : Γ} :\n    ((of R).symm (HahnSeries.single b r • x)).coeff (b +ᵥ a) = r • ((of R).symm x).coeff a := by\n  by_cases hr : r = 0\n  · simp_all only [map_zero, zero_smul, coeff_smul, HahnSeries.support_zero, HahnSeries.coeff_zero,\n    sum_const_zero]\n  simp only [hr, coeff_smul, coeff_smul, HahnSeries.support_single_of_ne, ne_eq, not_false_iff,\n    smul_eq_mul]\n  by_cases hx : ((of R).symm x).coeff a = 0\n  · simp only [hx, smul_zero]\n    rw [sum_congr _ fun _ _ => rfl, sum_empty]\n    ext ⟨a1, a2⟩\n    simp only [not_mem_empty, not_and, Set.mem_singleton_iff, Classical.not_not,\n      mem_vaddAntidiagonal, Set.mem_setOf_eq, iff_false]\n    rintro rfl h2 h1\n    rw [IsCancelVAdd.left_cancel a1 a2 a h1] at h2\n    exact h2 hx\n  trans ∑ ij ∈ {(b, a)},\n    (HahnSeries.single b r).coeff ij.fst • ((of R).symm x).coeff ij.snd\n  · apply sum_congr _ fun _ _ => rfl\n    ext ⟨a1, a2⟩\n    simp only [Set.mem_singleton_iff, Prod.mk.inj_iff, mem_vaddAntidiagonal, mem_singleton,\n      Set.mem_setOf_eq]\n    constructor\n    · rintro ⟨rfl, _, h1⟩\n      exact ⟨rfl, IsCancelVAdd.left_cancel a1 a2 a h1⟩\n    · rintro ⟨rfl, rfl⟩\n      exact ⟨rfl, by exact hx, rfl⟩\n  · simp\n\n"}
{"name":"HahnModule.single_smul_coeff_add","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\ninst✝² : AddCommMonoid V\ninst✝¹ : MulZeroClass R\ninst✝ : SMulWithZero R V\nr : R\nx : HahnModule Γ' R V\na : Γ'\nb : Γ\n⊢ Eq (((HahnModule.of R).symm (HSMul.hSMul ((HahnSeries.single b) r) x)).coeff (HVAdd.hVAdd b a)) (HSMul.hSMul r (((HahnModule.of R).symm x).coeff a))","decl":"@[deprecated (since := \"2025-01-31\")] alias single_smul_coeff_add := coeff_single_smul_vadd\n\n"}
{"name":"HahnModule.coeff_single_zero_smul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ'\ninst✝⁵ : AddCommMonoid V\nΓ : Type u_6\ninst✝⁴ : OrderedAddCommMonoid Γ\ninst✝³ : AddAction Γ Γ'\ninst✝² : IsOrderedCancelVAdd Γ Γ'\ninst✝¹ : MulZeroClass R\ninst✝ : SMulWithZero R V\nr : R\nx : HahnModule Γ' R V\na : Γ'\n⊢ Eq (((HahnModule.of R).symm (HSMul.hSMul ((HahnSeries.single 0) r) x)).coeff a) (HSMul.hSMul r (((HahnModule.of R).symm x).coeff a))","decl":"theorem coeff_single_zero_smul {Γ} [OrderedAddCommMonoid Γ] [AddAction Γ Γ']\n    [IsOrderedCancelVAdd Γ Γ'] [MulZeroClass R] [SMulWithZero R V] {r : R}\n    {x : HahnModule Γ' R V} {a : Γ'} :\n    ((of R).symm ((HahnSeries.single 0 r : HahnSeries Γ R) • x)).coeff a =\n    r • ((of R).symm x).coeff a := by\n  nth_rw 1 [← zero_vadd Γ a]\n  exact coeff_single_smul_vadd\n\n"}
{"name":"HahnModule.single_zero_smul_coeff","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ'\ninst✝⁵ : AddCommMonoid V\nΓ : Type u_6\ninst✝⁴ : OrderedAddCommMonoid Γ\ninst✝³ : AddAction Γ Γ'\ninst✝² : IsOrderedCancelVAdd Γ Γ'\ninst✝¹ : MulZeroClass R\ninst✝ : SMulWithZero R V\nr : R\nx : HahnModule Γ' R V\na : Γ'\n⊢ Eq (((HahnModule.of R).symm (HSMul.hSMul ((HahnSeries.single 0) r) x)).coeff a) (HSMul.hSMul r (((HahnModule.of R).symm x).coeff a))","decl":"@[deprecated (since := \"2025-01-31\")] alias single_zero_smul_coeff := coeff_single_zero_smul\n\n"}
{"name":"HahnModule.single_zero_smul_eq_smul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ'\ninst✝⁵ : AddCommMonoid V\nΓ : Type u_6\ninst✝⁴ : OrderedAddCommMonoid Γ\ninst✝³ : AddAction Γ Γ'\ninst✝² : IsOrderedCancelVAdd Γ Γ'\ninst✝¹ : MulZeroClass R\ninst✝ : SMulWithZero R V\nr : R\nx : HahnModule Γ' R V\n⊢ Eq (HSMul.hSMul ((HahnSeries.single 0) r) x) (HSMul.hSMul r x)","decl":"@[simp]\ntheorem single_zero_smul_eq_smul (Γ) [OrderedAddCommMonoid Γ] [AddAction Γ Γ']\n    [IsOrderedCancelVAdd Γ Γ'] [MulZeroClass R] [SMulWithZero R V] {r : R}\n    {x : HahnModule Γ' R V} :\n    (HahnSeries.single (0 : Γ) r) • x = r • x := by\n  ext\n  exact coeff_single_zero_smul\n\n"}
{"name":"HahnModule.zero_smul'","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\ninst✝² : AddCommMonoid V\ninst✝¹ : Zero R\ninst✝ : SMulWithZero R V\nx : HahnModule Γ' R V\n⊢ Eq (HSMul.hSMul 0 x) 0","decl":"@[simp]\ntheorem zero_smul' [Zero R] [SMulWithZero R V] {x : HahnModule Γ' R V} :\n    (0 : HahnSeries Γ R) • x = 0 := by\n  ext\n  simp [coeff_smul]\n\n"}
{"name":"HahnModule.one_smul'","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ'\ninst✝⁵ : AddCommMonoid V\nΓ : Type u_6\ninst✝⁴ : OrderedAddCommMonoid Γ\ninst✝³ : AddAction Γ Γ'\ninst✝² : IsOrderedCancelVAdd Γ Γ'\ninst✝¹ : MonoidWithZero R\ninst✝ : MulActionWithZero R V\nx : HahnModule Γ' R V\n⊢ Eq (HSMul.hSMul 1 x) x","decl":"@[simp]\ntheorem one_smul' {Γ} [OrderedAddCommMonoid Γ] [AddAction Γ Γ'] [IsOrderedCancelVAdd Γ Γ']\n    [MonoidWithZero R] [MulActionWithZero R V] {x : HahnModule Γ' R V} :\n    (1 : HahnSeries Γ R) • x = x := by\n  ext g\n  exact coeff_single_zero_smul.trans (one_smul R (x.coeff g))\n\n"}
{"name":"HahnModule.support_smul_subset_vadd_support'","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\ninst✝² : AddCommMonoid V\ninst✝¹ : MulZeroClass R\ninst✝ : SMulWithZero R V\nx : HahnSeries Γ R\ny : HahnModule Γ' R V\n⊢ HasSubset.Subset ((HahnModule.of R).symm (HSMul.hSMul x y)).support (HVAdd.hVAdd x.support ((HahnModule.of R).symm y).support)","decl":"theorem support_smul_subset_vadd_support' [MulZeroClass R] [SMulWithZero R V] {x : HahnSeries Γ R}\n    {y : HahnModule Γ' R V} :\n    ((of R).symm (x • y)).support ⊆ x.support +ᵥ ((of R).symm y).support := by\n  apply Set.Subset.trans (fun x hx => _) support_vaddAntidiagonal_subset_vadd\n  · exact x.isPWO_support\n  · exact y.isPWO_support\n  intro x hx\n  contrapose! hx\n  simp only [Set.mem_setOf_eq, not_nonempty_iff_eq_empty] at hx\n  simp [hx, coeff_smul]\n\n"}
{"name":"HahnModule.support_smul_subset_vadd_support","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\nV : Type u_5\ninst✝⁶ : PartialOrder Γ\ninst✝⁵ : PartialOrder Γ'\ninst✝⁴ : VAdd Γ Γ'\ninst✝³ : IsOrderedCancelVAdd Γ Γ'\ninst✝² : AddCommMonoid V\ninst✝¹ : MulZeroClass R\ninst✝ : SMulWithZero R V\nx : HahnSeries Γ R\ny : HahnModule Γ' R V\n⊢ HasSubset.Subset ((HahnModule.of R).symm (HSMul.hSMul x y)).support (HVAdd.hVAdd x.support ((HahnModule.of R).symm y).support)","decl":"theorem support_smul_subset_vadd_support [MulZeroClass R] [SMulWithZero R V] {x : HahnSeries Γ R}\n    {y : HahnModule Γ' R V} :\n    ((of R).symm (x • y)).support ⊆ x.support +ᵥ ((of R).symm y).support := by\n  have h : x.support +ᵥ ((of R).symm y).support =\n      x.support +ᵥ ((of R).symm y).support := by\n    exact rfl\n  rw [h]\n  exact support_smul_subset_vadd_support'\n\n"}
{"name":"HahnModule.coeff_smul_order_add_order","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"R : Type u_3\nV : Type u_5\ninst✝³ : AddCommMonoid V\nΓ : Type u_6\ninst✝² : LinearOrderedCancelAddCommMonoid Γ\ninst✝¹ : Zero R\ninst✝ : SMulWithZero R V\nx : HahnSeries Γ R\ny : HahnModule Γ R V\n⊢ Eq (((HahnModule.of R).symm (HSMul.hSMul x y)).coeff (HAdd.hAdd x.order ((HahnModule.of R).symm y).order)) (HSMul.hSMul x.leadingCoeff ((HahnModule.of R).symm y).leadingCoeff)","decl":"theorem coeff_smul_order_add_order {Γ} [LinearOrderedCancelAddCommMonoid Γ] [Zero R]\n    [SMulWithZero R V] (x : HahnSeries Γ R) (y : HahnModule Γ R V) :\n    ((of R).symm (x • y)).coeff (x.order + ((of R).symm y).order) =\n    x.leadingCoeff • ((of R).symm y).leadingCoeff := by\n  by_cases hx : x = (0 : HahnSeries Γ R); · simp [HahnSeries.coeff_zero, hx]\n  by_cases hy : (of R).symm y = 0; · simp [hy, coeff_smul]\n  rw [HahnSeries.order_of_ne hx, HahnSeries.order_of_ne hy, coeff_smul,\n    HahnSeries.leadingCoeff_of_ne hx, HahnSeries.leadingCoeff_of_ne hy]\n  erw [Finset.vaddAntidiagonal_min_vadd_min, Finset.sum_singleton]\n\n"}
{"name":"HahnModule.smul_coeff_order_add_order","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"R : Type u_3\nV : Type u_5\ninst✝³ : AddCommMonoid V\nΓ : Type u_6\ninst✝² : LinearOrderedCancelAddCommMonoid Γ\ninst✝¹ : Zero R\ninst✝ : SMulWithZero R V\nx : HahnSeries Γ R\ny : HahnModule Γ R V\n⊢ Eq (((HahnModule.of R).symm (HSMul.hSMul x y)).coeff (HAdd.hAdd x.order ((HahnModule.of R).symm y).order)) (HSMul.hSMul x.leadingCoeff ((HahnModule.of R).symm y).leadingCoeff)","decl":"@[deprecated (since := \"2025-01-31\")] alias smul_coeff_order_add_order := coeff_smul_order_add_order\n\n"}
{"name":"HahnSeries.of_symm_smul_of_eq_mul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nx y : HahnSeries Γ R\n⊢ Eq ((HahnModule.of R).symm (HSMul.hSMul x ((HahnModule.of R) y))) (HMul.hMul x y)","decl":"theorem of_symm_smul_of_eq_mul [NonUnitalNonAssocSemiring R] {x y : HahnSeries Γ R} :\n    (HahnModule.of R).symm (x • HahnModule.of R y) = x * y := rfl\n\n"}
{"name":"HahnSeries.coeff_mul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nx y : HahnSeries Γ R\na : Γ\n⊢ Eq ((HMul.hMul x y).coeff a) ((Finset.addAntidiagonal ⋯ ⋯ a).sum fun ij => HMul.hMul (x.coeff ij.1) (y.coeff ij.2))","decl":"theorem coeff_mul [NonUnitalNonAssocSemiring R] {x y : HahnSeries Γ R} {a : Γ} :\n    (x * y).coeff a =\n      ∑ ij ∈ addAntidiagonal x.isPWO_support y.isPWO_support a, x.coeff ij.fst * y.coeff ij.snd :=\n  rfl\n\n"}
{"name":"HahnSeries.mul_coeff","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nx y : HahnSeries Γ R\na : Γ\n⊢ Eq ((HMul.hMul x y).coeff a) ((Finset.addAntidiagonal ⋯ ⋯ a).sum fun ij => HMul.hMul (x.coeff ij.1) (y.coeff ij.2))","decl":"@[deprecated (since := \"2025-01-31\")] alias mul_coeff := coeff_mul\n\n"}
{"name":"HahnSeries.map_mul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝² : OrderedCancelAddCommMonoid Γ\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf : NonUnitalRingHom R S\nx y : HahnSeries Γ R\n⊢ Eq ((HMul.hMul x y).map f) (HMul.hMul (x.map f) (y.map f))","decl":"protected lemma map_mul [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S] (f : R →ₙ+* S)\n    {x y : HahnSeries Γ R} : (x * y).map f = (x.map f : HahnSeries Γ S) * (y.map f) := by\n  ext\n  simp only [map_coeff, coeff_mul, ZeroHom.coe_coe, map_sum, map_mul]\n  refine Eq.symm (sum_subset (fun gh hgh => ?_) (fun gh hgh hz => ?_))\n  · simp_all only [mem_addAntidiagonal, mem_support, map_coeff, ZeroHom.coe_coe, ne_eq, and_true]\n    exact ⟨fun h => hgh.1 (map_zero f ▸ congrArg f h), fun h => hgh.2.1 (map_zero f ▸ congrArg f h)⟩\n  · simp_all only [mem_addAntidiagonal, mem_support, ne_eq, map_coeff, ZeroHom.coe_coe, and_true,\n      not_and, not_not]\n    by_cases h : f (x.coeff gh.1) = 0\n    · exact mul_eq_zero_of_left h (f (y.coeff gh.2))\n    · exact mul_eq_zero_of_right (f (x.coeff gh.1)) (hz h)\n\n"}
{"name":"HahnSeries.coeff_mul_left'","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nx y : HahnSeries Γ R\na : Γ\ns : Set Γ\nhs : s.IsPWO\nhxs : HasSubset.Subset x.support s\n⊢ Eq ((HMul.hMul x y).coeff a) ((Finset.addAntidiagonal hs ⋯ a).sum fun ij => HMul.hMul (x.coeff ij.1) (y.coeff ij.2))","decl":"theorem coeff_mul_left' [NonUnitalNonAssocSemiring R] {x y : HahnSeries Γ R} {a : Γ} {s : Set Γ}\n    (hs : s.IsPWO) (hxs : x.support ⊆ s) :\n    (x * y).coeff a =\n      ∑ ij ∈ addAntidiagonal hs y.isPWO_support a, x.coeff ij.fst * y.coeff ij.snd :=\n  HahnModule.coeff_smul_left hs hxs\n\n"}
{"name":"HahnSeries.mul_coeff_left'","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nx y : HahnSeries Γ R\na : Γ\ns : Set Γ\nhs : s.IsPWO\nhxs : HasSubset.Subset x.support s\n⊢ Eq ((HMul.hMul x y).coeff a) ((Finset.addAntidiagonal hs ⋯ a).sum fun ij => HMul.hMul (x.coeff ij.1) (y.coeff ij.2))","decl":"@[deprecated (since := \"2025-01-31\")] alias mul_coeff_left' := coeff_mul_left'\n\n"}
{"name":"HahnSeries.coeff_mul_right'","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nx y : HahnSeries Γ R\na : Γ\ns : Set Γ\nhs : s.IsPWO\nhys : HasSubset.Subset y.support s\n⊢ Eq ((HMul.hMul x y).coeff a) ((Finset.addAntidiagonal ⋯ hs a).sum fun ij => HMul.hMul (x.coeff ij.1) (y.coeff ij.2))","decl":"theorem coeff_mul_right' [NonUnitalNonAssocSemiring R] {x y : HahnSeries Γ R} {a : Γ} {s : Set Γ}\n    (hs : s.IsPWO) (hys : y.support ⊆ s) :\n    (x * y).coeff a =\n      ∑ ij ∈ addAntidiagonal x.isPWO_support hs a, x.coeff ij.fst * y.coeff ij.snd :=\n  HahnModule.coeff_smul_right hs hys\n\n"}
{"name":"HahnSeries.mul_coeff_right'","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nx y : HahnSeries Γ R\na : Γ\ns : Set Γ\nhs : s.IsPWO\nhys : HasSubset.Subset y.support s\n⊢ Eq ((HMul.hMul x y).coeff a) ((Finset.addAntidiagonal ⋯ hs a).sum fun ij => HMul.hMul (x.coeff ij.1) (y.coeff ij.2))","decl":"@[deprecated (since := \"2025-01-31\")] alias mul_coeff_right' := coeff_mul_right'\n\n"}
{"name":"HahnSeries.coeff_single_mul_add","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries Γ R\na b : Γ\n⊢ Eq ((HMul.hMul ((HahnSeries.single b) r) x).coeff (HAdd.hAdd a b)) (HMul.hMul r (x.coeff a))","decl":"theorem coeff_single_mul_add [NonUnitalNonAssocSemiring R] {r : R} {x : HahnSeries Γ R} {a : Γ}\n    {b : Γ} : (single b r * x).coeff (a + b) = r * x.coeff a := by\n  rw [← of_symm_smul_of_eq_mul, add_comm, ← vadd_eq_add]\n  exact HahnModule.coeff_single_smul_vadd\n\n"}
{"name":"HahnSeries.single_mul_coeff_add","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries Γ R\na b : Γ\n⊢ Eq ((HMul.hMul ((HahnSeries.single b) r) x).coeff (HAdd.hAdd a b)) (HMul.hMul r (x.coeff a))","decl":"@[deprecated (since := \"2025-01-31\")] alias single_mul_coeff_add := coeff_single_mul_add\n\n"}
{"name":"HahnSeries.coeff_mul_single_add","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries Γ R\na b : Γ\n⊢ Eq ((HMul.hMul x ((HahnSeries.single b) r)).coeff (HAdd.hAdd a b)) (HMul.hMul (x.coeff a) r)","decl":"theorem coeff_mul_single_add [NonUnitalNonAssocSemiring R] {r : R} {x : HahnSeries Γ R} {a : Γ}\n    {b : Γ} : (x * single b r).coeff (a + b) = x.coeff a * r := by\n  by_cases hr : r = 0\n  · simp [hr, coeff_mul]\n  simp only [hr, coeff_smul, coeff_mul, support_single_of_ne, Ne, not_false_iff, smul_eq_mul]\n  by_cases hx : x.coeff a = 0\n  · simp only [hx, zero_mul]\n    rw [sum_congr _ fun _ _ => rfl, sum_empty]\n    ext ⟨a1, a2⟩\n    simp only [not_mem_empty, not_and, Set.mem_singleton_iff, Classical.not_not,\n      mem_addAntidiagonal, Set.mem_setOf_eq, iff_false]\n    rintro h2 rfl h1\n    rw [← add_right_cancel h1] at hx\n    exact h2 hx\n  trans ∑ ij ∈ {(a, b)}, x.coeff ij.fst * (single b r).coeff ij.snd\n  · apply sum_congr _ fun _ _ => rfl\n    ext ⟨a1, a2⟩\n    simp only [Set.mem_singleton_iff, Prod.mk.inj_iff, mem_addAntidiagonal, mem_singleton,\n      Set.mem_setOf_eq]\n    constructor\n    · rintro ⟨_, rfl, h1⟩\n      exact ⟨add_right_cancel h1, rfl⟩\n    · rintro ⟨rfl, rfl⟩\n      simp [hx]\n  · simp\n\n"}
{"name":"HahnSeries.mul_single_coeff_add","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries Γ R\na b : Γ\n⊢ Eq ((HMul.hMul x ((HahnSeries.single b) r)).coeff (HAdd.hAdd a b)) (HMul.hMul (x.coeff a) r)","decl":"@[deprecated (since := \"2025-01-31\")] alias mul_single_coeff_add := coeff_mul_single_add\n\n"}
{"name":"HahnSeries.coeff_mul_single_zero","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries Γ R\na : Γ\n⊢ Eq ((HMul.hMul x ((HahnSeries.single 0) r)).coeff a) (HMul.hMul (x.coeff a) r)","decl":"@[simp]\ntheorem coeff_mul_single_zero [NonUnitalNonAssocSemiring R] {r : R} {x : HahnSeries Γ R} {a : Γ} :\n    (x * single 0 r).coeff a = x.coeff a * r := by rw [← add_zero a, coeff_mul_single_add, add_zero]\n\n"}
{"name":"HahnSeries.mul_single_zero_coeff","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries Γ R\na : Γ\n⊢ Eq ((HMul.hMul x ((HahnSeries.single 0) r)).coeff a) (HMul.hMul (x.coeff a) r)","decl":"@[deprecated (since := \"2025-01-31\")] alias mul_single_zero_coeff := coeff_mul_single_zero\n\n"}
{"name":"HahnSeries.coeff_single_zero_mul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries Γ R\na : Γ\n⊢ Eq ((HMul.hMul ((HahnSeries.single 0) r) x).coeff a) (HMul.hMul r (x.coeff a))","decl":"theorem coeff_single_zero_mul [NonUnitalNonAssocSemiring R] {r : R} {x : HahnSeries Γ R} {a : Γ} :\n    ((single 0 r : HahnSeries Γ R) * x).coeff a = r * x.coeff a := by\n  rw [← add_zero a, coeff_single_mul_add, add_zero]\n\n"}
{"name":"HahnSeries.single_zero_mul_coeff","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries Γ R\na : Γ\n⊢ Eq ((HMul.hMul ((HahnSeries.single 0) r) x).coeff a) (HMul.hMul r (x.coeff a))","decl":"@[deprecated (since := \"2025-01-31\")] alias single_zero_mul_coeff := coeff_single_zero_mul\n\n"}
{"name":"HahnSeries.single_zero_mul_eq_smul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\nr : R\nx : HahnSeries Γ R\n⊢ Eq (HMul.hMul ((HahnSeries.single 0) r) x) (HSMul.hSMul r x)","decl":"@[simp]\ntheorem single_zero_mul_eq_smul [Semiring R] {r : R} {x : HahnSeries Γ R} :\n    single 0 r * x = r • x := by\n  ext\n  exact coeff_single_zero_mul\n\n"}
{"name":"HahnSeries.support_mul_subset_add_support","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nx y : HahnSeries Γ R\n⊢ HasSubset.Subset (HMul.hMul x y).support (HAdd.hAdd x.support y.support)","decl":"theorem support_mul_subset_add_support [NonUnitalNonAssocSemiring R] {x y : HahnSeries Γ R} :\n    support (x * y) ⊆ support x + support y := by\n  rw [← of_symm_smul_of_eq_mul, ← vadd_eq_add]\n  exact HahnModule.support_smul_subset_vadd_support\n\n"}
{"name":"HahnSeries.coeff_mul_order_add_order","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"R : Type u_3\nΓ : Type u_6\ninst✝¹ : LinearOrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nx y : HahnSeries Γ R\n⊢ Eq ((HMul.hMul x y).coeff (HAdd.hAdd x.order y.order)) (HMul.hMul x.leadingCoeff y.leadingCoeff)","decl":"theorem coeff_mul_order_add_order {Γ} [LinearOrderedCancelAddCommMonoid Γ]\n    [NonUnitalNonAssocSemiring R] (x y : HahnSeries Γ R) :\n    (x * y).coeff (x.order + y.order) = x.leadingCoeff * y.leadingCoeff := by\n  simp only [← of_symm_smul_of_eq_mul]\n  exact HahnModule.coeff_smul_order_add_order x y\n\n"}
{"name":"HahnSeries.mul_coeff_order_add_order","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"R : Type u_3\nΓ : Type u_6\ninst✝¹ : LinearOrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nx y : HahnSeries Γ R\n⊢ Eq ((HMul.hMul x y).coeff (HAdd.hAdd x.order y.order)) (HMul.hMul x.leadingCoeff y.leadingCoeff)","decl":"@[deprecated (since := \"2025-01-31\")] alias mul_coeff_order_add_order := coeff_mul_order_add_order\n\n"}
{"name":"HahnModule.instNoZeroSMulDivisors","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"R : Type u_3\nV : Type u_5\ninst✝⁴ : AddCommMonoid V\nΓ : Type u_6\ninst✝³ : LinearOrderedCancelAddCommMonoid Γ\ninst✝² : Zero R\ninst✝¹ : SMulWithZero R V\ninst✝ : NoZeroSMulDivisors R V\n⊢ NoZeroSMulDivisors (HahnSeries Γ R) (HahnModule Γ R V)","decl":"instance instNoZeroSMulDivisors {Γ} [LinearOrderedCancelAddCommMonoid Γ] [Zero R]\n    [SMulWithZero R V] [NoZeroSMulDivisors R V] :\n    NoZeroSMulDivisors (HahnSeries Γ R) (HahnModule Γ R V) where\n  eq_zero_or_eq_zero_of_smul_eq_zero {x y} hxy := by\n    contrapose! hxy\n    simp only [ne_eq]\n    rw [HahnModule.ext_iff, funext_iff, not_forall]\n    refine ⟨x.order + ((of R).symm y).order, ?_⟩\n    rw [coeff_smul_order_add_order x y, of_symm_zero, HahnSeries.coeff_zero, smul_eq_zero, not_or]\n    constructor\n    · exact HahnSeries.leadingCoeff_ne_iff.mpr hxy.1\n    · exact HahnSeries.leadingCoeff_ne_iff.mpr hxy.2\n\n"}
{"name":"HahnSeries.instNoZeroDivisors","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"R : Type u_3\nΓ : Type u_6\ninst✝² : LinearOrderedCancelAddCommMonoid Γ\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NoZeroDivisors R\n⊢ NoZeroDivisors (HahnSeries Γ R)","decl":"instance {Γ} [LinearOrderedCancelAddCommMonoid Γ] [NonUnitalNonAssocSemiring R] [NoZeroDivisors R] :\n    NoZeroDivisors (HahnSeries Γ R) where\n    eq_zero_or_eq_zero_of_mul_eq_zero {x y} xy := by\n      haveI : NoZeroSMulDivisors (HahnSeries Γ R) (HahnSeries Γ R) :=\n        HahnModule.instNoZeroSMulDivisors\n      exact eq_zero_or_eq_zero_of_smul_eq_zero xy\n\n"}
{"name":"HahnSeries.instIsDomain","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"R : Type u_3\nΓ : Type u_6\ninst✝² : LinearOrderedCancelAddCommMonoid Γ\ninst✝¹ : Ring R\ninst✝ : IsDomain R\n⊢ IsDomain (HahnSeries Γ R)","decl":"instance {Γ} [LinearOrderedCancelAddCommMonoid Γ] [Ring R] [IsDomain R] :\n    IsDomain (HahnSeries Γ R) :=\n  NoZeroDivisors.to_isDomain _\n\n"}
{"name":"HahnSeries.orderTop_add_orderTop_le_orderTop_mul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"R : Type u_3\nΓ : Type u_6\ninst✝¹ : LinearOrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\nx y : HahnSeries Γ R\n⊢ LE.le (HAdd.hAdd x.orderTop y.orderTop) (HMul.hMul x y).orderTop","decl":"theorem orderTop_add_orderTop_le_orderTop_mul {Γ} [LinearOrderedCancelAddCommMonoid Γ]\n    [NonUnitalNonAssocSemiring R] {x y : HahnSeries Γ R} :\n    x.orderTop + y.orderTop ≤ (x * y).orderTop := by\n  by_cases hx : x = 0; · simp [hx]\n  by_cases hy : y = 0; · simp [hy]\n  by_cases hxy : x * y = 0\n  · simp [hxy]\n  rw [orderTop_of_ne hx, orderTop_of_ne hy, orderTop_of_ne hxy, ← WithTop.coe_add,\n    WithTop.coe_le_coe, ← Set.IsWF.min_add]\n  exact Set.IsWF.min_le_min_of_subset support_mul_subset_add_support\n\n"}
{"name":"HahnSeries.order_mul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"R : Type u_3\nΓ : Type u_6\ninst✝² : LinearOrderedCancelAddCommMonoid Γ\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NoZeroDivisors R\nx y : HahnSeries Γ R\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (HMul.hMul x y).order (HAdd.hAdd x.order y.order)","decl":"@[simp]\ntheorem order_mul {Γ} [LinearOrderedCancelAddCommMonoid Γ] [NonUnitalNonAssocSemiring R]\n    [NoZeroDivisors R] {x y : HahnSeries Γ R} (hx : x ≠ 0) (hy : y ≠ 0) :\n    (x * y).order = x.order + y.order := by\n  apply le_antisymm\n  · apply order_le_of_coeff_ne_zero\n    rw [coeff_mul_order_add_order x y]\n    exact mul_ne_zero (leadingCoeff_ne_iff.mpr hx) (leadingCoeff_ne_iff.mpr hy)\n  · rw [order_of_ne hx, order_of_ne hy, order_of_ne (mul_ne_zero hx hy), ← Set.IsWF.min_add]\n    exact Set.IsWF.min_le_min_of_subset support_mul_subset_add_support\n\n"}
{"name":"HahnSeries.order_pow","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"R : Type u_3\nΓ : Type u_6\ninst✝² : LinearOrderedCancelAddCommMonoid Γ\ninst✝¹ : Semiring R\ninst✝ : NoZeroDivisors R\nx : HahnSeries Γ R\nn : Nat\n⊢ Eq (HPow.hPow x n).order (HSMul.hSMul n x.order)","decl":"@[simp]\ntheorem order_pow {Γ} [LinearOrderedCancelAddCommMonoid Γ] [Semiring R] [NoZeroDivisors R]\n    (x : HahnSeries Γ R) (n : ℕ) : (x ^ n).order = n • x.order := by\n  induction' n with h IH\n  · simp\n  rcases eq_or_ne x 0 with (rfl | hx)\n  · simp\n  rw [pow_succ, order_mul (pow_ne_zero _ hx) hx, succ_nsmul, IH]\n\n"}
{"name":"HahnSeries.single_mul_single","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonUnitalNonAssocSemiring R\na b : Γ\nr s : R\n⊢ Eq (HMul.hMul ((HahnSeries.single a) r) ((HahnSeries.single b) s)) ((HahnSeries.single (HAdd.hAdd a b)) (HMul.hMul r s))","decl":"@[simp]\ntheorem single_mul_single {a b : Γ} {r s : R} :\n    single a r * single b s = single (a + b) (r * s) := by\n  ext x\n  by_cases h : x = a + b\n  · rw [h, coeff_mul_single_add]\n    simp\n  · rw [coeff_single_of_ne h, coeff_mul, sum_eq_zero]\n    simp_rw [mem_addAntidiagonal]\n    rintro ⟨y, z⟩ ⟨hy, hz, rfl⟩\n    rw [eq_of_mem_support_single hy, eq_of_mem_support_single hz] at h\n    exact (h rfl).elim\n\n"}
{"name":"HahnSeries.single_pow","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\na : Γ\nn : Nat\nr : R\n⊢ Eq (HPow.hPow ((HahnSeries.single a) r) n) ((HahnSeries.single (HSMul.hSMul n a)) (HPow.hPow r n))","decl":"@[simp]\ntheorem single_pow (a : Γ) (n : ℕ) (r : R) : single a r ^ n = single (n • a) (r ^ n) := by\n  induction' n with n IH\n  · ext; simp only [pow_zero, coeff_one, zero_smul, coeff_single]\n  · rw [pow_succ, pow_succ, IH, single_mul_single, succ_nsmul]\n\n"}
{"name":"HahnSeries.C_apply","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonAssocSemiring R\na : R\n⊢ Eq (HahnSeries.C a) ((HahnSeries.single 0) a)","decl":"/-- `C a` is the constant Hahn Series `a`. `C` is provided as a ring homomorphism. -/\n@[simps]\ndef C : R →+* HahnSeries Γ R where\n  toFun := single 0\n  map_zero' := single_eq_zero\n  map_one' := rfl\n  map_add' x y := by\n    ext a\n    by_cases h : a = 0 <;> simp [h]\n  map_mul' x y := by rw [single_mul_single, zero_add]\n\n"}
{"name":"HahnSeries.C_zero","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonAssocSemiring R\n⊢ Eq (HahnSeries.C 0) 0","decl":"theorem C_zero : C (0 : R) = (0 : HahnSeries Γ R) :=\n  C.map_zero\n\n"}
{"name":"HahnSeries.C_one","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonAssocSemiring R\n⊢ Eq (HahnSeries.C 1) 1","decl":"theorem C_one : C (1 : R) = (1 : HahnSeries Γ R) :=\n  C.map_one\n\n"}
{"name":"HahnSeries.map_C","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝² : OrderedCancelAddCommMonoid Γ\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\na : R\nf : RingHom R S\n⊢ Eq ((HahnSeries.C a).map f) (HahnSeries.C (f a))","decl":"theorem map_C [NonAssocSemiring S] (a : R) (f : R →+* S) :\n    ((C a).map f : HahnSeries Γ S) = C (f a) := by\n  ext g\n  by_cases h : g = 0 <;> simp [h]\n\n"}
{"name":"HahnSeries.C_injective","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonAssocSemiring R\n⊢ Function.Injective ⇑HahnSeries.C","decl":"theorem C_injective : Function.Injective (C : R → HahnSeries Γ R) := by\n  intro r s rs\n  rw [HahnSeries.ext_iff, funext_iff] at rs\n  have h := rs 0\n  rwa [C_apply, coeff_single_same, C_apply, coeff_single_same] at h\n\n"}
{"name":"HahnSeries.C_ne_zero","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonAssocSemiring R\nr : R\nh : Ne r 0\n⊢ Ne (HahnSeries.C r) 0","decl":"theorem C_ne_zero {r : R} (h : r ≠ 0) : (C r : HahnSeries Γ R) ≠ 0 := by\n  contrapose! h\n  rw [← C_zero] at h\n  exact C_injective h\n\n"}
{"name":"HahnSeries.order_C","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : NonAssocSemiring R\nr : R\n⊢ Eq (HahnSeries.C r).order 0","decl":"theorem order_C {r : R} : order (C r : HahnSeries Γ R) = 0 := by\n  by_cases h : r = 0\n  · rw [h, C_zero, order_zero]\n  · exact order_single h\n\n"}
{"name":"HahnSeries.C_mul_eq_smul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : Semiring R\nr : R\nx : HahnSeries Γ R\n⊢ Eq (HMul.hMul (HahnSeries.C r) x) (HSMul.hSMul r x)","decl":"theorem C_mul_eq_smul {r : R} {x : HahnSeries Γ R} : C r * x = r • x :=\n  single_zero_mul_eq_smul\n\n"}
{"name":"HahnSeries.embDomain_mul","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : OrderedCancelAddCommMonoid Γ\nΓ' : Type u_6\ninst✝¹ : OrderedCancelAddCommMonoid Γ'\ninst✝ : NonUnitalNonAssocSemiring R\nf : OrderEmbedding Γ Γ'\nhf : ∀ (x y : Γ), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nx y : HahnSeries Γ R\n⊢ Eq (HahnSeries.embDomain f (HMul.hMul x y)) (HMul.hMul (HahnSeries.embDomain f x) (HahnSeries.embDomain f y))","decl":"theorem embDomain_mul [NonUnitalNonAssocSemiring R] (f : Γ ↪o Γ')\n    (hf : ∀ x y, f (x + y) = f x + f y) (x y : HahnSeries Γ R) :\n    embDomain f (x * y) = embDomain f x * embDomain f y := by\n  ext g\n  by_cases hg : g ∈ Set.range f\n  · obtain ⟨g, rfl⟩ := hg\n    simp only [coeff_mul, embDomain_coeff]\n    trans\n      ∑ ij ∈\n        (addAntidiagonal x.isPWO_support y.isPWO_support g).map\n          (f.toEmbedding.prodMap f.toEmbedding),\n        (embDomain f x).coeff ij.1 * (embDomain f y).coeff ij.2\n    · simp\n    apply sum_subset\n    · rintro ⟨i, j⟩ hij\n      simp only [exists_prop, mem_map, Prod.mk.inj_iff, mem_addAntidiagonal,\n        Function.Embedding.coe_prodMap, mem_support, Prod.exists] at hij\n      obtain ⟨i, j, ⟨hx, hy, rfl⟩, rfl, rfl⟩ := hij\n      simp [hx, hy, hf]\n    · rintro ⟨_, _⟩ h1 h2\n      contrapose! h2\n      obtain ⟨i, _, rfl⟩ := support_embDomain_subset (ne_zero_and_ne_zero_of_mul h2).1\n      obtain ⟨j, _, rfl⟩ := support_embDomain_subset (ne_zero_and_ne_zero_of_mul h2).2\n      simp only [exists_prop, mem_map, Prod.mk.inj_iff, mem_addAntidiagonal,\n        Function.Embedding.coe_prodMap, mem_support, Prod.exists]\n      simp only [mem_addAntidiagonal, embDomain_coeff, mem_support, ← hf,\n        OrderEmbedding.eq_iff_eq] at h1\n      exact ⟨i, j, h1, rfl⟩\n  · rw [embDomain_notin_range hg, eq_comm]\n    contrapose! hg\n    obtain ⟨_, hi, _, hj, rfl⟩ := support_mul_subset_add_support ((mem_support _ _).2 hg)\n    obtain ⟨i, _, rfl⟩ := support_embDomain_subset hi\n    obtain ⟨j, _, rfl⟩ := support_embDomain_subset hj\n    exact ⟨i + j, hf i j⟩\n\n"}
{"name":"HahnSeries.embDomain_one","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : OrderedCancelAddCommMonoid Γ\nΓ' : Type u_6\ninst✝¹ : OrderedCancelAddCommMonoid Γ'\ninst✝ : NonAssocSemiring R\nf : OrderEmbedding Γ Γ'\nhf : Eq (f 0) 0\n⊢ Eq (HahnSeries.embDomain f 1) 1","decl":"theorem embDomain_one [NonAssocSemiring R] (f : Γ ↪o Γ') (hf : f 0 = 0) :\n    embDomain f (1 : HahnSeries Γ R) = (1 : HahnSeries Γ' R) :=\n  embDomain_single.trans <| hf.symm ▸ rfl\n\n"}
{"name":"HahnSeries.embDomainRingHom_apply","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : OrderedCancelAddCommMonoid Γ\nΓ' : Type u_6\ninst✝¹ : OrderedCancelAddCommMonoid Γ'\ninst✝ : NonAssocSemiring R\nf : AddMonoidHom Γ Γ'\nhfi : Function.Injective ⇑f\nhf : ∀ (g g' : Γ), Iff (LE.le (f g) (f g')) (LE.le g g')\na✝ : HahnSeries Γ R\n⊢ Eq ((HahnSeries.embDomainRingHom f hfi hf) a✝) (HahnSeries.embDomain { toFun := ⇑f, inj' := hfi, map_rel_iff' := ⋯ } a✝)","decl":"/-- Extending the domain of Hahn series is a ring homomorphism. -/\n@[simps]\ndef embDomainRingHom [NonAssocSemiring R] (f : Γ →+ Γ') (hfi : Function.Injective f)\n    (hf : ∀ g g' : Γ, f g ≤ f g' ↔ g ≤ g') : HahnSeries Γ R →+* HahnSeries Γ' R where\n  toFun := embDomain ⟨⟨f, hfi⟩, hf _ _⟩\n  map_one' := embDomain_one _ f.map_zero\n  map_mul' := embDomain_mul _ f.map_add\n  map_zero' := embDomain_zero\n  map_add' := embDomain_add _\n\n"}
{"name":"HahnSeries.embDomainRingHom_C","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : OrderedCancelAddCommMonoid Γ\nΓ' : Type u_6\ninst✝¹ : OrderedCancelAddCommMonoid Γ'\ninst✝ : NonAssocSemiring R\nf : AddMonoidHom Γ Γ'\nhfi : Function.Injective ⇑f\nhf : ∀ (g g' : Γ), Iff (LE.le (f g) (f g')) (LE.le g g')\nr : R\n⊢ Eq ((HahnSeries.embDomainRingHom f hfi hf) (HahnSeries.C r)) (HahnSeries.C r)","decl":"theorem embDomainRingHom_C [NonAssocSemiring R] {f : Γ →+ Γ'} {hfi : Function.Injective f}\n    {hf : ∀ g g' : Γ, f g ≤ f g' ↔ g ≤ g'} {r : R} : embDomainRingHom f hfi hf (C r) = C r :=\n  embDomain_single.trans (by simp)\n\n"}
{"name":"HahnSeries.C_eq_algebraMap","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : OrderedCancelAddCommMonoid Γ\ninst✝ : CommSemiring R\n⊢ Eq HahnSeries.C (algebraMap R (HahnSeries Γ R))","decl":"theorem C_eq_algebraMap : C = algebraMap R (HahnSeries Γ R) :=\n  rfl\n\n"}
{"name":"HahnSeries.algebraMap_apply","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝³ : OrderedCancelAddCommMonoid Γ\ninst✝² : CommSemiring R\nA : Type u_6\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nr : R\n⊢ Eq ((algebraMap R (HahnSeries Γ A)) r) (HahnSeries.C ((algebraMap R A) r))","decl":"theorem algebraMap_apply {r : R} : algebraMap R (HahnSeries Γ A) r = C (algebraMap R A r) :=\n  rfl\n\n"}
{"name":"HahnSeries.instNontrivialSubalgebra","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝³ : OrderedCancelAddCommMonoid Γ\ninst✝² : CommSemiring R\ninst✝¹ : Nontrivial Γ\ninst✝ : Nontrivial R\n⊢ Nontrivial (Subalgebra R (HahnSeries Γ R))","decl":"instance [Nontrivial Γ] [Nontrivial R] : Nontrivial (Subalgebra R (HahnSeries Γ R)) :=\n  ⟨⟨⊥, ⊤, by\n      rw [Ne, SetLike.ext_iff, not_forall]\n      obtain ⟨a, ha⟩ := exists_ne (0 : Γ)\n      refine ⟨single a 1, ?_⟩\n      simp only [Algebra.mem_bot, not_exists, Set.mem_range, iff_true, Algebra.mem_top]\n      intro x\n      rw [HahnSeries.ext_iff, funext_iff, not_forall]\n      refine ⟨a, ?_⟩\n      rw [coeff_single_same, algebraMap_apply, C_apply, coeff_single_of_ne ha]\n      exact zero_ne_one⟩⟩\n\n"}
{"name":"HahnSeries.embDomainAlgHom_apply_coeff","module":"Mathlib.RingTheory.HahnSeries.Multiplication","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝⁴ : OrderedCancelAddCommMonoid Γ\ninst✝³ : CommSemiring R\nA : Type u_6\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\nΓ' : Type u_7\ninst✝ : OrderedCancelAddCommMonoid Γ'\nf : AddMonoidHom Γ Γ'\nhfi : Function.Injective ⇑f\nhf : ∀ (g g' : Γ), Iff (LE.le (f g) (f g')) (LE.le g g')\na✝ : HahnSeries Γ A\nb : Γ'\n⊢ Eq (((HahnSeries.embDomainAlgHom f hfi hf) a✝).coeff b) (dite (Membership.mem (Set.image (⇑f) a✝.support) b) (fun h => a✝.coeff (Classical.choose ⋯)) fun h => 0)","decl":"/-- Extending the domain of Hahn series is an algebra homomorphism. -/\n@[simps!]\ndef embDomainAlgHom (f : Γ →+ Γ') (hfi : Function.Injective f)\n    (hf : ∀ g g' : Γ, f g ≤ f g' ↔ g ≤ g') : HahnSeries Γ A →ₐ[R] HahnSeries Γ' A :=\n  { embDomainRingHom f hfi hf with commutes' := fun _ => embDomainRingHom_C (hf := hf) }\n\n"}
