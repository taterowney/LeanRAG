{"name":"orthogonalIdempotents_iff","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nI : Type u_3\ne : I → R\n⊢ Iff (OrthogonalIdempotents e) (And (∀ (i : I), IsIdempotentElem (e i)) (Pairwise fun x1 x2 => Eq (HMul.hMul (e x1) (e x2)) 0))","decl":"/-- A family `{ eᵢ }` of idempotent elements is orthogonal if `eᵢ * eⱼ = 0` for all `i ≠ j`. -/\n@[mk_iff]\nstructure OrthogonalIdempotents : Prop where\n  idem : ∀ i, IsIdempotentElem (e i)\n  ortho : Pairwise (e · * e · = 0)\n\n"}
{"name":"OrthogonalIdempotents.ortho","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nI : Type u_3\ne : I → R\nself : OrthogonalIdempotents e\n⊢ Pairwise fun x1 x2 => Eq (HMul.hMul (e x1) (e x2)) 0","decl":"/-- A family `{ eᵢ }` of idempotent elements is orthogonal if `eᵢ * eⱼ = 0` for all `i ≠ j`. -/\n@[mk_iff]\nstructure OrthogonalIdempotents : Prop where\n  idem : ∀ i, IsIdempotentElem (e i)\n  ortho : Pairwise (e · * e · = 0)\n\n"}
{"name":"OrthogonalIdempotents.idem","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nI : Type u_3\ne : I → R\nself : OrthogonalIdempotents e\ni : I\n⊢ IsIdempotentElem (e i)","decl":"/-- A family `{ eᵢ }` of idempotent elements is orthogonal if `eᵢ * eⱼ = 0` for all `i ≠ j`. -/\n@[mk_iff]\nstructure OrthogonalIdempotents : Prop where\n  idem : ∀ i, IsIdempotentElem (e i)\n  ortho : Pairwise (e · * e · = 0)\n\n"}
{"name":"OrthogonalIdempotents.mul_eq","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nI : Type u_3\ne : I → R\ninst✝ : DecidableEq I\nhe : OrthogonalIdempotents e\ni j : I\n⊢ Eq (HMul.hMul (e i) (e j)) (ite (Eq i j) (e i) 0)","decl":"lemma OrthogonalIdempotents.mul_eq [DecidableEq I] (he : OrthogonalIdempotents e) (i j) :\n    e i * e j = if i = j then e i else 0 := by\n  split\n  · simp [*, (he.idem j).eq]\n  · exact he.ortho ‹_›\n\n"}
{"name":"OrthogonalIdempotents.iff_mul_eq","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nI : Type u_3\ne : I → R\ninst✝ : DecidableEq I\n⊢ Iff (OrthogonalIdempotents e) (∀ (i j : I), Eq (HMul.hMul (e i) (e j)) (ite (Eq i j) (e i) 0))","decl":"lemma OrthogonalIdempotents.iff_mul_eq [DecidableEq I] :\n    OrthogonalIdempotents e ↔ ∀ i j, e i * e j = if i = j then e i else 0 :=\n  ⟨mul_eq, fun H ↦ ⟨fun i ↦ by simpa using H i i, fun i j e ↦ by simpa [e] using H i j⟩⟩\n\n"}
{"name":"OrthogonalIdempotents.isIdempotentElem_sum","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nI : Type u_3\ne : I → R\nhe : OrthogonalIdempotents e\ns : Finset I\n⊢ IsIdempotentElem (s.sum fun i => e i)","decl":"lemma OrthogonalIdempotents.isIdempotentElem_sum (he : OrthogonalIdempotents e) {s : Finset I} :\n    IsIdempotentElem (∑ i ∈ s, e i) := by\n  classical\n  simp [IsIdempotentElem, Finset.sum_mul, Finset.mul_sum, he.mul_eq]\n\n"}
{"name":"OrthogonalIdempotents.mul_sum_of_mem","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nI : Type u_3\ne : I → R\nhe : OrthogonalIdempotents e\ni : I\ns : Finset I\nh : Membership.mem s i\n⊢ Eq (HMul.hMul (e i) (s.sum fun j => e j)) (e i)","decl":"lemma OrthogonalIdempotents.mul_sum_of_mem (he : OrthogonalIdempotents e)\n    {i : I} {s : Finset I} (h : i ∈ s) : e i * ∑ j ∈ s, e j = e i := by\n  classical\n  simp [Finset.mul_sum, he.mul_eq, h]\n\n"}
{"name":"OrthogonalIdempotents.mul_sum_of_not_mem","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nI : Type u_3\ne : I → R\nhe : OrthogonalIdempotents e\ni : I\ns : Finset I\nh : Not (Membership.mem s i)\n⊢ Eq (HMul.hMul (e i) (s.sum fun j => e j)) 0","decl":"lemma OrthogonalIdempotents.mul_sum_of_not_mem (he : OrthogonalIdempotents e)\n    {i : I} {s : Finset I} (h : i ∉ s) : e i * ∑ j ∈ s, e j = 0 := by\n  classical\n  simp [Finset.mul_sum, he.mul_eq, h]\n\n"}
{"name":"OrthogonalIdempotents.map","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nI : Type u_3\ne : I → R\nhe : OrthogonalIdempotents e\n⊢ OrthogonalIdempotents (Function.comp (⇑f) e)","decl":"lemma OrthogonalIdempotents.map (he : OrthogonalIdempotents e) :\n    OrthogonalIdempotents (f ∘ e) := by\n  classical\n  simp [iff_mul_eq, he.mul_eq, ← map_mul f, apply_ite f]\n\n"}
{"name":"OrthogonalIdempotents.map_injective_iff","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nI : Type u_3\ne : I → R\nhf : Function.Injective ⇑f\n⊢ Iff (OrthogonalIdempotents (Function.comp (⇑f) e)) (OrthogonalIdempotents e)","decl":"lemma OrthogonalIdempotents.map_injective_iff (hf : Function.Injective f) :\n    OrthogonalIdempotents (f ∘ e) ↔ OrthogonalIdempotents e := by\n  classical\n  simp [iff_mul_eq, ← hf.eq_iff, apply_ite]\n\n"}
{"name":"OrthogonalIdempotents.embedding","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nI : Type u_3\ne : I → R\nhe : OrthogonalIdempotents e\nJ : Type u_4\ni : Function.Embedding J I\n⊢ OrthogonalIdempotents (Function.comp e ⇑i)","decl":"lemma OrthogonalIdempotents.embedding (he : OrthogonalIdempotents e) {J} (i : J ↪ I) :\n    OrthogonalIdempotents (e ∘ i) := by\n  classical\n  simp [iff_mul_eq, he.mul_eq]\n\n"}
{"name":"OrthogonalIdempotents.equiv","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nI : Type u_3\ne : I → R\nJ : Type u_4\ni : Equiv J I\n⊢ Iff (OrthogonalIdempotents (Function.comp e ⇑i)) (OrthogonalIdempotents e)","decl":"lemma OrthogonalIdempotents.equiv {J} (i : J ≃ I) :\n    OrthogonalIdempotents (e ∘ i) ↔ OrthogonalIdempotents e := by\n  classical\n  simp [iff_mul_eq, i.forall_congr_left]\n\n"}
{"name":"OrthogonalIdempotents.unique","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nI : Type u_3\ne : I → R\ninst✝ : Unique I\n⊢ Iff (OrthogonalIdempotents e) (IsIdempotentElem (e Inhabited.default))","decl":"lemma OrthogonalIdempotents.unique [Unique I] :\n    OrthogonalIdempotents e ↔ IsIdempotentElem (e default) := by\n  simp only [orthogonalIdempotents_iff, Unique.forall_iff, Subsingleton.pairwise, and_true]\n\n"}
{"name":"OrthogonalIdempotents.option","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nI : Type u_3\ne : I → R\nhe : OrthogonalIdempotents e\ninst✝ : Fintype I\nx : R\nhx : IsIdempotentElem x\nhx₁ : Eq (HMul.hMul x (Finset.univ.sum fun i => e i)) 0\nhx₂ : Eq (HMul.hMul (Finset.univ.sum fun i => e i) x) 0\n⊢ OrthogonalIdempotents fun x_1 => x_1.elim x e","decl":"lemma OrthogonalIdempotents.option (he : OrthogonalIdempotents e) [Fintype I] (x)\n    (hx : IsIdempotentElem x) (hx₁ : x * ∑ i, e i = 0) (hx₂ : (∑ i, e i) * x = 0) :\n    OrthogonalIdempotents (Option.elim · x e) where\n  idem i := i.rec hx he.idem\n  ortho i j ne := by\n    classical\n    cases' i with i <;> cases' j with j\n    · cases ne rfl\n    · simpa only [mul_assoc, Finset.sum_mul, he.mul_eq, Finset.sum_ite_eq', Finset.mem_univ,\n        ↓reduceIte, zero_mul] using congr_arg (· * e j) hx₁\n    · simpa only [Option.elim_some, Option.elim_none, ← mul_assoc, Finset.mul_sum, he.mul_eq,\n        Finset.sum_ite_eq, Finset.mem_univ, ↓reduceIte, mul_zero] using congr_arg (e i * ·) hx₂\n    · exact he.ortho (Option.some_inj.ne.mp ne)\n\n"}
{"name":"CompleteOrthogonalIdempotents.complete","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nI : Type u_3\ninst✝ : Fintype I\ne : I → R\nself : CompleteOrthogonalIdempotents e\n⊢ Eq (Finset.univ.sum fun i => e i) 1","decl":"/--\nA family `{ eᵢ }` of idempotent elements is complete orthogonal if\n1. (orthogonal) `eᵢ * eⱼ = 0` for all `i ≠ j`.\n2. (complete) `∑ eᵢ = 1`\n-/\n@[mk_iff]\nstructure CompleteOrthogonalIdempotents (e : I → R) extends OrthogonalIdempotents e : Prop where\n  complete : ∑ i, e i = 1\n\n"}
{"name":"CompleteOrthogonalIdempotents.toOrthogonalIdempotents","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nI : Type u_3\ninst✝ : Fintype I\ne : I → R\nself : CompleteOrthogonalIdempotents e\n⊢ OrthogonalIdempotents e","decl":"/--\nA family `{ eᵢ }` of idempotent elements is complete orthogonal if\n1. (orthogonal) `eᵢ * eⱼ = 0` for all `i ≠ j`.\n2. (complete) `∑ eᵢ = 1`\n-/\n@[mk_iff]\nstructure CompleteOrthogonalIdempotents (e : I → R) extends OrthogonalIdempotents e : Prop where\n  complete : ∑ i, e i = 1\n\n"}
{"name":"completeOrthogonalIdempotents_iff","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nI : Type u_3\ninst✝ : Fintype I\ne : I → R\n⊢ Iff (CompleteOrthogonalIdempotents e) (And (OrthogonalIdempotents e) (Eq (Finset.univ.sum fun i => e i) 1))","decl":"/--\nA family `{ eᵢ }` of idempotent elements is complete orthogonal if\n1. (orthogonal) `eᵢ * eⱼ = 0` for all `i ≠ j`.\n2. (complete) `∑ eᵢ = 1`\n-/\n@[mk_iff]\nstructure CompleteOrthogonalIdempotents (e : I → R) extends OrthogonalIdempotents e : Prop where\n  complete : ∑ i, e i = 1\n\n"}
{"name":"CompleteOrthogonalIdempotents.iff_ortho_complete","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nI : Type u_3\ne : I → R\ninst✝ : Fintype I\n⊢ Iff (CompleteOrthogonalIdempotents e) (And (Pairwise fun x1 x2 => Eq (HMul.hMul (e x1) (e x2)) 0) (Eq (Finset.univ.sum fun i => e i) 1))","decl":"/-- If a family is complete orthogonal, it consists of idempotents. -/\nlemma CompleteOrthogonalIdempotents.iff_ortho_complete :\n    CompleteOrthogonalIdempotents e ↔ Pairwise (e · * e · = 0) ∧ ∑ i, e i = 1 := by\n  rw [completeOrthogonalIdempotents_iff, orthogonalIdempotents_iff, and_assoc, and_iff_right_of_imp]\n  intro ⟨ortho, complete⟩ i\n  apply_fun (e i * ·) at complete\n  rwa [Finset.mul_sum, Finset.sum_eq_single i (fun _ _ ne ↦ ortho ne.symm) (by simp at ·), mul_one]\n    at complete\n\n"}
{"name":"CompleteOrthogonalIdempotents.pair_iff'ₛ","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\n⊢ Iff (CompleteOrthogonalIdempotents (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))) (And (Eq (HMul.hMul x y) 0) (And (Eq (HMul.hMul y x) 0) (Eq (HAdd.hAdd x y) 1)))","decl":"lemma CompleteOrthogonalIdempotents.pair_iff'ₛ {x y : R} :\n    CompleteOrthogonalIdempotents ![x, y] ↔ x * y = 0 ∧ y * x = 0 ∧ x + y = 1 := by\n  simp [iff_ortho_complete, Pairwise, Fin.forall_fin_two, and_assoc]\n\n"}
{"name":"CompleteOrthogonalIdempotents.pair_iffₛ","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_4\ninst✝ : CommSemiring R\nx y : R\n⊢ Iff (CompleteOrthogonalIdempotents (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))) (And (Eq (HMul.hMul x y) 0) (Eq (HAdd.hAdd x y) 1))","decl":"lemma CompleteOrthogonalIdempotents.pair_iffₛ {R} [CommSemiring R] {x y : R} :\n    CompleteOrthogonalIdempotents ![x, y] ↔ x * y = 0 ∧ x + y = 1 := by\n  rw [pair_iff'ₛ, and_left_comm, and_iff_right_of_imp]; exact (mul_comm x y ▸ ·.1)\n\n"}
{"name":"CompleteOrthogonalIdempotents.unique_iff","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nI : Type u_3\ne : I → R\ninst✝¹ : Fintype I\ninst✝ : Unique I\n⊢ Iff (CompleteOrthogonalIdempotents e) (Eq (e Inhabited.default) 1)","decl":"lemma CompleteOrthogonalIdempotents.unique_iff [Unique I] :\n    CompleteOrthogonalIdempotents e ↔ e default = 1 := by\n  rw [completeOrthogonalIdempotents_iff, OrthogonalIdempotents.unique, Fintype.sum_unique,\n    and_iff_right_iff_imp]\n  exact (· ▸ IsIdempotentElem.one)\n\n"}
{"name":"CompleteOrthogonalIdempotents.single","module":"Mathlib.RingTheory.Idempotents","initialProofState":"I : Type u_4\ninst✝² : Fintype I\ninst✝¹ : DecidableEq I\nR : I → Type u_5\ninst✝ : (i : I) → Semiring (R i)\n⊢ CompleteOrthogonalIdempotents fun x => Pi.single x 1","decl":"lemma CompleteOrthogonalIdempotents.single {I : Type*} [Fintype I] [DecidableEq I]\n    (R : I → Type*) [∀ i, Semiring (R i)] :\n    CompleteOrthogonalIdempotents (Pi.single (f := R) · 1) := by\n  refine ⟨⟨by simp [IsIdempotentElem, ← Pi.single_mul], ?_⟩, Finset.univ_sum_single 1⟩\n  intros i j hij\n  ext k\n  by_cases hi : i = k\n  · subst hi; simp [hij]\n  · simp [hi]\n\n"}
{"name":"CompleteOrthogonalIdempotents.map","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : Semiring R\ninst✝¹ : Semiring S\nf : RingHom R S\nI : Type u_3\ne : I → R\ninst✝ : Fintype I\nhe : CompleteOrthogonalIdempotents e\n⊢ CompleteOrthogonalIdempotents (Function.comp (⇑f) e)","decl":"lemma CompleteOrthogonalIdempotents.map (he : CompleteOrthogonalIdempotents e) :\n    CompleteOrthogonalIdempotents (f ∘ e) where\n  __ := he.toOrthogonalIdempotents.map f\n  complete := by simp only [Function.comp_apply, ← map_sum, he.complete, map_one]\n\n"}
{"name":"CompleteOrthogonalIdempotents.map_injective_iff","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : Semiring R\ninst✝¹ : Semiring S\nf : RingHom R S\nI : Type u_3\ne : I → R\ninst✝ : Fintype I\nhf : Function.Injective ⇑f\n⊢ Iff (CompleteOrthogonalIdempotents (Function.comp (⇑f) e)) (CompleteOrthogonalIdempotents e)","decl":"lemma CompleteOrthogonalIdempotents.map_injective_iff (hf : Function.Injective f) :\n    CompleteOrthogonalIdempotents (f ∘ e) ↔ CompleteOrthogonalIdempotents e := by\n  simp [completeOrthogonalIdempotents_iff, ← hf.eq_iff, apply_ite,\n    OrthogonalIdempotents.map_injective_iff f hf]\n\n"}
{"name":"CompleteOrthogonalIdempotents.equiv","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nI : Type u_3\ne : I → R\ninst✝¹ : Fintype I\nJ : Type u_4\ninst✝ : Fintype J\ni : Equiv J I\n⊢ Iff (CompleteOrthogonalIdempotents (Function.comp e ⇑i)) (CompleteOrthogonalIdempotents e)","decl":"lemma CompleteOrthogonalIdempotents.equiv {J} [Fintype J] (i : J ≃ I) :\n    CompleteOrthogonalIdempotents (e ∘ i) ↔ CompleteOrthogonalIdempotents e := by\n  simp only [completeOrthogonalIdempotents_iff, OrthogonalIdempotents.equiv, Function.comp_apply,\n    and_congr_right_iff, Fintype.sum_equiv i _ e (fun _ ↦ rfl)]\n\n"}
{"name":"CompleteOrthogonalIdempotents.of_subsingleton","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nI : Type u_3\ne : I → R\ninst✝¹ : Fintype I\ninst✝ : Subsingleton R\n⊢ CompleteOrthogonalIdempotents e","decl":"@[nontriviality]\nlemma CompleteOrthogonalIdempotents.of_subsingleton [Subsingleton R] :\n    CompleteOrthogonalIdempotents e :=\n  ⟨⟨fun _ ↦ Subsingleton.elim _ _, fun _ _ _ ↦ Subsingleton.elim _ _⟩, Subsingleton.elim _ _⟩\n\n"}
{"name":"isIdempotentElem_one_sub_one_sub_pow_pow","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : Ring R\nx : R\nn : Nat\nhx : Eq (HPow.hPow (HSub.hSub x (HPow.hPow x 2)) n) 0\n⊢ IsIdempotentElem (HSub.hSub 1 (HPow.hPow (HSub.hSub 1 (HPow.hPow x n)) n))","decl":"theorem isIdempotentElem_one_sub_one_sub_pow_pow\n    (x : R) (n : ℕ) (hx : (x - x ^ 2) ^ n = 0) :\n    IsIdempotentElem (1 - (1 - x ^ n) ^ n) := by\n  let P : Polynomial ℤ := 1 - (1 - .X ^ n) ^ n\n  have : (.X - .X ^ 2) ^ n ∣ P - P ^ 2 := by\n    have H₁ : .X ^ n ∣ P := by\n      have := sub_dvd_pow_sub_pow 1 ((1 : Polynomial ℤ) - Polynomial.X ^ n) n\n      rwa [sub_sub_cancel, one_pow] at this\n    have H₂ : (1 - .X) ^ n ∣ 1 - P := by\n      simp only [sub_sub_cancel, P]\n      simpa using pow_dvd_pow_of_dvd (sub_dvd_pow_sub_pow (α := Polynomial ℤ) 1 Polynomial.X n) n\n    have := mul_dvd_mul H₁ H₂\n    simpa only [← mul_pow, mul_sub, mul_one, ← pow_two] using this\n  have := map_dvd (Polynomial.aeval x) this\n  simp only [map_pow, map_sub, Polynomial.aeval_X, hx, map_one, zero_dvd_iff, P] at this\n  rwa [sub_eq_zero, eq_comm, pow_two] at this\n\n"}
{"name":"exists_isIdempotentElem_mul_eq_zero_of_ker_isNilpotent_aux","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nh : ∀ (x : R), Membership.mem (RingHom.ker f) x → IsNilpotent x\ne₁ : S\nhe : Membership.mem f.range e₁\nhe₁ : IsIdempotentElem e₁\ne₂ : R\nhe₂ : IsIdempotentElem e₂\nhe₁e₂ : Eq (HMul.hMul e₁ (f e₂)) 0\n⊢ Exists fun e' => And (IsIdempotentElem e') (And (Eq (f e') e₁) (Eq (HMul.hMul e' e₂) 0))","decl":"theorem exists_isIdempotentElem_mul_eq_zero_of_ker_isNilpotent_aux\n    (h : ∀ x ∈ RingHom.ker f, IsNilpotent x)\n    (e₁ : S) (he : e₁ ∈ f.range) (he₁ : IsIdempotentElem e₁)\n    (e₂ : R) (he₂ : IsIdempotentElem e₂) (he₁e₂ : e₁ * f e₂ = 0) :\n    ∃ e' : R, IsIdempotentElem e' ∧ f e' = e₁ ∧ e' * e₂ = 0 := by\n  obtain ⟨e₁, rfl⟩ := he\n  cases subsingleton_or_nontrivial R\n  · exact ⟨_, Subsingleton.elim _ _, rfl, Subsingleton.elim _ _⟩\n  let a := e₁ - e₁ * e₂\n  have ha : f a = f e₁ := by rw [map_sub, map_mul, he₁e₂, sub_zero]\n  have ha' : a * e₂ = 0 := by rw [sub_mul, mul_assoc, he₂.eq, sub_self]\n  have hx' : a - a ^ 2 ∈ RingHom.ker f := by\n    simp [RingHom.mem_ker, mul_sub, pow_two, ha, he₁.eq]\n  obtain ⟨n, hn⟩ := h _ hx'\n  refine ⟨_, isIdempotentElem_one_sub_one_sub_pow_pow _ _ hn, ?_, ?_⟩\n  · cases' n with n\n    · simp at hn\n    simp only [map_sub, map_one, map_pow, ha, he₁.pow_succ_eq,\n      he₁.one_sub.pow_succ_eq, sub_sub_cancel]\n  · obtain ⟨k, hk⟩ := (Commute.one_left (MulOpposite.op <| 1 - a ^ n)).sub_dvd_pow_sub_pow n\n    apply_fun MulOpposite.unop at hk\n    have : 1 - (1 - a ^ n) ^ n = MulOpposite.unop k * a ^ n := by simpa using hk\n    rw [this, mul_assoc]\n    cases' n with n\n    · simp at hn\n    rw [pow_succ, mul_assoc, ha', mul_zero, mul_zero]\n\n"}
{"name":"exists_isIdempotentElem_mul_eq_zero_of_ker_isNilpotent","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nh : ∀ (x : R), Membership.mem (RingHom.ker f) x → IsNilpotent x\ne₁ : S\nhe : Membership.mem f.range e₁\nhe₁ : IsIdempotentElem e₁\ne₂ : R\nhe₂ : IsIdempotentElem e₂\nhe₁e₂ : Eq (HMul.hMul e₁ (f e₂)) 0\nhe₂e₁ : Eq (HMul.hMul (f e₂) e₁) 0\n⊢ Exists fun e' => And (IsIdempotentElem e') (And (Eq (f e') e₁) (And (Eq (HMul.hMul e' e₂) 0) (Eq (HMul.hMul e₂ e') 0)))","decl":"/-- Orthogonal idempotents lift along nil ideals. -/\ntheorem exists_isIdempotentElem_mul_eq_zero_of_ker_isNilpotent\n    (h : ∀ x ∈ RingHom.ker f, IsNilpotent x)\n    (e₁ : S) (he : e₁ ∈ f.range) (he₁ : IsIdempotentElem e₁)\n    (e₂ : R) (he₂ : IsIdempotentElem e₂) (he₁e₂ : e₁ * f e₂ = 0) (he₂e₁ : f e₂ * e₁ = 0) :\n    ∃ e' : R, IsIdempotentElem e' ∧ f e' = e₁ ∧ e' * e₂ = 0 ∧ e₂ * e' = 0 := by\n  obtain ⟨e', h₁, rfl, h₂⟩ := exists_isIdempotentElem_mul_eq_zero_of_ker_isNilpotent_aux\n    f h e₁ he he₁ e₂ he₂ he₁e₂\n  refine ⟨(1 - e₂) * e', ?_, ?_, ?_, ?_⟩\n  · rw [IsIdempotentElem, mul_assoc, ← mul_assoc e', mul_sub, mul_one, h₂, sub_zero, h₁.eq]\n  · rw [map_mul, map_sub, map_one, sub_mul, one_mul, he₂e₁, sub_zero]\n  · rw [mul_assoc, h₂, mul_zero]\n  · rw [← mul_assoc, mul_sub, mul_one, he₂.eq, sub_self, zero_mul]\n\n"}
{"name":"exists_isIdempotentElem_eq_of_ker_isNilpotent","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nh : ∀ (x : R), Membership.mem (RingHom.ker f) x → IsNilpotent x\ne : S\nhe : Membership.mem f.range e\nhe' : IsIdempotentElem e\n⊢ Exists fun e' => And (IsIdempotentElem e') (Eq (f e') e)","decl":"/-- Idempotents lift along nil ideals. -/\ntheorem exists_isIdempotentElem_eq_of_ker_isNilpotent (h : ∀ x ∈ RingHom.ker f, IsNilpotent x)\n    (e : S) (he : e ∈ f.range) (he' : IsIdempotentElem e) :\n    ∃ e' : R, IsIdempotentElem e' ∧ f e' = e := by\n  simpa using exists_isIdempotentElem_mul_eq_zero_of_ker_isNilpotent f h e he he' 0 .zero (by simp)\n\n"}
{"name":"OrthogonalIdempotents.lift_of_isNilpotent_ker_aux","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nh : ∀ (x : R), Membership.mem (RingHom.ker f) x → IsNilpotent x\nn : Nat\ne : Fin n → S\nhe : OrthogonalIdempotents e\nhe' : ∀ (i : Fin n), Membership.mem f.range (e i)\n⊢ Exists fun e' => And (OrthogonalIdempotents e') (Eq (Function.comp (⇑f) e') e)","decl":"lemma OrthogonalIdempotents.lift_of_isNilpotent_ker_aux\n    (h : ∀ x ∈ RingHom.ker f, IsNilpotent x)\n    {n} {e : Fin n → S} (he : OrthogonalIdempotents e) (he' : ∀ i, e i ∈ f.range) :\n    ∃ e' : Fin n → R, OrthogonalIdempotents e' ∧ f ∘ e' = e := by\n  induction' n with n IH\n  · refine ⟨0, ⟨finZeroElim, finZeroElim⟩, funext finZeroElim⟩\n  · obtain ⟨e', h₁, h₂⟩ := IH (he.embedding (Fin.succEmb n)) (fun i ↦ he' _)\n    have h₂' (i) : f (e' i) = e i.succ := congr_fun h₂ i\n    obtain ⟨e₀, h₃, h₄, h₅, h₆⟩ :=\n      exists_isIdempotentElem_mul_eq_zero_of_ker_isNilpotent f h _ (he' 0) (he.idem 0) _\n      h₁.isIdempotentElem_sum\n      (by simp [Finset.mul_sum, h₂', he.mul_eq, Fin.succ_ne_zero, eq_comm])\n      (by simp [Finset.sum_mul, h₂', he.mul_eq, Fin.succ_ne_zero])\n    refine ⟨_, (h₁.option _ h₃ h₅ h₆).embedding (finSuccEquiv n).toEmbedding, funext fun i ↦ ?_⟩\n    obtain ⟨_ | i, rfl⟩ := (finSuccEquiv n).symm.surjective i <;> simp [*]\n\n"}
{"name":"OrthogonalIdempotents.lift_of_isNilpotent_ker","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : Ring R\ninst✝¹ : Ring S\nf : RingHom R S\nI : Type u_3\ninst✝ : Finite I\nh : ∀ (x : R), Membership.mem (RingHom.ker f) x → IsNilpotent x\ne : I → S\nhe : OrthogonalIdempotents e\nhe' : ∀ (i : I), Membership.mem f.range (e i)\n⊢ Exists fun e' => And (OrthogonalIdempotents e') (Eq (Function.comp (⇑f) e') e)","decl":"/-- A family of orthogonal idempotents lift along nil ideals. -/\nlemma OrthogonalIdempotents.lift_of_isNilpotent_ker [Finite I]\n    (h : ∀ x ∈ RingHom.ker f, IsNilpotent x)\n    {e : I → S} (he : OrthogonalIdempotents e) (he' : ∀ i, e i ∈ f.range) :\n    ∃ e' : I → R, OrthogonalIdempotents e' ∧ f ∘ e' = e := by\n  cases nonempty_fintype I\n  obtain ⟨e', h₁, h₂⟩ := lift_of_isNilpotent_ker_aux f h\n    (he.embedding (Fintype.equivFin I).symm.toEmbedding) (fun _ ↦ he' _)\n  refine ⟨_, h₁.embedding (Fintype.equivFin I).toEmbedding,\n    by ext x; simpa using congr_fun h₂ (Fintype.equivFin I x)⟩\n\n"}
{"name":"CompleteOrthogonalIdempotents.pair_iff","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : Ring R\nx y : R\n⊢ Iff (CompleteOrthogonalIdempotents (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty))) (And (IsIdempotentElem x) (Eq y (HSub.hSub 1 x)))","decl":"lemma CompleteOrthogonalIdempotents.pair_iff {x y : R} :\n    CompleteOrthogonalIdempotents ![x, y] ↔ IsIdempotentElem x ∧ y = 1 - x := by\n  rw [pair_iff'ₛ, ← eq_sub_iff_add_eq', ← and_assoc, and_congr_left_iff]\n  rintro rfl\n  simp [mul_sub, sub_mul, IsIdempotentElem, sub_eq_zero, eq_comm]\n\n"}
{"name":"CompleteOrthogonalIdempotents.of_isIdempotentElem","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : Ring R\ne : R\nhe : IsIdempotentElem e\n⊢ CompleteOrthogonalIdempotents (Matrix.vecCons e (Matrix.vecCons (HSub.hSub 1 e) Matrix.vecEmpty))","decl":"lemma CompleteOrthogonalIdempotents.of_isIdempotentElem {e : R} (he : IsIdempotentElem e) :\n    CompleteOrthogonalIdempotents ![e, 1 - e] :=\n  pair_iff.mpr ⟨he, rfl⟩\n\n"}
{"name":"CompleteOrthogonalIdempotents.option","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nI : Type u_3\ne : I → R\ninst✝ : Fintype I\nhe : OrthogonalIdempotents e\n⊢ CompleteOrthogonalIdempotents fun x => x.elim (HSub.hSub 1 (Finset.univ.sum fun i => e i)) e","decl":"lemma CompleteOrthogonalIdempotents.option (he : OrthogonalIdempotents e) :\n    CompleteOrthogonalIdempotents (Option.elim · (1 - ∑ i, e i) e) where\n  __ := he.option _ he.isIdempotentElem_sum.one_sub\n    (by simp [sub_mul, he.isIdempotentElem_sum.eq]) (by simp [mul_sub, he.isIdempotentElem_sum.eq])\n  complete := by\n    rw [Fintype.sum_option]\n    exact sub_add_cancel _ _\n\n"}
{"name":"CompleteOrthogonalIdempotents.lift_of_isNilpotent_ker_aux","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\nh : ∀ (x : R), Membership.mem (RingHom.ker f) x → IsNilpotent x\nn : Nat\ne : Fin n → S\nhe : CompleteOrthogonalIdempotents e\nhe' : ∀ (i : Fin n), Membership.mem f.range (e i)\n⊢ Exists fun e' => And (CompleteOrthogonalIdempotents e') (Eq (Function.comp (⇑f) e') e)","decl":"lemma CompleteOrthogonalIdempotents.lift_of_isNilpotent_ker_aux\n    (h : ∀ x ∈ RingHom.ker f, IsNilpotent x)\n    {n} {e : Fin n → S} (he : CompleteOrthogonalIdempotents e) (he' : ∀ i, e i ∈ f.range) :\n    ∃ e' : Fin n → R, CompleteOrthogonalIdempotents e' ∧ f ∘ e' = e := by\n  cases subsingleton_or_nontrivial R\n  · choose e' he' using he'\n    exact ⟨e', .of_subsingleton, funext he'⟩\n  cases subsingleton_or_nontrivial S\n  · obtain ⟨n, hn⟩ := h 1 (Subsingleton.elim _ _)\n    simp at hn\n  cases' n with n\n  · simpa using he.complete\n  obtain ⟨e', h₁, h₂⟩ := OrthogonalIdempotents.lift_of_isNilpotent_ker f h he.1 he'\n  refine ⟨_, (equiv (finSuccEquiv n)).mpr\n    (CompleteOrthogonalIdempotents.option (h₁.embedding (Fin.succEmb _))), funext fun i ↦ ?_⟩\n  have (i) : f (e' i) = e i := congr_fun h₂ i\n  obtain ⟨_ | i, rfl⟩ := (finSuccEquiv n).symm.surjective i\n  · simp only [Fin.val_succEmb, Function.comp_apply, finSuccEquiv_symm_none, finSuccEquiv_zero,\n      Option.elim_none, map_sub, map_one, map_sum, this, ← he.complete, sub_eq_iff_eq_add,\n      Fin.sum_univ_succ]\n  · simp [this]\n\n"}
{"name":"CompleteOrthogonalIdempotents.lift_of_isNilpotent_ker","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : Ring R\ninst✝¹ : Ring S\nf : RingHom R S\nI : Type u_3\ninst✝ : Fintype I\nh : ∀ (x : R), Membership.mem (RingHom.ker f) x → IsNilpotent x\ne : I → S\nhe : CompleteOrthogonalIdempotents e\nhe' : ∀ (i : I), Membership.mem f.range (e i)\n⊢ Exists fun e' => And (CompleteOrthogonalIdempotents e') (Eq (Function.comp (⇑f) e') e)","decl":"/-- A system of complete orthogonal idempotents lift along nil ideals. -/\nlemma CompleteOrthogonalIdempotents.lift_of_isNilpotent_ker\n    (h : ∀ x ∈ RingHom.ker f, IsNilpotent x)\n    {e : I → S} (he : CompleteOrthogonalIdempotents e) (he' : ∀ i, e i ∈ f.range) :\n    ∃ e' : I → R, CompleteOrthogonalIdempotents e' ∧ f ∘ e' = e := by\n  obtain ⟨e', h₁, h₂⟩ := lift_of_isNilpotent_ker_aux f h\n    ((equiv (Fintype.equivFin I).symm).mpr he) (fun _ ↦ he' _)\n  refine ⟨_, ((equiv (Fintype.equivFin I)).mpr h₁),\n    by ext x; simpa using congr_fun h₂ (Fintype.equivFin I x)⟩\n\n"}
{"name":"eq_of_isNilpotent_sub_of_isIdempotentElem_of_commute","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : Ring R\ne₁ e₂ : R\nhe₁ : IsIdempotentElem e₁\nhe₂ : IsIdempotentElem e₂\nH : IsNilpotent (HSub.hSub e₁ e₂)\nH' : Commute e₁ e₂\n⊢ Eq e₁ e₂","decl":"theorem eq_of_isNilpotent_sub_of_isIdempotentElem_of_commute {e₁ e₂ : R}\n    (he₁ : IsIdempotentElem e₁) (he₂ : IsIdempotentElem e₂) (H : IsNilpotent (e₁ - e₂))\n    (H' : Commute e₁ e₂) :\n    e₁ = e₂ := by\n  have : (e₁ - e₂) ^ 3 = (e₁ - e₂) := by\n    simp only [pow_succ, pow_zero, mul_sub, one_mul, sub_mul, he₁.eq, he₂.eq,\n      H'.eq, mul_assoc]\n    simp only [← mul_assoc, he₁.eq, he₂.eq]\n    abel\n  obtain ⟨n, hn⟩ := H\n  have : (e₁ - e₂) ^ (2 * n + 1) = (e₁ - e₂) := by\n    clear hn; induction n <;> simp [mul_add, add_assoc, pow_add _ (2 * _) 3, this, ← pow_succ, *]\n  rwa [pow_succ, two_mul, pow_add, hn, zero_mul, zero_mul, eq_comm, sub_eq_zero] at this\n\n"}
{"name":"CompleteOrthogonalIdempotents.of_ker_isNilpotent_of_isMulCentral","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : Ring R\ninst✝¹ : Ring S\nf : RingHom R S\nI : Type u_3\ne : I → R\ninst✝ : Fintype I\nh : ∀ (x : R), Membership.mem (RingHom.ker f) x → IsNilpotent x\nhe : ∀ (i : I), IsIdempotentElem (e i)\nhe' : ∀ (i : I), IsMulCentral (e i)\nhe'' : CompleteOrthogonalIdempotents (Function.comp (⇑f) e)\n⊢ CompleteOrthogonalIdempotents e","decl":"theorem CompleteOrthogonalIdempotents.of_ker_isNilpotent_of_isMulCentral\n    (h : ∀ x ∈ RingHom.ker f, IsNilpotent x)\n    (he : ∀ i, IsIdempotentElem (e i))\n    (he' : ∀ i, IsMulCentral (e i))\n    (he'' : CompleteOrthogonalIdempotents (f ∘ e)) :\n    CompleteOrthogonalIdempotents e := by\n  obtain ⟨e', h₁, h₂⟩ := lift_of_isNilpotent_ker f h he'' (fun _ ↦ ⟨_, rfl⟩)\n  obtain rfl : e = e' := by\n    ext i\n    refine eq_of_isNilpotent_sub_of_isIdempotentElem_of_commute\n      (he _) (h₁.idem _) (h _ ?_) ((he' i).comm _)\n    simpa [RingHom.mem_ker, sub_eq_zero] using congr_fun h₂.symm i\n  exact h₁\n\n"}
{"name":"eq_of_isNilpotent_sub_of_isIdempotentElem","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : CommRing R\ne₁ e₂ : R\nhe₁ : IsIdempotentElem e₁\nhe₂ : IsIdempotentElem e₂\nH : IsNilpotent (HSub.hSub e₁ e₂)\n⊢ Eq e₁ e₂","decl":"theorem eq_of_isNilpotent_sub_of_isIdempotentElem {e₁ e₂ : R}\n    (he₁ : IsIdempotentElem e₁) (he₂ : IsIdempotentElem e₂) (H : IsNilpotent (e₁ - e₂)) :\n    e₁ = e₂ :=\n  eq_of_isNilpotent_sub_of_isIdempotentElem_of_commute he₁ he₂ H (.all _ _)\n\n"}
{"name":"existsUnique_isIdempotentElem_eq_of_ker_isNilpotent","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : Ring S\nf : RingHom R S\nh : ∀ (x : R), Membership.mem (RingHom.ker f) x → IsNilpotent x\ne : S\nhe : Membership.mem f.range e\nhe' : IsIdempotentElem e\n⊢ ExistsUnique fun e' => And (IsIdempotentElem e') (Eq (f e') e)","decl":"@[stacks 00J9]\ntheorem existsUnique_isIdempotentElem_eq_of_ker_isNilpotent (h : ∀ x ∈ RingHom.ker f, IsNilpotent x)\n    (e : S) (he : e ∈ f.range) (he' : IsIdempotentElem e) :\n    ∃! e' : R, IsIdempotentElem e' ∧ f e' = e := by\n  obtain ⟨e', he₂, rfl⟩ := exists_isIdempotentElem_eq_of_ker_isNilpotent f h e he he'\n  exact ⟨e', ⟨he₂, rfl⟩, fun x ⟨hx, hx'⟩ ↦\n    eq_of_isNilpotent_sub_of_isIdempotentElem hx he₂\n      (h _ (by rw [RingHom.mem_ker, map_sub, hx', sub_self]))⟩\n\n"}
{"name":"OrthogonalIdempotents.surjective_pi","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Type u_3\ninst✝ : Finite I\ne : I → R\nhe : OrthogonalIdempotents e\n⊢ Function.Surjective ⇑(Pi.ringHom fun i => Ideal.Quotient.mk (Ideal.span (Singleton.singleton (HSub.hSub 1 (e i)))))","decl":"/-- A family of orthogonal idempotents induces an surjection `R ≃+* ∏ R ⧸ ⟨1 - eᵢ⟩` -/\nlemma OrthogonalIdempotents.surjective_pi {I : Type*} [Finite I] {e : I → R}\n    (he : OrthogonalIdempotents e) :\n    Function.Surjective (Pi.ringHom fun i ↦ Ideal.Quotient.mk (Ideal.span {1 - e i})) := by\n  suffices Pairwise fun i j ↦ IsCoprime (Ideal.span {1 - e i}) (Ideal.span {1 - e j}) by\n    intro x\n    obtain ⟨x, rfl⟩ := Ideal.quotientInfToPiQuotient_surj this x\n    obtain ⟨x, rfl⟩ := Ideal.Quotient.mk_surjective x\n    exact ⟨x, by ext i; simp [Ideal.quotientInfToPiQuotient]⟩\n  intros i j hij\n  rw [Ideal.isCoprime_span_singleton_iff]\n  exact ⟨1, e i, by simp [mul_sub, sub_mul, he.ortho hij]⟩\n\n"}
{"name":"OrthogonalIdempotents.prod_one_sub","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Type u_3\ne : I → R\nhe : OrthogonalIdempotents e\ns : Finset I\n⊢ Eq (s.prod fun i => HSub.hSub 1 (e i)) (HSub.hSub 1 (s.sum fun i => e i))","decl":"lemma OrthogonalIdempotents.prod_one_sub {I : Type*} {e : I → R}\n    (he : OrthogonalIdempotents e) (s : Finset I) :\n    ∏ i ∈ s, (1 - e i) = 1 - ∑ i ∈ s, e i := by\n  induction s using Finset.cons_induction with\n  | empty => simp\n  | cons a s has ih =>\n    simp [ih, sub_mul, mul_sub, he.mul_sum_of_not_mem has, sub_sub]\n\n"}
{"name":"CompleteOrthogonalIdempotents.of_ker_isNilpotent","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\nf : RingHom R S\nI : Type u_3\ninst✝ : Fintype I\ne : I → R\nh : ∀ (x : R), Membership.mem (RingHom.ker f) x → IsNilpotent x\nhe : ∀ (i : I), IsIdempotentElem (e i)\nhe' : CompleteOrthogonalIdempotents (Function.comp (⇑f) e)\n⊢ CompleteOrthogonalIdempotents e","decl":"theorem CompleteOrthogonalIdempotents.of_ker_isNilpotent (h : ∀ x ∈ RingHom.ker f, IsNilpotent x)\n    (he : ∀ i, IsIdempotentElem (e i))\n    (he' : CompleteOrthogonalIdempotents (f ∘ e)) :\n    CompleteOrthogonalIdempotents e :=\n  of_ker_isNilpotent_of_isMulCentral f h he\n    (fun _ ↦ Semigroup.mem_center_iff.mpr (mul_comm · _)) he'\n\n"}
{"name":"CompleteOrthogonalIdempotents.prod_one_sub","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Type u_3\ninst✝ : Fintype I\ne : I → R\nhe : CompleteOrthogonalIdempotents e\n⊢ Eq (Finset.univ.prod fun i => HSub.hSub 1 (e i)) 0","decl":"lemma CompleteOrthogonalIdempotents.prod_one_sub\n    (he : CompleteOrthogonalIdempotents e) :\n    ∏ i, (1 - e i) = 0 := by\n  rw [he.1.prod_one_sub, he.complete, sub_self]\n\n"}
{"name":"CompleteOrthogonalIdempotents.of_prod_one_sub","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Type u_3\ninst✝ : Fintype I\ne : I → R\nhe : OrthogonalIdempotents e\nhe' : Eq (Finset.univ.prod fun i => HSub.hSub 1 (e i)) 0\n⊢ CompleteOrthogonalIdempotents e","decl":"lemma CompleteOrthogonalIdempotents.of_prod_one_sub\n    (he : OrthogonalIdempotents e) (he' : ∏ i, (1 - e i) = 0) :\n    CompleteOrthogonalIdempotents e where\n  __ := he\n  complete := by rwa [he.prod_one_sub, sub_eq_zero, eq_comm] at he'\n\n"}
{"name":"CompleteOrthogonalIdempotents.bijective_pi","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Type u_3\ninst✝ : Fintype I\ne : I → R\nhe : CompleteOrthogonalIdempotents e\n⊢ Function.Bijective ⇑(Pi.ringHom fun i => Ideal.Quotient.mk (Ideal.span (Singleton.singleton (HSub.hSub 1 (e i)))))","decl":"/-- A family of complete orthogonal idempotents induces an isomorphism `R ≃+* ∏ R ⧸ ⟨1 - eᵢ⟩` -/\nlemma CompleteOrthogonalIdempotents.bijective_pi (he : CompleteOrthogonalIdempotents e) :\n    Function.Bijective (Pi.ringHom fun i ↦ Ideal.Quotient.mk (Ideal.span {1 - e i})) := by\n  classical\n  refine ⟨?_, he.1.surjective_pi⟩\n  rw [injective_iff_map_eq_zero]\n  intro x hx\n  simp [funext_iff, Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_span_singleton] at hx\n  suffices ∀ s : Finset I, (∏ i ∈ s, (1 - e i)) * x = x by\n    rw [← this Finset.univ, he.prod_one_sub, zero_mul]\n  refine fun s ↦ Finset.induction_on s (by simp) ?_\n  intros a s has e'\n  suffices (1 - e a) * x = x by simp [has, mul_assoc, e', this]\n  obtain ⟨c, rfl⟩ := hx a\n  rw [← mul_assoc, (he.idem a).one_sub.eq]\n\n"}
{"name":"CompleteOrthogonalIdempotents.bijective_pi'","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Type u_3\ninst✝ : Fintype I\ne : I → R\nhe : CompleteOrthogonalIdempotents fun x => HSub.hSub 1 (e x)\n⊢ Function.Bijective ⇑(Pi.ringHom fun i => Ideal.Quotient.mk (Ideal.span (Singleton.singleton (e i))))","decl":"lemma CompleteOrthogonalIdempotents.bijective_pi' (he : CompleteOrthogonalIdempotents (1 - e ·)) :\n    Function.Bijective (Pi.ringHom fun i ↦ Ideal.Quotient.mk (Ideal.span {e i})) := by\n  obtain ⟨e', rfl, h⟩ : ∃ e' : I → R, (e' = e) ∧ Function.Bijective (Pi.ringHom fun i ↦\n      Ideal.Quotient.mk (Ideal.span {e' i})) := ⟨_, funext (by simp), he.bijective_pi⟩\n  exact h\n\n"}
{"name":"bijective_pi_of_isIdempotentElem","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Type u_3\ninst✝ : Fintype I\ne : I → R\nhe : ∀ (i : I), IsIdempotentElem (e i)\nhe₁ : ∀ (i j : I), Ne i j → Eq (HMul.hMul (HSub.hSub 1 (e i)) (HSub.hSub 1 (e j))) 0\nhe₂ : Eq (Finset.univ.prod fun i => e i) 0\n⊢ Function.Bijective ⇑(Pi.ringHom fun i => Ideal.Quotient.mk (Ideal.span (Singleton.singleton (e i))))","decl":"lemma bijective_pi_of_isIdempotentElem (e : I → R)\n    (he : ∀ i, IsIdempotentElem (e i))\n    (he₁ : ∀ i j, i ≠ j → (1 - e i) * (1 - e j) = 0) (he₂ : ∏ i, e i = 0) :\n    Function.Bijective (Pi.ringHom fun i ↦ Ideal.Quotient.mk (Ideal.span {e i})) :=\n  (CompleteOrthogonalIdempotents.of_prod_one_sub\n      ⟨fun i ↦ (he i).one_sub, he₁⟩ (by simpa using he₂)).bijective_pi'\n\n"}
{"name":"Subsemigroup.mem_corner_iff","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ne : R\ninst✝ : Semigroup R\nidem : IsIdempotentElem e\nr : R\n⊢ Iff (Membership.mem (Subsemigroup.corner e) r) (And (Eq (HMul.hMul e r) r) (Eq (HMul.hMul r e) r))","decl":"lemma mem_corner_iff {r : R} : r ∈ corner e ↔ e * r = r ∧ r * e = r :=\n  ⟨by rintro ⟨r, rfl⟩; simp_rw [← mul_assoc, idem.eq, mul_assoc, idem.eq, true_and],\n    (⟨r, by simp_rw [·]⟩)⟩\n\n"}
{"name":"Subsemigroup.mem_corner_iff_mul_left","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ne : R\ninst✝ : Semigroup R\nidem : IsIdempotentElem e\nhc : IsMulCentral e\nr : R\n⊢ Iff (Membership.mem (Subsemigroup.corner e) r) (Eq (HMul.hMul e r) r)","decl":"lemma mem_corner_iff_mul_left (hc : IsMulCentral e) {r : R} : r ∈ corner e ↔ e * r = r := by\n  rw [mem_corner_iff idem, and_iff_left_of_imp]; intro; rwa [← hc.comm]\n\n"}
{"name":"Subsemigroup.mem_corner_iff_mul_right","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ne : R\ninst✝ : Semigroup R\nidem : IsIdempotentElem e\nhc : IsMulCentral e\nr : R\n⊢ Iff (Membership.mem (Subsemigroup.corner e) r) (Eq (HMul.hMul r e) r)","decl":"lemma mem_corner_iff_mul_right (hc : IsMulCentral e) {r : R} : r ∈ corner e ↔ r * e = r := by\n  rw [mem_corner_iff_mul_left idem hc, hc.comm]\n\n"}
{"name":"Subsemigroup.mem_corner_iff_mem_range_mul_left","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ne : R\ninst✝ : Semigroup R\nidem : IsIdempotentElem e\nhc : IsMulCentral e\nr : R\n⊢ Iff (Membership.mem (Subsemigroup.corner e) r) (Membership.mem (Set.range fun x => HMul.hMul e x) r)","decl":"lemma mem_corner_iff_mem_range_mul_left (hc : IsMulCentral e) {r : R} :\n    r ∈ corner e ↔ r ∈ Set.range (e * ·) := by\n  simp_rw [corner, mem_mk, Set.mem_range, ← hc.comm, ← mul_assoc, idem.eq]\n\n"}
{"name":"Subsemigroup.mem_corner_iff_mem_range_mul_right","module":"Mathlib.RingTheory.Idempotents","initialProofState":"R : Type u_1\ne : R\ninst✝ : Semigroup R\nidem : IsIdempotentElem e\nhc : IsMulCentral e\nr : R\n⊢ Iff (Membership.mem (Subsemigroup.corner e) r) (Membership.mem (Set.range fun x => HMul.hMul x e) r)","decl":"lemma mem_corner_iff_mem_range_mul_right (hc : IsMulCentral e) {r : R} :\n    r ∈ corner e ↔ r ∈ Set.range (· * e) := by\n  simp_rw [mem_corner_iff_mem_range_mul_left idem hc, hc.comm]\n\n"}
