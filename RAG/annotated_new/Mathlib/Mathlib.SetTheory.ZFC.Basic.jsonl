{"name":"PSet.mk.sizeOf_spec","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"α : Type u\nA : α → PSet.{u}\n⊢ Eq (SizeOf.sizeOf (PSet.mk α A)) (HAdd.hAdd 1 (SizeOf.sizeOf α))","decl":"/-- The type of pre-sets in universe `u`. A pre-set\n  is a family of pre-sets indexed by a type in `Type u`.\n  The ZFC universe is defined as a quotient of this\n  to ensure extensionality. -/\n@[pp_with_univ]\ninductive PSet : Type (u + 1)\n  | mk (α : Type u) (A : α → PSet) : PSet\n\n"}
{"name":"PSet.mk.inj","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"α✝ : Type u\nA✝ : α✝ → PSet.{u}\nα : Type u\nA : α → PSet.{u}\nx✝ : Eq (PSet.mk α✝ A✝) (PSet.mk α A)\n⊢ And (Eq α✝ α) (HEq A✝ A)","decl":"/-- The type of pre-sets in universe `u`. A pre-set\n  is a family of pre-sets indexed by a type in `Type u`.\n  The ZFC universe is defined as a quotient of this\n  to ensure extensionality. -/\n@[pp_with_univ]\ninductive PSet : Type (u + 1)\n  | mk (α : Type u) (A : α → PSet) : PSet\n\n"}
{"name":"PSet.mk.injEq","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"α✝ : Type u\nA✝ : α✝ → PSet.{u}\nα : Type u\nA : α → PSet.{u}\n⊢ Eq (Eq (PSet.mk α✝ A✝) (PSet.mk α A)) (And (Eq α✝ α) (HEq A✝ A))","decl":"/-- The type of pre-sets in universe `u`. A pre-set\n  is a family of pre-sets indexed by a type in `Type u`.\n  The ZFC universe is defined as a quotient of this\n  to ensure extensionality. -/\n@[pp_with_univ]\ninductive PSet : Type (u + 1)\n  | mk (α : Type u) (A : α → PSet) : PSet\n\n"}
{"name":"PSet.mk_type","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"α : Type u_1\nA : α → PSet.{u_1}\n⊢ Eq (PSet.mk α A).Type α","decl":"@[simp]\ntheorem mk_type (α A) : «Type» ⟨α, A⟩ = α :=\n  rfl\n\n"}
{"name":"PSet.mk_func","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"α : Type u_1\nA : α → PSet.{u_1}\n⊢ Eq (PSet.mk α A).Func A","decl":"@[simp]\ntheorem mk_func (α A) : Func ⟨α, A⟩ = A :=\n  rfl\n\n"}
{"name":"PSet.eta","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\n⊢ Eq (PSet.mk x.Type x.Func) x","decl":"@[simp]\ntheorem eta : ∀ x : PSet, mk x.Type x.Func = x\n  | ⟨_, _⟩ => rfl\n\n"}
{"name":"PSet.equiv_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\ny : PSet.{u_2}\n⊢ Iff (x.Equiv y) (And (∀ (i : x.Type), Exists fun j => (x.Func i).Equiv (y.Func j)) (∀ (j : y.Type), Exists fun i => (x.Func i).Equiv (y.Func j)))","decl":"theorem equiv_iff :\n    ∀ {x y : PSet},\n      Equiv x y ↔ (∀ i, ∃ j, Equiv (x.Func i) (y.Func j)) ∧ ∀ j, ∃ i, Equiv (x.Func i) (y.Func j)\n  | ⟨_, _⟩, ⟨_, _⟩ => Iff.rfl\n\n"}
{"name":"PSet.Equiv.exists_left","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\ny : PSet.{u_2}\nh : x.Equiv y\ni : x.Type\n⊢ Exists fun j => (x.Func i).Equiv (y.Func j)","decl":"theorem Equiv.exists_left {x y : PSet} (h : Equiv x y) : ∀ i, ∃ j, Equiv (x.Func i) (y.Func j) :=\n  (equiv_iff.1 h).1\n\n"}
{"name":"PSet.Equiv.exists_right","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\ny : PSet.{u_2}\nh : x.Equiv y\nj : y.Type\n⊢ Exists fun i => (x.Func i).Equiv (y.Func j)","decl":"theorem Equiv.exists_right {x y : PSet} (h : Equiv x y) : ∀ j, ∃ i, Equiv (x.Func i) (y.Func j) :=\n  (equiv_iff.1 h).2\n\n"}
{"name":"PSet.Equiv.refl","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\n⊢ x.Equiv x","decl":"@[refl]\nprotected theorem Equiv.refl : ∀ x, Equiv x x\n  | ⟨_, _⟩ => ⟨fun a => ⟨a, Equiv.refl _⟩, fun a => ⟨a, Equiv.refl _⟩⟩\n\n"}
{"name":"PSet.Equiv.rfl","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\n⊢ x.Equiv x","decl":"protected theorem Equiv.rfl {x} : Equiv x x :=\n  Equiv.refl x\n\n"}
{"name":"PSet.Equiv.euc","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\ny : PSet.{u_2}\nz : PSet.{u_3}\na✝¹ : x.Equiv y\na✝ : z.Equiv y\n⊢ x.Equiv z","decl":"protected theorem Equiv.euc : ∀ {x y z}, Equiv x y → Equiv z y → Equiv x z\n  | ⟨_, _⟩, ⟨_, _⟩, ⟨_, _⟩, ⟨αβ, βα⟩, ⟨γβ, βγ⟩ =>\n    ⟨ fun a =>\n        let ⟨b, ab⟩ := αβ a\n        let ⟨c, bc⟩ := βγ b\n        ⟨c, Equiv.euc ab bc⟩,\n      fun c =>\n        let ⟨b, cb⟩ := γβ c\n        let ⟨a, ba⟩ := βα b\n        ⟨a, Equiv.euc ba cb⟩ ⟩\n\n"}
{"name":"PSet.Equiv.symm","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\ny : PSet.{u_2}\na✝ : x.Equiv y\n⊢ y.Equiv x","decl":"@[symm]\nprotected theorem Equiv.symm {x y} : Equiv x y → Equiv y x :=\n  (Equiv.refl y).euc\n\n"}
{"name":"PSet.Equiv.comm","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\ny : PSet.{u_2}\n⊢ Iff (x.Equiv y) (y.Equiv x)","decl":"protected theorem Equiv.comm {x y} : Equiv x y ↔ Equiv y x :=\n  ⟨Equiv.symm, Equiv.symm⟩\n\n"}
{"name":"PSet.Equiv.trans","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\ny : PSet.{u_2}\nz : PSet.{u_3}\nh1 : x.Equiv y\nh2 : y.Equiv z\n⊢ x.Equiv z","decl":"@[trans]\nprotected theorem Equiv.trans {x y z} (h1 : Equiv x y) (h2 : Equiv y z) : Equiv x z :=\n  h1.euc h2.symm\n\n"}
{"name":"PSet.equiv_of_isEmpty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\ny : PSet.{u_2}\ninst✝¹ : IsEmpty x.Type\ninst✝ : IsEmpty y.Type\n⊢ x.Equiv y","decl":"protected theorem equiv_of_isEmpty (x y : PSet) [IsEmpty x.Type] [IsEmpty y.Type] : Equiv x y :=\n  equiv_iff.2 <| by simp\n\n"}
{"name":"PSet.instIsReflSubset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ IsRefl PSet.{u_1} fun x1 x2 => HasSubset.Subset x1 x2","decl":"instance : IsRefl PSet (· ⊆ ·) :=\n  ⟨fun _ a => ⟨a, Equiv.refl _⟩⟩\n\n"}
{"name":"PSet.instIsTransSubset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ IsTrans PSet.{u_1} fun x1 x2 => HasSubset.Subset x1 x2","decl":"instance : IsTrans PSet (· ⊆ ·) :=\n  ⟨fun x y z hxy hyz a => by\n    cases' hxy a with b hb\n    cases' hyz b with c hc\n    exact ⟨c, hb.trans hc⟩⟩\n\n"}
{"name":"PSet.Equiv.ext","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\n⊢ Iff (x.Equiv y) (And (HasSubset.Subset x y) (HasSubset.Subset y x))","decl":"theorem Equiv.ext : ∀ x y : PSet, Equiv x y ↔ x ⊆ y ∧ y ⊆ x\n  | ⟨_, _⟩, ⟨_, _⟩ =>\n    ⟨fun ⟨αβ, βα⟩ =>\n      ⟨αβ, fun b =>\n        let ⟨a, h⟩ := βα b\n        ⟨a, Equiv.symm h⟩⟩,\n      fun ⟨αβ, βα⟩ =>\n      ⟨αβ, fun b =>\n        let ⟨a, h⟩ := βα b\n        ⟨a, Equiv.symm h⟩⟩⟩\n\n"}
{"name":"PSet.Subset.congr_left","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : PSet.{u_1}\na✝ : x.Equiv y\n⊢ Iff (HasSubset.Subset x z) (HasSubset.Subset y z)","decl":"theorem Subset.congr_left : ∀ {x y z : PSet}, Equiv x y → (x ⊆ z ↔ y ⊆ z)\n  | ⟨_, _⟩, ⟨_, _⟩, ⟨_, _⟩, ⟨αβ, βα⟩ =>\n    ⟨fun αγ b =>\n      let ⟨a, ba⟩ := βα b\n      let ⟨c, ac⟩ := αγ a\n      ⟨c, (Equiv.symm ba).trans ac⟩,\n      fun βγ a =>\n      let ⟨b, ab⟩ := αβ a\n      let ⟨c, bc⟩ := βγ b\n      ⟨c, Equiv.trans ab bc⟩⟩\n\n"}
{"name":"PSet.Subset.congr_right","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : PSet.{u_1}\na✝ : x.Equiv y\n⊢ Iff (HasSubset.Subset z x) (HasSubset.Subset z y)","decl":"theorem Subset.congr_right : ∀ {x y z : PSet}, Equiv x y → (z ⊆ x ↔ z ⊆ y)\n  | ⟨_, _⟩, ⟨_, _⟩, ⟨_, _⟩, ⟨αβ, βα⟩ =>\n    ⟨fun γα c =>\n      let ⟨a, ca⟩ := γα c\n      let ⟨b, ab⟩ := αβ a\n      ⟨b, ca.trans ab⟩,\n      fun γβ c =>\n      let ⟨b, cb⟩ := γβ c\n      let ⟨a, ab⟩ := βα b\n      ⟨a, cb.trans (Equiv.symm ab)⟩⟩\n\n"}
{"name":"PSet.Mem.mk","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"α : Type u\nA : α → PSet.{u}\na : α\n⊢ Membership.mem (PSet.mk α A) (A a)","decl":"theorem Mem.mk {α : Type u} (A : α → PSet) (a : α) : A a ∈ mk α A :=\n  ⟨a, Equiv.refl (A a)⟩\n\n"}
{"name":"PSet.func_mem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\ni : x.Type\n⊢ Membership.mem x (x.Func i)","decl":"theorem func_mem (x : PSet) (i : x.Type) : x.Func i ∈ x := by\n  cases x\n  apply Mem.mk\n\n"}
{"name":"PSet.Mem.ext","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u}\na✝ : ∀ (w : PSet.{u}), Iff (Membership.mem x w) (Membership.mem y w)\n⊢ x.Equiv y","decl":"theorem Mem.ext : ∀ {x y : PSet.{u}}, (∀ w : PSet.{u}, w ∈ x ↔ w ∈ y) → Equiv x y\n  | ⟨_, A⟩, ⟨_, B⟩, h =>\n    ⟨fun a => (h (A a)).1 (Mem.mk A a), fun b =>\n      let ⟨a, ha⟩ := (h (B b)).2 (Mem.mk B b)\n      ⟨a, ha.symm⟩⟩\n\n"}
{"name":"PSet.Mem.congr_right","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u}\na✝ : x.Equiv y\nw : PSet.{u}\n⊢ Iff (Membership.mem x w) (Membership.mem y w)","decl":"theorem Mem.congr_right : ∀ {x y : PSet.{u}}, Equiv x y → ∀ {w : PSet.{u}}, w ∈ x ↔ w ∈ y\n  | ⟨_, _⟩, ⟨_, _⟩, ⟨αβ, βα⟩, _ =>\n    ⟨fun ⟨a, ha⟩ =>\n      let ⟨b, hb⟩ := αβ a\n      ⟨b, ha.trans hb⟩,\n      fun ⟨b, hb⟩ =>\n      let ⟨a, ha⟩ := βα b\n      ⟨a, hb.euc ha⟩⟩\n\n"}
{"name":"PSet.equiv_iff_mem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u}\n⊢ Iff (x.Equiv y) (∀ {w : PSet.{u}}, Iff (Membership.mem x w) (Membership.mem y w))","decl":"theorem equiv_iff_mem {x y : PSet.{u}} : Equiv x y ↔ ∀ {w : PSet.{u}}, w ∈ x ↔ w ∈ y :=\n  ⟨Mem.congr_right,\n    match x, y with\n    | ⟨_, A⟩, ⟨_, B⟩ => fun h =>\n      ⟨fun a => h.1 (Mem.mk A a), fun b =>\n        let ⟨a, h⟩ := h.2 (Mem.mk B b)\n        ⟨a, h.symm⟩⟩⟩\n\n"}
{"name":"PSet.Mem.congr_left","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u}\na✝ : x.Equiv y\nw : PSet.{u}\n⊢ Iff (Membership.mem w x) (Membership.mem w y)","decl":"theorem Mem.congr_left : ∀ {x y : PSet.{u}}, Equiv x y → ∀ {w : PSet.{u}}, x ∈ w ↔ y ∈ w\n  | _, _, h, ⟨_, _⟩ => ⟨fun ⟨a, ha⟩ => ⟨a, h.symm.trans ha⟩, fun ⟨a, ha⟩ => ⟨a, h.trans ha⟩⟩\n\n"}
{"name":"PSet.mem_of_subset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : PSet.{u_1}\na✝¹ : HasSubset.Subset x y\na✝ : Membership.mem x z\n⊢ Membership.mem y z","decl":"theorem mem_of_subset {x y z : PSet} : x ⊆ y → z ∈ x → z ∈ y\n  | h₁, ⟨a, h₂⟩ => (h₁ a).elim fun b h₃ => ⟨b, h₂.trans h₃⟩\n\n"}
{"name":"PSet.subset_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\n⊢ Iff (HasSubset.Subset x y) (∀ ⦃z : PSet.{u_1}⦄, Membership.mem x z → Membership.mem y z)","decl":"theorem subset_iff {x y : PSet} : x ⊆ y ↔ ∀ ⦃z⦄, z ∈ x → z ∈ y :=\n  ⟨fun h _ => mem_of_subset h, fun h a => h (Mem.mk _ a)⟩\n\n"}
{"name":"PSet.mem_wf","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ WellFounded fun x1 x2 => Membership.mem x2 x1","decl":"theorem mem_wf : @WellFounded PSet (· ∈ ·) :=\n  ⟨fun x => mem_wf_aux <| Equiv.refl x⟩\n\n"}
{"name":"PSet.instIsWellFoundedMem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ IsWellFounded PSet.{u_1} fun x1 x2 => Membership.mem x2 x1","decl":"instance : IsWellFounded PSet (· ∈ ·) :=\n  ⟨mem_wf⟩\n\n"}
{"name":"PSet.mem_asymm","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\na✝ : Membership.mem y x\n⊢ Not (Membership.mem x y)","decl":"theorem mem_asymm {x y : PSet} : x ∈ y → y ∉ x :=\n  asymm_of (· ∈ ·)\n\n"}
{"name":"PSet.mem_irrefl","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\n⊢ Not (Membership.mem x x)","decl":"theorem mem_irrefl (x : PSet) : x ∉ x :=\n  irrefl_of (· ∈ ·) x\n\n"}
{"name":"PSet.not_subset_of_mem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\nh : Membership.mem y x\n⊢ Not (HasSubset.Subset y x)","decl":"theorem not_subset_of_mem {x y : PSet} (h : x ∈ y) : ¬ y ⊆ x :=\n  fun h' ↦ mem_irrefl _ <| mem_of_subset h' h\n\n"}
{"name":"PSet.not_mem_of_subset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\nh : HasSubset.Subset x y\n⊢ Not (Membership.mem x y)","decl":"theorem not_mem_of_subset {x y : PSet} (h : x ⊆ y) : y ∉ x :=\n  imp_not_comm.2 not_subset_of_mem h\n\n"}
{"name":"PSet.mem_toSet","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"a u : PSet.{u}\n⊢ Iff (Membership.mem u.toSet a) (Membership.mem u a)","decl":"@[simp]\ntheorem mem_toSet (a u : PSet.{u}) : a ∈ u.toSet ↔ a ∈ u :=\n  Iff.rfl\n\n"}
{"name":"PSet.nonempty_def","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"u : PSet.{u_1}\n⊢ Iff u.Nonempty (Exists fun x => Membership.mem u x)","decl":"theorem nonempty_def (u : PSet) : u.Nonempty ↔ ∃ x, x ∈ u :=\n  Iff.rfl\n\n"}
{"name":"PSet.nonempty_of_mem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x u : PSet.{u_1}\nh : Membership.mem u x\n⊢ u.Nonempty","decl":"theorem nonempty_of_mem {x u : PSet} (h : x ∈ u) : u.Nonempty :=\n  ⟨x, h⟩\n\n"}
{"name":"PSet.nonempty_toSet_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"u : PSet.{u_1}\n⊢ Iff u.toSet.Nonempty u.Nonempty","decl":"@[simp]\ntheorem nonempty_toSet_iff {u : PSet} : u.toSet.Nonempty ↔ u.Nonempty :=\n  Iff.rfl\n\n"}
{"name":"PSet.nonempty_type_iff_nonempty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\n⊢ Iff (Nonempty x.Type) x.Nonempty","decl":"theorem nonempty_type_iff_nonempty {x : PSet} : Nonempty x.Type ↔ PSet.Nonempty x :=\n  ⟨fun ⟨i⟩ => ⟨_, func_mem _ i⟩, fun ⟨_, j, _⟩ => ⟨j⟩⟩\n\n"}
{"name":"PSet.nonempty_of_nonempty_type","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\nh : Nonempty x.Type\n⊢ x.Nonempty","decl":"theorem nonempty_of_nonempty_type (x : PSet) [h : Nonempty x.Type] : PSet.Nonempty x :=\n  nonempty_type_iff_nonempty.1 h\n\n"}
{"name":"PSet.Equiv.eq","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\n⊢ Iff (x.Equiv y) (Eq x.toSet y.toSet)","decl":"/-- Two pre-sets are equivalent iff they have the same members. -/\ntheorem Equiv.eq {x y : PSet} : Equiv x y ↔ toSet x = toSet y :=\n  equiv_iff_mem.trans Set.ext_iff.symm\n\n"}
{"name":"PSet.instIsEmptyTypeEmptyCollection","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ IsEmpty EmptyCollection.emptyCollection.Type","decl":"instance : IsEmpty («Type» ∅) :=\n  ⟨PEmpty.elim⟩\n\n"}
{"name":"PSet.empty_def","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Eq EmptyCollection.emptyCollection (PSet.mk PEmpty.{u_1 + 1} PEmpty.elim)","decl":"theorem empty_def : (∅ : PSet) = ⟨_, PEmpty.elim⟩ := by\n  simp [EmptyCollection.emptyCollection, PSet.empty]\n\n"}
{"name":"PSet.not_mem_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u}\n⊢ Not (Membership.mem EmptyCollection.emptyCollection x)","decl":"@[simp]\ntheorem not_mem_empty (x : PSet.{u}) : x ∉ (∅ : PSet.{u}) :=\n  IsEmpty.exists_iff.1\n\n"}
{"name":"PSet.toSet_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Eq EmptyCollection.emptyCollection.toSet EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem toSet_empty : toSet ∅ = ∅ := by simp [toSet]\n\n"}
{"name":"PSet.empty_subset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u}\n⊢ HasSubset.Subset EmptyCollection.emptyCollection x","decl":"@[simp]\ntheorem empty_subset (x : PSet.{u}) : (∅ : PSet) ⊆ x := fun x => x.elim\n\n"}
{"name":"PSet.not_nonempty_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Not EmptyCollection.emptyCollection.Nonempty","decl":"@[simp]\ntheorem not_nonempty_empty : ¬PSet.Nonempty ∅ := by simp [PSet.Nonempty]\n\n"}
{"name":"PSet.equiv_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\ninst✝ : IsEmpty x.Type\n⊢ x.Equiv EmptyCollection.emptyCollection","decl":"protected theorem equiv_empty (x : PSet) [IsEmpty x.Type] : Equiv x ∅ :=\n  PSet.equiv_of_isEmpty x _\n\n"}
{"name":"PSet.instLawfulSingleton","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ LawfulSingleton PSet.{u_1} PSet.{u_1}","decl":"instance : LawfulSingleton PSet PSet :=\n  ⟨fun _ => rfl⟩\n\n"}
{"name":"PSet.mem_insert_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : PSet.{u}\n⊢ Iff (Membership.mem (Insert.insert y z) x) (Or (x.Equiv y) (Membership.mem z x))","decl":"@[simp]\ntheorem mem_insert_iff : ∀ {x y z : PSet.{u}}, x ∈ insert y z ↔ Equiv x y ∨ x ∈ z\n  | x, y, ⟨α, A⟩ =>\n    show (x ∈ PSet.mk (Option α) fun o => Option.rec y A o) ↔ Equiv x y ∨ x ∈ PSet.mk α A from\n      ⟨fun m =>\n        match m with\n        | ⟨some a, ha⟩ => Or.inr ⟨a, ha⟩\n        | ⟨none, h⟩ => Or.inl h,\n        fun m =>\n        match m with\n        | Or.inr ⟨a, ha⟩ => ⟨some a, ha⟩\n        | Or.inl h => ⟨none, h⟩⟩\n\n"}
{"name":"PSet.mem_insert","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\n⊢ Membership.mem (Insert.insert x y) x","decl":"theorem mem_insert (x y : PSet) : x ∈ insert x y :=\n  mem_insert_iff.2 <| Or.inl Equiv.rfl\n\n"}
{"name":"PSet.mem_insert_of_mem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"y z x : PSet.{u_1}\nh : Membership.mem y z\n⊢ Membership.mem (Insert.insert x y) z","decl":"theorem mem_insert_of_mem {y z : PSet} (x) (h : z ∈ y) : z ∈ insert x y :=\n  mem_insert_iff.2 <| Or.inr h\n\n"}
{"name":"PSet.mem_singleton","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\n⊢ Iff (Membership.mem (Singleton.singleton y) x) (x.Equiv y)","decl":"@[simp]\ntheorem mem_singleton {x y : PSet} : x ∈ ({y} : PSet) ↔ Equiv x y :=\n  mem_insert_iff.trans\n    ⟨fun o => Or.rec id (fun n => absurd n (not_mem_empty _)) o, Or.inl⟩\n\n"}
{"name":"PSet.mem_pair","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : PSet.{u_1}\n⊢ Iff (Membership.mem (Insert.insert y (Singleton.singleton z)) x) (Or (x.Equiv y) (x.Equiv z))","decl":"theorem mem_pair {x y z : PSet} : x ∈ ({y, z} : PSet) ↔ Equiv x y ∨ Equiv x z := by\n  simp\n\n"}
{"name":"PSet.mem_sep","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"p : PSet.{u_1} → Prop\nH : ∀ (x y : PSet.{u_1}), x.Equiv y → p x → p y\nx y : PSet.{u_1}\n⊢ Iff (Membership.mem (PSet.sep p x) y) (And (Membership.mem x y) (p y))","decl":"theorem mem_sep {p : PSet → Prop} (H : ∀ x y, Equiv x y → p x → p y) :\n    ∀ {x y : PSet}, y ∈ PSet.sep p x ↔ y ∈ x ∧ p y\n  | ⟨_, _⟩, _ =>\n    ⟨fun ⟨⟨a, pa⟩, h⟩ => ⟨⟨a, h⟩, H _ _ h.symm pa⟩, fun ⟨⟨a, h⟩, pa⟩ =>\n      ⟨⟨a, H _ _ h pa⟩, h⟩⟩\n\n"}
{"name":"PSet.mem_powerset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\n⊢ Iff (Membership.mem x.powerset y) (HasSubset.Subset y x)","decl":"@[simp]\ntheorem mem_powerset : ∀ {x y : PSet}, y ∈ powerset x ↔ y ⊆ x\n  | ⟨_, A⟩, ⟨_, B⟩ =>\n    ⟨fun ⟨_, e⟩ => (Subset.congr_left e).2 fun ⟨a, _⟩ => ⟨a, Equiv.refl (A a)⟩, fun βα =>\n      ⟨{ a | ∃ b, Equiv (B b) (A a) }, fun b =>\n        let ⟨a, ba⟩ := βα b\n        ⟨⟨a, b, ba⟩, ba⟩,\n        fun ⟨_, b, ba⟩ => ⟨b, ba⟩⟩⟩\n\n"}
{"name":"PSet.mem_sUnion","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u}\n⊢ Iff (Membership.mem x.sUnion y) (Exists fun z => And (Membership.mem x z) (Membership.mem z y))","decl":"@[simp]\ntheorem mem_sUnion : ∀ {x y : PSet.{u}}, y ∈ ⋃₀ x ↔ ∃ z ∈ x, y ∈ z\n  | ⟨α, A⟩, y =>\n    ⟨fun ⟨⟨a, c⟩, (e : Equiv y ((A a).Func c))⟩ =>\n      have : Func (A a) c ∈ mk (A a).Type (A a).Func := Mem.mk (A a).Func c\n      ⟨_, Mem.mk _ _, (Mem.congr_left e).2 (by rwa [eta] at this)⟩,\n      fun ⟨⟨β, B⟩, ⟨a, (e : Equiv (mk β B) (A a))⟩, ⟨b, yb⟩⟩ => by\n      rw [← eta (A a)] at e\n      exact\n        let ⟨βt, _⟩ := e\n        let ⟨c, bc⟩ := βt b\n        ⟨⟨a, c⟩, yb.trans bc⟩⟩\n\n"}
{"name":"PSet.toSet_sUnion","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u}\n⊢ Eq x.sUnion.toSet (Set.image PSet.toSet x.toSet).sUnion","decl":"@[simp]\ntheorem toSet_sUnion (x : PSet.{u}) : (⋃₀ x).toSet = ⋃₀ (toSet '' x.toSet) := by\n  ext\n  simp\n\n"}
{"name":"PSet.mem_image","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"f : PSet.{u} → PSet.{u}\nH : ∀ (x y : PSet.{u}), x.Equiv y → (f x).Equiv (f y)\nx y : PSet.{u}\n⊢ Iff (Membership.mem (PSet.image f x) y) (Exists fun z => And (Membership.mem x z) (y.Equiv (f z)))","decl":"theorem mem_image {f : PSet.{u} → PSet.{u}} (H : ∀ x y, Equiv x y → Equiv (f x) (f y)) :\n    ∀ {x y : PSet.{u}}, y ∈ image f x ↔ ∃ z ∈ x, Equiv y (f z)\n  | ⟨_, A⟩, _ =>\n    ⟨fun ⟨a, ya⟩ => ⟨A a, Mem.mk A a, ya⟩, fun ⟨_, ⟨a, za⟩, yz⟩ => ⟨a, yz.trans <| H _ _ za⟩⟩\n\n"}
{"name":"PSet.lift_mem_embed","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u}\n⊢ Membership.mem PSet.embed x.Lift","decl":"theorem lift_mem_embed : ∀ x : PSet.{u}, PSet.Lift.{u, max (u + 1) v} x ∈ embed.{u, v} := fun x =>\n  ⟨⟨x⟩, Equiv.rfl⟩\n\n"}
{"name":"PSet.Arity.equiv_const","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"a : PSet.{u}\nn : Nat\n⊢ PSet.Arity.Equiv (Function.OfArity.const PSet.{u} a n) (Function.OfArity.const PSet.{u} a n)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-09-02\")]\ntheorem Arity.equiv_const {a : PSet.{u}} :\n    ∀ n, Arity.Equiv (OfArity.const PSet.{u} a n) (OfArity.const PSet.{u} a n)\n  | 0 => Equiv.rfl\n  | _ + 1 => fun _ _ _ => Arity.equiv_const _\n\n"}
{"name":"PSet.Resp.Equiv.refl","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"n : Nat\na : PSet.Resp n\n⊢ a.Equiv a","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-09-02\"), refl]\nprotected theorem Resp.Equiv.refl {n} (a : Resp n) : Resp.Equiv a a :=\n  a.2\n\n"}
{"name":"PSet.Resp.Equiv.euc","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"n : Nat\na b c : PSet.Resp n\na✝¹ : a.Equiv b\na✝ : c.Equiv b\n⊢ a.Equiv c","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-09-02\")]\nprotected theorem Resp.Equiv.euc :\n    ∀ {n} {a b c : Resp n}, Resp.Equiv a b → Resp.Equiv c b → Resp.Equiv a c\n  | 0, _, _, _, hab, hcb => PSet.Equiv.euc hab hcb\n  | n + 1, a, b, c, hab, hcb => fun x y h =>\n    @Resp.Equiv.euc n (a.f x) (b.f y) (c.f y) (hab _ _ h) (hcb _ _ <| PSet.Equiv.refl y)\n\n"}
{"name":"PSet.Resp.Equiv.symm","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"n : Nat\na b : PSet.Resp n\na✝ : a.Equiv b\n⊢ b.Equiv a","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-09-02\"), symm]\nprotected theorem Resp.Equiv.symm {n} {a b : Resp n} : Resp.Equiv a b → Resp.Equiv b a :=\n  (Resp.Equiv.refl b).euc\n\n"}
{"name":"PSet.Resp.Equiv.trans","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"n : Nat\nx y z : PSet.Resp n\nh1 : x.Equiv y\nh2 : y.Equiv z\n⊢ x.Equiv z","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-09-02\"), trans]\nprotected theorem Resp.Equiv.trans {n} {x y z : Resp n} (h1 : Resp.Equiv x y)\n    (h2 : Resp.Equiv y z) : Resp.Equiv x z :=\n  h1.euc h2.symm\n\n"}
{"name":"ZFSet.mk_eq","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\n⊢ Eq (Quotient.mk PSet.setoid x) (ZFSet.mk x)","decl":"@[simp]\ntheorem mk_eq (x : PSet) : @Eq ZFSet ⟦x⟧ (mk x) :=\n  rfl\n\n"}
{"name":"ZFSet.mk_out","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u_1}\n⊢ Eq (ZFSet.mk (Quotient.out x)) x","decl":"@[simp]\ntheorem mk_out : ∀ x : ZFSet, mk x.out = x :=\n  Quotient.out_eq\n\n"}
{"name":"ZFSet.Definable.mk_out","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"n : Nat\nf : (Fin n → ZFSet.{u}) → ZFSet.{u}\nself : ZFSet.Definable n f\nxs : Fin n → PSet.{u}\n⊢ Eq (ZFSet.mk (ZFSet.Definable.out f xs)) (f fun x => ZFSet.mk (xs x))","decl":"/-- A set function is \"definable\" if it is the image of some n-ary `PSet`\n  function. This isn't exactly definability, but is useful as a sufficient\n  condition for functions that have a computable image. -/\nclass Definable (n) (f : (Fin n → ZFSet.{u}) → ZFSet.{u}) where\n  /-- Turns a definable function into an n-ary `PSet` function. -/\n  out : (Fin n → PSet.{u}) → PSet.{u}\n  /-- A set function `f` is the image of `Definable.out f`. -/\n  mk_out xs : mk (out xs) = f (mk <| xs ·) := by simp\n\n"}
{"name":"ZFSet.Definable₁.mk_out","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"f : ZFSet.{u} → ZFSet.{u}\ninst✝ : ZFSet.Definable₁ f\nx : PSet.{u}\n⊢ Eq (ZFSet.mk (ZFSet.Definable₁.out f x)) (f (ZFSet.mk x))","decl":"lemma Definable₁.mk_out {f : ZFSet.{u} → ZFSet.{u}} [Definable₁ f]\n    {x : PSet} :\n    .mk (out f x) = f (.mk x) :=\n  Definable.mk_out ![x]\n\n"}
{"name":"ZFSet.Definable₂.mk_out","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"f : ZFSet.{u} → ZFSet.{u} → ZFSet.{u}\ninst✝ : ZFSet.Definable₂ f\nx y : PSet.{u}\n⊢ Eq (ZFSet.mk (ZFSet.Definable₂.out f x y)) (f (ZFSet.mk x) (ZFSet.mk y))","decl":"lemma Definable₂.mk_out {f : ZFSet.{u} → ZFSet.{u} → ZFSet.{u}} [Definable₂ f]\n    {x y : PSet} :\n    .mk (out f x y) = f (.mk x) (.mk y) :=\n  Definable.mk_out ![x, y]\n\n"}
{"name":"ZFSet.Definable.out_equiv","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"n : Nat\nf : (Fin n → ZFSet.{u}) → ZFSet.{u}\ninst✝ : ZFSet.Definable n f\nxs ys : Fin n → PSet.{u}\nh : ∀ (i : Fin n), HasEquiv.Equiv (xs i) (ys i)\n⊢ HasEquiv.Equiv (ZFSet.Definable.out f xs) (ZFSet.Definable.out f ys)","decl":"lemma Definable.out_equiv {n} (f : (Fin n → ZFSet.{u}) → ZFSet.{u}) [Definable n f]\n    {xs ys : Fin n → PSet} (h : ∀ i, xs i ≈ ys i) :\n    out f xs ≈ out f ys := by\n  rw [← Quotient.eq_iff_equiv, mk_eq, mk_eq, mk_out, mk_out]\n  exact congrArg _ (funext fun i ↦ Quotient.sound (h i))\n\n"}
{"name":"ZFSet.Definable₁.out_equiv","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"f : ZFSet.{u} → ZFSet.{u}\ninst✝ : ZFSet.Definable₁ f\nx y : PSet.{u}\nh : HasEquiv.Equiv x y\n⊢ HasEquiv.Equiv (ZFSet.Definable₁.out f x) (ZFSet.Definable₁.out f y)","decl":"lemma Definable₁.out_equiv (f : ZFSet.{u} → ZFSet.{u}) [Definable₁ f]\n    {x y : PSet} (h : x ≈ y) :\n    out f x ≈ out f y :=\n  Definable.out_equiv _ (by simp [h])\n\n"}
{"name":"ZFSet.Definable₂.out_equiv","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"f : ZFSet.{u} → ZFSet.{u} → ZFSet.{u}\ninst✝ : ZFSet.Definable₂ f\nx₁ y₁ x₂ y₂ : PSet.{u}\nh₁ : HasEquiv.Equiv x₁ y₁\nh₂ : HasEquiv.Equiv x₂ y₂\n⊢ HasEquiv.Equiv (ZFSet.Definable₂.out f x₁ x₂) (ZFSet.Definable₂.out f y₁ y₂)","decl":"lemma Definable₂.out_equiv (f : ZFSet.{u} → ZFSet.{u} → ZFSet.{u}) [Definable₂ f]\n    {x₁ y₁ x₂ y₂ : PSet} (h₁ : x₁ ≈ y₁) (h₂ : x₂ ≈ y₂) :\n    out f x₁ x₂ ≈ out f y₁ y₂ :=\n  Definable.out_equiv _ (by simp [Fin.forall_fin_succ, h₁, h₂])\n\n"}
{"name":"PSet.Resp.eval_val","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"n : Nat\nf : PSet.Resp (HAdd.hAdd n 1)\nx : PSet.{u_1}\n⊢ Eq (PSet.Resp.eval (HAdd.hAdd n 1) f (Quotient.mk PSet.setoid x)) (PSet.Resp.eval n (f.f x))","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-09-02\")]\ntheorem eval_val {n f x} :\n    (@eval (n + 1) f : ZFSet → OfArity ZFSet ZFSet n) ⟦x⟧ = eval n (Resp.f f x) :=\n  rfl\n\n"}
{"name":"PSet.Definable.eq","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"n : Nat\ns : Function.OfArity ZFSet.{u} ZFSet.{u} n\nH : PSet.Definable n s\n⊢ Eq (PSet.Resp.eval n (PSet.Definable.Resp s)) s","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-09-02\")]\ntheorem Definable.eq {n} :\n    ∀ (s : OfArity ZFSet.{u} ZFSet.{u} n) [H : Definable n s], (@Definable.Resp n s H).eval _ = s\n  | _, ⟨_⟩ => rfl\n\n"}
{"name":"ZFSet.eq","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\n⊢ Iff (Eq (ZFSet.mk x) (ZFSet.mk y)) (x.Equiv y)","decl":"theorem eq {x y : PSet} : mk x = mk y ↔ Equiv x y :=\n  Quotient.eq\n\n"}
{"name":"ZFSet.sound","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\nh : x.Equiv y\n⊢ Eq (ZFSet.mk x) (ZFSet.mk y)","decl":"theorem sound {x y : PSet} (h : PSet.Equiv x y) : mk x = mk y :=\n  Quotient.sound h\n\n"}
{"name":"ZFSet.exact","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\na✝ : Eq (ZFSet.mk x) (ZFSet.mk y)\n⊢ x.Equiv y","decl":"theorem exact {x y : PSet} : mk x = mk y → PSet.Equiv x y :=\n  Quotient.exact\n\n"}
{"name":"ZFSet.eval_mk","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"n : Nat\nf : PSet.Resp (HAdd.hAdd n 1)\nx : PSet.{u_1}\n⊢ Eq (PSet.Resp.eval (HAdd.hAdd n 1) f (ZFSet.mk x)) (PSet.Resp.eval n (f.f x))","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-09-02\"), simp]\ntheorem eval_mk {n f x} :\n    (@Resp.eval (n + 1) f : ZFSet → OfArity ZFSet ZFSet n) (mk x) = Resp.eval n (Resp.f f x) :=\n  rfl\n\n"}
{"name":"ZFSet.mk_mem_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\n⊢ Iff (Membership.mem (ZFSet.mk y) (ZFSet.mk x)) (Membership.mem y x)","decl":"@[simp]\ntheorem mk_mem_iff {x y : PSet} : mk x ∈ mk y ↔ x ∈ y :=\n  Iff.rfl\n\n"}
{"name":"ZFSet.mem_toSet","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"a u : ZFSet.{u}\n⊢ Iff (Membership.mem u.toSet a) (Membership.mem u a)","decl":"@[simp]\ntheorem mem_toSet (a u : ZFSet.{u}) : a ∈ u.toSet ↔ a ∈ u :=\n  Iff.rfl\n\n"}
{"name":"ZFSet.small_toSet","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\n⊢ Small.{u, u + 1} ↑x.toSet","decl":"instance small_toSet (x : ZFSet.{u}) : Small.{u} x.toSet :=\n  Quotient.inductionOn x fun a => by\n    let f : a.Type → (mk a).toSet := fun i => ⟨mk <| a.Func i, func_mem a i⟩\n    suffices Function.Surjective f by exact small_of_surjective this\n    rintro ⟨y, hb⟩\n    induction y using Quotient.inductionOn\n    cases' hb with i h\n    exact ⟨i, Subtype.coe_injective (Quotient.sound h.symm)⟩\n\n"}
{"name":"ZFSet.nonempty_def","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"u : ZFSet.{u_1}\n⊢ Iff u.Nonempty (Exists fun x => Membership.mem u x)","decl":"theorem nonempty_def (u : ZFSet) : u.Nonempty ↔ ∃ x, x ∈ u :=\n  Iff.rfl\n\n"}
{"name":"ZFSet.nonempty_of_mem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x u : ZFSet.{u_1}\nh : Membership.mem u x\n⊢ u.Nonempty","decl":"theorem nonempty_of_mem {x u : ZFSet} (h : x ∈ u) : u.Nonempty :=\n  ⟨x, h⟩\n\n"}
{"name":"ZFSet.nonempty_toSet_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"u : ZFSet.{u_1}\n⊢ Iff u.toSet.Nonempty u.Nonempty","decl":"@[simp]\ntheorem nonempty_toSet_iff {u : ZFSet} : u.toSet.Nonempty ↔ u.Nonempty :=\n  Iff.rfl\n\n"}
{"name":"ZFSet.subset_def","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Iff (HasSubset.Subset x y) (∀ ⦃z : ZFSet.{u}⦄, Membership.mem x z → Membership.mem y z)","decl":"theorem subset_def {x y : ZFSet.{u}} : x ⊆ y ↔ ∀ ⦃z⦄, z ∈ x → z ∈ y :=\n  Iff.rfl\n\n"}
{"name":"ZFSet.instIsReflSubset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ IsRefl ZFSet.{u_1} fun x1 x2 => HasSubset.Subset x1 x2","decl":"instance : IsRefl ZFSet (· ⊆ ·) :=\n  ⟨fun _ _ => id⟩\n\n"}
{"name":"ZFSet.instIsTransSubset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ IsTrans ZFSet.{u_1} fun x1 x2 => HasSubset.Subset x1 x2","decl":"instance : IsTrans ZFSet (· ⊆ ·) :=\n  ⟨fun _ _ _ hxy hyz _ ha => hyz (hxy ha)⟩\n\n"}
{"name":"ZFSet.subset_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : PSet.{u_1}\n⊢ Iff (HasSubset.Subset (ZFSet.mk x) (ZFSet.mk y)) (HasSubset.Subset x y)","decl":"@[simp]\ntheorem subset_iff : ∀ {x y : PSet}, mk x ⊆ mk y ↔ x ⊆ y\n  | ⟨_, A⟩, ⟨_, _⟩ =>\n    ⟨fun h a => @h ⟦A a⟧ (Mem.mk A a), fun h z =>\n      Quotient.inductionOn z fun _ ⟨a, za⟩ =>\n        let ⟨b, ab⟩ := h a\n        ⟨b, za.trans ab⟩⟩\n\n"}
{"name":"ZFSet.toSet_subset_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u_1}\n⊢ Iff (HasSubset.Subset x.toSet y.toSet) (HasSubset.Subset x y)","decl":"@[simp]\ntheorem toSet_subset_iff {x y : ZFSet} : x.toSet ⊆ y.toSet ↔ x ⊆ y := by\n  simp [subset_def, Set.subset_def]\n\n"}
{"name":"ZFSet.ext_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Iff (Eq x y) (∀ (z : ZFSet.{u}), Iff (Membership.mem x z) (Membership.mem y z))","decl":"@[ext]\ntheorem ext {x y : ZFSet.{u}} : (∀ z : ZFSet.{u}, z ∈ x ↔ z ∈ y) → x = y :=\n  Quotient.inductionOn₂ x y fun _ _ h => Quotient.sound (Mem.ext fun w => h ⟦w⟧)\n\n"}
{"name":"ZFSet.ext","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\na✝ : ∀ (z : ZFSet.{u}), Iff (Membership.mem x z) (Membership.mem y z)\n⊢ Eq x y","decl":"@[ext]\ntheorem ext {x y : ZFSet.{u}} : (∀ z : ZFSet.{u}, z ∈ x ↔ z ∈ y) → x = y :=\n  Quotient.inductionOn₂ x y fun _ _ h => Quotient.sound (Mem.ext fun w => h ⟦w⟧)\n\n"}
{"name":"ZFSet.toSet_injective","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Function.Injective ZFSet.toSet","decl":"theorem toSet_injective : Function.Injective toSet := fun _ _ h => ext <| Set.ext_iff.1 h\n\n"}
{"name":"ZFSet.toSet_inj","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u_1}\n⊢ Iff (Eq x.toSet y.toSet) (Eq x y)","decl":"@[simp]\ntheorem toSet_inj {x y : ZFSet} : x.toSet = y.toSet ↔ x = y :=\n  toSet_injective.eq_iff\n\n"}
{"name":"ZFSet.instIsAntisymmSubset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ IsAntisymm ZFSet.{u_1} fun x1 x2 => HasSubset.Subset x1 x2","decl":"instance : IsAntisymm ZFSet (· ⊆ ·) :=\n  ⟨fun _ _ hab hba => ext fun c => ⟨@hab c, @hba c⟩⟩\n\n"}
{"name":"ZFSet.not_mem_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\n⊢ Not (Membership.mem EmptyCollection.emptyCollection x)","decl":"@[simp]\ntheorem not_mem_empty (x) : x ∉ (∅ : ZFSet.{u}) :=\n  Quotient.inductionOn x PSet.not_mem_empty\n\n"}
{"name":"ZFSet.toSet_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Eq EmptyCollection.emptyCollection.toSet EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem toSet_empty : toSet ∅ = ∅ := by simp [toSet]\n\n"}
{"name":"ZFSet.empty_subset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\n⊢ HasSubset.Subset EmptyCollection.emptyCollection x","decl":"@[simp]\ntheorem empty_subset (x : ZFSet.{u}) : (∅ : ZFSet) ⊆ x :=\n  Quotient.inductionOn x fun y => subset_iff.2 <| PSet.empty_subset y\n\n"}
{"name":"ZFSet.not_nonempty_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Not EmptyCollection.emptyCollection.Nonempty","decl":"@[simp]\ntheorem not_nonempty_empty : ¬ZFSet.Nonempty ∅ := by simp [ZFSet.Nonempty]\n\n"}
{"name":"ZFSet.nonempty_mk_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : PSet.{u_1}\n⊢ Iff (ZFSet.mk x).Nonempty x.Nonempty","decl":"@[simp]\ntheorem nonempty_mk_iff {x : PSet} : (mk x).Nonempty ↔ x.Nonempty := by\n  refine ⟨?_, fun ⟨a, h⟩ => ⟨mk a, h⟩⟩\n  rintro ⟨a, h⟩\n  induction a using Quotient.inductionOn\n  exact ⟨_, h⟩\n\n"}
{"name":"ZFSet.eq_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\n⊢ Iff (Eq x EmptyCollection.emptyCollection) (∀ (y : ZFSet.{u}), Not (Membership.mem x y))","decl":"theorem eq_empty (x : ZFSet.{u}) : x = ∅ ↔ ∀ y : ZFSet.{u}, y ∉ x := by\n  simp [ZFSet.ext_iff]\n\n"}
{"name":"ZFSet.eq_empty_or_nonempty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"u : ZFSet.{u_1}\n⊢ Or (Eq u EmptyCollection.emptyCollection) u.Nonempty","decl":"theorem eq_empty_or_nonempty (u : ZFSet) : u = ∅ ∨ u.Nonempty := by\n  rw [eq_empty, ← not_exists]\n  apply em'\n\n"}
{"name":"ZFSet.instLawfulSingleton","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ LawfulSingleton ZFSet.{u_1} ZFSet.{u_1}","decl":"instance : LawfulSingleton ZFSet ZFSet :=\n  ⟨fun _ => rfl⟩\n\n"}
{"name":"ZFSet.mem_insert_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : ZFSet.{u}\n⊢ Iff (Membership.mem (Insert.insert y z) x) (Or (Eq x y) (Membership.mem z x))","decl":"@[simp]\ntheorem mem_insert_iff {x y z : ZFSet.{u}} : x ∈ insert y z ↔ x = y ∨ x ∈ z :=\n  Quotient.inductionOn₃ x y z fun _ _ _ => PSet.mem_insert_iff.trans (or_congr_left eq.symm)\n\n"}
{"name":"ZFSet.mem_insert","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u_1}\n⊢ Membership.mem (Insert.insert x y) x","decl":"theorem mem_insert (x y : ZFSet) : x ∈ insert x y :=\n  mem_insert_iff.2 <| Or.inl rfl\n\n"}
{"name":"ZFSet.mem_insert_of_mem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"y z x : ZFSet.{u_1}\nh : Membership.mem y z\n⊢ Membership.mem (Insert.insert x y) z","decl":"theorem mem_insert_of_mem {y z : ZFSet} (x) (h : z ∈ y) : z ∈ insert x y :=\n  mem_insert_iff.2 <| Or.inr h\n\n"}
{"name":"ZFSet.toSet_insert","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u_1}\n⊢ Eq (Insert.insert x y).toSet (Insert.insert x y.toSet)","decl":"@[simp]\ntheorem toSet_insert (x y : ZFSet) : (insert x y).toSet = insert x y.toSet := by\n  ext\n  simp\n\n"}
{"name":"ZFSet.mem_singleton","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Iff (Membership.mem (Singleton.singleton y) x) (Eq x y)","decl":"@[simp]\ntheorem mem_singleton {x y : ZFSet.{u}} : x ∈ @singleton ZFSet.{u} ZFSet.{u} _ y ↔ x = y :=\n  Quotient.inductionOn₂ x y fun _ _ => PSet.mem_singleton.trans eq.symm\n\n"}
{"name":"ZFSet.toSet_singleton","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u_1}\n⊢ Eq (Singleton.singleton x).toSet (Singleton.singleton x)","decl":"@[simp]\ntheorem toSet_singleton (x : ZFSet) : ({x} : ZFSet).toSet = {x} := by\n  ext\n  simp\n\n"}
{"name":"ZFSet.insert_nonempty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"u v : ZFSet.{u_1}\n⊢ (Insert.insert u v).Nonempty","decl":"theorem insert_nonempty (u v : ZFSet) : (insert u v).Nonempty :=\n  ⟨u, mem_insert u v⟩\n\n"}
{"name":"ZFSet.singleton_nonempty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"u : ZFSet.{u_1}\n⊢ (Singleton.singleton u).Nonempty","decl":"theorem singleton_nonempty (u : ZFSet) : ZFSet.Nonempty {u} :=\n  insert_nonempty u ∅\n\n"}
{"name":"ZFSet.mem_pair","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : ZFSet.{u}\n⊢ Iff (Membership.mem (Insert.insert y (Singleton.singleton z)) x) (Or (Eq x y) (Eq x z))","decl":"theorem mem_pair {x y z : ZFSet.{u}} : x ∈ ({y, z} : ZFSet) ↔ x = y ∨ x = z := by\n  simp\n\n"}
{"name":"ZFSet.pair_eq_singleton","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u_1}\n⊢ Eq (Insert.insert x (Singleton.singleton x)) (Singleton.singleton x)","decl":"@[simp]\ntheorem pair_eq_singleton (x : ZFSet) : {x, x} = ({x} : ZFSet) := by\n  ext\n  simp\n\n"}
{"name":"ZFSet.pair_eq_singleton_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : ZFSet.{u_1}\n⊢ Iff (Eq (Insert.insert x (Singleton.singleton y)) (Singleton.singleton z)) (And (Eq x z) (Eq y z))","decl":"@[simp]\ntheorem pair_eq_singleton_iff {x y z : ZFSet} : ({x, y} : ZFSet) = {z} ↔ x = z ∧ y = z := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · rw [← mem_singleton, ← mem_singleton]\n    simp [← h]\n  · rintro ⟨rfl, rfl⟩\n    exact pair_eq_singleton y\n\n"}
{"name":"ZFSet.singleton_eq_pair_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : ZFSet.{u_1}\n⊢ Iff (Eq (Singleton.singleton x) (Insert.insert y (Singleton.singleton z))) (And (Eq x y) (Eq x z))","decl":"@[simp]\ntheorem singleton_eq_pair_iff {x y z : ZFSet} : ({x} : ZFSet) = {y, z} ↔ x = y ∧ x = z := by\n  rw [eq_comm, pair_eq_singleton_iff]\n  simp_rw [eq_comm]\n\n"}
{"name":"ZFSet.omega_zero","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Membership.mem ZFSet.omega EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem omega_zero : ∅ ∈ omega :=\n  ⟨⟨0⟩, Equiv.rfl⟩\n\n"}
{"name":"ZFSet.omega_succ","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"n : ZFSet.{u}\na✝ : Membership.mem ZFSet.omega n\n⊢ Membership.mem ZFSet.omega (Insert.insert n n)","decl":"@[simp]\ntheorem omega_succ {n} : n ∈ omega.{u} → insert n n ∈ omega.{u} :=\n  Quotient.inductionOn n fun x ⟨⟨n⟩, h⟩ =>\n    ⟨⟨n + 1⟩,\n      ZFSet.exact <|\n        show insert (mk x) (mk x) = insert (mk <| ofNat n) (mk <| ofNat n) by\n          rw [ZFSet.sound h]\n          rfl⟩\n\n"}
{"name":"ZFSet.mem_sep","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"p : ZFSet.{u} → Prop\nx y : ZFSet.{u}\n⊢ Iff (Membership.mem (ZFSet.sep p x) y) (And (Membership.mem x y) (p y))","decl":"@[simp]\ntheorem mem_sep {p : ZFSet.{u} → Prop} {x y : ZFSet.{u}} :\n    y ∈ ZFSet.sep p x ↔ y ∈ x ∧ p y :=\n  Quotient.inductionOn₂ x y fun _ _ =>\n    PSet.mem_sep (p := p ∘ mk) fun _ _ h => (Quotient.sound h).subst\n\n"}
{"name":"ZFSet.sep_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"p : ZFSet.{u_1} → Prop\n⊢ Eq (ZFSet.sep p EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem sep_empty (p : ZFSet → Prop) : (∅ : ZFSet).sep p = ∅ :=\n  (eq_empty _).mpr fun _ h ↦ not_mem_empty _ (mem_sep.mp h).1\n\n"}
{"name":"ZFSet.toSet_sep","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"a : ZFSet.{u_1}\np : ZFSet.{u_1} → Prop\n⊢ Eq (ZFSet.sep p a).toSet (setOf fun x => And (Membership.mem a.toSet x) (p x))","decl":"@[simp]\ntheorem toSet_sep (a : ZFSet) (p : ZFSet → Prop) :\n    (ZFSet.sep p a).toSet = { x ∈ a.toSet | p x } := by\n  ext\n  simp\n\n"}
{"name":"ZFSet.mem_powerset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Iff (Membership.mem x.powerset y) (HasSubset.Subset y x)","decl":"@[simp]\ntheorem mem_powerset {x y : ZFSet.{u}} : y ∈ powerset x ↔ y ⊆ x :=\n  Quotient.inductionOn₂ x y fun _ _ => PSet.mem_powerset.trans subset_iff.symm\n\n"}
{"name":"ZFSet.sUnion_lem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"α β : Type u\nA : α → PSet.{u}\nB : β → PSet.{u}\nαβ : ∀ (a : α), Exists fun b => (A a).Equiv (B b)\na : (PSet.mk α A).sUnion.Type\n⊢ Exists fun b => ((PSet.mk α A).sUnion.Func a).Equiv ((PSet.mk β B).sUnion.Func b)","decl":"theorem sUnion_lem {α β : Type u} (A : α → PSet) (B : β → PSet) (αβ : ∀ a, ∃ b, Equiv (A a) (B b)) :\n    ∀ a, ∃ b, Equiv ((sUnion ⟨α, A⟩).Func a) ((sUnion ⟨β, B⟩).Func b)\n  | ⟨a, c⟩ => by\n    let ⟨b, hb⟩ := αβ a\n    induction' ea : A a with γ Γ\n    induction' eb : B b with δ Δ\n    rw [ea, eb] at hb\n    cases' hb with γδ δγ\n    let c : (A a).Type := c\n    let ⟨d, hd⟩ := γδ (by rwa [ea] at c)\n    use ⟨b, Eq.ndrec d (Eq.symm eb)⟩\n    change PSet.Equiv ((A a).Func c) ((B b).Func (Eq.ndrec d eb.symm))\n    match A a, B b, ea, eb, c, d, hd with\n    | _, _, rfl, rfl, _, _, hd => exact hd\n\n"}
{"name":"ZFSet.mem_sUnion","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Iff (Membership.mem x.sUnion y) (Exists fun z => And (Membership.mem x z) (Membership.mem z y))","decl":"@[simp]\ntheorem mem_sUnion {x y : ZFSet.{u}} : y ∈ ⋃₀ x ↔ ∃ z ∈ x, y ∈ z :=\n  Quotient.inductionOn₂ x y fun _ _ => PSet.mem_sUnion.trans\n    ⟨fun ⟨z, h⟩ => ⟨⟦z⟧, h⟩, fun ⟨z, h⟩ => Quotient.inductionOn z (fun z h => ⟨z, h⟩) h⟩\n\n"}
{"name":"ZFSet.mem_sInter","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u_1}\nh : x.Nonempty\n⊢ Iff (Membership.mem x.sInter y) (∀ (z : ZFSet.{u_1}), Membership.mem x z → Membership.mem z y)","decl":"theorem mem_sInter {x y : ZFSet} (h : x.Nonempty) : y ∈ ⋂₀ x ↔ ∀ z ∈ x, y ∈ z := by\n  unfold sInter\n  simp only [and_iff_right_iff_imp, mem_sep]\n  intro mem\n  apply mem_sUnion.mpr\n  replace ⟨s, h⟩ := h\n  exact ⟨_, h, mem _ h⟩\n\n"}
{"name":"ZFSet.sUnion_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Eq EmptyCollection.emptyCollection.sUnion EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem sUnion_empty : ⋃₀ (∅ : ZFSet.{u}) = ∅ := by\n  ext\n  simp\n\n"}
{"name":"ZFSet.sInter_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Eq EmptyCollection.emptyCollection.sInter EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem sInter_empty : ⋂₀ (∅ : ZFSet) = ∅ := by simp [sInter]\n\n"}
{"name":"ZFSet.mem_of_mem_sInter","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : ZFSet.{u_1}\nhy : Membership.mem x.sInter y\nhz : Membership.mem x z\n⊢ Membership.mem z y","decl":"theorem mem_of_mem_sInter {x y z : ZFSet} (hy : y ∈ ⋂₀ x) (hz : z ∈ x) : y ∈ z := by\n  rcases eq_empty_or_nonempty x with (rfl | hx)\n  · exact (not_mem_empty z hz).elim\n  · exact (mem_sInter hx).1 hy z hz\n\n"}
{"name":"ZFSet.mem_sUnion_of_mem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : ZFSet.{u_1}\nhy : Membership.mem z y\nhz : Membership.mem x z\n⊢ Membership.mem x.sUnion y","decl":"theorem mem_sUnion_of_mem {x y z : ZFSet} (hy : y ∈ z) (hz : z ∈ x) : y ∈ ⋃₀ x :=\n  mem_sUnion.2 ⟨z, hz, hy⟩\n\n"}
{"name":"ZFSet.not_mem_sInter_of_not_mem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : ZFSet.{u_1}\nhy : Not (Membership.mem z y)\nhz : Membership.mem x z\n⊢ Not (Membership.mem x.sInter y)","decl":"theorem not_mem_sInter_of_not_mem {x y z : ZFSet} (hy : ¬y ∈ z) (hz : z ∈ x) : ¬y ∈ ⋂₀ x :=\n  fun hx => hy <| mem_of_mem_sInter hx hz\n\n"}
{"name":"ZFSet.sUnion_singleton","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\n⊢ Eq (Singleton.singleton x).sUnion x","decl":"@[simp]\ntheorem sUnion_singleton {x : ZFSet.{u}} : ⋃₀ ({x} : ZFSet) = x :=\n  ext fun y => by simp_rw [mem_sUnion, mem_singleton, exists_eq_left]\n\n"}
{"name":"ZFSet.sInter_singleton","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\n⊢ Eq (Singleton.singleton x).sInter x","decl":"@[simp]\ntheorem sInter_singleton {x : ZFSet.{u}} : ⋂₀ ({x} : ZFSet) = x :=\n  ext fun y => by simp_rw [mem_sInter (singleton_nonempty x), mem_singleton, forall_eq]\n\n"}
{"name":"ZFSet.toSet_sUnion","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\n⊢ Eq x.sUnion.toSet (Set.image ZFSet.toSet x.toSet).sUnion","decl":"@[simp]\ntheorem toSet_sUnion (x : ZFSet.{u}) : (⋃₀ x).toSet = ⋃₀ (toSet '' x.toSet) := by\n  ext\n  simp\n\n"}
{"name":"ZFSet.toSet_sInter","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\nh : x.Nonempty\n⊢ Eq x.sInter.toSet (Set.image ZFSet.toSet x.toSet).sInter","decl":"theorem toSet_sInter {x : ZFSet.{u}} (h : x.Nonempty) : (⋂₀ x).toSet = ⋂₀ (toSet '' x.toSet) := by\n  ext\n  simp [mem_sInter h]\n\n"}
{"name":"ZFSet.singleton_injective","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Function.Injective Singleton.singleton","decl":"theorem singleton_injective : Function.Injective (@singleton ZFSet ZFSet _) := fun x y H => by\n  let this := congr_arg sUnion H\n  rwa [sUnion_singleton, sUnion_singleton] at this\n\n"}
{"name":"ZFSet.singleton_inj","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u_1}\n⊢ Iff (Eq (Singleton.singleton x) (Singleton.singleton y)) (Eq x y)","decl":"@[simp]\ntheorem singleton_inj {x y : ZFSet} : ({x} : ZFSet) = {y} ↔ x = y :=\n  singleton_injective.eq_iff\n\n"}
{"name":"ZFSet.toSet_union","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Eq (Union.union x y).toSet (Union.union x.toSet y.toSet)","decl":"@[simp]\ntheorem toSet_union (x y : ZFSet.{u}) : (x ∪ y).toSet = x.toSet ∪ y.toSet := by\n  change (⋃₀ {x, y}).toSet = _\n  simp\n\n"}
{"name":"ZFSet.toSet_inter","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Eq (Inter.inter x y).toSet (Inter.inter x.toSet y.toSet)","decl":"@[simp]\ntheorem toSet_inter (x y : ZFSet.{u}) : (x ∩ y).toSet = x.toSet ∩ y.toSet := by\n  change (ZFSet.sep (fun z => z ∈ y) x).toSet = _\n  ext\n  simp\n\n"}
{"name":"ZFSet.toSet_sdiff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Eq (SDiff.sdiff x y).toSet (SDiff.sdiff x.toSet y.toSet)","decl":"@[simp]\ntheorem toSet_sdiff (x y : ZFSet.{u}) : (x \\ y).toSet = x.toSet \\ y.toSet := by\n  change (ZFSet.sep (fun z => z ∉ y) x).toSet = _\n  ext\n  simp\n\n"}
{"name":"ZFSet.mem_union","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : ZFSet.{u}\n⊢ Iff (Membership.mem (Union.union x y) z) (Or (Membership.mem x z) (Membership.mem y z))","decl":"@[simp]\ntheorem mem_union {x y z : ZFSet.{u}} : z ∈ x ∪ y ↔ z ∈ x ∨ z ∈ y := by\n  rw [← mem_toSet]\n  simp\n\n"}
{"name":"ZFSet.mem_inter","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : ZFSet.{u}\n⊢ Iff (Membership.mem (Inter.inter x y) z) (And (Membership.mem x z) (Membership.mem y z))","decl":"@[simp]\ntheorem mem_inter {x y z : ZFSet.{u}} : z ∈ x ∩ y ↔ z ∈ x ∧ z ∈ y :=\n  @mem_sep (fun z : ZFSet.{u} => z ∈ y) x z\n\n"}
{"name":"ZFSet.mem_diff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : ZFSet.{u}\n⊢ Iff (Membership.mem (SDiff.sdiff x y) z) (And (Membership.mem x z) (Not (Membership.mem y z)))","decl":"@[simp]\ntheorem mem_diff {x y z : ZFSet.{u}} : z ∈ x \\ y ↔ z ∈ x ∧ z ∉ y :=\n  @mem_sep (fun z : ZFSet.{u} => z ∉ y) x z\n\n"}
{"name":"ZFSet.sUnion_pair","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Eq (Insert.insert x (Singleton.singleton y)).sUnion (Union.union x y)","decl":"@[simp]\ntheorem sUnion_pair {x y : ZFSet.{u}} : ⋃₀ ({x, y} : ZFSet.{u}) = x ∪ y :=\n  rfl\n\n"}
{"name":"ZFSet.mem_wf","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ WellFounded fun x1 x2 => Membership.mem x2 x1","decl":"theorem mem_wf : @WellFounded ZFSet (· ∈ ·) :=\n  (wellFounded_lift₂_iff (H := fun a b c d hx hy =>\n    propext ((@Mem.congr_left a c hx).trans (@Mem.congr_right b d hy _)))).mpr PSet.mem_wf\n\n"}
{"name":"ZFSet.inductionOn","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"p : ZFSet.{u_1} → Prop\nx : ZFSet.{u_1}\nh : ∀ (x : ZFSet.{u_1}), (∀ (y : ZFSet.{u_1}), Membership.mem x y → p y) → p x\n⊢ p x","decl":"/-- Induction on the `∈` relation. -/\n@[elab_as_elim]\ntheorem inductionOn {p : ZFSet → Prop} (x) (h : ∀ x, (∀ y ∈ x, p y) → p x) : p x :=\n  mem_wf.induction x h\n\n"}
{"name":"ZFSet.instIsWellFoundedMem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ IsWellFounded ZFSet.{u_1} fun x1 x2 => Membership.mem x2 x1","decl":"instance : IsWellFounded ZFSet (· ∈ ·) :=\n  ⟨mem_wf⟩\n\n"}
{"name":"ZFSet.mem_asymm","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u_1}\na✝ : Membership.mem y x\n⊢ Not (Membership.mem x y)","decl":"theorem mem_asymm {x y : ZFSet} : x ∈ y → y ∉ x :=\n  asymm_of (· ∈ ·)\n\n"}
{"name":"ZFSet.mem_irrefl","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u_1}\n⊢ Not (Membership.mem x x)","decl":"theorem mem_irrefl (x : ZFSet) : x ∉ x :=\n  irrefl_of (· ∈ ·) x\n\n"}
{"name":"ZFSet.not_subset_of_mem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u_1}\nh : Membership.mem y x\n⊢ Not (HasSubset.Subset y x)","decl":"theorem not_subset_of_mem {x y : ZFSet} (h : x ∈ y) : ¬ y ⊆ x :=\n  fun h' ↦ mem_irrefl _ (h' h)\n\n"}
{"name":"ZFSet.not_mem_of_subset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u_1}\nh : HasSubset.Subset x y\n⊢ Not (Membership.mem x y)","decl":"theorem not_mem_of_subset {x y : ZFSet} (h : x ⊆ y) : y ∉ x :=\n  imp_not_comm.2 not_subset_of_mem h\n\n"}
{"name":"ZFSet.regularity","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\nh : Ne x EmptyCollection.emptyCollection\n⊢ Exists fun y => And (Membership.mem x y) (Eq (Inter.inter x y) EmptyCollection.emptyCollection)","decl":"theorem regularity (x : ZFSet.{u}) (h : x ≠ ∅) : ∃ y ∈ x, x ∩ y = ∅ :=\n  by_contradiction fun ne =>\n    h <| (eq_empty x).2 fun y =>\n      @inductionOn (fun z => z ∉ x) y fun z IH zx =>\n        ne ⟨z, zx, (eq_empty _).2 fun w wxz =>\n          let ⟨wx, wz⟩ := mem_inter.1 wxz\n          IH w wz wx⟩\n\n"}
{"name":"ZFSet.image.mk","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"f : ZFSet.{u} → ZFSet.{u}\ninst✝ : ZFSet.Definable₁ f\nx y : ZFSet.{u}\na✝ : Membership.mem x y\n⊢ Membership.mem (ZFSet.image f x) (f y)","decl":"theorem image.mk (f : ZFSet.{u} → ZFSet.{u}) [Definable₁ f] (x) {y} : y ∈ x → f y ∈ image f x :=\n  Quotient.inductionOn₂ x y fun ⟨_, _⟩ _ ⟨a, ya⟩ => by\n    simp only [mk_eq, ← Definable₁.mk_out (f := f)]\n    exact ⟨a, Definable₁.out_equiv f ya⟩\n\n"}
{"name":"ZFSet.mem_image","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"f : ZFSet.{u} → ZFSet.{u}\ninst✝ : ZFSet.Definable₁ f\nx y : ZFSet.{u}\n⊢ Iff (Membership.mem (ZFSet.image f x) y) (Exists fun z => And (Membership.mem x z) (Eq (f z) y))","decl":"@[simp]\ntheorem mem_image {f : ZFSet.{u} → ZFSet.{u}} [Definable₁ f] {x y : ZFSet.{u}} :\n    y ∈ image f x ↔ ∃ z ∈ x, f z = y :=\n  Quotient.inductionOn₂ x y fun ⟨_, A⟩ _ =>\n    ⟨fun ⟨a, ya⟩ => ⟨⟦A a⟧, Mem.mk A a, ((Quotient.sound ya).trans Definable₁.mk_out).symm⟩,\n      fun ⟨_, hz, e⟩ => e ▸ image.mk _ _ hz⟩\n\n"}
{"name":"ZFSet.toSet_image","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"f : ZFSet.{u_1} → ZFSet.{u_1}\ninst✝ : ZFSet.Definable₁ f\nx : ZFSet.{u_1}\n⊢ Eq (ZFSet.image f x).toSet (Set.image f x.toSet)","decl":"@[simp]\ntheorem toSet_image (f : ZFSet → ZFSet) [Definable₁ f] (x : ZFSet) :\n    (image f x).toSet = f '' x.toSet := by\n  ext\n  simp\n\n"}
{"name":"ZFSet.mem_range","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"α : Type u_1\ninst✝ : Small.{u, u_1} α\nf : α → ZFSet.{u}\nx : ZFSet.{u}\n⊢ Iff (Membership.mem (ZFSet.range f) x) (Membership.mem (Set.range f) x)","decl":"@[simp]\ntheorem mem_range {α} [Small.{u} α] {f : α → ZFSet.{u}} {x : ZFSet.{u}} :\n    x ∈ range f ↔ x ∈ Set.range f :=\n  Quotient.inductionOn x fun y => by\n    constructor\n    · rintro ⟨z, hz⟩\n      exact ⟨(equivShrink α).symm z, Quotient.eq_mk_iff_out.2 hz.symm⟩\n    · rintro ⟨z, hz⟩\n      use equivShrink α z\n      simpa [hz] using PSet.Equiv.symm (Quotient.mk_out y)\n\n"}
{"name":"ZFSet.toSet_range","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"α : Type u_1\ninst✝ : Small.{u, u_1} α\nf : α → ZFSet.{u}\n⊢ Eq (ZFSet.range f).toSet (Set.range f)","decl":"@[simp]\ntheorem toSet_range {α} [Small.{u} α] (f : α → ZFSet.{u}) :\n    (range f).toSet = Set.range f := by\n  ext\n  simp\n\n"}
{"name":"ZFSet.toSet_pair","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Eq (x.pair y).toSet (Insert.insert (Singleton.singleton x) (Singleton.singleton (Insert.insert x (Singleton.singleton y))))","decl":"@[simp]\ntheorem toSet_pair (x y : ZFSet.{u}) : (pair x y).toSet = {{x}, {x, y}} := by simp [pair]\n\n"}
{"name":"ZFSet.mem_pairSep","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"p : ZFSet.{u} → ZFSet.{u} → Prop\nx y z : ZFSet.{u}\n⊢ Iff (Membership.mem (ZFSet.pairSep p x y) z) (Exists fun a => And (Membership.mem x a) (Exists fun b => And (Membership.mem y b) (And (Eq z (a.pair b)) (p a b))))","decl":"@[simp]\ntheorem mem_pairSep {p} {x y z : ZFSet.{u}} :\n    z ∈ pairSep p x y ↔ ∃ a ∈ x, ∃ b ∈ y, z = pair a b ∧ p a b := by\n  refine mem_sep.trans ⟨And.right, fun e => ⟨?_, e⟩⟩\n  rcases e with ⟨a, ax, b, bY, rfl, pab⟩\n  simp only [mem_powerset, subset_def, mem_union, pair, mem_pair]\n  rintro u (rfl | rfl) v <;> simp only [mem_singleton, mem_pair]\n  · rintro rfl\n    exact Or.inl ax\n  · rintro (rfl | rfl) <;> [left; right] <;> assumption\n\n"}
{"name":"ZFSet.pair_injective","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Function.Injective2 ZFSet.pair","decl":"theorem pair_injective : Function.Injective2 pair := by\n  intro x x' y y' H\n  simp_rw [ZFSet.ext_iff, pair, mem_pair] at H\n  obtain rfl : x = x' := And.left <| by simpa [or_and_left] using (H {x}).1 (Or.inl rfl)\n  have he : y = x → y = y' := by\n    rintro rfl\n    simpa [eq_comm] using H {y, y'}\n  have hx := H {x, y}\n  simp_rw [pair_eq_singleton_iff, true_and, or_true, true_iff] at hx\n  refine ⟨rfl, hx.elim he fun hy ↦ Or.elim ?_ he id⟩\n  simpa using ZFSet.ext_iff.1 hy y\n\n"}
{"name":"ZFSet.pair_inj","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y x' y' : ZFSet.{u_1}\n⊢ Iff (Eq (x.pair y) (x'.pair y')) (And (Eq x x') (Eq y y'))","decl":"@[simp]\ntheorem pair_inj {x y x' y' : ZFSet} : pair x y = pair x' y' ↔ x = x' ∧ y = y' :=\n  pair_injective.eq_iff\n\n"}
{"name":"ZFSet.mem_prod","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : ZFSet.{u}\n⊢ Iff (Membership.mem (x.prod y) z) (Exists fun a => And (Membership.mem x a) (Exists fun b => And (Membership.mem y b) (Eq z (a.pair b))))","decl":"@[simp]\ntheorem mem_prod {x y z : ZFSet.{u}} : z ∈ prod x y ↔ ∃ a ∈ x, ∃ b ∈ y, z = pair a b := by\n  simp [prod]\n\n"}
{"name":"ZFSet.pair_mem_prod","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y a b : ZFSet.{u}\n⊢ Iff (Membership.mem (x.prod y) (a.pair b)) (And (Membership.mem x a) (Membership.mem y b))","decl":"theorem pair_mem_prod {x y a b : ZFSet.{u}} : pair a b ∈ prod x y ↔ a ∈ x ∧ b ∈ y := by\n  simp\n\n"}
{"name":"ZFSet.mem_funs","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y f : ZFSet.{u}\n⊢ Iff (Membership.mem (x.funs y) f) (x.IsFunc y f)","decl":"@[simp]\ntheorem mem_funs {x y f : ZFSet.{u}} : f ∈ funs x y ↔ IsFunc x y f := by simp [funs, IsFunc]\n\n"}
{"name":"ZFSet.mem_map","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"f : ZFSet.{u_1} → ZFSet.{u_1}\ninst✝ : ZFSet.Definable₁ f\nx y : ZFSet.{u_1}\n⊢ Iff (Membership.mem (ZFSet.map f x) y) (Exists fun z => And (Membership.mem x z) (Eq (z.pair (f z)) y))","decl":"@[simp]\ntheorem mem_map {f : ZFSet → ZFSet} [Definable₁ f] {x y : ZFSet} :\n    y ∈ map f x ↔ ∃ z ∈ x, pair z (f z) = y :=\n  mem_image\n\n"}
{"name":"ZFSet.map_unique","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"f : ZFSet.{u} → ZFSet.{u}\ninst✝ : ZFSet.Definable₁ f\nx z : ZFSet.{u}\nzx : Membership.mem x z\n⊢ ExistsUnique fun w => Membership.mem (ZFSet.map f x) (z.pair w)","decl":"theorem map_unique {f : ZFSet.{u} → ZFSet.{u}} [Definable₁ f] {x z : ZFSet.{u}}\n    (zx : z ∈ x) : ∃! w, pair z w ∈ map f x :=\n  ⟨f z, image.mk _ _ zx, fun y yx => by\n    let ⟨w, _, we⟩ := mem_image.1 yx\n    let ⟨wz, fy⟩ := pair_injective we\n    rw [← fy, wz]⟩\n\n"}
{"name":"ZFSet.map_isFunc","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"f : ZFSet.{u_1} → ZFSet.{u_1}\ninst✝ : ZFSet.Definable₁ f\nx y : ZFSet.{u_1}\n⊢ Iff (x.IsFunc y (ZFSet.map f x)) (∀ (z : ZFSet.{u_1}), Membership.mem x z → Membership.mem y (f z))","decl":"@[simp]\ntheorem map_isFunc {f : ZFSet → ZFSet} [Definable₁ f] {x y : ZFSet} :\n    IsFunc x y (map f x) ↔ ∀ z ∈ x, f z ∈ y :=\n  ⟨fun ⟨ss, h⟩ z zx =>\n    let ⟨_, t1, t2⟩ := h z zx\n    (t2 (f z) (image.mk _ _ zx)).symm ▸ (pair_mem_prod.1 (ss t1)).right,\n    fun h =>\n    ⟨fun _ yx =>\n      let ⟨z, zx, ze⟩ := mem_image.1 yx\n      ze ▸ pair_mem_prod.2 ⟨zx, h z zx⟩,\n      fun _ => map_unique⟩⟩\n\n"}
{"name":"ZFSet.hereditarily_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"p : ZFSet.{u} → Prop\nx : ZFSet.{u}\n⊢ Iff (ZFSet.Hereditarily p x) (And (p x) (∀ (y : ZFSet.{u}), Membership.mem x y → ZFSet.Hereditarily p y))","decl":"theorem hereditarily_iff : Hereditarily p x ↔ p x ∧ ∀ y ∈ x, Hereditarily p y := by\n  rw [← Hereditarily]\n\n"}
{"name":"ZFSet.Hereditarily.def","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"p : ZFSet.{u} → Prop\nx : ZFSet.{u}\na✝ : ZFSet.Hereditarily p x\n⊢ And (p x) (∀ (y : ZFSet.{u}), Membership.mem x y → ZFSet.Hereditarily p y)","decl":"alias ⟨Hereditarily.def, _⟩ := hereditarily_iff\n\n"}
{"name":"ZFSet.Hereditarily.self","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"p : ZFSet.{u} → Prop\nx : ZFSet.{u}\nh : ZFSet.Hereditarily p x\n⊢ p x","decl":"theorem Hereditarily.self (h : x.Hereditarily p) : p x :=\n  h.def.1\n\n"}
{"name":"ZFSet.Hereditarily.mem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"p : ZFSet.{u} → Prop\nx y : ZFSet.{u}\nh : ZFSet.Hereditarily p x\nhy : Membership.mem x y\n⊢ ZFSet.Hereditarily p y","decl":"theorem Hereditarily.mem (h : x.Hereditarily p) (hy : y ∈ x) : y.Hereditarily p :=\n  h.def.2 _ hy\n\n"}
{"name":"ZFSet.Hereditarily.empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"p : ZFSet.{u} → Prop\nx : ZFSet.{u}\na✝ : ZFSet.Hereditarily p x\n⊢ p EmptyCollection.emptyCollection","decl":"theorem Hereditarily.empty : Hereditarily p x → p ∅ := by\n  apply @ZFSet.inductionOn _ x\n  intro y IH h\n  rcases ZFSet.eq_empty_or_nonempty y with (rfl | ⟨a, ha⟩)\n  · exact h.self\n  · exact IH a ha (h.mem ha)\n\n"}
{"name":"Class.ext_iff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : Class.{u}\n⊢ Iff (Eq x y) (∀ (z : ZFSet.{u}), Iff (x z) (y z))","decl":"@[ext]\ntheorem ext {x y : Class.{u}} : (∀ z : ZFSet.{u}, x z ↔ y z) → x = y :=\n  Set.ext\n\n"}
{"name":"Class.ext","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : Class.{u}\na✝ : ∀ (z : ZFSet.{u}), Iff (x z) (y z)\n⊢ Eq x y","decl":"@[ext]\ntheorem ext {x y : Class.{u}} : (∀ z : ZFSet.{u}, x z ↔ y z) → x = y :=\n  Set.ext\n\n"}
{"name":"Class.mem_def","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"A B : Class.{u}\n⊢ Iff (Membership.mem B A) (Exists fun x => And (Eq (↑x) A) (B x))","decl":"theorem mem_def (A B : Class.{u}) : A ∈ B ↔ ∃ x : ZFSet, ↑x = A ∧ B x :=\n  Iff.rfl\n\n"}
{"name":"Class.not_mem_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : Class.{u}\n⊢ Not (Membership.mem EmptyCollection.emptyCollection x)","decl":"@[simp]\ntheorem not_mem_empty (x : Class.{u}) : x ∉ (∅ : Class.{u}) := fun ⟨_, _, h⟩ => h\n\n"}
{"name":"Class.not_empty_hom","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\n⊢ Not (EmptyCollection.emptyCollection x)","decl":"@[simp]\ntheorem not_empty_hom (x : ZFSet.{u}) : ¬(∅ : Class.{u}) x :=\n  id\n\n"}
{"name":"Class.mem_univ","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"A : Class.{u}\n⊢ Iff (Membership.mem Class.univ A) (Exists fun x => Eq (↑x) A)","decl":"@[simp]\ntheorem mem_univ {A : Class.{u}} : A ∈ univ.{u} ↔ ∃ x : ZFSet.{u}, ↑x = A :=\n  exists_congr fun _ => iff_of_eq (and_true _)\n\n"}
{"name":"Class.mem_univ_hom","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\n⊢ Class.univ x","decl":"@[simp]\ntheorem mem_univ_hom (x : ZFSet.{u}) : univ.{u} x :=\n  trivial\n\n"}
{"name":"Class.eq_univ_iff_forall","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"A : Class.{u}\n⊢ Iff (Eq A Class.univ) (∀ (x : ZFSet.{u}), A x)","decl":"theorem eq_univ_iff_forall {A : Class.{u}} : A = univ ↔ ∀ x : ZFSet, A x :=\n  Set.eq_univ_iff_forall\n\n"}
{"name":"Class.eq_univ_of_forall","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"A : Class.{u}\na✝ : ∀ (x : ZFSet.{u}), A x\n⊢ Eq A Class.univ","decl":"theorem eq_univ_of_forall {A : Class.{u}} : (∀ x : ZFSet, A x) → A = univ :=\n  Set.eq_univ_of_forall\n\n"}
{"name":"Class.mem_wf","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ WellFounded fun x1 x2 => Membership.mem x2 x1","decl":"theorem mem_wf : @WellFounded Class.{u} (· ∈ ·) :=\n  ⟨by\n    have H : ∀ x : ZFSet.{u}, @Acc Class.{u} (· ∈ ·) ↑x := by\n      refine fun a => ZFSet.inductionOn a fun x IH => ⟨_, ?_⟩\n      rintro A ⟨z, rfl, hz⟩\n      exact IH z hz\n    refine fun A => ⟨A, ?_⟩\n    rintro B ⟨x, rfl, _⟩\n    exact H x⟩\n\n"}
{"name":"Class.instIsWellFoundedMem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ IsWellFounded Class.{u_1} fun x1 x2 => Membership.mem x2 x1","decl":"instance : IsWellFounded Class (· ∈ ·) :=\n  ⟨mem_wf⟩\n\n"}
{"name":"Class.mem_asymm","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : Class.{u_1}\na✝ : Membership.mem y x\n⊢ Not (Membership.mem x y)","decl":"theorem mem_asymm {x y : Class} : x ∈ y → y ∉ x :=\n  asymm_of (· ∈ ·)\n\n"}
{"name":"Class.mem_irrefl","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : Class.{u_1}\n⊢ Not (Membership.mem x x)","decl":"theorem mem_irrefl (x : Class) : x ∉ x :=\n  irrefl_of (· ∈ ·) x\n\n"}
{"name":"Class.univ_not_mem_univ","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Not (Membership.mem Class.univ Class.univ)","decl":"/-- **There is no universal set.**\nThis is stated as `univ ∉ univ`, meaning that `univ` (the class of all sets) is proper (does not\nbelong to the class of all sets). -/\ntheorem univ_not_mem_univ : univ ∉ univ :=\n  mem_irrefl _\n\n"}
{"name":"Class.congToClass_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Eq (Class.congToClass EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem congToClass_empty : congToClass ∅ = ∅ := by\n  ext z\n  simp only [congToClass, not_empty_hom, iff_false]\n  exact Set.not_mem_empty z\n\n"}
{"name":"Class.classToCong_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Eq EmptyCollection.emptyCollection.classToCong EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem classToCong_empty : classToCong ∅ = ∅ := by\n  ext\n  simp [classToCong]\n\n"}
{"name":"Class.ofSet.inj","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\nh : Eq ↑x ↑y\n⊢ Eq x y","decl":"theorem ofSet.inj {x y : ZFSet.{u}} (h : (x : Class.{u}) = y) : x = y :=\n  ZFSet.ext fun z => by\n    change (x : Class.{u}) z ↔ (y : Class.{u}) z\n    rw [h]\n\n"}
{"name":"Class.toSet_of_ZFSet","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"A : Class.{u}\nx : ZFSet.{u}\n⊢ Iff (A.ToSet ↑x) (A x)","decl":"@[simp]\ntheorem toSet_of_ZFSet (A : Class.{u}) (x : ZFSet.{u}) : ToSet A x ↔ A x :=\n  ⟨fun ⟨y, yx, py⟩ => by rwa [ofSet.inj yx] at py, fun px => ⟨x, rfl, px⟩⟩\n\n"}
{"name":"Class.coe_mem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\nA : Class.{u}\n⊢ Iff (Membership.mem A ↑x) (A x)","decl":"@[simp, norm_cast]\ntheorem coe_mem {x : ZFSet.{u}} {A : Class.{u}} : ↑x ∈ A ↔ A x :=\n  toSet_of_ZFSet _ _\n\n"}
{"name":"Class.coe_apply","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Iff (↑y x) (Membership.mem y x)","decl":"@[simp]\ntheorem coe_apply {x y : ZFSet.{u}} : (y : Class.{u}) x ↔ x ∈ y :=\n  Iff.rfl\n\n"}
{"name":"Class.coe_subset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Iff (HasSubset.Subset ↑x ↑y) (HasSubset.Subset x y)","decl":"@[simp, norm_cast]\ntheorem coe_subset (x y : ZFSet.{u}) : (x : Class.{u}) ⊆ y ↔ x ⊆ y :=\n  Iff.rfl\n\n"}
{"name":"Class.coe_sep","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"p : Class.{u}\nx : ZFSet.{u}\n⊢ Eq (↑(ZFSet.sep p x)) (setOf fun y => And (Membership.mem x y) (p y))","decl":"@[simp, norm_cast]\ntheorem coe_sep (p : Class.{u}) (x : ZFSet.{u}) :\n    (ZFSet.sep p x : Class) = { y ∈ x | p y } :=\n  ext fun _ => ZFSet.mem_sep\n\n"}
{"name":"Class.coe_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Eq (↑EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp, norm_cast]\ntheorem coe_empty : ↑(∅ : ZFSet.{u}) = (∅ : Class.{u}) :=\n  ext fun y => iff_false _ ▸ ZFSet.not_mem_empty y\n\n"}
{"name":"Class.coe_insert","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Eq (↑(Insert.insert x y)) (Insert.insert x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_insert (x y : ZFSet.{u}) : ↑(insert x y) = @insert ZFSet.{u} Class.{u} _ x y :=\n  ext fun _ => ZFSet.mem_insert_iff\n\n"}
{"name":"Class.coe_union","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Eq (↑(Union.union x y)) (Union.union ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_union (x y : ZFSet.{u}) : ↑(x ∪ y) = (x : Class.{u}) ∪ y :=\n  ext fun _ => ZFSet.mem_union\n\n"}
{"name":"Class.coe_inter","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Eq (↑(Inter.inter x y)) (Inter.inter ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_inter (x y : ZFSet.{u}) : ↑(x ∩ y) = (x : Class.{u}) ∩ y :=\n  ext fun _ => ZFSet.mem_inter\n\n"}
{"name":"Class.coe_diff","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : ZFSet.{u}\n⊢ Eq (↑(SDiff.sdiff x y)) (SDiff.sdiff ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_diff (x y : ZFSet.{u}) : ↑(x \\ y) = (x : Class.{u}) \\ y :=\n  ext fun _ => ZFSet.mem_diff\n\n"}
{"name":"Class.coe_powerset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\n⊢ Eq (↑x.powerset) (↑x).powerset","decl":"@[simp, norm_cast]\ntheorem coe_powerset (x : ZFSet.{u}) : ↑x.powerset = powerset.{u} x :=\n  ext fun _ => ZFSet.mem_powerset\n\n"}
{"name":"Class.powerset_apply","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"A : Class.{u}\nx : ZFSet.{u}\n⊢ Iff (A.powerset x) (HasSubset.Subset (↑x) A)","decl":"@[simp]\ntheorem powerset_apply {A : Class.{u}} {x : ZFSet.{u}} : powerset A x ↔ ↑x ⊆ A :=\n  Iff.rfl\n\n"}
{"name":"Class.sUnion_apply","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : Class.{u_1}\ny : ZFSet.{u_1}\n⊢ Iff (x.sUnion y) (Exists fun z => And (x z) (Membership.mem z y))","decl":"@[simp]\ntheorem sUnion_apply {x : Class} {y : ZFSet} : (⋃₀ x) y ↔ ∃ z : ZFSet, x z ∧ y ∈ z := by\n  constructor\n  · rintro ⟨-, ⟨z, rfl, hxz⟩, hyz⟩\n    exact ⟨z, hxz, hyz⟩\n  · exact fun ⟨z, hxz, hyz⟩ => ⟨_, coe_mem.2 hxz, hyz⟩\n\n"}
{"name":"Class.coe_sUnion","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\n⊢ Eq (↑x.sUnion) (↑x).sUnion","decl":"@[simp, norm_cast]\ntheorem coe_sUnion (x : ZFSet.{u}) : ↑(⋃₀ x : ZFSet) = ⋃₀ (x : Class.{u}) :=\n  ext fun y =>\n    ZFSet.mem_sUnion.trans (sUnion_apply.trans <| by rfl).symm\n\n"}
{"name":"Class.mem_sUnion","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : Class.{u}\n⊢ Iff (Membership.mem x.sUnion y) (Exists fun z => And (Membership.mem x z) (Membership.mem z y))","decl":"@[simp]\ntheorem mem_sUnion {x y : Class.{u}} : y ∈ ⋃₀ x ↔ ∃ z, z ∈ x ∧ y ∈ z := by\n  constructor\n  · rintro ⟨w, rfl, z, hzx, hwz⟩\n    exact ⟨z, hzx, coe_mem.2 hwz⟩\n  · rintro ⟨w, hwx, z, rfl, hwz⟩\n    exact ⟨z, rfl, w, hwx, hwz⟩\n\n"}
{"name":"Class.sInter_apply","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : Class.{u}\ny : ZFSet.{u}\n⊢ Iff (x.sInter y) (∀ (z : ZFSet.{u}), x z → Membership.mem z y)","decl":"theorem sInter_apply {x : Class.{u}} {y : ZFSet.{u}} : (⋂₀ x) y ↔ ∀ z : ZFSet.{u}, x z → y ∈ z := by\n  refine ⟨fun hxy z hxz => hxy _ ⟨z, rfl, hxz⟩, ?_⟩\n  rintro H - ⟨z, rfl, hxz⟩\n  exact H _ hxz\n\n"}
{"name":"Class.coe_sInter","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\nh : x.Nonempty\n⊢ Eq (↑x.sInter) (↑x).sInter","decl":"@[simp, norm_cast]\ntheorem coe_sInter {x : ZFSet.{u}} (h : x.Nonempty) : ↑(⋂₀ x : ZFSet) = ⋂₀ (x : Class.{u}) :=\n  Set.ext fun _ => (ZFSet.mem_sInter h).trans sInter_apply.symm\n\n"}
{"name":"Class.mem_of_mem_sInter","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y z : Class.{u_1}\nhy : Membership.mem x.sInter y\nhz : Membership.mem x z\n⊢ Membership.mem z y","decl":"theorem mem_of_mem_sInter {x y z : Class} (hy : y ∈ ⋂₀ x) (hz : z ∈ x) : y ∈ z := by\n  obtain ⟨w, rfl, hw⟩ := hy\n  exact coe_mem.2 (hw z hz)\n\n"}
{"name":"Class.mem_sInter","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x y : Class.{u}\nh : Set.Nonempty x\n⊢ Iff (Membership.mem x.sInter y) (∀ (z : Class.{u}), Membership.mem x z → Membership.mem z y)","decl":"theorem mem_sInter {x y : Class.{u}} (h : x.Nonempty) : y ∈ ⋂₀ x ↔ ∀ z, z ∈ x → y ∈ z := by\n  refine ⟨fun hy z => mem_of_mem_sInter hy, fun H => ?_⟩\n  simp_rw [mem_def, sInter_apply]\n  obtain ⟨z, hz⟩ := h\n  obtain ⟨y, rfl, _⟩ := H z (coe_mem.2 hz)\n  refine ⟨y, rfl, fun w hxw => ?_⟩\n  simpa only [coe_mem, coe_apply] using H w (coe_mem.2 hxw)\n\n"}
{"name":"Class.sUnion_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Eq EmptyCollection.emptyCollection.sUnion EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem sUnion_empty : ⋃₀ (∅ : Class.{u}) = (∅ : Class.{u}) := by\n  ext\n  simp\n\n"}
{"name":"Class.sInter_empty","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"⊢ Eq EmptyCollection.emptyCollection.sInter Class.univ","decl":"@[simp]\ntheorem sInter_empty : ⋂₀ (∅ : Class.{u}) = univ := by\n  rw [sInter, classToCong_empty, Set.sInter_empty, univ]\n\n"}
{"name":"Class.eq_univ_of_powerset_subset","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"A : Class.{u_1}\nhA : HasSubset.Subset A.powerset A\n⊢ Eq A Class.univ","decl":"/-- An induction principle for sets. If every subset of a class is a member, then the class is\n  universal. -/\ntheorem eq_univ_of_powerset_subset {A : Class} (hA : powerset A ⊆ A) : A = univ :=\n  eq_univ_of_forall\n    (by\n      by_contra! hnA\n      exact\n        WellFounded.min_mem ZFSet.mem_wf _ hnA\n          (hA fun x hx =>\n            Classical.not_not.1 fun hB =>\n              WellFounded.not_lt_min ZFSet.mem_wf _ hnA hB <| coe_apply.1 hx))\n\n"}
{"name":"Class.iota_val","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"A : Class.{u_1}\nx : ZFSet.{u_1}\nH : ∀ (y : ZFSet.{u_1}), Iff (A y) (Eq y x)\n⊢ Eq A.iota ↑x","decl":"theorem iota_val (A : Class) (x : ZFSet) (H : ∀ y, A y ↔ y = x) : iota A = ↑x :=\n  ext fun y =>\n    ⟨fun ⟨_, ⟨x', rfl, h⟩, yx'⟩ => by rwa [← (H x').1 <| (h x').2 rfl], fun yx =>\n      ⟨_, ⟨x, rfl, H⟩, yx⟩⟩\n\n"}
{"name":"Class.iota_ex","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"A : Class.{u}\n⊢ Membership.mem Class.univ A.iota","decl":"/-- Unlike the other set constructors, the `iota` definite descriptor\n  is a set for any set input, but not constructively so, so there is no\n  associated `Class → Set` function. -/\ntheorem iota_ex (A) : iota.{u} A ∈ univ.{u} :=\n  mem_univ.2 <|\n    Or.elim (Classical.em <| ∃ x, ∀ y, A y ↔ y = x) (fun ⟨x, h⟩ => ⟨x, Eq.symm <| iota_val A x h⟩)\n      fun hn =>\n      ⟨∅, ext fun _ => coe_empty.symm ▸ ⟨False.rec, fun ⟨_, ⟨x, rfl, H⟩, _⟩ => hn ⟨x, H⟩⟩⟩\n\n"}
{"name":"Class.fval_ex","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"F A : Class.{u}\n⊢ Membership.mem Class.univ (F.fval A)","decl":"theorem fval_ex (F A : Class.{u}) : F ′ A ∈ univ.{u} :=\n  iota_ex _\n\n"}
{"name":"ZFSet.map_fval","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"f : ZFSet.{u} → ZFSet.{u}\ninst✝ : ZFSet.Definable₁ f\nx y : ZFSet.{u}\nh : Membership.mem x y\n⊢ Eq ((↑(ZFSet.map f x)).fval ↑y) ↑(f y)","decl":"@[simp]\ntheorem map_fval {f : ZFSet.{u} → ZFSet.{u}} [Definable₁ f] {x y : ZFSet.{u}}\n    (h : y ∈ x) : (ZFSet.map f x ′ y : Class.{u}) = f y :=\n  Class.iota_val _ _ fun z => by\n    rw [Class.toSet_of_ZFSet, Class.coe_apply, mem_map]\n    exact\n      ⟨fun ⟨w, _, pr⟩ => by\n        let ⟨wy, fw⟩ := ZFSet.pair_injective pr\n        rw [← fw, wy], fun e => by\n        subst e\n        exact ⟨_, h, rfl⟩⟩\n\n"}
{"name":"ZFSet.choice_mem_aux","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\nh : Not (Membership.mem x EmptyCollection.emptyCollection)\ny : ZFSet.{u}\nyx : Membership.mem x y\n⊢ Membership.mem y (Classical.epsilon fun z => Membership.mem y z)","decl":"theorem choice_mem_aux (h : ∅ ∉ x) (y : ZFSet.{u}) (yx : y ∈ x) :\n    (Classical.epsilon fun z : ZFSet.{u} => z ∈ y) ∈ y :=\n  (@Classical.epsilon_spec _ fun z : ZFSet.{u} => z ∈ y) <|\n    by_contradiction fun n => h <| by rwa [← (eq_empty y).2 fun z zx => n ⟨z, zx⟩]\n\n"}
{"name":"ZFSet.choice_isFunc","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\nh : Not (Membership.mem x EmptyCollection.emptyCollection)\n⊢ x.IsFunc x.sUnion x.choice","decl":"theorem choice_isFunc (h : ∅ ∉ x) : IsFunc x (⋃₀ x) (choice x) :=\n  (@map_isFunc _ (Classical.allZFSetDefinable _) _ _).2 fun y yx =>\n    mem_sUnion.2 ⟨y, yx, choice_mem_aux x h y yx⟩\n\n"}
{"name":"ZFSet.choice_mem","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\nh : Not (Membership.mem x EmptyCollection.emptyCollection)\ny : ZFSet.{u}\nyx : Membership.mem x y\n⊢ Membership.mem (↑y) ((↑x.choice).fval ↑y)","decl":"theorem choice_mem (h : ∅ ∉ x) (y : ZFSet.{u}) (yx : y ∈ x) :\n    (choice x ′ y : Class.{u}) ∈ (y : Class.{u}) := by\n  delta choice\n  rw [@map_fval _ (Classical.allZFSetDefinable _) x y yx, Class.coe_mem, Class.coe_apply]\n  exact choice_mem_aux x h y yx\n\n"}
{"name":"ZFSet.toSet_equiv_apply_coe","module":"Mathlib.SetTheory.ZFC.Basic","initialProofState":"x : ZFSet.{u}\n⊢ Eq (↑(ZFSet.toSet_equiv x)) x.toSet","decl":"/-- `ZFSet.toSet` as an equivalence. -/\n@[simps apply_coe]\nnoncomputable def toSet_equiv : ZFSet.{u} ≃ {s : Set ZFSet.{u} // Small.{u, u+1} s} where\n  toFun x := ⟨x.toSet, x.small_toSet⟩\n  invFun := fun ⟨s, _⟩ ↦ mk <| PSet.mk (Shrink s) fun x ↦ ((equivShrink.{u, u+1} s).symm x).1.out\n  left_inv := Function.rightInverse_of_injective_of_leftInverse (by intros x y; simp)\n    fun s ↦ Subtype.coe_injective <| toSet_equiv_aux s.2\n  right_inv s := Subtype.coe_injective <| toSet_equiv_aux s.2\n\n"}
