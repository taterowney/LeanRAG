{"name":"PadicInt.ext","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx y : PadicInt p\na✝ : Eq ↑x ↑y\n⊢ Eq x y","decl":"theorem ext {x y : ℤ_[p]} : (x : ℚ_[p]) = y → x = y :=\n  Subtype.ext\n\n"}
{"name":"PadicInt.mem_subring_iff","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : Padic p\n⊢ Iff (Membership.mem (PadicInt.subring p) x) (LE.le (Norm.norm x) 1)","decl":"@[simp]\ntheorem mem_subring_iff {x : ℚ_[p]} : x ∈ subring p ↔ ‖x‖ ≤ 1 := Iff.rfl\n\n"}
{"name":"PadicInt.mk_zero","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nh : LE.le (Norm.norm 0) 1\n⊢ Eq ⟨0, h⟩ 0","decl":"@[simp]\ntheorem mk_zero {h} : (⟨0, h⟩ : ℤ_[p]) = (0 : ℤ_[p]) := rfl\n\n"}
{"name":"PadicInt.coe_add","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz1 z2 : PadicInt p\n⊢ Eq (↑(HAdd.hAdd z1 z2)) (HAdd.hAdd ↑z1 ↑z2)","decl":"@[simp, norm_cast]\ntheorem coe_add (z1 z2 : ℤ_[p]) : ((z1 + z2 : ℤ_[p]) : ℚ_[p]) = z1 + z2 := rfl\n\n"}
{"name":"PadicInt.coe_mul","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz1 z2 : PadicInt p\n⊢ Eq (↑(HMul.hMul z1 z2)) (HMul.hMul ↑z1 ↑z2)","decl":"@[simp, norm_cast]\ntheorem coe_mul (z1 z2 : ℤ_[p]) : ((z1 * z2 : ℤ_[p]) : ℚ_[p]) = z1 * z2 := rfl\n\n"}
{"name":"PadicInt.coe_neg","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz1 : PadicInt p\n⊢ Eq (↑(Neg.neg z1)) (Neg.neg ↑z1)","decl":"@[simp, norm_cast]\ntheorem coe_neg (z1 : ℤ_[p]) : ((-z1 : ℤ_[p]) : ℚ_[p]) = -z1 := rfl\n\n"}
{"name":"PadicInt.coe_sub","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz1 z2 : PadicInt p\n⊢ Eq (↑(HSub.hSub z1 z2)) (HSub.hSub ↑z1 ↑z2)","decl":"@[simp, norm_cast]\ntheorem coe_sub (z1 z2 : ℤ_[p]) : ((z1 - z2 : ℤ_[p]) : ℚ_[p]) = z1 - z2 := rfl\n\n"}
{"name":"PadicInt.coe_one","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coe_one : ((1 : ℤ_[p]) : ℚ_[p]) = 1 := rfl\n\n"}
{"name":"PadicInt.coe_zero","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ((0 : ℤ_[p]) : ℚ_[p]) = 0 := rfl\n\n"}
{"name":"PadicInt.coe_eq_zero","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ Iff (Eq (↑x) 0) (Eq x 0)","decl":"@[simp] lemma coe_eq_zero : (x : ℚ_[p]) = 0 ↔ x = 0 := by rw [← coe_zero, Subtype.coe_inj]\n\n"}
{"name":"PadicInt.coe_ne_zero","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ Iff (Ne (↑x) 0) (Ne x 0)","decl":"lemma coe_ne_zero : (x : ℚ_[p]) ≠ 0 ↔ x ≠ 0 := coe_eq_zero.not\n\n"}
{"name":"PadicInt.coe_natCast","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem coe_natCast (n : ℕ) : ((n : ℤ_[p]) : ℚ_[p]) = n := rfl\n\n"}
{"name":"PadicInt.coe_intCast","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : Int\n⊢ Eq ↑↑z ↑z","decl":"@[simp, norm_cast]\ntheorem coe_intCast (z : ℤ) : ((z : ℤ_[p]) : ℚ_[p]) = z := rfl\n\n"}
{"name":"PadicInt.coe_pow","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\nn : Nat\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[simp, norm_cast]\ntheorem coe_pow (x : ℤ_[p]) (n : ℕ) : (↑(x ^ n) : ℚ_[p]) = (↑x : ℚ_[p]) ^ n := rfl\n\n"}
{"name":"PadicInt.mk_coe","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : PadicInt p\n⊢ Eq ⟨↑k, ⋯⟩ k","decl":"theorem mk_coe (k : ℤ_[p]) : (⟨k, k.2⟩ : ℤ_[p]) = k := by simp\n\n"}
{"name":"PadicInt.instCharZero","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ CharZero (PadicInt p)","decl":"instance : CharZero ℤ_[p] where\n  cast_injective m n h :=\n    Nat.cast_injective (R := ℚ_[p]) (by rw [Subtype.ext_iff] at h; norm_cast at h)\n\n"}
{"name":"PadicInt.intCast_eq","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz1 z2 : Int\n⊢ Iff (Eq ↑z1 ↑z2) (Eq z1 z2)","decl":"@[norm_cast]\ntheorem intCast_eq (z1 z2 : ℤ) : (z1 : ℤ_[p]) = z2 ↔ z1 = z2 := by simp\n\n"}
{"name":"PadicInt.instIsUltrametricDist","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ IsUltrametricDist (PadicInt p)","decl":"instance : IsUltrametricDist ℤ_[p] := IsUltrametricDist.subtype _\n\n"}
{"name":"PadicInt.completeSpace","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ CompleteSpace (PadicInt p)","decl":"instance completeSpace : CompleteSpace ℤ_[p] :=\n  have : IsClosed { x : ℚ_[p] | ‖x‖ ≤ 1 } := isClosed_le continuous_norm continuous_const\n  this.completeSpace_coe\n\n"}
{"name":"PadicInt.norm_def","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : PadicInt p\n⊢ Eq (Norm.norm z) (Norm.norm ↑z)","decl":"theorem norm_def {z : ℤ_[p]} : ‖z‖ = ‖(z : ℚ_[p])‖ := rfl\n\n"}
{"name":"PadicInt.instNormOneClass","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ NormOneClass (PadicInt p)","decl":"instance : NormOneClass ℤ_[p] :=\n  ⟨norm_def.trans norm_one⟩\n\n"}
{"name":"PadicInt.isAbsoluteValue","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ IsAbsoluteValue fun z => Norm.norm z","decl":"instance isAbsoluteValue : IsAbsoluteValue fun z : ℤ_[p] => ‖z‖ where\n  abv_nonneg' := norm_nonneg\n  abv_eq_zero' := by simp [norm_eq_zero]\n  abv_add' := fun ⟨_, _⟩ ⟨_, _⟩ => norm_add_le _ _\n  abv_mul' _ _ := by simp only [norm_def, padicNormE.mul, PadicInt.coe_mul]\n\n"}
{"name":"PadicInt.instIsDomain","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ IsDomain (PadicInt p)","decl":"instance : IsDomain ℤ_[p] := Function.Injective.isDomain (subring p).subtype Subtype.coe_injective\n\n"}
{"name":"PadicInt.norm_le_one","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : PadicInt p\n⊢ LE.le (Norm.norm z) 1","decl":"theorem norm_le_one (z : ℤ_[p]) : ‖z‖ ≤ 1 := z.2\n\n"}
{"name":"PadicInt.norm_mul","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz1 z2 : PadicInt p\n⊢ Eq (Norm.norm (HMul.hMul z1 z2)) (HMul.hMul (Norm.norm z1) (Norm.norm z2))","decl":"@[simp]\ntheorem norm_mul (z1 z2 : ℤ_[p]) : ‖z1 * z2‖ = ‖z1‖ * ‖z2‖ := by simp [norm_def]\n\n"}
{"name":"PadicInt.norm_pow","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : PadicInt p\nn : Nat\n⊢ Eq (Norm.norm (HPow.hPow z n)) (HPow.hPow (Norm.norm z) n)","decl":"@[simp]\ntheorem norm_pow (z : ℤ_[p]) : ∀ n : ℕ, ‖z ^ n‖ = ‖z‖ ^ n\n  | 0 => by simp\n  | k + 1 => by\n    rw [pow_succ, pow_succ, norm_mul]\n    congr\n    apply norm_pow\n\n"}
{"name":"PadicInt.nonarchimedean","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : PadicInt p\n⊢ LE.le (Norm.norm (HAdd.hAdd q r)) (Max.max (Norm.norm q) (Norm.norm r))","decl":"theorem nonarchimedean (q r : ℤ_[p]) : ‖q + r‖ ≤ max ‖q‖ ‖r‖ := padicNormE.nonarchimedean _ _\n\n"}
{"name":"PadicInt.norm_add_eq_max_of_ne","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : PadicInt p\na✝ : Ne (Norm.norm q) (Norm.norm r)\n⊢ Eq (Norm.norm (HAdd.hAdd q r)) (Max.max (Norm.norm q) (Norm.norm r))","decl":"theorem norm_add_eq_max_of_ne {q r : ℤ_[p]} : ‖q‖ ≠ ‖r‖ → ‖q + r‖ = max ‖q‖ ‖r‖ :=\n  padicNormE.add_eq_max_of_ne\n\n"}
{"name":"PadicInt.norm_eq_of_norm_add_lt_right","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz1 z2 : PadicInt p\nh : LT.lt (Norm.norm (HAdd.hAdd z1 z2)) (Norm.norm z2)\n⊢ Eq (Norm.norm z1) (Norm.norm z2)","decl":"theorem norm_eq_of_norm_add_lt_right {z1 z2 : ℤ_[p]} (h : ‖z1 + z2‖ < ‖z2‖) : ‖z1‖ = ‖z2‖ :=\n  by_contra fun hne =>\n    not_lt_of_ge (by rw [norm_add_eq_max_of_ne hne]; apply le_max_right) h\n\n"}
{"name":"PadicInt.norm_eq_of_norm_add_lt_left","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz1 z2 : PadicInt p\nh : LT.lt (Norm.norm (HAdd.hAdd z1 z2)) (Norm.norm z1)\n⊢ Eq (Norm.norm z1) (Norm.norm z2)","decl":"theorem norm_eq_of_norm_add_lt_left {z1 z2 : ℤ_[p]} (h : ‖z1 + z2‖ < ‖z1‖) : ‖z1‖ = ‖z2‖ :=\n  by_contra fun hne =>\n    not_lt_of_ge (by rw [norm_add_eq_max_of_ne hne]; apply le_max_left) h\n\n"}
{"name":"PadicInt.padic_norm_e_of_padicInt","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : PadicInt p\n⊢ Eq (Norm.norm ↑z) (Norm.norm z)","decl":"@[simp]\ntheorem padic_norm_e_of_padicInt (z : ℤ_[p]) : ‖(z : ℚ_[p])‖ = ‖z‖ := by simp [norm_def]\n\n"}
{"name":"PadicInt.norm_intCast_eq_padic_norm","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : Int\n⊢ Eq (Norm.norm ↑z) (Norm.norm ↑z)","decl":"theorem norm_intCast_eq_padic_norm (z : ℤ) : ‖(z : ℤ_[p])‖ = ‖(z : ℚ_[p])‖ := by simp [norm_def]\n\n"}
{"name":"PadicInt.norm_eq_padic_norm","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Padic p\nhq : LE.le (Norm.norm q) 1\n⊢ Eq (Norm.norm ⟨q, hq⟩) (Norm.norm q)","decl":"@[simp]\ntheorem norm_eq_padic_norm {q : ℚ_[p]} (hq : ‖q‖ ≤ 1) : @norm ℤ_[p] _ ⟨q, hq⟩ = ‖q‖ := rfl\n\n"}
{"name":"PadicInt.norm_p","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (Norm.norm ↑p) (Inv.inv ↑p)","decl":"@[simp]\ntheorem norm_p : ‖(p : ℤ_[p])‖ = (p : ℝ)⁻¹ := padicNormE.norm_p\n\n"}
{"name":"PadicInt.norm_p_pow","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n⊢ Eq (Norm.norm (HPow.hPow (↑p) n)) (HPow.hPow (↑p) (Neg.neg ↑n))","decl":"theorem norm_p_pow (n : ℕ) : ‖(p : ℤ_[p]) ^ n‖ = (p : ℝ) ^ (-n : ℤ) := by simp\n\n"}
{"name":"PadicInt.complete","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ CauSeq.IsComplete (PadicInt p) Norm.norm","decl":"instance complete : CauSeq.IsComplete ℤ_[p] norm :=\n  ⟨fun f =>\n    have hqn : ‖CauSeq.lim (cauSeq_to_rat_cauSeq f)‖ ≤ 1 :=\n      padicNormE_lim_le zero_lt_one fun _ => norm_le_one _\n    ⟨⟨_, hqn⟩, fun ε => by\n      simpa [norm, norm_def] using CauSeq.equiv_lim (cauSeq_to_rat_cauSeq f) ε⟩⟩\n\n"}
{"name":"PadicInt.exists_pow_neg_lt","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun k => LT.lt (HPow.hPow (↑p) (Neg.neg ↑k)) ε","decl":"theorem exists_pow_neg_lt {ε : ℝ} (hε : 0 < ε) : ∃ k : ℕ, (p : ℝ) ^ (-(k : ℤ)) < ε := by\n  obtain ⟨k, hk⟩ := exists_nat_gt ε⁻¹\n  use k\n  rw [← inv_lt_inv₀ hε (zpow_pos _ _)]\n  · rw [zpow_neg, inv_inv, zpow_natCast]\n    apply lt_of_lt_of_le hk\n    norm_cast\n    apply le_of_lt\n    convert Nat.lt_pow_self _ using 1\n    exact hp.1.one_lt\n  · exact mod_cast hp.1.pos\n\n"}
{"name":"PadicInt.exists_pow_neg_lt_rat","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nε : Rat\nhε : LT.lt 0 ε\n⊢ Exists fun k => LT.lt (HPow.hPow (↑p) (Neg.neg ↑k)) ε","decl":"theorem exists_pow_neg_lt_rat {ε : ℚ} (hε : 0 < ε) : ∃ k : ℕ, (p : ℚ) ^ (-(k : ℤ)) < ε := by\n  obtain ⟨k, hk⟩ := @exists_pow_neg_lt p _ ε (mod_cast hε)\n  use k\n  rw [show (p : ℝ) = (p : ℚ) by simp] at hk\n  exact mod_cast hk\n\n"}
{"name":"PadicInt.norm_int_lt_one_iff_dvd","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Int\n⊢ Iff (LT.lt (Norm.norm ↑k) 1) (Dvd.dvd (↑p) k)","decl":"theorem norm_int_lt_one_iff_dvd (k : ℤ) : ‖(k : ℤ_[p])‖ < 1 ↔ (p : ℤ) ∣ k :=\n  suffices ‖(k : ℚ_[p])‖ < 1 ↔ ↑p ∣ k by rwa [norm_intCast_eq_padic_norm]\n  padicNormE.norm_int_lt_one_iff_dvd k\n\n"}
{"name":"PadicInt.norm_int_le_pow_iff_dvd","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Int\nn : Nat\n⊢ Iff (LE.le (Norm.norm ↑k) (HPow.hPow (↑p) (Neg.neg ↑n))) (Dvd.dvd (HPow.hPow (↑p) n) k)","decl":"theorem norm_int_le_pow_iff_dvd {k : ℤ} {n : ℕ} :\n    ‖(k : ℤ_[p])‖ ≤ (p : ℝ) ^ (-n : ℤ) ↔ (p ^ n : ℤ) ∣ k :=\n  suffices ‖(k : ℚ_[p])‖ ≤ (p : ℝ) ^ (-n : ℤ) ↔ (p ^ n : ℤ) ∣ k by\n    simpa [norm_intCast_eq_padic_norm]\n  padicNormE.norm_int_le_pow_iff_dvd _ _\n\n"}
{"name":"PadicInt.valuation_coe_nonneg","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ LE.le 0 (↑x).valuation","decl":"lemma valuation_coe_nonneg : 0 ≤ (x : ℚ_[p]).valuation := by\n  obtain rfl | hx := eq_or_ne x 0\n  · simp\n  have := x.2\n  rwa [Padic.norm_eq_zpow_neg_valuation <| coe_ne_zero.2 hx, zpow_le_one_iff_right₀, neg_nonpos]\n    at this\n  exact mod_cast hp.out.one_lt\n\n"}
{"name":"PadicInt.valuation_coe","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ Eq (↑x).valuation ↑x.valuation","decl":"@[simp, norm_cast] lemma valuation_coe (x : ℤ_[p]) : (x : ℚ_[p]).valuation = x.valuation := by\n  simp [valuation, valuation_coe_nonneg]\n\n"}
{"name":"PadicInt.valuation_zero","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (PadicInt.valuation 0) 0","decl":"@[simp] lemma valuation_zero : valuation (0 : ℤ_[p]) = 0 := by simp [valuation]\n"}
{"name":"PadicInt.valuation_one","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (PadicInt.valuation 1) 0","decl":"@[simp] lemma valuation_one : valuation (1 : ℤ_[p]) = 0 := by simp [valuation]\n"}
{"name":"PadicInt.valuation_p","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (↑p).valuation 1","decl":"@[simp] lemma valuation_p : valuation (p : ℤ_[p]) = 1 := by simp [valuation]\n\n"}
{"name":"PadicInt.le_valuation_add","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx y : PadicInt p\nhxy : Ne (HAdd.hAdd x y) 0\n⊢ LE.le (Min.min x.valuation y.valuation) (HAdd.hAdd x y).valuation","decl":"lemma le_valuation_add (hxy : x + y ≠ 0) : min x.valuation y.valuation ≤ (x + y).valuation := by\n  zify; simpa [← valuation_coe] using Padic.le_valuation_add <| coe_ne_zero.2 hxy\n\n"}
{"name":"PadicInt.valuation_mul","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx y : PadicInt p\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (HMul.hMul x y).valuation (HAdd.hAdd x.valuation y.valuation)","decl":"@[simp] lemma valuation_mul (hx : x ≠ 0) (hy : y ≠ 0) :\n    (x * y).valuation = x.valuation + y.valuation := by\n  zify; simp [← valuation_coe, Padic.valuation_mul (coe_ne_zero.2 hx) (coe_ne_zero.2 hy)]\n\n"}
{"name":"PadicInt.valuation_pow","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\nn : Nat\n⊢ Eq (HPow.hPow x n).valuation (HMul.hMul n x.valuation)","decl":"@[simp]\nlemma valuation_pow (x : ℤ_[p]) (n : ℕ) : (x ^ n).valuation = n * x.valuation := by\n  zify; simp [← valuation_coe]\n\n"}
{"name":"PadicInt.norm_eq_zpow_neg_valuation","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\nhx : Ne x 0\n⊢ Eq (Norm.norm x) (HPow.hPow (↑p) (Neg.neg ↑x.valuation))","decl":"lemma norm_eq_zpow_neg_valuation {x : ℤ_[p]} (hx : x ≠ 0) : ‖x‖ = p ^ (-x.valuation : ℤ) := by\n  simp [norm_def, Padic.norm_eq_zpow_neg_valuation <| coe_ne_zero.2 hx]\n\n"}
{"name":"PadicInt.norm_eq_pow_val","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\nhx : Ne x 0\n⊢ Eq (Norm.norm x) (HPow.hPow (↑p) (Neg.neg ↑x.valuation))","decl":"@[deprecated (since := \"2024-12-10\")] alias norm_eq_pow_val := norm_eq_zpow_neg_valuation\n\n-- TODO: Do we really need this lemma?\n"}
{"name":"PadicInt.valuation_p_pow_mul","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\nc : PadicInt p\nhc : Ne c 0\n⊢ Eq (HMul.hMul (HPow.hPow (↑p) n) c).valuation (HAdd.hAdd n c.valuation)","decl":"@[simp]\ntheorem valuation_p_pow_mul (n : ℕ) (c : ℤ_[p]) (hc : c ≠ 0) :\n    ((p : ℤ_[p]) ^ n * c).valuation = n + c.valuation := by\n  rw [valuation_mul (NeZero.ne _) hc, valuation_pow, valuation_p, mul_one]\n\n"}
{"name":"PadicInt.mul_inv","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : PadicInt p\na✝ : Eq (Norm.norm z) 1\n⊢ Eq (HMul.hMul z z.inv) 1","decl":"theorem mul_inv : ∀ {z : ℤ_[p]}, ‖z‖ = 1 → z * z.inv = 1\n  | ⟨k, _⟩, h => by\n    have hk : k ≠ 0 := fun h' => zero_ne_one' ℚ_[p] (by simp [h'] at h)\n    unfold PadicInt.inv\n    rw [norm_eq_padic_norm] at h\n    dsimp only\n    rw [dif_pos h]\n    apply Subtype.ext_iff_val.2\n    simp [mul_inv_cancel₀ hk]\n\n"}
{"name":"PadicInt.inv_mul","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : PadicInt p\nhz : Eq (Norm.norm z) 1\n⊢ Eq (HMul.hMul z.inv z) 1","decl":"theorem inv_mul {z : ℤ_[p]} (hz : ‖z‖ = 1) : z.inv * z = 1 := by rw [mul_comm, mul_inv hz]\n\n"}
{"name":"PadicInt.isUnit_iff","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : PadicInt p\n⊢ Iff (IsUnit z) (Eq (Norm.norm z) 1)","decl":"theorem isUnit_iff {z : ℤ_[p]} : IsUnit z ↔ ‖z‖ = 1 :=\n  ⟨fun h => by\n    rcases isUnit_iff_dvd_one.1 h with ⟨w, eq⟩\n    refine le_antisymm (norm_le_one _) ?_\n    have := mul_le_mul_of_nonneg_left (norm_le_one w) (norm_nonneg z)\n    rwa [mul_one, ← norm_mul, ← eq, norm_one] at this, fun h =>\n    ⟨⟨z, z.inv, mul_inv h, inv_mul h⟩, rfl⟩⟩\n\n"}
{"name":"PadicInt.norm_lt_one_add","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz1 z2 : PadicInt p\nhz1 : LT.lt (Norm.norm z1) 1\nhz2 : LT.lt (Norm.norm z2) 1\n⊢ LT.lt (Norm.norm (HAdd.hAdd z1 z2)) 1","decl":"theorem norm_lt_one_add {z1 z2 : ℤ_[p]} (hz1 : ‖z1‖ < 1) (hz2 : ‖z2‖ < 1) : ‖z1 + z2‖ < 1 :=\n  lt_of_le_of_lt (nonarchimedean _ _) (max_lt hz1 hz2)\n\n"}
{"name":"PadicInt.norm_lt_one_mul","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz1 z2 : PadicInt p\nhz2 : LT.lt (Norm.norm z2) 1\n⊢ LT.lt (Norm.norm (HMul.hMul z1 z2)) 1","decl":"theorem norm_lt_one_mul {z1 z2 : ℤ_[p]} (hz2 : ‖z2‖ < 1) : ‖z1 * z2‖ < 1 :=\n  calc\n    ‖z1 * z2‖ = ‖z1‖ * ‖z2‖ := by simp\n    _ < 1 := mul_lt_one_of_nonneg_of_lt_one_right (norm_le_one _) (norm_nonneg _) hz2\n\n"}
{"name":"PadicInt.mem_nonunits","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : PadicInt p\n⊢ Iff (Membership.mem (nonunits (PadicInt p)) z) (LT.lt (Norm.norm z) 1)","decl":"theorem mem_nonunits {z : ℤ_[p]} : z ∈ nonunits ℤ_[p] ↔ ‖z‖ < 1 := by\n  rw [lt_iff_le_and_ne]; simp [norm_le_one z, nonunits, isUnit_iff]\n\n"}
{"name":"PadicInt.not_isUnit_iff","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nz : PadicInt p\n⊢ Iff (Not (IsUnit z)) (LT.lt (Norm.norm z) 1)","decl":"theorem not_isUnit_iff {z : ℤ_[p]} : ¬IsUnit z ↔ ‖z‖ < 1 := by\n  simpa using mem_nonunits\n\n"}
{"name":"PadicInt.mkUnits_eq","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nu : Padic p\nh : Eq (Norm.norm u) 1\n⊢ Eq (↑↑(PadicInt.mkUnits h)) u","decl":"@[simp]\ntheorem mkUnits_eq {u : ℚ_[p]} (h : ‖u‖ = 1) : ((mkUnits h : ℤ_[p]) : ℚ_[p]) = u := rfl\n\n"}
{"name":"PadicInt.norm_units","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nu : Units (PadicInt p)\n⊢ Eq (Norm.norm ↑u) 1","decl":"@[simp]\ntheorem norm_units (u : ℤ_[p]ˣ) : ‖(u : ℤ_[p])‖ = 1 := isUnit_iff.mp <| by simp\n\n"}
{"name":"PadicInt.unitCoeff_coe","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\nhx : Ne x 0\n⊢ Eq (↑↑(PadicInt.unitCoeff hx)) (HMul.hMul (↑x) (HPow.hPow (↑p) (Neg.neg ↑x.valuation)))","decl":"@[simp]\ntheorem unitCoeff_coe {x : ℤ_[p]} (hx : x ≠ 0) :\n    (unitCoeff hx : ℚ_[p]) = x * (p : ℚ_[p]) ^ (-x.valuation : ℤ) := rfl\n\n"}
{"name":"PadicInt.unitCoeff_spec","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\nhx : Ne x 0\n⊢ Eq x (HMul.hMul (↑(PadicInt.unitCoeff hx)) (HPow.hPow (↑p) x.valuation))","decl":"theorem unitCoeff_spec {x : ℤ_[p]} (hx : x ≠ 0) :\n    x = (unitCoeff hx : ℤ_[p]) * (p : ℤ_[p]) ^ x.valuation := by\n  apply Subtype.coe_injective\n  push_cast\n  rw [unitCoeff_coe, mul_assoc, ← zpow_natCast, ← zpow_add₀]\n  · simp\n  · exact NeZero.ne _\n\n"}
{"name":"PadicInt.norm_le_pow_iff_le_valuation","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\nhx : Ne x 0\nn : Nat\n⊢ Iff (LE.le (Norm.norm x) (HPow.hPow (↑p) (Neg.neg ↑n))) (LE.le n x.valuation)","decl":"theorem norm_le_pow_iff_le_valuation (x : ℤ_[p]) (hx : x ≠ 0) (n : ℕ) :\n    ‖x‖ ≤ (p : ℝ) ^ (-n : ℤ) ↔ n ≤ x.valuation := by\n  rw [norm_eq_zpow_neg_valuation hx, zpow_le_zpow_iff_right₀, neg_le_neg_iff, Nat.cast_le]\n  exact mod_cast hp.out.one_lt\n\n"}
{"name":"PadicInt.mem_span_pow_iff_le_valuation","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\nhx : Ne x 0\nn : Nat\n⊢ Iff (Membership.mem (Ideal.span (Singleton.singleton (HPow.hPow (↑p) n))) x) (LE.le n x.valuation)","decl":"theorem mem_span_pow_iff_le_valuation (x : ℤ_[p]) (hx : x ≠ 0) (n : ℕ) :\n    x ∈ (Ideal.span {(p : ℤ_[p]) ^ n} : Ideal ℤ_[p]) ↔ n ≤ x.valuation := by\n  rw [Ideal.mem_span_singleton]\n  constructor\n  · rintro ⟨c, rfl⟩\n    suffices c ≠ 0 by\n      rw [valuation_p_pow_mul _ _ this]\n      exact le_self_add\n    contrapose! hx\n    rw [hx, mul_zero]\n  · nth_rewrite 2 [unitCoeff_spec hx]\n    simpa [Units.isUnit, IsUnit.dvd_mul_left] using pow_dvd_pow _\n\n"}
{"name":"PadicInt.norm_le_pow_iff_mem_span_pow","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\nn : Nat\n⊢ Iff (LE.le (Norm.norm x) (HPow.hPow (↑p) (Neg.neg ↑n))) (Membership.mem (Ideal.span (Singleton.singleton (HPow.hPow (↑p) n))) x)","decl":"theorem norm_le_pow_iff_mem_span_pow (x : ℤ_[p]) (n : ℕ) :\n    ‖x‖ ≤ (p : ℝ) ^ (-n : ℤ) ↔ x ∈ (Ideal.span {(p : ℤ_[p]) ^ n} : Ideal ℤ_[p]) := by\n  by_cases hx : x = 0\n  · subst hx\n    simp only [norm_zero, zpow_neg, zpow_natCast, inv_nonneg, iff_true, Submodule.zero_mem]\n    exact mod_cast Nat.zero_le _\n  rw [norm_le_pow_iff_le_valuation x hx, mem_span_pow_iff_le_valuation x hx]\n\n"}
{"name":"PadicInt.norm_le_pow_iff_norm_lt_pow_add_one","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\nn : Int\n⊢ Iff (LE.le (Norm.norm x) (HPow.hPow (↑p) n)) (LT.lt (Norm.norm x) (HPow.hPow (↑p) (HAdd.hAdd n 1)))","decl":"theorem norm_le_pow_iff_norm_lt_pow_add_one (x : ℤ_[p]) (n : ℤ) :\n    ‖x‖ ≤ (p : ℝ) ^ n ↔ ‖x‖ < (p : ℝ) ^ (n + 1) := by\n  rw [norm_def]; exact Padic.norm_le_pow_iff_norm_lt_pow_add_one _ _\n\n"}
{"name":"PadicInt.norm_lt_pow_iff_norm_le_pow_sub_one","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\nn : Int\n⊢ Iff (LT.lt (Norm.norm x) (HPow.hPow (↑p) n)) (LE.le (Norm.norm x) (HPow.hPow (↑p) (HSub.hSub n 1)))","decl":"theorem norm_lt_pow_iff_norm_le_pow_sub_one (x : ℤ_[p]) (n : ℤ) :\n    ‖x‖ < (p : ℝ) ^ n ↔ ‖x‖ ≤ (p : ℝ) ^ (n - 1) := by\n  rw [norm_le_pow_iff_norm_lt_pow_add_one, sub_add_cancel]\n\n"}
{"name":"PadicInt.norm_lt_one_iff_dvd","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ Iff (LT.lt (Norm.norm x) 1) (Dvd.dvd (↑p) x)","decl":"theorem norm_lt_one_iff_dvd (x : ℤ_[p]) : ‖x‖ < 1 ↔ ↑p ∣ x := by\n  have := norm_le_pow_iff_mem_span_pow x 1\n  rw [Ideal.mem_span_singleton, pow_one] at this\n  rw [← this, norm_le_pow_iff_norm_lt_pow_add_one]\n  simp only [zpow_zero, Int.ofNat_zero, Int.ofNat_succ, neg_add_cancel, zero_add]\n\n"}
{"name":"PadicInt.pow_p_dvd_int_iff","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\na : Int\n⊢ Iff (Dvd.dvd (HPow.hPow (↑p) n) ↑a) (Dvd.dvd (HPow.hPow (↑p) n) a)","decl":"@[simp]\ntheorem pow_p_dvd_int_iff (n : ℕ) (a : ℤ) : (p : ℤ_[p]) ^ n ∣ a ↔ (p ^ n : ℤ) ∣ a := by\n  rw [← Nat.cast_pow, ← norm_int_le_pow_iff_dvd, norm_le_pow_iff_mem_span_pow,\n    Ideal.mem_span_singleton, Nat.cast_pow]\n\n"}
{"name":"PadicInt.instIsLocalRing","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ IsLocalRing (PadicInt p)","decl":"instance : IsLocalRing ℤ_[p] :=\n  IsLocalRing.of_nonunits_add <| by simp only [mem_nonunits]; exact fun x y => norm_lt_one_add\n\n"}
{"name":"PadicInt.p_nonnunit","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Membership.mem (nonunits (PadicInt p)) ↑p","decl":"theorem p_nonnunit : (p : ℤ_[p]) ∈ nonunits ℤ_[p] := by\n  have : (p : ℝ)⁻¹ < 1 := inv_lt_one_of_one_lt₀ <| mod_cast hp.out.one_lt\n  rwa [← norm_p, ← mem_nonunits] at this\n\n"}
{"name":"PadicInt.maximalIdeal_eq_span_p","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (IsLocalRing.maximalIdeal (PadicInt p)) (Ideal.span (Singleton.singleton ↑p))","decl":"theorem maximalIdeal_eq_span_p : maximalIdeal ℤ_[p] = Ideal.span {(p : ℤ_[p])} := by\n  apply le_antisymm\n  · intro x hx\n    simp only [IsLocalRing.mem_maximalIdeal, mem_nonunits] at hx\n    rwa [Ideal.mem_span_singleton, ← norm_lt_one_iff_dvd]\n  · rw [Ideal.span_le, Set.singleton_subset_iff]\n    exact p_nonnunit\n\n"}
{"name":"PadicInt.prime_p","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Prime ↑p","decl":"theorem prime_p : Prime (p : ℤ_[p]) := by\n  rw [← Ideal.span_singleton_prime, ← maximalIdeal_eq_span_p]\n  · infer_instance\n  · exact NeZero.ne _\n\n"}
{"name":"PadicInt.irreducible_p","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Irreducible ↑p","decl":"theorem irreducible_p : Irreducible (p : ℤ_[p]) := Prime.irreducible prime_p\n\n"}
{"name":"PadicInt.instIsDiscreteValuationRing","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ IsDiscreteValuationRing (PadicInt p)","decl":"instance : IsDiscreteValuationRing ℤ_[p] :=\n  IsDiscreteValuationRing.ofHasUnitMulPowIrreducibleFactorization\n    ⟨p, irreducible_p, fun {x hx} =>\n      ⟨x.valuation, unitCoeff hx, by rw [mul_comm, ← unitCoeff_spec hx]⟩⟩\n\n"}
{"name":"PadicInt.ideal_eq_span_pow_p","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\ns : Ideal (PadicInt p)\nhs : Ne s Bot.bot\n⊢ Exists fun n => Eq s (Ideal.span (Singleton.singleton (HPow.hPow (↑p) n)))","decl":"theorem ideal_eq_span_pow_p {s : Ideal ℤ_[p]} (hs : s ≠ ⊥) :\n    ∃ n : ℕ, s = Ideal.span {(p : ℤ_[p]) ^ n} :=\n  IsDiscreteValuationRing.ideal_eq_span_pow_irreducible hs irreducible_p\n\n"}
{"name":"PadicInt.instIsAdicCompleteMaximalIdeal","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ IsAdicComplete (IsLocalRing.maximalIdeal (PadicInt p)) (PadicInt p)","decl":"instance : IsAdicComplete (maximalIdeal ℤ_[p]) ℤ_[p] where\n  prec' x hx := by\n    simp only [← Ideal.one_eq_top, smul_eq_mul, mul_one, SModEq.sub_mem, maximalIdeal_eq_span_p,\n      Ideal.span_singleton_pow, ← norm_le_pow_iff_mem_span_pow] at hx ⊢\n    let x' : CauSeq ℤ_[p] norm := ⟨x, ?_⟩; swap\n    · intro ε hε\n      obtain ⟨m, hm⟩ := exists_pow_neg_lt p hε\n      refine ⟨m, fun n hn => lt_of_le_of_lt ?_ hm⟩\n      rw [← neg_sub, norm_neg]\n      exact hx hn\n    · refine ⟨x'.lim, fun n => ?_⟩\n      have : (0 : ℝ) < (p : ℝ) ^ (-n : ℤ) := zpow_pos (mod_cast hp.out.pos) _\n      obtain ⟨i, hi⟩ := equiv_def₃ (equiv_lim x') this\n      by_cases hin : i ≤ n\n      · exact (hi i le_rfl n hin).le\n      · push_neg at hin\n        specialize hi i le_rfl i le_rfl\n        specialize hx hin.le\n        have := nonarchimedean (x n - x i : ℤ_[p]) (x i - x'.lim)\n        rw [sub_add_sub_cancel] at this\n        exact this.trans (max_le_iff.mpr ⟨hx, hi.le⟩)\n\n"}
{"name":"PadicInt.algebraMap_apply","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ Eq ((algebraMap (PadicInt p) (Padic p)) x) ↑x","decl":"@[simp]\ntheorem algebraMap_apply (x : ℤ_[p]) : algebraMap ℤ_[p] ℚ_[p] x = x :=\n  rfl\n\n"}
{"name":"PadicInt.isFractionRing","module":"Mathlib.NumberTheory.Padics.PadicIntegers","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ IsFractionRing (PadicInt p) (Padic p)","decl":"instance isFractionRing : IsFractionRing ℤ_[p] ℚ_[p] where\n  map_units' := fun ⟨x, hx⟩ => by\n    rwa [algebraMap_apply, isUnit_iff_ne_zero, PadicInt.coe_ne_zero, ←\n      mem_nonZeroDivisors_iff_ne_zero]\n  surj' x := by\n    by_cases hx : ‖x‖ ≤ 1\n    · use (⟨x, hx⟩, 1)\n      rw [Submonoid.coe_one, map_one, mul_one, PadicInt.algebraMap_apply, Subtype.coe_mk]\n    · set n := Int.toNat (-x.valuation) with hn\n      have hn_coe : (n : ℤ) = -x.valuation := by\n        rw [hn, Int.toNat_of_nonneg]\n        rw [Right.nonneg_neg_iff]\n        rw [Padic.norm_le_one_iff_val_nonneg, not_le] at hx\n        exact hx.le\n      set a := x * (p : ℚ_[p]) ^ n with ha\n      have ha_norm : ‖a‖ = 1 := by\n        have hx : x ≠ 0 := by\n          intro h0\n          rw [h0, norm_zero] at hx\n          exact hx zero_le_one\n        rw [ha, padicNormE.mul, padicNormE.norm_p_pow, Padic.norm_eq_zpow_neg_valuation hx,\n          ← zpow_add', hn_coe, neg_neg, neg_add_cancel, zpow_zero]\n        exact Or.inl (Nat.cast_ne_zero.mpr (NeZero.ne p))\n      use\n        (⟨a, le_of_eq ha_norm⟩,\n          ⟨(p ^ n : ℤ_[p]), mem_nonZeroDivisors_iff_ne_zero.mpr (NeZero.ne _)⟩)\n      simp only [a, map_pow, map_natCast, algebraMap_apply, PadicInt.coe_pow,\n        PadicInt.coe_natCast, Subtype.coe_mk, Nat.cast_pow]\n  exists_of_eq := by\n    simp_rw [algebraMap_apply, Subtype.coe_inj]\n    exact fun h => ⟨1, by rw [h]⟩\n\n"}
