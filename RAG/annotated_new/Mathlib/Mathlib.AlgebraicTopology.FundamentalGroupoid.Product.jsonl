{"name":"FundamentalGroupoidFunctor.proj_map","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"I : Type u\nX : I ‚Üí TopCat\ni : I\nx‚ÇÄ x‚ÇÅ : ‚Üë(FundamentalGroupoid.fundamentalGroupoidFunctor.obj (TopCat.of ((i : I) ‚Üí ‚Üë(X i))))\np : Quiver.Hom x‚ÇÄ x‚ÇÅ\n‚ä¢ Eq ((FundamentalGroupoidFunctor.proj X i).map p) (Path.Homotopic.proj i p)","decl":"/-- The projection map is precisely `Path.Homotopic.proj` interpreted as a functor -/\n@[simp]\ntheorem proj_map (i : I) (x‚ÇÄ x‚ÇÅ : œÄ‚Çì (TopCat.of (‚àÄ i, X i))) (p : x‚ÇÄ ‚ü∂ x‚ÇÅ) :\n    (proj X i).map p = @Path.Homotopic.proj _ _ _ _ _ i p :=\n  rfl\n\n"}
{"name":"FundamentalGroupoidFunctor.piToPiTop_obj_as","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"I : Type u\nX : I ‚Üí TopCat\ng : (i : I) ‚Üí ‚Üë(FundamentalGroupoid.fundamentalGroupoidFunctor.obj (X i))\ni : I\n‚ä¢ Eq (((FundamentalGroupoidFunctor.piToPiTop X).obj g).as i) (g i).as","decl":"/-- The map taking the pi product of a family of fundamental groupoids to the fundamental\ngroupoid of the pi product. This is actually an isomorphism (see `piIso`)\n-/\n@[simps]\ndef piToPiTop : (‚àÄ i, œÄ‚Çì (X i)) ‚•§ œÄ‚Çì (TopCat.of (‚àÄ i, X i)) where\n  obj g := ‚ü®fun i => (g i).as‚ü©\n  map p := Path.Homotopic.pi p\n  map_id x := by\n    change (Path.Homotopic.pi fun i => ‚ü¶_‚üß) = _\n    simp only [FundamentalGroupoid.id_eq_path_refl, Path.Homotopic.pi_lift]\n    rfl\n  map_comp f g := (Path.Homotopic.comp_pi_eq_pi_comp f g).symm\n\n"}
{"name":"FundamentalGroupoidFunctor.piToPiTop_map","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"I : Type u\nX : I ‚Üí TopCat\nX‚úù Y‚úù : (i : I) ‚Üí ‚Üë(FundamentalGroupoid.fundamentalGroupoidFunctor.obj (X i))\np : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((FundamentalGroupoidFunctor.piToPiTop X).map p) (Path.Homotopic.pi p)","decl":"/-- The map taking the pi product of a family of fundamental groupoids to the fundamental\ngroupoid of the pi product. This is actually an isomorphism (see `piIso`)\n-/\n@[simps]\ndef piToPiTop : (‚àÄ i, œÄ‚Çì (X i)) ‚•§ œÄ‚Çì (TopCat.of (‚àÄ i, X i)) where\n  obj g := ‚ü®fun i => (g i).as‚ü©\n  map p := Path.Homotopic.pi p\n  map_id x := by\n    change (Path.Homotopic.pi fun i => ‚ü¶_‚üß) = _\n    simp only [FundamentalGroupoid.id_eq_path_refl, Path.Homotopic.pi_lift]\n    rfl\n  map_comp f g := (Path.Homotopic.comp_pi_eq_pi_comp f g).symm\n\n"}
{"name":"FundamentalGroupoidFunctor.piIso_inv","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"I : Type u\nX : I ‚Üí TopCat\n‚ä¢ Eq (FundamentalGroupoidFunctor.piIso X).inv (CategoryTheory.Functor.pi' (FundamentalGroupoidFunctor.proj X))","decl":"/-- Shows `piToPiTop` is an isomorphism, whose inverse is precisely the pi product\nof the induced projections. This shows that `fundamentalGroupoidFunctor` preserves products.\n-/\n@[simps]\ndef piIso : CategoryTheory.Grpd.of (‚àÄ i : I, œÄ‚Çì (X i)) ‚âÖ œÄ‚Çì (TopCat.of (‚àÄ i, X i)) where\n  hom := piToPiTop X\n  inv := CategoryTheory.Functor.pi' (proj X)\n  hom_inv_id := by\n    change piToPiTop X ‚ãô CategoryTheory.Functor.pi' (proj X) = ùü≠ _\n    apply CategoryTheory.Functor.ext ?_ ?_\n    ¬∑ intros; rfl\n    ¬∑ intros; ext; simp\n  inv_hom_id := by\n    change CategoryTheory.Functor.pi' (proj X) ‚ãô piToPiTop X = ùü≠ _\n    apply CategoryTheory.Functor.ext\n    ¬∑ intro _ _ f\n      suffices Path.Homotopic.pi ((CategoryTheory.Functor.pi' (proj X)).map f) = f by simpa\n      change Path.Homotopic.pi (fun i => (CategoryTheory.Functor.pi' (proj X)).map f i) = _\n      simp\n    ¬∑ intros; rfl\n\n"}
{"name":"FundamentalGroupoidFunctor.piIso_hom","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"I : Type u\nX : I ‚Üí TopCat\n‚ä¢ Eq (FundamentalGroupoidFunctor.piIso X).hom (FundamentalGroupoidFunctor.piToPiTop X)","decl":"/-- Shows `piToPiTop` is an isomorphism, whose inverse is precisely the pi product\nof the induced projections. This shows that `fundamentalGroupoidFunctor` preserves products.\n-/\n@[simps]\ndef piIso : CategoryTheory.Grpd.of (‚àÄ i : I, œÄ‚Çì (X i)) ‚âÖ œÄ‚Çì (TopCat.of (‚àÄ i, X i)) where\n  hom := piToPiTop X\n  inv := CategoryTheory.Functor.pi' (proj X)\n  hom_inv_id := by\n    change piToPiTop X ‚ãô CategoryTheory.Functor.pi' (proj X) = ùü≠ _\n    apply CategoryTheory.Functor.ext ?_ ?_\n    ¬∑ intros; rfl\n    ¬∑ intros; ext; simp\n  inv_hom_id := by\n    change CategoryTheory.Functor.pi' (proj X) ‚ãô piToPiTop X = ùü≠ _\n    apply CategoryTheory.Functor.ext\n    ¬∑ intro _ _ f\n      suffices Path.Homotopic.pi ((CategoryTheory.Functor.pi' (proj X)).map f) = f by simpa\n      change Path.Homotopic.pi (fun i => (CategoryTheory.Functor.pi' (proj X)).map f i) = _\n      simp\n    ¬∑ intros; rfl\n\n"}
{"name":"FundamentalGroupoidFunctor.coneDiscreteComp_obj_mapCone","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"I : Type u\nX : I ‚Üí TopCat\n‚ä¢ Eq ((FundamentalGroupoidFunctor.coneDiscreteComp X).functor.obj (FundamentalGroupoid.fundamentalGroupoidFunctor.mapCone (TopCat.piFan X))) (CategoryTheory.Limits.Fan.mk (FundamentalGroupoid.fundamentalGroupoidFunctor.obj (TopCat.of ((i : I) ‚Üí ‚Üë(X i)))) (FundamentalGroupoidFunctor.proj X))","decl":"theorem coneDiscreteComp_obj_mapCone :\n    -- Porting note: check universe parameters here\n    (coneDiscreteComp X).functor.obj (Functor.mapCone œÄ (TopCat.piFan.{u,u} X)) =\n      Limits.Fan.mk (œÄ‚Çì (TopCat.of (‚àÄ i, X i))) (proj X) :=\n  rfl\n\n"}
{"name":"FundamentalGroupoidFunctor.instIsIsoFanGrpdObjTopCatFundamentalGroupoidFunctorPiTopToPiCone","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"I : Type u\nX : I ‚Üí TopCat\n‚ä¢ CategoryTheory.IsIso (FundamentalGroupoidFunctor.piTopToPiCone X)","decl":"instance : IsIso (piTopToPiCone X) :=\n  haveI : IsIso (piTopToPiCone X).hom := (inferInstance : IsIso (piIso X).inv)\n  Limits.Cones.cone_iso_of_hom_iso (piTopToPiCone X)\n\n"}
{"name":"FundamentalGroupoidFunctor.preservesProduct","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"I : Type u\nX : I ‚Üí TopCat\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor X) FundamentalGroupoid.fundamentalGroupoidFunctor","decl":"/-- The fundamental groupoid functor preserves products -/\nlemma preservesProduct : Limits.PreservesLimit (Discrete.functor X) œÄ := by\n  -- Porting note: check universe parameters here\n  apply Limits.preservesLimit_of_preserves_limit_cone (TopCat.piFanIsLimit.{u,u} X)\n  apply (Limits.IsLimit.ofConeEquiv (coneDiscreteComp X)).toFun\n  simp only [coneDiscreteComp_obj_mapCone]\n  apply Limits.IsLimit.ofIsoLimit _ (asIso (piTopToPiCone X)).symm\n  exact Grpd.piLimitFanIsLimit _\n\n"}
{"name":"FundamentalGroupoidFunctor.projLeft_map","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"A B : TopCat\nx‚ÇÄ x‚ÇÅ : ‚Üë(FundamentalGroupoid.fundamentalGroupoidFunctor.obj (TopCat.of (Prod ‚ÜëA ‚ÜëB)))\np : Quiver.Hom x‚ÇÄ x‚ÇÅ\n‚ä¢ Eq ((FundamentalGroupoidFunctor.projLeft A B).map p) (Path.Homotopic.projLeft p)","decl":"@[simp]\ntheorem projLeft_map (x‚ÇÄ x‚ÇÅ : œÄ‚Çì (TopCat.of (A √ó B))) (p : x‚ÇÄ ‚ü∂ x‚ÇÅ) :\n    (projLeft A B).map p = Path.Homotopic.projLeft p :=\n  rfl\n\n"}
{"name":"FundamentalGroupoidFunctor.projRight_map","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"A B : TopCat\nx‚ÇÄ x‚ÇÅ : ‚Üë(FundamentalGroupoid.fundamentalGroupoidFunctor.obj (TopCat.of (Prod ‚ÜëA ‚ÜëB)))\np : Quiver.Hom x‚ÇÄ x‚ÇÅ\n‚ä¢ Eq ((FundamentalGroupoidFunctor.projRight A B).map p) (Path.Homotopic.projRight p)","decl":"@[simp]\ntheorem projRight_map (x‚ÇÄ x‚ÇÅ : œÄ‚Çì (TopCat.of (A √ó B))) (p : x‚ÇÄ ‚ü∂ x‚ÇÅ) :\n    (projRight A B).map p = Path.Homotopic.projRight p :=\n  rfl\n\n"}
{"name":"FundamentalGroupoidFunctor.prodToProdTop_obj","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"A B : TopCat\ng : Prod ‚Üë(FundamentalGroupoid.fundamentalGroupoidFunctor.obj A) ‚Üë(FundamentalGroupoid.fundamentalGroupoidFunctor.obj B)\n‚ä¢ Eq ((FundamentalGroupoidFunctor.prodToProdTop A B).obj g) { as := { fst := g.1.as, snd := g.2.as } }","decl":"/--\nThe map taking the product of two fundamental groupoids to the fundamental groupoid of the product\nof the two topological spaces. This is in fact an isomorphism (see `prodIso`).\n-/\n@[simps obj]\ndef prodToProdTop : œÄ‚Çì A √ó œÄ‚Çì B ‚•§ œÄ‚Çì (TopCat.of (A √ó B)) where\n  obj g := ‚ü®g.fst.as, g.snd.as‚ü©\n  map {x y} p :=\n    match x, y, p with\n    | (_, _), (_, _), (p‚ÇÄ, p‚ÇÅ) => @Path.Homotopic.prod _ _ (_) (_) _ _ _ _ p‚ÇÄ p‚ÇÅ\n  map_id := by\n    rintro ‚ü®x‚ÇÄ, x‚ÇÅ‚ü©\n    simp only [CategoryTheory.prod_id, FundamentalGroupoid.id_eq_path_refl]\n    rfl\n  map_comp {x y z} f g :=\n    match x, y, z, f, g with\n    | (_, _), (_, _), (_, _), (f‚ÇÄ, f‚ÇÅ), (g‚ÇÄ, g‚ÇÅ) =>\n      (Path.Homotopic.comp_prod_eq_prod_comp f‚ÇÄ f‚ÇÅ g‚ÇÄ g‚ÇÅ).symm\n\n"}
{"name":"FundamentalGroupoidFunctor.prodToProdTop_map","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"A B : TopCat\nx‚ÇÄ x‚ÇÅ : ‚Üë(FundamentalGroupoid.fundamentalGroupoidFunctor.obj A)\ny‚ÇÄ y‚ÇÅ : ‚Üë(FundamentalGroupoid.fundamentalGroupoidFunctor.obj B)\np‚ÇÄ : Quiver.Hom x‚ÇÄ x‚ÇÅ\np‚ÇÅ : Quiver.Hom y‚ÇÄ y‚ÇÅ\n‚ä¢ Eq ((FundamentalGroupoidFunctor.prodToProdTop A B).map { fst := p‚ÇÄ, snd := p‚ÇÅ }) (Path.Homotopic.prod p‚ÇÄ p‚ÇÅ)","decl":"theorem prodToProdTop_map {x‚ÇÄ x‚ÇÅ : œÄ‚Çì A} {y‚ÇÄ y‚ÇÅ : œÄ‚Çì B} (p‚ÇÄ : x‚ÇÄ ‚ü∂ x‚ÇÅ) (p‚ÇÅ : y‚ÇÄ ‚ü∂ y‚ÇÅ) :\n    (prodToProdTop A B).map (X := (x‚ÇÄ, y‚ÇÄ)) (Y := (x‚ÇÅ, y‚ÇÅ)) (p‚ÇÄ, p‚ÇÅ) =\n      Path.Homotopic.prod p‚ÇÄ p‚ÇÅ :=\n  rfl\n\n"}
{"name":"FundamentalGroupoidFunctor.prodIso_hom","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"A B : TopCat\n‚ä¢ Eq (FundamentalGroupoidFunctor.prodIso A B).hom (FundamentalGroupoidFunctor.prodToProdTop A B)","decl":"/-- Shows `prodToProdTop` is an isomorphism, whose inverse is precisely the product\nof the induced left and right projections.\n-/\n@[simps]\ndef prodIso : CategoryTheory.Grpd.of (œÄ‚Çì A √ó œÄ‚Çì B) ‚âÖ œÄ‚Çì (TopCat.of (A √ó B)) where\n  hom := prodToProdTop A B\n  inv := (projLeft A B).prod' (projRight A B)\n  hom_inv_id := by\n    change prodToProdTop A B ‚ãô (projLeft A B).prod' (projRight A B) = ùü≠ _\n    apply CategoryTheory.Functor.hext; ¬∑ intros; ext <;> simp <;> rfl\n    rintro ‚ü®x‚ÇÄ, x‚ÇÅ‚ü© ‚ü®y‚ÇÄ, y‚ÇÅ‚ü© ‚ü®f‚ÇÄ, f‚ÇÅ‚ü©\n    have : Path.Homotopic.projLeft ((prodToProdTop A B).map (f‚ÇÄ, f‚ÇÅ)) = f‚ÇÄ ‚àß\n      Path.Homotopic.projRight ((prodToProdTop A B).map (f‚ÇÄ, f‚ÇÅ)) = f‚ÇÅ :=\n        And.intro (Path.Homotopic.projLeft_prod f‚ÇÄ f‚ÇÅ) (Path.Homotopic.projRight_prod f‚ÇÄ f‚ÇÅ)\n    simpa\n  inv_hom_id := by\n    change (projLeft A B).prod' (projRight A B) ‚ãô prodToProdTop A B = ùü≠ _\n    apply CategoryTheory.Functor.hext\n    ¬∑ intros; apply FundamentalGroupoid.ext; apply Prod.ext <;> simp <;> rfl\n    rintro ‚ü®x‚ÇÄ, x‚ÇÅ‚ü© ‚ü®y‚ÇÄ, y‚ÇÅ‚ü© f\n    have := Path.Homotopic.prod_projLeft_projRight f\n    -- Porting note: was simpa but TopSpace instances might be getting in the way\n    simp only [CategoryTheory.Functor.comp_obj, CategoryTheory.Functor.prod'_obj, prodToProdTop_obj,\n      CategoryTheory.Functor.comp_map, CategoryTheory.Functor.prod'_map, projLeft_map,\n      projRight_map, CategoryTheory.Functor.id_obj, CategoryTheory.Functor.id_map, heq_eq_eq]\n    apply this\n\n"}
{"name":"FundamentalGroupoidFunctor.prodIso_inv","module":"Mathlib.AlgebraicTopology.FundamentalGroupoid.Product","initialProofState":"A B : TopCat\n‚ä¢ Eq (FundamentalGroupoidFunctor.prodIso A B).inv ((FundamentalGroupoidFunctor.projLeft A B).prod' (FundamentalGroupoidFunctor.projRight A B))","decl":"/-- Shows `prodToProdTop` is an isomorphism, whose inverse is precisely the product\nof the induced left and right projections.\n-/\n@[simps]\ndef prodIso : CategoryTheory.Grpd.of (œÄ‚Çì A √ó œÄ‚Çì B) ‚âÖ œÄ‚Çì (TopCat.of (A √ó B)) where\n  hom := prodToProdTop A B\n  inv := (projLeft A B).prod' (projRight A B)\n  hom_inv_id := by\n    change prodToProdTop A B ‚ãô (projLeft A B).prod' (projRight A B) = ùü≠ _\n    apply CategoryTheory.Functor.hext; ¬∑ intros; ext <;> simp <;> rfl\n    rintro ‚ü®x‚ÇÄ, x‚ÇÅ‚ü© ‚ü®y‚ÇÄ, y‚ÇÅ‚ü© ‚ü®f‚ÇÄ, f‚ÇÅ‚ü©\n    have : Path.Homotopic.projLeft ((prodToProdTop A B).map (f‚ÇÄ, f‚ÇÅ)) = f‚ÇÄ ‚àß\n      Path.Homotopic.projRight ((prodToProdTop A B).map (f‚ÇÄ, f‚ÇÅ)) = f‚ÇÅ :=\n        And.intro (Path.Homotopic.projLeft_prod f‚ÇÄ f‚ÇÅ) (Path.Homotopic.projRight_prod f‚ÇÄ f‚ÇÅ)\n    simpa\n  inv_hom_id := by\n    change (projLeft A B).prod' (projRight A B) ‚ãô prodToProdTop A B = ùü≠ _\n    apply CategoryTheory.Functor.hext\n    ¬∑ intros; apply FundamentalGroupoid.ext; apply Prod.ext <;> simp <;> rfl\n    rintro ‚ü®x‚ÇÄ, x‚ÇÅ‚ü© ‚ü®y‚ÇÄ, y‚ÇÅ‚ü© f\n    have := Path.Homotopic.prod_projLeft_projRight f\n    -- Porting note: was simpa but TopSpace instances might be getting in the way\n    simp only [CategoryTheory.Functor.comp_obj, CategoryTheory.Functor.prod'_obj, prodToProdTop_obj,\n      CategoryTheory.Functor.comp_map, CategoryTheory.Functor.prod'_map, projLeft_map,\n      projRight_map, CategoryTheory.Functor.id_obj, CategoryTheory.Functor.id_map, heq_eq_eq]\n    apply this\n\n"}
