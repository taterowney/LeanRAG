{"name":"RingHom.isIntegralElem_map","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : Ring S\nf : RingHom R S\nx : R\n⊢ f.IsIntegralElem (f x)","decl":"theorem RingHom.isIntegralElem_map {x : R} : f.IsIntegralElem (f x) :=\n  ⟨X - C x, monic_X_sub_C _, by simp⟩\n\n"}
{"name":"isIntegral_algebraMap","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nA : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx : R\n⊢ IsIntegral R ((algebraMap R A) x)","decl":"theorem isIntegral_algebraMap {x : R} : IsIntegral R (algebraMap R A x) :=\n  (algebraMap R A).isIntegralElem_map\n\n"}
{"name":"IsIntegral.map","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝¹² : CommRing R\ninst✝¹¹ : CommRing A\ninst✝¹⁰ : Algebra R A\nB : Type u_5\nC : Type u_6\nF : Type u_7\ninst✝⁹ : Ring B\ninst✝⁸ : Ring C\ninst✝⁷ : Algebra R B\ninst✝⁶ : Algebra A B\ninst✝⁵ : Algebra R C\ninst✝⁴ : IsScalarTower R A B\ninst✝³ : Algebra A C\ninst✝² : IsScalarTower R A C\nb : B\ninst✝¹ : FunLike F B C\ninst✝ : AlgHomClass F A B C\nf : F\nhb : IsIntegral R b\n⊢ IsIntegral R (f b)","decl":"theorem IsIntegral.map {B C F : Type*} [Ring B] [Ring C] [Algebra R B] [Algebra A B] [Algebra R C]\n    [IsScalarTower R A B] [Algebra A C] [IsScalarTower R A C] {b : B}\n    [FunLike F B C] [AlgHomClass F A B C] (f : F)\n    (hb : IsIntegral R b) : IsIntegral R (f b) := by\n  obtain ⟨P, hP⟩ := hb\n  refine ⟨P, hP.1, ?_⟩\n  rw [← aeval_def, ← aeval_map_algebraMap A,\n    aeval_algHom_apply, aeval_map_algebraMap, aeval_def, hP.2, _root_.map_zero]\n\n"}
{"name":"isIntegral_algHom_iff","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nA : Type u_5\nB : Type u_6\ninst✝³ : Ring A\ninst✝² : Ring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\nhf : Function.Injective ⇑f\nx : A\n⊢ Iff (IsIntegral R (f x)) (IsIntegral R x)","decl":"theorem isIntegral_algHom_iff (f : A →ₐ[R] B) (hf : Function.Injective f) {x : A} :\n    IsIntegral R (f x) ↔ IsIntegral R x := by\n  refine ⟨fun ⟨p, hp, hx⟩ ↦ ⟨p, hp, ?_⟩, IsIntegral.map f⟩\n  rwa [← f.comp_algebraMap, ← AlgHom.coe_toRingHom, ← hom_eval₂, AlgHom.coe_toRingHom,\n    map_eq_zero_iff f hf] at hx\n\n"}
{"name":"Submodule.span_range_natDegree_eq_adjoin","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_5\nA : Type u_6\ninst✝² : CommRing R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\nf : Polynomial R\nhf : f.Monic\nhfx : Eq ((Polynomial.aeval x) f) 0\n⊢ Eq (Submodule.span R ↑(Finset.image (fun x_1 => HPow.hPow x x_1) (Finset.range f.natDegree))) (Subalgebra.toSubmodule (Algebra.adjoin R (Singleton.singleton x)))","decl":"open Classical in\ntheorem Submodule.span_range_natDegree_eq_adjoin {R A} [CommRing R] [Semiring A] [Algebra R A]\n    {x : A} {f : R[X]} (hf : f.Monic) (hfx : aeval x f = 0) :\n    span R (Finset.image (x ^ ·) (Finset.range (natDegree f))) =\n      Subalgebra.toSubmodule (Algebra.adjoin R {x}) := by\n  nontriviality A\n  have hf1 : f ≠ 1 := by rintro rfl; simp [one_ne_zero' A] at hfx\n  refine (span_le.mpr fun s hs ↦ ?_).antisymm fun r hr ↦ ?_\n  · rcases Finset.mem_image.1 hs with ⟨k, -, rfl⟩\n    exact (Algebra.adjoin R {x}).pow_mem (Algebra.subset_adjoin rfl) k\n  rw [Subalgebra.mem_toSubmodule, Algebra.adjoin_singleton_eq_range_aeval] at hr\n  rcases (aeval x).mem_range.mp hr with ⟨p, rfl⟩\n  rw [← modByMonic_add_div p hf, map_add, map_mul, hfx,\n      zero_mul, add_zero, ← sum_C_mul_X_pow_eq (p %ₘ f), aeval_def, eval₂_sum, sum_def]\n  refine sum_mem fun k hkq ↦ ?_\n  rw [C_mul_X_pow_eq_monomial, eval₂_monomial, ← Algebra.smul_def]\n  exact smul_mem _ _ (subset_span <| Finset.mem_image_of_mem _ <| Finset.mem_range.mpr <|\n    (le_natDegree_of_mem_supp _ hkq).trans_lt <| natDegree_modByMonic_lt p hf hf1)\n\n"}
{"name":"IsIntegral.fg_adjoin_singleton","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nx : B\nhx : IsIntegral R x\n⊢ (Subalgebra.toSubmodule (Algebra.adjoin R (Singleton.singleton x))).FG","decl":"theorem IsIntegral.fg_adjoin_singleton [Algebra R B] {x : B} (hx : IsIntegral R x) :\n    (Algebra.adjoin R {x}).toSubmodule.FG := by\n  classical\n  rcases hx with ⟨f, hfm, hfx⟩\n  use (Finset.range <| f.natDegree).image (x ^ ·)\n  exact span_range_natDegree_eq_adjoin hfm (by rwa [aeval_def])\n\n"}
{"name":"RingHom.isIntegralElem_zero","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝¹ : CommRing R\ninst✝ : Ring B\nf : RingHom R B\n⊢ f.IsIntegralElem 0","decl":"theorem RingHom.isIntegralElem_zero : f.IsIntegralElem 0 :=\n  f.map_zero ▸ f.isIntegralElem_map\n\n"}
{"name":"isIntegral_zero","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\n⊢ IsIntegral R 0","decl":"theorem isIntegral_zero [Algebra R B] : IsIntegral R (0 : B) :=\n  (algebraMap R B).isIntegralElem_zero\n\n"}
{"name":"RingHom.isIntegralElem_one","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝¹ : CommRing R\ninst✝ : Ring B\nf : RingHom R B\n⊢ f.IsIntegralElem 1","decl":"theorem RingHom.isIntegralElem_one : f.IsIntegralElem 1 :=\n  f.map_one ▸ f.isIntegralElem_map\n\n"}
{"name":"isIntegral_one","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\n⊢ IsIntegral R 1","decl":"theorem isIntegral_one [Algebra R B] : IsIntegral R (1 : B) :=\n  (algebraMap R B).isIntegralElem_one\n\n"}
{"name":"IsIntegral.of_pow","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nx : B\nn : Nat\nhn : LT.lt 0 n\nhx : IsIntegral R (HPow.hPow x n)\n⊢ IsIntegral R x","decl":"theorem IsIntegral.of_pow [Algebra R B] {x : B} {n : ℕ} (hn : 0 < n) (hx : IsIntegral R <| x ^ n) :\n    IsIntegral R x :=\n  have ⟨p, hmonic, heval⟩ := hx\n  ⟨expand R n p, hmonic.expand hn, by rwa [← aeval_def, expand_aeval]⟩\n\n"}
{"name":"IsIntegral.of_aeval_monic","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nx : A\np : Polynomial R\nmonic : p.Monic\ndeg : Ne p.natDegree 0\nhx : IsIntegral R ((Polynomial.aeval x) p)\n⊢ IsIntegral R x","decl":"theorem IsIntegral.of_aeval_monic {x : A} {p : R[X]} (monic : p.Monic)\n    (deg : p.natDegree ≠ 0) (hx : IsIntegral R (aeval x p)) : IsIntegral R x :=\n  have ⟨p, hmonic, heval⟩ := hx\n  ⟨_, hmonic.comp monic deg, by rwa [eval₂_comp, ← aeval_def x]⟩\n\n"}
{"name":"IsIntegral.map_of_comp_eq","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_5\nS : Type u_6\nT : Type u_7\nU : Type u_8\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring S\ninst✝³ : CommRing T\ninst✝² : Ring U\ninst✝¹ : Algebra R S\ninst✝ : Algebra T U\nφ : RingHom R T\nψ : RingHom S U\nh : Eq ((algebraMap T U).comp φ) (ψ.comp (algebraMap R S))\na : S\nha : IsIntegral R a\n⊢ IsIntegral T (ψ a)","decl":"theorem IsIntegral.map_of_comp_eq {R S T U : Type*} [CommRing R] [Ring S]\n    [CommRing T] [Ring U] [Algebra R S] [Algebra T U] (φ : R →+* T) (ψ : S →+* U)\n    (h : (algebraMap T U).comp φ = ψ.comp (algebraMap R S)) {a : S} (ha : IsIntegral R a) :\n    IsIntegral T (ψ a) :=\n  let ⟨p, hp⟩ := ha\n  ⟨p.map φ, hp.1.map _, by\n    rw [← eval_map, map_map, h, ← map_map, eval_map, eval₂_at_apply, eval_map, hp.2, ψ.map_zero]⟩\n\n"}
{"name":"isIntegral_algEquiv","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nA : Type u_5\nB : Type u_6\ninst✝³ : Ring A\ninst✝² : Ring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgEquiv R A B\nx : A\n⊢ Iff (IsIntegral R (f x)) (IsIntegral R x)","decl":"@[simp]\ntheorem isIntegral_algEquiv {A B : Type*} [Ring A] [Ring B] [Algebra R A] [Algebra R B]\n    (f : A ≃ₐ[R] B) {x : A} : IsIntegral R (f x) ↔ IsIntegral R x :=\n  ⟨fun h ↦ by simpa using h.map f.symm, IsIntegral.map f⟩\n\n"}
{"name":"IsIntegral.tower_top","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : Ring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : Algebra A B\ninst✝ : IsScalarTower R A B\nx : B\nhx : IsIntegral R x\n⊢ IsIntegral A x","decl":"/-- If `R → A → B` is an algebra tower,\nthen if the entire tower is an integral extension so is `A → B`. -/\ntheorem IsIntegral.tower_top [Algebra A B] [IsScalarTower R A B] {x : B}\n    (hx : IsIntegral R x) : IsIntegral A x :=\n  let ⟨p, hp, hpx⟩ := hx\n  ⟨p.map <| algebraMap R A, hp.map _, by rw [← aeval_def, aeval_map_algebraMap, aeval_def, hpx]⟩\n\n/- If `R` and `T` are isomorphic commutative rings and `S` is an `R`-algebra and a `T`-algebra in\n  a compatible way, then an element `a ∈ S` is integral over `R` if and only if it is integral\n  over `T`.-/\n"}
{"name":"RingEquiv.isIntegral_iff","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_5\nS : Type u_6\nT : Type u_7\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing T\ninst✝¹ : Algebra R S\ninst✝ : Algebra T S\nφ : RingEquiv R T\nh : Eq ((algebraMap T S).comp φ.toRingHom) (algebraMap R S)\na : S\n⊢ Iff (IsIntegral R a) (IsIntegral T a)","decl":"theorem RingEquiv.isIntegral_iff {R S T : Type*} [CommRing R] [CommRing S] [CommRing T]\n    [Algebra R S] [Algebra T S] (φ : R ≃+* T)\n    (h : (algebraMap T S).comp φ.toRingHom = algebraMap R S) (a : S) :\n    IsIntegral R a ↔ IsIntegral T a := by\n  constructor <;> intro ha\n  · letI : Algebra R T := φ.toRingHom.toAlgebra\n    letI : IsScalarTower R T S :=\n      ⟨fun r t s ↦ by simp only [Algebra.smul_def, map_mul, ← h, mul_assoc]; rfl⟩\n    exact IsIntegral.tower_top ha\n  · have h' : (algebraMap T S) = (algebraMap R S).comp φ.symm.toRingHom := by\n      simp only [← h, RingHom.comp_assoc, RingEquiv.toRingHom_eq_coe, RingEquiv.comp_symm,\n        RingHomCompTriple.comp_eq]\n    letI : Algebra T R := φ.symm.toRingHom.toAlgebra\n    letI : IsScalarTower T R S :=\n      ⟨fun r t s ↦ by simp only [Algebra.smul_def, map_mul, h', mul_assoc]; rfl⟩\n    exact IsIntegral.tower_top ha\n\n"}
{"name":"map_isIntegral_int","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"B : Type u_5\nC : Type u_6\nF : Type u_7\ninst✝³ : Ring B\ninst✝² : Ring C\nb : B\ninst✝¹ : FunLike F B C\ninst✝ : RingHomClass F B C\nf : F\nhb : IsIntegral Int b\n⊢ IsIntegral Int (f b)","decl":"theorem map_isIntegral_int {B C F : Type*} [Ring B] [Ring C] {b : B}\n    [FunLike F B C] [RingHomClass F B C] (f : F)\n    (hb : IsIntegral ℤ b) : IsIntegral ℤ (f b) :=\n  hb.map (f : B →+* C).toIntAlgHom\n\n"}
{"name":"IsIntegral.of_subring","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nx : B\nT : Subring R\nhx : IsIntegral (Subtype fun x => Membership.mem T x) x\n⊢ IsIntegral R x","decl":"theorem IsIntegral.of_subring {x : B} (T : Subring R) (hx : IsIntegral T x) : IsIntegral R x :=\n  hx.tower_top\n\n"}
{"name":"IsIntegral.algebraMap","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : Ring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : Algebra A B\ninst✝ : IsScalarTower R A B\nx : A\nh : IsIntegral R x\n⊢ IsIntegral R ((algebraMap A B) x)","decl":"protected theorem IsIntegral.algebraMap [Algebra A B] [IsScalarTower R A B] {x : A}\n    (h : IsIntegral R x) : IsIntegral R (algebraMap A B x) := by\n  rcases h with ⟨f, hf, hx⟩\n  use f, hf\n  rw [IsScalarTower.algebraMap_eq R A B, ← hom_eval₂, hx, RingHom.map_zero]\n\n"}
{"name":"isIntegral_algebraMap_iff","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : Ring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : Algebra A B\ninst✝ : IsScalarTower R A B\nx : A\nhAB : Function.Injective ⇑(algebraMap A B)\n⊢ Iff (IsIntegral R ((algebraMap A B) x)) (IsIntegral R x)","decl":"theorem isIntegral_algebraMap_iff [Algebra A B] [IsScalarTower R A B] {x : A}\n    (hAB : Function.Injective (algebraMap A B)) :\n    IsIntegral R (algebraMap A B x) ↔ IsIntegral R x :=\n  isIntegral_algHom_iff (IsScalarTower.toAlgHom R A B) hAB\n\n"}
{"name":"isIntegral_iff_isIntegral_closure_finite","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nr : B\n⊢ Iff (IsIntegral R r) (Exists fun s => And s.Finite (IsIntegral (Subtype fun x => Membership.mem (Subring.closure s) x) r))","decl":"theorem isIntegral_iff_isIntegral_closure_finite {r : B} :\n    IsIntegral R r ↔ ∃ s : Set R, s.Finite ∧ IsIntegral (Subring.closure s) r := by\n  constructor <;> intro hr\n  · rcases hr with ⟨p, hmp, hpr⟩\n    refine ⟨_, Finset.finite_toSet _, p.restriction, monic_restriction.2 hmp, ?_⟩\n    rw [← aeval_def, ← aeval_map_algebraMap R r p.restriction, map_restriction, aeval_def, hpr]\n  rcases hr with ⟨s, _, hsr⟩\n  exact hsr.of_subring _\n\n"}
{"name":"fg_adjoin_of_finite","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\ns : Set A\nhfs : s.Finite\nhis : ∀ (x : A), Membership.mem s x → IsIntegral R x\n⊢ (Subalgebra.toSubmodule (Algebra.adjoin R s)).FG","decl":"@[stacks 09GH]\ntheorem fg_adjoin_of_finite {s : Set A} (hfs : s.Finite) (his : ∀ x ∈ s, IsIntegral R x) :\n    (Algebra.adjoin R s).toSubmodule.FG :=\n  Set.Finite.induction_on _ hfs\n    (fun _ =>\n      ⟨{1},\n        Submodule.ext fun x => by\n          rw [Algebra.adjoin_empty, Finset.coe_singleton, ← one_eq_span, Algebra.toSubmodule_bot]⟩)\n    (fun {a s} _ _ ih his => by\n      rw [← Set.union_singleton, Algebra.adjoin_union_coe_submodule]\n      exact\n        FG.mul (ih fun i hi => his i <| Set.mem_insert_of_mem a hi)\n          (his a <| Set.mem_insert a s).fg_adjoin_singleton)\n    his\n\n"}
{"name":"Algebra.finite_adjoin_of_finite_of_isIntegral","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\ns : Set A\nhf : s.Finite\nhi : ∀ (x : A), Membership.mem s x → IsIntegral R x\n⊢ Module.Finite R (Subtype fun x => Membership.mem (Algebra.adjoin R s) x)","decl":"theorem Algebra.finite_adjoin_of_finite_of_isIntegral {s : Set A} (hf : s.Finite)\n    (hi : ∀ x ∈ s, IsIntegral R x) : Module.Finite R (adjoin R s) :=\n  Module.Finite.iff_fg.mpr <| fg_adjoin_of_finite hf hi\n\n"}
{"name":"Algebra.finite_adjoin_simple_of_isIntegral","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nx : A\nhi : IsIntegral R x\n⊢ Module.Finite R (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1)","decl":"theorem Algebra.finite_adjoin_simple_of_isIntegral {x : A} (hi : IsIntegral R x) :\n    Module.Finite R (adjoin R {x}) :=\n  Module.Finite.iff_fg.mpr hi.fg_adjoin_singleton\n\n"}
{"name":"isNoetherian_adjoin_finset","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : IsNoetherianRing R\ns : Finset A\nhs : ∀ (x : A), Membership.mem s x → IsIntegral R x\n⊢ IsNoetherian R (Subtype fun x => Membership.mem (Algebra.adjoin R ↑s) x)","decl":"theorem isNoetherian_adjoin_finset [IsNoetherianRing R] (s : Finset A)\n    (hs : ∀ x ∈ s, IsIntegral R x) : IsNoetherian R (Algebra.adjoin R (s : Set A)) :=\n  isNoetherian_of_fg_of_noetherian _ (fg_adjoin_of_finite s.finite_toSet hs)\n\n"}
{"name":"IsIntegral.pair","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Ring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nx : Prod A B\nhx₁ : IsIntegral R x.1\nhx₂ : IsIntegral R x.2\n⊢ IsIntegral R x","decl":"/-- An element of a product algebra is integral if each component is integral. -/\ntheorem IsIntegral.pair {x : A × B} (hx₁ : IsIntegral R x.1) (hx₂ : IsIntegral R x.2) :\n    IsIntegral R x := by\n  obtain ⟨p₁, ⟨hp₁Monic, hp₁Eval⟩⟩ := hx₁\n  obtain ⟨p₂, ⟨hp₂Monic, hp₂Eval⟩⟩ := hx₂\n  refine ⟨p₁ * p₂, ⟨hp₁Monic.mul hp₂Monic, ?_⟩⟩\n  rw [← aeval_def] at *\n  rw [aeval_prod_apply, aeval_mul, hp₁Eval, zero_mul, aeval_mul, hp₂Eval, mul_zero,\n    Prod.zero_eq_mk]\n\n"}
{"name":"IsIntegral.pair_iff","module":"Mathlib.RingTheory.IntegralClosure.IsIntegral.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Ring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nx : Prod A B\n⊢ Iff (IsIntegral R x) (And (IsIntegral R x.1) (IsIntegral R x.2))","decl":"/-- An element of a product algebra is integral iff each component is integral. -/\ntheorem IsIntegral.pair_iff {x : A × B} : IsIntegral R x ↔ IsIntegral R x.1 ∧ IsIntegral R x.2 :=\n  ⟨fun h ↦ ⟨h.map (AlgHom.fst R A B), h.map (AlgHom.snd R A B)⟩, fun h ↦ h.1.pair h.2⟩\n\n"}
