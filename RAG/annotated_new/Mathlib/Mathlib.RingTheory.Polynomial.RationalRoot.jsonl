{"name":"scaleRoots_aeval_eq_zero_of_aeval_mk'_eq_zero","module":"Mathlib.RingTheory.Polynomial.RationalRoot","initialProofState":"A : Type u_1\nS : Type u_4\ninst✝³ : CommRing A\ninst✝² : CommRing S\nM : Submonoid A\ninst✝¹ : Algebra A S\ninst✝ : IsLocalization M S\np : Polynomial A\nr : A\ns : Subtype fun x => Membership.mem M x\nhr : Eq ((Polynomial.aeval (IsLocalization.mk' S r s)) p) 0\n⊢ Eq ((Polynomial.aeval ((algebraMap A S) r)) (p.scaleRoots ↑s)) 0","decl":"theorem scaleRoots_aeval_eq_zero_of_aeval_mk'_eq_zero {p : A[X]} {r : A} {s : M}\n    (hr : aeval (mk' S r s) p = 0) : aeval (algebraMap A S r) (scaleRoots p s) = 0 := by\n  convert scaleRoots_eval₂_eq_zero (algebraMap A S) hr\n  -- Porting note: added\n  funext\n  rw [aeval_def, mk'_spec' _ r s]\n\n"}
{"name":"num_isRoot_scaleRoots_of_aeval_eq_zero","module":"Mathlib.RingTheory.Polynomial.RationalRoot","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝⁵ : CommRing A\ninst✝⁴ : Field K\ninst✝³ : Algebra A K\ninst✝² : IsFractionRing A K\ninst✝¹ : IsDomain A\ninst✝ : UniqueFactorizationMonoid A\np : Polynomial A\nx : K\nhr : Eq ((Polynomial.aeval x) p) 0\n⊢ (p.scaleRoots ↑(IsFractionRing.den A x)).IsRoot (IsFractionRing.num A x)","decl":"theorem num_isRoot_scaleRoots_of_aeval_eq_zero [UniqueFactorizationMonoid A] {p : A[X]} {x : K}\n    (hr : aeval x p = 0) : IsRoot (scaleRoots p (den A x)) (num A x) := by\n  apply isRoot_of_eval₂_map_eq_zero (IsFractionRing.injective A K)\n  refine scaleRoots_aeval_eq_zero_of_aeval_mk'_eq_zero ?_\n  rw [mk'_num_den]\n  exact hr\n\n"}
{"name":"num_dvd_of_is_root","module":"Mathlib.RingTheory.Polynomial.RationalRoot","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\np : Polynomial A\nr : K\nhr : Eq ((Polynomial.aeval r) p) 0\n⊢ Dvd.dvd (IsFractionRing.num A r) (p.coeff 0)","decl":"/-- **Rational root theorem** part 1:\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\nthen the numerator of `r` divides the constant coefficient -/\ntheorem num_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ∣ p.coeff 0 := by\n  suffices num A r ∣ (scaleRoots p (den A r)).coeff 0 by\n    simp only [coeff_scaleRoots, tsub_zero] at this\n    haveI inst := Classical.propDecidable\n    by_cases hr : num A r = 0\n    · simp_all [nonZeroDivisors.coe_ne_zero]\n    · refine dvd_of_dvd_mul_left_of_no_prime_factors hr ?_ this\n      intro q dvd_num dvd_denom_pow hq\n      apply hq.not_unit\n      exact num_den_reduced A r dvd_num (hq.dvd_of_dvd_pow dvd_denom_pow)\n  convert dvd_term_of_isRoot_of_dvd_terms 0 (num_isRoot_scaleRoots_of_aeval_eq_zero hr) _\n  · rw [pow_zero, mul_one]\n  intro j hj\n  apply dvd_mul_of_dvd_right\n  convert pow_dvd_pow (num A r) (Nat.succ_le_of_lt (bot_lt_iff_ne_bot.mpr hj))\n  exact (pow_one _).symm\n\n"}
{"name":"den_dvd_of_is_root","module":"Mathlib.RingTheory.Polynomial.RationalRoot","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\np : Polynomial A\nr : K\nhr : Eq ((Polynomial.aeval r) p) 0\n⊢ Dvd.dvd (↑(IsFractionRing.den A r)) p.leadingCoeff","decl":"/-- Rational root theorem part 2:\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\nthen the denominator of `r` divides the leading coefficient -/\ntheorem den_dvd_of_is_root {p : A[X]} {r : K} (hr : aeval r p = 0) :\n    (den A r : A) ∣ p.leadingCoeff := by\n  suffices (den A r : A) ∣ p.leadingCoeff * num A r ^ p.natDegree by\n    refine\n      dvd_of_dvd_mul_left_of_no_prime_factors (mem_nonZeroDivisors_iff_ne_zero.mp (den A r).2) ?_\n        this\n    intro q dvd_den dvd_num_pow hq\n    apply hq.not_unit\n    exact num_den_reduced A r (hq.dvd_of_dvd_pow dvd_num_pow) dvd_den\n  rw [← coeff_scaleRoots_natDegree]\n  apply dvd_term_of_isRoot_of_dvd_terms _ (num_isRoot_scaleRoots_of_aeval_eq_zero hr)\n  intro j hj\n  by_cases h : j < p.natDegree\n  · rw [coeff_scaleRoots]\n    refine (dvd_mul_of_dvd_right ?_ _).mul_right _\n    convert pow_dvd_pow (den A r : A) (Nat.succ_le_iff.mpr (lt_tsub_iff_left.mpr _))\n    · exact (pow_one _).symm\n    simpa using h\n  rw [← natDegree_scaleRoots p (den A r)] at *\n  rw [coeff_eq_zero_of_natDegree_lt (lt_of_le_of_ne (le_of_not_gt h) hj.symm),\n    zero_mul]\n  exact dvd_zero _\n\n"}
{"name":"isInteger_of_is_root_of_monic","module":"Mathlib.RingTheory.Polynomial.RationalRoot","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\np : Polynomial A\nhp : p.Monic\nr : K\nhr : Eq ((Polynomial.aeval r) p) 0\n⊢ IsLocalization.IsInteger A r","decl":"/-- **Integral root theorem**:\nif `r : f.codomain` is a root of a monic polynomial over the ufd `A`,\nthen `r` is an integer -/\ntheorem isInteger_of_is_root_of_monic {p : A[X]} (hp : Monic p) {r : K} (hr : aeval r p = 0) :\n    IsInteger A r :=\n  isInteger_of_isUnit_den (isUnit_of_dvd_one (hp ▸ den_dvd_of_is_root hr))\n\n"}
{"name":"exists_integer_of_is_root_of_monic","module":"Mathlib.RingTheory.Polynomial.RationalRoot","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\np : Polynomial A\nhp : p.Monic\nr : K\nhr : Eq ((Polynomial.aeval r) p) 0\n⊢ Exists fun r' => And (Eq r ((algebraMap A K) r')) (Dvd.dvd r' (p.coeff 0))","decl":"theorem exists_integer_of_is_root_of_monic {p : A[X]} (hp : Monic p) {r : K} (hr : aeval r p = 0) :\n    ∃ r' : A, r = algebraMap A K r' ∧ r' ∣ p.coeff 0 := by\n  /- I tried deducing this from above by unwrapping IsInteger,\n    but the divisibility condition is annoying -/\n  obtain ⟨inv, h_inv⟩ := hp ▸ den_dvd_of_is_root hr\n  use num A r * inv, ?_\n  · have h : inv ∣ 1 := ⟨den A r, by simpa [mul_comm] using h_inv⟩\n    simpa using mul_dvd_mul (num_dvd_of_is_root hr) h\n  · have d_ne_zero : algebraMap A K (den A r) ≠ 0 :=\n      IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors (den A r).prop\n    nth_rw 1 [← mk'_num_den' A r]\n    rw [div_eq_iff d_ne_zero, map_mul, mul_assoc, mul_comm ((algebraMap A K) inv),\n      ← map_mul, ← h_inv, map_one, mul_one]\n\n"}
{"name":"UniqueFactorizationMonoid.integer_of_integral","module":"Mathlib.RingTheory.Polynomial.RationalRoot","initialProofState":"A : Type u_1\nK : Type u_2\ninst✝⁵ : CommRing A\ninst✝⁴ : IsDomain A\ninst✝³ : UniqueFactorizationMonoid A\ninst✝² : Field K\ninst✝¹ : Algebra A K\ninst✝ : IsFractionRing A K\nx : K\na✝ : IsIntegral A x\n⊢ IsLocalization.IsInteger A x","decl":"theorem integer_of_integral {x : K} : IsIntegral A x → IsInteger A x := fun ⟨_, hp, hx⟩ =>\n  isInteger_of_is_root_of_monic hp hx\n\n-- See library note [lower instance priority]\n"}
{"name":"UniqueFactorizationMonoid.instIsIntegrallyClosed","module":"Mathlib.RingTheory.Polynomial.RationalRoot","initialProofState":"A : Type u_1\ninst✝² : CommRing A\ninst✝¹ : IsDomain A\ninst✝ : UniqueFactorizationMonoid A\n⊢ IsIntegrallyClosed A","decl":"instance (priority := 100) instIsIntegrallyClosed : IsIntegrallyClosed A :=\n  (isIntegrallyClosed_iff (FractionRing A)).mpr fun {_} => integer_of_integral\n\n"}
