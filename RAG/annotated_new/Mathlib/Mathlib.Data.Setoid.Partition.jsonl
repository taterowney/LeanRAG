{"name":"Setoid.eq_of_mem_eqv_class","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nc : Set (Set α)\nH : ∀ (a : α), ExistsUnique fun b => And (Membership.mem c b) (Membership.mem b a)\nx : α\nb b' : Set α\nhc : Membership.mem c b\nhb : Membership.mem b x\nhc' : Membership.mem c b'\nhb' : Membership.mem b' x\n⊢ Eq b b'","decl":"/-- If x ∈ α is in 2 elements of a set of sets partitioning α, those 2 sets are equal. -/\ntheorem eq_of_mem_eqv_class {c : Set (Set α)} (H : ∀ a, ∃! b ∈ c, a ∈ b) {x b b'}\n    (hc : b ∈ c) (hb : x ∈ b) (hc' : b' ∈ c) (hb' : x ∈ b') : b = b' :=\n  (H x).unique ⟨hc, hb⟩ ⟨hc', hb'⟩\n\n"}
{"name":"Setoid.mem_classes","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nr : Setoid α\ny : α\n⊢ Membership.mem r.classes (setOf fun x => r x y)","decl":"theorem mem_classes (r : Setoid α) (y) : { x | r x y } ∈ r.classes :=\n  ⟨y, rfl⟩\n\n"}
{"name":"Setoid.classes_ker_subset_fiber_set","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ HasSubset.Subset (Setoid.ker f).classes (Set.range fun y => setOf fun x => Eq (f x) y)","decl":"theorem classes_ker_subset_fiber_set {β : Type*} (f : α → β) :\n    (Setoid.ker f).classes ⊆ Set.range fun y => { x | f x = y } := by\n  rintro s ⟨x, rfl⟩\n  rw [Set.mem_range]\n  exact ⟨f x, rfl⟩\n\n"}
{"name":"Setoid.finite_classes_ker","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : Finite β\nf : α → β\n⊢ (Setoid.ker f).classes.Finite","decl":"theorem finite_classes_ker {α β : Type*} [Finite β] (f : α → β) : (Setoid.ker f).classes.Finite :=\n  (Set.finite_range _).subset <| classes_ker_subset_fiber_set f\n\n"}
{"name":"Setoid.card_classes_ker_le","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Fintype β\nf : α → β\ninst✝ : Fintype ↑(Setoid.ker f).classes\n⊢ LE.le (Fintype.card ↑(Setoid.ker f).classes) (Fintype.card β)","decl":"theorem card_classes_ker_le {α β : Type*} [Fintype β] (f : α → β)\n    [Fintype (Setoid.ker f).classes] : Fintype.card (Setoid.ker f).classes ≤ Fintype.card β := by\n  classical exact\n      le_trans (Set.card_le_card (classes_ker_subset_fiber_set f)) (Fintype.card_range_le _)\n\n"}
{"name":"Setoid.eq_iff_classes_eq","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nr₁ r₂ : Setoid α\n⊢ Iff (Eq r₁ r₂) (∀ (x : α), Eq (setOf fun y => r₁ x y) (setOf fun y => r₂ x y))","decl":"/-- Two equivalence relations are equal iff all their equivalence classes are equal. -/\ntheorem eq_iff_classes_eq {r₁ r₂ : Setoid α} :\n    r₁ = r₂ ↔ ∀ x, { y | r₁ x y } = { y | r₂ x y } :=\n  ⟨fun h _x => h ▸ rfl, fun h => ext fun x => Set.ext_iff.1 <| h x⟩\n\n"}
{"name":"Setoid.rel_iff_exists_classes","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nr : Setoid α\nx y : α\n⊢ Iff (r x y) (Exists fun c => And (Membership.mem r.classes c) (And (Membership.mem c x) (Membership.mem c y)))","decl":"theorem rel_iff_exists_classes (r : Setoid α) {x y} : r x y ↔ ∃ c ∈ r.classes, x ∈ c ∧ y ∈ c :=\n  ⟨fun h => ⟨_, r.mem_classes y, h, r.refl' y⟩, fun ⟨c, ⟨z, hz⟩, hx, hy⟩ => by\n    subst c\n    exact r.trans' hx (r.symm' hy)⟩\n\n"}
{"name":"Setoid.classes_inj","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nr₁ r₂ : Setoid α\n⊢ Iff (Eq r₁ r₂) (Eq r₁.classes r₂.classes)","decl":"/-- Two equivalence relations are equal iff their equivalence classes are equal. -/\ntheorem classes_inj {r₁ r₂ : Setoid α} : r₁ = r₂ ↔ r₁.classes = r₂.classes :=\n  ⟨fun h => h ▸ rfl, fun h => ext fun a b => by simp only [rel_iff_exists_classes, exists_prop, h]⟩\n\n"}
{"name":"Setoid.empty_not_mem_classes","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nr : Setoid α\n⊢ Not (Membership.mem r.classes EmptyCollection.emptyCollection)","decl":"/-- The empty set is not an equivalence class. -/\ntheorem empty_not_mem_classes {r : Setoid α} : ∅ ∉ r.classes := fun ⟨y, hy⟩ =>\n  Set.not_mem_empty y <| hy.symm ▸ r.refl' y\n\n"}
{"name":"Setoid.classes_eqv_classes","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nr : Setoid α\na : α\n⊢ ExistsUnique fun b => And (Membership.mem r.classes b) (Membership.mem b a)","decl":"/-- Equivalence classes partition the type. -/\ntheorem classes_eqv_classes {r : Setoid α} (a) : ∃! b ∈ r.classes, a ∈ b :=\n  ExistsUnique.intro { x | r x a } ⟨r.mem_classes a, r.refl' _⟩ <| by\n    rintro y ⟨⟨_, rfl⟩, ha⟩\n    ext x\n    exact ⟨fun hx => r.trans' hx (r.symm' ha), fun hx => r.trans' hx ha⟩\n\n"}
{"name":"Setoid.eq_of_mem_classes","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nr : Setoid α\nx : α\nb : Set α\nhc : Membership.mem r.classes b\nhb : Membership.mem b x\nb' : Set α\nhc' : Membership.mem r.classes b'\nhb' : Membership.mem b' x\n⊢ Eq b b'","decl":"/-- If x ∈ α is in 2 equivalence classes, the equivalence classes are equal. -/\ntheorem eq_of_mem_classes {r : Setoid α} {x b} (hc : b ∈ r.classes) (hb : x ∈ b) {b'}\n    (hc' : b' ∈ r.classes) (hb' : x ∈ b') : b = b' :=\n  eq_of_mem_eqv_class classes_eqv_classes hc hb hc' hb'\n\n"}
{"name":"Setoid.eq_eqv_class_of_mem","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nc : Set (Set α)\nH : ∀ (a : α), ExistsUnique fun b => And (Membership.mem c b) (Membership.mem b a)\ns : Set α\ny : α\nhs : Membership.mem c s\nhy : Membership.mem s y\n⊢ Eq s (setOf fun x => (Setoid.mkClasses c H) x y)","decl":"/-- The elements of a set of sets partitioning α are the equivalence classes of the\n    equivalence relation defined by the set of sets. -/\ntheorem eq_eqv_class_of_mem {c : Set (Set α)} (H : ∀ a, ∃! b ∈ c, a ∈ b) {s y}\n    (hs : s ∈ c) (hy : y ∈ s) : s = { x | mkClasses c H x y } := by\n  ext x\n  constructor\n  · intro hx _s' hs' hx'\n    rwa [eq_of_mem_eqv_class H hs' hx' hs hx]\n  · intro hx\n    obtain ⟨b', ⟨hc, hb'⟩, _⟩ := H x\n    rwa [eq_of_mem_eqv_class H hs hy hc (hx b' hc hb')]\n\n"}
{"name":"Setoid.eqv_class_mem","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nc : Set (Set α)\nH : ∀ (a : α), ExistsUnique fun b => And (Membership.mem c b) (Membership.mem b a)\ny : α\n⊢ Membership.mem c (setOf fun x => (Setoid.mkClasses c H) x y)","decl":"/-- The equivalence classes of the equivalence relation defined by a set of sets\n    partitioning α are elements of the set of sets. -/\ntheorem eqv_class_mem {c : Set (Set α)} (H : ∀ a, ∃! b ∈ c, a ∈ b) {y} :\n    { x | mkClasses c H x y } ∈ c :=\n  (H y).elim fun _ hc _ => eq_eqv_class_of_mem H hc.1 hc.2 ▸ hc.1\n\n"}
{"name":"Setoid.eqv_class_mem'","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nc : Set (Set α)\nH : ∀ (a : α), ExistsUnique fun b => And (Membership.mem c b) (Membership.mem b a)\nx : α\n⊢ Membership.mem c (setOf fun y => (Setoid.mkClasses c H) x y)","decl":"theorem eqv_class_mem' {c : Set (Set α)} (H : ∀ a, ∃! b ∈ c, a ∈ b) {x} :\n    { y : α | mkClasses c H x y } ∈ c := by\n  convert @Setoid.eqv_class_mem _ _ H x using 3\n  rw [Setoid.comm']\n\n"}
{"name":"Setoid.eqv_classes_disjoint","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nc : Set (Set α)\nH : ∀ (a : α), ExistsUnique fun b => And (Membership.mem c b) (Membership.mem b a)\n⊢ c.PairwiseDisjoint id","decl":"/-- Distinct elements of a set of sets partitioning α are disjoint. -/\ntheorem eqv_classes_disjoint {c : Set (Set α)} (H : ∀ a, ∃! b ∈ c, a ∈ b) :\n    c.PairwiseDisjoint id := fun _b₁ h₁ _b₂ h₂ h =>\n  Set.disjoint_left.2 fun x hx1 hx2 =>\n    (H x).elim fun _b _hc _hx => h <| eq_of_mem_eqv_class H h₁ hx1 h₂ hx2\n\n"}
{"name":"Setoid.eqv_classes_of_disjoint_union","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nc : Set (Set α)\nhu : Eq c.sUnion Set.univ\nH : c.PairwiseDisjoint id\na : α\n⊢ ExistsUnique fun b => And (Membership.mem c b) (Membership.mem b a)","decl":"/-- A set of disjoint sets covering α partition α (classical). -/\ntheorem eqv_classes_of_disjoint_union {c : Set (Set α)} (hu : Set.sUnion c = @Set.univ α)\n    (H : c.PairwiseDisjoint id) (a) : ∃! b ∈ c, a ∈ b :=\n  let ⟨b, hc, ha⟩ := Set.mem_sUnion.1 <| show a ∈ _ by rw [hu]; exact Set.mem_univ a\n  ExistsUnique.intro b ⟨hc, ha⟩ fun _ hc' => H.elim_set hc'.1 hc _ hc'.2 ha\n\n"}
{"name":"Setoid.mkClasses_classes","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nr : Setoid α\n⊢ Eq (Setoid.mkClasses r.classes ⋯) r","decl":"/-- The equivalence relation made from the equivalence classes of an equivalence\n    relation r equals r. -/\ntheorem mkClasses_classes (r : Setoid α) : mkClasses r.classes classes_eqv_classes = r :=\n  ext fun x _y =>\n    ⟨fun h => r.symm' (h { z | r z x } (r.mem_classes x) <| r.refl' x), fun h _b hb hx =>\n      eq_of_mem_classes (r.mem_classes x) (r.refl' x) hb hx ▸ r.symm' h⟩\n\n"}
{"name":"Setoid.sUnion_classes","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nr : Setoid α\n⊢ Eq r.classes.sUnion Set.univ","decl":"@[simp]\ntheorem sUnion_classes (r : Setoid α) : ⋃₀ r.classes = Set.univ :=\n  Set.eq_univ_of_forall fun x => Set.mem_sUnion.2 ⟨{ y | r y x }, ⟨x, rfl⟩, Setoid.refl _⟩\n\n"}
{"name":"Setoid.quotientEquivClasses_mk_eq","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nr : Setoid α\na : α\n⊢ Eq (↑(r.quotientEquivClasses (Quotient.mk r a))) (setOf fun x => r x a)","decl":"@[simp]\nlemma quotientEquivClasses_mk_eq (r : Setoid α) (a : α) :\n    (quotientEquivClasses r (Quotient.mk r a) : Set α) = { x | r x a } :=\n  (@Subtype.ext_iff_val _ _ _ ⟨{ x | r x a }, Setoid.mem_classes r a⟩).mp rfl\n\n"}
{"name":"Setoid.nonempty_of_mem_partition","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nc : Set (Set α)\nhc : Setoid.IsPartition c\ns : Set α\nh : Membership.mem c s\n⊢ s.Nonempty","decl":"/-- A partition of `α` does not contain the empty set. -/\ntheorem nonempty_of_mem_partition {c : Set (Set α)} (hc : IsPartition c) {s} (h : s ∈ c) :\n    s.Nonempty :=\n  Set.nonempty_iff_ne_empty.2 fun hs0 => hc.1 <| hs0 ▸ h\n\n"}
{"name":"Setoid.isPartition_classes","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nr : Setoid α\n⊢ Setoid.IsPartition r.classes","decl":"theorem isPartition_classes (r : Setoid α) : IsPartition r.classes :=\n  ⟨empty_not_mem_classes, classes_eqv_classes⟩\n\n"}
{"name":"Setoid.IsPartition.pairwiseDisjoint","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nc : Set (Set α)\nhc : Setoid.IsPartition c\n⊢ c.PairwiseDisjoint id","decl":"theorem IsPartition.pairwiseDisjoint {c : Set (Set α)} (hc : IsPartition c) :\n    c.PairwiseDisjoint id :=\n  eqv_classes_disjoint hc.2\n\n"}
{"name":"Set.PairwiseDisjoint.isPartition_of_exists_of_ne_empty","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_2\ns : Set (Set α)\nh₁ : s.PairwiseDisjoint id\nh₂ : ∀ (a : α), Exists fun x => And (Membership.mem s x) (Membership.mem x a)\nh₃ : Not (Membership.mem s EmptyCollection.emptyCollection)\n⊢ Setoid.IsPartition s","decl":"lemma _root_.Set.PairwiseDisjoint.isPartition_of_exists_of_ne_empty {α : Type*} {s : Set (Set α)}\n    (h₁ : s.PairwiseDisjoint id) (h₂ : ∀ a : α, ∃ x ∈ s, a ∈ x) (h₃ : ∅ ∉ s) :\n    Setoid.IsPartition s := by\n  refine ⟨h₃, fun a ↦ existsUnique_of_exists_of_unique (h₂ a) ?_⟩\n  intro b₁ b₂ hb₁ hb₂\n  apply h₁.elim hb₁.1 hb₂.1\n  simp only [Set.not_disjoint_iff]\n  exact ⟨a, hb₁.2, hb₂.2⟩\n\n"}
{"name":"Setoid.IsPartition.sUnion_eq_univ","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nc : Set (Set α)\nhc : Setoid.IsPartition c\n⊢ Eq c.sUnion Set.univ","decl":"theorem IsPartition.sUnion_eq_univ {c : Set (Set α)} (hc : IsPartition c) : ⋃₀ c = Set.univ :=\n  Set.eq_univ_of_forall fun x =>\n    Set.mem_sUnion.2 <|\n      let ⟨t, ht⟩ := hc.2 x\n      ⟨t, by\n        simp only [existsUnique_iff_exists] at ht\n        tauto⟩\n\n"}
{"name":"Setoid.exists_of_mem_partition","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nc : Set (Set α)\nhc : Setoid.IsPartition c\ns : Set α\nhs : Membership.mem c s\n⊢ Exists fun y => Eq s (setOf fun x => (Setoid.mkClasses c ⋯) x y)","decl":"/-- All elements of a partition of α are the equivalence class of some y ∈ α. -/\ntheorem exists_of_mem_partition {c : Set (Set α)} (hc : IsPartition c) {s} (hs : s ∈ c) :\n    ∃ y, s = { x | mkClasses c hc.2 x y } :=\n  let ⟨y, hy⟩ := nonempty_of_mem_partition hc hs\n  ⟨y, eq_eqv_class_of_mem hc.2 hs hy⟩\n\n"}
{"name":"Setoid.classes_mkClasses","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nc : Set (Set α)\nhc : Setoid.IsPartition c\n⊢ Eq (Setoid.mkClasses c ⋯).classes c","decl":"/-- The equivalence classes of the equivalence relation defined by a partition of α equal\n    the original partition. -/\ntheorem classes_mkClasses (c : Set (Set α)) (hc : IsPartition c) :\n    (mkClasses c hc.2).classes = c := by\n  ext s\n  constructor\n  · rintro ⟨y, rfl⟩\n    obtain ⟨b, ⟨hb, hy⟩, _⟩ := hc.2 y\n    rwa [← eq_eqv_class_of_mem _ hb hy]\n  · exact exists_of_mem_partition hc\n\n"}
{"name":"Setoid.IsPartition.finpartition_parts","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nc : Finset (Set α)\nhc : Setoid.IsPartition ↑c\n⊢ Eq hc.finpartition.parts c","decl":"/-- A finite setoid partition furnishes a finpartition -/\n@[simps]\ndef IsPartition.finpartition {c : Finset (Set α)} (hc : Setoid.IsPartition (c : Set (Set α))) :\n    Finpartition (Set.univ : Set α) where\n  parts := c\n  supIndep := Finset.supIndep_iff_pairwiseDisjoint.mpr <| eqv_classes_disjoint hc.2\n  sup_parts := c.sup_id_set_eq_sUnion.trans hc.sUnion_eq_univ\n  not_bot_mem := hc.left\n\n"}
{"name":"Finpartition.isPartition_parts","module":"Mathlib.Data.Setoid.Partition","initialProofState":"α : Type u_1\nf : Finpartition Set.univ\n⊢ Setoid.IsPartition ↑f.parts","decl":"/-- A finpartition gives rise to a setoid partition -/\ntheorem Finpartition.isPartition_parts {α} (f : Finpartition (Set.univ : Set α)) :\n    Setoid.IsPartition (f.parts : Set (Set α)) :=\n  ⟨f.not_bot_mem,\n    Setoid.eqv_classes_of_disjoint_union (f.parts.sup_id_set_eq_sUnion.symm.trans f.sup_parts)\n      f.supIndep.pairwiseDisjoint⟩\n\n"}
{"name":"IndexedPartition.mk.sizeOf_spec","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\ninst✝² : SizeOf ι\ninst✝¹ : SizeOf α\ninst✝ : (a : ι) → (a_1 : α) → SizeOf (s a a_1)\neq_of_mem : ∀ {x : α} {i j : ι}, Membership.mem (s i) x → Membership.mem (s j) x → Eq i j\nsome : ι → α\nsome_mem : ∀ (i : ι), Membership.mem (s i) (some i)\nindex : α → ι\nmem_index : ∀ (x : α), Membership.mem (s (index x)) x\n⊢ Eq (SizeOf.sizeOf { eq_of_mem := eq_of_mem, some := some, some_mem := some_mem, index := index, mem_index := mem_index }) 1","decl":"/-- Constructive information associated with a partition of a type `α` indexed by another type `ι`,\n`s : ι → Set α`.\n\n`IndexedPartition.index` sends an element to its index, while `IndexedPartition.some` sends\nan index to an element of the corresponding set.\n\nThis type is primarily useful for definitional control of `s` - if this is not needed, then\n`Setoid.ker index` by itself may be sufficient. -/\nstructure IndexedPartition {ι α : Type*} (s : ι → Set α) where\n  /-- two indexes are equal if they are equal in membership  -/\n  eq_of_mem : ∀ {x i j}, x ∈ s i → x ∈ s j → i = j\n  /-- sends an index to an element of the corresponding set -/\n  some : ι → α\n  /-- membership invariance for `some`-/\n  some_mem : ∀ i, some i ∈ s i\n  /-- index for type `α`-/\n  index : α → ι\n  /-- membership invariance for `index`-/\n  mem_index : ∀ x, x ∈ s (index x)\n\n"}
{"name":"IndexedPartition.some_mem","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nself : IndexedPartition s\ni : ι\n⊢ Membership.mem (s i) (self.some i)","decl":"/-- Constructive information associated with a partition of a type `α` indexed by another type `ι`,\n`s : ι → Set α`.\n\n`IndexedPartition.index` sends an element to its index, while `IndexedPartition.some` sends\nan index to an element of the corresponding set.\n\nThis type is primarily useful for definitional control of `s` - if this is not needed, then\n`Setoid.ker index` by itself may be sufficient. -/\nstructure IndexedPartition {ι α : Type*} (s : ι → Set α) where\n  /-- two indexes are equal if they are equal in membership  -/\n  eq_of_mem : ∀ {x i j}, x ∈ s i → x ∈ s j → i = j\n  /-- sends an index to an element of the corresponding set -/\n  some : ι → α\n  /-- membership invariance for `some`-/\n  some_mem : ∀ i, some i ∈ s i\n  /-- index for type `α`-/\n  index : α → ι\n  /-- membership invariance for `index`-/\n  mem_index : ∀ x, x ∈ s (index x)\n\n"}
{"name":"IndexedPartition.eq_of_mem","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nself : IndexedPartition s\nx : α\ni j : ι\na✝¹ : Membership.mem (s i) x\na✝ : Membership.mem (s j) x\n⊢ Eq i j","decl":"/-- Constructive information associated with a partition of a type `α` indexed by another type `ι`,\n`s : ι → Set α`.\n\n`IndexedPartition.index` sends an element to its index, while `IndexedPartition.some` sends\nan index to an element of the corresponding set.\n\nThis type is primarily useful for definitional control of `s` - if this is not needed, then\n`Setoid.ker index` by itself may be sufficient. -/\nstructure IndexedPartition {ι α : Type*} (s : ι → Set α) where\n  /-- two indexes are equal if they are equal in membership  -/\n  eq_of_mem : ∀ {x i j}, x ∈ s i → x ∈ s j → i = j\n  /-- sends an index to an element of the corresponding set -/\n  some : ι → α\n  /-- membership invariance for `some`-/\n  some_mem : ∀ i, some i ∈ s i\n  /-- index for type `α`-/\n  index : α → ι\n  /-- membership invariance for `index`-/\n  mem_index : ∀ x, x ∈ s (index x)\n\n"}
{"name":"IndexedPartition.mem_index","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nself : IndexedPartition s\nx : α\n⊢ Membership.mem (s (self.index x)) x","decl":"/-- Constructive information associated with a partition of a type `α` indexed by another type `ι`,\n`s : ι → Set α`.\n\n`IndexedPartition.index` sends an element to its index, while `IndexedPartition.some` sends\nan index to an element of the corresponding set.\n\nThis type is primarily useful for definitional control of `s` - if this is not needed, then\n`Setoid.ker index` by itself may be sufficient. -/\nstructure IndexedPartition {ι α : Type*} (s : ι → Set α) where\n  /-- two indexes are equal if they are equal in membership  -/\n  eq_of_mem : ∀ {x i j}, x ∈ s i → x ∈ s j → i = j\n  /-- sends an index to an element of the corresponding set -/\n  some : ι → α\n  /-- membership invariance for `some`-/\n  some_mem : ∀ i, some i ∈ s i\n  /-- index for type `α`-/\n  index : α → ι\n  /-- membership invariance for `index`-/\n  mem_index : ∀ x, x ∈ s (index x)\n\n"}
{"name":"IndexedPartition.mk.inj","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\neq_of_mem✝ : ∀ {x : α} {i j : ι}, Membership.mem (s i) x → Membership.mem (s j) x → Eq i j\nsome✝ : ι → α\nsome_mem✝ : ∀ (i : ι), Membership.mem (s i) (some✝ i)\nindex✝ : α → ι\nmem_index✝ : ∀ (x : α), Membership.mem (s (index✝ x)) x\neq_of_mem : ∀ {x : α} {i j : ι}, Membership.mem (s i) x → Membership.mem (s j) x → Eq i j\nsome : ι → α\nsome_mem : ∀ (i : ι), Membership.mem (s i) (some i)\nindex : α → ι\nmem_index : ∀ (x : α), Membership.mem (s (index x)) x\nx✝ : Eq { eq_of_mem := eq_of_mem✝, some := some✝, some_mem := some_mem✝, index := index✝, mem_index := mem_index✝ } { eq_of_mem := eq_of_mem, some := some, some_mem := some_mem, index := index, mem_index := mem_index }\n⊢ And (Eq some✝ some) (Eq index✝ index)","decl":"/-- Constructive information associated with a partition of a type `α` indexed by another type `ι`,\n`s : ι → Set α`.\n\n`IndexedPartition.index` sends an element to its index, while `IndexedPartition.some` sends\nan index to an element of the corresponding set.\n\nThis type is primarily useful for definitional control of `s` - if this is not needed, then\n`Setoid.ker index` by itself may be sufficient. -/\nstructure IndexedPartition {ι α : Type*} (s : ι → Set α) where\n  /-- two indexes are equal if they are equal in membership  -/\n  eq_of_mem : ∀ {x i j}, x ∈ s i → x ∈ s j → i = j\n  /-- sends an index to an element of the corresponding set -/\n  some : ι → α\n  /-- membership invariance for `some`-/\n  some_mem : ∀ i, some i ∈ s i\n  /-- index for type `α`-/\n  index : α → ι\n  /-- membership invariance for `index`-/\n  mem_index : ∀ x, x ∈ s (index x)\n\n"}
{"name":"IndexedPartition.mk.injEq","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\neq_of_mem✝ : ∀ {x : α} {i j : ι}, Membership.mem (s i) x → Membership.mem (s j) x → Eq i j\nsome✝ : ι → α\nsome_mem✝ : ∀ (i : ι), Membership.mem (s i) (some✝ i)\nindex✝ : α → ι\nmem_index✝ : ∀ (x : α), Membership.mem (s (index✝ x)) x\neq_of_mem : ∀ {x : α} {i j : ι}, Membership.mem (s i) x → Membership.mem (s j) x → Eq i j\nsome : ι → α\nsome_mem : ∀ (i : ι), Membership.mem (s i) (some i)\nindex : α → ι\nmem_index : ∀ (x : α), Membership.mem (s (index x)) x\n⊢ Eq (Eq { eq_of_mem := eq_of_mem✝, some := some✝, some_mem := some_mem✝, index := index✝, mem_index := mem_index✝ } { eq_of_mem := eq_of_mem, some := some, some_mem := some_mem, index := index, mem_index := mem_index }) (And (Eq some✝ some) (Eq index✝ index))","decl":"/-- Constructive information associated with a partition of a type `α` indexed by another type `ι`,\n`s : ι → Set α`.\n\n`IndexedPartition.index` sends an element to its index, while `IndexedPartition.some` sends\nan index to an element of the corresponding set.\n\nThis type is primarily useful for definitional control of `s` - if this is not needed, then\n`Setoid.ker index` by itself may be sufficient. -/\nstructure IndexedPartition {ι α : Type*} (s : ι → Set α) where\n  /-- two indexes are equal if they are equal in membership  -/\n  eq_of_mem : ∀ {x i j}, x ∈ s i → x ∈ s j → i = j\n  /-- sends an index to an element of the corresponding set -/\n  some : ι → α\n  /-- membership invariance for `some`-/\n  some_mem : ∀ i, some i ∈ s i\n  /-- index for type `α`-/\n  index : α → ι\n  /-- membership invariance for `index`-/\n  mem_index : ∀ x, x ∈ s (index x)\n\n"}
{"name":"IndexedPartition.exists_mem","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nx : α\n⊢ Exists fun i => Membership.mem (s i) x","decl":"include hs in\ntheorem exists_mem (x : α) : ∃ i, x ∈ s i :=\n  ⟨hs.index x, hs.mem_index x⟩\n\n"}
{"name":"IndexedPartition.iUnion","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\n⊢ Eq (Set.iUnion fun i => s i) Set.univ","decl":"include hs in\ntheorem iUnion : ⋃ i, s i = univ := by\n  ext x\n  simp [hs.exists_mem x]\n\n"}
{"name":"IndexedPartition.disjoint","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\n⊢ Pairwise (Function.onFun Disjoint s)","decl":"include hs in\ntheorem disjoint : Pairwise (Disjoint on s) := fun {_i _j} h =>\n  disjoint_left.mpr fun {_x} hxi hxj => h (hs.eq_of_mem hxi hxj)\n\n"}
{"name":"IndexedPartition.mem_iff_index_eq","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nx : α\ni : ι\n⊢ Iff (Membership.mem (s i) x) (Eq (hs.index x) i)","decl":"theorem mem_iff_index_eq {x i} : x ∈ s i ↔ hs.index x = i :=\n  ⟨fun hxi => (hs.eq_of_mem hxi (hs.mem_index x)).symm, fun h => h ▸ hs.mem_index _⟩\n\n"}
{"name":"IndexedPartition.eq","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\ni : ι\n⊢ Eq (s i) (setOf fun x => Eq (hs.index x) i)","decl":"theorem eq (i) : s i = { x | hs.index x = i } :=\n  Set.ext fun _ => hs.mem_iff_index_eq\n\n"}
{"name":"IndexedPartition.index_some","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\ni : ι\n⊢ Eq (hs.index (hs.some i)) i","decl":"@[simp]\ntheorem index_some (i : ι) : hs.index (hs.some i) = i :=\n  (mem_iff_index_eq _).1 <| hs.some_mem i\n\n"}
{"name":"IndexedPartition.some_index","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nx : α\n⊢ hs.setoid (hs.some (hs.index x)) x","decl":"theorem some_index (x : α) : hs.setoid (hs.some (hs.index x)) x :=\n  hs.index_some (hs.index x)\n\n"}
{"name":"IndexedPartition.proj_eq_iff","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nx y : α\n⊢ Iff (Eq (hs.proj x) (hs.proj y)) (Eq (hs.index x) (hs.index y))","decl":"theorem proj_eq_iff {x y : α} : hs.proj x = hs.proj y ↔ hs.index x = hs.index y :=\n  Quotient.eq''\n\n"}
{"name":"IndexedPartition.proj_some_index","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nx : α\n⊢ Eq (hs.proj (hs.some (hs.index x))) (hs.proj x)","decl":"@[simp]\ntheorem proj_some_index (x : α) : hs.proj (hs.some (hs.index x)) = hs.proj x :=\n  Quotient.eq''.2 (hs.some_index x)\n\n"}
{"name":"IndexedPartition.equivQuotient_index_apply","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nx : α\n⊢ Eq (hs.equivQuotient (hs.index x)) (hs.proj x)","decl":"@[simp]\ntheorem equivQuotient_index_apply (x : α) : hs.equivQuotient (hs.index x) = hs.proj x :=\n  hs.proj_eq_iff.mpr (some_index hs x)\n\n"}
{"name":"IndexedPartition.equivQuotient_symm_proj_apply","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nx : α\n⊢ Eq (hs.equivQuotient.symm (hs.proj x)) (hs.index x)","decl":"@[simp]\ntheorem equivQuotient_symm_proj_apply (x : α) : hs.equivQuotient.symm (hs.proj x) = hs.index x :=\n  rfl\n\n"}
{"name":"IndexedPartition.equivQuotient_index","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\n⊢ Eq (Function.comp (⇑hs.equivQuotient) hs.index) hs.proj","decl":"theorem equivQuotient_index : hs.equivQuotient ∘ hs.index = hs.proj :=\n  funext hs.equivQuotient_index_apply\n\n"}
{"name":"IndexedPartition.out_proj","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nx : α\n⊢ Eq (hs.out (hs.proj x)) (hs.some (hs.index x))","decl":"/-- This lemma is analogous to `Quotient.mk_out'`. -/\n@[simp]\ntheorem out_proj (x : α) : hs.out (hs.proj x) = hs.some (hs.index x) :=\n  rfl\n\n"}
{"name":"IndexedPartition.index_out","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nx : hs.Quotient\n⊢ Eq (hs.index (Quotient.out x)) (hs.index (hs.out x))","decl":"/-- The indices of `Quotient.out` and `IndexedPartition.out` are equal. -/\ntheorem index_out (x : hs.Quotient) : hs.index x.out = hs.index (hs.out x) :=\n  Quotient.inductionOn' x fun x => (Setoid.ker_apply_mk_out x).trans (hs.index_some _).symm\n\n"}
{"name":"IndexedPartition.index_out'","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nx : hs.Quotient\n⊢ Eq (hs.index (Quotient.out x)) (hs.index (hs.out x))","decl":"@[deprecated (since := \"2024-10-19\")] alias index_out' := index_out\n\n"}
{"name":"IndexedPartition.proj_out","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nx : hs.Quotient\n⊢ Eq (hs.proj (hs.out x)) x","decl":"/-- This lemma is analogous to `Quotient.out_eq'`. -/\n@[simp]\ntheorem proj_out (x : hs.Quotient) : hs.proj (hs.out x) = x :=\n  Quotient.inductionOn' x fun x => Quotient.sound' <| hs.some_index x\n\n"}
{"name":"IndexedPartition.class_of","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nx : α\n⊢ Eq (setOf (hs.setoid x)) (s (hs.index x))","decl":"theorem class_of {x : α} : setOf (hs.setoid x) = s (hs.index x) :=\n  Set.ext fun _y => eq_comm.trans hs.mem_iff_index_eq.symm\n\n"}
{"name":"IndexedPartition.proj_fiber","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nx : hs.Quotient\n⊢ Eq (Set.preimage hs.proj (Singleton.singleton x)) (s (hs.equivQuotient.symm x))","decl":"theorem proj_fiber (x : hs.Quotient) : hs.proj ⁻¹' {x} = s (hs.equivQuotient.symm x) :=\n  Quotient.inductionOn' x fun x => by\n    ext y\n    simp only [Set.mem_preimage, Set.mem_singleton_iff, hs.mem_iff_index_eq]\n    exact Quotient.eq''\n\n"}
{"name":"IndexedPartition.piecewise_apply","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nβ : Type u_3\nf : ι → α → β\nx : α\n⊢ Eq (hs.piecewise f x) (f (hs.index x) x)","decl":"lemma piecewise_apply {β : Type*} {f : ι → α → β} (x : α) : hs.piecewise f x = f (hs.index x) x :=\n  rfl\n\n"}
{"name":"IndexedPartition.piecewise_inj","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nβ : Type u_3\nf : ι → α → β\nh_injOn : ∀ (i : ι), Set.InjOn (f i) (s i)\nh_disjoint : Set.univ.PairwiseDisjoint fun i => Set.image (f i) (s i)\n⊢ Function.Injective (hs.piecewise f)","decl":"/-- A family of injective functions with pairwise disjoint\ndomains and pairwise disjoint ranges can be glued together\nto form an injective function. -/\ntheorem piecewise_inj {β : Type*} {f : ι → α → β}\n    (h_injOn : ∀ i, InjOn (f i) (s i))\n    (h_disjoint : PairwiseDisjoint (univ : Set ι) fun i => (f i) '' (s i)) :\n    Injective (piecewise hs f) := by\n  intro x y h\n  suffices hs.index x = hs.index y by\n    apply h_injOn (hs.index x) (hs.mem_index x) (this ▸ hs.mem_index y)\n    simpa only [piecewise_apply, this] using h\n  apply h_disjoint.elim trivial trivial\n  contrapose! h\n  exact h.ne_of_mem (mem_image_of_mem _ (hs.mem_index x)) (mem_image_of_mem _ (hs.mem_index y))\n\n"}
{"name":"IndexedPartition.piecewise_bij","module":"Mathlib.Data.Setoid.Partition","initialProofState":"ι : Type u_1\nα : Type u_2\ns : ι → Set α\nhs : IndexedPartition s\nβ : Type u_3\nf : ι → α → β\nt : ι → Set β\nht : IndexedPartition t\nhf : ∀ (i : ι), Set.BijOn (f i) (s i) (t i)\n⊢ Function.Bijective (hs.piecewise f)","decl":"/-- A family of bijective functions with pairwise disjoint\ndomains and pairwise disjoint ranges can be glued together\nto form a bijective function. -/\ntheorem piecewise_bij {β : Type*} {f : ι → α → β}\n    {t : ι → Set β} (ht : IndexedPartition t)\n    (hf : ∀ i, BijOn (f i) (s i) (t i)) :\n    Bijective (piecewise hs f) := by\n  set g := piecewise hs f with hg\n  have hg_bij : ∀ i, BijOn g (s i) (t i) := by\n    intro i\n    refine BijOn.congr (hf i) ?_\n    intro x hx\n    rw [hg, piecewise_apply, hs.mem_iff_index_eq.mp hx]\n  have hg_inj : InjOn g (⋃ i, s i) := by\n    refine injOn_of_injective ?_\n    refine piecewise_inj hs (fun i ↦ BijOn.injOn (hf i)) ?h_disjoint\n    simp only [fun i ↦ BijOn.image_eq (hf i)]\n    rintro i - j - hij\n    exact ht.disjoint hij\n  rw [bijective_iff_bijOn_univ, ← hs.iUnion, ← ht.iUnion]\n  exact bijOn_iUnion hg_bij hg_inj\n\n"}
