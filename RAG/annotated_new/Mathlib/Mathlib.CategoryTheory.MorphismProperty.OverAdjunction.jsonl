{"name":"CategoryTheory.MorphismProperty.Over.map_obj_left","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝¹ : Q.IsMultiplicative\nX✝ Y : T\nf : Quiver.Hom X✝ Y\ninst✝ : P.IsStableUnderComposition\nhPf : P f\nX : CategoryTheory.MorphismProperty.Comma (CategoryTheory.Functor.id T) (CategoryTheory.Functor.fromPUnit X✝) P Q Top.top\n⊢ Eq ((CategoryTheory.MorphismProperty.Over.map Q hPf).obj X).left X.left","decl":"/-- If `P` is stable under composition and `f : X ⟶ Y` satisfies `P`,\nthis is the functor `P.Over Q X ⥤ P.Over Q Y` given by composing with `f`. -/\n@[simps! obj_left obj_hom map_left]\ndef Over.map : P.Over Q X ⥤ P.Over Q Y :=\n  Comma.mapRight _ (Discrete.natTrans fun _ ↦ f) <| fun X ↦ P.comp_mem _ _ X.prop hPf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.map_map_left","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝¹ : Q.IsMultiplicative\nX✝ Y✝ : T\nf✝ : Quiver.Hom X✝ Y✝\ninst✝ : P.IsStableUnderComposition\nhPf : P f✝\nX Y : CategoryTheory.MorphismProperty.Comma (CategoryTheory.Functor.id T) (CategoryTheory.Functor.fromPUnit X✝) P Q Top.top\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.MorphismProperty.Over.map Q hPf).map f).left (CategoryTheory.MorphismProperty.Comma.Hom.hom f).left","decl":"/-- If `P` is stable under composition and `f : X ⟶ Y` satisfies `P`,\nthis is the functor `P.Over Q X ⥤ P.Over Q Y` given by composing with `f`. -/\n@[simps! obj_left obj_hom map_left]\ndef Over.map : P.Over Q X ⥤ P.Over Q Y :=\n  Comma.mapRight _ (Discrete.natTrans fun _ ↦ f) <| fun X ↦ P.comp_mem _ _ X.prop hPf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.map_obj_hom","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝¹ : Q.IsMultiplicative\nX✝ Y : T\nf : Quiver.Hom X✝ Y\ninst✝ : P.IsStableUnderComposition\nhPf : P f\nX : CategoryTheory.MorphismProperty.Comma (CategoryTheory.Functor.id T) (CategoryTheory.Functor.fromPUnit X✝) P Q Top.top\n⊢ Eq ((CategoryTheory.MorphismProperty.Over.map Q hPf).obj X).hom (CategoryTheory.CategoryStruct.comp X.hom f)","decl":"/-- If `P` is stable under composition and `f : X ⟶ Y` satisfies `P`,\nthis is the functor `P.Over Q X ⥤ P.Over Q Y` given by composing with `f`. -/\n@[simps! obj_left obj_hom map_left]\ndef Over.map : P.Over Q X ⥤ P.Over Q Y :=\n  Comma.mapRight _ (Discrete.natTrans fun _ ↦ f) <| fun X ↦ P.comp_mem _ _ X.prop hPf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.map_comp","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝¹ : Q.IsMultiplicative\ninst✝ : P.IsStableUnderComposition\nX Y Z : T\nf : Quiver.Hom X Y\nhf : P f\ng : Quiver.Hom Y Z\nhg : P g\n⊢ Eq (CategoryTheory.MorphismProperty.Over.map Q ⋯) ((CategoryTheory.MorphismProperty.Over.map Q hf).comp (CategoryTheory.MorphismProperty.Over.map Q hg))","decl":"lemma Over.map_comp {X Y Z : T} {f : X ⟶ Y} (hf : P f) {g : Y ⟶ Z} (hg : P g) :\n    map Q (P.comp_mem f g hf hg) = map Q hf ⋙ map Q hg := by\n  fapply Functor.ext\n  · simp [map, Comma.mapRight, CategoryTheory.Comma.mapRight, Comma.lift]\n  · intro U V k\n    ext\n    simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.mapComp_hom_app_left","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝² : Q.IsMultiplicative\ninst✝¹ : P.IsStableUnderComposition\nX✝ Y Z : T\nf : Quiver.Hom X✝ Y\nhf : P f\ng : Quiver.Hom Y Z\nhg : P g\ninst✝ : Q.RespectsIso\nX : P.Over Q X✝\n⊢ Eq ((CategoryTheory.MorphismProperty.Over.mapComp Q hf hg).hom.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- `Over.map` commutes with composition. -/\n@[simps! hom_app_left inv_app_left]\ndef Over.mapComp {X Y Z : T} {f : X ⟶ Y} (hf : P f) {g : Y ⟶ Z} (hg : P g) [Q.RespectsIso] :\n    map Q (P.comp_mem f g hf hg) ≅ map Q hf ⋙ map Q hg :=\n  NatIso.ofComponents (fun X ↦ Over.isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.mapComp_inv_app_left","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝² : Q.IsMultiplicative\ninst✝¹ : P.IsStableUnderComposition\nX✝ Y Z : T\nf : Quiver.Hom X✝ Y\nhf : P f\ng : Quiver.Hom Y Z\nhg : P g\ninst✝ : Q.RespectsIso\nX : P.Over Q X✝\n⊢ Eq ((CategoryTheory.MorphismProperty.Over.mapComp Q hf hg).inv.app X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- `Over.map` commutes with composition. -/\n@[simps! hom_app_left inv_app_left]\ndef Over.mapComp {X Y Z : T} {f : X ⟶ Y} (hf : P f) {g : Y ⟶ Z} (hg : P g) [Q.RespectsIso] :\n    map Q (P.comp_mem f g hf hg) ≅ map Q hf ⋙ map Q hg :=\n  NatIso.ofComponents (fun X ↦ Over.isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.pullback_obj_hom","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝³ : Q.IsMultiplicative\nX Y : T\nf : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasPullbacks T\ninst✝¹ : P.IsStableUnderBaseChange\ninst✝ : Q.IsStableUnderBaseChange\nA : P.Over Q Y\n⊢ Eq ((CategoryTheory.MorphismProperty.Over.pullback P Q f).obj A).hom (CategoryTheory.Limits.pullback.snd A.hom f)","decl":"/-- If `P` and `Q` are stable under base change and pullbacks exist in `T`,\nthis is the functor `P.Over Q Y ⥤ P.Over Q X` given by base change along `f`. -/\n@[simps! obj_left obj_hom map_left]\nnoncomputable def Over.pullback : P.Over Q Y ⥤ P.Over Q X where\n  obj A :=\n    { __ := (CategoryTheory.Over.pullback f).obj A.toComma\n      prop := P.pullback_snd _ _ A.prop }\n  map {A B} g :=\n    { __ := (CategoryTheory.Over.pullback f).map g.toCommaMorphism\n      prop_hom_left := Q.baseChange_map f g.toCommaMorphism g.prop_hom_left\n      prop_hom_right := trivial }\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.pullback_map_left","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝³ : Q.IsMultiplicative\nX Y : T\nf : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasPullbacks T\ninst✝¹ : P.IsStableUnderBaseChange\ninst✝ : Q.IsStableUnderBaseChange\nA B : P.Over Q Y\ng : Quiver.Hom A B\n⊢ Eq ((CategoryTheory.MorphismProperty.Over.pullback P Q f).map g).left (CategoryTheory.Limits.pullback.lift (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst A.hom f) g.left) (CategoryTheory.Limits.pullback.snd A.hom f) ⋯)","decl":"/-- If `P` and `Q` are stable under base change and pullbacks exist in `T`,\nthis is the functor `P.Over Q Y ⥤ P.Over Q X` given by base change along `f`. -/\n@[simps! obj_left obj_hom map_left]\nnoncomputable def Over.pullback : P.Over Q Y ⥤ P.Over Q X where\n  obj A :=\n    { __ := (CategoryTheory.Over.pullback f).obj A.toComma\n      prop := P.pullback_snd _ _ A.prop }\n  map {A B} g :=\n    { __ := (CategoryTheory.Over.pullback f).map g.toCommaMorphism\n      prop_hom_left := Q.baseChange_map f g.toCommaMorphism g.prop_hom_left\n      prop_hom_right := trivial }\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.pullback_obj_left","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝³ : Q.IsMultiplicative\nX Y : T\nf : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasPullbacks T\ninst✝¹ : P.IsStableUnderBaseChange\ninst✝ : Q.IsStableUnderBaseChange\nA : P.Over Q Y\n⊢ Eq ((CategoryTheory.MorphismProperty.Over.pullback P Q f).obj A).left (CategoryTheory.Limits.pullback A.hom f)","decl":"/-- If `P` and `Q` are stable under base change and pullbacks exist in `T`,\nthis is the functor `P.Over Q Y ⥤ P.Over Q X` given by base change along `f`. -/\n@[simps! obj_left obj_hom map_left]\nnoncomputable def Over.pullback : P.Over Q Y ⥤ P.Over Q X where\n  obj A :=\n    { __ := (CategoryTheory.Over.pullback f).obj A.toComma\n      prop := P.pullback_snd _ _ A.prop }\n  map {A B} g :=\n    { __ := (CategoryTheory.Over.pullback f).map g.toCommaMorphism\n      prop_hom_left := Q.baseChange_map f g.toCommaMorphism g.prop_hom_left\n      prop_hom_right := trivial }\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.pullbackComp_inv_app_left","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝⁴ : Q.IsMultiplicative\ninst✝³ : CategoryTheory.Limits.HasPullbacks T\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : Q.IsStableUnderBaseChange\ninst✝ : Q.RespectsIso\nX✝ Y Z : T\nf : Quiver.Hom X✝ Y\ng : Quiver.Hom Y Z\nX : P.Over Q Z\n⊢ Eq ((CategoryTheory.MorphismProperty.Over.pullbackComp f g).inv.app X).left (CategoryTheory.Limits.pullbackLeftPullbackSndIso X.hom g f).hom","decl":"/-- `Over.pullback` commutes with composition. -/\n@[simps! hom_app_left inv_app_left]\nnoncomputable def Over.pullbackComp [Q.RespectsIso] {X Y Z : T} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    Over.pullback P Q (f ≫ g) ≅ Over.pullback P Q g ⋙ Over.pullback P Q f :=\n  NatIso.ofComponents\n    (fun X ↦ Over.isoMk ((pullbackLeftPullbackSndIso X.hom g f).symm) (by simp))\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.pullbackComp_hom_app_left","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝⁴ : Q.IsMultiplicative\ninst✝³ : CategoryTheory.Limits.HasPullbacks T\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : Q.IsStableUnderBaseChange\ninst✝ : Q.RespectsIso\nX✝ Y Z : T\nf : Quiver.Hom X✝ Y\ng : Quiver.Hom Y Z\nX : P.Over Q Z\n⊢ Eq ((CategoryTheory.MorphismProperty.Over.pullbackComp f g).hom.app X).left (CategoryTheory.Limits.pullbackLeftPullbackSndIso X.hom g f).inv","decl":"/-- `Over.pullback` commutes with composition. -/\n@[simps! hom_app_left inv_app_left]\nnoncomputable def Over.pullbackComp [Q.RespectsIso] {X Y Z : T} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    Over.pullback P Q (f ≫ g) ≅ Over.pullback P Q g ⋙ Over.pullback P Q f :=\n  NatIso.ofComponents\n    (fun X ↦ Over.isoMk ((pullbackLeftPullbackSndIso X.hom g f).symm) (by simp))\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.pullbackComp_left_fst_fst","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝⁴ : Q.IsMultiplicative\ninst✝³ : CategoryTheory.Limits.HasPullbacks T\ninst✝² : P.IsStableUnderBaseChange\ninst✝¹ : Q.IsStableUnderBaseChange\ninst✝ : Q.RespectsIso\nX Y Z : T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nA : P.Over Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MorphismProperty.Over.pullbackComp f g).hom.app A).left (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.snd A.hom g) f) (CategoryTheory.Limits.pullback.fst A.hom g))) (CategoryTheory.Limits.pullback.fst A.hom (CategoryTheory.CategoryStruct.comp f g))","decl":"lemma Over.pullbackComp_left_fst_fst [Q.RespectsIso] {X Y Z : T} (f : X ⟶ Y) (g : Y ⟶ Z)\n    (A : P.Over Q Z) :\n    ((Over.pullbackComp f g).hom.app A).left ≫\n      pullback.fst (pullback.snd A.hom g) f ≫ pullback.fst A.hom g =\n        pullback.fst A.hom (f ≫ g) := by\n  simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.pullbackCongr_hom_app_left_fst_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝³ : Q.IsMultiplicative\ninst✝² : CategoryTheory.Limits.HasPullbacks T\ninst✝¹ : P.IsStableUnderBaseChange\ninst✝ : Q.IsStableUnderBaseChange\nX Y : T\nf g : Quiver.Hom X Y\nh✝ : Eq f g\nA : P.Over Q Y\nZ : T\nh : Quiver.Hom A.left Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MorphismProperty.Over.pullbackCongr h✝).hom.app A).left (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst A.hom g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst A.hom f) h)","decl":"@[reassoc (attr := simp)]\nlemma Over.pullbackCongr_hom_app_left_fst {X Y : T} {f g : X ⟶ Y} (h : f = g) (A : P.Over Q Y) :\n    ((Over.pullbackCongr h).hom.app A).left ≫ pullback.fst A.hom g =\n      pullback.fst A.hom f := by\n  subst h\n  simp [pullbackCongr]\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.pullbackCongr_hom_app_left_fst","module":"Mathlib.CategoryTheory.MorphismProperty.OverAdjunction","initialProofState":"T : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\ninst✝³ : Q.IsMultiplicative\ninst✝² : CategoryTheory.Limits.HasPullbacks T\ninst✝¹ : P.IsStableUnderBaseChange\ninst✝ : Q.IsStableUnderBaseChange\nX Y : T\nf g : Quiver.Hom X Y\nh : Eq f g\nA : P.Over Q Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MorphismProperty.Over.pullbackCongr h).hom.app A).left (CategoryTheory.Limits.pullback.fst A.hom g)) (CategoryTheory.Limits.pullback.fst A.hom f)","decl":"@[reassoc (attr := simp)]\nlemma Over.pullbackCongr_hom_app_left_fst {X Y : T} {f g : X ⟶ Y} (h : f = g) (A : P.Over Q Y) :\n    ((Over.pullbackCongr h).hom.app A).left ≫ pullback.fst A.hom g =\n      pullback.fst A.hom f := by\n  subst h\n  simp [pullbackCongr]\n\n"}
