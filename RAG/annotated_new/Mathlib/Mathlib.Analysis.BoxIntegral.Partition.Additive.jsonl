{"name":"BoxIntegral.BoxAdditiveMap.sum_partition_boxes'","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_3\nM : Type u_4\ninst✝ : AddCommMonoid M\nI : WithTop (BoxIntegral.Box ι)\nself : BoxIntegral.BoxAdditiveMap ι M I\nJ : BoxIntegral.Box ι\na✝¹ : LE.le (↑J) I\nπ : BoxIntegral.Prepartition J\na✝ : π.IsPartition\n⊢ Eq (π.boxes.sum fun Ji => self.toFun Ji) (self.toFun J)","decl":"/-- A function on `Box ι` is called box additive if for every box `J` and a partition `π` of `J`\nwe have `f J = ∑ Ji ∈ π.boxes, f Ji`. A function is called box additive on subboxes of `I : Box ι`\nif the same property holds for `J ≤ I`. We formalize these two notions in the same definition\nusing `I : WithBot (Box ι)`: the value `I = ⊤` corresponds to functions box additive on the whole\nspace. -/\nstructure BoxAdditiveMap (ι M : Type*) [AddCommMonoid M] (I : WithTop (Box ι)) where\n  /-- The function underlying this additive map. -/\n  toFun : Box ι → M\n  sum_partition_boxes' : ∀ J : Box ι, ↑J ≤ I → ∀ π : Prepartition J, π.IsPartition →\n    ∑ Ji ∈ π.boxes, toFun Ji = toFun J\n\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.mk.inj","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_3\nM : Type u_4\ninst✝ : AddCommMonoid M\nI : WithTop (BoxIntegral.Box ι)\ntoFun✝ : BoxIntegral.Box ι → M\nsum_partition_boxes'✝ : ∀ (J : BoxIntegral.Box ι), LE.le (↑J) I → ∀ (π : BoxIntegral.Prepartition J), π.IsPartition → Eq (π.boxes.sum fun Ji => toFun✝ Ji) (toFun✝ J)\ntoFun : BoxIntegral.Box ι → M\nsum_partition_boxes' : ∀ (J : BoxIntegral.Box ι), LE.le (↑J) I → ∀ (π : BoxIntegral.Prepartition J), π.IsPartition → Eq (π.boxes.sum fun Ji => toFun Ji) (toFun J)\nx✝ : Eq { toFun := toFun✝, sum_partition_boxes' := sum_partition_boxes'✝ } { toFun := toFun, sum_partition_boxes' := sum_partition_boxes' }\n⊢ Eq toFun✝ toFun","decl":"/-- A function on `Box ι` is called box additive if for every box `J` and a partition `π` of `J`\nwe have `f J = ∑ Ji ∈ π.boxes, f Ji`. A function is called box additive on subboxes of `I : Box ι`\nif the same property holds for `J ≤ I`. We formalize these two notions in the same definition\nusing `I : WithBot (Box ι)`: the value `I = ⊤` corresponds to functions box additive on the whole\nspace. -/\nstructure BoxAdditiveMap (ι M : Type*) [AddCommMonoid M] (I : WithTop (Box ι)) where\n  /-- The function underlying this additive map. -/\n  toFun : Box ι → M\n  sum_partition_boxes' : ∀ J : Box ι, ↑J ≤ I → ∀ π : Prepartition J, π.IsPartition →\n    ∑ Ji ∈ π.boxes, toFun Ji = toFun J\n\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.mk.sizeOf_spec","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_3\nM : Type u_4\ninst✝² : AddCommMonoid M\nI : WithTop (BoxIntegral.Box ι)\ninst✝¹ : SizeOf ι\ninst✝ : SizeOf M\ntoFun : BoxIntegral.Box ι → M\nsum_partition_boxes' : ∀ (J : BoxIntegral.Box ι), LE.le (↑J) I → ∀ (π : BoxIntegral.Prepartition J), π.IsPartition → Eq (π.boxes.sum fun Ji => toFun Ji) (toFun J)\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, sum_partition_boxes' := sum_partition_boxes' }) 1","decl":"/-- A function on `Box ι` is called box additive if for every box `J` and a partition `π` of `J`\nwe have `f J = ∑ Ji ∈ π.boxes, f Ji`. A function is called box additive on subboxes of `I : Box ι`\nif the same property holds for `J ≤ I`. We formalize these two notions in the same definition\nusing `I : WithBot (Box ι)`: the value `I = ⊤` corresponds to functions box additive on the whole\nspace. -/\nstructure BoxAdditiveMap (ι M : Type*) [AddCommMonoid M] (I : WithTop (Box ι)) where\n  /-- The function underlying this additive map. -/\n  toFun : Box ι → M\n  sum_partition_boxes' : ∀ J : Box ι, ↑J ≤ I → ∀ π : Prepartition J, π.IsPartition →\n    ∑ Ji ∈ π.boxes, toFun Ji = toFun J\n\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.mk.injEq","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_3\nM : Type u_4\ninst✝ : AddCommMonoid M\nI : WithTop (BoxIntegral.Box ι)\ntoFun✝ : BoxIntegral.Box ι → M\nsum_partition_boxes'✝ : ∀ (J : BoxIntegral.Box ι), LE.le (↑J) I → ∀ (π : BoxIntegral.Prepartition J), π.IsPartition → Eq (π.boxes.sum fun Ji => toFun✝ Ji) (toFun✝ J)\ntoFun : BoxIntegral.Box ι → M\nsum_partition_boxes' : ∀ (J : BoxIntegral.Box ι), LE.le (↑J) I → ∀ (π : BoxIntegral.Prepartition J), π.IsPartition → Eq (π.boxes.sum fun Ji => toFun Ji) (toFun J)\n⊢ Eq (Eq { toFun := toFun✝, sum_partition_boxes' := sum_partition_boxes'✝ } { toFun := toFun, sum_partition_boxes' := sum_partition_boxes' }) (Eq toFun✝ toFun)","decl":"/-- A function on `Box ι` is called box additive if for every box `J` and a partition `π` of `J`\nwe have `f J = ∑ Ji ∈ π.boxes, f Ji`. A function is called box additive on subboxes of `I : Box ι`\nif the same property holds for `J ≤ I`. We formalize these two notions in the same definition\nusing `I : WithBot (Box ι)`: the value `I = ⊤` corresponds to functions box additive on the whole\nspace. -/\nstructure BoxAdditiveMap (ι M : Type*) [AddCommMonoid M] (I : WithTop (Box ι)) where\n  /-- The function underlying this additive map. -/\n  toFun : Box ι → M\n  sum_partition_boxes' : ∀ J : Box ι, ↑J ≤ I → ∀ π : Prepartition J, π.IsPartition →\n    ∑ Ji ∈ π.boxes, toFun Ji = toFun J\n\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.coe_mk","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝ : AddCommMonoid M\nI₀ : WithTop (BoxIntegral.Box ι)\nf : BoxIntegral.Box ι → M\nh : ∀ (J : BoxIntegral.Box ι), LE.le (↑J) I₀ → ∀ (π : BoxIntegral.Prepartition J), π.IsPartition → Eq (π.boxes.sum fun Ji => f Ji) (f J)\n⊢ Eq (⇑{ toFun := f, sum_partition_boxes' := h }) f","decl":"@[simp]\ntheorem coe_mk (f h) : ⇑(mk f h : ι →ᵇᵃ[I₀] M) = f := rfl\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.coe_injective","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝ : AddCommMonoid M\nI₀ : WithTop (BoxIntegral.Box ι)\n⊢ Function.Injective fun f x => f x","decl":"theorem coe_injective : Injective fun (f : ι →ᵇᵃ[I₀] M) x => f x :=\n  DFunLike.coe_injective\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.coe_inj","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝ : AddCommMonoid M\nI₀ : WithTop (BoxIntegral.Box ι)\nf g : BoxIntegral.BoxAdditiveMap ι M I₀\n⊢ Iff (Eq ⇑f ⇑g) (Eq f g)","decl":"theorem coe_inj {f g : ι →ᵇᵃ[I₀] M} : (f : Box ι → M) = g ↔ f = g := DFunLike.coe_fn_eq\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.sum_partition_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝ : AddCommMonoid M\nI₀ : WithTop (BoxIntegral.Box ι)\nI : BoxIntegral.Box ι\nf : BoxIntegral.BoxAdditiveMap ι M I₀\nhI : LE.le (↑I) I₀\nπ : BoxIntegral.Prepartition I\nh : π.IsPartition\n⊢ Eq (π.boxes.sum fun J => f J) (f I)","decl":"theorem sum_partition_boxes (f : ι →ᵇᵃ[I₀] M) (hI : ↑I ≤ I₀) {π : Prepartition I}\n    (h : π.IsPartition) : ∑ J ∈ π.boxes, f J = f I :=\n  f.sum_partition_boxes' I hI π h\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.instZero_zero_apply","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝ : AddCommMonoid M\nI₀ : WithTop (BoxIntegral.Box ι)\n⊢ Eq (⇑0) 0","decl":"@[simps (config := .asFn)]\ninstance : Zero (ι →ᵇᵃ[I₀] M) :=\n  ⟨⟨0, fun _ _ _ _ => sum_const_zero⟩⟩\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.map_split_add","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝ : AddCommMonoid M\nI₀ : WithTop (BoxIntegral.Box ι)\nI : BoxIntegral.Box ι\nf : BoxIntegral.BoxAdditiveMap ι M I₀\nhI : LE.le (↑I) I₀\ni : ι\nx : Real\n⊢ Eq (HAdd.hAdd (Option.elim' 0 (⇑f) (I.splitLower i x)) (Option.elim' 0 (⇑f) (I.splitUpper i x))) (f I)","decl":"@[simp]\ntheorem map_split_add (f : ι →ᵇᵃ[I₀] M) (hI : ↑I ≤ I₀) (i : ι) (x : ℝ) :\n    (I.splitLower i x).elim' 0 f + (I.splitUpper i x).elim' 0 f = f I := by\n  rw [← f.sum_partition_boxes hI (isPartitionSplit I i x), sum_split_boxes]\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.restrict_apply","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝ : AddCommMonoid M\nI₀ : WithTop (BoxIntegral.Box ι)\nf : BoxIntegral.BoxAdditiveMap ι M I₀\nI : WithTop (BoxIntegral.Box ι)\nhI : LE.le I I₀\na : BoxIntegral.Box ι\n⊢ Eq ((f.restrict I hI) a) (f a)","decl":"/-- If `f` is box-additive on subboxes of `I₀`, then it is box-additive on subboxes of any\n`I ≤ I₀`. -/\n@[simps]\ndef restrict (f : ι →ᵇᵃ[I₀] M) (I : WithTop (Box ι)) (hI : I ≤ I₀) : ι →ᵇᵃ[I] M :=\n  ⟨f, fun J hJ => f.2 J (hJ.trans hI)⟩\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.map_apply","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid N\nI₀ : WithTop (BoxIntegral.Box ι)\nf : BoxIntegral.BoxAdditiveMap ι M I₀\ng : AddMonoidHom M N\n⊢ Eq (⇑(f.map g)) (Function.comp ⇑g ⇑f)","decl":"/-- If `g : M → N` is an additive map and `f` is a box additive map, then `g ∘ f` is a box additive\nmap. -/\n@[simps (config := .asFn)]\ndef map (f : ι →ᵇᵃ[I₀] M) (g : M →+ N) : ι →ᵇᵃ[I₀] N where\n  toFun := g ∘ f\n  sum_partition_boxes' I hI π hπ := by simp_rw [comp, ← map_sum, f.sum_partition_boxes hI hπ]\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.sum_boxes_congr","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_1\nM : Type u_2\ninst✝¹ : AddCommMonoid M\nI₀ : WithTop (BoxIntegral.Box ι)\nI : BoxIntegral.Box ι\ninst✝ : Finite ι\nf : BoxIntegral.BoxAdditiveMap ι M I₀\nhI : LE.le (↑I) I₀\nπ₁ π₂ : BoxIntegral.Prepartition I\nh : Eq π₁.iUnion π₂.iUnion\n⊢ Eq (π₁.boxes.sum fun J => f J) (π₂.boxes.sum fun J => f J)","decl":"/-- If `f` is a box additive function on subboxes of `I` and `π₁`, `π₂` are two prepartitions of\n`I` that cover the same part of `I`, then `∑ J ∈ π₁.boxes, f J = ∑ J ∈ π₂.boxes, f J`. -/\ntheorem sum_boxes_congr [Finite ι] (f : ι →ᵇᵃ[I₀] M) (hI : ↑I ≤ I₀) {π₁ π₂ : Prepartition I}\n    (h : π₁.iUnion = π₂.iUnion) : ∑ J ∈ π₁.boxes, f J = ∑ J ∈ π₂.boxes, f J := by\n  rcases exists_splitMany_inf_eq_filter_of_finite {π₁, π₂} ((finite_singleton _).insert _) with\n    ⟨s, hs⟩\n  simp only [inf_splitMany] at hs\n  rcases hs _ (Or.inl rfl), hs _ (Or.inr rfl) with ⟨h₁, h₂⟩; clear hs\n  rw [h] at h₁\n  calc\n    ∑ J ∈ π₁.boxes, f J = ∑ J ∈ π₁.boxes, ∑ J' ∈ (splitMany J s).boxes, f J' :=\n      Finset.sum_congr rfl fun J hJ => (f.sum_partition_boxes ?_ (isPartition_splitMany _ _)).symm\n    _ = ∑ J ∈ (π₁.biUnion fun J => splitMany J s).boxes, f J := (sum_biUnion_boxes _ _ _).symm\n    _ = ∑ J ∈ (π₂.biUnion fun J => splitMany J s).boxes, f J := by rw [h₁, h₂]\n    _ = ∑ J ∈ π₂.boxes, ∑ J' ∈ (splitMany J s).boxes, f J' := sum_biUnion_boxes _ _ _\n    _ = ∑ J ∈ π₂.boxes, f J :=\n      Finset.sum_congr rfl fun J hJ => f.sum_partition_boxes ?_ (isPartition_splitMany _ _)\n  exacts [(WithTop.coe_le_coe.2 <| π₁.le_of_mem hJ).trans hI,\n    (WithTop.coe_le_coe.2 <| π₂.le_of_mem hJ).trans hI]\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.toSMul_apply","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"ι : Type u_1\nI₀ : WithTop (BoxIntegral.Box ι)\nE : Type u_4\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : BoxIntegral.BoxAdditiveMap ι Real I₀\nI : BoxIntegral.Box ι\nx : E\n⊢ Eq ((f.toSMul I) x) (HSMul.hSMul (f I) x)","decl":"@[simp]\ntheorem toSMul_apply (f : ι →ᵇᵃ[I₀] ℝ) (I : Box ι) (x : E) : f.toSMul I x = f I • x := rfl\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.upperSubLower_apply","module":"Mathlib.Analysis.BoxIntegral.Partition.Additive","initialProofState":"n : Nat\nG : Type u\ninst✝ : AddCommGroup G\nI₀ : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\ni : Fin (HAdd.hAdd n 1)\nf : Real → BoxIntegral.Box (Fin n) → G\nfb : ↑(Set.Icc (I₀.lower i) (I₀.upper i)) → BoxIntegral.BoxAdditiveMap (Fin n) G ↑(I₀.face i)\nhf : ∀ (x : Real) (hx : Membership.mem (Set.Icc (I₀.lower i) (I₀.upper i)) x) (J : BoxIntegral.Box (Fin n)), Eq (f x J) ((fb ⟨x, hx⟩) J)\nJ : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\n⊢ Eq ((BoxIntegral.BoxAdditiveMap.upperSubLower I₀ i f fb hf) J) (HSub.hSub (f (J.upper i) (J.face i)) (f (J.lower i) (J.face i)))","decl":"/-- Given a box `I₀` in `ℝⁿ⁺¹`, `f x : Box (Fin n) → G` is a family of functions indexed by a real\n`x` and for `x ∈ [I₀.lower i, I₀.upper i]`, `f x` is box-additive on subboxes of the `i`-th face of\n`I₀`, then `fun J ↦ f (J.upper i) (J.face i) - f (J.lower i) (J.face i)` is box-additive on subboxes\nof `I₀`. -/\n@[simps!]\ndef upperSubLower.{u} {G : Type u} [AddCommGroup G] (I₀ : Box (Fin (n + 1))) (i : Fin (n + 1))\n    (f : ℝ → Box (Fin n) → G) (fb : Icc (I₀.lower i) (I₀.upper i) → Fin n →ᵇᵃ[I₀.face i] G)\n    (hf : ∀ (x) (hx : x ∈ Icc (I₀.lower i) (I₀.upper i)) (J), f x J = fb ⟨x, hx⟩ J) :\n    Fin (n + 1) →ᵇᵃ[I₀] G :=\n  ofMapSplitAdd (fun J : Box (Fin (n + 1)) => f (J.upper i) (J.face i) - f (J.lower i) (J.face i))\n    I₀\n    (by\n      intro J hJ j x\n      rw [WithTop.coe_le_coe] at hJ\n      refine i.succAboveCases (fun hx => ?_) (fun j hx => ?_) j\n      · simp only [Box.splitLower_def hx, Box.splitUpper_def hx, update_self, ← WithBot.some_eq_coe,\n          Option.elim', Box.face, Function.comp_def, update_of_ne (Fin.succAbove_ne _ _)]\n        abel\n      · have : (J.face i : WithTop (Box (Fin n))) ≤ I₀.face i :=\n          WithTop.coe_le_coe.2 (face_mono hJ i)\n        rw [le_iff_Icc, @Box.Icc_eq_pi _ I₀] at hJ\n        simp only\n        rw [hf _ (hJ J.upper_mem_Icc _ trivial), hf _ (hJ J.lower_mem_Icc _ trivial),\n          ← (fb _).map_split_add this j x, ← (fb _).map_split_add this j x]\n        have hx' : x ∈ Ioo ((J.face i).lower j) ((J.face i).upper j) := hx\n        simp only [Box.splitLower_def hx, Box.splitUpper_def hx, Box.splitLower_def hx',\n          Box.splitUpper_def hx', ← WithBot.some_eq_coe, Option.elim', Box.face_mk,\n          update_of_ne (Fin.succAbove_ne _ _).symm, sub_add_sub_comm,\n          update_comp_eq_of_injective _ (Fin.strictMono_succAbove i).injective j x, ← hf]\n        simp only [Box.face])\n\n"}
