{"name":"MvPolynomial.schwartz_zippel_sup_sum","module":"Mathlib.Algebra.MvPolynomial.SchwartzZippel","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : DecidableEq R\nn : Nat\np : MvPolynomial (Fin n) R\nhp : Ne p 0\nS : Fin n → Finset R\n⊢ LE.le (HDiv.hDiv (↑(Finset.filter (fun x => Eq ((MvPolynomial.eval x) p) 0) (Fintype.piFinset fun i => S i)).card) (Finset.univ.prod fun i => ↑(S i).card)) (p.support.sup fun s => Finset.univ.sum fun i => HDiv.hDiv ↑(s i) ↑(S i).card)","decl":"set_option linter.unusedVariables false in\n/-- The **Schwartz-Zippel lemma**\n\nFor a nonzero multivariable polynomial `p` over an integral domain, the probability that `p`\nevaluates to zero at points drawn at random from a product of finite subsets `S i` of the integral\ndomain is bounded by the supremum of `∑ i, degᵢ s / #(S i)` ranging over monomials `s` of `p`. -/\nlemma schwartz_zippel_sup_sum :\n    ∀ {n} {p : MvPolynomial (Fin n) R} (hp : p ≠ 0) (S : Fin n → Finset R),\n      #{x ∈ S ^^ n | eval x p = 0} / ∏ i, (#(S i) : ℚ≥0) ≤\n        p.support.sup fun s ↦ ∑ i, (s i / #(S i) : ℚ≥0)\n  | 0, p, hp, S => by\n    -- Because `p` is a polynomial over zero variables, it is constant.\n    rw [p.eq_C_of_isEmpty] at *\n    simp [C_ne_zero.mp hp]\n    -- Now, assume that the theorem holds for all polynomials in `n` variables.\n  | n + 1, p, hp, S => by\n    -- We can consider `p` to be a polynomial over multivariable polynomials in one fewer variables.\n    set p' : Polynomial (MvPolynomial (Fin n) R) := finSuccEquiv R n p with hp'\n    -- Since `p` is not identically zero, there is some `k` such that `pₖ` is not identically zero.\n    -- WLOG `k` is the largest such.\n    set k := p'.natDegree with hk\n    set pₖ := p'.leadingCoeff with hpₖ\n    have hp'₀ : p' ≠ 0 := EmbeddingLike.map_ne_zero_iff.2 hp\n    have hpₖ₀ : pₖ ≠ 0 := by simpa [pₖ, k]\n    calc\n      -- We split the set of possible zeros into a union of two cases.\n      #{x ∈ S ^^ (n + 1) | eval x p = 0} / ∏ i, (#(S i) : ℚ≥0)\n          -- In the first case, `pₖ` evaluates to `0`.\n        = #{x ∈ S ^^ (n + 1) | eval x p = 0 ∧ eval (tail x) pₖ = 0} / ∏ i, (#(S i) : ℚ≥0)\n          -- In the second case, `pₖ` does not evaluate to `0`.\n          + #{x ∈ S ^^ (n + 1) | eval x p = 0 ∧ eval (tail x) pₖ ≠ 0} / ∏ i, (#(S i) : ℚ≥0) := by\n        rw [← add_div, ← Nat.cast_add, ← card_union_add_card_inter, filter_union_right,\n          ← filter_and]\n        simp [← and_or_left, em, and_and_and_comm]\n      _ ≤ (pₖ.support.sup fun s ↦ ∑ i, (s i / #(S i.succ) : ℚ≥0)) + p.degreeOf 0 / #(S 0) := ?_\n      _ ≤ p.support.sup fun s ↦ ∑ i, (s i / #(S i) : ℚ≥0) := ?_\n    · gcongr ?_ + ?_\n      · -- We bound the size of the first set by induction\n        calc\n          #{x ∈ S ^^ (n + 1) | eval x p = 0 ∧ eval (tail x) pₖ = 0} / ∏ i, (#(S i) : ℚ≥0)\n            ≤ #{x ∈ S ^^ (n + 1) | eval (tail x) pₖ = 0} / ∏ i, (#(S i) : ℚ≥0) := by\n            gcongr; exact fun x hx ↦ hx.2\n          _ = #(S 0) * #{xₜ ∈ tail S ^^ n | eval xₜ pₖ = 0}\n              / (#(S 0) * (∏ i, #(S (.succ i)) : ℚ≥0)) := by\n            rw [card_consEquiv_filter_piFinset S fun x ↦ eval x pₖ = 0, prod_univ_succ, tail_def]\n            norm_cast\n          _ ≤ #{xₜ ∈ tail S ^^ n | eval xₜ pₖ = 0} / ∏ i, (#(S (.succ i)) : ℚ≥0) :=\n            mul_div_mul_left_le (by positivity)\n          _ ≤ (pₖ.support.sup fun s ↦ ∑ i, (s i / #(S (.succ i)) : ℚ≥0)) :=\n            schwartz_zippel_sup_sum hpₖ₀ _\n      · -- We bound the second set by noting that if `x` is in it, then `x₀` is the root of\n        -- the univariate polynomial`pₓ` obtained by evaluating each (multivariate polynomial)\n        -- coefficient at `xₜ`. Since `pₓ` has degree `k`, there are at most `k` such `x₀` for\n        -- each `xₜ`, which gives the result.\n        calc\n          #{x ∈ S ^^ (n + 1) | eval x p = 0 ∧ eval (tail x) pₖ ≠ 0} / ∏ i, (#(S i) : ℚ≥0)\n            ≤ ↑(p.degreeOf 0 * ∏ i, #(S (.succ i))) / ∏ i, (#(S i) : ℚ≥0) := ?_\n          _ = p.degreeOf 0 * (∏ i, #(S (.succ i))) / (#(S 0) * ∏ i, #(S (.succ i))) := by\n            norm_cast; rw [prod_univ_succ]\n          _ ≤ (p.degreeOf 0 / #(S 0) : ℚ≥0) := mul_div_mul_right_le (by positivity)\n        gcongr\n        calc\n          #{x ∈ S ^^ (n + 1) | eval x p = 0 ∧ eval (tail x) pₖ ≠ 0}\n            = #{x ∈ S ^^ (n + 1) | eval (tail x) pₖ ≠ 0 ∧ eval x p = 0} := by simp_rw [and_comm]\n          _ = #({xₜ ∈ tail S ^^ n | eval xₜ pₖ ≠ 0}.biUnion fun xₜ ↦ image (fun x₀ ↦ (x₀, xₜ))\n                {x₀ ∈ S 0 | eval (cons x₀ xₜ) p = 0}) := by\n            rw [← filter_filter, filter_piFinset_eq_map_consEquiv S (fun r ↦ eval r pₖ ≠ 0),\n              filter_map, card_map, product_eq_biUnion_right, filter_biUnion]\n            simp [Function.comp_def, filter_image, filter_filter]\n            rfl\n          _ ≤ ∑ xₜ ∈ tail S ^^ n with eval xₜ pₖ ≠ 0,\n                #(image (fun x₀ ↦ (x₀, xₜ)) {x₀ ∈ S 0 | eval (cons x₀ xₜ) p = 0}) :=\n            card_biUnion_le\n          _ ≤ ∑ xₜ ∈ tail S ^^ n with eval xₜ pₖ ≠ 0, #{x₀ ∈ S 0 | eval (cons x₀ xₜ) p = 0} := by\n            gcongr; exact card_image_le\n          _ ≤ ∑ xₜ ∈ tail S ^^ n with eval xₜ pₖ ≠ 0, p.degreeOf 0 := ?_\n          _ ≤ ∑ _xₜ ∈ tail S ^^ n, p.degreeOf 0 := by gcongr; exact filter_subset ..\n          _ = p.degreeOf 0 * ∏ i, #(S (.succ i)) := by simp [mul_comm, tail]\n        gcongr with xₜ hxₜ\n        set pₓ := p'.map (eval xₜ) with hpₓ\n        have hpₓdeg : pₓ.natDegree = k := by\n          rw [hpₓ, hk, Polynomial.natDegree_map_of_leadingCoeff_ne_zero _ (mem_filter.1 hxₜ).2]\n        have hpₓ₀ : pₓ ≠ 0 := fun h ↦ (mem_filter.1 hxₜ).2 <| by\n          rw [hpₖ, Polynomial.leadingCoeff, ← hk, ← hpₓdeg, h, Polynomial.natDegree_zero,\n            ← Polynomial.coeff_map, ← hpₓ, h, Polynomial.coeff_zero]\n        calc\n          #{x₀ ∈ S 0 | eval (cons x₀ xₜ) p = 0} ≤ #pₓ.roots.toFinset := by\n            gcongr\n            simp +contextual [subset_iff, eval_eq_eval_mv_eval', pₓ, hpₓ₀, p']\n          _ ≤ Multiset.card pₓ.roots := pₓ.roots.toFinset_card_le\n          _ ≤ pₓ.natDegree := pₓ.card_roots'\n          _ = k := hpₓdeg\n          _ ≤ p.degreeOf 0 := by\n            have :\n              (ofLex (AddMonoidAlgebra.supDegree toLex p'.leadingCoeff)).cons k ∈ p.support := by\n              rwa [← support_coeff_finSuccEquiv, mem_support_iff, ← hp', hk,\n                ← Polynomial.leadingCoeff, ← hpₖ, ← leadingCoeff_toLex,\n                AddMonoidAlgebra.leadingCoeff_ne_zero toLex.injective]\n            simpa using monomial_le_degreeOf 0 this\n    · rw [Finset.sup_add (support_nonempty.mpr hpₖ₀)]\n      apply Finset.sup_le\n      rintro i hi\n      refine le_sup_of_le (mem_support_coeff_finSuccEquiv.mp hi) ?_\n      rw [Fin.sum_univ_succ, add_comm]\n      dsimp\n      gcongr\n      simp [k, natDegree_finSuccEquiv, p']\n\n"}
{"name":"MvPolynomial.schwartz_zippel_sum_degreeOf","module":"Mathlib.Algebra.MvPolynomial.SchwartzZippel","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : DecidableEq R\nn : Nat\np : MvPolynomial (Fin n) R\nhp : Ne p 0\nS : Fin n → Finset R\n⊢ LE.le (HDiv.hDiv (↑(Finset.filter (fun x => Eq ((MvPolynomial.eval x) p) 0) (Fintype.piFinset fun i => S i)).card) (Finset.univ.prod fun i => ↑(S i).card)) (Finset.univ.sum fun i => HDiv.hDiv ↑(MvPolynomial.degreeOf i p) ↑(S i).card)","decl":"/-- The **Schwartz-Zippel lemma**\n\nFor a nonzero multivariable polynomial `p` over an integral domain, the probability that `p`\nevaluates to zero at points drawn at random from a product of finite subsets `S i` of the integral\ndomain is bounded by the sum of `degᵢ p / #(S i)`. -/\nlemma schwartz_zippel_sum_degreeOf {n} {p : MvPolynomial (Fin n) R} (hp : p ≠ 0)\n    (S : Fin n → Finset R) :\n    #{x ∈ S ^^ n | eval x p = 0} / ∏ i, (#(S i) : ℚ≥0) ≤ ∑ i, (p.degreeOf i / #(S i) : ℚ≥0) := by\n  calc\n    _ ≤ p.support.sup fun s ↦ ∑ i, (s i / #(S i) : ℚ≥0) := schwartz_zippel_sup_sum hp S\n    _ ≤ ∑ i, (p.degreeOf i / #(S i) : ℚ≥0) := Finset.sup_le fun s hs ↦ by\n      gcongr with i; exact monomial_le_degreeOf i hs\n\n"}
{"name":"MvPolynomial.schwartz_zippel_totalDegree","module":"Mathlib.Algebra.MvPolynomial.SchwartzZippel","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : DecidableEq R\nn : Nat\np : MvPolynomial (Fin n) R\nhp : Ne p 0\nS : Finset R\n⊢ LE.le (HDiv.hDiv (↑(Finset.filter (fun f => Eq ((MvPolynomial.eval f) p) 0) (Fintype.piFinset fun x => S)).card) (HPow.hPow (↑S.card) n)) (HDiv.hDiv ↑p.totalDegree ↑S.card)","decl":"/-- The **Schwartz-Zippel lemma**\n\nFor a nonzero multivariable polynomial `p` over an integral domain, the probability that `p`\nevaluates to zero at points drawn at random from some finite subset `S` of the integral domain is\nbounded by the degree of `p` over `#S`. This version presents this lemma in terms of `Finset`. -/\nlemma schwartz_zippel_totalDegree {n} {p : MvPolynomial (Fin n) R} (hp : p ≠ 0) (S : Finset R) :\n    #{f ∈ piFinset fun _ ↦ S | eval f p = 0} / (#S ^ n : ℚ≥0) ≤ p.totalDegree / #S :=\n  calc\n    _ = #{f ∈ piFinset fun _ ↦ S | eval f p = 0} / (∏ i : Fin n, #S : ℚ≥0) := by simp\n    _ ≤ p.support.sup fun s ↦ ∑ i, (s i / #S : ℚ≥0) := schwartz_zippel_sup_sum hp _\n    _ = p.totalDegree / #S := by\n      obtain rfl | hs := S.eq_empty_or_nonempty\n      · simp\n        simp only [← _root_.bot_eq_zero, sup_bot]\n      simp_rw [totalDegree, Nat.cast_finsetSup]\n      rw [sup_div₀ (ha := show 0 < (#S : ℚ≥0) by positivity)]\n      simp [← sum_div, Finsupp.sum_fintype]\n\n"}
