{"name":"FiberBundle.mem_baseSet_trivializationAt'","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝³ : TopologicalSpace B\ninst✝² : TopologicalSpace F\nE : B → Type u_5\ninst✝¹ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝ : (b : B) → TopologicalSpace (E b)\nself : FiberBundle F E\nb : B\n⊢ Membership.mem (FiberBundle.trivializationAt' b).baseSet b","decl":"/-- A (topological) fiber bundle with fiber `F` over a base `B` is a space projecting on `B`\nfor which the fibers are all homeomorphic to `F`, such that the local situation around each point\nis a direct product. -/\nclass FiberBundle where\n  totalSpaceMk_isInducing' : ∀ b : B, IsInducing (@TotalSpace.mk B F E b)\n  trivializationAtlas' : Set (Trivialization F (π F E))\n  trivializationAt' : B → Trivialization F (π F E)\n  mem_baseSet_trivializationAt' : ∀ b : B, b ∈ (trivializationAt' b).baseSet\n  trivialization_mem_atlas' : ∀ b : B, trivializationAt' b ∈ trivializationAtlas'\n\n"}
{"name":"FiberBundle.trivialization_mem_atlas'","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝³ : TopologicalSpace B\ninst✝² : TopologicalSpace F\nE : B → Type u_5\ninst✝¹ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝ : (b : B) → TopologicalSpace (E b)\nself : FiberBundle F E\nb : B\n⊢ Membership.mem FiberBundle.trivializationAtlas' (FiberBundle.trivializationAt' b)","decl":"/-- A (topological) fiber bundle with fiber `F` over a base `B` is a space projecting on `B`\nfor which the fibers are all homeomorphic to `F`, such that the local situation around each point\nis a direct product. -/\nclass FiberBundle where\n  totalSpaceMk_isInducing' : ∀ b : B, IsInducing (@TotalSpace.mk B F E b)\n  trivializationAtlas' : Set (Trivialization F (π F E))\n  trivializationAt' : B → Trivialization F (π F E)\n  mem_baseSet_trivializationAt' : ∀ b : B, b ∈ (trivializationAt' b).baseSet\n  trivialization_mem_atlas' : ∀ b : B, trivializationAt' b ∈ trivializationAtlas'\n\n"}
{"name":"FiberBundle.totalSpaceMk_isInducing'","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝³ : TopologicalSpace B\ninst✝² : TopologicalSpace F\nE : B → Type u_5\ninst✝¹ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝ : (b : B) → TopologicalSpace (E b)\nself : FiberBundle F E\nb : B\n⊢ Topology.IsInducing (Bundle.TotalSpace.mk b)","decl":"/-- A (topological) fiber bundle with fiber `F` over a base `B` is a space projecting on `B`\nfor which the fibers are all homeomorphic to `F`, such that the local situation around each point\nis a direct product. -/\nclass FiberBundle where\n  totalSpaceMk_isInducing' : ∀ b : B, IsInducing (@TotalSpace.mk B F E b)\n  trivializationAtlas' : Set (Trivialization F (π F E))\n  trivializationAt' : B → Trivialization F (π F E)\n  mem_baseSet_trivializationAt' : ∀ b : B, b ∈ (trivializationAt' b).baseSet\n  trivialization_mem_atlas' : ∀ b : B, trivializationAt' b ∈ trivializationAtlas'\n\n"}
{"name":"FiberBundle.totalSpaceMk_isInducing","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\nb : B\n⊢ Topology.IsInducing (Bundle.TotalSpace.mk b)","decl":"theorem totalSpaceMk_isInducing : IsInducing (@TotalSpace.mk B F E b) := totalSpaceMk_isInducing' b\n\n"}
{"name":"FiberBundle.totalSpaceMk_inducing","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\nb : B\n⊢ Topology.IsInducing (Bundle.TotalSpace.mk b)","decl":"@[deprecated (since := \"2024-10-28\")] alias totalSpaceMk_inducing := totalSpaceMk_isInducing\n\n"}
{"name":"FiberBundle.mem_baseSet_trivializationAt","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\nb : B\n⊢ Membership.mem (FiberBundle.trivializationAt F E b).baseSet b","decl":"theorem mem_baseSet_trivializationAt : b ∈ (trivializationAt F E b).baseSet :=\n  mem_baseSet_trivializationAt' b\n\n"}
{"name":"FiberBundle.trivialization_mem_atlas","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\nb : B\n⊢ Membership.mem (FiberBundle.trivializationAtlas F E) (FiberBundle.trivializationAt F E b)","decl":"theorem trivialization_mem_atlas : trivializationAt F E b ∈ trivializationAtlas F E :=\n  trivialization_mem_atlas' b\n\n"}
{"name":"MemTrivializationAtlas.out","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\ne : Trivialization F Bundle.TotalSpace.proj\nself : MemTrivializationAtlas e\n⊢ Membership.mem (FiberBundle.trivializationAtlas F E) e","decl":"/-- Given a type `E` equipped with a fiber bundle structure, this is a `Prop` typeclass\nfor trivializations of `E`, expressing that a trivialization is in the designated atlas for the\nbundle.  This is needed because lemmas about the linearity of trivializations or the continuity (as\nfunctions to `F →L[R] F`, where `F` is the model fiber) of the transition functions are only\nexpected to hold for trivializations in the designated atlas. -/\n@[mk_iff]\nclass MemTrivializationAtlas [FiberBundle F E] (e : Trivialization F (π F E)) : Prop where\n  out : e ∈ trivializationAtlas F E\n\n"}
{"name":"memTrivializationAtlas_iff","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\ne : Trivialization F Bundle.TotalSpace.proj\n⊢ Iff (MemTrivializationAtlas e) (Membership.mem (FiberBundle.trivializationAtlas F E) e)","decl":"/-- Given a type `E` equipped with a fiber bundle structure, this is a `Prop` typeclass\nfor trivializations of `E`, expressing that a trivialization is in the designated atlas for the\nbundle.  This is needed because lemmas about the linearity of trivializations or the continuity (as\nfunctions to `F →L[R] F`, where `F` is the model fiber) of the transition functions are only\nexpected to hold for trivializations in the designated atlas. -/\n@[mk_iff]\nclass MemTrivializationAtlas [FiberBundle F E] (e : Trivialization F (π F E)) : Prop where\n  out : e ∈ trivializationAtlas F E\n\n"}
{"name":"instMemTrivializationAtlasTrivializationAt","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\nb : B\n⊢ MemTrivializationAtlas (FiberBundle.trivializationAt F E b)","decl":"instance [FiberBundle F E] (b : B) : MemTrivializationAtlas (trivializationAt F E b) where\n  out := trivialization_mem_atlas F E b\n\n"}
{"name":"FiberBundle.map_proj_nhds","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\nx : Bundle.TotalSpace F E\n⊢ Eq (Filter.map Bundle.TotalSpace.proj (nhds x)) (nhds x.proj)","decl":"theorem map_proj_nhds (x : TotalSpace F E) : map (π F E) (𝓝 x) = 𝓝 x.proj :=\n  (trivializationAt F E x.proj).map_proj_nhds <|\n    (trivializationAt F E x.proj).mem_source.2 <| mem_baseSet_trivializationAt F E x.proj\n\n"}
{"name":"FiberBundle.continuous_proj","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\n⊢ Continuous Bundle.TotalSpace.proj","decl":"/-- The projection from a fiber bundle to its base is continuous. -/\n@[continuity]\ntheorem continuous_proj : Continuous (π F E) :=\n  continuous_iff_continuousAt.2 fun x => (map_proj_nhds F x).le\n\n"}
{"name":"FiberBundle.isOpenMap_proj","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\n⊢ IsOpenMap Bundle.TotalSpace.proj","decl":"/-- The projection from a fiber bundle to its base is an open map. -/\ntheorem isOpenMap_proj : IsOpenMap (π F E) :=\n  IsOpenMap.of_nhds_le fun x => (map_proj_nhds F x).ge\n\n"}
{"name":"FiberBundle.surjective_proj","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : TopologicalSpace F\nE : B → Type u_5\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (b : B) → TopologicalSpace (E b)\ninst✝¹ : FiberBundle F E\ninst✝ : Nonempty F\n⊢ Function.Surjective Bundle.TotalSpace.proj","decl":"/-- The projection from a fiber bundle with a nonempty fiber to its base is a surjective\nmap. -/\ntheorem surjective_proj [Nonempty F] : Function.Surjective (π F E) := fun b =>\n  let ⟨p, _, hpb⟩ :=\n    (trivializationAt F E b).proj_surjOn_baseSet (mem_baseSet_trivializationAt F E b)\n  ⟨p, hpb⟩\n\n"}
{"name":"FiberBundle.isQuotientMap_proj","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : TopologicalSpace F\nE : B → Type u_5\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (b : B) → TopologicalSpace (E b)\ninst✝¹ : FiberBundle F E\ninst✝ : Nonempty F\n⊢ Topology.IsQuotientMap Bundle.TotalSpace.proj","decl":"/-- The projection from a fiber bundle with a nonempty fiber to its base is a quotient\nmap. -/\ntheorem isQuotientMap_proj [Nonempty F] : IsQuotientMap (π F E) :=\n  (isOpenMap_proj F E).isQuotientMap (continuous_proj F E) (surjective_proj F E)\n\n"}
{"name":"FiberBundle.quotientMap_proj","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : TopologicalSpace F\nE : B → Type u_5\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (b : B) → TopologicalSpace (E b)\ninst✝¹ : FiberBundle F E\ninst✝ : Nonempty F\n⊢ Topology.IsQuotientMap Bundle.TotalSpace.proj","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_proj := isQuotientMap_proj\n\n"}
{"name":"FiberBundle.continuous_totalSpaceMk","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\nx : B\n⊢ Continuous (Bundle.TotalSpace.mk x)","decl":"theorem continuous_totalSpaceMk (x : B) : Continuous (@TotalSpace.mk B F E x) :=\n  (totalSpaceMk_isInducing F E x).continuous\n\n"}
{"name":"FiberBundle.totalSpaceMk_isEmbedding","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\nx : B\n⊢ Topology.IsEmbedding (Bundle.TotalSpace.mk x)","decl":"theorem totalSpaceMk_isEmbedding (x : B) : IsEmbedding (@TotalSpace.mk B F E x) :=\n  ⟨totalSpaceMk_isInducing F E x, TotalSpace.mk_injective x⟩\n\n"}
{"name":"FiberBundle.totalSpaceMk_embedding","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\nx : B\n⊢ Topology.IsEmbedding (Bundle.TotalSpace.mk x)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias totalSpaceMk_embedding := totalSpaceMk_isEmbedding\n\n"}
{"name":"FiberBundle.totalSpaceMk_isClosedEmbedding","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : TopologicalSpace F\nE : B → Type u_5\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (b : B) → TopologicalSpace (E b)\ninst✝¹ : FiberBundle F E\ninst✝ : T1Space B\nx : B\n⊢ Topology.IsClosedEmbedding (Bundle.TotalSpace.mk x)","decl":"theorem totalSpaceMk_isClosedEmbedding [T1Space B] (x : B) :\n    IsClosedEmbedding (@TotalSpace.mk B F E x) :=\n  ⟨totalSpaceMk_isEmbedding F E x, by\n    rw [TotalSpace.range_mk]\n    exact isClosed_singleton.preimage <| continuous_proj F E⟩\n\n"}
{"name":"FiberBundle.totalSpaceMk_closedEmbedding","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : TopologicalSpace F\nE : B → Type u_5\ninst✝³ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝² : (b : B) → TopologicalSpace (E b)\ninst✝¹ : FiberBundle F E\ninst✝ : T1Space B\nx : B\n⊢ Topology.IsClosedEmbedding (Bundle.TotalSpace.mk x)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias totalSpaceMk_closedEmbedding := totalSpaceMk_isClosedEmbedding\n\n"}
{"name":"FiberBundle.mem_trivializationAt_proj_source","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\nx : Bundle.TotalSpace F E\n⊢ Membership.mem (FiberBundle.trivializationAt F E x.proj).source x","decl":"@[simp, mfld_simps]\ntheorem mem_trivializationAt_proj_source {x : TotalSpace F E} :\n    x ∈ (trivializationAt F E x.proj).source :=\n  (Trivialization.mem_source _).mpr <| mem_baseSet_trivializationAt F E x.proj\n\n"}
{"name":"FiberBundle.trivializationAt_proj_fst","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\nx : Bundle.TotalSpace F E\n⊢ Eq (↑(FiberBundle.trivializationAt F E x.proj) x).1 x.proj","decl":"theorem trivializationAt_proj_fst {x : TotalSpace F E} :\n    ((trivializationAt F E x.proj) x).1 = x.proj :=\n  Trivialization.coe_fst' _ <| mem_baseSet_trivializationAt F E x.proj\n\n"}
{"name":"FiberBundle.continuousWithinAt_totalSpace","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nX : Type u_4\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\nf : X → Bundle.TotalSpace F E\ns : Set X\nx₀ : X\n⊢ Iff (ContinuousWithinAt f s x₀) (And (ContinuousWithinAt (fun x => (f x).proj) s x₀) (ContinuousWithinAt (fun x => (↑(FiberBundle.trivializationAt F E (f x₀).proj) (f x)).2) s x₀))","decl":"/-- Characterization of continuous functions (at a point, within a set) into a fiber bundle. -/\ntheorem continuousWithinAt_totalSpace (f : X → TotalSpace F E) {s : Set X} {x₀ : X} :\n    ContinuousWithinAt f s x₀ ↔\n      ContinuousWithinAt (fun x => (f x).proj) s x₀ ∧\n        ContinuousWithinAt (fun x => ((trivializationAt F E (f x₀).proj) (f x)).2) s x₀ :=\n  (trivializationAt F E (f x₀).proj).tendsto_nhds_iff mem_trivializationAt_proj_source\n\n"}
{"name":"FiberBundle.continuousAt_totalSpace","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nX : Type u_4\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace B\ninst✝³ : TopologicalSpace F\nE : B → Type u_5\ninst✝² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹ : (b : B) → TopologicalSpace (E b)\ninst✝ : FiberBundle F E\nf : X → Bundle.TotalSpace F E\nx₀ : X\n⊢ Iff (ContinuousAt f x₀) (And (ContinuousAt (fun x => (f x).proj) x₀) (ContinuousAt (fun x => (↑(FiberBundle.trivializationAt F E (f x₀).proj) (f x)).2) x₀))","decl":"/-- Characterization of continuous functions (at a point) into a fiber bundle. -/\ntheorem continuousAt_totalSpace (f : X → TotalSpace F E) {x₀ : X} :\n    ContinuousAt f x₀ ↔\n      ContinuousAt (fun x => (f x).proj) x₀ ∧\n        ContinuousAt (fun x => ((trivializationAt F E (f x₀).proj) (f x)).2) x₀ :=\n  (trivializationAt F E (f x₀).proj).tendsto_nhds_iff mem_trivializationAt_proj_source\n\n"}
{"name":"FiberBundle.exists_trivialization_Icc_subset","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\ninst✝⁶ : TopologicalSpace B\ninst✝⁵ : TopologicalSpace F\nE : B → Type u_5\ninst✝⁴ : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝³ : (b : B) → TopologicalSpace (E b)\ninst✝² : ConditionallyCompleteLinearOrder B\ninst✝¹ : OrderTopology B\ninst✝ : FiberBundle F E\na b : B\n⊢ Exists fun e => HasSubset.Subset (Set.Icc a b) e.baseSet","decl":"/-- If `E` is a fiber bundle over a conditionally complete linear order,\nthen it is trivial over any closed interval. -/\ntheorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]\n    [OrderTopology B] [FiberBundle F E] (a b : B) :\n    ∃ e : Trivialization F (π F E), Icc a b ⊆ e.baseSet := by\n  obtain ⟨ea, hea⟩ : ∃ ea : Trivialization F (π F E), a ∈ ea.baseSet :=\n    ⟨trivializationAt F E a, mem_baseSet_trivializationAt F E a⟩\n  -- If `a < b`, then `[a, b] = ∅`, and the statement is trivial\n  cases' lt_or_le b a with hab hab\n  · exact ⟨ea, by simp [*]⟩\n  /- Let `s` be the set of points `x ∈ [a, b]` such that `E` is trivializable over `[a, x]`.\n    We need to show that `b ∈ s`. Let `c = Sup s`. We will show that `c ∈ s` and `c = b`. -/\n  set s : Set B := { x ∈ Icc a b | ∃ e : Trivialization F (π F E), Icc a x ⊆ e.baseSet }\n  have ha : a ∈ s := ⟨left_mem_Icc.2 hab, ea, by simp [hea]⟩\n  have sne : s.Nonempty := ⟨a, ha⟩\n  have hsb : b ∈ upperBounds s := fun x hx => hx.1.2\n  have sbd : BddAbove s := ⟨b, hsb⟩\n  set c := sSup s\n  have hsc : IsLUB s c := isLUB_csSup sne sbd\n  have hc : c ∈ Icc a b := ⟨hsc.1 ha, hsc.2 hsb⟩\n  obtain ⟨-, ec : Trivialization F (π F E), hec : Icc a c ⊆ ec.baseSet⟩ : c ∈ s := by\n    rcases hc.1.eq_or_lt with heq | hlt\n    · rwa [← heq]\n    refine ⟨hc, ?_⟩\n    /- In order to show that `c ∈ s`, consider a trivialization `ec` of `proj` over a neighborhood\n      of `c`. Its base set includes `(c', c]` for some `c' ∈ [a, c)`. -/\n    obtain ⟨ec, hc⟩ : ∃ ec : Trivialization F (π F E), c ∈ ec.baseSet :=\n      ⟨trivializationAt F E c, mem_baseSet_trivializationAt F E c⟩\n    obtain ⟨c', hc', hc'e⟩ : ∃ c' ∈ Ico a c, Ioc c' c ⊆ ec.baseSet :=\n      (mem_nhdsLE_iff_exists_mem_Ico_Ioc_subset hlt).1\n        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)\n    /- Since `c' < c = Sup s`, there exists `d ∈ s ∩ (c', c]`. Let `ead` be a trivialization of\n      `proj` over `[a, d]`. Then we can glue `ead` and `ec` into a trivialization over `[a, c]`. -/\n    obtain ⟨d, ⟨hdab, ead, had⟩, hd⟩ : ∃ d ∈ s, d ∈ Ioc c' c := hsc.exists_between hc'.2\n    refine ⟨ead.piecewiseLe ec d (had ⟨hdab.1, le_rfl⟩) (hc'e hd), subset_ite.2 ?_⟩\n    exact ⟨fun x hx => had ⟨hx.1.1, hx.2⟩, fun x hx => hc'e ⟨hd.1.trans (not_le.1 hx.2), hx.1.2⟩⟩\n  /- So, `c ∈ s`. Let `ec` be a trivialization of `proj` over `[a, c]`.  If `c = b`, then we are\n    done. Otherwise we show that `proj` can be trivialized over a larger interval `[a, d]`,\n    `d ∈ (c, b]`, hence `c` is not an upper bound of `s`. -/\n  rcases hc.2.eq_or_lt with heq | hlt\n  · exact ⟨ec, heq ▸ hec⟩\n  rsuffices ⟨d, hdcb, hd⟩ : ∃ d ∈ Ioc c b, ∃ e : Trivialization F (π F E), Icc a d ⊆ e.baseSet\n  · exact ((hsc.1 ⟨⟨hc.1.trans hdcb.1.le, hdcb.2⟩, hd⟩).not_lt hdcb.1).elim\n  /- Since the base set of `ec` is open, it includes `[c, d)` (hence, `[a, d)`) for some\n    `d ∈ (c, b]`. -/\n  obtain ⟨d, hdcb, hd⟩ : ∃ d ∈ Ioc c b, Ico c d ⊆ ec.baseSet :=\n    (mem_nhdsGE_iff_exists_mem_Ioc_Ico_subset hlt).1\n      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ⟨hc.1, le_rfl⟩))\n  have had : Ico a d ⊆ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)\n  by_cases he : Disjoint (Iio d) (Ioi c)\n  · /- If `(c, d) = ∅`, then let `ed` be a trivialization of `proj` over a neighborhood of `d`.\n      Then the disjoint union of `ec` restricted to `(-∞, d)` and `ed` restricted to `(c, ∞)` is\n      a trivialization over `[a, d]`. -/\n    obtain ⟨ed, hed⟩ : ∃ ed : Trivialization F (π F E), d ∈ ed.baseSet :=\n      ⟨trivializationAt F E d, mem_baseSet_trivializationAt F E d⟩\n    refine ⟨d, hdcb,\n      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)\n        (he.mono inter_subset_right inter_subset_right), fun x hx => ?_⟩\n    rcases hx.2.eq_or_lt with (rfl | hxd)\n    exacts [Or.inr ⟨hed, hdcb.1⟩, Or.inl ⟨had ⟨hx.1, hxd⟩, hxd⟩]\n  · /- If `(c, d)` is nonempty, then take `d' ∈ (c, d)`. Since the base set of `ec` includes\n          `[a, d)`, it includes `[a, d'] ⊆ [a, d)` as well. -/\n    rw [disjoint_left] at he\n    push_neg at he\n    rcases he with ⟨d', hdd' : d' < d, hd'c⟩\n    exact ⟨d', ⟨hd'c, hdd'.le.trans hdcb.2⟩, ec, (Icc_subset_Ico_right hdd').trans had⟩\n\n"}
{"name":"FiberBundleCore.isOpen_baseSet","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_5\nB : Type u_6\ninst✝¹ : TopologicalSpace B\nF : Type u_7\ninst✝ : TopologicalSpace F\nself : FiberBundleCore ι B F\ni : ι\n⊢ IsOpen (self.baseSet i)","decl":"/-- Core data defining a locally trivial bundle with fiber `F` over a topological\nspace `B`. Note that \"bundle\" is used in its mathematical sense. This is the (computer science)\nbundled version, i.e., all the relevant data is contained in the following structure. A family of\nlocal trivializations is indexed by a type `ι`, on open subsets `baseSet i` for each `i : ι`.\nTrivialization changes from `i` to `j` are given by continuous maps `coordChange i j` from\n`baseSet i ∩ baseSet j` to the set of homeomorphisms of `F`, but we express them as maps\n`B → F → F` and require continuity on `(baseSet i ∩ baseSet j) × F` to avoid the topology on the\nspace of continuous maps on `F`. -/\nstructure FiberBundleCore (ι : Type*) (B : Type*) [TopologicalSpace B] (F : Type*)\n    [TopologicalSpace F] where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F → F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j,\n    ContinuousOn (fun p : B × F => coordChange i j p.1 p.2) ((baseSet i ∩ baseSet j) ×ˢ univ)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"FiberBundleCore.coordChange_self","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_5\nB : Type u_6\ninst✝¹ : TopologicalSpace B\nF : Type u_7\ninst✝ : TopologicalSpace F\nself : FiberBundleCore ι B F\ni : ι\nx : B\na✝ : Membership.mem (self.baseSet i) x\nv : F\n⊢ Eq (self.coordChange i i x v) v","decl":"/-- Core data defining a locally trivial bundle with fiber `F` over a topological\nspace `B`. Note that \"bundle\" is used in its mathematical sense. This is the (computer science)\nbundled version, i.e., all the relevant data is contained in the following structure. A family of\nlocal trivializations is indexed by a type `ι`, on open subsets `baseSet i` for each `i : ι`.\nTrivialization changes from `i` to `j` are given by continuous maps `coordChange i j` from\n`baseSet i ∩ baseSet j` to the set of homeomorphisms of `F`, but we express them as maps\n`B → F → F` and require continuity on `(baseSet i ∩ baseSet j) × F` to avoid the topology on the\nspace of continuous maps on `F`. -/\nstructure FiberBundleCore (ι : Type*) (B : Type*) [TopologicalSpace B] (F : Type*)\n    [TopologicalSpace F] where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F → F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j,\n    ContinuousOn (fun p : B × F => coordChange i j p.1 p.2) ((baseSet i ∩ baseSet j) ×ˢ univ)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"FiberBundleCore.mk.sizeOf_spec","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_5\nB : Type u_6\ninst✝⁴ : TopologicalSpace B\nF : Type u_7\ninst✝³ : TopologicalSpace F\ninst✝² : SizeOf ι\ninst✝¹ : SizeOf B\ninst✝ : SizeOf F\nbaseSet : ι → Set B\nisOpen_baseSet : ∀ (i : ι), IsOpen (baseSet i)\nindexAt : B → ι\nmem_baseSet_at : ∀ (x : B), Membership.mem (baseSet (indexAt x)) x\ncoordChange : ι → ι → B → F → F\ncoordChange_self : ∀ (i : ι) (x : B), Membership.mem (baseSet i) x → ∀ (v : F), Eq (coordChange i i x v) v\ncontinuousOn_coordChange : ∀ (i j : ι), ContinuousOn (fun p => coordChange i j p.1 p.2) (SProd.sprod (Inter.inter (baseSet i) (baseSet j)) Set.univ)\ncoordChange_comp : ∀ (i j k : ι) (x : B), Membership.mem (Inter.inter (Inter.inter (baseSet i) (baseSet j)) (baseSet k)) x → ∀ (v : F), Eq (coordChange j k x (coordChange i j x v)) (coordChange i k x v)\n⊢ Eq (SizeOf.sizeOf { baseSet := baseSet, isOpen_baseSet := isOpen_baseSet, indexAt := indexAt, mem_baseSet_at := mem_baseSet_at, coordChange := coordChange, coordChange_self := coordChange_self, continuousOn_coordChange := continuousOn_coordChange, coordChange_comp := coordChange_comp }) 1","decl":"/-- Core data defining a locally trivial bundle with fiber `F` over a topological\nspace `B`. Note that \"bundle\" is used in its mathematical sense. This is the (computer science)\nbundled version, i.e., all the relevant data is contained in the following structure. A family of\nlocal trivializations is indexed by a type `ι`, on open subsets `baseSet i` for each `i : ι`.\nTrivialization changes from `i` to `j` are given by continuous maps `coordChange i j` from\n`baseSet i ∩ baseSet j` to the set of homeomorphisms of `F`, but we express them as maps\n`B → F → F` and require continuity on `(baseSet i ∩ baseSet j) × F` to avoid the topology on the\nspace of continuous maps on `F`. -/\nstructure FiberBundleCore (ι : Type*) (B : Type*) [TopologicalSpace B] (F : Type*)\n    [TopologicalSpace F] where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F → F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j,\n    ContinuousOn (fun p : B × F => coordChange i j p.1 p.2) ((baseSet i ∩ baseSet j) ×ˢ univ)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"FiberBundleCore.mem_baseSet_at","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_5\nB : Type u_6\ninst✝¹ : TopologicalSpace B\nF : Type u_7\ninst✝ : TopologicalSpace F\nself : FiberBundleCore ι B F\nx : B\n⊢ Membership.mem (self.baseSet (self.indexAt x)) x","decl":"/-- Core data defining a locally trivial bundle with fiber `F` over a topological\nspace `B`. Note that \"bundle\" is used in its mathematical sense. This is the (computer science)\nbundled version, i.e., all the relevant data is contained in the following structure. A family of\nlocal trivializations is indexed by a type `ι`, on open subsets `baseSet i` for each `i : ι`.\nTrivialization changes from `i` to `j` are given by continuous maps `coordChange i j` from\n`baseSet i ∩ baseSet j` to the set of homeomorphisms of `F`, but we express them as maps\n`B → F → F` and require continuity on `(baseSet i ∩ baseSet j) × F` to avoid the topology on the\nspace of continuous maps on `F`. -/\nstructure FiberBundleCore (ι : Type*) (B : Type*) [TopologicalSpace B] (F : Type*)\n    [TopologicalSpace F] where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F → F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j,\n    ContinuousOn (fun p : B × F => coordChange i j p.1 p.2) ((baseSet i ∩ baseSet j) ×ˢ univ)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"FiberBundleCore.continuousOn_coordChange","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_5\nB : Type u_6\ninst✝¹ : TopologicalSpace B\nF : Type u_7\ninst✝ : TopologicalSpace F\nself : FiberBundleCore ι B F\ni j : ι\n⊢ ContinuousOn (fun p => self.coordChange i j p.1 p.2) (SProd.sprod (Inter.inter (self.baseSet i) (self.baseSet j)) Set.univ)","decl":"/-- Core data defining a locally trivial bundle with fiber `F` over a topological\nspace `B`. Note that \"bundle\" is used in its mathematical sense. This is the (computer science)\nbundled version, i.e., all the relevant data is contained in the following structure. A family of\nlocal trivializations is indexed by a type `ι`, on open subsets `baseSet i` for each `i : ι`.\nTrivialization changes from `i` to `j` are given by continuous maps `coordChange i j` from\n`baseSet i ∩ baseSet j` to the set of homeomorphisms of `F`, but we express them as maps\n`B → F → F` and require continuity on `(baseSet i ∩ baseSet j) × F` to avoid the topology on the\nspace of continuous maps on `F`. -/\nstructure FiberBundleCore (ι : Type*) (B : Type*) [TopologicalSpace B] (F : Type*)\n    [TopologicalSpace F] where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F → F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j,\n    ContinuousOn (fun p : B × F => coordChange i j p.1 p.2) ((baseSet i ∩ baseSet j) ×ˢ univ)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"FiberBundleCore.mk.injEq","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_5\nB : Type u_6\ninst✝¹ : TopologicalSpace B\nF : Type u_7\ninst✝ : TopologicalSpace F\nbaseSet✝ : ι → Set B\nisOpen_baseSet✝ : ∀ (i : ι), IsOpen (baseSet✝ i)\nindexAt✝ : B → ι\nmem_baseSet_at✝ : ∀ (x : B), Membership.mem (baseSet✝ (indexAt✝ x)) x\ncoordChange✝ : ι → ι → B → F → F\ncoordChange_self✝ : ∀ (i : ι) (x : B), Membership.mem (baseSet✝ i) x → ∀ (v : F), Eq (coordChange✝ i i x v) v\ncontinuousOn_coordChange✝ : ∀ (i j : ι), ContinuousOn (fun p => coordChange✝ i j p.1 p.2) (SProd.sprod (Inter.inter (baseSet✝ i) (baseSet✝ j)) Set.univ)\ncoordChange_comp✝ : ∀ (i j k : ι) (x : B), Membership.mem (Inter.inter (Inter.inter (baseSet✝ i) (baseSet✝ j)) (baseSet✝ k)) x → ∀ (v : F), Eq (coordChange✝ j k x (coordChange✝ i j x v)) (coordChange✝ i k x v)\nbaseSet : ι → Set B\nisOpen_baseSet : ∀ (i : ι), IsOpen (baseSet i)\nindexAt : B → ι\nmem_baseSet_at : ∀ (x : B), Membership.mem (baseSet (indexAt x)) x\ncoordChange : ι → ι → B → F → F\ncoordChange_self : ∀ (i : ι) (x : B), Membership.mem (baseSet i) x → ∀ (v : F), Eq (coordChange i i x v) v\ncontinuousOn_coordChange : ∀ (i j : ι), ContinuousOn (fun p => coordChange i j p.1 p.2) (SProd.sprod (Inter.inter (baseSet i) (baseSet j)) Set.univ)\ncoordChange_comp : ∀ (i j k : ι) (x : B), Membership.mem (Inter.inter (Inter.inter (baseSet i) (baseSet j)) (baseSet k)) x → ∀ (v : F), Eq (coordChange j k x (coordChange i j x v)) (coordChange i k x v)\n⊢ Eq (Eq { baseSet := baseSet✝, isOpen_baseSet := isOpen_baseSet✝, indexAt := indexAt✝, mem_baseSet_at := mem_baseSet_at✝, coordChange := coordChange✝, coordChange_self := coordChange_self✝, continuousOn_coordChange := continuousOn_coordChange✝, coordChange_comp := coordChange_comp✝ } { baseSet := baseSet, isOpen_baseSet := isOpen_baseSet, indexAt := indexAt, mem_baseSet_at := mem_baseSet_at, coordChange := coordChange, coordChange_self := coordChange_self, continuousOn_coordChange := continuousOn_coordChange, coordChange_comp := coordChange_comp }) (And (Eq baseSet✝ baseSet) (And (Eq indexAt✝ indexAt) (Eq coordChange✝ coordChange)))","decl":"/-- Core data defining a locally trivial bundle with fiber `F` over a topological\nspace `B`. Note that \"bundle\" is used in its mathematical sense. This is the (computer science)\nbundled version, i.e., all the relevant data is contained in the following structure. A family of\nlocal trivializations is indexed by a type `ι`, on open subsets `baseSet i` for each `i : ι`.\nTrivialization changes from `i` to `j` are given by continuous maps `coordChange i j` from\n`baseSet i ∩ baseSet j` to the set of homeomorphisms of `F`, but we express them as maps\n`B → F → F` and require continuity on `(baseSet i ∩ baseSet j) × F` to avoid the topology on the\nspace of continuous maps on `F`. -/\nstructure FiberBundleCore (ι : Type*) (B : Type*) [TopologicalSpace B] (F : Type*)\n    [TopologicalSpace F] where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F → F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j,\n    ContinuousOn (fun p : B × F => coordChange i j p.1 p.2) ((baseSet i ∩ baseSet j) ×ˢ univ)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"FiberBundleCore.coordChange_comp","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_5\nB : Type u_6\ninst✝¹ : TopologicalSpace B\nF : Type u_7\ninst✝ : TopologicalSpace F\nself : FiberBundleCore ι B F\ni j k : ι\nx : B\na✝ : Membership.mem (Inter.inter (Inter.inter (self.baseSet i) (self.baseSet j)) (self.baseSet k)) x\nv : F\n⊢ Eq (self.coordChange j k x (self.coordChange i j x v)) (self.coordChange i k x v)","decl":"/-- Core data defining a locally trivial bundle with fiber `F` over a topological\nspace `B`. Note that \"bundle\" is used in its mathematical sense. This is the (computer science)\nbundled version, i.e., all the relevant data is contained in the following structure. A family of\nlocal trivializations is indexed by a type `ι`, on open subsets `baseSet i` for each `i : ι`.\nTrivialization changes from `i` to `j` are given by continuous maps `coordChange i j` from\n`baseSet i ∩ baseSet j` to the set of homeomorphisms of `F`, but we express them as maps\n`B → F → F` and require continuity on `(baseSet i ∩ baseSet j) × F` to avoid the topology on the\nspace of continuous maps on `F`. -/\nstructure FiberBundleCore (ι : Type*) (B : Type*) [TopologicalSpace B] (F : Type*)\n    [TopologicalSpace F] where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F → F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j,\n    ContinuousOn (fun p : B × F => coordChange i j p.1 p.2) ((baseSet i ∩ baseSet j) ×ˢ univ)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"FiberBundleCore.mk.inj","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_5\nB : Type u_6\ninst✝¹ : TopologicalSpace B\nF : Type u_7\ninst✝ : TopologicalSpace F\nbaseSet✝ : ι → Set B\nisOpen_baseSet✝ : ∀ (i : ι), IsOpen (baseSet✝ i)\nindexAt✝ : B → ι\nmem_baseSet_at✝ : ∀ (x : B), Membership.mem (baseSet✝ (indexAt✝ x)) x\ncoordChange✝ : ι → ι → B → F → F\ncoordChange_self✝ : ∀ (i : ι) (x : B), Membership.mem (baseSet✝ i) x → ∀ (v : F), Eq (coordChange✝ i i x v) v\ncontinuousOn_coordChange✝ : ∀ (i j : ι), ContinuousOn (fun p => coordChange✝ i j p.1 p.2) (SProd.sprod (Inter.inter (baseSet✝ i) (baseSet✝ j)) Set.univ)\ncoordChange_comp✝ : ∀ (i j k : ι) (x : B), Membership.mem (Inter.inter (Inter.inter (baseSet✝ i) (baseSet✝ j)) (baseSet✝ k)) x → ∀ (v : F), Eq (coordChange✝ j k x (coordChange✝ i j x v)) (coordChange✝ i k x v)\nbaseSet : ι → Set B\nisOpen_baseSet : ∀ (i : ι), IsOpen (baseSet i)\nindexAt : B → ι\nmem_baseSet_at : ∀ (x : B), Membership.mem (baseSet (indexAt x)) x\ncoordChange : ι → ι → B → F → F\ncoordChange_self : ∀ (i : ι) (x : B), Membership.mem (baseSet i) x → ∀ (v : F), Eq (coordChange i i x v) v\ncontinuousOn_coordChange : ∀ (i j : ι), ContinuousOn (fun p => coordChange i j p.1 p.2) (SProd.sprod (Inter.inter (baseSet i) (baseSet j)) Set.univ)\ncoordChange_comp : ∀ (i j k : ι) (x : B), Membership.mem (Inter.inter (Inter.inter (baseSet i) (baseSet j)) (baseSet k)) x → ∀ (v : F), Eq (coordChange j k x (coordChange i j x v)) (coordChange i k x v)\nx✝ : Eq { baseSet := baseSet✝, isOpen_baseSet := isOpen_baseSet✝, indexAt := indexAt✝, mem_baseSet_at := mem_baseSet_at✝, coordChange := coordChange✝, coordChange_self := coordChange_self✝, continuousOn_coordChange := continuousOn_coordChange✝, coordChange_comp := coordChange_comp✝ } { baseSet := baseSet, isOpen_baseSet := isOpen_baseSet, indexAt := indexAt, mem_baseSet_at := mem_baseSet_at, coordChange := coordChange, coordChange_self := coordChange_self, continuousOn_coordChange := continuousOn_coordChange, coordChange_comp := coordChange_comp }\n⊢ And (Eq baseSet✝ baseSet) (And (Eq indexAt✝ indexAt) (Eq coordChange✝ coordChange))","decl":"/-- Core data defining a locally trivial bundle with fiber `F` over a topological\nspace `B`. Note that \"bundle\" is used in its mathematical sense. This is the (computer science)\nbundled version, i.e., all the relevant data is contained in the following structure. A family of\nlocal trivializations is indexed by a type `ι`, on open subsets `baseSet i` for each `i : ι`.\nTrivialization changes from `i` to `j` are given by continuous maps `coordChange i j` from\n`baseSet i ∩ baseSet j` to the set of homeomorphisms of `F`, but we express them as maps\n`B → F → F` and require continuity on `(baseSet i ∩ baseSet j) × F` to avoid the topology on the\nspace of continuous maps on `F`. -/\nstructure FiberBundleCore (ι : Type*) (B : Type*) [TopologicalSpace B] (F : Type*)\n    [TopologicalSpace F] where\n  baseSet : ι → Set B\n  isOpen_baseSet : ∀ i, IsOpen (baseSet i)\n  indexAt : B → ι\n  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)\n  coordChange : ι → ι → B → F → F\n  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v\n  continuousOn_coordChange : ∀ i j,\n    ContinuousOn (fun p : B × F => coordChange i j p.1 p.2) ((baseSet i ∩ baseSet j) ×ˢ univ)\n  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,\n    (coordChange j k x) (coordChange i j x v) = coordChange i k x v\n\n"}
{"name":"FiberBundleCore.mem_trivChange_source","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni j : ι\np : Prod B F\n⊢ Iff (Membership.mem (Z.trivChange i j).source p) (Membership.mem (Inter.inter (Z.baseSet i) (Z.baseSet j)) p.1)","decl":"@[simp, mfld_simps]\ntheorem mem_trivChange_source (i j : ι) (p : B × F) :\n    p ∈ (Z.trivChange i j).source ↔ p.1 ∈ Z.baseSet i ∩ Z.baseSet j := by\n  erw [mem_prod]\n  simp\n\n"}
{"name":"FiberBundleCore.mem_localTrivAsPartialEquiv_source","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni : ι\np : Z.TotalSpace\n⊢ Iff (Membership.mem (Z.localTrivAsPartialEquiv i).source p) (Membership.mem (Z.baseSet i) p.proj)","decl":"theorem mem_localTrivAsPartialEquiv_source (p : Z.TotalSpace) :\n    p ∈ (Z.localTrivAsPartialEquiv i).source ↔ p.1 ∈ Z.baseSet i :=\n  Iff.rfl\n\n"}
{"name":"FiberBundleCore.mem_localTrivAsPartialEquiv_target","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni : ι\np : Prod B F\n⊢ Iff (Membership.mem (Z.localTrivAsPartialEquiv i).target p) (Membership.mem (Z.baseSet i) p.1)","decl":"theorem mem_localTrivAsPartialEquiv_target (p : B × F) :\n    p ∈ (Z.localTrivAsPartialEquiv i).target ↔ p.1 ∈ Z.baseSet i := by\n  erw [mem_prod]\n  simp only [and_true, mem_univ]\n\n"}
{"name":"FiberBundleCore.localTrivAsPartialEquiv_apply","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni : ι\np : Z.TotalSpace\n⊢ Eq (↑(Z.localTrivAsPartialEquiv i) p) { fst := p.proj, snd := Z.coordChange (Z.indexAt p.proj) i p.proj p.snd }","decl":"theorem localTrivAsPartialEquiv_apply (p : Z.TotalSpace) :\n    (Z.localTrivAsPartialEquiv i) p = ⟨p.1, Z.coordChange (Z.indexAt p.1) i p.1 p.2⟩ :=\n  rfl\n\n"}
{"name":"FiberBundleCore.localTrivAsPartialEquiv_trans","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni j : ι\n⊢ HasEquiv.Equiv ((Z.localTrivAsPartialEquiv i).symm.trans (Z.localTrivAsPartialEquiv j)) (Z.trivChange i j).toPartialEquiv","decl":"/-- The composition of two local trivializations is the trivialization change Z.triv_change i j. -/\ntheorem localTrivAsPartialEquiv_trans (i j : ι) :\n    (Z.localTrivAsPartialEquiv i).symm.trans (Z.localTrivAsPartialEquiv j) ≈\n      (Z.trivChange i j).toPartialEquiv := by\n  constructor\n  · ext x\n    simp only [mem_localTrivAsPartialEquiv_target, mfld_simps]\n    rfl\n  · rintro ⟨x, v⟩ hx\n    simp only [trivChange, localTrivAsPartialEquiv, PartialEquiv.symm,\n      Prod.mk.inj_iff, prod_mk_mem_set_prod_eq, PartialEquiv.trans_source, mem_inter_iff,\n      mem_preimage, proj, mem_univ, eq_self_iff_true, (· ∘ ·),\n      PartialEquiv.coe_trans, TotalSpace.proj] at hx ⊢\n    simp only [Z.coordChange_comp, hx, mem_inter_iff, and_self_iff, mem_baseSet_at]\n\n"}
{"name":"FiberBundleCore.open_source'","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni : ι\n⊢ IsOpen (Z.localTrivAsPartialEquiv i).source","decl":"theorem open_source' (i : ι) : IsOpen (Z.localTrivAsPartialEquiv i).source := by\n  apply TopologicalSpace.GenerateOpen.basic\n  simp only [exists_prop, mem_iUnion, mem_singleton_iff]\n  refine ⟨i, Z.baseSet i ×ˢ univ, (Z.isOpen_baseSet i).prod isOpen_univ, ?_⟩\n  ext p\n  simp only [localTrivAsPartialEquiv_apply, prod_mk_mem_set_prod_eq, mem_inter_iff, and_self_iff,\n    mem_localTrivAsPartialEquiv_source, and_true, mem_univ, mem_preimage]\n\n"}
{"name":"FiberBundleCore.localTrivAt_def","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\nb : B\n⊢ Eq (Z.localTriv (Z.indexAt b)) (Z.localTrivAt b)","decl":"@[simp, mfld_simps]\ntheorem localTrivAt_def (b : B) : Z.localTriv (Z.indexAt b) = Z.localTrivAt b :=\n  rfl\n\n"}
{"name":"FiberBundleCore.localTrivAt_snd","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\nb : B\np : Bundle.TotalSpace F Z.Fiber\n⊢ Eq (↑(Z.localTrivAt b) p).2 (Z.coordChange (Z.indexAt p.proj) (Z.indexAt b) p.proj p.snd)","decl":"theorem localTrivAt_snd (b : B) (p) :\n    (Z.localTrivAt b p).2 = Z.coordChange (Z.indexAt p.1) (Z.indexAt b) p.1 p.2 :=\n  rfl\n\n"}
{"name":"FiberBundleCore.continuous_const_section","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\nv : F\nh : ∀ (i j : ι) (x : B), Membership.mem (Inter.inter (Z.baseSet i) (Z.baseSet j)) x → Eq (Z.coordChange i j x v) v\n⊢ Continuous (letFun (fun x => { proj := x, snd := v }) fun this => this)","decl":"/-- If an element of `F` is invariant under all coordinate changes, then one can define a\ncorresponding section of the fiber bundle, which is continuous. This applies in particular to the\nzero section of a vector bundle. Another example (not yet defined) would be the identity\nsection of the endomorphism bundle of a vector bundle. -/\ntheorem continuous_const_section (v : F)\n    (h : ∀ i j, ∀ x ∈ Z.baseSet i ∩ Z.baseSet j, Z.coordChange i j x v = v) :\n    Continuous (show B → Z.TotalSpace from fun x => ⟨x, v⟩) := by\n  refine continuous_iff_continuousAt.2 fun x => ?_\n  have A : Z.baseSet (Z.indexAt x) ∈ 𝓝 x :=\n    IsOpen.mem_nhds (Z.isOpen_baseSet (Z.indexAt x)) (Z.mem_baseSet_at x)\n  refine ((Z.localTrivAt x).toPartialHomeomorph.continuousAt_iff_continuousAt_comp_left ?_).2 ?_\n  · exact A\n  · apply continuousAt_id.prod\n    simp only [(· ∘ ·), mfld_simps, localTrivAt_snd]\n    have : ContinuousOn (fun _ : B => v) (Z.baseSet (Z.indexAt x)) := continuousOn_const\n    refine (this.congr fun y hy ↦ ?_).continuousAt A\n    exact h _ _ _ ⟨mem_baseSet_at _ _, hy⟩\n\n"}
{"name":"FiberBundleCore.localTrivAsPartialEquiv_coe","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni : ι\n⊢ Eq ↑(Z.localTrivAsPartialEquiv i) ↑(Z.localTriv i)","decl":"@[simp, mfld_simps]\ntheorem localTrivAsPartialEquiv_coe : ⇑(Z.localTrivAsPartialEquiv i) = Z.localTriv i :=\n  rfl\n\n"}
{"name":"FiberBundleCore.localTrivAsPartialEquiv_source","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni : ι\n⊢ Eq (Z.localTrivAsPartialEquiv i).source (Z.localTriv i).source","decl":"@[simp, mfld_simps]\ntheorem localTrivAsPartialEquiv_source :\n    (Z.localTrivAsPartialEquiv i).source = (Z.localTriv i).source :=\n  rfl\n\n"}
{"name":"FiberBundleCore.localTrivAsPartialEquiv_target","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni : ι\n⊢ Eq (Z.localTrivAsPartialEquiv i).target (Z.localTriv i).target","decl":"@[simp, mfld_simps]\ntheorem localTrivAsPartialEquiv_target :\n    (Z.localTrivAsPartialEquiv i).target = (Z.localTriv i).target :=\n  rfl\n\n"}
{"name":"FiberBundleCore.localTrivAsPartialEquiv_symm","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni : ι\n⊢ Eq (Z.localTrivAsPartialEquiv i).symm (Z.localTriv i).symm","decl":"@[simp, mfld_simps]\ntheorem localTrivAsPartialEquiv_symm :\n    (Z.localTrivAsPartialEquiv i).symm = (Z.localTriv i).toPartialEquiv.symm :=\n  rfl\n\n"}
{"name":"FiberBundleCore.baseSet_at","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni : ι\n⊢ Eq (Z.baseSet i) (Z.localTriv i).baseSet","decl":"@[simp, mfld_simps]\ntheorem baseSet_at : Z.baseSet i = (Z.localTriv i).baseSet :=\n  rfl\n\n"}
{"name":"FiberBundleCore.localTriv_apply","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni : ι\np : Z.TotalSpace\n⊢ Eq (↑(Z.localTriv i) p) { fst := p.proj, snd := Z.coordChange (Z.indexAt p.proj) i p.proj p.snd }","decl":"@[simp, mfld_simps]\ntheorem localTriv_apply (p : Z.TotalSpace) :\n    (Z.localTriv i) p = ⟨p.1, Z.coordChange (Z.indexAt p.1) i p.1 p.2⟩ :=\n  rfl\n\n"}
{"name":"FiberBundleCore.localTrivAt_apply","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\np : Z.TotalSpace\n⊢ Eq (↑(Z.localTrivAt p.proj) p) { fst := p.proj, snd := p.snd }","decl":"@[simp, mfld_simps]\ntheorem localTrivAt_apply (p : Z.TotalSpace) : (Z.localTrivAt p.1) p = ⟨p.1, p.2⟩ := by\n  rw [localTrivAt, localTriv_apply, coordChange_self]\n  exact Z.mem_baseSet_at p.1\n\n"}
{"name":"FiberBundleCore.localTrivAt_apply_mk","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\nb : B\na : F\n⊢ Eq (↑(Z.localTrivAt b) { proj := b, snd := a }) { fst := b, snd := a }","decl":"@[simp, mfld_simps]\ntheorem localTrivAt_apply_mk (b : B) (a : F) : (Z.localTrivAt b) ⟨b, a⟩ = ⟨b, a⟩ :=\n  Z.localTrivAt_apply _\n\n"}
{"name":"FiberBundleCore.mem_localTriv_source","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni : ι\np : Z.TotalSpace\n⊢ Iff (Membership.mem (Z.localTriv i).source p) (Membership.mem (Z.localTriv i).baseSet p.proj)","decl":"@[simp, mfld_simps]\ntheorem mem_localTriv_source (p : Z.TotalSpace) :\n    p ∈ (Z.localTriv i).source ↔ p.1 ∈ (Z.localTriv i).baseSet :=\n  Iff.rfl\n\n"}
{"name":"FiberBundleCore.mem_localTrivAt_source","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\np : Z.TotalSpace\nb : B\n⊢ Iff (Membership.mem (Z.localTrivAt b).source p) (Membership.mem (Z.localTrivAt b).baseSet p.proj)","decl":"@[simp, mfld_simps]\ntheorem mem_localTrivAt_source (p : Z.TotalSpace) (b : B) :\n    p ∈ (Z.localTrivAt b).source ↔ p.1 ∈ (Z.localTrivAt b).baseSet :=\n  Iff.rfl\n\n"}
{"name":"FiberBundleCore.mem_localTriv_target","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni : ι\np : Prod B F\n⊢ Iff (Membership.mem (Z.localTriv i).target p) (Membership.mem (Z.localTriv i).baseSet p.1)","decl":"@[simp, mfld_simps]\ntheorem mem_localTriv_target (p : B × F) :\n    p ∈ (Z.localTriv i).target ↔ p.1 ∈ (Z.localTriv i).baseSet :=\n  Trivialization.mem_target _\n\n"}
{"name":"FiberBundleCore.mem_localTrivAt_target","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\np : Prod B F\nb : B\n⊢ Iff (Membership.mem (Z.localTrivAt b).target p) (Membership.mem (Z.localTrivAt b).baseSet p.1)","decl":"@[simp, mfld_simps]\ntheorem mem_localTrivAt_target (p : B × F) (b : B) :\n    p ∈ (Z.localTrivAt b).target ↔ p.1 ∈ (Z.localTrivAt b).baseSet :=\n  Trivialization.mem_target _\n\n"}
{"name":"FiberBundleCore.localTriv_symm_apply","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\ni : ι\np : Prod B F\n⊢ Eq (↑(Z.localTriv i).symm p) { proj := p.1, snd := Z.coordChange i (Z.indexAt p.1) p.1 p.2 }","decl":"@[simp, mfld_simps]\ntheorem localTriv_symm_apply (p : B × F) :\n    (Z.localTriv i).toPartialHomeomorph.symm p = ⟨p.1, Z.coordChange i (Z.indexAt p.1) p.1 p.2⟩ :=\n  rfl\n\n"}
{"name":"FiberBundleCore.mem_localTrivAt_baseSet","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\nb : B\n⊢ Membership.mem (Z.localTrivAt b).baseSet b","decl":"@[simp, mfld_simps]\ntheorem mem_localTrivAt_baseSet (b : B) : b ∈ (Z.localTrivAt b).baseSet := by\n  rw [localTrivAt, ← baseSet_at]\n  exact Z.mem_baseSet_at b\n\n"}
{"name":"FiberBundleCore.mk_mem_localTrivAt_source","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\nb : B\na : F\n⊢ Membership.mem (Z.localTrivAt b).source { proj := b, snd := a }","decl":"theorem mk_mem_localTrivAt_source : (⟨b, a⟩ : Z.TotalSpace) ∈ (Z.localTrivAt b).source := by\n  simp only [mfld_simps]\n\n"}
{"name":"FiberBundleCore.continuous_totalSpaceMk","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\nb : B\n⊢ Continuous (Bundle.TotalSpace.mk b)","decl":"/-- The inclusion of a fiber into the total space is a continuous map. -/\n@[continuity]\ntheorem continuous_totalSpaceMk (b : B) :\n    Continuous (TotalSpace.mk b : Z.Fiber b → Bundle.TotalSpace F Z.Fiber) :=\n  FiberBundle.continuous_totalSpaceMk F Z.Fiber b\n\n"}
{"name":"FiberBundleCore.continuous_proj","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\n⊢ Continuous Z.proj","decl":"/-- The projection on the base of a fiber bundle created from core is continuous -/\nnonrec theorem continuous_proj : Continuous Z.proj :=\n  FiberBundle.continuous_proj F Z.Fiber\n\n"}
{"name":"FiberBundleCore.isOpenMap_proj","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"ι : Type u_1\nB : Type u_2\nF : Type u_3\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace F\nZ : FiberBundleCore ι B F\n⊢ IsOpenMap Z.proj","decl":"/-- The projection on the base of a fiber bundle created from core is an open map -/\nnonrec theorem isOpenMap_proj : IsOpenMap Z.proj :=\n  FiberBundle.isOpenMap_proj F Z.Fiber\n\n"}
{"name":"FiberPrebundle.continuous_trivChange","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\nself : FiberPrebundle F E\ne : Pretrivialization F Bundle.TotalSpace.proj\na✝¹ : Membership.mem self.pretrivializationAtlas e\ne' : Pretrivialization F Bundle.TotalSpace.proj\na✝ : Membership.mem self.pretrivializationAtlas e'\n⊢ ContinuousOn (Function.comp ↑e ↑e'.symm) (Inter.inter e'.target (Set.preimage (↑e'.symm) e.source))","decl":"/-- This structure permits to define a fiber bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space. The total space is hence given a\ntopology in such a way that there is a fiber bundle structure for which the partial equivalences\nare also partial homeomorphisms and hence local trivializations. -/\nstructure FiberPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  continuous_trivChange : ∀ e, e ∈ pretrivializationAtlas → ∀ e', e' ∈ pretrivializationAtlas →\n    ContinuousOn (e ∘ e'.toPartialEquiv.symm) (e'.target ∩ e'.toPartialEquiv.symm ⁻¹' e.source)\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ TotalSpace.mk b)\n\n"}
{"name":"FiberPrebundle.mk.injEq","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\npretrivializationAtlas✝ : Set (Pretrivialization F Bundle.TotalSpace.proj)\npretrivializationAt✝ : B → Pretrivialization F Bundle.TotalSpace.proj\nmem_base_pretrivializationAt✝ : ∀ (x : B), Membership.mem (pretrivializationAt✝ x).baseSet x\npretrivialization_mem_atlas✝ : ∀ (x : B), Membership.mem pretrivializationAtlas✝ (pretrivializationAt✝ x)\ncontinuous_trivChange✝ : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas✝ e → ∀ (e' : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas✝ e' → ContinuousOn (Function.comp ↑e ↑e'.symm) (Inter.inter e'.target (Set.preimage (↑e'.symm) e.source))\ntotalSpaceMk_isInducing✝ : ∀ (b : B), Topology.IsInducing (Function.comp (↑(pretrivializationAt✝ b)) (Bundle.TotalSpace.mk b))\npretrivializationAtlas : Set (Pretrivialization F Bundle.TotalSpace.proj)\npretrivializationAt : B → Pretrivialization F Bundle.TotalSpace.proj\nmem_base_pretrivializationAt : ∀ (x : B), Membership.mem (pretrivializationAt x).baseSet x\npretrivialization_mem_atlas : ∀ (x : B), Membership.mem pretrivializationAtlas (pretrivializationAt x)\ncontinuous_trivChange : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e → ∀ (e' : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e' → ContinuousOn (Function.comp ↑e ↑e'.symm) (Inter.inter e'.target (Set.preimage (↑e'.symm) e.source))\ntotalSpaceMk_isInducing : ∀ (b : B), Topology.IsInducing (Function.comp (↑(pretrivializationAt b)) (Bundle.TotalSpace.mk b))\n⊢ Eq (Eq { pretrivializationAtlas := pretrivializationAtlas✝, pretrivializationAt := pretrivializationAt✝, mem_base_pretrivializationAt := mem_base_pretrivializationAt✝, pretrivialization_mem_atlas := pretrivialization_mem_atlas✝, continuous_trivChange := continuous_trivChange✝, totalSpaceMk_isInducing := totalSpaceMk_isInducing✝ } { pretrivializationAtlas := pretrivializationAtlas, pretrivializationAt := pretrivializationAt, mem_base_pretrivializationAt := mem_base_pretrivializationAt, pretrivialization_mem_atlas := pretrivialization_mem_atlas, continuous_trivChange := continuous_trivChange, totalSpaceMk_isInducing := totalSpaceMk_isInducing }) (And (Eq pretrivializationAtlas✝ pretrivializationAtlas) (Eq pretrivializationAt✝ pretrivializationAt))","decl":"/-- This structure permits to define a fiber bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space. The total space is hence given a\ntopology in such a way that there is a fiber bundle structure for which the partial equivalences\nare also partial homeomorphisms and hence local trivializations. -/\nstructure FiberPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  continuous_trivChange : ∀ e, e ∈ pretrivializationAtlas → ∀ e', e' ∈ pretrivializationAtlas →\n    ContinuousOn (e ∘ e'.toPartialEquiv.symm) (e'.target ∩ e'.toPartialEquiv.symm ⁻¹' e.source)\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ TotalSpace.mk b)\n\n"}
{"name":"FiberPrebundle.pretrivialization_mem_atlas","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\nself : FiberPrebundle F E\nx : B\n⊢ Membership.mem self.pretrivializationAtlas (self.pretrivializationAt x)","decl":"/-- This structure permits to define a fiber bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space. The total space is hence given a\ntopology in such a way that there is a fiber bundle structure for which the partial equivalences\nare also partial homeomorphisms and hence local trivializations. -/\nstructure FiberPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  continuous_trivChange : ∀ e, e ∈ pretrivializationAtlas → ∀ e', e' ∈ pretrivializationAtlas →\n    ContinuousOn (e ∘ e'.toPartialEquiv.symm) (e'.target ∩ e'.toPartialEquiv.symm ⁻¹' e.source)\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ TotalSpace.mk b)\n\n"}
{"name":"FiberPrebundle.mem_base_pretrivializationAt","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\nself : FiberPrebundle F E\nx : B\n⊢ Membership.mem (self.pretrivializationAt x).baseSet x","decl":"/-- This structure permits to define a fiber bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space. The total space is hence given a\ntopology in such a way that there is a fiber bundle structure for which the partial equivalences\nare also partial homeomorphisms and hence local trivializations. -/\nstructure FiberPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  continuous_trivChange : ∀ e, e ∈ pretrivializationAtlas → ∀ e', e' ∈ pretrivializationAtlas →\n    ContinuousOn (e ∘ e'.toPartialEquiv.symm) (e'.target ∩ e'.toPartialEquiv.symm ⁻¹' e.source)\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ TotalSpace.mk b)\n\n"}
{"name":"FiberPrebundle.mk.inj","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\npretrivializationAtlas✝ : Set (Pretrivialization F Bundle.TotalSpace.proj)\npretrivializationAt✝ : B → Pretrivialization F Bundle.TotalSpace.proj\nmem_base_pretrivializationAt✝ : ∀ (x : B), Membership.mem (pretrivializationAt✝ x).baseSet x\npretrivialization_mem_atlas✝ : ∀ (x : B), Membership.mem pretrivializationAtlas✝ (pretrivializationAt✝ x)\ncontinuous_trivChange✝ : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas✝ e → ∀ (e' : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas✝ e' → ContinuousOn (Function.comp ↑e ↑e'.symm) (Inter.inter e'.target (Set.preimage (↑e'.symm) e.source))\ntotalSpaceMk_isInducing✝ : ∀ (b : B), Topology.IsInducing (Function.comp (↑(pretrivializationAt✝ b)) (Bundle.TotalSpace.mk b))\npretrivializationAtlas : Set (Pretrivialization F Bundle.TotalSpace.proj)\npretrivializationAt : B → Pretrivialization F Bundle.TotalSpace.proj\nmem_base_pretrivializationAt : ∀ (x : B), Membership.mem (pretrivializationAt x).baseSet x\npretrivialization_mem_atlas : ∀ (x : B), Membership.mem pretrivializationAtlas (pretrivializationAt x)\ncontinuous_trivChange : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e → ∀ (e' : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e' → ContinuousOn (Function.comp ↑e ↑e'.symm) (Inter.inter e'.target (Set.preimage (↑e'.symm) e.source))\ntotalSpaceMk_isInducing : ∀ (b : B), Topology.IsInducing (Function.comp (↑(pretrivializationAt b)) (Bundle.TotalSpace.mk b))\nx✝ : Eq { pretrivializationAtlas := pretrivializationAtlas✝, pretrivializationAt := pretrivializationAt✝, mem_base_pretrivializationAt := mem_base_pretrivializationAt✝, pretrivialization_mem_atlas := pretrivialization_mem_atlas✝, continuous_trivChange := continuous_trivChange✝, totalSpaceMk_isInducing := totalSpaceMk_isInducing✝ } { pretrivializationAtlas := pretrivializationAtlas, pretrivializationAt := pretrivializationAt, mem_base_pretrivializationAt := mem_base_pretrivializationAt, pretrivialization_mem_atlas := pretrivialization_mem_atlas, continuous_trivChange := continuous_trivChange, totalSpaceMk_isInducing := totalSpaceMk_isInducing }\n⊢ And (Eq pretrivializationAtlas✝ pretrivializationAtlas) (Eq pretrivializationAt✝ pretrivializationAt)","decl":"/-- This structure permits to define a fiber bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space. The total space is hence given a\ntopology in such a way that there is a fiber bundle structure for which the partial equivalences\nare also partial homeomorphisms and hence local trivializations. -/\nstructure FiberPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  continuous_trivChange : ∀ e, e ∈ pretrivializationAtlas → ∀ e', e' ∈ pretrivializationAtlas →\n    ContinuousOn (e ∘ e'.toPartialEquiv.symm) (e'.target ∩ e'.toPartialEquiv.symm ⁻¹' e.source)\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ TotalSpace.mk b)\n\n"}
{"name":"FiberPrebundle.totalSpaceMk_isInducing","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\nself : FiberPrebundle F E\nb : B\n⊢ Topology.IsInducing (Function.comp (↑(self.pretrivializationAt b)) (Bundle.TotalSpace.mk b))","decl":"/-- This structure permits to define a fiber bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space. The total space is hence given a\ntopology in such a way that there is a fiber bundle structure for which the partial equivalences\nare also partial homeomorphisms and hence local trivializations. -/\nstructure FiberPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  continuous_trivChange : ∀ e, e ∈ pretrivializationAtlas → ∀ e', e' ∈ pretrivializationAtlas →\n    ContinuousOn (e ∘ e'.toPartialEquiv.symm) (e'.target ∩ e'.toPartialEquiv.symm ⁻¹' e.source)\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ TotalSpace.mk b)\n\n"}
{"name":"FiberPrebundle.mk.sizeOf_spec","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝⁵ : TopologicalSpace B\ninst✝⁴ : TopologicalSpace F\ninst✝³ : (x : B) → TopologicalSpace (E x)\ninst✝² : SizeOf B\ninst✝¹ : SizeOf F\ninst✝ : (a : B) → SizeOf (E a)\npretrivializationAtlas : Set (Pretrivialization F Bundle.TotalSpace.proj)\npretrivializationAt : B → Pretrivialization F Bundle.TotalSpace.proj\nmem_base_pretrivializationAt : ∀ (x : B), Membership.mem (pretrivializationAt x).baseSet x\npretrivialization_mem_atlas : ∀ (x : B), Membership.mem pretrivializationAtlas (pretrivializationAt x)\ncontinuous_trivChange : ∀ (e : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e → ∀ (e' : Pretrivialization F Bundle.TotalSpace.proj), Membership.mem pretrivializationAtlas e' → ContinuousOn (Function.comp ↑e ↑e'.symm) (Inter.inter e'.target (Set.preimage (↑e'.symm) e.source))\ntotalSpaceMk_isInducing : ∀ (b : B), Topology.IsInducing (Function.comp (↑(pretrivializationAt b)) (Bundle.TotalSpace.mk b))\n⊢ Eq (SizeOf.sizeOf { pretrivializationAtlas := pretrivializationAtlas, pretrivializationAt := pretrivializationAt, mem_base_pretrivializationAt := mem_base_pretrivializationAt, pretrivialization_mem_atlas := pretrivialization_mem_atlas, continuous_trivChange := continuous_trivChange, totalSpaceMk_isInducing := totalSpaceMk_isInducing }) 1","decl":"/-- This structure permits to define a fiber bundle when trivializations are given as local\nequivalences but there is not yet a topology on the total space. The total space is hence given a\ntopology in such a way that there is a fiber bundle structure for which the partial equivalences\nare also partial homeomorphisms and hence local trivializations. -/\nstructure FiberPrebundle where\n  pretrivializationAtlas : Set (Pretrivialization F (π F E))\n  pretrivializationAt : B → Pretrivialization F (π F E)\n  mem_base_pretrivializationAt : ∀ x : B, x ∈ (pretrivializationAt x).baseSet\n  pretrivialization_mem_atlas : ∀ x : B, pretrivializationAt x ∈ pretrivializationAtlas\n  continuous_trivChange : ∀ e, e ∈ pretrivializationAtlas → ∀ e', e' ∈ pretrivializationAtlas →\n    ContinuousOn (e ∘ e'.toPartialEquiv.symm) (e'.target ∩ e'.toPartialEquiv.symm ⁻¹' e.source)\n  totalSpaceMk_isInducing : ∀ b : B, IsInducing (pretrivializationAt b ∘ TotalSpace.mk b)\n\n"}
{"name":"FiberPrebundle.continuous_symm_of_mem_pretrivializationAtlas","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\na : FiberPrebundle F E\ne : Pretrivialization F Bundle.TotalSpace.proj\nhe : Membership.mem a.pretrivializationAtlas e\n⊢ ContinuousOn (↑e.symm) e.target","decl":"theorem continuous_symm_of_mem_pretrivializationAtlas (he : e ∈ a.pretrivializationAtlas) :\n    @ContinuousOn _ _ _ a.totalSpaceTopology e.toPartialEquiv.symm e.target := by\n  refine fun z H U h => preimage_nhdsWithin_coinduced' H (le_def.1 (nhds_mono ?_) U h)\n  exact le_iSup₂ (α := TopologicalSpace (TotalSpace F E)) e he\n\n"}
{"name":"FiberPrebundle.isOpen_source","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\na : FiberPrebundle F E\ne : Pretrivialization F Bundle.TotalSpace.proj\n⊢ IsOpen e.source","decl":"theorem isOpen_source (e : Pretrivialization F (π F E)) :\n    IsOpen[a.totalSpaceTopology] e.source := by\n  refine isOpen_iSup_iff.mpr fun e' => isOpen_iSup_iff.mpr fun _ => ?_\n  refine isOpen_coinduced.mpr (isOpen_induced_iff.mpr ⟨e.target, e.open_target, ?_⟩)\n  ext ⟨x, hx⟩\n  simp only [mem_preimage, Pretrivialization.setSymm, restrict, e.mem_target, e.mem_source,\n    e'.proj_symm_apply hx]\n\n"}
{"name":"FiberPrebundle.isOpen_target_of_mem_pretrivializationAtlas_inter","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\na : FiberPrebundle F E\ne e' : Pretrivialization F Bundle.TotalSpace.proj\nhe' : Membership.mem a.pretrivializationAtlas e'\n⊢ IsOpen (Inter.inter e'.target (Set.preimage (↑e'.symm) e.source))","decl":"theorem isOpen_target_of_mem_pretrivializationAtlas_inter (e e' : Pretrivialization F (π F E))\n    (he' : e' ∈ a.pretrivializationAtlas) :\n    IsOpen (e'.toPartialEquiv.target ∩ e'.toPartialEquiv.symm ⁻¹' e.source) := by\n  letI := a.totalSpaceTopology\n  obtain ⟨u, hu1, hu2⟩ := continuousOn_iff'.mp (a.continuous_symm_of_mem_pretrivializationAtlas he')\n    e.source (a.isOpen_source e)\n  rw [inter_comm, hu2]\n  exact hu1.inter e'.open_target\n\n"}
{"name":"FiberPrebundle.mem_pretrivializationAt_source","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\na : FiberPrebundle F E\nb : B\nx : E b\n⊢ Membership.mem (a.pretrivializationAt b).source { proj := b, snd := x }","decl":"theorem mem_pretrivializationAt_source (b : B) (x : E b) :\n    ⟨b, x⟩ ∈ (a.pretrivializationAt b).source := by\n  simp only [(a.pretrivializationAt b).source_eq, mem_preimage, TotalSpace.proj]\n  exact a.mem_base_pretrivializationAt b\n\n"}
{"name":"FiberPrebundle.totalSpaceMk_preimage_source","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\na : FiberPrebundle F E\nb : B\n⊢ Eq (Set.preimage (Bundle.TotalSpace.mk b) (a.pretrivializationAt b).source) Set.univ","decl":"@[simp]\ntheorem totalSpaceMk_preimage_source (b : B) :\n    TotalSpace.mk b ⁻¹' (a.pretrivializationAt b).source = univ :=\n  eq_univ_of_forall (a.mem_pretrivializationAt_source b)\n\n"}
{"name":"FiberPrebundle.continuous_totalSpaceMk","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\na : FiberPrebundle F E\nb : B\n⊢ Continuous (Bundle.TotalSpace.mk b)","decl":"@[continuity]\ntheorem continuous_totalSpaceMk (b : B) :\n    Continuous[_, a.totalSpaceTopology] (TotalSpace.mk b) := by\n  letI := a.totalSpaceTopology\n  let e := a.trivializationOfMemPretrivializationAtlas (a.pretrivialization_mem_atlas b)\n  rw [e.toPartialHomeomorph.continuous_iff_continuous_comp_left\n      (a.totalSpaceMk_preimage_source b)]\n  exact continuous_iff_le_induced.2 (a.totalSpaceMk_isInducing b).eq_induced.le\n\n"}
{"name":"FiberPrebundle.inducing_totalSpaceMk_of_inducing_comp","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\na : FiberPrebundle F E\nb : B\nh : Topology.IsInducing (Function.comp (↑(a.pretrivializationAt b)) (Bundle.TotalSpace.mk b))\n⊢ Topology.IsInducing (Bundle.TotalSpace.mk b)","decl":"theorem inducing_totalSpaceMk_of_inducing_comp (b : B)\n    (h : IsInducing (a.pretrivializationAt b ∘ TotalSpace.mk b)) :\n    @IsInducing _ _ _ a.totalSpaceTopology (TotalSpace.mk b) := by\n  letI := a.totalSpaceTopology\n  rw [← restrict_comp_codRestrict (a.mem_pretrivializationAt_source b)] at h\n  apply IsInducing.of_codRestrict (a.mem_pretrivializationAt_source b)\n  refine h.of_comp ?_ (continuousOn_iff_continuous_restrict.mp\n    (a.trivializationOfMemPretrivializationAtlas (a.pretrivialization_mem_atlas b)).continuousOn)\n  exact (a.continuous_totalSpaceMk b).codRestrict (a.mem_pretrivializationAt_source b)\n\n"}
{"name":"FiberPrebundle.continuous_proj","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\na : FiberPrebundle F E\n⊢ Continuous Bundle.TotalSpace.proj","decl":"theorem continuous_proj : @Continuous _ _ a.totalSpaceTopology _ (π F E) := by\n  letI := a.totalSpaceTopology\n  letI := a.toFiberBundle\n  exact FiberBundle.continuous_proj F E\n\n"}
{"name":"FiberPrebundle.instMemTrivializationAtlasTrivializationOfMemPretrivializationAtlas","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace F\ninst✝ : (x : B) → TopologicalSpace (E x)\na : FiberPrebundle F E\ne₀ : Pretrivialization F Bundle.TotalSpace.proj\nhe₀ : Membership.mem a.pretrivializationAtlas e₀\n⊢ MemTrivializationAtlas (a.trivializationOfMemPretrivializationAtlas he₀)","decl":"instance {e₀} (he₀ : e₀ ∈ a.pretrivializationAtlas) :\n    (letI := a.totalSpaceTopology; letI := a.toFiberBundle\n      MemTrivializationAtlas (a.trivializationOfMemPretrivializationAtlas he₀)) :=\n  letI := a.totalSpaceTopology; letI := a.toFiberBundle; ⟨e₀, he₀, rfl⟩\n\n"}
{"name":"FiberPrebundle.continuousOn_of_comp_right","module":"Mathlib.Topology.FiberBundle.Basic","initialProofState":"B : Type u_2\nF : Type u_3\nE : B → Type u_5\ninst✝³ : TopologicalSpace B\ninst✝² : TopologicalSpace F\ninst✝¹ : (x : B) → TopologicalSpace (E x)\na : FiberPrebundle F E\nX : Type u_6\ninst✝ : TopologicalSpace X\nf : Bundle.TotalSpace F E → X\ns : Set B\nhs : IsOpen s\nhf : ∀ (b : B), Membership.mem s b → ContinuousOn (Function.comp f ↑(a.pretrivializationAt b).symm) (SProd.sprod (Inter.inter s (a.pretrivializationAt b).baseSet) Set.univ)\n⊢ ContinuousOn f (Set.preimage Bundle.TotalSpace.proj s)","decl":"/-- For a fiber bundle `E` over `B` constructed using the `FiberPrebundle` mechanism,\ncontinuity of a function `TotalSpace F E → X` on an open set `s` can be checked by precomposing at\neach point with the pretrivialization used for the construction at that point. -/\ntheorem continuousOn_of_comp_right {X : Type*} [TopologicalSpace X] {f : TotalSpace F E → X}\n    {s : Set B} (hs : IsOpen s) (hf : ∀ b ∈ s,\n      ContinuousOn (f ∘ (a.pretrivializationAt b).toPartialEquiv.symm)\n        ((s ∩ (a.pretrivializationAt b).baseSet) ×ˢ (Set.univ : Set F))) :\n    @ContinuousOn _ _ a.totalSpaceTopology _ f (π F E ⁻¹' s) := by\n  letI := a.totalSpaceTopology\n  intro z hz\n  let e : Trivialization F (π F E) :=\n    a.trivializationOfMemPretrivializationAtlas (a.pretrivialization_mem_atlas z.proj)\n  refine (e.continuousAt_of_comp_right ?_\n    ((hf z.proj hz).continuousAt (IsOpen.mem_nhds ?_ ?_))).continuousWithinAt\n  · exact a.mem_base_pretrivializationAt z.proj\n  · exact (hs.inter (a.pretrivializationAt z.proj).open_baseSet).prod isOpen_univ\n  refine ⟨?_, mem_univ _⟩\n  rw [e.coe_fst]\n  · exact ⟨hz, a.mem_base_pretrivializationAt z.proj⟩\n  · rw [e.mem_source]\n    exact a.mem_base_pretrivializationAt z.proj\n\n"}
