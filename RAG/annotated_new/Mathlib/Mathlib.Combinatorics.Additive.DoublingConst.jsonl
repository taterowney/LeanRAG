{"name":"Finset.addConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq (HMul.hMul (A.addConst B) ↑A.card) ↑(HAdd.hAdd A B).card","decl":"@[to_additive (attr := simp) addConst_mul_card]\nlemma mulConst_mul_card (A B : Finset G) : σₘ[A, B] * #A = #(A * B) := by\n  obtain rfl | hA := A.eq_empty_or_nonempty\n  · simp\n  · exact div_mul_cancel₀ _ (by positivity)\n\n"}
{"name":"Finset.mulConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq (HMul.hMul (A.mulConst B) ↑A.card) ↑(HMul.hMul A B).card","decl":"@[to_additive (attr := simp) addConst_mul_card]\nlemma mulConst_mul_card (A B : Finset G) : σₘ[A, B] * #A = #(A * B) := by\n  obtain rfl | hA := A.eq_empty_or_nonempty\n  · simp\n  · exact div_mul_cancel₀ _ (by positivity)\n\n"}
{"name":"Finset.divConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq (HMul.hMul (A.divConst B) ↑A.card) ↑(HDiv.hDiv A B).card","decl":"@[to_additive (attr := simp) subConst_mul_card]\nlemma divConst_mul_card (A B : Finset G) : δₘ[A, B] * #A = #(A / B) := by\n  obtain rfl | hA := A.eq_empty_or_nonempty\n  · simp\n  · exact div_mul_cancel₀ _ (by positivity)\n\n"}
{"name":"Finset.subConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq (HMul.hMul (A.subConst B) ↑A.card) ↑(HSub.hSub A B).card","decl":"@[to_additive (attr := simp) subConst_mul_card]\nlemma divConst_mul_card (A B : Finset G) : δₘ[A, B] * #A = #(A / B) := by\n  obtain rfl | hA := A.eq_empty_or_nonempty\n  · simp\n  · exact div_mul_cancel₀ _ (by positivity)\n\n"}
{"name":"Finset.card_mul_mulConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq (HMul.hMul (↑A.card) (A.mulConst B)) ↑(HMul.hMul A B).card","decl":"@[to_additive (attr := simp) card_mul_addConst]\nlemma card_mul_mulConst (A B : Finset G) : #A * σₘ[A, B] = #(A * B) := by\n  rw [mul_comm, mulConst_mul_card]\n\n"}
{"name":"Finset.card_mul_addConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq (HMul.hMul (↑A.card) (A.addConst B)) ↑(HAdd.hAdd A B).card","decl":"@[to_additive (attr := simp) card_mul_addConst]\nlemma card_mul_mulConst (A B : Finset G) : #A * σₘ[A, B] = #(A * B) := by\n  rw [mul_comm, mulConst_mul_card]\n\n"}
{"name":"Finset.card_mul_subConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq (HMul.hMul (↑A.card) (A.subConst B)) ↑(HSub.hSub A B).card","decl":"@[to_additive (attr := simp) card_mul_subConst]\nlemma card_mul_divConst (A B : Finset G) : #A * δₘ[A, B] = #(A / B) := by\n  rw [mul_comm, divConst_mul_card]\n\n"}
{"name":"Finset.card_mul_divConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq (HMul.hMul (↑A.card) (A.divConst B)) ↑(HDiv.hDiv A B).card","decl":"@[to_additive (attr := simp) card_mul_subConst]\nlemma card_mul_divConst (A B : Finset G) : #A * δₘ[A, B] = #(A / B) := by\n  rw [mul_comm, divConst_mul_card]\n\n"}
{"name":"Finset.addConst_empty_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nB : Finset G\n⊢ Eq (EmptyCollection.emptyCollection.addConst B) 0","decl":"@[to_additive (attr := simp)]\nlemma mulConst_empty_left (B : Finset G) : σₘ[∅, B] = 0 := by simp [mulConst]\n\n"}
{"name":"Finset.mulConst_empty_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nB : Finset G\n⊢ Eq (EmptyCollection.emptyCollection.mulConst B) 0","decl":"@[to_additive (attr := simp)]\nlemma mulConst_empty_left (B : Finset G) : σₘ[∅, B] = 0 := by simp [mulConst]\n\n"}
{"name":"Finset.divConst_empty_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nB : Finset G\n⊢ Eq (EmptyCollection.emptyCollection.divConst B) 0","decl":"@[to_additive (attr := simp)]\nlemma divConst_empty_left (B : Finset G) : δₘ[∅, B] = 0 := by simp [divConst]\n\n"}
{"name":"Finset.subConst_empty_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nB : Finset G\n⊢ Eq (EmptyCollection.emptyCollection.subConst B) 0","decl":"@[to_additive (attr := simp)]\nlemma divConst_empty_left (B : Finset G) : δₘ[∅, B] = 0 := by simp [divConst]\n\n"}
{"name":"Finset.addConst_empty_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nA : Finset G\n⊢ Eq (A.addConst EmptyCollection.emptyCollection) 0","decl":"@[to_additive (attr := simp)]\nlemma mulConst_empty_right (A : Finset G) : σₘ[A, ∅] = 0 := by simp [mulConst]\n\n"}
{"name":"Finset.mulConst_empty_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA : Finset G\n⊢ Eq (A.mulConst EmptyCollection.emptyCollection) 0","decl":"@[to_additive (attr := simp)]\nlemma mulConst_empty_right (A : Finset G) : σₘ[A, ∅] = 0 := by simp [mulConst]\n\n"}
{"name":"Finset.divConst_empty_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA : Finset G\n⊢ Eq (A.divConst EmptyCollection.emptyCollection) 0","decl":"@[to_additive (attr := simp)]\nlemma divConst_empty_right (A : Finset G) : δₘ[A, ∅] = 0 := by simp [divConst]\n\n"}
{"name":"Finset.subConst_empty_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nA : Finset G\n⊢ Eq (A.subConst EmptyCollection.emptyCollection) 0","decl":"@[to_additive (attr := simp)]\nlemma divConst_empty_right (A : Finset G) : δₘ[A, ∅] = 0 := by simp [divConst]\n\n"}
{"name":"Finset.mulConst_inv_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq (A.mulConst (Inv.inv B)) (A.divConst B)","decl":"@[to_additive (attr := simp)]\nlemma mulConst_inv_right (A B : Finset G) : σₘ[A, B⁻¹] = δₘ[A, B] := by\n  rw [mulConst, divConst, ← div_eq_mul_inv]\n\n"}
{"name":"Finset.addConst_neg_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq (A.addConst (Neg.neg B)) (A.subConst B)","decl":"@[to_additive (attr := simp)]\nlemma mulConst_inv_right (A B : Finset G) : σₘ[A, B⁻¹] = δₘ[A, B] := by\n  rw [mulConst, divConst, ← div_eq_mul_inv]\n\n"}
{"name":"Finset.subConst_neg_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq (A.subConst (Neg.neg B)) (A.addConst B)","decl":"@[to_additive (attr := simp)]\nlemma divConst_inv_right (A B : Finset G) : δₘ[A, B⁻¹] = σₘ[A, B] := by\n  rw [mulConst, divConst, div_inv_eq_mul]\n\n"}
{"name":"Finset.divConst_inv_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq (A.divConst (Inv.inv B)) (A.mulConst B)","decl":"@[to_additive (attr := simp)]\nlemma divConst_inv_right (A B : Finset G) : δₘ[A, B⁻¹] = σₘ[A, B] := by\n  rw [mulConst, divConst, div_inv_eq_mul]\n\n"}
{"name":"Finset.addConst_le_inv_dens","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : DecidableEq G\nA B : Finset G\ninst✝ : Fintype G\n⊢ LE.le (A.addConst B) (Inv.inv A.dens)","decl":"/-- Dense sets have small doubling. -/\n@[to_additive addConst_le_inv_dens \"Dense sets have small doubling.\"]\nlemma mulConst_le_inv_dens : σₘ[A, B] ≤ A.dens⁻¹ := by\n  rw [dens, inv_div, mulConst]; gcongr; exact card_le_univ _\n\n"}
{"name":"Finset.mulConst_le_inv_dens","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : DecidableEq G\nA B : Finset G\ninst✝ : Fintype G\n⊢ LE.le (A.mulConst B) (Inv.inv A.dens)","decl":"/-- Dense sets have small doubling. -/\n@[to_additive addConst_le_inv_dens \"Dense sets have small doubling.\"]\nlemma mulConst_le_inv_dens : σₘ[A, B] ≤ A.dens⁻¹ := by\n  rw [dens, inv_div, mulConst]; gcongr; exact card_le_univ _\n\n"}
{"name":"Finset.subConst_le_inv_dens","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\ninst✝¹ : DecidableEq G\nA B : Finset G\ninst✝ : Fintype G\n⊢ LE.le (A.subConst B) (Inv.inv A.dens)","decl":"/-- Dense sets have small difference constant. -/\n@[to_additive subConst_le_inv_dens \"Dense sets have small difference constant.\"]\nlemma divConst_le_inv_dens : δₘ[A, B] ≤ A.dens⁻¹ := by\n  rw [dens, inv_div, divConst]; gcongr; exact card_le_univ _\n\n"}
{"name":"Finset.divConst_le_inv_dens","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : DecidableEq G\nA B : Finset G\ninst✝ : Fintype G\n⊢ LE.le (A.divConst B) (Inv.inv A.dens)","decl":"/-- Dense sets have small difference constant. -/\n@[to_additive subConst_le_inv_dens \"Dense sets have small difference constant.\"]\nlemma divConst_le_inv_dens : δₘ[A, B] ≤ A.dens⁻¹ := by\n  rw [dens, inv_div, divConst]; gcongr; exact card_le_univ _\n\n"}
{"name":"Finset.cast_addConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G' : Type u_2\ninst✝³ : AddGroup G'\ninst✝² : DecidableEq G'\n𝕜 : Type u_3\ninst✝¹ : Semifield 𝕜\ninst✝ : CharZero 𝕜\nA B : Finset G'\n⊢ Eq (↑(A.addConst B)) (HDiv.hDiv ↑(HAdd.hAdd A B).card ↑A.card)","decl":"lemma cast_addConst (A B : Finset G') : (σ[A, B] : 𝕜) = #(A + B) / #A := by\n  simp [addConst]\n\n"}
{"name":"Finset.cast_subConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G' : Type u_2\ninst✝³ : AddGroup G'\ninst✝² : DecidableEq G'\n𝕜 : Type u_3\ninst✝¹ : Semifield 𝕜\ninst✝ : CharZero 𝕜\nA B : Finset G'\n⊢ Eq (↑(A.subConst B)) (HDiv.hDiv ↑(HSub.hSub A B).card ↑A.card)","decl":"lemma cast_subConst (A B : Finset G') : (δ[A, B] : 𝕜) = #(A - B) / #A := by\n  simp [subConst]\n\n"}
{"name":"Finset.cast_mulConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : DecidableEq G\n𝕜 : Type u_3\ninst✝¹ : Semifield 𝕜\ninst✝ : CharZero 𝕜\nA B : Finset G\n⊢ Eq (↑(A.mulConst B)) (HDiv.hDiv ↑(HMul.hMul A B).card ↑A.card)","decl":"@[to_additive existing]\nlemma cast_mulConst (A B : Finset G) : (σₘ[A, B] : 𝕜) = #(A * B) / #A := by simp [mulConst]\n\n"}
{"name":"Finset.cast_divConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : DecidableEq G\n𝕜 : Type u_3\ninst✝¹ : Semifield 𝕜\ninst✝ : CharZero 𝕜\nA B : Finset G\n⊢ Eq (↑(A.divConst B)) (HDiv.hDiv ↑(HDiv.hDiv A B).card ↑A.card)","decl":"@[to_additive existing]\nlemma cast_divConst (A B : Finset G) : (δₘ[A, B] : 𝕜) = #(A / B) / #A := by simp [divConst]\n\n"}
{"name":"Finset.cast_addConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G' : Type u_2\ninst✝³ : AddGroup G'\ninst✝² : DecidableEq G'\n𝕜 : Type u_3\ninst✝¹ : Semifield 𝕜\ninst✝ : CharZero 𝕜\nA B : Finset G'\n⊢ Eq (HMul.hMul ↑(A.addConst B) ↑A.card) ↑(HAdd.hAdd A B).card","decl":"lemma cast_addConst_mul_card (A B : Finset G') : (σ[A, B] * #A : 𝕜) = #(A + B) := by\n  norm_cast; exact addConst_mul_card _ _\n\n"}
{"name":"Finset.cast_subConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G' : Type u_2\ninst✝³ : AddGroup G'\ninst✝² : DecidableEq G'\n𝕜 : Type u_3\ninst✝¹ : Semifield 𝕜\ninst✝ : CharZero 𝕜\nA B : Finset G'\n⊢ Eq (HMul.hMul ↑(A.subConst B) ↑A.card) ↑(HSub.hSub A B).card","decl":"lemma cast_subConst_mul_card (A B : Finset G') : (δ[A, B] * #A : 𝕜) = #(A - B) := by\n  norm_cast; exact subConst_mul_card _ _\n\n"}
{"name":"Finset.card_mul_cast_addConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G' : Type u_2\ninst✝³ : AddGroup G'\ninst✝² : DecidableEq G'\n𝕜 : Type u_3\ninst✝¹ : Semifield 𝕜\ninst✝ : CharZero 𝕜\nA B : Finset G'\n⊢ Eq (HMul.hMul ↑A.card ↑(A.addConst B)) ↑(HAdd.hAdd A B).card","decl":"lemma card_mul_cast_addConst (A B : Finset G') : (#A * σ[A, B] : 𝕜) = #(A + B) := by\n  norm_cast; exact card_mul_addConst _ _\n\n"}
{"name":"Finset.card_mul_cast_subConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G' : Type u_2\ninst✝³ : AddGroup G'\ninst✝² : DecidableEq G'\n𝕜 : Type u_3\ninst✝¹ : Semifield 𝕜\ninst✝ : CharZero 𝕜\nA B : Finset G'\n⊢ Eq (HMul.hMul ↑A.card ↑(A.subConst B)) ↑(HSub.hSub A B).card","decl":"lemma card_mul_cast_subConst (A B : Finset G') : (#A * δ[A, B] : 𝕜) = #(A - B) := by\n  norm_cast; exact card_mul_subConst _ _\n\n"}
{"name":"Finset.cast_mulConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : DecidableEq G\n𝕜 : Type u_3\ninst✝¹ : Semifield 𝕜\ninst✝ : CharZero 𝕜\nA B : Finset G\n⊢ Eq (HMul.hMul ↑(A.mulConst B) ↑A.card) ↑(HMul.hMul A B).card","decl":"@[to_additive (attr := simp) existing cast_addConst_mul_card]\nlemma cast_mulConst_mul_card (A B : Finset G) : (σₘ[A, B] * #A : 𝕜) = #(A * B) := by\n  norm_cast; exact mulConst_mul_card _ _\n\n"}
{"name":"Finset.cast_divConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : DecidableEq G\n𝕜 : Type u_3\ninst✝¹ : Semifield 𝕜\ninst✝ : CharZero 𝕜\nA B : Finset G\n⊢ Eq (HMul.hMul ↑(A.divConst B) ↑A.card) ↑(HDiv.hDiv A B).card","decl":"@[to_additive (attr := simp) existing cast_subConst_mul_card]\nlemma cast_divConst_mul_card (A B : Finset G) : (δₘ[A, B] * #A : 𝕜) = #(A / B) := by\n  norm_cast; exact divConst_mul_card _ _\n\n"}
{"name":"Finset.card_mul_cast_mulConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : DecidableEq G\n𝕜 : Type u_3\ninst✝¹ : Semifield 𝕜\ninst✝ : CharZero 𝕜\nA B : Finset G\n⊢ Eq (HMul.hMul ↑A.card ↑(A.mulConst B)) ↑(HMul.hMul A B).card","decl":"@[to_additive (attr := simp) existing card_mul_cast_addConst]\nlemma card_mul_cast_mulConst (A B : Finset G) : (#A * σₘ[A, B] : 𝕜) = #(A * B) := by\n  norm_cast; exact card_mul_mulConst _ _\n\n"}
{"name":"Finset.card_mul_cast_divConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : DecidableEq G\n𝕜 : Type u_3\ninst✝¹ : Semifield 𝕜\ninst✝ : CharZero 𝕜\nA B : Finset G\n⊢ Eq (HMul.hMul ↑A.card ↑(A.divConst B)) ↑(HDiv.hDiv A B).card","decl":"@[to_additive (attr := simp) existing card_mul_cast_subConst]\nlemma card_mul_cast_divConst (A B : Finset G) : (#A * δₘ[A, B] : 𝕜) = #(A / B) := by\n  norm_cast; exact card_mul_divConst _ _\n\n"}
{"name":"Finset.mulConst_inv_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : CommGroup G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq ((Inv.inv A).mulConst B) (A.divConst B)","decl":"@[to_additive (attr := simp)]\nlemma mulConst_inv_left (A B : Finset G) : σₘ[A⁻¹, B] = δₘ[A, B] := by\n  rw [mulConst, divConst, card_inv, ← card_inv, mul_inv_rev, inv_inv, inv_mul_eq_div]\n\n"}
{"name":"Finset.addConst_neg_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddCommGroup G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq ((Neg.neg A).addConst B) (A.subConst B)","decl":"@[to_additive (attr := simp)]\nlemma mulConst_inv_left (A B : Finset G) : σₘ[A⁻¹, B] = δₘ[A, B] := by\n  rw [mulConst, divConst, card_inv, ← card_inv, mul_inv_rev, inv_inv, inv_mul_eq_div]\n\n"}
{"name":"Finset.divConst_inv_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : CommGroup G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq ((Inv.inv A).divConst B) (A.mulConst B)","decl":"@[to_additive (attr := simp)]\nlemma divConst_inv_left (A B : Finset G) : δₘ[A⁻¹, B] = σₘ[A, B] := by\n  rw [mulConst, divConst, card_inv, ← card_inv, inv_div, div_inv_eq_mul, mul_comm]\n\n"}
{"name":"Finset.subConst_neg_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddCommGroup G\ninst✝ : DecidableEq G\nA B : Finset G\n⊢ Eq ((Neg.neg A).subConst B) (A.addConst B)","decl":"@[to_additive (attr := simp)]\nlemma divConst_inv_left (A B : Finset G) : δₘ[A⁻¹, B] = σₘ[A, B] := by\n  rw [mulConst, divConst, card_inv, ← card_inv, inv_div, div_inv_eq_mul, mul_comm]\n\n"}
{"name":"Finset.addConst_le_subConst_sq","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddCommGroup G\ninst✝ : DecidableEq G\nA : Finset G\n⊢ LE.le (A.addConst A) (HPow.hPow (A.subConst A) 2)","decl":"/-- If `A` has small difference, then it has small doubling, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality. -/\n@[to_additive\n\"If `A` has small difference, then it has small doubling, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality.\"]\nlemma mulConst_le_divConst_sq : σₘ[A] ≤ δₘ[A] ^ 2 := by\n  obtain rfl | hA' := A.eq_empty_or_nonempty\n  · simp\n  refine le_of_mul_le_mul_right ?_ (by positivity : (0 : ℚ≥0) < #A * #A)\n  calc\n    _ = #(A * A) * (#A : ℚ≥0) := by rw [← mul_assoc, mulConst_mul_card]\n    _ ≤ #(A / A) * #(A / A) := by norm_cast; exact ruzsa_triangle_inequality_mul_div_div ..\n    _ = _ := by rw [← divConst_mul_card]; ring\n\n"}
{"name":"Finset.mulConst_le_divConst_sq","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : CommGroup G\ninst✝ : DecidableEq G\nA : Finset G\n⊢ LE.le (A.mulConst A) (HPow.hPow (A.divConst A) 2)","decl":"/-- If `A` has small difference, then it has small doubling, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality. -/\n@[to_additive\n\"If `A` has small difference, then it has small doubling, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality.\"]\nlemma mulConst_le_divConst_sq : σₘ[A] ≤ δₘ[A] ^ 2 := by\n  obtain rfl | hA' := A.eq_empty_or_nonempty\n  · simp\n  refine le_of_mul_le_mul_right ?_ (by positivity : (0 : ℚ≥0) < #A * #A)\n  calc\n    _ = #(A * A) * (#A : ℚ≥0) := by rw [← mul_assoc, mulConst_mul_card]\n    _ ≤ #(A / A) * #(A / A) := by norm_cast; exact ruzsa_triangle_inequality_mul_div_div ..\n    _ = _ := by rw [← divConst_mul_card]; ring\n\n"}
{"name":"Finset.divConst_le_mulConst_sq","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : CommGroup G\ninst✝ : DecidableEq G\nA : Finset G\n⊢ LE.le (A.divConst A) (HPow.hPow (A.mulConst A) 2)","decl":"/-- If `A` has small doubling, then it has small difference, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality. -/\n@[to_additive\n\"If `A` has small doubling, then it has small difference, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality.\"]\nlemma divConst_le_mulConst_sq : δₘ[A] ≤ σₘ[A] ^ 2 := by\n  obtain rfl | hA' := A.eq_empty_or_nonempty\n  · simp\n  refine le_of_mul_le_mul_right ?_ (by positivity : (0 : ℚ≥0) < #A * #A)\n  calc\n    _ = #(A / A) * (#A : ℚ≥0) := by rw [← mul_assoc, divConst_mul_card]\n    _ ≤ #(A * A) * #(A * A) := by norm_cast; exact ruzsa_triangle_inequality_div_mul_mul ..\n    _ = _ := by rw [← mulConst_mul_card]; ring\n\n"}
{"name":"Finset.subConst_le_addConst_sq","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninst✝¹ : AddCommGroup G\ninst✝ : DecidableEq G\nA : Finset G\n⊢ LE.le (A.subConst A) (HPow.hPow (A.addConst A) 2)","decl":"/-- If `A` has small doubling, then it has small difference, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality. -/\n@[to_additive\n\"If `A` has small doubling, then it has small difference, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality.\"]\nlemma divConst_le_mulConst_sq : δₘ[A] ≤ σₘ[A] ^ 2 := by\n  obtain rfl | hA' := A.eq_empty_or_nonempty\n  · simp\n  refine le_of_mul_le_mul_right ?_ (by positivity : (0 : ℚ≥0) < #A * #A)\n  calc\n    _ = #(A / A) * (#A : ℚ≥0) := by rw [← mul_assoc, divConst_mul_card]\n    _ ≤ #(A * A) * #(A * A) := by norm_cast; exact ruzsa_triangle_inequality_div_mul_mul ..\n    _ = _ := by rw [← mulConst_mul_card]; ring\n\n"}
