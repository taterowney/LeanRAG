{"name":"Finset.addConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddGroup G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq (HMul.hMul (A.addConst B) â†‘A.card) â†‘(HAdd.hAdd A B).card","decl":"@[to_additive (attr := simp) addConst_mul_card]\nlemma mulConst_mul_card (A B : Finset G) : Ïƒâ‚˜[A, B] * #A = #(A * B) := by\n  obtain rfl | hA := A.eq_empty_or_nonempty\n  Â· simp\n  Â· exact div_mul_cancelâ‚€ _ (by positivity)\n\n"}
{"name":"Finset.mulConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : Group G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq (HMul.hMul (A.mulConst B) â†‘A.card) â†‘(HMul.hMul A B).card","decl":"@[to_additive (attr := simp) addConst_mul_card]\nlemma mulConst_mul_card (A B : Finset G) : Ïƒâ‚˜[A, B] * #A = #(A * B) := by\n  obtain rfl | hA := A.eq_empty_or_nonempty\n  Â· simp\n  Â· exact div_mul_cancelâ‚€ _ (by positivity)\n\n"}
{"name":"Finset.divConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : Group G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq (HMul.hMul (A.divConst B) â†‘A.card) â†‘(HDiv.hDiv A B).card","decl":"@[to_additive (attr := simp) subConst_mul_card]\nlemma divConst_mul_card (A B : Finset G) : Î´â‚˜[A, B] * #A = #(A / B) := by\n  obtain rfl | hA := A.eq_empty_or_nonempty\n  Â· simp\n  Â· exact div_mul_cancelâ‚€ _ (by positivity)\n\n"}
{"name":"Finset.subConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddGroup G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq (HMul.hMul (A.subConst B) â†‘A.card) â†‘(HSub.hSub A B).card","decl":"@[to_additive (attr := simp) subConst_mul_card]\nlemma divConst_mul_card (A B : Finset G) : Î´â‚˜[A, B] * #A = #(A / B) := by\n  obtain rfl | hA := A.eq_empty_or_nonempty\n  Â· simp\n  Â· exact div_mul_cancelâ‚€ _ (by positivity)\n\n"}
{"name":"Finset.card_mul_mulConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : Group G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq (HMul.hMul (â†‘A.card) (A.mulConst B)) â†‘(HMul.hMul A B).card","decl":"@[to_additive (attr := simp) card_mul_addConst]\nlemma card_mul_mulConst (A B : Finset G) : #A * Ïƒâ‚˜[A, B] = #(A * B) := by\n  rw [mul_comm, mulConst_mul_card]\n\n"}
{"name":"Finset.card_mul_addConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddGroup G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq (HMul.hMul (â†‘A.card) (A.addConst B)) â†‘(HAdd.hAdd A B).card","decl":"@[to_additive (attr := simp) card_mul_addConst]\nlemma card_mul_mulConst (A B : Finset G) : #A * Ïƒâ‚˜[A, B] = #(A * B) := by\n  rw [mul_comm, mulConst_mul_card]\n\n"}
{"name":"Finset.card_mul_subConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddGroup G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq (HMul.hMul (â†‘A.card) (A.subConst B)) â†‘(HSub.hSub A B).card","decl":"@[to_additive (attr := simp) card_mul_subConst]\nlemma card_mul_divConst (A B : Finset G) : #A * Î´â‚˜[A, B] = #(A / B) := by\n  rw [mul_comm, divConst_mul_card]\n\n"}
{"name":"Finset.card_mul_divConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : Group G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq (HMul.hMul (â†‘A.card) (A.divConst B)) â†‘(HDiv.hDiv A B).card","decl":"@[to_additive (attr := simp) card_mul_subConst]\nlemma card_mul_divConst (A B : Finset G) : #A * Î´â‚˜[A, B] = #(A / B) := by\n  rw [mul_comm, divConst_mul_card]\n\n"}
{"name":"Finset.addConst_empty_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddGroup G\ninstâœ : DecidableEq G\nB : Finset G\nâŠ¢ Eq (EmptyCollection.emptyCollection.addConst B) 0","decl":"@[to_additive (attr := simp)]\nlemma mulConst_empty_left (B : Finset G) : Ïƒâ‚˜[âˆ…, B] = 0 := by simp [mulConst]\n\n"}
{"name":"Finset.mulConst_empty_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : Group G\ninstâœ : DecidableEq G\nB : Finset G\nâŠ¢ Eq (EmptyCollection.emptyCollection.mulConst B) 0","decl":"@[to_additive (attr := simp)]\nlemma mulConst_empty_left (B : Finset G) : Ïƒâ‚˜[âˆ…, B] = 0 := by simp [mulConst]\n\n"}
{"name":"Finset.divConst_empty_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : Group G\ninstâœ : DecidableEq G\nB : Finset G\nâŠ¢ Eq (EmptyCollection.emptyCollection.divConst B) 0","decl":"@[to_additive (attr := simp)]\nlemma divConst_empty_left (B : Finset G) : Î´â‚˜[âˆ…, B] = 0 := by simp [divConst]\n\n"}
{"name":"Finset.subConst_empty_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddGroup G\ninstâœ : DecidableEq G\nB : Finset G\nâŠ¢ Eq (EmptyCollection.emptyCollection.subConst B) 0","decl":"@[to_additive (attr := simp)]\nlemma divConst_empty_left (B : Finset G) : Î´â‚˜[âˆ…, B] = 0 := by simp [divConst]\n\n"}
{"name":"Finset.addConst_empty_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddGroup G\ninstâœ : DecidableEq G\nA : Finset G\nâŠ¢ Eq (A.addConst EmptyCollection.emptyCollection) 0","decl":"@[to_additive (attr := simp)]\nlemma mulConst_empty_right (A : Finset G) : Ïƒâ‚˜[A, âˆ…] = 0 := by simp [mulConst]\n\n"}
{"name":"Finset.mulConst_empty_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : Group G\ninstâœ : DecidableEq G\nA : Finset G\nâŠ¢ Eq (A.mulConst EmptyCollection.emptyCollection) 0","decl":"@[to_additive (attr := simp)]\nlemma mulConst_empty_right (A : Finset G) : Ïƒâ‚˜[A, âˆ…] = 0 := by simp [mulConst]\n\n"}
{"name":"Finset.divConst_empty_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : Group G\ninstâœ : DecidableEq G\nA : Finset G\nâŠ¢ Eq (A.divConst EmptyCollection.emptyCollection) 0","decl":"@[to_additive (attr := simp)]\nlemma divConst_empty_right (A : Finset G) : Î´â‚˜[A, âˆ…] = 0 := by simp [divConst]\n\n"}
{"name":"Finset.subConst_empty_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddGroup G\ninstâœ : DecidableEq G\nA : Finset G\nâŠ¢ Eq (A.subConst EmptyCollection.emptyCollection) 0","decl":"@[to_additive (attr := simp)]\nlemma divConst_empty_right (A : Finset G) : Î´â‚˜[A, âˆ…] = 0 := by simp [divConst]\n\n"}
{"name":"Finset.mulConst_inv_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : Group G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq (A.mulConst (Inv.inv B)) (A.divConst B)","decl":"@[to_additive (attr := simp)]\nlemma mulConst_inv_right (A B : Finset G) : Ïƒâ‚˜[A, Bâ»Â¹] = Î´â‚˜[A, B] := by\n  rw [mulConst, divConst, â† div_eq_mul_inv]\n\n"}
{"name":"Finset.addConst_neg_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddGroup G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq (A.addConst (Neg.neg B)) (A.subConst B)","decl":"@[to_additive (attr := simp)]\nlemma mulConst_inv_right (A B : Finset G) : Ïƒâ‚˜[A, Bâ»Â¹] = Î´â‚˜[A, B] := by\n  rw [mulConst, divConst, â† div_eq_mul_inv]\n\n"}
{"name":"Finset.subConst_neg_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddGroup G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq (A.subConst (Neg.neg B)) (A.addConst B)","decl":"@[to_additive (attr := simp)]\nlemma divConst_inv_right (A B : Finset G) : Î´â‚˜[A, Bâ»Â¹] = Ïƒâ‚˜[A, B] := by\n  rw [mulConst, divConst, div_inv_eq_mul]\n\n"}
{"name":"Finset.divConst_inv_right","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : Group G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq (A.divConst (Inv.inv B)) (A.mulConst B)","decl":"@[to_additive (attr := simp)]\nlemma divConst_inv_right (A B : Finset G) : Î´â‚˜[A, Bâ»Â¹] = Ïƒâ‚˜[A, B] := by\n  rw [mulConst, divConst, div_inv_eq_mul]\n\n"}
{"name":"Finset.addConst_le_inv_dens","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : DecidableEq G\nA B : Finset G\ninstâœ : Fintype G\nâŠ¢ LE.le (A.addConst B) (Inv.inv A.dens)","decl":"/-- Dense sets have small doubling. -/\n@[to_additive addConst_le_inv_dens \"Dense sets have small doubling.\"]\nlemma mulConst_le_inv_dens : Ïƒâ‚˜[A, B] â‰¤ A.densâ»Â¹ := by\n  rw [dens, inv_div, mulConst]; gcongr; exact card_le_univ _\n\n"}
{"name":"Finset.mulConst_le_inv_dens","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ² : Group G\ninstâœÂ¹ : DecidableEq G\nA B : Finset G\ninstâœ : Fintype G\nâŠ¢ LE.le (A.mulConst B) (Inv.inv A.dens)","decl":"/-- Dense sets have small doubling. -/\n@[to_additive addConst_le_inv_dens \"Dense sets have small doubling.\"]\nlemma mulConst_le_inv_dens : Ïƒâ‚˜[A, B] â‰¤ A.densâ»Â¹ := by\n  rw [dens, inv_div, mulConst]; gcongr; exact card_le_univ _\n\n"}
{"name":"Finset.subConst_le_inv_dens","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : DecidableEq G\nA B : Finset G\ninstâœ : Fintype G\nâŠ¢ LE.le (A.subConst B) (Inv.inv A.dens)","decl":"/-- Dense sets have small difference constant. -/\n@[to_additive subConst_le_inv_dens \"Dense sets have small difference constant.\"]\nlemma divConst_le_inv_dens : Î´â‚˜[A, B] â‰¤ A.densâ»Â¹ := by\n  rw [dens, inv_div, divConst]; gcongr; exact card_le_univ _\n\n"}
{"name":"Finset.divConst_le_inv_dens","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ² : Group G\ninstâœÂ¹ : DecidableEq G\nA B : Finset G\ninstâœ : Fintype G\nâŠ¢ LE.le (A.divConst B) (Inv.inv A.dens)","decl":"/-- Dense sets have small difference constant. -/\n@[to_additive subConst_le_inv_dens \"Dense sets have small difference constant.\"]\nlemma divConst_le_inv_dens : Î´â‚˜[A, B] â‰¤ A.densâ»Â¹ := by\n  rw [dens, inv_div, divConst]; gcongr; exact card_le_univ _\n\n"}
{"name":"Finset.cast_addConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G' : Type u_2\ninstâœÂ³ : AddGroup G'\ninstâœÂ² : DecidableEq G'\nğ•œ : Type u_3\ninstâœÂ¹ : Semifield ğ•œ\ninstâœ : CharZero ğ•œ\nA B : Finset G'\nâŠ¢ Eq (â†‘(A.addConst B)) (HDiv.hDiv â†‘(HAdd.hAdd A B).card â†‘A.card)","decl":"lemma cast_addConst (A B : Finset G') : (Ïƒ[A, B] : ğ•œ) = #(A + B) / #A := by\n  simp [addConst]\n\n"}
{"name":"Finset.cast_subConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G' : Type u_2\ninstâœÂ³ : AddGroup G'\ninstâœÂ² : DecidableEq G'\nğ•œ : Type u_3\ninstâœÂ¹ : Semifield ğ•œ\ninstâœ : CharZero ğ•œ\nA B : Finset G'\nâŠ¢ Eq (â†‘(A.subConst B)) (HDiv.hDiv â†‘(HSub.hSub A B).card â†‘A.card)","decl":"lemma cast_subConst (A B : Finset G') : (Î´[A, B] : ğ•œ) = #(A - B) / #A := by\n  simp [subConst]\n\n"}
{"name":"Finset.cast_mulConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ³ : Group G\ninstâœÂ² : DecidableEq G\nğ•œ : Type u_3\ninstâœÂ¹ : Semifield ğ•œ\ninstâœ : CharZero ğ•œ\nA B : Finset G\nâŠ¢ Eq (â†‘(A.mulConst B)) (HDiv.hDiv â†‘(HMul.hMul A B).card â†‘A.card)","decl":"@[to_additive existing]\nlemma cast_mulConst (A B : Finset G) : (Ïƒâ‚˜[A, B] : ğ•œ) = #(A * B) / #A := by simp [mulConst]\n\n"}
{"name":"Finset.cast_divConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ³ : Group G\ninstâœÂ² : DecidableEq G\nğ•œ : Type u_3\ninstâœÂ¹ : Semifield ğ•œ\ninstâœ : CharZero ğ•œ\nA B : Finset G\nâŠ¢ Eq (â†‘(A.divConst B)) (HDiv.hDiv â†‘(HDiv.hDiv A B).card â†‘A.card)","decl":"@[to_additive existing]\nlemma cast_divConst (A B : Finset G) : (Î´â‚˜[A, B] : ğ•œ) = #(A / B) / #A := by simp [divConst]\n\n"}
{"name":"Finset.cast_addConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G' : Type u_2\ninstâœÂ³ : AddGroup G'\ninstâœÂ² : DecidableEq G'\nğ•œ : Type u_3\ninstâœÂ¹ : Semifield ğ•œ\ninstâœ : CharZero ğ•œ\nA B : Finset G'\nâŠ¢ Eq (HMul.hMul â†‘(A.addConst B) â†‘A.card) â†‘(HAdd.hAdd A B).card","decl":"lemma cast_addConst_mul_card (A B : Finset G') : (Ïƒ[A, B] * #A : ğ•œ) = #(A + B) := by\n  norm_cast; exact addConst_mul_card _ _\n\n"}
{"name":"Finset.cast_subConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G' : Type u_2\ninstâœÂ³ : AddGroup G'\ninstâœÂ² : DecidableEq G'\nğ•œ : Type u_3\ninstâœÂ¹ : Semifield ğ•œ\ninstâœ : CharZero ğ•œ\nA B : Finset G'\nâŠ¢ Eq (HMul.hMul â†‘(A.subConst B) â†‘A.card) â†‘(HSub.hSub A B).card","decl":"lemma cast_subConst_mul_card (A B : Finset G') : (Î´[A, B] * #A : ğ•œ) = #(A - B) := by\n  norm_cast; exact subConst_mul_card _ _\n\n"}
{"name":"Finset.card_mul_cast_addConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G' : Type u_2\ninstâœÂ³ : AddGroup G'\ninstâœÂ² : DecidableEq G'\nğ•œ : Type u_3\ninstâœÂ¹ : Semifield ğ•œ\ninstâœ : CharZero ğ•œ\nA B : Finset G'\nâŠ¢ Eq (HMul.hMul â†‘A.card â†‘(A.addConst B)) â†‘(HAdd.hAdd A B).card","decl":"lemma card_mul_cast_addConst (A B : Finset G') : (#A * Ïƒ[A, B] : ğ•œ) = #(A + B) := by\n  norm_cast; exact card_mul_addConst _ _\n\n"}
{"name":"Finset.card_mul_cast_subConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G' : Type u_2\ninstâœÂ³ : AddGroup G'\ninstâœÂ² : DecidableEq G'\nğ•œ : Type u_3\ninstâœÂ¹ : Semifield ğ•œ\ninstâœ : CharZero ğ•œ\nA B : Finset G'\nâŠ¢ Eq (HMul.hMul â†‘A.card â†‘(A.subConst B)) â†‘(HSub.hSub A B).card","decl":"lemma card_mul_cast_subConst (A B : Finset G') : (#A * Î´[A, B] : ğ•œ) = #(A - B) := by\n  norm_cast; exact card_mul_subConst _ _\n\n"}
{"name":"Finset.cast_mulConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ³ : Group G\ninstâœÂ² : DecidableEq G\nğ•œ : Type u_3\ninstâœÂ¹ : Semifield ğ•œ\ninstâœ : CharZero ğ•œ\nA B : Finset G\nâŠ¢ Eq (HMul.hMul â†‘(A.mulConst B) â†‘A.card) â†‘(HMul.hMul A B).card","decl":"@[to_additive (attr := simp) existing cast_addConst_mul_card]\nlemma cast_mulConst_mul_card (A B : Finset G) : (Ïƒâ‚˜[A, B] * #A : ğ•œ) = #(A * B) := by\n  norm_cast; exact mulConst_mul_card _ _\n\n"}
{"name":"Finset.cast_divConst_mul_card","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ³ : Group G\ninstâœÂ² : DecidableEq G\nğ•œ : Type u_3\ninstâœÂ¹ : Semifield ğ•œ\ninstâœ : CharZero ğ•œ\nA B : Finset G\nâŠ¢ Eq (HMul.hMul â†‘(A.divConst B) â†‘A.card) â†‘(HDiv.hDiv A B).card","decl":"@[to_additive (attr := simp) existing cast_subConst_mul_card]\nlemma cast_divConst_mul_card (A B : Finset G) : (Î´â‚˜[A, B] * #A : ğ•œ) = #(A / B) := by\n  norm_cast; exact divConst_mul_card _ _\n\n"}
{"name":"Finset.card_mul_cast_mulConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ³ : Group G\ninstâœÂ² : DecidableEq G\nğ•œ : Type u_3\ninstâœÂ¹ : Semifield ğ•œ\ninstâœ : CharZero ğ•œ\nA B : Finset G\nâŠ¢ Eq (HMul.hMul â†‘A.card â†‘(A.mulConst B)) â†‘(HMul.hMul A B).card","decl":"@[to_additive (attr := simp) existing card_mul_cast_addConst]\nlemma card_mul_cast_mulConst (A B : Finset G) : (#A * Ïƒâ‚˜[A, B] : ğ•œ) = #(A * B) := by\n  norm_cast; exact card_mul_mulConst _ _\n\n"}
{"name":"Finset.card_mul_cast_divConst","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ³ : Group G\ninstâœÂ² : DecidableEq G\nğ•œ : Type u_3\ninstâœÂ¹ : Semifield ğ•œ\ninstâœ : CharZero ğ•œ\nA B : Finset G\nâŠ¢ Eq (HMul.hMul â†‘A.card â†‘(A.divConst B)) â†‘(HDiv.hDiv A B).card","decl":"@[to_additive (attr := simp) existing card_mul_cast_subConst]\nlemma card_mul_cast_divConst (A B : Finset G) : (#A * Î´â‚˜[A, B] : ğ•œ) = #(A / B) := by\n  norm_cast; exact card_mul_divConst _ _\n\n"}
{"name":"Finset.mulConst_inv_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : CommGroup G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq ((Inv.inv A).mulConst B) (A.divConst B)","decl":"@[to_additive (attr := simp)]\nlemma mulConst_inv_left (A B : Finset G) : Ïƒâ‚˜[Aâ»Â¹, B] = Î´â‚˜[A, B] := by\n  rw [mulConst, divConst, card_inv, â† card_inv, mul_inv_rev, inv_inv, inv_mul_eq_div]\n\n"}
{"name":"Finset.addConst_neg_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddCommGroup G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq ((Neg.neg A).addConst B) (A.subConst B)","decl":"@[to_additive (attr := simp)]\nlemma mulConst_inv_left (A B : Finset G) : Ïƒâ‚˜[Aâ»Â¹, B] = Î´â‚˜[A, B] := by\n  rw [mulConst, divConst, card_inv, â† card_inv, mul_inv_rev, inv_inv, inv_mul_eq_div]\n\n"}
{"name":"Finset.divConst_inv_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : CommGroup G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq ((Inv.inv A).divConst B) (A.mulConst B)","decl":"@[to_additive (attr := simp)]\nlemma divConst_inv_left (A B : Finset G) : Î´â‚˜[Aâ»Â¹, B] = Ïƒâ‚˜[A, B] := by\n  rw [mulConst, divConst, card_inv, â† card_inv, inv_div, div_inv_eq_mul, mul_comm]\n\n"}
{"name":"Finset.subConst_neg_left","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddCommGroup G\ninstâœ : DecidableEq G\nA B : Finset G\nâŠ¢ Eq ((Neg.neg A).subConst B) (A.addConst B)","decl":"@[to_additive (attr := simp)]\nlemma divConst_inv_left (A B : Finset G) : Î´â‚˜[Aâ»Â¹, B] = Ïƒâ‚˜[A, B] := by\n  rw [mulConst, divConst, card_inv, â† card_inv, inv_div, div_inv_eq_mul, mul_comm]\n\n"}
{"name":"Finset.addConst_le_subConst_sq","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddCommGroup G\ninstâœ : DecidableEq G\nA : Finset G\nâŠ¢ LE.le (A.addConst A) (HPow.hPow (A.subConst A) 2)","decl":"/-- If `A` has small difference, then it has small doubling, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality. -/\n@[to_additive\n\"If `A` has small difference, then it has small doubling, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality.\"]\nlemma mulConst_le_divConst_sq : Ïƒâ‚˜[A] â‰¤ Î´â‚˜[A] ^ 2 := by\n  obtain rfl | hA' := A.eq_empty_or_nonempty\n  Â· simp\n  refine le_of_mul_le_mul_right ?_ (by positivity : (0 : â„šâ‰¥0) < #A * #A)\n  calc\n    _ = #(A * A) * (#A : â„šâ‰¥0) := by rw [â† mul_assoc, mulConst_mul_card]\n    _ â‰¤ #(A / A) * #(A / A) := by norm_cast; exact ruzsa_triangle_inequality_mul_div_div ..\n    _ = _ := by rw [â† divConst_mul_card]; ring\n\n"}
{"name":"Finset.mulConst_le_divConst_sq","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : CommGroup G\ninstâœ : DecidableEq G\nA : Finset G\nâŠ¢ LE.le (A.mulConst A) (HPow.hPow (A.divConst A) 2)","decl":"/-- If `A` has small difference, then it has small doubling, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality. -/\n@[to_additive\n\"If `A` has small difference, then it has small doubling, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality.\"]\nlemma mulConst_le_divConst_sq : Ïƒâ‚˜[A] â‰¤ Î´â‚˜[A] ^ 2 := by\n  obtain rfl | hA' := A.eq_empty_or_nonempty\n  Â· simp\n  refine le_of_mul_le_mul_right ?_ (by positivity : (0 : â„šâ‰¥0) < #A * #A)\n  calc\n    _ = #(A * A) * (#A : â„šâ‰¥0) := by rw [â† mul_assoc, mulConst_mul_card]\n    _ â‰¤ #(A / A) * #(A / A) := by norm_cast; exact ruzsa_triangle_inequality_mul_div_div ..\n    _ = _ := by rw [â† divConst_mul_card]; ring\n\n"}
{"name":"Finset.divConst_le_mulConst_sq","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : CommGroup G\ninstâœ : DecidableEq G\nA : Finset G\nâŠ¢ LE.le (A.divConst A) (HPow.hPow (A.mulConst A) 2)","decl":"/-- If `A` has small doubling, then it has small difference, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality. -/\n@[to_additive\n\"If `A` has small doubling, then it has small difference, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality.\"]\nlemma divConst_le_mulConst_sq : Î´â‚˜[A] â‰¤ Ïƒâ‚˜[A] ^ 2 := by\n  obtain rfl | hA' := A.eq_empty_or_nonempty\n  Â· simp\n  refine le_of_mul_le_mul_right ?_ (by positivity : (0 : â„šâ‰¥0) < #A * #A)\n  calc\n    _ = #(A / A) * (#A : â„šâ‰¥0) := by rw [â† mul_assoc, divConst_mul_card]\n    _ â‰¤ #(A * A) * #(A * A) := by norm_cast; exact ruzsa_triangle_inequality_div_mul_mul ..\n    _ = _ := by rw [â† mulConst_mul_card]; ring\n\n"}
{"name":"Finset.subConst_le_addConst_sq","module":"Mathlib.Combinatorics.Additive.DoublingConst","initialProofState":"G : Type u_1\ninstâœÂ¹ : AddCommGroup G\ninstâœ : DecidableEq G\nA : Finset G\nâŠ¢ LE.le (A.subConst A) (HPow.hPow (A.addConst A) 2)","decl":"/-- If `A` has small doubling, then it has small difference, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality. -/\n@[to_additive\n\"If `A` has small doubling, then it has small difference, with the constant squared.\n\nThis is a consequence of the Ruzsa triangle inequality.\"]\nlemma divConst_le_mulConst_sq : Î´â‚˜[A] â‰¤ Ïƒâ‚˜[A] ^ 2 := by\n  obtain rfl | hA' := A.eq_empty_or_nonempty\n  Â· simp\n  refine le_of_mul_le_mul_right ?_ (by positivity : (0 : â„šâ‰¥0) < #A * #A)\n  calc\n    _ = #(A / A) * (#A : â„šâ‰¥0) := by rw [â† mul_assoc, divConst_mul_card]\n    _ â‰¤ #(A * A) * #(A * A) := by norm_cast; exact ruzsa_triangle_inequality_div_mul_mul ..\n    _ = _ := by rw [â† mulConst_mul_card]; ring\n\n"}
