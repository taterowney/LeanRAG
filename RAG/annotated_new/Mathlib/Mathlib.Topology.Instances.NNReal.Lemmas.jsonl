{"name":"NNReal.isOpen_Ico_zero","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"x : NNReal\n‚ä¢ IsOpen (Set.Ico 0 x)","decl":"lemma isOpen_Ico_zero {x : NNReal} : IsOpen (Set.Ico 0 x) :=\n  Ico_bot (a := x) ‚ñ∏ isOpen_Iio\n\n"}
{"name":"continuous_real_toNNReal","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"‚ä¢ Continuous Real.toNNReal","decl":"theorem _root_.continuous_real_toNNReal : Continuous Real.toNNReal :=\n  (continuous_id.max continuous_const).subtype_mk _\n\n"}
{"name":"ContinuousMap.realToNNReal_apply","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"‚ä¢ Eq (‚áëContinuousMap.realToNNReal) Real.toNNReal","decl":"/-- `Real.toNNReal` bundled as a continuous map for convenience. -/\n@[simps (config := .asFn)]\nnoncomputable def _root_.ContinuousMap.realToNNReal : C(‚Ñù, ‚Ñù‚â•0) :=\n  .mk Real.toNNReal continuous_real_toNNReal\n\n"}
{"name":"ContinuousOn.ofReal_map_toNNReal","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"f : NNReal ‚Üí NNReal\ns : Set Real\nt : Set NNReal\nhf : ContinuousOn f t\nh : Set.MapsTo Real.toNNReal s t\n‚ä¢ ContinuousOn (fun x => ‚Üë(f x.toNNReal)) s","decl":"lemma _root_.ContinuousOn.ofReal_map_toNNReal {f : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0} {s : Set ‚Ñù} {t : Set ‚Ñù‚â•0}\n    (hf : ContinuousOn f t) (h : Set.MapsTo Real.toNNReal s t) :\n    ContinuousOn (fun x ‚Ü¶ f x.toNNReal : ‚Ñù ‚Üí ‚Ñù) s :=\n  continuous_subtype_val.comp_continuousOn <| hf.comp continuous_real_toNNReal.continuousOn h\n\n"}
{"name":"NNReal.tendsto_coe","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\nm : Œ± ‚Üí NNReal\nx : NNReal\n‚ä¢ Iff (Filter.Tendsto (fun a => ‚Üë(m a)) f (nhds ‚Üëx)) (Filter.Tendsto m f (nhds x))","decl":"@[simp, norm_cast]\ntheorem tendsto_coe {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù‚â•0} {x : ‚Ñù‚â•0} :\n    Tendsto (fun a => (m a : ‚Ñù)) f (ùìù (x : ‚Ñù)) ‚Üî Tendsto m f (ùìù x) :=\n  tendsto_subtype_rng.symm\n\n"}
{"name":"NNReal.tendsto_coe'","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\ninst‚úù : f.NeBot\nm : Œ± ‚Üí NNReal\nx : Real\n‚ä¢ Iff (Filter.Tendsto (fun a => ‚Üë(m a)) f (nhds x)) (Exists fun hx => Filter.Tendsto m f (nhds ‚ü®x, hx‚ü©))","decl":"theorem tendsto_coe' {f : Filter Œ±} [NeBot f] {m : Œ± ‚Üí ‚Ñù‚â•0} {x : ‚Ñù} :\n    Tendsto (fun a => m a : Œ± ‚Üí ‚Ñù) f (ùìù x) ‚Üî ‚àÉ hx : 0 ‚â§ x, Tendsto m f (ùìù ‚ü®x, hx‚ü©) :=\n  ‚ü®fun h => ‚ü®ge_of_tendsto' h fun c => (m c).2, tendsto_coe.1 h‚ü©, fun ‚ü®_, hm‚ü© => tendsto_coe.2 hm‚ü©\n\n"}
{"name":"NNReal.map_coe_atTop","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"‚ä¢ Eq (Filter.map NNReal.toReal Filter.atTop) Filter.atTop","decl":"@[simp] theorem map_coe_atTop : map toReal atTop = atTop := map_val_Ici_atTop 0\n\n"}
{"name":"NNReal.comap_coe_atTop","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"‚ä¢ Eq (Filter.comap NNReal.toReal Filter.atTop) Filter.atTop","decl":"@[simp]\ntheorem comap_coe_atTop : comap toReal atTop = atTop := (atTop_Ici_eq 0).symm\n\n"}
{"name":"NNReal.tendsto_coe_atTop","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\nm : Œ± ‚Üí NNReal\n‚ä¢ Iff (Filter.Tendsto (fun a => ‚Üë(m a)) f Filter.atTop) (Filter.Tendsto m f Filter.atTop)","decl":"@[simp, norm_cast]\ntheorem tendsto_coe_atTop {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù‚â•0} :\n    Tendsto (fun a => (m a : ‚Ñù)) f atTop ‚Üî Tendsto m f atTop :=\n  tendsto_Ici_atTop.symm\n\n"}
{"name":"tendsto_real_toNNReal","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\nm : Œ± ‚Üí Real\nx : Real\nh : Filter.Tendsto m f (nhds x)\n‚ä¢ Filter.Tendsto (fun a => (m a).toNNReal) f (nhds x.toNNReal)","decl":"theorem _root_.tendsto_real_toNNReal {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù} {x : ‚Ñù} (h : Tendsto m f (ùìù x)) :\n    Tendsto (fun a => Real.toNNReal (m a)) f (ùìù (Real.toNNReal x)) :=\n  (continuous_real_toNNReal.tendsto _).comp h\n\n"}
{"name":"Real.map_toNNReal_atTop","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"‚ä¢ Eq (Filter.map Real.toNNReal Filter.atTop) Filter.atTop","decl":"@[simp]\ntheorem _root_.Real.map_toNNReal_atTop : map Real.toNNReal atTop = atTop := by\n  rw [‚Üê map_coe_atTop, Function.LeftInverse.filter_map @Real.toNNReal_coe]\n\n"}
{"name":"tendsto_real_toNNReal_atTop","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"‚ä¢ Filter.Tendsto Real.toNNReal Filter.atTop Filter.atTop","decl":"theorem _root_.tendsto_real_toNNReal_atTop : Tendsto Real.toNNReal atTop atTop :=\n  Real.map_toNNReal_atTop.le\n\n"}
{"name":"Real.comap_toNNReal_atTop","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"‚ä¢ Eq (Filter.comap Real.toNNReal Filter.atTop) Filter.atTop","decl":"@[simp]\ntheorem _root_.Real.comap_toNNReal_atTop : comap Real.toNNReal atTop = atTop := by\n  refine le_antisymm ?_ tendsto_real_toNNReal_atTop.le_comap\n  refine (atTop_basis_Ioi' 0).ge_iff.2 fun a ha ‚Ü¶ ?_\n  filter_upwards [preimage_mem_comap (Ioi_mem_atTop a.toNNReal)] with x hx\n  exact (Real.toNNReal_lt_toNNReal_iff_of_nonneg ha.le).1 hx\n\n"}
{"name":"Real.tendsto_toNNReal_atTop_iff","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Real\n‚ä¢ Iff (Filter.Tendsto (fun x => (f x).toNNReal) l Filter.atTop) (Filter.Tendsto f l Filter.atTop)","decl":"@[simp]\ntheorem _root_.Real.tendsto_toNNReal_atTop_iff {l : Filter Œ±} {f : Œ± ‚Üí ‚Ñù} :\n    Tendsto (fun x ‚Ü¶ (f x).toNNReal) l atTop ‚Üî Tendsto f l atTop := by\n  rw [‚Üê Real.comap_toNNReal_atTop, tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"Real.tendsto_toNNReal_atTop","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"‚ä¢ Filter.Tendsto Real.toNNReal Filter.atTop Filter.atTop","decl":"theorem _root_.Real.tendsto_toNNReal_atTop : Tendsto Real.toNNReal atTop atTop :=\n  Real.tendsto_toNNReal_atTop_iff.2 tendsto_id\n\n"}
{"name":"NNReal.nhds_zero","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"‚ä¢ Eq (nhds 0) (iInf fun a => iInf fun x => Filter.principal (Set.Iio a))","decl":"theorem nhds_zero : ùìù (0 : ‚Ñù‚â•0) = ‚®Ö (a : ‚Ñù‚â•0) (_ : a ‚â† 0), ùìü (Iio a) :=\n  nhds_bot_order.trans <| by simp only [bot_lt_iff_ne_bot]; rfl\n\n"}
{"name":"NNReal.nhds_zero_basis","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"‚ä¢ (nhds 0).HasBasis (fun a => LT.lt 0 a) fun a => Set.Iio a","decl":"theorem nhds_zero_basis : (ùìù (0 : ‚Ñù‚â•0)).HasBasis (fun a : ‚Ñù‚â•0 => 0 < a) fun a => Iio a :=\n  nhds_bot_basis\n\n\n"}
{"name":"NNReal.hasSum_coe","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí NNReal\nr : NNReal\n‚ä¢ Iff (HasSum (fun a => ‚Üë(f a)) ‚Üër) (HasSum f r)","decl":"@[norm_cast]\ntheorem hasSum_coe {f : Œ± ‚Üí ‚Ñù‚â•0} {r : ‚Ñù‚â•0} : HasSum (fun a => (f a : ‚Ñù)) (r : ‚Ñù) ‚Üî HasSum f r := by\n  simp only [HasSum, ‚Üê coe_sum, tendsto_coe]\n\n"}
{"name":"HasSum.toNNReal","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Real\ny : Real\nhf‚ÇÄ : ‚àÄ (n : Œ±), LE.le 0 (f n)\nhy : HasSum f y\n‚ä¢ HasSum (fun x => (f x).toNNReal) y.toNNReal","decl":"protected theorem _root_.HasSum.toNNReal {f : Œ± ‚Üí ‚Ñù} {y : ‚Ñù} (hf‚ÇÄ : ‚àÄ n, 0 ‚â§ f n)\n    (hy : HasSum f y) : HasSum (fun x => Real.toNNReal (f x)) y.toNNReal := by\n  lift y to ‚Ñù‚â•0 using hy.nonneg hf‚ÇÄ\n  lift f to Œ± ‚Üí ‚Ñù‚â•0 using hf‚ÇÄ\n  simpa [hasSum_coe] using hy\n\n"}
{"name":"NNReal.hasSum_real_toNNReal_of_nonneg","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Real\nhf_nonneg : ‚àÄ (n : Œ±), LE.le 0 (f n)\nhf : Summable f\n‚ä¢ HasSum (fun n => (f n).toNNReal) (tsum fun n => f n).toNNReal","decl":"theorem hasSum_real_toNNReal_of_nonneg {f : Œ± ‚Üí ‚Ñù} (hf_nonneg : ‚àÄ n, 0 ‚â§ f n) (hf : Summable f) :\n    HasSum (fun n => Real.toNNReal (f n)) (Real.toNNReal (‚àë' n, f n)) :=\n  hf.hasSum.toNNReal hf_nonneg\n\n"}
{"name":"NNReal.summable_coe","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí NNReal\n‚ä¢ Iff (Summable fun a => ‚Üë(f a)) (Summable f)","decl":"@[norm_cast]\ntheorem summable_coe {f : Œ± ‚Üí ‚Ñù‚â•0} : (Summable fun a => (f a : ‚Ñù)) ‚Üî Summable f := by\n  constructor\n  ¬∑ exact fun ‚ü®a, ha‚ü© => ‚ü®‚ü®a, ha.nonneg fun x => (f x).2‚ü©, hasSum_coe.1 ha‚ü©\n  ¬∑ exact fun ‚ü®a, ha‚ü© => ‚ü®a.1, hasSum_coe.2 ha‚ü©\n\n"}
{"name":"NNReal.summable_mk","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Real\nhf : ‚àÄ (n : Œ±), LE.le 0 (f n)\n‚ä¢ Iff (Summable fun n => ‚ü®f n, ‚ãØ‚ü©) (Summable f)","decl":"theorem summable_mk {f : Œ± ‚Üí ‚Ñù} (hf : ‚àÄ n, 0 ‚â§ f n) :\n    (@Summable ‚Ñù‚â•0 _ _ _ fun n => ‚ü®f n, hf n‚ü©) ‚Üî Summable f :=\n  Iff.symm <| summable_coe (f := fun x => ‚ü®f x, hf x‚ü©)\n\n"}
{"name":"NNReal.coe_tsum","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí NNReal\n‚ä¢ Eq (‚Üë(tsum fun a => f a)) (tsum fun a => ‚Üë(f a))","decl":"@[norm_cast]\ntheorem coe_tsum {f : Œ± ‚Üí ‚Ñù‚â•0} : ‚Üë(‚àë' a, f a) = ‚àë' a, (f a : ‚Ñù) := by\n  classical\n  exact if hf : Summable f then Eq.symm <| (hasSum_coe.2 <| hf.hasSum).tsum_eq\n  else by simp [tsum_def, hf, mt summable_coe.1 hf]\n\n"}
{"name":"NNReal.coe_tsum_of_nonneg","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Real\nhf‚ÇÅ : ‚àÄ (n : Œ±), LE.le 0 (f n)\n‚ä¢ Eq ‚ü®tsum fun n => f n, ‚ãØ‚ü© (tsum fun n => ‚ü®f n, ‚ãØ‚ü©)","decl":"theorem coe_tsum_of_nonneg {f : Œ± ‚Üí ‚Ñù} (hf‚ÇÅ : ‚àÄ n, 0 ‚â§ f n) :\n    (‚ü®‚àë' n, f n, tsum_nonneg hf‚ÇÅ‚ü© : ‚Ñù‚â•0) = (‚àë' n, ‚ü®f n, hf‚ÇÅ n‚ü© : ‚Ñù‚â•0) :=\n  NNReal.eq <| Eq.symm <| coe_tsum (f := fun x => ‚ü®f x, hf‚ÇÅ x‚ü©)\n\n"}
{"name":"NNReal.tsum_mul_left","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\na : NNReal\nf : Œ± ‚Üí NNReal\n‚ä¢ Eq (tsum fun x => HMul.hMul a (f x)) (HMul.hMul a (tsum fun x => f x))","decl":"nonrec theorem tsum_mul_left (a : ‚Ñù‚â•0) (f : Œ± ‚Üí ‚Ñù‚â•0) : ‚àë' x, a * f x = a * ‚àë' x, f x :=\n  NNReal.eq <| by simp only [coe_tsum, NNReal.coe_mul, tsum_mul_left]\n\n"}
{"name":"NNReal.tsum_mul_right","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí NNReal\na : NNReal\n‚ä¢ Eq (tsum fun x => HMul.hMul (f x) a) (HMul.hMul (tsum fun x => f x) a)","decl":"nonrec theorem tsum_mul_right (f : Œ± ‚Üí ‚Ñù‚â•0) (a : ‚Ñù‚â•0) : ‚àë' x, f x * a = (‚àë' x, f x) * a :=\n  NNReal.eq <| by simp only [coe_tsum, NNReal.coe_mul, tsum_mul_right]\n\n"}
{"name":"NNReal.summable_comp_injective","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Œ± ‚Üí NNReal\nhf : Summable f\ni : Œ≤ ‚Üí Œ±\nhi : Function.Injective i\n‚ä¢ Summable (Function.comp f i)","decl":"theorem summable_comp_injective {Œ≤ : Type*} {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Summable f) {i : Œ≤ ‚Üí Œ±}\n    (hi : Function.Injective i) : Summable (f ‚àò i) := by\n  rw [‚Üê summable_coe] at hf ‚ä¢\n  exact hf.comp_injective hi\n\n"}
{"name":"NNReal.summable_nat_add","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"f : Nat ‚Üí NNReal\nhf : Summable f\nk : Nat\n‚ä¢ Summable fun i => f (HAdd.hAdd i k)","decl":"theorem summable_nat_add (f : ‚Ñï ‚Üí ‚Ñù‚â•0) (hf : Summable f) (k : ‚Ñï) : Summable fun i => f (i + k) :=\n  summable_comp_injective hf <| add_left_injective k\n\n"}
{"name":"NNReal.summable_nat_add_iff","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"f : Nat ‚Üí NNReal\nk : Nat\n‚ä¢ Iff (Summable fun i => f (HAdd.hAdd i k)) (Summable f)","decl":"nonrec theorem summable_nat_add_iff {f : ‚Ñï ‚Üí ‚Ñù‚â•0} (k : ‚Ñï) :\n    (Summable fun i => f (i + k)) ‚Üî Summable f := by\n  rw [‚Üê summable_coe, ‚Üê summable_coe]\n  exact @summable_nat_add_iff ‚Ñù _ _ _ (fun i => (f i : ‚Ñù)) k\n\n"}
{"name":"NNReal.hasSum_nat_add_iff","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"f : Nat ‚Üí NNReal\nk : Nat\na : NNReal\n‚ä¢ Iff (HasSum (fun n => f (HAdd.hAdd n k)) a) (HasSum f (HAdd.hAdd a ((Finset.range k).sum fun i => f i)))","decl":"nonrec theorem hasSum_nat_add_iff {f : ‚Ñï ‚Üí ‚Ñù‚â•0} (k : ‚Ñï) {a : ‚Ñù‚â•0} :\n    HasSum (fun n => f (n + k)) a ‚Üî HasSum f (a + ‚àë i ‚àà range k, f i) := by\n  rw [‚Üê hasSum_coe, hasSum_nat_add_iff (f := fun n => toReal (f n)) k]; norm_cast\n\n"}
{"name":"NNReal.sum_add_tsum_nat_add","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"f : Nat ‚Üí NNReal\nk : Nat\nhf : Summable f\n‚ä¢ Eq (tsum fun i => f i) (HAdd.hAdd ((Finset.range k).sum fun i => f i) (tsum fun i => f (HAdd.hAdd i k)))","decl":"theorem sum_add_tsum_nat_add {f : ‚Ñï ‚Üí ‚Ñù‚â•0} (k : ‚Ñï) (hf : Summable f) :\n    ‚àë' i, f i = (‚àë i ‚àà range k, f i) + ‚àë' i, f (i + k) :=\n  (sum_add_tsum_nat_add' <| (summable_nat_add_iff k).2 hf).symm\n\n"}
{"name":"NNReal.iInf_real_pos_eq_iInf_nnreal_pos","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\nf : Real ‚Üí Œ±\n‚ä¢ Eq (iInf fun n => iInf fun x => f n) (iInf fun n => iInf fun x => f ‚Üën)","decl":"theorem iInf_real_pos_eq_iInf_nnreal_pos [CompleteLattice Œ±] {f : ‚Ñù ‚Üí Œ±} :\n    ‚®Ö (n : ‚Ñù) (_ : 0 < n), f n = ‚®Ö (n : ‚Ñù‚â•0) (_ : 0 < n), f n :=\n  le_antisymm (iInf_mono' fun r => ‚ü®r, le_rfl‚ü©) (iInf‚ÇÇ_mono' fun r hr => ‚ü®‚ü®r, hr.le‚ü©, hr, le_rfl‚ü©)\n\n"}
{"name":"NNReal.tendsto_cofinite_zero_of_summable","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_2\nf : Œ± ‚Üí NNReal\nhf : Summable f\n‚ä¢ Filter.Tendsto f Filter.cofinite (nhds 0)","decl":"theorem tendsto_cofinite_zero_of_summable {Œ±} {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Summable f) :\n    Tendsto f cofinite (ùìù 0) := by\n  simp only [‚Üê summable_coe, ‚Üê tendsto_coe] at hf ‚ä¢\n  exact hf.tendsto_cofinite_zero\n\n"}
{"name":"NNReal.tendsto_atTop_zero_of_summable","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"f : Nat ‚Üí NNReal\nhf : Summable f\n‚ä¢ Filter.Tendsto f Filter.atTop (nhds 0)","decl":"theorem tendsto_atTop_zero_of_summable {f : ‚Ñï ‚Üí ‚Ñù‚â•0} (hf : Summable f) : Tendsto f atTop (ùìù 0) := by\n  rw [‚Üê Nat.cofinite_eq_atTop]\n  exact tendsto_cofinite_zero_of_summable hf\n\n"}
{"name":"NNReal.tendsto_tsum_compl_atTop_zero","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"Œ± : Type u_2\nf : Œ± ‚Üí NNReal\n‚ä¢ Filter.Tendsto (fun s => tsum fun b => f ‚Üëb) Filter.atTop (nhds 0)","decl":"/-- The sum over the complement of a finset tends to `0` when the finset grows to cover the whole\nspace. This does not need a summability assumption, as otherwise all sums are zero. -/\nnonrec theorem tendsto_tsum_compl_atTop_zero {Œ± : Type*} (f : Œ± ‚Üí ‚Ñù‚â•0) :\n    Tendsto (fun s : Finset Œ± => ‚àë' b : { x // x ‚àâ s }, f b) atTop (ùìù 0) := by\n  simp_rw [‚Üê tendsto_coe, coe_tsum, NNReal.coe_zero]\n  exact tendsto_tsum_compl_atTop_zero fun a : Œ± => (f a : ‚Ñù)\n\n"}
{"name":"Real.tendsto_of_bddAbove_monotone","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"f : Nat ‚Üí Real\nh_bdd : BddAbove (Set.range f)\nh_mon : Monotone f\n‚ä¢ Exists fun r => Filter.Tendsto f Filter.atTop (nhds r)","decl":"/-- A monotone, bounded above sequence `f : ‚Ñï ‚Üí ‚Ñù` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddAbove_monotone {f : ‚Ñï ‚Üí ‚Ñù} (h_bdd : BddAbove (Set.range f))\n    (h_mon : Monotone f) : ‚àÉ r : ‚Ñù, Tendsto f atTop (ùìù r) := by\n  obtain ‚ü®B, hB‚ü© := Real.exists_isLUB (Set.range_nonempty f) h_bdd\n  exact ‚ü®B, tendsto_atTop_isLUB h_mon hB‚ü©\n\n"}
{"name":"Real.tendsto_of_bddBelow_antitone","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"f : Nat ‚Üí Real\nh_bdd : BddBelow (Set.range f)\nh_ant : Antitone f\n‚ä¢ Exists fun r => Filter.Tendsto f Filter.atTop (nhds r)","decl":"/-- An antitone, bounded below sequence `f : ‚Ñï ‚Üí ‚Ñù` has a finite limit. -/\ntheorem _root_.Real.tendsto_of_bddBelow_antitone {f : ‚Ñï ‚Üí ‚Ñù} (h_bdd : BddBelow (Set.range f))\n    (h_ant : Antitone f) : ‚àÉ r : ‚Ñù, Tendsto f atTop (ùìù r) := by\n  obtain ‚ü®B, hB‚ü© := Real.exists_isGLB (Set.range_nonempty f) h_bdd\n  exact ‚ü®B, tendsto_atTop_isGLB h_ant hB‚ü©\n\n"}
{"name":"NNReal.tendsto_of_antitone","module":"Mathlib.Topology.Instances.NNReal.Lemmas","initialProofState":"f : Nat ‚Üí NNReal\nh_ant : Antitone f\n‚ä¢ Exists fun r => Filter.Tendsto f Filter.atTop (nhds r)","decl":"/-- An antitone sequence `f : ‚Ñï ‚Üí ‚Ñù‚â•0` has a finite limit. -/\ntheorem tendsto_of_antitone {f : ‚Ñï ‚Üí ‚Ñù‚â•0} (h_ant : Antitone f) :\n    ‚àÉ r : ‚Ñù‚â•0, Tendsto f atTop (ùìù r) := by\n  have h_bdd_0 : (0 : ‚Ñù) ‚àà lowerBounds (Set.range fun n : ‚Ñï => (f n : ‚Ñù)) := by\n    rintro r ‚ü®n, hn‚ü©\n    simp_rw [‚Üê hn]\n    exact NNReal.coe_nonneg _\n  obtain ‚ü®L, hL‚ü© := Real.tendsto_of_bddBelow_antitone ‚ü®0, h_bdd_0‚ü© h_ant\n  have hL0 : 0 ‚â§ L :=\n    haveI h_glb : IsGLB (Set.range fun n => (f n : ‚Ñù)) L := isGLB_of_tendsto_atTop h_ant hL\n    (le_isGLB_iff h_glb).mpr h_bdd_0\n  exact ‚ü®‚ü®L, hL0‚ü©, NNReal.tendsto_coe.mp hL‚ü©\n\n"}
