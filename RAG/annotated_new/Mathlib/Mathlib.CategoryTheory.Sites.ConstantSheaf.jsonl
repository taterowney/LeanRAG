{"name":"CategoryTheory.constantPresheafAdj_counit_app_app","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nT : C\nhT : CategoryTheory.Limits.IsTerminal T\nF : CategoryTheory.Functor (Opposite C) D\nx✝ : Opposite C\n⊢ Eq (((CategoryTheory.constantPresheafAdj D hT).counit.app F).app x✝) (F.map (hT.from (Opposite.unop x✝)).op)","decl":"/-- The constant presheaf functor is left adjoint to evaluation at a terminal object. -/\n@[simps! unit_app counit_app_app]\nnoncomputable def constantPresheafAdj {T : C} (hT : IsTerminal T) :\n    Functor.const Cᵒᵖ ⊣ (evaluation Cᵒᵖ D).obj (op T) where\n  unit := (Functor.constCompEvaluationObj D (op T)).hom\n  counit := {\n    app := fun F => {\n      app := fun ⟨X⟩ => F.map (IsTerminal.from hT X).op\n      naturality := fun _ _ _ => by\n        simp only [Functor.comp_obj, Functor.const_obj_obj, Functor.id_obj, Functor.const_obj_map,\n          Category.id_comp, ← Functor.map_comp]\n        congr\n        simp }\n    naturality := by intros; ext; simp /- Note: `aesop` works but is kind of slow -/ }\n\n"}
{"name":"CategoryTheory.constantPresheafAdj_unit_app","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nT : C\nhT : CategoryTheory.Limits.IsTerminal T\nX : D\n⊢ Eq ((CategoryTheory.constantPresheafAdj D hT).unit.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The constant presheaf functor is left adjoint to evaluation at a terminal object. -/\n@[simps! unit_app counit_app_app]\nnoncomputable def constantPresheafAdj {T : C} (hT : IsTerminal T) :\n    Functor.const Cᵒᵖ ⊣ (evaluation Cᵒᵖ D).obj (op T) where\n  unit := (Functor.constCompEvaluationObj D (op T)).hom\n  counit := {\n    app := fun F => {\n      app := fun ⟨X⟩ => F.map (IsTerminal.from hT X).op\n      naturality := fun _ _ _ => by\n        simp only [Functor.comp_obj, Functor.const_obj_obj, Functor.id_obj, Functor.const_obj_map,\n          Category.id_comp, ← Functor.map_comp]\n        congr\n        simp }\n    naturality := by intros; ext; simp /- Note: `aesop` works but is kind of slow -/ }\n\n"}
{"name":"CategoryTheory.constantSheafAdj_counit_app","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nT : C\nhT : CategoryTheory.Limits.IsTerminal T\nX : CategoryTheory.Sheaf J D\n⊢ Eq ((CategoryTheory.constantSheafAdj J D hT).counit.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.presheafToSheaf J D).map ((CategoryTheory.constantPresheafAdj D hT).counit.app X.val)) ((CategoryTheory.sheafificationAdjunction J D).counit.app X))","decl":"/-- The constant sheaf functor is left adjoint to evaluation at a terminal object. -/\n@[simps! counit_app]\nnoncomputable def constantSheafAdj {T : C} (hT : IsTerminal T) :\n    constantSheaf J D ⊣ (sheafSections J D).obj (op T) :=\n  (constantPresheafAdj D hT).comp (sheafificationAdjunction J D)\n\n"}
{"name":"CategoryTheory.Sheaf.IsConstant.mem_essImage","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nF : CategoryTheory.Sheaf J D\nself : CategoryTheory.Sheaf.IsConstant J F\n⊢ Membership.mem (CategoryTheory.constantSheaf J D).essImage F","decl":"/--\nA sheaf is constant if it is in the essential image of the constant sheaf functor.\n-/\nclass IsConstant (F : Sheaf J D) : Prop where\n  mem_essImage : F ∈ (constantSheaf J D).essImage\n\n"}
{"name":"CategoryTheory.Sheaf.mem_essImage_of_isConstant","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.HasWeakSheafify J D\nF : CategoryTheory.Sheaf J D\ninst✝ : CategoryTheory.Sheaf.IsConstant J F\n⊢ Membership.mem (CategoryTheory.constantSheaf J D).essImage F","decl":"lemma mem_essImage_of_isConstant (F : Sheaf J D) [IsConstant J F] :\n    F ∈ (constantSheaf J D).essImage :=\n  IsConstant.mem_essImage\n\n"}
{"name":"CategoryTheory.Sheaf.isConstant_congr","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.HasWeakSheafify J D\nF G : CategoryTheory.Sheaf J D\ni : CategoryTheory.Iso F G\ninst✝ : CategoryTheory.Sheaf.IsConstant J F\n⊢ CategoryTheory.Sheaf.IsConstant J G","decl":"lemma isConstant_congr {F G : Sheaf J D} (i : F ≅ G) [IsConstant J F] : IsConstant J G where\n  mem_essImage := essImage.ofIso i F.mem_essImage_of_isConstant\n\n"}
{"name":"CategoryTheory.Sheaf.isConstant_of_iso","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nF : CategoryTheory.Sheaf J D\nX : D\ni : CategoryTheory.Iso F ((CategoryTheory.constantSheaf J D).obj X)\n⊢ CategoryTheory.Sheaf.IsConstant J F","decl":"lemma isConstant_of_iso {F : Sheaf J D} {X : D} (i : F ≅ (constantSheaf J D).obj X) :\n    IsConstant J F := ⟨_, ⟨i.symm⟩⟩\n\n"}
{"name":"CategoryTheory.Sheaf.isConstant_iff_mem_essImage","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nL : CategoryTheory.Functor D (CategoryTheory.Sheaf J D)\nT : C\nhT : CategoryTheory.Limits.IsTerminal T\nadj : CategoryTheory.Adjunction L ((CategoryTheory.sheafSections J D).obj { unop := T })\nF : CategoryTheory.Sheaf J D\n⊢ Iff (CategoryTheory.Sheaf.IsConstant J F) (Membership.mem L.essImage F)","decl":"lemma isConstant_iff_mem_essImage {L : D ⥤ Sheaf J D} {T : C} (hT : IsTerminal T)\n    (adj : L ⊣ (sheafSections J D).obj ⟨T⟩)\n    (F : Sheaf J D) : IsConstant J F ↔ F ∈ L.essImage := by\n  rw [essImage_eq_of_natIso (adj.leftAdjointUniq (constantSheafAdj J D hT))]\n  exact ⟨fun ⟨h⟩ ↦ h, fun h ↦ ⟨h⟩⟩\n\n"}
{"name":"CategoryTheory.Sheaf.isConstant_of_isIso_counit_app","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.HasWeakSheafify J D\nF : CategoryTheory.Sheaf J D\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.IsIso ((CategoryTheory.constantSheafAdj J D CategoryTheory.Limits.terminalIsTerminal).counit.app F)\n⊢ CategoryTheory.Sheaf.IsConstant J F","decl":"lemma isConstant_of_isIso_counit_app (F : Sheaf J D) [HasTerminal C]\n    [IsIso <| (constantSheafAdj J D terminalIsTerminal).counit.app F] : IsConstant J F where\n  mem_essImage := ⟨_, ⟨asIso <| (constantSheafAdj J D terminalIsTerminal).counit.app F⟩⟩\n\n"}
{"name":"CategoryTheory.Sheaf.instIsIsoAppCounitConstantSheafAdjOfFaithfulOfFullConstantSheafOfIsConstant","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} D\ninst✝³ : CategoryTheory.HasWeakSheafify J D\ninst✝² : (CategoryTheory.constantSheaf J D).Faithful\ninst✝¹ : (CategoryTheory.constantSheaf J D).Full\nF : CategoryTheory.Sheaf J D\ninst✝ : CategoryTheory.Sheaf.IsConstant J F\nT : C\nhT : CategoryTheory.Limits.IsTerminal T\n⊢ CategoryTheory.IsIso ((CategoryTheory.constantSheafAdj J D hT).counit.app F)","decl":"instance [(constantSheaf J D).Faithful] [(constantSheaf J D).Full] (F : Sheaf J D)\n    [IsConstant J F] {T : C} (hT : IsTerminal T) :\n    IsIso ((constantSheafAdj J D hT).counit.app F) := by\n  rw [isIso_counit_app_iff_mem_essImage]\n  exact F.mem_essImage_of_isConstant\n\n"}
{"name":"CategoryTheory.Sheaf.isConstant_iff_isIso_counit_app","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasWeakSheafify J D\ninst✝¹ : (CategoryTheory.constantSheaf J D).Faithful\ninst✝ : (CategoryTheory.constantSheaf J D).Full\nF : CategoryTheory.Sheaf J D\nT : C\nhT : CategoryTheory.Limits.IsTerminal T\n⊢ Iff (CategoryTheory.Sheaf.IsConstant J F) (CategoryTheory.IsIso ((CategoryTheory.constantSheafAdj J D hT).counit.app F))","decl":"/--\nIf the constant sheaf functor is fully faithful, then a sheaf is constant if and only if the\ncounit of the constant sheaf adjunction applied to it is an isomorphism.\n-/\nlemma isConstant_iff_isIso_counit_app [(constantSheaf J D).Faithful] [(constantSheaf J D).Full]\n    (F : Sheaf J D) {T : C} (hT : IsTerminal T) :\n      IsConstant J F ↔ (IsIso <| (constantSheafAdj J D hT).counit.app F) :=\n  ⟨fun _ ↦ inferInstance, fun _ ↦ ⟨_, ⟨asIso <| (constantSheafAdj J D hT).counit.app F⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Sheaf.isConstant_iff_isIso_counit_app'","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasWeakSheafify J D\nL : CategoryTheory.Functor D (CategoryTheory.Sheaf J D)\nT : C\nhT : CategoryTheory.Limits.IsTerminal T\nadj : CategoryTheory.Adjunction L ((CategoryTheory.sheafSections J D).obj { unop := T })\ninst✝¹ : L.Faithful\ninst✝ : L.Full\nF : CategoryTheory.Sheaf J D\n⊢ Iff (CategoryTheory.Sheaf.IsConstant J F) (CategoryTheory.IsIso (adj.counit.app F))","decl":"/--\nA variant of `isConstant_iff_isIso_counit_app` for a general left adjoint to evaluation at a\nterminal object.\n-/\nlemma isConstant_iff_isIso_counit_app'  {L : D ⥤ Sheaf J D} {T : C} (hT : IsTerminal T)\n    (adj : L ⊣ (sheafSections J D).obj ⟨T⟩)\n    [L.Faithful] [L.Full] (F : Sheaf J D) : IsConstant J F ↔ IsIso (adj.counit.app F) :=\n  (isConstant_iff_mem_essImage J hT adj F).trans (isIso_counit_app_iff_mem_essImage adj).symm\n\n"}
{"name":"CategoryTheory.Sheaf.isConstant_iff_of_equivalence","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_6, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁴ : CategoryTheory.HasWeakSheafify J D\nC' : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C'\nK : CategoryTheory.GrothendieckTopology C'\ninst✝² : CategoryTheory.HasWeakSheafify K D\nG : CategoryTheory.Functor C C'\ninst✝¹ : ∀ (X : Opposite C'), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.StructuredArrow X G.op) D\ninst✝ : CategoryTheory.Functor.IsDenseSubsite J K G\nT : C\nhT : CategoryTheory.Limits.IsTerminal T\nhT' : CategoryTheory.Limits.IsTerminal (G.obj T)\nF : CategoryTheory.Sheaf K D\n⊢ Iff (CategoryTheory.Sheaf.IsConstant J ((CategoryTheory.Functor.IsDenseSubsite.sheafEquiv G J K D).inverse.obj F)) (CategoryTheory.Sheaf.IsConstant K F)","decl":"include hT hT' in\n/--\nThe property of a sheaf of being constant is invariant under equivalence of sheaf\ncategories.\n-/\nlemma Sheaf.isConstant_iff_of_equivalence (F : Sheaf K D) :\n    ((sheafEquiv G J K D).inverse.obj F).IsConstant J ↔ IsConstant K F := by\n  constructor\n  · exact fun ⟨Y, ⟨i⟩⟩ ↦ ⟨_, ⟨(equivCommuteConstant J D K G hT hT').symm.app _ ≪≫\n      (sheafEquiv G J K D).functor.mapIso i ≪≫ (sheafEquiv G J K D).counitIso.app _⟩⟩\n  · exact fun ⟨Y, ⟨i⟩⟩ ↦ ⟨_, ⟨(equivCommuteConstant' J D K G hT hT').app _ ≪≫\n      (sheafEquiv G J K D).inverse.mapIso i⟩⟩\n\n"}
{"name":"CategoryTheory.constantCommuteCompose_hom_app_val","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_5, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_2} D\ninst✝⁴ : CategoryTheory.HasWeakSheafify J D\nB : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} B\nU : CategoryTheory.Functor D B\ninst✝² : CategoryTheory.HasWeakSheafify J B\ninst✝¹ : J.PreservesSheafification U\ninst✝ : J.HasSheafCompose U\nX : D\n⊢ Eq ((CategoryTheory.constantCommuteCompose J U).hom.app X).val (CategoryTheory.CategoryStruct.comp (CategoryTheory.sheafifyComposeIso J U ((CategoryTheory.Functor.const (Opposite C)).obj X)).inv (CategoryTheory.sheafifyMap J (CategoryTheory.Functor.constComp (Opposite C) X U).hom))","decl":"lemma constantCommuteCompose_hom_app_val (X : D) : ((constantCommuteCompose J U).hom.app X).val =\n    (sheafifyComposeIso J U ((const Cᵒᵖ).obj X)).inv ≫ sheafifyMap J (constComp Cᵒᵖ X U).hom := rfl\n\n"}
{"name":"CategoryTheory.constantSheafAdj_counit_w","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_2} D\ninst✝⁴ : CategoryTheory.HasWeakSheafify J D\nB : Type u_3\ninst✝³ : CategoryTheory.Category.{u_5, u_3} B\nU : CategoryTheory.Functor D B\ninst✝² : CategoryTheory.HasWeakSheafify J B\ninst✝¹ : J.PreservesSheafification U\ninst✝ : J.HasSheafCompose U\nF : CategoryTheory.Sheaf J D\nT : C\nhT : CategoryTheory.Limits.IsTerminal T\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.constantCommuteCompose J U).hom.app (F.val.obj { unop := T })) ((CategoryTheory.constantSheafAdj J B hT).counit.app ((CategoryTheory.sheafCompose J U).obj F))) ((CategoryTheory.sheafCompose J U).map ((CategoryTheory.constantSheafAdj J D hT).counit.app F))","decl":"/-- The counit of `constantSheafAdj` factors through the isomorphism `constantCommuteCompose`. -/\nlemma constantSheafAdj_counit_w {T : C} (hT : IsTerminal T) :\n    ((constantCommuteCompose J U).hom.app (F.val.obj ⟨T⟩)) ≫\n      ((constantSheafAdj J B hT).counit.app ((sheafCompose J U).obj F)) =\n        ((sheafCompose J U).map ((constantSheafAdj J D hT).counit.app F)) := by\n  apply Sheaf.hom_ext\n  rw [instCategorySheaf_comp_val, constantCommuteCompose_hom_app_val, assoc, Iso.inv_comp_eq]\n  apply sheafify_hom_ext _ _ _ ((sheafCompose J U).obj F).cond\n  ext\n  simp? says simp only [comp_obj, const_obj_obj, sheafCompose_obj_val, id_obj,\n      constantSheafAdj_counit_app, instCategorySheaf_comp_val,\n      sheafificationAdjunction_counit_app_val, sheafifyMap_sheafifyLift, comp_id,\n      toSheafify_sheafifyLift, NatTrans.comp_app, constComp_hom_app,\n      constantPresheafAdj_counit_app_app, Functor.comp_map, id_comp, flip_obj_obj,\n      sheafToPresheaf_obj, map_comp, sheafCompose_map_val, sheafComposeIso_hom_fac_assoc,\n      whiskerRight_app]\n  simp [← map_comp, ← NatTrans.comp_app]\n\n"}
{"name":"CategoryTheory.Sheaf.isConstant_of_forget","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝¹² : CategoryTheory.Category.{u_5, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝¹¹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹⁰ : CategoryTheory.HasWeakSheafify J D\nB : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_6, u_3} B\nU : CategoryTheory.Functor D B\ninst✝⁸ : CategoryTheory.HasWeakSheafify J B\ninst✝⁷ : J.PreservesSheafification U\ninst✝⁶ : J.HasSheafCompose U\nF : CategoryTheory.Sheaf J D\ninst✝⁵ : (CategoryTheory.constantSheaf J D).Faithful\ninst✝⁴ : (CategoryTheory.constantSheaf J D).Full\ninst✝³ : (CategoryTheory.constantSheaf J B).Faithful\ninst✝² : (CategoryTheory.constantSheaf J B).Full\ninst✝¹ : (CategoryTheory.sheafCompose J U).ReflectsIsomorphisms\ninst✝ : CategoryTheory.Sheaf.IsConstant J ((CategoryTheory.sheafCompose J U).obj F)\nT : C\nhT : CategoryTheory.Limits.IsTerminal T\n⊢ CategoryTheory.Sheaf.IsConstant J F","decl":"lemma Sheaf.isConstant_of_forget [constantSheaf J D |>.Faithful] [constantSheaf J D |>.Full]\n    [constantSheaf J B |>.Faithful] [constantSheaf J B |>.Full]\n    [(sheafCompose J U).ReflectsIsomorphisms] [((sheafCompose J U).obj F).IsConstant J]\n    {T : C} (hT : IsTerminal T) : F.IsConstant J := by\n  have : IsIso ((sheafCompose J U).map ((constantSheafAdj J D hT).counit.app F)) := by\n    rw [← constantSheafAdj_counit_w]\n    infer_instance\n  rw [F.isConstant_iff_isIso_counit_app (hT := hT)]\n  exact isIso_of_reflects_iso _ (sheafCompose J U)\n\n"}
{"name":"CategoryTheory.instIsConstantObjSheafSheafCompose","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\ninst✝³ : CategoryTheory.HasWeakSheafify J D\nB : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} B\nU : CategoryTheory.Functor D B\ninst✝¹ : CategoryTheory.HasWeakSheafify J B\ninst✝ : J.HasSheafCompose U\nF : CategoryTheory.Sheaf J D\nh : CategoryTheory.Sheaf.IsConstant J F\n⊢ CategoryTheory.Sheaf.IsConstant J ((CategoryTheory.sheafCompose J U).obj F)","decl":"instance [h : F.IsConstant J] : ((sheafCompose J U).obj F).IsConstant J := by\n  obtain ⟨Y, ⟨i⟩⟩ := h\n  exact ⟨U.obj Y, ⟨(fullyFaithfulSheafToPresheaf _ _).preimageIso\n    (((sheafifyComposeIso J U ((const Cᵒᵖ).obj Y)).symm ≪≫\n      (presheafToSheaf J B ⋙ sheafToPresheaf J B).mapIso (constComp Cᵒᵖ Y U)).symm ≪≫\n        (sheafToPresheaf _ _).mapIso ((sheafCompose J U).mapIso i))⟩⟩\n\n"}
{"name":"CategoryTheory.Sheaf.isConstant_iff_forget","module":"Mathlib.CategoryTheory.Sites.ConstantSheaf","initialProofState":"C : Type u_1\ninst✝¹¹ : CategoryTheory.Category.{u_5, u_1} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁹ : CategoryTheory.HasWeakSheafify J D\nB : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_6, u_3} B\nU : CategoryTheory.Functor D B\ninst✝⁷ : CategoryTheory.HasWeakSheafify J B\ninst✝⁶ : J.PreservesSheafification U\ninst✝⁵ : J.HasSheafCompose U\nF : CategoryTheory.Sheaf J D\ninst✝⁴ : (CategoryTheory.constantSheaf J D).Faithful\ninst✝³ : (CategoryTheory.constantSheaf J D).Full\ninst✝² : (CategoryTheory.constantSheaf J B).Faithful\ninst✝¹ : (CategoryTheory.constantSheaf J B).Full\ninst✝ : (CategoryTheory.sheafCompose J U).ReflectsIsomorphisms\nT : C\nhT : CategoryTheory.Limits.IsTerminal T\n⊢ Iff (CategoryTheory.Sheaf.IsConstant J F) (CategoryTheory.Sheaf.IsConstant J ((CategoryTheory.sheafCompose J U).obj F))","decl":"lemma Sheaf.isConstant_iff_forget [constantSheaf J D |>.Faithful] [constantSheaf J D |>.Full]\n    [constantSheaf J B |>.Faithful] [constantSheaf J B |>.Full]\n      [(sheafCompose J U).ReflectsIsomorphisms] {T : C} (hT : IsTerminal T) :\n        F.IsConstant J ↔ ((sheafCompose J U).obj F).IsConstant J :=\n  ⟨fun _ ↦ inferInstance, fun _ ↦ Sheaf.isConstant_of_forget _ U F hT⟩\n\n"}
