{"name":"Multiset.coe_range","module":"Mathlib.Data.Multiset.Range","initialProofState":"n : Nat\n⊢ Eq (↑(List.range n)) (Multiset.range n)","decl":"theorem coe_range (n : ℕ) : ↑(List.range n) = range n :=\n  rfl\n\n"}
{"name":"Multiset.range_zero","module":"Mathlib.Data.Multiset.Range","initialProofState":"⊢ Eq (Multiset.range 0) 0","decl":"@[simp]\ntheorem range_zero : range 0 = 0 :=\n  rfl\n\n"}
{"name":"Multiset.range_succ","module":"Mathlib.Data.Multiset.Range","initialProofState":"n : Nat\n⊢ Eq (Multiset.range n.succ) (Multiset.cons n (Multiset.range n))","decl":"@[simp]\ntheorem range_succ (n : ℕ) : range (succ n) = n ::ₘ range n := by\n  rw [range, List.range_succ, ← coe_add, Multiset.add_comm]; rfl\n\n"}
{"name":"Multiset.card_range","module":"Mathlib.Data.Multiset.Range","initialProofState":"n : Nat\n⊢ Eq (Multiset.range n).card n","decl":"@[simp]\ntheorem card_range (n : ℕ) : card (range n) = n :=\n  length_range _\n\n"}
{"name":"Multiset.range_subset","module":"Mathlib.Data.Multiset.Range","initialProofState":"m n : Nat\n⊢ Iff (HasSubset.Subset (Multiset.range m) (Multiset.range n)) (LE.le m n)","decl":"theorem range_subset {m n : ℕ} : range m ⊆ range n ↔ m ≤ n :=\n  List.range_subset\n\n"}
{"name":"Multiset.mem_range","module":"Mathlib.Data.Multiset.Range","initialProofState":"m n : Nat\n⊢ Iff (Membership.mem (Multiset.range n) m) (LT.lt m n)","decl":"@[simp]\ntheorem mem_range {m n : ℕ} : m ∈ range n ↔ m < n :=\n  List.mem_range\n\n"}
{"name":"Multiset.not_mem_range_self","module":"Mathlib.Data.Multiset.Range","initialProofState":"n : Nat\n⊢ Not (Membership.mem (Multiset.range n) n)","decl":"theorem not_mem_range_self {n : ℕ} : n ∉ range n :=\n  List.not_mem_range_self\n\n"}
{"name":"Multiset.self_mem_range_succ","module":"Mathlib.Data.Multiset.Range","initialProofState":"n : Nat\n⊢ Membership.mem (Multiset.range (HAdd.hAdd n 1)) n","decl":"theorem self_mem_range_succ (n : ℕ) : n ∈ range (n + 1) :=\n  List.self_mem_range_succ n\n\n"}
{"name":"Multiset.range_add","module":"Mathlib.Data.Multiset.Range","initialProofState":"a b : Nat\n⊢ Eq (Multiset.range (HAdd.hAdd a b)) (HAdd.hAdd (Multiset.range a) (Multiset.map (fun x => HAdd.hAdd a x) (Multiset.range b)))","decl":"theorem range_add (a b : ℕ) : range (a + b) = range a + (range b).map (a + ·) :=\n  congr_arg ((↑) : List ℕ → Multiset ℕ) (List.range_add _ _)\n\n"}
{"name":"Multiset.range_disjoint_map_add","module":"Mathlib.Data.Multiset.Range","initialProofState":"a : Nat\nm : Multiset Nat\n⊢ Disjoint (Multiset.range a) (Multiset.map (fun x => HAdd.hAdd a x) m)","decl":"theorem range_disjoint_map_add (a : ℕ) (m : Multiset ℕ) :\n    Disjoint (range a) (m.map (a + ·)) := by\n  rw [disjoint_left]\n  intro x hxa hxb\n  rw [range, mem_coe, List.mem_range] at hxa\n  obtain ⟨c, _, rfl⟩ := mem_map.1 hxb\n  exact (Nat.le_add_right _ _).not_lt hxa\n\n"}
{"name":"Multiset.range_add_eq_union","module":"Mathlib.Data.Multiset.Range","initialProofState":"a b : Nat\n⊢ Eq (Multiset.range (HAdd.hAdd a b)) (Union.union (Multiset.range a) (Multiset.map (fun x => HAdd.hAdd a x) (Multiset.range b)))","decl":"theorem range_add_eq_union (a b : ℕ) : range (a + b) = range a ∪ (range b).map (a + ·) := by\n  rw [range_add, add_eq_union_iff_disjoint]\n  apply range_disjoint_map_add\n\n"}
