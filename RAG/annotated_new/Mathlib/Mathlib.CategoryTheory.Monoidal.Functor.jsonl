{"name":"CategoryTheory.Functor.LaxMonoidal.right_unitality'","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.LaxMonoidal\nX : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) CategoryTheory.Functor.LaxMonoidal.ε') (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ' X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))","decl":"/-- A functor `F : C ⥤ D` between monoidal categories is lax monoidal if it is\nequipped with morphisms `ε : 𝟙_ D ⟶ F.obj (𝟙_ C)` and `μ X Y : F.obj X ⊗ F.obj Y ⟶ F.obj (X ⊗ Y)`,\nsatisfying the appropriate coherences. -/\nclass LaxMonoidal where\n  /-- unit morphism -/\n  ε' : 𝟙_ D ⟶ F.obj (𝟙_ C)\n  /-- tensorator -/\n  μ' : ∀ X Y : C, F.obj X ⊗ F.obj Y ⟶ F.obj (X ⊗ Y)\n  μ'_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      F.map f ▷ F.obj X' ≫ μ' Y X' = μ' X X' ≫ F.map (f ▷ X') := by\n    aesop_cat\n  μ'_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      F.obj X' ◁ F.map f ≫ μ' X' Y = μ' X' X ≫ F.map (X' ◁ f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity' :\n    ∀ X Y Z : C,\n      μ' X Y ▷ F.obj Z ≫ μ' (X ⊗ Y) Z ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ μ' Y Z ≫ μ' X (Y ⊗ Z) := by\n    aesop_cat\n  -- unitality\n  left_unitality' :\n    ∀ X : C, (λ_ (F.obj X)).hom = ε' ▷ F.obj X ≫ μ' (𝟙_ C) X ≫ F.map (λ_ X).hom := by\n      aesop_cat\n  right_unitality' :\n    ∀ X : C, (ρ_ (F.obj X)).hom = F.obj X ◁ ε' ≫ μ' X (𝟙_ C) ≫ F.map (ρ_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.left_unitality'","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.LaxMonoidal\nX : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight CategoryTheory.Functor.LaxMonoidal.ε' (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ' CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))","decl":"/-- A functor `F : C ⥤ D` between monoidal categories is lax monoidal if it is\nequipped with morphisms `ε : 𝟙_ D ⟶ F.obj (𝟙_ C)` and `μ X Y : F.obj X ⊗ F.obj Y ⟶ F.obj (X ⊗ Y)`,\nsatisfying the appropriate coherences. -/\nclass LaxMonoidal where\n  /-- unit morphism -/\n  ε' : 𝟙_ D ⟶ F.obj (𝟙_ C)\n  /-- tensorator -/\n  μ' : ∀ X Y : C, F.obj X ⊗ F.obj Y ⟶ F.obj (X ⊗ Y)\n  μ'_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      F.map f ▷ F.obj X' ≫ μ' Y X' = μ' X X' ≫ F.map (f ▷ X') := by\n    aesop_cat\n  μ'_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      F.obj X' ◁ F.map f ≫ μ' X' Y = μ' X' X ≫ F.map (X' ◁ f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity' :\n    ∀ X Y Z : C,\n      μ' X Y ▷ F.obj Z ≫ μ' (X ⊗ Y) Z ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ μ' Y Z ≫ μ' X (Y ⊗ Z) := by\n    aesop_cat\n  -- unitality\n  left_unitality' :\n    ∀ X : C, (λ_ (F.obj X)).hom = ε' ▷ F.obj X ≫ μ' (𝟙_ C) X ≫ F.map (λ_ X).hom := by\n      aesop_cat\n  right_unitality' :\n    ∀ X : C, (ρ_ (F.obj X)).hom = F.obj X ◁ ε' ≫ μ' X (𝟙_ C) ≫ F.map (ρ_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.μ'_natural_right","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.LaxMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (CategoryTheory.Functor.LaxMonoidal.μ' X' Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ' X' X) (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))","decl":"/-- A functor `F : C ⥤ D` between monoidal categories is lax monoidal if it is\nequipped with morphisms `ε : 𝟙_ D ⟶ F.obj (𝟙_ C)` and `μ X Y : F.obj X ⊗ F.obj Y ⟶ F.obj (X ⊗ Y)`,\nsatisfying the appropriate coherences. -/\nclass LaxMonoidal where\n  /-- unit morphism -/\n  ε' : 𝟙_ D ⟶ F.obj (𝟙_ C)\n  /-- tensorator -/\n  μ' : ∀ X Y : C, F.obj X ⊗ F.obj Y ⟶ F.obj (X ⊗ Y)\n  μ'_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      F.map f ▷ F.obj X' ≫ μ' Y X' = μ' X X' ≫ F.map (f ▷ X') := by\n    aesop_cat\n  μ'_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      F.obj X' ◁ F.map f ≫ μ' X' Y = μ' X' X ≫ F.map (X' ◁ f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity' :\n    ∀ X Y Z : C,\n      μ' X Y ▷ F.obj Z ≫ μ' (X ⊗ Y) Z ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ μ' Y Z ≫ μ' X (Y ⊗ Z) := by\n    aesop_cat\n  -- unitality\n  left_unitality' :\n    ∀ X : C, (λ_ (F.obj X)).hom = ε' ▷ F.obj X ≫ μ' (𝟙_ C) X ≫ F.map (λ_ X).hom := by\n      aesop_cat\n  right_unitality' :\n    ∀ X : C, (ρ_ (F.obj X)).hom = F.obj X ◁ ε' ≫ μ' X (𝟙_ C) ≫ F.map (ρ_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.μ'_natural_left","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.LaxMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (CategoryTheory.Functor.LaxMonoidal.μ' Y X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ' X X') (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))","decl":"/-- A functor `F : C ⥤ D` between monoidal categories is lax monoidal if it is\nequipped with morphisms `ε : 𝟙_ D ⟶ F.obj (𝟙_ C)` and `μ X Y : F.obj X ⊗ F.obj Y ⟶ F.obj (X ⊗ Y)`,\nsatisfying the appropriate coherences. -/\nclass LaxMonoidal where\n  /-- unit morphism -/\n  ε' : 𝟙_ D ⟶ F.obj (𝟙_ C)\n  /-- tensorator -/\n  μ' : ∀ X Y : C, F.obj X ⊗ F.obj Y ⟶ F.obj (X ⊗ Y)\n  μ'_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      F.map f ▷ F.obj X' ≫ μ' Y X' = μ' X X' ≫ F.map (f ▷ X') := by\n    aesop_cat\n  μ'_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      F.obj X' ◁ F.map f ≫ μ' X' Y = μ' X' X ≫ F.map (X' ◁ f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity' :\n    ∀ X Y Z : C,\n      μ' X Y ▷ F.obj Z ≫ μ' (X ⊗ Y) Z ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ μ' Y Z ≫ μ' X (Y ⊗ Z) := by\n    aesop_cat\n  -- unitality\n  left_unitality' :\n    ∀ X : C, (λ_ (F.obj X)).hom = ε' ▷ F.obj X ≫ μ' (𝟙_ C) X ≫ F.map (λ_ X).hom := by\n      aesop_cat\n  right_unitality' :\n    ∀ X : C, (ρ_ (F.obj X)).hom = F.obj X ◁ ε' ≫ μ' X (𝟙_ C) ≫ F.map (ρ_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.associativity'","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.LaxMonoidal\nX Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.μ' X Y) (F.obj Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ' (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.μ' Y Z)) (CategoryTheory.Functor.LaxMonoidal.μ' X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))","decl":"/-- A functor `F : C ⥤ D` between monoidal categories is lax monoidal if it is\nequipped with morphisms `ε : 𝟙_ D ⟶ F.obj (𝟙_ C)` and `μ X Y : F.obj X ⊗ F.obj Y ⟶ F.obj (X ⊗ Y)`,\nsatisfying the appropriate coherences. -/\nclass LaxMonoidal where\n  /-- unit morphism -/\n  ε' : 𝟙_ D ⟶ F.obj (𝟙_ C)\n  /-- tensorator -/\n  μ' : ∀ X Y : C, F.obj X ⊗ F.obj Y ⟶ F.obj (X ⊗ Y)\n  μ'_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      F.map f ▷ F.obj X' ≫ μ' Y X' = μ' X X' ≫ F.map (f ▷ X') := by\n    aesop_cat\n  μ'_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      F.obj X' ◁ F.map f ≫ μ' X' Y = μ' X' X ≫ F.map (X' ◁ f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity' :\n    ∀ X Y Z : C,\n      μ' X Y ▷ F.obj Z ≫ μ' (X ⊗ Y) Z ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ μ' Y Z ≫ μ' X (Y ⊗ Z) := by\n    aesop_cat\n  -- unitality\n  left_unitality' :\n    ∀ X : C, (λ_ (F.obj X)).hom = ε' ▷ F.obj X ≫ μ' (𝟙_ C) X ≫ F.map (λ_ X).hom := by\n      aesop_cat\n  right_unitality' :\n    ∀ X : C, (ρ_ (F.obj X)).hom = F.obj X ◁ ε' ≫ μ' X (𝟙_ C) ≫ F.map (ρ_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.μ_natural_left","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (CategoryTheory.Functor.LaxMonoidal.μ F Y X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X X') (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))","decl":"@[reassoc (attr := simp)]\nlemma μ_natural_left {X Y : C} (f : X ⟶ Y) (X' : C) :\n    F.map f ▷ F.obj X' ≫ μ F Y X' = μ F X X' ≫ F.map (f ▷ X') := by\n  apply μ'_natural_left\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.μ_natural_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y X')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F Y X') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X X') (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')) h))","decl":"@[reassoc (attr := simp)]\nlemma μ_natural_left {X Y : C} (f : X ⟶ Y) (X' : C) :\n    F.map f ▷ F.obj X' ≫ μ F Y X' = μ F X X' ≫ F.map (f ▷ X') := by\n  apply μ'_natural_left\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.μ_natural_right","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (CategoryTheory.Functor.LaxMonoidal.μ F X' Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X' X) (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))","decl":"@[reassoc (attr := simp)]\nlemma μ_natural_right {X Y : C} (X' : C) (f : X ⟶ Y) :\n    F.obj X' ◁ F.map f ≫ μ F X' Y = μ F X' X ≫ F.map (X' ◁ f) := by\n  apply μ'_natural_right\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.μ_natural_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X' Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X' Y) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X' X) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)) h))","decl":"@[reassoc (attr := simp)]\nlemma μ_natural_right {X Y : C} (X' : C) (f : X ⟶ Y) :\n    F.obj X' ◁ F.map f ≫ μ F X' Y = μ F X' X ≫ F.map (X' ◁ f) := by\n  apply μ'_natural_right\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.associativity","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.μ F X Y) (F.obj Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.μ F Y Z)) (CategoryTheory.Functor.LaxMonoidal.μ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))","decl":"@[reassoc (attr := simp)]\nlemma associativity (X Y Z : C) :\n    μ F X Y ▷ F.obj Z ≫ μ F (X ⊗ Y) Z ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ μ F Y Z ≫ μ F X (Y ⊗ Z) := by\n  apply associativity'\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.associativity_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX Y Z✝ : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.μ F X Y) (F.obj Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z✝)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.μ F Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) h)))","decl":"@[reassoc (attr := simp)]\nlemma associativity (X Y Z : C) :\n    μ F X Y ▷ F.obj Z ≫ μ F (X ⊗ Y) Z ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ μ F Y Z ≫ μ F X (Y ⊗ Z) := by\n  apply associativity'\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.left_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.ε F) (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) h)))","decl":"@[simp, reassoc]\nlemma left_unitality (X : C) :\n    (λ_ (F.obj X)).hom = ε F ▷ F.obj X ≫ μ F (𝟙_ C) X ≫ F.map (λ_ X).hom := by\n  apply left_unitality'\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.left_unitality","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.ε F) (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))","decl":"@[simp, reassoc]\nlemma left_unitality (X : C) :\n    (λ_ (F.obj X)).hom = ε F ▷ F.obj X ≫ μ F (𝟙_ C) X ≫ F.map (λ_ X).hom := by\n  apply left_unitality'\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.right_unitality","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.ε F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))","decl":"@[simp, reassoc]\nlemma right_unitality (X : C) :\n    (ρ_ (F.obj X)).hom = F.obj X ◁ ε F ≫ μ F X (𝟙_ C) ≫ F.map (ρ_ X).hom := by\n  apply right_unitality'\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.right_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.ε F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) h)))","decl":"@[simp, reassoc]\nlemma right_unitality (X : C) :\n    (ρ_ (F.obj X)).hom = F.obj X ◁ ε F ≫ μ F X (𝟙_ C) ≫ F.map (ρ_ X).hom := by\n  apply right_unitality'\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.μ_natural","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (CategoryTheory.Functor.LaxMonoidal.μ F Y Y')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X X') (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)))","decl":"@[reassoc (attr := simp)]\ntheorem μ_natural {X Y X' Y' : C} (f : X ⟶ Y) (g : X' ⟶ Y') :\n    (F.map f ⊗ F.map g) ≫ μ F Y Y' = μ F X X' ≫ F.map (f ⊗ g) := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.μ_natural_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Y')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F Y Y') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X X') (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) h))","decl":"@[reassoc (attr := simp)]\ntheorem μ_natural {X Y X' Y' : C} (f : X ⟶ Y) (g : X' ⟶ Y') :\n    (F.map f ⊗ F.map g) ≫ μ F Y Y' = μ F X X' ≫ F.map (f ⊗ g) := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.left_unitality_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.ε F) (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) h))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) h)","decl":"@[reassoc (attr := simp)]\ntheorem left_unitality_inv (X : C) :\n    (λ_ (F.obj X)).inv ≫ ε F ▷ F.obj X ≫ μ F (𝟙_ C) X = F.map (λ_ X).inv := by\n  rw [Iso.inv_comp_eq, left_unitality, Category.assoc, Category.assoc, ← F.map_comp,\n    Iso.hom_inv_id, F.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.left_unitality_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.ε F) (F.obj X)) (CategoryTheory.Functor.LaxMonoidal.μ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X))) (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv)","decl":"@[reassoc (attr := simp)]\ntheorem left_unitality_inv (X : C) :\n    (λ_ (F.obj X)).inv ≫ ε F ▷ F.obj X ≫ μ F (𝟙_ C) X = F.map (λ_ X).inv := by\n  rw [Iso.inv_comp_eq, left_unitality, Category.assoc, Category.assoc, ← F.map_comp,\n    Iso.hom_inv_id, F.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.right_unitality_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.ε F)) (CategoryTheory.Functor.LaxMonoidal.μ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit))) (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv)","decl":"@[reassoc (attr := simp)]\ntheorem right_unitality_inv (X : C) :\n    (ρ_ (F.obj X)).inv ≫ F.obj X ◁ ε F ≫ μ F X (𝟙_ C) = F.map (ρ_ X).inv := by\n  rw [Iso.inv_comp_eq, right_unitality, Category.assoc, Category.assoc, ← F.map_comp,\n    Iso.hom_inv_id, F.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.right_unitality_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X CategoryTheory.MonoidalCategoryStruct.tensorUnit)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.ε F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) h))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) h)","decl":"@[reassoc (attr := simp)]\ntheorem right_unitality_inv (X : C) :\n    (ρ_ (F.obj X)).inv ≫ F.obj X ◁ ε F ≫ μ F X (𝟙_ C) = F.map (ρ_ X).inv := by\n  rw [Iso.inv_comp_eq, right_unitality, Category.assoc, Category.assoc, ← F.map_comp,\n    Iso.hom_inv_id, F.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.associativity_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.μ F Y Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.μ F X Y) (F.obj Z)) (CategoryTheory.Functor.LaxMonoidal.μ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z)))","decl":"@[reassoc (attr := simp)]\ntheorem associativity_inv (X Y Z : C) :\n    F.obj X ◁ μ F Y Z ≫ μ F X (Y ⊗ Z) ≫ F.map (α_ X Y Z).inv =\n      (α_ (F.obj X) (F.obj Y) (F.obj Z)).inv ≫ μ F X Y ▷ F.obj Z ≫ μ F (X ⊗ Y) Z := by\n  rw [Iso.eq_inv_comp, ← associativity_assoc, ← F.map_comp, Iso.hom_inv_id,\n    F.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.associativity_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\nX Y Z✝ : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.μ F Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z✝)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.μ F X Y) (F.obj Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝) h)))","decl":"@[reassoc (attr := simp)]\ntheorem associativity_inv (X Y Z : C) :\n    F.obj X ◁ μ F Y Z ≫ μ F X (Y ⊗ Z) ≫ F.map (α_ X Y Z).inv =\n      (α_ (F.obj X) (F.obj Y) (F.obj Z)).inv ≫ μ F X Y ▷ F.obj Z ≫ μ F (X ⊗ Y) Z := by\n  rw [Iso.eq_inv_comp, ← associativity_assoc, ← F.map_comp, Iso.hom_inv_id,\n    F.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.ofTensorHom_ε","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nε' : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\n⊢ Eq (sorryAx (Unit → Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 196).num 4).num 196).num 7).num 4).num 7).str \"_sorry\").str \"_@\").str \"_hyg\").num 3184))) ε'","decl":"lemma ofTensorHom_ε :\n    letI := (ofTensorHom ε' μ' μ'_natural associativity' left_unitality' right_unitality')\n    ε F = ε' := rfl\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.ofTensorHom_μ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nμ' : (X Y : C) → Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\n⊢ Eq (sorryAx (Unit → (X Y : C) → Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 200).num 4).num 200).num 7).num 4).num 7).str \"_sorry\").str \"_@\").str \"_hyg\").num 3714))) μ'","decl":"lemma ofTensorHom_μ :\n    letI := (ofTensorHom ε' μ' μ'_natural associativity' left_unitality' right_unitality')\n    μ F = μ' := rfl\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.id_ε","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε (CategoryTheory.Functor.id C)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp]\nlemma id_ε : ε (𝟭 C) = 𝟙 _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.id_μ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ (CategoryTheory.Functor.id C) X Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.Functor.id C).obj X) ((CategoryTheory.Functor.id C).obj Y)))","decl":"@[simp]\nlemma id_μ (X Y : C) : μ (𝟭 C) X Y = 𝟙 _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.comp_ε","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.LaxMonoidal\ninst✝ : G.LaxMonoidal\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε (F.comp G)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.ε G) (G.map (CategoryTheory.Functor.LaxMonoidal.ε F)))","decl":"@[simp]\nlemma comp_ε : ε (F ⋙ G) = ε G ≫ G.map (ε F) := rfl\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.comp_μ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.LaxMonoidal\ninst✝ : G.LaxMonoidal\nX Y : C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ (F.comp G) X Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ G (F.obj X) (F.obj Y)) (G.map (CategoryTheory.Functor.LaxMonoidal.μ F X Y)))","decl":"@[simp]\nlemma comp_μ (X Y : C) : μ (F ⋙ G) X Y = μ G _ _ ≫ G.map (μ F X Y) := rfl\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.δ'_natural_right","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.OplaxMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ' X' X) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)) (CategoryTheory.Functor.OplaxMonoidal.δ' X' Y))","decl":"/-- A functor `F : C ⥤ D` between monoidal categories is oplax monoidal if it is\nequipped with morphisms `η : F.obj (𝟙_ C) ⟶ 𝟙 _D` and `δ X Y : F.obj (X ⊗ Y) ⟶ F.obj X ⊗ F.obj Y`,\nsatisfying the appropriate coherences. -/\nclass OplaxMonoidal where\n  /-- counit morphism -/\n  η' : F.obj (𝟙_ C) ⟶ 𝟙_ D\n  /-- cotensorator -/\n  δ' : ∀ X Y : C, F.obj (X ⊗ Y) ⟶ F.obj X ⊗ F.obj Y\n  δ'_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      δ' X X' ≫ F.map f ▷ F.obj X' = F.map (f ▷ X') ≫ δ' Y X' := by\n    aesop_cat\n  δ'_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      δ' X' X ≫ F.obj X' ◁ F.map f = F.map (X' ◁ f) ≫ δ' X' Y := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  oplax_associativity' :\n    ∀ X Y Z : C,\n      δ' (X ⊗ Y) Z ≫ δ' X Y ▷ F.obj Z ≫ (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n        F.map (α_ X Y Z).hom ≫ δ' X (Y ⊗ Z) ≫ F.obj X ◁ δ' Y Z := by\n    aesop_cat\n  -- unitality\n  oplax_left_unitality' :\n    ∀ X : C, (λ_ (F.obj X)).inv = F.map (λ_ X).inv ≫ δ' (𝟙_ C) X ≫ η' ▷ F.obj X := by\n      aesop_cat\n  oplax_right_unitality' :\n    ∀ X : C, (ρ_ (F.obj X)).inv = F.map (ρ_ X).inv ≫ δ' X (𝟙_ C) ≫ F.obj X ◁ η' := by\n      aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.oplax_right_unitality'","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.OplaxMonoidal\nX : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ' X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) CategoryTheory.Functor.OplaxMonoidal.η')))","decl":"/-- A functor `F : C ⥤ D` between monoidal categories is oplax monoidal if it is\nequipped with morphisms `η : F.obj (𝟙_ C) ⟶ 𝟙 _D` and `δ X Y : F.obj (X ⊗ Y) ⟶ F.obj X ⊗ F.obj Y`,\nsatisfying the appropriate coherences. -/\nclass OplaxMonoidal where\n  /-- counit morphism -/\n  η' : F.obj (𝟙_ C) ⟶ 𝟙_ D\n  /-- cotensorator -/\n  δ' : ∀ X Y : C, F.obj (X ⊗ Y) ⟶ F.obj X ⊗ F.obj Y\n  δ'_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      δ' X X' ≫ F.map f ▷ F.obj X' = F.map (f ▷ X') ≫ δ' Y X' := by\n    aesop_cat\n  δ'_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      δ' X' X ≫ F.obj X' ◁ F.map f = F.map (X' ◁ f) ≫ δ' X' Y := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  oplax_associativity' :\n    ∀ X Y Z : C,\n      δ' (X ⊗ Y) Z ≫ δ' X Y ▷ F.obj Z ≫ (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n        F.map (α_ X Y Z).hom ≫ δ' X (Y ⊗ Z) ≫ F.obj X ◁ δ' Y Z := by\n    aesop_cat\n  -- unitality\n  oplax_left_unitality' :\n    ∀ X : C, (λ_ (F.obj X)).inv = F.map (λ_ X).inv ≫ δ' (𝟙_ C) X ≫ η' ▷ F.obj X := by\n      aesop_cat\n  oplax_right_unitality' :\n    ∀ X : C, (ρ_ (F.obj X)).inv = F.map (ρ_ X).inv ≫ δ' X (𝟙_ C) ≫ F.obj X ◁ η' := by\n      aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.δ'_natural_left","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.OplaxMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ' X X') (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X'))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')) (CategoryTheory.Functor.OplaxMonoidal.δ' Y X'))","decl":"/-- A functor `F : C ⥤ D` between monoidal categories is oplax monoidal if it is\nequipped with morphisms `η : F.obj (𝟙_ C) ⟶ 𝟙 _D` and `δ X Y : F.obj (X ⊗ Y) ⟶ F.obj X ⊗ F.obj Y`,\nsatisfying the appropriate coherences. -/\nclass OplaxMonoidal where\n  /-- counit morphism -/\n  η' : F.obj (𝟙_ C) ⟶ 𝟙_ D\n  /-- cotensorator -/\n  δ' : ∀ X Y : C, F.obj (X ⊗ Y) ⟶ F.obj X ⊗ F.obj Y\n  δ'_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      δ' X X' ≫ F.map f ▷ F.obj X' = F.map (f ▷ X') ≫ δ' Y X' := by\n    aesop_cat\n  δ'_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      δ' X' X ≫ F.obj X' ◁ F.map f = F.map (X' ◁ f) ≫ δ' X' Y := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  oplax_associativity' :\n    ∀ X Y Z : C,\n      δ' (X ⊗ Y) Z ≫ δ' X Y ▷ F.obj Z ≫ (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n        F.map (α_ X Y Z).hom ≫ δ' X (Y ⊗ Z) ≫ F.obj X ◁ δ' Y Z := by\n    aesop_cat\n  -- unitality\n  oplax_left_unitality' :\n    ∀ X : C, (λ_ (F.obj X)).inv = F.map (λ_ X).inv ≫ δ' (𝟙_ C) X ≫ η' ▷ F.obj X := by\n      aesop_cat\n  oplax_right_unitality' :\n    ∀ X : C, (ρ_ (F.obj X)).inv = F.map (ρ_ X).inv ≫ δ' X (𝟙_ C) ≫ F.obj X ◁ η' := by\n      aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.oplax_left_unitality'","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.OplaxMonoidal\nX : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ' CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.MonoidalCategoryStruct.whiskerRight CategoryTheory.Functor.OplaxMonoidal.η' (F.obj X))))","decl":"/-- A functor `F : C ⥤ D` between monoidal categories is oplax monoidal if it is\nequipped with morphisms `η : F.obj (𝟙_ C) ⟶ 𝟙 _D` and `δ X Y : F.obj (X ⊗ Y) ⟶ F.obj X ⊗ F.obj Y`,\nsatisfying the appropriate coherences. -/\nclass OplaxMonoidal where\n  /-- counit morphism -/\n  η' : F.obj (𝟙_ C) ⟶ 𝟙_ D\n  /-- cotensorator -/\n  δ' : ∀ X Y : C, F.obj (X ⊗ Y) ⟶ F.obj X ⊗ F.obj Y\n  δ'_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      δ' X X' ≫ F.map f ▷ F.obj X' = F.map (f ▷ X') ≫ δ' Y X' := by\n    aesop_cat\n  δ'_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      δ' X' X ≫ F.obj X' ◁ F.map f = F.map (X' ◁ f) ≫ δ' X' Y := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  oplax_associativity' :\n    ∀ X Y Z : C,\n      δ' (X ⊗ Y) Z ≫ δ' X Y ▷ F.obj Z ≫ (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n        F.map (α_ X Y Z).hom ≫ δ' X (Y ⊗ Z) ≫ F.obj X ◁ δ' Y Z := by\n    aesop_cat\n  -- unitality\n  oplax_left_unitality' :\n    ∀ X : C, (λ_ (F.obj X)).inv = F.map (λ_ X).inv ≫ δ' (𝟙_ C) X ≫ η' ▷ F.obj X := by\n      aesop_cat\n  oplax_right_unitality' :\n    ∀ X : C, (ρ_ (F.obj X)).inv = F.map (ρ_ X).inv ≫ δ' X (𝟙_ C) ≫ F.obj X ◁ η' := by\n      aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.oplax_associativity'","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.OplaxMonoidal\nX Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ' (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.δ' X Y) (F.obj Z)) (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ' X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.δ' Y Z))))","decl":"/-- A functor `F : C ⥤ D` between monoidal categories is oplax monoidal if it is\nequipped with morphisms `η : F.obj (𝟙_ C) ⟶ 𝟙 _D` and `δ X Y : F.obj (X ⊗ Y) ⟶ F.obj X ⊗ F.obj Y`,\nsatisfying the appropriate coherences. -/\nclass OplaxMonoidal where\n  /-- counit morphism -/\n  η' : F.obj (𝟙_ C) ⟶ 𝟙_ D\n  /-- cotensorator -/\n  δ' : ∀ X Y : C, F.obj (X ⊗ Y) ⟶ F.obj X ⊗ F.obj Y\n  δ'_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      δ' X X' ≫ F.map f ▷ F.obj X' = F.map (f ▷ X') ≫ δ' Y X' := by\n    aesop_cat\n  δ'_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      δ' X' X ≫ F.obj X' ◁ F.map f = F.map (X' ◁ f) ≫ δ' X' Y := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  oplax_associativity' :\n    ∀ X Y Z : C,\n      δ' (X ⊗ Y) Z ≫ δ' X Y ▷ F.obj Z ≫ (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n        F.map (α_ X Y Z).hom ≫ δ' X (Y ⊗ Z) ≫ F.obj X ◁ δ' Y Z := by\n    aesop_cat\n  -- unitality\n  oplax_left_unitality' :\n    ∀ X : C, (λ_ (F.obj X)).inv = F.map (λ_ X).inv ≫ δ' (𝟙_ C) X ≫ η' ▷ F.obj X := by\n      aesop_cat\n  oplax_right_unitality' :\n    ∀ X : C, (ρ_ (F.obj X)).inv = F.map (ρ_ X).inv ≫ δ' X (𝟙_ C) ≫ F.obj X ◁ η' := by\n      aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.δ_natural_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj Y) (F.obj X')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X X') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F Y X') h))","decl":"@[reassoc (attr := simp)]\nlemma δ_natural_left {X Y : C} (f : X ⟶ Y) (X' : C) :\n    δ F X X' ≫ F.map f ▷ F.obj X' = F.map (f ▷ X') ≫ δ F Y X' := by\n  apply δ'_natural_left\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.δ_natural_left","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X X') (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X'))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')) (CategoryTheory.Functor.OplaxMonoidal.δ F Y X'))","decl":"@[reassoc (attr := simp)]\nlemma δ_natural_left {X Y : C} (f : X ⟶ Y) (X' : C) :\n    δ F X X' ≫ F.map f ▷ F.obj X' = F.map (f ▷ X') ≫ δ F Y X' := by\n  apply δ'_natural_left\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.δ_natural_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X') (F.obj Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X' X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X' Y) h))","decl":"@[reassoc (attr := simp)]\nlemma δ_natural_right {X Y : C} (X' : C) (f : X ⟶ Y) :\n    δ F X' X ≫ F.obj X' ◁ F.map f = F.map (X' ◁ f) ≫ δ F X' Y := by\n  apply δ'_natural_right\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.δ_natural_right","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X' X) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)) (CategoryTheory.Functor.OplaxMonoidal.δ F X' Y))","decl":"@[reassoc (attr := simp)]\nlemma δ_natural_right {X Y : C} (X' : C) (f : X ⟶ Y) :\n    δ F X' X ≫ F.obj X' ◁ F.map f = F.map (X' ◁ f) ≫ δ F X' Y := by\n  apply δ'_natural_right\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.associativity","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) (F.obj Z)) (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.δ F Y Z))))","decl":"@[reassoc (attr := simp)]\nlemma associativity (X Y Z : C) :\n    δ F (X ⊗ Y) Z ≫ δ F X Y ▷ F.obj Z ≫ (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n      F.map (α_ X Y Z).hom ≫ δ F X (Y ⊗ Z) ≫ F.obj X ◁ δ F Y Z := by\n  apply oplax_associativity'\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.associativity_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX Y Z✝ : C\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj Y) (F.obj Z✝))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) (F.obj Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z✝)).hom h))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.δ F Y Z✝)) h)))","decl":"@[reassoc (attr := simp)]\nlemma associativity (X Y Z : C) :\n    δ F (X ⊗ Y) Z ≫ δ F X Y ▷ F.obj Z ≫ (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n      F.map (α_ X Y Z).hom ≫ δ F X (Y ⊗ Z) ≫ F.obj X ◁ δ F Y Z := by\n  apply oplax_associativity'\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.left_unitality","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.η F) (F.obj X))))","decl":"@[simp, reassoc]\nlemma left_unitality (X : C) :\n    (λ_ (F.obj X)).inv = F.map (λ_ X).inv ≫ δ F (𝟙_ C) X ≫ η F ▷ F.obj X := by\n  apply oplax_left_unitality'\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.left_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv h) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.η F) (F.obj X)) h)))","decl":"@[simp, reassoc]\nlemma left_unitality (X : C) :\n    (λ_ (F.obj X)).inv = F.map (λ_ X).inv ≫ δ F (𝟙_ C) X ≫ η F ▷ F.obj X := by\n  apply oplax_left_unitality'\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.right_unitality","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.η F))))","decl":"@[simp, reassoc]\nlemma right_unitality (X : C) :\n    (ρ_ (F.obj X)).inv = F.map (ρ_ X).inv ≫ δ F X (𝟙_ C) ≫ F.obj X ◁ η F := by\n  apply oplax_right_unitality'\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.right_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv h) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.η F)) h)))","decl":"@[simp, reassoc]\nlemma right_unitality (X : C) :\n    (ρ_ (F.obj X)).inv = F.map (ρ_ X).inv ≫ δ F X (𝟙_ C) ≫ F.obj X ◁ η F := by\n  apply oplax_right_unitality'\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.δ_natural","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X X') (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.Functor.OplaxMonoidal.δ F Y Y'))","decl":"@[reassoc (attr := simp)]\ntheorem δ_natural {X Y X' Y' : C} (f : X ⟶ Y) (g : X' ⟶ Y') :\n    δ F X X' ≫ (F.map f ⊗ F.map g) = F.map (f ⊗ g) ≫ δ F Y Y' := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.δ_natural_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj Y) (F.obj Y')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X X') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F Y Y') h))","decl":"@[reassoc (attr := simp)]\ntheorem δ_natural {X Y X' Y' : C} (f : X ⟶ Y) (g : X' ⟶ Y') :\n    δ F X X' ≫ (F.map f ⊗ F.map g) = F.map (f ⊗ g) ≫ δ F Y Y' := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.left_unitality_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.η F) (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom h))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) h)","decl":"@[reassoc (attr := simp)]\ntheorem left_unitality_hom  (X : C) :\n    δ F (𝟙_ C) X ≫ η F ▷ F.obj X ≫ (λ_ (F.obj X)).hom = F.map (λ_ X).hom := by\n  rw [← Category.assoc, ← Iso.eq_comp_inv, left_unitality, ← Category.assoc,\n    ← F.map_comp, Iso.hom_inv_id, F.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.left_unitality_hom","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.η F) (F.obj X)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom)) (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)","decl":"@[reassoc (attr := simp)]\ntheorem left_unitality_hom  (X : C) :\n    δ F (𝟙_ C) X ≫ η F ▷ F.obj X ≫ (λ_ (F.obj X)).hom = F.map (λ_ X).hom := by\n  rw [← Category.assoc, ← Iso.eq_comp_inv, left_unitality, ← Category.assoc,\n    ← F.map_comp, Iso.hom_inv_id, F.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.right_unitality_hom","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.η F)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom)) (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)","decl":"@[reassoc (attr := simp)]\ntheorem right_unitality_hom (X : C) :\n    δ F X (𝟙_ C) ≫ F.obj X ◁ η F ≫ (ρ_ (F.obj X)).hom = F.map (ρ_ X).hom := by\n  rw [← Category.assoc, ← Iso.eq_comp_inv, right_unitality, ← Category.assoc,\n    ← F.map_comp, Iso.hom_inv_id, F.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.right_unitality_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.η F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom h))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) h)","decl":"@[reassoc (attr := simp)]\ntheorem right_unitality_hom (X : C) :\n    δ F X (𝟙_ C) ≫ F.obj X ◁ η F ≫ (ρ_ (F.obj X)).hom = F.map (ρ_ X).hom := by\n  rw [← Category.assoc, ← Iso.eq_comp_inv, right_unitality, ← Category.assoc,\n    ← F.map_comp, Iso.hom_inv_id, F.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.associativity_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.δ F Y Z)) (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).inv)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) (F.obj Z))))","decl":"@[reassoc (attr := simp)]\ntheorem associativity_inv (X Y Z : C) :\n    δ F X (Y ⊗ Z) ≫ F.obj X ◁ δ F Y Z ≫ (α_ (F.obj X) (F.obj Y) (F.obj Z)).inv =\n      F.map (α_ X Y Z).inv ≫ δ F (X ⊗ Y) Z ≫ δ F X Y ▷ F.obj Z := by\n  rw [← Category.assoc, Iso.comp_inv_eq, Category.assoc, Category.assoc, associativity,\n    ← Category.assoc, ← F.map_comp, Iso.inv_hom_id, F.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.associativity_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.OplaxMonoidal\nX Y Z✝ : C\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.δ F Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z✝)).inv h))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) (F.obj Z✝)) h)))","decl":"@[reassoc (attr := simp)]\ntheorem associativity_inv (X Y Z : C) :\n    δ F X (Y ⊗ Z) ≫ F.obj X ◁ δ F Y Z ≫ (α_ (F.obj X) (F.obj Y) (F.obj Z)).inv =\n      F.map (α_ X Y Z).inv ≫ δ F (X ⊗ Y) Z ≫ δ F X Y ▷ F.obj Z := by\n  rw [← Category.assoc, Iso.comp_inv_eq, Category.assoc, Category.assoc, associativity,\n    ← Category.assoc, ← F.map_comp, Iso.inv_hom_id, F.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.id_η","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.η (CategoryTheory.Functor.id C)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[simp]\nlemma id_η : η (𝟭 C) = 𝟙 _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.id_δ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ (CategoryTheory.Functor.id C) X Y) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)))","decl":"@[simp]\nlemma id_δ (X Y : C) : δ (𝟭 C) X Y = 𝟙 _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.comp_η","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.OplaxMonoidal\ninst✝ : G.OplaxMonoidal\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.η (F.comp G)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.η F)) (CategoryTheory.Functor.OplaxMonoidal.η G))","decl":"@[simp]\nlemma comp_η : η (F ⋙ G) = G.map (η F) ≫ η G := rfl\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.comp_δ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.OplaxMonoidal\ninst✝ : G.OplaxMonoidal\nX Y : C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ (F.comp G) X Y) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.δ F X Y)) (CategoryTheory.Functor.OplaxMonoidal.δ G (F.obj X) (F.obj Y)))","decl":"@[simp]\nlemma comp_δ (X Y : C) : δ (F ⋙ G) X Y = G.map (δ F X Y) ≫ δ G _ _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.ε_η","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.ε F) (CategoryTheory.Functor.OplaxMonoidal.η F)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/-- A functor between monoidal categories is monoidal if it is lax and oplax monoidals,\nand both data give inverse isomorphisms. -/\nclass Monoidal extends F.LaxMonoidal, F.OplaxMonoidal where\n  ε_η : ε F ≫ η F = 𝟙 _ := by aesop_cat\n  η_ε : η F ≫ ε F = 𝟙 _ := by aesop_cat\n  μ_δ (X Y : C) : μ F X Y ≫ δ F X Y = 𝟙 _ := by aesop_cat\n  δ_μ (X Y : C) : δ F X Y ≫ μ F X Y = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.η_ε","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.η F) (CategoryTheory.Functor.LaxMonoidal.ε F)) (CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"/-- A functor between monoidal categories is monoidal if it is lax and oplax monoidals,\nand both data give inverse isomorphisms. -/\nclass Monoidal extends F.LaxMonoidal, F.OplaxMonoidal where\n  ε_η : ε F ≫ η F = 𝟙 _ := by aesop_cat\n  η_ε : η F ≫ ε F = 𝟙 _ := by aesop_cat\n  μ_δ (X Y : C) : μ F X Y ≫ δ F X Y = 𝟙 _ := by aesop_cat\n  δ_μ (X Y : C) : δ F X Y ≫ μ F X Y = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.δ_μ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) (CategoryTheory.Functor.LaxMonoidal.μ F X Y)) (CategoryTheory.CategoryStruct.id (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)))","decl":"/-- A functor between monoidal categories is monoidal if it is lax and oplax monoidals,\nand both data give inverse isomorphisms. -/\nclass Monoidal extends F.LaxMonoidal, F.OplaxMonoidal where\n  ε_η : ε F ≫ η F = 𝟙 _ := by aesop_cat\n  η_ε : η F ≫ ε F = 𝟙 _ := by aesop_cat\n  μ_δ (X Y : C) : μ F X Y ≫ δ F X Y = 𝟙 _ := by aesop_cat\n  δ_μ (X Y : C) : δ F X Y ≫ μ F X Y = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.μ_δ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X Y) (CategoryTheory.Functor.OplaxMonoidal.δ F X Y)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)))","decl":"/-- A functor between monoidal categories is monoidal if it is lax and oplax monoidals,\nand both data give inverse isomorphisms. -/\nclass Monoidal extends F.LaxMonoidal, F.OplaxMonoidal where\n  ε_η : ε F ≫ η F = 𝟙 _ := by aesop_cat\n  η_ε : η F ≫ ε F = 𝟙 _ := by aesop_cat\n  μ_δ (X Y : C) : μ F X Y ≫ δ F X Y = 𝟙 _ := by aesop_cat\n  δ_μ (X Y : C) : δ F X Y ≫ μ F X Y = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.μ_δ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nX Y : C\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) h)) h","decl":"attribute [reassoc (attr := simp)] ε_η η_ε μ_δ δ_μ\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.ε_η_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nZ : D\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.ε F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.η F) h)) h","decl":"attribute [reassoc (attr := simp)] ε_η η_ε μ_δ δ_μ\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.δ_μ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nX Y : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X Y) h)) h","decl":"attribute [reassoc (attr := simp)] ε_η η_ε μ_δ δ_μ\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.η_ε_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nZ : D\nh : Quiver.Hom (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.η F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.ε F) h)) h","decl":"attribute [reassoc (attr := simp)] ε_η η_ε μ_δ δ_μ\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.εIso_hom","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\n⊢ Eq (CategoryTheory.Functor.Monoidal.εIso F).hom (CategoryTheory.Functor.LaxMonoidal.ε F)","decl":"/-- The isomorphism `𝟙_ D ≅ F.obj (𝟙_ C)` when `F` is a monoidal functor. -/\n@[simps]\ndef εIso : 𝟙_ D ≅ F.obj (𝟙_ C) where\n  hom := ε F\n  inv := η F\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.εIso_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\n⊢ Eq (CategoryTheory.Functor.Monoidal.εIso F).inv (CategoryTheory.Functor.OplaxMonoidal.η F)","decl":"/-- The isomorphism `𝟙_ D ≅ F.obj (𝟙_ C)` when `F` is a monoidal functor. -/\n@[simps]\ndef εIso : 𝟙_ D ≅ F.obj (𝟙_ C) where\n  hom := ε F\n  inv := η F\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.μIso_hom","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\n⊢ Eq (CategoryTheory.Functor.Monoidal.μIso F X Y).hom (CategoryTheory.Functor.LaxMonoidal.μ F X Y)","decl":"/-- The isomorphism `F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)` when `F` is a monoidal functor. -/\n@[simps]\ndef μIso (X Y : C) : F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y) where\n  hom := μ F X Y\n  inv := δ F X Y\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.μIso_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\n⊢ Eq (CategoryTheory.Functor.Monoidal.μIso F X Y).inv (CategoryTheory.Functor.OplaxMonoidal.δ F X Y)","decl":"/-- The isomorphism `F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)` when `F` is a monoidal functor. -/\n@[simps]\ndef μIso (X Y : C) : F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y) where\n  hom := μ F X Y\n  inv := δ F X Y\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.instIsIsoε","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\n⊢ CategoryTheory.IsIso (CategoryTheory.Functor.LaxMonoidal.ε F)","decl":"instance : IsIso (ε F) := (εIso F).isIso_hom\n"}
{"name":"CategoryTheory.Functor.Monoidal.instIsIsoη","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\n⊢ CategoryTheory.IsIso (CategoryTheory.Functor.OplaxMonoidal.η F)","decl":"instance : IsIso (η F) := (εIso F).isIso_inv\n"}
{"name":"CategoryTheory.Functor.Monoidal.instIsIsoμ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\n⊢ CategoryTheory.IsIso (CategoryTheory.Functor.LaxMonoidal.μ F X Y)","decl":"instance (X Y : C) : IsIso (μ F X Y) := (μIso F X Y).isIso_hom\n"}
{"name":"CategoryTheory.Functor.Monoidal.instIsIsoδ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\n⊢ CategoryTheory.IsIso (CategoryTheory.Functor.OplaxMonoidal.δ F X Y)","decl":"instance (X Y : C) : IsIso (δ F X Y) := (μIso F X Y).isIso_inv\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_ε_η","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\nC' : Type u₁'\ninst✝¹ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nG : CategoryTheory.Functor D C'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.LaxMonoidal.ε F)) (G.map (CategoryTheory.Functor.OplaxMonoidal.η F))) (CategoryTheory.CategoryStruct.id (G.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[reassoc (attr := simp)]\nlemma map_ε_η (G : D ⥤ C') : G.map (ε F) ≫ G.map (η F) = 𝟙 _ :=\n  (εIso F).map_hom_inv_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_ε_η_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\nC' : Type u₁'\ninst✝¹ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nG : CategoryTheory.Functor D C'\nZ : C'\nh : Quiver.Hom (G.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.LaxMonoidal.ε F)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.η F)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_ε_η (G : D ⥤ C') : G.map (ε F) ≫ G.map (η F) = 𝟙 _ :=\n  (εIso F).map_hom_inv_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_η_ε","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\nC' : Type u₁'\ninst✝¹ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nG : CategoryTheory.Functor D C'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.η F)) (G.map (CategoryTheory.Functor.LaxMonoidal.ε F))) (CategoryTheory.CategoryStruct.id (G.obj (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)))","decl":"@[reassoc (attr := simp)]\nlemma map_η_ε (G : D ⥤ C') : G.map (η F) ≫ G.map (ε F) = 𝟙 _ :=\n  (εIso F).map_inv_hom_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_η_ε_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\nC' : Type u₁'\ninst✝¹ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nG : CategoryTheory.Functor D C'\nZ : C'\nh : Quiver.Hom (G.obj (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.η F)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.LaxMonoidal.ε F)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_η_ε (G : D ⥤ C') : G.map (η F) ≫ G.map (ε F) = 𝟙 _ :=\n  (εIso F).map_inv_hom_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_μ_δ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\nC' : Type u₁'\ninst✝¹ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nG : CategoryTheory.Functor D C'\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.LaxMonoidal.μ F X Y)) (G.map (CategoryTheory.Functor.OplaxMonoidal.δ F X Y))) (CategoryTheory.CategoryStruct.id (G.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y))))","decl":"@[reassoc (attr := simp)]\nlemma map_μ_δ (G : D ⥤ C') (X Y : C) : G.map (μ F X Y) ≫ G.map (δ F X Y) = 𝟙 _ :=\n  (μIso F X Y).map_hom_inv_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_μ_δ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\nC' : Type u₁'\ninst✝¹ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nG : CategoryTheory.Functor D C'\nX Y : C\nZ : C'\nh : Quiver.Hom (G.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.LaxMonoidal.μ F X Y)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.δ F X Y)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_μ_δ (G : D ⥤ C') (X Y : C) : G.map (μ F X Y) ≫ G.map (δ F X Y) = 𝟙 _ :=\n  (μIso F X Y).map_hom_inv_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_δ_μ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\nC' : Type u₁'\ninst✝¹ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nG : CategoryTheory.Functor D C'\nX Y : C\nZ : C'\nh : Quiver.Hom (G.obj (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.δ F X Y)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.LaxMonoidal.μ F X Y)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_δ_μ (G : D ⥤ C') (X Y : C) : G.map (δ F X Y) ≫ G.map (μ F X Y) = 𝟙 _ :=\n  (μIso F X Y).map_inv_hom_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_δ_μ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\nC' : Type u₁'\ninst✝¹ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nG : CategoryTheory.Functor D C'\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.δ F X Y)) (G.map (CategoryTheory.Functor.LaxMonoidal.μ F X Y))) (CategoryTheory.CategoryStruct.id (G.obj (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))))","decl":"@[reassoc (attr := simp)]\nlemma map_δ_μ (G : D ⥤ C') (X Y : C) : G.map (δ F X Y) ≫ G.map (μ F X Y) = 𝟙 _ :=\n  (μIso F X Y).map_inv_hom_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_ε_η_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit T) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.ε F) T) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.η F) T) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_ε_η (T : D) : ε F ▷ T ≫ η F ▷ T = 𝟙 _ := by\n  rw [← MonoidalCategory.comp_whiskerRight, ε_η, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_ε_η","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nT : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.ε F) T) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.η F) T)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit T))","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_ε_η (T : D) : ε F ▷ T ≫ η F ▷ T = 𝟙 _ := by\n  rw [← MonoidalCategory.comp_whiskerRight, ε_η, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_η_ε_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) T) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.η F) T) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.ε F) T) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_η_ε (T : D) : η F ▷ T ≫ ε F ▷ T = 𝟙 _ := by\n  rw [← MonoidalCategory.comp_whiskerRight, η_ε, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_η_ε","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nT : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.η F) T) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.ε F) T)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) T))","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_η_ε (T : D) : η F ▷ T ≫ ε F ▷ T = 𝟙 _ := by\n  rw [← MonoidalCategory.comp_whiskerRight, η_ε, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_μ_δ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\nT : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.μ F X Y) T) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) T)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) T))","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_μ_δ (X Y : C) (T : D) : μ F X Y ▷ T ≫ δ F X Y ▷ T = 𝟙 _ := by\n  rw [← MonoidalCategory.comp_whiskerRight, μ_δ, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_μ_δ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) T) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.μ F X Y) T) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) T) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_μ_δ (X Y : C) (T : D) : μ F X Y ▷ T ≫ δ F X Y ▷ T = 𝟙 _ := by\n  rw [← MonoidalCategory.comp_whiskerRight, μ_δ, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_δ_μ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\nT : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) T) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.μ F X Y) T)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) T))","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_δ_μ (X Y : C) (T : D) : δ F X Y ▷ T ≫ μ F X Y ▷ T = 𝟙 _ := by\n  rw [← MonoidalCategory.comp_whiskerRight, δ_μ, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_δ_μ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) T) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) T) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.μ F X Y) T) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_δ_μ (X Y : C) (T : D) : δ F X Y ▷ T ≫ μ F X Y ▷ T = 𝟙 _ := by\n  rw [← MonoidalCategory.comp_whiskerRight, δ_μ, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_ε_η_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj T CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.ε F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.η F)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_ε_η (T : D) : T ◁ ε F ≫ T ◁ η F = 𝟙 _ := by\n  rw [← MonoidalCategory.whiskerLeft_comp, ε_η, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_ε_η","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nT : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.ε F)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.η F))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj T CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_ε_η (T : D) : T ◁ ε F ≫ T ◁ η F = 𝟙 _ := by\n  rw [← MonoidalCategory.whiskerLeft_comp, ε_η, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_η_ε","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nT : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.η F)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.ε F))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj T (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)))","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_η_ε (T : D) : T ◁ η F ≫ T ◁ ε F = 𝟙 _ := by\n  rw [← MonoidalCategory.whiskerLeft_comp, η_ε, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_η_ε_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj T (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.η F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.ε F)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_η_ε (T : D) : T ◁ η F ≫ T ◁ ε F = 𝟙 _ := by\n  rw [← MonoidalCategory.whiskerLeft_comp, η_ε, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_μ_δ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj T (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.μ F X Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.δ F X Y)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_μ_δ (X Y : C) (T : D) : T ◁ μ F X Y ≫ T ◁ δ F X Y = 𝟙 _ := by\n  rw [← MonoidalCategory.whiskerLeft_comp, μ_δ, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_μ_δ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\nT : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.μ F X Y)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.δ F X Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj T (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y))))","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_μ_δ (X Y : C) (T : D) : T ◁ μ F X Y ≫ T ◁ δ F X Y = 𝟙 _ := by\n  rw [← MonoidalCategory.whiskerLeft_comp, μ_δ, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_δ_μ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj T (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.δ F X Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.μ F X Y)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_δ_μ (X Y : C) (T : D) : T ◁ δ F X Y ≫ T ◁ μ F X Y = 𝟙 _ := by\n  rw [← MonoidalCategory.whiskerLeft_comp, δ_μ, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_δ_μ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\nT : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.δ F X Y)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.μ F X Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj T (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))))","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_δ_μ (X Y : C) (T : D) : T ◁ δ F X Y ≫ T ◁ μ F X Y = 𝟙 _ := by\n  rw [← MonoidalCategory.whiskerLeft_comp, δ_μ, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_tensor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X X') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (CategoryTheory.Functor.LaxMonoidal.μ F Y Y')))","decl":"@[reassoc]\ntheorem map_tensor {X Y X' Y' : C} (f : X ⟶ Y) (g : X' ⟶ Y') :\n    F.map (f ⊗ g) = δ F X X' ≫ (F.map f ⊗ F.map g) ≫ μ F Y Y' := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_tensor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Y')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X X') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F Y Y') h)))","decl":"@[reassoc]\ntheorem map_tensor {X Y X' Y' : C} (f : X ⟶ Y) (g : X' ⟶ Y') :\n    F.map (f ⊗ g) = δ F X X' ≫ (F.map f ⊗ F.map g) ≫ μ F Y Y' := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_whiskerLeft_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y Z✝ : C\nf : Quiver.Hom Y Z✝\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X Z✝) h)))","decl":"@[reassoc]\ntheorem map_whiskerLeft (X : C) {Y Z : C} (f : Y ⟶ Z) :\n    F.map (X ◁ f) = δ F X Y ≫ F.obj X ◁ F.map f ≫ μ F X Z := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y Z : C\nf : Quiver.Hom Y Z\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (CategoryTheory.Functor.LaxMonoidal.μ F X Z)))","decl":"@[reassoc]\ntheorem map_whiskerLeft (X : C) {Y Z : C} (f : Y ⟶ Z) :\n    F.map (X ◁ f) = δ F X Y ≫ F.obj X ◁ F.map f ≫ μ F X Z := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_whiskerRight_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\nf : Quiver.Hom X Y\nZ✝ : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z✝)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F Y Z✝) h)))","decl":"@[reassoc]\ntheorem map_whiskerRight {X Y : C} (f : X ⟶ Y) (Z : C) :\n    F.map (f ▷ Z) = δ F X Z ≫ F.map f ▷ F.obj Z ≫ μ F Y Z := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y : C\nf : Quiver.Hom X Y\nZ : C\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Z)) (CategoryTheory.Functor.LaxMonoidal.μ F Y Z)))","decl":"@[reassoc]\ntheorem map_whiskerRight {X Y : C} (f : X ⟶ Y) (Z : C) :\n    F.map (f ▷ Z) = δ F X Z ≫ F.map f ▷ F.obj Z ≫ μ F Y Z := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_associator","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y Z : C\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) (F.obj Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.μ F Y Z)) (CategoryTheory.Functor.LaxMonoidal.μ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))))","decl":"@[reassoc]\ntheorem map_associator (X Y Z : C) :\n    F.map (α_ X Y Z).hom =\n      δ F (X ⊗ Y) Z ≫ δ F X Y ▷ F.obj Z ≫\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ μ F Y Z ≫ μ F X (Y ⊗ Z) := by\n  rw [← LaxMonoidal.associativity F, whiskerRight_δ_μ_assoc, δ_μ_assoc]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_associator_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y Z✝ : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) (F.obj Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z✝)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.μ F Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) h)))))","decl":"@[reassoc]\ntheorem map_associator (X Y Z : C) :\n    F.map (α_ X Y Z).hom =\n      δ F (X ⊗ Y) Z ≫ δ F X Y ▷ F.obj Z ≫\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ μ F Y Z ≫ μ F X (Y ⊗ Z) := by\n  rw [← LaxMonoidal.associativity F, whiskerRight_δ_μ_assoc, δ_μ_assoc]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_associator_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y Z✝ : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.δ F Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z✝)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.μ F X Y) (F.obj Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝) h)))))","decl":"@[reassoc]\ntheorem map_associator_inv (X Y Z : C) :\n    F.map (α_ X Y Z).inv =\n      δ F X (Y ⊗ Z) ≫ F.obj X ◁ δ F Y Z ≫\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).inv ≫ μ F X Y ▷ F.obj Z ≫ μ F (X ⊗ Y) Z := by\n  rw [← cancel_epi (F.map (α_ X Y Z).hom), Iso.map_hom_inv_id, map_associator,\n    assoc, assoc, assoc, assoc, OplaxMonoidal.associativity_inv_assoc,\n    whiskerRight_δ_μ_assoc, δ_μ, comp_id, LaxMonoidal.associativity_inv,\n    Iso.hom_inv_id_assoc, whiskerRight_δ_μ_assoc, δ_μ]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_associator_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX Y Z : C\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.δ F Y Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.μ F X Y) (F.obj Z)) (CategoryTheory.Functor.LaxMonoidal.μ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z)))))","decl":"@[reassoc]\ntheorem map_associator_inv (X Y Z : C) :\n    F.map (α_ X Y Z).inv =\n      δ F X (Y ⊗ Z) ≫ F.obj X ◁ δ F Y Z ≫\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).inv ≫ μ F X Y ▷ F.obj Z ≫ μ F (X ⊗ Y) Z := by\n  rw [← cancel_epi (F.map (α_ X Y Z).hom), Iso.map_hom_inv_id, map_associator,\n    assoc, assoc, assoc, assoc, OplaxMonoidal.associativity_inv_assoc,\n    whiskerRight_δ_μ_assoc, δ_μ, comp_id, LaxMonoidal.associativity_inv,\n    Iso.hom_inv_id_assoc, whiskerRight_δ_μ_assoc, δ_μ]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_leftUnitor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.η F) (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom h)))","decl":"@[reassoc]\ntheorem map_leftUnitor (X : C) :\n    F.map (λ_ X).hom = δ F (𝟙_ C) X ≫ η F ▷ F.obj X ≫ (λ_ (F.obj X)).hom := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX : C\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.η F) (F.obj X)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom))","decl":"@[reassoc]\ntheorem map_leftUnitor (X : C) :\n    F.map (λ_ X).hom = δ F (𝟙_ C) X ≫ η F ▷ F.obj X ≫ (λ_ (F.obj X)).hom := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_leftUnitor_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX : C\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.ε F) (F.obj X)) (CategoryTheory.Functor.LaxMonoidal.μ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X)))","decl":"@[reassoc]\ntheorem map_leftUnitor_inv (X : C) :\n    F.map (λ_ X).inv = (λ_ (F.obj X)).inv ≫ ε F ▷ F.obj X ≫ μ F (𝟙_ C) X  := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_leftUnitor_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.ε F) (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) h)))","decl":"@[reassoc]\ntheorem map_leftUnitor_inv (X : C) :\n    F.map (λ_ X).inv = (λ_ (F.obj X)).inv ≫ ε F ▷ F.obj X ≫ μ F (𝟙_ C) X  := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX : C\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.η F)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom))","decl":"@[reassoc]\ntheorem map_rightUnitor (X : C) :\n    F.map (ρ_ X).hom = δ F X (𝟙_ C) ≫ F.obj X ◁ η F ≫ (ρ_ (F.obj X)).hom := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_rightUnitor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.η F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom h)))","decl":"@[reassoc]\ntheorem map_rightUnitor (X : C) :\n    F.map (ρ_ X).hom = δ F X (𝟙_ C) ≫ F.obj X ◁ η F ≫ (ρ_ (F.obj X)).hom := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_rightUnitor_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X CategoryTheory.MonoidalCategoryStruct.tensorUnit)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.ε F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) h)))","decl":"@[reassoc]\ntheorem map_rightUnitor_inv (X : C) :\n    F.map (ρ_ X).inv = (ρ_ (F.obj X)).inv ≫ F.obj X ◁ ε F  ≫ μ F X (𝟙_ C):= by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_rightUnitor_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX : C\n⊢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.ε F)) (CategoryTheory.Functor.LaxMonoidal.μ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit)))","decl":"@[reassoc]\ntheorem map_rightUnitor_inv (X : C) :\n    F.map (ρ_ X).inv = (ρ_ (F.obj X)).inv ≫ F.obj X ◁ ε F  ≫ μ F X (𝟙_ C):= by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.μNatIso_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX : Prod C C\n⊢ Eq ((CategoryTheory.Functor.Monoidal.μNatIso F).inv.app X) (CategoryTheory.Functor.OplaxMonoidal.δ F X.1 X.2)","decl":"/-- The tensorator as a natural isomorphism. -/\n@[simps!]\nnoncomputable def μNatIso :\n    Functor.prod F F ⋙ tensor D ≅ tensor C ⋙ F :=\n  NatIso.ofComponents (fun _ ↦ μIso F _ _)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.μNatIso_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX : Prod C C\n⊢ Eq ((CategoryTheory.Functor.Monoidal.μNatIso F).hom.app X) (CategoryTheory.Functor.LaxMonoidal.μ F X.1 X.2)","decl":"/-- The tensorator as a natural isomorphism. -/\n@[simps!]\nnoncomputable def μNatIso :\n    Functor.prod F F ⋙ tensor D ≅ tensor C ⋙ F :=\n  NatIso.ofComponents (fun _ ↦ μIso F _ _)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.commTensorLeft_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX✝ X : C\n⊢ Eq ((CategoryTheory.Functor.Monoidal.commTensorLeft F X✝).inv.app X) (CategoryTheory.Functor.OplaxMonoidal.δ F X✝ X)","decl":"/-- Monoidal functors commute with left tensoring up to isomorphism -/\n@[simps!]\nnoncomputable def commTensorLeft (X : C) :\n    F ⋙ tensorLeft (F.obj X) ≅ tensorLeft X ⋙ F :=\n  NatIso.ofComponents (fun Y => μIso F X Y)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.commTensorLeft_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX✝ X : C\n⊢ Eq ((CategoryTheory.Functor.Monoidal.commTensorLeft F X✝).hom.app X) (CategoryTheory.Functor.LaxMonoidal.μ F X✝ X)","decl":"/-- Monoidal functors commute with left tensoring up to isomorphism -/\n@[simps!]\nnoncomputable def commTensorLeft (X : C) :\n    F ⋙ tensorLeft (F.obj X) ≅ tensorLeft X ⋙ F :=\n  NatIso.ofComponents (fun Y => μIso F X Y)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.commTensorRight_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX✝ X : C\n⊢ Eq ((CategoryTheory.Functor.Monoidal.commTensorRight F X✝).inv.app X) (CategoryTheory.Functor.OplaxMonoidal.δ F X X✝)","decl":"/-- Monoidal functors commute with right tensoring up to isomorphism -/\n@[simps!]\nnoncomputable def commTensorRight (X : C) :\n    F ⋙ tensorRight (F.obj X) ≅ tensorRight X ⋙ F :=\n  NatIso.ofComponents (fun Y => μIso F Y X)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.commTensorRight_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.Monoidal\nX✝ X : C\n⊢ Eq ((CategoryTheory.Functor.Monoidal.commTensorRight F X✝).hom.app X) (CategoryTheory.Functor.LaxMonoidal.μ F X X✝)","decl":"/-- Monoidal functors commute with right tensoring up to isomorphism -/\n@[simps!]\nnoncomputable def commTensorRight (X : C) :\n    F ⋙ tensorRight (F.obj X) ≅ tensorRight X ⋙ F :=\n  NatIso.ofComponents (fun Y => μIso F Y X)\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.left_unitality","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.εIso.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (self.μIso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `εIso` and `μIso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  εIso : 𝟙_ D ≅ F.obj (𝟙_ C)\n  /-- tensorator -/\n  μIso : ∀ X Y : C, F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  μIso_hom_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      F.map f ▷ F.obj X' ≫ (μIso Y X').hom = (μIso X X').hom ≫ F.map (f ▷ X') := by\n    aesop_cat\n  μIso_hom_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      F.obj X' ◁ F.map f ≫ (μIso X' Y).hom = (μIso X' X).hom ≫ F.map (X' ◁ f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    ∀ X Y Z : C,\n      (μIso X Y).hom ▷ F.obj Z ≫ (μIso (X ⊗ Y) Z).hom ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ (μIso Y Z).hom ≫\n          (μIso X (Y ⊗ Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    ∀ X : C, (λ_ (F.obj X)).hom = εIso.hom ▷ F.obj X ≫ (μIso (𝟙_ C) X).hom ≫ F.map (λ_ X).hom := by\n      aesop_cat\n  right_unitality :\n    ∀ X : C, (ρ_ (F.obj X)).hom = F.obj X ◁ εIso.hom ≫ (μIso X (𝟙_ C)).hom ≫ F.map (ρ_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.associativity","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (self.μIso X Y).hom (F.obj Z)) (CategoryTheory.CategoryStruct.comp (self.μIso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (self.μIso Y Z).hom) (self.μIso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `εIso` and `μIso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  εIso : 𝟙_ D ≅ F.obj (𝟙_ C)\n  /-- tensorator -/\n  μIso : ∀ X Y : C, F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  μIso_hom_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      F.map f ▷ F.obj X' ≫ (μIso Y X').hom = (μIso X X').hom ≫ F.map (f ▷ X') := by\n    aesop_cat\n  μIso_hom_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      F.obj X' ◁ F.map f ≫ (μIso X' Y).hom = (μIso X' X).hom ≫ F.map (X' ◁ f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    ∀ X Y Z : C,\n      (μIso X Y).hom ▷ F.obj Z ≫ (μIso (X ⊗ Y) Z).hom ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ (μIso Y Z).hom ≫\n          (μIso X (Y ⊗ Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    ∀ X : C, (λ_ (F.obj X)).hom = εIso.hom ▷ F.obj X ≫ (μIso (𝟙_ C) X).hom ≫ F.map (λ_ X).hom := by\n      aesop_cat\n  right_unitality :\n    ∀ X : C, (ρ_ (F.obj X)).hom = F.obj X ◁ εIso.hom ≫ (μIso X (𝟙_ C)).hom ≫ F.map (ρ_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.μIso_hom_natural_right","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (self.μIso X' Y).hom) (CategoryTheory.CategoryStruct.comp (self.μIso X' X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `εIso` and `μIso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  εIso : 𝟙_ D ≅ F.obj (𝟙_ C)\n  /-- tensorator -/\n  μIso : ∀ X Y : C, F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  μIso_hom_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      F.map f ▷ F.obj X' ≫ (μIso Y X').hom = (μIso X X').hom ≫ F.map (f ▷ X') := by\n    aesop_cat\n  μIso_hom_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      F.obj X' ◁ F.map f ≫ (μIso X' Y).hom = (μIso X' X).hom ≫ F.map (X' ◁ f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    ∀ X Y Z : C,\n      (μIso X Y).hom ▷ F.obj Z ≫ (μIso (X ⊗ Y) Z).hom ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ (μIso Y Z).hom ≫\n          (μIso X (Y ⊗ Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    ∀ X : C, (λ_ (F.obj X)).hom = εIso.hom ▷ F.obj X ≫ (μIso (𝟙_ C) X).hom ≫ F.map (λ_ X).hom := by\n      aesop_cat\n  right_unitality :\n    ∀ X : C, (ρ_ (F.obj X)).hom = F.obj X ◁ εIso.hom ≫ (μIso X (𝟙_ C)).hom ≫ F.map (ρ_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nεIso✝ : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nμIso✝ : (X Y : C) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nμIso_hom_natural_left✝ : autoParam (∀ {X Y : C} (f : Quiver.Hom X Y) (X' : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (μIso✝ Y X').hom) (CategoryTheory.CategoryStruct.comp (μIso✝ X X').hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))) _auto✝\nμIso_hom_natural_right✝ : autoParam (∀ {X Y : C} (X' : C) (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (μIso✝ X' Y).hom) (CategoryTheory.CategoryStruct.comp (μIso✝ X' X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))) _auto✝\nassociativity✝ : autoParam (∀ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (μIso✝ X Y).hom (F.obj Z)) (CategoryTheory.CategoryStruct.comp (μIso✝ (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (μIso✝ Y Z).hom) (μIso✝ X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom))) _auto✝\nleft_unitality✝ : autoParam (∀ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight εIso✝.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (μIso✝ CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))) _auto✝\nright_unitality✝ : autoParam (∀ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) εIso✝.hom) (CategoryTheory.CategoryStruct.comp (μIso✝ X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))) _auto✝\nεIso : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nμIso : (X Y : C) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nμIso_hom_natural_left : autoParam (∀ {X Y : C} (f : Quiver.Hom X Y) (X' : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (μIso Y X').hom) (CategoryTheory.CategoryStruct.comp (μIso X X').hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))) _auto✝\nμIso_hom_natural_right : autoParam (∀ {X Y : C} (X' : C) (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (μIso X' Y).hom) (CategoryTheory.CategoryStruct.comp (μIso X' X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))) _auto✝\nassociativity : autoParam (∀ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (μIso X Y).hom (F.obj Z)) (CategoryTheory.CategoryStruct.comp (μIso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (μIso Y Z).hom) (μIso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom))) _auto✝\nleft_unitality : autoParam (∀ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight εIso.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (μIso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))) _auto✝\nright_unitality : autoParam (∀ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) εIso.hom) (CategoryTheory.CategoryStruct.comp (μIso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))) _auto✝\n⊢ Eq (Eq { εIso := εIso✝, μIso := μIso✝, μIso_hom_natural_left := μIso_hom_natural_left✝, μIso_hom_natural_right := μIso_hom_natural_right✝, associativity := associativity✝, left_unitality := left_unitality✝, right_unitality := right_unitality✝ } { εIso := εIso, μIso := μIso, μIso_hom_natural_left := μIso_hom_natural_left, μIso_hom_natural_right := μIso_hom_natural_right, associativity := associativity, left_unitality := left_unitality, right_unitality := right_unitality }) (And (Eq εIso✝ εIso) (Eq μIso✝ μIso))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `εIso` and `μIso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  εIso : 𝟙_ D ≅ F.obj (𝟙_ C)\n  /-- tensorator -/\n  μIso : ∀ X Y : C, F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  μIso_hom_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      F.map f ▷ F.obj X' ≫ (μIso Y X').hom = (μIso X X').hom ≫ F.map (f ▷ X') := by\n    aesop_cat\n  μIso_hom_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      F.obj X' ◁ F.map f ≫ (μIso X' Y).hom = (μIso X' X).hom ≫ F.map (X' ◁ f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    ∀ X Y Z : C,\n      (μIso X Y).hom ▷ F.obj Z ≫ (μIso (X ⊗ Y) Z).hom ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ (μIso Y Z).hom ≫\n          (μIso X (Y ⊗ Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    ∀ X : C, (λ_ (F.obj X)).hom = εIso.hom ▷ F.obj X ≫ (μIso (𝟙_ C) X).hom ≫ F.map (λ_ X).hom := by\n      aesop_cat\n  right_unitality :\n    ∀ X : C, (ρ_ (F.obj X)).hom = F.obj X ◁ εIso.hom ≫ (μIso X (𝟙_ C)).hom ≫ F.map (ρ_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nεIso✝ : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nμIso✝ : (X Y : C) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nμIso_hom_natural_left✝ : autoParam (∀ {X Y : C} (f : Quiver.Hom X Y) (X' : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (μIso✝ Y X').hom) (CategoryTheory.CategoryStruct.comp (μIso✝ X X').hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))) _auto✝\nμIso_hom_natural_right✝ : autoParam (∀ {X Y : C} (X' : C) (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (μIso✝ X' Y).hom) (CategoryTheory.CategoryStruct.comp (μIso✝ X' X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))) _auto✝\nassociativity✝ : autoParam (∀ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (μIso✝ X Y).hom (F.obj Z)) (CategoryTheory.CategoryStruct.comp (μIso✝ (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (μIso✝ Y Z).hom) (μIso✝ X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom))) _auto✝\nleft_unitality✝ : autoParam (∀ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight εIso✝.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (μIso✝ CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))) _auto✝\nright_unitality✝ : autoParam (∀ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) εIso✝.hom) (CategoryTheory.CategoryStruct.comp (μIso✝ X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))) _auto✝\nεIso : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nμIso : (X Y : C) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nμIso_hom_natural_left : autoParam (∀ {X Y : C} (f : Quiver.Hom X Y) (X' : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (μIso Y X').hom) (CategoryTheory.CategoryStruct.comp (μIso X X').hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))) _auto✝\nμIso_hom_natural_right : autoParam (∀ {X Y : C} (X' : C) (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (μIso X' Y).hom) (CategoryTheory.CategoryStruct.comp (μIso X' X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))) _auto✝\nassociativity : autoParam (∀ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (μIso X Y).hom (F.obj Z)) (CategoryTheory.CategoryStruct.comp (μIso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (μIso Y Z).hom) (μIso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom))) _auto✝\nleft_unitality : autoParam (∀ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight εIso.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (μIso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))) _auto✝\nright_unitality : autoParam (∀ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) εIso.hom) (CategoryTheory.CategoryStruct.comp (μIso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))) _auto✝\nx✝ : Eq { εIso := εIso✝, μIso := μIso✝, μIso_hom_natural_left := μIso_hom_natural_left✝, μIso_hom_natural_right := μIso_hom_natural_right✝, associativity := associativity✝, left_unitality := left_unitality✝, right_unitality := right_unitality✝ } { εIso := εIso, μIso := μIso, μIso_hom_natural_left := μIso_hom_natural_left, μIso_hom_natural_right := μIso_hom_natural_right, associativity := associativity, left_unitality := left_unitality, right_unitality := right_unitality }\n⊢ And (Eq εIso✝ εIso) (Eq μIso✝ μIso)","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `εIso` and `μIso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  εIso : 𝟙_ D ≅ F.obj (𝟙_ C)\n  /-- tensorator -/\n  μIso : ∀ X Y : C, F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  μIso_hom_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      F.map f ▷ F.obj X' ≫ (μIso Y X').hom = (μIso X X').hom ≫ F.map (f ▷ X') := by\n    aesop_cat\n  μIso_hom_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      F.obj X' ◁ F.map f ≫ (μIso X' Y).hom = (μIso X' X).hom ≫ F.map (X' ◁ f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    ∀ X Y Z : C,\n      (μIso X Y).hom ▷ F.obj Z ≫ (μIso (X ⊗ Y) Z).hom ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ (μIso Y Z).hom ≫\n          (μIso X (Y ⊗ Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    ∀ X : C, (λ_ (F.obj X)).hom = εIso.hom ▷ F.obj X ≫ (μIso (𝟙_ C) X).hom ≫ F.map (λ_ X).hom := by\n      aesop_cat\n  right_unitality :\n    ∀ X : C, (ρ_ (F.obj X)).hom = F.obj X ◁ εIso.hom ≫ (μIso X (𝟙_ C)).hom ≫ F.map (ρ_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.right_unitality","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) self.εIso.hom) (CategoryTheory.CategoryStruct.comp (self.μIso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `εIso` and `μIso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  εIso : 𝟙_ D ≅ F.obj (𝟙_ C)\n  /-- tensorator -/\n  μIso : ∀ X Y : C, F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  μIso_hom_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      F.map f ▷ F.obj X' ≫ (μIso Y X').hom = (μIso X X').hom ≫ F.map (f ▷ X') := by\n    aesop_cat\n  μIso_hom_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      F.obj X' ◁ F.map f ≫ (μIso X' Y).hom = (μIso X' X).hom ≫ F.map (X' ◁ f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    ∀ X Y Z : C,\n      (μIso X Y).hom ▷ F.obj Z ≫ (μIso (X ⊗ Y) Z).hom ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ (μIso Y Z).hom ≫\n          (μIso X (Y ⊗ Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    ∀ X : C, (λ_ (F.obj X)).hom = εIso.hom ▷ F.obj X ≫ (μIso (𝟙_ C) X).hom ≫ F.map (λ_ X).hom := by\n      aesop_cat\n  right_unitality :\n    ∀ X : C, (ρ_ (F.obj X)).hom = F.obj X ◁ εIso.hom ≫ (μIso X (𝟙_ C)).hom ≫ F.map (ρ_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.μIso_hom_natural_left","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (self.μIso Y X').hom) (CategoryTheory.CategoryStruct.comp (self.μIso X X').hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `εIso` and `μIso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  εIso : 𝟙_ D ≅ F.obj (𝟙_ C)\n  /-- tensorator -/\n  μIso : ∀ X Y : C, F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  μIso_hom_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      F.map f ▷ F.obj X' ≫ (μIso Y X').hom = (μIso X X').hom ≫ F.map (f ▷ X') := by\n    aesop_cat\n  μIso_hom_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      F.obj X' ◁ F.map f ≫ (μIso X' Y).hom = (μIso X' X).hom ≫ F.map (X' ◁ f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    ∀ X Y Z : C,\n      (μIso X Y).hom ▷ F.obj Z ≫ (μIso (X ⊗ Y) Z).hom ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ (μIso Y Z).hom ≫\n          (μIso X (Y ⊗ Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    ∀ X : C, (λ_ (F.obj X)).hom = εIso.hom ▷ F.obj X ≫ (μIso (𝟙_ C) X).hom ≫ F.map (λ_ X).hom := by\n      aesop_cat\n  right_unitality :\n    ∀ X : C, (ρ_ (F.obj X)).hom = F.obj X ◁ εIso.hom ≫ (μIso X (𝟙_ C)).hom ≫ F.map (ρ_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝¹ : SizeOf C\ninst✝ : SizeOf D\nεIso : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nμIso : (X Y : C) → CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nμIso_hom_natural_left : autoParam (∀ {X Y : C} (f : Quiver.Hom X Y) (X' : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (μIso Y X').hom) (CategoryTheory.CategoryStruct.comp (μIso X X').hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))) _auto✝\nμIso_hom_natural_right : autoParam (∀ {X Y : C} (X' : C) (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (μIso X' Y).hom) (CategoryTheory.CategoryStruct.comp (μIso X' X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))) _auto✝\nassociativity : autoParam (∀ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (μIso X Y).hom (F.obj Z)) (CategoryTheory.CategoryStruct.comp (μIso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (μIso Y Z).hom) (μIso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom))) _auto✝\nleft_unitality : autoParam (∀ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight εIso.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (μIso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))) _auto✝\nright_unitality : autoParam (∀ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) εIso.hom) (CategoryTheory.CategoryStruct.comp (μIso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))) _auto✝\n⊢ Eq (SizeOf.sizeOf { εIso := εIso, μIso := μIso, μIso_hom_natural_left := μIso_hom_natural_left, μIso_hom_natural_right := μIso_hom_natural_right, associativity := associativity, left_unitality := left_unitality, right_unitality := right_unitality }) (HAdd.hAdd 1 (SizeOf.sizeOf εIso))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `εIso` and `μIso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  εIso : 𝟙_ D ≅ F.obj (𝟙_ C)\n  /-- tensorator -/\n  μIso : ∀ X Y : C, F.obj X ⊗ F.obj Y ≅ F.obj (X ⊗ Y)\n  μIso_hom_natural_left :\n    ∀ {X Y : C} (f : X ⟶ Y) (X' : C),\n      F.map f ▷ F.obj X' ≫ (μIso Y X').hom = (μIso X X').hom ≫ F.map (f ▷ X') := by\n    aesop_cat\n  μIso_hom_natural_right :\n    ∀ {X Y : C} (X' : C) (f : X ⟶ Y) ,\n      F.obj X' ◁ F.map f ≫ (μIso X' Y).hom = (μIso X' X).hom ≫ F.map (X' ◁ f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    ∀ X Y Z : C,\n      (μIso X Y).hom ▷ F.obj Z ≫ (μIso (X ⊗ Y) Z).hom ≫ F.map (α_ X Y Z).hom =\n        (α_ (F.obj X) (F.obj Y) (F.obj Z)).hom ≫ F.obj X ◁ (μIso Y Z).hom ≫\n          (μIso X (Y ⊗ Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    ∀ X : C, (λ_ (F.obj X)).hom = εIso.hom ▷ F.obj X ≫ (μIso (𝟙_ C) X).hom ≫ F.map (λ_ X).hom := by\n      aesop_cat\n  right_unitality :\n    ∀ X : C, (ρ_ (F.obj X)).hom = F.obj X ◁ εIso.hom ≫ (μIso X (𝟙_ C)).hom ≫ F.map (ρ_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.μIso_hom_natural_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X' Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (CategoryTheory.CategoryStruct.comp (self.μIso X' Y).hom h)) (CategoryTheory.CategoryStruct.comp (self.μIso X' X).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)) h))","decl":"attribute [reassoc (attr := simp)] μIso_hom_natural_left\n  μIso_hom_natural_right associativity\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.associativity_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX Y Z✝ : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (self.μIso X Y).hom (F.obj Z✝)) (CategoryTheory.CategoryStruct.comp (self.μIso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z✝)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (self.μIso Y Z✝).hom) (CategoryTheory.CategoryStruct.comp (self.μIso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).hom h)))","decl":"attribute [reassoc (attr := simp)] μIso_hom_natural_left\n  μIso_hom_natural_right associativity\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.μIso_hom_natural_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y X')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (CategoryTheory.CategoryStruct.comp (self.μIso Y X').hom h)) (CategoryTheory.CategoryStruct.comp (self.μIso X X').hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')) h))","decl":"attribute [reassoc (attr := simp)] μIso_hom_natural_left\n  μIso_hom_natural_right associativity\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.left_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.εIso.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (self.μIso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) h)))","decl":"attribute [reassoc] left_unitality right_unitality\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.right_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) self.εIso.hom) (CategoryTheory.CategoryStruct.comp (self.μIso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) h)))","decl":"attribute [reassoc] left_unitality right_unitality\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.toLaxMonoidal_ε","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nh : F.CoreMonoidal\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε F) h.εIso.hom","decl":"lemma toLaxMonoidal_ε :\n    letI := h.toLaxMonoidal\n    LaxMonoidal.ε F = h.εIso.hom := rfl\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.toLaxMonoidal_μ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nh : F.CoreMonoidal\nX Y : C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ F X Y) (h.μIso X Y).hom","decl":"lemma toLaxMonoidal_μ (X Y : C) :\n    letI := h.toLaxMonoidal\n    LaxMonoidal.μ F X Y = (h.μIso X Y).hom := rfl\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.toOplaxMonoidal_η","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nh : F.CoreMonoidal\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.η F) h.εIso.inv","decl":"lemma toOplaxMonoidal_η :\n    letI := h.toOplaxMonoidal\n    OplaxMonoidal.η F = h.εIso.inv := rfl\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.toOplaxMonoidal_δ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nh : F.CoreMonoidal\nX Y : C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ F X Y) (h.μIso X Y).inv","decl":"lemma toOplaxMonoidal_δ  (X Y : C) :\n    letI := h.toOplaxMonoidal\n    OplaxMonoidal.δ F X Y = (h.μIso X Y).inv := rfl\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.toMonoidal_toOplaxMonoidal","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nh : F.CoreMonoidal\n⊢ Eq CategoryTheory.Functor.Monoidal.toOplaxMonoidal h.toOplaxMonoidal","decl":"attribute [local simp] toLaxMonoidal_ε toLaxMonoidal_μ toOplaxMonoidal_η toOplaxMonoidal_δ in\n/-- The monoidal functor structure induced by a `Functor.CoreMonoidal` structure. -/\n@[simps! toLaxMonoidal toOplaxMonoidal]\ndef toMonoidal : F.Monoidal where\n  toLaxMonoidal := h.toLaxMonoidal\n  toOplaxMonoidal := h.toOplaxMonoidal\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.toMonoidal_toLaxMonoidal","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nh : F.CoreMonoidal\n⊢ Eq CategoryTheory.Functor.Monoidal.toLaxMonoidal h.toLaxMonoidal","decl":"attribute [local simp] toLaxMonoidal_ε toLaxMonoidal_μ toOplaxMonoidal_η toOplaxMonoidal_δ in\n/-- The monoidal functor structure induced by a `Functor.CoreMonoidal` structure. -/\n@[simps! toLaxMonoidal toOplaxMonoidal]\ndef toMonoidal : F.Monoidal where\n  toLaxMonoidal := h.toLaxMonoidal\n  toOplaxMonoidal := h.toOplaxMonoidal\n\n"}
{"name":"CategoryTheory.Functor.prod_ε_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁶ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} E\ninst✝⁴ : CategoryTheory.MonoidalCategory E\nC' : Type u₁'\ninst✝³ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninst✝² : CategoryTheory.MonoidalCategory C'\ninst✝¹ : F.LaxMonoidal\ninst✝ : G.LaxMonoidal\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε (F.prod G)).1 (CategoryTheory.Functor.LaxMonoidal.ε F)","decl":"@[simp] lemma prod_ε_fst : (ε (prod F G)).1 = ε F := rfl\n"}
{"name":"CategoryTheory.Functor.prod_ε_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁶ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} E\ninst✝⁴ : CategoryTheory.MonoidalCategory E\nC' : Type u₁'\ninst✝³ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninst✝² : CategoryTheory.MonoidalCategory C'\ninst✝¹ : F.LaxMonoidal\ninst✝ : G.LaxMonoidal\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε (F.prod G)).2 (CategoryTheory.Functor.LaxMonoidal.ε G)","decl":"@[simp] lemma prod_ε_snd : (ε (prod F G)).2 = ε G := rfl\n"}
{"name":"CategoryTheory.Functor.prod_μ_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁶ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} E\ninst✝⁴ : CategoryTheory.MonoidalCategory E\nC' : Type u₁'\ninst✝³ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninst✝² : CategoryTheory.MonoidalCategory C'\ninst✝¹ : F.LaxMonoidal\ninst✝ : G.LaxMonoidal\nX Y : Prod C E\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ (F.prod G) X Y).1 (CategoryTheory.Functor.LaxMonoidal.μ F X.1 Y.1)","decl":"@[simp] lemma prod_μ_fst (X Y : C × E) : (μ (prod F G) X Y).1 = μ F _ _ := rfl\n"}
{"name":"CategoryTheory.Functor.prod_μ_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁶ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} E\ninst✝⁴ : CategoryTheory.MonoidalCategory E\nC' : Type u₁'\ninst✝³ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninst✝² : CategoryTheory.MonoidalCategory C'\ninst✝¹ : F.LaxMonoidal\ninst✝ : G.LaxMonoidal\nX Y : Prod C E\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ (F.prod G) X Y).2 (CategoryTheory.Functor.LaxMonoidal.μ G X.2 Y.2)","decl":"@[simp] lemma prod_μ_snd (X Y : C × E) : (μ (prod F G) X Y).2 = μ G _ _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.prod_η_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁶ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} E\ninst✝⁴ : CategoryTheory.MonoidalCategory E\nC' : Type u₁'\ninst✝³ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninst✝² : CategoryTheory.MonoidalCategory C'\ninst✝¹ : F.OplaxMonoidal\ninst✝ : G.OplaxMonoidal\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.η (F.prod G)).1 (CategoryTheory.Functor.OplaxMonoidal.η F)","decl":"@[simp] lemma prod_η_fst : (η (prod F G)).1 = η F := rfl\n"}
{"name":"CategoryTheory.Functor.prod_η_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁶ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} E\ninst✝⁴ : CategoryTheory.MonoidalCategory E\nC' : Type u₁'\ninst✝³ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninst✝² : CategoryTheory.MonoidalCategory C'\ninst✝¹ : F.OplaxMonoidal\ninst✝ : G.OplaxMonoidal\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.η (F.prod G)).2 (CategoryTheory.Functor.OplaxMonoidal.η G)","decl":"@[simp] lemma prod_η_snd : (η (prod F G)).2 = η G := rfl\n"}
{"name":"CategoryTheory.Functor.prod_δ_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁶ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} E\ninst✝⁴ : CategoryTheory.MonoidalCategory E\nC' : Type u₁'\ninst✝³ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninst✝² : CategoryTheory.MonoidalCategory C'\ninst✝¹ : F.OplaxMonoidal\ninst✝ : G.OplaxMonoidal\nX Y : Prod C E\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ (F.prod G) X Y).1 (CategoryTheory.Functor.OplaxMonoidal.δ F X.1 Y.1)","decl":"@[simp] lemma prod_δ_fst (X Y : C × E) : (δ (prod F G) X Y).1 = δ F _ _ := rfl\n"}
{"name":"CategoryTheory.Functor.prod_δ_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁶ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} E\ninst✝⁴ : CategoryTheory.MonoidalCategory E\nC' : Type u₁'\ninst✝³ : CategoryTheory.Category.{v₁', u₁'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninst✝² : CategoryTheory.MonoidalCategory C'\ninst✝¹ : F.OplaxMonoidal\ninst✝ : G.OplaxMonoidal\nX Y : Prod C E\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ (F.prod G) X Y).2 (CategoryTheory.Functor.OplaxMonoidal.δ G X.2 Y.2)","decl":"@[simp] lemma prod_δ_snd (X Y : C × E) : (δ (prod F G) X Y).2 = δ G _ _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.diag_ε","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε (CategoryTheory.Functor.diag C)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp] lemma diag_ε : ε (diag C) = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.Functor.diag_η","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.η (CategoryTheory.Functor.diag C)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.diag C).obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[simp] lemma diag_η : η (diag C) = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.Functor.diag_μ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ (CategoryTheory.Functor.diag C) X Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.Functor.diag C).obj X) ((CategoryTheory.Functor.diag C).obj Y)))","decl":"@[simp] lemma diag_μ (X Y : C) : μ (diag C) X Y = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.Functor.diag_δ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ (CategoryTheory.Functor.diag C) X Y) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.diag C).obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)))","decl":"@[simp] lemma diag_δ (X Y : C) : δ (diag C) X Y = 𝟙 _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_ε_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninst✝¹ : F.LaxMonoidal\ninst✝ : G.LaxMonoidal\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε (F.prod' G)).1 (CategoryTheory.Functor.LaxMonoidal.ε F)","decl":"@[simp] lemma prod'_ε_fst : (ε (prod' F G)).1 = ε F := by\n  change _ ≫ F.map (𝟙 _) = _\n  rw [Functor.map_id, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_ε_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninst✝¹ : F.LaxMonoidal\ninst✝ : G.LaxMonoidal\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε (F.prod' G)).2 (CategoryTheory.Functor.LaxMonoidal.ε G)","decl":"@[simp] lemma prod'_ε_snd : (ε (prod' F G)).2 = ε G := by\n  change _ ≫ G.map (𝟙 _) = _\n  rw [Functor.map_id, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_μ_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninst✝¹ : F.LaxMonoidal\ninst✝ : G.LaxMonoidal\nX Y : C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ (F.prod' G) X Y).1 (CategoryTheory.Functor.LaxMonoidal.μ F X Y)","decl":"@[simp] lemma prod'_μ_fst (X Y : C) : (μ (prod' F G) X Y).1 = μ F X Y := by\n  change _ ≫ F.map (𝟙 _) = _\n  rw [Functor.map_id, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_μ_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninst✝¹ : F.LaxMonoidal\ninst✝ : G.LaxMonoidal\nX Y : C\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ (F.prod' G) X Y).2 (CategoryTheory.Functor.LaxMonoidal.μ G X Y)","decl":"@[simp] lemma prod'_μ_snd (X Y : C) : (μ (prod' F G) X Y).2 = μ G X Y := by\n  change _ ≫ G.map (𝟙 _) = _\n  rw [Functor.map_id, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_η_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninst✝¹ : F.OplaxMonoidal\ninst✝ : G.OplaxMonoidal\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.η (F.prod' G)).1 (CategoryTheory.Functor.OplaxMonoidal.η F)","decl":"@[simp] lemma prod'_η_fst : (η (prod' F G)).1 = η F := by\n  change F.map (𝟙 _)  ≫ _ = _\n  rw [Functor.map_id, Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_η_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninst✝¹ : F.OplaxMonoidal\ninst✝ : G.OplaxMonoidal\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.η (F.prod' G)).2 (CategoryTheory.Functor.OplaxMonoidal.η G)","decl":"@[simp] lemma prod'_η_snd : (η (prod' F G)).2 = η G := by\n  change G.map (𝟙 _)  ≫ _ = _\n  rw [Functor.map_id, Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_δ_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninst✝¹ : F.OplaxMonoidal\ninst✝ : G.OplaxMonoidal\nX Y : C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ (F.prod' G) X Y).1 (CategoryTheory.Functor.OplaxMonoidal.δ F X Y)","decl":"@[simp] lemma prod'_δ_fst (X Y : C) : (δ (prod' F G) X Y).1 = δ F X Y := by\n  change F.map (𝟙 _) ≫ _ = _\n  rw [Functor.map_id, Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_δ_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninst✝¹ : F.OplaxMonoidal\ninst✝ : G.OplaxMonoidal\nX Y : C\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ (F.prod' G) X Y).2 (CategoryTheory.Functor.OplaxMonoidal.δ G X Y)","decl":"@[simp] lemma prod'_δ_snd (X Y : C) : (δ (prod' F G) X Y).2 = δ G X Y := by\n  change G.map (𝟙 _) ≫ _ = _\n  rw [Functor.map_id, Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod_comp_fst_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nX Y Z✝ : Prod C D\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom Z✝.1 Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).1 h) (CategoryTheory.CategoryStruct.comp f.1 (CategoryTheory.CategoryStruct.comp g.1 h))","decl":"@[simp, reassoc]\nlemma prod_comp_fst {C D : Type*} [Category C] [Category D]\n    {X Y Z : C × D} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).1 = f.1 ≫ g.1 := rfl\n\n"}
{"name":"CategoryTheory.Functor.prod_comp_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nX Y Z : Prod C D\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).1 (CategoryTheory.CategoryStruct.comp f.1 g.1)","decl":"@[simp, reassoc]\nlemma prod_comp_fst {C D : Type*} [Category C] [Category D]\n    {X Y Z : C × D} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).1 = f.1 ≫ g.1 := rfl\n\n"}
{"name":"CategoryTheory.Functor.prod_comp_snd_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nX Y Z✝ : Prod C D\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nZ : D\nh : Quiver.Hom Z✝.2 Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).2 h) (CategoryTheory.CategoryStruct.comp f.2 (CategoryTheory.CategoryStruct.comp g.2 h))","decl":"@[simp, reassoc]\nlemma prod_comp_snd {C D : Type*} [Category C] [Category D]\n    {X Y Z : C × D} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).2 = f.2 ≫ g.2 := rfl\n\n"}
{"name":"CategoryTheory.Functor.prod_comp_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Category.{u_4, u_2} D\nX Y Z : Prod C D\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).2 (CategoryTheory.CategoryStruct.comp f.2 g.2)","decl":"@[simp, reassoc]\nlemma prod_comp_snd {C D : Type*} [Category C] [Category D]\n    {X Y Z : C × D} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).2 = f.2 ≫ g.2 := rfl\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjointLaxMonoidal_ε","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.OplaxMonoidal\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε G) ((adj.homEquiv CategoryTheory.MonoidalCategoryStruct.tensorUnit CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.Functor.OplaxMonoidal.η F))","decl":"lemma rightAdjointLaxMonoidal_ε :\n    letI := adj.rightAdjointLaxMonoidal\n    ε G = adj.homEquiv _ _ (η F) := rfl\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjointLaxMonoidal_μ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.OplaxMonoidal\nX Y : D\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ G X Y) ((adj.homEquiv (CategoryTheory.MonoidalCategoryStruct.tensorObj (G.obj X) (G.obj Y)) (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.Functor.id D).obj X) ((CategoryTheory.Functor.id D).obj Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F (G.obj X) (G.obj Y)) (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.counit.app X) (adj.counit.app Y))))","decl":"lemma rightAdjointLaxMonoidal_μ (X Y : D) :\n    letI := adj.rightAdjointLaxMonoidal\n    μ G X Y = adj.homEquiv _ _ (δ F _ _ ≫ (adj.counit.app X ⊗ adj.counit.app Y)) := rfl\n\n"}
{"name":"CategoryTheory.Adjunction.IsMonoidal.leftAdjoint_μ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : F.OplaxMonoidal\ninst✝ : G.LaxMonoidal\nself : adj.IsMonoidal\nX Y : D\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ G X Y) ((adj.homEquiv (CategoryTheory.MonoidalCategoryStruct.tensorObj (G.obj X) (G.obj Y)) (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.Functor.id D).obj X) ((CategoryTheory.Functor.id D).obj Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F (G.obj X) (G.obj Y)) (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.counit.app X) (adj.counit.app Y))))","decl":"/-- When `adj : F ⊣ G` is an adjunction, with `F` oplax monoidal and `G` monoidal,\nthis typeclass expresses compatibilities between the adjunction and the (op)lax\nmonoidal structures. -/\nclass IsMonoidal [G.LaxMonoidal] : Prop where\n  leftAdjoint_ε : ε G = adj.homEquiv _ _ (η F) := by aesop_cat\n  leftAdjoint_μ (X Y : D) :\n    μ G X Y = adj.homEquiv _ _ (δ F _ _ ≫ (adj.counit.app X ⊗ adj.counit.app Y)) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.IsMonoidal.leftAdjoint_ε","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : F.OplaxMonoidal\ninst✝ : G.LaxMonoidal\nself : adj.IsMonoidal\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε G) ((adj.homEquiv CategoryTheory.MonoidalCategoryStruct.tensorUnit CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.Functor.OplaxMonoidal.η F))","decl":"/-- When `adj : F ⊣ G` is an adjunction, with `F` oplax monoidal and `G` monoidal,\nthis typeclass expresses compatibilities between the adjunction and the (op)lax\nmonoidal structures. -/\nclass IsMonoidal [G.LaxMonoidal] : Prop where\n  leftAdjoint_ε : ε G = adj.homEquiv _ _ (η F) := by aesop_cat\n  leftAdjoint_μ (X Y : D) :\n    μ G X Y = adj.homEquiv _ _ (δ F _ _ ≫ (adj.counit.app X ⊗ adj.counit.app Y)) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.instIsMonoidal","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.OplaxMonoidal\n⊢ adj.IsMonoidal","decl":"instance :\n    letI := adj.rightAdjointLaxMonoidal\n    adj.IsMonoidal := by\n  letI := adj.rightAdjointLaxMonoidal\n  constructor\n  · rfl\n  · intro _ _\n    rfl\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_unit_comp_map_η","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝² : F.OplaxMonoidal\ninst✝¹ : G.LaxMonoidal\ninst✝ : adj.IsMonoidal\n⊢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) (G.map (CategoryTheory.Functor.OplaxMonoidal.η F))) (CategoryTheory.Functor.LaxMonoidal.ε G)","decl":"@[reassoc]\nlemma unit_app_unit_comp_map_η : adj.unit.app (𝟙_ C) ≫ G.map (η F) = ε G :=\n  Adjunction.IsMonoidal.leftAdjoint_ε.symm\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_unit_comp_map_η_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝² : F.OplaxMonoidal\ninst✝¹ : G.LaxMonoidal\ninst✝ : adj.IsMonoidal\nZ : C\nh : Quiver.Hom (G.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.η F)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.ε G) h)","decl":"@[reassoc]\nlemma unit_app_unit_comp_map_η : adj.unit.app (𝟙_ C) ≫ G.map (η F) = ε G :=\n  Adjunction.IsMonoidal.leftAdjoint_ε.symm\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_tensor_comp_map_δ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝² : F.OplaxMonoidal\ninst✝¹ : G.LaxMonoidal\ninst✝ : adj.IsMonoidal\nX Y Z : C\nh : Quiver.Hom (G.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.δ F X Y)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.unit.app X) (adj.unit.app Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ G (F.obj X) (F.obj Y)) h))","decl":"@[reassoc]\nlemma unit_app_tensor_comp_map_δ (X Y : C) :\n    adj.unit.app (X ⊗ Y) ≫ G.map (δ F X Y) = (adj.unit.app X ⊗ adj.unit.app Y) ≫ μ G _ _ := by\n  rw [IsMonoidal.leftAdjoint_μ (adj := adj), homEquiv_unit]\n  dsimp\n  simp only [← adj.unit_naturality_assoc, ← Functor.map_comp, ← δ_natural_assoc,\n    ← tensor_comp, left_triangle_components, tensorHom_id, id_whiskerRight, comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_tensor_comp_map_δ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝² : F.OplaxMonoidal\ninst✝¹ : G.LaxMonoidal\ninst✝ : adj.IsMonoidal\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) (G.map (CategoryTheory.Functor.OplaxMonoidal.δ F X Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.unit.app X) (adj.unit.app Y)) (CategoryTheory.Functor.LaxMonoidal.μ G (F.obj X) (F.obj Y)))","decl":"@[reassoc]\nlemma unit_app_tensor_comp_map_δ (X Y : C) :\n    adj.unit.app (X ⊗ Y) ≫ G.map (δ F X Y) = (adj.unit.app X ⊗ adj.unit.app Y) ≫ μ G _ _ := by\n  rw [IsMonoidal.leftAdjoint_μ (adj := adj), homEquiv_unit]\n  dsimp\n  simp only [← adj.unit_naturality_assoc, ← Functor.map_comp, ← δ_natural_assoc,\n    ← tensor_comp, left_triangle_components, tensorHom_id, id_whiskerRight, comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.map_ε_comp_counit_app_unit","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝² : F.OplaxMonoidal\ninst✝¹ : G.LaxMonoidal\ninst✝ : adj.IsMonoidal\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Functor.LaxMonoidal.ε G)) (adj.counit.app CategoryTheory.MonoidalCategoryStruct.tensorUnit)) (CategoryTheory.Functor.OplaxMonoidal.η F)","decl":"@[reassoc]\nlemma map_ε_comp_counit_app_unit : F.map (ε G) ≫ adj.counit.app (𝟙_ D) = η F := by\n  rw [IsMonoidal.leftAdjoint_ε (adj := adj), homEquiv_unit, map_comp,\n    assoc, counit_naturality, left_triangle_components_assoc]\n\n"}
{"name":"CategoryTheory.Adjunction.map_ε_comp_counit_app_unit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝² : F.OplaxMonoidal\ninst✝¹ : G.LaxMonoidal\ninst✝ : adj.IsMonoidal\nZ : D\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Functor.LaxMonoidal.ε G)) (CategoryTheory.CategoryStruct.comp (adj.counit.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.η F) h)","decl":"@[reassoc]\nlemma map_ε_comp_counit_app_unit : F.map (ε G) ≫ adj.counit.app (𝟙_ D) = η F := by\n  rw [IsMonoidal.leftAdjoint_ε (adj := adj), homEquiv_unit, map_comp,\n    assoc, counit_naturality, left_triangle_components_assoc]\n\n"}
{"name":"CategoryTheory.Adjunction.map_μ_comp_counit_app_tensor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝² : F.OplaxMonoidal\ninst✝¹ : G.LaxMonoidal\ninst✝ : adj.IsMonoidal\nX Y : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Functor.LaxMonoidal.μ G X Y)) (adj.counit.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F (G.obj X) (G.obj Y)) (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.counit.app X) (adj.counit.app Y)))","decl":"@[reassoc]\nlemma map_μ_comp_counit_app_tensor (X Y : D) :\n    F.map (μ G X Y) ≫ adj.counit.app (X ⊗ Y) =\n      δ F _ _ ≫ (adj.counit.app X ⊗ adj.counit.app Y) := by\n  rw [IsMonoidal.leftAdjoint_μ (adj := adj), homEquiv_unit]\n  simp\n\n"}
{"name":"CategoryTheory.Adjunction.map_μ_comp_counit_app_tensor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝² : F.OplaxMonoidal\ninst✝¹ : G.LaxMonoidal\ninst✝ : adj.IsMonoidal\nX Y Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Functor.LaxMonoidal.μ G X Y)) (CategoryTheory.CategoryStruct.comp (adj.counit.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ F (G.obj X) (G.obj Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.counit.app X) (adj.counit.app Y)) h))","decl":"@[reassoc]\nlemma map_μ_comp_counit_app_tensor (X Y : D) :\n    F.map (μ G X Y) ≫ adj.counit.app (X ⊗ Y) =\n      δ F _ _ ≫ (adj.counit.app X ⊗ adj.counit.app Y) := by\n  rw [IsMonoidal.leftAdjoint_μ (adj := adj), homEquiv_unit]\n  simp\n\n"}
{"name":"CategoryTheory.Adjunction.instIsMonoidalId","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\n⊢ CategoryTheory.Adjunction.id.IsMonoidal","decl":"instance : (Adjunction.id (C := C)).IsMonoidal where\n  leftAdjoint_ε := by simp [id, homEquiv]\n  leftAdjoint_μ := by simp [id, homEquiv]\n\n"}
{"name":"CategoryTheory.Adjunction.isMonoidal_comp","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁸ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁷ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝⁶ : CategoryTheory.Category.{v₃, u₃} E\ninst✝⁵ : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝⁴ : F.OplaxMonoidal\ninst✝³ : G.LaxMonoidal\nF' : CategoryTheory.Functor D E\nG' : CategoryTheory.Functor E D\nadj' : CategoryTheory.Adjunction F' G'\ninst✝² : F'.OplaxMonoidal\ninst✝¹ : G'.LaxMonoidal\ninst✝ : adj'.IsMonoidal\n⊢ (adj.comp adj').IsMonoidal","decl":"instance isMonoidal_comp {F' : D ⥤ E} {G' : E ⥤ D} (adj' : F' ⊣ G')\n  [F'.OplaxMonoidal] [G'.LaxMonoidal] [adj'.IsMonoidal] : (adj.comp adj').IsMonoidal where\n  leftAdjoint_ε := by\n    dsimp [homEquiv]\n    rw [← adj.unit_app_unit_comp_map_η, ← adj'.unit_app_unit_comp_map_η,\n      assoc, comp_unit_app, assoc, ← Functor.map_comp,\n      ← adj'.unit_naturality_assoc, ← map_comp, ← map_comp]\n  leftAdjoint_μ X Y := by\n    apply ((adj.comp adj').homEquiv _ _).symm.injective\n    erw [Equiv.symm_apply_apply]\n    dsimp [homEquiv]\n    rw [comp_counit_app, comp_counit_app, comp_counit_app, assoc, tensor_comp, δ_natural_assoc]\n    dsimp\n    rw [← adj'.map_μ_comp_counit_app_tensor, ← map_comp_assoc, ← map_comp_assoc,\n      ← map_comp_assoc, ← adj.map_μ_comp_counit_app_tensor, assoc,\n      F.map_comp_assoc, counit_naturality]\n\n"}
{"name":"CategoryTheory.Equivalence.unitIso_hom_app_comp_inverse_map_η_functor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninst✝² : e.functor.Monoidal\ninst✝¹ : e.inverse.Monoidal\ninst✝ : e.IsMonoidal\nZ : C\nh : Quiver.Hom (e.inverse.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.unitIso.hom.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (e.inverse.map (CategoryTheory.Functor.OplaxMonoidal.η e.functor)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.ε e.inverse) h)","decl":"@[reassoc]\nlemma unitIso_hom_app_comp_inverse_map_η_functor :\n    e.unitIso.hom.app (𝟙_ C) ≫ e.inverse.map (η e.functor) = ε e.inverse :=\n  e.toAdjunction.unit_app_unit_comp_map_η\n\n"}
{"name":"CategoryTheory.Equivalence.unitIso_hom_app_comp_inverse_map_η_functor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninst✝² : e.functor.Monoidal\ninst✝¹ : e.inverse.Monoidal\ninst✝ : e.IsMonoidal\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.unitIso.hom.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) (e.inverse.map (CategoryTheory.Functor.OplaxMonoidal.η e.functor))) (CategoryTheory.Functor.LaxMonoidal.ε e.inverse)","decl":"@[reassoc]\nlemma unitIso_hom_app_comp_inverse_map_η_functor :\n    e.unitIso.hom.app (𝟙_ C) ≫ e.inverse.map (η e.functor) = ε e.inverse :=\n  e.toAdjunction.unit_app_unit_comp_map_η\n\n"}
{"name":"CategoryTheory.Equivalence.unitIso_hom_app_tensor_comp_inverse_map_δ_functor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninst✝² : e.functor.Monoidal\ninst✝¹ : e.inverse.Monoidal\ninst✝ : e.IsMonoidal\nX Y Z : C\nh : Quiver.Hom (e.inverse.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.functor.obj X) (e.functor.obj Y))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.unitIso.hom.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) (CategoryTheory.CategoryStruct.comp (e.inverse.map (CategoryTheory.Functor.OplaxMonoidal.δ e.functor X Y)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.unitIso.hom.app X) (e.unitIso.hom.app Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ e.inverse (e.functor.obj X) (e.functor.obj Y)) h))","decl":"@[reassoc]\nlemma unitIso_hom_app_tensor_comp_inverse_map_δ_functor (X Y : C) :\n    e.unitIso.hom.app (X ⊗ Y) ≫ e.inverse.map (δ e.functor X Y) =\n      (e.unitIso.hom.app X ⊗ e.unitIso.hom.app Y) ≫ μ e.inverse _ _ :=\n  e.toAdjunction.unit_app_tensor_comp_map_δ X Y\n\n"}
{"name":"CategoryTheory.Equivalence.unitIso_hom_app_tensor_comp_inverse_map_δ_functor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninst✝² : e.functor.Monoidal\ninst✝¹ : e.inverse.Monoidal\ninst✝ : e.IsMonoidal\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.unitIso.hom.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) (e.inverse.map (CategoryTheory.Functor.OplaxMonoidal.δ e.functor X Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.unitIso.hom.app X) (e.unitIso.hom.app Y)) (CategoryTheory.Functor.LaxMonoidal.μ e.inverse (e.functor.obj X) (e.functor.obj Y)))","decl":"@[reassoc]\nlemma unitIso_hom_app_tensor_comp_inverse_map_δ_functor (X Y : C) :\n    e.unitIso.hom.app (X ⊗ Y) ≫ e.inverse.map (δ e.functor X Y) =\n      (e.unitIso.hom.app X ⊗ e.unitIso.hom.app Y) ≫ μ e.inverse _ _ :=\n  e.toAdjunction.unit_app_tensor_comp_map_δ X Y\n\n"}
{"name":"CategoryTheory.Equivalence.functor_map_ε_inverse_comp_counitIso_hom_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninst✝² : e.functor.Monoidal\ninst✝¹ : e.inverse.Monoidal\ninst✝ : e.IsMonoidal\nZ : D\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.Functor.LaxMonoidal.ε e.inverse)) (CategoryTheory.CategoryStruct.comp (e.counitIso.hom.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.η e.functor) h)","decl":"@[reassoc]\nlemma functor_map_ε_inverse_comp_counitIso_hom_app :\n    e.functor.map (ε e.inverse) ≫ e.counitIso.hom.app (𝟙_ D) = η e.functor :=\n  e.toAdjunction.map_ε_comp_counit_app_unit\n\n"}
{"name":"CategoryTheory.Equivalence.functor_map_ε_inverse_comp_counitIso_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninst✝² : e.functor.Monoidal\ninst✝¹ : e.inverse.Monoidal\ninst✝ : e.IsMonoidal\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.Functor.LaxMonoidal.ε e.inverse)) (e.counitIso.hom.app CategoryTheory.MonoidalCategoryStruct.tensorUnit)) (CategoryTheory.Functor.OplaxMonoidal.η e.functor)","decl":"@[reassoc]\nlemma functor_map_ε_inverse_comp_counitIso_hom_app :\n    e.functor.map (ε e.inverse) ≫ e.counitIso.hom.app (𝟙_ D) = η e.functor :=\n  e.toAdjunction.map_ε_comp_counit_app_unit\n\n"}
{"name":"CategoryTheory.Equivalence.functor_map_μ_inverse_comp_counitIso_hom_app_tensor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninst✝² : e.functor.Monoidal\ninst✝¹ : e.inverse.Monoidal\ninst✝ : e.IsMonoidal\nX Y : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.Functor.LaxMonoidal.μ e.inverse X Y)) (e.counitIso.hom.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ e.functor (e.inverse.obj X) (e.inverse.obj Y)) (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.counitIso.hom.app X) (e.counitIso.hom.app Y)))","decl":"@[reassoc]\nlemma functor_map_μ_inverse_comp_counitIso_hom_app_tensor (X Y : D) :\n    e.functor.map (μ e.inverse X Y) ≫ e.counitIso.hom.app (X ⊗ Y) =\n      δ e.functor _ _ ≫ (e.counitIso.hom.app X ⊗ e.counitIso.hom.app Y) :=\n  e.toAdjunction.map_μ_comp_counit_app_tensor X Y\n\n"}
{"name":"CategoryTheory.Equivalence.functor_map_μ_inverse_comp_counitIso_hom_app_tensor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninst✝² : e.functor.Monoidal\ninst✝¹ : e.inverse.Monoidal\ninst✝ : e.IsMonoidal\nX Y Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.Functor.LaxMonoidal.μ e.inverse X Y)) (CategoryTheory.CategoryStruct.comp (e.counitIso.hom.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.δ e.functor (e.inverse.obj X) (e.inverse.obj Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.counitIso.hom.app X) (e.counitIso.hom.app Y)) h))","decl":"@[reassoc]\nlemma functor_map_μ_inverse_comp_counitIso_hom_app_tensor (X Y : D) :\n    e.functor.map (μ e.inverse X Y) ≫ e.counitIso.hom.app (X ⊗ Y) =\n      δ e.functor _ _ ≫ (e.counitIso.hom.app X ⊗ e.counitIso.hom.app Y) :=\n  e.toAdjunction.map_μ_comp_counit_app_tensor X Y\n\n"}
{"name":"CategoryTheory.Equivalence.counitIso_inv_app_comp_functor_map_η_inverse","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninst✝² : e.functor.Monoidal\ninst✝¹ : e.inverse.Monoidal\ninst✝ : e.IsMonoidal\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.counitIso.inv.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) (e.functor.map (CategoryTheory.Functor.OplaxMonoidal.η e.inverse))) (CategoryTheory.Functor.LaxMonoidal.ε e.functor)","decl":"@[reassoc]\nlemma counitIso_inv_app_comp_functor_map_η_inverse :\n    e.counitIso.inv.app (𝟙_ D) ≫ e.functor.map (η e.inverse) = ε e.functor := by\n  rw [← cancel_epi (η e.functor), Monoidal.η_ε, ← functor_map_ε_inverse_comp_counitIso_hom_app,\n    Category.assoc, Iso.hom_inv_id_app_assoc, Monoidal.map_ε_η]\n\n"}
{"name":"CategoryTheory.Equivalence.counitIso_inv_app_comp_functor_map_η_inverse_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninst✝² : e.functor.Monoidal\ninst✝¹ : e.inverse.Monoidal\ninst✝ : e.IsMonoidal\nZ : D\nh : Quiver.Hom (e.functor.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.counitIso.inv.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.Functor.OplaxMonoidal.η e.inverse)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.ε e.functor) h)","decl":"@[reassoc]\nlemma counitIso_inv_app_comp_functor_map_η_inverse :\n    e.counitIso.inv.app (𝟙_ D) ≫ e.functor.map (η e.inverse) = ε e.functor := by\n  rw [← cancel_epi (η e.functor), Monoidal.η_ε, ← functor_map_ε_inverse_comp_counitIso_hom_app,\n    Category.assoc, Iso.hom_inv_id_app_assoc, Monoidal.map_ε_η]\n\n"}
{"name":"CategoryTheory.Equivalence.counitIso_inv_app_tensor_comp_functor_map_δ_inverse","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninst✝² : e.functor.Monoidal\ninst✝¹ : e.inverse.Monoidal\ninst✝ : e.IsMonoidal\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.counitIso.inv.app (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.functor.obj X) (e.functor.obj Y))) (e.functor.map (CategoryTheory.Functor.OplaxMonoidal.δ e.inverse (e.functor.obj X) (e.functor.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ e.functor X Y) (e.functor.map (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.unitIso.hom.app X) (e.unitIso.hom.app Y))))","decl":"@[reassoc]\nlemma counitIso_inv_app_tensor_comp_functor_map_δ_inverse (X Y : C) :\n    e.counitIso.inv.app (e.functor.obj X ⊗ e.functor.obj Y) ≫\n      e.functor.map (δ e.inverse (e.functor.obj X) (e.functor.obj Y)) =\n      μ e.functor X Y ≫ e.functor.map (e.unitIso.hom.app X ⊗ e.unitIso.hom.app Y) := by\n  rw [← cancel_epi (δ e.functor _ _), Monoidal.δ_μ_assoc]\n  apply e.inverse.map_injective\n  simp [← cancel_epi (e.unitIso.hom.app (X ⊗ Y)), Functor.map_comp,\n    unitIso_hom_app_tensor_comp_inverse_map_δ_functor_assoc]\n\n"}
{"name":"CategoryTheory.Equivalence.counitIso_inv_app_tensor_comp_functor_map_δ_inverse_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninst✝² : e.functor.Monoidal\ninst✝¹ : e.inverse.Monoidal\ninst✝ : e.IsMonoidal\nX Y : C\nZ : D\nh : Quiver.Hom (e.functor.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.counitIso.inv.app (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.functor.obj X) (e.functor.obj Y))) (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.Functor.OplaxMonoidal.δ e.inverse (e.functor.obj X) (e.functor.obj Y))) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ e.functor X Y) (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.unitIso.hom.app X) (e.unitIso.hom.app Y))) h))","decl":"@[reassoc]\nlemma counitIso_inv_app_tensor_comp_functor_map_δ_inverse (X Y : C) :\n    e.counitIso.inv.app (e.functor.obj X ⊗ e.functor.obj Y) ≫\n      e.functor.map (δ e.inverse (e.functor.obj X) (e.functor.obj Y)) =\n      μ e.functor X Y ≫ e.functor.map (e.unitIso.hom.app X ⊗ e.unitIso.hom.app Y) := by\n  rw [← cancel_epi (δ e.functor _ _), Monoidal.δ_μ_assoc]\n  apply e.inverse.map_injective\n  simp [← cancel_epi (e.unitIso.hom.app (X ⊗ Y)), Functor.map_comp,\n    unitIso_hom_app_tensor_comp_inverse_map_δ_functor_assoc]\n\n"}
{"name":"CategoryTheory.Equivalence.isMonoidal_refl","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\n⊢ CategoryTheory.Equivalence.refl.IsMonoidal","decl":"/-- The obvious auto-equivalence of a monoidal category is monoidal. -/\ninstance isMonoidal_refl : (Equivalence.refl (C := C)).IsMonoidal :=\n  inferInstanceAs (Adjunction.id (C := C)).IsMonoidal\n\n"}
{"name":"CategoryTheory.Equivalence.isMonoidal_symm","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninst✝² : e.functor.Monoidal\ninst✝¹ : e.inverse.Monoidal\ninst✝ : e.IsMonoidal\n⊢ e.symm.IsMonoidal","decl":"/-- The inverse of a monoidal category equivalence is also a monoidal category equivalence. -/\ninstance isMonoidal_symm [e.inverse.Monoidal] [e.IsMonoidal] :\n    e.symm.IsMonoidal where\n  leftAdjoint_ε := by\n    simp only [toAdjunction, Adjunction.homEquiv_unit]\n    dsimp [symm]\n    rw [counitIso_inv_app_comp_functor_map_η_inverse]\n  leftAdjoint_μ X Y := by\n    simp only [toAdjunction, Adjunction.homEquiv_unit]\n    dsimp [symm]\n    rw [map_comp, counitIso_inv_app_tensor_comp_functor_map_δ_inverse_assoc,\n      ← Functor.map_comp, ← tensor_comp, Iso.hom_inv_id_app, Iso.hom_inv_id_app]\n    dsimp\n    rw [tensorHom_id, id_whiskerRight, map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Equivalence.isMonoidal_trans","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝⁸ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁷ : CategoryTheory.MonoidalCategory D\nE : Type u₃\ninst✝⁶ : CategoryTheory.Category.{v₃, u₃} E\ninst✝⁵ : CategoryTheory.MonoidalCategory E\ne : CategoryTheory.Equivalence C D\ninst✝⁴ : e.functor.Monoidal\ninst✝³ : e.inverse.Monoidal\ne' : CategoryTheory.Equivalence D E\ninst✝² : e'.functor.Monoidal\ninst✝¹ : e'.inverse.Monoidal\ninst✝ : e'.IsMonoidal\n⊢ (e.trans e').IsMonoidal","decl":"/-- The composition of two monoidal category equivalences is monoidal. -/\ninstance isMonoidal_trans [e'.functor.Monoidal] [e'.inverse.Monoidal] [e'.IsMonoidal] :\n    (e.trans e').IsMonoidal := by\n  dsimp [Equivalence.IsMonoidal]\n  rw [trans_toAdjunction]\n  infer_instance\n\n"}
{"name":"CategoryTheory.LaxMonoidalFunctor.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\ntoFunctor✝ : CategoryTheory.Functor C D\nlaxMonoidal✝ : autoParam toFunctor✝.LaxMonoidal _auto✝\ntoFunctor : CategoryTheory.Functor C D\nlaxMonoidal : autoParam toFunctor.LaxMonoidal _auto✝\n⊢ Eq (Eq { toFunctor := toFunctor✝, laxMonoidal := laxMonoidal✝ } { toFunctor := toFunctor, laxMonoidal := laxMonoidal }) (And (Eq toFunctor✝ toFunctor) (HEq laxMonoidal✝ laxMonoidal))","decl":"/-- Bundled version of lax monoidal functors. This type is equipped with a category\nstructure in `CategoryTheory.Monoidal.NaturalTransformation`. -/\nstructure LaxMonoidalFunctor extends C ⥤ D where\n  laxMonoidal : toFunctor.LaxMonoidal := by infer_instance\n\n"}
{"name":"CategoryTheory.LaxMonoidalFunctor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.MonoidalCategory D\ninst✝¹ : SizeOf C\ninst✝ : SizeOf D\ntoFunctor : CategoryTheory.Functor C D\nlaxMonoidal : autoParam toFunctor.LaxMonoidal _auto✝\n⊢ Eq (SizeOf.sizeOf { toFunctor := toFunctor, laxMonoidal := laxMonoidal }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toFunctor)) (SizeOf.sizeOf laxMonoidal))","decl":"/-- Bundled version of lax monoidal functors. This type is equipped with a category\nstructure in `CategoryTheory.Monoidal.NaturalTransformation`. -/\nstructure LaxMonoidalFunctor extends C ⥤ D where\n  laxMonoidal : toFunctor.LaxMonoidal := by infer_instance\n\n"}
{"name":"CategoryTheory.LaxMonoidalFunctor.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.MonoidalCategory D\ntoFunctor✝ : CategoryTheory.Functor C D\nlaxMonoidal✝ : autoParam toFunctor✝.LaxMonoidal _auto✝\ntoFunctor : CategoryTheory.Functor C D\nlaxMonoidal : autoParam toFunctor.LaxMonoidal _auto✝\nx✝ : Eq { toFunctor := toFunctor✝, laxMonoidal := laxMonoidal✝ } { toFunctor := toFunctor, laxMonoidal := laxMonoidal }\n⊢ And (Eq toFunctor✝ toFunctor) (HEq laxMonoidal✝ laxMonoidal)","decl":"/-- Bundled version of lax monoidal functors. This type is equipped with a category\nstructure in `CategoryTheory.Monoidal.NaturalTransformation`. -/\nstructure LaxMonoidalFunctor extends C ⥤ D where\n  laxMonoidal : toFunctor.LaxMonoidal := by infer_instance\n\n"}
{"name":"CategoryTheory.LaxMonoidalFunctor.of_toFunctor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst✝ : F.LaxMonoidal\n⊢ Eq (CategoryTheory.LaxMonoidalFunctor.of F).toFunctor F","decl":"/-- Constructor for `LaxMonoidalFunctor C D`. -/\n@[simps toFunctor]\ndef of (F : C ⥤ D) [F.LaxMonoidal] : LaxMonoidalFunctor C D where\n  toFunctor := F\n\n"}
