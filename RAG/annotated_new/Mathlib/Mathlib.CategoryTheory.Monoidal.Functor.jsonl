{"name":"CategoryTheory.Functor.LaxMonoidal.right_unitality'","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.LaxMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) CategoryTheory.Functor.LaxMonoidal.Îµ') (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼' X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))","decl":"/-- A functor `F : C â¥¤ D` between monoidal categories is lax monoidal if it is\nequipped with morphisms `Îµ : ğŸ™_ D âŸ¶ F.obj (ğŸ™_ C)` and `Î¼ X Y : F.obj X âŠ— F.obj Y âŸ¶ F.obj (X âŠ— Y)`,\nsatisfying the appropriate coherences. -/\nclass LaxMonoidal where\n  /-- unit morphism -/\n  Îµ' : ğŸ™_ D âŸ¶ F.obj (ğŸ™_ C)\n  /-- tensorator -/\n  Î¼' : âˆ€ X Y : C, F.obj X âŠ— F.obj Y âŸ¶ F.obj (X âŠ— Y)\n  Î¼'_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      F.map f â–· F.obj X' â‰« Î¼' Y X' = Î¼' X X' â‰« F.map (f â–· X') := by\n    aesop_cat\n  Î¼'_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      F.obj X' â— F.map f â‰« Î¼' X' Y = Î¼' X' X â‰« F.map (X' â— f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity' :\n    âˆ€ X Y Z : C,\n      Î¼' X Y â–· F.obj Z â‰« Î¼' (X âŠ— Y) Z â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— Î¼' Y Z â‰« Î¼' X (Y âŠ— Z) := by\n    aesop_cat\n  -- unitality\n  left_unitality' :\n    âˆ€ X : C, (Î»_ (F.obj X)).hom = Îµ' â–· F.obj X â‰« Î¼' (ğŸ™_ C) X â‰« F.map (Î»_ X).hom := by\n      aesop_cat\n  right_unitality' :\n    âˆ€ X : C, (Ï_ (F.obj X)).hom = F.obj X â— Îµ' â‰« Î¼' X (ğŸ™_ C) â‰« F.map (Ï_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.left_unitality'","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.LaxMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight CategoryTheory.Functor.LaxMonoidal.Îµ' (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼' CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))","decl":"/-- A functor `F : C â¥¤ D` between monoidal categories is lax monoidal if it is\nequipped with morphisms `Îµ : ğŸ™_ D âŸ¶ F.obj (ğŸ™_ C)` and `Î¼ X Y : F.obj X âŠ— F.obj Y âŸ¶ F.obj (X âŠ— Y)`,\nsatisfying the appropriate coherences. -/\nclass LaxMonoidal where\n  /-- unit morphism -/\n  Îµ' : ğŸ™_ D âŸ¶ F.obj (ğŸ™_ C)\n  /-- tensorator -/\n  Î¼' : âˆ€ X Y : C, F.obj X âŠ— F.obj Y âŸ¶ F.obj (X âŠ— Y)\n  Î¼'_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      F.map f â–· F.obj X' â‰« Î¼' Y X' = Î¼' X X' â‰« F.map (f â–· X') := by\n    aesop_cat\n  Î¼'_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      F.obj X' â— F.map f â‰« Î¼' X' Y = Î¼' X' X â‰« F.map (X' â— f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity' :\n    âˆ€ X Y Z : C,\n      Î¼' X Y â–· F.obj Z â‰« Î¼' (X âŠ— Y) Z â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— Î¼' Y Z â‰« Î¼' X (Y âŠ— Z) := by\n    aesop_cat\n  -- unitality\n  left_unitality' :\n    âˆ€ X : C, (Î»_ (F.obj X)).hom = Îµ' â–· F.obj X â‰« Î¼' (ğŸ™_ C) X â‰« F.map (Î»_ X).hom := by\n      aesop_cat\n  right_unitality' :\n    âˆ€ X : C, (Ï_ (F.obj X)).hom = F.obj X â— Îµ' â‰« Î¼' X (ğŸ™_ C) â‰« F.map (Ï_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.Î¼'_natural_right","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.LaxMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (CategoryTheory.Functor.LaxMonoidal.Î¼' X' Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼' X' X) (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))","decl":"/-- A functor `F : C â¥¤ D` between monoidal categories is lax monoidal if it is\nequipped with morphisms `Îµ : ğŸ™_ D âŸ¶ F.obj (ğŸ™_ C)` and `Î¼ X Y : F.obj X âŠ— F.obj Y âŸ¶ F.obj (X âŠ— Y)`,\nsatisfying the appropriate coherences. -/\nclass LaxMonoidal where\n  /-- unit morphism -/\n  Îµ' : ğŸ™_ D âŸ¶ F.obj (ğŸ™_ C)\n  /-- tensorator -/\n  Î¼' : âˆ€ X Y : C, F.obj X âŠ— F.obj Y âŸ¶ F.obj (X âŠ— Y)\n  Î¼'_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      F.map f â–· F.obj X' â‰« Î¼' Y X' = Î¼' X X' â‰« F.map (f â–· X') := by\n    aesop_cat\n  Î¼'_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      F.obj X' â— F.map f â‰« Î¼' X' Y = Î¼' X' X â‰« F.map (X' â— f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity' :\n    âˆ€ X Y Z : C,\n      Î¼' X Y â–· F.obj Z â‰« Î¼' (X âŠ— Y) Z â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— Î¼' Y Z â‰« Î¼' X (Y âŠ— Z) := by\n    aesop_cat\n  -- unitality\n  left_unitality' :\n    âˆ€ X : C, (Î»_ (F.obj X)).hom = Îµ' â–· F.obj X â‰« Î¼' (ğŸ™_ C) X â‰« F.map (Î»_ X).hom := by\n      aesop_cat\n  right_unitality' :\n    âˆ€ X : C, (Ï_ (F.obj X)).hom = F.obj X â— Îµ' â‰« Î¼' X (ğŸ™_ C) â‰« F.map (Ï_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.Î¼'_natural_left","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.LaxMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (CategoryTheory.Functor.LaxMonoidal.Î¼' Y X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼' X X') (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))","decl":"/-- A functor `F : C â¥¤ D` between monoidal categories is lax monoidal if it is\nequipped with morphisms `Îµ : ğŸ™_ D âŸ¶ F.obj (ğŸ™_ C)` and `Î¼ X Y : F.obj X âŠ— F.obj Y âŸ¶ F.obj (X âŠ— Y)`,\nsatisfying the appropriate coherences. -/\nclass LaxMonoidal where\n  /-- unit morphism -/\n  Îµ' : ğŸ™_ D âŸ¶ F.obj (ğŸ™_ C)\n  /-- tensorator -/\n  Î¼' : âˆ€ X Y : C, F.obj X âŠ— F.obj Y âŸ¶ F.obj (X âŠ— Y)\n  Î¼'_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      F.map f â–· F.obj X' â‰« Î¼' Y X' = Î¼' X X' â‰« F.map (f â–· X') := by\n    aesop_cat\n  Î¼'_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      F.obj X' â— F.map f â‰« Î¼' X' Y = Î¼' X' X â‰« F.map (X' â— f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity' :\n    âˆ€ X Y Z : C,\n      Î¼' X Y â–· F.obj Z â‰« Î¼' (X âŠ— Y) Z â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— Î¼' Y Z â‰« Î¼' X (Y âŠ— Z) := by\n    aesop_cat\n  -- unitality\n  left_unitality' :\n    âˆ€ X : C, (Î»_ (F.obj X)).hom = Îµ' â–· F.obj X â‰« Î¼' (ğŸ™_ C) X â‰« F.map (Î»_ X).hom := by\n      aesop_cat\n  right_unitality' :\n    âˆ€ X : C, (Ï_ (F.obj X)).hom = F.obj X â— Îµ' â‰« Î¼' X (ğŸ™_ C) â‰« F.map (Ï_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.associativity'","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.LaxMonoidal\nX Y Z : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Î¼' X Y) (F.obj Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼' (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.Î¼' Y Z)) (CategoryTheory.Functor.LaxMonoidal.Î¼' X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))","decl":"/-- A functor `F : C â¥¤ D` between monoidal categories is lax monoidal if it is\nequipped with morphisms `Îµ : ğŸ™_ D âŸ¶ F.obj (ğŸ™_ C)` and `Î¼ X Y : F.obj X âŠ— F.obj Y âŸ¶ F.obj (X âŠ— Y)`,\nsatisfying the appropriate coherences. -/\nclass LaxMonoidal where\n  /-- unit morphism -/\n  Îµ' : ğŸ™_ D âŸ¶ F.obj (ğŸ™_ C)\n  /-- tensorator -/\n  Î¼' : âˆ€ X Y : C, F.obj X âŠ— F.obj Y âŸ¶ F.obj (X âŠ— Y)\n  Î¼'_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      F.map f â–· F.obj X' â‰« Î¼' Y X' = Î¼' X X' â‰« F.map (f â–· X') := by\n    aesop_cat\n  Î¼'_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      F.obj X' â— F.map f â‰« Î¼' X' Y = Î¼' X' X â‰« F.map (X' â— f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity' :\n    âˆ€ X Y Z : C,\n      Î¼' X Y â–· F.obj Z â‰« Î¼' (X âŠ— Y) Z â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— Î¼' Y Z â‰« Î¼' X (Y âŠ— Z) := by\n    aesop_cat\n  -- unitality\n  left_unitality' :\n    âˆ€ X : C, (Î»_ (F.obj X)).hom = Îµ' â–· F.obj X â‰« Î¼' (ğŸ™_ C) X â‰« F.map (Î»_ X).hom := by\n      aesop_cat\n  right_unitality' :\n    âˆ€ X : C, (Ï_ (F.obj X)).hom = F.obj X â— Îµ' â‰« Î¼' X (ğŸ™_ C) â‰« F.map (Ï_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.Î¼_natural_left","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X X') (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))","decl":"@[reassoc (attr := simp)]\nlemma Î¼_natural_left {X Y : C} (f : X âŸ¶ Y) (X' : C) :\n    F.map f â–· F.obj X' â‰« Î¼ F Y X' = Î¼ F X X' â‰« F.map (f â–· X') := by\n  apply Î¼'_natural_left\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.Î¼_natural_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y X')) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y X') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X X') (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')) h))","decl":"@[reassoc (attr := simp)]\nlemma Î¼_natural_left {X Y : C} (f : X âŸ¶ Y) (X' : C) :\n    F.map f â–· F.obj X' â‰« Î¼ F Y X' = Î¼ F X X' â‰« F.map (f â–· X') := by\n  apply Î¼'_natural_left\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.Î¼_natural_right","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (CategoryTheory.Functor.LaxMonoidal.Î¼ F X' Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X' X) (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))","decl":"@[reassoc (attr := simp)]\nlemma Î¼_natural_right {X Y : C} (X' : C) (f : X âŸ¶ Y) :\n    F.obj X' â— F.map f â‰« Î¼ F X' Y = Î¼ F X' X â‰« F.map (X' â— f) := by\n  apply Î¼'_natural_right\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.Î¼_natural_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X' Y)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X' Y) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X' X) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)) h))","decl":"@[reassoc (attr := simp)]\nlemma Î¼_natural_right {X Y : C} (X' : C) (f : X âŸ¶ Y) :\n    F.obj X' â— F.map f â‰« Î¼ F X' Y = Î¼ F X' X â‰« F.map (X' â— f) := by\n  apply Î¼'_natural_right\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.associativity","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX Y Z : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) (F.obj Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y Z)) (CategoryTheory.Functor.LaxMonoidal.Î¼ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))","decl":"@[reassoc (attr := simp)]\nlemma associativity (X Y Z : C) :\n    Î¼ F X Y â–· F.obj Z â‰« Î¼ F (X âŠ— Y) Z â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— Î¼ F Y Z â‰« Î¼ F X (Y âŠ— Z) := by\n  apply associativity'\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.associativity_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX Y Zâœ : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Zâœ))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) (F.obj Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Zâœ) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Zâœ).hom) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Zâœ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Zâœ)) h)))","decl":"@[reassoc (attr := simp)]\nlemma associativity (X Y Z : C) :\n    Î¼ F X Y â–· F.obj Z â‰« Î¼ F (X âŠ— Y) Z â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— Î¼ F Y Z â‰« Î¼ F X (Y âŠ— Z) := by\n  apply associativity'\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.left_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Îµ F) (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) h)))","decl":"@[simp, reassoc]\nlemma left_unitality (X : C) :\n    (Î»_ (F.obj X)).hom = Îµ F â–· F.obj X â‰« Î¼ F (ğŸ™_ C) X â‰« F.map (Î»_ X).hom := by\n  apply left_unitality'\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.left_unitality","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Îµ F) (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))","decl":"@[simp, reassoc]\nlemma left_unitality (X : C) :\n    (Î»_ (F.obj X)).hom = Îµ F â–· F.obj X â‰« Î¼ F (ğŸ™_ C) X â‰« F.map (Î»_ X).hom := by\n  apply left_unitality'\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.right_unitality","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.Îµ F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))","decl":"@[simp, reassoc]\nlemma right_unitality (X : C) :\n    (Ï_ (F.obj X)).hom = F.obj X â— Îµ F â‰« Î¼ F X (ğŸ™_ C) â‰« F.map (Ï_ X).hom := by\n  apply right_unitality'\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.right_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.Îµ F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) h)))","decl":"@[simp, reassoc]\nlemma right_unitality (X : C) :\n    (Ï_ (F.obj X)).hom = F.obj X â— Îµ F â‰« Î¼ F X (ğŸ™_ C) â‰« F.map (Ï_ X).hom := by\n  apply right_unitality'\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.Î¼_natural","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y Y')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X X') (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)))","decl":"@[reassoc (attr := simp)]\ntheorem Î¼_natural {X Y X' Y' : C} (f : X âŸ¶ Y) (g : X' âŸ¶ Y') :\n    (F.map f âŠ— F.map g) â‰« Î¼ F Y Y' = Î¼ F X X' â‰« F.map (f âŠ— g) := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.Î¼_natural_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Y')) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y Y') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X X') (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) h))","decl":"@[reassoc (attr := simp)]\ntheorem Î¼_natural {X Y X' Y' : C} (f : X âŸ¶ Y) (g : X' âŸ¶ Y') :\n    (F.map f âŠ— F.map g) â‰« Î¼ F Y Y' = Î¼ F X X' â‰« F.map (f âŠ— g) := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.left_unitality_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit X)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Îµ F) (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) h))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) h)","decl":"@[reassoc (attr := simp)]\ntheorem left_unitality_inv (X : C) :\n    (Î»_ (F.obj X)).inv â‰« Îµ F â–· F.obj X â‰« Î¼ F (ğŸ™_ C) X = F.map (Î»_ X).inv := by\n  rw [Iso.inv_comp_eq, left_unitality, Category.assoc, Category.assoc, â† F.map_comp,\n    Iso.hom_inv_id, F.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.left_unitality_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Îµ F) (F.obj X)) (CategoryTheory.Functor.LaxMonoidal.Î¼ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X))) (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv)","decl":"@[reassoc (attr := simp)]\ntheorem left_unitality_inv (X : C) :\n    (Î»_ (F.obj X)).inv â‰« Îµ F â–· F.obj X â‰« Î¼ F (ğŸ™_ C) X = F.map (Î»_ X).inv := by\n  rw [Iso.inv_comp_eq, left_unitality, Category.assoc, Category.assoc, â† F.map_comp,\n    Iso.hom_inv_id, F.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.right_unitality_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.Îµ F)) (CategoryTheory.Functor.LaxMonoidal.Î¼ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit))) (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv)","decl":"@[reassoc (attr := simp)]\ntheorem right_unitality_inv (X : C) :\n    (Ï_ (F.obj X)).inv â‰« F.obj X â— Îµ F â‰« Î¼ F X (ğŸ™_ C) = F.map (Ï_ X).inv := by\n  rw [Iso.inv_comp_eq, right_unitality, Category.assoc, Category.assoc, â† F.map_comp,\n    Iso.hom_inv_id, F.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.right_unitality_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X CategoryTheory.MonoidalCategoryStruct.tensorUnit)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.Îµ F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) h))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) h)","decl":"@[reassoc (attr := simp)]\ntheorem right_unitality_inv (X : C) :\n    (Ï_ (F.obj X)).inv â‰« F.obj X â— Îµ F â‰« Î¼ F X (ğŸ™_ C) = F.map (Ï_ X).inv := by\n  rw [Iso.inv_comp_eq, right_unitality, Category.assoc, Category.assoc, â† F.map_comp,\n    Iso.hom_inv_id, F.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.associativity_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX Y Z : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) (F.obj Z)) (CategoryTheory.Functor.LaxMonoidal.Î¼ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z)))","decl":"@[reassoc (attr := simp)]\ntheorem associativity_inv (X Y Z : C) :\n    F.obj X â— Î¼ F Y Z â‰« Î¼ F X (Y âŠ— Z) â‰« F.map (Î±_ X Y Z).inv =\n      (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).inv â‰« Î¼ F X Y â–· F.obj Z â‰« Î¼ F (X âŠ— Y) Z := by\n  rw [Iso.eq_inv_comp, â† associativity_assoc, â† F.map_comp, Iso.hom_inv_id,\n    F.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.associativity_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nX Y Zâœ : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Zâœ)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Zâœ)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Zâœ).inv) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Zâœ)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) (F.obj Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Zâœ) h)))","decl":"@[reassoc (attr := simp)]\ntheorem associativity_inv (X Y Z : C) :\n    F.obj X â— Î¼ F Y Z â‰« Î¼ F X (Y âŠ— Z) â‰« F.map (Î±_ X Y Z).inv =\n      (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).inv â‰« Î¼ F X Y â–· F.obj Z â‰« Î¼ F (X âŠ— Y) Z := by\n  rw [Iso.eq_inv_comp, â† associativity_assoc, â† F.map_comp, Iso.hom_inv_id,\n    F.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.ofTensorHom_Îµ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nÎµ' : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nâŠ¢ Eq (sorryAx (Unit â†’ Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 196).num 4).num 196).num 7).num 4).num 7).str \"_sorry\").str \"_@\").str \"_hyg\").num 3184))) Îµ'","decl":"lemma ofTensorHom_Îµ :\n    letI := (ofTensorHom Îµ' Î¼' Î¼'_natural associativity' left_unitality' right_unitality')\n    Îµ F = Îµ' := rfl\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.ofTensorHom_Î¼","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nÎ¼' : (X Y : C) â†’ Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nâŠ¢ Eq (sorryAx (Unit â†’ (X Y : C) â†’ Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 200).num 4).num 200).num 7).num 4).num 7).str \"_sorry\").str \"_@\").str \"_hyg\").num 3714))) Î¼'","decl":"lemma ofTensorHom_Î¼ :\n    letI := (ofTensorHom Îµ' Î¼' Î¼'_natural associativity' left_unitality' right_unitality')\n    Î¼ F = Î¼' := rfl\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.id_Îµ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Îµ (CategoryTheory.Functor.id C)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp]\nlemma id_Îµ : Îµ (ğŸ­ C) = ğŸ™ _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.id_Î¼","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Î¼ (CategoryTheory.Functor.id C) X Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.Functor.id C).obj X) ((CategoryTheory.Functor.id C).obj Y)))","decl":"@[simp]\nlemma id_Î¼ (X Y : C) : Î¼ (ğŸ­ C) X Y = ğŸ™ _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.comp_Îµ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ· : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¶ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœÂ² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ¹ : F.LaxMonoidal\ninstâœ : G.LaxMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Îµ (F.comp G)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Îµ G) (G.map (CategoryTheory.Functor.LaxMonoidal.Îµ F)))","decl":"@[simp]\nlemma comp_Îµ : Îµ (F â‹™ G) = Îµ G â‰« G.map (Îµ F) := rfl\n\n"}
{"name":"CategoryTheory.Functor.LaxMonoidal.comp_Î¼","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ· : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¶ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœÂ² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ¹ : F.LaxMonoidal\ninstâœ : G.LaxMonoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Î¼ (F.comp G) X Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ G (F.obj X) (F.obj Y)) (G.map (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y)))","decl":"@[simp]\nlemma comp_Î¼ (X Y : C) : Î¼ (F â‹™ G) X Y = Î¼ G _ _ â‰« G.map (Î¼ F X Y) := rfl\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.Î´'_natural_right","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.OplaxMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´' X' X) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)) (CategoryTheory.Functor.OplaxMonoidal.Î´' X' Y))","decl":"/-- A functor `F : C â¥¤ D` between monoidal categories is oplax monoidal if it is\nequipped with morphisms `Î· : F.obj (ğŸ™_ C) âŸ¶ ğŸ™ _D` and `Î´ X Y : F.obj (X âŠ— Y) âŸ¶ F.obj X âŠ— F.obj Y`,\nsatisfying the appropriate coherences. -/\nclass OplaxMonoidal where\n  /-- counit morphism -/\n  Î·' : F.obj (ğŸ™_ C) âŸ¶ ğŸ™_ D\n  /-- cotensorator -/\n  Î´' : âˆ€ X Y : C, F.obj (X âŠ— Y) âŸ¶ F.obj X âŠ— F.obj Y\n  Î´'_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      Î´' X X' â‰« F.map f â–· F.obj X' = F.map (f â–· X') â‰« Î´' Y X' := by\n    aesop_cat\n  Î´'_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      Î´' X' X â‰« F.obj X' â— F.map f = F.map (X' â— f) â‰« Î´' X' Y := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  oplax_associativity' :\n    âˆ€ X Y Z : C,\n      Î´' (X âŠ— Y) Z â‰« Î´' X Y â–· F.obj Z â‰« (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n        F.map (Î±_ X Y Z).hom â‰« Î´' X (Y âŠ— Z) â‰« F.obj X â— Î´' Y Z := by\n    aesop_cat\n  -- unitality\n  oplax_left_unitality' :\n    âˆ€ X : C, (Î»_ (F.obj X)).inv = F.map (Î»_ X).inv â‰« Î´' (ğŸ™_ C) X â‰« Î·' â–· F.obj X := by\n      aesop_cat\n  oplax_right_unitality' :\n    âˆ€ X : C, (Ï_ (F.obj X)).inv = F.map (Ï_ X).inv â‰« Î´' X (ğŸ™_ C) â‰« F.obj X â— Î·' := by\n      aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.oplax_right_unitality'","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.OplaxMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´' X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) CategoryTheory.Functor.OplaxMonoidal.Î·')))","decl":"/-- A functor `F : C â¥¤ D` between monoidal categories is oplax monoidal if it is\nequipped with morphisms `Î· : F.obj (ğŸ™_ C) âŸ¶ ğŸ™ _D` and `Î´ X Y : F.obj (X âŠ— Y) âŸ¶ F.obj X âŠ— F.obj Y`,\nsatisfying the appropriate coherences. -/\nclass OplaxMonoidal where\n  /-- counit morphism -/\n  Î·' : F.obj (ğŸ™_ C) âŸ¶ ğŸ™_ D\n  /-- cotensorator -/\n  Î´' : âˆ€ X Y : C, F.obj (X âŠ— Y) âŸ¶ F.obj X âŠ— F.obj Y\n  Î´'_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      Î´' X X' â‰« F.map f â–· F.obj X' = F.map (f â–· X') â‰« Î´' Y X' := by\n    aesop_cat\n  Î´'_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      Î´' X' X â‰« F.obj X' â— F.map f = F.map (X' â— f) â‰« Î´' X' Y := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  oplax_associativity' :\n    âˆ€ X Y Z : C,\n      Î´' (X âŠ— Y) Z â‰« Î´' X Y â–· F.obj Z â‰« (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n        F.map (Î±_ X Y Z).hom â‰« Î´' X (Y âŠ— Z) â‰« F.obj X â— Î´' Y Z := by\n    aesop_cat\n  -- unitality\n  oplax_left_unitality' :\n    âˆ€ X : C, (Î»_ (F.obj X)).inv = F.map (Î»_ X).inv â‰« Î´' (ğŸ™_ C) X â‰« Î·' â–· F.obj X := by\n      aesop_cat\n  oplax_right_unitality' :\n    âˆ€ X : C, (Ï_ (F.obj X)).inv = F.map (Ï_ X).inv â‰« Î´' X (ğŸ™_ C) â‰« F.obj X â— Î·' := by\n      aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.Î´'_natural_left","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.OplaxMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´' X X') (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X'))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')) (CategoryTheory.Functor.OplaxMonoidal.Î´' Y X'))","decl":"/-- A functor `F : C â¥¤ D` between monoidal categories is oplax monoidal if it is\nequipped with morphisms `Î· : F.obj (ğŸ™_ C) âŸ¶ ğŸ™ _D` and `Î´ X Y : F.obj (X âŠ— Y) âŸ¶ F.obj X âŠ— F.obj Y`,\nsatisfying the appropriate coherences. -/\nclass OplaxMonoidal where\n  /-- counit morphism -/\n  Î·' : F.obj (ğŸ™_ C) âŸ¶ ğŸ™_ D\n  /-- cotensorator -/\n  Î´' : âˆ€ X Y : C, F.obj (X âŠ— Y) âŸ¶ F.obj X âŠ— F.obj Y\n  Î´'_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      Î´' X X' â‰« F.map f â–· F.obj X' = F.map (f â–· X') â‰« Î´' Y X' := by\n    aesop_cat\n  Î´'_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      Î´' X' X â‰« F.obj X' â— F.map f = F.map (X' â— f) â‰« Î´' X' Y := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  oplax_associativity' :\n    âˆ€ X Y Z : C,\n      Î´' (X âŠ— Y) Z â‰« Î´' X Y â–· F.obj Z â‰« (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n        F.map (Î±_ X Y Z).hom â‰« Î´' X (Y âŠ— Z) â‰« F.obj X â— Î´' Y Z := by\n    aesop_cat\n  -- unitality\n  oplax_left_unitality' :\n    âˆ€ X : C, (Î»_ (F.obj X)).inv = F.map (Î»_ X).inv â‰« Î´' (ğŸ™_ C) X â‰« Î·' â–· F.obj X := by\n      aesop_cat\n  oplax_right_unitality' :\n    âˆ€ X : C, (Ï_ (F.obj X)).inv = F.map (Ï_ X).inv â‰« Î´' X (ğŸ™_ C) â‰« F.obj X â— Î·' := by\n      aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.oplax_left_unitality'","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.OplaxMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´' CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.MonoidalCategoryStruct.whiskerRight CategoryTheory.Functor.OplaxMonoidal.Î·' (F.obj X))))","decl":"/-- A functor `F : C â¥¤ D` between monoidal categories is oplax monoidal if it is\nequipped with morphisms `Î· : F.obj (ğŸ™_ C) âŸ¶ ğŸ™ _D` and `Î´ X Y : F.obj (X âŠ— Y) âŸ¶ F.obj X âŠ— F.obj Y`,\nsatisfying the appropriate coherences. -/\nclass OplaxMonoidal where\n  /-- counit morphism -/\n  Î·' : F.obj (ğŸ™_ C) âŸ¶ ğŸ™_ D\n  /-- cotensorator -/\n  Î´' : âˆ€ X Y : C, F.obj (X âŠ— Y) âŸ¶ F.obj X âŠ— F.obj Y\n  Î´'_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      Î´' X X' â‰« F.map f â–· F.obj X' = F.map (f â–· X') â‰« Î´' Y X' := by\n    aesop_cat\n  Î´'_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      Î´' X' X â‰« F.obj X' â— F.map f = F.map (X' â— f) â‰« Î´' X' Y := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  oplax_associativity' :\n    âˆ€ X Y Z : C,\n      Î´' (X âŠ— Y) Z â‰« Î´' X Y â–· F.obj Z â‰« (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n        F.map (Î±_ X Y Z).hom â‰« Î´' X (Y âŠ— Z) â‰« F.obj X â— Î´' Y Z := by\n    aesop_cat\n  -- unitality\n  oplax_left_unitality' :\n    âˆ€ X : C, (Î»_ (F.obj X)).inv = F.map (Î»_ X).inv â‰« Î´' (ğŸ™_ C) X â‰« Î·' â–· F.obj X := by\n      aesop_cat\n  oplax_right_unitality' :\n    âˆ€ X : C, (Ï_ (F.obj X)).inv = F.map (Ï_ X).inv â‰« Î´' X (ğŸ™_ C) â‰« F.obj X â— Î·' := by\n      aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.oplax_associativity'","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.OplaxMonoidal\nX Y Z : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´' (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î´' X Y) (F.obj Z)) (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´' X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.Î´' Y Z))))","decl":"/-- A functor `F : C â¥¤ D` between monoidal categories is oplax monoidal if it is\nequipped with morphisms `Î· : F.obj (ğŸ™_ C) âŸ¶ ğŸ™ _D` and `Î´ X Y : F.obj (X âŠ— Y) âŸ¶ F.obj X âŠ— F.obj Y`,\nsatisfying the appropriate coherences. -/\nclass OplaxMonoidal where\n  /-- counit morphism -/\n  Î·' : F.obj (ğŸ™_ C) âŸ¶ ğŸ™_ D\n  /-- cotensorator -/\n  Î´' : âˆ€ X Y : C, F.obj (X âŠ— Y) âŸ¶ F.obj X âŠ— F.obj Y\n  Î´'_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      Î´' X X' â‰« F.map f â–· F.obj X' = F.map (f â–· X') â‰« Î´' Y X' := by\n    aesop_cat\n  Î´'_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      Î´' X' X â‰« F.obj X' â— F.map f = F.map (X' â— f) â‰« Î´' X' Y := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  oplax_associativity' :\n    âˆ€ X Y Z : C,\n      Î´' (X âŠ— Y) Z â‰« Î´' X Y â–· F.obj Z â‰« (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n        F.map (Î±_ X Y Z).hom â‰« Î´' X (Y âŠ— Z) â‰« F.obj X â— Î´' Y Z := by\n    aesop_cat\n  -- unitality\n  oplax_left_unitality' :\n    âˆ€ X : C, (Î»_ (F.obj X)).inv = F.map (Î»_ X).inv â‰« Î´' (ğŸ™_ C) X â‰« Î·' â–· F.obj X := by\n      aesop_cat\n  oplax_right_unitality' :\n    âˆ€ X : C, (Ï_ (F.obj X)).inv = F.map (Ï_ X).inv â‰« Î´' X (ğŸ™_ C) â‰« F.obj X â— Î·' := by\n      aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.Î´_natural_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj Y) (F.obj X')) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X X') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F Y X') h))","decl":"@[reassoc (attr := simp)]\nlemma Î´_natural_left {X Y : C} (f : X âŸ¶ Y) (X' : C) :\n    Î´ F X X' â‰« F.map f â–· F.obj X' = F.map (f â–· X') â‰« Î´ F Y X' := by\n  apply Î´'_natural_left\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.Î´_natural_left","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X X') (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X'))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')) (CategoryTheory.Functor.OplaxMonoidal.Î´ F Y X'))","decl":"@[reassoc (attr := simp)]\nlemma Î´_natural_left {X Y : C} (f : X âŸ¶ Y) (X' : C) :\n    Î´ F X X' â‰« F.map f â–· F.obj X' = F.map (f â–· X') â‰« Î´ F Y X' := by\n  apply Î´'_natural_left\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.Î´_natural_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X') (F.obj Y)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X' X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X' Y) h))","decl":"@[reassoc (attr := simp)]\nlemma Î´_natural_right {X Y : C} (X' : C) (f : X âŸ¶ Y) :\n    Î´ F X' X â‰« F.obj X' â— F.map f = F.map (X' â— f) â‰« Î´ F X' Y := by\n  apply Î´'_natural_right\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.Î´_natural_right","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X' X) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)) (CategoryTheory.Functor.OplaxMonoidal.Î´ F X' Y))","decl":"@[reassoc (attr := simp)]\nlemma Î´_natural_right {X Y : C} (X' : C) (f : X âŸ¶ Y) :\n    Î´ F X' X â‰« F.obj X' â— F.map f = F.map (X' â— f) â‰« Î´ F X' Y := by\n  apply Î´'_natural_right\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.associativity","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX Y Z : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) (F.obj Z)) (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.Î´ F Y Z))))","decl":"@[reassoc (attr := simp)]\nlemma associativity (X Y Z : C) :\n    Î´ F (X âŠ— Y) Z â‰« Î´ F X Y â–· F.obj Z â‰« (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n      F.map (Î±_ X Y Z).hom â‰« Î´ F X (Y âŠ— Z) â‰« F.obj X â— Î´ F Y Z := by\n  apply oplax_associativity'\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.associativity_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX Y Zâœ : C\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj Y) (F.obj Zâœ))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Zâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) (F.obj Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Zâœ)).hom h))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Zâœ).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.Î´ F Y Zâœ)) h)))","decl":"@[reassoc (attr := simp)]\nlemma associativity (X Y Z : C) :\n    Î´ F (X âŠ— Y) Z â‰« Î´ F X Y â–· F.obj Z â‰« (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom =\n      F.map (Î±_ X Y Z).hom â‰« Î´ F X (Y âŠ— Z) â‰« F.obj X â— Î´ F Y Z := by\n  apply oplax_associativity'\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.left_unitality","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î· F) (F.obj X))))","decl":"@[simp, reassoc]\nlemma left_unitality (X : C) :\n    (Î»_ (F.obj X)).inv = F.map (Î»_ X).inv â‰« Î´ F (ğŸ™_ C) X â‰« Î· F â–· F.obj X := by\n  apply oplax_left_unitality'\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.left_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj X)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv h) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î· F) (F.obj X)) h)))","decl":"@[simp, reassoc]\nlemma left_unitality (X : C) :\n    (Î»_ (F.obj X)).inv = F.map (Î»_ X).inv â‰« Î´ F (ğŸ™_ C) X â‰« Î· F â–· F.obj X := by\n  apply oplax_left_unitality'\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.right_unitality","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.Î· F))))","decl":"@[simp, reassoc]\nlemma right_unitality (X : C) :\n    (Ï_ (F.obj X)).inv = F.map (Ï_ X).inv â‰« Î´ F X (ğŸ™_ C) â‰« F.obj X â— Î· F := by\n  apply oplax_right_unitality'\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.right_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv h) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.Î· F)) h)))","decl":"@[simp, reassoc]\nlemma right_unitality (X : C) :\n    (Ï_ (F.obj X)).inv = F.map (Ï_ X).inv â‰« Î´ F X (ğŸ™_ C) â‰« F.obj X â— Î· F := by\n  apply oplax_right_unitality'\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.Î´_natural","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X X') (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.Functor.OplaxMonoidal.Î´ F Y Y'))","decl":"@[reassoc (attr := simp)]\ntheorem Î´_natural {X Y X' Y' : C} (f : X âŸ¶ Y) (g : X' âŸ¶ Y') :\n    Î´ F X X' â‰« (F.map f âŠ— F.map g) = F.map (f âŠ— g) â‰« Î´ F Y Y' := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.Î´_natural_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj Y) (F.obj Y')) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X X') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F Y Y') h))","decl":"@[reassoc (attr := simp)]\ntheorem Î´_natural {X Y X' Y' : C} (f : X âŸ¶ Y) (g : X' âŸ¶ Y') :\n    Î´ F X X' â‰« (F.map f âŠ— F.map g) = F.map (f âŠ— g) â‰« Î´ F Y Y' := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.left_unitality_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î· F) (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom h))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) h)","decl":"@[reassoc (attr := simp)]\ntheorem left_unitality_hom  (X : C) :\n    Î´ F (ğŸ™_ C) X â‰« Î· F â–· F.obj X â‰« (Î»_ (F.obj X)).hom = F.map (Î»_ X).hom := by\n  rw [â† Category.assoc, â† Iso.eq_comp_inv, left_unitality, â† Category.assoc,\n    â† F.map_comp, Iso.hom_inv_id, F.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.left_unitality_hom","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î· F) (F.obj X)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom)) (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)","decl":"@[reassoc (attr := simp)]\ntheorem left_unitality_hom  (X : C) :\n    Î´ F (ğŸ™_ C) X â‰« Î· F â–· F.obj X â‰« (Î»_ (F.obj X)).hom = F.map (Î»_ X).hom := by\n  rw [â† Category.assoc, â† Iso.eq_comp_inv, left_unitality, â† Category.assoc,\n    â† F.map_comp, Iso.hom_inv_id, F.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.right_unitality_hom","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.Î· F)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom)) (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)","decl":"@[reassoc (attr := simp)]\ntheorem right_unitality_hom (X : C) :\n    Î´ F X (ğŸ™_ C) â‰« F.obj X â— Î· F â‰« (Ï_ (F.obj X)).hom = F.map (Ï_ X).hom := by\n  rw [â† Category.assoc, â† Iso.eq_comp_inv, right_unitality, â† Category.assoc,\n    â† F.map_comp, Iso.hom_inv_id, F.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.right_unitality_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.Î· F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom h))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) h)","decl":"@[reassoc (attr := simp)]\ntheorem right_unitality_hom (X : C) :\n    Î´ F X (ğŸ™_ C) â‰« F.obj X â— Î· F â‰« (Ï_ (F.obj X)).hom = F.map (Ï_ X).hom := by\n  rw [â† Category.assoc, â† Iso.eq_comp_inv, right_unitality, â† Category.assoc,\n    â† F.map_comp, Iso.hom_inv_id, F.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.associativity_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX Y Z : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.Î´ F Y Z)) (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).inv)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) (F.obj Z))))","decl":"@[reassoc (attr := simp)]\ntheorem associativity_inv (X Y Z : C) :\n    Î´ F X (Y âŠ— Z) â‰« F.obj X â— Î´ F Y Z â‰« (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).inv =\n      F.map (Î±_ X Y Z).inv â‰« Î´ F (X âŠ— Y) Z â‰« Î´ F X Y â–· F.obj Z := by\n  rw [â† Category.assoc, Iso.comp_inv_eq, Category.assoc, Category.assoc, associativity,\n    â† Category.assoc, â† F.map_comp, Iso.inv_hom_id, F.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.associativity_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.OplaxMonoidal\nX Y Zâœ : C\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj Zâœ)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.Î´ F Y Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Zâœ)).inv h))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Zâœ).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Zâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) (F.obj Zâœ)) h)))","decl":"@[reassoc (attr := simp)]\ntheorem associativity_inv (X Y Z : C) :\n    Î´ F X (Y âŠ— Z) â‰« F.obj X â— Î´ F Y Z â‰« (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).inv =\n      F.map (Î±_ X Y Z).inv â‰« Î´ F (X âŠ— Y) Z â‰« Î´ F X Y â–· F.obj Z := by\n  rw [â† Category.assoc, Iso.comp_inv_eq, Category.assoc, Category.assoc, associativity,\n    â† Category.assoc, â† F.map_comp, Iso.inv_hom_id, F.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.id_Î·","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î· (CategoryTheory.Functor.id C)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[simp]\nlemma id_Î· : Î· (ğŸ­ C) = ğŸ™ _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.id_Î´","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î´ (CategoryTheory.Functor.id C) X Y) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)))","decl":"@[simp]\nlemma id_Î´ (X Y : C) : Î´ (ğŸ­ C) X Y = ğŸ™ _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.comp_Î·","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ· : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¶ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœÂ² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ¹ : F.OplaxMonoidal\ninstâœ : G.OplaxMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î· (F.comp G)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.Î· F)) (CategoryTheory.Functor.OplaxMonoidal.Î· G))","decl":"@[simp]\nlemma comp_Î· : Î· (F â‹™ G) = G.map (Î· F) â‰« Î· G := rfl\n\n"}
{"name":"CategoryTheory.Functor.OplaxMonoidal.comp_Î´","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ· : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¶ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœÂ² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninstâœÂ¹ : F.OplaxMonoidal\ninstâœ : G.OplaxMonoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î´ (F.comp G) X Y) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y)) (CategoryTheory.Functor.OplaxMonoidal.Î´ G (F.obj X) (F.obj Y)))","decl":"@[simp]\nlemma comp_Î´ (X Y : C) : Î´ (F â‹™ G) X Y = G.map (Î´ F X Y) â‰« Î´ G _ _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.Îµ_Î·","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Îµ F) (CategoryTheory.Functor.OplaxMonoidal.Î· F)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/-- A functor between monoidal categories is monoidal if it is lax and oplax monoidals,\nand both data give inverse isomorphisms. -/\nclass Monoidal extends F.LaxMonoidal, F.OplaxMonoidal where\n  Îµ_Î· : Îµ F â‰« Î· F = ğŸ™ _ := by aesop_cat\n  Î·_Îµ : Î· F â‰« Îµ F = ğŸ™ _ := by aesop_cat\n  Î¼_Î´ (X Y : C) : Î¼ F X Y â‰« Î´ F X Y = ğŸ™ _ := by aesop_cat\n  Î´_Î¼ (X Y : C) : Î´ F X Y â‰« Î¼ F X Y = ğŸ™ _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.Î·_Îµ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î· F) (CategoryTheory.Functor.LaxMonoidal.Îµ F)) (CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"/-- A functor between monoidal categories is monoidal if it is lax and oplax monoidals,\nand both data give inverse isomorphisms. -/\nclass Monoidal extends F.LaxMonoidal, F.OplaxMonoidal where\n  Îµ_Î· : Îµ F â‰« Î· F = ğŸ™ _ := by aesop_cat\n  Î·_Îµ : Î· F â‰« Îµ F = ğŸ™ _ := by aesop_cat\n  Î¼_Î´ (X Y : C) : Î¼ F X Y â‰« Î´ F X Y = ğŸ™ _ := by aesop_cat\n  Î´_Î¼ (X Y : C) : Î´ F X Y â‰« Î¼ F X Y = ğŸ™ _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.Î´_Î¼","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y)) (CategoryTheory.CategoryStruct.id (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)))","decl":"/-- A functor between monoidal categories is monoidal if it is lax and oplax monoidals,\nand both data give inverse isomorphisms. -/\nclass Monoidal extends F.LaxMonoidal, F.OplaxMonoidal where\n  Îµ_Î· : Îµ F â‰« Î· F = ğŸ™ _ := by aesop_cat\n  Î·_Îµ : Î· F â‰« Îµ F = ğŸ™ _ := by aesop_cat\n  Î¼_Î´ (X Y : C) : Î¼ F X Y â‰« Î´ F X Y = ğŸ™ _ := by aesop_cat\n  Î´_Î¼ (X Y : C) : Î´ F X Y â‰« Î¼ F X Y = ğŸ™ _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.Î¼_Î´","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)))","decl":"/-- A functor between monoidal categories is monoidal if it is lax and oplax monoidals,\nand both data give inverse isomorphisms. -/\nclass Monoidal extends F.LaxMonoidal, F.OplaxMonoidal where\n  Îµ_Î· : Îµ F â‰« Î· F = ğŸ™ _ := by aesop_cat\n  Î·_Îµ : Î· F â‰« Îµ F = ğŸ™ _ := by aesop_cat\n  Î¼_Î´ (X Y : C) : Î¼ F X Y â‰« Î´ F X Y = ğŸ™ _ := by aesop_cat\n  Î´_Î¼ (X Y : C) : Î´ F X Y â‰« Î¼ F X Y = ğŸ™ _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.Î¼_Î´_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nX Y : C\nZ : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) h)) h","decl":"attribute [reassoc (attr := simp)] Îµ_Î· Î·_Îµ Î¼_Î´ Î´_Î¼\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.Îµ_Î·_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nZ : D\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Îµ F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î· F) h)) h","decl":"attribute [reassoc (attr := simp)] Îµ_Î· Î·_Îµ Î¼_Î´ Î´_Î¼\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.Î´_Î¼_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nX Y : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) h)) h","decl":"attribute [reassoc (attr := simp)] Îµ_Î· Î·_Îµ Î¼_Î´ Î´_Î¼\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.Î·_Îµ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.Monoidal\nZ : D\nh : Quiver.Hom (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î· F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Îµ F) h)) h","decl":"attribute [reassoc (attr := simp)] Îµ_Î· Î·_Îµ Î¼_Î´ Î´_Î¼\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.ÎµIso_hom","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nâŠ¢ Eq (CategoryTheory.Functor.Monoidal.ÎµIso F).hom (CategoryTheory.Functor.LaxMonoidal.Îµ F)","decl":"/-- The isomorphism `ğŸ™_ D â‰… F.obj (ğŸ™_ C)` when `F` is a monoidal functor. -/\n@[simps]\ndef ÎµIso : ğŸ™_ D â‰… F.obj (ğŸ™_ C) where\n  hom := Îµ F\n  inv := Î· F\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.ÎµIso_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nâŠ¢ Eq (CategoryTheory.Functor.Monoidal.ÎµIso F).inv (CategoryTheory.Functor.OplaxMonoidal.Î· F)","decl":"/-- The isomorphism `ğŸ™_ D â‰… F.obj (ğŸ™_ C)` when `F` is a monoidal functor. -/\n@[simps]\ndef ÎµIso : ğŸ™_ D â‰… F.obj (ğŸ™_ C) where\n  hom := Îµ F\n  inv := Î· F\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.Î¼Iso_hom","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.Monoidal.Î¼Iso F X Y).hom (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y)","decl":"/-- The isomorphism `F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)` when `F` is a monoidal functor. -/\n@[simps]\ndef Î¼Iso (X Y : C) : F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y) where\n  hom := Î¼ F X Y\n  inv := Î´ F X Y\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.Î¼Iso_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.Monoidal.Î¼Iso F X Y).inv (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y)","decl":"/-- The isomorphism `F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)` when `F` is a monoidal functor. -/\n@[simps]\ndef Î¼Iso (X Y : C) : F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y) where\n  hom := Î¼ F X Y\n  inv := Î´ F X Y\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.instIsIsoÎµ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Functor.LaxMonoidal.Îµ F)","decl":"instance : IsIso (Îµ F) := (ÎµIso F).isIso_hom\n"}
{"name":"CategoryTheory.Functor.Monoidal.instIsIsoÎ·","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Functor.OplaxMonoidal.Î· F)","decl":"instance : IsIso (Î· F) := (ÎµIso F).isIso_inv\n"}
{"name":"CategoryTheory.Functor.Monoidal.instIsIsoÎ¼","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y)","decl":"instance (X Y : C) : IsIso (Î¼ F X Y) := (Î¼Iso F X Y).isIso_hom\n"}
{"name":"CategoryTheory.Functor.Monoidal.instIsIsoÎ´","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y)","decl":"instance (X Y : C) : IsIso (Î´ F X Y) := (Î¼Iso F X Y).isIso_inv\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_Îµ_Î·","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ´ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ² : CategoryTheory.MonoidalCategory D\nC' : Type uâ‚'\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nG : CategoryTheory.Functor D C'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.LaxMonoidal.Îµ F)) (G.map (CategoryTheory.Functor.OplaxMonoidal.Î· F))) (CategoryTheory.CategoryStruct.id (G.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[reassoc (attr := simp)]\nlemma map_Îµ_Î· (G : D â¥¤ C') : G.map (Îµ F) â‰« G.map (Î· F) = ğŸ™ _ :=\n  (ÎµIso F).map_hom_inv_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_Îµ_Î·_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ´ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ² : CategoryTheory.MonoidalCategory D\nC' : Type uâ‚'\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nG : CategoryTheory.Functor D C'\nZ : C'\nh : Quiver.Hom (G.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.LaxMonoidal.Îµ F)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.Î· F)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_Îµ_Î· (G : D â¥¤ C') : G.map (Îµ F) â‰« G.map (Î· F) = ğŸ™ _ :=\n  (ÎµIso F).map_hom_inv_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_Î·_Îµ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ´ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ² : CategoryTheory.MonoidalCategory D\nC' : Type uâ‚'\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nG : CategoryTheory.Functor D C'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.Î· F)) (G.map (CategoryTheory.Functor.LaxMonoidal.Îµ F))) (CategoryTheory.CategoryStruct.id (G.obj (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)))","decl":"@[reassoc (attr := simp)]\nlemma map_Î·_Îµ (G : D â¥¤ C') : G.map (Î· F) â‰« G.map (Îµ F) = ğŸ™ _ :=\n  (ÎµIso F).map_inv_hom_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_Î·_Îµ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ´ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ² : CategoryTheory.MonoidalCategory D\nC' : Type uâ‚'\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nG : CategoryTheory.Functor D C'\nZ : C'\nh : Quiver.Hom (G.obj (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.Î· F)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.LaxMonoidal.Îµ F)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_Î·_Îµ (G : D â¥¤ C') : G.map (Î· F) â‰« G.map (Îµ F) = ğŸ™ _ :=\n  (ÎµIso F).map_inv_hom_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_Î¼_Î´","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ´ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ² : CategoryTheory.MonoidalCategory D\nC' : Type uâ‚'\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nG : CategoryTheory.Functor D C'\nX Y : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y)) (G.map (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y))) (CategoryTheory.CategoryStruct.id (G.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y))))","decl":"@[reassoc (attr := simp)]\nlemma map_Î¼_Î´ (G : D â¥¤ C') (X Y : C) : G.map (Î¼ F X Y) â‰« G.map (Î´ F X Y) = ğŸ™ _ :=\n  (Î¼Iso F X Y).map_hom_inv_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_Î¼_Î´_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ´ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ² : CategoryTheory.MonoidalCategory D\nC' : Type uâ‚'\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nG : CategoryTheory.Functor D C'\nX Y : C\nZ : C'\nh : Quiver.Hom (G.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_Î¼_Î´ (G : D â¥¤ C') (X Y : C) : G.map (Î¼ F X Y) â‰« G.map (Î´ F X Y) = ğŸ™ _ :=\n  (Î¼Iso F X Y).map_hom_inv_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_Î´_Î¼_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ´ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ² : CategoryTheory.MonoidalCategory D\nC' : Type uâ‚'\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nG : CategoryTheory.Functor D C'\nX Y : C\nZ : C'\nh : Quiver.Hom (G.obj (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_Î´_Î¼ (G : D â¥¤ C') (X Y : C) : G.map (Î´ F X Y) â‰« G.map (Î¼ F X Y) = ğŸ™ _ :=\n  (Î¼Iso F X Y).map_inv_hom_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_Î´_Î¼","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ´ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ² : CategoryTheory.MonoidalCategory D\nC' : Type uâ‚'\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nG : CategoryTheory.Functor D C'\nX Y : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y)) (G.map (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y))) (CategoryTheory.CategoryStruct.id (G.obj (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))))","decl":"@[reassoc (attr := simp)]\nlemma map_Î´_Î¼ (G : D â¥¤ C') (X Y : C) : G.map (Î´ F X Y) â‰« G.map (Î¼ F X Y) = ğŸ™ _ :=\n  (Î¼Iso F X Y).map_inv_hom_id G\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_Îµ_Î·_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit T) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Îµ F) T) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î· F) T) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_Îµ_Î· (T : D) : Îµ F â–· T â‰« Î· F â–· T = ğŸ™ _ := by\n  rw [â† MonoidalCategory.comp_whiskerRight, Îµ_Î·, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_Îµ_Î·","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nT : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Îµ F) T) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î· F) T)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit T))","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_Îµ_Î· (T : D) : Îµ F â–· T â‰« Î· F â–· T = ğŸ™ _ := by\n  rw [â† MonoidalCategory.comp_whiskerRight, Îµ_Î·, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_Î·_Îµ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) T) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î· F) T) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Îµ F) T) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_Î·_Îµ (T : D) : Î· F â–· T â‰« Îµ F â–· T = ğŸ™ _ := by\n  rw [â† MonoidalCategory.comp_whiskerRight, Î·_Îµ, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_Î·_Îµ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nT : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î· F) T) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Îµ F) T)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) T))","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_Î·_Îµ (T : D) : Î· F â–· T â‰« Îµ F â–· T = ğŸ™ _ := by\n  rw [â† MonoidalCategory.comp_whiskerRight, Î·_Îµ, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_Î¼_Î´","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nT : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) T) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) T)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) T))","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_Î¼_Î´ (X Y : C) (T : D) : Î¼ F X Y â–· T â‰« Î´ F X Y â–· T = ğŸ™ _ := by\n  rw [â† MonoidalCategory.comp_whiskerRight, Î¼_Î´, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_Î¼_Î´_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) T) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) T) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) T) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_Î¼_Î´ (X Y : C) (T : D) : Î¼ F X Y â–· T â‰« Î´ F X Y â–· T = ğŸ™ _ := by\n  rw [â† MonoidalCategory.comp_whiskerRight, Î¼_Î´, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_Î´_Î¼","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nT : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) T) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) T)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) T))","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_Î´_Î¼ (X Y : C) (T : D) : Î´ F X Y â–· T â‰« Î¼ F X Y â–· T = ğŸ™ _ := by\n  rw [â† MonoidalCategory.comp_whiskerRight, Î´_Î¼, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_Î´_Î¼_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) T) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) T) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) T) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_Î´_Î¼ (X Y : C) (T : D) : Î´ F X Y â–· T â‰« Î¼ F X Y â–· T = ğŸ™ _ := by\n  rw [â† MonoidalCategory.comp_whiskerRight, Î´_Î¼, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_Îµ_Î·_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj T CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.Îµ F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.Î· F)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_Îµ_Î· (T : D) : T â— Îµ F â‰« T â— Î· F = ğŸ™ _ := by\n  rw [â† MonoidalCategory.whiskerLeft_comp, Îµ_Î·, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_Îµ_Î·","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nT : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.Îµ F)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.Î· F))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj T CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_Îµ_Î· (T : D) : T â— Îµ F â‰« T â— Î· F = ğŸ™ _ := by\n  rw [â† MonoidalCategory.whiskerLeft_comp, Îµ_Î·, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_Î·_Îµ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nT : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.Î· F)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.Îµ F))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj T (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)))","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_Î·_Îµ (T : D) : T â— Î· F â‰« T â— Îµ F = ğŸ™ _ := by\n  rw [â† MonoidalCategory.whiskerLeft_comp, Î·_Îµ, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_Î·_Îµ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj T (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.Î· F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.Îµ F)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_Î·_Îµ (T : D) : T â— Î· F â‰« T â— Îµ F = ğŸ™ _ := by\n  rw [â† MonoidalCategory.whiskerLeft_comp, Î·_Îµ, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_Î¼_Î´_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj T (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_Î¼_Î´ (X Y : C) (T : D) : T â— Î¼ F X Y â‰« T â— Î´ F X Y = ğŸ™ _ := by\n  rw [â† MonoidalCategory.whiskerLeft_comp, Î¼_Î´, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_Î¼_Î´","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nT : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj T (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y))))","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_Î¼_Î´ (X Y : C) (T : D) : T â— Î¼ F X Y â‰« T â— Î´ F X Y = ğŸ™ _ := by\n  rw [â† MonoidalCategory.whiskerLeft_comp, Î¼_Î´, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_Î´_Î¼_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nT Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj T (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_Î´_Î¼ (X Y : C) (T : D) : T â— Î´ F X Y â‰« T â— Î¼ F X Y = ğŸ™ _ := by\n  rw [â† MonoidalCategory.whiskerLeft_comp, Î´_Î¼, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_Î´_Î¼","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nT : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft T (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj T (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))))","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_Î´_Î¼ (X Y : C) (T : D) : T â— Î´ F X Y â‰« T â— Î¼ F X Y = ğŸ™ _ := by\n  rw [â† MonoidalCategory.whiskerLeft_comp, Î´_Î¼, MonoidalCategory.whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_tensor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X X') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y Y')))","decl":"@[reassoc]\ntheorem map_tensor {X Y X' Y' : C} (f : X âŸ¶ Y) (g : X' âŸ¶ Y') :\n    F.map (f âŠ— g) = Î´ F X X' â‰« (F.map f âŠ— F.map g) â‰« Î¼ F Y Y' := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_tensor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Y')) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X X') (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (F.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y Y') h)))","decl":"@[reassoc]\ntheorem map_tensor {X Y X' Y' : C} (f : X âŸ¶ Y) (g : X' âŸ¶ Y') :\n    F.map (f âŠ— g) = Î´ F X X' â‰« (F.map f âŠ— F.map g) â‰« Î¼ F Y Y' := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_whiskerLeft_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y Zâœ : C\nf : Quiver.Hom Y Zâœ\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Zâœ)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Zâœ) h)))","decl":"@[reassoc]\ntheorem map_whiskerLeft (X : C) {Y Z : C} (f : Y âŸ¶ Z) :\n    F.map (X â— f) = Î´ F X Y â‰« F.obj X â— F.map f â‰« Î¼ F X Z := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y Z : C\nf : Quiver.Hom Y Z\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (F.map f)) (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Z)))","decl":"@[reassoc]\ntheorem map_whiskerLeft (X : C) {Y Z : C} (f : Y âŸ¶ Z) :\n    F.map (X â— f) = Î´ F X Y â‰« F.obj X â— F.map f â‰« Î¼ F X Z := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_whiskerRight_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nf : Quiver.Hom X Y\nZâœ : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Zâœ)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Zâœ)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Zâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y Zâœ) h)))","decl":"@[reassoc]\ntheorem map_whiskerRight {X Y : C} (f : X âŸ¶ Y) (Z : C) :\n    F.map (f â–· Z) = Î´ F X Z â‰« F.map f â–· F.obj Z â‰« Î¼ F Y Z := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj Z)) (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y Z)))","decl":"@[reassoc]\ntheorem map_whiskerRight {X Y : C} (f : X âŸ¶ Y) (Z : C) :\n    F.map (f â–· Z) = Î´ F X Z â‰« F.map f â–· F.obj Z â‰« Î¼ F Y Z := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_associator","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y Z : C\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) (F.obj Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y Z)) (CategoryTheory.Functor.LaxMonoidal.Î¼ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))))))","decl":"@[reassoc]\ntheorem map_associator (X Y Z : C) :\n    F.map (Î±_ X Y Z).hom =\n      Î´ F (X âŠ— Y) Z â‰« Î´ F X Y â–· F.obj Z â‰«\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— Î¼ F Y Z â‰« Î¼ F X (Y âŠ— Z) := by\n  rw [â† LaxMonoidal.associativity F, whiskerRight_Î´_Î¼_assoc, Î´_Î¼_assoc]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_associator_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y Zâœ : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Zâœ))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Zâœ).hom) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Zâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) (F.obj Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Zâœ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.Î¼ F Y Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Zâœ)) h)))))","decl":"@[reassoc]\ntheorem map_associator (X Y Z : C) :\n    F.map (Î±_ X Y Z).hom =\n      Î´ F (X âŠ— Y) Z â‰« Î´ F X Y â–· F.obj Z â‰«\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— Î¼ F Y Z â‰« Î¼ F X (Y âŠ— Z) := by\n  rw [â† LaxMonoidal.associativity F, whiskerRight_Î´_Î¼_assoc, Î´_Î¼_assoc]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_associator_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y Zâœ : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Zâœ)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Zâœ).inv) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.Î´ F Y Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Zâœ)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) (F.obj Zâœ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Zâœ) h)))))","decl":"@[reassoc]\ntheorem map_associator_inv (X Y Z : C) :\n    F.map (Î±_ X Y Z).inv =\n      Î´ F X (Y âŠ— Z) â‰« F.obj X â— Î´ F Y Z â‰«\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).inv â‰« Î¼ F X Y â–· F.obj Z â‰« Î¼ F (X âŠ— Y) Z := by\n  rw [â† cancel_epi (F.map (Î±_ X Y Z).hom), Iso.map_hom_inv_id, map_associator,\n    assoc, assoc, assoc, assoc, OplaxMonoidal.associativity_inv_assoc,\n    whiskerRight_Î´_Î¼_assoc, Î´_Î¼, comp_id, LaxMonoidal.associativity_inv,\n    Iso.hom_inv_id_assoc, whiskerRight_Î´_Î¼_assoc, Î´_Î¼]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_associator_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX Y Z : C\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.Î´ F Y Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) (F.obj Z)) (CategoryTheory.Functor.LaxMonoidal.Î¼ F (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z)))))","decl":"@[reassoc]\ntheorem map_associator_inv (X Y Z : C) :\n    F.map (Î±_ X Y Z).inv =\n      Î´ F X (Y âŠ— Z) â‰« F.obj X â— Î´ F Y Z â‰«\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).inv â‰« Î¼ F X Y â–· F.obj Z â‰« Î¼ F (X âŠ— Y) Z := by\n  rw [â† cancel_epi (F.map (Î±_ X Y Z).hom), Iso.map_hom_inv_id, map_associator,\n    assoc, assoc, assoc, assoc, OplaxMonoidal.associativity_inv_assoc,\n    whiskerRight_Î´_Î¼_assoc, Î´_Î¼, comp_id, LaxMonoidal.associativity_inv,\n    Iso.hom_inv_id_assoc, whiskerRight_Î´_Î¼_assoc, Î´_Î¼]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_leftUnitor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î· F) (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom h)))","decl":"@[reassoc]\ntheorem map_leftUnitor (X : C) :\n    F.map (Î»_ X).hom = Î´ F (ğŸ™_ C) X â‰« Î· F â–· F.obj X â‰« (Î»_ (F.obj X)).hom := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_leftUnitor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX : C\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.OplaxMonoidal.Î· F) (F.obj X)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom))","decl":"@[reassoc]\ntheorem map_leftUnitor (X : C) :\n    F.map (Î»_ X).hom = Î´ F (ğŸ™_ C) X â‰« Î· F â–· F.obj X â‰« (Î»_ (F.obj X)).hom := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_leftUnitor_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX : C\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Îµ F) (F.obj X)) (CategoryTheory.Functor.LaxMonoidal.Î¼ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X)))","decl":"@[reassoc]\ntheorem map_leftUnitor_inv (X : C) :\n    F.map (Î»_ X).inv = (Î»_ (F.obj X)).inv â‰« Îµ F â–· F.obj X â‰« Î¼ F (ğŸ™_ C) X  := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_leftUnitor_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit X)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Functor.LaxMonoidal.Îµ F) (F.obj X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F CategoryTheory.MonoidalCategoryStruct.tensorUnit X) h)))","decl":"@[reassoc]\ntheorem map_leftUnitor_inv (X : C) :\n    F.map (Î»_ X).inv = (Î»_ (F.obj X)).inv â‰« Îµ F â–· F.obj X â‰« Î¼ F (ğŸ™_ C) X  := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX : C\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.Î· F)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom))","decl":"@[reassoc]\ntheorem map_rightUnitor (X : C) :\n    F.map (Ï_ X).hom = Î´ F X (ğŸ™_ C) â‰« F.obj X â— Î· F â‰« (Ï_ (F.obj X)).hom := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_rightUnitor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.OplaxMonoidal.Î· F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom h)))","decl":"@[reassoc]\ntheorem map_rightUnitor (X : C) :\n    F.map (Ï_ X).hom = Î´ F X (ğŸ™_ C) â‰« F.obj X â— Î· F â‰« (Ï_ (F.obj X)).hom := by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_rightUnitor_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X CategoryTheory.MonoidalCategoryStruct.tensorUnit)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.Îµ F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit) h)))","decl":"@[reassoc]\ntheorem map_rightUnitor_inv (X : C) :\n    F.map (Ï_ X).inv = (Ï_ (F.obj X)).inv â‰« F.obj X â— Îµ F  â‰« Î¼ F X (ğŸ™_ C):= by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.map_rightUnitor_inv","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX : C\nâŠ¢ Eq (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (CategoryTheory.Functor.LaxMonoidal.Îµ F)) (CategoryTheory.Functor.LaxMonoidal.Î¼ F X CategoryTheory.MonoidalCategoryStruct.tensorUnit)))","decl":"@[reassoc]\ntheorem map_rightUnitor_inv (X : C) :\n    F.map (Ï_ X).inv = (Ï_ (F.obj X)).inv â‰« F.obj X â— Îµ F  â‰« Î¼ F X (ğŸ™_ C):= by simp\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.Î¼NatIso_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX : Prod C C\nâŠ¢ Eq ((CategoryTheory.Functor.Monoidal.Î¼NatIso F).inv.app X) (CategoryTheory.Functor.OplaxMonoidal.Î´ F X.1 X.2)","decl":"/-- The tensorator as a natural isomorphism. -/\n@[simps!]\nnoncomputable def Î¼NatIso :\n    Functor.prod F F â‹™ tensor D â‰… tensor C â‹™ F :=\n  NatIso.ofComponents (fun _ â†¦ Î¼Iso F _ _)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.Î¼NatIso_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nX : Prod C C\nâŠ¢ Eq ((CategoryTheory.Functor.Monoidal.Î¼NatIso F).hom.app X) (CategoryTheory.Functor.LaxMonoidal.Î¼ F X.1 X.2)","decl":"/-- The tensorator as a natural isomorphism. -/\n@[simps!]\nnoncomputable def Î¼NatIso :\n    Functor.prod F F â‹™ tensor D â‰… tensor C â‹™ F :=\n  NatIso.ofComponents (fun _ â†¦ Î¼Iso F _ _)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.commTensorLeft_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nXâœ X : C\nâŠ¢ Eq ((CategoryTheory.Functor.Monoidal.commTensorLeft F Xâœ).inv.app X) (CategoryTheory.Functor.OplaxMonoidal.Î´ F Xâœ X)","decl":"/-- Monoidal functors commute with left tensoring up to isomorphism -/\n@[simps!]\nnoncomputable def commTensorLeft (X : C) :\n    F â‹™ tensorLeft (F.obj X) â‰… tensorLeft X â‹™ F :=\n  NatIso.ofComponents (fun Y => Î¼Iso F X Y)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.commTensorLeft_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nXâœ X : C\nâŠ¢ Eq ((CategoryTheory.Functor.Monoidal.commTensorLeft F Xâœ).hom.app X) (CategoryTheory.Functor.LaxMonoidal.Î¼ F Xâœ X)","decl":"/-- Monoidal functors commute with left tensoring up to isomorphism -/\n@[simps!]\nnoncomputable def commTensorLeft (X : C) :\n    F â‹™ tensorLeft (F.obj X) â‰… tensorLeft X â‹™ F :=\n  NatIso.ofComponents (fun Y => Î¼Iso F X Y)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.commTensorRight_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nXâœ X : C\nâŠ¢ Eq ((CategoryTheory.Functor.Monoidal.commTensorRight F Xâœ).inv.app X) (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Xâœ)","decl":"/-- Monoidal functors commute with right tensoring up to isomorphism -/\n@[simps!]\nnoncomputable def commTensorRight (X : C) :\n    F â‹™ tensorRight (F.obj X) â‰… tensorRight X â‹™ F :=\n  NatIso.ofComponents (fun Y => Î¼Iso F Y X)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.commTensorRight_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.Monoidal\nXâœ X : C\nâŠ¢ Eq ((CategoryTheory.Functor.Monoidal.commTensorRight F Xâœ).hom.app X) (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Xâœ)","decl":"/-- Monoidal functors commute with right tensoring up to isomorphism -/\n@[simps!]\nnoncomputable def commTensorRight (X : C) :\n    F â‹™ tensorRight (F.obj X) â‰… tensorRight X â‹™ F :=\n  NatIso.ofComponents (fun Y => Î¼Iso F Y X)\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.left_unitality","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.ÎµIso.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `ÎµIso` and `Î¼Iso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  ÎµIso : ğŸ™_ D â‰… F.obj (ğŸ™_ C)\n  /-- tensorator -/\n  Î¼Iso : âˆ€ X Y : C, F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  Î¼Iso_hom_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      F.map f â–· F.obj X' â‰« (Î¼Iso Y X').hom = (Î¼Iso X X').hom â‰« F.map (f â–· X') := by\n    aesop_cat\n  Î¼Iso_hom_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      F.obj X' â— F.map f â‰« (Î¼Iso X' Y).hom = (Î¼Iso X' X).hom â‰« F.map (X' â— f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    âˆ€ X Y Z : C,\n      (Î¼Iso X Y).hom â–· F.obj Z â‰« (Î¼Iso (X âŠ— Y) Z).hom â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— (Î¼Iso Y Z).hom â‰«\n          (Î¼Iso X (Y âŠ— Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    âˆ€ X : C, (Î»_ (F.obj X)).hom = ÎµIso.hom â–· F.obj X â‰« (Î¼Iso (ğŸ™_ C) X).hom â‰« F.map (Î»_ X).hom := by\n      aesop_cat\n  right_unitality :\n    âˆ€ X : C, (Ï_ (F.obj X)).hom = F.obj X â— ÎµIso.hom â‰« (Î¼Iso X (ğŸ™_ C)).hom â‰« F.map (Ï_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.associativity","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX Y Z : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (self.Î¼Iso X Y).hom (F.obj Z)) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (self.Î¼Iso Y Z).hom) (self.Î¼Iso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `ÎµIso` and `Î¼Iso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  ÎµIso : ğŸ™_ D â‰… F.obj (ğŸ™_ C)\n  /-- tensorator -/\n  Î¼Iso : âˆ€ X Y : C, F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  Î¼Iso_hom_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      F.map f â–· F.obj X' â‰« (Î¼Iso Y X').hom = (Î¼Iso X X').hom â‰« F.map (f â–· X') := by\n    aesop_cat\n  Î¼Iso_hom_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      F.obj X' â— F.map f â‰« (Î¼Iso X' Y).hom = (Î¼Iso X' X).hom â‰« F.map (X' â— f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    âˆ€ X Y Z : C,\n      (Î¼Iso X Y).hom â–· F.obj Z â‰« (Î¼Iso (X âŠ— Y) Z).hom â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— (Î¼Iso Y Z).hom â‰«\n          (Î¼Iso X (Y âŠ— Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    âˆ€ X : C, (Î»_ (F.obj X)).hom = ÎµIso.hom â–· F.obj X â‰« (Î¼Iso (ğŸ™_ C) X).hom â‰« F.map (Î»_ X).hom := by\n      aesop_cat\n  right_unitality :\n    âˆ€ X : C, (Ï_ (F.obj X)).hom = F.obj X â— ÎµIso.hom â‰« (Î¼Iso X (ğŸ™_ C)).hom â‰« F.map (Ï_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.Î¼Iso_hom_natural_right","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (self.Î¼Iso X' Y).hom) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso X' X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `ÎµIso` and `Î¼Iso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  ÎµIso : ğŸ™_ D â‰… F.obj (ğŸ™_ C)\n  /-- tensorator -/\n  Î¼Iso : âˆ€ X Y : C, F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  Î¼Iso_hom_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      F.map f â–· F.obj X' â‰« (Î¼Iso Y X').hom = (Î¼Iso X X').hom â‰« F.map (f â–· X') := by\n    aesop_cat\n  Î¼Iso_hom_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      F.obj X' â— F.map f â‰« (Î¼Iso X' Y).hom = (Î¼Iso X' X).hom â‰« F.map (X' â— f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    âˆ€ X Y Z : C,\n      (Î¼Iso X Y).hom â–· F.obj Z â‰« (Î¼Iso (X âŠ— Y) Z).hom â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— (Î¼Iso Y Z).hom â‰«\n          (Î¼Iso X (Y âŠ— Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    âˆ€ X : C, (Î»_ (F.obj X)).hom = ÎµIso.hom â–· F.obj X â‰« (Î¼Iso (ğŸ™_ C) X).hom â‰« F.map (Î»_ X).hom := by\n      aesop_cat\n  right_unitality :\n    âˆ€ X : C, (Ï_ (F.obj X)).hom = F.obj X â— ÎµIso.hom â‰« (Î¼Iso X (ğŸ™_ C)).hom â‰« F.map (Ï_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nÎµIsoâœ : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nÎ¼Isoâœ : (X Y : C) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nÎ¼Iso_hom_natural_leftâœ : autoParam (âˆ€ {X Y : C} (f : Quiver.Hom X Y) (X' : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (Î¼Isoâœ Y X').hom) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ X X').hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))) _autoâœ\nÎ¼Iso_hom_natural_rightâœ : autoParam (âˆ€ {X Y : C} (X' : C) (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (Î¼Isoâœ X' Y).hom) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ X' X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))) _autoâœ\nassociativityâœ : autoParam (âˆ€ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Î¼Isoâœ X Y).hom (F.obj Z)) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (Î¼Isoâœ Y Z).hom) (Î¼Isoâœ X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom))) _autoâœ\nleft_unitalityâœ : autoParam (âˆ€ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight ÎµIsoâœ.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))) _autoâœ\nright_unitalityâœ : autoParam (âˆ€ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) ÎµIsoâœ.hom) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))) _autoâœ\nÎµIso : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nÎ¼Iso : (X Y : C) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nÎ¼Iso_hom_natural_left : autoParam (âˆ€ {X Y : C} (f : Quiver.Hom X Y) (X' : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (Î¼Iso Y X').hom) (CategoryTheory.CategoryStruct.comp (Î¼Iso X X').hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))) _autoâœ\nÎ¼Iso_hom_natural_right : autoParam (âˆ€ {X Y : C} (X' : C) (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (Î¼Iso X' Y).hom) (CategoryTheory.CategoryStruct.comp (Î¼Iso X' X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))) _autoâœ\nassociativity : autoParam (âˆ€ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Î¼Iso X Y).hom (F.obj Z)) (CategoryTheory.CategoryStruct.comp (Î¼Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (Î¼Iso Y Z).hom) (Î¼Iso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom))) _autoâœ\nleft_unitality : autoParam (âˆ€ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight ÎµIso.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (Î¼Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))) _autoâœ\nright_unitality : autoParam (âˆ€ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) ÎµIso.hom) (CategoryTheory.CategoryStruct.comp (Î¼Iso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))) _autoâœ\nâŠ¢ Eq (Eq { ÎµIso := ÎµIsoâœ, Î¼Iso := Î¼Isoâœ, Î¼Iso_hom_natural_left := Î¼Iso_hom_natural_leftâœ, Î¼Iso_hom_natural_right := Î¼Iso_hom_natural_rightâœ, associativity := associativityâœ, left_unitality := left_unitalityâœ, right_unitality := right_unitalityâœ } { ÎµIso := ÎµIso, Î¼Iso := Î¼Iso, Î¼Iso_hom_natural_left := Î¼Iso_hom_natural_left, Î¼Iso_hom_natural_right := Î¼Iso_hom_natural_right, associativity := associativity, left_unitality := left_unitality, right_unitality := right_unitality }) (And (Eq ÎµIsoâœ ÎµIso) (Eq Î¼Isoâœ Î¼Iso))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `ÎµIso` and `Î¼Iso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  ÎµIso : ğŸ™_ D â‰… F.obj (ğŸ™_ C)\n  /-- tensorator -/\n  Î¼Iso : âˆ€ X Y : C, F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  Î¼Iso_hom_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      F.map f â–· F.obj X' â‰« (Î¼Iso Y X').hom = (Î¼Iso X X').hom â‰« F.map (f â–· X') := by\n    aesop_cat\n  Î¼Iso_hom_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      F.obj X' â— F.map f â‰« (Î¼Iso X' Y).hom = (Î¼Iso X' X).hom â‰« F.map (X' â— f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    âˆ€ X Y Z : C,\n      (Î¼Iso X Y).hom â–· F.obj Z â‰« (Î¼Iso (X âŠ— Y) Z).hom â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— (Î¼Iso Y Z).hom â‰«\n          (Î¼Iso X (Y âŠ— Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    âˆ€ X : C, (Î»_ (F.obj X)).hom = ÎµIso.hom â–· F.obj X â‰« (Î¼Iso (ğŸ™_ C) X).hom â‰« F.map (Î»_ X).hom := by\n      aesop_cat\n  right_unitality :\n    âˆ€ X : C, (Ï_ (F.obj X)).hom = F.obj X â— ÎµIso.hom â‰« (Î¼Iso X (ğŸ™_ C)).hom â‰« F.map (Ï_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nÎµIsoâœ : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nÎ¼Isoâœ : (X Y : C) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nÎ¼Iso_hom_natural_leftâœ : autoParam (âˆ€ {X Y : C} (f : Quiver.Hom X Y) (X' : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (Î¼Isoâœ Y X').hom) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ X X').hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))) _autoâœ\nÎ¼Iso_hom_natural_rightâœ : autoParam (âˆ€ {X Y : C} (X' : C) (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (Î¼Isoâœ X' Y).hom) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ X' X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))) _autoâœ\nassociativityâœ : autoParam (âˆ€ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Î¼Isoâœ X Y).hom (F.obj Z)) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (Î¼Isoâœ Y Z).hom) (Î¼Isoâœ X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom))) _autoâœ\nleft_unitalityâœ : autoParam (âˆ€ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight ÎµIsoâœ.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))) _autoâœ\nright_unitalityâœ : autoParam (âˆ€ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) ÎµIsoâœ.hom) (CategoryTheory.CategoryStruct.comp (Î¼Isoâœ X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))) _autoâœ\nÎµIso : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nÎ¼Iso : (X Y : C) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nÎ¼Iso_hom_natural_left : autoParam (âˆ€ {X Y : C} (f : Quiver.Hom X Y) (X' : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (Î¼Iso Y X').hom) (CategoryTheory.CategoryStruct.comp (Î¼Iso X X').hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))) _autoâœ\nÎ¼Iso_hom_natural_right : autoParam (âˆ€ {X Y : C} (X' : C) (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (Î¼Iso X' Y).hom) (CategoryTheory.CategoryStruct.comp (Î¼Iso X' X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))) _autoâœ\nassociativity : autoParam (âˆ€ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Î¼Iso X Y).hom (F.obj Z)) (CategoryTheory.CategoryStruct.comp (Î¼Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (Î¼Iso Y Z).hom) (Î¼Iso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom))) _autoâœ\nleft_unitality : autoParam (âˆ€ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight ÎµIso.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (Î¼Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))) _autoâœ\nright_unitality : autoParam (âˆ€ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) ÎµIso.hom) (CategoryTheory.CategoryStruct.comp (Î¼Iso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))) _autoâœ\nxâœ : Eq { ÎµIso := ÎµIsoâœ, Î¼Iso := Î¼Isoâœ, Î¼Iso_hom_natural_left := Î¼Iso_hom_natural_leftâœ, Î¼Iso_hom_natural_right := Î¼Iso_hom_natural_rightâœ, associativity := associativityâœ, left_unitality := left_unitalityâœ, right_unitality := right_unitalityâœ } { ÎµIso := ÎµIso, Î¼Iso := Î¼Iso, Î¼Iso_hom_natural_left := Î¼Iso_hom_natural_left, Î¼Iso_hom_natural_right := Î¼Iso_hom_natural_right, associativity := associativity, left_unitality := left_unitality, right_unitality := right_unitality }\nâŠ¢ And (Eq ÎµIsoâœ ÎµIso) (Eq Î¼Isoâœ Î¼Iso)","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `ÎµIso` and `Î¼Iso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  ÎµIso : ğŸ™_ D â‰… F.obj (ğŸ™_ C)\n  /-- tensorator -/\n  Î¼Iso : âˆ€ X Y : C, F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  Î¼Iso_hom_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      F.map f â–· F.obj X' â‰« (Î¼Iso Y X').hom = (Î¼Iso X X').hom â‰« F.map (f â–· X') := by\n    aesop_cat\n  Î¼Iso_hom_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      F.obj X' â— F.map f â‰« (Î¼Iso X' Y).hom = (Î¼Iso X' X).hom â‰« F.map (X' â— f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    âˆ€ X Y Z : C,\n      (Î¼Iso X Y).hom â–· F.obj Z â‰« (Î¼Iso (X âŠ— Y) Z).hom â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— (Î¼Iso Y Z).hom â‰«\n          (Î¼Iso X (Y âŠ— Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    âˆ€ X : C, (Î»_ (F.obj X)).hom = ÎµIso.hom â–· F.obj X â‰« (Î¼Iso (ğŸ™_ C) X).hom â‰« F.map (Î»_ X).hom := by\n      aesop_cat\n  right_unitality :\n    âˆ€ X : C, (Ï_ (F.obj X)).hom = F.obj X â— ÎµIso.hom â‰« (Î¼Iso X (ğŸ™_ C)).hom â‰« F.map (Ï_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.right_unitality","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) self.ÎµIso.hom) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `ÎµIso` and `Î¼Iso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  ÎµIso : ğŸ™_ D â‰… F.obj (ğŸ™_ C)\n  /-- tensorator -/\n  Î¼Iso : âˆ€ X Y : C, F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  Î¼Iso_hom_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      F.map f â–· F.obj X' â‰« (Î¼Iso Y X').hom = (Î¼Iso X X').hom â‰« F.map (f â–· X') := by\n    aesop_cat\n  Î¼Iso_hom_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      F.obj X' â— F.map f â‰« (Î¼Iso X' Y).hom = (Î¼Iso X' X).hom â‰« F.map (X' â— f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    âˆ€ X Y Z : C,\n      (Î¼Iso X Y).hom â–· F.obj Z â‰« (Î¼Iso (X âŠ— Y) Z).hom â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— (Î¼Iso Y Z).hom â‰«\n          (Î¼Iso X (Y âŠ— Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    âˆ€ X : C, (Î»_ (F.obj X)).hom = ÎµIso.hom â–· F.obj X â‰« (Î¼Iso (ğŸ™_ C) X).hom â‰« F.map (Î»_ X).hom := by\n      aesop_cat\n  right_unitality :\n    âˆ€ X : C, (Ï_ (F.obj X)).hom = F.obj X â— ÎµIso.hom â‰« (Î¼Iso X (ğŸ™_ C)).hom â‰« F.map (Ï_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.Î¼Iso_hom_natural_left","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (self.Î¼Iso Y X').hom) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso X X').hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `ÎµIso` and `Î¼Iso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  ÎµIso : ğŸ™_ D â‰… F.obj (ğŸ™_ C)\n  /-- tensorator -/\n  Î¼Iso : âˆ€ X Y : C, F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  Î¼Iso_hom_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      F.map f â–· F.obj X' â‰« (Î¼Iso Y X').hom = (Î¼Iso X X').hom â‰« F.map (f â–· X') := by\n    aesop_cat\n  Î¼Iso_hom_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      F.obj X' â— F.map f â‰« (Î¼Iso X' Y).hom = (Î¼Iso X' X).hom â‰« F.map (X' â— f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    âˆ€ X Y Z : C,\n      (Î¼Iso X Y).hom â–· F.obj Z â‰« (Î¼Iso (X âŠ— Y) Z).hom â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— (Î¼Iso Y Z).hom â‰«\n          (Î¼Iso X (Y âŠ— Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    âˆ€ X : C, (Î»_ (F.obj X)).hom = ÎµIso.hom â–· F.obj X â‰« (Î¼Iso (ğŸ™_ C) X).hom â‰« F.map (Î»_ X).hom := by\n      aesop_cat\n  right_unitality :\n    âˆ€ X : C, (Ï_ (F.obj X)).hom = F.obj X â— ÎµIso.hom â‰« (Î¼Iso X (ğŸ™_ C)).hom â‰« F.map (Ï_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ´ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ² : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : SizeOf C\ninstâœ : SizeOf D\nÎµIso : CategoryTheory.Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit (F.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit)\nÎ¼Iso : (X Y : C) â†’ CategoryTheory.Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y)) (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))\nÎ¼Iso_hom_natural_left : autoParam (âˆ€ {X Y : C} (f : Quiver.Hom X Y) (X' : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (Î¼Iso Y X').hom) (CategoryTheory.CategoryStruct.comp (Î¼Iso X X').hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')))) _autoâœ\nÎ¼Iso_hom_natural_right : autoParam (âˆ€ {X Y : C} (X' : C) (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (Î¼Iso X' Y).hom) (CategoryTheory.CategoryStruct.comp (Î¼Iso X' X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)))) _autoâœ\nassociativity : autoParam (âˆ€ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Î¼Iso X Y).hom (F.obj Z)) (CategoryTheory.CategoryStruct.comp (Î¼Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (Î¼Iso Y Z).hom) (Î¼Iso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom))) _autoâœ\nleft_unitality : autoParam (âˆ€ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight ÎµIso.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (Î¼Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom)))) _autoâœ\nright_unitality : autoParam (âˆ€ (X : C), Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) ÎµIso.hom) (CategoryTheory.CategoryStruct.comp (Î¼Iso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom)))) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { ÎµIso := ÎµIso, Î¼Iso := Î¼Iso, Î¼Iso_hom_natural_left := Î¼Iso_hom_natural_left, Î¼Iso_hom_natural_right := Î¼Iso_hom_natural_right, associativity := associativity, left_unitality := left_unitality, right_unitality := right_unitality }) (HAdd.hAdd 1 (SizeOf.sizeOf ÎµIso))","decl":"/-- Structure which is a helper in order to show that a functor is monoidal. It\nconsists of isomorphisms `ÎµIso` and `Î¼Iso` such that the morphisms `.hom` induced\nby these isomorphisms satisfy the axioms of lax monoidal functors. -/\nstructure CoreMonoidal where\n  /-- unit morphism -/\n  ÎµIso : ğŸ™_ D â‰… F.obj (ğŸ™_ C)\n  /-- tensorator -/\n  Î¼Iso : âˆ€ X Y : C, F.obj X âŠ— F.obj Y â‰… F.obj (X âŠ— Y)\n  Î¼Iso_hom_natural_left :\n    âˆ€ {X Y : C} (f : X âŸ¶ Y) (X' : C),\n      F.map f â–· F.obj X' â‰« (Î¼Iso Y X').hom = (Î¼Iso X X').hom â‰« F.map (f â–· X') := by\n    aesop_cat\n  Î¼Iso_hom_natural_right :\n    âˆ€ {X Y : C} (X' : C) (f : X âŸ¶ Y) ,\n      F.obj X' â— F.map f â‰« (Î¼Iso X' Y).hom = (Î¼Iso X' X).hom â‰« F.map (X' â— f) := by\n    aesop_cat\n  /-- associativity of the tensorator -/\n  associativity :\n    âˆ€ X Y Z : C,\n      (Î¼Iso X Y).hom â–· F.obj Z â‰« (Î¼Iso (X âŠ— Y) Z).hom â‰« F.map (Î±_ X Y Z).hom =\n        (Î±_ (F.obj X) (F.obj Y) (F.obj Z)).hom â‰« F.obj X â— (Î¼Iso Y Z).hom â‰«\n          (Î¼Iso X (Y âŠ— Z)).hom := by\n    aesop_cat\n  -- unitality\n  left_unitality :\n    âˆ€ X : C, (Î»_ (F.obj X)).hom = ÎµIso.hom â–· F.obj X â‰« (Î¼Iso (ğŸ™_ C) X).hom â‰« F.map (Î»_ X).hom := by\n      aesop_cat\n  right_unitality :\n    âˆ€ X : C, (Ï_ (F.obj X)).hom = F.obj X â— ÎµIso.hom â‰« (Î¼Iso X (ğŸ™_ C)).hom â‰« F.map (Ï_ X).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.Î¼Iso_hom_natural_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX Y X' : C\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X' Y)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X') (F.map f)) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso X' Y).hom h)) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso X' X).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X' f)) h))","decl":"attribute [reassoc (attr := simp)] Î¼Iso_hom_natural_left\n  Î¼Iso_hom_natural_right associativity\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.associativity_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX Y Zâœ : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Zâœ))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (self.Î¼Iso X Y).hom (F.obj Zâœ)) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Zâœ).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.associator X Y Zâœ).hom) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (F.obj X) (F.obj Y) (F.obj Zâœ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (self.Î¼Iso Y Zâœ).hom) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Zâœ)).hom h)))","decl":"attribute [reassoc (attr := simp)] Î¼Iso_hom_natural_left\n  Î¼Iso_hom_natural_right associativity\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.Î¼Iso_hom_natural_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX Y : C\nf : Quiver.Hom X Y\nX' : C\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj Y X')) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (F.obj X')) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso Y X').hom h)) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso X X').hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X')) h))","decl":"attribute [reassoc (attr := simp)] Î¼Iso_hom_natural_left\n  Î¼Iso_hom_natural_right associativity\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.left_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj X)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.ÎµIso.hom (F.obj X)) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso CategoryTheory.MonoidalCategoryStruct.tensorUnit X).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) h)))","decl":"attribute [reassoc] left_unitality right_unitality\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.right_unitality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nself : F.CoreMonoidal\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj X)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) self.ÎµIso.hom) (CategoryTheory.CategoryStruct.comp (self.Î¼Iso X CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) h)))","decl":"attribute [reassoc] left_unitality right_unitality\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.toLaxMonoidal_Îµ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nh : F.CoreMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Îµ F) h.ÎµIso.hom","decl":"lemma toLaxMonoidal_Îµ :\n    letI := h.toLaxMonoidal\n    LaxMonoidal.Îµ F = h.ÎµIso.hom := rfl\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.toLaxMonoidal_Î¼","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nh : F.CoreMonoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y) (h.Î¼Iso X Y).hom","decl":"lemma toLaxMonoidal_Î¼ (X Y : C) :\n    letI := h.toLaxMonoidal\n    LaxMonoidal.Î¼ F X Y = (h.Î¼Iso X Y).hom := rfl\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.toOplaxMonoidal_Î·","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nh : F.CoreMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î· F) h.ÎµIso.inv","decl":"lemma toOplaxMonoidal_Î· :\n    letI := h.toOplaxMonoidal\n    OplaxMonoidal.Î· F = h.ÎµIso.inv := rfl\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.toOplaxMonoidal_Î´","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nh : F.CoreMonoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y) (h.Î¼Iso X Y).inv","decl":"lemma toOplaxMonoidal_Î´  (X Y : C) :\n    letI := h.toOplaxMonoidal\n    OplaxMonoidal.Î´ F X Y = (h.Î¼Iso X Y).inv := rfl\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.toMonoidal_toOplaxMonoidal","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nh : F.CoreMonoidal\nâŠ¢ Eq CategoryTheory.Functor.Monoidal.toOplaxMonoidal h.toOplaxMonoidal","decl":"attribute [local simp] toLaxMonoidal_Îµ toLaxMonoidal_Î¼ toOplaxMonoidal_Î· toOplaxMonoidal_Î´ in\n/-- The monoidal functor structure induced by a `Functor.CoreMonoidal` structure. -/\n@[simps! toLaxMonoidal toOplaxMonoidal]\ndef toMonoidal : F.Monoidal where\n  toLaxMonoidal := h.toLaxMonoidal\n  toOplaxMonoidal := h.toOplaxMonoidal\n\n"}
{"name":"CategoryTheory.Functor.CoreMonoidal.toMonoidal_toLaxMonoidal","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nh : F.CoreMonoidal\nâŠ¢ Eq CategoryTheory.Functor.Monoidal.toLaxMonoidal h.toLaxMonoidal","decl":"attribute [local simp] toLaxMonoidal_Îµ toLaxMonoidal_Î¼ toOplaxMonoidal_Î· toOplaxMonoidal_Î´ in\n/-- The monoidal functor structure induced by a `Functor.CoreMonoidal` structure. -/\n@[simps! toLaxMonoidal toOplaxMonoidal]\ndef toMonoidal : F.Monoidal where\n  toLaxMonoidal := h.toLaxMonoidal\n  toOplaxMonoidal := h.toOplaxMonoidal\n\n"}
{"name":"CategoryTheory.Functor.prod_Îµ_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¸ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ· : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ¶ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœâµ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœâ´ : CategoryTheory.MonoidalCategory E\nC' : Type uâ‚'\ninstâœÂ³ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninstâœÂ² : CategoryTheory.MonoidalCategory C'\ninstâœÂ¹ : F.LaxMonoidal\ninstâœ : G.LaxMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Îµ (F.prod G)).1 (CategoryTheory.Functor.LaxMonoidal.Îµ F)","decl":"@[simp] lemma prod_Îµ_fst : (Îµ (prod F G)).1 = Îµ F := rfl\n"}
{"name":"CategoryTheory.Functor.prod_Îµ_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¸ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ· : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ¶ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœâµ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœâ´ : CategoryTheory.MonoidalCategory E\nC' : Type uâ‚'\ninstâœÂ³ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninstâœÂ² : CategoryTheory.MonoidalCategory C'\ninstâœÂ¹ : F.LaxMonoidal\ninstâœ : G.LaxMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Îµ (F.prod G)).2 (CategoryTheory.Functor.LaxMonoidal.Îµ G)","decl":"@[simp] lemma prod_Îµ_snd : (Îµ (prod F G)).2 = Îµ G := rfl\n"}
{"name":"CategoryTheory.Functor.prod_Î¼_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¸ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ· : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ¶ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœâµ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœâ´ : CategoryTheory.MonoidalCategory E\nC' : Type uâ‚'\ninstâœÂ³ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninstâœÂ² : CategoryTheory.MonoidalCategory C'\ninstâœÂ¹ : F.LaxMonoidal\ninstâœ : G.LaxMonoidal\nX Y : Prod C E\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Î¼ (F.prod G) X Y).1 (CategoryTheory.Functor.LaxMonoidal.Î¼ F X.1 Y.1)","decl":"@[simp] lemma prod_Î¼_fst (X Y : C Ã— E) : (Î¼ (prod F G) X Y).1 = Î¼ F _ _ := rfl\n"}
{"name":"CategoryTheory.Functor.prod_Î¼_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¸ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ· : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ¶ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœâµ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœâ´ : CategoryTheory.MonoidalCategory E\nC' : Type uâ‚'\ninstâœÂ³ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninstâœÂ² : CategoryTheory.MonoidalCategory C'\ninstâœÂ¹ : F.LaxMonoidal\ninstâœ : G.LaxMonoidal\nX Y : Prod C E\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Î¼ (F.prod G) X Y).2 (CategoryTheory.Functor.LaxMonoidal.Î¼ G X.2 Y.2)","decl":"@[simp] lemma prod_Î¼_snd (X Y : C Ã— E) : (Î¼ (prod F G) X Y).2 = Î¼ G _ _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.prod_Î·_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¸ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ· : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ¶ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœâµ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœâ´ : CategoryTheory.MonoidalCategory E\nC' : Type uâ‚'\ninstâœÂ³ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninstâœÂ² : CategoryTheory.MonoidalCategory C'\ninstâœÂ¹ : F.OplaxMonoidal\ninstâœ : G.OplaxMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î· (F.prod G)).1 (CategoryTheory.Functor.OplaxMonoidal.Î· F)","decl":"@[simp] lemma prod_Î·_fst : (Î· (prod F G)).1 = Î· F := rfl\n"}
{"name":"CategoryTheory.Functor.prod_Î·_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¸ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ· : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ¶ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœâµ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœâ´ : CategoryTheory.MonoidalCategory E\nC' : Type uâ‚'\ninstâœÂ³ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninstâœÂ² : CategoryTheory.MonoidalCategory C'\ninstâœÂ¹ : F.OplaxMonoidal\ninstâœ : G.OplaxMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î· (F.prod G)).2 (CategoryTheory.Functor.OplaxMonoidal.Î· G)","decl":"@[simp] lemma prod_Î·_snd : (Î· (prod F G)).2 = Î· G := rfl\n"}
{"name":"CategoryTheory.Functor.prod_Î´_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¸ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ· : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ¶ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœâµ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœâ´ : CategoryTheory.MonoidalCategory E\nC' : Type uâ‚'\ninstâœÂ³ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninstâœÂ² : CategoryTheory.MonoidalCategory C'\ninstâœÂ¹ : F.OplaxMonoidal\ninstâœ : G.OplaxMonoidal\nX Y : Prod C E\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î´ (F.prod G) X Y).1 (CategoryTheory.Functor.OplaxMonoidal.Î´ F X.1 Y.1)","decl":"@[simp] lemma prod_Î´_fst (X Y : C Ã— E) : (Î´ (prod F G) X Y).1 = Î´ F _ _ := rfl\n"}
{"name":"CategoryTheory.Functor.prod_Î´_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¸ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ· : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ¶ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœâµ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœâ´ : CategoryTheory.MonoidalCategory E\nC' : Type uâ‚'\ninstâœÂ³ : CategoryTheory.Category.{vâ‚', uâ‚'} C'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor E C'\ninstâœÂ² : CategoryTheory.MonoidalCategory C'\ninstâœÂ¹ : F.OplaxMonoidal\ninstâœ : G.OplaxMonoidal\nX Y : Prod C E\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î´ (F.prod G) X Y).2 (CategoryTheory.Functor.OplaxMonoidal.Î´ G X.2 Y.2)","decl":"@[simp] lemma prod_Î´_snd (X Y : C Ã— E) : (Î´ (prod F G) X Y).2 = Î´ G _ _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.diag_Îµ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Îµ (CategoryTheory.Functor.diag C)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp] lemma diag_Îµ : Îµ (diag C) = ğŸ™ _ := rfl\n"}
{"name":"CategoryTheory.Functor.diag_Î·","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î· (CategoryTheory.Functor.diag C)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.diag C).obj CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[simp] lemma diag_Î· : Î· (diag C) = ğŸ™ _ := rfl\n"}
{"name":"CategoryTheory.Functor.diag_Î¼","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Î¼ (CategoryTheory.Functor.diag C) X Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.Functor.diag C).obj X) ((CategoryTheory.Functor.diag C).obj Y)))","decl":"@[simp] lemma diag_Î¼ (X Y : C) : Î¼ (diag C) X Y = ğŸ™ _ := rfl\n"}
{"name":"CategoryTheory.Functor.diag_Î´","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î´ (CategoryTheory.Functor.diag C) X Y) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.diag C).obj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)))","decl":"@[simp] lemma diag_Î´ (X Y : C) : Î´ (diag C) X Y = ğŸ™ _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_Îµ_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ· : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¶ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœÂ² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninstâœÂ¹ : F.LaxMonoidal\ninstâœ : G.LaxMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Îµ (F.prod' G)).1 (CategoryTheory.Functor.LaxMonoidal.Îµ F)","decl":"@[simp] lemma prod'_Îµ_fst : (Îµ (prod' F G)).1 = Îµ F := by\n  change _ â‰« F.map (ğŸ™ _) = _\n  rw [Functor.map_id, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_Îµ_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ· : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¶ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœÂ² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninstâœÂ¹ : F.LaxMonoidal\ninstâœ : G.LaxMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Îµ (F.prod' G)).2 (CategoryTheory.Functor.LaxMonoidal.Îµ G)","decl":"@[simp] lemma prod'_Îµ_snd : (Îµ (prod' F G)).2 = Îµ G := by\n  change _ â‰« G.map (ğŸ™ _) = _\n  rw [Functor.map_id, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_Î¼_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ· : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¶ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœÂ² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninstâœÂ¹ : F.LaxMonoidal\ninstâœ : G.LaxMonoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Î¼ (F.prod' G) X Y).1 (CategoryTheory.Functor.LaxMonoidal.Î¼ F X Y)","decl":"@[simp] lemma prod'_Î¼_fst (X Y : C) : (Î¼ (prod' F G) X Y).1 = Î¼ F X Y := by\n  change _ â‰« F.map (ğŸ™ _) = _\n  rw [Functor.map_id, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_Î¼_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ· : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¶ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœÂ² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninstâœÂ¹ : F.LaxMonoidal\ninstâœ : G.LaxMonoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Î¼ (F.prod' G) X Y).2 (CategoryTheory.Functor.LaxMonoidal.Î¼ G X Y)","decl":"@[simp] lemma prod'_Î¼_snd (X Y : C) : (Î¼ (prod' F G) X Y).2 = Î¼ G X Y := by\n  change _ â‰« G.map (ğŸ™ _) = _\n  rw [Functor.map_id, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_Î·_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ· : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¶ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœÂ² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninstâœÂ¹ : F.OplaxMonoidal\ninstâœ : G.OplaxMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î· (F.prod' G)).1 (CategoryTheory.Functor.OplaxMonoidal.Î· F)","decl":"@[simp] lemma prod'_Î·_fst : (Î· (prod' F G)).1 = Î· F := by\n  change F.map (ğŸ™ _)  â‰« _ = _\n  rw [Functor.map_id, Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_Î·_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ· : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¶ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœÂ² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninstâœÂ¹ : F.OplaxMonoidal\ninstâœ : G.OplaxMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î· (F.prod' G)).2 (CategoryTheory.Functor.OplaxMonoidal.Î· G)","decl":"@[simp] lemma prod'_Î·_snd : (Î· (prod' F G)).2 = Î· G := by\n  change G.map (ğŸ™ _)  â‰« _ = _\n  rw [Functor.map_id, Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_Î´_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ· : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¶ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœÂ² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninstâœÂ¹ : F.OplaxMonoidal\ninstâœ : G.OplaxMonoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î´ (F.prod' G) X Y).1 (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y)","decl":"@[simp] lemma prod'_Î´_fst (X Y : C) : (Î´ (prod' F G) X Y).1 = Î´ F X Y := by\n  change F.map (ğŸ™ _) â‰« _ = _\n  rw [Functor.map_id, Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod'_Î´_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ· : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¶ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœÂ² : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor C E\ninstâœÂ¹ : F.OplaxMonoidal\ninstâœ : G.OplaxMonoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Î´ (F.prod' G) X Y).2 (CategoryTheory.Functor.OplaxMonoidal.Î´ G X Y)","decl":"@[simp] lemma prod'_Î´_snd (X Y : C) : (Î´ (prod' F G) X Y).2 = Î´ G X Y := by\n  change G.map (ğŸ™ _) â‰« _ = _\n  rw [Functor.map_id, Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.prod_comp_fst_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_3, u_1} C\ninstâœ : CategoryTheory.Category.{u_4, u_2} D\nX Y Zâœ : Prod C D\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Zâœ\nZ : C\nh : Quiver.Hom Zâœ.1 Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).1 h) (CategoryTheory.CategoryStruct.comp f.1 (CategoryTheory.CategoryStruct.comp g.1 h))","decl":"@[simp, reassoc]\nlemma prod_comp_fst {C D : Type*} [Category C] [Category D]\n    {X Y Z : C Ã— D} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) :\n    (f â‰« g).1 = f.1 â‰« g.1 := rfl\n\n"}
{"name":"CategoryTheory.Functor.prod_comp_fst","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_3, u_1} C\ninstâœ : CategoryTheory.Category.{u_4, u_2} D\nX Y Z : Prod C D\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g).1 (CategoryTheory.CategoryStruct.comp f.1 g.1)","decl":"@[simp, reassoc]\nlemma prod_comp_fst {C D : Type*} [Category C] [Category D]\n    {X Y Z : C Ã— D} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) :\n    (f â‰« g).1 = f.1 â‰« g.1 := rfl\n\n"}
{"name":"CategoryTheory.Functor.prod_comp_snd_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_3, u_1} C\ninstâœ : CategoryTheory.Category.{u_4, u_2} D\nX Y Zâœ : Prod C D\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Zâœ\nZ : D\nh : Quiver.Hom Zâœ.2 Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).2 h) (CategoryTheory.CategoryStruct.comp f.2 (CategoryTheory.CategoryStruct.comp g.2 h))","decl":"@[simp, reassoc]\nlemma prod_comp_snd {C D : Type*} [Category C] [Category D]\n    {X Y Z : C Ã— D} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) :\n    (f â‰« g).2 = f.2 â‰« g.2 := rfl\n\n"}
{"name":"CategoryTheory.Functor.prod_comp_snd","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ¹ : CategoryTheory.Category.{u_3, u_1} C\ninstâœ : CategoryTheory.Category.{u_4, u_2} D\nX Y Z : Prod C D\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g).2 (CategoryTheory.CategoryStruct.comp f.2 g.2)","decl":"@[simp, reassoc]\nlemma prod_comp_snd {C D : Type*} [Category C] [Category D]\n    {X Y Z : C Ã— D} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) :\n    (f â‰« g).2 = f.2 â‰« g.2 := rfl\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjointLaxMonoidal_Îµ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœ : F.OplaxMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Îµ G) ((adj.homEquiv CategoryTheory.MonoidalCategoryStruct.tensorUnit CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.Functor.OplaxMonoidal.Î· F))","decl":"lemma rightAdjointLaxMonoidal_Îµ :\n    letI := adj.rightAdjointLaxMonoidal\n    Îµ G = adj.homEquiv _ _ (Î· F) := rfl\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjointLaxMonoidal_Î¼","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœ : F.OplaxMonoidal\nX Y : D\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Î¼ G X Y) ((adj.homEquiv (CategoryTheory.MonoidalCategoryStruct.tensorObj (G.obj X) (G.obj Y)) (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.Functor.id D).obj X) ((CategoryTheory.Functor.id D).obj Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F (G.obj X) (G.obj Y)) (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.counit.app X) (adj.counit.app Y))))","decl":"lemma rightAdjointLaxMonoidal_Î¼ (X Y : D) :\n    letI := adj.rightAdjointLaxMonoidal\n    Î¼ G X Y = adj.homEquiv _ _ (Î´ F _ _ â‰« (adj.counit.app X âŠ— adj.counit.app Y)) := rfl\n\n"}
{"name":"CategoryTheory.Adjunction.IsMonoidal.leftAdjoint_Î¼","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ´ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ² : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœÂ¹ : F.OplaxMonoidal\ninstâœ : G.LaxMonoidal\nself : adj.IsMonoidal\nX Y : D\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Î¼ G X Y) ((adj.homEquiv (CategoryTheory.MonoidalCategoryStruct.tensorObj (G.obj X) (G.obj Y)) (CategoryTheory.MonoidalCategoryStruct.tensorObj ((CategoryTheory.Functor.id D).obj X) ((CategoryTheory.Functor.id D).obj Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F (G.obj X) (G.obj Y)) (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.counit.app X) (adj.counit.app Y))))","decl":"/-- When `adj : F âŠ£ G` is an adjunction, with `F` oplax monoidal and `G` monoidal,\nthis typeclass expresses compatibilities between the adjunction and the (op)lax\nmonoidal structures. -/\nclass IsMonoidal [G.LaxMonoidal] : Prop where\n  leftAdjoint_Îµ : Îµ G = adj.homEquiv _ _ (Î· F) := by aesop_cat\n  leftAdjoint_Î¼ (X Y : D) :\n    Î¼ G X Y = adj.homEquiv _ _ (Î´ F _ _ â‰« (adj.counit.app X âŠ— adj.counit.app Y)) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.IsMonoidal.leftAdjoint_Îµ","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ´ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ² : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœÂ¹ : F.OplaxMonoidal\ninstâœ : G.LaxMonoidal\nself : adj.IsMonoidal\nâŠ¢ Eq (CategoryTheory.Functor.LaxMonoidal.Îµ G) ((adj.homEquiv CategoryTheory.MonoidalCategoryStruct.tensorUnit CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.Functor.OplaxMonoidal.Î· F))","decl":"/-- When `adj : F âŠ£ G` is an adjunction, with `F` oplax monoidal and `G` monoidal,\nthis typeclass expresses compatibilities between the adjunction and the (op)lax\nmonoidal structures. -/\nclass IsMonoidal [G.LaxMonoidal] : Prop where\n  leftAdjoint_Îµ : Îµ G = adj.homEquiv _ _ (Î· F) := by aesop_cat\n  leftAdjoint_Î¼ (X Y : D) :\n    Î¼ G X Y = adj.homEquiv _ _ (Î´ F _ _ â‰« (adj.counit.app X âŠ— adj.counit.app Y)) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.instIsMonoidal","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœ : F.OplaxMonoidal\nâŠ¢ adj.IsMonoidal","decl":"instance :\n    letI := adj.rightAdjointLaxMonoidal\n    adj.IsMonoidal := by\n  letI := adj.rightAdjointLaxMonoidal\n  constructor\n  Â· rfl\n  Â· intro _ _\n    rfl\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_unit_comp_map_Î·","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœÂ² : F.OplaxMonoidal\ninstâœÂ¹ : G.LaxMonoidal\ninstâœ : adj.IsMonoidal\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) (G.map (CategoryTheory.Functor.OplaxMonoidal.Î· F))) (CategoryTheory.Functor.LaxMonoidal.Îµ G)","decl":"@[reassoc]\nlemma unit_app_unit_comp_map_Î· : adj.unit.app (ğŸ™_ C) â‰« G.map (Î· F) = Îµ G :=\n  Adjunction.IsMonoidal.leftAdjoint_Îµ.symm\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_unit_comp_map_Î·_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœÂ² : F.OplaxMonoidal\ninstâœÂ¹ : G.LaxMonoidal\ninstâœ : adj.IsMonoidal\nZ : C\nh : Quiver.Hom (G.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.Î· F)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Îµ G) h)","decl":"@[reassoc]\nlemma unit_app_unit_comp_map_Î· : adj.unit.app (ğŸ™_ C) â‰« G.map (Î· F) = Îµ G :=\n  Adjunction.IsMonoidal.leftAdjoint_Îµ.symm\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_tensor_comp_map_Î´_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœÂ² : F.OplaxMonoidal\ninstâœÂ¹ : G.LaxMonoidal\ninstâœ : adj.IsMonoidal\nX Y Z : C\nh : Quiver.Hom (G.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (F.obj X) (F.obj Y))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.unit.app X) (adj.unit.app Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ G (F.obj X) (F.obj Y)) h))","decl":"@[reassoc]\nlemma unit_app_tensor_comp_map_Î´ (X Y : C) :\n    adj.unit.app (X âŠ— Y) â‰« G.map (Î´ F X Y) = (adj.unit.app X âŠ— adj.unit.app Y) â‰« Î¼ G _ _ := by\n  rw [IsMonoidal.leftAdjoint_Î¼ (adj := adj), homEquiv_unit]\n  dsimp\n  simp only [â† adj.unit_naturality_assoc, â† Functor.map_comp, â† Î´_natural_assoc,\n    â† tensor_comp, left_triangle_components, tensorHom_id, id_whiskerRight, comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.unit_app_tensor_comp_map_Î´","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœÂ² : F.OplaxMonoidal\ninstâœÂ¹ : G.LaxMonoidal\ninstâœ : adj.IsMonoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) (G.map (CategoryTheory.Functor.OplaxMonoidal.Î´ F X Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.unit.app X) (adj.unit.app Y)) (CategoryTheory.Functor.LaxMonoidal.Î¼ G (F.obj X) (F.obj Y)))","decl":"@[reassoc]\nlemma unit_app_tensor_comp_map_Î´ (X Y : C) :\n    adj.unit.app (X âŠ— Y) â‰« G.map (Î´ F X Y) = (adj.unit.app X âŠ— adj.unit.app Y) â‰« Î¼ G _ _ := by\n  rw [IsMonoidal.leftAdjoint_Î¼ (adj := adj), homEquiv_unit]\n  dsimp\n  simp only [â† adj.unit_naturality_assoc, â† Functor.map_comp, â† Î´_natural_assoc,\n    â† tensor_comp, left_triangle_components, tensorHom_id, id_whiskerRight, comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.map_Îµ_comp_counit_app_unit","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœÂ² : F.OplaxMonoidal\ninstâœÂ¹ : G.LaxMonoidal\ninstâœ : adj.IsMonoidal\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Functor.LaxMonoidal.Îµ G)) (adj.counit.app CategoryTheory.MonoidalCategoryStruct.tensorUnit)) (CategoryTheory.Functor.OplaxMonoidal.Î· F)","decl":"@[reassoc]\nlemma map_Îµ_comp_counit_app_unit : F.map (Îµ G) â‰« adj.counit.app (ğŸ™_ D) = Î· F := by\n  rw [IsMonoidal.leftAdjoint_Îµ (adj := adj), homEquiv_unit, map_comp,\n    assoc, counit_naturality, left_triangle_components_assoc]\n\n"}
{"name":"CategoryTheory.Adjunction.map_Îµ_comp_counit_app_unit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœÂ² : F.OplaxMonoidal\ninstâœÂ¹ : G.LaxMonoidal\ninstâœ : adj.IsMonoidal\nZ : D\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Functor.LaxMonoidal.Îµ G)) (CategoryTheory.CategoryStruct.comp (adj.counit.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î· F) h)","decl":"@[reassoc]\nlemma map_Îµ_comp_counit_app_unit : F.map (Îµ G) â‰« adj.counit.app (ğŸ™_ D) = Î· F := by\n  rw [IsMonoidal.leftAdjoint_Îµ (adj := adj), homEquiv_unit, map_comp,\n    assoc, counit_naturality, left_triangle_components_assoc]\n\n"}
{"name":"CategoryTheory.Adjunction.map_Î¼_comp_counit_app_tensor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœÂ² : F.OplaxMonoidal\ninstâœÂ¹ : G.LaxMonoidal\ninstâœ : adj.IsMonoidal\nX Y : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Functor.LaxMonoidal.Î¼ G X Y)) (adj.counit.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F (G.obj X) (G.obj Y)) (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.counit.app X) (adj.counit.app Y)))","decl":"@[reassoc]\nlemma map_Î¼_comp_counit_app_tensor (X Y : D) :\n    F.map (Î¼ G X Y) â‰« adj.counit.app (X âŠ— Y) =\n      Î´ F _ _ â‰« (adj.counit.app X âŠ— adj.counit.app Y) := by\n  rw [IsMonoidal.leftAdjoint_Î¼ (adj := adj), homEquiv_unit]\n  simp\n\n"}
{"name":"CategoryTheory.Adjunction.map_Î¼_comp_counit_app_tensor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœÂ² : F.OplaxMonoidal\ninstâœÂ¹ : G.LaxMonoidal\ninstâœ : adj.IsMonoidal\nX Y Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Functor.LaxMonoidal.Î¼ G X Y)) (CategoryTheory.CategoryStruct.comp (adj.counit.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ F (G.obj X) (G.obj Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (adj.counit.app X) (adj.counit.app Y)) h))","decl":"@[reassoc]\nlemma map_Î¼_comp_counit_app_tensor (X Y : D) :\n    F.map (Î¼ G X Y) â‰« adj.counit.app (X âŠ— Y) =\n      Î´ F _ _ â‰« (adj.counit.app X âŠ— adj.counit.app Y) := by\n  rw [IsMonoidal.leftAdjoint_Î¼ (adj := adj), homEquiv_unit]\n  simp\n\n"}
{"name":"CategoryTheory.Adjunction.instIsMonoidalId","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nâŠ¢ CategoryTheory.Adjunction.id.IsMonoidal","decl":"instance : (Adjunction.id (C := C)).IsMonoidal where\n  leftAdjoint_Îµ := by simp [id, homEquiv]\n  leftAdjoint_Î¼ := by simp [id, homEquiv]\n\n"}
{"name":"CategoryTheory.Adjunction.isMonoidal_comp","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ¹â° : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¹ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ¸ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ· : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœâ¶ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœâµ : CategoryTheory.MonoidalCategory E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninstâœâ´ : F.OplaxMonoidal\ninstâœÂ³ : G.LaxMonoidal\nF' : CategoryTheory.Functor D E\nG' : CategoryTheory.Functor E D\nadj' : CategoryTheory.Adjunction F' G'\ninstâœÂ² : F'.OplaxMonoidal\ninstâœÂ¹ : G'.LaxMonoidal\ninstâœ : adj'.IsMonoidal\nâŠ¢ (adj.comp adj').IsMonoidal","decl":"instance isMonoidal_comp {F' : D â¥¤ E} {G' : E â¥¤ D} (adj' : F' âŠ£ G')\n  [F'.OplaxMonoidal] [G'.LaxMonoidal] [adj'.IsMonoidal] : (adj.comp adj').IsMonoidal where\n  leftAdjoint_Îµ := by\n    dsimp [homEquiv]\n    rw [â† adj.unit_app_unit_comp_map_Î·, â† adj'.unit_app_unit_comp_map_Î·,\n      assoc, comp_unit_app, assoc, â† Functor.map_comp,\n      â† adj'.unit_naturality_assoc, â† map_comp, â† map_comp]\n  leftAdjoint_Î¼ X Y := by\n    apply ((adj.comp adj').homEquiv _ _).symm.injective\n    erw [Equiv.symm_apply_apply]\n    dsimp [homEquiv]\n    rw [comp_counit_app, comp_counit_app, comp_counit_app, assoc, tensor_comp, Î´_natural_assoc]\n    dsimp\n    rw [â† adj'.map_Î¼_comp_counit_app_tensor, â† map_comp_assoc, â† map_comp_assoc,\n      â† map_comp_assoc, â† adj.map_Î¼_comp_counit_app_tensor, assoc,\n      F.map_comp_assoc, counit_naturality]\n\n"}
{"name":"CategoryTheory.Equivalence.unitIso_hom_app_comp_inverse_map_Î·_functor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninstâœÂ² : e.functor.Monoidal\ninstâœÂ¹ : e.inverse.Monoidal\ninstâœ : e.IsMonoidal\nZ : C\nh : Quiver.Hom (e.inverse.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.unitIso.hom.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (e.inverse.map (CategoryTheory.Functor.OplaxMonoidal.Î· e.functor)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Îµ e.inverse) h)","decl":"@[reassoc]\nlemma unitIso_hom_app_comp_inverse_map_Î·_functor :\n    e.unitIso.hom.app (ğŸ™_ C) â‰« e.inverse.map (Î· e.functor) = Îµ e.inverse :=\n  e.toAdjunction.unit_app_unit_comp_map_Î·\n\n"}
{"name":"CategoryTheory.Equivalence.unitIso_hom_app_comp_inverse_map_Î·_functor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninstâœÂ² : e.functor.Monoidal\ninstâœÂ¹ : e.inverse.Monoidal\ninstâœ : e.IsMonoidal\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.unitIso.hom.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) (e.inverse.map (CategoryTheory.Functor.OplaxMonoidal.Î· e.functor))) (CategoryTheory.Functor.LaxMonoidal.Îµ e.inverse)","decl":"@[reassoc]\nlemma unitIso_hom_app_comp_inverse_map_Î·_functor :\n    e.unitIso.hom.app (ğŸ™_ C) â‰« e.inverse.map (Î· e.functor) = Îµ e.inverse :=\n  e.toAdjunction.unit_app_unit_comp_map_Î·\n\n"}
{"name":"CategoryTheory.Equivalence.unitIso_hom_app_tensor_comp_inverse_map_Î´_functor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninstâœÂ² : e.functor.Monoidal\ninstâœÂ¹ : e.inverse.Monoidal\ninstâœ : e.IsMonoidal\nX Y Z : C\nh : Quiver.Hom (e.inverse.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.functor.obj X) (e.functor.obj Y))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.unitIso.hom.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) (CategoryTheory.CategoryStruct.comp (e.inverse.map (CategoryTheory.Functor.OplaxMonoidal.Î´ e.functor X Y)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.unitIso.hom.app X) (e.unitIso.hom.app Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ e.inverse (e.functor.obj X) (e.functor.obj Y)) h))","decl":"@[reassoc]\nlemma unitIso_hom_app_tensor_comp_inverse_map_Î´_functor (X Y : C) :\n    e.unitIso.hom.app (X âŠ— Y) â‰« e.inverse.map (Î´ e.functor X Y) =\n      (e.unitIso.hom.app X âŠ— e.unitIso.hom.app Y) â‰« Î¼ e.inverse _ _ :=\n  e.toAdjunction.unit_app_tensor_comp_map_Î´ X Y\n\n"}
{"name":"CategoryTheory.Equivalence.unitIso_hom_app_tensor_comp_inverse_map_Î´_functor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninstâœÂ² : e.functor.Monoidal\ninstâœÂ¹ : e.inverse.Monoidal\ninstâœ : e.IsMonoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.unitIso.hom.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) (e.inverse.map (CategoryTheory.Functor.OplaxMonoidal.Î´ e.functor X Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.unitIso.hom.app X) (e.unitIso.hom.app Y)) (CategoryTheory.Functor.LaxMonoidal.Î¼ e.inverse (e.functor.obj X) (e.functor.obj Y)))","decl":"@[reassoc]\nlemma unitIso_hom_app_tensor_comp_inverse_map_Î´_functor (X Y : C) :\n    e.unitIso.hom.app (X âŠ— Y) â‰« e.inverse.map (Î´ e.functor X Y) =\n      (e.unitIso.hom.app X âŠ— e.unitIso.hom.app Y) â‰« Î¼ e.inverse _ _ :=\n  e.toAdjunction.unit_app_tensor_comp_map_Î´ X Y\n\n"}
{"name":"CategoryTheory.Equivalence.functor_map_Îµ_inverse_comp_counitIso_hom_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninstâœÂ² : e.functor.Monoidal\ninstâœÂ¹ : e.inverse.Monoidal\ninstâœ : e.IsMonoidal\nZ : D\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.Functor.LaxMonoidal.Îµ e.inverse)) (CategoryTheory.CategoryStruct.comp (e.counitIso.hom.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î· e.functor) h)","decl":"@[reassoc]\nlemma functor_map_Îµ_inverse_comp_counitIso_hom_app :\n    e.functor.map (Îµ e.inverse) â‰« e.counitIso.hom.app (ğŸ™_ D) = Î· e.functor :=\n  e.toAdjunction.map_Îµ_comp_counit_app_unit\n\n"}
{"name":"CategoryTheory.Equivalence.functor_map_Îµ_inverse_comp_counitIso_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninstâœÂ² : e.functor.Monoidal\ninstâœÂ¹ : e.inverse.Monoidal\ninstâœ : e.IsMonoidal\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.Functor.LaxMonoidal.Îµ e.inverse)) (e.counitIso.hom.app CategoryTheory.MonoidalCategoryStruct.tensorUnit)) (CategoryTheory.Functor.OplaxMonoidal.Î· e.functor)","decl":"@[reassoc]\nlemma functor_map_Îµ_inverse_comp_counitIso_hom_app :\n    e.functor.map (Îµ e.inverse) â‰« e.counitIso.hom.app (ğŸ™_ D) = Î· e.functor :=\n  e.toAdjunction.map_Îµ_comp_counit_app_unit\n\n"}
{"name":"CategoryTheory.Equivalence.functor_map_Î¼_inverse_comp_counitIso_hom_app_tensor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninstâœÂ² : e.functor.Monoidal\ninstâœÂ¹ : e.inverse.Monoidal\ninstâœ : e.IsMonoidal\nX Y : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.Functor.LaxMonoidal.Î¼ e.inverse X Y)) (e.counitIso.hom.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ e.functor (e.inverse.obj X) (e.inverse.obj Y)) (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.counitIso.hom.app X) (e.counitIso.hom.app Y)))","decl":"@[reassoc]\nlemma functor_map_Î¼_inverse_comp_counitIso_hom_app_tensor (X Y : D) :\n    e.functor.map (Î¼ e.inverse X Y) â‰« e.counitIso.hom.app (X âŠ— Y) =\n      Î´ e.functor _ _ â‰« (e.counitIso.hom.app X âŠ— e.counitIso.hom.app Y) :=\n  e.toAdjunction.map_Î¼_comp_counit_app_tensor X Y\n\n"}
{"name":"CategoryTheory.Equivalence.functor_map_Î¼_inverse_comp_counitIso_hom_app_tensor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninstâœÂ² : e.functor.Monoidal\ninstâœÂ¹ : e.inverse.Monoidal\ninstâœ : e.IsMonoidal\nX Y Z : D\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.Functor.LaxMonoidal.Î¼ e.inverse X Y)) (CategoryTheory.CategoryStruct.comp (e.counitIso.hom.app (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OplaxMonoidal.Î´ e.functor (e.inverse.obj X) (e.inverse.obj Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.counitIso.hom.app X) (e.counitIso.hom.app Y)) h))","decl":"@[reassoc]\nlemma functor_map_Î¼_inverse_comp_counitIso_hom_app_tensor (X Y : D) :\n    e.functor.map (Î¼ e.inverse X Y) â‰« e.counitIso.hom.app (X âŠ— Y) =\n      Î´ e.functor _ _ â‰« (e.counitIso.hom.app X âŠ— e.counitIso.hom.app Y) :=\n  e.toAdjunction.map_Î¼_comp_counit_app_tensor X Y\n\n"}
{"name":"CategoryTheory.Equivalence.counitIso_inv_app_comp_functor_map_Î·_inverse","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninstâœÂ² : e.functor.Monoidal\ninstâœÂ¹ : e.inverse.Monoidal\ninstâœ : e.IsMonoidal\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.counitIso.inv.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) (e.functor.map (CategoryTheory.Functor.OplaxMonoidal.Î· e.inverse))) (CategoryTheory.Functor.LaxMonoidal.Îµ e.functor)","decl":"@[reassoc]\nlemma counitIso_inv_app_comp_functor_map_Î·_inverse :\n    e.counitIso.inv.app (ğŸ™_ D) â‰« e.functor.map (Î· e.inverse) = Îµ e.functor := by\n  rw [â† cancel_epi (Î· e.functor), Monoidal.Î·_Îµ, â† functor_map_Îµ_inverse_comp_counitIso_hom_app,\n    Category.assoc, Iso.hom_inv_id_app_assoc, Monoidal.map_Îµ_Î·]\n\n"}
{"name":"CategoryTheory.Equivalence.counitIso_inv_app_comp_functor_map_Î·_inverse_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninstâœÂ² : e.functor.Monoidal\ninstâœÂ¹ : e.inverse.Monoidal\ninstâœ : e.IsMonoidal\nZ : D\nh : Quiver.Hom (e.functor.obj CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.counitIso.inv.app CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.Functor.OplaxMonoidal.Î· e.inverse)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Îµ e.functor) h)","decl":"@[reassoc]\nlemma counitIso_inv_app_comp_functor_map_Î·_inverse :\n    e.counitIso.inv.app (ğŸ™_ D) â‰« e.functor.map (Î· e.inverse) = Îµ e.functor := by\n  rw [â† cancel_epi (Î· e.functor), Monoidal.Î·_Îµ, â† functor_map_Îµ_inverse_comp_counitIso_hom_app,\n    Category.assoc, Iso.hom_inv_id_app_assoc, Monoidal.map_Îµ_Î·]\n\n"}
{"name":"CategoryTheory.Equivalence.counitIso_inv_app_tensor_comp_functor_map_Î´_inverse","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninstâœÂ² : e.functor.Monoidal\ninstâœÂ¹ : e.inverse.Monoidal\ninstâœ : e.IsMonoidal\nX Y : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.counitIso.inv.app (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.functor.obj X) (e.functor.obj Y))) (e.functor.map (CategoryTheory.Functor.OplaxMonoidal.Î´ e.inverse (e.functor.obj X) (e.functor.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ e.functor X Y) (e.functor.map (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.unitIso.hom.app X) (e.unitIso.hom.app Y))))","decl":"@[reassoc]\nlemma counitIso_inv_app_tensor_comp_functor_map_Î´_inverse (X Y : C) :\n    e.counitIso.inv.app (e.functor.obj X âŠ— e.functor.obj Y) â‰«\n      e.functor.map (Î´ e.inverse (e.functor.obj X) (e.functor.obj Y)) =\n      Î¼ e.functor X Y â‰« e.functor.map (e.unitIso.hom.app X âŠ— e.unitIso.hom.app Y) := by\n  rw [â† cancel_epi (Î´ e.functor _ _), Monoidal.Î´_Î¼_assoc]\n  apply e.inverse.map_injective\n  simp [â† cancel_epi (e.unitIso.hom.app (X âŠ— Y)), Functor.map_comp,\n    unitIso_hom_app_tensor_comp_inverse_map_Î´_functor_assoc]\n\n"}
{"name":"CategoryTheory.Equivalence.counitIso_inv_app_tensor_comp_functor_map_Î´_inverse_assoc","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninstâœÂ² : e.functor.Monoidal\ninstâœÂ¹ : e.inverse.Monoidal\ninstâœ : e.IsMonoidal\nX Y : C\nZ : D\nh : Quiver.Hom (e.functor.obj (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.inverse.obj (e.functor.obj X)) (e.inverse.obj (e.functor.obj Y)))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.counitIso.inv.app (CategoryTheory.MonoidalCategoryStruct.tensorObj (e.functor.obj X) (e.functor.obj Y))) (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.Functor.OplaxMonoidal.Î´ e.inverse (e.functor.obj X) (e.functor.obj Y))) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.Î¼ e.functor X Y) (CategoryTheory.CategoryStruct.comp (e.functor.map (CategoryTheory.MonoidalCategoryStruct.tensorHom (e.unitIso.hom.app X) (e.unitIso.hom.app Y))) h))","decl":"@[reassoc]\nlemma counitIso_inv_app_tensor_comp_functor_map_Î´_inverse (X Y : C) :\n    e.counitIso.inv.app (e.functor.obj X âŠ— e.functor.obj Y) â‰«\n      e.functor.map (Î´ e.inverse (e.functor.obj X) (e.functor.obj Y)) =\n      Î¼ e.functor X Y â‰« e.functor.map (e.unitIso.hom.app X âŠ— e.unitIso.hom.app Y) := by\n  rw [â† cancel_epi (Î´ e.functor _ _), Monoidal.Î´_Î¼_assoc]\n  apply e.inverse.map_injective\n  simp [â† cancel_epi (e.unitIso.hom.app (X âŠ— Y)), Functor.map_comp,\n    unitIso_hom_app_tensor_comp_inverse_map_Î´_functor_assoc]\n\n"}
{"name":"CategoryTheory.Equivalence.isMonoidal_refl","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nâŠ¢ CategoryTheory.Equivalence.refl.IsMonoidal","decl":"/-- The obvious auto-equivalence of a monoidal category is monoidal. -/\ninstance isMonoidal_refl : (Equivalence.refl (C := C)).IsMonoidal :=\n  inferInstanceAs (Adjunction.id (C := C)).IsMonoidal\n\n"}
{"name":"CategoryTheory.Equivalence.isMonoidal_symm","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâµ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\ne : CategoryTheory.Equivalence C D\ninstâœÂ² : e.functor.Monoidal\ninstâœÂ¹ : e.inverse.Monoidal\ninstâœ : e.IsMonoidal\nâŠ¢ e.symm.IsMonoidal","decl":"/-- The inverse of a monoidal category equivalence is also a monoidal category equivalence. -/\ninstance isMonoidal_symm [e.inverse.Monoidal] [e.IsMonoidal] :\n    e.symm.IsMonoidal where\n  leftAdjoint_Îµ := by\n    simp only [toAdjunction, Adjunction.homEquiv_unit]\n    dsimp [symm]\n    rw [counitIso_inv_app_comp_functor_map_Î·_inverse]\n  leftAdjoint_Î¼ X Y := by\n    simp only [toAdjunction, Adjunction.homEquiv_unit]\n    dsimp [symm]\n    rw [map_comp, counitIso_inv_app_tensor_comp_functor_map_Î´_inverse_assoc,\n      â† Functor.map_comp, â† tensor_comp, Iso.hom_inv_id_app, Iso.hom_inv_id_app]\n    dsimp\n    rw [tensorHom_id, id_whiskerRight, map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Equivalence.isMonoidal_trans","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ¹â° : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ¹ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœâ¸ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ· : CategoryTheory.MonoidalCategory D\nE : Type uâ‚ƒ\ninstâœâ¶ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœâµ : CategoryTheory.MonoidalCategory E\ne : CategoryTheory.Equivalence C D\ninstâœâ´ : e.functor.Monoidal\ninstâœÂ³ : e.inverse.Monoidal\ne' : CategoryTheory.Equivalence D E\ninstâœÂ² : e'.functor.Monoidal\ninstâœÂ¹ : e'.inverse.Monoidal\ninstâœ : e'.IsMonoidal\nâŠ¢ (e.trans e').IsMonoidal","decl":"/-- The composition of two monoidal category equivalences is monoidal. -/\ninstance isMonoidal_trans [e'.functor.Monoidal] [e'.inverse.Monoidal] [e'.IsMonoidal] :\n    (e.trans e').IsMonoidal := by\n  dsimp [Equivalence.IsMonoidal]\n  rw [trans_toAdjunction]\n  infer_instance\n\n"}
{"name":"CategoryTheory.LaxMonoidalFunctor.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\ntoFunctorâœ : CategoryTheory.Functor C D\nlaxMonoidalâœ : autoParam toFunctorâœ.LaxMonoidal _autoâœ\ntoFunctor : CategoryTheory.Functor C D\nlaxMonoidal : autoParam toFunctor.LaxMonoidal _autoâœ\nâŠ¢ Eq (Eq { toFunctor := toFunctorâœ, laxMonoidal := laxMonoidalâœ } { toFunctor := toFunctor, laxMonoidal := laxMonoidal }) (And (Eq toFunctorâœ toFunctor) (HEq laxMonoidalâœ laxMonoidal))","decl":"/-- Bundled version of lax monoidal functors. This type is equipped with a category\nstructure in `CategoryTheory.Monoidal.NaturalTransformation`. -/\nstructure LaxMonoidalFunctor extends C â¥¤ D where\n  laxMonoidal : toFunctor.LaxMonoidal := by infer_instance\n\n"}
{"name":"CategoryTheory.LaxMonoidalFunctor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœâ´ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ² : CategoryTheory.MonoidalCategory D\ninstâœÂ¹ : SizeOf C\ninstâœ : SizeOf D\ntoFunctor : CategoryTheory.Functor C D\nlaxMonoidal : autoParam toFunctor.LaxMonoidal _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { toFunctor := toFunctor, laxMonoidal := laxMonoidal }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toFunctor)) (SizeOf.sizeOf laxMonoidal))","decl":"/-- Bundled version of lax monoidal functors. This type is equipped with a category\nstructure in `CategoryTheory.Monoidal.NaturalTransformation`. -/\nstructure LaxMonoidalFunctor extends C â¥¤ D where\n  laxMonoidal : toFunctor.LaxMonoidal := by infer_instance\n\n"}
{"name":"CategoryTheory.LaxMonoidalFunctor.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.MonoidalCategory D\ntoFunctorâœ : CategoryTheory.Functor C D\nlaxMonoidalâœ : autoParam toFunctorâœ.LaxMonoidal _autoâœ\ntoFunctor : CategoryTheory.Functor C D\nlaxMonoidal : autoParam toFunctor.LaxMonoidal _autoâœ\nxâœ : Eq { toFunctor := toFunctorâœ, laxMonoidal := laxMonoidalâœ } { toFunctor := toFunctor, laxMonoidal := laxMonoidal }\nâŠ¢ And (Eq toFunctorâœ toFunctor) (HEq laxMonoidalâœ laxMonoidal)","decl":"/-- Bundled version of lax monoidal functors. This type is equipped with a category\nstructure in `CategoryTheory.Monoidal.NaturalTransformation`. -/\nstructure LaxMonoidalFunctor extends C â¥¤ D where\n  laxMonoidal : toFunctor.LaxMonoidal := by infer_instance\n\n"}
{"name":"CategoryTheory.LaxMonoidalFunctor.of_toFunctor","module":"Mathlib.CategoryTheory.Monoidal.Functor","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninstâœ : F.LaxMonoidal\nâŠ¢ Eq (CategoryTheory.LaxMonoidalFunctor.of F).toFunctor F","decl":"/-- Constructor for `LaxMonoidalFunctor C D`. -/\n@[simps toFunctor]\ndef of (F : C â¥¤ D) [F.LaxMonoidal] : LaxMonoidalFunctor C D where\n  toFunctor := F\n\n"}
