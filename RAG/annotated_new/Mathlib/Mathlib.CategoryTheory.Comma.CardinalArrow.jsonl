{"name":"CategoryTheory.Arrow.finite_iff","module":"Mathlib.CategoryTheory.Comma.CardinalArrow","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.SmallCategory C\n‚ä¢ Iff (Finite (CategoryTheory.Arrow C)) (Nonempty (CategoryTheory.FinCategory C))","decl":"lemma Arrow.finite_iff (C : Type u) [SmallCategory C] :\n    Finite (Arrow C) ‚Üî Nonempty (FinCategory C) := by\n  constructor\n  ¬∑ intro\n    refine ‚ü®?_, fun a b ‚Ü¶ ?_‚ü©\n    ¬∑ have := Finite.of_injective (fun (a : C) ‚Ü¶ Arrow.mk (ùüô a))\n        (fun _ _  ‚Ü¶ congr_arg Comma.left)\n      apply Fintype.ofFinite\n    ¬∑ have := Finite.of_injective (fun (f : a ‚ü∂ b) ‚Ü¶ Arrow.mk f)\n        (fun f g h ‚Ü¶ by\n          change (Arrow.mk f).hom = (Arrow.mk g).hom\n          congr)\n      apply Fintype.ofFinite\n  ¬∑ rintro ‚ü®_‚ü©\n    have := Fintype.ofEquiv  _ (Arrow.equivSigma C).symm\n    infer_instance\n\n"}
{"name":"CategoryTheory.Arrow.finite","module":"Mathlib.CategoryTheory.Comma.CardinalArrow","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.SmallCategory C\ninst‚úù : CategoryTheory.FinCategory C\n‚ä¢ Finite (CategoryTheory.Arrow C)","decl":"instance Arrow.finite {C : Type u} [SmallCategory C] [FinCategory C] :\n    Finite (Arrow C) := by\n  rw [Arrow.finite_iff]\n  exact ‚ü®inferInstance‚ü©\n\n"}
{"name":"CategoryTheory.hasCardinalLT_arrow_op_iff","module":"Mathlib.CategoryTheory.Comma.CardinalArrow","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ∫ : Cardinal.{w}\n‚ä¢ Iff (HasCardinalLT (CategoryTheory.Arrow (Opposite C)) Œ∫) (HasCardinalLT (CategoryTheory.Arrow C) Œ∫)","decl":"@[simp]\nlemma hasCardinalLT_arrow_op_iff (C : Type u) [Category.{v} C] (Œ∫ : Cardinal.{w}) :\n    HasCardinalLT (Arrow C·µí·µñ) Œ∫ ‚Üî HasCardinalLT (Arrow C) Œ∫ :=\n  hasCardinalLT_iff_of_equiv (Arrow.opEquiv C) Œ∫\n\n"}
{"name":"CategoryTheory.hasCardinalLT_arrow_discrete_iff","module":"Mathlib.CategoryTheory.Comma.CardinalArrow","initialProofState":"X : Type u\nŒ∫ : Cardinal.{w}\n‚ä¢ Iff (HasCardinalLT (CategoryTheory.Arrow (CategoryTheory.Discrete X)) Œ∫) (HasCardinalLT X Œ∫)","decl":"@[simp]\nlemma hasCardinalLT_arrow_discrete_iff {X : Type u} (Œ∫ : Cardinal.{w}) :\n    HasCardinalLT (Arrow (Discrete X)) Œ∫ ‚Üî HasCardinalLT X Œ∫ :=\n  hasCardinalLT_iff_of_equiv (Arrow.discreteEquiv X) Œ∫\n\n"}
{"name":"CategoryTheory.small_of_small_arrow","module":"Mathlib.CategoryTheory.Comma.CardinalArrow","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : Small.{w, max u v} (CategoryTheory.Arrow C)\n‚ä¢ Small.{w, u} C","decl":"lemma small_of_small_arrow (C : Type u) [Category.{v} C] [Small.{w} (Arrow C)] :\n    Small.{w} C :=\n  small_of_injective (f := fun X ‚Ü¶ Arrow.mk (ùüô X)) (fun _ _ h ‚Ü¶ congr_arg Comma.left h)\n\n"}
{"name":"CategoryTheory.locallySmall_of_small_arrow","module":"Mathlib.CategoryTheory.Comma.CardinalArrow","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : Small.{w, max u v} (CategoryTheory.Arrow C)\n‚ä¢ CategoryTheory.LocallySmall.{w, v, u} C","decl":"lemma locallySmall_of_small_arrow (C : Type u) [Category.{v} C] [Small.{w} (Arrow C)] :\n    LocallySmall.{w} C where\n  hom_small X Y :=\n    small_of_injective (f := fun f ‚Ü¶ Arrow.mk f) (fun f g h ‚Ü¶ by\n      change (Arrow.mk f).hom = (Arrow.mk g).hom\n      congr)\n\n"}
{"name":"CategoryTheory.hasCardinalLT_arrow_shrinkHoms_iff","module":"Mathlib.CategoryTheory.Comma.CardinalArrow","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w', v, u} C\nŒ∫ : Cardinal.{w}\n‚ä¢ Iff (HasCardinalLT (CategoryTheory.Arrow (CategoryTheory.ShrinkHoms.{u} C)) Œ∫) (HasCardinalLT (CategoryTheory.Arrow C) Œ∫)","decl":"@[simp]\nlemma hasCardinalLT_arrow_shrinkHoms_iff (C : Type u) [Category.{v} C] [LocallySmall.{w'} C]\n    (Œ∫ : Cardinal.{w}) :\n    HasCardinalLT (Arrow.{w'} (ShrinkHoms C)) Œ∫ ‚Üî HasCardinalLT (Arrow C) Œ∫ :=\n  hasCardinalLT_iff_of_equiv (Arrow.shrinkHomsEquiv C) Œ∫\n\n"}
{"name":"CategoryTheory.hasCardinalLT_arrow_shrink_iff","module":"Mathlib.CategoryTheory.Comma.CardinalArrow","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : Small.{w', u} C\nŒ∫ : Cardinal.{w}\n‚ä¢ Iff (HasCardinalLT (CategoryTheory.Arrow (Shrink.{w', u} C)) Œ∫) (HasCardinalLT (CategoryTheory.Arrow C) Œ∫)","decl":"@[simp]\nlemma hasCardinalLT_arrow_shrink_iff (C : Type u) [Category.{v} C] [Small.{w'} C]\n    (Œ∫ : Cardinal.{w}) :\n    HasCardinalLT (Arrow (Shrink.{w'} C)) Œ∫ ‚Üî HasCardinalLT (Arrow C) Œ∫ :=\n  hasCardinalLT_iff_of_equiv (Arrow.shrinkEquiv C) Œ∫\n\n"}
{"name":"CategoryTheory.hasCardinalLT_of_hasCardinalLT_arrow","module":"Mathlib.CategoryTheory.Comma.CardinalArrow","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ∫ : Cardinal.{w}\nh : HasCardinalLT (CategoryTheory.Arrow C) Œ∫\n‚ä¢ HasCardinalLT C Œ∫","decl":"lemma hasCardinalLT_of_hasCardinalLT_arrow\n    {C : Type u} [Category.{v} C] {Œ∫ : Cardinal.{w}} (h : HasCardinalLT (Arrow C) Œ∫) :\n    HasCardinalLT C Œ∫ :=\n  h.of_injective (fun X ‚Ü¶ Arrow.mk (ùüô X)) (fun _ _ h ‚Ü¶ congr_arg Comma.left h)\n\n"}
