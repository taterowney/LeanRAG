{"name":"FormalMultilinearSeries.partialSum_continuous","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹⁰ : Ring 𝕜\ninst✝⁹ : AddCommGroup E\ninst✝⁸ : AddCommGroup F\ninst✝⁷ : Module 𝕜 E\ninst✝⁶ : Module 𝕜 F\ninst✝⁵ : TopologicalSpace E\ninst✝⁴ : TopologicalSpace F\ninst✝³ : TopologicalAddGroup E\ninst✝² : TopologicalAddGroup F\ninst✝¹ : ContinuousConstSMul 𝕜 E\ninst✝ : ContinuousConstSMul 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\n⊢ Continuous (p.partialSum n)","decl":"/-- The partial sums of a formal multilinear series are continuous. -/\ntheorem partialSum_continuous (p : FormalMultilinearSeries 𝕜 E F) (n : ℕ) :\n    Continuous (p.partialSum n) := by\n  unfold partialSum -- Porting note: added\n  continuity\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_bound","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nC : Real\nr : NNReal\nh : ∀ (n : Nat), LE.le (HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)) C\n⊢ LE.le (↑r) p.radius","decl":"/-- If `‖pₙ‖ rⁿ` is bounded in `n`, then the radius of `p` is at least `r`. -/\ntheorem le_radius_of_bound (C : ℝ) {r : ℝ≥0} (h : ∀ n : ℕ, ‖p n‖ * (r : ℝ) ^ n ≤ C) :\n    (r : ℝ≥0∞) ≤ p.radius :=\n  le_iSup_of_le r <| le_iSup_of_le C <| le_iSup (fun _ => (r : ℝ≥0∞)) h\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_bound_nnreal","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nC r : NNReal\nh : ∀ (n : Nat), LE.le (HMul.hMul (NNNorm.nnnorm (p n)) (HPow.hPow r n)) C\n⊢ LE.le (↑r) p.radius","decl":"/-- If `‖pₙ‖ rⁿ` is bounded in `n`, then the radius of `p` is at least `r`. -/\ntheorem le_radius_of_bound_nnreal (C : ℝ≥0) {r : ℝ≥0} (h : ∀ n : ℕ, ‖p n‖₊ * r ^ n ≤ C) :\n    (r : ℝ≥0∞) ≤ p.radius :=\n  p.le_radius_of_bound C fun n => mod_cast h n\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_isBigO","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nh : Asymptotics.IsBigO Filter.atTop (fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)) fun x => 1\n⊢ LE.le (↑r) p.radius","decl":"/-- If `‖pₙ‖ rⁿ = O(1)`, as `n → ∞`, then the radius of `p` is at least `r`. -/\ntheorem le_radius_of_isBigO (h : (fun n => ‖p n‖ * (r : ℝ) ^ n) =O[atTop] fun _ => (1 : ℝ)) :\n    ↑r ≤ p.radius :=\n  Exists.elim (isBigO_one_nat_atTop_iff.1 h) fun C hC =>\n    p.le_radius_of_bound C fun n => (le_abs_self _).trans (hC n)\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_eventually_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nC : Real\nh : Filter.Eventually (fun n => LE.le (HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)) C) Filter.atTop\n⊢ LE.le (↑r) p.radius","decl":"theorem le_radius_of_eventually_le (C) (h : ∀ᶠ n in atTop, ‖p n‖ * (r : ℝ) ^ n ≤ C) :\n    ↑r ≤ p.radius :=\n  p.le_radius_of_isBigO <| IsBigO.of_bound C <| h.mono fun n hn => by simpa\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_summable_nnnorm","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nh : Summable fun n => HMul.hMul (NNNorm.nnnorm (p n)) (HPow.hPow r n)\n⊢ LE.le (↑r) p.radius","decl":"theorem le_radius_of_summable_nnnorm (h : Summable fun n => ‖p n‖₊ * r ^ n) : ↑r ≤ p.radius :=\n  p.le_radius_of_bound_nnreal (∑' n, ‖p n‖₊ * r ^ n) fun _ => le_tsum' h _\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_summable","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nh : Summable fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)\n⊢ LE.le (↑r) p.radius","decl":"theorem le_radius_of_summable (h : Summable fun n => ‖p n‖ * (r : ℝ) ^ n) : ↑r ≤ p.radius :=\n  p.le_radius_of_summable_nnnorm <| by\n    simp only [← coe_nnnorm] at h\n    exact mod_cast h\n\n"}
{"name":"FormalMultilinearSeries.radius_eq_top_of_forall_nnreal_isBigO","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nh : ∀ (r : NNReal), Asymptotics.IsBigO Filter.atTop (fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)) fun x => 1\n⊢ Eq p.radius Top.top","decl":"theorem radius_eq_top_of_forall_nnreal_isBigO\n    (h : ∀ r : ℝ≥0, (fun n => ‖p n‖ * (r : ℝ) ^ n) =O[atTop] fun _ => (1 : ℝ)) : p.radius = ∞ :=\n  ENNReal.eq_top_of_forall_nnreal_le fun r => p.le_radius_of_isBigO (h r)\n\n"}
{"name":"FormalMultilinearSeries.radius_eq_top_of_eventually_eq_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nh : Filter.Eventually (fun n => Eq (p n) 0) Filter.atTop\n⊢ Eq p.radius Top.top","decl":"theorem radius_eq_top_of_eventually_eq_zero (h : ∀ᶠ n in atTop, p n = 0) : p.radius = ∞ :=\n  p.radius_eq_top_of_forall_nnreal_isBigO fun r =>\n    (isBigO_zero _ _).congr' (h.mono fun n hn => by simp [hn]) EventuallyEq.rfl\n\n"}
{"name":"FormalMultilinearSeries.radius_eq_top_of_forall_image_add_eq_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nn : Nat\nhn : ∀ (m : Nat), Eq (p (HAdd.hAdd m n)) 0\n⊢ Eq p.radius Top.top","decl":"theorem radius_eq_top_of_forall_image_add_eq_zero (n : ℕ) (hn : ∀ m, p (m + n) = 0) :\n    p.radius = ∞ :=\n  p.radius_eq_top_of_eventually_eq_zero <|\n    mem_atTop_sets.2 ⟨n, fun _ hk => tsub_add_cancel_of_le hk ▸ hn _⟩\n\n"}
{"name":"FormalMultilinearSeries.constFormalMultilinearSeries_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nv : F\n⊢ Eq (constFormalMultilinearSeries 𝕜 E v).radius Top.top","decl":"@[simp]\ntheorem constFormalMultilinearSeries_radius {v : F} :\n    (constFormalMultilinearSeries 𝕜 E v).radius = ⊤ :=\n  (constFormalMultilinearSeries 𝕜 E v).radius_eq_top_of_forall_image_add_eq_zero 1\n    (by simp [constFormalMultilinearSeries])\n\n"}
{"name":"FormalMultilinearSeries.zero_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\n⊢ Eq (FormalMultilinearSeries.radius 0) Top.top","decl":"/-- `0` has infinite radius of convergence -/\n@[simp] lemma zero_radius : (0 : FormalMultilinearSeries 𝕜 E F).radius = ∞ := by\n  rw [← constFormalMultilinearSeries_zero]\n  exact constFormalMultilinearSeries_radius\n\n"}
{"name":"FormalMultilinearSeries.isLittleO_of_lt_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nh : LT.lt (↑r) p.radius\n⊢ Exists fun a => And (Membership.mem (Set.Ioo 0 1) a) (Asymptotics.IsLittleO Filter.atTop (fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)) fun x => HPow.hPow a x)","decl":"/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` tends to zero exponentially:\nfor some `0 < a < 1`, `‖p n‖ rⁿ = o(aⁿ)`. -/\ntheorem isLittleO_of_lt_radius (h : ↑r < p.radius) :\n    ∃ a ∈ Ioo (0 : ℝ) 1, (fun n => ‖p n‖ * (r : ℝ) ^ n) =o[atTop] (a ^ ·) := by\n  have := (TFAE_exists_lt_isLittleO_pow (fun n => ‖p n‖ * (r : ℝ) ^ n) 1).out 1 4\n  rw [this]\n  -- Porting note: was\n  -- rw [(TFAE_exists_lt_isLittleO_pow (fun n => ‖p n‖ * (r : ℝ) ^ n) 1).out 1 4]\n  simp only [radius, lt_iSup_iff] at h\n  rcases h with ⟨t, C, hC, rt⟩\n  rw [ENNReal.coe_lt_coe, ← NNReal.coe_lt_coe] at rt\n  have : 0 < (t : ℝ) := r.coe_nonneg.trans_lt rt\n  rw [← div_lt_one this] at rt\n  refine ⟨_, rt, C, Or.inr zero_lt_one, fun n => ?_⟩\n  calc\n    |‖p n‖ * (r : ℝ) ^ n| = ‖p n‖ * (t : ℝ) ^ n * (r / t : ℝ) ^ n := by\n      field_simp [mul_right_comm, abs_mul]\n    _ ≤ C * (r / t : ℝ) ^ n := by gcongr; apply hC\n\n"}
{"name":"FormalMultilinearSeries.isLittleO_one_of_lt_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nh : LT.lt (↑r) p.radius\n⊢ Asymptotics.IsLittleO Filter.atTop (fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)) fun x => 1","decl":"/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ = o(1)`. -/\ntheorem isLittleO_one_of_lt_radius (h : ↑r < p.radius) :\n    (fun n => ‖p n‖ * (r : ℝ) ^ n) =o[atTop] (fun _ => 1 : ℕ → ℝ) :=\n  let ⟨_, ha, hp⟩ := p.isLittleO_of_lt_radius h\n  hp.trans <| (isLittleO_pow_pow_of_lt_left ha.1.le ha.2).congr (fun _ => rfl) one_pow\n\n"}
{"name":"FormalMultilinearSeries.norm_mul_pow_le_mul_pow_of_lt_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nh : LT.lt (↑r) p.radius\n⊢ Exists fun a => And (Membership.mem (Set.Ioo 0 1) a) (Exists fun C => And (GT.gt C 0) (∀ (n : Nat), LE.le (HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)) (HMul.hMul C (HPow.hPow a n))))","decl":"/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` tends to zero exponentially:\nfor some `0 < a < 1` and `C > 0`, `‖p n‖ * r ^ n ≤ C * a ^ n`. -/\ntheorem norm_mul_pow_le_mul_pow_of_lt_radius (h : ↑r < p.radius) :\n    ∃ a ∈ Ioo (0 : ℝ) 1, ∃ C > 0, ∀ n, ‖p n‖ * (r : ℝ) ^ n ≤ C * a ^ n := by\n  -- Porting note: moved out of `rcases`\n  have := ((TFAE_exists_lt_isLittleO_pow (fun n => ‖p n‖ * (r : ℝ) ^ n) 1).out 1 5).mp\n    (p.isLittleO_of_lt_radius h)\n  rcases this with ⟨a, ha, C, hC, H⟩\n  exact ⟨a, ha, C, hC, fun n => (le_abs_self _).trans (H n)⟩\n\n"}
{"name":"FormalMultilinearSeries.lt_radius_of_isBigO","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nh₀ : Ne r 0\na : Real\nha : Membership.mem (Set.Ioo (-1) 1) a\nhp : Asymptotics.IsBigO Filter.atTop (fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)) fun x => HPow.hPow a x\n⊢ LT.lt (↑r) p.radius","decl":"/-- If `r ≠ 0` and `‖pₙ‖ rⁿ = O(aⁿ)` for some `-1 < a < 1`, then `r < p.radius`. -/\ntheorem lt_radius_of_isBigO (h₀ : r ≠ 0) {a : ℝ} (ha : a ∈ Ioo (-1 : ℝ) 1)\n    (hp : (fun n => ‖p n‖ * (r : ℝ) ^ n) =O[atTop] (a ^ ·)) : ↑r < p.radius := by\n  -- Porting note: moved out of `rcases`\n  have := ((TFAE_exists_lt_isLittleO_pow (fun n => ‖p n‖ * (r : ℝ) ^ n) 1).out 2 5)\n  rcases this.mp ⟨a, ha, hp⟩ with ⟨a, ha, C, hC, hp⟩\n  rw [← pos_iff_ne_zero, ← NNReal.coe_pos] at h₀\n  lift a to ℝ≥0 using ha.1.le\n  have : (r : ℝ) < r / a := by\n    simpa only [div_one] using (div_lt_div_iff_of_pos_left h₀ zero_lt_one ha.1).2 ha.2\n  norm_cast at this\n  rw [← ENNReal.coe_lt_coe] at this\n  refine this.trans_le (p.le_radius_of_bound C fun n => ?_)\n  rw [NNReal.coe_div, div_pow, ← mul_div_assoc, div_le_iff₀ (pow_pos ha.1 n)]\n  exact (le_abs_self _).trans (hp n)\n\n"}
{"name":"FormalMultilinearSeries.norm_mul_pow_le_of_lt_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nh : LT.lt (↑r) p.radius\n⊢ Exists fun C => And (GT.gt C 0) (∀ (n : Nat), LE.le (HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)) C)","decl":"/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` is bounded. -/\ntheorem norm_mul_pow_le_of_lt_radius (p : FormalMultilinearSeries 𝕜 E F) {r : ℝ≥0}\n    (h : (r : ℝ≥0∞) < p.radius) : ∃ C > 0, ∀ n, ‖p n‖ * (r : ℝ) ^ n ≤ C :=\n  let ⟨_, ha, C, hC, h⟩ := p.norm_mul_pow_le_mul_pow_of_lt_radius h\n  ⟨C, hC, fun n => (h n).trans <| mul_le_of_le_one_right hC.lt.le (pow_le_one₀ ha.1.le ha.2.le)⟩\n\n"}
{"name":"FormalMultilinearSeries.norm_le_div_pow_of_pos_of_lt_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nh0 : LT.lt 0 r\nh : LT.lt (↑r) p.radius\n⊢ Exists fun C => And (GT.gt C 0) (∀ (n : Nat), LE.le (Norm.norm (p n)) (HDiv.hDiv C (HPow.hPow (↑r) n)))","decl":"/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` is bounded. -/\ntheorem norm_le_div_pow_of_pos_of_lt_radius (p : FormalMultilinearSeries 𝕜 E F) {r : ℝ≥0}\n    (h0 : 0 < r) (h : (r : ℝ≥0∞) < p.radius) : ∃ C > 0, ∀ n, ‖p n‖ ≤ C / (r : ℝ) ^ n :=\n  let ⟨C, hC, hp⟩ := p.norm_mul_pow_le_of_lt_radius h\n  ⟨C, hC, fun n => Iff.mpr (le_div_iff₀ (pow_pos h0 _)) (hp n)⟩\n\n"}
{"name":"FormalMultilinearSeries.nnnorm_mul_pow_le_of_lt_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nh : LT.lt (↑r) p.radius\n⊢ Exists fun C => And (GT.gt C 0) (∀ (n : Nat), LE.le (HMul.hMul (NNNorm.nnnorm (p n)) (HPow.hPow r n)) C)","decl":"/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` is bounded. -/\ntheorem nnnorm_mul_pow_le_of_lt_radius (p : FormalMultilinearSeries 𝕜 E F) {r : ℝ≥0}\n    (h : (r : ℝ≥0∞) < p.radius) : ∃ C > 0, ∀ n, ‖p n‖₊ * r ^ n ≤ C :=\n  let ⟨C, hC, hp⟩ := p.norm_mul_pow_le_of_lt_radius h\n  ⟨⟨C, hC.lt.le⟩, hC, mod_cast hp⟩\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_tendsto","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nr : NNReal\np : FormalMultilinearSeries 𝕜 E F\nl : Real\nh : Filter.Tendsto (fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)) Filter.atTop (nhds l)\n⊢ LE.le (↑r) p.radius","decl":"theorem le_radius_of_tendsto (p : FormalMultilinearSeries 𝕜 E F) {l : ℝ}\n    (h : Tendsto (fun n => ‖p n‖ * (r : ℝ) ^ n) atTop (𝓝 l)) : ↑r ≤ p.radius :=\n  p.le_radius_of_isBigO (h.isBigO_one _)\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_summable_norm","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nr : NNReal\np : FormalMultilinearSeries 𝕜 E F\nhs : Summable fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)\n⊢ LE.le (↑r) p.radius","decl":"theorem le_radius_of_summable_norm (p : FormalMultilinearSeries 𝕜 E F)\n    (hs : Summable fun n => ‖p n‖ * (r : ℝ) ^ n) : ↑r ≤ p.radius :=\n  p.le_radius_of_tendsto hs.tendsto_atTop_zero\n\n"}
{"name":"FormalMultilinearSeries.not_summable_norm_of_radius_lt_nnnorm","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nh : LT.lt p.radius ↑(NNNorm.nnnorm x)\n⊢ Not (Summable fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (Norm.norm x) n))","decl":"theorem not_summable_norm_of_radius_lt_nnnorm (p : FormalMultilinearSeries 𝕜 E F) {x : E}\n    (h : p.radius < ‖x‖₊) : ¬Summable fun n => ‖p n‖ * ‖x‖ ^ n :=\n  fun hs => not_le_of_lt h (p.le_radius_of_summable_norm hs)\n\n"}
{"name":"FormalMultilinearSeries.summable_norm_mul_pow","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nh : LT.lt (↑r) p.radius\n⊢ Summable fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)","decl":"theorem summable_norm_mul_pow (p : FormalMultilinearSeries 𝕜 E F) {r : ℝ≥0} (h : ↑r < p.radius) :\n    Summable fun n : ℕ => ‖p n‖ * (r : ℝ) ^ n := by\n  obtain ⟨a, ha : a ∈ Ioo (0 : ℝ) 1, C, - : 0 < C, hp⟩ := p.norm_mul_pow_le_mul_pow_of_lt_radius h\n  exact .of_nonneg_of_le (fun n => mul_nonneg (norm_nonneg _) (pow_nonneg r.coe_nonneg _))\n    hp ((summable_geometric_of_lt_one ha.1.le ha.2).mul_left _)\n\n"}
{"name":"FormalMultilinearSeries.summable_norm_apply","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhx : Membership.mem (EMetric.ball 0 p.radius) x\n⊢ Summable fun n => Norm.norm ((p n) fun x_1 => x)","decl":"theorem summable_norm_apply (p : FormalMultilinearSeries 𝕜 E F) {x : E}\n    (hx : x ∈ EMetric.ball (0 : E) p.radius) : Summable fun n : ℕ => ‖p n fun _ => x‖ := by\n  rw [mem_emetric_ball_zero_iff] at hx\n  refine .of_nonneg_of_le\n    (fun _ ↦ norm_nonneg _) (fun n ↦ ((p n).le_opNorm _).trans_eq ?_) (p.summable_norm_mul_pow hx)\n  simp\n\n"}
{"name":"FormalMultilinearSeries.summable_nnnorm_mul_pow","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nr : NNReal\nh : LT.lt (↑r) p.radius\n⊢ Summable fun n => HMul.hMul (NNNorm.nnnorm (p n)) (HPow.hPow r n)","decl":"theorem summable_nnnorm_mul_pow (p : FormalMultilinearSeries 𝕜 E F) {r : ℝ≥0} (h : ↑r < p.radius) :\n    Summable fun n : ℕ => ‖p n‖₊ * r ^ n := by\n  rw [← NNReal.summable_coe]\n  push_cast\n  exact p.summable_norm_mul_pow h\n\n"}
{"name":"FormalMultilinearSeries.summable","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhx : Membership.mem (EMetric.ball 0 p.radius) x\n⊢ Summable fun n => (p n) fun x_1 => x","decl":"protected theorem summable [CompleteSpace F] (p : FormalMultilinearSeries 𝕜 E F) {x : E}\n    (hx : x ∈ EMetric.ball (0 : E) p.radius) : Summable fun n : ℕ => p n fun _ => x :=\n  (p.summable_norm_apply hx).of_norm\n\n"}
{"name":"FormalMultilinearSeries.radius_eq_top_of_summable_norm","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nhs : ∀ (r : NNReal), Summable fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n)\n⊢ Eq p.radius Top.top","decl":"theorem radius_eq_top_of_summable_norm (p : FormalMultilinearSeries 𝕜 E F)\n    (hs : ∀ r : ℝ≥0, Summable fun n => ‖p n‖ * (r : ℝ) ^ n) : p.radius = ∞ :=\n  ENNReal.eq_top_of_forall_nnreal_le fun r => p.le_radius_of_summable_norm (hs r)\n\n"}
{"name":"FormalMultilinearSeries.radius_eq_top_iff_summable_norm","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\n⊢ Iff (Eq p.radius Top.top) (∀ (r : NNReal), Summable fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (↑r) n))","decl":"theorem radius_eq_top_iff_summable_norm (p : FormalMultilinearSeries 𝕜 E F) :\n    p.radius = ∞ ↔ ∀ r : ℝ≥0, Summable fun n => ‖p n‖ * (r : ℝ) ^ n := by\n  constructor\n  · intro h r\n    obtain ⟨a, ha : a ∈ Ioo (0 : ℝ) 1, C, - : 0 < C, hp⟩ := p.norm_mul_pow_le_mul_pow_of_lt_radius\n      (show (r : ℝ≥0∞) < p.radius from h.symm ▸ ENNReal.coe_lt_top)\n    refine .of_norm_bounded\n      (fun n ↦ (C : ℝ) * a ^ n) ((summable_geometric_of_lt_one ha.1.le ha.2).mul_left _) fun n ↦ ?_\n    specialize hp n\n    rwa [Real.norm_of_nonneg (mul_nonneg (norm_nonneg _) (pow_nonneg r.coe_nonneg n))]\n  · exact p.radius_eq_top_of_summable_norm\n\n"}
{"name":"FormalMultilinearSeries.le_mul_pow_of_radius_pos","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nh : LT.lt 0 p.radius\n⊢ Exists fun C => Exists fun r => Exists fun x => Exists fun x => ∀ (n : Nat), LE.le (Norm.norm (p n)) (HMul.hMul C (HPow.hPow r n))","decl":"/-- If the radius of `p` is positive, then `‖pₙ‖` grows at most geometrically. -/\ntheorem le_mul_pow_of_radius_pos (p : FormalMultilinearSeries 𝕜 E F) (h : 0 < p.radius) :\n    ∃ (C r : _) (_ : 0 < C) (_ : 0 < r), ∀ n, ‖p n‖ ≤ C * r ^ n := by\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 h with ⟨r, r0, rlt⟩\n  have rpos : 0 < (r : ℝ) := by simp [ENNReal.coe_pos.1 r0]\n  rcases norm_le_div_pow_of_pos_of_lt_radius p rpos rlt with ⟨C, Cpos, hCp⟩\n  refine ⟨C, r⁻¹, Cpos, by simp only [inv_pos, rpos], fun n => ?_⟩\n  -- Porting note: was `convert`\n  rw [inv_pow, ← div_eq_mul_inv]\n  exact hCp n\n\n"}
{"name":"FormalMultilinearSeries.radius_le_of_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedAddCommGroup F\ninst✝⁵ : NormedSpace 𝕜 F\n𝕜' : Type u_5\nE' : Type u_6\nF' : Type u_7\ninst✝⁴ : NontriviallyNormedField 𝕜'\ninst✝³ : NormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜' E'\ninst✝¹ : NormedAddCommGroup F'\ninst✝ : NormedSpace 𝕜' F'\np : FormalMultilinearSeries 𝕜 E F\nq : FormalMultilinearSeries 𝕜' E' F'\nh : ∀ (n : Nat), LE.le (Norm.norm (p n)) (Norm.norm (q n))\n⊢ LE.le q.radius p.radius","decl":"lemma radius_le_of_le {𝕜' E' F' : Type*}\n    [NontriviallyNormedField 𝕜'] [NormedAddCommGroup E'] [NormedSpace 𝕜' E']\n    [NormedAddCommGroup F'] [NormedSpace 𝕜' F']\n    {p : FormalMultilinearSeries 𝕜 E F} {q : FormalMultilinearSeries 𝕜' E' F'}\n    (h : ∀ n, ‖p n‖ ≤ ‖q n‖) : q.radius ≤ p.radius := by\n  apply le_of_forall_nnreal_lt (fun r hr ↦ ?_)\n  rcases norm_mul_pow_le_of_lt_radius _ hr with ⟨C, -, hC⟩\n  apply le_radius_of_bound _ C (fun n ↦ ?_)\n  apply le_trans _ (hC n)\n  gcongr\n  exact h n\n\n"}
{"name":"FormalMultilinearSeries.min_radius_le_radius_add","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np q : FormalMultilinearSeries 𝕜 E F\n⊢ LE.le (Min.min p.radius q.radius) (HAdd.hAdd p q).radius","decl":"/-- The radius of the sum of two formal series is at least the minimum of their two radii. -/\ntheorem min_radius_le_radius_add (p q : FormalMultilinearSeries 𝕜 E F) :\n    min p.radius q.radius ≤ (p + q).radius := by\n  refine ENNReal.le_of_forall_nnreal_lt fun r hr => ?_\n  rw [lt_min_iff] at hr\n  have := ((p.isLittleO_one_of_lt_radius hr.1).add (q.isLittleO_one_of_lt_radius hr.2)).isBigO\n  refine (p + q).le_radius_of_isBigO ((isBigO_of_le _ fun n => ?_).trans this)\n  rw [← add_mul, norm_mul, norm_mul, norm_norm]\n  exact mul_le_mul_of_nonneg_right ((norm_add_le _ _).trans (le_abs_self _)) (norm_nonneg _)\n\n"}
{"name":"FormalMultilinearSeries.radius_neg","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\n⊢ Eq (Neg.neg p).radius p.radius","decl":"@[simp]\ntheorem radius_neg (p : FormalMultilinearSeries 𝕜 E F) : (-p).radius = p.radius := by\n  simp only [radius, neg_apply, norm_neg]\n\n"}
{"name":"FormalMultilinearSeries.radius_le_smul","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nc : 𝕜\n⊢ LE.le p.radius (HSMul.hSMul c p).radius","decl":"theorem radius_le_smul {p : FormalMultilinearSeries 𝕜 E F} {c : 𝕜} : p.radius ≤ (c • p).radius := by\n  simp only [radius, smul_apply]\n  refine iSup_mono fun r ↦ iSup_mono' fun C ↦ ⟨‖c‖ * C, iSup_mono' fun h ↦ ?_⟩\n  simp only [le_refl, exists_prop, and_true]\n  intro n\n  rw [norm_smul c (p n), mul_assoc]\n  gcongr\n  exact h n\n\n"}
{"name":"FormalMultilinearSeries.radius_smul_eq","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\nc : 𝕜\nhc : Ne c 0\n⊢ Eq (HSMul.hSMul c p).radius p.radius","decl":"theorem radius_smul_eq (p : FormalMultilinearSeries 𝕜 E F) {c : 𝕜}\n    (hc : c ≠ 0) : (c • p).radius = p.radius := by\n  apply eq_of_le_of_le _ radius_le_smul\n  conv => rhs; rw [show p = c⁻¹ • (c • p) by simp [smul_smul, inv_mul_cancel₀ hc]]\n  apply radius_le_smul\n\n"}
{"name":"FormalMultilinearSeries.radius_shift","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\n⊢ Eq p.shift.radius p.radius","decl":"@[simp]\ntheorem radius_shift (p : FormalMultilinearSeries 𝕜 E F) : p.shift.radius = p.radius := by\n  simp only [radius, shift, Nat.succ_eq_add_one, ContinuousMultilinearMap.curryRight_norm]\n  congr\n  ext r\n  apply eq_of_le_of_le\n  · apply iSup_mono'\n    intro C\n    use ‖p 0‖ ⊔ (C * r)\n    apply iSup_mono'\n    intro h\n    simp only [le_refl, le_sup_iff, exists_prop, and_true]\n    intro n\n    cases' n with m\n    · simp\n    right\n    rw [pow_succ, ← mul_assoc]\n    apply mul_le_mul_of_nonneg_right (h m) zero_le_coe\n  · apply iSup_mono'\n    intro C\n    use ‖p 1‖ ⊔ C / r\n    apply iSup_mono'\n    intro h\n    simp only [le_refl, le_sup_iff, exists_prop, and_true]\n    intro n\n    cases eq_zero_or_pos r with\n    | inl hr =>\n      rw [hr]\n      cases n <;> simp\n    | inr hr =>\n      right\n      rw [← NNReal.coe_pos] at hr\n      specialize h (n + 1)\n      rw [le_div_iff₀ hr]\n      rwa [pow_succ, ← mul_assoc] at h\n\n"}
{"name":"FormalMultilinearSeries.radius_unshift","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E (ContinuousLinearMap (RingHom.id 𝕜) E F)\nz : F\n⊢ Eq (p.unshift z).radius p.radius","decl":"@[simp]\ntheorem radius_unshift (p : FormalMultilinearSeries 𝕜 E (E →L[𝕜] F)) (z : F) :\n    (p.unshift z).radius = p.radius := by\n  rw [← radius_shift, unshift_shift]\n\n"}
{"name":"FormalMultilinearSeries.hasSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhx : Membership.mem (EMetric.ball 0 p.radius) x\n⊢ HasSum (fun n => (p n) fun x_1 => x) (p.sum x)","decl":"protected theorem hasSum [CompleteSpace F] (p : FormalMultilinearSeries 𝕜 E F) {x : E}\n    (hx : x ∈ EMetric.ball (0 : E) p.radius) : HasSum (fun n : ℕ => p n fun _ => x) (p.sum x) :=\n  (p.summable hx).hasSum\n\n"}
{"name":"FormalMultilinearSeries.radius_le_radius_continuousLinearMap_comp","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\np : FormalMultilinearSeries 𝕜 E F\nf : ContinuousLinearMap (RingHom.id 𝕜) F G\n⊢ LE.le p.radius (f.compFormalMultilinearSeries p).radius","decl":"theorem radius_le_radius_continuousLinearMap_comp (p : FormalMultilinearSeries 𝕜 E F)\n    (f : F →L[𝕜] G) : p.radius ≤ (f.compFormalMultilinearSeries p).radius := by\n  refine ENNReal.le_of_forall_nnreal_lt fun r hr => ?_\n  apply le_radius_of_isBigO\n  apply (IsBigO.trans_isLittleO _ (p.isLittleO_one_of_lt_radius hr)).isBigO\n  refine IsBigO.mul (@IsBigOWith.isBigO _ _ _ _ _ ‖f‖ _ _ _ ?_) (isBigO_refl _ _)\n  refine IsBigOWith.of_bound (Eventually.of_forall fun n => ?_)\n  simpa only [norm_norm] using f.norm_compContinuousMultilinearMap_le (p n)\n\n"}
{"name":"HasFPowerSeriesOnBall.r_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nself : HasFPowerSeriesOnBall f p x r\n⊢ LE.le r p.radius","decl":"/-- Given a function `f : E → F` and a formal multilinear series `p`, we say that `f` has `p` as\na power series on the ball of radius `r > 0` around `x` if `f (x + y) = ∑' pₙ yⁿ` for all `‖y‖ < r`.\n-/\nstructure HasFPowerSeriesOnBall (f : E → F) (p : FormalMultilinearSeries 𝕜 E F) (x : E) (r : ℝ≥0∞) :\n    Prop where\n  r_le : r ≤ p.radius\n  r_pos : 0 < r\n  hasSum :\n    ∀ {y}, y ∈ EMetric.ball (0 : E) r → HasSum (fun n : ℕ => p n fun _ : Fin n => y) (f (x + y))\n\n"}
{"name":"HasFPowerSeriesOnBall.r_pos","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nself : HasFPowerSeriesOnBall f p x r\n⊢ LT.lt 0 r","decl":"/-- Given a function `f : E → F` and a formal multilinear series `p`, we say that `f` has `p` as\na power series on the ball of radius `r > 0` around `x` if `f (x + y) = ∑' pₙ yⁿ` for all `‖y‖ < r`.\n-/\nstructure HasFPowerSeriesOnBall (f : E → F) (p : FormalMultilinearSeries 𝕜 E F) (x : E) (r : ℝ≥0∞) :\n    Prop where\n  r_le : r ≤ p.radius\n  r_pos : 0 < r\n  hasSum :\n    ∀ {y}, y ∈ EMetric.ball (0 : E) r → HasSum (fun n : ℕ => p n fun _ : Fin n => y) (f (x + y))\n\n"}
{"name":"HasFPowerSeriesOnBall.hasSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nself : HasFPowerSeriesOnBall f p x r\ny : E\na✝ : Membership.mem (EMetric.ball 0 r) y\n⊢ HasSum (fun n => (p n) fun x => y) (f (HAdd.hAdd x y))","decl":"/-- Given a function `f : E → F` and a formal multilinear series `p`, we say that `f` has `p` as\na power series on the ball of radius `r > 0` around `x` if `f (x + y) = ∑' pₙ yⁿ` for all `‖y‖ < r`.\n-/\nstructure HasFPowerSeriesOnBall (f : E → F) (p : FormalMultilinearSeries 𝕜 E F) (x : E) (r : ℝ≥0∞) :\n    Prop where\n  r_le : r ≤ p.radius\n  r_pos : 0 < r\n  hasSum :\n    ∀ {y}, y ∈ EMetric.ball (0 : E) r → HasSum (fun n : ℕ => p n fun _ : Fin n => y) (f (x + y))\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.r_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nself : HasFPowerSeriesWithinOnBall f p s x r\n⊢ LE.le r p.radius","decl":"/-- Analogue of `HasFPowerSeriesOnBall` where convergence is required only on a set `s`. We also\nrequire convergence at `x` as the behavior of this notion is very bad otherwise. -/\nstructure HasFPowerSeriesWithinOnBall (f : E → F) (p : FormalMultilinearSeries 𝕜 E F) (s : Set E)\n    (x : E) (r : ℝ≥0∞) : Prop where\n  /-- `p` converges on `ball 0 r` -/\n  r_le : r ≤ p.radius\n  /-- The radius of convergence is positive -/\n  r_pos : 0 < r\n  /-- `p converges to f` within `s` -/\n  hasSum : ∀ {y}, x + y ∈ insert x s → y ∈ EMetric.ball (0 : E) r →\n    HasSum (fun n : ℕ => p n fun _ : Fin n => y) (f (x + y))\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.r_pos","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nself : HasFPowerSeriesWithinOnBall f p s x r\n⊢ LT.lt 0 r","decl":"/-- Analogue of `HasFPowerSeriesOnBall` where convergence is required only on a set `s`. We also\nrequire convergence at `x` as the behavior of this notion is very bad otherwise. -/\nstructure HasFPowerSeriesWithinOnBall (f : E → F) (p : FormalMultilinearSeries 𝕜 E F) (s : Set E)\n    (x : E) (r : ℝ≥0∞) : Prop where\n  /-- `p` converges on `ball 0 r` -/\n  r_le : r ≤ p.radius\n  /-- The radius of convergence is positive -/\n  r_pos : 0 < r\n  /-- `p converges to f` within `s` -/\n  hasSum : ∀ {y}, x + y ∈ insert x s → y ∈ EMetric.ball (0 : E) r →\n    HasSum (fun n : ℕ => p n fun _ : Fin n => y) (f (x + y))\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.hasSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nself : HasFPowerSeriesWithinOnBall f p s x r\ny : E\na✝¹ : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\na✝ : Membership.mem (EMetric.ball 0 r) y\n⊢ HasSum (fun n => (p n) fun x => y) (f (HAdd.hAdd x y))","decl":"/-- Analogue of `HasFPowerSeriesOnBall` where convergence is required only on a set `s`. We also\nrequire convergence at `x` as the behavior of this notion is very bad otherwise. -/\nstructure HasFPowerSeriesWithinOnBall (f : E → F) (p : FormalMultilinearSeries 𝕜 E F) (s : Set E)\n    (x : E) (r : ℝ≥0∞) : Prop where\n  /-- `p` converges on `ball 0 r` -/\n  r_le : r ≤ p.radius\n  /-- The radius of convergence is positive -/\n  r_pos : 0 < r\n  /-- `p converges to f` within `s` -/\n  hasSum : ∀ {y}, x + y ∈ insert x s → y ∈ EMetric.ball (0 : E) r →\n    HasSum (fun n : ℕ => p n fun _ : Fin n => y) (f (x + y))\n\n"}
{"name":"HasFPowerSeriesOnBall.hasFPowerSeriesAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\n⊢ HasFPowerSeriesAt f p x","decl":"theorem HasFPowerSeriesOnBall.hasFPowerSeriesAt (hf : HasFPowerSeriesOnBall f p x r) :\n    HasFPowerSeriesAt f p x :=\n  ⟨r, hf⟩\n\n"}
{"name":"HasFPowerSeriesAt.analyticAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f p x\n⊢ AnalyticAt 𝕜 f x","decl":"theorem HasFPowerSeriesAt.analyticAt (hf : HasFPowerSeriesAt f p x) : AnalyticAt 𝕜 f x :=\n  ⟨p, hf⟩\n\n"}
{"name":"HasFPowerSeriesOnBall.analyticAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\n⊢ AnalyticAt 𝕜 f x","decl":"theorem HasFPowerSeriesOnBall.analyticAt (hf : HasFPowerSeriesOnBall f p x r) : AnalyticAt 𝕜 f x :=\n  hf.hasFPowerSeriesAt.analyticAt\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.hasFPowerSeriesWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\n⊢ HasFPowerSeriesWithinAt f p s x","decl":"theorem HasFPowerSeriesWithinOnBall.hasFPowerSeriesWithinAt\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) : HasFPowerSeriesWithinAt f p s x :=\n  ⟨r, hf⟩\n\n"}
{"name":"HasFPowerSeriesWithinAt.analyticWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\n⊢ AnalyticWithinAt 𝕜 f s x","decl":"theorem HasFPowerSeriesWithinAt.analyticWithinAt (hf : HasFPowerSeriesWithinAt f p s x) :\n    AnalyticWithinAt 𝕜 f s x := ⟨p, hf⟩\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.analyticWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\n⊢ AnalyticWithinAt 𝕜 f s x","decl":"theorem HasFPowerSeriesWithinOnBall.analyticWithinAt (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    AnalyticWithinAt 𝕜 f s x :=\n  hf.hasFPowerSeriesWithinAt.analyticWithinAt\n\n"}
{"name":"HasFPowerSeriesOnBall.comp_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\ny : E\n⊢ HasFPowerSeriesOnBall (fun z => f (HSub.hSub z y)) p (HAdd.hAdd x y) r","decl":"/-- If a function `f` has a power series `p` around `x`, then the function `z ↦ f (z - y)` has the\nsame power series around `x + y`. -/\ntheorem HasFPowerSeriesOnBall.comp_sub (hf : HasFPowerSeriesOnBall f p x r) (y : E) :\n    HasFPowerSeriesOnBall (fun z => f (z - y)) p (x + y) r :=\n  { r_le := hf.r_le\n    r_pos := hf.r_pos\n    hasSum := fun {z} hz => by\n      convert hf.hasSum hz using 2\n      abel }\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.hasSum_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\ny : E\nhy : Membership.mem (Inter.inter (Insert.insert x s) (EMetric.ball x r)) y\n⊢ HasSum (fun n => (p n) fun x_1 => HSub.hSub y x) (f y)","decl":"theorem HasFPowerSeriesWithinOnBall.hasSum_sub (hf : HasFPowerSeriesWithinOnBall f p s x r) {y : E}\n    (hy : y ∈ (insert x s) ∩ EMetric.ball x r) :\n    HasSum (fun n : ℕ => p n fun _ => y - x) (f y) := by\n  have : y - x ∈ EMetric.ball (0 : E) r := by simpa [edist_eq_enorm_sub] using hy.2\n  have := hf.hasSum (by simpa only [add_sub_cancel] using hy.1) this\n  simpa only [add_sub_cancel]\n\n"}
{"name":"HasFPowerSeriesOnBall.hasSum_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\ny : E\nhy : Membership.mem (EMetric.ball x r) y\n⊢ HasSum (fun n => (p n) fun x_1 => HSub.hSub y x) (f y)","decl":"theorem HasFPowerSeriesOnBall.hasSum_sub (hf : HasFPowerSeriesOnBall f p x r) {y : E}\n    (hy : y ∈ EMetric.ball x r) : HasSum (fun n : ℕ => p n fun _ => y - x) (f y) := by\n  have : y - x ∈ EMetric.ball (0 : E) r := by simpa [edist_eq_enorm_sub] using hy\n  simpa only [add_sub_cancel] using hf.hasSum this\n\n"}
{"name":"HasFPowerSeriesOnBall.radius_pos","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\n⊢ LT.lt 0 p.radius","decl":"theorem HasFPowerSeriesOnBall.radius_pos (hf : HasFPowerSeriesOnBall f p x r) : 0 < p.radius :=\n  lt_of_lt_of_le hf.r_pos hf.r_le\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.radius_pos","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\n⊢ LT.lt 0 p.radius","decl":"theorem HasFPowerSeriesWithinOnBall.radius_pos (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    0 < p.radius :=\n  lt_of_lt_of_le hf.r_pos hf.r_le\n\n"}
{"name":"HasFPowerSeriesAt.radius_pos","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f p x\n⊢ LT.lt 0 p.radius","decl":"theorem HasFPowerSeriesAt.radius_pos (hf : HasFPowerSeriesAt f p x) : 0 < p.radius :=\n  let ⟨_, hr⟩ := hf\n  hr.radius_pos\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.of_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr r' : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nr'_pos : LT.lt 0 r'\nhr : LE.le r' r\n⊢ HasFPowerSeriesWithinOnBall f p s x r'","decl":"theorem HasFPowerSeriesWithinOnBall.of_le\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (r'_pos : 0 < r') (hr : r' ≤ r) :\n    HasFPowerSeriesWithinOnBall f p s x r' :=\n  ⟨le_trans hr hf.1, r'_pos, fun hy h'y => hf.hasSum hy (EMetric.ball_subset_ball hr h'y)⟩\n\n"}
{"name":"HasFPowerSeriesOnBall.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr r' : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nr'_pos : LT.lt 0 r'\nhr : LE.le r' r\n⊢ HasFPowerSeriesOnBall f p x r'","decl":"theorem HasFPowerSeriesOnBall.mono (hf : HasFPowerSeriesOnBall f p x r) (r'_pos : 0 < r')\n    (hr : r' ≤ r) : HasFPowerSeriesOnBall f p x r' :=\n  ⟨le_trans hr hf.1, r'_pos, fun hy => hf.hasSum (EMetric.ball_subset_ball hr hy)⟩\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nh : HasFPowerSeriesWithinOnBall f p s x r\nh' : Set.EqOn g f (Inter.inter s (EMetric.ball x r))\nh'' : Eq (g x) (f x)\n⊢ HasFPowerSeriesWithinOnBall g p s x r","decl":"lemma HasFPowerSeriesWithinOnBall.congr {f g : E → F} {p : FormalMultilinearSeries 𝕜 E F}\n    {s : Set E} {x : E} {r : ℝ≥0∞} (h : HasFPowerSeriesWithinOnBall f p s x r)\n    (h' : EqOn g f (s ∩ EMetric.ball x r)) (h'' : g x = f x) :\n    HasFPowerSeriesWithinOnBall g p s x r := by\n  refine ⟨h.r_le, h.r_pos, ?_⟩\n  intro y hy h'y\n  convert h.hasSum hy h'y using 1\n  simp only [mem_insert_iff, add_right_eq_self] at hy\n  rcases hy with rfl | hy\n  · simpa using h''\n  · apply h'\n    refine ⟨hy, ?_⟩\n    simpa [edist_eq_enorm_sub] using h'y\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.congr'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nh : HasFPowerSeriesWithinOnBall f p s x r\nh' : Set.EqOn g f (Inter.inter (Insert.insert x s) (EMetric.ball x r))\n⊢ HasFPowerSeriesWithinOnBall g p s x r","decl":"/-- Variant of `HasFPowerSeriesWithinOnBall.congr` in which one requests equality on `insert x s`\ninstead of separating `x` and `s`. -/\nlemma HasFPowerSeriesWithinOnBall.congr' {f g : E → F} {p : FormalMultilinearSeries 𝕜 E F}\n    {s : Set E} {x : E} {r : ℝ≥0∞} (h : HasFPowerSeriesWithinOnBall f p s x r)\n    (h' : EqOn g f (insert x s ∩ EMetric.ball x r)) :\n    HasFPowerSeriesWithinOnBall g p s x r := by\n  refine ⟨h.r_le, h.r_pos, fun {y} hy h'y ↦ ?_⟩\n  convert h.hasSum hy h'y using 1\n  exact h' ⟨hy, by simpa [edist_eq_enorm_sub] using h'y⟩\n\n"}
{"name":"HasFPowerSeriesWithinAt.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nh : HasFPowerSeriesWithinAt f p s x\nh' : (nhdsWithin x s).EventuallyEq g f\nh'' : Eq (g x) (f x)\n⊢ HasFPowerSeriesWithinAt g p s x","decl":"lemma HasFPowerSeriesWithinAt.congr {f g : E → F} {p : FormalMultilinearSeries 𝕜 E F} {s : Set E}\n    {x : E} (h : HasFPowerSeriesWithinAt f p s x) (h' : g =ᶠ[𝓝[s] x] f) (h'' : g x = f x) :\n    HasFPowerSeriesWithinAt g p s x := by\n  rcases h with ⟨r, hr⟩\n  obtain ⟨ε, εpos, hε⟩ : ∃ ε > 0, EMetric.ball x ε ∩ s ⊆ {y | g y = f y} :=\n    EMetric.mem_nhdsWithin_iff.1 h'\n  let r' := min r ε\n  refine ⟨r', ?_⟩\n  have := hr.of_le (r' := r') (by simp [r', εpos, hr.r_pos]) (min_le_left _ _)\n  apply this.congr _ h''\n  intro z hz\n  exact hε ⟨EMetric.ball_subset_ball (min_le_right _ _) hz.2, hz.1⟩\n\n"}
{"name":"HasFPowerSeriesOnBall.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nhg : Set.EqOn f g (EMetric.ball x r)\n⊢ HasFPowerSeriesOnBall g p x r","decl":"theorem HasFPowerSeriesOnBall.congr (hf : HasFPowerSeriesOnBall f p x r)\n    (hg : EqOn f g (EMetric.ball x r)) : HasFPowerSeriesOnBall g p x r :=\n  { r_le := hf.r_le\n    r_pos := hf.r_pos\n    hasSum := fun {y} hy => by\n      convert hf.hasSum hy using 1\n      apply hg.symm\n      simpa [edist_eq_enorm_sub] using hy }\n\n"}
{"name":"HasFPowerSeriesAt.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f p x\nhg : (nhds x).EventuallyEq f g\n⊢ HasFPowerSeriesAt g p x","decl":"theorem HasFPowerSeriesAt.congr (hf : HasFPowerSeriesAt f p x) (hg : f =ᶠ[𝓝 x] g) :\n    HasFPowerSeriesAt g p x := by\n  rcases hf with ⟨r₁, h₁⟩\n  rcases EMetric.mem_nhds_iff.mp hg with ⟨r₂, h₂pos, h₂⟩\n  exact ⟨min r₁ r₂,\n    (h₁.mono (lt_min h₁.r_pos h₂pos) inf_le_left).congr\n      fun y hy => h₂ (EMetric.ball_subset_ball inf_le_right hy)⟩\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.unique","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nhg : HasFPowerSeriesWithinOnBall g p s x r\n⊢ Set.EqOn f g (Inter.inter (Insert.insert x s) (EMetric.ball x r))","decl":"theorem HasFPowerSeriesWithinOnBall.unique (hf : HasFPowerSeriesWithinOnBall f p s x r)\n    (hg : HasFPowerSeriesWithinOnBall g p s x r) :\n    (insert x s ∩ EMetric.ball x r).EqOn f g := fun _ hy ↦\n  (hf.hasSum_sub hy).unique (hg.hasSum_sub hy)\n\n"}
{"name":"HasFPowerSeriesOnBall.unique","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nhg : HasFPowerSeriesOnBall g p x r\n⊢ Set.EqOn f g (EMetric.ball x r)","decl":"theorem HasFPowerSeriesOnBall.unique (hf : HasFPowerSeriesOnBall f p x r)\n    (hg : HasFPowerSeriesOnBall g p x r) : (EMetric.ball x r).EqOn f g := fun _ hy ↦\n  (hf.hasSum_sub hy).unique (hg.hasSum_sub hy)\n\n"}
{"name":"HasFPowerSeriesWithinAt.eventually","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\n⊢ Filter.Eventually (fun r => HasFPowerSeriesWithinOnBall f p s x r) (nhdsWithin 0 (Set.Ioi 0))","decl":"protected theorem HasFPowerSeriesWithinAt.eventually (hf : HasFPowerSeriesWithinAt f p s x) :\n    ∀ᶠ r : ℝ≥0∞ in 𝓝[>] 0, HasFPowerSeriesWithinOnBall f p s x r :=\n  let ⟨_, hr⟩ := hf\n  mem_of_superset (Ioo_mem_nhdsGT hr.r_pos) fun _ hr' => hr.of_le hr'.1 hr'.2.le\n\n"}
{"name":"HasFPowerSeriesAt.eventually","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f p x\n⊢ Filter.Eventually (fun r => HasFPowerSeriesOnBall f p x r) (nhdsWithin 0 (Set.Ioi 0))","decl":"protected theorem HasFPowerSeriesAt.eventually (hf : HasFPowerSeriesAt f p x) :\n    ∀ᶠ r : ℝ≥0∞ in 𝓝[>] 0, HasFPowerSeriesOnBall f p x r :=\n  let ⟨_, hr⟩ := hf\n  mem_of_superset (Ioo_mem_nhdsGT hr.r_pos) fun _ hr' => hr.mono hr'.1 hr'.2.le\n\n"}
{"name":"HasFPowerSeriesOnBall.eventually_hasSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\n⊢ Filter.Eventually (fun y => HasSum (fun n => (p n) fun x => y) (f (HAdd.hAdd x y))) (nhds 0)","decl":"theorem HasFPowerSeriesOnBall.eventually_hasSum (hf : HasFPowerSeriesOnBall f p x r) :\n    ∀ᶠ y in 𝓝 0, HasSum (fun n : ℕ => p n fun _ : Fin n => y) (f (x + y)) := by\n  filter_upwards [EMetric.ball_mem_nhds (0 : E) hf.r_pos] using fun _ => hf.hasSum\n\n"}
{"name":"HasFPowerSeriesAt.eventually_hasSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f p x\n⊢ Filter.Eventually (fun y => HasSum (fun n => (p n) fun x => y) (f (HAdd.hAdd x y))) (nhds 0)","decl":"theorem HasFPowerSeriesAt.eventually_hasSum (hf : HasFPowerSeriesAt f p x) :\n    ∀ᶠ y in 𝓝 0, HasSum (fun n : ℕ => p n fun _ : Fin n => y) (f (x + y)) :=\n  let ⟨_, hr⟩ := hf\n  hr.eventually_hasSum\n\n"}
{"name":"HasFPowerSeriesOnBall.eventually_hasSum_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\n⊢ Filter.Eventually (fun y => HasSum (fun n => (p n) fun x_1 => HSub.hSub y x) (f y)) (nhds x)","decl":"theorem HasFPowerSeriesOnBall.eventually_hasSum_sub (hf : HasFPowerSeriesOnBall f p x r) :\n    ∀ᶠ y in 𝓝 x, HasSum (fun n : ℕ => p n fun _ : Fin n => y - x) (f y) := by\n  filter_upwards [EMetric.ball_mem_nhds x hf.r_pos] with y using hf.hasSum_sub\n\n"}
{"name":"HasFPowerSeriesAt.eventually_hasSum_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f p x\n⊢ Filter.Eventually (fun y => HasSum (fun n => (p n) fun x_1 => HSub.hSub y x) (f y)) (nhds x)","decl":"theorem HasFPowerSeriesAt.eventually_hasSum_sub (hf : HasFPowerSeriesAt f p x) :\n    ∀ᶠ y in 𝓝 x, HasSum (fun n : ℕ => p n fun _ : Fin n => y - x) (f y) :=\n  let ⟨_, hr⟩ := hf\n  hr.eventually_hasSum_sub\n\n"}
{"name":"HasFPowerSeriesOnBall.eventually_eq_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f 0 x r\n⊢ Filter.Eventually (fun z => Eq (f z) 0) (nhds x)","decl":"theorem HasFPowerSeriesOnBall.eventually_eq_zero\n    (hf : HasFPowerSeriesOnBall f (0 : FormalMultilinearSeries 𝕜 E F) x r) :\n    ∀ᶠ z in 𝓝 x, f z = 0 := by\n  filter_upwards [hf.eventually_hasSum_sub] with z hz using hz.unique hasSum_zero\n\n"}
{"name":"HasFPowerSeriesAt.eventually_eq_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nhf : HasFPowerSeriesAt f 0 x\n⊢ Filter.Eventually (fun z => Eq (f z) 0) (nhds x)","decl":"theorem HasFPowerSeriesAt.eventually_eq_zero\n    (hf : HasFPowerSeriesAt f (0 : FormalMultilinearSeries 𝕜 E F) x) : ∀ᶠ z in 𝓝 x, f z = 0 :=\n  let ⟨_, hr⟩ := hf\n  hr.eventually_eq_zero\n\n"}
{"name":"hasFPowerSeriesWithinOnBall_univ","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\n⊢ Iff (HasFPowerSeriesWithinOnBall f p Set.univ x r) (HasFPowerSeriesOnBall f p x r)","decl":"@[simp] lemma hasFPowerSeriesWithinOnBall_univ :\n    HasFPowerSeriesWithinOnBall f p univ x r ↔ HasFPowerSeriesOnBall f p x r := by\n  constructor\n  · intro h\n    refine ⟨h.r_le, h.r_pos, fun {y} m ↦ h.hasSum (by simp) m⟩\n  · intro h\n    exact ⟨h.r_le, h.r_pos, fun {y} _ m => h.hasSum m⟩\n\n"}
{"name":"hasFPowerSeriesWithinAt_univ","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\n⊢ Iff (HasFPowerSeriesWithinAt f p Set.univ x) (HasFPowerSeriesAt f p x)","decl":"@[simp] lemma hasFPowerSeriesWithinAt_univ :\n    HasFPowerSeriesWithinAt f p univ x ↔ HasFPowerSeriesAt f p x := by\n  simp only [HasFPowerSeriesWithinAt, hasFPowerSeriesWithinOnBall_univ, HasFPowerSeriesAt]\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns t : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nh : HasSubset.Subset t s\n⊢ HasFPowerSeriesWithinOnBall f p t x r","decl":"lemma HasFPowerSeriesWithinOnBall.mono (hf : HasFPowerSeriesWithinOnBall f p s x r) (h : t ⊆ s) :\n    HasFPowerSeriesWithinOnBall f p t x r where\n  r_le := hf.r_le\n  r_pos := hf.r_pos\n  hasSum hy h'y := hf.hasSum (insert_subset_insert h hy) h'y\n\n"}
{"name":"HasFPowerSeriesOnBall.hasFPowerSeriesWithinOnBall","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\n⊢ HasFPowerSeriesWithinOnBall f p s x r","decl":"lemma HasFPowerSeriesOnBall.hasFPowerSeriesWithinOnBall (hf : HasFPowerSeriesOnBall f p x r) :\n    HasFPowerSeriesWithinOnBall f p s x r := by\n  rw [← hasFPowerSeriesWithinOnBall_univ] at hf\n  exact hf.mono (subset_univ _)\n\n"}
{"name":"HasFPowerSeriesWithinAt.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns t : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\nh : HasSubset.Subset t s\n⊢ HasFPowerSeriesWithinAt f p t x","decl":"lemma HasFPowerSeriesWithinAt.mono (hf : HasFPowerSeriesWithinAt f p s x) (h : t ⊆ s) :\n    HasFPowerSeriesWithinAt f p t x := by\n  obtain ⟨r, hp⟩ := hf\n  exact ⟨r, hp.mono h⟩\n\n"}
{"name":"HasFPowerSeriesAt.hasFPowerSeriesWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nhf : HasFPowerSeriesAt f p x\n⊢ HasFPowerSeriesWithinAt f p s x","decl":"lemma HasFPowerSeriesAt.hasFPowerSeriesWithinAt (hf : HasFPowerSeriesAt f p x) :\n    HasFPowerSeriesWithinAt f p s x := by\n  rw [← hasFPowerSeriesWithinAt_univ] at hf\n  apply hf.mono (subset_univ _)\n\n"}
{"name":"HasFPowerSeriesWithinAt.mono_of_mem_nhdsWithin","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns t : Set E\nx : E\nh : HasFPowerSeriesWithinAt f p s x\nhst : Membership.mem (nhdsWithin x t) s\n⊢ HasFPowerSeriesWithinAt f p t x","decl":"theorem HasFPowerSeriesWithinAt.mono_of_mem_nhdsWithin\n    (h : HasFPowerSeriesWithinAt f p s x) (hst : s ∈ 𝓝[t] x) :\n    HasFPowerSeriesWithinAt f p t x := by\n  rcases h with ⟨r, hr⟩\n  rcases EMetric.mem_nhdsWithin_iff.1 hst with ⟨r', r'_pos, hr'⟩\n  refine ⟨min r r', ?_⟩\n  have Z := hr.of_le (by simp [r'_pos, hr.r_pos]) (min_le_left r r')\n  refine ⟨Z.r_le, Z.r_pos, fun {y} hy h'y ↦ ?_⟩\n  apply Z.hasSum ?_ h'y\n  simp only [mem_insert_iff, add_right_eq_self] at hy\n  rcases hy with rfl | hy\n  · simp\n  apply mem_insert_of_mem _ (hr' ?_)\n  simp only [EMetric.mem_ball, edist_eq_enorm_sub, sub_zero, lt_min_iff, mem_inter_iff,\n    add_sub_cancel_left, hy, and_true] at h'y ⊢\n  exact h'y.2\n\n"}
{"name":"HasFPowerSeriesWithinAt.mono_of_mem","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns t : Set E\nx : E\nh : HasFPowerSeriesWithinAt f p s x\nhst : Membership.mem (nhdsWithin x t) s\n⊢ HasFPowerSeriesWithinAt f p t x","decl":"@[deprecated (since := \"2024-10-31\")]\nalias HasFPowerSeriesWithinAt.mono_of_mem := HasFPowerSeriesWithinAt.mono_of_mem_nhdsWithin\n\n"}
{"name":"hasFPowerSeriesWithinOnBall_insert_self","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\n⊢ Iff (HasFPowerSeriesWithinOnBall f p (Insert.insert x s) x r) (HasFPowerSeriesWithinOnBall f p s x r)","decl":"@[simp] lemma hasFPowerSeriesWithinOnBall_insert_self :\n    HasFPowerSeriesWithinOnBall f p (insert x s) x r ↔ HasFPowerSeriesWithinOnBall f p s x r := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩  <;>\n  exact ⟨h.r_le, h.r_pos, fun {y} ↦ by simpa only [insert_idem] using h.hasSum (y := y)⟩\n\n"}
{"name":"hasFPowerSeriesWithinAt_insert","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx y : E\n⊢ Iff (HasFPowerSeriesWithinAt f p (Insert.insert y s) x) (HasFPowerSeriesWithinAt f p s x)","decl":"@[simp] theorem hasFPowerSeriesWithinAt_insert {y : E} :\n    HasFPowerSeriesWithinAt f p (insert y s) x ↔ HasFPowerSeriesWithinAt f p s x := by\n  rcases eq_or_ne x y with rfl | hy\n  · simp [HasFPowerSeriesWithinAt]\n  · refine ⟨fun h ↦ h.mono (subset_insert _ _), fun h ↦ ?_⟩\n    apply HasFPowerSeriesWithinAt.mono_of_mem_nhdsWithin h\n    rw [nhdsWithin_insert_of_ne hy]\n    exact self_mem_nhdsWithin\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.coeff_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f pf s x r\nv : Fin 0 → E\n⊢ Eq ((pf 0) v) (f x)","decl":"theorem HasFPowerSeriesWithinOnBall.coeff_zero (hf : HasFPowerSeriesWithinOnBall f pf s x r)\n    (v : Fin 0 → E) : pf 0 v = f x := by\n  have v_eq : v = fun i => 0 := Subsingleton.elim _ _\n  have zero_mem : (0 : E) ∈ EMetric.ball (0 : E) r := by simp [hf.r_pos]\n  have : ∀ i, i ≠ 0 → (pf i fun _ => 0) = 0 := by\n    intro i hi\n    have : 0 < i := pos_iff_ne_zero.2 hi\n    exact ContinuousMultilinearMap.map_coord_zero _ (⟨0, this⟩ : Fin i) rfl\n  have A := (hf.hasSum (by simp) zero_mem).unique (hasSum_single _ this)\n  simpa [v_eq] using A.symm\n\n"}
{"name":"HasFPowerSeriesOnBall.coeff_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f pf x r\nv : Fin 0 → E\n⊢ Eq ((pf 0) v) (f x)","decl":"theorem HasFPowerSeriesOnBall.coeff_zero (hf : HasFPowerSeriesOnBall f pf x r)\n    (v : Fin 0 → E) : pf 0 v = f x := by\n  rw [← hasFPowerSeriesWithinOnBall_univ] at hf\n  exact hf.coeff_zero v\n\n"}
{"name":"HasFPowerSeriesWithinAt.coeff_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f pf s x\nv : Fin 0 → E\n⊢ Eq ((pf 0) v) (f x)","decl":"theorem HasFPowerSeriesWithinAt.coeff_zero (hf : HasFPowerSeriesWithinAt f pf s x) (v : Fin 0 → E) :\n    pf 0 v = f x :=\n  let ⟨_, hrf⟩ := hf\n  hrf.coeff_zero v\n\n"}
{"name":"HasFPowerSeriesAt.coeff_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\npf : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f pf x\nv : Fin 0 → E\n⊢ Eq ((pf 0) v) (f x)","decl":"theorem HasFPowerSeriesAt.coeff_zero (hf : HasFPowerSeriesAt f pf x) (v : Fin 0 → E) :\n    pf 0 v = f x :=\n  let ⟨_, hrf⟩ := hf\n  hrf.coeff_zero v\n\n"}
{"name":"analyticWithinAt_univ","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\n⊢ Iff (AnalyticWithinAt 𝕜 f Set.univ x) (AnalyticAt 𝕜 f x)","decl":"@[simp] lemma analyticWithinAt_univ :\n    AnalyticWithinAt 𝕜 f univ x ↔ AnalyticAt 𝕜 f x := by\n  simp [AnalyticWithinAt, AnalyticAt]\n\n"}
{"name":"analyticOn_univ","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ Iff (AnalyticOn 𝕜 f Set.univ) (AnalyticOnNhd 𝕜 f Set.univ)","decl":"@[simp] lemma analyticOn_univ {f : E → F} :\n    AnalyticOn 𝕜 f univ ↔ AnalyticOnNhd 𝕜 f univ := by\n  simp only [AnalyticOn, analyticWithinAt_univ, AnalyticOnNhd]\n\n"}
{"name":"analyticWithinOn_univ","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ Iff (AnalyticOn 𝕜 f Set.univ) (AnalyticOnNhd 𝕜 f Set.univ)","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticWithinOn_univ := analyticOn_univ\n\n"}
{"name":"AnalyticWithinAt.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns t : Set E\nx : E\nhf : AnalyticWithinAt 𝕜 f s x\nh : HasSubset.Subset t s\n⊢ AnalyticWithinAt 𝕜 f t x","decl":"lemma AnalyticWithinAt.mono (hf : AnalyticWithinAt 𝕜 f s x) (h : t ⊆ s) :\n    AnalyticWithinAt 𝕜 f t x := by\n  obtain ⟨p, hp⟩ := hf\n  exact ⟨p, hp.mono h⟩\n\n"}
{"name":"AnalyticAt.analyticWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx : E\nhf : AnalyticAt 𝕜 f x\n⊢ AnalyticWithinAt 𝕜 f s x","decl":"lemma AnalyticAt.analyticWithinAt (hf : AnalyticAt 𝕜 f x) : AnalyticWithinAt 𝕜 f s x := by\n  rw [← analyticWithinAt_univ] at hf\n  apply hf.mono (subset_univ _)\n\n"}
{"name":"AnalyticOnNhd.analyticOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nhf : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOn 𝕜 f s","decl":"lemma AnalyticOnNhd.analyticOn (hf : AnalyticOnNhd 𝕜 f s) : AnalyticOn 𝕜 f s :=\n  fun x hx ↦ (hf x hx).analyticWithinAt\n\n"}
{"name":"AnalyticOn.analyticWithinOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nhf : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOn 𝕜 f s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.analyticWithinOn := AnalyticOnNhd.analyticOn\n\n"}
{"name":"AnalyticWithinAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nx : E\nhf : AnalyticWithinAt 𝕜 f s x\nhs : (nhdsWithin x s).EventuallyEq g f\nhx : Eq (g x) (f x)\n⊢ AnalyticWithinAt 𝕜 g s x","decl":"lemma AnalyticWithinAt.congr_of_eventuallyEq {f g : E → F} {s : Set E} {x : E}\n    (hf : AnalyticWithinAt 𝕜 f s x) (hs : g =ᶠ[𝓝[s] x] f) (hx : g x = f x) :\n    AnalyticWithinAt 𝕜 g s x := by\n  rcases hf with ⟨p, hp⟩\n  exact ⟨p, hp.congr hs hx⟩\n\n"}
{"name":"AnalyticWithinAt.congr_of_eventuallyEq_insert","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nx : E\nhf : AnalyticWithinAt 𝕜 f s x\nhs : (nhdsWithin x (Insert.insert x s)).EventuallyEq g f\n⊢ AnalyticWithinAt 𝕜 g s x","decl":"lemma AnalyticWithinAt.congr_of_eventuallyEq_insert {f g : E → F} {s : Set E} {x : E}\n    (hf : AnalyticWithinAt 𝕜 f s x) (hs : g =ᶠ[𝓝[insert x s] x] f) :\n    AnalyticWithinAt 𝕜 g s x := by\n  apply hf.congr_of_eventuallyEq (nhdsWithin_mono x (subset_insert x s) hs)\n  apply mem_of_mem_nhdsWithin (mem_insert x s) hs\n\n"}
{"name":"AnalyticWithinAt.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nx : E\nhf : AnalyticWithinAt 𝕜 f s x\nhs : Set.EqOn g f s\nhx : Eq (g x) (f x)\n⊢ AnalyticWithinAt 𝕜 g s x","decl":"lemma AnalyticWithinAt.congr {f g : E → F} {s : Set E} {x : E}\n    (hf : AnalyticWithinAt 𝕜 f s x) (hs : EqOn g f s) (hx : g x = f x) :\n    AnalyticWithinAt 𝕜 g s x :=\n  hf.congr_of_eventuallyEq hs.eventuallyEq_nhdsWithin hx\n\n"}
{"name":"AnalyticOn.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhf : AnalyticOn 𝕜 f s\nhs : Set.EqOn g f s\n⊢ AnalyticOn 𝕜 g s","decl":"lemma AnalyticOn.congr {f g : E → F} {s : Set E}\n    (hf : AnalyticOn 𝕜 f s) (hs : EqOn g f s) :\n    AnalyticOn 𝕜 g s :=\n  fun x m ↦ (hf x m).congr hs (hs m)\n\n"}
{"name":"AnalyticWithinOn.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhf : AnalyticOn 𝕜 f s\nhs : Set.EqOn g f s\n⊢ AnalyticOn 𝕜 g s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.congr := AnalyticOn.congr\n\n"}
{"name":"AnalyticAt.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\nx : E\nhf : AnalyticAt 𝕜 f x\nhg : (nhds x).EventuallyEq f g\n⊢ AnalyticAt 𝕜 g x","decl":"theorem AnalyticAt.congr (hf : AnalyticAt 𝕜 f x) (hg : f =ᶠ[𝓝 x] g) : AnalyticAt 𝕜 g x :=\n  let ⟨_, hpf⟩ := hf\n  (hpf.congr hg).analyticAt\n\n"}
{"name":"analyticAt_congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\nx : E\nh : (nhds x).EventuallyEq f g\n⊢ Iff (AnalyticAt 𝕜 f x) (AnalyticAt 𝕜 g x)","decl":"theorem analyticAt_congr (h : f =ᶠ[𝓝 x] g) : AnalyticAt 𝕜 f x ↔ AnalyticAt 𝕜 g x :=\n  ⟨fun hf ↦ hf.congr h, fun hg ↦ hg.congr h.symm⟩\n\n"}
{"name":"AnalyticOnNhd.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns t : Set E\nhf : AnalyticOnNhd 𝕜 f t\nhst : HasSubset.Subset s t\n⊢ AnalyticOnNhd 𝕜 f s","decl":"theorem AnalyticOnNhd.mono {s t : Set E} (hf : AnalyticOnNhd 𝕜 f t) (hst : s ⊆ t) :\n    AnalyticOnNhd 𝕜 f s :=\n  fun z hz => hf z (hst hz)\n\n"}
{"name":"AnalyticOnNhd.congr'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhf : AnalyticOnNhd 𝕜 f s\nhg : (nhdsSet s).EventuallyEq f g\n⊢ AnalyticOnNhd 𝕜 g s","decl":"theorem AnalyticOnNhd.congr' (hf : AnalyticOnNhd 𝕜 f s) (hg : f =ᶠ[𝓝ˢ s] g) :\n    AnalyticOnNhd 𝕜 g s :=\n  fun z hz => (hf z hz).congr (mem_nhdsSet_iff_forall.mp hg z hz)\n\n"}
{"name":"AnalyticOn.congr'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhf : AnalyticOnNhd 𝕜 f s\nhg : (nhdsSet s).EventuallyEq f g\n⊢ AnalyticOnNhd 𝕜 g s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.congr' := AnalyticOnNhd.congr'\n\n"}
{"name":"analyticOnNhd_congr'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nh : (nhdsSet s).EventuallyEq f g\n⊢ Iff (AnalyticOnNhd 𝕜 f s) (AnalyticOnNhd 𝕜 g s)","decl":"theorem analyticOnNhd_congr' (h : f =ᶠ[𝓝ˢ s] g) : AnalyticOnNhd 𝕜 f s ↔ AnalyticOnNhd 𝕜 g s :=\n  ⟨fun hf => hf.congr' h, fun hg => hg.congr' h.symm⟩\n\n"}
{"name":"analyticOn_congr'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nh : (nhdsSet s).EventuallyEq f g\n⊢ Iff (AnalyticOnNhd 𝕜 f s) (AnalyticOnNhd 𝕜 g s)","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticOn_congr' := analyticOnNhd_congr'\n\n"}
{"name":"AnalyticOnNhd.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhs : IsOpen s\nhf : AnalyticOnNhd 𝕜 f s\nhg : Set.EqOn f g s\n⊢ AnalyticOnNhd 𝕜 g s","decl":"theorem AnalyticOnNhd.congr (hs : IsOpen s) (hf : AnalyticOnNhd 𝕜 f s) (hg : s.EqOn f g) :\n    AnalyticOnNhd 𝕜 g s :=\n  hf.congr' <| mem_nhdsSet_iff_forall.mpr\n    (fun _ hz => eventuallyEq_iff_exists_mem.mpr ⟨s, hs.mem_nhds hz, hg⟩)\n\n"}
{"name":"analyticOnNhd_congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhs : IsOpen s\nh : Set.EqOn f g s\n⊢ Iff (AnalyticOnNhd 𝕜 f s) (AnalyticOnNhd 𝕜 g s)","decl":"theorem analyticOnNhd_congr (hs : IsOpen s) (h : s.EqOn f g) : AnalyticOnNhd 𝕜 f s ↔\n    AnalyticOnNhd 𝕜 g s := ⟨fun hf => hf.congr hs h, fun hg => hg.congr hs h.symm⟩\n\n"}
{"name":"analyticOn_congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : E → F\ns : Set E\nhs : IsOpen s\nh : Set.EqOn f g s\n⊢ Iff (AnalyticOnNhd 𝕜 f s) (AnalyticOnNhd 𝕜 g s)","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticOn_congr := analyticOnNhd_congr\n\n"}
{"name":"AnalyticWithinAt.mono_of_mem_nhdsWithin","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns t : Set E\nx : E\nh : AnalyticWithinAt 𝕜 f s x\nhst : Membership.mem (nhdsWithin x t) s\n⊢ AnalyticWithinAt 𝕜 f t x","decl":"theorem AnalyticWithinAt.mono_of_mem_nhdsWithin\n    (h : AnalyticWithinAt 𝕜 f s x) (hst : s ∈ 𝓝[t] x) : AnalyticWithinAt 𝕜 f t x := by\n  rcases h with ⟨p, hp⟩\n  exact ⟨p, hp.mono_of_mem_nhdsWithin hst⟩\n\n"}
{"name":"AnalyticWithinAt.mono_of_mem","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns t : Set E\nx : E\nh : AnalyticWithinAt 𝕜 f s x\nhst : Membership.mem (nhdsWithin x t) s\n⊢ AnalyticWithinAt 𝕜 f t x","decl":"@[deprecated (since := \"2024-10-31\")]\nalias AnalyticWithinAt.mono_of_mem := AnalyticWithinAt.mono_of_mem_nhdsWithin\n\n"}
{"name":"AnalyticOn.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns t : Set E\nh : AnalyticOn 𝕜 f t\nhs : HasSubset.Subset s t\n⊢ AnalyticOn 𝕜 f s","decl":"lemma AnalyticOn.mono {f : E → F} {s t : Set E} (h : AnalyticOn 𝕜 f t)\n    (hs : s ⊆ t) : AnalyticOn 𝕜 f s :=\n  fun _ m ↦ (h _ (hs m)).mono hs\n\n"}
{"name":"AnalyticWithinOn.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns t : Set E\nh : AnalyticOn 𝕜 f t\nhs : HasSubset.Subset s t\n⊢ AnalyticOn 𝕜 f s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.mono := AnalyticOn.mono\n\n"}
{"name":"analyticWithinAt_insert","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx y : E\n⊢ Iff (AnalyticWithinAt 𝕜 f (Insert.insert y s) x) (AnalyticWithinAt 𝕜 f s x)","decl":"@[simp] theorem analyticWithinAt_insert {f : E → F} {s : Set E} {x y : E} :\n    AnalyticWithinAt 𝕜 f (insert y s) x ↔ AnalyticWithinAt 𝕜 f s x := by\n  simp [AnalyticWithinAt]\n\n"}
{"name":"ContinuousLinearMap.comp_hasFPowerSeriesWithinOnBall","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\nh : HasFPowerSeriesWithinOnBall f p s x r\n⊢ HasFPowerSeriesWithinOnBall (Function.comp (⇑g) f) (g.compFormalMultilinearSeries p) s x r","decl":"/-- If a function `f` has a power series `p` on a ball within a set and `g` is linear,\nthen `g ∘ f` has the power series `g ∘ p` on the same ball. -/\ntheorem ContinuousLinearMap.comp_hasFPowerSeriesWithinOnBall (g : F →L[𝕜] G)\n    (h : HasFPowerSeriesWithinOnBall f p s x r) :\n    HasFPowerSeriesWithinOnBall (g ∘ f) (g.compFormalMultilinearSeries p) s x r where\n  r_le := h.r_le.trans (p.radius_le_radius_continuousLinearMap_comp _)\n  r_pos := h.r_pos\n  hasSum hy h'y := by\n    simpa only [ContinuousLinearMap.compFormalMultilinearSeries_apply,\n      ContinuousLinearMap.compContinuousMultilinearMap_coe, Function.comp_apply] using\n      g.hasSum (h.hasSum hy h'y)\n\n"}
{"name":"ContinuousLinearMap.comp_hasFPowerSeriesOnBall","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\nh : HasFPowerSeriesOnBall f p x r\n⊢ HasFPowerSeriesOnBall (Function.comp (⇑g) f) (g.compFormalMultilinearSeries p) x r","decl":"/-- If a function `f` has a power series `p` on a ball and `g` is linear, then `g ∘ f` has the\npower series `g ∘ p` on the same ball. -/\ntheorem ContinuousLinearMap.comp_hasFPowerSeriesOnBall (g : F →L[𝕜] G)\n    (h : HasFPowerSeriesOnBall f p x r) :\n    HasFPowerSeriesOnBall (g ∘ f) (g.compFormalMultilinearSeries p) x r := by\n  rw [← hasFPowerSeriesWithinOnBall_univ] at h ⊢\n  exact g.comp_hasFPowerSeriesWithinOnBall h\n\n"}
{"name":"ContinuousLinearMap.comp_analyticOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\ns : Set E\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\nh : AnalyticOn 𝕜 f s\n⊢ AnalyticOn 𝕜 (Function.comp (⇑g) f) s","decl":"/-- If a function `f` is analytic on a set `s` and `g` is linear, then `g ∘ f` is analytic\non `s`. -/\ntheorem ContinuousLinearMap.comp_analyticOn (g : F →L[𝕜] G) (h : AnalyticOn 𝕜 f s) :\n    AnalyticOn 𝕜 (g ∘ f) s := by\n  rintro x hx\n  rcases h x hx with ⟨p, r, hp⟩\n  exact ⟨g.compFormalMultilinearSeries p, r, g.comp_hasFPowerSeriesWithinOnBall hp⟩\n\n"}
{"name":"ContinuousLinearMap.comp_analyticOnNhd","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\ns : Set E\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\nh : AnalyticOnNhd 𝕜 f s\n⊢ AnalyticOnNhd 𝕜 (Function.comp (⇑g) f) s","decl":"/-- If a function `f` is analytic on a set `s` and `g` is linear, then `g ∘ f` is analytic\non `s`. -/\ntheorem ContinuousLinearMap.comp_analyticOnNhd\n    {s : Set E} (g : F →L[𝕜] G) (h : AnalyticOnNhd 𝕜 f s) :\n    AnalyticOnNhd 𝕜 (g ∘ f) s := by\n  rintro x hx\n  rcases h x hx with ⟨p, r, hp⟩\n  exact ⟨g.compFormalMultilinearSeries p, r, g.comp_hasFPowerSeriesOnBall hp⟩\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.tendsto_partialSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\ny : E\nhy : Membership.mem (EMetric.ball 0 r) y\nh'y : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\n⊢ Filter.Tendsto (fun n => p.partialSum n y) Filter.atTop (nhds (f (HAdd.hAdd x y)))","decl":"theorem HasFPowerSeriesWithinOnBall.tendsto_partialSum\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) {y : E} (hy : y ∈ EMetric.ball (0 : E) r)\n    (h'y : x + y ∈ insert x s) :\n    Tendsto (fun n => p.partialSum n y) atTop (𝓝 (f (x + y))) :=\n  (hf.hasSum h'y hy).tendsto_sum_nat\n\n"}
{"name":"HasFPowerSeriesOnBall.tendsto_partialSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\ny : E\nhy : Membership.mem (EMetric.ball 0 r) y\n⊢ Filter.Tendsto (fun n => p.partialSum n y) Filter.atTop (nhds (f (HAdd.hAdd x y)))","decl":"theorem HasFPowerSeriesOnBall.tendsto_partialSum\n    (hf : HasFPowerSeriesOnBall f p x r) {y : E} (hy : y ∈ EMetric.ball (0 : E) r) :\n    Tendsto (fun n => p.partialSum n y) atTop (𝓝 (f (x + y))) :=\n  (hf.hasSum hy).tendsto_sum_nat\n\n"}
{"name":"HasFPowerSeriesAt.tendsto_partialSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f p x\n⊢ Filter.Eventually (fun y => Filter.Tendsto (fun n => p.partialSum n y) Filter.atTop (nhds (f (HAdd.hAdd x y)))) (nhds 0)","decl":"theorem HasFPowerSeriesAt.tendsto_partialSum\n    (hf : HasFPowerSeriesAt f p x) :\n    ∀ᶠ y in 𝓝 0, Tendsto (fun n => p.partialSum n y) atTop (𝓝 (f (x + y))) := by\n  rcases hf with ⟨r, hr⟩\n  filter_upwards [EMetric.ball_mem_nhds (0 : E) hr.r_pos] with y hy\n  exact hr.tendsto_partialSum hy\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.tendsto_partialSum_prod","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\ny : E\nhf : HasFPowerSeriesWithinOnBall f p s x r\nhy : Membership.mem (EMetric.ball 0 r) y\nh'y : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\n⊢ Filter.Tendsto (fun z => p.partialSum z.1 z.2) (SProd.sprod Filter.atTop (nhds y)) (nhds (f (HAdd.hAdd x y)))","decl":"open Finset in\n/-- If a function admits a power series expansion within a ball, then the partial sums\n`p.partialSum n z` converge to `f (x + y)` as `n → ∞` and `z → y`. Note that `x + z` doesn't need\nto belong to the set where the power series expansion holds. -/\ntheorem HasFPowerSeriesWithinOnBall.tendsto_partialSum_prod {y : E}\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (hy : y ∈ EMetric.ball (0 : E) r)\n    (h'y : x + y ∈ insert x s) :\n    Tendsto (fun (z : ℕ × E) ↦ p.partialSum z.1 z.2) (atTop ×ˢ 𝓝 y) (𝓝 (f (x + y))) := by\n  have A : Tendsto (fun (z : ℕ × E) ↦ p.partialSum z.1 y) (atTop ×ˢ 𝓝 y) (𝓝 (f (x + y))) := by\n    apply (hf.tendsto_partialSum hy h'y).comp tendsto_fst\n  suffices Tendsto (fun (z : ℕ × E) ↦ p.partialSum z.1 z.2 - p.partialSum z.1 y)\n    (atTop ×ˢ 𝓝 y) (𝓝 0) by simpa using A.add this\n  apply Metric.tendsto_nhds.2 (fun ε εpos ↦ ?_)\n  obtain ⟨r', yr', r'r⟩ : ∃ (r' : ℝ≥0), ‖y‖₊ < r' ∧ r' < r := by\n    simp [edist_zero_eq_enorm] at hy\n    simpa using ENNReal.lt_iff_exists_nnreal_btwn.1 hy\n  have yr'_2 : ‖y‖ < r' := by simpa [← coe_nnnorm] using yr'\n  have S : Summable fun n ↦ ‖p n‖ * ↑r' ^ n := p.summable_norm_mul_pow (r'r.trans_le hf.r_le)\n  obtain ⟨k, hk⟩ : ∃ k, ∑' (n : ℕ), ‖p (n + k)‖ * ↑r' ^ (n + k) < ε / 4 := by\n    have : Tendsto (fun k ↦ ∑' n, ‖p (n + k)‖ * ↑r' ^ (n + k)) atTop (𝓝 0) := by\n      apply _root_.tendsto_sum_nat_add (f := fun n ↦ ‖p n‖ * ↑r' ^ n)\n    exact ((tendsto_order.1 this).2 _ (by linarith)).exists\n  have A : ∀ᶠ (z : ℕ × E) in atTop ×ˢ 𝓝 y,\n      dist (p.partialSum k z.2) (p.partialSum k y) < ε / 4 := by\n    have : ContinuousAt (fun z ↦ p.partialSum k z) y := (p.partialSum_continuous k).continuousAt\n    exact tendsto_snd (Metric.tendsto_nhds.1 this.tendsto (ε / 4) (by linarith))\n  have B : ∀ᶠ (z : ℕ × E) in atTop ×ˢ 𝓝 y, ‖z.2‖₊ < r' := by\n    suffices ∀ᶠ (z : E) in 𝓝 y, ‖z‖₊ < r' from tendsto_snd this\n    have : Metric.ball 0 r' ∈ 𝓝 y := Metric.isOpen_ball.mem_nhds (by simpa using yr'_2)\n    filter_upwards [this] with a ha using by simpa [← coe_nnnorm] using ha\n  have C : ∀ᶠ (z : ℕ × E) in atTop ×ˢ 𝓝 y, k ≤ z.1 := tendsto_fst (Ici_mem_atTop _)\n  filter_upwards [A, B, C]\n  rintro ⟨n, z⟩ hz h'z hkn\n  simp only [dist_eq_norm, sub_zero] at hz ⊢\n  have I (w : E) (hw : ‖w‖₊ < r') : ‖∑ i ∈ Ico k n, p i (fun _ ↦ w)‖ ≤ ε / 4 := calc\n    ‖∑ i ∈ Ico k n, p i (fun _ ↦ w)‖\n    _ = ‖∑ i ∈ range (n - k), p (i + k) (fun _ ↦ w)‖ := by\n        rw [sum_Ico_eq_sum_range]\n        congr with i\n        rw [add_comm k]\n    _ ≤ ∑ i ∈ range (n - k), ‖p (i + k) (fun _ ↦ w)‖ := norm_sum_le _ _\n    _ ≤ ∑ i ∈ range (n - k), ‖p (i + k)‖ * ‖w‖ ^ (i + k) := by\n        gcongr with i _hi; exact ((p (i + k)).le_opNorm _).trans_eq (by simp)\n    _ ≤ ∑ i ∈ range (n - k), ‖p (i + k)‖ * ↑r' ^ (i + k) := by\n        gcongr with i _hi; simpa [← coe_nnnorm] using hw.le\n    _ ≤ ∑' i, ‖p (i + k)‖ * ↑r' ^ (i + k) := by\n        apply sum_le_tsum _ (fun i _hi ↦ by positivity)\n        apply ((_root_.summable_nat_add_iff k).2 S)\n    _ ≤ ε / 4 := hk.le\n  calc\n  ‖p.partialSum n z - p.partialSum n y‖\n  _ = ‖∑ i ∈ range n, p i (fun _ ↦ z) - ∑ i ∈ range n, p i (fun _ ↦ y)‖ := rfl\n  _ = ‖(∑ i ∈ range k, p i (fun _ ↦ z) + ∑ i ∈ Ico k n, p i (fun _ ↦ z))\n        - (∑ i ∈ range k, p i (fun _ ↦ y) + ∑ i ∈ Ico k n, p i (fun _ ↦ y))‖ := by\n    simp [sum_range_add_sum_Ico _ hkn]\n  _ = ‖(p.partialSum k z - p.partialSum k y) + (∑ i ∈ Ico k n, p i (fun _ ↦ z))\n        + (- ∑ i ∈ Ico k n, p i (fun _ ↦ y))‖ := by\n    congr 1\n    simp only [FormalMultilinearSeries.partialSum]\n    abel\n  _ ≤ ‖p.partialSum k z - p.partialSum k y‖ + ‖∑ i ∈ Ico k n, p i (fun _ ↦ z)‖\n      + ‖- ∑ i ∈ Ico k n, p i (fun _ ↦ y)‖ := norm_add₃_le\n  _ ≤ ε / 4 + ε / 4 + ε / 4 := by\n    gcongr\n    · exact I _ h'z\n    · simp only [norm_neg]; exact I _ yr'\n  _ < ε := by linarith\n\n"}
{"name":"HasFPowerSeriesOnBall.tendsto_partialSum_prod","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\ny : E\nhf : HasFPowerSeriesOnBall f p x r\nhy : Membership.mem (EMetric.ball 0 r) y\n⊢ Filter.Tendsto (fun z => p.partialSum z.1 z.2) (SProd.sprod Filter.atTop (nhds y)) (nhds (f (HAdd.hAdd x y)))","decl":"/-- If a function admits a power series on a ball, then the partial sums\n`p.partialSum n z` converges to `f (x + y)` as `n → ∞` and `z → y`. -/\ntheorem HasFPowerSeriesOnBall.tendsto_partialSum_prod {y : E}\n    (hf : HasFPowerSeriesOnBall f p x r) (hy : y ∈ EMetric.ball (0 : E) r) :\n    Tendsto (fun (z : ℕ × E) ↦ p.partialSum z.1 z.2) (atTop ×ˢ 𝓝 y) (𝓝 (f (x + y))) :=\n  (hf.hasFPowerSeriesWithinOnBall (s := univ)).tendsto_partialSum_prod hy (by simp)\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.uniform_geometric_approx'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nh : LT.lt (↑r') r\n⊢ Exists fun a => And (Membership.mem (Set.Ioo 0 1) a) (Exists fun C => And (GT.gt C 0) (∀ (y : E), Membership.mem (Metric.ball 0 ↑r') y → ∀ (n : Nat), Membership.mem (Insert.insert x s) (HAdd.hAdd x y) → LE.le (Norm.norm (HSub.hSub (f (HAdd.hAdd x y)) (p.partialSum n y))) (HMul.hMul C (HPow.hPow (HMul.hMul a (HDiv.hDiv (Norm.norm y) ↑r')) n))))","decl":"/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence.\n\nThis version provides an upper estimate that decreases both in `‖y‖` and `n`. See also\n`HasFPowerSeriesWithinOnBall.uniform_geometric_approx` for a weaker version. -/\ntheorem HasFPowerSeriesWithinOnBall.uniform_geometric_approx' {r' : ℝ≥0}\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (h : (r' : ℝ≥0∞) < r) :\n    ∃ a ∈ Ioo (0 : ℝ) 1, ∃ C > 0, ∀ y ∈ Metric.ball (0 : E) r', ∀ n, x + y ∈ insert x s →\n      ‖f (x + y) - p.partialSum n y‖ ≤ C * (a * (‖y‖ / r')) ^ n := by\n  obtain ⟨a, ha, C, hC, hp⟩ : ∃ a ∈ Ioo (0 : ℝ) 1, ∃ C > 0, ∀ n, ‖p n‖ * (r' : ℝ) ^ n ≤ C * a ^ n :=\n    p.norm_mul_pow_le_mul_pow_of_lt_radius (h.trans_le hf.r_le)\n  refine ⟨a, ha, C / (1 - a), div_pos hC (sub_pos.2 ha.2), fun y hy n ys => ?_⟩\n  have yr' : ‖y‖ < r' := by\n    rw [ball_zero_eq] at hy\n    exact hy\n  have hr'0 : 0 < (r' : ℝ) := (norm_nonneg _).trans_lt yr'\n  have : y ∈ EMetric.ball (0 : E) r := by\n    refine mem_emetric_ball_zero_iff.2 (lt_trans ?_ h)\n    simpa [enorm] using yr'\n  rw [norm_sub_rev, ← mul_div_right_comm]\n  have ya : a * (‖y‖ / ↑r') ≤ a :=\n    mul_le_of_le_one_right ha.1.le (div_le_one_of_le₀ yr'.le r'.coe_nonneg)\n  suffices ‖p.partialSum n y - f (x + y)‖ ≤ C * (a * (‖y‖ / r')) ^ n / (1 - a * (‖y‖ / r')) by\n    refine this.trans ?_\n    have : 0 < a := ha.1\n    gcongr\n    apply_rules [sub_pos.2, ha.2]\n  apply norm_sub_le_of_geometric_bound_of_hasSum (ya.trans_lt ha.2) _ (hf.hasSum ys this)\n  intro n\n  calc\n    ‖(p n) fun _ : Fin n => y‖\n    _ ≤ ‖p n‖ * ∏ _i : Fin n, ‖y‖ := ContinuousMultilinearMap.le_opNorm _ _\n    _ = ‖p n‖ * (r' : ℝ) ^ n * (‖y‖ / r') ^ n := by field_simp [mul_right_comm]\n    _ ≤ C * a ^ n * (‖y‖ / r') ^ n := by gcongr ?_ * _; apply hp\n    _ ≤ C * (a * (‖y‖ / r')) ^ n := by rw [mul_pow, mul_assoc]\n\n"}
{"name":"HasFPowerSeriesOnBall.uniform_geometric_approx'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesOnBall f p x r\nh : LT.lt (↑r') r\n⊢ Exists fun a => And (Membership.mem (Set.Ioo 0 1) a) (Exists fun C => And (GT.gt C 0) (∀ (y : E), Membership.mem (Metric.ball 0 ↑r') y → ∀ (n : Nat), LE.le (Norm.norm (HSub.hSub (f (HAdd.hAdd x y)) (p.partialSum n y))) (HMul.hMul C (HPow.hPow (HMul.hMul a (HDiv.hDiv (Norm.norm y) ↑r')) n))))","decl":"/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence.\n\nThis version provides an upper estimate that decreases both in `‖y‖` and `n`. See also\n`HasFPowerSeriesOnBall.uniform_geometric_approx` for a weaker version. -/\ntheorem HasFPowerSeriesOnBall.uniform_geometric_approx' {r' : ℝ≥0}\n    (hf : HasFPowerSeriesOnBall f p x r) (h : (r' : ℝ≥0∞) < r) :\n    ∃ a ∈ Ioo (0 : ℝ) 1, ∃ C > 0, ∀ y ∈ Metric.ball (0 : E) r', ∀ n,\n      ‖f (x + y) - p.partialSum n y‖ ≤ C * (a * (‖y‖ / r')) ^ n := by\n   rw [← hasFPowerSeriesWithinOnBall_univ] at hf\n   simpa using hf.uniform_geometric_approx' h\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.uniform_geometric_approx","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nh : LT.lt (↑r') r\n⊢ Exists fun a => And (Membership.mem (Set.Ioo 0 1) a) (Exists fun C => And (GT.gt C 0) (∀ (y : E), Membership.mem (Metric.ball 0 ↑r') y → ∀ (n : Nat), Membership.mem (Insert.insert x s) (HAdd.hAdd x y) → LE.le (Norm.norm (HSub.hSub (f (HAdd.hAdd x y)) (p.partialSum n y))) (HMul.hMul C (HPow.hPow a n))))","decl":"/-- If a function admits a power series expansion within a set in a ball, then it is exponentially\nclose to the partial sums of this power series on strict subdisks of the disk of convergence. -/\ntheorem HasFPowerSeriesWithinOnBall.uniform_geometric_approx {r' : ℝ≥0}\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (h : (r' : ℝ≥0∞) < r) :\n    ∃ a ∈ Ioo (0 : ℝ) 1,\n      ∃ C > 0, ∀ y ∈ Metric.ball (0 : E) r', ∀ n, x + y ∈ insert x s →\n      ‖f (x + y) - p.partialSum n y‖ ≤ C * a ^ n := by\n  obtain ⟨a, ha, C, hC, hp⟩ : ∃ a ∈ Ioo (0 : ℝ) 1, ∃ C > 0, ∀ y ∈ Metric.ball (0 : E) r', ∀ n,\n      x + y ∈ insert x s → ‖f (x + y) - p.partialSum n y‖ ≤ C * (a * (‖y‖ / r')) ^ n :=\n    hf.uniform_geometric_approx' h\n  refine ⟨a, ha, C, hC, fun y hy n ys => (hp y hy n ys).trans ?_⟩\n  have yr' : ‖y‖ < r' := by rwa [ball_zero_eq] at hy\n  have := ha.1.le -- needed to discharge a side goal on the next line\n  gcongr\n  exact mul_le_of_le_one_right ha.1.le (div_le_one_of_le₀ yr'.le r'.coe_nonneg)\n\n"}
{"name":"HasFPowerSeriesOnBall.uniform_geometric_approx","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesOnBall f p x r\nh : LT.lt (↑r') r\n⊢ Exists fun a => And (Membership.mem (Set.Ioo 0 1) a) (Exists fun C => And (GT.gt C 0) (∀ (y : E), Membership.mem (Metric.ball 0 ↑r') y → ∀ (n : Nat), LE.le (Norm.norm (HSub.hSub (f (HAdd.hAdd x y)) (p.partialSum n y))) (HMul.hMul C (HPow.hPow a n))))","decl":"/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence. -/\ntheorem HasFPowerSeriesOnBall.uniform_geometric_approx {r' : ℝ≥0}\n    (hf : HasFPowerSeriesOnBall f p x r) (h : (r' : ℝ≥0∞) < r) :\n    ∃ a ∈ Ioo (0 : ℝ) 1,\n      ∃ C > 0, ∀ y ∈ Metric.ball (0 : E) r', ∀ n,\n      ‖f (x + y) - p.partialSum n y‖ ≤ C * a ^ n := by\n  rw [← hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.uniform_geometric_approx h\n\n"}
{"name":"HasFPowerSeriesWithinAt.isBigO_sub_partialSum_pow","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\nn : Nat\n⊢ Asymptotics.IsBigO (nhdsWithin 0 (Set.preimage (fun x_1 => HAdd.hAdd x x_1) (Insert.insert x s))) (fun y => HSub.hSub (f (HAdd.hAdd x y)) (p.partialSum n y)) fun y => HPow.hPow (Norm.norm y) n","decl":"/-- Taylor formula for an analytic function within a set, `IsBigO` version. -/\ntheorem HasFPowerSeriesWithinAt.isBigO_sub_partialSum_pow\n    (hf : HasFPowerSeriesWithinAt f p s x) (n : ℕ) :\n    (fun y : E => f (x + y) - p.partialSum n y)\n      =O[𝓝[(x + ·)⁻¹' insert x s] 0] fun y => ‖y‖ ^ n := by\n  rcases hf with ⟨r, hf⟩\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hf.r_pos with ⟨r', r'0, h⟩\n  obtain ⟨a, -, C, -, hp⟩ : ∃ a ∈ Ioo (0 : ℝ) 1, ∃ C > 0, ∀ y ∈ Metric.ball (0 : E) r', ∀ n,\n      x + y ∈ insert x s → ‖f (x + y) - p.partialSum n y‖ ≤ C * (a * (‖y‖ / r')) ^ n :=\n    hf.uniform_geometric_approx' h\n  refine isBigO_iff.2 ⟨C * (a / r') ^ n, ?_⟩\n  replace r'0 : 0 < (r' : ℝ) := mod_cast r'0\n  filter_upwards [inter_mem_nhdsWithin _ (Metric.ball_mem_nhds (0 : E) r'0)] with y hy\n  simpa [mul_pow, mul_div_assoc, mul_assoc, div_mul_eq_mul_div, div_pow]\n    using hp y hy.2 n (by simpa using hy.1)\n\n"}
{"name":"HasFPowerSeriesAt.isBigO_sub_partialSum_pow","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f p x\nn : Nat\n⊢ Asymptotics.IsBigO (nhds 0) (fun y => HSub.hSub (f (HAdd.hAdd x y)) (p.partialSum n y)) fun y => HPow.hPow (Norm.norm y) n","decl":"/-- Taylor formula for an analytic function, `IsBigO` version. -/\ntheorem HasFPowerSeriesAt.isBigO_sub_partialSum_pow\n    (hf : HasFPowerSeriesAt f p x) (n : ℕ) :\n    (fun y : E => f (x + y) - p.partialSum n y) =O[𝓝 0] fun y => ‖y‖ ^ n := by\n  rw [← hasFPowerSeriesWithinAt_univ] at hf\n  simpa using hf.isBigO_sub_partialSum_pow n\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.isBigO_image_sub_image_sub_deriv_principal","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr r' : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nhr : LT.lt r' r\n⊢ Asymptotics.IsBigO (Filter.principal (Inter.inter (EMetric.ball { fst := x, snd := x } r') (SProd.sprod (Insert.insert x s) (Insert.insert x s)))) (fun y => HSub.hSub (HSub.hSub (f y.1) (f y.2)) ((p 1) fun x => HSub.hSub y.1 y.2)) fun y => HMul.hMul (Norm.norm (HSub.hSub y { fst := x, snd := x })) (Norm.norm (HSub.hSub y.1 y.2))","decl":"/-- If `f` has formal power series `∑ n, pₙ` in a set, within a ball of radius `r`, then\nfor `y, z` in any smaller ball, the norm of the difference `f y - f z - p 1 (fun _ ↦ y - z)` is\nbounded above by `C * (max ‖y - x‖ ‖z - x‖) * ‖y - z‖`. This lemma formulates this property\nusing `IsBigO` and `Filter.principal` on `E × E`. -/\ntheorem HasFPowerSeriesWithinOnBall.isBigO_image_sub_image_sub_deriv_principal\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (hr : r' < r) :\n    (fun y : E × E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2)\n      =O[𝓟 (EMetric.ball (x, x) r' ∩ ((insert x s) ×ˢ (insert x s)))]\n      fun y => ‖y - (x, x)‖ * ‖y.1 - y.2‖ := by\n  lift r' to ℝ≥0 using ne_top_of_lt hr\n  rcases (zero_le r').eq_or_lt with (rfl | hr'0)\n  · simp only [ENNReal.coe_zero, EMetric.ball_zero, empty_inter, principal_empty, isBigO_bot]\n  obtain ⟨a, ha, C, hC : 0 < C, hp⟩ :\n      ∃ a ∈ Ioo (0 : ℝ) 1, ∃ C > 0, ∀ n : ℕ, ‖p n‖ * (r' : ℝ) ^ n ≤ C * a ^ n :=\n    p.norm_mul_pow_le_mul_pow_of_lt_radius (hr.trans_le hf.r_le)\n  simp only [← le_div_iff₀ (pow_pos (NNReal.coe_pos.2 hr'0) _)] at hp\n  set L : E × E → ℝ := fun y =>\n    C * (a / r') ^ 2 * (‖y - (x, x)‖ * ‖y.1 - y.2‖) * (a / (1 - a) ^ 2 + 2 / (1 - a))\n  have hL : ∀ y ∈ EMetric.ball (x, x) r' ∩ ((insert x s) ×ˢ (insert x s)),\n      ‖f y.1 - f y.2 - p 1 fun _ => y.1 - y.2‖ ≤ L y := by\n    intro y ⟨hy', ys⟩\n    have hy : y ∈ EMetric.ball x r ×ˢ EMetric.ball x r := by\n      rw [EMetric.ball_prod_same]\n      exact EMetric.ball_subset_ball hr.le hy'\n    set A : ℕ → F := fun n => (p n fun _ => y.1 - x) - p n fun _ => y.2 - x\n    have hA : HasSum (fun n => A (n + 2)) (f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) := by\n      convert (hasSum_nat_add_iff' 2).2\n        ((hf.hasSum_sub ⟨ys.1, hy.1⟩).sub (hf.hasSum_sub ⟨ys.2, hy.2⟩)) using 1\n      rw [Finset.sum_range_succ, Finset.sum_range_one, hf.coeff_zero, hf.coeff_zero, sub_self,\n        zero_add, ← Subsingleton.pi_single_eq (0 : Fin 1) (y.1 - x), Pi.single,\n        ← Subsingleton.pi_single_eq (0 : Fin 1) (y.2 - x), Pi.single, ← (p 1).map_update_sub,\n        ← Pi.single, Subsingleton.pi_single_eq, sub_sub_sub_cancel_right]\n    rw [EMetric.mem_ball, edist_eq_enorm_sub, enorm_lt_coe] at hy'\n    set B : ℕ → ℝ := fun n => C * (a / r') ^ 2 * (‖y - (x, x)‖ * ‖y.1 - y.2‖) * ((n + 2) * a ^ n)\n    have hAB : ∀ n, ‖A (n + 2)‖ ≤ B n := fun n =>\n      calc\n        ‖A (n + 2)‖ ≤ ‖p (n + 2)‖ * ↑(n + 2) * ‖y - (x, x)‖ ^ (n + 1) * ‖y.1 - y.2‖ := by\n          -- Porting note: `pi_norm_const` was `pi_norm_const (_ : E)`\n          simpa only [Fintype.card_fin, pi_norm_const, Prod.norm_def, Pi.sub_def,\n            Prod.fst_sub, Prod.snd_sub, sub_sub_sub_cancel_right] using\n            (p <| n + 2).norm_image_sub_le (fun _ => y.1 - x) fun _ => y.2 - x\n        _ = ‖p (n + 2)‖ * ‖y - (x, x)‖ ^ n * (↑(n + 2) * ‖y - (x, x)‖ * ‖y.1 - y.2‖) := by\n          rw [pow_succ ‖y - (x, x)‖]\n          ring\n        -- Porting note: the two `↑` in `↑r'` are new, without them, Lean fails to synthesize\n        -- instances `HDiv ℝ ℝ≥0 ?m` or `HMul ℝ ℝ≥0 ?m`\n        _ ≤ C * a ^ (n + 2) / ↑r' ^ (n + 2)\n            * ↑r' ^ n * (↑(n + 2) * ‖y - (x, x)‖ * ‖y.1 - y.2‖) := by\n          have : 0 < a := ha.1\n          gcongr\n          · apply hp\n          · apply hy'.le\n        _ = B n := by\n          field_simp [B, pow_succ]\n          simp only [mul_assoc, mul_comm, mul_left_comm]\n    have hBL : HasSum B (L y) := by\n      apply HasSum.mul_left\n      simp only [add_mul]\n      have : ‖a‖ < 1 := by simp only [Real.norm_eq_abs, abs_of_pos ha.1, ha.2]\n      rw [div_eq_mul_inv, div_eq_mul_inv]\n      exact (hasSum_coe_mul_geometric_of_norm_lt_one this).add  -- Porting note: was `convert`!\n          ((hasSum_geometric_of_norm_lt_one this).mul_left 2)\n    exact hA.norm_le_of_bounded hBL hAB\n  suffices L =O[𝓟 (EMetric.ball (x, x) r' ∩ ((insert x s) ×ˢ (insert x s)))]\n      fun y => ‖y - (x, x)‖ * ‖y.1 - y.2‖ from\n    .trans (.of_norm_eventuallyLE (eventually_principal.2 hL)) this\n  simp_rw [L, mul_right_comm _ (_ * _)]\n  exact (isBigO_refl _ _).const_mul_left _\n\n"}
{"name":"HasFPowerSeriesOnBall.isBigO_image_sub_image_sub_deriv_principal","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr r' : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nhr : LT.lt r' r\n⊢ Asymptotics.IsBigO (Filter.principal (EMetric.ball { fst := x, snd := x } r')) (fun y => HSub.hSub (HSub.hSub (f y.1) (f y.2)) ((p 1) fun x => HSub.hSub y.1 y.2)) fun y => HMul.hMul (Norm.norm (HSub.hSub y { fst := x, snd := x })) (Norm.norm (HSub.hSub y.1 y.2))","decl":"/-- If `f` has formal power series `∑ n, pₙ` on a ball of radius `r`, then for `y, z` in any smaller\nball, the norm of the difference `f y - f z - p 1 (fun _ ↦ y - z)` is bounded above by\n`C * (max ‖y - x‖ ‖z - x‖) * ‖y - z‖`. This lemma formulates this property using `IsBigO` and\n`Filter.principal` on `E × E`. -/\ntheorem HasFPowerSeriesOnBall.isBigO_image_sub_image_sub_deriv_principal\n    (hf : HasFPowerSeriesOnBall f p x r) (hr : r' < r) :\n    (fun y : E × E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2)\n      =O[𝓟 (EMetric.ball (x, x) r')] fun y => ‖y - (x, x)‖ * ‖y.1 - y.2‖ := by\n  rw [← hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.isBigO_image_sub_image_sub_deriv_principal hr\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.image_sub_sub_deriv_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr r' : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nhr : LT.lt r' r\n⊢ Exists fun C => ∀ (y : E), Membership.mem (Inter.inter (Insert.insert x s) (EMetric.ball x r')) y → ∀ (z : E), Membership.mem (Inter.inter (Insert.insert x s) (EMetric.ball x r')) z → LE.le (Norm.norm (HSub.hSub (HSub.hSub (f y) (f z)) ((p 1) fun x => HSub.hSub y z))) (HMul.hMul (HMul.hMul C (Max.max (Norm.norm (HSub.hSub y x)) (Norm.norm (HSub.hSub z x)))) (Norm.norm (HSub.hSub y z)))","decl":"/-- If `f` has formal power series `∑ n, pₙ` within a set, on a ball of radius `r`, then for `y, z`\nin any smaller ball, the norm of the difference `f y - f z - p 1 (fun _ ↦ y - z)` is bounded above\nby `C * (max ‖y - x‖ ‖z - x‖) * ‖y - z‖`. -/\ntheorem HasFPowerSeriesWithinOnBall.image_sub_sub_deriv_le\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (hr : r' < r) :\n    ∃ C, ∀ᵉ (y ∈ insert x s ∩ EMetric.ball x r') (z ∈ insert x s ∩ EMetric.ball x r'),\n      ‖f y - f z - p 1 fun _ => y - z‖ ≤ C * max ‖y - x‖ ‖z - x‖ * ‖y - z‖ := by\n  have := hf.isBigO_image_sub_image_sub_deriv_principal hr\n  simp only [isBigO_principal, mem_inter_iff, EMetric.mem_ball, Prod.edist_eq, max_lt_iff, mem_prod,\n    norm_mul, Real.norm_eq_abs, abs_norm, and_imp, Prod.forall, mul_assoc] at this ⊢\n  rcases this with ⟨C, hC⟩\n  exact ⟨C, fun y ys hy z zs hz ↦ hC y z hy hz ys zs⟩\n\n"}
{"name":"HasFPowerSeriesOnBall.image_sub_sub_deriv_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr r' : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nhr : LT.lt r' r\n⊢ Exists fun C => ∀ (y : E), Membership.mem (EMetric.ball x r') y → ∀ (z : E), Membership.mem (EMetric.ball x r') z → LE.le (Norm.norm (HSub.hSub (HSub.hSub (f y) (f z)) ((p 1) fun x => HSub.hSub y z))) (HMul.hMul (HMul.hMul C (Max.max (Norm.norm (HSub.hSub y x)) (Norm.norm (HSub.hSub z x)))) (Norm.norm (HSub.hSub y z)))","decl":"/-- If `f` has formal power series `∑ n, pₙ` on a ball of radius `r`, then for `y, z` in any smaller\nball, the norm of the difference `f y - f z - p 1 (fun _ ↦ y - z)` is bounded above by\n`C * (max ‖y - x‖ ‖z - x‖) * ‖y - z‖`. -/\ntheorem HasFPowerSeriesOnBall.image_sub_sub_deriv_le\n    (hf : HasFPowerSeriesOnBall f p x r) (hr : r' < r) :\n    ∃ C, ∀ᵉ (y ∈ EMetric.ball x r') (z ∈ EMetric.ball x r'),\n      ‖f y - f z - p 1 fun _ => y - z‖ ≤ C * max ‖y - x‖ ‖z - x‖ * ‖y - z‖ := by\n  rw [← hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa only [mem_univ, insert_eq_of_mem, univ_inter] using hf.image_sub_sub_deriv_le hr\n\n"}
{"name":"HasFPowerSeriesWithinAt.isBigO_image_sub_norm_mul_norm_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\n⊢ Asymptotics.IsBigO (nhdsWithin { fst := x, snd := x } (SProd.sprod (Insert.insert x s) (Insert.insert x s))) (fun y => HSub.hSub (HSub.hSub (f y.1) (f y.2)) ((p 1) fun x => HSub.hSub y.1 y.2)) fun y => HMul.hMul (Norm.norm (HSub.hSub y { fst := x, snd := x })) (Norm.norm (HSub.hSub y.1 y.2))","decl":"/-- If `f` has formal power series `∑ n, pₙ` at `x` within a set `s`, then\n`f y - f z - p 1 (fun _ ↦ y - z) = O(‖(y, z) - (x, x)‖ * ‖y - z‖)` as `(y, z) → (x, x)`\nwithin `s × s`. -/\ntheorem HasFPowerSeriesWithinAt.isBigO_image_sub_norm_mul_norm_sub\n    (hf : HasFPowerSeriesWithinAt f p s x) :\n    (fun y : E × E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2)\n      =O[𝓝[(insert x s) ×ˢ (insert x s)] (x, x)] fun y => ‖y - (x, x)‖ * ‖y.1 - y.2‖ := by\n  rcases hf with ⟨r, hf⟩\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hf.r_pos with ⟨r', r'0, h⟩\n  refine (hf.isBigO_image_sub_image_sub_deriv_principal h).mono ?_\n  rw [inter_comm]\n  exact le_principal_iff.2 (inter_mem_nhdsWithin _ (EMetric.ball_mem_nhds _ r'0))\n\n"}
{"name":"HasFPowerSeriesAt.isBigO_image_sub_norm_mul_norm_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f p x\n⊢ Asymptotics.IsBigO (nhds { fst := x, snd := x }) (fun y => HSub.hSub (HSub.hSub (f y.1) (f y.2)) ((p 1) fun x => HSub.hSub y.1 y.2)) fun y => HMul.hMul (Norm.norm (HSub.hSub y { fst := x, snd := x })) (Norm.norm (HSub.hSub y.1 y.2))","decl":"/-- If `f` has formal power series `∑ n, pₙ` at `x`, then\n`f y - f z - p 1 (fun _ ↦ y - z) = O(‖(y, z) - (x, x)‖ * ‖y - z‖)` as `(y, z) → (x, x)`.\nIn particular, `f` is strictly differentiable at `x`. -/\ntheorem HasFPowerSeriesAt.isBigO_image_sub_norm_mul_norm_sub (hf : HasFPowerSeriesAt f p x) :\n    (fun y : E × E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) =O[𝓝 (x, x)] fun y =>\n      ‖y - (x, x)‖ * ‖y.1 - y.2‖ := by\n  rw [← hasFPowerSeriesWithinAt_univ] at hf\n  simpa using hf.isBigO_image_sub_norm_mul_norm_sub\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.tendstoUniformlyOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nh : LT.lt (↑r') r\n⊢ TendstoUniformlyOn (fun n y => p.partialSum n y) (fun y => f (HAdd.hAdd x y)) Filter.atTop (Inter.inter (Set.preimage (fun x_1 => HAdd.hAdd x x_1) (Insert.insert x s)) (Metric.ball 0 ↑r'))","decl":"/-- If a function admits a power series expansion within a set at `x`, then it is the uniform limit\nof the partial sums of this power series on strict subdisks of the disk of convergence, i.e.,\n`f (x + y)` is the uniform limit of `p.partialSum n y` there. -/\ntheorem HasFPowerSeriesWithinOnBall.tendstoUniformlyOn {r' : ℝ≥0}\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (h : (r' : ℝ≥0∞) < r) :\n    TendstoUniformlyOn (fun n y => p.partialSum n y) (fun y => f (x + y)) atTop\n      ((x + ·)⁻¹' (insert x s) ∩ Metric.ball (0 : E) r') := by\n  obtain ⟨a, ha, C, -, hp⟩ : ∃ a ∈ Ioo (0 : ℝ) 1, ∃ C > 0, ∀ y ∈ Metric.ball (0 : E) r', ∀ n,\n    x + y ∈ insert x s → ‖f (x + y) - p.partialSum n y‖ ≤ C * a ^ n := hf.uniform_geometric_approx h\n  refine Metric.tendstoUniformlyOn_iff.2 fun ε εpos => ?_\n  have L : Tendsto (fun n => (C : ℝ) * a ^ n) atTop (𝓝 ((C : ℝ) * 0)) :=\n    tendsto_const_nhds.mul (tendsto_pow_atTop_nhds_zero_of_lt_one ha.1.le ha.2)\n  rw [mul_zero] at L\n  refine (L.eventually (gt_mem_nhds εpos)).mono fun n hn y hy => ?_\n  rw [dist_eq_norm]\n  exact (hp y hy.2 n hy.1).trans_lt hn\n\n"}
{"name":"HasFPowerSeriesOnBall.tendstoUniformlyOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesOnBall f p x r\nh : LT.lt (↑r') r\n⊢ TendstoUniformlyOn (fun n y => p.partialSum n y) (fun y => f (HAdd.hAdd x y)) Filter.atTop (Metric.ball 0 ↑r')","decl":"/-- If a function admits a power series expansion at `x`, then it is the uniform limit of the\npartial sums of this power series on strict subdisks of the disk of convergence, i.e., `f (x + y)`\nis the uniform limit of `p.partialSum n y` there. -/\ntheorem HasFPowerSeriesOnBall.tendstoUniformlyOn {r' : ℝ≥0} (hf : HasFPowerSeriesOnBall f p x r)\n    (h : (r' : ℝ≥0∞) < r) :\n    TendstoUniformlyOn (fun n y => p.partialSum n y) (fun y => f (x + y)) atTop\n      (Metric.ball (0 : E) r') := by\n  rw [← hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.tendstoUniformlyOn h\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.tendstoLocallyUniformlyOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\n⊢ TendstoLocallyUniformlyOn (fun n y => p.partialSum n y) (fun y => f (HAdd.hAdd x y)) Filter.atTop (Inter.inter (Set.preimage (fun x_1 => HAdd.hAdd x x_1) (Insert.insert x s)) (EMetric.ball 0 r))","decl":"/-- If a function admits a power series expansion within a set at `x`, then it is the locally\nuniform limit of the partial sums of this power series on the disk of convergence, i.e., `f (x + y)`\nis the locally uniform limit of `p.partialSum n y` there. -/\ntheorem HasFPowerSeriesWithinOnBall.tendstoLocallyUniformlyOn\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    TendstoLocallyUniformlyOn (fun n y => p.partialSum n y) (fun y => f (x + y)) atTop\n      ((x + ·)⁻¹' (insert x s) ∩ EMetric.ball (0 : E) r) := by\n  intro u hu y hy\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hy.2 with ⟨r', yr', hr'⟩\n  have : EMetric.ball (0 : E) r' ∈ 𝓝 y := IsOpen.mem_nhds EMetric.isOpen_ball yr'\n  refine ⟨(x + ·)⁻¹' (insert x s) ∩ EMetric.ball (0 : E) r', ?_, ?_⟩\n  · rw [nhdsWithin_inter_of_mem']\n    · exact inter_mem_nhdsWithin _ this\n    · apply mem_nhdsWithin_of_mem_nhds\n      apply Filter.mem_of_superset this (EMetric.ball_subset_ball hr'.le)\n  · simpa [Metric.emetric_ball_nnreal] using hf.tendstoUniformlyOn hr' u hu\n\n"}
{"name":"HasFPowerSeriesOnBall.tendstoLocallyUniformlyOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\n⊢ TendstoLocallyUniformlyOn (fun n y => p.partialSum n y) (fun y => f (HAdd.hAdd x y)) Filter.atTop (EMetric.ball 0 r)","decl":"/-- If a function admits a power series expansion at `x`, then it is the locally uniform limit of\nthe partial sums of this power series on the disk of convergence, i.e., `f (x + y)`\nis the locally uniform limit of `p.partialSum n y` there. -/\ntheorem HasFPowerSeriesOnBall.tendstoLocallyUniformlyOn (hf : HasFPowerSeriesOnBall f p x r) :\n    TendstoLocallyUniformlyOn (fun n y => p.partialSum n y) (fun y => f (x + y)) atTop\n      (EMetric.ball (0 : E) r) := by\n  rw [← hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.tendstoLocallyUniformlyOn\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.tendstoUniformlyOn'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nh : LT.lt (↑r') r\n⊢ TendstoUniformlyOn (fun n y => p.partialSum n (HSub.hSub y x)) f Filter.atTop (Inter.inter (Insert.insert x s) (Metric.ball x ↑r'))","decl":"/-- If a function admits a power series expansion within a set at `x`, then it is the uniform limit\nof the partial sums of this power series on strict subdisks of the disk of convergence, i.e., `f y`\nis the uniform limit of `p.partialSum n (y - x)` there. -/\ntheorem HasFPowerSeriesWithinOnBall.tendstoUniformlyOn' {r' : ℝ≥0}\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (h : (r' : ℝ≥0∞) < r) :\n    TendstoUniformlyOn (fun n y => p.partialSum n (y - x)) f atTop\n      (insert x s ∩ Metric.ball (x : E) r') := by\n  convert (hf.tendstoUniformlyOn h).comp fun y => y - x using 1\n  · simp [Function.comp_def]\n  · ext z\n    simp [dist_eq_norm]\n\n"}
{"name":"HasFPowerSeriesOnBall.tendstoUniformlyOn'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesOnBall f p x r\nh : LT.lt (↑r') r\n⊢ TendstoUniformlyOn (fun n y => p.partialSum n (HSub.hSub y x)) f Filter.atTop (Metric.ball x ↑r')","decl":"/-- If a function admits a power series expansion at `x`, then it is the uniform limit of the\npartial sums of this power series on strict subdisks of the disk of convergence, i.e., `f y`\nis the uniform limit of `p.partialSum n (y - x)` there. -/\ntheorem HasFPowerSeriesOnBall.tendstoUniformlyOn' {r' : ℝ≥0} (hf : HasFPowerSeriesOnBall f p x r)\n    (h : (r' : ℝ≥0∞) < r) :\n    TendstoUniformlyOn (fun n y => p.partialSum n (y - x)) f atTop (Metric.ball (x : E) r') := by\n  rw [← hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.tendstoUniformlyOn' h\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.tendstoLocallyUniformlyOn'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\n⊢ TendstoLocallyUniformlyOn (fun n y => p.partialSum n (HSub.hSub y x)) f Filter.atTop (Inter.inter (Insert.insert x s) (EMetric.ball x r))","decl":"/-- If a function admits a power series expansion within a set at `x`, then it is the locally\nuniform limit of the partial sums of this power series on the disk of convergence, i.e., `f y`\nis the locally uniform limit of `p.partialSum n (y - x)` there. -/\ntheorem HasFPowerSeriesWithinOnBall.tendstoLocallyUniformlyOn'\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    TendstoLocallyUniformlyOn (fun n y => p.partialSum n (y - x)) f atTop\n      (insert x s ∩ EMetric.ball (x : E) r) := by\n  have A : ContinuousOn (fun y : E => y - x) (insert x s ∩ EMetric.ball (x : E) r) :=\n    (continuous_id.sub continuous_const).continuousOn\n  convert hf.tendstoLocallyUniformlyOn.comp (fun y : E => y - x) _ A using 1\n  · ext z\n    simp\n  · intro z\n    simp [edist_zero_eq_enorm, edist_eq_enorm_sub]\n\n"}
{"name":"HasFPowerSeriesOnBall.tendstoLocallyUniformlyOn'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\n⊢ TendstoLocallyUniformlyOn (fun n y => p.partialSum n (HSub.hSub y x)) f Filter.atTop (EMetric.ball x r)","decl":"/-- If a function admits a power series expansion at `x`, then it is the locally uniform limit of\nthe partial sums of this power series on the disk of convergence, i.e., `f y`\nis the locally uniform limit of `p.partialSum n (y - x)` there. -/\ntheorem HasFPowerSeriesOnBall.tendstoLocallyUniformlyOn' (hf : HasFPowerSeriesOnBall f p x r) :\n    TendstoLocallyUniformlyOn (fun n y => p.partialSum n (y - x)) f atTop\n      (EMetric.ball (x : E) r) := by\n  rw [← hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.tendstoLocallyUniformlyOn'\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.continuousOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\n⊢ ContinuousOn f (Inter.inter (Insert.insert x s) (EMetric.ball x r))","decl":"/-- If a function admits a power series expansion within a set on a ball, then it is\ncontinuous there. -/\nprotected theorem HasFPowerSeriesWithinOnBall.continuousOn\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    ContinuousOn f (insert x s ∩ EMetric.ball x r) :=\n  hf.tendstoLocallyUniformlyOn'.continuousOn <|\n    Eventually.of_forall fun n =>\n      ((p.partialSum_continuous n).comp (continuous_id.sub continuous_const)).continuousOn\n\n"}
{"name":"HasFPowerSeriesOnBall.continuousOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\n⊢ ContinuousOn f (EMetric.ball x r)","decl":"/-- If a function admits a power series expansion on a ball, then it is continuous there. -/\nprotected theorem HasFPowerSeriesOnBall.continuousOn (hf : HasFPowerSeriesOnBall f p x r) :\n    ContinuousOn f (EMetric.ball x r) := by\n  rw [← hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.continuousOn\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.continuousWithinAt_insert","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\n⊢ ContinuousWithinAt f (Insert.insert x s) x","decl":"protected theorem HasFPowerSeriesWithinOnBall.continuousWithinAt_insert\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    ContinuousWithinAt f (insert x s) x := by\n  apply (hf.continuousOn.continuousWithinAt (x := x) (by simp [hf.r_pos])).mono_of_mem_nhdsWithin\n  exact inter_mem_nhdsWithin _ (EMetric.ball_mem_nhds x hf.r_pos)\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.continuousWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\n⊢ ContinuousWithinAt f s x","decl":"protected theorem HasFPowerSeriesWithinOnBall.continuousWithinAt\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    ContinuousWithinAt f s x :=\n  hf.continuousWithinAt_insert.mono (subset_insert x s)\n\n"}
{"name":"HasFPowerSeriesWithinAt.continuousWithinAt_insert","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\n⊢ ContinuousWithinAt f (Insert.insert x s) x","decl":"protected theorem HasFPowerSeriesWithinAt.continuousWithinAt_insert\n    (hf : HasFPowerSeriesWithinAt f p s x) :\n    ContinuousWithinAt f (insert x s) x := by\n  rcases hf with ⟨r, hr⟩\n  apply hr.continuousWithinAt_insert\n\n"}
{"name":"HasFPowerSeriesWithinAt.continuousWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\n⊢ ContinuousWithinAt f s x","decl":"protected theorem HasFPowerSeriesWithinAt.continuousWithinAt\n    (hf : HasFPowerSeriesWithinAt f p s x) :\n    ContinuousWithinAt f s x :=\n  hf.continuousWithinAt_insert.mono (subset_insert x s)\n\n"}
{"name":"HasFPowerSeriesAt.continuousAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nhf : HasFPowerSeriesAt f p x\n⊢ ContinuousAt f x","decl":"protected theorem HasFPowerSeriesAt.continuousAt (hf : HasFPowerSeriesAt f p x) :\n    ContinuousAt f x :=\n  let ⟨_, hr⟩ := hf\n  hr.continuousOn.continuousAt (EMetric.ball_mem_nhds x hr.r_pos)\n\n"}
{"name":"AnalyticWithinAt.continuousWithinAt_insert","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx : E\nhf : AnalyticWithinAt 𝕜 f s x\n⊢ ContinuousWithinAt f (Insert.insert x s) x","decl":"protected theorem AnalyticWithinAt.continuousWithinAt_insert (hf : AnalyticWithinAt 𝕜 f s x) :\n    ContinuousWithinAt f (insert x s) x :=\n  let ⟨_, hp⟩ := hf\n  hp.continuousWithinAt_insert\n\n"}
{"name":"AnalyticWithinAt.continuousWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx : E\nhf : AnalyticWithinAt 𝕜 f s x\n⊢ ContinuousWithinAt f s x","decl":"protected theorem AnalyticWithinAt.continuousWithinAt (hf : AnalyticWithinAt 𝕜 f s x) :\n    ContinuousWithinAt f s x :=\n  hf.continuousWithinAt_insert.mono (subset_insert x s)\n\n"}
{"name":"AnalyticAt.continuousAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nhf : AnalyticAt 𝕜 f x\n⊢ ContinuousAt f x","decl":"@[fun_prop]\nprotected theorem AnalyticAt.continuousAt (hf : AnalyticAt 𝕜 f x) : ContinuousAt f x :=\n  let ⟨_, hp⟩ := hf\n  hp.continuousAt\n\n"}
{"name":"AnalyticOnNhd.continuousOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nhf : AnalyticOnNhd 𝕜 f s\n⊢ ContinuousOn f s","decl":"protected theorem AnalyticOnNhd.continuousOn {s : Set E} (hf : AnalyticOnNhd 𝕜 f s) :\n    ContinuousOn f s :=\n  fun x hx => (hf x hx).continuousAt.continuousWithinAt\n\n"}
{"name":"AnalyticOn.continuousOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : AnalyticOn 𝕜 f s\n⊢ ContinuousOn f s","decl":"protected lemma AnalyticOn.continuousOn {f : E → F} {s : Set E} (h : AnalyticOn 𝕜 f s) :\n    ContinuousOn f s :=\n  fun x m ↦ (h x m).continuousWithinAt\n\n"}
{"name":"AnalyticWithinOn.continuousOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : AnalyticOn 𝕜 f s\n⊢ ContinuousOn f s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.continuousOn := AnalyticOn.continuousOn\n\n"}
{"name":"AnalyticOnNhd.continuous","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nfa : AnalyticOnNhd 𝕜 f Set.univ\n⊢ Continuous f","decl":"/-- Analytic everywhere implies continuous -/\ntheorem AnalyticOnNhd.continuous {f : E → F} (fa : AnalyticOnNhd 𝕜 f univ) : Continuous f := by\n  rw [continuous_iff_continuousOn_univ]; exact fa.continuousOn\n\n"}
{"name":"AnalyticOn.continuous","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nfa : AnalyticOnNhd 𝕜 f Set.univ\n⊢ Continuous f","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.continuous := AnalyticOnNhd.continuous\n\n"}
{"name":"FormalMultilinearSeries.hasFPowerSeriesOnBall","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\np : FormalMultilinearSeries 𝕜 E F\nh : LT.lt 0 p.radius\n⊢ HasFPowerSeriesOnBall p.sum p 0 p.radius","decl":"/-- In a complete space, the sum of a converging power series `p` admits `p` as a power series.\nThis is not totally obvious as we need to check the convergence of the series. -/\nprotected theorem FormalMultilinearSeries.hasFPowerSeriesOnBall [CompleteSpace F]\n    (p : FormalMultilinearSeries 𝕜 E F) (h : 0 < p.radius) :\n    HasFPowerSeriesOnBall p.sum p 0 p.radius :=\n  { r_le := le_rfl\n    r_pos := h\n    hasSum := fun hy => by\n      rw [zero_add]\n      exact p.hasSum hy }\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.sum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\nh : HasFPowerSeriesWithinOnBall f p s x r\ny : E\nh'y : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\nhy : Membership.mem (EMetric.ball 0 r) y\n⊢ Eq (f (HAdd.hAdd x y)) (p.sum y)","decl":"theorem HasFPowerSeriesWithinOnBall.sum (h : HasFPowerSeriesWithinOnBall f p s x r) {y : E}\n    (h'y : x + y ∈ insert x s) (hy : y ∈ EMetric.ball (0 : E) r) : f (x + y) = p.sum y :=\n  (h.hasSum h'y hy).tsum_eq.symm\n\n"}
{"name":"HasFPowerSeriesOnBall.sum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\nx : E\nr : ENNReal\nh : HasFPowerSeriesOnBall f p x r\ny : E\nhy : Membership.mem (EMetric.ball 0 r) y\n⊢ Eq (f (HAdd.hAdd x y)) (p.sum y)","decl":"theorem HasFPowerSeriesOnBall.sum (h : HasFPowerSeriesOnBall f p x r) {y : E}\n    (hy : y ∈ EMetric.ball (0 : E) r) : f (x + y) = p.sum y :=\n  (h.hasSum hy).tsum_eq.symm\n\n"}
{"name":"FormalMultilinearSeries.continuousOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : FormalMultilinearSeries 𝕜 E F\ninst✝ : CompleteSpace F\n⊢ ContinuousOn p.sum (EMetric.ball 0 p.radius)","decl":"/-- The sum of a converging power series is continuous in its disk of convergence. -/\nprotected theorem FormalMultilinearSeries.continuousOn [CompleteSpace F] :\n    ContinuousOn p.sum (EMetric.ball 0 p.radius) := by\n  rcases (zero_le p.radius).eq_or_lt with h | h\n  · simp [← h, continuousOn_empty]\n  · exact (p.hasFPowerSeriesOnBall h).continuousOn\n\n"}
{"name":"hasFPowerSeriesAt_iff","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\np : FormalMultilinearSeries 𝕜 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\n⊢ Iff (HasFPowerSeriesAt f p z₀) (Filter.Eventually (fun z => HasSum (fun n => HSMul.hSMul (HPow.hPow z n) (p.coeff n)) (f (HAdd.hAdd z₀ z))) (nhds 0))","decl":"/-- A function `f : 𝕜 → E` has `p` as power series expansion at a point `z₀` iff it is the sum of\n`p` in a neighborhood of `z₀`. This makes some proofs easier by hiding the fact that\n`HasFPowerSeriesAt` depends on `p.radius`. -/\ntheorem hasFPowerSeriesAt_iff :\n    HasFPowerSeriesAt f p z₀ ↔ ∀ᶠ z in 𝓝 0, HasSum (fun n => z ^ n • p.coeff n) (f (z₀ + z)) := by\n  refine ⟨fun ⟨r, _, r_pos, h⟩ =>\n    eventually_of_mem (EMetric.ball_mem_nhds 0 r_pos) fun _ => by simpa using h, ?_⟩\n  simp only [Metric.eventually_nhds_iff]\n  rintro ⟨r, r_pos, h⟩\n  refine ⟨p.radius ⊓ r.toNNReal, by simp, ?_, ?_⟩\n  · simp only [r_pos.lt, lt_inf_iff, ENNReal.coe_pos, Real.toNNReal_pos, and_true]\n    obtain ⟨z, z_pos, le_z⟩ := NormedField.exists_norm_lt 𝕜 r_pos.lt\n    have : (‖z‖₊ : ENNReal) ≤ p.radius := by\n      simp only [dist_zero_right] at h\n      apply FormalMultilinearSeries.le_radius_of_tendsto\n      convert tendsto_norm.comp (h le_z).summable.tendsto_atTop_zero\n      simp [norm_smul, mul_comm]\n    refine lt_of_lt_of_le ?_ this\n    simp only [ENNReal.coe_pos]\n    exact zero_lt_iff.mpr (nnnorm_ne_zero_iff.mpr (norm_pos_iff.mp z_pos))\n  · simp only [EMetric.mem_ball, lt_inf_iff, edist_lt_coe, apply_eq_pow_smul_coeff, and_imp,\n      dist_zero_right] at h ⊢\n    refine fun {y} _ hyr => h ?_\n    simpa [nndist_eq_nnnorm, Real.lt_toNNReal_iff_coe_lt] using hyr\n\n"}
{"name":"hasFPowerSeriesAt_iff'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\np : FormalMultilinearSeries 𝕜 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\n⊢ Iff (HasFPowerSeriesAt f p z₀) (Filter.Eventually (fun z => HasSum (fun n => HSMul.hSMul (HPow.hPow (HSub.hSub z z₀) n) (p.coeff n)) (f z)) (nhds z₀))","decl":"theorem hasFPowerSeriesAt_iff' :\n    HasFPowerSeriesAt f p z₀ ↔ ∀ᶠ z in 𝓝 z₀, HasSum (fun n => (z - z₀) ^ n • p.coeff n) (f z) := by\n  rw [← map_add_left_nhds_zero, eventually_map, hasFPowerSeriesAt_iff]\n  simp_rw [add_sub_cancel_left]\n\n"}
