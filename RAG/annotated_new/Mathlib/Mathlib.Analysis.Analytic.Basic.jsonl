{"name":"FormalMultilinearSeries.partialSum_continuous","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹â° : Ring ğ•œ\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ E\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : TopologicalSpace F\ninstâœÂ³ : TopologicalAddGroup E\ninstâœÂ² : TopologicalAddGroup F\ninstâœÂ¹ : ContinuousConstSMul ğ•œ E\ninstâœ : ContinuousConstSMul ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nâŠ¢ Continuous (p.partialSum n)","decl":"/-- The partial sums of a formal multilinear series are continuous. -/\ntheorem partialSum_continuous (p : FormalMultilinearSeries ğ•œ E F) (n : â„•) :\n    Continuous (p.partialSum n) := by\n  unfold partialSum -- Porting note: added\n  continuity\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_bound","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nC : Real\nr : NNReal\nh : âˆ€ (n : Nat), LE.le (HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)) C\nâŠ¢ LE.le (â†‘r) p.radius","decl":"/-- If `â€–pâ‚™â€– râ¿` is bounded in `n`, then the radius of `p` is at least `r`. -/\ntheorem le_radius_of_bound (C : â„) {r : â„â‰¥0} (h : âˆ€ n : â„•, â€–p nâ€– * (r : â„) ^ n â‰¤ C) :\n    (r : â„â‰¥0âˆ) â‰¤ p.radius :=\n  le_iSup_of_le r <| le_iSup_of_le C <| le_iSup (fun _ => (r : â„â‰¥0âˆ)) h\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_bound_nnreal","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nC r : NNReal\nh : âˆ€ (n : Nat), LE.le (HMul.hMul (NNNorm.nnnorm (p n)) (HPow.hPow r n)) C\nâŠ¢ LE.le (â†‘r) p.radius","decl":"/-- If `â€–pâ‚™â€– râ¿` is bounded in `n`, then the radius of `p` is at least `r`. -/\ntheorem le_radius_of_bound_nnreal (C : â„â‰¥0) {r : â„â‰¥0} (h : âˆ€ n : â„•, â€–p nâ€–â‚Š * r ^ n â‰¤ C) :\n    (r : â„â‰¥0âˆ) â‰¤ p.radius :=\n  p.le_radius_of_bound C fun n => mod_cast h n\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_isBigO","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nh : Asymptotics.IsBigO Filter.atTop (fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)) fun x => 1\nâŠ¢ LE.le (â†‘r) p.radius","decl":"/-- If `â€–pâ‚™â€– râ¿ = O(1)`, as `n â†’ âˆ`, then the radius of `p` is at least `r`. -/\ntheorem le_radius_of_isBigO (h : (fun n => â€–p nâ€– * (r : â„) ^ n) =O[atTop] fun _ => (1 : â„)) :\n    â†‘r â‰¤ p.radius :=\n  Exists.elim (isBigO_one_nat_atTop_iff.1 h) fun C hC =>\n    p.le_radius_of_bound C fun n => (le_abs_self _).trans (hC n)\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_eventually_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nC : Real\nh : Filter.Eventually (fun n => LE.le (HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)) C) Filter.atTop\nâŠ¢ LE.le (â†‘r) p.radius","decl":"theorem le_radius_of_eventually_le (C) (h : âˆ€á¶  n in atTop, â€–p nâ€– * (r : â„) ^ n â‰¤ C) :\n    â†‘r â‰¤ p.radius :=\n  p.le_radius_of_isBigO <| IsBigO.of_bound C <| h.mono fun n hn => by simpa\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_summable_nnnorm","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nh : Summable fun n => HMul.hMul (NNNorm.nnnorm (p n)) (HPow.hPow r n)\nâŠ¢ LE.le (â†‘r) p.radius","decl":"theorem le_radius_of_summable_nnnorm (h : Summable fun n => â€–p nâ€–â‚Š * r ^ n) : â†‘r â‰¤ p.radius :=\n  p.le_radius_of_bound_nnreal (âˆ‘' n, â€–p nâ€–â‚Š * r ^ n) fun _ => le_tsum' h _\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_summable","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nh : Summable fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)\nâŠ¢ LE.le (â†‘r) p.radius","decl":"theorem le_radius_of_summable (h : Summable fun n => â€–p nâ€– * (r : â„) ^ n) : â†‘r â‰¤ p.radius :=\n  p.le_radius_of_summable_nnnorm <| by\n    simp only [â† coe_nnnorm] at h\n    exact mod_cast h\n\n"}
{"name":"FormalMultilinearSeries.radius_eq_top_of_forall_nnreal_isBigO","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nh : âˆ€ (r : NNReal), Asymptotics.IsBigO Filter.atTop (fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)) fun x => 1\nâŠ¢ Eq p.radius Top.top","decl":"theorem radius_eq_top_of_forall_nnreal_isBigO\n    (h : âˆ€ r : â„â‰¥0, (fun n => â€–p nâ€– * (r : â„) ^ n) =O[atTop] fun _ => (1 : â„)) : p.radius = âˆ :=\n  ENNReal.eq_top_of_forall_nnreal_le fun r => p.le_radius_of_isBigO (h r)\n\n"}
{"name":"FormalMultilinearSeries.radius_eq_top_of_eventually_eq_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nh : Filter.Eventually (fun n => Eq (p n) 0) Filter.atTop\nâŠ¢ Eq p.radius Top.top","decl":"theorem radius_eq_top_of_eventually_eq_zero (h : âˆ€á¶  n in atTop, p n = 0) : p.radius = âˆ :=\n  p.radius_eq_top_of_forall_nnreal_isBigO fun r =>\n    (isBigO_zero _ _).congr' (h.mono fun n hn => by simp [hn]) EventuallyEq.rfl\n\n"}
{"name":"FormalMultilinearSeries.radius_eq_top_of_forall_image_add_eq_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nn : Nat\nhn : âˆ€ (m : Nat), Eq (p (HAdd.hAdd m n)) 0\nâŠ¢ Eq p.radius Top.top","decl":"theorem radius_eq_top_of_forall_image_add_eq_zero (n : â„•) (hn : âˆ€ m, p (m + n) = 0) :\n    p.radius = âˆ :=\n  p.radius_eq_top_of_eventually_eq_zero <|\n    mem_atTop_sets.2 âŸ¨n, fun _ hk => tsub_add_cancel_of_le hk â–¸ hn _âŸ©\n\n"}
{"name":"FormalMultilinearSeries.constFormalMultilinearSeries_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nv : F\nâŠ¢ Eq (constFormalMultilinearSeries ğ•œ E v).radius Top.top","decl":"@[simp]\ntheorem constFormalMultilinearSeries_radius {v : F} :\n    (constFormalMultilinearSeries ğ•œ E v).radius = âŠ¤ :=\n  (constFormalMultilinearSeries ğ•œ E v).radius_eq_top_of_forall_image_add_eq_zero 1\n    (by simp [constFormalMultilinearSeries])\n\n"}
{"name":"FormalMultilinearSeries.zero_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nâŠ¢ Eq (FormalMultilinearSeries.radius 0) Top.top","decl":"/-- `0` has infinite radius of convergence -/\n@[simp] lemma zero_radius : (0 : FormalMultilinearSeries ğ•œ E F).radius = âˆ := by\n  rw [â† constFormalMultilinearSeries_zero]\n  exact constFormalMultilinearSeries_radius\n\n"}
{"name":"FormalMultilinearSeries.isLittleO_of_lt_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nh : LT.lt (â†‘r) p.radius\nâŠ¢ Exists fun a => And (Membership.mem (Set.Ioo 0 1) a) (Asymptotics.IsLittleO Filter.atTop (fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)) fun x => HPow.hPow a x)","decl":"/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` tends to zero exponentially:\nfor some `0 < a < 1`, `â€–p nâ€– râ¿ = o(aâ¿)`. -/\ntheorem isLittleO_of_lt_radius (h : â†‘r < p.radius) :\n    âˆƒ a âˆˆ Ioo (0 : â„) 1, (fun n => â€–p nâ€– * (r : â„) ^ n) =o[atTop] (a ^ Â·) := by\n  have := (TFAE_exists_lt_isLittleO_pow (fun n => â€–p nâ€– * (r : â„) ^ n) 1).out 1 4\n  rw [this]\n  -- Porting note: was\n  -- rw [(TFAE_exists_lt_isLittleO_pow (fun n => â€–p nâ€– * (r : â„) ^ n) 1).out 1 4]\n  simp only [radius, lt_iSup_iff] at h\n  rcases h with âŸ¨t, C, hC, rtâŸ©\n  rw [ENNReal.coe_lt_coe, â† NNReal.coe_lt_coe] at rt\n  have : 0 < (t : â„) := r.coe_nonneg.trans_lt rt\n  rw [â† div_lt_one this] at rt\n  refine âŸ¨_, rt, C, Or.inr zero_lt_one, fun n => ?_âŸ©\n  calc\n    |â€–p nâ€– * (r : â„) ^ n| = â€–p nâ€– * (t : â„) ^ n * (r / t : â„) ^ n := by\n      field_simp [mul_right_comm, abs_mul]\n    _ â‰¤ C * (r / t : â„) ^ n := by gcongr; apply hC\n\n"}
{"name":"FormalMultilinearSeries.isLittleO_one_of_lt_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nh : LT.lt (â†‘r) p.radius\nâŠ¢ Asymptotics.IsLittleO Filter.atTop (fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)) fun x => 1","decl":"/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿ = o(1)`. -/\ntheorem isLittleO_one_of_lt_radius (h : â†‘r < p.radius) :\n    (fun n => â€–p nâ€– * (r : â„) ^ n) =o[atTop] (fun _ => 1 : â„• â†’ â„) :=\n  let âŸ¨_, ha, hpâŸ© := p.isLittleO_of_lt_radius h\n  hp.trans <| (isLittleO_pow_pow_of_lt_left ha.1.le ha.2).congr (fun _ => rfl) one_pow\n\n"}
{"name":"FormalMultilinearSeries.norm_mul_pow_le_mul_pow_of_lt_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nh : LT.lt (â†‘r) p.radius\nâŠ¢ Exists fun a => And (Membership.mem (Set.Ioo 0 1) a) (Exists fun C => And (GT.gt C 0) (âˆ€ (n : Nat), LE.le (HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)) (HMul.hMul C (HPow.hPow a n))))","decl":"/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` tends to zero exponentially:\nfor some `0 < a < 1` and `C > 0`, `â€–p nâ€– * r ^ n â‰¤ C * a ^ n`. -/\ntheorem norm_mul_pow_le_mul_pow_of_lt_radius (h : â†‘r < p.radius) :\n    âˆƒ a âˆˆ Ioo (0 : â„) 1, âˆƒ C > 0, âˆ€ n, â€–p nâ€– * (r : â„) ^ n â‰¤ C * a ^ n := by\n  -- Porting note: moved out of `rcases`\n  have := ((TFAE_exists_lt_isLittleO_pow (fun n => â€–p nâ€– * (r : â„) ^ n) 1).out 1 5).mp\n    (p.isLittleO_of_lt_radius h)\n  rcases this with âŸ¨a, ha, C, hC, HâŸ©\n  exact âŸ¨a, ha, C, hC, fun n => (le_abs_self _).trans (H n)âŸ©\n\n"}
{"name":"FormalMultilinearSeries.lt_radius_of_isBigO","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nhâ‚€ : Ne r 0\na : Real\nha : Membership.mem (Set.Ioo (-1) 1) a\nhp : Asymptotics.IsBigO Filter.atTop (fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)) fun x => HPow.hPow a x\nâŠ¢ LT.lt (â†‘r) p.radius","decl":"/-- If `r â‰  0` and `â€–pâ‚™â€– râ¿ = O(aâ¿)` for some `-1 < a < 1`, then `r < p.radius`. -/\ntheorem lt_radius_of_isBigO (hâ‚€ : r â‰  0) {a : â„} (ha : a âˆˆ Ioo (-1 : â„) 1)\n    (hp : (fun n => â€–p nâ€– * (r : â„) ^ n) =O[atTop] (a ^ Â·)) : â†‘r < p.radius := by\n  -- Porting note: moved out of `rcases`\n  have := ((TFAE_exists_lt_isLittleO_pow (fun n => â€–p nâ€– * (r : â„) ^ n) 1).out 2 5)\n  rcases this.mp âŸ¨a, ha, hpâŸ© with âŸ¨a, ha, C, hC, hpâŸ©\n  rw [â† pos_iff_ne_zero, â† NNReal.coe_pos] at hâ‚€\n  lift a to â„â‰¥0 using ha.1.le\n  have : (r : â„) < r / a := by\n    simpa only [div_one] using (div_lt_div_iff_of_pos_left hâ‚€ zero_lt_one ha.1).2 ha.2\n  norm_cast at this\n  rw [â† ENNReal.coe_lt_coe] at this\n  refine this.trans_le (p.le_radius_of_bound C fun n => ?_)\n  rw [NNReal.coe_div, div_pow, â† mul_div_assoc, div_le_iffâ‚€ (pow_pos ha.1 n)]\n  exact (le_abs_self _).trans (hp n)\n\n"}
{"name":"FormalMultilinearSeries.norm_mul_pow_le_of_lt_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nh : LT.lt (â†‘r) p.radius\nâŠ¢ Exists fun C => And (GT.gt C 0) (âˆ€ (n : Nat), LE.le (HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)) C)","decl":"/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` is bounded. -/\ntheorem norm_mul_pow_le_of_lt_radius (p : FormalMultilinearSeries ğ•œ E F) {r : â„â‰¥0}\n    (h : (r : â„â‰¥0âˆ) < p.radius) : âˆƒ C > 0, âˆ€ n, â€–p nâ€– * (r : â„) ^ n â‰¤ C :=\n  let âŸ¨_, ha, C, hC, hâŸ© := p.norm_mul_pow_le_mul_pow_of_lt_radius h\n  âŸ¨C, hC, fun n => (h n).trans <| mul_le_of_le_one_right hC.lt.le (pow_le_oneâ‚€ ha.1.le ha.2.le)âŸ©\n\n"}
{"name":"FormalMultilinearSeries.norm_le_div_pow_of_pos_of_lt_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nh0 : LT.lt 0 r\nh : LT.lt (â†‘r) p.radius\nâŠ¢ Exists fun C => And (GT.gt C 0) (âˆ€ (n : Nat), LE.le (Norm.norm (p n)) (HDiv.hDiv C (HPow.hPow (â†‘r) n)))","decl":"/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` is bounded. -/\ntheorem norm_le_div_pow_of_pos_of_lt_radius (p : FormalMultilinearSeries ğ•œ E F) {r : â„â‰¥0}\n    (h0 : 0 < r) (h : (r : â„â‰¥0âˆ) < p.radius) : âˆƒ C > 0, âˆ€ n, â€–p nâ€– â‰¤ C / (r : â„) ^ n :=\n  let âŸ¨C, hC, hpâŸ© := p.norm_mul_pow_le_of_lt_radius h\n  âŸ¨C, hC, fun n => Iff.mpr (le_div_iffâ‚€ (pow_pos h0 _)) (hp n)âŸ©\n\n"}
{"name":"FormalMultilinearSeries.nnnorm_mul_pow_le_of_lt_radius","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nh : LT.lt (â†‘r) p.radius\nâŠ¢ Exists fun C => And (GT.gt C 0) (âˆ€ (n : Nat), LE.le (HMul.hMul (NNNorm.nnnorm (p n)) (HPow.hPow r n)) C)","decl":"/-- For `r` strictly smaller than the radius of `p`, then `â€–pâ‚™â€– râ¿` is bounded. -/\ntheorem nnnorm_mul_pow_le_of_lt_radius (p : FormalMultilinearSeries ğ•œ E F) {r : â„â‰¥0}\n    (h : (r : â„â‰¥0âˆ) < p.radius) : âˆƒ C > 0, âˆ€ n, â€–p nâ€–â‚Š * r ^ n â‰¤ C :=\n  let âŸ¨C, hC, hpâŸ© := p.norm_mul_pow_le_of_lt_radius h\n  âŸ¨âŸ¨C, hC.lt.leâŸ©, hC, mod_cast hpâŸ©\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_tendsto","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nr : NNReal\np : FormalMultilinearSeries ğ•œ E F\nl : Real\nh : Filter.Tendsto (fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)) Filter.atTop (nhds l)\nâŠ¢ LE.le (â†‘r) p.radius","decl":"theorem le_radius_of_tendsto (p : FormalMultilinearSeries ğ•œ E F) {l : â„}\n    (h : Tendsto (fun n => â€–p nâ€– * (r : â„) ^ n) atTop (ğ“ l)) : â†‘r â‰¤ p.radius :=\n  p.le_radius_of_isBigO (h.isBigO_one _)\n\n"}
{"name":"FormalMultilinearSeries.le_radius_of_summable_norm","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nr : NNReal\np : FormalMultilinearSeries ğ•œ E F\nhs : Summable fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)\nâŠ¢ LE.le (â†‘r) p.radius","decl":"theorem le_radius_of_summable_norm (p : FormalMultilinearSeries ğ•œ E F)\n    (hs : Summable fun n => â€–p nâ€– * (r : â„) ^ n) : â†‘r â‰¤ p.radius :=\n  p.le_radius_of_tendsto hs.tendsto_atTop_zero\n\n"}
{"name":"FormalMultilinearSeries.not_summable_norm_of_radius_lt_nnnorm","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nh : LT.lt p.radius â†‘(NNNorm.nnnorm x)\nâŠ¢ Not (Summable fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (Norm.norm x) n))","decl":"theorem not_summable_norm_of_radius_lt_nnnorm (p : FormalMultilinearSeries ğ•œ E F) {x : E}\n    (h : p.radius < â€–xâ€–â‚Š) : Â¬Summable fun n => â€–p nâ€– * â€–xâ€– ^ n :=\n  fun hs => not_le_of_lt h (p.le_radius_of_summable_norm hs)\n\n"}
{"name":"FormalMultilinearSeries.summable_norm_mul_pow","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nh : LT.lt (â†‘r) p.radius\nâŠ¢ Summable fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)","decl":"theorem summable_norm_mul_pow (p : FormalMultilinearSeries ğ•œ E F) {r : â„â‰¥0} (h : â†‘r < p.radius) :\n    Summable fun n : â„• => â€–p nâ€– * (r : â„) ^ n := by\n  obtain âŸ¨a, ha : a âˆˆ Ioo (0 : â„) 1, C, - : 0 < C, hpâŸ© := p.norm_mul_pow_le_mul_pow_of_lt_radius h\n  exact .of_nonneg_of_le (fun n => mul_nonneg (norm_nonneg _) (pow_nonneg r.coe_nonneg _))\n    hp ((summable_geometric_of_lt_one ha.1.le ha.2).mul_left _)\n\n"}
{"name":"FormalMultilinearSeries.summable_norm_apply","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhx : Membership.mem (EMetric.ball 0 p.radius) x\nâŠ¢ Summable fun n => Norm.norm ((p n) fun x_1 => x)","decl":"theorem summable_norm_apply (p : FormalMultilinearSeries ğ•œ E F) {x : E}\n    (hx : x âˆˆ EMetric.ball (0 : E) p.radius) : Summable fun n : â„• => â€–p n fun _ => xâ€– := by\n  rw [mem_emetric_ball_zero_iff] at hx\n  refine .of_nonneg_of_le\n    (fun _ â†¦ norm_nonneg _) (fun n â†¦ ((p n).le_opNorm _).trans_eq ?_) (p.summable_norm_mul_pow hx)\n  simp\n\n"}
{"name":"FormalMultilinearSeries.summable_nnnorm_mul_pow","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nr : NNReal\nh : LT.lt (â†‘r) p.radius\nâŠ¢ Summable fun n => HMul.hMul (NNNorm.nnnorm (p n)) (HPow.hPow r n)","decl":"theorem summable_nnnorm_mul_pow (p : FormalMultilinearSeries ğ•œ E F) {r : â„â‰¥0} (h : â†‘r < p.radius) :\n    Summable fun n : â„• => â€–p nâ€–â‚Š * r ^ n := by\n  rw [â† NNReal.summable_coe]\n  push_cast\n  exact p.summable_norm_mul_pow h\n\n"}
{"name":"FormalMultilinearSeries.summable","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhx : Membership.mem (EMetric.ball 0 p.radius) x\nâŠ¢ Summable fun n => (p n) fun x_1 => x","decl":"protected theorem summable [CompleteSpace F] (p : FormalMultilinearSeries ğ•œ E F) {x : E}\n    (hx : x âˆˆ EMetric.ball (0 : E) p.radius) : Summable fun n : â„• => p n fun _ => x :=\n  (p.summable_norm_apply hx).of_norm\n\n"}
{"name":"FormalMultilinearSeries.radius_eq_top_of_summable_norm","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nhs : âˆ€ (r : NNReal), Summable fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n)\nâŠ¢ Eq p.radius Top.top","decl":"theorem radius_eq_top_of_summable_norm (p : FormalMultilinearSeries ğ•œ E F)\n    (hs : âˆ€ r : â„â‰¥0, Summable fun n => â€–p nâ€– * (r : â„) ^ n) : p.radius = âˆ :=\n  ENNReal.eq_top_of_forall_nnreal_le fun r => p.le_radius_of_summable_norm (hs r)\n\n"}
{"name":"FormalMultilinearSeries.radius_eq_top_iff_summable_norm","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nâŠ¢ Iff (Eq p.radius Top.top) (âˆ€ (r : NNReal), Summable fun n => HMul.hMul (Norm.norm (p n)) (HPow.hPow (â†‘r) n))","decl":"theorem radius_eq_top_iff_summable_norm (p : FormalMultilinearSeries ğ•œ E F) :\n    p.radius = âˆ â†” âˆ€ r : â„â‰¥0, Summable fun n => â€–p nâ€– * (r : â„) ^ n := by\n  constructor\n  Â· intro h r\n    obtain âŸ¨a, ha : a âˆˆ Ioo (0 : â„) 1, C, - : 0 < C, hpâŸ© := p.norm_mul_pow_le_mul_pow_of_lt_radius\n      (show (r : â„â‰¥0âˆ) < p.radius from h.symm â–¸ ENNReal.coe_lt_top)\n    refine .of_norm_bounded\n      (fun n â†¦ (C : â„) * a ^ n) ((summable_geometric_of_lt_one ha.1.le ha.2).mul_left _) fun n â†¦ ?_\n    specialize hp n\n    rwa [Real.norm_of_nonneg (mul_nonneg (norm_nonneg _) (pow_nonneg r.coe_nonneg n))]\n  Â· exact p.radius_eq_top_of_summable_norm\n\n"}
{"name":"FormalMultilinearSeries.le_mul_pow_of_radius_pos","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nh : LT.lt 0 p.radius\nâŠ¢ Exists fun C => Exists fun r => Exists fun x => Exists fun x => âˆ€ (n : Nat), LE.le (Norm.norm (p n)) (HMul.hMul C (HPow.hPow r n))","decl":"/-- If the radius of `p` is positive, then `â€–pâ‚™â€–` grows at most geometrically. -/\ntheorem le_mul_pow_of_radius_pos (p : FormalMultilinearSeries ğ•œ E F) (h : 0 < p.radius) :\n    âˆƒ (C r : _) (_ : 0 < C) (_ : 0 < r), âˆ€ n, â€–p nâ€– â‰¤ C * r ^ n := by\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 h with âŸ¨r, r0, rltâŸ©\n  have rpos : 0 < (r : â„) := by simp [ENNReal.coe_pos.1 r0]\n  rcases norm_le_div_pow_of_pos_of_lt_radius p rpos rlt with âŸ¨C, Cpos, hCpâŸ©\n  refine âŸ¨C, râ»Â¹, Cpos, by simp only [inv_pos, rpos], fun n => ?_âŸ©\n  -- Porting note: was `convert`\n  rw [inv_pow, â† div_eq_mul_inv]\n  exact hCp n\n\n"}
{"name":"FormalMultilinearSeries.radius_le_of_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\nğ•œ' : Type u_5\nE' : Type u_6\nF' : Type u_7\ninstâœâ´ : NontriviallyNormedField ğ•œ'\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•œ' E'\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•œ' F'\np : FormalMultilinearSeries ğ•œ E F\nq : FormalMultilinearSeries ğ•œ' E' F'\nh : âˆ€ (n : Nat), LE.le (Norm.norm (p n)) (Norm.norm (q n))\nâŠ¢ LE.le q.radius p.radius","decl":"lemma radius_le_of_le {ğ•œ' E' F' : Type*}\n    [NontriviallyNormedField ğ•œ'] [NormedAddCommGroup E'] [NormedSpace ğ•œ' E']\n    [NormedAddCommGroup F'] [NormedSpace ğ•œ' F']\n    {p : FormalMultilinearSeries ğ•œ E F} {q : FormalMultilinearSeries ğ•œ' E' F'}\n    (h : âˆ€ n, â€–p nâ€– â‰¤ â€–q nâ€–) : q.radius â‰¤ p.radius := by\n  apply le_of_forall_nnreal_lt (fun r hr â†¦ ?_)\n  rcases norm_mul_pow_le_of_lt_radius _ hr with âŸ¨C, -, hCâŸ©\n  apply le_radius_of_bound _ C (fun n â†¦ ?_)\n  apply le_trans _ (hC n)\n  gcongr\n  exact h n\n\n"}
{"name":"FormalMultilinearSeries.min_radius_le_radius_add","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np q : FormalMultilinearSeries ğ•œ E F\nâŠ¢ LE.le (Min.min p.radius q.radius) (HAdd.hAdd p q).radius","decl":"/-- The radius of the sum of two formal series is at least the minimum of their two radii. -/\ntheorem min_radius_le_radius_add (p q : FormalMultilinearSeries ğ•œ E F) :\n    min p.radius q.radius â‰¤ (p + q).radius := by\n  refine ENNReal.le_of_forall_nnreal_lt fun r hr => ?_\n  rw [lt_min_iff] at hr\n  have := ((p.isLittleO_one_of_lt_radius hr.1).add (q.isLittleO_one_of_lt_radius hr.2)).isBigO\n  refine (p + q).le_radius_of_isBigO ((isBigO_of_le _ fun n => ?_).trans this)\n  rw [â† add_mul, norm_mul, norm_mul, norm_norm]\n  exact mul_le_mul_of_nonneg_right ((norm_add_le _ _).trans (le_abs_self _)) (norm_nonneg _)\n\n"}
{"name":"FormalMultilinearSeries.radius_neg","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nâŠ¢ Eq (Neg.neg p).radius p.radius","decl":"@[simp]\ntheorem radius_neg (p : FormalMultilinearSeries ğ•œ E F) : (-p).radius = p.radius := by\n  simp only [radius, neg_apply, norm_neg]\n\n"}
{"name":"FormalMultilinearSeries.radius_le_smul","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nc : ğ•œ\nâŠ¢ LE.le p.radius (HSMul.hSMul c p).radius","decl":"theorem radius_le_smul {p : FormalMultilinearSeries ğ•œ E F} {c : ğ•œ} : p.radius â‰¤ (c â€¢ p).radius := by\n  simp only [radius, smul_apply]\n  refine iSup_mono fun r â†¦ iSup_mono' fun C â†¦ âŸ¨â€–câ€– * C, iSup_mono' fun h â†¦ ?_âŸ©\n  simp only [le_refl, exists_prop, and_true]\n  intro n\n  rw [norm_smul c (p n), mul_assoc]\n  gcongr\n  exact h n\n\n"}
{"name":"FormalMultilinearSeries.radius_smul_eq","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nc : ğ•œ\nhc : Ne c 0\nâŠ¢ Eq (HSMul.hSMul c p).radius p.radius","decl":"theorem radius_smul_eq (p : FormalMultilinearSeries ğ•œ E F) {c : ğ•œ}\n    (hc : c â‰  0) : (c â€¢ p).radius = p.radius := by\n  apply eq_of_le_of_le _ radius_le_smul\n  conv => rhs; rw [show p = câ»Â¹ â€¢ (c â€¢ p) by simp [smul_smul, inv_mul_cancelâ‚€ hc]]\n  apply radius_le_smul\n\n"}
{"name":"FormalMultilinearSeries.radius_shift","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\nâŠ¢ Eq p.shift.radius p.radius","decl":"@[simp]\ntheorem radius_shift (p : FormalMultilinearSeries ğ•œ E F) : p.shift.radius = p.radius := by\n  simp only [radius, shift, Nat.succ_eq_add_one, ContinuousMultilinearMap.curryRight_norm]\n  congr\n  ext r\n  apply eq_of_le_of_le\n  Â· apply iSup_mono'\n    intro C\n    use â€–p 0â€– âŠ” (C * r)\n    apply iSup_mono'\n    intro h\n    simp only [le_refl, le_sup_iff, exists_prop, and_true]\n    intro n\n    cases' n with m\n    Â· simp\n    right\n    rw [pow_succ, â† mul_assoc]\n    apply mul_le_mul_of_nonneg_right (h m) zero_le_coe\n  Â· apply iSup_mono'\n    intro C\n    use â€–p 1â€– âŠ” C / r\n    apply iSup_mono'\n    intro h\n    simp only [le_refl, le_sup_iff, exists_prop, and_true]\n    intro n\n    cases eq_zero_or_pos r with\n    | inl hr =>\n      rw [hr]\n      cases n <;> simp\n    | inr hr =>\n      right\n      rw [â† NNReal.coe_pos] at hr\n      specialize h (n + 1)\n      rw [le_div_iffâ‚€ hr]\n      rwa [pow_succ, â† mul_assoc] at h\n\n"}
{"name":"FormalMultilinearSeries.radius_unshift","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nz : F\nâŠ¢ Eq (p.unshift z).radius p.radius","decl":"@[simp]\ntheorem radius_unshift (p : FormalMultilinearSeries ğ•œ E (E â†’L[ğ•œ] F)) (z : F) :\n    (p.unshift z).radius = p.radius := by\n  rw [â† radius_shift, unshift_shift]\n\n"}
{"name":"FormalMultilinearSeries.hasSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhx : Membership.mem (EMetric.ball 0 p.radius) x\nâŠ¢ HasSum (fun n => (p n) fun x_1 => x) (p.sum x)","decl":"protected theorem hasSum [CompleteSpace F] (p : FormalMultilinearSeries ğ•œ E F) {x : E}\n    (hx : x âˆˆ EMetric.ball (0 : E) p.radius) : HasSum (fun n : â„• => p n fun _ => x) (p.sum x) :=\n  (p.summable hx).hasSum\n\n"}
{"name":"FormalMultilinearSeries.radius_le_radius_continuousLinearMap_comp","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\np : FormalMultilinearSeries ğ•œ E F\nf : ContinuousLinearMap (RingHom.id ğ•œ) F G\nâŠ¢ LE.le p.radius (f.compFormalMultilinearSeries p).radius","decl":"theorem radius_le_radius_continuousLinearMap_comp (p : FormalMultilinearSeries ğ•œ E F)\n    (f : F â†’L[ğ•œ] G) : p.radius â‰¤ (f.compFormalMultilinearSeries p).radius := by\n  refine ENNReal.le_of_forall_nnreal_lt fun r hr => ?_\n  apply le_radius_of_isBigO\n  apply (IsBigO.trans_isLittleO _ (p.isLittleO_one_of_lt_radius hr)).isBigO\n  refine IsBigO.mul (@IsBigOWith.isBigO _ _ _ _ _ â€–fâ€– _ _ _ ?_) (isBigO_refl _ _)\n  refine IsBigOWith.of_bound (Eventually.of_forall fun n => ?_)\n  simpa only [norm_norm] using f.norm_compContinuousMultilinearMap_le (p n)\n\n"}
{"name":"HasFPowerSeriesOnBall.r_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nself : HasFPowerSeriesOnBall f p x r\nâŠ¢ LE.le r p.radius","decl":"/-- Given a function `f : E â†’ F` and a formal multilinear series `p`, we say that `f` has `p` as\na power series on the ball of radius `r > 0` around `x` if `f (x + y) = âˆ‘' pâ‚™ yâ¿` for all `â€–yâ€– < r`.\n-/\nstructure HasFPowerSeriesOnBall (f : E â†’ F) (p : FormalMultilinearSeries ğ•œ E F) (x : E) (r : â„â‰¥0âˆ) :\n    Prop where\n  r_le : r â‰¤ p.radius\n  r_pos : 0 < r\n  hasSum :\n    âˆ€ {y}, y âˆˆ EMetric.ball (0 : E) r â†’ HasSum (fun n : â„• => p n fun _ : Fin n => y) (f (x + y))\n\n"}
{"name":"HasFPowerSeriesOnBall.r_pos","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nself : HasFPowerSeriesOnBall f p x r\nâŠ¢ LT.lt 0 r","decl":"/-- Given a function `f : E â†’ F` and a formal multilinear series `p`, we say that `f` has `p` as\na power series on the ball of radius `r > 0` around `x` if `f (x + y) = âˆ‘' pâ‚™ yâ¿` for all `â€–yâ€– < r`.\n-/\nstructure HasFPowerSeriesOnBall (f : E â†’ F) (p : FormalMultilinearSeries ğ•œ E F) (x : E) (r : â„â‰¥0âˆ) :\n    Prop where\n  r_le : r â‰¤ p.radius\n  r_pos : 0 < r\n  hasSum :\n    âˆ€ {y}, y âˆˆ EMetric.ball (0 : E) r â†’ HasSum (fun n : â„• => p n fun _ : Fin n => y) (f (x + y))\n\n"}
{"name":"HasFPowerSeriesOnBall.hasSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nself : HasFPowerSeriesOnBall f p x r\ny : E\naâœ : Membership.mem (EMetric.ball 0 r) y\nâŠ¢ HasSum (fun n => (p n) fun x => y) (f (HAdd.hAdd x y))","decl":"/-- Given a function `f : E â†’ F` and a formal multilinear series `p`, we say that `f` has `p` as\na power series on the ball of radius `r > 0` around `x` if `f (x + y) = âˆ‘' pâ‚™ yâ¿` for all `â€–yâ€– < r`.\n-/\nstructure HasFPowerSeriesOnBall (f : E â†’ F) (p : FormalMultilinearSeries ğ•œ E F) (x : E) (r : â„â‰¥0âˆ) :\n    Prop where\n  r_le : r â‰¤ p.radius\n  r_pos : 0 < r\n  hasSum :\n    âˆ€ {y}, y âˆˆ EMetric.ball (0 : E) r â†’ HasSum (fun n : â„• => p n fun _ : Fin n => y) (f (x + y))\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.r_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nself : HasFPowerSeriesWithinOnBall f p s x r\nâŠ¢ LE.le r p.radius","decl":"/-- Analogue of `HasFPowerSeriesOnBall` where convergence is required only on a set `s`. We also\nrequire convergence at `x` as the behavior of this notion is very bad otherwise. -/\nstructure HasFPowerSeriesWithinOnBall (f : E â†’ F) (p : FormalMultilinearSeries ğ•œ E F) (s : Set E)\n    (x : E) (r : â„â‰¥0âˆ) : Prop where\n  /-- `p` converges on `ball 0 r` -/\n  r_le : r â‰¤ p.radius\n  /-- The radius of convergence is positive -/\n  r_pos : 0 < r\n  /-- `p converges to f` within `s` -/\n  hasSum : âˆ€ {y}, x + y âˆˆ insert x s â†’ y âˆˆ EMetric.ball (0 : E) r â†’\n    HasSum (fun n : â„• => p n fun _ : Fin n => y) (f (x + y))\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.r_pos","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nself : HasFPowerSeriesWithinOnBall f p s x r\nâŠ¢ LT.lt 0 r","decl":"/-- Analogue of `HasFPowerSeriesOnBall` where convergence is required only on a set `s`. We also\nrequire convergence at `x` as the behavior of this notion is very bad otherwise. -/\nstructure HasFPowerSeriesWithinOnBall (f : E â†’ F) (p : FormalMultilinearSeries ğ•œ E F) (s : Set E)\n    (x : E) (r : â„â‰¥0âˆ) : Prop where\n  /-- `p` converges on `ball 0 r` -/\n  r_le : r â‰¤ p.radius\n  /-- The radius of convergence is positive -/\n  r_pos : 0 < r\n  /-- `p converges to f` within `s` -/\n  hasSum : âˆ€ {y}, x + y âˆˆ insert x s â†’ y âˆˆ EMetric.ball (0 : E) r â†’\n    HasSum (fun n : â„• => p n fun _ : Fin n => y) (f (x + y))\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.hasSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nself : HasFPowerSeriesWithinOnBall f p s x r\ny : E\naâœÂ¹ : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\naâœ : Membership.mem (EMetric.ball 0 r) y\nâŠ¢ HasSum (fun n => (p n) fun x => y) (f (HAdd.hAdd x y))","decl":"/-- Analogue of `HasFPowerSeriesOnBall` where convergence is required only on a set `s`. We also\nrequire convergence at `x` as the behavior of this notion is very bad otherwise. -/\nstructure HasFPowerSeriesWithinOnBall (f : E â†’ F) (p : FormalMultilinearSeries ğ•œ E F) (s : Set E)\n    (x : E) (r : â„â‰¥0âˆ) : Prop where\n  /-- `p` converges on `ball 0 r` -/\n  r_le : r â‰¤ p.radius\n  /-- The radius of convergence is positive -/\n  r_pos : 0 < r\n  /-- `p converges to f` within `s` -/\n  hasSum : âˆ€ {y}, x + y âˆˆ insert x s â†’ y âˆˆ EMetric.ball (0 : E) r â†’\n    HasSum (fun n : â„• => p n fun _ : Fin n => y) (f (x + y))\n\n"}
{"name":"HasFPowerSeriesOnBall.hasFPowerSeriesAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nâŠ¢ HasFPowerSeriesAt f p x","decl":"theorem HasFPowerSeriesOnBall.hasFPowerSeriesAt (hf : HasFPowerSeriesOnBall f p x r) :\n    HasFPowerSeriesAt f p x :=\n  âŸ¨r, hfâŸ©\n\n"}
{"name":"HasFPowerSeriesAt.analyticAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f p x\nâŠ¢ AnalyticAt ğ•œ f x","decl":"theorem HasFPowerSeriesAt.analyticAt (hf : HasFPowerSeriesAt f p x) : AnalyticAt ğ•œ f x :=\n  âŸ¨p, hfâŸ©\n\n"}
{"name":"HasFPowerSeriesOnBall.analyticAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nâŠ¢ AnalyticAt ğ•œ f x","decl":"theorem HasFPowerSeriesOnBall.analyticAt (hf : HasFPowerSeriesOnBall f p x r) : AnalyticAt ğ•œ f x :=\n  hf.hasFPowerSeriesAt.analyticAt\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.hasFPowerSeriesWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nâŠ¢ HasFPowerSeriesWithinAt f p s x","decl":"theorem HasFPowerSeriesWithinOnBall.hasFPowerSeriesWithinAt\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) : HasFPowerSeriesWithinAt f p s x :=\n  âŸ¨r, hfâŸ©\n\n"}
{"name":"HasFPowerSeriesWithinAt.analyticWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\nâŠ¢ AnalyticWithinAt ğ•œ f s x","decl":"theorem HasFPowerSeriesWithinAt.analyticWithinAt (hf : HasFPowerSeriesWithinAt f p s x) :\n    AnalyticWithinAt ğ•œ f s x := âŸ¨p, hfâŸ©\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.analyticWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nâŠ¢ AnalyticWithinAt ğ•œ f s x","decl":"theorem HasFPowerSeriesWithinOnBall.analyticWithinAt (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    AnalyticWithinAt ğ•œ f s x :=\n  hf.hasFPowerSeriesWithinAt.analyticWithinAt\n\n"}
{"name":"HasFPowerSeriesOnBall.comp_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\ny : E\nâŠ¢ HasFPowerSeriesOnBall (fun z => f (HSub.hSub z y)) p (HAdd.hAdd x y) r","decl":"/-- If a function `f` has a power series `p` around `x`, then the function `z â†¦ f (z - y)` has the\nsame power series around `x + y`. -/\ntheorem HasFPowerSeriesOnBall.comp_sub (hf : HasFPowerSeriesOnBall f p x r) (y : E) :\n    HasFPowerSeriesOnBall (fun z => f (z - y)) p (x + y) r :=\n  { r_le := hf.r_le\n    r_pos := hf.r_pos\n    hasSum := fun {z} hz => by\n      convert hf.hasSum hz using 2\n      abel }\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.hasSum_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\ny : E\nhy : Membership.mem (Inter.inter (Insert.insert x s) (EMetric.ball x r)) y\nâŠ¢ HasSum (fun n => (p n) fun x_1 => HSub.hSub y x) (f y)","decl":"theorem HasFPowerSeriesWithinOnBall.hasSum_sub (hf : HasFPowerSeriesWithinOnBall f p s x r) {y : E}\n    (hy : y âˆˆ (insert x s) âˆ© EMetric.ball x r) :\n    HasSum (fun n : â„• => p n fun _ => y - x) (f y) := by\n  have : y - x âˆˆ EMetric.ball (0 : E) r := by simpa [edist_eq_enorm_sub] using hy.2\n  have := hf.hasSum (by simpa only [add_sub_cancel] using hy.1) this\n  simpa only [add_sub_cancel]\n\n"}
{"name":"HasFPowerSeriesOnBall.hasSum_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\ny : E\nhy : Membership.mem (EMetric.ball x r) y\nâŠ¢ HasSum (fun n => (p n) fun x_1 => HSub.hSub y x) (f y)","decl":"theorem HasFPowerSeriesOnBall.hasSum_sub (hf : HasFPowerSeriesOnBall f p x r) {y : E}\n    (hy : y âˆˆ EMetric.ball x r) : HasSum (fun n : â„• => p n fun _ => y - x) (f y) := by\n  have : y - x âˆˆ EMetric.ball (0 : E) r := by simpa [edist_eq_enorm_sub] using hy\n  simpa only [add_sub_cancel] using hf.hasSum this\n\n"}
{"name":"HasFPowerSeriesOnBall.radius_pos","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nâŠ¢ LT.lt 0 p.radius","decl":"theorem HasFPowerSeriesOnBall.radius_pos (hf : HasFPowerSeriesOnBall f p x r) : 0 < p.radius :=\n  lt_of_lt_of_le hf.r_pos hf.r_le\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.radius_pos","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nâŠ¢ LT.lt 0 p.radius","decl":"theorem HasFPowerSeriesWithinOnBall.radius_pos (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    0 < p.radius :=\n  lt_of_lt_of_le hf.r_pos hf.r_le\n\n"}
{"name":"HasFPowerSeriesAt.radius_pos","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f p x\nâŠ¢ LT.lt 0 p.radius","decl":"theorem HasFPowerSeriesAt.radius_pos (hf : HasFPowerSeriesAt f p x) : 0 < p.radius :=\n  let âŸ¨_, hrâŸ© := hf\n  hr.radius_pos\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.of_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr r' : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nr'_pos : LT.lt 0 r'\nhr : LE.le r' r\nâŠ¢ HasFPowerSeriesWithinOnBall f p s x r'","decl":"theorem HasFPowerSeriesWithinOnBall.of_le\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (r'_pos : 0 < r') (hr : r' â‰¤ r) :\n    HasFPowerSeriesWithinOnBall f p s x r' :=\n  âŸ¨le_trans hr hf.1, r'_pos, fun hy h'y => hf.hasSum hy (EMetric.ball_subset_ball hr h'y)âŸ©\n\n"}
{"name":"HasFPowerSeriesOnBall.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr r' : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nr'_pos : LT.lt 0 r'\nhr : LE.le r' r\nâŠ¢ HasFPowerSeriesOnBall f p x r'","decl":"theorem HasFPowerSeriesOnBall.mono (hf : HasFPowerSeriesOnBall f p x r) (r'_pos : 0 < r')\n    (hr : r' â‰¤ r) : HasFPowerSeriesOnBall f p x r' :=\n  âŸ¨le_trans hr hf.1, r'_pos, fun hy => hf.hasSum (EMetric.ball_subset_ball hr hy)âŸ©\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nh : HasFPowerSeriesWithinOnBall f p s x r\nh' : Set.EqOn g f (Inter.inter s (EMetric.ball x r))\nh'' : Eq (g x) (f x)\nâŠ¢ HasFPowerSeriesWithinOnBall g p s x r","decl":"lemma HasFPowerSeriesWithinOnBall.congr {f g : E â†’ F} {p : FormalMultilinearSeries ğ•œ E F}\n    {s : Set E} {x : E} {r : â„â‰¥0âˆ} (h : HasFPowerSeriesWithinOnBall f p s x r)\n    (h' : EqOn g f (s âˆ© EMetric.ball x r)) (h'' : g x = f x) :\n    HasFPowerSeriesWithinOnBall g p s x r := by\n  refine âŸ¨h.r_le, h.r_pos, ?_âŸ©\n  intro y hy h'y\n  convert h.hasSum hy h'y using 1\n  simp only [mem_insert_iff, add_right_eq_self] at hy\n  rcases hy with rfl | hy\n  Â· simpa using h''\n  Â· apply h'\n    refine âŸ¨hy, ?_âŸ©\n    simpa [edist_eq_enorm_sub] using h'y\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.congr'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nh : HasFPowerSeriesWithinOnBall f p s x r\nh' : Set.EqOn g f (Inter.inter (Insert.insert x s) (EMetric.ball x r))\nâŠ¢ HasFPowerSeriesWithinOnBall g p s x r","decl":"/-- Variant of `HasFPowerSeriesWithinOnBall.congr` in which one requests equality on `insert x s`\ninstead of separating `x` and `s`. -/\nlemma HasFPowerSeriesWithinOnBall.congr' {f g : E â†’ F} {p : FormalMultilinearSeries ğ•œ E F}\n    {s : Set E} {x : E} {r : â„â‰¥0âˆ} (h : HasFPowerSeriesWithinOnBall f p s x r)\n    (h' : EqOn g f (insert x s âˆ© EMetric.ball x r)) :\n    HasFPowerSeriesWithinOnBall g p s x r := by\n  refine âŸ¨h.r_le, h.r_pos, fun {y} hy h'y â†¦ ?_âŸ©\n  convert h.hasSum hy h'y using 1\n  exact h' âŸ¨hy, by simpa [edist_eq_enorm_sub] using h'yâŸ©\n\n"}
{"name":"HasFPowerSeriesWithinAt.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nh : HasFPowerSeriesWithinAt f p s x\nh' : (nhdsWithin x s).EventuallyEq g f\nh'' : Eq (g x) (f x)\nâŠ¢ HasFPowerSeriesWithinAt g p s x","decl":"lemma HasFPowerSeriesWithinAt.congr {f g : E â†’ F} {p : FormalMultilinearSeries ğ•œ E F} {s : Set E}\n    {x : E} (h : HasFPowerSeriesWithinAt f p s x) (h' : g =á¶ [ğ“[s] x] f) (h'' : g x = f x) :\n    HasFPowerSeriesWithinAt g p s x := by\n  rcases h with âŸ¨r, hrâŸ©\n  obtain âŸ¨Îµ, Îµpos, hÎµâŸ© : âˆƒ Îµ > 0, EMetric.ball x Îµ âˆ© s âŠ† {y | g y = f y} :=\n    EMetric.mem_nhdsWithin_iff.1 h'\n  let r' := min r Îµ\n  refine âŸ¨r', ?_âŸ©\n  have := hr.of_le (r' := r') (by simp [r', Îµpos, hr.r_pos]) (min_le_left _ _)\n  apply this.congr _ h''\n  intro z hz\n  exact hÎµ âŸ¨EMetric.ball_subset_ball (min_le_right _ _) hz.2, hz.1âŸ©\n\n"}
{"name":"HasFPowerSeriesOnBall.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nhg : Set.EqOn f g (EMetric.ball x r)\nâŠ¢ HasFPowerSeriesOnBall g p x r","decl":"theorem HasFPowerSeriesOnBall.congr (hf : HasFPowerSeriesOnBall f p x r)\n    (hg : EqOn f g (EMetric.ball x r)) : HasFPowerSeriesOnBall g p x r :=\n  { r_le := hf.r_le\n    r_pos := hf.r_pos\n    hasSum := fun {y} hy => by\n      convert hf.hasSum hy using 1\n      apply hg.symm\n      simpa [edist_eq_enorm_sub] using hy }\n\n"}
{"name":"HasFPowerSeriesAt.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f p x\nhg : (nhds x).EventuallyEq f g\nâŠ¢ HasFPowerSeriesAt g p x","decl":"theorem HasFPowerSeriesAt.congr (hf : HasFPowerSeriesAt f p x) (hg : f =á¶ [ğ“ x] g) :\n    HasFPowerSeriesAt g p x := by\n  rcases hf with âŸ¨râ‚, hâ‚âŸ©\n  rcases EMetric.mem_nhds_iff.mp hg with âŸ¨râ‚‚, hâ‚‚pos, hâ‚‚âŸ©\n  exact âŸ¨min râ‚ râ‚‚,\n    (hâ‚.mono (lt_min hâ‚.r_pos hâ‚‚pos) inf_le_left).congr\n      fun y hy => hâ‚‚ (EMetric.ball_subset_ball inf_le_right hy)âŸ©\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.unique","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nhg : HasFPowerSeriesWithinOnBall g p s x r\nâŠ¢ Set.EqOn f g (Inter.inter (Insert.insert x s) (EMetric.ball x r))","decl":"theorem HasFPowerSeriesWithinOnBall.unique (hf : HasFPowerSeriesWithinOnBall f p s x r)\n    (hg : HasFPowerSeriesWithinOnBall g p s x r) :\n    (insert x s âˆ© EMetric.ball x r).EqOn f g := fun _ hy â†¦\n  (hf.hasSum_sub hy).unique (hg.hasSum_sub hy)\n\n"}
{"name":"HasFPowerSeriesOnBall.unique","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nhg : HasFPowerSeriesOnBall g p x r\nâŠ¢ Set.EqOn f g (EMetric.ball x r)","decl":"theorem HasFPowerSeriesOnBall.unique (hf : HasFPowerSeriesOnBall f p x r)\n    (hg : HasFPowerSeriesOnBall g p x r) : (EMetric.ball x r).EqOn f g := fun _ hy â†¦\n  (hf.hasSum_sub hy).unique (hg.hasSum_sub hy)\n\n"}
{"name":"HasFPowerSeriesWithinAt.eventually","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\nâŠ¢ Filter.Eventually (fun r => HasFPowerSeriesWithinOnBall f p s x r) (nhdsWithin 0 (Set.Ioi 0))","decl":"protected theorem HasFPowerSeriesWithinAt.eventually (hf : HasFPowerSeriesWithinAt f p s x) :\n    âˆ€á¶  r : â„â‰¥0âˆ in ğ“[>] 0, HasFPowerSeriesWithinOnBall f p s x r :=\n  let âŸ¨_, hrâŸ© := hf\n  mem_of_superset (Ioo_mem_nhdsGT hr.r_pos) fun _ hr' => hr.of_le hr'.1 hr'.2.le\n\n"}
{"name":"HasFPowerSeriesAt.eventually","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f p x\nâŠ¢ Filter.Eventually (fun r => HasFPowerSeriesOnBall f p x r) (nhdsWithin 0 (Set.Ioi 0))","decl":"protected theorem HasFPowerSeriesAt.eventually (hf : HasFPowerSeriesAt f p x) :\n    âˆ€á¶  r : â„â‰¥0âˆ in ğ“[>] 0, HasFPowerSeriesOnBall f p x r :=\n  let âŸ¨_, hrâŸ© := hf\n  mem_of_superset (Ioo_mem_nhdsGT hr.r_pos) fun _ hr' => hr.mono hr'.1 hr'.2.le\n\n"}
{"name":"HasFPowerSeriesOnBall.eventually_hasSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nâŠ¢ Filter.Eventually (fun y => HasSum (fun n => (p n) fun x => y) (f (HAdd.hAdd x y))) (nhds 0)","decl":"theorem HasFPowerSeriesOnBall.eventually_hasSum (hf : HasFPowerSeriesOnBall f p x r) :\n    âˆ€á¶  y in ğ“ 0, HasSum (fun n : â„• => p n fun _ : Fin n => y) (f (x + y)) := by\n  filter_upwards [EMetric.ball_mem_nhds (0 : E) hf.r_pos] using fun _ => hf.hasSum\n\n"}
{"name":"HasFPowerSeriesAt.eventually_hasSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f p x\nâŠ¢ Filter.Eventually (fun y => HasSum (fun n => (p n) fun x => y) (f (HAdd.hAdd x y))) (nhds 0)","decl":"theorem HasFPowerSeriesAt.eventually_hasSum (hf : HasFPowerSeriesAt f p x) :\n    âˆ€á¶  y in ğ“ 0, HasSum (fun n : â„• => p n fun _ : Fin n => y) (f (x + y)) :=\n  let âŸ¨_, hrâŸ© := hf\n  hr.eventually_hasSum\n\n"}
{"name":"HasFPowerSeriesOnBall.eventually_hasSum_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nâŠ¢ Filter.Eventually (fun y => HasSum (fun n => (p n) fun x_1 => HSub.hSub y x) (f y)) (nhds x)","decl":"theorem HasFPowerSeriesOnBall.eventually_hasSum_sub (hf : HasFPowerSeriesOnBall f p x r) :\n    âˆ€á¶  y in ğ“ x, HasSum (fun n : â„• => p n fun _ : Fin n => y - x) (f y) := by\n  filter_upwards [EMetric.ball_mem_nhds x hf.r_pos] with y using hf.hasSum_sub\n\n"}
{"name":"HasFPowerSeriesAt.eventually_hasSum_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f p x\nâŠ¢ Filter.Eventually (fun y => HasSum (fun n => (p n) fun x_1 => HSub.hSub y x) (f y)) (nhds x)","decl":"theorem HasFPowerSeriesAt.eventually_hasSum_sub (hf : HasFPowerSeriesAt f p x) :\n    âˆ€á¶  y in ğ“ x, HasSum (fun n : â„• => p n fun _ : Fin n => y - x) (f y) :=\n  let âŸ¨_, hrâŸ© := hf\n  hr.eventually_hasSum_sub\n\n"}
{"name":"HasFPowerSeriesOnBall.eventually_eq_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f 0 x r\nâŠ¢ Filter.Eventually (fun z => Eq (f z) 0) (nhds x)","decl":"theorem HasFPowerSeriesOnBall.eventually_eq_zero\n    (hf : HasFPowerSeriesOnBall f (0 : FormalMultilinearSeries ğ•œ E F) x r) :\n    âˆ€á¶  z in ğ“ x, f z = 0 := by\n  filter_upwards [hf.eventually_hasSum_sub] with z hz using hz.unique hasSum_zero\n\n"}
{"name":"HasFPowerSeriesAt.eventually_eq_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nhf : HasFPowerSeriesAt f 0 x\nâŠ¢ Filter.Eventually (fun z => Eq (f z) 0) (nhds x)","decl":"theorem HasFPowerSeriesAt.eventually_eq_zero\n    (hf : HasFPowerSeriesAt f (0 : FormalMultilinearSeries ğ•œ E F) x) : âˆ€á¶  z in ğ“ x, f z = 0 :=\n  let âŸ¨_, hrâŸ© := hf\n  hr.eventually_eq_zero\n\n"}
{"name":"hasFPowerSeriesWithinOnBall_univ","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nâŠ¢ Iff (HasFPowerSeriesWithinOnBall f p Set.univ x r) (HasFPowerSeriesOnBall f p x r)","decl":"@[simp] lemma hasFPowerSeriesWithinOnBall_univ :\n    HasFPowerSeriesWithinOnBall f p univ x r â†” HasFPowerSeriesOnBall f p x r := by\n  constructor\n  Â· intro h\n    refine âŸ¨h.r_le, h.r_pos, fun {y} m â†¦ h.hasSum (by simp) mâŸ©\n  Â· intro h\n    exact âŸ¨h.r_le, h.r_pos, fun {y} _ m => h.hasSum mâŸ©\n\n"}
{"name":"hasFPowerSeriesWithinAt_univ","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nâŠ¢ Iff (HasFPowerSeriesWithinAt f p Set.univ x) (HasFPowerSeriesAt f p x)","decl":"@[simp] lemma hasFPowerSeriesWithinAt_univ :\n    HasFPowerSeriesWithinAt f p univ x â†” HasFPowerSeriesAt f p x := by\n  simp only [HasFPowerSeriesWithinAt, hasFPowerSeriesWithinOnBall_univ, HasFPowerSeriesAt]\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns t : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nh : HasSubset.Subset t s\nâŠ¢ HasFPowerSeriesWithinOnBall f p t x r","decl":"lemma HasFPowerSeriesWithinOnBall.mono (hf : HasFPowerSeriesWithinOnBall f p s x r) (h : t âŠ† s) :\n    HasFPowerSeriesWithinOnBall f p t x r where\n  r_le := hf.r_le\n  r_pos := hf.r_pos\n  hasSum hy h'y := hf.hasSum (insert_subset_insert h hy) h'y\n\n"}
{"name":"HasFPowerSeriesOnBall.hasFPowerSeriesWithinOnBall","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nâŠ¢ HasFPowerSeriesWithinOnBall f p s x r","decl":"lemma HasFPowerSeriesOnBall.hasFPowerSeriesWithinOnBall (hf : HasFPowerSeriesOnBall f p x r) :\n    HasFPowerSeriesWithinOnBall f p s x r := by\n  rw [â† hasFPowerSeriesWithinOnBall_univ] at hf\n  exact hf.mono (subset_univ _)\n\n"}
{"name":"HasFPowerSeriesWithinAt.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns t : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\nh : HasSubset.Subset t s\nâŠ¢ HasFPowerSeriesWithinAt f p t x","decl":"lemma HasFPowerSeriesWithinAt.mono (hf : HasFPowerSeriesWithinAt f p s x) (h : t âŠ† s) :\n    HasFPowerSeriesWithinAt f p t x := by\n  obtain âŸ¨r, hpâŸ© := hf\n  exact âŸ¨r, hp.mono hâŸ©\n\n"}
{"name":"HasFPowerSeriesAt.hasFPowerSeriesWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nhf : HasFPowerSeriesAt f p x\nâŠ¢ HasFPowerSeriesWithinAt f p s x","decl":"lemma HasFPowerSeriesAt.hasFPowerSeriesWithinAt (hf : HasFPowerSeriesAt f p x) :\n    HasFPowerSeriesWithinAt f p s x := by\n  rw [â† hasFPowerSeriesWithinAt_univ] at hf\n  apply hf.mono (subset_univ _)\n\n"}
{"name":"HasFPowerSeriesWithinAt.mono_of_mem_nhdsWithin","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns t : Set E\nx : E\nh : HasFPowerSeriesWithinAt f p s x\nhst : Membership.mem (nhdsWithin x t) s\nâŠ¢ HasFPowerSeriesWithinAt f p t x","decl":"theorem HasFPowerSeriesWithinAt.mono_of_mem_nhdsWithin\n    (h : HasFPowerSeriesWithinAt f p s x) (hst : s âˆˆ ğ“[t] x) :\n    HasFPowerSeriesWithinAt f p t x := by\n  rcases h with âŸ¨r, hrâŸ©\n  rcases EMetric.mem_nhdsWithin_iff.1 hst with âŸ¨r', r'_pos, hr'âŸ©\n  refine âŸ¨min r r', ?_âŸ©\n  have Z := hr.of_le (by simp [r'_pos, hr.r_pos]) (min_le_left r r')\n  refine âŸ¨Z.r_le, Z.r_pos, fun {y} hy h'y â†¦ ?_âŸ©\n  apply Z.hasSum ?_ h'y\n  simp only [mem_insert_iff, add_right_eq_self] at hy\n  rcases hy with rfl | hy\n  Â· simp\n  apply mem_insert_of_mem _ (hr' ?_)\n  simp only [EMetric.mem_ball, edist_eq_enorm_sub, sub_zero, lt_min_iff, mem_inter_iff,\n    add_sub_cancel_left, hy, and_true] at h'y âŠ¢\n  exact h'y.2\n\n"}
{"name":"HasFPowerSeriesWithinAt.mono_of_mem","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns t : Set E\nx : E\nh : HasFPowerSeriesWithinAt f p s x\nhst : Membership.mem (nhdsWithin x t) s\nâŠ¢ HasFPowerSeriesWithinAt f p t x","decl":"@[deprecated (since := \"2024-10-31\")]\nalias HasFPowerSeriesWithinAt.mono_of_mem := HasFPowerSeriesWithinAt.mono_of_mem_nhdsWithin\n\n"}
{"name":"hasFPowerSeriesWithinOnBall_insert_self","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nâŠ¢ Iff (HasFPowerSeriesWithinOnBall f p (Insert.insert x s) x r) (HasFPowerSeriesWithinOnBall f p s x r)","decl":"@[simp] lemma hasFPowerSeriesWithinOnBall_insert_self :\n    HasFPowerSeriesWithinOnBall f p (insert x s) x r â†” HasFPowerSeriesWithinOnBall f p s x r := by\n  refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©  <;>\n  exact âŸ¨h.r_le, h.r_pos, fun {y} â†¦ by simpa only [insert_idem] using h.hasSum (y := y)âŸ©\n\n"}
{"name":"hasFPowerSeriesWithinAt_insert","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx y : E\nâŠ¢ Iff (HasFPowerSeriesWithinAt f p (Insert.insert y s) x) (HasFPowerSeriesWithinAt f p s x)","decl":"@[simp] theorem hasFPowerSeriesWithinAt_insert {y : E} :\n    HasFPowerSeriesWithinAt f p (insert y s) x â†” HasFPowerSeriesWithinAt f p s x := by\n  rcases eq_or_ne x y with rfl | hy\n  Â· simp [HasFPowerSeriesWithinAt]\n  Â· refine âŸ¨fun h â†¦ h.mono (subset_insert _ _), fun h â†¦ ?_âŸ©\n    apply HasFPowerSeriesWithinAt.mono_of_mem_nhdsWithin h\n    rw [nhdsWithin_insert_of_ne hy]\n    exact self_mem_nhdsWithin\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.coeff_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f pf s x r\nv : Fin 0 â†’ E\nâŠ¢ Eq ((pf 0) v) (f x)","decl":"theorem HasFPowerSeriesWithinOnBall.coeff_zero (hf : HasFPowerSeriesWithinOnBall f pf s x r)\n    (v : Fin 0 â†’ E) : pf 0 v = f x := by\n  have v_eq : v = fun i => 0 := Subsingleton.elim _ _\n  have zero_mem : (0 : E) âˆˆ EMetric.ball (0 : E) r := by simp [hf.r_pos]\n  have : âˆ€ i, i â‰  0 â†’ (pf i fun _ => 0) = 0 := by\n    intro i hi\n    have : 0 < i := pos_iff_ne_zero.2 hi\n    exact ContinuousMultilinearMap.map_coord_zero _ (âŸ¨0, thisâŸ© : Fin i) rfl\n  have A := (hf.hasSum (by simp) zero_mem).unique (hasSum_single _ this)\n  simpa [v_eq] using A.symm\n\n"}
{"name":"HasFPowerSeriesOnBall.coeff_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f pf x r\nv : Fin 0 â†’ E\nâŠ¢ Eq ((pf 0) v) (f x)","decl":"theorem HasFPowerSeriesOnBall.coeff_zero (hf : HasFPowerSeriesOnBall f pf x r)\n    (v : Fin 0 â†’ E) : pf 0 v = f x := by\n  rw [â† hasFPowerSeriesWithinOnBall_univ] at hf\n  exact hf.coeff_zero v\n\n"}
{"name":"HasFPowerSeriesWithinAt.coeff_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f pf s x\nv : Fin 0 â†’ E\nâŠ¢ Eq ((pf 0) v) (f x)","decl":"theorem HasFPowerSeriesWithinAt.coeff_zero (hf : HasFPowerSeriesWithinAt f pf s x) (v : Fin 0 â†’ E) :\n    pf 0 v = f x :=\n  let âŸ¨_, hrfâŸ© := hf\n  hrf.coeff_zero v\n\n"}
{"name":"HasFPowerSeriesAt.coeff_zero","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\npf : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f pf x\nv : Fin 0 â†’ E\nâŠ¢ Eq ((pf 0) v) (f x)","decl":"theorem HasFPowerSeriesAt.coeff_zero (hf : HasFPowerSeriesAt f pf x) (v : Fin 0 â†’ E) :\n    pf 0 v = f x :=\n  let âŸ¨_, hrfâŸ© := hf\n  hrf.coeff_zero v\n\n"}
{"name":"analyticWithinAt_univ","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nâŠ¢ Iff (AnalyticWithinAt ğ•œ f Set.univ x) (AnalyticAt ğ•œ f x)","decl":"@[simp] lemma analyticWithinAt_univ :\n    AnalyticWithinAt ğ•œ f univ x â†” AnalyticAt ğ•œ f x := by\n  simp [AnalyticWithinAt, AnalyticAt]\n\n"}
{"name":"analyticOn_univ","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Iff (AnalyticOn ğ•œ f Set.univ) (AnalyticOnNhd ğ•œ f Set.univ)","decl":"@[simp] lemma analyticOn_univ {f : E â†’ F} :\n    AnalyticOn ğ•œ f univ â†” AnalyticOnNhd ğ•œ f univ := by\n  simp only [AnalyticOn, analyticWithinAt_univ, AnalyticOnNhd]\n\n"}
{"name":"analyticWithinOn_univ","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Iff (AnalyticOn ğ•œ f Set.univ) (AnalyticOnNhd ğ•œ f Set.univ)","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticWithinOn_univ := analyticOn_univ\n\n"}
{"name":"AnalyticWithinAt.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns t : Set E\nx : E\nhf : AnalyticWithinAt ğ•œ f s x\nh : HasSubset.Subset t s\nâŠ¢ AnalyticWithinAt ğ•œ f t x","decl":"lemma AnalyticWithinAt.mono (hf : AnalyticWithinAt ğ•œ f s x) (h : t âŠ† s) :\n    AnalyticWithinAt ğ•œ f t x := by\n  obtain âŸ¨p, hpâŸ© := hf\n  exact âŸ¨p, hp.mono hâŸ©\n\n"}
{"name":"AnalyticAt.analyticWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nx : E\nhf : AnalyticAt ğ•œ f x\nâŠ¢ AnalyticWithinAt ğ•œ f s x","decl":"lemma AnalyticAt.analyticWithinAt (hf : AnalyticAt ğ•œ f x) : AnalyticWithinAt ğ•œ f s x := by\n  rw [â† analyticWithinAt_univ] at hf\n  apply hf.mono (subset_univ _)\n\n"}
{"name":"AnalyticOnNhd.analyticOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nhf : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOn ğ•œ f s","decl":"lemma AnalyticOnNhd.analyticOn (hf : AnalyticOnNhd ğ•œ f s) : AnalyticOn ğ•œ f s :=\n  fun x hx â†¦ (hf x hx).analyticWithinAt\n\n"}
{"name":"AnalyticOn.analyticWithinOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nhf : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOn ğ•œ f s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.analyticWithinOn := AnalyticOnNhd.analyticOn\n\n"}
{"name":"AnalyticWithinAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nx : E\nhf : AnalyticWithinAt ğ•œ f s x\nhs : (nhdsWithin x s).EventuallyEq g f\nhx : Eq (g x) (f x)\nâŠ¢ AnalyticWithinAt ğ•œ g s x","decl":"lemma AnalyticWithinAt.congr_of_eventuallyEq {f g : E â†’ F} {s : Set E} {x : E}\n    (hf : AnalyticWithinAt ğ•œ f s x) (hs : g =á¶ [ğ“[s] x] f) (hx : g x = f x) :\n    AnalyticWithinAt ğ•œ g s x := by\n  rcases hf with âŸ¨p, hpâŸ©\n  exact âŸ¨p, hp.congr hs hxâŸ©\n\n"}
{"name":"AnalyticWithinAt.congr_of_eventuallyEq_insert","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nx : E\nhf : AnalyticWithinAt ğ•œ f s x\nhs : (nhdsWithin x (Insert.insert x s)).EventuallyEq g f\nâŠ¢ AnalyticWithinAt ğ•œ g s x","decl":"lemma AnalyticWithinAt.congr_of_eventuallyEq_insert {f g : E â†’ F} {s : Set E} {x : E}\n    (hf : AnalyticWithinAt ğ•œ f s x) (hs : g =á¶ [ğ“[insert x s] x] f) :\n    AnalyticWithinAt ğ•œ g s x := by\n  apply hf.congr_of_eventuallyEq (nhdsWithin_mono x (subset_insert x s) hs)\n  apply mem_of_mem_nhdsWithin (mem_insert x s) hs\n\n"}
{"name":"AnalyticWithinAt.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nx : E\nhf : AnalyticWithinAt ğ•œ f s x\nhs : Set.EqOn g f s\nhx : Eq (g x) (f x)\nâŠ¢ AnalyticWithinAt ğ•œ g s x","decl":"lemma AnalyticWithinAt.congr {f g : E â†’ F} {s : Set E} {x : E}\n    (hf : AnalyticWithinAt ğ•œ f s x) (hs : EqOn g f s) (hx : g x = f x) :\n    AnalyticWithinAt ğ•œ g s x :=\n  hf.congr_of_eventuallyEq hs.eventuallyEq_nhdsWithin hx\n\n"}
{"name":"AnalyticOn.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhf : AnalyticOn ğ•œ f s\nhs : Set.EqOn g f s\nâŠ¢ AnalyticOn ğ•œ g s","decl":"lemma AnalyticOn.congr {f g : E â†’ F} {s : Set E}\n    (hf : AnalyticOn ğ•œ f s) (hs : EqOn g f s) :\n    AnalyticOn ğ•œ g s :=\n  fun x m â†¦ (hf x m).congr hs (hs m)\n\n"}
{"name":"AnalyticWithinOn.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhf : AnalyticOn ğ•œ f s\nhs : Set.EqOn g f s\nâŠ¢ AnalyticOn ğ•œ g s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.congr := AnalyticOn.congr\n\n"}
{"name":"AnalyticAt.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\nx : E\nhf : AnalyticAt ğ•œ f x\nhg : (nhds x).EventuallyEq f g\nâŠ¢ AnalyticAt ğ•œ g x","decl":"theorem AnalyticAt.congr (hf : AnalyticAt ğ•œ f x) (hg : f =á¶ [ğ“ x] g) : AnalyticAt ğ•œ g x :=\n  let âŸ¨_, hpfâŸ© := hf\n  (hpf.congr hg).analyticAt\n\n"}
{"name":"analyticAt_congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\nx : E\nh : (nhds x).EventuallyEq f g\nâŠ¢ Iff (AnalyticAt ğ•œ f x) (AnalyticAt ğ•œ g x)","decl":"theorem analyticAt_congr (h : f =á¶ [ğ“ x] g) : AnalyticAt ğ•œ f x â†” AnalyticAt ğ•œ g x :=\n  âŸ¨fun hf â†¦ hf.congr h, fun hg â†¦ hg.congr h.symmâŸ©\n\n"}
{"name":"AnalyticOnNhd.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns t : Set E\nhf : AnalyticOnNhd ğ•œ f t\nhst : HasSubset.Subset s t\nâŠ¢ AnalyticOnNhd ğ•œ f s","decl":"theorem AnalyticOnNhd.mono {s t : Set E} (hf : AnalyticOnNhd ğ•œ f t) (hst : s âŠ† t) :\n    AnalyticOnNhd ğ•œ f s :=\n  fun z hz => hf z (hst hz)\n\n"}
{"name":"AnalyticOnNhd.congr'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhf : AnalyticOnNhd ğ•œ f s\nhg : (nhdsSet s).EventuallyEq f g\nâŠ¢ AnalyticOnNhd ğ•œ g s","decl":"theorem AnalyticOnNhd.congr' (hf : AnalyticOnNhd ğ•œ f s) (hg : f =á¶ [ğ“Ë¢ s] g) :\n    AnalyticOnNhd ğ•œ g s :=\n  fun z hz => (hf z hz).congr (mem_nhdsSet_iff_forall.mp hg z hz)\n\n"}
{"name":"AnalyticOn.congr'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhf : AnalyticOnNhd ğ•œ f s\nhg : (nhdsSet s).EventuallyEq f g\nâŠ¢ AnalyticOnNhd ğ•œ g s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.congr' := AnalyticOnNhd.congr'\n\n"}
{"name":"analyticOnNhd_congr'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nh : (nhdsSet s).EventuallyEq f g\nâŠ¢ Iff (AnalyticOnNhd ğ•œ f s) (AnalyticOnNhd ğ•œ g s)","decl":"theorem analyticOnNhd_congr' (h : f =á¶ [ğ“Ë¢ s] g) : AnalyticOnNhd ğ•œ f s â†” AnalyticOnNhd ğ•œ g s :=\n  âŸ¨fun hf => hf.congr' h, fun hg => hg.congr' h.symmâŸ©\n\n"}
{"name":"analyticOn_congr'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nh : (nhdsSet s).EventuallyEq f g\nâŠ¢ Iff (AnalyticOnNhd ğ•œ f s) (AnalyticOnNhd ğ•œ g s)","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticOn_congr' := analyticOnNhd_congr'\n\n"}
{"name":"AnalyticOnNhd.congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhs : IsOpen s\nhf : AnalyticOnNhd ğ•œ f s\nhg : Set.EqOn f g s\nâŠ¢ AnalyticOnNhd ğ•œ g s","decl":"theorem AnalyticOnNhd.congr (hs : IsOpen s) (hf : AnalyticOnNhd ğ•œ f s) (hg : s.EqOn f g) :\n    AnalyticOnNhd ğ•œ g s :=\n  hf.congr' <| mem_nhdsSet_iff_forall.mpr\n    (fun _ hz => eventuallyEq_iff_exists_mem.mpr âŸ¨s, hs.mem_nhds hz, hgâŸ©)\n\n"}
{"name":"analyticOnNhd_congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhs : IsOpen s\nh : Set.EqOn f g s\nâŠ¢ Iff (AnalyticOnNhd ğ•œ f s) (AnalyticOnNhd ğ•œ g s)","decl":"theorem analyticOnNhd_congr (hs : IsOpen s) (h : s.EqOn f g) : AnalyticOnNhd ğ•œ f s â†”\n    AnalyticOnNhd ğ•œ g s := âŸ¨fun hf => hf.congr hs h, fun hg => hg.congr hs h.symmâŸ©\n\n"}
{"name":"analyticOn_congr","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf g : E â†’ F\ns : Set E\nhs : IsOpen s\nh : Set.EqOn f g s\nâŠ¢ Iff (AnalyticOnNhd ğ•œ f s) (AnalyticOnNhd ğ•œ g s)","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticOn_congr := analyticOnNhd_congr\n\n"}
{"name":"AnalyticWithinAt.mono_of_mem_nhdsWithin","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns t : Set E\nx : E\nh : AnalyticWithinAt ğ•œ f s x\nhst : Membership.mem (nhdsWithin x t) s\nâŠ¢ AnalyticWithinAt ğ•œ f t x","decl":"theorem AnalyticWithinAt.mono_of_mem_nhdsWithin\n    (h : AnalyticWithinAt ğ•œ f s x) (hst : s âˆˆ ğ“[t] x) : AnalyticWithinAt ğ•œ f t x := by\n  rcases h with âŸ¨p, hpâŸ©\n  exact âŸ¨p, hp.mono_of_mem_nhdsWithin hstâŸ©\n\n"}
{"name":"AnalyticWithinAt.mono_of_mem","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns t : Set E\nx : E\nh : AnalyticWithinAt ğ•œ f s x\nhst : Membership.mem (nhdsWithin x t) s\nâŠ¢ AnalyticWithinAt ğ•œ f t x","decl":"@[deprecated (since := \"2024-10-31\")]\nalias AnalyticWithinAt.mono_of_mem := AnalyticWithinAt.mono_of_mem_nhdsWithin\n\n"}
{"name":"AnalyticOn.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns t : Set E\nh : AnalyticOn ğ•œ f t\nhs : HasSubset.Subset s t\nâŠ¢ AnalyticOn ğ•œ f s","decl":"lemma AnalyticOn.mono {f : E â†’ F} {s t : Set E} (h : AnalyticOn ğ•œ f t)\n    (hs : s âŠ† t) : AnalyticOn ğ•œ f s :=\n  fun _ m â†¦ (h _ (hs m)).mono hs\n\n"}
{"name":"AnalyticWithinOn.mono","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns t : Set E\nh : AnalyticOn ğ•œ f t\nhs : HasSubset.Subset s t\nâŠ¢ AnalyticOn ğ•œ f s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.mono := AnalyticOn.mono\n\n"}
{"name":"analyticWithinAt_insert","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nx y : E\nâŠ¢ Iff (AnalyticWithinAt ğ•œ f (Insert.insert y s) x) (AnalyticWithinAt ğ•œ f s x)","decl":"@[simp] theorem analyticWithinAt_insert {f : E â†’ F} {s : Set E} {x y : E} :\n    AnalyticWithinAt ğ•œ f (insert y s) x â†” AnalyticWithinAt ğ•œ f s x := by\n  simp [AnalyticWithinAt]\n\n"}
{"name":"ContinuousLinearMap.comp_hasFPowerSeriesWithinOnBall","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nh : HasFPowerSeriesWithinOnBall f p s x r\nâŠ¢ HasFPowerSeriesWithinOnBall (Function.comp (â‡‘g) f) (g.compFormalMultilinearSeries p) s x r","decl":"/-- If a function `f` has a power series `p` on a ball within a set and `g` is linear,\nthen `g âˆ˜ f` has the power series `g âˆ˜ p` on the same ball. -/\ntheorem ContinuousLinearMap.comp_hasFPowerSeriesWithinOnBall (g : F â†’L[ğ•œ] G)\n    (h : HasFPowerSeriesWithinOnBall f p s x r) :\n    HasFPowerSeriesWithinOnBall (g âˆ˜ f) (g.compFormalMultilinearSeries p) s x r where\n  r_le := h.r_le.trans (p.radius_le_radius_continuousLinearMap_comp _)\n  r_pos := h.r_pos\n  hasSum hy h'y := by\n    simpa only [ContinuousLinearMap.compFormalMultilinearSeries_apply,\n      ContinuousLinearMap.compContinuousMultilinearMap_coe, Function.comp_apply] using\n      g.hasSum (h.hasSum hy h'y)\n\n"}
{"name":"ContinuousLinearMap.comp_hasFPowerSeriesOnBall","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nh : HasFPowerSeriesOnBall f p x r\nâŠ¢ HasFPowerSeriesOnBall (Function.comp (â‡‘g) f) (g.compFormalMultilinearSeries p) x r","decl":"/-- If a function `f` has a power series `p` on a ball and `g` is linear, then `g âˆ˜ f` has the\npower series `g âˆ˜ p` on the same ball. -/\ntheorem ContinuousLinearMap.comp_hasFPowerSeriesOnBall (g : F â†’L[ğ•œ] G)\n    (h : HasFPowerSeriesOnBall f p x r) :\n    HasFPowerSeriesOnBall (g âˆ˜ f) (g.compFormalMultilinearSeries p) x r := by\n  rw [â† hasFPowerSeriesWithinOnBall_univ] at h âŠ¢\n  exact g.comp_hasFPowerSeriesWithinOnBall h\n\n"}
{"name":"ContinuousLinearMap.comp_analyticOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\ns : Set E\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nh : AnalyticOn ğ•œ f s\nâŠ¢ AnalyticOn ğ•œ (Function.comp (â‡‘g) f) s","decl":"/-- If a function `f` is analytic on a set `s` and `g` is linear, then `g âˆ˜ f` is analytic\non `s`. -/\ntheorem ContinuousLinearMap.comp_analyticOn (g : F â†’L[ğ•œ] G) (h : AnalyticOn ğ•œ f s) :\n    AnalyticOn ğ•œ (g âˆ˜ f) s := by\n  rintro x hx\n  rcases h x hx with âŸ¨p, r, hpâŸ©\n  exact âŸ¨g.compFormalMultilinearSeries p, r, g.comp_hasFPowerSeriesWithinOnBall hpâŸ©\n\n"}
{"name":"ContinuousLinearMap.comp_analyticOnNhd","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\ns : Set E\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nh : AnalyticOnNhd ğ•œ f s\nâŠ¢ AnalyticOnNhd ğ•œ (Function.comp (â‡‘g) f) s","decl":"/-- If a function `f` is analytic on a set `s` and `g` is linear, then `g âˆ˜ f` is analytic\non `s`. -/\ntheorem ContinuousLinearMap.comp_analyticOnNhd\n    {s : Set E} (g : F â†’L[ğ•œ] G) (h : AnalyticOnNhd ğ•œ f s) :\n    AnalyticOnNhd ğ•œ (g âˆ˜ f) s := by\n  rintro x hx\n  rcases h x hx with âŸ¨p, r, hpâŸ©\n  exact âŸ¨g.compFormalMultilinearSeries p, r, g.comp_hasFPowerSeriesOnBall hpâŸ©\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.tendsto_partialSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\ny : E\nhy : Membership.mem (EMetric.ball 0 r) y\nh'y : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\nâŠ¢ Filter.Tendsto (fun n => p.partialSum n y) Filter.atTop (nhds (f (HAdd.hAdd x y)))","decl":"theorem HasFPowerSeriesWithinOnBall.tendsto_partialSum\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) {y : E} (hy : y âˆˆ EMetric.ball (0 : E) r)\n    (h'y : x + y âˆˆ insert x s) :\n    Tendsto (fun n => p.partialSum n y) atTop (ğ“ (f (x + y))) :=\n  (hf.hasSum h'y hy).tendsto_sum_nat\n\n"}
{"name":"HasFPowerSeriesOnBall.tendsto_partialSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\ny : E\nhy : Membership.mem (EMetric.ball 0 r) y\nâŠ¢ Filter.Tendsto (fun n => p.partialSum n y) Filter.atTop (nhds (f (HAdd.hAdd x y)))","decl":"theorem HasFPowerSeriesOnBall.tendsto_partialSum\n    (hf : HasFPowerSeriesOnBall f p x r) {y : E} (hy : y âˆˆ EMetric.ball (0 : E) r) :\n    Tendsto (fun n => p.partialSum n y) atTop (ğ“ (f (x + y))) :=\n  (hf.hasSum hy).tendsto_sum_nat\n\n"}
{"name":"HasFPowerSeriesAt.tendsto_partialSum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f p x\nâŠ¢ Filter.Eventually (fun y => Filter.Tendsto (fun n => p.partialSum n y) Filter.atTop (nhds (f (HAdd.hAdd x y)))) (nhds 0)","decl":"theorem HasFPowerSeriesAt.tendsto_partialSum\n    (hf : HasFPowerSeriesAt f p x) :\n    âˆ€á¶  y in ğ“ 0, Tendsto (fun n => p.partialSum n y) atTop (ğ“ (f (x + y))) := by\n  rcases hf with âŸ¨r, hrâŸ©\n  filter_upwards [EMetric.ball_mem_nhds (0 : E) hr.r_pos] with y hy\n  exact hr.tendsto_partialSum hy\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.tendsto_partialSum_prod","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\ny : E\nhf : HasFPowerSeriesWithinOnBall f p s x r\nhy : Membership.mem (EMetric.ball 0 r) y\nh'y : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\nâŠ¢ Filter.Tendsto (fun z => p.partialSum z.1 z.2) (SProd.sprod Filter.atTop (nhds y)) (nhds (f (HAdd.hAdd x y)))","decl":"open Finset in\n/-- If a function admits a power series expansion within a ball, then the partial sums\n`p.partialSum n z` converge to `f (x + y)` as `n â†’ âˆ` and `z â†’ y`. Note that `x + z` doesn't need\nto belong to the set where the power series expansion holds. -/\ntheorem HasFPowerSeriesWithinOnBall.tendsto_partialSum_prod {y : E}\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (hy : y âˆˆ EMetric.ball (0 : E) r)\n    (h'y : x + y âˆˆ insert x s) :\n    Tendsto (fun (z : â„• Ã— E) â†¦ p.partialSum z.1 z.2) (atTop Ã—Ë¢ ğ“ y) (ğ“ (f (x + y))) := by\n  have A : Tendsto (fun (z : â„• Ã— E) â†¦ p.partialSum z.1 y) (atTop Ã—Ë¢ ğ“ y) (ğ“ (f (x + y))) := by\n    apply (hf.tendsto_partialSum hy h'y).comp tendsto_fst\n  suffices Tendsto (fun (z : â„• Ã— E) â†¦ p.partialSum z.1 z.2 - p.partialSum z.1 y)\n    (atTop Ã—Ë¢ ğ“ y) (ğ“ 0) by simpa using A.add this\n  apply Metric.tendsto_nhds.2 (fun Îµ Îµpos â†¦ ?_)\n  obtain âŸ¨r', yr', r'râŸ© : âˆƒ (r' : â„â‰¥0), â€–yâ€–â‚Š < r' âˆ§ r' < r := by\n    simp [edist_zero_eq_enorm] at hy\n    simpa using ENNReal.lt_iff_exists_nnreal_btwn.1 hy\n  have yr'_2 : â€–yâ€– < r' := by simpa [â† coe_nnnorm] using yr'\n  have S : Summable fun n â†¦ â€–p nâ€– * â†‘r' ^ n := p.summable_norm_mul_pow (r'r.trans_le hf.r_le)\n  obtain âŸ¨k, hkâŸ© : âˆƒ k, âˆ‘' (n : â„•), â€–p (n + k)â€– * â†‘r' ^ (n + k) < Îµ / 4 := by\n    have : Tendsto (fun k â†¦ âˆ‘' n, â€–p (n + k)â€– * â†‘r' ^ (n + k)) atTop (ğ“ 0) := by\n      apply _root_.tendsto_sum_nat_add (f := fun n â†¦ â€–p nâ€– * â†‘r' ^ n)\n    exact ((tendsto_order.1 this).2 _ (by linarith)).exists\n  have A : âˆ€á¶  (z : â„• Ã— E) in atTop Ã—Ë¢ ğ“ y,\n      dist (p.partialSum k z.2) (p.partialSum k y) < Îµ / 4 := by\n    have : ContinuousAt (fun z â†¦ p.partialSum k z) y := (p.partialSum_continuous k).continuousAt\n    exact tendsto_snd (Metric.tendsto_nhds.1 this.tendsto (Îµ / 4) (by linarith))\n  have B : âˆ€á¶  (z : â„• Ã— E) in atTop Ã—Ë¢ ğ“ y, â€–z.2â€–â‚Š < r' := by\n    suffices âˆ€á¶  (z : E) in ğ“ y, â€–zâ€–â‚Š < r' from tendsto_snd this\n    have : Metric.ball 0 r' âˆˆ ğ“ y := Metric.isOpen_ball.mem_nhds (by simpa using yr'_2)\n    filter_upwards [this] with a ha using by simpa [â† coe_nnnorm] using ha\n  have C : âˆ€á¶  (z : â„• Ã— E) in atTop Ã—Ë¢ ğ“ y, k â‰¤ z.1 := tendsto_fst (Ici_mem_atTop _)\n  filter_upwards [A, B, C]\n  rintro âŸ¨n, zâŸ© hz h'z hkn\n  simp only [dist_eq_norm, sub_zero] at hz âŠ¢\n  have I (w : E) (hw : â€–wâ€–â‚Š < r') : â€–âˆ‘ i âˆˆ Ico k n, p i (fun _ â†¦ w)â€– â‰¤ Îµ / 4 := calc\n    â€–âˆ‘ i âˆˆ Ico k n, p i (fun _ â†¦ w)â€–\n    _ = â€–âˆ‘ i âˆˆ range (n - k), p (i + k) (fun _ â†¦ w)â€– := by\n        rw [sum_Ico_eq_sum_range]\n        congr with i\n        rw [add_comm k]\n    _ â‰¤ âˆ‘ i âˆˆ range (n - k), â€–p (i + k) (fun _ â†¦ w)â€– := norm_sum_le _ _\n    _ â‰¤ âˆ‘ i âˆˆ range (n - k), â€–p (i + k)â€– * â€–wâ€– ^ (i + k) := by\n        gcongr with i _hi; exact ((p (i + k)).le_opNorm _).trans_eq (by simp)\n    _ â‰¤ âˆ‘ i âˆˆ range (n - k), â€–p (i + k)â€– * â†‘r' ^ (i + k) := by\n        gcongr with i _hi; simpa [â† coe_nnnorm] using hw.le\n    _ â‰¤ âˆ‘' i, â€–p (i + k)â€– * â†‘r' ^ (i + k) := by\n        apply sum_le_tsum _ (fun i _hi â†¦ by positivity)\n        apply ((_root_.summable_nat_add_iff k).2 S)\n    _ â‰¤ Îµ / 4 := hk.le\n  calc\n  â€–p.partialSum n z - p.partialSum n yâ€–\n  _ = â€–âˆ‘ i âˆˆ range n, p i (fun _ â†¦ z) - âˆ‘ i âˆˆ range n, p i (fun _ â†¦ y)â€– := rfl\n  _ = â€–(âˆ‘ i âˆˆ range k, p i (fun _ â†¦ z) + âˆ‘ i âˆˆ Ico k n, p i (fun _ â†¦ z))\n        - (âˆ‘ i âˆˆ range k, p i (fun _ â†¦ y) + âˆ‘ i âˆˆ Ico k n, p i (fun _ â†¦ y))â€– := by\n    simp [sum_range_add_sum_Ico _ hkn]\n  _ = â€–(p.partialSum k z - p.partialSum k y) + (âˆ‘ i âˆˆ Ico k n, p i (fun _ â†¦ z))\n        + (- âˆ‘ i âˆˆ Ico k n, p i (fun _ â†¦ y))â€– := by\n    congr 1\n    simp only [FormalMultilinearSeries.partialSum]\n    abel\n  _ â‰¤ â€–p.partialSum k z - p.partialSum k yâ€– + â€–âˆ‘ i âˆˆ Ico k n, p i (fun _ â†¦ z)â€–\n      + â€–- âˆ‘ i âˆˆ Ico k n, p i (fun _ â†¦ y)â€– := norm_addâ‚ƒ_le\n  _ â‰¤ Îµ / 4 + Îµ / 4 + Îµ / 4 := by\n    gcongr\n    Â· exact I _ h'z\n    Â· simp only [norm_neg]; exact I _ yr'\n  _ < Îµ := by linarith\n\n"}
{"name":"HasFPowerSeriesOnBall.tendsto_partialSum_prod","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\ny : E\nhf : HasFPowerSeriesOnBall f p x r\nhy : Membership.mem (EMetric.ball 0 r) y\nâŠ¢ Filter.Tendsto (fun z => p.partialSum z.1 z.2) (SProd.sprod Filter.atTop (nhds y)) (nhds (f (HAdd.hAdd x y)))","decl":"/-- If a function admits a power series on a ball, then the partial sums\n`p.partialSum n z` converges to `f (x + y)` as `n â†’ âˆ` and `z â†’ y`. -/\ntheorem HasFPowerSeriesOnBall.tendsto_partialSum_prod {y : E}\n    (hf : HasFPowerSeriesOnBall f p x r) (hy : y âˆˆ EMetric.ball (0 : E) r) :\n    Tendsto (fun (z : â„• Ã— E) â†¦ p.partialSum z.1 z.2) (atTop Ã—Ë¢ ğ“ y) (ğ“ (f (x + y))) :=\n  (hf.hasFPowerSeriesWithinOnBall (s := univ)).tendsto_partialSum_prod hy (by simp)\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.uniform_geometric_approx'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nh : LT.lt (â†‘r') r\nâŠ¢ Exists fun a => And (Membership.mem (Set.Ioo 0 1) a) (Exists fun C => And (GT.gt C 0) (âˆ€ (y : E), Membership.mem (Metric.ball 0 â†‘r') y â†’ âˆ€ (n : Nat), Membership.mem (Insert.insert x s) (HAdd.hAdd x y) â†’ LE.le (Norm.norm (HSub.hSub (f (HAdd.hAdd x y)) (p.partialSum n y))) (HMul.hMul C (HPow.hPow (HMul.hMul a (HDiv.hDiv (Norm.norm y) â†‘r')) n))))","decl":"/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence.\n\nThis version provides an upper estimate that decreases both in `â€–yâ€–` and `n`. See also\n`HasFPowerSeriesWithinOnBall.uniform_geometric_approx` for a weaker version. -/\ntheorem HasFPowerSeriesWithinOnBall.uniform_geometric_approx' {r' : â„â‰¥0}\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (h : (r' : â„â‰¥0âˆ) < r) :\n    âˆƒ a âˆˆ Ioo (0 : â„) 1, âˆƒ C > 0, âˆ€ y âˆˆ Metric.ball (0 : E) r', âˆ€ n, x + y âˆˆ insert x s â†’\n      â€–f (x + y) - p.partialSum n yâ€– â‰¤ C * (a * (â€–yâ€– / r')) ^ n := by\n  obtain âŸ¨a, ha, C, hC, hpâŸ© : âˆƒ a âˆˆ Ioo (0 : â„) 1, âˆƒ C > 0, âˆ€ n, â€–p nâ€– * (r' : â„) ^ n â‰¤ C * a ^ n :=\n    p.norm_mul_pow_le_mul_pow_of_lt_radius (h.trans_le hf.r_le)\n  refine âŸ¨a, ha, C / (1 - a), div_pos hC (sub_pos.2 ha.2), fun y hy n ys => ?_âŸ©\n  have yr' : â€–yâ€– < r' := by\n    rw [ball_zero_eq] at hy\n    exact hy\n  have hr'0 : 0 < (r' : â„) := (norm_nonneg _).trans_lt yr'\n  have : y âˆˆ EMetric.ball (0 : E) r := by\n    refine mem_emetric_ball_zero_iff.2 (lt_trans ?_ h)\n    simpa [enorm] using yr'\n  rw [norm_sub_rev, â† mul_div_right_comm]\n  have ya : a * (â€–yâ€– / â†‘r') â‰¤ a :=\n    mul_le_of_le_one_right ha.1.le (div_le_one_of_leâ‚€ yr'.le r'.coe_nonneg)\n  suffices â€–p.partialSum n y - f (x + y)â€– â‰¤ C * (a * (â€–yâ€– / r')) ^ n / (1 - a * (â€–yâ€– / r')) by\n    refine this.trans ?_\n    have : 0 < a := ha.1\n    gcongr\n    apply_rules [sub_pos.2, ha.2]\n  apply norm_sub_le_of_geometric_bound_of_hasSum (ya.trans_lt ha.2) _ (hf.hasSum ys this)\n  intro n\n  calc\n    â€–(p n) fun _ : Fin n => yâ€–\n    _ â‰¤ â€–p nâ€– * âˆ _i : Fin n, â€–yâ€– := ContinuousMultilinearMap.le_opNorm _ _\n    _ = â€–p nâ€– * (r' : â„) ^ n * (â€–yâ€– / r') ^ n := by field_simp [mul_right_comm]\n    _ â‰¤ C * a ^ n * (â€–yâ€– / r') ^ n := by gcongr ?_ * _; apply hp\n    _ â‰¤ C * (a * (â€–yâ€– / r')) ^ n := by rw [mul_pow, mul_assoc]\n\n"}
{"name":"HasFPowerSeriesOnBall.uniform_geometric_approx'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesOnBall f p x r\nh : LT.lt (â†‘r') r\nâŠ¢ Exists fun a => And (Membership.mem (Set.Ioo 0 1) a) (Exists fun C => And (GT.gt C 0) (âˆ€ (y : E), Membership.mem (Metric.ball 0 â†‘r') y â†’ âˆ€ (n : Nat), LE.le (Norm.norm (HSub.hSub (f (HAdd.hAdd x y)) (p.partialSum n y))) (HMul.hMul C (HPow.hPow (HMul.hMul a (HDiv.hDiv (Norm.norm y) â†‘r')) n))))","decl":"/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence.\n\nThis version provides an upper estimate that decreases both in `â€–yâ€–` and `n`. See also\n`HasFPowerSeriesOnBall.uniform_geometric_approx` for a weaker version. -/\ntheorem HasFPowerSeriesOnBall.uniform_geometric_approx' {r' : â„â‰¥0}\n    (hf : HasFPowerSeriesOnBall f p x r) (h : (r' : â„â‰¥0âˆ) < r) :\n    âˆƒ a âˆˆ Ioo (0 : â„) 1, âˆƒ C > 0, âˆ€ y âˆˆ Metric.ball (0 : E) r', âˆ€ n,\n      â€–f (x + y) - p.partialSum n yâ€– â‰¤ C * (a * (â€–yâ€– / r')) ^ n := by\n   rw [â† hasFPowerSeriesWithinOnBall_univ] at hf\n   simpa using hf.uniform_geometric_approx' h\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.uniform_geometric_approx","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nh : LT.lt (â†‘r') r\nâŠ¢ Exists fun a => And (Membership.mem (Set.Ioo 0 1) a) (Exists fun C => And (GT.gt C 0) (âˆ€ (y : E), Membership.mem (Metric.ball 0 â†‘r') y â†’ âˆ€ (n : Nat), Membership.mem (Insert.insert x s) (HAdd.hAdd x y) â†’ LE.le (Norm.norm (HSub.hSub (f (HAdd.hAdd x y)) (p.partialSum n y))) (HMul.hMul C (HPow.hPow a n))))","decl":"/-- If a function admits a power series expansion within a set in a ball, then it is exponentially\nclose to the partial sums of this power series on strict subdisks of the disk of convergence. -/\ntheorem HasFPowerSeriesWithinOnBall.uniform_geometric_approx {r' : â„â‰¥0}\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (h : (r' : â„â‰¥0âˆ) < r) :\n    âˆƒ a âˆˆ Ioo (0 : â„) 1,\n      âˆƒ C > 0, âˆ€ y âˆˆ Metric.ball (0 : E) r', âˆ€ n, x + y âˆˆ insert x s â†’\n      â€–f (x + y) - p.partialSum n yâ€– â‰¤ C * a ^ n := by\n  obtain âŸ¨a, ha, C, hC, hpâŸ© : âˆƒ a âˆˆ Ioo (0 : â„) 1, âˆƒ C > 0, âˆ€ y âˆˆ Metric.ball (0 : E) r', âˆ€ n,\n      x + y âˆˆ insert x s â†’ â€–f (x + y) - p.partialSum n yâ€– â‰¤ C * (a * (â€–yâ€– / r')) ^ n :=\n    hf.uniform_geometric_approx' h\n  refine âŸ¨a, ha, C, hC, fun y hy n ys => (hp y hy n ys).trans ?_âŸ©\n  have yr' : â€–yâ€– < r' := by rwa [ball_zero_eq] at hy\n  have := ha.1.le -- needed to discharge a side goal on the next line\n  gcongr\n  exact mul_le_of_le_one_right ha.1.le (div_le_one_of_leâ‚€ yr'.le r'.coe_nonneg)\n\n"}
{"name":"HasFPowerSeriesOnBall.uniform_geometric_approx","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesOnBall f p x r\nh : LT.lt (â†‘r') r\nâŠ¢ Exists fun a => And (Membership.mem (Set.Ioo 0 1) a) (Exists fun C => And (GT.gt C 0) (âˆ€ (y : E), Membership.mem (Metric.ball 0 â†‘r') y â†’ âˆ€ (n : Nat), LE.le (Norm.norm (HSub.hSub (f (HAdd.hAdd x y)) (p.partialSum n y))) (HMul.hMul C (HPow.hPow a n))))","decl":"/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence. -/\ntheorem HasFPowerSeriesOnBall.uniform_geometric_approx {r' : â„â‰¥0}\n    (hf : HasFPowerSeriesOnBall f p x r) (h : (r' : â„â‰¥0âˆ) < r) :\n    âˆƒ a âˆˆ Ioo (0 : â„) 1,\n      âˆƒ C > 0, âˆ€ y âˆˆ Metric.ball (0 : E) r', âˆ€ n,\n      â€–f (x + y) - p.partialSum n yâ€– â‰¤ C * a ^ n := by\n  rw [â† hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.uniform_geometric_approx h\n\n"}
{"name":"HasFPowerSeriesWithinAt.isBigO_sub_partialSum_pow","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\nn : Nat\nâŠ¢ Asymptotics.IsBigO (nhdsWithin 0 (Set.preimage (fun x_1 => HAdd.hAdd x x_1) (Insert.insert x s))) (fun y => HSub.hSub (f (HAdd.hAdd x y)) (p.partialSum n y)) fun y => HPow.hPow (Norm.norm y) n","decl":"/-- Taylor formula for an analytic function within a set, `IsBigO` version. -/\ntheorem HasFPowerSeriesWithinAt.isBigO_sub_partialSum_pow\n    (hf : HasFPowerSeriesWithinAt f p s x) (n : â„•) :\n    (fun y : E => f (x + y) - p.partialSum n y)\n      =O[ğ“[(x + Â·)â»Â¹' insert x s] 0] fun y => â€–yâ€– ^ n := by\n  rcases hf with âŸ¨r, hfâŸ©\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hf.r_pos with âŸ¨r', r'0, hâŸ©\n  obtain âŸ¨a, -, C, -, hpâŸ© : âˆƒ a âˆˆ Ioo (0 : â„) 1, âˆƒ C > 0, âˆ€ y âˆˆ Metric.ball (0 : E) r', âˆ€ n,\n      x + y âˆˆ insert x s â†’ â€–f (x + y) - p.partialSum n yâ€– â‰¤ C * (a * (â€–yâ€– / r')) ^ n :=\n    hf.uniform_geometric_approx' h\n  refine isBigO_iff.2 âŸ¨C * (a / r') ^ n, ?_âŸ©\n  replace r'0 : 0 < (r' : â„) := mod_cast r'0\n  filter_upwards [inter_mem_nhdsWithin _ (Metric.ball_mem_nhds (0 : E) r'0)] with y hy\n  simpa [mul_pow, mul_div_assoc, mul_assoc, div_mul_eq_mul_div, div_pow]\n    using hp y hy.2 n (by simpa using hy.1)\n\n"}
{"name":"HasFPowerSeriesAt.isBigO_sub_partialSum_pow","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f p x\nn : Nat\nâŠ¢ Asymptotics.IsBigO (nhds 0) (fun y => HSub.hSub (f (HAdd.hAdd x y)) (p.partialSum n y)) fun y => HPow.hPow (Norm.norm y) n","decl":"/-- Taylor formula for an analytic function, `IsBigO` version. -/\ntheorem HasFPowerSeriesAt.isBigO_sub_partialSum_pow\n    (hf : HasFPowerSeriesAt f p x) (n : â„•) :\n    (fun y : E => f (x + y) - p.partialSum n y) =O[ğ“ 0] fun y => â€–yâ€– ^ n := by\n  rw [â† hasFPowerSeriesWithinAt_univ] at hf\n  simpa using hf.isBigO_sub_partialSum_pow n\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.isBigO_image_sub_image_sub_deriv_principal","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr r' : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nhr : LT.lt r' r\nâŠ¢ Asymptotics.IsBigO (Filter.principal (Inter.inter (EMetric.ball { fst := x, snd := x } r') (SProd.sprod (Insert.insert x s) (Insert.insert x s)))) (fun y => HSub.hSub (HSub.hSub (f y.1) (f y.2)) ((p 1) fun x => HSub.hSub y.1 y.2)) fun y => HMul.hMul (Norm.norm (HSub.hSub y { fst := x, snd := x })) (Norm.norm (HSub.hSub y.1 y.2))","decl":"/-- If `f` has formal power series `âˆ‘ n, pâ‚™` in a set, within a ball of radius `r`, then\nfor `y, z` in any smaller ball, the norm of the difference `f y - f z - p 1 (fun _ â†¦ y - z)` is\nbounded above by `C * (max â€–y - xâ€– â€–z - xâ€–) * â€–y - zâ€–`. This lemma formulates this property\nusing `IsBigO` and `Filter.principal` on `E Ã— E`. -/\ntheorem HasFPowerSeriesWithinOnBall.isBigO_image_sub_image_sub_deriv_principal\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (hr : r' < r) :\n    (fun y : E Ã— E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2)\n      =O[ğ“Ÿ (EMetric.ball (x, x) r' âˆ© ((insert x s) Ã—Ë¢ (insert x s)))]\n      fun y => â€–y - (x, x)â€– * â€–y.1 - y.2â€– := by\n  lift r' to â„â‰¥0 using ne_top_of_lt hr\n  rcases (zero_le r').eq_or_lt with (rfl | hr'0)\n  Â· simp only [ENNReal.coe_zero, EMetric.ball_zero, empty_inter, principal_empty, isBigO_bot]\n  obtain âŸ¨a, ha, C, hC : 0 < C, hpâŸ© :\n      âˆƒ a âˆˆ Ioo (0 : â„) 1, âˆƒ C > 0, âˆ€ n : â„•, â€–p nâ€– * (r' : â„) ^ n â‰¤ C * a ^ n :=\n    p.norm_mul_pow_le_mul_pow_of_lt_radius (hr.trans_le hf.r_le)\n  simp only [â† le_div_iffâ‚€ (pow_pos (NNReal.coe_pos.2 hr'0) _)] at hp\n  set L : E Ã— E â†’ â„ := fun y =>\n    C * (a / r') ^ 2 * (â€–y - (x, x)â€– * â€–y.1 - y.2â€–) * (a / (1 - a) ^ 2 + 2 / (1 - a))\n  have hL : âˆ€ y âˆˆ EMetric.ball (x, x) r' âˆ© ((insert x s) Ã—Ë¢ (insert x s)),\n      â€–f y.1 - f y.2 - p 1 fun _ => y.1 - y.2â€– â‰¤ L y := by\n    intro y âŸ¨hy', ysâŸ©\n    have hy : y âˆˆ EMetric.ball x r Ã—Ë¢ EMetric.ball x r := by\n      rw [EMetric.ball_prod_same]\n      exact EMetric.ball_subset_ball hr.le hy'\n    set A : â„• â†’ F := fun n => (p n fun _ => y.1 - x) - p n fun _ => y.2 - x\n    have hA : HasSum (fun n => A (n + 2)) (f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) := by\n      convert (hasSum_nat_add_iff' 2).2\n        ((hf.hasSum_sub âŸ¨ys.1, hy.1âŸ©).sub (hf.hasSum_sub âŸ¨ys.2, hy.2âŸ©)) using 1\n      rw [Finset.sum_range_succ, Finset.sum_range_one, hf.coeff_zero, hf.coeff_zero, sub_self,\n        zero_add, â† Subsingleton.pi_single_eq (0 : Fin 1) (y.1 - x), Pi.single,\n        â† Subsingleton.pi_single_eq (0 : Fin 1) (y.2 - x), Pi.single, â† (p 1).map_update_sub,\n        â† Pi.single, Subsingleton.pi_single_eq, sub_sub_sub_cancel_right]\n    rw [EMetric.mem_ball, edist_eq_enorm_sub, enorm_lt_coe] at hy'\n    set B : â„• â†’ â„ := fun n => C * (a / r') ^ 2 * (â€–y - (x, x)â€– * â€–y.1 - y.2â€–) * ((n + 2) * a ^ n)\n    have hAB : âˆ€ n, â€–A (n + 2)â€– â‰¤ B n := fun n =>\n      calc\n        â€–A (n + 2)â€– â‰¤ â€–p (n + 2)â€– * â†‘(n + 2) * â€–y - (x, x)â€– ^ (n + 1) * â€–y.1 - y.2â€– := by\n          -- Porting note: `pi_norm_const` was `pi_norm_const (_ : E)`\n          simpa only [Fintype.card_fin, pi_norm_const, Prod.norm_def, Pi.sub_def,\n            Prod.fst_sub, Prod.snd_sub, sub_sub_sub_cancel_right] using\n            (p <| n + 2).norm_image_sub_le (fun _ => y.1 - x) fun _ => y.2 - x\n        _ = â€–p (n + 2)â€– * â€–y - (x, x)â€– ^ n * (â†‘(n + 2) * â€–y - (x, x)â€– * â€–y.1 - y.2â€–) := by\n          rw [pow_succ â€–y - (x, x)â€–]\n          ring\n        -- Porting note: the two `â†‘` in `â†‘r'` are new, without them, Lean fails to synthesize\n        -- instances `HDiv â„ â„â‰¥0 ?m` or `HMul â„ â„â‰¥0 ?m`\n        _ â‰¤ C * a ^ (n + 2) / â†‘r' ^ (n + 2)\n            * â†‘r' ^ n * (â†‘(n + 2) * â€–y - (x, x)â€– * â€–y.1 - y.2â€–) := by\n          have : 0 < a := ha.1\n          gcongr\n          Â· apply hp\n          Â· apply hy'.le\n        _ = B n := by\n          field_simp [B, pow_succ]\n          simp only [mul_assoc, mul_comm, mul_left_comm]\n    have hBL : HasSum B (L y) := by\n      apply HasSum.mul_left\n      simp only [add_mul]\n      have : â€–aâ€– < 1 := by simp only [Real.norm_eq_abs, abs_of_pos ha.1, ha.2]\n      rw [div_eq_mul_inv, div_eq_mul_inv]\n      exact (hasSum_coe_mul_geometric_of_norm_lt_one this).add  -- Porting note: was `convert`!\n          ((hasSum_geometric_of_norm_lt_one this).mul_left 2)\n    exact hA.norm_le_of_bounded hBL hAB\n  suffices L =O[ğ“Ÿ (EMetric.ball (x, x) r' âˆ© ((insert x s) Ã—Ë¢ (insert x s)))]\n      fun y => â€–y - (x, x)â€– * â€–y.1 - y.2â€– from\n    .trans (.of_norm_eventuallyLE (eventually_principal.2 hL)) this\n  simp_rw [L, mul_right_comm _ (_ * _)]\n  exact (isBigO_refl _ _).const_mul_left _\n\n"}
{"name":"HasFPowerSeriesOnBall.isBigO_image_sub_image_sub_deriv_principal","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr r' : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nhr : LT.lt r' r\nâŠ¢ Asymptotics.IsBigO (Filter.principal (EMetric.ball { fst := x, snd := x } r')) (fun y => HSub.hSub (HSub.hSub (f y.1) (f y.2)) ((p 1) fun x => HSub.hSub y.1 y.2)) fun y => HMul.hMul (Norm.norm (HSub.hSub y { fst := x, snd := x })) (Norm.norm (HSub.hSub y.1 y.2))","decl":"/-- If `f` has formal power series `âˆ‘ n, pâ‚™` on a ball of radius `r`, then for `y, z` in any smaller\nball, the norm of the difference `f y - f z - p 1 (fun _ â†¦ y - z)` is bounded above by\n`C * (max â€–y - xâ€– â€–z - xâ€–) * â€–y - zâ€–`. This lemma formulates this property using `IsBigO` and\n`Filter.principal` on `E Ã— E`. -/\ntheorem HasFPowerSeriesOnBall.isBigO_image_sub_image_sub_deriv_principal\n    (hf : HasFPowerSeriesOnBall f p x r) (hr : r' < r) :\n    (fun y : E Ã— E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2)\n      =O[ğ“Ÿ (EMetric.ball (x, x) r')] fun y => â€–y - (x, x)â€– * â€–y.1 - y.2â€– := by\n  rw [â† hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.isBigO_image_sub_image_sub_deriv_principal hr\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.image_sub_sub_deriv_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr r' : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nhr : LT.lt r' r\nâŠ¢ Exists fun C => âˆ€ (y : E), Membership.mem (Inter.inter (Insert.insert x s) (EMetric.ball x r')) y â†’ âˆ€ (z : E), Membership.mem (Inter.inter (Insert.insert x s) (EMetric.ball x r')) z â†’ LE.le (Norm.norm (HSub.hSub (HSub.hSub (f y) (f z)) ((p 1) fun x => HSub.hSub y z))) (HMul.hMul (HMul.hMul C (Max.max (Norm.norm (HSub.hSub y x)) (Norm.norm (HSub.hSub z x)))) (Norm.norm (HSub.hSub y z)))","decl":"/-- If `f` has formal power series `âˆ‘ n, pâ‚™` within a set, on a ball of radius `r`, then for `y, z`\nin any smaller ball, the norm of the difference `f y - f z - p 1 (fun _ â†¦ y - z)` is bounded above\nby `C * (max â€–y - xâ€– â€–z - xâ€–) * â€–y - zâ€–`. -/\ntheorem HasFPowerSeriesWithinOnBall.image_sub_sub_deriv_le\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (hr : r' < r) :\n    âˆƒ C, âˆ€áµ‰ (y âˆˆ insert x s âˆ© EMetric.ball x r') (z âˆˆ insert x s âˆ© EMetric.ball x r'),\n      â€–f y - f z - p 1 fun _ => y - zâ€– â‰¤ C * max â€–y - xâ€– â€–z - xâ€– * â€–y - zâ€– := by\n  have := hf.isBigO_image_sub_image_sub_deriv_principal hr\n  simp only [isBigO_principal, mem_inter_iff, EMetric.mem_ball, Prod.edist_eq, max_lt_iff, mem_prod,\n    norm_mul, Real.norm_eq_abs, abs_norm, and_imp, Prod.forall, mul_assoc] at this âŠ¢\n  rcases this with âŸ¨C, hCâŸ©\n  exact âŸ¨C, fun y ys hy z zs hz â†¦ hC y z hy hz ys zsâŸ©\n\n"}
{"name":"HasFPowerSeriesOnBall.image_sub_sub_deriv_le","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr r' : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nhr : LT.lt r' r\nâŠ¢ Exists fun C => âˆ€ (y : E), Membership.mem (EMetric.ball x r') y â†’ âˆ€ (z : E), Membership.mem (EMetric.ball x r') z â†’ LE.le (Norm.norm (HSub.hSub (HSub.hSub (f y) (f z)) ((p 1) fun x => HSub.hSub y z))) (HMul.hMul (HMul.hMul C (Max.max (Norm.norm (HSub.hSub y x)) (Norm.norm (HSub.hSub z x)))) (Norm.norm (HSub.hSub y z)))","decl":"/-- If `f` has formal power series `âˆ‘ n, pâ‚™` on a ball of radius `r`, then for `y, z` in any smaller\nball, the norm of the difference `f y - f z - p 1 (fun _ â†¦ y - z)` is bounded above by\n`C * (max â€–y - xâ€– â€–z - xâ€–) * â€–y - zâ€–`. -/\ntheorem HasFPowerSeriesOnBall.image_sub_sub_deriv_le\n    (hf : HasFPowerSeriesOnBall f p x r) (hr : r' < r) :\n    âˆƒ C, âˆ€áµ‰ (y âˆˆ EMetric.ball x r') (z âˆˆ EMetric.ball x r'),\n      â€–f y - f z - p 1 fun _ => y - zâ€– â‰¤ C * max â€–y - xâ€– â€–z - xâ€– * â€–y - zâ€– := by\n  rw [â† hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa only [mem_univ, insert_eq_of_mem, univ_inter] using hf.image_sub_sub_deriv_le hr\n\n"}
{"name":"HasFPowerSeriesWithinAt.isBigO_image_sub_norm_mul_norm_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\nâŠ¢ Asymptotics.IsBigO (nhdsWithin { fst := x, snd := x } (SProd.sprod (Insert.insert x s) (Insert.insert x s))) (fun y => HSub.hSub (HSub.hSub (f y.1) (f y.2)) ((p 1) fun x => HSub.hSub y.1 y.2)) fun y => HMul.hMul (Norm.norm (HSub.hSub y { fst := x, snd := x })) (Norm.norm (HSub.hSub y.1 y.2))","decl":"/-- If `f` has formal power series `âˆ‘ n, pâ‚™` at `x` within a set `s`, then\n`f y - f z - p 1 (fun _ â†¦ y - z) = O(â€–(y, z) - (x, x)â€– * â€–y - zâ€–)` as `(y, z) â†’ (x, x)`\nwithin `s Ã— s`. -/\ntheorem HasFPowerSeriesWithinAt.isBigO_image_sub_norm_mul_norm_sub\n    (hf : HasFPowerSeriesWithinAt f p s x) :\n    (fun y : E Ã— E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2)\n      =O[ğ“[(insert x s) Ã—Ë¢ (insert x s)] (x, x)] fun y => â€–y - (x, x)â€– * â€–y.1 - y.2â€– := by\n  rcases hf with âŸ¨r, hfâŸ©\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hf.r_pos with âŸ¨r', r'0, hâŸ©\n  refine (hf.isBigO_image_sub_image_sub_deriv_principal h).mono ?_\n  rw [inter_comm]\n  exact le_principal_iff.2 (inter_mem_nhdsWithin _ (EMetric.ball_mem_nhds _ r'0))\n\n"}
{"name":"HasFPowerSeriesAt.isBigO_image_sub_norm_mul_norm_sub","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f p x\nâŠ¢ Asymptotics.IsBigO (nhds { fst := x, snd := x }) (fun y => HSub.hSub (HSub.hSub (f y.1) (f y.2)) ((p 1) fun x => HSub.hSub y.1 y.2)) fun y => HMul.hMul (Norm.norm (HSub.hSub y { fst := x, snd := x })) (Norm.norm (HSub.hSub y.1 y.2))","decl":"/-- If `f` has formal power series `âˆ‘ n, pâ‚™` at `x`, then\n`f y - f z - p 1 (fun _ â†¦ y - z) = O(â€–(y, z) - (x, x)â€– * â€–y - zâ€–)` as `(y, z) â†’ (x, x)`.\nIn particular, `f` is strictly differentiable at `x`. -/\ntheorem HasFPowerSeriesAt.isBigO_image_sub_norm_mul_norm_sub (hf : HasFPowerSeriesAt f p x) :\n    (fun y : E Ã— E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) =O[ğ“ (x, x)] fun y =>\n      â€–y - (x, x)â€– * â€–y.1 - y.2â€– := by\n  rw [â† hasFPowerSeriesWithinAt_univ] at hf\n  simpa using hf.isBigO_image_sub_norm_mul_norm_sub\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.tendstoUniformlyOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nh : LT.lt (â†‘r') r\nâŠ¢ TendstoUniformlyOn (fun n y => p.partialSum n y) (fun y => f (HAdd.hAdd x y)) Filter.atTop (Inter.inter (Set.preimage (fun x_1 => HAdd.hAdd x x_1) (Insert.insert x s)) (Metric.ball 0 â†‘r'))","decl":"/-- If a function admits a power series expansion within a set at `x`, then it is the uniform limit\nof the partial sums of this power series on strict subdisks of the disk of convergence, i.e.,\n`f (x + y)` is the uniform limit of `p.partialSum n y` there. -/\ntheorem HasFPowerSeriesWithinOnBall.tendstoUniformlyOn {r' : â„â‰¥0}\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (h : (r' : â„â‰¥0âˆ) < r) :\n    TendstoUniformlyOn (fun n y => p.partialSum n y) (fun y => f (x + y)) atTop\n      ((x + Â·)â»Â¹' (insert x s) âˆ© Metric.ball (0 : E) r') := by\n  obtain âŸ¨a, ha, C, -, hpâŸ© : âˆƒ a âˆˆ Ioo (0 : â„) 1, âˆƒ C > 0, âˆ€ y âˆˆ Metric.ball (0 : E) r', âˆ€ n,\n    x + y âˆˆ insert x s â†’ â€–f (x + y) - p.partialSum n yâ€– â‰¤ C * a ^ n := hf.uniform_geometric_approx h\n  refine Metric.tendstoUniformlyOn_iff.2 fun Îµ Îµpos => ?_\n  have L : Tendsto (fun n => (C : â„) * a ^ n) atTop (ğ“ ((C : â„) * 0)) :=\n    tendsto_const_nhds.mul (tendsto_pow_atTop_nhds_zero_of_lt_one ha.1.le ha.2)\n  rw [mul_zero] at L\n  refine (L.eventually (gt_mem_nhds Îµpos)).mono fun n hn y hy => ?_\n  rw [dist_eq_norm]\n  exact (hp y hy.2 n hy.1).trans_lt hn\n\n"}
{"name":"HasFPowerSeriesOnBall.tendstoUniformlyOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesOnBall f p x r\nh : LT.lt (â†‘r') r\nâŠ¢ TendstoUniformlyOn (fun n y => p.partialSum n y) (fun y => f (HAdd.hAdd x y)) Filter.atTop (Metric.ball 0 â†‘r')","decl":"/-- If a function admits a power series expansion at `x`, then it is the uniform limit of the\npartial sums of this power series on strict subdisks of the disk of convergence, i.e., `f (x + y)`\nis the uniform limit of `p.partialSum n y` there. -/\ntheorem HasFPowerSeriesOnBall.tendstoUniformlyOn {r' : â„â‰¥0} (hf : HasFPowerSeriesOnBall f p x r)\n    (h : (r' : â„â‰¥0âˆ) < r) :\n    TendstoUniformlyOn (fun n y => p.partialSum n y) (fun y => f (x + y)) atTop\n      (Metric.ball (0 : E) r') := by\n  rw [â† hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.tendstoUniformlyOn h\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.tendstoLocallyUniformlyOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nâŠ¢ TendstoLocallyUniformlyOn (fun n y => p.partialSum n y) (fun y => f (HAdd.hAdd x y)) Filter.atTop (Inter.inter (Set.preimage (fun x_1 => HAdd.hAdd x x_1) (Insert.insert x s)) (EMetric.ball 0 r))","decl":"/-- If a function admits a power series expansion within a set at `x`, then it is the locally\nuniform limit of the partial sums of this power series on the disk of convergence, i.e., `f (x + y)`\nis the locally uniform limit of `p.partialSum n y` there. -/\ntheorem HasFPowerSeriesWithinOnBall.tendstoLocallyUniformlyOn\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    TendstoLocallyUniformlyOn (fun n y => p.partialSum n y) (fun y => f (x + y)) atTop\n      ((x + Â·)â»Â¹' (insert x s) âˆ© EMetric.ball (0 : E) r) := by\n  intro u hu y hy\n  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hy.2 with âŸ¨r', yr', hr'âŸ©\n  have : EMetric.ball (0 : E) r' âˆˆ ğ“ y := IsOpen.mem_nhds EMetric.isOpen_ball yr'\n  refine âŸ¨(x + Â·)â»Â¹' (insert x s) âˆ© EMetric.ball (0 : E) r', ?_, ?_âŸ©\n  Â· rw [nhdsWithin_inter_of_mem']\n    Â· exact inter_mem_nhdsWithin _ this\n    Â· apply mem_nhdsWithin_of_mem_nhds\n      apply Filter.mem_of_superset this (EMetric.ball_subset_ball hr'.le)\n  Â· simpa [Metric.emetric_ball_nnreal] using hf.tendstoUniformlyOn hr' u hu\n\n"}
{"name":"HasFPowerSeriesOnBall.tendstoLocallyUniformlyOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nâŠ¢ TendstoLocallyUniformlyOn (fun n y => p.partialSum n y) (fun y => f (HAdd.hAdd x y)) Filter.atTop (EMetric.ball 0 r)","decl":"/-- If a function admits a power series expansion at `x`, then it is the locally uniform limit of\nthe partial sums of this power series on the disk of convergence, i.e., `f (x + y)`\nis the locally uniform limit of `p.partialSum n y` there. -/\ntheorem HasFPowerSeriesOnBall.tendstoLocallyUniformlyOn (hf : HasFPowerSeriesOnBall f p x r) :\n    TendstoLocallyUniformlyOn (fun n y => p.partialSum n y) (fun y => f (x + y)) atTop\n      (EMetric.ball (0 : E) r) := by\n  rw [â† hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.tendstoLocallyUniformlyOn\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.tendstoUniformlyOn'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nh : LT.lt (â†‘r') r\nâŠ¢ TendstoUniformlyOn (fun n y => p.partialSum n (HSub.hSub y x)) f Filter.atTop (Inter.inter (Insert.insert x s) (Metric.ball x â†‘r'))","decl":"/-- If a function admits a power series expansion within a set at `x`, then it is the uniform limit\nof the partial sums of this power series on strict subdisks of the disk of convergence, i.e., `f y`\nis the uniform limit of `p.partialSum n (y - x)` there. -/\ntheorem HasFPowerSeriesWithinOnBall.tendstoUniformlyOn' {r' : â„â‰¥0}\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) (h : (r' : â„â‰¥0âˆ) < r) :\n    TendstoUniformlyOn (fun n y => p.partialSum n (y - x)) f atTop\n      (insert x s âˆ© Metric.ball (x : E) r') := by\n  convert (hf.tendstoUniformlyOn h).comp fun y => y - x using 1\n  Â· simp [Function.comp_def]\n  Â· ext z\n    simp [dist_eq_norm]\n\n"}
{"name":"HasFPowerSeriesOnBall.tendstoUniformlyOn'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nr' : NNReal\nhf : HasFPowerSeriesOnBall f p x r\nh : LT.lt (â†‘r') r\nâŠ¢ TendstoUniformlyOn (fun n y => p.partialSum n (HSub.hSub y x)) f Filter.atTop (Metric.ball x â†‘r')","decl":"/-- If a function admits a power series expansion at `x`, then it is the uniform limit of the\npartial sums of this power series on strict subdisks of the disk of convergence, i.e., `f y`\nis the uniform limit of `p.partialSum n (y - x)` there. -/\ntheorem HasFPowerSeriesOnBall.tendstoUniformlyOn' {r' : â„â‰¥0} (hf : HasFPowerSeriesOnBall f p x r)\n    (h : (r' : â„â‰¥0âˆ) < r) :\n    TendstoUniformlyOn (fun n y => p.partialSum n (y - x)) f atTop (Metric.ball (x : E) r') := by\n  rw [â† hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.tendstoUniformlyOn' h\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.tendstoLocallyUniformlyOn'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nâŠ¢ TendstoLocallyUniformlyOn (fun n y => p.partialSum n (HSub.hSub y x)) f Filter.atTop (Inter.inter (Insert.insert x s) (EMetric.ball x r))","decl":"/-- If a function admits a power series expansion within a set at `x`, then it is the locally\nuniform limit of the partial sums of this power series on the disk of convergence, i.e., `f y`\nis the locally uniform limit of `p.partialSum n (y - x)` there. -/\ntheorem HasFPowerSeriesWithinOnBall.tendstoLocallyUniformlyOn'\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    TendstoLocallyUniformlyOn (fun n y => p.partialSum n (y - x)) f atTop\n      (insert x s âˆ© EMetric.ball (x : E) r) := by\n  have A : ContinuousOn (fun y : E => y - x) (insert x s âˆ© EMetric.ball (x : E) r) :=\n    (continuous_id.sub continuous_const).continuousOn\n  convert hf.tendstoLocallyUniformlyOn.comp (fun y : E => y - x) _ A using 1\n  Â· ext z\n    simp\n  Â· intro z\n    simp [edist_zero_eq_enorm, edist_eq_enorm_sub]\n\n"}
{"name":"HasFPowerSeriesOnBall.tendstoLocallyUniformlyOn'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nâŠ¢ TendstoLocallyUniformlyOn (fun n y => p.partialSum n (HSub.hSub y x)) f Filter.atTop (EMetric.ball x r)","decl":"/-- If a function admits a power series expansion at `x`, then it is the locally uniform limit of\nthe partial sums of this power series on the disk of convergence, i.e., `f y`\nis the locally uniform limit of `p.partialSum n (y - x)` there. -/\ntheorem HasFPowerSeriesOnBall.tendstoLocallyUniformlyOn' (hf : HasFPowerSeriesOnBall f p x r) :\n    TendstoLocallyUniformlyOn (fun n y => p.partialSum n (y - x)) f atTop\n      (EMetric.ball (x : E) r) := by\n  rw [â† hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.tendstoLocallyUniformlyOn'\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.continuousOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nâŠ¢ ContinuousOn f (Inter.inter (Insert.insert x s) (EMetric.ball x r))","decl":"/-- If a function admits a power series expansion within a set on a ball, then it is\ncontinuous there. -/\nprotected theorem HasFPowerSeriesWithinOnBall.continuousOn\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    ContinuousOn f (insert x s âˆ© EMetric.ball x r) :=\n  hf.tendstoLocallyUniformlyOn'.continuousOn <|\n    Eventually.of_forall fun n =>\n      ((p.partialSum_continuous n).comp (continuous_id.sub continuous_const)).continuousOn\n\n"}
{"name":"HasFPowerSeriesOnBall.continuousOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nhf : HasFPowerSeriesOnBall f p x r\nâŠ¢ ContinuousOn f (EMetric.ball x r)","decl":"/-- If a function admits a power series expansion on a ball, then it is continuous there. -/\nprotected theorem HasFPowerSeriesOnBall.continuousOn (hf : HasFPowerSeriesOnBall f p x r) :\n    ContinuousOn f (EMetric.ball x r) := by\n  rw [â† hasFPowerSeriesWithinOnBall_univ] at hf\n  simpa using hf.continuousOn\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.continuousWithinAt_insert","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nâŠ¢ ContinuousWithinAt f (Insert.insert x s) x","decl":"protected theorem HasFPowerSeriesWithinOnBall.continuousWithinAt_insert\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    ContinuousWithinAt f (insert x s) x := by\n  apply (hf.continuousOn.continuousWithinAt (x := x) (by simp [hf.r_pos])).mono_of_mem_nhdsWithin\n  exact inter_mem_nhdsWithin _ (EMetric.ball_mem_nhds x hf.r_pos)\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.continuousWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nhf : HasFPowerSeriesWithinOnBall f p s x r\nâŠ¢ ContinuousWithinAt f s x","decl":"protected theorem HasFPowerSeriesWithinOnBall.continuousWithinAt\n    (hf : HasFPowerSeriesWithinOnBall f p s x r) :\n    ContinuousWithinAt f s x :=\n  hf.continuousWithinAt_insert.mono (subset_insert x s)\n\n"}
{"name":"HasFPowerSeriesWithinAt.continuousWithinAt_insert","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\nâŠ¢ ContinuousWithinAt f (Insert.insert x s) x","decl":"protected theorem HasFPowerSeriesWithinAt.continuousWithinAt_insert\n    (hf : HasFPowerSeriesWithinAt f p s x) :\n    ContinuousWithinAt f (insert x s) x := by\n  rcases hf with âŸ¨r, hrâŸ©\n  apply hr.continuousWithinAt_insert\n\n"}
{"name":"HasFPowerSeriesWithinAt.continuousWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nhf : HasFPowerSeriesWithinAt f p s x\nâŠ¢ ContinuousWithinAt f s x","decl":"protected theorem HasFPowerSeriesWithinAt.continuousWithinAt\n    (hf : HasFPowerSeriesWithinAt f p s x) :\n    ContinuousWithinAt f s x :=\n  hf.continuousWithinAt_insert.mono (subset_insert x s)\n\n"}
{"name":"HasFPowerSeriesAt.continuousAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nhf : HasFPowerSeriesAt f p x\nâŠ¢ ContinuousAt f x","decl":"protected theorem HasFPowerSeriesAt.continuousAt (hf : HasFPowerSeriesAt f p x) :\n    ContinuousAt f x :=\n  let âŸ¨_, hrâŸ© := hf\n  hr.continuousOn.continuousAt (EMetric.ball_mem_nhds x hr.r_pos)\n\n"}
{"name":"AnalyticWithinAt.continuousWithinAt_insert","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nx : E\nhf : AnalyticWithinAt ğ•œ f s x\nâŠ¢ ContinuousWithinAt f (Insert.insert x s) x","decl":"protected theorem AnalyticWithinAt.continuousWithinAt_insert (hf : AnalyticWithinAt ğ•œ f s x) :\n    ContinuousWithinAt f (insert x s) x :=\n  let âŸ¨_, hpâŸ© := hf\n  hp.continuousWithinAt_insert\n\n"}
{"name":"AnalyticWithinAt.continuousWithinAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nx : E\nhf : AnalyticWithinAt ğ•œ f s x\nâŠ¢ ContinuousWithinAt f s x","decl":"protected theorem AnalyticWithinAt.continuousWithinAt (hf : AnalyticWithinAt ğ•œ f s x) :\n    ContinuousWithinAt f s x :=\n  hf.continuousWithinAt_insert.mono (subset_insert x s)\n\n"}
{"name":"AnalyticAt.continuousAt","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nhf : AnalyticAt ğ•œ f x\nâŠ¢ ContinuousAt f x","decl":"@[fun_prop]\nprotected theorem AnalyticAt.continuousAt (hf : AnalyticAt ğ•œ f x) : ContinuousAt f x :=\n  let âŸ¨_, hpâŸ© := hf\n  hp.continuousAt\n\n"}
{"name":"AnalyticOnNhd.continuousOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nhf : AnalyticOnNhd ğ•œ f s\nâŠ¢ ContinuousOn f s","decl":"protected theorem AnalyticOnNhd.continuousOn {s : Set E} (hf : AnalyticOnNhd ğ•œ f s) :\n    ContinuousOn f s :=\n  fun x hx => (hf x hx).continuousAt.continuousWithinAt\n\n"}
{"name":"AnalyticOn.continuousOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : AnalyticOn ğ•œ f s\nâŠ¢ ContinuousOn f s","decl":"protected lemma AnalyticOn.continuousOn {f : E â†’ F} {s : Set E} (h : AnalyticOn ğ•œ f s) :\n    ContinuousOn f s :=\n  fun x m â†¦ (h x m).continuousWithinAt\n\n"}
{"name":"AnalyticWithinOn.continuousOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : AnalyticOn ğ•œ f s\nâŠ¢ ContinuousOn f s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.continuousOn := AnalyticOn.continuousOn\n\n"}
{"name":"AnalyticOnNhd.continuous","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nfa : AnalyticOnNhd ğ•œ f Set.univ\nâŠ¢ Continuous f","decl":"/-- Analytic everywhere implies continuous -/\ntheorem AnalyticOnNhd.continuous {f : E â†’ F} (fa : AnalyticOnNhd ğ•œ f univ) : Continuous f := by\n  rw [continuous_iff_continuousOn_univ]; exact fa.continuousOn\n\n"}
{"name":"AnalyticOn.continuous","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nfa : AnalyticOnNhd ğ•œ f Set.univ\nâŠ¢ Continuous f","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.continuous := AnalyticOnNhd.continuous\n\n"}
{"name":"FormalMultilinearSeries.hasFPowerSeriesOnBall","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\np : FormalMultilinearSeries ğ•œ E F\nh : LT.lt 0 p.radius\nâŠ¢ HasFPowerSeriesOnBall p.sum p 0 p.radius","decl":"/-- In a complete space, the sum of a converging power series `p` admits `p` as a power series.\nThis is not totally obvious as we need to check the convergence of the series. -/\nprotected theorem FormalMultilinearSeries.hasFPowerSeriesOnBall [CompleteSpace F]\n    (p : FormalMultilinearSeries ğ•œ E F) (h : 0 < p.radius) :\n    HasFPowerSeriesOnBall p.sum p 0 p.radius :=\n  { r_le := le_rfl\n    r_pos := h\n    hasSum := fun hy => by\n      rw [zero_add]\n      exact p.hasSum hy }\n\n"}
{"name":"HasFPowerSeriesWithinOnBall.sum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nh : HasFPowerSeriesWithinOnBall f p s x r\ny : E\nh'y : Membership.mem (Insert.insert x s) (HAdd.hAdd x y)\nhy : Membership.mem (EMetric.ball 0 r) y\nâŠ¢ Eq (f (HAdd.hAdd x y)) (p.sum y)","decl":"theorem HasFPowerSeriesWithinOnBall.sum (h : HasFPowerSeriesWithinOnBall f p s x r) {y : E}\n    (h'y : x + y âˆˆ insert x s) (hy : y âˆˆ EMetric.ball (0 : E) r) : f (x + y) = p.sum y :=\n  (h.hasSum h'y hy).tsum_eq.symm\n\n"}
{"name":"HasFPowerSeriesOnBall.sum","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\nx : E\nr : ENNReal\nh : HasFPowerSeriesOnBall f p x r\ny : E\nhy : Membership.mem (EMetric.ball 0 r) y\nâŠ¢ Eq (f (HAdd.hAdd x y)) (p.sum y)","decl":"theorem HasFPowerSeriesOnBall.sum (h : HasFPowerSeriesOnBall f p x r) {y : E}\n    (hy : y âˆˆ EMetric.ball (0 : E) r) : f (x + y) = p.sum y :=\n  (h.hasSum hy).tsum_eq.symm\n\n"}
{"name":"FormalMultilinearSeries.continuousOn","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : FormalMultilinearSeries ğ•œ E F\ninstâœ : CompleteSpace F\nâŠ¢ ContinuousOn p.sum (EMetric.ball 0 p.radius)","decl":"/-- The sum of a converging power series is continuous in its disk of convergence. -/\nprotected theorem FormalMultilinearSeries.continuousOn [CompleteSpace F] :\n    ContinuousOn p.sum (EMetric.ball 0 p.radius) := by\n  rcases (zero_le p.radius).eq_or_lt with h | h\n  Â· simp [â† h, continuousOn_empty]\n  Â· exact (p.hasFPowerSeriesOnBall h).continuousOn\n\n"}
{"name":"hasFPowerSeriesAt_iff","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\np : FormalMultilinearSeries ğ•œ ğ•œ E\nf : ğ•œ â†’ E\nzâ‚€ : ğ•œ\nâŠ¢ Iff (HasFPowerSeriesAt f p zâ‚€) (Filter.Eventually (fun z => HasSum (fun n => HSMul.hSMul (HPow.hPow z n) (p.coeff n)) (f (HAdd.hAdd zâ‚€ z))) (nhds 0))","decl":"/-- A function `f : ğ•œ â†’ E` has `p` as power series expansion at a point `zâ‚€` iff it is the sum of\n`p` in a neighborhood of `zâ‚€`. This makes some proofs easier by hiding the fact that\n`HasFPowerSeriesAt` depends on `p.radius`. -/\ntheorem hasFPowerSeriesAt_iff :\n    HasFPowerSeriesAt f p zâ‚€ â†” âˆ€á¶  z in ğ“ 0, HasSum (fun n => z ^ n â€¢ p.coeff n) (f (zâ‚€ + z)) := by\n  refine âŸ¨fun âŸ¨r, _, r_pos, hâŸ© =>\n    eventually_of_mem (EMetric.ball_mem_nhds 0 r_pos) fun _ => by simpa using h, ?_âŸ©\n  simp only [Metric.eventually_nhds_iff]\n  rintro âŸ¨r, r_pos, hâŸ©\n  refine âŸ¨p.radius âŠ“ r.toNNReal, by simp, ?_, ?_âŸ©\n  Â· simp only [r_pos.lt, lt_inf_iff, ENNReal.coe_pos, Real.toNNReal_pos, and_true]\n    obtain âŸ¨z, z_pos, le_zâŸ© := NormedField.exists_norm_lt ğ•œ r_pos.lt\n    have : (â€–zâ€–â‚Š : ENNReal) â‰¤ p.radius := by\n      simp only [dist_zero_right] at h\n      apply FormalMultilinearSeries.le_radius_of_tendsto\n      convert tendsto_norm.comp (h le_z).summable.tendsto_atTop_zero\n      simp [norm_smul, mul_comm]\n    refine lt_of_lt_of_le ?_ this\n    simp only [ENNReal.coe_pos]\n    exact zero_lt_iff.mpr (nnnorm_ne_zero_iff.mpr (norm_pos_iff.mp z_pos))\n  Â· simp only [EMetric.mem_ball, lt_inf_iff, edist_lt_coe, apply_eq_pow_smul_coeff, and_imp,\n      dist_zero_right] at h âŠ¢\n    refine fun {y} _ hyr => h ?_\n    simpa [nndist_eq_nnnorm, Real.lt_toNNReal_iff_coe_lt] using hyr\n\n"}
{"name":"hasFPowerSeriesAt_iff'","module":"Mathlib.Analysis.Analytic.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\np : FormalMultilinearSeries ğ•œ ğ•œ E\nf : ğ•œ â†’ E\nzâ‚€ : ğ•œ\nâŠ¢ Iff (HasFPowerSeriesAt f p zâ‚€) (Filter.Eventually (fun z => HasSum (fun n => HSMul.hSMul (HPow.hPow (HSub.hSub z zâ‚€) n) (p.coeff n)) (f z)) (nhds zâ‚€))","decl":"theorem hasFPowerSeriesAt_iff' :\n    HasFPowerSeriesAt f p zâ‚€ â†” âˆ€á¶  z in ğ“ zâ‚€, HasSum (fun n => (z - zâ‚€) ^ n â€¢ p.coeff n) (f z) := by\n  rw [â† map_add_left_nhds_zero, eventually_map, hasFPowerSeriesAt_iff]\n  simp_rw [add_sub_cancel_left]\n\n"}
