{"name":"SheafOfModules.GeneratingSections.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninst✝³ : CategoryTheory.HasWeakSheafify J AddCommGrp\ninst✝² : J.WEqualsLocallyBijective AddCommGrp\ninst✝¹ : J.HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\nM : SheafOfModules R\ninst✝ : SizeOf C\nI : Type u\ns : I → M.sections\nepi : autoParam (CategoryTheory.Epi (M.freeHomEquiv.symm s)) _auto✝\n⊢ Eq (SizeOf.sizeOf { I := I, s := s, epi := epi }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf I)) (SizeOf.sizeOf epi))","decl":"/-- The type of sections which generate a sheaf of modules. -/\nstructure GeneratingSections where\n  /-- the index type for the sections -/\n  I : Type u\n  /-- a family of sections which generate the sheaf of modules -/\n  s : I → M.sections\n  epi : Epi (M.freeHomEquiv.symm s) := by infer_instance\n\n"}
{"name":"SheafOfModules.GeneratingSections.epi","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninst✝² : CategoryTheory.HasWeakSheafify J AddCommGrp\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : J.HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\nM : SheafOfModules R\nself : M.GeneratingSections\n⊢ CategoryTheory.Epi (M.freeHomEquiv.symm self.s)","decl":"/-- The type of sections which generate a sheaf of modules. -/\nstructure GeneratingSections where\n  /-- the index type for the sections -/\n  I : Type u\n  /-- a family of sections which generate the sheaf of modules -/\n  s : I → M.sections\n  epi : Epi (M.freeHomEquiv.symm s) := by infer_instance\n\n"}
{"name":"SheafOfModules.GeneratingSections.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninst✝² : CategoryTheory.HasWeakSheafify J AddCommGrp\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : J.HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\nM : SheafOfModules R\nI✝ : Type u\ns✝ : I✝ → M.sections\nepi✝ : autoParam (CategoryTheory.Epi (M.freeHomEquiv.symm s✝)) _auto✝\nI : Type u\ns : I → M.sections\nepi : autoParam (CategoryTheory.Epi (M.freeHomEquiv.symm s)) _auto✝\nx✝ : Eq { I := I✝, s := s✝, epi := epi✝ } { I := I, s := s, epi := epi }\n⊢ And (Eq I✝ I) (HEq s✝ s)","decl":"/-- The type of sections which generate a sheaf of modules. -/\nstructure GeneratingSections where\n  /-- the index type for the sections -/\n  I : Type u\n  /-- a family of sections which generate the sheaf of modules -/\n  s : I → M.sections\n  epi : Epi (M.freeHomEquiv.symm s) := by infer_instance\n\n"}
{"name":"SheafOfModules.GeneratingSections.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninst✝² : CategoryTheory.HasWeakSheafify J AddCommGrp\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : J.HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\nM : SheafOfModules R\nI✝ : Type u\ns✝ : I✝ → M.sections\nepi✝ : autoParam (CategoryTheory.Epi (M.freeHomEquiv.symm s✝)) _auto✝\nI : Type u\ns : I → M.sections\nepi : autoParam (CategoryTheory.Epi (M.freeHomEquiv.symm s)) _auto✝\n⊢ Eq (Eq { I := I✝, s := s✝, epi := epi✝ } { I := I, s := s, epi := epi }) (And (Eq I✝ I) (HEq s✝ s))","decl":"/-- The type of sections which generate a sheaf of modules. -/\nstructure GeneratingSections where\n  /-- the index type for the sections -/\n  I : Type u\n  /-- a family of sections which generate the sheaf of modules -/\n  s : I → M.sections\n  epi : Epi (M.freeHomEquiv.symm s) := by infer_instance\n\n"}
{"name":"SheafOfModules.GeneratingSections.ofEpi_I","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninst✝³ : CategoryTheory.HasWeakSheafify J AddCommGrp\ninst✝² : J.WEqualsLocallyBijective AddCommGrp\ninst✝¹ : J.HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\nM N : SheafOfModules R\nσ : M.GeneratingSections\np : Quiver.Hom M N\ninst✝ : CategoryTheory.Epi p\n⊢ Eq (σ.ofEpi p).I σ.I","decl":"/-- If `M ⟶ N` is an epimorphisms and that `M` is generated by some sections,\nthen `N` is generated by the images of these sections. -/\n@[simps]\ndef ofEpi (σ : M.GeneratingSections) (p : M ⟶ N) [Epi p] :\n    N.GeneratingSections where\n  I := σ.I\n  s i := sectionsMap p (σ.s i)\n  epi := by\n    rw [← freeHomEquiv_symm_comp]\n    apply epi_comp\n\n"}
{"name":"SheafOfModules.GeneratingSections.ofEpi_s","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninst✝³ : CategoryTheory.HasWeakSheafify J AddCommGrp\ninst✝² : J.WEqualsLocallyBijective AddCommGrp\ninst✝¹ : J.HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\nM N : SheafOfModules R\nσ : M.GeneratingSections\np : Quiver.Hom M N\ninst✝ : CategoryTheory.Epi p\ni : σ.I\n⊢ Eq ((σ.ofEpi p).s i) (SheafOfModules.sectionsMap p (σ.s i))","decl":"/-- If `M ⟶ N` is an epimorphisms and that `M` is generated by some sections,\nthen `N` is generated by the images of these sections. -/\n@[simps]\ndef ofEpi (σ : M.GeneratingSections) (p : M ⟶ N) [Epi p] :\n    N.GeneratingSections where\n  I := σ.I\n  s i := sectionsMap p (σ.s i)\n  epi := by\n    rw [← freeHomEquiv_symm_comp]\n    apply epi_comp\n\n"}
{"name":"SheafOfModules.GeneratingSections.opEpi_id","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninst✝² : CategoryTheory.HasWeakSheafify J AddCommGrp\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : J.HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\nM : SheafOfModules R\nσ : M.GeneratingSections\n⊢ Eq (σ.ofEpi (CategoryTheory.CategoryStruct.id M)) σ","decl":"lemma opEpi_id (σ : M.GeneratingSections) :\n    σ.ofEpi (𝟙 M) = σ := rfl\n\n"}
{"name":"SheafOfModules.GeneratingSections.opEpi_comp","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝⁵ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninst✝⁴ : CategoryTheory.HasWeakSheafify J AddCommGrp\ninst✝³ : J.WEqualsLocallyBijective AddCommGrp\ninst✝² : J.HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\nM N P : SheafOfModules R\nσ : M.GeneratingSections\np : Quiver.Hom M N\nq : Quiver.Hom N P\ninst✝¹ : CategoryTheory.Epi p\ninst✝ : CategoryTheory.Epi q\n⊢ Eq (σ.ofEpi (CategoryTheory.CategoryStruct.comp p q)) ((σ.ofEpi p).ofEpi q)","decl":"lemma opEpi_comp (σ : M.GeneratingSections) (p : M ⟶ N) (q : N ⟶ P) [Epi p] [Epi q] :\n    σ.ofEpi (p ≫ q) = (σ.ofEpi p).ofEpi q := rfl\n\n"}
{"name":"SheafOfModules.LocalGeneratorsData.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝¹ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\nI✝ : Type u'\nX✝ : I✝ → C\ncoversTop✝ : J.CoversTop X✝\ngenerators✝ : (i : I✝) → (M.over (X✝ i)).GeneratingSections\nI : Type u'\nX : I → C\ncoversTop : J.CoversTop X\ngenerators : (i : I) → (M.over (X i)).GeneratingSections\n⊢ Eq (Eq { I := I✝, X := X✝, coversTop := coversTop✝, generators := generators✝ } { I := I, X := X, coversTop := coversTop, generators := generators }) (And (Eq I✝ I) (And (HEq X✝ X) (HEq generators✝ generators)))","decl":"/-- The data of generating sections of the restriction of a sheaf of modules\nover a covering of the terminal object. -/\nstructure LocalGeneratorsData where\n  /-- the index type of the covering -/\n  I : Type u'\n  /-- a family of objects which cover the terminal object -/\n  X : I → C\n  coversTop : J.CoversTop X\n  /-- the data of sections of `M` over `X i` which generate `M.over (X i)` -/\n  generators (i : I) : (M.over (X i)).GeneratingSections\n\n"}
{"name":"SheafOfModules.LocalGeneratorsData.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝³ : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝² : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninst✝¹ : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝ : SizeOf C\nI : Type u'\nX : I → C\ncoversTop : J.CoversTop X\ngenerators : (i : I) → (M.over (X i)).GeneratingSections\n⊢ Eq (SizeOf.sizeOf { I := I, X := X, coversTop := coversTop, generators := generators }) (HAdd.hAdd 1 (SizeOf.sizeOf I))","decl":"/-- The data of generating sections of the restriction of a sheaf of modules\nover a covering of the terminal object. -/\nstructure LocalGeneratorsData where\n  /-- the index type of the covering -/\n  I : Type u'\n  /-- a family of objects which cover the terminal object -/\n  X : I → C\n  coversTop : J.CoversTop X\n  /-- the data of sections of `M` over `X i` which generate `M.over (X i)` -/\n  generators (i : I) : (M.over (X i)).GeneratingSections\n\n"}
{"name":"SheafOfModules.LocalGeneratorsData.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝¹ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\nI✝ : Type u'\nX✝ : I✝ → C\ncoversTop✝ : J.CoversTop X✝\ngenerators✝ : (i : I✝) → (M.over (X✝ i)).GeneratingSections\nI : Type u'\nX : I → C\ncoversTop : J.CoversTop X\ngenerators : (i : I) → (M.over (X i)).GeneratingSections\nx✝ : Eq { I := I✝, X := X✝, coversTop := coversTop✝, generators := generators✝ } { I := I, X := X, coversTop := coversTop, generators := generators }\n⊢ And (Eq I✝ I) (And (HEq X✝ X) (HEq generators✝ generators))","decl":"/-- The data of generating sections of the restriction of a sheaf of modules\nover a covering of the terminal object. -/\nstructure LocalGeneratorsData where\n  /-- the index type of the covering -/\n  I : Type u'\n  /-- a family of objects which cover the terminal object -/\n  X : I → C\n  coversTop : J.CoversTop X\n  /-- the data of sections of `M` over `X i` which generate `M.over (X i)` -/\n  generators (i : I) : (M.over (X i)).GeneratingSections\n\n"}
{"name":"SheafOfModules.LocalGeneratorsData.coversTop","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝¹ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\nself : M.LocalGeneratorsData\n⊢ J.CoversTop self.X","decl":"/-- The data of generating sections of the restriction of a sheaf of modules\nover a covering of the terminal object. -/\nstructure LocalGeneratorsData where\n  /-- the index type of the covering -/\n  I : Type u'\n  /-- a family of objects which cover the terminal object -/\n  X : I → C\n  coversTop : J.CoversTop X\n  /-- the data of sections of `M` over `X i` which generate `M.over (X i)` -/\n  generators (i : I) : (M.over (X i)).GeneratingSections\n\n"}
{"name":"SheafOfModules.IsFiniteType.exists_localGeneratorsData","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝¹ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\nself : M.IsFiniteType\n⊢ Exists fun σ => ∀ (i : σ.I), Finite (σ.generators i).I","decl":"/-- A sheaf of modules is of finite type if locally, it is generated by finitely\nmany sections. -/\nclass IsFiniteType : Prop where\n  exists_localGeneratorsData :\n    ∃ (σ : M.LocalGeneratorsData), ∀ (i : σ.I), Finite (σ.generators i).I\n\n"}
{"name":"SheafOfModules.instFiniteIOverXLocalGeneratorsDataOfIsFiniteTypeGenerators","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝¹ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\nh : M.IsFiniteType\ni : M.localGeneratorsDataOfIsFiniteType.I\n⊢ Finite (M.localGeneratorsDataOfIsFiniteType.generators i).I","decl":"instance (i : M.localGeneratorsDataOfIsFiniteType.I) :\n    Finite (M.localGeneratorsDataOfIsFiniteType.generators i).I :=\n  h.exists_localGeneratorsData.choose_spec i\n\n"}
