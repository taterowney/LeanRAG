{"name":"SheafOfModules.GeneratingSections.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninstâœÂ³ : CategoryTheory.HasWeakSheafify J AddCommGrp\ninstâœÂ² : J.WEqualsLocallyBijective AddCommGrp\ninstâœÂ¹ : J.HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\nM : SheafOfModules R\ninstâœ : SizeOf C\nI : Type u\ns : I â†’ M.sections\nepi : autoParam (CategoryTheory.Epi (M.freeHomEquiv.symm s)) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { I := I, s := s, epi := epi }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf I)) (SizeOf.sizeOf epi))","decl":"/-- The type of sections which generate a sheaf of modules. -/\nstructure GeneratingSections where\n  /-- the index type for the sections -/\n  I : Type u\n  /-- a family of sections which generate the sheaf of modules -/\n  s : I â†’ M.sections\n  epi : Epi (M.freeHomEquiv.symm s) := by infer_instance\n\n"}
{"name":"SheafOfModules.GeneratingSections.epi","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninstâœÂ² : CategoryTheory.HasWeakSheafify J AddCommGrp\ninstâœÂ¹ : J.WEqualsLocallyBijective AddCommGrp\ninstâœ : J.HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\nM : SheafOfModules R\nself : M.GeneratingSections\nâŠ¢ CategoryTheory.Epi (M.freeHomEquiv.symm self.s)","decl":"/-- The type of sections which generate a sheaf of modules. -/\nstructure GeneratingSections where\n  /-- the index type for the sections -/\n  I : Type u\n  /-- a family of sections which generate the sheaf of modules -/\n  s : I â†’ M.sections\n  epi : Epi (M.freeHomEquiv.symm s) := by infer_instance\n\n"}
{"name":"SheafOfModules.GeneratingSections.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninstâœÂ² : CategoryTheory.HasWeakSheafify J AddCommGrp\ninstâœÂ¹ : J.WEqualsLocallyBijective AddCommGrp\ninstâœ : J.HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\nM : SheafOfModules R\nIâœ : Type u\nsâœ : Iâœ â†’ M.sections\nepiâœ : autoParam (CategoryTheory.Epi (M.freeHomEquiv.symm sâœ)) _autoâœ\nI : Type u\ns : I â†’ M.sections\nepi : autoParam (CategoryTheory.Epi (M.freeHomEquiv.symm s)) _autoâœ\nxâœ : Eq { I := Iâœ, s := sâœ, epi := epiâœ } { I := I, s := s, epi := epi }\nâŠ¢ And (Eq Iâœ I) (HEq sâœ s)","decl":"/-- The type of sections which generate a sheaf of modules. -/\nstructure GeneratingSections where\n  /-- the index type for the sections -/\n  I : Type u\n  /-- a family of sections which generate the sheaf of modules -/\n  s : I â†’ M.sections\n  epi : Epi (M.freeHomEquiv.symm s) := by infer_instance\n\n"}
{"name":"SheafOfModules.GeneratingSections.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninstâœÂ² : CategoryTheory.HasWeakSheafify J AddCommGrp\ninstâœÂ¹ : J.WEqualsLocallyBijective AddCommGrp\ninstâœ : J.HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\nM : SheafOfModules R\nIâœ : Type u\nsâœ : Iâœ â†’ M.sections\nepiâœ : autoParam (CategoryTheory.Epi (M.freeHomEquiv.symm sâœ)) _autoâœ\nI : Type u\ns : I â†’ M.sections\nepi : autoParam (CategoryTheory.Epi (M.freeHomEquiv.symm s)) _autoâœ\nâŠ¢ Eq (Eq { I := Iâœ, s := sâœ, epi := epiâœ } { I := I, s := s, epi := epi }) (And (Eq Iâœ I) (HEq sâœ s))","decl":"/-- The type of sections which generate a sheaf of modules. -/\nstructure GeneratingSections where\n  /-- the index type for the sections -/\n  I : Type u\n  /-- a family of sections which generate the sheaf of modules -/\n  s : I â†’ M.sections\n  epi : Epi (M.freeHomEquiv.symm s) := by infer_instance\n\n"}
{"name":"SheafOfModules.GeneratingSections.ofEpi_I","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninstâœÂ³ : CategoryTheory.HasWeakSheafify J AddCommGrp\ninstâœÂ² : J.WEqualsLocallyBijective AddCommGrp\ninstâœÂ¹ : J.HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\nM N : SheafOfModules R\nÏƒ : M.GeneratingSections\np : Quiver.Hom M N\ninstâœ : CategoryTheory.Epi p\nâŠ¢ Eq (Ïƒ.ofEpi p).I Ïƒ.I","decl":"/-- If `M âŸ¶ N` is an epimorphisms and that `M` is generated by some sections,\nthen `N` is generated by the images of these sections. -/\n@[simps]\ndef ofEpi (Ïƒ : M.GeneratingSections) (p : M âŸ¶ N) [Epi p] :\n    N.GeneratingSections where\n  I := Ïƒ.I\n  s i := sectionsMap p (Ïƒ.s i)\n  epi := by\n    rw [â† freeHomEquiv_symm_comp]\n    apply epi_comp\n\n"}
{"name":"SheafOfModules.GeneratingSections.ofEpi_s","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninstâœÂ³ : CategoryTheory.HasWeakSheafify J AddCommGrp\ninstâœÂ² : J.WEqualsLocallyBijective AddCommGrp\ninstâœÂ¹ : J.HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\nM N : SheafOfModules R\nÏƒ : M.GeneratingSections\np : Quiver.Hom M N\ninstâœ : CategoryTheory.Epi p\ni : Ïƒ.I\nâŠ¢ Eq ((Ïƒ.ofEpi p).s i) (SheafOfModules.sectionsMap p (Ïƒ.s i))","decl":"/-- If `M âŸ¶ N` is an epimorphisms and that `M` is generated by some sections,\nthen `N` is generated by the images of these sections. -/\n@[simps]\ndef ofEpi (Ïƒ : M.GeneratingSections) (p : M âŸ¶ N) [Epi p] :\n    N.GeneratingSections where\n  I := Ïƒ.I\n  s i := sectionsMap p (Ïƒ.s i)\n  epi := by\n    rw [â† freeHomEquiv_symm_comp]\n    apply epi_comp\n\n"}
{"name":"SheafOfModules.GeneratingSections.opEpi_id","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninstâœÂ² : CategoryTheory.HasWeakSheafify J AddCommGrp\ninstâœÂ¹ : J.WEqualsLocallyBijective AddCommGrp\ninstâœ : J.HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\nM : SheafOfModules R\nÏƒ : M.GeneratingSections\nâŠ¢ Eq (Ïƒ.ofEpi (CategoryTheory.CategoryStruct.id M)) Ïƒ","decl":"lemma opEpi_id (Ïƒ : M.GeneratingSections) :\n    Ïƒ.ofEpi (ğŸ™ M) = Ïƒ := rfl\n\n"}
{"name":"SheafOfModules.GeneratingSections.opEpi_comp","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœâµ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\ninstâœâ´ : CategoryTheory.HasWeakSheafify J AddCommGrp\ninstâœÂ³ : J.WEqualsLocallyBijective AddCommGrp\ninstâœÂ² : J.HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\nM N P : SheafOfModules R\nÏƒ : M.GeneratingSections\np : Quiver.Hom M N\nq : Quiver.Hom N P\ninstâœÂ¹ : CategoryTheory.Epi p\ninstâœ : CategoryTheory.Epi q\nâŠ¢ Eq (Ïƒ.ofEpi (CategoryTheory.CategoryStruct.comp p q)) ((Ïƒ.ofEpi p).ofEpi q)","decl":"lemma opEpi_comp (Ïƒ : M.GeneratingSections) (p : M âŸ¶ N) (q : N âŸ¶ P) [Epi p] [Epi q] :\n    Ïƒ.ofEpi (p â‰« q) = (Ïƒ.ofEpi p).ofEpi q := rfl\n\n"}
{"name":"SheafOfModules.LocalGeneratorsData.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninstâœÂ² : âˆ€ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninstâœÂ¹ : âˆ€ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninstâœ : âˆ€ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\nIâœ : Type u'\nXâœ : Iâœ â†’ C\ncoversTopâœ : J.CoversTop Xâœ\ngeneratorsâœ : (i : Iâœ) â†’ (M.over (Xâœ i)).GeneratingSections\nI : Type u'\nX : I â†’ C\ncoversTop : J.CoversTop X\ngenerators : (i : I) â†’ (M.over (X i)).GeneratingSections\nâŠ¢ Eq (Eq { I := Iâœ, X := Xâœ, coversTop := coversTopâœ, generators := generatorsâœ } { I := I, X := X, coversTop := coversTop, generators := generators }) (And (Eq Iâœ I) (And (HEq Xâœ X) (HEq generatorsâœ generators)))","decl":"/-- The data of generating sections of the restriction of a sheaf of modules\nover a covering of the terminal object. -/\nstructure LocalGeneratorsData where\n  /-- the index type of the covering -/\n  I : Type u'\n  /-- a family of objects which cover the terminal object -/\n  X : I â†’ C\n  coversTop : J.CoversTop X\n  /-- the data of sections of `M` over `X i` which generate `M.over (X i)` -/\n  generators (i : I) : (M.over (X i)).GeneratingSections\n\n"}
{"name":"SheafOfModules.LocalGeneratorsData.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœâ´ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninstâœÂ³ : âˆ€ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninstâœÂ² : âˆ€ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninstâœÂ¹ : âˆ€ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\ninstâœ : SizeOf C\nI : Type u'\nX : I â†’ C\ncoversTop : J.CoversTop X\ngenerators : (i : I) â†’ (M.over (X i)).GeneratingSections\nâŠ¢ Eq (SizeOf.sizeOf { I := I, X := X, coversTop := coversTop, generators := generators }) (HAdd.hAdd 1 (SizeOf.sizeOf I))","decl":"/-- The data of generating sections of the restriction of a sheaf of modules\nover a covering of the terminal object. -/\nstructure LocalGeneratorsData where\n  /-- the index type of the covering -/\n  I : Type u'\n  /-- a family of objects which cover the terminal object -/\n  X : I â†’ C\n  coversTop : J.CoversTop X\n  /-- the data of sections of `M` over `X i` which generate `M.over (X i)` -/\n  generators (i : I) : (M.over (X i)).GeneratingSections\n\n"}
{"name":"SheafOfModules.LocalGeneratorsData.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninstâœÂ² : âˆ€ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninstâœÂ¹ : âˆ€ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninstâœ : âˆ€ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\nIâœ : Type u'\nXâœ : Iâœ â†’ C\ncoversTopâœ : J.CoversTop Xâœ\ngeneratorsâœ : (i : Iâœ) â†’ (M.over (Xâœ i)).GeneratingSections\nI : Type u'\nX : I â†’ C\ncoversTop : J.CoversTop X\ngenerators : (i : I) â†’ (M.over (X i)).GeneratingSections\nxâœ : Eq { I := Iâœ, X := Xâœ, coversTop := coversTopâœ, generators := generatorsâœ } { I := I, X := X, coversTop := coversTop, generators := generators }\nâŠ¢ And (Eq Iâœ I) (And (HEq Xâœ X) (HEq generatorsâœ generators))","decl":"/-- The data of generating sections of the restriction of a sheaf of modules\nover a covering of the terminal object. -/\nstructure LocalGeneratorsData where\n  /-- the index type of the covering -/\n  I : Type u'\n  /-- a family of objects which cover the terminal object -/\n  X : I â†’ C\n  coversTop : J.CoversTop X\n  /-- the data of sections of `M` over `X i` which generate `M.over (X i)` -/\n  generators (i : I) : (M.over (X i)).GeneratingSections\n\n"}
{"name":"SheafOfModules.LocalGeneratorsData.coversTop","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninstâœÂ² : âˆ€ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninstâœÂ¹ : âˆ€ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninstâœ : âˆ€ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\nself : M.LocalGeneratorsData\nâŠ¢ J.CoversTop self.X","decl":"/-- The data of generating sections of the restriction of a sheaf of modules\nover a covering of the terminal object. -/\nstructure LocalGeneratorsData where\n  /-- the index type of the covering -/\n  I : Type u'\n  /-- a family of objects which cover the terminal object -/\n  X : I â†’ C\n  coversTop : J.CoversTop X\n  /-- the data of sections of `M` over `X i` which generate `M.over (X i)` -/\n  generators (i : I) : (M.over (X i)).GeneratingSections\n\n"}
{"name":"SheafOfModules.IsFiniteType.exists_localGeneratorsData","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninstâœÂ² : âˆ€ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninstâœÂ¹ : âˆ€ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninstâœ : âˆ€ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\nself : M.IsFiniteType\nâŠ¢ Exists fun Ïƒ => âˆ€ (i : Ïƒ.I), Finite (Ïƒ.generators i).I","decl":"/-- A sheaf of modules is of finite type if locally, it is generated by finitely\nmany sections. -/\nclass IsFiniteType : Prop where\n  exists_localGeneratorsData :\n    âˆƒ (Ïƒ : M.LocalGeneratorsData), âˆ€ (i : Ïƒ.I), Finite (Ïƒ.generators i).I\n\n"}
{"name":"SheafOfModules.instFiniteIOverXLocalGeneratorsDataOfIsFiniteTypeGenerators","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Generators","initialProofState":"C : Type u'\ninstâœÂ³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninstâœÂ² : âˆ€ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninstâœÂ¹ : âˆ€ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninstâœ : âˆ€ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forgetâ‚‚ RingCat AddCommGrp)\nh : M.IsFiniteType\ni : M.localGeneratorsDataOfIsFiniteType.I\nâŠ¢ Finite (M.localGeneratorsDataOfIsFiniteType.generators i).I","decl":"instance (i : M.localGeneratorsDataOfIsFiniteType.I) :\n    Finite (M.localGeneratorsDataOfIsFiniteType.generators i).I :=\n  h.exists_localGeneratorsData.choose_spec i\n\n"}
