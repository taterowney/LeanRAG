{"name":"CategoryTheory.Limits.cokernel.π_desc_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Elementwise","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasCokernel f\nW : C\nk : Quiver.Hom Y W\nh : Eq (CategoryTheory.CategoryStruct.comp f k) 0\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj Y\n⊢ Eq ((CategoryTheory.Limits.cokernel.desc f k h) ((CategoryTheory.Limits.cokernel.π f) x)) (k x)","decl":"set_option linter.existingAttributeWarning false in\nattribute [elementwise (attr := simp)] Cone.w limit.lift_π limit.w\n  colimit.ι_desc colimit.w kernel.lift_ι cokernel.π_desc kernel.condition cokernel.condition\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_π_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Elementwise","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nc : CategoryTheory.Limits.Cone F\nj : J\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj c.pt\n⊢ Eq ((CategoryTheory.Limits.limit.π F j) ((CategoryTheory.Limits.limit.lift F c) x)) ((c.π.app j) x)","decl":"set_option linter.existingAttributeWarning false in\nattribute [elementwise (attr := simp)] Cone.w limit.lift_π limit.w\n  colimit.ι_desc colimit.w kernel.lift_ι cokernel.π_desc kernel.condition cokernel.condition\n\n"}
{"name":"CategoryTheory.Limits.kernel.lift_ι_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Elementwise","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\nW : C\nk : Quiver.Hom W X\nh : Eq (CategoryTheory.CategoryStruct.comp k f) 0\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj W\n⊢ Eq ((CategoryTheory.Limits.kernel.ι f) ((CategoryTheory.Limits.kernel.lift f k h) x)) (k x)","decl":"set_option linter.existingAttributeWarning false in\nattribute [elementwise (attr := simp)] Cone.w limit.lift_π limit.w\n  colimit.ι_desc colimit.w kernel.lift_ι cokernel.π_desc kernel.condition cokernel.condition\n\n"}
{"name":"CategoryTheory.Limits.Cone.w_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Elementwise","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nj j' : J\nf : Quiver.Hom j j'\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (((CategoryTheory.Functor.const J).obj c.pt).obj j)\n⊢ Eq ((F.map f) ((c.π.app j) x)) ((c.π.app j') x)","decl":"set_option linter.existingAttributeWarning false in\nattribute [elementwise (attr := simp)] Cone.w limit.lift_π limit.w\n  colimit.ι_desc colimit.w kernel.lift_ι cokernel.π_desc kernel.condition cokernel.condition\n\n"}
{"name":"CategoryTheory.Limits.colimit.w_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Elementwise","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nj j' : J\nf : Quiver.Hom j j'\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (F.obj j)\n⊢ Eq ((CategoryTheory.Limits.colimit.ι F j') ((F.map f) x)) ((CategoryTheory.Limits.colimit.ι F j) x)","decl":"set_option linter.existingAttributeWarning false in\nattribute [elementwise (attr := simp)] Cone.w limit.lift_π limit.w\n  colimit.ι_desc colimit.w kernel.lift_ι cokernel.π_desc kernel.condition cokernel.condition\n\n"}
{"name":"CategoryTheory.Limits.kernel.condition_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Elementwise","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (CategoryTheory.Limits.kernel f)\n⊢ Eq (f ((CategoryTheory.Limits.kernel.ι f) x)) (0 x)","decl":"set_option linter.existingAttributeWarning false in\nattribute [elementwise (attr := simp)] Cone.w limit.lift_π limit.w\n  colimit.ι_desc colimit.w kernel.lift_ι cokernel.π_desc kernel.condition cokernel.condition\n\n"}
{"name":"CategoryTheory.Limits.limit.w_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Elementwise","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\nj j' : J\nf : Quiver.Hom j j'\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (CategoryTheory.Limits.limit F)\n⊢ Eq ((F.map f) ((CategoryTheory.Limits.limit.π F j) x)) ((CategoryTheory.Limits.limit.π F j') x)","decl":"set_option linter.existingAttributeWarning false in\nattribute [elementwise (attr := simp)] Cone.w limit.lift_π limit.w\n  colimit.ι_desc colimit.w kernel.lift_ι cokernel.π_desc kernel.condition cokernel.condition\n\n"}
{"name":"CategoryTheory.Limits.cokernel.condition_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Elementwise","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasCokernel f\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj X\n⊢ Eq ((CategoryTheory.Limits.cokernel.π f) (f x)) (0 x)","decl":"set_option linter.existingAttributeWarning false in\nattribute [elementwise (attr := simp)] Cone.w limit.lift_π limit.w\n  colimit.ι_desc colimit.w kernel.lift_ι cokernel.π_desc kernel.condition cokernel.condition\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_desc_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Elementwise","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\nc : CategoryTheory.Limits.Cocone F\nj : J\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (F.obj j)\n⊢ Eq ((CategoryTheory.Limits.colimit.desc F c) ((CategoryTheory.Limits.colimit.ι F j) x)) ((c.ι.app j) x)","decl":"set_option linter.existingAttributeWarning false in\nattribute [elementwise (attr := simp)] Cone.w limit.lift_π limit.w\n  colimit.ι_desc colimit.w kernel.lift_ι cokernel.π_desc kernel.condition cokernel.condition\n\n"}
{"name":"CategoryTheory.Limits.Cocone.w_apply","module":"Mathlib.CategoryTheory.ConcreteCategory.Elementwise","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nj j' : J\nf : Quiver.Hom j j'\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (F.obj j)\n⊢ Eq ((c.ι.app j') ((F.map f) x)) ((c.ι.app j) x)","decl":"attribute [elementwise] Cocone.w\n"}
