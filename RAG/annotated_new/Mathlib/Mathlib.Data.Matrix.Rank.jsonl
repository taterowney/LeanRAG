{"name":"Matrix.rank_one","module":"Mathlib.Data.Matrix.Rank","initialProofState":"n : Type u_3\nR : Type u_5\ninst✝³ : Fintype n\ninst✝² : CommRing R\ninst✝¹ : StrongRankCondition R\ninst✝ : DecidableEq n\n⊢ Eq (Matrix.rank 1) (Fintype.card n)","decl":"@[simp]\ntheorem rank_one [StrongRankCondition R] [DecidableEq n] :\n    rank (1 : Matrix n n R) = Fintype.card n := by\n  rw [rank, mulVecLin_one, LinearMap.range_id, finrank_top, finrank_pi]\n\n"}
{"name":"Matrix.rank_zero","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝² : Fintype n\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\n⊢ Eq (Matrix.rank 0) 0","decl":"@[simp]\ntheorem rank_zero [Nontrivial R] : rank (0 : Matrix m n R) = 0 := by\n  rw [rank, mulVecLin_zero, LinearMap.range_zero, finrank_bot]\n\n"}
{"name":"Matrix.rank_le_card_width","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝² : Fintype n\ninst✝¹ : CommRing R\ninst✝ : StrongRankCondition R\nA : Matrix m n R\n⊢ LE.le A.rank (Fintype.card n)","decl":"theorem rank_le_card_width [StrongRankCondition R] (A : Matrix m n R) :\n    A.rank ≤ Fintype.card n := by\n  haveI : Module.Finite R (n → R) := Module.Finite.pi\n  haveI : Module.Free R (n → R) := Module.Free.pi _ _\n  exact A.mulVecLin.finrank_range_le.trans_eq (finrank_pi _)\n\n"}
{"name":"Matrix.rank_le_width","module":"Mathlib.Data.Matrix.Rank","initialProofState":"R : Type u_5\ninst✝¹ : CommRing R\ninst✝ : StrongRankCondition R\nm n : Nat\nA : Matrix (Fin m) (Fin n) R\n⊢ LE.le A.rank n","decl":"theorem rank_le_width [StrongRankCondition R] {m n : ℕ} (A : Matrix (Fin m) (Fin n) R) :\n    A.rank ≤ n :=\n  A.rank_le_card_width.trans <| (Fintype.card_fin n).le\n\n"}
{"name":"Matrix.rank_mul_le_left","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\ninst✝³ : Fintype n\ninst✝² : Fintype o\ninst✝¹ : CommRing R\ninst✝ : StrongRankCondition R\nA : Matrix m n R\nB : Matrix n o R\n⊢ LE.le (HMul.hMul A B).rank A.rank","decl":"theorem rank_mul_le_left [StrongRankCondition R] (A : Matrix m n R) (B : Matrix n o R) :\n    (A * B).rank ≤ A.rank := by\n  rw [rank, rank, mulVecLin_mul]\n  exact Cardinal.toNat_le_toNat (LinearMap.rank_comp_le_left _ _) (rank_lt_aleph0 _ _)\n\n"}
{"name":"Matrix.rank_mul_le_right","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\ninst✝³ : Fintype n\ninst✝² : Fintype o\ninst✝¹ : CommRing R\ninst✝ : StrongRankCondition R\nA : Matrix m n R\nB : Matrix n o R\n⊢ LE.le (HMul.hMul A B).rank B.rank","decl":"theorem rank_mul_le_right [StrongRankCondition R] (A : Matrix m n R) (B : Matrix n o R) :\n    (A * B).rank ≤ B.rank := by\n  rw [rank, rank, mulVecLin_mul]\n  exact finrank_le_finrank_of_rank_le_rank (LinearMap.lift_rank_comp_le_right _ _)\n    (rank_lt_aleph0 _ _)\n\n"}
{"name":"Matrix.rank_mul_le","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\ninst✝³ : Fintype n\ninst✝² : Fintype o\ninst✝¹ : CommRing R\ninst✝ : StrongRankCondition R\nA : Matrix m n R\nB : Matrix n o R\n⊢ LE.le (HMul.hMul A B).rank (Min.min A.rank B.rank)","decl":"theorem rank_mul_le [StrongRankCondition R] (A : Matrix m n R) (B : Matrix n o R) :\n    (A * B).rank ≤ min A.rank B.rank :=\n  le_min (rank_mul_le_left _ _) (rank_mul_le_right _ _)\n\n"}
{"name":"Matrix.rank_unit","module":"Mathlib.Data.Matrix.Rank","initialProofState":"n : Type u_3\nR : Type u_5\ninst✝³ : Fintype n\ninst✝² : CommRing R\ninst✝¹ : StrongRankCondition R\ninst✝ : DecidableEq n\nA : Units (Matrix n n R)\n⊢ Eq (↑A).rank (Fintype.card n)","decl":"theorem rank_unit [StrongRankCondition R] [DecidableEq n] (A : (Matrix n n R)ˣ) :\n    (A : Matrix n n R).rank = Fintype.card n := by\n  apply le_antisymm (rank_le_card_width (A : Matrix n n R)) _\n  have := rank_mul_le_left (A : Matrix n n R) (↑A⁻¹ : Matrix n n R)\n  rwa [← Units.val_mul, mul_inv_cancel, Units.val_one, rank_one] at this\n\n"}
{"name":"Matrix.rank_of_isUnit","module":"Mathlib.Data.Matrix.Rank","initialProofState":"n : Type u_3\nR : Type u_5\ninst✝³ : Fintype n\ninst✝² : CommRing R\ninst✝¹ : StrongRankCondition R\ninst✝ : DecidableEq n\nA : Matrix n n R\nh : IsUnit A\n⊢ Eq A.rank (Fintype.card n)","decl":"theorem rank_of_isUnit [StrongRankCondition R] [DecidableEq n] (A : Matrix n n R) (h : IsUnit A) :\n    A.rank = Fintype.card n := by\n  obtain ⟨A, rfl⟩ := h\n  exact rank_unit A\n\n"}
{"name":"Matrix.rank_mul_eq_left_of_isUnit_det","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝² : Fintype n\ninst✝¹ : CommRing R\ninst✝ : DecidableEq n\nA : Matrix n n R\nB : Matrix m n R\nhA : IsUnit A.det\n⊢ Eq (HMul.hMul B A).rank B.rank","decl":"/-- Right multiplying by an invertible matrix does not change the rank -/\n@[simp]\nlemma rank_mul_eq_left_of_isUnit_det [DecidableEq n]\n    (A : Matrix n n R) (B : Matrix m n R) (hA : IsUnit A.det) :\n    (B * A).rank = B.rank := by\n  suffices Function.Surjective A.mulVecLin by\n    rw [rank, mulVecLin_mul, LinearMap.range_comp_of_range_eq_top _\n      (LinearMap.range_eq_top.mpr this), ← rank]\n  intro v\n  exact ⟨(A⁻¹).mulVecLin v, by simp [mul_nonsing_inv _ hA]⟩\n\n"}
{"name":"Matrix.rank_mul_eq_right_of_isUnit_det","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝³ : Fintype n\ninst✝² : CommRing R\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nA : Matrix m m R\nB : Matrix m n R\nhA : IsUnit A.det\n⊢ Eq (HMul.hMul A B).rank B.rank","decl":"/-- Left multiplying by an invertible matrix does not change the rank -/\n@[simp]\nlemma rank_mul_eq_right_of_isUnit_det [Fintype m] [DecidableEq m]\n    (A : Matrix m m R) (B : Matrix m n R) (hA : IsUnit A.det) :\n    (A * B).rank = B.rank := by\n  let b : Basis m R (m → R) := Pi.basisFun R m\n  replace hA : IsUnit (LinearMap.toMatrix b b A.mulVecLin).det := by\n    convert hA; rw [← LinearEquiv.eq_symm_apply]; rfl\n  have hAB : mulVecLin (A * B) = (LinearEquiv.ofIsUnitDet hA).comp (mulVecLin B) := by ext; simp\n  rw [rank, rank, hAB, LinearMap.range_comp, LinearEquiv.finrank_map_eq]\n\n"}
{"name":"Matrix.rank_submatrix_le","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝³ : Fintype n\ninst✝² : CommRing R\ninst✝¹ : StrongRankCondition R\ninst✝ : Fintype m\nf : n → m\ne : Equiv n m\nA : Matrix m m R\n⊢ LE.le (A.submatrix f ⇑e).rank A.rank","decl":"/-- Taking a subset of the rows and permuting the columns reduces the rank. -/\ntheorem rank_submatrix_le [StrongRankCondition R] [Fintype m] (f : n → m) (e : n ≃ m)\n    (A : Matrix m m R) : rank (A.submatrix f e) ≤ rank A := by\n  rw [rank, rank, mulVecLin_submatrix, LinearMap.range_comp, LinearMap.range_comp,\n    show LinearMap.funLeft R R e.symm = LinearEquiv.funCongrLeft R R e.symm from rfl,\n    LinearEquiv.range, Submodule.map_top]\n  exact Submodule.finrank_map_le _ _\n\n"}
{"name":"Matrix.rank_reindex","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝² : Fintype n\ninst✝¹ : CommRing R\ninst✝ : Fintype m\ne₁ e₂ : Equiv m n\nA : Matrix m m R\n⊢ Eq ((Matrix.reindex e₁ e₂) A).rank A.rank","decl":"theorem rank_reindex [Fintype m] (e₁ e₂ : m ≃ n) (A : Matrix m m R) :\n    rank (reindex e₁ e₂ A) = rank A := by\n  rw [rank, rank, mulVecLin_reindex, LinearMap.range_comp, LinearMap.range_comp,\n    LinearEquiv.range, Submodule.map_top, LinearEquiv.finrank_map_eq]\n\n"}
{"name":"Matrix.rank_submatrix","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝² : Fintype n\ninst✝¹ : CommRing R\ninst✝ : Fintype m\nA : Matrix m m R\ne₁ e₂ : Equiv n m\n⊢ Eq (A.submatrix ⇑e₁ ⇑e₂).rank A.rank","decl":"@[simp]\ntheorem rank_submatrix [Fintype m] (A : Matrix m m R) (e₁ e₂ : n ≃ m) :\n    rank (A.submatrix e₁ e₂) = rank A := by\n  simpa only [reindex_apply] using rank_reindex e₁.symm e₂.symm A\n\n"}
{"name":"Matrix.rank_eq_finrank_range_toLin","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝⁷ : Fintype n\ninst✝⁶ : CommRing R\ninst✝⁵ : Finite m\ninst✝⁴ : DecidableEq n\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nA : Matrix m n R\nv₁ : Basis m R M₁\nv₂ : Basis n R M₂\n⊢ Eq A.rank (Module.finrank R (Subtype fun x => Membership.mem (LinearMap.range ((Matrix.toLin v₂ v₁) A)) x))","decl":"theorem rank_eq_finrank_range_toLin [Finite m] [DecidableEq n] {M₁ M₂ : Type*} [AddCommGroup M₁]\n    [AddCommGroup M₂] [Module R M₁] [Module R M₂] (A : Matrix m n R) (v₁ : Basis m R M₁)\n    (v₂ : Basis n R M₂) : A.rank = finrank R (LinearMap.range (toLin v₂ v₁ A)) := by\n  cases nonempty_fintype m\n  let e₁ := (Pi.basisFun R m).equiv v₁ (Equiv.refl _)\n  let e₂ := (Pi.basisFun R n).equiv v₂ (Equiv.refl _)\n  have range_e₂ : LinearMap.range e₂ = ⊤ := by\n    rw [LinearMap.range_eq_top]\n    exact e₂.surjective\n  refine LinearEquiv.finrank_eq (e₁.ofSubmodules _ _ ?_)\n  rw [← LinearMap.range_comp, ← LinearMap.range_comp_of_range_eq_top (toLin v₂ v₁ A) range_e₂]\n  congr 1\n  apply LinearMap.pi_ext'\n  rintro i\n  apply LinearMap.ext_ring\n  have aux₁ := toLin_self (Pi.basisFun R n) (Pi.basisFun R m) A i\n  have aux₂ := Basis.equiv_apply (Pi.basisFun R n) i v₂\n  rw [toLin_eq_toLin', toLin'_apply'] at aux₁\n  rw [Pi.basisFun_apply] at aux₁ aux₂\n  simp only [e₁, e₂, LinearMap.comp_apply, LinearEquiv.coe_coe, Equiv.refl_apply,\n    aux₁, aux₂, LinearMap.coe_single, toLin_self, map_sum, LinearEquiv.map_smul, Basis.equiv_apply]\n\n"}
{"name":"Matrix.rank_le_card_height","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝³ : Fintype n\ninst✝² : CommRing R\ninst✝¹ : Fintype m\ninst✝ : StrongRankCondition R\nA : Matrix m n R\n⊢ LE.le A.rank (Fintype.card m)","decl":"theorem rank_le_card_height [Fintype m] [StrongRankCondition R] (A : Matrix m n R) :\n    A.rank ≤ Fintype.card m := by\n  haveI : Module.Finite R (m → R) := Module.Finite.pi\n  haveI : Module.Free R (m → R) := Module.Free.pi _ _\n  exact (Submodule.finrank_le _).trans (finrank_pi R).le\n\n"}
{"name":"Matrix.rank_le_height","module":"Mathlib.Data.Matrix.Rank","initialProofState":"R : Type u_5\ninst✝¹ : CommRing R\ninst✝ : StrongRankCondition R\nm n : Nat\nA : Matrix (Fin m) (Fin n) R\n⊢ LE.le A.rank m","decl":"theorem rank_le_height [StrongRankCondition R] {m n : ℕ} (A : Matrix (Fin m) (Fin n) R) :\n    A.rank ≤ m :=\n  A.rank_le_card_height.trans <| (Fintype.card_fin m).le\n\n"}
{"name":"Matrix.rank_eq_finrank_span_cols","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝¹ : Fintype n\ninst✝ : CommRing R\nA : Matrix m n R\n⊢ Eq A.rank (Module.finrank R (Subtype fun x => Membership.mem (Submodule.span R (Set.range A.transpose)) x))","decl":"/-- The rank of a matrix is the rank of the space spanned by its columns. -/\ntheorem rank_eq_finrank_span_cols (A : Matrix m n R) :\n    A.rank = finrank R (Submodule.span R (Set.range Aᵀ)) := by rw [rank, Matrix.range_mulVecLin]\n\n"}
{"name":"Matrix.rank_diagonal","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nR : Type u_5\ninst✝³ : Field R\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq R\nw : m → R\n⊢ Eq (Matrix.diagonal w).rank (Fintype.card (Subtype fun i => Ne (w i) 0))","decl":"/-- The rank of a diagonal matrix is the count of non-zero elements on its main diagonal -/\ntheorem rank_diagonal [Fintype m] [DecidableEq m] [DecidableEq R] (w : m → R) :\n    (diagonal w).rank = Fintype.card {i // (w i) ≠ 0} := by\n  rw [Matrix.rank, ← Matrix.toLin'_apply', Module.finrank, ← LinearMap.rank,\n    LinearMap.rank_diagonal, Cardinal.toNat_natCast]\n\n"}
{"name":"Matrix.ker_mulVecLin_conjTranspose_mul_self","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝⁵ : Fintype n\ninst✝⁴ : Fintype m\ninst✝³ : Field R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nA : Matrix m n R\n⊢ Eq (LinearMap.ker (HMul.hMul A.conjTranspose A).mulVecLin) (LinearMap.ker A.mulVecLin)","decl":"theorem ker_mulVecLin_conjTranspose_mul_self (A : Matrix m n R) :\n    LinearMap.ker (Aᴴ * A).mulVecLin = LinearMap.ker (mulVecLin A) := by\n  ext x\n  simp only [LinearMap.mem_ker, mulVecLin_apply, conjTranspose_mul_self_mulVec_eq_zero]\n\n"}
{"name":"Matrix.rank_conjTranspose_mul_self","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝⁵ : Fintype n\ninst✝⁴ : Fintype m\ninst✝³ : Field R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nA : Matrix m n R\n⊢ Eq (HMul.hMul A.conjTranspose A).rank A.rank","decl":"theorem rank_conjTranspose_mul_self (A : Matrix m n R) : (Aᴴ * A).rank = A.rank := by\n  dsimp only [rank]\n  refine add_left_injective (finrank R (LinearMap.ker (mulVecLin A))) ?_\n  dsimp only\n  trans finrank R { x // x ∈ LinearMap.range (mulVecLin (Aᴴ * A)) } +\n    finrank R { x // x ∈ LinearMap.ker (mulVecLin (Aᴴ * A)) }\n  · rw [ker_mulVecLin_conjTranspose_mul_self]\n  · simp only [LinearMap.finrank_range_add_finrank_ker]\n\n-- this follows the proof here https://math.stackexchange.com/a/81903/1896\n"}
{"name":"Matrix.rank_conjTranspose","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝⁵ : Fintype n\ninst✝⁴ : Fintype m\ninst✝³ : Field R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nA : Matrix m n R\n⊢ Eq A.conjTranspose.rank A.rank","decl":"/-- TODO: prove this in greater generality. -/\n@[simp]\ntheorem rank_conjTranspose (A : Matrix m n R) : Aᴴ.rank = A.rank :=\n  le_antisymm\n    (((rank_conjTranspose_mul_self _).symm.trans_le <| rank_mul_le_left _ _).trans_eq <|\n      congr_arg _ <| conjTranspose_conjTranspose _)\n    ((rank_conjTranspose_mul_self _).symm.trans_le <| rank_mul_le_left _ _)\n\n"}
{"name":"Matrix.rank_self_mul_conjTranspose","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝⁵ : Fintype n\ninst✝⁴ : Fintype m\ninst✝³ : Field R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nA : Matrix m n R\n⊢ Eq (HMul.hMul A A.conjTranspose).rank A.rank","decl":"@[simp]\ntheorem rank_self_mul_conjTranspose (A : Matrix m n R) : (A * Aᴴ).rank = A.rank := by\n  simpa only [rank_conjTranspose, conjTranspose_conjTranspose] using\n    rank_conjTranspose_mul_self Aᴴ\n\n"}
{"name":"Matrix.ker_mulVecLin_transpose_mul_self","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝² : Fintype n\ninst✝¹ : Fintype m\ninst✝ : LinearOrderedField R\nA : Matrix m n R\n⊢ Eq (LinearMap.ker (HMul.hMul A.transpose A).mulVecLin) (LinearMap.ker A.mulVecLin)","decl":"theorem ker_mulVecLin_transpose_mul_self (A : Matrix m n R) :\n    LinearMap.ker (Aᵀ * A).mulVecLin = LinearMap.ker (mulVecLin A) := by\n  ext x\n  simp only [LinearMap.mem_ker, mulVecLin_apply, ← mulVec_mulVec]\n  constructor\n  · intro h\n    replace h := congr_arg (dotProduct x) h\n    rwa [dotProduct_mulVec, dotProduct_zero, vecMul_transpose, dotProduct_self_eq_zero] at h\n  · intro h\n    rw [h, mulVec_zero]\n\n"}
{"name":"Matrix.rank_transpose_mul_self","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝² : Fintype n\ninst✝¹ : Fintype m\ninst✝ : LinearOrderedField R\nA : Matrix m n R\n⊢ Eq (HMul.hMul A.transpose A).rank A.rank","decl":"theorem rank_transpose_mul_self (A : Matrix m n R) : (Aᵀ * A).rank = A.rank := by\n  dsimp only [rank]\n  refine add_left_injective (finrank R <| LinearMap.ker A.mulVecLin) ?_\n  dsimp only\n  trans finrank R { x // x ∈ LinearMap.range (mulVecLin (Aᵀ * A)) } +\n    finrank R { x // x ∈ LinearMap.ker (mulVecLin (Aᵀ * A)) }\n  · rw [ker_mulVecLin_transpose_mul_self]\n  · simp only [LinearMap.finrank_range_add_finrank_ker]\n\n"}
{"name":"Matrix.rank_transpose","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝² : Fintype n\ninst✝¹ : Field R\ninst✝ : Fintype m\nA : Matrix m n R\n⊢ Eq A.transpose.rank A.rank","decl":"@[simp]\ntheorem rank_transpose [Field R] [Fintype m] (A : Matrix m n R) : Aᵀ.rank = A.rank := by\n  classical\n  rw [Aᵀ.rank_eq_finrank_range_toLin (Pi.basisFun R n).dualBasis (Pi.basisFun R m).dualBasis,\n      toLin_transpose, ← LinearMap.dualMap_def, LinearMap.finrank_range_dualMap_eq_finrank_range,\n      toLin_eq_toLin', toLin'_apply', rank]\n\n"}
{"name":"Matrix.rank_self_mul_transpose","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝² : Fintype n\ninst✝¹ : LinearOrderedField R\ninst✝ : Fintype m\nA : Matrix m n R\n⊢ Eq (HMul.hMul A A.transpose).rank A.rank","decl":"@[simp]\ntheorem rank_self_mul_transpose [LinearOrderedField R] [Fintype m] (A : Matrix m n R) :\n    (A * Aᵀ).rank = A.rank := by\n  simpa only [rank_transpose, transpose_transpose] using rank_transpose_mul_self Aᵀ\n\n"}
{"name":"Matrix.rank_eq_finrank_span_row","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝² : Fintype n\ninst✝¹ : Field R\ninst✝ : Finite m\nA : Matrix m n R\n⊢ Eq A.rank (Module.finrank R (Subtype fun x => Membership.mem (Submodule.span R (Set.range A)) x))","decl":"/-- The rank of a matrix is the rank of the space spanned by its rows. -/\ntheorem rank_eq_finrank_span_row [Field R] [Finite m] (A : Matrix m n R) :\n    A.rank = finrank R (Submodule.span R (Set.range A)) := by\n  cases nonempty_fintype m\n  rw [← rank_transpose, rank_eq_finrank_span_cols, transpose_transpose]\n\n"}
{"name":"LinearIndependent.rank_matrix","module":"Mathlib.Data.Matrix.Rank","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝² : Fintype n\ninst✝¹ : Field R\ninst✝ : Fintype m\nM : Matrix m n R\nh : LinearIndependent R M\n⊢ Eq M.rank (Fintype.card m)","decl":"theorem _root_.LinearIndependent.rank_matrix [Field R] [Fintype m]\n    {M : Matrix m n R} (h : LinearIndependent R M) : M.rank = Fintype.card m := by\n  rw [M.rank_eq_finrank_span_row, linearIndependent_iff_card_eq_finrank_span.mp h, Set.finrank]\n\n"}
{"name":"Matrix.rank_add_rank_le_card_of_mul_eq_zero","module":"Mathlib.Data.Matrix.Rank","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_5\ninst✝³ : Fintype n\ninst✝² : Field R\ninst✝¹ : Finite l\ninst✝ : Fintype m\nA : Matrix l m R\nB : Matrix m n R\nhAB : Eq (HMul.hMul A B) 0\n⊢ LE.le (HAdd.hAdd A.rank B.rank) (Fintype.card m)","decl":"lemma rank_add_rank_le_card_of_mul_eq_zero [Field R] [Finite l] [Fintype m]\n    {A : Matrix l m R} {B : Matrix m n R} (hAB : A * B = 0) :\n    A.rank + B.rank ≤ Fintype.card m := by\n  classical\n  let el : Basis l R (l → R) := Pi.basisFun R l\n  let em : Basis m R (m → R) := Pi.basisFun R m\n  let en : Basis n R (n → R) := Pi.basisFun R n\n  rw [Matrix.rank_eq_finrank_range_toLin A el em,\n      Matrix.rank_eq_finrank_range_toLin B em en,\n      ← Module.finrank_fintype_fun_eq_card R,\n      ← LinearMap.finrank_range_add_finrank_ker (Matrix.toLin em el A),\n      add_le_add_iff_left]\n  apply Submodule.finrank_mono\n  rw [LinearMap.range_le_ker_iff, ← Matrix.toLin_mul, hAB, map_zero]\n\n"}
