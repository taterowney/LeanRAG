{"name":"CategoryTheory.GradedObject.mapBifunctor_obj_map","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_6, u_1} Câ‚\ninstâœÂ¹ : CategoryTheory.Category.{u_7, u_2} Câ‚‚\ninstâœ : CategoryTheory.Category.{u_8, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nX : CategoryTheory.GradedObject I Câ‚\nXâœ Yâœ : CategoryTheory.GradedObject J Câ‚‚\nÏ† : Quiver.Hom Xâœ Yâœ\nij : Prod I J\nâŠ¢ Eq (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).map Ï† ij) ((F.obj (X ij.1)).map (Ï† ij.2))","decl":"/-- Given a bifunctor `F : Câ‚ â¥¤ Câ‚‚ â¥¤ Câ‚ƒ` and types `I` and `J`, this is the obvious\nfunctor `GradedObject I Câ‚ â¥¤ GradedObject J Câ‚‚ â¥¤ GradedObject (I Ã— J) Câ‚ƒ`. -/\n@[simps]\ndef mapBifunctor (I J : Type*) :\n    GradedObject I Câ‚ â¥¤ GradedObject J Câ‚‚ â¥¤ GradedObject (I Ã— J) Câ‚ƒ where\n  obj X :=\n    { obj := fun Y ij => (F.obj (X ij.1)).obj (Y ij.2)\n      map := fun Ï† ij => (F.obj (X ij.1)).map (Ï† ij.2) }\n  map Ï† :=\n    { app := fun Y ij => (F.map (Ï† ij.1)).app (Y ij.2) }\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctor_obj_obj","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_6, u_1} Câ‚\ninstâœÂ¹ : CategoryTheory.Category.{u_7, u_2} Câ‚‚\ninstâœ : CategoryTheory.Category.{u_8, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nX : CategoryTheory.GradedObject I Câ‚\nY : CategoryTheory.GradedObject J Câ‚‚\nij : Prod I J\nâŠ¢ Eq (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y ij) ((F.obj (X ij.1)).obj (Y ij.2))","decl":"/-- Given a bifunctor `F : Câ‚ â¥¤ Câ‚‚ â¥¤ Câ‚ƒ` and types `I` and `J`, this is the obvious\nfunctor `GradedObject I Câ‚ â¥¤ GradedObject J Câ‚‚ â¥¤ GradedObject (I Ã— J) Câ‚ƒ`. -/\n@[simps]\ndef mapBifunctor (I J : Type*) :\n    GradedObject I Câ‚ â¥¤ GradedObject J Câ‚‚ â¥¤ GradedObject (I Ã— J) Câ‚ƒ where\n  obj X :=\n    { obj := fun Y ij => (F.obj (X ij.1)).obj (Y ij.2)\n      map := fun Ï† ij => (F.obj (X ij.1)).map (Ï† ij.2) }\n  map Ï† :=\n    { app := fun Y ij => (F.map (Ï† ij.1)).app (Y ij.2) }\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctor_map_app","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_6, u_1} Câ‚\ninstâœÂ¹ : CategoryTheory.Category.{u_7, u_2} Câ‚‚\ninstâœ : CategoryTheory.Category.{u_8, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nXâœ Yâœ : CategoryTheory.GradedObject I Câ‚\nÏ† : Quiver.Hom Xâœ Yâœ\nY : CategoryTheory.GradedObject J Câ‚‚\nij : Prod I J\nâŠ¢ Eq (((CategoryTheory.GradedObject.mapBifunctor F I J).map Ï†).app Y ij) ((F.map (Ï† ij.1)).app (Y ij.2))","decl":"/-- Given a bifunctor `F : Câ‚ â¥¤ Câ‚‚ â¥¤ Câ‚ƒ` and types `I` and `J`, this is the obvious\nfunctor `GradedObject I Câ‚ â¥¤ GradedObject J Câ‚‚ â¥¤ GradedObject (I Ã— J) Câ‚ƒ`. -/\n@[simps]\ndef mapBifunctor (I J : Type*) :\n    GradedObject I Câ‚ â¥¤ GradedObject J Câ‚‚ â¥¤ GradedObject (I Ã— J) Câ‚ƒ where\n  obj X :=\n    { obj := fun Y ij => (F.obj (X ij.1)).obj (Y ij.2)\n      map := fun Ï† ij => (F.obj (X ij.1)).map (Ï† ij.2) }\n  map Ï† :=\n    { app := fun Y ij => (F.map (Ï† ij.1)).app (Y ij.2) }\n\n"}
{"name":"CategoryTheory.GradedObject.Î¹_mapBifunctorMapMap_assoc","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_7, u_1} Câ‚\ninstâœÂ³ : CategoryTheory.Category.{u_8, u_2} Câ‚‚\ninstâœÂ² : CategoryTheory.Category.{u_9, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J â†’ K\nXâ‚ Xâ‚‚ : CategoryTheory.GradedObject I Câ‚\nf : Quiver.Hom Xâ‚ Xâ‚‚\nYâ‚ Yâ‚‚ : CategoryTheory.GradedObject J Câ‚‚\ng : Quiver.Hom Yâ‚ Yâ‚‚\ninstâœÂ¹ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj Xâ‚).obj Yâ‚).HasMap p\ninstâœ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj Xâ‚‚).obj Yâ‚‚).HasMap p\ni : I\nj : J\nk : K\nhâœ : Eq (p { fst := i, snd := j }) k\nZ : Câ‚ƒ\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F p Xâ‚‚ Yâ‚‚ k) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.Î¹MapBifunctorMapObj F p Xâ‚ Yâ‚ i j k hâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorMapMap F p f g k) h)) (CategoryTheory.CategoryStruct.comp ((F.map (f i)).app (Yâ‚ j)) (CategoryTheory.CategoryStruct.comp ((F.obj (Xâ‚‚ i)).map (g j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.Î¹MapBifunctorMapObj F p Xâ‚‚ Yâ‚‚ i j k hâœ) h)))","decl":"@[reassoc (attr := simp)]\nlemma Î¹_mapBifunctorMapMap {Xâ‚ Xâ‚‚ : GradedObject I Câ‚} (f : Xâ‚ âŸ¶ Xâ‚‚)\n    {Yâ‚ Yâ‚‚ : GradedObject J Câ‚‚} (g : Yâ‚ âŸ¶ Yâ‚‚)\n    [HasMap (((mapBifunctor F I J).obj Xâ‚).obj Yâ‚) p]\n    [HasMap (((mapBifunctor F I J).obj Xâ‚‚).obj Yâ‚‚) p]\n    (i : I) (j : J) (k : K) (h : p âŸ¨i, jâŸ© = k) :\n    Î¹MapBifunctorMapObj F p Xâ‚ Yâ‚ i j k h â‰« mapBifunctorMapMap F p f g k =\n      (F.map (f i)).app (Yâ‚ j) â‰« (F.obj (Xâ‚‚ i)).map (g j) â‰«\n        Î¹MapBifunctorMapObj F p Xâ‚‚ Yâ‚‚ i j k h := by\n  simp [Î¹MapBifunctorMapObj, mapBifunctorMapMap]\n\n"}
{"name":"CategoryTheory.GradedObject.Î¹_mapBifunctorMapMap","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_7, u_1} Câ‚\ninstâœÂ³ : CategoryTheory.Category.{u_8, u_2} Câ‚‚\ninstâœÂ² : CategoryTheory.Category.{u_9, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J â†’ K\nXâ‚ Xâ‚‚ : CategoryTheory.GradedObject I Câ‚\nf : Quiver.Hom Xâ‚ Xâ‚‚\nYâ‚ Yâ‚‚ : CategoryTheory.GradedObject J Câ‚‚\ng : Quiver.Hom Yâ‚ Yâ‚‚\ninstâœÂ¹ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj Xâ‚).obj Yâ‚).HasMap p\ninstâœ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj Xâ‚‚).obj Yâ‚‚).HasMap p\ni : I\nj : J\nk : K\nh : Eq (p { fst := i, snd := j }) k\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.Î¹MapBifunctorMapObj F p Xâ‚ Yâ‚ i j k h) (CategoryTheory.GradedObject.mapBifunctorMapMap F p f g k)) (CategoryTheory.CategoryStruct.comp ((F.map (f i)).app (Yâ‚ j)) (CategoryTheory.CategoryStruct.comp ((F.obj (Xâ‚‚ i)).map (g j)) (CategoryTheory.GradedObject.Î¹MapBifunctorMapObj F p Xâ‚‚ Yâ‚‚ i j k h)))","decl":"@[reassoc (attr := simp)]\nlemma Î¹_mapBifunctorMapMap {Xâ‚ Xâ‚‚ : GradedObject I Câ‚} (f : Xâ‚ âŸ¶ Xâ‚‚)\n    {Yâ‚ Yâ‚‚ : GradedObject J Câ‚‚} (g : Yâ‚ âŸ¶ Yâ‚‚)\n    [HasMap (((mapBifunctor F I J).obj Xâ‚).obj Yâ‚) p]\n    [HasMap (((mapBifunctor F I J).obj Xâ‚‚).obj Yâ‚‚) p]\n    (i : I) (j : J) (k : K) (h : p âŸ¨i, jâŸ© = k) :\n    Î¹MapBifunctorMapObj F p Xâ‚ Yâ‚ i j k h â‰« mapBifunctorMapMap F p f g k =\n      (F.map (f i)).app (Yâ‚ j) â‰« (F.obj (Xâ‚‚ i)).map (g j) â‰«\n        Î¹MapBifunctorMapObj F p Xâ‚‚ Yâ‚‚ i j k h := by\n  simp [Î¹MapBifunctorMapObj, mapBifunctorMapMap]\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMapObj_ext","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_9, u_1} Câ‚\ninstâœÂ² : CategoryTheory.Category.{u_8, u_2} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{u_7, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J â†’ K\nX : CategoryTheory.GradedObject I Câ‚\nY : CategoryTheory.GradedObject J Câ‚‚\nA : Câ‚ƒ\nk : K\ninstâœ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nf g : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F p X Y k) A\nh : âˆ€ (i : I) (j : J) (hij : Eq (p { fst := i, snd := j }) k), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.Î¹MapBifunctorMapObj F p X Y i j k hij) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.Î¹MapBifunctorMapObj F p X Y i j k hij) g)\nâŠ¢ Eq f g","decl":"@[ext]\nlemma mapBifunctorMapObj_ext {X : GradedObject I Câ‚} {Y : GradedObject J Câ‚‚} {A : Câ‚ƒ} {k : K}\n    [HasMap (((mapBifunctor F I J).obj X).obj Y) p]\n    {f g : mapBifunctorMapObj F p X Y k âŸ¶ A}\n    (h : âˆ€ (i : I) (j : J) (hij : p âŸ¨i, jâŸ© = k),\n      Î¹MapBifunctorMapObj F p X Y i j k hij â‰« f = Î¹MapBifunctorMapObj F p X Y i j k hij â‰« g) :\n    f = g := by\n  apply mapObj_ext\n  rintro âŸ¨i, jâŸ© hij\n  exact h i j hij\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMapObj_ext_iff","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_9, u_1} Câ‚\ninstâœÂ² : CategoryTheory.Category.{u_8, u_2} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{u_7, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J â†’ K\nX : CategoryTheory.GradedObject I Câ‚\nY : CategoryTheory.GradedObject J Câ‚‚\nA : Câ‚ƒ\nk : K\ninstâœ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nf g : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F p X Y k) A\nâŠ¢ Iff (Eq f g) (âˆ€ (i : I) (j : J) (hij : Eq (p { fst := i, snd := j }) k), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.Î¹MapBifunctorMapObj F p X Y i j k hij) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.Î¹MapBifunctorMapObj F p X Y i j k hij) g))","decl":"@[ext]\nlemma mapBifunctorMapObj_ext {X : GradedObject I Câ‚} {Y : GradedObject J Câ‚‚} {A : Câ‚ƒ} {k : K}\n    [HasMap (((mapBifunctor F I J).obj X).obj Y) p]\n    {f g : mapBifunctorMapObj F p X Y k âŸ¶ A}\n    (h : âˆ€ (i : I) (j : J) (hij : p âŸ¨i, jâŸ© = k),\n      Î¹MapBifunctorMapObj F p X Y i j k hij â‰« f = Î¹MapBifunctorMapObj F p X Y i j k hij â‰« g) :\n    f = g := by\n  apply mapObj_ext\n  rintro âŸ¨i, jâŸ© hij\n  exact h i j hij\n\n"}
{"name":"CategoryTheory.GradedObject.Î¹_mapBifunctorMapObjDesc","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_9, u_1} Câ‚\ninstâœÂ² : CategoryTheory.Category.{u_8, u_2} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{u_7, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J â†’ K\nX : CategoryTheory.GradedObject I Câ‚\nY : CategoryTheory.GradedObject J Câ‚‚\nA : Câ‚ƒ\nk : K\ninstâœ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nf : (i : I) â†’ (j : J) â†’ Eq (p { fst := i, snd := j }) k â†’ Quiver.Hom ((F.obj (X i)).obj (Y j)) A\ni : I\nj : J\nhij : Eq (p { fst := i, snd := j }) k\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.Î¹MapBifunctorMapObj F p X Y i j k hij) (CategoryTheory.GradedObject.mapBifunctorMapObjDesc f)) (f i j hij)","decl":"@[reassoc (attr := simp)]\nlemma Î¹_mapBifunctorMapObjDesc {X : GradedObject I Câ‚} {Y : GradedObject J Câ‚‚} {A : Câ‚ƒ} {k : K}\n    [HasMap (((mapBifunctor F I J).obj X).obj Y) p]\n    (f : âˆ€ (i : I) (j : J) (_ : p âŸ¨i, jâŸ© = k), (F.obj (X i)).obj (Y j) âŸ¶ A)\n    (i : I) (j : J) (hij : p âŸ¨i, jâŸ© = k) :\n    Î¹MapBifunctorMapObj F p X Y i j k hij â‰« mapBifunctorMapObjDesc f = f i j hij := by\n  apply Î¹_descMapObj\n\n"}
{"name":"CategoryTheory.GradedObject.Î¹_mapBifunctorMapObjDesc_assoc","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_9, u_1} Câ‚\ninstâœÂ² : CategoryTheory.Category.{u_8, u_2} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{u_7, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J â†’ K\nX : CategoryTheory.GradedObject I Câ‚\nY : CategoryTheory.GradedObject J Câ‚‚\nA : Câ‚ƒ\nk : K\ninstâœ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nf : (i : I) â†’ (j : J) â†’ Eq (p { fst := i, snd := j }) k â†’ Quiver.Hom ((F.obj (X i)).obj (Y j)) A\ni : I\nj : J\nhij : Eq (p { fst := i, snd := j }) k\nZ : Câ‚ƒ\nh : Quiver.Hom A Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.Î¹MapBifunctorMapObj F p X Y i j k hij) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorMapObjDesc f) h)) (CategoryTheory.CategoryStruct.comp (f i j hij) h)","decl":"@[reassoc (attr := simp)]\nlemma Î¹_mapBifunctorMapObjDesc {X : GradedObject I Câ‚} {Y : GradedObject J Câ‚‚} {A : Câ‚ƒ} {k : K}\n    [HasMap (((mapBifunctor F I J).obj X).obj Y) p]\n    (f : âˆ€ (i : I) (j : J) (_ : p âŸ¨i, jâŸ© = k), (F.obj (X i)).obj (Y j) âŸ¶ A)\n    (i : I) (j : J) (hij : p âŸ¨i, jâŸ© = k) :\n    Î¹MapBifunctorMapObj F p X Y i j k hij â‰« mapBifunctorMapObjDesc f = f i j hij := by\n  apply Î¹_descMapObj\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMapMapIso_hom","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_7, u_1} Câ‚\ninstâœÂ³ : CategoryTheory.Category.{u_8, u_2} Câ‚‚\ninstâœÂ² : CategoryTheory.Category.{u_9, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J â†’ K\nXâ‚ Xâ‚‚ : CategoryTheory.GradedObject I Câ‚\nYâ‚ Yâ‚‚ : CategoryTheory.GradedObject J Câ‚‚\ninstâœÂ¹ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj Xâ‚).obj Yâ‚).HasMap p\ninstâœ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj Xâ‚‚).obj Yâ‚‚).HasMap p\ne : CategoryTheory.Iso Xâ‚ Xâ‚‚\ne' : CategoryTheory.Iso Yâ‚ Yâ‚‚\ni : K\nâŠ¢ Eq ((CategoryTheory.GradedObject.mapBifunctorMapMapIso F p e e').hom i) (CategoryTheory.GradedObject.mapBifunctorMapMap F p e.hom e'.hom i)","decl":"/-- The isomorphism `mapBifunctorMapObj F p Xâ‚ Yâ‚ â‰… mapBifunctorMapObj F p Xâ‚‚ Yâ‚‚`\ninduced by isomorphisms `Xâ‚ â‰… Xâ‚‚` and `Yâ‚ â‰… Yâ‚‚`. -/\n@[simps]\nnoncomputable def mapBifunctorMapMapIso (e : Xâ‚ â‰… Xâ‚‚) (e' : Yâ‚ â‰… Yâ‚‚) :\n    mapBifunctorMapObj F p Xâ‚ Yâ‚ â‰… mapBifunctorMapObj F p Xâ‚‚ Yâ‚‚ where\n  hom := mapBifunctorMapMap F p e.hom e'.hom\n  inv := mapBifunctorMapMap F p e.inv e'.inv\n  hom_inv_id := by ext; simp\n  inv_hom_id := by ext; simp\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMapMapIso_inv","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_7, u_1} Câ‚\ninstâœÂ³ : CategoryTheory.Category.{u_8, u_2} Câ‚‚\ninstâœÂ² : CategoryTheory.Category.{u_9, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J â†’ K\nXâ‚ Xâ‚‚ : CategoryTheory.GradedObject I Câ‚\nYâ‚ Yâ‚‚ : CategoryTheory.GradedObject J Câ‚‚\ninstâœÂ¹ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj Xâ‚).obj Yâ‚).HasMap p\ninstâœ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj Xâ‚‚).obj Yâ‚‚).HasMap p\ne : CategoryTheory.Iso Xâ‚ Xâ‚‚\ne' : CategoryTheory.Iso Yâ‚ Yâ‚‚\ni : K\nâŠ¢ Eq ((CategoryTheory.GradedObject.mapBifunctorMapMapIso F p e e').inv i) (CategoryTheory.GradedObject.mapBifunctorMapMap F p e.inv e'.inv i)","decl":"/-- The isomorphism `mapBifunctorMapObj F p Xâ‚ Yâ‚ â‰… mapBifunctorMapObj F p Xâ‚‚ Yâ‚‚`\ninduced by isomorphisms `Xâ‚ â‰… Xâ‚‚` and `Yâ‚ â‰… Yâ‚‚`. -/\n@[simps]\nnoncomputable def mapBifunctorMapMapIso (e : Xâ‚ â‰… Xâ‚‚) (e' : Yâ‚ â‰… Yâ‚‚) :\n    mapBifunctorMapObj F p Xâ‚ Yâ‚ â‰… mapBifunctorMapObj F p Xâ‚‚ Yâ‚‚ where\n  hom := mapBifunctorMapMap F p e.hom e'.hom\n  inv := mapBifunctorMapMap F p e.inv e'.inv\n  hom_inv_id := by ext; simp\n  inv_hom_id := by ext; simp\n\n"}
{"name":"CategoryTheory.GradedObject.instIsIsoMapBifunctorMapMap","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœâ¶ : CategoryTheory.Category.{u_7, u_1} Câ‚\ninstâœâµ : CategoryTheory.Category.{u_8, u_2} Câ‚‚\ninstâœâ´ : CategoryTheory.Category.{u_9, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J â†’ K\nXâ‚ Xâ‚‚ : CategoryTheory.GradedObject I Câ‚\nYâ‚ Yâ‚‚ : CategoryTheory.GradedObject J Câ‚‚\ninstâœÂ³ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj Xâ‚).obj Yâ‚).HasMap p\ninstâœÂ² : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj Xâ‚‚).obj Yâ‚‚).HasMap p\nf : Quiver.Hom Xâ‚ Xâ‚‚\ng : Quiver.Hom Yâ‚ Yâ‚‚\ninstâœÂ¹ : CategoryTheory.IsIso f\ninstâœ : CategoryTheory.IsIso g\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.GradedObject.mapBifunctorMapMap F p f g)","decl":"instance (f : Xâ‚ âŸ¶ Xâ‚‚) (g : Yâ‚ âŸ¶ Yâ‚‚) [IsIso f] [IsIso g] :\n    IsIso (mapBifunctorMapMap F p f g) :=\n  (inferInstance : IsIso (mapBifunctorMapMapIso F p (asIso f) (asIso g)).hom)\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMap_map_app","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} Câ‚\ninstâœÂ² : CategoryTheory.Category.{u_8, u_2} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{u_9, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J â†’ K\ninstâœ : âˆ€ (X : CategoryTheory.GradedObject I Câ‚) (Y : CategoryTheory.GradedObject J Câ‚‚), (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nXâ‚ Xâ‚‚ : CategoryTheory.GradedObject I Câ‚\nÏ† : Quiver.Hom Xâ‚ Xâ‚‚\nY : CategoryTheory.GradedObject J Câ‚‚\ni : K\nâŠ¢ Eq (((CategoryTheory.GradedObject.mapBifunctorMap F p).map Ï†).app Y i) (CategoryTheory.GradedObject.mapBifunctorMapMap F p Ï† (CategoryTheory.CategoryStruct.id Y) i)","decl":"/-- Given a bifunctor `F : Câ‚ â¥¤ Câ‚‚ â¥¤ Câ‚ƒ` and a map `p : I Ã— J â†’ K`, this is the\nfunctor `GradedObject I Câ‚ â¥¤ GradedObject J Câ‚‚ â¥¤ GradedObject K Câ‚ƒ` sending\n`X : GradedObject I Câ‚` and `Y : GradedObject J Câ‚‚` to the `K`-graded object sending\n`k` to the coproduct of `(F.obj (X i)).obj (Y j)` for `p âŸ¨i, jâŸ© = k`. -/\n@[simps]\nnoncomputable def mapBifunctorMap [âˆ€ X Y, HasMap (((mapBifunctor F I J).obj X).obj Y) p] :\n    GradedObject I Câ‚ â¥¤ GradedObject J Câ‚‚ â¥¤ GradedObject K Câ‚ƒ where\n  obj X :=\n    { obj := fun Y => mapBifunctorMapObj F p X Y\n      map := fun Ïˆ => mapBifunctorMapMap F p (ğŸ™ X) Ïˆ }\n  map {Xâ‚ Xâ‚‚} Ï† :=\n    { app := fun Y => mapBifunctorMapMap F p Ï† (ğŸ™ Y)\n      naturality := fun {Yâ‚ Yâ‚‚} Ïˆ => by\n        dsimp\n        simp only [Functor.map_id, NatTrans.id_app, id_comp, comp_id,\n          â† mapMap_comp, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMap_obj_obj","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} Câ‚\ninstâœÂ² : CategoryTheory.Category.{u_8, u_2} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{u_9, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J â†’ K\ninstâœ : âˆ€ (X : CategoryTheory.GradedObject I Câ‚) (Y : CategoryTheory.GradedObject J Câ‚‚), (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nX : CategoryTheory.GradedObject I Câ‚\nY : CategoryTheory.GradedObject J Câ‚‚\nâŠ¢ Eq (((CategoryTheory.GradedObject.mapBifunctorMap F p).obj X).obj Y) (CategoryTheory.GradedObject.mapBifunctorMapObj F p X Y)","decl":"/-- Given a bifunctor `F : Câ‚ â¥¤ Câ‚‚ â¥¤ Câ‚ƒ` and a map `p : I Ã— J â†’ K`, this is the\nfunctor `GradedObject I Câ‚ â¥¤ GradedObject J Câ‚‚ â¥¤ GradedObject K Câ‚ƒ` sending\n`X : GradedObject I Câ‚` and `Y : GradedObject J Câ‚‚` to the `K`-graded object sending\n`k` to the coproduct of `(F.obj (X i)).obj (Y j)` for `p âŸ¨i, jâŸ© = k`. -/\n@[simps]\nnoncomputable def mapBifunctorMap [âˆ€ X Y, HasMap (((mapBifunctor F I J).obj X).obj Y) p] :\n    GradedObject I Câ‚ â¥¤ GradedObject J Câ‚‚ â¥¤ GradedObject K Câ‚ƒ where\n  obj X :=\n    { obj := fun Y => mapBifunctorMapObj F p X Y\n      map := fun Ïˆ => mapBifunctorMapMap F p (ğŸ™ X) Ïˆ }\n  map {Xâ‚ Xâ‚‚} Ï† :=\n    { app := fun Y => mapBifunctorMapMap F p Ï† (ğŸ™ Y)\n      naturality := fun {Yâ‚ Yâ‚‚} Ïˆ => by\n        dsimp\n        simp only [Functor.map_id, NatTrans.id_app, id_comp, comp_id,\n          â† mapMap_comp, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMap_obj_map","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} Câ‚\ninstâœÂ² : CategoryTheory.Category.{u_8, u_2} Câ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{u_9, u_3} Câ‚ƒ\nF : CategoryTheory.Functor Câ‚ (CategoryTheory.Functor Câ‚‚ Câ‚ƒ)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J â†’ K\ninstâœ : âˆ€ (X : CategoryTheory.GradedObject I Câ‚) (Y : CategoryTheory.GradedObject J Câ‚‚), (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nX : CategoryTheory.GradedObject I Câ‚\nXâœ Yâœ : CategoryTheory.GradedObject J Câ‚‚\nÏˆ : Quiver.Hom Xâœ Yâœ\ni : K\nâŠ¢ Eq (((CategoryTheory.GradedObject.mapBifunctorMap F p).obj X).map Ïˆ i) (CategoryTheory.GradedObject.mapBifunctorMapMap F p (CategoryTheory.CategoryStruct.id X) Ïˆ i)","decl":"/-- Given a bifunctor `F : Câ‚ â¥¤ Câ‚‚ â¥¤ Câ‚ƒ` and a map `p : I Ã— J â†’ K`, this is the\nfunctor `GradedObject I Câ‚ â¥¤ GradedObject J Câ‚‚ â¥¤ GradedObject K Câ‚ƒ` sending\n`X : GradedObject I Câ‚` and `Y : GradedObject J Câ‚‚` to the `K`-graded object sending\n`k` to the coproduct of `(F.obj (X i)).obj (Y j)` for `p âŸ¨i, jâŸ© = k`. -/\n@[simps]\nnoncomputable def mapBifunctorMap [âˆ€ X Y, HasMap (((mapBifunctor F I J).obj X).obj Y) p] :\n    GradedObject I Câ‚ â¥¤ GradedObject J Câ‚‚ â¥¤ GradedObject K Câ‚ƒ where\n  obj X :=\n    { obj := fun Y => mapBifunctorMapObj F p X Y\n      map := fun Ïˆ => mapBifunctorMapMap F p (ğŸ™ X) Ïˆ }\n  map {Xâ‚ Xâ‚‚} Ï† :=\n    { app := fun Y => mapBifunctorMapMap F p Ï† (ğŸ™ Y)\n      naturality := fun {Yâ‚ Yâ‚‚} Ïˆ => by\n        dsimp\n        simp only [Functor.map_id, NatTrans.id_app, id_comp, comp_id,\n          â† mapMap_comp, NatTrans.naturality] }\n\n"}
