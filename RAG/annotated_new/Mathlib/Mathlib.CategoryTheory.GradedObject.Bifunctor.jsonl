{"name":"CategoryTheory.GradedObject.mapBifunctor_obj_map","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_7, u_2} C₂\ninst✝ : CategoryTheory.Category.{u_8, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nX : CategoryTheory.GradedObject I C₁\nX✝ Y✝ : CategoryTheory.GradedObject J C₂\nφ : Quiver.Hom X✝ Y✝\nij : Prod I J\n⊢ Eq (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).map φ ij) ((F.obj (X ij.1)).map (φ ij.2))","decl":"/-- Given a bifunctor `F : C₁ ⥤ C₂ ⥤ C₃` and types `I` and `J`, this is the obvious\nfunctor `GradedObject I C₁ ⥤ GradedObject J C₂ ⥤ GradedObject (I × J) C₃`. -/\n@[simps]\ndef mapBifunctor (I J : Type*) :\n    GradedObject I C₁ ⥤ GradedObject J C₂ ⥤ GradedObject (I × J) C₃ where\n  obj X :=\n    { obj := fun Y ij => (F.obj (X ij.1)).obj (Y ij.2)\n      map := fun φ ij => (F.obj (X ij.1)).map (φ ij.2) }\n  map φ :=\n    { app := fun Y ij => (F.map (φ ij.1)).app (Y ij.2) }\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctor_obj_obj","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_7, u_2} C₂\ninst✝ : CategoryTheory.Category.{u_8, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nX : CategoryTheory.GradedObject I C₁\nY : CategoryTheory.GradedObject J C₂\nij : Prod I J\n⊢ Eq (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y ij) ((F.obj (X ij.1)).obj (Y ij.2))","decl":"/-- Given a bifunctor `F : C₁ ⥤ C₂ ⥤ C₃` and types `I` and `J`, this is the obvious\nfunctor `GradedObject I C₁ ⥤ GradedObject J C₂ ⥤ GradedObject (I × J) C₃`. -/\n@[simps]\ndef mapBifunctor (I J : Type*) :\n    GradedObject I C₁ ⥤ GradedObject J C₂ ⥤ GradedObject (I × J) C₃ where\n  obj X :=\n    { obj := fun Y ij => (F.obj (X ij.1)).obj (Y ij.2)\n      map := fun φ ij => (F.obj (X ij.1)).map (φ ij.2) }\n  map φ :=\n    { app := fun Y ij => (F.map (φ ij.1)).app (Y ij.2) }\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctor_map_app","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_7, u_2} C₂\ninst✝ : CategoryTheory.Category.{u_8, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nX✝ Y✝ : CategoryTheory.GradedObject I C₁\nφ : Quiver.Hom X✝ Y✝\nY : CategoryTheory.GradedObject J C₂\nij : Prod I J\n⊢ Eq (((CategoryTheory.GradedObject.mapBifunctor F I J).map φ).app Y ij) ((F.map (φ ij.1)).app (Y ij.2))","decl":"/-- Given a bifunctor `F : C₁ ⥤ C₂ ⥤ C₃` and types `I` and `J`, this is the obvious\nfunctor `GradedObject I C₁ ⥤ GradedObject J C₂ ⥤ GradedObject (I × J) C₃`. -/\n@[simps]\ndef mapBifunctor (I J : Type*) :\n    GradedObject I C₁ ⥤ GradedObject J C₂ ⥤ GradedObject (I × J) C₃ where\n  obj X :=\n    { obj := fun Y ij => (F.obj (X ij.1)).obj (Y ij.2)\n      map := fun φ ij => (F.obj (X ij.1)).map (φ ij.2) }\n  map φ :=\n    { app := fun Y ij => (F.map (φ ij.1)).app (Y ij.2) }\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorMapMap_assoc","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J → K\nX₁ X₂ : CategoryTheory.GradedObject I C₁\nf : Quiver.Hom X₁ X₂\nY₁ Y₂ : CategoryTheory.GradedObject J C₂\ng : Quiver.Hom Y₁ Y₂\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X₁).obj Y₁).HasMap p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X₂).obj Y₂).HasMap p\ni : I\nj : J\nk : K\nh✝ : Eq (p { fst := i, snd := j }) k\nZ : C₃\nh : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F p X₂ Y₂ k) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorMapObj F p X₁ Y₁ i j k h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorMapMap F p f g k) h)) (CategoryTheory.CategoryStruct.comp ((F.map (f i)).app (Y₁ j)) (CategoryTheory.CategoryStruct.comp ((F.obj (X₂ i)).map (g j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorMapObj F p X₂ Y₂ i j k h✝) h)))","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorMapMap {X₁ X₂ : GradedObject I C₁} (f : X₁ ⟶ X₂)\n    {Y₁ Y₂ : GradedObject J C₂} (g : Y₁ ⟶ Y₂)\n    [HasMap (((mapBifunctor F I J).obj X₁).obj Y₁) p]\n    [HasMap (((mapBifunctor F I J).obj X₂).obj Y₂) p]\n    (i : I) (j : J) (k : K) (h : p ⟨i, j⟩ = k) :\n    ιMapBifunctorMapObj F p X₁ Y₁ i j k h ≫ mapBifunctorMapMap F p f g k =\n      (F.map (f i)).app (Y₁ j) ≫ (F.obj (X₂ i)).map (g j) ≫\n        ιMapBifunctorMapObj F p X₂ Y₂ i j k h := by\n  simp [ιMapBifunctorMapObj, mapBifunctorMapMap]\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorMapMap","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J → K\nX₁ X₂ : CategoryTheory.GradedObject I C₁\nf : Quiver.Hom X₁ X₂\nY₁ Y₂ : CategoryTheory.GradedObject J C₂\ng : Quiver.Hom Y₁ Y₂\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X₁).obj Y₁).HasMap p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X₂).obj Y₂).HasMap p\ni : I\nj : J\nk : K\nh : Eq (p { fst := i, snd := j }) k\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorMapObj F p X₁ Y₁ i j k h) (CategoryTheory.GradedObject.mapBifunctorMapMap F p f g k)) (CategoryTheory.CategoryStruct.comp ((F.map (f i)).app (Y₁ j)) (CategoryTheory.CategoryStruct.comp ((F.obj (X₂ i)).map (g j)) (CategoryTheory.GradedObject.ιMapBifunctorMapObj F p X₂ Y₂ i j k h)))","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorMapMap {X₁ X₂ : GradedObject I C₁} (f : X₁ ⟶ X₂)\n    {Y₁ Y₂ : GradedObject J C₂} (g : Y₁ ⟶ Y₂)\n    [HasMap (((mapBifunctor F I J).obj X₁).obj Y₁) p]\n    [HasMap (((mapBifunctor F I J).obj X₂).obj Y₂) p]\n    (i : I) (j : J) (k : K) (h : p ⟨i, j⟩ = k) :\n    ιMapBifunctorMapObj F p X₁ Y₁ i j k h ≫ mapBifunctorMapMap F p f g k =\n      (F.map (f i)).app (Y₁ j) ≫ (F.obj (X₂ i)).map (g j) ≫\n        ιMapBifunctorMapObj F p X₂ Y₂ i j k h := by\n  simp [ιMapBifunctorMapObj, mapBifunctorMapMap]\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMapObj_ext","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝³ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J → K\nX : CategoryTheory.GradedObject I C₁\nY : CategoryTheory.GradedObject J C₂\nA : C₃\nk : K\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nf g : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F p X Y k) A\nh : ∀ (i : I) (j : J) (hij : Eq (p { fst := i, snd := j }) k), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorMapObj F p X Y i j k hij) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorMapObj F p X Y i j k hij) g)\n⊢ Eq f g","decl":"@[ext]\nlemma mapBifunctorMapObj_ext {X : GradedObject I C₁} {Y : GradedObject J C₂} {A : C₃} {k : K}\n    [HasMap (((mapBifunctor F I J).obj X).obj Y) p]\n    {f g : mapBifunctorMapObj F p X Y k ⟶ A}\n    (h : ∀ (i : I) (j : J) (hij : p ⟨i, j⟩ = k),\n      ιMapBifunctorMapObj F p X Y i j k hij ≫ f = ιMapBifunctorMapObj F p X Y i j k hij ≫ g) :\n    f = g := by\n  apply mapObj_ext\n  rintro ⟨i, j⟩ hij\n  exact h i j hij\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMapObj_ext_iff","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝³ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J → K\nX : CategoryTheory.GradedObject I C₁\nY : CategoryTheory.GradedObject J C₂\nA : C₃\nk : K\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nf g : Quiver.Hom (CategoryTheory.GradedObject.mapBifunctorMapObj F p X Y k) A\n⊢ Iff (Eq f g) (∀ (i : I) (j : J) (hij : Eq (p { fst := i, snd := j }) k), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorMapObj F p X Y i j k hij) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorMapObj F p X Y i j k hij) g))","decl":"@[ext]\nlemma mapBifunctorMapObj_ext {X : GradedObject I C₁} {Y : GradedObject J C₂} {A : C₃} {k : K}\n    [HasMap (((mapBifunctor F I J).obj X).obj Y) p]\n    {f g : mapBifunctorMapObj F p X Y k ⟶ A}\n    (h : ∀ (i : I) (j : J) (hij : p ⟨i, j⟩ = k),\n      ιMapBifunctorMapObj F p X Y i j k hij ≫ f = ιMapBifunctorMapObj F p X Y i j k hij ≫ g) :\n    f = g := by\n  apply mapObj_ext\n  rintro ⟨i, j⟩ hij\n  exact h i j hij\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorMapObjDesc","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝³ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J → K\nX : CategoryTheory.GradedObject I C₁\nY : CategoryTheory.GradedObject J C₂\nA : C₃\nk : K\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nf : (i : I) → (j : J) → Eq (p { fst := i, snd := j }) k → Quiver.Hom ((F.obj (X i)).obj (Y j)) A\ni : I\nj : J\nhij : Eq (p { fst := i, snd := j }) k\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorMapObj F p X Y i j k hij) (CategoryTheory.GradedObject.mapBifunctorMapObjDesc f)) (f i j hij)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorMapObjDesc {X : GradedObject I C₁} {Y : GradedObject J C₂} {A : C₃} {k : K}\n    [HasMap (((mapBifunctor F I J).obj X).obj Y) p]\n    (f : ∀ (i : I) (j : J) (_ : p ⟨i, j⟩ = k), (F.obj (X i)).obj (Y j) ⟶ A)\n    (i : I) (j : J) (hij : p ⟨i, j⟩ = k) :\n    ιMapBifunctorMapObj F p X Y i j k hij ≫ mapBifunctorMapObjDesc f = f i j hij := by\n  apply ι_descMapObj\n\n"}
{"name":"CategoryTheory.GradedObject.ι_mapBifunctorMapObjDesc_assoc","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝³ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J → K\nX : CategoryTheory.GradedObject I C₁\nY : CategoryTheory.GradedObject J C₂\nA : C₃\nk : K\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nf : (i : I) → (j : J) → Eq (p { fst := i, snd := j }) k → Quiver.Hom ((F.obj (X i)).obj (Y j)) A\ni : I\nj : J\nhij : Eq (p { fst := i, snd := j }) k\nZ : C₃\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.ιMapBifunctorMapObj F p X Y i j k hij) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapBifunctorMapObjDesc f) h)) (CategoryTheory.CategoryStruct.comp (f i j hij) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_mapBifunctorMapObjDesc {X : GradedObject I C₁} {Y : GradedObject J C₂} {A : C₃} {k : K}\n    [HasMap (((mapBifunctor F I J).obj X).obj Y) p]\n    (f : ∀ (i : I) (j : J) (_ : p ⟨i, j⟩ = k), (F.obj (X i)).obj (Y j) ⟶ A)\n    (i : I) (j : J) (hij : p ⟨i, j⟩ = k) :\n    ιMapBifunctorMapObj F p X Y i j k hij ≫ mapBifunctorMapObjDesc f = f i j hij := by\n  apply ι_descMapObj\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMapMapIso_hom","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J → K\nX₁ X₂ : CategoryTheory.GradedObject I C₁\nY₁ Y₂ : CategoryTheory.GradedObject J C₂\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X₁).obj Y₁).HasMap p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X₂).obj Y₂).HasMap p\ne : CategoryTheory.Iso X₁ X₂\ne' : CategoryTheory.Iso Y₁ Y₂\ni : K\n⊢ Eq ((CategoryTheory.GradedObject.mapBifunctorMapMapIso F p e e').hom i) (CategoryTheory.GradedObject.mapBifunctorMapMap F p e.hom e'.hom i)","decl":"/-- The isomorphism `mapBifunctorMapObj F p X₁ Y₁ ≅ mapBifunctorMapObj F p X₂ Y₂`\ninduced by isomorphisms `X₁ ≅ X₂` and `Y₁ ≅ Y₂`. -/\n@[simps]\nnoncomputable def mapBifunctorMapMapIso (e : X₁ ≅ X₂) (e' : Y₁ ≅ Y₂) :\n    mapBifunctorMapObj F p X₁ Y₁ ≅ mapBifunctorMapObj F p X₂ Y₂ where\n  hom := mapBifunctorMapMap F p e.hom e'.hom\n  inv := mapBifunctorMapMap F p e.inv e'.inv\n  hom_inv_id := by ext; simp\n  inv_hom_id := by ext; simp\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMapMapIso_inv","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J → K\nX₁ X₂ : CategoryTheory.GradedObject I C₁\nY₁ Y₂ : CategoryTheory.GradedObject J C₂\ninst✝¹ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X₁).obj Y₁).HasMap p\ninst✝ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X₂).obj Y₂).HasMap p\ne : CategoryTheory.Iso X₁ X₂\ne' : CategoryTheory.Iso Y₁ Y₂\ni : K\n⊢ Eq ((CategoryTheory.GradedObject.mapBifunctorMapMapIso F p e e').inv i) (CategoryTheory.GradedObject.mapBifunctorMapMap F p e.inv e'.inv i)","decl":"/-- The isomorphism `mapBifunctorMapObj F p X₁ Y₁ ≅ mapBifunctorMapObj F p X₂ Y₂`\ninduced by isomorphisms `X₁ ≅ X₂` and `Y₁ ≅ Y₂`. -/\n@[simps]\nnoncomputable def mapBifunctorMapMapIso (e : X₁ ≅ X₂) (e' : Y₁ ≅ Y₂) :\n    mapBifunctorMapObj F p X₁ Y₁ ≅ mapBifunctorMapObj F p X₂ Y₂ where\n  hom := mapBifunctorMapMap F p e.hom e'.hom\n  inv := mapBifunctorMapMap F p e.inv e'.inv\n  hom_inv_id := by ext; simp\n  inv_hom_id := by ext; simp\n\n"}
{"name":"CategoryTheory.GradedObject.instIsIsoMapBifunctorMapMap","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝⁶ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_9, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J → K\nX₁ X₂ : CategoryTheory.GradedObject I C₁\nY₁ Y₂ : CategoryTheory.GradedObject J C₂\ninst✝³ : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X₁).obj Y₁).HasMap p\ninst✝² : (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X₂).obj Y₂).HasMap p\nf : Quiver.Hom X₁ X₂\ng : Quiver.Hom Y₁ Y₂\ninst✝¹ : CategoryTheory.IsIso f\ninst✝ : CategoryTheory.IsIso g\n⊢ CategoryTheory.IsIso (CategoryTheory.GradedObject.mapBifunctorMapMap F p f g)","decl":"instance (f : X₁ ⟶ X₂) (g : Y₁ ⟶ Y₂) [IsIso f] [IsIso g] :\n    IsIso (mapBifunctorMapMap F p f g) :=\n  (inferInstance : IsIso (mapBifunctorMapMapIso F p (asIso f) (asIso g)).hom)\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMap_map_app","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_9, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J → K\ninst✝ : ∀ (X : CategoryTheory.GradedObject I C₁) (Y : CategoryTheory.GradedObject J C₂), (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nX₁ X₂ : CategoryTheory.GradedObject I C₁\nφ : Quiver.Hom X₁ X₂\nY : CategoryTheory.GradedObject J C₂\ni : K\n⊢ Eq (((CategoryTheory.GradedObject.mapBifunctorMap F p).map φ).app Y i) (CategoryTheory.GradedObject.mapBifunctorMapMap F p φ (CategoryTheory.CategoryStruct.id Y) i)","decl":"/-- Given a bifunctor `F : C₁ ⥤ C₂ ⥤ C₃` and a map `p : I × J → K`, this is the\nfunctor `GradedObject I C₁ ⥤ GradedObject J C₂ ⥤ GradedObject K C₃` sending\n`X : GradedObject I C₁` and `Y : GradedObject J C₂` to the `K`-graded object sending\n`k` to the coproduct of `(F.obj (X i)).obj (Y j)` for `p ⟨i, j⟩ = k`. -/\n@[simps]\nnoncomputable def mapBifunctorMap [∀ X Y, HasMap (((mapBifunctor F I J).obj X).obj Y) p] :\n    GradedObject I C₁ ⥤ GradedObject J C₂ ⥤ GradedObject K C₃ where\n  obj X :=\n    { obj := fun Y => mapBifunctorMapObj F p X Y\n      map := fun ψ => mapBifunctorMapMap F p (𝟙 X) ψ }\n  map {X₁ X₂} φ :=\n    { app := fun Y => mapBifunctorMapMap F p φ (𝟙 Y)\n      naturality := fun {Y₁ Y₂} ψ => by\n        dsimp\n        simp only [Functor.map_id, NatTrans.id_app, id_comp, comp_id,\n          ← mapMap_comp, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMap_obj_obj","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_9, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J → K\ninst✝ : ∀ (X : CategoryTheory.GradedObject I C₁) (Y : CategoryTheory.GradedObject J C₂), (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nX : CategoryTheory.GradedObject I C₁\nY : CategoryTheory.GradedObject J C₂\n⊢ Eq (((CategoryTheory.GradedObject.mapBifunctorMap F p).obj X).obj Y) (CategoryTheory.GradedObject.mapBifunctorMapObj F p X Y)","decl":"/-- Given a bifunctor `F : C₁ ⥤ C₂ ⥤ C₃` and a map `p : I × J → K`, this is the\nfunctor `GradedObject I C₁ ⥤ GradedObject J C₂ ⥤ GradedObject K C₃` sending\n`X : GradedObject I C₁` and `Y : GradedObject J C₂` to the `K`-graded object sending\n`k` to the coproduct of `(F.obj (X i)).obj (Y j)` for `p ⟨i, j⟩ = k`. -/\n@[simps]\nnoncomputable def mapBifunctorMap [∀ X Y, HasMap (((mapBifunctor F I J).obj X).obj Y) p] :\n    GradedObject I C₁ ⥤ GradedObject J C₂ ⥤ GradedObject K C₃ where\n  obj X :=\n    { obj := fun Y => mapBifunctorMapObj F p X Y\n      map := fun ψ => mapBifunctorMapMap F p (𝟙 X) ψ }\n  map {X₁ X₂} φ :=\n    { app := fun Y => mapBifunctorMapMap F p φ (𝟙 Y)\n      naturality := fun {Y₁ Y₂} ψ => by\n        dsimp\n        simp only [Functor.map_id, NatTrans.id_app, id_comp, comp_id,\n          ← mapMap_comp, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.GradedObject.mapBifunctorMap_obj_map","module":"Mathlib.CategoryTheory.GradedObject.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_9, u_3} C₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₃)\nI : Type u_4\nJ : Type u_5\nK : Type u_6\np : Prod I J → K\ninst✝ : ∀ (X : CategoryTheory.GradedObject I C₁) (Y : CategoryTheory.GradedObject J C₂), (((CategoryTheory.GradedObject.mapBifunctor F I J).obj X).obj Y).HasMap p\nX : CategoryTheory.GradedObject I C₁\nX✝ Y✝ : CategoryTheory.GradedObject J C₂\nψ : Quiver.Hom X✝ Y✝\ni : K\n⊢ Eq (((CategoryTheory.GradedObject.mapBifunctorMap F p).obj X).map ψ i) (CategoryTheory.GradedObject.mapBifunctorMapMap F p (CategoryTheory.CategoryStruct.id X) ψ i)","decl":"/-- Given a bifunctor `F : C₁ ⥤ C₂ ⥤ C₃` and a map `p : I × J → K`, this is the\nfunctor `GradedObject I C₁ ⥤ GradedObject J C₂ ⥤ GradedObject K C₃` sending\n`X : GradedObject I C₁` and `Y : GradedObject J C₂` to the `K`-graded object sending\n`k` to the coproduct of `(F.obj (X i)).obj (Y j)` for `p ⟨i, j⟩ = k`. -/\n@[simps]\nnoncomputable def mapBifunctorMap [∀ X Y, HasMap (((mapBifunctor F I J).obj X).obj Y) p] :\n    GradedObject I C₁ ⥤ GradedObject J C₂ ⥤ GradedObject K C₃ where\n  obj X :=\n    { obj := fun Y => mapBifunctorMapObj F p X Y\n      map := fun ψ => mapBifunctorMapMap F p (𝟙 X) ψ }\n  map {X₁ X₂} φ :=\n    { app := fun Y => mapBifunctorMapMap F p φ (𝟙 Y)\n      naturality := fun {Y₁ Y₂} ψ => by\n        dsimp\n        simp only [Functor.map_id, NatTrans.id_app, id_comp, comp_id,\n          ← mapMap_comp, NatTrans.naturality] }\n\n"}
