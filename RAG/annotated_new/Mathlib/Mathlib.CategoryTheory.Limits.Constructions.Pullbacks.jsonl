{"name":"CategoryTheory.Limits.hasLimit_cospan_of_hasLimit_pair_of_hasLimit_parallelPair","module":"Mathlib.CategoryTheory.Limits.Constructions.Pullbacks","initialProofState":"C : Type u\nğ’ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)\ninstâœ : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd g))\nâŠ¢ CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)","decl":"/-- If the product `X â¨¯ Y` and the equalizer of `Ï€â‚ â‰« f` and `Ï€â‚‚ â‰« g` exist, then the\n    pullback of `f` and `g` exists: It is given by composing the equalizer with the projections. -/\ntheorem hasLimit_cospan_of_hasLimit_pair_of_hasLimit_parallelPair {C : Type u} [ğ’ : Category.{v} C]\n    {X Y Z : C} (f : X âŸ¶ Z) (g : Y âŸ¶ Z) [HasLimit (pair X Y)]\n    [HasLimit (parallelPair (prod.fst â‰« f) (prod.snd â‰« g))] : HasLimit (cospan f g) :=\n  let Ï€â‚ : X â¨¯ Y âŸ¶ X := prod.fst\n  let Ï€â‚‚ : X â¨¯ Y âŸ¶ Y := prod.snd\n  let e := equalizer.Î¹ (Ï€â‚ â‰« f) (Ï€â‚‚ â‰« g)\n  HasLimit.mk\n    { cone :=\n        PullbackCone.mk (e â‰« Ï€â‚) (e â‰« Ï€â‚‚) <| by\n          rw [Category.assoc, equalizer.condition]\n          simp [e]\n      isLimit :=\n        PullbackCone.IsLimit.mk _ (fun s => equalizer.lift\n          (prod.lift (s.Ï€.app WalkingCospan.left) (s.Ï€.app WalkingCospan.right)) <| by\n            rw [â† Category.assoc, limit.lift_Ï€, â† Category.assoc, limit.lift_Ï€]\n            exact PullbackCone.condition _)\n          (by simp [Ï€â‚, e]) (by simp [Ï€â‚‚, e]) fun s m hâ‚ hâ‚‚ => by\n          ext\n          Â· dsimp; simpa using hâ‚\n          Â· simpa using hâ‚‚ }\n\n"}
{"name":"CategoryTheory.Limits.hasPullbacks_of_hasBinaryProducts_of_hasEqualizers","module":"Mathlib.CategoryTheory.Limits.Constructions.Pullbacks","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryProducts C\ninstâœ : CategoryTheory.Limits.HasEqualizers C\nâŠ¢ CategoryTheory.Limits.HasPullbacks C","decl":"/-- If a category has all binary products and all equalizers, then it also has all pullbacks.\n    As usual, this is not an instance, since there may be a more direct way to construct\n    pullbacks. -/\ntheorem hasPullbacks_of_hasBinaryProducts_of_hasEqualizers (C : Type u) [Category.{v} C]\n    [HasBinaryProducts C] [HasEqualizers C] : HasPullbacks C :=\n  { has_limit := fun F => hasLimitOfIso (diagramIsoCospan F).symm }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair","module":"Mathlib.CategoryTheory.Limits.Constructions.Pullbacks","initialProofState":"C : Type u\nğ’ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair Y Z)\ninstâœ : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelPair (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.coprod.inl) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.coprod.inr))\nâŠ¢ CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)","decl":"/-- If the coproduct `Y â¨¿ Z` and the coequalizer of `f â‰« Î¹â‚` and `g â‰« Î¹â‚‚` exist, then the\n    pushout of `f` and `g` exists: It is given by composing the inclusions with the coequalizer. -/\ntheorem hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair {C : Type u}\n    [ğ’ : Category.{v} C] {X Y Z : C} (f : X âŸ¶ Y) (g : X âŸ¶ Z) [HasColimit (pair Y Z)]\n    [HasColimit (parallelPair (f â‰« coprod.inl) (g â‰« coprod.inr))] : HasColimit (span f g) :=\n  let Î¹â‚ : Y âŸ¶ Y â¨¿ Z := coprod.inl\n  let Î¹â‚‚ : Z âŸ¶ Y â¨¿ Z := coprod.inr\n  let c := coequalizer.Ï€ (f â‰« Î¹â‚) (g â‰« Î¹â‚‚)\n  HasColimit.mk\n    { cocone :=\n        PushoutCocone.mk (Î¹â‚ â‰« c) (Î¹â‚‚ â‰« c) <| by\n          rw [â† Category.assoc, â† Category.assoc, coequalizer.condition]\n      isColimit :=\n        PushoutCocone.IsColimit.mk _\n          (fun s => coequalizer.desc\n              (coprod.desc (s.Î¹.app WalkingSpan.left) (s.Î¹.app WalkingSpan.right)) <| by\n            rw [Category.assoc, colimit.Î¹_desc, Category.assoc, colimit.Î¹_desc]\n            exact PushoutCocone.condition _)\n          (by simp [Î¹â‚, c]) (by simp [Î¹â‚‚, c]) fun s m hâ‚ hâ‚‚ => by\n          ext\n          Â· simpa using hâ‚\n          Â· simpa using hâ‚‚ }\n\n"}
{"name":"CategoryTheory.Limits.hasPushouts_of_hasBinaryCoproducts_of_hasCoequalizers","module":"Mathlib.CategoryTheory.Limits.Constructions.Pullbacks","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasBinaryCoproducts C\ninstâœ : CategoryTheory.Limits.HasCoequalizers C\nâŠ¢ CategoryTheory.Limits.HasPushouts C","decl":"/-- If a category has all binary coproducts and all coequalizers, then it also has all pushouts.\n    As usual, this is not an instance, since there may be a more direct way to construct\n    pushouts. -/\ntheorem hasPushouts_of_hasBinaryCoproducts_of_hasCoequalizers (C : Type u) [Category.{v} C]\n    [HasBinaryCoproducts C] [HasCoequalizers C] : HasPushouts C :=\n  hasPushouts_of_hasColimit_span C\n\n"}
