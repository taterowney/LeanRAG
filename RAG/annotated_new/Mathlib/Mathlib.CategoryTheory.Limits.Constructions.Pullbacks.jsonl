{"name":"CategoryTheory.Limits.hasLimit_cospan_of_hasLimit_pair_of_hasLimit_parallelPair","module":"Mathlib.CategoryTheory.Limits.Constructions.Pullbacks","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)\ninst✝ : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd g))\n⊢ CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)","decl":"/-- If the product `X ⨯ Y` and the equalizer of `π₁ ≫ f` and `π₂ ≫ g` exist, then the\n    pullback of `f` and `g` exists: It is given by composing the equalizer with the projections. -/\ntheorem hasLimit_cospan_of_hasLimit_pair_of_hasLimit_parallelPair {C : Type u} [𝒞 : Category.{v} C]\n    {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [HasLimit (pair X Y)]\n    [HasLimit (parallelPair (prod.fst ≫ f) (prod.snd ≫ g))] : HasLimit (cospan f g) :=\n  let π₁ : X ⨯ Y ⟶ X := prod.fst\n  let π₂ : X ⨯ Y ⟶ Y := prod.snd\n  let e := equalizer.ι (π₁ ≫ f) (π₂ ≫ g)\n  HasLimit.mk\n    { cone :=\n        PullbackCone.mk (e ≫ π₁) (e ≫ π₂) <| by\n          rw [Category.assoc, equalizer.condition]\n          simp [e]\n      isLimit :=\n        PullbackCone.IsLimit.mk _ (fun s => equalizer.lift\n          (prod.lift (s.π.app WalkingCospan.left) (s.π.app WalkingCospan.right)) <| by\n            rw [← Category.assoc, limit.lift_π, ← Category.assoc, limit.lift_π]\n            exact PullbackCone.condition _)\n          (by simp [π₁, e]) (by simp [π₂, e]) fun s m h₁ h₂ => by\n          ext\n          · dsimp; simpa using h₁\n          · simpa using h₂ }\n\n"}
{"name":"CategoryTheory.Limits.hasPullbacks_of_hasBinaryProducts_of_hasEqualizers","module":"Mathlib.CategoryTheory.Limits.Constructions.Pullbacks","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProducts C\ninst✝ : CategoryTheory.Limits.HasEqualizers C\n⊢ CategoryTheory.Limits.HasPullbacks C","decl":"/-- If a category has all binary products and all equalizers, then it also has all pullbacks.\n    As usual, this is not an instance, since there may be a more direct way to construct\n    pullbacks. -/\ntheorem hasPullbacks_of_hasBinaryProducts_of_hasEqualizers (C : Type u) [Category.{v} C]\n    [HasBinaryProducts C] [HasEqualizers C] : HasPullbacks C :=\n  { has_limit := fun F => hasLimitOfIso (diagramIsoCospan F).symm }\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair","module":"Mathlib.CategoryTheory.Limits.Constructions.Pullbacks","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair Y Z)\ninst✝ : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelPair (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.coprod.inl) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.coprod.inr))\n⊢ CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)","decl":"/-- If the coproduct `Y ⨿ Z` and the coequalizer of `f ≫ ι₁` and `g ≫ ι₂` exist, then the\n    pushout of `f` and `g` exists: It is given by composing the inclusions with the coequalizer. -/\ntheorem hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair {C : Type u}\n    [𝒞 : Category.{v} C] {X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z) [HasColimit (pair Y Z)]\n    [HasColimit (parallelPair (f ≫ coprod.inl) (g ≫ coprod.inr))] : HasColimit (span f g) :=\n  let ι₁ : Y ⟶ Y ⨿ Z := coprod.inl\n  let ι₂ : Z ⟶ Y ⨿ Z := coprod.inr\n  let c := coequalizer.π (f ≫ ι₁) (g ≫ ι₂)\n  HasColimit.mk\n    { cocone :=\n        PushoutCocone.mk (ι₁ ≫ c) (ι₂ ≫ c) <| by\n          rw [← Category.assoc, ← Category.assoc, coequalizer.condition]\n      isColimit :=\n        PushoutCocone.IsColimit.mk _\n          (fun s => coequalizer.desc\n              (coprod.desc (s.ι.app WalkingSpan.left) (s.ι.app WalkingSpan.right)) <| by\n            rw [Category.assoc, colimit.ι_desc, Category.assoc, colimit.ι_desc]\n            exact PushoutCocone.condition _)\n          (by simp [ι₁, c]) (by simp [ι₂, c]) fun s m h₁ h₂ => by\n          ext\n          · simpa using h₁\n          · simpa using h₂ }\n\n"}
{"name":"CategoryTheory.Limits.hasPushouts_of_hasBinaryCoproducts_of_hasCoequalizers","module":"Mathlib.CategoryTheory.Limits.Constructions.Pullbacks","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst✝ : CategoryTheory.Limits.HasCoequalizers C\n⊢ CategoryTheory.Limits.HasPushouts C","decl":"/-- If a category has all binary coproducts and all coequalizers, then it also has all pushouts.\n    As usual, this is not an instance, since there may be a more direct way to construct\n    pushouts. -/\ntheorem hasPushouts_of_hasBinaryCoproducts_of_hasCoequalizers (C : Type u) [Category.{v} C]\n    [HasBinaryCoproducts C] [HasCoequalizers C] : HasPushouts C :=\n  hasPushouts_of_hasColimit_span C\n\n"}
