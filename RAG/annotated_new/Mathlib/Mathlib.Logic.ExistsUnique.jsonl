{"name":"ExistsUnique.intro","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\np : α → Prop\nw : α\nh₁ : p w\nh₂ : ∀ (y : α), p y → Eq y w\n⊢ ExistsUnique fun x => p x","decl":"theorem ExistsUnique.intro {p : α → Prop} (w : α)\n    (h₁ : p w) (h₂ : ∀ y, p y → y = w) : ∃! x, p x := ⟨w, h₁, h₂⟩\n\n"}
{"name":"ExistsUnique.elim","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\np : α → Prop\nb : Prop\nh₂ : ExistsUnique fun x => p x\nh₁ : ∀ (x : α), p x → (∀ (y : α), p y → Eq y x) → b\n⊢ b","decl":"theorem ExistsUnique.elim {p : α → Prop} {b : Prop}\n    (h₂ : ∃! x, p x) (h₁ : ∀ x, p x → (∀ y, p y → y = x) → b) : b :=\n  Exists.elim h₂ (fun w hw ↦ h₁ w (And.left hw) (And.right hw))\n\n"}
{"name":"existsUnique_of_exists_of_unique","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\np : α → Prop\nhex : Exists fun x => p x\nhunique : ∀ (y₁ y₂ : α), p y₁ → p y₂ → Eq y₁ y₂\n⊢ ExistsUnique fun x => p x","decl":"theorem existsUnique_of_exists_of_unique {p : α → Prop}\n    (hex : ∃ x, p x) (hunique : ∀ y₁ y₂, p y₁ → p y₂ → y₁ = y₂) : ∃! x, p x :=\n  Exists.elim hex (fun x px ↦ ExistsUnique.intro x px (fun y (h : p y) ↦ hunique y x h px))\n\n"}
{"name":"exists_unique_of_exists_of_unique","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\np : α → Prop\nhex : Exists fun x => p x\nhunique : ∀ (y₁ y₂ : α), p y₁ → p y₂ → Eq y₁ y₂\n⊢ ExistsUnique fun x => p x","decl":"@[deprecated (since := \"2024-12-17\")]\nalias exists_unique_of_exists_of_unique := existsUnique_of_exists_of_unique\n\n"}
{"name":"ExistsUnique.exists","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\np : α → Prop\na✝ : ExistsUnique fun x => p x\n⊢ Exists fun x => p x","decl":"theorem ExistsUnique.exists {p : α → Prop} : (∃! x, p x) → ∃ x, p x | ⟨x, h, _⟩ => ⟨x, h⟩\n\n"}
{"name":"ExistsUnique.unique","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\np : α → Prop\nh : ExistsUnique fun x => p x\ny₁ y₂ : α\npy₁ : p y₁\npy₂ : p y₂\n⊢ Eq y₁ y₂","decl":"theorem ExistsUnique.unique {p : α → Prop}\n    (h : ∃! x, p x) {y₁ y₂ : α} (py₁ : p y₁) (py₂ : p y₂) : y₁ = y₂ :=\n  let ⟨_, _, hy⟩ := h; (hy _ py₁).trans (hy _ py₂).symm\n\n-- TODO\n-- attribute [congr] forall_congr'\n-- attribute [congr] exists_congr'\n\n-- @[congr]\n"}
{"name":"existsUnique_congr","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\np q : α → Prop\nh : ∀ (a : α), Iff (p a) (q a)\n⊢ Iff (ExistsUnique fun a => p a) (ExistsUnique fun a => q a)","decl":"theorem existsUnique_congr {p q : α → Prop} (h : ∀ a, p a ↔ q a) : (∃! a, p a) ↔ ∃! a, q a :=\n  exists_congr fun _ ↦ and_congr (h _) <| forall_congr' fun _ ↦ imp_congr_left (h _)\n\n"}
{"name":"existsUnique_iff_exists","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\ninst✝ : Subsingleton α\np : α → Prop\n⊢ Iff (ExistsUnique fun x => p x) (Exists fun x => p x)","decl":"@[simp] theorem existsUnique_iff_exists [Subsingleton α] {p : α → Prop} :\n    (∃! x, p x) ↔ ∃ x, p x :=\n  ⟨fun h ↦ h.exists, Exists.imp fun x hx ↦ ⟨hx, fun y _ ↦ Subsingleton.elim y x⟩⟩\n\n"}
{"name":"exists_unique_iff_exists","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\ninst✝ : Subsingleton α\np : α → Prop\n⊢ Iff (ExistsUnique fun x => p x) (Exists fun x => p x)","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique_iff_exists := existsUnique_iff_exists\n\n"}
{"name":"existsUnique_const","module":"Mathlib.Logic.ExistsUnique","initialProofState":"b : Prop\nα : Sort u_2\ni : Nonempty α\ninst✝ : Subsingleton α\n⊢ Iff (ExistsUnique fun x => b) b","decl":"theorem existsUnique_const {b : Prop} (α : Sort*) [i : Nonempty α] [Subsingleton α] :\n    (∃! _ : α, b) ↔ b := by simp\n\n"}
{"name":"exists_unique_const","module":"Mathlib.Logic.ExistsUnique","initialProofState":"b : Prop\nα : Sort u_2\ni : Nonempty α\ninst✝ : Subsingleton α\n⊢ Iff (ExistsUnique fun x => b) b","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique_const := existsUnique_const\n\n"}
{"name":"existsUnique_eq","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\na' : α\n⊢ ExistsUnique fun a => Eq a a'","decl":"@[simp] theorem existsUnique_eq {a' : α} : ∃! a, a = a' := by\n  simp only [eq_comm, ExistsUnique, and_self, forall_eq', exists_eq']\n\n"}
{"name":"exists_unique_eq","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\na' : α\n⊢ ExistsUnique fun a => Eq a a'","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique_eq := existsUnique_eq\n\n"}
{"name":"existsUnique_eq'","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\na' : α\n⊢ ExistsUnique fun a => Eq a' a","decl":"/-- The difference with `existsUnique_eq` is that the equality is reversed. -/\n@[simp] theorem existsUnique_eq' {a' : α} : ∃! a, a' = a := by\n  simp only [ExistsUnique, and_self, forall_eq', exists_eq']\n\n"}
{"name":"exists_unique_eq'","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\na' : α\n⊢ ExistsUnique fun a => Eq a' a","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique_eq' := existsUnique_eq'\n\n"}
{"name":"existsUnique_prop","module":"Mathlib.Logic.ExistsUnique","initialProofState":"p q : Prop\n⊢ Iff (ExistsUnique fun x => q) (And p q)","decl":"theorem existsUnique_prop {p q : Prop} : (∃! _ : p, q) ↔ p ∧ q := by simp\n\n"}
{"name":"exists_unique_prop","module":"Mathlib.Logic.ExistsUnique","initialProofState":"p q : Prop\n⊢ Iff (ExistsUnique fun x => q) (And p q)","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique_prop := existsUnique_prop\n\n"}
{"name":"existsUnique_false","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\n⊢ Not (ExistsUnique fun x => False)","decl":"@[simp] theorem existsUnique_false : ¬∃! _ : α, False := fun ⟨_, h, _⟩ ↦ h\n\n"}
{"name":"exists_unique_false","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\n⊢ Not (ExistsUnique fun x => False)","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique_false := existsUnique_false\n\n"}
{"name":"existsUnique_prop_of_true","module":"Mathlib.Logic.ExistsUnique","initialProofState":"p : Prop\nq : p → Prop\nh : p\n⊢ Iff (ExistsUnique fun h' => q h') (q h)","decl":"theorem existsUnique_prop_of_true {p : Prop} {q : p → Prop} (h : p) : (∃! h' : p, q h') ↔ q h :=\n  @existsUnique_const (q h) p ⟨h⟩ _\n\n"}
{"name":"exists_unique_prop_of_true","module":"Mathlib.Logic.ExistsUnique","initialProofState":"p : Prop\nq : p → Prop\nh : p\n⊢ Iff (ExistsUnique fun h' => q h') (q h)","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique_prop_of_true := existsUnique_prop_of_true\n\n"}
{"name":"ExistsUnique.elim₂","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\np : α → Sort u_2\ninst✝ : ∀ (x : α), Subsingleton (p x)\nq : (x : α) → p x → Prop\nb : Prop\nh₂ : ExistsUnique fun x => ExistsUnique fun h => q x h\nh₁ : ∀ (x : α) (h : p x), q x h → (∀ (y : α) (hy : p y), q y hy → Eq y x) → b\n⊢ b","decl":"theorem ExistsUnique.elim₂ {p : α → Sort*} [∀ x, Subsingleton (p x)]\n    {q : ∀ (x) (_ : p x), Prop} {b : Prop} (h₂ : ∃! x, ∃! h : p x, q x h)\n    (h₁ : ∀ (x) (h : p x), q x h → (∀ (y) (hy : p y), q y hy → y = x) → b) : b := by\n  simp only [existsUnique_iff_exists] at h₂\n  apply h₂.elim\n  exact fun x ⟨hxp, hxq⟩ H ↦ h₁ x hxp hxq fun y hyp hyq ↦ H y ⟨hyp, hyq⟩\n\n"}
{"name":"ExistsUnique.intro₂","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\np : α → Sort u_2\ninst✝ : ∀ (x : α), Subsingleton (p x)\nq : (x : α) → p x → Prop\nw : α\nhp : p w\nhq : q w hp\nH : ∀ (y : α) (hy : p y), q y hy → Eq y w\n⊢ ExistsUnique fun x => ExistsUnique fun hx => q x hx","decl":"theorem ExistsUnique.intro₂ {p : α → Sort*} [∀ x, Subsingleton (p x)]\n    {q : ∀ (x : α) (_ : p x), Prop} (w : α) (hp : p w) (hq : q w hp)\n    (H : ∀ (y) (hy : p y), q y hy → y = w) : ∃! x, ∃! hx : p x, q x hx := by\n  simp only [existsUnique_iff_exists]\n  exact ExistsUnique.intro w ⟨hp, hq⟩ fun y ⟨hyp, hyq⟩ ↦ H y hyp hyq\n\n"}
{"name":"ExistsUnique.exists₂","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\np : α → Sort u_2\nq : (x : α) → p x → Prop\nh : ExistsUnique fun x => ExistsUnique fun hx => q x hx\n⊢ Exists fun x => Exists fun hx => q x hx","decl":"theorem ExistsUnique.exists₂ {p : α → Sort*} {q : ∀ (x : α) (_ : p x), Prop}\n    (h : ∃! x, ∃! hx : p x, q x hx) : ∃ (x : _) (hx : p x), q x hx :=\n  h.exists.imp fun _ hx ↦ hx.exists\n\n"}
{"name":"ExistsUnique.unique₂","module":"Mathlib.Logic.ExistsUnique","initialProofState":"α : Sort u_1\np : α → Sort u_2\ninst✝ : ∀ (x : α), Subsingleton (p x)\nq : (x : α) → p x → Prop\nh : ExistsUnique fun x => ExistsUnique fun hx => q x hx\ny₁ y₂ : α\nhpy₁ : p y₁\nhqy₁ : q y₁ hpy₁\nhpy₂ : p y₂\nhqy₂ : q y₂ hpy₂\n⊢ Eq y₁ y₂","decl":"theorem ExistsUnique.unique₂ {p : α → Sort*} [∀ x, Subsingleton (p x)]\n    {q : ∀ (x : α) (_ : p x), Prop} (h : ∃! x, ∃! hx : p x, q x hx) {y₁ y₂ : α}\n    (hpy₁ : p y₁) (hqy₁ : q y₁ hpy₁) (hpy₂ : p y₂) (hqy₂ : q y₂ hpy₂) : y₁ = y₂ := by\n  simp only [existsUnique_iff_exists] at h\n  exact h.unique ⟨hpy₁, hqy₁⟩ ⟨hpy₂, hqy₂⟩\n"}
