{"name":"OrderHom.monotone'","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nself : OrderHom α β\n⊢ Monotone self.toFun","decl":"/-- Bundled monotone (aka, increasing) function -/\nstructure OrderHom (α β : Type*) [Preorder α] [Preorder β] where\n  /-- The underlying function of an `OrderHom`. -/\n  toFun : α → β\n  /-- The underlying function of an `OrderHom` is monotone. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderHom.mk.sizeOf_spec","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoFun : α → β\nmonotone' : Monotone toFun\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, monotone' := monotone' }) 1","decl":"/-- Bundled monotone (aka, increasing) function -/\nstructure OrderHom (α β : Type*) [Preorder α] [Preorder β] where\n  /-- The underlying function of an `OrderHom`. -/\n  toFun : α → β\n  /-- The underlying function of an `OrderHom` is monotone. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderHom.mk.inj","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ntoFun✝ : α → β\nmonotone'✝ : Monotone toFun✝\ntoFun : α → β\nmonotone' : Monotone toFun\nx✝ : Eq { toFun := toFun✝, monotone' := monotone'✝ } { toFun := toFun, monotone' := monotone' }\n⊢ Eq toFun✝ toFun","decl":"/-- Bundled monotone (aka, increasing) function -/\nstructure OrderHom (α β : Type*) [Preorder α] [Preorder β] where\n  /-- The underlying function of an `OrderHom`. -/\n  toFun : α → β\n  /-- The underlying function of an `OrderHom` is monotone. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderHom.mk.injEq","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ntoFun✝ : α → β\nmonotone'✝ : Monotone toFun✝\ntoFun : α → β\nmonotone' : Monotone toFun\n⊢ Eq (Eq { toFun := toFun✝, monotone' := monotone'✝ } { toFun := toFun, monotone' := monotone' }) (Eq toFun✝ toFun)","decl":"/-- Bundled monotone (aka, increasing) function -/\nstructure OrderHom (α β : Type*) [Preorder α] [Preorder β] where\n  /-- The underlying function of an `OrderHom`. -/\n  toFun : α → β\n  /-- The underlying function of an `OrderHom` is monotone. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderIsoClass.map_le_map_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\nβ : outParam (Type u_8)\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : EquivLike F α β\nself : OrderIsoClass F α β\nf : F\na b : α\n⊢ Iff (LE.le (f a) (f b)) (LE.le a b)","decl":"/-- `OrderIsoClass F α β` states that `F` is a type of order isomorphisms.\n\nYou should extend this class when you extend `OrderIso`. -/\nclass OrderIsoClass (F : Type*) (α β : outParam Type*) [LE α] [LE β] [EquivLike F α β] :\n    Prop where\n  /-- An order isomorphism respects `≤`. -/\n  map_le_map_iff (f : F) {a b : α} : f a ≤ f b ↔ a ≤ b\n\n"}
{"name":"OrderIsoClass.toOrderHomClass","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : LE α\ninst✝² : LE β\ninst✝¹ : EquivLike F α β\ninst✝ : OrderIsoClass F α β\n⊢ OrderHomClass F α β","decl":"instance (priority := 100) OrderIsoClass.toOrderHomClass [LE α] [LE β]\n    [EquivLike F α β] [OrderIsoClass F α β] : OrderHomClass F α β :=\n  { EquivLike.toEmbeddingLike (E := F) with\n    map_rel := fun f _ _ => (map_le_map_iff f).2 }\n\n"}
{"name":"OrderHomClass.monotone","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : FunLike F α β\ninst✝ : OrderHomClass F α β\nf : F\n⊢ Monotone ⇑f","decl":"protected theorem monotone (f : F) : Monotone f := fun _ _ => map_rel f\n\n"}
{"name":"OrderHomClass.mono","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : FunLike F α β\ninst✝ : OrderHomClass F α β\nf : F\n⊢ Monotone ⇑f","decl":"protected theorem mono (f : F) : Monotone f := fun _ _ => map_rel f\n\n"}
{"name":"OrderHomClass.GCongr.mono","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : FunLike F α β\ninst✝ : OrderHomClass F α β\nf : F\na b : α\nhab : LE.le a b\n⊢ LE.le (f a) (f b)","decl":"@[gcongr] protected lemma GCongr.mono (f : F) {a b : α} (hab : a ≤ b) : f a ≤ f b :=\n  OrderHomClass.mono f hab\n\n"}
{"name":"map_inv_le_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : LE α\ninst✝² : LE β\ninst✝¹ : EquivLike F α β\ninst✝ : OrderIsoClass F α β\nf : F\na : α\nb : β\n⊢ Iff (LE.le (EquivLike.inv f b) a) (LE.le b (f a))","decl":"@[simp]\ntheorem map_inv_le_iff (f : F) {a : α} {b : β} : EquivLike.inv f b ≤ a ↔ b ≤ f a := by\n  convert (map_le_map_iff f (a := EquivLike.inv f b) (b := a)).symm\n  exact (EquivLike.right_inv f _).symm\n\n"}
{"name":"map_inv_le_map_inv_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : LE α\ninst✝² : LE β\ninst✝¹ : EquivLike F α β\ninst✝ : OrderIsoClass F α β\nf : F\na b : β\n⊢ Iff (LE.le (EquivLike.inv f b) (EquivLike.inv f a)) (LE.le b a)","decl":"theorem map_inv_le_map_inv_iff (f : F) {a b : β} :\n    EquivLike.inv f b ≤ EquivLike.inv f a ↔ b ≤ a := by\n  simp\n\n-- Porting note: needed to add explicit arguments to map_le_map_iff\n"}
{"name":"le_map_inv_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : LE α\ninst✝² : LE β\ninst✝¹ : EquivLike F α β\ninst✝ : OrderIsoClass F α β\nf : F\na : α\nb : β\n⊢ Iff (LE.le a (EquivLike.inv f b)) (LE.le (f a) b)","decl":"@[simp]\ntheorem le_map_inv_iff (f : F) {a : α} {b : β} : a ≤ EquivLike.inv f b ↔ f a ≤ b := by\n  convert (map_le_map_iff f (a := a) (b := EquivLike.inv f b)).symm\n  exact (EquivLike.right_inv _ _).symm\n\n"}
{"name":"map_lt_map_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : EquivLike F α β\ninst✝ : OrderIsoClass F α β\nf : F\na b : α\n⊢ Iff (LT.lt (f a) (f b)) (LT.lt a b)","decl":"theorem map_lt_map_iff (f : F) {a b : α} : f a < f b ↔ a < b :=\n  lt_iff_lt_of_le_iff_le' (map_le_map_iff f) (map_le_map_iff f)\n\n"}
{"name":"map_inv_lt_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : EquivLike F α β\ninst✝ : OrderIsoClass F α β\nf : F\na : α\nb : β\n⊢ Iff (LT.lt (EquivLike.inv f b) a) (LT.lt b (f a))","decl":"@[simp]\ntheorem map_inv_lt_iff (f : F) {a : α} {b : β} : EquivLike.inv f b < a ↔ b < f a := by\n  rw [← map_lt_map_iff f]\n  simp only [EquivLike.apply_inv_apply]\n\n"}
{"name":"map_inv_lt_map_inv_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : EquivLike F α β\ninst✝ : OrderIsoClass F α β\nf : F\na b : β\n⊢ Iff (LT.lt (EquivLike.inv f b) (EquivLike.inv f a)) (LT.lt b a)","decl":"theorem map_inv_lt_map_inv_iff (f : F) {a b : β} :\n    EquivLike.inv f b < EquivLike.inv f a ↔ b < a := by\n  simp\n\n"}
{"name":"lt_map_inv_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : EquivLike F α β\ninst✝ : OrderIsoClass F α β\nf : F\na : α\nb : β\n⊢ Iff (LT.lt a (EquivLike.inv f b)) (LT.lt (f a) b)","decl":"@[simp]\ntheorem lt_map_inv_iff (f : F) {a : α} {b : β} : a < EquivLike.inv f b ↔ f a < b := by\n  rw [← map_lt_map_iff f]\n  simp only [EquivLike.apply_inv_apply]\n\n"}
{"name":"OrderHom.instOrderHomClass","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ OrderHomClass (OrderHom α β) α β","decl":"instance : OrderHomClass (α →o β) α β where\n  map_rel f _ _ h := f.monotone' h\n\n"}
{"name":"OrderHom.coe_mk","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : Monotone f\n⊢ Eq (⇑{ toFun := f, monotone' := hf }) f","decl":"@[simp] theorem coe_mk (f : α → β) (hf : Monotone f) : ⇑(mk f hf) = f := rfl\n\n"}
{"name":"OrderHom.monotone","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\n⊢ Monotone ⇑f","decl":"protected theorem monotone (f : α →o β) : Monotone f :=\n  f.monotone'\n\n"}
{"name":"OrderHom.mono","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\n⊢ Monotone ⇑f","decl":"protected theorem mono (f : α →o β) : Monotone f :=\n  f.monotone\n\n"}
{"name":"OrderHom.toFun_eq_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\n⊢ Eq f.toFun ⇑f","decl":"@[simp] theorem toFun_eq_coe (f : α →o β) : f.toFun = f := rfl\n\n-- See library note [partially-applied ext lemmas]\n"}
{"name":"OrderHom.ext","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf g : OrderHom α β\nh : Eq ⇑f ⇑g\n⊢ Eq f g","decl":"@[ext]\ntheorem ext (f g : α →o β) (h : (f : α → β) = g) : f = g :=\n  DFunLike.coe_injective h\n\n"}
{"name":"OrderHom.ext_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf g : OrderHom α β\n⊢ Iff (Eq f g) (Eq ⇑f ⇑g)","decl":"@[ext]\ntheorem ext (f g : α →o β) (h : (f : α → β) = g) : f = g :=\n  DFunLike.coe_injective h\n\n"}
{"name":"OrderHom.coe_eq","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\n⊢ Eq (↑f) f","decl":"@[simp] theorem coe_eq (f : α →o β) : OrderHomClass.toOrderHom f = f := rfl\n\n"}
{"name":"OrderHomClass.coe_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\nF : Type u_6\ninst✝¹ : FunLike F α β\ninst✝ : OrderHomClass F α β\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp] theorem _root_.OrderHomClass.coe_coe {F} [FunLike F α β] [OrderHomClass F α β] (f : F) :\n    ⇑(f : α →o β) = f :=\n  rfl\n\n"}
{"name":"OrderHom.canLift","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ CanLift (α → β) (OrderHom α β) DFunLike.coe Monotone","decl":"/-- One can lift an unbundled monotone function to a bundled one. -/\nprotected instance canLift : CanLift (α → β) (α →o β) (↑) Monotone where\n  prf f h := ⟨⟨f, h⟩, rfl⟩\n\n"}
{"name":"OrderHom.coe_copy","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : α →o β) (f' : α → β) (h : f' = f) : (f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"OrderHom.copy_eq","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : α →o β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"OrderHom.id_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\n⊢ Eq (⇑OrderHom.id) id","decl":"/-- The identity function as bundled monotone function. -/\n@[simps (config := .asFn)]\ndef id : α →o α :=\n  ⟨_root_.id, monotone_id⟩\n\n"}
{"name":"OrderHom.le_def","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf g : OrderHom α β\n⊢ Iff (LE.le f g) (∀ (x : α), LE.le (f x) (g x))","decl":"theorem le_def {f g : α →o β} : f ≤ g ↔ ∀ x, f x ≤ g x :=\n  Iff.rfl\n\n"}
{"name":"OrderHom.coe_le_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf g : OrderHom α β\n⊢ Iff (LE.le ⇑f ⇑g) (LE.le f g)","decl":"@[simp, norm_cast]\ntheorem coe_le_coe {f g : α →o β} : (f : α → β) ≤ g ↔ f ≤ g :=\n  Iff.rfl\n\n"}
{"name":"OrderHom.mk_le_mk","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf g : α → β\nhf : Monotone f\nhg : Monotone g\n⊢ Iff (LE.le { toFun := f, monotone' := hf } { toFun := g, monotone' := hg }) (LE.le f g)","decl":"@[simp]\ntheorem mk_le_mk {f g : α → β} {hf hg} : mk f hf ≤ mk g hg ↔ f ≤ g :=\n  Iff.rfl\n\n"}
{"name":"OrderHom.apply_mono","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf g : OrderHom α β\nx y : α\nh₁ : LE.le f g\nh₂ : LE.le x y\n⊢ LE.le (f x) (g y)","decl":"@[mono]\ntheorem apply_mono {f g : α →o β} {x y : α} (h₁ : f ≤ g) (h₂ : x ≤ y) : f x ≤ g y :=\n  (h₁ x).trans <| g.mono h₂\n\n"}
{"name":"OrderHom.curry_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : OrderHom (Prod α β) γ\nx : α\ny : β\n⊢ Eq (((OrderHom.curry f) x) y) (f { fst := x, snd := y })","decl":"@[simp]\ntheorem curry_apply (f : α × β →o γ) (x : α) (y : β) : curry f x y = f (x, y) :=\n  rfl\n\n"}
{"name":"OrderHom.curry_symm_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : OrderHom α (OrderHom β γ)\nx : Prod α β\n⊢ Eq (((RelIso.symm OrderHom.curry) f) x) ((f x.1) x.2)","decl":"@[simp]\ntheorem curry_symm_apply (f : α →o β →o γ) (x : α × β) : curry.symm f x = f x.1 x.2 :=\n  rfl\n\n"}
{"name":"OrderHom.comp_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : OrderHom β γ\nf : OrderHom α β\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"/-- The composition of two bundled monotone functions. -/\n@[simps (config := .asFn)]\ndef comp (g : β →o γ) (f : α →o β) : α →o γ :=\n  ⟨g ∘ f, g.mono.comp f.mono⟩\n\n"}
{"name":"OrderHom.comp_mono","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng₁ g₂ : OrderHom β γ\nhg : LE.le g₁ g₂\nf₁ f₂ : OrderHom α β\nhf : LE.le f₁ f₂\n⊢ LE.le (g₁.comp f₁) (g₂.comp f₂)","decl":"@[mono]\ntheorem comp_mono ⦃g₁ g₂ : β →o γ⦄ (hg : g₁ ≤ g₂) ⦃f₁ f₂ : α →o β⦄ (hf : f₁ ≤ f₂) :\n    g₁.comp f₁ ≤ g₂.comp f₂ := fun _ => (hg _).trans (g₂.mono <| hf _)\n\n"}
{"name":"OrderHom.mk_comp_mk","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\nhg : Monotone g\nhf : Monotone f\n⊢ Eq ({ toFun := g, monotone' := hg }.comp { toFun := f, monotone' := hf }) { toFun := Function.comp g f, monotone' := ⋯ }","decl":"@[simp] lemma mk_comp_mk (g : β → γ) (f : α → β) (hg hf) :\n    comp ⟨g, hg⟩ ⟨f, hf⟩ = ⟨g ∘ f, hg.comp hf⟩ := rfl\n\n"}
{"name":"OrderHom.compₘ_coe_coe_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nx : OrderHom β γ\na✝ : OrderHom α β\n⊢ Eq (⇑((OrderHom.compₘ x) a✝)) (Function.comp ⇑x ⇑a✝)","decl":"/-- The composition of two bundled monotone functions, a fully bundled version. -/\n@[simps! (config := .asFn)]\ndef compₘ : (β →o γ) →o (α →o β) →o α →o γ :=\n  curry ⟨fun f : (β →o γ) × (α →o β) => f.1.comp f.2, fun _ _ h => comp_mono h.1 h.2⟩\n\n"}
{"name":"OrderHom.comp_id","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\n⊢ Eq (f.comp OrderHom.id) f","decl":"@[simp]\ntheorem comp_id (f : α →o β) : comp f id = f := by\n  ext\n  rfl\n\n"}
{"name":"OrderHom.id_comp","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\n⊢ Eq (OrderHom.id.comp f) f","decl":"@[simp]\ntheorem id_comp (f : α →o β) : comp id f = f := by\n  ext\n  rfl\n\n"}
{"name":"OrderHom.const_coe_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\ninst✝¹ : Preorder α\nβ : Type u_7\ninst✝ : Preorder β\nb : β\n⊢ Eq (⇑((OrderHom.const α) b)) (Function.const α b)","decl":"/-- Constant function bundled as an `OrderHom`. -/\n@[simps (config := .asFn)]\ndef const (α : Type*) [Preorder α] {β : Type*} [Preorder β] : β →o α →o β where\n  toFun b := ⟨Function.const α b, fun _ _ _ => le_rfl⟩\n  monotone' _ _ h _ := h\n\n"}
{"name":"OrderHom.const_comp","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : OrderHom α β\nc : γ\n⊢ Eq (((OrderHom.const β) c).comp f) ((OrderHom.const α) c)","decl":"@[simp]\ntheorem const_comp (f : α →o β) (c : γ) : (const β c).comp f = const α c :=\n  rfl\n\n"}
{"name":"OrderHom.comp_const","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nγ : Type u_6\ninst✝ : Preorder γ\nf : OrderHom α β\nc : α\n⊢ Eq (f.comp ((OrderHom.const γ) c)) ((OrderHom.const γ) (f c))","decl":"@[simp]\ntheorem comp_const (γ : Type*) [Preorder γ] (f : α →o β) (c : α) :\n    f.comp (const γ c) = const γ (f c) :=\n  rfl\n\n"}
{"name":"OrderHom.prod_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : OrderHom α β\ng : OrderHom α γ\nx : α\n⊢ Eq ((f.prod g) x) { fst := f x, snd := g x }","decl":"/-- Given two bundled monotone maps `f`, `g`, `f.prod g` is the map `x ↦ (f x, g x)` bundled as a\n`OrderHom`. -/\n@[simps]\nprotected def prod (f : α →o β) (g : α →o γ) : α →o β × γ :=\n  ⟨fun x => (f x, g x), fun _ _ h => ⟨f.mono h, g.mono h⟩⟩\n\n"}
{"name":"OrderHom.prod_mono","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf₁ f₂ : OrderHom α β\nhf : LE.le f₁ f₂\ng₁ g₂ : OrderHom α γ\nhg : LE.le g₁ g₂\n⊢ LE.le (f₁.prod g₁) (f₂.prod g₂)","decl":"@[mono]\ntheorem prod_mono {f₁ f₂ : α →o β} (hf : f₁ ≤ f₂) {g₁ g₂ : α →o γ} (hg : g₁ ≤ g₂) :\n    f₁.prod g₁ ≤ f₂.prod g₂ := fun _ => Prod.le_def.2 ⟨hf _, hg _⟩\n\n"}
{"name":"OrderHom.comp_prod_comp_same","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf₁ f₂ : OrderHom β γ\ng : OrderHom α β\n⊢ Eq ((f₁.comp g).prod (f₂.comp g)) ((f₁.prod f₂).comp g)","decl":"theorem comp_prod_comp_same (f₁ f₂ : β →o γ) (g : α →o β) :\n    (f₁.comp g).prod (f₂.comp g) = (f₁.prod f₂).comp g :=\n  rfl\n\n"}
{"name":"OrderHom.prodₘ_coe_coe_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nx✝ : OrderHom α β\na✝ : OrderHom α γ\nx : α\n⊢ Eq (((OrderHom.prodₘ x✝) a✝) x) { fst := x✝ x, snd := a✝ x }","decl":"/-- Given two bundled monotone maps `f`, `g`, `f.prod g` is the map `x ↦ (f x, g x)` bundled as a\n`OrderHom`. This is a fully bundled version. -/\n@[simps!]\ndef prodₘ : (α →o β) →o (α →o γ) →o α →o β × γ :=\n  curry ⟨fun f : (α →o β) × (α →o γ) => f.1.prod f.2, fun _ _ h => prod_mono h.1 h.2⟩\n\n"}
{"name":"OrderHom.diag_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\nx : α\n⊢ Eq (OrderHom.diag x) { fst := x, snd := x }","decl":"/-- Diagonal embedding of `α` into `α × α` as an `OrderHom`. -/\n@[simps!]\ndef diag : α →o α × α :=\n  id.prod id\n\n"}
{"name":"OrderHom.onDiag_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α (OrderHom α β)\na✝ : α\n⊢ Eq (f.onDiag a✝) ((f a✝) a✝)","decl":"/-- Restriction of `f : α →o α →o β` to the diagonal. -/\n@[simps! (config := { simpRhs := true })]\ndef onDiag (f : α →o α →o β) : α →o β :=\n  (curry.symm f).comp diag\n\n"}
{"name":"OrderHom.fst_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nself : Prod α β\n⊢ Eq (OrderHom.fst self) self.1","decl":"/-- `Prod.fst` as an `OrderHom`. -/\n@[simps]\ndef fst : α × β →o α :=\n  ⟨Prod.fst, fun _ _ h => h.1⟩\n\n"}
{"name":"OrderHom.snd_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nself : Prod α β\n⊢ Eq (OrderHom.snd self) self.2","decl":"/-- `Prod.snd` as an `OrderHom`. -/\n@[simps]\ndef snd : α × β →o β :=\n  ⟨Prod.snd, fun _ _ h => h.2⟩\n\n"}
{"name":"OrderHom.fst_prod_snd","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ Eq (OrderHom.fst.prod OrderHom.snd) OrderHom.id","decl":"@[simp]\ntheorem fst_prod_snd : (fst : α × β →o α).prod snd = id := by\n  ext ⟨x, y⟩ : 2\n  rfl\n\n"}
{"name":"OrderHom.fst_comp_prod","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : OrderHom α β\ng : OrderHom α γ\n⊢ Eq (OrderHom.fst.comp (f.prod g)) f","decl":"@[simp]\ntheorem fst_comp_prod (f : α →o β) (g : α →o γ) : fst.comp (f.prod g) = f :=\n  ext _ _ rfl\n\n"}
{"name":"OrderHom.snd_comp_prod","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : OrderHom α β\ng : OrderHom α γ\n⊢ Eq (OrderHom.snd.comp (f.prod g)) g","decl":"@[simp]\ntheorem snd_comp_prod (f : α →o β) (g : α →o γ) : snd.comp (f.prod g) = g :=\n  ext _ _ rfl\n\n"}
{"name":"OrderHom.prodIso_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : OrderHom α (Prod β γ)\n⊢ Eq (OrderHom.prodIso f) { fst := OrderHom.fst.comp f, snd := OrderHom.snd.comp f }","decl":"/-- Order isomorphism between the space of monotone maps to `β × γ` and the product of the spaces\nof monotone maps to `β` and `γ`. -/\n@[simps]\ndef prodIso : (α →o β × γ) ≃o (α →o β) × (α →o γ) where\n  toFun f := (fst.comp f, snd.comp f)\n  invFun f := f.1.prod f.2\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := forall_and.symm\n\n"}
{"name":"OrderHom.prodIso_symm_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : Prod (OrderHom α β) (OrderHom α γ)\n⊢ Eq ((RelIso.symm OrderHom.prodIso) f) (f.1.prod f.2)","decl":"/-- Order isomorphism between the space of monotone maps to `β × γ` and the product of the spaces\nof monotone maps to `β` and `γ`. -/\n@[simps]\ndef prodIso : (α →o β × γ) ≃o (α →o β) × (α →o γ) where\n  toFun f := (fst.comp f, snd.comp f)\n  invFun f := f.1.prod f.2\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := forall_and.symm\n\n"}
{"name":"OrderHom.prodMap_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Preorder γ\ninst✝ : Preorder δ\nf : OrderHom α β\ng : OrderHom γ δ\na✝ : Prod α γ\n⊢ Eq ((f.prodMap g) a✝) (Prod.map (⇑f) (⇑g) a✝)","decl":"/-- `Prod.map` of two `OrderHom`s as an `OrderHom`. -/\n@[simps]\ndef prodMap (f : α →o β) (g : γ →o δ) : α × γ →o β × δ :=\n  ⟨Prod.map f g, fun _ _ h => ⟨f.mono h.1, g.mono h.2⟩⟩\n\n"}
{"name":"Pi.evalOrderHom_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"ι : Type u_6\nπ : ι → Type u_7\ninst✝ : (i : ι) → Preorder (π i)\ni : ι\n⊢ Eq (⇑(Pi.evalOrderHom i)) (Function.eval i)","decl":"/-- Evaluation of an unbundled function at a point (`Function.eval`) as an `OrderHom`. -/\n@[simps (config := .asFn)]\ndef _root_.Pi.evalOrderHom (i : ι) : (∀ j, π j) →o π i :=\n  ⟨Function.eval i, Function.monotone_eval i⟩\n\n"}
{"name":"OrderHom.coeFnHom_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\n⊢ Eq ⇑OrderHom.coeFnHom fun f => ⇑f","decl":"/-- The \"forgetful functor\" from `α →o β` to `α → β` that takes the underlying function,\nis monotone. -/\n@[simps (config := .asFn)]\ndef coeFnHom : (α →o β) →o α → β where\n  toFun f := f\n  monotone' _ _ h := h\n\n"}
{"name":"OrderHom.apply_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx : α\n⊢ Eq (⇑(OrderHom.apply x)) (Function.comp (Function.eval x) fun f => ⇑f)","decl":"/-- Function application `fun f => f a` (for fixed `a`) is a monotone function from the\nmonotone function space `α →o β` to `β`. See also `Pi.evalOrderHom`. -/\n@[simps! (config := .asFn)]\ndef apply (x : α) : (α →o β) →o β :=\n  (Pi.evalOrderHom x).comp coeFnHom\n\n"}
{"name":"OrderHom.pi_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\nι : Type u_6\nπ : ι → Type u_7\ninst✝ : (i : ι) → Preorder (π i)\nf : (i : ι) → OrderHom α (π i)\nx : α\ni : ι\n⊢ Eq ((OrderHom.pi f) x i) ((f i) x)","decl":"/-- Construct a bundled monotone map `α →o Π i, π i` from a family of monotone maps\n`f i : α →o π i`. -/\n@[simps]\ndef pi (f : ∀ i, α →o π i) : α →o ∀ i, π i :=\n  ⟨fun x i => f i x, fun _ _ h i => (f i).mono h⟩\n\n"}
{"name":"OrderHom.piIso_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\nι : Type u_6\nπ : ι → Type u_7\ninst✝ : (i : ι) → Preorder (π i)\nf : OrderHom α ((i : ι) → π i)\ni : ι\n⊢ Eq (OrderHom.piIso f i) ((Pi.evalOrderHom i).comp f)","decl":"/-- Order isomorphism between bundled monotone maps `α →o Π i, π i` and families of bundled monotone\nmaps `Π i, α →o π i`. -/\n@[simps]\ndef piIso : (α →o ∀ i, π i) ≃o ∀ i, α →o π i where\n  toFun f i := (Pi.evalOrderHom i).comp f\n  invFun := pi\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := forall_swap\n\n"}
{"name":"OrderHom.piIso_symm_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\nι : Type u_6\nπ : ι → Type u_7\ninst✝ : (i : ι) → Preorder (π i)\nf : (i : ι) → OrderHom α (π i)\n⊢ Eq ((RelIso.symm OrderHom.piIso) f) (OrderHom.pi f)","decl":"/-- Order isomorphism between bundled monotone maps `α →o Π i, π i` and families of bundled monotone\nmaps `Π i, α →o π i`. -/\n@[simps]\ndef piIso : (α →o ∀ i, π i) ≃o ∀ i, α →o π i where\n  toFun f i := (Pi.evalOrderHom i).comp f\n  invFun := pi\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := forall_swap\n\n"}
{"name":"OrderHom.Subtype.val_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\np : α → Prop\n⊢ Eq (⇑(OrderHom.Subtype.val p)) Subtype.val","decl":"/-- `Subtype.val` as a bundled monotone function. -/\n@[simps (config := .asFn)]\ndef Subtype.val (p : α → Prop) : Subtype p →o α :=\n  ⟨_root_.Subtype.val, fun _ _ h => h⟩\n\n"}
{"name":"Subtype.orderEmbedding_apply_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\np q : α → Prop\nh : ∀ (a : α), p a → q a\nx : Subtype fun x => p x\n⊢ Eq ↑((Subtype.orderEmbedding h) x) ↑x","decl":"/-- `Subtype.impEmbedding` as an order embedding. -/\n@[simps!]\ndef _root_.Subtype.orderEmbedding {p q : α → Prop} (h : ∀ a, p a → q a) :\n    {x // p x} ↪o {x // q x} :=\n  { Subtype.impEmbedding _ _ h with\n    map_rel_iff' := by aesop }\n\n"}
{"name":"OrderHom.orderHom_eq_id","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Subsingleton α\ng : OrderHom α α\n⊢ Eq g OrderHom.id","decl":"theorem orderHom_eq_id [Subsingleton α] (g : α →o α) : g = OrderHom.id :=\n  Subsingleton.elim _ _\n\n"}
{"name":"OrderHom.dual_symm_apply_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom (OrderDual α) (OrderDual β)\na✝ : α\n⊢ Eq ((OrderHom.dual.symm f) a✝) (Function.comp (⇑OrderDual.ofDual) (Function.comp ⇑f ⇑OrderDual.toDual) a✝)","decl":"/-- Reinterpret a bundled monotone function as a monotone function between dual orders. -/\n@[simps]\nprotected def dual : (α →o β) ≃ (αᵒᵈ →o βᵒᵈ) where\n  toFun f := ⟨(OrderDual.toDual : β → βᵒᵈ) ∘ (f : α → β) ∘\n    (OrderDual.ofDual : αᵒᵈ → α), f.mono.dual⟩\n  invFun f := ⟨OrderDual.ofDual ∘ f ∘ OrderDual.toDual, f.mono.dual⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"OrderHom.dual_apply_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\na✝ : OrderDual α\n⊢ Eq ((OrderHom.dual f) a✝) (Function.comp (⇑OrderDual.toDual) (Function.comp ⇑f ⇑OrderDual.ofDual) a✝)","decl":"/-- Reinterpret a bundled monotone function as a monotone function between dual orders. -/\n@[simps]\nprotected def dual : (α →o β) ≃ (αᵒᵈ →o βᵒᵈ) where\n  toFun f := ⟨(OrderDual.toDual : β → βᵒᵈ) ∘ (f : α → β) ∘\n    (OrderDual.ofDual : αᵒᵈ → α), f.mono.dual⟩\n  invFun f := ⟨OrderDual.ofDual ∘ f ∘ OrderDual.toDual, f.mono.dual⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"OrderHom.dual_id","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\n⊢ Eq (OrderHom.dual OrderHom.id) OrderHom.id","decl":"@[simp]\ntheorem dual_id : (OrderHom.id : α →o α).dual = OrderHom.id :=\n  rfl\n\n"}
{"name":"OrderHom.dual_comp","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : OrderHom β γ\nf : OrderHom α β\n⊢ Eq (OrderHom.dual (g.comp f)) ((OrderHom.dual g).comp (OrderHom.dual f))","decl":"@[simp]\ntheorem dual_comp (g : β →o γ) (f : α →o β) :\n    (g.comp f).dual = g.dual.comp f.dual :=\n  rfl\n\n"}
{"name":"OrderHom.symm_dual_id","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\n⊢ Eq (OrderHom.dual.symm OrderHom.id) OrderHom.id","decl":"@[simp]\ntheorem symm_dual_id : OrderHom.dual.symm OrderHom.id = (OrderHom.id : α →o α) :=\n  rfl\n\n"}
{"name":"OrderHom.symm_dual_comp","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : OrderHom (OrderDual β) (OrderDual γ)\nf : OrderHom (OrderDual α) (OrderDual β)\n⊢ Eq (OrderHom.dual.symm (g.comp f)) ((OrderHom.dual.symm g).comp (OrderHom.dual.symm f))","decl":"@[simp]\ntheorem symm_dual_comp (g : βᵒᵈ →o γᵒᵈ) (f : αᵒᵈ →o βᵒᵈ) :\n    OrderHom.dual.symm (g.comp f) = (OrderHom.dual.symm g).comp (OrderHom.dual.symm f) :=\n  rfl\n\n"}
{"name":"OrderHom.withBotMap_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\n⊢ Eq (⇑f.withBotMap) (WithBot.map ⇑f)","decl":"/-- Lift an order homomorphism `f : α →o β` to an order homomorphism `WithBot α →o WithBot β`. -/\n@[simps (config := .asFn)]\nprotected def withBotMap (f : α →o β) : WithBot α →o WithBot β :=\n  ⟨WithBot.map f, f.mono.withBot_map⟩\n\n"}
{"name":"OrderHom.withTopMap_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\n⊢ Eq (⇑f.withTopMap) (WithTop.map ⇑f)","decl":"/-- Lift an order homomorphism `f : α →o β` to an order homomorphism `WithTop α →o WithTop β`. -/\n@[simps (config := .asFn)]\nprotected def withTopMap (f : α →o β) : WithTop α →o WithTop β :=\n  ⟨WithTop.map f, f.mono.withTop_map⟩\n\n"}
{"name":"OrderHom.uliftMap_coe_down","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderHom α β\ni : ULift.{u_8, u_2} α\n⊢ Eq (f.uliftMap i).down (f i.down)","decl":"/-- Lift an order homomorphism `f : α →o β` to an order homomorphism `ULift α →o ULift β` in a\nhigher universe. -/\n@[simps!]\ndef uliftMap (f : α →o β) : ULift α →o ULift β :=\n  ⟨fun i => ⟨f i.down⟩, fun _ _ h ↦ f.monotone h⟩\n\n"}
{"name":"OrderHomClass.toOrderHomClassOrderDual","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : LE α\ninst✝² : LE β\ninst✝¹ : FunLike F α β\ninst✝ : OrderHomClass F α β\n⊢ OrderHomClass F (OrderDual α) (OrderDual β)","decl":"instance (priority := 90) OrderHomClass.toOrderHomClassOrderDual [LE α] [LE β]\n    [FunLike F α β] [OrderHomClass F α β] : OrderHomClass F αᵒᵈ βᵒᵈ where\n  map_rel f := map_rel f\n\n"}
{"name":"RelEmbedding.orderEmbeddingOfLTEmbedding_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nf : RelEmbedding (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\nx : α\n⊢ Eq (f.orderEmbeddingOfLTEmbedding x) (f x)","decl":"@[simp]\ntheorem RelEmbedding.orderEmbeddingOfLTEmbedding_apply [PartialOrder α] [PartialOrder β]\n    {f : ((· < ·) : α → α → Prop) ↪r ((· < ·) : β → β → Prop)} {x : α} :\n    RelEmbedding.orderEmbeddingOfLTEmbedding f x = f x :=\n  rfl\n\n"}
{"name":"OrderEmbedding.ltEmbedding_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderEmbedding α β\nx : α\n⊢ Eq (f.ltEmbedding x) (f x)","decl":"@[simp]\ntheorem ltEmbedding_apply (x : α) : f.ltEmbedding x = f x :=\n  rfl\n\n"}
{"name":"OrderEmbedding.le_iff_le","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderEmbedding α β\na b : α\n⊢ Iff (LE.le (f a) (f b)) (LE.le a b)","decl":"@[simp]\ntheorem le_iff_le {a b} : f a ≤ f b ↔ a ≤ b :=\n  f.map_rel_iff\n\n"}
{"name":"OrderEmbedding.lt_iff_lt","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderEmbedding α β\na b : α\n⊢ Iff (LT.lt (f a) (f b)) (LT.lt a b)","decl":"@[simp]\ntheorem lt_iff_lt {a b} : f a < f b ↔ a < b :=\n  f.ltEmbedding.map_rel_iff\n\n"}
{"name":"OrderEmbedding.eq_iff_eq","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderEmbedding α β\na b : α\n⊢ Iff (Eq (f a) (f b)) (Eq a b)","decl":"theorem eq_iff_eq {a b} : f a = f b ↔ a = b :=\n  f.injective.eq_iff\n\n"}
{"name":"OrderEmbedding.monotone","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderEmbedding α β\n⊢ Monotone ⇑f","decl":"protected theorem monotone : Monotone f :=\n  OrderHomClass.monotone f\n\n"}
{"name":"OrderEmbedding.strictMono","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderEmbedding α β\n⊢ StrictMono ⇑f","decl":"protected theorem strictMono : StrictMono f := fun _ _ => f.lt_iff_lt.2\n\n"}
{"name":"OrderEmbedding.acc","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderEmbedding α β\na : α\na✝ : Acc (fun x1 x2 => LT.lt x1 x2) (f a)\n⊢ Acc (fun x1 x2 => LT.lt x1 x2) a","decl":"protected theorem acc (a : α) : Acc (· < ·) (f a) → Acc (· < ·) a :=\n  f.ltEmbedding.acc a\n\n"}
{"name":"OrderEmbedding.wellFounded","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderEmbedding α β\na✝ : WellFounded fun x1 x2 => LT.lt x1 x2\n⊢ WellFounded fun x1 x2 => LT.lt x1 x2","decl":"protected theorem wellFounded (f : α ↪o β) :\n    WellFounded ((· < ·) : β → β → Prop) → WellFounded ((· < ·) : α → α → Prop) :=\n  f.ltEmbedding.wellFounded\n\n"}
{"name":"OrderEmbedding.isWellOrder","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : IsWellOrder β fun x1 x2 => LT.lt x1 x2\nf : OrderEmbedding α β\n⊢ IsWellOrder α fun x1 x2 => LT.lt x1 x2","decl":"protected theorem isWellOrder [IsWellOrder β (· < ·)] (f : α ↪o β) : IsWellOrder α (· < ·) :=\n  f.ltEmbedding.isWellOrder\n\n"}
{"name":"OrderEmbedding.wellFoundedLT","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : WellFoundedLT β\nf : OrderEmbedding α β\n⊢ WellFoundedLT α","decl":"/-- A preorder which embeds into a well-founded preorder is itself well-founded. -/\nprotected theorem wellFoundedLT [WellFoundedLT β] (f : α ↪o β) : WellFoundedLT α where\n  wf := f.wellFounded IsWellFounded.wf\n\n"}
{"name":"OrderEmbedding.wellFoundedGT","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : WellFoundedGT β\nf : OrderEmbedding α β\n⊢ WellFoundedGT α","decl":"/-- A preorder which embeds into a preorder in which `(· > ·)` is well-founded\nalso has `(· > ·)` well-founded. -/\nprotected theorem wellFoundedGT [WellFoundedGT β] (f : α ↪o β) : WellFoundedGT α :=\n  @OrderEmbedding.wellFoundedLT αᵒᵈ _ _ _ _ f.dual\n\n"}
{"name":"OrderEmbedding.withBotMap_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderEmbedding α β\n⊢ Eq (⇑f.withBotMap) (WithBot.map ⇑f)","decl":"/-- A version of `WithBot.map` for order embeddings. -/\n@[simps (config := .asFn)]\nprotected def withBotMap (f : α ↪o β) : WithBot α ↪o WithBot β :=\n  { f.toEmbedding.optionMap with\n    toFun := WithBot.map f,\n    map_rel_iff' := @fun a b => WithBot.map_le_iff f f.map_rel_iff a b }\n\n"}
{"name":"OrderEmbedding.withTopMap_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderEmbedding α β\n⊢ Eq (⇑f.withTopMap) (WithTop.map ⇑f)","decl":"/-- A version of `WithTop.map` for order embeddings. -/\n@[simps (config := .asFn)]\nprotected def withTopMap (f : α ↪o β) : WithTop α ↪o WithTop β :=\n  { f.dual.withBotMap.dual with toFun := WithTop.map f }\n\n"}
{"name":"OrderEmbedding.withBotCoe_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\n⊢ Eq (⇑OrderEmbedding.withBotCoe) WithBot.some","decl":"/-- Coercion `α → WithBot α` as an `OrderEmbedding`. -/\n@[simps (config := .asFn)]\nprotected def withBotCoe : α ↪o WithBot α where\n  toFun := .some\n  inj' := Option.some_injective _\n  map_rel_iff' := WithBot.coe_le_coe\n\n"}
{"name":"OrderEmbedding.withTopCoe_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\n⊢ Eq (⇑OrderEmbedding.withTopCoe) WithTop.some","decl":"/-- Coercion `α → WithTop α` as an `OrderEmbedding`. -/\n@[simps (config := .asFn)]\nprotected def withTopCoe : α ↪o WithTop α :=\n  { (OrderEmbedding.withBotCoe (α := αᵒᵈ)).dual with toFun := .some }\n\n"}
{"name":"OrderEmbedding.coe_ofMapLEIff","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nf : α → β\nh : ∀ (a b : α), Iff (LE.le (f a) (f b)) (LE.le a b)\n⊢ Eq (⇑(OrderEmbedding.ofMapLEIff f h)) f","decl":"@[simp]\ntheorem coe_ofMapLEIff {α β} [PartialOrder α] [Preorder β] {f : α → β} (h) :\n    ⇑(ofMapLEIff f h) = f :=\n  rfl\n\n"}
{"name":"OrderEmbedding.coe_ofStrictMono","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nh : StrictMono f\n⊢ Eq (⇑(OrderEmbedding.ofStrictMono f h)) f","decl":"@[simp]\ntheorem coe_ofStrictMono {α β} [LinearOrder α] [Preorder β] {f : α → β} (h : StrictMono f) :\n    ⇑(ofStrictMono f h) = f :=\n  rfl\n\n"}
{"name":"OrderEmbedding.subtype_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\np : α → Prop\n⊢ Eq (⇑(OrderEmbedding.subtype p)) Subtype.val","decl":"/-- Embedding of a subtype into the ambient type as an `OrderEmbedding`. -/\n@[simps! (config := .asFn)]\ndef subtype (p : α → Prop) : Subtype p ↪o α :=\n  ⟨Function.Embedding.subtype p, Iff.rfl⟩\n\n"}
{"name":"OrderEmbedding.toOrderHom_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"X : Type u_6\nY : Type u_7\ninst✝¹ : Preorder X\ninst✝ : Preorder Y\nf : OrderEmbedding X Y\n⊢ Eq ⇑f.toOrderHom ⇑f","decl":"/-- Convert an `OrderEmbedding` to an `OrderHom`. -/\n@[simps (config := .asFn)]\ndef toOrderHom {X Y : Type*} [Preorder X] [Preorder Y] (f : X ↪o Y) : X →o Y where\n  toFun := f\n  monotone' := f.monotone\n\n"}
{"name":"OrderEmbedding.ofIsEmpty_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : IsEmpty α\na : α\n⊢ Eq (OrderEmbedding.ofIsEmpty a) (isEmptyElim a)","decl":"/-- The trivial embedding from an empty preorder to another preorder -/\n@[simps] def ofIsEmpty [IsEmpty α] : α ↪o β where\n  toFun := isEmptyElim\n  inj' := isEmptyElim\n  map_rel_iff' {a} := isEmptyElim a\n\n"}
{"name":"OrderEmbedding.coe_ofIsEmpty","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : IsEmpty α\n⊢ Eq ⇑OrderEmbedding.ofIsEmpty fun a => isEmptyElim a","decl":"@[simp, norm_cast]\nlemma coe_ofIsEmpty [IsEmpty α] : (ofIsEmpty : α ↪o β) = (isEmptyElim : α → β) := rfl\n\n"}
{"name":"Disjoint.of_orderEmbedding","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\nf : OrderEmbedding α β\ninst✝¹ : OrderBot α\ninst✝ : OrderBot β\na₁ a₂ : α\na✝ : Disjoint (f a₁) (f a₂)\n⊢ Disjoint a₁ a₂","decl":"/-- If the images by an order embedding of two elements are disjoint,\nthen they are themselves disjoint. -/\nlemma Disjoint.of_orderEmbedding [OrderBot α] [OrderBot β] {a₁ a₂ : α} :\n    Disjoint (f a₁) (f a₂) → Disjoint a₁ a₂ := by\n  intro h x h₁ h₂\n  rw [← f.le_iff_le] at h₁ h₂ ⊢\n  calc\n    f x ≤ ⊥ := h h₁ h₂\n    _ ≤ f ⊥ := bot_le\n\n"}
{"name":"Codisjoint.of_orderEmbedding","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\nf : OrderEmbedding α β\ninst✝¹ : OrderTop α\ninst✝ : OrderTop β\na₁ a₂ : α\na✝ : Codisjoint (f a₁) (f a₂)\n⊢ Codisjoint a₁ a₂","decl":"/-- If the images by an order embedding of two elements are codisjoint,\nthen they are themselves codisjoint. -/\nlemma Codisjoint.of_orderEmbedding [OrderTop α] [OrderTop β] {a₁ a₂ : α} :\n    Codisjoint (f a₁) (f a₂) → Codisjoint a₁ a₂ :=\n  Disjoint.of_orderEmbedding (α := αᵒᵈ) (β := βᵒᵈ) f.dual\n\n"}
{"name":"IsCompl.of_orderEmbedding","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : PartialOrder α\ninst✝² : PartialOrder β\nf : OrderEmbedding α β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\na₁ a₂ : α\na✝ : IsCompl (f a₁) (f a₂)\n⊢ IsCompl a₁ a₂","decl":"/-- If the images by an order embedding of two elements are complements,\nthen they are themselves complements. -/\nlemma IsCompl.of_orderEmbedding [BoundedOrder α] [BoundedOrder β] {a₁ a₂ : α} :\n    IsCompl (f a₁) (f a₂) → IsCompl a₁ a₂ := fun ⟨hd, hcd⟩ ↦\n  ⟨Disjoint.of_orderEmbedding f hd, Codisjoint.of_orderEmbedding f hcd⟩\n\n"}
{"name":"RelHom.toOrderHom_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nf : RelHom (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Eq ⇑f.toOrderHom ⇑f","decl":"/-- A bundled expression of the fact that a map between partial orders that is strictly monotone\nis weakly monotone. -/\n@[simps (config := .asFn)]\ndef toOrderHom : α →o β where\n  toFun := f\n  monotone' := StrictMono.monotone fun _ _ => f.map_rel\n\n"}
{"name":"RelEmbedding.toOrderHom_injective","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nf : RelEmbedding (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Function.Injective ⇑f.toRelHom.toOrderHom","decl":"theorem RelEmbedding.toOrderHom_injective\n    (f : ((· < ·) : α → α → Prop) ↪r ((· < ·) : β → β → Prop)) :\n    Function.Injective (f : ((· < ·) : α → α → Prop) →r ((· < ·) : β → β → Prop)).toOrderHom :=\n  fun _ _ h => f.injective h\n\n"}
{"name":"OrderIso.instOrderIsoClass","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\n⊢ OrderIsoClass (OrderIso α β) α β","decl":"instance : OrderIsoClass (α ≃o β) α β where\n  map_le_map_iff f _ _ := f.map_rel_iff'\n\n"}
{"name":"OrderIso.toFun_eq_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\nf : OrderIso α β\n⊢ Eq f.toFun ⇑f","decl":"@[simp]\ntheorem toFun_eq_coe {f : α ≃o β} : f.toFun = f :=\n  rfl\n\n-- See note [partially-applied ext lemmas]\n"}
{"name":"OrderIso.ext_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\nf g : OrderIso α β\n⊢ Iff (Eq f g) (Eq ⇑f ⇑g)","decl":"@[ext]\ntheorem ext {f g : α ≃o β} (h : (f : α → β) = g) : f = g :=\n  DFunLike.coe_injective h\n\n"}
{"name":"OrderIso.ext","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\nf g : OrderIso α β\nh : Eq ⇑f ⇑g\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : α ≃o β} (h : (f : α → β) = g) : f = g :=\n  DFunLike.coe_injective h\n\n"}
{"name":"OrderIso.coe_toOrderEmbedding","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\n⊢ Eq ⇑e.toOrderEmbedding ⇑e","decl":"@[simp]\ntheorem coe_toOrderEmbedding (e : α ≃o β) : ⇑e.toOrderEmbedding = e :=\n  rfl\n\n"}
{"name":"OrderIso.bijective","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\n⊢ Function.Bijective ⇑e","decl":"protected theorem bijective (e : α ≃o β) : Function.Bijective e :=\n  e.toEquiv.bijective\n\n"}
{"name":"OrderIso.injective","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\n⊢ Function.Injective ⇑e","decl":"protected theorem injective (e : α ≃o β) : Function.Injective e :=\n  e.toEquiv.injective\n\n"}
{"name":"OrderIso.surjective","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\n⊢ Function.Surjective ⇑e","decl":"protected theorem surjective (e : α ≃o β) : Function.Surjective e :=\n  e.toEquiv.surjective\n\n"}
{"name":"OrderIso.apply_eq_iff_eq","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\nx y : α\n⊢ Iff (Eq (e x) (e y)) (Eq x y)","decl":"theorem apply_eq_iff_eq (e : α ≃o β) {x y : α} : e x = e y ↔ x = y :=\n  e.toEquiv.apply_eq_iff_eq\n\n"}
{"name":"OrderIso.coe_refl","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\n⊢ Eq (⇑(OrderIso.refl α)) id","decl":"@[simp]\ntheorem coe_refl : ⇑(refl α) = id :=\n  rfl\n\n"}
{"name":"OrderIso.refl_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\nx : α\n⊢ Eq ((OrderIso.refl α) x) x","decl":"@[simp]\ntheorem refl_apply (x : α) : refl α x = x :=\n  rfl\n\n"}
{"name":"OrderIso.refl_toEquiv","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\n⊢ Eq (OrderIso.refl α).toEquiv (Equiv.refl α)","decl":"@[simp]\ntheorem refl_toEquiv : (refl α).toEquiv = Equiv.refl α :=\n  rfl\n\n"}
{"name":"OrderIso.apply_symm_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\nx : β\n⊢ Eq (e (e.symm x)) x","decl":"@[simp]\ntheorem apply_symm_apply (e : α ≃o β) (x : β) : e (e.symm x) = x :=\n  e.toEquiv.apply_symm_apply x\n\n"}
{"name":"OrderIso.symm_apply_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\nx : α\n⊢ Eq (e.symm (e x)) x","decl":"@[simp]\ntheorem symm_apply_apply (e : α ≃o β) (x : α) : e.symm (e x) = x :=\n  e.toEquiv.symm_apply_apply x\n\n"}
{"name":"OrderIso.symm_refl","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\ninst✝ : LE α\n⊢ Eq (OrderIso.refl α).symm (OrderIso.refl α)","decl":"@[simp]\ntheorem symm_refl (α : Type*) [LE α] : (refl α).symm = refl α :=\n  rfl\n\n"}
{"name":"OrderIso.apply_eq_iff_eq_symm_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\nx : α\ny : β\n⊢ Iff (Eq (e x) y) (Eq x (e.symm y))","decl":"theorem apply_eq_iff_eq_symm_apply (e : α ≃o β) (x : α) (y : β) : e x = y ↔ x = e.symm y :=\n  e.toEquiv.apply_eq_iff_eq_symm_apply\n\n"}
{"name":"OrderIso.symm_apply_eq","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\nx : α\ny : β\n⊢ Iff (Eq (e.symm y) x) (Eq y (e x))","decl":"theorem symm_apply_eq (e : α ≃o β) {x : α} {y : β} : e.symm y = x ↔ y = e x :=\n  e.toEquiv.symm_apply_eq\n\n"}
{"name":"OrderIso.symm_symm","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\n⊢ Eq e.symm.symm e","decl":"@[simp]\ntheorem symm_symm (e : α ≃o β) : e.symm.symm = e := rfl\n\n"}
{"name":"OrderIso.symm_bijective","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\n⊢ Function.Bijective OrderIso.symm","decl":"theorem symm_bijective : Function.Bijective (OrderIso.symm : (α ≃o β) → β ≃o α) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"OrderIso.symm_injective","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\n⊢ Function.Injective OrderIso.symm","decl":"theorem symm_injective : Function.Injective (symm : α ≃o β → β ≃o α) :=\n  symm_bijective.injective\n\n"}
{"name":"OrderIso.toEquiv_symm","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\n⊢ Eq e.symm e.symm.toEquiv","decl":"@[simp]\ntheorem toEquiv_symm (e : α ≃o β) : e.toEquiv.symm = e.symm.toEquiv :=\n  rfl\n\n"}
{"name":"OrderIso.coe_trans","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\ne : OrderIso α β\ne' : OrderIso β γ\n⊢ Eq (⇑(e.trans e')) (Function.comp ⇑e' ⇑e)","decl":"@[simp]\ntheorem coe_trans (e : α ≃o β) (e' : β ≃o γ) : ⇑(e.trans e') = e' ∘ e :=\n  rfl\n\n"}
{"name":"OrderIso.trans_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\ne : OrderIso α β\ne' : OrderIso β γ\nx : α\n⊢ Eq ((e.trans e') x) (e' (e x))","decl":"@[simp]\ntheorem trans_apply (e : α ≃o β) (e' : β ≃o γ) (x : α) : e.trans e' x = e' (e x) :=\n  rfl\n\n"}
{"name":"OrderIso.refl_trans","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\n⊢ Eq ((OrderIso.refl α).trans e) e","decl":"@[simp]\ntheorem refl_trans (e : α ≃o β) : (refl α).trans e = e := by\n  ext x\n  rfl\n\n"}
{"name":"OrderIso.trans_refl","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\n⊢ Eq (e.trans (OrderIso.refl β)) e","decl":"@[simp]\ntheorem trans_refl (e : α ≃o β) : e.trans (refl β) = e := by\n  ext x\n  rfl\n\n"}
{"name":"OrderIso.symm_trans_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\ne₁ : OrderIso α β\ne₂ : OrderIso β γ\nc : γ\n⊢ Eq ((e₁.trans e₂).symm c) (e₁.symm (e₂.symm c))","decl":"@[simp]\ntheorem symm_trans_apply (e₁ : α ≃o β) (e₂ : β ≃o γ) (c : γ) :\n    (e₁.trans e₂).symm c = e₁.symm (e₂.symm c) :=\n  rfl\n\n"}
{"name":"OrderIso.symm_trans","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : LE α\ninst✝¹ : LE β\ninst✝ : LE γ\ne₁ : OrderIso α β\ne₂ : OrderIso β γ\n⊢ Eq (e₁.trans e₂).symm (e₂.symm.trans e₁.symm)","decl":"theorem symm_trans (e₁ : α ≃o β) (e₂ : β ≃o γ) : (e₁.trans e₂).symm = e₂.symm.trans e₁.symm :=\n  rfl\n\n"}
{"name":"OrderIso.self_trans_symm","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\n⊢ Eq (e.trans e.symm) (OrderIso.refl α)","decl":"@[simp]\ntheorem self_trans_symm (e : α ≃o β) : e.trans e.symm = OrderIso.refl α :=\n  RelIso.self_trans_symm e\n\n"}
{"name":"OrderIso.symm_trans_self","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\n⊢ Eq (e.symm.trans e) (OrderIso.refl β)","decl":"@[simp]\ntheorem symm_trans_self (e : α ≃o β) : e.symm.trans e = OrderIso.refl β :=\n  RelIso.symm_trans_self e\n\n"}
{"name":"OrderIso.arrowCongr_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\nγ : Type u_8\nδ : Type u_9\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Preorder γ\ninst✝ : Preorder δ\nf : OrderIso α γ\ng : OrderIso β δ\np : OrderHom α β\n⊢ Eq ((f.arrowCongr g) p) ((↑g).comp (p.comp ↑f.symm))","decl":"/-- An order isomorphism between the domains and codomains of two prosets of\norder homomorphisms gives an order isomorphism between the two function prosets. -/\n@[simps apply symm_apply]\ndef arrowCongr {α β γ δ} [Preorder α] [Preorder β] [Preorder γ] [Preorder δ]\n    (f : α ≃o γ) (g : β ≃o δ) : (α →o β) ≃o (γ →o δ) where\n  toFun  p := .comp g <| .comp p f.symm\n  invFun p := .comp g.symm <| .comp p f\n  left_inv p := DFunLike.coe_injective <| by\n    change (g.symm ∘ g) ∘ p ∘ (f.symm ∘ f) = p\n    simp only [← DFunLike.coe_eq_coe_fn, ← OrderIso.coe_trans, Function.id_comp,\n               OrderIso.self_trans_symm, OrderIso.coe_refl, Function.comp_id]\n  right_inv p := DFunLike.coe_injective <| by\n    change (g ∘ g.symm) ∘ p ∘ (f ∘ f.symm) = p\n    simp only [← DFunLike.coe_eq_coe_fn, ← OrderIso.coe_trans, Function.id_comp,\n               OrderIso.symm_trans_self, OrderIso.coe_refl, Function.comp_id]\n  map_rel_iff' {p q} := by\n    simp only [Equiv.coe_fn_mk, OrderHom.le_def, OrderHom.comp_coe,\n               OrderHomClass.coe_coe, Function.comp_apply, map_le_map_iff]\n    exact Iff.symm f.forall_congr_left\n\n"}
{"name":"OrderIso.arrowCongr_symm_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\nγ : Type u_8\nδ : Type u_9\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : Preorder γ\ninst✝ : Preorder δ\nf : OrderIso α γ\ng : OrderIso β δ\np : OrderHom γ δ\n⊢ Eq ((RelIso.symm (f.arrowCongr g)) p) ((↑g.symm).comp (p.comp ↑f))","decl":"/-- An order isomorphism between the domains and codomains of two prosets of\norder homomorphisms gives an order isomorphism between the two function prosets. -/\n@[simps apply symm_apply]\ndef arrowCongr {α β γ δ} [Preorder α] [Preorder β] [Preorder γ] [Preorder δ]\n    (f : α ≃o γ) (g : β ≃o δ) : (α →o β) ≃o (γ →o δ) where\n  toFun  p := .comp g <| .comp p f.symm\n  invFun p := .comp g.symm <| .comp p f\n  left_inv p := DFunLike.coe_injective <| by\n    change (g.symm ∘ g) ∘ p ∘ (f.symm ∘ f) = p\n    simp only [← DFunLike.coe_eq_coe_fn, ← OrderIso.coe_trans, Function.id_comp,\n               OrderIso.self_trans_symm, OrderIso.coe_refl, Function.comp_id]\n  right_inv p := DFunLike.coe_injective <| by\n    change (g ∘ g.symm) ∘ p ∘ (f ∘ f.symm) = p\n    simp only [← DFunLike.coe_eq_coe_fn, ← OrderIso.coe_trans, Function.id_comp,\n               OrderIso.symm_trans_self, OrderIso.coe_refl, Function.comp_id]\n  map_rel_iff' {p q} := by\n    simp only [Equiv.coe_fn_mk, OrderHom.le_def, OrderHom.comp_coe,\n               OrderHomClass.coe_coe, Function.comp_apply, map_le_map_iff]\n    exact Iff.symm f.forall_congr_left\n\n"}
{"name":"OrderIso.conj_symm_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\na✝ : OrderHom β β\n⊢ Eq (f.conj.symm a✝) (EquivLike.inv (f.arrowCongr f) a✝)","decl":"/-- If `α` and `β` are order-isomorphic then the two orders of order-homomorphisms\nfrom `α` and `β` to themselves are order-isomorphic. -/\n@[simps! apply symm_apply]\ndef conj {α β} [Preorder α] [Preorder β] (f : α ≃o β) : (α →o α) ≃ (β →o β) :=\n  arrowCongr f f\n\n"}
{"name":"OrderIso.conj_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\na : OrderHom α α\n⊢ Eq (f.conj a) ((↑f).comp (a.comp ↑f.symm))","decl":"/-- If `α` and `β` are order-isomorphic then the two orders of order-homomorphisms\nfrom `α` and `β` to themselves are order-isomorphic. -/\n@[simps! apply symm_apply]\ndef conj {α β} [Preorder α] [Preorder β] (f : α ≃o β) : (α →o α) ≃ (β →o β) :=\n  arrowCongr f f\n\n"}
{"name":"OrderIso.coe_prodComm","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\n⊢ Eq (⇑OrderIso.prodComm) Prod.swap","decl":"@[simp]\ntheorem coe_prodComm : ⇑(prodComm : α × β ≃o β × α) = Prod.swap :=\n  rfl\n\n"}
{"name":"OrderIso.prodComm_symm","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\n⊢ Eq OrderIso.prodComm.symm OrderIso.prodComm","decl":"@[simp]\ntheorem prodComm_symm : (prodComm : α × β ≃o β × α).symm = prodComm :=\n  rfl\n\n"}
{"name":"OrderIso.coe_dualDual","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\n⊢ Eq (⇑(OrderIso.dualDual α)) (Function.comp ⇑OrderDual.toDual ⇑OrderDual.toDual)","decl":"@[simp]\ntheorem coe_dualDual : ⇑(dualDual α) = toDual ∘ toDual :=\n  rfl\n\n"}
{"name":"OrderIso.coe_dualDual_symm","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\n⊢ Eq (⇑(OrderIso.dualDual α).symm) (Function.comp ⇑OrderDual.ofDual ⇑OrderDual.ofDual)","decl":"@[simp]\ntheorem coe_dualDual_symm : ⇑(dualDual α).symm = ofDual ∘ ofDual :=\n  rfl\n\n"}
{"name":"OrderIso.dualDual_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\na : α\n⊢ Eq ((OrderIso.dualDual α) a) (OrderDual.toDual (OrderDual.toDual a))","decl":"@[simp]\ntheorem dualDual_apply (a : α) : dualDual α a = toDual (toDual a) :=\n  rfl\n\n"}
{"name":"OrderIso.dualDual_symm_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\na : OrderDual (OrderDual α)\n⊢ Eq ((OrderIso.dualDual α).symm a) (OrderDual.ofDual (OrderDual.ofDual a))","decl":"@[simp]\ntheorem dualDual_symm_apply (a : αᵒᵈᵒᵈ) : (dualDual α).symm a = ofDual (ofDual a) :=\n  rfl\n\n"}
{"name":"OrderIso.le_iff_le","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\nx y : α\n⊢ Iff (LE.le (e x) (e y)) (LE.le x y)","decl":"theorem le_iff_le (e : α ≃o β) {x y : α} : e x ≤ e y ↔ x ≤ y :=\n  e.map_rel_iff\n\n"}
{"name":"OrderIso.GCongr.orderIso_apply_le_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\nx y : α\na✝ : LE.le x y\n⊢ LE.le (e x) (e y)","decl":"@[gcongr] protected alias ⟨_, GCongr.orderIso_apply_le_apply⟩ := le_iff_le\n\n"}
{"name":"OrderIso.le_symm_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\nx : α\ny : β\n⊢ Iff (LE.le x (e.symm y)) (LE.le (e x) y)","decl":"theorem le_symm_apply (e : α ≃o β) {x : α} {y : β} : x ≤ e.symm y ↔ e x ≤ y :=\n  e.rel_symm_apply\n\n"}
{"name":"OrderIso.symm_apply_le","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\ne : OrderIso α β\nx : α\ny : β\n⊢ Iff (LE.le (e.symm y) x) (LE.le y (e x))","decl":"theorem symm_apply_le (e : α ≃o β) {x : α} {y : β} : e.symm y ≤ x ↔ y ≤ e x :=\n  e.symm_apply_rel\n\n"}
{"name":"OrderIso.monotone","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\n⊢ Monotone ⇑e","decl":"protected theorem monotone (e : α ≃o β) : Monotone e :=\n  e.toOrderEmbedding.monotone\n\n"}
{"name":"OrderIso.strictMono","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\n⊢ StrictMono ⇑e","decl":"protected theorem strictMono (e : α ≃o β) : StrictMono e :=\n  e.toOrderEmbedding.strictMono\n\n"}
{"name":"OrderIso.lt_iff_lt","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\nx y : α\n⊢ Iff (LT.lt (e x) (e y)) (LT.lt x y)","decl":"@[simp]\ntheorem lt_iff_lt (e : α ≃o β) {x y : α} : e x < e y ↔ x < y :=\n  e.toOrderEmbedding.lt_iff_lt\n\n"}
{"name":"OrderIso.GCongr.orderIso_apply_lt_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\nx y : α\na✝ : LT.lt x y\n⊢ LT.lt (e x) (e y)","decl":"@[gcongr] protected alias ⟨_, GCongr.orderIso_apply_lt_apply⟩ := lt_iff_lt\n\n"}
{"name":"OrderIso.toRelIsoLT_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\nx : α\n⊢ Eq (e.toRelIsoLT x) (e x)","decl":"@[simp]\ntheorem toRelIsoLT_apply (e : α ≃o β) (x : α) : e.toRelIsoLT x = e x :=\n  rfl\n\n"}
{"name":"OrderIso.toRelIsoLT_symm","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\n⊢ Eq e.toRelIsoLT.symm e.symm.toRelIsoLT","decl":"@[simp]\ntheorem toRelIsoLT_symm (e : α ≃o β) : e.toRelIsoLT.symm = e.symm.toRelIsoLT :=\n  rfl\n\n"}
{"name":"OrderIso.ofRelIsoLT_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\ne : RelIso (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\nx : α\n⊢ Eq ((OrderIso.ofRelIsoLT e) x) (e x)","decl":"@[simp]\ntheorem ofRelIsoLT_apply {α β} [PartialOrder α] [PartialOrder β]\n    (e : ((· < ·) : α → α → Prop) ≃r ((· < ·) : β → β → Prop)) (x : α) : ofRelIsoLT e x = e x :=\n  rfl\n\n"}
{"name":"OrderIso.ofRelIsoLT_symm","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\ne : RelIso (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Eq (OrderIso.ofRelIsoLT e).symm (OrderIso.ofRelIsoLT e.symm)","decl":"@[simp]\ntheorem ofRelIsoLT_symm {α β} [PartialOrder α] [PartialOrder β]\n    (e : ((· < ·) : α → α → Prop) ≃r ((· < ·) : β → β → Prop)) :\n    (ofRelIsoLT e).symm = ofRelIsoLT e.symm :=\n  rfl\n\n"}
{"name":"OrderIso.ofRelIsoLT_toRelIsoLT","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\ne : OrderIso α β\n⊢ Eq (OrderIso.ofRelIsoLT e.toRelIsoLT) e","decl":"@[simp]\ntheorem ofRelIsoLT_toRelIsoLT {α β} [PartialOrder α] [PartialOrder β] (e : α ≃o β) :\n    ofRelIsoLT (toRelIsoLT e) = e := by\n  ext\n  simp\n\n"}
{"name":"OrderIso.toRelIsoLT_ofRelIsoLT","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\ne : RelIso (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Eq (OrderIso.ofRelIsoLT e).toRelIsoLT e","decl":"@[simp]\ntheorem toRelIsoLT_ofRelIsoLT {α β} [PartialOrder α] [PartialOrder β]\n    (e : ((· < ·) : α → α → Prop) ≃r ((· < ·) : β → β → Prop)) : toRelIsoLT (ofRelIsoLT e) = e := by\n  ext\n  simp\n\n"}
{"name":"OrderIso.funUnique_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Unique α\ninst✝ : Preorder β\nf : (i : α) → (fun a => β) i\n⊢ Eq ((OrderIso.funUnique α β) f) (f Inhabited.default)","decl":"/-- Order isomorphism between `α → β` and `β`, where `α` has a unique element. -/\n@[simps! toEquiv apply]\ndef funUnique (α β : Type*) [Unique α] [Preorder β] : (α → β) ≃o β where\n  toEquiv := Equiv.funUnique α β\n  map_rel_iff' := by simp [Pi.le_def, Unique.forall_iff]\n\n"}
{"name":"OrderIso.funUnique_toEquiv","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Unique α\ninst✝ : Preorder β\n⊢ Eq (OrderIso.funUnique α β).toEquiv (Equiv.funUnique α β)","decl":"/-- Order isomorphism between `α → β` and `β`, where `α` has a unique element. -/\n@[simps! toEquiv apply]\ndef funUnique (α β : Type*) [Unique α] [Preorder β] : (α → β) ≃o β where\n  toEquiv := Equiv.funUnique α β\n  map_rel_iff' := by simp [Pi.le_def, Unique.forall_iff]\n\n"}
{"name":"OrderIso.funUnique_symm_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Unique α\ninst✝ : Preorder β\n⊢ Eq (⇑(OrderIso.funUnique α β).symm) (Function.const α)","decl":"@[simp]\ntheorem funUnique_symm_apply {α β : Type*} [Unique α] [Preorder β] :\n    ((funUnique α β).symm : β → α → β) = Function.const α :=\n  rfl\n\n"}
{"name":"OrderIso.ofUnique_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Unique α\ninst✝² : Unique β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na✝ : α\n⊢ Eq ((OrderIso.ofUnique α β) a✝) Inhabited.default","decl":"/-- The order isomorphism `α ≃o β` when `α` and `β` are preordered types\ncontaining unique elements. -/\n@[simps!]\nnoncomputable def ofUnique\n    (α β : Type*) [Unique α] [Unique β] [Preorder α] [Preorder β] :\n    α ≃o β where\n  toEquiv := Equiv.ofUnique α β\n  map_rel_iff' := by simp\n\n"}
{"name":"OrderIso.ofUnique_symm_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Unique α\ninst✝² : Unique β\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na✝ : β\n⊢ Eq ((RelIso.symm (OrderIso.ofUnique α β)) a✝) Inhabited.default","decl":"/-- The order isomorphism `α ≃o β` when `α` and `β` are preordered types\ncontaining unique elements. -/\n@[simps!]\nnoncomputable def ofUnique\n    (α β : Type*) [Unique α] [Unique β] [Preorder α] [Preorder β] :\n    α ≃o β where\n  toEquiv := Equiv.ofUnique α β\n  map_rel_iff' := by simp\n\n"}
{"name":"Equiv.coe_toOrderIso","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : Equiv α β\nh₁ : Monotone ⇑e\nh₂ : Monotone ⇑e.symm\n⊢ Eq ⇑(e.toOrderIso h₁ h₂) ⇑e","decl":"@[simp]\ntheorem coe_toOrderIso (e : α ≃ β) (h₁ : Monotone e) (h₂ : Monotone e.symm) :\n    ⇑(e.toOrderIso h₁ h₂) = e :=\n  rfl\n\n"}
{"name":"Equiv.toOrderIso_toEquiv","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : Equiv α β\nh₁ : Monotone ⇑e\nh₂ : Monotone ⇑e.symm\n⊢ Eq (e.toOrderIso h₁ h₂).toEquiv e","decl":"@[simp]\ntheorem toOrderIso_toEquiv (e : α ≃ β) (h₁ : Monotone e) (h₂ : Monotone e.symm) :\n    (e.toOrderIso h₁ h₂).toEquiv = e :=\n  rfl\n\n"}
{"name":"StrictMono.orderIsoOfRightInverse_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nh_mono : StrictMono f\ng : β → α\nhg : Function.RightInverse g f\n⊢ Eq (⇑(StrictMono.orderIsoOfRightInverse f h_mono g hg)) f","decl":"/-- A strictly monotone function with a right inverse is an order isomorphism. -/\n@[simps (config := .asFn)]\ndef orderIsoOfRightInverse (g : β → α) (hg : Function.RightInverse g f) : α ≃o β :=\n  { OrderEmbedding.ofStrictMono f h_mono with\n    toFun := f,\n    invFun := g,\n    left_inv := fun _ => h_mono.injective <| hg _,\n    right_inv := hg }\n\n"}
{"name":"StrictMono.orderIsoOfRightInverse_symm_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nh_mono : StrictMono f\ng : β → α\nhg : Function.RightInverse g f\n⊢ Eq (⇑(RelIso.symm (StrictMono.orderIsoOfRightInverse f h_mono g hg))) g","decl":"/-- A strictly monotone function with a right inverse is an order isomorphism. -/\n@[simps (config := .asFn)]\ndef orderIsoOfRightInverse (g : β → α) (hg : Function.RightInverse g f) : α ≃o β :=\n  { OrderEmbedding.ofStrictMono f h_mono with\n    toFun := f,\n    invFun := g,\n    left_inv := fun _ => h_mono.injective <| hg _,\n    right_inv := hg }\n\n"}
{"name":"OrderIso.map_bot'","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : PartialOrder β\nf : OrderIso α β\nx : α\ny : β\nhx : ∀ (x' : α), LE.le x x'\nhy : ∀ (y' : β), LE.le y y'\n⊢ Eq (f x) y","decl":"theorem OrderIso.map_bot' [LE α] [PartialOrder β] (f : α ≃o β) {x : α} {y : β} (hx : ∀ x', x ≤ x')\n    (hy : ∀ y', y ≤ y') : f x = y := by\n  refine le_antisymm ?_ (hy _)\n  rw [← f.apply_symm_apply y, f.map_rel_iff]\n  apply hx\n\n"}
{"name":"OrderIso.map_bot","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : LE α\ninst✝² : PartialOrder β\ninst✝¹ : OrderBot α\ninst✝ : OrderBot β\nf : OrderIso α β\n⊢ Eq (f Bot.bot) Bot.bot","decl":"theorem OrderIso.map_bot [LE α] [PartialOrder β] [OrderBot α] [OrderBot β] (f : α ≃o β) : f ⊥ = ⊥ :=\n  f.map_bot' (fun _ => bot_le) fun _ => bot_le\n\n"}
{"name":"OrderIso.map_top'","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : PartialOrder β\nf : OrderIso α β\nx : α\ny : β\nhx : ∀ (x' : α), LE.le x' x\nhy : ∀ (y' : β), LE.le y' y\n⊢ Eq (f x) y","decl":"theorem OrderIso.map_top' [LE α] [PartialOrder β] (f : α ≃o β) {x : α} {y : β} (hx : ∀ x', x' ≤ x)\n    (hy : ∀ y', y' ≤ y) : f x = y :=\n  f.dual.map_bot' hx hy\n\n"}
{"name":"OrderIso.map_top","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : LE α\ninst✝² : PartialOrder β\ninst✝¹ : OrderTop α\ninst✝ : OrderTop β\nf : OrderIso α β\n⊢ Eq (f Top.top) Top.top","decl":"theorem OrderIso.map_top [LE α] [PartialOrder β] [OrderTop α] [OrderTop β] (f : α ≃o β) : f ⊤ = ⊤ :=\n  f.dual.map_bot\n\n"}
{"name":"OrderEmbedding.map_inf_le","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\nf : OrderEmbedding α β\nx y : α\n⊢ LE.le (f (Min.min x y)) (Min.min (f x) (f y))","decl":"theorem OrderEmbedding.map_inf_le [SemilatticeInf α] [SemilatticeInf β] (f : α ↪o β) (x y : α) :\n    f (x ⊓ y) ≤ f x ⊓ f y :=\n  f.monotone.map_inf_le x y\n\n"}
{"name":"OrderEmbedding.le_map_sup","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\nf : OrderEmbedding α β\nx y : α\n⊢ LE.le (Max.max (f x) (f y)) (f (Max.max x y))","decl":"theorem OrderEmbedding.le_map_sup [SemilatticeSup α] [SemilatticeSup β] (f : α ↪o β) (x y : α) :\n    f x ⊔ f y ≤ f (x ⊔ y) :=\n  f.monotone.le_map_sup x y\n\n"}
{"name":"OrderIso.map_inf","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\nf : OrderIso α β\nx y : α\n⊢ Eq (f (Min.min x y)) (Min.min (f x) (f y))","decl":"theorem OrderIso.map_inf [SemilatticeInf α] [SemilatticeInf β] (f : α ≃o β) (x y : α) :\n    f (x ⊓ y) = f x ⊓ f y := by\n  refine (f.toOrderEmbedding.map_inf_le x y).antisymm ?_\n  apply f.symm.le_iff_le.1\n  simpa using f.symm.toOrderEmbedding.map_inf_le (f x) (f y)\n\n"}
{"name":"OrderIso.map_sup","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\nf : OrderIso α β\nx y : α\n⊢ Eq (f (Max.max x y)) (Max.max (f x) (f y))","decl":"theorem OrderIso.map_sup [SemilatticeSup α] [SemilatticeSup β] (f : α ≃o β) (x y : α) :\n    f (x ⊔ y) = f x ⊔ f y :=\n  f.dual.map_inf x y\n\n"}
{"name":"OrderIso.isMax_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\nx : α\n⊢ Iff (IsMax (f x)) (IsMax x)","decl":"theorem OrderIso.isMax_apply {α β : Type*} [Preorder α] [Preorder β] (f : α ≃o β) {x : α} :\n    IsMax (f x) ↔ IsMax x := by\n  refine ⟨f.strictMono.isMax_of_apply, ?_⟩\n  conv_lhs => rw [← f.symm_apply_apply x]\n  exact f.symm.strictMono.isMax_of_apply\n\n"}
{"name":"OrderIso.isMin_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\nx : α\n⊢ Iff (IsMin (f x)) (IsMin x)","decl":"theorem OrderIso.isMin_apply {α β : Type*} [Preorder α] [Preorder β] (f : α ≃o β) {x : α} :\n    IsMin (f x) ↔ IsMin x := by\n  refine ⟨f.strictMono.isMin_of_apply, ?_⟩\n  conv_lhs => rw [← f.symm_apply_apply x]\n  exact f.symm.strictMono.isMin_of_apply\n\n"}
{"name":"Disjoint.map_orderIso","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : SemilatticeInf α\ninst✝² : OrderBot α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderBot β\na b : α\nf : OrderIso α β\nha : Disjoint a b\n⊢ Disjoint (f a) (f b)","decl":"/-- Note that this goal could also be stated `(Disjoint on f) a b` -/\ntheorem Disjoint.map_orderIso [SemilatticeInf α] [OrderBot α] [SemilatticeInf β] [OrderBot β]\n    {a b : α} (f : α ≃o β) (ha : Disjoint a b) : Disjoint (f a) (f b) := by\n  rw [disjoint_iff_inf_le, ← f.map_inf, ← f.map_bot]\n  exact f.monotone ha.le_bot\n\n"}
{"name":"Codisjoint.map_orderIso","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : SemilatticeSup α\ninst✝² : OrderTop α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderTop β\na b : α\nf : OrderIso α β\nha : Codisjoint a b\n⊢ Codisjoint (f a) (f b)","decl":"/-- Note that this goal could also be stated `(Codisjoint on f) a b` -/\ntheorem Codisjoint.map_orderIso [SemilatticeSup α] [OrderTop α] [SemilatticeSup β] [OrderTop β]\n    {a b : α} (f : α ≃o β) (ha : Codisjoint a b) : Codisjoint (f a) (f b) := by\n  rw [codisjoint_iff_le_sup, ← f.map_sup, ← f.map_top]\n  exact f.monotone ha.top_le\n\n"}
{"name":"disjoint_map_orderIso_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : SemilatticeInf α\ninst✝² : OrderBot α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderBot β\na b : α\nf : OrderIso α β\n⊢ Iff (Disjoint (f a) (f b)) (Disjoint a b)","decl":"@[simp]\ntheorem disjoint_map_orderIso_iff [SemilatticeInf α] [OrderBot α] [SemilatticeInf β] [OrderBot β]\n    {a b : α} (f : α ≃o β) : Disjoint (f a) (f b) ↔ Disjoint a b :=\n  ⟨fun h => f.symm_apply_apply a ▸ f.symm_apply_apply b ▸ h.map_orderIso f.symm,\n   fun h => h.map_orderIso f⟩\n\n"}
{"name":"codisjoint_map_orderIso_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : SemilatticeSup α\ninst✝² : OrderTop α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderTop β\na b : α\nf : OrderIso α β\n⊢ Iff (Codisjoint (f a) (f b)) (Codisjoint a b)","decl":"@[simp]\ntheorem codisjoint_map_orderIso_iff [SemilatticeSup α] [OrderTop α] [SemilatticeSup β] [OrderTop β]\n    {a b : α} (f : α ≃o β) : Codisjoint (f a) (f b) ↔ Codisjoint a b :=\n  ⟨fun h => f.symm_apply_apply a ▸ f.symm_apply_apply b ▸ h.map_orderIso f.symm,\n   fun h => h.map_orderIso f⟩\n\n"}
{"name":"WithBot.toDualTopEquiv_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\na : α\n⊢ Eq (WithBot.toDualTopEquiv ↑(OrderDual.toDual a)) (OrderDual.toDual ↑a)","decl":"@[simp]\ntheorem toDualTopEquiv_coe [LE α] (a : α) :\n    WithBot.toDualTopEquiv ↑(toDual a) = toDual (a : WithTop α) :=\n  rfl\n\n"}
{"name":"WithBot.toDualTopEquiv_symm_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\na : α\n⊢ Eq (WithBot.toDualTopEquiv.symm (OrderDual.toDual ↑a)) ↑(OrderDual.toDual a)","decl":"@[simp]\ntheorem toDualTopEquiv_symm_coe [LE α] (a : α) :\n    WithBot.toDualTopEquiv.symm (toDual (a : WithTop α)) = ↑(toDual a) :=\n  rfl\n\n"}
{"name":"WithBot.toDualTopEquiv_bot","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\n⊢ Eq (WithBot.toDualTopEquiv Bot.bot) Bot.bot","decl":"@[simp]\ntheorem toDualTopEquiv_bot [LE α] : WithBot.toDualTopEquiv (⊥ : WithBot αᵒᵈ) = ⊥ :=\n  rfl\n\n"}
{"name":"WithBot.toDualTopEquiv_symm_bot","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\n⊢ Eq (WithBot.toDualTopEquiv.symm Bot.bot) Bot.bot","decl":"@[simp]\ntheorem toDualTopEquiv_symm_bot [LE α] : WithBot.toDualTopEquiv.symm (⊥ : (WithTop α)ᵒᵈ) = ⊥ :=\n  rfl\n\n"}
{"name":"WithBot.coe_toDualTopEquiv_eq","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\n⊢ Eq (⇑WithBot.toDualTopEquiv) (Function.comp ⇑OrderDual.toDual ⇑WithBot.ofDual)","decl":"theorem coe_toDualTopEquiv_eq [LE α] :\n    (WithBot.toDualTopEquiv : WithBot αᵒᵈ → (WithTop α)ᵒᵈ) = toDual ∘ WithBot.ofDual :=\n  funext fun _ => rfl\n\n"}
{"name":"WithBot.coeOrderHom_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\ninst✝ : Preorder α\na✝ : α\n⊢ Eq (WithBot.coeOrderHom a✝) ↑a✝","decl":"/-- The coercion `α → WithBot α` bundled as monotone map. -/\n@[simps]\ndef coeOrderHom {α : Type*} [Preorder α] : α ↪o WithBot α where\n  toFun := (↑)\n  inj' := WithBot.coe_injective\n  map_rel_iff' := WithBot.coe_le_coe\n\n"}
{"name":"WithTop.toDualBotEquiv_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\na : α\n⊢ Eq (WithTop.toDualBotEquiv ↑(OrderDual.toDual a)) (OrderDual.toDual ↑a)","decl":"@[simp]\ntheorem toDualBotEquiv_coe [LE α] (a : α) :\n    WithTop.toDualBotEquiv ↑(toDual a) = toDual (a : WithBot α) :=\n  rfl\n\n"}
{"name":"WithTop.toDualBotEquiv_symm_coe","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\na : α\n⊢ Eq (WithTop.toDualBotEquiv.symm (OrderDual.toDual ↑a)) ↑(OrderDual.toDual a)","decl":"@[simp]\ntheorem toDualBotEquiv_symm_coe [LE α] (a : α) :\n    WithTop.toDualBotEquiv.symm (toDual (a : WithBot α)) = ↑(toDual a) :=\n  rfl\n\n"}
{"name":"WithTop.toDualBotEquiv_top","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\n⊢ Eq (WithTop.toDualBotEquiv Top.top) Top.top","decl":"@[simp]\ntheorem toDualBotEquiv_top [LE α] : WithTop.toDualBotEquiv (⊤ : WithTop αᵒᵈ) = ⊤ :=\n  rfl\n\n"}
{"name":"WithTop.toDualBotEquiv_symm_top","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\n⊢ Eq (WithTop.toDualBotEquiv.symm Top.top) Top.top","decl":"@[simp]\ntheorem toDualBotEquiv_symm_top [LE α] : WithTop.toDualBotEquiv.symm (⊤ : (WithBot α)ᵒᵈ) = ⊤ :=\n  rfl\n\n"}
{"name":"WithTop.coe_toDualBotEquiv","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\n⊢ Eq (⇑WithTop.toDualBotEquiv) (Function.comp ⇑OrderDual.toDual ⇑WithTop.ofDual)","decl":"theorem coe_toDualBotEquiv [LE α] :\n    (WithTop.toDualBotEquiv : WithTop αᵒᵈ → (WithBot α)ᵒᵈ) = toDual ∘ WithTop.ofDual :=\n  funext fun _ => rfl\n\n"}
{"name":"WithTop.coeOrderHom_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_6\ninst✝ : Preorder α\na✝ : α\n⊢ Eq (WithTop.coeOrderHom a✝) ↑a✝","decl":"/-- The coercion `α → WithTop α` bundled as monotone map. -/\n@[simps]\ndef coeOrderHom {α : Type*} [Preorder α] : α ↪o WithTop α where\n  toFun := (↑)\n  inj' := WithTop.coe_injective\n  map_rel_iff' := WithTop.coe_le_coe\n\n"}
{"name":"OrderIso.withTopCongr_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\ne : OrderIso α β\na✝ : Option α\n⊢ Eq (e.withTopCongr a✝) (Option.map (⇑e) a✝)","decl":"/-- A version of `Equiv.optionCongr` for `WithTop`. -/\n@[simps! apply]\ndef withTopCongr (e : α ≃o β) : WithTop α ≃o WithTop β :=\n  { e.toOrderEmbedding.withTopMap with\n    toEquiv := e.toEquiv.optionCongr }\n\n"}
{"name":"OrderIso.withTopCongr_refl","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\n⊢ Eq (OrderIso.refl α).withTopCongr (OrderIso.refl (WithTop α))","decl":"@[simp]\ntheorem withTopCongr_refl : (OrderIso.refl α).withTopCongr = OrderIso.refl _ :=\n  RelIso.toEquiv_injective Equiv.optionCongr_refl\n\n"}
{"name":"OrderIso.withTopCongr_symm","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\ne : OrderIso α β\n⊢ Eq e.withTopCongr.symm e.symm.withTopCongr","decl":"@[simp]\ntheorem withTopCongr_symm (e : α ≃o β) : e.withTopCongr.symm = e.symm.withTopCongr :=\n  RelIso.toEquiv_injective e.toEquiv.optionCongr_symm\n\n"}
{"name":"OrderIso.withTopCongr_trans","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : PartialOrder α\ninst✝¹ : PartialOrder β\ninst✝ : PartialOrder γ\ne₁ : OrderIso α β\ne₂ : OrderIso β γ\n⊢ Eq (e₁.withTopCongr.trans e₂.withTopCongr) (e₁.trans e₂).withTopCongr","decl":"@[simp]\ntheorem withTopCongr_trans (e₁ : α ≃o β) (e₂ : β ≃o γ) :\n    e₁.withTopCongr.trans e₂.withTopCongr = (e₁.trans e₂).withTopCongr :=\n  RelIso.toEquiv_injective <| e₁.toEquiv.optionCongr_trans e₂.toEquiv\n\n"}
{"name":"OrderIso.withBotCongr_apply","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\ne : OrderIso α β\na✝ : Option α\n⊢ Eq (e.withBotCongr a✝) (Option.map (⇑e) a✝)","decl":"/-- A version of `Equiv.optionCongr` for `WithBot`. -/\n@[simps! apply]\ndef withBotCongr (e : α ≃o β) : WithBot α ≃o WithBot β :=\n  { e.toOrderEmbedding.withBotMap with toEquiv := e.toEquiv.optionCongr }\n\n"}
{"name":"OrderIso.withBotCongr_refl","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\n⊢ Eq (OrderIso.refl α).withBotCongr (OrderIso.refl (WithBot α))","decl":"@[simp]\ntheorem withBotCongr_refl : (OrderIso.refl α).withBotCongr = OrderIso.refl _ :=\n  RelIso.toEquiv_injective Equiv.optionCongr_refl\n\n"}
{"name":"OrderIso.withBotCongr_symm","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\ne : OrderIso α β\n⊢ Eq e.withBotCongr.symm e.symm.withBotCongr","decl":"@[simp]\ntheorem withBotCongr_symm (e : α ≃o β) : e.withBotCongr.symm = e.symm.withBotCongr :=\n  RelIso.toEquiv_injective e.toEquiv.optionCongr_symm\n\n"}
{"name":"OrderIso.withBotCongr_trans","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : PartialOrder α\ninst✝¹ : PartialOrder β\ninst✝ : PartialOrder γ\ne₁ : OrderIso α β\ne₂ : OrderIso β γ\n⊢ Eq (e₁.withBotCongr.trans e₂.withBotCongr) (e₁.trans e₂).withBotCongr","decl":"@[simp]\ntheorem withBotCongr_trans (e₁ : α ≃o β) (e₂ : β ≃o γ) :\n    e₁.withBotCongr.trans e₂.withBotCongr = (e₁.trans e₂).withBotCongr :=\n  RelIso.toEquiv_injective <| e₁.toEquiv.optionCongr_trans e₂.toEquiv\n\n"}
{"name":"OrderIso.isCompl","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Lattice α\ninst✝² : Lattice β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\nf : OrderIso α β\nx y : α\nh : IsCompl x y\n⊢ IsCompl (f x) (f y)","decl":"theorem OrderIso.isCompl {x y : α} (h : IsCompl x y) : IsCompl (f x) (f y) :=\n  ⟨h.1.map_orderIso _, h.2.map_orderIso _⟩\n\n"}
{"name":"OrderIso.isCompl_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Lattice α\ninst✝² : Lattice β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\nf : OrderIso α β\nx y : α\n⊢ Iff (IsCompl x y) (IsCompl (f x) (f y))","decl":"theorem OrderIso.isCompl_iff {x y : α} : IsCompl x y ↔ IsCompl (f x) (f y) :=\n  ⟨f.isCompl, fun h => f.symm_apply_apply x ▸ f.symm_apply_apply y ▸ f.symm.isCompl h⟩\n\n"}
{"name":"OrderIso.complementedLattice","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : Lattice α\ninst✝³ : Lattice β\ninst✝² : BoundedOrder α\ninst✝¹ : BoundedOrder β\ninst✝ : ComplementedLattice α\nf : OrderIso α β\n⊢ ComplementedLattice β","decl":"theorem OrderIso.complementedLattice [ComplementedLattice α] (f : α ≃o β) : ComplementedLattice β :=\n  ⟨fun x => by\n    obtain ⟨y, hy⟩ := exists_isCompl (f.symm x)\n    rw [← f.symm_apply_apply y] at hy\n    exact ⟨f y, f.symm.isCompl_iff.2 hy⟩⟩\n\n"}
{"name":"OrderIso.complementedLattice_iff","module":"Mathlib.Order.Hom.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Lattice α\ninst✝² : Lattice β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\nf : OrderIso α β\n⊢ Iff (ComplementedLattice α) (ComplementedLattice β)","decl":"theorem OrderIso.complementedLattice_iff (f : α ≃o β) :\n    ComplementedLattice α ↔ ComplementedLattice β :=\n  ⟨by intro; exact f.complementedLattice,\n   by intro; exact f.symm.complementedLattice⟩\n\n"}
{"name":"OrderIsoClass.toOrderIsoClassOrderDual","module":"Mathlib.Order.Hom.Basic","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : LE α\ninst✝² : LE β\ninst✝¹ : EquivLike F α β\ninst✝ : OrderIsoClass F α β\n⊢ OrderIsoClass F (OrderDual α) (OrderDual β)","decl":"instance (priority := 90) OrderIsoClass.toOrderIsoClassOrderDual [LE α] [LE β]\n    [EquivLike F α β] [OrderIsoClass F α β] : OrderIsoClass F αᵒᵈ βᵒᵈ where\n  map_le_map_iff f := map_le_map_iff f\n\n"}
{"name":"denselyOrdered_iff_of_orderIsoClass","module":"Mathlib.Order.Hom.Basic","initialProofState":"X : Type u_6\nY : Type u_7\nF : Type u_8\ninst✝³ : Preorder X\ninst✝² : Preorder Y\ninst✝¹ : EquivLike F X Y\ninst✝ : OrderIsoClass F X Y\nf : F\n⊢ Iff (DenselyOrdered X) (DenselyOrdered Y)","decl":"lemma denselyOrdered_iff_of_orderIsoClass {X Y F : Type*} [Preorder X] [Preorder Y]\n    [EquivLike F X Y] [OrderIsoClass F X Y] (f : F) :\n    DenselyOrdered X ↔ DenselyOrdered Y := by\n  constructor\n  · intro H\n    refine ⟨fun a b h ↦ ?_⟩\n    obtain ⟨c, hc⟩ := exists_between ((map_inv_lt_map_inv_iff f).mpr h)\n    exact ⟨f c, by simpa using hc⟩\n  · intro H\n    refine ⟨fun a b h ↦ ?_⟩\n    obtain ⟨c, hc⟩ := exists_between ((map_lt_map_iff f).mpr h)\n    exact ⟨EquivLike.inv f c, by simpa using hc⟩\n\n"}
