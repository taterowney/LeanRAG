{"name":"Polynomial.evalEval_C","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\np : Polynomial R\n⊢ Eq (Polynomial.evalEval x y (Polynomial.C p)) (Polynomial.eval x p)","decl":"lemma evalEval_C (x y : R) (p : R[X]) : (C p).evalEval x y = p.eval x := by\n  rw [evalEval, eval_C]\n\n"}
{"name":"Polynomial.evalEval_CC","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y p : R\n⊢ Eq (Polynomial.evalEval x y (Polynomial.CC p)) p","decl":"@[simp]\nlemma evalEval_CC (x y : R) (p : R) : (CC p).evalEval x y = p := by\n  rw [evalEval_C, eval_C]\n\n"}
{"name":"Polynomial.evalEval_zero","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\n⊢ Eq (Polynomial.evalEval x y 0) 0","decl":"@[simp]\nlemma evalEval_zero (x y : R) : (0 : R[X][Y]).evalEval x y = 0 := by\n  simp only [evalEval, eval_zero]\n\n"}
{"name":"Polynomial.evalEval_one","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\n⊢ Eq (Polynomial.evalEval x y 1) 1","decl":"@[simp]\nlemma evalEval_one (x y : R) : (1 : R[X][Y]).evalEval x y = 1 := by\n  simp only [evalEval, eval_one]\n\n"}
{"name":"Polynomial.evalEval_natCast","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\nn : Nat\n⊢ Eq (Polynomial.evalEval x y ↑n) ↑n","decl":"@[simp]\nlemma evalEval_natCast (x y : R) (n : ℕ) : (n : R[X][Y]).evalEval x y = n := by\n  simp only [evalEval, eval_natCast]\n\n"}
{"name":"Polynomial.evalEval_X","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\n⊢ Eq (Polynomial.evalEval x y Polynomial.X) y","decl":"@[simp]\nlemma evalEval_X (x y : R) : X.evalEval x y = y := by\n  rw [evalEval, eval_X, eval_C]\n\n"}
{"name":"Polynomial.evalEval_add","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\np q : Polynomial (Polynomial R)\n⊢ Eq (Polynomial.evalEval x y (HAdd.hAdd p q)) (HAdd.hAdd (Polynomial.evalEval x y p) (Polynomial.evalEval x y q))","decl":"@[simp]\nlemma evalEval_add (x y : R) (p q : R[X][Y]) :\n    (p + q).evalEval x y = p.evalEval x y + q.evalEval x y := by\n  simp only [evalEval, eval_add]\n\n"}
{"name":"Polynomial.evalEval_sum","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\np : Polynomial R\nf : Nat → R → Polynomial (Polynomial R)\n⊢ Eq (Polynomial.evalEval x y (p.sum f)) (p.sum fun n a => Polynomial.evalEval x y (f n a))","decl":"lemma evalEval_sum (x y : R) (p : R[X]) (f : ℕ → R → R[X][Y]) :\n    (p.sum f).evalEval x y = p.sum fun n a => (f n a).evalEval x y := by\n  simp only [evalEval, eval, eval₂_sum]\n\n"}
{"name":"Polynomial.evalEval_finset_sum","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nι : Type u_3\ns : Finset ι\nx y : R\nf : ι → Polynomial (Polynomial R)\n⊢ Eq (Polynomial.evalEval x y (s.sum fun i => f i)) (s.sum fun i => Polynomial.evalEval x y (f i))","decl":"lemma evalEval_finset_sum {ι : Type*} (s : Finset ι) (x y : R) (f : ι → R[X][Y]) :\n    (∑ i ∈ s, f i).evalEval x y = ∑ i ∈ s, (f i).evalEval x y := by\n  simp only [evalEval, eval_finset_sum]\n\n"}
{"name":"Polynomial.evalEval_smul","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S R\ninst✝ : IsScalarTower S R R\nx y : R\ns : S\np : Polynomial (Polynomial R)\n⊢ Eq (Polynomial.evalEval x y (HSMul.hSMul s p)) (HSMul.hSMul s (Polynomial.evalEval x y p))","decl":"@[simp]\nlemma evalEval_smul [Monoid S] [DistribMulAction S R] [IsScalarTower S R R] (x y : R) (s : S)\n    (p : R[X][Y]) : (s • p).evalEval x y = s • p.evalEval x y := by\n  simp only [evalEval, eval_smul]\n\n"}
{"name":"Polynomial.evalEval_surjective","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nx y : R\n⊢ Function.Surjective (Polynomial.evalEval x y)","decl":"lemma evalEval_surjective (x y : R) : Function.Surjective <| evalEval x y :=\n  fun y => ⟨CC y, evalEval_CC ..⟩\n\n"}
{"name":"Polynomial.evalEval_neg","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : Ring R\nx y : R\np : Polynomial (Polynomial R)\n⊢ Eq (Polynomial.evalEval x y (Neg.neg p)) (Neg.neg (Polynomial.evalEval x y p))","decl":"@[simp]\nlemma evalEval_neg (x y : R) (p : R[X][Y]) : (-p).evalEval x y = -p.evalEval x y := by\n  simp only [evalEval, eval_neg]\n\n"}
{"name":"Polynomial.evalEval_sub","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : Ring R\nx y : R\np q : Polynomial (Polynomial R)\n⊢ Eq (Polynomial.evalEval x y (HSub.hSub p q)) (HSub.hSub (Polynomial.evalEval x y p) (Polynomial.evalEval x y q))","decl":"@[simp]\nlemma evalEval_sub (x y : R) (p q : R[X][Y]) :\n    (p - q).evalEval x y = p.evalEval x y - q.evalEval x y := by\n  simp only [evalEval, eval_sub]\n\n"}
{"name":"Polynomial.evalEval_intCast","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : Ring R\nx y : R\nn : Int\n⊢ Eq (Polynomial.evalEval x y ↑n) ↑n","decl":"@[simp]\nlemma evalEval_intCast (x y : R) (n : ℤ) : (n : R[X][Y]).evalEval x y = n := by\n  simp only [evalEval, eval_intCast]\n\n"}
{"name":"Polynomial.evalEval_mul","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx y : R\np q : Polynomial (Polynomial R)\n⊢ Eq (Polynomial.evalEval x y (HMul.hMul p q)) (HMul.hMul (Polynomial.evalEval x y p) (Polynomial.evalEval x y q))","decl":"@[simp]\nlemma evalEval_mul (x y : R) (p q : R[X][Y]) :\n    (p * q).evalEval x y = p.evalEval x y * q.evalEval x y := by\n  simp only [evalEval, eval_mul]\n\n"}
{"name":"Polynomial.evalEval_prod","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nι : Type u_3\ns : Finset ι\nx y : R\np : ι → Polynomial (Polynomial R)\n⊢ Eq (Polynomial.evalEval x y (s.prod fun j => p j)) (s.prod fun j => Polynomial.evalEval x y (p j))","decl":"lemma evalEval_prod {ι : Type*} (s : Finset ι) (x y : R) (p : ι → R[X][Y]) :\n    (∏ j ∈ s, p j).evalEval x y = ∏ j ∈ s, (p j).evalEval x y := by\n  simp only [evalEval, eval_prod]\n\n"}
{"name":"Polynomial.evalEval_list_prod","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx y : R\nl : List (Polynomial (Polynomial R))\n⊢ Eq (Polynomial.evalEval x y l.prod) (List.map (Polynomial.evalEval x y) l).prod","decl":"lemma evalEval_list_prod (x y : R) (l : List R[X][Y]) :\n    l.prod.evalEval x y = (l.map <| evalEval x y).prod := by\n  simpa only [evalEval, eval_list_prod, List.map_map] using by rfl\n\n"}
{"name":"Polynomial.evalEval_multiset_prod","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx y : R\nl : Multiset (Polynomial (Polynomial R))\n⊢ Eq (Polynomial.evalEval x y l.prod) (Multiset.map (Polynomial.evalEval x y) l).prod","decl":"lemma evalEval_multiset_prod (x y : R) (l : Multiset R[X][Y]) :\n    l.prod.evalEval x y = (l.map <| evalEval x y).prod := by\n  simpa only [evalEval, eval_multiset_prod, Multiset.map_map] using by rfl\n\n"}
{"name":"Polynomial.evalEval_pow","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx y : R\np : Polynomial (Polynomial R)\nn : Nat\n⊢ Eq (Polynomial.evalEval x y (HPow.hPow p n)) (HPow.hPow (Polynomial.evalEval x y p) n)","decl":"@[simp]\nlemma evalEval_pow (x y : R) (p : R[X][Y]) (n : ℕ) : (p ^ n).evalEval x y = p.evalEval x y ^ n := by\n  simp only [evalEval, eval_pow]\n\n"}
{"name":"Polynomial.evalEval_dvd","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx y : R\np q : Polynomial (Polynomial R)\na✝ : Dvd.dvd p q\n⊢ Dvd.dvd (Polynomial.evalEval x y p) (Polynomial.evalEval x y q)","decl":"lemma evalEval_dvd (x y : R) {p q : R[X][Y]} : p ∣ q → p.evalEval x y ∣ q.evalEval x y :=\n  eval_dvd ∘ eval_dvd\n\n"}
{"name":"Polynomial.coe_algebraMap_eq_CC","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (⇑(algebraMap R (Polynomial (Polynomial R)))) Polynomial.CC","decl":"lemma coe_algebraMap_eq_CC : algebraMap R R[X][Y] = CC (R := R) := rfl\n\n"}
{"name":"Polynomial.evalEvalRingHom_apply","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx y : R\na✝ : Polynomial (Polynomial R)\n⊢ Eq ((Polynomial.evalEvalRingHom x y) a✝) (Polynomial.eval x (Polynomial.eval (Polynomial.C y) a✝))","decl":"/-- `evalEval x y` as a ring homomorphism. -/\n@[simps!] abbrev evalEvalRingHom (x y : R) : R[X][Y] →+* R :=\n  (evalRingHom x).comp (evalRingHom <| C y)\n\n"}
{"name":"Polynomial.coe_evalEvalRingHom","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx y : R\n⊢ Eq (⇑(Polynomial.evalEvalRingHom x y)) (Polynomial.evalEval x y)","decl":"lemma coe_evalEvalRingHom (x y : R) : evalEvalRingHom x y = evalEval x y := rfl\n\n"}
{"name":"Polynomial.evalEvalRingHom_eq","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx : R\n⊢ Eq (Polynomial.evalEvalRingHom x) (Polynomial.eval₂RingHom (Polynomial.evalRingHom x))","decl":"lemma evalEvalRingHom_eq (x : R) : evalEvalRingHom x = eval₂RingHom (evalRingHom x) := by\n  ext <;> simp\n\n"}
{"name":"Polynomial.eval₂_evalRingHom","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx : R\n⊢ Eq (Polynomial.eval₂ (Polynomial.evalRingHom x)) (Polynomial.evalEval x)","decl":"lemma eval₂_evalRingHom (x : R) : eval₂ (evalRingHom x) = evalEval x := by\n  ext1; rw [← coe_evalEvalRingHom, evalEvalRingHom_eq, coe_eval₂RingHom]\n\n"}
{"name":"Polynomial.map_evalRingHom_eval","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx y : R\np : Polynomial (Polynomial R)\n⊢ Eq (Polynomial.eval y (Polynomial.map (Polynomial.evalRingHom x) p)) (Polynomial.evalEval x y p)","decl":"lemma map_evalRingHom_eval (x y : R) (p : R[X][Y]) :\n    (p.map <| evalRingHom x).eval y = p.evalEval x y := by\n  rw [eval_map, eval₂_evalRingHom]\n\n"}
{"name":"Polynomial.map_mapRingHom_eval_map","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial (Polynomial R)\nq : Polynomial R\n⊢ Eq (Polynomial.eval (Polynomial.map f q) (Polynomial.map (Polynomial.mapRingHom f) p)) (Polynomial.map f (Polynomial.eval q p))","decl":"lemma map_mapRingHom_eval_map : (p.map <| mapRingHom f).eval (q.map f) = (p.eval q).map f := by\n  rw [eval_map, ← coe_mapRingHom, eval₂_hom]\n\n"}
{"name":"Polynomial.map_mapRingHom_eval_map_eval","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial (Polynomial R)\nq : Polynomial R\nr : R\n⊢ Eq (Polynomial.eval (f r) (Polynomial.eval (Polynomial.map f q) (Polynomial.map (Polynomial.mapRingHom f) p))) (f (Polynomial.eval r (Polynomial.eval q p)))","decl":"lemma map_mapRingHom_eval_map_eval (r : R) :\n    ((p.map <| mapRingHom f).eval <| q.map f).eval (f r) = f ((p.eval q).eval r) := by\n  rw [map_mapRingHom_eval_map, eval_map, eval₂_hom]\n\n"}
{"name":"Polynomial.map_mapRingHom_evalEval","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial (Polynomial R)\nx y : R\n⊢ Eq (Polynomial.evalEval (f x) (f y) (Polynomial.map (Polynomial.mapRingHom f) p)) (f (Polynomial.evalEval x y p))","decl":"lemma map_mapRingHom_evalEval (x y : R) :\n    (p.map <| mapRingHom f).evalEval (f x) (f y) = f (p.evalEval x y) := by\n  rw [evalEval, ← map_mapRingHom_eval_map_eval, map_C]\n\n"}
{"name":"Polynomial.eval₂RingHom_eval₂RingHom","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nx y : S\n⊢ Eq (Polynomial.eval₂RingHom (Polynomial.eval₂RingHom f x) y) ((Polynomial.evalEvalRingHom x y).comp (Polynomial.mapRingHom (Polynomial.mapRingHom f)))","decl":"/-- Two equivalent ways to express the evaluation of a bivariate polynomial over `R`\nat a point in the affine plane over an `R`-algebra `S`. -/\nlemma eval₂RingHom_eval₂RingHom (f : R →+* S) (x y : S) :\n    eval₂RingHom (eval₂RingHom f x) y =\n      (evalEvalRingHom x y).comp (mapRingHom <| mapRingHom f) := by\n  ext <;> simp\n\n"}
{"name":"Polynomial.eval₂_eval₂RingHom_apply","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nx y : S\np : Polynomial (Polynomial R)\n⊢ Eq (Polynomial.eval₂ (Polynomial.eval₂RingHom f x) y p) (Polynomial.evalEval x y (Polynomial.map (Polynomial.mapRingHom f) p))","decl":"lemma eval₂_eval₂RingHom_apply (f : R →+* S) (x y : S) (p : R[X][Y]) :\n    eval₂ (eval₂RingHom f x) y p = (p.map <| mapRingHom f).evalEval x y :=\n  congr($(eval₂RingHom_eval₂RingHom f x y) p)\n\n"}
{"name":"Polynomial.eval_C_X_comp_eval₂_map_C_X","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq ((Polynomial.evalRingHom (Polynomial.C Polynomial.X)).comp (Polynomial.eval₂RingHom (Polynomial.mapRingHom (algebraMap R (Polynomial (Polynomial R)))) (Polynomial.C Polynomial.X))) (RingHom.id (Polynomial (Polynomial R)))","decl":"lemma eval_C_X_comp_eval₂_map_C_X :\n    (evalRingHom (C X : R[X][Y])).comp (eval₂RingHom (mapRingHom <| algebraMap R R[X][Y]) (C Y)) =\n      .id _ := by\n  ext <;> simp\n\n"}
{"name":"Polynomial.eval_C_X_eval₂_map_C_X","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Polynomial (Polynomial R)\n⊢ Eq (Polynomial.eval (Polynomial.C Polynomial.X) (Polynomial.eval₂ (Polynomial.mapRingHom (algebraMap R (Polynomial (Polynomial R)))) (Polynomial.C Polynomial.X) p)) p","decl":"/-- Viewing `R[X,Y,X']` as an `R[X']`-algebra, a polynomial `p : R[X',Y']` can be evaluated at\n`Y : R[X,Y,X']` (substitution of `Y'` by `Y`), obtaining another polynomial in `R[X,Y,X']`.\nWhen this polynomial is then evaluated at `X' = X`, the original polynomial `p` is recovered. -/\nlemma eval_C_X_eval₂_map_C_X {p : R[X][Y]} :\n    eval (C X) (eval₂ (mapRingHom <| algebraMap R R[X][Y]) (C Y) p) = p :=\n  congr($eval_C_X_comp_eval₂_map_C_X p)\n\n"}
{"name":"AdjoinRoot.evalEval_apply","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\np : Polynomial (Polynomial R)\nh : Eq (Polynomial.evalEval x y p) 0\na✝ : HasQuotient.Quotient (Polynomial (Polynomial R)) (Submodule.toAddSubgroup (Ideal.span (Singleton.singleton p)))\n⊢ Eq ((AdjoinRoot.evalEval h) a✝) ((QuotientAddGroup.lift (Submodule.toAddSubgroup (Ideal.span (Singleton.singleton p))) ↑(Polynomial.eval₂RingHom (Polynomial.evalRingHom x) y) ⋯) a✝)","decl":"/-- If the evaluation (`evalEval`) of a bivariate polynomial `p : R[X][Y]` at a point (x,y)\nis zero, then `Polynomial.evalEval x y` factors through `AdjoinRoot.evalEval`, a ring homomorphism\nfrom `AdjoinRoot p` to `R`. -/\n@[simps!] def evalEval : AdjoinRoot p →+* R :=\n  lift (evalRingHom x) y <| eval₂_evalRingHom x ▸ h\n\n"}
{"name":"AdjoinRoot.evalEval_mk","module":"Mathlib.Algebra.Polynomial.Bivariate","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\np : Polynomial (Polynomial R)\nh : Eq (Polynomial.evalEval x y p) 0\ng : Polynomial (Polynomial R)\n⊢ Eq ((AdjoinRoot.evalEval h) ((AdjoinRoot.mk p) g)) (Polynomial.evalEval x y g)","decl":"lemma evalEval_mk (g : R[X][Y]) : evalEval h (mk p g) = g.evalEval x y := by\n  rw [evalEval, lift_mk, eval₂_evalRingHom]\n\n"}
