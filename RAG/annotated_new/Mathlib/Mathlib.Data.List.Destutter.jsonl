{"name":"List.destutter'_nil","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝ : DecidableRel R\na : α\n⊢ Eq (List.destutter' R a List.nil) (List.cons a List.nil)","decl":"@[simp]\ntheorem destutter'_nil : destutter' R a [] = [a] :=\n  rfl\n\n"}
{"name":"List.destutter'_cons","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\nR : α → α → Prop\ninst✝ : DecidableRel R\na b : α\n⊢ Eq (List.destutter' R a (List.cons b l)) (ite (R a b) (List.cons a (List.destutter' R b l)) (List.destutter' R a l))","decl":"theorem destutter'_cons :\n    (b :: l).destutter' R a = if R a b then a :: destutter' R b l else destutter' R a l :=\n  rfl\n\n"}
{"name":"List.destutter'_cons_pos","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\nR : α → α → Prop\ninst✝ : DecidableRel R\na b : α\nh : R b a\n⊢ Eq (List.destutter' R b (List.cons a l)) (List.cons b (List.destutter' R a l))","decl":"@[simp]\ntheorem destutter'_cons_pos (h : R b a) : (a :: l).destutter' R b = b :: l.destutter' R a := by\n  rw [destutter', if_pos h]\n\n"}
{"name":"List.destutter'_cons_neg","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\nR : α → α → Prop\ninst✝ : DecidableRel R\na b : α\nh : Not (R b a)\n⊢ Eq (List.destutter' R b (List.cons a l)) (List.destutter' R b l)","decl":"@[simp]\ntheorem destutter'_cons_neg (h : ¬R b a) : (a :: l).destutter' R b = l.destutter' R b := by\n  rw [destutter', if_neg h]\n\n"}
{"name":"List.destutter'_singleton","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝ : DecidableRel R\na b : α\n⊢ Eq (List.destutter' R a (List.cons b List.nil)) (ite (R a b) (List.cons a (List.cons b List.nil)) (List.cons a List.nil))","decl":"@[simp]\ntheorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a] := by\n  split_ifs with h <;> simp! [h]\n\n"}
{"name":"List.destutter'_sublist","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\nR : α → α → Prop\ninst✝ : DecidableRel R\na : α\n⊢ (List.destutter' R a l).Sublist (List.cons a l)","decl":"theorem destutter'_sublist (a) : l.destutter' R a <+ a :: l := by\n  induction' l with b l hl generalizing a\n  · simp\n  rw [destutter']\n  split_ifs\n  · exact Sublist.cons₂ a (hl b)\n  · exact (hl a).trans ((l.sublist_cons_self b).cons_cons a)\n\n"}
{"name":"List.mem_destutter'","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\nR : α → α → Prop\ninst✝ : DecidableRel R\na : α\n⊢ Membership.mem (List.destutter' R a l) a","decl":"theorem mem_destutter' (a) : a ∈ l.destutter' R a := by\n  induction' l with b l hl\n  · simp\n  rw [destutter']\n  split_ifs\n  · simp\n  · assumption\n\n"}
{"name":"List.destutter'_is_chain","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝ : DecidableRel R\nl : List α\na b : α\na✝ : R a b\n⊢ List.Chain R a (List.destutter' R b l)","decl":"theorem destutter'_is_chain : ∀ l : List α, ∀ {a b}, R a b → (l.destutter' R b).Chain R a\n  | [], _, _, h => chain_singleton.mpr h\n  | c :: l, a, b, h => by\n    rw [destutter']\n    split_ifs with hbc\n    · rw [chain_cons]\n      exact ⟨h, destutter'_is_chain l hbc⟩\n    · exact destutter'_is_chain l h\n\n"}
{"name":"List.destutter'_is_chain'","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\nR : α → α → Prop\ninst✝ : DecidableRel R\na : α\n⊢ List.Chain' R (List.destutter' R a l)","decl":"theorem destutter'_is_chain' (a) : (l.destutter' R a).Chain' R := by\n  induction' l with b l hl generalizing a\n  · simp\n  rw [destutter']\n  split_ifs with h\n  · exact destutter'_is_chain R l h\n  · exact hl a\n\n"}
{"name":"List.destutter'_of_chain","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\nR : α → α → Prop\ninst✝ : DecidableRel R\na : α\nh : List.Chain R a l\n⊢ Eq (List.destutter' R a l) (List.cons a l)","decl":"theorem destutter'_of_chain (h : l.Chain R a) : l.destutter' R a = a :: l := by\n  induction' l with b l hb generalizing a\n  · simp\n  obtain ⟨h, hc⟩ := chain_cons.mp h\n  rw [l.destutter'_cons_pos h, hb hc]\n\n"}
{"name":"List.destutter'_eq_self_iff","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\nR : α → α → Prop\ninst✝ : DecidableRel R\na : α\n⊢ Iff (Eq (List.destutter' R a l) (List.cons a l)) (List.Chain R a l)","decl":"@[simp]\ntheorem destutter'_eq_self_iff (a) : l.destutter' R a = a :: l ↔ l.Chain R a :=\n  ⟨fun h => by\n    suffices Chain' R (a::l) by\n      assumption\n    rw [← h]\n    exact l.destutter'_is_chain' R a, destutter'_of_chain _ _⟩\n\n"}
{"name":"List.destutter'_ne_nil","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\nR : α → α → Prop\ninst✝ : DecidableRel R\na : α\n⊢ Ne (List.destutter' R a l) List.nil","decl":"theorem destutter'_ne_nil : l.destutter' R a ≠ [] :=\n  ne_nil_of_mem <| l.mem_destutter' R a\n\n"}
{"name":"List.destutter_nil","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝ : DecidableRel R\n⊢ Eq (List.destutter R List.nil) List.nil","decl":"@[simp]\ntheorem destutter_nil : ([] : List α).destutter R = [] :=\n  rfl\n\n"}
{"name":"List.destutter_cons'","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\nR : α → α → Prop\ninst✝ : DecidableRel R\na : α\n⊢ Eq (List.destutter R (List.cons a l)) (List.destutter' R a l)","decl":"theorem destutter_cons' : (a :: l).destutter R = destutter' R a l :=\n  rfl\n\n"}
{"name":"List.destutter_cons_cons","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\nR : α → α → Prop\ninst✝ : DecidableRel R\na b : α\n⊢ Eq (List.destutter R (List.cons a (List.cons b l))) (ite (R a b) (List.cons a (List.destutter' R b l)) (List.destutter' R a l))","decl":"theorem destutter_cons_cons :\n    (a :: b :: l).destutter R = if R a b then a :: destutter' R b l else destutter' R a l :=\n  rfl\n\n"}
{"name":"List.destutter_singleton","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝ : DecidableRel R\na : α\n⊢ Eq (List.destutter R (List.cons a List.nil)) (List.cons a List.nil)","decl":"@[simp]\ntheorem destutter_singleton : destutter R [a] = [a] :=\n  rfl\n\n"}
{"name":"List.destutter_pair","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝ : DecidableRel R\na b : α\n⊢ Eq (List.destutter R (List.cons a (List.cons b List.nil))) (ite (R a b) (List.cons a (List.cons b List.nil)) (List.cons a List.nil))","decl":"@[simp]\ntheorem destutter_pair : destutter R [a, b] = if R a b then [a, b] else [a] :=\n  destutter_cons_cons _ R\n\n"}
{"name":"List.destutter_sublist","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝ : DecidableRel R\nl : List α\n⊢ (List.destutter R l).Sublist l","decl":"theorem destutter_sublist : ∀ l : List α, l.destutter R <+ l\n  | [] => Sublist.slnil\n  | h :: l => l.destutter'_sublist R h\n\n"}
{"name":"List.destutter_is_chain'","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝ : DecidableRel R\nl : List α\n⊢ List.Chain' R (List.destutter R l)","decl":"theorem destutter_is_chain' : ∀ l : List α, (l.destutter R).Chain' R\n  | [] => List.chain'_nil\n  | h :: l => l.destutter'_is_chain' R h\n\n"}
{"name":"List.destutter_of_chain'","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝ : DecidableRel R\nl : List α\na✝ : List.Chain' R l\n⊢ Eq (List.destutter R l) l","decl":"theorem destutter_of_chain' : ∀ l : List α, l.Chain' R → l.destutter R = l\n  | [], _ => rfl\n  | _ :: l, h => l.destutter'_of_chain _ h\n\n"}
{"name":"List.destutter_eq_self_iff","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝ : DecidableRel R\nl : List α\n⊢ Iff (Eq (List.destutter R l) l) (List.Chain' R l)","decl":"@[simp]\ntheorem destutter_eq_self_iff : ∀ l : List α, l.destutter R = l ↔ l.Chain' R\n  | [] => by simp\n  | a :: l => l.destutter'_eq_self_iff R a\n\n"}
{"name":"List.destutter_idem","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\nR : α → α → Prop\ninst✝ : DecidableRel R\n⊢ Eq (List.destutter R (List.destutter R l)) (List.destutter R l)","decl":"theorem destutter_idem : (l.destutter R).destutter R = l.destutter R :=\n  destutter_of_chain' R _ <| l.destutter_is_chain' R\n\n"}
{"name":"List.destutter_eq_nil","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝ : DecidableRel R\nl : List α\n⊢ Iff (Eq (List.destutter R l) List.nil) (Eq l List.nil)","decl":"@[simp]\ntheorem destutter_eq_nil : ∀ {l : List α}, destutter R l = [] ↔ l = []\n  | [] => Iff.rfl\n  | _ :: l => ⟨fun h => absurd h <| l.destutter'_ne_nil R, fun h => nomatch h⟩\n\n"}
{"name":"List.map_destutter","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → α → Prop\ninst✝¹ : DecidableRel R\nR₂ : β → β → Prop\ninst✝ : DecidableRel R₂\nf : α → β\nl : List α\na✝ : ∀ (a : α), Membership.mem l a → ∀ (b : α), Membership.mem l b → Iff (R a b) (R₂ (f a) (f b))\n⊢ Eq (List.map f (List.destutter R l)) (List.destutter R₂ (List.map f l))","decl":"/-- For a relation-preserving map, `destutter` commutes with `map`. -/\ntheorem map_destutter {f : α → β} : ∀ {l : List α}, (∀ a ∈ l, ∀ b ∈ l, R a b ↔ R₂ (f a) (f b)) →\n    (l.destutter R).map f = (l.map f).destutter R₂\n  | [], hl => by simp\n  | [a], hl => by simp\n  | a :: b :: l, hl => by\n    have := hl a (by simp) b (by simp)\n    simp_rw [map_cons, destutter_cons_cons, ← this]\n    by_cases hr : R a b <;>\n      simp [hr, ← destutter_cons', map_destutter fun c hc d hd ↦ hl _ (cons_subset_cons _\n        (subset_cons_self _ _) hc) _ (cons_subset_cons _ (subset_cons_self _ _) hd),\n        map_destutter fun c hc d hd ↦ hl _ (subset_cons_self _ _ hc) _ (subset_cons_self _ _ hd)]\n\n"}
{"name":"List.map_destutter_ne","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List α\nf : α → β\nh : Function.Injective f\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\n⊢ Eq (List.map f (List.destutter (fun x1 x2 => Ne x1 x2) l)) (List.destutter (fun x1 x2 => Ne x1 x2) (List.map f l))","decl":"/-- For a injective function `f`, `destutter' (·≠·)` commutes with `map f`. -/\ntheorem map_destutter_ne {f : α → β} (h : Injective f) [DecidableEq α] [DecidableEq β] :\n    (l.destutter (·≠·)).map f = (l.map f).destutter (·≠·) :=\n  map_destutter fun _ _ _ _ ↦ h.ne_iff.symm\n\n"}
{"name":"List.length_destutter'_cotrans_ge","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝ : DecidableRel R\nb : α\ni : IsTrans α (HasCompl.compl R)\na : α\nl : List α\na✝ : Not (R b a)\n⊢ LE.le (List.destutter' R b l).length (List.destutter' R a l).length","decl":"/-- `destutter'` on a relation like ≠ or <, whose negation is transitive, has length monotone\nunder a `¬R` changing of the first element. -/\ntheorem length_destutter'_cotrans_ge [i : IsTrans α Rᶜ] :\n    ∀ {a} {l : List α}, ¬R b a → (l.destutter' R b).length ≤ (l.destutter' R a).length\n  | a, [], hba => by simp\n  | a, c :: l, hba => by\n    by_cases hbc : R b c\n    case pos =>\n      have hac : ¬Rᶜ a c := (mt (_root_.trans hba)) (not_not.2 hbc)\n      simp_rw [destutter', if_pos (not_not.1 hac), if_pos hbc, length_cons, le_refl]\n    case neg =>\n      simp only [destutter', if_neg hbc]\n      by_cases hac : R a c\n      case pos =>\n        simp only [if_pos hac, length_cons]\n        exact Nat.le_succ_of_le (length_destutter'_cotrans_ge hbc)\n      case neg =>\n        simp only [if_neg hac]\n        exact length_destutter'_cotrans_ge hba\n\n"}
{"name":"List.length_destutter'_congr","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\nR : α → α → Prop\ninst✝¹ : DecidableRel R\na b : α\ninst✝ : IsEquiv α (HasCompl.compl R)\nhab : Not (R a b)\n⊢ Eq (List.destutter' R a l).length (List.destutter' R b l).length","decl":"/-- `List.destutter'` on a relation like `≠`, whose negation is an equivalence, gives the same\nlength if the first elements are not related. -/\ntheorem length_destutter'_congr [IsEquiv α Rᶜ] (hab : ¬R a b) :\n    (l.destutter' R a).length = (l.destutter' R b).length :=\n  (length_destutter'_cotrans_ge hab).antisymm <| length_destutter'_cotrans_ge (symm hab : Rᶜ b a)\n\n"}
{"name":"List.le_length_destutter'_cons","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝¹ : DecidableRel R\na b : α\ninst✝ : IsEquiv α (HasCompl.compl R)\nl : List α\n⊢ LE.le (List.destutter' R b l).length (List.destutter' R a (List.cons b l)).length","decl":"/-- `List.destutter'` on a relation like ≠, whose negation is an equivalence, has length\n    monotonic under List.cons -/\n/-\nTODO: Replace this lemma by the more general version:\ntheorem Sublist.length_destutter'_mono [IsEquiv α Rᶜ] (h : a :: l₁ <+ b :: l₂) :\n    (List.destutter' R a l₁).length ≤ (List.destutter' R b l₂).length\n-/\ntheorem le_length_destutter'_cons [IsEquiv α Rᶜ] :\n    ∀ {l : List α}, (l.destutter' R b).length ≤ ((b :: l).destutter' R a).length\n  | [] => by by_cases hab : (R a b) <;> simp_all [Nat.le_succ]\n  | c :: cs => by\n    by_cases hab : R a b\n    case pos => simp [destutter', if_pos hab, Nat.le_succ]\n    obtain hac | hac : R a c ∨ Rᶜ a c := em _\n    · have hbc : ¬Rᶜ b c := mt (_root_.trans hab) (not_not.2 hac)\n      simp [destutter', if_pos hac, if_pos (not_not.1 hbc), if_neg hab]\n    · have hbc : ¬R b c := trans (symm hab) hac\n      simp only [destutter', if_neg hbc, if_neg hac, if_neg hab]\n      exact (length_destutter'_congr cs hab).ge\n\n"}
{"name":"List.length_destutter_le_length_destutter_cons","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝¹ : DecidableRel R\na : α\ninst✝ : IsEquiv α (HasCompl.compl R)\nl : List α\n⊢ LE.le (List.destutter R l).length (List.destutter R (List.cons a l)).length","decl":"/-- `List.destutter` on a relation like ≠, whose negation is an equivalence, has length\nmonotone under List.cons -/\ntheorem length_destutter_le_length_destutter_cons [IsEquiv α Rᶜ] :\n    ∀ {l : List α}, (l.destutter R).length ≤ ((a :: l).destutter R).length\n  | [] => by simp [destutter]\n  | b :: l => le_length_destutter'_cons\n\n"}
{"name":"List.length_destutter_ne_le_length_destutter_cons","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl : List α\na : α\ninst✝ : DecidableEq α\n⊢ LE.le (List.destutter (fun x1 x2 => Ne x1 x2) l).length (List.destutter (fun x1 x2 => Ne x1 x2) (List.cons a l)).length","decl":"/-- `destutter ≠` has length monotone under `List.cons`. -/\ntheorem length_destutter_ne_le_length_destutter_cons [DecidableEq α] :\n    (l.destutter (· ≠ ·)).length ≤ ((a :: l).destutter (· ≠ ·)).length :=\n  length_destutter_le_length_destutter_cons\n\n"}
{"name":"List.Chain'.length_le_length_destutter","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nR : α → α → Prop\ninst✝¹ : DecidableRel R\ninst✝ : IsEquiv α (HasCompl.compl R)\nl₁ l₂ : List α\na✝¹ : l₁.Sublist l₂\na✝ : List.Chain' R l₁\n⊢ LE.le l₁.length (List.destutter R l₂).length","decl":"/-- `destutter` of relations like `≠`, whose negation is an equivalence relation,\ngives a list of maximal length over any chain.\n\nIn other words, `l.destutter R` is an `R`-chain sublist of `l`, and is at least as long as any other\n`R`-chain sublist. -/\nlemma Chain'.length_le_length_destutter [IsEquiv α Rᶜ] :\n    ∀ {l₁ l₂ : List α}, l₁ <+ l₂ → l₁.Chain' R → l₁.length ≤ (l₂.destutter R).length\n  -- `l₁ := []`, `l₂ := []`\n  | [], [], _, _ => by simp\n  -- `l₁ := l₁`, `l₂ := a :: l₂`\n  | l₁, _, .cons (l₂ := l₂) a hl, hl₁ =>\n    (hl₁.length_le_length_destutter hl).trans length_destutter_le_length_destutter_cons\n  -- `l₁ := [a]`, `l₂ := a :: l₂`\n  | _, _, .cons₂ (l₁ := []) (l₂ := l₁) a hl, hl₁ => by simp [Nat.one_le_iff_ne_zero]\n  -- `l₁ := a :: l₁`, `l₂ := a :: b :: l₂`\n  | _, _, .cons₂ a <| .cons (l₁ := l₁) (l₂ := l₂) b hl, hl₁ => by\n    by_cases hab : R a b\n    · simpa [destutter_cons_cons, hab] using hl₁.tail.length_le_length_destutter (hl.cons _)\n    · simpa [destutter_cons_cons, hab] using hl₁.length_le_length_destutter (hl.cons₂ _)\n  -- `l₁ := a :: b :: l₁`, `l₂ := a :: b :: l₂`\n  | _, _, .cons₂ a <| .cons₂ (l₁ := l₁) (l₂ := l₂) b hl, hl₁ => by\n    simpa [destutter_cons_cons, rel_of_chain_cons hl₁]\n      using hl₁.tail.length_le_length_destutter (hl.cons₂ _)\n\n"}
{"name":"List.Chain'.length_le_length_destutter_ne","module":"Mathlib.Data.List.Destutter","initialProofState":"α : Type u_1\nl₁ l₂ : List α\ninst✝ : DecidableEq α\nhl : l₁.Sublist l₂\nhl₁ : List.Chain' (fun x1 x2 => Ne x1 x2) l₁\n⊢ LE.le l₁.length (List.destutter (fun x1 x2 => Ne x1 x2) l₂).length","decl":"/-- `destutter` of `≠` gives a list of maximal length over any chain.\n\nIn other words, `l.destutter (· ≠ ·)` is a `≠`-chain sublist of `l`, and is at least as long as any\nother `≠`-chain sublist. -/\nlemma Chain'.length_le_length_destutter_ne [DecidableEq α] (hl : l₁ <+ l₂)\n    (hl₁ : l₁.Chain' (· ≠ ·)) : l₁.length ≤ (l₂.destutter (· ≠ ·)).length :=\n  hl₁.length_le_length_destutter hl\n\n"}
