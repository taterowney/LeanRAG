{"name":"CliffordAlgebra.even_toSubmodule","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (Subalgebra.toSubmodule (CliffordAlgebra.even Q)) (CliffordAlgebra.evenOdd Q 0)","decl":"@[simp]\ntheorem even_toSubmodule : Subalgebra.toSubmodule (even Q) = evenOdd Q 0 :=\n  rfl\n\n"}
{"name":"CliffordAlgebra.EvenHom.ext_iff","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx y : CliffordAlgebra.EvenHom Q A\n⊢ Iff (Eq x y) (Eq x.bilin y.bilin)","decl":"/-- The type of bilinear maps which are accepted by `CliffordAlgebra.even.lift`. -/\n@[ext]\nstructure EvenHom : Type max uA uM where\n  bilin : M →ₗ[R] M →ₗ[R] A\n  contract (m : M) : bilin m m = algebraMap R A (Q m)\n  contract_mid (m₁ m₂ m₃ : M) : bilin m₁ m₂ * bilin m₂ m₃ = Q m₂ • bilin m₁ m₃\n\n"}
{"name":"CliffordAlgebra.EvenHom.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\ninst✝² : SizeOf R\ninst✝¹ : SizeOf M\ninst✝ : SizeOf A\nbilin : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M A)\ncontract : ∀ (m : M), Eq ((bilin m) m) ((algebraMap R A) (Q m))\ncontract_mid : ∀ (m₁ m₂ m₃ : M), Eq (HMul.hMul ((bilin m₁) m₂) ((bilin m₂) m₃)) (HSMul.hSMul (Q m₂) ((bilin m₁) m₃))\n⊢ Eq (SizeOf.sizeOf { bilin := bilin, contract := contract, contract_mid := contract_mid }) (HAdd.hAdd 1 (SizeOf.sizeOf bilin))","decl":"/-- The type of bilinear maps which are accepted by `CliffordAlgebra.even.lift`. -/\n@[ext]\nstructure EvenHom : Type max uA uM where\n  bilin : M →ₗ[R] M →ₗ[R] A\n  contract (m : M) : bilin m m = algebraMap R A (Q m)\n  contract_mid (m₁ m₂ m₃ : M) : bilin m₁ m₂ * bilin m₂ m₃ = Q m₂ • bilin m₁ m₃\n\n"}
{"name":"CliffordAlgebra.EvenHom.mk.injEq","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nbilin✝ : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M A)\ncontract✝ : ∀ (m : M), Eq ((bilin✝ m) m) ((algebraMap R A) (Q m))\ncontract_mid✝ : ∀ (m₁ m₂ m₃ : M), Eq (HMul.hMul ((bilin✝ m₁) m₂) ((bilin✝ m₂) m₃)) (HSMul.hSMul (Q m₂) ((bilin✝ m₁) m₃))\nbilin : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M A)\ncontract : ∀ (m : M), Eq ((bilin m) m) ((algebraMap R A) (Q m))\ncontract_mid : ∀ (m₁ m₂ m₃ : M), Eq (HMul.hMul ((bilin m₁) m₂) ((bilin m₂) m₃)) (HSMul.hSMul (Q m₂) ((bilin m₁) m₃))\n⊢ Eq (Eq { bilin := bilin✝, contract := contract✝, contract_mid := contract_mid✝ } { bilin := bilin, contract := contract, contract_mid := contract_mid }) (Eq bilin✝ bilin)","decl":"/-- The type of bilinear maps which are accepted by `CliffordAlgebra.even.lift`. -/\n@[ext]\nstructure EvenHom : Type max uA uM where\n  bilin : M →ₗ[R] M →ₗ[R] A\n  contract (m : M) : bilin m m = algebraMap R A (Q m)\n  contract_mid (m₁ m₂ m₃ : M) : bilin m₁ m₂ * bilin m₂ m₃ = Q m₂ • bilin m₁ m₃\n\n"}
{"name":"CliffordAlgebra.EvenHom.contract_mid","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nself : CliffordAlgebra.EvenHom Q A\nm₁ m₂ m₃ : M\n⊢ Eq (HMul.hMul ((self.bilin m₁) m₂) ((self.bilin m₂) m₃)) (HSMul.hSMul (Q m₂) ((self.bilin m₁) m₃))","decl":"/-- The type of bilinear maps which are accepted by `CliffordAlgebra.even.lift`. -/\n@[ext]\nstructure EvenHom : Type max uA uM where\n  bilin : M →ₗ[R] M →ₗ[R] A\n  contract (m : M) : bilin m m = algebraMap R A (Q m)\n  contract_mid (m₁ m₂ m₃ : M) : bilin m₁ m₂ * bilin m₂ m₃ = Q m₂ • bilin m₁ m₃\n\n"}
{"name":"CliffordAlgebra.EvenHom.mk.inj","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nbilin✝ : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M A)\ncontract✝ : ∀ (m : M), Eq ((bilin✝ m) m) ((algebraMap R A) (Q m))\ncontract_mid✝ : ∀ (m₁ m₂ m₃ : M), Eq (HMul.hMul ((bilin✝ m₁) m₂) ((bilin✝ m₂) m₃)) (HSMul.hSMul (Q m₂) ((bilin✝ m₁) m₃))\nbilin : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M A)\ncontract : ∀ (m : M), Eq ((bilin m) m) ((algebraMap R A) (Q m))\ncontract_mid : ∀ (m₁ m₂ m₃ : M), Eq (HMul.hMul ((bilin m₁) m₂) ((bilin m₂) m₃)) (HSMul.hSMul (Q m₂) ((bilin m₁) m₃))\nx✝ : Eq { bilin := bilin✝, contract := contract✝, contract_mid := contract_mid✝ } { bilin := bilin, contract := contract, contract_mid := contract_mid }\n⊢ Eq bilin✝ bilin","decl":"/-- The type of bilinear maps which are accepted by `CliffordAlgebra.even.lift`. -/\n@[ext]\nstructure EvenHom : Type max uA uM where\n  bilin : M →ₗ[R] M →ₗ[R] A\n  contract (m : M) : bilin m m = algebraMap R A (Q m)\n  contract_mid (m₁ m₂ m₃ : M) : bilin m₁ m₂ * bilin m₂ m₃ = Q m₂ • bilin m₁ m₃\n\n"}
{"name":"CliffordAlgebra.EvenHom.contract","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nself : CliffordAlgebra.EvenHom Q A\nm : M\n⊢ Eq ((self.bilin m) m) ((algebraMap R A) (Q m))","decl":"/-- The type of bilinear maps which are accepted by `CliffordAlgebra.even.lift`. -/\n@[ext]\nstructure EvenHom : Type max uA uM where\n  bilin : M →ₗ[R] M →ₗ[R] A\n  contract (m : M) : bilin m m = algebraMap R A (Q m)\n  contract_mid (m₁ m₂ m₃ : M) : bilin m₁ m₂ * bilin m₂ m₃ = Q m₂ • bilin m₁ m₃\n\n"}
{"name":"CliffordAlgebra.EvenHom.ext","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx y : CliffordAlgebra.EvenHom Q A\nbilin : Eq x.bilin y.bilin\n⊢ Eq x y","decl":"/-- The type of bilinear maps which are accepted by `CliffordAlgebra.even.lift`. -/\n@[ext]\nstructure EvenHom : Type max uA uM where\n  bilin : M →ₗ[R] M →ₗ[R] A\n  contract (m : M) : bilin m m = algebraMap R A (Q m)\n  contract_mid (m₁ m₂ m₃ : M) : bilin m₁ m₂ * bilin m₂ m₃ = Q m₂ • bilin m₁ m₃\n\n"}
{"name":"CliffordAlgebra.EvenHom.compr₂_bilin","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\nQ : QuadraticForm R M\nA : Type uA\nB : Type uB\ninst✝³ : Ring A\ninst✝² : Ring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\ng : CliffordAlgebra.EvenHom Q A\nf : AlgHom R A B\n⊢ Eq (g.compr₂ f).bilin (g.bilin.compr₂ f.toLinearMap)","decl":"/-- Compose an `EvenHom` with an `AlgHom` on the output. -/\n@[simps]\ndef EvenHom.compr₂ (g : EvenHom Q A) (f : A →ₐ[R] B) : EvenHom Q B where\n  bilin := g.bilin.compr₂ f.toLinearMap\n  contract _m := (f.congr_arg <| g.contract _).trans <| f.commutes _\n  contract_mid _m₁ _m₂ _m₃ :=\n    (map_mul f _ _).symm.trans <| (f.congr_arg <| g.contract_mid _ _ _).trans <| map_smul f _ _\n\n"}
{"name":"CliffordAlgebra.even.algHom_ext_iff","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nf g : AlgHom R (Subtype fun x => Membership.mem (CliffordAlgebra.even Q) x) A\n⊢ Iff (Eq f g) (Eq ((CliffordAlgebra.even.ι Q).compr₂ f) ((CliffordAlgebra.even.ι Q).compr₂ g))","decl":"/-- Two algebra morphisms from the even subalgebra are equal if they agree on pairs of generators.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem even.algHom_ext ⦃f g : even Q →ₐ[R] A⦄ (h : (even.ι Q).compr₂ f = (even.ι Q).compr₂ g) :\n    f = g := by\n  rw [EvenHom.ext_iff] at h\n  ext ⟨x, hx⟩\n  induction x, hx using even_induction with\n  | algebraMap r =>\n    exact (f.commutes r).trans (g.commutes r).symm\n  | add x y hx hy ihx ihy =>\n    have := congr_arg₂ (· + ·) ihx ihy\n    exact (map_add f _ _).trans (this.trans <| (map_add g _ _).symm)\n  | ι_mul_ι_mul m₁ m₂ x hx ih =>\n    have := congr_arg₂ (· * ·) (LinearMap.congr_fun (LinearMap.congr_fun h m₁) m₂) ih\n    exact (map_mul f _ _).trans (this.trans <| (map_mul g _ _).symm)\n\n"}
{"name":"CliffordAlgebra.even.algHom_ext","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nf g : AlgHom R (Subtype fun x => Membership.mem (CliffordAlgebra.even Q) x) A\nh : Eq ((CliffordAlgebra.even.ι Q).compr₂ f) ((CliffordAlgebra.even.ι Q).compr₂ g)\n⊢ Eq f g","decl":"/-- Two algebra morphisms from the even subalgebra are equal if they agree on pairs of generators.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem even.algHom_ext ⦃f g : even Q →ₐ[R] A⦄ (h : (even.ι Q).compr₂ f = (even.ι Q).compr₂ g) :\n    f = g := by\n  rw [EvenHom.ext_iff] at h\n  ext ⟨x, hx⟩\n  induction x, hx using even_induction with\n  | algebraMap r =>\n    exact (f.commutes r).trans (g.commutes r).symm\n  | add x y hx hy ihx ihy =>\n    have := congr_arg₂ (· + ·) ihx ihy\n    exact (map_add f _ _).trans (this.trans <| (map_add g _ _).symm)\n  | ι_mul_ι_mul m₁ m₂ x hx ih =>\n    have := congr_arg₂ (· * ·) (LinearMap.congr_fun (LinearMap.congr_fun h m₁) m₂) ih\n    exact (map_mul f _ _).trans (this.trans <| (map_mul g _ _).symm)\n\n"}
{"name":"CliffordAlgebra.even.lift.aux_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nf : CliffordAlgebra.EvenHom Q A\na✝ : Subtype fun x => Membership.mem (CliffordAlgebra.even Q) x\n⊢ Eq ((CliffordAlgebra.even.lift.aux f) a✝) (((CliffordAlgebra.foldr Q (CliffordAlgebra.even.lift.fFold f) ⋯) { fst := 1, snd := 0 }) ↑a✝).1","decl":"/-- The final auxiliary construction for `CliffordAlgebra.even.lift`. This map is the forwards\ndirection of that equivalence, but not in the fully-bundled form. -/\n@[simps! (config := .lemmasOnly) apply]\ndef aux (f : EvenHom Q A) : CliffordAlgebra.even Q →ₗ[R] A := by\n  refine ?_ ∘ₗ (even Q).val.toLinearMap\n  -- Porting note: added, can't be found otherwise\n  letI : AddCommGroup (S f) := AddSubgroupClass.toAddCommGroup _\n  exact LinearMap.fst R _ _ ∘ₗ foldr Q (fFold f) (fFold_fFold f) (1, 0)\n\n"}
{"name":"CliffordAlgebra.even.lift.aux_one","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nf : CliffordAlgebra.EvenHom Q A\n⊢ Eq ((CliffordAlgebra.even.lift.aux f) 1) 1","decl":"@[simp, nolint simpNF] -- Added `nolint simpNF` to avoid a timeout https://github.com/leanprover-community/mathlib4/pull/8386\ntheorem aux_one : aux f 1 = 1 :=\n  congr_arg Prod.fst (foldr_one _ _ _ _)\n\n"}
{"name":"CliffordAlgebra.even.lift.aux_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nf : CliffordAlgebra.EvenHom Q A\nm₁ m₂ : M\n⊢ Eq ((CliffordAlgebra.even.lift.aux f) (((CliffordAlgebra.even.ι Q).bilin m₁) m₂)) ((f.bilin m₁) m₂)","decl":"@[simp, nolint simpNF] -- Added `nolint simpNF` to avoid a timeout https://github.com/leanprover-community/mathlib4/pull/8386\ntheorem aux_ι (m₁ m₂ : M) : aux f ((even.ι Q).bilin m₁ m₂) = f.bilin m₁ m₂ :=\n  (congr_arg Prod.fst (foldr_mul _ _ _ _ _ _)).trans\n    (by\n      rw [foldr_ι, foldr_ι]\n      exact mul_one _)\n\n"}
{"name":"CliffordAlgebra.even.lift.aux_algebraMap","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nf : CliffordAlgebra.EvenHom Q A\nr : R\nhr : Membership.mem (CliffordAlgebra.even Q) ((algebraMap R (CliffordAlgebra Q)) r)\n⊢ Eq ((CliffordAlgebra.even.lift.aux f) ⟨(algebraMap R (CliffordAlgebra Q)) r, hr⟩) ((algebraMap R A) r)","decl":"@[simp, nolint simpNF] -- Added `nolint simpNF` to avoid a timeout https://github.com/leanprover-community/mathlib4/pull/8386\ntheorem aux_algebraMap (r) (hr) : aux f ⟨algebraMap R _ r, hr⟩ = algebraMap R _ r :=\n  (congr_arg Prod.fst (foldr_algebraMap _ _ _ _ _)).trans (Algebra.algebraMap_eq_smul_one r).symm\n\n"}
{"name":"CliffordAlgebra.even.lift.aux_mul","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nf : CliffordAlgebra.EvenHom Q A\nx y : Subtype fun x => Membership.mem (CliffordAlgebra.even Q) x\n⊢ Eq ((CliffordAlgebra.even.lift.aux f) (HMul.hMul x y)) (HMul.hMul ((CliffordAlgebra.even.lift.aux f) x) ((CliffordAlgebra.even.lift.aux f) y))","decl":"@[simp, nolint simpNF] -- Added `nolint simpNF` to avoid a timeout https://github.com/leanprover-community/mathlib4/pull/8386\ntheorem aux_mul (x y : even Q) : aux f (x * y) = aux f x * aux f y := by\n  cases' x with x x_property\n  cases y\n  refine (congr_arg Prod.fst (foldr_mul _ _ _ _ _ _)).trans ?_\n  dsimp only\n  induction x, x_property using even_induction Q with\n  | algebraMap r =>\n    rw [foldr_algebraMap, aux_algebraMap]\n    exact Algebra.smul_def r _\n  | add x y hx hy ihx ihy =>\n    rw [LinearMap.map_add, Prod.fst_add, ihx, ihy, ← add_mul, ← LinearMap.map_add]\n    rfl\n  | ι_mul_ι_mul m₁ m₂ x hx ih =>\n    rw [aux_apply, foldr_mul, foldr_mul, foldr_ι, foldr_ι, fst_fFold_fFold, ih, ← mul_assoc,\n      Subtype.coe_mk, foldr_mul, foldr_mul, foldr_ι, foldr_ι, fst_fFold_fFold]\n    rfl\n\n"}
{"name":"CliffordAlgebra.even.lift_symm_apply_bilin","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nF : AlgHom R (Subtype fun x => Membership.mem (CliffordAlgebra.even Q) x) A\n⊢ Eq ((CliffordAlgebra.even.lift Q).symm F).bilin ((CliffordAlgebra.even.ι Q).bilin.compr₂ F.toLinearMap)","decl":"/-- Every algebra morphism from the even subalgebra is in one-to-one correspondence with a\nbilinear map that sends duplicate arguments to the quadratic form, and contracts across\nmultiplication. -/\n@[simps! symm_apply_bilin]\ndef even.lift : EvenHom Q A ≃ (CliffordAlgebra.even Q →ₐ[R] A) where\n  toFun f := AlgHom.ofLinearMap (aux f) (aux_one f) (aux_mul f)\n  invFun F := (even.ι Q).compr₂ F\n  left_inv f := EvenHom.ext <| LinearMap.ext₂ <| even.lift.aux_ι f\n  right_inv _ := even.algHom_ext Q <| EvenHom.ext <| LinearMap.ext₂ <| even.lift.aux_ι _\n\n-- @[simp] -- Porting note: simpNF linter times out on this one\n"}
{"name":"CliffordAlgebra.even.lift_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Even","initialProofState":"R : Type uR\nM : Type uM\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type uA\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nf : CliffordAlgebra.EvenHom Q A\nm₁ m₂ : M\n⊢ Eq (((CliffordAlgebra.even.lift Q) f) (((CliffordAlgebra.even.ι Q).bilin m₁) m₂)) ((f.bilin m₁) m₂)","decl":"theorem even.lift_ι (f : EvenHom Q A) (m₁ m₂ : M) :\n    even.lift Q f ((even.ι Q).bilin m₁ m₂) = f.bilin m₁ m₂ :=\n  even.lift.aux_ι _ _ _\n\n"}
