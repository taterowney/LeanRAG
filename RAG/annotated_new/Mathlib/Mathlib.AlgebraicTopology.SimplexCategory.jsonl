{"name":"SimplexCategory.ext","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\na‚úù : Eq a.len b.len\n‚ä¢ Eq a b","decl":"@[ext]\ntheorem ext (a b : SimplexCategory) : a.len = b.len ‚Üí a = b :=\n  id\n\n"}
{"name":"SimplexCategory.ext_iff","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\n‚ä¢ Iff (Eq a b) (Eq a.len b.len)","decl":"@[ext]\ntheorem ext (a b : SimplexCategory) : a.len = b.len ‚Üí a = b :=\n  id\n\n"}
{"name":"SimplexCategory.len_mk","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\n‚ä¢ Eq (SimplexCategory.mk n).len n","decl":"@[simp]\ntheorem len_mk (n : ‚Ñï) : [n].len = n :=\n  rfl\n\n"}
{"name":"SimplexCategory.mk_len","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : SimplexCategory\n‚ä¢ Eq (SimplexCategory.mk n.len) n","decl":"@[simp]\ntheorem mk_len (n : SimplexCategory) : ([n.len] : SimplexCategory) = n :=\n  rfl\n\n"}
{"name":"SimplexCategory.Hom.ext'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\nf g : a.Hom b\na‚úù : Eq f.toOrderHom g.toOrderHom\n‚ä¢ Eq f g","decl":"theorem ext' {a b : SimplexCategory} (f g : SimplexCategory.Hom a b) :\n    f.toOrderHom = g.toOrderHom ‚Üí f = g :=\n  id\n\n"}
{"name":"SimplexCategory.Hom.mk_toOrderHom","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\nf : a.Hom b\n‚ä¢ Eq (SimplexCategory.Hom.mk f.toOrderHom) f","decl":"@[simp]\ntheorem mk_toOrderHom {a b : SimplexCategory} (f : SimplexCategory.Hom a b) : mk f.toOrderHom = f :=\n  rfl\n\n"}
{"name":"SimplexCategory.Hom.toOrderHom_mk","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\nf : OrderHom (Fin (HAdd.hAdd a.len 1)) (Fin (HAdd.hAdd b.len 1))\n‚ä¢ Eq (SimplexCategory.Hom.mk f).toOrderHom f","decl":"@[simp]\ntheorem toOrderHom_mk {a b : SimplexCategory} (f : Fin (a.len + 1) ‚Üío Fin (b.len + 1)) :\n    (mk f).toOrderHom = f :=\n  rfl\n\n"}
{"name":"SimplexCategory.Hom.mk_toOrderHom_apply","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\nf : OrderHom (Fin (HAdd.hAdd a.len 1)) (Fin (HAdd.hAdd b.len 1))\ni : Fin (HAdd.hAdd a.len 1)\n‚ä¢ Eq ((SimplexCategory.Hom.mk f).toOrderHom i) (f i)","decl":"theorem mk_toOrderHom_apply {a b : SimplexCategory} (f : Fin (a.len + 1) ‚Üío Fin (b.len + 1))\n    (i : Fin (a.len + 1)) : (mk f).toOrderHom i = f i :=\n  rfl\n\n"}
{"name":"SimplexCategory.id_toOrderHom","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a : SimplexCategory\n‚ä¢ Eq (SimplexCategory.Hom.toOrderHom (CategoryTheory.CategoryStruct.id a)) OrderHom.id","decl":"@[simp]\nlemma id_toOrderHom (a : SimplexCategory) :\n    Hom.toOrderHom (ùüô a) = OrderHom.id := rfl\n\n"}
{"name":"SimplexCategory.comp_toOrderHom","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b c : SimplexCategory\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n‚ä¢ Eq (SimplexCategory.Hom.toOrderHom (CategoryTheory.CategoryStruct.comp f g)) ((SimplexCategory.Hom.toOrderHom g).comp (SimplexCategory.Hom.toOrderHom f))","decl":"@[simp]\nlemma comp_toOrderHom {a b c : SimplexCategory} (f : a ‚ü∂ b) (g : b ‚ü∂ c) :\n    (f ‚â´ g).toOrderHom = g.toOrderHom.comp f.toOrderHom := rfl\n\n"}
{"name":"SimplexCategory.Hom.ext","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\nf g : Quiver.Hom a b\na‚úù : Eq (SimplexCategory.Hom.toOrderHom f) (SimplexCategory.Hom.toOrderHom g)\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem Hom.ext {a b : SimplexCategory} (f g : a ‚ü∂ b) :\n    f.toOrderHom = g.toOrderHom ‚Üí f = g :=\n  Hom.ext' _ _\n\n"}
{"name":"SimplexCategory.Hom.ext_iff","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\nf g : Quiver.Hom a b\n‚ä¢ Iff (Eq f g) (Eq (SimplexCategory.Hom.toOrderHom f) (SimplexCategory.Hom.toOrderHom g))","decl":"@[ext]\ntheorem Hom.ext {a b : SimplexCategory} (f g : a ‚ü∂ b) :\n    f.toOrderHom = g.toOrderHom ‚Üí f = g :=\n  Hom.ext' _ _\n\n"}
{"name":"SimplexCategory.const_eq_id","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"‚ä¢ Eq ((SimplexCategory.mk 0).const (SimplexCategory.mk 0) 0) (CategoryTheory.CategoryStruct.id (SimplexCategory.mk 0))","decl":"@[simp]\nlemma const_eq_id : const [0] [0] 0 = ùüô _ := by aesop\n\n"}
{"name":"SimplexCategory.const_apply","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x y : SimplexCategory\ni : Fin (HAdd.hAdd y.len 1)\na : Fin (HAdd.hAdd x.len 1)\n‚ä¢ Eq ((SimplexCategory.Hom.toOrderHom (x.const y i)) a) i","decl":"@[simp]\nlemma const_apply (x y : SimplexCategory) (i : Fin (y.len + 1)) (a : Fin (x.len + 1)) :\n    (const x y i).toOrderHom a = i := rfl\n\n"}
{"name":"SimplexCategory.const_comp","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x y z : SimplexCategory\nf : Quiver.Hom y z\ni : Fin (HAdd.hAdd y.len 1)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (x.const y i) f) (x.const z ((SimplexCategory.Hom.toOrderHom f) i))","decl":"@[simp]\ntheorem const_comp (x : SimplexCategory) {y z : SimplexCategory}\n    (f : y ‚ü∂ z) (i : Fin (y.len + 1)) :\n    const x y i ‚â´ f = const x z (f.toOrderHom i) :=\n  rfl\n\n"}
{"name":"SimplexCategory.const_fac_thru_zero","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n m : SimplexCategory\ni : Fin (HAdd.hAdd m.len 1)\n‚ä¢ Eq (n.const m i) (CategoryTheory.CategoryStruct.comp (n.const (SimplexCategory.mk 0) 0) ((SimplexCategory.mk 0).const m i))","decl":"theorem const_fac_thru_zero (n m : SimplexCategory) (i : Fin (m.len + 1)) :\n    const n m i = const n [0] 0 ‚â´ SimplexCategory.const [0] m i := by\n  rw [const_comp]; rfl\n\n"}
{"name":"SimplexCategory.Hom.ext_zero_left","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : SimplexCategory\nf g : Quiver.Hom (SimplexCategory.mk 0) n\nh0 : autoParam (Eq ((SimplexCategory.Hom.toOrderHom f) 0) ((SimplexCategory.Hom.toOrderHom g) 0)) _auto‚úù\n‚ä¢ Eq f g","decl":"theorem Hom.ext_zero_left {n : SimplexCategory} (f g : ([0] : SimplexCategory) ‚ü∂ n)\n    (h0 : f.toOrderHom 0 = g.toOrderHom 0 := by rfl) : f = g := by\n  ext i; match i with | 0 => exact h0 ‚ñ∏ rfl\n\n"}
{"name":"SimplexCategory.eq_const_of_zero","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : SimplexCategory\nf : Quiver.Hom (SimplexCategory.mk 0) n\n‚ä¢ Eq f ((SimplexCategory.mk 0).const n ((SimplexCategory.Hom.toOrderHom f) 0))","decl":"theorem eq_const_of_zero {n : SimplexCategory} (f : ([0] : SimplexCategory) ‚ü∂ n) :\n    f = const _ n (f.toOrderHom 0) := by\n  ext x; match x with | 0 => rfl\n\n"}
{"name":"SimplexCategory.exists_eq_const_of_zero","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : SimplexCategory\nf : Quiver.Hom (SimplexCategory.mk 0) n\n‚ä¢ Exists fun a => Eq f ((SimplexCategory.mk 0).const n a)","decl":"theorem exists_eq_const_of_zero {n : SimplexCategory} (f : ([0] : SimplexCategory) ‚ü∂ n) :\n    ‚àÉ a, f = const _ n a := ‚ü®_, eq_const_of_zero _‚ü©\n\n"}
{"name":"SimplexCategory.eq_const_to_zero","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : SimplexCategory\nf : Quiver.Hom n (SimplexCategory.mk 0)\n‚ä¢ Eq f (n.const (SimplexCategory.mk 0) 0)","decl":"theorem eq_const_to_zero {n : SimplexCategory} (f : n ‚ü∂ [0]) :\n    f = const n _ 0 := by\n  ext : 3\n  apply @Subsingleton.elim (Fin 1)\n\n"}
{"name":"SimplexCategory.Hom.ext_one_left","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : SimplexCategory\nf g : Quiver.Hom (SimplexCategory.mk 1) n\nh0 : autoParam (Eq ((SimplexCategory.Hom.toOrderHom f) 0) ((SimplexCategory.Hom.toOrderHom g) 0)) _auto‚úù\nh1 : autoParam (Eq ((SimplexCategory.Hom.toOrderHom f) 1) ((SimplexCategory.Hom.toOrderHom g) 1)) _auto‚úù\n‚ä¢ Eq f g","decl":"theorem Hom.ext_one_left {n : SimplexCategory} (f g : ([1] : SimplexCategory) ‚ü∂ n)\n    (h0 : f.toOrderHom 0 = g.toOrderHom 0 := by rfl)\n    (h1 : f.toOrderHom 1 = g.toOrderHom 1 := by rfl) : f = g := by\n  ext i\n  match i with\n  | 0 => exact h0 ‚ñ∏ rfl\n  | 1 => exact h1 ‚ñ∏ rfl\n\n"}
{"name":"SimplexCategory.eq_of_one_to_one","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"f : Quiver.Hom (SimplexCategory.mk 1) (SimplexCategory.mk 1)\n‚ä¢ Or (Exists fun a => Eq f ((SimplexCategory.mk 1).const (SimplexCategory.mk 1) a)) (Eq f (CategoryTheory.CategoryStruct.id (SimplexCategory.mk 1)))","decl":"theorem eq_of_one_to_one (f : ([1] : SimplexCategory) ‚ü∂ [1]) :\n    (‚àÉ a, f = const [1] _ a) ‚à® f = ùüô _ := by\n  match e0 : f.toOrderHom 0, e1 : f.toOrderHom 1 with\n  | 0, 0 | 1, 1 =>\n    refine .inl ‚ü®f.toOrderHom 0, ?_‚ü©\n    ext i : 3\n    match i with\n    | 0 => rfl\n    | 1 => exact e1.trans e0.symm\n  | 0, 1 =>\n    right\n    ext i : 3\n    match i with\n    | 0 => exact e0\n    | 1 => exact e1\n  | 1, 0 =>\n    have := f.toOrderHom.monotone (by decide : (0 : Fin 2) ‚â§ 1)\n    rw [e0, e1] at this\n    exact Not.elim (by decide) this\n\n\n"}
{"name":"SimplexCategory.mkOfLe_refl","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nj : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (SimplexCategory.mkOfLe j j ‚ãØ) ((SimplexCategory.mk 1).const (SimplexCategory.mk n) j)","decl":"@[simp]\nlemma mkOfLe_refl {n} (j : Fin (n + 1)) :\n    mkOfLe j j (by omega) = [1].const [n] j := Hom.ext_one_left _ _\n\n"}
{"name":"SimplexCategory.mkOfSucc_homToOrderHom_zero","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\n‚ä¢ Eq ((SimplexCategory.Hom.toOrderHom (SimplexCategory.mkOfSucc i)) 0) i.castSucc","decl":"@[simp]\nlemma mkOfSucc_homToOrderHom_zero {n} (i : Fin n) :\n    DFunLike.coe (F := Fin 2 ‚Üío Fin (n+1)) (Hom.toOrderHom (mkOfSucc i)) 0 = i.castSucc := rfl\n\n"}
{"name":"SimplexCategory.mkOfSucc_homToOrderHom_one","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\n‚ä¢ Eq ((SimplexCategory.Hom.toOrderHom (SimplexCategory.mkOfSucc i)) 1) i.succ","decl":"@[simp]\nlemma mkOfSucc_homToOrderHom_one {n} (i : Fin n) :\n    DFunLike.coe (F := Fin 2 ‚Üío Fin (n+1)) (Hom.toOrderHom (mkOfSucc i)) 1 = i.succ := rfl\n\n\n"}
{"name":"SimplexCategory.const_subinterval_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n j l : Nat\nhjl : LE.le (HAdd.hAdd j l) n\ni : Fin (HAdd.hAdd l 1)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((SimplexCategory.mk 0).const (SimplexCategory.mk l) i) (SimplexCategory.subinterval j l hjl)) ((SimplexCategory.mk 0).const (SimplexCategory.mk n) ‚ü®HAdd.hAdd j ‚Üëi, ‚ãØ‚ü©)","decl":"lemma const_subinterval_eq {n} (j l : ‚Ñï) (hjl : j + l ‚â§ n) (i : Fin (l + 1)) :\n    [0].const [l] i ‚â´ subinterval j l hjl =\n    [0].const [n] ‚ü®j + i.1, lt_add_of_lt_add_right (Nat.add_lt_add_left i.2 j) hjl‚ü©  := by\n  rw [const_comp]\n  congr\n  ext\n  dsimp [subinterval]\n  rw [add_comm]\n\n"}
{"name":"SimplexCategory.mkOfSucc_subinterval_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n j l : Nat\nhjl : LE.le (HAdd.hAdd j l) n\ni : Fin l\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.mkOfSucc i) (SimplexCategory.subinterval j l hjl)) (SimplexCategory.mkOfSucc ‚ü®HAdd.hAdd j ‚Üëi, ‚ãØ‚ü©)","decl":"@[simp]\nlemma mkOfSucc_subinterval_eq {n} (j l : ‚Ñï) (hjl : j + l ‚â§ n) (i : Fin l) :\n    mkOfSucc i ‚â´ subinterval j l hjl =\n    mkOfSucc ‚ü®j + i.1, Nat.lt_of_lt_of_le (Nat.add_lt_add_left i.2 j) hjl‚ü© := by\n  unfold subinterval mkOfSucc\n  ext i\n  match i with\n  | 0 =>\n    simp only [len_mk, Nat.reduceAdd, mkHom, comp_toOrderHom, Hom.toOrderHom_mk,\n      OrderHom.mk_comp_mk, Fin.isValue, OrderHom.coe_mk, Function.comp_apply, Fin.castSucc_mk,\n      Fin.succ_mk]\n    rw [add_comm]\n    rfl\n  | 1 =>\n    simp only [len_mk, Nat.reduceAdd, mkHom, comp_toOrderHom, Hom.toOrderHom_mk,\n      OrderHom.mk_comp_mk, Fin.isValue, OrderHom.coe_mk, Function.comp_apply, Fin.castSucc_mk,\n      Fin.succ_mk]\n    rw [‚Üê Nat.add_comm j _]\n    rfl\n\n"}
{"name":"SimplexCategory.diag_subinterval_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n j l : Nat\nhjl : LE.le (HAdd.hAdd j l) n\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.diag l) (SimplexCategory.subinterval j l hjl)) (SimplexCategory.intervalEdge j l hjl)","decl":"@[simp]\nlemma diag_subinterval_eq {n} (j l : ‚Ñï) (hjl : j + l ‚â§ n) :\n    diag l ‚â´ subinterval j l hjl = intervalEdge j l hjl := by\n  unfold subinterval intervalEdge diag mkOfLe\n  ext i\n  match i with\n  | 0 =>\n    simp only [len_mk, Nat.reduceAdd, mkHom, Fin.natCast_eq_last, comp_toOrderHom,\n      Hom.toOrderHom_mk, OrderHom.mk_comp_mk, Fin.isValue, OrderHom.coe_mk, Function.comp_apply]\n    rw [Nat.add_comm]\n    rfl\n  | 1 =>\n    simp only [len_mk, Nat.reduceAdd, mkHom, Fin.natCast_eq_last, comp_toOrderHom,\n      Hom.toOrderHom_mk, OrderHom.mk_comp_mk, Fin.isValue, OrderHom.coe_mk, Function.comp_apply]\n    rw [Nat.add_comm]\n    rfl\n\n"}
{"name":"SimplexCategory.instSubsingletonHomMkOfNatNat","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Œî : SimplexCategory\n‚ä¢ Subsingleton (Quiver.Hom Œî (SimplexCategory.mk 0))","decl":"instance (Œî : SimplexCategory) : Subsingleton (Œî ‚ü∂ [0]) where\n  allEq f g := by ext : 3; apply Subsingleton.elim (Œ± := Fin 1)\n\n"}
{"name":"SimplexCategory.hom_zero_zero","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"f : Quiver.Hom (SimplexCategory.mk 0) (SimplexCategory.mk 0)\n‚ä¢ Eq f (CategoryTheory.CategoryStruct.id (SimplexCategory.mk 0))","decl":"theorem hom_zero_zero (f : ([0] : SimplexCategory) ‚ü∂ [0]) : f = ùüô _ := by\n  apply Subsingleton.elim\n\n"}
{"name":"SimplexCategory.Œ¥_comp_Œ¥","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni j : Fin (HAdd.hAdd n 2)\nH : LE.le i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) (SimplexCategory.Œ¥ j.succ)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ j) (SimplexCategory.Œ¥ i.castSucc))","decl":"/-- The generic case of the first simplicial identity -/\ntheorem Œ¥_comp_Œ¥ {n} {i j : Fin (n + 2)} (H : i ‚â§ j) :\n    Œ¥ i ‚â´ Œ¥ j.succ = Œ¥ j ‚â´ Œ¥ i.castSucc := by\n  ext k\n  dsimp [Œ¥, Fin.succAbove]\n  rcases i with ‚ü®i, _‚ü©\n  rcases j with ‚ü®j, _‚ü©\n  rcases k with ‚ü®k, _‚ü©\n  split_ifs <;> ¬∑ simp at * <;> omega\n\n"}
{"name":"SimplexCategory.Œ¥_comp_Œ¥'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : LT.lt i.castSucc j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) (SimplexCategory.Œ¥ j)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ (j.pred ‚ãØ)) (SimplexCategory.Œ¥ i.castSucc))","decl":"theorem Œ¥_comp_Œ¥' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : i.castSucc < j) :\n    Œ¥ i ‚â´ Œ¥ j =\n      Œ¥ (j.pred fun (hj : j = 0) => by simp [hj, Fin.not_lt_zero] at H) ‚â´\n        Œ¥ (Fin.castSucc i) := by\n  rw [‚Üê Œ¥_comp_Œ¥]\n  ¬∑ rw [Fin.succ_pred]\n  ¬∑ simpa only [Fin.le_iff_val_le_val, ‚Üê Nat.lt_succ_iff, Nat.succ_eq_add_one, ‚Üê Fin.val_succ,\n      j.succ_pred, Fin.lt_iff_val_lt_val] using H\n\n"}
{"name":"SimplexCategory.Œ¥_comp_Œ¥''","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LE.le i j.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ (i.castLT ‚ãØ)) (SimplexCategory.Œ¥ j.succ)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ j) (SimplexCategory.Œ¥ i))","decl":"theorem Œ¥_comp_Œ¥'' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : i ‚â§ Fin.castSucc j) :\n    Œ¥ (i.castLT (Nat.lt_of_le_of_lt (Fin.le_iff_val_le_val.mp H) j.is_lt)) ‚â´ Œ¥ j.succ =\n      Œ¥ j ‚â´ Œ¥ i := by\n  rw [Œ¥_comp_Œ¥]\n  ¬∑ rfl\n  ¬∑ exact H\n\n"}
{"name":"SimplexCategory.Œ¥_comp_Œ¥_self","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) (SimplexCategory.Œ¥ i.castSucc)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) (SimplexCategory.Œ¥ i.succ))","decl":"/-- The special case of the first simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_Œ¥_self {n} {i : Fin (n + 2)} : Œ¥ i ‚â´ Œ¥ i.castSucc = Œ¥ i ‚â´ Œ¥ i.succ :=\n  (Œ¥_comp_Œ¥ (le_refl i)).symm\n\n"}
{"name":"SimplexCategory.Œ¥_comp_Œ¥_self_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i.castSucc) h)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i.succ) h))","decl":"/-- The special case of the first simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_Œ¥_self {n} {i : Fin (n + 2)} : Œ¥ i ‚â´ Œ¥ i.castSucc = Œ¥ i ‚â´ Œ¥ i.succ :=\n  (Œ¥_comp_Œ¥ (le_refl i)).symm\n\n"}
{"name":"SimplexCategory.Œ¥_comp_Œ¥_self'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : Eq j i.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) (SimplexCategory.Œ¥ j)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) (SimplexCategory.Œ¥ i.succ))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥_self' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : j = i.castSucc) :\n    Œ¥ i ‚â´ Œ¥ j = Œ¥ i ‚â´ Œ¥ i.succ := by\n  subst H\n  rw [Œ¥_comp_Œ¥_self]\n\n"}
{"name":"SimplexCategory.Œ¥_comp_Œ¥_self'_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : Eq j i.castSucc\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ j) h)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i.succ) h))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥_self' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : j = i.castSucc) :\n    Œ¥ i ‚â´ Œ¥ j = Œ¥ i ‚â´ Œ¥ i.succ := by\n  subst H\n  rw [Œ¥_comp_Œ¥_self]\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_of_le_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LE.le i j.castSucc\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd n 1)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i.castSucc) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ j.succ) h)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ j) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) h))","decl":"/-- The second simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ‚â§ j.castSucc) :\n    Œ¥ i.castSucc ‚â´ œÉ j.succ = œÉ j ‚â´ Œ¥ i := by\n  ext k : 3\n  dsimp [œÉ, Œ¥]\n  rcases le_or_lt i k with (hik | hik)\n  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hik),\n    Fin.succ_predAbove_succ, Fin.succAbove_of_le_castSucc]\n    rcases le_or_lt k (j.castSucc) with (hjk | hjk)\n    ¬∑ rwa [Fin.predAbove_of_le_castSucc _ _ hjk, Fin.castSucc_castPred]\n    ¬∑ rw [Fin.le_castSucc_iff, Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succ_pred]\n      exact H.trans_lt hjk\n  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hik)]\n    have hjk := H.trans_lt' hik\n    rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr\n      (hjk.trans (Fin.castSucc_lt_succ _)).le),\n      Fin.predAbove_of_le_castSucc _ _ hjk.le, Fin.castPred_castSucc, Fin.succAbove_of_castSucc_lt,\n      Fin.castSucc_castPred]\n    rwa [Fin.castSucc_castPred]\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_of_le","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LE.le i j.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i.castSucc) (SimplexCategory.œÉ j.succ)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ j) (SimplexCategory.Œ¥ i))","decl":"/-- The second simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ‚â§ j.castSucc) :\n    Œ¥ i.castSucc ‚â´ œÉ j.succ = œÉ j ‚â´ Œ¥ i := by\n  ext k : 3\n  dsimp [œÉ, Œ¥]\n  rcases le_or_lt i k with (hik | hik)\n  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hik),\n    Fin.succ_predAbove_succ, Fin.succAbove_of_le_castSucc]\n    rcases le_or_lt k (j.castSucc) with (hjk | hjk)\n    ¬∑ rwa [Fin.predAbove_of_le_castSucc _ _ hjk, Fin.castSucc_castPred]\n    ¬∑ rw [Fin.le_castSucc_iff, Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succ_pred]\n      exact H.trans_lt hjk\n  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hik)]\n    have hjk := H.trans_lt' hik\n    rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr\n      (hjk.trans (Fin.castSucc_lt_succ _)).le),\n      Fin.predAbove_of_le_castSucc _ _ hjk.le, Fin.castPred_castSucc, Fin.succAbove_of_castSucc_lt,\n      Fin.castSucc_castPred]\n    rwa [Fin.castSucc_castPred]\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_self","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i.castSucc) (SimplexCategory.œÉ i)) (CategoryTheory.CategoryStruct.id (SimplexCategory.mk n))","decl":"/-- The first part of the third simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_self {n} {i : Fin (n + 1)} :\n    Œ¥ (Fin.castSucc i) ‚â´ œÉ i = ùüô ([n] : SimplexCategory) := by\n  rcases i with ‚ü®i, hi‚ü©\n  ext ‚ü®j, hj‚ü©\n  simp? at hj says simp only [len_mk] at hj\n  dsimp [œÉ, Œ¥, Fin.predAbove, Fin.succAbove]\n  simp only [Fin.lt_iff_val_lt_val, Fin.dite_val, Fin.ite_val, Fin.coe_pred, Fin.coe_castLT]\n  split_ifs\n  any_goals simp\n  all_goals omega\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_self_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk n) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i.castSucc) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ i) h)) h","decl":"/-- The first part of the third simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_self {n} {i : Fin (n + 1)} :\n    Œ¥ (Fin.castSucc i) ‚â´ œÉ i = ùüô ([n] : SimplexCategory) := by\n  rcases i with ‚ü®i, hi‚ü©\n  ext ‚ü®j, hj‚ü©\n  simp? at hj says simp only [len_mk] at hj\n  dsimp [œÉ, Œ¥, Fin.predAbove, Fin.succAbove]\n  simp only [Fin.lt_iff_val_lt_val, Fin.dite_val, Fin.ite_val, Fin.coe_pred, Fin.coe_castLT]\n  split_ifs\n  any_goals simp\n  all_goals omega\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_self'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ j) (SimplexCategory.œÉ i)) (CategoryTheory.CategoryStruct.id (SimplexCategory.mk n))","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_self' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.castSucc) :\n    Œ¥ j ‚â´ œÉ i = ùüô ([n] : SimplexCategory) := by\n  subst H\n  rw [Œ¥_comp_œÉ_self]\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_self'_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.castSucc\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk n) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ j) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ i) h)) h","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_self' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.castSucc) :\n    Œ¥ j ‚â´ œÉ i = ùüô ([n] : SimplexCategory) := by\n  subst H\n  rw [Œ¥_comp_œÉ_self]\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_succ","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i.succ) (SimplexCategory.œÉ i)) (CategoryTheory.CategoryStruct.id (SimplexCategory.mk n))","decl":"/-- The second part of the third simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_succ {n} {i : Fin (n + 1)} : Œ¥ i.succ ‚â´ œÉ i = ùüô ([n] : SimplexCategory) := by\n  ext j\n  rcases i with ‚ü®i, _‚ü©\n  rcases j with ‚ü®j, _‚ü©\n  dsimp [Œ¥, œÉ, Fin.succAbove, Fin.predAbove]\n  split_ifs <;> simp <;> simp at * <;> omega\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_succ_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk n) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i.succ) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ i) h)) h","decl":"/-- The second part of the third simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_succ {n} {i : Fin (n + 1)} : Œ¥ i.succ ‚â´ œÉ i = ùüô ([n] : SimplexCategory) := by\n  ext j\n  rcases i with ‚ü®i, _‚ü©\n  rcases j with ‚ü®j, _‚ü©\n  dsimp [Œ¥, œÉ, Fin.succAbove, Fin.predAbove]\n  split_ifs <;> simp <;> simp at * <;> omega\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_succ'_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.succ\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk n) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ j) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ i) h)) h","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_succ' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.succ) :\n    Œ¥ j ‚â´ œÉ i = ùüô ([n] : SimplexCategory) := by\n  subst H\n  rw [Œ¥_comp_œÉ_succ]\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_succ'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.succ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ j) (SimplexCategory.œÉ i)) (CategoryTheory.CategoryStruct.id (SimplexCategory.mk n))","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_succ' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.succ) :\n    Œ¥ j ‚â´ œÉ i = ùüô ([n] : SimplexCategory) := by\n  subst H\n  rw [Œ¥_comp_œÉ_succ]\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_of_gt","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LT.lt j.castSucc i\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i.succ) (SimplexCategory.œÉ j.castSucc)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ j) (SimplexCategory.Œ¥ i))","decl":"/-- The fourth simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : j.castSucc < i) :\n    Œ¥ i.succ ‚â´ œÉ j.castSucc = œÉ j ‚â´ Œ¥ i := by\n  ext k : 3\n  dsimp [Œ¥, œÉ]\n  rcases le_or_lt k i with (hik | hik)\n  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]\n    rcases le_or_lt k (j.castSucc) with (hjk | hjk)\n    ¬∑ rw [Fin.predAbove_of_le_castSucc _ _\n      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,\n      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]\n      rw [Fin.castSucc_castPred]\n      exact hjk.trans_lt H\n    ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),\n      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,\n      Fin.castSucc_pred_eq_pred_castSucc]\n      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]\n  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]\n    have hjk := H.trans hik\n    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _\n      (Fin.castSucc_lt_succ_iff.mpr hjk.le),\n    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]\n    rwa [Fin.le_castSucc_pred_iff]\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_of_gt_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LT.lt j.castSucc i\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd n 1)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i.succ) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ j.castSucc) h)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ j) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) h))","decl":"/-- The fourth simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : j.castSucc < i) :\n    Œ¥ i.succ ‚â´ œÉ j.castSucc = œÉ j ‚â´ Œ¥ i := by\n  ext k : 3\n  dsimp [Œ¥, œÉ]\n  rcases le_or_lt k i with (hik | hik)\n  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]\n    rcases le_or_lt k (j.castSucc) with (hjk | hjk)\n    ¬∑ rw [Fin.predAbove_of_le_castSucc _ _\n      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,\n      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]\n      rw [Fin.castSucc_castPred]\n      exact hjk.trans_lt H\n    ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),\n      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,\n      Fin.castSucc_pred_eq_pred_castSucc]\n      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]\n  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]\n    have hjk := H.trans hik\n    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _\n      (Fin.castSucc_lt_succ_iff.mpr hjk.le),\n    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]\n    rwa [Fin.le_castSucc_pred_iff]\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_of_gt'_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LT.lt j.succ i\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd n 1)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ j) h)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ (j.castLT ‚ãØ)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ (i.pred ‚ãØ)) h))","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_of_gt' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : j.succ < i) :\n    Œ¥ i ‚â´ œÉ j = œÉ (j.castLT ((add_lt_add_iff_right 1).mp (lt_of_lt_of_le H i.is_le))) ‚â´\n      Œ¥ (i.pred fun (hi : i = 0) => by simp only [Fin.not_lt_zero, hi] at H) := by\n  rw [‚Üê Œ¥_comp_œÉ_of_gt]\n  ¬∑ simp\n  ¬∑ rw [Fin.castSucc_castLT, ‚Üê Fin.succ_lt_succ_iff, Fin.succ_pred]\n    exact H\n\n"}
{"name":"SimplexCategory.Œ¥_comp_œÉ_of_gt'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LT.lt j.succ i\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ i) (SimplexCategory.œÉ j)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ (j.castLT ‚ãØ)) (SimplexCategory.Œ¥ (i.pred ‚ãØ)))","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_of_gt' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : j.succ < i) :\n    Œ¥ i ‚â´ œÉ j = œÉ (j.castLT ((add_lt_add_iff_right 1).mp (lt_of_lt_of_le H i.is_le))) ‚â´\n      Œ¥ (i.pred fun (hi : i = 0) => by simp only [Fin.not_lt_zero, hi] at H) := by\n  rw [‚Üê Œ¥_comp_œÉ_of_gt]\n  ¬∑ simp\n  ¬∑ rw [Fin.castSucc_castLT, ‚Üê Fin.succ_lt_succ_iff, Fin.succ_pred]\n    exact H\n\n"}
{"name":"SimplexCategory.œÉ_comp_œÉ","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni j : Fin (HAdd.hAdd n 1)\nH : LE.le i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ i.castSucc) (SimplexCategory.œÉ j)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ j.succ) (SimplexCategory.œÉ i))","decl":"/-- The fifth simplicial identity -/\n@[reassoc]\ntheorem œÉ_comp_œÉ {n} {i j : Fin (n + 1)} (H : i ‚â§ j) :\n    œÉ (Fin.castSucc i) ‚â´ œÉ j = œÉ j.succ ‚â´ œÉ i := by\n  ext k : 3\n  dsimp [œÉ]\n  cases' k using Fin.lastCases with k\n  ¬∑ simp only [len_mk, Fin.predAbove_right_last]\n  ¬∑ cases' k using Fin.cases with k\n    ¬∑ rw [Fin.castSucc_zero, Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),\n      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _), Fin.castPred_zero,\n      Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),\n      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _)]\n    ¬∑ rcases le_or_lt i k with (h | h)\n      ¬∑ simp_rw [Fin.predAbove_of_castSucc_lt i.castSucc _ (Fin.castSucc_lt_castSucc_iff.mpr\n        (Fin.castSucc_lt_succ_iff.mpr h)), ‚Üê Fin.succ_castSucc, Fin.pred_succ,\n        Fin.succ_predAbove_succ]\n        rw [Fin.predAbove_of_castSucc_lt i _ (Fin.castSucc_lt_succ_iff.mpr _), Fin.pred_succ]\n        rcases le_or_lt k j with (hkj | hkj)\n        ¬∑ rwa [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hkj),\n          Fin.castPred_castSucc]\n        ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hkj),\n          Fin.le_pred_iff,\n          Fin.succ_le_castSucc_iff]\n          exact H.trans_lt hkj\n      ¬∑ simp_rw [Fin.predAbove_of_le_castSucc i.castSucc _ (Fin.castSucc_le_castSucc_iff.mpr\n        (Fin.succ_le_castSucc_iff.mpr h)), Fin.castPred_castSucc, ‚Üê Fin.succ_castSucc,\n        Fin.succ_predAbove_succ]\n        rw [Fin.predAbove_of_le_castSucc _ k.castSucc\n        (Fin.castSucc_le_castSucc_iff.mpr (h.le.trans H)),\n        Fin.castPred_castSucc, Fin.predAbove_of_le_castSucc _ k.succ\n        (Fin.succ_le_castSucc_iff.mpr (H.trans_lt' h)), Fin.predAbove_of_le_castSucc _ k.succ\n        (Fin.succ_le_castSucc_iff.mpr h)]\n\n"}
{"name":"SimplexCategory.œÉ_comp_œÉ_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni j : Fin (HAdd.hAdd n 1)\nH : LE.le i j\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk n) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ i.castSucc) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ j) h)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ j.succ) (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ i) h))","decl":"/-- The fifth simplicial identity -/\n@[reassoc]\ntheorem œÉ_comp_œÉ {n} {i j : Fin (n + 1)} (H : i ‚â§ j) :\n    œÉ (Fin.castSucc i) ‚â´ œÉ j = œÉ j.succ ‚â´ œÉ i := by\n  ext k : 3\n  dsimp [œÉ]\n  cases' k using Fin.lastCases with k\n  ¬∑ simp only [len_mk, Fin.predAbove_right_last]\n  ¬∑ cases' k using Fin.cases with k\n    ¬∑ rw [Fin.castSucc_zero, Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),\n      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _), Fin.castPred_zero,\n      Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),\n      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _)]\n    ¬∑ rcases le_or_lt i k with (h | h)\n      ¬∑ simp_rw [Fin.predAbove_of_castSucc_lt i.castSucc _ (Fin.castSucc_lt_castSucc_iff.mpr\n        (Fin.castSucc_lt_succ_iff.mpr h)), ‚Üê Fin.succ_castSucc, Fin.pred_succ,\n        Fin.succ_predAbove_succ]\n        rw [Fin.predAbove_of_castSucc_lt i _ (Fin.castSucc_lt_succ_iff.mpr _), Fin.pred_succ]\n        rcases le_or_lt k j with (hkj | hkj)\n        ¬∑ rwa [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hkj),\n          Fin.castPred_castSucc]\n        ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hkj),\n          Fin.le_pred_iff,\n          Fin.succ_le_castSucc_iff]\n          exact H.trans_lt hkj\n      ¬∑ simp_rw [Fin.predAbove_of_le_castSucc i.castSucc _ (Fin.castSucc_le_castSucc_iff.mpr\n        (Fin.succ_le_castSucc_iff.mpr h)), Fin.castPred_castSucc, ‚Üê Fin.succ_castSucc,\n        Fin.succ_predAbove_succ]\n        rw [Fin.predAbove_of_le_castSucc _ k.castSucc\n        (Fin.castSucc_le_castSucc_iff.mpr (h.le.trans H)),\n        Fin.castPred_castSucc, Fin.predAbove_of_le_castSucc _ k.succ\n        (Fin.succ_le_castSucc_iff.mpr (H.trans_lt' h)), Fin.predAbove_of_le_castSucc _ k.succ\n        (Fin.succ_le_castSucc_iff.mpr h)]\n\n"}
{"name":"SimplexCategory.factor_Œ¥_spec","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"m n : Nat\nf : Quiver.Hom (SimplexCategory.mk m) (SimplexCategory.mk (HAdd.hAdd n 1))\nj : Fin (HAdd.hAdd n 2)\nhj : ‚àÄ (k : Fin (HAdd.hAdd m 1)), Ne ((SimplexCategory.Hom.toOrderHom f) k) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.factor_Œ¥ f j) (SimplexCategory.Œ¥ j)) f","decl":"open Fin in\nlemma factor_Œ¥_spec {m n : ‚Ñï} (f : ([m] : SimplexCategory) ‚ü∂ [n+1]) (j : Fin (n+2))\n    (hj : ‚àÄ (k : Fin (m+1)), f.toOrderHom k ‚â† j) :\n    factor_Œ¥ f j ‚â´ Œ¥ j = f := by\n  ext k : 3\n  specialize hj k\n  dsimp [factor_Œ¥, Œ¥, œÉ]\n  cases' j using cases with j\n  ¬∑ rw [predAbove_of_le_castSucc _ _ (zero_le _), castPred_zero, predAbove_of_castSucc_lt 0 _\n    (castSucc_zero ‚ñ∏ pos_of_ne_zero hj),\n    zero_succAbove, succ_pred]\n  ¬∑ rw [predAbove_of_castSucc_lt 0 _ (castSucc_zero ‚ñ∏ succ_pos _), pred_succ]\n    rcases hj.lt_or_lt with (hj | hj)\n    ¬∑ rw [predAbove_of_le_castSucc j _]\n      swap\n      ¬∑ exact (le_castSucc_iff.mpr hj)\n      ¬∑ rw [succAbove_of_castSucc_lt]\n        swap\n        ¬∑ rwa [castSucc_lt_succ_iff, castPred_le_iff, le_castSucc_iff]\n        rw [castSucc_castPred]\n    ¬∑ rw [predAbove_of_castSucc_lt]\n      swap\n      ¬∑ exact (castSucc_lt_succ _).trans hj\n      rw [succAbove_of_le_castSucc]\n      swap\n      ¬∑ rwa [succ_le_castSucc_iff, lt_pred_iff]\n      rw [succ_pred]\n\n"}
{"name":"SimplexCategory.Œ¥_zero_mkOfSucc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ 0) (SimplexCategory.mkOfSucc i)) ((SimplexCategory.mk 0).const (SimplexCategory.mk n) i.succ)","decl":"@[simp]\nlemma Œ¥_zero_mkOfSucc {n : ‚Ñï} (i : Fin n) :\n    Œ¥ 0 ‚â´ mkOfSucc i = SimplexCategory.const _ [n] i.succ := by\n  ext x\n  fin_cases x\n  rfl\n\n"}
{"name":"SimplexCategory.Œ¥_one_mkOfSucc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.Œ¥ 1) (SimplexCategory.mkOfSucc i)) ((SimplexCategory.mk 0).const (SimplexCategory.mk n) ‚Üë‚Üëi.castSucc)","decl":"@[simp]\nlemma Œ¥_one_mkOfSucc {n : ‚Ñï} (i : Fin n) :\n    Œ¥ 1 ‚â´ mkOfSucc i = SimplexCategory.const _ _ i.castSucc := by\n  ext x\n  fin_cases x\n  aesop\n\n"}
{"name":"SimplexCategory.mkOfSucc_Œ¥_lt","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\nj : Fin (HAdd.hAdd n 2)\nh : LT.lt i.succ.castSucc j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.mkOfSucc i) (SimplexCategory.Œ¥ j)) (SimplexCategory.mkOfSucc i.castSucc)","decl":"/-- If `i + 1 < j`, `mkOfSucc i ‚â´ Œ¥ j` is the morphism `[1] ‚ü∂ [n]` that\nsends `0` and `1` to `i` and `i + 1`, respectively. -/\nlemma mkOfSucc_Œ¥_lt {n : ‚Ñï} {i : Fin n} {j : Fin (n + 2)}\n    (h : i.succ.castSucc < j) :\n    mkOfSucc i ‚â´ Œ¥ j = mkOfSucc i.castSucc := by\n  ext x\n  fin_cases x\n  ¬∑ simp [Œ¥, Fin.succAbove_of_castSucc_lt _ _ (Nat.lt_trans _ h)]\n  ¬∑ simp [Œ¥, Fin.succAbove_of_castSucc_lt _ _ h]\n\n"}
{"name":"SimplexCategory.mkOfSucc_Œ¥_gt","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\nj : Fin (HAdd.hAdd n 2)\nh : LT.lt j i.succ.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.mkOfSucc i) (SimplexCategory.Œ¥ j)) (SimplexCategory.mkOfSucc i.succ)","decl":"/-- If `i + 1 > j`, `mkOfSucc i ‚â´ Œ¥ j` is the morphism `[1] ‚ü∂ [n]` that\nsends `0` and `1` to `i + 1` and `i + 2`, respectively. -/\nlemma mkOfSucc_Œ¥_gt {n : ‚Ñï} {i : Fin n} {j : Fin (n + 2)}\n    (h : j < i.succ.castSucc) :\n    mkOfSucc i ‚â´ Œ¥ j = mkOfSucc i.succ := by\n  ext x\n  simp only [Œ¥, len_mk, mkHom, comp_toOrderHom, Hom.toOrderHom_mk, OrderHom.comp_coe,\n    OrderEmbedding.toOrderHom_coe, Function.comp_apply, Fin.succAboveOrderEmb_apply]\n  fin_cases x <;> rw [Fin.succAbove_of_le_castSucc]\n  ¬∑ rfl\n  ¬∑ exact Nat.le_of_lt_succ h\n  ¬∑ rfl\n  ¬∑ exact Nat.le_of_lt h\n\n"}
{"name":"SimplexCategory.mkOfSucc_Œ¥_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\nj : Fin (HAdd.hAdd n 2)\nh : Eq j i.succ.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.mkOfSucc i) (SimplexCategory.Œ¥ j)) (SimplexCategory.intervalEdge (‚Üëi) 2 ‚ãØ)","decl":"/-- If `i + 1 = j`, `mkOfSucc i ‚â´ Œ¥ j` is the morphism `[1] ‚ü∂ [n]` that\nsends `0` and `1` to `i` and `i + 2`, respectively. -/\nlemma mkOfSucc_Œ¥_eq {n : ‚Ñï} {i : Fin n} {j : Fin (n + 2)}\n    (h : j = i.succ.castSucc) :\n    mkOfSucc i ‚â´ Œ¥ j = intervalEdge i 2 (by omega) := by\n  ext x\n  fin_cases x\n  ¬∑ subst h\n    simp only [Œ¥, len_mk, Nat.reduceAdd, mkHom, comp_toOrderHom, Hom.toOrderHom_mk,\n      Fin.zero_eta, OrderHom.comp_coe, OrderEmbedding.toOrderHom_coe, Function.comp_apply,\n      mkOfSucc_homToOrderHom_zero, Fin.succAboveOrderEmb_apply,\n      Fin.castSucc_succAbove_castSucc, Fin.succAbove_succ_self]\n    rfl\n  ¬∑ simp only [Œ¥, len_mk, Nat.reduceAdd, mkHom, comp_toOrderHom, Hom.toOrderHom_mk, Fin.mk_one,\n      OrderHom.comp_coe, OrderEmbedding.toOrderHom_coe, Function.comp_apply,\n      mkOfSucc_homToOrderHom_one, Fin.succAboveOrderEmb_apply]\n    subst h\n    rw [Fin.succAbove_castSucc_self]\n    rfl\n\n"}
{"name":"SimplexCategory.eq_of_one_to_two","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"f : Quiver.Hom (SimplexCategory.mk 1) (SimplexCategory.mk 2)\n‚ä¢ Or (Eq f (SimplexCategory.Œ¥ 0)) (Or (Eq f (SimplexCategory.Œ¥ 1)) (Or (Eq f (SimplexCategory.Œ¥ 2)) (Exists fun a => Eq f ((SimplexCategory.mk 1).const (SimplexCategory.mk 2) a))))","decl":"theorem eq_of_one_to_two (f : ([1] : SimplexCategory) ‚ü∂ [2]) :\n    f = (Œ¥ (n := 1) 0) ‚à® f = (Œ¥ (n := 1) 1) ‚à® f = (Œ¥ (n := 1) 2) ‚à®\n      ‚àÉ a, f = SimplexCategory.const _ _ a := by\n  have : f.toOrderHom 0 ‚â§ f.toOrderHom 1 := f.toOrderHom.monotone (by decide : (0 : Fin 2) ‚â§ 1)\n  match e0 : f.toOrderHom 0, e1 : f.toOrderHom 1 with\n  | 1, 2 =>\n    left\n    ext i : 3\n    match i with\n    | 0 => exact e0\n    | 1 => exact e1\n  | 0, 2 =>\n    right; left\n    ext i : 3\n    match i with\n    | 0 => exact e0\n    | 1 => exact e1\n  | 0, 1 =>\n    right; right; left\n    ext i : 3\n    match i with\n    | 0 => exact e0\n    | 1 => exact e1\n  | 0, 0 | 1, 1 | 2, 2 =>\n    right; right; right; use f.toOrderHom 0\n    ext i : 3\n    match i with\n    | 0 => rfl\n    | 1 => exact e1.trans e0.symm\n  | 1, 0 | 2, 0 | 2, 1 =>\n    rw [e0, e1] at this\n    exact Not.elim (by decide) this\n\n"}
{"name":"SimplexCategory.skeletalFunctor_obj","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a : SimplexCategory\n‚ä¢ Eq (SimplexCategory.skeletalFunctor.obj a) (NonemptyFinLinOrd.of (Fin (HAdd.hAdd a.len 1)))","decl":"/-- The functor that exhibits `SimplexCategory` as skeleton\nof `NonemptyFinLinOrd` -/\n@[simps obj map]\ndef skeletalFunctor : SimplexCategory ‚•§ NonemptyFinLinOrd where\n  obj a := NonemptyFinLinOrd.of (Fin (a.len + 1))\n  map f := f.toOrderHom\n\n"}
{"name":"SimplexCategory.skeletalFunctor_map","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"X‚úù Y‚úù : SimplexCategory\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (SimplexCategory.skeletalFunctor.map f) (SimplexCategory.Hom.toOrderHom f)","decl":"/-- The functor that exhibits `SimplexCategory` as skeleton\nof `NonemptyFinLinOrd` -/\n@[simps obj map]\ndef skeletalFunctor : SimplexCategory ‚•§ NonemptyFinLinOrd where\n  obj a := NonemptyFinLinOrd.of (Fin (a.len + 1))\n  map f := f.toOrderHom\n\n"}
{"name":"SimplexCategory.skeletalFunctor.coe_map","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Œî‚ÇÅ Œî‚ÇÇ : SimplexCategory\nf : Quiver.Hom Œî‚ÇÅ Œî‚ÇÇ\n‚ä¢ Eq (SimplexCategory.skeletalFunctor.map f) (SimplexCategory.Hom.toOrderHom f)","decl":"theorem skeletalFunctor.coe_map {Œî‚ÇÅ Œî‚ÇÇ : SimplexCategory} (f : Œî‚ÇÅ ‚ü∂ Œî‚ÇÇ) :\n    ‚Üë(skeletalFunctor.map f) = f.toOrderHom :=\n  rfl\n\n"}
{"name":"SimplexCategory.skeletal","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"‚ä¢ CategoryTheory.Skeletal SimplexCategory","decl":"theorem skeletal : Skeletal SimplexCategory := fun X Y ‚ü®I‚ü© => by\n  suffices Fintype.card (Fin (X.len + 1)) = Fintype.card (Fin (Y.len + 1)) by\n    ext\n    simpa\n  apply Fintype.card_congr\n  exact ((skeletalFunctor ‚ãô forget NonemptyFinLinOrd).mapIso I).toEquiv\n\n"}
{"name":"SimplexCategory.SkeletalFunctor.instFullNonemptyFinLinOrdSkeletalFunctor","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"‚ä¢ SimplexCategory.skeletalFunctor.Full","decl":"instance : skeletalFunctor.Full where\n  map_surjective f := ‚ü®SimplexCategory.Hom.mk f, rfl‚ü©\n\n"}
{"name":"SimplexCategory.SkeletalFunctor.instFaithfulNonemptyFinLinOrdSkeletalFunctor","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"‚ä¢ SimplexCategory.skeletalFunctor.Faithful","decl":"instance : skeletalFunctor.Faithful where\n  map_injective {_ _ f g} h := by\n    ext1\n    exact h\n\n"}
{"name":"SimplexCategory.SkeletalFunctor.instEssSurjNonemptyFinLinOrdSkeletalFunctor","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"‚ä¢ SimplexCategory.skeletalFunctor.EssSurj","decl":"instance : skeletalFunctor.EssSurj where\n  mem_essImage X :=\n    ‚ü®mk (Fintype.card X - 1 : ‚Ñï),\n      ‚ü®by\n        have aux : Fintype.card X = Fintype.card X - 1 + 1 :=\n          (Nat.succ_pred_eq_of_pos <| Fintype.card_pos_iff.mpr ‚ü®‚ä•‚ü©).symm\n        let f := monoEquivOfFin X aux\n        have hf := (Finset.univ.orderEmbOfFin aux).strictMono\n        refine\n          { hom := ‚ü®f, hf.monotone‚ü©\n            inv := ‚ü®f.symm, ?_‚ü©\n            hom_inv_id := by ext1; apply f.symm_apply_apply\n            inv_hom_id := by ext1; apply f.apply_symm_apply }\n        intro i j h\n        show f.symm i ‚â§ f.symm j\n        rw [‚Üê hf.le_iff_le]\n        show f (f.symm i) ‚â§ f (f.symm j)\n        simpa only [OrderIso.apply_symm_apply]‚ü©‚ü©\n\n"}
{"name":"SimplexCategory.SkeletalFunctor.isEquivalence","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"‚ä¢ SimplexCategory.skeletalFunctor.IsEquivalence","decl":"noncomputable instance isEquivalence : skeletalFunctor.IsEquivalence where\n\n"}
{"name":"SimplexCategory.isSkeletonOf","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"‚ä¢ CategoryTheory.IsSkeletonOf NonemptyFinLinOrd SimplexCategory SimplexCategory.skeletalFunctor","decl":"/-- `SimplexCategory` is a skeleton of `NonemptyFinLinOrd`.\n-/\nlemma isSkeletonOf :\n    IsSkeletonOf NonemptyFinLinOrd SimplexCategory skeletalFunctor where\n  skel := skeletal\n  eqv := SkeletalFunctor.isEquivalence\n\n"}
{"name":"SimplexCategory.Truncated.instFullInclusion","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\n‚ä¢ (SimplexCategory.Truncated.inclusion n).Full","decl":"instance (n : ‚Ñï) : (inclusion n : Truncated n ‚•§ _).Full := FullSubcategory.full _\n"}
{"name":"SimplexCategory.Truncated.instFaithfulInclusion","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\n‚ä¢ (SimplexCategory.Truncated.inclusion n).Faithful","decl":"instance (n : ‚Ñï) : (inclusion n : Truncated n ‚•§ _).Faithful := FullSubcategory.faithful _\n\n"}
{"name":"SimplexCategory.Truncated.Hom.ext_iff","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\na b : SimplexCategory.Truncated n\nf g : Quiver.Hom a b\n‚ä¢ Iff (Eq f g) (Eq (SimplexCategory.Hom.toOrderHom f) (SimplexCategory.Hom.toOrderHom g))","decl":"@[ext]\ntheorem Hom.ext {n} {a b : Truncated n} (f g : a ‚ü∂ b) :\n    f.toOrderHom = g.toOrderHom ‚Üí f = g := SimplexCategory.Hom.ext _ _\n\n"}
{"name":"SimplexCategory.Truncated.Hom.ext","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\na b : SimplexCategory.Truncated n\nf g : Quiver.Hom a b\na‚úù : Eq (SimplexCategory.Hom.toOrderHom f) (SimplexCategory.Hom.toOrderHom g)\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem Hom.ext {n} {a b : Truncated n} (f g : a ‚ü∂ b) :\n    f.toOrderHom = g.toOrderHom ‚Üí f = g := SimplexCategory.Hom.ext _ _\n\n"}
{"name":"SimplexCategory.mono_iff_injective","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n m : SimplexCategory\nf : Quiver.Hom n m\n‚ä¢ Iff (CategoryTheory.Mono f) (Function.Injective ‚áë(SimplexCategory.Hom.toOrderHom f))","decl":"/-- A morphism in `SimplexCategory` is a monomorphism precisely when it is an injective function\n-/\ntheorem mono_iff_injective {n m : SimplexCategory} {f : n ‚ü∂ m} :\n    Mono f ‚Üî Function.Injective f.toOrderHom := by\n  rw [‚Üê Functor.mono_map_iff_mono skeletalEquivalence.functor]\n  dsimp only [skeletalEquivalence, Functor.asEquivalence_functor]\n  simp only [skeletalFunctor_obj, skeletalFunctor_map,\n    NonemptyFinLinOrd.mono_iff_injective, NonemptyFinLinOrd.coe_of]\n\n"}
{"name":"SimplexCategory.epi_iff_surjective","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n m : SimplexCategory\nf : Quiver.Hom n m\n‚ä¢ Iff (CategoryTheory.Epi f) (Function.Surjective ‚áë(SimplexCategory.Hom.toOrderHom f))","decl":"/-- A morphism in `SimplexCategory` is an epimorphism if and only if it is a surjective function\n-/\ntheorem epi_iff_surjective {n m : SimplexCategory} {f : n ‚ü∂ m} :\n    Epi f ‚Üî Function.Surjective f.toOrderHom := by\n  rw [‚Üê Functor.epi_map_iff_epi skeletalEquivalence.functor]\n  dsimp only [skeletalEquivalence, Functor.asEquivalence_functor]\n  simp only [skeletalFunctor_obj, skeletalFunctor_map,\n    NonemptyFinLinOrd.epi_iff_surjective, NonemptyFinLinOrd.coe_of]\n\n"}
{"name":"SimplexCategory.len_le_of_mono","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x y : SimplexCategory\nf : Quiver.Hom x y\na‚úù : CategoryTheory.Mono f\n‚ä¢ LE.le x.len y.len","decl":"/-- A monomorphism in `SimplexCategory` must increase lengths -/\ntheorem len_le_of_mono {x y : SimplexCategory} {f : x ‚ü∂ y} : Mono f ‚Üí x.len ‚â§ y.len := by\n  intro hyp_f_mono\n  have f_inj : Function.Injective f.toOrderHom.toFun := mono_iff_injective.1 hyp_f_mono\n  simpa using Fintype.card_le_of_injective f.toOrderHom.toFun f_inj\n\n"}
{"name":"SimplexCategory.le_of_mono","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n m : Nat\nf : Quiver.Hom (SimplexCategory.mk n) (SimplexCategory.mk m)\na‚úù : CategoryTheory.Mono f\n‚ä¢ LE.le n m","decl":"theorem le_of_mono {n m : ‚Ñï} {f : ([n] : SimplexCategory) ‚ü∂ [m]} : CategoryTheory.Mono f ‚Üí n ‚â§ m :=\n  len_le_of_mono\n\n"}
{"name":"SimplexCategory.len_le_of_epi","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x y : SimplexCategory\nf : Quiver.Hom x y\na‚úù : CategoryTheory.Epi f\n‚ä¢ LE.le y.len x.len","decl":"/-- An epimorphism in `SimplexCategory` must decrease lengths -/\ntheorem len_le_of_epi {x y : SimplexCategory} {f : x ‚ü∂ y} : Epi f ‚Üí y.len ‚â§ x.len := by\n  intro hyp_f_epi\n  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_epi\n  simpa using Fintype.card_le_of_surjective f.toOrderHom.toFun f_surj\n\n"}
{"name":"SimplexCategory.le_of_epi","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n m : Nat\nf : Quiver.Hom (SimplexCategory.mk n) (SimplexCategory.mk m)\na‚úù : CategoryTheory.Epi f\n‚ä¢ LE.le m n","decl":"theorem le_of_epi {n m : ‚Ñï} {f : ([n] : SimplexCategory) ‚ü∂ [m]} : Epi f ‚Üí m ‚â§ n :=\n  len_le_of_epi\n\n"}
{"name":"SimplexCategory.instMonoŒ¥","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\n‚ä¢ CategoryTheory.Mono (SimplexCategory.Œ¥ i)","decl":"instance {n : ‚Ñï} {i : Fin (n + 2)} : Mono (Œ¥ i) := by\n  rw [mono_iff_injective]\n  exact Fin.succAbove_right_injective\n\n"}
{"name":"SimplexCategory.instEpiœÉ","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ CategoryTheory.Epi (SimplexCategory.œÉ i)","decl":"instance {n : ‚Ñï} {i : Fin (n + 1)} : Epi (œÉ i) := by\n  rw [epi_iff_surjective]\n  intro b\n  simp only [œÉ, mkHom, Hom.toOrderHom_mk, OrderHom.coe_mk]\n  by_cases h : b ‚â§ i\n  ¬∑ use b\n    -- This was not needed before https://github.com/leanprover/lean4/pull/2644\n    dsimp\n    rw [Fin.predAbove_of_le_castSucc i b (by simpa only [Fin.coe_eq_castSucc] using h)]\n    simp only [len_mk, Fin.coe_eq_castSucc, Fin.castPred_castSucc]\n  ¬∑ use b.succ\n    -- This was not needed before https://github.com/leanprover/lean4/pull/2644\n    dsimp\n    rw [Fin.predAbove_of_castSucc_lt i b.succ _, Fin.pred_succ]\n    rw [not_le] at h\n    rw [Fin.lt_iff_val_lt_val] at h ‚ä¢\n    simpa only [Fin.val_succ, Fin.coe_castSucc] using Nat.lt.step h\n\n"}
{"name":"SimplexCategory.instReflectsIsomorphismsForget","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"‚ä¢ (CategoryTheory.forget SimplexCategory).ReflectsIsomorphisms","decl":"instance : (forget SimplexCategory).ReflectsIsomorphisms :=\n  ‚ü®fun f hf =>\n    Iso.isIso_hom\n      { hom := f\n        inv := Hom.mk\n            { toFun := inv ((forget SimplexCategory).map f)\n              monotone' := fun y‚ÇÅ y‚ÇÇ h => by\n                by_cases h' : y‚ÇÅ < y‚ÇÇ\n                ¬∑ by_contra h''\n                  apply not_le.mpr h'\n                  convert f.toOrderHom.monotone (le_of_not_ge h'')\n                  all_goals\n                    exact (congr_hom (Iso.inv_hom_id\n                      (asIso ((forget SimplexCategory).map f))) _).symm\n                ¬∑ rw [eq_of_le_of_not_lt h h'] }\n        hom_inv_id := by\n          ext1\n          ext1\n          exact Iso.hom_inv_id (asIso ((forget _).map f))\n        inv_hom_id := by\n          ext1\n          ext1\n          exact Iso.inv_hom_id (asIso ((forget _).map f)) }‚ü©\n\n"}
{"name":"SimplexCategory.isIso_of_bijective","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x y : SimplexCategory\nf : Quiver.Hom x y\nhf : Function.Bijective (SimplexCategory.Hom.toOrderHom f).toFun\n‚ä¢ CategoryTheory.IsIso f","decl":"theorem isIso_of_bijective {x y : SimplexCategory} {f : x ‚ü∂ y}\n    (hf : Function.Bijective f.toOrderHom.toFun) : IsIso f :=\n  haveI : IsIso ((forget SimplexCategory).map f) := (isIso_iff_bijective _).mpr hf\n  isIso_of_reflects_iso f (forget SimplexCategory)\n\n"}
{"name":"SimplexCategory.iso_eq_iso_refl","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x : SimplexCategory\ne : CategoryTheory.Iso x x\n‚ä¢ Eq e (CategoryTheory.Iso.refl x)","decl":"theorem iso_eq_iso_refl {x : SimplexCategory} (e : x ‚âÖ x) : e = Iso.refl x := by\n  have h : (Finset.univ : Finset (Fin (x.len + 1))).card = x.len + 1 := Finset.card_fin (x.len + 1)\n  have eq‚ÇÅ := Finset.orderEmbOfFin_unique' h fun i => Finset.mem_univ ((orderIsoOfIso e) i)\n  have eq‚ÇÇ :=\n    Finset.orderEmbOfFin_unique' h fun i => Finset.mem_univ ((orderIsoOfIso (Iso.refl x)) i)\n  -- Porting note: the proof was rewritten from this point in https://github.com/leanprover-community/mathlib4/pull/3414 (reenableeta)\n  -- It could be investigated again to see if the original can be restored.\n  ext x\n  replace eq‚ÇÅ := congr_arg (¬∑ x) eq‚ÇÅ\n  replace eq‚ÇÇ := congr_arg (¬∑ x) eq‚ÇÇ.symm\n  simp_all\n\n"}
{"name":"SimplexCategory.eq_id_of_isIso","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x : SimplexCategory\nf : Quiver.Hom x x\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ Eq f (CategoryTheory.CategoryStruct.id x)","decl":"theorem eq_id_of_isIso {x : SimplexCategory} (f : x ‚ü∂ x) [IsIso f] : f = ùüô _ :=\n  congr_arg (fun œÜ : _ ‚âÖ _ => œÜ.hom) (iso_eq_iso_refl (asIso f))\n\n"}
{"name":"SimplexCategory.eq_œÉ_comp_of_not_injective'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nŒî' : SimplexCategory\nŒ∏ : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd n 1)) Œî'\ni : Fin (HAdd.hAdd n 1)\nhi : Eq ((SimplexCategory.Hom.toOrderHom Œ∏) i.castSucc) ((SimplexCategory.Hom.toOrderHom Œ∏) i.succ)\n‚ä¢ Exists fun Œ∏' => Eq Œ∏ (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ i) Œ∏')","decl":"theorem eq_œÉ_comp_of_not_injective' {n : ‚Ñï} {Œî' : SimplexCategory} (Œ∏ : mk (n + 1) ‚ü∂ Œî')\n    (i : Fin (n + 1)) (hi : Œ∏.toOrderHom (Fin.castSucc i) = Œ∏.toOrderHom i.succ) :\n    ‚àÉ Œ∏' : mk n ‚ü∂ Œî', Œ∏ = œÉ i ‚â´ Œ∏' := by\n  use Œ¥ i.succ ‚â´ Œ∏\n  ext1; ext1; ext1 x\n  simp only [len_mk, œÉ, mkHom, comp_toOrderHom, Hom.toOrderHom_mk, OrderHom.comp_coe,\n    OrderHom.coe_mk, Function.comp_apply]\n  by_cases h' : x ‚â§ Fin.castSucc i\n  ¬∑ -- This was not needed before https://github.com/leanprover/lean4/pull/2644\n    dsimp\n    rw [Fin.predAbove_of_le_castSucc i x h']\n    dsimp [Œ¥]\n    rw [Fin.succAbove_of_castSucc_lt _ _ _]\n    ¬∑ rw [Fin.castSucc_castPred]\n    ¬∑ exact (Fin.castSucc_lt_succ_iff.mpr h')\n  ¬∑ simp only [not_le] at h'\n    let y := x.pred <| by rintro (rfl : x = 0); simp at h'\n    have hy : x = y.succ := (Fin.succ_pred x _).symm\n    rw [hy] at h' ‚ä¢\n    -- This was not needed before https://github.com/leanprover/lean4/pull/2644\n    conv_rhs => dsimp\n    rw [Fin.predAbove_of_castSucc_lt i y.succ h', Fin.pred_succ]\n    by_cases h'' : y = i\n    ¬∑ rw [h'']\n      refine hi.symm.trans ?_\n      congr 1\n      dsimp [Œ¥]\n      rw [Fin.succAbove_of_castSucc_lt i.succ]\n      exact Fin.lt_succ\n    ¬∑ dsimp [Œ¥]\n      rw [Fin.succAbove_of_le_castSucc i.succ _]\n      simp only [Fin.lt_iff_val_lt_val, Fin.le_iff_val_le_val, Fin.val_succ, Fin.coe_castSucc,\n        Nat.lt_succ_iff, Fin.ext_iff] at h' h'' ‚ä¢\n      omega\n\n"}
{"name":"SimplexCategory.eq_œÉ_comp_of_not_injective","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nŒî' : SimplexCategory\nŒ∏ : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd n 1)) Œî'\nhŒ∏ : Not (Function.Injective ‚áë(SimplexCategory.Hom.toOrderHom Œ∏))\n‚ä¢ Exists fun i => Exists fun Œ∏' => Eq Œ∏ (CategoryTheory.CategoryStruct.comp (SimplexCategory.œÉ i) Œ∏')","decl":"theorem eq_œÉ_comp_of_not_injective {n : ‚Ñï} {Œî' : SimplexCategory} (Œ∏ : mk (n + 1) ‚ü∂ Œî')\n    (hŒ∏ : ¬¨Function.Injective Œ∏.toOrderHom) :\n    ‚àÉ (i : Fin (n + 1)) (Œ∏' : mk n ‚ü∂ Œî'), Œ∏ = œÉ i ‚â´ Œ∏' := by\n  simp only [Function.Injective, exists_prop, not_forall] at hŒ∏\n  -- as Œ∏ is not injective, there exists `x<y` such that `Œ∏ x = Œ∏ y`\n  -- and then, `Œ∏ x = Œ∏ (x+1)`\n  have hŒ∏‚ÇÇ : ‚àÉ x y : Fin (n + 2), (Hom.toOrderHom Œ∏) x = (Hom.toOrderHom Œ∏) y ‚àß x < y := by\n    rcases hŒ∏ with ‚ü®x, y, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©‚ü©\n    by_cases h : x < y\n    ¬∑ exact ‚ü®x, y, ‚ü®h‚ÇÅ, h‚ü©‚ü©\n    ¬∑ refine ‚ü®y, x, ‚ü®h‚ÇÅ.symm, ?_‚ü©‚ü©\n      rcases lt_or_eq_of_le (not_lt.mp h) with h' | h'\n      ¬∑ exact h'\n      ¬∑ exfalso\n        exact h‚ÇÇ h'.symm\n  rcases hŒ∏‚ÇÇ with ‚ü®x, y, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©‚ü©\n  use x.castPred ((Fin.le_last _).trans_lt' h‚ÇÇ).ne\n  apply eq_œÉ_comp_of_not_injective'\n  apply le_antisymm\n  ¬∑ exact Œ∏.toOrderHom.monotone (le_of_lt (Fin.castSucc_lt_succ _))\n  ¬∑ rw [Fin.castSucc_castPred, h‚ÇÅ]\n    exact Œ∏.toOrderHom.monotone ((Fin.succ_castPred_le_iff _).mpr h‚ÇÇ)\n\n"}
{"name":"SimplexCategory.eq_comp_Œ¥_of_not_surjective'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nŒî : SimplexCategory\nŒ∏ : Quiver.Hom Œî (SimplexCategory.mk (HAdd.hAdd n 1))\ni : Fin (HAdd.hAdd n 2)\nhi : ‚àÄ (x : Fin (HAdd.hAdd Œî.len 1)), Ne ((SimplexCategory.Hom.toOrderHom Œ∏) x) i\n‚ä¢ Exists fun Œ∏' => Eq Œ∏ (CategoryTheory.CategoryStruct.comp Œ∏' (SimplexCategory.Œ¥ i))","decl":"theorem eq_comp_Œ¥_of_not_surjective' {n : ‚Ñï} {Œî : SimplexCategory} (Œ∏ : Œî ‚ü∂ mk (n + 1))\n    (i : Fin (n + 2)) (hi : ‚àÄ x, Œ∏.toOrderHom x ‚â† i) : ‚àÉ Œ∏' : Œî ‚ü∂ mk n, Œ∏ = Œ∏' ‚â´ Œ¥ i := by\n  by_cases h : i < Fin.last (n + 1)\n  ¬∑ use Œ∏ ‚â´ œÉ (Fin.castPred i h.ne)\n    ext1\n    ext1\n    ext1 x\n    simp only [len_mk, Category.assoc, comp_toOrderHom, OrderHom.comp_coe, Function.comp_apply]\n    by_cases h' : Œ∏.toOrderHom x ‚â§ i\n    ¬∑ simp only [œÉ, mkHom, Hom.toOrderHom_mk, OrderHom.coe_mk]\n      rw [Fin.predAbove_of_le_castSucc _ _ (by rwa [Fin.castSucc_castPred])]\n      dsimp [Œ¥]\n      rw [Fin.succAbove_of_castSucc_lt i]\n      ¬∑ rw [Fin.castSucc_castPred]\n      ¬∑ rw [(hi x).le_iff_lt] at h'\n        exact h'\n    ¬∑ simp only [not_le] at h'\n      dsimp [œÉ, Œ¥]\n      rw [Fin.predAbove_of_castSucc_lt _ _ (by rwa [Fin.castSucc_castPred])]\n      rw [Fin.succAbove_of_le_castSucc i _]\n      ¬∑ rw [Fin.succ_pred]\n      ¬∑ exact Nat.le_sub_one_of_lt (Fin.lt_iff_val_lt_val.mp h')\n  ¬∑ obtain rfl := le_antisymm (Fin.le_last i) (not_lt.mp h)\n    use Œ∏ ‚â´ œÉ (Fin.last _)\n    ext x : 3\n    dsimp [Œ¥, œÉ]\n    simp_rw [Fin.succAbove_last, Fin.predAbove_last_apply]\n    erw [dif_neg (hi x)]\n    rw [Fin.castSucc_castPred]\n\n"}
{"name":"SimplexCategory.eq_comp_Œ¥_of_not_surjective","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nŒî : SimplexCategory\nŒ∏ : Quiver.Hom Œî (SimplexCategory.mk (HAdd.hAdd n 1))\nhŒ∏ : Not (Function.Surjective ‚áë(SimplexCategory.Hom.toOrderHom Œ∏))\n‚ä¢ Exists fun i => Exists fun Œ∏' => Eq Œ∏ (CategoryTheory.CategoryStruct.comp Œ∏' (SimplexCategory.Œ¥ i))","decl":"theorem eq_comp_Œ¥_of_not_surjective {n : ‚Ñï} {Œî : SimplexCategory} (Œ∏ : Œî ‚ü∂ mk (n + 1))\n    (hŒ∏ : ¬¨Function.Surjective Œ∏.toOrderHom) :\n    ‚àÉ (i : Fin (n + 2)) (Œ∏' : Œî ‚ü∂ mk n), Œ∏ = Œ∏' ‚â´ Œ¥ i := by\n  cases' not_forall.mp hŒ∏ with i hi\n  use i\n  exact eq_comp_Œ¥_of_not_surjective' Œ∏ i (not_exists.mp hi)\n\n"}
{"name":"SimplexCategory.eq_id_of_mono","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x : SimplexCategory\ni : Quiver.Hom x x\ninst‚úù : CategoryTheory.Mono i\n‚ä¢ Eq i (CategoryTheory.CategoryStruct.id x)","decl":"theorem eq_id_of_mono {x : SimplexCategory} (i : x ‚ü∂ x) [Mono i] : i = ùüô _ := by\n  suffices IsIso i by\n    apply eq_id_of_isIso\n  apply isIso_of_bijective\n  dsimp\n  rw [Fintype.bijective_iff_injective_and_card i.toOrderHom, ‚Üê mono_iff_injective,\n    eq_self_iff_true, and_true]\n  infer_instance\n\n"}
{"name":"SimplexCategory.eq_id_of_epi","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x : SimplexCategory\ni : Quiver.Hom x x\ninst‚úù : CategoryTheory.Epi i\n‚ä¢ Eq i (CategoryTheory.CategoryStruct.id x)","decl":"theorem eq_id_of_epi {x : SimplexCategory} (i : x ‚ü∂ x) [Epi i] : i = ùüô _ := by\n  suffices IsIso i by\n    haveI := this\n    apply eq_id_of_isIso\n  apply isIso_of_bijective\n  dsimp\n  rw [Fintype.bijective_iff_surjective_and_card i.toOrderHom, ‚Üê epi_iff_surjective,\n    eq_self_iff_true, and_true]\n  infer_instance\n\n"}
{"name":"SimplexCategory.eq_œÉ_of_epi","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nŒ∏ : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd n 1)) (SimplexCategory.mk n)\ninst‚úù : CategoryTheory.Epi Œ∏\n‚ä¢ Exists fun i => Eq Œ∏ (SimplexCategory.œÉ i)","decl":"theorem eq_œÉ_of_epi {n : ‚Ñï} (Œ∏ : mk (n + 1) ‚ü∂ mk n) [Epi Œ∏] : ‚àÉ i : Fin (n + 1), Œ∏ = œÉ i := by\n  rcases eq_œÉ_comp_of_not_injective Œ∏ (by\n    by_contra h\n    simpa using le_of_mono (mono_iff_injective.mpr h)) with ‚ü®i, Œ∏', h‚ü©\n  use i\n  haveI : Epi (œÉ i ‚â´ Œ∏') := by\n    rw [‚Üê h]\n    infer_instance\n  haveI := CategoryTheory.epi_of_epi (œÉ i) Œ∏'\n  rw [h, eq_id_of_epi Œ∏', Category.comp_id]\n\n"}
{"name":"SimplexCategory.eq_Œ¥_of_mono","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nŒ∏ : Quiver.Hom (SimplexCategory.mk n) (SimplexCategory.mk (HAdd.hAdd n 1))\ninst‚úù : CategoryTheory.Mono Œ∏\n‚ä¢ Exists fun i => Eq Œ∏ (SimplexCategory.Œ¥ i)","decl":"theorem eq_Œ¥_of_mono {n : ‚Ñï} (Œ∏ : mk n ‚ü∂ mk (n + 1)) [Mono Œ∏] : ‚àÉ i : Fin (n + 2), Œ∏ = Œ¥ i := by\n  rcases eq_comp_Œ¥_of_not_surjective Œ∏ (by\n    by_contra h\n    simpa using le_of_epi (epi_iff_surjective.mpr h)) with ‚ü®i, Œ∏', h‚ü©\n  use i\n  haveI : Mono (Œ∏' ‚â´ Œ¥ i) := by\n    rw [‚Üê h]\n    infer_instance\n  haveI := CategoryTheory.mono_of_mono Œ∏' (Œ¥ i)\n  rw [h, eq_id_of_mono Œ∏', Category.id_comp]\n\n"}
{"name":"SimplexCategory.len_lt_of_mono","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Œî' Œî : SimplexCategory\ni : Quiver.Hom Œî' Œî\nhi : CategoryTheory.Mono i\nhi' : Ne Œî Œî'\n‚ä¢ LT.lt Œî'.len Œî.len","decl":"theorem len_lt_of_mono {Œî' Œî : SimplexCategory} (i : Œî' ‚ü∂ Œî) [hi : Mono i] (hi' : Œî ‚â† Œî') :\n    Œî'.len < Œî.len := by\n  rcases lt_or_eq_of_le (len_le_of_mono hi) with (h | h)\n  ¬∑ exact h\n  ¬∑ exfalso\n    exact hi' (by ext; exact h.symm)\n\n"}
{"name":"SimplexCategory.instSplitEpiCategory","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"‚ä¢ CategoryTheory.SplitEpiCategory SimplexCategory","decl":"noncomputable instance : SplitEpiCategory SimplexCategory :=\n  skeletalEquivalence.inverse.splitEpiCategoryImpOfIsEquivalence\n\n"}
{"name":"SimplexCategory.instHasStrongEpiMonoFactorisations","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"‚ä¢ CategoryTheory.Limits.HasStrongEpiMonoFactorisations SimplexCategory","decl":"instance : HasStrongEpiMonoFactorisations SimplexCategory :=\n  Functor.hasStrongEpiMonoFactorisations_imp_of_isEquivalence\n    SimplexCategory.skeletalEquivalence.inverse\n\n"}
{"name":"SimplexCategory.instHasStrongEpiImages","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"‚ä¢ CategoryTheory.Limits.HasStrongEpiImages SimplexCategory","decl":"instance : HasStrongEpiImages SimplexCategory :=\n  Limits.hasStrongEpiImages_of_hasStrongEpiMonoFactorisations\n\n"}
{"name":"SimplexCategory.instEpiFactorThruImage","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Œî Œî' : SimplexCategory\nŒ∏ : Quiver.Hom Œî Œî'\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.factorThruImage Œ∏)","decl":"instance (Œî Œî' : SimplexCategory) (Œ∏ : Œî ‚ü∂ Œî') : Epi (factorThruImage Œ∏) :=\n  StrongEpi.epi\n\n"}
{"name":"SimplexCategory.image_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Œî Œî' Œî'' : SimplexCategory\nœÜ : Quiver.Hom Œî Œî''\ne : Quiver.Hom Œî Œî'\ninst‚úù¬π : CategoryTheory.Epi e\ni : Quiver.Hom Œî' Œî''\ninst‚úù : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) œÜ\n‚ä¢ Eq (CategoryTheory.Limits.image œÜ) Œî'","decl":"theorem image_eq {Œî Œî' Œî'' : SimplexCategory} {œÜ : Œî ‚ü∂ Œî''} {e : Œî ‚ü∂ Œî'} [Epi e] {i : Œî' ‚ü∂ Œî''}\n    [Mono i] (fac : e ‚â´ i = œÜ) : image œÜ = Œî' := by\n  haveI := strongEpi_of_epi e\n  let e := image.isoStrongEpiMono e i fac\n  ext\n  exact\n    le_antisymm (len_le_of_epi (inferInstance : Epi e.hom))\n      (len_le_of_mono (inferInstance : Mono e.hom))\n\n"}
{"name":"SimplexCategory.image_Œπ_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Œî Œî'' : SimplexCategory\nœÜ : Quiver.Hom Œî Œî''\ne : Quiver.Hom Œî (CategoryTheory.Limits.image œÜ)\ninst‚úù¬π : CategoryTheory.Epi e\ni : Quiver.Hom (CategoryTheory.Limits.image œÜ) Œî''\ninst‚úù : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) œÜ\n‚ä¢ Eq (CategoryTheory.Limits.image.Œπ œÜ) i","decl":"theorem image_Œπ_eq {Œî Œî'' : SimplexCategory} {œÜ : Œî ‚ü∂ Œî''} {e : Œî ‚ü∂ image œÜ} [Epi e]\n    {i : image œÜ ‚ü∂ Œî''} [Mono i] (fac : e ‚â´ i = œÜ) : image.Œπ œÜ = i := by\n  haveI := strongEpi_of_epi e\n  rw [‚Üê image.isoStrongEpiMono_hom_comp_Œπ e i fac,\n    SimplexCategory.eq_id_of_isIso (image.isoStrongEpiMono e i fac).hom, Category.id_comp]\n\n"}
{"name":"SimplexCategory.factorThruImage_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Œî Œî'' : SimplexCategory\nœÜ : Quiver.Hom Œî Œî''\ne : Quiver.Hom Œî (CategoryTheory.Limits.image œÜ)\ninst‚úù¬π : CategoryTheory.Epi e\ni : Quiver.Hom (CategoryTheory.Limits.image œÜ) Œî''\ninst‚úù : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) œÜ\n‚ä¢ Eq (CategoryTheory.Limits.factorThruImage œÜ) e","decl":"theorem factorThruImage_eq {Œî Œî'' : SimplexCategory} {œÜ : Œî ‚ü∂ Œî''} {e : Œî ‚ü∂ image œÜ} [Epi e]\n    {i : image œÜ ‚ü∂ Œî''} [Mono i] (fac : e ‚â´ i = œÜ) : factorThruImage œÜ = e := by\n  rw [‚Üê cancel_mono i, fac, ‚Üê image_Œπ_eq fac, image.fac]\n\n"}
{"name":"SimplexCategory.toCat_map","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"X‚úù Y‚úù : SimplexCategory\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (SimplexCategory.toCat.map f) ‚ãØ.functor","decl":"/-- This functor `SimplexCategory ‚•§ Cat` sends `[n]` (for `n : ‚Ñï`)\nto the category attached to the ordered set `{0, 1, ..., n}` -/\n@[simps! obj map]\ndef toCat : SimplexCategory ‚•§ Cat.{0} :=\n  SimplexCategory.skeletalFunctor ‚ãô forget‚ÇÇ NonemptyFinLinOrd LinOrd ‚ãô\n      forget‚ÇÇ LinOrd Lat ‚ãô forget‚ÇÇ Lat PartOrd ‚ãô\n      forget‚ÇÇ PartOrd Preord ‚ãô preordToCat\n\n"}
{"name":"SimplexCategory.toCat_obj","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"X : SimplexCategory\n‚ä¢ Eq (SimplexCategory.toCat.obj X) (CategoryTheory.Cat.of ‚Üë((CategoryTheory.forget‚ÇÇ PartOrd Preord).obj ((CategoryTheory.forget‚ÇÇ Lat PartOrd).obj ((CategoryTheory.forget‚ÇÇ LinOrd Lat).obj ((CategoryTheory.forget‚ÇÇ NonemptyFinLinOrd LinOrd).obj (NonemptyFinLinOrd.of (Fin (HAdd.hAdd X.len 1))))))))","decl":"/-- This functor `SimplexCategory ‚•§ Cat` sends `[n]` (for `n : ‚Ñï`)\nto the category attached to the ordered set `{0, 1, ..., n}` -/\n@[simps! obj map]\ndef toCat : SimplexCategory ‚•§ Cat.{0} :=\n  SimplexCategory.skeletalFunctor ‚ãô forget‚ÇÇ NonemptyFinLinOrd LinOrd ‚ãô\n      forget‚ÇÇ LinOrd Lat ‚ãô forget‚ÇÇ Lat PartOrd ‚ãô\n      forget‚ÇÇ PartOrd Preord ‚ãô preordToCat\n\n"}
