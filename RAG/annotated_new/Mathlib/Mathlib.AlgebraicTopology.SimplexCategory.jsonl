{"name":"SimplexCategory.ext","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\na✝ : Eq a.len b.len\n⊢ Eq a b","decl":"@[ext]\ntheorem ext (a b : SimplexCategory) : a.len = b.len → a = b :=\n  id\n\n"}
{"name":"SimplexCategory.ext_iff","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\n⊢ Iff (Eq a b) (Eq a.len b.len)","decl":"@[ext]\ntheorem ext (a b : SimplexCategory) : a.len = b.len → a = b :=\n  id\n\n"}
{"name":"SimplexCategory.len_mk","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\n⊢ Eq (SimplexCategory.mk n).len n","decl":"@[simp]\ntheorem len_mk (n : ℕ) : [n].len = n :=\n  rfl\n\n"}
{"name":"SimplexCategory.mk_len","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : SimplexCategory\n⊢ Eq (SimplexCategory.mk n.len) n","decl":"@[simp]\ntheorem mk_len (n : SimplexCategory) : ([n.len] : SimplexCategory) = n :=\n  rfl\n\n"}
{"name":"SimplexCategory.Hom.ext'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\nf g : a.Hom b\na✝ : Eq f.toOrderHom g.toOrderHom\n⊢ Eq f g","decl":"theorem ext' {a b : SimplexCategory} (f g : SimplexCategory.Hom a b) :\n    f.toOrderHom = g.toOrderHom → f = g :=\n  id\n\n"}
{"name":"SimplexCategory.Hom.mk_toOrderHom","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\nf : a.Hom b\n⊢ Eq (SimplexCategory.Hom.mk f.toOrderHom) f","decl":"@[simp]\ntheorem mk_toOrderHom {a b : SimplexCategory} (f : SimplexCategory.Hom a b) : mk f.toOrderHom = f :=\n  rfl\n\n"}
{"name":"SimplexCategory.Hom.toOrderHom_mk","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\nf : OrderHom (Fin (HAdd.hAdd a.len 1)) (Fin (HAdd.hAdd b.len 1))\n⊢ Eq (SimplexCategory.Hom.mk f).toOrderHom f","decl":"@[simp]\ntheorem toOrderHom_mk {a b : SimplexCategory} (f : Fin (a.len + 1) →o Fin (b.len + 1)) :\n    (mk f).toOrderHom = f :=\n  rfl\n\n"}
{"name":"SimplexCategory.Hom.mk_toOrderHom_apply","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\nf : OrderHom (Fin (HAdd.hAdd a.len 1)) (Fin (HAdd.hAdd b.len 1))\ni : Fin (HAdd.hAdd a.len 1)\n⊢ Eq ((SimplexCategory.Hom.mk f).toOrderHom i) (f i)","decl":"theorem mk_toOrderHom_apply {a b : SimplexCategory} (f : Fin (a.len + 1) →o Fin (b.len + 1))\n    (i : Fin (a.len + 1)) : (mk f).toOrderHom i = f i :=\n  rfl\n\n"}
{"name":"SimplexCategory.id_toOrderHom","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a : SimplexCategory\n⊢ Eq (SimplexCategory.Hom.toOrderHom (CategoryTheory.CategoryStruct.id a)) OrderHom.id","decl":"@[simp]\nlemma id_toOrderHom (a : SimplexCategory) :\n    Hom.toOrderHom (𝟙 a) = OrderHom.id := rfl\n\n"}
{"name":"SimplexCategory.comp_toOrderHom","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b c : SimplexCategory\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n⊢ Eq (SimplexCategory.Hom.toOrderHom (CategoryTheory.CategoryStruct.comp f g)) ((SimplexCategory.Hom.toOrderHom g).comp (SimplexCategory.Hom.toOrderHom f))","decl":"@[simp]\nlemma comp_toOrderHom {a b c : SimplexCategory} (f : a ⟶ b) (g : b ⟶ c) :\n    (f ≫ g).toOrderHom = g.toOrderHom.comp f.toOrderHom := rfl\n\n"}
{"name":"SimplexCategory.Hom.ext","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\nf g : Quiver.Hom a b\na✝ : Eq (SimplexCategory.Hom.toOrderHom f) (SimplexCategory.Hom.toOrderHom g)\n⊢ Eq f g","decl":"@[ext]\ntheorem Hom.ext {a b : SimplexCategory} (f g : a ⟶ b) :\n    f.toOrderHom = g.toOrderHom → f = g :=\n  Hom.ext' _ _\n\n"}
{"name":"SimplexCategory.Hom.ext_iff","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a b : SimplexCategory\nf g : Quiver.Hom a b\n⊢ Iff (Eq f g) (Eq (SimplexCategory.Hom.toOrderHom f) (SimplexCategory.Hom.toOrderHom g))","decl":"@[ext]\ntheorem Hom.ext {a b : SimplexCategory} (f g : a ⟶ b) :\n    f.toOrderHom = g.toOrderHom → f = g :=\n  Hom.ext' _ _\n\n"}
{"name":"SimplexCategory.const_eq_id","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"⊢ Eq ((SimplexCategory.mk 0).const (SimplexCategory.mk 0) 0) (CategoryTheory.CategoryStruct.id (SimplexCategory.mk 0))","decl":"@[simp]\nlemma const_eq_id : const [0] [0] 0 = 𝟙 _ := by aesop\n\n"}
{"name":"SimplexCategory.const_apply","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x y : SimplexCategory\ni : Fin (HAdd.hAdd y.len 1)\na : Fin (HAdd.hAdd x.len 1)\n⊢ Eq ((SimplexCategory.Hom.toOrderHom (x.const y i)) a) i","decl":"@[simp]\nlemma const_apply (x y : SimplexCategory) (i : Fin (y.len + 1)) (a : Fin (x.len + 1)) :\n    (const x y i).toOrderHom a = i := rfl\n\n"}
{"name":"SimplexCategory.const_comp","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x y z : SimplexCategory\nf : Quiver.Hom y z\ni : Fin (HAdd.hAdd y.len 1)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (x.const y i) f) (x.const z ((SimplexCategory.Hom.toOrderHom f) i))","decl":"@[simp]\ntheorem const_comp (x : SimplexCategory) {y z : SimplexCategory}\n    (f : y ⟶ z) (i : Fin (y.len + 1)) :\n    const x y i ≫ f = const x z (f.toOrderHom i) :=\n  rfl\n\n"}
{"name":"SimplexCategory.const_fac_thru_zero","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n m : SimplexCategory\ni : Fin (HAdd.hAdd m.len 1)\n⊢ Eq (n.const m i) (CategoryTheory.CategoryStruct.comp (n.const (SimplexCategory.mk 0) 0) ((SimplexCategory.mk 0).const m i))","decl":"theorem const_fac_thru_zero (n m : SimplexCategory) (i : Fin (m.len + 1)) :\n    const n m i = const n [0] 0 ≫ SimplexCategory.const [0] m i := by\n  rw [const_comp]; rfl\n\n"}
{"name":"SimplexCategory.Hom.ext_zero_left","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : SimplexCategory\nf g : Quiver.Hom (SimplexCategory.mk 0) n\nh0 : autoParam (Eq ((SimplexCategory.Hom.toOrderHom f) 0) ((SimplexCategory.Hom.toOrderHom g) 0)) _auto✝\n⊢ Eq f g","decl":"theorem Hom.ext_zero_left {n : SimplexCategory} (f g : ([0] : SimplexCategory) ⟶ n)\n    (h0 : f.toOrderHom 0 = g.toOrderHom 0 := by rfl) : f = g := by\n  ext i; match i with | 0 => exact h0 ▸ rfl\n\n"}
{"name":"SimplexCategory.eq_const_of_zero","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : SimplexCategory\nf : Quiver.Hom (SimplexCategory.mk 0) n\n⊢ Eq f ((SimplexCategory.mk 0).const n ((SimplexCategory.Hom.toOrderHom f) 0))","decl":"theorem eq_const_of_zero {n : SimplexCategory} (f : ([0] : SimplexCategory) ⟶ n) :\n    f = const _ n (f.toOrderHom 0) := by\n  ext x; match x with | 0 => rfl\n\n"}
{"name":"SimplexCategory.exists_eq_const_of_zero","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : SimplexCategory\nf : Quiver.Hom (SimplexCategory.mk 0) n\n⊢ Exists fun a => Eq f ((SimplexCategory.mk 0).const n a)","decl":"theorem exists_eq_const_of_zero {n : SimplexCategory} (f : ([0] : SimplexCategory) ⟶ n) :\n    ∃ a, f = const _ n a := ⟨_, eq_const_of_zero _⟩\n\n"}
{"name":"SimplexCategory.eq_const_to_zero","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : SimplexCategory\nf : Quiver.Hom n (SimplexCategory.mk 0)\n⊢ Eq f (n.const (SimplexCategory.mk 0) 0)","decl":"theorem eq_const_to_zero {n : SimplexCategory} (f : n ⟶ [0]) :\n    f = const n _ 0 := by\n  ext : 3\n  apply @Subsingleton.elim (Fin 1)\n\n"}
{"name":"SimplexCategory.Hom.ext_one_left","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : SimplexCategory\nf g : Quiver.Hom (SimplexCategory.mk 1) n\nh0 : autoParam (Eq ((SimplexCategory.Hom.toOrderHom f) 0) ((SimplexCategory.Hom.toOrderHom g) 0)) _auto✝\nh1 : autoParam (Eq ((SimplexCategory.Hom.toOrderHom f) 1) ((SimplexCategory.Hom.toOrderHom g) 1)) _auto✝\n⊢ Eq f g","decl":"theorem Hom.ext_one_left {n : SimplexCategory} (f g : ([1] : SimplexCategory) ⟶ n)\n    (h0 : f.toOrderHom 0 = g.toOrderHom 0 := by rfl)\n    (h1 : f.toOrderHom 1 = g.toOrderHom 1 := by rfl) : f = g := by\n  ext i\n  match i with\n  | 0 => exact h0 ▸ rfl\n  | 1 => exact h1 ▸ rfl\n\n"}
{"name":"SimplexCategory.eq_of_one_to_one","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"f : Quiver.Hom (SimplexCategory.mk 1) (SimplexCategory.mk 1)\n⊢ Or (Exists fun a => Eq f ((SimplexCategory.mk 1).const (SimplexCategory.mk 1) a)) (Eq f (CategoryTheory.CategoryStruct.id (SimplexCategory.mk 1)))","decl":"theorem eq_of_one_to_one (f : ([1] : SimplexCategory) ⟶ [1]) :\n    (∃ a, f = const [1] _ a) ∨ f = 𝟙 _ := by\n  match e0 : f.toOrderHom 0, e1 : f.toOrderHom 1 with\n  | 0, 0 | 1, 1 =>\n    refine .inl ⟨f.toOrderHom 0, ?_⟩\n    ext i : 3\n    match i with\n    | 0 => rfl\n    | 1 => exact e1.trans e0.symm\n  | 0, 1 =>\n    right\n    ext i : 3\n    match i with\n    | 0 => exact e0\n    | 1 => exact e1\n  | 1, 0 =>\n    have := f.toOrderHom.monotone (by decide : (0 : Fin 2) ≤ 1)\n    rw [e0, e1] at this\n    exact Not.elim (by decide) this\n\n\n"}
{"name":"SimplexCategory.mkOfLe_refl","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nj : Fin (HAdd.hAdd n 1)\n⊢ Eq (SimplexCategory.mkOfLe j j ⋯) ((SimplexCategory.mk 1).const (SimplexCategory.mk n) j)","decl":"@[simp]\nlemma mkOfLe_refl {n} (j : Fin (n + 1)) :\n    mkOfLe j j (by omega) = [1].const [n] j := Hom.ext_one_left _ _\n\n"}
{"name":"SimplexCategory.mkOfSucc_homToOrderHom_zero","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq ((SimplexCategory.Hom.toOrderHom (SimplexCategory.mkOfSucc i)) 0) i.castSucc","decl":"@[simp]\nlemma mkOfSucc_homToOrderHom_zero {n} (i : Fin n) :\n    DFunLike.coe (F := Fin 2 →o Fin (n+1)) (Hom.toOrderHom (mkOfSucc i)) 0 = i.castSucc := rfl\n\n"}
{"name":"SimplexCategory.mkOfSucc_homToOrderHom_one","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq ((SimplexCategory.Hom.toOrderHom (SimplexCategory.mkOfSucc i)) 1) i.succ","decl":"@[simp]\nlemma mkOfSucc_homToOrderHom_one {n} (i : Fin n) :\n    DFunLike.coe (F := Fin 2 →o Fin (n+1)) (Hom.toOrderHom (mkOfSucc i)) 1 = i.succ := rfl\n\n\n"}
{"name":"SimplexCategory.const_subinterval_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n j l : Nat\nhjl : LE.le (HAdd.hAdd j l) n\ni : Fin (HAdd.hAdd l 1)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((SimplexCategory.mk 0).const (SimplexCategory.mk l) i) (SimplexCategory.subinterval j l hjl)) ((SimplexCategory.mk 0).const (SimplexCategory.mk n) ⟨HAdd.hAdd j ↑i, ⋯⟩)","decl":"lemma const_subinterval_eq {n} (j l : ℕ) (hjl : j + l ≤ n) (i : Fin (l + 1)) :\n    [0].const [l] i ≫ subinterval j l hjl =\n    [0].const [n] ⟨j + i.1, lt_add_of_lt_add_right (Nat.add_lt_add_left i.2 j) hjl⟩  := by\n  rw [const_comp]\n  congr\n  ext\n  dsimp [subinterval]\n  rw [add_comm]\n\n"}
{"name":"SimplexCategory.mkOfSucc_subinterval_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n j l : Nat\nhjl : LE.le (HAdd.hAdd j l) n\ni : Fin l\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.mkOfSucc i) (SimplexCategory.subinterval j l hjl)) (SimplexCategory.mkOfSucc ⟨HAdd.hAdd j ↑i, ⋯⟩)","decl":"@[simp]\nlemma mkOfSucc_subinterval_eq {n} (j l : ℕ) (hjl : j + l ≤ n) (i : Fin l) :\n    mkOfSucc i ≫ subinterval j l hjl =\n    mkOfSucc ⟨j + i.1, Nat.lt_of_lt_of_le (Nat.add_lt_add_left i.2 j) hjl⟩ := by\n  unfold subinterval mkOfSucc\n  ext i\n  match i with\n  | 0 =>\n    simp only [len_mk, Nat.reduceAdd, mkHom, comp_toOrderHom, Hom.toOrderHom_mk,\n      OrderHom.mk_comp_mk, Fin.isValue, OrderHom.coe_mk, Function.comp_apply, Fin.castSucc_mk,\n      Fin.succ_mk]\n    rw [add_comm]\n    rfl\n  | 1 =>\n    simp only [len_mk, Nat.reduceAdd, mkHom, comp_toOrderHom, Hom.toOrderHom_mk,\n      OrderHom.mk_comp_mk, Fin.isValue, OrderHom.coe_mk, Function.comp_apply, Fin.castSucc_mk,\n      Fin.succ_mk]\n    rw [← Nat.add_comm j _]\n    rfl\n\n"}
{"name":"SimplexCategory.diag_subinterval_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n j l : Nat\nhjl : LE.le (HAdd.hAdd j l) n\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.diag l) (SimplexCategory.subinterval j l hjl)) (SimplexCategory.intervalEdge j l hjl)","decl":"@[simp]\nlemma diag_subinterval_eq {n} (j l : ℕ) (hjl : j + l ≤ n) :\n    diag l ≫ subinterval j l hjl = intervalEdge j l hjl := by\n  unfold subinterval intervalEdge diag mkOfLe\n  ext i\n  match i with\n  | 0 =>\n    simp only [len_mk, Nat.reduceAdd, mkHom, Fin.natCast_eq_last, comp_toOrderHom,\n      Hom.toOrderHom_mk, OrderHom.mk_comp_mk, Fin.isValue, OrderHom.coe_mk, Function.comp_apply]\n    rw [Nat.add_comm]\n    rfl\n  | 1 =>\n    simp only [len_mk, Nat.reduceAdd, mkHom, Fin.natCast_eq_last, comp_toOrderHom,\n      Hom.toOrderHom_mk, OrderHom.mk_comp_mk, Fin.isValue, OrderHom.coe_mk, Function.comp_apply]\n    rw [Nat.add_comm]\n    rfl\n\n"}
{"name":"SimplexCategory.instSubsingletonHomMkOfNatNat","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Δ : SimplexCategory\n⊢ Subsingleton (Quiver.Hom Δ (SimplexCategory.mk 0))","decl":"instance (Δ : SimplexCategory) : Subsingleton (Δ ⟶ [0]) where\n  allEq f g := by ext : 3; apply Subsingleton.elim (α := Fin 1)\n\n"}
{"name":"SimplexCategory.hom_zero_zero","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"f : Quiver.Hom (SimplexCategory.mk 0) (SimplexCategory.mk 0)\n⊢ Eq f (CategoryTheory.CategoryStruct.id (SimplexCategory.mk 0))","decl":"theorem hom_zero_zero (f : ([0] : SimplexCategory) ⟶ [0]) : f = 𝟙 _ := by\n  apply Subsingleton.elim\n\n"}
{"name":"SimplexCategory.δ_comp_δ","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni j : Fin (HAdd.hAdd n 2)\nH : LE.le i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) (SimplexCategory.δ j.succ)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ j) (SimplexCategory.δ i.castSucc))","decl":"/-- The generic case of the first simplicial identity -/\ntheorem δ_comp_δ {n} {i j : Fin (n + 2)} (H : i ≤ j) :\n    δ i ≫ δ j.succ = δ j ≫ δ i.castSucc := by\n  ext k\n  dsimp [δ, Fin.succAbove]\n  rcases i with ⟨i, _⟩\n  rcases j with ⟨j, _⟩\n  rcases k with ⟨k, _⟩\n  split_ifs <;> · simp at * <;> omega\n\n"}
{"name":"SimplexCategory.δ_comp_δ'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : LT.lt i.castSucc j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) (SimplexCategory.δ j)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ (j.pred ⋯)) (SimplexCategory.δ i.castSucc))","decl":"theorem δ_comp_δ' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : i.castSucc < j) :\n    δ i ≫ δ j =\n      δ (j.pred fun (hj : j = 0) => by simp [hj, Fin.not_lt_zero] at H) ≫\n        δ (Fin.castSucc i) := by\n  rw [← δ_comp_δ]\n  · rw [Fin.succ_pred]\n  · simpa only [Fin.le_iff_val_le_val, ← Nat.lt_succ_iff, Nat.succ_eq_add_one, ← Fin.val_succ,\n      j.succ_pred, Fin.lt_iff_val_lt_val] using H\n\n"}
{"name":"SimplexCategory.δ_comp_δ''","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LE.le i j.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ (i.castLT ⋯)) (SimplexCategory.δ j.succ)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ j) (SimplexCategory.δ i))","decl":"theorem δ_comp_δ'' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : i ≤ Fin.castSucc j) :\n    δ (i.castLT (Nat.lt_of_le_of_lt (Fin.le_iff_val_le_val.mp H) j.is_lt)) ≫ δ j.succ =\n      δ j ≫ δ i := by\n  rw [δ_comp_δ]\n  · rfl\n  · exact H\n\n"}
{"name":"SimplexCategory.δ_comp_δ_self","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) (SimplexCategory.δ i.castSucc)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) (SimplexCategory.δ i.succ))","decl":"/-- The special case of the first simplicial identity -/\n@[reassoc]\ntheorem δ_comp_δ_self {n} {i : Fin (n + 2)} : δ i ≫ δ i.castSucc = δ i ≫ δ i.succ :=\n  (δ_comp_δ (le_refl i)).symm\n\n"}
{"name":"SimplexCategory.δ_comp_δ_self_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i.castSucc) h)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i.succ) h))","decl":"/-- The special case of the first simplicial identity -/\n@[reassoc]\ntheorem δ_comp_δ_self {n} {i : Fin (n + 2)} : δ i ≫ δ i.castSucc = δ i ≫ δ i.succ :=\n  (δ_comp_δ (le_refl i)).symm\n\n"}
{"name":"SimplexCategory.δ_comp_δ_self'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : Eq j i.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) (SimplexCategory.δ j)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) (SimplexCategory.δ i.succ))","decl":"@[reassoc]\ntheorem δ_comp_δ_self' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : j = i.castSucc) :\n    δ i ≫ δ j = δ i ≫ δ i.succ := by\n  subst H\n  rw [δ_comp_δ_self]\n\n"}
{"name":"SimplexCategory.δ_comp_δ_self'_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : Eq j i.castSucc\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ j) h)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i.succ) h))","decl":"@[reassoc]\ntheorem δ_comp_δ_self' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : j = i.castSucc) :\n    δ i ≫ δ j = δ i ≫ δ i.succ := by\n  subst H\n  rw [δ_comp_δ_self]\n\n"}
{"name":"SimplexCategory.δ_comp_σ_of_le_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LE.le i j.castSucc\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd n 1)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i.castSucc) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ j.succ) h)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ j) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) h))","decl":"/-- The second simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ j.castSucc) :\n    δ i.castSucc ≫ σ j.succ = σ j ≫ δ i := by\n  ext k : 3\n  dsimp [σ, δ]\n  rcases le_or_lt i k with (hik | hik)\n  · rw [Fin.succAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hik),\n    Fin.succ_predAbove_succ, Fin.succAbove_of_le_castSucc]\n    rcases le_or_lt k (j.castSucc) with (hjk | hjk)\n    · rwa [Fin.predAbove_of_le_castSucc _ _ hjk, Fin.castSucc_castPred]\n    · rw [Fin.le_castSucc_iff, Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succ_pred]\n      exact H.trans_lt hjk\n  · rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hik)]\n    have hjk := H.trans_lt' hik\n    rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr\n      (hjk.trans (Fin.castSucc_lt_succ _)).le),\n      Fin.predAbove_of_le_castSucc _ _ hjk.le, Fin.castPred_castSucc, Fin.succAbove_of_castSucc_lt,\n      Fin.castSucc_castPred]\n    rwa [Fin.castSucc_castPred]\n\n"}
{"name":"SimplexCategory.δ_comp_σ_of_le","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LE.le i j.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i.castSucc) (SimplexCategory.σ j.succ)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ j) (SimplexCategory.δ i))","decl":"/-- The second simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ j.castSucc) :\n    δ i.castSucc ≫ σ j.succ = σ j ≫ δ i := by\n  ext k : 3\n  dsimp [σ, δ]\n  rcases le_or_lt i k with (hik | hik)\n  · rw [Fin.succAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hik),\n    Fin.succ_predAbove_succ, Fin.succAbove_of_le_castSucc]\n    rcases le_or_lt k (j.castSucc) with (hjk | hjk)\n    · rwa [Fin.predAbove_of_le_castSucc _ _ hjk, Fin.castSucc_castPred]\n    · rw [Fin.le_castSucc_iff, Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succ_pred]\n      exact H.trans_lt hjk\n  · rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hik)]\n    have hjk := H.trans_lt' hik\n    rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr\n      (hjk.trans (Fin.castSucc_lt_succ _)).le),\n      Fin.predAbove_of_le_castSucc _ _ hjk.le, Fin.castPred_castSucc, Fin.succAbove_of_castSucc_lt,\n      Fin.castSucc_castPred]\n    rwa [Fin.castSucc_castPred]\n\n"}
{"name":"SimplexCategory.δ_comp_σ_self","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i.castSucc) (SimplexCategory.σ i)) (CategoryTheory.CategoryStruct.id (SimplexCategory.mk n))","decl":"/-- The first part of the third simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_self {n} {i : Fin (n + 1)} :\n    δ (Fin.castSucc i) ≫ σ i = 𝟙 ([n] : SimplexCategory) := by\n  rcases i with ⟨i, hi⟩\n  ext ⟨j, hj⟩\n  simp? at hj says simp only [len_mk] at hj\n  dsimp [σ, δ, Fin.predAbove, Fin.succAbove]\n  simp only [Fin.lt_iff_val_lt_val, Fin.dite_val, Fin.ite_val, Fin.coe_pred, Fin.coe_castLT]\n  split_ifs\n  any_goals simp\n  all_goals omega\n\n"}
{"name":"SimplexCategory.δ_comp_σ_self_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i.castSucc) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ i) h)) h","decl":"/-- The first part of the third simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_self {n} {i : Fin (n + 1)} :\n    δ (Fin.castSucc i) ≫ σ i = 𝟙 ([n] : SimplexCategory) := by\n  rcases i with ⟨i, hi⟩\n  ext ⟨j, hj⟩\n  simp? at hj says simp only [len_mk] at hj\n  dsimp [σ, δ, Fin.predAbove, Fin.succAbove]\n  simp only [Fin.lt_iff_val_lt_val, Fin.dite_val, Fin.ite_val, Fin.coe_pred, Fin.coe_castLT]\n  split_ifs\n  any_goals simp\n  all_goals omega\n\n"}
{"name":"SimplexCategory.δ_comp_σ_self'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ j) (SimplexCategory.σ i)) (CategoryTheory.CategoryStruct.id (SimplexCategory.mk n))","decl":"@[reassoc]\ntheorem δ_comp_σ_self' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.castSucc) :\n    δ j ≫ σ i = 𝟙 ([n] : SimplexCategory) := by\n  subst H\n  rw [δ_comp_σ_self]\n\n"}
{"name":"SimplexCategory.δ_comp_σ_self'_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.castSucc\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ j) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ i) h)) h","decl":"@[reassoc]\ntheorem δ_comp_σ_self' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.castSucc) :\n    δ j ≫ σ i = 𝟙 ([n] : SimplexCategory) := by\n  subst H\n  rw [δ_comp_σ_self]\n\n"}
{"name":"SimplexCategory.δ_comp_σ_succ","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i.succ) (SimplexCategory.σ i)) (CategoryTheory.CategoryStruct.id (SimplexCategory.mk n))","decl":"/-- The second part of the third simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_succ {n} {i : Fin (n + 1)} : δ i.succ ≫ σ i = 𝟙 ([n] : SimplexCategory) := by\n  ext j\n  rcases i with ⟨i, _⟩\n  rcases j with ⟨j, _⟩\n  dsimp [δ, σ, Fin.succAbove, Fin.predAbove]\n  split_ifs <;> simp <;> simp at * <;> omega\n\n"}
{"name":"SimplexCategory.δ_comp_σ_succ_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i.succ) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ i) h)) h","decl":"/-- The second part of the third simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_succ {n} {i : Fin (n + 1)} : δ i.succ ≫ σ i = 𝟙 ([n] : SimplexCategory) := by\n  ext j\n  rcases i with ⟨i, _⟩\n  rcases j with ⟨j, _⟩\n  dsimp [δ, σ, Fin.succAbove, Fin.predAbove]\n  split_ifs <;> simp <;> simp at * <;> omega\n\n"}
{"name":"SimplexCategory.δ_comp_σ_succ'_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.succ\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ j) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ i) h)) h","decl":"@[reassoc]\ntheorem δ_comp_σ_succ' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.succ) :\n    δ j ≫ σ i = 𝟙 ([n] : SimplexCategory) := by\n  subst H\n  rw [δ_comp_σ_succ]\n\n"}
{"name":"SimplexCategory.δ_comp_σ_succ'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.succ\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ j) (SimplexCategory.σ i)) (CategoryTheory.CategoryStruct.id (SimplexCategory.mk n))","decl":"@[reassoc]\ntheorem δ_comp_σ_succ' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.succ) :\n    δ j ≫ σ i = 𝟙 ([n] : SimplexCategory) := by\n  subst H\n  rw [δ_comp_σ_succ]\n\n"}
{"name":"SimplexCategory.δ_comp_σ_of_gt","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LT.lt j.castSucc i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i.succ) (SimplexCategory.σ j.castSucc)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ j) (SimplexCategory.δ i))","decl":"/-- The fourth simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : j.castSucc < i) :\n    δ i.succ ≫ σ j.castSucc = σ j ≫ δ i := by\n  ext k : 3\n  dsimp [δ, σ]\n  rcases le_or_lt k i with (hik | hik)\n  · rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]\n    rcases le_or_lt k (j.castSucc) with (hjk | hjk)\n    · rw [Fin.predAbove_of_le_castSucc _ _\n      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,\n      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]\n      rw [Fin.castSucc_castPred]\n      exact hjk.trans_lt H\n    · rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),\n      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,\n      Fin.castSucc_pred_eq_pred_castSucc]\n      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]\n  · rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]\n    have hjk := H.trans hik\n    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _\n      (Fin.castSucc_lt_succ_iff.mpr hjk.le),\n    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]\n    rwa [Fin.le_castSucc_pred_iff]\n\n"}
{"name":"SimplexCategory.δ_comp_σ_of_gt_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LT.lt j.castSucc i\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd n 1)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i.succ) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ j.castSucc) h)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ j) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) h))","decl":"/-- The fourth simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : j.castSucc < i) :\n    δ i.succ ≫ σ j.castSucc = σ j ≫ δ i := by\n  ext k : 3\n  dsimp [δ, σ]\n  rcases le_or_lt k i with (hik | hik)\n  · rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]\n    rcases le_or_lt k (j.castSucc) with (hjk | hjk)\n    · rw [Fin.predAbove_of_le_castSucc _ _\n      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,\n      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]\n      rw [Fin.castSucc_castPred]\n      exact hjk.trans_lt H\n    · rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),\n      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,\n      Fin.castSucc_pred_eq_pred_castSucc]\n      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]\n  · rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]\n    have hjk := H.trans hik\n    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _\n      (Fin.castSucc_lt_succ_iff.mpr hjk.le),\n    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]\n    rwa [Fin.le_castSucc_pred_iff]\n\n"}
{"name":"SimplexCategory.δ_comp_σ_of_gt'_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LT.lt j.succ i\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd n 1)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ j) h)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ (j.castLT ⋯)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ (i.pred ⋯)) h))","decl":"@[reassoc]\ntheorem δ_comp_σ_of_gt' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : j.succ < i) :\n    δ i ≫ σ j = σ (j.castLT ((add_lt_add_iff_right 1).mp (lt_of_lt_of_le H i.is_le))) ≫\n      δ (i.pred fun (hi : i = 0) => by simp only [Fin.not_lt_zero, hi] at H) := by\n  rw [← δ_comp_σ_of_gt]\n  · simp\n  · rw [Fin.castSucc_castLT, ← Fin.succ_lt_succ_iff, Fin.succ_pred]\n    exact H\n\n"}
{"name":"SimplexCategory.δ_comp_σ_of_gt'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LT.lt j.succ i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ i) (SimplexCategory.σ j)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ (j.castLT ⋯)) (SimplexCategory.δ (i.pred ⋯)))","decl":"@[reassoc]\ntheorem δ_comp_σ_of_gt' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : j.succ < i) :\n    δ i ≫ σ j = σ (j.castLT ((add_lt_add_iff_right 1).mp (lt_of_lt_of_le H i.is_le))) ≫\n      δ (i.pred fun (hi : i = 0) => by simp only [Fin.not_lt_zero, hi] at H) := by\n  rw [← δ_comp_σ_of_gt]\n  · simp\n  · rw [Fin.castSucc_castLT, ← Fin.succ_lt_succ_iff, Fin.succ_pred]\n    exact H\n\n"}
{"name":"SimplexCategory.σ_comp_σ","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni j : Fin (HAdd.hAdd n 1)\nH : LE.le i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ i.castSucc) (SimplexCategory.σ j)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ j.succ) (SimplexCategory.σ i))","decl":"/-- The fifth simplicial identity -/\n@[reassoc]\ntheorem σ_comp_σ {n} {i j : Fin (n + 1)} (H : i ≤ j) :\n    σ (Fin.castSucc i) ≫ σ j = σ j.succ ≫ σ i := by\n  ext k : 3\n  dsimp [σ]\n  cases' k using Fin.lastCases with k\n  · simp only [len_mk, Fin.predAbove_right_last]\n  · cases' k using Fin.cases with k\n    · rw [Fin.castSucc_zero, Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),\n      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _), Fin.castPred_zero,\n      Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),\n      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _)]\n    · rcases le_or_lt i k with (h | h)\n      · simp_rw [Fin.predAbove_of_castSucc_lt i.castSucc _ (Fin.castSucc_lt_castSucc_iff.mpr\n        (Fin.castSucc_lt_succ_iff.mpr h)), ← Fin.succ_castSucc, Fin.pred_succ,\n        Fin.succ_predAbove_succ]\n        rw [Fin.predAbove_of_castSucc_lt i _ (Fin.castSucc_lt_succ_iff.mpr _), Fin.pred_succ]\n        rcases le_or_lt k j with (hkj | hkj)\n        · rwa [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hkj),\n          Fin.castPred_castSucc]\n        · rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hkj),\n          Fin.le_pred_iff,\n          Fin.succ_le_castSucc_iff]\n          exact H.trans_lt hkj\n      · simp_rw [Fin.predAbove_of_le_castSucc i.castSucc _ (Fin.castSucc_le_castSucc_iff.mpr\n        (Fin.succ_le_castSucc_iff.mpr h)), Fin.castPred_castSucc, ← Fin.succ_castSucc,\n        Fin.succ_predAbove_succ]\n        rw [Fin.predAbove_of_le_castSucc _ k.castSucc\n        (Fin.castSucc_le_castSucc_iff.mpr (h.le.trans H)),\n        Fin.castPred_castSucc, Fin.predAbove_of_le_castSucc _ k.succ\n        (Fin.succ_le_castSucc_iff.mpr (H.trans_lt' h)), Fin.predAbove_of_le_castSucc _ k.succ\n        (Fin.succ_le_castSucc_iff.mpr h)]\n\n"}
{"name":"SimplexCategory.σ_comp_σ_assoc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni j : Fin (HAdd.hAdd n 1)\nH : LE.le i j\nZ : SimplexCategory\nh : Quiver.Hom (SimplexCategory.mk n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ i.castSucc) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ j) h)) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ j.succ) (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ i) h))","decl":"/-- The fifth simplicial identity -/\n@[reassoc]\ntheorem σ_comp_σ {n} {i j : Fin (n + 1)} (H : i ≤ j) :\n    σ (Fin.castSucc i) ≫ σ j = σ j.succ ≫ σ i := by\n  ext k : 3\n  dsimp [σ]\n  cases' k using Fin.lastCases with k\n  · simp only [len_mk, Fin.predAbove_right_last]\n  · cases' k using Fin.cases with k\n    · rw [Fin.castSucc_zero, Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),\n      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _), Fin.castPred_zero,\n      Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),\n      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _)]\n    · rcases le_or_lt i k with (h | h)\n      · simp_rw [Fin.predAbove_of_castSucc_lt i.castSucc _ (Fin.castSucc_lt_castSucc_iff.mpr\n        (Fin.castSucc_lt_succ_iff.mpr h)), ← Fin.succ_castSucc, Fin.pred_succ,\n        Fin.succ_predAbove_succ]\n        rw [Fin.predAbove_of_castSucc_lt i _ (Fin.castSucc_lt_succ_iff.mpr _), Fin.pred_succ]\n        rcases le_or_lt k j with (hkj | hkj)\n        · rwa [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hkj),\n          Fin.castPred_castSucc]\n        · rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hkj),\n          Fin.le_pred_iff,\n          Fin.succ_le_castSucc_iff]\n          exact H.trans_lt hkj\n      · simp_rw [Fin.predAbove_of_le_castSucc i.castSucc _ (Fin.castSucc_le_castSucc_iff.mpr\n        (Fin.succ_le_castSucc_iff.mpr h)), Fin.castPred_castSucc, ← Fin.succ_castSucc,\n        Fin.succ_predAbove_succ]\n        rw [Fin.predAbove_of_le_castSucc _ k.castSucc\n        (Fin.castSucc_le_castSucc_iff.mpr (h.le.trans H)),\n        Fin.castPred_castSucc, Fin.predAbove_of_le_castSucc _ k.succ\n        (Fin.succ_le_castSucc_iff.mpr (H.trans_lt' h)), Fin.predAbove_of_le_castSucc _ k.succ\n        (Fin.succ_le_castSucc_iff.mpr h)]\n\n"}
{"name":"SimplexCategory.factor_δ_spec","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"m n : Nat\nf : Quiver.Hom (SimplexCategory.mk m) (SimplexCategory.mk (HAdd.hAdd n 1))\nj : Fin (HAdd.hAdd n 2)\nhj : ∀ (k : Fin (HAdd.hAdd m 1)), Ne ((SimplexCategory.Hom.toOrderHom f) k) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.factor_δ f j) (SimplexCategory.δ j)) f","decl":"open Fin in\nlemma factor_δ_spec {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))\n    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :\n    factor_δ f j ≫ δ j = f := by\n  ext k : 3\n  specialize hj k\n  dsimp [factor_δ, δ, σ]\n  cases' j using cases with j\n  · rw [predAbove_of_le_castSucc _ _ (zero_le _), castPred_zero, predAbove_of_castSucc_lt 0 _\n    (castSucc_zero ▸ pos_of_ne_zero hj),\n    zero_succAbove, succ_pred]\n  · rw [predAbove_of_castSucc_lt 0 _ (castSucc_zero ▸ succ_pos _), pred_succ]\n    rcases hj.lt_or_lt with (hj | hj)\n    · rw [predAbove_of_le_castSucc j _]\n      swap\n      · exact (le_castSucc_iff.mpr hj)\n      · rw [succAbove_of_castSucc_lt]\n        swap\n        · rwa [castSucc_lt_succ_iff, castPred_le_iff, le_castSucc_iff]\n        rw [castSucc_castPred]\n    · rw [predAbove_of_castSucc_lt]\n      swap\n      · exact (castSucc_lt_succ _).trans hj\n      rw [succAbove_of_le_castSucc]\n      swap\n      · rwa [succ_le_castSucc_iff, lt_pred_iff]\n      rw [succ_pred]\n\n"}
{"name":"SimplexCategory.δ_zero_mkOfSucc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ 0) (SimplexCategory.mkOfSucc i)) ((SimplexCategory.mk 0).const (SimplexCategory.mk n) i.succ)","decl":"@[simp]\nlemma δ_zero_mkOfSucc {n : ℕ} (i : Fin n) :\n    δ 0 ≫ mkOfSucc i = SimplexCategory.const _ [n] i.succ := by\n  ext x\n  fin_cases x\n  rfl\n\n"}
{"name":"SimplexCategory.δ_one_mkOfSucc","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.δ 1) (SimplexCategory.mkOfSucc i)) ((SimplexCategory.mk 0).const (SimplexCategory.mk n) ↑↑i.castSucc)","decl":"@[simp]\nlemma δ_one_mkOfSucc {n : ℕ} (i : Fin n) :\n    δ 1 ≫ mkOfSucc i = SimplexCategory.const _ _ i.castSucc := by\n  ext x\n  fin_cases x\n  aesop\n\n"}
{"name":"SimplexCategory.mkOfSucc_δ_lt","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\nj : Fin (HAdd.hAdd n 2)\nh : LT.lt i.succ.castSucc j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.mkOfSucc i) (SimplexCategory.δ j)) (SimplexCategory.mkOfSucc i.castSucc)","decl":"/-- If `i + 1 < j`, `mkOfSucc i ≫ δ j` is the morphism `[1] ⟶ [n]` that\nsends `0` and `1` to `i` and `i + 1`, respectively. -/\nlemma mkOfSucc_δ_lt {n : ℕ} {i : Fin n} {j : Fin (n + 2)}\n    (h : i.succ.castSucc < j) :\n    mkOfSucc i ≫ δ j = mkOfSucc i.castSucc := by\n  ext x\n  fin_cases x\n  · simp [δ, Fin.succAbove_of_castSucc_lt _ _ (Nat.lt_trans _ h)]\n  · simp [δ, Fin.succAbove_of_castSucc_lt _ _ h]\n\n"}
{"name":"SimplexCategory.mkOfSucc_δ_gt","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\nj : Fin (HAdd.hAdd n 2)\nh : LT.lt j i.succ.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.mkOfSucc i) (SimplexCategory.δ j)) (SimplexCategory.mkOfSucc i.succ)","decl":"/-- If `i + 1 > j`, `mkOfSucc i ≫ δ j` is the morphism `[1] ⟶ [n]` that\nsends `0` and `1` to `i + 1` and `i + 2`, respectively. -/\nlemma mkOfSucc_δ_gt {n : ℕ} {i : Fin n} {j : Fin (n + 2)}\n    (h : j < i.succ.castSucc) :\n    mkOfSucc i ≫ δ j = mkOfSucc i.succ := by\n  ext x\n  simp only [δ, len_mk, mkHom, comp_toOrderHom, Hom.toOrderHom_mk, OrderHom.comp_coe,\n    OrderEmbedding.toOrderHom_coe, Function.comp_apply, Fin.succAboveOrderEmb_apply]\n  fin_cases x <;> rw [Fin.succAbove_of_le_castSucc]\n  · rfl\n  · exact Nat.le_of_lt_succ h\n  · rfl\n  · exact Nat.le_of_lt h\n\n"}
{"name":"SimplexCategory.mkOfSucc_δ_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin n\nj : Fin (HAdd.hAdd n 2)\nh : Eq j i.succ.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SimplexCategory.mkOfSucc i) (SimplexCategory.δ j)) (SimplexCategory.intervalEdge (↑i) 2 ⋯)","decl":"/-- If `i + 1 = j`, `mkOfSucc i ≫ δ j` is the morphism `[1] ⟶ [n]` that\nsends `0` and `1` to `i` and `i + 2`, respectively. -/\nlemma mkOfSucc_δ_eq {n : ℕ} {i : Fin n} {j : Fin (n + 2)}\n    (h : j = i.succ.castSucc) :\n    mkOfSucc i ≫ δ j = intervalEdge i 2 (by omega) := by\n  ext x\n  fin_cases x\n  · subst h\n    simp only [δ, len_mk, Nat.reduceAdd, mkHom, comp_toOrderHom, Hom.toOrderHom_mk,\n      Fin.zero_eta, OrderHom.comp_coe, OrderEmbedding.toOrderHom_coe, Function.comp_apply,\n      mkOfSucc_homToOrderHom_zero, Fin.succAboveOrderEmb_apply,\n      Fin.castSucc_succAbove_castSucc, Fin.succAbove_succ_self]\n    rfl\n  · simp only [δ, len_mk, Nat.reduceAdd, mkHom, comp_toOrderHom, Hom.toOrderHom_mk, Fin.mk_one,\n      OrderHom.comp_coe, OrderEmbedding.toOrderHom_coe, Function.comp_apply,\n      mkOfSucc_homToOrderHom_one, Fin.succAboveOrderEmb_apply]\n    subst h\n    rw [Fin.succAbove_castSucc_self]\n    rfl\n\n"}
{"name":"SimplexCategory.eq_of_one_to_two","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"f : Quiver.Hom (SimplexCategory.mk 1) (SimplexCategory.mk 2)\n⊢ Or (Eq f (SimplexCategory.δ 0)) (Or (Eq f (SimplexCategory.δ 1)) (Or (Eq f (SimplexCategory.δ 2)) (Exists fun a => Eq f ((SimplexCategory.mk 1).const (SimplexCategory.mk 2) a))))","decl":"theorem eq_of_one_to_two (f : ([1] : SimplexCategory) ⟶ [2]) :\n    f = (δ (n := 1) 0) ∨ f = (δ (n := 1) 1) ∨ f = (δ (n := 1) 2) ∨\n      ∃ a, f = SimplexCategory.const _ _ a := by\n  have : f.toOrderHom 0 ≤ f.toOrderHom 1 := f.toOrderHom.monotone (by decide : (0 : Fin 2) ≤ 1)\n  match e0 : f.toOrderHom 0, e1 : f.toOrderHom 1 with\n  | 1, 2 =>\n    left\n    ext i : 3\n    match i with\n    | 0 => exact e0\n    | 1 => exact e1\n  | 0, 2 =>\n    right; left\n    ext i : 3\n    match i with\n    | 0 => exact e0\n    | 1 => exact e1\n  | 0, 1 =>\n    right; right; left\n    ext i : 3\n    match i with\n    | 0 => exact e0\n    | 1 => exact e1\n  | 0, 0 | 1, 1 | 2, 2 =>\n    right; right; right; use f.toOrderHom 0\n    ext i : 3\n    match i with\n    | 0 => rfl\n    | 1 => exact e1.trans e0.symm\n  | 1, 0 | 2, 0 | 2, 1 =>\n    rw [e0, e1] at this\n    exact Not.elim (by decide) this\n\n"}
{"name":"SimplexCategory.skeletalFunctor_obj","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"a : SimplexCategory\n⊢ Eq (SimplexCategory.skeletalFunctor.obj a) (NonemptyFinLinOrd.of (Fin (HAdd.hAdd a.len 1)))","decl":"/-- The functor that exhibits `SimplexCategory` as skeleton\nof `NonemptyFinLinOrd` -/\n@[simps obj map]\ndef skeletalFunctor : SimplexCategory ⥤ NonemptyFinLinOrd where\n  obj a := NonemptyFinLinOrd.of (Fin (a.len + 1))\n  map f := f.toOrderHom\n\n"}
{"name":"SimplexCategory.skeletalFunctor_map","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"X✝ Y✝ : SimplexCategory\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (SimplexCategory.skeletalFunctor.map f) (SimplexCategory.Hom.toOrderHom f)","decl":"/-- The functor that exhibits `SimplexCategory` as skeleton\nof `NonemptyFinLinOrd` -/\n@[simps obj map]\ndef skeletalFunctor : SimplexCategory ⥤ NonemptyFinLinOrd where\n  obj a := NonemptyFinLinOrd.of (Fin (a.len + 1))\n  map f := f.toOrderHom\n\n"}
{"name":"SimplexCategory.skeletalFunctor.coe_map","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Δ₁ Δ₂ : SimplexCategory\nf : Quiver.Hom Δ₁ Δ₂\n⊢ Eq (SimplexCategory.skeletalFunctor.map f) (SimplexCategory.Hom.toOrderHom f)","decl":"theorem skeletalFunctor.coe_map {Δ₁ Δ₂ : SimplexCategory} (f : Δ₁ ⟶ Δ₂) :\n    ↑(skeletalFunctor.map f) = f.toOrderHom :=\n  rfl\n\n"}
{"name":"SimplexCategory.skeletal","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"⊢ CategoryTheory.Skeletal SimplexCategory","decl":"theorem skeletal : Skeletal SimplexCategory := fun X Y ⟨I⟩ => by\n  suffices Fintype.card (Fin (X.len + 1)) = Fintype.card (Fin (Y.len + 1)) by\n    ext\n    simpa\n  apply Fintype.card_congr\n  exact ((skeletalFunctor ⋙ forget NonemptyFinLinOrd).mapIso I).toEquiv\n\n"}
{"name":"SimplexCategory.SkeletalFunctor.instFullNonemptyFinLinOrdSkeletalFunctor","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"⊢ SimplexCategory.skeletalFunctor.Full","decl":"instance : skeletalFunctor.Full where\n  map_surjective f := ⟨SimplexCategory.Hom.mk f, rfl⟩\n\n"}
{"name":"SimplexCategory.SkeletalFunctor.instFaithfulNonemptyFinLinOrdSkeletalFunctor","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"⊢ SimplexCategory.skeletalFunctor.Faithful","decl":"instance : skeletalFunctor.Faithful where\n  map_injective {_ _ f g} h := by\n    ext1\n    exact h\n\n"}
{"name":"SimplexCategory.SkeletalFunctor.instEssSurjNonemptyFinLinOrdSkeletalFunctor","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"⊢ SimplexCategory.skeletalFunctor.EssSurj","decl":"instance : skeletalFunctor.EssSurj where\n  mem_essImage X :=\n    ⟨mk (Fintype.card X - 1 : ℕ),\n      ⟨by\n        have aux : Fintype.card X = Fintype.card X - 1 + 1 :=\n          (Nat.succ_pred_eq_of_pos <| Fintype.card_pos_iff.mpr ⟨⊥⟩).symm\n        let f := monoEquivOfFin X aux\n        have hf := (Finset.univ.orderEmbOfFin aux).strictMono\n        refine\n          { hom := ⟨f, hf.monotone⟩\n            inv := ⟨f.symm, ?_⟩\n            hom_inv_id := by ext1; apply f.symm_apply_apply\n            inv_hom_id := by ext1; apply f.apply_symm_apply }\n        intro i j h\n        show f.symm i ≤ f.symm j\n        rw [← hf.le_iff_le]\n        show f (f.symm i) ≤ f (f.symm j)\n        simpa only [OrderIso.apply_symm_apply]⟩⟩\n\n"}
{"name":"SimplexCategory.SkeletalFunctor.isEquivalence","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"⊢ SimplexCategory.skeletalFunctor.IsEquivalence","decl":"noncomputable instance isEquivalence : skeletalFunctor.IsEquivalence where\n\n"}
{"name":"SimplexCategory.isSkeletonOf","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"⊢ CategoryTheory.IsSkeletonOf NonemptyFinLinOrd SimplexCategory SimplexCategory.skeletalFunctor","decl":"/-- `SimplexCategory` is a skeleton of `NonemptyFinLinOrd`.\n-/\nlemma isSkeletonOf :\n    IsSkeletonOf NonemptyFinLinOrd SimplexCategory skeletalFunctor where\n  skel := skeletal\n  eqv := SkeletalFunctor.isEquivalence\n\n"}
{"name":"SimplexCategory.Truncated.instFullInclusion","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\n⊢ (SimplexCategory.Truncated.inclusion n).Full","decl":"instance (n : ℕ) : (inclusion n : Truncated n ⥤ _).Full := FullSubcategory.full _\n"}
{"name":"SimplexCategory.Truncated.instFaithfulInclusion","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\n⊢ (SimplexCategory.Truncated.inclusion n).Faithful","decl":"instance (n : ℕ) : (inclusion n : Truncated n ⥤ _).Faithful := FullSubcategory.faithful _\n\n"}
{"name":"SimplexCategory.Truncated.Hom.ext_iff","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\na b : SimplexCategory.Truncated n\nf g : Quiver.Hom a b\n⊢ Iff (Eq f g) (Eq (SimplexCategory.Hom.toOrderHom f) (SimplexCategory.Hom.toOrderHom g))","decl":"@[ext]\ntheorem Hom.ext {n} {a b : Truncated n} (f g : a ⟶ b) :\n    f.toOrderHom = g.toOrderHom → f = g := SimplexCategory.Hom.ext _ _\n\n"}
{"name":"SimplexCategory.Truncated.Hom.ext","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\na b : SimplexCategory.Truncated n\nf g : Quiver.Hom a b\na✝ : Eq (SimplexCategory.Hom.toOrderHom f) (SimplexCategory.Hom.toOrderHom g)\n⊢ Eq f g","decl":"@[ext]\ntheorem Hom.ext {n} {a b : Truncated n} (f g : a ⟶ b) :\n    f.toOrderHom = g.toOrderHom → f = g := SimplexCategory.Hom.ext _ _\n\n"}
{"name":"SimplexCategory.mono_iff_injective","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n m : SimplexCategory\nf : Quiver.Hom n m\n⊢ Iff (CategoryTheory.Mono f) (Function.Injective ⇑(SimplexCategory.Hom.toOrderHom f))","decl":"/-- A morphism in `SimplexCategory` is a monomorphism precisely when it is an injective function\n-/\ntheorem mono_iff_injective {n m : SimplexCategory} {f : n ⟶ m} :\n    Mono f ↔ Function.Injective f.toOrderHom := by\n  rw [← Functor.mono_map_iff_mono skeletalEquivalence.functor]\n  dsimp only [skeletalEquivalence, Functor.asEquivalence_functor]\n  simp only [skeletalFunctor_obj, skeletalFunctor_map,\n    NonemptyFinLinOrd.mono_iff_injective, NonemptyFinLinOrd.coe_of]\n\n"}
{"name":"SimplexCategory.epi_iff_surjective","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n m : SimplexCategory\nf : Quiver.Hom n m\n⊢ Iff (CategoryTheory.Epi f) (Function.Surjective ⇑(SimplexCategory.Hom.toOrderHom f))","decl":"/-- A morphism in `SimplexCategory` is an epimorphism if and only if it is a surjective function\n-/\ntheorem epi_iff_surjective {n m : SimplexCategory} {f : n ⟶ m} :\n    Epi f ↔ Function.Surjective f.toOrderHom := by\n  rw [← Functor.epi_map_iff_epi skeletalEquivalence.functor]\n  dsimp only [skeletalEquivalence, Functor.asEquivalence_functor]\n  simp only [skeletalFunctor_obj, skeletalFunctor_map,\n    NonemptyFinLinOrd.epi_iff_surjective, NonemptyFinLinOrd.coe_of]\n\n"}
{"name":"SimplexCategory.len_le_of_mono","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x y : SimplexCategory\nf : Quiver.Hom x y\na✝ : CategoryTheory.Mono f\n⊢ LE.le x.len y.len","decl":"/-- A monomorphism in `SimplexCategory` must increase lengths -/\ntheorem len_le_of_mono {x y : SimplexCategory} {f : x ⟶ y} : Mono f → x.len ≤ y.len := by\n  intro hyp_f_mono\n  have f_inj : Function.Injective f.toOrderHom.toFun := mono_iff_injective.1 hyp_f_mono\n  simpa using Fintype.card_le_of_injective f.toOrderHom.toFun f_inj\n\n"}
{"name":"SimplexCategory.le_of_mono","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n m : Nat\nf : Quiver.Hom (SimplexCategory.mk n) (SimplexCategory.mk m)\na✝ : CategoryTheory.Mono f\n⊢ LE.le n m","decl":"theorem le_of_mono {n m : ℕ} {f : ([n] : SimplexCategory) ⟶ [m]} : CategoryTheory.Mono f → n ≤ m :=\n  len_le_of_mono\n\n"}
{"name":"SimplexCategory.len_le_of_epi","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x y : SimplexCategory\nf : Quiver.Hom x y\na✝ : CategoryTheory.Epi f\n⊢ LE.le y.len x.len","decl":"/-- An epimorphism in `SimplexCategory` must decrease lengths -/\ntheorem len_le_of_epi {x y : SimplexCategory} {f : x ⟶ y} : Epi f → y.len ≤ x.len := by\n  intro hyp_f_epi\n  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_epi\n  simpa using Fintype.card_le_of_surjective f.toOrderHom.toFun f_surj\n\n"}
{"name":"SimplexCategory.le_of_epi","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n m : Nat\nf : Quiver.Hom (SimplexCategory.mk n) (SimplexCategory.mk m)\na✝ : CategoryTheory.Epi f\n⊢ LE.le m n","decl":"theorem le_of_epi {n m : ℕ} {f : ([n] : SimplexCategory) ⟶ [m]} : Epi f → m ≤ n :=\n  len_le_of_epi\n\n"}
{"name":"SimplexCategory.instMonoδ","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\n⊢ CategoryTheory.Mono (SimplexCategory.δ i)","decl":"instance {n : ℕ} {i : Fin (n + 2)} : Mono (δ i) := by\n  rw [mono_iff_injective]\n  exact Fin.succAbove_right_injective\n\n"}
{"name":"SimplexCategory.instEpiσ","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ CategoryTheory.Epi (SimplexCategory.σ i)","decl":"instance {n : ℕ} {i : Fin (n + 1)} : Epi (σ i) := by\n  rw [epi_iff_surjective]\n  intro b\n  simp only [σ, mkHom, Hom.toOrderHom_mk, OrderHom.coe_mk]\n  by_cases h : b ≤ i\n  · use b\n    -- This was not needed before https://github.com/leanprover/lean4/pull/2644\n    dsimp\n    rw [Fin.predAbove_of_le_castSucc i b (by simpa only [Fin.coe_eq_castSucc] using h)]\n    simp only [len_mk, Fin.coe_eq_castSucc, Fin.castPred_castSucc]\n  · use b.succ\n    -- This was not needed before https://github.com/leanprover/lean4/pull/2644\n    dsimp\n    rw [Fin.predAbove_of_castSucc_lt i b.succ _, Fin.pred_succ]\n    rw [not_le] at h\n    rw [Fin.lt_iff_val_lt_val] at h ⊢\n    simpa only [Fin.val_succ, Fin.coe_castSucc] using Nat.lt.step h\n\n"}
{"name":"SimplexCategory.instReflectsIsomorphismsForget","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"⊢ (CategoryTheory.forget SimplexCategory).ReflectsIsomorphisms","decl":"instance : (forget SimplexCategory).ReflectsIsomorphisms :=\n  ⟨fun f hf =>\n    Iso.isIso_hom\n      { hom := f\n        inv := Hom.mk\n            { toFun := inv ((forget SimplexCategory).map f)\n              monotone' := fun y₁ y₂ h => by\n                by_cases h' : y₁ < y₂\n                · by_contra h''\n                  apply not_le.mpr h'\n                  convert f.toOrderHom.monotone (le_of_not_ge h'')\n                  all_goals\n                    exact (congr_hom (Iso.inv_hom_id\n                      (asIso ((forget SimplexCategory).map f))) _).symm\n                · rw [eq_of_le_of_not_lt h h'] }\n        hom_inv_id := by\n          ext1\n          ext1\n          exact Iso.hom_inv_id (asIso ((forget _).map f))\n        inv_hom_id := by\n          ext1\n          ext1\n          exact Iso.inv_hom_id (asIso ((forget _).map f)) }⟩\n\n"}
{"name":"SimplexCategory.isIso_of_bijective","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x y : SimplexCategory\nf : Quiver.Hom x y\nhf : Function.Bijective (SimplexCategory.Hom.toOrderHom f).toFun\n⊢ CategoryTheory.IsIso f","decl":"theorem isIso_of_bijective {x y : SimplexCategory} {f : x ⟶ y}\n    (hf : Function.Bijective f.toOrderHom.toFun) : IsIso f :=\n  haveI : IsIso ((forget SimplexCategory).map f) := (isIso_iff_bijective _).mpr hf\n  isIso_of_reflects_iso f (forget SimplexCategory)\n\n"}
{"name":"SimplexCategory.iso_eq_iso_refl","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x : SimplexCategory\ne : CategoryTheory.Iso x x\n⊢ Eq e (CategoryTheory.Iso.refl x)","decl":"theorem iso_eq_iso_refl {x : SimplexCategory} (e : x ≅ x) : e = Iso.refl x := by\n  have h : (Finset.univ : Finset (Fin (x.len + 1))).card = x.len + 1 := Finset.card_fin (x.len + 1)\n  have eq₁ := Finset.orderEmbOfFin_unique' h fun i => Finset.mem_univ ((orderIsoOfIso e) i)\n  have eq₂ :=\n    Finset.orderEmbOfFin_unique' h fun i => Finset.mem_univ ((orderIsoOfIso (Iso.refl x)) i)\n  -- Porting note: the proof was rewritten from this point in https://github.com/leanprover-community/mathlib4/pull/3414 (reenableeta)\n  -- It could be investigated again to see if the original can be restored.\n  ext x\n  replace eq₁ := congr_arg (· x) eq₁\n  replace eq₂ := congr_arg (· x) eq₂.symm\n  simp_all\n\n"}
{"name":"SimplexCategory.eq_id_of_isIso","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x : SimplexCategory\nf : Quiver.Hom x x\ninst✝ : CategoryTheory.IsIso f\n⊢ Eq f (CategoryTheory.CategoryStruct.id x)","decl":"theorem eq_id_of_isIso {x : SimplexCategory} (f : x ⟶ x) [IsIso f] : f = 𝟙 _ :=\n  congr_arg (fun φ : _ ≅ _ => φ.hom) (iso_eq_iso_refl (asIso f))\n\n"}
{"name":"SimplexCategory.eq_σ_comp_of_not_injective'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nΔ' : SimplexCategory\nθ : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd n 1)) Δ'\ni : Fin (HAdd.hAdd n 1)\nhi : Eq ((SimplexCategory.Hom.toOrderHom θ) i.castSucc) ((SimplexCategory.Hom.toOrderHom θ) i.succ)\n⊢ Exists fun θ' => Eq θ (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ i) θ')","decl":"theorem eq_σ_comp_of_not_injective' {n : ℕ} {Δ' : SimplexCategory} (θ : mk (n + 1) ⟶ Δ')\n    (i : Fin (n + 1)) (hi : θ.toOrderHom (Fin.castSucc i) = θ.toOrderHom i.succ) :\n    ∃ θ' : mk n ⟶ Δ', θ = σ i ≫ θ' := by\n  use δ i.succ ≫ θ\n  ext1; ext1; ext1 x\n  simp only [len_mk, σ, mkHom, comp_toOrderHom, Hom.toOrderHom_mk, OrderHom.comp_coe,\n    OrderHom.coe_mk, Function.comp_apply]\n  by_cases h' : x ≤ Fin.castSucc i\n  · -- This was not needed before https://github.com/leanprover/lean4/pull/2644\n    dsimp\n    rw [Fin.predAbove_of_le_castSucc i x h']\n    dsimp [δ]\n    rw [Fin.succAbove_of_castSucc_lt _ _ _]\n    · rw [Fin.castSucc_castPred]\n    · exact (Fin.castSucc_lt_succ_iff.mpr h')\n  · simp only [not_le] at h'\n    let y := x.pred <| by rintro (rfl : x = 0); simp at h'\n    have hy : x = y.succ := (Fin.succ_pred x _).symm\n    rw [hy] at h' ⊢\n    -- This was not needed before https://github.com/leanprover/lean4/pull/2644\n    conv_rhs => dsimp\n    rw [Fin.predAbove_of_castSucc_lt i y.succ h', Fin.pred_succ]\n    by_cases h'' : y = i\n    · rw [h'']\n      refine hi.symm.trans ?_\n      congr 1\n      dsimp [δ]\n      rw [Fin.succAbove_of_castSucc_lt i.succ]\n      exact Fin.lt_succ\n    · dsimp [δ]\n      rw [Fin.succAbove_of_le_castSucc i.succ _]\n      simp only [Fin.lt_iff_val_lt_val, Fin.le_iff_val_le_val, Fin.val_succ, Fin.coe_castSucc,\n        Nat.lt_succ_iff, Fin.ext_iff] at h' h'' ⊢\n      omega\n\n"}
{"name":"SimplexCategory.eq_σ_comp_of_not_injective","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nΔ' : SimplexCategory\nθ : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd n 1)) Δ'\nhθ : Not (Function.Injective ⇑(SimplexCategory.Hom.toOrderHom θ))\n⊢ Exists fun i => Exists fun θ' => Eq θ (CategoryTheory.CategoryStruct.comp (SimplexCategory.σ i) θ')","decl":"theorem eq_σ_comp_of_not_injective {n : ℕ} {Δ' : SimplexCategory} (θ : mk (n + 1) ⟶ Δ')\n    (hθ : ¬Function.Injective θ.toOrderHom) :\n    ∃ (i : Fin (n + 1)) (θ' : mk n ⟶ Δ'), θ = σ i ≫ θ' := by\n  simp only [Function.Injective, exists_prop, not_forall] at hθ\n  -- as θ is not injective, there exists `x<y` such that `θ x = θ y`\n  -- and then, `θ x = θ (x+1)`\n  have hθ₂ : ∃ x y : Fin (n + 2), (Hom.toOrderHom θ) x = (Hom.toOrderHom θ) y ∧ x < y := by\n    rcases hθ with ⟨x, y, ⟨h₁, h₂⟩⟩\n    by_cases h : x < y\n    · exact ⟨x, y, ⟨h₁, h⟩⟩\n    · refine ⟨y, x, ⟨h₁.symm, ?_⟩⟩\n      rcases lt_or_eq_of_le (not_lt.mp h) with h' | h'\n      · exact h'\n      · exfalso\n        exact h₂ h'.symm\n  rcases hθ₂ with ⟨x, y, ⟨h₁, h₂⟩⟩\n  use x.castPred ((Fin.le_last _).trans_lt' h₂).ne\n  apply eq_σ_comp_of_not_injective'\n  apply le_antisymm\n  · exact θ.toOrderHom.monotone (le_of_lt (Fin.castSucc_lt_succ _))\n  · rw [Fin.castSucc_castPred, h₁]\n    exact θ.toOrderHom.monotone ((Fin.succ_castPred_le_iff _).mpr h₂)\n\n"}
{"name":"SimplexCategory.eq_comp_δ_of_not_surjective'","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nΔ : SimplexCategory\nθ : Quiver.Hom Δ (SimplexCategory.mk (HAdd.hAdd n 1))\ni : Fin (HAdd.hAdd n 2)\nhi : ∀ (x : Fin (HAdd.hAdd Δ.len 1)), Ne ((SimplexCategory.Hom.toOrderHom θ) x) i\n⊢ Exists fun θ' => Eq θ (CategoryTheory.CategoryStruct.comp θ' (SimplexCategory.δ i))","decl":"theorem eq_comp_δ_of_not_surjective' {n : ℕ} {Δ : SimplexCategory} (θ : Δ ⟶ mk (n + 1))\n    (i : Fin (n + 2)) (hi : ∀ x, θ.toOrderHom x ≠ i) : ∃ θ' : Δ ⟶ mk n, θ = θ' ≫ δ i := by\n  by_cases h : i < Fin.last (n + 1)\n  · use θ ≫ σ (Fin.castPred i h.ne)\n    ext1\n    ext1\n    ext1 x\n    simp only [len_mk, Category.assoc, comp_toOrderHom, OrderHom.comp_coe, Function.comp_apply]\n    by_cases h' : θ.toOrderHom x ≤ i\n    · simp only [σ, mkHom, Hom.toOrderHom_mk, OrderHom.coe_mk]\n      rw [Fin.predAbove_of_le_castSucc _ _ (by rwa [Fin.castSucc_castPred])]\n      dsimp [δ]\n      rw [Fin.succAbove_of_castSucc_lt i]\n      · rw [Fin.castSucc_castPred]\n      · rw [(hi x).le_iff_lt] at h'\n        exact h'\n    · simp only [not_le] at h'\n      dsimp [σ, δ]\n      rw [Fin.predAbove_of_castSucc_lt _ _ (by rwa [Fin.castSucc_castPred])]\n      rw [Fin.succAbove_of_le_castSucc i _]\n      · rw [Fin.succ_pred]\n      · exact Nat.le_sub_one_of_lt (Fin.lt_iff_val_lt_val.mp h')\n  · obtain rfl := le_antisymm (Fin.le_last i) (not_lt.mp h)\n    use θ ≫ σ (Fin.last _)\n    ext x : 3\n    dsimp [δ, σ]\n    simp_rw [Fin.succAbove_last, Fin.predAbove_last_apply]\n    erw [dif_neg (hi x)]\n    rw [Fin.castSucc_castPred]\n\n"}
{"name":"SimplexCategory.eq_comp_δ_of_not_surjective","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nΔ : SimplexCategory\nθ : Quiver.Hom Δ (SimplexCategory.mk (HAdd.hAdd n 1))\nhθ : Not (Function.Surjective ⇑(SimplexCategory.Hom.toOrderHom θ))\n⊢ Exists fun i => Exists fun θ' => Eq θ (CategoryTheory.CategoryStruct.comp θ' (SimplexCategory.δ i))","decl":"theorem eq_comp_δ_of_not_surjective {n : ℕ} {Δ : SimplexCategory} (θ : Δ ⟶ mk (n + 1))\n    (hθ : ¬Function.Surjective θ.toOrderHom) :\n    ∃ (i : Fin (n + 2)) (θ' : Δ ⟶ mk n), θ = θ' ≫ δ i := by\n  cases' not_forall.mp hθ with i hi\n  use i\n  exact eq_comp_δ_of_not_surjective' θ i (not_exists.mp hi)\n\n"}
{"name":"SimplexCategory.eq_id_of_mono","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x : SimplexCategory\ni : Quiver.Hom x x\ninst✝ : CategoryTheory.Mono i\n⊢ Eq i (CategoryTheory.CategoryStruct.id x)","decl":"theorem eq_id_of_mono {x : SimplexCategory} (i : x ⟶ x) [Mono i] : i = 𝟙 _ := by\n  suffices IsIso i by\n    apply eq_id_of_isIso\n  apply isIso_of_bijective\n  dsimp\n  rw [Fintype.bijective_iff_injective_and_card i.toOrderHom, ← mono_iff_injective,\n    eq_self_iff_true, and_true]\n  infer_instance\n\n"}
{"name":"SimplexCategory.eq_id_of_epi","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"x : SimplexCategory\ni : Quiver.Hom x x\ninst✝ : CategoryTheory.Epi i\n⊢ Eq i (CategoryTheory.CategoryStruct.id x)","decl":"theorem eq_id_of_epi {x : SimplexCategory} (i : x ⟶ x) [Epi i] : i = 𝟙 _ := by\n  suffices IsIso i by\n    haveI := this\n    apply eq_id_of_isIso\n  apply isIso_of_bijective\n  dsimp\n  rw [Fintype.bijective_iff_surjective_and_card i.toOrderHom, ← epi_iff_surjective,\n    eq_self_iff_true, and_true]\n  infer_instance\n\n"}
{"name":"SimplexCategory.eq_σ_of_epi","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nθ : Quiver.Hom (SimplexCategory.mk (HAdd.hAdd n 1)) (SimplexCategory.mk n)\ninst✝ : CategoryTheory.Epi θ\n⊢ Exists fun i => Eq θ (SimplexCategory.σ i)","decl":"theorem eq_σ_of_epi {n : ℕ} (θ : mk (n + 1) ⟶ mk n) [Epi θ] : ∃ i : Fin (n + 1), θ = σ i := by\n  rcases eq_σ_comp_of_not_injective θ (by\n    by_contra h\n    simpa using le_of_mono (mono_iff_injective.mpr h)) with ⟨i, θ', h⟩\n  use i\n  haveI : Epi (σ i ≫ θ') := by\n    rw [← h]\n    infer_instance\n  haveI := CategoryTheory.epi_of_epi (σ i) θ'\n  rw [h, eq_id_of_epi θ', Category.comp_id]\n\n"}
{"name":"SimplexCategory.eq_δ_of_mono","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"n : Nat\nθ : Quiver.Hom (SimplexCategory.mk n) (SimplexCategory.mk (HAdd.hAdd n 1))\ninst✝ : CategoryTheory.Mono θ\n⊢ Exists fun i => Eq θ (SimplexCategory.δ i)","decl":"theorem eq_δ_of_mono {n : ℕ} (θ : mk n ⟶ mk (n + 1)) [Mono θ] : ∃ i : Fin (n + 2), θ = δ i := by\n  rcases eq_comp_δ_of_not_surjective θ (by\n    by_contra h\n    simpa using le_of_epi (epi_iff_surjective.mpr h)) with ⟨i, θ', h⟩\n  use i\n  haveI : Mono (θ' ≫ δ i) := by\n    rw [← h]\n    infer_instance\n  haveI := CategoryTheory.mono_of_mono θ' (δ i)\n  rw [h, eq_id_of_mono θ', Category.id_comp]\n\n"}
{"name":"SimplexCategory.len_lt_of_mono","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Δ' Δ : SimplexCategory\ni : Quiver.Hom Δ' Δ\nhi : CategoryTheory.Mono i\nhi' : Ne Δ Δ'\n⊢ LT.lt Δ'.len Δ.len","decl":"theorem len_lt_of_mono {Δ' Δ : SimplexCategory} (i : Δ' ⟶ Δ) [hi : Mono i] (hi' : Δ ≠ Δ') :\n    Δ'.len < Δ.len := by\n  rcases lt_or_eq_of_le (len_le_of_mono hi) with (h | h)\n  · exact h\n  · exfalso\n    exact hi' (by ext; exact h.symm)\n\n"}
{"name":"SimplexCategory.instSplitEpiCategory","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"⊢ CategoryTheory.SplitEpiCategory SimplexCategory","decl":"noncomputable instance : SplitEpiCategory SimplexCategory :=\n  skeletalEquivalence.inverse.splitEpiCategoryImpOfIsEquivalence\n\n"}
{"name":"SimplexCategory.instHasStrongEpiMonoFactorisations","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"⊢ CategoryTheory.Limits.HasStrongEpiMonoFactorisations SimplexCategory","decl":"instance : HasStrongEpiMonoFactorisations SimplexCategory :=\n  Functor.hasStrongEpiMonoFactorisations_imp_of_isEquivalence\n    SimplexCategory.skeletalEquivalence.inverse\n\n"}
{"name":"SimplexCategory.instHasStrongEpiImages","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"⊢ CategoryTheory.Limits.HasStrongEpiImages SimplexCategory","decl":"instance : HasStrongEpiImages SimplexCategory :=\n  Limits.hasStrongEpiImages_of_hasStrongEpiMonoFactorisations\n\n"}
{"name":"SimplexCategory.instEpiFactorThruImage","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Δ Δ' : SimplexCategory\nθ : Quiver.Hom Δ Δ'\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.factorThruImage θ)","decl":"instance (Δ Δ' : SimplexCategory) (θ : Δ ⟶ Δ') : Epi (factorThruImage θ) :=\n  StrongEpi.epi\n\n"}
{"name":"SimplexCategory.image_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Δ Δ' Δ'' : SimplexCategory\nφ : Quiver.Hom Δ Δ''\ne : Quiver.Hom Δ Δ'\ninst✝¹ : CategoryTheory.Epi e\ni : Quiver.Hom Δ' Δ''\ninst✝ : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) φ\n⊢ Eq (CategoryTheory.Limits.image φ) Δ'","decl":"theorem image_eq {Δ Δ' Δ'' : SimplexCategory} {φ : Δ ⟶ Δ''} {e : Δ ⟶ Δ'} [Epi e] {i : Δ' ⟶ Δ''}\n    [Mono i] (fac : e ≫ i = φ) : image φ = Δ' := by\n  haveI := strongEpi_of_epi e\n  let e := image.isoStrongEpiMono e i fac\n  ext\n  exact\n    le_antisymm (len_le_of_epi (inferInstance : Epi e.hom))\n      (len_le_of_mono (inferInstance : Mono e.hom))\n\n"}
{"name":"SimplexCategory.image_ι_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Δ Δ'' : SimplexCategory\nφ : Quiver.Hom Δ Δ''\ne : Quiver.Hom Δ (CategoryTheory.Limits.image φ)\ninst✝¹ : CategoryTheory.Epi e\ni : Quiver.Hom (CategoryTheory.Limits.image φ) Δ''\ninst✝ : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) φ\n⊢ Eq (CategoryTheory.Limits.image.ι φ) i","decl":"theorem image_ι_eq {Δ Δ'' : SimplexCategory} {φ : Δ ⟶ Δ''} {e : Δ ⟶ image φ} [Epi e]\n    {i : image φ ⟶ Δ''} [Mono i] (fac : e ≫ i = φ) : image.ι φ = i := by\n  haveI := strongEpi_of_epi e\n  rw [← image.isoStrongEpiMono_hom_comp_ι e i fac,\n    SimplexCategory.eq_id_of_isIso (image.isoStrongEpiMono e i fac).hom, Category.id_comp]\n\n"}
{"name":"SimplexCategory.factorThruImage_eq","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"Δ Δ'' : SimplexCategory\nφ : Quiver.Hom Δ Δ''\ne : Quiver.Hom Δ (CategoryTheory.Limits.image φ)\ninst✝¹ : CategoryTheory.Epi e\ni : Quiver.Hom (CategoryTheory.Limits.image φ) Δ''\ninst✝ : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) φ\n⊢ Eq (CategoryTheory.Limits.factorThruImage φ) e","decl":"theorem factorThruImage_eq {Δ Δ'' : SimplexCategory} {φ : Δ ⟶ Δ''} {e : Δ ⟶ image φ} [Epi e]\n    {i : image φ ⟶ Δ''} [Mono i] (fac : e ≫ i = φ) : factorThruImage φ = e := by\n  rw [← cancel_mono i, fac, ← image_ι_eq fac, image.fac]\n\n"}
{"name":"SimplexCategory.toCat_map","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"X✝ Y✝ : SimplexCategory\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (SimplexCategory.toCat.map f) ⋯.functor","decl":"/-- This functor `SimplexCategory ⥤ Cat` sends `[n]` (for `n : ℕ`)\nto the category attached to the ordered set `{0, 1, ..., n}` -/\n@[simps! obj map]\ndef toCat : SimplexCategory ⥤ Cat.{0} :=\n  SimplexCategory.skeletalFunctor ⋙ forget₂ NonemptyFinLinOrd LinOrd ⋙\n      forget₂ LinOrd Lat ⋙ forget₂ Lat PartOrd ⋙\n      forget₂ PartOrd Preord ⋙ preordToCat\n\n"}
{"name":"SimplexCategory.toCat_obj","module":"Mathlib.AlgebraicTopology.SimplexCategory","initialProofState":"X : SimplexCategory\n⊢ Eq (SimplexCategory.toCat.obj X) (CategoryTheory.Cat.of ↑((CategoryTheory.forget₂ PartOrd Preord).obj ((CategoryTheory.forget₂ Lat PartOrd).obj ((CategoryTheory.forget₂ LinOrd Lat).obj ((CategoryTheory.forget₂ NonemptyFinLinOrd LinOrd).obj (NonemptyFinLinOrd.of (Fin (HAdd.hAdd X.len 1))))))))","decl":"/-- This functor `SimplexCategory ⥤ Cat` sends `[n]` (for `n : ℕ`)\nto the category attached to the ordered set `{0, 1, ..., n}` -/\n@[simps! obj map]\ndef toCat : SimplexCategory ⥤ Cat.{0} :=\n  SimplexCategory.skeletalFunctor ⋙ forget₂ NonemptyFinLinOrd LinOrd ⋙\n      forget₂ LinOrd Lat ⋙ forget₂ Lat PartOrd ⋙\n      forget₂ PartOrd Preord ⋙ preordToCat\n\n"}
