{"name":"CategoryTheory.IsPushout.hasLiftingProperty","module":"Mathlib.CategoryTheory.LiftingProperties.Limits","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y Z W : C\nf : Quiver.Hom X Y\ns : Quiver.Hom X Z\ng : Quiver.Hom Z W\nt : Quiver.Hom Y W\nh : CategoryTheory.IsPushout s f g t\nZ' W' : C\ng' : Quiver.Hom Z' W'\ninst✝ : CategoryTheory.HasLiftingProperty f g'\n⊢ CategoryTheory.HasLiftingProperty g g'","decl":"lemma IsPushout.hasLiftingProperty (h : IsPushout s f g t)\n    {Z' W' : C} (g' : Z' ⟶ W') [HasLiftingProperty f g'] : HasLiftingProperty g g' where\n  sq_hasLift := fun {u v} sq ↦ by\n    have w : (s ≫ u) ≫ g' = f ≫ (t ≫ v) := by\n      rw [← Category.assoc, ← h.w, Category.assoc, Category.assoc, sq.w]\n    exact ⟨h.desc u (CommSq.mk w).lift (by rw [CommSq.fac_left]), h.inl_desc ..,\n      h.hom_ext (by rw [h.inl_desc_assoc, sq.w]) (by rw [h.inr_desc_assoc, CommSq.fac_right])⟩\n\n"}
{"name":"CategoryTheory.IsPullback.hasLiftingProperty","module":"Mathlib.CategoryTheory.LiftingProperties.Limits","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y Z W : C\nf : Quiver.Hom X Y\ns : Quiver.Hom X Z\ng : Quiver.Hom Z W\nt : Quiver.Hom Y W\nh : CategoryTheory.IsPullback s f g t\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst✝ : CategoryTheory.HasLiftingProperty f' g\n⊢ CategoryTheory.HasLiftingProperty f' f","decl":"lemma IsPullback.hasLiftingProperty (h : IsPullback s f g t)\n    {X' Y' : C} (f' : X' ⟶ Y') [HasLiftingProperty f' g] : HasLiftingProperty f' f where\n  sq_hasLift := fun {u v} sq ↦ by\n    have w : (u ≫ s) ≫ g = f' ≫ v ≫ t := by\n      rw [Category.assoc, h.toCommSq.w, ← Category.assoc, ← Category.assoc, sq.w]\n    exact ⟨h.lift (CommSq.mk w).lift v (by rw [CommSq.fac_right]),\n      h.hom_ext (by rw [Category.assoc, h.lift_fst, CommSq.fac_left])\n        (by rw [Category.assoc, h.lift_snd, sq.w]), h.lift_snd _ _ _⟩\n\n"}
{"name":"CategoryTheory.instHasLiftingPropertyInl","module":"Mathlib.CategoryTheory.LiftingProperties.Limits","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y Z : C\nf : Quiver.Hom X Y\ns : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.Limits.HasPushout s f\nT₁ T₂ : C\np : Quiver.Hom T₁ T₂\ninst✝ : CategoryTheory.HasLiftingProperty f p\n⊢ CategoryTheory.HasLiftingProperty (CategoryTheory.Limits.pushout.inl s f) p","decl":"instance [HasPushout s f] {T₁ T₂ : C} (p : T₁ ⟶ T₂) [HasLiftingProperty f p] :\n    HasLiftingProperty (pushout.inl s f) p :=\n  (IsPushout.of_hasPushout s f).hasLiftingProperty p\n\n"}
{"name":"CategoryTheory.instHasLiftingPropertyInr","module":"Mathlib.CategoryTheory.LiftingProperties.Limits","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y Z : C\nf : Quiver.Hom X Y\ns : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.Limits.HasPushout s f\nT₁ T₂ : C\np : Quiver.Hom T₁ T₂\ninst✝ : CategoryTheory.HasLiftingProperty s p\n⊢ CategoryTheory.HasLiftingProperty (CategoryTheory.Limits.pushout.inr s f) p","decl":"instance [HasPushout s f] {T₁ T₂ : C} (p : T₁ ⟶ T₂) [HasLiftingProperty s p] :\n    HasLiftingProperty (pushout.inr s f) p :=\n  (IsPushout.of_hasPushout s f).flip.hasLiftingProperty p\n\n"}
{"name":"CategoryTheory.instHasLiftingPropertySnd","module":"Mathlib.CategoryTheory.LiftingProperties.Limits","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nY Z W : C\ng : Quiver.Hom Z W\nt : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Limits.HasPullback g t\nT₁ T₂ : C\np : Quiver.Hom T₁ T₂\ninst✝ : CategoryTheory.HasLiftingProperty p g\n⊢ CategoryTheory.HasLiftingProperty p (CategoryTheory.Limits.pullback.snd g t)","decl":"instance [HasPullback g t] {T₁ T₂ : C} (p : T₁ ⟶ T₂) [HasLiftingProperty p g] :\n    HasLiftingProperty p (pullback.snd g t) :=\n  (IsPullback.of_hasPullback g t).hasLiftingProperty p\n\n"}
{"name":"CategoryTheory.instHasLiftingPropertyFst","module":"Mathlib.CategoryTheory.LiftingProperties.Limits","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nY Z W : C\ng : Quiver.Hom Z W\nt : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Limits.HasPullback g t\nT₁ T₂ : C\np : Quiver.Hom T₁ T₂\ninst✝ : CategoryTheory.HasLiftingProperty p t\n⊢ CategoryTheory.HasLiftingProperty p (CategoryTheory.Limits.pullback.fst g t)","decl":"instance [HasPullback g t] {T₁ T₂ : C} (p : T₁ ⟶ T₂) [HasLiftingProperty p t] :\n    HasLiftingProperty p (pullback.fst g t) :=\n  (IsPullback.of_hasPullback g t).flip.hasLiftingProperty p\n\n"}
{"name":"CategoryTheory.instHasLiftingPropertyMap","module":"Mathlib.CategoryTheory.LiftingProperties.Limits","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nJ : Type u_2\nA B : J → C\ninst✝² : CategoryTheory.Limits.HasProduct A\ninst✝¹ : CategoryTheory.Limits.HasProduct B\nf : (j : J) → Quiver.Hom (A j) (B j)\nX Y : C\np : Quiver.Hom X Y\ninst✝ : ∀ (j : J), CategoryTheory.HasLiftingProperty p (f j)\n⊢ CategoryTheory.HasLiftingProperty p (CategoryTheory.Limits.Pi.map f)","decl":"instance {J : Type*} {A B : J → C} [HasProduct A] [HasProduct B]\n    (f : (j : J) → A j ⟶ B j) {X Y : C} (p : X ⟶ Y)\n    [∀ j, HasLiftingProperty p (f j)] :\n    HasLiftingProperty p (Limits.Pi.map f) where\n  sq_hasLift {t b} sq := by\n    have sq' (j : J) :\n        CommSq (t ≫ Pi.π _ j) p (f j) (b ≫ Pi.π _ j) :=\n      ⟨by rw [← Category.assoc, ← sq.w]; simp⟩\n    exact ⟨⟨{ l := Pi.lift (fun j ↦ (sq' j).lift) }⟩⟩\n\n"}
{"name":"CategoryTheory.instHasLiftingPropertyMap_1","module":"Mathlib.CategoryTheory.LiftingProperties.Limits","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nJ : Type u_2\nA B : J → C\ninst✝² : CategoryTheory.Limits.HasCoproduct A\ninst✝¹ : CategoryTheory.Limits.HasCoproduct B\nf : (j : J) → Quiver.Hom (A j) (B j)\nX Y : C\np : Quiver.Hom X Y\ninst✝ : ∀ (j : J), CategoryTheory.HasLiftingProperty (f j) p\n⊢ CategoryTheory.HasLiftingProperty (CategoryTheory.Limits.Sigma.map f) p","decl":"instance {J : Type*} {A B : J → C} [HasCoproduct A] [HasCoproduct B]\n    (f : (j : J) → A j ⟶ B j) {X Y : C} (p : X ⟶ Y)\n    [∀ j, HasLiftingProperty (f j) p] :\n    HasLiftingProperty (Limits.Sigma.map f) p where\n  sq_hasLift {t b} sq := by\n    have sq' (j : J) :\n        CommSq (Sigma.ι _ j ≫ t) (f j) p (Sigma.ι _ j ≫ b) :=\n      ⟨by simp [sq.w]⟩\n    exact ⟨⟨{ l := Sigma.desc (fun j ↦ (sq' j).lift) }⟩⟩\n\n"}
