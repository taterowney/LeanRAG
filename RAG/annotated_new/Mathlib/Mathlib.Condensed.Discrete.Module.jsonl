{"name":"CompHausLike.LocallyConstantModule.functorToPresheaves_map_app","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"P : TopCat → Prop\nR : Type (max u w)\ninst✝ : Ring R\nX✝ Y✝ : ModuleCat R\nf : Quiver.Hom X✝ Y✝\nS : Opposite (CompHausLike P)\n⊢ Eq (((CompHausLike.LocallyConstantModule.functorToPresheaves R).map f).app S) (ModuleCat.ofHom (LocallyConstant.mapₗ R (ModuleCat.Hom.hom f)))","decl":"/--\nThe functor from the category of `R`-modules to presheaves on `CompHausLike P` given by locally\nconstant maps.\n-/\n@[simps]\ndef functorToPresheaves : ModuleCat.{max u w} R ⥤ ((CompHausLike.{u} P)ᵒᵖ ⥤ ModuleCat R) where\n  obj X := {\n    obj := fun ⟨S⟩ ↦ ModuleCat.of R (LocallyConstant S X)\n    map := fun f ↦ ModuleCat.ofHom (comapₗ R f.unop) }\n  map f := { app := fun S ↦ ModuleCat.ofHom (mapₗ R f.hom) }\n\n"}
{"name":"CompHausLike.LocallyConstantModule.functorToPresheaves_obj_obj_carrier","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"P : TopCat → Prop\nR : Type (max u w)\ninst✝ : Ring R\nX : ModuleCat R\nx✝ : Opposite (CompHausLike P)\n⊢ Eq (↑(((CompHausLike.LocallyConstantModule.functorToPresheaves R).obj X).obj x✝)) (LocallyConstant ↑(Opposite.unop x✝).toTop ↑X)","decl":"/--\nThe functor from the category of `R`-modules to presheaves on `CompHausLike P` given by locally\nconstant maps.\n-/\n@[simps]\ndef functorToPresheaves : ModuleCat.{max u w} R ⥤ ((CompHausLike.{u} P)ᵒᵖ ⥤ ModuleCat R) where\n  obj X := {\n    obj := fun ⟨S⟩ ↦ ModuleCat.of R (LocallyConstant S X)\n    map := fun f ↦ ModuleCat.ofHom (comapₗ R f.unop) }\n  map f := { app := fun S ↦ ModuleCat.ofHom (mapₗ R f.hom) }\n\n"}
{"name":"CompHausLike.LocallyConstantModule.functorToPresheaves_obj_obj_isAddCommGroup","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"P : TopCat → Prop\nR : Type (max u w)\ninst✝ : Ring R\nX : ModuleCat R\nx✝ : Opposite (CompHausLike P)\n⊢ Eq (((CompHausLike.LocallyConstantModule.functorToPresheaves R).obj X).obj x✝).isAddCommGroup LocallyConstant.instAddCommGroup","decl":"/--\nThe functor from the category of `R`-modules to presheaves on `CompHausLike P` given by locally\nconstant maps.\n-/\n@[simps]\ndef functorToPresheaves : ModuleCat.{max u w} R ⥤ ((CompHausLike.{u} P)ᵒᵖ ⥤ ModuleCat R) where\n  obj X := {\n    obj := fun ⟨S⟩ ↦ ModuleCat.of R (LocallyConstant S X)\n    map := fun f ↦ ModuleCat.ofHom (comapₗ R f.unop) }\n  map f := { app := fun S ↦ ModuleCat.ofHom (mapₗ R f.hom) }\n\n"}
{"name":"CompHausLike.LocallyConstantModule.functorToPresheaves_obj_map","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"P : TopCat → Prop\nR : Type (max u w)\ninst✝ : Ring R\nX : ModuleCat R\nX✝ Y✝ : Opposite (CompHausLike P)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CompHausLike.LocallyConstantModule.functorToPresheaves R).obj X).map f) (ModuleCat.ofHom (LocallyConstant.comapₗ R f.unop))","decl":"/--\nThe functor from the category of `R`-modules to presheaves on `CompHausLike P` given by locally\nconstant maps.\n-/\n@[simps]\ndef functorToPresheaves : ModuleCat.{max u w} R ⥤ ((CompHausLike.{u} P)ᵒᵖ ⥤ ModuleCat R) where\n  obj X := {\n    obj := fun ⟨S⟩ ↦ ModuleCat.of R (LocallyConstant S X)\n    map := fun f ↦ ModuleCat.ofHom (comapₗ R f.unop) }\n  map f := { app := fun S ↦ ModuleCat.ofHom (mapₗ R f.hom) }\n\n"}
{"name":"CompHausLike.LocallyConstantModule.functorToPresheaves_obj_obj_isModule","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"P : TopCat → Prop\nR : Type (max u w)\ninst✝ : Ring R\nX : ModuleCat R\nx✝ : Opposite (CompHausLike P)\n⊢ Eq (((CompHausLike.LocallyConstantModule.functorToPresheaves R).obj X).obj x✝).isModule LocallyConstant.instModule","decl":"/--\nThe functor from the category of `R`-modules to presheaves on `CompHausLike P` given by locally\nconstant maps.\n-/\n@[simps]\ndef functorToPresheaves : ModuleCat.{max u w} R ⥤ ((CompHausLike.{u} P)ᵒᵖ ⥤ ModuleCat R) where\n  obj X := {\n    obj := fun ⟨S⟩ ↦ ModuleCat.of R (LocallyConstant S X)\n    map := fun f ↦ ModuleCat.ofHom (comapₗ R f.unop) }\n  map f := { app := fun S ↦ ModuleCat.ofHom (mapₗ R f.hom) }\n\n"}
{"name":"CompHausLike.LocallyConstantModule.functor_map_val","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"P : TopCat → Prop\nR : Type (max u w)\ninst✝² : Ring R\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\nX✝ Y✝ : ModuleCat R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CompHausLike.LocallyConstantModule.functor R hs).map f).val ((CompHausLike.LocallyConstantModule.functorToPresheaves R).map f)","decl":"/-- `CompHausLike.LocallyConstantModule.functorToPresheaves` lands in sheaves. -/\n@[simps]\ndef functor : haveI := CompHausLike.preregular hs\n    ModuleCat R ⥤ Sheaf (coherentTopology (CompHausLike.{u} P)) (ModuleCat R) where\n  obj X := {\n    val := (functorToPresheaves.{w, u} R).obj X\n    cond := by\n      have := CompHausLike.preregular hs\n      apply Presheaf.isSheaf_coherent_of_hasPullbacks_of_comp\n        (s := CategoryTheory.forget (ModuleCat R))\n      exact ((CompHausLike.LocallyConstant.functor P hs).obj _).cond }\n  map f := ⟨(functorToPresheaves.{w, u} R).map f⟩\n\n"}
{"name":"CompHausLike.LocallyConstantModule.functor_obj_val","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"P : TopCat → Prop\nR : Type (max u w)\ninst✝² : Ring R\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\nX : ModuleCat R\n⊢ Eq ((CompHausLike.LocallyConstantModule.functor R hs).obj X).val ((CompHausLike.LocallyConstantModule.functorToPresheaves R).obj X)","decl":"/-- `CompHausLike.LocallyConstantModule.functorToPresheaves` lands in sheaves. -/\n@[simps]\ndef functor : haveI := CompHausLike.preregular hs\n    ModuleCat R ⥤ Sheaf (coherentTopology (CompHausLike.{u} P)) (ModuleCat R) where\n  obj X := {\n    val := (functorToPresheaves.{w, u} R).obj X\n    cond := by\n      have := CompHausLike.preregular hs\n      apply Presheaf.isSheaf_coherent_of_hasPullbacks_of_comp\n        (s := CategoryTheory.forget (ModuleCat R))\n      exact ((CompHausLike.LocallyConstant.functor P hs).obj _).cond }\n  map f := ⟨(functorToPresheaves.{w, u} R).map f⟩\n\n"}
{"name":"CondensedMod.LocallyConstant.instIsIsoCondensedSetMapForgetAppCondensedModuleCatCounitDiscreteUnderlyingAdjObjFunctor","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type (u + 1)\ninst✝ : Ring R\nM : ModuleCat R\n⊢ CategoryTheory.IsIso ((Condensed.forget R).map ((Condensed.discreteUnderlyingAdj (ModuleCat R)).counit.app ((CondensedMod.LocallyConstant.functor R).obj M)))","decl":"instance (M : ModuleCat R) : IsIso ((forget R).map\n    ((discreteUnderlyingAdj (ModuleCat R)).counit.app ((functor R).obj M))) := by\n  dsimp [Condensed.forget, discreteUnderlyingAdj]\n  rw [← constantSheafAdj_counit_w]\n  refine IsIso.comp_isIso' inferInstance ?_\n  have : (constantSheaf (coherentTopology CompHaus) (Type (u + 1))).Faithful :=\n    inferInstanceAs (discrete _).Faithful\n  have : (constantSheaf (coherentTopology CompHaus) (Type (u + 1))).Full :=\n    inferInstanceAs (discrete _).Full\n  rw [← Sheaf.isConstant_iff_isIso_counit_app]\n  constructor\n  change _ ∈ (discrete _).essImage\n  rw [essImage_eq_of_natIso CondensedSet.LocallyConstant.iso.symm]\n  exact obj_mem_essImage CondensedSet.LocallyConstant.functor M\n\n"}
{"name":"CondensedMod.LocallyConstant.instFaithfulModuleCatFunctor","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type (u + 1)\ninst✝ : Ring R\n⊢ (CondensedMod.LocallyConstant.functor R).Faithful","decl":"instance : (functor R).Faithful := (fullyFaithfulFunctor R).faithful\n\n"}
{"name":"CondensedMod.LocallyConstant.instFullModuleCatFunctor","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type (u + 1)\ninst✝ : Ring R\n⊢ (CondensedMod.LocallyConstant.functor R).Full","decl":"instance : (functor R).Full := (fullyFaithfulFunctor R).full\n\n"}
{"name":"CondensedMod.LocallyConstant.instFaithfulModuleCatCondensedDiscrete","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type (u + 1)\ninst✝ : Ring R\n⊢ (Condensed.discrete (ModuleCat R)).Faithful","decl":"instance : (discrete (ModuleCat R)).Faithful :=\n  Functor.Faithful.of_iso (functorIsoDiscrete R)\n\n"}
{"name":"CondensedMod.LocallyConstant.instFaithfulModuleCatSheafCompHausCoherentTopologyConstantSheaf","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type (u + 1)\ninst✝ : Ring R\n⊢ (CategoryTheory.constantSheaf (CategoryTheory.coherentTopology CompHaus) (ModuleCat R)).Faithful","decl":"instance : (constantSheaf (coherentTopology CompHaus) (ModuleCat R)).Faithful :=\n  inferInstanceAs (discrete (ModuleCat R)).Faithful\n\n"}
{"name":"CondensedMod.LocallyConstant.instFullModuleCatCondensedDiscrete","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type (u + 1)\ninst✝ : Ring R\n⊢ (Condensed.discrete (ModuleCat R)).Full","decl":"instance : (discrete (ModuleCat R)).Full :=\n  Functor.Full.of_iso (functorIsoDiscrete R)\n\n"}
{"name":"CondensedMod.LocallyConstant.instFullModuleCatSheafCompHausCoherentTopologyConstantSheaf","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type (u + 1)\ninst✝ : Ring R\n⊢ (CategoryTheory.constantSheaf (CategoryTheory.coherentTopology CompHaus) (ModuleCat R)).Full","decl":"instance : (constantSheaf (coherentTopology CompHaus) (ModuleCat R)).Full :=\n  inferInstanceAs (discrete (ModuleCat R)).Full\n\n"}
{"name":"CondensedMod.LocallyConstant.instFaithfulSheafCompHausCoherentTopologyTypeConstantSheaf","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"⊢ (CategoryTheory.constantSheaf (CategoryTheory.coherentTopology CompHaus) (Type (u + 1))).Faithful","decl":"instance : (constantSheaf (coherentTopology CompHaus) (Type (u + 1))).Faithful :=\n  inferInstanceAs (discrete (Type (u + 1))).Faithful\n\n"}
{"name":"CondensedMod.LocallyConstant.instFullSheafCompHausCoherentTopologyTypeConstantSheaf","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"⊢ (CategoryTheory.constantSheaf (CategoryTheory.coherentTopology CompHaus) (Type (u + 1))).Full","decl":"instance : (constantSheaf (coherentTopology CompHaus) (Type (u + 1))).Full :=\n  inferInstanceAs (discrete (Type (u + 1))).Full\n\n"}
{"name":"LightCondMod.LocallyConstant.instHasSheafifyLightProfiniteCoherentTopologyModuleCat","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.HasSheafify (CategoryTheory.coherentTopology LightProfinite) (ModuleCat R)","decl":"instance : HasSheafify (coherentTopology LightProfinite.{u}) (ModuleCat.{u} R) :=\n  inferInstance\n\n"}
{"name":"LightCondMod.LocallyConstant.instIsIsoLightCondSetMapForgetAppLightCondensedModuleCatCounitDiscreteUnderlyingAdjObjFunctor","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type u\ninst✝ : Ring R\nM : ModuleCat R\n⊢ CategoryTheory.IsIso ((LightCondensed.forget R).map ((LightCondensed.discreteUnderlyingAdj (ModuleCat R)).counit.app ((LightCondMod.LocallyConstant.functor R).obj M)))","decl":"instance (M : ModuleCat R) :\n    IsIso ((LightCondensed.forget R).map\n    ((discreteUnderlyingAdj (ModuleCat R)).counit.app\n      ((functor R).obj M))) := by\n  dsimp [LightCondensed.forget, discreteUnderlyingAdj]\n  rw [← constantSheafAdj_counit_w]\n  refine IsIso.comp_isIso' inferInstance ?_\n  have : (constantSheaf (coherentTopology LightProfinite) (Type u)).Faithful :=\n    inferInstanceAs (discrete _).Faithful\n  have : (constantSheaf (coherentTopology LightProfinite) (Type u)).Full :=\n    inferInstanceAs (discrete _).Full\n  rw [← Sheaf.isConstant_iff_isIso_counit_app]\n  constructor\n  change _ ∈ (discrete _).essImage\n  rw [essImage_eq_of_natIso LightCondSet.LocallyConstant.iso.symm]\n  exact obj_mem_essImage LightCondSet.LocallyConstant.functor M\n\n"}
{"name":"LightCondMod.LocallyConstant.instFaithfulModuleCatFunctor","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ (LightCondMod.LocallyConstant.functor R).Faithful","decl":"instance : (functor R).Faithful := (fullyFaithfulFunctor R).faithful\n\n"}
{"name":"LightCondMod.LocallyConstant.instFullModuleCatFunctor","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ (LightCondMod.LocallyConstant.functor R).Full","decl":"instance : (functor R).Full := (fullyFaithfulFunctor R).full\n\n"}
{"name":"LightCondMod.LocallyConstant.instFaithfulModuleCatLightCondensedDiscrete","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ (LightCondensed.discrete (ModuleCat R)).Faithful","decl":"instance : (discrete.{u} (ModuleCat R)).Faithful := Functor.Faithful.of_iso (functorIsoDiscrete R)\n\n"}
{"name":"LightCondMod.LocallyConstant.instFaithfulModuleCatSheafLightProfiniteCoherentTopologyConstantSheaf","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ (CategoryTheory.constantSheaf (CategoryTheory.coherentTopology LightProfinite) (ModuleCat R)).Faithful","decl":"instance : (constantSheaf (coherentTopology LightProfinite.{u}) (ModuleCat.{u} R)).Faithful :=\n  inferInstanceAs (discrete.{u} (ModuleCat R)).Faithful\n\n"}
{"name":"LightCondMod.LocallyConstant.instFullModuleCatLightCondensedDiscrete","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ (LightCondensed.discrete (ModuleCat R)).Full","decl":"instance : (discrete (ModuleCat.{u} R)).Full :=\n  Functor.Full.of_iso (functorIsoDiscrete R)\n\n"}
{"name":"LightCondMod.LocallyConstant.instFullModuleCatSheafLightProfiniteCoherentTopologyConstantSheaf","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ (CategoryTheory.constantSheaf (CategoryTheory.coherentTopology LightProfinite) (ModuleCat R)).Full","decl":"instance : (constantSheaf (coherentTopology LightProfinite.{u}) (ModuleCat.{u} R)).Full :=\n  inferInstanceAs (discrete.{u} (ModuleCat.{u} R)).Full\n\n"}
{"name":"LightCondMod.LocallyConstant.instFaithfulSheafLightProfiniteCoherentTopologyTypeConstantSheaf","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"⊢ (CategoryTheory.constantSheaf (CategoryTheory.coherentTopology LightProfinite) (Type u)).Faithful","decl":"instance : (constantSheaf (coherentTopology LightProfinite) (Type u)).Faithful :=\n  inferInstanceAs (discrete (Type u)).Faithful\n\n"}
{"name":"LightCondMod.LocallyConstant.instFullSheafLightProfiniteCoherentTopologyTypeConstantSheaf","module":"Mathlib.Condensed.Discrete.Module","initialProofState":"⊢ (CategoryTheory.constantSheaf (CategoryTheory.coherentTopology LightProfinite) (Type u)).Full","decl":"instance : (constantSheaf (coherentTopology LightProfinite) (Type u)).Full :=\n  inferInstanceAs (discrete (Type u)).Full\n\n"}
