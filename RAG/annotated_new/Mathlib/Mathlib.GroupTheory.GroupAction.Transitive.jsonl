{"name":"AddAction.isPretransitive_iff_base","module":"Mathlib.GroupTheory.GroupAction.Transitive","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G X\na : X\n⊢ Iff (AddAction.IsPretransitive G X) (∀ (x : X), Exists fun g => Eq (HVAdd.hVAdd g a) x)","decl":"/-- An action of a group is pretransitive iff any element can be moved from a fixed given one. -/\n@[to_additive\n  \"An additive action of an additive group is pretransitive\n  iff any element can be moved from a fixed given one.\"]\ntheorem isPretransitive_iff_base (a : X) :\n    IsPretransitive G X ↔ ∀ x : X, ∃ g : G, g • a = x where\n  mp hG x := exists_smul_eq _ a x\n  mpr hG := .mk fun x y ↦ by\n    obtain ⟨g, hx⟩ := hG x\n    obtain ⟨h, hy⟩ := hG y\n    exact ⟨h * g⁻¹, by rw [← hx, smul_smul, inv_mul_cancel_right, hy]⟩\n\n"}
{"name":"MulAction.isPretransitive_iff_base","module":"Mathlib.GroupTheory.GroupAction.Transitive","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G X\na : X\n⊢ Iff (MulAction.IsPretransitive G X) (∀ (x : X), Exists fun g => Eq (HSMul.hSMul g a) x)","decl":"/-- An action of a group is pretransitive iff any element can be moved from a fixed given one. -/\n@[to_additive\n  \"An additive action of an additive group is pretransitive\n  iff any element can be moved from a fixed given one.\"]\ntheorem isPretransitive_iff_base (a : X) :\n    IsPretransitive G X ↔ ∀ x : X, ∃ g : G, g • a = x where\n  mp hG x := exists_smul_eq _ a x\n  mpr hG := .mk fun x y ↦ by\n    obtain ⟨g, hx⟩ := hG x\n    obtain ⟨h, hy⟩ := hG y\n    exact ⟨h * g⁻¹, by rw [← hx, smul_smul, inv_mul_cancel_right, hy]⟩\n\n"}
{"name":"MulAction.isPretransitive_iff_orbit_eq_top","module":"Mathlib.GroupTheory.GroupAction.Transitive","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G X\na : X\n⊢ Iff (MulAction.IsPretransitive G X) (Eq (MulAction.orbit G a) Top.top)","decl":"/-- An action of a group is pretransitive iff the orbit of every given element is full -/\n@[to_additive\n  \"An action of a group is pretransitive iff the orbit of every given element is full\"]\ntheorem isPretransitive_iff_orbit_eq_top (a : X) :\n    IsPretransitive G X ↔ orbit G a = ⊤ := by\n  rw [isPretransitive_iff_base a, Set.ext_iff]\n  apply forall_congr'\n  intro x\n  simp_rw [Set.top_eq_univ, Set.mem_univ, iff_true, mem_orbit_iff]\n\n"}
{"name":"AddAction.isPretransitive_iff_orbit_eq_top","module":"Mathlib.GroupTheory.GroupAction.Transitive","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G X\na : X\n⊢ Iff (AddAction.IsPretransitive G X) (Eq (AddAction.orbit G a) Top.top)","decl":"/-- An action of a group is pretransitive iff the orbit of every given element is full -/\n@[to_additive\n  \"An action of a group is pretransitive iff the orbit of every given element is full\"]\ntheorem isPretransitive_iff_orbit_eq_top (a : X) :\n    IsPretransitive G X ↔ orbit G a = ⊤ := by\n  rw [isPretransitive_iff_base a, Set.ext_iff]\n  apply forall_congr'\n  intro x\n  simp_rw [Set.top_eq_univ, Set.mem_univ, iff_true, mem_orbit_iff]\n\n"}
{"name":"AddAction.IsPretransitive.of_surjective_map","module":"Mathlib.GroupTheory.GroupAction.Transitive","initialProofState":"M : Type u_3\nN : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝³ : AddMonoid M\ninst✝² : AddMonoid N\ninst✝¹ : AddAction M α\ninst✝ : AddAction N β\nφ : M → N\nf : AddActionHom φ α β\nhf : Function.Surjective ⇑f\nh : AddAction.IsPretransitive M α\n⊢ AddAction.IsPretransitive N β","decl":"@[to_additive]\ntheorem IsPretransitive.of_surjective_map {φ : M → N} {f : α →ₑ[φ] β}\n    (hf : Function.Surjective f) (h : IsPretransitive M α) :\n    IsPretransitive N β := by\n  apply MulAction.IsPretransitive.mk\n  intro x y\n  obtain ⟨x', rfl⟩ := hf x\n  obtain ⟨y', rfl⟩ := hf y\n  obtain ⟨g, rfl⟩ := h.exists_smul_eq x' y'\n  exact ⟨φ g, by simp only [map_smulₛₗ]⟩\n\n"}
{"name":"MulAction.IsPretransitive.of_surjective_map","module":"Mathlib.GroupTheory.GroupAction.Transitive","initialProofState":"M : Type u_3\nN : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝³ : Monoid M\ninst✝² : Monoid N\ninst✝¹ : MulAction M α\ninst✝ : MulAction N β\nφ : M → N\nf : MulActionHom φ α β\nhf : Function.Surjective ⇑f\nh : MulAction.IsPretransitive M α\n⊢ MulAction.IsPretransitive N β","decl":"@[to_additive]\ntheorem IsPretransitive.of_surjective_map {φ : M → N} {f : α →ₑ[φ] β}\n    (hf : Function.Surjective f) (h : IsPretransitive M α) :\n    IsPretransitive N β := by\n  apply MulAction.IsPretransitive.mk\n  intro x y\n  obtain ⟨x', rfl⟩ := hf x\n  obtain ⟨y', rfl⟩ := hf y\n  obtain ⟨g, rfl⟩ := h.exists_smul_eq x' y'\n  exact ⟨φ g, by simp only [map_smulₛₗ]⟩\n\n"}
{"name":"AddAction.isPretransitive_congr","module":"Mathlib.GroupTheory.GroupAction.Transitive","initialProofState":"M : Type u_3\nN : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝³ : AddMonoid M\ninst✝² : AddMonoid N\ninst✝¹ : AddAction M α\ninst✝ : AddAction N β\nφ : M → N\nf : AddActionHom φ α β\nhφ : Function.Surjective φ\nhf : Function.Bijective ⇑f\n⊢ Iff (AddAction.IsPretransitive M α) (AddAction.IsPretransitive N β)","decl":"@[to_additive]\ntheorem isPretransitive_congr {φ : M → N} {f : α →ₑ[φ] β}\n    (hφ : Function.Surjective φ) (hf : Function.Bijective f) :\n    IsPretransitive M α ↔ IsPretransitive N β := by\n  constructor\n  · apply IsPretransitive.of_surjective_map hf.surjective\n  · intro hN\n    apply IsPretransitive.mk\n    intro x y\n    obtain ⟨k, hk⟩ := hN.exists_smul_eq (f x) (f y)\n    obtain ⟨g, rfl⟩ := hφ k\n    use g\n    apply hf.injective\n    simp only [hk, map_smulₛₗ]\n\n"}
{"name":"MulAction.isPretransitive_congr","module":"Mathlib.GroupTheory.GroupAction.Transitive","initialProofState":"M : Type u_3\nN : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝³ : Monoid M\ninst✝² : Monoid N\ninst✝¹ : MulAction M α\ninst✝ : MulAction N β\nφ : M → N\nf : MulActionHom φ α β\nhφ : Function.Surjective φ\nhf : Function.Bijective ⇑f\n⊢ Iff (MulAction.IsPretransitive M α) (MulAction.IsPretransitive N β)","decl":"@[to_additive]\ntheorem isPretransitive_congr {φ : M → N} {f : α →ₑ[φ] β}\n    (hφ : Function.Surjective φ) (hf : Function.Bijective f) :\n    IsPretransitive M α ↔ IsPretransitive N β := by\n  constructor\n  · apply IsPretransitive.of_surjective_map hf.surjective\n  · intro hN\n    apply IsPretransitive.mk\n    intro x y\n    obtain ⟨k, hk⟩ := hN.exists_smul_eq (f x) (f y)\n    obtain ⟨g, rfl⟩ := hφ k\n    use g\n    apply hf.injective\n    simp only [hk, map_smulₛₗ]\n\n"}
