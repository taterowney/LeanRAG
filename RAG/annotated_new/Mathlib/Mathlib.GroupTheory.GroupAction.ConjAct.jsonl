{"name":"ConjAct.card","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : Fintype G\n⊢ Eq (Fintype.card (ConjAct G)) (Fintype.card G)","decl":"@[simp]\ntheorem card [Fintype G] : Fintype.card (ConjAct G) = Fintype.card G :=\n  rfl\n\n"}
{"name":"ConjAct.forall","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\np : ConjAct G → Prop\n⊢ Iff (∀ (x : ConjAct G), p x) (∀ (x : G), p (ConjAct.toConjAct x))","decl":"@[simp]\ntheorem «forall» (p : ConjAct G → Prop) : (∀ x : ConjAct G, p x) ↔ ∀ x : G, p (toConjAct x) :=\n  id Iff.rfl\n\n"}
{"name":"ConjAct.of_mul_symm_eq","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\n⊢ Eq ConjAct.ofConjAct.symm ConjAct.toConjAct","decl":"@[simp]\ntheorem of_mul_symm_eq : (@ofConjAct G _).symm = toConjAct :=\n  rfl\n\n"}
{"name":"ConjAct.to_mul_symm_eq","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\n⊢ Eq ConjAct.toConjAct.symm ConjAct.ofConjAct","decl":"@[simp]\ntheorem to_mul_symm_eq : (@toConjAct G _).symm = ofConjAct :=\n  rfl\n\n"}
{"name":"ConjAct.toConjAct_ofConjAct","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\nx : ConjAct G\n⊢ Eq (ConjAct.toConjAct (ConjAct.ofConjAct x)) x","decl":"@[simp]\ntheorem toConjAct_ofConjAct (x : ConjAct G) : toConjAct (ofConjAct x) = x :=\n  rfl\n\n"}
{"name":"ConjAct.ofConjAct_toConjAct","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\nx : G\n⊢ Eq (ConjAct.ofConjAct (ConjAct.toConjAct x)) x","decl":"@[simp]\ntheorem ofConjAct_toConjAct (x : G) : ofConjAct (toConjAct x) = x :=\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): removed `simp` attribute because `simpNF` says it can prove it\n"}
{"name":"ConjAct.ofConjAct_one","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\n⊢ Eq (ConjAct.ofConjAct 1) 1","decl":"theorem ofConjAct_one : ofConjAct (1 : ConjAct G) = 1 :=\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): removed `simp` attribute because `simpNF` says it can prove it\n"}
{"name":"ConjAct.toConjAct_one","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\n⊢ Eq (ConjAct.toConjAct 1) 1","decl":"theorem toConjAct_one : toConjAct (1 : G) = 1 :=\n  rfl\n\n"}
{"name":"ConjAct.ofConjAct_inv","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\nx : ConjAct G\n⊢ Eq (ConjAct.ofConjAct (Inv.inv x)) (Inv.inv (ConjAct.ofConjAct x))","decl":"@[simp]\ntheorem ofConjAct_inv (x : ConjAct G) : ofConjAct x⁻¹ = (ofConjAct x)⁻¹ :=\n  rfl\n\n"}
{"name":"ConjAct.toConjAct_inv","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\nx : G\n⊢ Eq (ConjAct.toConjAct (Inv.inv x)) (Inv.inv (ConjAct.toConjAct x))","decl":"@[simp]\ntheorem toConjAct_inv (x : G) : toConjAct x⁻¹ = (toConjAct x)⁻¹ :=\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): removed `simp` attribute because `simpNF` says it can prove it\n"}
{"name":"ConjAct.ofConjAct_mul","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\nx y : ConjAct G\n⊢ Eq (ConjAct.ofConjAct (HMul.hMul x y)) (HMul.hMul (ConjAct.ofConjAct x) (ConjAct.ofConjAct y))","decl":"theorem ofConjAct_mul (x y : ConjAct G) : ofConjAct (x * y) = ofConjAct x * ofConjAct y :=\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): removed `simp` attribute because `simpNF` says it can prove it\n"}
{"name":"ConjAct.toConjAct_mul","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\nx y : G\n⊢ Eq (ConjAct.toConjAct (HMul.hMul x y)) (HMul.hMul (ConjAct.toConjAct x) (ConjAct.toConjAct y))","decl":"theorem toConjAct_mul (x y : G) : toConjAct (x * y) = toConjAct x * toConjAct y :=\n  rfl\n\n"}
{"name":"ConjAct.smul_def","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\ng : ConjAct G\nh : G\n⊢ Eq (HSMul.hSMul g h) (HMul.hMul (HMul.hMul (ConjAct.ofConjAct g) h) (Inv.inv (ConjAct.ofConjAct g)))","decl":"theorem smul_def (g : ConjAct G) (h : G) : g • h = ofConjAct g * h * (ofConjAct g)⁻¹ :=\n  rfl\n\n"}
{"name":"ConjAct.toConjAct_smul","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\ng h : G\n⊢ Eq (HSMul.hSMul (ConjAct.toConjAct g) h) (HMul.hMul (HMul.hMul g h) (Inv.inv g))","decl":"theorem toConjAct_smul (g h : G) : toConjAct g • h = g * h * g⁻¹ :=\n  rfl\n\n"}
{"name":"ConjAct.units_smul_def","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"M : Type u_2\ninst✝ : Monoid M\ng : ConjAct (Units M)\nh : M\n⊢ Eq (HSMul.hSMul g h) (HMul.hMul (HMul.hMul (↑(ConjAct.ofConjAct g)) h) ↑(Inv.inv (ConjAct.ofConjAct g)))","decl":"theorem units_smul_def (g : ConjAct Mˣ) (h : M) : g • h = ofConjAct g * h * ↑(ofConjAct g)⁻¹ :=\n  rfl\n\n"}
{"name":"ConjAct.unitsSMulCommClass","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝³ : Monoid M\ninst✝² : SMul α M\ninst✝¹ : SMulCommClass α M M\ninst✝ : IsScalarTower α M M\n⊢ SMulCommClass α (ConjAct (Units M)) M","decl":"instance unitsSMulCommClass [SMul α M] [SMulCommClass α M M] [IsScalarTower α M M] :\n    SMulCommClass α (ConjAct Mˣ) M where\n  smul_comm a um m := by rw [units_smul_def, units_smul_def, mul_smul_comm, smul_mul_assoc]\n\n"}
{"name":"ConjAct.unitsSMulCommClass'","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝³ : Monoid M\ninst✝² : SMul α M\ninst✝¹ : SMulCommClass M α M\ninst✝ : IsScalarTower α M M\n⊢ SMulCommClass (ConjAct (Units M)) α M","decl":"instance unitsSMulCommClass' [SMul α M] [SMulCommClass M α M] [IsScalarTower α M M] :\n    SMulCommClass (ConjAct Mˣ) α M :=\n  haveI : SMulCommClass α M M := SMulCommClass.symm _ _ _\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"ConjAct.smulCommClass","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"α : Type u_1\nG : Type u_3\ninst✝³ : Group G\ninst✝² : SMul α G\ninst✝¹ : SMulCommClass α G G\ninst✝ : IsScalarTower α G G\n⊢ SMulCommClass α (ConjAct G) G","decl":"instance smulCommClass [SMul α G] [SMulCommClass α G G] [IsScalarTower α G G] :\n    SMulCommClass α (ConjAct G) G where\n  smul_comm a ug g := by rw [smul_def, smul_def, mul_smul_comm, smul_mul_assoc]\n\n"}
{"name":"ConjAct.smulCommClass'","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"α : Type u_1\nG : Type u_3\ninst✝³ : Group G\ninst✝² : SMul α G\ninst✝¹ : SMulCommClass G α G\ninst✝ : IsScalarTower α G G\n⊢ SMulCommClass (ConjAct G) α G","decl":"instance smulCommClass' [SMul α G] [SMulCommClass G α G] [IsScalarTower α G G] :\n    SMulCommClass (ConjAct G) α G :=\n  haveI := SMulCommClass.symm G α G\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"ConjAct.smul_eq_mulAut_conj","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : Group G\ng : ConjAct G\nh : G\n⊢ Eq (HSMul.hSMul g h) ((MulAut.conj (ConjAct.ofConjAct g)) h)","decl":"theorem smul_eq_mulAut_conj (g : ConjAct G) (h : G) : g • h = MulAut.conj (ofConjAct g) h :=\n  rfl\n\n"}
{"name":"ConjAct.fixedPoints_eq_center","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : Group G\n⊢ Eq (MulAction.fixedPoints (ConjAct G) G) ↑(Subgroup.center G)","decl":"/-- The set of fixed points of the conjugation action of `G` on itself is the center of `G`. -/\ntheorem fixedPoints_eq_center : fixedPoints (ConjAct G) G = center G := by\n  ext x\n  simp [mem_center_iff, smul_def, mul_inv_eq_iff_eq_mul]\n\n"}
{"name":"ConjAct.mem_orbit_conjAct","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : Group G\ng h : G\n⊢ Iff (Membership.mem (MulAction.orbit (ConjAct G) h) g) (IsConj g h)","decl":"@[simp]\ntheorem mem_orbit_conjAct {g h : G} : g ∈ orbit (ConjAct G) h ↔ IsConj g h := by\n  rw [isConj_comm, isConj_iff, mem_orbit_iff]; rfl\n\n"}
{"name":"ConjAct.orbitRel_conjAct","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : Group G\n⊢ Eq (⇑(MulAction.orbitRel (ConjAct G) G)) IsConj","decl":"theorem orbitRel_conjAct : ⇑(orbitRel (ConjAct G) G) = IsConj :=\n  funext₂ fun g h => by rw [orbitRel_apply, mem_orbit_conjAct]\n\n"}
{"name":"ConjAct.orbit_eq_carrier_conjClasses","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : Group G\ng : G\n⊢ Eq (MulAction.orbit (ConjAct G) g) (ConjClasses.mk g).carrier","decl":"theorem orbit_eq_carrier_conjClasses (g : G) :\n    orbit (ConjAct G) g = (ConjClasses.mk g).carrier := by\n  ext h\n  rw [ConjClasses.mem_carrier_iff_mk_eq, ConjClasses.mk_eq_mk_iff_isConj, mem_orbit_conjAct]\n\n"}
{"name":"ConjAct.stabilizer_eq_centralizer","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : Group G\ng : G\n⊢ Eq (MulAction.stabilizer (ConjAct G) g) (Subgroup.centralizer ↑(Subgroup.zpowers (ConjAct.toConjAct g)))","decl":"theorem stabilizer_eq_centralizer (g : G) :\n    stabilizer (ConjAct G) g = centralizer (zpowers (toConjAct g) : Set (ConjAct G)) :=\n  le_antisymm (le_centralizer_iff.mp (zpowers_le.mpr fun _ => mul_inv_eq_iff_eq_mul.mp)) fun _ h =>\n    mul_inv_eq_of_eq_mul (h g (mem_zpowers g)).symm\n\n"}
{"name":"Subgroup.centralizer_eq_comap_stabilizer","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : Group G\ng : G\n⊢ Eq (Subgroup.centralizer (Singleton.singleton g)) (Subgroup.comap ConjAct.toConjAct.toMonoidHom (MulAction.stabilizer (ConjAct G) g))","decl":"theorem _root_.Subgroup.centralizer_eq_comap_stabilizer (g : G) :\n    Subgroup.centralizer {g} = Subgroup.comap ConjAct.toConjAct.toMonoidHom\n      (MulAction.stabilizer (ConjAct G) g) := by\n  ext k\n-- NOTE: `Subgroup.mem_centralizer_iff` should probably be stated\n-- with the equality in the other direction\n  simp only [mem_centralizer_iff, Set.mem_singleton_iff, forall_eq, ConjAct.toConjAct_smul]\n  rw [eq_comm]\n  exact Iff.symm mul_inv_eq_iff_eq_mul\n\n"}
{"name":"ConjAct.Subgroup.val_conj_smul","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.Normal\ng : ConjAct G\nh : Subtype fun x => Membership.mem H x\n⊢ Eq (↑(HSMul.hSMul g h)) (HSMul.hSMul g ↑h)","decl":"theorem Subgroup.val_conj_smul {H : Subgroup G} [H.Normal] (g : ConjAct G) (h : H) :\n    ↑(g • h) = g • (h : G) :=\n  rfl\n\n"}
{"name":"MulAut.conjNormal_apply","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.Normal\ng : G\nh : Subtype fun x => Membership.mem H x\n⊢ Eq (↑((MulAut.conjNormal g) h)) (HMul.hMul (HMul.hMul g ↑h) (Inv.inv g))","decl":"@[simp]\ntheorem _root_.MulAut.conjNormal_apply {H : Subgroup G} [H.Normal] (g : G) (h : H) :\n    ↑(MulAut.conjNormal g h) = g * h * g⁻¹ :=\n  rfl\n\n"}
{"name":"MulAut.conjNormal_symm_apply","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.Normal\ng : G\nh : Subtype fun x => Membership.mem H x\n⊢ Eq (↑((MulEquiv.symm (MulAut.conjNormal g)) h)) (HMul.hMul (HMul.hMul (Inv.inv g) ↑h) g)","decl":"@[simp]\ntheorem _root_.MulAut.conjNormal_symm_apply {H : Subgroup G} [H.Normal] (g : G) (h : H) :\n    ↑((MulAut.conjNormal g).symm h) = g⁻¹ * h * g := by\n  change _ * _⁻¹⁻¹ = _\n  rw [inv_inv]\n  rfl\n\n"}
{"name":"MulAut.conjNormal_inv_apply","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.Normal\ng : G\nh : Subtype fun x => Membership.mem H x\n⊢ Eq (↑((Inv.inv (MulAut.conjNormal g)) h)) (HMul.hMul (HMul.hMul (Inv.inv g) ↑h) g)","decl":"@[simp]\ntheorem _root_.MulAut.conjNormal_inv_apply {H : Subgroup G} [H.Normal] (g : G) (h : H) :\n    ↑((MulAut.conjNormal g)⁻¹ h) = g⁻¹ * h * g :=\n  MulAut.conjNormal_symm_apply g h\n\n"}
{"name":"MulAut.conjNormal_val","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.Normal\nh : Subtype fun x => Membership.mem H x\n⊢ Eq (MulAut.conjNormal ↑h) (MulAut.conj h)","decl":"theorem _root_.MulAut.conjNormal_val {H : Subgroup G} [H.Normal] {h : H} :\n    MulAut.conjNormal ↑h = MulAut.conj h :=\n  MulEquiv.ext fun _ => rfl\n\n"}
{"name":"ConjAct.normal_of_characteristic_of_normal","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"G : Type u_3\ninst✝ : Group G\nH : Subgroup G\nhH : H.Normal\nK : Subgroup (Subtype fun x => Membership.mem H x)\nh : K.Characteristic\n⊢ (Subgroup.map H.subtype K).Normal","decl":"instance normal_of_characteristic_of_normal {H : Subgroup G} [hH : H.Normal] {K : Subgroup H}\n    [h : K.Characteristic] : (K.map H.subtype).Normal :=\n  ⟨fun a ha b => by\n    obtain ⟨a, ha, rfl⟩ := ha\n    exact K.apply_coe_mem_map H.subtype\n      ⟨_, (SetLike.ext_iff.mp (h.fixed (MulAut.conjNormal b)) a).mpr ha⟩⟩\n\n"}
{"name":"val_unitsCentralizerEquiv_apply_coe","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"M : Type u_2\ninst✝ : Monoid M\nx : Units M\na✝ : Units (Subtype fun x_1 => Membership.mem (Submonoid.centralizer (Singleton.singleton ↑x)) x_1)\n⊢ Eq ↑↑((unitsCentralizerEquiv M x) a✝) ↑↑a✝","decl":"/-- The stabilizer of `Mˣ` acting on itself by conjugation at `x : Mˣ` is exactly the\nunits of the centralizer of `x : M`. -/\n@[simps! apply_coe_val symm_apply_val_coe]\ndef unitsCentralizerEquiv (x : Mˣ) :\n    (Submonoid.centralizer ({↑x} : Set M))ˣ ≃* MulAction.stabilizer (ConjAct Mˣ) x :=\n  MulEquiv.symm\n  { toFun := MonoidHom.toHomUnits <|\n      { toFun := fun u ↦ ⟨↑(ConjAct.ofConjAct u.1 : Mˣ), by\n          rintro x ⟨rfl⟩\n          have : (u : ConjAct Mˣ) • x = x := u.2\n          rwa [ConjAct.smul_def, mul_inv_eq_iff_eq_mul, Units.ext_iff, eq_comm] at this⟩,\n        map_one' := rfl,\n        map_mul' := fun _ _ ↦ rfl }\n    invFun := fun u ↦\n      ⟨ConjAct.toConjAct (Units.map (Submonoid.centralizer ({↑x} : Set M)).subtype u), by\n      change _ • _ = _\n      simp only [ConjAct.smul_def, ConjAct.ofConjAct_toConjAct, mul_inv_eq_iff_eq_mul]\n      exact Units.ext <| (u.1.2 x <| Set.mem_singleton _).symm⟩\n    left_inv := fun _ ↦ by ext; rfl\n    right_inv := fun _ ↦ by ext; rfl\n    map_mul' := map_mul _ }\n\n"}
{"name":"val_unitsCentralizerEquiv_symm_apply_coe","module":"Mathlib.GroupTheory.GroupAction.ConjAct","initialProofState":"M : Type u_2\ninst✝ : Monoid M\nx : Units M\na✝ : Subtype fun x_1 => Membership.mem (MulAction.stabilizer (ConjAct (Units M)) x) x_1\n⊢ Eq ↑↑((unitsCentralizerEquiv M x).symm a✝) ↑(ConjAct.ofConjAct ↑a✝)","decl":"/-- The stabilizer of `Mˣ` acting on itself by conjugation at `x : Mˣ` is exactly the\nunits of the centralizer of `x : M`. -/\n@[simps! apply_coe_val symm_apply_val_coe]\ndef unitsCentralizerEquiv (x : Mˣ) :\n    (Submonoid.centralizer ({↑x} : Set M))ˣ ≃* MulAction.stabilizer (ConjAct Mˣ) x :=\n  MulEquiv.symm\n  { toFun := MonoidHom.toHomUnits <|\n      { toFun := fun u ↦ ⟨↑(ConjAct.ofConjAct u.1 : Mˣ), by\n          rintro x ⟨rfl⟩\n          have : (u : ConjAct Mˣ) • x = x := u.2\n          rwa [ConjAct.smul_def, mul_inv_eq_iff_eq_mul, Units.ext_iff, eq_comm] at this⟩,\n        map_one' := rfl,\n        map_mul' := fun _ _ ↦ rfl }\n    invFun := fun u ↦\n      ⟨ConjAct.toConjAct (Units.map (Submonoid.centralizer ({↑x} : Set M)).subtype u), by\n      change _ • _ = _\n      simp only [ConjAct.smul_def, ConjAct.ofConjAct_toConjAct, mul_inv_eq_iff_eq_mul]\n      exact Units.ext <| (u.1.2 x <| Set.mem_singleton _).symm⟩\n    left_inv := fun _ ↦ by ext; rfl\n    right_inv := fun _ ↦ by ext; rfl\n    map_mul' := map_mul _ }\n\n"}
