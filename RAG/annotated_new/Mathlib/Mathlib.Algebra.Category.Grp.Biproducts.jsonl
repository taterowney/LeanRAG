{"name":"AddCommGrp.instHasBinaryBiproducts","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"⊢ CategoryTheory.Limits.HasBinaryBiproducts AddCommGrp","decl":"instance : HasBinaryBiproducts AddCommGrp :=\n  HasBinaryBiproducts.of_hasBinaryProducts\n\n"}
{"name":"AddCommGrp.instHasFiniteBiproducts","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"⊢ CategoryTheory.Limits.HasFiniteBiproducts AddCommGrp","decl":"instance : HasFiniteBiproducts AddCommGrp :=\n  HasFiniteBiproducts.of_hasFiniteProducts\n\n-- We now construct explicit limit data,\n-- so we can compare the biproducts to the usual unbundled constructions.\n"}
{"name":"AddCommGrp.binaryProductLimitCone_isLimit_lift","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"G H : AddCommGrp\ns : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair G H)\n⊢ Eq ((G.binaryProductLimitCone H).isLimit.lift s) (AddCommGrp.ofHom ((AddCommGrp.Hom.hom (s.π.app { as := CategoryTheory.Limits.WalkingPair.left })).prod (AddCommGrp.Hom.hom (s.π.app { as := CategoryTheory.Limits.WalkingPair.right }))))","decl":"/-- Construct limit data for a binary product in `AddCommGrp`, using\n`AddCommGrp.of (G × H)`.\n-/\n@[simps cone_pt isLimit_lift]\ndef binaryProductLimitCone (G H : AddCommGrp.{u}) : Limits.LimitCone (pair G H) where\n  cone :=\n    { pt := AddCommGrp.of (G × H)\n      π :=\n        { app := fun j =>\n            Discrete.casesOn j fun j =>\n              WalkingPair.casesOn j (ofHom (AddMonoidHom.fst G H)) (ofHom (AddMonoidHom.snd G H))\n          naturality := by rintro ⟨⟨⟩⟩ ⟨⟨⟩⟩ ⟨⟨⟨⟩⟩⟩ <;> rfl } }\n  isLimit :=\n    { lift := fun s => ofHom <|\n        AddMonoidHom.prod (s.π.app ⟨WalkingPair.left⟩).hom (s.π.app ⟨WalkingPair.right⟩).hom\n      fac := by rintro s (⟨⟩ | ⟨⟩) <;> rfl\n      uniq := fun s m w => by\n        simp_rw [← w ⟨WalkingPair.left⟩, ← w ⟨WalkingPair.right⟩]\n        rfl }\n\n"}
{"name":"AddCommGrp.binaryProductLimitCone_cone_pt","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"G H : AddCommGrp\n⊢ Eq (G.binaryProductLimitCone H).cone.pt (AddCommGrp.of (Prod ↑G ↑H))","decl":"/-- Construct limit data for a binary product in `AddCommGrp`, using\n`AddCommGrp.of (G × H)`.\n-/\n@[simps cone_pt isLimit_lift]\ndef binaryProductLimitCone (G H : AddCommGrp.{u}) : Limits.LimitCone (pair G H) where\n  cone :=\n    { pt := AddCommGrp.of (G × H)\n      π :=\n        { app := fun j =>\n            Discrete.casesOn j fun j =>\n              WalkingPair.casesOn j (ofHom (AddMonoidHom.fst G H)) (ofHom (AddMonoidHom.snd G H))\n          naturality := by rintro ⟨⟨⟩⟩ ⟨⟨⟩⟩ ⟨⟨⟨⟩⟩⟩ <;> rfl } }\n  isLimit :=\n    { lift := fun s => ofHom <|\n        AddMonoidHom.prod (s.π.app ⟨WalkingPair.left⟩).hom (s.π.app ⟨WalkingPair.right⟩).hom\n      fac := by rintro s (⟨⟩ | ⟨⟩) <;> rfl\n      uniq := fun s m w => by\n        simp_rw [← w ⟨WalkingPair.left⟩, ← w ⟨WalkingPair.right⟩]\n        rfl }\n\n"}
{"name":"AddCommGrp.binaryProductLimitCone_cone_π_app_left","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"G H : AddCommGrp\n⊢ Eq ((G.binaryProductLimitCone H).cone.π.app { as := CategoryTheory.Limits.WalkingPair.left }) (AddCommGrp.ofHom (AddMonoidHom.fst ↑G ↑H))","decl":"@[simp]\ntheorem binaryProductLimitCone_cone_π_app_left (G H : AddCommGrp.{u}) :\n    (binaryProductLimitCone G H).cone.π.app ⟨WalkingPair.left⟩ = ofHom (AddMonoidHom.fst G H) :=\n  rfl\n\n"}
{"name":"AddCommGrp.binaryProductLimitCone_cone_π_app_right","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"G H : AddCommGrp\n⊢ Eq ((G.binaryProductLimitCone H).cone.π.app { as := CategoryTheory.Limits.WalkingPair.right }) (AddCommGrp.ofHom (AddMonoidHom.snd ↑G ↑H))","decl":"@[simp]\ntheorem binaryProductLimitCone_cone_π_app_right (G H : AddCommGrp.{u}) :\n    (binaryProductLimitCone G H).cone.π.app ⟨WalkingPair.right⟩ = ofHom (AddMonoidHom.snd G H) :=\n  rfl\n\n"}
{"name":"AddCommGrp.biprodIsoProd_inv_comp_fst","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"G H : AddCommGrp\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.biprodIsoProd H).inv CategoryTheory.Limits.biprod.fst) (AddCommGrp.ofHom (AddMonoidHom.fst ↑G ↑H))","decl":"@[simp, elementwise]\ntheorem biprodIsoProd_inv_comp_fst (G H : AddCommGrp.{u}) :\n    (biprodIsoProd G H).inv ≫ biprod.fst = ofHom (AddMonoidHom.fst G H) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ (Discrete.mk WalkingPair.left)\n\n"}
{"name":"AddCommGrp.biprodIsoProd_inv_comp_fst_apply","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"G H : AddCommGrp\nx : CategoryTheory.ToType (AddCommGrp.of (Prod ↑G ↑H))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom CategoryTheory.Limits.biprod.fst) ((CategoryTheory.ConcreteCategory.hom (G.biprodIsoProd H).inv) x)) x.1","decl":"@[simp, elementwise]\ntheorem biprodIsoProd_inv_comp_fst (G H : AddCommGrp.{u}) :\n    (biprodIsoProd G H).inv ≫ biprod.fst = ofHom (AddMonoidHom.fst G H) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ (Discrete.mk WalkingPair.left)\n\n"}
{"name":"AddCommGrp.biprodIsoProd_inv_comp_snd","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"G H : AddCommGrp\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.biprodIsoProd H).inv CategoryTheory.Limits.biprod.snd) (AddCommGrp.ofHom (AddMonoidHom.snd ↑G ↑H))","decl":"@[simp, elementwise]\ntheorem biprodIsoProd_inv_comp_snd (G H : AddCommGrp.{u}) :\n    (biprodIsoProd G H).inv ≫ biprod.snd = ofHom (AddMonoidHom.snd G H) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ (Discrete.mk WalkingPair.right)\n\n"}
{"name":"AddCommGrp.biprodIsoProd_inv_comp_snd_apply","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"G H : AddCommGrp\nx : CategoryTheory.ToType (AddCommGrp.of (Prod ↑G ↑H))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom CategoryTheory.Limits.biprod.snd) ((CategoryTheory.ConcreteCategory.hom (G.biprodIsoProd H).inv) x)) x.2","decl":"@[simp, elementwise]\ntheorem biprodIsoProd_inv_comp_snd (G H : AddCommGrp.{u}) :\n    (biprodIsoProd G H).inv ≫ biprod.snd = ofHom (AddMonoidHom.snd G H) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ (Discrete.mk WalkingPair.right)\n\n"}
{"name":"AddCommGrp.HasLimit.lift_hom_apply","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"J : Type w\nf : J → AddCommGrp\ns : CategoryTheory.Limits.Fan f\nx : ↑s.1\nj : J\n⊢ Eq ((AddCommGrp.Hom.hom (AddCommGrp.HasLimit.lift f s)) x j) ((CategoryTheory.ConcreteCategory.hom (s.π.app { as := j })) x)","decl":"/-- The map from an arbitrary cone over an indexed family of abelian groups\nto the cartesian product of those groups.\n-/\n@[simps!]\ndef lift (s : Fan f) : s.pt ⟶ AddCommGrp.of (∀ j, f j) :=\n  ofHom\n  { toFun x j := s.π.app ⟨j⟩ x\n    map_zero' := by\n      simp only [Functor.const_obj_obj, map_zero]\n      rfl\n    map_add' x y := by\n      simp only [Functor.const_obj_obj, map_add]\n      rfl }\n\n"}
{"name":"AddCommGrp.HasLimit.productLimitCone_cone_pt_coe","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"J : Type w\nf : J → AddCommGrp\n⊢ Eq (↑(AddCommGrp.HasLimit.productLimitCone f).cone.pt) ((j : J) → ↑(f j))","decl":"/-- Construct limit data for a product in `AddCommGrp`, using\n`AddCommGrp.of (∀ j, F.obj j)`.\n-/\n@[simps]\ndef productLimitCone : Limits.LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := AddCommGrp.of (∀ j, f j)\n      π := Discrete.natTrans fun j => ofHom <| Pi.evalAddMonoidHom (fun j => f j) j.as }\n  isLimit :=\n    { lift := lift.{_, u} f\n      fac := fun _ _ => rfl\n      uniq := fun s m w => by\n        ext x j\n        exact CategoryTheory.congr_fun (w ⟨j⟩) x }\n\n"}
{"name":"AddCommGrp.HasLimit.productLimitCone_cone_π","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"J : Type w\nf : J → AddCommGrp\n⊢ Eq (AddCommGrp.HasLimit.productLimitCone f).cone.π (CategoryTheory.Discrete.natTrans fun j => AddCommGrp.ofHom (Pi.evalAddMonoidHom (fun j => ↑(f j)) j.as))","decl":"/-- Construct limit data for a product in `AddCommGrp`, using\n`AddCommGrp.of (∀ j, F.obj j)`.\n-/\n@[simps]\ndef productLimitCone : Limits.LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := AddCommGrp.of (∀ j, f j)\n      π := Discrete.natTrans fun j => ofHom <| Pi.evalAddMonoidHom (fun j => f j) j.as }\n  isLimit :=\n    { lift := lift.{_, u} f\n      fac := fun _ _ => rfl\n      uniq := fun s m w => by\n        ext x j\n        exact CategoryTheory.congr_fun (w ⟨j⟩) x }\n\n"}
{"name":"AddCommGrp.HasLimit.productLimitCone_isLimit_lift","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"J : Type w\nf : J → AddCommGrp\ns : CategoryTheory.Limits.Fan f\n⊢ Eq ((AddCommGrp.HasLimit.productLimitCone f).isLimit.lift s) (AddCommGrp.HasLimit.lift f s)","decl":"/-- Construct limit data for a product in `AddCommGrp`, using\n`AddCommGrp.of (∀ j, F.obj j)`.\n-/\n@[simps]\ndef productLimitCone : Limits.LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := AddCommGrp.of (∀ j, f j)\n      π := Discrete.natTrans fun j => ofHom <| Pi.evalAddMonoidHom (fun j => f j) j.as }\n  isLimit :=\n    { lift := lift.{_, u} f\n      fac := fun _ _ => rfl\n      uniq := fun s m w => by\n        ext x j\n        exact CategoryTheory.congr_fun (w ⟨j⟩) x }\n\n"}
{"name":"AddCommGrp.biproductIsoPi_inv_comp_π_apply","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"J : Type\ninst✝ : Finite J\nf : J → AddCommGrp\nj : J\nx : CategoryTheory.ToType (AddCommGrp.of ((j : J) → ↑(f j)))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Limits.biproduct.π f j)) ((CategoryTheory.ConcreteCategory.hom (AddCommGrp.biproductIsoPi f).inv) x)) (x j)","decl":"@[simp, elementwise]\ntheorem biproductIsoPi_inv_comp_π (f : J → AddCommGrp.{u}) (j : J) :\n    (biproductIsoPi f).inv ≫ biproduct.π f j = ofHom (Pi.evalAddMonoidHom (fun j => f j) j) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ (Discrete.mk j)\n\n"}
{"name":"AddCommGrp.biproductIsoPi_inv_comp_π","module":"Mathlib.Algebra.Category.Grp.Biproducts","initialProofState":"J : Type\ninst✝ : Finite J\nf : J → AddCommGrp\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AddCommGrp.biproductIsoPi f).inv (CategoryTheory.Limits.biproduct.π f j)) (AddCommGrp.ofHom (Pi.evalAddMonoidHom (fun j => ↑(f j)) j))","decl":"@[simp, elementwise]\ntheorem biproductIsoPi_inv_comp_π (f : J → AddCommGrp.{u}) (j : J) :\n    (biproductIsoPi f).inv ≫ biproduct.π f j = ofHom (Pi.evalAddMonoidHom (fun j => f j) j) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ (Discrete.mk j)\n\n"}
