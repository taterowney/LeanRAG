{"name":"Multiset.coe_ndinsert","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ Eq (Multiset.ndinsert a ↑l) ↑(Insert.insert a l)","decl":"@[simp]\ntheorem coe_ndinsert (a : α) (l : List α) : ndinsert a l = (insert a l : List α) :=\n  rfl\n\n"}
{"name":"Multiset.ndinsert_zero","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Multiset.ndinsert a 0) (Singleton.singleton a)","decl":"@[simp]\ntheorem ndinsert_zero (a : α) : ndinsert a 0 = {a} :=\n  rfl\n\n"}
{"name":"Multiset.ndinsert_of_mem","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\na✝ : Membership.mem s a\n⊢ Eq (Multiset.ndinsert a s) s","decl":"@[simp]\ntheorem ndinsert_of_mem {a : α} {s : Multiset α} : a ∈ s → ndinsert a s = s :=\n  Quot.inductionOn s fun _ h => congr_arg ((↑) : List α → Multiset α) <| insert_of_mem h\n\n"}
{"name":"Multiset.ndinsert_of_not_mem","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\na✝ : Not (Membership.mem s a)\n⊢ Eq (Multiset.ndinsert a s) (Multiset.cons a s)","decl":"@[simp]\ntheorem ndinsert_of_not_mem {a : α} {s : Multiset α} : a ∉ s → ndinsert a s = a ::ₘ s :=\n  Quot.inductionOn s fun _ h => congr_arg ((↑) : List α → Multiset α) <| insert_of_not_mem h\n\n"}
{"name":"Multiset.mem_ndinsert","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Multiset α\n⊢ Iff (Membership.mem (Multiset.ndinsert b s) a) (Or (Eq a b) (Membership.mem s a))","decl":"@[simp]\ntheorem mem_ndinsert {a b : α} {s : Multiset α} : a ∈ ndinsert b s ↔ a = b ∨ a ∈ s :=\n  Quot.inductionOn s fun _ => mem_insert_iff\n\n"}
{"name":"Multiset.le_ndinsert_self","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ LE.le s (Multiset.ndinsert a s)","decl":"@[simp]\ntheorem le_ndinsert_self (a : α) (s : Multiset α) : s ≤ ndinsert a s :=\n  Quot.inductionOn s fun _ => (sublist_insert _ _).subperm\n\n"}
{"name":"Multiset.mem_ndinsert_self","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Membership.mem (Multiset.ndinsert a s) a","decl":"theorem mem_ndinsert_self (a : α) (s : Multiset α) : a ∈ ndinsert a s := by simp\n\n"}
{"name":"Multiset.mem_ndinsert_of_mem","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Multiset α\nh : Membership.mem s a\n⊢ Membership.mem (Multiset.ndinsert b s) a","decl":"theorem mem_ndinsert_of_mem {a b : α} {s : Multiset α} (h : a ∈ s) : a ∈ ndinsert b s :=\n  mem_ndinsert.2 (Or.inr h)\n\n"}
{"name":"Multiset.length_ndinsert_of_mem","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\nh : Membership.mem s a\n⊢ Eq (Multiset.ndinsert a s).card s.card","decl":"@[simp]\ntheorem length_ndinsert_of_mem {a : α} {s : Multiset α} (h : a ∈ s) :\n    card (ndinsert a s) = card s := by simp [h]\n\n"}
{"name":"Multiset.length_ndinsert_of_not_mem","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\nh : Not (Membership.mem s a)\n⊢ Eq (Multiset.ndinsert a s).card (HAdd.hAdd s.card 1)","decl":"@[simp]\ntheorem length_ndinsert_of_not_mem {a : α} {s : Multiset α} (h : a ∉ s) :\n    card (ndinsert a s) = card s + 1 := by simp [h]\n\n"}
{"name":"Multiset.dedup_cons","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Eq (Multiset.cons a s).dedup (Multiset.ndinsert a s.dedup)","decl":"theorem dedup_cons {a : α} {s : Multiset α} : dedup (a ::ₘ s) = ndinsert a (dedup s) := by\n  by_cases h : a ∈ s <;> simp [h]\n\n"}
{"name":"Multiset.Nodup.ndinsert","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\na : α\na✝ : s.Nodup\n⊢ (Multiset.ndinsert a s).Nodup","decl":"theorem Nodup.ndinsert (a : α) : Nodup s → Nodup (ndinsert a s) :=\n  Quot.inductionOn s fun _ => Nodup.insert\n\n"}
{"name":"Multiset.ndinsert_le","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\n⊢ Iff (LE.le (Multiset.ndinsert a s) t) (And (LE.le s t) (Membership.mem t a))","decl":"theorem ndinsert_le {a : α} {s t : Multiset α} : ndinsert a s ≤ t ↔ s ≤ t ∧ a ∈ t :=\n  ⟨fun h => ⟨le_trans (le_ndinsert_self _ _) h, mem_of_le h (mem_ndinsert_self _ _)⟩, fun ⟨l, m⟩ =>\n    if h : a ∈ s then by simp [h, l]\n    else by\n      rw [ndinsert_of_not_mem h, ← cons_erase m, cons_le_cons_iff, ← le_cons_of_not_mem h,\n          cons_erase m]\n      exact l⟩\n\n"}
{"name":"Multiset.attach_ndinsert","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Eq (Multiset.ndinsert a s).attach (Multiset.ndinsert ⟨a, ⋯⟩ (Multiset.map (fun p => ⟨↑p, ⋯⟩) s.attach))","decl":"theorem attach_ndinsert (a : α) (s : Multiset α) :\n    (s.ndinsert a).attach =\n      ndinsert ⟨a, mem_ndinsert_self a s⟩ (s.attach.map fun p => ⟨p.1, mem_ndinsert_of_mem p.2⟩) :=\n  have eq :\n    ∀ h : ∀ p : { x // x ∈ s }, p.1 ∈ s,\n      (fun p : { x // x ∈ s } => ⟨p.val, h p⟩ : { x // x ∈ s } → { x // x ∈ s }) = id :=\n    fun _ => funext fun _ => Subtype.eq rfl\n  have : ∀ (t) (eq : s.ndinsert a = t), t.attach = ndinsert ⟨a, eq ▸ mem_ndinsert_self a s⟩\n      (s.attach.map fun p => ⟨p.1, eq ▸ mem_ndinsert_of_mem p.2⟩) := by\n    intro t ht\n    by_cases h : a ∈ s\n    · rw [ndinsert_of_mem h] at ht\n      subst ht\n      rw [eq, map_id, ndinsert_of_mem (mem_attach _ _)]\n    · rw [ndinsert_of_not_mem h] at ht\n      subst ht\n      simp [attach_cons, h]\n  this _ rfl\n\n"}
{"name":"Multiset.disjoint_ndinsert_left","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\n⊢ Iff (Disjoint (Multiset.ndinsert a s) t) (And (Not (Membership.mem t a)) (Disjoint s t))","decl":"@[simp]\ntheorem disjoint_ndinsert_left {a : α} {s t : Multiset α} :\n    Disjoint (ndinsert a s) t ↔ a ∉ t ∧ Disjoint s t :=\n  Iff.trans (by simp [disjoint_left]) disjoint_cons_left\n\n"}
{"name":"Multiset.disjoint_ndinsert_right","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\n⊢ Iff (Disjoint s (Multiset.ndinsert a t)) (And (Not (Membership.mem s a)) (Disjoint s t))","decl":"@[simp]\ntheorem disjoint_ndinsert_right {a : α} {s t : Multiset α} :\n    Disjoint s (ndinsert a t) ↔ a ∉ s ∧ Disjoint s t := by\n  rw [_root_.disjoint_comm, disjoint_ndinsert_left]; tauto\n\n"}
{"name":"Multiset.coe_ndunion","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ : List α\n⊢ Eq ((↑l₁).ndunion ↑l₂) ↑(Union.union l₁ l₂)","decl":"@[simp]\ntheorem coe_ndunion (l₁ l₂ : List α) : @ndunion α _ l₁ l₂ = (l₁ ∪ l₂ : List α) :=\n  rfl\n\n-- Porting note: removed @[simp], original porting note incorrectly claimed that simp can prove it\n"}
{"name":"Multiset.zero_ndunion","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq (Multiset.ndunion 0 s) s","decl":"theorem zero_ndunion (s : Multiset α) : ndunion 0 s = s :=\n  Quot.inductionOn s fun _ => rfl\n\n"}
{"name":"Multiset.cons_ndunion","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\na : α\n⊢ Eq ((Multiset.cons a s).ndunion t) (Multiset.ndinsert a (s.ndunion t))","decl":"@[simp]\ntheorem cons_ndunion (s t : Multiset α) (a : α) : ndunion (a ::ₘ s) t = ndinsert a (ndunion s t) :=\n  Quot.induction_on₂ s t fun _ _ => rfl\n\n"}
{"name":"Multiset.mem_ndunion","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\na : α\n⊢ Iff (Membership.mem (s.ndunion t) a) (Or (Membership.mem s a) (Membership.mem t a))","decl":"@[simp]\ntheorem mem_ndunion {s t : Multiset α} {a : α} : a ∈ ndunion s t ↔ a ∈ s ∨ a ∈ t :=\n  Quot.induction_on₂ s t fun _ _ => List.mem_union_iff\n\n"}
{"name":"Multiset.le_ndunion_right","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ LE.le t (s.ndunion t)","decl":"theorem le_ndunion_right (s t : Multiset α) : t ≤ ndunion s t :=\n  Quot.induction_on₂ s t fun _ _ => (suffix_union_right _ _).sublist.subperm\n\n"}
{"name":"Multiset.subset_ndunion_right","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ HasSubset.Subset t (s.ndunion t)","decl":"theorem subset_ndunion_right (s t : Multiset α) : t ⊆ ndunion s t :=\n  subset_of_le (le_ndunion_right s t)\n\n"}
{"name":"Multiset.ndunion_le_add","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ LE.le (s.ndunion t) (HAdd.hAdd s t)","decl":"theorem ndunion_le_add (s t : Multiset α) : ndunion s t ≤ s + t :=\n  Quot.induction_on₂ s t fun _ _ => (union_sublist_append _ _).subperm\n\n"}
{"name":"Multiset.ndunion_le","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\n⊢ Iff (LE.le (s.ndunion t) u) (And (HasSubset.Subset s u) (LE.le t u))","decl":"theorem ndunion_le {s t u : Multiset α} : ndunion s t ≤ u ↔ s ⊆ u ∧ t ≤ u :=\n  Multiset.induction_on s (by simp [zero_ndunion])\n    (fun _ _ h =>\n      by simp only [cons_ndunion, mem_ndunion, ndinsert_le, and_comm, cons_subset, and_left_comm, h,\n        and_assoc])\n\n"}
{"name":"Multiset.subset_ndunion_left","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ HasSubset.Subset s (s.ndunion t)","decl":"theorem subset_ndunion_left (s t : Multiset α) : s ⊆ ndunion s t := fun _ h =>\n  mem_ndunion.2 <| Or.inl h\n\n"}
{"name":"Multiset.le_ndunion_left","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nd : s.Nodup\n⊢ LE.le s (s.ndunion t)","decl":"theorem le_ndunion_left {s} (t : Multiset α) (d : Nodup s) : s ≤ ndunion s t :=\n  (le_iff_subset d).2 <| subset_ndunion_left _ _\n\n"}
{"name":"Multiset.ndunion_le_union","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ LE.le (s.ndunion t) (Union.union s t)","decl":"theorem ndunion_le_union (s t : Multiset α) : ndunion s t ≤ s ∪ t :=\n  ndunion_le.2 ⟨subset_of_le le_union_left, le_union_right⟩\n\n"}
{"name":"Multiset.Nodup.ndunion","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\na✝ : t.Nodup\n⊢ (s.ndunion t).Nodup","decl":"theorem Nodup.ndunion (s : Multiset α) {t : Multiset α} : Nodup t → Nodup (ndunion s t) :=\n  Quot.induction_on₂ s t fun _ _ => List.Nodup.union _\n\n"}
{"name":"Multiset.ndunion_eq_union","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nd : s.Nodup\n⊢ Eq (s.ndunion t) (Union.union s t)","decl":"@[simp]\ntheorem ndunion_eq_union {s t : Multiset α} (d : Nodup s) : ndunion s t = s ∪ t :=\n  le_antisymm (ndunion_le_union _ _) <| union_le (le_ndunion_left _ d) (le_ndunion_right _ _)\n\n"}
{"name":"Multiset.dedup_add","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (HAdd.hAdd s t).dedup (s.ndunion t.dedup)","decl":"theorem dedup_add (s t : Multiset α) : dedup (s + t) = ndunion s (dedup t) :=\n  Quot.induction_on₂ s t fun _ _ => congr_arg ((↑) : List α → Multiset α) <| dedup_append _ _\n\n"}
{"name":"Multiset.Disjoint.ndunion_eq","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : Disjoint s t\n⊢ Eq (s.ndunion t) (HAdd.hAdd s.dedup t)","decl":"theorem Disjoint.ndunion_eq {s t : Multiset α} (h : Disjoint s t) :\n    s.ndunion t = s.dedup + t := by\n  induction s, t using Quot.induction_on₂\n  exact congr_arg ((↑) : List α → Multiset α) <| List.Disjoint.union_eq <| by simpa using h\n\n"}
{"name":"Multiset.Subset.ndunion_eq_right","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : HasSubset.Subset s t\n⊢ Eq (s.ndunion t) t","decl":"theorem Subset.ndunion_eq_right {s t : Multiset α} (h : s ⊆ t) : s.ndunion t = t := by\n  induction s, t using Quot.induction_on₂\n  exact congr_arg ((↑) : List α → Multiset α) <| List.Subset.union_eq_right h\n\n"}
{"name":"Multiset.coe_ndinter","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ : List α\n⊢ Eq ((↑l₁).ndinter ↑l₂) ↑(Inter.inter l₁ l₂)","decl":"@[simp]\ntheorem coe_ndinter (l₁ l₂ : List α) : @ndinter α _ l₁ l₂ = (l₁ ∩ l₂ : List α) := by\n  simp only [ndinter, mem_coe, filter_coe, coe_eq_coe, ← elem_eq_mem]\n  apply Perm.refl\n\n"}
{"name":"Multiset.zero_ndinter","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq (Multiset.ndinter 0 s) 0","decl":"@[simp]\ntheorem zero_ndinter (s : Multiset α) : ndinter 0 s = 0 :=\n  rfl\n\n"}
{"name":"Multiset.cons_ndinter_of_mem","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\nh : Membership.mem t a\n⊢ Eq ((Multiset.cons a s).ndinter t) (Multiset.cons a (s.ndinter t))","decl":"@[simp]\ntheorem cons_ndinter_of_mem {a : α} (s : Multiset α) {t : Multiset α} (h : a ∈ t) :\n    ndinter (a ::ₘ s) t = a ::ₘ ndinter s t := by simp [ndinter, h]\n\n"}
{"name":"Multiset.ndinter_cons_of_not_mem","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\nh : Not (Membership.mem t a)\n⊢ Eq ((Multiset.cons a s).ndinter t) (s.ndinter t)","decl":"@[simp]\ntheorem ndinter_cons_of_not_mem {a : α} (s : Multiset α) {t : Multiset α} (h : a ∉ t) :\n    ndinter (a ::ₘ s) t = ndinter s t := by simp [ndinter, h]\n\n"}
{"name":"Multiset.mem_ndinter","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\na : α\n⊢ Iff (Membership.mem (s.ndinter t) a) (And (Membership.mem s a) (Membership.mem t a))","decl":"@[simp]\ntheorem mem_ndinter {s t : Multiset α} {a : α} : a ∈ ndinter s t ↔ a ∈ s ∧ a ∈ t := by\n  simp [ndinter, mem_filter]\n\n"}
{"name":"Multiset.Nodup.ndinter","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\na✝ : s.Nodup\n⊢ (s.ndinter t).Nodup","decl":"@[simp]\ntheorem Nodup.ndinter {s : Multiset α} (t : Multiset α) : Nodup s → Nodup (ndinter s t) :=\n  Nodup.filter _\n\n"}
{"name":"Multiset.le_ndinter","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\n⊢ Iff (LE.le s (t.ndinter u)) (And (LE.le s t) (HasSubset.Subset s u))","decl":"theorem le_ndinter {s t u : Multiset α} : s ≤ ndinter t u ↔ s ≤ t ∧ s ⊆ u := by\n  simp [ndinter, le_filter, subset_iff]\n\n"}
{"name":"Multiset.ndinter_le_left","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ LE.le (s.ndinter t) s","decl":"theorem ndinter_le_left (s t : Multiset α) : ndinter s t ≤ s :=\n  (le_ndinter.1 le_rfl).1\n\n"}
{"name":"Multiset.ndinter_subset_left","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ HasSubset.Subset (s.ndinter t) s","decl":"theorem ndinter_subset_left (s t : Multiset α) : ndinter s t ⊆ s :=\n  subset_of_le (ndinter_le_left s t)\n\n"}
{"name":"Multiset.ndinter_subset_right","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ HasSubset.Subset (s.ndinter t) t","decl":"theorem ndinter_subset_right (s t : Multiset α) : ndinter s t ⊆ t :=\n  (le_ndinter.1 le_rfl).2\n\n"}
{"name":"Multiset.ndinter_le_right","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nd : s.Nodup\n⊢ LE.le (s.ndinter t) t","decl":"theorem ndinter_le_right {s} (t : Multiset α) (d : Nodup s) : ndinter s t ≤ t :=\n  (le_iff_subset <| d.ndinter _).2 <| ndinter_subset_right _ _\n\n"}
{"name":"Multiset.inter_le_ndinter","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ LE.le (Inter.inter s t) (s.ndinter t)","decl":"theorem inter_le_ndinter (s t : Multiset α) : s ∩ t ≤ ndinter s t :=\n  le_ndinter.2 ⟨inter_le_left, subset_of_le inter_le_right⟩\n\n"}
{"name":"Multiset.ndinter_eq_inter","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nd : s.Nodup\n⊢ Eq (s.ndinter t) (Inter.inter s t)","decl":"@[simp]\ntheorem ndinter_eq_inter {s t : Multiset α} (d : Nodup s) : ndinter s t = s ∩ t :=\n  le_antisymm (le_inter (ndinter_le_left _ _) (ndinter_le_right _ d)) (inter_le_ndinter _ _)\n\n"}
{"name":"Multiset.ndinter_eq_zero_iff_disjoint","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Iff (Eq (s.ndinter t) 0) (Disjoint s t)","decl":"theorem ndinter_eq_zero_iff_disjoint {s t : Multiset α} : ndinter s t = 0 ↔ Disjoint s t := by\n  rw [← subset_zero]; simp [subset_iff, disjoint_left]\n\n"}
{"name":"Multiset.Disjoint.ndinter_eq_zero","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\na✝ : Disjoint s t\n⊢ Eq (s.ndinter t) 0","decl":"alias ⟨_, Disjoint.ndinter_eq_zero⟩ := ndinter_eq_zero_iff_disjoint\n\n"}
{"name":"Multiset.Subset.ndinter_eq_left","module":"Mathlib.Data.Multiset.FinsetOps","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : HasSubset.Subset s t\n⊢ Eq (s.ndinter t) s","decl":"theorem Subset.ndinter_eq_left {s t : Multiset α} (h : s ⊆ t) : s.ndinter t = s := by\n  induction s, t using Quot.induction_on₂\n  rw [quot_mk_to_coe'', quot_mk_to_coe'', coe_ndinter, List.Subset.inter_eq_left h]\n\n"}
