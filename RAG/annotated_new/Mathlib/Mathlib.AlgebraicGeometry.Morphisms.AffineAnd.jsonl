{"name":"AlgebraicGeometry.affineAnd_apply","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsAffine Y\n⊢ Iff (AlgebraicGeometry.affineAnd (fun {R S} [CommRing R] [CommRing S] => Q) f) (And (AlgebraicGeometry.IsAffine X) (Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop f))))","decl":"@[simp]\nlemma affineAnd_apply {X Y : Scheme.{u}} (f : X ⟶ Y) [IsAffine Y] :\n    affineAnd Q f ↔ IsAffine X ∧ Q (f.appTop).hom :=\n  Iff.rfl\n\n"}
{"name":"AlgebraicGeometry.affineAnd_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => Q\n⊢ (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q).toProperty.RespectsIso","decl":"/-- If `P` respects isos, also `affineAnd P` respects isomorphisms. -/\nlemma affineAnd_respectsIso (hP : RingHom.RespectsIso Q) :\n    (affineAnd Q).toProperty.RespectsIso := by\n  refine RespectsIso.mk _ ?_ ?_\n  · intro X Y Z e f ⟨hZ, ⟨hY, hf⟩⟩\n    simpa [hP.cancel_right_isIso, isAffine_of_isIso e.hom]\n  · intro X Y Z e f ⟨hZ, hf⟩\n    simpa [AffineTargetMorphismProperty.toProperty, isAffine_of_isIso e.inv, hP.cancel_left_isIso]\n\n"}
{"name":"AlgebraicGeometry.affineAnd_isLocal","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => Q\nhQl : RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => Q\nhQs : RingHom.OfLocalizationSpan fun {R S} [CommRing R] [CommRing S] => Q\n⊢ (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q).IsLocal","decl":"/-- `affineAnd P` is local if `P` is local on the (algebraic) source. -/\nlemma affineAnd_isLocal (hPi : RingHom.RespectsIso Q) (hQl : RingHom.LocalizationAwayPreserves Q)\n    (hQs : RingHom.OfLocalizationSpan Q) : (affineAnd Q).IsLocal where\n  respectsIso := affineAnd_respectsIso hPi\n  to_basicOpen {X Y _} f r := fun ⟨hX, hf⟩ ↦ by\n    simp only [Opens.map_top] at hf\n    constructor\n    · simp only [Scheme.preimage_basicOpen, Opens.map_top]\n      exact (isAffineOpen_top X).basicOpen _\n    · dsimp only\n      rw [morphismRestrict_appTop, CommRingCat.hom_comp, hPi.cancel_right_isIso]\n      -- Not sure why the `show` fixes the following `rw` complaining about \"motive is incorrect\"\n      show Q (Scheme.Hom.app f ((Y.basicOpen r).ι ''ᵁ ⊤)).hom\n      rw [Scheme.Opens.ι_image_top]\n      rw [(isAffineOpen_top Y).app_basicOpen_eq_away_map f (isAffineOpen_top X),\n        CommRingCat.hom_comp, hPi.cancel_right_isIso, ← Scheme.Hom.appTop]\n      dsimp only [Opens.map_top]\n      haveI := (isAffineOpen_top X).isLocalization_basicOpen (f.appTop r)\n      apply hQl\n      exact hf\n  of_basicOpenCover {X Y _} f s hs hf := by\n    dsimp [affineAnd] at hf\n    haveI : IsAffine X := by\n      apply isAffine_of_isAffineOpen_basicOpen (f.appTop '' s)\n      · apply_fun Ideal.map (f.appTop).hom at hs\n        rwa [Ideal.map_span, Ideal.map_top] at hs\n      · rintro - ⟨r, hr, rfl⟩\n        simp_rw [Scheme.preimage_basicOpen] at hf\n        exact (hf ⟨r, hr⟩).left\n    refine ⟨inferInstance, hQs.ofIsLocalization' hPi (f.appTop).hom s hs fun a ↦ ?_⟩\n    refine ⟨Γ(Y, Y.basicOpen a.val), Γ(X, X.basicOpen (f.appTop a.val)), inferInstance,\n      inferInstance, inferInstance, inferInstance, inferInstance, ?_, ?_⟩\n    · exact (isAffineOpen_top X).isLocalization_basicOpen (f.appTop a.val)\n    · obtain ⟨_, hf⟩ := hf a\n      rw [morphismRestrict_appTop, CommRingCat.hom_comp, hPi.cancel_right_isIso] at hf\n      -- Not sure why the `show` fixes the following `rw` complaining about \"motive is incorrect\"\n      have hf : Q (Scheme.Hom.app f ((Y.basicOpen a.1).ι ''ᵁ ⊤)).hom := hf\n      rw [Scheme.Opens.ι_image_top] at hf\n      rw [(isAffineOpen_top Y).app_basicOpen_eq_away_map _ (isAffineOpen_top X)] at hf\n      rwa [CommRingCat.hom_comp, hPi.cancel_right_isIso] at hf\n\n"}
{"name":"AlgebraicGeometry.affineAnd_isLocal_of_propertyIsLocal","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPi : RingHom.PropertyIsLocal fun {R S} [CommRing R] [CommRing S] => Q\n⊢ (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q).IsLocal","decl":"lemma affineAnd_isLocal_of_propertyIsLocal\n    (hPi : RingHom.PropertyIsLocal Q) : (affineAnd Q).IsLocal :=\n  affineAnd_isLocal hPi.respectsIso hPi.localizationAwayPreserves hPi.ofLocalizationSpan\n\n"}
{"name":"AlgebraicGeometry.affineAnd_isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhQi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => Q\nhQb : RingHom.IsStableUnderBaseChange fun {R S} [CommRing R] [CommRing S] => Q\n⊢ (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q).IsStableUnderBaseChange","decl":"/-- If `P` is stable under base change, so is `affineAnd P`. -/\nlemma affineAnd_isStableUnderBaseChange (hQi : RingHom.RespectsIso Q)\n    (hQb : RingHom.IsStableUnderBaseChange Q) :\n    (affineAnd Q).IsStableUnderBaseChange := by\n  haveI : (affineAnd Q).toProperty.RespectsIso := affineAnd_respectsIso hQi\n  apply AffineTargetMorphismProperty.IsStableUnderBaseChange.mk\n  intro X Y S _ _ f g ⟨hY, hg⟩\n  exact ⟨inferInstance, hQb.pullback_fst_appTop _ hQi f _ hg⟩\n\n"}
{"name":"AlgebraicGeometry.targetAffineLocally_affineAnd_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhQi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.targetAffineLocally (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q) f) (∀ (U : Y.Opens), AlgebraicGeometry.IsAffineOpen U → And (AlgebraicGeometry.IsAffineOpen ((TopologicalSpace.Opens.map f.base).obj U)) (Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.app f U))))","decl":"lemma targetAffineLocally_affineAnd_iff (hQi : RingHom.RespectsIso Q)\n    {X Y : Scheme.{u}} (f : X ⟶ Y) :\n    targetAffineLocally (affineAnd Q) f ↔ ∀ U : Y.Opens, IsAffineOpen U →\n      IsAffineOpen (f ⁻¹ᵁ U) ∧ Q (f.app U).hom := by\n  simp only [targetAffineLocally, affineAnd_apply, morphismRestrict_app, CommRingCat.hom_comp,\n    hQi.cancel_right_isIso]\n  refine ⟨fun hf U hU ↦ ?_, fun h U ↦ ?_⟩\n  · obtain ⟨hfU, hf⟩ := hf ⟨U, hU⟩\n    use hfU\n    have hf : Q (Scheme.Hom.app f (((⟨U, hU⟩ : Y.affineOpens) : Y.Opens).ι ''ᵁ ⊤)).hom := hf\n    rwa [Scheme.Opens.ι_image_top] at hf\n  · refine ⟨(h U U.2).1, ?_⟩\n    show Q (Scheme.Hom.app f ((U : Y.Opens).ι ''ᵁ ⊤)).hom\n    rw [Scheme.Opens.ι_image_top]\n    exact (h U U.2).2\n\n"}
{"name":"AlgebraicGeometry.targetAffineLocally_affineAnd_iff'","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhQi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.targetAffineLocally (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q) f) (And (AlgebraicGeometry.IsAffineHom f) (∀ (U : Y.Opens), AlgebraicGeometry.IsAffineOpen U → Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.app f U))))","decl":"/-- Variant of `targetAffineLocally_affineAnd_iff` where `IsAffineHom` is bundled. -/\nlemma targetAffineLocally_affineAnd_iff' (hQi : RingHom.RespectsIso Q)\n    {X Y : Scheme.{u}} (f : X ⟶ Y) :\n    targetAffineLocally (affineAnd Q) f ↔\n      IsAffineHom f ∧ ∀ U : Y.Opens, IsAffineOpen U → Q (f.app U).hom := by\n  rw [targetAffineLocally_affineAnd_iff hQi, isAffineHom_iff]\n  aesop\n\n"}
{"name":"AlgebraicGeometry.targetAffineLocally_affineAnd_iff_affineLocally","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhQ : RingHom.PropertyIsLocal fun {R S} [CommRing R] [CommRing S] => Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.targetAffineLocally (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q) f) (And (AlgebraicGeometry.IsAffineHom f) (AlgebraicGeometry.affineLocally (fun {R S} [CommRing R] [CommRing S] => Q) f))","decl":"lemma targetAffineLocally_affineAnd_iff_affineLocally (hQ : RingHom.PropertyIsLocal Q)\n    {X Y : Scheme.{u}} (f : X ⟶ Y) :\n    targetAffineLocally (affineAnd Q) f ↔ IsAffineHom f ∧ affineLocally Q f := by\n  haveI : HasRingHomProperty (affineLocally Q) Q := ⟨hQ, rfl⟩\n  rw [targetAffineLocally_affineAnd_iff' hQ.respectsIso]\n  simp only [and_congr_right_iff]\n  intro hf\n  constructor\n  · wlog hY : IsAffine Y\n    · intro h\n      rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := affineLocally Q)\n        _ (iSup_affineOpens_eq_top _)]\n      intro U\n      have : IsAffine (f ⁻¹ᵁ U) := hf.isAffine_preimage U U.2\n      rw [HasRingHomProperty.iff_of_isAffine (P := affineLocally Q),\n        morphismRestrict_appTop, CommRingCat.hom_comp, hQ.respectsIso.cancel_right_isIso]\n      apply h\n      rw [Scheme.Opens.ι_image_top]\n      exact U.2\n    intro h\n    have : IsAffine X := isAffine_of_isAffineHom f\n    rw [HasRingHomProperty.iff_of_isAffine (P := affineLocally Q)]\n    exact h ⊤ (isAffineOpen_top Y)\n  · intro h U hU\n    rw [affineLocally_iff_affineOpens_le] at h\n    rw [f.app_eq_appLE]\n    exact h ⟨U, hU⟩ ⟨f ⁻¹ᵁ U, hf.isAffine_preimage U hU⟩ (by simp)\n\n"}
{"name":"AlgebraicGeometry.targetAffineLocally_affineAnd_eq_affineLocally","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhQ : RingHom.PropertyIsLocal fun {R S} [CommRing R] [CommRing S] => Q\n⊢ Eq (AlgebraicGeometry.targetAffineLocally (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q)) (Min.min (@AlgebraicGeometry.IsAffineHom) (AlgebraicGeometry.affineLocally fun {R S} [CommRing R] [CommRing S] => Q))","decl":"lemma targetAffineLocally_affineAnd_eq_affineLocally (hQ : RingHom.PropertyIsLocal Q) :\n    targetAffineLocally (affineAnd Q) =\n      (@IsAffineHom ⊓ @affineLocally Q : MorphismProperty Scheme.{u}) := by\n  ext X Y f\n  exact targetAffineLocally_affineAnd_iff_affineLocally hQ f\n\n"}
{"name":"AlgebraicGeometry.targetAffineLocally_affineAnd_le","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q W : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhQW : ∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] {f : RingHom R S}, Q f → W f\n⊢ LE.le (AlgebraicGeometry.targetAffineLocally (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q)) (AlgebraicGeometry.targetAffineLocally (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => W))","decl":"lemma targetAffineLocally_affineAnd_le\n    (hQW : ∀ {R S : Type u} [CommRing R] [CommRing S] {f : R →+* S}, Q f → W f) :\n    targetAffineLocally (affineAnd Q) ≤ targetAffineLocally (affineAnd W) := by\n  intro X Y f h U\n  exact ⟨(h U).1, hQW (h U).2⟩\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.affineAnd_isStableUnderComposition","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nP : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhA : AlgebraicGeometry.HasAffineProperty P (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q)\nhQ : RingHom.StableUnderComposition fun {R S} [CommRing R] [CommRing S] => Q\n⊢ P.IsStableUnderComposition","decl":"/-- If `P` is a morphism property affine locally defined by `affineAnd Q`, `P` is stable under\ncomposition if `Q` is. -/\nlemma HasAffineProperty.affineAnd_isStableUnderComposition {P : MorphismProperty Scheme.{u}}\n    (hA : HasAffineProperty P (affineAnd Q)) (hQ : RingHom.StableUnderComposition Q) :\n    P.IsStableUnderComposition where\n  comp_mem {X Y Z} f g hf hg := by\n    haveI := hA\n    wlog hZ : IsAffine Z\n    · rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top _)]\n      intro U\n      rw [morphismRestrict_comp]\n      exact this hA hQ _ _ (IsLocalAtTarget.restrict hf _) (IsLocalAtTarget.restrict hg _) hA U.2\n    rw [HasAffineProperty.iff_of_isAffine (P := P) (Q := (affineAnd Q))] at hg\n    obtain ⟨hY, hg⟩ := hg\n    rw [HasAffineProperty.iff_of_isAffine (P := P) (Q := (affineAnd Q))] at hf\n    obtain ⟨hX, hf⟩ := hf\n    rw [HasAffineProperty.iff_of_isAffine (P := P) (Q := (affineAnd Q))]\n    exact ⟨hX, hQ _ _ hg hf⟩\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.affineAnd_isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nP : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nx✝ : AlgebraicGeometry.HasAffineProperty P (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q)\nhQi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => Q\nhQb : RingHom.IsStableUnderBaseChange fun {R S} [CommRing R] [CommRing S] => Q\n⊢ P.IsStableUnderBaseChange","decl":"/-- If `P` is a morphism property affine locally defined by `affineAnd Q`, `P` is stable under\nbase change if `Q` is. -/\nlemma HasAffineProperty.affineAnd_isStableUnderBaseChange {P : MorphismProperty Scheme.{u}}\n    (_ : HasAffineProperty P (affineAnd Q)) (hQi : RingHom.RespectsIso Q)\n    (hQb : RingHom.IsStableUnderBaseChange Q) :\n    P.IsStableUnderBaseChange :=\n  HasAffineProperty.isStableUnderBaseChange\n    (AlgebraicGeometry.affineAnd_isStableUnderBaseChange hQi hQb)\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.affineAnd_containsIdentities","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nP : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhA : AlgebraicGeometry.HasAffineProperty P (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q)\nhQi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => Q\nhQ : RingHom.ContainsIdentities fun {R S} [CommRing R] [CommRing S] => Q\n⊢ P.ContainsIdentities","decl":"/-- If `Q` contains identities and respects isomorphisms (i.e. is satisfied by isomorphisms),\nand `P` is affine locally defined by `affineAnd Q`, then `P` contains identities. -/\nlemma HasAffineProperty.affineAnd_containsIdentities {P : MorphismProperty Scheme.{u}}\n    (hA : HasAffineProperty P (affineAnd Q)) (hQi : RingHom.RespectsIso Q)\n    (hQ : RingHom.ContainsIdentities Q) :\n    P.ContainsIdentities where\n  id_mem X := by\n    rw [eq_targetAffineLocally P, targetAffineLocally_affineAnd_iff hQi]\n    intro U hU\n    exact ⟨hU, hQ _⟩\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.affineAnd_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nP : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhQi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => Q\nhQl : RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => Q\nhQs : RingHom.OfLocalizationSpan fun {R S} [CommRing R] [CommRing S] => Q\n⊢ Iff (AlgebraicGeometry.HasAffineProperty P (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q)) (∀ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y), Iff (P f) (And (AlgebraicGeometry.IsAffineHom f) (∀ (U : Y.Opens), AlgebraicGeometry.IsAffineOpen U → Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.app f U)))))","decl":"/-- A convenience constructor for `HasAffineProperty P (affineAnd Q)`. The `IsAffineHom` is bundled,\nsince this goes well with defining morphism properties via `extends IsAffineHom`. -/\nlemma HasAffineProperty.affineAnd_iff (P : MorphismProperty Scheme.{u})\n    (hQi : RingHom.RespectsIso Q) (hQl : RingHom.LocalizationAwayPreserves Q)\n    (hQs : RingHom.OfLocalizationSpan Q) :\n    HasAffineProperty P (affineAnd Q) ↔\n      ∀ {X Y : Scheme.{u}} (f : X ⟶ Y), P f ↔\n        (IsAffineHom f ∧ ∀ U : Y.Opens, IsAffineOpen U → Q (f.app U).hom) := by\n  simp_rw [isAffineHom_iff]\n  refine ⟨fun h X Y f ↦ ?_, fun h ↦ ⟨affineAnd_isLocal hQi hQl hQs, ?_⟩⟩\n  · rw [eq_targetAffineLocally P, targetAffineLocally_affineAnd_iff hQi]\n    aesop\n  · ext X Y f\n    rw [targetAffineLocally_affineAnd_iff hQi, h f]\n    aesop\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.affineAnd_le_isAffineHom","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nP : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhA : AlgebraicGeometry.HasAffineProperty P (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q)\n⊢ LE.le P @AlgebraicGeometry.IsAffineHom","decl":"lemma HasAffineProperty.affineAnd_le_isAffineHom (P : MorphismProperty Scheme.{u})\n    (hA : HasAffineProperty P (affineAnd Q)) : P ≤ @IsAffineHom := by\n  intro X Y f hf\n  wlog hY : IsAffine Y\n  · rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := @IsAffineHom) _ (iSup_affineOpens_eq_top _)]\n    intro U\n    exact this P hA _ (IsLocalAtTarget.restrict hf _) U.2\n  rw [HasAffineProperty.iff_of_isAffine (P := P) (Q := (affineAnd Q))] at hf\n  rw [HasAffineProperty.iff_of_isAffine (P := @IsAffineHom)]\n  exact hf.1\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.affineAnd_eq_of_propertyIsLocal","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nP P' : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.HasAffineProperty P (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q)\ninst✝ : AlgebraicGeometry.HasRingHomProperty P' fun {R S} [CommRing R] [CommRing S] => Q\n⊢ Eq P (Min.min (@AlgebraicGeometry.IsAffineHom) P')","decl":"lemma HasAffineProperty.affineAnd_eq_of_propertyIsLocal {P P' : MorphismProperty Scheme.{u}}\n    (hP : HasAffineProperty P (affineAnd Q)) [HasRingHomProperty P' Q] :\n    P = (@IsAffineHom ⊓ P' : MorphismProperty Scheme.{u}) := by\n  rw [HasAffineProperty.eq_targetAffineLocally (P := P),\n    targetAffineLocally_affineAnd_eq_affineLocally,\n    HasRingHomProperty.eq_affineLocally (P := P')]\n  exact HasRingHomProperty.isLocal_ringHomProperty P'\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.affineAnd_le_affineAnd","module":"Mathlib.AlgebraicGeometry.Morphisms.AffineAnd","initialProofState":"Q Q' : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nP P' : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.HasAffineProperty P (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q)\nhP' : AlgebraicGeometry.HasAffineProperty P' (AlgebraicGeometry.affineAnd fun {R S} [CommRing R] [CommRing S] => Q')\nhQQ' : ∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] {f : RingHom R S}, Q f → Q' f\n⊢ LE.le P P'","decl":"lemma HasAffineProperty.affineAnd_le_affineAnd {P P' : MorphismProperty Scheme.{u}}\n    (hP : HasAffineProperty P (affineAnd Q)) (hP' : HasAffineProperty P' (affineAnd Q'))\n    (hQQ' : ∀ {R S : Type u} [CommRing R] [CommRing S] {f : R →+* S}, Q f → Q' f) :\n    P ≤ P' := by\n  rw [HasAffineProperty.eq_targetAffineLocally (P := P),\n    HasAffineProperty.eq_targetAffineLocally (P := P')]\n  exact targetAffineLocally_affineAnd_le hQQ'\n\n"}
