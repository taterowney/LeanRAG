{"name":"ContinuousLinearMap.opNorm_mul_flip_apply","module":"Mathlib.Analysis.CStarAlgebra.Unitization","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NonUnitalNormedRing E\ninstâœâµ : StarRing E\ninstâœâ´ : NormedStarGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : IsScalarTower ğ•œ E E\ninstâœÂ¹ : SMulCommClass ğ•œ E E\ninstâœ : RegularNormedAlgebra ğ•œ E\na : E\nâŠ¢ Eq (Norm.norm ((ContinuousLinearMap.mul ğ•œ E).flip a)) (Norm.norm a)","decl":"lemma opNorm_mul_flip_apply (a : E) : â€–(mul ğ•œ E).flip aâ€– = â€–aâ€– := by\n  refine le_antisymm\n    (opNorm_le_bound _ (norm_nonneg _) fun b => by simpa only [mul_comm] using norm_mul_le b a) ?_\n  suffices â€–mul ğ•œ E (star a)â€– â‰¤ â€–(mul ğ•œ E).flip aâ€– by\n    simpa only [ge_iff_le, opNorm_mul_apply, norm_star] using this\n  refine opNorm_le_bound _ (norm_nonneg _) fun b => ?_\n  calc â€–mul ğ•œ E (star a) bâ€– = â€–(mul ğ•œ E).flip a (star b)â€– := by\n        simpa only [mul_apply', flip_apply, star_mul, star_star] using norm_star (star b * a)\n    _ â‰¤ â€–(mul ğ•œ E).flip aâ€– * â€–bâ€– := by\n        simpa only [flip_apply, mul_apply', norm_star] using le_opNorm ((mul ğ•œ E).flip a) (star b)\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_mul_flip_apply","module":"Mathlib.Analysis.CStarAlgebra.Unitization","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NonUnitalNormedRing E\ninstâœâµ : StarRing E\ninstâœâ´ : NormedStarGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : IsScalarTower ğ•œ E E\ninstâœÂ¹ : SMulCommClass ğ•œ E E\ninstâœ : RegularNormedAlgebra ğ•œ E\na : E\nâŠ¢ Eq (NNNorm.nnnorm ((ContinuousLinearMap.mul ğ•œ E).flip a)) (NNNorm.nnnorm a)","decl":"lemma opNNNorm_mul_flip_apply (a : E) : â€–(mul ğ•œ E).flip aâ€–â‚Š = â€–aâ€–â‚Š :=\n  Subtype.ext (opNorm_mul_flip_apply ğ•œ a)\n\n"}
{"name":"ContinuousLinearMap.isometry_mul_flip","module":"Mathlib.Analysis.CStarAlgebra.Unitization","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NonUnitalNormedRing E\ninstâœâµ : StarRing E\ninstâœâ´ : NormedStarGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : IsScalarTower ğ•œ E E\ninstâœÂ¹ : SMulCommClass ğ•œ E E\ninstâœ : RegularNormedAlgebra ğ•œ E\nâŠ¢ Isometry â‡‘(ContinuousLinearMap.mul ğ•œ E).flip","decl":"lemma isometry_mul_flip : Isometry (mul ğ•œ E).flip :=\n  AddMonoidHomClass.isometry_of_norm _ (opNorm_mul_flip_apply ğ•œ)\n\n"}
{"name":"CStarRing.instRegularNormedAlgebra","module":"Mathlib.Analysis.CStarAlgebra.Unitization","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : DenselyNormedField ğ•œ\ninstâœÂ³ : NonUnitalNormedRing E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : IsScalarTower ğ•œ E E\ninstâœ : SMulCommClass ğ•œ E E\nâŠ¢ RegularNormedAlgebra ğ•œ E","decl":"/-- A Câ‹†-algebra over a densely normed field is a regular normed algebra. -/\ninstance CStarRing.instRegularNormedAlgebra : RegularNormedAlgebra ğ•œ E where\n  isometry_mul' := AddMonoidHomClass.isometry_of_norm (mul ğ•œ E) fun a => NNReal.eq_iff.mp <|\n    show â€–mul ğ•œ E aâ€–â‚Š = â€–aâ€–â‚Š by\n    rw [â† sSup_unitClosedBall_eq_nnnorm]\n    refine csSup_eq_of_forall_le_of_forall_lt_exists_gt ?_ ?_ fun r hr => ?_\n    Â· exact (Metric.nonempty_closedBall.mpr zero_le_one).image _\n    Â· rintro - âŸ¨x, hx, rflâŸ©\n      exact\n        ((mul ğ•œ E a).unit_le_opNorm x <| mem_closedBall_zero_iff.mp hx).trans\n          (opNorm_mul_apply_le ğ•œ E a)\n    Â· have ha : 0 < â€–aâ€–â‚Š := zero_le'.trans_lt hr\n      rw [â† inv_inv â€–aâ€–â‚Š, NNReal.lt_inv_iff_mul_lt (inv_ne_zero ha.ne')] at hr\n      obtain âŸ¨k, hkâ‚, hkâ‚‚âŸ© :=\n        NormedField.exists_lt_nnnorm_lt ğ•œ (mul_lt_mul_of_pos_right hr <| inv_pos.2 ha)\n      refine âŸ¨_, âŸ¨k â€¢ star a, ?_, rflâŸ©, ?_âŸ©\n      Â· simpa only [mem_closedBall_zero_iff, norm_smul, one_mul, norm_star] using\n          (NNReal.le_inv_iff_mul_le ha.ne').1 (one_mul â€–aâ€–â‚Šâ»Â¹ â–¸ hkâ‚‚.le : â€–kâ€–â‚Š â‰¤ â€–aâ€–â‚Šâ»Â¹)\n      Â· simp only [map_smul, nnnorm_smul, mul_apply', mul_smul_comm, CStarRing.nnnorm_self_mul_star]\n        rwa [â† div_lt_iffâ‚€ (mul_pos ha ha), div_eq_mul_inv, mul_inv, â† mul_assoc]\n\n"}
{"name":"Unitization.norm_splitMul_snd_sq","module":"Mathlib.Analysis.CStarAlgebra.Unitization","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¸ : DenselyNormedField ğ•œ\ninstâœâ· : NonUnitalNormedRing E\ninstâœâ¶ : StarRing E\ninstâœâµ : CStarRing E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : IsScalarTower ğ•œ E E\ninstâœÂ² : SMulCommClass ğ•œ E E\ninstâœÂ¹ : StarRing ğ•œ\ninstâœ : StarModule ğ•œ E\nx : Unitization ğ•œ E\nâŠ¢ LE.le (HPow.hPow (Norm.norm ((Unitization.splitMul ğ•œ E) x).2) 2) (Norm.norm ((Unitization.splitMul ğ•œ E) (HMul.hMul (Star.star x) x)).2)","decl":"/-- This is the key lemma used to establish the instance `Unitization.instCStarRing`\n(i.e., proving that the norm on `Unitization ğ•œ E` satisfies the Câ‹†-property). We split this one\nout so that declaring the `CStarRing` instance doesn't time out. -/\ntheorem Unitization.norm_splitMul_snd_sq (x : Unitization ğ•œ E) :\n    â€–(Unitization.splitMul ğ•œ E x).sndâ€– ^ 2 â‰¤ â€–(Unitization.splitMul ğ•œ E (star x * x)).sndâ€– := by\n  /- The key idea is that we can use `sSup_unitClosedBall_eq_norm` to make this about\n  applying this linear map to elements of norm at most one. There is a bit of `sqrt` and `sq`\n  shuffling that needs to occur, which is primarily just an annoyance. -/\n  refine (Real.le_sqrt (norm_nonneg _) (norm_nonneg _)).mp ?_\n  simp only [Unitization.splitMul_apply]\n  rw [â† sSup_unitClosedBall_eq_norm]\n  refine csSup_le ((Metric.nonempty_closedBall.2 zero_le_one).image _) ?_\n  rintro - âŸ¨b, hb, rflâŸ©\n  simp only\n  -- rewrite to a more convenient form; this is where we use the Câ‹†-property\n  rw [â† Real.sqrt_sq (norm_nonneg _), Real.sqrt_le_sqrt_iff (norm_nonneg _), sq,\n    â† CStarRing.norm_star_mul_self, ContinuousLinearMap.add_apply, star_add, mul_apply',\n    Algebra.algebraMap_eq_smul_one, ContinuousLinearMap.smul_apply,\n    ContinuousLinearMap.one_apply, star_mul, star_smul, add_mul, smul_mul_assoc, â† mul_smul_comm,\n    mul_assoc, â† mul_add, â† sSup_unitClosedBall_eq_norm]\n  refine (norm_mul_le _ _).trans ?_\n  calc\n    _ â‰¤ â€–star x.fst â€¢ (x.fst â€¢ b + x.snd * b) + star x.snd * (x.fst â€¢ b + x.snd * b)â€– := by\n      nth_rewrite 2 [â† one_mul â€–_ + _â€–]\n      gcongr\n      exact (norm_star b).symm â–¸ mem_closedBall_zero_iff.1 hb\n    _ â‰¤ sSup (_ '' Metric.closedBall 0 1) := le_csSup ?_ âŸ¨b, hb, ?_âŸ©\n  -- now we just check the side conditions for `le_csSup`. There is nothing of interest here.\n  Â· refine âŸ¨â€–(star x * x).fstâ€– + â€–(star x * x).sndâ€–, ?_âŸ©\n    rintro _ âŸ¨y, hy, rflâŸ©\n    refine (norm_add_le _ _).trans ?_\n    gcongr\n    Â· rw [Algebra.algebraMap_eq_smul_one]\n      refine (norm_smul _ _).trans_le ?_\n      simpa only [mul_one] using\n        mul_le_mul_of_nonneg_left (mem_closedBall_zero_iff.1 hy) (norm_nonneg (star x * x).fst)\n    Â· exact (unit_le_opNorm _ y <| mem_closedBall_zero_iff.1 hy).trans (opNorm_mul_apply_le _ _ _)\n  Â· simp only [ContinuousLinearMap.add_apply, mul_apply', Unitization.snd_star, Unitization.snd_mul,\n      Unitization.fst_mul, Unitization.fst_star, Algebra.algebraMap_eq_smul_one, smul_apply,\n      one_apply, smul_add, mul_add, add_mul]\n    simp only [smul_smul, smul_mul_assoc, â† add_assoc, â† mul_assoc, mul_smul_comm]\n\n"}
{"name":"Unitization.instCStarRing","module":"Mathlib.Analysis.CStarAlgebra.Unitization","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : DenselyNormedField ğ•œ\ninstâœâ¶ : NonUnitalNormedRing E\ninstâœâµ : StarRing E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : IsScalarTower ğ•œ E E\ninstâœÂ² : SMulCommClass ğ•œ E E\ninstâœÂ¹ : StarRing ğ•œ\ninstâœ : StarModule ğ•œ E\nâŠ¢ CStarRing (Unitization ğ•œ E)","decl":"/-- The norm on `Unitization ğ•œ E` satisfies the Câ‹†-property -/\ninstance Unitization.instCStarRing : CStarRing (Unitization ğ•œ E) where\n  norm_mul_self_le x := by\n    -- rewrite both sides as a `âŠ”`\n    simp only [Unitization.norm_def, Prod.norm_def]\n    -- Show that `(Unitization.splitMul ğ•œ E x).snd` satisfies the Câ‹†-property, in two stages:\n    have hâ‚ : âˆ€ x : Unitization ğ•œ E,\n        â€–(Unitization.splitMul ğ•œ E x).sndâ€– â‰¤ â€–(Unitization.splitMul ğ•œ E (star x)).sndâ€– := by\n      simp only [add_zero, Unitization.splitMul_apply, Unitization.snd_star, Unitization.fst_star]\n      intro x\n      /- split based on whether the term inside the norm is zero or not. If so, it's trivial.\n      If not, then apply `norm_splitMul_snd_sq` and cancel one copy of the norm -/\n      by_cases h : algebraMap ğ•œ (E â†’L[ğ•œ] E) x.fst + mul ğ•œ E x.snd = 0\n      Â· simp only [h, norm_zero, norm_le_zero_iff]\n        exact norm_nonneg _\n      Â· have : â€–(Unitization.splitMul ğ•œ E x).sndâ€– ^ 2 â‰¤\n          â€–(Unitization.splitMul ğ•œ E (star x)).sndâ€– * â€–(Unitization.splitMul ğ•œ E x).sndâ€– :=\n          (norm_splitMul_snd_sq ğ•œ x).trans <| by\n            rw [map_mul, Prod.snd_mul]\n            exact norm_mul_le _ _\n        rw [sq] at this\n        rw [â† Ne, â† norm_pos_iff] at h\n        simp only [add_zero, Unitization.splitMul_apply, Unitization.snd_star,\n          Unitization.fst_star, star_star] at this\n        exact (mul_le_mul_right h).mp this\n    -- in this step we make use of the key lemma `norm_splitMul_snd_sq`\n    have hâ‚‚ : â€–(Unitization.splitMul ğ•œ E (star x * x)).sndâ€–\n        = â€–(Unitization.splitMul ğ•œ E x).sndâ€– ^ 2 := by\n      refine le_antisymm ?_ (norm_splitMul_snd_sq ğ•œ x)\n      rw [map_mul, Prod.snd_mul]\n      exact (norm_mul_le _ _).trans <| by\n        rw [sq]\n        gcongr\n        simpa only [star_star] using hâ‚ (star x)\n    -- Show that `(Unitization.splitMul ğ•œ E x).fst` satisfies the Câ‹†-property\n    have hâ‚ƒ : â€–(Unitization.splitMul ğ•œ E (star x * x)).fstâ€–\n        = â€–(Unitization.splitMul ğ•œ E x).fstâ€– ^ 2 := by\n      simp only [Unitization.splitMul_apply, Unitization.fst_mul, Unitization.fst_star, add_zero,\n        norm_mul, norm_star, sq]\n    rw [hâ‚‚, hâ‚ƒ]\n    /- use the definition of the norm, and split into cases based on whether the norm in the first\n    coordinate is bigger or smaller than the norm in the second coordinate. -/\n    by_cases h : â€–(Unitization.splitMul ğ•œ E x).fstâ€– â‰¤ â€–(Unitization.splitMul ğ•œ E x).sndâ€–\n    Â· rw [sq, sq, sup_eq_right.mpr h, sup_eq_right.mpr (mul_self_le_mul_self (norm_nonneg _) h)]\n    Â· replace h := (not_le.mp h).le\n      rw [sq, sq, sup_eq_left.mpr h, sup_eq_left.mpr (mul_self_le_mul_self (norm_nonneg _) h)]\n\n"}
