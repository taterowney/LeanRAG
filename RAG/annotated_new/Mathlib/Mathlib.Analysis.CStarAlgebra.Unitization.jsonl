{"name":"ContinuousLinearMap.opNorm_mul_flip_apply","module":"Mathlib.Analysis.CStarAlgebra.Unitization","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NonUnitalNormedRing E\ninst✝⁵ : StarRing E\ninst✝⁴ : NormedStarGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : IsScalarTower 𝕜 E E\ninst✝¹ : SMulCommClass 𝕜 E E\ninst✝ : RegularNormedAlgebra 𝕜 E\na : E\n⊢ Eq (Norm.norm ((ContinuousLinearMap.mul 𝕜 E).flip a)) (Norm.norm a)","decl":"lemma opNorm_mul_flip_apply (a : E) : ‖(mul 𝕜 E).flip a‖ = ‖a‖ := by\n  refine le_antisymm\n    (opNorm_le_bound _ (norm_nonneg _) fun b => by simpa only [mul_comm] using norm_mul_le b a) ?_\n  suffices ‖mul 𝕜 E (star a)‖ ≤ ‖(mul 𝕜 E).flip a‖ by\n    simpa only [ge_iff_le, opNorm_mul_apply, norm_star] using this\n  refine opNorm_le_bound _ (norm_nonneg _) fun b => ?_\n  calc ‖mul 𝕜 E (star a) b‖ = ‖(mul 𝕜 E).flip a (star b)‖ := by\n        simpa only [mul_apply', flip_apply, star_mul, star_star] using norm_star (star b * a)\n    _ ≤ ‖(mul 𝕜 E).flip a‖ * ‖b‖ := by\n        simpa only [flip_apply, mul_apply', norm_star] using le_opNorm ((mul 𝕜 E).flip a) (star b)\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_mul_flip_apply","module":"Mathlib.Analysis.CStarAlgebra.Unitization","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NonUnitalNormedRing E\ninst✝⁵ : StarRing E\ninst✝⁴ : NormedStarGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : IsScalarTower 𝕜 E E\ninst✝¹ : SMulCommClass 𝕜 E E\ninst✝ : RegularNormedAlgebra 𝕜 E\na : E\n⊢ Eq (NNNorm.nnnorm ((ContinuousLinearMap.mul 𝕜 E).flip a)) (NNNorm.nnnorm a)","decl":"lemma opNNNorm_mul_flip_apply (a : E) : ‖(mul 𝕜 E).flip a‖₊ = ‖a‖₊ :=\n  Subtype.ext (opNorm_mul_flip_apply 𝕜 a)\n\n"}
{"name":"ContinuousLinearMap.isometry_mul_flip","module":"Mathlib.Analysis.CStarAlgebra.Unitization","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NonUnitalNormedRing E\ninst✝⁵ : StarRing E\ninst✝⁴ : NormedStarGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : IsScalarTower 𝕜 E E\ninst✝¹ : SMulCommClass 𝕜 E E\ninst✝ : RegularNormedAlgebra 𝕜 E\n⊢ Isometry ⇑(ContinuousLinearMap.mul 𝕜 E).flip","decl":"lemma isometry_mul_flip : Isometry (mul 𝕜 E).flip :=\n  AddMonoidHomClass.isometry_of_norm _ (opNorm_mul_flip_apply 𝕜)\n\n"}
{"name":"CStarRing.instRegularNormedAlgebra","module":"Mathlib.Analysis.CStarAlgebra.Unitization","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : DenselyNormedField 𝕜\ninst✝³ : NonUnitalNormedRing E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : IsScalarTower 𝕜 E E\ninst✝ : SMulCommClass 𝕜 E E\n⊢ RegularNormedAlgebra 𝕜 E","decl":"/-- A C⋆-algebra over a densely normed field is a regular normed algebra. -/\ninstance CStarRing.instRegularNormedAlgebra : RegularNormedAlgebra 𝕜 E where\n  isometry_mul' := AddMonoidHomClass.isometry_of_norm (mul 𝕜 E) fun a => NNReal.eq_iff.mp <|\n    show ‖mul 𝕜 E a‖₊ = ‖a‖₊ by\n    rw [← sSup_unitClosedBall_eq_nnnorm]\n    refine csSup_eq_of_forall_le_of_forall_lt_exists_gt ?_ ?_ fun r hr => ?_\n    · exact (Metric.nonempty_closedBall.mpr zero_le_one).image _\n    · rintro - ⟨x, hx, rfl⟩\n      exact\n        ((mul 𝕜 E a).unit_le_opNorm x <| mem_closedBall_zero_iff.mp hx).trans\n          (opNorm_mul_apply_le 𝕜 E a)\n    · have ha : 0 < ‖a‖₊ := zero_le'.trans_lt hr\n      rw [← inv_inv ‖a‖₊, NNReal.lt_inv_iff_mul_lt (inv_ne_zero ha.ne')] at hr\n      obtain ⟨k, hk₁, hk₂⟩ :=\n        NormedField.exists_lt_nnnorm_lt 𝕜 (mul_lt_mul_of_pos_right hr <| inv_pos.2 ha)\n      refine ⟨_, ⟨k • star a, ?_, rfl⟩, ?_⟩\n      · simpa only [mem_closedBall_zero_iff, norm_smul, one_mul, norm_star] using\n          (NNReal.le_inv_iff_mul_le ha.ne').1 (one_mul ‖a‖₊⁻¹ ▸ hk₂.le : ‖k‖₊ ≤ ‖a‖₊⁻¹)\n      · simp only [map_smul, nnnorm_smul, mul_apply', mul_smul_comm, CStarRing.nnnorm_self_mul_star]\n        rwa [← div_lt_iff₀ (mul_pos ha ha), div_eq_mul_inv, mul_inv, ← mul_assoc]\n\n"}
{"name":"Unitization.norm_splitMul_snd_sq","module":"Mathlib.Analysis.CStarAlgebra.Unitization","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁸ : DenselyNormedField 𝕜\ninst✝⁷ : NonUnitalNormedRing E\ninst✝⁶ : StarRing E\ninst✝⁵ : CStarRing E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : IsScalarTower 𝕜 E E\ninst✝² : SMulCommClass 𝕜 E E\ninst✝¹ : StarRing 𝕜\ninst✝ : StarModule 𝕜 E\nx : Unitization 𝕜 E\n⊢ LE.le (HPow.hPow (Norm.norm ((Unitization.splitMul 𝕜 E) x).2) 2) (Norm.norm ((Unitization.splitMul 𝕜 E) (HMul.hMul (Star.star x) x)).2)","decl":"/-- This is the key lemma used to establish the instance `Unitization.instCStarRing`\n(i.e., proving that the norm on `Unitization 𝕜 E` satisfies the C⋆-property). We split this one\nout so that declaring the `CStarRing` instance doesn't time out. -/\ntheorem Unitization.norm_splitMul_snd_sq (x : Unitization 𝕜 E) :\n    ‖(Unitization.splitMul 𝕜 E x).snd‖ ^ 2 ≤ ‖(Unitization.splitMul 𝕜 E (star x * x)).snd‖ := by\n  /- The key idea is that we can use `sSup_unitClosedBall_eq_norm` to make this about\n  applying this linear map to elements of norm at most one. There is a bit of `sqrt` and `sq`\n  shuffling that needs to occur, which is primarily just an annoyance. -/\n  refine (Real.le_sqrt (norm_nonneg _) (norm_nonneg _)).mp ?_\n  simp only [Unitization.splitMul_apply]\n  rw [← sSup_unitClosedBall_eq_norm]\n  refine csSup_le ((Metric.nonempty_closedBall.2 zero_le_one).image _) ?_\n  rintro - ⟨b, hb, rfl⟩\n  simp only\n  -- rewrite to a more convenient form; this is where we use the C⋆-property\n  rw [← Real.sqrt_sq (norm_nonneg _), Real.sqrt_le_sqrt_iff (norm_nonneg _), sq,\n    ← CStarRing.norm_star_mul_self, ContinuousLinearMap.add_apply, star_add, mul_apply',\n    Algebra.algebraMap_eq_smul_one, ContinuousLinearMap.smul_apply,\n    ContinuousLinearMap.one_apply, star_mul, star_smul, add_mul, smul_mul_assoc, ← mul_smul_comm,\n    mul_assoc, ← mul_add, ← sSup_unitClosedBall_eq_norm]\n  refine (norm_mul_le _ _).trans ?_\n  calc\n    _ ≤ ‖star x.fst • (x.fst • b + x.snd * b) + star x.snd * (x.fst • b + x.snd * b)‖ := by\n      nth_rewrite 2 [← one_mul ‖_ + _‖]\n      gcongr\n      exact (norm_star b).symm ▸ mem_closedBall_zero_iff.1 hb\n    _ ≤ sSup (_ '' Metric.closedBall 0 1) := le_csSup ?_ ⟨b, hb, ?_⟩\n  -- now we just check the side conditions for `le_csSup`. There is nothing of interest here.\n  · refine ⟨‖(star x * x).fst‖ + ‖(star x * x).snd‖, ?_⟩\n    rintro _ ⟨y, hy, rfl⟩\n    refine (norm_add_le _ _).trans ?_\n    gcongr\n    · rw [Algebra.algebraMap_eq_smul_one]\n      refine (norm_smul _ _).trans_le ?_\n      simpa only [mul_one] using\n        mul_le_mul_of_nonneg_left (mem_closedBall_zero_iff.1 hy) (norm_nonneg (star x * x).fst)\n    · exact (unit_le_opNorm _ y <| mem_closedBall_zero_iff.1 hy).trans (opNorm_mul_apply_le _ _ _)\n  · simp only [ContinuousLinearMap.add_apply, mul_apply', Unitization.snd_star, Unitization.snd_mul,\n      Unitization.fst_mul, Unitization.fst_star, Algebra.algebraMap_eq_smul_one, smul_apply,\n      one_apply, smul_add, mul_add, add_mul]\n    simp only [smul_smul, smul_mul_assoc, ← add_assoc, ← mul_assoc, mul_smul_comm]\n\n"}
{"name":"Unitization.instCStarRing","module":"Mathlib.Analysis.CStarAlgebra.Unitization","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : DenselyNormedField 𝕜\ninst✝⁶ : NonUnitalNormedRing E\ninst✝⁵ : StarRing E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : IsScalarTower 𝕜 E E\ninst✝² : SMulCommClass 𝕜 E E\ninst✝¹ : StarRing 𝕜\ninst✝ : StarModule 𝕜 E\n⊢ CStarRing (Unitization 𝕜 E)","decl":"/-- The norm on `Unitization 𝕜 E` satisfies the C⋆-property -/\ninstance Unitization.instCStarRing : CStarRing (Unitization 𝕜 E) where\n  norm_mul_self_le x := by\n    -- rewrite both sides as a `⊔`\n    simp only [Unitization.norm_def, Prod.norm_def]\n    -- Show that `(Unitization.splitMul 𝕜 E x).snd` satisfies the C⋆-property, in two stages:\n    have h₁ : ∀ x : Unitization 𝕜 E,\n        ‖(Unitization.splitMul 𝕜 E x).snd‖ ≤ ‖(Unitization.splitMul 𝕜 E (star x)).snd‖ := by\n      simp only [add_zero, Unitization.splitMul_apply, Unitization.snd_star, Unitization.fst_star]\n      intro x\n      /- split based on whether the term inside the norm is zero or not. If so, it's trivial.\n      If not, then apply `norm_splitMul_snd_sq` and cancel one copy of the norm -/\n      by_cases h : algebraMap 𝕜 (E →L[𝕜] E) x.fst + mul 𝕜 E x.snd = 0\n      · simp only [h, norm_zero, norm_le_zero_iff]\n        exact norm_nonneg _\n      · have : ‖(Unitization.splitMul 𝕜 E x).snd‖ ^ 2 ≤\n          ‖(Unitization.splitMul 𝕜 E (star x)).snd‖ * ‖(Unitization.splitMul 𝕜 E x).snd‖ :=\n          (norm_splitMul_snd_sq 𝕜 x).trans <| by\n            rw [map_mul, Prod.snd_mul]\n            exact norm_mul_le _ _\n        rw [sq] at this\n        rw [← Ne, ← norm_pos_iff] at h\n        simp only [add_zero, Unitization.splitMul_apply, Unitization.snd_star,\n          Unitization.fst_star, star_star] at this\n        exact (mul_le_mul_right h).mp this\n    -- in this step we make use of the key lemma `norm_splitMul_snd_sq`\n    have h₂ : ‖(Unitization.splitMul 𝕜 E (star x * x)).snd‖\n        = ‖(Unitization.splitMul 𝕜 E x).snd‖ ^ 2 := by\n      refine le_antisymm ?_ (norm_splitMul_snd_sq 𝕜 x)\n      rw [map_mul, Prod.snd_mul]\n      exact (norm_mul_le _ _).trans <| by\n        rw [sq]\n        gcongr\n        simpa only [star_star] using h₁ (star x)\n    -- Show that `(Unitization.splitMul 𝕜 E x).fst` satisfies the C⋆-property\n    have h₃ : ‖(Unitization.splitMul 𝕜 E (star x * x)).fst‖\n        = ‖(Unitization.splitMul 𝕜 E x).fst‖ ^ 2 := by\n      simp only [Unitization.splitMul_apply, Unitization.fst_mul, Unitization.fst_star, add_zero,\n        norm_mul, norm_star, sq]\n    rw [h₂, h₃]\n    /- use the definition of the norm, and split into cases based on whether the norm in the first\n    coordinate is bigger or smaller than the norm in the second coordinate. -/\n    by_cases h : ‖(Unitization.splitMul 𝕜 E x).fst‖ ≤ ‖(Unitization.splitMul 𝕜 E x).snd‖\n    · rw [sq, sq, sup_eq_right.mpr h, sup_eq_right.mpr (mul_self_le_mul_self (norm_nonneg _) h)]\n    · replace h := (not_le.mp h).le\n      rw [sq, sq, sup_eq_left.mpr h, sup_eq_left.mpr (mul_self_le_mul_self (norm_nonneg _) h)]\n\n"}
