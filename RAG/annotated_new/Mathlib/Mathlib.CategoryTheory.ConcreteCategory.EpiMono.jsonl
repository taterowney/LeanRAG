{"name":"CategoryTheory.ConcreteCategory.mono_of_injective","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.HasForget C\nX Y : C\nf : Quiver.Hom X Y\ni : Function.Injective ⇑f\n⊢ CategoryTheory.Mono f","decl":"attribute [local instance] HasForget.instFunLike in\n/-- In any concrete category, injective morphisms are monomorphisms. -/\ntheorem mono_of_injective {X Y : C} (f : X ⟶ Y) (i : Function.Injective f) :\n    Mono f :=\n  (forget C).mono_of_mono_map ((mono_iff_injective ((forget C).map f)).2 i)\n\n"}
{"name":"CategoryTheory.ConcreteCategory.forget₂_preservesMonomorphisms","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.HasForget C\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.HasForget D\ninst✝¹ : CategoryTheory.HasForget₂ C D\ninst✝ : (CategoryTheory.forget C).PreservesMonomorphisms\n⊢ (CategoryTheory.forget₂ C D).PreservesMonomorphisms","decl":"instance forget₂_preservesMonomorphisms (C : Type u) (D : Type u')\n    [Category.{v} C] [HasForget.{w} C] [Category.{v'} D] [HasForget.{w} D]\n    [HasForget₂ C D] [(forget C).PreservesMonomorphisms] :\n    (forget₂ C D).PreservesMonomorphisms :=\n  have : (forget₂ C D ⋙ forget D).PreservesMonomorphisms := by\n    simp only [HasForget₂.forget_comp]\n    infer_instance\n  Functor.preservesMonomorphisms_of_preserves_of_reflects _ (forget D)\n\n"}
{"name":"CategoryTheory.ConcreteCategory.forget₂_preservesEpimorphisms","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.HasForget C\ninst✝³ : CategoryTheory.Category.{v', u'} D\ninst✝² : CategoryTheory.HasForget D\ninst✝¹ : CategoryTheory.HasForget₂ C D\ninst✝ : (CategoryTheory.forget C).PreservesEpimorphisms\n⊢ (CategoryTheory.forget₂ C D).PreservesEpimorphisms","decl":"instance forget₂_preservesEpimorphisms (C : Type u) (D : Type u')\n    [Category.{v} C] [HasForget.{w} C] [Category.{v'} D] [HasForget.{w} D]\n    [HasForget₂ C D] [(forget C).PreservesEpimorphisms] :\n    (forget₂ C D).PreservesEpimorphisms :=\n  have : (forget₂ C D ⋙ forget D).PreservesEpimorphisms := by\n    simp only [HasForget₂.forget_comp]\n    infer_instance\n  Functor.preservesEpimorphisms_of_preserves_of_reflects _ (forget D)\n\n"}
{"name":"CategoryTheory.ConcreteCategory.surjective_le_epimorphisms","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.HasForget C\n⊢ LE.le (CategoryTheory.MorphismProperty.surjective C) (CategoryTheory.MorphismProperty.epimorphisms C)","decl":"lemma surjective_le_epimorphisms :\n    MorphismProperty.surjective C ≤ epimorphisms C :=\n  fun _ _ _ hf => (forget C).epi_of_epi_map ((epi_iff_surjective _).2 hf)\n\n"}
{"name":"CategoryTheory.ConcreteCategory.injective_le_monomorphisms","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.HasForget C\n⊢ LE.le (CategoryTheory.MorphismProperty.injective C) (CategoryTheory.MorphismProperty.monomorphisms C)","decl":"lemma injective_le_monomorphisms :\n    MorphismProperty.injective C ≤ monomorphisms C :=\n  fun _ _ _ hf => (forget C).mono_of_mono_map ((mono_iff_injective _).2 hf)\n\n"}
{"name":"CategoryTheory.ConcreteCategory.surjective_eq_epimorphisms_iff","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.HasForget C\n⊢ Iff (Eq (CategoryTheory.MorphismProperty.surjective C) (CategoryTheory.MorphismProperty.epimorphisms C)) (CategoryTheory.forget C).PreservesEpimorphisms","decl":"lemma surjective_eq_epimorphisms_iff :\n    MorphismProperty.surjective C = epimorphisms C ↔ (forget C).PreservesEpimorphisms := by\n  constructor\n  · intro h\n    constructor\n    rintro _ _ f (hf : epimorphisms C f)\n    rw [epi_iff_surjective]\n    rw [← h] at hf\n    exact hf\n  · intro\n    apply le_antisymm (surjective_le_epimorphisms C)\n    intro _ _ f hf\n    have : Epi f := hf\n    change Function.Surjective ((forget C).map f)\n    rw [← epi_iff_surjective]\n    infer_instance\n\n"}
{"name":"CategoryTheory.ConcreteCategory.injective_eq_monomorphisms_iff","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.HasForget C\n⊢ Iff (Eq (CategoryTheory.MorphismProperty.injective C) (CategoryTheory.MorphismProperty.monomorphisms C)) (CategoryTheory.forget C).PreservesMonomorphisms","decl":"lemma injective_eq_monomorphisms_iff :\n    MorphismProperty.injective C = monomorphisms C ↔ (forget C).PreservesMonomorphisms := by\n  constructor\n  · intro h\n    constructor\n    rintro _ _ f (hf : monomorphisms C f)\n    rw [mono_iff_injective]\n    rw [← h] at hf\n    exact hf\n  · intro\n    apply le_antisymm (injective_le_monomorphisms C)\n    intro _ _ f hf\n    have : Mono f := hf\n    change Function.Injective ((forget C).map f)\n    rw [← mono_iff_injective]\n    infer_instance\n\n"}
{"name":"CategoryTheory.ConcreteCategory.injective_eq_monomorphisms","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.HasForget C\ninst✝ : (CategoryTheory.forget C).PreservesMonomorphisms\n⊢ Eq (CategoryTheory.MorphismProperty.injective C) (CategoryTheory.MorphismProperty.monomorphisms C)","decl":"lemma injective_eq_monomorphisms [(forget C).PreservesMonomorphisms] :\n    MorphismProperty.injective C = monomorphisms C := by\n  rw [injective_eq_monomorphisms_iff]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ConcreteCategory.surjective_eq_epimorphisms","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.HasForget C\ninst✝ : (CategoryTheory.forget C).PreservesEpimorphisms\n⊢ Eq (CategoryTheory.MorphismProperty.surjective C) (CategoryTheory.MorphismProperty.epimorphisms C)","decl":"lemma surjective_eq_epimorphisms [(forget C).PreservesEpimorphisms] :\n    MorphismProperty.surjective C = epimorphisms C := by\n  rw [surjective_eq_epimorphisms_iff]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ConcreteCategory.instHasFunctorialSurjectiveInjectiveFactorization","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.HasForget C\ninst✝ : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\n⊢ CategoryTheory.ConcreteCategory.HasFunctorialSurjectiveInjectiveFactorization C","decl":"instance (priority := 100) : HasFunctorialSurjectiveInjectiveFactorization C where\n  nonempty_functorialFactorizationData :=\n    ⟨functorialSurjectiveInjectiveFactorizationData C⟩\n\n"}
{"name":"CategoryTheory.ConcreteCategory.injective_of_mono_of_preservesPullback","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Mono f\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan (CategoryTheory.forget C)\n⊢ Function.Injective ⇑f","decl":"theorem injective_of_mono_of_preservesPullback {X Y : C} (f : X ⟶ Y) [Mono f]\n    [PreservesLimitsOfShape WalkingCospan (forget C)] : Function.Injective f :=\n  (mono_iff_injective ((forget C).map f)).mp inferInstance\n\n"}
{"name":"CategoryTheory.ConcreteCategory.mono_iff_injective_of_preservesPullback","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.HasForget C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan (CategoryTheory.forget C)\n⊢ Iff (CategoryTheory.Mono f) (Function.Injective ⇑f)","decl":"theorem mono_iff_injective_of_preservesPullback {X Y : C} (f : X ⟶ Y)\n    [PreservesLimitsOfShape WalkingCospan (forget C)] : Mono f ↔ Function.Injective f :=\n  ((forget C).mono_map_iff_mono _).symm.trans (mono_iff_injective _)\n\n"}
{"name":"CategoryTheory.ConcreteCategory.epi_of_surjective","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.HasForget C\nX Y : C\nf : Quiver.Hom X Y\ns : Function.Surjective ⇑f\n⊢ CategoryTheory.Epi f","decl":"/-- In any concrete category, surjective morphisms are epimorphisms. -/\ntheorem epi_of_surjective {X Y : C} (f : X ⟶ Y) (s : Function.Surjective f) :\n    Epi f :=\n  (forget C).epi_of_epi_map ((epi_iff_surjective ((forget C).map f)).2 s)\n\n"}
{"name":"CategoryTheory.ConcreteCategory.surjective_of_epi_of_preservesPushout","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Epi f\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingSpan (CategoryTheory.forget C)\n⊢ Function.Surjective ⇑f","decl":"theorem surjective_of_epi_of_preservesPushout {X Y : C} (f : X ⟶ Y) [Epi f]\n    [PreservesColimitsOfShape WalkingSpan (forget C)] : Function.Surjective f :=\n  (epi_iff_surjective ((forget C).map f)).mp inferInstance\n\n"}
{"name":"CategoryTheory.ConcreteCategory.epi_iff_surjective_of_preservesPushout","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.HasForget C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingSpan (CategoryTheory.forget C)\n⊢ Iff (CategoryTheory.Epi f) (Function.Surjective ⇑f)","decl":"theorem epi_iff_surjective_of_preservesPushout {X Y : C} (f : X ⟶ Y)\n    [PreservesColimitsOfShape WalkingSpan (forget C)] : Epi f ↔ Function.Surjective f :=\n  ((forget C).epi_map_iff_epi _).symm.trans (epi_iff_surjective _)\n\n"}
{"name":"CategoryTheory.ConcreteCategory.bijective_of_isIso","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.HasForget C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ Function.Bijective ((CategoryTheory.forget C).map f)","decl":"theorem bijective_of_isIso {X Y : C} (f : X ⟶ Y) [IsIso f] :\n    Function.Bijective ((forget C).map f) := by\n  rw [← isIso_iff_bijective]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ConcreteCategory.isIso_iff_bijective","module":"Mathlib.CategoryTheory.ConcreteCategory.EpiMono","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.HasForget C\ninst✝ : (CategoryTheory.forget C).ReflectsIsomorphisms\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.IsIso f) (Function.Bijective ((CategoryTheory.forget C).map f))","decl":"/-- If the forgetful functor of a concrete category reflects isomorphisms, being an isomorphism\nis equivalent to being bijective. -/\ntheorem isIso_iff_bijective [(forget C).ReflectsIsomorphisms]\n    {X Y : C} (f : X ⟶ Y) : IsIso f ↔ Function.Bijective ((forget C).map f) := by\n  rw [← CategoryTheory.isIso_iff_bijective]\n  exact ⟨fun _ ↦ inferInstance, fun _ ↦ isIso_of_reflects_iso f (forget C)⟩\n\n"}
