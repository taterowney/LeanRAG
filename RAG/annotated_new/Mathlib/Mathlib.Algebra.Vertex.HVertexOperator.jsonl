{"name":"HVertexOperator.ext_iff","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_1\ninst✝⁵ : PartialOrder Γ\nR : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA B : HVertexOperator Γ R V W\n⊢ Iff (Eq A B) (∀ (v : V), Eq (A v) (B v))","decl":"@[ext]\ntheorem ext (A B : HVertexOperator Γ R V W) (h : ∀ v : V, A v = B v) :\n    A = B := LinearMap.ext h\n\n"}
{"name":"HVertexOperator.ext","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_1\ninst✝⁵ : PartialOrder Γ\nR : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA B : HVertexOperator Γ R V W\nh : ∀ (v : V), Eq (A v) (B v)\n⊢ Eq A B","decl":"@[ext]\ntheorem ext (A B : HVertexOperator Γ R V W) (h : ∀ v : V, A v = B v) :\n    A = B := LinearMap.ext h\n\n"}
{"name":"HVertexOperator.coeff_apply","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_1\ninst✝⁵ : PartialOrder Γ\nR : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA : HVertexOperator Γ R V W\nn : Γ\nv : V\n⊢ Eq ((A.coeff n) v) (((HahnModule.of R).symm (A v)).coeff n)","decl":"/-- The coefficient of a heterogeneous vertex operator, viewed as a formal power series with\ncoefficients in linear maps. -/\n@[simps]\ndef coeff (A : HVertexOperator Γ R V W) (n : Γ) : V →ₗ[R] W where\n  toFun v := ((of R).symm (A v)).coeff n\n  map_add' _ _ := by simp\n  map_smul' _ _ := by\n    simp only [map_smul, RingHom.id_apply, of_symm_smul, HahnSeries.coeff_smul]\n\n"}
{"name":"HVertexOperator.coeff_isPWOsupport","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_1\ninst✝⁵ : PartialOrder Γ\nR : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA : HVertexOperator Γ R V W\nv : V\n⊢ (Function.support ((HahnModule.of R).symm (A v)).coeff).IsPWO","decl":"theorem coeff_isPWOsupport (A : HVertexOperator Γ R V W) (v : V) :\n    ((of R).symm (A v)).coeff.support.IsPWO :=\n  ((of R).symm (A v)).isPWO_support'\n\n"}
{"name":"HVertexOperator.coeff_inj","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_1\ninst✝⁵ : PartialOrder Γ\nR : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\n⊢ Function.Injective HVertexOperator.coeff","decl":"@[ext]\ntheorem coeff_inj : Function.Injective (coeff : HVertexOperator Γ R V W → Γ → (V →ₗ[R] W)) := by\n  intro _ _ h\n  ext v n\n  exact congrFun (congrArg DFunLike.coe (congrFun h n)) v\n\n"}
{"name":"HVertexOperator.coeff_inj_iff","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_1\ninst✝⁵ : PartialOrder Γ\nR : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\na₁ a₂ : HVertexOperator Γ R V W\n⊢ Iff (Eq a₁ a₂) (Eq a₁.coeff a₂.coeff)","decl":"@[ext]\ntheorem coeff_inj : Function.Injective (coeff : HVertexOperator Γ R V W → Γ → (V →ₗ[R] W)) := by\n  intro _ _ h\n  ext v n\n  exact congrFun (congrArg DFunLike.coe (congrFun h n)) v\n\n"}
{"name":"HVertexOperator.of_coeff_apply","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_1\ninst✝⁵ : PartialOrder Γ\nR : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nf : Γ → LinearMap (RingHom.id R) V W\nhf : ∀ (x : V), (Function.support fun x_1 => (f x_1) x).IsPWO\nx : V\n⊢ Eq ((HVertexOperator.of_coeff f hf) x) ((HahnModule.of R) { coeff := fun g => (f g) x, isPWO_support' := ⋯ })","decl":"/-- Given a coefficient function valued in linear maps satisfying a partially well-ordered support\ncondition, we produce a heterogeneous vertex operator. -/\n@[simps]\ndef of_coeff (f : Γ → V →ₗ[R] W)\n    (hf : ∀(x : V), (Function.support (f · x)).IsPWO) : HVertexOperator Γ R V W where\n  toFun x := (of R) { coeff := fun g => f g x, isPWO_support' := hf x }\n  map_add' _ _ := by ext; simp\n  map_smul' _ _ := by ext; simp\n\n"}
{"name":"HVertexOperator.coeff_add","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_1\ninst✝⁵ : PartialOrder Γ\nR : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA B : HVertexOperator Γ R V W\n⊢ Eq (HAdd.hAdd A B).coeff (HAdd.hAdd A.coeff B.coeff)","decl":"@[simp]\ntheorem coeff_add (A B : HVertexOperator Γ R V W) : (A + B).coeff = A.coeff + B.coeff := by\n  ext\n  simp\n\n"}
{"name":"HVertexOperator.add_coeff","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_1\ninst✝⁵ : PartialOrder Γ\nR : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA B : HVertexOperator Γ R V W\n⊢ Eq (HAdd.hAdd A B).coeff (HAdd.hAdd A.coeff B.coeff)","decl":"@[deprecated (since := \"2025-01-31\")] alias add_coeff := coeff_add\n\n"}
{"name":"HVertexOperator.coeff_smul","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_1\ninst✝⁵ : PartialOrder Γ\nR : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA : HVertexOperator Γ R V W\nr : R\n⊢ Eq (HSMul.hSMul r A).coeff (HSMul.hSMul r A.coeff)","decl":"@[simp]\ntheorem coeff_smul (A : HVertexOperator Γ R V W) (r : R) : (r • A).coeff = r • (A.coeff) := by\n  ext\n  simp\n\n"}
{"name":"HVertexOperator.smul_coeff","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_1\ninst✝⁵ : PartialOrder Γ\nR : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA : HVertexOperator Γ R V W\nr : R\n⊢ Eq (HSMul.hSMul r A).coeff (HSMul.hSMul r A.coeff)","decl":"@[deprecated (since := \"2025-01-31\")] alias smul_coeff := coeff_smul\n\n"}
{"name":"HVertexOperator.compHahnSeries_coeff","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_5\nΓ' : Type u_6\ninst✝⁸ : OrderedCancelAddCommMonoid Γ\ninst✝⁷ : OrderedCancelAddCommMonoid Γ'\nR : Type u_7\ninst✝⁶ : CommRing R\nU : Type u_8\nV : Type u_9\nW : Type u_10\ninst✝⁵ : AddCommGroup U\ninst✝⁴ : Module R U\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA : HVertexOperator Γ R V W\nB : HVertexOperator Γ' R U V\nu : U\ng' : Γ'\n⊢ Eq ((A.compHahnSeries B u).coeff g') (A ((B.coeff g') u))","decl":"/-- The composite of two heterogeneous vertex operators acting on a vector, as an iterated Hahn\nseries. -/\n@[simps]\ndef compHahnSeries (u : U) : HahnSeries Γ' (HahnSeries Γ W) where\n  coeff g' := A (coeff B g' u)\n  isPWO_support' := by\n    refine Set.IsPWO.mono (((of R).symm (B u)).isPWO_support') ?_\n    simp_all only [coeff_apply, Function.support_subset_iff, ne_eq, Function.mem_support]\n    intro g' hg' hAB\n    apply hg'\n    simp_rw [hAB]\n    simp_all only [map_zero, HahnSeries.coeff_zero, not_true_eq_false]\n\n"}
{"name":"HVertexOperator.compHahnSeries_add","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_5\nΓ' : Type u_6\ninst✝⁸ : OrderedCancelAddCommMonoid Γ\ninst✝⁷ : OrderedCancelAddCommMonoid Γ'\nR : Type u_7\ninst✝⁶ : CommRing R\nU : Type u_8\nV : Type u_9\nW : Type u_10\ninst✝⁵ : AddCommGroup U\ninst✝⁴ : Module R U\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA : HVertexOperator Γ R V W\nB : HVertexOperator Γ' R U V\nu v : U\n⊢ Eq (A.compHahnSeries B (HAdd.hAdd u v)) (HAdd.hAdd (A.compHahnSeries B u) (A.compHahnSeries B v))","decl":"@[simp]\ntheorem compHahnSeries_add (u v : U) :\n    compHahnSeries A B (u + v) = compHahnSeries A B u + compHahnSeries A B v := by\n  ext\n  simp only [compHahnSeries_coeff, map_add, coeff_apply, HahnSeries.coeff_add', Pi.add_apply]\n  rw [← HahnSeries.coeff_add]\n\n"}
{"name":"HVertexOperator.compHahnSeries_smul","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_5\nΓ' : Type u_6\ninst✝⁸ : OrderedCancelAddCommMonoid Γ\ninst✝⁷ : OrderedCancelAddCommMonoid Γ'\nR : Type u_7\ninst✝⁶ : CommRing R\nU : Type u_8\nV : Type u_9\nW : Type u_10\ninst✝⁵ : AddCommGroup U\ninst✝⁴ : Module R U\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA : HVertexOperator Γ R V W\nB : HVertexOperator Γ' R U V\nr : R\nu : U\n⊢ Eq (A.compHahnSeries B (HSMul.hSMul r u)) (HSMul.hSMul r (A.compHahnSeries B u))","decl":"@[simp]\ntheorem compHahnSeries_smul (r : R) (u : U) :\n    compHahnSeries A B (r • u) = r • compHahnSeries A B u := by\n  ext\n  simp only [compHahnSeries_coeff, LinearMapClass.map_smul, coeff_apply, HahnSeries.coeff_smul]\n  rw [← HahnSeries.coeff_smul]\n\n"}
{"name":"HVertexOperator.comp_apply","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_5\nΓ' : Type u_6\ninst✝⁸ : OrderedCancelAddCommMonoid Γ\ninst✝⁷ : OrderedCancelAddCommMonoid Γ'\nR : Type u_7\ninst✝⁶ : CommRing R\nU : Type u_8\nV : Type u_9\nW : Type u_10\ninst✝⁵ : AddCommGroup U\ninst✝⁴ : Module R U\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA : HVertexOperator Γ R V W\nB : HVertexOperator Γ' R U V\nu : U\n⊢ Eq ((A.comp B) u) ((HahnModule.of R) (A.compHahnSeries B u).ofIterate)","decl":"/-- The composite of two heterogeneous vertex operators, as a heterogeneous vertex operator. -/\n@[simps]\ndef comp : HVertexOperator (Γ' ×ₗ Γ) R U W where\n  toFun u := HahnModule.of R (HahnSeries.ofIterate (compHahnSeries A B u))\n  map_add' := by\n    intro u v\n    ext g\n    simp only [HahnSeries.ofIterate, compHahnSeries_add, Equiv.symm_apply_apply,\n      HahnModule.of_symm_add, HahnSeries.coeff_add', Pi.add_apply]\n  map_smul' := by\n    intro r x\n    ext g\n    simp only [HahnSeries.ofIterate, compHahnSeries_smul, HahnSeries.coeff_smul,\n      compHahnSeries_coeff, coeff_apply, Equiv.symm_apply_apply, RingHom.id_apply, of_symm_smul]\n\n"}
{"name":"HVertexOperator.coeff_comp","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_5\nΓ' : Type u_6\ninst✝⁸ : OrderedCancelAddCommMonoid Γ\ninst✝⁷ : OrderedCancelAddCommMonoid Γ'\nR : Type u_7\ninst✝⁶ : CommRing R\nU : Type u_8\nV : Type u_9\nW : Type u_10\ninst✝⁵ : AddCommGroup U\ninst✝⁴ : Module R U\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA : HVertexOperator Γ R V W\nB : HVertexOperator Γ' R U V\ng : Lex (Prod Γ' Γ)\n⊢ Eq ((A.comp B).coeff g) ((A.coeff (ofLex g).2).comp (B.coeff (ofLex g).1))","decl":"@[simp]\ntheorem coeff_comp (g : Γ' ×ₗ Γ) :\n    (comp A B).coeff g = A.coeff (ofLex g).2 ∘ₗ B.coeff (ofLex g).1 := by\n  rfl\n\n"}
{"name":"HVertexOperator.comp_coeff","module":"Mathlib.Algebra.Vertex.HVertexOperator","initialProofState":"Γ : Type u_5\nΓ' : Type u_6\ninst✝⁸ : OrderedCancelAddCommMonoid Γ\ninst✝⁷ : OrderedCancelAddCommMonoid Γ'\nR : Type u_7\ninst✝⁶ : CommRing R\nU : Type u_8\nV : Type u_9\nW : Type u_10\ninst✝⁵ : AddCommGroup U\ninst✝⁴ : Module R U\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : AddCommGroup W\ninst✝ : Module R W\nA : HVertexOperator Γ R V W\nB : HVertexOperator Γ' R U V\ng : Lex (Prod Γ' Γ)\n⊢ Eq ((A.comp B).coeff g) ((A.coeff (ofLex g).2).comp (B.coeff (ofLex g).1))","decl":"@[deprecated (since := \"2025-01-31\")] alias comp_coeff := coeff_comp\n\n"}
