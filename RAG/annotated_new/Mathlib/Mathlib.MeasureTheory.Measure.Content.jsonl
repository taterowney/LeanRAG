{"name":"MeasureTheory.Content.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝¹ : TopologicalSpace G\ninst✝ : SizeOf G\ntoFun : TopologicalSpace.Compacts G → NNReal\nmono' : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), HasSubset.Subset ↑K₁ ↑K₂ → LE.le (toFun K₁) (toFun K₂)\nsup_disjoint' : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), Disjoint ↑K₁ ↑K₂ → IsClosed ↑K₁ → IsClosed ↑K₂ → Eq (toFun (Max.max K₁ K₂)) (HAdd.hAdd (toFun K₁) (toFun K₂))\nsup_le' : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), LE.le (toFun (Max.max K₁ K₂)) (HAdd.hAdd (toFun K₁) (toFun K₂))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, mono' := mono', sup_disjoint' := sup_disjoint', sup_le' := sup_le' }) 1","decl":"/-- A content is an additive function on compact sets taking values in `ℝ≥0`. It is a device\nfrom which one can define a measure. -/\nstructure Content (G : Type w) [TopologicalSpace G] where\n  toFun : Compacts G → ℝ≥0\n  mono' : ∀ K₁ K₂ : Compacts G, (K₁ : Set G) ⊆ K₂ → toFun K₁ ≤ toFun K₂\n  sup_disjoint' :\n    ∀ K₁ K₂ : Compacts G, Disjoint (K₁ : Set G) K₂ → IsClosed (K₁ : Set G) → IsClosed (K₂ : Set G)\n      → toFun (K₁ ⊔ K₂) = toFun K₁ + toFun K₂\n  sup_le' : ∀ K₁ K₂ : Compacts G, toFun (K₁ ⊔ K₂) ≤ toFun K₁ + toFun K₂\n\n"}
{"name":"MeasureTheory.Content.mk.inj","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\ntoFun✝ : TopologicalSpace.Compacts G → NNReal\nmono'✝ : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), HasSubset.Subset ↑K₁ ↑K₂ → LE.le (toFun✝ K₁) (toFun✝ K₂)\nsup_disjoint'✝ : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), Disjoint ↑K₁ ↑K₂ → IsClosed ↑K₁ → IsClosed ↑K₂ → Eq (toFun✝ (Max.max K₁ K₂)) (HAdd.hAdd (toFun✝ K₁) (toFun✝ K₂))\nsup_le'✝ : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), LE.le (toFun✝ (Max.max K₁ K₂)) (HAdd.hAdd (toFun✝ K₁) (toFun✝ K₂))\ntoFun : TopologicalSpace.Compacts G → NNReal\nmono' : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), HasSubset.Subset ↑K₁ ↑K₂ → LE.le (toFun K₁) (toFun K₂)\nsup_disjoint' : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), Disjoint ↑K₁ ↑K₂ → IsClosed ↑K₁ → IsClosed ↑K₂ → Eq (toFun (Max.max K₁ K₂)) (HAdd.hAdd (toFun K₁) (toFun K₂))\nsup_le' : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), LE.le (toFun (Max.max K₁ K₂)) (HAdd.hAdd (toFun K₁) (toFun K₂))\nx✝ : Eq { toFun := toFun✝, mono' := mono'✝, sup_disjoint' := sup_disjoint'✝, sup_le' := sup_le'✝ } { toFun := toFun, mono' := mono', sup_disjoint' := sup_disjoint', sup_le' := sup_le' }\n⊢ Eq toFun✝ toFun","decl":"/-- A content is an additive function on compact sets taking values in `ℝ≥0`. It is a device\nfrom which one can define a measure. -/\nstructure Content (G : Type w) [TopologicalSpace G] where\n  toFun : Compacts G → ℝ≥0\n  mono' : ∀ K₁ K₂ : Compacts G, (K₁ : Set G) ⊆ K₂ → toFun K₁ ≤ toFun K₂\n  sup_disjoint' :\n    ∀ K₁ K₂ : Compacts G, Disjoint (K₁ : Set G) K₂ → IsClosed (K₁ : Set G) → IsClosed (K₂ : Set G)\n      → toFun (K₁ ⊔ K₂) = toFun K₁ + toFun K₂\n  sup_le' : ∀ K₁ K₂ : Compacts G, toFun (K₁ ⊔ K₂) ≤ toFun K₁ + toFun K₂\n\n"}
{"name":"MeasureTheory.Content.mk.injEq","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\ntoFun✝ : TopologicalSpace.Compacts G → NNReal\nmono'✝ : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), HasSubset.Subset ↑K₁ ↑K₂ → LE.le (toFun✝ K₁) (toFun✝ K₂)\nsup_disjoint'✝ : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), Disjoint ↑K₁ ↑K₂ → IsClosed ↑K₁ → IsClosed ↑K₂ → Eq (toFun✝ (Max.max K₁ K₂)) (HAdd.hAdd (toFun✝ K₁) (toFun✝ K₂))\nsup_le'✝ : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), LE.le (toFun✝ (Max.max K₁ K₂)) (HAdd.hAdd (toFun✝ K₁) (toFun✝ K₂))\ntoFun : TopologicalSpace.Compacts G → NNReal\nmono' : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), HasSubset.Subset ↑K₁ ↑K₂ → LE.le (toFun K₁) (toFun K₂)\nsup_disjoint' : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), Disjoint ↑K₁ ↑K₂ → IsClosed ↑K₁ → IsClosed ↑K₂ → Eq (toFun (Max.max K₁ K₂)) (HAdd.hAdd (toFun K₁) (toFun K₂))\nsup_le' : ∀ (K₁ K₂ : TopologicalSpace.Compacts G), LE.le (toFun (Max.max K₁ K₂)) (HAdd.hAdd (toFun K₁) (toFun K₂))\n⊢ Eq (Eq { toFun := toFun✝, mono' := mono'✝, sup_disjoint' := sup_disjoint'✝, sup_le' := sup_le'✝ } { toFun := toFun, mono' := mono', sup_disjoint' := sup_disjoint', sup_le' := sup_le' }) (Eq toFun✝ toFun)","decl":"/-- A content is an additive function on compact sets taking values in `ℝ≥0`. It is a device\nfrom which one can define a measure. -/\nstructure Content (G : Type w) [TopologicalSpace G] where\n  toFun : Compacts G → ℝ≥0\n  mono' : ∀ K₁ K₂ : Compacts G, (K₁ : Set G) ⊆ K₂ → toFun K₁ ≤ toFun K₂\n  sup_disjoint' :\n    ∀ K₁ K₂ : Compacts G, Disjoint (K₁ : Set G) K₂ → IsClosed (K₁ : Set G) → IsClosed (K₂ : Set G)\n      → toFun (K₁ ⊔ K₂) = toFun K₁ + toFun K₂\n  sup_le' : ∀ K₁ K₂ : Compacts G, toFun (K₁ ⊔ K₂) ≤ toFun K₁ + toFun K₂\n\n"}
{"name":"MeasureTheory.Content.sup_le'","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nself : MeasureTheory.Content G\nK₁ K₂ : TopologicalSpace.Compacts G\n⊢ LE.le (self.toFun (Max.max K₁ K₂)) (HAdd.hAdd (self.toFun K₁) (self.toFun K₂))","decl":"/-- A content is an additive function on compact sets taking values in `ℝ≥0`. It is a device\nfrom which one can define a measure. -/\nstructure Content (G : Type w) [TopologicalSpace G] where\n  toFun : Compacts G → ℝ≥0\n  mono' : ∀ K₁ K₂ : Compacts G, (K₁ : Set G) ⊆ K₂ → toFun K₁ ≤ toFun K₂\n  sup_disjoint' :\n    ∀ K₁ K₂ : Compacts G, Disjoint (K₁ : Set G) K₂ → IsClosed (K₁ : Set G) → IsClosed (K₂ : Set G)\n      → toFun (K₁ ⊔ K₂) = toFun K₁ + toFun K₂\n  sup_le' : ∀ K₁ K₂ : Compacts G, toFun (K₁ ⊔ K₂) ≤ toFun K₁ + toFun K₂\n\n"}
{"name":"MeasureTheory.Content.mono'","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nself : MeasureTheory.Content G\nK₁ K₂ : TopologicalSpace.Compacts G\na✝ : HasSubset.Subset ↑K₁ ↑K₂\n⊢ LE.le (self.toFun K₁) (self.toFun K₂)","decl":"/-- A content is an additive function on compact sets taking values in `ℝ≥0`. It is a device\nfrom which one can define a measure. -/\nstructure Content (G : Type w) [TopologicalSpace G] where\n  toFun : Compacts G → ℝ≥0\n  mono' : ∀ K₁ K₂ : Compacts G, (K₁ : Set G) ⊆ K₂ → toFun K₁ ≤ toFun K₂\n  sup_disjoint' :\n    ∀ K₁ K₂ : Compacts G, Disjoint (K₁ : Set G) K₂ → IsClosed (K₁ : Set G) → IsClosed (K₂ : Set G)\n      → toFun (K₁ ⊔ K₂) = toFun K₁ + toFun K₂\n  sup_le' : ∀ K₁ K₂ : Compacts G, toFun (K₁ ⊔ K₂) ≤ toFun K₁ + toFun K₂\n\n"}
{"name":"MeasureTheory.Content.sup_disjoint'","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nself : MeasureTheory.Content G\nK₁ K₂ : TopologicalSpace.Compacts G\na✝² : Disjoint ↑K₁ ↑K₂\na✝¹ : IsClosed ↑K₁\na✝ : IsClosed ↑K₂\n⊢ Eq (self.toFun (Max.max K₁ K₂)) (HAdd.hAdd (self.toFun K₁) (self.toFun K₂))","decl":"/-- A content is an additive function on compact sets taking values in `ℝ≥0`. It is a device\nfrom which one can define a measure. -/\nstructure Content (G : Type w) [TopologicalSpace G] where\n  toFun : Compacts G → ℝ≥0\n  mono' : ∀ K₁ K₂ : Compacts G, (K₁ : Set G) ⊆ K₂ → toFun K₁ ≤ toFun K₂\n  sup_disjoint' :\n    ∀ K₁ K₂ : Compacts G, Disjoint (K₁ : Set G) K₂ → IsClosed (K₁ : Set G) → IsClosed (K₂ : Set G)\n      → toFun (K₁ ⊔ K₂) = toFun K₁ + toFun K₂\n  sup_le' : ∀ K₁ K₂ : Compacts G, toFun (K₁ ⊔ K₂) ≤ toFun K₁ + toFun K₂\n\n"}
{"name":"MeasureTheory.Content.apply_eq_coe_toFun","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\nK : TopologicalSpace.Compacts G\n⊢ Eq ((fun s => ↑(μ.toFun s)) K) ↑(μ.toFun K)","decl":"theorem apply_eq_coe_toFun (K : Compacts G) : μ K = μ.toFun K :=\n  rfl\n\n"}
{"name":"MeasureTheory.Content.mono","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\nK₁ K₂ : TopologicalSpace.Compacts G\nh : HasSubset.Subset ↑K₁ ↑K₂\n⊢ LE.le ((fun s => ↑(μ.toFun s)) K₁) ((fun s => ↑(μ.toFun s)) K₂)","decl":"theorem mono (K₁ K₂ : Compacts G) (h : (K₁ : Set G) ⊆ K₂) : μ K₁ ≤ μ K₂ := by\n  simp [apply_eq_coe_toFun, μ.mono' _ _ h]\n\n"}
{"name":"MeasureTheory.Content.sup_disjoint","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\nK₁ K₂ : TopologicalSpace.Compacts G\nh : Disjoint ↑K₁ ↑K₂\nh₁ : IsClosed ↑K₁\nh₂ : IsClosed ↑K₂\n⊢ Eq ((fun s => ↑(μ.toFun s)) (Max.max K₁ K₂)) (HAdd.hAdd ((fun s => ↑(μ.toFun s)) K₁) ((fun s => ↑(μ.toFun s)) K₂))","decl":"theorem sup_disjoint (K₁ K₂ : Compacts G) (h : Disjoint (K₁ : Set G) K₂)\n    (h₁ : IsClosed (K₁ : Set G)) (h₂ : IsClosed (K₂ : Set G)) :\n    μ (K₁ ⊔ K₂) = μ K₁ + μ K₂ := by\n  simp [apply_eq_coe_toFun, μ.sup_disjoint' _ _ h]\n\n"}
{"name":"MeasureTheory.Content.sup_le","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\nK₁ K₂ : TopologicalSpace.Compacts G\n⊢ LE.le ((fun s => ↑(μ.toFun s)) (Max.max K₁ K₂)) (HAdd.hAdd ((fun s => ↑(μ.toFun s)) K₁) ((fun s => ↑(μ.toFun s)) K₂))","decl":"theorem sup_le (K₁ K₂ : Compacts G) : μ (K₁ ⊔ K₂) ≤ μ K₁ + μ K₂ := by\n  simp only [apply_eq_coe_toFun]\n  norm_cast\n  exact μ.sup_le' _ _\n\n"}
{"name":"MeasureTheory.Content.lt_top","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\nK : TopologicalSpace.Compacts G\n⊢ LT.lt ((fun s => ↑(μ.toFun s)) K) Top.top","decl":"theorem lt_top (K : Compacts G) : μ K < ∞ :=\n  ENNReal.coe_lt_top\n\n"}
{"name":"MeasureTheory.Content.empty","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\n⊢ Eq ((fun s => ↑(μ.toFun s)) Bot.bot) 0","decl":"theorem empty : μ ⊥ = 0 := by\n  have := μ.sup_disjoint' ⊥ ⊥\n  simpa [apply_eq_coe_toFun] using this\n\n"}
{"name":"MeasureTheory.Content.le_innerContent","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\nK : TopologicalSpace.Compacts G\nU : TopologicalSpace.Opens G\nh2 : HasSubset.Subset ↑K ↑U\n⊢ LE.le ((fun s => ↑(μ.toFun s)) K) (μ.innerContent U)","decl":"theorem le_innerContent (K : Compacts G) (U : Opens G) (h2 : (K : Set G) ⊆ U) :\n    μ K ≤ μ.innerContent U :=\n  le_iSup_of_le K <| le_iSup (fun _ ↦ (μ.toFun K : ℝ≥0∞)) h2\n\n"}
{"name":"MeasureTheory.Content.innerContent_le","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\nU : TopologicalSpace.Opens G\nK : TopologicalSpace.Compacts G\nh2 : HasSubset.Subset ↑U ↑K\n⊢ LE.le (μ.innerContent U) ((fun s => ↑(μ.toFun s)) K)","decl":"theorem innerContent_le (U : Opens G) (K : Compacts G) (h2 : (U : Set G) ⊆ K) :\n    μ.innerContent U ≤ μ K :=\n  iSup₂_le fun _ hK' => μ.mono _ _ (Subset.trans hK' h2)\n\n"}
{"name":"MeasureTheory.Content.innerContent_of_isCompact","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\nK : Set G\nh1K : IsCompact K\nh2K : IsOpen K\n⊢ Eq (μ.innerContent { carrier := K, is_open' := h2K }) ((fun s => ↑(μ.toFun s)) { carrier := K, isCompact' := h1K })","decl":"theorem innerContent_of_isCompact {K : Set G} (h1K : IsCompact K) (h2K : IsOpen K) :\n    μ.innerContent ⟨K, h2K⟩ = μ ⟨K, h1K⟩ :=\n  le_antisymm (iSup₂_le fun _ hK' => μ.mono _ ⟨K, h1K⟩ hK') (μ.le_innerContent _ _ Subset.rfl)\n\n"}
{"name":"MeasureTheory.Content.innerContent_bot","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\n⊢ Eq (μ.innerContent Bot.bot) 0","decl":"theorem innerContent_bot : μ.innerContent ⊥ = 0 := by\n  refine le_antisymm ?_ (zero_le _)\n  rw [← μ.empty]\n  refine iSup₂_le fun K hK => ?_\n  have : K = ⊥ := by\n    ext1\n    rw [subset_empty_iff.mp hK, Compacts.coe_bot]\n  rw [this]\n\n"}
{"name":"MeasureTheory.Content.innerContent_mono","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\nU V : Set G\nhU : IsOpen U\nhV : IsOpen V\nh2 : HasSubset.Subset U V\n⊢ LE.le (μ.innerContent { carrier := U, is_open' := hU }) (μ.innerContent { carrier := V, is_open' := hV })","decl":"/-- This is \"unbundled\", because that is required for the API of `inducedOuterMeasure`. -/\ntheorem innerContent_mono ⦃U V : Set G⦄ (hU : IsOpen U) (hV : IsOpen V) (h2 : U ⊆ V) :\n    μ.innerContent ⟨U, hU⟩ ≤ μ.innerContent ⟨V, hV⟩ :=\n  biSup_mono fun _ hK => hK.trans h2\n\n"}
{"name":"MeasureTheory.Content.innerContent_exists_compact","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\nU : TopologicalSpace.Opens G\nhU : Ne (μ.innerContent U) Top.top\nε : NNReal\nhε : Ne ε 0\n⊢ Exists fun K => And (HasSubset.Subset ↑K ↑U) (LE.le (μ.innerContent U) (HAdd.hAdd ((fun s => ↑(μ.toFun s)) K) ↑ε))","decl":"theorem innerContent_exists_compact {U : Opens G} (hU : μ.innerContent U ≠ ∞) {ε : ℝ≥0}\n    (hε : ε ≠ 0) : ∃ K : Compacts G, (K : Set G) ⊆ U ∧ μ.innerContent U ≤ μ K + ε := by\n  have h'ε := ENNReal.coe_ne_zero.2 hε\n  rcases le_or_lt (μ.innerContent U) ε with h | h\n  · exact ⟨⊥, empty_subset _, le_add_left h⟩\n  have h₂ := ENNReal.sub_lt_self hU h.ne_bot h'ε\n  conv at h₂ => rhs; rw [innerContent]\n  simp only [lt_iSup_iff] at h₂\n  rcases h₂ with ⟨U, h1U, h2U⟩; refine ⟨U, h1U, ?_⟩\n  rw [← tsub_le_iff_right]; exact le_of_lt h2U\n\n"}
{"name":"MeasureTheory.Content.innerContent_iSup_nat","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝ : R1Space G\nU : Nat → TopologicalSpace.Opens G\n⊢ LE.le (μ.innerContent (iSup fun i => U i)) (tsum fun i => μ.innerContent (U i))","decl":"/-- The inner content of a supremum of opens is at most the sum of the individual inner contents. -/\ntheorem innerContent_iSup_nat [R1Space G] (U : ℕ → Opens G) :\n    μ.innerContent (⨆ i : ℕ, U i) ≤ ∑' i : ℕ, μ.innerContent (U i) := by\n  have h3 : ∀ (t : Finset ℕ) (K : ℕ → Compacts G), μ (t.sup K) ≤ t.sum fun i => μ (K i) := by\n    intro t K\n    refine Finset.induction_on t ?_ ?_\n    · simp only [μ.empty, nonpos_iff_eq_zero, Finset.sum_empty, Finset.sup_empty]\n    · intro n s hn ih\n      rw [Finset.sup_insert, Finset.sum_insert hn]\n      exact le_trans (μ.sup_le _ _) (add_le_add_left ih _)\n  refine iSup₂_le fun K hK => ?_\n  obtain ⟨t, ht⟩ :=\n    K.isCompact.elim_finite_subcover _ (fun i => (U i).isOpen) (by rwa [← Opens.coe_iSup])\n  rcases K.isCompact.finite_compact_cover t (SetLike.coe ∘ U) (fun i _ => (U i).isOpen) ht with\n    ⟨K', h1K', h2K', h3K'⟩\n  let L : ℕ → Compacts G := fun n => ⟨K' n, h1K' n⟩\n  convert le_trans (h3 t L) _\n  · ext1\n    rw [Compacts.coe_finset_sup, Finset.sup_eq_iSup]\n    exact h3K'\n  refine le_trans (Finset.sum_le_sum ?_) (ENNReal.sum_le_tsum t)\n  intro i _\n  refine le_trans ?_ (le_iSup _ (L i))\n  refine le_trans ?_ (le_iSup _ (h2K' i))\n  rfl\n\n"}
{"name":"MeasureTheory.Content.innerContent_iUnion_nat","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝ : R1Space G\nU : Nat → Set G\nhU : ∀ (i : Nat), IsOpen (U i)\n⊢ LE.le (μ.innerContent { carrier := Set.iUnion fun i => U i, is_open' := ⋯ }) (tsum fun i => μ.innerContent { carrier := U i, is_open' := ⋯ })","decl":"/-- The inner content of a union of sets is at most the sum of the individual inner contents.\n  This is the \"unbundled\" version of `innerContent_iSup_nat`.\n  It is required for the API of `inducedOuterMeasure`. -/\ntheorem innerContent_iUnion_nat [R1Space G] ⦃U : ℕ → Set G⦄\n    (hU : ∀ i : ℕ, IsOpen (U i)) :\n    μ.innerContent ⟨⋃ i : ℕ, U i, isOpen_iUnion hU⟩ ≤ ∑' i : ℕ, μ.innerContent ⟨U i, hU i⟩ := by\n  have := μ.innerContent_iSup_nat fun i => ⟨U i, hU i⟩\n  rwa [Opens.iSup_def] at this\n\n"}
{"name":"MeasureTheory.Content.innerContent_comap","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\nf : Homeomorph G G\nh : ∀ ⦃K : TopologicalSpace.Compacts G⦄, Eq ((fun s => ↑(μ.toFun s)) (TopologicalSpace.Compacts.map ⇑f ⋯ K)) ((fun s => ↑(μ.toFun s)) K)\nU : TopologicalSpace.Opens G\n⊢ Eq (μ.innerContent ((TopologicalSpace.Opens.comap ↑f) U)) (μ.innerContent U)","decl":"theorem innerContent_comap (f : G ≃ₜ G) (h : ∀ ⦃K : Compacts G⦄, μ (K.map f f.continuous) = μ K)\n    (U : Opens G) : μ.innerContent (Opens.comap f U) = μ.innerContent U := by\n  refine (Compacts.equiv f).surjective.iSup_congr _ fun K => iSup_congr_Prop image_subset_iff ?_\n  intro hK\n  simp only [Equiv.coe_fn_mk, Subtype.mk_eq_mk, Compacts.equiv]\n  apply h\n\n"}
{"name":"MeasureTheory.Content.is_mul_left_invariant_innerContent","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝² : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝¹ : Group G\ninst✝ : TopologicalGroup G\nh : ∀ (g : G) {K : TopologicalSpace.Compacts G}, Eq ((fun s => ↑(μ.toFun s)) (TopologicalSpace.Compacts.map (fun b => HMul.hMul g b) ⋯ K)) ((fun s => ↑(μ.toFun s)) K)\ng : G\nU : TopologicalSpace.Opens G\n⊢ Eq (μ.innerContent ((TopologicalSpace.Opens.comap ↑(Homeomorph.mulLeft g)) U)) (μ.innerContent U)","decl":"@[to_additive]\ntheorem is_mul_left_invariant_innerContent [Group G] [TopologicalGroup G]\n    (h : ∀ (g : G) {K : Compacts G}, μ (K.map _ <| continuous_mul_left g) = μ K) (g : G)\n    (U : Opens G) :\n    μ.innerContent (Opens.comap (Homeomorph.mulLeft g) U) = μ.innerContent U := by\n  convert μ.innerContent_comap (Homeomorph.mulLeft g) (fun K => h g) U\n\n"}
{"name":"MeasureTheory.Content.is_add_left_invariant_innerContent","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝² : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝¹ : AddGroup G\ninst✝ : TopologicalAddGroup G\nh : ∀ (g : G) {K : TopologicalSpace.Compacts G}, Eq ((fun s => ↑(μ.toFun s)) (TopologicalSpace.Compacts.map (fun b => HAdd.hAdd g b) ⋯ K)) ((fun s => ↑(μ.toFun s)) K)\ng : G\nU : TopologicalSpace.Opens G\n⊢ Eq (μ.innerContent ((TopologicalSpace.Opens.comap ↑(Homeomorph.addLeft g)) U)) (μ.innerContent U)","decl":"@[to_additive]\ntheorem is_mul_left_invariant_innerContent [Group G] [TopologicalGroup G]\n    (h : ∀ (g : G) {K : Compacts G}, μ (K.map _ <| continuous_mul_left g) = μ K) (g : G)\n    (U : Opens G) :\n    μ.innerContent (Opens.comap (Homeomorph.mulLeft g) U) = μ.innerContent U := by\n  convert μ.innerContent_comap (Homeomorph.mulLeft g) (fun K => h g) U\n\n"}
{"name":"MeasureTheory.Content.innerContent_pos_of_is_add_left_invariant","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝² : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝¹ : AddGroup G\ninst✝ : TopologicalAddGroup G\nh3 : ∀ (g : G) {K : TopologicalSpace.Compacts G}, Eq ((fun s => ↑(μ.toFun s)) (TopologicalSpace.Compacts.map (fun b => HAdd.hAdd g b) ⋯ K)) ((fun s => ↑(μ.toFun s)) K)\nK : TopologicalSpace.Compacts G\nhK : Ne ((fun s => ↑(μ.toFun s)) K) 0\nU : TopologicalSpace.Opens G\nhU : (↑U).Nonempty\n⊢ LT.lt 0 (μ.innerContent U)","decl":"@[to_additive]\ntheorem innerContent_pos_of_is_mul_left_invariant [Group G] [TopologicalGroup G]\n    (h3 : ∀ (g : G) {K : Compacts G}, μ (K.map _ <| continuous_mul_left g) = μ K) (K : Compacts G)\n    (hK : μ K ≠ 0) (U : Opens G) (hU : (U : Set G).Nonempty) : 0 < μ.innerContent U := by\n  have : (interior (U : Set G)).Nonempty := by rwa [U.isOpen.interior_eq]\n  rcases compact_covered_by_mul_left_translates K.2 this with ⟨s, hs⟩\n  suffices μ K ≤ s.card * μ.innerContent U by\n    exact (ENNReal.mul_pos_iff.mp <| hK.bot_lt.trans_le this).2\n  have : (K : Set G) ⊆ ↑(⨆ g ∈ s, Opens.comap (Homeomorph.mulLeft g : C(G, G)) U) := by\n    simpa only [Opens.iSup_def, Opens.coe_comap, Subtype.coe_mk]\n  refine (μ.le_innerContent _ _ this).trans ?_\n  refine\n    (rel_iSup_sum μ.innerContent μ.innerContent_bot (· ≤ ·) μ.innerContent_iSup_nat _ _).trans ?_\n  simp only [μ.is_mul_left_invariant_innerContent h3, Finset.sum_const, nsmul_eq_mul, le_refl]\n\n"}
{"name":"MeasureTheory.Content.innerContent_pos_of_is_mul_left_invariant","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝² : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝¹ : Group G\ninst✝ : TopologicalGroup G\nh3 : ∀ (g : G) {K : TopologicalSpace.Compacts G}, Eq ((fun s => ↑(μ.toFun s)) (TopologicalSpace.Compacts.map (fun b => HMul.hMul g b) ⋯ K)) ((fun s => ↑(μ.toFun s)) K)\nK : TopologicalSpace.Compacts G\nhK : Ne ((fun s => ↑(μ.toFun s)) K) 0\nU : TopologicalSpace.Opens G\nhU : (↑U).Nonempty\n⊢ LT.lt 0 (μ.innerContent U)","decl":"@[to_additive]\ntheorem innerContent_pos_of_is_mul_left_invariant [Group G] [TopologicalGroup G]\n    (h3 : ∀ (g : G) {K : Compacts G}, μ (K.map _ <| continuous_mul_left g) = μ K) (K : Compacts G)\n    (hK : μ K ≠ 0) (U : Opens G) (hU : (U : Set G).Nonempty) : 0 < μ.innerContent U := by\n  have : (interior (U : Set G)).Nonempty := by rwa [U.isOpen.interior_eq]\n  rcases compact_covered_by_mul_left_translates K.2 this with ⟨s, hs⟩\n  suffices μ K ≤ s.card * μ.innerContent U by\n    exact (ENNReal.mul_pos_iff.mp <| hK.bot_lt.trans_le this).2\n  have : (K : Set G) ⊆ ↑(⨆ g ∈ s, Opens.comap (Homeomorph.mulLeft g : C(G, G)) U) := by\n    simpa only [Opens.iSup_def, Opens.coe_comap, Subtype.coe_mk]\n  refine (μ.le_innerContent _ _ this).trans ?_\n  refine\n    (rel_iSup_sum μ.innerContent μ.innerContent_bot (· ≤ ·) μ.innerContent_iSup_nat _ _).trans ?_\n  simp only [μ.is_mul_left_invariant_innerContent h3, Finset.sum_const, nsmul_eq_mul, le_refl]\n\n"}
{"name":"MeasureTheory.Content.innerContent_mono'","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\nU V : Set G\nhU : IsOpen U\nhV : IsOpen V\nh2 : HasSubset.Subset U V\n⊢ LE.le (μ.innerContent { carrier := U, is_open' := hU }) (μ.innerContent { carrier := V, is_open' := hV })","decl":"theorem innerContent_mono' ⦃U V : Set G⦄ (hU : IsOpen U) (hV : IsOpen V) (h2 : U ⊆ V) :\n    μ.innerContent ⟨U, hU⟩ ≤ μ.innerContent ⟨V, hV⟩ :=\n  biSup_mono fun _ hK => hK.trans h2\n\n"}
{"name":"MeasureTheory.Content.outerMeasure_opens","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝ : R1Space G\nU : TopologicalSpace.Opens G\n⊢ Eq (μ.outerMeasure ↑U) (μ.innerContent U)","decl":"theorem outerMeasure_opens (U : Opens G) : μ.outerMeasure U = μ.innerContent U :=\n  inducedOuterMeasure_eq' (fun _ => isOpen_iUnion) μ.innerContent_iUnion_nat μ.innerContent_mono U.2\n\n"}
{"name":"MeasureTheory.Content.outerMeasure_of_isOpen","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝ : R1Space G\nU : Set G\nhU : IsOpen U\n⊢ Eq (μ.outerMeasure U) (μ.innerContent { carrier := U, is_open' := hU })","decl":"theorem outerMeasure_of_isOpen (U : Set G) (hU : IsOpen U) :\n    μ.outerMeasure U = μ.innerContent ⟨U, hU⟩ :=\n  μ.outerMeasure_opens ⟨U, hU⟩\n\n"}
{"name":"MeasureTheory.Content.outerMeasure_le","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝ : R1Space G\nU : TopologicalSpace.Opens G\nK : TopologicalSpace.Compacts G\nhUK : HasSubset.Subset ↑U ↑K\n⊢ LE.le (μ.outerMeasure ↑U) ((fun s => ↑(μ.toFun s)) K)","decl":"theorem outerMeasure_le (U : Opens G) (K : Compacts G) (hUK : (U : Set G) ⊆ K) :\n    μ.outerMeasure U ≤ μ K :=\n  (μ.outerMeasure_opens U).le.trans <| μ.innerContent_le U K hUK\n\n"}
{"name":"MeasureTheory.Content.le_outerMeasure_compacts","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝ : R1Space G\nK : TopologicalSpace.Compacts G\n⊢ LE.le ((fun s => ↑(μ.toFun s)) K) (μ.outerMeasure ↑K)","decl":"theorem le_outerMeasure_compacts (K : Compacts G) : μ K ≤ μ.outerMeasure K := by\n  rw [Content.outerMeasure, inducedOuterMeasure_eq_iInf]\n  · exact le_iInf fun U => le_iInf fun hU => le_iInf <| μ.le_innerContent K ⟨U, hU⟩\n  · exact fun U hU => isOpen_iUnion hU\n  · exact μ.innerContent_iUnion_nat\n  · exact μ.innerContent_mono\n\n"}
{"name":"MeasureTheory.Content.outerMeasure_eq_iInf","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝ : R1Space G\nA : Set G\n⊢ Eq (μ.outerMeasure A) (iInf fun U => iInf fun hU => iInf fun x => μ.innerContent { carrier := U, is_open' := hU })","decl":"theorem outerMeasure_eq_iInf (A : Set G) :\n    μ.outerMeasure A = ⨅ (U : Set G) (hU : IsOpen U) (_ : A ⊆ U), μ.innerContent ⟨U, hU⟩ :=\n  inducedOuterMeasure_eq_iInf _ μ.innerContent_iUnion_nat μ.innerContent_mono A\n\n"}
{"name":"MeasureTheory.Content.outerMeasure_interior_compacts","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝ : R1Space G\nK : TopologicalSpace.Compacts G\n⊢ LE.le (μ.outerMeasure (interior ↑K)) ((fun s => ↑(μ.toFun s)) K)","decl":"theorem outerMeasure_interior_compacts (K : Compacts G) : μ.outerMeasure (interior K) ≤ μ K :=\n  (μ.outerMeasure_opens <| Opens.interior K).le.trans <| μ.innerContent_le _ _ interior_subset\n\n"}
{"name":"MeasureTheory.Content.outerMeasure_exists_compact","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝ : R1Space G\nU : TopologicalSpace.Opens G\nhU : Ne (μ.outerMeasure ↑U) Top.top\nε : NNReal\nhε : Ne ε 0\n⊢ Exists fun K => And (HasSubset.Subset ↑K ↑U) (LE.le (μ.outerMeasure ↑U) (HAdd.hAdd (μ.outerMeasure ↑K) ↑ε))","decl":"theorem outerMeasure_exists_compact {U : Opens G} (hU : μ.outerMeasure U ≠ ∞) {ε : ℝ≥0}\n    (hε : ε ≠ 0) : ∃ K : Compacts G, (K : Set G) ⊆ U ∧ μ.outerMeasure U ≤ μ.outerMeasure K + ε := by\n  rw [μ.outerMeasure_opens] at hU ⊢\n  rcases μ.innerContent_exists_compact hU hε with ⟨K, h1K, h2K⟩\n  exact ⟨K, h1K, le_trans h2K <| add_le_add_right (μ.le_outerMeasure_compacts K) _⟩\n\n"}
{"name":"MeasureTheory.Content.outerMeasure_exists_open","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝ : R1Space G\nA : Set G\nhA : Ne (μ.outerMeasure A) Top.top\nε : NNReal\nhε : Ne ε 0\n⊢ Exists fun U => And (HasSubset.Subset A ↑U) (LE.le (μ.outerMeasure ↑U) (HAdd.hAdd (μ.outerMeasure A) ↑ε))","decl":"theorem outerMeasure_exists_open {A : Set G} (hA : μ.outerMeasure A ≠ ∞) {ε : ℝ≥0} (hε : ε ≠ 0) :\n    ∃ U : Opens G, A ⊆ U ∧ μ.outerMeasure U ≤ μ.outerMeasure A + ε := by\n  rcases inducedOuterMeasure_exists_set _ μ.innerContent_iUnion_nat μ.innerContent_mono hA\n      (ENNReal.coe_ne_zero.2 hε) with\n    ⟨U, hU, h2U, h3U⟩\n  exact ⟨⟨U, hU⟩, h2U, h3U⟩\n\n"}
{"name":"MeasureTheory.Content.outerMeasure_preimage","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝ : R1Space G\nf : Homeomorph G G\nh : ∀ ⦃K : TopologicalSpace.Compacts G⦄, Eq ((fun s => ↑(μ.toFun s)) (TopologicalSpace.Compacts.map ⇑f ⋯ K)) ((fun s => ↑(μ.toFun s)) K)\nA : Set G\n⊢ Eq (μ.outerMeasure (Set.preimage (⇑f) A)) (μ.outerMeasure A)","decl":"theorem outerMeasure_preimage (f : G ≃ₜ G) (h : ∀ ⦃K : Compacts G⦄, μ (K.map f f.continuous) = μ K)\n    (A : Set G) : μ.outerMeasure (f ⁻¹' A) = μ.outerMeasure A := by\n  refine inducedOuterMeasure_preimage _ μ.innerContent_iUnion_nat μ.innerContent_mono _\n    (fun _ => f.isOpen_preimage) ?_\n  intro s hs\n  convert μ.innerContent_comap f h ⟨s, hs⟩\n\n"}
{"name":"MeasureTheory.Content.outerMeasure_lt_top_of_isCompact","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝² : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝¹ : R1Space G\ninst✝ : WeaklyLocallyCompactSpace G\nK : Set G\nhK : IsCompact K\n⊢ LT.lt (μ.outerMeasure K) Top.top","decl":"theorem outerMeasure_lt_top_of_isCompact [WeaklyLocallyCompactSpace G]\n    {K : Set G} (hK : IsCompact K) :\n    μ.outerMeasure K < ∞ := by\n  rcases exists_compact_superset hK with ⟨F, h1F, h2F⟩\n  calc\n    μ.outerMeasure K ≤ μ.outerMeasure (interior F) := measure_mono h2F\n    _ ≤ μ ⟨F, h1F⟩ := by\n      apply μ.outerMeasure_le ⟨interior F, isOpen_interior⟩ ⟨F, h1F⟩ interior_subset\n    _ < ⊤ := μ.lt_top _\n\n"}
{"name":"MeasureTheory.Content.is_mul_left_invariant_outerMeasure","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝³ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝² : R1Space G\ninst✝¹ : Group G\ninst✝ : TopologicalGroup G\nh : ∀ (g : G) {K : TopologicalSpace.Compacts G}, Eq ((fun s => ↑(μ.toFun s)) (TopologicalSpace.Compacts.map (fun b => HMul.hMul g b) ⋯ K)) ((fun s => ↑(μ.toFun s)) K)\ng : G\nA : Set G\n⊢ Eq (μ.outerMeasure (Set.preimage (fun x => HMul.hMul g x) A)) (μ.outerMeasure A)","decl":"@[to_additive]\ntheorem is_mul_left_invariant_outerMeasure [Group G] [TopologicalGroup G]\n    (h : ∀ (g : G) {K : Compacts G}, μ (K.map _ <| continuous_mul_left g) = μ K) (g : G)\n    (A : Set G) : μ.outerMeasure ((g * ·) ⁻¹' A) = μ.outerMeasure A := by\n  convert μ.outerMeasure_preimage (Homeomorph.mulLeft g) (fun K => h g) A\n\n"}
{"name":"MeasureTheory.Content.is_add_left_invariant_outerMeasure","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝³ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝² : R1Space G\ninst✝¹ : AddGroup G\ninst✝ : TopologicalAddGroup G\nh : ∀ (g : G) {K : TopologicalSpace.Compacts G}, Eq ((fun s => ↑(μ.toFun s)) (TopologicalSpace.Compacts.map (fun b => HAdd.hAdd g b) ⋯ K)) ((fun s => ↑(μ.toFun s)) K)\ng : G\nA : Set G\n⊢ Eq (μ.outerMeasure (Set.preimage (fun x => HAdd.hAdd g x) A)) (μ.outerMeasure A)","decl":"@[to_additive]\ntheorem is_mul_left_invariant_outerMeasure [Group G] [TopologicalGroup G]\n    (h : ∀ (g : G) {K : Compacts G}, μ (K.map _ <| continuous_mul_left g) = μ K) (g : G)\n    (A : Set G) : μ.outerMeasure ((g * ·) ⁻¹' A) = μ.outerMeasure A := by\n  convert μ.outerMeasure_preimage (Homeomorph.mulLeft g) (fun K => h g) A\n\n"}
{"name":"MeasureTheory.Content.outerMeasure_caratheodory","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝¹ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝ : R1Space G\nA : Set G\n⊢ Iff (MeasurableSet A) (∀ (U : TopologicalSpace.Opens G), LE.le (HAdd.hAdd (μ.outerMeasure (Inter.inter (↑U) A)) (μ.outerMeasure (SDiff.sdiff (↑U) A))) (μ.outerMeasure ↑U))","decl":"theorem outerMeasure_caratheodory (A : Set G) :\n    MeasurableSet[μ.outerMeasure.caratheodory] A ↔\n      ∀ U : Opens G, μ.outerMeasure (U ∩ A) + μ.outerMeasure (U \\ A) ≤ μ.outerMeasure U := by\n  rw [Opens.forall]\n  apply inducedOuterMeasure_caratheodory\n  · apply innerContent_iUnion_nat\n  · apply innerContent_mono'\n\n"}
{"name":"MeasureTheory.Content.outerMeasure_pos_of_is_mul_left_invariant","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝³ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝² : R1Space G\ninst✝¹ : Group G\ninst✝ : TopologicalGroup G\nh3 : ∀ (g : G) {K : TopologicalSpace.Compacts G}, Eq ((fun s => ↑(μ.toFun s)) (TopologicalSpace.Compacts.map (fun b => HMul.hMul g b) ⋯ K)) ((fun s => ↑(μ.toFun s)) K)\nK : TopologicalSpace.Compacts G\nhK : Ne ((fun s => ↑(μ.toFun s)) K) 0\nU : Set G\nh1U : IsOpen U\nh2U : U.Nonempty\n⊢ LT.lt 0 (μ.outerMeasure U)","decl":"@[to_additive]\ntheorem outerMeasure_pos_of_is_mul_left_invariant [Group G] [TopologicalGroup G]\n    (h3 : ∀ (g : G) {K : Compacts G}, μ (K.map _ <| continuous_mul_left g) = μ K) (K : Compacts G)\n    (hK : μ K ≠ 0) {U : Set G} (h1U : IsOpen U) (h2U : U.Nonempty) : 0 < μ.outerMeasure U := by\n  convert μ.innerContent_pos_of_is_mul_left_invariant h3 K hK ⟨U, h1U⟩ h2U\n  exact μ.outerMeasure_opens ⟨U, h1U⟩\n\n"}
{"name":"MeasureTheory.Content.outerMeasure_pos_of_is_add_left_invariant","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝³ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝² : R1Space G\ninst✝¹ : AddGroup G\ninst✝ : TopologicalAddGroup G\nh3 : ∀ (g : G) {K : TopologicalSpace.Compacts G}, Eq ((fun s => ↑(μ.toFun s)) (TopologicalSpace.Compacts.map (fun b => HAdd.hAdd g b) ⋯ K)) ((fun s => ↑(μ.toFun s)) K)\nK : TopologicalSpace.Compacts G\nhK : Ne ((fun s => ↑(μ.toFun s)) K) 0\nU : Set G\nh1U : IsOpen U\nh2U : U.Nonempty\n⊢ LT.lt 0 (μ.outerMeasure U)","decl":"@[to_additive]\ntheorem outerMeasure_pos_of_is_mul_left_invariant [Group G] [TopologicalGroup G]\n    (h3 : ∀ (g : G) {K : Compacts G}, μ (K.map _ <| continuous_mul_left g) = μ K) (K : Compacts G)\n    (hK : μ K ≠ 0) {U : Set G} (h1U : IsOpen U) (h2U : U.Nonempty) : 0 < μ.outerMeasure U := by\n  convert μ.innerContent_pos_of_is_mul_left_invariant h3 K hK ⟨U, h1U⟩ h2U\n  exact μ.outerMeasure_opens ⟨U, h1U⟩\n\n"}
{"name":"MeasureTheory.Content.borel_le_caratheodory","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝² : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝¹ : R1Space G\nS : MeasurableSpace G\ninst✝ : BorelSpace G\n⊢ LE.le S μ.outerMeasure.caratheodory","decl":"/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem borel_le_caratheodory : S ≤ μ.outerMeasure.caratheodory := by\n  rw [BorelSpace.measurable_eq (α := G)]\n  refine MeasurableSpace.generateFrom_le ?_\n  intro U hU\n  rw [μ.outerMeasure_caratheodory]\n  intro U'\n  rw [μ.outerMeasure_of_isOpen ((U' : Set G) ∩ U) (U'.isOpen.inter hU)]\n  simp only [innerContent, iSup_subtype']\n  rw [Opens.coe_mk]\n  haveI : Nonempty { L : Compacts G // (L : Set G) ⊆ U' ∩ U } := ⟨⟨⊥, empty_subset _⟩⟩\n  rw [ENNReal.iSup_add]\n  refine iSup_le ?_\n  rintro ⟨L, hL⟩\n  let L' : Compacts G := ⟨closure L, L.isCompact.closure⟩\n  suffices μ L' + μ.outerMeasure (↑U' \\ U) ≤ μ.outerMeasure U' by\n    have A : μ L ≤ μ L' := μ.mono _ _ subset_closure\n    exact (add_le_add_right A _).trans this\n  simp only [subset_inter_iff] at hL\n  have hL'U : (L' : Set G) ⊆ U := IsCompact.closure_subset_of_isOpen L.2 hU hL.2\n  have hL'U' : (L' : Set G) ⊆ (U' : Set G) := IsCompact.closure_subset_of_isOpen L.2 U'.2 hL.1\n  have : ↑U' \\ U ⊆ U' \\ L' := diff_subset_diff_right hL'U\n  refine le_trans (add_le_add_left (measure_mono this) _) ?_\n  rw [μ.outerMeasure_of_isOpen (↑U' \\ L') (IsOpen.sdiff U'.2 isClosed_closure)]\n  simp only [innerContent, iSup_subtype']\n  rw [Opens.coe_mk]\n  haveI : Nonempty { M : Compacts G // (M : Set G) ⊆ ↑U' \\ closure L } := ⟨⟨⊥, empty_subset _⟩⟩\n  rw [ENNReal.add_iSup]\n  refine iSup_le ?_\n  rintro ⟨M, hM⟩\n  let M' : Compacts G := ⟨closure M, M.isCompact.closure⟩\n  suffices μ L' + μ M' ≤ μ.outerMeasure U' by\n    have A : μ M ≤ μ M' := μ.mono _ _ subset_closure\n    exact (add_le_add_left A _).trans this\n  have hM' : (M' : Set G) ⊆ U' \\ L' :=\n    IsCompact.closure_subset_of_isOpen M.2 (IsOpen.sdiff U'.2 isClosed_closure) hM\n  have : (↑(L' ⊔ M') : Set G) ⊆ U' := by\n    simp only [Compacts.coe_sup, union_subset_iff, hL'U', true_and]\n    exact hM'.trans diff_subset\n  rw [μ.outerMeasure_of_isOpen (↑U') U'.2]\n  refine le_trans (ge_of_eq ?_) (μ.le_innerContent _ _ this)\n  exact μ.sup_disjoint L' M' (subset_diff.1 hM').2.symm isClosed_closure isClosed_closure\n\n"}
{"name":"MeasureTheory.Content.measure_apply","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝² : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝¹ : R1Space G\nS : MeasurableSpace G\ninst✝ : BorelSpace G\ns : Set G\nhs : MeasurableSet s\n⊢ Eq (μ.measure s) (μ.outerMeasure s)","decl":"theorem measure_apply {s : Set G} (hs : MeasurableSet s) : μ.measure s = μ.outerMeasure s :=\n  toMeasure_apply _ _ hs\n\n"}
{"name":"MeasureTheory.Content.outerRegular","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝² : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝¹ : R1Space G\nS : MeasurableSpace G\ninst✝ : BorelSpace G\n⊢ μ.measure.OuterRegular","decl":"instance outerRegular : μ.measure.OuterRegular := by\n  refine ⟨fun A hA r (hr : _ < _) ↦ ?_⟩\n  rw [μ.measure_apply hA, outerMeasure_eq_iInf] at hr\n  simp only [iInf_lt_iff] at hr\n  rcases hr with ⟨U, hUo, hAU, hr⟩\n  rw [← μ.outerMeasure_of_isOpen U hUo, ← μ.measure_apply hUo.measurableSet] at hr\n  exact ⟨U, hAU, hUo, hr⟩\n\n"}
{"name":"MeasureTheory.Content.regular","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝³ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝² : R1Space G\nS : MeasurableSpace G\ninst✝¹ : BorelSpace G\ninst✝ : WeaklyLocallyCompactSpace G\n⊢ μ.measure.Regular","decl":"/-- In a locally compact space, any measure constructed from a content is regular. -/\ninstance regular [WeaklyLocallyCompactSpace G] : μ.measure.Regular := by\n  have : IsFiniteMeasureOnCompacts μ.measure := by\n    refine ⟨fun K hK => ?_⟩\n    apply (measure_mono subset_closure).trans_lt _\n    rw [measure_apply _ isClosed_closure.measurableSet]\n    exact μ.outerMeasure_lt_top_of_isCompact hK.closure\n  refine ⟨fun U hU r hr => ?_⟩\n  rw [measure_apply _ hU.measurableSet, μ.outerMeasure_of_isOpen U hU] at hr\n  simp only [innerContent, lt_iSup_iff] at hr\n  rcases hr with ⟨K, hKU, hr⟩\n  refine ⟨K, hKU, K.2, hr.trans_le ?_⟩\n  exact (μ.le_outerMeasure_compacts K).trans (le_toMeasure_apply _ _ _)\n\n"}
{"name":"MeasureTheory.Content.contentRegular_exists_compact","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝ : TopologicalSpace G\nμ : MeasureTheory.Content G\nH : μ.ContentRegular\nK : TopologicalSpace.Compacts G\nε : NNReal\nhε : Ne ε 0\n⊢ Exists fun K' => And (HasSubset.Subset K.carrier (interior K'.carrier)) (LE.le ((fun s => ↑(μ.toFun s)) K') (HAdd.hAdd ((fun s => ↑(μ.toFun s)) K) ↑ε))","decl":"theorem contentRegular_exists_compact (H : ContentRegular μ) (K : TopologicalSpace.Compacts G)\n    {ε : NNReal} (hε : ε ≠ 0) :\n    ∃ K' : TopologicalSpace.Compacts G, K.carrier ⊆ interior K'.carrier ∧ μ K' ≤ μ K + ε := by\n  by_contra hc\n  simp only [not_exists, not_and, not_le] at hc\n  have lower_bound_iInf : μ K + ε ≤\n      ⨅ (K' : TopologicalSpace.Compacts G) (_ : (K : Set G) ⊆ interior (K' : Set G)), μ K' :=\n    le_iInf fun K' => le_iInf fun K'_hyp => le_of_lt (hc K' K'_hyp)\n  rw [← H] at lower_bound_iInf\n  exact (lt_self_iff_false (μ K)).mp (lt_of_le_of_lt' lower_bound_iInf\n    (ENNReal.lt_add_right (ne_top_of_lt (μ.lt_top K)) (ENNReal.coe_ne_zero.mpr hε)))\n\n"}
{"name":"MeasureTheory.Content.measure_eq_content_of_regular","module":"Mathlib.MeasureTheory.Measure.Content","initialProofState":"G : Type w\ninst✝³ : TopologicalSpace G\nμ : MeasureTheory.Content G\ninst✝² : MeasurableSpace G\ninst✝¹ : R1Space G\ninst✝ : BorelSpace G\nH : μ.ContentRegular\nK : TopologicalSpace.Compacts G\n⊢ Eq (μ.measure ↑K) ((fun s => ↑(μ.toFun s)) K)","decl":"/-- If `μ` is a regular content, then the measure induced by `μ` will agree with `μ`\n  on compact sets. -/\ntheorem measure_eq_content_of_regular (H : MeasureTheory.Content.ContentRegular μ)\n    (K : TopologicalSpace.Compacts G) : μ.measure ↑K = μ K := by\n  refine le_antisymm ?_ ?_\n  · apply ENNReal.le_of_forall_pos_le_add\n    intro ε εpos _\n    obtain ⟨K', K'_hyp⟩ := contentRegular_exists_compact μ H K (ne_bot_of_gt εpos)\n    calc\n      μ.measure ↑K ≤ μ.measure (interior ↑K') := measure_mono K'_hyp.1\n      _ ≤ μ K' := by\n        rw [μ.measure_apply (IsOpen.measurableSet isOpen_interior)]\n        exact μ.outerMeasure_interior_compacts K'\n      _ ≤ μ K + ε := K'_hyp.right\n  · calc\n    μ K ≤ μ ⟨closure K, K.2.closure⟩ := μ.mono _ _ subset_closure\n    _ ≤ μ.measure (closure K) := by\n      rw [μ.measure_apply (isClosed_closure.measurableSet)]\n      exact μ.le_outerMeasure_compacts _\n    _ = μ.measure K := K.2.measure_closure _\n\n"}
