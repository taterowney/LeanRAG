{"name":"BoxIntegral.Prepartition.mem_splitCenter","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI J : BoxIntegral.Box Î¹\nâŠ¢ Iff (Membership.mem (BoxIntegral.Prepartition.splitCenter I) J) (Exists fun s => Eq (I.splitCenterBox s) J)","decl":"@[simp]\ntheorem mem_splitCenter : J âˆˆ splitCenter I â†” âˆƒ s, I.splitCenterBox s = J := by simp [splitCenter]\n\n"}
{"name":"BoxIntegral.Prepartition.isPartition_splitCenter","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI : BoxIntegral.Box Î¹\nâŠ¢ (BoxIntegral.Prepartition.splitCenter I).IsPartition","decl":"theorem isPartition_splitCenter (I : Box Î¹) : IsPartition (splitCenter I) := fun x hx => by\n  simp [hx]\n\n"}
{"name":"BoxIntegral.Prepartition.upper_sub_lower_of_mem_splitCenter","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI J : BoxIntegral.Box Î¹\nh : Membership.mem (BoxIntegral.Prepartition.splitCenter I) J\ni : Î¹\nâŠ¢ Eq (HSub.hSub (J.upper i) (J.lower i)) (HDiv.hDiv (HSub.hSub (I.upper i) (I.lower i)) 2)","decl":"theorem upper_sub_lower_of_mem_splitCenter (h : J âˆˆ splitCenter I) (i : Î¹) :\n    J.upper i - J.lower i = (I.upper i - I.lower i) / 2 :=\n  let âŸ¨s, hsâŸ© := mem_splitCenter.1 h\n  hs â–¸ I.upper_sub_lower_splitCenterBox s i\n\n"}
{"name":"BoxIntegral.Box.subbox_induction_on","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\np : BoxIntegral.Box Î¹ â†’ Prop\nI : BoxIntegral.Box Î¹\nH_ind : âˆ€ (J : BoxIntegral.Box Î¹), LE.le J I â†’ (âˆ€ (J' : BoxIntegral.Box Î¹), Membership.mem (BoxIntegral.Prepartition.splitCenter J) J' â†’ p J') â†’ p J\nH_nhds : âˆ€ (z : Î¹ â†’ Real), Membership.mem (BoxIntegral.Box.Icc I) z â†’ Exists fun U => And (Membership.mem (nhdsWithin z (BoxIntegral.Box.Icc I)) U) (âˆ€ (J : BoxIntegral.Box Î¹), LE.le J I â†’ âˆ€ (m : Nat), Membership.mem (BoxIntegral.Box.Icc J) z â†’ HasSubset.Subset (BoxIntegral.Box.Icc J) U â†’ (âˆ€ (i : Î¹), Eq (HSub.hSub (J.upper i) (J.lower i)) (HDiv.hDiv (HSub.hSub (I.upper i) (I.lower i)) (HPow.hPow 2 m))) â†’ p J)\nâŠ¢ p I","decl":"/-- Let `p` be a predicate on `Box Î¹`, let `I` be a box. Suppose that the following two properties\nhold true.\n\n* Consider a smaller box `J â‰¤ I`. The hyperplanes passing through the center of `J` split it into\n  `2 ^ n` boxes. If `p` holds true on each of these boxes, then it true on `J`.\n* For each `z` in the closed box `I.Icc` there exists a neighborhood `U` of `z` within `I.Icc` such\n  that for every box `J â‰¤ I` such that `z âˆˆ J.Icc âŠ† U`, if `J` is homothetic to `I` with a\n  coefficient of the form `1 / 2 ^ m`, then `p` is true on `J`.\n\nThen `p I` is true. See also `BoxIntegral.Box.subbox_induction_on'` for a version using\n`BoxIntegral.Box.splitCenterBox` instead of `BoxIntegral.Prepartition.splitCenter`. -/\n@[elab_as_elim]\ntheorem subbox_induction_on {p : Box Î¹ â†’ Prop} (I : Box Î¹)\n    (H_ind : âˆ€ J â‰¤ I, (âˆ€ J' âˆˆ splitCenter J, p J') â†’ p J)\n    (H_nhds : âˆ€ z âˆˆ Box.Icc I, âˆƒ U âˆˆ ğ“[Box.Icc I] z, âˆ€ J â‰¤ I, âˆ€ (m : â„•),\n      z âˆˆ Box.Icc J â†’ Box.Icc J âŠ† U â†’\n        (âˆ€ i, J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J) :\n    p I := by\n  refine subbox_induction_on' I (fun J hle hs => H_ind J hle fun J' h' => ?_) H_nhds\n  rcases mem_splitCenter.1 h' with âŸ¨s, rflâŸ©\n  exact hs s\n\n"}
{"name":"BoxIntegral.Box.exists_taggedPartition_isHenstock_isSubordinate_homothetic","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI : BoxIntegral.Box Î¹\nr : (Î¹ â†’ Real) â†’ â†‘(Set.Ioi 0)\nâŠ¢ Exists fun Ï€ => And Ï€.IsPartition (And Ï€.IsHenstock (And (Ï€.IsSubordinate r) (And (âˆ€ (J : BoxIntegral.Box Î¹), Membership.mem Ï€ J â†’ Exists fun m => âˆ€ (i : Î¹), Eq (HSub.hSub (J.upper i) (J.lower i)) (HDiv.hDiv (HSub.hSub (I.upper i) (I.lower i)) (HPow.hPow 2 m))) (Eq Ï€.distortion I.distortion))))","decl":"/-- Given a box `I` in `â„â¿` and a function `r : â„â¿ â†’ (0, âˆ)`, there exists a tagged partition `Ï€` of\n`I` such that\n\n* `Ï€` is a Henstock partition;\n* `Ï€` is subordinate to `r`;\n* each box in `Ï€` is homothetic to `I` with coefficient of the form `1 / 2 ^ m`.\n\nThis lemma implies that the Henstock filter is nontrivial, hence the Henstock integral is\nwell-defined. -/\ntheorem exists_taggedPartition_isHenstock_isSubordinate_homothetic (I : Box Î¹)\n    (r : (Î¹ â†’ â„) â†’ Ioi (0 : â„)) :\n    âˆƒ Ï€ : TaggedPrepartition I, Ï€.IsPartition âˆ§ Ï€.IsHenstock âˆ§ Ï€.IsSubordinate r âˆ§\n      (âˆ€ J âˆˆ Ï€, âˆƒ m : â„•, âˆ€ i, (J :).upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) âˆ§\n        Ï€.distortion = I.distortion := by\n  refine subbox_induction_on I (fun J _ hJ => ?_) fun z _ => ?_\n  Â· choose! Ï€i hP hHen hr Hn _ using hJ\n    choose! n hn using Hn\n    have hP : ((splitCenter J).biUnionTagged Ï€i).IsPartition :=\n      (isPartition_splitCenter _).biUnionTagged hP\n    have hsub : âˆ€ J' âˆˆ (splitCenter J).biUnionTagged Ï€i, âˆƒ n : â„•, âˆ€ i,\n        (J' :).upper i - J'.lower i = (J.upper i - J.lower i) / 2 ^ n := by\n      intro J' hJ'\n      rcases (splitCenter J).mem_biUnionTagged.1 hJ' with âŸ¨Jâ‚, hâ‚, hâ‚‚âŸ©\n      refine âŸ¨n Jâ‚ J' + 1, fun i => ?_âŸ©\n      simp only [hn Jâ‚ hâ‚ J' hâ‚‚, upper_sub_lower_of_mem_splitCenter hâ‚, pow_succ', div_div]\n    refine âŸ¨_, hP, isHenstock_biUnionTagged.2 hHen, isSubordinate_biUnionTagged.2 hr, hsub, ?_âŸ©\n    refine TaggedPrepartition.distortion_of_const _ hP.nonempty_boxes fun J' h' => ?_\n    rcases hsub J' h' with âŸ¨n, hnâŸ©\n    exact Box.distortion_eq_of_sub_eq_div hn\n  Â· refine âŸ¨Box.Icc I âˆ© closedBall z (r z),\n      inter_mem_nhdsWithin _ (closedBall_mem_nhds _ (r z).coe_prop), ?_âŸ©\n    intro J _ n Hmem HIcc Hsub\n    rw [Set.subset_inter_iff] at HIcc\n    refine âŸ¨single _ _ le_rfl _ Hmem, isPartition_single _, isHenstock_single _,\n      (isSubordinate_single _ _).2 HIcc.2, ?_, distortion_single _ _âŸ©\n    simp only [TaggedPrepartition.mem_single, forall_eq]\n    refine âŸ¨0, fun i => ?_âŸ©\n    simp\n\n"}
{"name":"BoxIntegral.Prepartition.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI : BoxIntegral.Box Î¹\nr : (Î¹ â†’ Real) â†’ â†‘(Set.Ioi 0)\nÏ€ : BoxIntegral.Prepartition I\nâŠ¢ Exists fun Ï€' => And (LE.le Ï€'.toPrepartition Ï€) (And Ï€'.IsHenstock (And (Ï€'.IsSubordinate r) (And (Eq Ï€'.distortion Ï€.distortion) (Eq Ï€'.iUnion Ï€.iUnion))))","decl":"/-- Given a box `I` in `â„â¿`, a function `r : â„â¿ â†’ (0, âˆ)`, and a prepartition `Ï€` of `I`, there\nexists a tagged prepartition `Ï€'` of `I` such that\n\n* each box of `Ï€'` is included in some box of `Ï€`;\n* `Ï€'` is a Henstock partition;\n* `Ï€'` is subordinate to `r`;\n* `Ï€'` covers exactly the same part of `I` as `Ï€`;\n* the distortion of `Ï€'` is equal to the distortion of `Ï€`.\n-/\ntheorem exists_tagged_le_isHenstock_isSubordinate_iUnion_eq {I : Box Î¹} (r : (Î¹ â†’ â„) â†’ Ioi (0 : â„))\n    (Ï€ : Prepartition I) :\n    âˆƒ Ï€' : TaggedPrepartition I, Ï€'.toPrepartition â‰¤ Ï€ âˆ§ Ï€'.IsHenstock âˆ§ Ï€'.IsSubordinate r âˆ§\n      Ï€'.distortion = Ï€.distortion âˆ§ Ï€'.iUnion = Ï€.iUnion := by\n  have := fun J => Box.exists_taggedPartition_isHenstock_isSubordinate_homothetic J r\n  choose! Ï€i Ï€ip Ï€iH Ï€ir _ Ï€id using this\n  refine âŸ¨Ï€.biUnionTagged Ï€i, biUnion_le _ _, isHenstock_biUnionTagged.2 fun J _ => Ï€iH J,\n    isSubordinate_biUnionTagged.2 fun J _ => Ï€ir J, ?_, Ï€.iUnion_biUnion_partition fun J _ => Ï€ip JâŸ©\n  rw [distortion_biUnionTagged]\n  exact sup_congr rfl fun J _ => Ï€id J\n\n"}
{"name":"BoxIntegral.Prepartition.toSubordinate_toPrepartition_le","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI : BoxIntegral.Box Î¹\nÏ€ : BoxIntegral.Prepartition I\nr : (Î¹ â†’ Real) â†’ â†‘(Set.Ioi 0)\nâŠ¢ LE.le (Ï€.toSubordinate r).toPrepartition Ï€","decl":"theorem toSubordinate_toPrepartition_le (Ï€ : Prepartition I) (r : (Î¹ â†’ â„) â†’ Ioi (0 : â„)) :\n    (Ï€.toSubordinate r).toPrepartition â‰¤ Ï€ :=\n  (Ï€.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq r).choose_spec.1\n\n"}
{"name":"BoxIntegral.Prepartition.isHenstock_toSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI : BoxIntegral.Box Î¹\nÏ€ : BoxIntegral.Prepartition I\nr : (Î¹ â†’ Real) â†’ â†‘(Set.Ioi 0)\nâŠ¢ (Ï€.toSubordinate r).IsHenstock","decl":"theorem isHenstock_toSubordinate (Ï€ : Prepartition I) (r : (Î¹ â†’ â„) â†’ Ioi (0 : â„)) :\n    (Ï€.toSubordinate r).IsHenstock :=\n  (Ï€.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq r).choose_spec.2.1\n\n"}
{"name":"BoxIntegral.Prepartition.isSubordinate_toSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI : BoxIntegral.Box Î¹\nÏ€ : BoxIntegral.Prepartition I\nr : (Î¹ â†’ Real) â†’ â†‘(Set.Ioi 0)\nâŠ¢ (Ï€.toSubordinate r).IsSubordinate r","decl":"theorem isSubordinate_toSubordinate (Ï€ : Prepartition I) (r : (Î¹ â†’ â„) â†’ Ioi (0 : â„)) :\n    (Ï€.toSubordinate r).IsSubordinate r :=\n  (Ï€.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq r).choose_spec.2.2.1\n\n"}
{"name":"BoxIntegral.Prepartition.distortion_toSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI : BoxIntegral.Box Î¹\nÏ€ : BoxIntegral.Prepartition I\nr : (Î¹ â†’ Real) â†’ â†‘(Set.Ioi 0)\nâŠ¢ Eq (Ï€.toSubordinate r).distortion Ï€.distortion","decl":"@[simp]\ntheorem distortion_toSubordinate (Ï€ : Prepartition I) (r : (Î¹ â†’ â„) â†’ Ioi (0 : â„)) :\n    (Ï€.toSubordinate r).distortion = Ï€.distortion :=\n  (Ï€.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq r).choose_spec.2.2.2.1\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_toSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI : BoxIntegral.Box Î¹\nÏ€ : BoxIntegral.Prepartition I\nr : (Î¹ â†’ Real) â†’ â†‘(Set.Ioi 0)\nâŠ¢ Eq (Ï€.toSubordinate r).iUnion Ï€.iUnion","decl":"@[simp]\ntheorem iUnion_toSubordinate (Ï€ : Prepartition I) (r : (Î¹ â†’ â„) â†’ Ioi (0 : â„)) :\n    (Ï€.toSubordinate r).iUnion = Ï€.iUnion :=\n  (Ï€.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq r).choose_spec.2.2.2.2\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.isPartition_unionComplToSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI : BoxIntegral.Box Î¹\nÏ€â‚ : BoxIntegral.TaggedPrepartition I\nÏ€â‚‚ : BoxIntegral.Prepartition I\nhU : Eq Ï€â‚‚.iUnion (SDiff.sdiff (â†‘I) Ï€â‚.iUnion)\nr : (Î¹ â†’ Real) â†’ â†‘(Set.Ioi 0)\nâŠ¢ (Ï€â‚.unionComplToSubordinate Ï€â‚‚ hU r).IsPartition","decl":"theorem isPartition_unionComplToSubordinate (Ï€â‚ : TaggedPrepartition I) (Ï€â‚‚ : Prepartition I)\n    (hU : Ï€â‚‚.iUnion = â†‘I \\ Ï€â‚.iUnion) (r : (Î¹ â†’ â„) â†’ Ioi (0 : â„)) :\n    IsPartition (Ï€â‚.unionComplToSubordinate Ï€â‚‚ hU r) :=\n  Prepartition.isPartitionDisjUnionOfEqDiff ((Ï€â‚‚.iUnion_toSubordinate r).trans hU)\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.unionComplToSubordinate_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI : BoxIntegral.Box Î¹\nÏ€â‚ : BoxIntegral.TaggedPrepartition I\nÏ€â‚‚ : BoxIntegral.Prepartition I\nhU : Eq Ï€â‚‚.iUnion (SDiff.sdiff (â†‘I) Ï€â‚.iUnion)\nr : (Î¹ â†’ Real) â†’ â†‘(Set.Ioi 0)\nâŠ¢ Eq (Ï€â‚.unionComplToSubordinate Ï€â‚‚ hU r).boxes (Union.union Ï€â‚.boxes (Ï€â‚‚.toSubordinate r).boxes)","decl":"open scoped Classical in\n@[simp]\ntheorem unionComplToSubordinate_boxes (Ï€â‚ : TaggedPrepartition I) (Ï€â‚‚ : Prepartition I)\n    (hU : Ï€â‚‚.iUnion = â†‘I \\ Ï€â‚.iUnion) (r : (Î¹ â†’ â„) â†’ Ioi (0 : â„)) :\n    (Ï€â‚.unionComplToSubordinate Ï€â‚‚ hU r).boxes = Ï€â‚.boxes âˆª (Ï€â‚‚.toSubordinate r).boxes := rfl\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.iUnion_unionComplToSubordinate_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI : BoxIntegral.Box Î¹\nÏ€â‚ : BoxIntegral.TaggedPrepartition I\nÏ€â‚‚ : BoxIntegral.Prepartition I\nhU : Eq Ï€â‚‚.iUnion (SDiff.sdiff (â†‘I) Ï€â‚.iUnion)\nr : (Î¹ â†’ Real) â†’ â†‘(Set.Ioi 0)\nâŠ¢ Eq (Ï€â‚.unionComplToSubordinate Ï€â‚‚ hU r).iUnion â†‘I","decl":"@[simp]\ntheorem iUnion_unionComplToSubordinate_boxes (Ï€â‚ : TaggedPrepartition I) (Ï€â‚‚ : Prepartition I)\n    (hU : Ï€â‚‚.iUnion = â†‘I \\ Ï€â‚.iUnion) (r : (Î¹ â†’ â„) â†’ Ioi (0 : â„)) :\n    (Ï€â‚.unionComplToSubordinate Ï€â‚‚ hU r).iUnion = I :=\n  (isPartition_unionComplToSubordinate _ _ _ _).iUnion_eq\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.distortion_unionComplToSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"Î¹ : Type u_1\ninstâœ : Fintype Î¹\nI : BoxIntegral.Box Î¹\nÏ€â‚ : BoxIntegral.TaggedPrepartition I\nÏ€â‚‚ : BoxIntegral.Prepartition I\nhU : Eq Ï€â‚‚.iUnion (SDiff.sdiff (â†‘I) Ï€â‚.iUnion)\nr : (Î¹ â†’ Real) â†’ â†‘(Set.Ioi 0)\nâŠ¢ Eq (Ï€â‚.unionComplToSubordinate Ï€â‚‚ hU r).distortion (Max.max Ï€â‚.distortion Ï€â‚‚.distortion)","decl":"@[simp]\ntheorem distortion_unionComplToSubordinate (Ï€â‚ : TaggedPrepartition I) (Ï€â‚‚ : Prepartition I)\n    (hU : Ï€â‚‚.iUnion = â†‘I \\ Ï€â‚.iUnion) (r : (Î¹ â†’ â„) â†’ Ioi (0 : â„)) :\n    (Ï€â‚.unionComplToSubordinate Ï€â‚‚ hU r).distortion = max Ï€â‚.distortion Ï€â‚‚.distortion := by\n  simp [unionComplToSubordinate]\n\n"}
