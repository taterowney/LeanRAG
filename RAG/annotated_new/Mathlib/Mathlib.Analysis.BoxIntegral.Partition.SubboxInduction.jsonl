{"name":"BoxIntegral.Prepartition.mem_splitCenter","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI J : BoxIntegral.Box ι\n⊢ Iff (Membership.mem (BoxIntegral.Prepartition.splitCenter I) J) (Exists fun s => Eq (I.splitCenterBox s) J)","decl":"@[simp]\ntheorem mem_splitCenter : J ∈ splitCenter I ↔ ∃ s, I.splitCenterBox s = J := by simp [splitCenter]\n\n"}
{"name":"BoxIntegral.Prepartition.isPartition_splitCenter","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\n⊢ (BoxIntegral.Prepartition.splitCenter I).IsPartition","decl":"theorem isPartition_splitCenter (I : Box ι) : IsPartition (splitCenter I) := fun x hx => by\n  simp [hx]\n\n"}
{"name":"BoxIntegral.Prepartition.upper_sub_lower_of_mem_splitCenter","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI J : BoxIntegral.Box ι\nh : Membership.mem (BoxIntegral.Prepartition.splitCenter I) J\ni : ι\n⊢ Eq (HSub.hSub (J.upper i) (J.lower i)) (HDiv.hDiv (HSub.hSub (I.upper i) (I.lower i)) 2)","decl":"theorem upper_sub_lower_of_mem_splitCenter (h : J ∈ splitCenter I) (i : ι) :\n    J.upper i - J.lower i = (I.upper i - I.lower i) / 2 :=\n  let ⟨s, hs⟩ := mem_splitCenter.1 h\n  hs ▸ I.upper_sub_lower_splitCenterBox s i\n\n"}
{"name":"BoxIntegral.Box.subbox_induction_on","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\np : BoxIntegral.Box ι → Prop\nI : BoxIntegral.Box ι\nH_ind : ∀ (J : BoxIntegral.Box ι), LE.le J I → (∀ (J' : BoxIntegral.Box ι), Membership.mem (BoxIntegral.Prepartition.splitCenter J) J' → p J') → p J\nH_nhds : ∀ (z : ι → Real), Membership.mem (BoxIntegral.Box.Icc I) z → Exists fun U => And (Membership.mem (nhdsWithin z (BoxIntegral.Box.Icc I)) U) (∀ (J : BoxIntegral.Box ι), LE.le J I → ∀ (m : Nat), Membership.mem (BoxIntegral.Box.Icc J) z → HasSubset.Subset (BoxIntegral.Box.Icc J) U → (∀ (i : ι), Eq (HSub.hSub (J.upper i) (J.lower i)) (HDiv.hDiv (HSub.hSub (I.upper i) (I.lower i)) (HPow.hPow 2 m))) → p J)\n⊢ p I","decl":"/-- Let `p` be a predicate on `Box ι`, let `I` be a box. Suppose that the following two properties\nhold true.\n\n* Consider a smaller box `J ≤ I`. The hyperplanes passing through the center of `J` split it into\n  `2 ^ n` boxes. If `p` holds true on each of these boxes, then it true on `J`.\n* For each `z` in the closed box `I.Icc` there exists a neighborhood `U` of `z` within `I.Icc` such\n  that for every box `J ≤ I` such that `z ∈ J.Icc ⊆ U`, if `J` is homothetic to `I` with a\n  coefficient of the form `1 / 2 ^ m`, then `p` is true on `J`.\n\nThen `p I` is true. See also `BoxIntegral.Box.subbox_induction_on'` for a version using\n`BoxIntegral.Box.splitCenterBox` instead of `BoxIntegral.Prepartition.splitCenter`. -/\n@[elab_as_elim]\ntheorem subbox_induction_on {p : Box ι → Prop} (I : Box ι)\n    (H_ind : ∀ J ≤ I, (∀ J' ∈ splitCenter J, p J') → p J)\n    (H_nhds : ∀ z ∈ Box.Icc I, ∃ U ∈ 𝓝[Box.Icc I] z, ∀ J ≤ I, ∀ (m : ℕ),\n      z ∈ Box.Icc J → Box.Icc J ⊆ U →\n        (∀ i, J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) → p J) :\n    p I := by\n  refine subbox_induction_on' I (fun J hle hs => H_ind J hle fun J' h' => ?_) H_nhds\n  rcases mem_splitCenter.1 h' with ⟨s, rfl⟩\n  exact hs s\n\n"}
{"name":"BoxIntegral.Box.exists_taggedPartition_isHenstock_isSubordinate_homothetic","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nr : (ι → Real) → ↑(Set.Ioi 0)\n⊢ Exists fun π => And π.IsPartition (And π.IsHenstock (And (π.IsSubordinate r) (And (∀ (J : BoxIntegral.Box ι), Membership.mem π J → Exists fun m => ∀ (i : ι), Eq (HSub.hSub (J.upper i) (J.lower i)) (HDiv.hDiv (HSub.hSub (I.upper i) (I.lower i)) (HPow.hPow 2 m))) (Eq π.distortion I.distortion))))","decl":"/-- Given a box `I` in `ℝⁿ` and a function `r : ℝⁿ → (0, ∞)`, there exists a tagged partition `π` of\n`I` such that\n\n* `π` is a Henstock partition;\n* `π` is subordinate to `r`;\n* each box in `π` is homothetic to `I` with coefficient of the form `1 / 2 ^ m`.\n\nThis lemma implies that the Henstock filter is nontrivial, hence the Henstock integral is\nwell-defined. -/\ntheorem exists_taggedPartition_isHenstock_isSubordinate_homothetic (I : Box ι)\n    (r : (ι → ℝ) → Ioi (0 : ℝ)) :\n    ∃ π : TaggedPrepartition I, π.IsPartition ∧ π.IsHenstock ∧ π.IsSubordinate r ∧\n      (∀ J ∈ π, ∃ m : ℕ, ∀ i, (J :).upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) ∧\n        π.distortion = I.distortion := by\n  refine subbox_induction_on I (fun J _ hJ => ?_) fun z _ => ?_\n  · choose! πi hP hHen hr Hn _ using hJ\n    choose! n hn using Hn\n    have hP : ((splitCenter J).biUnionTagged πi).IsPartition :=\n      (isPartition_splitCenter _).biUnionTagged hP\n    have hsub : ∀ J' ∈ (splitCenter J).biUnionTagged πi, ∃ n : ℕ, ∀ i,\n        (J' :).upper i - J'.lower i = (J.upper i - J.lower i) / 2 ^ n := by\n      intro J' hJ'\n      rcases (splitCenter J).mem_biUnionTagged.1 hJ' with ⟨J₁, h₁, h₂⟩\n      refine ⟨n J₁ J' + 1, fun i => ?_⟩\n      simp only [hn J₁ h₁ J' h₂, upper_sub_lower_of_mem_splitCenter h₁, pow_succ', div_div]\n    refine ⟨_, hP, isHenstock_biUnionTagged.2 hHen, isSubordinate_biUnionTagged.2 hr, hsub, ?_⟩\n    refine TaggedPrepartition.distortion_of_const _ hP.nonempty_boxes fun J' h' => ?_\n    rcases hsub J' h' with ⟨n, hn⟩\n    exact Box.distortion_eq_of_sub_eq_div hn\n  · refine ⟨Box.Icc I ∩ closedBall z (r z),\n      inter_mem_nhdsWithin _ (closedBall_mem_nhds _ (r z).coe_prop), ?_⟩\n    intro J _ n Hmem HIcc Hsub\n    rw [Set.subset_inter_iff] at HIcc\n    refine ⟨single _ _ le_rfl _ Hmem, isPartition_single _, isHenstock_single _,\n      (isSubordinate_single _ _).2 HIcc.2, ?_, distortion_single _ _⟩\n    simp only [TaggedPrepartition.mem_single, forall_eq]\n    refine ⟨0, fun i => ?_⟩\n    simp\n\n"}
{"name":"BoxIntegral.Prepartition.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nr : (ι → Real) → ↑(Set.Ioi 0)\nπ : BoxIntegral.Prepartition I\n⊢ Exists fun π' => And (LE.le π'.toPrepartition π) (And π'.IsHenstock (And (π'.IsSubordinate r) (And (Eq π'.distortion π.distortion) (Eq π'.iUnion π.iUnion))))","decl":"/-- Given a box `I` in `ℝⁿ`, a function `r : ℝⁿ → (0, ∞)`, and a prepartition `π` of `I`, there\nexists a tagged prepartition `π'` of `I` such that\n\n* each box of `π'` is included in some box of `π`;\n* `π'` is a Henstock partition;\n* `π'` is subordinate to `r`;\n* `π'` covers exactly the same part of `I` as `π`;\n* the distortion of `π'` is equal to the distortion of `π`.\n-/\ntheorem exists_tagged_le_isHenstock_isSubordinate_iUnion_eq {I : Box ι} (r : (ι → ℝ) → Ioi (0 : ℝ))\n    (π : Prepartition I) :\n    ∃ π' : TaggedPrepartition I, π'.toPrepartition ≤ π ∧ π'.IsHenstock ∧ π'.IsSubordinate r ∧\n      π'.distortion = π.distortion ∧ π'.iUnion = π.iUnion := by\n  have := fun J => Box.exists_taggedPartition_isHenstock_isSubordinate_homothetic J r\n  choose! πi πip πiH πir _ πid using this\n  refine ⟨π.biUnionTagged πi, biUnion_le _ _, isHenstock_biUnionTagged.2 fun J _ => πiH J,\n    isSubordinate_biUnionTagged.2 fun J _ => πir J, ?_, π.iUnion_biUnion_partition fun J _ => πip J⟩\n  rw [distortion_biUnionTagged]\n  exact sup_congr rfl fun J _ => πid J\n\n"}
{"name":"BoxIntegral.Prepartition.toSubordinate_toPrepartition_le","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nr : (ι → Real) → ↑(Set.Ioi 0)\n⊢ LE.le (π.toSubordinate r).toPrepartition π","decl":"theorem toSubordinate_toPrepartition_le (π : Prepartition I) (r : (ι → ℝ) → Ioi (0 : ℝ)) :\n    (π.toSubordinate r).toPrepartition ≤ π :=\n  (π.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq r).choose_spec.1\n\n"}
{"name":"BoxIntegral.Prepartition.isHenstock_toSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nr : (ι → Real) → ↑(Set.Ioi 0)\n⊢ (π.toSubordinate r).IsHenstock","decl":"theorem isHenstock_toSubordinate (π : Prepartition I) (r : (ι → ℝ) → Ioi (0 : ℝ)) :\n    (π.toSubordinate r).IsHenstock :=\n  (π.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq r).choose_spec.2.1\n\n"}
{"name":"BoxIntegral.Prepartition.isSubordinate_toSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nr : (ι → Real) → ↑(Set.Ioi 0)\n⊢ (π.toSubordinate r).IsSubordinate r","decl":"theorem isSubordinate_toSubordinate (π : Prepartition I) (r : (ι → ℝ) → Ioi (0 : ℝ)) :\n    (π.toSubordinate r).IsSubordinate r :=\n  (π.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq r).choose_spec.2.2.1\n\n"}
{"name":"BoxIntegral.Prepartition.distortion_toSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nr : (ι → Real) → ↑(Set.Ioi 0)\n⊢ Eq (π.toSubordinate r).distortion π.distortion","decl":"@[simp]\ntheorem distortion_toSubordinate (π : Prepartition I) (r : (ι → ℝ) → Ioi (0 : ℝ)) :\n    (π.toSubordinate r).distortion = π.distortion :=\n  (π.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq r).choose_spec.2.2.2.1\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_toSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nr : (ι → Real) → ↑(Set.Ioi 0)\n⊢ Eq (π.toSubordinate r).iUnion π.iUnion","decl":"@[simp]\ntheorem iUnion_toSubordinate (π : Prepartition I) (r : (ι → ℝ) → Ioi (0 : ℝ)) :\n    (π.toSubordinate r).iUnion = π.iUnion :=\n  (π.exists_tagged_le_isHenstock_isSubordinate_iUnion_eq r).choose_spec.2.2.2.2\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.isPartition_unionComplToSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nπ₁ : BoxIntegral.TaggedPrepartition I\nπ₂ : BoxIntegral.Prepartition I\nhU : Eq π₂.iUnion (SDiff.sdiff (↑I) π₁.iUnion)\nr : (ι → Real) → ↑(Set.Ioi 0)\n⊢ (π₁.unionComplToSubordinate π₂ hU r).IsPartition","decl":"theorem isPartition_unionComplToSubordinate (π₁ : TaggedPrepartition I) (π₂ : Prepartition I)\n    (hU : π₂.iUnion = ↑I \\ π₁.iUnion) (r : (ι → ℝ) → Ioi (0 : ℝ)) :\n    IsPartition (π₁.unionComplToSubordinate π₂ hU r) :=\n  Prepartition.isPartitionDisjUnionOfEqDiff ((π₂.iUnion_toSubordinate r).trans hU)\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.unionComplToSubordinate_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nπ₁ : BoxIntegral.TaggedPrepartition I\nπ₂ : BoxIntegral.Prepartition I\nhU : Eq π₂.iUnion (SDiff.sdiff (↑I) π₁.iUnion)\nr : (ι → Real) → ↑(Set.Ioi 0)\n⊢ Eq (π₁.unionComplToSubordinate π₂ hU r).boxes (Union.union π₁.boxes (π₂.toSubordinate r).boxes)","decl":"open scoped Classical in\n@[simp]\ntheorem unionComplToSubordinate_boxes (π₁ : TaggedPrepartition I) (π₂ : Prepartition I)\n    (hU : π₂.iUnion = ↑I \\ π₁.iUnion) (r : (ι → ℝ) → Ioi (0 : ℝ)) :\n    (π₁.unionComplToSubordinate π₂ hU r).boxes = π₁.boxes ∪ (π₂.toSubordinate r).boxes := rfl\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.iUnion_unionComplToSubordinate_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nπ₁ : BoxIntegral.TaggedPrepartition I\nπ₂ : BoxIntegral.Prepartition I\nhU : Eq π₂.iUnion (SDiff.sdiff (↑I) π₁.iUnion)\nr : (ι → Real) → ↑(Set.Ioi 0)\n⊢ Eq (π₁.unionComplToSubordinate π₂ hU r).iUnion ↑I","decl":"@[simp]\ntheorem iUnion_unionComplToSubordinate_boxes (π₁ : TaggedPrepartition I) (π₂ : Prepartition I)\n    (hU : π₂.iUnion = ↑I \\ π₁.iUnion) (r : (ι → ℝ) → Ioi (0 : ℝ)) :\n    (π₁.unionComplToSubordinate π₂ hU r).iUnion = I :=\n  (isPartition_unionComplToSubordinate _ _ _ _).iUnion_eq\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.distortion_unionComplToSubordinate","module":"Mathlib.Analysis.BoxIntegral.Partition.SubboxInduction","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\nπ₁ : BoxIntegral.TaggedPrepartition I\nπ₂ : BoxIntegral.Prepartition I\nhU : Eq π₂.iUnion (SDiff.sdiff (↑I) π₁.iUnion)\nr : (ι → Real) → ↑(Set.Ioi 0)\n⊢ Eq (π₁.unionComplToSubordinate π₂ hU r).distortion (Max.max π₁.distortion π₂.distortion)","decl":"@[simp]\ntheorem distortion_unionComplToSubordinate (π₁ : TaggedPrepartition I) (π₂ : Prepartition I)\n    (hU : π₂.iUnion = ↑I \\ π₁.iUnion) (r : (ι → ℝ) → Ioi (0 : ℝ)) :\n    (π₁.unionComplToSubordinate π₂ hU r).distortion = max π₁.distortion π₂.distortion := by\n  simp [unionComplToSubordinate]\n\n"}
