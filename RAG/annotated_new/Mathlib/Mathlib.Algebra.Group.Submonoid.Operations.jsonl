{"name":"Submonoid.coe_toAddSubmonoid_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Eq (↑(Submonoid.toAddSubmonoid S)) (Set.preimage ⇑Additive.toMul ↑S)","decl":"/-- Submonoids of monoid `M` are isomorphic to additive submonoids of `Additive M`. -/\n@[simps]\ndef Submonoid.toAddSubmonoid : Submonoid M ≃o AddSubmonoid (Additive M) where\n  toFun S :=\n    { carrier := Additive.toMul ⁻¹' S\n      zero_mem' := S.one_mem'\n      add_mem' := fun ha hb => S.mul_mem' ha hb }\n  invFun S :=\n    { carrier := Additive.ofMul ⁻¹' S\n      one_mem' := S.zero_mem'\n      mul_mem' := fun ha hb => S.add_mem' ha hb}\n  left_inv x := by cases x; rfl\n  right_inv x := by cases x; rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"Submonoid.coe_toAddSubmonoid_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : AddSubmonoid (Additive M)\n⊢ Eq (↑((RelIso.symm Submonoid.toAddSubmonoid) S)) (Set.preimage ⇑Additive.ofMul ↑S)","decl":"/-- Submonoids of monoid `M` are isomorphic to additive submonoids of `Additive M`. -/\n@[simps]\ndef Submonoid.toAddSubmonoid : Submonoid M ≃o AddSubmonoid (Additive M) where\n  toFun S :=\n    { carrier := Additive.toMul ⁻¹' S\n      zero_mem' := S.one_mem'\n      add_mem' := fun ha hb => S.mul_mem' ha hb }\n  invFun S :=\n    { carrier := Additive.ofMul ⁻¹' S\n      one_mem' := S.zero_mem'\n      mul_mem' := fun ha hb => S.add_mem' ha hb}\n  left_inv x := by cases x; rfl\n  right_inv x := by cases x; rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"Submonoid.toAddSubmonoid_closure","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Set M\n⊢ Eq (Submonoid.toAddSubmonoid (Submonoid.closure S)) (AddSubmonoid.closure (Set.preimage (⇑Additive.toMul) S))","decl":"theorem Submonoid.toAddSubmonoid_closure (S : Set M) :\n    Submonoid.toAddSubmonoid (Submonoid.closure S)\n      = AddSubmonoid.closure (Additive.toMul ⁻¹' S) :=\n  le_antisymm\n    (Submonoid.toAddSubmonoid.le_symm_apply.1 <|\n      Submonoid.closure_le.2 (AddSubmonoid.subset_closure (M := Additive M)))\n    (AddSubmonoid.closure_le.2 <| Submonoid.subset_closure (M := M))\n\n"}
{"name":"AddSubmonoid.toSubmonoid'_closure","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Set (Additive M)\n⊢ Eq (AddSubmonoid.toSubmonoid' (AddSubmonoid.closure S)) (Submonoid.closure (Set.preimage (⇑Multiplicative.ofAdd) S))","decl":"theorem AddSubmonoid.toSubmonoid'_closure (S : Set (Additive M)) :\n    AddSubmonoid.toSubmonoid' (AddSubmonoid.closure S)\n      = Submonoid.closure (Multiplicative.ofAdd ⁻¹' S) :=\n  le_antisymm\n    (AddSubmonoid.toSubmonoid'.le_symm_apply.1 <|\n      AddSubmonoid.closure_le.2 (Submonoid.subset_closure (M := M)))\n    (Submonoid.closure_le.2 <| AddSubmonoid.subset_closure (M := Additive M))\n\n"}
{"name":"AddSubmonoid.coe_toSubmonoid_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"A : Type u_4\ninst✝ : AddZeroClass A\nS : Submonoid (Multiplicative A)\n⊢ Eq (↑((RelIso.symm AddSubmonoid.toSubmonoid) S)) (Set.preimage ⇑Multiplicative.ofAdd ↑S)","decl":"/-- Additive submonoids of an additive monoid `A` are isomorphic to\nmultiplicative submonoids of `Multiplicative A`. -/\n@[simps]\ndef AddSubmonoid.toSubmonoid : AddSubmonoid A ≃o Submonoid (Multiplicative A) where\n  toFun S :=\n    { carrier := Multiplicative.toAdd ⁻¹' S\n      one_mem' := S.zero_mem'\n      mul_mem' := fun ha hb => S.add_mem' ha hb }\n  invFun S :=\n    { carrier := Multiplicative.ofAdd ⁻¹' S\n      zero_mem' := S.one_mem'\n      add_mem' := fun ha hb => S.mul_mem' ha hb}\n  left_inv x := by cases x; rfl\n  right_inv x := by cases x; rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"AddSubmonoid.coe_toSubmonoid_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"A : Type u_4\ninst✝ : AddZeroClass A\nS : AddSubmonoid A\n⊢ Eq (↑(AddSubmonoid.toSubmonoid S)) (Set.preimage ⇑Multiplicative.toAdd ↑S)","decl":"/-- Additive submonoids of an additive monoid `A` are isomorphic to\nmultiplicative submonoids of `Multiplicative A`. -/\n@[simps]\ndef AddSubmonoid.toSubmonoid : AddSubmonoid A ≃o Submonoid (Multiplicative A) where\n  toFun S :=\n    { carrier := Multiplicative.toAdd ⁻¹' S\n      one_mem' := S.zero_mem'\n      mul_mem' := fun ha hb => S.add_mem' ha hb }\n  invFun S :=\n    { carrier := Multiplicative.ofAdd ⁻¹' S\n      zero_mem' := S.one_mem'\n      add_mem' := fun ha hb => S.mul_mem' ha hb}\n  left_inv x := by cases x; rfl\n  right_inv x := by cases x; rfl\n  map_rel_iff' := Iff.rfl\n\n"}
{"name":"AddSubmonoid.toSubmonoid_closure","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"A : Type u_4\ninst✝ : AddZeroClass A\nS : Set A\n⊢ Eq (AddSubmonoid.toSubmonoid (AddSubmonoid.closure S)) (Submonoid.closure (Set.preimage (⇑Multiplicative.toAdd) S))","decl":"theorem AddSubmonoid.toSubmonoid_closure (S : Set A) :\n    (AddSubmonoid.toSubmonoid) (AddSubmonoid.closure S)\n      = Submonoid.closure (Multiplicative.toAdd ⁻¹' S) :=\n  le_antisymm\n    (AddSubmonoid.toSubmonoid.to_galoisConnection.l_le <|\n      AddSubmonoid.closure_le.2 <| Submonoid.subset_closure (M := Multiplicative A))\n    (Submonoid.closure_le.2 <| AddSubmonoid.subset_closure (M := A))\n\n"}
{"name":"Submonoid.toAddSubmonoid'_closure","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"A : Type u_4\ninst✝ : AddZeroClass A\nS : Set (Multiplicative A)\n⊢ Eq (Submonoid.toAddSubmonoid' (Submonoid.closure S)) (AddSubmonoid.closure (Set.preimage (⇑Additive.ofMul) S))","decl":"theorem Submonoid.toAddSubmonoid'_closure (S : Set (Multiplicative A)) :\n    Submonoid.toAddSubmonoid' (Submonoid.closure S)\n      = AddSubmonoid.closure (Additive.ofMul ⁻¹' S) :=\n  le_antisymm\n    (Submonoid.toAddSubmonoid'.to_galoisConnection.l_le <|\n      Submonoid.closure_le.2 <| AddSubmonoid.subset_closure (M := A))\n    (AddSubmonoid.closure_le.2 <| Submonoid.subset_closure (M := Multiplicative A))\n\n"}
{"name":"Submonoid.coe_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nS : Submonoid N\nf : F\n⊢ Eq (↑(Submonoid.comap f S)) (Set.preimage ⇑f ↑S)","decl":"@[to_additive (attr := simp)]\ntheorem coe_comap (S : Submonoid N) (f : F) : (S.comap f : Set M) = f ⁻¹' S :=\n  rfl\n\n"}
{"name":"AddSubmonoid.coe_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nS : AddSubmonoid N\nf : F\n⊢ Eq (↑(AddSubmonoid.comap f S)) (Set.preimage ⇑f ↑S)","decl":"@[to_additive (attr := simp)]\ntheorem coe_comap (S : Submonoid N) (f : F) : (S.comap f : Set M) = f ⁻¹' S :=\n  rfl\n\n"}
{"name":"Submonoid.mem_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nS : Submonoid N\nf : F\nx : M\n⊢ Iff (Membership.mem (Submonoid.comap f S) x) (Membership.mem S (f x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_comap {S : Submonoid N} {f : F} {x : M} : x ∈ S.comap f ↔ f x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"AddSubmonoid.mem_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nS : AddSubmonoid N\nf : F\nx : M\n⊢ Iff (Membership.mem (AddSubmonoid.comap f S) x) (Membership.mem S (f x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_comap {S : Submonoid N} {f : F} {x : M} : x ∈ S.comap f ↔ f x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"Submonoid.comap_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nS : Submonoid P\ng : MonoidHom N P\nf : MonoidHom M N\n⊢ Eq (Submonoid.comap f (Submonoid.comap g S)) (Submonoid.comap (g.comp f) S)","decl":"@[to_additive]\ntheorem comap_comap (S : Submonoid P) (g : N →* P) (f : M →* N) :\n    (S.comap g).comap f = S.comap (g.comp f) :=\n  rfl\n\n"}
{"name":"AddSubmonoid.comap_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nS : AddSubmonoid P\ng : AddMonoidHom N P\nf : AddMonoidHom M N\n⊢ Eq (AddSubmonoid.comap f (AddSubmonoid.comap g S)) (AddSubmonoid.comap (g.comp f) S)","decl":"@[to_additive]\ntheorem comap_comap (S : Submonoid P) (g : N →* P) (f : M →* N) :\n    (S.comap g).comap f = S.comap (g.comp f) :=\n  rfl\n\n"}
{"name":"Submonoid.comap_id","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"P : Type u_3\ninst✝ : MulOneClass P\nS : Submonoid P\n⊢ Eq (Submonoid.comap (MonoidHom.id P) S) S","decl":"@[to_additive (attr := simp)]\ntheorem comap_id (S : Submonoid P) : S.comap (MonoidHom.id P) = S :=\n  ext (by simp)\n\n"}
{"name":"AddSubmonoid.comap_id","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"P : Type u_3\ninst✝ : AddZeroClass P\nS : AddSubmonoid P\n⊢ Eq (AddSubmonoid.comap (AddMonoidHom.id P) S) S","decl":"@[to_additive (attr := simp)]\ntheorem comap_id (S : Submonoid P) : S.comap (MonoidHom.id P) = S :=\n  ext (by simp)\n\n"}
{"name":"Submonoid.coe_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nS : Submonoid M\n⊢ Eq (↑(Submonoid.map f S)) (Set.image ⇑f ↑S)","decl":"@[to_additive (attr := simp)]\ntheorem coe_map (f : F) (S : Submonoid M) : (S.map f : Set N) = f '' S :=\n  rfl\n\n"}
{"name":"AddSubmonoid.coe_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nS : AddSubmonoid M\n⊢ Eq (↑(AddSubmonoid.map f S)) (Set.image ⇑f ↑S)","decl":"@[to_additive (attr := simp)]\ntheorem coe_map (f : F) (S : Submonoid M) : (S.map f : Set N) = f '' S :=\n  rfl\n\n"}
{"name":"AddSubmonoid.mem_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nS : AddSubmonoid M\ny : N\n⊢ Iff (Membership.mem (AddSubmonoid.map f S) y) (Exists fun x => And (Membership.mem S x) (Eq (f x) y))","decl":"@[to_additive (attr := simp)]\ntheorem mem_map {f : F} {S : Submonoid M} {y : N} : y ∈ S.map f ↔ ∃ x ∈ S, f x = y := Iff.rfl\n\n"}
{"name":"Submonoid.mem_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nS : Submonoid M\ny : N\n⊢ Iff (Membership.mem (Submonoid.map f S) y) (Exists fun x => And (Membership.mem S x) (Eq (f x) y))","decl":"@[to_additive (attr := simp)]\ntheorem mem_map {f : F} {S : Submonoid M} {y : N} : y ∈ S.map f ↔ ∃ x ∈ S, f x = y := Iff.rfl\n\n"}
{"name":"Submonoid.mem_map_of_mem","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nS : Submonoid M\nx : M\nhx : Membership.mem S x\n⊢ Membership.mem (Submonoid.map f S) (f x)","decl":"@[to_additive]\ntheorem mem_map_of_mem (f : F) {S : Submonoid M} {x : M} (hx : x ∈ S) : f x ∈ S.map f :=\n  mem_image_of_mem f hx\n\n"}
{"name":"AddSubmonoid.mem_map_of_mem","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nS : AddSubmonoid M\nx : M\nhx : Membership.mem S x\n⊢ Membership.mem (AddSubmonoid.map f S) (f x)","decl":"@[to_additive]\ntheorem mem_map_of_mem (f : F) {S : Submonoid M} {x : M} (hx : x ∈ S) : f x ∈ S.map f :=\n  mem_image_of_mem f hx\n\n"}
{"name":"AddSubmonoid.apply_coe_mem_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nS : AddSubmonoid M\nx : Subtype fun x => Membership.mem S x\n⊢ Membership.mem (AddSubmonoid.map f S) (f ↑x)","decl":"@[to_additive]\ntheorem apply_coe_mem_map (f : F) (S : Submonoid M) (x : S) : f x ∈ S.map f :=\n  mem_map_of_mem f x.2\n\n"}
{"name":"Submonoid.apply_coe_mem_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nS : Submonoid M\nx : Subtype fun x => Membership.mem S x\n⊢ Membership.mem (Submonoid.map f S) (f ↑x)","decl":"@[to_additive]\ntheorem apply_coe_mem_map (f : F) (S : Submonoid M) (x : S) : f x ∈ S.map f :=\n  mem_map_of_mem f x.2\n\n"}
{"name":"Submonoid.map_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nS : Submonoid M\ng : MonoidHom N P\nf : MonoidHom M N\n⊢ Eq (Submonoid.map g (Submonoid.map f S)) (Submonoid.map (g.comp f) S)","decl":"@[to_additive]\ntheorem map_map (g : N →* P) (f : M →* N) : (S.map f).map g = S.map (g.comp f) :=\n  SetLike.coe_injective <| image_image _ _ _\n\n-- The simpNF linter says that the LHS can be simplified via `Submonoid.mem_map`.\n-- However this is a higher priority lemma.\n-- https://github.com/leanprover/std4/issues/207\n"}
{"name":"AddSubmonoid.map_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nS : AddSubmonoid M\ng : AddMonoidHom N P\nf : AddMonoidHom M N\n⊢ Eq (AddSubmonoid.map g (AddSubmonoid.map f S)) (AddSubmonoid.map (g.comp f) S)","decl":"@[to_additive]\ntheorem map_map (g : N →* P) (f : M →* N) : (S.map f).map g = S.map (g.comp f) :=\n  SetLike.coe_injective <| image_image _ _ _\n\n-- The simpNF linter says that the LHS can be simplified via `Submonoid.mem_map`.\n-- However this is a higher priority lemma.\n-- https://github.com/leanprover/std4/issues/207\n"}
{"name":"AddSubmonoid.mem_map_iff_mem","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\nS : AddSubmonoid M\nx : M\n⊢ Iff (Membership.mem (AddSubmonoid.map f S) (f x)) (Membership.mem S x)","decl":"@[to_additive (attr := simp 1100, nolint simpNF)]\ntheorem mem_map_iff_mem {f : F} (hf : Function.Injective f) {S : Submonoid M} {x : M} :\n    f x ∈ S.map f ↔ x ∈ S :=\n  hf.mem_set_image\n\n"}
{"name":"Submonoid.mem_map_iff_mem","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\nS : Submonoid M\nx : M\n⊢ Iff (Membership.mem (Submonoid.map f S) (f x)) (Membership.mem S x)","decl":"@[to_additive (attr := simp 1100, nolint simpNF)]\ntheorem mem_map_iff_mem {f : F} (hf : Function.Injective f) {S : Submonoid M} {x : M} :\n    f x ∈ S.map f ↔ x ∈ S :=\n  hf.mem_set_image\n\n"}
{"name":"Submonoid.map_le_iff_le_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nS : Submonoid M\nT : Submonoid N\n⊢ Iff (LE.le (Submonoid.map f S) T) (LE.le S (Submonoid.comap f T))","decl":"@[to_additive]\ntheorem map_le_iff_le_comap {f : F} {S : Submonoid M} {T : Submonoid N} :\n    S.map f ≤ T ↔ S ≤ T.comap f :=\n  image_subset_iff\n\n"}
{"name":"AddSubmonoid.map_le_iff_le_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nS : AddSubmonoid M\nT : AddSubmonoid N\n⊢ Iff (LE.le (AddSubmonoid.map f S) T) (LE.le S (AddSubmonoid.comap f T))","decl":"@[to_additive]\ntheorem map_le_iff_le_comap {f : F} {S : Submonoid M} {T : Submonoid N} :\n    S.map f ≤ T ↔ S ≤ T.comap f :=\n  image_subset_iff\n\n"}
{"name":"Submonoid.gc_map_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ GaloisConnection (Submonoid.map f) (Submonoid.comap f)","decl":"@[to_additive]\ntheorem gc_map_comap (f : F) : GaloisConnection (map f) (comap f) := fun _ _ => map_le_iff_le_comap\n\n"}
{"name":"AddSubmonoid.gc_map_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\n⊢ GaloisConnection (AddSubmonoid.map f) (AddSubmonoid.comap f)","decl":"@[to_additive]\ntheorem gc_map_comap (f : F) : GaloisConnection (map f) (comap f) := fun _ _ => map_le_iff_le_comap\n\n"}
{"name":"Submonoid.map_le_of_le_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nS : Submonoid M\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nT : Submonoid N\nf : F\na✝ : LE.le S (Submonoid.comap f T)\n⊢ LE.le (Submonoid.map f S) T","decl":"@[to_additive]\ntheorem map_le_of_le_comap {T : Submonoid N} {f : F} : S ≤ T.comap f → S.map f ≤ T :=\n  (gc_map_comap f).l_le\n\n"}
{"name":"AddSubmonoid.map_le_of_le_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nS : AddSubmonoid M\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nT : AddSubmonoid N\nf : F\na✝ : LE.le S (AddSubmonoid.comap f T)\n⊢ LE.le (AddSubmonoid.map f S) T","decl":"@[to_additive]\ntheorem map_le_of_le_comap {T : Submonoid N} {f : F} : S ≤ T.comap f → S.map f ≤ T :=\n  (gc_map_comap f).l_le\n\n"}
{"name":"AddSubmonoid.le_comap_of_map_le","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nS : AddSubmonoid M\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nT : AddSubmonoid N\nf : F\na✝ : LE.le (AddSubmonoid.map f S) T\n⊢ LE.le S (AddSubmonoid.comap f T)","decl":"@[to_additive]\ntheorem le_comap_of_map_le {T : Submonoid N} {f : F} : S.map f ≤ T → S ≤ T.comap f :=\n  (gc_map_comap f).le_u\n\n"}
{"name":"Submonoid.le_comap_of_map_le","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nS : Submonoid M\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nT : Submonoid N\nf : F\na✝ : LE.le (Submonoid.map f S) T\n⊢ LE.le S (Submonoid.comap f T)","decl":"@[to_additive]\ntheorem le_comap_of_map_le {T : Submonoid N} {f : F} : S.map f ≤ T → S ≤ T.comap f :=\n  (gc_map_comap f).le_u\n\n"}
{"name":"Submonoid.le_comap_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nS : Submonoid M\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ LE.le S (Submonoid.comap f (Submonoid.map f S))","decl":"@[to_additive]\ntheorem le_comap_map {f : F} : S ≤ (S.map f).comap f :=\n  (gc_map_comap f).le_u_l _\n\n"}
{"name":"AddSubmonoid.le_comap_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nS : AddSubmonoid M\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\n⊢ LE.le S (AddSubmonoid.comap f (AddSubmonoid.map f S))","decl":"@[to_additive]\ntheorem le_comap_map {f : F} : S ≤ (S.map f).comap f :=\n  (gc_map_comap f).le_u_l _\n\n"}
{"name":"AddSubmonoid.map_comap_le","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nS : AddSubmonoid N\nf : F\n⊢ LE.le (AddSubmonoid.map f (AddSubmonoid.comap f S)) S","decl":"@[to_additive]\ntheorem map_comap_le {S : Submonoid N} {f : F} : (S.comap f).map f ≤ S :=\n  (gc_map_comap f).l_u_le _\n\n"}
{"name":"Submonoid.map_comap_le","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nS : Submonoid N\nf : F\n⊢ LE.le (Submonoid.map f (Submonoid.comap f S)) S","decl":"@[to_additive]\ntheorem map_comap_le {S : Submonoid N} {f : F} : (S.comap f).map f ≤ S :=\n  (gc_map_comap f).l_u_le _\n\n"}
{"name":"Submonoid.monotone_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ Monotone (Submonoid.map f)","decl":"@[to_additive]\ntheorem monotone_map {f : F} : Monotone (map f) :=\n  (gc_map_comap f).monotone_l\n\n"}
{"name":"AddSubmonoid.monotone_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\n⊢ Monotone (AddSubmonoid.map f)","decl":"@[to_additive]\ntheorem monotone_map {f : F} : Monotone (map f) :=\n  (gc_map_comap f).monotone_l\n\n"}
{"name":"Submonoid.monotone_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ Monotone (Submonoid.comap f)","decl":"@[to_additive]\ntheorem monotone_comap {f : F} : Monotone (comap f) :=\n  (gc_map_comap f).monotone_u\n\n"}
{"name":"AddSubmonoid.monotone_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\n⊢ Monotone (AddSubmonoid.comap f)","decl":"@[to_additive]\ntheorem monotone_comap {f : F} : Monotone (comap f) :=\n  (gc_map_comap f).monotone_u\n\n"}
{"name":"AddSubmonoid.map_comap_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nS : AddSubmonoid M\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\n⊢ Eq (AddSubmonoid.map f (AddSubmonoid.comap f (AddSubmonoid.map f S))) (AddSubmonoid.map f S)","decl":"@[to_additive (attr := simp)]\ntheorem map_comap_map {f : F} : ((S.map f).comap f).map f = S.map f :=\n  (gc_map_comap f).l_u_l_eq_l _\n\n"}
{"name":"Submonoid.map_comap_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nS : Submonoid M\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ Eq (Submonoid.map f (Submonoid.comap f (Submonoid.map f S))) (Submonoid.map f S)","decl":"@[to_additive (attr := simp)]\ntheorem map_comap_map {f : F} : ((S.map f).comap f).map f = S.map f :=\n  (gc_map_comap f).l_u_l_eq_l _\n\n"}
{"name":"Submonoid.comap_map_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nS : Submonoid N\nf : F\n⊢ Eq (Submonoid.comap f (Submonoid.map f (Submonoid.comap f S))) (Submonoid.comap f S)","decl":"@[to_additive (attr := simp)]\ntheorem comap_map_comap {S : Submonoid N} {f : F} : ((S.comap f).map f).comap f = S.comap f :=\n  (gc_map_comap f).u_l_u_eq_u _\n\n"}
{"name":"AddSubmonoid.comap_map_comap","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nS : AddSubmonoid N\nf : F\n⊢ Eq (AddSubmonoid.comap f (AddSubmonoid.map f (AddSubmonoid.comap f S))) (AddSubmonoid.comap f S)","decl":"@[to_additive (attr := simp)]\ntheorem comap_map_comap {S : Submonoid N} {f : F} : ((S.comap f).map f).comap f = S.comap f :=\n  (gc_map_comap f).u_l_u_eq_u _\n\n"}
{"name":"Submonoid.map_sup","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nS T : Submonoid M\nf : F\n⊢ Eq (Submonoid.map f (Max.max S T)) (Max.max (Submonoid.map f S) (Submonoid.map f T))","decl":"@[to_additive]\ntheorem map_sup (S T : Submonoid M) (f : F) : (S ⊔ T).map f = S.map f ⊔ T.map f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_sup\n\n"}
{"name":"AddSubmonoid.map_sup","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nS T : AddSubmonoid M\nf : F\n⊢ Eq (AddSubmonoid.map f (Max.max S T)) (Max.max (AddSubmonoid.map f S) (AddSubmonoid.map f T))","decl":"@[to_additive]\ntheorem map_sup (S T : Submonoid M) (f : F) : (S ⊔ T).map f = S.map f ⊔ T.map f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_sup\n\n"}
{"name":"AddSubmonoid.map_iSup","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nι : Sort u_5\nf : F\ns : ι → AddSubmonoid M\n⊢ Eq (AddSubmonoid.map f (iSup s)) (iSup fun i => AddSubmonoid.map f (s i))","decl":"@[to_additive]\ntheorem map_iSup {ι : Sort*} (f : F) (s : ι → Submonoid M) : (iSup s).map f = ⨆ i, (s i).map f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_iSup\n\n"}
{"name":"Submonoid.map_iSup","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nι : Sort u_5\nf : F\ns : ι → Submonoid M\n⊢ Eq (Submonoid.map f (iSup s)) (iSup fun i => Submonoid.map f (s i))","decl":"@[to_additive]\ntheorem map_iSup {ι : Sort*} (f : F) (s : ι → Submonoid M) : (iSup s).map f = ⨆ i, (s i).map f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_iSup\n\n"}
{"name":"AddSubmonoid.map_inf","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nS T : AddSubmonoid M\nf : F\nhf : Function.Injective ⇑f\n⊢ Eq (AddSubmonoid.map f (Min.min S T)) (Min.min (AddSubmonoid.map f S) (AddSubmonoid.map f T))","decl":"@[to_additive]\ntheorem map_inf (S T : Submonoid M) (f : F) (hf : Function.Injective f) :\n    (S ⊓ T).map f = S.map f ⊓ T.map f := SetLike.coe_injective (Set.image_inter hf)\n\n"}
{"name":"Submonoid.map_inf","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nS T : Submonoid M\nf : F\nhf : Function.Injective ⇑f\n⊢ Eq (Submonoid.map f (Min.min S T)) (Min.min (Submonoid.map f S) (Submonoid.map f T))","decl":"@[to_additive]\ntheorem map_inf (S T : Submonoid M) (f : F) (hf : Function.Injective f) :\n    (S ⊓ T).map f = S.map f ⊓ T.map f := SetLike.coe_injective (Set.image_inter hf)\n\n"}
{"name":"Submonoid.map_iInf","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\nF : Type u_4\ninst✝¹ : FunLike F M N\nmc : MonoidHomClass F M N\nι : Sort u_5\ninst✝ : Nonempty ι\nf : F\nhf : Function.Injective ⇑f\ns : ι → Submonoid M\n⊢ Eq (Submonoid.map f (iInf s)) (iInf fun i => Submonoid.map f (s i))","decl":"@[to_additive]\ntheorem map_iInf {ι : Sort*} [Nonempty ι] (f : F) (hf : Function.Injective f)\n    (s : ι → Submonoid M) : (iInf s).map f = ⨅ i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe ∘ s)\n\n"}
{"name":"AddSubmonoid.map_iInf","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\nF : Type u_4\ninst✝¹ : FunLike F M N\nmc : AddMonoidHomClass F M N\nι : Sort u_5\ninst✝ : Nonempty ι\nf : F\nhf : Function.Injective ⇑f\ns : ι → AddSubmonoid M\n⊢ Eq (AddSubmonoid.map f (iInf s)) (iInf fun i => AddSubmonoid.map f (s i))","decl":"@[to_additive]\ntheorem map_iInf {ι : Sort*} [Nonempty ι] (f : F) (hf : Function.Injective f)\n    (s : ι → Submonoid M) : (iInf s).map f = ⨅ i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe ∘ s)\n\n"}
{"name":"AddSubmonoid.comap_inf","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nS T : AddSubmonoid N\nf : F\n⊢ Eq (AddSubmonoid.comap f (Min.min S T)) (Min.min (AddSubmonoid.comap f S) (AddSubmonoid.comap f T))","decl":"@[to_additive]\ntheorem comap_inf (S T : Submonoid N) (f : F) : (S ⊓ T).comap f = S.comap f ⊓ T.comap f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_inf\n\n"}
{"name":"Submonoid.comap_inf","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nS T : Submonoid N\nf : F\n⊢ Eq (Submonoid.comap f (Min.min S T)) (Min.min (Submonoid.comap f S) (Submonoid.comap f T))","decl":"@[to_additive]\ntheorem comap_inf (S T : Submonoid N) (f : F) : (S ⊓ T).comap f = S.comap f ⊓ T.comap f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_inf\n\n"}
{"name":"AddSubmonoid.comap_iInf","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nι : Sort u_5\nf : F\ns : ι → AddSubmonoid N\n⊢ Eq (AddSubmonoid.comap f (iInf s)) (iInf fun i => AddSubmonoid.comap f (s i))","decl":"@[to_additive]\ntheorem comap_iInf {ι : Sort*} (f : F) (s : ι → Submonoid N) :\n    (iInf s).comap f = ⨅ i, (s i).comap f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_iInf\n\n"}
{"name":"Submonoid.comap_iInf","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nι : Sort u_5\nf : F\ns : ι → Submonoid N\n⊢ Eq (Submonoid.comap f (iInf s)) (iInf fun i => Submonoid.comap f (s i))","decl":"@[to_additive]\ntheorem comap_iInf {ι : Sort*} (f : F) (s : ι → Submonoid N) :\n    (iInf s).comap f = ⨅ i, (s i).comap f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_iInf\n\n"}
{"name":"Submonoid.map_bot","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ Eq (Submonoid.map f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem map_bot (f : F) : (⊥ : Submonoid M).map f = ⊥ :=\n  (gc_map_comap f).l_bot\n\n"}
{"name":"AddSubmonoid.map_bot","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\n⊢ Eq (AddSubmonoid.map f Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem map_bot (f : F) : (⊥ : Submonoid M).map f = ⊥ :=\n  (gc_map_comap f).l_bot\n\n"}
{"name":"Submonoid.comap_top","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ Eq (Submonoid.comap f Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem comap_top (f : F) : (⊤ : Submonoid N).comap f = ⊤ :=\n  (gc_map_comap f).u_top\n\n"}
{"name":"AddSubmonoid.comap_top","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\n⊢ Eq (AddSubmonoid.comap f Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem comap_top (f : F) : (⊤ : Submonoid N).comap f = ⊤ :=\n  (gc_map_comap f).u_top\n\n"}
{"name":"AddSubmonoid.map_id","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Eq (AddSubmonoid.map (AddMonoidHom.id M) S) S","decl":"@[to_additive (attr := simp)]\ntheorem map_id (S : Submonoid M) : S.map (MonoidHom.id M) = S :=\n  ext fun _ => ⟨fun ⟨_, h, rfl⟩ => h, fun h => ⟨_, h, rfl⟩⟩\n\n"}
{"name":"Submonoid.map_id","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Eq (Submonoid.map (MonoidHom.id M) S) S","decl":"@[to_additive (attr := simp)]\ntheorem map_id (S : Submonoid M) : S.map (MonoidHom.id M) = S :=\n  ext fun _ => ⟨fun ⟨_, h, rfl⟩ => h, fun h => ⟨_, h, rfl⟩⟩\n\n"}
{"name":"Submonoid.comap_map_eq_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\nS : Submonoid M\n⊢ Eq (Submonoid.comap f (Submonoid.map f S)) S","decl":"@[to_additive]\ntheorem comap_map_eq_of_injective (S : Submonoid M) : (S.map f).comap f = S :=\n  (gciMapComap hf).u_l_eq _\n\n"}
{"name":"AddSubmonoid.comap_map_eq_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\nS : AddSubmonoid M\n⊢ Eq (AddSubmonoid.comap f (AddSubmonoid.map f S)) S","decl":"@[to_additive]\ntheorem comap_map_eq_of_injective (S : Submonoid M) : (S.map f).comap f = S :=\n  (gciMapComap hf).u_l_eq _\n\n"}
{"name":"Submonoid.comap_surjective_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\n⊢ Function.Surjective (Submonoid.comap f)","decl":"@[to_additive]\ntheorem comap_surjective_of_injective : Function.Surjective (comap f) :=\n  (gciMapComap hf).u_surjective\n\n"}
{"name":"AddSubmonoid.comap_surjective_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\n⊢ Function.Surjective (AddSubmonoid.comap f)","decl":"@[to_additive]\ntheorem comap_surjective_of_injective : Function.Surjective (comap f) :=\n  (gciMapComap hf).u_surjective\n\n"}
{"name":"Submonoid.map_injective_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\n⊢ Function.Injective (Submonoid.map f)","decl":"@[to_additive]\ntheorem map_injective_of_injective : Function.Injective (map f) :=\n  (gciMapComap hf).l_injective\n\n"}
{"name":"AddSubmonoid.map_injective_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\n⊢ Function.Injective (AddSubmonoid.map f)","decl":"@[to_additive]\ntheorem map_injective_of_injective : Function.Injective (map f) :=\n  (gciMapComap hf).l_injective\n\n"}
{"name":"Submonoid.comap_inf_map_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\nS T : Submonoid M\n⊢ Eq (Submonoid.comap f (Min.min (Submonoid.map f S) (Submonoid.map f T))) (Min.min S T)","decl":"@[to_additive]\ntheorem comap_inf_map_of_injective (S T : Submonoid M) : (S.map f ⊓ T.map f).comap f = S ⊓ T :=\n  (gciMapComap hf).u_inf_l _ _\n\n"}
{"name":"AddSubmonoid.comap_inf_map_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\nS T : AddSubmonoid M\n⊢ Eq (AddSubmonoid.comap f (Min.min (AddSubmonoid.map f S) (AddSubmonoid.map f T))) (Min.min S T)","decl":"@[to_additive]\ntheorem comap_inf_map_of_injective (S T : Submonoid M) : (S.map f ⊓ T.map f).comap f = S ⊓ T :=\n  (gciMapComap hf).u_inf_l _ _\n\n"}
{"name":"Submonoid.comap_iInf_map_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nι : Type u_5\nf : F\nhf : Function.Injective ⇑f\nS : ι → Submonoid M\n⊢ Eq (Submonoid.comap f (iInf fun i => Submonoid.map f (S i))) (iInf S)","decl":"@[to_additive]\ntheorem comap_iInf_map_of_injective (S : ι → Submonoid M) : (⨅ i, (S i).map f).comap f = iInf S :=\n  (gciMapComap hf).u_iInf_l _\n\n"}
{"name":"AddSubmonoid.comap_iInf_map_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nι : Type u_5\nf : F\nhf : Function.Injective ⇑f\nS : ι → AddSubmonoid M\n⊢ Eq (AddSubmonoid.comap f (iInf fun i => AddSubmonoid.map f (S i))) (iInf S)","decl":"@[to_additive]\ntheorem comap_iInf_map_of_injective (S : ι → Submonoid M) : (⨅ i, (S i).map f).comap f = iInf S :=\n  (gciMapComap hf).u_iInf_l _\n\n"}
{"name":"Submonoid.comap_sup_map_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\nS T : Submonoid M\n⊢ Eq (Submonoid.comap f (Max.max (Submonoid.map f S) (Submonoid.map f T))) (Max.max S T)","decl":"@[to_additive]\ntheorem comap_sup_map_of_injective (S T : Submonoid M) : (S.map f ⊔ T.map f).comap f = S ⊔ T :=\n  (gciMapComap hf).u_sup_l _ _\n\n"}
{"name":"AddSubmonoid.comap_sup_map_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\nS T : AddSubmonoid M\n⊢ Eq (AddSubmonoid.comap f (Max.max (AddSubmonoid.map f S) (AddSubmonoid.map f T))) (Max.max S T)","decl":"@[to_additive]\ntheorem comap_sup_map_of_injective (S T : Submonoid M) : (S.map f ⊔ T.map f).comap f = S ⊔ T :=\n  (gciMapComap hf).u_sup_l _ _\n\n"}
{"name":"AddSubmonoid.comap_iSup_map_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nι : Type u_5\nf : F\nhf : Function.Injective ⇑f\nS : ι → AddSubmonoid M\n⊢ Eq (AddSubmonoid.comap f (iSup fun i => AddSubmonoid.map f (S i))) (iSup S)","decl":"@[to_additive]\ntheorem comap_iSup_map_of_injective (S : ι → Submonoid M) : (⨆ i, (S i).map f).comap f = iSup S :=\n  (gciMapComap hf).u_iSup_l _\n\n"}
{"name":"Submonoid.comap_iSup_map_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nι : Type u_5\nf : F\nhf : Function.Injective ⇑f\nS : ι → Submonoid M\n⊢ Eq (Submonoid.comap f (iSup fun i => Submonoid.map f (S i))) (iSup S)","decl":"@[to_additive]\ntheorem comap_iSup_map_of_injective (S : ι → Submonoid M) : (⨆ i, (S i).map f).comap f = iSup S :=\n  (gciMapComap hf).u_iSup_l _\n\n"}
{"name":"Submonoid.map_le_map_iff_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\nS T : Submonoid M\n⊢ Iff (LE.le (Submonoid.map f S) (Submonoid.map f T)) (LE.le S T)","decl":"@[to_additive]\ntheorem map_le_map_iff_of_injective {S T : Submonoid M} : S.map f ≤ T.map f ↔ S ≤ T :=\n  (gciMapComap hf).l_le_l_iff\n\n"}
{"name":"AddSubmonoid.map_le_map_iff_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\nS T : AddSubmonoid M\n⊢ Iff (LE.le (AddSubmonoid.map f S) (AddSubmonoid.map f T)) (LE.le S T)","decl":"@[to_additive]\ntheorem map_le_map_iff_of_injective {S T : Submonoid M} : S.map f ≤ T.map f ↔ S ≤ T :=\n  (gciMapComap hf).l_le_l_iff\n\n"}
{"name":"AddSubmonoid.map_strictMono_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\n⊢ StrictMono (AddSubmonoid.map f)","decl":"@[to_additive]\ntheorem map_strictMono_of_injective : StrictMono (map f) :=\n  (gciMapComap hf).strictMono_l\n\n"}
{"name":"Submonoid.map_strictMono_of_injective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Injective ⇑f\n⊢ StrictMono (Submonoid.map f)","decl":"@[to_additive]\ntheorem map_strictMono_of_injective : StrictMono (map f) :=\n  (gciMapComap hf).strictMono_l\n\n"}
{"name":"AddSubmonoid.map_comap_eq_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\nS : AddSubmonoid N\n⊢ Eq (AddSubmonoid.map f (AddSubmonoid.comap f S)) S","decl":"@[to_additive]\ntheorem map_comap_eq_of_surjective (S : Submonoid N) : (S.comap f).map f = S :=\n  (giMapComap hf).l_u_eq _\n\n"}
{"name":"Submonoid.map_comap_eq_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\nS : Submonoid N\n⊢ Eq (Submonoid.map f (Submonoid.comap f S)) S","decl":"@[to_additive]\ntheorem map_comap_eq_of_surjective (S : Submonoid N) : (S.comap f).map f = S :=\n  (giMapComap hf).l_u_eq _\n\n"}
{"name":"Submonoid.map_surjective_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective (Submonoid.map f)","decl":"@[to_additive]\ntheorem map_surjective_of_surjective : Function.Surjective (map f) :=\n  (giMapComap hf).l_surjective\n\n"}
{"name":"AddSubmonoid.map_surjective_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective (AddSubmonoid.map f)","decl":"@[to_additive]\ntheorem map_surjective_of_surjective : Function.Surjective (map f) :=\n  (giMapComap hf).l_surjective\n\n"}
{"name":"AddSubmonoid.comap_injective_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\n⊢ Function.Injective (AddSubmonoid.comap f)","decl":"@[to_additive]\ntheorem comap_injective_of_surjective : Function.Injective (comap f) :=\n  (giMapComap hf).u_injective\n\n"}
{"name":"Submonoid.comap_injective_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\n⊢ Function.Injective (Submonoid.comap f)","decl":"@[to_additive]\ntheorem comap_injective_of_surjective : Function.Injective (comap f) :=\n  (giMapComap hf).u_injective\n\n"}
{"name":"AddSubmonoid.map_inf_comap_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\nS T : AddSubmonoid N\n⊢ Eq (AddSubmonoid.map f (Min.min (AddSubmonoid.comap f S) (AddSubmonoid.comap f T))) (Min.min S T)","decl":"@[to_additive]\ntheorem map_inf_comap_of_surjective (S T : Submonoid N) : (S.comap f ⊓ T.comap f).map f = S ⊓ T :=\n  (giMapComap hf).l_inf_u _ _\n\n"}
{"name":"Submonoid.map_inf_comap_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\nS T : Submonoid N\n⊢ Eq (Submonoid.map f (Min.min (Submonoid.comap f S) (Submonoid.comap f T))) (Min.min S T)","decl":"@[to_additive]\ntheorem map_inf_comap_of_surjective (S T : Submonoid N) : (S.comap f ⊓ T.comap f).map f = S ⊓ T :=\n  (giMapComap hf).l_inf_u _ _\n\n"}
{"name":"Submonoid.map_iInf_comap_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nι : Type u_5\nf : F\nhf : Function.Surjective ⇑f\nS : ι → Submonoid N\n⊢ Eq (Submonoid.map f (iInf fun i => Submonoid.comap f (S i))) (iInf S)","decl":"@[to_additive]\ntheorem map_iInf_comap_of_surjective (S : ι → Submonoid N) : (⨅ i, (S i).comap f).map f = iInf S :=\n  (giMapComap hf).l_iInf_u _\n\n"}
{"name":"AddSubmonoid.map_iInf_comap_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nι : Type u_5\nf : F\nhf : Function.Surjective ⇑f\nS : ι → AddSubmonoid N\n⊢ Eq (AddSubmonoid.map f (iInf fun i => AddSubmonoid.comap f (S i))) (iInf S)","decl":"@[to_additive]\ntheorem map_iInf_comap_of_surjective (S : ι → Submonoid N) : (⨅ i, (S i).comap f).map f = iInf S :=\n  (giMapComap hf).l_iInf_u _\n\n"}
{"name":"Submonoid.map_sup_comap_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\nS T : Submonoid N\n⊢ Eq (Submonoid.map f (Max.max (Submonoid.comap f S) (Submonoid.comap f T))) (Max.max S T)","decl":"@[to_additive]\ntheorem map_sup_comap_of_surjective (S T : Submonoid N) : (S.comap f ⊔ T.comap f).map f = S ⊔ T :=\n  (giMapComap hf).l_sup_u _ _\n\n"}
{"name":"AddSubmonoid.map_sup_comap_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\nS T : AddSubmonoid N\n⊢ Eq (AddSubmonoid.map f (Max.max (AddSubmonoid.comap f S) (AddSubmonoid.comap f T))) (Max.max S T)","decl":"@[to_additive]\ntheorem map_sup_comap_of_surjective (S T : Submonoid N) : (S.comap f ⊔ T.comap f).map f = S ⊔ T :=\n  (giMapComap hf).l_sup_u _ _\n\n"}
{"name":"Submonoid.map_iSup_comap_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nι : Type u_5\nf : F\nhf : Function.Surjective ⇑f\nS : ι → Submonoid N\n⊢ Eq (Submonoid.map f (iSup fun i => Submonoid.comap f (S i))) (iSup S)","decl":"@[to_additive]\ntheorem map_iSup_comap_of_surjective (S : ι → Submonoid N) : (⨆ i, (S i).comap f).map f = iSup S :=\n  (giMapComap hf).l_iSup_u _\n\n"}
{"name":"AddSubmonoid.map_iSup_comap_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nι : Type u_5\nf : F\nhf : Function.Surjective ⇑f\nS : ι → AddSubmonoid N\n⊢ Eq (AddSubmonoid.map f (iSup fun i => AddSubmonoid.comap f (S i))) (iSup S)","decl":"@[to_additive]\ntheorem map_iSup_comap_of_surjective (S : ι → Submonoid N) : (⨆ i, (S i).comap f).map f = iSup S :=\n  (giMapComap hf).l_iSup_u _\n\n"}
{"name":"AddSubmonoid.comap_le_comap_iff_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\nS T : AddSubmonoid N\n⊢ Iff (LE.le (AddSubmonoid.comap f S) (AddSubmonoid.comap f T)) (LE.le S T)","decl":"@[to_additive]\ntheorem comap_le_comap_iff_of_surjective {S T : Submonoid N} : S.comap f ≤ T.comap f ↔ S ≤ T :=\n  (giMapComap hf).u_le_u_iff\n\n"}
{"name":"Submonoid.comap_le_comap_iff_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\nS T : Submonoid N\n⊢ Iff (LE.le (Submonoid.comap f S) (Submonoid.comap f T)) (LE.le S T)","decl":"@[to_additive]\ntheorem comap_le_comap_iff_of_surjective {S T : Submonoid N} : S.comap f ≤ T.comap f ↔ S ≤ T :=\n  (giMapComap hf).u_le_u_iff\n\n"}
{"name":"AddSubmonoid.comap_strictMono_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\n⊢ StrictMono (AddSubmonoid.comap f)","decl":"@[to_additive]\ntheorem comap_strictMono_of_surjective : StrictMono (comap f) :=\n  (giMapComap hf).strictMono_u\n\n"}
{"name":"Submonoid.comap_strictMono_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\n⊢ StrictMono (Submonoid.comap f)","decl":"@[to_additive]\ntheorem comap_strictMono_of_surjective : StrictMono (comap f) :=\n  (giMapComap hf).strictMono_u\n\n"}
{"name":"Submonoid.topEquiv_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_5\ninst✝ : MulOneClass M\nx : Subtype fun x => Membership.mem Top.top x\n⊢ Eq (Submonoid.topEquiv x) ↑x","decl":"/-- The top submonoid is isomorphic to the monoid. -/\n@[to_additive (attr := simps) \"The top additive submonoid is isomorphic to the additive monoid.\"]\ndef topEquiv : (⊤ : Submonoid M) ≃* M where\n  toFun x := x\n  invFun x := ⟨x, mem_top x⟩\n  left_inv x := x.eta _\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddSubmonoid.topEquiv_symm_apply_coe","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_5\ninst✝ : AddZeroClass M\nx : M\n⊢ Eq (↑(AddSubmonoid.topEquiv.symm x)) x","decl":"/-- The top submonoid is isomorphic to the monoid. -/\n@[to_additive (attr := simps) \"The top additive submonoid is isomorphic to the additive monoid.\"]\ndef topEquiv : (⊤ : Submonoid M) ≃* M where\n  toFun x := x\n  invFun x := ⟨x, mem_top x⟩\n  left_inv x := x.eta _\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddSubmonoid.topEquiv_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_5\ninst✝ : AddZeroClass M\nx : Subtype fun x => Membership.mem Top.top x\n⊢ Eq (AddSubmonoid.topEquiv x) ↑x","decl":"/-- The top submonoid is isomorphic to the monoid. -/\n@[to_additive (attr := simps) \"The top additive submonoid is isomorphic to the additive monoid.\"]\ndef topEquiv : (⊤ : Submonoid M) ≃* M where\n  toFun x := x\n  invFun x := ⟨x, mem_top x⟩\n  left_inv x := x.eta _\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"Submonoid.topEquiv_symm_apply_coe","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_5\ninst✝ : MulOneClass M\nx : M\n⊢ Eq (↑(Submonoid.topEquiv.symm x)) x","decl":"/-- The top submonoid is isomorphic to the monoid. -/\n@[to_additive (attr := simps) \"The top additive submonoid is isomorphic to the additive monoid.\"]\ndef topEquiv : (⊤ : Submonoid M) ≃* M where\n  toFun x := x\n  invFun x := ⟨x, mem_top x⟩\n  left_inv x := x.eta _\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddSubmonoid.topEquiv_toAddMonoidHom","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_5\ninst✝ : AddZeroClass M\n⊢ Eq (↑AddSubmonoid.topEquiv) Top.top.subtype","decl":"@[to_additive (attr := simp)]\ntheorem topEquiv_toMonoidHom : ((topEquiv : _ ≃* M) : _ →* M) = (⊤ : Submonoid M).subtype :=\n  rfl\n\n"}
{"name":"Submonoid.topEquiv_toMonoidHom","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_5\ninst✝ : MulOneClass M\n⊢ Eq (↑Submonoid.topEquiv) Top.top.subtype","decl":"@[to_additive (attr := simp)]\ntheorem topEquiv_toMonoidHom : ((topEquiv : _ ≃* M) : _ →* M) = (⊤ : Submonoid M).subtype :=\n  rfl\n\n"}
{"name":"Submonoid.coe_equivMapOfInjective_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\nS : Submonoid M\nf : MonoidHom M N\nhf : Function.Injective ⇑f\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (↑((S.equivMapOfInjective f hf) x)) (f ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem coe_equivMapOfInjective_apply (f : M →* N) (hf : Function.Injective f) (x : S) :\n    (equivMapOfInjective S f hf x : N) = f x :=\n  rfl\n\n"}
{"name":"AddSubmonoid.coe_equivMapOfInjective_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\nf : AddMonoidHom M N\nhf : Function.Injective ⇑f\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (↑((S.equivMapOfInjective f hf) x)) (f ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem coe_equivMapOfInjective_apply (f : M →* N) (hf : Function.Injective f) (x : S) :\n    (equivMapOfInjective S f hf x : N) = f x :=\n  rfl\n\n"}
{"name":"Submonoid.closure_closure_coe_preimage","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_5\ninst✝ : MulOneClass M\ns : Set M\n⊢ Eq (Submonoid.closure (Set.preimage Subtype.val s)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_closure_coe_preimage {s : Set M} : closure (((↑) : closure s → M) ⁻¹' s) = ⊤ :=\n  eq_top_iff.2 fun x _ ↦ Subtype.recOn x fun _ hx' ↦\n    closure_induction (fun _ h ↦ subset_closure h) (one_mem _) (fun _ _ _ _ ↦ mul_mem) hx'\n\n"}
{"name":"AddSubmonoid.closure_closure_coe_preimage","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_5\ninst✝ : AddZeroClass M\ns : Set M\n⊢ Eq (AddSubmonoid.closure (Set.preimage Subtype.val s)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_closure_coe_preimage {s : Set M} : closure (((↑) : closure s → M) ⁻¹' s) = ⊤ :=\n  eq_top_iff.2 fun x _ ↦ Subtype.recOn x fun _ hx' ↦\n    closure_induction (fun _ h ↦ subset_closure h) (one_mem _) (fun _ _ _ _ ↦ mul_mem) hx'\n\n"}
{"name":"Submonoid.coe_prod","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\ns : Submonoid M\nt : Submonoid N\n⊢ Eq (↑(s.prod t)) (SProd.sprod ↑s ↑t)","decl":"@[to_additive coe_prod]\ntheorem coe_prod (s : Submonoid M) (t : Submonoid N) :\n    (s.prod t : Set (M × N)) = (s : Set M) ×ˢ (t : Set N) :=\n  rfl\n\n"}
{"name":"AddSubmonoid.coe_prod","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\ns : AddSubmonoid M\nt : AddSubmonoid N\n⊢ Eq (↑(s.prod t)) (SProd.sprod ↑s ↑t)","decl":"@[to_additive coe_prod]\ntheorem coe_prod (s : Submonoid M) (t : Submonoid N) :\n    (s.prod t : Set (M × N)) = (s : Set M) ×ˢ (t : Set N) :=\n  rfl\n\n"}
{"name":"Submonoid.mem_prod","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\ns : Submonoid M\nt : Submonoid N\np : Prod M N\n⊢ Iff (Membership.mem (s.prod t) p) (And (Membership.mem s p.1) (Membership.mem t p.2))","decl":"@[to_additive mem_prod]\ntheorem mem_prod {s : Submonoid M} {t : Submonoid N} {p : M × N} :\n    p ∈ s.prod t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  Iff.rfl\n\n"}
{"name":"AddSubmonoid.mem_prod","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\ns : AddSubmonoid M\nt : AddSubmonoid N\np : Prod M N\n⊢ Iff (Membership.mem (s.prod t) p) (And (Membership.mem s p.1) (Membership.mem t p.2))","decl":"@[to_additive mem_prod]\ntheorem mem_prod {s : Submonoid M} {t : Submonoid N} {p : M × N} :\n    p ∈ s.prod t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  Iff.rfl\n\n"}
{"name":"Submonoid.prod_mono","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\ns₁ s₂ : Submonoid M\nt₁ t₂ : Submonoid N\nhs : LE.le s₁ s₂\nht : LE.le t₁ t₂\n⊢ LE.le (s₁.prod t₁) (s₂.prod t₂)","decl":"@[to_additive prod_mono]\ntheorem prod_mono {s₁ s₂ : Submonoid M} {t₁ t₂ : Submonoid N} (hs : s₁ ≤ s₂) (ht : t₁ ≤ t₂) :\n    s₁.prod t₁ ≤ s₂.prod t₂ :=\n  Set.prod_mono hs ht\n\n"}
{"name":"AddSubmonoid.prod_mono","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\ns₁ s₂ : AddSubmonoid M\nt₁ t₂ : AddSubmonoid N\nhs : LE.le s₁ s₂\nht : LE.le t₁ t₂\n⊢ LE.le (s₁.prod t₁) (s₂.prod t₂)","decl":"@[to_additive prod_mono]\ntheorem prod_mono {s₁ s₂ : Submonoid M} {t₁ t₂ : Submonoid N} (hs : s₁ ≤ s₂) (ht : t₁ ≤ t₂) :\n    s₁.prod t₁ ≤ s₂.prod t₂ :=\n  Set.prod_mono hs ht\n\n"}
{"name":"AddSubmonoid.prod_top","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\ns : AddSubmonoid M\n⊢ Eq (s.prod Top.top) (AddSubmonoid.comap (AddMonoidHom.fst M N) s)","decl":"@[to_additive prod_top]\ntheorem prod_top (s : Submonoid M) : s.prod (⊤ : Submonoid N) = s.comap (MonoidHom.fst M N) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]\n\n"}
{"name":"Submonoid.prod_top","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\ns : Submonoid M\n⊢ Eq (s.prod Top.top) (Submonoid.comap (MonoidHom.fst M N) s)","decl":"@[to_additive prod_top]\ntheorem prod_top (s : Submonoid M) : s.prod (⊤ : Submonoid N) = s.comap (MonoidHom.fst M N) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]\n\n"}
{"name":"Submonoid.top_prod","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\ns : Submonoid N\n⊢ Eq (Top.top.prod s) (Submonoid.comap (MonoidHom.snd M N) s)","decl":"@[to_additive top_prod]\ntheorem top_prod (s : Submonoid N) : (⊤ : Submonoid M).prod s = s.comap (MonoidHom.snd M N) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]\n\n"}
{"name":"AddSubmonoid.top_prod","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\ns : AddSubmonoid N\n⊢ Eq (Top.top.prod s) (AddSubmonoid.comap (AddMonoidHom.snd M N) s)","decl":"@[to_additive top_prod]\ntheorem top_prod (s : Submonoid N) : (⊤ : Submonoid M).prod s = s.comap (MonoidHom.snd M N) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]\n\n"}
{"name":"Submonoid.top_prod_top","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\n⊢ Eq (Top.top.prod Top.top) Top.top","decl":"@[to_additive (attr := simp) top_prod_top]\ntheorem top_prod_top : (⊤ : Submonoid M).prod (⊤ : Submonoid N) = ⊤ :=\n  (top_prod _).trans <| comap_top _\n\n"}
{"name":"AddSubmonoid.top_prod_top","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\n⊢ Eq (Top.top.prod Top.top) Top.top","decl":"@[to_additive (attr := simp) top_prod_top]\ntheorem top_prod_top : (⊤ : Submonoid M).prod (⊤ : Submonoid N) = ⊤ :=\n  (top_prod _).trans <| comap_top _\n\n"}
{"name":"Submonoid.bot_prod_bot","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\n⊢ Eq (Bot.bot.prod Bot.bot) Bot.bot","decl":"@[to_additive bot_prod_bot]\ntheorem bot_prod_bot : (⊥ : Submonoid M).prod (⊥ : Submonoid N) = ⊥ :=\n  SetLike.coe_injective <| by simp [coe_prod]\n-- Porting note: to_additive translated the name incorrectly in mathlib 3.\n\n"}
{"name":"AddSubmonoid.bot_prod_bot","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\n⊢ Eq (Bot.bot.prod Bot.bot) Bot.bot","decl":"@[to_additive bot_prod_bot]\ntheorem bot_prod_bot : (⊥ : Submonoid M).prod (⊥ : Submonoid N) = ⊥ :=\n  SetLike.coe_injective <| by simp [coe_prod]\n-- Porting note: to_additive translated the name incorrectly in mathlib 3.\n\n"}
{"name":"Submonoid.map_inl","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\ns : Submonoid M\n⊢ Eq (Submonoid.map (MonoidHom.inl M N) s) (s.prod Bot.bot)","decl":"@[to_additive]\ntheorem map_inl (s : Submonoid M) : s.map (inl M N) = s.prod ⊥ :=\n  ext fun p =>\n    ⟨fun ⟨_, hx, hp⟩ => hp ▸ ⟨hx, Set.mem_singleton 1⟩, fun ⟨hps, hp1⟩ =>\n      ⟨p.1, hps, Prod.ext rfl <| (Set.eq_of_mem_singleton hp1).symm⟩⟩\n\n"}
{"name":"AddSubmonoid.map_inl","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\ns : AddSubmonoid M\n⊢ Eq (AddSubmonoid.map (AddMonoidHom.inl M N) s) (s.prod Bot.bot)","decl":"@[to_additive]\ntheorem map_inl (s : Submonoid M) : s.map (inl M N) = s.prod ⊥ :=\n  ext fun p =>\n    ⟨fun ⟨_, hx, hp⟩ => hp ▸ ⟨hx, Set.mem_singleton 1⟩, fun ⟨hps, hp1⟩ =>\n      ⟨p.1, hps, Prod.ext rfl <| (Set.eq_of_mem_singleton hp1).symm⟩⟩\n\n"}
{"name":"Submonoid.map_inr","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\ns : Submonoid N\n⊢ Eq (Submonoid.map (MonoidHom.inr M N) s) (Bot.bot.prod s)","decl":"@[to_additive]\ntheorem map_inr (s : Submonoid N) : s.map (inr M N) = prod ⊥ s :=\n  ext fun p =>\n    ⟨fun ⟨_, hx, hp⟩ => hp ▸ ⟨Set.mem_singleton 1, hx⟩, fun ⟨hp1, hps⟩ =>\n      ⟨p.2, hps, Prod.ext (Set.eq_of_mem_singleton hp1).symm rfl⟩⟩\n\n"}
{"name":"AddSubmonoid.map_inr","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\ns : AddSubmonoid N\n⊢ Eq (AddSubmonoid.map (AddMonoidHom.inr M N) s) (Bot.bot.prod s)","decl":"@[to_additive]\ntheorem map_inr (s : Submonoid N) : s.map (inr M N) = prod ⊥ s :=\n  ext fun p =>\n    ⟨fun ⟨_, hx, hp⟩ => hp ▸ ⟨Set.mem_singleton 1, hx⟩, fun ⟨hp1, hps⟩ =>\n      ⟨p.2, hps, Prod.ext (Set.eq_of_mem_singleton hp1).symm rfl⟩⟩\n\n"}
{"name":"Submonoid.prod_bot_sup_bot_prod","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\ns : Submonoid M\nt : Submonoid N\n⊢ Eq (Max.max (s.prod Bot.bot) (Bot.bot.prod t)) (s.prod t)","decl":"@[to_additive (attr := simp) prod_bot_sup_bot_prod]\ntheorem prod_bot_sup_bot_prod (s : Submonoid M) (t : Submonoid N) :\n    (prod s ⊥) ⊔ (prod ⊥ t) = prod s t :=\n  (le_antisymm (sup_le (prod_mono (le_refl s) bot_le) (prod_mono bot_le (le_refl t))))\n    fun p hp => Prod.fst_mul_snd p ▸ mul_mem\n        ((le_sup_left : prod s ⊥ ≤ prod s ⊥ ⊔ prod ⊥ t) ⟨hp.1, Set.mem_singleton 1⟩)\n        ((le_sup_right : prod ⊥ t ≤ prod s ⊥ ⊔ prod ⊥ t) ⟨Set.mem_singleton 1, hp.2⟩)\n\n"}
{"name":"AddSubmonoid.prod_bot_sup_bot_prod","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\ns : AddSubmonoid M\nt : AddSubmonoid N\n⊢ Eq (Max.max (s.prod Bot.bot) (Bot.bot.prod t)) (s.prod t)","decl":"@[to_additive (attr := simp) prod_bot_sup_bot_prod]\ntheorem prod_bot_sup_bot_prod (s : Submonoid M) (t : Submonoid N) :\n    (prod s ⊥) ⊔ (prod ⊥ t) = prod s t :=\n  (le_antisymm (sup_le (prod_mono (le_refl s) bot_le) (prod_mono bot_le (le_refl t))))\n    fun p hp => Prod.fst_mul_snd p ▸ mul_mem\n        ((le_sup_left : prod s ⊥ ≤ prod s ⊥ ⊔ prod ⊥ t) ⟨hp.1, Set.mem_singleton 1⟩)\n        ((le_sup_right : prod ⊥ t ≤ prod s ⊥ ⊔ prod ⊥ t) ⟨Set.mem_singleton 1, hp.2⟩)\n\n"}
{"name":"AddSubmonoid.mem_map_equiv","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\nf : AddEquiv M N\nK : AddSubmonoid M\nx : N\n⊢ Iff (Membership.mem (AddSubmonoid.map f.toAddMonoidHom K) x) (Membership.mem K (f.symm x))","decl":"@[to_additive]\ntheorem mem_map_equiv {f : M ≃* N} {K : Submonoid M} {x : N} :\n    x ∈ K.map f.toMonoidHom ↔ f.symm x ∈ K :=\n  Set.mem_image_equiv\n\n"}
{"name":"Submonoid.mem_map_equiv","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\nf : MulEquiv M N\nK : Submonoid M\nx : N\n⊢ Iff (Membership.mem (Submonoid.map f.toMonoidHom K) x) (Membership.mem K (f.symm x))","decl":"@[to_additive]\ntheorem mem_map_equiv {f : M ≃* N} {K : Submonoid M} {x : N} :\n    x ∈ K.map f.toMonoidHom ↔ f.symm x ∈ K :=\n  Set.mem_image_equiv\n\n"}
{"name":"AddSubmonoid.map_equiv_eq_comap_symm","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\nf : AddEquiv M N\nK : AddSubmonoid M\n⊢ Eq (AddSubmonoid.map f.toAddMonoidHom K) (AddSubmonoid.comap f.symm.toAddMonoidHom K)","decl":"@[to_additive]\ntheorem map_equiv_eq_comap_symm (f : M ≃* N) (K : Submonoid M) :\n    K.map f.toMonoidHom = K.comap f.symm.toMonoidHom :=\n  SetLike.coe_injective (f.toEquiv.image_eq_preimage K)\n\n"}
{"name":"Submonoid.map_equiv_eq_comap_symm","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\nf : MulEquiv M N\nK : Submonoid M\n⊢ Eq (Submonoid.map f.toMonoidHom K) (Submonoid.comap f.symm.toMonoidHom K)","decl":"@[to_additive]\ntheorem map_equiv_eq_comap_symm (f : M ≃* N) (K : Submonoid M) :\n    K.map f.toMonoidHom = K.comap f.symm.toMonoidHom :=\n  SetLike.coe_injective (f.toEquiv.image_eq_preimage K)\n\n"}
{"name":"AddSubmonoid.comap_equiv_eq_map_symm","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\nf : AddEquiv N M\nK : AddSubmonoid M\n⊢ Eq (AddSubmonoid.comap f K) (AddSubmonoid.map f.symm K)","decl":"@[to_additive]\ntheorem comap_equiv_eq_map_symm (f : N ≃* M) (K : Submonoid M) :\n    K.comap f = K.map f.symm :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n\n"}
{"name":"Submonoid.comap_equiv_eq_map_symm","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\nf : MulEquiv N M\nK : Submonoid M\n⊢ Eq (Submonoid.comap f K) (Submonoid.map f.symm K)","decl":"@[to_additive]\ntheorem comap_equiv_eq_map_symm (f : N ≃* M) (K : Submonoid M) :\n    K.comap f = K.map f.symm :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n\n"}
{"name":"AddSubmonoid.map_equiv_top","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\nf : AddEquiv M N\n⊢ Eq (AddSubmonoid.map f Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem map_equiv_top (f : M ≃* N) : (⊤ : Submonoid M).map f = ⊤ :=\n  SetLike.coe_injective <| Set.image_univ.trans f.surjective.range_eq\n\n"}
{"name":"Submonoid.map_equiv_top","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\nf : MulEquiv M N\n⊢ Eq (Submonoid.map f Top.top) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem map_equiv_top (f : M ≃* N) : (⊤ : Submonoid M).map f = ⊤ :=\n  SetLike.coe_injective <| Set.image_univ.trans f.surjective.range_eq\n\n"}
{"name":"Submonoid.le_prod_iff","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\ns : Submonoid M\nt : Submonoid N\nu : Submonoid (Prod M N)\n⊢ Iff (LE.le u (s.prod t)) (And (LE.le (Submonoid.map (MonoidHom.fst M N) u) s) (LE.le (Submonoid.map (MonoidHom.snd M N) u) t))","decl":"@[to_additive le_prod_iff]\ntheorem le_prod_iff {s : Submonoid M} {t : Submonoid N} {u : Submonoid (M × N)} :\n    u ≤ s.prod t ↔ u.map (fst M N) ≤ s ∧ u.map (snd M N) ≤ t := by\n  constructor\n  · intro h\n    constructor\n    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩\n      exact (h hy1).1\n    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩\n      exact (h hy1).2\n  · rintro ⟨hH, hK⟩ ⟨x1, x2⟩ h\n    exact ⟨hH ⟨_, h, rfl⟩, hK ⟨_, h, rfl⟩⟩\n\n"}
{"name":"AddSubmonoid.le_prod_iff","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\ns : AddSubmonoid M\nt : AddSubmonoid N\nu : AddSubmonoid (Prod M N)\n⊢ Iff (LE.le u (s.prod t)) (And (LE.le (AddSubmonoid.map (AddMonoidHom.fst M N) u) s) (LE.le (AddSubmonoid.map (AddMonoidHom.snd M N) u) t))","decl":"@[to_additive le_prod_iff]\ntheorem le_prod_iff {s : Submonoid M} {t : Submonoid N} {u : Submonoid (M × N)} :\n    u ≤ s.prod t ↔ u.map (fst M N) ≤ s ∧ u.map (snd M N) ≤ t := by\n  constructor\n  · intro h\n    constructor\n    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩\n      exact (h hy1).1\n    · rintro x ⟨⟨y1, y2⟩, ⟨hy1, rfl⟩⟩\n      exact (h hy1).2\n  · rintro ⟨hH, hK⟩ ⟨x1, x2⟩ h\n    exact ⟨hH ⟨_, h, rfl⟩, hK ⟨_, h, rfl⟩⟩\n\n"}
{"name":"Submonoid.prod_le_iff","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\ns : Submonoid M\nt : Submonoid N\nu : Submonoid (Prod M N)\n⊢ Iff (LE.le (s.prod t) u) (And (LE.le (Submonoid.map (MonoidHom.inl M N) s) u) (LE.le (Submonoid.map (MonoidHom.inr M N) t) u))","decl":"@[to_additive prod_le_iff]\ntheorem prod_le_iff {s : Submonoid M} {t : Submonoid N} {u : Submonoid (M × N)} :\n    s.prod t ≤ u ↔ s.map (inl M N) ≤ u ∧ t.map (inr M N) ≤ u := by\n  constructor\n  · intro h\n    constructor\n    · rintro _ ⟨x, hx, rfl⟩\n      apply h\n      exact ⟨hx, Submonoid.one_mem _⟩\n    · rintro _ ⟨x, hx, rfl⟩\n      apply h\n      exact ⟨Submonoid.one_mem _, hx⟩\n  · rintro ⟨hH, hK⟩ ⟨x1, x2⟩ ⟨h1, h2⟩\n    have h1' : inl M N x1 ∈ u := by\n      apply hH\n      simpa using h1\n    have h2' : inr M N x2 ∈ u := by\n      apply hK\n      simpa using h2\n    simpa using Submonoid.mul_mem _ h1' h2'\n\n"}
{"name":"AddSubmonoid.prod_le_iff","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\ns : AddSubmonoid M\nt : AddSubmonoid N\nu : AddSubmonoid (Prod M N)\n⊢ Iff (LE.le (s.prod t) u) (And (LE.le (AddSubmonoid.map (AddMonoidHom.inl M N) s) u) (LE.le (AddSubmonoid.map (AddMonoidHom.inr M N) t) u))","decl":"@[to_additive prod_le_iff]\ntheorem prod_le_iff {s : Submonoid M} {t : Submonoid N} {u : Submonoid (M × N)} :\n    s.prod t ≤ u ↔ s.map (inl M N) ≤ u ∧ t.map (inr M N) ≤ u := by\n  constructor\n  · intro h\n    constructor\n    · rintro _ ⟨x, hx, rfl⟩\n      apply h\n      exact ⟨hx, Submonoid.one_mem _⟩\n    · rintro _ ⟨x, hx, rfl⟩\n      apply h\n      exact ⟨Submonoid.one_mem _, hx⟩\n  · rintro ⟨hH, hK⟩ ⟨x1, x2⟩ ⟨h1, h2⟩\n    have h1' : inl M N x1 ∈ u := by\n      apply hH\n      simpa using h1\n    have h2' : inr M N x2 ∈ u := by\n      apply hK\n      simpa using h2\n    simpa using Submonoid.mul_mem _ h1' h2'\n\n"}
{"name":"Submonoid.closure_prod","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : MulOneClass N\nM : Type u_5\ninst✝ : MulOneClass M\ns : Set M\nt : Set N\nhs : Membership.mem s 1\nht : Membership.mem t 1\n⊢ Eq (Submonoid.closure (SProd.sprod s t)) ((Submonoid.closure s).prod (Submonoid.closure t))","decl":"@[to_additive closure_prod]\ntheorem closure_prod {s : Set M} {t : Set N} (hs : 1 ∈ s) (ht : 1 ∈ t) :\n    closure (s ×ˢ t) = (closure s).prod (closure t) :=\n  le_antisymm\n    (closure_le.2 <| Set.prod_subset_prod_iff.2 <| .inl ⟨subset_closure, subset_closure⟩)\n    (prod_le_iff.2 ⟨\n      map_le_of_le_comap _ <| closure_le.2 fun _x hx => subset_closure ⟨hx, ht⟩,\n      map_le_of_le_comap _ <| closure_le.2 fun _y hy => subset_closure ⟨hs, hy⟩⟩)\n\n"}
{"name":"AddSubmonoid.closure_prod","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"N : Type u_2\ninst✝¹ : AddZeroClass N\nM : Type u_5\ninst✝ : AddZeroClass M\ns : Set M\nt : Set N\nhs : Membership.mem s 0\nht : Membership.mem t 0\n⊢ Eq (AddSubmonoid.closure (SProd.sprod s t)) ((AddSubmonoid.closure s).prod (AddSubmonoid.closure t))","decl":"@[to_additive closure_prod]\ntheorem closure_prod {s : Set M} {t : Set N} (hs : 1 ∈ s) (ht : 1 ∈ t) :\n    closure (s ×ˢ t) = (closure s).prod (closure t) :=\n  le_antisymm\n    (closure_le.2 <| Set.prod_subset_prod_iff.2 <| .inl ⟨subset_closure, subset_closure⟩)\n    (prod_le_iff.2 ⟨\n      map_le_of_le_comap _ <| closure_le.2 fun _x hx => subset_closure ⟨hx, ht⟩,\n      map_le_of_le_comap _ <| closure_le.2 fun _y hy => subset_closure ⟨hs, hy⟩⟩)\n\n"}
{"name":"AddMonoidHom.coe_mrange","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\n⊢ Eq (↑(AddMonoidHom.mrange f)) (Set.range ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_mrange (f : F) : (mrange f : Set N) = Set.range f :=\n  rfl\n\n"}
{"name":"MonoidHom.coe_mrange","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ Eq (↑(MonoidHom.mrange f)) (Set.range ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_mrange (f : F) : (mrange f : Set N) = Set.range f :=\n  rfl\n\n"}
{"name":"AddMonoidHom.mem_mrange","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\ny : N\n⊢ Iff (Membership.mem (AddMonoidHom.mrange f) y) (Exists fun x => Eq (f x) y)","decl":"@[to_additive (attr := simp)]\ntheorem mem_mrange {f : F} {y : N} : y ∈ mrange f ↔ ∃ x, f x = y :=\n  Iff.rfl\n\n"}
{"name":"MonoidHom.mem_mrange","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\ny : N\n⊢ Iff (Membership.mem (MonoidHom.mrange f) y) (Exists fun x => Eq (f x) y)","decl":"@[to_additive (attr := simp)]\ntheorem mem_mrange {f : F} {y : N} : y ∈ mrange f ↔ ∃ x, f x = y :=\n  Iff.rfl\n\n"}
{"name":"MonoidHom.mrange_comp","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nO : Type u_5\ninst✝ : Monoid O\nf : MonoidHom N O\ng : MonoidHom M N\n⊢ Eq (MonoidHom.mrange (f.comp g)) (Submonoid.map f (MonoidHom.mrange g))","decl":"@[to_additive]\nlemma mrange_comp {O : Type*} [Monoid O] (f : N →* O) (g : M →* N) :\n    mrange (f.comp g) = (mrange g).map f := SetLike.coe_injective <| Set.range_comp f _\n\n"}
{"name":"AddMonoidHom.mrange_comp","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nO : Type u_5\ninst✝ : AddMonoid O\nf : AddMonoidHom N O\ng : AddMonoidHom M N\n⊢ Eq (AddMonoidHom.mrange (f.comp g)) (AddSubmonoid.map f (AddMonoidHom.mrange g))","decl":"@[to_additive]\nlemma mrange_comp {O : Type*} [Monoid O] (f : N →* O) (g : M →* N) :\n    mrange (f.comp g) = (mrange g).map f := SetLike.coe_injective <| Set.range_comp f _\n\n"}
{"name":"AddMonoidHom.mrange_eq_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\n⊢ Eq (AddMonoidHom.mrange f) (AddSubmonoid.map f Top.top)","decl":"@[to_additive]\ntheorem mrange_eq_map (f : F) : mrange f = (⊤ : Submonoid M).map f :=\n  Submonoid.copy_eq _\n\n"}
{"name":"MonoidHom.mrange_eq_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ Eq (MonoidHom.mrange f) (Submonoid.map f Top.top)","decl":"@[to_additive]\ntheorem mrange_eq_map (f : F) : mrange f = (⊤ : Submonoid M).map f :=\n  Submonoid.copy_eq _\n\n"}
{"name":"AddMonoidHom.mrange_id","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\n⊢ Eq (AddMonoidHom.mrange (AddMonoidHom.id M)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mrange_id : mrange (MonoidHom.id M) = ⊤ := by\n  simp [mrange_eq_map]\n\n"}
{"name":"MonoidHom.mrange_id","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\n⊢ Eq (MonoidHom.mrange (MonoidHom.id M)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mrange_id : mrange (MonoidHom.id M) = ⊤ := by\n  simp [mrange_eq_map]\n\n"}
{"name":"AddMonoidHom.map_mrange","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\ng : AddMonoidHom N P\nf : AddMonoidHom M N\n⊢ Eq (AddSubmonoid.map g (AddMonoidHom.mrange f)) (AddMonoidHom.mrange (g.comp f))","decl":"@[to_additive]\ntheorem map_mrange (g : N →* P) (f : M →* N) : f.mrange.map g = mrange (comp g f) := by\n  simpa only [mrange_eq_map] using (⊤ : Submonoid M).map_map g f\n\n"}
{"name":"MonoidHom.map_mrange","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\ng : MonoidHom N P\nf : MonoidHom M N\n⊢ Eq (Submonoid.map g (MonoidHom.mrange f)) (MonoidHom.mrange (g.comp f))","decl":"@[to_additive]\ntheorem map_mrange (g : N →* P) (f : M →* N) : f.mrange.map g = mrange (comp g f) := by\n  simpa only [mrange_eq_map] using (⊤ : Submonoid M).map_map g f\n\n"}
{"name":"MonoidHom.mrange_eq_top","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ Iff (Eq (MonoidHom.mrange f) Top.top) (Function.Surjective ⇑f)","decl":"@[to_additive]\ntheorem mrange_eq_top {f : F} : mrange f = (⊤ : Submonoid N) ↔ Surjective f :=\n  SetLike.ext'_iff.trans <| Iff.trans (by rw [coe_mrange, coe_top]) Set.range_eq_univ\n\n"}
{"name":"AddMonoidHom.mrange_eq_top","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\n⊢ Iff (Eq (AddMonoidHom.mrange f) Top.top) (Function.Surjective ⇑f)","decl":"@[to_additive]\ntheorem mrange_eq_top {f : F} : mrange f = (⊤ : Submonoid N) ↔ Surjective f :=\n  SetLike.ext'_iff.trans <| Iff.trans (by rw [coe_mrange, coe_top]) Set.range_eq_univ\n\n"}
{"name":"MonoidHom.mrange_top_iff_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ Iff (Eq (MonoidHom.mrange f) Top.top) (Function.Surjective ⇑f)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias mrange_top_iff_surjective := mrange_eq_top\n\n"}
{"name":"MonoidHom.mrange_eq_top_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\n⊢ Eq (MonoidHom.mrange f) Top.top","decl":"/-- The range of a surjective monoid hom is the whole of the codomain. -/\n@[to_additive (attr := simp)\n  \"The range of a surjective `AddMonoid` hom is the whole of the codomain.\"]\ntheorem mrange_eq_top_of_surjective (f : F) (hf : Function.Surjective f) :\n    mrange f = (⊤ : Submonoid N) :=\n  mrange_eq_top.2 hf\n\n"}
{"name":"AddMonoidHom.mrange_eq_top_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\n⊢ Eq (AddMonoidHom.mrange f) Top.top","decl":"/-- The range of a surjective monoid hom is the whole of the codomain. -/\n@[to_additive (attr := simp)\n  \"The range of a surjective `AddMonoid` hom is the whole of the codomain.\"]\ntheorem mrange_eq_top_of_surjective (f : F) (hf : Function.Surjective f) :\n    mrange f = (⊤ : Submonoid N) :=\n  mrange_eq_top.2 hf\n\n"}
{"name":"MonoidHom.mrange_top_of_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nhf : Function.Surjective ⇑f\n⊢ Eq (MonoidHom.mrange f) Top.top","decl":"@[deprecated (since := \"2024-11-11\")] alias mrange_top_of_surjective := mrange_eq_top_of_surjective\n\n"}
{"name":"MonoidHom.mclosure_preimage_le","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\ns : Set N\n⊢ LE.le (Submonoid.closure (Set.preimage (⇑f) s)) (Submonoid.comap f (Submonoid.closure s))","decl":"@[to_additive]\ntheorem mclosure_preimage_le (f : F) (s : Set N) : closure (f ⁻¹' s) ≤ (closure s).comap f :=\n  closure_le.2 fun _ hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n\n"}
{"name":"AddMonoidHom.mclosure_preimage_le","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\ns : Set N\n⊢ LE.le (AddSubmonoid.closure (Set.preimage (⇑f) s)) (AddSubmonoid.comap f (AddSubmonoid.closure s))","decl":"@[to_additive]\ntheorem mclosure_preimage_le (f : F) (s : Set N) : closure (f ⁻¹' s) ≤ (closure s).comap f :=\n  closure_le.2 fun _ hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n\n"}
{"name":"AddMonoidHom.map_mclosure","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\ns : Set M\n⊢ Eq (AddSubmonoid.map f (AddSubmonoid.closure s)) (AddSubmonoid.closure (Set.image (⇑f) s))","decl":"/-- The image under a monoid hom of the submonoid generated by a set equals the submonoid generated\n    by the image of the set. -/\n@[to_additive\n      \"The image under an `AddMonoid` hom of the `AddSubmonoid` generated by a set equals\n      the `AddSubmonoid` generated by the image of the set.\"]\ntheorem map_mclosure (f : F) (s : Set M) : (closure s).map f = closure (f '' s) :=\n  Set.image_preimage.l_comm_of_u_comm (gc_map_comap f) (Submonoid.gi N).gc (Submonoid.gi M).gc\n    fun _ ↦ rfl\n\n"}
{"name":"MonoidHom.map_mclosure","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\ns : Set M\n⊢ Eq (Submonoid.map f (Submonoid.closure s)) (Submonoid.closure (Set.image (⇑f) s))","decl":"/-- The image under a monoid hom of the submonoid generated by a set equals the submonoid generated\n    by the image of the set. -/\n@[to_additive\n      \"The image under an `AddMonoid` hom of the `AddSubmonoid` generated by a set equals\n      the `AddSubmonoid` generated by the image of the set.\"]\ntheorem map_mclosure (f : F) (s : Set M) : (closure s).map f = closure (f '' s) :=\n  Set.image_preimage.l_comm_of_u_comm (gc_map_comap f) (Submonoid.gi N).gc (Submonoid.gi M).gc\n    fun _ ↦ rfl\n\n"}
{"name":"MonoidHom.mclosure_range","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ Eq (Submonoid.closure (Set.range ⇑f)) (MonoidHom.mrange f)","decl":"@[to_additive (attr := simp)]\ntheorem mclosure_range (f : F) : closure (Set.range f) = mrange f := by\n  rw [← Set.image_univ, ← map_mclosure, mrange_eq_map, closure_univ]\n\n"}
{"name":"AddMonoidHom.mclosure_range","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\n⊢ Eq (AddSubmonoid.closure (Set.range ⇑f)) (AddMonoidHom.mrange f)","decl":"@[to_additive (attr := simp)]\ntheorem mclosure_range (f : F) : closure (Set.range f) = mrange f := by\n  rw [← Set.image_univ, ← map_mclosure, mrange_eq_map, closure_univ]\n\n"}
{"name":"AddMonoidHom.restrict_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝³ : AddZeroClass M\nN : Type u_5\nS : Type u_6\ninst✝² : AddZeroClass N\ninst✝¹ : SetLike S M\ninst✝ : AddSubmonoidClass S M\nf : AddMonoidHom M N\ns : S\nx : Subtype fun x => Membership.mem s x\n⊢ Eq ((f.restrict s) x) (f ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem restrict_apply {N S : Type*} [MulOneClass N] [SetLike S M] [SubmonoidClass S M]\n    (f : M →* N) (s : S) (x : s) : f.restrict s x = f x :=\n  rfl\n\n"}
{"name":"MonoidHom.restrict_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝³ : MulOneClass M\nN : Type u_5\nS : Type u_6\ninst✝² : MulOneClass N\ninst✝¹ : SetLike S M\ninst✝ : SubmonoidClass S M\nf : MonoidHom M N\ns : S\nx : Subtype fun x => Membership.mem s x\n⊢ Eq ((f.restrict s) x) (f ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem restrict_apply {N S : Type*} [MulOneClass N] [SetLike S M] [SubmonoidClass S M]\n    (f : M →* N) (s : S) (x : s) : f.restrict s x = f x :=\n  rfl\n\n"}
{"name":"AddMonoidHom.restrict_mrange","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nS : AddSubmonoid M\nf : AddMonoidHom M N\n⊢ Eq (AddMonoidHom.mrange (f.restrict S)) (AddSubmonoid.map f S)","decl":"@[to_additive (attr := simp)]\ntheorem restrict_mrange (f : M →* N) : mrange (f.restrict S) = S.map f := by\n  simp [SetLike.ext_iff]\n\n"}
{"name":"MonoidHom.restrict_mrange","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nS : Submonoid M\nf : MonoidHom M N\n⊢ Eq (MonoidHom.mrange (f.restrict S)) (Submonoid.map f S)","decl":"@[to_additive (attr := simp)]\ntheorem restrict_mrange (f : M →* N) : mrange (f.restrict S) = S.map f := by\n  simp [SetLike.ext_iff]\n\n"}
{"name":"MonoidHom.codRestrict_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\nS : Type u_5\ninst✝¹ : SetLike S N\ninst✝ : SubmonoidClass S N\nf : MonoidHom M N\ns : S\nh : ∀ (x : M), Membership.mem s (f x)\nn : M\n⊢ Eq ((f.codRestrict s h) n) ⟨f n, ⋯⟩","decl":"/-- Restriction of a monoid hom to a submonoid of the codomain. -/\n@[to_additive (attr := simps apply)\n  \"Restriction of an `AddMonoid` hom to an `AddSubmonoid` of the codomain.\"]\ndef codRestrict {S} [SetLike S N] [SubmonoidClass S N] (f : M →* N) (s : S) (h : ∀ x, f x ∈ s) :\n    M →* s where\n  toFun n := ⟨f n, h n⟩\n  map_one' := Subtype.eq f.map_one\n  map_mul' x y := Subtype.eq (f.map_mul x y)\n\n"}
{"name":"AddMonoidHom.codRestrict_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\nS : Type u_5\ninst✝¹ : SetLike S N\ninst✝ : AddSubmonoidClass S N\nf : AddMonoidHom M N\ns : S\nh : ∀ (x : M), Membership.mem s (f x)\nn : M\n⊢ Eq ((f.codRestrict s h) n) ⟨f n, ⋯⟩","decl":"/-- Restriction of a monoid hom to a submonoid of the codomain. -/\n@[to_additive (attr := simps apply)\n  \"Restriction of an `AddMonoid` hom to an `AddSubmonoid` of the codomain.\"]\ndef codRestrict {S} [SetLike S N] [SubmonoidClass S N] (f : M →* N) (s : S) (h : ∀ x, f x ∈ s) :\n    M →* s where\n  toFun n := ⟨f n, h n⟩\n  map_one' := Subtype.eq f.map_one\n  map_mul' x y := Subtype.eq (f.map_mul x y)\n\n"}
{"name":"AddMonoidHom.injective_codRestrict","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\nS : Type u_5\ninst✝¹ : SetLike S N\ninst✝ : AddSubmonoidClass S N\nf : AddMonoidHom M N\ns : S\nh : ∀ (x : M), Membership.mem s (f x)\n⊢ Iff (Function.Injective ⇑(f.codRestrict s h)) (Function.Injective ⇑f)","decl":"@[to_additive (attr := simp)]\nlemma injective_codRestrict {S} [SetLike S N] [SubmonoidClass S N] (f : M →* N) (s : S)\n    (h : ∀ x, f x ∈ s) : Function.Injective (f.codRestrict s h) ↔ Function.Injective f :=\n  ⟨fun H _ _ hxy ↦ H <| Subtype.eq hxy, fun H _ _ hxy ↦ H (congr_arg Subtype.val hxy)⟩\n\n"}
{"name":"MonoidHom.injective_codRestrict","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\nS : Type u_5\ninst✝¹ : SetLike S N\ninst✝ : SubmonoidClass S N\nf : MonoidHom M N\ns : S\nh : ∀ (x : M), Membership.mem s (f x)\n⊢ Iff (Function.Injective ⇑(f.codRestrict s h)) (Function.Injective ⇑f)","decl":"@[to_additive (attr := simp)]\nlemma injective_codRestrict {S} [SetLike S N] [SubmonoidClass S N] (f : M →* N) (s : S)\n    (h : ∀ x, f x ∈ s) : Function.Injective (f.codRestrict s h) ↔ Function.Injective f :=\n  ⟨fun H _ _ hxy ↦ H <| Subtype.eq hxy, fun H _ _ hxy ↦ H (congr_arg Subtype.val hxy)⟩\n\n"}
{"name":"MonoidHom.coe_mrangeRestrict","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝¹ : MulOneClass M\nN : Type u_5\ninst✝ : MulOneClass N\nf : MonoidHom M N\nx : M\n⊢ Eq (↑(f.mrangeRestrict x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem coe_mrangeRestrict {N} [MulOneClass N] (f : M →* N) (x : M) :\n    (f.mrangeRestrict x : N) = f x :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_mrangeRestrict","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝¹ : AddZeroClass M\nN : Type u_5\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\nx : M\n⊢ Eq (↑(f.mrangeRestrict x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem coe_mrangeRestrict {N} [MulOneClass N] (f : M →* N) (x : M) :\n    (f.mrangeRestrict x : N) = f x :=\n  rfl\n\n"}
{"name":"MonoidHom.mrangeRestrict_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\n⊢ Function.Surjective ⇑f.mrangeRestrict","decl":"@[to_additive]\ntheorem mrangeRestrict_surjective (f : M →* N) : Function.Surjective f.mrangeRestrict :=\n  fun ⟨_, ⟨x, rfl⟩⟩ => ⟨x, rfl⟩\n\n"}
{"name":"AddMonoidHom.mrangeRestrict_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\n⊢ Function.Surjective ⇑f.mrangeRestrict","decl":"@[to_additive]\ntheorem mrangeRestrict_surjective (f : M →* N) : Function.Surjective f.mrangeRestrict :=\n  fun ⟨_, ⟨x, rfl⟩⟩ => ⟨x, rfl⟩\n\n"}
{"name":"MonoidHom.mem_mker","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nx : M\n⊢ Iff (Membership.mem (MonoidHom.mker f) x) (Eq (f x) 1)","decl":"@[to_additive (attr := simp)]\ntheorem mem_mker {f : F} {x : M} : x ∈ mker f ↔ f x = 1 :=\n  Iff.rfl\n\n"}
{"name":"AddMonoidHom.mem_mker","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nx : M\n⊢ Iff (Membership.mem (AddMonoidHom.mker f) x) (Eq (f x) 0)","decl":"@[to_additive (attr := simp)]\ntheorem mem_mker {f : F} {x : M} : x ∈ mker f ↔ f x = 1 :=\n  Iff.rfl\n\n"}
{"name":"MonoidHom.coe_mker","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ Eq (↑(MonoidHom.mker f)) (Set.preimage (⇑f) (Singleton.singleton 1))","decl":"@[to_additive]\ntheorem coe_mker (f : F) : (mker f : Set M) = (f : M → N) ⁻¹' {1} :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_mker","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\n⊢ Eq (↑(AddMonoidHom.mker f)) (Set.preimage (⇑f) (Singleton.singleton 0))","decl":"@[to_additive]\ntheorem coe_mker (f : F) : (mker f : Set M) = (f : M → N) ⁻¹' {1} :=\n  rfl\n\n"}
{"name":"AddMonoidHom.comap_mker","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\ng : AddMonoidHom N P\nf : AddMonoidHom M N\n⊢ Eq (AddSubmonoid.comap f (AddMonoidHom.mker g)) (AddMonoidHom.mker (g.comp f))","decl":"@[to_additive]\ntheorem comap_mker (g : N →* P) (f : M →* N) : g.mker.comap f = mker (comp g f) :=\n  rfl\n\n"}
{"name":"MonoidHom.comap_mker","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\ng : MonoidHom N P\nf : MonoidHom M N\n⊢ Eq (Submonoid.comap f (MonoidHom.mker g)) (MonoidHom.mker (g.comp f))","decl":"@[to_additive]\ntheorem comap_mker (g : N →* P) (f : M →* N) : g.mker.comap f = mker (comp g f) :=\n  rfl\n\n"}
{"name":"MonoidHom.comap_bot'","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\n⊢ Eq (Submonoid.comap f Bot.bot) (MonoidHom.mker f)","decl":"@[to_additive (attr := simp)]\ntheorem comap_bot' (f : F) : (⊥ : Submonoid N).comap f = mker f :=\n  rfl\n\n"}
{"name":"AddMonoidHom.comap_bot'","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\n⊢ Eq (AddSubmonoid.comap f Bot.bot) (AddMonoidHom.mker f)","decl":"@[to_additive (attr := simp)]\ntheorem comap_bot' (f : F) : (⊥ : Submonoid N).comap f = mker f :=\n  rfl\n\n"}
{"name":"MonoidHom.restrict_mker","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nS : Submonoid M\nf : MonoidHom M N\n⊢ Eq (MonoidHom.mker (f.restrict S)) (Submonoid.comap S.subtype (MonoidHom.mker f))","decl":"@[to_additive (attr := simp)]\ntheorem restrict_mker (f : M →* N) : mker (f.restrict S) = f.mker.comap S.subtype :=\n  rfl\n\n"}
{"name":"AddMonoidHom.restrict_mker","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nS : AddSubmonoid M\nf : AddMonoidHom M N\n⊢ Eq (AddMonoidHom.mker (f.restrict S)) (AddSubmonoid.comap S.subtype (AddMonoidHom.mker f))","decl":"@[to_additive (attr := simp)]\ntheorem restrict_mker (f : M →* N) : mker (f.restrict S) = f.mker.comap S.subtype :=\n  rfl\n\n"}
{"name":"MonoidHom.mrangeRestrict_mker","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\n⊢ Eq (MonoidHom.mker f.mrangeRestrict) (MonoidHom.mker f)","decl":"@[to_additive]\ntheorem mrangeRestrict_mker (f : M →* N) : mker (mrangeRestrict f) = mker f := by\n  ext x\n  change (⟨f x, _⟩ : mrange f) = ⟨1, _⟩ ↔ f x = 1\n  simp\n\n"}
{"name":"AddMonoidHom.mrangeRestrict_mker","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\n⊢ Eq (AddMonoidHom.mker f.mrangeRestrict) (AddMonoidHom.mker f)","decl":"@[to_additive]\ntheorem mrangeRestrict_mker (f : M →* N) : mker (mrangeRestrict f) = mker f := by\n  ext x\n  change (⟨f x, _⟩ : mrange f) = ⟨1, _⟩ ↔ f x = 1\n  simp\n\n"}
{"name":"AddMonoidHom.mker_zero","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mker 0) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mker_one : mker (1 : M →* N) = ⊤ := by\n  ext\n  simp [mem_mker]\n\n"}
{"name":"MonoidHom.mker_one","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mker 1) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mker_one : mker (1 : M →* N) = ⊤ := by\n  ext\n  simp [mem_mker]\n\n"}
{"name":"MonoidHom.prod_map_comap_prod'","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\nM' : Type u_5\nN' : Type u_6\ninst✝¹ : MulOneClass M'\ninst✝ : MulOneClass N'\nf : MonoidHom M N\ng : MonoidHom M' N'\nS : Submonoid N\nS' : Submonoid N'\n⊢ Eq (Submonoid.comap (f.prodMap g) (S.prod S')) ((Submonoid.comap f S).prod (Submonoid.comap g S'))","decl":"@[to_additive prod_map_comap_prod']\ntheorem prod_map_comap_prod' {M' : Type*} {N' : Type*} [MulOneClass M'] [MulOneClass N']\n    (f : M →* N) (g : M' →* N') (S : Submonoid N) (S' : Submonoid N') :\n    (S.prod S').comap (prodMap f g) = (S.comap f).prod (S'.comap g) :=\n  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _\n-- Porting note: to_additive translated the name incorrectly in mathlib 3.\n\n"}
{"name":"AddMonoidHom.prod_map_comap_prod'","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\nM' : Type u_5\nN' : Type u_6\ninst✝¹ : AddZeroClass M'\ninst✝ : AddZeroClass N'\nf : AddMonoidHom M N\ng : AddMonoidHom M' N'\nS : AddSubmonoid N\nS' : AddSubmonoid N'\n⊢ Eq (AddSubmonoid.comap (f.prodMap g) (S.prod S')) ((AddSubmonoid.comap f S).prod (AddSubmonoid.comap g S'))","decl":"@[to_additive prod_map_comap_prod']\ntheorem prod_map_comap_prod' {M' : Type*} {N' : Type*} [MulOneClass M'] [MulOneClass N']\n    (f : M →* N) (g : M' →* N') (S : Submonoid N) (S' : Submonoid N') :\n    (S.prod S').comap (prodMap f g) = (S.comap f).prod (S'.comap g) :=\n  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _\n-- Porting note: to_additive translated the name incorrectly in mathlib 3.\n\n"}
{"name":"MonoidHom.mker_prod_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\nM' : Type u_5\nN' : Type u_6\ninst✝¹ : MulOneClass M'\ninst✝ : MulOneClass N'\nf : MonoidHom M N\ng : MonoidHom M' N'\n⊢ Eq (MonoidHom.mker (f.prodMap g)) ((MonoidHom.mker f).prod (MonoidHom.mker g))","decl":"@[to_additive mker_prod_map]\ntheorem mker_prod_map {M' : Type*} {N' : Type*} [MulOneClass M'] [MulOneClass N'] (f : M →* N)\n    (g : M' →* N') : mker (prodMap f g) = f.mker.prod (mker g) := by\n  rw [← comap_bot', ← comap_bot', ← comap_bot', ← prod_map_comap_prod', bot_prod_bot]\n-- Porting note: to_additive translated the name incorrectly in mathlib 3.\n\n"}
{"name":"AddMonoidHom.mker_prod_map","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\nM' : Type u_5\nN' : Type u_6\ninst✝¹ : AddZeroClass M'\ninst✝ : AddZeroClass N'\nf : AddMonoidHom M N\ng : AddMonoidHom M' N'\n⊢ Eq (AddMonoidHom.mker (f.prodMap g)) ((AddMonoidHom.mker f).prod (AddMonoidHom.mker g))","decl":"@[to_additive mker_prod_map]\ntheorem mker_prod_map {M' : Type*} {N' : Type*} [MulOneClass M'] [MulOneClass N'] (f : M →* N)\n    (g : M' →* N') : mker (prodMap f g) = f.mker.prod (mker g) := by\n  rw [← comap_bot', ← comap_bot', ← comap_bot', ← prod_map_comap_prod', bot_prod_bot]\n-- Porting note: to_additive translated the name incorrectly in mathlib 3.\n\n"}
{"name":"AddMonoidHom.mker_inl","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mker (AddMonoidHom.inl M N)) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem mker_inl : mker (inl M N) = ⊥ := by\n  ext x\n  simp [mem_mker]\n\n"}
{"name":"MonoidHom.mker_inl","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mker (MonoidHom.inl M N)) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem mker_inl : mker (inl M N) = ⊥ := by\n  ext x\n  simp [mem_mker]\n\n"}
{"name":"AddMonoidHom.mker_inr","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mker (AddMonoidHom.inr M N)) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem mker_inr : mker (inr M N) = ⊥ := by\n  ext x\n  simp [mem_mker]\n\n"}
{"name":"MonoidHom.mker_inr","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mker (MonoidHom.inr M N)) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem mker_inr : mker (inr M N) = ⊥ := by\n  ext x\n  simp [mem_mker]\n\n"}
{"name":"MonoidHom.mker_fst","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mker (MonoidHom.fst M N)) (Bot.bot.prod Top.top)","decl":"@[to_additive (attr := simp)]\nlemma mker_fst : mker (fst M N) = .prod ⊥ ⊤ := SetLike.ext fun _ => (iff_of_eq (and_true _)).symm\n\n"}
{"name":"AddMonoidHom.mker_fst","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mker (AddMonoidHom.fst M N)) (Bot.bot.prod Top.top)","decl":"@[to_additive (attr := simp)]\nlemma mker_fst : mker (fst M N) = .prod ⊥ ⊤ := SetLike.ext fun _ => (iff_of_eq (and_true _)).symm\n\n"}
{"name":"AddMonoidHom.mker_snd","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mker (AddMonoidHom.snd M N)) (Top.top.prod Bot.bot)","decl":"@[to_additive (attr := simp)]\nlemma mker_snd : mker (snd M N) = .prod ⊤ ⊥ := SetLike.ext fun _ => (iff_of_eq (true_and _)).symm\n\n"}
{"name":"MonoidHom.mker_snd","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mker (MonoidHom.snd M N)) (Top.top.prod Bot.bot)","decl":"@[to_additive (attr := simp)]\nlemma mker_snd : mker (snd M N) = .prod ⊤ ⊥ := SetLike.ext fun _ => (iff_of_eq (true_and _)).symm\n\n"}
{"name":"MonoidHom.submonoidComap_apply_coe","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\nN' : Submonoid N\nx : Subtype fun x => Membership.mem (Submonoid.comap f N') x\n⊢ Eq (↑((f.submonoidComap N') x)) (f ↑x)","decl":"/-- The `MonoidHom` from the preimage of a submonoid to itself. -/\n@[to_additive (attr := simps)\n      \"the `AddMonoidHom` from the preimage of an additive submonoid to itself.\"]\ndef submonoidComap (f : M →* N) (N' : Submonoid N) :\n    N'.comap f →* N' where\n  toFun x := ⟨f x, x.2⟩\n  map_one' := Subtype.eq f.map_one\n  map_mul' x y := Subtype.eq (f.map_mul x y)\n\n"}
{"name":"AddMonoidHom.addSubmonoidComap_apply_coe","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\nN' : AddSubmonoid N\nx : Subtype fun x => Membership.mem (AddSubmonoid.comap f N') x\n⊢ Eq (↑((f.addSubmonoidComap N') x)) (f ↑x)","decl":"/-- The `MonoidHom` from the preimage of a submonoid to itself. -/\n@[to_additive (attr := simps)\n      \"the `AddMonoidHom` from the preimage of an additive submonoid to itself.\"]\ndef submonoidComap (f : M →* N) (N' : Submonoid N) :\n    N'.comap f →* N' where\n  toFun x := ⟨f x, x.2⟩\n  map_one' := Subtype.eq f.map_one\n  map_mul' x y := Subtype.eq (f.map_mul x y)\n\n"}
{"name":"AddMonoidHom.addSubmonoidMap_apply_coe","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\nM' : AddSubmonoid M\nx : Subtype fun x => Membership.mem M' x\n⊢ Eq (↑((f.addSubmonoidMap M') x)) (f ↑x)","decl":"/-- The `MonoidHom` from a submonoid to its image.\nSee `MulEquiv.SubmonoidMap` for a variant for `MulEquiv`s. -/\n@[to_additive (attr := simps)\n      \"the `AddMonoidHom` from an additive submonoid to its image. See\n      `AddEquiv.AddSubmonoidMap` for a variant for `AddEquiv`s.\"]\ndef submonoidMap (f : M →* N) (M' : Submonoid M) : M' →* M'.map f where\n  toFun x := ⟨f x, ⟨x, x.2, rfl⟩⟩\n  map_one' := Subtype.eq <| f.map_one\n  map_mul' x y := Subtype.eq <| f.map_mul x y\n\n"}
{"name":"MonoidHom.submonoidMap_apply_coe","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\nM' : Submonoid M\nx : Subtype fun x => Membership.mem M' x\n⊢ Eq (↑((f.submonoidMap M') x)) (f ↑x)","decl":"/-- The `MonoidHom` from a submonoid to its image.\nSee `MulEquiv.SubmonoidMap` for a variant for `MulEquiv`s. -/\n@[to_additive (attr := simps)\n      \"the `AddMonoidHom` from an additive submonoid to its image. See\n      `AddEquiv.AddSubmonoidMap` for a variant for `AddEquiv`s.\"]\ndef submonoidMap (f : M →* N) (M' : Submonoid M) : M' →* M'.map f where\n  toFun x := ⟨f x, ⟨x, x.2, rfl⟩⟩\n  map_one' := Subtype.eq <| f.map_one\n  map_mul' x y := Subtype.eq <| f.map_mul x y\n\n"}
{"name":"MonoidHom.submonoidMap_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\nM' : Submonoid M\n⊢ Function.Surjective ⇑(f.submonoidMap M')","decl":"@[to_additive]\ntheorem submonoidMap_surjective (f : M →* N) (M' : Submonoid M) :\n    Function.Surjective (f.submonoidMap M') := by\n  rintro ⟨_, x, hx, rfl⟩\n  exact ⟨⟨x, hx⟩, rfl⟩\n\n"}
{"name":"AddMonoidHom.addSubmonoidMap_surjective","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\nM' : AddSubmonoid M\n⊢ Function.Surjective ⇑(f.addSubmonoidMap M')","decl":"@[to_additive]\ntheorem submonoidMap_surjective (f : M →* N) (M' : Submonoid M) :\n    Function.Surjective (f.submonoidMap M') := by\n  rintro ⟨_, x, hx, rfl⟩\n  exact ⟨⟨x, hx⟩, rfl⟩\n\n"}
{"name":"AddSubmonoid.mrange_inl","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mrange (AddMonoidHom.inl M N)) (Top.top.prod Bot.bot)","decl":"@[to_additive]\ntheorem mrange_inl : mrange (inl M N) = prod ⊤ ⊥ := by simpa only [mrange_eq_map] using map_inl ⊤\n\n"}
{"name":"Submonoid.mrange_inl","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mrange (MonoidHom.inl M N)) (Top.top.prod Bot.bot)","decl":"@[to_additive]\ntheorem mrange_inl : mrange (inl M N) = prod ⊤ ⊥ := by simpa only [mrange_eq_map] using map_inl ⊤\n\n"}
{"name":"Submonoid.mrange_inr","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mrange (MonoidHom.inr M N)) (Bot.bot.prod Top.top)","decl":"@[to_additive]\ntheorem mrange_inr : mrange (inr M N) = prod ⊥ ⊤ := by simpa only [mrange_eq_map] using map_inr ⊤\n\n"}
{"name":"AddSubmonoid.mrange_inr","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mrange (AddMonoidHom.inr M N)) (Bot.bot.prod Top.top)","decl":"@[to_additive]\ntheorem mrange_inr : mrange (inr M N) = prod ⊥ ⊤ := by simpa only [mrange_eq_map] using map_inr ⊤\n\n"}
{"name":"Submonoid.mrange_inl'","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mrange (MonoidHom.inl M N)) (Submonoid.comap (MonoidHom.snd M N) Bot.bot)","decl":"@[to_additive]\ntheorem mrange_inl' : mrange (inl M N) = comap (snd M N) ⊥ :=\n  mrange_inl.trans (top_prod _)\n\n"}
{"name":"AddSubmonoid.mrange_inl'","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mrange (AddMonoidHom.inl M N)) (AddSubmonoid.comap (AddMonoidHom.snd M N) Bot.bot)","decl":"@[to_additive]\ntheorem mrange_inl' : mrange (inl M N) = comap (snd M N) ⊥ :=\n  mrange_inl.trans (top_prod _)\n\n"}
{"name":"AddSubmonoid.mrange_inr'","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mrange (AddMonoidHom.inr M N)) (AddSubmonoid.comap (AddMonoidHom.fst M N) Bot.bot)","decl":"@[to_additive]\ntheorem mrange_inr' : mrange (inr M N) = comap (fst M N) ⊥ :=\n  mrange_inr.trans (prod_top _)\n\n"}
{"name":"Submonoid.mrange_inr'","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mrange (MonoidHom.inr M N)) (Submonoid.comap (MonoidHom.fst M N) Bot.bot)","decl":"@[to_additive]\ntheorem mrange_inr' : mrange (inr M N) = comap (fst M N) ⊥ :=\n  mrange_inr.trans (prod_top _)\n\n"}
{"name":"AddSubmonoid.mrange_fst","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mrange (AddMonoidHom.fst M N)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mrange_fst : mrange (fst M N) = ⊤ :=\n  mrange_eq_top_of_surjective (fst M N) <| @Prod.fst_surjective _ _ ⟨1⟩\n\n"}
{"name":"Submonoid.mrange_fst","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mrange (MonoidHom.fst M N)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mrange_fst : mrange (fst M N) = ⊤ :=\n  mrange_eq_top_of_surjective (fst M N) <| @Prod.fst_surjective _ _ ⟨1⟩\n\n"}
{"name":"Submonoid.mrange_snd","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mrange (MonoidHom.snd M N)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mrange_snd : mrange (snd M N) = ⊤ :=\n  mrange_eq_top_of_surjective (snd M N) <| @Prod.snd_surjective _ _ ⟨1⟩\n\n"}
{"name":"AddSubmonoid.mrange_snd","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mrange (AddMonoidHom.snd M N)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mrange_snd : mrange (snd M N) = ⊤ :=\n  mrange_eq_top_of_surjective (snd M N) <| @Prod.snd_surjective _ _ ⟨1⟩\n\n"}
{"name":"Submonoid.prod_eq_bot_iff","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\ns : Submonoid M\nt : Submonoid N\n⊢ Iff (Eq (s.prod t) Bot.bot) (And (Eq s Bot.bot) (Eq t Bot.bot))","decl":"@[to_additive prod_eq_bot_iff]\ntheorem prod_eq_bot_iff {s : Submonoid M} {t : Submonoid N} : s.prod t = ⊥ ↔ s = ⊥ ∧ t = ⊥ := by\n  simp only [eq_bot_iff, prod_le_iff, (gc_map_comap _).le_iff_le, comap_bot', mker_inl, mker_inr]\n-- Porting note: to_additive translated the name incorrectly in mathlib 3.\n\n"}
{"name":"AddSubmonoid.prod_eq_bot_iff","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\ns : AddSubmonoid M\nt : AddSubmonoid N\n⊢ Iff (Eq (s.prod t) Bot.bot) (And (Eq s Bot.bot) (Eq t Bot.bot))","decl":"@[to_additive prod_eq_bot_iff]\ntheorem prod_eq_bot_iff {s : Submonoid M} {t : Submonoid N} : s.prod t = ⊥ ↔ s = ⊥ ∧ t = ⊥ := by\n  simp only [eq_bot_iff, prod_le_iff, (gc_map_comap _).le_iff_le, comap_bot', mker_inl, mker_inr]\n-- Porting note: to_additive translated the name incorrectly in mathlib 3.\n\n"}
{"name":"AddSubmonoid.prod_eq_top_iff","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\ns : AddSubmonoid M\nt : AddSubmonoid N\n⊢ Iff (Eq (s.prod t) Top.top) (And (Eq s Top.top) (Eq t Top.top))","decl":"@[to_additive prod_eq_top_iff]\ntheorem prod_eq_top_iff {s : Submonoid M} {t : Submonoid N} : s.prod t = ⊤ ↔ s = ⊤ ∧ t = ⊤ := by\n  simp only [eq_top_iff, le_prod_iff, ← (gc_map_comap _).le_iff_le, ← mrange_eq_map, mrange_fst,\n    mrange_snd]\n-- Porting note: to_additive translated the name incorrectly in mathlib 3.\n\n"}
{"name":"Submonoid.prod_eq_top_iff","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\ns : Submonoid M\nt : Submonoid N\n⊢ Iff (Eq (s.prod t) Top.top) (And (Eq s Top.top) (Eq t Top.top))","decl":"@[to_additive prod_eq_top_iff]\ntheorem prod_eq_top_iff {s : Submonoid M} {t : Submonoid N} : s.prod t = ⊤ ↔ s = ⊤ ∧ t = ⊤ := by\n  simp only [eq_top_iff, le_prod_iff, ← (gc_map_comap _).le_iff_le, ← mrange_eq_map, mrange_fst,\n    mrange_snd]\n-- Porting note: to_additive translated the name incorrectly in mathlib 3.\n\n"}
{"name":"Submonoid.mrange_inl_sup_mrange_inr","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (Max.max (MonoidHom.mrange (MonoidHom.inl M N)) (MonoidHom.mrange (MonoidHom.inr M N))) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mrange_inl_sup_mrange_inr : mrange (inl M N) ⊔ mrange (inr M N) = ⊤ := by\n  simp only [mrange_inl, mrange_inr, prod_bot_sup_bot_prod, top_prod_top]\n\n"}
{"name":"AddSubmonoid.mrange_inl_sup_mrange_inr","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (Max.max (AddMonoidHom.mrange (AddMonoidHom.inl M N)) (AddMonoidHom.mrange (AddMonoidHom.inr M N))) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mrange_inl_sup_mrange_inr : mrange (inl M N) ⊔ mrange (inr M N) = ⊤ := by\n  simp only [mrange_inl, mrange_inr, prod_bot_sup_bot_prod, top_prod_top]\n\n"}
{"name":"AddSubmonoid.mrange_subtype","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns : AddSubmonoid M\n⊢ Eq (AddMonoidHom.mrange s.subtype) s","decl":"@[to_additive (attr := simp)]\ntheorem mrange_subtype (s : Submonoid M) : mrange s.subtype = s :=\n  SetLike.coe_injective <| (coe_mrange _).trans <| Subtype.range_coe\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Submonoid.mrange_subtype","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Submonoid M\n⊢ Eq (MonoidHom.mrange s.subtype) s","decl":"@[to_additive (attr := simp)]\ntheorem mrange_subtype (s : Submonoid M) : mrange s.subtype = s :=\n  SetLike.coe_injective <| (coe_mrange _).trans <| Subtype.range_coe\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Submonoid.range_subtype","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\ns : Submonoid M\n⊢ Eq (MonoidHom.mrange s.subtype) s","decl":"@[to_additive] alias range_subtype := mrange_subtype\n"}
{"name":"AddSubmonoid.range_subtype","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\ns : AddSubmonoid M\n⊢ Eq (AddMonoidHom.mrange s.subtype) s","decl":"@[to_additive] alias range_subtype := mrange_subtype\n"}
{"name":"AddSubmonoid.eq_top_iff'","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Iff (Eq S Top.top) (∀ (x : M), Membership.mem S x)","decl":"@[to_additive]\ntheorem eq_top_iff' : S = ⊤ ↔ ∀ x : M, x ∈ S :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n\n"}
{"name":"Submonoid.eq_top_iff'","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Iff (Eq S Top.top) (∀ (x : M), Membership.mem S x)","decl":"@[to_additive]\ntheorem eq_top_iff' : S = ⊤ ↔ ∀ x : M, x ∈ S :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n\n"}
{"name":"AddSubmonoid.eq_bot_iff_forall","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Iff (Eq S Bot.bot) (∀ (x : M), Membership.mem S x → Eq x 0)","decl":"@[to_additive]\ntheorem eq_bot_iff_forall : S = ⊥ ↔ ∀ x ∈ S, x = (1 : M) :=\n  SetLike.ext_iff.trans <| by simp +contextual [iff_def, S.one_mem]\n\n"}
{"name":"Submonoid.eq_bot_iff_forall","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Iff (Eq S Bot.bot) (∀ (x : M), Membership.mem S x → Eq x 1)","decl":"@[to_additive]\ntheorem eq_bot_iff_forall : S = ⊥ ↔ ∀ x ∈ S, x = (1 : M) :=\n  SetLike.ext_iff.trans <| by simp +contextual [iff_def, S.one_mem]\n\n"}
{"name":"Submonoid.eq_bot_of_subsingleton","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝¹ : MulOneClass M\nS : Submonoid M\ninst✝ : Subsingleton (Subtype fun x => Membership.mem S x)\n⊢ Eq S Bot.bot","decl":"@[to_additive]\ntheorem eq_bot_of_subsingleton [Subsingleton S] : S = ⊥ := by\n  rw [eq_bot_iff_forall]\n  intro y hy\n  simpa using congr_arg ((↑) : S → M) <| Subsingleton.elim (⟨y, hy⟩ : S) 1\n\n"}
{"name":"AddSubmonoid.eq_bot_of_subsingleton","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝¹ : AddZeroClass M\nS : AddSubmonoid M\ninst✝ : Subsingleton (Subtype fun x => Membership.mem S x)\n⊢ Eq S Bot.bot","decl":"@[to_additive]\ntheorem eq_bot_of_subsingleton [Subsingleton S] : S = ⊥ := by\n  rw [eq_bot_iff_forall]\n  intro y hy\n  simpa using congr_arg ((↑) : S → M) <| Subsingleton.elim (⟨y, hy⟩ : S) 1\n\n"}
{"name":"AddSubmonoid.nontrivial_iff_exists_ne_zero","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Iff (Nontrivial (Subtype fun x => Membership.mem S x)) (Exists fun x => And (Membership.mem S x) (Ne x 0))","decl":"@[to_additive]\ntheorem nontrivial_iff_exists_ne_one (S : Submonoid M) : Nontrivial S ↔ ∃ x ∈ S, x ≠ (1 : M) :=\n  calc\n    Nontrivial S ↔ ∃ x : S, x ≠ 1 := nontrivial_iff_exists_ne 1\n    _ ↔ ∃ (x : _) (hx : x ∈ S), (⟨x, hx⟩ : S) ≠ ⟨1, S.one_mem⟩ := Subtype.exists\n    _ ↔ ∃ x ∈ S, x ≠ (1 : M) := by simp [Ne]\n\n"}
{"name":"Submonoid.nontrivial_iff_exists_ne_one","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Iff (Nontrivial (Subtype fun x => Membership.mem S x)) (Exists fun x => And (Membership.mem S x) (Ne x 1))","decl":"@[to_additive]\ntheorem nontrivial_iff_exists_ne_one (S : Submonoid M) : Nontrivial S ↔ ∃ x ∈ S, x ≠ (1 : M) :=\n  calc\n    Nontrivial S ↔ ∃ x : S, x ≠ 1 := nontrivial_iff_exists_ne 1\n    _ ↔ ∃ (x : _) (hx : x ∈ S), (⟨x, hx⟩ : S) ≠ ⟨1, S.one_mem⟩ := Subtype.exists\n    _ ↔ ∃ x ∈ S, x ≠ (1 : M) := by simp [Ne]\n\n"}
{"name":"AddSubmonoid.bot_or_nontrivial","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Or (Eq S Bot.bot) (Nontrivial (Subtype fun x => Membership.mem S x))","decl":"/-- A submonoid is either the trivial submonoid or nontrivial. -/\n@[to_additive \"An additive submonoid is either the trivial additive submonoid or nontrivial.\"]\ntheorem bot_or_nontrivial (S : Submonoid M) : S = ⊥ ∨ Nontrivial S := by\n  simp only [eq_bot_iff_forall, nontrivial_iff_exists_ne_one, ← not_forall, ← Classical.not_imp,\n    Classical.em]\n\n"}
{"name":"Submonoid.bot_or_nontrivial","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Or (Eq S Bot.bot) (Nontrivial (Subtype fun x => Membership.mem S x))","decl":"/-- A submonoid is either the trivial submonoid or nontrivial. -/\n@[to_additive \"An additive submonoid is either the trivial additive submonoid or nontrivial.\"]\ntheorem bot_or_nontrivial (S : Submonoid M) : S = ⊥ ∨ Nontrivial S := by\n  simp only [eq_bot_iff_forall, nontrivial_iff_exists_ne_one, ← not_forall, ← Classical.not_imp,\n    Classical.em]\n\n"}
{"name":"AddSubmonoid.bot_or_exists_ne_zero","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Or (Eq S Bot.bot) (Exists fun x => And (Membership.mem S x) (Ne x 0))","decl":"/-- A submonoid is either the trivial submonoid or contains a nonzero element. -/\n@[to_additive\n      \"An additive submonoid is either the trivial additive submonoid or contains a nonzero\n      element.\"]\ntheorem bot_or_exists_ne_one (S : Submonoid M) : S = ⊥ ∨ ∃ x ∈ S, x ≠ (1 : M) :=\n  S.bot_or_nontrivial.imp_right S.nontrivial_iff_exists_ne_one.mp\n\n"}
{"name":"Submonoid.bot_or_exists_ne_one","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Or (Eq S Bot.bot) (Exists fun x => And (Membership.mem S x) (Ne x 1))","decl":"/-- A submonoid is either the trivial submonoid or contains a nonzero element. -/\n@[to_additive\n      \"An additive submonoid is either the trivial additive submonoid or contains a nonzero\n      element.\"]\ntheorem bot_or_exists_ne_one (S : Submonoid M) : S = ⊥ ∨ ∃ x ∈ S, x ≠ (1 : M) :=\n  S.bot_or_nontrivial.imp_right S.nontrivial_iff_exists_ne_one.mp\n\n"}
{"name":"MulEquiv.ofLeftInverse'_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\ng : N → M\nh : Function.LeftInverse g ⇑f\na✝ : Subtype fun x => Membership.mem (MonoidHom.mrange f) x\n⊢ Eq ((MulEquiv.ofLeftInverse' f h).symm a✝) (g ↑a✝)","decl":"/-- A monoid homomorphism `f : M →* N` with a left-inverse `g : N → M` defines a multiplicative\nequivalence between `M` and `f.mrange`.\nThis is a bidirectional version of `MonoidHom.mrange_restrict`. -/\n@[to_additive (attr := simps (config := { simpRhs := true }))\n      \"An additive monoid homomorphism `f : M →+ N` with a left-inverse `g : N → M`\n      defines an additive equivalence between `M` and `f.mrange`.\n      This is a bidirectional version of `AddMonoidHom.mrange_restrict`. \"]\ndef ofLeftInverse' (f : M →* N) {g : N → M} (h : Function.LeftInverse g f) :\n    M ≃* MonoidHom.mrange f :=\n  { f.mrangeRestrict with\n    toFun := f.mrangeRestrict\n    invFun := g ∘ f.mrange.subtype\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let ⟨x', hx'⟩ := MonoidHom.mem_mrange.mp x.2\n        show f (g x) = x by rw [← hx', h x'] }\n\n"}
{"name":"MulEquiv.ofLeftInverse'_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\ng : N → M\nh : Function.LeftInverse g ⇑f\na : M\n⊢ Eq ((MulEquiv.ofLeftInverse' f h) a) (f.mrangeRestrict a)","decl":"/-- A monoid homomorphism `f : M →* N` with a left-inverse `g : N → M` defines a multiplicative\nequivalence between `M` and `f.mrange`.\nThis is a bidirectional version of `MonoidHom.mrange_restrict`. -/\n@[to_additive (attr := simps (config := { simpRhs := true }))\n      \"An additive monoid homomorphism `f : M →+ N` with a left-inverse `g : N → M`\n      defines an additive equivalence between `M` and `f.mrange`.\n      This is a bidirectional version of `AddMonoidHom.mrange_restrict`. \"]\ndef ofLeftInverse' (f : M →* N) {g : N → M} (h : Function.LeftInverse g f) :\n    M ≃* MonoidHom.mrange f :=\n  { f.mrangeRestrict with\n    toFun := f.mrangeRestrict\n    invFun := g ∘ f.mrange.subtype\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let ⟨x', hx'⟩ := MonoidHom.mem_mrange.mp x.2\n        show f (g x) = x by rw [← hx', h x'] }\n\n"}
{"name":"AddEquiv.ofLeftInverse'_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\ng : N → M\nh : Function.LeftInverse g ⇑f\na✝ : Subtype fun x => Membership.mem (AddMonoidHom.mrange f) x\n⊢ Eq ((AddEquiv.ofLeftInverse' f h).symm a✝) (g ↑a✝)","decl":"/-- A monoid homomorphism `f : M →* N` with a left-inverse `g : N → M` defines a multiplicative\nequivalence between `M` and `f.mrange`.\nThis is a bidirectional version of `MonoidHom.mrange_restrict`. -/\n@[to_additive (attr := simps (config := { simpRhs := true }))\n      \"An additive monoid homomorphism `f : M →+ N` with a left-inverse `g : N → M`\n      defines an additive equivalence between `M` and `f.mrange`.\n      This is a bidirectional version of `AddMonoidHom.mrange_restrict`. \"]\ndef ofLeftInverse' (f : M →* N) {g : N → M} (h : Function.LeftInverse g f) :\n    M ≃* MonoidHom.mrange f :=\n  { f.mrangeRestrict with\n    toFun := f.mrangeRestrict\n    invFun := g ∘ f.mrange.subtype\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let ⟨x', hx'⟩ := MonoidHom.mem_mrange.mp x.2\n        show f (g x) = x by rw [← hx', h x'] }\n\n"}
{"name":"AddEquiv.ofLeftInverse'_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\ng : N → M\nh : Function.LeftInverse g ⇑f\na : M\n⊢ Eq ((AddEquiv.ofLeftInverse' f h) a) (f.mrangeRestrict a)","decl":"/-- A monoid homomorphism `f : M →* N` with a left-inverse `g : N → M` defines a multiplicative\nequivalence between `M` and `f.mrange`.\nThis is a bidirectional version of `MonoidHom.mrange_restrict`. -/\n@[to_additive (attr := simps (config := { simpRhs := true }))\n      \"An additive monoid homomorphism `f : M →+ N` with a left-inverse `g : N → M`\n      defines an additive equivalence between `M` and `f.mrange`.\n      This is a bidirectional version of `AddMonoidHom.mrange_restrict`. \"]\ndef ofLeftInverse' (f : M →* N) {g : N → M} (h : Function.LeftInverse g f) :\n    M ≃* MonoidHom.mrange f :=\n  { f.mrangeRestrict with\n    toFun := f.mrangeRestrict\n    invFun := g ∘ f.mrange.subtype\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let ⟨x', hx'⟩ := MonoidHom.mem_mrange.mp x.2\n        show f (g x) = x by rw [← hx', h x'] }\n\n"}
{"name":"AddEquiv.coe_addSubmonoidMap_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\ne : AddEquiv M N\nS : AddSubmonoid M\ng : Subtype fun x => Membership.mem S x\n⊢ Eq (↑((e.addSubmonoidMap S) g)) (e ↑g)","decl":"@[to_additive (attr := simp)]\ntheorem coe_submonoidMap_apply (e : M ≃* N) (S : Submonoid M) (g : S) :\n    ((submonoidMap e S g : S.map (e : M →* N)) : N) = e g :=\n  rfl\n\n"}
{"name":"MulEquiv.coe_submonoidMap_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\ne : MulEquiv M N\nS : Submonoid M\ng : Subtype fun x => Membership.mem S x\n⊢ Eq (↑((e.submonoidMap S) g)) (e ↑g)","decl":"@[to_additive (attr := simp)]\ntheorem coe_submonoidMap_apply (e : M ≃* N) (S : Submonoid M) (g : S) :\n    ((submonoidMap e S g : S.map (e : M →* N)) : N) = e g :=\n  rfl\n\n"}
{"name":"AddEquiv.add_submonoid_map_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\ne : AddEquiv M N\nS : AddSubmonoid M\ng : Subtype fun x => Membership.mem (AddSubmonoid.map (↑e) S) x\n⊢ Eq ((e.addSubmonoidMap S).symm g) ⟨e.symm ↑g, ⋯⟩","decl":"@[to_additive (attr := simp) AddEquiv.add_submonoid_map_symm_apply]\ntheorem submonoidMap_symm_apply (e : M ≃* N) (S : Submonoid M) (g : S.map (e : M →* N)) :\n    (e.submonoidMap S).symm g = ⟨e.symm g, SetLike.mem_coe.1 <| Set.mem_image_equiv.1 g.2⟩ :=\n  rfl\n\n"}
{"name":"MulEquiv.submonoidMap_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\ne : MulEquiv M N\nS : Submonoid M\ng : Subtype fun x => Membership.mem (Submonoid.map (↑e) S) x\n⊢ Eq ((e.submonoidMap S).symm g) ⟨e.symm ↑g, ⋯⟩","decl":"@[to_additive (attr := simp) AddEquiv.add_submonoid_map_symm_apply]\ntheorem submonoidMap_symm_apply (e : M ≃* N) (S : Submonoid M) (g : S.map (e : M →* N)) :\n    (e.submonoidMap S).symm g = ⟨e.symm g, SetLike.mem_coe.1 <| Set.mem_image_equiv.1 g.2⟩ :=\n  rfl\n\n"}
{"name":"Submonoid.equivMapOfInjective_coe_mulEquiv","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nS : Submonoid M\ne : MulEquiv M N\n⊢ Eq (S.equivMapOfInjective ↑e ⋯) (e.submonoidMap S)","decl":"@[to_additive (attr := simp)]\ntheorem Submonoid.equivMapOfInjective_coe_mulEquiv (e : M ≃* N) :\n    S.equivMapOfInjective (e : M →* N) (EquivLike.injective e) = e.submonoidMap S := by\n  ext\n  rfl\n\n"}
{"name":"AddSubmonoid.equivMapOfInjective_coe_addEquiv","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nS : AddSubmonoid M\ne : AddEquiv M N\n⊢ Eq (S.equivMapOfInjective ↑e ⋯) (e.addSubmonoidMap S)","decl":"@[to_additive (attr := simp)]\ntheorem Submonoid.equivMapOfInjective_coe_mulEquiv (e : M ≃* N) :\n    S.equivMapOfInjective (e : M →* N) (EquivLike.injective e) = e.submonoidMap S := by\n  ext\n  rfl\n\n"}
{"name":"Submonoid.faithfulSMul","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M' : Type u_4\nα : Type u_5\ninst✝² : MulOneClass M'\ninst✝¹ : SMul M' α\nS : Submonoid M'\ninst✝ : FaithfulSMul M' α\n⊢ FaithfulSMul (Subtype fun x => Membership.mem S x) α","decl":"instance Submonoid.faithfulSMul {M' α : Type*} [MulOneClass M'] [SMul M' α] {S : Submonoid M'}\n    [FaithfulSMul M' α] : FaithfulSMul S α :=\n  ⟨fun h => Subtype.ext <| eq_of_smul_eq_smul h⟩\n\n"}
{"name":"Submonoid.val_unitsTypeEquivIsUnitSubmonoid_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx : Subtype fun x => Membership.mem (IsUnit.submonoid M) x\n⊢ Eq ↑(Submonoid.unitsTypeEquivIsUnitSubmonoid.symm x) ↑x","decl":"/-- The multiplicative equivalence between the type of units of `M` and the submonoid of unit\nelements of `M`. -/\n@[to_additive (attr := simps!) \" The additive equivalence between the type of additive units of `M`\n  and the additive submonoid whose elements are the additive units of `M`. \"]\nnoncomputable def unitsTypeEquivIsUnitSubmonoid [Monoid M] : Mˣ ≃* IsUnit.submonoid M where\n  toFun x := ⟨x, Units.isUnit x⟩\n  invFun x := x.prop.unit\n  left_inv _ := IsUnit.unit_of_val_units _\n  right_inv x := by simp_rw [IsUnit.unit_spec]\n  map_mul' x y := by simp_rw [Units.val_mul]; rfl\n\n"}
{"name":"Submonoid.unitsTypeEquivIsUnitSubmonoid_apply_coe","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx : Units M\n⊢ Eq ↑(Submonoid.unitsTypeEquivIsUnitSubmonoid x) ↑x","decl":"/-- The multiplicative equivalence between the type of units of `M` and the submonoid of unit\nelements of `M`. -/\n@[to_additive (attr := simps!) \" The additive equivalence between the type of additive units of `M`\n  and the additive submonoid whose elements are the additive units of `M`. \"]\nnoncomputable def unitsTypeEquivIsUnitSubmonoid [Monoid M] : Mˣ ≃* IsUnit.submonoid M where\n  toFun x := ⟨x, Units.isUnit x⟩\n  invFun x := x.prop.unit\n  left_inv _ := IsUnit.unit_of_val_units _\n  right_inv x := by simp_rw [IsUnit.unit_spec]\n  map_mul' x y := by simp_rw [Units.val_mul]; rfl\n\n"}
{"name":"AddSubmonoid.val_addUnitsTypeEquivIsAddUnitAddSubmonoid_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nx : Subtype fun x => Membership.mem (IsAddUnit.addSubmonoid M) x\n⊢ Eq ↑(AddSubmonoid.addUnitsTypeEquivIsAddUnitAddSubmonoid.symm x) ↑x","decl":"/-- The multiplicative equivalence between the type of units of `M` and the submonoid of unit\nelements of `M`. -/\n@[to_additive (attr := simps!) \" The additive equivalence between the type of additive units of `M`\n  and the additive submonoid whose elements are the additive units of `M`. \"]\nnoncomputable def unitsTypeEquivIsUnitSubmonoid [Monoid M] : Mˣ ≃* IsUnit.submonoid M where\n  toFun x := ⟨x, Units.isUnit x⟩\n  invFun x := x.prop.unit\n  left_inv _ := IsUnit.unit_of_val_units _\n  right_inv x := by simp_rw [IsUnit.unit_spec]\n  map_mul' x y := by simp_rw [Units.val_mul]; rfl\n\n"}
{"name":"AddSubmonoid.addUnitsTypeEquivIsAddUnitAddSubmonoid_apply_coe","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nx : AddUnits M\n⊢ Eq ↑(AddSubmonoid.addUnitsTypeEquivIsAddUnitAddSubmonoid x) ↑x","decl":"/-- The multiplicative equivalence between the type of units of `M` and the submonoid of unit\nelements of `M`. -/\n@[to_additive (attr := simps!) \" The additive equivalence between the type of additive units of `M`\n  and the additive submonoid whose elements are the additive units of `M`. \"]\nnoncomputable def unitsTypeEquivIsUnitSubmonoid [Monoid M] : Mˣ ≃* IsUnit.submonoid M where\n  toFun x := ⟨x, Units.isUnit x⟩\n  invFun x := x.prop.unit\n  left_inv _ := IsUnit.unit_of_val_units _\n  right_inv x := by simp_rw [IsUnit.unit_spec]\n  map_mul' x y := by simp_rw [Units.val_mul]; rfl\n\n"}
{"name":"AddSubmonoid.val_neg_addUnitsTypeEquivIsAddUnitAddSubmonoid_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nx : Subtype fun x => Membership.mem (IsAddUnit.addSubmonoid M) x\n⊢ Eq ↑(Neg.neg (AddSubmonoid.addUnitsTypeEquivIsAddUnitAddSubmonoid.symm x)) ↑(Neg.neg (Classical.choose ⋯))","decl":"/-- The multiplicative equivalence between the type of units of `M` and the submonoid of unit\nelements of `M`. -/\n@[to_additive (attr := simps!) \" The additive equivalence between the type of additive units of `M`\n  and the additive submonoid whose elements are the additive units of `M`. \"]\nnoncomputable def unitsTypeEquivIsUnitSubmonoid [Monoid M] : Mˣ ≃* IsUnit.submonoid M where\n  toFun x := ⟨x, Units.isUnit x⟩\n  invFun x := x.prop.unit\n  left_inv _ := IsUnit.unit_of_val_units _\n  right_inv x := by simp_rw [IsUnit.unit_spec]\n  map_mul' x y := by simp_rw [Units.val_mul]; rfl\n\n"}
{"name":"Submonoid.val_inv_unitsTypeEquivIsUnitSubmonoid_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx : Subtype fun x => Membership.mem (IsUnit.submonoid M) x\n⊢ Eq ↑(Inv.inv (Submonoid.unitsTypeEquivIsUnitSubmonoid.symm x)) ↑(Inv.inv (Classical.choose ⋯))","decl":"/-- The multiplicative equivalence between the type of units of `M` and the submonoid of unit\nelements of `M`. -/\n@[to_additive (attr := simps!) \" The additive equivalence between the type of additive units of `M`\n  and the additive submonoid whose elements are the additive units of `M`. \"]\nnoncomputable def unitsTypeEquivIsUnitSubmonoid [Monoid M] : Mˣ ≃* IsUnit.submonoid M where\n  toFun x := ⟨x, Units.isUnit x⟩\n  invFun x := x.prop.unit\n  left_inv _ := IsUnit.unit_of_val_units _\n  right_inv x := by simp_rw [IsUnit.unit_spec]\n  map_mul' x y := by simp_rw [Units.val_mul]; rfl\n\n"}
{"name":"Nat.addSubmonoid_closure_one","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"⊢ Eq (AddSubmonoid.closure (Singleton.singleton 1)) Top.top","decl":"@[simp] lemma addSubmonoid_closure_one : closure ({1} : Set ℕ) = ⊤ := by\n  refine (eq_top_iff' _).2 <| Nat.rec (zero_mem _) ?_\n  simp_rw [Nat.succ_eq_add_one]\n  exact fun n hn ↦ AddSubmonoid.add_mem _ hn <| subset_closure <| Set.mem_singleton _\n\n"}
{"name":"AddSubmonoid.map_comap_eq","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nS : AddSubmonoid N\n⊢ Eq (AddSubmonoid.map f (AddSubmonoid.comap f S)) (Min.min S (AddMonoidHom.mrange f))","decl":"@[to_additive]\ntheorem map_comap_eq (f : F) (S : Submonoid N) : (S.comap f).map f = S ⊓ MonoidHom.mrange f :=\n  SetLike.coe_injective Set.image_preimage_eq_inter_range\n\n"}
{"name":"Submonoid.map_comap_eq","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nS : Submonoid N\n⊢ Eq (Submonoid.map f (Submonoid.comap f S)) (Min.min S (MonoidHom.mrange f))","decl":"@[to_additive]\ntheorem map_comap_eq (f : F) (S : Submonoid N) : (S.comap f).map f = S ⊓ MonoidHom.mrange f :=\n  SetLike.coe_injective Set.image_preimage_eq_inter_range\n\n"}
{"name":"AddSubmonoid.map_comap_eq_self","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : AddMonoidHomClass F M N\nf : F\nS : AddSubmonoid N\nh : LE.le S (AddMonoidHom.mrange f)\n⊢ Eq (AddSubmonoid.map f (AddSubmonoid.comap f S)) S","decl":"@[to_additive]\ntheorem map_comap_eq_self {f : F} {S : Submonoid N} (h : S ≤ MonoidHom.mrange f) :\n    (S.comap f).map f = S := by\n  simpa only [inf_of_le_left h] using map_comap_eq f S\n\n"}
{"name":"Submonoid.map_comap_eq_self","module":"Mathlib.Algebra.Group.Submonoid.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\nF : Type u_4\ninst✝ : FunLike F M N\nmc : MonoidHomClass F M N\nf : F\nS : Submonoid N\nh : LE.le S (MonoidHom.mrange f)\n⊢ Eq (Submonoid.map f (Submonoid.comap f S)) S","decl":"@[to_additive]\ntheorem map_comap_eq_self {f : F} {S : Submonoid N} (h : S ≤ MonoidHom.mrange f) :\n    (S.comap f).map f = S := by\n  simpa only [inf_of_le_left h] using map_comap_eq f S\n\n"}
