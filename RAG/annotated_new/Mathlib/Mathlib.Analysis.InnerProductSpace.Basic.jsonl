{"name":"inner_conj_symm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq ((starRingEnd 𝕜) (Inner.inner y x)) (Inner.inner x y)","decl":"@[simp]\ntheorem inner_conj_symm (x y : E) : ⟪y, x⟫† = ⟪x, y⟫ :=\n  InnerProductSpace.conj_symm _ _\n\n"}
{"name":"real_inner_comm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Eq (Inner.inner y x) (Inner.inner x y)","decl":"theorem real_inner_comm (x y : F) : ⟪y, x⟫_ℝ = ⟪x, y⟫_ℝ :=\n  @inner_conj_symm ℝ _ _ _ _ x y\n\n"}
{"name":"inner_eq_zero_symm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Iff (Eq (Inner.inner x y) 0) (Eq (Inner.inner y x) 0)","decl":"theorem inner_eq_zero_symm {x y : E} : ⟪x, y⟫ = 0 ↔ ⟪y, x⟫ = 0 := by\n  rw [← inner_conj_symm]\n  exact star_eq_zero\n\n"}
{"name":"inner_self_im","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (RCLike.im (Inner.inner x x)) 0","decl":"@[simp]\ntheorem inner_self_im (x : E) : im ⟪x, x⟫ = 0 := by rw [← @ofReal_inj 𝕜, im_eq_conj_sub]; simp\n\n"}
{"name":"inner_add_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y z : E\n⊢ Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))","decl":"theorem inner_add_left (x y z : E) : ⟪x + y, z⟫ = ⟪x, z⟫ + ⟪y, z⟫ :=\n  InnerProductSpace.add_left _ _ _\n\n"}
{"name":"inner_add_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y z : E\n⊢ Eq (Inner.inner x (HAdd.hAdd y z)) (HAdd.hAdd (Inner.inner x y) (Inner.inner x z))","decl":"theorem inner_add_right (x y z : E) : ⟪x, y + z⟫ = ⟪x, y⟫ + ⟪x, z⟫ := by\n  rw [← inner_conj_symm, inner_add_left, RingHom.map_add]\n  simp only [inner_conj_symm]\n\n"}
{"name":"inner_re_symm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (RCLike.re (Inner.inner x y)) (RCLike.re (Inner.inner y x))","decl":"theorem inner_re_symm (x y : E) : re ⟪x, y⟫ = re ⟪y, x⟫ := by rw [← inner_conj_symm, conj_re]\n\n"}
{"name":"inner_im_symm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (RCLike.im (Inner.inner x y)) (Neg.neg (RCLike.im (Inner.inner y x)))","decl":"theorem inner_im_symm (x y : E) : im ⟪x, y⟫ = -im ⟪y, x⟫ := by rw [← inner_conj_symm, conj_im]\n\n"}
{"name":"inner_smul_left_eq_star_smul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁸ : RCLike 𝕜\ninst✝⁷ : SeminormedAddCommGroup E\ninst✝⁶ : InnerProductSpace 𝕜 E\n𝕝 : Type u_4\ninst✝⁵ : CommSemiring 𝕝\ninst✝⁴ : StarRing 𝕝\ninst✝³ : Algebra 𝕝 𝕜\ninst✝² : Module 𝕝 E\ninst✝¹ : IsScalarTower 𝕝 𝕜 E\ninst✝ : StarModule 𝕝 𝕜\nx y : E\nr : 𝕝\n⊢ Eq (Inner.inner (HSMul.hSMul r x) y) (HSMul.hSMul ((starRingEnd 𝕝) r) (Inner.inner x y))","decl":"/-- See `inner_smul_left` for the common special when `𝕜 = 𝕝`. -/\nlemma inner_smul_left_eq_star_smul (x y : E) (r : 𝕝) : ⟪r • x, y⟫ = r† • ⟪x, y⟫ := by\n  rw [← algebraMap_smul 𝕜 r, InnerProductSpace.smul_left, starRingEnd_apply, starRingEnd_apply,\n    ← algebraMap_star_comm, ← smul_eq_mul, algebraMap_smul]\n\n"}
{"name":"inner_smul_left_eq_smul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁹ : RCLike 𝕜\ninst✝⁸ : SeminormedAddCommGroup E\ninst✝⁷ : InnerProductSpace 𝕜 E\n𝕝 : Type u_4\ninst✝⁶ : CommSemiring 𝕝\ninst✝⁵ : StarRing 𝕝\ninst✝⁴ : Algebra 𝕝 𝕜\ninst✝³ : Module 𝕝 E\ninst✝² : IsScalarTower 𝕝 𝕜 E\ninst✝¹ : StarModule 𝕝 𝕜\ninst✝ : TrivialStar 𝕝\nx y : E\nr : 𝕝\n⊢ Eq (Inner.inner (HSMul.hSMul r x) y) (HSMul.hSMul r (Inner.inner x y))","decl":"/-- Special case of `inner_smul_left_eq_star_smul` when the acting ring has a trivial star\n(eg `ℕ`, `ℤ`, `ℚ≥0`, `ℚ`, `ℝ`). -/\nlemma inner_smul_left_eq_smul [TrivialStar 𝕝] (x y : E) (r : 𝕝) : ⟪r • x, y⟫ = r • ⟪x, y⟫ := by\n  rw [inner_smul_left_eq_star_smul, starRingEnd_apply, star_trivial]\n\n"}
{"name":"inner_smul_right_eq_smul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁸ : RCLike 𝕜\ninst✝⁷ : SeminormedAddCommGroup E\ninst✝⁶ : InnerProductSpace 𝕜 E\n𝕝 : Type u_4\ninst✝⁵ : CommSemiring 𝕝\ninst✝⁴ : StarRing 𝕝\ninst✝³ : Algebra 𝕝 𝕜\ninst✝² : Module 𝕝 E\ninst✝¹ : IsScalarTower 𝕝 𝕜 E\ninst✝ : StarModule 𝕝 𝕜\nx y : E\nr : 𝕝\n⊢ Eq (Inner.inner x (HSMul.hSMul r y)) (HSMul.hSMul r (Inner.inner x y))","decl":"/-- See `inner_smul_right` for the common special when `𝕜 = 𝕝`. -/\nlemma inner_smul_right_eq_smul (x y : E) (r : 𝕝) : ⟪x, r • y⟫ = r • ⟪x, y⟫ := by\n  rw [← inner_conj_symm, inner_smul_left_eq_star_smul, starRingEnd_apply, starRingEnd_apply,\n    star_smul, star_star, ← starRingEnd_apply, inner_conj_symm]\n\n"}
{"name":"inner_smul_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\nr : 𝕜\n⊢ Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd 𝕜) r) (Inner.inner x y))","decl":"/-- See `inner_smul_left_eq_star_smul` for the case of a general algebra action. -/\ntheorem inner_smul_left (x y : E) (r : 𝕜) : ⟪r • x, y⟫ = r† * ⟪x, y⟫ :=\n  inner_smul_left_eq_star_smul ..\n\n"}
{"name":"real_inner_smul_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\nr : Real\n⊢ Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul r (Inner.inner x y))","decl":"theorem real_inner_smul_left (x y : F) (r : ℝ) : ⟪r • x, y⟫_ℝ = r * ⟪x, y⟫_ℝ :=\n  inner_smul_left _ _ _\n\n"}
{"name":"inner_smul_real_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\nr : Real\n⊢ Eq (Inner.inner (HSMul.hSMul (↑r) x) y) (HSMul.hSMul r (Inner.inner x y))","decl":"theorem inner_smul_real_left (x y : E) (r : ℝ) : ⟪(r : 𝕜) • x, y⟫ = r • ⟪x, y⟫ := by\n  rw [inner_smul_left, conj_ofReal, Algebra.smul_def]\n\n"}
{"name":"inner_smul_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\nr : 𝕜\n⊢ Eq (Inner.inner x (HSMul.hSMul r y)) (HMul.hMul r (Inner.inner x y))","decl":"/-- See `inner_smul_right_eq_smul` for the case of a general algebra action. -/\ntheorem inner_smul_right (x y : E) (r : 𝕜) : ⟪x, r • y⟫ = r * ⟪x, y⟫ :=\n  inner_smul_right_eq_smul ..\n\n"}
{"name":"real_inner_smul_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\nr : Real\n⊢ Eq (Inner.inner x (HSMul.hSMul r y)) (HMul.hMul r (Inner.inner x y))","decl":"theorem real_inner_smul_right (x y : F) (r : ℝ) : ⟪x, r • y⟫_ℝ = r * ⟪x, y⟫_ℝ :=\n  inner_smul_right _ _ _\n\n"}
{"name":"inner_smul_real_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\nr : Real\n⊢ Eq (Inner.inner x (HSMul.hSMul (↑r) y)) (HSMul.hSMul r (Inner.inner x y))","decl":"theorem inner_smul_real_right (x y : E) (r : ℝ) : ⟪x, (r : 𝕜) • y⟫ = r • ⟪x, y⟫ := by\n  rw [inner_smul_right, Algebra.smul_def]\n\n"}
{"name":"sesqFormOfInner_apply_apply","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nm y : E\n⊢ Eq ((sesqFormOfInner m) y) (Inner.inner y m)","decl":"/-- The inner product as a sesquilinear form.\n\nNote that in the case `𝕜 = ℝ` this is a bilinear form. -/\n@[simps!]\ndef sesqFormOfInner : E →ₗ[𝕜] E →ₗ⋆[𝕜] 𝕜 :=\n  LinearMap.mk₂'ₛₗ (RingHom.id 𝕜) (starRingEnd _) (fun x y => ⟪y, x⟫)\n    (fun _x _y _z => inner_add_right _ _ _) (fun _r _x _y => inner_smul_right _ _ _)\n    (fun _x _y _z => inner_add_left _ _ _) fun _r _x _y => inner_smul_left _ _ _\n\n"}
{"name":"bilinFormOfRealInner_apply_apply","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nm✝ m : F\n⊢ Eq ((bilinFormOfRealInner m✝) m) (Inner.inner m✝ m)","decl":"/-- The real inner product as a bilinear form.\n\nNote that unlike `sesqFormOfInner`, this does not reverse the order of the arguments. -/\n@[simps!]\ndef bilinFormOfRealInner : BilinForm ℝ F := sesqFormOfInner.flip\n\n"}
{"name":"sum_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\ns : Finset ι\nf : ι → E\nx : E\n⊢ Eq (Inner.inner (s.sum fun i => f i) x) (s.sum fun i => Inner.inner (f i) x)","decl":"/-- An inner product with a sum on the left. -/\ntheorem sum_inner {ι : Type*} (s : Finset ι) (f : ι → E) (x : E) :\n    ⟪∑ i ∈ s, f i, x⟫ = ∑ i ∈ s, ⟪f i, x⟫ :=\n  map_sum (sesqFormOfInner (𝕜 := 𝕜) (E := E) x) _ _\n\n"}
{"name":"inner_sum","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\ns : Finset ι\nf : ι → E\nx : E\n⊢ Eq (Inner.inner x (s.sum fun i => f i)) (s.sum fun i => Inner.inner x (f i))","decl":"/-- An inner product with a sum on the right. -/\ntheorem inner_sum {ι : Type*} (s : Finset ι) (f : ι → E) (x : E) :\n    ⟪x, ∑ i ∈ s, f i⟫ = ∑ i ∈ s, ⟪x, f i⟫ :=\n  map_sum (LinearMap.flip sesqFormOfInner x) _ _\n\n"}
{"name":"Finsupp.sum_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nl : Finsupp ι 𝕜\nv : ι → E\nx : E\n⊢ Eq (Inner.inner (l.sum fun i a => HSMul.hSMul a (v i)) x) (l.sum fun i a => HSMul.hSMul ((starRingEnd 𝕜) a) (Inner.inner (v i) x))","decl":"/-- An inner product with a sum on the left, `Finsupp` version. -/\nprotected theorem Finsupp.sum_inner {ι : Type*} (l : ι →₀ 𝕜) (v : ι → E) (x : E) :\n    ⟪l.sum fun (i : ι) (a : 𝕜) => a • v i, x⟫ = l.sum fun (i : ι) (a : 𝕜) => conj a • ⟪v i, x⟫ := by\n  convert sum_inner (𝕜 := 𝕜) l.support (fun a => l a • v a) x\n  simp only [inner_smul_left, Finsupp.sum, smul_eq_mul]\n\n"}
{"name":"Finsupp.inner_sum","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nl : Finsupp ι 𝕜\nv : ι → E\nx : E\n⊢ Eq (Inner.inner x (l.sum fun i a => HSMul.hSMul a (v i))) (l.sum fun i a => HSMul.hSMul a (Inner.inner x (v i)))","decl":"/-- An inner product with a sum on the right, `Finsupp` version. -/\nprotected theorem Finsupp.inner_sum {ι : Type*} (l : ι →₀ 𝕜) (v : ι → E) (x : E) :\n    ⟪x, l.sum fun (i : ι) (a : 𝕜) => a • v i⟫ = l.sum fun (i : ι) (a : 𝕜) => a • ⟪x, v i⟫ := by\n  convert inner_sum (𝕜 := 𝕜) l.support (fun a => l a • v a) x\n  simp only [inner_smul_right, Finsupp.sum, smul_eq_mul]\n\n"}
{"name":"DFinsupp.sum_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_4\ninst✝² : DecidableEq ι\nα : ι → Type u_5\ninst✝¹ : (i : ι) → AddZeroClass (α i)\ninst✝ : (i : ι) → (x : α i) → Decidable (Ne x 0)\nf : (i : ι) → α i → E\nl : DFinsupp fun i => α i\nx : E\n⊢ Eq (Inner.inner (l.sum f) x) (l.sum fun i a => Inner.inner (f i a) x)","decl":"protected theorem DFinsupp.sum_inner {ι : Type*} [DecidableEq ι] {α : ι → Type*}\n    [∀ i, AddZeroClass (α i)] [∀ (i) (x : α i), Decidable (x ≠ 0)] (f : ∀ i, α i → E)\n    (l : Π₀ i, α i) (x : E) : ⟪l.sum f, x⟫ = l.sum fun i a => ⟪f i a, x⟫ := by\n  simp +contextual only [DFinsupp.sum, sum_inner, smul_eq_mul]\n\n"}
{"name":"DFinsupp.inner_sum","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\nι : Type u_4\ninst✝² : DecidableEq ι\nα : ι → Type u_5\ninst✝¹ : (i : ι) → AddZeroClass (α i)\ninst✝ : (i : ι) → (x : α i) → Decidable (Ne x 0)\nf : (i : ι) → α i → E\nl : DFinsupp fun i => α i\nx : E\n⊢ Eq (Inner.inner x (l.sum f)) (l.sum fun i a => Inner.inner x (f i a))","decl":"protected theorem DFinsupp.inner_sum {ι : Type*} [DecidableEq ι] {α : ι → Type*}\n    [∀ i, AddZeroClass (α i)] [∀ (i) (x : α i), Decidable (x ≠ 0)] (f : ∀ i, α i → E)\n    (l : Π₀ i, α i) (x : E) : ⟪x, l.sum f⟫ = l.sum fun i a => ⟪x, f i a⟫ := by\n  simp +contextual only [DFinsupp.sum, inner_sum, smul_eq_mul]\n\n"}
{"name":"inner_zero_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (Inner.inner 0 x) 0","decl":"@[simp]\ntheorem inner_zero_left (x : E) : ⟪0, x⟫ = 0 := by\n  rw [← zero_smul 𝕜 (0 : E), inner_smul_left, RingHom.map_zero, zero_mul]\n\n"}
{"name":"inner_re_zero_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (RCLike.re (Inner.inner 0 x)) 0","decl":"theorem inner_re_zero_left (x : E) : re ⟪0, x⟫ = 0 := by\n  simp only [inner_zero_left, AddMonoidHom.map_zero]\n\n"}
{"name":"inner_zero_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (Inner.inner x 0) 0","decl":"@[simp]\ntheorem inner_zero_right (x : E) : ⟪x, 0⟫ = 0 := by\n  rw [← inner_conj_symm, inner_zero_left, RingHom.map_zero]\n\n"}
{"name":"inner_re_zero_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (RCLike.re (Inner.inner x 0)) 0","decl":"theorem inner_re_zero_right (x : E) : re ⟪x, 0⟫ = 0 := by\n  simp only [inner_zero_right, AddMonoidHom.map_zero]\n\n"}
{"name":"inner_self_nonneg","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ LE.le 0 (RCLike.re (Inner.inner x x))","decl":"theorem inner_self_nonneg {x : E} : 0 ≤ re ⟪x, x⟫ :=\n  PreInnerProductSpace.toCore.nonneg_re x\n\n"}
{"name":"real_inner_self_nonneg","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx : F\n⊢ LE.le 0 (Inner.inner x x)","decl":"theorem real_inner_self_nonneg {x : F} : 0 ≤ ⟪x, x⟫_ℝ :=\n  @inner_self_nonneg ℝ F _ _ _ x\n\n"}
{"name":"inner_self_ofReal_re","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (↑(RCLike.re (Inner.inner x x))) (Inner.inner x x)","decl":"@[simp]\ntheorem inner_self_ofReal_re (x : E) : (re ⟪x, x⟫ : 𝕜) = ⟪x, x⟫ :=\n  ((RCLike.is_real_TFAE (⟪x, x⟫ : 𝕜)).out 2 3).2 (inner_self_im (𝕜 := 𝕜) x)\n\n"}
{"name":"inner_self_eq_norm_sq_to_K","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (Inner.inner x x) (HPow.hPow (↑(Norm.norm x)) 2)","decl":"theorem inner_self_eq_norm_sq_to_K (x : E) : ⟪x, x⟫ = (‖x‖ : 𝕜) ^ 2 := by\n  rw [← inner_self_ofReal_re, ← norm_sq_eq_inner, ofReal_pow]\n\n"}
{"name":"inner_self_re_eq_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (RCLike.re (Inner.inner x x)) (Norm.norm (Inner.inner x x))","decl":"theorem inner_self_re_eq_norm (x : E) : re ⟪x, x⟫ = ‖⟪x, x⟫‖ := by\n  conv_rhs => rw [← inner_self_ofReal_re]\n  symm\n  exact norm_of_nonneg inner_self_nonneg\n\n"}
{"name":"inner_self_ofReal_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (↑(Norm.norm (Inner.inner x x))) (Inner.inner x x)","decl":"theorem inner_self_ofReal_norm (x : E) : (‖⟪x, x⟫‖ : 𝕜) = ⟪x, x⟫ := by\n  rw [← inner_self_re_eq_norm]\n  exact inner_self_ofReal_re _\n\n"}
{"name":"real_inner_self_abs","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx : F\n⊢ Eq (abs (Inner.inner x x)) (Inner.inner x x)","decl":"theorem real_inner_self_abs (x : F) : |⟪x, x⟫_ℝ| = ⟪x, x⟫_ℝ :=\n  @inner_self_ofReal_norm ℝ F _ _ _ x\n\n"}
{"name":"norm_inner_symm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (Norm.norm (Inner.inner x y)) (Norm.norm (Inner.inner y x))","decl":"theorem norm_inner_symm (x y : E) : ‖⟪x, y⟫‖ = ‖⟪y, x⟫‖ := by rw [← inner_conj_symm, norm_conj]\n\n"}
{"name":"inner_neg_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (Inner.inner (Neg.neg x) y) (Neg.neg (Inner.inner x y))","decl":"@[simp]\ntheorem inner_neg_left (x y : E) : ⟪-x, y⟫ = -⟪x, y⟫ := by\n  rw [← neg_one_smul 𝕜 x, inner_smul_left]\n  simp\n\n"}
{"name":"inner_neg_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (Inner.inner x (Neg.neg y)) (Neg.neg (Inner.inner x y))","decl":"@[simp]\ntheorem inner_neg_right (x y : E) : ⟪x, -y⟫ = -⟪x, y⟫ := by\n  rw [← inner_conj_symm, inner_neg_left]; simp only [RingHom.map_neg, inner_conj_symm]\n\n"}
{"name":"inner_neg_neg","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (Inner.inner (Neg.neg x) (Neg.neg y)) (Inner.inner x y)","decl":"theorem inner_neg_neg (x y : E) : ⟪-x, -y⟫ = ⟪x, y⟫ := by simp\n\n"}
{"name":"inner_self_conj","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq ((starRingEnd 𝕜) (Inner.inner x x)) (Inner.inner x x)","decl":"theorem inner_self_conj (x : E) : ⟪x, x⟫† = ⟪x, x⟫ := inner_conj_symm _ _\n\n"}
{"name":"inner_sub_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y z : E\n⊢ Eq (Inner.inner (HSub.hSub x y) z) (HSub.hSub (Inner.inner x z) (Inner.inner y z))","decl":"theorem inner_sub_left (x y z : E) : ⟪x - y, z⟫ = ⟪x, z⟫ - ⟪y, z⟫ := by\n  simp [sub_eq_add_neg, inner_add_left]\n\n"}
{"name":"inner_sub_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y z : E\n⊢ Eq (Inner.inner x (HSub.hSub y z)) (HSub.hSub (Inner.inner x y) (Inner.inner x z))","decl":"theorem inner_sub_right (x y z : E) : ⟪x, y - z⟫ = ⟪x, y⟫ - ⟪x, z⟫ := by\n  simp [sub_eq_add_neg, inner_add_right]\n\n"}
{"name":"inner_mul_symm_re_eq_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (RCLike.re (HMul.hMul (Inner.inner x y) (Inner.inner y x))) (Norm.norm (HMul.hMul (Inner.inner x y) (Inner.inner y x)))","decl":"theorem inner_mul_symm_re_eq_norm (x y : E) : re (⟪x, y⟫ * ⟪y, x⟫) = ‖⟪x, y⟫ * ⟪y, x⟫‖ := by\n  rw [← inner_conj_symm, mul_comm]\n  exact re_eq_norm_of_mul_conj (inner y x)\n\n"}
{"name":"inner_add_add_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (Inner.inner (HAdd.hAdd x y) (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (Inner.inner x x) (Inner.inner x y)) (Inner.inner y x)) (Inner.inner y y))","decl":"/-- Expand `⟪x + y, x + y⟫` -/\ntheorem inner_add_add_self (x y : E) : ⟪x + y, x + y⟫ = ⟪x, x⟫ + ⟪x, y⟫ + ⟪y, x⟫ + ⟪y, y⟫ := by\n  simp only [inner_add_left, inner_add_right]; ring\n\n"}
{"name":"real_inner_add_add_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Eq (Inner.inner (HAdd.hAdd x y) (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (Inner.inner x x) (HMul.hMul 2 (Inner.inner x y))) (Inner.inner y y))","decl":"/-- Expand `⟪x + y, x + y⟫_ℝ` -/\ntheorem real_inner_add_add_self (x y : F) :\n    ⟪x + y, x + y⟫_ℝ = ⟪x, x⟫_ℝ + 2 * ⟪x, y⟫_ℝ + ⟪y, y⟫_ℝ := by\n  have : ⟪y, x⟫_ℝ = ⟪x, y⟫_ℝ := by rw [← inner_conj_symm]; rfl\n  simp only [inner_add_add_self, this, add_left_inj]\n  ring\n\n-- Expand `⟪x - y, x - y⟫`\n"}
{"name":"inner_sub_sub_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (Inner.inner (HSub.hSub x y) (HSub.hSub x y)) (HAdd.hAdd (HSub.hSub (HSub.hSub (Inner.inner x x) (Inner.inner x y)) (Inner.inner y x)) (Inner.inner y y))","decl":"theorem inner_sub_sub_self (x y : E) : ⟪x - y, x - y⟫ = ⟪x, x⟫ - ⟪x, y⟫ - ⟪y, x⟫ + ⟪y, y⟫ := by\n  simp only [inner_sub_left, inner_sub_right]; ring\n\n"}
{"name":"real_inner_sub_sub_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Eq (Inner.inner (HSub.hSub x y) (HSub.hSub x y)) (HAdd.hAdd (HSub.hSub (Inner.inner x x) (HMul.hMul 2 (Inner.inner x y))) (Inner.inner y y))","decl":"/-- Expand `⟪x - y, x - y⟫_ℝ` -/\ntheorem real_inner_sub_sub_self (x y : F) :\n    ⟪x - y, x - y⟫_ℝ = ⟪x, x⟫_ℝ - 2 * ⟪x, y⟫_ℝ + ⟪y, y⟫_ℝ := by\n  have : ⟪y, x⟫_ℝ = ⟪x, y⟫_ℝ := by rw [← inner_conj_symm]; rfl\n  simp only [inner_sub_sub_self, this, add_left_inj]\n  ring\n\n"}
{"name":"parallelogram_law","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (HAdd.hAdd (Inner.inner (HAdd.hAdd x y) (HAdd.hAdd x y)) (Inner.inner (HSub.hSub x y) (HSub.hSub x y))) (HMul.hMul 2 (HAdd.hAdd (Inner.inner x x) (Inner.inner y y)))","decl":"/-- Parallelogram law -/\ntheorem parallelogram_law {x y : E} : ⟪x + y, x + y⟫ + ⟪x - y, x - y⟫ = 2 * (⟪x, x⟫ + ⟪y, y⟫) := by\n  simp only [inner_add_add_self, inner_sub_sub_self]\n  ring\n\n"}
{"name":"inner_mul_inner_self_le","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ LE.le (HMul.hMul (Norm.norm (Inner.inner x y)) (Norm.norm (Inner.inner y x))) (HMul.hMul (RCLike.re (Inner.inner x x)) (RCLike.re (Inner.inner y y)))","decl":"/-- **Cauchy–Schwarz inequality**. -/\ntheorem inner_mul_inner_self_le (x y : E) : ‖⟪x, y⟫‖ * ‖⟪y, x⟫‖ ≤ re ⟪x, x⟫ * re ⟪y, y⟫ :=\n  letI cd : PreInnerProductSpace.Core 𝕜 E := PreInnerProductSpace.toCore\n  InnerProductSpace.Core.inner_mul_inner_self_le x y\n\n"}
{"name":"real_inner_mul_inner_self_le","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ LE.le (HMul.hMul (Inner.inner x y) (Inner.inner x y)) (HMul.hMul (Inner.inner x x) (Inner.inner y y))","decl":"/-- Cauchy–Schwarz inequality for real inner products. -/\ntheorem real_inner_mul_inner_self_le (x y : F) : ⟪x, y⟫_ℝ * ⟪x, y⟫_ℝ ≤ ⟪x, x⟫_ℝ * ⟪y, y⟫_ℝ :=\n  calc\n    ⟪x, y⟫_ℝ * ⟪x, y⟫_ℝ ≤ ‖⟪x, y⟫_ℝ‖ * ‖⟪y, x⟫_ℝ‖ := by\n      rw [real_inner_comm y, ← norm_mul]\n      exact le_abs_self _\n    _ ≤ ⟪x, x⟫_ℝ * ⟪y, y⟫_ℝ := @inner_mul_inner_self_le ℝ _ _ _ _ x y\n\n"}
{"name":"inner_self_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Iff (Eq (Inner.inner x x) 0) (Eq x 0)","decl":"@[simp]\ntheorem inner_self_eq_zero {x : E} : ⟪x, x⟫ = 0 ↔ x = 0 := by\n  rw [inner_self_eq_norm_sq_to_K, sq_eq_zero_iff, ofReal_eq_zero, norm_eq_zero]\n\n"}
{"name":"inner_self_ne_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Iff (Ne (Inner.inner x x) 0) (Ne x 0)","decl":"theorem inner_self_ne_zero {x : E} : ⟪x, x⟫ ≠ 0 ↔ x ≠ 0 :=\n  inner_self_eq_zero.not\n\n"}
{"name":"ext_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\nh : ∀ (v : E), Eq (Inner.inner v x) (Inner.inner v y)\n⊢ Eq x y","decl":"theorem ext_inner_left {x y : E} (h : ∀ v, ⟪v, x⟫ = ⟪v, y⟫) : x = y := by\n  rw [← sub_eq_zero, ← @inner_self_eq_zero 𝕜, inner_sub_right, sub_eq_zero, h (x - y)]\n\n"}
{"name":"ext_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\nh : ∀ (v : E), Eq (Inner.inner x v) (Inner.inner y v)\n⊢ Eq x y","decl":"theorem ext_inner_right {x y : E} (h : ∀ v, ⟪x, v⟫ = ⟪y, v⟫) : x = y := by\n  rw [← sub_eq_zero, ← @inner_self_eq_zero 𝕜, inner_sub_left, sub_eq_zero, h (x - y)]\n\n"}
{"name":"inner_self_nonpos","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Iff (LE.le (RCLike.re (Inner.inner x x)) 0) (Eq x 0)","decl":"@[simp]\ntheorem inner_self_nonpos {x : E} : re ⟪x, x⟫ ≤ 0 ↔ x = 0 := by\n  rw [← norm_sq_eq_inner, (sq_nonneg _).le_iff_eq, sq_eq_zero_iff, norm_eq_zero]\n\n"}
{"name":"real_inner_self_nonpos","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx : F\n⊢ Iff (LE.le (Inner.inner x x) 0) (Eq x 0)","decl":"open scoped InnerProductSpace in\ntheorem real_inner_self_nonpos {x : F} : ⟪x, x⟫_ℝ ≤ 0 ↔ x = 0 :=\n  @inner_self_nonpos ℝ F _ _ _ x\n\n"}
{"name":"linearIndependent_of_ne_zero_of_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nι : Type u_4\nv : ι → E\nhz : ∀ (i : ι), Ne (v i) 0\nho : Pairwise fun i j => Eq (Inner.inner (v i) (v j)) 0\n⊢ LinearIndependent 𝕜 v","decl":"/-- A family of vectors is linearly independent if they are nonzero\nand orthogonal. -/\ntheorem linearIndependent_of_ne_zero_of_inner_eq_zero {ι : Type*} {v : ι → E} (hz : ∀ i, v i ≠ 0)\n    (ho : Pairwise fun i j => ⟪v i, v j⟫ = 0) : LinearIndependent 𝕜 v := by\n  rw [linearIndependent_iff']\n  intro s g hg i hi\n  have h' : g i * inner (v i) (v i) = inner (v i) (∑ j ∈ s, g j • v j) := by\n    rw [inner_sum]\n    symm\n    convert Finset.sum_eq_single (β := 𝕜) i ?_ ?_\n    · rw [inner_smul_right]\n    · intro j _hj hji\n      rw [inner_smul_right, ho hji.symm, mul_zero]\n    · exact fun h => False.elim (h hi)\n  simpa [hg, hz] using h'\n\n"}
{"name":"norm_eq_sqrt_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (Norm.norm x) (RCLike.re (Inner.inner x x)).sqrt","decl":"theorem norm_eq_sqrt_inner (x : E) : ‖x‖ = √(re ⟪x, x⟫) :=\n  calc\n    ‖x‖ = √(‖x‖ ^ 2) := (sqrt_sq (norm_nonneg _)).symm\n    _ = √(re ⟪x, x⟫) := congr_arg _ (norm_sq_eq_inner _)\n\n"}
{"name":"norm_eq_sqrt_real_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx : F\n⊢ Eq (Norm.norm x) (Inner.inner x x).sqrt","decl":"theorem norm_eq_sqrt_real_inner (x : F) : ‖x‖ = √⟪x, x⟫_ℝ :=\n  @norm_eq_sqrt_inner ℝ _ _ _ _ x\n\n"}
{"name":"inner_self_eq_norm_mul_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (RCLike.re (Inner.inner x x)) (HMul.hMul (Norm.norm x) (Norm.norm x))","decl":"theorem inner_self_eq_norm_mul_norm (x : E) : re ⟪x, x⟫ = ‖x‖ * ‖x‖ := by\n  rw [@norm_eq_sqrt_inner 𝕜, ← sqrt_mul inner_self_nonneg (re ⟪x, x⟫),\n    sqrt_mul_self inner_self_nonneg]\n\n"}
{"name":"inner_self_eq_norm_sq","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (RCLike.re (Inner.inner x x)) (HPow.hPow (Norm.norm x) 2)","decl":"theorem inner_self_eq_norm_sq (x : E) : re ⟪x, x⟫ = ‖x‖ ^ 2 := by\n  rw [pow_two, inner_self_eq_norm_mul_norm]\n\n"}
{"name":"real_inner_self_eq_norm_mul_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx : F\n⊢ Eq (Inner.inner x x) (HMul.hMul (Norm.norm x) (Norm.norm x))","decl":"theorem real_inner_self_eq_norm_mul_norm (x : F) : ⟪x, x⟫_ℝ = ‖x‖ * ‖x‖ := by\n  have h := @inner_self_eq_norm_mul_norm ℝ F _ _ _ x\n  simpa using h\n\n"}
{"name":"real_inner_self_eq_norm_sq","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx : F\n⊢ Eq (Inner.inner x x) (HPow.hPow (Norm.norm x) 2)","decl":"theorem real_inner_self_eq_norm_sq (x : F) : ⟪x, x⟫_ℝ = ‖x‖ ^ 2 := by\n  rw [pow_two, real_inner_self_eq_norm_mul_norm]\n\n-- Porting note: this was present in mathlib3 but seemingly didn't do anything.\n-- variable (𝕜)\n\n"}
{"name":"norm_add_sq","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (HPow.hPow (Norm.norm (HAdd.hAdd x y)) 2) (HAdd.hAdd (HAdd.hAdd (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (RCLike.re (Inner.inner x y)))) (HPow.hPow (Norm.norm y) 2))","decl":"/-- Expand the square -/\ntheorem norm_add_sq (x y : E) : ‖x + y‖ ^ 2 = ‖x‖ ^ 2 + 2 * re ⟪x, y⟫ + ‖y‖ ^ 2 := by\n  repeat' rw [sq (M := ℝ), ← @inner_self_eq_norm_mul_norm 𝕜]\n  rw [inner_add_add_self, two_mul]\n  simp only [add_assoc, add_left_inj, add_right_inj, AddMonoidHom.map_add]\n  rw [← inner_conj_symm, conj_re]\n\n"}
{"name":"norm_add_pow_two","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (HPow.hPow (Norm.norm (HAdd.hAdd x y)) 2) (HAdd.hAdd (HAdd.hAdd (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (RCLike.re (Inner.inner x y)))) (HPow.hPow (Norm.norm y) 2))","decl":"alias norm_add_pow_two := norm_add_sq\n\n"}
{"name":"norm_add_sq_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Eq (HPow.hPow (Norm.norm (HAdd.hAdd x y)) 2) (HAdd.hAdd (HAdd.hAdd (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (Inner.inner x y))) (HPow.hPow (Norm.norm y) 2))","decl":"/-- Expand the square -/\ntheorem norm_add_sq_real (x y : F) : ‖x + y‖ ^ 2 = ‖x‖ ^ 2 + 2 * ⟪x, y⟫_ℝ + ‖y‖ ^ 2 := by\n  have h := @norm_add_sq ℝ _ _ _ _ x y\n  simpa using h\n\n"}
{"name":"norm_add_pow_two_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Eq (HPow.hPow (Norm.norm (HAdd.hAdd x y)) 2) (HAdd.hAdd (HAdd.hAdd (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (Inner.inner x y))) (HPow.hPow (Norm.norm y) 2))","decl":"alias norm_add_pow_two_real := norm_add_sq_real\n\n"}
{"name":"norm_add_mul_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul 2 (RCLike.re (Inner.inner x y)))) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Expand the square -/\ntheorem norm_add_mul_self (x y : E) :\n    ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + 2 * re ⟪x, y⟫ + ‖y‖ * ‖y‖ := by\n  repeat' rw [← sq (M := ℝ)]\n  exact norm_add_sq _ _\n\n"}
{"name":"norm_add_mul_self_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Eq (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul 2 (Inner.inner x y))) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Expand the square -/\ntheorem norm_add_mul_self_real (x y : F) :\n    ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + 2 * ⟪x, y⟫_ℝ + ‖y‖ * ‖y‖ := by\n  have h := @norm_add_mul_self ℝ _ _ _ _ x y\n  simpa using h\n\n"}
{"name":"norm_sub_sq","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (HPow.hPow (Norm.norm (HSub.hSub x y)) 2) (HAdd.hAdd (HSub.hSub (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (RCLike.re (Inner.inner x y)))) (HPow.hPow (Norm.norm y) 2))","decl":"/-- Expand the square -/\ntheorem norm_sub_sq (x y : E) : ‖x - y‖ ^ 2 = ‖x‖ ^ 2 - 2 * re ⟪x, y⟫ + ‖y‖ ^ 2 := by\n  rw [sub_eq_add_neg, @norm_add_sq 𝕜 _ _ _ _ x (-y), norm_neg, inner_neg_right, map_neg, mul_neg,\n    sub_eq_add_neg]\n\n"}
{"name":"norm_sub_pow_two","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (HPow.hPow (Norm.norm (HSub.hSub x y)) 2) (HAdd.hAdd (HSub.hSub (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (RCLike.re (Inner.inner x y)))) (HPow.hPow (Norm.norm y) 2))","decl":"alias norm_sub_pow_two := norm_sub_sq\n\n"}
{"name":"norm_sub_sq_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Eq (HPow.hPow (Norm.norm (HSub.hSub x y)) 2) (HAdd.hAdd (HSub.hSub (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (Inner.inner x y))) (HPow.hPow (Norm.norm y) 2))","decl":"/-- Expand the square -/\ntheorem norm_sub_sq_real (x y : F) : ‖x - y‖ ^ 2 = ‖x‖ ^ 2 - 2 * ⟪x, y⟫_ℝ + ‖y‖ ^ 2 :=\n  @norm_sub_sq ℝ _ _ _ _ _ _\n\n"}
{"name":"norm_sub_pow_two_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Eq (HPow.hPow (Norm.norm (HSub.hSub x y)) 2) (HAdd.hAdd (HSub.hSub (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (Inner.inner x y))) (HPow.hPow (Norm.norm y) 2))","decl":"alias norm_sub_pow_two_real := norm_sub_sq_real\n\n"}
{"name":"norm_sub_mul_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y))) (HAdd.hAdd (HSub.hSub (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul 2 (RCLike.re (Inner.inner x y)))) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Expand the square -/\ntheorem norm_sub_mul_self (x y : E) :\n    ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ - 2 * re ⟪x, y⟫ + ‖y‖ * ‖y‖ := by\n  repeat' rw [← sq (M := ℝ)]\n  exact norm_sub_sq _ _\n\n"}
{"name":"norm_sub_mul_self_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Eq (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y))) (HAdd.hAdd (HSub.hSub (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul 2 (Inner.inner x y))) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Expand the square -/\ntheorem norm_sub_mul_self_real (x y : F) :\n    ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ - 2 * ⟪x, y⟫_ℝ + ‖y‖ * ‖y‖ := by\n  have h := @norm_sub_mul_self ℝ _ _ _ _ x y\n  simpa using h\n\n"}
{"name":"norm_inner_le_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ LE.le (Norm.norm (Inner.inner x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"/-- Cauchy–Schwarz inequality with norm -/\ntheorem norm_inner_le_norm (x y : E) : ‖⟪x, y⟫‖ ≤ ‖x‖ * ‖y‖ := by\n  rw [norm_eq_sqrt_inner (𝕜 := 𝕜) x, norm_eq_sqrt_inner (𝕜 := 𝕜) y]\n  letI : PreInnerProductSpace.Core 𝕜 E := PreInnerProductSpace.toCore\n  exact InnerProductSpace.Core.norm_inner_le_norm x y\n\n"}
{"name":"nnnorm_inner_le_nnnorm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ LE.le (NNNorm.nnnorm (Inner.inner x y)) (HMul.hMul (NNNorm.nnnorm x) (NNNorm.nnnorm y))","decl":"theorem nnnorm_inner_le_nnnorm (x y : E) : ‖⟪x, y⟫‖₊ ≤ ‖x‖₊ * ‖y‖₊ :=\n  norm_inner_le_norm x y\n\n"}
{"name":"re_inner_le_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ LE.le (RCLike.re (Inner.inner x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"theorem re_inner_le_norm (x y : E) : re ⟪x, y⟫ ≤ ‖x‖ * ‖y‖ :=\n  le_trans (re_le_norm (inner x y)) (norm_inner_le_norm x y)\n\n"}
{"name":"abs_real_inner_le_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ LE.le (abs (Inner.inner x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"/-- Cauchy–Schwarz inequality with norm -/\ntheorem abs_real_inner_le_norm (x y : F) : |⟪x, y⟫_ℝ| ≤ ‖x‖ * ‖y‖ :=\n  (Real.norm_eq_abs _).ge.trans (norm_inner_le_norm x y)\n\n"}
{"name":"real_inner_le_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ LE.le (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"/-- Cauchy–Schwarz inequality with norm -/\ntheorem real_inner_le_norm (x y : F) : ⟪x, y⟫_ℝ ≤ ‖x‖ * ‖y‖ :=\n  le_trans (le_abs_self _) (abs_real_inner_le_norm _ _)\n\n"}
{"name":"inner_eq_zero_of_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\nh : Eq (Norm.norm x) 0\n⊢ Eq (Inner.inner x y) 0","decl":"lemma inner_eq_zero_of_left {x : E} (y : E) (h : ‖x‖ = 0) : ⟪x, y⟫_𝕜 = 0 := by\n  rw [← norm_eq_zero]\n  refine le_antisymm ?_ (by positivity)\n  exact norm_inner_le_norm _ _ |>.trans <| by simp [h]\n\n"}
{"name":"inner_eq_zero_of_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\nh : Eq (Norm.norm y) 0\n⊢ Eq (Inner.inner x y) 0","decl":"lemma inner_eq_zero_of_right (x : E) {y : E} (h : ‖y‖ = 0) : ⟪x, y⟫_𝕜 = 0 := by\n  rw [inner_eq_zero_symm, inner_eq_zero_of_left _ h]\n\n"}
{"name":"parallelogram_law_with_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (HAdd.hAdd (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y)))) (HMul.hMul 2 (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y))))","decl":"include 𝕜 in\ntheorem parallelogram_law_with_norm (x y : E) :\n    ‖x + y‖ * ‖x + y‖ + ‖x - y‖ * ‖x - y‖ = 2 * (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) := by\n  simp only [← @inner_self_eq_norm_mul_norm 𝕜]\n  rw [← re.map_add, parallelogram_law, two_mul, two_mul]\n  simp only [re.map_add]\n\n"}
{"name":"parallelogram_law_with_nnnorm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (HAdd.hAdd (HMul.hMul (NNNorm.nnnorm (HAdd.hAdd x y)) (NNNorm.nnnorm (HAdd.hAdd x y))) (HMul.hMul (NNNorm.nnnorm (HSub.hSub x y)) (NNNorm.nnnorm (HSub.hSub x y)))) (HMul.hMul 2 (HAdd.hAdd (HMul.hMul (NNNorm.nnnorm x) (NNNorm.nnnorm x)) (HMul.hMul (NNNorm.nnnorm y) (NNNorm.nnnorm y))))","decl":"include 𝕜 in\ntheorem parallelogram_law_with_nnnorm (x y : E) :\n    ‖x + y‖₊ * ‖x + y‖₊ + ‖x - y‖₊ * ‖x - y‖₊ = 2 * (‖x‖₊ * ‖x‖₊ + ‖y‖₊ * ‖y‖₊) :=\n  Subtype.ext <| parallelogram_law_with_norm 𝕜 x y\n\n"}
{"name":"re_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (RCLike.re (Inner.inner x y)) (HDiv.hDiv (HSub.hSub (HSub.hSub (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HMul.hMul (Norm.norm x) (Norm.norm x))) (HMul.hMul (Norm.norm y) (Norm.norm y))) 2)","decl":"/-- Polarization identity: The real part of the inner product, in terms of the norm. -/\ntheorem re_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two (x y : E) :\n    re ⟪x, y⟫ = (‖x + y‖ * ‖x + y‖ - ‖x‖ * ‖x‖ - ‖y‖ * ‖y‖) / 2 := by\n  rw [@norm_add_mul_self 𝕜]\n  ring\n\n"}
{"name":"re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (RCLike.re (Inner.inner x y)) (HDiv.hDiv (HSub.hSub (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y))) (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y)))) 2)","decl":"/-- Polarization identity: The real part of the inner product, in terms of the norm. -/\ntheorem re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two (x y : E) :\n    re ⟪x, y⟫ = (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ - ‖x - y‖ * ‖x - y‖) / 2 := by\n  rw [@norm_sub_mul_self 𝕜]\n  ring\n\n"}
{"name":"re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (RCLike.re (Inner.inner x y)) (HDiv.hDiv (HSub.hSub (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y)))) 4)","decl":"/-- Polarization identity: The real part of the inner product, in terms of the norm. -/\ntheorem re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four (x y : E) :\n    re ⟪x, y⟫ = (‖x + y‖ * ‖x + y‖ - ‖x - y‖ * ‖x - y‖) / 4 := by\n  rw [@norm_add_mul_self 𝕜, @norm_sub_mul_self 𝕜]\n  ring\n\n"}
{"name":"im_inner_eq_norm_sub_i_smul_mul_self_sub_norm_add_i_smul_mul_self_div_four","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (RCLike.im (Inner.inner x y)) (HDiv.hDiv (HSub.hSub (HMul.hMul (Norm.norm (HSub.hSub x (HSMul.hSMul RCLike.I y))) (Norm.norm (HSub.hSub x (HSMul.hSMul RCLike.I y)))) (HMul.hMul (Norm.norm (HAdd.hAdd x (HSMul.hSMul RCLike.I y))) (Norm.norm (HAdd.hAdd x (HSMul.hSMul RCLike.I y))))) 4)","decl":"/-- Polarization identity: The imaginary part of the inner product, in terms of the norm. -/\ntheorem im_inner_eq_norm_sub_i_smul_mul_self_sub_norm_add_i_smul_mul_self_div_four (x y : E) :\n    im ⟪x, y⟫ = (‖x - IK • y‖ * ‖x - IK • y‖ - ‖x + IK • y‖ * ‖x + IK • y‖) / 4 := by\n  simp only [@norm_add_mul_self 𝕜, @norm_sub_mul_self 𝕜, inner_smul_right, I_mul_re]\n  ring\n\n"}
{"name":"inner_eq_sum_norm_sq_div_four","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (Inner.inner x y) (HDiv.hDiv (HAdd.hAdd (HSub.hSub (HPow.hPow (↑(Norm.norm (HAdd.hAdd x y))) 2) (HPow.hPow (↑(Norm.norm (HSub.hSub x y))) 2)) (HMul.hMul (HSub.hSub (HPow.hPow (↑(Norm.norm (HSub.hSub x (HSMul.hSMul RCLike.I y)))) 2) (HPow.hPow (↑(Norm.norm (HAdd.hAdd x (HSMul.hSMul RCLike.I y)))) 2)) RCLike.I)) 4)","decl":"/-- Polarization identity: The inner product, in terms of the norm. -/\ntheorem inner_eq_sum_norm_sq_div_four (x y : E) :\n    ⟪x, y⟫ = ((‖x + y‖ : 𝕜) ^ 2 - (‖x - y‖ : 𝕜) ^ 2 +\n              ((‖x - IK • y‖ : 𝕜) ^ 2 - (‖x + IK • y‖ : 𝕜) ^ 2) * IK) / 4 := by\n  rw [← re_add_im ⟪x, y⟫, re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four,\n    im_inner_eq_norm_sub_i_smul_mul_self_sub_norm_add_i_smul_mul_self_div_four]\n  push_cast\n  simp only [sq, ← mul_div_right_comm, ← add_div]\n\n-- See note [lower instance priority]\n"}
{"name":"InnerProductSpace.toUniformConvexSpace","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝ : SeminormedAddCommGroup F\n⊢ UniformConvexSpace F","decl":"instance (priority := 100) InnerProductSpace.toUniformConvexSpace : UniformConvexSpace F :=\n  ⟨fun ε hε => by\n    refine\n      ⟨2 - √(4 - ε ^ 2), sub_pos_of_lt <| (sqrt_lt' zero_lt_two).2 ?_, fun x hx y hy hxy => ?_⟩\n    · norm_num\n      exact pow_pos hε _\n    rw [sub_sub_cancel]\n    refine le_sqrt_of_sq_le ?_\n    rw [sq, eq_sub_iff_add_eq.2 (parallelogram_law_with_norm ℝ x y), ← sq ‖x - y‖, hx, hy]\n    ring_nf\n    gcongr⟩\n\n"}
{"name":"real_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Eq (Inner.inner x y) (HDiv.hDiv (HSub.hSub (HSub.hSub (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HMul.hMul (Norm.norm x) (Norm.norm x))) (HMul.hMul (Norm.norm y) (Norm.norm y))) 2)","decl":"/-- Polarization identity: The real inner product, in terms of the norm. -/\ntheorem real_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two (x y : F) :\n    ⟪x, y⟫_ℝ = (‖x + y‖ * ‖x + y‖ - ‖x‖ * ‖x‖ - ‖y‖ * ‖y‖) / 2 :=\n  re_to_real.symm.trans <|\n    re_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two x y\n\n"}
{"name":"real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Eq (Inner.inner x y) (HDiv.hDiv (HSub.hSub (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y))) (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y)))) 2)","decl":"/-- Polarization identity: The real inner product, in terms of the norm. -/\ntheorem real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two (x y : F) :\n    ⟪x, y⟫_ℝ = (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ - ‖x - y‖ * ‖x - y‖) / 2 :=\n  re_to_real.symm.trans <|\n    re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two x y\n\n"}
{"name":"norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Iff (Eq (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y)))) (Eq (Inner.inner x y) 0)","decl":"/-- Pythagorean theorem, if-and-only-if vector inner product form. -/\ntheorem norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero (x y : F) :\n    ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ ⟪x, y⟫_ℝ = 0 := by\n  rw [@norm_add_mul_self ℝ, add_right_cancel_iff, add_right_eq_self, mul_eq_zero]\n  norm_num\n\n"}
{"name":"norm_add_eq_sqrt_iff_real_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Iff (Eq (Norm.norm (HAdd.hAdd x y)) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y))).sqrt) (Eq (Inner.inner x y) 0)","decl":"/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem norm_add_eq_sqrt_iff_real_inner_eq_zero {x y : F} :\n    ‖x + y‖ = √(‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ ⟪x, y⟫_ℝ = 0 := by\n  rw [← norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero, eq_comm, sqrt_eq_iff_mul_self_eq,\n    eq_comm] <;> positivity\n\n"}
{"name":"norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\nh : Eq (Inner.inner x y) 0\n⊢ Eq (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Pythagorean theorem, vector inner product form. -/\ntheorem norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero (x y : E) (h : ⟪x, y⟫ = 0) :\n    ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ := by\n  rw [@norm_add_mul_self 𝕜, add_right_cancel_iff, add_right_eq_self, mul_eq_zero]\n  apply Or.inr\n  simp only [h, zero_re']\n\n"}
{"name":"norm_add_sq_eq_norm_sq_add_norm_sq_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\nh : Eq (Inner.inner x y) 0\n⊢ Eq (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Pythagorean theorem, vector inner product form. -/\ntheorem norm_add_sq_eq_norm_sq_add_norm_sq_real {x y : F} (h : ⟪x, y⟫_ℝ = 0) :\n    ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ :=\n  (norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero x y).2 h\n\n"}
{"name":"norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Iff (Eq (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y))) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y)))) (Eq (Inner.inner x y) 0)","decl":"/-- Pythagorean theorem, subtracting vectors, if-and-only-if vector\ninner product form. -/\ntheorem norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero (x y : F) :\n    ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ ⟪x, y⟫_ℝ = 0 := by\n  rw [@norm_sub_mul_self ℝ, add_right_cancel_iff, sub_eq_add_neg, add_right_eq_self, neg_eq_zero,\n    mul_eq_zero]\n  norm_num\n\n"}
{"name":"norm_sub_eq_sqrt_iff_real_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Iff (Eq (Norm.norm (HSub.hSub x y)) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y))).sqrt) (Eq (Inner.inner x y) 0)","decl":"/-- Pythagorean theorem, subtracting vectors, if-and-if vector inner product form using square\nroots. -/\ntheorem norm_sub_eq_sqrt_iff_real_inner_eq_zero {x y : F} :\n    ‖x - y‖ = √(‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ ⟪x, y⟫_ℝ = 0 := by\n  rw [← norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero, eq_comm, sqrt_eq_iff_mul_self_eq,\n    eq_comm] <;> positivity\n\n"}
{"name":"norm_sub_sq_eq_norm_sq_add_norm_sq_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\nh : Eq (Inner.inner x y) 0\n⊢ Eq (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y))) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Pythagorean theorem, subtracting vectors, vector inner product\nform. -/\ntheorem norm_sub_sq_eq_norm_sq_add_norm_sq_real {x y : F} (h : ⟪x, y⟫_ℝ = 0) :\n    ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ :=\n  (norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero x y).2 h\n\n"}
{"name":"real_inner_add_sub_eq_zero_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Iff (Eq (Inner.inner (HAdd.hAdd x y) (HSub.hSub x y)) 0) (Eq (Norm.norm x) (Norm.norm y))","decl":"/-- The sum and difference of two vectors are orthogonal if and only\nif they have the same norm. -/\ntheorem real_inner_add_sub_eq_zero_iff (x y : F) : ⟪x + y, x - y⟫_ℝ = 0 ↔ ‖x‖ = ‖y‖ := by\n  conv_rhs => rw [← mul_self_inj_of_nonneg (norm_nonneg _) (norm_nonneg _)]\n  simp only [← @inner_self_eq_norm_mul_norm ℝ, inner_add_left, inner_sub_right, real_inner_comm y x,\n    sub_eq_zero, re_to_real]\n  constructor\n  · intro h\n    rw [add_comm] at h\n    linarith\n  · intro h\n    linarith\n\n"}
{"name":"norm_sub_eq_norm_add","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nv w : E\nh : Eq (Inner.inner v w) 0\n⊢ Eq (Norm.norm (HSub.hSub w v)) (Norm.norm (HAdd.hAdd w v))","decl":"/-- Given two orthogonal vectors, their sum and difference have equal norms. -/\ntheorem norm_sub_eq_norm_add {v w : E} (h : ⟪v, w⟫ = 0) : ‖w - v‖ = ‖w + v‖ := by\n  rw [← mul_self_inj_of_nonneg (norm_nonneg _) (norm_nonneg _)]\n  simp only [h, ← @inner_self_eq_norm_mul_norm 𝕜, sub_neg_eq_add, sub_zero, map_sub, zero_re',\n    zero_sub, add_zero, map_add, inner_add_right, inner_sub_left, inner_sub_right, inner_re_symm,\n    zero_add]\n\n"}
{"name":"abs_real_inner_div_norm_mul_norm_le_one","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ LE.le (abs (HDiv.hDiv (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y)))) 1","decl":"/-- The real inner product of two vectors, divided by the product of their\nnorms, has absolute value at most 1. -/\ntheorem abs_real_inner_div_norm_mul_norm_le_one (x y : F) : |⟪x, y⟫_ℝ / (‖x‖ * ‖y‖)| ≤ 1 := by\n  rw [abs_div, abs_mul, abs_norm, abs_norm]\n  exact div_le_one_of_le₀ (abs_real_inner_le_norm x y) (by positivity)\n\n"}
{"name":"real_inner_smul_self_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx : F\nr : Real\n⊢ Eq (Inner.inner (HSMul.hSMul r x) x) (HMul.hMul r (HMul.hMul (Norm.norm x) (Norm.norm x)))","decl":"/-- The inner product of a vector with a multiple of itself. -/\ntheorem real_inner_smul_self_left (x : F) (r : ℝ) : ⟪r • x, x⟫_ℝ = r * (‖x‖ * ‖x‖) := by\n  rw [real_inner_smul_left, ← real_inner_self_eq_norm_mul_norm]\n\n"}
{"name":"real_inner_smul_self_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx : F\nr : Real\n⊢ Eq (Inner.inner x (HSMul.hSMul r x)) (HMul.hMul r (HMul.hMul (Norm.norm x) (Norm.norm x)))","decl":"/-- The inner product of a vector with a multiple of itself. -/\ntheorem real_inner_smul_self_right (x : F) (r : ℝ) : ⟪x, r • x⟫_ℝ = r * (‖x‖ * ‖x‖) := by\n  rw [inner_smul_right, ← real_inner_self_eq_norm_mul_norm]\n\n"}
{"name":"isBoundedBilinearMap_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : NormedSpace Real E\ninst✝ : IsScalarTower Real 𝕜 E\n⊢ IsBoundedBilinearMap Real fun p => Inner.inner p.1 p.2","decl":"/-- When an inner product space `E` over `𝕜` is considered as a real normed space, its inner\nproduct satisfies `IsBoundedBilinearMap`.\n\nIn order to state these results, we need a `NormedSpace ℝ E` instance. We will later establish\nsuch an instance by restriction-of-scalars, `InnerProductSpace.rclikeToReal 𝕜 E`, but this\ninstance may be not definitionally equal to some other “natural” instance. So, we assume\n`[NormedSpace ℝ E]`.\n-/\ntheorem _root_.isBoundedBilinearMap_inner [NormedSpace ℝ E] [IsScalarTower ℝ 𝕜 E] :\n    IsBoundedBilinearMap ℝ fun p : E × E => ⟪p.1, p.2⟫ :=\n  { add_left := inner_add_left\n    smul_left := fun r x y => by\n      simp only [← algebraMap_smul 𝕜 r x, algebraMap_eq_ofReal, inner_smul_real_left]\n    add_right := inner_add_right\n    smul_right := fun r x y => by\n      simp only [← algebraMap_smul 𝕜 r y, algebraMap_eq_ofReal, inner_smul_real_right]\n    bound :=\n      ⟨1, zero_lt_one, fun x y => by\n        rw [one_mul]\n        exact norm_inner_le_norm x y⟩ }\n\n"}
{"name":"inner_sum_smul_sum_smul_of_sum_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nι₁ : Type u_4\ns₁ : Finset ι₁\nw₁ : ι₁ → Real\nv₁ : ι₁ → F\nh₁ : Eq (s₁.sum fun i => w₁ i) 0\nι₂ : Type u_5\ns₂ : Finset ι₂\nw₂ : ι₂ → Real\nv₂ : ι₂ → F\nh₂ : Eq (s₂.sum fun i => w₂ i) 0\n⊢ Eq (Inner.inner (s₁.sum fun i₁ => HSMul.hSMul (w₁ i₁) (v₁ i₁)) (s₂.sum fun i₂ => HSMul.hSMul (w₂ i₂) (v₂ i₂))) (HDiv.hDiv (Neg.neg (s₁.sum fun i₁ => s₂.sum fun i₂ => HMul.hMul (HMul.hMul (w₁ i₁) (w₂ i₂)) (HMul.hMul (Norm.norm (HSub.hSub (v₁ i₁) (v₂ i₂))) (Norm.norm (HSub.hSub (v₁ i₁) (v₂ i₂)))))) 2)","decl":"/-- The inner product of two weighted sums, where the weights in each\nsum add to 0, in terms of the norms of pairwise differences. -/\ntheorem inner_sum_smul_sum_smul_of_sum_eq_zero {ι₁ : Type*} {s₁ : Finset ι₁} {w₁ : ι₁ → ℝ}\n    (v₁ : ι₁ → F) (h₁ : ∑ i ∈ s₁, w₁ i = 0) {ι₂ : Type*} {s₂ : Finset ι₂} {w₂ : ι₂ → ℝ}\n    (v₂ : ι₂ → F) (h₂ : ∑ i ∈ s₂, w₂ i = 0) :\n    ⟪∑ i₁ ∈ s₁, w₁ i₁ • v₁ i₁, ∑ i₂ ∈ s₂, w₂ i₂ • v₂ i₂⟫_ℝ =\n      (-∑ i₁ ∈ s₁, ∑ i₂ ∈ s₂, w₁ i₁ * w₂ i₂ * (‖v₁ i₁ - v₂ i₂‖ * ‖v₁ i₁ - v₂ i₂‖)) / 2 := by\n  simp_rw [sum_inner, inner_sum, real_inner_smul_left, real_inner_smul_right,\n    real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two, ← div_sub_div_same,\n    ← div_add_div_same, mul_sub_left_distrib, left_distrib, Finset.sum_sub_distrib,\n    Finset.sum_add_distrib, ← Finset.mul_sum, ← Finset.sum_mul, h₁, h₂, zero_mul,\n    mul_zero, Finset.sum_const_zero, zero_add, zero_sub, Finset.mul_sum, neg_div,\n    Finset.sum_div, mul_div_assoc, mul_assoc]\n\n"}
{"name":"dist_div_norm_sq_smul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\nhx : Ne x 0\nhy : Ne y 0\nR : Real\n⊢ Eq (Dist.dist (HSMul.hSMul (HPow.hPow (HDiv.hDiv R (Norm.norm x)) 2) x) (HSMul.hSMul (HPow.hPow (HDiv.hDiv R (Norm.norm y)) 2) y)) (HMul.hMul (HDiv.hDiv (HPow.hPow R 2) (HMul.hMul (Norm.norm x) (Norm.norm y))) (Dist.dist x y))","decl":"/-- Formula for the distance between the images of two nonzero points under an inversion with center\nzero. See also `EuclideanGeometry.dist_inversion_inversion` for inversions around a general\npoint. -/\ntheorem dist_div_norm_sq_smul {x y : F} (hx : x ≠ 0) (hy : y ≠ 0) (R : ℝ) :\n    dist ((R / ‖x‖) ^ 2 • x) ((R / ‖y‖) ^ 2 • y) = R ^ 2 / (‖x‖ * ‖y‖) * dist x y :=\n  calc\n    dist ((R / ‖x‖) ^ 2 • x) ((R / ‖y‖) ^ 2 • y) =\n        √(‖(R / ‖x‖) ^ 2 • x - (R / ‖y‖) ^ 2 • y‖ ^ 2) := by\n      rw [dist_eq_norm, sqrt_sq (norm_nonneg _)]\n    _ = √((R ^ 2 / (‖x‖ * ‖y‖)) ^ 2 * ‖x - y‖ ^ 2) :=\n      congr_arg sqrt <| by\n        field_simp [sq, norm_sub_mul_self_real, norm_smul, real_inner_smul_left, inner_smul_right,\n          Real.norm_of_nonneg (mul_self_nonneg _)]\n        ring\n    _ = R ^ 2 / (‖x‖ * ‖y‖) * dist x y := by\n      rw [sqrt_mul, sqrt_sq, sqrt_sq, dist_eq_norm] <;> positivity\n\n"}
{"name":"norm_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\nr : 𝕜\nhx : Ne x 0\nhr : Ne r 0\n⊢ Eq (HDiv.hDiv (Norm.norm (Inner.inner x (HSMul.hSMul r x))) (HMul.hMul (Norm.norm x) (Norm.norm (HSMul.hSMul r x)))) 1","decl":"/-- The inner product of a nonzero vector with a nonzero multiple of\nitself, divided by the product of their norms, has absolute value\n1. -/\ntheorem norm_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul {x : E} {r : 𝕜} (hx : x ≠ 0)\n    (hr : r ≠ 0) : ‖⟪x, r • x⟫‖ / (‖x‖ * ‖r • x‖) = 1 := by\n  have hx' : ‖x‖ ≠ 0 := by simp [hx]\n  have hr' : ‖r‖ ≠ 0 := by simp [hr]\n  rw [inner_smul_right, norm_mul, ← inner_self_re_eq_norm, inner_self_eq_norm_mul_norm, norm_smul]\n  rw [← mul_assoc, ← div_div, mul_div_cancel_right₀ _ hx', ← div_div, mul_comm,\n    mul_div_cancel_right₀ _ hr', div_self hx']\n\n"}
{"name":"abs_real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx : F\nr : Real\nhx : Ne x 0\nhr : Ne r 0\n⊢ Eq (HDiv.hDiv (abs (Inner.inner x (HSMul.hSMul r x))) (HMul.hMul (Norm.norm x) (Norm.norm (HSMul.hSMul r x)))) 1","decl":"/-- The inner product of a nonzero vector with a nonzero multiple of\nitself, divided by the product of their norms, has absolute value\n1. -/\ntheorem abs_real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul {x : F} {r : ℝ}\n    (hx : x ≠ 0) (hr : r ≠ 0) : |⟪x, r • x⟫_ℝ| / (‖x‖ * ‖r • x‖) = 1 :=\n  norm_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul hx hr\n\n"}
{"name":"real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx : F\nr : Real\nhx : Ne x 0\nhr : LT.lt 0 r\n⊢ Eq (HDiv.hDiv (Inner.inner x (HSMul.hSMul r x)) (HMul.hMul (Norm.norm x) (Norm.norm (HSMul.hSMul r x)))) 1","decl":"/-- The inner product of a nonzero vector with a positive multiple of\nitself, divided by the product of their norms, has value 1. -/\ntheorem real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul {x : F} {r : ℝ} (hx : x ≠ 0)\n    (hr : 0 < r) : ⟪x, r • x⟫_ℝ / (‖x‖ * ‖r • x‖) = 1 := by\n  rw [real_inner_smul_self_right, norm_smul, Real.norm_eq_abs, ← mul_assoc ‖x‖, mul_comm _ |r|,\n    mul_assoc, abs_of_nonneg hr.le, div_self]\n  exact mul_ne_zero hr.ne' (mul_self_ne_zero.2 (norm_ne_zero_iff.2 hx))\n\n"}
{"name":"real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx : F\nr : Real\nhx : Ne x 0\nhr : LT.lt r 0\n⊢ Eq (HDiv.hDiv (Inner.inner x (HSMul.hSMul r x)) (HMul.hMul (Norm.norm x) (Norm.norm (HSMul.hSMul r x)))) (-1)","decl":"/-- The inner product of a nonzero vector with a negative multiple of\nitself, divided by the product of their norms, has value -1. -/\ntheorem real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul {x : F} {r : ℝ} (hx : x ≠ 0)\n    (hr : r < 0) : ⟪x, r • x⟫_ℝ / (‖x‖ * ‖r • x‖) = -1 := by\n  rw [real_inner_smul_self_right, norm_smul, Real.norm_eq_abs, ← mul_assoc ‖x‖, mul_comm _ |r|,\n    mul_assoc, abs_of_neg hr, neg_mul, div_neg_eq_neg_div, div_self]\n  exact mul_ne_zero hr.ne (mul_self_ne_zero.2 (norm_ne_zero_iff.2 hx))\n\n"}
{"name":"norm_inner_eq_norm_tfae","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ (List.cons (Eq (Norm.norm (Inner.inner x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))) (List.cons (Or (Eq x 0) (Eq y (HSMul.hSMul (HDiv.hDiv (Inner.inner x y) (Inner.inner x x)) x))) (List.cons (Or (Eq x 0) (Exists fun r => Eq y (HSMul.hSMul r x))) (List.cons (Or (Eq x 0) (Membership.mem (Submodule.span 𝕜 (Singleton.singleton x)) y)) List.nil)))).TFAE","decl":"theorem norm_inner_eq_norm_tfae (x y : E) :\n    List.TFAE [‖⟪x, y⟫‖ = ‖x‖ * ‖y‖,\n      x = 0 ∨ y = (⟪x, y⟫ / ⟪x, x⟫) • x,\n      x = 0 ∨ ∃ r : 𝕜, y = r • x,\n      x = 0 ∨ y ∈ 𝕜 ∙ x] := by\n  tfae_have 1 → 2 := by\n    refine fun h => or_iff_not_imp_left.2 fun hx₀ => ?_\n    have : ‖x‖ ^ 2 ≠ 0 := pow_ne_zero _ (norm_ne_zero_iff.2 hx₀)\n    rw [← sq_eq_sq₀, mul_pow, ← mul_right_inj' this, eq_comm, ← sub_eq_zero, ← mul_sub] at h <;>\n      try positivity\n    simp only [@norm_sq_eq_inner 𝕜] at h\n    letI : InnerProductSpace.Core 𝕜 E := InnerProductSpace.toCore\n    erw [← InnerProductSpace.Core.cauchy_schwarz_aux (𝕜 := 𝕜) (F := E),\n      InnerProductSpace.Core.normSq_eq_zero, sub_eq_zero] at h\n    rw [div_eq_inv_mul, mul_smul, h, inv_smul_smul₀]\n    rwa [inner_self_ne_zero]\n  tfae_have 2 → 3 := fun h => h.imp_right fun h' => ⟨_, h'⟩\n  tfae_have 3 → 1 := by\n    rintro (rfl | ⟨r, rfl⟩) <;>\n    simp [inner_smul_right, norm_smul, inner_self_eq_norm_sq_to_K, inner_self_eq_norm_mul_norm,\n      sq, mul_left_comm]\n  tfae_have 3 ↔ 4 := by simp only [Submodule.mem_span_singleton, eq_comm]\n  tfae_finish\n\n"}
{"name":"norm_inner_eq_norm_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\nhx₀ : Ne x 0\nhy₀ : Ne y 0\n⊢ Iff (Eq (Norm.norm (Inner.inner x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))) (Exists fun r => And (Ne r 0) (Eq y (HSMul.hSMul r x)))","decl":"/-- If the inner product of two vectors is equal to the product of their norms, then the two vectors\nare multiples of each other. One form of the equality case for Cauchy-Schwarz.\nCompare `inner_eq_norm_mul_iff`, which takes the stronger hypothesis `⟪x, y⟫ = ‖x‖ * ‖y‖`. -/\ntheorem norm_inner_eq_norm_iff {x y : E} (hx₀ : x ≠ 0) (hy₀ : y ≠ 0) :\n    ‖⟪x, y⟫‖ = ‖x‖ * ‖y‖ ↔ ∃ r : 𝕜, r ≠ 0 ∧ y = r • x :=\n  calc\n    ‖⟪x, y⟫‖ = ‖x‖ * ‖y‖ ↔ x = 0 ∨ ∃ r : 𝕜, y = r • x :=\n      (@norm_inner_eq_norm_tfae 𝕜 _ _ _ _ x y).out 0 2\n    _ ↔ ∃ r : 𝕜, y = r • x := or_iff_right hx₀\n    _ ↔ ∃ r : 𝕜, r ≠ 0 ∧ y = r • x :=\n      ⟨fun ⟨r, h⟩ => ⟨r, fun hr₀ => hy₀ <| h.symm ▸ smul_eq_zero.2 <| Or.inl hr₀, h⟩,\n        fun ⟨r, _hr₀, h⟩ => ⟨r, h⟩⟩\n\n"}
{"name":"norm_inner_div_norm_mul_norm_eq_one_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Iff (Eq (Norm.norm (HDiv.hDiv (Inner.inner x y) (HMul.hMul ↑(Norm.norm x) ↑(Norm.norm y)))) 1) (And (Ne x 0) (Exists fun r => And (Ne r 0) (Eq y (HSMul.hSMul r x))))","decl":"/-- The inner product of two vectors, divided by the product of their\nnorms, has absolute value 1 if and only if they are nonzero and one is\na multiple of the other. One form of equality case for Cauchy-Schwarz. -/\ntheorem norm_inner_div_norm_mul_norm_eq_one_iff (x y : E) :\n    ‖⟪x, y⟫ / (‖x‖ * ‖y‖)‖ = 1 ↔ x ≠ 0 ∧ ∃ r : 𝕜, r ≠ 0 ∧ y = r • x := by\n  constructor\n  · intro h\n    have hx₀ : x ≠ 0 := fun h₀ => by simp [h₀] at h\n    have hy₀ : y ≠ 0 := fun h₀ => by simp [h₀] at h\n    refine ⟨hx₀, (norm_inner_eq_norm_iff hx₀ hy₀).1 <| eq_of_div_eq_one ?_⟩\n    simpa using h\n  · rintro ⟨hx, ⟨r, ⟨hr, rfl⟩⟩⟩\n    simp only [norm_div, norm_mul, norm_ofReal, abs_norm]\n    exact norm_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul hx hr\n\n"}
{"name":"abs_real_inner_div_norm_mul_norm_eq_one_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Iff (Eq (abs (HDiv.hDiv (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y)))) 1) (And (Ne x 0) (Exists fun r => And (Ne r 0) (Eq y (HSMul.hSMul r x))))","decl":"/-- The inner product of two vectors, divided by the product of their\nnorms, has absolute value 1 if and only if they are nonzero and one is\na multiple of the other. One form of equality case for Cauchy-Schwarz. -/\ntheorem abs_real_inner_div_norm_mul_norm_eq_one_iff (x y : F) :\n    |⟪x, y⟫_ℝ / (‖x‖ * ‖y‖)| = 1 ↔ x ≠ 0 ∧ ∃ r : ℝ, r ≠ 0 ∧ y = r • x :=\n  @norm_inner_div_norm_mul_norm_eq_one_iff ℝ F _ _ _ x y\n\n"}
{"name":"inner_eq_norm_mul_iff_div","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\nh₀ : Ne x 0\n⊢ Iff (Eq (Inner.inner x y) (HMul.hMul ↑(Norm.norm x) ↑(Norm.norm y))) (Eq (HSMul.hSMul (HDiv.hDiv ↑(Norm.norm y) ↑(Norm.norm x)) x) y)","decl":"theorem inner_eq_norm_mul_iff_div {x y : E} (h₀ : x ≠ 0) :\n    ⟪x, y⟫ = (‖x‖ : 𝕜) * ‖y‖ ↔ (‖y‖ / ‖x‖ : 𝕜) • x = y := by\n  have h₀' := h₀\n  rw [← norm_ne_zero_iff, Ne, ← @ofReal_eq_zero 𝕜] at h₀'\n  constructor <;> intro h\n  · have : x = 0 ∨ y = (⟪x, y⟫ / ⟪x, x⟫ : 𝕜) • x :=\n      ((@norm_inner_eq_norm_tfae 𝕜 _ _ _ _ x y).out 0 1).1 (by simp [h])\n    rw [this.resolve_left h₀, h]\n    simp [norm_smul, inner_self_ofReal_norm, mul_div_cancel_right₀ _ h₀']\n  · conv_lhs => rw [← h, inner_smul_right, inner_self_eq_norm_sq_to_K]\n    field_simp [sq, mul_left_comm]\n\n"}
{"name":"inner_eq_norm_mul_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Iff (Eq (Inner.inner x y) (HMul.hMul ↑(Norm.norm x) ↑(Norm.norm y))) (Eq (HSMul.hSMul (↑(Norm.norm y)) x) (HSMul.hSMul (↑(Norm.norm x)) y))","decl":"/-- If the inner product of two vectors is equal to the product of their norms (i.e.,\n`⟪x, y⟫ = ‖x‖ * ‖y‖`), then the two vectors are nonnegative real multiples of each other. One form\nof the equality case for Cauchy-Schwarz.\nCompare `norm_inner_eq_norm_iff`, which takes the weaker hypothesis `abs ⟪x, y⟫ = ‖x‖ * ‖y‖`. -/\ntheorem inner_eq_norm_mul_iff {x y : E} :\n    ⟪x, y⟫ = (‖x‖ : 𝕜) * ‖y‖ ↔ (‖y‖ : 𝕜) • x = (‖x‖ : 𝕜) • y := by\n  rcases eq_or_ne x 0 with (rfl | h₀)\n  · simp\n  · rw [inner_eq_norm_mul_iff_div h₀, div_eq_inv_mul, mul_smul, inv_smul_eq_iff₀]\n    rwa [Ne, ofReal_eq_zero, norm_eq_zero]\n\n"}
{"name":"inner_eq_norm_mul_iff_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Iff (Eq (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y))) (Eq (HSMul.hSMul (Norm.norm y) x) (HSMul.hSMul (Norm.norm x) y))","decl":"/-- If the inner product of two vectors is equal to the product of their norms (i.e.,\n`⟪x, y⟫ = ‖x‖ * ‖y‖`), then the two vectors are nonnegative real multiples of each other. One form\nof the equality case for Cauchy-Schwarz.\nCompare `norm_inner_eq_norm_iff`, which takes the weaker hypothesis `abs ⟪x, y⟫ = ‖x‖ * ‖y‖`. -/\ntheorem inner_eq_norm_mul_iff_real {x y : F} : ⟪x, y⟫_ℝ = ‖x‖ * ‖y‖ ↔ ‖y‖ • x = ‖x‖ • y :=\n  inner_eq_norm_mul_iff\n\n"}
{"name":"real_inner_div_norm_mul_norm_eq_one_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Iff (Eq (HDiv.hDiv (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y))) 1) (And (Ne x 0) (Exists fun r => And (LT.lt 0 r) (Eq y (HSMul.hSMul r x))))","decl":"/-- The inner product of two vectors, divided by the product of their\nnorms, has value 1 if and only if they are nonzero and one is\na positive multiple of the other. -/\ntheorem real_inner_div_norm_mul_norm_eq_one_iff (x y : F) :\n    ⟪x, y⟫_ℝ / (‖x‖ * ‖y‖) = 1 ↔ x ≠ 0 ∧ ∃ r : ℝ, 0 < r ∧ y = r • x := by\n  constructor\n  · intro h\n    have hx₀ : x ≠ 0 := fun h₀ => by simp [h₀] at h\n    have hy₀ : y ≠ 0 := fun h₀ => by simp [h₀] at h\n    refine ⟨hx₀, ‖y‖ / ‖x‖, div_pos (norm_pos_iff.2 hy₀) (norm_pos_iff.2 hx₀), ?_⟩\n    exact ((inner_eq_norm_mul_iff_div hx₀).1 (eq_of_div_eq_one h)).symm\n  · rintro ⟨hx, ⟨r, ⟨hr, rfl⟩⟩⟩\n    exact real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul hx hr\n\n"}
{"name":"real_inner_div_norm_mul_norm_eq_neg_one_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Iff (Eq (HDiv.hDiv (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y))) (-1)) (And (Ne x 0) (Exists fun r => And (LT.lt r 0) (Eq y (HSMul.hSMul r x))))","decl":"/-- The inner product of two vectors, divided by the product of their\nnorms, has value -1 if and only if they are nonzero and one is\na negative multiple of the other. -/\ntheorem real_inner_div_norm_mul_norm_eq_neg_one_iff (x y : F) :\n    ⟪x, y⟫_ℝ / (‖x‖ * ‖y‖) = -1 ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by\n  rw [← neg_eq_iff_eq_neg, ← neg_div, ← inner_neg_right, ← norm_neg y,\n    real_inner_div_norm_mul_norm_eq_one_iff, (@neg_surjective ℝ _).exists]\n  refine Iff.rfl.and (exists_congr fun r => ?_)\n  rw [neg_pos, neg_smul, neg_inj]\n\n"}
{"name":"inner_eq_one_iff_of_norm_one","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\nhx : Eq (Norm.norm x) 1\nhy : Eq (Norm.norm y) 1\n⊢ Iff (Eq (Inner.inner x y) 1) (Eq x y)","decl":"/-- If the inner product of two unit vectors is `1`, then the two vectors are equal. One form of\nthe equality case for Cauchy-Schwarz. -/\ntheorem inner_eq_one_iff_of_norm_one {x y : E} (hx : ‖x‖ = 1) (hy : ‖y‖ = 1) :\n    ⟪x, y⟫ = 1 ↔ x = y := by\n  convert inner_eq_norm_mul_iff (𝕜 := 𝕜) (E := E) using 2 <;> simp [hx, hy]\n\n"}
{"name":"inner_lt_norm_mul_iff_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\n⊢ Iff (LT.lt (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y))) (Ne (HSMul.hSMul (Norm.norm y) x) (HSMul.hSMul (Norm.norm x) y))","decl":"theorem inner_lt_norm_mul_iff_real {x y : F} : ⟪x, y⟫_ℝ < ‖x‖ * ‖y‖ ↔ ‖y‖ • x ≠ ‖x‖ • y :=\n  calc\n    ⟪x, y⟫_ℝ < ‖x‖ * ‖y‖ ↔ ⟪x, y⟫_ℝ ≠ ‖x‖ * ‖y‖ :=\n      ⟨ne_of_lt, lt_of_le_of_ne (real_inner_le_norm _ _)⟩\n    _ ↔ ‖y‖ • x ≠ ‖x‖ • y := not_congr inner_eq_norm_mul_iff_real\n\n"}
{"name":"inner_lt_one_iff_real_of_norm_one","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nx y : F\nhx : Eq (Norm.norm x) 1\nhy : Eq (Norm.norm y) 1\n⊢ Iff (LT.lt (Inner.inner x y) 1) (Ne x y)","decl":"/-- If the inner product of two unit vectors is strictly less than `1`, then the two vectors are\ndistinct. One form of the equality case for Cauchy-Schwarz. -/\ntheorem inner_lt_one_iff_real_of_norm_one {x y : F} (hx : ‖x‖ = 1) (hy : ‖y‖ = 1) :\n    ⟪x, y⟫_ℝ < 1 ↔ x ≠ y := by convert inner_lt_norm_mul_iff_real (F := F) <;> simp [hx, hy]\n\n"}
{"name":"eq_of_norm_le_re_inner_eq_norm_sq","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\nhle : LE.le (Norm.norm x) (Norm.norm y)\nh : Eq (RCLike.re (Inner.inner x y)) (HPow.hPow (Norm.norm y) 2)\n⊢ Eq x y","decl":"/-- The sphere of radius `r = ‖y‖` is tangent to the plane `⟪x, y⟫ = ‖y‖ ^ 2` at `x = y`. -/\ntheorem eq_of_norm_le_re_inner_eq_norm_sq {x y : E} (hle : ‖x‖ ≤ ‖y‖) (h : re ⟪x, y⟫ = ‖y‖ ^ 2) :\n    x = y := by\n  suffices H : re ⟪x - y, x - y⟫ ≤ 0 by rwa [inner_self_nonpos, sub_eq_zero] at H\n  have H₁ : ‖x‖ ^ 2 ≤ ‖y‖ ^ 2 := by gcongr\n  have H₂ : re ⟪y, x⟫ = ‖y‖ ^ 2 := by rwa [← inner_conj_symm, conj_re]\n  simpa [inner_sub_left, inner_sub_right, ← norm_sq_eq_inner, h, H₂] using H₁\n\n"}
{"name":"RCLike.inner_apply","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\ninst✝ : RCLike 𝕜\nx y : 𝕜\n⊢ Eq (Inner.inner x y) (HMul.hMul ((starRingEnd 𝕜) x) y)","decl":"@[simp]\ntheorem RCLike.inner_apply (x y : 𝕜) : ⟪x, y⟫ = conj x * y :=\n  rfl\n\n"}
{"name":"real_inner_eq_re_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx y : E\n⊢ Eq (Inner.inner x y) (RCLike.re (Inner.inner x y))","decl":"theorem real_inner_eq_re_inner (x y : E) :\n    @Inner.inner ℝ E (Inner.rclikeToReal 𝕜 E) x y = re ⟪x, y⟫ :=\n  rfl\n\n"}
{"name":"real_inner_I_smul_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nx : E\n⊢ Eq (Inner.inner x (HSMul.hSMul RCLike.I x)) 0","decl":"theorem real_inner_I_smul_self (x : E) :\n    @Inner.inner ℝ E (Inner.rclikeToReal 𝕜 E) x ((I : 𝕜) • x) = 0 := by\n  simp [real_inner_eq_re_inner 𝕜, inner_smul_right]\n\n"}
{"name":"Complex.inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"w z : Complex\n⊢ Eq (Inner.inner w z) (HMul.hMul ((starRingEnd Complex) w) z).re","decl":"@[simp]\nprotected theorem Complex.inner (w z : ℂ) : ⟪w, z⟫_ℝ = (conj w * z).re :=\n  rfl\n\n"}
{"name":"continuous_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\n⊢ Continuous fun p => Inner.inner p.1 p.2","decl":"theorem continuous_inner : Continuous fun p : E × E => ⟪p.1, p.2⟫ :=\n  letI : InnerProductSpace ℝ E := InnerProductSpace.rclikeToReal 𝕜 E\n  letI : IsScalarTower ℝ 𝕜 E := RestrictScalars.isScalarTower _ _ _\n  isBoundedBilinearMap_inner.continuous\n\n"}
{"name":"Filter.Tendsto.inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nα : Type u_4\nf g : α → E\nl : Filter α\nx y : E\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\n⊢ Filter.Tendsto (fun t => Inner.inner (f t) (g t)) l (nhds (Inner.inner x y))","decl":"theorem Filter.Tendsto.inner {f g : α → E} {l : Filter α} {x y : E} (hf : Tendsto f l (𝓝 x))\n    (hg : Tendsto g l (𝓝 y)) : Tendsto (fun t => ⟪f t, g t⟫) l (𝓝 ⟪x, y⟫) :=\n  (continuous_inner.tendsto _).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"ContinuousWithinAt.inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nα : Type u_4\ninst✝ : TopologicalSpace α\nf g : α → E\nx : α\ns : Set α\nhf : ContinuousWithinAt f s x\nhg : ContinuousWithinAt g s x\n⊢ ContinuousWithinAt (fun t => Inner.inner (f t) (g t)) s x","decl":"theorem ContinuousWithinAt.inner (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) :\n    ContinuousWithinAt (fun t => ⟪f t, g t⟫) s x :=\n  Filter.Tendsto.inner hf hg\n\n"}
{"name":"ContinuousAt.inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nα : Type u_4\ninst✝ : TopologicalSpace α\nf g : α → E\nx : α\nhf : ContinuousAt f x\nhg : ContinuousAt g x\n⊢ ContinuousAt (fun t => Inner.inner (f t) (g t)) x","decl":"theorem ContinuousAt.inner (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun t => ⟪f t, g t⟫) x :=\n  Filter.Tendsto.inner hf hg\n\n"}
{"name":"ContinuousOn.inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nα : Type u_4\ninst✝ : TopologicalSpace α\nf g : α → E\ns : Set α\nhf : ContinuousOn f s\nhg : ContinuousOn g s\n⊢ ContinuousOn (fun t => Inner.inner (f t) (g t)) s","decl":"theorem ContinuousOn.inner (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun t => ⟪f t, g t⟫) s := fun x hx => (hf x hx).inner (hg x hx)\n\n"}
{"name":"Continuous.inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nα : Type u_4\ninst✝ : TopologicalSpace α\nf g : α → E\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun t => Inner.inner (f t) (g t)","decl":"@[continuity]\ntheorem Continuous.inner (hf : Continuous f) (hg : Continuous g) : Continuous fun t => ⟪f t, g t⟫ :=\n  continuous_iff_continuousAt.2 fun _x => hf.continuousAt.inner hg.continuousAt\n\n"}
