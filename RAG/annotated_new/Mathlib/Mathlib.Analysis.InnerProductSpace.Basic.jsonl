{"name":"inner_conj_symm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq ((starRingEnd ğ•œ) (Inner.inner y x)) (Inner.inner x y)","decl":"@[simp]\ntheorem inner_conj_symm (x y : E) : âŸªy, xâŸ«â€  = âŸªx, yâŸ« :=\n  InnerProductSpace.conj_symm _ _\n\n"}
{"name":"real_inner_comm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Eq (Inner.inner y x) (Inner.inner x y)","decl":"theorem real_inner_comm (x y : F) : âŸªy, xâŸ«_â„ = âŸªx, yâŸ«_â„ :=\n  @inner_conj_symm â„ _ _ _ _ x y\n\n"}
{"name":"inner_eq_zero_symm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Iff (Eq (Inner.inner x y) 0) (Eq (Inner.inner y x) 0)","decl":"theorem inner_eq_zero_symm {x y : E} : âŸªx, yâŸ« = 0 â†” âŸªy, xâŸ« = 0 := by\n  rw [â† inner_conj_symm]\n  exact star_eq_zero\n\n"}
{"name":"inner_self_im","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (RCLike.im (Inner.inner x x)) 0","decl":"@[simp]\ntheorem inner_self_im (x : E) : im âŸªx, xâŸ« = 0 := by rw [â† @ofReal_inj ğ•œ, im_eq_conj_sub]; simp\n\n"}
{"name":"inner_add_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y z : E\nâŠ¢ Eq (Inner.inner (HAdd.hAdd x y) z) (HAdd.hAdd (Inner.inner x z) (Inner.inner y z))","decl":"theorem inner_add_left (x y z : E) : âŸªx + y, zâŸ« = âŸªx, zâŸ« + âŸªy, zâŸ« :=\n  InnerProductSpace.add_left _ _ _\n\n"}
{"name":"inner_add_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y z : E\nâŠ¢ Eq (Inner.inner x (HAdd.hAdd y z)) (HAdd.hAdd (Inner.inner x y) (Inner.inner x z))","decl":"theorem inner_add_right (x y z : E) : âŸªx, y + zâŸ« = âŸªx, yâŸ« + âŸªx, zâŸ« := by\n  rw [â† inner_conj_symm, inner_add_left, RingHom.map_add]\n  simp only [inner_conj_symm]\n\n"}
{"name":"inner_re_symm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (RCLike.re (Inner.inner x y)) (RCLike.re (Inner.inner y x))","decl":"theorem inner_re_symm (x y : E) : re âŸªx, yâŸ« = re âŸªy, xâŸ« := by rw [â† inner_conj_symm, conj_re]\n\n"}
{"name":"inner_im_symm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (RCLike.im (Inner.inner x y)) (Neg.neg (RCLike.im (Inner.inner y x)))","decl":"theorem inner_im_symm (x y : E) : im âŸªx, yâŸ« = -im âŸªy, xâŸ« := by rw [â† inner_conj_symm, conj_im]\n\n"}
{"name":"inner_smul_left_eq_star_smul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¸ : RCLike ğ•œ\ninstâœâ· : SeminormedAddCommGroup E\ninstâœâ¶ : InnerProductSpace ğ•œ E\nğ• : Type u_4\ninstâœâµ : CommSemiring ğ•\ninstâœâ´ : StarRing ğ•\ninstâœÂ³ : Algebra ğ• ğ•œ\ninstâœÂ² : Module ğ• E\ninstâœÂ¹ : IsScalarTower ğ• ğ•œ E\ninstâœ : StarModule ğ• ğ•œ\nx y : E\nr : ğ•\nâŠ¢ Eq (Inner.inner (HSMul.hSMul r x) y) (HSMul.hSMul ((starRingEnd ğ•) r) (Inner.inner x y))","decl":"/-- See `inner_smul_left` for the common special when `ğ•œ = ğ•`. -/\nlemma inner_smul_left_eq_star_smul (x y : E) (r : ğ•) : âŸªr â€¢ x, yâŸ« = râ€  â€¢ âŸªx, yâŸ« := by\n  rw [â† algebraMap_smul ğ•œ r, InnerProductSpace.smul_left, starRingEnd_apply, starRingEnd_apply,\n    â† algebraMap_star_comm, â† smul_eq_mul, algebraMap_smul]\n\n"}
{"name":"inner_smul_left_eq_smul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¹ : RCLike ğ•œ\ninstâœâ¸ : SeminormedAddCommGroup E\ninstâœâ· : InnerProductSpace ğ•œ E\nğ• : Type u_4\ninstâœâ¶ : CommSemiring ğ•\ninstâœâµ : StarRing ğ•\ninstâœâ´ : Algebra ğ• ğ•œ\ninstâœÂ³ : Module ğ• E\ninstâœÂ² : IsScalarTower ğ• ğ•œ E\ninstâœÂ¹ : StarModule ğ• ğ•œ\ninstâœ : TrivialStar ğ•\nx y : E\nr : ğ•\nâŠ¢ Eq (Inner.inner (HSMul.hSMul r x) y) (HSMul.hSMul r (Inner.inner x y))","decl":"/-- Special case of `inner_smul_left_eq_star_smul` when the acting ring has a trivial star\n(eg `â„•`, `â„¤`, `â„šâ‰¥0`, `â„š`, `â„`). -/\nlemma inner_smul_left_eq_smul [TrivialStar ğ•] (x y : E) (r : ğ•) : âŸªr â€¢ x, yâŸ« = r â€¢ âŸªx, yâŸ« := by\n  rw [inner_smul_left_eq_star_smul, starRingEnd_apply, star_trivial]\n\n"}
{"name":"inner_smul_right_eq_smul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¸ : RCLike ğ•œ\ninstâœâ· : SeminormedAddCommGroup E\ninstâœâ¶ : InnerProductSpace ğ•œ E\nğ• : Type u_4\ninstâœâµ : CommSemiring ğ•\ninstâœâ´ : StarRing ğ•\ninstâœÂ³ : Algebra ğ• ğ•œ\ninstâœÂ² : Module ğ• E\ninstâœÂ¹ : IsScalarTower ğ• ğ•œ E\ninstâœ : StarModule ğ• ğ•œ\nx y : E\nr : ğ•\nâŠ¢ Eq (Inner.inner x (HSMul.hSMul r y)) (HSMul.hSMul r (Inner.inner x y))","decl":"/-- See `inner_smul_right` for the common special when `ğ•œ = ğ•`. -/\nlemma inner_smul_right_eq_smul (x y : E) (r : ğ•) : âŸªx, r â€¢ yâŸ« = r â€¢ âŸªx, yâŸ« := by\n  rw [â† inner_conj_symm, inner_smul_left_eq_star_smul, starRingEnd_apply, starRingEnd_apply,\n    star_smul, star_star, â† starRingEnd_apply, inner_conj_symm]\n\n"}
{"name":"inner_smul_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nr : ğ•œ\nâŠ¢ Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul ((starRingEnd ğ•œ) r) (Inner.inner x y))","decl":"/-- See `inner_smul_left_eq_star_smul` for the case of a general algebra action. -/\ntheorem inner_smul_left (x y : E) (r : ğ•œ) : âŸªr â€¢ x, yâŸ« = râ€  * âŸªx, yâŸ« :=\n  inner_smul_left_eq_star_smul ..\n\n"}
{"name":"real_inner_smul_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nr : Real\nâŠ¢ Eq (Inner.inner (HSMul.hSMul r x) y) (HMul.hMul r (Inner.inner x y))","decl":"theorem real_inner_smul_left (x y : F) (r : â„) : âŸªr â€¢ x, yâŸ«_â„ = r * âŸªx, yâŸ«_â„ :=\n  inner_smul_left _ _ _\n\n"}
{"name":"inner_smul_real_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nr : Real\nâŠ¢ Eq (Inner.inner (HSMul.hSMul (â†‘r) x) y) (HSMul.hSMul r (Inner.inner x y))","decl":"theorem inner_smul_real_left (x y : E) (r : â„) : âŸª(r : ğ•œ) â€¢ x, yâŸ« = r â€¢ âŸªx, yâŸ« := by\n  rw [inner_smul_left, conj_ofReal, Algebra.smul_def]\n\n"}
{"name":"inner_smul_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nr : ğ•œ\nâŠ¢ Eq (Inner.inner x (HSMul.hSMul r y)) (HMul.hMul r (Inner.inner x y))","decl":"/-- See `inner_smul_right_eq_smul` for the case of a general algebra action. -/\ntheorem inner_smul_right (x y : E) (r : ğ•œ) : âŸªx, r â€¢ yâŸ« = r * âŸªx, yâŸ« :=\n  inner_smul_right_eq_smul ..\n\n"}
{"name":"real_inner_smul_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nr : Real\nâŠ¢ Eq (Inner.inner x (HSMul.hSMul r y)) (HMul.hMul r (Inner.inner x y))","decl":"theorem real_inner_smul_right (x y : F) (r : â„) : âŸªx, r â€¢ yâŸ«_â„ = r * âŸªx, yâŸ«_â„ :=\n  inner_smul_right _ _ _\n\n"}
{"name":"inner_smul_real_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nr : Real\nâŠ¢ Eq (Inner.inner x (HSMul.hSMul (â†‘r) y)) (HSMul.hSMul r (Inner.inner x y))","decl":"theorem inner_smul_real_right (x y : E) (r : â„) : âŸªx, (r : ğ•œ) â€¢ yâŸ« = r â€¢ âŸªx, yâŸ« := by\n  rw [inner_smul_right, Algebra.smul_def]\n\n"}
{"name":"sesqFormOfInner_apply_apply","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nm y : E\nâŠ¢ Eq ((sesqFormOfInner m) y) (Inner.inner y m)","decl":"/-- The inner product as a sesquilinear form.\n\nNote that in the case `ğ•œ = â„` this is a bilinear form. -/\n@[simps!]\ndef sesqFormOfInner : E â†’â‚—[ğ•œ] E â†’â‚—â‹†[ğ•œ] ğ•œ :=\n  LinearMap.mkâ‚‚'â‚›â‚— (RingHom.id ğ•œ) (starRingEnd _) (fun x y => âŸªy, xâŸ«)\n    (fun _x _y _z => inner_add_right _ _ _) (fun _r _x _y => inner_smul_right _ _ _)\n    (fun _x _y _z => inner_add_left _ _ _) fun _r _x _y => inner_smul_left _ _ _\n\n"}
{"name":"bilinFormOfRealInner_apply_apply","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nmâœ m : F\nâŠ¢ Eq ((bilinFormOfRealInner mâœ) m) (Inner.inner mâœ m)","decl":"/-- The real inner product as a bilinear form.\n\nNote that unlike `sesqFormOfInner`, this does not reverse the order of the arguments. -/\n@[simps!]\ndef bilinFormOfRealInner : BilinForm â„ F := sesqFormOfInner.flip\n\n"}
{"name":"sum_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ns : Finset Î¹\nf : Î¹ â†’ E\nx : E\nâŠ¢ Eq (Inner.inner (s.sum fun i => f i) x) (s.sum fun i => Inner.inner (f i) x)","decl":"/-- An inner product with a sum on the left. -/\ntheorem sum_inner {Î¹ : Type*} (s : Finset Î¹) (f : Î¹ â†’ E) (x : E) :\n    âŸªâˆ‘ i âˆˆ s, f i, xâŸ« = âˆ‘ i âˆˆ s, âŸªf i, xâŸ« :=\n  map_sum (sesqFormOfInner (ğ•œ := ğ•œ) (E := E) x) _ _\n\n"}
{"name":"inner_sum","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ns : Finset Î¹\nf : Î¹ â†’ E\nx : E\nâŠ¢ Eq (Inner.inner x (s.sum fun i => f i)) (s.sum fun i => Inner.inner x (f i))","decl":"/-- An inner product with a sum on the right. -/\ntheorem inner_sum {Î¹ : Type*} (s : Finset Î¹) (f : Î¹ â†’ E) (x : E) :\n    âŸªx, âˆ‘ i âˆˆ s, f iâŸ« = âˆ‘ i âˆˆ s, âŸªx, f iâŸ« :=\n  map_sum (LinearMap.flip sesqFormOfInner x) _ _\n\n"}
{"name":"Finsupp.sum_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nl : Finsupp Î¹ ğ•œ\nv : Î¹ â†’ E\nx : E\nâŠ¢ Eq (Inner.inner (l.sum fun i a => HSMul.hSMul a (v i)) x) (l.sum fun i a => HSMul.hSMul ((starRingEnd ğ•œ) a) (Inner.inner (v i) x))","decl":"/-- An inner product with a sum on the left, `Finsupp` version. -/\nprotected theorem Finsupp.sum_inner {Î¹ : Type*} (l : Î¹ â†’â‚€ ğ•œ) (v : Î¹ â†’ E) (x : E) :\n    âŸªl.sum fun (i : Î¹) (a : ğ•œ) => a â€¢ v i, xâŸ« = l.sum fun (i : Î¹) (a : ğ•œ) => conj a â€¢ âŸªv i, xâŸ« := by\n  convert sum_inner (ğ•œ := ğ•œ) l.support (fun a => l a â€¢ v a) x\n  simp only [inner_smul_left, Finsupp.sum, smul_eq_mul]\n\n"}
{"name":"Finsupp.inner_sum","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nl : Finsupp Î¹ ğ•œ\nv : Î¹ â†’ E\nx : E\nâŠ¢ Eq (Inner.inner x (l.sum fun i a => HSMul.hSMul a (v i))) (l.sum fun i a => HSMul.hSMul a (Inner.inner x (v i)))","decl":"/-- An inner product with a sum on the right, `Finsupp` version. -/\nprotected theorem Finsupp.inner_sum {Î¹ : Type*} (l : Î¹ â†’â‚€ ğ•œ) (v : Î¹ â†’ E) (x : E) :\n    âŸªx, l.sum fun (i : Î¹) (a : ğ•œ) => a â€¢ v iâŸ« = l.sum fun (i : Î¹) (a : ğ•œ) => a â€¢ âŸªx, v iâŸ« := by\n  convert inner_sum (ğ•œ := ğ•œ) l.support (fun a => l a â€¢ v a) x\n  simp only [inner_smul_right, Finsupp.sum, smul_eq_mul]\n\n"}
{"name":"DFinsupp.sum_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ninstâœÂ² : DecidableEq Î¹\nÎ± : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ AddZeroClass (Î± i)\ninstâœ : (i : Î¹) â†’ (x : Î± i) â†’ Decidable (Ne x 0)\nf : (i : Î¹) â†’ Î± i â†’ E\nl : DFinsupp fun i => Î± i\nx : E\nâŠ¢ Eq (Inner.inner (l.sum f) x) (l.sum fun i a => Inner.inner (f i a) x)","decl":"protected theorem DFinsupp.sum_inner {Î¹ : Type*} [DecidableEq Î¹] {Î± : Î¹ â†’ Type*}\n    [âˆ€ i, AddZeroClass (Î± i)] [âˆ€ (i) (x : Î± i), Decidable (x â‰  0)] (f : âˆ€ i, Î± i â†’ E)\n    (l : Î â‚€ i, Î± i) (x : E) : âŸªl.sum f, xâŸ« = l.sum fun i a => âŸªf i a, xâŸ« := by\n  simp +contextual only [DFinsupp.sum, sum_inner, smul_eq_mul]\n\n"}
{"name":"DFinsupp.inner_sum","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\ninstâœÂ² : DecidableEq Î¹\nÎ± : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ AddZeroClass (Î± i)\ninstâœ : (i : Î¹) â†’ (x : Î± i) â†’ Decidable (Ne x 0)\nf : (i : Î¹) â†’ Î± i â†’ E\nl : DFinsupp fun i => Î± i\nx : E\nâŠ¢ Eq (Inner.inner x (l.sum f)) (l.sum fun i a => Inner.inner x (f i a))","decl":"protected theorem DFinsupp.inner_sum {Î¹ : Type*} [DecidableEq Î¹] {Î± : Î¹ â†’ Type*}\n    [âˆ€ i, AddZeroClass (Î± i)] [âˆ€ (i) (x : Î± i), Decidable (x â‰  0)] (f : âˆ€ i, Î± i â†’ E)\n    (l : Î â‚€ i, Î± i) (x : E) : âŸªx, l.sum fâŸ« = l.sum fun i a => âŸªx, f i aâŸ« := by\n  simp +contextual only [DFinsupp.sum, inner_sum, smul_eq_mul]\n\n"}
{"name":"inner_zero_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (Inner.inner 0 x) 0","decl":"@[simp]\ntheorem inner_zero_left (x : E) : âŸª0, xâŸ« = 0 := by\n  rw [â† zero_smul ğ•œ (0 : E), inner_smul_left, RingHom.map_zero, zero_mul]\n\n"}
{"name":"inner_re_zero_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (RCLike.re (Inner.inner 0 x)) 0","decl":"theorem inner_re_zero_left (x : E) : re âŸª0, xâŸ« = 0 := by\n  simp only [inner_zero_left, AddMonoidHom.map_zero]\n\n"}
{"name":"inner_zero_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (Inner.inner x 0) 0","decl":"@[simp]\ntheorem inner_zero_right (x : E) : âŸªx, 0âŸ« = 0 := by\n  rw [â† inner_conj_symm, inner_zero_left, RingHom.map_zero]\n\n"}
{"name":"inner_re_zero_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (RCLike.re (Inner.inner x 0)) 0","decl":"theorem inner_re_zero_right (x : E) : re âŸªx, 0âŸ« = 0 := by\n  simp only [inner_zero_right, AddMonoidHom.map_zero]\n\n"}
{"name":"inner_self_nonneg","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ LE.le 0 (RCLike.re (Inner.inner x x))","decl":"theorem inner_self_nonneg {x : E} : 0 â‰¤ re âŸªx, xâŸ« :=\n  PreInnerProductSpace.toCore.nonneg_re x\n\n"}
{"name":"real_inner_self_nonneg","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx : F\nâŠ¢ LE.le 0 (Inner.inner x x)","decl":"theorem real_inner_self_nonneg {x : F} : 0 â‰¤ âŸªx, xâŸ«_â„ :=\n  @inner_self_nonneg â„ F _ _ _ x\n\n"}
{"name":"inner_self_ofReal_re","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (â†‘(RCLike.re (Inner.inner x x))) (Inner.inner x x)","decl":"@[simp]\ntheorem inner_self_ofReal_re (x : E) : (re âŸªx, xâŸ« : ğ•œ) = âŸªx, xâŸ« :=\n  ((RCLike.is_real_TFAE (âŸªx, xâŸ« : ğ•œ)).out 2 3).2 (inner_self_im (ğ•œ := ğ•œ) x)\n\n"}
{"name":"inner_self_eq_norm_sq_to_K","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (Inner.inner x x) (HPow.hPow (â†‘(Norm.norm x)) 2)","decl":"theorem inner_self_eq_norm_sq_to_K (x : E) : âŸªx, xâŸ« = (â€–xâ€– : ğ•œ) ^ 2 := by\n  rw [â† inner_self_ofReal_re, â† norm_sq_eq_inner, ofReal_pow]\n\n"}
{"name":"inner_self_re_eq_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (RCLike.re (Inner.inner x x)) (Norm.norm (Inner.inner x x))","decl":"theorem inner_self_re_eq_norm (x : E) : re âŸªx, xâŸ« = â€–âŸªx, xâŸ«â€– := by\n  conv_rhs => rw [â† inner_self_ofReal_re]\n  symm\n  exact norm_of_nonneg inner_self_nonneg\n\n"}
{"name":"inner_self_ofReal_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (â†‘(Norm.norm (Inner.inner x x))) (Inner.inner x x)","decl":"theorem inner_self_ofReal_norm (x : E) : (â€–âŸªx, xâŸ«â€– : ğ•œ) = âŸªx, xâŸ« := by\n  rw [â† inner_self_re_eq_norm]\n  exact inner_self_ofReal_re _\n\n"}
{"name":"real_inner_self_abs","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx : F\nâŠ¢ Eq (abs (Inner.inner x x)) (Inner.inner x x)","decl":"theorem real_inner_self_abs (x : F) : |âŸªx, xâŸ«_â„| = âŸªx, xâŸ«_â„ :=\n  @inner_self_ofReal_norm â„ F _ _ _ x\n\n"}
{"name":"norm_inner_symm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (Norm.norm (Inner.inner x y)) (Norm.norm (Inner.inner y x))","decl":"theorem norm_inner_symm (x y : E) : â€–âŸªx, yâŸ«â€– = â€–âŸªy, xâŸ«â€– := by rw [â† inner_conj_symm, norm_conj]\n\n"}
{"name":"inner_neg_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (Inner.inner (Neg.neg x) y) (Neg.neg (Inner.inner x y))","decl":"@[simp]\ntheorem inner_neg_left (x y : E) : âŸª-x, yâŸ« = -âŸªx, yâŸ« := by\n  rw [â† neg_one_smul ğ•œ x, inner_smul_left]\n  simp\n\n"}
{"name":"inner_neg_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (Inner.inner x (Neg.neg y)) (Neg.neg (Inner.inner x y))","decl":"@[simp]\ntheorem inner_neg_right (x y : E) : âŸªx, -yâŸ« = -âŸªx, yâŸ« := by\n  rw [â† inner_conj_symm, inner_neg_left]; simp only [RingHom.map_neg, inner_conj_symm]\n\n"}
{"name":"inner_neg_neg","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (Inner.inner (Neg.neg x) (Neg.neg y)) (Inner.inner x y)","decl":"theorem inner_neg_neg (x y : E) : âŸª-x, -yâŸ« = âŸªx, yâŸ« := by simp\n\n"}
{"name":"inner_self_conj","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq ((starRingEnd ğ•œ) (Inner.inner x x)) (Inner.inner x x)","decl":"theorem inner_self_conj (x : E) : âŸªx, xâŸ«â€  = âŸªx, xâŸ« := inner_conj_symm _ _\n\n"}
{"name":"inner_sub_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y z : E\nâŠ¢ Eq (Inner.inner (HSub.hSub x y) z) (HSub.hSub (Inner.inner x z) (Inner.inner y z))","decl":"theorem inner_sub_left (x y z : E) : âŸªx - y, zâŸ« = âŸªx, zâŸ« - âŸªy, zâŸ« := by\n  simp [sub_eq_add_neg, inner_add_left]\n\n"}
{"name":"inner_sub_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y z : E\nâŠ¢ Eq (Inner.inner x (HSub.hSub y z)) (HSub.hSub (Inner.inner x y) (Inner.inner x z))","decl":"theorem inner_sub_right (x y z : E) : âŸªx, y - zâŸ« = âŸªx, yâŸ« - âŸªx, zâŸ« := by\n  simp [sub_eq_add_neg, inner_add_right]\n\n"}
{"name":"inner_mul_symm_re_eq_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (RCLike.re (HMul.hMul (Inner.inner x y) (Inner.inner y x))) (Norm.norm (HMul.hMul (Inner.inner x y) (Inner.inner y x)))","decl":"theorem inner_mul_symm_re_eq_norm (x y : E) : re (âŸªx, yâŸ« * âŸªy, xâŸ«) = â€–âŸªx, yâŸ« * âŸªy, xâŸ«â€– := by\n  rw [â† inner_conj_symm, mul_comm]\n  exact re_eq_norm_of_mul_conj (inner y x)\n\n"}
{"name":"inner_add_add_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (Inner.inner (HAdd.hAdd x y) (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (Inner.inner x x) (Inner.inner x y)) (Inner.inner y x)) (Inner.inner y y))","decl":"/-- Expand `âŸªx + y, x + yâŸ«` -/\ntheorem inner_add_add_self (x y : E) : âŸªx + y, x + yâŸ« = âŸªx, xâŸ« + âŸªx, yâŸ« + âŸªy, xâŸ« + âŸªy, yâŸ« := by\n  simp only [inner_add_left, inner_add_right]; ring\n\n"}
{"name":"real_inner_add_add_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Eq (Inner.inner (HAdd.hAdd x y) (HAdd.hAdd x y)) (HAdd.hAdd (HAdd.hAdd (Inner.inner x x) (HMul.hMul 2 (Inner.inner x y))) (Inner.inner y y))","decl":"/-- Expand `âŸªx + y, x + yâŸ«_â„` -/\ntheorem real_inner_add_add_self (x y : F) :\n    âŸªx + y, x + yâŸ«_â„ = âŸªx, xâŸ«_â„ + 2 * âŸªx, yâŸ«_â„ + âŸªy, yâŸ«_â„ := by\n  have : âŸªy, xâŸ«_â„ = âŸªx, yâŸ«_â„ := by rw [â† inner_conj_symm]; rfl\n  simp only [inner_add_add_self, this, add_left_inj]\n  ring\n\n-- Expand `âŸªx - y, x - yâŸ«`\n"}
{"name":"inner_sub_sub_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (Inner.inner (HSub.hSub x y) (HSub.hSub x y)) (HAdd.hAdd (HSub.hSub (HSub.hSub (Inner.inner x x) (Inner.inner x y)) (Inner.inner y x)) (Inner.inner y y))","decl":"theorem inner_sub_sub_self (x y : E) : âŸªx - y, x - yâŸ« = âŸªx, xâŸ« - âŸªx, yâŸ« - âŸªy, xâŸ« + âŸªy, yâŸ« := by\n  simp only [inner_sub_left, inner_sub_right]; ring\n\n"}
{"name":"real_inner_sub_sub_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Eq (Inner.inner (HSub.hSub x y) (HSub.hSub x y)) (HAdd.hAdd (HSub.hSub (Inner.inner x x) (HMul.hMul 2 (Inner.inner x y))) (Inner.inner y y))","decl":"/-- Expand `âŸªx - y, x - yâŸ«_â„` -/\ntheorem real_inner_sub_sub_self (x y : F) :\n    âŸªx - y, x - yâŸ«_â„ = âŸªx, xâŸ«_â„ - 2 * âŸªx, yâŸ«_â„ + âŸªy, yâŸ«_â„ := by\n  have : âŸªy, xâŸ«_â„ = âŸªx, yâŸ«_â„ := by rw [â† inner_conj_symm]; rfl\n  simp only [inner_sub_sub_self, this, add_left_inj]\n  ring\n\n"}
{"name":"parallelogram_law","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (HAdd.hAdd (Inner.inner (HAdd.hAdd x y) (HAdd.hAdd x y)) (Inner.inner (HSub.hSub x y) (HSub.hSub x y))) (HMul.hMul 2 (HAdd.hAdd (Inner.inner x x) (Inner.inner y y)))","decl":"/-- Parallelogram law -/\ntheorem parallelogram_law {x y : E} : âŸªx + y, x + yâŸ« + âŸªx - y, x - yâŸ« = 2 * (âŸªx, xâŸ« + âŸªy, yâŸ«) := by\n  simp only [inner_add_add_self, inner_sub_sub_self]\n  ring\n\n"}
{"name":"inner_mul_inner_self_le","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ LE.le (HMul.hMul (Norm.norm (Inner.inner x y)) (Norm.norm (Inner.inner y x))) (HMul.hMul (RCLike.re (Inner.inner x x)) (RCLike.re (Inner.inner y y)))","decl":"/-- **Cauchyâ€“Schwarz inequality**. -/\ntheorem inner_mul_inner_self_le (x y : E) : â€–âŸªx, yâŸ«â€– * â€–âŸªy, xâŸ«â€– â‰¤ re âŸªx, xâŸ« * re âŸªy, yâŸ« :=\n  letI cd : PreInnerProductSpace.Core ğ•œ E := PreInnerProductSpace.toCore\n  InnerProductSpace.Core.inner_mul_inner_self_le x y\n\n"}
{"name":"real_inner_mul_inner_self_le","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ LE.le (HMul.hMul (Inner.inner x y) (Inner.inner x y)) (HMul.hMul (Inner.inner x x) (Inner.inner y y))","decl":"/-- Cauchyâ€“Schwarz inequality for real inner products. -/\ntheorem real_inner_mul_inner_self_le (x y : F) : âŸªx, yâŸ«_â„ * âŸªx, yâŸ«_â„ â‰¤ âŸªx, xâŸ«_â„ * âŸªy, yâŸ«_â„ :=\n  calc\n    âŸªx, yâŸ«_â„ * âŸªx, yâŸ«_â„ â‰¤ â€–âŸªx, yâŸ«_â„â€– * â€–âŸªy, xâŸ«_â„â€– := by\n      rw [real_inner_comm y, â† norm_mul]\n      exact le_abs_self _\n    _ â‰¤ âŸªx, xâŸ«_â„ * âŸªy, yâŸ«_â„ := @inner_mul_inner_self_le â„ _ _ _ _ x y\n\n"}
{"name":"inner_self_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Iff (Eq (Inner.inner x x) 0) (Eq x 0)","decl":"@[simp]\ntheorem inner_self_eq_zero {x : E} : âŸªx, xâŸ« = 0 â†” x = 0 := by\n  rw [inner_self_eq_norm_sq_to_K, sq_eq_zero_iff, ofReal_eq_zero, norm_eq_zero]\n\n"}
{"name":"inner_self_ne_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Iff (Ne (Inner.inner x x) 0) (Ne x 0)","decl":"theorem inner_self_ne_zero {x : E} : âŸªx, xâŸ« â‰  0 â†” x â‰  0 :=\n  inner_self_eq_zero.not\n\n"}
{"name":"ext_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nh : âˆ€ (v : E), Eq (Inner.inner v x) (Inner.inner v y)\nâŠ¢ Eq x y","decl":"theorem ext_inner_left {x y : E} (h : âˆ€ v, âŸªv, xâŸ« = âŸªv, yâŸ«) : x = y := by\n  rw [â† sub_eq_zero, â† @inner_self_eq_zero ğ•œ, inner_sub_right, sub_eq_zero, h (x - y)]\n\n"}
{"name":"ext_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nh : âˆ€ (v : E), Eq (Inner.inner x v) (Inner.inner y v)\nâŠ¢ Eq x y","decl":"theorem ext_inner_right {x y : E} (h : âˆ€ v, âŸªx, vâŸ« = âŸªy, vâŸ«) : x = y := by\n  rw [â† sub_eq_zero, â† @inner_self_eq_zero ğ•œ, inner_sub_left, sub_eq_zero, h (x - y)]\n\n"}
{"name":"inner_self_nonpos","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Iff (LE.le (RCLike.re (Inner.inner x x)) 0) (Eq x 0)","decl":"@[simp]\ntheorem inner_self_nonpos {x : E} : re âŸªx, xâŸ« â‰¤ 0 â†” x = 0 := by\n  rw [â† norm_sq_eq_inner, (sq_nonneg _).le_iff_eq, sq_eq_zero_iff, norm_eq_zero]\n\n"}
{"name":"real_inner_self_nonpos","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx : F\nâŠ¢ Iff (LE.le (Inner.inner x x) 0) (Eq x 0)","decl":"open scoped InnerProductSpace in\ntheorem real_inner_self_nonpos {x : F} : âŸªx, xâŸ«_â„ â‰¤ 0 â†” x = 0 :=\n  @inner_self_nonpos â„ F _ _ _ x\n\n"}
{"name":"linearIndependent_of_ne_zero_of_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nv : Î¹ â†’ E\nhz : âˆ€ (i : Î¹), Ne (v i) 0\nho : Pairwise fun i j => Eq (Inner.inner (v i) (v j)) 0\nâŠ¢ LinearIndependent ğ•œ v","decl":"/-- A family of vectors is linearly independent if they are nonzero\nand orthogonal. -/\ntheorem linearIndependent_of_ne_zero_of_inner_eq_zero {Î¹ : Type*} {v : Î¹ â†’ E} (hz : âˆ€ i, v i â‰  0)\n    (ho : Pairwise fun i j => âŸªv i, v jâŸ« = 0) : LinearIndependent ğ•œ v := by\n  rw [linearIndependent_iff']\n  intro s g hg i hi\n  have h' : g i * inner (v i) (v i) = inner (v i) (âˆ‘ j âˆˆ s, g j â€¢ v j) := by\n    rw [inner_sum]\n    symm\n    convert Finset.sum_eq_single (Î² := ğ•œ) i ?_ ?_\n    Â· rw [inner_smul_right]\n    Â· intro j _hj hji\n      rw [inner_smul_right, ho hji.symm, mul_zero]\n    Â· exact fun h => False.elim (h hi)\n  simpa [hg, hz] using h'\n\n"}
{"name":"norm_eq_sqrt_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (Norm.norm x) (RCLike.re (Inner.inner x x)).sqrt","decl":"theorem norm_eq_sqrt_inner (x : E) : â€–xâ€– = âˆš(re âŸªx, xâŸ«) :=\n  calc\n    â€–xâ€– = âˆš(â€–xâ€– ^ 2) := (sqrt_sq (norm_nonneg _)).symm\n    _ = âˆš(re âŸªx, xâŸ«) := congr_arg _ (norm_sq_eq_inner _)\n\n"}
{"name":"norm_eq_sqrt_real_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx : F\nâŠ¢ Eq (Norm.norm x) (Inner.inner x x).sqrt","decl":"theorem norm_eq_sqrt_real_inner (x : F) : â€–xâ€– = âˆšâŸªx, xâŸ«_â„ :=\n  @norm_eq_sqrt_inner â„ _ _ _ _ x\n\n"}
{"name":"inner_self_eq_norm_mul_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (RCLike.re (Inner.inner x x)) (HMul.hMul (Norm.norm x) (Norm.norm x))","decl":"theorem inner_self_eq_norm_mul_norm (x : E) : re âŸªx, xâŸ« = â€–xâ€– * â€–xâ€– := by\n  rw [@norm_eq_sqrt_inner ğ•œ, â† sqrt_mul inner_self_nonneg (re âŸªx, xâŸ«),\n    sqrt_mul_self inner_self_nonneg]\n\n"}
{"name":"inner_self_eq_norm_sq","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (RCLike.re (Inner.inner x x)) (HPow.hPow (Norm.norm x) 2)","decl":"theorem inner_self_eq_norm_sq (x : E) : re âŸªx, xâŸ« = â€–xâ€– ^ 2 := by\n  rw [pow_two, inner_self_eq_norm_mul_norm]\n\n"}
{"name":"real_inner_self_eq_norm_mul_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx : F\nâŠ¢ Eq (Inner.inner x x) (HMul.hMul (Norm.norm x) (Norm.norm x))","decl":"theorem real_inner_self_eq_norm_mul_norm (x : F) : âŸªx, xâŸ«_â„ = â€–xâ€– * â€–xâ€– := by\n  have h := @inner_self_eq_norm_mul_norm â„ F _ _ _ x\n  simpa using h\n\n"}
{"name":"real_inner_self_eq_norm_sq","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx : F\nâŠ¢ Eq (Inner.inner x x) (HPow.hPow (Norm.norm x) 2)","decl":"theorem real_inner_self_eq_norm_sq (x : F) : âŸªx, xâŸ«_â„ = â€–xâ€– ^ 2 := by\n  rw [pow_two, real_inner_self_eq_norm_mul_norm]\n\n-- Porting note: this was present in mathlib3 but seemingly didn't do anything.\n-- variable (ğ•œ)\n\n"}
{"name":"norm_add_sq","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (HPow.hPow (Norm.norm (HAdd.hAdd x y)) 2) (HAdd.hAdd (HAdd.hAdd (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (RCLike.re (Inner.inner x y)))) (HPow.hPow (Norm.norm y) 2))","decl":"/-- Expand the square -/\ntheorem norm_add_sq (x y : E) : â€–x + yâ€– ^ 2 = â€–xâ€– ^ 2 + 2 * re âŸªx, yâŸ« + â€–yâ€– ^ 2 := by\n  repeat' rw [sq (M := â„), â† @inner_self_eq_norm_mul_norm ğ•œ]\n  rw [inner_add_add_self, two_mul]\n  simp only [add_assoc, add_left_inj, add_right_inj, AddMonoidHom.map_add]\n  rw [â† inner_conj_symm, conj_re]\n\n"}
{"name":"norm_add_pow_two","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (HPow.hPow (Norm.norm (HAdd.hAdd x y)) 2) (HAdd.hAdd (HAdd.hAdd (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (RCLike.re (Inner.inner x y)))) (HPow.hPow (Norm.norm y) 2))","decl":"alias norm_add_pow_two := norm_add_sq\n\n"}
{"name":"norm_add_sq_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Eq (HPow.hPow (Norm.norm (HAdd.hAdd x y)) 2) (HAdd.hAdd (HAdd.hAdd (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (Inner.inner x y))) (HPow.hPow (Norm.norm y) 2))","decl":"/-- Expand the square -/\ntheorem norm_add_sq_real (x y : F) : â€–x + yâ€– ^ 2 = â€–xâ€– ^ 2 + 2 * âŸªx, yâŸ«_â„ + â€–yâ€– ^ 2 := by\n  have h := @norm_add_sq â„ _ _ _ _ x y\n  simpa using h\n\n"}
{"name":"norm_add_pow_two_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Eq (HPow.hPow (Norm.norm (HAdd.hAdd x y)) 2) (HAdd.hAdd (HAdd.hAdd (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (Inner.inner x y))) (HPow.hPow (Norm.norm y) 2))","decl":"alias norm_add_pow_two_real := norm_add_sq_real\n\n"}
{"name":"norm_add_mul_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul 2 (RCLike.re (Inner.inner x y)))) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Expand the square -/\ntheorem norm_add_mul_self (x y : E) :\n    â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + 2 * re âŸªx, yâŸ« + â€–yâ€– * â€–yâ€– := by\n  repeat' rw [â† sq (M := â„)]\n  exact norm_add_sq _ _\n\n"}
{"name":"norm_add_mul_self_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Eq (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul 2 (Inner.inner x y))) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Expand the square -/\ntheorem norm_add_mul_self_real (x y : F) :\n    â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + 2 * âŸªx, yâŸ«_â„ + â€–yâ€– * â€–yâ€– := by\n  have h := @norm_add_mul_self â„ _ _ _ _ x y\n  simpa using h\n\n"}
{"name":"norm_sub_sq","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (HPow.hPow (Norm.norm (HSub.hSub x y)) 2) (HAdd.hAdd (HSub.hSub (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (RCLike.re (Inner.inner x y)))) (HPow.hPow (Norm.norm y) 2))","decl":"/-- Expand the square -/\ntheorem norm_sub_sq (x y : E) : â€–x - yâ€– ^ 2 = â€–xâ€– ^ 2 - 2 * re âŸªx, yâŸ« + â€–yâ€– ^ 2 := by\n  rw [sub_eq_add_neg, @norm_add_sq ğ•œ _ _ _ _ x (-y), norm_neg, inner_neg_right, map_neg, mul_neg,\n    sub_eq_add_neg]\n\n"}
{"name":"norm_sub_pow_two","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (HPow.hPow (Norm.norm (HSub.hSub x y)) 2) (HAdd.hAdd (HSub.hSub (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (RCLike.re (Inner.inner x y)))) (HPow.hPow (Norm.norm y) 2))","decl":"alias norm_sub_pow_two := norm_sub_sq\n\n"}
{"name":"norm_sub_sq_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Eq (HPow.hPow (Norm.norm (HSub.hSub x y)) 2) (HAdd.hAdd (HSub.hSub (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (Inner.inner x y))) (HPow.hPow (Norm.norm y) 2))","decl":"/-- Expand the square -/\ntheorem norm_sub_sq_real (x y : F) : â€–x - yâ€– ^ 2 = â€–xâ€– ^ 2 - 2 * âŸªx, yâŸ«_â„ + â€–yâ€– ^ 2 :=\n  @norm_sub_sq â„ _ _ _ _ _ _\n\n"}
{"name":"norm_sub_pow_two_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Eq (HPow.hPow (Norm.norm (HSub.hSub x y)) 2) (HAdd.hAdd (HSub.hSub (HPow.hPow (Norm.norm x) 2) (HMul.hMul 2 (Inner.inner x y))) (HPow.hPow (Norm.norm y) 2))","decl":"alias norm_sub_pow_two_real := norm_sub_sq_real\n\n"}
{"name":"norm_sub_mul_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y))) (HAdd.hAdd (HSub.hSub (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul 2 (RCLike.re (Inner.inner x y)))) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Expand the square -/\ntheorem norm_sub_mul_self (x y : E) :\n    â€–x - yâ€– * â€–x - yâ€– = â€–xâ€– * â€–xâ€– - 2 * re âŸªx, yâŸ« + â€–yâ€– * â€–yâ€– := by\n  repeat' rw [â† sq (M := â„)]\n  exact norm_sub_sq _ _\n\n"}
{"name":"norm_sub_mul_self_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Eq (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y))) (HAdd.hAdd (HSub.hSub (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul 2 (Inner.inner x y))) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Expand the square -/\ntheorem norm_sub_mul_self_real (x y : F) :\n    â€–x - yâ€– * â€–x - yâ€– = â€–xâ€– * â€–xâ€– - 2 * âŸªx, yâŸ«_â„ + â€–yâ€– * â€–yâ€– := by\n  have h := @norm_sub_mul_self â„ _ _ _ _ x y\n  simpa using h\n\n"}
{"name":"norm_inner_le_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ LE.le (Norm.norm (Inner.inner x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"/-- Cauchyâ€“Schwarz inequality with norm -/\ntheorem norm_inner_le_norm (x y : E) : â€–âŸªx, yâŸ«â€– â‰¤ â€–xâ€– * â€–yâ€– := by\n  rw [norm_eq_sqrt_inner (ğ•œ := ğ•œ) x, norm_eq_sqrt_inner (ğ•œ := ğ•œ) y]\n  letI : PreInnerProductSpace.Core ğ•œ E := PreInnerProductSpace.toCore\n  exact InnerProductSpace.Core.norm_inner_le_norm x y\n\n"}
{"name":"nnnorm_inner_le_nnnorm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ LE.le (NNNorm.nnnorm (Inner.inner x y)) (HMul.hMul (NNNorm.nnnorm x) (NNNorm.nnnorm y))","decl":"theorem nnnorm_inner_le_nnnorm (x y : E) : â€–âŸªx, yâŸ«â€–â‚Š â‰¤ â€–xâ€–â‚Š * â€–yâ€–â‚Š :=\n  norm_inner_le_norm x y\n\n"}
{"name":"re_inner_le_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ LE.le (RCLike.re (Inner.inner x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"theorem re_inner_le_norm (x y : E) : re âŸªx, yâŸ« â‰¤ â€–xâ€– * â€–yâ€– :=\n  le_trans (re_le_norm (inner x y)) (norm_inner_le_norm x y)\n\n"}
{"name":"abs_real_inner_le_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ LE.le (abs (Inner.inner x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"/-- Cauchyâ€“Schwarz inequality with norm -/\ntheorem abs_real_inner_le_norm (x y : F) : |âŸªx, yâŸ«_â„| â‰¤ â€–xâ€– * â€–yâ€– :=\n  (Real.norm_eq_abs _).ge.trans (norm_inner_le_norm x y)\n\n"}
{"name":"real_inner_le_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ LE.le (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"/-- Cauchyâ€“Schwarz inequality with norm -/\ntheorem real_inner_le_norm (x y : F) : âŸªx, yâŸ«_â„ â‰¤ â€–xâ€– * â€–yâ€– :=\n  le_trans (le_abs_self _) (abs_real_inner_le_norm _ _)\n\n"}
{"name":"inner_eq_zero_of_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nh : Eq (Norm.norm x) 0\nâŠ¢ Eq (Inner.inner x y) 0","decl":"lemma inner_eq_zero_of_left {x : E} (y : E) (h : â€–xâ€– = 0) : âŸªx, yâŸ«_ğ•œ = 0 := by\n  rw [â† norm_eq_zero]\n  refine le_antisymm ?_ (by positivity)\n  exact norm_inner_le_norm _ _ |>.trans <| by simp [h]\n\n"}
{"name":"inner_eq_zero_of_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nh : Eq (Norm.norm y) 0\nâŠ¢ Eq (Inner.inner x y) 0","decl":"lemma inner_eq_zero_of_right (x : E) {y : E} (h : â€–yâ€– = 0) : âŸªx, yâŸ«_ğ•œ = 0 := by\n  rw [inner_eq_zero_symm, inner_eq_zero_of_left _ h]\n\n"}
{"name":"parallelogram_law_with_norm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (HAdd.hAdd (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y)))) (HMul.hMul 2 (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y))))","decl":"include ğ•œ in\ntheorem parallelogram_law_with_norm (x y : E) :\n    â€–x + yâ€– * â€–x + yâ€– + â€–x - yâ€– * â€–x - yâ€– = 2 * (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) := by\n  simp only [â† @inner_self_eq_norm_mul_norm ğ•œ]\n  rw [â† re.map_add, parallelogram_law, two_mul, two_mul]\n  simp only [re.map_add]\n\n"}
{"name":"parallelogram_law_with_nnnorm","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (HAdd.hAdd (HMul.hMul (NNNorm.nnnorm (HAdd.hAdd x y)) (NNNorm.nnnorm (HAdd.hAdd x y))) (HMul.hMul (NNNorm.nnnorm (HSub.hSub x y)) (NNNorm.nnnorm (HSub.hSub x y)))) (HMul.hMul 2 (HAdd.hAdd (HMul.hMul (NNNorm.nnnorm x) (NNNorm.nnnorm x)) (HMul.hMul (NNNorm.nnnorm y) (NNNorm.nnnorm y))))","decl":"include ğ•œ in\ntheorem parallelogram_law_with_nnnorm (x y : E) :\n    â€–x + yâ€–â‚Š * â€–x + yâ€–â‚Š + â€–x - yâ€–â‚Š * â€–x - yâ€–â‚Š = 2 * (â€–xâ€–â‚Š * â€–xâ€–â‚Š + â€–yâ€–â‚Š * â€–yâ€–â‚Š) :=\n  Subtype.ext <| parallelogram_law_with_norm ğ•œ x y\n\n"}
{"name":"re_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (RCLike.re (Inner.inner x y)) (HDiv.hDiv (HSub.hSub (HSub.hSub (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HMul.hMul (Norm.norm x) (Norm.norm x))) (HMul.hMul (Norm.norm y) (Norm.norm y))) 2)","decl":"/-- Polarization identity: The real part of the inner product, in terms of the norm. -/\ntheorem re_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two (x y : E) :\n    re âŸªx, yâŸ« = (â€–x + yâ€– * â€–x + yâ€– - â€–xâ€– * â€–xâ€– - â€–yâ€– * â€–yâ€–) / 2 := by\n  rw [@norm_add_mul_self ğ•œ]\n  ring\n\n"}
{"name":"re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (RCLike.re (Inner.inner x y)) (HDiv.hDiv (HSub.hSub (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y))) (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y)))) 2)","decl":"/-- Polarization identity: The real part of the inner product, in terms of the norm. -/\ntheorem re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two (x y : E) :\n    re âŸªx, yâŸ« = (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– - â€–x - yâ€– * â€–x - yâ€–) / 2 := by\n  rw [@norm_sub_mul_self ğ•œ]\n  ring\n\n"}
{"name":"re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (RCLike.re (Inner.inner x y)) (HDiv.hDiv (HSub.hSub (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y)))) 4)","decl":"/-- Polarization identity: The real part of the inner product, in terms of the norm. -/\ntheorem re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four (x y : E) :\n    re âŸªx, yâŸ« = (â€–x + yâ€– * â€–x + yâ€– - â€–x - yâ€– * â€–x - yâ€–) / 4 := by\n  rw [@norm_add_mul_self ğ•œ, @norm_sub_mul_self ğ•œ]\n  ring\n\n"}
{"name":"im_inner_eq_norm_sub_i_smul_mul_self_sub_norm_add_i_smul_mul_self_div_four","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (RCLike.im (Inner.inner x y)) (HDiv.hDiv (HSub.hSub (HMul.hMul (Norm.norm (HSub.hSub x (HSMul.hSMul RCLike.I y))) (Norm.norm (HSub.hSub x (HSMul.hSMul RCLike.I y)))) (HMul.hMul (Norm.norm (HAdd.hAdd x (HSMul.hSMul RCLike.I y))) (Norm.norm (HAdd.hAdd x (HSMul.hSMul RCLike.I y))))) 4)","decl":"/-- Polarization identity: The imaginary part of the inner product, in terms of the norm. -/\ntheorem im_inner_eq_norm_sub_i_smul_mul_self_sub_norm_add_i_smul_mul_self_div_four (x y : E) :\n    im âŸªx, yâŸ« = (â€–x - IK â€¢ yâ€– * â€–x - IK â€¢ yâ€– - â€–x + IK â€¢ yâ€– * â€–x + IK â€¢ yâ€–) / 4 := by\n  simp only [@norm_add_mul_self ğ•œ, @norm_sub_mul_self ğ•œ, inner_smul_right, I_mul_re]\n  ring\n\n"}
{"name":"inner_eq_sum_norm_sq_div_four","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (Inner.inner x y) (HDiv.hDiv (HAdd.hAdd (HSub.hSub (HPow.hPow (â†‘(Norm.norm (HAdd.hAdd x y))) 2) (HPow.hPow (â†‘(Norm.norm (HSub.hSub x y))) 2)) (HMul.hMul (HSub.hSub (HPow.hPow (â†‘(Norm.norm (HSub.hSub x (HSMul.hSMul RCLike.I y)))) 2) (HPow.hPow (â†‘(Norm.norm (HAdd.hAdd x (HSMul.hSMul RCLike.I y)))) 2)) RCLike.I)) 4)","decl":"/-- Polarization identity: The inner product, in terms of the norm. -/\ntheorem inner_eq_sum_norm_sq_div_four (x y : E) :\n    âŸªx, yâŸ« = ((â€–x + yâ€– : ğ•œ) ^ 2 - (â€–x - yâ€– : ğ•œ) ^ 2 +\n              ((â€–x - IK â€¢ yâ€– : ğ•œ) ^ 2 - (â€–x + IK â€¢ yâ€– : ğ•œ) ^ 2) * IK) / 4 := by\n  rw [â† re_add_im âŸªx, yâŸ«, re_inner_eq_norm_add_mul_self_sub_norm_sub_mul_self_div_four,\n    im_inner_eq_norm_sub_i_smul_mul_self_sub_norm_add_i_smul_mul_self_div_four]\n  push_cast\n  simp only [sq, â† mul_div_right_comm, â† add_div]\n\n-- See note [lower instance priority]\n"}
{"name":"InnerProductSpace.toUniformConvexSpace","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœ : SeminormedAddCommGroup F\nâŠ¢ UniformConvexSpace F","decl":"instance (priority := 100) InnerProductSpace.toUniformConvexSpace : UniformConvexSpace F :=\n  âŸ¨fun Îµ hÎµ => by\n    refine\n      âŸ¨2 - âˆš(4 - Îµ ^ 2), sub_pos_of_lt <| (sqrt_lt' zero_lt_two).2 ?_, fun x hx y hy hxy => ?_âŸ©\n    Â· norm_num\n      exact pow_pos hÎµ _\n    rw [sub_sub_cancel]\n    refine le_sqrt_of_sq_le ?_\n    rw [sq, eq_sub_iff_add_eq.2 (parallelogram_law_with_norm â„ x y), â† sq â€–x - yâ€–, hx, hy]\n    ring_nf\n    gcongrâŸ©\n\n"}
{"name":"real_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Eq (Inner.inner x y) (HDiv.hDiv (HSub.hSub (HSub.hSub (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HMul.hMul (Norm.norm x) (Norm.norm x))) (HMul.hMul (Norm.norm y) (Norm.norm y))) 2)","decl":"/-- Polarization identity: The real inner product, in terms of the norm. -/\ntheorem real_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two (x y : F) :\n    âŸªx, yâŸ«_â„ = (â€–x + yâ€– * â€–x + yâ€– - â€–xâ€– * â€–xâ€– - â€–yâ€– * â€–yâ€–) / 2 :=\n  re_to_real.symm.trans <|\n    re_inner_eq_norm_add_mul_self_sub_norm_mul_self_sub_norm_mul_self_div_two x y\n\n"}
{"name":"real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Eq (Inner.inner x y) (HDiv.hDiv (HSub.hSub (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y))) (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y)))) 2)","decl":"/-- Polarization identity: The real inner product, in terms of the norm. -/\ntheorem real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two (x y : F) :\n    âŸªx, yâŸ«_â„ = (â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– - â€–x - yâ€– * â€–x - yâ€–) / 2 :=\n  re_to_real.symm.trans <|\n    re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two x y\n\n"}
{"name":"norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Iff (Eq (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y)))) (Eq (Inner.inner x y) 0)","decl":"/-- Pythagorean theorem, if-and-only-if vector inner product form. -/\ntheorem norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero (x y : F) :\n    â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” âŸªx, yâŸ«_â„ = 0 := by\n  rw [@norm_add_mul_self â„, add_right_cancel_iff, add_right_eq_self, mul_eq_zero]\n  norm_num\n\n"}
{"name":"norm_add_eq_sqrt_iff_real_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Iff (Eq (Norm.norm (HAdd.hAdd x y)) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y))).sqrt) (Eq (Inner.inner x y) 0)","decl":"/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem norm_add_eq_sqrt_iff_real_inner_eq_zero {x y : F} :\n    â€–x + yâ€– = âˆš(â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” âŸªx, yâŸ«_â„ = 0 := by\n  rw [â† norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero, eq_comm, sqrt_eq_iff_mul_self_eq,\n    eq_comm] <;> positivity\n\n"}
{"name":"norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nh : Eq (Inner.inner x y) 0\nâŠ¢ Eq (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Pythagorean theorem, vector inner product form. -/\ntheorem norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero (x y : E) (h : âŸªx, yâŸ« = 0) :\n    â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– := by\n  rw [@norm_add_mul_self ğ•œ, add_right_cancel_iff, add_right_eq_self, mul_eq_zero]\n  apply Or.inr\n  simp only [h, zero_re']\n\n"}
{"name":"norm_add_sq_eq_norm_sq_add_norm_sq_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nh : Eq (Inner.inner x y) 0\nâŠ¢ Eq (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Pythagorean theorem, vector inner product form. -/\ntheorem norm_add_sq_eq_norm_sq_add_norm_sq_real {x y : F} (h : âŸªx, yâŸ«_â„ = 0) :\n    â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :=\n  (norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero x y).2 h\n\n"}
{"name":"norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Iff (Eq (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y))) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y)))) (Eq (Inner.inner x y) 0)","decl":"/-- Pythagorean theorem, subtracting vectors, if-and-only-if vector\ninner product form. -/\ntheorem norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero (x y : F) :\n    â€–x - yâ€– * â€–x - yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– â†” âŸªx, yâŸ«_â„ = 0 := by\n  rw [@norm_sub_mul_self â„, add_right_cancel_iff, sub_eq_add_neg, add_right_eq_self, neg_eq_zero,\n    mul_eq_zero]\n  norm_num\n\n"}
{"name":"norm_sub_eq_sqrt_iff_real_inner_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Iff (Eq (Norm.norm (HSub.hSub x y)) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y))).sqrt) (Eq (Inner.inner x y) 0)","decl":"/-- Pythagorean theorem, subtracting vectors, if-and-if vector inner product form using square\nroots. -/\ntheorem norm_sub_eq_sqrt_iff_real_inner_eq_zero {x y : F} :\n    â€–x - yâ€– = âˆš(â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€–) â†” âŸªx, yâŸ«_â„ = 0 := by\n  rw [â† norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero, eq_comm, sqrt_eq_iff_mul_self_eq,\n    eq_comm] <;> positivity\n\n"}
{"name":"norm_sub_sq_eq_norm_sq_add_norm_sq_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nh : Eq (Inner.inner x y) 0\nâŠ¢ Eq (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y))) (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y)))","decl":"/-- Pythagorean theorem, subtracting vectors, vector inner product\nform. -/\ntheorem norm_sub_sq_eq_norm_sq_add_norm_sq_real {x y : F} (h : âŸªx, yâŸ«_â„ = 0) :\n    â€–x - yâ€– * â€–x - yâ€– = â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– :=\n  (norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero x y).2 h\n\n"}
{"name":"real_inner_add_sub_eq_zero_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Iff (Eq (Inner.inner (HAdd.hAdd x y) (HSub.hSub x y)) 0) (Eq (Norm.norm x) (Norm.norm y))","decl":"/-- The sum and difference of two vectors are orthogonal if and only\nif they have the same norm. -/\ntheorem real_inner_add_sub_eq_zero_iff (x y : F) : âŸªx + y, x - yâŸ«_â„ = 0 â†” â€–xâ€– = â€–yâ€– := by\n  conv_rhs => rw [â† mul_self_inj_of_nonneg (norm_nonneg _) (norm_nonneg _)]\n  simp only [â† @inner_self_eq_norm_mul_norm â„, inner_add_left, inner_sub_right, real_inner_comm y x,\n    sub_eq_zero, re_to_real]\n  constructor\n  Â· intro h\n    rw [add_comm] at h\n    linarith\n  Â· intro h\n    linarith\n\n"}
{"name":"norm_sub_eq_norm_add","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nv w : E\nh : Eq (Inner.inner v w) 0\nâŠ¢ Eq (Norm.norm (HSub.hSub w v)) (Norm.norm (HAdd.hAdd w v))","decl":"/-- Given two orthogonal vectors, their sum and difference have equal norms. -/\ntheorem norm_sub_eq_norm_add {v w : E} (h : âŸªv, wâŸ« = 0) : â€–w - vâ€– = â€–w + vâ€– := by\n  rw [â† mul_self_inj_of_nonneg (norm_nonneg _) (norm_nonneg _)]\n  simp only [h, â† @inner_self_eq_norm_mul_norm ğ•œ, sub_neg_eq_add, sub_zero, map_sub, zero_re',\n    zero_sub, add_zero, map_add, inner_add_right, inner_sub_left, inner_sub_right, inner_re_symm,\n    zero_add]\n\n"}
{"name":"abs_real_inner_div_norm_mul_norm_le_one","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ LE.le (abs (HDiv.hDiv (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y)))) 1","decl":"/-- The real inner product of two vectors, divided by the product of their\nnorms, has absolute value at most 1. -/\ntheorem abs_real_inner_div_norm_mul_norm_le_one (x y : F) : |âŸªx, yâŸ«_â„ / (â€–xâ€– * â€–yâ€–)| â‰¤ 1 := by\n  rw [abs_div, abs_mul, abs_norm, abs_norm]\n  exact div_le_one_of_leâ‚€ (abs_real_inner_le_norm x y) (by positivity)\n\n"}
{"name":"real_inner_smul_self_left","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx : F\nr : Real\nâŠ¢ Eq (Inner.inner (HSMul.hSMul r x) x) (HMul.hMul r (HMul.hMul (Norm.norm x) (Norm.norm x)))","decl":"/-- The inner product of a vector with a multiple of itself. -/\ntheorem real_inner_smul_self_left (x : F) (r : â„) : âŸªr â€¢ x, xâŸ«_â„ = r * (â€–xâ€– * â€–xâ€–) := by\n  rw [real_inner_smul_left, â† real_inner_self_eq_norm_mul_norm]\n\n"}
{"name":"real_inner_smul_self_right","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx : F\nr : Real\nâŠ¢ Eq (Inner.inner x (HSMul.hSMul r x)) (HMul.hMul r (HMul.hMul (Norm.norm x) (Norm.norm x)))","decl":"/-- The inner product of a vector with a multiple of itself. -/\ntheorem real_inner_smul_self_right (x : F) (r : â„) : âŸªx, r â€¢ xâŸ«_â„ = r * (â€–xâ€– * â€–xâ€–) := by\n  rw [inner_smul_right, â† real_inner_self_eq_norm_mul_norm]\n\n"}
{"name":"isBoundedBilinearMap_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : IsScalarTower Real ğ•œ E\nâŠ¢ IsBoundedBilinearMap Real fun p => Inner.inner p.1 p.2","decl":"/-- When an inner product space `E` over `ğ•œ` is considered as a real normed space, its inner\nproduct satisfies `IsBoundedBilinearMap`.\n\nIn order to state these results, we need a `NormedSpace â„ E` instance. We will later establish\nsuch an instance by restriction-of-scalars, `InnerProductSpace.rclikeToReal ğ•œ E`, but this\ninstance may be not definitionally equal to some other â€œnaturalâ€ instance. So, we assume\n`[NormedSpace â„ E]`.\n-/\ntheorem _root_.isBoundedBilinearMap_inner [NormedSpace â„ E] [IsScalarTower â„ ğ•œ E] :\n    IsBoundedBilinearMap â„ fun p : E Ã— E => âŸªp.1, p.2âŸ« :=\n  { add_left := inner_add_left\n    smul_left := fun r x y => by\n      simp only [â† algebraMap_smul ğ•œ r x, algebraMap_eq_ofReal, inner_smul_real_left]\n    add_right := inner_add_right\n    smul_right := fun r x y => by\n      simp only [â† algebraMap_smul ğ•œ r y, algebraMap_eq_ofReal, inner_smul_real_right]\n    bound :=\n      âŸ¨1, zero_lt_one, fun x y => by\n        rw [one_mul]\n        exact norm_inner_le_norm x yâŸ© }\n\n"}
{"name":"inner_sum_smul_sum_smul_of_sum_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nÎ¹â‚ : Type u_4\nsâ‚ : Finset Î¹â‚\nwâ‚ : Î¹â‚ â†’ Real\nvâ‚ : Î¹â‚ â†’ F\nhâ‚ : Eq (sâ‚.sum fun i => wâ‚ i) 0\nÎ¹â‚‚ : Type u_5\nsâ‚‚ : Finset Î¹â‚‚\nwâ‚‚ : Î¹â‚‚ â†’ Real\nvâ‚‚ : Î¹â‚‚ â†’ F\nhâ‚‚ : Eq (sâ‚‚.sum fun i => wâ‚‚ i) 0\nâŠ¢ Eq (Inner.inner (sâ‚.sum fun iâ‚ => HSMul.hSMul (wâ‚ iâ‚) (vâ‚ iâ‚)) (sâ‚‚.sum fun iâ‚‚ => HSMul.hSMul (wâ‚‚ iâ‚‚) (vâ‚‚ iâ‚‚))) (HDiv.hDiv (Neg.neg (sâ‚.sum fun iâ‚ => sâ‚‚.sum fun iâ‚‚ => HMul.hMul (HMul.hMul (wâ‚ iâ‚) (wâ‚‚ iâ‚‚)) (HMul.hMul (Norm.norm (HSub.hSub (vâ‚ iâ‚) (vâ‚‚ iâ‚‚))) (Norm.norm (HSub.hSub (vâ‚ iâ‚) (vâ‚‚ iâ‚‚)))))) 2)","decl":"/-- The inner product of two weighted sums, where the weights in each\nsum add to 0, in terms of the norms of pairwise differences. -/\ntheorem inner_sum_smul_sum_smul_of_sum_eq_zero {Î¹â‚ : Type*} {sâ‚ : Finset Î¹â‚} {wâ‚ : Î¹â‚ â†’ â„}\n    (vâ‚ : Î¹â‚ â†’ F) (hâ‚ : âˆ‘ i âˆˆ sâ‚, wâ‚ i = 0) {Î¹â‚‚ : Type*} {sâ‚‚ : Finset Î¹â‚‚} {wâ‚‚ : Î¹â‚‚ â†’ â„}\n    (vâ‚‚ : Î¹â‚‚ â†’ F) (hâ‚‚ : âˆ‘ i âˆˆ sâ‚‚, wâ‚‚ i = 0) :\n    âŸªâˆ‘ iâ‚ âˆˆ sâ‚, wâ‚ iâ‚ â€¢ vâ‚ iâ‚, âˆ‘ iâ‚‚ âˆˆ sâ‚‚, wâ‚‚ iâ‚‚ â€¢ vâ‚‚ iâ‚‚âŸ«_â„ =\n      (-âˆ‘ iâ‚ âˆˆ sâ‚, âˆ‘ iâ‚‚ âˆˆ sâ‚‚, wâ‚ iâ‚ * wâ‚‚ iâ‚‚ * (â€–vâ‚ iâ‚ - vâ‚‚ iâ‚‚â€– * â€–vâ‚ iâ‚ - vâ‚‚ iâ‚‚â€–)) / 2 := by\n  simp_rw [sum_inner, inner_sum, real_inner_smul_left, real_inner_smul_right,\n    real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two, â† div_sub_div_same,\n    â† div_add_div_same, mul_sub_left_distrib, left_distrib, Finset.sum_sub_distrib,\n    Finset.sum_add_distrib, â† Finset.mul_sum, â† Finset.sum_mul, hâ‚, hâ‚‚, zero_mul,\n    mul_zero, Finset.sum_const_zero, zero_add, zero_sub, Finset.mul_sum, neg_div,\n    Finset.sum_div, mul_div_assoc, mul_assoc]\n\n"}
{"name":"dist_div_norm_sq_smul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nhx : Ne x 0\nhy : Ne y 0\nR : Real\nâŠ¢ Eq (Dist.dist (HSMul.hSMul (HPow.hPow (HDiv.hDiv R (Norm.norm x)) 2) x) (HSMul.hSMul (HPow.hPow (HDiv.hDiv R (Norm.norm y)) 2) y)) (HMul.hMul (HDiv.hDiv (HPow.hPow R 2) (HMul.hMul (Norm.norm x) (Norm.norm y))) (Dist.dist x y))","decl":"/-- Formula for the distance between the images of two nonzero points under an inversion with center\nzero. See also `EuclideanGeometry.dist_inversion_inversion` for inversions around a general\npoint. -/\ntheorem dist_div_norm_sq_smul {x y : F} (hx : x â‰  0) (hy : y â‰  0) (R : â„) :\n    dist ((R / â€–xâ€–) ^ 2 â€¢ x) ((R / â€–yâ€–) ^ 2 â€¢ y) = R ^ 2 / (â€–xâ€– * â€–yâ€–) * dist x y :=\n  calc\n    dist ((R / â€–xâ€–) ^ 2 â€¢ x) ((R / â€–yâ€–) ^ 2 â€¢ y) =\n        âˆš(â€–(R / â€–xâ€–) ^ 2 â€¢ x - (R / â€–yâ€–) ^ 2 â€¢ yâ€– ^ 2) := by\n      rw [dist_eq_norm, sqrt_sq (norm_nonneg _)]\n    _ = âˆš((R ^ 2 / (â€–xâ€– * â€–yâ€–)) ^ 2 * â€–x - yâ€– ^ 2) :=\n      congr_arg sqrt <| by\n        field_simp [sq, norm_sub_mul_self_real, norm_smul, real_inner_smul_left, inner_smul_right,\n          Real.norm_of_nonneg (mul_self_nonneg _)]\n        ring\n    _ = R ^ 2 / (â€–xâ€– * â€–yâ€–) * dist x y := by\n      rw [sqrt_mul, sqrt_sq, sqrt_sq, dist_eq_norm] <;> positivity\n\n"}
{"name":"norm_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nr : ğ•œ\nhx : Ne x 0\nhr : Ne r 0\nâŠ¢ Eq (HDiv.hDiv (Norm.norm (Inner.inner x (HSMul.hSMul r x))) (HMul.hMul (Norm.norm x) (Norm.norm (HSMul.hSMul r x)))) 1","decl":"/-- The inner product of a nonzero vector with a nonzero multiple of\nitself, divided by the product of their norms, has absolute value\n1. -/\ntheorem norm_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul {x : E} {r : ğ•œ} (hx : x â‰  0)\n    (hr : r â‰  0) : â€–âŸªx, r â€¢ xâŸ«â€– / (â€–xâ€– * â€–r â€¢ xâ€–) = 1 := by\n  have hx' : â€–xâ€– â‰  0 := by simp [hx]\n  have hr' : â€–râ€– â‰  0 := by simp [hr]\n  rw [inner_smul_right, norm_mul, â† inner_self_re_eq_norm, inner_self_eq_norm_mul_norm, norm_smul]\n  rw [â† mul_assoc, â† div_div, mul_div_cancel_rightâ‚€ _ hx', â† div_div, mul_comm,\n    mul_div_cancel_rightâ‚€ _ hr', div_self hx']\n\n"}
{"name":"abs_real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx : F\nr : Real\nhx : Ne x 0\nhr : Ne r 0\nâŠ¢ Eq (HDiv.hDiv (abs (Inner.inner x (HSMul.hSMul r x))) (HMul.hMul (Norm.norm x) (Norm.norm (HSMul.hSMul r x)))) 1","decl":"/-- The inner product of a nonzero vector with a nonzero multiple of\nitself, divided by the product of their norms, has absolute value\n1. -/\ntheorem abs_real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul {x : F} {r : â„}\n    (hx : x â‰  0) (hr : r â‰  0) : |âŸªx, r â€¢ xâŸ«_â„| / (â€–xâ€– * â€–r â€¢ xâ€–) = 1 :=\n  norm_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul hx hr\n\n"}
{"name":"real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx : F\nr : Real\nhx : Ne x 0\nhr : LT.lt 0 r\nâŠ¢ Eq (HDiv.hDiv (Inner.inner x (HSMul.hSMul r x)) (HMul.hMul (Norm.norm x) (Norm.norm (HSMul.hSMul r x)))) 1","decl":"/-- The inner product of a nonzero vector with a positive multiple of\nitself, divided by the product of their norms, has value 1. -/\ntheorem real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul {x : F} {r : â„} (hx : x â‰  0)\n    (hr : 0 < r) : âŸªx, r â€¢ xâŸ«_â„ / (â€–xâ€– * â€–r â€¢ xâ€–) = 1 := by\n  rw [real_inner_smul_self_right, norm_smul, Real.norm_eq_abs, â† mul_assoc â€–xâ€–, mul_comm _ |r|,\n    mul_assoc, abs_of_nonneg hr.le, div_self]\n  exact mul_ne_zero hr.ne' (mul_self_ne_zero.2 (norm_ne_zero_iff.2 hx))\n\n"}
{"name":"real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx : F\nr : Real\nhx : Ne x 0\nhr : LT.lt r 0\nâŠ¢ Eq (HDiv.hDiv (Inner.inner x (HSMul.hSMul r x)) (HMul.hMul (Norm.norm x) (Norm.norm (HSMul.hSMul r x)))) (-1)","decl":"/-- The inner product of a nonzero vector with a negative multiple of\nitself, divided by the product of their norms, has value -1. -/\ntheorem real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul {x : F} {r : â„} (hx : x â‰  0)\n    (hr : r < 0) : âŸªx, r â€¢ xâŸ«_â„ / (â€–xâ€– * â€–r â€¢ xâ€–) = -1 := by\n  rw [real_inner_smul_self_right, norm_smul, Real.norm_eq_abs, â† mul_assoc â€–xâ€–, mul_comm _ |r|,\n    mul_assoc, abs_of_neg hr, neg_mul, div_neg_eq_neg_div, div_self]\n  exact mul_ne_zero hr.ne (mul_self_ne_zero.2 (norm_ne_zero_iff.2 hx))\n\n"}
{"name":"norm_inner_eq_norm_tfae","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ (List.cons (Eq (Norm.norm (Inner.inner x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))) (List.cons (Or (Eq x 0) (Eq y (HSMul.hSMul (HDiv.hDiv (Inner.inner x y) (Inner.inner x x)) x))) (List.cons (Or (Eq x 0) (Exists fun r => Eq y (HSMul.hSMul r x))) (List.cons (Or (Eq x 0) (Membership.mem (Submodule.span ğ•œ (Singleton.singleton x)) y)) List.nil)))).TFAE","decl":"theorem norm_inner_eq_norm_tfae (x y : E) :\n    List.TFAE [â€–âŸªx, yâŸ«â€– = â€–xâ€– * â€–yâ€–,\n      x = 0 âˆ¨ y = (âŸªx, yâŸ« / âŸªx, xâŸ«) â€¢ x,\n      x = 0 âˆ¨ âˆƒ r : ğ•œ, y = r â€¢ x,\n      x = 0 âˆ¨ y âˆˆ ğ•œ âˆ™ x] := by\n  tfae_have 1 â†’ 2 := by\n    refine fun h => or_iff_not_imp_left.2 fun hxâ‚€ => ?_\n    have : â€–xâ€– ^ 2 â‰  0 := pow_ne_zero _ (norm_ne_zero_iff.2 hxâ‚€)\n    rw [â† sq_eq_sqâ‚€, mul_pow, â† mul_right_inj' this, eq_comm, â† sub_eq_zero, â† mul_sub] at h <;>\n      try positivity\n    simp only [@norm_sq_eq_inner ğ•œ] at h\n    letI : InnerProductSpace.Core ğ•œ E := InnerProductSpace.toCore\n    erw [â† InnerProductSpace.Core.cauchy_schwarz_aux (ğ•œ := ğ•œ) (F := E),\n      InnerProductSpace.Core.normSq_eq_zero, sub_eq_zero] at h\n    rw [div_eq_inv_mul, mul_smul, h, inv_smul_smulâ‚€]\n    rwa [inner_self_ne_zero]\n  tfae_have 2 â†’ 3 := fun h => h.imp_right fun h' => âŸ¨_, h'âŸ©\n  tfae_have 3 â†’ 1 := by\n    rintro (rfl | âŸ¨r, rflâŸ©) <;>\n    simp [inner_smul_right, norm_smul, inner_self_eq_norm_sq_to_K, inner_self_eq_norm_mul_norm,\n      sq, mul_left_comm]\n  tfae_have 3 â†” 4 := by simp only [Submodule.mem_span_singleton, eq_comm]\n  tfae_finish\n\n"}
{"name":"norm_inner_eq_norm_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nhxâ‚€ : Ne x 0\nhyâ‚€ : Ne y 0\nâŠ¢ Iff (Eq (Norm.norm (Inner.inner x y)) (HMul.hMul (Norm.norm x) (Norm.norm y))) (Exists fun r => And (Ne r 0) (Eq y (HSMul.hSMul r x)))","decl":"/-- If the inner product of two vectors is equal to the product of their norms, then the two vectors\nare multiples of each other. One form of the equality case for Cauchy-Schwarz.\nCompare `inner_eq_norm_mul_iff`, which takes the stronger hypothesis `âŸªx, yâŸ« = â€–xâ€– * â€–yâ€–`. -/\ntheorem norm_inner_eq_norm_iff {x y : E} (hxâ‚€ : x â‰  0) (hyâ‚€ : y â‰  0) :\n    â€–âŸªx, yâŸ«â€– = â€–xâ€– * â€–yâ€– â†” âˆƒ r : ğ•œ, r â‰  0 âˆ§ y = r â€¢ x :=\n  calc\n    â€–âŸªx, yâŸ«â€– = â€–xâ€– * â€–yâ€– â†” x = 0 âˆ¨ âˆƒ r : ğ•œ, y = r â€¢ x :=\n      (@norm_inner_eq_norm_tfae ğ•œ _ _ _ _ x y).out 0 2\n    _ â†” âˆƒ r : ğ•œ, y = r â€¢ x := or_iff_right hxâ‚€\n    _ â†” âˆƒ r : ğ•œ, r â‰  0 âˆ§ y = r â€¢ x :=\n      âŸ¨fun âŸ¨r, hâŸ© => âŸ¨r, fun hrâ‚€ => hyâ‚€ <| h.symm â–¸ smul_eq_zero.2 <| Or.inl hrâ‚€, hâŸ©,\n        fun âŸ¨r, _hrâ‚€, hâŸ© => âŸ¨r, hâŸ©âŸ©\n\n"}
{"name":"norm_inner_div_norm_mul_norm_eq_one_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Iff (Eq (Norm.norm (HDiv.hDiv (Inner.inner x y) (HMul.hMul â†‘(Norm.norm x) â†‘(Norm.norm y)))) 1) (And (Ne x 0) (Exists fun r => And (Ne r 0) (Eq y (HSMul.hSMul r x))))","decl":"/-- The inner product of two vectors, divided by the product of their\nnorms, has absolute value 1 if and only if they are nonzero and one is\na multiple of the other. One form of equality case for Cauchy-Schwarz. -/\ntheorem norm_inner_div_norm_mul_norm_eq_one_iff (x y : E) :\n    â€–âŸªx, yâŸ« / (â€–xâ€– * â€–yâ€–)â€– = 1 â†” x â‰  0 âˆ§ âˆƒ r : ğ•œ, r â‰  0 âˆ§ y = r â€¢ x := by\n  constructor\n  Â· intro h\n    have hxâ‚€ : x â‰  0 := fun hâ‚€ => by simp [hâ‚€] at h\n    have hyâ‚€ : y â‰  0 := fun hâ‚€ => by simp [hâ‚€] at h\n    refine âŸ¨hxâ‚€, (norm_inner_eq_norm_iff hxâ‚€ hyâ‚€).1 <| eq_of_div_eq_one ?_âŸ©\n    simpa using h\n  Â· rintro âŸ¨hx, âŸ¨r, âŸ¨hr, rflâŸ©âŸ©âŸ©\n    simp only [norm_div, norm_mul, norm_ofReal, abs_norm]\n    exact norm_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul hx hr\n\n"}
{"name":"abs_real_inner_div_norm_mul_norm_eq_one_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Iff (Eq (abs (HDiv.hDiv (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y)))) 1) (And (Ne x 0) (Exists fun r => And (Ne r 0) (Eq y (HSMul.hSMul r x))))","decl":"/-- The inner product of two vectors, divided by the product of their\nnorms, has absolute value 1 if and only if they are nonzero and one is\na multiple of the other. One form of equality case for Cauchy-Schwarz. -/\ntheorem abs_real_inner_div_norm_mul_norm_eq_one_iff (x y : F) :\n    |âŸªx, yâŸ«_â„ / (â€–xâ€– * â€–yâ€–)| = 1 â†” x â‰  0 âˆ§ âˆƒ r : â„, r â‰  0 âˆ§ y = r â€¢ x :=\n  @norm_inner_div_norm_mul_norm_eq_one_iff â„ F _ _ _ x y\n\n"}
{"name":"inner_eq_norm_mul_iff_div","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nhâ‚€ : Ne x 0\nâŠ¢ Iff (Eq (Inner.inner x y) (HMul.hMul â†‘(Norm.norm x) â†‘(Norm.norm y))) (Eq (HSMul.hSMul (HDiv.hDiv â†‘(Norm.norm y) â†‘(Norm.norm x)) x) y)","decl":"theorem inner_eq_norm_mul_iff_div {x y : E} (hâ‚€ : x â‰  0) :\n    âŸªx, yâŸ« = (â€–xâ€– : ğ•œ) * â€–yâ€– â†” (â€–yâ€– / â€–xâ€– : ğ•œ) â€¢ x = y := by\n  have hâ‚€' := hâ‚€\n  rw [â† norm_ne_zero_iff, Ne, â† @ofReal_eq_zero ğ•œ] at hâ‚€'\n  constructor <;> intro h\n  Â· have : x = 0 âˆ¨ y = (âŸªx, yâŸ« / âŸªx, xâŸ« : ğ•œ) â€¢ x :=\n      ((@norm_inner_eq_norm_tfae ğ•œ _ _ _ _ x y).out 0 1).1 (by simp [h])\n    rw [this.resolve_left hâ‚€, h]\n    simp [norm_smul, inner_self_ofReal_norm, mul_div_cancel_rightâ‚€ _ hâ‚€']\n  Â· conv_lhs => rw [â† h, inner_smul_right, inner_self_eq_norm_sq_to_K]\n    field_simp [sq, mul_left_comm]\n\n"}
{"name":"inner_eq_norm_mul_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Iff (Eq (Inner.inner x y) (HMul.hMul â†‘(Norm.norm x) â†‘(Norm.norm y))) (Eq (HSMul.hSMul (â†‘(Norm.norm y)) x) (HSMul.hSMul (â†‘(Norm.norm x)) y))","decl":"/-- If the inner product of two vectors is equal to the product of their norms (i.e.,\n`âŸªx, yâŸ« = â€–xâ€– * â€–yâ€–`), then the two vectors are nonnegative real multiples of each other. One form\nof the equality case for Cauchy-Schwarz.\nCompare `norm_inner_eq_norm_iff`, which takes the weaker hypothesis `abs âŸªx, yâŸ« = â€–xâ€– * â€–yâ€–`. -/\ntheorem inner_eq_norm_mul_iff {x y : E} :\n    âŸªx, yâŸ« = (â€–xâ€– : ğ•œ) * â€–yâ€– â†” (â€–yâ€– : ğ•œ) â€¢ x = (â€–xâ€– : ğ•œ) â€¢ y := by\n  rcases eq_or_ne x 0 with (rfl | hâ‚€)\n  Â· simp\n  Â· rw [inner_eq_norm_mul_iff_div hâ‚€, div_eq_inv_mul, mul_smul, inv_smul_eq_iffâ‚€]\n    rwa [Ne, ofReal_eq_zero, norm_eq_zero]\n\n"}
{"name":"inner_eq_norm_mul_iff_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Iff (Eq (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y))) (Eq (HSMul.hSMul (Norm.norm y) x) (HSMul.hSMul (Norm.norm x) y))","decl":"/-- If the inner product of two vectors is equal to the product of their norms (i.e.,\n`âŸªx, yâŸ« = â€–xâ€– * â€–yâ€–`), then the two vectors are nonnegative real multiples of each other. One form\nof the equality case for Cauchy-Schwarz.\nCompare `norm_inner_eq_norm_iff`, which takes the weaker hypothesis `abs âŸªx, yâŸ« = â€–xâ€– * â€–yâ€–`. -/\ntheorem inner_eq_norm_mul_iff_real {x y : F} : âŸªx, yâŸ«_â„ = â€–xâ€– * â€–yâ€– â†” â€–yâ€– â€¢ x = â€–xâ€– â€¢ y :=\n  inner_eq_norm_mul_iff\n\n"}
{"name":"real_inner_div_norm_mul_norm_eq_one_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Iff (Eq (HDiv.hDiv (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y))) 1) (And (Ne x 0) (Exists fun r => And (LT.lt 0 r) (Eq y (HSMul.hSMul r x))))","decl":"/-- The inner product of two vectors, divided by the product of their\nnorms, has value 1 if and only if they are nonzero and one is\na positive multiple of the other. -/\ntheorem real_inner_div_norm_mul_norm_eq_one_iff (x y : F) :\n    âŸªx, yâŸ«_â„ / (â€–xâ€– * â€–yâ€–) = 1 â†” x â‰  0 âˆ§ âˆƒ r : â„, 0 < r âˆ§ y = r â€¢ x := by\n  constructor\n  Â· intro h\n    have hxâ‚€ : x â‰  0 := fun hâ‚€ => by simp [hâ‚€] at h\n    have hyâ‚€ : y â‰  0 := fun hâ‚€ => by simp [hâ‚€] at h\n    refine âŸ¨hxâ‚€, â€–yâ€– / â€–xâ€–, div_pos (norm_pos_iff.2 hyâ‚€) (norm_pos_iff.2 hxâ‚€), ?_âŸ©\n    exact ((inner_eq_norm_mul_iff_div hxâ‚€).1 (eq_of_div_eq_one h)).symm\n  Â· rintro âŸ¨hx, âŸ¨r, âŸ¨hr, rflâŸ©âŸ©âŸ©\n    exact real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_pos_mul hx hr\n\n"}
{"name":"real_inner_div_norm_mul_norm_eq_neg_one_iff","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Iff (Eq (HDiv.hDiv (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y))) (-1)) (And (Ne x 0) (Exists fun r => And (LT.lt r 0) (Eq y (HSMul.hSMul r x))))","decl":"/-- The inner product of two vectors, divided by the product of their\nnorms, has value -1 if and only if they are nonzero and one is\na negative multiple of the other. -/\ntheorem real_inner_div_norm_mul_norm_eq_neg_one_iff (x y : F) :\n    âŸªx, yâŸ«_â„ / (â€–xâ€– * â€–yâ€–) = -1 â†” x â‰  0 âˆ§ âˆƒ r : â„, r < 0 âˆ§ y = r â€¢ x := by\n  rw [â† neg_eq_iff_eq_neg, â† neg_div, â† inner_neg_right, â† norm_neg y,\n    real_inner_div_norm_mul_norm_eq_one_iff, (@neg_surjective â„ _).exists]\n  refine Iff.rfl.and (exists_congr fun r => ?_)\n  rw [neg_pos, neg_smul, neg_inj]\n\n"}
{"name":"inner_eq_one_iff_of_norm_one","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nhx : Eq (Norm.norm x) 1\nhy : Eq (Norm.norm y) 1\nâŠ¢ Iff (Eq (Inner.inner x y) 1) (Eq x y)","decl":"/-- If the inner product of two unit vectors is `1`, then the two vectors are equal. One form of\nthe equality case for Cauchy-Schwarz. -/\ntheorem inner_eq_one_iff_of_norm_one {x y : E} (hx : â€–xâ€– = 1) (hy : â€–yâ€– = 1) :\n    âŸªx, yâŸ« = 1 â†” x = y := by\n  convert inner_eq_norm_mul_iff (ğ•œ := ğ•œ) (E := E) using 2 <;> simp [hx, hy]\n\n"}
{"name":"inner_lt_norm_mul_iff_real","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nâŠ¢ Iff (LT.lt (Inner.inner x y) (HMul.hMul (Norm.norm x) (Norm.norm y))) (Ne (HSMul.hSMul (Norm.norm y) x) (HSMul.hSMul (Norm.norm x) y))","decl":"theorem inner_lt_norm_mul_iff_real {x y : F} : âŸªx, yâŸ«_â„ < â€–xâ€– * â€–yâ€– â†” â€–yâ€– â€¢ x â‰  â€–xâ€– â€¢ y :=\n  calc\n    âŸªx, yâŸ«_â„ < â€–xâ€– * â€–yâ€– â†” âŸªx, yâŸ«_â„ â‰  â€–xâ€– * â€–yâ€– :=\n      âŸ¨ne_of_lt, lt_of_le_of_ne (real_inner_le_norm _ _)âŸ©\n    _ â†” â€–yâ€– â€¢ x â‰  â€–xâ€– â€¢ y := not_congr inner_eq_norm_mul_iff_real\n\n"}
{"name":"inner_lt_one_iff_real_of_norm_one","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"F : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nx y : F\nhx : Eq (Norm.norm x) 1\nhy : Eq (Norm.norm y) 1\nâŠ¢ Iff (LT.lt (Inner.inner x y) 1) (Ne x y)","decl":"/-- If the inner product of two unit vectors is strictly less than `1`, then the two vectors are\ndistinct. One form of the equality case for Cauchy-Schwarz. -/\ntheorem inner_lt_one_iff_real_of_norm_one {x y : F} (hx : â€–xâ€– = 1) (hy : â€–yâ€– = 1) :\n    âŸªx, yâŸ«_â„ < 1 â†” x â‰  y := by convert inner_lt_norm_mul_iff_real (F := F) <;> simp [hx, hy]\n\n"}
{"name":"eq_of_norm_le_re_inner_eq_norm_sq","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nhle : LE.le (Norm.norm x) (Norm.norm y)\nh : Eq (RCLike.re (Inner.inner x y)) (HPow.hPow (Norm.norm y) 2)\nâŠ¢ Eq x y","decl":"/-- The sphere of radius `r = â€–yâ€–` is tangent to the plane `âŸªx, yâŸ« = â€–yâ€– ^ 2` at `x = y`. -/\ntheorem eq_of_norm_le_re_inner_eq_norm_sq {x y : E} (hle : â€–xâ€– â‰¤ â€–yâ€–) (h : re âŸªx, yâŸ« = â€–yâ€– ^ 2) :\n    x = y := by\n  suffices H : re âŸªx - y, x - yâŸ« â‰¤ 0 by rwa [inner_self_nonpos, sub_eq_zero] at H\n  have Hâ‚ : â€–xâ€– ^ 2 â‰¤ â€–yâ€– ^ 2 := by gcongr\n  have Hâ‚‚ : re âŸªy, xâŸ« = â€–yâ€– ^ 2 := by rwa [â† inner_conj_symm, conj_re]\n  simpa [inner_sub_left, inner_sub_right, â† norm_sq_eq_inner, h, Hâ‚‚] using Hâ‚\n\n"}
{"name":"RCLike.inner_apply","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœ : RCLike ğ•œ\nx y : ğ•œ\nâŠ¢ Eq (Inner.inner x y) (HMul.hMul ((starRingEnd ğ•œ) x) y)","decl":"@[simp]\ntheorem RCLike.inner_apply (x y : ğ•œ) : âŸªx, yâŸ« = conj x * y :=\n  rfl\n\n"}
{"name":"real_inner_eq_re_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx y : E\nâŠ¢ Eq (Inner.inner x y) (RCLike.re (Inner.inner x y))","decl":"theorem real_inner_eq_re_inner (x y : E) :\n    @Inner.inner â„ E (Inner.rclikeToReal ğ•œ E) x y = re âŸªx, yâŸ« :=\n  rfl\n\n"}
{"name":"real_inner_I_smul_self","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nx : E\nâŠ¢ Eq (Inner.inner x (HSMul.hSMul RCLike.I x)) 0","decl":"theorem real_inner_I_smul_self (x : E) :\n    @Inner.inner â„ E (Inner.rclikeToReal ğ•œ E) x ((I : ğ•œ) â€¢ x) = 0 := by\n  simp [real_inner_eq_re_inner ğ•œ, inner_smul_right]\n\n"}
{"name":"Complex.inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"w z : Complex\nâŠ¢ Eq (Inner.inner w z) (HMul.hMul ((starRingEnd Complex) w) z).re","decl":"@[simp]\nprotected theorem Complex.inner (w z : â„‚) : âŸªw, zâŸ«_â„ = (conj w * z).re :=\n  rfl\n\n"}
{"name":"continuous_inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ Continuous fun p => Inner.inner p.1 p.2","decl":"theorem continuous_inner : Continuous fun p : E Ã— E => âŸªp.1, p.2âŸ« :=\n  letI : InnerProductSpace â„ E := InnerProductSpace.rclikeToReal ğ•œ E\n  letI : IsScalarTower â„ ğ•œ E := RestrictScalars.isScalarTower _ _ _\n  isBoundedBilinearMap_inner.continuous\n\n"}
{"name":"Filter.Tendsto.inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ± : Type u_4\nf g : Î± â†’ E\nl : Filter Î±\nx y : E\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\nâŠ¢ Filter.Tendsto (fun t => Inner.inner (f t) (g t)) l (nhds (Inner.inner x y))","decl":"theorem Filter.Tendsto.inner {f g : Î± â†’ E} {l : Filter Î±} {x y : E} (hf : Tendsto f l (ğ“ x))\n    (hg : Tendsto g l (ğ“ y)) : Tendsto (fun t => âŸªf t, g tâŸ«) l (ğ“ âŸªx, yâŸ«) :=\n  (continuous_inner.tendsto _).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"ContinuousWithinAt.inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nÎ± : Type u_4\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ E\nx : Î±\ns : Set Î±\nhf : ContinuousWithinAt f s x\nhg : ContinuousWithinAt g s x\nâŠ¢ ContinuousWithinAt (fun t => Inner.inner (f t) (g t)) s x","decl":"theorem ContinuousWithinAt.inner (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) :\n    ContinuousWithinAt (fun t => âŸªf t, g tâŸ«) s x :=\n  Filter.Tendsto.inner hf hg\n\n"}
{"name":"ContinuousAt.inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nÎ± : Type u_4\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ E\nx : Î±\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nâŠ¢ ContinuousAt (fun t => Inner.inner (f t) (g t)) x","decl":"theorem ContinuousAt.inner (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun t => âŸªf t, g tâŸ«) x :=\n  Filter.Tendsto.inner hf hg\n\n"}
{"name":"ContinuousOn.inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nÎ± : Type u_4\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ E\ns : Set Î±\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nâŠ¢ ContinuousOn (fun t => Inner.inner (f t) (g t)) s","decl":"theorem ContinuousOn.inner (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun t => âŸªf t, g tâŸ«) s := fun x hx => (hf x hx).inner (hg x hx)\n\n"}
{"name":"Continuous.inner","module":"Mathlib.Analysis.InnerProductSpace.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nÎ± : Type u_4\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ E\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun t => Inner.inner (f t) (g t)","decl":"@[continuity]\ntheorem Continuous.inner (hf : Continuous f) (hg : Continuous g) : Continuous fun t => âŸªf t, g tâŸ« :=\n  continuous_iff_continuousAt.2 fun _x => hf.continuousAt.inner hg.continuousAt\n\n"}
