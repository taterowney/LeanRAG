{"name":"AlgebraicGeometry.Scheme.mk.injEq","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"toLocallyRingedSpace✝ : AlgebraicGeometry.LocallyRingedSpace\nlocal_affine✝ : ∀ (x : ↑toLocallyRingedSpace✝.toTopCat), Exists fun U => Exists fun R => Nonempty (CategoryTheory.Iso (toLocallyRingedSpace✝.restrict ⋯) (AlgebraicGeometry.Spec.toLocallyRingedSpace.obj { unop := R }))\ntoLocallyRingedSpace : AlgebraicGeometry.LocallyRingedSpace\nlocal_affine : ∀ (x : ↑toLocallyRingedSpace.toTopCat), Exists fun U => Exists fun R => Nonempty (CategoryTheory.Iso (toLocallyRingedSpace.restrict ⋯) (AlgebraicGeometry.Spec.toLocallyRingedSpace.obj { unop := R }))\n⊢ Eq (Eq { toLocallyRingedSpace := toLocallyRingedSpace✝, local_affine := local_affine✝ } { toLocallyRingedSpace := toLocallyRingedSpace, local_affine := local_affine }) (Eq toLocallyRingedSpace✝ toLocallyRingedSpace)","decl":"/-- We define `Scheme` as an `X : LocallyRingedSpace`,\nalong with a proof that every point has an open neighbourhood `U`\nso that the restriction of `X` to `U` is isomorphic,\nas a locally ringed space, to `Spec.toLocallyRingedSpace.obj (op R)`\nfor some `R : CommRingCat`.\n-/\nstructure Scheme extends LocallyRingedSpace where\n  local_affine :\n    ∀ x : toLocallyRingedSpace,\n      ∃ (U : OpenNhds x) (R : CommRingCat),\n        Nonempty\n          (toLocallyRingedSpace.restrict U.isOpenEmbedding ≅ Spec.toLocallyRingedSpace.obj (op R))\n\n"}
{"name":"AlgebraicGeometry.Scheme.mk.inj","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"toLocallyRingedSpace✝ : AlgebraicGeometry.LocallyRingedSpace\nlocal_affine✝ : ∀ (x : ↑toLocallyRingedSpace✝.toTopCat), Exists fun U => Exists fun R => Nonempty (CategoryTheory.Iso (toLocallyRingedSpace✝.restrict ⋯) (AlgebraicGeometry.Spec.toLocallyRingedSpace.obj { unop := R }))\ntoLocallyRingedSpace : AlgebraicGeometry.LocallyRingedSpace\nlocal_affine : ∀ (x : ↑toLocallyRingedSpace.toTopCat), Exists fun U => Exists fun R => Nonempty (CategoryTheory.Iso (toLocallyRingedSpace.restrict ⋯) (AlgebraicGeometry.Spec.toLocallyRingedSpace.obj { unop := R }))\nx✝ : Eq { toLocallyRingedSpace := toLocallyRingedSpace✝, local_affine := local_affine✝ } { toLocallyRingedSpace := toLocallyRingedSpace, local_affine := local_affine }\n⊢ Eq toLocallyRingedSpace✝ toLocallyRingedSpace","decl":"/-- We define `Scheme` as an `X : LocallyRingedSpace`,\nalong with a proof that every point has an open neighbourhood `U`\nso that the restriction of `X` to `U` is isomorphic,\nas a locally ringed space, to `Spec.toLocallyRingedSpace.obj (op R)`\nfor some `R : CommRingCat`.\n-/\nstructure Scheme extends LocallyRingedSpace where\n  local_affine :\n    ∀ x : toLocallyRingedSpace,\n      ∃ (U : OpenNhds x) (R : CommRingCat),\n        Nonempty\n          (toLocallyRingedSpace.restrict U.isOpenEmbedding ≅ Spec.toLocallyRingedSpace.obj (op R))\n\n"}
{"name":"AlgebraicGeometry.Scheme.local_affine","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"self : AlgebraicGeometry.Scheme\nx : ↑self.toTopCat\n⊢ Exists fun U => Exists fun R => Nonempty (CategoryTheory.Iso (self.restrict ⋯) (AlgebraicGeometry.Spec.toLocallyRingedSpace.obj { unop := R }))","decl":"/-- We define `Scheme` as an `X : LocallyRingedSpace`,\nalong with a proof that every point has an open neighbourhood `U`\nso that the restriction of `X` to `U` is isomorphic,\nas a locally ringed space, to `Spec.toLocallyRingedSpace.obj (op R)`\nfor some `R : CommRingCat`.\n-/\nstructure Scheme extends LocallyRingedSpace where\n  local_affine :\n    ∀ x : toLocallyRingedSpace,\n      ∃ (U : OpenNhds x) (R : CommRingCat),\n        Nonempty\n          (toLocallyRingedSpace.restrict U.isOpenEmbedding ≅ Spec.toLocallyRingedSpace.obj (op R))\n\n"}
{"name":"AlgebraicGeometry.Scheme.mk.sizeOf_spec","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"toLocallyRingedSpace : AlgebraicGeometry.LocallyRingedSpace\nlocal_affine : ∀ (x : ↑toLocallyRingedSpace.toTopCat), Exists fun U => Exists fun R => Nonempty (CategoryTheory.Iso (toLocallyRingedSpace.restrict ⋯) (AlgebraicGeometry.Spec.toLocallyRingedSpace.obj { unop := R }))\n⊢ Eq (SizeOf.sizeOf { toLocallyRingedSpace := toLocallyRingedSpace, local_affine := local_affine }) (HAdd.hAdd 1 (SizeOf.sizeOf toLocallyRingedSpace))","decl":"/-- We define `Scheme` as an `X : LocallyRingedSpace`,\nalong with a proof that every point has an open neighbourhood `U`\nso that the restriction of `X` to `U` is isomorphic,\nas a locally ringed space, to `Spec.toLocallyRingedSpace.obj (op R)`\nfor some `R : CommRingCat`.\n-/\nstructure Scheme extends LocallyRingedSpace where\n  local_affine :\n    ∀ x : toLocallyRingedSpace,\n      ∃ (U : OpenNhds x) (R : CommRingCat),\n        Nonempty\n          (toLocallyRingedSpace.restrict U.isOpenEmbedding ≅ Spec.toLocallyRingedSpace.obj (op R))\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.mk.injEq","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ntoHom_1✝ toHom_1 : X.Hom Y.toLocallyRingedSpace\n⊢ Eq (Eq { toHom_1 := toHom_1✝ } { toHom_1 := toHom_1 }) (Eq toHom_1✝ toHom_1)","decl":"/-- A morphism between schemes is a morphism between the underlying locally ringed spaces. -/\nstructure Hom (X Y : Scheme) extends X.toLocallyRingedSpace.Hom Y.toLocallyRingedSpace where\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.mk.inj","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ntoHom_1✝ toHom_1 : X.Hom Y.toLocallyRingedSpace\nx✝ : Eq { toHom_1 := toHom_1✝ } { toHom_1 := toHom_1 }\n⊢ Eq toHom_1✝ toHom_1","decl":"/-- A morphism between schemes is a morphism between the underlying locally ringed spaces. -/\nstructure Hom (X Y : Scheme) extends X.toLocallyRingedSpace.Hom Y.toLocallyRingedSpace where\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.mk.sizeOf_spec","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ntoHom_1 : X.Hom Y.toLocallyRingedSpace\n⊢ Eq (SizeOf.sizeOf { toHom_1 := toHom_1 }) (HAdd.hAdd 1 (SizeOf.sizeOf toHom_1))","decl":"/-- A morphism between schemes is a morphism between the underlying locally ringed spaces. -/\nstructure Hom (X Y : Scheme) extends X.toLocallyRingedSpace.Hom Y.toLocallyRingedSpace where\n\n"}
{"name":"AlgebraicGeometry.Scheme.instSubsingletonCarrierObjOppositeOpensαTopologicalSpaceCarrierCommRingCatPresheafOpOpensBot","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Subsingleton ↑(X.presheaf.obj { unop := Bot.bot })","decl":"instance {X : Scheme.{u}} : Subsingleton Γ(X, ⊥) :=\n  CommRingCat.subsingleton_of_isTerminal X.sheaf.isTerminalOfEmpty\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.continuous","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\n⊢ Continuous ⇑f.base","decl":"@[continuity, fun_prop]\nlemma Hom.continuous {X Y : Scheme} (f : X.Hom Y) : Continuous f.base := f.base.2\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.naturality","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU U' : Y.Opens\ni : Quiver.Hom { unop := U' } { unop := U }\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.map i) (f.app U)) (CategoryTheory.CategoryStruct.comp (f.app U') (X.presheaf.map ((TopologicalSpace.Opens.map f.base).map i.unop).op))","decl":"@[reassoc]\nlemma naturality (i : op U' ⟶ op U) :\n    Y.presheaf.map i ≫ f.app U = f.app U' ≫ X.presheaf.map ((Opens.map f.base).map i.unop).op :=\n  f.c.naturality i\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.naturality_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU U' : Y.Opens\ni : Quiver.Hom { unop := U' } { unop := U }\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.obj { unop := (TopologicalSpace.Opens.map f.base).obj U }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.map i) (CategoryTheory.CategoryStruct.comp (f.app U) h)) (CategoryTheory.CategoryStruct.comp (f.app U') (CategoryTheory.CategoryStruct.comp (X.presheaf.map ((TopologicalSpace.Opens.map f.base).map i.unop).op) h))","decl":"@[reassoc]\nlemma naturality (i : op U' ⟶ op U) :\n    Y.presheaf.map i ≫ f.app U = f.app U' ≫ X.presheaf.map ((Opens.map f.base).map i.unop).op :=\n  f.c.naturality i\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appLE_map_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU : Y.Opens\nV V' : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ni : Quiver.Hom { unop := V } { unop := V' }\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.obj { unop := V' }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.appLE U V e) (CategoryTheory.CategoryStruct.comp (X.presheaf.map i) h)) (CategoryTheory.CategoryStruct.comp (f.appLE U V' ⋯) h)","decl":"@[reassoc (attr := simp)]\nlemma appLE_map (e : V ≤ f ⁻¹ᵁ U) (i : op V ⟶ op V') :\n    f.appLE U V e ≫ X.presheaf.map i = f.appLE U V' (i.unop.le.trans e) := by\n  rw [Hom.appLE, Category.assoc, ← Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appLE_map","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU : Y.Opens\nV V' : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ni : Quiver.Hom { unop := V } { unop := V' }\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.appLE U V e) (X.presheaf.map i)) (f.appLE U V' ⋯)","decl":"@[reassoc (attr := simp)]\nlemma appLE_map (e : V ≤ f ⁻¹ᵁ U) (i : op V ⟶ op V') :\n    f.appLE U V e ≫ X.presheaf.map i = f.appLE U V' (i.unop.le.trans e) := by\n  rw [Hom.appLE, Category.assoc, ← Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appLE_map'_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU : Y.Opens\nV V' : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ni : Eq V V'\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.obj { unop := V }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.appLE U V' ⋯) (CategoryTheory.CategoryStruct.comp (X.presheaf.map (CategoryTheory.eqToHom i).op) h)) (CategoryTheory.CategoryStruct.comp (f.appLE U V e) h)","decl":"@[reassoc]\nlemma appLE_map' (e : V ≤ f ⁻¹ᵁ U) (i : V = V') :\n    f.appLE U V' (i ▸ e) ≫ X.presheaf.map (eqToHom i).op = f.appLE U V e :=\n  appLE_map _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appLE_map'","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU : Y.Opens\nV V' : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ni : Eq V V'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.appLE U V' ⋯) (X.presheaf.map (CategoryTheory.eqToHom i).op)) (f.appLE U V e)","decl":"@[reassoc]\nlemma appLE_map' (e : V ≤ f ⁻¹ᵁ U) (i : V = V') :\n    f.appLE U V' (i ▸ e) ≫ X.presheaf.map (eqToHom i).op = f.appLE U V e :=\n  appLE_map _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.map_appLE","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU U' : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ni : Quiver.Hom { unop := U' } { unop := U }\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.map i) (f.appLE U V e)) (f.appLE U' V ⋯)","decl":"@[reassoc (attr := simp)]\nlemma map_appLE (e : V ≤ f ⁻¹ᵁ U) (i : op U' ⟶ op U) :\n    Y.presheaf.map i ≫ f.appLE U V e =\n      f.appLE U' V (e.trans ((Opens.map f.base).map i.unop).le) := by\n  rw [Hom.appLE, f.naturality_assoc, ← Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.map_appLE_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU U' : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ni : Quiver.Hom { unop := U' } { unop := U }\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.obj { unop := V }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.map i) (CategoryTheory.CategoryStruct.comp (f.appLE U V e) h)) (CategoryTheory.CategoryStruct.comp (f.appLE U' V ⋯) h)","decl":"@[reassoc (attr := simp)]\nlemma map_appLE (e : V ≤ f ⁻¹ᵁ U) (i : op U' ⟶ op U) :\n    Y.presheaf.map i ≫ f.appLE U V e =\n      f.appLE U' V (e.trans ((Opens.map f.base).map i.unop).le) := by\n  rw [Hom.appLE, f.naturality_assoc, ← Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.map_appLE'","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU U' : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ni : Eq U' U\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.map (CategoryTheory.eqToHom i).op) (f.appLE U' V ⋯)) (f.appLE U V e)","decl":"@[reassoc]\nlemma map_appLE' (e : V ≤ f ⁻¹ᵁ U) (i : U' = U) :\n    Y.presheaf.map (eqToHom i).op ≫ f.appLE U' V (i ▸ e) = f.appLE U V e :=\n  map_appLE _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.map_appLE'_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU U' : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ni : Eq U' U\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.obj { unop := V }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.map (CategoryTheory.eqToHom i).op) (CategoryTheory.CategoryStruct.comp (f.appLE U' V ⋯) h)) (CategoryTheory.CategoryStruct.comp (f.appLE U V e) h)","decl":"@[reassoc]\nlemma map_appLE' (e : V ≤ f ⁻¹ᵁ U) (i : U' = U) :\n    Y.presheaf.map (eqToHom i).op ≫ f.appLE U' V (i ▸ e) = f.appLE U V e :=\n  map_appLE _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.app_eq_appLE","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU : Y.Opens\n⊢ Eq (f.app U) (f.appLE U ((TopologicalSpace.Opens.map f.base).obj U) ⋯)","decl":"lemma app_eq_appLE {U : Y.Opens} :\n    f.app U = f.appLE U _ le_rfl := by\n  simp [Hom.appLE]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appLE_eq_app","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU : Y.Opens\n⊢ Eq (f.appLE U ((TopologicalSpace.Opens.map f.base).obj U) ⋯) (f.app U)","decl":"lemma appLE_eq_app {U : Y.Opens} :\n    f.appLE U (f ⁻¹ᵁ U) le_rfl = f.app U :=\n  (app_eq_appLE f).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appLE_congr","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU U' : Y.Opens\nV V' : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ne₁ : Eq U U'\ne₂ : Eq V V'\nP : {R S : CommRingCat} → Quiver.Hom R S → Prop\n⊢ Iff (P (f.appLE U V e)) (P (f.appLE U' V' ⋯))","decl":"lemma appLE_congr (e : V ≤ f ⁻¹ᵁ U) (e₁ : U = U') (e₂ : V = V')\n    (P : ∀ {R S : CommRingCat.{u}} (_ : R ⟶ S), Prop) :\n    P (f.appLE U V e) ↔ P (f.appLE U' V' (e₁ ▸ e₂ ▸ e)) := by\n  subst e₁; subst e₂; rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.ext","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf g : Quiver.Hom X Y\nh_base : Eq f.base g.base\nh_app : ∀ (U : Y.Opens), Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f U) (X.presheaf.map (CategoryTheory.eqToHom ⋯).op)) (AlgebraicGeometry.Scheme.Hom.app g U)\n⊢ Eq f g","decl":"@[ext (iff := false)]\nprotected lemma ext {f g : X ⟶ Y} (h_base : f.base = g.base)\n    (h_app : ∀ U, f.app U ≫ X.presheaf.map\n      (eqToHom congr((Opens.map $h_base.symm).obj U)).op = g.app U) : f = g := by\n  cases f; cases g; congr 1\n  exact LocallyRingedSpace.Hom.ext' <| SheafedSpace.ext _ _ h_base\n    (TopCat.Presheaf.ext fun U ↦ by simpa using h_app U)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.ext'","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf g : Quiver.Hom X Y\nh : Eq (AlgebraicGeometry.Scheme.Hom.toLRSHom f) (AlgebraicGeometry.Scheme.Hom.toLRSHom g)\n⊢ Eq f g","decl":"/-- An alternative ext lemma for scheme morphisms. -/\nprotected lemma ext' {f g : X ⟶ Y} (h : f.toLRSHom = g.toLRSHom) : f = g := by\n  cases f; cases g; congr 1\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.preimage_iSup","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nι : Sort u_1\nU : ι → Y.Opens\n⊢ Eq ((TopologicalSpace.Opens.map f.base).obj (iSup U)) (iSup fun i => (TopologicalSpace.Opens.map f.base).obj (U i))","decl":"lemma preimage_iSup {ι} (U : ι → Opens Y) : f ⁻¹ᵁ iSup U = ⨆ i, f ⁻¹ᵁ U i :=\n  Opens.ext (by simp)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.preimage_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nι : Sort u_1\nU : ι → Y.Opens\nhU : Eq (iSup U) Top.top\n⊢ Eq (iSup fun i => (TopologicalSpace.Opens.map f.base).obj (U i)) Top.top","decl":"lemma preimage_iSup_eq_top {ι} {U : ι → Opens Y} (hU : iSup U = ⊤) :\n    ⨆ i, f ⁻¹ᵁ U i = ⊤ := f.preimage_iSup U ▸ hU ▸ rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.preimage_le_preimage_of_le","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nU U' : Y.Opens\nhUU' : LE.le U U'\n⊢ LE.le ((TopologicalSpace.Opens.map f.base).obj U) ((TopologicalSpace.Opens.map f.base).obj U')","decl":"lemma preimage_le_preimage_of_le {U U' : Y.Opens} (hUU' : U ≤ U') :\n    f ⁻¹ᵁ U ≤ f ⁻¹ᵁ U' :=\n  fun _ ha ↦ hUU' ha\n\n"}
{"name":"AlgebraicGeometry.Scheme.preimage_comp","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : Z.Opens\n⊢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g).base).obj U) ((TopologicalSpace.Opens.map f.base).obj ((TopologicalSpace.Opens.map g.base).obj U))","decl":"@[simp]\nlemma preimage_comp {X Y Z : Scheme.{u}} (f : X ⟶ Y) (g : Y ⟶ Z) (U) :\n    (f ≫ g) ⁻¹ᵁ U = f ⁻¹ᵁ g ⁻¹ᵁ U := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace_obj","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"self : AlgebraicGeometry.Scheme\n⊢ Eq (AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace.obj self) self.toLocallyRingedSpace","decl":"/-- The forgetful functor from `Scheme` to `LocallyRingedSpace`. -/\n@[simps!]\ndef forgetToLocallyRingedSpace : Scheme ⥤ LocallyRingedSpace where\n  obj := toLocallyRingedSpace\n  map := Hom.toLRSHom\n\n"}
{"name":"AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace_map","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X✝ Y✝ : AlgebraicGeometry.Scheme\nf : X✝.Hom Y✝\n⊢ Eq (AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace.map f) f.toLRSHom","decl":"/-- The forgetful functor from `Scheme` to `LocallyRingedSpace`. -/\n@[simps!]\ndef forgetToLocallyRingedSpace : Scheme ⥤ LocallyRingedSpace where\n  obj := toLocallyRingedSpace\n  map := Hom.toLRSHom\n\n"}
{"name":"AlgebraicGeometry.Scheme.fullyFaithfulForgetToLocallyRingedSpace_preimage_toLRSHom","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X✝ Y✝ : AlgebraicGeometry.Scheme\ntoHom_1 : X✝.Hom Y✝.toLocallyRingedSpace\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.toLRSHom (AlgebraicGeometry.Scheme.fullyFaithfulForgetToLocallyRingedSpace.preimage toHom_1)) toHom_1","decl":"/-- The forget functor `Scheme ⥤ LocallyRingedSpace` is fully faithful. -/\n@[simps preimage_toLRSHom]\ndef fullyFaithfulForgetToLocallyRingedSpace :\n    forgetToLocallyRingedSpace.FullyFaithful where\n  preimage := Hom.mk\n\n"}
{"name":"AlgebraicGeometry.Scheme.instFullLocallyRingedSpaceForgetToLocallyRingedSpace","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"⊢ AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace.Full","decl":"instance : forgetToLocallyRingedSpace.Full :=\n  fullyFaithfulForgetToLocallyRingedSpace.full\n\n"}
{"name":"AlgebraicGeometry.Scheme.instFaithfulLocallyRingedSpaceForgetToLocallyRingedSpace","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"⊢ AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace.Faithful","decl":"instance : forgetToLocallyRingedSpace.Faithful :=\n  fullyFaithfulForgetToLocallyRingedSpace.faithful\n\n"}
{"name":"AlgebraicGeometry.Scheme.forgetToTop_map","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X✝ Y✝ : AlgebraicGeometry.Scheme\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (AlgebraicGeometry.Scheme.forgetToTop.map f) ((AlgebraicGeometry.SheafedSpace.forget CommRingCat).map (AlgebraicGeometry.Scheme.Hom.toLRSHom f).toHom)","decl":"/-- The forgetful functor from `Scheme` to `TopCat`. -/\n@[simps!]\ndef forgetToTop : Scheme ⥤ TopCat :=\n  Scheme.forgetToLocallyRingedSpace ⋙ LocallyRingedSpace.forgetToTop\n\n"}
{"name":"AlgebraicGeometry.Scheme.forgetToTop_obj","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Eq (AlgebraicGeometry.Scheme.forgetToTop.obj X) ((AlgebraicGeometry.SheafedSpace.forget CommRingCat).obj X.toSheafedSpace)","decl":"/-- The forgetful functor from `Scheme` to `TopCat`. -/\n@[simps!]\ndef forgetToTop : Scheme ⥤ TopCat :=\n  Scheme.forgetToLocallyRingedSpace ⋙ LocallyRingedSpace.forgetToTop\n\n"}
{"name":"AlgebraicGeometry.Scheme.homeoOfIso_symm","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\n⊢ Eq (AlgebraicGeometry.Scheme.homeoOfIso e).symm (AlgebraicGeometry.Scheme.homeoOfIso e.symm)","decl":"@[simp]\nlemma homeoOfIso_symm {X Y : Scheme} (e : X ≅ Y) :\n    (homeoOfIso e).symm = homeoOfIso e.symm := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.homeoOfIso_apply","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\nx : ↑↑X.toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.Scheme.homeoOfIso e) x) (e.hom.base x)","decl":"@[simp]\nlemma homeoOfIso_apply {X Y : Scheme} (e : X ≅ Y) (x : X) :\n    homeoOfIso e x = e.hom.base x := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.homeomorph_apply","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\ninst✝ : CategoryTheory.IsIso f\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (f.homeomorph x) (f.base x)","decl":"@[simp]\nlemma Hom.homeomorph_apply {X Y : Scheme.{u}} (f : X.Hom Y) [IsIso (C := Scheme) f] (x) :\n    f.homeomorph x = f.base x := rfl\n\n-- Porting note: Lean seems not able to find this coercion any more\n"}
{"name":"AlgebraicGeometry.Scheme.id.base","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Eq (CategoryTheory.CategoryStruct.id X).base (CategoryTheory.CategoryStruct.id ↑X.toPresheafedSpace)","decl":"@[simp]\ntheorem id.base (X : Scheme) : (𝟙 X :).base = 𝟙 _ :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.id_app","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app (CategoryTheory.CategoryStruct.id X) U) (CategoryTheory.CategoryStruct.id (X.presheaf.obj { unop := U }))","decl":"@[simp]\ntheorem id_app {X : Scheme} (U : X.Opens) :\n    (𝟙 X :).app U = 𝟙 _ := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.id_appTop","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appTop (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (X.presheaf.obj { unop := Top.top }))","decl":"@[simp]\ntheorem id_appTop {X : Scheme} :\n    (𝟙 X :).appTop = 𝟙 _ :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.comp_toLRSHom_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nZ : AlgebraicGeometry.LocallyRingedSpace\nh : Quiver.Hom Z✝.toLocallyRingedSpace Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.toLRSHom (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.toLRSHom f) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.toLRSHom g) h))","decl":"@[reassoc]\ntheorem comp_toLRSHom {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).toLRSHom = f.toLRSHom ≫ g.toLRSHom :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.comp_toLRSHom","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.toLRSHom (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.toLRSHom f) (AlgebraicGeometry.Scheme.Hom.toLRSHom g))","decl":"@[reassoc]\ntheorem comp_toLRSHom {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).toLRSHom = f.toLRSHom ≫ g.toLRSHom :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.comp_coeBase_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nZ : TopCat\nh : Quiver.Hom (↑Z✝.toPresheafedSpace) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).base h) (CategoryTheory.CategoryStruct.comp f.base (CategoryTheory.CategoryStruct.comp g.base h))","decl":"@[simp, reassoc] -- reassoc lemma does not need `simp`\ntheorem comp_coeBase {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).base = f.base ≫ g.base :=\n  rfl\n\n-- Porting note: removed elementwise attribute, as generated lemmas were trivial.\n"}
{"name":"AlgebraicGeometry.Scheme.comp_coeBase","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).base (CategoryTheory.CategoryStruct.comp f.base g.base)","decl":"@[simp, reassoc] -- reassoc lemma does not need `simp`\ntheorem comp_coeBase {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).base = f.base ≫ g.base :=\n  rfl\n\n-- Porting note: removed elementwise attribute, as generated lemmas were trivial.\n"}
{"name":"AlgebraicGeometry.Scheme.comp_base","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).base (CategoryTheory.CategoryStruct.comp f.base g.base)","decl":"@[reassoc]\ntheorem comp_base {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).base = f.base ≫ g.base :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.comp_base_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nZ : TopCat\nh : Quiver.Hom (↑Z✝.toPresheafedSpace) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).base h) (CategoryTheory.CategoryStruct.comp f.base (CategoryTheory.CategoryStruct.comp g.base h))","decl":"@[reassoc]\ntheorem comp_base {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).base = f.base ≫ g.base :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.comp_base_apply","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nx : ↑↑X.toPresheafedSpace\n⊢ Eq ((CategoryTheory.CategoryStruct.comp f g).base x) (g.base (f.base x))","decl":"theorem comp_base_apply {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) (x : X) :\n    (f ≫ g).base x = g.base (f.base x) := by\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.comp_app","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : Z.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app (CategoryTheory.CategoryStruct.comp f g) U) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app g U) (AlgebraicGeometry.Scheme.Hom.app f ((TopologicalSpace.Opens.map g.base).obj U)))","decl":"@[simp, reassoc] -- reassoc lemma does not need `simp`\ntheorem comp_app {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) (U) :\n    (f ≫ g).app U = g.app U ≫ f.app _ :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.comp_app_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nU : Z✝.Opens\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.obj { unop := (TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g).base).obj U }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app (CategoryTheory.CategoryStruct.comp f g) U) h) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app g U) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f ((TopologicalSpace.Opens.map g.base).obj U)) h))","decl":"@[simp, reassoc] -- reassoc lemma does not need `simp`\ntheorem comp_app {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) (U) :\n    (f ≫ g).app U = g.app U ≫ f.app _ :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.comp_appTop","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appTop (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appTop g) (AlgebraicGeometry.Scheme.Hom.appTop f))","decl":"@[simp, reassoc] -- reassoc lemma does not need `simp`\ntheorem comp_appTop {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).appTop = g.appTop ≫ f.appTop :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.comp_appTop_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.obj { unop := Top.top }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appTop (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appTop g) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appTop f) h))","decl":"@[simp, reassoc] -- reassoc lemma does not need `simp`\ntheorem comp_appTop {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).appTop = g.appTop ≫ f.appTop :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.appLE_comp_appLE","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : Z.Opens\nV : Y.Opens\nW : X.Opens\ne₁ : LE.le V ((TopologicalSpace.Opens.map g.base).obj U)\ne₂ : LE.le W ((TopologicalSpace.Opens.map f.base).obj V)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appLE g U V e₁) (AlgebraicGeometry.Scheme.Hom.appLE f V W e₂)) (AlgebraicGeometry.Scheme.Hom.appLE (CategoryTheory.CategoryStruct.comp f g) U W ⋯)","decl":"theorem appLE_comp_appLE {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) (U V W e₁ e₂) :\n    g.appLE U V e₁ ≫ f.appLE V W e₂ =\n      (f ≫ g).appLE U W (e₂.trans ((Opens.map f.base).map (homOfLE e₁)).le) := by\n  dsimp [Hom.appLE]\n  rw [Category.assoc, f.naturality_assoc, ← Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.comp_appLE","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : Z.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g).base).obj U)\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appLE (CategoryTheory.CategoryStruct.comp f g) U V e) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app g U) (AlgebraicGeometry.Scheme.Hom.appLE f ((TopologicalSpace.Opens.map g.base).obj U) V e))","decl":"@[simp, reassoc] -- reassoc lemma does not need `simp`\ntheorem comp_appLE {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) (U V e) :\n    (f ≫ g).appLE U V e = g.app U ≫ f.appLE _ V e := by\n  rw [g.app_eq_appLE, appLE_comp_appLE]\n\n"}
{"name":"AlgebraicGeometry.Scheme.comp_appLE_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nU : Z✝.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g).base).obj U)\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.obj { unop := V }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appLE (CategoryTheory.CategoryStruct.comp f g) U V e) h) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app g U) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appLE f ((TopologicalSpace.Opens.map g.base).obj U) V e) h))","decl":"@[simp, reassoc] -- reassoc lemma does not need `simp`\ntheorem comp_appLE {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z) (U V e) :\n    (f ≫ g).appLE U V e = g.app U ≫ f.appLE _ V e := by\n  rw [g.app_eq_appLE, appLE_comp_appLE]\n\n"}
{"name":"AlgebraicGeometry.Scheme.congr_app","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf g : Quiver.Hom X Y\ne : Eq f g\nU : Y.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app f U) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app g U) (X.presheaf.map (CategoryTheory.eqToHom ⋯).op))","decl":"theorem congr_app {X Y : Scheme} {f g : X ⟶ Y} (e : f = g) (U) :\n    f.app U = g.app U ≫ X.presheaf.map (eqToHom (by subst e; rfl)).op := by\n  subst e; dsimp; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.app_eq","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU V : Y.Opens\ne : Eq U V\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app f U) (CategoryTheory.CategoryStruct.comp (Y.presheaf.map (CategoryTheory.eqToHom ⋯).op) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f V) (X.presheaf.map (CategoryTheory.eqToHom ⋯).op)))","decl":"theorem app_eq {X Y : Scheme} (f : X ⟶ Y) {U V : Y.Opens} (e : U = V) :\n    f.app U =\n      Y.presheaf.map (eqToHom e.symm).op ≫\n        f.app V ≫\n          X.presheaf.map (eqToHom (congr_arg (Opens.map f.base).obj e)).op := by\n  rw [← IsIso.inv_comp_eq, ← Functor.map_inv, f.naturality]\n  cases e\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.eqToHom_c_app","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : Eq X Y\nU : Y.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app (CategoryTheory.eqToHom e) U) (CategoryTheory.eqToHom ⋯)","decl":"theorem eqToHom_c_app {X Y : Scheme} (e : X = Y) (U) :\n    (eqToHom e).app U = eqToHom (by subst e; rfl) := by subst e; rfl\n\n-- Porting note: in `AffineScheme.lean` file, `eqToHom_op` can't be used in `(e)rw` or `simp(_rw)`\n-- when terms get very complicated. See `AlgebraicGeometry.IsAffineOpen.isLocalization_stalk_aux`.\n"}
{"name":"AlgebraicGeometry.Scheme.presheaf_map_eqToHom_op","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ni : Eq U V\n⊢ Eq (X.presheaf.map (CategoryTheory.eqToHom i).op) (CategoryTheory.eqToHom ⋯)","decl":"lemma presheaf_map_eqToHom_op (X : Scheme) (U V : X.Opens) (i : U = V) :\n    X.presheaf.map (eqToHom i).op = eqToHom (i ▸ rfl) := by\n  rw [eqToHom_op, eqToHom_map]\n\n"}
{"name":"AlgebraicGeometry.Scheme.is_locallyRingedSpace_iso","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.Scheme.Hom.toLRSHom f)","decl":"instance is_locallyRingedSpace_iso {X Y : Scheme} (f : X ⟶ Y) [IsIso f] : IsIso f.toLRSHom :=\n  forgetToLocallyRingedSpace.map_isIso f\n\n"}
{"name":"AlgebraicGeometry.Scheme.base_isIso","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.IsIso f.base","decl":"instance base_isIso {X Y : Scheme.{u}} (f : X ⟶ Y) [IsIso f] : IsIso f.base :=\n  Scheme.forgetToTop.map_isIso f\n\n-- Porting note: need an extra instance here.\n"}
{"name":"AlgebraicGeometry.Scheme.instIsIsoCommRingCatAppOppositeOpensαTopologicalSpaceCarrierC","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\nU : Opposite (TopologicalSpace.Opens ↑↑Y.toPresheafedSpace)\n⊢ CategoryTheory.IsIso (f.c.app U)","decl":"instance {X Y : Scheme} (f : X ⟶ Y) [IsIso f] (U) : IsIso (f.c.app U) :=\n  haveI := PresheafedSpace.c_isIso_of_iso f.toPshHom\n  NatIso.isIso_app_of_isIso f.c _\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsIsoCommRingCatApp","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\nU : Y.Opens\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.Scheme.Hom.app f U)","decl":"instance {X Y : Scheme} (f : X ⟶ Y) [IsIso f] (U) : IsIso (f.app U) :=\n  haveI := PresheafedSpace.c_isIso_of_iso f.toPshHom\n  NatIso.isIso_app_of_isIso f.c _\n\n"}
{"name":"AlgebraicGeometry.Scheme.inv_app","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\nU : X.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app (CategoryTheory.inv f) U) (CategoryTheory.CategoryStruct.comp (X.presheaf.map (CategoryTheory.eqToHom ⋯).op) (CategoryTheory.inv (AlgebraicGeometry.Scheme.Hom.app f ((TopologicalSpace.Opens.map (CategoryTheory.inv f).base).obj U))))","decl":"@[simp]\ntheorem inv_app {X Y : Scheme} (f : X ⟶ Y) [IsIso f] (U : X.Opens) :\n    (inv f).app U =\n      X.presheaf.map (eqToHom (show (f ≫ inv f) ⁻¹ᵁ U = U by rw [IsIso.hom_inv_id]; rfl)).op ≫\n        inv (f.app ((inv f) ⁻¹ᵁ U)) := by\n  rw [IsIso.eq_comp_inv, ← Scheme.comp_app, Scheme.congr_app (IsIso.hom_inv_id f),\n    Scheme.id_app, Category.id_comp]\n\n"}
{"name":"AlgebraicGeometry.Scheme.inv_appTop","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appTop (CategoryTheory.inv f)) (CategoryTheory.inv (AlgebraicGeometry.Scheme.Hom.appTop f))","decl":"theorem inv_appTop {X Y : Scheme} (f : X ⟶ Y) [IsIso f] :\n    (inv f).appTop = inv (f.appTop) := by simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.inv_app_top","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appTop (CategoryTheory.inv f)) (CategoryTheory.inv (AlgebraicGeometry.Scheme.Hom.appTop f))","decl":"@[deprecated (since := \"2024-11-23\")] alias inv_app_top := inv_appTop\n\n"}
{"name":"AlgebraicGeometry.Spec_toLocallyRingedSpace","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec R).toLocallyRingedSpace (AlgebraicGeometry.Spec.locallyRingedSpaceObj R)","decl":"theorem Spec_toLocallyRingedSpace (R : CommRingCat) :\n    (Spec R).toLocallyRingedSpace = Spec.locallyRingedSpaceObj R :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.map_id","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec.map (CategoryTheory.CategoryStruct.id R)) (CategoryTheory.CategoryStruct.id (AlgebraicGeometry.Spec R))","decl":"@[simp]\ntheorem Spec.map_id (R : CommRingCat) : Spec.map (𝟙 R) = 𝟙 (Spec R) :=\n  Scheme.Hom.ext' <| Spec.locallyRingedSpaceMap_id R\n\n"}
{"name":"AlgebraicGeometry.Spec.map_comp_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S T : CommRingCat\nf : Quiver.Hom R S\ng : Quiver.Hom S T\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (AlgebraicGeometry.Spec R) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map g) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map f) h))","decl":"@[reassoc, simp]\ntheorem Spec.map_comp {R S T : CommRingCat} (f : R ⟶ S) (g : S ⟶ T) :\n    Spec.map (f ≫ g) = Spec.map g ≫ Spec.map f :=\n  Scheme.Hom.ext' <| Spec.locallyRingedSpaceMap_comp f g\n\n"}
{"name":"AlgebraicGeometry.Spec.map_comp","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S T : CommRingCat\nf : Quiver.Hom R S\ng : Quiver.Hom S T\n⊢ Eq (AlgebraicGeometry.Spec.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map g) (AlgebraicGeometry.Spec.map f))","decl":"@[reassoc, simp]\ntheorem Spec.map_comp {R S T : CommRingCat} (f : R ⟶ S) (g : S ⟶ T) :\n    Spec.map (f ≫ g) = Spec.map g ≫ Spec.map f :=\n  Scheme.Hom.ext' <| Spec.locallyRingedSpaceMap_comp f g\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_map","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X✝ Y✝ : Opposite CommRingCat\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (AlgebraicGeometry.Scheme.Spec.map f) (AlgebraicGeometry.Spec.map f.unop)","decl":"/-- The spectrum, as a contravariant functor from commutative rings to schemes. -/\n@[simps]\nprotected def Scheme.Spec : CommRingCatᵒᵖ ⥤ Scheme where\n  obj R := Spec (unop R)\n  map f := Spec.map f.unop\n  map_id R := by simp\n  map_comp f g := by simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_obj","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : Opposite CommRingCat\n⊢ Eq (AlgebraicGeometry.Scheme.Spec.obj R) (AlgebraicGeometry.Spec (Opposite.unop R))","decl":"/-- The spectrum, as a contravariant functor from commutative rings to schemes. -/\n@[simps]\nprotected def Scheme.Spec : CommRingCatᵒᵖ ⥤ Scheme where\n  obj R := Spec (unop R)\n  map f := Spec.map f.unop\n  map_id R := by simp\n  map_comp f g := by simp\n\n"}
{"name":"AlgebraicGeometry.Spec.map_eqToHom","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S : CommRingCat\ne : Eq R S\n⊢ Eq (AlgebraicGeometry.Spec.map (CategoryTheory.eqToHom e)) (CategoryTheory.eqToHom ⋯)","decl":"lemma Spec.map_eqToHom {R S : CommRingCat} (e : R = S) :\n    Spec.map (eqToHom e) = eqToHom (e ▸ rfl) := by\n  subst e; exact Spec.map_id _\n\n"}
{"name":"AlgebraicGeometry.instIsIsoSchemeMapOfCommRingCat","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.Spec.map f)","decl":"instance {R S : CommRingCat} (f : R ⟶ S) [IsIso f] : IsIso (Spec.map f) :=\n  inferInstanceAs (IsIso <| Scheme.Spec.map f.op)\n\n"}
{"name":"AlgebraicGeometry.Spec.map_inv","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\ninst✝ : CategoryTheory.IsIso f\n⊢ Eq (AlgebraicGeometry.Spec.map (CategoryTheory.inv f)) (CategoryTheory.inv (AlgebraicGeometry.Spec.map f))","decl":"@[simp]\nlemma Spec.map_inv {R S : CommRingCat} (f : R ⟶ S) [IsIso f] :\n    Spec.map (inv f) = inv (Spec.map f) := by\n  show Scheme.Spec.map (inv f).op = inv (Scheme.Spec.map f.op)\n  rw [op_inv, ← Scheme.Spec.map_inv]\n\n"}
{"name":"AlgebraicGeometry.Spec_carrier","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\n⊢ Eq (↑↑(AlgebraicGeometry.Spec R).toPresheafedSpace) (PrimeSpectrum ↑R)","decl":"lemma Spec_carrier (R : CommRingCat.{u}) : (Spec R).carrier = PrimeSpectrum R := rfl\n"}
{"name":"AlgebraicGeometry.Spec_sheaf","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec R).sheaf (AlgebraicGeometry.Spec.structureSheaf ↑R)","decl":"lemma Spec_sheaf (R : CommRingCat.{u}) : (Spec R).sheaf = Spec.structureSheaf R := rfl\n"}
{"name":"AlgebraicGeometry.Spec_presheaf","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Spec R).presheaf (AlgebraicGeometry.Spec.structureSheaf ↑R).val","decl":"lemma Spec_presheaf (R : CommRingCat.{u}) : (Spec R).presheaf = (Spec.structureSheaf R).1 := rfl\n"}
{"name":"AlgebraicGeometry.Spec.map_base","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\n⊢ Eq (AlgebraicGeometry.Spec.map f).base (PrimeSpectrum.comap (CommRingCat.Hom.hom f))","decl":"lemma Spec.map_base : (Spec.map f).base = PrimeSpectrum.comap f.hom := rfl\n"}
{"name":"AlgebraicGeometry.Spec.map_base_apply","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\nx : ↑↑(AlgebraicGeometry.Spec S).toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.Spec.map f).base x) ((PrimeSpectrum.comap (CommRingCat.Hom.hom f)) x)","decl":"lemma Spec.map_base_apply (x : Spec S) : (Spec.map f).base x = PrimeSpectrum.comap f.hom x := rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.map_app","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\nU : (AlgebraicGeometry.Spec R).Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app (AlgebraicGeometry.Spec.map f) U) (CommRingCat.ofHom (AlgebraicGeometry.StructureSheaf.comap (CommRingCat.Hom.hom f) U ((TopologicalSpace.Opens.map (AlgebraicGeometry.Spec.map f).base).obj U) ⋯))","decl":"lemma Spec.map_app (U) :\n    (Spec.map f).app U =\n      CommRingCat.ofHom (StructureSheaf.comap f.hom U (Spec.map f ⁻¹ᵁ U) le_rfl) := rfl\n\n"}
{"name":"AlgebraicGeometry.Spec.map_appLE","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\nU : (AlgebraicGeometry.Spec S).Opens\nV : (AlgebraicGeometry.Spec R).Opens\ne : LE.le U ((TopologicalSpace.Opens.map (AlgebraicGeometry.Spec.map f).base).obj V)\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appLE (AlgebraicGeometry.Spec.map f) V U e) (CommRingCat.ofHom (AlgebraicGeometry.StructureSheaf.comap (CommRingCat.Hom.hom f) V U e))","decl":"lemma Spec.map_appLE {U V} (e : U ≤ Spec.map f ⁻¹ᵁ V) :\n    (Spec.map f).appLE V U e = CommRingCat.ofHom (StructureSheaf.comap f.hom V U e) := rfl\n\n"}
{"name":"AlgebraicGeometry.instNonemptyαTopologicalSpaceCarrierCommRingCatSpecOfNontrivialCarrier","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"A : CommRingCat\ninst✝ : Nontrivial ↑A\n⊢ Nonempty ↑↑(AlgebraicGeometry.Spec A).toPresheafedSpace","decl":"instance {A : CommRingCat} [Nontrivial A] : Nonempty (Spec A) :=\n  inferInstanceAs <| Nonempty (PrimeSpectrum A)\n\n"}
{"name":"AlgebraicGeometry.Scheme.empty_carrier","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"⊢ Eq (↑AlgebraicGeometry.Scheme.empty.toPresheafedSpace) (TopCat.of PEmpty.{u_1 + 1})","decl":"/-- The empty scheme. -/\n@[simps]\ndef empty : Scheme where\n  carrier := TopCat.of PEmpty\n  presheaf := (CategoryTheory.Functor.const _).obj (CommRingCat.of PUnit)\n  IsSheaf := Presheaf.isSheaf_of_isTerminal _ CommRingCat.punitIsTerminal\n  isLocalRing x := PEmpty.elim x\n  local_affine x := PEmpty.elim x\n\n"}
{"name":"AlgebraicGeometry.Scheme.empty_presheaf","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"⊢ Eq AlgebraicGeometry.Scheme.empty.presheaf ((CategoryTheory.Functor.const (Opposite (TopologicalSpace.Opens ↑(TopCat.of PEmpty.{u_1 + 1})))).obj (CommRingCat.of PUnit.{u_1 + 1}))","decl":"/-- The empty scheme. -/\n@[simps]\ndef empty : Scheme where\n  carrier := TopCat.of PEmpty\n  presheaf := (CategoryTheory.Functor.const _).obj (CommRingCat.of PUnit)\n  IsSheaf := Presheaf.isSheaf_of_isTerminal _ CommRingCat.punitIsTerminal\n  isLocalRing x := PEmpty.elim x\n  local_affine x := PEmpty.elim x\n\n"}
{"name":"AlgebraicGeometry.Scheme.Γ_def","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"⊢ Eq AlgebraicGeometry.Scheme.Γ (AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace.op.comp AlgebraicGeometry.LocallyRingedSpace.Γ)","decl":"theorem Γ_def : Γ = Scheme.forgetToLocallyRingedSpace.op ⋙ LocallyRingedSpace.Γ :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Γ_obj","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : Opposite AlgebraicGeometry.Scheme\n⊢ Eq (AlgebraicGeometry.Scheme.Γ.obj X) ((Opposite.unop X).presheaf.obj { unop := Top.top })","decl":"@[simp]\ntheorem Γ_obj (X : Schemeᵒᵖ) : Γ.obj X = Γ(unop X, ⊤) :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Γ_obj_op","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Eq (AlgebraicGeometry.Scheme.Γ.obj { unop := X }) (X.presheaf.obj { unop := Top.top })","decl":"theorem Γ_obj_op (X : Scheme) : Γ.obj (op X) = Γ(X, ⊤) :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Γ_map","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : Opposite AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Eq (AlgebraicGeometry.Scheme.Γ.map f) (AlgebraicGeometry.Scheme.Hom.appTop f.unop)","decl":"@[simp]\ntheorem Γ_map {X Y : Schemeᵒᵖ} (f : X ⟶ Y) : Γ.map f = f.unop.appTop :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Γ_map_op","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Eq (AlgebraicGeometry.Scheme.Γ.map f.op) (AlgebraicGeometry.Scheme.Hom.appTop f)","decl":"theorem Γ_map_op {X Y : Scheme} (f : X ⟶ Y) : Γ.map f.op = f.appTop :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.SpecΓIdentity_app","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Scheme.SpecΓIdentity.app R) (AlgebraicGeometry.Scheme.ΓSpecIso R)","decl":"@[simp] lemma SpecΓIdentity_app : SpecΓIdentity.app R = ΓSpecIso R := rfl\n"}
{"name":"AlgebraicGeometry.Scheme.SpecΓIdentity_hom_app","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Scheme.SpecΓIdentity.hom.app R) (AlgebraicGeometry.Scheme.ΓSpecIso R).hom","decl":"@[simp] lemma SpecΓIdentity_hom_app : SpecΓIdentity.hom.app R = (ΓSpecIso R).hom := rfl\n"}
{"name":"AlgebraicGeometry.Scheme.SpecΓIdentity_inv_app","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Scheme.SpecΓIdentity.inv.app R) (AlgebraicGeometry.Scheme.ΓSpecIso R).inv","decl":"@[simp] lemma SpecΓIdentity_inv_app : SpecΓIdentity.inv.app R = (ΓSpecIso R).inv := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.ΓSpecIso_naturality","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appTop (AlgebraicGeometry.Spec.map f)) (AlgebraicGeometry.Scheme.ΓSpecIso S).hom) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ΓSpecIso R).hom f)","decl":"@[reassoc (attr := simp)]\nlemma ΓSpecIso_naturality {R S : CommRingCat.{u}} (f : R ⟶ S) :\n    (Spec.map f).appTop ≫ (ΓSpecIso S).hom = (ΓSpecIso R).hom ≫ f := SpecΓIdentity.hom.naturality f\n\n-- The RHS is not necessarily simpler than the LHS, but this direction coincides with the simp\n-- direction of `NatTrans.naturality`.\n"}
{"name":"AlgebraicGeometry.Scheme.ΓSpecIso_naturality_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\nZ : CommRingCat\nh : Quiver.Hom S Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appTop (AlgebraicGeometry.Spec.map f)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ΓSpecIso S).hom h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ΓSpecIso R).hom (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma ΓSpecIso_naturality {R S : CommRingCat.{u}} (f : R ⟶ S) :\n    (Spec.map f).appTop ≫ (ΓSpecIso S).hom = (ΓSpecIso R).hom ≫ f := SpecΓIdentity.hom.naturality f\n\n-- The RHS is not necessarily simpler than the LHS, but this direction coincides with the simp\n-- direction of `NatTrans.naturality`.\n"}
{"name":"AlgebraicGeometry.Scheme.ΓSpecIso_inv_naturality_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\nZ : CommRingCat\nh : Quiver.Hom ((AlgebraicGeometry.Spec S).presheaf.obj { unop := Top.top }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ΓSpecIso S).inv h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ΓSpecIso R).inv (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appTop (AlgebraicGeometry.Spec.map f)) h))","decl":"@[reassoc (attr := simp)]\nlemma ΓSpecIso_inv_naturality {R S : CommRingCat.{u}} (f : R ⟶ S) :\n    f ≫ (ΓSpecIso S).inv = (ΓSpecIso R).inv ≫ (Spec.map f).appTop := SpecΓIdentity.inv.naturality f\n\n-- This is not marked simp to respect the abstraction\n"}
{"name":"AlgebraicGeometry.Scheme.ΓSpecIso_inv_naturality","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (AlgebraicGeometry.Scheme.ΓSpecIso S).inv) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ΓSpecIso R).inv (AlgebraicGeometry.Scheme.Hom.appTop (AlgebraicGeometry.Spec.map f)))","decl":"@[reassoc (attr := simp)]\nlemma ΓSpecIso_inv_naturality {R S : CommRingCat.{u}} (f : R ⟶ S) :\n    f ≫ (ΓSpecIso S).inv = (ΓSpecIso R).inv ≫ (Spec.map f).appTop := SpecΓIdentity.inv.naturality f\n\n-- This is not marked simp to respect the abstraction\n"}
{"name":"AlgebraicGeometry.Scheme.ΓSpecIso_inv","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\n⊢ Eq (AlgebraicGeometry.Scheme.ΓSpecIso R).inv (AlgebraicGeometry.StructureSheaf.toOpen (↑R) Top.top)","decl":"lemma ΓSpecIso_inv : (ΓSpecIso R).inv = StructureSheaf.toOpen R ⊤ := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.toOpen_eq","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\nU : TopologicalSpace.Opens ↑(AlgebraicGeometry.PrimeSpectrum.Top ↑R)\n⊢ Eq (AlgebraicGeometry.StructureSheaf.toOpen (↑R) U) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.ΓSpecIso R).inv ((AlgebraicGeometry.Spec R).presheaf.map (CategoryTheory.homOfLE ⋯).op))","decl":"lemma toOpen_eq (U) :\n    (by exact StructureSheaf.toOpen R U) =\n    (ΓSpecIso R).inv ≫ (Spec R).presheaf.map (homOfLE le_top).op := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.default_asIdeal","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ Eq Inhabited.default.asIdeal Bot.bot","decl":"@[simp]\nlemma default_asIdeal {K} [Field K] : (default : Spec (.of K)).asIdeal = ⊥ := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.mem_basicOpen","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nf : ↑(X.presheaf.obj { unop := U })\nx : ↑↑X.toPresheafedSpace\nhx : Membership.mem U x\n⊢ Iff (Membership.mem (X.basicOpen f) x) (IsUnit ((CategoryTheory.ConcreteCategory.hom (X.presheaf.germ U x hx)) f))","decl":"theorem mem_basicOpen (x : X) (hx : x ∈ U) :\n    x ∈ X.basicOpen f ↔ IsUnit (X.presheaf.germ U x hx f) :=\n  RingedSpace.mem_basicOpen _ _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.mem_basicOpen'","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nf : ↑(X.presheaf.obj { unop := U })\nx : Subtype fun x => Membership.mem U x\n⊢ Iff (Membership.mem (X.basicOpen f) ↑x) (IsUnit ((CategoryTheory.ConcreteCategory.hom (X.presheaf.germ U ↑x ⋯)) f))","decl":"/-- A variant of `mem_basicOpen` for bundled `x : U`. -/\n@[simp]\ntheorem mem_basicOpen' (x : U) : ↑x ∈ X.basicOpen f ↔ IsUnit (X.presheaf.germ U x x.2 f) :=\n  RingedSpace.mem_basicOpen _ _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.mem_basicOpen''","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nf : ↑(X.presheaf.obj { unop := U })\nx : ↑↑X.toPresheafedSpace\n⊢ Iff (Membership.mem (X.basicOpen f) x) (Exists fun m => IsUnit ((CategoryTheory.ConcreteCategory.hom (X.presheaf.germ U x m)) f))","decl":"/-- A variant of `mem_basicOpen` without the `x ∈ U` assumption. -/\ntheorem mem_basicOpen'' {U : X.Opens} (f : Γ(X, U)) (x : X) :\n    x ∈ X.basicOpen f ↔ ∃ (m : x ∈ U), IsUnit (X.presheaf.germ U x m f) :=\n  Iff.rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.mem_basicOpen_top","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nf : ↑(X.presheaf.obj { unop := Top.top })\nx : ↑↑X.toPresheafedSpace\n⊢ Iff (Membership.mem (X.basicOpen f) x) (IsUnit ((CategoryTheory.ConcreteCategory.hom (X.presheaf.germ Top.top x trivial)) f))","decl":"@[simp]\ntheorem mem_basicOpen_top (f : Γ(X, ⊤)) (x : X) :\n    x ∈ X.basicOpen f ↔ IsUnit (X.presheaf.germ ⊤ x trivial f) :=\n  RingedSpace.mem_top_basicOpen _ f x\n\n"}
{"name":"AlgebraicGeometry.Scheme.basicOpen_res","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nV U : X.Opens\nf : ↑(X.presheaf.obj { unop := U })\ni : Quiver.Hom { unop := U } { unop := V }\n⊢ Eq (X.basicOpen ((CategoryTheory.ConcreteCategory.hom (X.presheaf.map i)) f)) (Min.min V (X.basicOpen f))","decl":"@[simp]\ntheorem basicOpen_res (i : op U ⟶ op V) : X.basicOpen (X.presheaf.map i f) = V ⊓ X.basicOpen f :=\n  RingedSpace.basicOpen_res _ i f\n\n-- This should fire before `basicOpen_res`.\n"}
{"name":"AlgebraicGeometry.Scheme.basicOpen_res_eq","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nV U : X.Opens\nf : ↑(X.presheaf.obj { unop := U })\ni : Quiver.Hom { unop := U } { unop := V }\ninst✝ : CategoryTheory.IsIso i\n⊢ Eq (X.basicOpen ((CategoryTheory.ConcreteCategory.hom (X.presheaf.map i)) f)) (X.basicOpen f)","decl":"@[simp 1100]\ntheorem basicOpen_res_eq (i : op U ⟶ op V) [IsIso i] :\n    X.basicOpen (X.presheaf.map i f) = X.basicOpen f :=\n  RingedSpace.basicOpen_res_eq _ i f\n\n"}
{"name":"AlgebraicGeometry.Scheme.basicOpen_le","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nf : ↑(X.presheaf.obj { unop := U })\n⊢ LE.le (X.basicOpen f) U","decl":"@[sheaf_restrict]\ntheorem basicOpen_le : X.basicOpen f ≤ U :=\n  RingedSpace.basicOpen_le _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.basicOpen_restrict","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nV U : X.Opens\ni : Quiver.Hom V U\nf : ↑(X.presheaf.obj { unop := U })\n⊢ LE.le (X.basicOpen (TopCat.Presheaf.restrict f i)) (X.basicOpen f)","decl":"@[sheaf_restrict]\nlemma basicOpen_restrict (i : V ⟶ U) (f : Γ(X, U)) :\n    X.basicOpen (TopCat.Presheaf.restrict f i) ≤ X.basicOpen f :=\n  (Scheme.basicOpen_res _ _ _).trans_le inf_le_right\n\n"}
{"name":"AlgebraicGeometry.Scheme.preimage_basicOpen","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nr : ↑(Y.presheaf.obj { unop := U })\n⊢ Eq ((TopologicalSpace.Opens.map f.base).obj (Y.basicOpen r)) (X.basicOpen ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app f U)) r))","decl":"@[simp]\ntheorem preimage_basicOpen {X Y : Scheme.{u}} (f : X ⟶ Y) {U : Y.Opens} (r : Γ(Y, U)) :\n    f ⁻¹ᵁ (Y.basicOpen r) = X.basicOpen (f.app U r) :=\n  LocallyRingedSpace.preimage_basicOpen f.toLRSHom r\n\n"}
{"name":"AlgebraicGeometry.Scheme.preimage_basicOpen_top","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nr : ↑(Y.presheaf.obj { unop := Top.top })\n⊢ Eq ((TopologicalSpace.Opens.map f.base).obj (Y.basicOpen r)) (X.basicOpen ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appTop f)) r))","decl":"theorem preimage_basicOpen_top {X Y : Scheme.{u}} (f : X ⟶ Y) (r : Γ(Y, ⊤)) :\n    f ⁻¹ᵁ (Y.basicOpen r) = X.basicOpen (f.appTop r) :=\n  preimage_basicOpen ..\n\n"}
{"name":"AlgebraicGeometry.Scheme.basicOpen_appLE","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : X.Opens\nV : Y.Opens\ne : LE.le U ((TopologicalSpace.Opens.map f.base).obj V)\ns : ↑(Y.presheaf.obj { unop := V })\n⊢ Eq (X.basicOpen ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appLE f V U e)) s)) (Min.min U ((TopologicalSpace.Opens.map f.base).obj (Y.basicOpen s)))","decl":"lemma basicOpen_appLE {X Y : Scheme.{u}} (f : X ⟶ Y) (U : X.Opens) (V : Y.Opens) (e : U ≤ f ⁻¹ᵁ V)\n    (s : Γ(Y, V)) : X.basicOpen (f.appLE V U e s) = U ⊓ f ⁻¹ᵁ (Y.basicOpen s) := by\n  simp only [preimage_basicOpen, Hom.appLE, CommRingCat.comp_apply, RingHom.coe_comp,\n    Function.comp_apply]\n  rw [basicOpen_res]\n\n"}
{"name":"AlgebraicGeometry.Scheme.basicOpen_zero","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (X.basicOpen 0) Bot.bot","decl":"@[simp]\ntheorem basicOpen_zero (U : X.Opens) : X.basicOpen (0 : Γ(X, U)) = ⊥ :=\n  LocallyRingedSpace.basicOpen_zero _ U\n\n"}
{"name":"AlgebraicGeometry.Scheme.basicOpen_mul","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nf g : ↑(X.presheaf.obj { unop := U })\n⊢ Eq (X.basicOpen (HMul.hMul f g)) (Min.min (X.basicOpen f) (X.basicOpen g))","decl":"@[simp]\ntheorem basicOpen_mul : X.basicOpen (f * g) = X.basicOpen f ⊓ X.basicOpen g :=\n  RingedSpace.basicOpen_mul _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.basicOpen_pow","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nf : ↑(X.presheaf.obj { unop := U })\nn : Nat\nh : LT.lt 0 n\n⊢ Eq (X.basicOpen (HPow.hPow f n)) (X.basicOpen f)","decl":"lemma basicOpen_pow {n : ℕ} (h : 0 < n) : X.basicOpen (f ^ n) = X.basicOpen f :=\n  RingedSpace.basicOpen_pow _ _ _ h\n\n"}
{"name":"AlgebraicGeometry.Scheme.basicOpen_add_le","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nf g : ↑(X.presheaf.obj { unop := U })\n⊢ LE.le (X.basicOpen (HAdd.hAdd f g)) (Max.max (X.basicOpen f) (X.basicOpen g))","decl":"lemma basicOpen_add_le :\n    X.basicOpen (f + g) ≤ X.basicOpen f ⊔ X.basicOpen g := by\n  intro x hx\n  have hxU : x ∈ U := X.basicOpen_le _ hx\n  simp only [SetLike.mem_coe, Scheme.mem_basicOpen _ _ _ hxU, map_add, Opens.coe_sup,\n    Set.mem_union] at hx ⊢\n  exact IsLocalRing.isUnit_or_isUnit_of_isUnit_add hx\n\n"}
{"name":"AlgebraicGeometry.Scheme.basicOpen_of_isUnit","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nf : ↑(X.presheaf.obj { unop := U })\nhf : IsUnit f\n⊢ Eq (X.basicOpen f) U","decl":"theorem basicOpen_of_isUnit {f : Γ(X, U)} (hf : IsUnit f) : X.basicOpen f = U :=\n  RingedSpace.basicOpen_of_isUnit _ hf\n\n"}
{"name":"AlgebraicGeometry.Scheme.basicOpen_one","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (X.basicOpen 1) U","decl":"@[simp]\ntheorem basicOpen_one : X.basicOpen (1 : Γ(X, U)) = U :=\n  X.basicOpen_of_isUnit isUnit_one\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_def","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ns : Set ↑(X.presheaf.obj { unop := U })\n⊢ Eq (X.zeroLocus s) (Set.iInter fun f => Set.iInter fun h => HasCompl.compl (X.basicOpen f).carrier)","decl":"lemma zeroLocus_def {U : X.Opens} (s : Set Γ(X, U)) :\n    X.zeroLocus s = ⋂ f ∈ s, (X.basicOpen f).carrierᶜ :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_isClosed","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ns : Set ↑(X.presheaf.obj { unop := U })\n⊢ IsClosed (X.zeroLocus s)","decl":"lemma zeroLocus_isClosed {U : X.Opens} (s : Set Γ(X, U)) :\n    IsClosed (X.zeroLocus s) :=\n  X.toRingedSpace.zeroLocus_isClosed s\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_singleton","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nf : ↑(X.presheaf.obj { unop := U })\n⊢ Eq (X.zeroLocus (Singleton.singleton f)) (HasCompl.compl (X.basicOpen f).carrier)","decl":"lemma zeroLocus_singleton {U : X.Opens} (f : Γ(X, U)) :\n    X.zeroLocus {f} = (X.basicOpen f).carrierᶜ :=\n  X.toRingedSpace.zeroLocus_singleton f\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_empty_eq_univ","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (X.zeroLocus EmptyCollection.emptyCollection) Set.univ","decl":"@[simp]\nlemma zeroLocus_empty_eq_univ {U : X.Opens} :\n    X.zeroLocus (∅ : Set Γ(X, U)) = Set.univ :=\n  X.toRingedSpace.zeroLocus_empty_eq_univ\n\n"}
{"name":"AlgebraicGeometry.Scheme.mem_zeroLocus_iff","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ns : Set ↑(X.presheaf.obj { unop := U })\nx : ↑↑X.toPresheafedSpace\n⊢ Iff (Membership.mem (X.zeroLocus s) x) (∀ (f : ↑(X.presheaf.obj { unop := U })), Membership.mem s f → Not (Membership.mem (X.basicOpen f) x))","decl":"@[simp]\nlemma mem_zeroLocus_iff {U : X.Opens} (s : Set Γ(X, U)) (x : X) :\n    x ∈ X.zeroLocus s ↔ ∀ f ∈ s, x ∉ X.basicOpen f :=\n  X.toRingedSpace.mem_zeroLocus_iff s x\n\n"}
{"name":"AlgebraicGeometry.Scheme.codisjoint_zeroLocus","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ns : Set ↑(X.presheaf.obj { unop := U })\n⊢ Codisjoint (X.zeroLocus s) ↑U","decl":"lemma codisjoint_zeroLocus {U : X.Opens}\n    (s : Set Γ(X, U)) : Codisjoint (X.zeroLocus s) U := by\n  have (x : X) : ∀ f ∈ s, x ∈ X.basicOpen f → x ∈ U := fun _ _ h ↦ X.basicOpen_le _ h\n  simpa [codisjoint_iff_le_sup, Set.ext_iff, or_iff_not_imp_left]\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_span","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ns : Set ↑(X.presheaf.obj { unop := U })\n⊢ Eq (X.zeroLocus ↑(Ideal.span s)) (X.zeroLocus s)","decl":"lemma zeroLocus_span {U : X.Opens} (s : Set Γ(X, U)) :\n    X.zeroLocus (U := U) (Ideal.span s) = X.zeroLocus s := by\n  ext x\n  simp only [Scheme.mem_zeroLocus_iff, SetLike.mem_coe]\n  refine ⟨fun H f hfs ↦ H f (Ideal.subset_span hfs), fun H f ↦ Submodule.span_induction H ?_ ?_ ?_⟩\n  · simp only [Scheme.basicOpen_zero]; exact not_false\n  · exact fun a b _ _ ha hb H ↦ (X.basicOpen_add_le a b H).elim ha hb\n  · simp +contextual\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_map","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ni : LE.le U V\ns : Set ↑(X.presheaf.obj { unop := V })\n⊢ Eq (X.zeroLocus (Set.image (⇑(CommRingCat.Hom.hom (X.presheaf.map (CategoryTheory.homOfLE i).op))) s)) (Union.union (X.zeroLocus s) (HasCompl.compl ↑U))","decl":"lemma zeroLocus_map {U V : X.Opens} (i : U ≤ V) (s : Set Γ(X, V)) :\n    X.zeroLocus ((X.presheaf.map (homOfLE i).op).hom '' s) = X.zeroLocus s ∪ Uᶜ := by\n  ext x\n  suffices (∀ f ∈ s, x ∈ U → x ∉ X.basicOpen f) ↔ x ∈ U → (∀ f ∈ s, x ∉ X.basicOpen f) by\n    simpa [or_iff_not_imp_right]\n  conv_lhs => enter [i]; rw [forall_comm (β := x ∈ U)] -- why doesn't simp fire on this\n  rw [forall_comm (β := x ∈ U)]\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_map_of_eq","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ni : Eq U V\ns : Set ↑(X.presheaf.obj { unop := V })\n⊢ Eq (X.zeroLocus (Set.image (⇑(CommRingCat.Hom.hom (X.presheaf.map (CategoryTheory.eqToHom i).op))) s)) (X.zeroLocus s)","decl":"lemma zeroLocus_map_of_eq {U V : X.Opens} (i : U = V) (s : Set Γ(X, V)) :\n    X.zeroLocus ((X.presheaf.map (eqToHom i).op).hom '' s) = X.zeroLocus s := by\n  ext; simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_mono","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ns t : Set ↑(X.presheaf.obj { unop := U })\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (X.zeroLocus t) (X.zeroLocus s)","decl":"lemma zeroLocus_mono {U : X.Opens} {s t : Set Γ(X, U)} (h : s ⊆ t) :\n    X.zeroLocus t ⊆ X.zeroLocus s := by\n  simp only [Set.subset_def, Scheme.mem_zeroLocus_iff]\n  exact fun x H f hf hxf ↦ H f (h hf) hxf\n\n"}
{"name":"AlgebraicGeometry.Scheme.preimage_zeroLocus","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\ns : Set ↑(Y.presheaf.obj { unop := U })\n⊢ Eq (Set.preimage (⇑f.base) (Y.zeroLocus s)) (X.zeroLocus (Set.image (⇑(CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.app f U))) s))","decl":"lemma preimage_zeroLocus {X Y : Scheme.{u}} (f : X ⟶ Y) {U : Y.Opens} (s : Set Γ(Y, U)) :\n    f.base ⁻¹' Y.zeroLocus s = X.zeroLocus ((f.app U).hom '' s) := by\n  ext\n  simp [← Scheme.preimage_basicOpen]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.zeroLocus_univ","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (X.zeroLocus Set.univ) (HasCompl.compl ↑U)","decl":"@[simp]\nlemma zeroLocus_univ {U : X.Opens} :\n    X.zeroLocus (U := U) Set.univ = (↑U)ᶜ := by\n  ext x\n  simp only [Scheme.mem_zeroLocus_iff, Set.mem_univ, forall_const, Set.mem_compl_iff,\n    SetLike.mem_coe, ← not_exists, not_iff_not]\n  exact ⟨fun ⟨f, hf⟩ ↦ X.basicOpen_le f hf, fun _ ↦ ⟨1, by rwa [X.basicOpen_of_isUnit isUnit_one]⟩⟩\n\n"}
{"name":"AlgebraicGeometry.basicOpen_eq_of_affine","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\nf : ↑R\n⊢ Eq ((AlgebraicGeometry.Spec R).basicOpen ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.ΓSpecIso R).inv) f)) (PrimeSpectrum.basicOpen f)","decl":"theorem basicOpen_eq_of_affine {R : CommRingCat} (f : R) :\n    (Spec R).basicOpen ((Scheme.ΓSpecIso R).inv f) = PrimeSpectrum.basicOpen f := by\n  ext x\n  simp only [SetLike.mem_coe, Scheme.mem_basicOpen_top, Opens.coe_top]\n  suffices IsUnit (StructureSheaf.toStalk R x f) ↔ f ∉ PrimeSpectrum.asIdeal x by exact this\n  rw [← isUnit_map_iff (StructureSheaf.stalkToFiberRingHom R x).hom,\n    StructureSheaf.stalkToFiberRingHom_toStalk]\n  exact\n    (IsLocalization.AtPrime.isUnit_to_map_iff (Localization.AtPrime (PrimeSpectrum.asIdeal x))\n        (PrimeSpectrum.asIdeal x) f :\n      _)\n\n"}
{"name":"AlgebraicGeometry.basicOpen_eq_of_affine'","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\nf : ↑((AlgebraicGeometry.Spec R).presheaf.obj { unop := Top.top })\n⊢ Eq ((AlgebraicGeometry.Spec R).basicOpen f) (PrimeSpectrum.basicOpen ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.ΓSpecIso R).hom) f))","decl":"@[simp]\ntheorem basicOpen_eq_of_affine' {R : CommRingCat} (f : Γ(Spec R, ⊤)) :\n    (Spec R).basicOpen f = PrimeSpectrum.basicOpen ((Scheme.ΓSpecIso R).hom f) := by\n  convert basicOpen_eq_of_affine ((Scheme.ΓSpecIso R).hom f)\n  exact (Iso.hom_inv_id_apply (Scheme.ΓSpecIso R) f).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.Spec_map_presheaf_map_eqToHom","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\nh : Eq U V\nW : (AlgebraicGeometry.Spec (X.presheaf.obj { unop := V })).Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app (AlgebraicGeometry.Spec.map (X.presheaf.map (CategoryTheory.eqToHom h).op)) W) (CategoryTheory.eqToHom ⋯)","decl":"theorem Scheme.Spec_map_presheaf_map_eqToHom {X : Scheme} {U V : X.Opens} (h : U = V) (W) :\n    (Spec.map (X.presheaf.map (eqToHom h).op)).app W = eqToHom (by cases h; dsimp; simp) := by\n  have : Scheme.Spec.map (X.presheaf.map (𝟙 (op U))).op = 𝟙 _ := by\n    rw [X.presheaf.map_id, op_id, Scheme.Spec.map_id]\n  cases h\n  refine (Scheme.congr_app this _).trans ?_\n  simp [eqToHom_map]\n\n"}
{"name":"AlgebraicGeometry.germ_eq_zero_of_pow_mul_eq_zero","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nU : TopologicalSpace.Opens ↑↑X.toPresheafedSpace\nx : Subtype fun x => Membership.mem U x\nf s : ↑(X.presheaf.obj { unop := U })\nhx : Membership.mem (X.basicOpen s) ↑x\nn : Nat\nhf : Eq (HMul.hMul (HPow.hPow s n) f) 0\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (X.presheaf.germ U ↑x ⋯)) f) 0","decl":"lemma germ_eq_zero_of_pow_mul_eq_zero {X : Scheme.{u}} {U : Opens X} (x : U) {f s : Γ(X, U)}\n    (hx : x.val ∈ X.basicOpen s) {n : ℕ} (hf : s ^ n * f = 0) : X.presheaf.germ U x x.2 f = 0 := by\n  rw [Scheme.mem_basicOpen] at hx\n  have hu : IsUnit (X.presheaf.germ _ x x.2 (s ^ n)) := by\n    rw [map_pow]\n    exact IsUnit.pow n hx\n  rw [← hu.mul_right_eq_zero, ← map_mul, hf, map_zero]\n\n"}
{"name":"AlgebraicGeometry.Scheme.iso_hom_base_inv_base","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp e.hom.base e.inv.base) (CategoryTheory.CategoryStruct.id ↑X.toPresheafedSpace)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.iso_hom_base_inv_base {X Y : Scheme.{u}} (e : X ≅ Y) :\n    e.hom.base ≫ e.inv.base = 𝟙 _ :=\n  LocallyRingedSpace.iso_hom_base_inv_base (Scheme.forgetToLocallyRingedSpace.mapIso e)\n\n"}
{"name":"AlgebraicGeometry.Scheme.iso_hom_base_inv_base_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\nZ : TopCat\nh : Quiver.Hom (↑X.toPresheafedSpace) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp e.hom.base (CategoryTheory.CategoryStruct.comp e.inv.base h)) h","decl":"@[reassoc (attr := simp)]\nlemma Scheme.iso_hom_base_inv_base {X Y : Scheme.{u}} (e : X ≅ Y) :\n    e.hom.base ≫ e.inv.base = 𝟙 _ :=\n  LocallyRingedSpace.iso_hom_base_inv_base (Scheme.forgetToLocallyRingedSpace.mapIso e)\n\n"}
{"name":"AlgebraicGeometry.Scheme.iso_hom_base_inv_base_apply","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (e.inv.base (e.hom.base x)) x","decl":"@[simp]\nlemma Scheme.iso_hom_base_inv_base_apply {X Y : Scheme.{u}} (e : X ≅ Y) (x : X) :\n    (e.inv.base (e.hom.base x)) = x := by\n  show (e.hom.base ≫ e.inv.base) x = 𝟙 X.toPresheafedSpace x\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.iso_inv_base_hom_base","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp e.inv.base e.hom.base) (CategoryTheory.CategoryStruct.id ↑Y.toPresheafedSpace)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.iso_inv_base_hom_base {X Y : Scheme.{u}} (e : X ≅ Y) :\n    e.inv.base ≫ e.hom.base = 𝟙 _ :=\n  LocallyRingedSpace.iso_inv_base_hom_base (Scheme.forgetToLocallyRingedSpace.mapIso e)\n\n"}
{"name":"AlgebraicGeometry.Scheme.iso_inv_base_hom_base_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\nZ : TopCat\nh : Quiver.Hom (↑Y.toPresheafedSpace) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp e.inv.base (CategoryTheory.CategoryStruct.comp e.hom.base h)) h","decl":"@[reassoc (attr := simp)]\nlemma Scheme.iso_inv_base_hom_base {X Y : Scheme.{u}} (e : X ≅ Y) :\n    e.inv.base ≫ e.hom.base = 𝟙 _ :=\n  LocallyRingedSpace.iso_inv_base_hom_base (Scheme.forgetToLocallyRingedSpace.mapIso e)\n\n"}
{"name":"AlgebraicGeometry.Scheme.iso_inv_base_hom_base_apply","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\ny : ↑↑Y.toPresheafedSpace\n⊢ Eq (e.hom.base (e.inv.base y)) y","decl":"@[simp]\nlemma Scheme.iso_inv_base_hom_base_apply {X Y : Scheme.{u}} (e : X ≅ Y) (y : Y) :\n    (e.hom.base (e.inv.base y)) = y := by\n  show (e.inv.base ≫ e.hom.base) y = 𝟙 Y.toPresheafedSpace y\n  simp\n\n"}
{"name":"AlgebraicGeometry.Spec_zeroLocus_eq_zeroLocus","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\ns : Set ↑R\n⊢ Eq ((AlgebraicGeometry.Spec R).zeroLocus (Set.image (⇑(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.ΓSpecIso R).inv)) s)) (PrimeSpectrum.zeroLocus s)","decl":"theorem Spec_zeroLocus_eq_zeroLocus {R : CommRingCat} (s : Set R) :\n    (Spec R).zeroLocus ((Scheme.ΓSpecIso R).inv '' s) = PrimeSpectrum.zeroLocus s := by\n  ext x\n  suffices (∀ a ∈ s, x ∉ PrimeSpectrum.basicOpen a) ↔ x ∈ PrimeSpectrum.zeroLocus s by simpa\n  simp [Spec_carrier, PrimeSpectrum.mem_zeroLocus, Set.subset_def,\n    PrimeSpectrum.mem_basicOpen _ x]\n\n"}
{"name":"AlgebraicGeometry.Spec_zeroLocus","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R : CommRingCat\ns : Set ↑((AlgebraicGeometry.Spec R).presheaf.obj { unop := Top.top })\n⊢ Eq ((AlgebraicGeometry.Spec R).zeroLocus s) (PrimeSpectrum.zeroLocus (Set.preimage (⇑(CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.ΓSpecIso R).inv)) s))","decl":"@[simp]\ntheorem Spec_zeroLocus {R : CommRingCat} (s : Set Γ(Spec R, ⊤)) :\n    (Spec R).zeroLocus s = PrimeSpectrum.zeroLocus ((Scheme.ΓSpecIso R).inv ⁻¹' s) := by\n  convert Spec_zeroLocus_eq_zeroLocus ((Scheme.ΓSpecIso R).inv ⁻¹' s)\n  rw [Set.image_preimage_eq]\n  exact (ConcreteCategory.bijective_of_isIso (C := CommRingCat) _).2\n"}
{"name":"AlgebraicGeometry.Scheme.instIsLocalHomCarrierStalkCommRingCatPresheafCoeHomTopCatCarrierαTopologicalSpaceBaseRingHomHomStalkMap","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nx : ↑↑X.toPresheafedSpace\n⊢ IsLocalHom (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x))","decl":"instance (x) : IsLocalHom (f.stalkMap x).hom :=\n  f.prop x\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_id","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.stalkMap (CategoryTheory.CategoryStruct.id X) x) (CategoryTheory.CategoryStruct.id (X.presheaf.stalk x))","decl":"@[simp]\nlemma stalkMap_id (X : Scheme.{u}) (x : X) :\n    (𝟙 X : X ⟶ X).stalkMap x = 𝟙 (X.presheaf.stalk x) :=\n  PresheafedSpace.stalkMap.id _ x\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_comp","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.stalkMap (CategoryTheory.CategoryStruct.comp f g) x) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap g (f.base x)) (AlgebraicGeometry.Scheme.Hom.stalkMap f x))","decl":"lemma stalkMap_comp {X Y Z : Scheme.{u}} (f : X ⟶ Y) (g : Y ⟶ Z) (x : X) :\n    (f ≫ g : X ⟶ Z).stalkMap x = g.stalkMap (f.base x) ≫ f.stalkMap x :=\n  PresheafedSpace.stalkMap.comp f.toPshHom g.toPshHom x\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkSpecializes_stalkMap","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nx x' : ↑↑X.toPresheafedSpace\nh : Specializes x x'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkSpecializes ⋯) (AlgebraicGeometry.Scheme.Hom.stalkMap f x)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap f x') (X.presheaf.stalkSpecializes h))","decl":"@[reassoc]\nlemma stalkSpecializes_stalkMap (x x' : X)\n    (h : x ⤳ x') : Y.presheaf.stalkSpecializes (f.base.map_specializes h) ≫ f.stalkMap x =\n      f.stalkMap x' ≫ X.presheaf.stalkSpecializes h :=\n  PresheafedSpace.stalkMap.stalkSpecializes_stalkMap f.toPshHom h\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkSpecializes_stalkMap_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nx x' : ↑↑X.toPresheafedSpace\nh✝ : Specializes x x'\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.stalk x) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkSpecializes ⋯) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap f x) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap f x') (CategoryTheory.CategoryStruct.comp (X.presheaf.stalkSpecializes h✝) h))","decl":"@[reassoc]\nlemma stalkSpecializes_stalkMap (x x' : X)\n    (h : x ⤳ x') : Y.presheaf.stalkSpecializes (f.base.map_specializes h) ≫ f.stalkMap x =\n      f.stalkMap x' ≫ X.presheaf.stalkSpecializes h :=\n  PresheafedSpace.stalkMap.stalkSpecializes_stalkMap f.toPshHom h\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkSpecializes_stalkMap_apply","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nx x' : ↑↑X.toPresheafedSpace\nh : Specializes x x'\ny : ↑(Y.presheaf.stalk (f.base x'))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x)) ((CategoryTheory.ConcreteCategory.hom (Y.presheaf.stalkSpecializes ⋯)) y)) ((CategoryTheory.ConcreteCategory.hom (X.presheaf.stalkSpecializes h)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x')) y))","decl":"lemma stalkSpecializes_stalkMap_apply (x x' : X) (h : x ⤳ x') (y) :\n    f.stalkMap x (Y.presheaf.stalkSpecializes (f.base.map_specializes h) y) =\n      (X.presheaf.stalkSpecializes h (f.stalkMap x' y)) :=\n  DFunLike.congr_fun (CommRingCat.hom_ext_iff.mp (stalkSpecializes_stalkMap f x x' h)) y\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_congr","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf g : Quiver.Hom X Y\nhfg : Eq f g\nx x' : ↑↑X.toPresheafedSpace\nhxx' : Eq x x'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap f x) (X.presheaf.stalkCongr ⋯).hom) (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkCongr ⋯).hom (AlgebraicGeometry.Scheme.Hom.stalkMap g x'))","decl":"@[reassoc]\nlemma stalkMap_congr (f g : X ⟶ Y) (hfg : f = g) (x x' : X)\n    (hxx' : x = x') : f.stalkMap x ≫ (X.presheaf.stalkCongr (.of_eq hxx')).hom =\n      (Y.presheaf.stalkCongr (.of_eq <| hfg ▸ hxx' ▸ rfl)).hom ≫ g.stalkMap x' :=\n  LocallyRingedSpace.stalkMap_congr f.toLRSHom g.toLRSHom congr(($hfg).toLRSHom) x x' hxx'\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_congr_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf g : Quiver.Hom X Y\nhfg : Eq f g\nx x' : ↑↑X.toPresheafedSpace\nhxx' : Eq x x'\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.stalk x') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap f x) (CategoryTheory.CategoryStruct.comp (X.presheaf.stalkCongr ⋯).hom h)) (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkCongr ⋯).hom (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap g x') h))","decl":"@[reassoc]\nlemma stalkMap_congr (f g : X ⟶ Y) (hfg : f = g) (x x' : X)\n    (hxx' : x = x') : f.stalkMap x ≫ (X.presheaf.stalkCongr (.of_eq hxx')).hom =\n      (Y.presheaf.stalkCongr (.of_eq <| hfg ▸ hxx' ▸ rfl)).hom ≫ g.stalkMap x' :=\n  LocallyRingedSpace.stalkMap_congr f.toLRSHom g.toLRSHom congr(($hfg).toLRSHom) x x' hxx'\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_congr_hom_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf g : Quiver.Hom X Y\nhfg : Eq f g\nx : ↑↑X.toPresheafedSpace\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.stalk x) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap f x) h) (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkCongr ⋯).hom (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap g x) h))","decl":"@[reassoc]\nlemma stalkMap_congr_hom (f g : X ⟶ Y) (hfg : f = g) (x : X) :\n    f.stalkMap x = (Y.presheaf.stalkCongr (.of_eq <| hfg ▸ rfl)).hom ≫ g.stalkMap x :=\n  LocallyRingedSpace.stalkMap_congr_hom f.toLRSHom g.toLRSHom congr(($hfg).toLRSHom) x\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_congr_hom","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf g : Quiver.Hom X Y\nhfg : Eq f g\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.stalkMap f x) (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkCongr ⋯).hom (AlgebraicGeometry.Scheme.Hom.stalkMap g x))","decl":"@[reassoc]\nlemma stalkMap_congr_hom (f g : X ⟶ Y) (hfg : f = g) (x : X) :\n    f.stalkMap x = (Y.presheaf.stalkCongr (.of_eq <| hfg ▸ rfl)).hom ≫ g.stalkMap x :=\n  LocallyRingedSpace.stalkMap_congr_hom f.toLRSHom g.toLRSHom congr(($hfg).toLRSHom) x\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_congr_point_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nx x' : ↑↑X.toPresheafedSpace\nhxx' : Eq x x'\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.stalk x') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap f x) (CategoryTheory.CategoryStruct.comp (X.presheaf.stalkCongr ⋯).hom h)) (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkCongr ⋯).hom (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap f x') h))","decl":"@[reassoc]\nlemma stalkMap_congr_point (x x' : X) (hxx' : x = x') :\n    f.stalkMap x ≫ (X.presheaf.stalkCongr (.of_eq hxx')).hom =\n      (Y.presheaf.stalkCongr (.of_eq <| hxx' ▸ rfl)).hom ≫ f.stalkMap x' :=\n  LocallyRingedSpace.stalkMap_congr_point f.toLRSHom x x' hxx'\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_congr_point","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nx x' : ↑↑X.toPresheafedSpace\nhxx' : Eq x x'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap f x) (X.presheaf.stalkCongr ⋯).hom) (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkCongr ⋯).hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x'))","decl":"@[reassoc]\nlemma stalkMap_congr_point (x x' : X) (hxx' : x = x') :\n    f.stalkMap x ≫ (X.presheaf.stalkCongr (.of_eq hxx')).hom =\n      (Y.presheaf.stalkCongr (.of_eq <| hxx' ▸ rfl)).hom ≫ f.stalkMap x' :=\n  LocallyRingedSpace.stalkMap_congr_point f.toLRSHom x x' hxx'\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_hom_inv","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\ny : ↑↑Y.toPresheafedSpace\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap e.hom (e.inv.base y)) (AlgebraicGeometry.Scheme.Hom.stalkMap e.inv y)) (Y.presheaf.stalkCongr ⋯).hom","decl":"@[reassoc (attr := simp)]\nlemma stalkMap_hom_inv (e : X ≅ Y) (y : Y) :\n    e.hom.stalkMap (e.inv.base y) ≫ e.inv.stalkMap y =\n      (Y.presheaf.stalkCongr (.of_eq (by simp))).hom :=\n  LocallyRingedSpace.stalkMap_hom_inv (forgetToLocallyRingedSpace.mapIso e) y\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_hom_inv_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\ny : ↑↑Y.toPresheafedSpace\nZ : CommRingCat\nh : Quiver.Hom (Y.presheaf.stalk y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap e.hom (e.inv.base y)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap e.inv y) h)) (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkCongr ⋯).hom h)","decl":"@[reassoc (attr := simp)]\nlemma stalkMap_hom_inv (e : X ≅ Y) (y : Y) :\n    e.hom.stalkMap (e.inv.base y) ≫ e.inv.stalkMap y =\n      (Y.presheaf.stalkCongr (.of_eq (by simp))).hom :=\n  LocallyRingedSpace.stalkMap_hom_inv (forgetToLocallyRingedSpace.mapIso e) y\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_hom_inv_apply","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\ny : ↑↑Y.toPresheafedSpace\nz : ↑(Y.presheaf.stalk (e.hom.base (e.inv.base y)))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap e.inv y)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap e.hom (e.inv.base y))) z)) ((CategoryTheory.ConcreteCategory.hom (Y.presheaf.stalkCongr ⋯).hom) z)","decl":"@[simp]\nlemma stalkMap_hom_inv_apply (e : X ≅ Y) (y : Y) (z) :\n    e.inv.stalkMap y (e.hom.stalkMap (e.inv.base y) z) =\n      (Y.presheaf.stalkCongr (.of_eq (by simp))).hom z :=\n  DFunLike.congr_fun (CommRingCat.hom_ext_iff.mp (stalkMap_hom_inv e y)) z\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_inv_hom","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\nx : ↑↑X.toPresheafedSpace\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap e.inv (e.hom.base x)) (AlgebraicGeometry.Scheme.Hom.stalkMap e.hom x)) (X.presheaf.stalkCongr ⋯).hom","decl":"@[reassoc (attr := simp)]\nlemma stalkMap_inv_hom (e : X ≅ Y) (x : X) :\n    e.inv.stalkMap (e.hom.base x) ≫ e.hom.stalkMap x =\n      (X.presheaf.stalkCongr (.of_eq (by simp))).hom :=\n  LocallyRingedSpace.stalkMap_inv_hom (forgetToLocallyRingedSpace.mapIso e) x\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_inv_hom_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\nx : ↑↑X.toPresheafedSpace\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.stalk x) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap e.inv (e.hom.base x)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap e.hom x) h)) (CategoryTheory.CategoryStruct.comp (X.presheaf.stalkCongr ⋯).hom h)","decl":"@[reassoc (attr := simp)]\nlemma stalkMap_inv_hom (e : X ≅ Y) (x : X) :\n    e.inv.stalkMap (e.hom.base x) ≫ e.hom.stalkMap x =\n      (X.presheaf.stalkCongr (.of_eq (by simp))).hom :=\n  LocallyRingedSpace.stalkMap_inv_hom (forgetToLocallyRingedSpace.mapIso e) x\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_inv_hom_apply","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\ne : CategoryTheory.Iso X Y\nx : ↑↑X.toPresheafedSpace\ny : ↑(X.presheaf.stalk (e.inv.base (e.hom.base x)))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap e.hom x)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap e.inv (e.hom.base x))) y)) ((CategoryTheory.ConcreteCategory.hom (X.presheaf.stalkCongr ⋯).hom) y)","decl":"@[simp]\nlemma stalkMap_inv_hom_apply (e : X ≅ Y) (x : X) (y) :\n    e.hom.stalkMap x (e.inv.stalkMap (e.hom.base x) y) =\n      (X.presheaf.stalkCongr (.of_eq (by simp))).hom y :=\n  DFunLike.congr_fun (CommRingCat.hom_ext_iff.mp (stalkMap_inv_hom e x)) y\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_germ","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nx : ↑↑X.toPresheafedSpace\nhx : Membership.mem U (f.base x)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.germ U (f.base x) hx) (AlgebraicGeometry.Scheme.Hom.stalkMap f x)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f U) (X.presheaf.germ ((TopologicalSpace.Opens.map f.base).obj U) x hx))","decl":"@[reassoc (attr := simp)]\nlemma stalkMap_germ (U : Y.Opens) (x : X) (hx : f.base x ∈ U) :\n    Y.presheaf.germ U (f.base x) hx ≫ f.stalkMap x =\n      f.app U ≫ X.presheaf.germ (f ⁻¹ᵁ U) x hx :=\n  PresheafedSpace.stalkMap_germ f.toPshHom U x hx\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_germ_assoc","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nx : ↑↑X.toPresheafedSpace\nhx : Membership.mem U (f.base x)\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.stalk x) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.germ U (f.base x) hx) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap f x) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f U) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ ((TopologicalSpace.Opens.map f.base).obj U) x hx) h))","decl":"@[reassoc (attr := simp)]\nlemma stalkMap_germ (U : Y.Opens) (x : X) (hx : f.base x ∈ U) :\n    Y.presheaf.germ U (f.base x) hx ≫ f.stalkMap x =\n      f.app U ≫ X.presheaf.germ (f ⁻¹ᵁ U) x hx :=\n  PresheafedSpace.stalkMap_germ f.toPshHom U x hx\n\n"}
{"name":"AlgebraicGeometry.Scheme.stalkMap_germ_apply","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nx : ↑↑X.toPresheafedSpace\nhx : Membership.mem U (f.base x)\ny : ↑(Y.presheaf.obj { unop := U })\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x)) ((CategoryTheory.ConcreteCategory.hom (Y.presheaf.germ U (f.base x) hx)) y)) ((CategoryTheory.ConcreteCategory.hom (X.presheaf.germ ((TopologicalSpace.Opens.map f.base).obj U) x hx)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app f U)) y))","decl":"@[simp]\nlemma stalkMap_germ_apply (U : Y.Opens) (x : X) (hx : f.base x ∈ U) (y) :\n    f.stalkMap x (Y.presheaf.germ _ (f.base x) hx y) =\n      X.presheaf.germ (f ⁻¹ᵁ U) x hx (f.app U y) :=\n  PresheafedSpace.stalkMap_germ_apply f.toPshHom U x hx y\n\n"}
{"name":"AlgebraicGeometry.Spec_closedPoint","module":"Mathlib.AlgebraicGeometry.Scheme","initialProofState":"R S : CommRingCat\ninst✝² : IsLocalRing ↑R\ninst✝¹ : IsLocalRing ↑S\nf : Quiver.Hom R S\ninst✝ : IsLocalHom (CommRingCat.Hom.hom f)\n⊢ Eq ((AlgebraicGeometry.Spec.map f).base (IsLocalRing.closedPoint ↑S)) (IsLocalRing.closedPoint ↑R)","decl":"@[simp]\nlemma Spec_closedPoint {R S : CommRingCat} [IsLocalRing R] [IsLocalRing S]\n    {f : R ⟶ S} [IsLocalHom f.hom] : (Spec.map f).base (closedPoint S) = closedPoint R :=\n  IsLocalRing.comap_closedPoint f.hom\n\n"}
