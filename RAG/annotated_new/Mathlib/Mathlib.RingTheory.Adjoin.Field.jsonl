{"name":"Polynomial.lift_of_splits","module":"Mathlib.RingTheory.Adjoin.Field","initialProofState":"F : Type u_2\nK : Type u_3\nL : Type u_4\ninst✝⁴ : Field F\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra F K\ninst✝ : Algebra F L\ns : Finset K\na✝ : ∀ (x : K), Membership.mem s x → And (IsIntegral F x) (Polynomial.Splits (algebraMap F L) (minpoly F x))\n⊢ Nonempty (AlgHom F (Subtype fun x => Membership.mem (Algebra.adjoin F ↑s) x) L)","decl":"/-- If `K` and `L` are field extensions of `F` and we have `s : Finset K` such that\nthe minimal polynomial of each `x ∈ s` splits in `L` then `Algebra.adjoin F s` embeds in `L`. -/\ntheorem Polynomial.lift_of_splits {F K L : Type*} [Field F] [Field K] [Field L] [Algebra F K]\n    [Algebra F L] (s : Finset K) : (∀ x ∈ s, IsIntegral F x ∧\n      Splits (algebraMap F L) (minpoly F x)) → Nonempty (Algebra.adjoin F (s : Set K) →ₐ[F] L) := by\n  classical\n    refine Finset.induction_on s (fun _ ↦ ?_) fun a s _ ih H ↦ ?_\n    · rw [coe_empty, Algebra.adjoin_empty]\n      exact ⟨(Algebra.ofId F L).comp (Algebra.botEquiv F K)⟩\n    rw [forall_mem_insert] at H\n    rcases H with ⟨⟨H1, H2⟩, H3⟩\n    cases' ih H3 with f\n    choose H3 _ using H3\n    rw [coe_insert, Set.insert_eq, Set.union_comm, Algebra.adjoin_union_eq_adjoin_adjoin]\n    set Ks := Algebra.adjoin F (s : Set K)\n    haveI : FiniteDimensional F Ks := ((Submodule.fg_iff_finiteDimensional _).1\n      (fg_adjoin_of_finite s.finite_toSet H3)).of_subalgebra_toSubmodule\n    letI := fieldOfFiniteDimensional F Ks\n    letI := (f : Ks →+* L).toAlgebra\n    have H5 : IsIntegral Ks a := H1.tower_top\n    have H6 : (minpoly Ks a).Splits (algebraMap Ks L) := by\n      refine splits_of_splits_of_dvd _ ((minpoly.monic H1).map (algebraMap F Ks)).ne_zero\n        ((splits_map_iff _ _).2 ?_) (minpoly.dvd _ _ ?_)\n      · rw [← IsScalarTower.algebraMap_eq]\n        exact H2\n      · rw [Polynomial.aeval_map_algebraMap, minpoly.aeval]\n    obtain ⟨y, hy⟩ := Polynomial.exists_root_of_splits _ H6 (minpoly.degree_pos H5).ne'\n    exact ⟨Subalgebra.ofRestrictScalars F _ <| Algebra.adjoin.liftSingleton Ks a y hy⟩\n\n"}
{"name":"IsIntegral.mem_range_algHom_of_minpoly_splits","module":"Mathlib.RingTheory.Adjoin.Field","initialProofState":"R : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra R K\nx : L\ninst✝ : Algebra R L\nint : IsIntegral R x\nh : Polynomial.Splits (algebraMap R K) (minpoly R x)\nf : AlgHom R K L\n⊢ Membership.mem f.range x","decl":"theorem IsIntegral.mem_range_algHom_of_minpoly_splits\n    (int : IsIntegral R x) (h : Splits (algebraMap R K) (minpoly R x))(f : K →ₐ[R] L) :\n    x ∈ f.range :=\n  show x ∈ Set.range f from Set.image_subset_range _ ((minpoly R x).rootSet K) <| by\n    rw [image_rootSet h f, mem_rootSet']\n    exact ⟨((minpoly.monic int).map _).ne_zero, minpoly.aeval R x⟩\n\n"}
{"name":"IsIntegral.mem_range_algebraMap_of_minpoly_splits","module":"Mathlib.RingTheory.Adjoin.Field","initialProofState":"R : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : Field K\ninst✝⁴ : Field L\ninst✝³ : Algebra R K\nx : L\ninst✝² : Algebra R L\ninst✝¹ : Algebra K L\ninst✝ : IsScalarTower R K L\nint : IsIntegral R x\nh : Polynomial.Splits (algebraMap R K) (minpoly R x)\n⊢ Membership.mem (algebraMap K L).range x","decl":"theorem IsIntegral.mem_range_algebraMap_of_minpoly_splits [Algebra K L] [IsScalarTower R K L]\n    (int : IsIntegral R x) (h : Splits (algebraMap R K) (minpoly R x)) :\n    x ∈ (algebraMap K L).range :=\n  int.mem_range_algHom_of_minpoly_splits h (IsScalarTower.toAlgHom R K L)\n\n"}
{"name":"minpoly_neg_splits","module":"Mathlib.RingTheory.Adjoin.Field","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\ng : Polynomial.Splits (algebraMap K L) (minpoly K x)\n⊢ Polynomial.Splits (algebraMap K L) (minpoly K (Neg.neg x))","decl":"theorem minpoly_neg_splits [Algebra K L] {x : L} (g : (minpoly K x).Splits (algebraMap K L)) :\n    (minpoly K (-x)).Splits (algebraMap K L) := by\n  rw [minpoly.neg]\n  apply splits_mul _ _ g.comp_neg_X\n  simpa only [map_pow, map_neg, map_one] using\n    splits_C (algebraMap K L) ((-1) ^ (minpoly K x).natDegree)\n\n"}
{"name":"minpoly_add_algebraMap_splits","module":"Mathlib.RingTheory.Adjoin.Field","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nr : K\ng : Polynomial.Splits (algebraMap K L) (minpoly K x)\n⊢ Polynomial.Splits (algebraMap K L) (minpoly K (HAdd.hAdd x ((algebraMap K L) r)))","decl":"theorem minpoly_add_algebraMap_splits [Algebra K L] {x : L} (r : K)\n    (g : (minpoly K x).Splits (algebraMap K L)) :\n    (minpoly K (x + algebraMap K L r)).Splits (algebraMap K L) := by\n  simpa [minpoly.add_algebraMap] using g.comp_X_sub_C r\n\n"}
{"name":"minpoly_sub_algebraMap_splits","module":"Mathlib.RingTheory.Adjoin.Field","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nr : K\ng : Polynomial.Splits (algebraMap K L) (minpoly K x)\n⊢ Polynomial.Splits (algebraMap K L) (minpoly K (HSub.hSub x ((algebraMap K L) r)))","decl":"theorem minpoly_sub_algebraMap_splits [Algebra K L] {x : L} (r : K)\n    (g : (minpoly K x).Splits (algebraMap K L)) :\n    (minpoly K (x - algebraMap K L r)).Splits (algebraMap K L) := by\n  simpa only [sub_eq_add_neg, map_neg] using minpoly_add_algebraMap_splits (-r) g\n\n"}
{"name":"minpoly_algebraMap_add_splits","module":"Mathlib.RingTheory.Adjoin.Field","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nr : K\ng : Polynomial.Splits (algebraMap K L) (minpoly K x)\n⊢ Polynomial.Splits (algebraMap K L) (minpoly K (HAdd.hAdd ((algebraMap K L) r) x))","decl":"theorem minpoly_algebraMap_add_splits [Algebra K L] {x : L} (r : K)\n    (g : (minpoly K x).Splits (algebraMap K L)) :\n    (minpoly K (algebraMap K L r + x)).Splits (algebraMap K L) := by\n  simpa only [add_comm] using minpoly_add_algebraMap_splits r g\n\n"}
{"name":"minpoly_algebraMap_sub_splits","module":"Mathlib.RingTheory.Adjoin.Field","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nr : K\ng : Polynomial.Splits (algebraMap K L) (minpoly K x)\n⊢ Polynomial.Splits (algebraMap K L) (minpoly K (HSub.hSub ((algebraMap K L) r) x))","decl":"theorem minpoly_algebraMap_sub_splits [Algebra K L] {x : L} (r : K)\n    (g : (minpoly K x).Splits (algebraMap K L)) :\n    (minpoly K (algebraMap K L r - x)).Splits (algebraMap K L) := by\n  simpa only [neg_sub] using minpoly_neg_splits (minpoly_sub_algebraMap_splits r g)\n\n"}
{"name":"IsIntegral.minpoly_splits_tower_top'","module":"Mathlib.RingTheory.Adjoin.Field","initialProofState":"R : Type u_1\nK : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : CommRing M\ninst✝³ : Algebra R K\ninst✝² : Algebra R M\ninst✝¹ : Algebra K M\ninst✝ : IsScalarTower R K M\nx : M\nint : IsIntegral R x\nf : RingHom K L\nh : Polynomial.Splits (f.comp (algebraMap R K)) (minpoly R x)\n⊢ Polynomial.Splits f (minpoly K x)","decl":"/-- The `RingHom` version of `IsIntegral.minpoly_splits_tower_top`.  -/\ntheorem IsIntegral.minpoly_splits_tower_top' (int : IsIntegral R x) {f : K →+* L}\n    (h : Splits (f.comp <| algebraMap R K) (minpoly R x)) :\n    Splits f (minpoly K x) :=\n  splits_of_splits_of_dvd _ ((minpoly.monic int).map _).ne_zero\n    ((splits_map_iff _ _).mpr h) (minpoly.dvd_map_of_isScalarTower R _ x)\n\n"}
{"name":"IsIntegral.minpoly_splits_tower_top","module":"Mathlib.RingTheory.Adjoin.Field","initialProofState":"R : Type u_1\nK : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹⁰ : CommRing R\ninst✝⁹ : Field K\ninst✝⁸ : Field L\ninst✝⁷ : CommRing M\ninst✝⁶ : Algebra R K\ninst✝⁵ : Algebra R M\ninst✝⁴ : Algebra K M\ninst✝³ : IsScalarTower R K M\nx : M\ninst✝² : Algebra K L\ninst✝¹ : Algebra R L\ninst✝ : IsScalarTower R K L\nint : IsIntegral R x\nh : Polynomial.Splits (algebraMap R L) (minpoly R x)\n⊢ Polynomial.Splits (algebraMap K L) (minpoly K x)","decl":"theorem IsIntegral.minpoly_splits_tower_top [Algebra K L] [Algebra R L] [IsScalarTower R K L]\n    (int : IsIntegral R x) (h : Splits (algebraMap R L) (minpoly R x)) :\n    Splits (algebraMap K L) (minpoly K x) := by\n  rw [IsScalarTower.algebraMap_eq R K L] at h\n  exact int.minpoly_splits_tower_top' h\n\n"}
{"name":"Subalgebra.adjoin_rank_le","module":"Mathlib.RingTheory.Adjoin.Field","initialProofState":"F : Type u_5\nE : Type u_6\nK : Type u_7\ninst✝⁹ : CommRing F\ninst✝⁸ : StrongRankCondition F\ninst✝⁷ : CommRing E\ninst✝⁶ : StrongRankCondition E\ninst✝⁵ : Ring K\ninst✝⁴ : SMul F E\ninst✝³ : Algebra E K\ninst✝² : Algebra F K\ninst✝¹ : IsScalarTower F E K\nL : Subalgebra F K\ninst✝ : Module.Free F (Subtype fun x => Membership.mem L x)\n⊢ LE.le (Module.rank E (Subtype fun x => Membership.mem (Algebra.adjoin E ↑L) x)) (Module.rank F (Subtype fun x => Membership.mem L x))","decl":"/-- If `K / E / F` is a ring extension tower, `L` is a subalgebra of `K / F`,\nthen `[E[L] : E] ≤ [L : F]`. -/\nlemma Subalgebra.adjoin_rank_le {F : Type*} (E : Type*) {K : Type*}\n    [CommRing F] [StrongRankCondition F] [CommRing E] [StrongRankCondition E] [Ring K]\n    [SMul F E] [Algebra E K] [Algebra F K] [IsScalarTower F E K]\n    (L : Subalgebra F K) [Module.Free F L] :\n    Module.rank E (Algebra.adjoin E (L : Set K)) ≤ Module.rank F L := by\n  rw [← rank_toSubmodule, Module.Free.rank_eq_card_chooseBasisIndex F L,\n    L.adjoin_eq_span_basis E (Module.Free.chooseBasis F L)]\n  exact rank_span_le _ |>.trans Cardinal.mk_range_le\n"}
