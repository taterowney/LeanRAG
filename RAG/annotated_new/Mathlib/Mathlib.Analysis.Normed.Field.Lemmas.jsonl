{"name":"Filter.Tendsto.zero_mul_isBoundedUnder_le","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\nŒπ : Type u_3\ninst‚úù : NonUnitalSeminormedRing Œ±\nf g : Œπ ‚Üí Œ±\nl : Filter Œπ\nhf : Filter.Tendsto f l (nhds 0)\nhg : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp (fun x => Norm.norm x) g)\n‚ä¢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l (nhds 0)","decl":"theorem Filter.Tendsto.zero_mul_isBoundedUnder_le {f g : Œπ ‚Üí Œ±} {l : Filter Œπ}\n    (hf : Tendsto f l (ùìù 0)) (hg : IsBoundedUnder (¬∑ ‚â§ ¬∑) l ((‚Äñ¬∑‚Äñ) ‚àò g)) :\n    Tendsto (fun x => f x * g x) l (ùìù 0) :=\n  hf.op_zero_isBoundedUnder_le hg (¬∑ * ¬∑) norm_mul_le\n\n"}
{"name":"Filter.isBoundedUnder_le_mul_tendsto_zero","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\nŒπ : Type u_3\ninst‚úù : NonUnitalSeminormedRing Œ±\nf g : Œπ ‚Üí Œ±\nl : Filter Œπ\nhf : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm f)\nhg : Filter.Tendsto g l (nhds 0)\n‚ä¢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l (nhds 0)","decl":"theorem Filter.isBoundedUnder_le_mul_tendsto_zero {f g : Œπ ‚Üí Œ±} {l : Filter Œπ}\n    (hf : IsBoundedUnder (¬∑ ‚â§ ¬∑) l (norm ‚àò f)) (hg : Tendsto g l (ùìù 0)) :\n    Tendsto (fun x => f x * g x) l (ùìù 0) :=\n  hg.op_zero_isBoundedUnder_le hf (flip (¬∑ * ¬∑)) fun x y =>\n    (norm_mul_le y x).trans_eq (mul_comm _ _)\n\n"}
{"name":"NonUnitalSeminormedRing.toContinuousMul","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NonUnitalSeminormedRing Œ±\n‚ä¢ ContinuousMul Œ±","decl":"instance (priority := 100) NonUnitalSeminormedRing.toContinuousMul [NonUnitalSeminormedRing Œ±] :\n    ContinuousMul Œ± :=\n  ‚ü®continuous_iff_continuousAt.2 fun x =>\n      tendsto_iff_norm_sub_tendsto_zero.2 <| by\n        have : ‚àÄ e : Œ± √ó Œ±,\n            ‚Äñe.1 * e.2 - x.1 * x.2‚Äñ ‚â§ ‚Äñe.1‚Äñ * ‚Äñe.2 - x.2‚Äñ + ‚Äñe.1 - x.1‚Äñ * ‚Äñx.2‚Äñ := by\n          intro e\n          calc\n            ‚Äñe.1 * e.2 - x.1 * x.2‚Äñ ‚â§ ‚Äñe.1 * (e.2 - x.2) + (e.1 - x.1) * x.2‚Äñ := by\n              rw [mul_sub, sub_mul, sub_add_sub_cancel]\n            _ ‚â§ ‚Äñe.1‚Äñ * ‚Äñe.2 - x.2‚Äñ + ‚Äñe.1 - x.1‚Äñ * ‚Äñx.2‚Äñ :=\n              norm_add_le_of_le (norm_mul_le _ _) (norm_mul_le _ _)\n        refine squeeze_zero (fun e => norm_nonneg _) this ?_\n        convert\n          ((continuous_fst.tendsto x).norm.mul\n                ((continuous_snd.tendsto x).sub tendsto_const_nhds).norm).add\n            (((continuous_fst.tendsto x).sub tendsto_const_nhds).norm.mul _)\n        -- Porting note: `show` used to select a goal to work on\n        rotate_right\n        ¬∑ show Tendsto _ _ _\n          exact tendsto_const_nhds\n        ¬∑ simp‚ü©\n\n-- see Note [lower instance priority]\n"}
{"name":"NonUnitalSeminormedRing.toTopologicalRing","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NonUnitalSeminormedRing Œ±\n‚ä¢ TopologicalRing Œ±","decl":"/-- A seminormed ring is a topological ring. -/\ninstance (priority := 100) NonUnitalSeminormedRing.toTopologicalRing [NonUnitalSeminormedRing Œ±] :\n    TopologicalRing Œ± where\n\n"}
{"name":"SeparationQuotient.instNormOneClass","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : SeminormedAddCommGroup Œ±\ninst‚úù¬π : One Œ±\ninst‚úù : NormOneClass Œ±\n‚ä¢ NormOneClass (SeparationQuotient Œ±)","decl":"instance [SeminormedAddCommGroup Œ±] [One Œ±] [NormOneClass Œ±] :\n    NormOneClass (SeparationQuotient Œ±) where\n  norm_one := norm_one (Œ± := Œ±)\n\n"}
{"name":"antilipschitzWith_mul_left","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : Ne a 0\n‚ä¢ AntilipschitzWith (Inv.inv (NNNorm.nnnorm a)) fun x => HMul.hMul a x","decl":"lemma antilipschitzWith_mul_left {a : Œ±} (ha : a ‚â† 0) : AntilipschitzWith (‚Äña‚Äñ‚Çä‚Åª¬π) (a * ¬∑) :=\n  AntilipschitzWith.of_le_mul_dist fun _ _ ‚Ü¶ by simp [dist_eq_norm, ‚Üê _root_.mul_sub, ha]\n\n"}
{"name":"antilipschitzWith_mul_right","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : Ne a 0\n‚ä¢ AntilipschitzWith (Inv.inv (NNNorm.nnnorm a)) fun x => HMul.hMul x a","decl":"lemma antilipschitzWith_mul_right {a : Œ±} (ha : a ‚â† 0) : AntilipschitzWith (‚Äña‚Äñ‚Çä‚Åª¬π) (¬∑ * a) :=\n  AntilipschitzWith.of_le_mul_dist fun _ _ ‚Ü¶ by\n    simp [dist_eq_norm, ‚Üê _root_.sub_mul, ‚Üê mul_comm (‚Äña‚Äñ), ha]\n\n"}
{"name":"DilationEquiv.mulLeft_symm_apply","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : Ne a 0\nx : Œ±\n‚ä¢ Eq ((DilationEquiv.mulLeft a ha).symm x) (HMul.hMul (Inv.inv a) x)","decl":"/-- Multiplication by a nonzero element `a` on the left\nas a `DilationEquiv` of a normed division ring. -/\n@[simps!]\ndef DilationEquiv.mulLeft (a : Œ±) (ha : a ‚â† 0) : Œ± ‚âÉ·µà Œ± where\n  toEquiv := Equiv.mulLeft‚ÇÄ a ha\n  edist_eq' := ‚ü®‚Äña‚Äñ‚Çä, nnnorm_ne_zero_iff.2 ha, fun x y ‚Ü¶ by\n    simp [edist_nndist, nndist_eq_nnnorm, ‚Üê mul_sub]‚ü©\n\n"}
{"name":"DilationEquiv.mulLeft_apply","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : Ne a 0\nx : Œ±\n‚ä¢ Eq ((DilationEquiv.mulLeft a ha) x) (HMul.hMul a x)","decl":"/-- Multiplication by a nonzero element `a` on the left\nas a `DilationEquiv` of a normed division ring. -/\n@[simps!]\ndef DilationEquiv.mulLeft (a : Œ±) (ha : a ‚â† 0) : Œ± ‚âÉ·µà Œ± where\n  toEquiv := Equiv.mulLeft‚ÇÄ a ha\n  edist_eq' := ‚ü®‚Äña‚Äñ‚Çä, nnnorm_ne_zero_iff.2 ha, fun x y ‚Ü¶ by\n    simp [edist_nndist, nndist_eq_nnnorm, ‚Üê mul_sub]‚ü©\n\n"}
{"name":"DilationEquiv.mulRight_symm_apply","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : Ne a 0\nx : Œ±\n‚ä¢ Eq ((DilationEquiv.mulRight a ha).symm x) (HMul.hMul x (Inv.inv a))","decl":"/-- Multiplication by a nonzero element `a` on the right\nas a `DilationEquiv` of a normed division ring. -/\n@[simps!]\ndef DilationEquiv.mulRight (a : Œ±) (ha : a ‚â† 0) : Œ± ‚âÉ·µà Œ± where\n  toEquiv := Equiv.mulRight‚ÇÄ a ha\n  edist_eq' := ‚ü®‚Äña‚Äñ‚Çä, nnnorm_ne_zero_iff.2 ha, fun x y ‚Ü¶ by\n    simp [edist_nndist, nndist_eq_nnnorm, ‚Üê sub_mul, ‚Üê mul_comm (‚Äña‚Äñ‚Çä)]‚ü©\n\n"}
{"name":"DilationEquiv.mulRight_apply","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : Ne a 0\nx : Œ±\n‚ä¢ Eq ((DilationEquiv.mulRight a ha) x) (HMul.hMul x a)","decl":"/-- Multiplication by a nonzero element `a` on the right\nas a `DilationEquiv` of a normed division ring. -/\n@[simps!]\ndef DilationEquiv.mulRight (a : Œ±) (ha : a ‚â† 0) : Œ± ‚âÉ·µà Œ± where\n  toEquiv := Equiv.mulRight‚ÇÄ a ha\n  edist_eq' := ‚ü®‚Äña‚Äñ‚Çä, nnnorm_ne_zero_iff.2 ha, fun x y ‚Ü¶ by\n    simp [edist_nndist, nndist_eq_nnnorm, ‚Üê sub_mul, ‚Üê mul_comm (‚Äña‚Äñ‚Çä)]‚ü©\n\n"}
{"name":"Filter.comap_mul_left_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : Ne a 0\n‚ä¢ Eq (Filter.comap (fun x => HMul.hMul a x) (Bornology.cobounded Œ±)) (Bornology.cobounded Œ±)","decl":"@[simp]\nlemma comap_mul_left_cobounded {a : Œ±} (ha : a ‚â† 0) :\n    comap (a * ¬∑) (cobounded Œ±) = cobounded Œ± :=\n  Dilation.comap_cobounded (DilationEquiv.mulLeft a ha)\n\n"}
{"name":"Filter.map_mul_left_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : Ne a 0\n‚ä¢ Eq (Filter.map (fun x => HMul.hMul a x) (Bornology.cobounded Œ±)) (Bornology.cobounded Œ±)","decl":"@[simp]\nlemma map_mul_left_cobounded {a : Œ±} (ha : a ‚â† 0) :\n    map (a * ¬∑) (cobounded Œ±) = cobounded Œ± :=\n  DilationEquiv.map_cobounded (DilationEquiv.mulLeft a ha)\n\n"}
{"name":"Filter.comap_mul_right_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : Ne a 0\n‚ä¢ Eq (Filter.comap (fun x => HMul.hMul x a) (Bornology.cobounded Œ±)) (Bornology.cobounded Œ±)","decl":"@[simp]\nlemma comap_mul_right_cobounded {a : Œ±} (ha : a ‚â† 0) :\n    comap (¬∑ * a) (cobounded Œ±) = cobounded Œ± :=\n  Dilation.comap_cobounded (DilationEquiv.mulRight a ha)\n\n"}
{"name":"Filter.map_mul_right_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : Ne a 0\n‚ä¢ Eq (Filter.map (fun x => HMul.hMul x a) (Bornology.cobounded Œ±)) (Bornology.cobounded Œ±)","decl":"@[simp]\nlemma map_mul_right_cobounded {a : Œ±} (ha : a ‚â† 0) :\n    map (¬∑ * a) (cobounded Œ±) = cobounded Œ± :=\n  DilationEquiv.map_cobounded (DilationEquiv.mulRight a ha)\n\n"}
{"name":"Filter.tendsto_mul_left_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : Ne a 0\n‚ä¢ Filter.Tendsto (fun x => HMul.hMul a x) (Bornology.cobounded Œ±) (Bornology.cobounded Œ±)","decl":"/-- Multiplication on the left by a nonzero element of a normed division ring tends to infinity at\ninfinity. -/\ntheorem tendsto_mul_left_cobounded {a : Œ±} (ha : a ‚â† 0) :\n    Tendsto (a * ¬∑) (cobounded Œ±) (cobounded Œ±) :=\n  (map_mul_left_cobounded ha).le\n\n"}
{"name":"Filter.tendsto_mul_right_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : Ne a 0\n‚ä¢ Filter.Tendsto (fun x => HMul.hMul x a) (Bornology.cobounded Œ±) (Bornology.cobounded Œ±)","decl":"/-- Multiplication on the right by a nonzero element of a normed division ring tends to infinity at\ninfinity. -/\ntheorem tendsto_mul_right_cobounded {a : Œ±} (ha : a ‚â† 0) :\n    Tendsto (¬∑ * a) (cobounded Œ±) (cobounded Œ±) :=\n  (map_mul_right_cobounded ha).le\n\n"}
{"name":"Filter.inv_cobounded‚ÇÄ","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\n‚ä¢ Eq (Inv.inv (Bornology.cobounded Œ±)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"@[simp]\nlemma inv_cobounded‚ÇÄ : (cobounded Œ±)‚Åª¬π = ùìù[‚â†] 0 := by\n  rw [‚Üê comap_norm_atTop, ‚Üê Filter.comap_inv, ‚Üê comap_norm_nhdsGT_zero, ‚Üê inv_atTop‚ÇÄ,\n    ‚Üê Filter.comap_inv]\n  simp only [comap_comap, Function.comp_def, norm_inv]\n\n"}
{"name":"Filter.inv_nhdsWithin_ne_zero","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\n‚ä¢ Eq (Inv.inv (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))) (Bornology.cobounded Œ±)","decl":"@[simp]\nlemma inv_nhdsWithin_ne_zero : (ùìù[‚â†] (0 : Œ±))‚Åª¬π = cobounded Œ± := by\n  rw [‚Üê inv_cobounded‚ÇÄ, inv_inv]\n\n"}
{"name":"Filter.tendsto_inv‚ÇÄ_cobounded'","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\n‚ä¢ Filter.Tendsto Inv.inv (Bornology.cobounded Œ±) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"lemma tendsto_inv‚ÇÄ_cobounded' : Tendsto Inv.inv (cobounded Œ±) (ùìù[‚â†] 0) :=\n  inv_cobounded‚ÇÄ.le\n\n"}
{"name":"Filter.tendsto_inv‚ÇÄ_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\n‚ä¢ Filter.Tendsto Inv.inv (Bornology.cobounded Œ±) (nhds 0)","decl":"theorem tendsto_inv‚ÇÄ_cobounded : Tendsto Inv.inv (cobounded Œ±) (ùìù 0) :=\n  tendsto_inv‚ÇÄ_cobounded'.mono_right inf_le_left\n\n"}
{"name":"Filter.tendsto_inv‚ÇÄ_nhdsWithin_ne_zero","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\n‚ä¢ Filter.Tendsto Inv.inv (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (Bornology.cobounded Œ±)","decl":"lemma tendsto_inv‚ÇÄ_nhdsWithin_ne_zero : Tendsto Inv.inv (ùìù[‚â†] 0) (cobounded Œ±) :=\n  inv_nhdsWithin_ne_zero.le\n\n"}
{"name":"NormedDivisionRing.to_hasContinuousInv‚ÇÄ","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\n‚ä¢ HasContinuousInv‚ÇÄ Œ±","decl":"instance (priority := 100) NormedDivisionRing.to_hasContinuousInv‚ÇÄ : HasContinuousInv‚ÇÄ Œ± := by\n  refine ‚ü®fun r r0 => tendsto_iff_norm_sub_tendsto_zero.2 ?_‚ü©\n  have r0' : 0 < ‚Äñr‚Äñ := norm_pos_iff.2 r0\n  rcases exists_between r0' with ‚ü®Œµ, Œµ0, Œµr‚ü©\n  have : ‚àÄ·∂† e in ùìù r, ‚Äñe‚Åª¬π - r‚Åª¬π‚Äñ ‚â§ ‚Äñr - e‚Äñ / ‚Äñr‚Äñ / Œµ := by\n    filter_upwards [(isOpen_lt continuous_const continuous_norm).eventually_mem Œµr] with e he\n    have e0 : e ‚â† 0 := norm_pos_iff.1 (Œµ0.trans he)\n    calc\n      ‚Äñe‚Åª¬π - r‚Åª¬π‚Äñ = ‚Äñr‚Äñ‚Åª¬π * ‚Äñr - e‚Äñ * ‚Äñe‚Äñ‚Åª¬π := by\n        rw [‚Üê norm_inv, ‚Üê norm_inv, ‚Üê norm_mul, ‚Üê norm_mul, mul_sub, sub_mul,\n          mul_assoc _ e, inv_mul_cancel‚ÇÄ r0, mul_inv_cancel‚ÇÄ e0, one_mul, mul_one]\n      _ = ‚Äñr - e‚Äñ / ‚Äñr‚Äñ / ‚Äñe‚Äñ := by field_simp [mul_comm]\n      _ ‚â§ ‚Äñr - e‚Äñ / ‚Äñr‚Äñ / Œµ := by gcongr\n  refine squeeze_zero' (Eventually.of_forall fun _ => norm_nonneg _) this ?_\n  refine (((continuous_const.sub continuous_id).norm.div_const _).div_const _).tendsto' _ _ ?_\n  simp\n\n-- see Note [lower instance priority]\n"}
{"name":"NormedDivisionRing.to_topologicalDivisionRing","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\n‚ä¢ TopologicalDivisionRing Œ±","decl":"/-- A normed division ring is a topological division ring. -/\ninstance (priority := 100) NormedDivisionRing.to_topologicalDivisionRing :\n    TopologicalDivisionRing Œ± where\n\n"}
{"name":"IsOfFinOrder.norm_eq_one","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\na : Œ±\nha : IsOfFinOrder a\n‚ä¢ Eq (Norm.norm a) 1","decl":"protected lemma IsOfFinOrder.norm_eq_one (ha : IsOfFinOrder a) : ‚Äña‚Äñ = 1 :=\n  ((normHom : Œ± ‚Üí*‚ÇÄ ‚Ñù).toMonoidHom.isOfFinOrder ha).eq_one <| norm_nonneg _\n\n"}
{"name":"AddChar.norm_apply","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : NormedDivisionRing Œ±\nG : Type u_4\ninst‚úù¬π : AddLeftCancelMonoid G\ninst‚úù : Finite G\nœà : AddChar G Œ±\nx : G\n‚ä¢ Eq (Norm.norm (œà x)) 1","decl":"@[simp] lemma AddChar.norm_apply {G : Type*} [AddLeftCancelMonoid G] [Finite G] (œà : AddChar G Œ±)\n    (x : G) : ‚Äñœà x‚Äñ = 1 := (œà.toMonoidHom.isOfFinOrder <| isOfFinOrder_of_finite _).norm_eq_one\n\n"}
{"name":"NormedField.tendsto_norm_inv_nhdsNE_zero_atTop","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\n‚ä¢ Filter.Tendsto (fun x => Norm.norm (Inv.inv x)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) Filter.atTop","decl":"lemma NormedField.tendsto_norm_inv_nhdsNE_zero_atTop : Tendsto (fun x : Œ± ‚Ü¶ ‚Äñx‚Åª¬π‚Äñ) (ùìù[‚â†] 0) atTop :=\n  (tendsto_inv_nhdsGT_zero.comp tendsto_norm_nhdsNE_zero).congr fun x ‚Ü¶ (norm_inv x).symm\n\n"}
{"name":"NormedField.tendsto_norm_inverse_nhdsWithin_0_atTop","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\n‚ä¢ Filter.Tendsto (fun x => Norm.norm (Inv.inv x)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) Filter.atTop","decl":"@[deprecated (since := \"2024-12-22\")]\nalias NormedField.tendsto_norm_inverse_nhdsWithin_0_atTop :=\n  NormedField.tendsto_norm_inv_nhdsNE_zero_atTop\n\n"}
{"name":"NormedField.tendsto_norm_zpow_nhdsNE_zero_atTop","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\nm : Int\nhm : LT.lt m 0\n‚ä¢ Filter.Tendsto (fun x => Norm.norm (HPow.hPow x m)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) Filter.atTop","decl":"lemma NormedField.tendsto_norm_zpow_nhdsNE_zero_atTop {m : ‚Ñ§} (hm : m < 0) :\n    Tendsto (fun x : Œ± ‚Ü¶ ‚Äñx ^ m‚Äñ) (ùìù[‚â†] 0) atTop := by\n  obtain ‚ü®m, rfl‚ü© := neg_surjective m\n  rw [neg_lt_zero] at hm\n  lift m to ‚Ñï using hm.le\n  rw [Int.natCast_pos] at hm\n  simp only [norm_pow, zpow_neg, zpow_natCast, ‚Üê inv_pow]\n  exact (tendsto_pow_atTop hm.ne').comp NormedField.tendsto_norm_inv_nhdsNE_zero_atTop\n\n"}
{"name":"NormedField.tendsto_norm_zpow_nhdsWithin_0_atTop","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : NormedDivisionRing Œ±\nm : Int\nhm : LT.lt m 0\n‚ä¢ Filter.Tendsto (fun x => Norm.norm (HPow.hPow x m)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) Filter.atTop","decl":"@[deprecated (since := \"2024-12-22\")]\nalias NormedField.tendsto_norm_zpow_nhdsWithin_0_atTop :=\n  NormedField.tendsto_norm_zpow_nhdsNE_zero_atTop\n\n"}
{"name":"NormedField.discreteTopology_or_nontriviallyNormedField","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"ùïú : Type u_4\nh : NormedField ùïú\n‚ä¢ Or (DiscreteTopology ùïú) (Nonempty (Subtype fun h' => Eq NontriviallyNormedField.toNormedField h))","decl":"/-- A normed field is either nontrivially normed or has a discrete topology.\nIn the discrete topology case, all the norms are 1, by `norm_eq_one_iff_ne_zero_of_discrete`.\nThe nontrivially normed field instance is provided by a subtype with a proof that the\nforgetful inheritance to the existing `NormedField` instance is definitionally true.\nThis allows one to have the new `NontriviallyNormedField` instance without data clashes. -/\nlemma discreteTopology_or_nontriviallyNormedField (ùïú : Type*) [h : NormedField ùïú] :\n    DiscreteTopology ùïú ‚à® Nonempty ({h' : NontriviallyNormedField ùïú // h'.toNormedField = h}) := by\n  by_cases H : ‚àÉ x : ùïú, x ‚â† 0 ‚àß ‚Äñx‚Äñ ‚â† 1\n  ¬∑ exact Or.inr ‚ü®(‚ü®NontriviallyNormedField.ofNormNeOne H, rfl‚ü©)‚ü©\n  ¬∑ simp_rw [discreteTopology_iff_isOpen_singleton_zero, Metric.isOpen_singleton_iff, dist_eq_norm,\n             sub_zero]\n    refine Or.inl ‚ü®1, zero_lt_one, ?_‚ü©\n    contrapose! H\n    refine H.imp ?_\n    -- contextual to reuse the `a ‚â† 0` hypothesis in the proof of `a ‚â† 0 ‚àß ‚Äña‚Äñ ‚â† 1`\n    simp (config := {contextual := true}) [add_comm, ne_of_lt]\n\n"}
{"name":"NormedField.discreteTopology_of_bddAbove_range_norm","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"ùïú : Type u_4\ninst‚úù : NormedField ùïú\nh : BddAbove (Set.range fun k => Norm.norm k)\n‚ä¢ DiscreteTopology ùïú","decl":"lemma discreteTopology_of_bddAbove_range_norm {ùïú : Type*} [NormedField ùïú]\n    (h : BddAbove (Set.range fun k : ùïú ‚Ü¶ ‚Äñk‚Äñ)) :\n    DiscreteTopology ùïú := by\n  refine (NormedField.discreteTopology_or_nontriviallyNormedField _).resolve_right ?_\n  rintro ‚ü®_, rfl‚ü©\n  obtain ‚ü®x, h‚ü© := h\n  obtain ‚ü®k, hk‚ü© := NormedField.exists_lt_norm ùïú x\n  exact hk.not_le (h (Set.mem_range_self k))\n\n"}
{"name":"NormedField.denseRange_nnnorm","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : DenselyNormedField Œ±\n‚ä¢ DenseRange NNNorm.nnnorm","decl":"theorem denseRange_nnnorm : DenseRange (nnnorm : Œ± ‚Üí ‚Ñù‚â•0) :=\n  dense_of_exists_between fun _ _ hr =>\n    let ‚ü®x, h‚ü© := exists_lt_nnnorm_lt Œ± hr\n    ‚ü®‚Äñx‚Äñ‚Çä, ‚ü®x, rfl‚ü©, h‚ü©\n\n"}
{"name":"NormedField.continuousAt_zpow","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"ùïú : Type u_4\ninst‚úù : NontriviallyNormedField ùïú\nn : Int\nx : ùïú\n‚ä¢ Iff (ContinuousAt (fun x => HPow.hPow x n) x) (Or (Ne x 0) (LE.le 0 n))","decl":"@[simp]\nprotected lemma continuousAt_zpow : ContinuousAt (fun x ‚Ü¶ x ^ n) x ‚Üî x ‚â† 0 ‚à® 0 ‚â§ n := by\n  refine ‚ü®?_, continuousAt_zpow‚ÇÄ _ _‚ü©\n  contrapose!\n  rintro ‚ü®rfl, hm‚ü© hc\n  exact not_tendsto_atTop_of_tendsto_nhds (hc.tendsto.mono_left nhdsWithin_le_nhds).norm\n    (NormedField.tendsto_norm_zpow_nhdsNE_zero_atTop hm)\n\n"}
{"name":"NormedField.continuousAt_inv","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"ùïú : Type u_4\ninst‚úù : NontriviallyNormedField ùïú\nx : ùïú\n‚ä¢ Iff (ContinuousAt Inv.inv x) (Ne x 0)","decl":"@[simp]\nprotected lemma continuousAt_inv : ContinuousAt Inv.inv x ‚Üî x ‚â† 0 := by\n  simpa using NormedField.continuousAt_zpow (n := -1) (x := x)\n\n"}
{"name":"NNReal.lipschitzWith_sub","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"‚ä¢ LipschitzWith 2 fun p => HSub.hSub p.1 p.2","decl":"lemma lipschitzWith_sub : LipschitzWith 2 (fun (p : ‚Ñù‚â•0 √ó ‚Ñù‚â•0) ‚Ü¶ p.1 - p.2) := by\n  rw [‚Üê isometry_subtype_coe.lipschitzWith_iff]\n  have : Isometry (Prod.map ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù)) :=\n    isometry_subtype_coe.prod_map isometry_subtype_coe\n  convert (((LipschitzWith.prod_fst.comp this.lipschitz).sub\n    (LipschitzWith.prod_snd.comp this.lipschitz)).max_const 0)\n  norm_num\n\n"}
{"name":"Int.instNormOneClass","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"‚ä¢ NormOneClass Int","decl":"instance Int.instNormOneClass : NormOneClass ‚Ñ§ :=\n  ‚ü®by simp [‚Üê Int.norm_cast_real]‚ü©\n\n"}
{"name":"NormedField.completeSpace_iff_isComplete_closedBall","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"K : Type u_4\ninst‚úù : NormedField K\n‚ä¢ Iff (CompleteSpace K) (IsComplete (Metric.closedBall 0 1))","decl":"lemma NormedField.completeSpace_iff_isComplete_closedBall {K : Type*} [NormedField K] :\n    CompleteSpace K ‚Üî IsComplete (Metric.closedBall 0 1 : Set K) := by\n  constructor <;> intro h\n  ¬∑ exact Metric.isClosed_ball.isComplete\n  rcases NormedField.discreteTopology_or_nontriviallyNormedField K with _|‚ü®_, rfl‚ü©\n  ¬∑ rwa [completeSpace_iff_isComplete_univ,\n         ‚Üê NormedDivisionRing.unitClosedBall_eq_univ_of_discrete]\n  refine Metric.complete_of_cauchySeq_tendsto fun u hu ‚Ü¶ ?_\n  obtain ‚ü®k, hk‚ü© := hu.norm_bddAbove\n  have kpos : 0 ‚â§ k := (_root_.norm_nonneg (u 0)).trans (hk (by simp))\n  obtain ‚ü®x, hx‚ü© := NormedField.exists_lt_norm K k\n  have hu' : CauchySeq ((¬∑ / x) ‚àò u) := (uniformContinuous_div_const' x).comp_cauchySeq hu\n  have hb : ‚àÄ n, ((¬∑ / x) ‚àò u) n ‚àà Metric.closedBall 0 1 := by\n    intro\n    simp only [Function.comp_apply, Metric.mem_closedBall, dist_zero_right, norm_div]\n    rw [div_le_one (kpos.trans_lt hx)]\n    exact hx.le.trans' (hk (by simp))\n  obtain ‚ü®a, -, ha'‚ü© := cauchySeq_tendsto_of_isComplete h hb hu'\n  refine ‚ü®a * x, (((continuous_mul_right x).tendsto a).comp ha').congr ?_‚ü©\n  have hx' : x ‚â† 0 := by\n    contrapose! hx\n    simp [hx, kpos]\n  simp [div_mul_cancel‚ÇÄ _ hx']\n\n"}
