{"name":"Filter.Tendsto.zero_mul_isBoundedUnder_le","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : NonUnitalSeminormedRing α\nf g : ι → α\nl : Filter ι\nhf : Filter.Tendsto f l (nhds 0)\nhg : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp (fun x => Norm.norm x) g)\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l (nhds 0)","decl":"theorem Filter.Tendsto.zero_mul_isBoundedUnder_le {f g : ι → α} {l : Filter ι}\n    (hf : Tendsto f l (𝓝 0)) (hg : IsBoundedUnder (· ≤ ·) l ((‖·‖) ∘ g)) :\n    Tendsto (fun x => f x * g x) l (𝓝 0) :=\n  hf.op_zero_isBoundedUnder_le hg (· * ·) norm_mul_le\n\n"}
{"name":"Filter.isBoundedUnder_le_mul_tendsto_zero","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : NonUnitalSeminormedRing α\nf g : ι → α\nl : Filter ι\nhf : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm f)\nhg : Filter.Tendsto g l (nhds 0)\n⊢ Filter.Tendsto (fun x => HMul.hMul (f x) (g x)) l (nhds 0)","decl":"theorem Filter.isBoundedUnder_le_mul_tendsto_zero {f g : ι → α} {l : Filter ι}\n    (hf : IsBoundedUnder (· ≤ ·) l (norm ∘ f)) (hg : Tendsto g l (𝓝 0)) :\n    Tendsto (fun x => f x * g x) l (𝓝 0) :=\n  hg.op_zero_isBoundedUnder_le hf (flip (· * ·)) fun x y =>\n    (norm_mul_le y x).trans_eq (mul_comm _ _)\n\n"}
{"name":"NonUnitalSeminormedRing.toContinuousMul","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NonUnitalSeminormedRing α\n⊢ ContinuousMul α","decl":"instance (priority := 100) NonUnitalSeminormedRing.toContinuousMul [NonUnitalSeminormedRing α] :\n    ContinuousMul α :=\n  ⟨continuous_iff_continuousAt.2 fun x =>\n      tendsto_iff_norm_sub_tendsto_zero.2 <| by\n        have : ∀ e : α × α,\n            ‖e.1 * e.2 - x.1 * x.2‖ ≤ ‖e.1‖ * ‖e.2 - x.2‖ + ‖e.1 - x.1‖ * ‖x.2‖ := by\n          intro e\n          calc\n            ‖e.1 * e.2 - x.1 * x.2‖ ≤ ‖e.1 * (e.2 - x.2) + (e.1 - x.1) * x.2‖ := by\n              rw [mul_sub, sub_mul, sub_add_sub_cancel]\n            _ ≤ ‖e.1‖ * ‖e.2 - x.2‖ + ‖e.1 - x.1‖ * ‖x.2‖ :=\n              norm_add_le_of_le (norm_mul_le _ _) (norm_mul_le _ _)\n        refine squeeze_zero (fun e => norm_nonneg _) this ?_\n        convert\n          ((continuous_fst.tendsto x).norm.mul\n                ((continuous_snd.tendsto x).sub tendsto_const_nhds).norm).add\n            (((continuous_fst.tendsto x).sub tendsto_const_nhds).norm.mul _)\n        -- Porting note: `show` used to select a goal to work on\n        rotate_right\n        · show Tendsto _ _ _\n          exact tendsto_const_nhds\n        · simp⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"NonUnitalSeminormedRing.toTopologicalRing","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NonUnitalSeminormedRing α\n⊢ TopologicalRing α","decl":"/-- A seminormed ring is a topological ring. -/\ninstance (priority := 100) NonUnitalSeminormedRing.toTopologicalRing [NonUnitalSeminormedRing α] :\n    TopologicalRing α where\n\n"}
{"name":"SeparationQuotient.instNormOneClass","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝² : SeminormedAddCommGroup α\ninst✝¹ : One α\ninst✝ : NormOneClass α\n⊢ NormOneClass (SeparationQuotient α)","decl":"instance [SeminormedAddCommGroup α] [One α] [NormOneClass α] :\n    NormOneClass (SeparationQuotient α) where\n  norm_one := norm_one (α := α)\n\n"}
{"name":"antilipschitzWith_mul_left","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\na : α\nha : Ne a 0\n⊢ AntilipschitzWith (Inv.inv (NNNorm.nnnorm a)) fun x => HMul.hMul a x","decl":"lemma antilipschitzWith_mul_left {a : α} (ha : a ≠ 0) : AntilipschitzWith (‖a‖₊⁻¹) (a * ·) :=\n  AntilipschitzWith.of_le_mul_dist fun _ _ ↦ by simp [dist_eq_norm, ← _root_.mul_sub, ha]\n\n"}
{"name":"antilipschitzWith_mul_right","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\na : α\nha : Ne a 0\n⊢ AntilipschitzWith (Inv.inv (NNNorm.nnnorm a)) fun x => HMul.hMul x a","decl":"lemma antilipschitzWith_mul_right {a : α} (ha : a ≠ 0) : AntilipschitzWith (‖a‖₊⁻¹) (· * a) :=\n  AntilipschitzWith.of_le_mul_dist fun _ _ ↦ by\n    simp [dist_eq_norm, ← _root_.sub_mul, ← mul_comm (‖a‖), ha]\n\n"}
{"name":"DilationEquiv.mulLeft_symm_apply","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\na : α\nha : Ne a 0\nx : α\n⊢ Eq ((DilationEquiv.mulLeft a ha).symm x) (HMul.hMul (Inv.inv a) x)","decl":"/-- Multiplication by a nonzero element `a` on the left\nas a `DilationEquiv` of a normed division ring. -/\n@[simps!]\ndef DilationEquiv.mulLeft (a : α) (ha : a ≠ 0) : α ≃ᵈ α where\n  toEquiv := Equiv.mulLeft₀ a ha\n  edist_eq' := ⟨‖a‖₊, nnnorm_ne_zero_iff.2 ha, fun x y ↦ by\n    simp [edist_nndist, nndist_eq_nnnorm, ← mul_sub]⟩\n\n"}
{"name":"DilationEquiv.mulLeft_apply","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\na : α\nha : Ne a 0\nx : α\n⊢ Eq ((DilationEquiv.mulLeft a ha) x) (HMul.hMul a x)","decl":"/-- Multiplication by a nonzero element `a` on the left\nas a `DilationEquiv` of a normed division ring. -/\n@[simps!]\ndef DilationEquiv.mulLeft (a : α) (ha : a ≠ 0) : α ≃ᵈ α where\n  toEquiv := Equiv.mulLeft₀ a ha\n  edist_eq' := ⟨‖a‖₊, nnnorm_ne_zero_iff.2 ha, fun x y ↦ by\n    simp [edist_nndist, nndist_eq_nnnorm, ← mul_sub]⟩\n\n"}
{"name":"DilationEquiv.mulRight_symm_apply","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\na : α\nha : Ne a 0\nx : α\n⊢ Eq ((DilationEquiv.mulRight a ha).symm x) (HMul.hMul x (Inv.inv a))","decl":"/-- Multiplication by a nonzero element `a` on the right\nas a `DilationEquiv` of a normed division ring. -/\n@[simps!]\ndef DilationEquiv.mulRight (a : α) (ha : a ≠ 0) : α ≃ᵈ α where\n  toEquiv := Equiv.mulRight₀ a ha\n  edist_eq' := ⟨‖a‖₊, nnnorm_ne_zero_iff.2 ha, fun x y ↦ by\n    simp [edist_nndist, nndist_eq_nnnorm, ← sub_mul, ← mul_comm (‖a‖₊)]⟩\n\n"}
{"name":"DilationEquiv.mulRight_apply","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\na : α\nha : Ne a 0\nx : α\n⊢ Eq ((DilationEquiv.mulRight a ha) x) (HMul.hMul x a)","decl":"/-- Multiplication by a nonzero element `a` on the right\nas a `DilationEquiv` of a normed division ring. -/\n@[simps!]\ndef DilationEquiv.mulRight (a : α) (ha : a ≠ 0) : α ≃ᵈ α where\n  toEquiv := Equiv.mulRight₀ a ha\n  edist_eq' := ⟨‖a‖₊, nnnorm_ne_zero_iff.2 ha, fun x y ↦ by\n    simp [edist_nndist, nndist_eq_nnnorm, ← sub_mul, ← mul_comm (‖a‖₊)]⟩\n\n"}
{"name":"Filter.comap_mul_left_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\na : α\nha : Ne a 0\n⊢ Eq (Filter.comap (fun x => HMul.hMul a x) (Bornology.cobounded α)) (Bornology.cobounded α)","decl":"@[simp]\nlemma comap_mul_left_cobounded {a : α} (ha : a ≠ 0) :\n    comap (a * ·) (cobounded α) = cobounded α :=\n  Dilation.comap_cobounded (DilationEquiv.mulLeft a ha)\n\n"}
{"name":"Filter.map_mul_left_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\na : α\nha : Ne a 0\n⊢ Eq (Filter.map (fun x => HMul.hMul a x) (Bornology.cobounded α)) (Bornology.cobounded α)","decl":"@[simp]\nlemma map_mul_left_cobounded {a : α} (ha : a ≠ 0) :\n    map (a * ·) (cobounded α) = cobounded α :=\n  DilationEquiv.map_cobounded (DilationEquiv.mulLeft a ha)\n\n"}
{"name":"Filter.comap_mul_right_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\na : α\nha : Ne a 0\n⊢ Eq (Filter.comap (fun x => HMul.hMul x a) (Bornology.cobounded α)) (Bornology.cobounded α)","decl":"@[simp]\nlemma comap_mul_right_cobounded {a : α} (ha : a ≠ 0) :\n    comap (· * a) (cobounded α) = cobounded α :=\n  Dilation.comap_cobounded (DilationEquiv.mulRight a ha)\n\n"}
{"name":"Filter.map_mul_right_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\na : α\nha : Ne a 0\n⊢ Eq (Filter.map (fun x => HMul.hMul x a) (Bornology.cobounded α)) (Bornology.cobounded α)","decl":"@[simp]\nlemma map_mul_right_cobounded {a : α} (ha : a ≠ 0) :\n    map (· * a) (cobounded α) = cobounded α :=\n  DilationEquiv.map_cobounded (DilationEquiv.mulRight a ha)\n\n"}
{"name":"Filter.tendsto_mul_left_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\na : α\nha : Ne a 0\n⊢ Filter.Tendsto (fun x => HMul.hMul a x) (Bornology.cobounded α) (Bornology.cobounded α)","decl":"/-- Multiplication on the left by a nonzero element of a normed division ring tends to infinity at\ninfinity. -/\ntheorem tendsto_mul_left_cobounded {a : α} (ha : a ≠ 0) :\n    Tendsto (a * ·) (cobounded α) (cobounded α) :=\n  (map_mul_left_cobounded ha).le\n\n"}
{"name":"Filter.tendsto_mul_right_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\na : α\nha : Ne a 0\n⊢ Filter.Tendsto (fun x => HMul.hMul x a) (Bornology.cobounded α) (Bornology.cobounded α)","decl":"/-- Multiplication on the right by a nonzero element of a normed division ring tends to infinity at\ninfinity. -/\ntheorem tendsto_mul_right_cobounded {a : α} (ha : a ≠ 0) :\n    Tendsto (· * a) (cobounded α) (cobounded α) :=\n  (map_mul_right_cobounded ha).le\n\n"}
{"name":"Filter.inv_cobounded₀","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\n⊢ Eq (Inv.inv (Bornology.cobounded α)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"@[simp]\nlemma inv_cobounded₀ : (cobounded α)⁻¹ = 𝓝[≠] 0 := by\n  rw [← comap_norm_atTop, ← Filter.comap_inv, ← comap_norm_nhdsGT_zero, ← inv_atTop₀,\n    ← Filter.comap_inv]\n  simp only [comap_comap, Function.comp_def, norm_inv]\n\n"}
{"name":"Filter.inv_nhdsWithin_ne_zero","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\n⊢ Eq (Inv.inv (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))) (Bornology.cobounded α)","decl":"@[simp]\nlemma inv_nhdsWithin_ne_zero : (𝓝[≠] (0 : α))⁻¹ = cobounded α := by\n  rw [← inv_cobounded₀, inv_inv]\n\n"}
{"name":"Filter.tendsto_inv₀_cobounded'","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\n⊢ Filter.Tendsto Inv.inv (Bornology.cobounded α) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"lemma tendsto_inv₀_cobounded' : Tendsto Inv.inv (cobounded α) (𝓝[≠] 0) :=\n  inv_cobounded₀.le\n\n"}
{"name":"Filter.tendsto_inv₀_cobounded","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\n⊢ Filter.Tendsto Inv.inv (Bornology.cobounded α) (nhds 0)","decl":"theorem tendsto_inv₀_cobounded : Tendsto Inv.inv (cobounded α) (𝓝 0) :=\n  tendsto_inv₀_cobounded'.mono_right inf_le_left\n\n"}
{"name":"Filter.tendsto_inv₀_nhdsWithin_ne_zero","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\n⊢ Filter.Tendsto Inv.inv (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (Bornology.cobounded α)","decl":"lemma tendsto_inv₀_nhdsWithin_ne_zero : Tendsto Inv.inv (𝓝[≠] 0) (cobounded α) :=\n  inv_nhdsWithin_ne_zero.le\n\n"}
{"name":"NormedDivisionRing.to_hasContinuousInv₀","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\n⊢ HasContinuousInv₀ α","decl":"instance (priority := 100) NormedDivisionRing.to_hasContinuousInv₀ : HasContinuousInv₀ α := by\n  refine ⟨fun r r0 => tendsto_iff_norm_sub_tendsto_zero.2 ?_⟩\n  have r0' : 0 < ‖r‖ := norm_pos_iff.2 r0\n  rcases exists_between r0' with ⟨ε, ε0, εr⟩\n  have : ∀ᶠ e in 𝓝 r, ‖e⁻¹ - r⁻¹‖ ≤ ‖r - e‖ / ‖r‖ / ε := by\n    filter_upwards [(isOpen_lt continuous_const continuous_norm).eventually_mem εr] with e he\n    have e0 : e ≠ 0 := norm_pos_iff.1 (ε0.trans he)\n    calc\n      ‖e⁻¹ - r⁻¹‖ = ‖r‖⁻¹ * ‖r - e‖ * ‖e‖⁻¹ := by\n        rw [← norm_inv, ← norm_inv, ← norm_mul, ← norm_mul, mul_sub, sub_mul,\n          mul_assoc _ e, inv_mul_cancel₀ r0, mul_inv_cancel₀ e0, one_mul, mul_one]\n      _ = ‖r - e‖ / ‖r‖ / ‖e‖ := by field_simp [mul_comm]\n      _ ≤ ‖r - e‖ / ‖r‖ / ε := by gcongr\n  refine squeeze_zero' (Eventually.of_forall fun _ => norm_nonneg _) this ?_\n  refine (((continuous_const.sub continuous_id).norm.div_const _).div_const _).tendsto' _ _ ?_\n  simp\n\n-- see Note [lower instance priority]\n"}
{"name":"NormedDivisionRing.to_topologicalDivisionRing","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\n⊢ TopologicalDivisionRing α","decl":"/-- A normed division ring is a topological division ring. -/\ninstance (priority := 100) NormedDivisionRing.to_topologicalDivisionRing :\n    TopologicalDivisionRing α where\n\n"}
{"name":"IsOfFinOrder.norm_eq_one","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\na : α\nha : IsOfFinOrder a\n⊢ Eq (Norm.norm a) 1","decl":"protected lemma IsOfFinOrder.norm_eq_one (ha : IsOfFinOrder a) : ‖a‖ = 1 :=\n  ((normHom : α →*₀ ℝ).toMonoidHom.isOfFinOrder ha).eq_one <| norm_nonneg _\n\n"}
{"name":"AddChar.norm_apply","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝² : NormedDivisionRing α\nG : Type u_4\ninst✝¹ : AddLeftCancelMonoid G\ninst✝ : Finite G\nψ : AddChar G α\nx : G\n⊢ Eq (Norm.norm (ψ x)) 1","decl":"@[simp] lemma AddChar.norm_apply {G : Type*} [AddLeftCancelMonoid G] [Finite G] (ψ : AddChar G α)\n    (x : G) : ‖ψ x‖ = 1 := (ψ.toMonoidHom.isOfFinOrder <| isOfFinOrder_of_finite _).norm_eq_one\n\n"}
{"name":"NormedField.tendsto_norm_inv_nhdsNE_zero_atTop","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\n⊢ Filter.Tendsto (fun x => Norm.norm (Inv.inv x)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) Filter.atTop","decl":"lemma NormedField.tendsto_norm_inv_nhdsNE_zero_atTop : Tendsto (fun x : α ↦ ‖x⁻¹‖) (𝓝[≠] 0) atTop :=\n  (tendsto_inv_nhdsGT_zero.comp tendsto_norm_nhdsNE_zero).congr fun x ↦ (norm_inv x).symm\n\n"}
{"name":"NormedField.tendsto_norm_inverse_nhdsWithin_0_atTop","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\n⊢ Filter.Tendsto (fun x => Norm.norm (Inv.inv x)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) Filter.atTop","decl":"@[deprecated (since := \"2024-12-22\")]\nalias NormedField.tendsto_norm_inverse_nhdsWithin_0_atTop :=\n  NormedField.tendsto_norm_inv_nhdsNE_zero_atTop\n\n"}
{"name":"NormedField.tendsto_norm_zpow_nhdsNE_zero_atTop","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\nm : Int\nhm : LT.lt m 0\n⊢ Filter.Tendsto (fun x => Norm.norm (HPow.hPow x m)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) Filter.atTop","decl":"lemma NormedField.tendsto_norm_zpow_nhdsNE_zero_atTop {m : ℤ} (hm : m < 0) :\n    Tendsto (fun x : α ↦ ‖x ^ m‖) (𝓝[≠] 0) atTop := by\n  obtain ⟨m, rfl⟩ := neg_surjective m\n  rw [neg_lt_zero] at hm\n  lift m to ℕ using hm.le\n  rw [Int.natCast_pos] at hm\n  simp only [norm_pow, zpow_neg, zpow_natCast, ← inv_pow]\n  exact (tendsto_pow_atTop hm.ne').comp NormedField.tendsto_norm_inv_nhdsNE_zero_atTop\n\n"}
{"name":"NormedField.tendsto_norm_zpow_nhdsWithin_0_atTop","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : NormedDivisionRing α\nm : Int\nhm : LT.lt m 0\n⊢ Filter.Tendsto (fun x => Norm.norm (HPow.hPow x m)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) Filter.atTop","decl":"@[deprecated (since := \"2024-12-22\")]\nalias NormedField.tendsto_norm_zpow_nhdsWithin_0_atTop :=\n  NormedField.tendsto_norm_zpow_nhdsNE_zero_atTop\n\n"}
{"name":"NormedField.discreteTopology_or_nontriviallyNormedField","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"𝕜 : Type u_4\nh : NormedField 𝕜\n⊢ Or (DiscreteTopology 𝕜) (Nonempty (Subtype fun h' => Eq NontriviallyNormedField.toNormedField h))","decl":"/-- A normed field is either nontrivially normed or has a discrete topology.\nIn the discrete topology case, all the norms are 1, by `norm_eq_one_iff_ne_zero_of_discrete`.\nThe nontrivially normed field instance is provided by a subtype with a proof that the\nforgetful inheritance to the existing `NormedField` instance is definitionally true.\nThis allows one to have the new `NontriviallyNormedField` instance without data clashes. -/\nlemma discreteTopology_or_nontriviallyNormedField (𝕜 : Type*) [h : NormedField 𝕜] :\n    DiscreteTopology 𝕜 ∨ Nonempty ({h' : NontriviallyNormedField 𝕜 // h'.toNormedField = h}) := by\n  by_cases H : ∃ x : 𝕜, x ≠ 0 ∧ ‖x‖ ≠ 1\n  · exact Or.inr ⟨(⟨NontriviallyNormedField.ofNormNeOne H, rfl⟩)⟩\n  · simp_rw [discreteTopology_iff_isOpen_singleton_zero, Metric.isOpen_singleton_iff, dist_eq_norm,\n             sub_zero]\n    refine Or.inl ⟨1, zero_lt_one, ?_⟩\n    contrapose! H\n    refine H.imp ?_\n    -- contextual to reuse the `a ≠ 0` hypothesis in the proof of `a ≠ 0 ∧ ‖a‖ ≠ 1`\n    simp (config := {contextual := true}) [add_comm, ne_of_lt]\n\n"}
{"name":"NormedField.discreteTopology_of_bddAbove_range_norm","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"𝕜 : Type u_4\ninst✝ : NormedField 𝕜\nh : BddAbove (Set.range fun k => Norm.norm k)\n⊢ DiscreteTopology 𝕜","decl":"lemma discreteTopology_of_bddAbove_range_norm {𝕜 : Type*} [NormedField 𝕜]\n    (h : BddAbove (Set.range fun k : 𝕜 ↦ ‖k‖)) :\n    DiscreteTopology 𝕜 := by\n  refine (NormedField.discreteTopology_or_nontriviallyNormedField _).resolve_right ?_\n  rintro ⟨_, rfl⟩\n  obtain ⟨x, h⟩ := h\n  obtain ⟨k, hk⟩ := NormedField.exists_lt_norm 𝕜 x\n  exact hk.not_le (h (Set.mem_range_self k))\n\n"}
{"name":"NormedField.denseRange_nnnorm","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DenselyNormedField α\n⊢ DenseRange NNNorm.nnnorm","decl":"theorem denseRange_nnnorm : DenseRange (nnnorm : α → ℝ≥0) :=\n  dense_of_exists_between fun _ _ hr =>\n    let ⟨x, h⟩ := exists_lt_nnnorm_lt α hr\n    ⟨‖x‖₊, ⟨x, rfl⟩, h⟩\n\n"}
{"name":"NormedField.continuousAt_zpow","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"𝕜 : Type u_4\ninst✝ : NontriviallyNormedField 𝕜\nn : Int\nx : 𝕜\n⊢ Iff (ContinuousAt (fun x => HPow.hPow x n) x) (Or (Ne x 0) (LE.le 0 n))","decl":"@[simp]\nprotected lemma continuousAt_zpow : ContinuousAt (fun x ↦ x ^ n) x ↔ x ≠ 0 ∨ 0 ≤ n := by\n  refine ⟨?_, continuousAt_zpow₀ _ _⟩\n  contrapose!\n  rintro ⟨rfl, hm⟩ hc\n  exact not_tendsto_atTop_of_tendsto_nhds (hc.tendsto.mono_left nhdsWithin_le_nhds).norm\n    (NormedField.tendsto_norm_zpow_nhdsNE_zero_atTop hm)\n\n"}
{"name":"NormedField.continuousAt_inv","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"𝕜 : Type u_4\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\n⊢ Iff (ContinuousAt Inv.inv x) (Ne x 0)","decl":"@[simp]\nprotected lemma continuousAt_inv : ContinuousAt Inv.inv x ↔ x ≠ 0 := by\n  simpa using NormedField.continuousAt_zpow (n := -1) (x := x)\n\n"}
{"name":"NNReal.lipschitzWith_sub","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"⊢ LipschitzWith 2 fun p => HSub.hSub p.1 p.2","decl":"lemma lipschitzWith_sub : LipschitzWith 2 (fun (p : ℝ≥0 × ℝ≥0) ↦ p.1 - p.2) := by\n  rw [← isometry_subtype_coe.lipschitzWith_iff]\n  have : Isometry (Prod.map ((↑) : ℝ≥0 → ℝ) ((↑) : ℝ≥0 → ℝ)) :=\n    isometry_subtype_coe.prod_map isometry_subtype_coe\n  convert (((LipschitzWith.prod_fst.comp this.lipschitz).sub\n    (LipschitzWith.prod_snd.comp this.lipschitz)).max_const 0)\n  norm_num\n\n"}
{"name":"Int.instNormOneClass","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"⊢ NormOneClass Int","decl":"instance Int.instNormOneClass : NormOneClass ℤ :=\n  ⟨by simp [← Int.norm_cast_real]⟩\n\n"}
{"name":"NormedField.completeSpace_iff_isComplete_closedBall","module":"Mathlib.Analysis.Normed.Field.Lemmas","initialProofState":"K : Type u_4\ninst✝ : NormedField K\n⊢ Iff (CompleteSpace K) (IsComplete (Metric.closedBall 0 1))","decl":"lemma NormedField.completeSpace_iff_isComplete_closedBall {K : Type*} [NormedField K] :\n    CompleteSpace K ↔ IsComplete (Metric.closedBall 0 1 : Set K) := by\n  constructor <;> intro h\n  · exact Metric.isClosed_ball.isComplete\n  rcases NormedField.discreteTopology_or_nontriviallyNormedField K with _|⟨_, rfl⟩\n  · rwa [completeSpace_iff_isComplete_univ,\n         ← NormedDivisionRing.unitClosedBall_eq_univ_of_discrete]\n  refine Metric.complete_of_cauchySeq_tendsto fun u hu ↦ ?_\n  obtain ⟨k, hk⟩ := hu.norm_bddAbove\n  have kpos : 0 ≤ k := (_root_.norm_nonneg (u 0)).trans (hk (by simp))\n  obtain ⟨x, hx⟩ := NormedField.exists_lt_norm K k\n  have hu' : CauchySeq ((· / x) ∘ u) := (uniformContinuous_div_const' x).comp_cauchySeq hu\n  have hb : ∀ n, ((· / x) ∘ u) n ∈ Metric.closedBall 0 1 := by\n    intro\n    simp only [Function.comp_apply, Metric.mem_closedBall, dist_zero_right, norm_div]\n    rw [div_le_one (kpos.trans_lt hx)]\n    exact hx.le.trans' (hk (by simp))\n  obtain ⟨a, -, ha'⟩ := cauchySeq_tendsto_of_isComplete h hb hu'\n  refine ⟨a * x, (((continuous_mul_right x).tendsto a).comp ha').congr ?_⟩\n  have hx' : x ≠ 0 := by\n    contrapose! hx\n    simp [hx, kpos]\n  simp [div_mul_cancel₀ _ hx']\n\n"}
