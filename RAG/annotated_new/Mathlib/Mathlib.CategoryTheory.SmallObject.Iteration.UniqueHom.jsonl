{"name":"CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTransApp_eq_of_le","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\ninst‚úù¬≤ : LinearOrder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\ni : J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ (Order.succ i)\nhi : Not (IsMax i)\nœÜ : Quiver.Hom (iter‚ÇÅ.trunc ‚ãØ) (iter‚ÇÇ.trunc ‚ãØ)\nk : J\nhk : LE.le k i\n‚ä¢ Eq (CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTransApp hi œÜ k ‚ãØ) (œÜ.natTrans.app ‚ü®k, hk‚ü©)","decl":"lemma mkOfSuccNatTransApp_eq_of_le (k : J) (hk : k ‚â§ i) :\n    mkOfSuccNatTransApp hi œÜ k (hk.trans (Order.le_succ i)) =\n      œÜ.natTrans.app ‚ü®k, hk‚ü© :=\n  dif_neg (by rintro rfl; simpa using lt_of_le_of_lt hk (Order.lt_succ_of_not_isMax hi))\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTransApp_succ_eq","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\ninst‚úù¬≤ : LinearOrder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\ni : J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ (Order.succ i)\nhi : Not (IsMax i)\nœÜ : Quiver.Hom (iter‚ÇÅ.trunc ‚ãØ) (iter‚ÇÇ.trunc ‚ãØ)\n‚ä¢ Eq (CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTransApp hi œÜ (Order.succ i) ‚ãØ) (CategoryTheory.CategoryStruct.comp (iter‚ÇÅ.isoSucc i ‚ãØ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (œÜ.natTrans.app ‚ü®i, ‚ãØ‚ü©) Œ¶) (iter‚ÇÇ.isoSucc i ‚ãØ).inv))","decl":"@[simp]\nlemma mkOfSuccNatTransApp_succ_eq :\n    mkOfSuccNatTransApp hi œÜ (Order.succ i) (by rfl) =\n      (iter‚ÇÅ.isoSucc i (Order.lt_succ_of_not_isMax hi)).hom ‚â´\n        whiskerRight (œÜ.natTrans.app ‚ü®i, by simp‚ü©) _ ‚â´\n        (iter‚ÇÇ.isoSucc i (Order.lt_succ_of_not_isMax hi)).inv := by\n  dsimp [mkOfSuccNatTransApp]\n  rw [dif_pos rfl, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTrans_app","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\ninst‚úù¬≤ : LinearOrder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\ni : J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ (Order.succ i)\nhi : Not (IsMax i)\nœÜ : Quiver.Hom (iter‚ÇÅ.trunc ‚ãØ) (iter‚ÇÇ.trunc ‚ãØ)\nx‚úù : ‚Üë(Set.Iic (Order.succ i))\n‚ä¢ Eq ((CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTrans hi œÜ).app x‚úù) (CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTrans.match_1 (fun x => Quiver.Hom (iter‚ÇÅ.F.obj x) (iter‚ÇÇ.F.obj x)) x‚úù fun k hk => CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTransApp hi œÜ k hk)","decl":"/-- Auxiliary definition for `mkOfSucc`. -/\n@[simps]\nnoncomputable def mkOfSuccNatTrans :\n    iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F where\n  app := fun ‚ü®k, hk‚ü© => mkOfSuccNatTransApp hi œÜ k hk\n  naturality := fun ‚ü®k‚ÇÅ, hk‚ÇÅ‚ü© ‚ü®k‚ÇÇ, hk‚ÇÇ‚ü© f => by\n    dsimp\n    have hk : k‚ÇÅ ‚â§ k‚ÇÇ := leOfHom f\n    obtain h‚ÇÇ | rfl := hk‚ÇÇ.lt_or_eq\n    ¬∑ replace h‚ÇÇ : k‚ÇÇ ‚â§ i := Order.le_of_lt_succ h‚ÇÇ\n      rw [mkOfSuccNatTransApp_eq_of_le hi œÜ k‚ÇÇ h‚ÇÇ,\n        mkOfSuccNatTransApp_eq_of_le hi œÜ k‚ÇÅ (hk.trans h‚ÇÇ)]\n      exact natTrans_naturality œÜ k‚ÇÅ k‚ÇÇ hk h‚ÇÇ\n    ¬∑ obtain h‚ÇÅ | rfl := hk.lt_or_eq\n      ¬∑ have h‚ÇÇ : k‚ÇÅ ‚â§ i := Order.le_of_lt_succ h‚ÇÅ\n        let f‚ÇÅ : (‚ü®k‚ÇÅ, hk‚ü© : { l | l ‚â§ Order.succ i}) ‚ü∂\n          ‚ü®i, Order.le_succ i‚ü© := homOfLE h‚ÇÇ\n        let f‚ÇÇ : (‚ü®i, Order.le_succ i‚ü© : Set.Iic (Order.succ i)) ‚ü∂\n          ‚ü®Order.succ i, by simp‚ü© := homOfLE (Order.le_succ i)\n        obtain rfl : f = f‚ÇÅ ‚â´ f‚ÇÇ := rfl\n        rw [Functor.map_comp, Functor.map_comp, assoc,\n          mkOfSuccNatTransApp_eq_of_le hi œÜ k‚ÇÅ h‚ÇÇ]\n        erw [‚Üê natTrans_naturality_assoc œÜ k‚ÇÅ i h‚ÇÇ (by rfl)]\n        rw [mkOfSuccNatTransApp_succ_eq]\n        dsimp\n        have ha : iter‚ÇÅ.F.map f‚ÇÇ = iter‚ÇÅ.mapSucc i (Order.lt_succ_of_not_isMax hi) := rfl\n        have hb : iter‚ÇÇ.F.map f‚ÇÇ = iter‚ÇÇ.mapSucc i (Order.lt_succ_of_not_isMax hi) := rfl\n        rw [ha, hb]\n        rw [iter‚ÇÅ.mapSucc_eq i, iter‚ÇÇ.mapSucc_eq i, assoc,\n          Iso.inv_hom_id_assoc]\n        ext X\n        dsimp\n        rw [‚Üê Œµ.naturality_assoc]\n        rfl\n      ¬∑ obtain rfl : f = ùüô _ := rfl\n        rw [Functor.map_id, Functor.map_id, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTransApp_eq_of_lt","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\ninst‚úù¬≥ : LinearOrder J\ninst‚úù¬≤ : OrderBot J\ninst‚úù¬π : SuccOrder J\nj : J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nœÜ : (i : J) ‚Üí (hi : LT.lt i j) ‚Üí Quiver.Hom (iter‚ÇÅ.trunc ‚ãØ) (iter‚ÇÇ.trunc ‚ãØ)\ninst‚úù : WellFoundedLT J\nhj : Order.IsSuccLimit j\ni : J\nhi : LT.lt i j\n‚ä¢ Eq (CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTransApp œÜ hj i ‚ãØ) ((œÜ i hi).natTrans.app ‚ü®i, ‚ãØ‚ü©)","decl":"lemma mkOfLimitNatTransApp_eq_of_lt (i : J) (hi : i < j) :\n    mkOfLimitNatTransApp œÜ hj i hi.le = (œÜ i hi).natTrans.app ‚ü®i, by simp‚ü© :=\n  dif_pos hi\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTransApp_naturality_top","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\ninst‚úù¬≥ : LinearOrder J\ninst‚úù¬≤ : OrderBot J\ninst‚úù¬π : SuccOrder J\nj : J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nœÜ : (i : J) ‚Üí (hi : LT.lt i j) ‚Üí Quiver.Hom (iter‚ÇÅ.trunc ‚ãØ) (iter‚ÇÇ.trunc ‚ãØ)\ninst‚úù : WellFoundedLT J\nhj : Order.IsSuccLimit j\ni : J\nhi : LT.lt i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (iter‚ÇÅ.F.map (CategoryTheory.homOfLE ‚ãØ)) (CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTransApp œÜ hj j ‚ãØ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTransApp œÜ hj i ‚ãØ) (iter‚ÇÇ.F.map (CategoryTheory.homOfLE ‚ãØ)))","decl":"lemma mkOfLimitNatTransApp_naturality_top (i : J) (hi : i < j) :\n    iter‚ÇÅ.F.map (homOfLE (by simpa using hi.le) : ‚ü®i, hi.le‚ü© ‚ü∂ ‚ü®j, by simp‚ü©) ‚â´\n      mkOfLimitNatTransApp œÜ hj j (by rfl) =\n      mkOfLimitNatTransApp œÜ hj i hi.le ‚â´ iter‚ÇÇ.F.map (homOfLE (by simpa using hi.le)) := by\n  rw [mkOfLimitNatTransApp_eq_of_lt œÜ hj i hi, mkOfLimitNatTransApp, dif_neg (by simp)]\n  exact (iter‚ÇÅ.isColimit j hj (by rfl)).fac _ ‚ü®i, hi‚ü©\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTrans_app","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\ninst‚úù¬≤ : LinearOrder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\nj : J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\nœÜ : (i : J) ‚Üí (hi : LT.lt i j) ‚Üí Quiver.Hom (iter‚ÇÅ.trunc ‚ãØ) (iter‚ÇÇ.trunc ‚ãØ)\nhj : Order.IsSuccLimit j\nx‚úù : ‚Üë(Set.Iic j)\n‚ä¢ Eq ((CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTrans œÜ hj).app x‚úù) (CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTrans.match_1 (fun x => Quiver.Hom (iter‚ÇÅ.F.obj x) (iter‚ÇÇ.F.obj x)) x‚úù fun k hk => CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTransApp œÜ hj k hk)","decl":"/-- Auxiliary definition for `mkOfLimit`. -/\n@[simps]\ndef mkOfLimitNatTrans : iter‚ÇÅ.F ‚ü∂ iter‚ÇÇ.F where\n  app := fun ‚ü®k, hk‚ü© => mkOfLimitNatTransApp œÜ hj k hk\n  naturality := fun ‚ü®k‚ÇÅ, hk‚ÇÅ‚ü© ‚ü®k‚ÇÇ, hk‚ÇÇ‚ü© f => by\n    have hk : k‚ÇÅ ‚â§ k‚ÇÇ := leOfHom f\n    obtain h‚ÇÇ | rfl := hk‚ÇÇ.lt_or_eq\n    ¬∑ dsimp\n      rw [mkOfLimitNatTransApp_eq_of_lt _ hj k‚ÇÇ h‚ÇÇ,\n        mkOfLimitNatTransApp_eq_of_lt _ hj k‚ÇÅ (lt_of_le_of_lt hk h‚ÇÇ),\n        congr_app (œÜ k‚ÇÅ (lt_of_le_of_lt hk h‚ÇÇ)) ((truncFunctor Œµ hk).map (œÜ k‚ÇÇ h‚ÇÇ))]\n      exact natTrans_naturality (œÜ k‚ÇÇ h‚ÇÇ) k‚ÇÅ k‚ÇÇ hk (by rfl)\n    ¬∑ obtain h‚ÇÅ | rfl := hk‚ÇÅ.lt_or_eq\n      ¬∑ exact mkOfLimitNatTransApp_naturality_top _ hj _ h‚ÇÅ\n      ¬∑ obtain rfl : f = ùüô _ := rfl\n        simp only [map_id, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.instNonemptyHom","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\ninst‚úù¬≤ : LinearOrder J\ninst‚úù¬π : OrderBot J\ninst‚úù : SuccOrder J\nj : J\niter‚ÇÅ iter‚ÇÇ : CategoryTheory.Functor.Iteration Œµ j\n‚ä¢ Nonempty (Quiver.Hom iter‚ÇÅ iter‚ÇÇ)","decl":"instance : Nonempty (iter‚ÇÅ ‚ü∂ iter‚ÇÇ) := by\n  let P := fun (i : J) => ‚àÄ (hi : i ‚â§ j),\n    Nonempty ((truncFunctor Œµ hi).obj iter‚ÇÅ ‚ü∂ (truncFunctor Œµ hi).obj iter‚ÇÇ)\n  suffices ‚àÄ i, P i from this j (by rfl)\n  intro i\n  induction i using SuccOrder.limitRecOn with\n  | hm i hi =>\n    obtain rfl : i = ‚ä• := by simpa using hi\n    exact fun hi' ‚Ü¶ ‚ü®Hom.mkOfBot _ _‚ü©\n  | hs i hi hi' =>\n    exact fun hi'' ‚Ü¶ ‚ü®Hom.mkOfSucc _ _ hi (hi' ((Order.le_succ i).trans hi'')).some‚ü©\n  | hl i hi hi' =>\n    exact fun hi'' ‚Ü¶ ‚ü®Hom.mkOfLimit (fun k hk ‚Ü¶ (hi' k hk (hk.le.trans hi'')).some) hi‚ü©\n\n"}
{"name":"CategoryTheory.Functor.Iteration.iso_refl","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\ninst‚úù¬≥ : LinearOrder J\ninst‚úù¬≤ : OrderBot J\ninst‚úù¬π : SuccOrder J\ninst‚úù : WellFoundedLT J\nj : J\niter‚ÇÅ : CategoryTheory.Functor.Iteration Œµ j\n‚ä¢ Eq (iter‚ÇÅ.iso iter‚ÇÅ) (CategoryTheory.Iso.refl iter‚ÇÅ)","decl":"@[simp]\nlemma iso_refl : iso iter‚ÇÅ iter‚ÇÅ = Iso.refl _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Iteration.iso_trans","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\nŒ¶ : CategoryTheory.Functor C C\nŒµ : Quiver.Hom (CategoryTheory.Functor.id C) Œ¶\nJ : Type u\ninst‚úù¬≥ : LinearOrder J\ninst‚úù¬≤ : OrderBot J\ninst‚úù¬π : SuccOrder J\ninst‚úù : WellFoundedLT J\nj : J\niter‚ÇÅ iter‚ÇÇ iter‚ÇÉ : CategoryTheory.Functor.Iteration Œµ j\n‚ä¢ Eq ((iter‚ÇÅ.iso iter‚ÇÇ).trans (iter‚ÇÇ.iso iter‚ÇÉ)) (iter‚ÇÅ.iso iter‚ÇÉ)","decl":"lemma iso_trans : iso iter‚ÇÅ iter‚ÇÇ ‚â™‚â´ iso iter‚ÇÇ iter‚ÇÉ = iso iter‚ÇÅ iter‚ÇÉ := by aesop_cat\n\n"}
