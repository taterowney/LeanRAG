{"name":"CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTransApp_eq_of_le","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\nÎ¦ : CategoryTheory.Functor C C\nÎµ : Quiver.Hom (CategoryTheory.Functor.id C) Î¦\nJ : Type u\ninstâœÂ² : LinearOrder J\ninstâœÂ¹ : OrderBot J\ninstâœ : SuccOrder J\ni : J\niterâ‚ iterâ‚‚ : CategoryTheory.Functor.Iteration Îµ (Order.succ i)\nhi : Not (IsMax i)\nÏ† : Quiver.Hom (iterâ‚.trunc â‹¯) (iterâ‚‚.trunc â‹¯)\nk : J\nhk : LE.le k i\nâŠ¢ Eq (CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTransApp hi Ï† k â‹¯) (Ï†.natTrans.app âŸ¨k, hkâŸ©)","decl":"lemma mkOfSuccNatTransApp_eq_of_le (k : J) (hk : k â‰¤ i) :\n    mkOfSuccNatTransApp hi Ï† k (hk.trans (Order.le_succ i)) =\n      Ï†.natTrans.app âŸ¨k, hkâŸ© :=\n  dif_neg (by rintro rfl; simpa using lt_of_le_of_lt hk (Order.lt_succ_of_not_isMax hi))\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTransApp_succ_eq","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\nÎ¦ : CategoryTheory.Functor C C\nÎµ : Quiver.Hom (CategoryTheory.Functor.id C) Î¦\nJ : Type u\ninstâœÂ² : LinearOrder J\ninstâœÂ¹ : OrderBot J\ninstâœ : SuccOrder J\ni : J\niterâ‚ iterâ‚‚ : CategoryTheory.Functor.Iteration Îµ (Order.succ i)\nhi : Not (IsMax i)\nÏ† : Quiver.Hom (iterâ‚.trunc â‹¯) (iterâ‚‚.trunc â‹¯)\nâŠ¢ Eq (CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTransApp hi Ï† (Order.succ i) â‹¯) (CategoryTheory.CategoryStruct.comp (iterâ‚.isoSucc i â‹¯).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (Ï†.natTrans.app âŸ¨i, â‹¯âŸ©) Î¦) (iterâ‚‚.isoSucc i â‹¯).inv))","decl":"@[simp]\nlemma mkOfSuccNatTransApp_succ_eq :\n    mkOfSuccNatTransApp hi Ï† (Order.succ i) (by rfl) =\n      (iterâ‚.isoSucc i (Order.lt_succ_of_not_isMax hi)).hom â‰«\n        whiskerRight (Ï†.natTrans.app âŸ¨i, by simpâŸ©) _ â‰«\n        (iterâ‚‚.isoSucc i (Order.lt_succ_of_not_isMax hi)).inv := by\n  dsimp [mkOfSuccNatTransApp]\n  rw [dif_pos rfl, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTrans_app","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\nÎ¦ : CategoryTheory.Functor C C\nÎµ : Quiver.Hom (CategoryTheory.Functor.id C) Î¦\nJ : Type u\ninstâœÂ² : LinearOrder J\ninstâœÂ¹ : OrderBot J\ninstâœ : SuccOrder J\ni : J\niterâ‚ iterâ‚‚ : CategoryTheory.Functor.Iteration Îµ (Order.succ i)\nhi : Not (IsMax i)\nÏ† : Quiver.Hom (iterâ‚.trunc â‹¯) (iterâ‚‚.trunc â‹¯)\nxâœ : â†‘(Set.Iic (Order.succ i))\nâŠ¢ Eq ((CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTrans hi Ï†).app xâœ) (CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTrans.match_1 (fun x => Quiver.Hom (iterâ‚.F.obj x) (iterâ‚‚.F.obj x)) xâœ fun k hk => CategoryTheory.Functor.Iteration.Hom.mkOfSuccNatTransApp hi Ï† k hk)","decl":"/-- Auxiliary definition for `mkOfSucc`. -/\n@[simps]\nnoncomputable def mkOfSuccNatTrans :\n    iterâ‚.F âŸ¶ iterâ‚‚.F where\n  app := fun âŸ¨k, hkâŸ© => mkOfSuccNatTransApp hi Ï† k hk\n  naturality := fun âŸ¨kâ‚, hkâ‚âŸ© âŸ¨kâ‚‚, hkâ‚‚âŸ© f => by\n    dsimp\n    have hk : kâ‚ â‰¤ kâ‚‚ := leOfHom f\n    obtain hâ‚‚ | rfl := hkâ‚‚.lt_or_eq\n    Â· replace hâ‚‚ : kâ‚‚ â‰¤ i := Order.le_of_lt_succ hâ‚‚\n      rw [mkOfSuccNatTransApp_eq_of_le hi Ï† kâ‚‚ hâ‚‚,\n        mkOfSuccNatTransApp_eq_of_le hi Ï† kâ‚ (hk.trans hâ‚‚)]\n      exact natTrans_naturality Ï† kâ‚ kâ‚‚ hk hâ‚‚\n    Â· obtain hâ‚ | rfl := hk.lt_or_eq\n      Â· have hâ‚‚ : kâ‚ â‰¤ i := Order.le_of_lt_succ hâ‚\n        let fâ‚ : (âŸ¨kâ‚, hkâŸ© : { l | l â‰¤ Order.succ i}) âŸ¶\n          âŸ¨i, Order.le_succ iâŸ© := homOfLE hâ‚‚\n        let fâ‚‚ : (âŸ¨i, Order.le_succ iâŸ© : Set.Iic (Order.succ i)) âŸ¶\n          âŸ¨Order.succ i, by simpâŸ© := homOfLE (Order.le_succ i)\n        obtain rfl : f = fâ‚ â‰« fâ‚‚ := rfl\n        rw [Functor.map_comp, Functor.map_comp, assoc,\n          mkOfSuccNatTransApp_eq_of_le hi Ï† kâ‚ hâ‚‚]\n        erw [â† natTrans_naturality_assoc Ï† kâ‚ i hâ‚‚ (by rfl)]\n        rw [mkOfSuccNatTransApp_succ_eq]\n        dsimp\n        have ha : iterâ‚.F.map fâ‚‚ = iterâ‚.mapSucc i (Order.lt_succ_of_not_isMax hi) := rfl\n        have hb : iterâ‚‚.F.map fâ‚‚ = iterâ‚‚.mapSucc i (Order.lt_succ_of_not_isMax hi) := rfl\n        rw [ha, hb]\n        rw [iterâ‚.mapSucc_eq i, iterâ‚‚.mapSucc_eq i, assoc,\n          Iso.inv_hom_id_assoc]\n        ext X\n        dsimp\n        rw [â† Îµ.naturality_assoc]\n        rfl\n      Â· obtain rfl : f = ğŸ™ _ := rfl\n        rw [Functor.map_id, Functor.map_id, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTransApp_eq_of_lt","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_2, u_1} C\nÎ¦ : CategoryTheory.Functor C C\nÎµ : Quiver.Hom (CategoryTheory.Functor.id C) Î¦\nJ : Type u\ninstâœÂ³ : LinearOrder J\ninstâœÂ² : OrderBot J\ninstâœÂ¹ : SuccOrder J\nj : J\niterâ‚ iterâ‚‚ : CategoryTheory.Functor.Iteration Îµ j\nÏ† : (i : J) â†’ (hi : LT.lt i j) â†’ Quiver.Hom (iterâ‚.trunc â‹¯) (iterâ‚‚.trunc â‹¯)\ninstâœ : WellFoundedLT J\nhj : Order.IsSuccLimit j\ni : J\nhi : LT.lt i j\nâŠ¢ Eq (CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTransApp Ï† hj i â‹¯) ((Ï† i hi).natTrans.app âŸ¨i, â‹¯âŸ©)","decl":"lemma mkOfLimitNatTransApp_eq_of_lt (i : J) (hi : i < j) :\n    mkOfLimitNatTransApp Ï† hj i hi.le = (Ï† i hi).natTrans.app âŸ¨i, by simpâŸ© :=\n  dif_pos hi\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTransApp_naturality_top","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_2, u_1} C\nÎ¦ : CategoryTheory.Functor C C\nÎµ : Quiver.Hom (CategoryTheory.Functor.id C) Î¦\nJ : Type u\ninstâœÂ³ : LinearOrder J\ninstâœÂ² : OrderBot J\ninstâœÂ¹ : SuccOrder J\nj : J\niterâ‚ iterâ‚‚ : CategoryTheory.Functor.Iteration Îµ j\nÏ† : (i : J) â†’ (hi : LT.lt i j) â†’ Quiver.Hom (iterâ‚.trunc â‹¯) (iterâ‚‚.trunc â‹¯)\ninstâœ : WellFoundedLT J\nhj : Order.IsSuccLimit j\ni : J\nhi : LT.lt i j\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (iterâ‚.F.map (CategoryTheory.homOfLE â‹¯)) (CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTransApp Ï† hj j â‹¯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTransApp Ï† hj i â‹¯) (iterâ‚‚.F.map (CategoryTheory.homOfLE â‹¯)))","decl":"lemma mkOfLimitNatTransApp_naturality_top (i : J) (hi : i < j) :\n    iterâ‚.F.map (homOfLE (by simpa using hi.le) : âŸ¨i, hi.leâŸ© âŸ¶ âŸ¨j, by simpâŸ©) â‰«\n      mkOfLimitNatTransApp Ï† hj j (by rfl) =\n      mkOfLimitNatTransApp Ï† hj i hi.le â‰« iterâ‚‚.F.map (homOfLE (by simpa using hi.le)) := by\n  rw [mkOfLimitNatTransApp_eq_of_lt Ï† hj i hi, mkOfLimitNatTransApp, dif_neg (by simp)]\n  exact (iterâ‚.isColimit j hj (by rfl)).fac _ âŸ¨i, hiâŸ©\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTrans_app","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\nÎ¦ : CategoryTheory.Functor C C\nÎµ : Quiver.Hom (CategoryTheory.Functor.id C) Î¦\nJ : Type u\ninstâœÂ² : LinearOrder J\ninstâœÂ¹ : OrderBot J\ninstâœ : SuccOrder J\nj : J\niterâ‚ iterâ‚‚ : CategoryTheory.Functor.Iteration Îµ j\nÏ† : (i : J) â†’ (hi : LT.lt i j) â†’ Quiver.Hom (iterâ‚.trunc â‹¯) (iterâ‚‚.trunc â‹¯)\nhj : Order.IsSuccLimit j\nxâœ : â†‘(Set.Iic j)\nâŠ¢ Eq ((CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTrans Ï† hj).app xâœ) (CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTrans.match_1 (fun x => Quiver.Hom (iterâ‚.F.obj x) (iterâ‚‚.F.obj x)) xâœ fun k hk => CategoryTheory.Functor.Iteration.Hom.mkOfLimitNatTransApp Ï† hj k hk)","decl":"/-- Auxiliary definition for `mkOfLimit`. -/\n@[simps]\ndef mkOfLimitNatTrans : iterâ‚.F âŸ¶ iterâ‚‚.F where\n  app := fun âŸ¨k, hkâŸ© => mkOfLimitNatTransApp Ï† hj k hk\n  naturality := fun âŸ¨kâ‚, hkâ‚âŸ© âŸ¨kâ‚‚, hkâ‚‚âŸ© f => by\n    have hk : kâ‚ â‰¤ kâ‚‚ := leOfHom f\n    obtain hâ‚‚ | rfl := hkâ‚‚.lt_or_eq\n    Â· dsimp\n      rw [mkOfLimitNatTransApp_eq_of_lt _ hj kâ‚‚ hâ‚‚,\n        mkOfLimitNatTransApp_eq_of_lt _ hj kâ‚ (lt_of_le_of_lt hk hâ‚‚),\n        congr_app (Ï† kâ‚ (lt_of_le_of_lt hk hâ‚‚)) ((truncFunctor Îµ hk).map (Ï† kâ‚‚ hâ‚‚))]\n      exact natTrans_naturality (Ï† kâ‚‚ hâ‚‚) kâ‚ kâ‚‚ hk (by rfl)\n    Â· obtain hâ‚ | rfl := hkâ‚.lt_or_eq\n      Â· exact mkOfLimitNatTransApp_naturality_top _ hj _ hâ‚\n      Â· obtain rfl : f = ğŸ™ _ := rfl\n        simp only [map_id, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.Iteration.Hom.instNonemptyHom","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\nÎ¦ : CategoryTheory.Functor C C\nÎµ : Quiver.Hom (CategoryTheory.Functor.id C) Î¦\nJ : Type u\ninstâœÂ² : LinearOrder J\ninstâœÂ¹ : OrderBot J\ninstâœ : SuccOrder J\nj : J\niterâ‚ iterâ‚‚ : CategoryTheory.Functor.Iteration Îµ j\nâŠ¢ Nonempty (Quiver.Hom iterâ‚ iterâ‚‚)","decl":"instance : Nonempty (iterâ‚ âŸ¶ iterâ‚‚) := by\n  let P := fun (i : J) => âˆ€ (hi : i â‰¤ j),\n    Nonempty ((truncFunctor Îµ hi).obj iterâ‚ âŸ¶ (truncFunctor Îµ hi).obj iterâ‚‚)\n  suffices âˆ€ i, P i from this j (by rfl)\n  intro i\n  induction i using SuccOrder.limitRecOn with\n  | hm i hi =>\n    obtain rfl : i = âŠ¥ := by simpa using hi\n    exact fun hi' â†¦ âŸ¨Hom.mkOfBot _ _âŸ©\n  | hs i hi hi' =>\n    exact fun hi'' â†¦ âŸ¨Hom.mkOfSucc _ _ hi (hi' ((Order.le_succ i).trans hi'')).someâŸ©\n  | hl i hi hi' =>\n    exact fun hi'' â†¦ âŸ¨Hom.mkOfLimit (fun k hk â†¦ (hi' k hk (hk.le.trans hi'')).some) hiâŸ©\n\n"}
{"name":"CategoryTheory.Functor.Iteration.iso_refl","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_2, u_1} C\nÎ¦ : CategoryTheory.Functor C C\nÎµ : Quiver.Hom (CategoryTheory.Functor.id C) Î¦\nJ : Type u\ninstâœÂ³ : LinearOrder J\ninstâœÂ² : OrderBot J\ninstâœÂ¹ : SuccOrder J\ninstâœ : WellFoundedLT J\nj : J\niterâ‚ : CategoryTheory.Functor.Iteration Îµ j\nâŠ¢ Eq (iterâ‚.iso iterâ‚) (CategoryTheory.Iso.refl iterâ‚)","decl":"@[simp]\nlemma iso_refl : iso iterâ‚ iterâ‚ = Iso.refl _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.Iteration.iso_trans","module":"Mathlib.CategoryTheory.SmallObject.Iteration.UniqueHom","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_2, u_1} C\nÎ¦ : CategoryTheory.Functor C C\nÎµ : Quiver.Hom (CategoryTheory.Functor.id C) Î¦\nJ : Type u\ninstâœÂ³ : LinearOrder J\ninstâœÂ² : OrderBot J\ninstâœÂ¹ : SuccOrder J\ninstâœ : WellFoundedLT J\nj : J\niterâ‚ iterâ‚‚ iterâ‚ƒ : CategoryTheory.Functor.Iteration Îµ j\nâŠ¢ Eq ((iterâ‚.iso iterâ‚‚).trans (iterâ‚‚.iso iterâ‚ƒ)) (iterâ‚.iso iterâ‚ƒ)","decl":"lemma iso_trans : iso iterâ‚ iterâ‚‚ â‰ªâ‰« iso iterâ‚‚ iterâ‚ƒ = iso iterâ‚ iterâ‚ƒ := by aesop_cat\n\n"}
