{"name":"RelativeCWComplex.AttachGeneralizedCells.mk.inj","module":"Mathlib.Topology.CWComplex","initialProofState":"S D : TopCat\nf : Quiver.Hom S D\nX X' : TopCat\ncells✝ : Type u\nattachMaps✝ : cells✝ → Quiver.Hom S X\niso_pushout✝ : CategoryTheory.Iso X' (CategoryTheory.Limits.pushout (CategoryTheory.Limits.Sigma.desc attachMaps✝) (CategoryTheory.Limits.Sigma.map fun x => f))\ncells : Type u\nattachMaps : cells → Quiver.Hom S X\niso_pushout : CategoryTheory.Iso X' (CategoryTheory.Limits.pushout (CategoryTheory.Limits.Sigma.desc attachMaps) (CategoryTheory.Limits.Sigma.map fun x => f))\nx✝ : Eq { cells := cells✝, attachMaps := attachMaps✝, iso_pushout := iso_pushout✝ } { cells := cells, attachMaps := attachMaps, iso_pushout := iso_pushout }\n⊢ And (Eq cells✝ cells) (And (HEq attachMaps✝ attachMaps) (HEq iso_pushout✝ iso_pushout))","decl":"/-- A type witnessing that `X'` is obtained from `X` by attaching generalized cells `f : S ⟶ D` -/\nstructure AttachGeneralizedCells {S D : TopCat.{u}} (f : S ⟶ D) (X X' : TopCat.{u}) where\n  /-- The index type over the generalized cells -/\n  cells : Type u\n  /-- An attaching map for each generalized cell -/\n  attachMaps : cells → (S ⟶ X)\n  /-- `X'` is the pushout of `∐ S ⟶ X` and `∐ S ⟶ ∐ D`. -/\n  iso_pushout : X' ≅ Limits.pushout (Limits.Sigma.desc attachMaps) (Limits.Sigma.map fun _ ↦ f)\n\n"}
{"name":"RelativeCWComplex.AttachGeneralizedCells.mk.injEq","module":"Mathlib.Topology.CWComplex","initialProofState":"S D : TopCat\nf : Quiver.Hom S D\nX X' : TopCat\ncells✝ : Type u\nattachMaps✝ : cells✝ → Quiver.Hom S X\niso_pushout✝ : CategoryTheory.Iso X' (CategoryTheory.Limits.pushout (CategoryTheory.Limits.Sigma.desc attachMaps✝) (CategoryTheory.Limits.Sigma.map fun x => f))\ncells : Type u\nattachMaps : cells → Quiver.Hom S X\niso_pushout : CategoryTheory.Iso X' (CategoryTheory.Limits.pushout (CategoryTheory.Limits.Sigma.desc attachMaps) (CategoryTheory.Limits.Sigma.map fun x => f))\n⊢ Eq (Eq { cells := cells✝, attachMaps := attachMaps✝, iso_pushout := iso_pushout✝ } { cells := cells, attachMaps := attachMaps, iso_pushout := iso_pushout }) (And (Eq cells✝ cells) (And (HEq attachMaps✝ attachMaps) (HEq iso_pushout✝ iso_pushout)))","decl":"/-- A type witnessing that `X'` is obtained from `X` by attaching generalized cells `f : S ⟶ D` -/\nstructure AttachGeneralizedCells {S D : TopCat.{u}} (f : S ⟶ D) (X X' : TopCat.{u}) where\n  /-- The index type over the generalized cells -/\n  cells : Type u\n  /-- An attaching map for each generalized cell -/\n  attachMaps : cells → (S ⟶ X)\n  /-- `X'` is the pushout of `∐ S ⟶ X` and `∐ S ⟶ ∐ D`. -/\n  iso_pushout : X' ≅ Limits.pushout (Limits.Sigma.desc attachMaps) (Limits.Sigma.map fun _ ↦ f)\n\n"}
{"name":"RelativeCWComplex.AttachGeneralizedCells.mk.sizeOf_spec","module":"Mathlib.Topology.CWComplex","initialProofState":"S D : TopCat\nf : Quiver.Hom S D\nX X' : TopCat\ncells : Type u\nattachMaps : cells → Quiver.Hom S X\niso_pushout : CategoryTheory.Iso X' (CategoryTheory.Limits.pushout (CategoryTheory.Limits.Sigma.desc attachMaps) (CategoryTheory.Limits.Sigma.map fun x => f))\n⊢ Eq (SizeOf.sizeOf { cells := cells, attachMaps := attachMaps, iso_pushout := iso_pushout }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf cells)) (SizeOf.sizeOf iso_pushout))","decl":"/-- A type witnessing that `X'` is obtained from `X` by attaching generalized cells `f : S ⟶ D` -/\nstructure AttachGeneralizedCells {S D : TopCat.{u}} (f : S ⟶ D) (X X' : TopCat.{u}) where\n  /-- The index type over the generalized cells -/\n  cells : Type u\n  /-- An attaching map for each generalized cell -/\n  attachMaps : cells → (S ⟶ X)\n  /-- `X'` is the pushout of `∐ S ⟶ X` and `∐ S ⟶ ∐ D`. -/\n  iso_pushout : X' ≅ Limits.pushout (Limits.Sigma.desc attachMaps) (Limits.Sigma.map fun _ ↦ f)\n\n"}
{"name":"RelativeCWComplex.mk.inj","module":"Mathlib.Topology.CWComplex","initialProofState":"sk✝ : Nat → TopCat\nattachCells✝ : (n : Nat) → RelativeCWComplex.AttachCells (HSub.hSub (↑n) 1) (sk✝ n) (sk✝ (HAdd.hAdd n 1))\nsk : Nat → TopCat\nattachCells : (n : Nat) → RelativeCWComplex.AttachCells (HSub.hSub (↑n) 1) (sk n) (sk (HAdd.hAdd n 1))\nx✝ : Eq { sk := sk✝, attachCells := attachCells✝ } { sk := sk, attachCells := attachCells }\n⊢ And (Eq sk✝ sk) (HEq attachCells✝ attachCells)","decl":"/-- A relative CW-complex consists of an expanding sequence of subspaces `sk i` (called the\n$(i-1)$-skeleton) for `i ≥ 0`, where `sk 0` (i.e., the $(-1)$-skeleton) is an arbitrary topological\nspace, and each `sk (n + 1)` (i.e., the `n`-skeleton) is obtained from `sk n` (i.e., the\n$(n-1)$-skeleton) by attaching `n`-disks. -/\nstructure RelativeCWComplex where\n  /-- The skeletons. Note: `sk i` is usually called the $(i-1)$-skeleton in the math literature. -/\n  sk : ℕ → TopCat.{u}\n  /-- Each `sk (n + 1)` (i.e., the $n$-skeleton) is obtained from `sk n`\n  (i.e., the $(n-1)$-skeleton) by attaching `n`-disks. -/\n  attachCells (n : ℕ) : RelativeCWComplex.AttachCells ((n : ℤ) - 1) (sk n) (sk (n + 1))\n\n"}
{"name":"RelativeCWComplex.mk.sizeOf_spec","module":"Mathlib.Topology.CWComplex","initialProofState":"sk : Nat → TopCat\nattachCells : (n : Nat) → RelativeCWComplex.AttachCells (HSub.hSub (↑n) 1) (sk n) (sk (HAdd.hAdd n 1))\n⊢ Eq (SizeOf.sizeOf { sk := sk, attachCells := attachCells }) 1","decl":"/-- A relative CW-complex consists of an expanding sequence of subspaces `sk i` (called the\n$(i-1)$-skeleton) for `i ≥ 0`, where `sk 0` (i.e., the $(-1)$-skeleton) is an arbitrary topological\nspace, and each `sk (n + 1)` (i.e., the `n`-skeleton) is obtained from `sk n` (i.e., the\n$(n-1)$-skeleton) by attaching `n`-disks. -/\nstructure RelativeCWComplex where\n  /-- The skeletons. Note: `sk i` is usually called the $(i-1)$-skeleton in the math literature. -/\n  sk : ℕ → TopCat.{u}\n  /-- Each `sk (n + 1)` (i.e., the $n$-skeleton) is obtained from `sk n`\n  (i.e., the $(n-1)$-skeleton) by attaching `n`-disks. -/\n  attachCells (n : ℕ) : RelativeCWComplex.AttachCells ((n : ℤ) - 1) (sk n) (sk (n + 1))\n\n"}
{"name":"RelativeCWComplex.mk.injEq","module":"Mathlib.Topology.CWComplex","initialProofState":"sk✝ : Nat → TopCat\nattachCells✝ : (n : Nat) → RelativeCWComplex.AttachCells (HSub.hSub (↑n) 1) (sk✝ n) (sk✝ (HAdd.hAdd n 1))\nsk : Nat → TopCat\nattachCells : (n : Nat) → RelativeCWComplex.AttachCells (HSub.hSub (↑n) 1) (sk n) (sk (HAdd.hAdd n 1))\n⊢ Eq (Eq { sk := sk✝, attachCells := attachCells✝ } { sk := sk, attachCells := attachCells }) (And (Eq sk✝ sk) (HEq attachCells✝ attachCells))","decl":"/-- A relative CW-complex consists of an expanding sequence of subspaces `sk i` (called the\n$(i-1)$-skeleton) for `i ≥ 0`, where `sk 0` (i.e., the $(-1)$-skeleton) is an arbitrary topological\nspace, and each `sk (n + 1)` (i.e., the `n`-skeleton) is obtained from `sk n` (i.e., the\n$(n-1)$-skeleton) by attaching `n`-disks. -/\nstructure RelativeCWComplex where\n  /-- The skeletons. Note: `sk i` is usually called the $(i-1)$-skeleton in the math literature. -/\n  sk : ℕ → TopCat.{u}\n  /-- Each `sk (n + 1)` (i.e., the $n$-skeleton) is obtained from `sk n`\n  (i.e., the $(n-1)$-skeleton) by attaching `n`-disks. -/\n  attachCells (n : ℕ) : RelativeCWComplex.AttachCells ((n : ℤ) - 1) (sk n) (sk (n + 1))\n\n"}
{"name":"CWComplex.mk.injEq","module":"Mathlib.Topology.CWComplex","initialProofState":"toRelativeCWComplex✝ : RelativeCWComplex\nisEmpty_sk_zero✝ : IsEmpty ↑(toRelativeCWComplex✝.sk 0)\ntoRelativeCWComplex : RelativeCWComplex\nisEmpty_sk_zero : IsEmpty ↑(toRelativeCWComplex.sk 0)\n⊢ Eq (Eq { toRelativeCWComplex := toRelativeCWComplex✝, isEmpty_sk_zero := isEmpty_sk_zero✝ } { toRelativeCWComplex := toRelativeCWComplex, isEmpty_sk_zero := isEmpty_sk_zero }) (Eq toRelativeCWComplex✝ toRelativeCWComplex)","decl":"/-- A CW-complex is a relative CW-complex whose `sk 0` (i.e., $(-1)$-skeleton) is empty. -/\nstructure CWComplex extends RelativeCWComplex.{u} where\n  /-- `sk 0` (i.e., the $(-1)$-skeleton) is empty. -/\n  isEmpty_sk_zero : IsEmpty (sk 0)\n\n"}
{"name":"CWComplex.mk.inj","module":"Mathlib.Topology.CWComplex","initialProofState":"toRelativeCWComplex✝ : RelativeCWComplex\nisEmpty_sk_zero✝ : IsEmpty ↑(toRelativeCWComplex✝.sk 0)\ntoRelativeCWComplex : RelativeCWComplex\nisEmpty_sk_zero : IsEmpty ↑(toRelativeCWComplex.sk 0)\nx✝ : Eq { toRelativeCWComplex := toRelativeCWComplex✝, isEmpty_sk_zero := isEmpty_sk_zero✝ } { toRelativeCWComplex := toRelativeCWComplex, isEmpty_sk_zero := isEmpty_sk_zero }\n⊢ Eq toRelativeCWComplex✝ toRelativeCWComplex","decl":"/-- A CW-complex is a relative CW-complex whose `sk 0` (i.e., $(-1)$-skeleton) is empty. -/\nstructure CWComplex extends RelativeCWComplex.{u} where\n  /-- `sk 0` (i.e., the $(-1)$-skeleton) is empty. -/\n  isEmpty_sk_zero : IsEmpty (sk 0)\n\n"}
{"name":"CWComplex.isEmpty_sk_zero","module":"Mathlib.Topology.CWComplex","initialProofState":"self : CWComplex\n⊢ IsEmpty ↑(self.sk 0)","decl":"/-- A CW-complex is a relative CW-complex whose `sk 0` (i.e., $(-1)$-skeleton) is empty. -/\nstructure CWComplex extends RelativeCWComplex.{u} where\n  /-- `sk 0` (i.e., the $(-1)$-skeleton) is empty. -/\n  isEmpty_sk_zero : IsEmpty (sk 0)\n\n"}
{"name":"CWComplex.mk.sizeOf_spec","module":"Mathlib.Topology.CWComplex","initialProofState":"toRelativeCWComplex : RelativeCWComplex\nisEmpty_sk_zero : IsEmpty ↑(toRelativeCWComplex.sk 0)\n⊢ Eq (SizeOf.sizeOf { toRelativeCWComplex := toRelativeCWComplex, isEmpty_sk_zero := isEmpty_sk_zero }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toRelativeCWComplex)) (SizeOf.sizeOf isEmpty_sk_zero))","decl":"/-- A CW-complex is a relative CW-complex whose `sk 0` (i.e., $(-1)$-skeleton) is empty. -/\nstructure CWComplex extends RelativeCWComplex.{u} where\n  /-- `sk 0` (i.e., the $(-1)$-skeleton) is empty. -/\n  isEmpty_sk_zero : IsEmpty (sk 0)\n\n"}
