{"name":"Subsemigroup.mem_iSup_of_directed","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : Mul M\nS : ι → Subsemigroup M\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\nx : M\n⊢ Iff (Membership.mem (iSup fun i => S i) x) (Exists fun i => Membership.mem (S i) x)","decl":"@[to_additive]\ntheorem mem_iSup_of_directed {S : ι → Subsemigroup M} (hS : Directed (· ≤ ·) S) {x : M} :\n    (x ∈ ⨆ i, S i) ↔ ∃ i, x ∈ S i := by\n  refine ⟨?_, fun ⟨i, hi⟩ ↦ le_iSup S i hi⟩\n  suffices x ∈ closure (⋃ i, (S i : Set M)) → ∃ i, x ∈ S i by\n    simpa only [closure_iUnion, closure_eq (S _)] using this\n  refine fun hx ↦ closure_induction (fun y hy ↦ mem_iUnion.mp hy) ?_ hx\n  rintro x y - - ⟨i, hi⟩ ⟨j, hj⟩\n  rcases hS i j with ⟨k, hki, hkj⟩\n  exact ⟨k, (S k).mul_mem (hki hi) (hkj hj)⟩\n\n"}
{"name":"AddSubsemigroup.mem_iSup_of_directed","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : Add M\nS : ι → AddSubsemigroup M\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\nx : M\n⊢ Iff (Membership.mem (iSup fun i => S i) x) (Exists fun i => Membership.mem (S i) x)","decl":"@[to_additive]\ntheorem mem_iSup_of_directed {S : ι → Subsemigroup M} (hS : Directed (· ≤ ·) S) {x : M} :\n    (x ∈ ⨆ i, S i) ↔ ∃ i, x ∈ S i := by\n  refine ⟨?_, fun ⟨i, hi⟩ ↦ le_iSup S i hi⟩\n  suffices x ∈ closure (⋃ i, (S i : Set M)) → ∃ i, x ∈ S i by\n    simpa only [closure_iUnion, closure_eq (S _)] using this\n  refine fun hx ↦ closure_induction (fun y hy ↦ mem_iUnion.mp hy) ?_ hx\n  rintro x y - - ⟨i, hi⟩ ⟨j, hj⟩\n  rcases hS i j with ⟨k, hki, hkj⟩\n  exact ⟨k, (S k).mul_mem (hki hi) (hkj hj)⟩\n\n"}
{"name":"AddSubsemigroup.coe_iSup_of_directed","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : Add M\nS : ι → AddSubsemigroup M\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(iSup fun i => S i)) (Set.iUnion fun i => ↑(S i))","decl":"@[to_additive]\ntheorem coe_iSup_of_directed {S : ι → Subsemigroup M} (hS : Directed (· ≤ ·) S) :\n    ((⨆ i, S i : Subsemigroup M) : Set M) = ⋃ i, S i :=\n  Set.ext fun x => by simp [mem_iSup_of_directed hS]\n\n"}
{"name":"Subsemigroup.coe_iSup_of_directed","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : Mul M\nS : ι → Subsemigroup M\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(iSup fun i => S i)) (Set.iUnion fun i => ↑(S i))","decl":"@[to_additive]\ntheorem coe_iSup_of_directed {S : ι → Subsemigroup M} (hS : Directed (· ≤ ·) S) :\n    ((⨆ i, S i : Subsemigroup M) : Set M) = ⋃ i, S i :=\n  Set.ext fun x => by simp [mem_iSup_of_directed hS]\n\n"}
{"name":"AddSubsemigroup.mem_sSup_of_directed_on","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"M : Type u_2\ninst✝ : Add M\nS : Set (AddSubsemigroup M)\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\nx : M\n⊢ Iff (Membership.mem (SupSet.sSup S) x) (Exists fun s => And (Membership.mem S s) (Membership.mem s x))","decl":"@[to_additive]\ntheorem mem_sSup_of_directed_on {S : Set (Subsemigroup M)} (hS : DirectedOn (· ≤ ·) S) {x : M} :\n    x ∈ sSup S ↔ ∃ s ∈ S, x ∈ s := by\n  simp only [sSup_eq_iSup', mem_iSup_of_directed hS.directed_val, SetCoe.exists, Subtype.coe_mk,\n    exists_prop]\n\n"}
{"name":"Subsemigroup.mem_sSup_of_directed_on","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"M : Type u_2\ninst✝ : Mul M\nS : Set (Subsemigroup M)\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\nx : M\n⊢ Iff (Membership.mem (SupSet.sSup S) x) (Exists fun s => And (Membership.mem S s) (Membership.mem s x))","decl":"@[to_additive]\ntheorem mem_sSup_of_directed_on {S : Set (Subsemigroup M)} (hS : DirectedOn (· ≤ ·) S) {x : M} :\n    x ∈ sSup S ↔ ∃ s ∈ S, x ∈ s := by\n  simp only [sSup_eq_iSup', mem_iSup_of_directed hS.directed_val, SetCoe.exists, Subtype.coe_mk,\n    exists_prop]\n\n"}
{"name":"Subsemigroup.coe_sSup_of_directed_on","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"M : Type u_2\ninst✝ : Mul M\nS : Set (Subsemigroup M)\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(SupSet.sSup S)) (Set.iUnion fun s => Set.iUnion fun h => ↑s)","decl":"@[to_additive]\ntheorem coe_sSup_of_directed_on {S : Set (Subsemigroup M)} (hS : DirectedOn (· ≤ ·) S) :\n    (↑(sSup S) : Set M) = ⋃ s ∈ S, ↑s :=\n  Set.ext fun x => by simp [mem_sSup_of_directed_on hS]\n\n"}
{"name":"AddSubsemigroup.coe_sSup_of_directed_on","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"M : Type u_2\ninst✝ : Add M\nS : Set (AddSubsemigroup M)\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(SupSet.sSup S)) (Set.iUnion fun s => Set.iUnion fun h => ↑s)","decl":"@[to_additive]\ntheorem coe_sSup_of_directed_on {S : Set (Subsemigroup M)} (hS : DirectedOn (· ≤ ·) S) :\n    (↑(sSup S) : Set M) = ⋃ s ∈ S, ↑s :=\n  Set.ext fun x => by simp [mem_sSup_of_directed_on hS]\n\n"}
{"name":"Subsemigroup.mem_sup_left","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"M : Type u_2\ninst✝ : Mul M\nS T : Subsemigroup M\nx : M\na✝ : Membership.mem S x\n⊢ Membership.mem (Max.max S T) x","decl":"@[to_additive]\ntheorem mem_sup_left {S T : Subsemigroup M} : ∀ {x : M}, x ∈ S → x ∈ S ⊔ T := by\n  have : S ≤ S ⊔ T := le_sup_left\n  tauto\n\n"}
{"name":"AddSubsemigroup.mem_sup_left","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"M : Type u_2\ninst✝ : Add M\nS T : AddSubsemigroup M\nx : M\na✝ : Membership.mem S x\n⊢ Membership.mem (Max.max S T) x","decl":"@[to_additive]\ntheorem mem_sup_left {S T : Subsemigroup M} : ∀ {x : M}, x ∈ S → x ∈ S ⊔ T := by\n  have : S ≤ S ⊔ T := le_sup_left\n  tauto\n\n"}
{"name":"Subsemigroup.mem_sup_right","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"M : Type u_2\ninst✝ : Mul M\nS T : Subsemigroup M\nx : M\na✝ : Membership.mem T x\n⊢ Membership.mem (Max.max S T) x","decl":"@[to_additive]\ntheorem mem_sup_right {S T : Subsemigroup M} : ∀ {x : M}, x ∈ T → x ∈ S ⊔ T := by\n  have : T ≤ S ⊔ T := le_sup_right\n  tauto\n\n"}
{"name":"AddSubsemigroup.mem_sup_right","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"M : Type u_2\ninst✝ : Add M\nS T : AddSubsemigroup M\nx : M\na✝ : Membership.mem T x\n⊢ Membership.mem (Max.max S T) x","decl":"@[to_additive]\ntheorem mem_sup_right {S T : Subsemigroup M} : ∀ {x : M}, x ∈ T → x ∈ S ⊔ T := by\n  have : T ≤ S ⊔ T := le_sup_right\n  tauto\n\n"}
{"name":"AddSubsemigroup.add_mem_sup","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"M : Type u_2\ninst✝ : Add M\nS T : AddSubsemigroup M\nx y : M\nhx : Membership.mem S x\nhy : Membership.mem T y\n⊢ Membership.mem (Max.max S T) (HAdd.hAdd x y)","decl":"@[to_additive]\ntheorem mul_mem_sup {S T : Subsemigroup M} {x y : M} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ S ⊔ T :=\n  mul_mem (mem_sup_left hx) (mem_sup_right hy)\n\n"}
{"name":"Subsemigroup.mul_mem_sup","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"M : Type u_2\ninst✝ : Mul M\nS T : Subsemigroup M\nx y : M\nhx : Membership.mem S x\nhy : Membership.mem T y\n⊢ Membership.mem (Max.max S T) (HMul.hMul x y)","decl":"@[to_additive]\ntheorem mul_mem_sup {S T : Subsemigroup M} {x y : M} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ S ⊔ T :=\n  mul_mem (mem_sup_left hx) (mem_sup_right hy)\n\n"}
{"name":"AddSubsemigroup.mem_iSup_of_mem","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : Add M\nS : ι → AddSubsemigroup M\ni : ι\nx : M\na✝ : Membership.mem (S i) x\n⊢ Membership.mem (iSup S) x","decl":"@[to_additive]\ntheorem mem_iSup_of_mem {S : ι → Subsemigroup M} (i : ι) : ∀ {x : M}, x ∈ S i → x ∈ iSup S := by\n  have : S i ≤ iSup S := le_iSup _ _\n  tauto\n\n"}
{"name":"Subsemigroup.mem_iSup_of_mem","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : Mul M\nS : ι → Subsemigroup M\ni : ι\nx : M\na✝ : Membership.mem (S i) x\n⊢ Membership.mem (iSup S) x","decl":"@[to_additive]\ntheorem mem_iSup_of_mem {S : ι → Subsemigroup M} (i : ι) : ∀ {x : M}, x ∈ S i → x ∈ iSup S := by\n  have : S i ≤ iSup S := le_iSup _ _\n  tauto\n\n"}
{"name":"Subsemigroup.mem_sSup_of_mem","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"M : Type u_2\ninst✝ : Mul M\nS : Set (Subsemigroup M)\ns : Subsemigroup M\nhs : Membership.mem S s\nx : M\na✝ : Membership.mem s x\n⊢ Membership.mem (SupSet.sSup S) x","decl":"@[to_additive]\ntheorem mem_sSup_of_mem {S : Set (Subsemigroup M)} {s : Subsemigroup M} (hs : s ∈ S) :\n    ∀ {x : M}, x ∈ s → x ∈ sSup S := by\n  have : s ≤ sSup S := le_sSup hs\n  tauto\n\n"}
{"name":"AddSubsemigroup.mem_sSup_of_mem","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"M : Type u_2\ninst✝ : Add M\nS : Set (AddSubsemigroup M)\ns : AddSubsemigroup M\nhs : Membership.mem S s\nx : M\na✝ : Membership.mem s x\n⊢ Membership.mem (SupSet.sSup S) x","decl":"@[to_additive]\ntheorem mem_sSup_of_mem {S : Set (Subsemigroup M)} {s : Subsemigroup M} (hs : s ∈ S) :\n    ∀ {x : M}, x ∈ s → x ∈ sSup S := by\n  have : s ≤ sSup S := le_sSup hs\n  tauto\n\n"}
{"name":"Subsemigroup.iSup_induction","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : Mul M\nS : ι → Subsemigroup M\nC : M → Prop\nx₁ : M\nhx₁ : Membership.mem (iSup fun i => S i) x₁\nmem : ∀ (i : ι) (x₂ : M), Membership.mem (S i) x₂ → C x₂\nmul : ∀ (x y : M), C x → C y → C (HMul.hMul x y)\n⊢ C x₁","decl":"/-- An induction principle for elements of `⨆ i, S i`.\nIf `C` holds all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. -/\n@[to_additive (attr := elab_as_elim)\n\"An induction principle for elements of `⨆ i, S i`. If `C` holds all\nelements of `S i` for all `i`, and is preserved under addition, then it holds for all elements of\nthe supremum of `S`.\"]\ntheorem iSup_induction (S : ι → Subsemigroup M) {C : M → Prop} {x₁ : M} (hx₁ : x₁ ∈ ⨆ i, S i)\n    (mem : ∀ i, ∀ x₂ ∈ S i, C x₂) (mul : ∀ x y, C x → C y → C (x * y)) : C x₁ := by\n  rw [iSup_eq_closure] at hx₁\n  refine closure_induction (fun x₂ hx₂ => ?_) (fun x y _ _ ↦ mul x y) hx₁\n  obtain ⟨i, hi⟩ := Set.mem_iUnion.mp hx₂\n  exact mem _ _ hi\n\n"}
{"name":"AddSubsemigroup.iSup_induction","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : Add M\nS : ι → AddSubsemigroup M\nC : M → Prop\nx₁ : M\nhx₁ : Membership.mem (iSup fun i => S i) x₁\nmem : ∀ (i : ι) (x₂ : M), Membership.mem (S i) x₂ → C x₂\nmul : ∀ (x y : M), C x → C y → C (HAdd.hAdd x y)\n⊢ C x₁","decl":"/-- An induction principle for elements of `⨆ i, S i`.\nIf `C` holds all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. -/\n@[to_additive (attr := elab_as_elim)\n\"An induction principle for elements of `⨆ i, S i`. If `C` holds all\nelements of `S i` for all `i`, and is preserved under addition, then it holds for all elements of\nthe supremum of `S`.\"]\ntheorem iSup_induction (S : ι → Subsemigroup M) {C : M → Prop} {x₁ : M} (hx₁ : x₁ ∈ ⨆ i, S i)\n    (mem : ∀ i, ∀ x₂ ∈ S i, C x₂) (mul : ∀ x y, C x → C y → C (x * y)) : C x₁ := by\n  rw [iSup_eq_closure] at hx₁\n  refine closure_induction (fun x₂ hx₂ => ?_) (fun x y _ _ ↦ mul x y) hx₁\n  obtain ⟨i, hi⟩ := Set.mem_iUnion.mp hx₂\n  exact mem _ _ hi\n\n"}
{"name":"AddSubsemigroup.iSup_induction'","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : Add M\nS : ι → AddSubsemigroup M\nC : (x : M) → Membership.mem (iSup fun i => S i) x → Prop\nmem : ∀ (i : ι) (x : M) (hxS : Membership.mem (S i) x), C x ⋯\nmul : ∀ (x y : M) (hx : Membership.mem (iSup fun i => S i) x) (hy : Membership.mem (iSup fun i => S i) y), C x hx → C y hy → C (HAdd.hAdd x y) ⋯\nx₁ : M\nhx₁ : Membership.mem (iSup fun i => S i) x₁\n⊢ C x₁ hx₁","decl":"/-- A dependent version of `Subsemigroup.iSup_induction`. -/\n@[to_additive (attr := elab_as_elim)\n\"A dependent version of `AddSubsemigroup.iSup_induction`.\"]\ntheorem iSup_induction' (S : ι → Subsemigroup M) {C : ∀ x, (x ∈ ⨆ i, S i) → Prop}\n    (mem : ∀ (i) (x) (hxS : x ∈ S i), C x (mem_iSup_of_mem i ‹_›))\n    (mul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x₁ : M}\n    (hx₁ : x₁ ∈ ⨆ i, S i) : C x₁ hx₁ := by\n  refine Exists.elim ?_ fun (hx₁' : x₁ ∈ ⨆ i, S i) (hc : C x₁ hx₁') => hc\n  refine @iSup_induction _ _ _ S (fun x' => ∃ hx'', C x' hx'') _ hx₁\n      (fun i x₂ hx₂ => ?_) fun x₃ y => ?_\n  · exact ⟨_, mem _ _ hx₂⟩\n  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩\n    exact ⟨_, mul _ _ _ _ Cx Cy⟩\n\n"}
{"name":"Subsemigroup.iSup_induction'","module":"Mathlib.Algebra.Group.Subsemigroup.Membership","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : Mul M\nS : ι → Subsemigroup M\nC : (x : M) → Membership.mem (iSup fun i => S i) x → Prop\nmem : ∀ (i : ι) (x : M) (hxS : Membership.mem (S i) x), C x ⋯\nmul : ∀ (x y : M) (hx : Membership.mem (iSup fun i => S i) x) (hy : Membership.mem (iSup fun i => S i) y), C x hx → C y hy → C (HMul.hMul x y) ⋯\nx₁ : M\nhx₁ : Membership.mem (iSup fun i => S i) x₁\n⊢ C x₁ hx₁","decl":"/-- A dependent version of `Subsemigroup.iSup_induction`. -/\n@[to_additive (attr := elab_as_elim)\n\"A dependent version of `AddSubsemigroup.iSup_induction`.\"]\ntheorem iSup_induction' (S : ι → Subsemigroup M) {C : ∀ x, (x ∈ ⨆ i, S i) → Prop}\n    (mem : ∀ (i) (x) (hxS : x ∈ S i), C x (mem_iSup_of_mem i ‹_›))\n    (mul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x₁ : M}\n    (hx₁ : x₁ ∈ ⨆ i, S i) : C x₁ hx₁ := by\n  refine Exists.elim ?_ fun (hx₁' : x₁ ∈ ⨆ i, S i) (hc : C x₁ hx₁') => hc\n  refine @iSup_induction _ _ _ S (fun x' => ∃ hx'', C x' hx'') _ hx₁\n      (fun i x₂ hx₂ => ?_) fun x₃ y => ?_\n  · exact ⟨_, mem _ _ hx₂⟩\n  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩\n    exact ⟨_, mul _ _ _ _ Cx Cy⟩\n\n"}
