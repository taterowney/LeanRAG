{"name":"separatedNhds_iff_disjoint","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns t : Set X\n‚ä¢ Iff (SeparatedNhds s t) (Disjoint (nhdsSet s) (nhdsSet t))","decl":"theorem separatedNhds_iff_disjoint {s t : Set X} : SeparatedNhds s t ‚Üî Disjoint (ùìùÀ¢ s) (ùìùÀ¢ t) := by\n  simp only [(hasBasis_nhdsSet s).disjoint_iff (hasBasis_nhdsSet t), SeparatedNhds, exists_prop, ‚Üê\n    exists_and_left, and_assoc, and_comm, and_left_comm]\n\n"}
{"name":"SeparatedNhds.disjoint_nhdsSet","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns t : Set X\na‚úù : SeparatedNhds s t\n‚ä¢ Disjoint (nhdsSet s) (nhdsSet t)","decl":"alias ‚ü®SeparatedNhds.disjoint_nhdsSet, _‚ü© := separatedNhds_iff_disjoint\n\n"}
{"name":"hasSeparatingCovers_iff_separatedNhds","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns t : Set X\n‚ä¢ Iff (And (HasSeparatingCover s t) (HasSeparatingCover t s)) (SeparatedNhds s t)","decl":"/-- Used to prove that a regular topological space with Lindel√∂f topology is a normal space,\nand a perfectly normal space is a completely normal space. -/\ntheorem hasSeparatingCovers_iff_separatedNhds {s t : Set X} :\n    HasSeparatingCover s t ‚àß HasSeparatingCover t s ‚Üî SeparatedNhds s t := by\n  constructor\n  ¬∑ rintro ‚ü®‚ü®u, u_cov, u_props‚ü©, ‚ü®v, v_cov, v_props‚ü©‚ü©\n    have open_lemma : ‚àÄ (u‚ÇÄ a : ‚Ñï ‚Üí Set X), (‚àÄ n, IsOpen (u‚ÇÄ n)) ‚Üí\n      IsOpen (‚ãÉ n, u‚ÇÄ n \\ closure (a n)) := fun _ _ u‚ÇÄi_open ‚Ü¶\n        isOpen_iUnion fun i ‚Ü¶ (u‚ÇÄi_open i).sdiff isClosed_closure\n    have cover_lemma : ‚àÄ (h‚ÇÄ : Set X) (u‚ÇÄ v‚ÇÄ : ‚Ñï ‚Üí Set X),\n        (h‚ÇÄ ‚äÜ ‚ãÉ n, u‚ÇÄ n) ‚Üí (‚àÄ n, Disjoint (closure (v‚ÇÄ n)) h‚ÇÄ) ‚Üí\n        (h‚ÇÄ ‚äÜ ‚ãÉ n, u‚ÇÄ n \\ closure (‚ãÉ m ‚â§ n, v‚ÇÄ m)) :=\n        fun h‚ÇÄ u‚ÇÄ v‚ÇÄ h‚ÇÄ_cov dis x xinh ‚Ü¶ by\n      rcases h‚ÇÄ_cov xinh with ‚ü®un , ‚ü®n, rfl‚ü© , xinun‚ü©\n      simp only [mem_iUnion]\n      refine ‚ü®n, xinun, ?_‚ü©\n      simp_all only [closure_iUnion‚ÇÇ_le_nat, disjoint_right, mem_setOf_eq, mem_iUnion,\n        exists_false, exists_const, not_false_eq_true]\n    refine\n      ‚ü®‚ãÉ n : ‚Ñï, u n \\ (closure (‚ãÉ m ‚â§ n, v m)),\n       ‚ãÉ n : ‚Ñï, v n \\ (closure (‚ãÉ m ‚â§ n, u m)),\n       open_lemma u (fun n ‚Ü¶ ‚ãÉ m ‚â§ n, v m) (fun n ‚Ü¶ (u_props n).1),\n       open_lemma v (fun n ‚Ü¶ ‚ãÉ m ‚â§ n, u m) (fun n ‚Ü¶ (v_props n).1),\n       cover_lemma s u v u_cov (fun n ‚Ü¶ (v_props n).2),\n       cover_lemma t v u v_cov (fun n ‚Ü¶ (u_props n).2),\n       ?_‚ü©\n    rw [Set.disjoint_left]\n    rintro x ‚ü®un, ‚ü®n, rfl‚ü©, xinun‚ü©\n    suffices ‚àÄ (m : ‚Ñï), x ‚àà v m ‚Üí x ‚àà closure (‚ãÉ m' ‚àà {m' | m' ‚â§ m}, u m') by simpa\n    intro m xinvm\n    have n_le_m : n ‚â§ m := by\n      by_contra m_gt_n\n      exact xinun.2 (subset_closure (mem_biUnion (le_of_lt (not_le.mp m_gt_n)) xinvm))\n    exact subset_closure (mem_biUnion n_le_m xinun.1)\n  ¬∑ rintro ‚ü®U, V, U_open, V_open, h_sub_U, k_sub_V, UV_dis‚ü©\n    exact\n      ‚ü®‚ü®fun _ ‚Ü¶ U,\n        h_sub_U.trans (iUnion_const U).symm.subset,\n        fun _ ‚Ü¶\n          ‚ü®U_open, disjoint_of_subset (fun ‚¶Éa‚¶Ñ a ‚Ü¶ a) k_sub_V (UV_dis.closure_left V_open)‚ü©‚ü©,\n       ‚ü®fun _ ‚Ü¶ V,\n        k_sub_V.trans (iUnion_const V).symm.subset,\n        fun _ ‚Ü¶\n          ‚ü®V_open, disjoint_of_subset (fun ‚¶Éa‚¶Ñ a ‚Ü¶ a) h_sub_U (UV_dis.closure_right U_open).symm‚ü©‚ü©‚ü©\n\n"}
{"name":"Set.hasSeparatingCover_empty_left","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ HasSeparatingCover EmptyCollection.emptyCollection s","decl":"theorem Set.hasSeparatingCover_empty_left (s : Set X) : HasSeparatingCover ‚àÖ s :=\n  ‚ü®fun _ ‚Ü¶ ‚àÖ, empty_subset (‚ãÉ _, ‚àÖ),\n   fun _ ‚Ü¶ ‚ü®isOpen_empty, by simp only [closure_empty, empty_disjoint]‚ü©‚ü©\n\n"}
{"name":"Set.hasSeparatingCover_empty_right","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ HasSeparatingCover s EmptyCollection.emptyCollection","decl":"theorem Set.hasSeparatingCover_empty_right (s : Set X) : HasSeparatingCover s ‚àÖ :=\n  ‚ü®fun _ ‚Ü¶ univ, (subset_univ s).trans univ.iUnion_const.symm.subset,\n   fun _ ‚Ü¶ ‚ü®isOpen_univ, by apply disjoint_empty‚ü©‚ü©\n\n"}
{"name":"HasSeparatingCover.mono","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns‚ÇÅ s‚ÇÇ t‚ÇÅ t‚ÇÇ : Set X\nsc_st : HasSeparatingCover s‚ÇÇ t‚ÇÇ\ns_sub : HasSubset.Subset s‚ÇÅ s‚ÇÇ\nt_sub : HasSubset.Subset t‚ÇÅ t‚ÇÇ\n‚ä¢ HasSeparatingCover s‚ÇÅ t‚ÇÅ","decl":"theorem HasSeparatingCover.mono {s‚ÇÅ s‚ÇÇ t‚ÇÅ t‚ÇÇ : Set X} (sc_st : HasSeparatingCover s‚ÇÇ t‚ÇÇ)\n    (s_sub : s‚ÇÅ ‚äÜ s‚ÇÇ) (t_sub : t‚ÇÅ ‚äÜ t‚ÇÇ) : HasSeparatingCover s‚ÇÅ t‚ÇÅ := by\n  obtain ‚ü®u, u_cov, u_props‚ü© := sc_st\n  exact\n    ‚ü®u,\n     s_sub.trans u_cov,\n     fun n ‚Ü¶\n       ‚ü®(u_props n).1,\n        disjoint_of_subset (fun ‚¶É_‚¶Ñ a ‚Ü¶ a) t_sub (u_props n).2‚ü©‚ü©\n\n"}
{"name":"SeparatedNhds.symm","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns t : Set X\na‚úù : SeparatedNhds s t\n‚ä¢ SeparatedNhds t s","decl":"@[symm]\ntheorem symm : SeparatedNhds s t ‚Üí SeparatedNhds t s := fun ‚ü®U, V, oU, oV, aU, bV, UV‚ü© =>\n  ‚ü®V, U, oV, oU, bV, aU, Disjoint.symm UV‚ü©\n\n"}
{"name":"SeparatedNhds.comm","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns t : Set X\n‚ä¢ Iff (SeparatedNhds s t) (SeparatedNhds t s)","decl":"theorem comm (s t : Set X) : SeparatedNhds s t ‚Üî SeparatedNhds t s :=\n  ‚ü®symm, symm‚ü©\n\n"}
{"name":"SeparatedNhds.preimage","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ns t : Set Y\nh : SeparatedNhds s t\nhf : Continuous f\n‚ä¢ SeparatedNhds (Set.preimage f s) (Set.preimage f t)","decl":"theorem preimage [TopologicalSpace Y] {f : X ‚Üí Y} {s t : Set Y} (h : SeparatedNhds s t)\n    (hf : Continuous f) : SeparatedNhds (f ‚Åª¬π' s) (f ‚Åª¬π' t) :=\n  let ‚ü®U, V, oU, oV, sU, tV, UV‚ü© := h\n  ‚ü®f ‚Åª¬π' U, f ‚Åª¬π' V, oU.preimage hf, oV.preimage hf, preimage_mono sU, preimage_mono tV,\n    UV.preimage f‚ü©\n\n"}
{"name":"SeparatedNhds.disjoint","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns t : Set X\nh : SeparatedNhds s t\n‚ä¢ Disjoint s t","decl":"protected theorem disjoint (h : SeparatedNhds s t) : Disjoint s t :=\n  let ‚ü®_, _, _, _, hsU, htV, hd‚ü© := h; hd.mono hsU htV\n\n"}
{"name":"SeparatedNhds.disjoint_closure_left","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns t : Set X\nh : SeparatedNhds s t\n‚ä¢ Disjoint (closure s) t","decl":"theorem disjoint_closure_left (h : SeparatedNhds s t) : Disjoint (closure s) t :=\n  let ‚ü®_U, _V, _, hV, hsU, htV, hd‚ü© := h\n  (hd.closure_left hV).mono (closure_mono hsU) htV\n\n"}
{"name":"SeparatedNhds.disjoint_closure_right","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns t : Set X\nh : SeparatedNhds s t\n‚ä¢ Disjoint s (closure t)","decl":"theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t) :=\n  h.symm.disjoint_closure_left.symm\n\n"}
{"name":"SeparatedNhds.empty_right","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ SeparatedNhds s EmptyCollection.emptyCollection","decl":"@[simp] theorem empty_right (s : Set X) : SeparatedNhds s ‚àÖ :=\n  ‚ü®_, _, isOpen_univ, isOpen_empty, fun a _ => mem_univ a, Subset.rfl, disjoint_empty _‚ü©\n\n"}
{"name":"SeparatedNhds.empty_left","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ SeparatedNhds EmptyCollection.emptyCollection s","decl":"@[simp] theorem empty_left (s : Set X) : SeparatedNhds ‚àÖ s :=\n  (empty_right _).symm\n\n"}
{"name":"SeparatedNhds.mono","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns‚ÇÅ s‚ÇÇ t‚ÇÅ t‚ÇÇ : Set X\nh : SeparatedNhds s‚ÇÇ t‚ÇÇ\nhs : HasSubset.Subset s‚ÇÅ s‚ÇÇ\nht : HasSubset.Subset t‚ÇÅ t‚ÇÇ\n‚ä¢ SeparatedNhds s‚ÇÅ t‚ÇÅ","decl":"theorem mono (h : SeparatedNhds s‚ÇÇ t‚ÇÇ) (hs : s‚ÇÅ ‚äÜ s‚ÇÇ) (ht : t‚ÇÅ ‚äÜ t‚ÇÇ) : SeparatedNhds s‚ÇÅ t‚ÇÅ :=\n  let ‚ü®U, V, hU, hV, hsU, htV, hd‚ü© := h\n  ‚ü®U, V, hU, hV, hs.trans hsU, ht.trans htV, hd‚ü©\n\n"}
{"name":"SeparatedNhds.union_left","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns t u : Set X\na‚úù¬π : SeparatedNhds s u\na‚úù : SeparatedNhds t u\n‚ä¢ SeparatedNhds (Union.union s t) u","decl":"theorem union_left : SeparatedNhds s u ‚Üí SeparatedNhds t u ‚Üí SeparatedNhds (s ‚à™ t) u := by\n  simpa only [separatedNhds_iff_disjoint, nhdsSet_union, disjoint_sup_left] using And.intro\n\n"}
{"name":"SeparatedNhds.union_right","module":"Mathlib.Topology.Separation.SeparatedNhds","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns t u : Set X\nht : SeparatedNhds s t\nhu : SeparatedNhds s u\n‚ä¢ SeparatedNhds s (Union.union t u)","decl":"theorem union_right (ht : SeparatedNhds s t) (hu : SeparatedNhds s u) : SeparatedNhds s (t ‚à™ u) :=\n  (ht.symm.union_left hu.symm).symm\n\n"}
