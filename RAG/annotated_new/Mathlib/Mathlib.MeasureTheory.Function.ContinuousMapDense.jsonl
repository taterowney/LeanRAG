{"name":"MeasureTheory.exists_continuous_eLpNorm_sub_le_of_closed","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å∂ : TopologicalSpace Œ±\ninst‚úù‚Åµ : NormalSpace Œ±\ninst‚úù‚Å¥ : MeasurableSpace Œ±\ninst‚úù¬≥ : BorelSpace Œ±\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : Œº.OuterRegular\nhp : Ne p Top.top\ns u : Set Œ±\ns_closed : IsClosed s\nu_open : IsOpen u\nhsu : HasSubset.Subset s u\nhs : Ne (Œº s) Top.top\nc : E\nŒµ : ENNReal\nhŒµ : Ne Œµ 0\n‚ä¢ Exists fun f => And (Continuous f) (And (LE.le (MeasureTheory.eLpNorm (fun x => HSub.hSub (f x) (s.indicator (fun _y => c) x)) p Œº) Œµ) (And (‚àÄ (x : Œ±), LE.le (Norm.norm (f x)) (Norm.norm c)) (And (HasSubset.Subset (Function.support f) u) (MeasureTheory.Mem‚Ñíp f p Œº))))","decl":"/-- A variant of Urysohn's lemma, `‚Ñí^p` version, for an outer regular measure `Œº`:\nconsider two sets `s ‚äÜ u` which are respectively closed and open with `Œº s < ‚àû`, and a vector `c`.\nThen one may find a continuous function `f` equal to `c` on `s` and to `0` outside of `u`,\nbounded by `‚Äñc‚Äñ` everywhere, and such that the `‚Ñí^p` norm of `f - s.indicator (fun y ‚Ü¶ c)` is\narbitrarily small. Additionally, this function `f` belongs to `‚Ñí^p`. -/\ntheorem exists_continuous_eLpNorm_sub_le_of_closed [Œº.OuterRegular] (hp : p ‚â† ‚àû) {s u : Set Œ±}\n    (s_closed : IsClosed s) (u_open : IsOpen u) (hsu : s ‚äÜ u) (hs : Œº s ‚â† ‚àû) (c : E) {Œµ : ‚Ñù‚â•0‚àû}\n    (hŒµ : Œµ ‚â† 0) :\n    ‚àÉ f : Œ± ‚Üí E,\n      Continuous f ‚àß\n        eLpNorm (fun x => f x - s.indicator (fun _y => c) x) p Œº ‚â§ Œµ ‚àß\n          (‚àÄ x, ‚Äñf x‚Äñ ‚â§ ‚Äñc‚Äñ) ‚àß Function.support f ‚äÜ u ‚àß Mem‚Ñíp f p Œº := by\n  obtain ‚ü®Œ∑, Œ∑_pos, hŒ∑‚ü© :\n      ‚àÉ Œ∑ : ‚Ñù‚â•0, 0 < Œ∑ ‚àß ‚àÄ s : Set Œ±, Œº s ‚â§ Œ∑ ‚Üí eLpNorm (s.indicator fun _x => c) p Œº ‚â§ Œµ :=\n    exists_eLpNorm_indicator_le hp c hŒµ\n  have Œ∑pos : (0 : ‚Ñù‚â•0‚àû) < Œ∑ := ENNReal.coe_lt_coe.2 Œ∑_pos\n  obtain ‚ü®V, sV, V_open, h'V, hV‚ü© : ‚àÉ (V : Set Œ±), V ‚äá s ‚àß IsOpen V ‚àß Œº V < ‚àû ‚àß Œº (V \\ s) < Œ∑ :=\n    s_closed.measurableSet.exists_isOpen_diff_lt hs Œ∑pos.ne'\n  let v := u ‚à© V\n  have hsv : s ‚äÜ v := subset_inter hsu sV\n  have hŒºv : Œº v < ‚àû := (measure_mono inter_subset_right).trans_lt h'V\n  obtain ‚ü®g, hgv, hgs, hg_range‚ü© :=\n    exists_continuous_zero_one_of_isClosed (u_open.inter V_open).isClosed_compl s_closed\n      (disjoint_compl_left_iff.2 hsv)\n  -- Multiply this by `c` to get a continuous approximation to the function `f`; the key point is\n  -- that this is pointwise bounded by the indicator of the set `v \\ s`, which has small measure.\n  have g_norm : ‚àÄ x, ‚Äñg x‚Äñ = g x := fun x => by rw [Real.norm_eq_abs, abs_of_nonneg (hg_range x).1]\n  have gc_bd0 : ‚àÄ x, ‚Äñg x ‚Ä¢ c‚Äñ ‚â§ ‚Äñc‚Äñ := by\n    intro x\n    simp only [norm_smul, g_norm x]\n    apply mul_le_of_le_one_left (norm_nonneg _)\n    exact (hg_range x).2\n  have gc_bd :\n      ‚àÄ x, ‚Äñg x ‚Ä¢ c - s.indicator (fun _x => c) x‚Äñ ‚â§ ‚Äñ(v \\ s).indicator (fun _x => c) x‚Äñ := by\n    intro x\n    by_cases hv : x ‚àà v\n    ¬∑ rw [‚Üê Set.diff_union_of_subset hsv] at hv\n      cases' hv with hsv hs\n      ¬∑ simpa only [hsv.2, Set.indicator_of_not_mem, not_false_iff, sub_zero, hsv,\n          Set.indicator_of_mem] using gc_bd0 x\n      ¬∑ simp [hgs hs, hs]\n    ¬∑ simp [hgv hv, show x ‚àâ s from fun h => hv (hsv h)]\n  have gc_support : (Function.support fun x : Œ± => g x ‚Ä¢ c) ‚äÜ v := by\n    refine Function.support_subset_iff'.2 fun x hx => ?_\n    simp only [hgv hx, Pi.zero_apply, zero_smul]\n  have gc_mem : Mem‚Ñíp (fun x => g x ‚Ä¢ c) p Œº := by\n    refine Mem‚Ñíp.smul_of_top_left (mem‚Ñíp_top_const _) ?_\n    refine ‚ü®g.continuous.aestronglyMeasurable, ?_‚ü©\n    have : eLpNorm (v.indicator fun _x => (1 : ‚Ñù)) p Œº < ‚ä§ :=\n      (eLpNorm_indicator_const_le _ _).trans_lt <| by simp [lt_top_iff_ne_top, hŒºv.ne]\n    refine (eLpNorm_mono fun x => ?_).trans_lt this\n    by_cases hx : x ‚àà v\n    ¬∑ simp only [hx, abs_of_nonneg (hg_range x).1, (hg_range x).2, Real.norm_eq_abs,\n        indicator_of_mem, CStarRing.norm_one]\n    ¬∑ simp only [hgv hx, Pi.zero_apply, Real.norm_eq_abs, abs_zero, abs_nonneg]\n  refine\n    ‚ü®fun x => g x ‚Ä¢ c, g.continuous.smul continuous_const, (eLpNorm_mono gc_bd).trans ?_, gc_bd0,\n      gc_support.trans inter_subset_left, gc_mem‚ü©\n  exact hŒ∑ _ ((measure_mono (diff_subset_diff inter_subset_right Subset.rfl)).trans hV.le)\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.exists_hasCompactSupport_eLpNorm_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å∏ : TopologicalSpace Œ±\ninst‚úù‚Å∑ : NormalSpace Œ±\ninst‚úù‚Å∂ : MeasurableSpace Œ±\ninst‚úù‚Åµ : BorelSpace Œ±\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : R1Space Œ±\ninst‚úù¬π : WeaklyLocallyCompactSpace Œ±\ninst‚úù : Œº.Regular\nhp : Ne p Top.top\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nŒµ : ENNReal\nhŒµ : Ne Œµ 0\n‚ä¢ Exists fun g => And (HasCompactSupport g) (And (LE.le (MeasureTheory.eLpNorm (HSub.hSub f g) p Œº) Œµ) (And (Continuous g) (MeasureTheory.Mem‚Ñíp g p Œº)))","decl":"/-- In a locally compact space, any function in `‚Ñíp` can be approximated by compactly supported\ncontinuous functions when `p < ‚àû`, version in terms of `eLpNorm`. -/\ntheorem Mem‚Ñíp.exists_hasCompactSupport_eLpNorm_sub_le\n    [R1Space Œ±] [WeaklyLocallyCompactSpace Œ±] [Œº.Regular]\n    (hp : p ‚â† ‚àû) {f : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) :\n    ‚àÉ g : Œ± ‚Üí E, HasCompactSupport g ‚àß eLpNorm (f - g) p Œº ‚â§ Œµ ‚àß Continuous g ‚àß Mem‚Ñíp g p Œº := by\n  suffices H :\n      ‚àÉ g : Œ± ‚Üí E, eLpNorm (f - g) p Œº ‚â§ Œµ ‚àß Continuous g ‚àß Mem‚Ñíp g p Œº ‚àß HasCompactSupport g by\n    rcases H with ‚ü®g, hg, g_cont, g_mem, g_support‚ü©\n    exact ‚ü®g, g_support, hg, g_cont, g_mem‚ü©\n  -- It suffices to check that the set of functions we consider approximates characteristic\n  -- functions, is stable under addition and consists of ae strongly measurable functions.\n  -- First check the latter easy facts.\n  apply hf.induction_dense hp _ _ _ _ hŒµ\n  rotate_left\n  -- stability under addition\n  ¬∑ rintro f g ‚ü®f_cont, f_mem, hf‚ü© ‚ü®g_cont, g_mem, hg‚ü©\n    exact ‚ü®f_cont.add g_cont, f_mem.add g_mem, hf.add hg‚ü©\n  -- ae strong measurability\n  ¬∑ rintro f ‚ü®_f_cont, f_mem, _hf‚ü©\n    exact f_mem.aestronglyMeasurable\n  -- We are left with approximating characteristic functions.\n  -- This follows from `exists_continuous_eLpNorm_sub_le_of_closed`.\n  intro c t ht htŒº Œµ hŒµ\n  rcases exists_Lp_half E Œº p hŒµ with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©\n  obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© :\n      ‚àÉ Œ∑ : ‚Ñù‚â•0, 0 < Œ∑ ‚àß ‚àÄ s : Set Œ±, Œº s ‚â§ Œ∑ ‚Üí eLpNorm (s.indicator fun _x => c) p Œº ‚â§ Œ¥ :=\n    exists_eLpNorm_indicator_le hp c Œ¥pos.ne'\n  have hŒ∑_pos' : (0 : ‚Ñù‚â•0‚àû) < Œ∑ := ENNReal.coe_pos.2 Œ∑pos\n  obtain ‚ü®s, st, s_compact, s_closed, Œºs‚ü© :\n      ‚àÉ s, s ‚äÜ t ‚àß IsCompact s ‚àß IsClosed s ‚àß Œº (t \\ s) < Œ∑ :=\n    ht.exists_isCompact_isClosed_diff_lt htŒº.ne hŒ∑_pos'.ne'\n  have hsŒº : Œº s < ‚àû := (measure_mono st).trans_lt htŒº\n  have I1 : eLpNorm ((s.indicator fun _y => c) - t.indicator fun _y => c) p Œº ‚â§ Œ¥ := by\n    rw [‚Üê eLpNorm_neg, neg_sub, ‚Üê indicator_diff st]\n    exact hŒ∑ _ Œºs.le\n  obtain ‚ü®k, k_compact, sk‚ü© : ‚àÉ k : Set Œ±, IsCompact k ‚àß s ‚äÜ interior k :=\n    exists_compact_superset s_compact\n  rcases exists_continuous_eLpNorm_sub_le_of_closed hp s_closed isOpen_interior sk hsŒº.ne c Œ¥pos.ne'\n    with ‚ü®f, f_cont, I2, _f_bound, f_support, f_mem‚ü©\n  have I3 : eLpNorm (f - t.indicator fun _y => c) p Œº ‚â§ Œµ := by\n    convert\n      (hŒ¥ _ _\n          (f_mem.aestronglyMeasurable.sub\n            (aestronglyMeasurable_const.indicator s_closed.measurableSet))\n          ((aestronglyMeasurable_const.indicator s_closed.measurableSet).sub\n            (aestronglyMeasurable_const.indicator ht))\n          I2 I1).le using 2\n    simp only [sub_add_sub_cancel]\n  refine ‚ü®f, I3, f_cont, f_mem, HasCompactSupport.intro k_compact fun x hx => ?_‚ü©\n  rw [‚Üê Function.nmem_support]\n  contrapose! hx\n  exact interior_subset (f_support hx)\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.exists_hasCompactSupport_integral_rpow_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å∏ : TopologicalSpace Œ±\ninst‚úù‚Å∑ : NormalSpace Œ±\ninst‚úù‚Å∂ : MeasurableSpace Œ±\ninst‚úù‚Åµ : BorelSpace Œ±\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : R1Space Œ±\ninst‚úù¬π : WeaklyLocallyCompactSpace Œ±\ninst‚úù : Œº.Regular\np : Real\nhp : LT.lt 0 p\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f (ENNReal.ofReal p) Œº\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun g => And (HasCompactSupport g) (And (LE.le (MeasureTheory.integral Œº fun x => HPow.hPow (Norm.norm (HSub.hSub (f x) (g x))) p) Œµ) (And (Continuous g) (MeasureTheory.Mem‚Ñíp g (ENNReal.ofReal p) Œº)))","decl":"/-- In a locally compact space, any function in `‚Ñíp` can be approximated by compactly supported\ncontinuous functions when `0 < p < ‚àû`, version in terms of `‚à´`. -/\ntheorem Mem‚Ñíp.exists_hasCompactSupport_integral_rpow_sub_le\n    [R1Space Œ±] [WeaklyLocallyCompactSpace Œ±] [Œº.Regular]\n    {p : ‚Ñù} (hp : 0 < p) {f : Œ± ‚Üí E} (hf : Mem‚Ñíp f (ENNReal.ofReal p) Œº) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ g : Œ± ‚Üí E,\n      HasCompactSupport g ‚àß\n        (‚à´ x, ‚Äñf x - g x‚Äñ ^ p ‚àÇŒº) ‚â§ Œµ ‚àß Continuous g ‚àß Mem‚Ñíp g (ENNReal.ofReal p) Œº := by\n  have I : 0 < Œµ ^ (1 / p) := Real.rpow_pos_of_pos hŒµ _\n  have A : ENNReal.ofReal (Œµ ^ (1 / p)) ‚â† 0 := by\n    simp only [Ne, ENNReal.ofReal_eq_zero, not_le, I]\n  have B : ENNReal.ofReal p ‚â† 0 := by simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hp\n  rcases hf.exists_hasCompactSupport_eLpNorm_sub_le ENNReal.coe_ne_top A with\n    ‚ü®g, g_support, hg, g_cont, g_mem‚ü©\n  change eLpNorm _ (ENNReal.ofReal p) _ ‚â§ _ at hg\n  refine ‚ü®g, g_support, ?_, g_cont, g_mem‚ü©\n  rwa [(hf.sub g_mem).eLpNorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,\n    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,\n    Real.rpow_le_rpow_iff _ hŒµ.le (inv_pos.2 hp)] at hg\n  positivity\n\n"}
{"name":"MeasureTheory.Integrable.exists_hasCompactSupport_lintegral_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å∏ : TopologicalSpace Œ±\ninst‚úù‚Å∑ : NormalSpace Œ±\ninst‚úù‚Å∂ : MeasurableSpace Œ±\ninst‚úù‚Åµ : BorelSpace Œ±\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : R1Space Œ±\ninst‚úù¬π : WeaklyLocallyCompactSpace Œ±\ninst‚úù : Œº.Regular\nf : Œ± ‚Üí E\nhf : MeasureTheory.Integrable f Œº\nŒµ : ENNReal\nhŒµ : Ne Œµ 0\n‚ä¢ Exists fun g => And (HasCompactSupport g) (And (LE.le (MeasureTheory.lintegral Œº fun x => ENorm.enorm (HSub.hSub (f x) (g x))) Œµ) (And (Continuous g) (MeasureTheory.Integrable g Œº)))","decl":"/-- In a locally compact space, any integrable function can be approximated by compactly supported\ncontinuous functions, version in terms of `‚à´‚Åª`. -/\ntheorem Integrable.exists_hasCompactSupport_lintegral_sub_le\n    [R1Space Œ±] [WeaklyLocallyCompactSpace Œ±] [Œº.Regular]\n    {f : Œ± ‚Üí E} (hf : Integrable f Œº) {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) :\n    ‚àÉ g : Œ± ‚Üí E,\n      HasCompactSupport g ‚àß ‚à´‚Åª x, ‚Äñf x - g x‚Äñ‚Çë ‚àÇŒº ‚â§ Œµ ‚àß Continuous g ‚àß Integrable g Œº := by\n  simp only [‚Üê mem‚Ñíp_one_iff_integrable, ‚Üê eLpNorm_one_eq_lintegral_enorm] at hf ‚ä¢\n  exact hf.exists_hasCompactSupport_eLpNorm_sub_le ENNReal.one_ne_top hŒµ\n\n"}
{"name":"MeasureTheory.Integrable.exists_hasCompactSupport_integral_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å∏ : TopologicalSpace Œ±\ninst‚úù‚Å∑ : NormalSpace Œ±\ninst‚úù‚Å∂ : MeasurableSpace Œ±\ninst‚úù‚Åµ : BorelSpace Œ±\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : R1Space Œ±\ninst‚úù¬π : WeaklyLocallyCompactSpace Œ±\ninst‚úù : Œº.Regular\nf : Œ± ‚Üí E\nhf : MeasureTheory.Integrable f Œº\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun g => And (HasCompactSupport g) (And (LE.le (MeasureTheory.integral Œº fun x => Norm.norm (HSub.hSub (f x) (g x))) Œµ) (And (Continuous g) (MeasureTheory.Integrable g Œº)))","decl":"/-- In a locally compact space, any integrable function can be approximated by compactly supported\ncontinuous functions, version in terms of `‚à´`. -/\ntheorem Integrable.exists_hasCompactSupport_integral_sub_le\n    [R1Space Œ±] [WeaklyLocallyCompactSpace Œ±] [Œº.Regular]\n    {f : Œ± ‚Üí E} (hf : Integrable f Œº) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ g : Œ± ‚Üí E, HasCompactSupport g ‚àß (‚à´ x, ‚Äñf x - g x‚Äñ ‚àÇŒº) ‚â§ Œµ ‚àß\n      Continuous g ‚àß Integrable g Œº := by\n  simp only [‚Üê mem‚Ñíp_one_iff_integrable, ‚Üê eLpNorm_one_eq_lintegral_enorm, ‚Üê ENNReal.ofReal_one]\n    at hf ‚ä¢\n  simpa using hf.exists_hasCompactSupport_integral_rpow_sub_le zero_lt_one hŒµ\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.exists_boundedContinuous_eLpNorm_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å∂ : TopologicalSpace Œ±\ninst‚úù‚Åµ : NormalSpace Œ±\ninst‚úù‚Å¥ : MeasurableSpace Œ±\ninst‚úù¬≥ : BorelSpace Œ±\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : Œº.WeaklyRegular\nhp : Ne p Top.top\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nŒµ : ENNReal\nhŒµ : Ne Œµ 0\n‚ä¢ Exists fun g => And (LE.le (MeasureTheory.eLpNorm (HSub.hSub f ‚áëg) p Œº) Œµ) (MeasureTheory.Mem‚Ñíp (‚áëg) p Œº)","decl":"/-- Any function in `‚Ñíp` can be approximated by bounded continuous functions when `p < ‚àû`,\nversion in terms of `eLpNorm`. -/\ntheorem Mem‚Ñíp.exists_boundedContinuous_eLpNorm_sub_le [Œº.WeaklyRegular] (hp : p ‚â† ‚àû) {f : Œ± ‚Üí E}\n    (hf : Mem‚Ñíp f p Œº) {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) :\n    ‚àÉ g : Œ± ‚Üí·µá E, eLpNorm (f - (g : Œ± ‚Üí E)) p Œº ‚â§ Œµ ‚àß Mem‚Ñíp g p Œº := by\n  suffices H :\n      ‚àÉ g : Œ± ‚Üí E, eLpNorm (f - g) p Œº ‚â§ Œµ ‚àß Continuous g ‚àß Mem‚Ñíp g p Œº ‚àß IsBounded (range g) by\n    rcases H with ‚ü®g, hg, g_cont, g_mem, g_bd‚ü©\n    exact ‚ü®‚ü®‚ü®g, g_cont‚ü©, Metric.isBounded_range_iff.1 g_bd‚ü©, hg, g_mem‚ü©\n  -- It suffices to check that the set of functions we consider approximates characteristic\n  -- functions, is stable under addition and made of ae strongly measurable functions.\n  -- First check the latter easy facts.\n  apply hf.induction_dense hp _ _ _ _ hŒµ\n  rotate_left\n  -- stability under addition\n  ¬∑ rintro f g ‚ü®f_cont, f_mem, f_bd‚ü© ‚ü®g_cont, g_mem, g_bd‚ü©\n    refine ‚ü®f_cont.add g_cont, f_mem.add g_mem, ?_‚ü©\n    let f' : Œ± ‚Üí·µá E := ‚ü®‚ü®f, f_cont‚ü©, Metric.isBounded_range_iff.1 f_bd‚ü©\n    let g' : Œ± ‚Üí·µá E := ‚ü®‚ü®g, g_cont‚ü©, Metric.isBounded_range_iff.1 g_bd‚ü©\n    exact (f' + g').isBounded_range\n  -- ae strong measurability\n  ¬∑ exact fun f ‚ü®_, h, _‚ü© => h.aestronglyMeasurable\n  -- We are left with approximating characteristic functions.\n  -- This follows from `exists_continuous_eLpNorm_sub_le_of_closed`.\n  intro c t ht htŒº Œµ hŒµ\n  rcases exists_Lp_half E Œº p hŒµ with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©\n  obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© :\n      ‚àÉ Œ∑ : ‚Ñù‚â•0, 0 < Œ∑ ‚àß ‚àÄ s : Set Œ±, Œº s ‚â§ Œ∑ ‚Üí eLpNorm (s.indicator fun _x => c) p Œº ‚â§ Œ¥ :=\n    exists_eLpNorm_indicator_le hp c Œ¥pos.ne'\n  have hŒ∑_pos' : (0 : ‚Ñù‚â•0‚àû) < Œ∑ := ENNReal.coe_pos.2 Œ∑pos\n  obtain ‚ü®s, st, s_closed, Œºs‚ü© : ‚àÉ s, s ‚äÜ t ‚àß IsClosed s ‚àß Œº (t \\ s) < Œ∑ :=\n    ht.exists_isClosed_diff_lt htŒº.ne hŒ∑_pos'.ne'\n  have hsŒº : Œº s < ‚àû := (measure_mono st).trans_lt htŒº\n  have I1 : eLpNorm ((s.indicator fun _y => c) - t.indicator fun _y => c) p Œº ‚â§ Œ¥ := by\n    rw [‚Üê eLpNorm_neg, neg_sub, ‚Üê indicator_diff st]\n    exact hŒ∑ _ Œºs.le\n  rcases exists_continuous_eLpNorm_sub_le_of_closed hp s_closed isOpen_univ (subset_univ _) hsŒº.ne c\n      Œ¥pos.ne' with\n    ‚ü®f, f_cont, I2, f_bound, -, f_mem‚ü©\n  have I3 : eLpNorm (f - t.indicator fun _y => c) p Œº ‚â§ Œµ := by\n    convert\n      (hŒ¥ _ _\n          (f_mem.aestronglyMeasurable.sub\n            (aestronglyMeasurable_const.indicator s_closed.measurableSet))\n          ((aestronglyMeasurable_const.indicator s_closed.measurableSet).sub\n            (aestronglyMeasurable_const.indicator ht))\n          I2 I1).le using 2\n    simp only [sub_add_sub_cancel]\n  refine ‚ü®f, I3, f_cont, f_mem, ?_‚ü©\n  exact (BoundedContinuousFunction.ofNormedAddCommGroup f f_cont _ f_bound).isBounded_range\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.exists_boundedContinuous_integral_rpow_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å∂ : TopologicalSpace Œ±\ninst‚úù‚Åµ : NormalSpace Œ±\ninst‚úù‚Å¥ : MeasurableSpace Œ±\ninst‚úù¬≥ : BorelSpace Œ±\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : Œº.WeaklyRegular\np : Real\nhp : LT.lt 0 p\nf : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f (ENNReal.ofReal p) Œº\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun g => And (LE.le (MeasureTheory.integral Œº fun x => HPow.hPow (Norm.norm (HSub.hSub (f x) (g x))) p) Œµ) (MeasureTheory.Mem‚Ñíp (‚áëg) (ENNReal.ofReal p) Œº)","decl":"/-- Any function in `‚Ñíp` can be approximated by bounded continuous functions when `0 < p < ‚àû`,\nversion in terms of `‚à´`. -/\ntheorem Mem‚Ñíp.exists_boundedContinuous_integral_rpow_sub_le [Œº.WeaklyRegular] {p : ‚Ñù} (hp : 0 < p)\n    {f : Œ± ‚Üí E} (hf : Mem‚Ñíp f (ENNReal.ofReal p) Œº) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ g : Œ± ‚Üí·µá E, (‚à´ x, ‚Äñf x - g x‚Äñ ^ p ‚àÇŒº) ‚â§ Œµ ‚àß Mem‚Ñíp g (ENNReal.ofReal p) Œº := by\n  have I : 0 < Œµ ^ (1 / p) := Real.rpow_pos_of_pos hŒµ _\n  have A : ENNReal.ofReal (Œµ ^ (1 / p)) ‚â† 0 := by\n    simp only [Ne, ENNReal.ofReal_eq_zero, not_le, I]\n  have B : ENNReal.ofReal p ‚â† 0 := by simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hp\n  rcases hf.exists_boundedContinuous_eLpNorm_sub_le ENNReal.coe_ne_top A with ‚ü®g, hg, g_mem‚ü©\n  change eLpNorm _ (ENNReal.ofReal p) _ ‚â§ _ at hg\n  refine ‚ü®g, ?_, g_mem‚ü©\n  rwa [(hf.sub g_mem).eLpNorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,\n    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,\n    Real.rpow_le_rpow_iff _ hŒµ.le (inv_pos.2 hp)] at hg\n  positivity\n\n"}
{"name":"MeasureTheory.Integrable.exists_boundedContinuous_lintegral_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å∂ : TopologicalSpace Œ±\ninst‚úù‚Åµ : NormalSpace Œ±\ninst‚úù‚Å¥ : MeasurableSpace Œ±\ninst‚úù¬≥ : BorelSpace Œ±\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : Œº.WeaklyRegular\nf : Œ± ‚Üí E\nhf : MeasureTheory.Integrable f Œº\nŒµ : ENNReal\nhŒµ : Ne Œµ 0\n‚ä¢ Exists fun g => And (LE.le (MeasureTheory.lintegral Œº fun x => ENorm.enorm (HSub.hSub (f x) (g x))) Œµ) (MeasureTheory.Integrable (‚áëg) Œº)","decl":"/-- Any integrable function can be approximated by bounded continuous functions,\nversion in terms of `‚à´‚Åª`. -/\ntheorem Integrable.exists_boundedContinuous_lintegral_sub_le [Œº.WeaklyRegular] {f : Œ± ‚Üí E}\n    (hf : Integrable f Œº) {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) :\n    ‚àÉ g : Œ± ‚Üí·µá E, ‚à´‚Åª x, ‚Äñf x - g x‚Äñ‚Çë ‚àÇŒº ‚â§ Œµ ‚àß Integrable g Œº := by\n  simp only [‚Üê mem‚Ñíp_one_iff_integrable, ‚Üê eLpNorm_one_eq_lintegral_enorm] at hf ‚ä¢\n  exact hf.exists_boundedContinuous_eLpNorm_sub_le ENNReal.one_ne_top hŒµ\n\n"}
{"name":"MeasureTheory.Integrable.exists_boundedContinuous_integral_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å∂ : TopologicalSpace Œ±\ninst‚úù‚Åµ : NormalSpace Œ±\ninst‚úù‚Å¥ : MeasurableSpace Œ±\ninst‚úù¬≥ : BorelSpace Œ±\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : Œº.WeaklyRegular\nf : Œ± ‚Üí E\nhf : MeasureTheory.Integrable f Œº\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun g => And (LE.le (MeasureTheory.integral Œº fun x => Norm.norm (HSub.hSub (f x) (g x))) Œµ) (MeasureTheory.Integrable (‚áëg) Œº)","decl":"/-- Any integrable function can be approximated by bounded continuous functions,\nversion in terms of `‚à´`. -/\ntheorem Integrable.exists_boundedContinuous_integral_sub_le [Œº.WeaklyRegular] {f : Œ± ‚Üí E}\n    (hf : Integrable f Œº) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ g : Œ± ‚Üí·µá E, (‚à´ x, ‚Äñf x - g x‚Äñ ‚àÇŒº) ‚â§ Œµ ‚àß Integrable g Œº := by\n  simp only [‚Üê mem‚Ñíp_one_iff_integrable, ‚Üê eLpNorm_one_eq_lintegral_enorm, ‚Üê ENNReal.ofReal_one]\n    at hf ‚ä¢\n  simpa using hf.exists_boundedContinuous_integral_rpow_sub_le zero_lt_one hŒµ\n\n"}
{"name":"MeasureTheory.Lp.boundedContinuousFunction_dense","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å∏ : TopologicalSpace Œ±\ninst‚úù‚Å∑ : NormalSpace Œ±\ninst‚úù‚Å∂ : MeasurableSpace Œ±\ninst‚úù‚Åµ : BorelSpace Œ±\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : SecondCountableTopologyEither Œ± E\ninst‚úù¬π : Fact (LE.le 1 p)\nhp : Ne p Top.top\ninst‚úù : Œº.WeaklyRegular\n‚ä¢ Dense ‚Üë(MeasureTheory.Lp.boundedContinuousFunction E p Œº)","decl":"/-- A function in `Lp` can be approximated in `Lp` by continuous functions. -/\ntheorem boundedContinuousFunction_dense [SecondCountableTopologyEither Œ± E] [Fact (1 ‚â§ p)]\n    (hp : p ‚â† ‚àû) [Œº.WeaklyRegular] :\n    Dense (boundedContinuousFunction E p Œº : Set (Lp E p Œº)) := by\n  intro f\n  refine (mem_closure_iff_nhds_basis EMetric.nhds_basis_closed_eball).2 fun Œµ hŒµ ‚Ü¶ ?_\n  obtain ‚ü®g, hg, g_mem‚ü© :\n      ‚àÉ g : Œ± ‚Üí·µá E, eLpNorm ((f : Œ± ‚Üí E) - (g : Œ± ‚Üí E)) p Œº ‚â§ Œµ ‚àß Mem‚Ñíp g p Œº :=\n    (Lp.mem‚Ñíp f).exists_boundedContinuous_eLpNorm_sub_le hp hŒµ.ne'\n  refine ‚ü®g_mem.toLp _, ‚ü®g, rfl‚ü©, ?_‚ü©\n  rwa [EMetric.mem_closedBall', ‚Üê Lp.toLp_coeFn f (Lp.mem‚Ñíp f), Lp.edist_toLp_toLp]\n\n"}
{"name":"MeasureTheory.Lp.boundedContinuousFunction_topologicalClosure","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å∏ : TopologicalSpace Œ±\ninst‚úù‚Å∑ : NormalSpace Œ±\ninst‚úù‚Å∂ : MeasurableSpace Œ±\ninst‚úù‚Åµ : BorelSpace Œ±\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : SecondCountableTopologyEither Œ± E\ninst‚úù¬π : Fact (LE.le 1 p)\nhp : Ne p Top.top\ninst‚úù : Œº.WeaklyRegular\n‚ä¢ Eq (MeasureTheory.Lp.boundedContinuousFunction E p Œº).topologicalClosure Top.top","decl":"/-- A function in `Lp` can be approximated in `Lp` by continuous functions. -/\ntheorem boundedContinuousFunction_topologicalClosure [SecondCountableTopologyEither Œ± E]\n    [Fact (1 ‚â§ p)] (hp : p ‚â† ‚àû) [Œº.WeaklyRegular] :\n    (boundedContinuousFunction E p Œº).topologicalClosure = ‚ä§ :=\n  SetLike.ext' <| (boundedContinuousFunction_dense E Œº hp).closure_eq\n\n"}
{"name":"BoundedContinuousFunction.toLp_denseRange","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"Œ± : Type u_1\ninst‚úù¬π‚Å∞ : TopologicalSpace Œ±\ninst‚úù‚Åπ : NormalSpace Œ±\ninst‚úù‚Å∏ : MeasurableSpace Œ±\ninst‚úù‚Å∑ : BorelSpace Œ±\nE : Type u_2\ninst‚úù‚Å∂ : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\ninst‚úù‚Åµ : SecondCountableTopologyEither Œ± E\n_i : Fact (LE.le 1 p)\nùïú : Type u_3\ninst‚úù‚Å¥ : NormedField ùïú\ninst‚úù¬≥ : NormedAlgebra Real ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : Œº.WeaklyRegular\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhp : Ne p Top.top\n‚ä¢ DenseRange ‚áë(BoundedContinuousFunction.toLp p Œº ùïú)","decl":"theorem toLp_denseRange [Œº.WeaklyRegular] [IsFiniteMeasure Œº] (hp : p ‚â† ‚àû) :\n    DenseRange (toLp p Œº ùïú : (Œ± ‚Üí·µá E) ‚ÜíL[ùïú] Lp E p Œº) := by\n  haveI : NormedSpace ‚Ñù E := RestrictScalars.normedSpace ‚Ñù ùïú E\n  simpa only [‚Üê range_toLp p Œº (ùïú := ùïú)]\n    using MeasureTheory.Lp.boundedContinuousFunction_dense E Œº hp\n\n"}
{"name":"ContinuousMap.toLp_denseRange","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"Œ± : Type u_1\ninst‚úù¬π¬π : TopologicalSpace Œ±\ninst‚úù¬π‚Å∞ : NormalSpace Œ±\ninst‚úù‚Åπ : MeasurableSpace Œ±\ninst‚úù‚Å∏ : BorelSpace Œ±\nE : Type u_2\ninst‚úù‚Å∑ : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\ninst‚úù‚Å∂ : SecondCountableTopologyEither Œ± E\n_i : Fact (LE.le 1 p)\nùïú : Type u_3\ninst‚úù‚Åµ : NormedField ùïú\ninst‚úù‚Å¥ : NormedAlgebra Real ùïú\ninst‚úù¬≥ : NormedSpace ùïú E\ninst‚úù¬≤ : CompactSpace Œ±\ninst‚úù¬π : Œº.WeaklyRegular\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhp : Ne p Top.top\n‚ä¢ DenseRange ‚áë(ContinuousMap.toLp p Œº ùïú)","decl":"/-- Continuous functions are dense in `MeasureTheory.Lp`, `1 ‚â§ p < ‚àû`. This theorem assumes that\nthe domain is a compact space because otherwise `ContinuousMap.toLp` is undefined. Use\n`BoundedContinuousFunction.toLp_denseRange` if the domain is not a compact space. -/\ntheorem toLp_denseRange [CompactSpace Œ±] [Œº.WeaklyRegular] [IsFiniteMeasure Œº] (hp : p ‚â† ‚àû) :\n    DenseRange (toLp p Œº ùïú : C(Œ±, E) ‚ÜíL[ùïú] Lp E p Œº) := by\n  refine (BoundedContinuousFunction.toLp_denseRange _ _ ùïú hp).mono ?_\n  refine range_subset_iff.2 fun f ‚Ü¶ ?_\n  exact ‚ü®f.toContinuousMap, rfl‚ü©\n\n"}
