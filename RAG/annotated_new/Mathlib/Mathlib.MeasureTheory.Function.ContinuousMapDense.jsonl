{"name":"MeasureTheory.exists_continuous_eLpNorm_sub_le_of_closed","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : NormalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\nE : Type u_2\ninst✝² : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\ninst✝¹ : NormedSpace Real E\ninst✝ : μ.OuterRegular\nhp : Ne p Top.top\ns u : Set α\ns_closed : IsClosed s\nu_open : IsOpen u\nhsu : HasSubset.Subset s u\nhs : Ne (μ s) Top.top\nc : E\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun f => And (Continuous f) (And (LE.le (MeasureTheory.eLpNorm (fun x => HSub.hSub (f x) (s.indicator (fun _y => c) x)) p μ) ε) (And (∀ (x : α), LE.le (Norm.norm (f x)) (Norm.norm c)) (And (HasSubset.Subset (Function.support f) u) (MeasureTheory.Memℒp f p μ))))","decl":"/-- A variant of Urysohn's lemma, `ℒ^p` version, for an outer regular measure `μ`:\nconsider two sets `s ⊆ u` which are respectively closed and open with `μ s < ∞`, and a vector `c`.\nThen one may find a continuous function `f` equal to `c` on `s` and to `0` outside of `u`,\nbounded by `‖c‖` everywhere, and such that the `ℒ^p` norm of `f - s.indicator (fun y ↦ c)` is\narbitrarily small. Additionally, this function `f` belongs to `ℒ^p`. -/\ntheorem exists_continuous_eLpNorm_sub_le_of_closed [μ.OuterRegular] (hp : p ≠ ∞) {s u : Set α}\n    (s_closed : IsClosed s) (u_open : IsOpen u) (hsu : s ⊆ u) (hs : μ s ≠ ∞) (c : E) {ε : ℝ≥0∞}\n    (hε : ε ≠ 0) :\n    ∃ f : α → E,\n      Continuous f ∧\n        eLpNorm (fun x => f x - s.indicator (fun _y => c) x) p μ ≤ ε ∧\n          (∀ x, ‖f x‖ ≤ ‖c‖) ∧ Function.support f ⊆ u ∧ Memℒp f p μ := by\n  obtain ⟨η, η_pos, hη⟩ :\n      ∃ η : ℝ≥0, 0 < η ∧ ∀ s : Set α, μ s ≤ η → eLpNorm (s.indicator fun _x => c) p μ ≤ ε :=\n    exists_eLpNorm_indicator_le hp c hε\n  have ηpos : (0 : ℝ≥0∞) < η := ENNReal.coe_lt_coe.2 η_pos\n  obtain ⟨V, sV, V_open, h'V, hV⟩ : ∃ (V : Set α), V ⊇ s ∧ IsOpen V ∧ μ V < ∞ ∧ μ (V \\ s) < η :=\n    s_closed.measurableSet.exists_isOpen_diff_lt hs ηpos.ne'\n  let v := u ∩ V\n  have hsv : s ⊆ v := subset_inter hsu sV\n  have hμv : μ v < ∞ := (measure_mono inter_subset_right).trans_lt h'V\n  obtain ⟨g, hgv, hgs, hg_range⟩ :=\n    exists_continuous_zero_one_of_isClosed (u_open.inter V_open).isClosed_compl s_closed\n      (disjoint_compl_left_iff.2 hsv)\n  -- Multiply this by `c` to get a continuous approximation to the function `f`; the key point is\n  -- that this is pointwise bounded by the indicator of the set `v \\ s`, which has small measure.\n  have g_norm : ∀ x, ‖g x‖ = g x := fun x => by rw [Real.norm_eq_abs, abs_of_nonneg (hg_range x).1]\n  have gc_bd0 : ∀ x, ‖g x • c‖ ≤ ‖c‖ := by\n    intro x\n    simp only [norm_smul, g_norm x]\n    apply mul_le_of_le_one_left (norm_nonneg _)\n    exact (hg_range x).2\n  have gc_bd :\n      ∀ x, ‖g x • c - s.indicator (fun _x => c) x‖ ≤ ‖(v \\ s).indicator (fun _x => c) x‖ := by\n    intro x\n    by_cases hv : x ∈ v\n    · rw [← Set.diff_union_of_subset hsv] at hv\n      cases' hv with hsv hs\n      · simpa only [hsv.2, Set.indicator_of_not_mem, not_false_iff, sub_zero, hsv,\n          Set.indicator_of_mem] using gc_bd0 x\n      · simp [hgs hs, hs]\n    · simp [hgv hv, show x ∉ s from fun h => hv (hsv h)]\n  have gc_support : (Function.support fun x : α => g x • c) ⊆ v := by\n    refine Function.support_subset_iff'.2 fun x hx => ?_\n    simp only [hgv hx, Pi.zero_apply, zero_smul]\n  have gc_mem : Memℒp (fun x => g x • c) p μ := by\n    refine Memℒp.smul_of_top_left (memℒp_top_const _) ?_\n    refine ⟨g.continuous.aestronglyMeasurable, ?_⟩\n    have : eLpNorm (v.indicator fun _x => (1 : ℝ)) p μ < ⊤ :=\n      (eLpNorm_indicator_const_le _ _).trans_lt <| by simp [lt_top_iff_ne_top, hμv.ne]\n    refine (eLpNorm_mono fun x => ?_).trans_lt this\n    by_cases hx : x ∈ v\n    · simp only [hx, abs_of_nonneg (hg_range x).1, (hg_range x).2, Real.norm_eq_abs,\n        indicator_of_mem, CStarRing.norm_one]\n    · simp only [hgv hx, Pi.zero_apply, Real.norm_eq_abs, abs_zero, abs_nonneg]\n  refine\n    ⟨fun x => g x • c, g.continuous.smul continuous_const, (eLpNorm_mono gc_bd).trans ?_, gc_bd0,\n      gc_support.trans inter_subset_left, gc_mem⟩\n  exact hη _ ((measure_mono (diff_subset_diff inter_subset_right Subset.rfl)).trans hV.le)\n\n"}
{"name":"MeasureTheory.Memℒp.exists_hasCompactSupport_eLpNorm_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"α : Type u_1\ninst✝⁸ : TopologicalSpace α\ninst✝⁷ : NormalSpace α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : BorelSpace α\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\ninst✝³ : NormedSpace Real E\ninst✝² : R1Space α\ninst✝¹ : WeaklyLocallyCompactSpace α\ninst✝ : μ.Regular\nhp : Ne p Top.top\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun g => And (HasCompactSupport g) (And (LE.le (MeasureTheory.eLpNorm (HSub.hSub f g) p μ) ε) (And (Continuous g) (MeasureTheory.Memℒp g p μ)))","decl":"/-- In a locally compact space, any function in `ℒp` can be approximated by compactly supported\ncontinuous functions when `p < ∞`, version in terms of `eLpNorm`. -/\ntheorem Memℒp.exists_hasCompactSupport_eLpNorm_sub_le\n    [R1Space α] [WeaklyLocallyCompactSpace α] [μ.Regular]\n    (hp : p ≠ ∞) {f : α → E} (hf : Memℒp f p μ) {ε : ℝ≥0∞} (hε : ε ≠ 0) :\n    ∃ g : α → E, HasCompactSupport g ∧ eLpNorm (f - g) p μ ≤ ε ∧ Continuous g ∧ Memℒp g p μ := by\n  suffices H :\n      ∃ g : α → E, eLpNorm (f - g) p μ ≤ ε ∧ Continuous g ∧ Memℒp g p μ ∧ HasCompactSupport g by\n    rcases H with ⟨g, hg, g_cont, g_mem, g_support⟩\n    exact ⟨g, g_support, hg, g_cont, g_mem⟩\n  -- It suffices to check that the set of functions we consider approximates characteristic\n  -- functions, is stable under addition and consists of ae strongly measurable functions.\n  -- First check the latter easy facts.\n  apply hf.induction_dense hp _ _ _ _ hε\n  rotate_left\n  -- stability under addition\n  · rintro f g ⟨f_cont, f_mem, hf⟩ ⟨g_cont, g_mem, hg⟩\n    exact ⟨f_cont.add g_cont, f_mem.add g_mem, hf.add hg⟩\n  -- ae strong measurability\n  · rintro f ⟨_f_cont, f_mem, _hf⟩\n    exact f_mem.aestronglyMeasurable\n  -- We are left with approximating characteristic functions.\n  -- This follows from `exists_continuous_eLpNorm_sub_le_of_closed`.\n  intro c t ht htμ ε hε\n  rcases exists_Lp_half E μ p hε with ⟨δ, δpos, hδ⟩\n  obtain ⟨η, ηpos, hη⟩ :\n      ∃ η : ℝ≥0, 0 < η ∧ ∀ s : Set α, μ s ≤ η → eLpNorm (s.indicator fun _x => c) p μ ≤ δ :=\n    exists_eLpNorm_indicator_le hp c δpos.ne'\n  have hη_pos' : (0 : ℝ≥0∞) < η := ENNReal.coe_pos.2 ηpos\n  obtain ⟨s, st, s_compact, s_closed, μs⟩ :\n      ∃ s, s ⊆ t ∧ IsCompact s ∧ IsClosed s ∧ μ (t \\ s) < η :=\n    ht.exists_isCompact_isClosed_diff_lt htμ.ne hη_pos'.ne'\n  have hsμ : μ s < ∞ := (measure_mono st).trans_lt htμ\n  have I1 : eLpNorm ((s.indicator fun _y => c) - t.indicator fun _y => c) p μ ≤ δ := by\n    rw [← eLpNorm_neg, neg_sub, ← indicator_diff st]\n    exact hη _ μs.le\n  obtain ⟨k, k_compact, sk⟩ : ∃ k : Set α, IsCompact k ∧ s ⊆ interior k :=\n    exists_compact_superset s_compact\n  rcases exists_continuous_eLpNorm_sub_le_of_closed hp s_closed isOpen_interior sk hsμ.ne c δpos.ne'\n    with ⟨f, f_cont, I2, _f_bound, f_support, f_mem⟩\n  have I3 : eLpNorm (f - t.indicator fun _y => c) p μ ≤ ε := by\n    convert\n      (hδ _ _\n          (f_mem.aestronglyMeasurable.sub\n            (aestronglyMeasurable_const.indicator s_closed.measurableSet))\n          ((aestronglyMeasurable_const.indicator s_closed.measurableSet).sub\n            (aestronglyMeasurable_const.indicator ht))\n          I2 I1).le using 2\n    simp only [sub_add_sub_cancel]\n  refine ⟨f, I3, f_cont, f_mem, HasCompactSupport.intro k_compact fun x hx => ?_⟩\n  rw [← Function.nmem_support]\n  contrapose! hx\n  exact interior_subset (f_support hx)\n\n"}
{"name":"MeasureTheory.Memℒp.exists_hasCompactSupport_integral_rpow_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"α : Type u_1\ninst✝⁸ : TopologicalSpace α\ninst✝⁷ : NormalSpace α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : BorelSpace α\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\ninst✝³ : NormedSpace Real E\ninst✝² : R1Space α\ninst✝¹ : WeaklyLocallyCompactSpace α\ninst✝ : μ.Regular\np : Real\nhp : LT.lt 0 p\nf : α → E\nhf : MeasureTheory.Memℒp f (ENNReal.ofReal p) μ\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun g => And (HasCompactSupport g) (And (LE.le (MeasureTheory.integral μ fun x => HPow.hPow (Norm.norm (HSub.hSub (f x) (g x))) p) ε) (And (Continuous g) (MeasureTheory.Memℒp g (ENNReal.ofReal p) μ)))","decl":"/-- In a locally compact space, any function in `ℒp` can be approximated by compactly supported\ncontinuous functions when `0 < p < ∞`, version in terms of `∫`. -/\ntheorem Memℒp.exists_hasCompactSupport_integral_rpow_sub_le\n    [R1Space α] [WeaklyLocallyCompactSpace α] [μ.Regular]\n    {p : ℝ} (hp : 0 < p) {f : α → E} (hf : Memℒp f (ENNReal.ofReal p) μ) {ε : ℝ} (hε : 0 < ε) :\n    ∃ g : α → E,\n      HasCompactSupport g ∧\n        (∫ x, ‖f x - g x‖ ^ p ∂μ) ≤ ε ∧ Continuous g ∧ Memℒp g (ENNReal.ofReal p) μ := by\n  have I : 0 < ε ^ (1 / p) := Real.rpow_pos_of_pos hε _\n  have A : ENNReal.ofReal (ε ^ (1 / p)) ≠ 0 := by\n    simp only [Ne, ENNReal.ofReal_eq_zero, not_le, I]\n  have B : ENNReal.ofReal p ≠ 0 := by simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hp\n  rcases hf.exists_hasCompactSupport_eLpNorm_sub_le ENNReal.coe_ne_top A with\n    ⟨g, g_support, hg, g_cont, g_mem⟩\n  change eLpNorm _ (ENNReal.ofReal p) _ ≤ _ at hg\n  refine ⟨g, g_support, ?_, g_cont, g_mem⟩\n  rwa [(hf.sub g_mem).eLpNorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,\n    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,\n    Real.rpow_le_rpow_iff _ hε.le (inv_pos.2 hp)] at hg\n  positivity\n\n"}
{"name":"MeasureTheory.Integrable.exists_hasCompactSupport_lintegral_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"α : Type u_1\ninst✝⁸ : TopologicalSpace α\ninst✝⁷ : NormalSpace α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : BorelSpace α\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\ninst✝³ : NormedSpace Real E\ninst✝² : R1Space α\ninst✝¹ : WeaklyLocallyCompactSpace α\ninst✝ : μ.Regular\nf : α → E\nhf : MeasureTheory.Integrable f μ\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun g => And (HasCompactSupport g) (And (LE.le (MeasureTheory.lintegral μ fun x => ENorm.enorm (HSub.hSub (f x) (g x))) ε) (And (Continuous g) (MeasureTheory.Integrable g μ)))","decl":"/-- In a locally compact space, any integrable function can be approximated by compactly supported\ncontinuous functions, version in terms of `∫⁻`. -/\ntheorem Integrable.exists_hasCompactSupport_lintegral_sub_le\n    [R1Space α] [WeaklyLocallyCompactSpace α] [μ.Regular]\n    {f : α → E} (hf : Integrable f μ) {ε : ℝ≥0∞} (hε : ε ≠ 0) :\n    ∃ g : α → E,\n      HasCompactSupport g ∧ ∫⁻ x, ‖f x - g x‖ₑ ∂μ ≤ ε ∧ Continuous g ∧ Integrable g μ := by\n  simp only [← memℒp_one_iff_integrable, ← eLpNorm_one_eq_lintegral_enorm] at hf ⊢\n  exact hf.exists_hasCompactSupport_eLpNorm_sub_le ENNReal.one_ne_top hε\n\n"}
{"name":"MeasureTheory.Integrable.exists_hasCompactSupport_integral_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"α : Type u_1\ninst✝⁸ : TopologicalSpace α\ninst✝⁷ : NormalSpace α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : BorelSpace α\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\ninst✝³ : NormedSpace Real E\ninst✝² : R1Space α\ninst✝¹ : WeaklyLocallyCompactSpace α\ninst✝ : μ.Regular\nf : α → E\nhf : MeasureTheory.Integrable f μ\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun g => And (HasCompactSupport g) (And (LE.le (MeasureTheory.integral μ fun x => Norm.norm (HSub.hSub (f x) (g x))) ε) (And (Continuous g) (MeasureTheory.Integrable g μ)))","decl":"/-- In a locally compact space, any integrable function can be approximated by compactly supported\ncontinuous functions, version in terms of `∫`. -/\ntheorem Integrable.exists_hasCompactSupport_integral_sub_le\n    [R1Space α] [WeaklyLocallyCompactSpace α] [μ.Regular]\n    {f : α → E} (hf : Integrable f μ) {ε : ℝ} (hε : 0 < ε) :\n    ∃ g : α → E, HasCompactSupport g ∧ (∫ x, ‖f x - g x‖ ∂μ) ≤ ε ∧\n      Continuous g ∧ Integrable g μ := by\n  simp only [← memℒp_one_iff_integrable, ← eLpNorm_one_eq_lintegral_enorm, ← ENNReal.ofReal_one]\n    at hf ⊢\n  simpa using hf.exists_hasCompactSupport_integral_rpow_sub_le zero_lt_one hε\n\n"}
{"name":"MeasureTheory.Memℒp.exists_boundedContinuous_eLpNorm_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : NormalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\nE : Type u_2\ninst✝² : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\ninst✝¹ : NormedSpace Real E\ninst✝ : μ.WeaklyRegular\nhp : Ne p Top.top\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun g => And (LE.le (MeasureTheory.eLpNorm (HSub.hSub f ⇑g) p μ) ε) (MeasureTheory.Memℒp (⇑g) p μ)","decl":"/-- Any function in `ℒp` can be approximated by bounded continuous functions when `p < ∞`,\nversion in terms of `eLpNorm`. -/\ntheorem Memℒp.exists_boundedContinuous_eLpNorm_sub_le [μ.WeaklyRegular] (hp : p ≠ ∞) {f : α → E}\n    (hf : Memℒp f p μ) {ε : ℝ≥0∞} (hε : ε ≠ 0) :\n    ∃ g : α →ᵇ E, eLpNorm (f - (g : α → E)) p μ ≤ ε ∧ Memℒp g p μ := by\n  suffices H :\n      ∃ g : α → E, eLpNorm (f - g) p μ ≤ ε ∧ Continuous g ∧ Memℒp g p μ ∧ IsBounded (range g) by\n    rcases H with ⟨g, hg, g_cont, g_mem, g_bd⟩\n    exact ⟨⟨⟨g, g_cont⟩, Metric.isBounded_range_iff.1 g_bd⟩, hg, g_mem⟩\n  -- It suffices to check that the set of functions we consider approximates characteristic\n  -- functions, is stable under addition and made of ae strongly measurable functions.\n  -- First check the latter easy facts.\n  apply hf.induction_dense hp _ _ _ _ hε\n  rotate_left\n  -- stability under addition\n  · rintro f g ⟨f_cont, f_mem, f_bd⟩ ⟨g_cont, g_mem, g_bd⟩\n    refine ⟨f_cont.add g_cont, f_mem.add g_mem, ?_⟩\n    let f' : α →ᵇ E := ⟨⟨f, f_cont⟩, Metric.isBounded_range_iff.1 f_bd⟩\n    let g' : α →ᵇ E := ⟨⟨g, g_cont⟩, Metric.isBounded_range_iff.1 g_bd⟩\n    exact (f' + g').isBounded_range\n  -- ae strong measurability\n  · exact fun f ⟨_, h, _⟩ => h.aestronglyMeasurable\n  -- We are left with approximating characteristic functions.\n  -- This follows from `exists_continuous_eLpNorm_sub_le_of_closed`.\n  intro c t ht htμ ε hε\n  rcases exists_Lp_half E μ p hε with ⟨δ, δpos, hδ⟩\n  obtain ⟨η, ηpos, hη⟩ :\n      ∃ η : ℝ≥0, 0 < η ∧ ∀ s : Set α, μ s ≤ η → eLpNorm (s.indicator fun _x => c) p μ ≤ δ :=\n    exists_eLpNorm_indicator_le hp c δpos.ne'\n  have hη_pos' : (0 : ℝ≥0∞) < η := ENNReal.coe_pos.2 ηpos\n  obtain ⟨s, st, s_closed, μs⟩ : ∃ s, s ⊆ t ∧ IsClosed s ∧ μ (t \\ s) < η :=\n    ht.exists_isClosed_diff_lt htμ.ne hη_pos'.ne'\n  have hsμ : μ s < ∞ := (measure_mono st).trans_lt htμ\n  have I1 : eLpNorm ((s.indicator fun _y => c) - t.indicator fun _y => c) p μ ≤ δ := by\n    rw [← eLpNorm_neg, neg_sub, ← indicator_diff st]\n    exact hη _ μs.le\n  rcases exists_continuous_eLpNorm_sub_le_of_closed hp s_closed isOpen_univ (subset_univ _) hsμ.ne c\n      δpos.ne' with\n    ⟨f, f_cont, I2, f_bound, -, f_mem⟩\n  have I3 : eLpNorm (f - t.indicator fun _y => c) p μ ≤ ε := by\n    convert\n      (hδ _ _\n          (f_mem.aestronglyMeasurable.sub\n            (aestronglyMeasurable_const.indicator s_closed.measurableSet))\n          ((aestronglyMeasurable_const.indicator s_closed.measurableSet).sub\n            (aestronglyMeasurable_const.indicator ht))\n          I2 I1).le using 2\n    simp only [sub_add_sub_cancel]\n  refine ⟨f, I3, f_cont, f_mem, ?_⟩\n  exact (BoundedContinuousFunction.ofNormedAddCommGroup f f_cont _ f_bound).isBounded_range\n\n"}
{"name":"MeasureTheory.Memℒp.exists_boundedContinuous_integral_rpow_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : NormalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\nE : Type u_2\ninst✝² : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedSpace Real E\ninst✝ : μ.WeaklyRegular\np : Real\nhp : LT.lt 0 p\nf : α → E\nhf : MeasureTheory.Memℒp f (ENNReal.ofReal p) μ\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun g => And (LE.le (MeasureTheory.integral μ fun x => HPow.hPow (Norm.norm (HSub.hSub (f x) (g x))) p) ε) (MeasureTheory.Memℒp (⇑g) (ENNReal.ofReal p) μ)","decl":"/-- Any function in `ℒp` can be approximated by bounded continuous functions when `0 < p < ∞`,\nversion in terms of `∫`. -/\ntheorem Memℒp.exists_boundedContinuous_integral_rpow_sub_le [μ.WeaklyRegular] {p : ℝ} (hp : 0 < p)\n    {f : α → E} (hf : Memℒp f (ENNReal.ofReal p) μ) {ε : ℝ} (hε : 0 < ε) :\n    ∃ g : α →ᵇ E, (∫ x, ‖f x - g x‖ ^ p ∂μ) ≤ ε ∧ Memℒp g (ENNReal.ofReal p) μ := by\n  have I : 0 < ε ^ (1 / p) := Real.rpow_pos_of_pos hε _\n  have A : ENNReal.ofReal (ε ^ (1 / p)) ≠ 0 := by\n    simp only [Ne, ENNReal.ofReal_eq_zero, not_le, I]\n  have B : ENNReal.ofReal p ≠ 0 := by simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hp\n  rcases hf.exists_boundedContinuous_eLpNorm_sub_le ENNReal.coe_ne_top A with ⟨g, hg, g_mem⟩\n  change eLpNorm _ (ENNReal.ofReal p) _ ≤ _ at hg\n  refine ⟨g, ?_, g_mem⟩\n  rwa [(hf.sub g_mem).eLpNorm_eq_integral_rpow_norm B ENNReal.coe_ne_top,\n    ENNReal.ofReal_le_ofReal_iff I.le, one_div, ENNReal.toReal_ofReal hp.le,\n    Real.rpow_le_rpow_iff _ hε.le (inv_pos.2 hp)] at hg\n  positivity\n\n"}
{"name":"MeasureTheory.Integrable.exists_boundedContinuous_lintegral_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : NormalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\nE : Type u_2\ninst✝² : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedSpace Real E\ninst✝ : μ.WeaklyRegular\nf : α → E\nhf : MeasureTheory.Integrable f μ\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun g => And (LE.le (MeasureTheory.lintegral μ fun x => ENorm.enorm (HSub.hSub (f x) (g x))) ε) (MeasureTheory.Integrable (⇑g) μ)","decl":"/-- Any integrable function can be approximated by bounded continuous functions,\nversion in terms of `∫⁻`. -/\ntheorem Integrable.exists_boundedContinuous_lintegral_sub_le [μ.WeaklyRegular] {f : α → E}\n    (hf : Integrable f μ) {ε : ℝ≥0∞} (hε : ε ≠ 0) :\n    ∃ g : α →ᵇ E, ∫⁻ x, ‖f x - g x‖ₑ ∂μ ≤ ε ∧ Integrable g μ := by\n  simp only [← memℒp_one_iff_integrable, ← eLpNorm_one_eq_lintegral_enorm] at hf ⊢\n  exact hf.exists_boundedContinuous_eLpNorm_sub_le ENNReal.one_ne_top hε\n\n"}
{"name":"MeasureTheory.Integrable.exists_boundedContinuous_integral_sub_le","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"α : Type u_1\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : NormalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\nE : Type u_2\ninst✝² : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedSpace Real E\ninst✝ : μ.WeaklyRegular\nf : α → E\nhf : MeasureTheory.Integrable f μ\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun g => And (LE.le (MeasureTheory.integral μ fun x => Norm.norm (HSub.hSub (f x) (g x))) ε) (MeasureTheory.Integrable (⇑g) μ)","decl":"/-- Any integrable function can be approximated by bounded continuous functions,\nversion in terms of `∫`. -/\ntheorem Integrable.exists_boundedContinuous_integral_sub_le [μ.WeaklyRegular] {f : α → E}\n    (hf : Integrable f μ) {ε : ℝ} (hε : 0 < ε) :\n    ∃ g : α →ᵇ E, (∫ x, ‖f x - g x‖ ∂μ) ≤ ε ∧ Integrable g μ := by\n  simp only [← memℒp_one_iff_integrable, ← eLpNorm_one_eq_lintegral_enorm, ← ENNReal.ofReal_one]\n    at hf ⊢\n  simpa using hf.exists_boundedContinuous_integral_rpow_sub_le zero_lt_one hε\n\n"}
{"name":"MeasureTheory.Lp.boundedContinuousFunction_dense","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"α : Type u_1\ninst✝⁸ : TopologicalSpace α\ninst✝⁷ : NormalSpace α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : BorelSpace α\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\ninst✝³ : NormedSpace Real E\ninst✝² : SecondCountableTopologyEither α E\ninst✝¹ : Fact (LE.le 1 p)\nhp : Ne p Top.top\ninst✝ : μ.WeaklyRegular\n⊢ Dense ↑(MeasureTheory.Lp.boundedContinuousFunction E p μ)","decl":"/-- A function in `Lp` can be approximated in `Lp` by continuous functions. -/\ntheorem boundedContinuousFunction_dense [SecondCountableTopologyEither α E] [Fact (1 ≤ p)]\n    (hp : p ≠ ∞) [μ.WeaklyRegular] :\n    Dense (boundedContinuousFunction E p μ : Set (Lp E p μ)) := by\n  intro f\n  refine (mem_closure_iff_nhds_basis EMetric.nhds_basis_closed_eball).2 fun ε hε ↦ ?_\n  obtain ⟨g, hg, g_mem⟩ :\n      ∃ g : α →ᵇ E, eLpNorm ((f : α → E) - (g : α → E)) p μ ≤ ε ∧ Memℒp g p μ :=\n    (Lp.memℒp f).exists_boundedContinuous_eLpNorm_sub_le hp hε.ne'\n  refine ⟨g_mem.toLp _, ⟨g, rfl⟩, ?_⟩\n  rwa [EMetric.mem_closedBall', ← Lp.toLp_coeFn f (Lp.memℒp f), Lp.edist_toLp_toLp]\n\n"}
{"name":"MeasureTheory.Lp.boundedContinuousFunction_topologicalClosure","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"α : Type u_1\ninst✝⁸ : TopologicalSpace α\ninst✝⁷ : NormalSpace α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : BorelSpace α\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\ninst✝³ : NormedSpace Real E\ninst✝² : SecondCountableTopologyEither α E\ninst✝¹ : Fact (LE.le 1 p)\nhp : Ne p Top.top\ninst✝ : μ.WeaklyRegular\n⊢ Eq (MeasureTheory.Lp.boundedContinuousFunction E p μ).topologicalClosure Top.top","decl":"/-- A function in `Lp` can be approximated in `Lp` by continuous functions. -/\ntheorem boundedContinuousFunction_topologicalClosure [SecondCountableTopologyEither α E]\n    [Fact (1 ≤ p)] (hp : p ≠ ∞) [μ.WeaklyRegular] :\n    (boundedContinuousFunction E p μ).topologicalClosure = ⊤ :=\n  SetLike.ext' <| (boundedContinuousFunction_dense E μ hp).closure_eq\n\n"}
{"name":"BoundedContinuousFunction.toLp_denseRange","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"α : Type u_1\ninst✝¹⁰ : TopologicalSpace α\ninst✝⁹ : NormalSpace α\ninst✝⁸ : MeasurableSpace α\ninst✝⁷ : BorelSpace α\nE : Type u_2\ninst✝⁶ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\ninst✝⁵ : SecondCountableTopologyEither α E\n_i : Fact (LE.le 1 p)\n𝕜 : Type u_3\ninst✝⁴ : NormedField 𝕜\ninst✝³ : NormedAlgebra Real 𝕜\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : μ.WeaklyRegular\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhp : Ne p Top.top\n⊢ DenseRange ⇑(BoundedContinuousFunction.toLp p μ 𝕜)","decl":"theorem toLp_denseRange [μ.WeaklyRegular] [IsFiniteMeasure μ] (hp : p ≠ ∞) :\n    DenseRange (toLp p μ 𝕜 : (α →ᵇ E) →L[𝕜] Lp E p μ) := by\n  haveI : NormedSpace ℝ E := RestrictScalars.normedSpace ℝ 𝕜 E\n  simpa only [← range_toLp p μ (𝕜 := 𝕜)]\n    using MeasureTheory.Lp.boundedContinuousFunction_dense E μ hp\n\n"}
{"name":"ContinuousMap.toLp_denseRange","module":"Mathlib.MeasureTheory.Function.ContinuousMapDense","initialProofState":"α : Type u_1\ninst✝¹¹ : TopologicalSpace α\ninst✝¹⁰ : NormalSpace α\ninst✝⁹ : MeasurableSpace α\ninst✝⁸ : BorelSpace α\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\np : ENNReal\ninst✝⁶ : SecondCountableTopologyEither α E\n_i : Fact (LE.le 1 p)\n𝕜 : Type u_3\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : NormedAlgebra Real 𝕜\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : CompactSpace α\ninst✝¹ : μ.WeaklyRegular\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhp : Ne p Top.top\n⊢ DenseRange ⇑(ContinuousMap.toLp p μ 𝕜)","decl":"/-- Continuous functions are dense in `MeasureTheory.Lp`, `1 ≤ p < ∞`. This theorem assumes that\nthe domain is a compact space because otherwise `ContinuousMap.toLp` is undefined. Use\n`BoundedContinuousFunction.toLp_denseRange` if the domain is not a compact space. -/\ntheorem toLp_denseRange [CompactSpace α] [μ.WeaklyRegular] [IsFiniteMeasure μ] (hp : p ≠ ∞) :\n    DenseRange (toLp p μ 𝕜 : C(α, E) →L[𝕜] Lp E p μ) := by\n  refine (BoundedContinuousFunction.toLp_denseRange _ _ 𝕜 hp).mono ?_\n  refine range_subset_iff.2 fun f ↦ ?_\n  exact ⟨f.toContinuousMap, rfl⟩\n\n"}
