{"name":"Subgroup.mem_zpowers","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\n⊢ Membership.mem (Subgroup.zpowers g) g","decl":"@[to_additive (attr := simp)]\ntheorem mem_zpowers (g : G) : g ∈ zpowers g :=\n  ⟨1, zpow_one _⟩\n\n"}
{"name":"AddSubgroup.mem_zmultiples","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng : G\n⊢ Membership.mem (AddSubgroup.zmultiples g) g","decl":"@[to_additive (attr := simp)]\ntheorem mem_zpowers (g : G) : g ∈ zpowers g :=\n  ⟨1, zpow_one _⟩\n\n"}
{"name":"Subgroup.coe_zpowers","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\n⊢ Eq (↑(Subgroup.zpowers g)) (Set.range fun x => HPow.hPow g x)","decl":"@[to_additive (attr := norm_cast)] -- TODO: simp?\ntheorem coe_zpowers (g : G) : ↑(zpowers g) = Set.range (g ^ · : ℤ → G) :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_zmultiples","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng : G\n⊢ Eq (↑(AddSubgroup.zmultiples g)) (Set.range fun x => HSMul.hSMul x g)","decl":"@[to_additive (attr := norm_cast)] -- TODO: simp?\ntheorem coe_zpowers (g : G) : ↑(zpowers g) = Set.range (g ^ · : ℤ → G) :=\n  rfl\n\n"}
{"name":"AddSubgroup.zmultiples_eq_closure","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng : G\n⊢ Eq (AddSubgroup.zmultiples g) (AddSubgroup.closure (Singleton.singleton g))","decl":"@[to_additive]\ntheorem zpowers_eq_closure (g : G) : zpowers g = closure {g} := by\n  ext\n  exact mem_closure_singleton.symm\n\n"}
{"name":"Subgroup.zpowers_eq_closure","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\n⊢ Eq (Subgroup.zpowers g) (Subgroup.closure (Singleton.singleton g))","decl":"@[to_additive]\ntheorem zpowers_eq_closure (g : G) : zpowers g = closure {g} := by\n  ext\n  exact mem_closure_singleton.symm\n\n"}
{"name":"AddSubgroup.mem_zmultiples_iff","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng h : G\n⊢ Iff (Membership.mem (AddSubgroup.zmultiples g) h) (Exists fun k => Eq (HSMul.hSMul k g) h)","decl":"@[to_additive]\ntheorem mem_zpowers_iff {g h : G} : h ∈ zpowers g ↔ ∃ k : ℤ, g ^ k = h :=\n  Iff.rfl\n\n"}
{"name":"Subgroup.mem_zpowers_iff","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng h : G\n⊢ Iff (Membership.mem (Subgroup.zpowers g) h) (Exists fun k => Eq (HPow.hPow g k) h)","decl":"@[to_additive]\ntheorem mem_zpowers_iff {g h : G} : h ∈ zpowers g ↔ ∃ k : ℤ, g ^ k = h :=\n  Iff.rfl\n\n"}
{"name":"AddSubgroup.zsmul_mem_zmultiples","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng : G\nk : Int\n⊢ Membership.mem (AddSubgroup.zmultiples g) (HSMul.hSMul k g)","decl":"@[to_additive (attr := simp)]\ntheorem zpow_mem_zpowers (g : G) (k : ℤ) : g ^ k ∈ zpowers g :=\n  mem_zpowers_iff.mpr ⟨k, rfl⟩\n\n"}
{"name":"Subgroup.zpow_mem_zpowers","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\nk : Int\n⊢ Membership.mem (Subgroup.zpowers g) (HPow.hPow g k)","decl":"@[to_additive (attr := simp)]\ntheorem zpow_mem_zpowers (g : G) (k : ℤ) : g ^ k ∈ zpowers g :=\n  mem_zpowers_iff.mpr ⟨k, rfl⟩\n\n"}
{"name":"Subgroup.npow_mem_zpowers","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\nk : Nat\n⊢ Membership.mem (Subgroup.zpowers g) (HPow.hPow g k)","decl":"@[to_additive (attr := simp)]\ntheorem npow_mem_zpowers (g : G) (k : ℕ) : g ^ k ∈ zpowers g :=\n  zpow_natCast g k ▸ zpow_mem_zpowers g k\n\n-- Porting note: increasing simp priority. Better lemma than `Subtype.exists`\n"}
{"name":"AddSubgroup.nsmul_mem_zmultiples","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng : G\nk : Nat\n⊢ Membership.mem (AddSubgroup.zmultiples g) (HSMul.hSMul k g)","decl":"@[to_additive (attr := simp)]\ntheorem npow_mem_zpowers (g : G) (k : ℕ) : g ^ k ∈ zpowers g :=\n  zpow_natCast g k ▸ zpow_mem_zpowers g k\n\n-- Porting note: increasing simp priority. Better lemma than `Subtype.exists`\n"}
{"name":"AddSubgroup.forall_zmultiples","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\np : (Subtype fun x_1 => Membership.mem (AddSubgroup.zmultiples x) x_1) → Prop\n⊢ Iff (∀ (g : Subtype fun x_1 => Membership.mem (AddSubgroup.zmultiples x) x_1), p g) (∀ (m : Int), p ⟨HSMul.hSMul m x, ⋯⟩)","decl":"@[to_additive (attr := simp 1100)]\ntheorem forall_zpowers {x : G} {p : zpowers x → Prop} : (∀ g, p g) ↔ ∀ m : ℤ, p ⟨x ^ m, m, rfl⟩ :=\n  Set.forall_subtype_range_iff\n\n-- Porting note: increasing simp priority. Better lemma than `Subtype.exists`\n"}
{"name":"Subgroup.forall_zpowers","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\np : (Subtype fun x_1 => Membership.mem (Subgroup.zpowers x) x_1) → Prop\n⊢ Iff (∀ (g : Subtype fun x_1 => Membership.mem (Subgroup.zpowers x) x_1), p g) (∀ (m : Int), p ⟨HPow.hPow x m, ⋯⟩)","decl":"@[to_additive (attr := simp 1100)]\ntheorem forall_zpowers {x : G} {p : zpowers x → Prop} : (∀ g, p g) ↔ ∀ m : ℤ, p ⟨x ^ m, m, rfl⟩ :=\n  Set.forall_subtype_range_iff\n\n-- Porting note: increasing simp priority. Better lemma than `Subtype.exists`\n"}
{"name":"Subgroup.exists_zpowers","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\np : (Subtype fun x_1 => Membership.mem (Subgroup.zpowers x) x_1) → Prop\n⊢ Iff (Exists fun g => p g) (Exists fun m => p ⟨HPow.hPow x m, ⋯⟩)","decl":"@[to_additive (attr := simp 1100)]\ntheorem exists_zpowers {x : G} {p : zpowers x → Prop} : (∃ g, p g) ↔ ∃ m : ℤ, p ⟨x ^ m, m, rfl⟩ :=\n  Set.exists_subtype_range_iff\n\n"}
{"name":"AddSubgroup.exists_zmultiples","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\np : (Subtype fun x_1 => Membership.mem (AddSubgroup.zmultiples x) x_1) → Prop\n⊢ Iff (Exists fun g => p g) (Exists fun m => p ⟨HSMul.hSMul m x, ⋯⟩)","decl":"@[to_additive (attr := simp 1100)]\ntheorem exists_zpowers {x : G} {p : zpowers x → Prop} : (∃ g, p g) ↔ ∃ m : ℤ, p ⟨x ^ m, m, rfl⟩ :=\n  Set.exists_subtype_range_iff\n\n"}
{"name":"AddSubgroup.forall_mem_zmultiples","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\np : G → Prop\n⊢ Iff (∀ (g : G), Membership.mem (AddSubgroup.zmultiples x) g → p g) (∀ (m : Int), p (HSMul.hSMul m x))","decl":"@[to_additive]\ntheorem forall_mem_zpowers {x : G} {p : G → Prop} : (∀ g ∈ zpowers x, p g) ↔ ∀ m : ℤ, p (x ^ m) :=\n  Set.forall_mem_range\n\n"}
{"name":"Subgroup.forall_mem_zpowers","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\np : G → Prop\n⊢ Iff (∀ (g : G), Membership.mem (Subgroup.zpowers x) g → p g) (∀ (m : Int), p (HPow.hPow x m))","decl":"@[to_additive]\ntheorem forall_mem_zpowers {x : G} {p : G → Prop} : (∀ g ∈ zpowers x, p g) ↔ ∀ m : ℤ, p (x ^ m) :=\n  Set.forall_mem_range\n\n"}
{"name":"AddSubgroup.exists_mem_zmultiples","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nx : G\np : G → Prop\n⊢ Iff (Exists fun g => And (Membership.mem (AddSubgroup.zmultiples x) g) (p g)) (Exists fun m => p (HSMul.hSMul m x))","decl":"@[to_additive]\ntheorem exists_mem_zpowers {x : G} {p : G → Prop} : (∃ g ∈ zpowers x, p g) ↔ ∃ m : ℤ, p (x ^ m) :=\n  Set.exists_range_iff\n\n"}
{"name":"Subgroup.exists_mem_zpowers","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\np : G → Prop\n⊢ Iff (Exists fun g => And (Membership.mem (Subgroup.zpowers x) g) (p g)) (Exists fun m => p (HPow.hPow x m))","decl":"@[to_additive]\ntheorem exists_mem_zpowers {x : G} {p : G → Prop} : (∃ g ∈ zpowers x, p g) ↔ ∃ m : ℤ, p (x ^ m) :=\n  Set.exists_range_iff\n\n"}
{"name":"MonoidHom.map_zpowers","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_3\ninst✝ : Group N\nf : MonoidHom G N\nx : G\n⊢ Eq (Subgroup.map f (Subgroup.zpowers x)) (Subgroup.zpowers (f x))","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.map_zpowers (f : G →* N) (x : G) :\n    (Subgroup.zpowers x).map f = Subgroup.zpowers (f x) := by\n  rw [Subgroup.zpowers_eq_closure, Subgroup.zpowers_eq_closure, f.map_closure, Set.image_singleton]\n\n"}
{"name":"AddMonoidHom.map_zmultiples","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_3\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nx : G\n⊢ Eq (AddSubgroup.map f (AddSubgroup.zmultiples x)) (AddSubgroup.zmultiples (f x))","decl":"@[to_additive (attr := simp)]\ntheorem MonoidHom.map_zpowers (f : G →* N) (x : G) :\n    (Subgroup.zpowers x).map f = Subgroup.zpowers (f x) := by\n  rw [Subgroup.zpowers_eq_closure, Subgroup.zpowers_eq_closure, f.map_closure, Set.image_singleton]\n\n"}
{"name":"Int.mem_zmultiples_iff","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"a b : Int\n⊢ Iff (Membership.mem (AddSubgroup.zmultiples a) b) (Dvd.dvd a b)","decl":"theorem Int.mem_zmultiples_iff {a b : ℤ} : b ∈ AddSubgroup.zmultiples a ↔ a ∣ b :=\n  exists_congr fun k => by rw [mul_comm, eq_comm, ← smul_eq_mul]\n\n"}
{"name":"Int.zmultiples_one","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"⊢ Eq (AddSubgroup.zmultiples 1) Top.top","decl":"@[simp]\nlemma Int.zmultiples_one : AddSubgroup.zmultiples (1 : ℤ) = ⊤ := by\n  ext z\n  simpa only [AddSubgroup.mem_top, iff_true] using ⟨z, zsmul_int_one z⟩\n\n"}
{"name":"ofMul_image_zpowers_eq_zmultiples_ofMul","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nx : G\n⊢ Eq (Set.image ⇑Additive.ofMul ↑(Subgroup.zpowers x)) ↑(AddSubgroup.zmultiples (Additive.ofMul x))","decl":"theorem ofMul_image_zpowers_eq_zmultiples_ofMul {x : G} :\n    Additive.ofMul '' (Subgroup.zpowers x : Set G) = AddSubgroup.zmultiples (Additive.ofMul x) := by\n  ext y\n  constructor\n  · rintro ⟨z, ⟨m, hm⟩, hz2⟩\n    use m\n    simp only at *\n    rwa [← ofMul_zpow, hm]\n  · rintro ⟨n, hn⟩\n    refine ⟨x ^ n, ⟨n, rfl⟩, ?_⟩\n    rwa [ofMul_zpow]\n\n"}
{"name":"ofAdd_image_zmultiples_eq_zpowers_ofAdd","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"A : Type u_2\ninst✝ : AddGroup A\nx : A\n⊢ Eq (Set.image ⇑Multiplicative.ofAdd ↑(AddSubgroup.zmultiples x)) ↑(Subgroup.zpowers (Multiplicative.ofAdd x))","decl":"theorem ofAdd_image_zmultiples_eq_zpowers_ofAdd {x : A} :\n    Multiplicative.ofAdd '' (AddSubgroup.zmultiples x : Set A) =\n      Subgroup.zpowers (Multiplicative.ofAdd x) := by\n  symm\n  rw [Equiv.eq_image_iff_symm_image_eq]\n  exact ofMul_image_zpowers_eq_zmultiples_ofMul\n\n"}
{"name":"AddSubgroup.zmultiples_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng : G\n⊢ (AddSubgroup.zmultiples g).IsCommutative","decl":"@[to_additive]\ninstance zpowers_isCommutative (g : G) : (zpowers g).IsCommutative :=\n  ⟨⟨fun ⟨_, _, h₁⟩ ⟨_, _, h₂⟩ => by\n      rw [Subtype.ext_iff, coe_mul, coe_mul, Subtype.coe_mk, Subtype.coe_mk, ← h₁, ← h₂,\n        zpow_mul_comm]⟩⟩\n\n"}
{"name":"Subgroup.zpowers_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\n⊢ (Subgroup.zpowers g).IsCommutative","decl":"@[to_additive]\ninstance zpowers_isCommutative (g : G) : (zpowers g).IsCommutative :=\n  ⟨⟨fun ⟨_, _, h₁⟩ ⟨_, _, h₂⟩ => by\n      rw [Subtype.ext_iff, coe_mul, coe_mul, Subtype.coe_mk, Subtype.coe_mk, ← h₁, ← h₂,\n        zpow_mul_comm]⟩⟩\n\n"}
{"name":"AddSubgroup.zmultiples_le","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng : G\nH : AddSubgroup G\n⊢ Iff (LE.le (AddSubgroup.zmultiples g) H) (Membership.mem H g)","decl":"@[to_additive (attr := simp)]\ntheorem zpowers_le {g : G} {H : Subgroup G} : zpowers g ≤ H ↔ g ∈ H := by\n  rw [zpowers_eq_closure, closure_le, Set.singleton_subset_iff, SetLike.mem_coe]\n\n"}
{"name":"Subgroup.zpowers_le","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\nH : Subgroup G\n⊢ Iff (LE.le (Subgroup.zpowers g) H) (Membership.mem H g)","decl":"@[to_additive (attr := simp)]\ntheorem zpowers_le {g : G} {H : Subgroup G} : zpowers g ≤ H ↔ g ∈ H := by\n  rw [zpowers_eq_closure, closure_le, Set.singleton_subset_iff, SetLike.mem_coe]\n\n"}
{"name":"Subgroup.zpowers_le_of_mem","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\nH : Subgroup G\na✝ : Membership.mem H g\n⊢ LE.le (Subgroup.zpowers g) H","decl":"alias ⟨_, zpowers_le_of_mem⟩ := zpowers_le\n\n"}
{"name":"AddSubgroup.zmultiples_le_of_mem","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng : G\nH : AddSubgroup G\na✝ : Membership.mem H g\n⊢ LE.le (AddSubgroup.zmultiples g) H","decl":"alias ⟨_, _root_.AddSubgroup.zmultiples_le_of_mem⟩ := AddSubgroup.zmultiples_le\n\n"}
{"name":"Subgroup.zpowers_eq_bot","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\n⊢ Iff (Eq (Subgroup.zpowers g) Bot.bot) (Eq g 1)","decl":"@[to_additive (attr := simp)]\ntheorem zpowers_eq_bot {g : G} : zpowers g = ⊥ ↔ g = 1 := by rw [eq_bot_iff, zpowers_le, mem_bot]\n\n"}
{"name":"AddSubgroup.zmultiples_eq_bot","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng : G\n⊢ Iff (Eq (AddSubgroup.zmultiples g) Bot.bot) (Eq g 0)","decl":"@[to_additive (attr := simp)]\ntheorem zpowers_eq_bot {g : G} : zpowers g = ⊥ ↔ g = 1 := by rw [eq_bot_iff, zpowers_le, mem_bot]\n\n"}
{"name":"AddSubgroup.zmultiples_ne_bot","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng : G\n⊢ Iff (Ne (AddSubgroup.zmultiples g) Bot.bot) (Ne g 0)","decl":"@[to_additive]\ntheorem zpowers_ne_bot : zpowers g ≠ ⊥ ↔ g ≠ 1 :=\n  zpowers_eq_bot.not\n\n"}
{"name":"Subgroup.zpowers_ne_bot","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\n⊢ Iff (Ne (Subgroup.zpowers g) Bot.bot) (Ne g 1)","decl":"@[to_additive]\ntheorem zpowers_ne_bot : zpowers g ≠ ⊥ ↔ g ≠ 1 :=\n  zpowers_eq_bot.not\n\n"}
{"name":"Subgroup.zpowers_one_eq_bot","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (Subgroup.zpowers 1) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem zpowers_one_eq_bot : Subgroup.zpowers (1 : G) = ⊥ :=\n  Subgroup.zpowers_eq_bot.mpr rfl\n\n"}
{"name":"AddSubgroup.zmultiples_zero_eq_bot","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Eq (AddSubgroup.zmultiples 0) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem zpowers_one_eq_bot : Subgroup.zpowers (1 : G) = ⊥ :=\n  Subgroup.zpowers_eq_bot.mpr rfl\n\n"}
{"name":"AddSubgroup.zmultiples_neg","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ng : G\n⊢ Eq (AddSubgroup.zmultiples (Neg.neg g)) (AddSubgroup.zmultiples g)","decl":"@[to_additive (attr := simp)]\ntheorem zpowers_inv : zpowers g⁻¹ = zpowers g :=\n  eq_of_forall_ge_iff fun _ ↦ by simp only [zpowers_le, inv_mem_iff]\n\n"}
{"name":"Subgroup.zpowers_inv","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ng : G\n⊢ Eq (Subgroup.zpowers (Inv.inv g)) (Subgroup.zpowers g)","decl":"@[to_additive (attr := simp)]\ntheorem zpowers_inv : zpowers g⁻¹ = zpowers g :=\n  eq_of_forall_ge_iff fun _ ↦ by simp only [zpowers_le, inv_mem_iff]\n\n"}
{"name":"AddSubgroup.closure_singleton_int_one_eq_top","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"⊢ Eq (AddSubgroup.closure (Singleton.singleton 1)) Top.top","decl":"lemma AddSubgroup.closure_singleton_int_one_eq_top : closure ({1} : Set ℤ) = ⊤ := by\n  ext\n  simp [mem_closure_singleton]\n\n"}
{"name":"AddSubgroup.zmultiples_one_eq_top","module":"Mathlib.Algebra.Group.Subgroup.ZPowers.Basic","initialProofState":"⊢ Eq (AddSubgroup.zmultiples 1) Top.top","decl":"lemma AddSubgroup.zmultiples_one_eq_top : zmultiples (1 : ℤ) = ⊤ := by\n  rw [zmultiples_eq_closure, closure_singleton_int_one_eq_top]\n"}
