{"name":"CategoryTheory.Subgroupoid.mk.inj","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\narrows✝ : (c d : C) → Set (Quiver.Hom c d)\ninv✝ : ∀ {c d : C} {p : Quiver.Hom c d}, Membership.mem (arrows✝ c d) p → Membership.mem (arrows✝ d c) (CategoryTheory.Groupoid.inv p)\nmul✝ : ∀ {c d e : C} {p : Quiver.Hom c d}, Membership.mem (arrows✝ c d) p → ∀ {q : Quiver.Hom d e}, Membership.mem (arrows✝ d e) q → Membership.mem (arrows✝ c e) (CategoryTheory.CategoryStruct.comp p q)\narrows : (c d : C) → Set (Quiver.Hom c d)\ninv : ∀ {c d : C} {p : Quiver.Hom c d}, Membership.mem (arrows c d) p → Membership.mem (arrows d c) (CategoryTheory.Groupoid.inv p)\nmul : ∀ {c d e : C} {p : Quiver.Hom c d}, Membership.mem (arrows c d) p → ∀ {q : Quiver.Hom d e}, Membership.mem (arrows d e) q → Membership.mem (arrows c e) (CategoryTheory.CategoryStruct.comp p q)\nx✝ : Eq { arrows := arrows✝, inv := inv✝, mul := mul✝ } { arrows := arrows, inv := inv, mul := mul }\n⊢ Eq arrows✝ arrows","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ∀ c d : C, Set (c ⟶ d)\n  protected inv : ∀ {c d} {p : c ⟶ d}, p ∈ arrows c d → Groupoid.inv p ∈ arrows d c\n  protected mul : ∀ {c d e} {p}, p ∈ arrows c d → ∀ {q}, q ∈ arrows d e → p ≫ q ∈ arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.ext","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nx y : CategoryTheory.Subgroupoid C\narrows : Eq x.arrows y.arrows\n⊢ Eq x y","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ∀ c d : C, Set (c ⟶ d)\n  protected inv : ∀ {c d} {p : c ⟶ d}, p ∈ arrows c d → Groupoid.inv p ∈ arrows d c\n  protected mul : ∀ {c d e} {p}, p ∈ arrows c d → ∀ {q}, q ∈ arrows d e → p ≫ q ∈ arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.mk.injEq","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\narrows✝ : (c d : C) → Set (Quiver.Hom c d)\ninv✝ : ∀ {c d : C} {p : Quiver.Hom c d}, Membership.mem (arrows✝ c d) p → Membership.mem (arrows✝ d c) (CategoryTheory.Groupoid.inv p)\nmul✝ : ∀ {c d e : C} {p : Quiver.Hom c d}, Membership.mem (arrows✝ c d) p → ∀ {q : Quiver.Hom d e}, Membership.mem (arrows✝ d e) q → Membership.mem (arrows✝ c e) (CategoryTheory.CategoryStruct.comp p q)\narrows : (c d : C) → Set (Quiver.Hom c d)\ninv : ∀ {c d : C} {p : Quiver.Hom c d}, Membership.mem (arrows c d) p → Membership.mem (arrows d c) (CategoryTheory.Groupoid.inv p)\nmul : ∀ {c d e : C} {p : Quiver.Hom c d}, Membership.mem (arrows c d) p → ∀ {q : Quiver.Hom d e}, Membership.mem (arrows d e) q → Membership.mem (arrows c e) (CategoryTheory.CategoryStruct.comp p q)\n⊢ Eq (Eq { arrows := arrows✝, inv := inv✝, mul := mul✝ } { arrows := arrows, inv := inv, mul := mul }) (Eq arrows✝ arrows)","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ∀ c d : C, Set (c ⟶ d)\n  protected inv : ∀ {c d} {p : c ⟶ d}, p ∈ arrows c d → Groupoid.inv p ∈ arrows d c\n  protected mul : ∀ {c d e} {p}, p ∈ arrows c d → ∀ {q}, q ∈ arrows d e → p ≫ q ∈ arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.ext_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nx y : CategoryTheory.Subgroupoid C\n⊢ Iff (Eq x y) (Eq x.arrows y.arrows)","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ∀ c d : C, Set (c ⟶ d)\n  protected inv : ∀ {c d} {p : c ⟶ d}, p ∈ arrows c d → Groupoid.inv p ∈ arrows d c\n  protected mul : ∀ {c d e} {p}, p ∈ arrows c d → ∀ {q}, q ∈ arrows d e → p ≫ q ∈ arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.mul","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nself : CategoryTheory.Subgroupoid C\nc d e : C\np : Quiver.Hom c d\na✝¹ : Membership.mem (self.arrows c d) p\nq : Quiver.Hom d e\na✝ : Membership.mem (self.arrows d e) q\n⊢ Membership.mem (self.arrows c e) (CategoryTheory.CategoryStruct.comp p q)","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ∀ c d : C, Set (c ⟶ d)\n  protected inv : ∀ {c d} {p : c ⟶ d}, p ∈ arrows c d → Groupoid.inv p ∈ arrows d c\n  protected mul : ∀ {c d e} {p}, p ∈ arrows c d → ∀ {q}, q ∈ arrows d e → p ≫ q ∈ arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.inv","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nself : CategoryTheory.Subgroupoid C\nc d : C\np : Quiver.Hom c d\na✝ : Membership.mem (self.arrows c d) p\n⊢ Membership.mem (self.arrows d c) (CategoryTheory.Groupoid.inv p)","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ∀ c d : C, Set (c ⟶ d)\n  protected inv : ∀ {c d} {p : c ⟶ d}, p ∈ arrows c d → Groupoid.inv p ∈ arrows d c\n  protected mul : ∀ {c d e} {p}, p ∈ arrows c d → ∀ {q}, q ∈ arrows d e → p ≫ q ∈ arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\ninst✝ : SizeOf C\narrows : (c d : C) → Set (Quiver.Hom c d)\ninv : ∀ {c d : C} {p : Quiver.Hom c d}, Membership.mem (arrows c d) p → Membership.mem (arrows d c) (CategoryTheory.Groupoid.inv p)\nmul : ∀ {c d e : C} {p : Quiver.Hom c d}, Membership.mem (arrows c d) p → ∀ {q : Quiver.Hom d e}, Membership.mem (arrows d e) q → Membership.mem (arrows c e) (CategoryTheory.CategoryStruct.comp p q)\n⊢ Eq (SizeOf.sizeOf { arrows := arrows, inv := inv, mul := mul }) 1","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ∀ c d : C, Set (c ⟶ d)\n  protected inv : ∀ {c d} {p : c ⟶ d}, p ∈ arrows c d → Groupoid.inv p ∈ arrows d c\n  protected mul : ∀ {c d e} {p}, p ∈ arrows c d → ∀ {q}, q ∈ arrows d e → p ≫ q ∈ arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.inv_mem_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : C\nf : Quiver.Hom c d\n⊢ Iff (Membership.mem (S.arrows d c) (CategoryTheory.Groupoid.inv f)) (Membership.mem (S.arrows c d) f)","decl":"theorem inv_mem_iff {c d : C} (f : c ⟶ d) :\n    Groupoid.inv f ∈ S.arrows d c ↔ f ∈ S.arrows c d := by\n  constructor\n  · intro h\n    simpa only [inv_eq_inv, IsIso.inv_inv] using S.inv h\n  · apply S.inv\n\n"}
{"name":"CategoryTheory.Subgroupoid.mul_mem_cancel_left","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d e : C\nf : Quiver.Hom c d\ng : Quiver.Hom d e\nhf : Membership.mem (S.arrows c d) f\n⊢ Iff (Membership.mem (S.arrows c e) (CategoryTheory.CategoryStruct.comp f g)) (Membership.mem (S.arrows d e) g)","decl":"theorem mul_mem_cancel_left {c d e : C} {f : c ⟶ d} {g : d ⟶ e} (hf : f ∈ S.arrows c d) :\n    f ≫ g ∈ S.arrows c e ↔ g ∈ S.arrows d e := by\n  constructor\n  · rintro h\n    suffices Groupoid.inv f ≫ f ≫ g ∈ S.arrows d e by\n      simpa only [inv_eq_inv, IsIso.inv_hom_id_assoc] using this\n    apply S.mul (S.inv hf) h\n  · apply S.mul hf\n\n"}
{"name":"CategoryTheory.Subgroupoid.mul_mem_cancel_right","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d e : C\nf : Quiver.Hom c d\ng : Quiver.Hom d e\nhg : Membership.mem (S.arrows d e) g\n⊢ Iff (Membership.mem (S.arrows c e) (CategoryTheory.CategoryStruct.comp f g)) (Membership.mem (S.arrows c d) f)","decl":"theorem mul_mem_cancel_right {c d e : C} {f : c ⟶ d} {g : d ⟶ e} (hg : g ∈ S.arrows d e) :\n    f ≫ g ∈ S.arrows c e ↔ f ∈ S.arrows c d := by\n  constructor\n  · rintro h\n    suffices (f ≫ g) ≫ Groupoid.inv g ∈ S.arrows c d by\n      simpa only [inv_eq_inv, IsIso.hom_inv_id, Category.comp_id, Category.assoc] using this\n    apply S.mul h (S.inv hg)\n  · exact fun hf => S.mul hf hg\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_objs_of_src","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : C\nf : Quiver.Hom c d\nh : Membership.mem (S.arrows c d) f\n⊢ Membership.mem S.objs c","decl":"theorem mem_objs_of_src {c d : C} {f : c ⟶ d} (h : f ∈ S.arrows c d) : c ∈ S.objs :=\n  ⟨f ≫ Groupoid.inv f, S.mul h (S.inv h)⟩\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_objs_of_tgt","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : C\nf : Quiver.Hom c d\nh : Membership.mem (S.arrows c d) f\n⊢ Membership.mem S.objs d","decl":"theorem mem_objs_of_tgt {c d : C} {f : c ⟶ d} (h : f ∈ S.arrows c d) : d ∈ S.objs :=\n  ⟨Groupoid.inv f ≫ f, S.mul (S.inv h) h⟩\n\n"}
{"name":"CategoryTheory.Subgroupoid.id_mem_of_nonempty_isotropy","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc : C\na✝ : Membership.mem S.objs c\n⊢ Membership.mem (S.arrows c c) (CategoryTheory.CategoryStruct.id c)","decl":"theorem id_mem_of_nonempty_isotropy (c : C) : c ∈ objs S → 𝟙 c ∈ S.arrows c c := by\n  rintro ⟨γ, hγ⟩\n  convert S.mul hγ (S.inv hγ)\n  simp only [inv_eq_inv, IsIso.hom_inv_id]\n\n"}
{"name":"CategoryTheory.Subgroupoid.id_mem_of_src","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : C\nf : Quiver.Hom c d\nh : Membership.mem (S.arrows c d) f\n⊢ Membership.mem (S.arrows c c) (CategoryTheory.CategoryStruct.id c)","decl":"theorem id_mem_of_src {c d : C} {f : c ⟶ d} (h : f ∈ S.arrows c d) : 𝟙 c ∈ S.arrows c c :=\n  id_mem_of_nonempty_isotropy S c (mem_objs_of_src S h)\n\n"}
{"name":"CategoryTheory.Subgroupoid.id_mem_of_tgt","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : C\nf : Quiver.Hom c d\nh : Membership.mem (S.arrows c d) f\n⊢ Membership.mem (S.arrows d d) (CategoryTheory.CategoryStruct.id d)","decl":"theorem id_mem_of_tgt {c d : C} {f : c ⟶ d} (h : f ∈ S.arrows c d) : 𝟙 d ∈ S.arrows d d :=\n  id_mem_of_nonempty_isotropy S d (mem_objs_of_tgt S h)\n\n"}
{"name":"CategoryTheory.Subgroupoid.coe_inv_coe","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nX✝ Y✝ : ↑S.objs\np : Quiver.Hom X✝ Y✝\n⊢ Eq (↑(CategoryTheory.Groupoid.inv p)) (CategoryTheory.Groupoid.inv ↑p)","decl":"/-- The coercion of a subgroupoid as a groupoid -/\n@[simps comp_coe, simps (config := .lemmasOnly) inv_coe]\ninstance coe : Groupoid S.objs where\n  Hom a b := S.arrows a.val b.val\n  id a := ⟨𝟙 a.val, id_mem_of_nonempty_isotropy S a.val a.prop⟩\n  comp p q := ⟨p.val ≫ q.val, S.mul p.prop q.prop⟩\n  inv p := ⟨Groupoid.inv p.val, S.inv p.prop⟩\n\n"}
{"name":"CategoryTheory.Subgroupoid.coe_comp_coe","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nX✝ Y✝ Z✝ : ↑S.objs\np : Quiver.Hom X✝ Y✝\nq : Quiver.Hom Y✝ Z✝\n⊢ Eq (↑(CategoryTheory.CategoryStruct.comp p q)) (CategoryTheory.CategoryStruct.comp ↑p ↑q)","decl":"/-- The coercion of a subgroupoid as a groupoid -/\n@[simps comp_coe, simps (config := .lemmasOnly) inv_coe]\ninstance coe : Groupoid S.objs where\n  Hom a b := S.arrows a.val b.val\n  id a := ⟨𝟙 a.val, id_mem_of_nonempty_isotropy S a.val a.prop⟩\n  comp p q := ⟨p.val ≫ q.val, S.mul p.prop q.prop⟩\n  inv p := ⟨Groupoid.inv p.val, S.inv p.prop⟩\n\n"}
{"name":"CategoryTheory.Subgroupoid.coe_inv_coe'","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : ↑S.objs\np : Quiver.Hom c d\n⊢ Eq (↑(CategoryTheory.inv p)) (CategoryTheory.inv ↑p)","decl":"@[simp]\ntheorem coe_inv_coe' {c d : S.objs} (p : c ⟶ d) :\n    (CategoryTheory.inv p).val = CategoryTheory.inv p.val := by\n  simp only [← inv_eq_inv, coe_inv_coe]\n\n"}
{"name":"CategoryTheory.Subgroupoid.hom.inj_on_objects","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n⊢ Function.Injective S.hom.obj","decl":"theorem hom.inj_on_objects : Function.Injective (hom S).obj := by\n  rintro ⟨c, hc⟩ ⟨d, hd⟩ hcd\n  simp only [Subtype.mk_eq_mk]; exact hcd\n\n"}
{"name":"CategoryTheory.Subgroupoid.hom.faithful","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : ↑S.objs\n⊢ Function.Injective fun f => S.hom.map f","decl":"theorem hom.faithful : ∀ c d, Function.Injective fun f : c ⟶ d => (hom S).map f := by\n  rintro ⟨c, hc⟩ ⟨d, hd⟩ ⟨f, hf⟩ ⟨g, hg⟩ hfg; exact Subtype.eq hfg\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nF : Sigma fun c => Sigma fun d => Quiver.Hom c d\n⊢ Iff (Membership.mem S F) (Membership.mem (S.arrows F.fst F.snd.fst) F.snd.snd)","decl":"theorem mem_iff (S : Subgroupoid C) (F : Σ c d, c ⟶ d) : F ∈ S ↔ F.2.2 ∈ S.arrows F.1 F.2.1 :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.Subgroupoid.le_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS T : CategoryTheory.Subgroupoid C\n⊢ Iff (LE.le S T) (∀ {c d : C}, HasSubset.Subset (S.arrows c d) (T.arrows c d))","decl":"theorem le_iff (S T : Subgroupoid C) : S ≤ T ↔ ∀ {c d}, S.arrows c d ⊆ T.arrows c d := by\n  rw [SetLike.le_def, Sigma.forall]; exact forall_congr' fun c => Sigma.forall\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_top","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nc d : C\nf : Quiver.Hom c d\n⊢ Membership.mem (Top.top.arrows c d) f","decl":"theorem mem_top {c d : C} (f : c ⟶ d) : f ∈ (⊤ : Subgroupoid C).arrows c d :=\n  trivial\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_top_objs","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nc : C\n⊢ Membership.mem Top.top.objs c","decl":"theorem mem_top_objs (c : C) : c ∈ (⊤ : Subgroupoid C).objs := by\n  dsimp [Top.top, objs]\n  simp only [univ_nonempty]\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_sInf_arrows","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\ns : Set (CategoryTheory.Subgroupoid C)\nc d : C\np : Quiver.Hom c d\n⊢ Iff (Membership.mem ((InfSet.sInf s).arrows c d) p) (∀ (S : CategoryTheory.Subgroupoid C), Membership.mem s S → Membership.mem (S.arrows c d) p)","decl":"theorem mem_sInf_arrows {s : Set (Subgroupoid C)} {c d : C} {p : c ⟶ d} :\n    p ∈ (sInf s).arrows c d ↔ ∀ S ∈ s, p ∈ S.arrows c d :=\n  mem_iInter₂\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_sInf","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\ns : Set (CategoryTheory.Subgroupoid C)\np : Sigma fun c => Sigma fun d => Quiver.Hom c d\n⊢ Iff (Membership.mem (InfSet.sInf s) p) (∀ (S : CategoryTheory.Subgroupoid C), Membership.mem s S → Membership.mem S p)","decl":"theorem mem_sInf {s : Set (Subgroupoid C)} {p : Σ c d : C, c ⟶ d} :\n    p ∈ sInf s ↔ ∀ S ∈ s, p ∈ S :=\n  mem_sInf_arrows\n\n"}
{"name":"CategoryTheory.Subgroupoid.le_objs","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS T : CategoryTheory.Subgroupoid C\nh : LE.le S T\n⊢ HasSubset.Subset S.objs T.objs","decl":"theorem le_objs {S T : Subgroupoid C} (h : S ≤ T) : S.objs ⊆ T.objs := fun s ⟨γ, hγ⟩ =>\n  ⟨γ, @h ⟨s, s, γ⟩ hγ⟩\n\n"}
{"name":"CategoryTheory.Subgroupoid.inclusion_inj_on_objects","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS T : CategoryTheory.Subgroupoid C\nh : LE.le S T\n⊢ Function.Injective (CategoryTheory.Subgroupoid.inclusion h).obj","decl":"theorem inclusion_inj_on_objects {S T : Subgroupoid C} (h : S ≤ T) :\n    Function.Injective (inclusion h).obj := fun ⟨s, hs⟩ ⟨t, ht⟩ => by\n  simpa only [inclusion, Subtype.mk_eq_mk] using id\n\n"}
{"name":"CategoryTheory.Subgroupoid.inclusion_faithful","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS T : CategoryTheory.Subgroupoid C\nh : LE.le S T\ns t : ↑S.objs\n⊢ Function.Injective fun f => (CategoryTheory.Subgroupoid.inclusion h).map f","decl":"theorem inclusion_faithful {S T : Subgroupoid C} (h : S ≤ T) (s t : S.objs) :\n    Function.Injective fun f : s ⟶ t => (inclusion h).map f := fun ⟨f, hf⟩ ⟨g, hg⟩ => by\n  -- Porting note: was `...; simpa only [Subtype.mk_eq_mk] using id`\n  dsimp only [inclusion]; rw [Subtype.mk_eq_mk, Subtype.mk_eq_mk]; exact id\n\n"}
{"name":"CategoryTheory.Subgroupoid.inclusion_refl","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n⊢ Eq (CategoryTheory.Subgroupoid.inclusion ⋯) (CategoryTheory.Functor.id ↑S.objs)","decl":"theorem inclusion_refl {S : Subgroupoid C} : inclusion (le_refl S) = 𝟭 S.objs :=\n  Functor.hext (fun _ => rfl) fun _ _ _ => HEq.refl _\n\n"}
{"name":"CategoryTheory.Subgroupoid.inclusion_trans","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nR S T : CategoryTheory.Subgroupoid C\nk : LE.le R S\nh : LE.le S T\n⊢ Eq (CategoryTheory.Subgroupoid.inclusion ⋯) ((CategoryTheory.Subgroupoid.inclusion k).comp (CategoryTheory.Subgroupoid.inclusion h))","decl":"theorem inclusion_trans {R S T : Subgroupoid C} (k : R ≤ S) (h : S ≤ T) :\n    inclusion (k.trans h) = inclusion k ⋙ inclusion h :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subgroupoid.inclusion_comp_embedding","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS T : CategoryTheory.Subgroupoid C\nh : LE.le S T\n⊢ Eq ((CategoryTheory.Subgroupoid.inclusion h).comp T.hom) S.hom","decl":"theorem inclusion_comp_embedding {S T : Subgroupoid C} (h : S ≤ T) : inclusion h ⋙ T.hom = S.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_discrete_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nc d : C\nf : Quiver.Hom c d\n⊢ Iff (Membership.mem (CategoryTheory.Subgroupoid.discrete.arrows c d) f) (Exists fun h => Eq f (CategoryTheory.eqToHom h))","decl":"theorem mem_discrete_iff {c d : C} (f : c ⟶ d) :\n    f ∈ discrete.arrows c d ↔ ∃ h : c = d, f = eqToHom h :=\n  ⟨by rintro ⟨⟩; exact ⟨rfl, rfl⟩, by rintro ⟨rfl, rfl⟩; constructor⟩\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsWide.wide","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nself : S.IsWide\nc : C\n⊢ Membership.mem (S.arrows c c) (CategoryTheory.CategoryStruct.id c)","decl":"/-- A subgroupoid is wide if its carrier set is all of `C`-/\nstructure IsWide : Prop where\n  wide : ∀ c, 𝟙 c ∈ S.arrows c c\n\n"}
{"name":"CategoryTheory.Subgroupoid.isWide_iff_objs_eq_univ","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n⊢ Iff S.IsWide (Eq S.objs Set.univ)","decl":"theorem isWide_iff_objs_eq_univ : S.IsWide ↔ S.objs = Set.univ := by\n  constructor\n  · rintro h\n    ext x; constructor <;> simp only [top_eq_univ, mem_univ, imp_true_iff, forall_true_left]\n    apply mem_objs_of_src S (h.wide x)\n  · rintro h\n    refine ⟨fun c => ?_⟩\n    obtain ⟨γ, γS⟩ := (le_of_eq h.symm : ⊤ ⊆ S.objs) (Set.mem_univ c)\n    exact id_mem_of_src S γS\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsWide.id_mem","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nSw : S.IsWide\nc : C\n⊢ Membership.mem (S.arrows c c) (CategoryTheory.CategoryStruct.id c)","decl":"theorem IsWide.id_mem {S : Subgroupoid C} (Sw : S.IsWide) (c : C) : 𝟙 c ∈ S.arrows c c :=\n  Sw.wide c\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsWide.eqToHom_mem","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nSw : S.IsWide\nc d : C\nh : Eq c d\n⊢ Membership.mem (S.arrows c d) (CategoryTheory.eqToHom h)","decl":"theorem IsWide.eqToHom_mem {S : Subgroupoid C} (Sw : S.IsWide) {c d : C} (h : c = d) :\n    eqToHom h ∈ S.arrows c d := by cases h; simp only [eqToHom_refl]; apply Sw.id_mem c\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsNormal.conj","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nself : S.IsNormal\nc d : C\np : Quiver.Hom c d\nγ : Quiver.Hom c c\na✝ : Membership.mem (S.arrows c c) γ\n⊢ Membership.mem (S.arrows d d) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Groupoid.inv p) (CategoryTheory.CategoryStruct.comp γ p))","decl":"/-- A subgroupoid is normal if it is wide and satisfies the expected stability under conjugacy. -/\nstructure IsNormal extends IsWide S : Prop where\n  conj : ∀ {c d} (p : c ⟶ d) {γ : c ⟶ c}, γ ∈ S.arrows c c → Groupoid.inv p ≫ γ ≫ p ∈ S.arrows d d\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsNormal.toIsWide","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nself : S.IsNormal\n⊢ S.IsWide","decl":"/-- A subgroupoid is normal if it is wide and satisfies the expected stability under conjugacy. -/\nstructure IsNormal extends IsWide S : Prop where\n  conj : ∀ {c d} (p : c ⟶ d) {γ : c ⟶ c}, γ ∈ S.arrows c c → Groupoid.inv p ≫ γ ≫ p ∈ S.arrows d d\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsNormal.conj'","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nSn : S.IsNormal\nc d : C\np : Quiver.Hom d c\nγ : Quiver.Hom c c\na✝ : Membership.mem (S.arrows c c) γ\n⊢ Membership.mem (S.arrows d d) (CategoryTheory.CategoryStruct.comp p (CategoryTheory.CategoryStruct.comp γ (CategoryTheory.Groupoid.inv p)))","decl":"theorem IsNormal.conj' {S : Subgroupoid C} (Sn : IsNormal S) :\n    ∀ {c d} (p : d ⟶ c) {γ : c ⟶ c}, γ ∈ S.arrows c c → p ≫ γ ≫ Groupoid.inv p ∈ S.arrows d d :=\n  fun p γ hs => by convert Sn.conj (Groupoid.inv p) hs; simp\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsNormal.conjugation_bij","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nSn : S.IsNormal\nc d : C\np : Quiver.Hom c d\n⊢ Set.BijOn (fun γ => CategoryTheory.CategoryStruct.comp (CategoryTheory.Groupoid.inv p) (CategoryTheory.CategoryStruct.comp γ p)) (S.arrows c c) (S.arrows d d)","decl":"theorem IsNormal.conjugation_bij (Sn : IsNormal S) {c d} (p : c ⟶ d) :\n    Set.BijOn (fun γ : c ⟶ c => Groupoid.inv p ≫ γ ≫ p) (S.arrows c c) (S.arrows d d) := by\n  refine ⟨fun γ γS => Sn.conj p γS, fun γ₁ _ γ₂ _ h => ?_, fun δ δS =>\n    ⟨p ≫ δ ≫ Groupoid.inv p, Sn.conj' p δS, ?_⟩⟩\n  · simpa only [inv_eq_inv, Category.assoc, IsIso.hom_inv_id, Category.comp_id,\n      IsIso.hom_inv_id_assoc] using p ≫= h =≫ inv p\n  · simp only [inv_eq_inv, Category.assoc, IsIso.inv_hom_id, Category.comp_id,\n      IsIso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.Subgroupoid.top_isNormal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\n⊢ Top.top.IsNormal","decl":"theorem top_isNormal : IsNormal (⊤ : Subgroupoid C) :=\n  { wide := fun _ => trivial\n    conj := fun _ _ _ => trivial }\n\n"}
{"name":"CategoryTheory.Subgroupoid.sInf_isNormal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\ns : Set (CategoryTheory.Subgroupoid C)\nsn : ∀ (S : CategoryTheory.Subgroupoid C), Membership.mem s S → S.IsNormal\n⊢ (InfSet.sInf s).IsNormal","decl":"theorem sInf_isNormal (s : Set <| Subgroupoid C) (sn : ∀ S ∈ s, IsNormal S) : IsNormal (sInf s) :=\n  { wide := by simp_rw [sInf, mem_iInter₂]; exact fun c S Ss => (sn S Ss).wide c\n    conj := by simp_rw [sInf, mem_iInter₂]; exact fun p γ hγ S Ss => (sn S Ss).conj p (hγ S Ss) }\n\n"}
{"name":"CategoryTheory.Subgroupoid.discrete_isNormal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\n⊢ CategoryTheory.Subgroupoid.discrete.IsNormal","decl":"theorem discrete_isNormal : (@discrete C _).IsNormal :=\n  { wide := fun c => by constructor\n    conj := fun f γ hγ => by\n      cases hγ\n      simp only [inv_eq_inv, Category.id_comp, IsIso.inv_hom_id]; constructor }\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsNormal.vertexSubgroup","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nSn : S.IsNormal\nc : C\ncS : Membership.mem S.objs c\n⊢ (S.vertexSubgroup cS).Normal","decl":"theorem IsNormal.vertexSubgroup (Sn : IsNormal S) (c : C) (cS : c ∈ S.objs) :\n    (S.vertexSubgroup cS).Normal where\n  conj_mem x hx y := by rw [mul_assoc]; exact Sn.conj' y hx\n\n"}
{"name":"CategoryTheory.Subgroupoid.subset_generated","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nX : (c d : C) → Set (Quiver.Hom c d)\nc d : C\n⊢ HasSubset.Subset (X c d) ((CategoryTheory.Subgroupoid.generated X).arrows c d)","decl":"theorem subset_generated (c d : C) : X c d ⊆ (generated X).arrows c d := by\n  dsimp only [generated, sInf]\n  simp only [subset_iInter₂_iff]\n  exact fun S hS f fS => hS _ _ fS\n\n"}
{"name":"CategoryTheory.Subgroupoid.generated_le_generatedNormal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nX : (c d : C) → Set (Quiver.Hom c d)\n⊢ LE.le (CategoryTheory.Subgroupoid.generated X) (CategoryTheory.Subgroupoid.generatedNormal X)","decl":"theorem generated_le_generatedNormal : generated X ≤ generatedNormal X := by\n  apply @sInf_le_sInf (Subgroupoid C) _\n  exact fun S ⟨h, _⟩ => h\n\n"}
{"name":"CategoryTheory.Subgroupoid.generatedNormal_isNormal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nX : (c d : C) → Set (Quiver.Hom c d)\n⊢ (CategoryTheory.Subgroupoid.generatedNormal X).IsNormal","decl":"theorem generatedNormal_isNormal : (generatedNormal X).IsNormal :=\n  sInf_isNormal _ fun _ h => h.right\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsNormal.generatedNormal_le","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nX : (c d : C) → Set (Quiver.Hom c d)\nS : CategoryTheory.Subgroupoid C\nSn : S.IsNormal\n⊢ Iff (LE.le (CategoryTheory.Subgroupoid.generatedNormal X) S) (∀ (c d : C), HasSubset.Subset (X c d) (S.arrows c d))","decl":"theorem IsNormal.generatedNormal_le {S : Subgroupoid C} (Sn : S.IsNormal) :\n    generatedNormal X ≤ S ↔ ∀ c d, X c d ⊆ S.arrows c d := by\n  constructor\n  · rintro h c d\n    have h' := generated_le_generatedNormal X\n    rw [le_iff] at h h'\n    exact ((subset_generated X c d).trans (@h' c d)).trans (@h c d)\n  · rintro h\n    apply @sInf_le (Subgroupoid C) _\n    exact ⟨h, Sn⟩\n\n"}
{"name":"CategoryTheory.Subgroupoid.comap_mono","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nS T : CategoryTheory.Subgroupoid D\na✝ : LE.le S T\n⊢ LE.le (CategoryTheory.Subgroupoid.comap φ S) (CategoryTheory.Subgroupoid.comap φ T)","decl":"theorem comap_mono (S T : Subgroupoid D) : S ≤ T → comap φ S ≤ comap φ T := fun ST _ =>\n  @ST ⟨_, _, _⟩\n\n"}
{"name":"CategoryTheory.Subgroupoid.isNormal_comap","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nS : CategoryTheory.Subgroupoid D\nSn : S.IsNormal\n⊢ (CategoryTheory.Subgroupoid.comap φ S).IsNormal","decl":"theorem isNormal_comap {S : Subgroupoid D} (Sn : IsNormal S) : IsNormal (comap φ S) where\n  wide c := by rw [comap, mem_setOf, Functor.map_id]; apply Sn.wide\n  conj f γ hγ := by\n    simp_rw [inv_eq_inv f, comap, mem_setOf, Functor.map_comp, Functor.map_inv, ← inv_eq_inv]\n    exact Sn.conj _ hγ\n\n"}
{"name":"CategoryTheory.Subgroupoid.comap_comp","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝¹ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nE : Type u_2\ninst✝ : CategoryTheory.Groupoid E\nψ : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.Subgroupoid.comap (φ.comp ψ)) (Function.comp (CategoryTheory.Subgroupoid.comap φ) (CategoryTheory.Subgroupoid.comap ψ))","decl":"@[simp]\ntheorem comap_comp {E : Type*} [Groupoid E] (ψ : D ⥤ E) : comap (φ ⋙ ψ) = comap φ ∘ comap ψ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_ker_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nc d : C\nf : Quiver.Hom c d\n⊢ Iff (Membership.mem ((CategoryTheory.Subgroupoid.ker φ).arrows c d) f) (Exists fun h => Eq (φ.map f) (CategoryTheory.eqToHom h))","decl":"theorem mem_ker_iff {c d : C} (f : c ⟶ d) :\n    f ∈ (ker φ).arrows c d ↔ ∃ h : φ.obj c = φ.obj d, φ.map f = eqToHom h :=\n  mem_discrete_iff (φ.map f)\n\n"}
{"name":"CategoryTheory.Subgroupoid.ker_isNormal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\n⊢ (CategoryTheory.Subgroupoid.ker φ).IsNormal","decl":"theorem ker_isNormal : (ker φ).IsNormal :=\n  isNormal_comap φ discrete_isNormal\n\n"}
{"name":"CategoryTheory.Subgroupoid.ker_comp","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝¹ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nE : Type u_2\ninst✝ : CategoryTheory.Groupoid E\nψ : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.Subgroupoid.ker (φ.comp ψ)) (CategoryTheory.Subgroupoid.comap φ (CategoryTheory.Subgroupoid.ker ψ))","decl":"@[simp]\ntheorem ker_comp {E : Type*} [Groupoid E] (ψ : D ⥤ E) : ker (φ ⋙ ψ) = comap φ (ker ψ) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subgroupoid.Map.arrows_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nhφ : Function.Injective φ.obj\nS : CategoryTheory.Subgroupoid C\nc d : D\nf : Quiver.Hom c d\n⊢ Iff (CategoryTheory.Subgroupoid.Map.Arrows φ hφ S c d f) (Exists fun a => Exists fun b => Exists fun g => Exists fun ha => Exists fun hb => Exists fun _hg => Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp (φ.map g) (CategoryTheory.eqToHom hb))))","decl":"theorem Map.arrows_iff (hφ : Function.Injective φ.obj) (S : Subgroupoid C) {c d : D} (f : c ⟶ d) :\n    Map.Arrows φ hφ S c d f ↔\n      ∃ (a b : C) (g : a ⟶ b) (ha : φ.obj a = c) (hb : φ.obj b = d) (_hg : g ∈ S.arrows a b),\n        f = eqToHom ha.symm ≫ φ.map g ≫ eqToHom hb := by\n  constructor\n  · rintro ⟨g, hg⟩; exact ⟨_, _, g, rfl, rfl, hg, eq_conj_eqToHom _⟩\n  · rintro ⟨a, b, g, rfl, rfl, hg, rfl⟩; rw [← eq_conj_eqToHom]; constructor; exact hg\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_map_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nhφ : Function.Injective φ.obj\nS : CategoryTheory.Subgroupoid C\nc d : D\nf : Quiver.Hom c d\n⊢ Iff (Membership.mem ((CategoryTheory.Subgroupoid.map φ hφ S).arrows c d) f) (Exists fun a => Exists fun b => Exists fun g => Exists fun ha => Exists fun hb => Exists fun _hg => Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp (φ.map g) (CategoryTheory.eqToHom hb))))","decl":"theorem mem_map_iff (hφ : Function.Injective φ.obj) (S : Subgroupoid C) {c d : D} (f : c ⟶ d) :\n    f ∈ (map φ hφ S).arrows c d ↔\n      ∃ (a b : C) (g : a ⟶ b) (ha : φ.obj a = c) (hb : φ.obj b = d) (_hg : g ∈ S.arrows a b),\n        f = eqToHom ha.symm ≫ φ.map g ≫ eqToHom hb :=\n  Map.arrows_iff φ hφ S f\n\n"}
{"name":"CategoryTheory.Subgroupoid.galoisConnection_map_comap","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nhφ : Function.Injective φ.obj\n⊢ GaloisConnection (CategoryTheory.Subgroupoid.map φ hφ) (CategoryTheory.Subgroupoid.comap φ)","decl":"theorem galoisConnection_map_comap (hφ : Function.Injective φ.obj) :\n    GaloisConnection (map φ hφ) (comap φ) := by\n  rintro S T; simp_rw [le_iff]; constructor\n  · exact fun h c d f fS => h (Map.Arrows.im f fS)\n  · rintro h _ _ g ⟨a, gφS⟩\n    exact h gφS\n\n"}
{"name":"CategoryTheory.Subgroupoid.map_mono","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nhφ : Function.Injective φ.obj\nS T : CategoryTheory.Subgroupoid C\na✝ : LE.le S T\n⊢ LE.le (CategoryTheory.Subgroupoid.map φ hφ S) (CategoryTheory.Subgroupoid.map φ hφ T)","decl":"theorem map_mono (hφ : Function.Injective φ.obj) (S T : Subgroupoid C) :\n    S ≤ T → map φ hφ S ≤ map φ hφ T := fun h => (galoisConnection_map_comap φ hφ).monotone_l h\n\n"}
{"name":"CategoryTheory.Subgroupoid.le_comap_map","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nhφ : Function.Injective φ.obj\nS : CategoryTheory.Subgroupoid C\n⊢ LE.le S (CategoryTheory.Subgroupoid.comap φ (CategoryTheory.Subgroupoid.map φ hφ S))","decl":"theorem le_comap_map (hφ : Function.Injective φ.obj) (S : Subgroupoid C) :\n    S ≤ comap φ (map φ hφ S) :=\n  (galoisConnection_map_comap φ hφ).le_u_l S\n\n"}
{"name":"CategoryTheory.Subgroupoid.map_comap_le","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nhφ : Function.Injective φ.obj\nT : CategoryTheory.Subgroupoid D\n⊢ LE.le (CategoryTheory.Subgroupoid.map φ hφ (CategoryTheory.Subgroupoid.comap φ T)) T","decl":"theorem map_comap_le (hφ : Function.Injective φ.obj) (T : Subgroupoid D) :\n    map φ hφ (comap φ T) ≤ T :=\n  (galoisConnection_map_comap φ hφ).l_u_le T\n\n"}
{"name":"CategoryTheory.Subgroupoid.map_le_iff_le_comap","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nhφ : Function.Injective φ.obj\nS : CategoryTheory.Subgroupoid C\nT : CategoryTheory.Subgroupoid D\n⊢ Iff (LE.le (CategoryTheory.Subgroupoid.map φ hφ S) T) (LE.le S (CategoryTheory.Subgroupoid.comap φ T))","decl":"theorem map_le_iff_le_comap (hφ : Function.Injective φ.obj) (S : Subgroupoid C)\n    (T : Subgroupoid D) : map φ hφ S ≤ T ↔ S ≤ comap φ T :=\n  (galoisConnection_map_comap φ hφ).le_iff_le\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_map_objs_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nhφ : Function.Injective φ.obj\nd : D\n⊢ Iff (Membership.mem (CategoryTheory.Subgroupoid.map φ hφ S).objs d) (Exists fun c => And (Membership.mem S.objs c) (Eq (φ.obj c) d))","decl":"theorem mem_map_objs_iff (hφ : Function.Injective φ.obj) (d : D) :\n    d ∈ (map φ hφ S).objs ↔ ∃ c ∈ S.objs, φ.obj c = d := by\n  dsimp [objs, map]\n  constructor\n  · rintro ⟨f, hf⟩\n    change Map.Arrows φ hφ S d d f at hf; rw [Map.arrows_iff] at hf\n    obtain ⟨c, d, g, ec, ed, eg, gS, eg⟩ := hf\n    exact ⟨c, ⟨mem_objs_of_src S eg, ec⟩⟩\n  · rintro ⟨c, ⟨γ, γS⟩, rfl⟩\n    exact ⟨φ.map γ, ⟨γ, γS⟩⟩\n\n"}
{"name":"CategoryTheory.Subgroupoid.map_objs_eq","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nhφ : Function.Injective φ.obj\n⊢ Eq (CategoryTheory.Subgroupoid.map φ hφ S).objs (Set.image φ.obj S.objs)","decl":"@[simp]\ntheorem map_objs_eq (hφ : Function.Injective φ.obj) : (map φ hφ S).objs = φ.obj '' S.objs := by\n  ext x; convert mem_map_objs_iff S φ hφ x\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_im_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nhφ : Function.Injective φ.obj\nc d : D\nf : Quiver.Hom c d\n⊢ Iff (Membership.mem ((CategoryTheory.Subgroupoid.im φ hφ).arrows c d) f) (Exists fun a => Exists fun b => Exists fun g => Exists fun ha => Exists fun hb => Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp (φ.map g) (CategoryTheory.eqToHom hb))))","decl":"theorem mem_im_iff (hφ : Function.Injective φ.obj) {c d : D} (f : c ⟶ d) :\n    f ∈ (im φ hφ).arrows c d ↔\n      ∃ (a b : C) (g : a ⟶ b) (ha : φ.obj a = c) (hb : φ.obj b = d),\n        f = eqToHom ha.symm ≫ φ.map g ≫ eqToHom hb := by\n  convert Map.arrows_iff φ hφ ⊤ f; simp only [Top.top, mem_univ, exists_true_left]\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_im_objs_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nhφ : Function.Injective φ.obj\nd : D\n⊢ Iff (Membership.mem (CategoryTheory.Subgroupoid.im φ hφ).objs d) (Exists fun c => Eq (φ.obj c) d)","decl":"theorem mem_im_objs_iff (hφ : Function.Injective φ.obj) (d : D) :\n    d ∈ (im φ hφ).objs ↔ ∃ c : C, φ.obj c = d := by\n  simp only [im, mem_map_objs_iff, mem_top_objs, true_and]\n\n"}
{"name":"CategoryTheory.Subgroupoid.obj_surjective_of_im_eq_top","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nhφ : Function.Injective φ.obj\nhφ' : Eq (CategoryTheory.Subgroupoid.im φ hφ) Top.top\n⊢ Function.Surjective φ.obj","decl":"theorem obj_surjective_of_im_eq_top (hφ : Function.Injective φ.obj) (hφ' : im φ hφ = ⊤) :\n    Function.Surjective φ.obj := by\n  rintro d\n  rw [← mem_im_objs_iff, hφ']\n  apply mem_top_objs\n\n"}
{"name":"CategoryTheory.Subgroupoid.isNormal_map","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nD : Type u_1\ninst✝ : CategoryTheory.Groupoid D\nφ : CategoryTheory.Functor C D\nhφ : Function.Injective φ.obj\nhφ' : Eq (CategoryTheory.Subgroupoid.im φ hφ) Top.top\nSn : S.IsNormal\n⊢ (CategoryTheory.Subgroupoid.map φ hφ S).IsNormal","decl":"theorem isNormal_map (hφ : Function.Injective φ.obj) (hφ' : im φ hφ = ⊤) (Sn : S.IsNormal) :\n    (map φ hφ S).IsNormal :=\n  { wide := fun d => by\n      obtain ⟨c, rfl⟩ := obj_surjective_of_im_eq_top φ hφ hφ' d\n      change Map.Arrows φ hφ S _ _ (𝟙 _); rw [← Functor.map_id]\n      constructor; exact Sn.wide c\n    conj := fun {d d'} g δ hδ => by\n      rw [mem_map_iff] at hδ\n      obtain ⟨c, c', γ, cd, cd', γS, hγ⟩ := hδ; subst_vars; cases hφ cd'\n      have : d' ∈ (im φ hφ).objs := by rw [hφ']; apply mem_top_objs\n      rw [mem_im_objs_iff] at this\n      obtain ⟨c', rfl⟩ := this\n      have : g ∈ (im φ hφ).arrows (φ.obj c) (φ.obj c') := by rw [hφ']; trivial\n      rw [mem_im_iff] at this\n      obtain ⟨b, b', f, hb, hb', _, hf⟩ := this; cases hφ hb; cases hφ hb'\n      change Map.Arrows φ hφ S (φ.obj c') (φ.obj c') _\n      simp only [eqToHom_refl, Category.comp_id, Category.id_comp, inv_eq_inv]\n      suffices Map.Arrows φ hφ S (φ.obj c') (φ.obj c') (φ.map <| Groupoid.inv f ≫ γ ≫ f) by\n        simp only [inv_eq_inv, Functor.map_comp, Functor.map_inv] at this; exact this\n      constructor; apply Sn.conj f γS }\n\n"}
{"name":"CategoryTheory.Subgroupoid.isThin_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n⊢ Iff S.IsThin (∀ (c : ↑S.objs), Subsingleton ↑(S.arrows ↑c ↑c))","decl":"nonrec theorem isThin_iff : S.IsThin ↔ ∀ c : S.objs, Subsingleton (S.arrows c c) := isThin_iff _\n\n"}
{"name":"CategoryTheory.Subgroupoid.isTotallyDisconnected_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n⊢ Iff S.IsTotallyDisconnected (∀ (c d : C), (S.arrows c d).Nonempty → Eq c d)","decl":"theorem isTotallyDisconnected_iff :\n    S.IsTotallyDisconnected ↔ ∀ c d, (S.arrows c d).Nonempty → c = d := by\n  constructor\n  · rintro h c d ⟨f, fS⟩\n    exact congr_arg Subtype.val <| h ⟨c, mem_objs_of_src S fS⟩ ⟨d, mem_objs_of_tgt S fS⟩ ⟨f, fS⟩\n  · rintro h ⟨c, hc⟩ ⟨d, hd⟩ ⟨f, fS⟩\n    simp only [Subtype.mk_eq_mk]\n    exact h c d ⟨f, fS⟩\n\n"}
{"name":"CategoryTheory.Subgroupoid.disconnect_le","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n⊢ LE.le S.disconnect S","decl":"theorem disconnect_le : S.disconnect ≤ S := by rw [le_iff]; rintro _ _ _ ⟨⟩; assumption\n\n"}
{"name":"CategoryTheory.Subgroupoid.disconnect_normal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nSn : S.IsNormal\n⊢ S.disconnect.IsNormal","decl":"theorem disconnect_normal (Sn : S.IsNormal) : S.disconnect.IsNormal :=\n  { wide := fun c => ⟨rfl, Sn.wide c⟩\n    conj := fun _ _ ⟨_, h'⟩ => ⟨rfl, Sn.conj _ h'⟩ }\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_disconnect_objs_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc : C\n⊢ Iff (Membership.mem S.disconnect.objs c) (Membership.mem S.objs c)","decl":"@[simp]\ntheorem mem_disconnect_objs_iff {c : C} : c ∈ S.disconnect.objs ↔ c ∈ S.objs :=\n  ⟨fun ⟨γ, _, γS⟩ => ⟨γ, γS⟩, fun ⟨γ, γS⟩ => ⟨γ, rfl, γS⟩⟩\n\n"}
{"name":"CategoryTheory.Subgroupoid.disconnect_objs","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n⊢ Eq S.disconnect.objs S.objs","decl":"theorem disconnect_objs : S.disconnect.objs = S.objs := Set.ext fun _ ↦ mem_disconnect_objs_iff _\n\n"}
{"name":"CategoryTheory.Subgroupoid.disconnect_isTotallyDisconnected","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n⊢ S.disconnect.IsTotallyDisconnected","decl":"theorem disconnect_isTotallyDisconnected : S.disconnect.IsTotallyDisconnected := by\n  rw [isTotallyDisconnected_iff]; exact fun c d ⟨_, h, _⟩ => h\n\n"}
{"name":"CategoryTheory.Subgroupoid.full_objs","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nD : Set C\n⊢ Eq (CategoryTheory.Subgroupoid.full D).objs D","decl":"theorem full_objs : (full D).objs = D :=\n  Set.ext fun _ => ⟨fun ⟨_, h, _⟩ => h, fun h => ⟨𝟙 _, h, h⟩⟩\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_full_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nD : Set C\nc d : C\nf : Quiver.Hom c d\n⊢ Iff (Membership.mem ((CategoryTheory.Subgroupoid.full D).arrows c d) f) (And (Membership.mem D c) (Membership.mem D d))","decl":"@[simp]\ntheorem mem_full_iff {c d : C} {f : c ⟶ d} : f ∈ (full D).arrows c d ↔ c ∈ D ∧ d ∈ D :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_full_objs_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nD : Set C\nc : C\n⊢ Iff (Membership.mem (CategoryTheory.Subgroupoid.full D).objs c) (Membership.mem D c)","decl":"@[simp]\ntheorem mem_full_objs_iff {c : C} : c ∈ (full D).objs ↔ c ∈ D := by rw [full_objs]\n\n"}
{"name":"CategoryTheory.Subgroupoid.full_empty","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\n⊢ Eq (CategoryTheory.Subgroupoid.full EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem full_empty : full ∅ = (⊥ : Subgroupoid C) := by\n  ext\n  simp only [Bot.bot, mem_full_iff, mem_empty_iff_false, and_self_iff]\n\n"}
{"name":"CategoryTheory.Subgroupoid.full_univ","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\n⊢ Eq (CategoryTheory.Subgroupoid.full Set.univ) Top.top","decl":"@[simp]\ntheorem full_univ : full Set.univ = (⊤ : Subgroupoid C) := by\n  ext\n  simp only [mem_full_iff, mem_univ, and_self, mem_top]\n\n"}
{"name":"CategoryTheory.Subgroupoid.full_mono","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nD E : Set C\nh : LE.le D E\n⊢ LE.le (CategoryTheory.Subgroupoid.full D) (CategoryTheory.Subgroupoid.full E)","decl":"theorem full_mono {D E : Set C} (h : D ≤ E) : full D ≤ full E := by\n  rw [le_iff]\n  rintro c d f\n  simp only [mem_full_iff]\n  exact fun ⟨hc, hd⟩ => ⟨h hc, h hd⟩\n\n-- Porting note: using `.1` instead of `↑`\n"}
{"name":"CategoryTheory.Subgroupoid.full_arrow_eq_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\nD : Set C\nc d : ↑(CategoryTheory.Subgroupoid.full D).objs\nf g : Quiver.Hom c d\n⊢ Iff (Eq f g) (Eq ↑f ↑g)","decl":"theorem full_arrow_eq_iff {c d : (full D).objs} {f g : c ⟶ d} :\n    f = g ↔ (f.1 : c.val ⟶ d.val) = g.1 :=\n  Subtype.ext_iff\n\n"}
