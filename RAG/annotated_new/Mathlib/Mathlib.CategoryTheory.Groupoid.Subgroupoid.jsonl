{"name":"CategoryTheory.Subgroupoid.mk.inj","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\narrows‚úù : (c d : C) ‚Üí Set (Quiver.Hom c d)\ninv‚úù : ‚àÄ {c d : C} {p : Quiver.Hom c d}, Membership.mem (arrows‚úù c d) p ‚Üí Membership.mem (arrows‚úù d c) (CategoryTheory.Groupoid.inv p)\nmul‚úù : ‚àÄ {c d e : C} {p : Quiver.Hom c d}, Membership.mem (arrows‚úù c d) p ‚Üí ‚àÄ {q : Quiver.Hom d e}, Membership.mem (arrows‚úù d e) q ‚Üí Membership.mem (arrows‚úù c e) (CategoryTheory.CategoryStruct.comp p q)\narrows : (c d : C) ‚Üí Set (Quiver.Hom c d)\ninv : ‚àÄ {c d : C} {p : Quiver.Hom c d}, Membership.mem (arrows c d) p ‚Üí Membership.mem (arrows d c) (CategoryTheory.Groupoid.inv p)\nmul : ‚àÄ {c d e : C} {p : Quiver.Hom c d}, Membership.mem (arrows c d) p ‚Üí ‚àÄ {q : Quiver.Hom d e}, Membership.mem (arrows d e) q ‚Üí Membership.mem (arrows c e) (CategoryTheory.CategoryStruct.comp p q)\nx‚úù : Eq { arrows := arrows‚úù, inv := inv‚úù, mul := mul‚úù } { arrows := arrows, inv := inv, mul := mul }\n‚ä¢ Eq arrows‚úù arrows","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ‚àÄ c d : C, Set (c ‚ü∂ d)\n  protected inv : ‚àÄ {c d} {p : c ‚ü∂ d}, p ‚àà arrows c d ‚Üí Groupoid.inv p ‚àà arrows d c\n  protected mul : ‚àÄ {c d e} {p}, p ‚àà arrows c d ‚Üí ‚àÄ {q}, q ‚àà arrows d e ‚Üí p ‚â´ q ‚àà arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.ext","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nx y : CategoryTheory.Subgroupoid C\narrows : Eq x.arrows y.arrows\n‚ä¢ Eq x y","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ‚àÄ c d : C, Set (c ‚ü∂ d)\n  protected inv : ‚àÄ {c d} {p : c ‚ü∂ d}, p ‚àà arrows c d ‚Üí Groupoid.inv p ‚àà arrows d c\n  protected mul : ‚àÄ {c d e} {p}, p ‚àà arrows c d ‚Üí ‚àÄ {q}, q ‚àà arrows d e ‚Üí p ‚â´ q ‚àà arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.mk.injEq","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\narrows‚úù : (c d : C) ‚Üí Set (Quiver.Hom c d)\ninv‚úù : ‚àÄ {c d : C} {p : Quiver.Hom c d}, Membership.mem (arrows‚úù c d) p ‚Üí Membership.mem (arrows‚úù d c) (CategoryTheory.Groupoid.inv p)\nmul‚úù : ‚àÄ {c d e : C} {p : Quiver.Hom c d}, Membership.mem (arrows‚úù c d) p ‚Üí ‚àÄ {q : Quiver.Hom d e}, Membership.mem (arrows‚úù d e) q ‚Üí Membership.mem (arrows‚úù c e) (CategoryTheory.CategoryStruct.comp p q)\narrows : (c d : C) ‚Üí Set (Quiver.Hom c d)\ninv : ‚àÄ {c d : C} {p : Quiver.Hom c d}, Membership.mem (arrows c d) p ‚Üí Membership.mem (arrows d c) (CategoryTheory.Groupoid.inv p)\nmul : ‚àÄ {c d e : C} {p : Quiver.Hom c d}, Membership.mem (arrows c d) p ‚Üí ‚àÄ {q : Quiver.Hom d e}, Membership.mem (arrows d e) q ‚Üí Membership.mem (arrows c e) (CategoryTheory.CategoryStruct.comp p q)\n‚ä¢ Eq (Eq { arrows := arrows‚úù, inv := inv‚úù, mul := mul‚úù } { arrows := arrows, inv := inv, mul := mul }) (Eq arrows‚úù arrows)","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ‚àÄ c d : C, Set (c ‚ü∂ d)\n  protected inv : ‚àÄ {c d} {p : c ‚ü∂ d}, p ‚àà arrows c d ‚Üí Groupoid.inv p ‚àà arrows d c\n  protected mul : ‚àÄ {c d e} {p}, p ‚àà arrows c d ‚Üí ‚àÄ {q}, q ‚àà arrows d e ‚Üí p ‚â´ q ‚àà arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.ext_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nx y : CategoryTheory.Subgroupoid C\n‚ä¢ Iff (Eq x y) (Eq x.arrows y.arrows)","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ‚àÄ c d : C, Set (c ‚ü∂ d)\n  protected inv : ‚àÄ {c d} {p : c ‚ü∂ d}, p ‚àà arrows c d ‚Üí Groupoid.inv p ‚àà arrows d c\n  protected mul : ‚àÄ {c d e} {p}, p ‚àà arrows c d ‚Üí ‚àÄ {q}, q ‚àà arrows d e ‚Üí p ‚â´ q ‚àà arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.mul","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nself : CategoryTheory.Subgroupoid C\nc d e : C\np : Quiver.Hom c d\na‚úù¬π : Membership.mem (self.arrows c d) p\nq : Quiver.Hom d e\na‚úù : Membership.mem (self.arrows d e) q\n‚ä¢ Membership.mem (self.arrows c e) (CategoryTheory.CategoryStruct.comp p q)","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ‚àÄ c d : C, Set (c ‚ü∂ d)\n  protected inv : ‚àÄ {c d} {p : c ‚ü∂ d}, p ‚àà arrows c d ‚Üí Groupoid.inv p ‚àà arrows d c\n  protected mul : ‚àÄ {c d e} {p}, p ‚àà arrows c d ‚Üí ‚àÄ {q}, q ‚àà arrows d e ‚Üí p ‚â´ q ‚àà arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.inv","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nself : CategoryTheory.Subgroupoid C\nc d : C\np : Quiver.Hom c d\na‚úù : Membership.mem (self.arrows c d) p\n‚ä¢ Membership.mem (self.arrows d c) (CategoryTheory.Groupoid.inv p)","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ‚àÄ c d : C, Set (c ‚ü∂ d)\n  protected inv : ‚àÄ {c d} {p : c ‚ü∂ d}, p ‚àà arrows c d ‚Üí Groupoid.inv p ‚àà arrows d c\n  protected mul : ‚àÄ {c d e} {p}, p ‚àà arrows c d ‚Üí ‚àÄ {q}, q ‚àà arrows d e ‚Üí p ‚â´ q ‚àà arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\ninst‚úù : SizeOf C\narrows : (c d : C) ‚Üí Set (Quiver.Hom c d)\ninv : ‚àÄ {c d : C} {p : Quiver.Hom c d}, Membership.mem (arrows c d) p ‚Üí Membership.mem (arrows d c) (CategoryTheory.Groupoid.inv p)\nmul : ‚àÄ {c d e : C} {p : Quiver.Hom c d}, Membership.mem (arrows c d) p ‚Üí ‚àÄ {q : Quiver.Hom d e}, Membership.mem (arrows d e) q ‚Üí Membership.mem (arrows c e) (CategoryTheory.CategoryStruct.comp p q)\n‚ä¢ Eq (SizeOf.sizeOf { arrows := arrows, inv := inv, mul := mul }) 1","decl":"/-- A sugroupoid of `C` consists of a choice of arrows for each pair of vertices, closed\nunder composition and inverses.\n-/\n@[ext]\nstructure Subgroupoid (C : Type u) [Groupoid C] where\n  arrows : ‚àÄ c d : C, Set (c ‚ü∂ d)\n  protected inv : ‚àÄ {c d} {p : c ‚ü∂ d}, p ‚àà arrows c d ‚Üí Groupoid.inv p ‚àà arrows d c\n  protected mul : ‚àÄ {c d e} {p}, p ‚àà arrows c d ‚Üí ‚àÄ {q}, q ‚àà arrows d e ‚Üí p ‚â´ q ‚àà arrows c e\n\n"}
{"name":"CategoryTheory.Subgroupoid.inv_mem_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : C\nf : Quiver.Hom c d\n‚ä¢ Iff (Membership.mem (S.arrows d c) (CategoryTheory.Groupoid.inv f)) (Membership.mem (S.arrows c d) f)","decl":"theorem inv_mem_iff {c d : C} (f : c ‚ü∂ d) :\n    Groupoid.inv f ‚àà S.arrows d c ‚Üî f ‚àà S.arrows c d := by\n  constructor\n  ¬∑ intro h\n    simpa only [inv_eq_inv, IsIso.inv_inv] using S.inv h\n  ¬∑ apply S.inv\n\n"}
{"name":"CategoryTheory.Subgroupoid.mul_mem_cancel_left","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d e : C\nf : Quiver.Hom c d\ng : Quiver.Hom d e\nhf : Membership.mem (S.arrows c d) f\n‚ä¢ Iff (Membership.mem (S.arrows c e) (CategoryTheory.CategoryStruct.comp f g)) (Membership.mem (S.arrows d e) g)","decl":"theorem mul_mem_cancel_left {c d e : C} {f : c ‚ü∂ d} {g : d ‚ü∂ e} (hf : f ‚àà S.arrows c d) :\n    f ‚â´ g ‚àà S.arrows c e ‚Üî g ‚àà S.arrows d e := by\n  constructor\n  ¬∑ rintro h\n    suffices Groupoid.inv f ‚â´ f ‚â´ g ‚àà S.arrows d e by\n      simpa only [inv_eq_inv, IsIso.inv_hom_id_assoc] using this\n    apply S.mul (S.inv hf) h\n  ¬∑ apply S.mul hf\n\n"}
{"name":"CategoryTheory.Subgroupoid.mul_mem_cancel_right","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d e : C\nf : Quiver.Hom c d\ng : Quiver.Hom d e\nhg : Membership.mem (S.arrows d e) g\n‚ä¢ Iff (Membership.mem (S.arrows c e) (CategoryTheory.CategoryStruct.comp f g)) (Membership.mem (S.arrows c d) f)","decl":"theorem mul_mem_cancel_right {c d e : C} {f : c ‚ü∂ d} {g : d ‚ü∂ e} (hg : g ‚àà S.arrows d e) :\n    f ‚â´ g ‚àà S.arrows c e ‚Üî f ‚àà S.arrows c d := by\n  constructor\n  ¬∑ rintro h\n    suffices (f ‚â´ g) ‚â´ Groupoid.inv g ‚àà S.arrows c d by\n      simpa only [inv_eq_inv, IsIso.hom_inv_id, Category.comp_id, Category.assoc] using this\n    apply S.mul h (S.inv hg)\n  ¬∑ exact fun hf => S.mul hf hg\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_objs_of_src","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : C\nf : Quiver.Hom c d\nh : Membership.mem (S.arrows c d) f\n‚ä¢ Membership.mem S.objs c","decl":"theorem mem_objs_of_src {c d : C} {f : c ‚ü∂ d} (h : f ‚àà S.arrows c d) : c ‚àà S.objs :=\n  ‚ü®f ‚â´ Groupoid.inv f, S.mul h (S.inv h)‚ü©\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_objs_of_tgt","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : C\nf : Quiver.Hom c d\nh : Membership.mem (S.arrows c d) f\n‚ä¢ Membership.mem S.objs d","decl":"theorem mem_objs_of_tgt {c d : C} {f : c ‚ü∂ d} (h : f ‚àà S.arrows c d) : d ‚àà S.objs :=\n  ‚ü®Groupoid.inv f ‚â´ f, S.mul (S.inv h) h‚ü©\n\n"}
{"name":"CategoryTheory.Subgroupoid.id_mem_of_nonempty_isotropy","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc : C\na‚úù : Membership.mem S.objs c\n‚ä¢ Membership.mem (S.arrows c c) (CategoryTheory.CategoryStruct.id c)","decl":"theorem id_mem_of_nonempty_isotropy (c : C) : c ‚àà objs S ‚Üí ùüô c ‚àà S.arrows c c := by\n  rintro ‚ü®Œ≥, hŒ≥‚ü©\n  convert S.mul hŒ≥ (S.inv hŒ≥)\n  simp only [inv_eq_inv, IsIso.hom_inv_id]\n\n"}
{"name":"CategoryTheory.Subgroupoid.id_mem_of_src","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : C\nf : Quiver.Hom c d\nh : Membership.mem (S.arrows c d) f\n‚ä¢ Membership.mem (S.arrows c c) (CategoryTheory.CategoryStruct.id c)","decl":"theorem id_mem_of_src {c d : C} {f : c ‚ü∂ d} (h : f ‚àà S.arrows c d) : ùüô c ‚àà S.arrows c c :=\n  id_mem_of_nonempty_isotropy S c (mem_objs_of_src S h)\n\n"}
{"name":"CategoryTheory.Subgroupoid.id_mem_of_tgt","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : C\nf : Quiver.Hom c d\nh : Membership.mem (S.arrows c d) f\n‚ä¢ Membership.mem (S.arrows d d) (CategoryTheory.CategoryStruct.id d)","decl":"theorem id_mem_of_tgt {c d : C} {f : c ‚ü∂ d} (h : f ‚àà S.arrows c d) : ùüô d ‚àà S.arrows d d :=\n  id_mem_of_nonempty_isotropy S d (mem_objs_of_tgt S h)\n\n"}
{"name":"CategoryTheory.Subgroupoid.coe_inv_coe","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nX‚úù Y‚úù : ‚ÜëS.objs\np : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (‚Üë(CategoryTheory.Groupoid.inv p)) (CategoryTheory.Groupoid.inv ‚Üëp)","decl":"/-- The coercion of a subgroupoid as a groupoid -/\n@[simps comp_coe, simps (config := .lemmasOnly) inv_coe]\ninstance coe : Groupoid S.objs where\n  Hom a b := S.arrows a.val b.val\n  id a := ‚ü®ùüô a.val, id_mem_of_nonempty_isotropy S a.val a.prop‚ü©\n  comp p q := ‚ü®p.val ‚â´ q.val, S.mul p.prop q.prop‚ü©\n  inv p := ‚ü®Groupoid.inv p.val, S.inv p.prop‚ü©\n\n"}
{"name":"CategoryTheory.Subgroupoid.coe_comp_coe","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nX‚úù Y‚úù Z‚úù : ‚ÜëS.objs\np : Quiver.Hom X‚úù Y‚úù\nq : Quiver.Hom Y‚úù Z‚úù\n‚ä¢ Eq (‚Üë(CategoryTheory.CategoryStruct.comp p q)) (CategoryTheory.CategoryStruct.comp ‚Üëp ‚Üëq)","decl":"/-- The coercion of a subgroupoid as a groupoid -/\n@[simps comp_coe, simps (config := .lemmasOnly) inv_coe]\ninstance coe : Groupoid S.objs where\n  Hom a b := S.arrows a.val b.val\n  id a := ‚ü®ùüô a.val, id_mem_of_nonempty_isotropy S a.val a.prop‚ü©\n  comp p q := ‚ü®p.val ‚â´ q.val, S.mul p.prop q.prop‚ü©\n  inv p := ‚ü®Groupoid.inv p.val, S.inv p.prop‚ü©\n\n"}
{"name":"CategoryTheory.Subgroupoid.coe_inv_coe'","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : ‚ÜëS.objs\np : Quiver.Hom c d\n‚ä¢ Eq (‚Üë(CategoryTheory.inv p)) (CategoryTheory.inv ‚Üëp)","decl":"@[simp]\ntheorem coe_inv_coe' {c d : S.objs} (p : c ‚ü∂ d) :\n    (CategoryTheory.inv p).val = CategoryTheory.inv p.val := by\n  simp only [‚Üê inv_eq_inv, coe_inv_coe]\n\n"}
{"name":"CategoryTheory.Subgroupoid.hom.inj_on_objects","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n‚ä¢ Function.Injective S.hom.obj","decl":"theorem hom.inj_on_objects : Function.Injective (hom S).obj := by\n  rintro ‚ü®c, hc‚ü© ‚ü®d, hd‚ü© hcd\n  simp only [Subtype.mk_eq_mk]; exact hcd\n\n"}
{"name":"CategoryTheory.Subgroupoid.hom.faithful","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc d : ‚ÜëS.objs\n‚ä¢ Function.Injective fun f => S.hom.map f","decl":"theorem hom.faithful : ‚àÄ c d, Function.Injective fun f : c ‚ü∂ d => (hom S).map f := by\n  rintro ‚ü®c, hc‚ü© ‚ü®d, hd‚ü© ‚ü®f, hf‚ü© ‚ü®g, hg‚ü© hfg; exact Subtype.eq hfg\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nF : Sigma fun c => Sigma fun d => Quiver.Hom c d\n‚ä¢ Iff (Membership.mem S F) (Membership.mem (S.arrows F.fst F.snd.fst) F.snd.snd)","decl":"theorem mem_iff (S : Subgroupoid C) (F : Œ£ c d, c ‚ü∂ d) : F ‚àà S ‚Üî F.2.2 ‚àà S.arrows F.1 F.2.1 :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.Subgroupoid.le_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS T : CategoryTheory.Subgroupoid C\n‚ä¢ Iff (LE.le S T) (‚àÄ {c d : C}, HasSubset.Subset (S.arrows c d) (T.arrows c d))","decl":"theorem le_iff (S T : Subgroupoid C) : S ‚â§ T ‚Üî ‚àÄ {c d}, S.arrows c d ‚äÜ T.arrows c d := by\n  rw [SetLike.le_def, Sigma.forall]; exact forall_congr' fun c => Sigma.forall\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_top","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nc d : C\nf : Quiver.Hom c d\n‚ä¢ Membership.mem (Top.top.arrows c d) f","decl":"theorem mem_top {c d : C} (f : c ‚ü∂ d) : f ‚àà (‚ä§ : Subgroupoid C).arrows c d :=\n  trivial\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_top_objs","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nc : C\n‚ä¢ Membership.mem Top.top.objs c","decl":"theorem mem_top_objs (c : C) : c ‚àà (‚ä§ : Subgroupoid C).objs := by\n  dsimp [Top.top, objs]\n  simp only [univ_nonempty]\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_sInf_arrows","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\ns : Set (CategoryTheory.Subgroupoid C)\nc d : C\np : Quiver.Hom c d\n‚ä¢ Iff (Membership.mem ((InfSet.sInf s).arrows c d) p) (‚àÄ (S : CategoryTheory.Subgroupoid C), Membership.mem s S ‚Üí Membership.mem (S.arrows c d) p)","decl":"theorem mem_sInf_arrows {s : Set (Subgroupoid C)} {c d : C} {p : c ‚ü∂ d} :\n    p ‚àà (sInf s).arrows c d ‚Üî ‚àÄ S ‚àà s, p ‚àà S.arrows c d :=\n  mem_iInter‚ÇÇ\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_sInf","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\ns : Set (CategoryTheory.Subgroupoid C)\np : Sigma fun c => Sigma fun d => Quiver.Hom c d\n‚ä¢ Iff (Membership.mem (InfSet.sInf s) p) (‚àÄ (S : CategoryTheory.Subgroupoid C), Membership.mem s S ‚Üí Membership.mem S p)","decl":"theorem mem_sInf {s : Set (Subgroupoid C)} {p : Œ£ c d : C, c ‚ü∂ d} :\n    p ‚àà sInf s ‚Üî ‚àÄ S ‚àà s, p ‚àà S :=\n  mem_sInf_arrows\n\n"}
{"name":"CategoryTheory.Subgroupoid.le_objs","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS T : CategoryTheory.Subgroupoid C\nh : LE.le S T\n‚ä¢ HasSubset.Subset S.objs T.objs","decl":"theorem le_objs {S T : Subgroupoid C} (h : S ‚â§ T) : S.objs ‚äÜ T.objs := fun s ‚ü®Œ≥, hŒ≥‚ü© =>\n  ‚ü®Œ≥, @h ‚ü®s, s, Œ≥‚ü© hŒ≥‚ü©\n\n"}
{"name":"CategoryTheory.Subgroupoid.inclusion_inj_on_objects","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS T : CategoryTheory.Subgroupoid C\nh : LE.le S T\n‚ä¢ Function.Injective (CategoryTheory.Subgroupoid.inclusion h).obj","decl":"theorem inclusion_inj_on_objects {S T : Subgroupoid C} (h : S ‚â§ T) :\n    Function.Injective (inclusion h).obj := fun ‚ü®s, hs‚ü© ‚ü®t, ht‚ü© => by\n  simpa only [inclusion, Subtype.mk_eq_mk] using id\n\n"}
{"name":"CategoryTheory.Subgroupoid.inclusion_faithful","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS T : CategoryTheory.Subgroupoid C\nh : LE.le S T\ns t : ‚ÜëS.objs\n‚ä¢ Function.Injective fun f => (CategoryTheory.Subgroupoid.inclusion h).map f","decl":"theorem inclusion_faithful {S T : Subgroupoid C} (h : S ‚â§ T) (s t : S.objs) :\n    Function.Injective fun f : s ‚ü∂ t => (inclusion h).map f := fun ‚ü®f, hf‚ü© ‚ü®g, hg‚ü© => by\n  -- Porting note: was `...; simpa only [Subtype.mk_eq_mk] using id`\n  dsimp only [inclusion]; rw [Subtype.mk_eq_mk, Subtype.mk_eq_mk]; exact id\n\n"}
{"name":"CategoryTheory.Subgroupoid.inclusion_refl","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n‚ä¢ Eq (CategoryTheory.Subgroupoid.inclusion ‚ãØ) (CategoryTheory.Functor.id ‚ÜëS.objs)","decl":"theorem inclusion_refl {S : Subgroupoid C} : inclusion (le_refl S) = ùü≠ S.objs :=\n  Functor.hext (fun _ => rfl) fun _ _ _ => HEq.refl _\n\n"}
{"name":"CategoryTheory.Subgroupoid.inclusion_trans","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nR S T : CategoryTheory.Subgroupoid C\nk : LE.le R S\nh : LE.le S T\n‚ä¢ Eq (CategoryTheory.Subgroupoid.inclusion ‚ãØ) ((CategoryTheory.Subgroupoid.inclusion k).comp (CategoryTheory.Subgroupoid.inclusion h))","decl":"theorem inclusion_trans {R S T : Subgroupoid C} (k : R ‚â§ S) (h : S ‚â§ T) :\n    inclusion (k.trans h) = inclusion k ‚ãô inclusion h :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subgroupoid.inclusion_comp_embedding","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS T : CategoryTheory.Subgroupoid C\nh : LE.le S T\n‚ä¢ Eq ((CategoryTheory.Subgroupoid.inclusion h).comp T.hom) S.hom","decl":"theorem inclusion_comp_embedding {S T : Subgroupoid C} (h : S ‚â§ T) : inclusion h ‚ãô T.hom = S.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_discrete_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nc d : C\nf : Quiver.Hom c d\n‚ä¢ Iff (Membership.mem (CategoryTheory.Subgroupoid.discrete.arrows c d) f) (Exists fun h => Eq f (CategoryTheory.eqToHom h))","decl":"theorem mem_discrete_iff {c d : C} (f : c ‚ü∂ d) :\n    f ‚àà discrete.arrows c d ‚Üî ‚àÉ h : c = d, f = eqToHom h :=\n  ‚ü®by rintro ‚ü®‚ü©; exact ‚ü®rfl, rfl‚ü©, by rintro ‚ü®rfl, rfl‚ü©; constructor‚ü©\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsWide.wide","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nself : S.IsWide\nc : C\n‚ä¢ Membership.mem (S.arrows c c) (CategoryTheory.CategoryStruct.id c)","decl":"/-- A subgroupoid is wide if its carrier set is all of `C`-/\nstructure IsWide : Prop where\n  wide : ‚àÄ c, ùüô c ‚àà S.arrows c c\n\n"}
{"name":"CategoryTheory.Subgroupoid.isWide_iff_objs_eq_univ","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n‚ä¢ Iff S.IsWide (Eq S.objs Set.univ)","decl":"theorem isWide_iff_objs_eq_univ : S.IsWide ‚Üî S.objs = Set.univ := by\n  constructor\n  ¬∑ rintro h\n    ext x; constructor <;> simp only [top_eq_univ, mem_univ, imp_true_iff, forall_true_left]\n    apply mem_objs_of_src S (h.wide x)\n  ¬∑ rintro h\n    refine ‚ü®fun c => ?_‚ü©\n    obtain ‚ü®Œ≥, Œ≥S‚ü© := (le_of_eq h.symm : ‚ä§ ‚äÜ S.objs) (Set.mem_univ c)\n    exact id_mem_of_src S Œ≥S\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsWide.id_mem","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nSw : S.IsWide\nc : C\n‚ä¢ Membership.mem (S.arrows c c) (CategoryTheory.CategoryStruct.id c)","decl":"theorem IsWide.id_mem {S : Subgroupoid C} (Sw : S.IsWide) (c : C) : ùüô c ‚àà S.arrows c c :=\n  Sw.wide c\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsWide.eqToHom_mem","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nSw : S.IsWide\nc d : C\nh : Eq c d\n‚ä¢ Membership.mem (S.arrows c d) (CategoryTheory.eqToHom h)","decl":"theorem IsWide.eqToHom_mem {S : Subgroupoid C} (Sw : S.IsWide) {c d : C} (h : c = d) :\n    eqToHom h ‚àà S.arrows c d := by cases h; simp only [eqToHom_refl]; apply Sw.id_mem c\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsNormal.conj","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nself : S.IsNormal\nc d : C\np : Quiver.Hom c d\nŒ≥ : Quiver.Hom c c\na‚úù : Membership.mem (S.arrows c c) Œ≥\n‚ä¢ Membership.mem (S.arrows d d) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Groupoid.inv p) (CategoryTheory.CategoryStruct.comp Œ≥ p))","decl":"/-- A subgroupoid is normal if it is wide and satisfies the expected stability under conjugacy. -/\nstructure IsNormal extends IsWide S : Prop where\n  conj : ‚àÄ {c d} (p : c ‚ü∂ d) {Œ≥ : c ‚ü∂ c}, Œ≥ ‚àà S.arrows c c ‚Üí Groupoid.inv p ‚â´ Œ≥ ‚â´ p ‚àà S.arrows d d\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsNormal.toIsWide","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nself : S.IsNormal\n‚ä¢ S.IsWide","decl":"/-- A subgroupoid is normal if it is wide and satisfies the expected stability under conjugacy. -/\nstructure IsNormal extends IsWide S : Prop where\n  conj : ‚àÄ {c d} (p : c ‚ü∂ d) {Œ≥ : c ‚ü∂ c}, Œ≥ ‚àà S.arrows c c ‚Üí Groupoid.inv p ‚â´ Œ≥ ‚â´ p ‚àà S.arrows d d\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsNormal.conj'","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nSn : S.IsNormal\nc d : C\np : Quiver.Hom d c\nŒ≥ : Quiver.Hom c c\na‚úù : Membership.mem (S.arrows c c) Œ≥\n‚ä¢ Membership.mem (S.arrows d d) (CategoryTheory.CategoryStruct.comp p (CategoryTheory.CategoryStruct.comp Œ≥ (CategoryTheory.Groupoid.inv p)))","decl":"theorem IsNormal.conj' {S : Subgroupoid C} (Sn : IsNormal S) :\n    ‚àÄ {c d} (p : d ‚ü∂ c) {Œ≥ : c ‚ü∂ c}, Œ≥ ‚àà S.arrows c c ‚Üí p ‚â´ Œ≥ ‚â´ Groupoid.inv p ‚àà S.arrows d d :=\n  fun p Œ≥ hs => by convert Sn.conj (Groupoid.inv p) hs; simp\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsNormal.conjugation_bij","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nSn : S.IsNormal\nc d : C\np : Quiver.Hom c d\n‚ä¢ Set.BijOn (fun Œ≥ => CategoryTheory.CategoryStruct.comp (CategoryTheory.Groupoid.inv p) (CategoryTheory.CategoryStruct.comp Œ≥ p)) (S.arrows c c) (S.arrows d d)","decl":"theorem IsNormal.conjugation_bij (Sn : IsNormal S) {c d} (p : c ‚ü∂ d) :\n    Set.BijOn (fun Œ≥ : c ‚ü∂ c => Groupoid.inv p ‚â´ Œ≥ ‚â´ p) (S.arrows c c) (S.arrows d d) := by\n  refine ‚ü®fun Œ≥ Œ≥S => Sn.conj p Œ≥S, fun Œ≥‚ÇÅ _ Œ≥‚ÇÇ _ h => ?_, fun Œ¥ Œ¥S =>\n    ‚ü®p ‚â´ Œ¥ ‚â´ Groupoid.inv p, Sn.conj' p Œ¥S, ?_‚ü©‚ü©\n  ¬∑ simpa only [inv_eq_inv, Category.assoc, IsIso.hom_inv_id, Category.comp_id,\n      IsIso.hom_inv_id_assoc] using p ‚â´= h =‚â´ inv p\n  ¬∑ simp only [inv_eq_inv, Category.assoc, IsIso.inv_hom_id, Category.comp_id,\n      IsIso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.Subgroupoid.top_isNormal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\n‚ä¢ Top.top.IsNormal","decl":"theorem top_isNormal : IsNormal (‚ä§ : Subgroupoid C) :=\n  { wide := fun _ => trivial\n    conj := fun _ _ _ => trivial }\n\n"}
{"name":"CategoryTheory.Subgroupoid.sInf_isNormal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\ns : Set (CategoryTheory.Subgroupoid C)\nsn : ‚àÄ (S : CategoryTheory.Subgroupoid C), Membership.mem s S ‚Üí S.IsNormal\n‚ä¢ (InfSet.sInf s).IsNormal","decl":"theorem sInf_isNormal (s : Set <| Subgroupoid C) (sn : ‚àÄ S ‚àà s, IsNormal S) : IsNormal (sInf s) :=\n  { wide := by simp_rw [sInf, mem_iInter‚ÇÇ]; exact fun c S Ss => (sn S Ss).wide c\n    conj := by simp_rw [sInf, mem_iInter‚ÇÇ]; exact fun p Œ≥ hŒ≥ S Ss => (sn S Ss).conj p (hŒ≥ S Ss) }\n\n"}
{"name":"CategoryTheory.Subgroupoid.discrete_isNormal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\n‚ä¢ CategoryTheory.Subgroupoid.discrete.IsNormal","decl":"theorem discrete_isNormal : (@discrete C _).IsNormal :=\n  { wide := fun c => by constructor\n    conj := fun f Œ≥ hŒ≥ => by\n      cases hŒ≥\n      simp only [inv_eq_inv, Category.id_comp, IsIso.inv_hom_id]; constructor }\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsNormal.vertexSubgroup","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nSn : S.IsNormal\nc : C\ncS : Membership.mem S.objs c\n‚ä¢ (S.vertexSubgroup cS).Normal","decl":"theorem IsNormal.vertexSubgroup (Sn : IsNormal S) (c : C) (cS : c ‚àà S.objs) :\n    (S.vertexSubgroup cS).Normal where\n  conj_mem x hx y := by rw [mul_assoc]; exact Sn.conj' y hx\n\n"}
{"name":"CategoryTheory.Subgroupoid.subset_generated","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nX : (c d : C) ‚Üí Set (Quiver.Hom c d)\nc d : C\n‚ä¢ HasSubset.Subset (X c d) ((CategoryTheory.Subgroupoid.generated X).arrows c d)","decl":"theorem subset_generated (c d : C) : X c d ‚äÜ (generated X).arrows c d := by\n  dsimp only [generated, sInf]\n  simp only [subset_iInter‚ÇÇ_iff]\n  exact fun S hS f fS => hS _ _ fS\n\n"}
{"name":"CategoryTheory.Subgroupoid.generated_le_generatedNormal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nX : (c d : C) ‚Üí Set (Quiver.Hom c d)\n‚ä¢ LE.le (CategoryTheory.Subgroupoid.generated X) (CategoryTheory.Subgroupoid.generatedNormal X)","decl":"theorem generated_le_generatedNormal : generated X ‚â§ generatedNormal X := by\n  apply @sInf_le_sInf (Subgroupoid C) _\n  exact fun S ‚ü®h, _‚ü© => h\n\n"}
{"name":"CategoryTheory.Subgroupoid.generatedNormal_isNormal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nX : (c d : C) ‚Üí Set (Quiver.Hom c d)\n‚ä¢ (CategoryTheory.Subgroupoid.generatedNormal X).IsNormal","decl":"theorem generatedNormal_isNormal : (generatedNormal X).IsNormal :=\n  sInf_isNormal _ fun _ h => h.right\n\n"}
{"name":"CategoryTheory.Subgroupoid.IsNormal.generatedNormal_le","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nX : (c d : C) ‚Üí Set (Quiver.Hom c d)\nS : CategoryTheory.Subgroupoid C\nSn : S.IsNormal\n‚ä¢ Iff (LE.le (CategoryTheory.Subgroupoid.generatedNormal X) S) (‚àÄ (c d : C), HasSubset.Subset (X c d) (S.arrows c d))","decl":"theorem IsNormal.generatedNormal_le {S : Subgroupoid C} (Sn : S.IsNormal) :\n    generatedNormal X ‚â§ S ‚Üî ‚àÄ c d, X c d ‚äÜ S.arrows c d := by\n  constructor\n  ¬∑ rintro h c d\n    have h' := generated_le_generatedNormal X\n    rw [le_iff] at h h'\n    exact ((subset_generated X c d).trans (@h' c d)).trans (@h c d)\n  ¬∑ rintro h\n    apply @sInf_le (Subgroupoid C) _\n    exact ‚ü®h, Sn‚ü©\n\n"}
{"name":"CategoryTheory.Subgroupoid.comap_mono","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nS T : CategoryTheory.Subgroupoid D\na‚úù : LE.le S T\n‚ä¢ LE.le (CategoryTheory.Subgroupoid.comap œÜ S) (CategoryTheory.Subgroupoid.comap œÜ T)","decl":"theorem comap_mono (S T : Subgroupoid D) : S ‚â§ T ‚Üí comap œÜ S ‚â§ comap œÜ T := fun ST _ =>\n  @ST ‚ü®_, _, _‚ü©\n\n"}
{"name":"CategoryTheory.Subgroupoid.isNormal_comap","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nS : CategoryTheory.Subgroupoid D\nSn : S.IsNormal\n‚ä¢ (CategoryTheory.Subgroupoid.comap œÜ S).IsNormal","decl":"theorem isNormal_comap {S : Subgroupoid D} (Sn : IsNormal S) : IsNormal (comap œÜ S) where\n  wide c := by rw [comap, mem_setOf, Functor.map_id]; apply Sn.wide\n  conj f Œ≥ hŒ≥ := by\n    simp_rw [inv_eq_inv f, comap, mem_setOf, Functor.map_comp, Functor.map_inv, ‚Üê inv_eq_inv]\n    exact Sn.conj _ hŒ≥\n\n"}
{"name":"CategoryTheory.Subgroupoid.comap_comp","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù¬π : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nE : Type u_2\ninst‚úù : CategoryTheory.Groupoid E\nœà : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.Subgroupoid.comap (œÜ.comp œà)) (Function.comp (CategoryTheory.Subgroupoid.comap œÜ) (CategoryTheory.Subgroupoid.comap œà))","decl":"@[simp]\ntheorem comap_comp {E : Type*} [Groupoid E] (œà : D ‚•§ E) : comap (œÜ ‚ãô œà) = comap œÜ ‚àò comap œà :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_ker_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nc d : C\nf : Quiver.Hom c d\n‚ä¢ Iff (Membership.mem ((CategoryTheory.Subgroupoid.ker œÜ).arrows c d) f) (Exists fun h => Eq (œÜ.map f) (CategoryTheory.eqToHom h))","decl":"theorem mem_ker_iff {c d : C} (f : c ‚ü∂ d) :\n    f ‚àà (ker œÜ).arrows c d ‚Üî ‚àÉ h : œÜ.obj c = œÜ.obj d, œÜ.map f = eqToHom h :=\n  mem_discrete_iff (œÜ.map f)\n\n"}
{"name":"CategoryTheory.Subgroupoid.ker_isNormal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\n‚ä¢ (CategoryTheory.Subgroupoid.ker œÜ).IsNormal","decl":"theorem ker_isNormal : (ker œÜ).IsNormal :=\n  isNormal_comap œÜ discrete_isNormal\n\n"}
{"name":"CategoryTheory.Subgroupoid.ker_comp","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù¬π : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nE : Type u_2\ninst‚úù : CategoryTheory.Groupoid E\nœà : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.Subgroupoid.ker (œÜ.comp œà)) (CategoryTheory.Subgroupoid.comap œÜ (CategoryTheory.Subgroupoid.ker œà))","decl":"@[simp]\ntheorem ker_comp {E : Type*} [Groupoid E] (œà : D ‚•§ E) : ker (œÜ ‚ãô œà) = comap œÜ (ker œà) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Subgroupoid.Map.arrows_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nhœÜ : Function.Injective œÜ.obj\nS : CategoryTheory.Subgroupoid C\nc d : D\nf : Quiver.Hom c d\n‚ä¢ Iff (CategoryTheory.Subgroupoid.Map.Arrows œÜ hœÜ S c d f) (Exists fun a => Exists fun b => Exists fun g => Exists fun ha => Exists fun hb => Exists fun _hg => Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (œÜ.map g) (CategoryTheory.eqToHom hb))))","decl":"theorem Map.arrows_iff (hœÜ : Function.Injective œÜ.obj) (S : Subgroupoid C) {c d : D} (f : c ‚ü∂ d) :\n    Map.Arrows œÜ hœÜ S c d f ‚Üî\n      ‚àÉ (a b : C) (g : a ‚ü∂ b) (ha : œÜ.obj a = c) (hb : œÜ.obj b = d) (_hg : g ‚àà S.arrows a b),\n        f = eqToHom ha.symm ‚â´ œÜ.map g ‚â´ eqToHom hb := by\n  constructor\n  ¬∑ rintro ‚ü®g, hg‚ü©; exact ‚ü®_, _, g, rfl, rfl, hg, eq_conj_eqToHom _‚ü©\n  ¬∑ rintro ‚ü®a, b, g, rfl, rfl, hg, rfl‚ü©; rw [‚Üê eq_conj_eqToHom]; constructor; exact hg\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_map_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nhœÜ : Function.Injective œÜ.obj\nS : CategoryTheory.Subgroupoid C\nc d : D\nf : Quiver.Hom c d\n‚ä¢ Iff (Membership.mem ((CategoryTheory.Subgroupoid.map œÜ hœÜ S).arrows c d) f) (Exists fun a => Exists fun b => Exists fun g => Exists fun ha => Exists fun hb => Exists fun _hg => Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (œÜ.map g) (CategoryTheory.eqToHom hb))))","decl":"theorem mem_map_iff (hœÜ : Function.Injective œÜ.obj) (S : Subgroupoid C) {c d : D} (f : c ‚ü∂ d) :\n    f ‚àà (map œÜ hœÜ S).arrows c d ‚Üî\n      ‚àÉ (a b : C) (g : a ‚ü∂ b) (ha : œÜ.obj a = c) (hb : œÜ.obj b = d) (_hg : g ‚àà S.arrows a b),\n        f = eqToHom ha.symm ‚â´ œÜ.map g ‚â´ eqToHom hb :=\n  Map.arrows_iff œÜ hœÜ S f\n\n"}
{"name":"CategoryTheory.Subgroupoid.galoisConnection_map_comap","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nhœÜ : Function.Injective œÜ.obj\n‚ä¢ GaloisConnection (CategoryTheory.Subgroupoid.map œÜ hœÜ) (CategoryTheory.Subgroupoid.comap œÜ)","decl":"theorem galoisConnection_map_comap (hœÜ : Function.Injective œÜ.obj) :\n    GaloisConnection (map œÜ hœÜ) (comap œÜ) := by\n  rintro S T; simp_rw [le_iff]; constructor\n  ¬∑ exact fun h c d f fS => h (Map.Arrows.im f fS)\n  ¬∑ rintro h _ _ g ‚ü®a, gœÜS‚ü©\n    exact h gœÜS\n\n"}
{"name":"CategoryTheory.Subgroupoid.map_mono","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nhœÜ : Function.Injective œÜ.obj\nS T : CategoryTheory.Subgroupoid C\na‚úù : LE.le S T\n‚ä¢ LE.le (CategoryTheory.Subgroupoid.map œÜ hœÜ S) (CategoryTheory.Subgroupoid.map œÜ hœÜ T)","decl":"theorem map_mono (hœÜ : Function.Injective œÜ.obj) (S T : Subgroupoid C) :\n    S ‚â§ T ‚Üí map œÜ hœÜ S ‚â§ map œÜ hœÜ T := fun h => (galoisConnection_map_comap œÜ hœÜ).monotone_l h\n\n"}
{"name":"CategoryTheory.Subgroupoid.le_comap_map","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nhœÜ : Function.Injective œÜ.obj\nS : CategoryTheory.Subgroupoid C\n‚ä¢ LE.le S (CategoryTheory.Subgroupoid.comap œÜ (CategoryTheory.Subgroupoid.map œÜ hœÜ S))","decl":"theorem le_comap_map (hœÜ : Function.Injective œÜ.obj) (S : Subgroupoid C) :\n    S ‚â§ comap œÜ (map œÜ hœÜ S) :=\n  (galoisConnection_map_comap œÜ hœÜ).le_u_l S\n\n"}
{"name":"CategoryTheory.Subgroupoid.map_comap_le","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nhœÜ : Function.Injective œÜ.obj\nT : CategoryTheory.Subgroupoid D\n‚ä¢ LE.le (CategoryTheory.Subgroupoid.map œÜ hœÜ (CategoryTheory.Subgroupoid.comap œÜ T)) T","decl":"theorem map_comap_le (hœÜ : Function.Injective œÜ.obj) (T : Subgroupoid D) :\n    map œÜ hœÜ (comap œÜ T) ‚â§ T :=\n  (galoisConnection_map_comap œÜ hœÜ).l_u_le T\n\n"}
{"name":"CategoryTheory.Subgroupoid.map_le_iff_le_comap","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nhœÜ : Function.Injective œÜ.obj\nS : CategoryTheory.Subgroupoid C\nT : CategoryTheory.Subgroupoid D\n‚ä¢ Iff (LE.le (CategoryTheory.Subgroupoid.map œÜ hœÜ S) T) (LE.le S (CategoryTheory.Subgroupoid.comap œÜ T))","decl":"theorem map_le_iff_le_comap (hœÜ : Function.Injective œÜ.obj) (S : Subgroupoid C)\n    (T : Subgroupoid D) : map œÜ hœÜ S ‚â§ T ‚Üî S ‚â§ comap œÜ T :=\n  (galoisConnection_map_comap œÜ hœÜ).le_iff_le\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_map_objs_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nhœÜ : Function.Injective œÜ.obj\nd : D\n‚ä¢ Iff (Membership.mem (CategoryTheory.Subgroupoid.map œÜ hœÜ S).objs d) (Exists fun c => And (Membership.mem S.objs c) (Eq (œÜ.obj c) d))","decl":"theorem mem_map_objs_iff (hœÜ : Function.Injective œÜ.obj) (d : D) :\n    d ‚àà (map œÜ hœÜ S).objs ‚Üî ‚àÉ c ‚àà S.objs, œÜ.obj c = d := by\n  dsimp [objs, map]\n  constructor\n  ¬∑ rintro ‚ü®f, hf‚ü©\n    change Map.Arrows œÜ hœÜ S d d f at hf; rw [Map.arrows_iff] at hf\n    obtain ‚ü®c, d, g, ec, ed, eg, gS, eg‚ü© := hf\n    exact ‚ü®c, ‚ü®mem_objs_of_src S eg, ec‚ü©‚ü©\n  ¬∑ rintro ‚ü®c, ‚ü®Œ≥, Œ≥S‚ü©, rfl‚ü©\n    exact ‚ü®œÜ.map Œ≥, ‚ü®Œ≥, Œ≥S‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Subgroupoid.map_objs_eq","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nhœÜ : Function.Injective œÜ.obj\n‚ä¢ Eq (CategoryTheory.Subgroupoid.map œÜ hœÜ S).objs (Set.image œÜ.obj S.objs)","decl":"@[simp]\ntheorem map_objs_eq (hœÜ : Function.Injective œÜ.obj) : (map œÜ hœÜ S).objs = œÜ.obj '' S.objs := by\n  ext x; convert mem_map_objs_iff S œÜ hœÜ x\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_im_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nhœÜ : Function.Injective œÜ.obj\nc d : D\nf : Quiver.Hom c d\n‚ä¢ Iff (Membership.mem ((CategoryTheory.Subgroupoid.im œÜ hœÜ).arrows c d) f) (Exists fun a => Exists fun b => Exists fun g => Exists fun ha => Exists fun hb => Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (œÜ.map g) (CategoryTheory.eqToHom hb))))","decl":"theorem mem_im_iff (hœÜ : Function.Injective œÜ.obj) {c d : D} (f : c ‚ü∂ d) :\n    f ‚àà (im œÜ hœÜ).arrows c d ‚Üî\n      ‚àÉ (a b : C) (g : a ‚ü∂ b) (ha : œÜ.obj a = c) (hb : œÜ.obj b = d),\n        f = eqToHom ha.symm ‚â´ œÜ.map g ‚â´ eqToHom hb := by\n  convert Map.arrows_iff œÜ hœÜ ‚ä§ f; simp only [Top.top, mem_univ, exists_true_left]\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_im_objs_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nhœÜ : Function.Injective œÜ.obj\nd : D\n‚ä¢ Iff (Membership.mem (CategoryTheory.Subgroupoid.im œÜ hœÜ).objs d) (Exists fun c => Eq (œÜ.obj c) d)","decl":"theorem mem_im_objs_iff (hœÜ : Function.Injective œÜ.obj) (d : D) :\n    d ‚àà (im œÜ hœÜ).objs ‚Üî ‚àÉ c : C, œÜ.obj c = d := by\n  simp only [im, mem_map_objs_iff, mem_top_objs, true_and]\n\n"}
{"name":"CategoryTheory.Subgroupoid.obj_surjective_of_im_eq_top","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nhœÜ : Function.Injective œÜ.obj\nhœÜ' : Eq (CategoryTheory.Subgroupoid.im œÜ hœÜ) Top.top\n‚ä¢ Function.Surjective œÜ.obj","decl":"theorem obj_surjective_of_im_eq_top (hœÜ : Function.Injective œÜ.obj) (hœÜ' : im œÜ hœÜ = ‚ä§) :\n    Function.Surjective œÜ.obj := by\n  rintro d\n  rw [‚Üê mem_im_objs_iff, hœÜ']\n  apply mem_top_objs\n\n"}
{"name":"CategoryTheory.Subgroupoid.isNormal_map","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nD : Type u_1\ninst‚úù : CategoryTheory.Groupoid D\nœÜ : CategoryTheory.Functor C D\nhœÜ : Function.Injective œÜ.obj\nhœÜ' : Eq (CategoryTheory.Subgroupoid.im œÜ hœÜ) Top.top\nSn : S.IsNormal\n‚ä¢ (CategoryTheory.Subgroupoid.map œÜ hœÜ S).IsNormal","decl":"theorem isNormal_map (hœÜ : Function.Injective œÜ.obj) (hœÜ' : im œÜ hœÜ = ‚ä§) (Sn : S.IsNormal) :\n    (map œÜ hœÜ S).IsNormal :=\n  { wide := fun d => by\n      obtain ‚ü®c, rfl‚ü© := obj_surjective_of_im_eq_top œÜ hœÜ hœÜ' d\n      change Map.Arrows œÜ hœÜ S _ _ (ùüô _); rw [‚Üê Functor.map_id]\n      constructor; exact Sn.wide c\n    conj := fun {d d'} g Œ¥ hŒ¥ => by\n      rw [mem_map_iff] at hŒ¥\n      obtain ‚ü®c, c', Œ≥, cd, cd', Œ≥S, hŒ≥‚ü© := hŒ¥; subst_vars; cases hœÜ cd'\n      have : d' ‚àà (im œÜ hœÜ).objs := by rw [hœÜ']; apply mem_top_objs\n      rw [mem_im_objs_iff] at this\n      obtain ‚ü®c', rfl‚ü© := this\n      have : g ‚àà (im œÜ hœÜ).arrows (œÜ.obj c) (œÜ.obj c') := by rw [hœÜ']; trivial\n      rw [mem_im_iff] at this\n      obtain ‚ü®b, b', f, hb, hb', _, hf‚ü© := this; cases hœÜ hb; cases hœÜ hb'\n      change Map.Arrows œÜ hœÜ S (œÜ.obj c') (œÜ.obj c') _\n      simp only [eqToHom_refl, Category.comp_id, Category.id_comp, inv_eq_inv]\n      suffices Map.Arrows œÜ hœÜ S (œÜ.obj c') (œÜ.obj c') (œÜ.map <| Groupoid.inv f ‚â´ Œ≥ ‚â´ f) by\n        simp only [inv_eq_inv, Functor.map_comp, Functor.map_inv] at this; exact this\n      constructor; apply Sn.conj f Œ≥S }\n\n"}
{"name":"CategoryTheory.Subgroupoid.isThin_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n‚ä¢ Iff S.IsThin (‚àÄ (c : ‚ÜëS.objs), Subsingleton ‚Üë(S.arrows ‚Üëc ‚Üëc))","decl":"nonrec theorem isThin_iff : S.IsThin ‚Üî ‚àÄ c : S.objs, Subsingleton (S.arrows c c) := isThin_iff _\n\n"}
{"name":"CategoryTheory.Subgroupoid.isTotallyDisconnected_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n‚ä¢ Iff S.IsTotallyDisconnected (‚àÄ (c d : C), (S.arrows c d).Nonempty ‚Üí Eq c d)","decl":"theorem isTotallyDisconnected_iff :\n    S.IsTotallyDisconnected ‚Üî ‚àÄ c d, (S.arrows c d).Nonempty ‚Üí c = d := by\n  constructor\n  ¬∑ rintro h c d ‚ü®f, fS‚ü©\n    exact congr_arg Subtype.val <| h ‚ü®c, mem_objs_of_src S fS‚ü© ‚ü®d, mem_objs_of_tgt S fS‚ü© ‚ü®f, fS‚ü©\n  ¬∑ rintro h ‚ü®c, hc‚ü© ‚ü®d, hd‚ü© ‚ü®f, fS‚ü©\n    simp only [Subtype.mk_eq_mk]\n    exact h c d ‚ü®f, fS‚ü©\n\n"}
{"name":"CategoryTheory.Subgroupoid.disconnect_le","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n‚ä¢ LE.le S.disconnect S","decl":"theorem disconnect_le : S.disconnect ‚â§ S := by rw [le_iff]; rintro _ _ _ ‚ü®‚ü©; assumption\n\n"}
{"name":"CategoryTheory.Subgroupoid.disconnect_normal","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nSn : S.IsNormal\n‚ä¢ S.disconnect.IsNormal","decl":"theorem disconnect_normal (Sn : S.IsNormal) : S.disconnect.IsNormal :=\n  { wide := fun c => ‚ü®rfl, Sn.wide c‚ü©\n    conj := fun _ _ ‚ü®_, h'‚ü© => ‚ü®rfl, Sn.conj _ h'‚ü© }\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_disconnect_objs_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\nc : C\n‚ä¢ Iff (Membership.mem S.disconnect.objs c) (Membership.mem S.objs c)","decl":"@[simp]\ntheorem mem_disconnect_objs_iff {c : C} : c ‚àà S.disconnect.objs ‚Üî c ‚àà S.objs :=\n  ‚ü®fun ‚ü®Œ≥, _, Œ≥S‚ü© => ‚ü®Œ≥, Œ≥S‚ü©, fun ‚ü®Œ≥, Œ≥S‚ü© => ‚ü®Œ≥, rfl, Œ≥S‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Subgroupoid.disconnect_objs","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n‚ä¢ Eq S.disconnect.objs S.objs","decl":"theorem disconnect_objs : S.disconnect.objs = S.objs := Set.ext fun _ ‚Ü¶ mem_disconnect_objs_iff _\n\n"}
{"name":"CategoryTheory.Subgroupoid.disconnect_isTotallyDisconnected","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nS : CategoryTheory.Subgroupoid C\n‚ä¢ S.disconnect.IsTotallyDisconnected","decl":"theorem disconnect_isTotallyDisconnected : S.disconnect.IsTotallyDisconnected := by\n  rw [isTotallyDisconnected_iff]; exact fun c d ‚ü®_, h, _‚ü© => h\n\n"}
{"name":"CategoryTheory.Subgroupoid.full_objs","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nD : Set C\n‚ä¢ Eq (CategoryTheory.Subgroupoid.full D).objs D","decl":"theorem full_objs : (full D).objs = D :=\n  Set.ext fun _ => ‚ü®fun ‚ü®_, h, _‚ü© => h, fun h => ‚ü®ùüô _, h, h‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_full_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nD : Set C\nc d : C\nf : Quiver.Hom c d\n‚ä¢ Iff (Membership.mem ((CategoryTheory.Subgroupoid.full D).arrows c d) f) (And (Membership.mem D c) (Membership.mem D d))","decl":"@[simp]\ntheorem mem_full_iff {c d : C} {f : c ‚ü∂ d} : f ‚àà (full D).arrows c d ‚Üî c ‚àà D ‚àß d ‚àà D :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.Subgroupoid.mem_full_objs_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nD : Set C\nc : C\n‚ä¢ Iff (Membership.mem (CategoryTheory.Subgroupoid.full D).objs c) (Membership.mem D c)","decl":"@[simp]\ntheorem mem_full_objs_iff {c : C} : c ‚àà (full D).objs ‚Üî c ‚àà D := by rw [full_objs]\n\n"}
{"name":"CategoryTheory.Subgroupoid.full_empty","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\n‚ä¢ Eq (CategoryTheory.Subgroupoid.full EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem full_empty : full ‚àÖ = (‚ä• : Subgroupoid C) := by\n  ext\n  simp only [Bot.bot, mem_full_iff, mem_empty_iff_false, and_self_iff]\n\n"}
{"name":"CategoryTheory.Subgroupoid.full_univ","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\n‚ä¢ Eq (CategoryTheory.Subgroupoid.full Set.univ) Top.top","decl":"@[simp]\ntheorem full_univ : full Set.univ = (‚ä§ : Subgroupoid C) := by\n  ext\n  simp only [mem_full_iff, mem_univ, and_self, mem_top]\n\n"}
{"name":"CategoryTheory.Subgroupoid.full_mono","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nD E : Set C\nh : LE.le D E\n‚ä¢ LE.le (CategoryTheory.Subgroupoid.full D) (CategoryTheory.Subgroupoid.full E)","decl":"theorem full_mono {D E : Set C} (h : D ‚â§ E) : full D ‚â§ full E := by\n  rw [le_iff]\n  rintro c d f\n  simp only [mem_full_iff]\n  exact fun ‚ü®hc, hd‚ü© => ‚ü®h hc, h hd‚ü©\n\n-- Porting note: using `.1` instead of `‚Üë`\n"}
{"name":"CategoryTheory.Subgroupoid.full_arrow_eq_iff","module":"Mathlib.CategoryTheory.Groupoid.Subgroupoid","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Groupoid C\nD : Set C\nc d : ‚Üë(CategoryTheory.Subgroupoid.full D).objs\nf g : Quiver.Hom c d\n‚ä¢ Iff (Eq f g) (Eq ‚Üëf ‚Üëg)","decl":"theorem full_arrow_eq_iff {c d : (full D).objs} {f g : c ‚ü∂ d} :\n    f = g ‚Üî (f.1 : c.val ‚ü∂ d.val) = g.1 :=\n  Subtype.ext_iff\n\n"}
