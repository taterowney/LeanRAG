{"name":"CategoryTheory.ShiftMkCore.mk.inj","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : AddMonoid A\nF✝ : A → CategoryTheory.Functor C C\nzero✝ : CategoryTheory.Iso (F✝ 0) (CategoryTheory.Functor.id C)\nadd✝ : (n m : A) → CategoryTheory.Iso (F✝ (HAdd.hAdd n m)) ((F✝ n).comp (F✝ m))\nassoc_hom_app✝ : autoParam (∀ (m₁ m₂ m₃ : A) (X : C), Eq (CategoryTheory.CategoryStruct.comp ((add✝ (HAdd.hAdd m₁ m₂) m₃).hom.app X) ((F✝ m₃).map ((add✝ m₁ m₂).hom.app X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp ((add✝ m₁ (HAdd.hAdd m₂ m₃)).hom.app X) ((add✝ m₂ m₃).hom.app ((F✝ m₁).obj X))))) _auto✝\nzero_add_hom_app✝ : autoParam (∀ (n : A) (X : C), Eq ((add✝ 0 n).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) ((F✝ n).map (zero✝.inv.app X)))) _auto✝\nadd_zero_hom_app✝ : autoParam (∀ (n : A) (X : C), Eq ((add✝ n 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (zero✝.inv.app ((F✝ n).obj X)))) _auto✝\nF : A → CategoryTheory.Functor C C\nzero : CategoryTheory.Iso (F 0) (CategoryTheory.Functor.id C)\nadd : (n m : A) → CategoryTheory.Iso (F (HAdd.hAdd n m)) ((F n).comp (F m))\nassoc_hom_app : autoParam (∀ (m₁ m₂ m₃ : A) (X : C), Eq (CategoryTheory.CategoryStruct.comp ((add (HAdd.hAdd m₁ m₂) m₃).hom.app X) ((F m₃).map ((add m₁ m₂).hom.app X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp ((add m₁ (HAdd.hAdd m₂ m₃)).hom.app X) ((add m₂ m₃).hom.app ((F m₁).obj X))))) _auto✝\nzero_add_hom_app : autoParam (∀ (n : A) (X : C), Eq ((add 0 n).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) ((F n).map (zero.inv.app X)))) _auto✝\nadd_zero_hom_app : autoParam (∀ (n : A) (X : C), Eq ((add n 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (zero.inv.app ((F n).obj X)))) _auto✝\nx✝ : Eq { F := F✝, zero := zero✝, add := add✝, assoc_hom_app := assoc_hom_app✝, zero_add_hom_app := zero_add_hom_app✝, add_zero_hom_app := add_zero_hom_app✝ } { F := F, zero := zero, add := add, assoc_hom_app := assoc_hom_app, zero_add_hom_app := zero_add_hom_app, add_zero_hom_app := add_zero_hom_app }\n⊢ And (Eq F✝ F) (And (HEq zero✝ zero) (HEq add✝ add))","decl":"/-- A helper structure to construct the shift functor `(Discrete A) ⥤ (C ⥤ C)`. -/\nstructure ShiftMkCore where\n  /-- the family of shift functors -/\n  F : A → C ⥤ C\n  /-- the shift by 0 identifies to the identity functor -/\n  zero : F 0 ≅ 𝟭 C\n  /-- the composition of shift functors identifies to the shift by the sum -/\n  add : ∀ n m : A, F (n + m) ≅ F n ⋙ F m\n  /-- compatibility with the associativity -/\n  assoc_hom_app : ∀ (m₁ m₂ m₃ : A) (X : C),\n    (add (m₁ + m₂) m₃).hom.app X ≫ (F m₃).map ((add m₁ m₂).hom.app X) =\n      eqToHom (by rw [add_assoc]) ≫ (add m₁ (m₂ + m₃)).hom.app X ≫\n        (add m₂ m₃).hom.app ((F m₁).obj X) := by aesop_cat\n  /-- compatibility with the left addition with 0 -/\n  zero_add_hom_app : ∀ (n : A) (X : C), (add 0 n).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ≫ (F n).map (zero.inv.app X) := by aesop_cat\n  /-- compatibility with the right addition with 0 -/\n  add_zero_hom_app : ∀ (n : A) (X : C), (add n 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ≫ zero.inv.app ((F n).obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShiftMkCore.assoc_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : AddMonoid A\nself : CategoryTheory.ShiftMkCore C A\nm₁ m₂ m₃ : A\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((self.add (HAdd.hAdd m₁ m₂) m₃).hom.app X) ((self.F m₃).map ((self.add m₁ m₂).hom.app X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp ((self.add m₁ (HAdd.hAdd m₂ m₃)).hom.app X) ((self.add m₂ m₃).hom.app ((self.F m₁).obj X))))","decl":"/-- A helper structure to construct the shift functor `(Discrete A) ⥤ (C ⥤ C)`. -/\nstructure ShiftMkCore where\n  /-- the family of shift functors -/\n  F : A → C ⥤ C\n  /-- the shift by 0 identifies to the identity functor -/\n  zero : F 0 ≅ 𝟭 C\n  /-- the composition of shift functors identifies to the shift by the sum -/\n  add : ∀ n m : A, F (n + m) ≅ F n ⋙ F m\n  /-- compatibility with the associativity -/\n  assoc_hom_app : ∀ (m₁ m₂ m₃ : A) (X : C),\n    (add (m₁ + m₂) m₃).hom.app X ≫ (F m₃).map ((add m₁ m₂).hom.app X) =\n      eqToHom (by rw [add_assoc]) ≫ (add m₁ (m₂ + m₃)).hom.app X ≫\n        (add m₂ m₃).hom.app ((F m₁).obj X) := by aesop_cat\n  /-- compatibility with the left addition with 0 -/\n  zero_add_hom_app : ∀ (n : A) (X : C), (add 0 n).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ≫ (F n).map (zero.inv.app X) := by aesop_cat\n  /-- compatibility with the right addition with 0 -/\n  add_zero_hom_app : ∀ (n : A) (X : C), (add n 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ≫ zero.inv.app ((F n).obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShiftMkCore.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : AddMonoid A\ninst✝¹ : SizeOf C\ninst✝ : SizeOf A\nF : A → CategoryTheory.Functor C C\nzero : CategoryTheory.Iso (F 0) (CategoryTheory.Functor.id C)\nadd : (n m : A) → CategoryTheory.Iso (F (HAdd.hAdd n m)) ((F n).comp (F m))\nassoc_hom_app : autoParam (∀ (m₁ m₂ m₃ : A) (X : C), Eq (CategoryTheory.CategoryStruct.comp ((add (HAdd.hAdd m₁ m₂) m₃).hom.app X) ((F m₃).map ((add m₁ m₂).hom.app X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp ((add m₁ (HAdd.hAdd m₂ m₃)).hom.app X) ((add m₂ m₃).hom.app ((F m₁).obj X))))) _auto✝\nzero_add_hom_app : autoParam (∀ (n : A) (X : C), Eq ((add 0 n).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) ((F n).map (zero.inv.app X)))) _auto✝\nadd_zero_hom_app : autoParam (∀ (n : A) (X : C), Eq ((add n 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (zero.inv.app ((F n).obj X)))) _auto✝\n⊢ Eq (SizeOf.sizeOf { F := F, zero := zero, add := add, assoc_hom_app := assoc_hom_app, zero_add_hom_app := zero_add_hom_app, add_zero_hom_app := add_zero_hom_app }) (HAdd.hAdd 1 (SizeOf.sizeOf zero))","decl":"/-- A helper structure to construct the shift functor `(Discrete A) ⥤ (C ⥤ C)`. -/\nstructure ShiftMkCore where\n  /-- the family of shift functors -/\n  F : A → C ⥤ C\n  /-- the shift by 0 identifies to the identity functor -/\n  zero : F 0 ≅ 𝟭 C\n  /-- the composition of shift functors identifies to the shift by the sum -/\n  add : ∀ n m : A, F (n + m) ≅ F n ⋙ F m\n  /-- compatibility with the associativity -/\n  assoc_hom_app : ∀ (m₁ m₂ m₃ : A) (X : C),\n    (add (m₁ + m₂) m₃).hom.app X ≫ (F m₃).map ((add m₁ m₂).hom.app X) =\n      eqToHom (by rw [add_assoc]) ≫ (add m₁ (m₂ + m₃)).hom.app X ≫\n        (add m₂ m₃).hom.app ((F m₁).obj X) := by aesop_cat\n  /-- compatibility with the left addition with 0 -/\n  zero_add_hom_app : ∀ (n : A) (X : C), (add 0 n).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ≫ (F n).map (zero.inv.app X) := by aesop_cat\n  /-- compatibility with the right addition with 0 -/\n  add_zero_hom_app : ∀ (n : A) (X : C), (add n 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ≫ zero.inv.app ((F n).obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShiftMkCore.add_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : AddMonoid A\nself : CategoryTheory.ShiftMkCore C A\nn : A\nX : C\n⊢ Eq ((self.add n 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (self.zero.inv.app ((self.F n).obj X)))","decl":"/-- A helper structure to construct the shift functor `(Discrete A) ⥤ (C ⥤ C)`. -/\nstructure ShiftMkCore where\n  /-- the family of shift functors -/\n  F : A → C ⥤ C\n  /-- the shift by 0 identifies to the identity functor -/\n  zero : F 0 ≅ 𝟭 C\n  /-- the composition of shift functors identifies to the shift by the sum -/\n  add : ∀ n m : A, F (n + m) ≅ F n ⋙ F m\n  /-- compatibility with the associativity -/\n  assoc_hom_app : ∀ (m₁ m₂ m₃ : A) (X : C),\n    (add (m₁ + m₂) m₃).hom.app X ≫ (F m₃).map ((add m₁ m₂).hom.app X) =\n      eqToHom (by rw [add_assoc]) ≫ (add m₁ (m₂ + m₃)).hom.app X ≫\n        (add m₂ m₃).hom.app ((F m₁).obj X) := by aesop_cat\n  /-- compatibility with the left addition with 0 -/\n  zero_add_hom_app : ∀ (n : A) (X : C), (add 0 n).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ≫ (F n).map (zero.inv.app X) := by aesop_cat\n  /-- compatibility with the right addition with 0 -/\n  add_zero_hom_app : ∀ (n : A) (X : C), (add n 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ≫ zero.inv.app ((F n).obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShiftMkCore.zero_add_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : AddMonoid A\nself : CategoryTheory.ShiftMkCore C A\nn : A\nX : C\n⊢ Eq ((self.add 0 n).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) ((self.F n).map (self.zero.inv.app X)))","decl":"/-- A helper structure to construct the shift functor `(Discrete A) ⥤ (C ⥤ C)`. -/\nstructure ShiftMkCore where\n  /-- the family of shift functors -/\n  F : A → C ⥤ C\n  /-- the shift by 0 identifies to the identity functor -/\n  zero : F 0 ≅ 𝟭 C\n  /-- the composition of shift functors identifies to the shift by the sum -/\n  add : ∀ n m : A, F (n + m) ≅ F n ⋙ F m\n  /-- compatibility with the associativity -/\n  assoc_hom_app : ∀ (m₁ m₂ m₃ : A) (X : C),\n    (add (m₁ + m₂) m₃).hom.app X ≫ (F m₃).map ((add m₁ m₂).hom.app X) =\n      eqToHom (by rw [add_assoc]) ≫ (add m₁ (m₂ + m₃)).hom.app X ≫\n        (add m₂ m₃).hom.app ((F m₁).obj X) := by aesop_cat\n  /-- compatibility with the left addition with 0 -/\n  zero_add_hom_app : ∀ (n : A) (X : C), (add 0 n).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ≫ (F n).map (zero.inv.app X) := by aesop_cat\n  /-- compatibility with the right addition with 0 -/\n  add_zero_hom_app : ∀ (n : A) (X : C), (add n 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ≫ zero.inv.app ((F n).obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShiftMkCore.mk.injEq","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : AddMonoid A\nF✝ : A → CategoryTheory.Functor C C\nzero✝ : CategoryTheory.Iso (F✝ 0) (CategoryTheory.Functor.id C)\nadd✝ : (n m : A) → CategoryTheory.Iso (F✝ (HAdd.hAdd n m)) ((F✝ n).comp (F✝ m))\nassoc_hom_app✝ : autoParam (∀ (m₁ m₂ m₃ : A) (X : C), Eq (CategoryTheory.CategoryStruct.comp ((add✝ (HAdd.hAdd m₁ m₂) m₃).hom.app X) ((F✝ m₃).map ((add✝ m₁ m₂).hom.app X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp ((add✝ m₁ (HAdd.hAdd m₂ m₃)).hom.app X) ((add✝ m₂ m₃).hom.app ((F✝ m₁).obj X))))) _auto✝\nzero_add_hom_app✝ : autoParam (∀ (n : A) (X : C), Eq ((add✝ 0 n).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) ((F✝ n).map (zero✝.inv.app X)))) _auto✝\nadd_zero_hom_app✝ : autoParam (∀ (n : A) (X : C), Eq ((add✝ n 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (zero✝.inv.app ((F✝ n).obj X)))) _auto✝\nF : A → CategoryTheory.Functor C C\nzero : CategoryTheory.Iso (F 0) (CategoryTheory.Functor.id C)\nadd : (n m : A) → CategoryTheory.Iso (F (HAdd.hAdd n m)) ((F n).comp (F m))\nassoc_hom_app : autoParam (∀ (m₁ m₂ m₃ : A) (X : C), Eq (CategoryTheory.CategoryStruct.comp ((add (HAdd.hAdd m₁ m₂) m₃).hom.app X) ((F m₃).map ((add m₁ m₂).hom.app X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp ((add m₁ (HAdd.hAdd m₂ m₃)).hom.app X) ((add m₂ m₃).hom.app ((F m₁).obj X))))) _auto✝\nzero_add_hom_app : autoParam (∀ (n : A) (X : C), Eq ((add 0 n).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) ((F n).map (zero.inv.app X)))) _auto✝\nadd_zero_hom_app : autoParam (∀ (n : A) (X : C), Eq ((add n 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (zero.inv.app ((F n).obj X)))) _auto✝\n⊢ Eq (Eq { F := F✝, zero := zero✝, add := add✝, assoc_hom_app := assoc_hom_app✝, zero_add_hom_app := zero_add_hom_app✝, add_zero_hom_app := add_zero_hom_app✝ } { F := F, zero := zero, add := add, assoc_hom_app := assoc_hom_app, zero_add_hom_app := zero_add_hom_app, add_zero_hom_app := add_zero_hom_app }) (And (Eq F✝ F) (And (HEq zero✝ zero) (HEq add✝ add)))","decl":"/-- A helper structure to construct the shift functor `(Discrete A) ⥤ (C ⥤ C)`. -/\nstructure ShiftMkCore where\n  /-- the family of shift functors -/\n  F : A → C ⥤ C\n  /-- the shift by 0 identifies to the identity functor -/\n  zero : F 0 ≅ 𝟭 C\n  /-- the composition of shift functors identifies to the shift by the sum -/\n  add : ∀ n m : A, F (n + m) ≅ F n ⋙ F m\n  /-- compatibility with the associativity -/\n  assoc_hom_app : ∀ (m₁ m₂ m₃ : A) (X : C),\n    (add (m₁ + m₂) m₃).hom.app X ≫ (F m₃).map ((add m₁ m₂).hom.app X) =\n      eqToHom (by rw [add_assoc]) ≫ (add m₁ (m₂ + m₃)).hom.app X ≫\n        (add m₂ m₃).hom.app ((F m₁).obj X) := by aesop_cat\n  /-- compatibility with the left addition with 0 -/\n  zero_add_hom_app : ∀ (n : A) (X : C), (add 0 n).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ≫ (F n).map (zero.inv.app X) := by aesop_cat\n  /-- compatibility with the right addition with 0 -/\n  add_zero_hom_app : ∀ (n : A) (X : C), (add n 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ≫ zero.inv.app ((F n).obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShiftMkCore.assoc_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : AddMonoid A\nself : CategoryTheory.ShiftMkCore C A\nm₁ m₂ m₃ : A\nX Z : C\nh : Quiver.Hom ((self.F m₃).obj ((self.F m₂).obj ((self.F m₁).obj X))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((self.add (HAdd.hAdd m₁ m₂) m₃).hom.app X) (CategoryTheory.CategoryStruct.comp ((self.F m₃).map ((self.add m₁ m₂).hom.app X)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp ((self.add m₁ (HAdd.hAdd m₂ m₃)).hom.app X) (CategoryTheory.CategoryStruct.comp ((self.add m₂ m₃).hom.app ((self.F m₁).obj X)) h)))","decl":"attribute [reassoc] assoc_hom_app\n\n"}
{"name":"CategoryTheory.ShiftMkCore.assoc_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : AddMonoid A\nh : CategoryTheory.ShiftMkCore C A\nm₁ m₂ m₃ : A\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((h.F m₃).map ((h.add m₁ m₂).inv.app X)) ((h.add (HAdd.hAdd m₁ m₂) m₃).inv.app X)) (CategoryTheory.CategoryStruct.comp ((h.add m₂ m₃).inv.app ((h.F m₁).obj X)) (CategoryTheory.CategoryStruct.comp ((h.add m₁ (HAdd.hAdd m₂ m₃)).inv.app X) (CategoryTheory.eqToHom ⋯)))","decl":"@[reassoc]\nlemma assoc_inv_app (h : ShiftMkCore C A) (m₁ m₂ m₃ : A) (X : C) :\n    (h.F m₃).map ((h.add m₁ m₂).inv.app X) ≫ (h.add (m₁ + m₂) m₃).inv.app X =\n    (h.add m₂ m₃).inv.app ((h.F m₁).obj X) ≫ (h.add m₁ (m₂ + m₃)).inv.app X ≫\n      eqToHom (by rw [add_assoc]) := by\n  rw [← cancel_mono ((h.add (m₁ + m₂) m₃).hom.app X ≫ (h.F m₃).map ((h.add m₁ m₂).hom.app X)),\n    Category.assoc, Category.assoc, Category.assoc, Iso.inv_hom_id_app_assoc, ← Functor.map_comp,\n    Iso.inv_hom_id_app, Functor.map_id, h.assoc_hom_app, eqToHom_trans_assoc, eqToHom_refl,\n    Category.id_comp, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app]\n  rfl\n\n"}
{"name":"CategoryTheory.ShiftMkCore.assoc_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : AddMonoid A\nh✝ : CategoryTheory.ShiftMkCore C A\nm₁ m₂ m₃ : A\nX Z : C\nh : Quiver.Hom ((h✝.F (HAdd.hAdd (HAdd.hAdd m₁ m₂) m₃)).obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((h✝.F m₃).map ((h✝.add m₁ m₂).inv.app X)) (CategoryTheory.CategoryStruct.comp ((h✝.add (HAdd.hAdd m₁ m₂) m₃).inv.app X) h)) (CategoryTheory.CategoryStruct.comp ((h✝.add m₂ m₃).inv.app ((h✝.F m₁).obj X)) (CategoryTheory.CategoryStruct.comp ((h✝.add m₁ (HAdd.hAdd m₂ m₃)).inv.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) h)))","decl":"@[reassoc]\nlemma assoc_inv_app (h : ShiftMkCore C A) (m₁ m₂ m₃ : A) (X : C) :\n    (h.F m₃).map ((h.add m₁ m₂).inv.app X) ≫ (h.add (m₁ + m₂) m₃).inv.app X =\n    (h.add m₂ m₃).inv.app ((h.F m₁).obj X) ≫ (h.add m₁ (m₂ + m₃)).inv.app X ≫\n      eqToHom (by rw [add_assoc]) := by\n  rw [← cancel_mono ((h.add (m₁ + m₂) m₃).hom.app X ≫ (h.F m₃).map ((h.add m₁ m₂).hom.app X)),\n    Category.assoc, Category.assoc, Category.assoc, Iso.inv_hom_id_app_assoc, ← Functor.map_comp,\n    Iso.inv_hom_id_app, Functor.map_id, h.assoc_hom_app, eqToHom_trans_assoc, eqToHom_refl,\n    Category.id_comp, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app]\n  rfl\n\n"}
{"name":"CategoryTheory.ShiftMkCore.zero_add_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : AddMonoid A\nh : CategoryTheory.ShiftMkCore C A\nn : A\nX : C\n⊢ Eq ((h.add 0 n).inv.app X) (CategoryTheory.CategoryStruct.comp ((h.F n).map (h.zero.hom.app X)) (CategoryTheory.eqToHom ⋯))","decl":"lemma zero_add_inv_app (h : ShiftMkCore C A) (n : A) (X : C) :\n    (h.add 0 n).inv.app X = (h.F n).map (h.zero.hom.app X) ≫\n      eqToHom (by dsimp; rw [zero_add]) := by\n  rw [← cancel_epi ((h.add 0 n).hom.app X), Iso.hom_inv_id_app, h.zero_add_hom_app,\n    Category.assoc, ← Functor.map_comp_assoc, Iso.inv_hom_id_app, Functor.map_id,\n    Category.id_comp, eqToHom_trans, eqToHom_refl]\n\n"}
{"name":"CategoryTheory.ShiftMkCore.add_zero_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : AddMonoid A\nh : CategoryTheory.ShiftMkCore C A\nn : A\nX : C\n⊢ Eq ((h.add n 0).inv.app X) (CategoryTheory.CategoryStruct.comp (h.zero.hom.app ((h.F n).obj X)) (CategoryTheory.eqToHom ⋯))","decl":"lemma add_zero_inv_app (h : ShiftMkCore C A) (n : A) (X : C) :\n    (h.add n 0).inv.app X = h.zero.hom.app ((h.F n).obj X) ≫\n      eqToHom (by dsimp; rw [add_zero]) := by\n  rw [← cancel_epi ((h.add n 0).hom.app X), Iso.hom_inv_id_app, h.add_zero_hom_app,\n    Category.assoc, Iso.inv_hom_id_app_assoc, eqToHom_trans, eqToHom_refl]\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_eq_shiftFunctorAdd","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\ni j : A\n⊢ Eq (CategoryTheory.shiftFunctorAdd' C i j (HAdd.hAdd i j) ⋯) (CategoryTheory.shiftFunctorAdd C i j)","decl":"lemma shiftFunctorAdd'_eq_shiftFunctorAdd (i j : A) :\n    shiftFunctorAdd' C i j (i+j) rfl = shiftFunctorAdd C i j := by\n  ext1\n  apply Category.id_comp\n\n"}
{"name":"CategoryTheory.ShiftMkCore.shiftFunctor_eq","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : AddMonoid A\nh : CategoryTheory.ShiftMkCore C A\na : A\n⊢ Eq (CategoryTheory.shiftFunctor C a) (h.F a)","decl":"lemma ShiftMkCore.shiftFunctor_eq (h : ShiftMkCore C A) (a : A) :\n    letI := hasShiftMk C A h\n    shiftFunctor C a = h.F a := rfl\n\n"}
{"name":"CategoryTheory.ShiftMkCore.shiftFunctorZero_eq","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : AddMonoid A\nh : CategoryTheory.ShiftMkCore C A\n⊢ Eq (CategoryTheory.shiftFunctorZero C A) h.zero","decl":"lemma ShiftMkCore.shiftFunctorZero_eq (h : ShiftMkCore C A) :\n    letI := hasShiftMk C A h\n    shiftFunctorZero C A = h.zero := rfl\n\n"}
{"name":"CategoryTheory.ShiftMkCore.shiftFunctorAdd_eq","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : AddMonoid A\nh : CategoryTheory.ShiftMkCore C A\na b : A\n⊢ Eq (CategoryTheory.shiftFunctorAdd C a b) (h.add a b)","decl":"lemma ShiftMkCore.shiftFunctorAdd_eq (h : ShiftMkCore C A) (a b : A) :\n    letI := hasShiftMk C A h\n    shiftFunctorAdd C a b = h.add a b := rfl\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_zero_add","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na : A\n⊢ Eq (CategoryTheory.shiftFunctorAdd' C 0 a a ⋯) ((CategoryTheory.shiftFunctor C a).leftUnitor.symm.trans (CategoryTheory.isoWhiskerRight (CategoryTheory.shiftFunctorZero C A).symm (CategoryTheory.shiftFunctor C a)))","decl":"lemma shiftFunctorAdd'_zero_add (a : A) :\n    shiftFunctorAdd' C 0 a a (zero_add a) = (Functor.leftUnitor _).symm ≪≫\n    isoWhiskerRight (shiftFunctorZero C A).symm (shiftFunctor C a) := by\n  ext X\n  dsimp [shiftFunctorAdd', shiftFunctorZero, shiftFunctor]\n  simp only [eqToHom_app, obj_ε_app, Discrete.addMonoidal_leftUnitor, eqToIso.inv,\n    eqToHom_map, Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_add_zero","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na : A\n⊢ Eq (CategoryTheory.shiftFunctorAdd' C a 0 a ⋯) ((CategoryTheory.shiftFunctor C a).rightUnitor.symm.trans (CategoryTheory.isoWhiskerLeft (CategoryTheory.shiftFunctor C a) (CategoryTheory.shiftFunctorZero C A).symm))","decl":"lemma shiftFunctorAdd'_add_zero (a : A) :\n    shiftFunctorAdd' C a 0 a (add_zero a) = (Functor.rightUnitor _).symm ≪≫\n    isoWhiskerLeft (shiftFunctor C a) (shiftFunctorZero C A).symm := by\n  ext\n  dsimp [shiftFunctorAdd', shiftFunctorZero, shiftFunctor]\n  simp only [eqToHom_app, ε_app_obj, Discrete.addMonoidal_rightUnitor, eqToIso.inv,\n    eqToHom_map, Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na₁ a₂ a₃ a₁₂ a₂₃ a₁₂₃ : A\nh₁₂ : Eq (HAdd.hAdd a₁ a₂) a₁₂\nh₂₃ : Eq (HAdd.hAdd a₂ a₃) a₂₃\nh₁₂₃ : Eq (HAdd.hAdd (HAdd.hAdd a₁ a₂) a₃) a₁₂₃\n⊢ Eq ((CategoryTheory.shiftFunctorAdd' C a₁₂ a₃ a₁₂₃ ⋯).trans ((CategoryTheory.isoWhiskerRight (CategoryTheory.shiftFunctorAdd' C a₁ a₂ a₁₂ h₁₂) (CategoryTheory.shiftFunctor C a₃)).trans ((CategoryTheory.shiftFunctor C a₁).associator (CategoryTheory.shiftFunctor C a₂) (CategoryTheory.shiftFunctor C a₃)))) ((CategoryTheory.shiftFunctorAdd' C a₁ a₂₃ a₁₂₃ ⋯).trans (CategoryTheory.isoWhiskerLeft (CategoryTheory.shiftFunctor C a₁) (CategoryTheory.shiftFunctorAdd' C a₂ a₃ a₂₃ h₂₃)))","decl":"lemma shiftFunctorAdd'_assoc (a₁ a₂ a₃ a₁₂ a₂₃ a₁₂₃ : A)\n    (h₁₂ : a₁ + a₂ = a₁₂) (h₂₃ : a₂ + a₃ = a₂₃) (h₁₂₃ : a₁ + a₂ + a₃ = a₁₂₃) :\n    shiftFunctorAdd' C a₁₂ a₃ a₁₂₃ (by rw [← h₁₂, h₁₂₃]) ≪≫\n      isoWhiskerRight (shiftFunctorAdd' C a₁ a₂ a₁₂ h₁₂) _ ≪≫ Functor.associator _ _ _ =\n    shiftFunctorAdd' C a₁ a₂₃ a₁₂₃ (by rw [← h₂₃, ← add_assoc, h₁₂₃]) ≪≫\n      isoWhiskerLeft _ (shiftFunctorAdd' C a₂ a₃ a₂₃ h₂₃) := by\n  subst h₁₂ h₂₃ h₁₂₃\n  ext X\n  dsimp\n  simp only [shiftFunctorAdd'_eq_shiftFunctorAdd, Category.comp_id]\n  dsimp [shiftFunctorAdd']\n  simp only [eqToHom_app]\n  dsimp [shiftFunctorAdd, shiftFunctor]\n  simp only [obj_μ_inv_app, Discrete.addMonoidal_associator, eqToIso.hom, eqToHom_map,\n    eqToHom_app]\n  erw [δ_μ_app_assoc, Category.assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na₁ a₂ a₃ : A\n⊢ Eq ((CategoryTheory.shiftFunctorAdd C (HAdd.hAdd a₁ a₂) a₃).trans ((CategoryTheory.isoWhiskerRight (CategoryTheory.shiftFunctorAdd C a₁ a₂) (CategoryTheory.shiftFunctor C a₃)).trans ((CategoryTheory.shiftFunctor C a₁).associator (CategoryTheory.shiftFunctor C a₂) (CategoryTheory.shiftFunctor C a₃)))) ((CategoryTheory.shiftFunctorAdd' C a₁ (HAdd.hAdd a₂ a₃) (HAdd.hAdd (HAdd.hAdd a₁ a₂) a₃) ⋯).trans (CategoryTheory.isoWhiskerLeft (CategoryTheory.shiftFunctor C a₁) (CategoryTheory.shiftFunctorAdd C a₂ a₃)))","decl":"lemma shiftFunctorAdd_assoc (a₁ a₂ a₃ : A) :\n    shiftFunctorAdd C (a₁ + a₂) a₃ ≪≫\n      isoWhiskerRight (shiftFunctorAdd C a₁ a₂) _ ≪≫ Functor.associator _ _ _ =\n    shiftFunctorAdd' C a₁ (a₂ + a₃) _ (add_assoc a₁ a₂ a₃).symm ≪≫\n      isoWhiskerLeft _ (shiftFunctorAdd C a₂ a₃) := by\n  ext X\n  simpa [shiftFunctorAdd'_eq_shiftFunctorAdd]\n    using NatTrans.congr_app (congr_arg Iso.hom\n      (shiftFunctorAdd'_assoc C a₁ a₂ a₃ _ _ _ rfl rfl rfl)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_zero_add_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorAdd' C 0 a a ⋯).hom.app X) ((CategoryTheory.shiftFunctor C a).map ((CategoryTheory.shiftFunctorZero C A).inv.app X))","decl":"lemma shiftFunctorAdd'_zero_add_hom_app (a : A) (X : C) :\n    (shiftFunctorAdd' C 0 a a (zero_add a)).hom.app X =\n    ((shiftFunctorZero C A).inv.app X)⟦a⟧' := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorAdd'_zero_add C a)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_zero_add_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorAdd C 0 a).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) ((CategoryTheory.shiftFunctor C a).map ((CategoryTheory.shiftFunctorZero C A).inv.app X)))","decl":"lemma shiftFunctorAdd_zero_add_hom_app (a : A) (X : C) :\n    (shiftFunctorAdd C 0 a).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ≫ ((shiftFunctorZero C A).inv.app X)⟦a⟧' := by\n  simp [← shiftFunctorAdd'_zero_add_hom_app, shiftFunctorAdd']\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_zero_add_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorAdd' C 0 a a ⋯).inv.app X) ((CategoryTheory.shiftFunctor C a).map ((CategoryTheory.shiftFunctorZero C A).hom.app X))","decl":"lemma shiftFunctorAdd'_zero_add_inv_app (a : A) (X : C) :\n    (shiftFunctorAdd' C 0 a a (zero_add a)).inv.app X =\n    ((shiftFunctorZero C A).hom.app X)⟦a⟧' := by\n  simpa using NatTrans.congr_app (congr_arg Iso.inv (shiftFunctorAdd'_zero_add C a)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_zero_add_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorAdd C 0 a).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map ((CategoryTheory.shiftFunctorZero C A).hom.app X)) (CategoryTheory.eqToHom ⋯))","decl":"lemma shiftFunctorAdd_zero_add_inv_app (a : A) (X : C) : (shiftFunctorAdd C 0 a).inv.app X =\n    ((shiftFunctorZero C A).hom.app X)⟦a⟧' ≫ eqToHom (by dsimp; rw [zero_add]) := by\n  simp [← shiftFunctorAdd'_zero_add_inv_app, shiftFunctorAdd']\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_add_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorAdd' C a 0 a ⋯).hom.app X) ((CategoryTheory.shiftFunctorZero C A).inv.app ((CategoryTheory.shiftFunctor C a).obj X))","decl":"lemma shiftFunctorAdd'_add_zero_hom_app (a : A) (X : C) :\n    (shiftFunctorAdd' C a 0 a (add_zero a)).hom.app X =\n    (shiftFunctorZero C A).inv.app (X⟦a⟧) := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorAdd'_add_zero C a)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_add_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorAdd C a 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) ((CategoryTheory.shiftFunctorZero C A).inv.app ((CategoryTheory.shiftFunctor C a).obj X)))","decl":"lemma shiftFunctorAdd_add_zero_hom_app (a : A) (X : C) : (shiftFunctorAdd C a 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ≫ (shiftFunctorZero C A).inv.app (X⟦a⟧) := by\n  simp [← shiftFunctorAdd'_add_zero_hom_app, shiftFunctorAdd']\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_add_zero_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorAdd' C a 0 a ⋯).inv.app X) ((CategoryTheory.shiftFunctorZero C A).hom.app ((CategoryTheory.shiftFunctor C a).obj X))","decl":"lemma shiftFunctorAdd'_add_zero_inv_app (a : A) (X : C) :\n    (shiftFunctorAdd' C a 0 a (add_zero a)).inv.app X =\n    (shiftFunctorZero C A).hom.app (X⟦a⟧) := by\n  simpa using NatTrans.congr_app (congr_arg Iso.inv (shiftFunctorAdd'_add_zero C a)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_add_zero_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorAdd C a 0).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero C A).hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.eqToHom ⋯))","decl":"lemma shiftFunctorAdd_add_zero_inv_app (a : A) (X : C) : (shiftFunctorAdd C a 0).inv.app X =\n    (shiftFunctorZero C A).hom.app (X⟦a⟧) ≫ eqToHom (by dsimp; rw [add_zero]) := by\n  simp [← shiftFunctorAdd'_add_zero_inv_app, shiftFunctorAdd']\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_assoc_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na₁ a₂ a₃ a₁₂ a₂₃ a₁₂₃ : A\nh₁₂ : Eq (HAdd.hAdd a₁ a₂) a₁₂\nh₂₃ : Eq (HAdd.hAdd a₂ a₃) a₂₃\nh₁₂₃ : Eq (HAdd.hAdd (HAdd.hAdd a₁ a₂) a₃) a₁₂₃\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C a₃).obj ((CategoryTheory.shiftFunctor C a₂).obj ((CategoryTheory.shiftFunctor C a₁).obj X))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a₁₂ a₃ a₁₂₃ ⋯).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a₃).map ((CategoryTheory.shiftFunctorAdd' C a₁ a₂ a₁₂ h₁₂).hom.app X)) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a₁ a₂₃ a₁₂₃ ⋯).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a₂ a₃ a₂₃ h₂₃).hom.app ((CategoryTheory.shiftFunctor C a₁).obj X)) h))","decl":"@[reassoc]\nlemma shiftFunctorAdd'_assoc_hom_app (a₁ a₂ a₃ a₁₂ a₂₃ a₁₂₃ : A)\n    (h₁₂ : a₁ + a₂ = a₁₂) (h₂₃ : a₂ + a₃ = a₂₃) (h₁₂₃ : a₁ + a₂ + a₃ = a₁₂₃) (X : C) :\n    (shiftFunctorAdd' C a₁₂ a₃ a₁₂₃ (by rw [← h₁₂, h₁₂₃])).hom.app X ≫\n      ((shiftFunctorAdd' C a₁ a₂ a₁₂ h₁₂).hom.app X)⟦a₃⟧' =\n    (shiftFunctorAdd' C a₁ a₂₃ a₁₂₃ (by rw [← h₂₃, ← add_assoc, h₁₂₃])).hom.app X ≫\n      (shiftFunctorAdd' C a₂ a₃ a₂₃ h₂₃).hom.app (X⟦a₁⟧) := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom\n    (shiftFunctorAdd'_assoc C _ _ _ _ _ _ h₁₂ h₂₃ h₁₂₃)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_assoc_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na₁ a₂ a₃ a₁₂ a₂₃ a₁₂₃ : A\nh₁₂ : Eq (HAdd.hAdd a₁ a₂) a₁₂\nh₂₃ : Eq (HAdd.hAdd a₂ a₃) a₂₃\nh₁₂₃ : Eq (HAdd.hAdd (HAdd.hAdd a₁ a₂) a₃) a₁₂₃\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a₁₂ a₃ a₁₂₃ ⋯).hom.app X) ((CategoryTheory.shiftFunctor C a₃).map ((CategoryTheory.shiftFunctorAdd' C a₁ a₂ a₁₂ h₁₂).hom.app X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a₁ a₂₃ a₁₂₃ ⋯).hom.app X) ((CategoryTheory.shiftFunctorAdd' C a₂ a₃ a₂₃ h₂₃).hom.app ((CategoryTheory.shiftFunctor C a₁).obj X)))","decl":"@[reassoc]\nlemma shiftFunctorAdd'_assoc_hom_app (a₁ a₂ a₃ a₁₂ a₂₃ a₁₂₃ : A)\n    (h₁₂ : a₁ + a₂ = a₁₂) (h₂₃ : a₂ + a₃ = a₂₃) (h₁₂₃ : a₁ + a₂ + a₃ = a₁₂₃) (X : C) :\n    (shiftFunctorAdd' C a₁₂ a₃ a₁₂₃ (by rw [← h₁₂, h₁₂₃])).hom.app X ≫\n      ((shiftFunctorAdd' C a₁ a₂ a₁₂ h₁₂).hom.app X)⟦a₃⟧' =\n    (shiftFunctorAdd' C a₁ a₂₃ a₁₂₃ (by rw [← h₂₃, ← add_assoc, h₁₂₃])).hom.app X ≫\n      (shiftFunctorAdd' C a₂ a₃ a₂₃ h₂₃).hom.app (X⟦a₁⟧) := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom\n    (shiftFunctorAdd'_assoc C _ _ _ _ _ _ h₁₂ h₂₃ h₁₂₃)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_assoc_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na₁ a₂ a₃ a₁₂ a₂₃ a₁₂₃ : A\nh₁₂ : Eq (HAdd.hAdd a₁ a₂) a₁₂\nh₂₃ : Eq (HAdd.hAdd a₂ a₃) a₂₃\nh₁₂₃ : Eq (HAdd.hAdd (HAdd.hAdd a₁ a₂) a₃) a₁₂₃\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C a₁₂₃).obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a₃).map ((CategoryTheory.shiftFunctorAdd' C a₁ a₂ a₁₂ h₁₂).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a₁₂ a₃ a₁₂₃ ⋯).inv.app X) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a₂ a₃ a₂₃ h₂₃).inv.app ((CategoryTheory.shiftFunctor C a₁).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a₁ a₂₃ a₁₂₃ ⋯).inv.app X) h))","decl":"@[reassoc]\nlemma shiftFunctorAdd'_assoc_inv_app (a₁ a₂ a₃ a₁₂ a₂₃ a₁₂₃ : A)\n    (h₁₂ : a₁ + a₂ = a₁₂) (h₂₃ : a₂ + a₃ = a₂₃) (h₁₂₃ : a₁ + a₂ + a₃ = a₁₂₃) (X : C) :\n    ((shiftFunctorAdd' C a₁ a₂ a₁₂ h₁₂).inv.app X)⟦a₃⟧' ≫\n      (shiftFunctorAdd' C a₁₂ a₃ a₁₂₃ (by rw [← h₁₂, h₁₂₃])).inv.app X =\n    (shiftFunctorAdd' C a₂ a₃ a₂₃ h₂₃).inv.app (X⟦a₁⟧) ≫\n      (shiftFunctorAdd' C a₁ a₂₃ a₁₂₃ (by rw [← h₂₃, ← add_assoc, h₁₂₃])).inv.app X := by\n  simpa using NatTrans.congr_app (congr_arg Iso.inv\n    (shiftFunctorAdd'_assoc C _ _ _ _ _ _ h₁₂ h₂₃ h₁₂₃)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_assoc_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na₁ a₂ a₃ a₁₂ a₂₃ a₁₂₃ : A\nh₁₂ : Eq (HAdd.hAdd a₁ a₂) a₁₂\nh₂₃ : Eq (HAdd.hAdd a₂ a₃) a₂₃\nh₁₂₃ : Eq (HAdd.hAdd (HAdd.hAdd a₁ a₂) a₃) a₁₂₃\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a₃).map ((CategoryTheory.shiftFunctorAdd' C a₁ a₂ a₁₂ h₁₂).inv.app X)) ((CategoryTheory.shiftFunctorAdd' C a₁₂ a₃ a₁₂₃ ⋯).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a₂ a₃ a₂₃ h₂₃).inv.app ((CategoryTheory.shiftFunctor C a₁).obj X)) ((CategoryTheory.shiftFunctorAdd' C a₁ a₂₃ a₁₂₃ ⋯).inv.app X))","decl":"@[reassoc]\nlemma shiftFunctorAdd'_assoc_inv_app (a₁ a₂ a₃ a₁₂ a₂₃ a₁₂₃ : A)\n    (h₁₂ : a₁ + a₂ = a₁₂) (h₂₃ : a₂ + a₃ = a₂₃) (h₁₂₃ : a₁ + a₂ + a₃ = a₁₂₃) (X : C) :\n    ((shiftFunctorAdd' C a₁ a₂ a₁₂ h₁₂).inv.app X)⟦a₃⟧' ≫\n      (shiftFunctorAdd' C a₁₂ a₃ a₁₂₃ (by rw [← h₁₂, h₁₂₃])).inv.app X =\n    (shiftFunctorAdd' C a₂ a₃ a₂₃ h₂₃).inv.app (X⟦a₁⟧) ≫\n      (shiftFunctorAdd' C a₁ a₂₃ a₁₂₃ (by rw [← h₂₃, ← add_assoc, h₁₂₃])).inv.app X := by\n  simpa using NatTrans.congr_app (congr_arg Iso.inv\n    (shiftFunctorAdd'_assoc C _ _ _ _ _ _ h₁₂ h₂₃ h₁₂₃)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_assoc_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na₁ a₂ a₃ : A\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C (HAdd.hAdd a₁ a₂) a₃).hom.app X) ((CategoryTheory.shiftFunctor C a₃).map ((CategoryTheory.shiftFunctorAdd C a₁ a₂).hom.app X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a₁ (HAdd.hAdd a₂ a₃) (HAdd.hAdd (HAdd.hAdd a₁ a₂) a₃) ⋯).hom.app X) ((CategoryTheory.shiftFunctorAdd C a₂ a₃).hom.app ((CategoryTheory.shiftFunctor C a₁).obj X)))","decl":"@[reassoc]\nlemma shiftFunctorAdd_assoc_hom_app (a₁ a₂ a₃ : A) (X : C) :\n    (shiftFunctorAdd C (a₁ + a₂) a₃).hom.app X ≫\n      ((shiftFunctorAdd C a₁ a₂).hom.app X)⟦a₃⟧' =\n    (shiftFunctorAdd' C a₁ (a₂ + a₃) (a₁ + a₂ + a₃) (add_assoc _ _ _).symm).hom.app X ≫\n      (shiftFunctorAdd C a₂ a₃).hom.app (X⟦a₁⟧) := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorAdd_assoc C a₁ a₂ a₃)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_assoc_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na₁ a₂ a₃ : A\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C a₃).obj ((CategoryTheory.shiftFunctor C a₂).obj ((CategoryTheory.shiftFunctor C a₁).obj X))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C (HAdd.hAdd a₁ a₂) a₃).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a₃).map ((CategoryTheory.shiftFunctorAdd C a₁ a₂).hom.app X)) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a₁ (HAdd.hAdd a₂ a₃) (HAdd.hAdd (HAdd.hAdd a₁ a₂) a₃) ⋯).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C a₂ a₃).hom.app ((CategoryTheory.shiftFunctor C a₁).obj X)) h))","decl":"@[reassoc]\nlemma shiftFunctorAdd_assoc_hom_app (a₁ a₂ a₃ : A) (X : C) :\n    (shiftFunctorAdd C (a₁ + a₂) a₃).hom.app X ≫\n      ((shiftFunctorAdd C a₁ a₂).hom.app X)⟦a₃⟧' =\n    (shiftFunctorAdd' C a₁ (a₂ + a₃) (a₁ + a₂ + a₃) (add_assoc _ _ _).symm).hom.app X ≫\n      (shiftFunctorAdd C a₂ a₃).hom.app (X⟦a₁⟧) := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorAdd_assoc C a₁ a₂ a₃)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_assoc_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na₁ a₂ a₃ : A\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a₃).map ((CategoryTheory.shiftFunctorAdd C a₁ a₂).inv.app X)) ((CategoryTheory.shiftFunctorAdd C (HAdd.hAdd a₁ a₂) a₃).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C a₂ a₃).inv.app ((CategoryTheory.shiftFunctor C a₁).obj X)) ((CategoryTheory.shiftFunctorAdd' C a₁ (HAdd.hAdd a₂ a₃) (HAdd.hAdd (HAdd.hAdd a₁ a₂) a₃) ⋯).inv.app X))","decl":"@[reassoc]\nlemma shiftFunctorAdd_assoc_inv_app (a₁ a₂ a₃ : A) (X : C) :\n    ((shiftFunctorAdd C a₁ a₂).inv.app X)⟦a₃⟧' ≫\n      (shiftFunctorAdd C (a₁ + a₂) a₃).inv.app X =\n    (shiftFunctorAdd C a₂ a₃).inv.app (X⟦a₁⟧) ≫\n      (shiftFunctorAdd' C a₁ (a₂ + a₃) (a₁ + a₂ + a₃) (add_assoc _ _ _).symm).inv.app X := by\n  simpa using NatTrans.congr_app (congr_arg Iso.inv (shiftFunctorAdd_assoc C a₁ a₂ a₃)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_assoc_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na₁ a₂ a₃ : A\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C (HAdd.hAdd (HAdd.hAdd a₁ a₂) a₃)).obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a₃).map ((CategoryTheory.shiftFunctorAdd C a₁ a₂).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C (HAdd.hAdd a₁ a₂) a₃).inv.app X) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C a₂ a₃).inv.app ((CategoryTheory.shiftFunctor C a₁).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a₁ (HAdd.hAdd a₂ a₃) (HAdd.hAdd (HAdd.hAdd a₁ a₂) a₃) ⋯).inv.app X) h))","decl":"@[reassoc]\nlemma shiftFunctorAdd_assoc_inv_app (a₁ a₂ a₃ : A) (X : C) :\n    ((shiftFunctorAdd C a₁ a₂).inv.app X)⟦a₃⟧' ≫\n      (shiftFunctorAdd C (a₁ + a₂) a₃).inv.app X =\n    (shiftFunctorAdd C a₂ a₃).inv.app (X⟦a₁⟧) ≫\n      (shiftFunctorAdd' C a₁ (a₂ + a₃) (a₁ + a₂ + a₃) (add_assoc _ _ _).symm).inv.app X := by\n  simpa using NatTrans.congr_app (congr_arg Iso.inv (shiftFunctorAdd_assoc C a₁ a₂ a₃)) X\n\n"}
{"name":"CategoryTheory.shift_shift'","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\ni j : A\n⊢ Eq ((CategoryTheory.shiftFunctor C j).map ((CategoryTheory.shiftFunctor C i).map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.shiftAdd X i j).inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C (HAdd.hAdd i j)).map f) (CategoryTheory.shiftAdd Y i j).hom))","decl":"theorem shift_shift' (i j : A) :\n    f⟦i⟧'⟦j⟧' = (shiftAdd X i j).inv ≫ f⟦i + j⟧' ≫ (shiftAdd Y i j).hom := by\n  symm\n  rw [← Functor.comp_map, NatIso.app_inv]\n  apply NatIso.naturality_1\n\n"}
{"name":"CategoryTheory.shiftZero'","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.shiftFunctor C 0).map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.shiftZero A X).hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.shiftZero A Y).inv))","decl":"theorem shiftZero' : f⟦(0 : A)⟧' = (shiftZero A X).hom ≫ f ≫ (shiftZero A Y).inv := by\n  symm\n  rw [NatIso.app_inv, NatIso.app_hom]\n  apply NatIso.naturality_2\n\n"}
{"name":"CategoryTheory.shiftEquiv'_counitIso","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\ni j : A\nh : Eq (HAdd.hAdd i j) 0\n⊢ Eq (CategoryTheory.shiftEquiv' C i j h).counitIso (CategoryTheory.shiftFunctorCompIsoId C j i ⋯)","decl":"/-- Shifting by `i` and shifting by `j` forms an equivalence when `i + j = 0`. -/\n@[simps]\ndef shiftEquiv' (i j : A) (h : i + j = 0) : C ≌ C where\n  functor := shiftFunctor C i\n  inverse := shiftFunctor C j\n  unitIso := (shiftFunctorCompIsoId C i j h).symm\n  counitIso := shiftFunctorCompIsoId C j i\n    (by rw [← add_left_inj j, add_assoc, h, zero_add, add_zero])\n  functor_unitIso_comp X := by\n    convert (equivOfTensorIsoUnit (shiftMonoidalFunctor C A) ⟨i⟩ ⟨j⟩ (Discrete.eqToIso h)\n      (Discrete.eqToIso (by dsimp; rw [← add_left_inj j, add_assoc, h, zero_add, add_zero]))\n      (Subsingleton.elim _ _)).functor_unitIso_comp X\n    all_goals\n      ext X\n      dsimp [shiftFunctorCompIsoId, unitOfTensorIsoUnit,\n        shiftFunctorAdd']\n      simp only [Category.assoc, eqToHom_map]\n      rfl\n\n"}
{"name":"CategoryTheory.shiftEquiv'_unitIso","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\ni j : A\nh : Eq (HAdd.hAdd i j) 0\n⊢ Eq (CategoryTheory.shiftEquiv' C i j h).unitIso (CategoryTheory.shiftFunctorCompIsoId C i j h).symm","decl":"/-- Shifting by `i` and shifting by `j` forms an equivalence when `i + j = 0`. -/\n@[simps]\ndef shiftEquiv' (i j : A) (h : i + j = 0) : C ≌ C where\n  functor := shiftFunctor C i\n  inverse := shiftFunctor C j\n  unitIso := (shiftFunctorCompIsoId C i j h).symm\n  counitIso := shiftFunctorCompIsoId C j i\n    (by rw [← add_left_inj j, add_assoc, h, zero_add, add_zero])\n  functor_unitIso_comp X := by\n    convert (equivOfTensorIsoUnit (shiftMonoidalFunctor C A) ⟨i⟩ ⟨j⟩ (Discrete.eqToIso h)\n      (Discrete.eqToIso (by dsimp; rw [← add_left_inj j, add_assoc, h, zero_add, add_zero]))\n      (Subsingleton.elim _ _)).functor_unitIso_comp X\n    all_goals\n      ext X\n      dsimp [shiftFunctorCompIsoId, unitOfTensorIsoUnit,\n        shiftFunctorAdd']\n      simp only [Category.assoc, eqToHom_map]\n      rfl\n\n"}
{"name":"CategoryTheory.shiftEquiv'_functor","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\ni j : A\nh : Eq (HAdd.hAdd i j) 0\n⊢ Eq (CategoryTheory.shiftEquiv' C i j h).functor (CategoryTheory.shiftFunctor C i)","decl":"/-- Shifting by `i` and shifting by `j` forms an equivalence when `i + j = 0`. -/\n@[simps]\ndef shiftEquiv' (i j : A) (h : i + j = 0) : C ≌ C where\n  functor := shiftFunctor C i\n  inverse := shiftFunctor C j\n  unitIso := (shiftFunctorCompIsoId C i j h).symm\n  counitIso := shiftFunctorCompIsoId C j i\n    (by rw [← add_left_inj j, add_assoc, h, zero_add, add_zero])\n  functor_unitIso_comp X := by\n    convert (equivOfTensorIsoUnit (shiftMonoidalFunctor C A) ⟨i⟩ ⟨j⟩ (Discrete.eqToIso h)\n      (Discrete.eqToIso (by dsimp; rw [← add_left_inj j, add_assoc, h, zero_add, add_zero]))\n      (Subsingleton.elim _ _)).functor_unitIso_comp X\n    all_goals\n      ext X\n      dsimp [shiftFunctorCompIsoId, unitOfTensorIsoUnit,\n        shiftFunctorAdd']\n      simp only [Category.assoc, eqToHom_map]\n      rfl\n\n"}
{"name":"CategoryTheory.shiftEquiv'_inverse","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\ni j : A\nh : Eq (HAdd.hAdd i j) 0\n⊢ Eq (CategoryTheory.shiftEquiv' C i j h).inverse (CategoryTheory.shiftFunctor C j)","decl":"/-- Shifting by `i` and shifting by `j` forms an equivalence when `i + j = 0`. -/\n@[simps]\ndef shiftEquiv' (i j : A) (h : i + j = 0) : C ≌ C where\n  functor := shiftFunctor C i\n  inverse := shiftFunctor C j\n  unitIso := (shiftFunctorCompIsoId C i j h).symm\n  counitIso := shiftFunctorCompIsoId C j i\n    (by rw [← add_left_inj j, add_assoc, h, zero_add, add_zero])\n  functor_unitIso_comp X := by\n    convert (equivOfTensorIsoUnit (shiftMonoidalFunctor C A) ⟨i⟩ ⟨j⟩ (Discrete.eqToIso h)\n      (Discrete.eqToIso (by dsimp; rw [← add_left_inj j, add_assoc, h, zero_add, add_zero]))\n      (Subsingleton.elim _ _)).functor_unitIso_comp X\n    all_goals\n      ext X\n      dsimp [shiftFunctorCompIsoId, unitOfTensorIsoUnit,\n        shiftFunctorAdd']\n      simp only [Category.assoc, eqToHom_map]\n      rfl\n\n"}
{"name":"CategoryTheory.instIsEquivalenceShiftFunctor","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\ni : A\n⊢ (CategoryTheory.shiftFunctor C i).IsEquivalence","decl":"/-- Shifting by `i` is an equivalence. -/\ninstance (i : A) : (shiftFunctor C i).IsEquivalence := by\n  change (shiftEquiv C i).functor.IsEquivalence\n  infer_instance\n\n"}
{"name":"CategoryTheory.shift_shift_neg'","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\ni : A\n⊢ Eq ((CategoryTheory.shiftFunctor C (Neg.neg i)).map ((CategoryTheory.shiftFunctor C i).map f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId C i (Neg.neg i) ⋯).hom.app X) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.shiftFunctorCompIsoId C i (Neg.neg i) ⋯).inv.app Y)))","decl":"theorem shift_shift_neg' (i : A) :\n    f⟦i⟧'⟦-i⟧' = (shiftFunctorCompIsoId C i (-i) (add_neg_cancel i)).hom.app X ≫\n      f ≫ (shiftFunctorCompIsoId C i (-i) (add_neg_cancel i)).inv.app Y :=\n  (NatIso.naturality_2 (shiftFunctorCompIsoId C i (-i) (add_neg_cancel i)) f).symm\n\n"}
{"name":"CategoryTheory.shift_neg_shift'","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\ni : A\n⊢ Eq ((CategoryTheory.shiftFunctor C i).map ((CategoryTheory.shiftFunctor C (Neg.neg i)).map f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId C (Neg.neg i) i ⋯).hom.app X) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.shiftFunctorCompIsoId C (Neg.neg i) i ⋯).inv.app Y)))","decl":"theorem shift_neg_shift' (i : A) :\n    f⟦-i⟧'⟦i⟧' = (shiftFunctorCompIsoId C (-i) i (neg_add_cancel i)).hom.app X ≫ f ≫\n      (shiftFunctorCompIsoId C (-i) i (neg_add_cancel i)).inv.app Y :=\n  (NatIso.naturality_2 (shiftFunctorCompIsoId C (-i) i (neg_add_cancel i)) f).symm\n\n"}
{"name":"CategoryTheory.shift_equiv_triangle","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\nn : A\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map (CategoryTheory.shiftShiftNeg X n).inv) (CategoryTheory.shiftNegShift ((CategoryTheory.shiftFunctor C n).obj X) n).hom) (CategoryTheory.CategoryStruct.id ((CategoryTheory.shiftFunctor C n).obj X))","decl":"theorem shift_equiv_triangle (n : A) (X : C) :\n    (shiftShiftNeg X n).inv⟦n⟧' ≫ (shiftNegShift (X⟦n⟧) n).hom = 𝟙 (X⟦n⟧) :=\n  (shiftEquiv C n).functor_unitIso_comp X\n\n"}
{"name":"CategoryTheory.shift_shiftFunctorCompIsoId_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\nn m : A\nh : Eq (HAdd.hAdd n m) 0\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorCompIsoId C n m h).hom.app X)) ((CategoryTheory.shiftFunctorCompIsoId C m n ⋯).hom.app ((CategoryTheory.shiftFunctor C n).obj X))","decl":"theorem shift_shiftFunctorCompIsoId_hom_app (n m : A) (h : n + m = 0) (X : C) :\n    ((shiftFunctorCompIsoId C n m h).hom.app X)⟦n⟧' =\n    (shiftFunctorCompIsoId C m n\n      (by rw [← neg_eq_of_add_eq_zero_left h, add_neg_cancel])).hom.app (X⟦n⟧) := by\n  dsimp [shiftFunctorCompIsoId]\n  simpa only [Functor.map_comp, ← shiftFunctorAdd'_zero_add_inv_app n X,\n    ← shiftFunctorAdd'_add_zero_inv_app n X]\n    using shiftFunctorAdd'_assoc_inv_app n m n 0 0 n h\n      (by rw [← neg_eq_of_add_eq_zero_left h, add_neg_cancel]) (by rw [h, zero_add]) X\n\n"}
{"name":"CategoryTheory.shift_shiftFunctorCompIsoId_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\nn m : A\nh : Eq (HAdd.hAdd n m) 0\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorCompIsoId C n m h).inv.app X)) ((CategoryTheory.shiftFunctorCompIsoId C m n ⋯).inv.app ((CategoryTheory.shiftFunctor C n).obj X))","decl":"theorem shift_shiftFunctorCompIsoId_inv_app (n m : A) (h : n + m = 0) (X : C) :\n    ((shiftFunctorCompIsoId C n m h).inv.app X)⟦n⟧' =\n    ((shiftFunctorCompIsoId C m n\n      (by rw [← neg_eq_of_add_eq_zero_left h, add_neg_cancel])).inv.app (X⟦n⟧)) := by\n  rw [← cancel_mono (((shiftFunctorCompIsoId C n m h).hom.app X)⟦n⟧'),\n    ← Functor.map_comp, Iso.inv_hom_id_app, Functor.map_id,\n    shift_shiftFunctorCompIsoId_hom_app, Iso.inv_hom_id_app]\n  rfl\n\n"}
{"name":"CategoryTheory.shift_shiftFunctorCompIsoId_add_neg_cancel_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\nn : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorCompIsoId C n (Neg.neg n) ⋯).hom.app X)) ((CategoryTheory.shiftFunctorCompIsoId C (Neg.neg n) n ⋯).hom.app ((CategoryTheory.shiftFunctor C n).obj X))","decl":"theorem shift_shiftFunctorCompIsoId_add_neg_cancel_hom_app (n : A) (X : C) :\n    ((shiftFunctorCompIsoId C n (-n) (add_neg_cancel n)).hom.app X)⟦n⟧' =\n    (shiftFunctorCompIsoId C (-n) n (neg_add_cancel n)).hom.app (X⟦n⟧) := by\n  apply shift_shiftFunctorCompIsoId_hom_app\n\n"}
{"name":"CategoryTheory.shift_shiftFunctorCompIsoId_add_neg_cancel_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\nn : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorCompIsoId C n (Neg.neg n) ⋯).inv.app X)) ((CategoryTheory.shiftFunctorCompIsoId C (Neg.neg n) n ⋯).inv.app ((CategoryTheory.shiftFunctor C n).obj X))","decl":"theorem shift_shiftFunctorCompIsoId_add_neg_cancel_inv_app (n : A) (X : C) :\n    ((shiftFunctorCompIsoId C n (-n) (add_neg_cancel n)).inv.app X)⟦n⟧' =\n    (shiftFunctorCompIsoId C (-n) n (neg_add_cancel n)).inv.app (X⟦n⟧) := by\n  apply shift_shiftFunctorCompIsoId_inv_app\n\n"}
{"name":"CategoryTheory.shift_shiftFunctorCompIsoId_neg_add_cancel_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\nn : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctor C (Neg.neg n)).map ((CategoryTheory.shiftFunctorCompIsoId C (Neg.neg n) n ⋯).hom.app X)) ((CategoryTheory.shiftFunctorCompIsoId C n (Neg.neg n) ⋯).hom.app ((CategoryTheory.shiftFunctor C (Neg.neg n)).obj X))","decl":"theorem shift_shiftFunctorCompIsoId_neg_add_cancel_hom_app (n : A) (X : C) :\n    ((shiftFunctorCompIsoId C (-n) n (neg_add_cancel n)).hom.app X)⟦-n⟧' =\n    (shiftFunctorCompIsoId C n (-n) (add_neg_cancel n)).hom.app (X⟦-n⟧) := by\n  apply shift_shiftFunctorCompIsoId_hom_app\n\n"}
{"name":"CategoryTheory.shift_shiftFunctorCompIsoId_neg_add_cancel_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\nn : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctor C (Neg.neg n)).map ((CategoryTheory.shiftFunctorCompIsoId C (Neg.neg n) n ⋯).inv.app X)) ((CategoryTheory.shiftFunctorCompIsoId C n (Neg.neg n) ⋯).inv.app ((CategoryTheory.shiftFunctor C (Neg.neg n)).obj X))","decl":"theorem shift_shiftFunctorCompIsoId_neg_add_cancel_inv_app (n : A) (X : C) :\n    ((shiftFunctorCompIsoId C (-n) n (neg_add_cancel n)).inv.app X)⟦-n⟧' =\n    (shiftFunctorCompIsoId C n (-n) (add_neg_cancel n)).inv.app (X⟦-n⟧) := by\n  apply shift_shiftFunctorCompIsoId_inv_app\n\n"}
{"name":"CategoryTheory.shiftFunctorCompIsoId_zero_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorCompIsoId C 0 0 ⋯).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C 0).map ((CategoryTheory.shiftFunctorZero C A).hom.app X)) ((CategoryTheory.shiftFunctorZero C A).hom.app X))","decl":"lemma shiftFunctorCompIsoId_zero_zero_hom_app (X : C) :\n    (shiftFunctorCompIsoId C 0 0 (add_zero 0)).hom.app X =\n      ((shiftFunctorZero C A).hom.app X)⟦0⟧' ≫ (shiftFunctorZero C A).hom.app X := by\n  simp [shiftFunctorCompIsoId, shiftFunctorAdd'_zero_add_inv_app]\n\n"}
{"name":"CategoryTheory.shiftFunctorCompIsoId_zero_zero_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctorCompIsoId C 0 0 ⋯).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero C A).inv.app X) ((CategoryTheory.shiftFunctor C 0).map ((CategoryTheory.shiftFunctorZero C A).inv.app X)))","decl":"lemma shiftFunctorCompIsoId_zero_zero_inv_app (X : C) :\n    (shiftFunctorCompIsoId C 0 0 (add_zero 0)).inv.app X =\n      (shiftFunctorZero C A).inv.app X ≫ ((shiftFunctorZero C A).inv.app X)⟦0⟧' := by\n  simp [shiftFunctorCompIsoId, shiftFunctorAdd'_zero_add_hom_app]\n\n"}
{"name":"CategoryTheory.shiftFunctorCompIsoId_add'_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\nX : C\nm n p m' n' p' : A\nhm : Eq (HAdd.hAdd m' m) 0\nhn : Eq (HAdd.hAdd n' n) 0\nhp : Eq (HAdd.hAdd p' p) 0\nh : Eq (HAdd.hAdd m n) p\n⊢ Eq ((CategoryTheory.shiftFunctorCompIsoId C p' p hp).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId C n' n hn).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorCompIsoId C m' m hm).inv.app ((CategoryTheory.shiftFunctor C n').obj X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C m n p h).inv.app ((CategoryTheory.shiftFunctor C m').obj ((CategoryTheory.shiftFunctor C n').obj X))) ((CategoryTheory.shiftFunctor C p).map ((CategoryTheory.shiftFunctorAdd' C n' m' p' ⋯).inv.app X)))))","decl":"lemma shiftFunctorCompIsoId_add'_inv_app :\n    (shiftFunctorCompIsoId C p' p hp).inv.app X =\n      (shiftFunctorCompIsoId C n' n hn).inv.app X ≫\n      (shiftFunctorCompIsoId C m' m hm).inv.app (X⟦n'⟧)⟦n⟧' ≫\n      (shiftFunctorAdd' C m n p h).inv.app (X⟦n'⟧⟦m'⟧) ≫\n      ((shiftFunctorAdd' C n' m' p'\n        (by rw [← add_left_inj p, hp, ← h, add_assoc,\n          ← add_assoc m', hm, zero_add, hn])).inv.app X)⟦p⟧' := by\n  dsimp [shiftFunctorCompIsoId]\n  simp only [Functor.map_comp, Category.assoc]\n  congr 1\n  rw [← NatTrans.naturality]\n  dsimp\n  rw [← cancel_mono ((shiftFunctorAdd' C p' p 0 hp).inv.app X), Iso.hom_inv_id_app,\n    Category.assoc, Category.assoc, Category.assoc, Category.assoc,\n    ← shiftFunctorAdd'_assoc_inv_app p' m n n' p 0\n      (by rw [← add_left_inj n, hn, add_assoc, h, hp]) h (by rw [add_assoc, h, hp]),\n    ← Functor.map_comp_assoc, ← Functor.map_comp_assoc, ← Functor.map_comp_assoc,\n    Category.assoc, Category.assoc,\n    shiftFunctorAdd'_assoc_inv_app n' m' m p' 0 n' _ _\n      (by rw [add_assoc, hm, add_zero]), Iso.hom_inv_id_app_assoc,\n    ← shiftFunctorAdd'_add_zero_hom_app, Iso.hom_inv_id_app,\n    Functor.map_id, Category.id_comp, Iso.hom_inv_id_app]\n\n"}
{"name":"CategoryTheory.shiftFunctorCompIsoId_add'_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddGroup A\ninst✝ : CategoryTheory.HasShift C A\nX : C\nm n p m' n' p' : A\nhm : Eq (HAdd.hAdd m' m) 0\nhn : Eq (HAdd.hAdd n' n) 0\nhp : Eq (HAdd.hAdd p' p) 0\nh : Eq (HAdd.hAdd m n) p\n⊢ Eq ((CategoryTheory.shiftFunctorCompIsoId C p' p hp).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C p).map ((CategoryTheory.shiftFunctorAdd' C n' m' p' ⋯).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C m n p h).hom.app ((CategoryTheory.shiftFunctor C m').obj ((CategoryTheory.shiftFunctor C n').obj X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorCompIsoId C m' m hm).hom.app ((CategoryTheory.shiftFunctor C n').obj X))) ((CategoryTheory.shiftFunctorCompIsoId C n' n hn).hom.app X))))","decl":"lemma shiftFunctorCompIsoId_add'_hom_app :\n    (shiftFunctorCompIsoId C p' p hp).hom.app X =\n      ((shiftFunctorAdd' C n' m' p'\n          (by rw [← add_left_inj p, hp, ← h, add_assoc,\n            ← add_assoc m', hm, zero_add, hn])).hom.app X)⟦p⟧' ≫\n      (shiftFunctorAdd' C m n p h).hom.app (X⟦n'⟧⟦m'⟧) ≫\n      (shiftFunctorCompIsoId C m' m hm).hom.app (X⟦n'⟧)⟦n⟧' ≫\n      (shiftFunctorCompIsoId C n' n hn).hom.app X := by\n  rw [← cancel_mono ((shiftFunctorCompIsoId C p' p hp).inv.app X), Iso.hom_inv_id_app,\n    shiftFunctorCompIsoId_add'_inv_app m n p m' n' p' hm hn hp h,\n    Category.assoc, Category.assoc, Category.assoc, Iso.hom_inv_id_app_assoc,\n    ← Functor.map_comp_assoc, Iso.hom_inv_id_app]\n  dsimp\n  rw [Functor.map_id, Category.id_comp, Iso.hom_inv_id_app_assoc,\n    ← Functor.map_comp, Iso.hom_inv_id_app, Functor.map_id]\n\n"}
{"name":"CategoryTheory.shift_zero_eq_zero","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : AddGroup A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nn : A\n⊢ Eq ((CategoryTheory.shiftFunctor C n).map 0) 0","decl":"theorem shift_zero_eq_zero (X Y : C) (n : A) : (0 : X ⟶ Y)⟦n⟧' = (0 : X⟦n⟧ ⟶ Y⟦n⟧) :=\n  CategoryTheory.Functor.map_zero _ _ _\n\n"}
{"name":"CategoryTheory.shiftFunctorComm_eq","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddCommMonoid A\ninst✝ : CategoryTheory.HasShift C A\ni j k : A\nh : Eq (HAdd.hAdd i j) k\n⊢ Eq (CategoryTheory.shiftFunctorComm C i j) ((CategoryTheory.shiftFunctorAdd' C i j k h).symm.trans (CategoryTheory.shiftFunctorAdd' C j i k ⋯))","decl":"lemma shiftFunctorComm_eq (i j k : A) (h : i + j = k) :\n    shiftFunctorComm C i j = (shiftFunctorAdd' C i j k h).symm ≪≫\n      shiftFunctorAdd' C j i k (by rw [add_comm j i, h]) := by\n  subst h\n  rw [shiftFunctorAdd'_eq_shiftFunctorAdd]\n  rfl\n\n"}
{"name":"CategoryTheory.shiftFunctorComm_eq_refl","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddCommMonoid A\ninst✝ : CategoryTheory.HasShift C A\ni : A\n⊢ Eq (CategoryTheory.shiftFunctorComm C i i) (CategoryTheory.Iso.refl ((CategoryTheory.shiftFunctor C i).comp (CategoryTheory.shiftFunctor C i)))","decl":"@[simp]\nlemma shiftFunctorComm_eq_refl (i : A) :\n    shiftFunctorComm C i i = Iso.refl _ := by\n  rw [shiftFunctorComm_eq C i i (i + i) rfl, Iso.symm_self_id]\n\n"}
{"name":"CategoryTheory.shiftFunctorComm_symm","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddCommMonoid A\ninst✝ : CategoryTheory.HasShift C A\ni j : A\n⊢ Eq (CategoryTheory.shiftFunctorComm C i j).symm (CategoryTheory.shiftFunctorComm C j i)","decl":"lemma shiftFunctorComm_symm (i j : A) :\n    (shiftFunctorComm C i j).symm = shiftFunctorComm C j i := by\n  ext1\n  dsimp\n  rw [shiftFunctorComm_eq C i j (i+j) rfl, shiftFunctorComm_eq C j i (i+j) (add_comm j i)]\n  rfl\n\n"}
{"name":"CategoryTheory.shiftComm_symm","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddCommMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX : C\ni j : A\n⊢ Eq (CategoryTheory.shiftComm X i j).symm (CategoryTheory.shiftComm X j i)","decl":"@[simp]\ntheorem shiftComm_symm (i j : A) : (shiftComm X i j).symm = shiftComm X j i := by\n  ext\n  exact NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorComm_symm C i j)) X\n\n"}
{"name":"CategoryTheory.shiftComm'","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddCommMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\ni j : A\n⊢ Eq ((CategoryTheory.shiftFunctor C j).map ((CategoryTheory.shiftFunctor C i).map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.shiftComm X i j).hom (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C i).map ((CategoryTheory.shiftFunctor C j).map f)) (CategoryTheory.shiftComm Y j i).hom))","decl":"/-- When shifts are indexed by an additive commutative monoid, then shifts commute. -/\ntheorem shiftComm' (i j : A) :\n    f⟦i⟧'⟦j⟧' = (shiftComm _ _ _).hom ≫ f⟦j⟧'⟦i⟧' ≫ (shiftComm _ _ _).hom := by\n  erw [← shiftComm_symm Y i j, ← ((shiftFunctorComm C i j).hom.naturality_assoc f)]\n  dsimp\n  simp only [Iso.hom_inv_id_app, Functor.comp_obj, Category.comp_id]\n\n"}
{"name":"CategoryTheory.shiftComm_hom_comp","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddCommMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\ni j : A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.shiftComm X i j).hom ((CategoryTheory.shiftFunctor C i).map ((CategoryTheory.shiftFunctor C j).map f))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C j).map ((CategoryTheory.shiftFunctor C i).map f)) (CategoryTheory.shiftComm Y i j).hom)","decl":"@[reassoc]\ntheorem shiftComm_hom_comp (i j : A) :\n    (shiftComm X i j).hom ≫ f⟦j⟧'⟦i⟧' = f⟦i⟧'⟦j⟧' ≫ (shiftComm Y i j).hom := by\n  rw [shiftComm', ← shiftComm_symm, Iso.symm_hom, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.shiftComm_hom_comp_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddCommMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\ni j : A\nZ : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C i).obj ((CategoryTheory.shiftFunctor C j).obj Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.shiftComm X i j).hom (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C i).map ((CategoryTheory.shiftFunctor C j).map f)) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C j).map ((CategoryTheory.shiftFunctor C i).map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.shiftComm Y i j).hom h))","decl":"@[reassoc]\ntheorem shiftComm_hom_comp (i j : A) :\n    (shiftComm X i j).hom ≫ f⟦j⟧'⟦i⟧' = f⟦i⟧'⟦j⟧' ≫ (shiftComm Y i j).hom := by\n  rw [shiftComm', ← shiftComm_symm, Iso.symm_hom, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.shiftFunctorZero_hom_app_shift","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddCommMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX : C\nn : A\n⊢ Eq ((CategoryTheory.shiftFunctorZero C A).hom.app ((CategoryTheory.shiftFunctor C n).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorComm C n 0).hom.app X) ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorZero C A).hom.app X)))","decl":"lemma shiftFunctorZero_hom_app_shift (n : A) :\n    (shiftFunctorZero C A).hom.app (X⟦n⟧) =\n    (shiftFunctorComm C n 0).hom.app X ≫ ((shiftFunctorZero C A).hom.app X)⟦n⟧' := by\n  rw [← shiftFunctorAdd'_zero_add_inv_app n X, shiftFunctorComm_eq C n 0 n (add_zero n)]\n  dsimp\n  rw [Category.assoc, Iso.hom_inv_id_app, Category.comp_id, shiftFunctorAdd'_add_zero_inv_app]\n\n"}
{"name":"CategoryTheory.shiftFunctorZero_inv_app_shift","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddCommMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX : C\nn : A\n⊢ Eq ((CategoryTheory.shiftFunctorZero C A).inv.app ((CategoryTheory.shiftFunctor C n).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorZero C A).inv.app X)) ((CategoryTheory.shiftFunctorComm C n 0).inv.app X))","decl":"lemma shiftFunctorZero_inv_app_shift (n : A) :\n    (shiftFunctorZero C A).inv.app (X⟦n⟧) =\n  ((shiftFunctorZero C A).inv.app X)⟦n⟧' ≫ (shiftFunctorComm C n 0).inv.app X := by\n  rw [← cancel_mono ((shiftFunctorZero C A).hom.app (X⟦n⟧)), Category.assoc, Iso.inv_hom_id_app,\n    shiftFunctorZero_hom_app_shift, Iso.inv_hom_id_app_assoc, ← Functor.map_comp,\n    Iso.inv_hom_id_app]\n  dsimp\n  rw [Functor.map_id]\n\n"}
{"name":"CategoryTheory.shiftFunctorComm_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddCommMonoid A\ninst✝ : CategoryTheory.HasShift C A\nX : C\na : A\n⊢ Eq ((CategoryTheory.shiftFunctorComm C a 0).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero C A).hom.app ((CategoryTheory.shiftFunctor C a).obj X)) ((CategoryTheory.shiftFunctor C a).map ((CategoryTheory.shiftFunctorZero C A).inv.app X)))","decl":"lemma shiftFunctorComm_zero_hom_app (a : A) :\n    (shiftFunctorComm C a 0).hom.app X =\n      (shiftFunctorZero C A).hom.app (X⟦a⟧) ≫ ((shiftFunctorZero C A).inv.app X)⟦a⟧' := by\n  simp only [shiftFunctorZero_hom_app_shift, Category.assoc, ← Functor.map_comp,\n    Iso.hom_inv_id_app, Functor.map_id, Functor.comp_obj, Category.comp_id]\n\n"}
{"name":"CategoryTheory.shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddCommMonoid A\ninst✝ : CategoryTheory.HasShift C A\nm₁ m₂ m₃ : A\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorComm C m₁ (HAdd.hAdd m₂ m₃)).hom.app X) ((CategoryTheory.shiftFunctor C m₁).map ((CategoryTheory.shiftFunctorAdd C m₂ m₃).hom.app X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C m₂ m₃).hom.app ((CategoryTheory.shiftFunctor C m₁).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C m₃).map ((CategoryTheory.shiftFunctorComm C m₁ m₂).hom.app X)) ((CategoryTheory.shiftFunctorComm C m₁ m₃).hom.app ((CategoryTheory.shiftFunctor C m₂).obj X))))","decl":"@[reassoc]\nlemma shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app (m₁ m₂ m₃ : A) (X : C) :\n    (shiftFunctorComm C m₁ (m₂ + m₃)).hom.app X ≫\n    ((shiftFunctorAdd C m₂ m₃).hom.app X)⟦m₁⟧' =\n  (shiftFunctorAdd C m₂ m₃).hom.app (X⟦m₁⟧) ≫\n    ((shiftFunctorComm C m₁ m₂).hom.app X)⟦m₃⟧' ≫\n    (shiftFunctorComm C m₁ m₃).hom.app (X⟦m₂⟧) := by\n  rw [← cancel_mono ((shiftFunctorComm C m₁ m₃).inv.app (X⟦m₂⟧)),\n    ← cancel_mono (((shiftFunctorComm C m₁ m₂).inv.app X)⟦m₃⟧')]\n  simp only [Category.assoc, Iso.hom_inv_id_app]\n  dsimp\n  simp only [Category.id_comp, ← Functor.map_comp, Iso.hom_inv_id_app]\n  dsimp\n  simp only [Functor.map_id, Category.comp_id,\n    shiftFunctorComm_eq C _ _ _ rfl, ← shiftFunctorAdd'_eq_shiftFunctorAdd]\n  dsimp\n  simp only [Category.assoc, Iso.hom_inv_id_app_assoc, Iso.inv_hom_id_app_assoc,\n    ← Functor.map_comp,\n    shiftFunctorAdd'_assoc_hom_app_assoc m₂ m₃ m₁ (m₂ + m₃) (m₁ + m₃) (m₁ + (m₂ + m₃)) rfl\n      (add_comm m₃ m₁) (add_comm _ m₁) X,\n    ← shiftFunctorAdd'_assoc_hom_app_assoc m₂ m₁ m₃ (m₁ + m₂) (m₁ + m₃)\n      (m₁ + (m₂ + m₃)) (add_comm _ _) rfl (by rw [add_comm m₂ m₁, add_assoc]) X,\n    shiftFunctorAdd'_assoc_hom_app m₁ m₂ m₃\n      (m₁ + m₂) (m₂ + m₃) (m₁ + (m₂ + m₃)) rfl rfl (add_assoc _ _ _) X]\n\n"}
{"name":"CategoryTheory.shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : AddCommMonoid A\ninst✝ : CategoryTheory.HasShift C A\nm₁ m₂ m₃ : A\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C m₁).obj ((CategoryTheory.shiftFunctor C m₃).obj ((CategoryTheory.shiftFunctor C m₂).obj X))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorComm C m₁ (HAdd.hAdd m₂ m₃)).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C m₁).map ((CategoryTheory.shiftFunctorAdd C m₂ m₃).hom.app X)) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C m₂ m₃).hom.app ((CategoryTheory.shiftFunctor C m₁).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C m₃).map ((CategoryTheory.shiftFunctorComm C m₁ m₂).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorComm C m₁ m₃).hom.app ((CategoryTheory.shiftFunctor C m₂).obj X)) h)))","decl":"@[reassoc]\nlemma shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app (m₁ m₂ m₃ : A) (X : C) :\n    (shiftFunctorComm C m₁ (m₂ + m₃)).hom.app X ≫\n    ((shiftFunctorAdd C m₂ m₃).hom.app X)⟦m₁⟧' =\n  (shiftFunctorAdd C m₂ m₃).hom.app (X⟦m₁⟧) ≫\n    ((shiftFunctorComm C m₁ m₂).hom.app X)⟦m₃⟧' ≫\n    (shiftFunctorComm C m₁ m₃).hom.app (X⟦m₂⟧) := by\n  rw [← cancel_mono ((shiftFunctorComm C m₁ m₃).inv.app (X⟦m₂⟧)),\n    ← cancel_mono (((shiftFunctorComm C m₁ m₂).inv.app X)⟦m₃⟧')]\n  simp only [Category.assoc, Iso.hom_inv_id_app]\n  dsimp\n  simp only [Category.id_comp, ← Functor.map_comp, Iso.hom_inv_id_app]\n  dsimp\n  simp only [Functor.map_id, Category.comp_id,\n    shiftFunctorComm_eq C _ _ _ rfl, ← shiftFunctorAdd'_eq_shiftFunctorAdd]\n  dsimp\n  simp only [Category.assoc, Iso.hom_inv_id_app_assoc, Iso.inv_hom_id_app_assoc,\n    ← Functor.map_comp,\n    shiftFunctorAdd'_assoc_hom_app_assoc m₂ m₃ m₁ (m₂ + m₃) (m₁ + m₃) (m₁ + (m₂ + m₃)) rfl\n      (add_comm m₃ m₁) (add_comm _ m₁) X,\n    ← shiftFunctorAdd'_assoc_hom_app_assoc m₂ m₁ m₃ (m₁ + m₂) (m₁ + m₃)\n      (m₁ + (m₂ + m₃)) (add_comm _ _) rfl (by rw [add_comm m₂ m₁, add_assoc]) X,\n    shiftFunctorAdd'_assoc_hom_app m₁ m₂ m₃\n      (m₁ + m₂) (m₂ + m₃) (m₁ + (m₂ + m₃)) rfl rfl (add_assoc _ _ _) X]\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.hasShift.map_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\ns : A → CategoryTheory.Functor C C\ni : (i : A) → CategoryTheory.Iso ((s i).comp F) (F.comp (CategoryTheory.shiftFunctor D i))\nX : C\n⊢ Eq (F.map ((CategoryTheory.Functor.FullyFaithful.hasShift.zero hF s i).hom.app X)) (CategoryTheory.CategoryStruct.comp ((i 0).hom.app X) ((CategoryTheory.shiftFunctorZero D A).hom.app (F.obj X)))","decl":"@[simp]\nlemma map_zero_hom_app (X : C) :\n    F.map ((zero hF s i).hom.app X) =\n      (i 0).hom.app X ≫ (shiftFunctorZero D A).hom.app (F.obj X) := by\n  simp [zero]\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.hasShift.map_zero_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\ns : A → CategoryTheory.Functor C C\ni : (i : A) → CategoryTheory.Iso ((s i).comp F) (F.comp (CategoryTheory.shiftFunctor D i))\nX : C\n⊢ Eq (F.map ((CategoryTheory.Functor.FullyFaithful.hasShift.zero hF s i).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero D A).inv.app (F.obj X)) ((i 0).inv.app X))","decl":"@[simp]\nlemma map_zero_inv_app (X : C) :\n    F.map ((zero hF s i).inv.app X) =\n      (shiftFunctorZero D A).inv.app (F.obj X) ≫ (i 0).inv.app X := by\n  simp [zero]\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.hasShift.map_add_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\ns : A → CategoryTheory.Functor C C\ni : (i : A) → CategoryTheory.Iso ((s i).comp F) (F.comp (CategoryTheory.shiftFunctor D i))\na b : A\nX : C\n⊢ Eq (F.map ((CategoryTheory.Functor.FullyFaithful.hasShift.add hF s i a b).hom.app X)) (CategoryTheory.CategoryStruct.comp ((i (HAdd.hAdd a b)).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd D a b).hom.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((i a).inv.app X)) ((i b).inv.app ((s a).obj X)))))","decl":"@[simp]\nlemma map_add_hom_app (a b : A) (X : C) :\n    F.map ((add hF s i a b).hom.app X) =\n      (i (a + b)).hom.app X ≫ (shiftFunctorAdd D a b).hom.app (F.obj X) ≫\n        ((i a).inv.app X)⟦b⟧' ≫ (i b).inv.app ((s a).obj X) := by\n  dsimp [add]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.hasShift.map_add_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\ns : A → CategoryTheory.Functor C C\ni : (i : A) → CategoryTheory.Iso ((s i).comp F) (F.comp (CategoryTheory.shiftFunctor D i))\na b : A\nX : C\n⊢ Eq (F.map ((CategoryTheory.Functor.FullyFaithful.hasShift.add hF s i a b).inv.app X)) (CategoryTheory.CategoryStruct.comp ((i b).hom.app ((s a).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((i a).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd D a b).inv.app (F.obj X)) ((i (HAdd.hAdd a b)).inv.app X))))","decl":"@[simp]\nlemma map_add_inv_app (a b : A) (X : C) :\n    F.map ((add hF s i a b).inv.app X) =\n      (i b).hom.app ((s a).obj X) ≫ ((i a).hom.app X)⟦b⟧' ≫\n        (shiftFunctorAdd D a b).inv.app (F.obj X) ≫ (i (a + b)).inv.app X := by\n  dsimp [add]\n  simp\n\n"}
