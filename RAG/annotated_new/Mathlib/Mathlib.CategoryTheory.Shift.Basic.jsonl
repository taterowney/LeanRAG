{"name":"CategoryTheory.ShiftMkCore.mk.inj","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : AddMonoid A\nF‚úù : A ‚Üí CategoryTheory.Functor C C\nzero‚úù : CategoryTheory.Iso (F‚úù 0) (CategoryTheory.Functor.id C)\nadd‚úù : (n m : A) ‚Üí CategoryTheory.Iso (F‚úù (HAdd.hAdd n m)) ((F‚úù n).comp (F‚úù m))\nassoc_hom_app‚úù : autoParam (‚àÄ (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C), Eq (CategoryTheory.CategoryStruct.comp ((add‚úù (HAdd.hAdd m‚ÇÅ m‚ÇÇ) m‚ÇÉ).hom.app X) ((F‚úù m‚ÇÉ).map ((add‚úù m‚ÇÅ m‚ÇÇ).hom.app X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp ((add‚úù m‚ÇÅ (HAdd.hAdd m‚ÇÇ m‚ÇÉ)).hom.app X) ((add‚úù m‚ÇÇ m‚ÇÉ).hom.app ((F‚úù m‚ÇÅ).obj X))))) _auto‚úù\nzero_add_hom_app‚úù : autoParam (‚àÄ (n : A) (X : C), Eq ((add‚úù 0 n).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) ((F‚úù n).map (zero‚úù.inv.app X)))) _auto‚úù\nadd_zero_hom_app‚úù : autoParam (‚àÄ (n : A) (X : C), Eq ((add‚úù n 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (zero‚úù.inv.app ((F‚úù n).obj X)))) _auto‚úù\nF : A ‚Üí CategoryTheory.Functor C C\nzero : CategoryTheory.Iso (F 0) (CategoryTheory.Functor.id C)\nadd : (n m : A) ‚Üí CategoryTheory.Iso (F (HAdd.hAdd n m)) ((F n).comp (F m))\nassoc_hom_app : autoParam (‚àÄ (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C), Eq (CategoryTheory.CategoryStruct.comp ((add (HAdd.hAdd m‚ÇÅ m‚ÇÇ) m‚ÇÉ).hom.app X) ((F m‚ÇÉ).map ((add m‚ÇÅ m‚ÇÇ).hom.app X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp ((add m‚ÇÅ (HAdd.hAdd m‚ÇÇ m‚ÇÉ)).hom.app X) ((add m‚ÇÇ m‚ÇÉ).hom.app ((F m‚ÇÅ).obj X))))) _auto‚úù\nzero_add_hom_app : autoParam (‚àÄ (n : A) (X : C), Eq ((add 0 n).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) ((F n).map (zero.inv.app X)))) _auto‚úù\nadd_zero_hom_app : autoParam (‚àÄ (n : A) (X : C), Eq ((add n 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (zero.inv.app ((F n).obj X)))) _auto‚úù\nx‚úù : Eq { F := F‚úù, zero := zero‚úù, add := add‚úù, assoc_hom_app := assoc_hom_app‚úù, zero_add_hom_app := zero_add_hom_app‚úù, add_zero_hom_app := add_zero_hom_app‚úù } { F := F, zero := zero, add := add, assoc_hom_app := assoc_hom_app, zero_add_hom_app := zero_add_hom_app, add_zero_hom_app := add_zero_hom_app }\n‚ä¢ And (Eq F‚úù F) (And (HEq zero‚úù zero) (HEq add‚úù add))","decl":"/-- A helper structure to construct the shift functor `(Discrete A) ‚•§ (C ‚•§ C)`. -/\nstructure ShiftMkCore where\n  /-- the family of shift functors -/\n  F : A ‚Üí C ‚•§ C\n  /-- the shift by 0 identifies to the identity functor -/\n  zero : F 0 ‚âÖ ùü≠ C\n  /-- the composition of shift functors identifies to the shift by the sum -/\n  add : ‚àÄ n m : A, F (n + m) ‚âÖ F n ‚ãô F m\n  /-- compatibility with the associativity -/\n  assoc_hom_app : ‚àÄ (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C),\n    (add (m‚ÇÅ + m‚ÇÇ) m‚ÇÉ).hom.app X ‚â´ (F m‚ÇÉ).map ((add m‚ÇÅ m‚ÇÇ).hom.app X) =\n      eqToHom (by rw [add_assoc]) ‚â´ (add m‚ÇÅ (m‚ÇÇ + m‚ÇÉ)).hom.app X ‚â´\n        (add m‚ÇÇ m‚ÇÉ).hom.app ((F m‚ÇÅ).obj X) := by aesop_cat\n  /-- compatibility with the left addition with 0 -/\n  zero_add_hom_app : ‚àÄ (n : A) (X : C), (add 0 n).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ‚â´ (F n).map (zero.inv.app X) := by aesop_cat\n  /-- compatibility with the right addition with 0 -/\n  add_zero_hom_app : ‚àÄ (n : A) (X : C), (add n 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ‚â´ zero.inv.app ((F n).obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShiftMkCore.assoc_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : AddMonoid A\nself : CategoryTheory.ShiftMkCore C A\nm‚ÇÅ m‚ÇÇ m‚ÇÉ : A\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((self.add (HAdd.hAdd m‚ÇÅ m‚ÇÇ) m‚ÇÉ).hom.app X) ((self.F m‚ÇÉ).map ((self.add m‚ÇÅ m‚ÇÇ).hom.app X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp ((self.add m‚ÇÅ (HAdd.hAdd m‚ÇÇ m‚ÇÉ)).hom.app X) ((self.add m‚ÇÇ m‚ÇÉ).hom.app ((self.F m‚ÇÅ).obj X))))","decl":"/-- A helper structure to construct the shift functor `(Discrete A) ‚•§ (C ‚•§ C)`. -/\nstructure ShiftMkCore where\n  /-- the family of shift functors -/\n  F : A ‚Üí C ‚•§ C\n  /-- the shift by 0 identifies to the identity functor -/\n  zero : F 0 ‚âÖ ùü≠ C\n  /-- the composition of shift functors identifies to the shift by the sum -/\n  add : ‚àÄ n m : A, F (n + m) ‚âÖ F n ‚ãô F m\n  /-- compatibility with the associativity -/\n  assoc_hom_app : ‚àÄ (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C),\n    (add (m‚ÇÅ + m‚ÇÇ) m‚ÇÉ).hom.app X ‚â´ (F m‚ÇÉ).map ((add m‚ÇÅ m‚ÇÇ).hom.app X) =\n      eqToHom (by rw [add_assoc]) ‚â´ (add m‚ÇÅ (m‚ÇÇ + m‚ÇÉ)).hom.app X ‚â´\n        (add m‚ÇÇ m‚ÇÉ).hom.app ((F m‚ÇÅ).obj X) := by aesop_cat\n  /-- compatibility with the left addition with 0 -/\n  zero_add_hom_app : ‚àÄ (n : A) (X : C), (add 0 n).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ‚â´ (F n).map (zero.inv.app X) := by aesop_cat\n  /-- compatibility with the right addition with 0 -/\n  add_zero_hom_app : ‚àÄ (n : A) (X : C), (add n 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ‚â´ zero.inv.app ((F n).obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShiftMkCore.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : AddMonoid A\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf A\nF : A ‚Üí CategoryTheory.Functor C C\nzero : CategoryTheory.Iso (F 0) (CategoryTheory.Functor.id C)\nadd : (n m : A) ‚Üí CategoryTheory.Iso (F (HAdd.hAdd n m)) ((F n).comp (F m))\nassoc_hom_app : autoParam (‚àÄ (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C), Eq (CategoryTheory.CategoryStruct.comp ((add (HAdd.hAdd m‚ÇÅ m‚ÇÇ) m‚ÇÉ).hom.app X) ((F m‚ÇÉ).map ((add m‚ÇÅ m‚ÇÇ).hom.app X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp ((add m‚ÇÅ (HAdd.hAdd m‚ÇÇ m‚ÇÉ)).hom.app X) ((add m‚ÇÇ m‚ÇÉ).hom.app ((F m‚ÇÅ).obj X))))) _auto‚úù\nzero_add_hom_app : autoParam (‚àÄ (n : A) (X : C), Eq ((add 0 n).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) ((F n).map (zero.inv.app X)))) _auto‚úù\nadd_zero_hom_app : autoParam (‚àÄ (n : A) (X : C), Eq ((add n 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (zero.inv.app ((F n).obj X)))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { F := F, zero := zero, add := add, assoc_hom_app := assoc_hom_app, zero_add_hom_app := zero_add_hom_app, add_zero_hom_app := add_zero_hom_app }) (HAdd.hAdd 1 (SizeOf.sizeOf zero))","decl":"/-- A helper structure to construct the shift functor `(Discrete A) ‚•§ (C ‚•§ C)`. -/\nstructure ShiftMkCore where\n  /-- the family of shift functors -/\n  F : A ‚Üí C ‚•§ C\n  /-- the shift by 0 identifies to the identity functor -/\n  zero : F 0 ‚âÖ ùü≠ C\n  /-- the composition of shift functors identifies to the shift by the sum -/\n  add : ‚àÄ n m : A, F (n + m) ‚âÖ F n ‚ãô F m\n  /-- compatibility with the associativity -/\n  assoc_hom_app : ‚àÄ (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C),\n    (add (m‚ÇÅ + m‚ÇÇ) m‚ÇÉ).hom.app X ‚â´ (F m‚ÇÉ).map ((add m‚ÇÅ m‚ÇÇ).hom.app X) =\n      eqToHom (by rw [add_assoc]) ‚â´ (add m‚ÇÅ (m‚ÇÇ + m‚ÇÉ)).hom.app X ‚â´\n        (add m‚ÇÇ m‚ÇÉ).hom.app ((F m‚ÇÅ).obj X) := by aesop_cat\n  /-- compatibility with the left addition with 0 -/\n  zero_add_hom_app : ‚àÄ (n : A) (X : C), (add 0 n).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ‚â´ (F n).map (zero.inv.app X) := by aesop_cat\n  /-- compatibility with the right addition with 0 -/\n  add_zero_hom_app : ‚àÄ (n : A) (X : C), (add n 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ‚â´ zero.inv.app ((F n).obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShiftMkCore.add_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : AddMonoid A\nself : CategoryTheory.ShiftMkCore C A\nn : A\nX : C\n‚ä¢ Eq ((self.add n 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (self.zero.inv.app ((self.F n).obj X)))","decl":"/-- A helper structure to construct the shift functor `(Discrete A) ‚•§ (C ‚•§ C)`. -/\nstructure ShiftMkCore where\n  /-- the family of shift functors -/\n  F : A ‚Üí C ‚•§ C\n  /-- the shift by 0 identifies to the identity functor -/\n  zero : F 0 ‚âÖ ùü≠ C\n  /-- the composition of shift functors identifies to the shift by the sum -/\n  add : ‚àÄ n m : A, F (n + m) ‚âÖ F n ‚ãô F m\n  /-- compatibility with the associativity -/\n  assoc_hom_app : ‚àÄ (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C),\n    (add (m‚ÇÅ + m‚ÇÇ) m‚ÇÉ).hom.app X ‚â´ (F m‚ÇÉ).map ((add m‚ÇÅ m‚ÇÇ).hom.app X) =\n      eqToHom (by rw [add_assoc]) ‚â´ (add m‚ÇÅ (m‚ÇÇ + m‚ÇÉ)).hom.app X ‚â´\n        (add m‚ÇÇ m‚ÇÉ).hom.app ((F m‚ÇÅ).obj X) := by aesop_cat\n  /-- compatibility with the left addition with 0 -/\n  zero_add_hom_app : ‚àÄ (n : A) (X : C), (add 0 n).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ‚â´ (F n).map (zero.inv.app X) := by aesop_cat\n  /-- compatibility with the right addition with 0 -/\n  add_zero_hom_app : ‚àÄ (n : A) (X : C), (add n 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ‚â´ zero.inv.app ((F n).obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShiftMkCore.zero_add_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : AddMonoid A\nself : CategoryTheory.ShiftMkCore C A\nn : A\nX : C\n‚ä¢ Eq ((self.add 0 n).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) ((self.F n).map (self.zero.inv.app X)))","decl":"/-- A helper structure to construct the shift functor `(Discrete A) ‚•§ (C ‚•§ C)`. -/\nstructure ShiftMkCore where\n  /-- the family of shift functors -/\n  F : A ‚Üí C ‚•§ C\n  /-- the shift by 0 identifies to the identity functor -/\n  zero : F 0 ‚âÖ ùü≠ C\n  /-- the composition of shift functors identifies to the shift by the sum -/\n  add : ‚àÄ n m : A, F (n + m) ‚âÖ F n ‚ãô F m\n  /-- compatibility with the associativity -/\n  assoc_hom_app : ‚àÄ (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C),\n    (add (m‚ÇÅ + m‚ÇÇ) m‚ÇÉ).hom.app X ‚â´ (F m‚ÇÉ).map ((add m‚ÇÅ m‚ÇÇ).hom.app X) =\n      eqToHom (by rw [add_assoc]) ‚â´ (add m‚ÇÅ (m‚ÇÇ + m‚ÇÉ)).hom.app X ‚â´\n        (add m‚ÇÇ m‚ÇÉ).hom.app ((F m‚ÇÅ).obj X) := by aesop_cat\n  /-- compatibility with the left addition with 0 -/\n  zero_add_hom_app : ‚àÄ (n : A) (X : C), (add 0 n).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ‚â´ (F n).map (zero.inv.app X) := by aesop_cat\n  /-- compatibility with the right addition with 0 -/\n  add_zero_hom_app : ‚àÄ (n : A) (X : C), (add n 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ‚â´ zero.inv.app ((F n).obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShiftMkCore.mk.injEq","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : AddMonoid A\nF‚úù : A ‚Üí CategoryTheory.Functor C C\nzero‚úù : CategoryTheory.Iso (F‚úù 0) (CategoryTheory.Functor.id C)\nadd‚úù : (n m : A) ‚Üí CategoryTheory.Iso (F‚úù (HAdd.hAdd n m)) ((F‚úù n).comp (F‚úù m))\nassoc_hom_app‚úù : autoParam (‚àÄ (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C), Eq (CategoryTheory.CategoryStruct.comp ((add‚úù (HAdd.hAdd m‚ÇÅ m‚ÇÇ) m‚ÇÉ).hom.app X) ((F‚úù m‚ÇÉ).map ((add‚úù m‚ÇÅ m‚ÇÇ).hom.app X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp ((add‚úù m‚ÇÅ (HAdd.hAdd m‚ÇÇ m‚ÇÉ)).hom.app X) ((add‚úù m‚ÇÇ m‚ÇÉ).hom.app ((F‚úù m‚ÇÅ).obj X))))) _auto‚úù\nzero_add_hom_app‚úù : autoParam (‚àÄ (n : A) (X : C), Eq ((add‚úù 0 n).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) ((F‚úù n).map (zero‚úù.inv.app X)))) _auto‚úù\nadd_zero_hom_app‚úù : autoParam (‚àÄ (n : A) (X : C), Eq ((add‚úù n 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (zero‚úù.inv.app ((F‚úù n).obj X)))) _auto‚úù\nF : A ‚Üí CategoryTheory.Functor C C\nzero : CategoryTheory.Iso (F 0) (CategoryTheory.Functor.id C)\nadd : (n m : A) ‚Üí CategoryTheory.Iso (F (HAdd.hAdd n m)) ((F n).comp (F m))\nassoc_hom_app : autoParam (‚àÄ (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C), Eq (CategoryTheory.CategoryStruct.comp ((add (HAdd.hAdd m‚ÇÅ m‚ÇÇ) m‚ÇÉ).hom.app X) ((F m‚ÇÉ).map ((add m‚ÇÅ m‚ÇÇ).hom.app X))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp ((add m‚ÇÅ (HAdd.hAdd m‚ÇÇ m‚ÇÉ)).hom.app X) ((add m‚ÇÇ m‚ÇÉ).hom.app ((F m‚ÇÅ).obj X))))) _auto‚úù\nzero_add_hom_app : autoParam (‚àÄ (n : A) (X : C), Eq ((add 0 n).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) ((F n).map (zero.inv.app X)))) _auto‚úù\nadd_zero_hom_app : autoParam (‚àÄ (n : A) (X : C), Eq ((add n 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (zero.inv.app ((F n).obj X)))) _auto‚úù\n‚ä¢ Eq (Eq { F := F‚úù, zero := zero‚úù, add := add‚úù, assoc_hom_app := assoc_hom_app‚úù, zero_add_hom_app := zero_add_hom_app‚úù, add_zero_hom_app := add_zero_hom_app‚úù } { F := F, zero := zero, add := add, assoc_hom_app := assoc_hom_app, zero_add_hom_app := zero_add_hom_app, add_zero_hom_app := add_zero_hom_app }) (And (Eq F‚úù F) (And (HEq zero‚úù zero) (HEq add‚úù add)))","decl":"/-- A helper structure to construct the shift functor `(Discrete A) ‚•§ (C ‚•§ C)`. -/\nstructure ShiftMkCore where\n  /-- the family of shift functors -/\n  F : A ‚Üí C ‚•§ C\n  /-- the shift by 0 identifies to the identity functor -/\n  zero : F 0 ‚âÖ ùü≠ C\n  /-- the composition of shift functors identifies to the shift by the sum -/\n  add : ‚àÄ n m : A, F (n + m) ‚âÖ F n ‚ãô F m\n  /-- compatibility with the associativity -/\n  assoc_hom_app : ‚àÄ (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C),\n    (add (m‚ÇÅ + m‚ÇÇ) m‚ÇÉ).hom.app X ‚â´ (F m‚ÇÉ).map ((add m‚ÇÅ m‚ÇÇ).hom.app X) =\n      eqToHom (by rw [add_assoc]) ‚â´ (add m‚ÇÅ (m‚ÇÇ + m‚ÇÉ)).hom.app X ‚â´\n        (add m‚ÇÇ m‚ÇÉ).hom.app ((F m‚ÇÅ).obj X) := by aesop_cat\n  /-- compatibility with the left addition with 0 -/\n  zero_add_hom_app : ‚àÄ (n : A) (X : C), (add 0 n).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ‚â´ (F n).map (zero.inv.app X) := by aesop_cat\n  /-- compatibility with the right addition with 0 -/\n  add_zero_hom_app : ‚àÄ (n : A) (X : C), (add n 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ‚â´ zero.inv.app ((F n).obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShiftMkCore.assoc_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : AddMonoid A\nself : CategoryTheory.ShiftMkCore C A\nm‚ÇÅ m‚ÇÇ m‚ÇÉ : A\nX Z : C\nh : Quiver.Hom ((self.F m‚ÇÉ).obj ((self.F m‚ÇÇ).obj ((self.F m‚ÇÅ).obj X))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((self.add (HAdd.hAdd m‚ÇÅ m‚ÇÇ) m‚ÇÉ).hom.app X) (CategoryTheory.CategoryStruct.comp ((self.F m‚ÇÉ).map ((self.add m‚ÇÅ m‚ÇÇ).hom.app X)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp ((self.add m‚ÇÅ (HAdd.hAdd m‚ÇÇ m‚ÇÉ)).hom.app X) (CategoryTheory.CategoryStruct.comp ((self.add m‚ÇÇ m‚ÇÉ).hom.app ((self.F m‚ÇÅ).obj X)) h)))","decl":"attribute [reassoc] assoc_hom_app\n\n"}
{"name":"CategoryTheory.ShiftMkCore.assoc_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : AddMonoid A\nh : CategoryTheory.ShiftMkCore C A\nm‚ÇÅ m‚ÇÇ m‚ÇÉ : A\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((h.F m‚ÇÉ).map ((h.add m‚ÇÅ m‚ÇÇ).inv.app X)) ((h.add (HAdd.hAdd m‚ÇÅ m‚ÇÇ) m‚ÇÉ).inv.app X)) (CategoryTheory.CategoryStruct.comp ((h.add m‚ÇÇ m‚ÇÉ).inv.app ((h.F m‚ÇÅ).obj X)) (CategoryTheory.CategoryStruct.comp ((h.add m‚ÇÅ (HAdd.hAdd m‚ÇÇ m‚ÇÉ)).inv.app X) (CategoryTheory.eqToHom ‚ãØ)))","decl":"@[reassoc]\nlemma assoc_inv_app (h : ShiftMkCore C A) (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C) :\n    (h.F m‚ÇÉ).map ((h.add m‚ÇÅ m‚ÇÇ).inv.app X) ‚â´ (h.add (m‚ÇÅ + m‚ÇÇ) m‚ÇÉ).inv.app X =\n    (h.add m‚ÇÇ m‚ÇÉ).inv.app ((h.F m‚ÇÅ).obj X) ‚â´ (h.add m‚ÇÅ (m‚ÇÇ + m‚ÇÉ)).inv.app X ‚â´\n      eqToHom (by rw [add_assoc]) := by\n  rw [‚Üê cancel_mono ((h.add (m‚ÇÅ + m‚ÇÇ) m‚ÇÉ).hom.app X ‚â´ (h.F m‚ÇÉ).map ((h.add m‚ÇÅ m‚ÇÇ).hom.app X)),\n    Category.assoc, Category.assoc, Category.assoc, Iso.inv_hom_id_app_assoc, ‚Üê Functor.map_comp,\n    Iso.inv_hom_id_app, Functor.map_id, h.assoc_hom_app, eqToHom_trans_assoc, eqToHom_refl,\n    Category.id_comp, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app]\n  rfl\n\n"}
{"name":"CategoryTheory.ShiftMkCore.assoc_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : AddMonoid A\nh‚úù : CategoryTheory.ShiftMkCore C A\nm‚ÇÅ m‚ÇÇ m‚ÇÉ : A\nX Z : C\nh : Quiver.Hom ((h‚úù.F (HAdd.hAdd (HAdd.hAdd m‚ÇÅ m‚ÇÇ) m‚ÇÉ)).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((h‚úù.F m‚ÇÉ).map ((h‚úù.add m‚ÇÅ m‚ÇÇ).inv.app X)) (CategoryTheory.CategoryStruct.comp ((h‚úù.add (HAdd.hAdd m‚ÇÅ m‚ÇÇ) m‚ÇÉ).inv.app X) h)) (CategoryTheory.CategoryStruct.comp ((h‚úù.add m‚ÇÇ m‚ÇÉ).inv.app ((h‚úù.F m‚ÇÅ).obj X)) (CategoryTheory.CategoryStruct.comp ((h‚úù.add m‚ÇÅ (HAdd.hAdd m‚ÇÇ m‚ÇÉ)).inv.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) h)))","decl":"@[reassoc]\nlemma assoc_inv_app (h : ShiftMkCore C A) (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C) :\n    (h.F m‚ÇÉ).map ((h.add m‚ÇÅ m‚ÇÇ).inv.app X) ‚â´ (h.add (m‚ÇÅ + m‚ÇÇ) m‚ÇÉ).inv.app X =\n    (h.add m‚ÇÇ m‚ÇÉ).inv.app ((h.F m‚ÇÅ).obj X) ‚â´ (h.add m‚ÇÅ (m‚ÇÇ + m‚ÇÉ)).inv.app X ‚â´\n      eqToHom (by rw [add_assoc]) := by\n  rw [‚Üê cancel_mono ((h.add (m‚ÇÅ + m‚ÇÇ) m‚ÇÉ).hom.app X ‚â´ (h.F m‚ÇÉ).map ((h.add m‚ÇÅ m‚ÇÇ).hom.app X)),\n    Category.assoc, Category.assoc, Category.assoc, Iso.inv_hom_id_app_assoc, ‚Üê Functor.map_comp,\n    Iso.inv_hom_id_app, Functor.map_id, h.assoc_hom_app, eqToHom_trans_assoc, eqToHom_refl,\n    Category.id_comp, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app]\n  rfl\n\n"}
{"name":"CategoryTheory.ShiftMkCore.zero_add_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : AddMonoid A\nh : CategoryTheory.ShiftMkCore C A\nn : A\nX : C\n‚ä¢ Eq ((h.add 0 n).inv.app X) (CategoryTheory.CategoryStruct.comp ((h.F n).map (h.zero.hom.app X)) (CategoryTheory.eqToHom ‚ãØ))","decl":"lemma zero_add_inv_app (h : ShiftMkCore C A) (n : A) (X : C) :\n    (h.add 0 n).inv.app X = (h.F n).map (h.zero.hom.app X) ‚â´\n      eqToHom (by dsimp; rw [zero_add]) := by\n  rw [‚Üê cancel_epi ((h.add 0 n).hom.app X), Iso.hom_inv_id_app, h.zero_add_hom_app,\n    Category.assoc, ‚Üê Functor.map_comp_assoc, Iso.inv_hom_id_app, Functor.map_id,\n    Category.id_comp, eqToHom_trans, eqToHom_refl]\n\n"}
{"name":"CategoryTheory.ShiftMkCore.add_zero_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : AddMonoid A\nh : CategoryTheory.ShiftMkCore C A\nn : A\nX : C\n‚ä¢ Eq ((h.add n 0).inv.app X) (CategoryTheory.CategoryStruct.comp (h.zero.hom.app ((h.F n).obj X)) (CategoryTheory.eqToHom ‚ãØ))","decl":"lemma add_zero_inv_app (h : ShiftMkCore C A) (n : A) (X : C) :\n    (h.add n 0).inv.app X = h.zero.hom.app ((h.F n).obj X) ‚â´\n      eqToHom (by dsimp; rw [add_zero]) := by\n  rw [‚Üê cancel_epi ((h.add n 0).hom.app X), Iso.hom_inv_id_app, h.add_zero_hom_app,\n    Category.assoc, Iso.inv_hom_id_app_assoc, eqToHom_trans, eqToHom_refl]\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_eq_shiftFunctorAdd","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\ni j : A\n‚ä¢ Eq (CategoryTheory.shiftFunctorAdd' C i j (HAdd.hAdd i j) ‚ãØ) (CategoryTheory.shiftFunctorAdd C i j)","decl":"lemma shiftFunctorAdd'_eq_shiftFunctorAdd (i j : A) :\n    shiftFunctorAdd' C i j (i+j) rfl = shiftFunctorAdd C i j := by\n  ext1\n  apply Category.id_comp\n\n"}
{"name":"CategoryTheory.ShiftMkCore.shiftFunctor_eq","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : AddMonoid A\nh : CategoryTheory.ShiftMkCore C A\na : A\n‚ä¢ Eq (CategoryTheory.shiftFunctor C a) (h.F a)","decl":"lemma ShiftMkCore.shiftFunctor_eq (h : ShiftMkCore C A) (a : A) :\n    letI := hasShiftMk C A h\n    shiftFunctor C a = h.F a := rfl\n\n"}
{"name":"CategoryTheory.ShiftMkCore.shiftFunctorZero_eq","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : AddMonoid A\nh : CategoryTheory.ShiftMkCore C A\n‚ä¢ Eq (CategoryTheory.shiftFunctorZero C A) h.zero","decl":"lemma ShiftMkCore.shiftFunctorZero_eq (h : ShiftMkCore C A) :\n    letI := hasShiftMk C A h\n    shiftFunctorZero C A = h.zero := rfl\n\n"}
{"name":"CategoryTheory.ShiftMkCore.shiftFunctorAdd_eq","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : AddMonoid A\nh : CategoryTheory.ShiftMkCore C A\na b : A\n‚ä¢ Eq (CategoryTheory.shiftFunctorAdd C a b) (h.add a b)","decl":"lemma ShiftMkCore.shiftFunctorAdd_eq (h : ShiftMkCore C A) (a b : A) :\n    letI := hasShiftMk C A h\n    shiftFunctorAdd C a b = h.add a b := rfl\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_zero_add","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na : A\n‚ä¢ Eq (CategoryTheory.shiftFunctorAdd' C 0 a a ‚ãØ) ((CategoryTheory.shiftFunctor C a).leftUnitor.symm.trans (CategoryTheory.isoWhiskerRight (CategoryTheory.shiftFunctorZero C A).symm (CategoryTheory.shiftFunctor C a)))","decl":"lemma shiftFunctorAdd'_zero_add (a : A) :\n    shiftFunctorAdd' C 0 a a (zero_add a) = (Functor.leftUnitor _).symm ‚â™‚â´\n    isoWhiskerRight (shiftFunctorZero C A).symm (shiftFunctor C a) := by\n  ext X\n  dsimp [shiftFunctorAdd', shiftFunctorZero, shiftFunctor]\n  simp only [eqToHom_app, obj_Œµ_app, Discrete.addMonoidal_leftUnitor, eqToIso.inv,\n    eqToHom_map, Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_add_zero","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na : A\n‚ä¢ Eq (CategoryTheory.shiftFunctorAdd' C a 0 a ‚ãØ) ((CategoryTheory.shiftFunctor C a).rightUnitor.symm.trans (CategoryTheory.isoWhiskerLeft (CategoryTheory.shiftFunctor C a) (CategoryTheory.shiftFunctorZero C A).symm))","decl":"lemma shiftFunctorAdd'_add_zero (a : A) :\n    shiftFunctorAdd' C a 0 a (add_zero a) = (Functor.rightUnitor _).symm ‚â™‚â´\n    isoWhiskerLeft (shiftFunctor C a) (shiftFunctorZero C A).symm := by\n  ext\n  dsimp [shiftFunctorAdd', shiftFunctorZero, shiftFunctor]\n  simp only [eqToHom_app, Œµ_app_obj, Discrete.addMonoidal_rightUnitor, eqToIso.inv,\n    eqToHom_map, Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ : A\nh‚ÇÅ‚ÇÇ : Eq (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÅ‚ÇÇ\nh‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd a‚ÇÇ a‚ÇÉ) a‚ÇÇ‚ÇÉ\nh‚ÇÅ‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ) a‚ÇÅ‚ÇÇ‚ÇÉ\n‚ä¢ Eq ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ ‚ãØ).trans ((CategoryTheory.isoWhiskerRight (CategoryTheory.shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ a‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ) (CategoryTheory.shiftFunctor C a‚ÇÉ)).trans ((CategoryTheory.shiftFunctor C a‚ÇÅ).associator (CategoryTheory.shiftFunctor C a‚ÇÇ) (CategoryTheory.shiftFunctor C a‚ÇÉ)))) ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ ‚ãØ).trans (CategoryTheory.isoWhiskerLeft (CategoryTheory.shiftFunctor C a‚ÇÅ) (CategoryTheory.shiftFunctorAdd' C a‚ÇÇ a‚ÇÉ a‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ)))","decl":"lemma shiftFunctorAdd'_assoc (a‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ : A)\n    (h‚ÇÅ‚ÇÇ : a‚ÇÅ + a‚ÇÇ = a‚ÇÅ‚ÇÇ) (h‚ÇÇ‚ÇÉ : a‚ÇÇ + a‚ÇÉ = a‚ÇÇ‚ÇÉ) (h‚ÇÅ‚ÇÇ‚ÇÉ : a‚ÇÅ + a‚ÇÇ + a‚ÇÉ = a‚ÇÅ‚ÇÇ‚ÇÉ) :\n    shiftFunctorAdd' C a‚ÇÅ‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ (by rw [‚Üê h‚ÇÅ‚ÇÇ, h‚ÇÅ‚ÇÇ‚ÇÉ]) ‚â™‚â´\n      isoWhiskerRight (shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ a‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ) _ ‚â™‚â´ Functor.associator _ _ _ =\n    shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ (by rw [‚Üê h‚ÇÇ‚ÇÉ, ‚Üê add_assoc, h‚ÇÅ‚ÇÇ‚ÇÉ]) ‚â™‚â´\n      isoWhiskerLeft _ (shiftFunctorAdd' C a‚ÇÇ a‚ÇÉ a‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ) := by\n  subst h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÇ‚ÇÉ\n  ext X\n  dsimp\n  simp only [shiftFunctorAdd'_eq_shiftFunctorAdd, Category.comp_id]\n  dsimp [shiftFunctorAdd']\n  simp only [eqToHom_app]\n  dsimp [shiftFunctorAdd, shiftFunctor]\n  simp only [obj_Œº_inv_app, Discrete.addMonoidal_associator, eqToIso.hom, eqToHom_map,\n    eqToHom_app]\n  erw [Œ¥_Œº_app_assoc, Category.assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na‚ÇÅ a‚ÇÇ a‚ÇÉ : A\n‚ä¢ Eq ((CategoryTheory.shiftFunctorAdd C (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ).trans ((CategoryTheory.isoWhiskerRight (CategoryTheory.shiftFunctorAdd C a‚ÇÅ a‚ÇÇ) (CategoryTheory.shiftFunctor C a‚ÇÉ)).trans ((CategoryTheory.shiftFunctor C a‚ÇÅ).associator (CategoryTheory.shiftFunctor C a‚ÇÇ) (CategoryTheory.shiftFunctor C a‚ÇÉ)))) ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ (HAdd.hAdd a‚ÇÇ a‚ÇÉ) (HAdd.hAdd (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ) ‚ãØ).trans (CategoryTheory.isoWhiskerLeft (CategoryTheory.shiftFunctor C a‚ÇÅ) (CategoryTheory.shiftFunctorAdd C a‚ÇÇ a‚ÇÉ)))","decl":"lemma shiftFunctorAdd_assoc (a‚ÇÅ a‚ÇÇ a‚ÇÉ : A) :\n    shiftFunctorAdd C (a‚ÇÅ + a‚ÇÇ) a‚ÇÉ ‚â™‚â´\n      isoWhiskerRight (shiftFunctorAdd C a‚ÇÅ a‚ÇÇ) _ ‚â™‚â´ Functor.associator _ _ _ =\n    shiftFunctorAdd' C a‚ÇÅ (a‚ÇÇ + a‚ÇÉ) _ (add_assoc a‚ÇÅ a‚ÇÇ a‚ÇÉ).symm ‚â™‚â´\n      isoWhiskerLeft _ (shiftFunctorAdd C a‚ÇÇ a‚ÇÉ) := by\n  ext X\n  simpa [shiftFunctorAdd'_eq_shiftFunctorAdd]\n    using NatTrans.congr_app (congr_arg Iso.hom\n      (shiftFunctorAdd'_assoc C a‚ÇÅ a‚ÇÇ a‚ÇÉ _ _ _ rfl rfl rfl)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_zero_add_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na : A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctorAdd' C 0 a a ‚ãØ).hom.app X) ((CategoryTheory.shiftFunctor C a).map ((CategoryTheory.shiftFunctorZero C A).inv.app X))","decl":"lemma shiftFunctorAdd'_zero_add_hom_app (a : A) (X : C) :\n    (shiftFunctorAdd' C 0 a a (zero_add a)).hom.app X =\n    ((shiftFunctorZero C A).inv.app X)‚ü¶a‚üß' := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorAdd'_zero_add C a)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_zero_add_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na : A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctorAdd C 0 a).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) ((CategoryTheory.shiftFunctor C a).map ((CategoryTheory.shiftFunctorZero C A).inv.app X)))","decl":"lemma shiftFunctorAdd_zero_add_hom_app (a : A) (X : C) :\n    (shiftFunctorAdd C 0 a).hom.app X =\n    eqToHom (by dsimp; rw [zero_add]) ‚â´ ((shiftFunctorZero C A).inv.app X)‚ü¶a‚üß' := by\n  simp [‚Üê shiftFunctorAdd'_zero_add_hom_app, shiftFunctorAdd']\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_zero_add_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na : A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctorAdd' C 0 a a ‚ãØ).inv.app X) ((CategoryTheory.shiftFunctor C a).map ((CategoryTheory.shiftFunctorZero C A).hom.app X))","decl":"lemma shiftFunctorAdd'_zero_add_inv_app (a : A) (X : C) :\n    (shiftFunctorAdd' C 0 a a (zero_add a)).inv.app X =\n    ((shiftFunctorZero C A).hom.app X)‚ü¶a‚üß' := by\n  simpa using NatTrans.congr_app (congr_arg Iso.inv (shiftFunctorAdd'_zero_add C a)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_zero_add_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na : A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctorAdd C 0 a).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a).map ((CategoryTheory.shiftFunctorZero C A).hom.app X)) (CategoryTheory.eqToHom ‚ãØ))","decl":"lemma shiftFunctorAdd_zero_add_inv_app (a : A) (X : C) : (shiftFunctorAdd C 0 a).inv.app X =\n    ((shiftFunctorZero C A).hom.app X)‚ü¶a‚üß' ‚â´ eqToHom (by dsimp; rw [zero_add]) := by\n  simp [‚Üê shiftFunctorAdd'_zero_add_inv_app, shiftFunctorAdd']\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_add_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na : A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctorAdd' C a 0 a ‚ãØ).hom.app X) ((CategoryTheory.shiftFunctorZero C A).inv.app ((CategoryTheory.shiftFunctor C a).obj X))","decl":"lemma shiftFunctorAdd'_add_zero_hom_app (a : A) (X : C) :\n    (shiftFunctorAdd' C a 0 a (add_zero a)).hom.app X =\n    (shiftFunctorZero C A).inv.app (X‚ü¶a‚üß) := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorAdd'_add_zero C a)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_add_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na : A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctorAdd C a 0).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) ((CategoryTheory.shiftFunctorZero C A).inv.app ((CategoryTheory.shiftFunctor C a).obj X)))","decl":"lemma shiftFunctorAdd_add_zero_hom_app (a : A) (X : C) : (shiftFunctorAdd C a 0).hom.app X =\n    eqToHom (by dsimp; rw [add_zero]) ‚â´ (shiftFunctorZero C A).inv.app (X‚ü¶a‚üß) := by\n  simp [‚Üê shiftFunctorAdd'_add_zero_hom_app, shiftFunctorAdd']\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_add_zero_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na : A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctorAdd' C a 0 a ‚ãØ).inv.app X) ((CategoryTheory.shiftFunctorZero C A).hom.app ((CategoryTheory.shiftFunctor C a).obj X))","decl":"lemma shiftFunctorAdd'_add_zero_inv_app (a : A) (X : C) :\n    (shiftFunctorAdd' C a 0 a (add_zero a)).inv.app X =\n    (shiftFunctorZero C A).hom.app (X‚ü¶a‚üß) := by\n  simpa using NatTrans.congr_app (congr_arg Iso.inv (shiftFunctorAdd'_add_zero C a)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_add_zero_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na : A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctorAdd C a 0).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero C A).hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.eqToHom ‚ãØ))","decl":"lemma shiftFunctorAdd_add_zero_inv_app (a : A) (X : C) : (shiftFunctorAdd C a 0).inv.app X =\n    (shiftFunctorZero C A).hom.app (X‚ü¶a‚üß) ‚â´ eqToHom (by dsimp; rw [add_zero]) := by\n  simp [‚Üê shiftFunctorAdd'_add_zero_inv_app, shiftFunctorAdd']\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_assoc_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ : A\nh‚ÇÅ‚ÇÇ : Eq (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÅ‚ÇÇ\nh‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd a‚ÇÇ a‚ÇÉ) a‚ÇÇ‚ÇÉ\nh‚ÇÅ‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ) a‚ÇÅ‚ÇÇ‚ÇÉ\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C a‚ÇÉ).obj ((CategoryTheory.shiftFunctor C a‚ÇÇ).obj ((CategoryTheory.shiftFunctor C a‚ÇÅ).obj X))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ ‚ãØ).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a‚ÇÉ).map ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ a‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ).hom.app X)) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ ‚ãØ).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a‚ÇÇ a‚ÇÉ a‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ).hom.app ((CategoryTheory.shiftFunctor C a‚ÇÅ).obj X)) h))","decl":"@[reassoc]\nlemma shiftFunctorAdd'_assoc_hom_app (a‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ : A)\n    (h‚ÇÅ‚ÇÇ : a‚ÇÅ + a‚ÇÇ = a‚ÇÅ‚ÇÇ) (h‚ÇÇ‚ÇÉ : a‚ÇÇ + a‚ÇÉ = a‚ÇÇ‚ÇÉ) (h‚ÇÅ‚ÇÇ‚ÇÉ : a‚ÇÅ + a‚ÇÇ + a‚ÇÉ = a‚ÇÅ‚ÇÇ‚ÇÉ) (X : C) :\n    (shiftFunctorAdd' C a‚ÇÅ‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ (by rw [‚Üê h‚ÇÅ‚ÇÇ, h‚ÇÅ‚ÇÇ‚ÇÉ])).hom.app X ‚â´\n      ((shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ a‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ).hom.app X)‚ü¶a‚ÇÉ‚üß' =\n    (shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ (by rw [‚Üê h‚ÇÇ‚ÇÉ, ‚Üê add_assoc, h‚ÇÅ‚ÇÇ‚ÇÉ])).hom.app X ‚â´\n      (shiftFunctorAdd' C a‚ÇÇ a‚ÇÉ a‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ).hom.app (X‚ü¶a‚ÇÅ‚üß) := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom\n    (shiftFunctorAdd'_assoc C _ _ _ _ _ _ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÇ‚ÇÉ)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_assoc_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ : A\nh‚ÇÅ‚ÇÇ : Eq (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÅ‚ÇÇ\nh‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd a‚ÇÇ a‚ÇÉ) a‚ÇÇ‚ÇÉ\nh‚ÇÅ‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ) a‚ÇÅ‚ÇÇ‚ÇÉ\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ ‚ãØ).hom.app X) ((CategoryTheory.shiftFunctor C a‚ÇÉ).map ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ a‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ).hom.app X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ ‚ãØ).hom.app X) ((CategoryTheory.shiftFunctorAdd' C a‚ÇÇ a‚ÇÉ a‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ).hom.app ((CategoryTheory.shiftFunctor C a‚ÇÅ).obj X)))","decl":"@[reassoc]\nlemma shiftFunctorAdd'_assoc_hom_app (a‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ : A)\n    (h‚ÇÅ‚ÇÇ : a‚ÇÅ + a‚ÇÇ = a‚ÇÅ‚ÇÇ) (h‚ÇÇ‚ÇÉ : a‚ÇÇ + a‚ÇÉ = a‚ÇÇ‚ÇÉ) (h‚ÇÅ‚ÇÇ‚ÇÉ : a‚ÇÅ + a‚ÇÇ + a‚ÇÉ = a‚ÇÅ‚ÇÇ‚ÇÉ) (X : C) :\n    (shiftFunctorAdd' C a‚ÇÅ‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ (by rw [‚Üê h‚ÇÅ‚ÇÇ, h‚ÇÅ‚ÇÇ‚ÇÉ])).hom.app X ‚â´\n      ((shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ a‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ).hom.app X)‚ü¶a‚ÇÉ‚üß' =\n    (shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ (by rw [‚Üê h‚ÇÇ‚ÇÉ, ‚Üê add_assoc, h‚ÇÅ‚ÇÇ‚ÇÉ])).hom.app X ‚â´\n      (shiftFunctorAdd' C a‚ÇÇ a‚ÇÉ a‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ).hom.app (X‚ü¶a‚ÇÅ‚üß) := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom\n    (shiftFunctorAdd'_assoc C _ _ _ _ _ _ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÇ‚ÇÉ)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_assoc_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ : A\nh‚ÇÅ‚ÇÇ : Eq (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÅ‚ÇÇ\nh‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd a‚ÇÇ a‚ÇÉ) a‚ÇÇ‚ÇÉ\nh‚ÇÅ‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ) a‚ÇÅ‚ÇÇ‚ÇÉ\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C a‚ÇÅ‚ÇÇ‚ÇÉ).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a‚ÇÉ).map ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ a‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ ‚ãØ).inv.app X) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a‚ÇÇ a‚ÇÉ a‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ).inv.app ((CategoryTheory.shiftFunctor C a‚ÇÅ).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ ‚ãØ).inv.app X) h))","decl":"@[reassoc]\nlemma shiftFunctorAdd'_assoc_inv_app (a‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ : A)\n    (h‚ÇÅ‚ÇÇ : a‚ÇÅ + a‚ÇÇ = a‚ÇÅ‚ÇÇ) (h‚ÇÇ‚ÇÉ : a‚ÇÇ + a‚ÇÉ = a‚ÇÇ‚ÇÉ) (h‚ÇÅ‚ÇÇ‚ÇÉ : a‚ÇÅ + a‚ÇÇ + a‚ÇÉ = a‚ÇÅ‚ÇÇ‚ÇÉ) (X : C) :\n    ((shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ a‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ).inv.app X)‚ü¶a‚ÇÉ‚üß' ‚â´\n      (shiftFunctorAdd' C a‚ÇÅ‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ (by rw [‚Üê h‚ÇÅ‚ÇÇ, h‚ÇÅ‚ÇÇ‚ÇÉ])).inv.app X =\n    (shiftFunctorAdd' C a‚ÇÇ a‚ÇÉ a‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ).inv.app (X‚ü¶a‚ÇÅ‚üß) ‚â´\n      (shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ (by rw [‚Üê h‚ÇÇ‚ÇÉ, ‚Üê add_assoc, h‚ÇÅ‚ÇÇ‚ÇÉ])).inv.app X := by\n  simpa using NatTrans.congr_app (congr_arg Iso.inv\n    (shiftFunctorAdd'_assoc C _ _ _ _ _ _ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÇ‚ÇÉ)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd'_assoc_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ : A\nh‚ÇÅ‚ÇÇ : Eq (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÅ‚ÇÇ\nh‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd a‚ÇÇ a‚ÇÉ) a‚ÇÇ‚ÇÉ\nh‚ÇÅ‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ) a‚ÇÅ‚ÇÇ‚ÇÉ\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a‚ÇÉ).map ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ a‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ).inv.app X)) ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ ‚ãØ).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a‚ÇÇ a‚ÇÉ a‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ).inv.app ((CategoryTheory.shiftFunctor C a‚ÇÅ).obj X)) ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ ‚ãØ).inv.app X))","decl":"@[reassoc]\nlemma shiftFunctorAdd'_assoc_inv_app (a‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ : A)\n    (h‚ÇÅ‚ÇÇ : a‚ÇÅ + a‚ÇÇ = a‚ÇÅ‚ÇÇ) (h‚ÇÇ‚ÇÉ : a‚ÇÇ + a‚ÇÉ = a‚ÇÇ‚ÇÉ) (h‚ÇÅ‚ÇÇ‚ÇÉ : a‚ÇÅ + a‚ÇÇ + a‚ÇÉ = a‚ÇÅ‚ÇÇ‚ÇÉ) (X : C) :\n    ((shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ a‚ÇÅ‚ÇÇ h‚ÇÅ‚ÇÇ).inv.app X)‚ü¶a‚ÇÉ‚üß' ‚â´\n      (shiftFunctorAdd' C a‚ÇÅ‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ (by rw [‚Üê h‚ÇÅ‚ÇÇ, h‚ÇÅ‚ÇÇ‚ÇÉ])).inv.app X =\n    (shiftFunctorAdd' C a‚ÇÇ a‚ÇÉ a‚ÇÇ‚ÇÉ h‚ÇÇ‚ÇÉ).inv.app (X‚ü¶a‚ÇÅ‚üß) ‚â´\n      (shiftFunctorAdd' C a‚ÇÅ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ‚ÇÉ (by rw [‚Üê h‚ÇÇ‚ÇÉ, ‚Üê add_assoc, h‚ÇÅ‚ÇÇ‚ÇÉ])).inv.app X := by\n  simpa using NatTrans.congr_app (congr_arg Iso.inv\n    (shiftFunctorAdd'_assoc C _ _ _ _ _ _ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÇ‚ÇÉ)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_assoc_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na‚ÇÅ a‚ÇÇ a‚ÇÉ : A\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ).hom.app X) ((CategoryTheory.shiftFunctor C a‚ÇÉ).map ((CategoryTheory.shiftFunctorAdd C a‚ÇÅ a‚ÇÇ).hom.app X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ (HAdd.hAdd a‚ÇÇ a‚ÇÉ) (HAdd.hAdd (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ) ‚ãØ).hom.app X) ((CategoryTheory.shiftFunctorAdd C a‚ÇÇ a‚ÇÉ).hom.app ((CategoryTheory.shiftFunctor C a‚ÇÅ).obj X)))","decl":"@[reassoc]\nlemma shiftFunctorAdd_assoc_hom_app (a‚ÇÅ a‚ÇÇ a‚ÇÉ : A) (X : C) :\n    (shiftFunctorAdd C (a‚ÇÅ + a‚ÇÇ) a‚ÇÉ).hom.app X ‚â´\n      ((shiftFunctorAdd C a‚ÇÅ a‚ÇÇ).hom.app X)‚ü¶a‚ÇÉ‚üß' =\n    (shiftFunctorAdd' C a‚ÇÅ (a‚ÇÇ + a‚ÇÉ) (a‚ÇÅ + a‚ÇÇ + a‚ÇÉ) (add_assoc _ _ _).symm).hom.app X ‚â´\n      (shiftFunctorAdd C a‚ÇÇ a‚ÇÉ).hom.app (X‚ü¶a‚ÇÅ‚üß) := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorAdd_assoc C a‚ÇÅ a‚ÇÇ a‚ÇÉ)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_assoc_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na‚ÇÅ a‚ÇÇ a‚ÇÉ : A\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C a‚ÇÉ).obj ((CategoryTheory.shiftFunctor C a‚ÇÇ).obj ((CategoryTheory.shiftFunctor C a‚ÇÅ).obj X))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a‚ÇÉ).map ((CategoryTheory.shiftFunctorAdd C a‚ÇÅ a‚ÇÇ).hom.app X)) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ (HAdd.hAdd a‚ÇÇ a‚ÇÉ) (HAdd.hAdd (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ) ‚ãØ).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C a‚ÇÇ a‚ÇÉ).hom.app ((CategoryTheory.shiftFunctor C a‚ÇÅ).obj X)) h))","decl":"@[reassoc]\nlemma shiftFunctorAdd_assoc_hom_app (a‚ÇÅ a‚ÇÇ a‚ÇÉ : A) (X : C) :\n    (shiftFunctorAdd C (a‚ÇÅ + a‚ÇÇ) a‚ÇÉ).hom.app X ‚â´\n      ((shiftFunctorAdd C a‚ÇÅ a‚ÇÇ).hom.app X)‚ü¶a‚ÇÉ‚üß' =\n    (shiftFunctorAdd' C a‚ÇÅ (a‚ÇÇ + a‚ÇÉ) (a‚ÇÅ + a‚ÇÇ + a‚ÇÉ) (add_assoc _ _ _).symm).hom.app X ‚â´\n      (shiftFunctorAdd C a‚ÇÇ a‚ÇÉ).hom.app (X‚ü¶a‚ÇÅ‚üß) := by\n  simpa using NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorAdd_assoc C a‚ÇÅ a‚ÇÇ a‚ÇÉ)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_assoc_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na‚ÇÅ a‚ÇÇ a‚ÇÉ : A\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a‚ÇÉ).map ((CategoryTheory.shiftFunctorAdd C a‚ÇÅ a‚ÇÇ).inv.app X)) ((CategoryTheory.shiftFunctorAdd C (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C a‚ÇÇ a‚ÇÉ).inv.app ((CategoryTheory.shiftFunctor C a‚ÇÅ).obj X)) ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ (HAdd.hAdd a‚ÇÇ a‚ÇÉ) (HAdd.hAdd (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ) ‚ãØ).inv.app X))","decl":"@[reassoc]\nlemma shiftFunctorAdd_assoc_inv_app (a‚ÇÅ a‚ÇÇ a‚ÇÉ : A) (X : C) :\n    ((shiftFunctorAdd C a‚ÇÅ a‚ÇÇ).inv.app X)‚ü¶a‚ÇÉ‚üß' ‚â´\n      (shiftFunctorAdd C (a‚ÇÅ + a‚ÇÇ) a‚ÇÉ).inv.app X =\n    (shiftFunctorAdd C a‚ÇÇ a‚ÇÉ).inv.app (X‚ü¶a‚ÇÅ‚üß) ‚â´\n      (shiftFunctorAdd' C a‚ÇÅ (a‚ÇÇ + a‚ÇÉ) (a‚ÇÅ + a‚ÇÇ + a‚ÇÉ) (add_assoc _ _ _).symm).inv.app X := by\n  simpa using NatTrans.congr_app (congr_arg Iso.inv (shiftFunctorAdd_assoc C a‚ÇÅ a‚ÇÇ a‚ÇÉ)) X\n\n"}
{"name":"CategoryTheory.shiftFunctorAdd_assoc_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\na‚ÇÅ a‚ÇÇ a‚ÇÉ : A\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C (HAdd.hAdd (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ)).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C a‚ÇÉ).map ((CategoryTheory.shiftFunctorAdd C a‚ÇÅ a‚ÇÇ).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ).inv.app X) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C a‚ÇÇ a‚ÇÉ).inv.app ((CategoryTheory.shiftFunctor C a‚ÇÅ).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C a‚ÇÅ (HAdd.hAdd a‚ÇÇ a‚ÇÉ) (HAdd.hAdd (HAdd.hAdd a‚ÇÅ a‚ÇÇ) a‚ÇÉ) ‚ãØ).inv.app X) h))","decl":"@[reassoc]\nlemma shiftFunctorAdd_assoc_inv_app (a‚ÇÅ a‚ÇÇ a‚ÇÉ : A) (X : C) :\n    ((shiftFunctorAdd C a‚ÇÅ a‚ÇÇ).inv.app X)‚ü¶a‚ÇÉ‚üß' ‚â´\n      (shiftFunctorAdd C (a‚ÇÅ + a‚ÇÇ) a‚ÇÉ).inv.app X =\n    (shiftFunctorAdd C a‚ÇÇ a‚ÇÉ).inv.app (X‚ü¶a‚ÇÅ‚üß) ‚â´\n      (shiftFunctorAdd' C a‚ÇÅ (a‚ÇÇ + a‚ÇÉ) (a‚ÇÅ + a‚ÇÇ + a‚ÇÉ) (add_assoc _ _ _).symm).inv.app X := by\n  simpa using NatTrans.congr_app (congr_arg Iso.inv (shiftFunctorAdd_assoc C a‚ÇÅ a‚ÇÇ a‚ÇÉ)) X\n\n"}
{"name":"CategoryTheory.shift_shift'","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\ni j : A\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C j).map ((CategoryTheory.shiftFunctor C i).map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.shiftAdd X i j).inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C (HAdd.hAdd i j)).map f) (CategoryTheory.shiftAdd Y i j).hom))","decl":"theorem shift_shift' (i j : A) :\n    f‚ü¶i‚üß'‚ü¶j‚üß' = (shiftAdd X i j).inv ‚â´ f‚ü¶i + j‚üß' ‚â´ (shiftAdd Y i j).hom := by\n  symm\n  rw [‚Üê Functor.comp_map, NatIso.app_inv]\n  apply NatIso.naturality_1\n\n"}
{"name":"CategoryTheory.shiftZero'","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C 0).map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.shiftZero A X).hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.shiftZero A Y).inv))","decl":"theorem shiftZero' : f‚ü¶(0 : A)‚üß' = (shiftZero A X).hom ‚â´ f ‚â´ (shiftZero A Y).inv := by\n  symm\n  rw [NatIso.app_inv, NatIso.app_hom]\n  apply NatIso.naturality_2\n\n"}
{"name":"CategoryTheory.shiftEquiv'_counitIso","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\ni j : A\nh : Eq (HAdd.hAdd i j) 0\n‚ä¢ Eq (CategoryTheory.shiftEquiv' C i j h).counitIso (CategoryTheory.shiftFunctorCompIsoId C j i ‚ãØ)","decl":"/-- Shifting by `i` and shifting by `j` forms an equivalence when `i + j = 0`. -/\n@[simps]\ndef shiftEquiv' (i j : A) (h : i + j = 0) : C ‚âå C where\n  functor := shiftFunctor C i\n  inverse := shiftFunctor C j\n  unitIso := (shiftFunctorCompIsoId C i j h).symm\n  counitIso := shiftFunctorCompIsoId C j i\n    (by rw [‚Üê add_left_inj j, add_assoc, h, zero_add, add_zero])\n  functor_unitIso_comp X := by\n    convert (equivOfTensorIsoUnit (shiftMonoidalFunctor C A) ‚ü®i‚ü© ‚ü®j‚ü© (Discrete.eqToIso h)\n      (Discrete.eqToIso (by dsimp; rw [‚Üê add_left_inj j, add_assoc, h, zero_add, add_zero]))\n      (Subsingleton.elim _ _)).functor_unitIso_comp X\n    all_goals\n      ext X\n      dsimp [shiftFunctorCompIsoId, unitOfTensorIsoUnit,\n        shiftFunctorAdd']\n      simp only [Category.assoc, eqToHom_map]\n      rfl\n\n"}
{"name":"CategoryTheory.shiftEquiv'_unitIso","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\ni j : A\nh : Eq (HAdd.hAdd i j) 0\n‚ä¢ Eq (CategoryTheory.shiftEquiv' C i j h).unitIso (CategoryTheory.shiftFunctorCompIsoId C i j h).symm","decl":"/-- Shifting by `i` and shifting by `j` forms an equivalence when `i + j = 0`. -/\n@[simps]\ndef shiftEquiv' (i j : A) (h : i + j = 0) : C ‚âå C where\n  functor := shiftFunctor C i\n  inverse := shiftFunctor C j\n  unitIso := (shiftFunctorCompIsoId C i j h).symm\n  counitIso := shiftFunctorCompIsoId C j i\n    (by rw [‚Üê add_left_inj j, add_assoc, h, zero_add, add_zero])\n  functor_unitIso_comp X := by\n    convert (equivOfTensorIsoUnit (shiftMonoidalFunctor C A) ‚ü®i‚ü© ‚ü®j‚ü© (Discrete.eqToIso h)\n      (Discrete.eqToIso (by dsimp; rw [‚Üê add_left_inj j, add_assoc, h, zero_add, add_zero]))\n      (Subsingleton.elim _ _)).functor_unitIso_comp X\n    all_goals\n      ext X\n      dsimp [shiftFunctorCompIsoId, unitOfTensorIsoUnit,\n        shiftFunctorAdd']\n      simp only [Category.assoc, eqToHom_map]\n      rfl\n\n"}
{"name":"CategoryTheory.shiftEquiv'_functor","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\ni j : A\nh : Eq (HAdd.hAdd i j) 0\n‚ä¢ Eq (CategoryTheory.shiftEquiv' C i j h).functor (CategoryTheory.shiftFunctor C i)","decl":"/-- Shifting by `i` and shifting by `j` forms an equivalence when `i + j = 0`. -/\n@[simps]\ndef shiftEquiv' (i j : A) (h : i + j = 0) : C ‚âå C where\n  functor := shiftFunctor C i\n  inverse := shiftFunctor C j\n  unitIso := (shiftFunctorCompIsoId C i j h).symm\n  counitIso := shiftFunctorCompIsoId C j i\n    (by rw [‚Üê add_left_inj j, add_assoc, h, zero_add, add_zero])\n  functor_unitIso_comp X := by\n    convert (equivOfTensorIsoUnit (shiftMonoidalFunctor C A) ‚ü®i‚ü© ‚ü®j‚ü© (Discrete.eqToIso h)\n      (Discrete.eqToIso (by dsimp; rw [‚Üê add_left_inj j, add_assoc, h, zero_add, add_zero]))\n      (Subsingleton.elim _ _)).functor_unitIso_comp X\n    all_goals\n      ext X\n      dsimp [shiftFunctorCompIsoId, unitOfTensorIsoUnit,\n        shiftFunctorAdd']\n      simp only [Category.assoc, eqToHom_map]\n      rfl\n\n"}
{"name":"CategoryTheory.shiftEquiv'_inverse","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\ni j : A\nh : Eq (HAdd.hAdd i j) 0\n‚ä¢ Eq (CategoryTheory.shiftEquiv' C i j h).inverse (CategoryTheory.shiftFunctor C j)","decl":"/-- Shifting by `i` and shifting by `j` forms an equivalence when `i + j = 0`. -/\n@[simps]\ndef shiftEquiv' (i j : A) (h : i + j = 0) : C ‚âå C where\n  functor := shiftFunctor C i\n  inverse := shiftFunctor C j\n  unitIso := (shiftFunctorCompIsoId C i j h).symm\n  counitIso := shiftFunctorCompIsoId C j i\n    (by rw [‚Üê add_left_inj j, add_assoc, h, zero_add, add_zero])\n  functor_unitIso_comp X := by\n    convert (equivOfTensorIsoUnit (shiftMonoidalFunctor C A) ‚ü®i‚ü© ‚ü®j‚ü© (Discrete.eqToIso h)\n      (Discrete.eqToIso (by dsimp; rw [‚Üê add_left_inj j, add_assoc, h, zero_add, add_zero]))\n      (Subsingleton.elim _ _)).functor_unitIso_comp X\n    all_goals\n      ext X\n      dsimp [shiftFunctorCompIsoId, unitOfTensorIsoUnit,\n        shiftFunctorAdd']\n      simp only [Category.assoc, eqToHom_map]\n      rfl\n\n"}
{"name":"CategoryTheory.instIsEquivalenceShiftFunctor","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\ni : A\n‚ä¢ (CategoryTheory.shiftFunctor C i).IsEquivalence","decl":"/-- Shifting by `i` is an equivalence. -/\ninstance (i : A) : (shiftFunctor C i).IsEquivalence := by\n  change (shiftEquiv C i).functor.IsEquivalence\n  infer_instance\n\n"}
{"name":"CategoryTheory.shift_shift_neg'","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\ni : A\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C (Neg.neg i)).map ((CategoryTheory.shiftFunctor C i).map f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId C i (Neg.neg i) ‚ãØ).hom.app X) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.shiftFunctorCompIsoId C i (Neg.neg i) ‚ãØ).inv.app Y)))","decl":"theorem shift_shift_neg' (i : A) :\n    f‚ü¶i‚üß'‚ü¶-i‚üß' = (shiftFunctorCompIsoId C i (-i) (add_neg_cancel i)).hom.app X ‚â´\n      f ‚â´ (shiftFunctorCompIsoId C i (-i) (add_neg_cancel i)).inv.app Y :=\n  (NatIso.naturality_2 (shiftFunctorCompIsoId C i (-i) (add_neg_cancel i)) f).symm\n\n"}
{"name":"CategoryTheory.shift_neg_shift'","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\ni : A\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C i).map ((CategoryTheory.shiftFunctor C (Neg.neg i)).map f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId C (Neg.neg i) i ‚ãØ).hom.app X) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.shiftFunctorCompIsoId C (Neg.neg i) i ‚ãØ).inv.app Y)))","decl":"theorem shift_neg_shift' (i : A) :\n    f‚ü¶-i‚üß'‚ü¶i‚üß' = (shiftFunctorCompIsoId C (-i) i (neg_add_cancel i)).hom.app X ‚â´ f ‚â´\n      (shiftFunctorCompIsoId C (-i) i (neg_add_cancel i)).inv.app Y :=\n  (NatIso.naturality_2 (shiftFunctorCompIsoId C (-i) i (neg_add_cancel i)) f).symm\n\n"}
{"name":"CategoryTheory.shift_equiv_triangle","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\nn : A\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map (CategoryTheory.shiftShiftNeg X n).inv) (CategoryTheory.shiftNegShift ((CategoryTheory.shiftFunctor C n).obj X) n).hom) (CategoryTheory.CategoryStruct.id ((CategoryTheory.shiftFunctor C n).obj X))","decl":"theorem shift_equiv_triangle (n : A) (X : C) :\n    (shiftShiftNeg X n).inv‚ü¶n‚üß' ‚â´ (shiftNegShift (X‚ü¶n‚üß) n).hom = ùüô (X‚ü¶n‚üß) :=\n  (shiftEquiv C n).functor_unitIso_comp X\n\n"}
{"name":"CategoryTheory.shift_shiftFunctorCompIsoId_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\nn m : A\nh : Eq (HAdd.hAdd n m) 0\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorCompIsoId C n m h).hom.app X)) ((CategoryTheory.shiftFunctorCompIsoId C m n ‚ãØ).hom.app ((CategoryTheory.shiftFunctor C n).obj X))","decl":"theorem shift_shiftFunctorCompIsoId_hom_app (n m : A) (h : n + m = 0) (X : C) :\n    ((shiftFunctorCompIsoId C n m h).hom.app X)‚ü¶n‚üß' =\n    (shiftFunctorCompIsoId C m n\n      (by rw [‚Üê neg_eq_of_add_eq_zero_left h, add_neg_cancel])).hom.app (X‚ü¶n‚üß) := by\n  dsimp [shiftFunctorCompIsoId]\n  simpa only [Functor.map_comp, ‚Üê shiftFunctorAdd'_zero_add_inv_app n X,\n    ‚Üê shiftFunctorAdd'_add_zero_inv_app n X]\n    using shiftFunctorAdd'_assoc_inv_app n m n 0 0 n h\n      (by rw [‚Üê neg_eq_of_add_eq_zero_left h, add_neg_cancel]) (by rw [h, zero_add]) X\n\n"}
{"name":"CategoryTheory.shift_shiftFunctorCompIsoId_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\nn m : A\nh : Eq (HAdd.hAdd n m) 0\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorCompIsoId C n m h).inv.app X)) ((CategoryTheory.shiftFunctorCompIsoId C m n ‚ãØ).inv.app ((CategoryTheory.shiftFunctor C n).obj X))","decl":"theorem shift_shiftFunctorCompIsoId_inv_app (n m : A) (h : n + m = 0) (X : C) :\n    ((shiftFunctorCompIsoId C n m h).inv.app X)‚ü¶n‚üß' =\n    ((shiftFunctorCompIsoId C m n\n      (by rw [‚Üê neg_eq_of_add_eq_zero_left h, add_neg_cancel])).inv.app (X‚ü¶n‚üß)) := by\n  rw [‚Üê cancel_mono (((shiftFunctorCompIsoId C n m h).hom.app X)‚ü¶n‚üß'),\n    ‚Üê Functor.map_comp, Iso.inv_hom_id_app, Functor.map_id,\n    shift_shiftFunctorCompIsoId_hom_app, Iso.inv_hom_id_app]\n  rfl\n\n"}
{"name":"CategoryTheory.shift_shiftFunctorCompIsoId_add_neg_cancel_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\nn : A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorCompIsoId C n (Neg.neg n) ‚ãØ).hom.app X)) ((CategoryTheory.shiftFunctorCompIsoId C (Neg.neg n) n ‚ãØ).hom.app ((CategoryTheory.shiftFunctor C n).obj X))","decl":"theorem shift_shiftFunctorCompIsoId_add_neg_cancel_hom_app (n : A) (X : C) :\n    ((shiftFunctorCompIsoId C n (-n) (add_neg_cancel n)).hom.app X)‚ü¶n‚üß' =\n    (shiftFunctorCompIsoId C (-n) n (neg_add_cancel n)).hom.app (X‚ü¶n‚üß) := by\n  apply shift_shiftFunctorCompIsoId_hom_app\n\n"}
{"name":"CategoryTheory.shift_shiftFunctorCompIsoId_add_neg_cancel_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\nn : A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorCompIsoId C n (Neg.neg n) ‚ãØ).inv.app X)) ((CategoryTheory.shiftFunctorCompIsoId C (Neg.neg n) n ‚ãØ).inv.app ((CategoryTheory.shiftFunctor C n).obj X))","decl":"theorem shift_shiftFunctorCompIsoId_add_neg_cancel_inv_app (n : A) (X : C) :\n    ((shiftFunctorCompIsoId C n (-n) (add_neg_cancel n)).inv.app X)‚ü¶n‚üß' =\n    (shiftFunctorCompIsoId C (-n) n (neg_add_cancel n)).inv.app (X‚ü¶n‚üß) := by\n  apply shift_shiftFunctorCompIsoId_inv_app\n\n"}
{"name":"CategoryTheory.shift_shiftFunctorCompIsoId_neg_add_cancel_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\nn : A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C (Neg.neg n)).map ((CategoryTheory.shiftFunctorCompIsoId C (Neg.neg n) n ‚ãØ).hom.app X)) ((CategoryTheory.shiftFunctorCompIsoId C n (Neg.neg n) ‚ãØ).hom.app ((CategoryTheory.shiftFunctor C (Neg.neg n)).obj X))","decl":"theorem shift_shiftFunctorCompIsoId_neg_add_cancel_hom_app (n : A) (X : C) :\n    ((shiftFunctorCompIsoId C (-n) n (neg_add_cancel n)).hom.app X)‚ü¶-n‚üß' =\n    (shiftFunctorCompIsoId C n (-n) (add_neg_cancel n)).hom.app (X‚ü¶-n‚üß) := by\n  apply shift_shiftFunctorCompIsoId_hom_app\n\n"}
{"name":"CategoryTheory.shift_shiftFunctorCompIsoId_neg_add_cancel_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\nn : A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C (Neg.neg n)).map ((CategoryTheory.shiftFunctorCompIsoId C (Neg.neg n) n ‚ãØ).inv.app X)) ((CategoryTheory.shiftFunctorCompIsoId C n (Neg.neg n) ‚ãØ).inv.app ((CategoryTheory.shiftFunctor C (Neg.neg n)).obj X))","decl":"theorem shift_shiftFunctorCompIsoId_neg_add_cancel_inv_app (n : A) (X : C) :\n    ((shiftFunctorCompIsoId C (-n) n (neg_add_cancel n)).inv.app X)‚ü¶-n‚üß' =\n    (shiftFunctorCompIsoId C n (-n) (add_neg_cancel n)).inv.app (X‚ü¶-n‚üß) := by\n  apply shift_shiftFunctorCompIsoId_inv_app\n\n"}
{"name":"CategoryTheory.shiftFunctorCompIsoId_zero_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctorCompIsoId C 0 0 ‚ãØ).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C 0).map ((CategoryTheory.shiftFunctorZero C A).hom.app X)) ((CategoryTheory.shiftFunctorZero C A).hom.app X))","decl":"lemma shiftFunctorCompIsoId_zero_zero_hom_app (X : C) :\n    (shiftFunctorCompIsoId C 0 0 (add_zero 0)).hom.app X =\n      ((shiftFunctorZero C A).hom.app X)‚ü¶0‚üß' ‚â´ (shiftFunctorZero C A).hom.app X := by\n  simp [shiftFunctorCompIsoId, shiftFunctorAdd'_zero_add_inv_app]\n\n"}
{"name":"CategoryTheory.shiftFunctorCompIsoId_zero_zero_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\nX : C\n‚ä¢ Eq ((CategoryTheory.shiftFunctorCompIsoId C 0 0 ‚ãØ).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero C A).inv.app X) ((CategoryTheory.shiftFunctor C 0).map ((CategoryTheory.shiftFunctorZero C A).inv.app X)))","decl":"lemma shiftFunctorCompIsoId_zero_zero_inv_app (X : C) :\n    (shiftFunctorCompIsoId C 0 0 (add_zero 0)).inv.app X =\n      (shiftFunctorZero C A).inv.app X ‚â´ ((shiftFunctorZero C A).inv.app X)‚ü¶0‚üß' := by\n  simp [shiftFunctorCompIsoId, shiftFunctorAdd'_zero_add_hom_app]\n\n"}
{"name":"CategoryTheory.shiftFunctorCompIsoId_add'_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\nX : C\nm n p m' n' p' : A\nhm : Eq (HAdd.hAdd m' m) 0\nhn : Eq (HAdd.hAdd n' n) 0\nhp : Eq (HAdd.hAdd p' p) 0\nh : Eq (HAdd.hAdd m n) p\n‚ä¢ Eq ((CategoryTheory.shiftFunctorCompIsoId C p' p hp).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId C n' n hn).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorCompIsoId C m' m hm).inv.app ((CategoryTheory.shiftFunctor C n').obj X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C m n p h).inv.app ((CategoryTheory.shiftFunctor C m').obj ((CategoryTheory.shiftFunctor C n').obj X))) ((CategoryTheory.shiftFunctor C p).map ((CategoryTheory.shiftFunctorAdd' C n' m' p' ‚ãØ).inv.app X)))))","decl":"lemma shiftFunctorCompIsoId_add'_inv_app :\n    (shiftFunctorCompIsoId C p' p hp).inv.app X =\n      (shiftFunctorCompIsoId C n' n hn).inv.app X ‚â´\n      (shiftFunctorCompIsoId C m' m hm).inv.app (X‚ü¶n'‚üß)‚ü¶n‚üß' ‚â´\n      (shiftFunctorAdd' C m n p h).inv.app (X‚ü¶n'‚üß‚ü¶m'‚üß) ‚â´\n      ((shiftFunctorAdd' C n' m' p'\n        (by rw [‚Üê add_left_inj p, hp, ‚Üê h, add_assoc,\n          ‚Üê add_assoc m', hm, zero_add, hn])).inv.app X)‚ü¶p‚üß' := by\n  dsimp [shiftFunctorCompIsoId]\n  simp only [Functor.map_comp, Category.assoc]\n  congr 1\n  rw [‚Üê NatTrans.naturality]\n  dsimp\n  rw [‚Üê cancel_mono ((shiftFunctorAdd' C p' p 0 hp).inv.app X), Iso.hom_inv_id_app,\n    Category.assoc, Category.assoc, Category.assoc, Category.assoc,\n    ‚Üê shiftFunctorAdd'_assoc_inv_app p' m n n' p 0\n      (by rw [‚Üê add_left_inj n, hn, add_assoc, h, hp]) h (by rw [add_assoc, h, hp]),\n    ‚Üê Functor.map_comp_assoc, ‚Üê Functor.map_comp_assoc, ‚Üê Functor.map_comp_assoc,\n    Category.assoc, Category.assoc,\n    shiftFunctorAdd'_assoc_inv_app n' m' m p' 0 n' _ _\n      (by rw [add_assoc, hm, add_zero]), Iso.hom_inv_id_app_assoc,\n    ‚Üê shiftFunctorAdd'_add_zero_hom_app, Iso.hom_inv_id_app,\n    Functor.map_id, Category.id_comp, Iso.hom_inv_id_app]\n\n"}
{"name":"CategoryTheory.shiftFunctorCompIsoId_add'_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddGroup A\ninst‚úù : CategoryTheory.HasShift C A\nX : C\nm n p m' n' p' : A\nhm : Eq (HAdd.hAdd m' m) 0\nhn : Eq (HAdd.hAdd n' n) 0\nhp : Eq (HAdd.hAdd p' p) 0\nh : Eq (HAdd.hAdd m n) p\n‚ä¢ Eq ((CategoryTheory.shiftFunctorCompIsoId C p' p hp).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C p).map ((CategoryTheory.shiftFunctorAdd' C n' m' p' ‚ãØ).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' C m n p h).hom.app ((CategoryTheory.shiftFunctor C m').obj ((CategoryTheory.shiftFunctor C n').obj X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorCompIsoId C m' m hm).hom.app ((CategoryTheory.shiftFunctor C n').obj X))) ((CategoryTheory.shiftFunctorCompIsoId C n' n hn).hom.app X))))","decl":"lemma shiftFunctorCompIsoId_add'_hom_app :\n    (shiftFunctorCompIsoId C p' p hp).hom.app X =\n      ((shiftFunctorAdd' C n' m' p'\n          (by rw [‚Üê add_left_inj p, hp, ‚Üê h, add_assoc,\n            ‚Üê add_assoc m', hm, zero_add, hn])).hom.app X)‚ü¶p‚üß' ‚â´\n      (shiftFunctorAdd' C m n p h).hom.app (X‚ü¶n'‚üß‚ü¶m'‚üß) ‚â´\n      (shiftFunctorCompIsoId C m' m hm).hom.app (X‚ü¶n'‚üß)‚ü¶n‚üß' ‚â´\n      (shiftFunctorCompIsoId C n' n hn).hom.app X := by\n  rw [‚Üê cancel_mono ((shiftFunctorCompIsoId C p' p hp).inv.app X), Iso.hom_inv_id_app,\n    shiftFunctorCompIsoId_add'_inv_app m n p m' n' p' hm hn hp h,\n    Category.assoc, Category.assoc, Category.assoc, Iso.hom_inv_id_app_assoc,\n    ‚Üê Functor.map_comp_assoc, Iso.hom_inv_id_app]\n  dsimp\n  rw [Functor.map_id, Category.id_comp, Iso.hom_inv_id_app_assoc,\n    ‚Üê Functor.map_comp, Iso.hom_inv_id_app, Functor.map_id]\n\n"}
{"name":"CategoryTheory.shift_zero_eq_zero","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : AddGroup A\ninst‚úù¬π : CategoryTheory.HasShift C A\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nn : A\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C n).map 0) 0","decl":"theorem shift_zero_eq_zero (X Y : C) (n : A) : (0 : X ‚ü∂ Y)‚ü¶n‚üß' = (0 : X‚ü¶n‚üß ‚ü∂ Y‚ü¶n‚üß) :=\n  CategoryTheory.Functor.map_zero _ _ _\n\n"}
{"name":"CategoryTheory.shiftFunctorComm_eq","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : CategoryTheory.HasShift C A\ni j k : A\nh : Eq (HAdd.hAdd i j) k\n‚ä¢ Eq (CategoryTheory.shiftFunctorComm C i j) ((CategoryTheory.shiftFunctorAdd' C i j k h).symm.trans (CategoryTheory.shiftFunctorAdd' C j i k ‚ãØ))","decl":"lemma shiftFunctorComm_eq (i j k : A) (h : i + j = k) :\n    shiftFunctorComm C i j = (shiftFunctorAdd' C i j k h).symm ‚â™‚â´\n      shiftFunctorAdd' C j i k (by rw [add_comm j i, h]) := by\n  subst h\n  rw [shiftFunctorAdd'_eq_shiftFunctorAdd]\n  rfl\n\n"}
{"name":"CategoryTheory.shiftFunctorComm_eq_refl","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : CategoryTheory.HasShift C A\ni : A\n‚ä¢ Eq (CategoryTheory.shiftFunctorComm C i i) (CategoryTheory.Iso.refl ((CategoryTheory.shiftFunctor C i).comp (CategoryTheory.shiftFunctor C i)))","decl":"@[simp]\nlemma shiftFunctorComm_eq_refl (i : A) :\n    shiftFunctorComm C i i = Iso.refl _ := by\n  rw [shiftFunctorComm_eq C i i (i + i) rfl, Iso.symm_self_id]\n\n"}
{"name":"CategoryTheory.shiftFunctorComm_symm","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : CategoryTheory.HasShift C A\ni j : A\n‚ä¢ Eq (CategoryTheory.shiftFunctorComm C i j).symm (CategoryTheory.shiftFunctorComm C j i)","decl":"lemma shiftFunctorComm_symm (i j : A) :\n    (shiftFunctorComm C i j).symm = shiftFunctorComm C j i := by\n  ext1\n  dsimp\n  rw [shiftFunctorComm_eq C i j (i+j) rfl, shiftFunctorComm_eq C j i (i+j) (add_comm j i)]\n  rfl\n\n"}
{"name":"CategoryTheory.shiftComm_symm","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : CategoryTheory.HasShift C A\nX : C\ni j : A\n‚ä¢ Eq (CategoryTheory.shiftComm X i j).symm (CategoryTheory.shiftComm X j i)","decl":"@[simp]\ntheorem shiftComm_symm (i j : A) : (shiftComm X i j).symm = shiftComm X j i := by\n  ext\n  exact NatTrans.congr_app (congr_arg Iso.hom (shiftFunctorComm_symm C i j)) X\n\n"}
{"name":"CategoryTheory.shiftComm'","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\ni j : A\n‚ä¢ Eq ((CategoryTheory.shiftFunctor C j).map ((CategoryTheory.shiftFunctor C i).map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.shiftComm X i j).hom (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C i).map ((CategoryTheory.shiftFunctor C j).map f)) (CategoryTheory.shiftComm Y j i).hom))","decl":"/-- When shifts are indexed by an additive commutative monoid, then shifts commute. -/\ntheorem shiftComm' (i j : A) :\n    f‚ü¶i‚üß'‚ü¶j‚üß' = (shiftComm _ _ _).hom ‚â´ f‚ü¶j‚üß'‚ü¶i‚üß' ‚â´ (shiftComm _ _ _).hom := by\n  erw [‚Üê shiftComm_symm Y i j, ‚Üê ((shiftFunctorComm C i j).hom.naturality_assoc f)]\n  dsimp\n  simp only [Iso.hom_inv_id_app, Functor.comp_obj, Category.comp_id]\n\n"}
{"name":"CategoryTheory.shiftComm_hom_comp","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\ni j : A\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.shiftComm X i j).hom ((CategoryTheory.shiftFunctor C i).map ((CategoryTheory.shiftFunctor C j).map f))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C j).map ((CategoryTheory.shiftFunctor C i).map f)) (CategoryTheory.shiftComm Y i j).hom)","decl":"@[reassoc]\ntheorem shiftComm_hom_comp (i j : A) :\n    (shiftComm X i j).hom ‚â´ f‚ü¶j‚üß'‚ü¶i‚üß' = f‚ü¶i‚üß'‚ü¶j‚üß' ‚â´ (shiftComm Y i j).hom := by\n  rw [shiftComm', ‚Üê shiftComm_symm, Iso.symm_hom, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.shiftComm_hom_comp_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : CategoryTheory.HasShift C A\nX Y : C\nf : Quiver.Hom X Y\ni j : A\nZ : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C i).obj ((CategoryTheory.shiftFunctor C j).obj Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.shiftComm X i j).hom (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C i).map ((CategoryTheory.shiftFunctor C j).map f)) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C j).map ((CategoryTheory.shiftFunctor C i).map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.shiftComm Y i j).hom h))","decl":"@[reassoc]\ntheorem shiftComm_hom_comp (i j : A) :\n    (shiftComm X i j).hom ‚â´ f‚ü¶j‚üß'‚ü¶i‚üß' = f‚ü¶i‚üß'‚ü¶j‚üß' ‚â´ (shiftComm Y i j).hom := by\n  rw [shiftComm', ‚Üê shiftComm_symm, Iso.symm_hom, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.shiftFunctorZero_hom_app_shift","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : CategoryTheory.HasShift C A\nX : C\nn : A\n‚ä¢ Eq ((CategoryTheory.shiftFunctorZero C A).hom.app ((CategoryTheory.shiftFunctor C n).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorComm C n 0).hom.app X) ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorZero C A).hom.app X)))","decl":"lemma shiftFunctorZero_hom_app_shift (n : A) :\n    (shiftFunctorZero C A).hom.app (X‚ü¶n‚üß) =\n    (shiftFunctorComm C n 0).hom.app X ‚â´ ((shiftFunctorZero C A).hom.app X)‚ü¶n‚üß' := by\n  rw [‚Üê shiftFunctorAdd'_zero_add_inv_app n X, shiftFunctorComm_eq C n 0 n (add_zero n)]\n  dsimp\n  rw [Category.assoc, Iso.hom_inv_id_app, Category.comp_id, shiftFunctorAdd'_add_zero_inv_app]\n\n"}
{"name":"CategoryTheory.shiftFunctorZero_inv_app_shift","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : CategoryTheory.HasShift C A\nX : C\nn : A\n‚ä¢ Eq ((CategoryTheory.shiftFunctorZero C A).inv.app ((CategoryTheory.shiftFunctor C n).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n).map ((CategoryTheory.shiftFunctorZero C A).inv.app X)) ((CategoryTheory.shiftFunctorComm C n 0).inv.app X))","decl":"lemma shiftFunctorZero_inv_app_shift (n : A) :\n    (shiftFunctorZero C A).inv.app (X‚ü¶n‚üß) =\n  ((shiftFunctorZero C A).inv.app X)‚ü¶n‚üß' ‚â´ (shiftFunctorComm C n 0).inv.app X := by\n  rw [‚Üê cancel_mono ((shiftFunctorZero C A).hom.app (X‚ü¶n‚üß)), Category.assoc, Iso.inv_hom_id_app,\n    shiftFunctorZero_hom_app_shift, Iso.inv_hom_id_app_assoc, ‚Üê Functor.map_comp,\n    Iso.inv_hom_id_app]\n  dsimp\n  rw [Functor.map_id]\n\n"}
{"name":"CategoryTheory.shiftFunctorComm_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : CategoryTheory.HasShift C A\nX : C\na : A\n‚ä¢ Eq ((CategoryTheory.shiftFunctorComm C a 0).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero C A).hom.app ((CategoryTheory.shiftFunctor C a).obj X)) ((CategoryTheory.shiftFunctor C a).map ((CategoryTheory.shiftFunctorZero C A).inv.app X)))","decl":"lemma shiftFunctorComm_zero_hom_app (a : A) :\n    (shiftFunctorComm C a 0).hom.app X =\n      (shiftFunctorZero C A).hom.app (X‚ü¶a‚üß) ‚â´ ((shiftFunctorZero C A).inv.app X)‚ü¶a‚üß' := by\n  simp only [shiftFunctorZero_hom_app_shift, Category.assoc, ‚Üê Functor.map_comp,\n    Iso.hom_inv_id_app, Functor.map_id, Functor.comp_obj, Category.comp_id]\n\n"}
{"name":"CategoryTheory.shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : CategoryTheory.HasShift C A\nm‚ÇÅ m‚ÇÇ m‚ÇÉ : A\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorComm C m‚ÇÅ (HAdd.hAdd m‚ÇÇ m‚ÇÉ)).hom.app X) ((CategoryTheory.shiftFunctor C m‚ÇÅ).map ((CategoryTheory.shiftFunctorAdd C m‚ÇÇ m‚ÇÉ).hom.app X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C m‚ÇÇ m‚ÇÉ).hom.app ((CategoryTheory.shiftFunctor C m‚ÇÅ).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C m‚ÇÉ).map ((CategoryTheory.shiftFunctorComm C m‚ÇÅ m‚ÇÇ).hom.app X)) ((CategoryTheory.shiftFunctorComm C m‚ÇÅ m‚ÇÉ).hom.app ((CategoryTheory.shiftFunctor C m‚ÇÇ).obj X))))","decl":"@[reassoc]\nlemma shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C) :\n    (shiftFunctorComm C m‚ÇÅ (m‚ÇÇ + m‚ÇÉ)).hom.app X ‚â´\n    ((shiftFunctorAdd C m‚ÇÇ m‚ÇÉ).hom.app X)‚ü¶m‚ÇÅ‚üß' =\n  (shiftFunctorAdd C m‚ÇÇ m‚ÇÉ).hom.app (X‚ü¶m‚ÇÅ‚üß) ‚â´\n    ((shiftFunctorComm C m‚ÇÅ m‚ÇÇ).hom.app X)‚ü¶m‚ÇÉ‚üß' ‚â´\n    (shiftFunctorComm C m‚ÇÅ m‚ÇÉ).hom.app (X‚ü¶m‚ÇÇ‚üß) := by\n  rw [‚Üê cancel_mono ((shiftFunctorComm C m‚ÇÅ m‚ÇÉ).inv.app (X‚ü¶m‚ÇÇ‚üß)),\n    ‚Üê cancel_mono (((shiftFunctorComm C m‚ÇÅ m‚ÇÇ).inv.app X)‚ü¶m‚ÇÉ‚üß')]\n  simp only [Category.assoc, Iso.hom_inv_id_app]\n  dsimp\n  simp only [Category.id_comp, ‚Üê Functor.map_comp, Iso.hom_inv_id_app]\n  dsimp\n  simp only [Functor.map_id, Category.comp_id,\n    shiftFunctorComm_eq C _ _ _ rfl, ‚Üê shiftFunctorAdd'_eq_shiftFunctorAdd]\n  dsimp\n  simp only [Category.assoc, Iso.hom_inv_id_app_assoc, Iso.inv_hom_id_app_assoc,\n    ‚Üê Functor.map_comp,\n    shiftFunctorAdd'_assoc_hom_app_assoc m‚ÇÇ m‚ÇÉ m‚ÇÅ (m‚ÇÇ + m‚ÇÉ) (m‚ÇÅ + m‚ÇÉ) (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)) rfl\n      (add_comm m‚ÇÉ m‚ÇÅ) (add_comm _ m‚ÇÅ) X,\n    ‚Üê shiftFunctorAdd'_assoc_hom_app_assoc m‚ÇÇ m‚ÇÅ m‚ÇÉ (m‚ÇÅ + m‚ÇÇ) (m‚ÇÅ + m‚ÇÉ)\n      (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)) (add_comm _ _) rfl (by rw [add_comm m‚ÇÇ m‚ÇÅ, add_assoc]) X,\n    shiftFunctorAdd'_assoc_hom_app m‚ÇÅ m‚ÇÇ m‚ÇÉ\n      (m‚ÇÅ + m‚ÇÇ) (m‚ÇÇ + m‚ÇÉ) (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)) rfl rfl (add_assoc _ _ _) X]\n\n"}
{"name":"CategoryTheory.shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : AddCommMonoid A\ninst‚úù : CategoryTheory.HasShift C A\nm‚ÇÅ m‚ÇÇ m‚ÇÉ : A\nX Z : C\nh : Quiver.Hom ((CategoryTheory.shiftFunctor C m‚ÇÅ).obj ((CategoryTheory.shiftFunctor C m‚ÇÉ).obj ((CategoryTheory.shiftFunctor C m‚ÇÇ).obj X))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorComm C m‚ÇÅ (HAdd.hAdd m‚ÇÇ m‚ÇÉ)).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C m‚ÇÅ).map ((CategoryTheory.shiftFunctorAdd C m‚ÇÇ m‚ÇÉ).hom.app X)) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd C m‚ÇÇ m‚ÇÉ).hom.app ((CategoryTheory.shiftFunctor C m‚ÇÅ).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C m‚ÇÉ).map ((CategoryTheory.shiftFunctorComm C m‚ÇÅ m‚ÇÇ).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorComm C m‚ÇÅ m‚ÇÉ).hom.app ((CategoryTheory.shiftFunctor C m‚ÇÇ).obj X)) h)))","decl":"@[reassoc]\nlemma shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app (m‚ÇÅ m‚ÇÇ m‚ÇÉ : A) (X : C) :\n    (shiftFunctorComm C m‚ÇÅ (m‚ÇÇ + m‚ÇÉ)).hom.app X ‚â´\n    ((shiftFunctorAdd C m‚ÇÇ m‚ÇÉ).hom.app X)‚ü¶m‚ÇÅ‚üß' =\n  (shiftFunctorAdd C m‚ÇÇ m‚ÇÉ).hom.app (X‚ü¶m‚ÇÅ‚üß) ‚â´\n    ((shiftFunctorComm C m‚ÇÅ m‚ÇÇ).hom.app X)‚ü¶m‚ÇÉ‚üß' ‚â´\n    (shiftFunctorComm C m‚ÇÅ m‚ÇÉ).hom.app (X‚ü¶m‚ÇÇ‚üß) := by\n  rw [‚Üê cancel_mono ((shiftFunctorComm C m‚ÇÅ m‚ÇÉ).inv.app (X‚ü¶m‚ÇÇ‚üß)),\n    ‚Üê cancel_mono (((shiftFunctorComm C m‚ÇÅ m‚ÇÇ).inv.app X)‚ü¶m‚ÇÉ‚üß')]\n  simp only [Category.assoc, Iso.hom_inv_id_app]\n  dsimp\n  simp only [Category.id_comp, ‚Üê Functor.map_comp, Iso.hom_inv_id_app]\n  dsimp\n  simp only [Functor.map_id, Category.comp_id,\n    shiftFunctorComm_eq C _ _ _ rfl, ‚Üê shiftFunctorAdd'_eq_shiftFunctorAdd]\n  dsimp\n  simp only [Category.assoc, Iso.hom_inv_id_app_assoc, Iso.inv_hom_id_app_assoc,\n    ‚Üê Functor.map_comp,\n    shiftFunctorAdd'_assoc_hom_app_assoc m‚ÇÇ m‚ÇÉ m‚ÇÅ (m‚ÇÇ + m‚ÇÉ) (m‚ÇÅ + m‚ÇÉ) (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)) rfl\n      (add_comm m‚ÇÉ m‚ÇÅ) (add_comm _ m‚ÇÅ) X,\n    ‚Üê shiftFunctorAdd'_assoc_hom_app_assoc m‚ÇÇ m‚ÇÅ m‚ÇÉ (m‚ÇÅ + m‚ÇÇ) (m‚ÇÅ + m‚ÇÉ)\n      (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)) (add_comm _ _) rfl (by rw [add_comm m‚ÇÇ m‚ÇÅ, add_assoc]) X,\n    shiftFunctorAdd'_assoc_hom_app m‚ÇÅ m‚ÇÇ m‚ÇÉ\n      (m‚ÇÅ + m‚ÇÇ) (m‚ÇÇ + m‚ÇÉ) (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)) rfl rfl (add_assoc _ _ _) X]\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.hasShift.map_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\ns : A ‚Üí CategoryTheory.Functor C C\ni : (i : A) ‚Üí CategoryTheory.Iso ((s i).comp F) (F.comp (CategoryTheory.shiftFunctor D i))\nX : C\n‚ä¢ Eq (F.map ((CategoryTheory.Functor.FullyFaithful.hasShift.zero hF s i).hom.app X)) (CategoryTheory.CategoryStruct.comp ((i 0).hom.app X) ((CategoryTheory.shiftFunctorZero D A).hom.app (F.obj X)))","decl":"@[simp]\nlemma map_zero_hom_app (X : C) :\n    F.map ((zero hF s i).hom.app X) =\n      (i 0).hom.app X ‚â´ (shiftFunctorZero D A).hom.app (F.obj X) := by\n  simp [zero]\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.hasShift.map_zero_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\ns : A ‚Üí CategoryTheory.Functor C C\ni : (i : A) ‚Üí CategoryTheory.Iso ((s i).comp F) (F.comp (CategoryTheory.shiftFunctor D i))\nX : C\n‚ä¢ Eq (F.map ((CategoryTheory.Functor.FullyFaithful.hasShift.zero hF s i).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero D A).inv.app (F.obj X)) ((i 0).inv.app X))","decl":"@[simp]\nlemma map_zero_inv_app (X : C) :\n    F.map ((zero hF s i).inv.app X) =\n      (shiftFunctorZero D A).inv.app (F.obj X) ‚â´ (i 0).inv.app X := by\n  simp [zero]\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.hasShift.map_add_hom_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\ns : A ‚Üí CategoryTheory.Functor C C\ni : (i : A) ‚Üí CategoryTheory.Iso ((s i).comp F) (F.comp (CategoryTheory.shiftFunctor D i))\na b : A\nX : C\n‚ä¢ Eq (F.map ((CategoryTheory.Functor.FullyFaithful.hasShift.add hF s i a b).hom.app X)) (CategoryTheory.CategoryStruct.comp ((i (HAdd.hAdd a b)).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd D a b).hom.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((i a).inv.app X)) ((i b).inv.app ((s a).obj X)))))","decl":"@[simp]\nlemma map_add_hom_app (a b : A) (X : C) :\n    F.map ((add hF s i a b).hom.app X) =\n      (i (a + b)).hom.app X ‚â´ (shiftFunctorAdd D a b).hom.app (F.obj X) ‚â´\n        ((i a).inv.app X)‚ü¶b‚üß' ‚â´ (i b).inv.app ((s a).obj X) := by\n  dsimp [add]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.hasShift.map_add_inv_app","module":"Mathlib.CategoryTheory.Shift.Basic","initialProofState":"C : Type u\nA : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : AddMonoid A\ninst‚úù : CategoryTheory.HasShift D A\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\ns : A ‚Üí CategoryTheory.Functor C C\ni : (i : A) ‚Üí CategoryTheory.Iso ((s i).comp F) (F.comp (CategoryTheory.shiftFunctor D i))\na b : A\nX : C\n‚ä¢ Eq (F.map ((CategoryTheory.Functor.FullyFaithful.hasShift.add hF s i a b).inv.app X)) (CategoryTheory.CategoryStruct.comp ((i b).hom.app ((s a).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((i a).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd D a b).inv.app (F.obj X)) ((i (HAdd.hAdd a b)).inv.app X))))","decl":"@[simp]\nlemma map_add_inv_app (a b : A) (X : C) :\n    F.map ((add hF s i a b).inv.app X) =\n      (i b).hom.app ((s a).obj X) ‚â´ ((i a).hom.app X)‚ü¶b‚üß' ‚â´\n        (shiftFunctorAdd D a b).inv.app (F.obj X) ‚â´ (i (a + b)).inv.app X := by\n  dsimp [add]\n  simp\n\n"}
