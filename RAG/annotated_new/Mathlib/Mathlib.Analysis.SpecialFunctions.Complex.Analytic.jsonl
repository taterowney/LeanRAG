{"name":"analyticAt_clog","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"z : Complex\nm : Membership.mem Complex.slitPlane z\n‚ä¢ AnalyticAt Complex Complex.log z","decl":"/-- `log` is analytic away from nonpositive reals -/\n@[fun_prop]\ntheorem analyticAt_clog (m : z ‚àà slitPlane) : AnalyticAt ‚ÑÇ log z := by\n  rw [analyticAt_iff_eventually_differentiableAt]\n  filter_upwards [isOpen_slitPlane.eventually_mem m]\n  intro z m\n  exact differentiableAt_id.clog m\n\n"}
{"name":"AnalyticAt.clog","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"E : Type\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : E ‚Üí Complex\nx : E\nfa : AnalyticAt Complex f x\nm : Membership.mem Complex.slitPlane (f x)\n‚ä¢ AnalyticAt Complex (fun z => Complex.log (f z)) x","decl":"/-- `log` is analytic away from nonpositive reals -/\n@[fun_prop]\ntheorem AnalyticAt.clog (fa : AnalyticAt ‚ÑÇ f x) (m : f x ‚àà slitPlane) :\n    AnalyticAt ‚ÑÇ (fun z ‚Ü¶ log (f z)) x :=\n  (analyticAt_clog m).comp fa\n\n"}
{"name":"AnalyticWithinAt.clog","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"E : Type\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : E ‚Üí Complex\nx : E\ns : Set E\nfa : AnalyticWithinAt Complex f s x\nm : Membership.mem Complex.slitPlane (f x)\n‚ä¢ AnalyticWithinAt Complex (fun z => Complex.log (f z)) s x","decl":"theorem AnalyticWithinAt.clog (fa : AnalyticWithinAt ‚ÑÇ f s x) (m : f x ‚àà slitPlane) :\n    AnalyticWithinAt ‚ÑÇ (fun z ‚Ü¶ log (f z)) s x :=\n  (analyticAt_clog m).comp_analyticWithinAt fa\n\n"}
{"name":"AnalyticOnNhd.clog","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"E : Type\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : E ‚Üí Complex\ns : Set E\nfs : AnalyticOnNhd Complex f s\nm : ‚àÄ (z : E), Membership.mem s z ‚Üí Membership.mem Complex.slitPlane (f z)\n‚ä¢ AnalyticOnNhd Complex (fun z => Complex.log (f z)) s","decl":"/-- `log` is analytic away from nonpositive reals -/\ntheorem AnalyticOnNhd.clog (fs : AnalyticOnNhd ‚ÑÇ f s) (m : ‚àÄ z ‚àà s, f z ‚àà slitPlane) :\n    AnalyticOnNhd ‚ÑÇ (fun z ‚Ü¶ log (f z)) s :=\n  fun z n ‚Ü¶ (analyticAt_clog (m z n)).comp (fs z n)\n\n"}
{"name":"AnalyticOn.clog","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"E : Type\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : E ‚Üí Complex\ns : Set E\nfs : AnalyticOn Complex f s\nm : ‚àÄ (z : E), Membership.mem s z ‚Üí Membership.mem Complex.slitPlane (f z)\n‚ä¢ AnalyticOn Complex (fun z => Complex.log (f z)) s","decl":"theorem AnalyticOn.clog (fs : AnalyticOn ‚ÑÇ f s) (m : ‚àÄ z ‚àà s, f z ‚àà slitPlane) :\n    AnalyticOn ‚ÑÇ (fun z ‚Ü¶ log (f z)) s :=\n  fun z n ‚Ü¶ (analyticAt_clog (m z n)).analyticWithinAt.comp (fs z n) m\n\n"}
{"name":"AnalyticWithinAt.cpow","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"E : Type\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf g : E ‚Üí Complex\nx : E\ns : Set E\nfa : AnalyticWithinAt Complex f s x\nga : AnalyticWithinAt Complex g s x\nm : Membership.mem Complex.slitPlane (f x)\n‚ä¢ AnalyticWithinAt Complex (fun z => HPow.hPow (f z) (g z)) s x","decl":"/-- `f z ^ g z` is analytic if `f z` is not a nonpositive real -/\ntheorem AnalyticWithinAt.cpow (fa : AnalyticWithinAt ‚ÑÇ f s x) (ga : AnalyticWithinAt ‚ÑÇ g s x)\n    (m : f x ‚àà slitPlane) : AnalyticWithinAt ‚ÑÇ (fun z ‚Ü¶ f z ^ g z) s x := by\n  have e : (fun z ‚Ü¶ f z ^ g z) =·∂†[ùìù[insert x s] x] fun z ‚Ü¶ exp (log (f z) * g z) := by\n    filter_upwards [(fa.continuousWithinAt_insert.eventually_ne (slitPlane_ne_zero m))]\n    intro z fz\n    simp only [fz, cpow_def, if_false]\n  apply AnalyticWithinAt.congr_of_eventuallyEq_insert _ e\n  exact ((fa.clog m).mul ga).cexp\n\n"}
{"name":"AnalyticAt.cpow","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"E : Type\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf g : E ‚Üí Complex\nx : E\nfa : AnalyticAt Complex f x\nga : AnalyticAt Complex g x\nm : Membership.mem Complex.slitPlane (f x)\n‚ä¢ AnalyticAt Complex (fun z => HPow.hPow (f z) (g z)) x","decl":"/-- `f z ^ g z` is analytic if `f z` is not a nonpositive real -/\n@[fun_prop]\ntheorem AnalyticAt.cpow (fa : AnalyticAt ‚ÑÇ f x) (ga : AnalyticAt ‚ÑÇ g x)\n    (m : f x ‚àà slitPlane) : AnalyticAt ‚ÑÇ (fun z ‚Ü¶ f z ^ g z) x := by\n  rw [‚Üê analyticWithinAt_univ] at fa ga ‚ä¢\n  exact fa.cpow ga m\n\n"}
{"name":"AnalyticOn.cpow","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"E : Type\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf g : E ‚Üí Complex\ns : Set E\nfs : AnalyticOn Complex f s\ngs : AnalyticOn Complex g s\nm : ‚àÄ (z : E), Membership.mem s z ‚Üí Membership.mem Complex.slitPlane (f z)\n‚ä¢ AnalyticOn Complex (fun z => HPow.hPow (f z) (g z)) s","decl":"/-- `f z ^ g z` is analytic if `f z` avoids nonpositive reals -/\ntheorem AnalyticOn.cpow (fs : AnalyticOn ‚ÑÇ f s) (gs : AnalyticOn ‚ÑÇ g s)\n    (m : ‚àÄ z ‚àà s, f z ‚àà slitPlane) : AnalyticOn ‚ÑÇ (fun z ‚Ü¶ f z ^ g z) s :=\n  fun z n ‚Ü¶ (fs z n).cpow (gs z n) (m z n)\n\n"}
{"name":"AnalyticOnNhd.cpow","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"E : Type\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf g : E ‚Üí Complex\ns : Set E\nfs : AnalyticOnNhd Complex f s\ngs : AnalyticOnNhd Complex g s\nm : ‚àÄ (z : E), Membership.mem s z ‚Üí Membership.mem Complex.slitPlane (f z)\n‚ä¢ AnalyticOnNhd Complex (fun z => HPow.hPow (f z) (g z)) s","decl":"/-- `f z ^ g z` is analytic if `f z` avoids nonpositive reals -/\ntheorem AnalyticOnNhd.cpow (fs : AnalyticOnNhd ‚ÑÇ f s) (gs : AnalyticOnNhd ‚ÑÇ g s)\n    (m : ‚àÄ z ‚àà s, f z ‚àà slitPlane) : AnalyticOnNhd ‚ÑÇ (fun z ‚Ü¶ f z ^ g z) s :=\n  fun z n ‚Ü¶ (fs z n).cpow (gs z n) (m z n)\n\n"}
{"name":"AnalyticAt.re_ofReal","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"f : Complex ‚Üí Complex\nx : Real\nhf : AnalyticAt Complex f ‚Üëx\n‚ä¢ AnalyticAt Real (fun x => (f ‚Üëx).re) x","decl":"lemma AnalyticAt.re_ofReal (hf : AnalyticAt ‚ÑÇ f x) :\n    AnalyticAt ‚Ñù (fun x : ‚Ñù ‚Ü¶ (f x).re) x :=\n  (Complex.reCLM.analyticAt _).comp (hf.restrictScalars.comp (Complex.ofRealCLM.analyticAt _))\n\n"}
{"name":"AnalyticAt.im_ofReal","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"f : Complex ‚Üí Complex\nx : Real\nhf : AnalyticAt Complex f ‚Üëx\n‚ä¢ AnalyticAt Real (fun x => (f ‚Üëx).im) x","decl":"lemma AnalyticAt.im_ofReal (hf : AnalyticAt ‚ÑÇ f x) :\n    AnalyticAt ‚Ñù (fun x : ‚Ñù ‚Ü¶ (f x).im) x :=\n  (Complex.imCLM.analyticAt _).comp (hf.restrictScalars.comp (Complex.ofRealCLM.analyticAt _))\n\n"}
{"name":"AnalyticWithinAt.re_ofReal","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"f : Complex ‚Üí Complex\ns : Set Real\nx : Real\nhf : AnalyticWithinAt Complex f (Set.image Complex.ofReal s) ‚Üëx\n‚ä¢ AnalyticWithinAt Real (fun x => (f ‚Üëx).re) s x","decl":"lemma AnalyticWithinAt.re_ofReal (hf : AnalyticWithinAt ‚ÑÇ f (ofReal '' s) x) :\n    AnalyticWithinAt ‚Ñù (fun x : ‚Ñù ‚Ü¶ (f x).re) s x :=\n  ((Complex.reCLM.analyticWithinAt _ _).comp hf.restrictScalars (mapsTo_image f _)).comp\n    (Complex.ofRealCLM.analyticWithinAt _ _) (mapsTo_image ofReal s)\n\n"}
{"name":"AnalyticWithinAt.im_ofReal","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"f : Complex ‚Üí Complex\ns : Set Real\nx : Real\nhf : AnalyticWithinAt Complex f (Set.image Complex.ofReal s) ‚Üëx\n‚ä¢ AnalyticWithinAt Real (fun x => (f ‚Üëx).im) s x","decl":"lemma AnalyticWithinAt.im_ofReal (hf : AnalyticWithinAt ‚ÑÇ f (ofReal '' s) x) :\n    AnalyticWithinAt ‚Ñù (fun x : ‚Ñù ‚Ü¶ (f x).im) s x :=\n  ((Complex.imCLM.analyticWithinAt _ _).comp hf.restrictScalars (mapsTo_image f _)).comp\n    (Complex.ofRealCLM.analyticWithinAt _ _) (mapsTo_image ofReal s)\n\n"}
{"name":"AnalyticOn.re_ofReal","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"f : Complex ‚Üí Complex\ns : Set Real\nhf : AnalyticOn Complex f (Set.image Complex.ofReal s)\n‚ä¢ AnalyticOn Real (fun x => (f ‚Üëx).re) s","decl":"lemma AnalyticOn.re_ofReal (hf : AnalyticOn ‚ÑÇ f (ofReal '' s)) :\n    AnalyticOn ‚Ñù (fun x : ‚Ñù ‚Ü¶ (f x).re) s :=\n  ((Complex.reCLM.analyticOn _).comp hf.restrictScalars (mapsTo_image f _)).comp\n    (Complex.ofRealCLM.analyticOn _) (mapsTo_image ofReal s)\n\n"}
{"name":"AnalyticOn.im_ofReal","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"f : Complex ‚Üí Complex\ns : Set Real\nhf : AnalyticOn Complex f (Set.image Complex.ofReal s)\n‚ä¢ AnalyticOn Real (fun x => (f ‚Üëx).im) s","decl":"lemma AnalyticOn.im_ofReal (hf : AnalyticOn ‚ÑÇ f (ofReal '' s)) :\n    AnalyticOn ‚Ñù (fun x : ‚Ñù ‚Ü¶ (f x).im) s :=\n  ((Complex.imCLM.analyticOn _).comp hf.restrictScalars (mapsTo_image f _)).comp\n    (Complex.ofRealCLM.analyticOn _) (mapsTo_image ofReal s)\n\n"}
{"name":"AnalyticOnNhd.re_ofReal","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"f : Complex ‚Üí Complex\ns : Set Real\nhf : AnalyticOnNhd Complex f (Set.image Complex.ofReal s)\n‚ä¢ AnalyticOnNhd Real (fun x => (f ‚Üëx).re) s","decl":"lemma AnalyticOnNhd.re_ofReal (hf : AnalyticOnNhd ‚ÑÇ f (ofReal '' s)) :\n    AnalyticOnNhd ‚Ñù (fun x : ‚Ñù ‚Ü¶ (f x).re) s :=\n  ((Complex.reCLM.analyticOnNhd _).comp hf.restrictScalars (mapsTo_image f _)).comp\n    (Complex.ofRealCLM.analyticOnNhd _) (mapsTo_image ofReal s)\n\n"}
{"name":"AnalyticOnNhd.im_ofReal","module":"Mathlib.Analysis.SpecialFunctions.Complex.Analytic","initialProofState":"f : Complex ‚Üí Complex\ns : Set Real\nhf : AnalyticOnNhd Complex f (Set.image Complex.ofReal s)\n‚ä¢ AnalyticOnNhd Real (fun x => (f ‚Üëx).im) s","decl":"lemma AnalyticOnNhd.im_ofReal (hf : AnalyticOnNhd ‚ÑÇ f (ofReal '' s)) :\n    AnalyticOnNhd ‚Ñù (fun x : ‚Ñù ‚Ü¶ (f x).im) s :=\n  ((Complex.imCLM.analyticOnNhd _).comp hf.restrictScalars (mapsTo_image f _)).comp\n    (Complex.ofRealCLM.analyticOnNhd _) (mapsTo_image ofReal s)\n\n"}
