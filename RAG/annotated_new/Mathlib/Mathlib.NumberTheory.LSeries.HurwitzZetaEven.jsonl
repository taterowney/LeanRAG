{"name":"HurwitzZeta.evenKernel_def","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a x : Real\n⊢ Eq (↑(HurwitzZeta.evenKernel (↑a) x)) (HMul.hMul (Complex.exp (HMul.hMul (HMul.hMul (Neg.neg ↑Real.pi) (HPow.hPow (↑a) 2)) ↑x)) (jacobiTheta₂ (HMul.hMul (HMul.hMul (↑a) Complex.I) ↑x) (HMul.hMul Complex.I ↑x)))","decl":"lemma evenKernel_def (a x : ℝ) :\n    ↑(evenKernel ↑a x) = cexp (-π * a ^ 2 * x) * jacobiTheta₂ (a * I * x) (I * x) := by\n  simp [evenKernel, re_eq_add_conj, jacobiTheta₂_conj, ← mul_two,\n    mul_div_cancel_right₀ _ (two_ne_zero' ℂ)]\n\n"}
{"name":"HurwitzZeta.evenKernel_undef","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\nx : Real\nhx : LE.le x 0\n⊢ Eq (HurwitzZeta.evenKernel a x) 0","decl":"/-- For `x ≤ 0` the defining sum diverges, so the kernel is 0. -/\nlemma evenKernel_undef (a : UnitAddCircle) {x : ℝ} (hx : x ≤ 0) : evenKernel a x = 0 := by\n  induction a using QuotientAddGroup.induction_on with\n  | H a' => simp [← ofReal_inj, evenKernel_def, jacobiTheta₂_undef _ (by simpa : (I * ↑x).im ≤ 0)]\n\n"}
{"name":"HurwitzZeta.cosKernel_def","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a x : Real\n⊢ Eq (↑(HurwitzZeta.cosKernel (↑a) x)) (jacobiTheta₂ (↑a) (HMul.hMul Complex.I ↑x))","decl":"lemma cosKernel_def (a x : ℝ) : ↑(cosKernel ↑a x) = jacobiTheta₂ a (I * x) := by\n  simp [cosKernel, re_eq_add_conj, jacobiTheta₂_conj, ← mul_two,\n    mul_div_cancel_right₀ _ (two_ne_zero' ℂ)]\n\n"}
{"name":"HurwitzZeta.cosKernel_undef","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\nx : Real\nhx : LE.le x 0\n⊢ Eq (HurwitzZeta.cosKernel a x) 0","decl":"lemma cosKernel_undef (a : UnitAddCircle) {x : ℝ} (hx : x ≤ 0) : cosKernel a x = 0 := by\n  induction a using QuotientAddGroup.induction_on with\n  | H => simp [← ofReal_inj, cosKernel_def, jacobiTheta₂_undef _ (by simpa : (I * ↑x).im ≤ 0)]\n\n"}
{"name":"HurwitzZeta.evenKernel_eq_cosKernel_of_zero","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"⊢ Eq (HurwitzZeta.evenKernel 0) (HurwitzZeta.cosKernel 0)","decl":"/-- For `a = 0`, both kernels agree. -/\nlemma evenKernel_eq_cosKernel_of_zero : evenKernel 0 = cosKernel 0 := by\n  ext1 x\n  simp [← QuotientAddGroup.mk_zero, ← ofReal_inj, evenKernel_def, cosKernel_def]\n\n"}
{"name":"HurwitzZeta.evenKernel_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\nx : Real\n⊢ Eq (HurwitzZeta.evenKernel (Neg.neg a) x) (HurwitzZeta.evenKernel a x)","decl":"@[simp]\nlemma evenKernel_neg (a : UnitAddCircle) (x : ℝ) : evenKernel (-a) x = evenKernel a x := by\n  induction a using QuotientAddGroup.induction_on with\n  | H => simp [← QuotientAddGroup.mk_neg, ← ofReal_inj, evenKernel_def, jacobiTheta₂_neg_left]\n\n"}
{"name":"HurwitzZeta.cosKernel_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\nx : Real\n⊢ Eq (HurwitzZeta.cosKernel (Neg.neg a) x) (HurwitzZeta.cosKernel a x)","decl":"@[simp]\nlemma cosKernel_neg (a : UnitAddCircle) (x : ℝ) : cosKernel (-a) x = cosKernel a x := by\n  induction a using QuotientAddGroup.induction_on with\n  | H => simp [← QuotientAddGroup.mk_neg, ← ofReal_inj, cosKernel_def]\n\n"}
{"name":"HurwitzZeta.continuousOn_evenKernel","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ ContinuousOn (HurwitzZeta.evenKernel a) (Set.Ioi 0)","decl":"lemma continuousOn_evenKernel (a : UnitAddCircle) : ContinuousOn (evenKernel a) (Ioi 0) := by\n  induction' a using QuotientAddGroup.induction_on with a'\n  apply continuous_re.comp_continuousOn (f := fun x ↦ (evenKernel a' x : ℂ))\n  simp only [evenKernel_def]\n  refine continuousOn_of_forall_continuousAt (fun x hx ↦ .mul (by fun_prop) ?_)\n  exact (continuousAt_jacobiTheta₂ (a' * I * x) <| by simpa).comp\n    (f := fun u : ℝ ↦ (a' * I * u, I * u)) (by fun_prop)\n\n"}
{"name":"HurwitzZeta.continuousOn_cosKernel","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ ContinuousOn (HurwitzZeta.cosKernel a) (Set.Ioi 0)","decl":"lemma continuousOn_cosKernel (a : UnitAddCircle) : ContinuousOn (cosKernel a) (Ioi 0) := by\n  induction' a using QuotientAddGroup.induction_on with a'\n  apply continuous_re.comp_continuousOn (f := fun x ↦ (cosKernel a' x : ℂ))\n  simp only [cosKernel_def]\n  refine continuousOn_of_forall_continuousAt (fun x hx ↦ ?_)\n  exact (continuousAt_jacobiTheta₂ a' <| by simpa).comp\n    (f := fun u : ℝ ↦ ((a' : ℂ), I * u)) (by fun_prop)\n\n"}
{"name":"HurwitzZeta.evenKernel_functional_equation","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\nx : Real\n⊢ Eq (HurwitzZeta.evenKernel a x) (HMul.hMul (HDiv.hDiv 1 (HPow.hPow x (1 / 2))) (HurwitzZeta.cosKernel a (HDiv.hDiv 1 x)))","decl":"lemma evenKernel_functional_equation (a : UnitAddCircle) (x : ℝ) :\n    evenKernel a x = 1 / x ^ (1 / 2 : ℝ) * cosKernel a (1 / x) := by\n  rcases le_or_lt x 0 with hx | hx\n  · rw [evenKernel_undef _ hx, cosKernel_undef, mul_zero]\n    exact div_nonpos_of_nonneg_of_nonpos zero_le_one hx\n  induction' a using QuotientAddGroup.induction_on with a\n  rw [← ofReal_inj, ofReal_mul, evenKernel_def, cosKernel_def, jacobiTheta₂_functional_equation]\n  have h1 : I * ↑(1 / x) = -1 / (I * x) := by\n    push_cast\n    rw [← div_div, mul_one_div, div_I, neg_one_mul, neg_neg]\n  have hx' : I * x ≠ 0 := mul_ne_zero I_ne_zero (ofReal_ne_zero.mpr hx.ne')\n  have h2 : a * I * x / (I * x) = a := by\n    rw [div_eq_iff hx']\n    ring\n  have h3 : 1 / (-I * (I * x)) ^ (1 / 2 : ℂ) = 1 / ↑(x ^ (1 / 2 : ℝ)) := by\n    rw [neg_mul, ← mul_assoc, I_mul_I, neg_one_mul, neg_neg,ofReal_cpow hx.le, ofReal_div,\n      ofReal_one, ofReal_ofNat]\n  have h4 : -π * I * (a * I * x) ^ 2 / (I * x) = - (-π * a ^ 2 * x) := by\n    rw [mul_pow, mul_pow, I_sq, div_eq_iff hx']\n    ring\n  rw [h1, h2, h3, h4, ← mul_assoc, mul_comm (cexp _), mul_assoc _ (cexp _) (cexp _),\n    ← Complex.exp_add, neg_add_cancel, Complex.exp_zero, mul_one, ofReal_div, ofReal_one]\n\n"}
{"name":"HurwitzZeta.hasSum_int_evenKernel","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a t : Real\nht : LT.lt 0 t\n⊢ HasSum (fun n => Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow (HAdd.hAdd (↑n) a) 2)) t)) (HurwitzZeta.evenKernel (↑a) t)","decl":"lemma hasSum_int_evenKernel (a : ℝ) {t : ℝ} (ht : 0 < t) :\n    HasSum (fun n : ℤ ↦ rexp (-π * (n + a) ^ 2 * t)) (evenKernel a t) := by\n  rw [← hasSum_ofReal, evenKernel_def]\n  have (n : ℤ) : cexp (-(π * (n + a) ^ 2 * t)) = cexp (-(π * a ^ 2 * t)) *\n      jacobiTheta₂_term n (a * I * t) (I * t) := by\n    rw [jacobiTheta₂_term, ← Complex.exp_add]\n    ring_nf\n    simp\n  simpa [this] using (hasSum_jacobiTheta₂_term _ (by simpa)).mul_left _\n\n"}
{"name":"HurwitzZeta.hasSum_int_cosKernel","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a t : Real\nht : LT.lt 0 t\n⊢ HasSum (fun n => HMul.hMul (Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑a) ↑n)) ↑(Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow (↑n) 2)) t))) ↑(HurwitzZeta.cosKernel (↑a) t)","decl":"lemma hasSum_int_cosKernel (a : ℝ) {t : ℝ} (ht : 0 < t) :\n    HasSum (fun n : ℤ ↦ cexp (2 * π * I * a * n) * rexp (-π * n ^ 2 * t)) ↑(cosKernel a t) := by\n  rw [cosKernel_def a t]\n  have (n : ℤ) : cexp (2 * π * I * a * n) * cexp (-(π * n ^ 2 * t)) =\n      jacobiTheta₂_term n a (I * ↑t) := by\n    rw [jacobiTheta₂_term, ← Complex.exp_add]\n    ring_nf\n    simp [sub_eq_add_neg]\n  simpa [this] using hasSum_jacobiTheta₂_term _ (by simpa)\n\n"}
{"name":"HurwitzZeta.hasSum_int_evenKernel₀","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a t : Real\nht : LT.lt 0 t\n⊢ HasSum (fun n => ite (Eq (HAdd.hAdd (↑n) a) 0) 0 (Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow (HAdd.hAdd (↑n) a) 2)) t))) (HSub.hSub (HurwitzZeta.evenKernel (↑a) t) (ite (Eq (↑a) 0) 1 0))","decl":"/-- Modified version of `hasSum_int_evenKernel` omitting the constant term at `∞`. -/\nlemma hasSum_int_evenKernel₀ (a : ℝ) {t : ℝ} (ht : 0 < t) :\n    HasSum (fun n : ℤ ↦ if n + a = 0 then 0 else rexp (-π * (n + a) ^ 2 * t))\n    (evenKernel a t - if (a : UnitAddCircle) = 0 then 1 else 0) := by\n  haveI := Classical.propDecidable -- speed up instance search for `if / then / else`\n  simp_rw [AddCircle.coe_eq_zero_iff, zsmul_one]\n  split_ifs with h\n  · obtain ⟨k, rfl⟩ := h\n    simpa [← Int.cast_add, add_eq_zero_iff_eq_neg]\n      using hasSum_ite_sub_hasSum (hasSum_int_evenKernel (k : ℝ) ht) (-k)\n  · suffices ∀ (n : ℤ), n + a ≠ 0 by simpa [this] using hasSum_int_evenKernel a ht\n    contrapose! h\n    let ⟨n, hn⟩ := h\n    exact ⟨-n, by simpa [neg_eq_iff_add_eq_zero]⟩\n\n"}
{"name":"HurwitzZeta.hasSum_int_cosKernel₀","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a t : Real\nht : LT.lt 0 t\n⊢ HasSum (fun n => ite (Eq n 0) 0 (HMul.hMul (Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑a) ↑n)) ↑(Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow (↑n) 2)) t)))) (HSub.hSub (↑(HurwitzZeta.cosKernel (↑a) t)) 1)","decl":"lemma hasSum_int_cosKernel₀ (a : ℝ) {t : ℝ} (ht : 0 < t) :\n    HasSum (fun n : ℤ ↦ if n = 0 then 0 else cexp (2 * π * I * a * n) * rexp (-π * n ^ 2 * t))\n    (↑(cosKernel a t) - 1) := by\n  simpa using hasSum_ite_sub_hasSum (hasSum_int_cosKernel a ht) 0\n\n"}
{"name":"HurwitzZeta.hasSum_nat_cosKernel₀","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a t : Real\nht : LT.lt 0 t\n⊢ HasSum (fun n => HMul.hMul (HMul.hMul 2 (Real.cos (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) a) (HAdd.hAdd (↑n) 1)))) (Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow (HAdd.hAdd (↑n) 1) 2)) t))) (HSub.hSub (HurwitzZeta.cosKernel (↑a) t) 1)","decl":"lemma hasSum_nat_cosKernel₀ (a : ℝ) {t : ℝ} (ht : 0 < t) :\n    HasSum (fun n : ℕ ↦ 2 * Real.cos (2 * π * a * (n + 1)) * rexp (-π * (n + 1) ^ 2 * t))\n    (cosKernel a t - 1) := by\n  rw [← hasSum_ofReal, ofReal_sub, ofReal_one]\n  have := (hasSum_int_cosKernel a ht).nat_add_neg\n  rw [← hasSum_nat_add_iff' 1] at this\n  simp_rw [Finset.sum_range_one, Nat.cast_zero, neg_zero, Int.cast_zero, zero_pow two_ne_zero,\n    mul_zero, zero_mul, Complex.exp_zero, Real.exp_zero, ofReal_one, mul_one, Int.cast_neg,\n    Int.cast_natCast, neg_sq, ← add_mul, add_sub_assoc, ← sub_sub, sub_self, zero_sub,\n    ← sub_eq_add_neg, mul_neg] at this\n  refine this.congr_fun fun n ↦ ?_\n  push_cast\n  rw [Complex.cos, mul_div_cancel₀ _ two_ne_zero]\n  congr 3 <;> ring\n\n"}
{"name":"HurwitzZeta.isBigO_atTop_evenKernel_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ Exists fun p => And (LT.lt 0 p) (Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (HurwitzZeta.evenKernel a x) (ite (Eq a 0) 1 0)) fun x => Real.exp (HMul.hMul (Neg.neg p) x))","decl":"/-- The function `evenKernel a - L` has exponential decay at `+∞`, where `L = 1` if\n`a = 0` and `L = 0` otherwise. -/\nlemma isBigO_atTop_evenKernel_sub (a : UnitAddCircle) : ∃ p : ℝ, 0 < p ∧\n    (evenKernel a · - (if a = 0 then 1 else 0)) =O[atTop] (rexp <| -p * ·) := by\n  induction' a using QuotientAddGroup.induction_on with b\n  obtain ⟨p, hp, hp'⟩ := HurwitzKernelBounds.isBigO_atTop_F_int_zero_sub b\n  refine ⟨p, hp, (EventuallyEq.isBigO ?_).trans hp'⟩\n  filter_upwards [eventually_gt_atTop 0] with t h\n  simp [← (hasSum_int_evenKernel b h).tsum_eq, HurwitzKernelBounds.F_int, HurwitzKernelBounds.f_int]\n\n"}
{"name":"HurwitzZeta.isBigO_atTop_cosKernel_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ Exists fun p => And (LT.lt 0 p) (Asymptotics.IsBigO Filter.atTop (fun x => HSub.hSub (HurwitzZeta.cosKernel a x) 1) fun x => Real.exp (HMul.hMul (Neg.neg p) x))","decl":"/-- The function `cosKernel a - 1` has exponential decay at `+∞`, for any `a`. -/\nlemma isBigO_atTop_cosKernel_sub (a : UnitAddCircle) :\n    ∃ p, 0 < p ∧ IsBigO atTop (cosKernel a · - 1) (fun x ↦ Real.exp (-p * x)) := by\n  induction' a using QuotientAddGroup.induction_on with a\n  obtain ⟨p, hp, hp'⟩ := HurwitzKernelBounds.isBigO_atTop_F_nat_zero_sub zero_le_one\n  refine ⟨p, hp, (Eventually.isBigO ?_).trans (hp'.const_mul_left 2)⟩\n  filter_upwards [eventually_gt_atTop 0] with t ht\n  simp only [eq_false_intro one_ne_zero, if_false, sub_zero,\n    ← (hasSum_nat_cosKernel₀ a ht).tsum_eq, HurwitzKernelBounds.F_nat]\n  apply tsum_of_norm_bounded ((HurwitzKernelBounds.summable_f_nat 0 1 ht).hasSum.mul_left 2)\n  intro n\n  rw [norm_mul, norm_mul, norm_two, mul_assoc, mul_le_mul_iff_of_pos_left two_pos,\n    norm_of_nonneg (exp_pos _).le, HurwitzKernelBounds.f_nat, pow_zero, one_mul, Real.norm_eq_abs]\n  exact mul_le_of_le_one_left (exp_pos _).le (abs_cos_le_one _)\n\n"}
{"name":"HurwitzZeta.hurwitzEvenFEPair_zero_symm","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"⊢ Eq (HurwitzZeta.hurwitzEvenFEPair 0).symm (HurwitzZeta.hurwitzEvenFEPair 0)","decl":"@[simp]\nlemma hurwitzEvenFEPair_zero_symm :\n    (hurwitzEvenFEPair 0).symm = hurwitzEvenFEPair 0 := by\n  unfold hurwitzEvenFEPair WeakFEPair.symm\n  congr 1 <;> simp [evenKernel_eq_cosKernel_of_zero]\n\n"}
{"name":"HurwitzZeta.hurwitzEvenFEPair_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ Eq (HurwitzZeta.hurwitzEvenFEPair (Neg.neg a)) (HurwitzZeta.hurwitzEvenFEPair a)","decl":"@[simp]\nlemma hurwitzEvenFEPair_neg (a : UnitAddCircle) : hurwitzEvenFEPair (-a) = hurwitzEvenFEPair a := by\n  unfold hurwitzEvenFEPair\n  congr 1 <;> simp [Function.comp_def]\n\n"}
{"name":"HurwitzZeta.completedHurwitzZetaEven_eq","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedHurwitzZetaEven a s) (HSub.hSub (HSub.hSub (HurwitzZeta.completedHurwitzZetaEven₀ a s) (HDiv.hDiv (ite (Eq a 0) 1 0) s)) (HDiv.hDiv 1 (HSub.hSub 1 s)))","decl":"lemma completedHurwitzZetaEven_eq (a : UnitAddCircle) (s : ℂ) :\n    completedHurwitzZetaEven a s =\n    completedHurwitzZetaEven₀ a s - (if a = 0 then 1 else 0) / s - 1 / (1 - s) := by\n  rw [completedHurwitzZetaEven, WeakFEPair.Λ, sub_div, sub_div]\n  congr 1\n  · change completedHurwitzZetaEven₀ a s - (1 / (s / 2)) • (if a = 0 then 1 else 0) / 2 =\n      completedHurwitzZetaEven₀ a s - (if a = 0 then 1 else 0) / s\n    rw [smul_eq_mul, mul_comm, mul_div_assoc, div_div, div_mul_cancel₀ _ two_ne_zero, mul_one_div]\n  · change (1 / (↑(1 / 2 : ℝ) - s / 2)) • 1 / 2 = 1 / (1 - s)\n    push_cast\n    rw [smul_eq_mul, mul_one, ← sub_div, div_div, div_mul_cancel₀ _ two_ne_zero]\n\n"}
{"name":"HurwitzZeta.completedCosZeta_eq","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedCosZeta a s) (HSub.hSub (HSub.hSub (HurwitzZeta.completedCosZeta₀ a s) (HDiv.hDiv 1 s)) (HDiv.hDiv (ite (Eq a 0) 1 0) (HSub.hSub 1 s)))","decl":"lemma completedCosZeta_eq (a : UnitAddCircle) (s : ℂ) :\n    completedCosZeta a s =\n    completedCosZeta₀ a s - 1 / s - (if a = 0 then 1 else 0) / (1 - s) := by\n  rw [completedCosZeta, WeakFEPair.Λ, sub_div, sub_div]\n  congr 1\n  · rw [completedCosZeta₀, WeakFEPair.symm, hurwitzEvenFEPair, smul_eq_mul, mul_one, div_div,\n      div_mul_cancel₀ _ (two_ne_zero' ℂ)]\n  · simp_rw [WeakFEPair.symm, hurwitzEvenFEPair, push_cast, inv_one, smul_eq_mul,\n      mul_comm _ (if _ then _ else _), mul_div_assoc, div_div, ← sub_div,\n      div_mul_cancel₀ _ (two_ne_zero' ℂ), mul_one_div]\n\n"}
{"name":"HurwitzZeta.completedHurwitzZetaEven_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedHurwitzZetaEven (Neg.neg a) s) (HurwitzZeta.completedHurwitzZetaEven a s)","decl":"@[simp]\nlemma completedHurwitzZetaEven_neg (a : UnitAddCircle) (s : ℂ) :\n    completedHurwitzZetaEven (-a) s = completedHurwitzZetaEven a s := by\n  simp [completedHurwitzZetaEven]\n\n"}
{"name":"HurwitzZeta.completedHurwitzZetaEven₀_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedHurwitzZetaEven₀ (Neg.neg a) s) (HurwitzZeta.completedHurwitzZetaEven₀ a s)","decl":"@[simp]\nlemma completedHurwitzZetaEven₀_neg (a : UnitAddCircle) (s : ℂ) :\n    completedHurwitzZetaEven₀ (-a) s = completedHurwitzZetaEven₀ a s := by\n  simp [completedHurwitzZetaEven₀]\n\n"}
{"name":"HurwitzZeta.completedCosZeta_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedCosZeta (Neg.neg a) s) (HurwitzZeta.completedCosZeta a s)","decl":"@[simp]\nlemma completedCosZeta_neg (a : UnitAddCircle) (s : ℂ) :\n    completedCosZeta (-a) s = completedCosZeta a s := by\n  simp [completedCosZeta]\n\n"}
{"name":"HurwitzZeta.completedCosZeta₀_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedCosZeta₀ (Neg.neg a) s) (HurwitzZeta.completedCosZeta₀ a s)","decl":"@[simp]\nlemma completedCosZeta₀_neg (a : UnitAddCircle) (s : ℂ) :\n    completedCosZeta₀ (-a) s = completedCosZeta₀ a s := by\n  simp [completedCosZeta₀]\n\n"}
{"name":"HurwitzZeta.completedHurwitzZetaEven_one_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedHurwitzZetaEven a (HSub.hSub 1 s)) (HurwitzZeta.completedCosZeta a s)","decl":"/-- Functional equation for the even Hurwitz zeta function. -/\nlemma completedHurwitzZetaEven_one_sub (a : UnitAddCircle) (s : ℂ) :\n    completedHurwitzZetaEven a (1 - s) = completedCosZeta a s := by\n  rw [completedHurwitzZetaEven, completedCosZeta, sub_div,\n    (by norm_num : (1 / 2 : ℂ) = ↑(1 / 2 : ℝ)),\n    (by rfl : (1 / 2 : ℝ) = (hurwitzEvenFEPair a).k),\n    (hurwitzEvenFEPair a).functional_equation (s / 2),\n    (by rfl : (hurwitzEvenFEPair a).ε = 1),\n    one_smul]\n\n"}
{"name":"HurwitzZeta.completedHurwitzZetaEven₀_one_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedHurwitzZetaEven₀ a (HSub.hSub 1 s)) (HurwitzZeta.completedCosZeta₀ a s)","decl":"/-- Functional equation for the even Hurwitz zeta function with poles removed. -/\nlemma completedHurwitzZetaEven₀_one_sub (a : UnitAddCircle) (s : ℂ) :\n    completedHurwitzZetaEven₀ a (1 - s) = completedCosZeta₀ a s := by\n  rw [completedHurwitzZetaEven₀, completedCosZeta₀, sub_div,\n    (by norm_num : (1 / 2 : ℂ) = ↑(1 / 2 : ℝ)),\n    (by rfl : (1 / 2 : ℝ) = (hurwitzEvenFEPair a).k),\n    (hurwitzEvenFEPair a).functional_equation₀ (s / 2),\n    (by rfl : (hurwitzEvenFEPair a).ε = 1),\n    one_smul]\n\n"}
{"name":"HurwitzZeta.completedCosZeta_one_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedCosZeta a (HSub.hSub 1 s)) (HurwitzZeta.completedHurwitzZetaEven a s)","decl":"/-- Functional equation for the even Hurwitz zeta function (alternative form). -/\nlemma completedCosZeta_one_sub (a : UnitAddCircle) (s : ℂ) :\n    completedCosZeta a (1 - s) = completedHurwitzZetaEven a s := by\n  rw [← completedHurwitzZetaEven_one_sub, sub_sub_cancel]\n\n"}
{"name":"HurwitzZeta.completedCosZeta₀_one_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedCosZeta₀ a (HSub.hSub 1 s)) (HurwitzZeta.completedHurwitzZetaEven₀ a s)","decl":"/-- Functional equation for the even Hurwitz zeta function with poles removed (alternative form). -/\nlemma completedCosZeta₀_one_sub (a : UnitAddCircle) (s : ℂ) :\n    completedCosZeta₀ a (1 - s) = completedHurwitzZetaEven₀ a s := by\n  rw [← completedHurwitzZetaEven₀_one_sub, sub_sub_cancel]\n\n"}
{"name":"HurwitzZeta.differentiableAt_completedHurwitzZetaEven","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\nhs : Or (Ne s 0) (Ne a 0)\nhs' : Ne s 1\n⊢ DifferentiableAt Complex (HurwitzZeta.completedHurwitzZetaEven a) s","decl":"/--\nThe even Hurwitz completed zeta is differentiable away from `s = 0` and `s = 1` (and also at\n`s = 0` if `a ≠ 0`)\n-/\nlemma differentiableAt_completedHurwitzZetaEven\n    (a : UnitAddCircle) {s : ℂ} (hs : s ≠ 0 ∨ a ≠ 0) (hs' : s ≠ 1) :\n    DifferentiableAt ℂ (completedHurwitzZetaEven a) s := by\n  refine (((hurwitzEvenFEPair a).differentiableAt_Λ ?_ (Or.inl ?_)).comp s\n      (differentiableAt_id.div_const _)).div_const _\n  · rcases hs with h | h <;>\n    simp [hurwitzEvenFEPair, h]\n  · change s / 2 ≠ ↑(1 / 2 : ℝ)\n    rw [ofReal_div, ofReal_one, ofReal_ofNat]\n    exact hs' ∘ (div_left_inj' two_ne_zero).mp\n\n"}
{"name":"HurwitzZeta.differentiable_completedHurwitzZetaEven₀","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ Differentiable Complex (HurwitzZeta.completedHurwitzZetaEven₀ a)","decl":"lemma differentiable_completedHurwitzZetaEven₀ (a : UnitAddCircle) :\n    Differentiable ℂ (completedHurwitzZetaEven₀ a) :=\n  ((hurwitzEvenFEPair a).differentiable_Λ₀.comp (differentiable_id.div_const _)).div_const _\n\n"}
{"name":"HurwitzZeta.differentiableAt_one_completedHurwitzZetaEven_sub_completedHurwitzZetaEven","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a b : UnitAddCircle\n⊢ DifferentiableAt Complex (fun s => HSub.hSub (HurwitzZeta.completedHurwitzZetaEven a s) (HurwitzZeta.completedHurwitzZetaEven b s)) 1","decl":"/-- The difference of two completed even Hurwitz zeta functions is differentiable at `s = 1`. -/\nlemma differentiableAt_one_completedHurwitzZetaEven_sub_completedHurwitzZetaEven\n    (a b : UnitAddCircle) :\n    DifferentiableAt ℂ (fun s ↦ completedHurwitzZetaEven a s - completedHurwitzZetaEven b s) 1 := by\n  have (s) : completedHurwitzZetaEven a s - completedHurwitzZetaEven b s =\n      completedHurwitzZetaEven₀ a s - completedHurwitzZetaEven₀ b s -\n      ((if a = 0 then 1 else 0) - (if b = 0 then 1 else 0)) / s := by\n    simp_rw [completedHurwitzZetaEven_eq, sub_div]\n    abel\n  rw [funext this]\n  refine .sub ?_ <| (differentiable_const _ _).div (differentiable_id _) one_ne_zero\n  apply DifferentiableAt.sub <;> apply differentiable_completedHurwitzZetaEven₀\n\n"}
{"name":"HurwitzZeta.differentiableAt_completedCosZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\nhs : Ne s 0\nhs' : Or (Ne s 1) (Ne a 0)\n⊢ DifferentiableAt Complex (HurwitzZeta.completedCosZeta a) s","decl":"lemma differentiableAt_completedCosZeta\n    (a : UnitAddCircle) {s : ℂ} (hs : s ≠ 0) (hs' : s ≠ 1 ∨ a ≠ 0) :\n    DifferentiableAt ℂ (completedCosZeta a) s := by\n  refine (((hurwitzEvenFEPair a).symm.differentiableAt_Λ (Or.inl ?_) ?_).comp s\n      (differentiableAt_id.div_const _)).div_const _\n  · exact div_ne_zero_iff.mpr ⟨hs, two_ne_zero⟩\n  · change s / 2 ≠ ↑(1 / 2 : ℝ) ∨ (if a = 0 then 1 else 0) = 0\n    refine Or.imp (fun h ↦ ?_) (fun ha ↦ ?_) hs'\n    · simpa [push_cast] using h ∘ (div_left_inj' two_ne_zero).mp\n    · simpa\n\n"}
{"name":"HurwitzZeta.differentiable_completedCosZeta₀","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ Differentiable Complex (HurwitzZeta.completedCosZeta₀ a)","decl":"lemma differentiable_completedCosZeta₀ (a : UnitAddCircle) :\n    Differentiable ℂ (completedCosZeta₀ a) :=\n  ((hurwitzEvenFEPair a).symm.differentiable_Λ₀.comp (differentiable_id.div_const _)).div_const _\n\n"}
{"name":"HurwitzZeta.completedHurwitzZetaEven_residue_one","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ Filter.Tendsto (fun s => HMul.hMul (HSub.hSub s 1) (HurwitzZeta.completedHurwitzZetaEven a s)) (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhds 1)","decl":"/-- The residue of `completedHurwitzZetaEven a s` at `s = 1` is equal to `1`. -/\nlemma completedHurwitzZetaEven_residue_one (a : UnitAddCircle) :\n    Tendsto (fun s ↦ (s - 1) * completedHurwitzZetaEven a s) (𝓝[≠] 1) (𝓝 1) := by\n  have h1 : Tendsto (fun s : ℂ ↦ (s - ↑(1  / 2 : ℝ)) * _) (𝓝[≠] ↑(1  / 2 : ℝ))\n    (𝓝 ((1 : ℂ) * (1 : ℂ))) := (hurwitzEvenFEPair a).Λ_residue_k\n  simp only [push_cast, one_mul] at h1\n  refine (h1.comp <| tendsto_div_two_punctured_nhds 1).congr (fun s ↦ ?_)\n  rw [completedHurwitzZetaEven, Function.comp_apply, ← sub_div, div_mul_eq_mul_div, mul_div_assoc]\n\n"}
{"name":"HurwitzZeta.completedHurwitzZetaEven_residue_zero","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ Filter.Tendsto (fun s => HMul.hMul s (HurwitzZeta.completedHurwitzZetaEven a s)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhds (ite (Eq a 0) (-1) 0))","decl":"/-- The residue of `completedHurwitzZetaEven a s` at `s = 0` is equal to `-1` if `a = 0`, and `0`\notherwise. -/\nlemma completedHurwitzZetaEven_residue_zero (a : UnitAddCircle) :\n    Tendsto (fun s ↦ s * completedHurwitzZetaEven a s) (𝓝[≠] 0) (𝓝 (if a = 0 then -1 else 0)) := by\n  have h1 : Tendsto (fun s : ℂ ↦ s * _) (𝓝[≠] 0)\n    (𝓝 (-(if a = 0 then 1 else 0))) := (hurwitzEvenFEPair a).Λ_residue_zero\n  have : -(if a = 0 then (1 : ℂ) else 0) = (if a = 0 then -1 else 0) := by { split_ifs <;> simp }\n  simp only [this, push_cast, one_mul] at h1\n  refine (h1.comp <| zero_div (2 : ℂ) ▸ (tendsto_div_two_punctured_nhds 0)).congr (fun s ↦ ?_)\n  simp [completedHurwitzZetaEven, div_mul_eq_mul_div, mul_div_assoc]\n\n"}
{"name":"HurwitzZeta.completedCosZeta_residue_zero","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ Filter.Tendsto (fun s => HMul.hMul s (HurwitzZeta.completedCosZeta a s)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhds (-1))","decl":"lemma completedCosZeta_residue_zero (a : UnitAddCircle) :\n    Tendsto (fun s ↦ s * completedCosZeta a s) (𝓝[≠] 0) (𝓝 (-1)) := by\n  have h1 : Tendsto (fun s : ℂ ↦ s * _) (𝓝[≠] 0)\n    (𝓝 (-1)) := (hurwitzEvenFEPair a).symm.Λ_residue_zero\n  refine (h1.comp <| zero_div (2 : ℂ) ▸ (tendsto_div_two_punctured_nhds 0)).congr (fun s ↦ ?_)\n  simp [completedCosZeta, div_mul_eq_mul_div, mul_div_assoc]\n\n"}
{"name":"HurwitzZeta.hasSum_int_completedCosZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (HDiv.hDiv (HMul.hMul s.Gammaℝ (Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑a) ↑n))) (HPow.hPow (↑(abs n)) s)) 2) (HurwitzZeta.completedCosZeta (↑a) s)","decl":"/-- Formula for `completedCosZeta` as a Dirichlet series in the convergence range\n(first version, with sum over `ℤ`). -/\nlemma hasSum_int_completedCosZeta (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℤ ↦ Gammaℝ s * cexp (2 * π * I * a * n) / (↑|n| : ℂ) ^ s / 2)\n    (completedCosZeta a s) := by\n  let c (n : ℤ) : ℂ := cexp (2 * π * I * a * n) / 2\n  have hF t (ht : 0 < t) : HasSum (fun n : ℤ ↦ if n = 0 then 0 else c n * rexp (-π * n ^ 2 * t))\n      ((cosKernel a t - 1) / 2) := by\n    refine ((hasSum_int_cosKernel₀ a ht).div_const 2).congr_fun fun n ↦ ?_\n    split_ifs <;> simp [c, div_mul_eq_mul_div]\n  simp only [← Int.cast_eq_zero (α := ℝ)] at hF\n  rw [show completedCosZeta a s = mellin (fun t ↦ (cosKernel a t - 1 : ℂ) / 2) (s / 2) by\n    rw [mellin_div_const, completedCosZeta]\n    congr 1\n    refine ((hurwitzEvenFEPair a).symm.hasMellin (?_ : 1 / 2 < (s / 2).re)).2.symm\n    rwa [div_ofNat_re, div_lt_div_iff_of_pos_right two_pos]]\n  refine (hasSum_mellin_pi_mul_sq (zero_lt_one.trans hs) hF ?_).congr_fun fun n ↦ ?_\n  · apply (((summable_one_div_int_add_rpow 0 s.re).mpr hs).div_const 2).of_norm_bounded\n    intro i\n    simp only [c, (by { push_cast; ring } : 2 * π * I * a * i = ↑(2 * π * a * i) * I), norm_div,\n      RCLike.norm_ofNat, norm_norm, Complex.norm_exp_ofReal_mul_I, add_zero, norm_one,\n      norm_of_nonneg (by positivity : 0 ≤ |(i : ℝ)| ^ s.re), div_right_comm, le_rfl]\n  · simp [c, ← Int.cast_abs, div_right_comm, mul_div_assoc]\n\n"}
{"name":"HurwitzZeta.hasSum_nat_completedCosZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => ite (Eq n 0) 0 (HDiv.hDiv (HMul.hMul s.Gammaℝ ↑(Real.cos (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) a) ↑n))) (HPow.hPow (↑n) s))) (HurwitzZeta.completedCosZeta (↑a) s)","decl":"/-- Formula for `completedCosZeta` as a Dirichlet series in the convergence range\n(second version, with sum over `ℕ`). -/\nlemma hasSum_nat_completedCosZeta (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℕ ↦ if n = 0 then 0 else Gammaℝ s * Real.cos (2 * π * a * n) / (n : ℂ) ^ s)\n    (completedCosZeta a s) := by\n  have aux : ((|0| : ℤ) : ℂ) ^ s = 0 := by\n    rw [abs_zero, Int.cast_zero, zero_cpow (ne_zero_of_one_lt_re hs)]\n  have hint := (hasSum_int_completedCosZeta a hs).nat_add_neg\n  rw [aux, div_zero, zero_div, add_zero] at hint\n  refine hint.congr_fun fun n ↦ ?_\n  split_ifs with h\n  · simp only [h, Nat.cast_zero, aux, div_zero, zero_div, neg_zero, zero_add]\n  · simp only [ofReal_cos, ofReal_mul, ofReal_ofNat, ofReal_natCast, Complex.cos,\n      show 2 * π * a * n * I = 2 * π * I * a * n by ring, neg_mul, mul_div_assoc,\n      div_right_comm _ (2 : ℂ), Int.cast_natCast, Nat.abs_cast, Int.cast_neg, mul_neg, abs_neg, ←\n      mul_add, ← add_div]\n\n"}
{"name":"HurwitzZeta.hasSum_int_completedHurwitzZetaEven","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (HDiv.hDiv s.Gammaℝ (HPow.hPow (↑(abs (HAdd.hAdd (↑n) a))) s)) 2) (HurwitzZeta.completedHurwitzZetaEven (↑a) s)","decl":"/-- Formula for `completedHurwitzZetaEven` as a Dirichlet series in the convergence range. -/\nlemma hasSum_int_completedHurwitzZetaEven (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℤ ↦ Gammaℝ s / (↑|n + a| : ℂ) ^ s / 2) (completedHurwitzZetaEven a s) := by\n  have hF (t : ℝ) (ht : 0 < t) : HasSum (fun n : ℤ ↦ if n + a = 0 then 0\n      else (1 / 2 : ℂ) * rexp (-π * (n + a) ^ 2 * t))\n      ((evenKernel a t - (if (a : UnitAddCircle) = 0 then 1 else 0 : ℝ)) / 2) := by\n    refine (ofReal_sub .. ▸ (hasSum_ofReal.mpr (hasSum_int_evenKernel₀ a ht)).div_const\n      2).congr_fun fun n ↦ ?_\n    split_ifs\n    · rw [ofReal_zero, zero_div]\n    · rw [mul_comm, mul_one_div]\n  rw [show completedHurwitzZetaEven a s = mellin (fun t ↦ ((evenKernel (↑a) t : ℂ) -\n        ↑(if (a : UnitAddCircle) = 0 then 1 else 0 : ℝ)) / 2) (s / 2) by\n    simp_rw [mellin_div_const, apply_ite ofReal, ofReal_one, ofReal_zero]\n    refine congr_arg (· / 2) ((hurwitzEvenFEPair a).hasMellin (?_ : 1 / 2 < (s / 2).re)).2.symm\n    rwa [div_ofNat_re, div_lt_div_iff_of_pos_right two_pos]]\n  refine (hasSum_mellin_pi_mul_sq (zero_lt_one.trans hs) hF ?_).congr_fun fun n ↦ ?_\n  · simp_rw [← mul_one_div ‖_‖]\n    apply Summable.mul_left\n    rwa [summable_one_div_int_add_rpow]\n  · rw [mul_one_div, div_right_comm]\n\n"}
{"name":"HurwitzZeta.differentiableAt_update_of_residue","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"Λ : Complex → Complex\nhf : ∀ (s : Complex), Ne s 0 → Ne s 1 → DifferentiableAt Complex Λ s\nL : Complex\nh_lim : Filter.Tendsto (fun s => HMul.hMul s (Λ s)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (nhds L)\ns : Complex\nhs' : Ne s 1\n⊢ DifferentiableAt Complex (Function.update (fun s => HDiv.hDiv (Λ s) s.Gammaℝ) 0 (HDiv.hDiv L 2)) s","decl":"/-- Technical lemma which will give us differentiability of Hurwitz zeta at `s = 0`. -/\nlemma differentiableAt_update_of_residue\n    {Λ : ℂ → ℂ} (hf : ∀ (s : ℂ) (_ : s ≠ 0) (_ : s ≠ 1), DifferentiableAt ℂ Λ s)\n    {L : ℂ} (h_lim : Tendsto (fun s ↦ s * Λ s) (𝓝[≠] 0) (𝓝 L)) (s : ℂ) (hs' : s ≠ 1) :\n    DifferentiableAt ℂ (Function.update (fun s ↦ Λ s / Gammaℝ s) 0 (L / 2)) s := by\n  have claim (t) (ht : t ≠ 0) (ht' : t ≠ 1) : DifferentiableAt ℂ (fun u : ℂ ↦ Λ u / Gammaℝ u) t :=\n    (hf t ht ht').mul differentiable_Gammaℝ_inv.differentiableAt\n  have claim2 : Tendsto (fun s : ℂ ↦ Λ s / Gammaℝ s) (𝓝[≠] 0) (𝓝 <| L / 2) := by\n    refine Tendsto.congr' ?_ (h_lim.div Gammaℝ_residue_zero two_ne_zero)\n    filter_upwards [self_mem_nhdsWithin] with s (hs : s ≠ 0)\n    rw [Pi.div_apply, ← div_div, mul_div_cancel_left₀ _ hs]\n  rcases ne_or_eq s 0 with hs | rfl\n  · -- Easy case : `s ≠ 0`\n    refine (claim s hs hs').congr_of_eventuallyEq ?_\n    filter_upwards [isOpen_compl_singleton.mem_nhds hs] with x hx\n    simp [Function.update_of_ne hx]\n  · -- Hard case : `s = 0`\n    simp_rw [← claim2.limUnder_eq]\n    have S_nhds : {(1 : ℂ)}ᶜ ∈ 𝓝 (0 : ℂ) := isOpen_compl_singleton.mem_nhds hs'\n    refine ((Complex.differentiableOn_update_limUnder_of_isLittleO S_nhds\n      (fun t ht ↦ (claim t ht.2 ht.1).differentiableWithinAt) ?_) 0 hs').differentiableAt S_nhds\n    simp only [Gammaℝ, zero_div, div_zero, Complex.Gamma_zero, mul_zero, cpow_zero, sub_zero]\n    -- Remains to show completed zeta is `o (s ^ (-1))` near 0.\n    refine (isBigO_const_of_tendsto claim2 <| one_ne_zero' ℂ).trans_isLittleO ?_\n    rw [isLittleO_iff_tendsto']\n    · exact Tendsto.congr (fun x ↦ by rw [← one_div, one_div_one_div]) nhdsWithin_le_nhds\n    · exact eventually_of_mem self_mem_nhdsWithin fun x hx hx' ↦ (hx <| inv_eq_zero.mp hx').elim\n\n"}
{"name":"HurwitzZeta.hurwitzZetaEven_def_of_ne_or_ne","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\nh : Or (Ne a 0) (Ne s 0)\n⊢ Eq (HurwitzZeta.hurwitzZetaEven a s) (HDiv.hDiv (HurwitzZeta.completedHurwitzZetaEven a s) s.Gammaℝ)","decl":"lemma hurwitzZetaEven_def_of_ne_or_ne {a : UnitAddCircle} {s : ℂ} (h : a ≠ 0 ∨ s ≠ 0) :\n    hurwitzZetaEven a s = completedHurwitzZetaEven a s / Gammaℝ s := by\n  rw [hurwitzZetaEven]\n  rcases ne_or_eq s 0 with h' | rfl\n  · rw [Function.update_of_ne h']\n  · simpa [Gammaℝ] using h\n\n"}
{"name":"HurwitzZeta.hurwitzZetaEven_apply_zero","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ Eq (HurwitzZeta.hurwitzZetaEven a 0) (ite (Eq a 0) (-1 / 2) 0)","decl":"lemma hurwitzZetaEven_apply_zero (a : UnitAddCircle) :\n    hurwitzZetaEven a 0 = if a = 0 then -1 / 2 else 0 :=\n  Function.update_self ..\n\n"}
{"name":"HurwitzZeta.hurwitzZetaEven_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.hurwitzZetaEven (Neg.neg a) s) (HurwitzZeta.hurwitzZetaEven a s)","decl":"lemma hurwitzZetaEven_neg (a : UnitAddCircle) (s : ℂ) :\n    hurwitzZetaEven (-a) s = hurwitzZetaEven a s := by\n  simp [hurwitzZetaEven]\n\n"}
{"name":"HurwitzZeta.hurwitzZetaEven_neg_two_mul_nat_add_one","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\nn : Nat\n⊢ Eq (HurwitzZeta.hurwitzZetaEven a (HMul.hMul (-2) (HAdd.hAdd (↑n) 1))) 0","decl":"/-- The trivial zeroes of the even Hurwitz zeta function. -/\ntheorem hurwitzZetaEven_neg_two_mul_nat_add_one (a : UnitAddCircle) (n : ℕ) :\n    hurwitzZetaEven a (-2 * (n + 1)) = 0 := by\n  have : (-2 : ℂ) * (n + 1) ≠ 0 :=\n    mul_ne_zero (neg_ne_zero.mpr two_ne_zero) (Nat.cast_add_one_ne_zero n)\n  rw [hurwitzZetaEven, Function.update_of_ne this, Gammaℝ_eq_zero_iff.mpr ⟨n + 1, by simp⟩,\n    div_zero]\n\n"}
{"name":"HurwitzZeta.differentiableAt_hurwitzZetaEven","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\nhs' : Ne s 1\n⊢ DifferentiableAt Complex (HurwitzZeta.hurwitzZetaEven a) s","decl":"/-- The Hurwitz zeta function is differentiable everywhere except at `s = 1`. This is true\neven in the delicate case `a = 0` and `s = 0` (where the completed zeta has a pole, but this is\ncancelled out by the Gamma factor). -/\nlemma differentiableAt_hurwitzZetaEven (a : UnitAddCircle) {s : ℂ} (hs' : s ≠ 1) :\n    DifferentiableAt ℂ (hurwitzZetaEven a) s := by\n  have := differentiableAt_update_of_residue\n    (fun t ht ht' ↦ differentiableAt_completedHurwitzZetaEven a (Or.inl ht) ht')\n    (completedHurwitzZetaEven_residue_zero a) s hs'\n  simp_rw [div_eq_mul_inv, ite_mul, zero_mul, ← div_eq_mul_inv] at this\n  exact this\n\n"}
{"name":"HurwitzZeta.hurwitzZetaEven_residue_one","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ Filter.Tendsto (fun s => HMul.hMul (HSub.hSub s 1) (HurwitzZeta.hurwitzZetaEven a s)) (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhds 1)","decl":"lemma hurwitzZetaEven_residue_one (a : UnitAddCircle) :\n    Tendsto (fun s ↦ (s - 1) * hurwitzZetaEven a s) (𝓝[≠] 1) (𝓝 1) := by\n  have : Tendsto (fun s ↦ (s - 1) * completedHurwitzZetaEven a s / Gammaℝ s) (𝓝[≠] 1) (𝓝 1) := by\n    simpa only [Gammaℝ_one, inv_one, mul_one] using (completedHurwitzZetaEven_residue_one a).mul\n      <| (differentiable_Gammaℝ_inv.continuous.tendsto _).mono_left nhdsWithin_le_nhds\n  refine this.congr' ?_\n  filter_upwards [eventually_ne_nhdsWithin one_ne_zero] with s hs\n  simp [hurwitzZetaEven_def_of_ne_or_ne (Or.inr hs), mul_div_assoc]\n\n"}
{"name":"HurwitzZeta.differentiableAt_hurwitzZetaEven_sub_one_div","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ DifferentiableAt Complex (fun s => HSub.hSub (HurwitzZeta.hurwitzZetaEven a s) (HDiv.hDiv (HDiv.hDiv 1 (HSub.hSub s 1)) s.Gammaℝ)) 1","decl":"lemma differentiableAt_hurwitzZetaEven_sub_one_div (a : UnitAddCircle) :\n    DifferentiableAt ℂ (fun s ↦ hurwitzZetaEven a s - 1 / (s - 1) / Gammaℝ s) 1 := by\n  suffices DifferentiableAt ℂ\n      (fun s ↦ completedHurwitzZetaEven a s / Gammaℝ s - 1 / (s - 1) / Gammaℝ s) 1 by\n    apply this.congr_of_eventuallyEq\n    filter_upwards [eventually_ne_nhds one_ne_zero] with x hx\n    rw [hurwitzZetaEven, Function.update_of_ne hx]\n  simp_rw [← sub_div, div_eq_mul_inv _ (Gammaℝ _)]\n  refine DifferentiableAt.mul ?_ differentiable_Gammaℝ_inv.differentiableAt\n  simp_rw [completedHurwitzZetaEven_eq, sub_sub, add_assoc]\n  conv => enter [2, s, 2]; rw [← neg_sub, div_neg, neg_add_cancel, add_zero]\n  exact (differentiable_completedHurwitzZetaEven₀ a _).sub\n    <| (differentiableAt_const _).div differentiableAt_id one_ne_zero\n\n"}
{"name":"HurwitzZeta.tendsto_hurwitzZetaEven_sub_one_div_nhds_one","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ Filter.Tendsto (fun s => HSub.hSub (HurwitzZeta.hurwitzZetaEven a s) (HDiv.hDiv (HDiv.hDiv 1 (HSub.hSub s 1)) s.Gammaℝ)) (nhds 1) (nhds (HurwitzZeta.hurwitzZetaEven a 1))","decl":"/-- Expression for `hurwitzZetaEven a 1` as a limit. (Mathematically `hurwitzZetaEven a 1` is\nundefined, but our construction assigns some value to it; this lemma is mostly of interest for\ndetermining what that value is). -/\nlemma tendsto_hurwitzZetaEven_sub_one_div_nhds_one (a : UnitAddCircle) :\n    Tendsto (fun s ↦ hurwitzZetaEven a s - 1 / (s - 1) / Gammaℝ s) (𝓝 1)\n    (𝓝 (hurwitzZetaEven a 1)) := by\n  simpa using (differentiableAt_hurwitzZetaEven_sub_one_div a).continuousAt.tendsto\n\n"}
{"name":"HurwitzZeta.differentiable_hurwitzZetaEven_sub_hurwitzZetaEven","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a b : UnitAddCircle\n⊢ Differentiable Complex fun s => HSub.hSub (HurwitzZeta.hurwitzZetaEven a s) (HurwitzZeta.hurwitzZetaEven b s)","decl":"lemma differentiable_hurwitzZetaEven_sub_hurwitzZetaEven (a b : UnitAddCircle) :\n    Differentiable ℂ (fun s ↦ hurwitzZetaEven a s - hurwitzZetaEven b s) := by\n  intro z\n  rcases ne_or_eq z 1 with hz | rfl\n  · exact (differentiableAt_hurwitzZetaEven a hz).sub (differentiableAt_hurwitzZetaEven b hz)\n  · convert (differentiableAt_hurwitzZetaEven_sub_one_div a).sub\n      (differentiableAt_hurwitzZetaEven_sub_one_div b) using 2 with s\n    abel\n\n"}
{"name":"HurwitzZeta.hasSum_int_hurwitzZetaEven","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (HDiv.hDiv 1 (HPow.hPow (↑(abs (HAdd.hAdd (↑n) a))) s)) 2) (HurwitzZeta.hurwitzZetaEven (↑a) s)","decl":"/--\nFormula for `hurwitzZetaEven` as a Dirichlet series in the convergence range, with sum over `ℤ`.\n-/\nlemma hasSum_int_hurwitzZetaEven (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℤ ↦ 1 / (↑|n + a| : ℂ) ^ s / 2) (hurwitzZetaEven a s) := by\n  rw [hurwitzZetaEven, Function.update_of_ne (ne_zero_of_one_lt_re hs)]\n  have := (hasSum_int_completedHurwitzZetaEven a hs).div_const (Gammaℝ s)\n  exact this.congr_fun fun n ↦ by simp only [div_right_comm _ _ (Gammaℝ _),\n    div_self (Gammaℝ_ne_zero_of_re_pos (zero_lt_one.trans hs))]\n\n"}
{"name":"HurwitzZeta.hasSum_nat_hurwitzZetaEven","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (HAdd.hAdd (HDiv.hDiv 1 (HPow.hPow (↑(abs (HAdd.hAdd (↑n) a))) s)) (HDiv.hDiv 1 (HPow.hPow (↑(abs (HSub.hSub (HAdd.hAdd (↑n) 1) a))) s))) 2) (HurwitzZeta.hurwitzZetaEven (↑a) s)","decl":"/-- Formula for `hurwitzZetaEven` as a Dirichlet series in the convergence range, with sum over `ℕ`\n(version with absolute values) -/\nlemma hasSum_nat_hurwitzZetaEven (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℕ ↦ (1 / (↑|n + a| : ℂ) ^ s + 1 / (↑|n + 1 - a| : ℂ) ^ s) / 2)\n    (hurwitzZetaEven a s) := by\n  refine (hasSum_int_hurwitzZetaEven a hs).nat_add_neg_add_one.congr_fun fun n ↦ ?_\n  simp [← abs_neg (n + 1 - a), -neg_sub, neg_sub', add_div]\n\n"}
{"name":"HurwitzZeta.hasSum_nat_hurwitzZetaEven_of_mem_Icc","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : Real\nha : Membership.mem (Set.Icc 0 1) a\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (HAdd.hAdd (HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd ↑n ↑a) s)) (HDiv.hDiv 1 (HPow.hPow (HSub.hSub (HAdd.hAdd (↑n) 1) ↑a) s))) 2) (HurwitzZeta.hurwitzZetaEven (↑a) s)","decl":"/-- Formula for `hurwitzZetaEven` as a Dirichlet series in the convergence range, with sum over `ℕ`\n(version without absolute values, assuming `a ∈ Icc 0 1`) -/\nlemma hasSum_nat_hurwitzZetaEven_of_mem_Icc {a : ℝ} (ha : a ∈ Icc 0 1) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℕ ↦ (1 / (n + a : ℂ) ^ s + 1 / (n + 1 - a : ℂ) ^ s) / 2)\n    (hurwitzZetaEven a s) := by\n  refine (hasSum_nat_hurwitzZetaEven a hs).congr_fun fun n ↦ ?_\n  congr 2 <;>\n  rw [_root_.abs_of_nonneg (by linarith [ha.1, ha.2])] <;>\n  simp\n\n"}
{"name":"HurwitzZeta.cosZeta_apply_zero","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\n⊢ Eq (HurwitzZeta.cosZeta a 0) (-1 / 2)","decl":"lemma cosZeta_apply_zero (a : UnitAddCircle) : cosZeta a 0 = -1 / 2 :=\n  Function.update_self ..\n\n"}
{"name":"HurwitzZeta.cosZeta_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.cosZeta (Neg.neg a) s) (HurwitzZeta.cosZeta a s)","decl":"lemma cosZeta_neg (a : UnitAddCircle) (s : ℂ) :\n    cosZeta (-a) s = cosZeta a s := by\n  simp [cosZeta]\n\n"}
{"name":"HurwitzZeta.cosZeta_neg_two_mul_nat_add_one","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\nn : Nat\n⊢ Eq (HurwitzZeta.cosZeta a (HMul.hMul (-2) (HAdd.hAdd (↑n) 1))) 0","decl":"/-- The trivial zeroes of the cosine zeta function. -/\ntheorem cosZeta_neg_two_mul_nat_add_one (a : UnitAddCircle) (n : ℕ) :\n    cosZeta a (-2 * (n + 1)) = 0 := by\n  have : (-2 : ℂ) * (n + 1) ≠ 0 :=\n    mul_ne_zero (neg_ne_zero.mpr two_ne_zero) (Nat.cast_add_one_ne_zero n)\n  rw [cosZeta, Function.update_of_ne this,\n    Gammaℝ_eq_zero_iff.mpr ⟨n + 1, by rw [neg_mul, Nat.cast_add_one]⟩, div_zero]\n\n"}
{"name":"HurwitzZeta.differentiableAt_cosZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\nhs' : Or (Ne s 1) (Ne a 0)\n⊢ DifferentiableAt Complex (HurwitzZeta.cosZeta a) s","decl":"/-- The cosine zeta function is differentiable everywhere, except at `s = 1` if `a = 0`. -/\nlemma differentiableAt_cosZeta (a : UnitAddCircle) {s : ℂ} (hs' : s ≠ 1 ∨ a ≠ 0) :\n    DifferentiableAt ℂ (cosZeta a) s := by\n  rcases ne_or_eq s 1 with hs' | rfl\n  · exact differentiableAt_update_of_residue (fun _ ht ht' ↦\n      differentiableAt_completedCosZeta a ht (Or.inl ht')) (completedCosZeta_residue_zero a) s hs'\n  · apply ((differentiableAt_completedCosZeta a one_ne_zero hs').mul\n      (differentiable_Gammaℝ_inv.differentiableAt)).congr_of_eventuallyEq\n    filter_upwards [isOpen_compl_singleton.mem_nhds one_ne_zero] with x hx\n    rw [cosZeta, Function.update_of_ne hx, div_eq_mul_inv]\n\n"}
{"name":"HurwitzZeta.differentiable_cosZeta_of_ne_zero","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\nha : Ne a 0\n⊢ Differentiable Complex (HurwitzZeta.cosZeta a)","decl":"/-- If `a ≠ 0` then the cosine zeta function is entire. -/\nlemma differentiable_cosZeta_of_ne_zero {a : UnitAddCircle} (ha : a ≠ 0) :\n    Differentiable ℂ (cosZeta a) :=\n  fun _ ↦ differentiableAt_cosZeta a (Or.inr ha)\n\n"}
{"name":"HurwitzZeta.hasSum_int_cosZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (HDiv.hDiv (Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑a) ↑n)) (HPow.hPow (↑(abs n)) s)) 2) (HurwitzZeta.cosZeta (↑a) s)","decl":"/-- Formula for `cosZeta` as a Dirichlet series in the convergence range, with sum over `ℤ`. -/\nlemma hasSum_int_cosZeta (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℤ ↦ cexp (2 * π * I * a * n) / ↑|n| ^ s / 2) (cosZeta a s) := by\n  rw [cosZeta, Function.update_of_ne (ne_zero_of_one_lt_re hs)]\n  refine ((hasSum_int_completedCosZeta a hs).div_const (Gammaℝ s)).congr_fun fun n ↦ ?_\n  rw [mul_div_assoc _ (cexp _), div_right_comm _ (2 : ℂ),\n    mul_div_cancel_left₀ _ (Gammaℝ_ne_zero_of_re_pos (zero_lt_one.trans hs))]\n\n"}
{"name":"HurwitzZeta.hasSum_nat_cosZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (↑(Real.cos (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) a) ↑n))) (HPow.hPow (↑n) s)) (HurwitzZeta.cosZeta (↑a) s)","decl":"/-- Formula for `cosZeta` as a Dirichlet series in the convergence range, with sum over `ℕ`. -/\nlemma hasSum_nat_cosZeta (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℕ ↦ Real.cos (2 * π * a * n) / (n : ℂ) ^ s) (cosZeta a s) := by\n  have := (hasSum_int_cosZeta a hs).nat_add_neg\n  simp_rw [abs_neg, Int.cast_neg, Nat.abs_cast, Int.cast_natCast, mul_neg, abs_zero, Int.cast_zero,\n    zero_cpow (ne_zero_of_one_lt_re hs), div_zero, zero_div, add_zero, ← add_div,\n    div_right_comm _ _ (2 : ℂ)] at this\n  simp_rw [push_cast, Complex.cos, neg_mul]\n  exact this.congr_fun fun n ↦ by rw [show 2 * π * a * n * I = 2 * π * I * a * n by ring]\n\n"}
{"name":"HurwitzZeta.LSeriesHasSum_cos","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ LSeriesHasSum (fun x => ↑(Real.cos (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) a) ↑x))) s (HurwitzZeta.cosZeta (↑a) s)","decl":"/-- Reformulation of `hasSum_nat_cosZeta` using `LSeriesHasSum`. -/\nlemma LSeriesHasSum_cos (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    LSeriesHasSum (Real.cos <| 2 * π * a * ·) s (cosZeta a s) :=\n  (hasSum_nat_cosZeta a hs).congr_fun (LSeries.term_of_ne_zero' (ne_zero_of_one_lt_re hs) _)\n\n"}
{"name":"HurwitzZeta.hurwitzZetaEven_one_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\nhs : ∀ (n : Nat), Ne s (Neg.neg ↑n)\nhs' : Or (Ne a 0) (Ne s 1)\n⊢ Eq (HurwitzZeta.hurwitzZetaEven a (HSub.hSub 1 s)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 (HPow.hPow (HMul.hMul 2 ↑Real.pi) (Neg.neg s))) (Complex.Gamma s)) (Complex.cos (HDiv.hDiv (HMul.hMul (↑Real.pi) s) 2))) (HurwitzZeta.cosZeta a s))","decl":"/-- If `s` is not in `-ℕ`, and either `a ≠ 0` or `s ≠ 1`, then\n`hurwitzZetaEven a (1 - s)` is an explicit multiple of `cosZeta s`. -/\nlemma hurwitzZetaEven_one_sub (a : UnitAddCircle) {s : ℂ}\n    (hs : ∀ (n : ℕ), s ≠ -n) (hs' : a ≠ 0 ∨ s ≠ 1) :\n    hurwitzZetaEven a (1 - s) = 2 * (2 * π) ^ (-s) * Gamma s * cos (π * s / 2) * cosZeta a s := by\n  have : hurwitzZetaEven a (1 - s) = completedHurwitzZetaEven a (1 - s) * (Gammaℝ (1 - s))⁻¹ := by\n    rw [hurwitzZetaEven_def_of_ne_or_ne, div_eq_mul_inv]\n    simpa [sub_eq_zero, eq_comm (a := s)] using hs'\n  rw [this, completedHurwitzZetaEven_one_sub, inv_Gammaℝ_one_sub hs, cosZeta,\n    Function.update_of_ne (by simpa using hs 0), ← Gammaℂ]\n  generalize Gammaℂ s * cos (π * s / 2) = A -- speeds up ring_nf call\n  ring_nf\n\n"}
{"name":"HurwitzZeta.cosZeta_one_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaEven","initialProofState":"a : UnitAddCircle\ns : Complex\nhs : ∀ (n : Nat), Ne s (HSub.hSub 1 ↑n)\n⊢ Eq (HurwitzZeta.cosZeta a (HSub.hSub 1 s)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 (HPow.hPow (HMul.hMul 2 ↑Real.pi) (Neg.neg s))) (Complex.Gamma s)) (Complex.cos (HDiv.hDiv (HMul.hMul (↑Real.pi) s) 2))) (HurwitzZeta.hurwitzZetaEven a s))","decl":"/-- If `s` is not of the form `1 - n` for `n ∈ ℕ`, then `cosZeta a (1 - s)` is an explicit\nmultiple of `hurwitzZetaEven s`. -/\nlemma cosZeta_one_sub (a : UnitAddCircle) {s : ℂ} (hs : ∀ (n : ℕ), s ≠ 1 - n) :\n    cosZeta a (1 - s) = 2 * (2 * π) ^ (-s) * Gamma s * cos (π * s / 2) * hurwitzZetaEven a s := by\n  rw [← Gammaℂ]\n  have : cosZeta a (1 - s) = completedCosZeta a (1 - s) * (Gammaℝ (1 - s))⁻¹ := by\n    rw [cosZeta, Function.update_of_ne, div_eq_mul_inv]\n    simpa [sub_eq_zero] using (hs 0).symm\n  rw [this, completedCosZeta_one_sub, inv_Gammaℝ_one_sub (fun n ↦ by simpa using hs (n + 1)),\n    hurwitzZetaEven_def_of_ne_or_ne (Or.inr (by simpa using hs 1))]\n  generalize Gammaℂ s * cos (π * s / 2) = A -- speeds up ring_nf call\n  ring_nf\n\n"}
