{"name":"Finsupp.toAList_entries","module":"Mathlib.Data.Finsupp.AList","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : Zero M\nf : Finsupp α M\n⊢ Eq f.toAList.entries (List.map Prod.toSigma f.graph.toList)","decl":"/-- Produce an association list for the finsupp over its support using choice. -/\n@[simps]\nnoncomputable def toAList (f : α →₀ M) : AList fun _x : α => M :=\n  ⟨f.graph.toList.map Prod.toSigma,\n    by\n      rw [List.NodupKeys, List.keys, List.map_map, Prod.fst_comp_toSigma, List.nodup_map_iff_inj_on]\n      · rintro ⟨b, m⟩ hb ⟨c, n⟩ hc (rfl : b = c)\n        rw [Finset.mem_toList, Finsupp.mem_graph_iff] at hb hc\n        dsimp at hb hc\n        rw [← hc.1, hb.1]\n      · apply Finset.nodup_toList⟩\n\n"}
{"name":"Finsupp.toAList_keys_toFinset","module":"Mathlib.Data.Finsupp.AList","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝¹ : Zero M\ninst✝ : DecidableEq α\nf : Finsupp α M\n⊢ Eq f.toAList.keys.toFinset f.support","decl":"@[simp]\ntheorem toAList_keys_toFinset [DecidableEq α] (f : α →₀ M) :\n    f.toAList.keys.toFinset = f.support := by\n  ext\n  simp [toAList, AList.mem_keys, AList.keys, List.keys]\n\n"}
{"name":"Finsupp.mem_toAlist","module":"Mathlib.Data.Finsupp.AList","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : Zero M\nf : Finsupp α M\nx : α\n⊢ Iff (Membership.mem f.toAList x) (Ne (f x) 0)","decl":"@[simp]\ntheorem mem_toAlist {f : α →₀ M} {x : α} : x ∈ f.toAList ↔ f x ≠ 0 := by\n  classical rw [AList.mem_keys, ← List.mem_toFinset, toAList_keys_toFinset, mem_support_iff]\n\n"}
{"name":"AList.lookupFinsupp_apply","module":"Mathlib.Data.Finsupp.AList","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝¹ : Zero M\ninst✝ : DecidableEq α\nl : AList fun _x => M\na : α\n⊢ Eq (l.lookupFinsupp a) ((AList.lookup a l).getD 0)","decl":"@[simp]\ntheorem lookupFinsupp_apply [DecidableEq α] (l : AList fun _x : α => M) (a : α) :\n    l.lookupFinsupp a = (l.lookup a).getD 0 := by\n    convert rfl; congr\n\n"}
{"name":"AList.lookupFinsupp_support","module":"Mathlib.Data.Finsupp.AList","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝² : Zero M\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq M\nl : AList fun _x => M\n⊢ Eq l.lookupFinsupp.support (List.filter (fun x => Decidable.decide (Ne x.snd 0)) l.entries).keys.toFinset","decl":"@[simp]\ntheorem lookupFinsupp_support [DecidableEq α] [DecidableEq M] (l : AList fun _x : α => M) :\n    l.lookupFinsupp.support = (l.1.filter fun x => Sigma.snd x ≠ 0).keys.toFinset := by\n  dsimp only [lookupFinsupp]\n  congr!\n\n"}
{"name":"AList.lookupFinsupp_eq_iff_of_ne_zero","module":"Mathlib.Data.Finsupp.AList","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝¹ : Zero M\ninst✝ : DecidableEq α\nl : AList fun _x => M\na : α\nx : M\nhx : Ne x 0\n⊢ Iff (Eq (l.lookupFinsupp a) x) (Membership.mem (AList.lookup a l) x)","decl":"theorem lookupFinsupp_eq_iff_of_ne_zero [DecidableEq α] {l : AList fun _x : α => M} {a : α} {x : M}\n    (hx : x ≠ 0) : l.lookupFinsupp a = x ↔ x ∈ l.lookup a := by\n  rw [lookupFinsupp_apply]\n  cases' lookup a l with m <;> simp [hx.symm]\n\n"}
{"name":"AList.lookupFinsupp_eq_zero_iff","module":"Mathlib.Data.Finsupp.AList","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝¹ : Zero M\ninst✝ : DecidableEq α\nl : AList fun _x => M\na : α\n⊢ Iff (Eq (l.lookupFinsupp a) 0) (Or (Not (Membership.mem l a)) (Membership.mem (AList.lookup a l) 0))","decl":"theorem lookupFinsupp_eq_zero_iff [DecidableEq α] {l : AList fun _x : α => M} {a : α} :\n    l.lookupFinsupp a = 0 ↔ a ∉ l ∨ (0 : M) ∈ l.lookup a := by\n  rw [lookupFinsupp_apply, ← lookup_eq_none]\n  cases' lookup a l with m <;> simp\n\n"}
{"name":"AList.empty_lookupFinsupp","module":"Mathlib.Data.Finsupp.AList","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : Zero M\n⊢ Eq EmptyCollection.emptyCollection.lookupFinsupp 0","decl":"@[simp]\ntheorem empty_lookupFinsupp : lookupFinsupp (∅ : AList fun _x : α => M) = 0 := by\n  classical\n    ext\n    simp\n\n"}
{"name":"AList.insert_lookupFinsupp","module":"Mathlib.Data.Finsupp.AList","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝¹ : Zero M\ninst✝ : DecidableEq α\nl : AList fun _x => M\na : α\nm : M\n⊢ Eq (AList.insert a m l).lookupFinsupp (l.lookupFinsupp.update a m)","decl":"@[simp]\ntheorem insert_lookupFinsupp [DecidableEq α] (l : AList fun _x : α => M) (a : α) (m : M) :\n    (l.insert a m).lookupFinsupp = l.lookupFinsupp.update a m := by\n  ext b\n  by_cases h : b = a <;> simp [h]\n\n"}
{"name":"AList.singleton_lookupFinsupp","module":"Mathlib.Data.Finsupp.AList","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : Zero M\na : α\nm : M\n⊢ Eq (AList.singleton a m).lookupFinsupp (Finsupp.single a m)","decl":"@[simp]\ntheorem singleton_lookupFinsupp (a : α) (m : M) :\n    (singleton a m).lookupFinsupp = Finsupp.single a m := by\n  classical\n  simp [← AList.insert_empty]\n\n"}
{"name":"Finsupp.toAList_lookupFinsupp","module":"Mathlib.Data.Finsupp.AList","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : Zero M\nf : Finsupp α M\n⊢ Eq f.toAList.lookupFinsupp f","decl":"@[simp]\ntheorem _root_.Finsupp.toAList_lookupFinsupp (f : α →₀ M) : f.toAList.lookupFinsupp = f := by\n  ext a\n  classical\n    by_cases h : f a = 0\n    · suffices f.toAList.lookup a = none by simp [h, this]\n      simp [lookup_eq_none, h]\n    · suffices f.toAList.lookup a = some (f a) by simp [h, this]\n      apply mem_lookup_iff.2\n      simpa using h\n\n"}
{"name":"AList.lookupFinsupp_surjective","module":"Mathlib.Data.Finsupp.AList","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : Zero M\n⊢ Function.Surjective AList.lookupFinsupp","decl":"theorem lookupFinsupp_surjective : Function.Surjective (@lookupFinsupp α M _) := fun f =>\n  ⟨_, Finsupp.toAList_lookupFinsupp f⟩\n\n"}
