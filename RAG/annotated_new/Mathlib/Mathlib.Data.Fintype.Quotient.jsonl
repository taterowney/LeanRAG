{"name":"Quotient.listChoice_mk","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nS : (i : ι) → Setoid (α i)\nl : List ι\na : (i : ι) → Membership.mem l i → α i\n⊢ Eq (Quotient.listChoice fun x1 x2 => Quotient.mk (S x1) (a x1 x2)) (Quotient.mk piSetoid a)","decl":"theorem listChoice_mk {l : List ι} (a : ∀ i ∈ l, α i) : listChoice (S := S) (⟦a · ·⟧) = ⟦a⟧ :=\n  match l with\n  |     [] => Quotient.sound nofun\n  | i :: l => by\n    unfold listChoice List.Pi.tail\n    rw [listChoice_mk]\n    exact congrArg (⟦·⟧) (List.Pi.cons_eta a)\n\n"}
{"name":"Quotient.list_ind","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nS : (i : ι) → Setoid (α i)\nl : List ι\nC : ((i : ι) → Membership.mem l i → Quotient (S i)) → Prop\nf : ∀ (a : (i : ι) → Membership.mem l i → α i), C fun x1 x2 => Quotient.mk (S x1) (a x1 x2)\nq : (i : ι) → Membership.mem l i → Quotient (S i)\n⊢ C q","decl":"/-- Choice-free induction principle for quotients indexed by a `List`. -/\n@[elab_as_elim]\nlemma list_ind {l : List ι} {C : (∀ i ∈ l, Quotient (S i)) → Prop}\n    (f : ∀ a : ∀ i ∈ l, α i, C (⟦a · ·⟧)) (q : ∀ i ∈ l, Quotient (S i)) : C q :=\n  match l with\n  |     [] => cast (congr_arg _ (funext₂ nofun)) (f nofun)\n  | i :: l => by\n    rw [← List.Pi.cons_eta q]\n    induction' List.Pi.head q using Quotient.ind with a\n    refine @list_ind _ (fun q ↦ C (List.Pi.cons _ _ ⟦a⟧ q)) ?_ (List.Pi.tail q)\n    intro as\n    rw [List.Pi.cons_map a as (fun i ↦ Quotient.mk (S i))]\n    exact f _\n\n"}
{"name":"Quotient.ind_fintype_pi","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nS : (i : ι) → Setoid (α i)\nC : ((i : ι) → Quotient (S i)) → Prop\nf : ∀ (a : (i : ι) → α i), C fun x => Quotient.mk (S x) (a x)\nq : (i : ι) → Quotient (S i)\n⊢ C q","decl":"/-- Choice-free induction principle for quotients indexed by a finite type.\n  See `Quotient.induction_on_pi` for the general version assuming `Classical.choice`. -/\n@[elab_as_elim]\nlemma ind_fintype_pi {C : (∀ i, Quotient (S i)) → Prop}\n    (f : ∀ a : ∀ i, α i, C (⟦a ·⟧)) (q : ∀ i, Quotient (S i)) : C q := by\n  have {m : Multiset ι} (C : (∀ i ∈ m, Quotient (S i)) → Prop) :\n      ∀ (_ : ∀ a : ∀ i ∈ m, α i, C (⟦a · ·⟧)) (q : ∀ i ∈ m, Quotient (S i)), C q := by\n    induction m using Quotient.ind\n    exact list_ind\n  exact this (fun q ↦ C (q · (Finset.mem_univ _))) (fun _ ↦ f _) (fun i _ ↦ q i)\n\n"}
{"name":"Quotient.induction_on_fintype_pi","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nS : (i : ι) → Setoid (α i)\nC : ((i : ι) → Quotient (S i)) → Prop\nq : (i : ι) → Quotient (S i)\nf : ∀ (a : (i : ι) → α i), C fun x => Quotient.mk (S x) (a x)\n⊢ C q","decl":"/-- Choice-free induction principle for quotients indexed by a finite type.\n  See `Quotient.induction_on_pi` for the general version assuming `Classical.choice`. -/\n@[elab_as_elim]\nlemma induction_on_fintype_pi {C : (∀ i, Quotient (S i)) → Prop}\n    (q : ∀ i, Quotient (S i)) (f : ∀ a : ∀ i, α i, C (⟦a ·⟧)) : C q :=\n  ind_fintype_pi f q\n\n"}
{"name":"Quotient.finChoice_eq","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nS : (i : ι) → Setoid (α i)\na : (i : ι) → α i\n⊢ Eq (Quotient.finChoice fun x => Quotient.mk (S x) (a x)) (Quotient.mk piSetoid a)","decl":"theorem finChoice_eq (a : ∀ i, α i) :\n    finChoice (S := S) (⟦a ·⟧) = ⟦a⟧ := by\n  dsimp [finChoice]\n  obtain ⟨l, hl⟩ := (Finset.univ.val : Multiset ι).exists_rep\n  simp_rw [← hl, Equiv.subtypeQuotientEquivQuotientSubtype, listChoice_mk]\n  rfl\n\n"}
{"name":"Quotient.eval_finChoice","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nS : (i : ι) → Setoid (α i)\nf : (i : ι) → Quotient (S i)\n⊢ Eq (Quotient.finChoice f).eval f","decl":"lemma eval_finChoice (f : ∀ i, Quotient (S i)) :\n    eval (finChoice f) = f :=\n  induction_on_fintype_pi f (fun a ↦ by rw [finChoice_eq]; rfl)\n\n"}
{"name":"Quotient.finLiftOn_empty","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nS : (i : ι) → Setoid (α i)\nβ : Sort u_3\ne : IsEmpty ι\nq : (i : ι) → Quotient (S i)\n⊢ Eq (Quotient.finLiftOn q) fun f x => f fun a => e.elim a","decl":"@[simp]\nlemma finLiftOn_empty [e : IsEmpty ι] (q : ∀ i, Quotient (S i)) :\n    finLiftOn (β := β) q = fun f _ ↦ f e.elim := by\n  ext f h\n  dsimp [finLiftOn]\n  induction finChoice q using Quotient.ind\n  exact h _ _ e.elim\n\n"}
{"name":"Quotient.finLiftOn_mk","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nS : (i : ι) → Setoid (α i)\nβ : Sort u_3\na : (i : ι) → α i\n⊢ Eq (Quotient.finLiftOn fun x => Quotient.mk (S x) (a x)) fun f x => f a","decl":"@[simp]\nlemma finLiftOn_mk (a : ∀ i, α i) :\n    finLiftOn (S := S) (β := β) (⟦a ·⟧) = fun f _ ↦ f a := by\n  ext f h\n  dsimp [finLiftOn]\n  rw [finChoice_eq]\n  rfl\n\n"}
{"name":"Quotient.finChoiceEquiv_symm_apply","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nS : (i : ι) → Setoid (α i)\nq : Quotient inferInstance\ni : ι\n⊢ Eq (Quotient.finChoiceEquiv.symm q i) (q.eval i)","decl":"/-- `Quotient.finChoice` as an equivalence. -/\n@[simps]\ndef finChoiceEquiv :\n    (∀ i, Quotient (S i)) ≃ @Quotient (∀ i, α i) piSetoid where\n  toFun := finChoice\n  invFun := eval\n  left_inv q := by\n    refine induction_on_fintype_pi q (fun a ↦ ?_)\n    rw [finChoice_eq]\n    rfl\n  right_inv q := by\n    induction q using Quotient.ind\n    exact finChoice_eq _\n\n"}
{"name":"Quotient.finChoiceEquiv_apply","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nS : (i : ι) → Setoid (α i)\nq : (i : ι) → Quotient (S i)\n⊢ Eq (Quotient.finChoiceEquiv q) (Quotient.finChoice q)","decl":"/-- `Quotient.finChoice` as an equivalence. -/\n@[simps]\ndef finChoiceEquiv :\n    (∀ i, Quotient (S i)) ≃ @Quotient (∀ i, α i) piSetoid where\n  toFun := finChoice\n  invFun := eval\n  left_inv q := by\n    refine induction_on_fintype_pi q (fun a ↦ ?_)\n    rw [finChoice_eq]\n    rfl\n  right_inv q := by\n    induction q using Quotient.ind\n    exact finChoice_eq _\n\n"}
{"name":"Quotient.finHRecOn_mk","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nS : (i : ι) → Setoid (α i)\nC : ((i : ι) → Quotient (S i)) → Sort u_4\na : (i : ι) → α i\n⊢ Eq (Quotient.finHRecOn fun x => Quotient.mk (S x) (a x)) fun f x => f a","decl":"@[simp]\nlemma finHRecOn_mk {C : (∀ i, Quotient (S i)) → Sort*}\n    (a : ∀ i, α i) :\n    finHRecOn (C := C) (⟦a ·⟧) = fun f _ ↦ f a := by\n  ext f h\n  refine eq_of_heq ((eqRec_heq _ _).trans ?_)\n  rw [finChoice_eq]\n  rfl\n\n"}
{"name":"Quotient.finRecOn_mk","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nS : (i : ι) → Setoid (α i)\nC : ((i : ι) → Quotient (S i)) → Sort u_4\na : (i : ι) → α i\n⊢ Eq (Quotient.finRecOn fun x => Quotient.mk (S x) (a x)) fun f x => f a","decl":"@[simp]\nlemma finRecOn_mk {C : (∀ i, Quotient (S i)) → Sort*}\n    (a : ∀ i, α i) :\n    finRecOn (C := C) (⟦a ·⟧) = fun f _ ↦ f a := by\n  unfold finRecOn\n  simp\n\n"}
{"name":"Trunc.finChoice_eq","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nα : ι → Sort u_2\nf : (i : ι) → α i\n⊢ Eq (Trunc.finChoice fun i => Trunc.mk (f i)) (Trunc.mk f)","decl":"theorem finChoice_eq (f : ∀ i, α i) : (Trunc.finChoice fun i => Trunc.mk (f i)) = Trunc.mk f :=\n  Subsingleton.elim _ _\n\n"}
{"name":"Trunc.finLiftOn_empty","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nα : ι → Sort u_2\nβ : Sort u_3\ne : IsEmpty ι\nq : (i : ι) → Trunc (α i)\n⊢ Eq (Trunc.finLiftOn q) fun f x => f fun a => e.elim a","decl":"@[simp]\nlemma finLiftOn_empty [e : IsEmpty ι] (q : ∀ i, Trunc (α i)) :\n    finLiftOn (β := β) q = fun f _ ↦ f e.elim :=\n  funext₂ fun _ _ ↦ congrFun₂ (Quotient.finLiftOn_empty q) _ _\n\n"}
{"name":"Trunc.finLiftOn_mk","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nα : ι → Sort u_2\nβ : Sort u_3\na : (i : ι) → α i\n⊢ Eq (Trunc.finLiftOn fun x => Quotient.mk trueSetoid (a x)) fun f x => f a","decl":"@[simp]\nlemma finLiftOn_mk (a : ∀ i, α i) :\n    finLiftOn (β := β) (⟦a ·⟧) = fun f _ ↦ f a :=\n  funext₂ fun _ _ ↦ congrFun₂ (Quotient.finLiftOn_mk a) _ _\n\n"}
{"name":"Trunc.finChoiceEquiv_apply","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nα : ι → Sort u_2\nq : (i : ι) → Trunc (α i)\n⊢ Eq (Trunc.finChoiceEquiv q) (Trunc.finChoice q)","decl":"/-- `Trunc.finChoice` as an equivalence. -/\n@[simps]\ndef finChoiceEquiv : (∀ i, Trunc (α i)) ≃ Trunc (∀ i, α i) where\n  toFun := finChoice\n  invFun q i := q.map (· i)\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"Trunc.finChoiceEquiv_symm_apply","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nα : ι → Sort u_2\nq : Trunc ((i : ι) → α i)\ni : ι\n⊢ Eq (Trunc.finChoiceEquiv.symm q i) (Trunc.map (fun x => x i) q)","decl":"/-- `Trunc.finChoice` as an equivalence. -/\n@[simps]\ndef finChoiceEquiv : (∀ i, Trunc (α i)) ≃ Trunc (∀ i, α i) where\n  toFun := finChoice\n  invFun q i := q.map (· i)\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _\n\n"}
{"name":"Trunc.finRecOn_mk","module":"Mathlib.Data.Fintype.Quotient","initialProofState":"ι : Type u_1\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nα : ι → Sort u_2\nC : ((i : ι) → Trunc (α i)) → Sort u_4\na : (i : ι) → α i\n⊢ Eq (Trunc.finRecOn fun x => Quotient.mk trueSetoid (a x)) fun f x => f a","decl":"@[simp]\nlemma finRecOn_mk {C : (∀ i, Trunc (α i)) → Sort*}\n    (a : ∀ i, α i) :\n    finRecOn (C := C) (⟦a ·⟧) = fun f _ ↦ f a := by\n  unfold finRecOn\n  simp\n\n"}
