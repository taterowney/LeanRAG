{"name":"Filter.isOpen_Iic_principal","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\ns : Set Î±\nâŠ¢ IsOpen (Set.Iic (Filter.principal s))","decl":"theorem isOpen_Iic_principal {s : Set Î±} : IsOpen (Iic (ğ“Ÿ s)) :=\n  GenerateOpen.basic _ (mem_range_self _)\n\n"}
{"name":"Filter.isOpen_setOf_mem","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\ns : Set Î±\nâŠ¢ IsOpen (setOf fun l => Membership.mem l s)","decl":"theorem isOpen_setOf_mem {s : Set Î±} : IsOpen { l : Filter Î± | s âˆˆ l } := by\n  simpa only [Iic_principal] using isOpen_Iic_principal\n\n"}
{"name":"Filter.isTopologicalBasis_Iic_principal","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nâŠ¢ TopologicalSpace.IsTopologicalBasis (Set.range (Function.comp Set.Iic Filter.principal))","decl":"theorem isTopologicalBasis_Iic_principal :\n    IsTopologicalBasis (range (Iic âˆ˜ ğ“Ÿ : Set Î± â†’ Set (Filter Î±))) :=\n  { exists_subset_inter := by\n      rintro _ âŸ¨s, rflâŸ© _ âŸ¨t, rflâŸ© l hl\n      exact âŸ¨Iic (ğ“Ÿ s) âˆ© Iic (ğ“Ÿ t), âŸ¨s âˆ© t, by simpâŸ©, hl, Subset.rflâŸ©\n    sUnion_eq := sUnion_eq_univ_iff.2 fun _ => âŸ¨Iic âŠ¤, âŸ¨univ, congr_arg Iic principal_univâŸ©,\n      mem_Iic.2 le_topâŸ©\n    eq_generateFrom := rfl }\n\n"}
{"name":"Filter.isOpen_iff","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\ns : Set (Filter Î±)\nâŠ¢ Iff (IsOpen s) (Exists fun T => Eq s (Set.iUnion fun t => Set.iUnion fun h => Set.Iic (Filter.principal t)))","decl":"theorem isOpen_iff {s : Set (Filter Î±)} : IsOpen s â†” âˆƒ T : Set (Set Î±), s = â‹ƒ t âˆˆ T, Iic (ğ“Ÿ t) :=\n  isTopologicalBasis_Iic_principal.open_iff_eq_sUnion.trans <| by\n    simp only [exists_subset_range_and_iff, sUnion_image, (Â· âˆ˜ Â·)]\n\n"}
{"name":"Filter.nhds_eq","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nl : Filter Î±\nâŠ¢ Eq (nhds l) (l.lift' (Function.comp Set.Iic Filter.principal))","decl":"theorem nhds_eq (l : Filter Î±) : ğ“ l = l.lift' (Iic âˆ˜ ğ“Ÿ) :=\n  nhds_generateFrom.trans <| by\n    simp only [mem_setOf_eq, @and_comm (l âˆˆ _), iInf_and, iInf_range, Filter.lift', Filter.lift,\n      (Â· âˆ˜ Â·), mem_Iic, le_principal_iff]\n\n"}
{"name":"Filter.nhds_eq'","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nl : Filter Î±\nâŠ¢ Eq (nhds l) (l.lift' fun s => setOf fun l' => Membership.mem l' s)","decl":"theorem nhds_eq' (l : Filter Î±) : ğ“ l = l.lift' fun s => { l' | s âˆˆ l' } := by\n  simpa only [Function.comp_def, Iic_principal] using nhds_eq l\n\n"}
{"name":"Filter.tendsto_nhds","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nla : Filter Î±\nlb : Filter Î²\nf : Î± â†’ Filter Î²\nâŠ¢ Iff (Filter.Tendsto f la (nhds lb)) (âˆ€ (s : Set Î²), Membership.mem lb s â†’ Filter.Eventually (fun a => Membership.mem (f a) s) la)","decl":"protected theorem tendsto_nhds {la : Filter Î±} {lb : Filter Î²} {f : Î± â†’ Filter Î²} :\n    Tendsto f la (ğ“ lb) â†” âˆ€ s âˆˆ lb, âˆ€á¶  a in la, s âˆˆ f a := by\n  simp only [nhds_eq', tendsto_lift', mem_setOf_eq]\n\n"}
{"name":"Filter.HasBasis.nhds","module":"Mathlib.Topology.Filter","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_2\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ (nhds l).HasBasis p fun i => Set.Iic (Filter.principal (s i))","decl":"protected theorem HasBasis.nhds {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : HasBasis l p s) :\n    HasBasis (ğ“ l) p fun i => Iic (ğ“Ÿ (s i)) := by\n  rw [nhds_eq]\n  exact h.lift' monotone_principal.Iic\n\n"}
{"name":"Filter.tendsto_pure_self","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\nl : Filter X\nâŠ¢ Filter.Tendsto Pure.pure l (nhds l)","decl":"protected theorem tendsto_pure_self (l : Filter X) :\n    Tendsto (pure : X â†’ Filter X) l (ğ“ l) := by\n  rw [Filter.tendsto_nhds]\n  exact fun s hs â†¦ Eventually.mono hs fun x â†¦ id\n\n"}
{"name":"Filter.instIsCountablyGeneratedNhds","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nl : Filter Î±\ninstâœ : l.IsCountablyGenerated\nâŠ¢ (nhds l).IsCountablyGenerated","decl":"/-- Neighborhoods of a countably generated filter is a countably generated filter. -/\ninstance {l : Filter Î±} [IsCountablyGenerated l] : IsCountablyGenerated (ğ“ l) :=\n  let âŸ¨_b, hbâŸ© := l.exists_antitone_basis\n  HasCountableBasis.isCountablyGenerated <| âŸ¨hb.nhds, Set.to_countable _âŸ©\n\n"}
{"name":"Filter.HasBasis.nhds'","module":"Mathlib.Topology.Filter","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_2\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ (nhds l).HasBasis p fun i => setOf fun l' => Membership.mem l' (s i)","decl":"theorem HasBasis.nhds' {l : Filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : HasBasis l p s) :\n    HasBasis (ğ“ l) p fun i => { l' | s i âˆˆ l' } := by simpa only [Iic_principal] using h.nhds\n\n"}
{"name":"Filter.mem_nhds_iff","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nl : Filter Î±\nS : Set (Filter Î±)\nâŠ¢ Iff (Membership.mem (nhds l) S) (Exists fun t => And (Membership.mem l t) (HasSubset.Subset (Set.Iic (Filter.principal t)) S))","decl":"protected theorem mem_nhds_iff {l : Filter Î±} {S : Set (Filter Î±)} :\n    S âˆˆ ğ“ l â†” âˆƒ t âˆˆ l, Iic (ğ“Ÿ t) âŠ† S :=\n  l.basis_sets.nhds.mem_iff\n\n"}
{"name":"Filter.mem_nhds_iff'","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nl : Filter Î±\nS : Set (Filter Î±)\nâŠ¢ Iff (Membership.mem (nhds l) S) (Exists fun t => And (Membership.mem l t) (âˆ€ â¦ƒl' : Filter Î±â¦„, Membership.mem l' t â†’ Membership.mem S l'))","decl":"theorem mem_nhds_iff' {l : Filter Î±} {S : Set (Filter Î±)} :\n    S âˆˆ ğ“ l â†” âˆƒ t âˆˆ l, âˆ€ â¦ƒl' : Filter Î±â¦„, t âˆˆ l' â†’ l' âˆˆ S :=\n  l.basis_sets.nhds'.mem_iff\n\n"}
{"name":"Filter.nhds_bot","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nâŠ¢ Eq (nhds Bot.bot) (Pure.pure Bot.bot)","decl":"@[simp]\ntheorem nhds_bot : ğ“ (âŠ¥ : Filter Î±) = pure âŠ¥ := by\n  simp [nhds_eq, Function.comp_def, lift'_bot monotone_principal.Iic]\n\n"}
{"name":"Filter.nhds_top","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nâŠ¢ Eq (nhds Top.top) Top.top","decl":"@[simp]\ntheorem nhds_top : ğ“ (âŠ¤ : Filter Î±) = âŠ¤ := by simp [nhds_eq]\n\n"}
{"name":"Filter.nhds_principal","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\ns : Set Î±\nâŠ¢ Eq (nhds (Filter.principal s)) (Filter.principal (Set.Iic (Filter.principal s)))","decl":"@[simp]\ntheorem nhds_principal (s : Set Î±) : ğ“ (ğ“Ÿ s) = ğ“Ÿ (Iic (ğ“Ÿ s)) :=\n  (hasBasis_principal s).nhds.eq_of_same_basis (hasBasis_principal _)\n\n"}
{"name":"Filter.nhds_pure","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nx : Î±\nâŠ¢ Eq (nhds (Pure.pure x)) (Filter.principal (Insert.insert Bot.bot (Singleton.singleton (Pure.pure x))))","decl":"@[simp]\ntheorem nhds_pure (x : Î±) : ğ“ (pure x : Filter Î±) = ğ“Ÿ {âŠ¥, pure x} := by\n  rw [â† principal_singleton, nhds_principal, principal_singleton, Iic_pure]\n\n"}
{"name":"Filter.nhds_iInf","module":"Mathlib.Topology.Filter","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_2\nf : Î¹ â†’ Filter Î±\nâŠ¢ Eq (nhds (iInf fun i => f i)) (iInf fun i => nhds (f i))","decl":"@[simp]\nprotected theorem nhds_iInf (f : Î¹ â†’ Filter Î±) : ğ“ (â¨… i, f i) = â¨… i, ğ“ (f i) := by\n  simp only [nhds_eq]\n  apply lift'_iInf_of_map_univ <;> simp\n\n"}
{"name":"Filter.nhds_inf","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nlâ‚ lâ‚‚ : Filter Î±\nâŠ¢ Eq (nhds (Min.min lâ‚ lâ‚‚)) (Min.min (nhds lâ‚) (nhds lâ‚‚))","decl":"@[simp]\nprotected theorem nhds_inf (lâ‚ lâ‚‚ : Filter Î±) : ğ“ (lâ‚ âŠ“ lâ‚‚) = ğ“ lâ‚ âŠ“ ğ“ lâ‚‚ := by\n  simpa only [iInf_bool_eq] using Filter.nhds_iInf fun b => cond b lâ‚ lâ‚‚\n\n"}
{"name":"Filter.monotone_nhds","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nâŠ¢ Monotone nhds","decl":"theorem monotone_nhds : Monotone (ğ“ : Filter Î± â†’ Filter (Filter Î±)) :=\n  Monotone.of_map_inf Filter.nhds_inf\n\n"}
{"name":"Filter.sInter_nhds","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nl : Filter Î±\nâŠ¢ Eq (setOf fun s => Membership.mem (nhds l) s).sInter (Set.Iic l)","decl":"theorem sInter_nhds (l : Filter Î±) : â‹‚â‚€ { s | s âˆˆ ğ“ l } = Iic l := by\n  simp_rw [nhds_eq, Function.comp_def, sInter_lift'_sets monotone_principal.Iic, Iic,\n    le_principal_iff, â† setOf_forall, â† Filter.le_def]\n\n"}
{"name":"Filter.nhds_mono","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nlâ‚ lâ‚‚ : Filter Î±\nâŠ¢ Iff (LE.le (nhds lâ‚) (nhds lâ‚‚)) (LE.le lâ‚ lâ‚‚)","decl":"@[simp]\ntheorem nhds_mono {lâ‚ lâ‚‚ : Filter Î±} : ğ“ lâ‚ â‰¤ ğ“ lâ‚‚ â†” lâ‚ â‰¤ lâ‚‚ := by\n  refine âŸ¨fun h => ?_, fun h => monotone_nhds hâŸ©\n  rw [â† Iic_subset_Iic, â† sInter_nhds, â† sInter_nhds]\n  exact sInter_subset_sInter h\n\n"}
{"name":"Filter.mem_interior","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\ns : Set (Filter Î±)\nl : Filter Î±\nâŠ¢ Iff (Membership.mem (interior s) l) (Exists fun t => And (Membership.mem l t) (HasSubset.Subset (Set.Iic (Filter.principal t)) s))","decl":"protected theorem mem_interior {s : Set (Filter Î±)} {l : Filter Î±} :\n    l âˆˆ interior s â†” âˆƒ t âˆˆ l, Iic (ğ“Ÿ t) âŠ† s := by\n  rw [mem_interior_iff_mem_nhds, Filter.mem_nhds_iff]\n\n"}
{"name":"Filter.mem_closure","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\ns : Set (Filter Î±)\nl : Filter Î±\nâŠ¢ Iff (Membership.mem (closure s) l) (âˆ€ (t : Set Î±), Membership.mem l t â†’ Exists fun l' => And (Membership.mem s l') (Membership.mem l' t))","decl":"protected theorem mem_closure {s : Set (Filter Î±)} {l : Filter Î±} :\n    l âˆˆ closure s â†” âˆ€ t âˆˆ l, âˆƒ l' âˆˆ s, t âˆˆ l' := by\n  simp only [closure_eq_compl_interior_compl, Filter.mem_interior, mem_compl_iff, not_exists,\n    not_forall, Classical.not_not, exists_prop, not_and, and_comm, subset_def, mem_Iic,\n    le_principal_iff]\n\n"}
{"name":"Filter.closure_singleton","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nl : Filter Î±\nâŠ¢ Eq (closure (Singleton.singleton l)) (Set.Ici l)","decl":"@[simp]\nprotected theorem closure_singleton (l : Filter Î±) : closure {l} = Ici l := by\n  ext l'\n  simp [Filter.mem_closure, Filter.le_def]\n\n"}
{"name":"Filter.specializes_iff_le","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nlâ‚ lâ‚‚ : Filter Î±\nâŠ¢ Iff (Specializes lâ‚ lâ‚‚) (LE.le lâ‚ lâ‚‚)","decl":"@[simp]\ntheorem specializes_iff_le {lâ‚ lâ‚‚ : Filter Î±} : lâ‚ â¤³ lâ‚‚ â†” lâ‚ â‰¤ lâ‚‚ := by\n  simp only [specializes_iff_closure_subset, Filter.closure_singleton, Ici_subset_Ici]\n\n"}
{"name":"Filter.instT0Space","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nâŠ¢ T0Space (Filter Î±)","decl":"instance : T0Space (Filter Î±) :=\n  âŸ¨fun _ _ h => (specializes_iff_le.1 h.specializes).antisymm\n    (specializes_iff_le.1 h.symm.specializes)âŸ©\n\n"}
{"name":"Filter.nhds_atTop","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\ninstâœ : Preorder Î±\nâŠ¢ Eq (nhds Filter.atTop) (iInf fun x => Filter.principal (Set.Iic (Filter.principal (Set.Ici x))))","decl":"theorem nhds_atTop [Preorder Î±] : ğ“ atTop = â¨… x : Î±, ğ“Ÿ (Iic (ğ“Ÿ (Ici x))) := by\n  simp only [atTop, Filter.nhds_iInf, nhds_principal]\n\n"}
{"name":"Filter.tendsto_nhds_atTop_iff","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : Preorder Î²\nl : Filter Î±\nf : Î± â†’ Filter Î²\nâŠ¢ Iff (Filter.Tendsto f l (nhds Filter.atTop)) (âˆ€ (y : Î²), Filter.Eventually (fun a => Membership.mem (f a) (Set.Ici y)) l)","decl":"protected theorem tendsto_nhds_atTop_iff [Preorder Î²] {l : Filter Î±} {f : Î± â†’ Filter Î²} :\n    Tendsto f l (ğ“ atTop) â†” âˆ€ y, âˆ€á¶  a in l, Ici y âˆˆ f a := by\n  simp only [nhds_atTop, tendsto_iInf, tendsto_principal, mem_Iic, le_principal_iff]\n\n"}
{"name":"Filter.nhds_atBot","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\ninstâœ : Preorder Î±\nâŠ¢ Eq (nhds Filter.atBot) (iInf fun x => Filter.principal (Set.Iic (Filter.principal (Set.Iic x))))","decl":"theorem nhds_atBot [Preorder Î±] : ğ“ atBot = â¨… x : Î±, ğ“Ÿ (Iic (ğ“Ÿ (Iic x))) :=\n  @nhds_atTop Î±áµ’áµˆ _\n\n"}
{"name":"Filter.tendsto_nhds_atBot_iff","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : Preorder Î²\nl : Filter Î±\nf : Î± â†’ Filter Î²\nâŠ¢ Iff (Filter.Tendsto f l (nhds Filter.atBot)) (âˆ€ (y : Î²), Filter.Eventually (fun a => Membership.mem (f a) (Set.Iic y)) l)","decl":"protected theorem tendsto_nhds_atBot_iff [Preorder Î²] {l : Filter Î±} {f : Î± â†’ Filter Î²} :\n    Tendsto f l (ğ“ atBot) â†” âˆ€ y, âˆ€á¶  a in l, Iic y âˆˆ f a :=\n  @Filter.tendsto_nhds_atTop_iff Î± Î²áµ’áµˆ _ _ _\n\n"}
{"name":"Filter.nhds_nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\ninstâœ : TopologicalSpace X\nx : X\nâŠ¢ Eq (nhds (nhds x)) (iInf fun s => iInf fun x_1 => iInf fun x => Filter.principal (Set.Iic (Filter.principal s)))","decl":"theorem nhds_nhds (x : X) :\n    ğ“ (ğ“ x) = â¨… (s : Set X) (_ : IsOpen s) (_ : x âˆˆ s), ğ“Ÿ (Iic (ğ“Ÿ s)) := by\n  simp only [(nhds_basis_opens x).nhds.eq_biInf, iInf_and, @iInf_comm _ (_ âˆˆ _)]\n\n"}
{"name":"Filter.isInducing_nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\ninstâœ : TopologicalSpace X\nâŠ¢ Topology.IsInducing nhds","decl":"theorem isInducing_nhds : IsInducing (ğ“ : X â†’ Filter X) :=\n  isInducing_iff_nhds.2 fun x =>\n    (nhds_def' _).trans <| by\n      simp +contextual only [nhds_nhds, comap_iInf, comap_principal,\n        Iic_principal, preimage_setOf_eq, â† mem_interior_iff_mem_nhds, setOf_mem_eq,\n        IsOpen.interior_eq]\n\n"}
{"name":"Filter.inducing_nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\ninstâœ : TopologicalSpace X\nâŠ¢ Topology.IsInducing nhds","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_nhds := isInducing_nhds\n\n"}
{"name":"Filter.continuous_nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\ninstâœ : TopologicalSpace X\nâŠ¢ Continuous nhds","decl":"@[continuity]\ntheorem continuous_nhds : Continuous (ğ“ : X â†’ Filter X) :=\n  isInducing_nhds.continuous\n\n"}
{"name":"Filter.Tendsto.nhds","module":"Mathlib.Topology.Filter","initialProofState":"Î± : Type u_2\nX : Type u_4\ninstâœ : TopologicalSpace X\nf : Î± â†’ X\nl : Filter Î±\nx : X\nh : Filter.Tendsto f l (nhds x)\nâŠ¢ Filter.Tendsto (Function.comp nhds f) l (nhds (nhds x))","decl":"protected theorem Tendsto.nhds {f : Î± â†’ X} {l : Filter Î±} {x : X} (h : Tendsto f l (ğ“ x)) :\n    Tendsto (ğ“ âˆ˜ f) l (ğ“ (ğ“ x)) :=\n  (continuous_nhds.tendsto _).comp h\n\n"}
{"name":"ContinuousWithinAt.nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\nY : Type u_5\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nx : X\ns : Set X\nh : ContinuousWithinAt f s x\nâŠ¢ ContinuousWithinAt (Function.comp nhds f) s x","decl":"protected nonrec theorem ContinuousWithinAt.nhds (h : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (ğ“ âˆ˜ f) s x :=\n  h.nhds\n\n"}
{"name":"ContinuousAt.nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\nY : Type u_5\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nx : X\nh : ContinuousAt f x\nâŠ¢ ContinuousAt (Function.comp nhds f) x","decl":"protected nonrec theorem ContinuousAt.nhds (h : ContinuousAt f x) : ContinuousAt (ğ“ âˆ˜ f) x :=\n  h.nhds\n\n"}
{"name":"ContinuousOn.nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\nY : Type u_5\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\ns : Set X\nh : ContinuousOn f s\nâŠ¢ ContinuousOn (Function.comp nhds f) s","decl":"protected nonrec theorem ContinuousOn.nhds (h : ContinuousOn f s) : ContinuousOn (ğ“ âˆ˜ f) s :=\n  fun x hx => (h x hx).nhds\n\n"}
{"name":"Continuous.nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\nY : Type u_5\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nh : Continuous f\nâŠ¢ Continuous (Function.comp nhds f)","decl":"protected nonrec theorem Continuous.nhds (h : Continuous f) : Continuous (ğ“ âˆ˜ f) :=\n  Filter.continuous_nhds.comp h\n"}
