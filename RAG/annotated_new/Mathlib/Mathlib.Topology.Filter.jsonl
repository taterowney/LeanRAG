{"name":"Filter.isOpen_Iic_principal","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\ns : Set α\n⊢ IsOpen (Set.Iic (Filter.principal s))","decl":"theorem isOpen_Iic_principal {s : Set α} : IsOpen (Iic (𝓟 s)) :=\n  GenerateOpen.basic _ (mem_range_self _)\n\n"}
{"name":"Filter.isOpen_setOf_mem","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\ns : Set α\n⊢ IsOpen (setOf fun l => Membership.mem l s)","decl":"theorem isOpen_setOf_mem {s : Set α} : IsOpen { l : Filter α | s ∈ l } := by\n  simpa only [Iic_principal] using isOpen_Iic_principal\n\n"}
{"name":"Filter.isTopologicalBasis_Iic_principal","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\n⊢ TopologicalSpace.IsTopologicalBasis (Set.range (Function.comp Set.Iic Filter.principal))","decl":"theorem isTopologicalBasis_Iic_principal :\n    IsTopologicalBasis (range (Iic ∘ 𝓟 : Set α → Set (Filter α))) :=\n  { exists_subset_inter := by\n      rintro _ ⟨s, rfl⟩ _ ⟨t, rfl⟩ l hl\n      exact ⟨Iic (𝓟 s) ∩ Iic (𝓟 t), ⟨s ∩ t, by simp⟩, hl, Subset.rfl⟩\n    sUnion_eq := sUnion_eq_univ_iff.2 fun _ => ⟨Iic ⊤, ⟨univ, congr_arg Iic principal_univ⟩,\n      mem_Iic.2 le_top⟩\n    eq_generateFrom := rfl }\n\n"}
{"name":"Filter.isOpen_iff","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\ns : Set (Filter α)\n⊢ Iff (IsOpen s) (Exists fun T => Eq s (Set.iUnion fun t => Set.iUnion fun h => Set.Iic (Filter.principal t)))","decl":"theorem isOpen_iff {s : Set (Filter α)} : IsOpen s ↔ ∃ T : Set (Set α), s = ⋃ t ∈ T, Iic (𝓟 t) :=\n  isTopologicalBasis_Iic_principal.open_iff_eq_sUnion.trans <| by\n    simp only [exists_subset_range_and_iff, sUnion_image, (· ∘ ·)]\n\n"}
{"name":"Filter.nhds_eq","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nl : Filter α\n⊢ Eq (nhds l) (l.lift' (Function.comp Set.Iic Filter.principal))","decl":"theorem nhds_eq (l : Filter α) : 𝓝 l = l.lift' (Iic ∘ 𝓟) :=\n  nhds_generateFrom.trans <| by\n    simp only [mem_setOf_eq, @and_comm (l ∈ _), iInf_and, iInf_range, Filter.lift', Filter.lift,\n      (· ∘ ·), mem_Iic, le_principal_iff]\n\n"}
{"name":"Filter.nhds_eq'","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nl : Filter α\n⊢ Eq (nhds l) (l.lift' fun s => setOf fun l' => Membership.mem l' s)","decl":"theorem nhds_eq' (l : Filter α) : 𝓝 l = l.lift' fun s => { l' | s ∈ l' } := by\n  simpa only [Function.comp_def, Iic_principal] using nhds_eq l\n\n"}
{"name":"Filter.tendsto_nhds","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nβ : Type u_3\nla : Filter α\nlb : Filter β\nf : α → Filter β\n⊢ Iff (Filter.Tendsto f la (nhds lb)) (∀ (s : Set β), Membership.mem lb s → Filter.Eventually (fun a => Membership.mem (f a) s) la)","decl":"protected theorem tendsto_nhds {la : Filter α} {lb : Filter β} {f : α → Filter β} :\n    Tendsto f la (𝓝 lb) ↔ ∀ s ∈ lb, ∀ᶠ a in la, s ∈ f a := by\n  simp only [nhds_eq', tendsto_lift', mem_setOf_eq]\n\n"}
{"name":"Filter.HasBasis.nhds","module":"Mathlib.Topology.Filter","initialProofState":"ι : Sort u_1\nα : Type u_2\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ (nhds l).HasBasis p fun i => Set.Iic (Filter.principal (s i))","decl":"protected theorem HasBasis.nhds {l : Filter α} {p : ι → Prop} {s : ι → Set α} (h : HasBasis l p s) :\n    HasBasis (𝓝 l) p fun i => Iic (𝓟 (s i)) := by\n  rw [nhds_eq]\n  exact h.lift' monotone_principal.Iic\n\n"}
{"name":"Filter.tendsto_pure_self","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\nl : Filter X\n⊢ Filter.Tendsto Pure.pure l (nhds l)","decl":"protected theorem tendsto_pure_self (l : Filter X) :\n    Tendsto (pure : X → Filter X) l (𝓝 l) := by\n  rw [Filter.tendsto_nhds]\n  exact fun s hs ↦ Eventually.mono hs fun x ↦ id\n\n"}
{"name":"Filter.instIsCountablyGeneratedNhds","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nl : Filter α\ninst✝ : l.IsCountablyGenerated\n⊢ (nhds l).IsCountablyGenerated","decl":"/-- Neighborhoods of a countably generated filter is a countably generated filter. -/\ninstance {l : Filter α} [IsCountablyGenerated l] : IsCountablyGenerated (𝓝 l) :=\n  let ⟨_b, hb⟩ := l.exists_antitone_basis\n  HasCountableBasis.isCountablyGenerated <| ⟨hb.nhds, Set.to_countable _⟩\n\n"}
{"name":"Filter.HasBasis.nhds'","module":"Mathlib.Topology.Filter","initialProofState":"ι : Sort u_1\nα : Type u_2\nl : Filter α\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ (nhds l).HasBasis p fun i => setOf fun l' => Membership.mem l' (s i)","decl":"theorem HasBasis.nhds' {l : Filter α} {p : ι → Prop} {s : ι → Set α} (h : HasBasis l p s) :\n    HasBasis (𝓝 l) p fun i => { l' | s i ∈ l' } := by simpa only [Iic_principal] using h.nhds\n\n"}
{"name":"Filter.mem_nhds_iff","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nl : Filter α\nS : Set (Filter α)\n⊢ Iff (Membership.mem (nhds l) S) (Exists fun t => And (Membership.mem l t) (HasSubset.Subset (Set.Iic (Filter.principal t)) S))","decl":"protected theorem mem_nhds_iff {l : Filter α} {S : Set (Filter α)} :\n    S ∈ 𝓝 l ↔ ∃ t ∈ l, Iic (𝓟 t) ⊆ S :=\n  l.basis_sets.nhds.mem_iff\n\n"}
{"name":"Filter.mem_nhds_iff'","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nl : Filter α\nS : Set (Filter α)\n⊢ Iff (Membership.mem (nhds l) S) (Exists fun t => And (Membership.mem l t) (∀ ⦃l' : Filter α⦄, Membership.mem l' t → Membership.mem S l'))","decl":"theorem mem_nhds_iff' {l : Filter α} {S : Set (Filter α)} :\n    S ∈ 𝓝 l ↔ ∃ t ∈ l, ∀ ⦃l' : Filter α⦄, t ∈ l' → l' ∈ S :=\n  l.basis_sets.nhds'.mem_iff\n\n"}
{"name":"Filter.nhds_bot","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\n⊢ Eq (nhds Bot.bot) (Pure.pure Bot.bot)","decl":"@[simp]\ntheorem nhds_bot : 𝓝 (⊥ : Filter α) = pure ⊥ := by\n  simp [nhds_eq, Function.comp_def, lift'_bot monotone_principal.Iic]\n\n"}
{"name":"Filter.nhds_top","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\n⊢ Eq (nhds Top.top) Top.top","decl":"@[simp]\ntheorem nhds_top : 𝓝 (⊤ : Filter α) = ⊤ := by simp [nhds_eq]\n\n"}
{"name":"Filter.nhds_principal","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\ns : Set α\n⊢ Eq (nhds (Filter.principal s)) (Filter.principal (Set.Iic (Filter.principal s)))","decl":"@[simp]\ntheorem nhds_principal (s : Set α) : 𝓝 (𝓟 s) = 𝓟 (Iic (𝓟 s)) :=\n  (hasBasis_principal s).nhds.eq_of_same_basis (hasBasis_principal _)\n\n"}
{"name":"Filter.nhds_pure","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nx : α\n⊢ Eq (nhds (Pure.pure x)) (Filter.principal (Insert.insert Bot.bot (Singleton.singleton (Pure.pure x))))","decl":"@[simp]\ntheorem nhds_pure (x : α) : 𝓝 (pure x : Filter α) = 𝓟 {⊥, pure x} := by\n  rw [← principal_singleton, nhds_principal, principal_singleton, Iic_pure]\n\n"}
{"name":"Filter.nhds_iInf","module":"Mathlib.Topology.Filter","initialProofState":"ι : Sort u_1\nα : Type u_2\nf : ι → Filter α\n⊢ Eq (nhds (iInf fun i => f i)) (iInf fun i => nhds (f i))","decl":"@[simp]\nprotected theorem nhds_iInf (f : ι → Filter α) : 𝓝 (⨅ i, f i) = ⨅ i, 𝓝 (f i) := by\n  simp only [nhds_eq]\n  apply lift'_iInf_of_map_univ <;> simp\n\n"}
{"name":"Filter.nhds_inf","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nl₁ l₂ : Filter α\n⊢ Eq (nhds (Min.min l₁ l₂)) (Min.min (nhds l₁) (nhds l₂))","decl":"@[simp]\nprotected theorem nhds_inf (l₁ l₂ : Filter α) : 𝓝 (l₁ ⊓ l₂) = 𝓝 l₁ ⊓ 𝓝 l₂ := by\n  simpa only [iInf_bool_eq] using Filter.nhds_iInf fun b => cond b l₁ l₂\n\n"}
{"name":"Filter.monotone_nhds","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\n⊢ Monotone nhds","decl":"theorem monotone_nhds : Monotone (𝓝 : Filter α → Filter (Filter α)) :=\n  Monotone.of_map_inf Filter.nhds_inf\n\n"}
{"name":"Filter.sInter_nhds","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nl : Filter α\n⊢ Eq (setOf fun s => Membership.mem (nhds l) s).sInter (Set.Iic l)","decl":"theorem sInter_nhds (l : Filter α) : ⋂₀ { s | s ∈ 𝓝 l } = Iic l := by\n  simp_rw [nhds_eq, Function.comp_def, sInter_lift'_sets monotone_principal.Iic, Iic,\n    le_principal_iff, ← setOf_forall, ← Filter.le_def]\n\n"}
{"name":"Filter.nhds_mono","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nl₁ l₂ : Filter α\n⊢ Iff (LE.le (nhds l₁) (nhds l₂)) (LE.le l₁ l₂)","decl":"@[simp]\ntheorem nhds_mono {l₁ l₂ : Filter α} : 𝓝 l₁ ≤ 𝓝 l₂ ↔ l₁ ≤ l₂ := by\n  refine ⟨fun h => ?_, fun h => monotone_nhds h⟩\n  rw [← Iic_subset_Iic, ← sInter_nhds, ← sInter_nhds]\n  exact sInter_subset_sInter h\n\n"}
{"name":"Filter.mem_interior","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\ns : Set (Filter α)\nl : Filter α\n⊢ Iff (Membership.mem (interior s) l) (Exists fun t => And (Membership.mem l t) (HasSubset.Subset (Set.Iic (Filter.principal t)) s))","decl":"protected theorem mem_interior {s : Set (Filter α)} {l : Filter α} :\n    l ∈ interior s ↔ ∃ t ∈ l, Iic (𝓟 t) ⊆ s := by\n  rw [mem_interior_iff_mem_nhds, Filter.mem_nhds_iff]\n\n"}
{"name":"Filter.mem_closure","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\ns : Set (Filter α)\nl : Filter α\n⊢ Iff (Membership.mem (closure s) l) (∀ (t : Set α), Membership.mem l t → Exists fun l' => And (Membership.mem s l') (Membership.mem l' t))","decl":"protected theorem mem_closure {s : Set (Filter α)} {l : Filter α} :\n    l ∈ closure s ↔ ∀ t ∈ l, ∃ l' ∈ s, t ∈ l' := by\n  simp only [closure_eq_compl_interior_compl, Filter.mem_interior, mem_compl_iff, not_exists,\n    not_forall, Classical.not_not, exists_prop, not_and, and_comm, subset_def, mem_Iic,\n    le_principal_iff]\n\n"}
{"name":"Filter.closure_singleton","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nl : Filter α\n⊢ Eq (closure (Singleton.singleton l)) (Set.Ici l)","decl":"@[simp]\nprotected theorem closure_singleton (l : Filter α) : closure {l} = Ici l := by\n  ext l'\n  simp [Filter.mem_closure, Filter.le_def]\n\n"}
{"name":"Filter.specializes_iff_le","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nl₁ l₂ : Filter α\n⊢ Iff (Specializes l₁ l₂) (LE.le l₁ l₂)","decl":"@[simp]\ntheorem specializes_iff_le {l₁ l₂ : Filter α} : l₁ ⤳ l₂ ↔ l₁ ≤ l₂ := by\n  simp only [specializes_iff_closure_subset, Filter.closure_singleton, Ici_subset_Ici]\n\n"}
{"name":"Filter.instT0Space","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\n⊢ T0Space (Filter α)","decl":"instance : T0Space (Filter α) :=\n  ⟨fun _ _ h => (specializes_iff_le.1 h.specializes).antisymm\n    (specializes_iff_le.1 h.symm.specializes)⟩\n\n"}
{"name":"Filter.nhds_atTop","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\ninst✝ : Preorder α\n⊢ Eq (nhds Filter.atTop) (iInf fun x => Filter.principal (Set.Iic (Filter.principal (Set.Ici x))))","decl":"theorem nhds_atTop [Preorder α] : 𝓝 atTop = ⨅ x : α, 𝓟 (Iic (𝓟 (Ici x))) := by\n  simp only [atTop, Filter.nhds_iInf, nhds_principal]\n\n"}
{"name":"Filter.tendsto_nhds_atTop_iff","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : Preorder β\nl : Filter α\nf : α → Filter β\n⊢ Iff (Filter.Tendsto f l (nhds Filter.atTop)) (∀ (y : β), Filter.Eventually (fun a => Membership.mem (f a) (Set.Ici y)) l)","decl":"protected theorem tendsto_nhds_atTop_iff [Preorder β] {l : Filter α} {f : α → Filter β} :\n    Tendsto f l (𝓝 atTop) ↔ ∀ y, ∀ᶠ a in l, Ici y ∈ f a := by\n  simp only [nhds_atTop, tendsto_iInf, tendsto_principal, mem_Iic, le_principal_iff]\n\n"}
{"name":"Filter.nhds_atBot","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\ninst✝ : Preorder α\n⊢ Eq (nhds Filter.atBot) (iInf fun x => Filter.principal (Set.Iic (Filter.principal (Set.Iic x))))","decl":"theorem nhds_atBot [Preorder α] : 𝓝 atBot = ⨅ x : α, 𝓟 (Iic (𝓟 (Iic x))) :=\n  @nhds_atTop αᵒᵈ _\n\n"}
{"name":"Filter.tendsto_nhds_atBot_iff","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : Preorder β\nl : Filter α\nf : α → Filter β\n⊢ Iff (Filter.Tendsto f l (nhds Filter.atBot)) (∀ (y : β), Filter.Eventually (fun a => Membership.mem (f a) (Set.Iic y)) l)","decl":"protected theorem tendsto_nhds_atBot_iff [Preorder β] {l : Filter α} {f : α → Filter β} :\n    Tendsto f l (𝓝 atBot) ↔ ∀ y, ∀ᶠ a in l, Iic y ∈ f a :=\n  @Filter.tendsto_nhds_atTop_iff α βᵒᵈ _ _ _\n\n"}
{"name":"Filter.nhds_nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (nhds (nhds x)) (iInf fun s => iInf fun x_1 => iInf fun x => Filter.principal (Set.Iic (Filter.principal s)))","decl":"theorem nhds_nhds (x : X) :\n    𝓝 (𝓝 x) = ⨅ (s : Set X) (_ : IsOpen s) (_ : x ∈ s), 𝓟 (Iic (𝓟 s)) := by\n  simp only [(nhds_basis_opens x).nhds.eq_biInf, iInf_and, @iInf_comm _ (_ ∈ _)]\n\n"}
{"name":"Filter.isInducing_nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\ninst✝ : TopologicalSpace X\n⊢ Topology.IsInducing nhds","decl":"theorem isInducing_nhds : IsInducing (𝓝 : X → Filter X) :=\n  isInducing_iff_nhds.2 fun x =>\n    (nhds_def' _).trans <| by\n      simp +contextual only [nhds_nhds, comap_iInf, comap_principal,\n        Iic_principal, preimage_setOf_eq, ← mem_interior_iff_mem_nhds, setOf_mem_eq,\n        IsOpen.interior_eq]\n\n"}
{"name":"Filter.inducing_nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\ninst✝ : TopologicalSpace X\n⊢ Topology.IsInducing nhds","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_nhds := isInducing_nhds\n\n"}
{"name":"Filter.continuous_nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\ninst✝ : TopologicalSpace X\n⊢ Continuous nhds","decl":"@[continuity]\ntheorem continuous_nhds : Continuous (𝓝 : X → Filter X) :=\n  isInducing_nhds.continuous\n\n"}
{"name":"Filter.Tendsto.nhds","module":"Mathlib.Topology.Filter","initialProofState":"α : Type u_2\nX : Type u_4\ninst✝ : TopologicalSpace X\nf : α → X\nl : Filter α\nx : X\nh : Filter.Tendsto f l (nhds x)\n⊢ Filter.Tendsto (Function.comp nhds f) l (nhds (nhds x))","decl":"protected theorem Tendsto.nhds {f : α → X} {l : Filter α} {x : X} (h : Tendsto f l (𝓝 x)) :\n    Tendsto (𝓝 ∘ f) l (𝓝 (𝓝 x)) :=\n  (continuous_nhds.tendsto _).comp h\n\n"}
{"name":"ContinuousWithinAt.nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\nY : Type u_5\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nx : X\ns : Set X\nh : ContinuousWithinAt f s x\n⊢ ContinuousWithinAt (Function.comp nhds f) s x","decl":"protected nonrec theorem ContinuousWithinAt.nhds (h : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (𝓝 ∘ f) s x :=\n  h.nhds\n\n"}
{"name":"ContinuousAt.nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\nY : Type u_5\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nx : X\nh : ContinuousAt f x\n⊢ ContinuousAt (Function.comp nhds f) x","decl":"protected nonrec theorem ContinuousAt.nhds (h : ContinuousAt f x) : ContinuousAt (𝓝 ∘ f) x :=\n  h.nhds\n\n"}
{"name":"ContinuousOn.nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\nY : Type u_5\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nh : ContinuousOn f s\n⊢ ContinuousOn (Function.comp nhds f) s","decl":"protected nonrec theorem ContinuousOn.nhds (h : ContinuousOn f s) : ContinuousOn (𝓝 ∘ f) s :=\n  fun x hx => (h x hx).nhds\n\n"}
{"name":"Continuous.nhds","module":"Mathlib.Topology.Filter","initialProofState":"X : Type u_4\nY : Type u_5\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nh : Continuous f\n⊢ Continuous (Function.comp nhds f)","decl":"protected nonrec theorem Continuous.nhds (h : Continuous f) : Continuous (𝓝 ∘ f) :=\n  Filter.continuous_nhds.comp h\n"}
