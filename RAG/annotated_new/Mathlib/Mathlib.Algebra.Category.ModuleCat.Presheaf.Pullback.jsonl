{"name":"PresheafOfModules.pullbackObjIsDefined_free_yoneda","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Pullback","initialProofState":"C D : Type u\ninst✝¹ : CategoryTheory.SmallCategory C\ninst✝ : CategoryTheory.SmallCategory D\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) RingCat\nS : CategoryTheory.Functor (Opposite C) RingCat\nφ : Quiver.Hom S (F.op.comp R)\nX : C\n⊢ PresheafOfModules.PullbackObjIsDefined φ ((PresheafOfModules.free S).obj (CategoryTheory.yoneda.obj X))","decl":"lemma pullbackObjIsDefined_free_yoneda (X : C) :\n    PullbackObjIsDefined φ ((free S).obj (yoneda.obj X)) :=\n  (pushforwardCompCoyonedaFreeYonedaCorepresentableBy φ X).isCorepresentable\n\n"}
{"name":"PresheafOfModules.pullbackObjIsDefined_eq_top","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Pullback","initialProofState":"C D : Type u\ninst✝¹ : CategoryTheory.SmallCategory C\ninst✝ : CategoryTheory.SmallCategory D\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) RingCat\nS : CategoryTheory.Functor (Opposite C) RingCat\nφ : Quiver.Hom S (F.op.comp R)\n⊢ Eq (PresheafOfModules.PullbackObjIsDefined φ) Top.top","decl":"lemma pullbackObjIsDefined_eq_top :\n    PullbackObjIsDefined.{u} φ = ⊤ := by\n  ext M\n  simp only [Pi.top_apply, Prop.top_eq_true, iff_true]\n  apply Functor.leftAdjointObjIsDefined_of_isColimit\n    M.isColimitFreeYonedaCoproductsCokernelCofork\n  rintro (_ | _)\n  all_goals\n    apply Functor.leftAdjointObjIsDefined_colimit _\n      (fun _ ↦ pullbackObjIsDefined_free_yoneda _ _)\n\n"}
{"name":"PresheafOfModules.instIsRightAdjointPushforward","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Pullback","initialProofState":"C D : Type u\ninst✝¹ : CategoryTheory.SmallCategory C\ninst✝ : CategoryTheory.SmallCategory D\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) RingCat\nS : CategoryTheory.Functor (Opposite C) RingCat\nφ : Quiver.Hom S (F.op.comp R)\n⊢ (PresheafOfModules.pushforward φ).IsRightAdjoint","decl":"instance : (pushforward.{u} φ).IsRightAdjoint :=\n  Functor.isRightAdjoint_of_leftAdjointObjIsDefined_eq_top\n    (pullbackObjIsDefined_eq_top φ)\n\n"}
