{"name":"ContinuousLinearMap.toExposed.isExposed","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nl : ContinuousLinearMap (RingHom.id ùïú) E ùïú\nA : Set E\n‚ä¢ IsExposed ùïú A (l.toExposed A)","decl":"theorem ContinuousLinearMap.toExposed.isExposed : IsExposed ùïú A (l.toExposed A) := fun _ => ‚ü®l, rfl‚ü©\n\n"}
{"name":"isExposed_empty","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA : Set E\n‚ä¢ IsExposed ùïú A EmptyCollection.emptyCollection","decl":"theorem isExposed_empty : IsExposed ùïú A ‚àÖ := fun ‚ü®_, hx‚ü© => by\n  exfalso\n  exact hx\n\n"}
{"name":"IsExposed.subset","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA B : Set E\nhAB : IsExposed ùïú A B\n‚ä¢ HasSubset.Subset B A","decl":"protected theorem subset (hAB : IsExposed ùïú A B) : B ‚äÜ A := by\n  rintro x hx\n  obtain ‚ü®_, rfl‚ü© := hAB ‚ü®x, hx‚ü©\n  exact hx.1\n\n"}
{"name":"IsExposed.refl","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA : Set E\n‚ä¢ IsExposed ùïú A A","decl":"@[refl]\nprotected theorem refl (A : Set E) : IsExposed ùïú A A := fun ‚ü®_, _‚ü© =>\n  ‚ü®0, Subset.antisymm (fun _ hx => ‚ü®hx, fun _ _ => le_refl 0‚ü©) fun _ hx => hx.1‚ü©\n\n"}
{"name":"IsExposed.antisymm","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA B : Set E\nhB : IsExposed ùïú A B\nhA : IsExposed ùïú B A\n‚ä¢ Eq A B","decl":"protected theorem antisymm (hB : IsExposed ùïú A B) (hA : IsExposed ùïú B A) : A = B :=\n  hA.subset.antisymm hB.subset\n\n"}
{"name":"IsExposed.mono","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA B C : Set E\nhC : IsExposed ùïú A C\nhBA : HasSubset.Subset B A\nhCB : HasSubset.Subset C B\n‚ä¢ IsExposed ùïú B C","decl":"protected theorem mono (hC : IsExposed ùïú A C) (hBA : B ‚äÜ A) (hCB : C ‚äÜ B) : IsExposed ùïú B C := by\n  rintro ‚ü®w, hw‚ü©\n  obtain ‚ü®l, rfl‚ü© := hC ‚ü®w, hw‚ü©\n  exact ‚ü®l, Subset.antisymm (fun x hx => ‚ü®hCB hx, fun y hy => hx.2 y (hBA hy)‚ü©) fun x hx =>\n    ‚ü®hBA hx.1, fun y hy => (hw.2 y hy).trans (hx.2 w (hCB hw))‚ü©‚ü©\n\n"}
{"name":"IsExposed.eq_inter_halfSpace'","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA B : Set E\nhAB : IsExposed ùïú A B\nhB : B.Nonempty\n‚ä¢ Exists fun l => Exists fun a => Eq B (setOf fun x => And (Membership.mem A x) (LE.le a (l x)))","decl":"/-- If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\nhalf-space. The converse is *not* true. It would require that the corresponding open half-space\ndoesn't intersect `A`. -/\ntheorem eq_inter_halfSpace' {A B : Set E} (hAB : IsExposed ùïú A B) (hB : B.Nonempty) :\n    ‚àÉ l : E ‚ÜíL[ùïú] ùïú, ‚àÉ a, B = { x ‚àà A | a ‚â§ l x } := by\n  obtain ‚ü®l, rfl‚ü© := hAB hB\n  obtain ‚ü®w, hw‚ü© := hB\n  exact ‚ü®l, l w, Subset.antisymm (fun x hx => ‚ü®hx.1, hx.2 w hw.1‚ü©) fun x hx =>\n    ‚ü®hx.1, fun y hy => (hw.2 y hy).trans hx.2‚ü©‚ü©\n"}
{"name":"IsExposed.eq_inter_halfspace'","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA B : Set E\nhAB : IsExposed ùïú A B\nhB : B.Nonempty\n‚ä¢ Exists fun l => Exists fun a => Eq B (setOf fun x => And (Membership.mem A x) (LE.le a (l x)))","decl":"@[deprecated (since := \"2024-11-12\")] alias eq_inter_halfspace' := eq_inter_halfSpace'\n\n"}
{"name":"IsExposed.eq_inter_halfSpace","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Åµ : TopologicalSpace ùïú\ninst‚úù‚Å¥ : OrderedRing ùïú\ninst‚úù¬≥ : AddCommMonoid E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : Module ùïú E\ninst‚úù : Nontrivial ùïú\nA B : Set E\nhAB : IsExposed ùïú A B\n‚ä¢ Exists fun l => Exists fun a => Eq B (setOf fun x => And (Membership.mem A x) (LE.le a (l x)))","decl":"/-- For nontrivial `ùïú`, if `B` is an exposed subset of `A`, then `B` is the intersection of `A` with\nsome closed half-space. The converse is *not* true. It would require that the corresponding open\nhalf-space doesn't intersect `A`. -/\ntheorem eq_inter_halfSpace [Nontrivial ùïú] {A B : Set E} (hAB : IsExposed ùïú A B) :\n    ‚àÉ l : E ‚ÜíL[ùïú] ùïú, ‚àÉ a, B = { x ‚àà A | a ‚â§ l x } := by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  ¬∑ refine ‚ü®0, 1, ?_‚ü©\n    rw [eq_comm, eq_empty_iff_forall_not_mem]\n    rintro x ‚ü®-, h‚ü©\n    rw [ContinuousLinearMap.zero_apply] at h\n    have : ¬¨(1 : ùïú) ‚â§ 0 := not_le_of_lt zero_lt_one\n    contradiction\n  exact hAB.eq_inter_halfSpace' hB\n"}
{"name":"IsExposed.eq_inter_halfspace","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Åµ : TopologicalSpace ùïú\ninst‚úù‚Å¥ : OrderedRing ùïú\ninst‚úù¬≥ : AddCommMonoid E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : Module ùïú E\ninst‚úù : Nontrivial ùïú\nA B : Set E\nhAB : IsExposed ùïú A B\n‚ä¢ Exists fun l => Exists fun a => Eq B (setOf fun x => And (Membership.mem A x) (LE.le a (l x)))","decl":"@[deprecated (since := \"2024-11-12\")] alias eq_inter_halfspace := eq_inter_halfSpace\n\n"}
{"name":"IsExposed.inter","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Åµ : TopologicalSpace ùïú\ninst‚úù‚Å¥ : OrderedRing ùïú\ninst‚úù¬≥ : AddCommMonoid E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : Module ùïú E\ninst‚úù : ContinuousAdd ùïú\nA B C : Set E\nhB : IsExposed ùïú A B\nhC : IsExposed ùïú A C\n‚ä¢ IsExposed ùïú A (Inter.inter B C)","decl":"protected theorem inter [ContinuousAdd ùïú] {A B C : Set E} (hB : IsExposed ùïú A B)\n    (hC : IsExposed ùïú A C) : IsExposed ùïú A (B ‚à© C) := by\n  rintro ‚ü®w, hwB, hwC‚ü©\n  obtain ‚ü®l‚ÇÅ, rfl‚ü© := hB ‚ü®w, hwB‚ü©\n  obtain ‚ü®l‚ÇÇ, rfl‚ü© := hC ‚ü®w, hwC‚ü©\n  refine ‚ü®l‚ÇÅ + l‚ÇÇ, Subset.antisymm ?_ ?_‚ü©\n  ¬∑ rintro x ‚ü®‚ü®hxA, hxB‚ü©, ‚ü®-, hxC‚ü©‚ü©\n    exact ‚ü®hxA, fun z hz => add_le_add (hxB z hz) (hxC z hz)‚ü©\n  rintro x ‚ü®hxA, hx‚ü©\n  refine ‚ü®‚ü®hxA, fun y hy => ?_‚ü©, hxA, fun y hy => ?_‚ü©\n  ¬∑ exact\n      (add_le_add_iff_right (l‚ÇÇ x)).1 ((add_le_add (hwB.2 y hy) (hwC.2 x hxA)).trans (hx w hwB.1))\n  ¬∑ exact\n      (add_le_add_iff_left (l‚ÇÅ x)).1 (le_trans (add_le_add (hwB.2 x hxA) (hwC.2 y hy)) (hx w hwB.1))\n\n"}
{"name":"IsExposed.sInter","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Åµ : TopologicalSpace ùïú\ninst‚úù‚Å¥ : OrderedRing ùïú\ninst‚úù¬≥ : AddCommMonoid E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : Module ùïú E\nA : Set E\ninst‚úù : ContinuousAdd ùïú\nF : Finset (Set E)\nhF : F.Nonempty\nhAF : ‚àÄ (B : Set E), Membership.mem F B ‚Üí IsExposed ùïú A B\n‚ä¢ IsExposed ùïú A (‚ÜëF).sInter","decl":"theorem sInter [ContinuousAdd ùïú] {F : Finset (Set E)} (hF : F.Nonempty)\n    (hAF : ‚àÄ B ‚àà F, IsExposed ùïú A B) : IsExposed ùïú A (‚ãÇ‚ÇÄ F) := by\n  classical\n  induction F using Finset.induction with\n  | empty => exfalso; exact Finset.not_nonempty_empty hF\n  | @insert C F _ hF' =>\n    rw [Finset.coe_insert, sInter_insert]\n    obtain rfl | hFnemp := F.eq_empty_or_nonempty\n    ¬∑ rw [Finset.coe_empty, sInter_empty, inter_univ]\n      exact hAF C (Finset.mem_singleton_self C)\n    ¬∑ exact (hAF C (Finset.mem_insert_self C F)).inter\n        (hF' hFnemp fun B hB => hAF B (Finset.mem_insert_of_mem hB))\n\n"}
{"name":"IsExposed.inter_left","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA B C : Set E\nhC : IsExposed ùïú A C\nhCB : HasSubset.Subset C B\n‚ä¢ IsExposed ùïú (Inter.inter A B) C","decl":"theorem inter_left (hC : IsExposed ùïú A C) (hCB : C ‚äÜ B) : IsExposed ùïú (A ‚à© B) C := by\n  rintro ‚ü®w, hw‚ü©\n  obtain ‚ü®l, rfl‚ü© := hC ‚ü®w, hw‚ü©\n  exact ‚ü®l, Subset.antisymm (fun x hx => ‚ü®‚ü®hx.1, hCB hx‚ü©, fun y hy => hx.2 y hy.1‚ü©)\n    fun x ‚ü®‚ü®hxC, _‚ü©, hx‚ü© => ‚ü®hxC, fun y hy => (hw.2 y hy).trans (hx w ‚ü®hC.subset hw, hCB hw‚ü©)‚ü©‚ü©\n\n"}
{"name":"IsExposed.inter_right","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA B C : Set E\nhC : IsExposed ùïú B C\nhCA : HasSubset.Subset C A\n‚ä¢ IsExposed ùïú (Inter.inter A B) C","decl":"theorem inter_right (hC : IsExposed ùïú B C) (hCA : C ‚äÜ A) : IsExposed ùïú (A ‚à© B) C := by\n  rw [inter_comm]\n  exact hC.inter_left hCA\n\n"}
{"name":"IsExposed.isClosed","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Åµ : TopologicalSpace ùïú\ninst‚úù‚Å¥ : OrderedRing ùïú\ninst‚úù¬≥ : AddCommMonoid E\ninst‚úù¬≤ : TopologicalSpace E\ninst‚úù¬π : Module ùïú E\ninst‚úù : OrderClosedTopology ùïú\nA B : Set E\nhAB : IsExposed ùïú A B\nhA : IsClosed A\n‚ä¢ IsClosed B","decl":"protected theorem isClosed [OrderClosedTopology ùïú] {A B : Set E} (hAB : IsExposed ùïú A B)\n    (hA : IsClosed A) : IsClosed B := by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  ¬∑ simp\n  obtain ‚ü®l, a, rfl‚ü© := hAB.eq_inter_halfSpace' hB\n  exact hA.isClosed_le continuousOn_const l.continuous.continuousOn\n\n"}
{"name":"IsExposed.isCompact","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å∂ : TopologicalSpace ùïú\ninst‚úù‚Åµ : OrderedRing ùïú\ninst‚úù‚Å¥ : AddCommMonoid E\ninst‚úù¬≥ : TopologicalSpace E\ninst‚úù¬≤ : Module ùïú E\ninst‚úù¬π : OrderClosedTopology ùïú\ninst‚úù : T2Space E\nA B : Set E\nhAB : IsExposed ùïú A B\nhA : IsCompact A\n‚ä¢ IsCompact B","decl":"protected theorem isCompact [OrderClosedTopology ùïú] [T2Space E] {A B : Set E}\n    (hAB : IsExposed ùïú A B) (hA : IsCompact A) : IsCompact B :=\n  hA.of_isClosed_subset (hAB.isClosed hA.isClosed) hAB.subset\n\n"}
{"name":"exposed_point_def","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA : Set E\nx : E\n‚ä¢ Iff (Membership.mem (Set.exposedPoints ùïú A) x) (And (Membership.mem A x) (Exists fun l => ‚àÄ (y : E), Membership.mem A y ‚Üí And (LE.le (l y) (l x)) (LE.le (l x) (l y) ‚Üí Eq y x)))","decl":"theorem exposed_point_def :\n    x ‚àà A.exposedPoints ùïú ‚Üî x ‚àà A ‚àß ‚àÉ l : E ‚ÜíL[ùïú] ùïú, ‚àÄ y ‚àà A, l y ‚â§ l x ‚àß (l x ‚â§ l y ‚Üí y = x) :=\n  Iff.rfl\n\n"}
{"name":"exposedPoints_subset","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA : Set E\n‚ä¢ HasSubset.Subset (Set.exposedPoints ùïú A) A","decl":"theorem exposedPoints_subset : A.exposedPoints ùïú ‚äÜ A := fun _ hx => hx.1\n\n"}
{"name":"exposedPoints_empty","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\n‚ä¢ Eq (Set.exposedPoints ùïú EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem exposedPoints_empty : (‚àÖ : Set E).exposedPoints ùïú = ‚àÖ :=\n  subset_empty_iff.1 exposedPoints_subset\n\n"}
{"name":"mem_exposedPoints_iff_exposed_singleton","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : OrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA : Set E\nx : E\n‚ä¢ Iff (Membership.mem (Set.exposedPoints ùïú A) x) (IsExposed ùïú A (Singleton.singleton x))","decl":"/-- Exposed points exactly correspond to exposed singletons. -/\ntheorem mem_exposedPoints_iff_exposed_singleton : x ‚àà A.exposedPoints ùïú ‚Üî IsExposed ùïú A {x} := by\n  use fun ‚ü®hxA, l, hl‚ü© _ =>\n    ‚ü®l,\n      Eq.symm <|\n        eq_singleton_iff_unique_mem.2\n          ‚ü®‚ü®hxA, fun y hy => (hl y hy).1‚ü©, fun z hz => (hl z hz.1).2 (hz.2 x hxA)‚ü©‚ü©\n  rintro h\n  obtain ‚ü®l, hl‚ü© := h ‚ü®x, mem_singleton _‚ü©\n  rw [eq_comm, eq_singleton_iff_unique_mem] at hl\n  exact\n    ‚ü®hl.1.1, l, fun y hy =>\n      ‚ü®hl.1.2 y hy, fun hxy => hl.2 y ‚ü®hy, fun z hz => (hl.1.2 z hz).trans hxy‚ü©‚ü©‚ü©\n\n"}
{"name":"IsExposed.convex","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : LinearOrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA B : Set E\nhAB : IsExposed ùïú A B\nhA : Convex ùïú A\n‚ä¢ Convex ùïú B","decl":"protected theorem convex (hAB : IsExposed ùïú A B) (hA : Convex ùïú A) : Convex ùïú B := by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  ¬∑ exact convex_empty\n  obtain ‚ü®l, rfl‚ü© := hAB hB\n  exact fun x‚ÇÅ hx‚ÇÅ x‚ÇÇ hx‚ÇÇ a b ha hb hab =>\n    ‚ü®hA hx‚ÇÅ.1 hx‚ÇÇ.1 ha hb hab, fun y hy =>\n      ((l.toLinearMap.concaveOn convex_univ).convex_ge _ ‚ü®mem_univ _, hx‚ÇÅ.2 y hy‚ü©\n          ‚ü®mem_univ _, hx‚ÇÇ.2 y hy‚ü© ha hb hab).2‚ü©\n\n"}
{"name":"IsExposed.isExtreme","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : LinearOrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA B : Set E\nhAB : IsExposed ùïú A B\n‚ä¢ IsExtreme ùïú A B","decl":"protected theorem isExtreme (hAB : IsExposed ùïú A B) : IsExtreme ùïú A B := by\n  refine ‚ü®hAB.subset, fun x‚ÇÅ hx‚ÇÅA x‚ÇÇ hx‚ÇÇA x hxB hx => ?_‚ü©\n  obtain ‚ü®l, rfl‚ü© := hAB ‚ü®x, hxB‚ü©\n  have hl : ConvexOn ùïú univ l := l.toLinearMap.convexOn convex_univ\n  have hlx‚ÇÅ := hxB.2 x‚ÇÅ hx‚ÇÅA\n  have hlx‚ÇÇ := hxB.2 x‚ÇÇ hx‚ÇÇA\n  refine ‚ü®‚ü®hx‚ÇÅA, fun y hy => ?_‚ü©, ‚ü®hx‚ÇÇA, fun y hy => ?_‚ü©‚ü©\n  ¬∑ rw [hlx‚ÇÅ.antisymm (hl.le_left_of_right_le (mem_univ _) (mem_univ _) hx hlx‚ÇÇ)]\n    exact hxB.2 y hy\n  ¬∑ rw [hlx‚ÇÇ.antisymm (hl.le_right_of_left_le (mem_univ _) (mem_univ _) hx hlx‚ÇÅ)]\n    exact hxB.2 y hy\n\n"}
{"name":"exposedPoints_subset_extremePoints","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace ùïú\ninst‚úù¬≥ : LinearOrderedRing ùïú\ninst‚úù¬≤ : AddCommMonoid E\ninst‚úù¬π : TopologicalSpace E\ninst‚úù : Module ùïú E\nA : Set E\n‚ä¢ HasSubset.Subset (Set.exposedPoints ùïú A) (Set.extremePoints ùïú A)","decl":"theorem exposedPoints_subset_extremePoints : A.exposedPoints ùïú ‚äÜ A.extremePoints ùïú := fun _ hx =>\n  (mem_exposedPoints_iff_exposed_singleton.1 hx).isExtreme.mem_extremePoints\n\n"}
