{"name":"ContinuousLinearMap.toExposed.isExposed","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nl : ContinuousLinearMap (RingHom.id 𝕜) E 𝕜\nA : Set E\n⊢ IsExposed 𝕜 A (l.toExposed A)","decl":"theorem ContinuousLinearMap.toExposed.isExposed : IsExposed 𝕜 A (l.toExposed A) := fun _ => ⟨l, rfl⟩\n\n"}
{"name":"isExposed_empty","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA : Set E\n⊢ IsExposed 𝕜 A EmptyCollection.emptyCollection","decl":"theorem isExposed_empty : IsExposed 𝕜 A ∅ := fun ⟨_, hx⟩ => by\n  exfalso\n  exact hx\n\n"}
{"name":"IsExposed.subset","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA B : Set E\nhAB : IsExposed 𝕜 A B\n⊢ HasSubset.Subset B A","decl":"protected theorem subset (hAB : IsExposed 𝕜 A B) : B ⊆ A := by\n  rintro x hx\n  obtain ⟨_, rfl⟩ := hAB ⟨x, hx⟩\n  exact hx.1\n\n"}
{"name":"IsExposed.refl","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA : Set E\n⊢ IsExposed 𝕜 A A","decl":"@[refl]\nprotected theorem refl (A : Set E) : IsExposed 𝕜 A A := fun ⟨_, _⟩ =>\n  ⟨0, Subset.antisymm (fun _ hx => ⟨hx, fun _ _ => le_refl 0⟩) fun _ hx => hx.1⟩\n\n"}
{"name":"IsExposed.antisymm","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA B : Set E\nhB : IsExposed 𝕜 A B\nhA : IsExposed 𝕜 B A\n⊢ Eq A B","decl":"protected theorem antisymm (hB : IsExposed 𝕜 A B) (hA : IsExposed 𝕜 B A) : A = B :=\n  hA.subset.antisymm hB.subset\n\n"}
{"name":"IsExposed.mono","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA B C : Set E\nhC : IsExposed 𝕜 A C\nhBA : HasSubset.Subset B A\nhCB : HasSubset.Subset C B\n⊢ IsExposed 𝕜 B C","decl":"protected theorem mono (hC : IsExposed 𝕜 A C) (hBA : B ⊆ A) (hCB : C ⊆ B) : IsExposed 𝕜 B C := by\n  rintro ⟨w, hw⟩\n  obtain ⟨l, rfl⟩ := hC ⟨w, hw⟩\n  exact ⟨l, Subset.antisymm (fun x hx => ⟨hCB hx, fun y hy => hx.2 y (hBA hy)⟩) fun x hx =>\n    ⟨hBA hx.1, fun y hy => (hw.2 y hy).trans (hx.2 w (hCB hw))⟩⟩\n\n"}
{"name":"IsExposed.eq_inter_halfSpace'","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA B : Set E\nhAB : IsExposed 𝕜 A B\nhB : B.Nonempty\n⊢ Exists fun l => Exists fun a => Eq B (setOf fun x => And (Membership.mem A x) (LE.le a (l x)))","decl":"/-- If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\nhalf-space. The converse is *not* true. It would require that the corresponding open half-space\ndoesn't intersect `A`. -/\ntheorem eq_inter_halfSpace' {A B : Set E} (hAB : IsExposed 𝕜 A B) (hB : B.Nonempty) :\n    ∃ l : E →L[𝕜] 𝕜, ∃ a, B = { x ∈ A | a ≤ l x } := by\n  obtain ⟨l, rfl⟩ := hAB hB\n  obtain ⟨w, hw⟩ := hB\n  exact ⟨l, l w, Subset.antisymm (fun x hx => ⟨hx.1, hx.2 w hw.1⟩) fun x hx =>\n    ⟨hx.1, fun y hy => (hw.2 y hy).trans hx.2⟩⟩\n"}
{"name":"IsExposed.eq_inter_halfspace'","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA B : Set E\nhAB : IsExposed 𝕜 A B\nhB : B.Nonempty\n⊢ Exists fun l => Exists fun a => Eq B (setOf fun x => And (Membership.mem A x) (LE.le a (l x)))","decl":"@[deprecated (since := \"2024-11-12\")] alias eq_inter_halfspace' := eq_inter_halfSpace'\n\n"}
{"name":"IsExposed.eq_inter_halfSpace","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : TopologicalSpace 𝕜\ninst✝⁴ : OrderedRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : TopologicalSpace E\ninst✝¹ : Module 𝕜 E\ninst✝ : Nontrivial 𝕜\nA B : Set E\nhAB : IsExposed 𝕜 A B\n⊢ Exists fun l => Exists fun a => Eq B (setOf fun x => And (Membership.mem A x) (LE.le a (l x)))","decl":"/-- For nontrivial `𝕜`, if `B` is an exposed subset of `A`, then `B` is the intersection of `A` with\nsome closed half-space. The converse is *not* true. It would require that the corresponding open\nhalf-space doesn't intersect `A`. -/\ntheorem eq_inter_halfSpace [Nontrivial 𝕜] {A B : Set E} (hAB : IsExposed 𝕜 A B) :\n    ∃ l : E →L[𝕜] 𝕜, ∃ a, B = { x ∈ A | a ≤ l x } := by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  · refine ⟨0, 1, ?_⟩\n    rw [eq_comm, eq_empty_iff_forall_not_mem]\n    rintro x ⟨-, h⟩\n    rw [ContinuousLinearMap.zero_apply] at h\n    have : ¬(1 : 𝕜) ≤ 0 := not_le_of_lt zero_lt_one\n    contradiction\n  exact hAB.eq_inter_halfSpace' hB\n"}
{"name":"IsExposed.eq_inter_halfspace","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : TopologicalSpace 𝕜\ninst✝⁴ : OrderedRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : TopologicalSpace E\ninst✝¹ : Module 𝕜 E\ninst✝ : Nontrivial 𝕜\nA B : Set E\nhAB : IsExposed 𝕜 A B\n⊢ Exists fun l => Exists fun a => Eq B (setOf fun x => And (Membership.mem A x) (LE.le a (l x)))","decl":"@[deprecated (since := \"2024-11-12\")] alias eq_inter_halfspace := eq_inter_halfSpace\n\n"}
{"name":"IsExposed.inter","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : TopologicalSpace 𝕜\ninst✝⁴ : OrderedRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : TopologicalSpace E\ninst✝¹ : Module 𝕜 E\ninst✝ : ContinuousAdd 𝕜\nA B C : Set E\nhB : IsExposed 𝕜 A B\nhC : IsExposed 𝕜 A C\n⊢ IsExposed 𝕜 A (Inter.inter B C)","decl":"protected theorem inter [ContinuousAdd 𝕜] {A B C : Set E} (hB : IsExposed 𝕜 A B)\n    (hC : IsExposed 𝕜 A C) : IsExposed 𝕜 A (B ∩ C) := by\n  rintro ⟨w, hwB, hwC⟩\n  obtain ⟨l₁, rfl⟩ := hB ⟨w, hwB⟩\n  obtain ⟨l₂, rfl⟩ := hC ⟨w, hwC⟩\n  refine ⟨l₁ + l₂, Subset.antisymm ?_ ?_⟩\n  · rintro x ⟨⟨hxA, hxB⟩, ⟨-, hxC⟩⟩\n    exact ⟨hxA, fun z hz => add_le_add (hxB z hz) (hxC z hz)⟩\n  rintro x ⟨hxA, hx⟩\n  refine ⟨⟨hxA, fun y hy => ?_⟩, hxA, fun y hy => ?_⟩\n  · exact\n      (add_le_add_iff_right (l₂ x)).1 ((add_le_add (hwB.2 y hy) (hwC.2 x hxA)).trans (hx w hwB.1))\n  · exact\n      (add_le_add_iff_left (l₁ x)).1 (le_trans (add_le_add (hwB.2 x hxA) (hwC.2 y hy)) (hx w hwB.1))\n\n"}
{"name":"IsExposed.sInter","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : TopologicalSpace 𝕜\ninst✝⁴ : OrderedRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : TopologicalSpace E\ninst✝¹ : Module 𝕜 E\nA : Set E\ninst✝ : ContinuousAdd 𝕜\nF : Finset (Set E)\nhF : F.Nonempty\nhAF : ∀ (B : Set E), Membership.mem F B → IsExposed 𝕜 A B\n⊢ IsExposed 𝕜 A (↑F).sInter","decl":"theorem sInter [ContinuousAdd 𝕜] {F : Finset (Set E)} (hF : F.Nonempty)\n    (hAF : ∀ B ∈ F, IsExposed 𝕜 A B) : IsExposed 𝕜 A (⋂₀ F) := by\n  classical\n  induction F using Finset.induction with\n  | empty => exfalso; exact Finset.not_nonempty_empty hF\n  | @insert C F _ hF' =>\n    rw [Finset.coe_insert, sInter_insert]\n    obtain rfl | hFnemp := F.eq_empty_or_nonempty\n    · rw [Finset.coe_empty, sInter_empty, inter_univ]\n      exact hAF C (Finset.mem_singleton_self C)\n    · exact (hAF C (Finset.mem_insert_self C F)).inter\n        (hF' hFnemp fun B hB => hAF B (Finset.mem_insert_of_mem hB))\n\n"}
{"name":"IsExposed.inter_left","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA B C : Set E\nhC : IsExposed 𝕜 A C\nhCB : HasSubset.Subset C B\n⊢ IsExposed 𝕜 (Inter.inter A B) C","decl":"theorem inter_left (hC : IsExposed 𝕜 A C) (hCB : C ⊆ B) : IsExposed 𝕜 (A ∩ B) C := by\n  rintro ⟨w, hw⟩\n  obtain ⟨l, rfl⟩ := hC ⟨w, hw⟩\n  exact ⟨l, Subset.antisymm (fun x hx => ⟨⟨hx.1, hCB hx⟩, fun y hy => hx.2 y hy.1⟩)\n    fun x ⟨⟨hxC, _⟩, hx⟩ => ⟨hxC, fun y hy => (hw.2 y hy).trans (hx w ⟨hC.subset hw, hCB hw⟩)⟩⟩\n\n"}
{"name":"IsExposed.inter_right","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA B C : Set E\nhC : IsExposed 𝕜 B C\nhCA : HasSubset.Subset C A\n⊢ IsExposed 𝕜 (Inter.inter A B) C","decl":"theorem inter_right (hC : IsExposed 𝕜 B C) (hCA : C ⊆ A) : IsExposed 𝕜 (A ∩ B) C := by\n  rw [inter_comm]\n  exact hC.inter_left hCA\n\n"}
{"name":"IsExposed.isClosed","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : TopologicalSpace 𝕜\ninst✝⁴ : OrderedRing 𝕜\ninst✝³ : AddCommMonoid E\ninst✝² : TopologicalSpace E\ninst✝¹ : Module 𝕜 E\ninst✝ : OrderClosedTopology 𝕜\nA B : Set E\nhAB : IsExposed 𝕜 A B\nhA : IsClosed A\n⊢ IsClosed B","decl":"protected theorem isClosed [OrderClosedTopology 𝕜] {A B : Set E} (hAB : IsExposed 𝕜 A B)\n    (hA : IsClosed A) : IsClosed B := by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  · simp\n  obtain ⟨l, a, rfl⟩ := hAB.eq_inter_halfSpace' hB\n  exact hA.isClosed_le continuousOn_const l.continuous.continuousOn\n\n"}
{"name":"IsExposed.isCompact","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁶ : TopologicalSpace 𝕜\ninst✝⁵ : OrderedRing 𝕜\ninst✝⁴ : AddCommMonoid E\ninst✝³ : TopologicalSpace E\ninst✝² : Module 𝕜 E\ninst✝¹ : OrderClosedTopology 𝕜\ninst✝ : T2Space E\nA B : Set E\nhAB : IsExposed 𝕜 A B\nhA : IsCompact A\n⊢ IsCompact B","decl":"protected theorem isCompact [OrderClosedTopology 𝕜] [T2Space E] {A B : Set E}\n    (hAB : IsExposed 𝕜 A B) (hA : IsCompact A) : IsCompact B :=\n  hA.of_isClosed_subset (hAB.isClosed hA.isClosed) hAB.subset\n\n"}
{"name":"exposed_point_def","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA : Set E\nx : E\n⊢ Iff (Membership.mem (Set.exposedPoints 𝕜 A) x) (And (Membership.mem A x) (Exists fun l => ∀ (y : E), Membership.mem A y → And (LE.le (l y) (l x)) (LE.le (l x) (l y) → Eq y x)))","decl":"theorem exposed_point_def :\n    x ∈ A.exposedPoints 𝕜 ↔ x ∈ A ∧ ∃ l : E →L[𝕜] 𝕜, ∀ y ∈ A, l y ≤ l x ∧ (l x ≤ l y → y = x) :=\n  Iff.rfl\n\n"}
{"name":"exposedPoints_subset","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA : Set E\n⊢ HasSubset.Subset (Set.exposedPoints 𝕜 A) A","decl":"theorem exposedPoints_subset : A.exposedPoints 𝕜 ⊆ A := fun _ hx => hx.1\n\n"}
{"name":"exposedPoints_empty","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\n⊢ Eq (Set.exposedPoints 𝕜 EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem exposedPoints_empty : (∅ : Set E).exposedPoints 𝕜 = ∅ :=\n  subset_empty_iff.1 exposedPoints_subset\n\n"}
{"name":"mem_exposedPoints_iff_exposed_singleton","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : OrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA : Set E\nx : E\n⊢ Iff (Membership.mem (Set.exposedPoints 𝕜 A) x) (IsExposed 𝕜 A (Singleton.singleton x))","decl":"/-- Exposed points exactly correspond to exposed singletons. -/\ntheorem mem_exposedPoints_iff_exposed_singleton : x ∈ A.exposedPoints 𝕜 ↔ IsExposed 𝕜 A {x} := by\n  use fun ⟨hxA, l, hl⟩ _ =>\n    ⟨l,\n      Eq.symm <|\n        eq_singleton_iff_unique_mem.2\n          ⟨⟨hxA, fun y hy => (hl y hy).1⟩, fun z hz => (hl z hz.1).2 (hz.2 x hxA)⟩⟩\n  rintro h\n  obtain ⟨l, hl⟩ := h ⟨x, mem_singleton _⟩\n  rw [eq_comm, eq_singleton_iff_unique_mem] at hl\n  exact\n    ⟨hl.1.1, l, fun y hy =>\n      ⟨hl.1.2 y hy, fun hxy => hl.2 y ⟨hy, fun z hz => (hl.1.2 z hz).trans hxy⟩⟩⟩\n\n"}
{"name":"IsExposed.convex","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : LinearOrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA B : Set E\nhAB : IsExposed 𝕜 A B\nhA : Convex 𝕜 A\n⊢ Convex 𝕜 B","decl":"protected theorem convex (hAB : IsExposed 𝕜 A B) (hA : Convex 𝕜 A) : Convex 𝕜 B := by\n  obtain rfl | hB := B.eq_empty_or_nonempty\n  · exact convex_empty\n  obtain ⟨l, rfl⟩ := hAB hB\n  exact fun x₁ hx₁ x₂ hx₂ a b ha hb hab =>\n    ⟨hA hx₁.1 hx₂.1 ha hb hab, fun y hy =>\n      ((l.toLinearMap.concaveOn convex_univ).convex_ge _ ⟨mem_univ _, hx₁.2 y hy⟩\n          ⟨mem_univ _, hx₂.2 y hy⟩ ha hb hab).2⟩\n\n"}
{"name":"IsExposed.isExtreme","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : LinearOrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA B : Set E\nhAB : IsExposed 𝕜 A B\n⊢ IsExtreme 𝕜 A B","decl":"protected theorem isExtreme (hAB : IsExposed 𝕜 A B) : IsExtreme 𝕜 A B := by\n  refine ⟨hAB.subset, fun x₁ hx₁A x₂ hx₂A x hxB hx => ?_⟩\n  obtain ⟨l, rfl⟩ := hAB ⟨x, hxB⟩\n  have hl : ConvexOn 𝕜 univ l := l.toLinearMap.convexOn convex_univ\n  have hlx₁ := hxB.2 x₁ hx₁A\n  have hlx₂ := hxB.2 x₂ hx₂A\n  refine ⟨⟨hx₁A, fun y hy => ?_⟩, ⟨hx₂A, fun y hy => ?_⟩⟩\n  · rw [hlx₁.antisymm (hl.le_left_of_right_le (mem_univ _) (mem_univ _) hx hlx₂)]\n    exact hxB.2 y hy\n  · rw [hlx₂.antisymm (hl.le_right_of_left_le (mem_univ _) (mem_univ _) hx hlx₁)]\n    exact hxB.2 y hy\n\n"}
{"name":"exposedPoints_subset_extremePoints","module":"Mathlib.Analysis.Convex.Exposed","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : LinearOrderedRing 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nA : Set E\n⊢ HasSubset.Subset (Set.exposedPoints 𝕜 A) (Set.extremePoints 𝕜 A)","decl":"theorem exposedPoints_subset_extremePoints : A.exposedPoints 𝕜 ⊆ A.extremePoints 𝕜 := fun _ hx =>\n  (mem_exposedPoints_iff_exposed_singleton.1 hx).isExtreme.mem_extremePoints\n\n"}
