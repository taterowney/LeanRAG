{"name":"Lists'.cons'.injEq","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u\nb✝ : Bool\na✝³ : Lists' α b✝\na✝² : Lists' α Bool.true\nb : Bool\na✝¹ : Lists' α b\na✝ : Lists' α Bool.true\n⊢ Eq (Eq (a✝³.cons' a✝²) (a✝¹.cons' a✝)) (And (Eq b✝ b) (And (HEq a✝³ a✝¹) (Eq a✝² a✝)))","decl":"/-- Prelists, helper type to define `Lists`. `Lists' α false` are the \"atoms\", a copy of `α`.\n`Lists' α true` are the \"proper\" ZFA prelists, inductively defined from the empty ZFA prelist and\nfrom appending a ZFA prelist to a proper ZFA prelist. It is made so that you can't append anything\nto an atom while having only one appending function for appending both atoms and proper ZFC prelists\nto a proper ZFA prelist. -/\ninductive Lists'.{u} (α : Type u) : Bool → Type u\n  | atom : α → Lists' α false\n  | nil : Lists' α true\n  | cons' {b} : Lists' α b → Lists' α true → Lists' α true\n  deriving DecidableEq\n"}
{"name":"Lists'.cons'.inj","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u\nb✝ : Bool\na✝³ : Lists' α b✝\na✝² : Lists' α Bool.true\nb : Bool\na✝¹ : Lists' α b\na✝ : Lists' α Bool.true\nx✝ : Eq (a✝³.cons' a✝²) (a✝¹.cons' a✝)\n⊢ And (Eq b✝ b) (And (HEq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- Prelists, helper type to define `Lists`. `Lists' α false` are the \"atoms\", a copy of `α`.\n`Lists' α true` are the \"proper\" ZFA prelists, inductively defined from the empty ZFA prelist and\nfrom appending a ZFA prelist to a proper ZFA prelist. It is made so that you can't append anything\nto an atom while having only one appending function for appending both atoms and proper ZFC prelists\nto a proper ZFA prelist. -/\ninductive Lists'.{u} (α : Type u) : Bool → Type u\n  | atom : α → Lists' α false\n  | nil : Lists' α true\n  | cons' {b} : Lists' α b → Lists' α true → Lists' α true\n  deriving DecidableEq\n"}
{"name":"Lists'.nil.sizeOf_spec","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u\ninst✝ : SizeOf α\n⊢ Eq (SizeOf.sizeOf Lists'.nil) 1","decl":"/-- Prelists, helper type to define `Lists`. `Lists' α false` are the \"atoms\", a copy of `α`.\n`Lists' α true` are the \"proper\" ZFA prelists, inductively defined from the empty ZFA prelist and\nfrom appending a ZFA prelist to a proper ZFA prelist. It is made so that you can't append anything\nto an atom while having only one appending function for appending both atoms and proper ZFC prelists\nto a proper ZFA prelist. -/\ninductive Lists'.{u} (α : Type u) : Bool → Type u\n  | atom : α → Lists' α false\n  | nil : Lists' α true\n  | cons' {b} : Lists' α b → Lists' α true → Lists' α true\n  deriving DecidableEq\n"}
{"name":"Lists'.cons'.sizeOf_spec","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u\ninst✝ : SizeOf α\nb : Bool\na✝¹ : Lists' α b\na✝ : Lists' α Bool.true\n⊢ Eq (SizeOf.sizeOf (a✝¹.cons' a✝)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf b)) (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- Prelists, helper type to define `Lists`. `Lists' α false` are the \"atoms\", a copy of `α`.\n`Lists' α true` are the \"proper\" ZFA prelists, inductively defined from the empty ZFA prelist and\nfrom appending a ZFA prelist to a proper ZFA prelist. It is made so that you can't append anything\nto an atom while having only one appending function for appending both atoms and proper ZFC prelists\nto a proper ZFA prelist. -/\ninductive Lists'.{u} (α : Type u) : Bool → Type u\n  | atom : α → Lists' α false\n  | nil : Lists' α true\n  | cons' {b} : Lists' α b → Lists' α true → Lists' α true\n  deriving DecidableEq\n"}
{"name":"Lists'.atom.injEq","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u\na✝¹ a✝ : α\n⊢ Eq (Eq (Lists'.atom a✝¹) (Lists'.atom a✝)) (Eq a✝¹ a✝)","decl":"/-- Prelists, helper type to define `Lists`. `Lists' α false` are the \"atoms\", a copy of `α`.\n`Lists' α true` are the \"proper\" ZFA prelists, inductively defined from the empty ZFA prelist and\nfrom appending a ZFA prelist to a proper ZFA prelist. It is made so that you can't append anything\nto an atom while having only one appending function for appending both atoms and proper ZFC prelists\nto a proper ZFA prelist. -/\ninductive Lists'.{u} (α : Type u) : Bool → Type u\n  | atom : α → Lists' α false\n  | nil : Lists' α true\n  | cons' {b} : Lists' α b → Lists' α true → Lists' α true\n  deriving DecidableEq\n"}
{"name":"Lists'.atom.sizeOf_spec","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u\ninst✝ : SizeOf α\na✝ : α\n⊢ Eq (SizeOf.sizeOf (Lists'.atom a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- Prelists, helper type to define `Lists`. `Lists' α false` are the \"atoms\", a copy of `α`.\n`Lists' α true` are the \"proper\" ZFA prelists, inductively defined from the empty ZFA prelist and\nfrom appending a ZFA prelist to a proper ZFA prelist. It is made so that you can't append anything\nto an atom while having only one appending function for appending both atoms and proper ZFC prelists\nto a proper ZFA prelist. -/\ninductive Lists'.{u} (α : Type u) : Bool → Type u\n  | atom : α → Lists' α false\n  | nil : Lists' α true\n  | cons' {b} : Lists' α b → Lists' α true → Lists' α true\n  deriving DecidableEq\n"}
{"name":"Lists'.atom.inj","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u\na✝¹ a✝ : α\nx✝ : Eq (Lists'.atom a✝¹) (Lists'.atom a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- Prelists, helper type to define `Lists`. `Lists' α false` are the \"atoms\", a copy of `α`.\n`Lists' α true` are the \"proper\" ZFA prelists, inductively defined from the empty ZFA prelist and\nfrom appending a ZFA prelist to a proper ZFA prelist. It is made so that you can't append anything\nto an atom while having only one appending function for appending both atoms and proper ZFC prelists\nto a proper ZFA prelist. -/\ninductive Lists'.{u} (α : Type u) : Bool → Type u\n  | atom : α → Lists' α false\n  | nil : Lists' α true\n  | cons' {b} : Lists' α b → Lists' α true → Lists' α true\n  deriving DecidableEq\n"}
{"name":"Lists'.toList_cons","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\na : Lists α\nl : Lists' α Bool.true\n⊢ Eq (Lists'.cons a l).toList (List.cons a l.toList)","decl":"@[simp]\ntheorem toList_cons (a : Lists α) (l) : toList (cons a l) = a :: l.toList := rfl\n\n"}
{"name":"Lists'.to_ofList","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl : List (Lists α)\n⊢ Eq (Lists'.ofList l).toList l","decl":"@[simp]\ntheorem to_ofList (l : List (Lists α)) : toList (ofList l) = l := by induction l <;> simp [*]\n\n"}
{"name":"Lists'.of_toList","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl : Lists' α Bool.true\n⊢ Eq (Lists'.ofList l.toList) l","decl":"@[simp]\ntheorem of_toList : ∀ l : Lists' α true, ofList (toList l) = l :=\n  suffices\n    ∀ (b) (h : true = b) (l : Lists' α b),\n      let l' : Lists' α true := by rw [h]; exact l\n      ofList (toList l') = l'\n    from this _ rfl\n  fun b h l => by\n    induction l with\n    | atom => cases h\n    | nil => simp\n    | cons' b a _ IH => simpa [cons] using IH rfl\n\n"}
{"name":"Lists'.mem_def","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nb : Bool\na : Lists α\nl : Lists' α b\n⊢ Iff (Membership.mem l a) (Exists fun a' => And (Membership.mem l.toList a') (a.Equiv a'))","decl":"theorem mem_def {b a} {l : Lists' α b} : a ∈ l ↔ ∃ a' ∈ l.toList, a ~ a' :=\n  Iff.rfl\n\n"}
{"name":"Lists'.mem_cons","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\na y : Lists α\nl : Lists' α Bool.true\n⊢ Iff (Membership.mem (Lists'.cons y l) a) (Or (a.Equiv y) (Membership.mem l a))","decl":"@[simp]\ntheorem mem_cons {a y l} : a ∈ @cons α y l ↔ a ~ y ∨ a ∈ l := by\n  simp [mem_def, or_and_right, exists_or]\n\n"}
{"name":"Lists'.cons_subset","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\na : Lists α\nl₁ l₂ : Lists' α Bool.true\n⊢ Iff (HasSubset.Subset (Lists'.cons a l₁) l₂) (And (Membership.mem l₂ a) (HasSubset.Subset l₁ l₂))","decl":"theorem cons_subset {a} {l₁ l₂ : Lists' α true} : Lists'.cons a l₁ ⊆ l₂ ↔ a ∈ l₂ ∧ l₁ ⊆ l₂ := by\n  refine ⟨fun h => ?_, fun ⟨⟨a', m, e⟩, s⟩ => Subset.cons e m s⟩\n  generalize h' : Lists'.cons a l₁ = l₁' at h\n  cases' h with l a' a'' l l' e m s\n  · cases a\n    cases h'\n  cases a; cases a'; cases h'; exact ⟨⟨_, m, e⟩, s⟩\n\n"}
{"name":"Lists'.ofList_subset","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl₁ l₂ : List (Lists α)\nh : HasSubset.Subset l₁ l₂\n⊢ HasSubset.Subset (Lists'.ofList l₁) (Lists'.ofList l₂)","decl":"theorem ofList_subset {l₁ l₂ : List (Lists α)} (h : l₁ ⊆ l₂) :\n    Lists'.ofList l₁ ⊆ Lists'.ofList l₂ := by\n  induction l₁ with\n  | nil => exact Subset.nil\n  | cons _ _ l₁_ih =>\n    refine Subset.cons (Lists.Equiv.refl _) ?_ (l₁_ih (List.subset_of_cons_subset h))\n    simp only [List.cons_subset] at h; simp [h]\n\n"}
{"name":"Lists'.Subset.refl","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl : Lists' α Bool.true\n⊢ HasSubset.Subset l l","decl":"@[refl]\ntheorem Subset.refl {l : Lists' α true} : l ⊆ l := by\n  rw [← Lists'.of_toList l]; exact ofList_subset (List.Subset.refl _)\n\n"}
{"name":"Lists'.subset_nil","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl : Lists' α Bool.true\na✝ : HasSubset.Subset l Lists'.nil\n⊢ Eq l Lists'.nil","decl":"theorem subset_nil {l : Lists' α true} : l ⊆ Lists'.nil → l = Lists'.nil := by\n  rw [← of_toList l]\n  induction toList l <;> intro h\n  · rfl\n  · rcases cons_subset.1 h with ⟨⟨_, ⟨⟩, _⟩, _⟩\n\n"}
{"name":"Lists'.mem_of_subset'","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\na : Lists α\nl₁ l₂ : Lists' α Bool.true\nx✝¹ : HasSubset.Subset l₁ l₂\nx✝ : Membership.mem l₁.toList a\n⊢ Membership.mem l₂ a","decl":"theorem mem_of_subset' {a} : ∀ {l₁ l₂ : Lists' α true} (_ : l₁ ⊆ l₂) (_ : a ∈ l₁.toList), a ∈ l₂\n  | nil, _, Lists'.Subset.nil, h => by cases h\n  | cons' a0 l0, l₂, s, h => by\n    cases' s with _ _ _ _ _ e m s\n    simp only [toList, Sigma.eta, List.find?, List.mem_cons] at h\n    rcases h with (rfl | h)\n    · exact ⟨_, m, e⟩\n    · exact mem_of_subset' s h\n\n"}
{"name":"Lists'.subset_def","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl₁ l₂ : Lists' α Bool.true\n⊢ Iff (HasSubset.Subset l₁ l₂) (∀ (a : Lists α), Membership.mem l₁.toList a → Membership.mem l₂ a)","decl":"theorem subset_def {l₁ l₂ : Lists' α true} : l₁ ⊆ l₂ ↔ ∀ a ∈ l₁.toList, a ∈ l₂ :=\n  ⟨fun H _ => mem_of_subset' H, fun H => by\n    rw [← of_toList l₁]\n    revert H; induction' toList l₁ with h t t_ih <;> intro H\n    · exact Subset.nil\n    · simp only [ofList, List.find?, List.mem_cons, forall_eq_or_imp] at *\n      exact cons_subset.2 ⟨H.1, t_ih H.2⟩⟩\n\n"}
{"name":"Lists.isList_toList","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl : List (Lists α)\n⊢ (Lists.ofList l).IsList","decl":"theorem isList_toList (l : List (Lists α)) : IsList (ofList l) :=\n  Eq.refl _\n\n"}
{"name":"Lists.to_ofList","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl : List (Lists α)\n⊢ Eq (Lists.ofList l).toList l","decl":"theorem to_ofList (l : List (Lists α)) : toList (ofList l) = l := by simp [ofList, of']\n\n"}
{"name":"Lists.of_toList","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl : Lists α\na✝ : l.IsList\n⊢ Eq (Lists.ofList l.toList) l","decl":"theorem of_toList : ∀ {l : Lists α}, IsList l → ofList (toList l) = l\n  | ⟨true, l⟩, _ => by simp_all [ofList, of']\n\n"}
{"name":"Lists.isList_of_mem","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\na l : Lists α\na✝ : Membership.mem l a\n⊢ l.IsList","decl":"theorem isList_of_mem {a : Lists α} : ∀ {l : Lists α}, a ∈ l → IsList l\n  | ⟨_, Lists'.nil⟩, _ => rfl\n  | ⟨_, Lists'.cons' _ _⟩, _ => rfl\n\n"}
{"name":"Lists.Equiv.antisymm_iff","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl₁ l₂ : Lists' α Bool.true\n⊢ Iff ((Lists.of' l₁).Equiv (Lists.of' l₂)) (And (HasSubset.Subset l₁ l₂) (HasSubset.Subset l₂ l₁))","decl":"theorem Equiv.antisymm_iff {l₁ l₂ : Lists' α true} : of' l₁ ~ of' l₂ ↔ l₁ ⊆ l₂ ∧ l₂ ⊆ l₁ := by\n  refine ⟨fun h => ?_, fun ⟨h₁, h₂⟩ => Equiv.antisymm h₁ h₂⟩\n  cases' h with _ _ _ h₁ h₂\n  · simp [Lists'.Subset.refl]\n  · exact ⟨h₁, h₂⟩\n\n"}
{"name":"Lists.equiv_atom","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\na : α\nl : Lists α\n⊢ Iff ((Lists.atom a).Equiv l) (Eq (Lists.atom a) l)","decl":"theorem equiv_atom {a} {l : Lists α} : atom a ~ l ↔ atom a = l :=\n  ⟨fun h => by cases h; rfl, fun h => h ▸ Equiv.refl _⟩\n\n"}
{"name":"Lists.Equiv.symm","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl₁ l₂ : Lists α\nh : l₁.Equiv l₂\n⊢ l₂.Equiv l₁","decl":"@[symm]\ntheorem Equiv.symm {l₁ l₂ : Lists α} (h : l₁ ~ l₂) : l₂ ~ l₁ := by\n  cases' h with _ _ _ h₁ h₂ <;> [rfl; exact Equiv.antisymm h₂ h₁]\n\n"}
{"name":"Lists.Equiv.trans","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl₁ l₂ l₃ : Lists α\na✝¹ : l₁.Equiv l₂\na✝ : l₂.Equiv l₃\n⊢ l₁.Equiv l₃","decl":"theorem Equiv.trans : ∀ {l₁ l₂ l₃ : Lists α}, l₁ ~ l₂ → l₂ ~ l₃ → l₁ ~ l₃ := by\n  let trans := fun l₁ : Lists α => ∀ ⦃l₂ l₃⦄, l₁ ~ l₂ → l₂ ~ l₃ → l₁ ~ l₃\n  suffices PProd (∀ l₁, trans l₁) (∀ (l : Lists' α true), ∀ l' ∈ l.toList, trans l') by exact this.1\n  apply inductionMut\n  · intro a l₂ l₃ h₁ h₂\n    rwa [← equiv_atom.1 h₁] at h₂\n  · intro l₁ IH l₂ l₃ h₁ h₂\n    cases' id h₁ with _ _ l₂\n    · exact h₂\n    cases' id h₂ with _ _ l₃\n    · exact h₁\n    cases' Equiv.antisymm_iff.1 h₁ with hl₁ hr₁\n    cases' Equiv.antisymm_iff.1 h₂ with hl₂ hr₂\n    apply Equiv.antisymm_iff.2; constructor <;> apply Lists'.subset_def.2\n    · intro a₁ m₁\n      rcases Lists'.mem_of_subset' hl₁ m₁ with ⟨a₂, m₂, e₁₂⟩\n      rcases Lists'.mem_of_subset' hl₂ m₂ with ⟨a₃, m₃, e₂₃⟩\n      exact ⟨a₃, m₃, IH _ m₁ e₁₂ e₂₃⟩\n    · intro a₃ m₃\n      rcases Lists'.mem_of_subset' hr₂ m₃ with ⟨a₂, m₂, e₃₂⟩\n      rcases Lists'.mem_of_subset' hr₁ m₂ with ⟨a₁, m₁, e₂₁⟩\n      exact ⟨a₁, m₁, (IH _ m₁ e₂₁.symm e₃₂.symm).symm⟩\n  · rintro _ ⟨⟩\n  · intro a l IH₁ IH₂\n    simpa using ⟨IH₁, IH₂⟩\n\n"}
{"name":"Lists.sizeof_pos","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nb : Bool\nl : Lists' α b\n⊢ LT.lt 0 (SizeOf.sizeOf l)","decl":"theorem sizeof_pos {b} (l : Lists' α b) : 0 < SizeOf.sizeOf l := by\n  cases l <;> simp only [Lists'.atom.sizeOf_spec, Lists'.nil.sizeOf_spec, Lists'.cons'.sizeOf_spec,\n    true_or, add_pos_iff, zero_lt_one]\n\n"}
{"name":"Lists.lt_sizeof_cons'","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nb : Bool\na : Lists' α b\nl : Lists' α Bool.true\n⊢ LT.lt (SizeOf.sizeOf ⟨b, a⟩) (SizeOf.sizeOf (a.cons' l))","decl":"theorem lt_sizeof_cons' {b} (a : Lists' α b) (l) :\n    SizeOf.sizeOf (⟨b, a⟩ : Lists α) < SizeOf.sizeOf (Lists'.cons' a l) := by\n  simp only [Sigma.mk.sizeOf_spec, Lists'.cons'.sizeOf_spec, lt_add_iff_pos_right]\n  apply sizeof_pos\n\n"}
{"name":"Lists'.mem_equiv_left","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl : Lists' α Bool.true\na a' : Lists α\na✝ : a.Equiv a'\n⊢ Iff (Membership.mem l a) (Membership.mem l a')","decl":"theorem mem_equiv_left {l : Lists' α true} : ∀ {a a'}, a ~ a' → (a ∈ l ↔ a' ∈ l) :=\n  suffices ∀ {a a'}, a ~ a' → a ∈ l → a' ∈ l from fun e => ⟨this e, this e.symm⟩\n  fun e₁ ⟨_, m₃, e₂⟩ => ⟨_, m₃, e₁.symm.trans e₂⟩\n\n"}
{"name":"Lists'.mem_of_subset","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\na : Lists α\nl₁ l₂ : Lists' α Bool.true\ns : HasSubset.Subset l₁ l₂\na✝ : Membership.mem l₁ a\n⊢ Membership.mem l₂ a","decl":"theorem mem_of_subset {a} {l₁ l₂ : Lists' α true} (s : l₁ ⊆ l₂) : a ∈ l₁ → a ∈ l₂\n  | ⟨_, m, e⟩ => (mem_equiv_left e).2 (mem_of_subset' s m)\n\n"}
{"name":"Lists'.Subset.trans","module":"Mathlib.SetTheory.Lists","initialProofState":"α : Type u_1\nl₁ l₂ l₃ : Lists' α Bool.true\nh₁ : HasSubset.Subset l₁ l₂\nh₂ : HasSubset.Subset l₂ l₃\n⊢ HasSubset.Subset l₁ l₃","decl":"theorem Subset.trans {l₁ l₂ l₃ : Lists' α true} (h₁ : l₁ ⊆ l₂) (h₂ : l₂ ⊆ l₃) : l₁ ⊆ l₃ :=\n  subset_def.2 fun _ m₁ => mem_of_subset h₂ <| mem_of_subset' h₁ m₁\n\n"}
