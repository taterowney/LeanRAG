{"name":"Int.addSubmonoid_closure_range_pow","module":"Mathlib.Data.Int.Star","initialProofState":"n : Nat\nhn : Even n\n⊢ Eq (AddSubmonoid.closure (Set.range fun x => HPow.hPow x n)) (AddSubmonoid.nonneg Int)","decl":"@[simp] lemma addSubmonoid_closure_range_pow {n : ℕ} (hn : Even n) :\n    closure (range fun x : ℤ ↦ x ^ n) = nonneg _ := by\n  refine le_antisymm (closure_le.2 <| range_subset_iff.2 hn.pow_nonneg) fun x hx ↦ ?_\n  have : x = x.natAbs • 1 ^ n := by simpa [eq_comm (a := x)] using hx\n  rw [this]\n  exact nsmul_mem (subset_closure <| mem_range_self _) _\n\n"}
{"name":"Int.addSubmonoid_closure_range_mul_self","module":"Mathlib.Data.Int.Star","initialProofState":"⊢ Eq (AddSubmonoid.closure (Set.range fun x => HMul.hMul x x)) (AddSubmonoid.nonneg Int)","decl":"@[simp]\nlemma addSubmonoid_closure_range_mul_self : closure (range fun x : ℤ ↦ x * x) = nonneg _ := by\n  simpa only [sq] using addSubmonoid_closure_range_pow even_two\n\n"}
{"name":"Int.instStarOrderedRing","module":"Mathlib.Data.Int.Star","initialProofState":"⊢ StarOrderedRing Int","decl":"instance instStarOrderedRing : StarOrderedRing ℤ where\n  le_iff a b := by simp [eq_comm, le_iff_exists_nonneg_add (a := a)]\n\n"}
