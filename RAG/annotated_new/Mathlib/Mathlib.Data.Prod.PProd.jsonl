{"name":"PProd.mk.eta","module":"Mathlib.Data.Prod.PProd","initialProofState":"α : Sort u_1\nβ : Sort u_2\np : PProd α β\n⊢ Eq { fst := p.fst, snd := p.snd } p","decl":"@[simp]\ntheorem mk.eta {p : PProd α β} : PProd.mk p.1 p.2 = p :=\n  rfl\n\n"}
{"name":"PProd.forall","module":"Mathlib.Data.Prod.PProd","initialProofState":"α : Sort u_1\nβ : Sort u_2\np : PProd α β → Prop\n⊢ Iff (∀ (x : PProd α β), p x) (∀ (a : α) (b : β), p { fst := a, snd := b })","decl":"@[simp]\ntheorem «forall» {p : PProd α β → Prop} : (∀ x, p x) ↔ ∀ a b, p ⟨a, b⟩ :=\n  ⟨fun h a b ↦ h ⟨a, b⟩, fun h ⟨a, b⟩ ↦ h a b⟩\n\n"}
{"name":"PProd.exists","module":"Mathlib.Data.Prod.PProd","initialProofState":"α : Sort u_1\nβ : Sort u_2\np : PProd α β → Prop\n⊢ Iff (Exists fun x => p x) (Exists fun a => Exists fun b => p { fst := a, snd := b })","decl":"@[simp]\ntheorem «exists» {p : PProd α β → Prop} : (∃ x, p x) ↔ ∃ a b, p ⟨a, b⟩ :=\n  ⟨fun ⟨⟨a, b⟩, h⟩ ↦ ⟨a, b, h⟩, fun ⟨a, b, h⟩ ↦ ⟨⟨a, b⟩, h⟩⟩\n\n"}
{"name":"PProd.forall'","module":"Mathlib.Data.Prod.PProd","initialProofState":"α : Sort u_1\nβ : Sort u_2\np : α → β → Prop\n⊢ Iff (∀ (x : PProd α β), p x.fst x.snd) (∀ (a : α) (b : β), p a b)","decl":"theorem forall' {p : α → β → Prop} : (∀ x : PProd α β, p x.1 x.2) ↔ ∀ a b, p a b :=\n  PProd.forall\n\n"}
{"name":"PProd.exists'","module":"Mathlib.Data.Prod.PProd","initialProofState":"α : Sort u_1\nβ : Sort u_2\np : α → β → Prop\n⊢ Iff (Exists fun x => p x.fst x.snd) (Exists fun a => Exists fun b => p a b)","decl":"theorem exists' {p : α → β → Prop} : (∃ x : PProd α β, p x.1 x.2) ↔ ∃ a b, p a b :=\n  PProd.exists\n\n"}
{"name":"Function.Injective.pprod_map","module":"Mathlib.Data.Prod.PProd","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nδ : Sort u_4\nf : α → β\ng : γ → δ\nhf : Function.Injective f\nhg : Function.Injective g\n⊢ Function.Injective fun x => { fst := f x.fst, snd := g x.snd }","decl":"theorem Function.Injective.pprod_map {f : α → β} {g : γ → δ} (hf : Injective f) (hg : Injective g) :\n    Injective (fun x ↦ ⟨f x.1, g x.2⟩ : PProd α γ → PProd β δ) := fun _ _ h ↦\n  have A := congr_arg PProd.fst h\n  have B := congr_arg PProd.snd h\n  congr_arg₂ PProd.mk (hf A) (hg B)\n"}
