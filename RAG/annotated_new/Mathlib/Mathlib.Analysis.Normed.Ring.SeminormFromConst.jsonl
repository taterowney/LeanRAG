{"name":"seminormFromConst_seq_def","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nx : R\n‚ä¢ Eq (seminormFromConst_seq c f x) fun n => HDiv.hDiv (f (HMul.hMul x (HPow.hPow c n))) (HPow.hPow (f c) n)","decl":"lemma seminormFromConst_seq_def (x : R) :\n    seminormFromConst_seq c f x = fun n ‚Ü¶ f (x * c ^ n) / f c ^ n := rfl\n\n"}
{"name":"seminormFromConst_seq_nonneg","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nx : R\n‚ä¢ LE.le 0 (seminormFromConst_seq c f x)","decl":"/-- The terms in the sequence `seminormFromConst_seq c f x` are nonnegative. -/\ntheorem seminormFromConst_seq_nonneg (x : R) : 0 ‚â§ seminormFromConst_seq c f x :=\n  fun n ‚Ü¶ div_nonneg (apply_nonneg f (x * c ^ n)) (pow_nonneg (apply_nonneg f c) n)\n\n"}
{"name":"seminormFromConst_bddBelow","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nx : R\n‚ä¢ BddBelow (Set.range (seminormFromConst_seq c f x))","decl":"/-- The image of `seminormFromConst_seq c f x` is bounded below by zero. -/\ntheorem seminormFromConst_bddBelow (x : R) :\n    BddBelow (Set.range (seminormFromConst_seq c f x)) := by\n  use 0\n  rintro r ‚ü®n, rfl‚ü©\n  exact seminormFromConst_seq_nonneg c f x n\n\n"}
{"name":"seminormFromConst_seq_zero","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhf : Eq (f 0) 0\n‚ä¢ Eq (seminormFromConst_seq c f 0) 0","decl":"/-- `seminormFromConst_seq c f 0` is the constant sequence zero. -/\ntheorem seminormFromConst_seq_zero (hf : f 0 = 0) : seminormFromConst_seq c f 0 = 0 := by\n  rw [seminormFromConst_seq_def]\n  ext n\n  rw [zero_mul, hf, zero_div, Pi.zero_apply]\n\n"}
{"name":"seminormFromConst_seq_one","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhc : Ne (f c) 0\nhpm : IsPowMul ‚áëf\nn : Nat\nhn : LE.le 1 n\n‚ä¢ Eq (seminormFromConst_seq c f 1 n) 1","decl":"/-- If `1 ‚â§ n`, then `seminormFromConst_seq c f 1 n = 1`. -/\ntheorem seminormFromConst_seq_one (n : ‚Ñï) (hn : 1 ‚â§ n) : seminormFromConst_seq c f 1 n = 1 := by\n  simp only [seminormFromConst_seq]\n  rw [one_mul, hpm _ hn, div_self (pow_ne_zero n hc)]\n\n"}
{"name":"seminormFromConst_seq_antitone","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : LE.le (f 1) 1\nhc : Ne (f c) 0\nhpm : IsPowMul ‚áëf\nx : R\n‚ä¢ Antitone (seminormFromConst_seq c f x)","decl":"/-- `seminormFromConst_seq c f x` is antitone. -/\ntheorem seminormFromConst_seq_antitone (x : R) : Antitone (seminormFromConst_seq c f x) := by\n  intro m n hmn\n  simp only [seminormFromConst_seq]\n  nth_rw 1 [‚Üê Nat.add_sub_of_le hmn]\n  rw [pow_add, ‚Üê mul_assoc]\n  have hc_pos : 0 < f c := lt_of_le_of_ne (apply_nonneg f _) hc.symm\n  apply le_trans ((div_le_div_iff_of_pos_right (pow_pos hc_pos _)).mpr (map_mul_le_mul f _ _))\n  by_cases heq : m = n\n  ¬∑ have hnm : n - m = 0 := by rw [heq, Nat.sub_self n]\n    rw [hnm, heq, div_le_div_iff_of_pos_right (pow_pos hc_pos _), pow_zero]\n    conv_rhs => rw [‚Üê mul_one (f (x * c ^ n))]\n    exact mul_le_mul_of_nonneg_left hf1 (apply_nonneg f _)\n  ¬∑ have h1 : 1 ‚â§ n - m := by\n      rw [Nat.one_le_iff_ne_zero, ne_eq, Nat.sub_eq_zero_iff_le, not_le]\n      exact lt_of_le_of_ne hmn heq\n    rw [hpm c h1, mul_div_assoc, div_eq_mul_inv, pow_sub‚ÇÄ _ hc hmn, mul_assoc, mul_comm (f c ^ m)‚Åª¬π,\n      ‚Üê mul_assoc (f c ^ n), mul_inv_cancel‚ÇÄ (pow_ne_zero n hc), one_mul, div_eq_mul_inv]\n\n"}
{"name":"seminormFromConst_isLimit","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : LE.le (f 1) 1\nhc : Ne (f c) 0\nhpm : IsPowMul ‚áëf\nx : R\n‚ä¢ Filter.Tendsto (seminormFromConst_seq c f x) Filter.atTop (nhds (seminormFromConst' hf1 hc hpm x))","decl":"/-- We prove that `seminormFromConst' hf1 hc hpm x` is the limit of the sequence\n  `seminormFromConst_seq c f x` as `n` tends to infinity. -/\ntheorem seminormFromConst_isLimit (x : R) :\n    Tendsto (seminormFromConst_seq c f x) atTop (ùìù (seminormFromConst' hf1 hc hpm x)) :=\n  (Real.tendsto_of_bddBelow_antitone (seminormFromConst_bddBelow c f x)\n      (seminormFromConst_seq_antitone hf1 hc hpm x)).choose_spec\n\n"}
{"name":"seminormFromConst_one","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : LE.le (f 1) 1\nhc : Ne (f c) 0\nhpm : IsPowMul ‚áëf\n‚ä¢ Eq (seminormFromConst' hf1 hc hpm 1) 1","decl":"/-- `seminormFromConst' hf1 hc hpm 1 = 1`. -/\ntheorem seminormFromConst_one : seminormFromConst' hf1 hc hpm 1 = 1 := by\n  apply tendsto_nhds_unique_of_eventuallyEq (seminormFromConst_isLimit hf1 hc hpm 1)\n    tendsto_const_nhds\n  simp only [EventuallyEq, eventually_atTop, ge_iff_le]\n  exact ‚ü®1, seminormFromConst_seq_one hc hpm‚ü©\n\n"}
{"name":"seminormFromConst_def","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : LE.le (f 1) 1\nhc : Ne (f c) 0\nhpm : IsPowMul ‚áëf\nx : R\n‚ä¢ Eq ((seminormFromConst hf1 hc hpm) x) (seminormFromConst' hf1 hc hpm x)","decl":"theorem seminormFromConst_def (x : R) :\n    seminormFromConst hf1 hc hpm x = seminormFromConst' hf1 hc hpm x :=\n  rfl\n\n"}
{"name":"seminormFromConst_one_le","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : LE.le (f 1) 1\nhc : Ne (f c) 0\nhpm : IsPowMul ‚áëf\n‚ä¢ LE.le (seminormFromConst' hf1 hc hpm 1) 1","decl":"/-- `seminormFromConst' hf1 hc hpm 1 ‚â§ 1`. -/\ntheorem seminormFromConst_one_le : seminormFromConst' hf1 hc hpm 1 ‚â§ 1 :=\n  le_of_eq (seminormFromConst_one hf1 hc hpm)\n\n"}
{"name":"seminormFromConst_isNonarchimedean","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : LE.le (f 1) 1\nhc : Ne (f c) 0\nhpm : IsPowMul ‚áëf\nhna : IsNonarchimedean ‚áëf\n‚ä¢ IsNonarchimedean (seminormFromConst' hf1 hc hpm)","decl":"/-- The function `seminormFromConst' hf1 hc hpm` is nonarchimedean. -/\ntheorem seminormFromConst_isNonarchimedean (hna : IsNonarchimedean f) :\n    IsNonarchimedean (seminormFromConst' hf1 hc hpm) := fun x y ‚Ü¶ by\n  apply le_of_tendsto_of_tendsto' (seminormFromConst_isLimit hf1 hc hpm (x + y))\n    ((seminormFromConst_isLimit hf1 hc hpm x).max (seminormFromConst_isLimit hf1 hc hpm y))\n  intro n\n  have hmax : f ((x + y) * c ^ n) ‚â§ max (f (x * c ^ n)) (f (y * c ^ n)) := by\n    simp only [add_mul, hna _ _]\n  rw [le_max_iff] at hmax ‚ä¢\n  unfold seminormFromConst_seq\n  apply hmax.imp <;> intro <;> gcongr\n\n"}
{"name":"seminormFromConst_isPowMul","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : LE.le (f 1) 1\nhc : Ne (f c) 0\nhpm : IsPowMul ‚áëf\n‚ä¢ IsPowMul (seminormFromConst' hf1 hc hpm)","decl":"/-- The function `seminormFromConst' hf1 hc hpm` is power-multiplicative. -/\ntheorem seminormFromConst_isPowMul : IsPowMul (seminormFromConst' hf1 hc hpm) := fun x m hm ‚Ü¶ by\n  simp only [seminormFromConst']\n  have hlim : Tendsto (fun n ‚Ü¶ seminormFromConst_seq c f (x ^ m) (m * n)) atTop\n      (ùìù (seminormFromConst' hf1 hc hpm (x ^ m))) := by\n    apply (seminormFromConst_isLimit hf1 hc hpm (x ^ m)).comp\n      (tendsto_atTop_atTop_of_monotone (fun _ _ hnk ‚Ü¶ mul_le_mul_left' hnk m) _)\n    rintro n; use n; exact le_mul_of_one_le_left' hm\n  apply tendsto_nhds_unique hlim\n  convert (seminormFromConst_isLimit hf1 hc hpm x).pow m using 1\n  ext n\n  simp only [seminormFromConst_seq, div_pow, ‚Üê hpm _ hm, ‚Üê pow_mul, mul_pow, mul_comm m n]\n\n"}
{"name":"seminormFromConst_le_seminorm","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : LE.le (f 1) 1\nhc : Ne (f c) 0\nhpm : IsPowMul ‚áëf\nx : R\n‚ä¢ LE.le (seminormFromConst' hf1 hc hpm x) (f x)","decl":"/-- The function `seminormFromConst' hf1 hc hpm` is bounded above by `x`. -/\ntheorem seminormFromConst_le_seminorm (x : R) : seminormFromConst' hf1 hc hpm x ‚â§ f x := by\n  apply le_of_tendsto (seminormFromConst_isLimit hf1 hc hpm x)\n  simp only [eventually_atTop, ge_iff_le]\n  use 1\n  intro n hn\n  rw [seminormFromConst_seq, div_le_iff‚ÇÄ (by positivity), ‚Üê hpm c hn]\n  exact map_mul_le_mul ..\n\n"}
{"name":"seminormFromConst_apply_of_isMul","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : LE.le (f 1) 1\nhc : Ne (f c) 0\nhpm : IsPowMul ‚áëf\nx : R\nhx : ‚àÄ (y : R), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n‚ä¢ Eq (seminormFromConst' hf1 hc hpm x) (f x)","decl":"/-- If `x : R` is multiplicative for `f`, then `seminormFromConst' hf1 hc hpm x = f x`. -/\ntheorem seminormFromConst_apply_of_isMul {x : R} (hx : ‚àÄ y : R, f (x * y) = f x * f y) :\n    seminormFromConst' hf1 hc hpm x = f x :=\n  have hlim : Tendsto (seminormFromConst_seq c f x) atTop (ùìù (f x)) := by\n    have hseq : seminormFromConst_seq c f x = fun _n ‚Ü¶ f x := by\n      ext n\n      by_cases hn : n = 0\n      ¬∑ simp only [seminormFromConst_seq, hn, pow_zero, mul_one, div_one]\n      ¬∑ simp only [seminormFromConst_seq, hx (c ^ n), hpm _ (Nat.one_le_iff_ne_zero.mpr hn),\n          mul_div_assoc, div_self (pow_ne_zero n hc), mul_one]\n    rw [hseq]\n    exact tendsto_const_nhds\n  tendsto_nhds_unique (seminormFromConst_isLimit hf1 hc hpm x) hlim\n\n"}
{"name":"seminormFromConst_isMul_of_isMul","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : LE.le (f 1) 1\nhc : Ne (f c) 0\nhpm : IsPowMul ‚áëf\nx : R\nhx : ‚àÄ (y : R), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\ny : R\n‚ä¢ Eq (seminormFromConst' hf1 hc hpm (HMul.hMul x y)) (HMul.hMul (seminormFromConst' hf1 hc hpm x) (seminormFromConst' hf1 hc hpm y))","decl":"/-- If `x : R` is multiplicative for `f`, then it is multiplicative for\n  `seminormFromConst' hf1 hc hpm`. -/\ntheorem seminormFromConst_isMul_of_isMul {x : R} (hx : ‚àÄ y : R, f (x * y) = f x * f y) (y : R) :\n    seminormFromConst' hf1 hc hpm (x * y) =\n      seminormFromConst' hf1 hc hpm x * seminormFromConst' hf1 hc hpm y :=\n  have hlim : Tendsto (seminormFromConst_seq c f (x * y)) atTop\n      (ùìù (seminormFromConst' hf1 hc hpm x * seminormFromConst' hf1 hc hpm y)) := by\n    rw [seminormFromConst_apply_of_isMul hf1 hc hpm hx]\n    have hseq : seminormFromConst_seq c f (x * y) =\n        fun n ‚Ü¶ f x * seminormFromConst_seq c f y n := by\n      ext n\n      simp only [seminormFromConst_seq, mul_assoc, hx, mul_div_assoc]\n    simpa [hseq] using (seminormFromConst_isLimit hf1 hc hpm y).const_mul _\n  tendsto_nhds_unique (seminormFromConst_isLimit hf1 hc hpm (x * y)) hlim\n\n"}
{"name":"seminormFromConst_apply_c","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : LE.le (f 1) 1\nhc : Ne (f c) 0\nhpm : IsPowMul ‚áëf\n‚ä¢ Eq (seminormFromConst' hf1 hc hpm c) (f c)","decl":"/-- `seminormFromConst' hf1 hc hpm c = f c`. -/\ntheorem seminormFromConst_apply_c : seminormFromConst' hf1 hc hpm c = f c :=\n  have hlim : Tendsto (seminormFromConst_seq c f c) atTop (ùìù (f c)) := by\n    have hseq : seminormFromConst_seq c f c = fun _n ‚Ü¶ f c := by\n      ext n\n      simp only [seminormFromConst_seq]\n      rw [mul_comm, ‚Üê pow_succ, hpm _ le_add_self, pow_succ, mul_comm,  mul_div_assoc,\n        div_self (pow_ne_zero n hc), mul_one]\n    rw [hseq]\n    exact tendsto_const_nhds\n  tendsto_nhds_unique (seminormFromConst_isLimit hf1 hc hpm c) hlim\n\n"}
{"name":"seminormFromConst_const_mul","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : LE.le (f 1) 1\nhc : Ne (f c) 0\nhpm : IsPowMul ‚áëf\nx : R\n‚ä¢ Eq (seminormFromConst' hf1 hc hpm (HMul.hMul c x)) (HMul.hMul (seminormFromConst' hf1 hc hpm c) (seminormFromConst' hf1 hc hpm x))","decl":"/-- For every `x : R`, `seminormFromConst' hf1 hc hpm (c * x)` equals the product\n  `seminormFromConst' hf1 hc hpm c * SeminormFromConst' hf1 hc hpm x`. -/\ntheorem seminormFromConst_const_mul (x : R) :\n    seminormFromConst' hf1 hc hpm (c * x) =\n      seminormFromConst' hf1 hc hpm c * seminormFromConst' hf1 hc hpm x := by\n  have hlim : Tendsto (fun n ‚Ü¶ seminormFromConst_seq c f x (n + 1)) atTop\n      (ùìù (seminormFromConst' hf1 hc hpm x)) := by\n    apply (seminormFromConst_isLimit hf1 hc hpm x).comp\n      (tendsto_atTop_atTop_of_monotone (fun _ _ hnm ‚Ü¶ add_le_add_right hnm 1) _)\n    rintro n; use n; omega\n  rw [seminormFromConst_apply_c hf1 hc hpm]\n  apply tendsto_nhds_unique (seminormFromConst_isLimit hf1 hc hpm (c * x))\n  have hterm : seminormFromConst_seq c f (c * x) =\n      fun n ‚Ü¶ f c * seminormFromConst_seq c f x (n + 1) := by\n    simp only [seminormFromConst_seq_def]\n    ext n\n    ring_nf\n    rw [mul_assoc _ (f c), mul_inv_cancel‚ÇÄ hc, mul_one]\n  simpa [hterm] using tendsto_const_nhds.mul hlim\n\n"}
{"name":"seminormFromConstRingNormOfField_def","module":"Mathlib.Analysis.Normed.Ring.SeminormFromConst","initialProofState":"K : Type u_1\ninst‚úù : Field K\nk : K\ng : RingSeminorm K\nhg1 : LE.le (g 1) 1\nhg_k : Ne (g k) 0\nhg_pm : IsPowMul ‚áëg\nx : K\n‚ä¢ Eq ((normFromConst hg1 hg_k hg_pm) x) (seminormFromConst' hg1 hg_k hg_pm x)","decl":"theorem seminormFromConstRingNormOfField_def {k : K} {g : RingSeminorm K} (hg1 : g 1 ‚â§ 1)\n    (hg_k : g k ‚â† 0) (hg_pm : IsPowMul g) (x : K) :\n    normFromConst hg1 hg_k hg_pm x = seminormFromConst' hg1 hg_k hg_pm x := rfl\n\n"}
