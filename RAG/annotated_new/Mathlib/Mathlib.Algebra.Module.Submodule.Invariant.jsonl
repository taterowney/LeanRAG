{"name":"Module.End.mem_invtSubmodule","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\np : Submodule R M\n⊢ Iff (Membership.mem f.invtSubmodule p) (LE.le p (Submodule.comap f p))","decl":"lemma mem_invtSubmodule {p : Submodule R M} :\n    p ∈ f.invtSubmodule ↔ p ≤ p.comap f :=\n  Iff.rfl\n\n"}
{"name":"Module.End.invtSubmodule.inf_mem","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\np q : Submodule R M\nhp : Membership.mem f.invtSubmodule p\nhq : Membership.mem f.invtSubmodule q\n⊢ Membership.mem f.invtSubmodule (Min.min p q)","decl":"lemma inf_mem {p q : Submodule R M} (hp : p ∈ f.invtSubmodule) (hq : q ∈ f.invtSubmodule) :\n    p ⊓ q ∈ f.invtSubmodule :=\n  ((⟨p, hp⟩ : f.invtSubmodule) ⊓ (⟨q, hq⟩ : f.invtSubmodule)).property\n\n"}
{"name":"Module.End.invtSubmodule.sup_mem","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\np q : Submodule R M\nhp : Membership.mem f.invtSubmodule p\nhq : Membership.mem f.invtSubmodule q\n⊢ Membership.mem f.invtSubmodule (Max.max p q)","decl":"lemma sup_mem {p q : Submodule R M} (hp : p ∈ f.invtSubmodule) (hq : q ∈ f.invtSubmodule) :\n    p ⊔ q ∈ f.invtSubmodule :=\n  ((⟨p, hp⟩ : f.invtSubmodule) ⊔ (⟨q, hq⟩ : f.invtSubmodule)).property\n\n"}
{"name":"Module.End.invtSubmodule.top_mem","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\n⊢ Membership.mem f.invtSubmodule Top.top","decl":"@[simp]\nprotected lemma top_mem : ⊤ ∈ f.invtSubmodule := by simp [invtSubmodule]\n\n"}
{"name":"Module.End.invtSubmodule.bot_mem","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\n⊢ Membership.mem f.invtSubmodule Bot.bot","decl":"@[simp]\nprotected lemma bot_mem : ⊥ ∈ f.invtSubmodule := by simp [invtSubmodule]\n\n"}
{"name":"Module.End.invtSubmodule.zero","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Module.End.invtSubmodule 0) Top.top","decl":"@[simp]\nprotected lemma zero :\n    (0 : End R M).invtSubmodule = ⊤ :=\n  eq_top_iff.mpr fun x ↦ by simp [invtSubmodule]\n\n"}
{"name":"Module.End.invtSubmodule.id","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Module.End.invtSubmodule LinearMap.id) Top.top","decl":"@[simp]\nprotected lemma id :\n    invtSubmodule (LinearMap.id : End R M) = ⊤ :=\n  eq_top_iff.mpr fun x ↦ by simp [invtSubmodule]\n\n"}
{"name":"Module.End.invtSubmodule.mk_eq_bot_iff","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\np : Submodule R M\nhp : Membership.mem f.invtSubmodule p\n⊢ Iff (Eq ⟨p, hp⟩ Bot.bot) (Eq p Bot.bot)","decl":"protected lemma mk_eq_bot_iff {p : Submodule R M} (hp : p ∈ f.invtSubmodule) :\n    (⟨p, hp⟩ : f.invtSubmodule) = ⊥ ↔ p = ⊥ :=\n  Subtype.mk_eq_bot_iff (by simp [invtSubmodule]) _\n\n"}
{"name":"Module.End.invtSubmodule.mk_eq_top_iff","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\np : Submodule R M\nhp : Membership.mem f.invtSubmodule p\n⊢ Iff (Eq ⟨p, hp⟩ Top.top) (Eq p Top.top)","decl":"protected lemma mk_eq_top_iff {p : Submodule R M} (hp : p ∈ f.invtSubmodule) :\n    (⟨p, hp⟩ : f.invtSubmodule) = ⊤ ↔ p = ⊤ :=\n  Subtype.mk_eq_top_iff (by simp [invtSubmodule]) _\n\n"}
{"name":"Module.End.invtSubmodule.disjoint_mk_iff","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\np q : Submodule R M\nhp : Membership.mem f.invtSubmodule p\nhq : Membership.mem f.invtSubmodule q\n⊢ Iff (Disjoint ⟨p, hp⟩ ⟨q, hq⟩) (Disjoint p q)","decl":"@[simp]\nprotected lemma disjoint_mk_iff {p q : Submodule R M}\n    (hp : p ∈ f.invtSubmodule) (hq : q ∈ f.invtSubmodule) :\n    Disjoint (α := f.invtSubmodule) ⟨p, hp⟩ ⟨q, hq⟩ ↔ Disjoint p q := by\n  rw [disjoint_iff, disjoint_iff, Sublattice.mk_inf_mk,\n    Subtype.mk_eq_bot_iff (⊥ : f.invtSubmodule).property]\n\n"}
{"name":"Module.End.invtSubmodule.disjoint_iff","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\np q : Subtype fun x => Membership.mem f.invtSubmodule x\n⊢ Iff (Disjoint p q) (Disjoint ↑p ↑q)","decl":"protected lemma disjoint_iff {p q : f.invtSubmodule} :\n    Disjoint p q ↔ Disjoint (p : Submodule R M) (q : Submodule R M) := by\n  obtain ⟨p, hp⟩ := p\n  obtain ⟨q, hq⟩ := q\n  simp\n\n"}
{"name":"Module.End.invtSubmodule.codisjoint_mk_iff","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\np q : Submodule R M\nhp : Membership.mem f.invtSubmodule p\nhq : Membership.mem f.invtSubmodule q\n⊢ Iff (Codisjoint ⟨p, hp⟩ ⟨q, hq⟩) (Codisjoint p q)","decl":"@[simp]\nprotected lemma codisjoint_mk_iff {p q : Submodule R M}\n    (hp : p ∈ f.invtSubmodule) (hq : q ∈ f.invtSubmodule) :\n    Codisjoint (α := f.invtSubmodule) ⟨p, hp⟩ ⟨q, hq⟩ ↔ Codisjoint p q := by\n  rw [codisjoint_iff, codisjoint_iff, Sublattice.mk_sup_mk,\n    Subtype.mk_eq_top_iff (⊤ : f.invtSubmodule).property]\n\n"}
{"name":"Module.End.invtSubmodule.codisjoint_iff","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\np q : Subtype fun x => Membership.mem f.invtSubmodule x\n⊢ Iff (Codisjoint p q) (Codisjoint ↑p ↑q)","decl":"protected lemma codisjoint_iff {p q : f.invtSubmodule} :\n    Codisjoint p q ↔ Codisjoint (p : Submodule R M) (q : Submodule R M) := by\n  obtain ⟨p, hp⟩ := p\n  obtain ⟨q, hq⟩ := q\n  simp\n\n"}
{"name":"Module.End.invtSubmodule.isCompl_mk_iff","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\np q : Submodule R M\nhp : Membership.mem f.invtSubmodule p\nhq : Membership.mem f.invtSubmodule q\n⊢ Iff (IsCompl ⟨p, hp⟩ ⟨q, hq⟩) (IsCompl p q)","decl":"@[simp]\nprotected lemma isCompl_mk_iff {p q : Submodule R M}\n    (hp : p ∈ f.invtSubmodule) (hq : q ∈ f.invtSubmodule) :\n    IsCompl (α := f.invtSubmodule) ⟨p, hp⟩ ⟨q, hq⟩ ↔ IsCompl p q := by\n  simp [isCompl_iff]\n\n"}
{"name":"Module.End.invtSubmodule.isCompl_iff","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\np q : Subtype fun x => Membership.mem f.invtSubmodule x\n⊢ Iff (IsCompl p q) (IsCompl ↑p ↑q)","decl":"protected lemma isCompl_iff {p q : f.invtSubmodule} :\n    IsCompl p q ↔ IsCompl (p : Submodule R M) (q : Submodule R M) := by\n  obtain ⟨p, hp⟩ := p\n  obtain ⟨q, hq⟩ := q\n  simp\n\n"}
{"name":"Module.End.invtSubmodule.map_subtype_mem_of_mem_invtSubmodule","module":"Mathlib.Algebra.Module.Submodule.Invariant","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\np : Submodule R M\nhp : Membership.mem f.invtSubmodule p\nq : Submodule R (Subtype fun x => Membership.mem p x)\nhq : Membership.mem (Module.End.invtSubmodule (LinearMap.restrict f hp)) q\n⊢ Membership.mem f.invtSubmodule (Submodule.map p.subtype q)","decl":"lemma map_subtype_mem_of_mem_invtSubmodule {p : Submodule R M} (hp : p ∈ f.invtSubmodule)\n    {q : Submodule R p} (hq : q ∈ invtSubmodule (LinearMap.restrict f hp)) :\n    Submodule.map p.subtype q ∈ f.invtSubmodule := by\n  rintro - ⟨⟨x, hx⟩, hx', rfl⟩\n  specialize hq hx'\n  rw [Submodule.mem_comap, LinearMap.restrict_apply] at hq\n  simpa [hq] using hp hx\n\n"}
