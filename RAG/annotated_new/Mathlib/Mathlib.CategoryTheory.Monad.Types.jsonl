{"name":"CategoryTheory.ofTypeMonad_obj","module":"Mathlib.CategoryTheory.Monad.Types","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\na✝ : Type u\n⊢ Eq ((CategoryTheory.ofTypeMonad m).obj a✝) (m a✝)","decl":"/-- A lawful `Control.Monad` gives a category theory `Monad` on the category of types.\n-/\n@[simps!]\ndef ofTypeMonad : Monad (Type u) where\n  toFunctor := ofTypeFunctor m\n  η := ⟨@pure m _, fun _ _ f => funext fun x => (LawfulApplicative.map_pure f x).symm⟩\n  μ := ⟨@joinM m _, fun α β (f : α → β) => funext fun a => by apply joinM_map_map⟩\n  assoc α := funext fun a => by apply joinM_map_joinM\n  left_unit α := funext fun a => by apply joinM_pure\n  right_unit α := funext fun a => by apply joinM_map_pure\n\n"}
{"name":"CategoryTheory.ofTypeMonad_μ_app","module":"Mathlib.CategoryTheory.Monad.Types","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nα : Type u\na : m (m α)\n⊢ Eq ((CategoryTheory.ofTypeMonad m).μ.app α a) (joinM a)","decl":"/-- A lawful `Control.Monad` gives a category theory `Monad` on the category of types.\n-/\n@[simps!]\ndef ofTypeMonad : Monad (Type u) where\n  toFunctor := ofTypeFunctor m\n  η := ⟨@pure m _, fun _ _ f => funext fun x => (LawfulApplicative.map_pure f x).symm⟩\n  μ := ⟨@joinM m _, fun α β (f : α → β) => funext fun a => by apply joinM_map_map⟩\n  assoc α := funext fun a => by apply joinM_map_joinM\n  left_unit α := funext fun a => by apply joinM_pure\n  right_unit α := funext fun a => by apply joinM_map_pure\n\n"}
{"name":"CategoryTheory.ofTypeMonad_η_app","module":"Mathlib.CategoryTheory.Monad.Types","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nα : Type u\na✝ : α\n⊢ Eq ((CategoryTheory.ofTypeMonad m).η.app α a✝) (Pure.pure a✝)","decl":"/-- A lawful `Control.Monad` gives a category theory `Monad` on the category of types.\n-/\n@[simps!]\ndef ofTypeMonad : Monad (Type u) where\n  toFunctor := ofTypeFunctor m\n  η := ⟨@pure m _, fun _ _ f => funext fun x => (LawfulApplicative.map_pure f x).symm⟩\n  μ := ⟨@joinM m _, fun α β (f : α → β) => funext fun a => by apply joinM_map_map⟩\n  assoc α := funext fun a => by apply joinM_map_joinM\n  left_unit α := funext fun a => by apply joinM_pure\n  right_unit α := funext fun a => by apply joinM_map_pure\n\n"}
{"name":"CategoryTheory.ofTypeMonad_map","module":"Mathlib.CategoryTheory.Monad.Types","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nX✝ Y✝ : Type u\nf : Quiver.Hom X✝ Y✝\na✝ : m X✝\n⊢ Eq ((CategoryTheory.ofTypeMonad m).map f a✝) (Functor.map f a✝)","decl":"/-- A lawful `Control.Monad` gives a category theory `Monad` on the category of types.\n-/\n@[simps!]\ndef ofTypeMonad : Monad (Type u) where\n  toFunctor := ofTypeFunctor m\n  η := ⟨@pure m _, fun _ _ f => funext fun x => (LawfulApplicative.map_pure f x).symm⟩\n  μ := ⟨@joinM m _, fun α β (f : α → β) => funext fun a => by apply joinM_map_map⟩\n  assoc α := funext fun a => by apply joinM_map_joinM\n  left_unit α := funext fun a => by apply joinM_pure\n  right_unit α := funext fun a => by apply joinM_map_pure\n\n"}
{"name":"CategoryTheory.eq_functor_map","module":"Mathlib.CategoryTheory.Monad.Types","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nX✝ Y✝ : CategoryTheory.KleisliCat m\nf : Quiver.Hom X✝ Y✝\na✝ : X✝\n⊢ Eq ((CategoryTheory.eq m).functor.map f a✝) (f a✝)","decl":"/-- The `Kleisli` category of a `Control.Monad` is equivalent to the `Kleisli` category of its\ncategory-theoretic version, provided the monad is lawful.\n-/\n@[simps]\ndef eq : KleisliCat m ≌ Kleisli (ofTypeMonad m) where\n  functor :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun _ => rfl\n      map_comp := fun f g => by\n        --unfold_projs\n        funext t\n        -- Porting note: missing tactic `unfold_projs`, using `change` instead.\n        change _ = joinM (g <$> (f t))\n        simp only [joinM, seq_bind_eq, Function.id_comp]\n        rfl }\n  inverse :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun _ => rfl\n      map_comp := fun f g => by\n        --unfold_projs\n        -- Porting note: Need these instances for some lemmas below.\n        --Should they be added as actual instances elsewhere?\n        letI : _root_.Monad (ofTypeMonad m).obj :=\n          show _root_.Monad m from inferInstance\n        letI : LawfulMonad (ofTypeMonad m).obj :=\n          show LawfulMonad m from inferInstance\n        funext t\n        dsimp\n        -- Porting note: missing tactic `unfold_projs`, using `change` instead.\n        change joinM (g <$> (f t)) = _\n        simp only [joinM, seq_bind_eq, Function.id_comp]\n        rfl }\n  unitIso := by\n    refine NatIso.ofComponents (fun X => Iso.refl X) fun f => ?_\n    change f >=> pure = pure >=> f\n    simp [functor_norm]\n  counitIso := NatIso.ofComponents fun X => Iso.refl X\n\n"}
{"name":"CategoryTheory.eq_counitIso","module":"Mathlib.CategoryTheory.Monad.Types","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\n⊢ Eq (CategoryTheory.eq m).counitIso (CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.Iso.refl X) ⋯)","decl":"/-- The `Kleisli` category of a `Control.Monad` is equivalent to the `Kleisli` category of its\ncategory-theoretic version, provided the monad is lawful.\n-/\n@[simps]\ndef eq : KleisliCat m ≌ Kleisli (ofTypeMonad m) where\n  functor :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun _ => rfl\n      map_comp := fun f g => by\n        --unfold_projs\n        funext t\n        -- Porting note: missing tactic `unfold_projs`, using `change` instead.\n        change _ = joinM (g <$> (f t))\n        simp only [joinM, seq_bind_eq, Function.id_comp]\n        rfl }\n  inverse :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun _ => rfl\n      map_comp := fun f g => by\n        --unfold_projs\n        -- Porting note: Need these instances for some lemmas below.\n        --Should they be added as actual instances elsewhere?\n        letI : _root_.Monad (ofTypeMonad m).obj :=\n          show _root_.Monad m from inferInstance\n        letI : LawfulMonad (ofTypeMonad m).obj :=\n          show LawfulMonad m from inferInstance\n        funext t\n        dsimp\n        -- Porting note: missing tactic `unfold_projs`, using `change` instead.\n        change joinM (g <$> (f t)) = _\n        simp only [joinM, seq_bind_eq, Function.id_comp]\n        rfl }\n  unitIso := by\n    refine NatIso.ofComponents (fun X => Iso.refl X) fun f => ?_\n    change f >=> pure = pure >=> f\n    simp [functor_norm]\n  counitIso := NatIso.ofComponents fun X => Iso.refl X\n\n"}
{"name":"CategoryTheory.eq_functor_obj","module":"Mathlib.CategoryTheory.Monad.Types","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nX : CategoryTheory.KleisliCat m\n⊢ Eq ((CategoryTheory.eq m).functor.obj X) X","decl":"/-- The `Kleisli` category of a `Control.Monad` is equivalent to the `Kleisli` category of its\ncategory-theoretic version, provided the monad is lawful.\n-/\n@[simps]\ndef eq : KleisliCat m ≌ Kleisli (ofTypeMonad m) where\n  functor :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun _ => rfl\n      map_comp := fun f g => by\n        --unfold_projs\n        funext t\n        -- Porting note: missing tactic `unfold_projs`, using `change` instead.\n        change _ = joinM (g <$> (f t))\n        simp only [joinM, seq_bind_eq, Function.id_comp]\n        rfl }\n  inverse :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun _ => rfl\n      map_comp := fun f g => by\n        --unfold_projs\n        -- Porting note: Need these instances for some lemmas below.\n        --Should they be added as actual instances elsewhere?\n        letI : _root_.Monad (ofTypeMonad m).obj :=\n          show _root_.Monad m from inferInstance\n        letI : LawfulMonad (ofTypeMonad m).obj :=\n          show LawfulMonad m from inferInstance\n        funext t\n        dsimp\n        -- Porting note: missing tactic `unfold_projs`, using `change` instead.\n        change joinM (g <$> (f t)) = _\n        simp only [joinM, seq_bind_eq, Function.id_comp]\n        rfl }\n  unitIso := by\n    refine NatIso.ofComponents (fun X => Iso.refl X) fun f => ?_\n    change f >=> pure = pure >=> f\n    simp [functor_norm]\n  counitIso := NatIso.ofComponents fun X => Iso.refl X\n\n"}
{"name":"CategoryTheory.eq_unitIso","module":"Mathlib.CategoryTheory.Monad.Types","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\n⊢ Eq (CategoryTheory.eq m).unitIso (CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.Iso.refl X) ⋯)","decl":"/-- The `Kleisli` category of a `Control.Monad` is equivalent to the `Kleisli` category of its\ncategory-theoretic version, provided the monad is lawful.\n-/\n@[simps]\ndef eq : KleisliCat m ≌ Kleisli (ofTypeMonad m) where\n  functor :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun _ => rfl\n      map_comp := fun f g => by\n        --unfold_projs\n        funext t\n        -- Porting note: missing tactic `unfold_projs`, using `change` instead.\n        change _ = joinM (g <$> (f t))\n        simp only [joinM, seq_bind_eq, Function.id_comp]\n        rfl }\n  inverse :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun _ => rfl\n      map_comp := fun f g => by\n        --unfold_projs\n        -- Porting note: Need these instances for some lemmas below.\n        --Should they be added as actual instances elsewhere?\n        letI : _root_.Monad (ofTypeMonad m).obj :=\n          show _root_.Monad m from inferInstance\n        letI : LawfulMonad (ofTypeMonad m).obj :=\n          show LawfulMonad m from inferInstance\n        funext t\n        dsimp\n        -- Porting note: missing tactic `unfold_projs`, using `change` instead.\n        change joinM (g <$> (f t)) = _\n        simp only [joinM, seq_bind_eq, Function.id_comp]\n        rfl }\n  unitIso := by\n    refine NatIso.ofComponents (fun X => Iso.refl X) fun f => ?_\n    change f >=> pure = pure >=> f\n    simp [functor_norm]\n  counitIso := NatIso.ofComponents fun X => Iso.refl X\n\n"}
{"name":"CategoryTheory.eq_inverse_obj","module":"Mathlib.CategoryTheory.Monad.Types","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nX : CategoryTheory.Kleisli (CategoryTheory.ofTypeMonad m)\n⊢ Eq ((CategoryTheory.eq m).inverse.obj X) X","decl":"/-- The `Kleisli` category of a `Control.Monad` is equivalent to the `Kleisli` category of its\ncategory-theoretic version, provided the monad is lawful.\n-/\n@[simps]\ndef eq : KleisliCat m ≌ Kleisli (ofTypeMonad m) where\n  functor :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun _ => rfl\n      map_comp := fun f g => by\n        --unfold_projs\n        funext t\n        -- Porting note: missing tactic `unfold_projs`, using `change` instead.\n        change _ = joinM (g <$> (f t))\n        simp only [joinM, seq_bind_eq, Function.id_comp]\n        rfl }\n  inverse :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun _ => rfl\n      map_comp := fun f g => by\n        --unfold_projs\n        -- Porting note: Need these instances for some lemmas below.\n        --Should they be added as actual instances elsewhere?\n        letI : _root_.Monad (ofTypeMonad m).obj :=\n          show _root_.Monad m from inferInstance\n        letI : LawfulMonad (ofTypeMonad m).obj :=\n          show LawfulMonad m from inferInstance\n        funext t\n        dsimp\n        -- Porting note: missing tactic `unfold_projs`, using `change` instead.\n        change joinM (g <$> (f t)) = _\n        simp only [joinM, seq_bind_eq, Function.id_comp]\n        rfl }\n  unitIso := by\n    refine NatIso.ofComponents (fun X => Iso.refl X) fun f => ?_\n    change f >=> pure = pure >=> f\n    simp [functor_norm]\n  counitIso := NatIso.ofComponents fun X => Iso.refl X\n\n"}
{"name":"CategoryTheory.eq_inverse_map","module":"Mathlib.CategoryTheory.Monad.Types","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nX✝ Y✝ : CategoryTheory.Kleisli (CategoryTheory.ofTypeMonad m)\nf : Quiver.Hom X✝ Y✝\na✝ : X✝\n⊢ Eq ((CategoryTheory.eq m).inverse.map f a✝) (f a✝)","decl":"/-- The `Kleisli` category of a `Control.Monad` is equivalent to the `Kleisli` category of its\ncategory-theoretic version, provided the monad is lawful.\n-/\n@[simps]\ndef eq : KleisliCat m ≌ Kleisli (ofTypeMonad m) where\n  functor :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun _ => rfl\n      map_comp := fun f g => by\n        --unfold_projs\n        funext t\n        -- Porting note: missing tactic `unfold_projs`, using `change` instead.\n        change _ = joinM (g <$> (f t))\n        simp only [joinM, seq_bind_eq, Function.id_comp]\n        rfl }\n  inverse :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun _ => rfl\n      map_comp := fun f g => by\n        --unfold_projs\n        -- Porting note: Need these instances for some lemmas below.\n        --Should they be added as actual instances elsewhere?\n        letI : _root_.Monad (ofTypeMonad m).obj :=\n          show _root_.Monad m from inferInstance\n        letI : LawfulMonad (ofTypeMonad m).obj :=\n          show LawfulMonad m from inferInstance\n        funext t\n        dsimp\n        -- Porting note: missing tactic `unfold_projs`, using `change` instead.\n        change joinM (g <$> (f t)) = _\n        simp only [joinM, seq_bind_eq, Function.id_comp]\n        rfl }\n  unitIso := by\n    refine NatIso.ofComponents (fun X => Iso.refl X) fun f => ?_\n    change f >=> pure = pure >=> f\n    simp [functor_norm]\n  counitIso := NatIso.ofComponents fun X => Iso.refl X\n\n"}
