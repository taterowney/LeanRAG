{"name":"FirstOrder.Language.DirectedSystem.map_self","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"ι : Type u_1\ninst✝² : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝¹ : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ni : ι\nx : F i\n⊢ Eq ((f i i ⋯) x) x","decl":"alias map_self := DirectedSystem.map_self'\n"}
{"name":"FirstOrder.Language.DirectedSystem.map_map","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"ι : Type u_1\ninst✝² : Preorder ι\nF : ι → Type u_4\nT : ⦃i j : ι⦄ → LE.le i j → Sort u_8\nf : (i j : ι) → (h : LE.le i j) → T h\ninst✝¹ : ⦃i j : ι⦄ → (h : LE.le i j) → FunLike (T h) (F i) (F j)\ninst✝ : DirectedSystem F fun x1 x2 x3 => ⇑(f x1 x2 x3)\ni j k : ι\nhij : LE.le i j\nhjk : LE.le j k\nx : F i\n⊢ Eq ((f j k hjk) ((f i j hij) x)) ((f i k ⋯) x)","decl":"alias map_map := DirectedSystem.map_map'\n\n"}
{"name":"FirstOrder.Language.DirectedSystem.coe_natLERec","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nG' : Nat → Type w\ninst✝ : (i : Nat) → L.Structure (G' i)\nf' : (n : Nat) → L.Embedding (G' n) (G' (HAdd.hAdd n 1))\nm n : Nat\nh : LE.le m n\n⊢ Eq ⇑(FirstOrder.Language.DirectedSystem.natLERec f' m n h) fun a => Nat.leRecOn h (fun k => ⇑(f' k)) a","decl":"@[simp]\ntheorem coe_natLERec (m n : ℕ) (h : m ≤ n) :\n    (natLERec f' m n h : G' m → G' n) = Nat.leRecOn h (@fun k => f' k) := by\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le h\n  ext x\n  induction' k with k ih\n  · -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [natLERec, Nat.leRecOn_self, Embedding.refl_apply, Nat.leRecOn_self]\n  · -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [Nat.leRecOn_succ le_self_add, natLERec, Nat.leRecOn_succ le_self_add, ← natLERec,\n      Embedding.comp_apply, ih]\n\n"}
{"name":"FirstOrder.Language.DirectedSystem.natLERec.directedSystem","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nG' : Nat → Type w\ninst✝ : (i : Nat) → L.Structure (G' i)\nf' : (n : Nat) → L.Embedding (G' n) (G' (HAdd.hAdd n 1))\n⊢ DirectedSystem G' fun i j h => ⇑(FirstOrder.Language.DirectedSystem.natLERec f' i j h)","decl":"instance natLERec.directedSystem : DirectedSystem G' fun i j h => natLERec f' i j h :=\n  ⟨fun _ _ => congr (congr rfl (Nat.leRecOn_self _)) rfl,\n   fun _ _ _ hij hjk => by simp [Nat.leRecOn_trans hij hjk]⟩\n\n"}
{"name":"FirstOrder.Language.DirectLimit.unify_sigma_mk_self","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝² : Preorder ι\nG : ι → Type w\ninst✝¹ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝ : DirectedSystem G fun i j h => ⇑(f i j h)\nα : Type u_1\ni : ι\nx : α → G i\n⊢ Eq (FirstOrder.Language.DirectLimit.unify f (fun a => FirstOrder.Language.Structure.Sigma.mk f i (x a)) i ⋯) x","decl":"@[simp]\ntheorem unify_sigma_mk_self {α : Type*} {i : ι} {x : α → G i} :\n    (unify f (fun a => .mk f i (x a)) i fun _ ⟨_, hj⟩ =>\n      _root_.trans (le_of_eq hj.symm) (refl _)) = x := by\n  ext a\n  rw [unify]\n  apply DirectedSystem.map_self\n\n"}
{"name":"FirstOrder.Language.DirectLimit.comp_unify","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝² : Preorder ι\nG : ι → Type w\ninst✝¹ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝ : DirectedSystem G fun i j h => ⇑(f i j h)\nα : Type u_1\nx : α → FirstOrder.Language.Structure.Sigma f\ni j : ι\nij : LE.le i j\nh : Membership.mem (upperBounds (Set.range (Function.comp Sigma.fst x))) i\n⊢ Eq (Function.comp (⇑(f i j ij)) (FirstOrder.Language.DirectLimit.unify f x i h)) (FirstOrder.Language.DirectLimit.unify f x j ⋯)","decl":"theorem comp_unify {α : Type*} {x : α → Σˣ f} {i j : ι} (ij : i ≤ j)\n    (h : i ∈ upperBounds (range (Sigma.fst ∘ x))) :\n    f i j ij ∘ unify f x i h = unify f x j\n      fun k hk => _root_.trans (mem_upperBounds.1 h k hk) ij := by\n  ext a\n  simp [unify, DirectedSystem.map_map]\n\n"}
{"name":"FirstOrder.Language.DirectLimit.equiv_iff","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝³ : Preorder ι\nG : ι → Type w\ninst✝² : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : DirectedSystem G fun i j h => ⇑(f i j h)\nx y : FirstOrder.Language.Structure.Sigma f\ni : ι\nhx : LE.le x.fst i\nhy : LE.le y.fst i\n⊢ Iff (HasEquiv.Equiv x y) (Eq ((f x.fst i hx) x.snd) ((f y.fst i hy) y.snd))","decl":"theorem equiv_iff {x y : Σˣ f} {i : ι} (hx : x.1 ≤ i) (hy : y.1 ≤ i) :\n    x ≈ y ↔ (f x.1 i hx) x.2 = (f y.1 i hy) y.2 := by\n  cases x\n  cases y\n  refine ⟨fun xy => ?_, fun xy => ⟨i, hx, hy, xy⟩⟩\n  obtain ⟨j, _, _, h⟩ := xy\n  obtain ⟨k, ik, jk⟩ := directed_of (· ≤ ·) i j\n  have h := congr_arg (f j k jk) h\n  apply (f i k ik).injective\n  rw [DirectedSystem.map_map, DirectedSystem.map_map] at *\n  exact h\n\n"}
{"name":"FirstOrder.Language.DirectLimit.funMap_unify_equiv","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝³ : Preorder ι\nG : ι → Type w\ninst✝² : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : DirectedSystem G fun i j h => ⇑(f i j h)\nn : Nat\nF : L.Functions n\nx : Fin n → FirstOrder.Language.Structure.Sigma f\ni j : ι\nhi : Membership.mem (upperBounds (Set.range (Function.comp Sigma.fst x))) i\nhj : Membership.mem (upperBounds (Set.range (Function.comp Sigma.fst x))) j\n⊢ HasEquiv.Equiv (FirstOrder.Language.Structure.Sigma.mk f i (FirstOrder.Language.Structure.funMap F (FirstOrder.Language.DirectLimit.unify f x i hi))) (FirstOrder.Language.Structure.Sigma.mk f j (FirstOrder.Language.Structure.funMap F (FirstOrder.Language.DirectLimit.unify f x j hj)))","decl":"theorem funMap_unify_equiv {n : ℕ} (F : L.Functions n) (x : Fin n → Σˣ f) (i j : ι)\n    (hi : i ∈ upperBounds (range (Sigma.fst ∘ x))) (hj : j ∈ upperBounds (range (Sigma.fst ∘ x))) :\n    Structure.Sigma.mk f i (funMap F (unify f x i hi)) ≈ .mk f j (funMap F (unify f x j hj)) := by\n  obtain ⟨k, ik, jk⟩ := directed_of (· ≤ ·) i j\n  refine ⟨k, ik, jk, ?_⟩\n  rw [(f i k ik).map_fun, (f j k jk).map_fun, comp_unify, comp_unify]\n\n"}
{"name":"FirstOrder.Language.DirectLimit.relMap_unify_equiv","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝³ : Preorder ι\nG : ι → Type w\ninst✝² : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : DirectedSystem G fun i j h => ⇑(f i j h)\nn : Nat\nR : L.Relations n\nx : Fin n → FirstOrder.Language.Structure.Sigma f\ni j : ι\nhi : Membership.mem (upperBounds (Set.range (Function.comp Sigma.fst x))) i\nhj : Membership.mem (upperBounds (Set.range (Function.comp Sigma.fst x))) j\n⊢ Eq (FirstOrder.Language.Structure.RelMap R (FirstOrder.Language.DirectLimit.unify f x i hi)) (FirstOrder.Language.Structure.RelMap R (FirstOrder.Language.DirectLimit.unify f x j hj))","decl":"theorem relMap_unify_equiv {n : ℕ} (R : L.Relations n) (x : Fin n → Σˣ f) (i j : ι)\n    (hi : i ∈ upperBounds (range (Sigma.fst ∘ x))) (hj : j ∈ upperBounds (range (Sigma.fst ∘ x))) :\n    RelMap R (unify f x i hi) = RelMap R (unify f x j hj) := by\n  obtain ⟨k, ik, jk⟩ := directed_of (· ≤ ·) i j\n  rw [← (f i k ik).map_rel, comp_unify, ← (f j k jk).map_rel, comp_unify]\n\n"}
{"name":"FirstOrder.Language.DirectLimit.exists_unify_eq","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁵ : Preorder ι\nG : ι → Type w\ninst✝⁴ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝¹ : Nonempty ι\nα : Type u_1\ninst✝ : Finite α\nx y : α → FirstOrder.Language.Structure.Sigma f\nxy : HasEquiv.Equiv x y\n⊢ Exists fun i => Exists fun hx => Exists fun hy => Eq (FirstOrder.Language.DirectLimit.unify f x i hx) (FirstOrder.Language.DirectLimit.unify f y i hy)","decl":"theorem exists_unify_eq {α : Type*} [Finite α] {x y : α → Σˣ f} (xy : x ≈ y) :\n    ∃ (i : ι) (hx : i ∈ upperBounds (range (Sigma.fst ∘ x)))\n      (hy : i ∈ upperBounds (range (Sigma.fst ∘ y))), unify f x i hx = unify f y i hy := by\n  obtain ⟨i, hi⟩ := Finite.bddAbove_range (Sum.elim (fun a => (x a).1) fun a => (y a).1)\n  rw [Sum.elim_range, upperBounds_union] at hi\n  simp_rw [← Function.comp_apply (f := Sigma.fst)] at hi\n  exact ⟨i, hi.1, hi.2, funext fun a => (equiv_iff G f _ _).1 (xy a)⟩\n\n"}
{"name":"FirstOrder.Language.DirectLimit.funMap_equiv_unify","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁴ : Preorder ι\nG : ι → Type w\ninst✝³ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝ : Nonempty ι\nn : Nat\nF : L.Functions n\nx : Fin n → FirstOrder.Language.Structure.Sigma f\ni : ι\nhi : Membership.mem (upperBounds (Set.range (Function.comp Sigma.fst x))) i\n⊢ HasEquiv.Equiv (FirstOrder.Language.Structure.funMap F x) (FirstOrder.Language.Structure.Sigma.mk f i (FirstOrder.Language.Structure.funMap F (FirstOrder.Language.DirectLimit.unify f x i hi)))","decl":"theorem funMap_equiv_unify {n : ℕ} (F : L.Functions n) (x : Fin n → Σˣ f) (i : ι)\n    (hi : i ∈ upperBounds (range (Sigma.fst ∘ x))) :\n    funMap F x ≈ .mk f _ (funMap F (unify f x i hi)) :=\n  funMap_unify_equiv G f F x (Classical.choose (Finite.bddAbove_range fun a => (x a).1)) i _ hi\n\n"}
{"name":"FirstOrder.Language.DirectLimit.relMap_equiv_unify","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁴ : Preorder ι\nG : ι → Type w\ninst✝³ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝ : Nonempty ι\nn : Nat\nR : L.Relations n\nx : Fin n → FirstOrder.Language.Structure.Sigma f\ni : ι\nhi : Membership.mem (upperBounds (Set.range (Function.comp Sigma.fst x))) i\n⊢ Eq (FirstOrder.Language.Structure.RelMap R x) (FirstOrder.Language.Structure.RelMap R (FirstOrder.Language.DirectLimit.unify f x i hi))","decl":"theorem relMap_equiv_unify {n : ℕ} (R : L.Relations n) (x : Fin n → Σˣ f) (i : ι)\n    (hi : i ∈ upperBounds (range (Sigma.fst ∘ x))) :\n    RelMap R x = RelMap R (unify f x i hi) :=\n  relMap_unify_equiv G f R x (Classical.choose (Finite.bddAbove_range fun a => (x a).1)) i _ hi\n\n"}
{"name":"FirstOrder.Language.DirectLimit.funMap_quotient_mk'_sigma_mk'","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁴ : Preorder ι\nG : ι → Type w\ninst✝³ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝ : Nonempty ι\nn : Nat\nF : L.Functions n\ni : ι\nx : Fin n → G i\n⊢ Eq (FirstOrder.Language.Structure.funMap F fun a => Quotient.mk (FirstOrder.Language.DirectLimit.setoid G f) (FirstOrder.Language.Structure.Sigma.mk f i (x a))) (Quotient.mk (FirstOrder.Language.DirectLimit.setoid G f) (FirstOrder.Language.Structure.Sigma.mk f i (FirstOrder.Language.Structure.funMap F x)))","decl":"@[simp]\ntheorem funMap_quotient_mk'_sigma_mk' {n : ℕ} {F : L.Functions n} {i : ι} {x : Fin n → G i} :\n    funMap F (fun a => (⟦.mk f i (x a)⟧ : DirectLimit G f)) = ⟦.mk f i (funMap F x)⟧ := by\n  simp only [funMap_quotient_mk', Quotient.eq]\n  obtain ⟨k, ik, jk⟩ :=\n    directed_of (· ≤ ·) i (Classical.choose (Finite.bddAbove_range fun _ : Fin n => i))\n  refine ⟨k, jk, ik, ?_⟩\n  simp only [Embedding.map_fun, comp_unify]\n  rfl\n\n"}
{"name":"FirstOrder.Language.DirectLimit.relMap_quotient_mk'_sigma_mk'","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁴ : Preorder ι\nG : ι → Type w\ninst✝³ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝ : Nonempty ι\nn : Nat\nR : L.Relations n\ni : ι\nx : Fin n → G i\n⊢ Eq (FirstOrder.Language.Structure.RelMap R fun a => Quotient.mk (FirstOrder.Language.DirectLimit.setoid G f) (FirstOrder.Language.Structure.Sigma.mk f i (x a))) (FirstOrder.Language.Structure.RelMap R x)","decl":"@[simp]\ntheorem relMap_quotient_mk'_sigma_mk' {n : ℕ} {R : L.Relations n} {i : ι} {x : Fin n → G i} :\n    RelMap R (fun a => (⟦.mk f i (x a)⟧ : DirectLimit G f)) = RelMap R x := by\n  rw [relMap_quotient_mk']\n  obtain ⟨k, _, _⟩ :=\n    directed_of (· ≤ ·) i (Classical.choose (Finite.bddAbove_range fun _ : Fin n => i))\n  rw [relMap_equiv_unify G f R (fun a => .mk f i (x a)) i]\n  rw [unify_sigma_mk_self]\n\n"}
{"name":"FirstOrder.Language.DirectLimit.exists_quotient_mk'_sigma_mk'_eq","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁵ : Preorder ι\nG : ι → Type w\ninst✝⁴ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝¹ : Nonempty ι\nα : Type u_1\ninst✝ : Finite α\nx : α → FirstOrder.Language.DirectLimit G f\n⊢ Exists fun i => Exists fun y => Eq x fun a => Quotient.mk (FirstOrder.Language.DirectLimit.setoid G f) (FirstOrder.Language.Structure.Sigma.mk f i (y a))","decl":"theorem exists_quotient_mk'_sigma_mk'_eq {α : Type*} [Finite α] (x : α → DirectLimit G f) :\n    ∃ (i : ι) (y : α → G i), x = fun a => ⟦.mk f i (y a)⟧ := by\n  obtain ⟨i, hi⟩ := Finite.bddAbove_range fun a => (x a).out.1\n  refine ⟨i, unify f (Quotient.out ∘ x) i hi, ?_⟩\n  ext a\n  rw [Quotient.eq_mk_iff_out, unify]\n  generalize_proofs r\n  change _ ≈ Structure.Sigma.mk f i (f (Quotient.out (x a)).fst i r (Quotient.out (x a)).snd)\n  have : (.mk f i (f (Quotient.out (x a)).fst i r (Quotient.out (x a)).snd) : Σˣ f).fst ≤ i :=\n    le_rfl\n  rw [equiv_iff G f (i := i) (hi _) this]\n  · simp only [DirectedSystem.map_self]\n  exact ⟨a, rfl⟩\n\n"}
{"name":"FirstOrder.Language.DirectLimit.of_apply","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁴ : Preorder ι\nG : ι → Type w\ninst✝³ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝ : Nonempty ι\ni : ι\nx : G i\n⊢ Eq ((FirstOrder.Language.DirectLimit.of L ι G f i) x) (Quotient.mk (FirstOrder.Language.DirectLimit.setoid G f) (FirstOrder.Language.Structure.Sigma.mk f i x))","decl":"@[simp]\ntheorem of_apply {i : ι} {x : G i} : of L ι G f i x = ⟦.mk f i x⟧ :=\n  rfl\n\n-- Porting note: removed the `@[simp]`, it is not in simp-normal form, but the simp-normal version\n-- of this theorem would not be useful.\n"}
{"name":"FirstOrder.Language.DirectLimit.of_f","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁴ : Preorder ι\nG : ι → Type w\ninst✝³ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝ : Nonempty ι\ni j : ι\nhij : LE.le i j\nx : G i\n⊢ Eq ((FirstOrder.Language.DirectLimit.of L ι G f j) ((f i j hij) x)) ((FirstOrder.Language.DirectLimit.of L ι G f i) x)","decl":"theorem of_f {i j : ι} {hij : i ≤ j} {x : G i} : of L ι G f j (f i j hij x) = of L ι G f i x := by\n  rw [of_apply, of_apply, Quotient.eq]\n  refine Setoid.symm ⟨j, hij, refl j, ?_⟩\n  simp only [DirectedSystem.map_self]\n\n"}
{"name":"FirstOrder.Language.DirectLimit.exists_of","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁴ : Preorder ι\nG : ι → Type w\ninst✝³ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝ : Nonempty ι\nz : FirstOrder.Language.DirectLimit G f\n⊢ Exists fun i => Exists fun x => Eq ((FirstOrder.Language.DirectLimit.of L ι G f i) x) z","decl":"/-- Every element of the direct limit corresponds to some element in\nsome component of the directed system. -/\ntheorem exists_of (z : DirectLimit G f) : ∃ i x, of L ι G f i x = z :=\n  ⟨z.out.1, z.out.2, by simp⟩\n\n"}
{"name":"FirstOrder.Language.DirectLimit.inductionOn","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁴ : Preorder ι\nG : ι → Type w\ninst✝³ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝ : Nonempty ι\nC : FirstOrder.Language.DirectLimit G f → Prop\nz : FirstOrder.Language.DirectLimit G f\nih : ∀ (i : ι) (x : G i), C ((FirstOrder.Language.DirectLimit.of L ι G f i) x)\n⊢ C z","decl":"@[elab_as_elim]\nprotected theorem inductionOn {C : DirectLimit G f → Prop} (z : DirectLimit G f)\n    (ih : ∀ i x, C (of L ι G f i x)) : C z :=\n  let ⟨i, x, h⟩ := exists_of z\n  h ▸ ih i x\n\n"}
{"name":"FirstOrder.Language.DirectLimit.iSup_range_of_eq_top","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁴ : Preorder ι\nG : ι → Type w\ninst✝³ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝ : Nonempty ι\n⊢ Eq (iSup fun i => (FirstOrder.Language.DirectLimit.of L ι G f i).toHom.range) Top.top","decl":"theorem iSup_range_of_eq_top : ⨆ i, (of L ι G f i).toHom.range = ⊤ :=\n  eq_top_iff.2 (fun x _ ↦ DirectLimit.inductionOn x\n    (fun i _ ↦ le_iSup (fun i ↦ Hom.range (Embedding.toHom (of L ι G f i))) i (mem_range_self _)))\n\n"}
{"name":"FirstOrder.Language.DirectLimit.exists_fg_substructure_in_Sigma","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁴ : Preorder ι\nG : ι → Type w\ninst✝³ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝ : Nonempty ι\nS : L.Substructure (FirstOrder.Language.DirectLimit G f)\nS_fg : S.FG\n⊢ Exists fun i => Exists fun T => Eq (FirstOrder.Language.Substructure.map (FirstOrder.Language.DirectLimit.of L ι G f i).toHom T) S","decl":"/-- Every finitely generated substructure of the direct limit corresponds to some\nsubstructure in some component of the directed system. -/\ntheorem exists_fg_substructure_in_Sigma (S : L.Substructure (DirectLimit G f)) (S_fg : S.FG) :\n    ∃ i, ∃ T : L.Substructure (G i), T.map (of L ι G f i).toHom = S := by\n  let ⟨A, A_closure⟩ := S_fg\n  let ⟨i, y, eq_y⟩ := exists_quotient_mk'_sigma_mk'_eq G _ (fun a : A ↦ a.1)\n  use i\n  use Substructure.closure L (range y)\n  rw [Substructure.map_closure]\n  simp only [Embedding.coe_toHom, of_apply]\n  rw [← image_univ, image_image, image_univ, ← eq_y,\n    Subtype.range_coe_subtype, Finset.setOf_mem, A_closure]\n\n"}
{"name":"FirstOrder.Language.DirectLimit.lift_quotient_mk'_sigma_mk'","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁵ : Preorder ι\nG : ι → Type w\ninst✝⁴ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝¹ : Nonempty ι\nP : Type u₁\ninst✝ : L.Structure P\ng : (i : ι) → L.Embedding (G i) P\nHg : ∀ (i j : ι) (hij : LE.le i j) (x : G i), Eq ((g j) ((f i j hij) x)) ((g i) x)\ni : ι\nx : G i\n⊢ Eq ((FirstOrder.Language.DirectLimit.lift L ι G f g Hg) (Quotient.mk (FirstOrder.Language.DirectLimit.setoid G f) (FirstOrder.Language.Structure.Sigma.mk f i x))) ((g i) x)","decl":"@[simp]\ntheorem lift_quotient_mk'_sigma_mk' {i} (x : G i) : lift L ι G f g Hg ⟦.mk f i x⟧ = (g i) x := by\n  change (lift L ι G f g Hg).toFun ⟦.mk f i x⟧ = _\n  simp only [lift, Quotient.lift_mk]\n\n"}
{"name":"FirstOrder.Language.DirectLimit.lift_of","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁵ : Preorder ι\nG : ι → Type w\ninst✝⁴ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝¹ : Nonempty ι\nP : Type u₁\ninst✝ : L.Structure P\ng : (i : ι) → L.Embedding (G i) P\nHg : ∀ (i j : ι) (hij : LE.le i j) (x : G i), Eq ((g j) ((f i j hij) x)) ((g i) x)\ni : ι\nx : G i\n⊢ Eq ((FirstOrder.Language.DirectLimit.lift L ι G f g Hg) ((FirstOrder.Language.DirectLimit.of L ι G f i) x)) ((g i) x)","decl":"theorem lift_of {i} (x : G i) : lift L ι G f g Hg (of L ι G f i x) = g i x := by simp\n\n"}
{"name":"FirstOrder.Language.DirectLimit.lift_unique","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁵ : Preorder ι\nG : ι → Type w\ninst✝⁴ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝¹ : Nonempty ι\nP : Type u₁\ninst✝ : L.Structure P\nF : L.Embedding (FirstOrder.Language.DirectLimit G f) P\nx : FirstOrder.Language.DirectLimit G f\n⊢ Eq (F x) ((FirstOrder.Language.DirectLimit.lift L ι G f (fun i => F.comp (FirstOrder.Language.DirectLimit.of L ι G f i)) ⋯) x)","decl":"theorem lift_unique (F : DirectLimit G f ↪[L] P) (x) :\n    F x =\n      lift L ι G f (fun i => F.comp <| of L ι G f i)\n        (fun i j hij x => by rw [F.comp_apply, F.comp_apply, of_f]) x :=\n  DirectLimit.inductionOn x fun i x => by rw [lift_of]; rfl\n\n"}
{"name":"FirstOrder.Language.DirectLimit.range_lift","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁵ : Preorder ι\nG : ι → Type w\ninst✝⁴ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝¹ : Nonempty ι\nP : Type u₁\ninst✝ : L.Structure P\ng : (i : ι) → L.Embedding (G i) P\nHg : ∀ (i j : ι) (hij : LE.le i j) (x : G i), Eq ((g j) ((f i j hij) x)) ((g i) x)\n⊢ Eq (FirstOrder.Language.DirectLimit.lift L ι G f g Hg).toHom.range (iSup fun i => (g i).toHom.range)","decl":"lemma range_lift : (lift L ι G f g Hg).toHom.range = ⨆ i, (g i).toHom.range := by\n  simp_rw [Hom.range_eq_map]\n  rw [← iSup_range_of_eq_top, Substructure.map_iSup]\n  simp_rw [Hom.range_eq_map, Substructure.map_map]\n  rfl\n\n"}
{"name":"FirstOrder.Language.DirectLimit.equiv_lift_of","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝⁶ : Preorder ι\nG : ι → Type w\ninst✝⁵ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝⁴ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝³ : DirectedSystem G fun i j h => ⇑(f i j h)\ninst✝² : Nonempty ι\nG' : ι → Type w'\ninst✝¹ : (i : ι) → L.Structure (G' i)\nf' : (i j : ι) → LE.le i j → L.Embedding (G' i) (G' j)\ng : (i : ι) → L.Equiv (G i) (G' i)\ninst✝ : DirectedSystem G' fun i j h => ⇑(f' i j h)\nH_commuting : ∀ (i j : ι) (hij : LE.le i j) (x : G i), Eq ((g j) ((f i j hij) x)) ((f' i j hij) ((g i) x))\ni : ι\nx : G i\n⊢ Eq ((FirstOrder.Language.DirectLimit.equiv_lift L ι G f G' f' g H_commuting) ((FirstOrder.Language.DirectLimit.of L ι G f i) x)) ((FirstOrder.Language.DirectLimit.of L ι G' f' i) ((g i) x))","decl":"theorem equiv_lift_of {i : ι} (x : G i) :\n    equiv_lift L ι G f G' f' g H_commuting (of L ι G f i x) = of L ι G' f' i (g i x) := rfl\n\n"}
{"name":"FirstOrder.Language.DirectLimit.cg","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type u_1\ninst✝⁵ : Countable ι\ninst✝⁴ : Preorder ι\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\nG : ι → Type w\ninst✝¹ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\nh : ∀ (i : ι), FirstOrder.Language.Structure.CG L (G i)\ninst✝ : DirectedSystem G fun i j h => ⇑(f i j h)\n⊢ FirstOrder.Language.Structure.CG L (FirstOrder.Language.DirectLimit G f)","decl":"/-- The direct limit of countably many countably generated structures is countably generated. -/\ntheorem cg {ι : Type*} [Countable ι] [Preorder ι] [IsDirected ι (· ≤ ·)] [Nonempty ι]\n    {G : ι → Type w} [∀ i, L.Structure (G i)] (f : ∀ i j, i ≤ j → G i ↪[L] G j)\n    (h : ∀ i, Structure.CG L (G i)) [DirectedSystem G fun i j h => f i j h] :\n    Structure.CG L (DirectLimit G f) := by\n  refine ⟨⟨⋃ i, DirectLimit.of L ι G f i '' Classical.choose (h i).out, ?_, ?_⟩⟩\n  · exact Set.countable_iUnion fun i => Set.Countable.image (Classical.choose_spec (h i).out).1 _\n  · rw [eq_top_iff, Substructure.closure_iUnion]\n    simp_rw [← Embedding.coe_toHom, Substructure.closure_image]\n    rw [le_iSup_iff]\n    intro S hS x _\n    let out := Quotient.out (s := DirectLimit.setoid G f)\n    refine hS (out x).1 ⟨(out x).2, ?_, ?_⟩\n    · rw [(Classical.choose_spec (h (out x).1).out).2]\n      trivial\n    · simp only [out, Embedding.coe_toHom, DirectLimit.of_apply, Sigma.eta, Quotient.out_eq]\n\n"}
{"name":"FirstOrder.Language.DirectLimit.cg'","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type u_1\ninst✝⁵ : Countable ι\ninst✝⁴ : Preorder ι\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\nG : ι → Type w\ninst✝¹ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\nh : ∀ (i : ι), FirstOrder.Language.Structure.CG L (G i)\ninst✝ : DirectedSystem G fun i j h => ⇑(f i j h)\n⊢ FirstOrder.Language.Structure.CG L (FirstOrder.Language.DirectLimit G f)","decl":"instance cg' {ι : Type*} [Countable ι] [Preorder ι] [IsDirected ι (· ≤ ·)] [Nonempty ι]\n    {G : ι → Type w} [∀ i, L.Structure (G i)] (f : ∀ i j, i ≤ j → G i ↪[L] G j)\n    [h : ∀ i, Structure.CG L (G i)] [DirectedSystem G fun i j h => f i j h] :\n    Structure.CG L (DirectLimit G f) :=\n  cg f h\n\n"}
{"name":"FirstOrder.Language.instDirectedSystemSubtypeMemSubstructureCoeOrderHomEmbeddingInclusion","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝¹ : Preorder ι\nM : Type u_1\ninst✝ : L.Structure M\nS : OrderHom ι (L.Substructure M)\n⊢ DirectedSystem (fun i => Subtype fun x => Membership.mem (S i) x) fun x x_1 h => ⇑(FirstOrder.Language.Substructure.inclusion ⋯)","decl":"instance : DirectedSystem (fun i ↦ S i) (fun _ _ h ↦ Substructure.inclusion (S.monotone h)) where\n  map_self _ _ := rfl\n  map_map _ _ _ _ _ _ := rfl\n\n"}
{"name":"FirstOrder.Language.DirectLimit.liftInclusion_of","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝³ : Preorder ι\ninst✝² : Nonempty ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\nM : Type u_1\ninst✝ : L.Structure M\nS : OrderHom ι (L.Substructure M)\ni : ι\nx : Subtype fun x => Membership.mem (S i) x\n⊢ Eq ((FirstOrder.Language.DirectLimit.liftInclusion S) ((FirstOrder.Language.DirectLimit.of L ι (fun x => Subtype fun x_1 => Membership.mem (S x) x_1) (fun x x_1 h => FirstOrder.Language.Substructure.inclusion ⋯) i) x)) ((S i).subtype x)","decl":"theorem liftInclusion_of {i : ι} (x : S i) :\n    (liftInclusion S) (of L ι _ (fun _ _ h ↦ Substructure.inclusion (S.monotone h)) i x)\n    = Substructure.subtype (S i) x := rfl\n\n"}
{"name":"FirstOrder.Language.DirectLimit.rangeLiftInclusion","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝³ : Preorder ι\ninst✝² : Nonempty ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\nM : Type u_1\ninst✝ : L.Structure M\nS : OrderHom ι (L.Substructure M)\n⊢ Eq (FirstOrder.Language.DirectLimit.liftInclusion S).toHom.range (iSup fun i => S i)","decl":"lemma rangeLiftInclusion : (liftInclusion S).toHom.range = ⨆ i, S i := by\n  simp_rw [liftInclusion, range_lift, Substructure.range_subtype]\n\n"}
{"name":"FirstOrder.Language.DirectLimit.Equiv_isup_of_apply","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝³ : Preorder ι\ninst✝² : Nonempty ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\nM : Type u_1\ninst✝ : L.Structure M\nS : OrderHom ι (L.Substructure M)\ni : ι\nx : Subtype fun x => Membership.mem (S i) x\n⊢ Eq ((FirstOrder.Language.DirectLimit.Equiv_iSup S) ((FirstOrder.Language.DirectLimit.of L ι (fun x => Subtype fun x_1 => Membership.mem (S x) x_1) (fun x x_1 h => FirstOrder.Language.Substructure.inclusion ⋯) i) x)) ((FirstOrder.Language.Substructure.inclusion ⋯) x)","decl":"theorem Equiv_isup_of_apply {i : ι} (x : S i) :\n    Equiv_iSup S (of L ι _ (fun _ _ h ↦ Substructure.inclusion (S.monotone h)) i x)\n    = Substructure.inclusion (le_iSup _ _) x := rfl\n\n"}
{"name":"FirstOrder.Language.DirectLimit.Equiv_isup_symm_inclusion_apply","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝³ : Preorder ι\ninst✝² : Nonempty ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\nM : Type u_1\ninst✝ : L.Structure M\nS : OrderHom ι (L.Substructure M)\ni : ι\nx : Subtype fun x => Membership.mem (S i) x\n⊢ Eq ((FirstOrder.Language.DirectLimit.Equiv_iSup S).symm ((FirstOrder.Language.Substructure.inclusion ⋯) x)) ((FirstOrder.Language.DirectLimit.of L ι (fun x => Subtype fun x_1 => Membership.mem (S x) x_1) (fun x x_1 h => FirstOrder.Language.Substructure.inclusion ⋯) i) x)","decl":"theorem Equiv_isup_symm_inclusion_apply {i : ι} (x : S i) :\n    (Equiv_iSup S).symm (Substructure.inclusion (le_iSup _ _) x)\n    = of L ι _ (fun _ _ h ↦ Substructure.inclusion (S.monotone h)) i x := by\n  apply (Equiv_iSup S).injective\n  simp only [Equiv.apply_symm_apply]\n  rfl\n\n"}
{"name":"FirstOrder.Language.DirectLimit.Equiv_isup_symm_inclusion","module":"Mathlib.ModelTheory.DirectLimit","initialProofState":"L : FirstOrder.Language\nι : Type v\ninst✝³ : Preorder ι\ninst✝² : Nonempty ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\nM : Type u_1\ninst✝ : L.Structure M\nS : OrderHom ι (L.Substructure M)\ni : ι\n⊢ Eq ((FirstOrder.Language.DirectLimit.Equiv_iSup S).symm.toEmbedding.comp (FirstOrder.Language.Substructure.inclusion ⋯)) (FirstOrder.Language.DirectLimit.of L ι (fun x => Subtype fun x_1 => Membership.mem (S x) x_1) (fun x x_1 h => FirstOrder.Language.Substructure.inclusion ⋯) i)","decl":"@[simp]\ntheorem Equiv_isup_symm_inclusion (i : ι) :\n    (Equiv_iSup S).symm.toEmbedding.comp (Substructure.inclusion (le_iSup _ _))\n    = of L ι _ (fun _ _ h ↦ Substructure.inclusion (S.monotone h)) i := by\n  ext x; exact Equiv_isup_symm_inclusion_apply _ x\n\n"}
