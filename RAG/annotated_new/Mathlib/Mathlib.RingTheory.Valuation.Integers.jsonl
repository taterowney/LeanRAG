{"name":"Valuation.mem_integer_iff","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"R : Type u\nΓ₀ : Type v\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation R Γ₀\nr : R\n⊢ Iff (Membership.mem v.integer r) (LE.le (v r) 1)","decl":"lemma mem_integer_iff (r : R) : r ∈ v.integer ↔ v r ≤ 1 := by rfl\n\n"}
{"name":"Valuation.Integers.map_le_one","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"R : Type u\nΓ₀ : Type v\ninst✝³ : CommRing R\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation R Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O R\nself : v.Integers O\nx : O\n⊢ LE.le (v ((algebraMap O R) x)) 1","decl":"/-- Given a valuation v : R → Γ₀ and a ring homomorphism O →+* R, we say that O is the integers of v\nif f is injective, and its range is exactly `v.integer`. -/\nstructure Integers : Prop where\n  hom_inj : Function.Injective (algebraMap O R)\n  map_le_one : ∀ x, v (algebraMap O R x) ≤ 1\n  exists_of_le_one : ∀ ⦃r⦄, v r ≤ 1 → ∃ x, algebraMap O R x = r\n\n-- typeclass shortcut\n"}
{"name":"Valuation.Integers.hom_inj","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"R : Type u\nΓ₀ : Type v\ninst✝³ : CommRing R\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation R Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O R\nself : v.Integers O\n⊢ Function.Injective ⇑(algebraMap O R)","decl":"/-- Given a valuation v : R → Γ₀ and a ring homomorphism O →+* R, we say that O is the integers of v\nif f is injective, and its range is exactly `v.integer`. -/\nstructure Integers : Prop where\n  hom_inj : Function.Injective (algebraMap O R)\n  map_le_one : ∀ x, v (algebraMap O R x) ≤ 1\n  exists_of_le_one : ∀ ⦃r⦄, v r ≤ 1 → ∃ x, algebraMap O R x = r\n\n-- typeclass shortcut\n"}
{"name":"Valuation.Integers.exists_of_le_one","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"R : Type u\nΓ₀ : Type v\ninst✝³ : CommRing R\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation R Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O R\nself : v.Integers O\nr : R\na✝ : LE.le (v r) 1\n⊢ Exists fun x => Eq ((algebraMap O R) x) r","decl":"/-- Given a valuation v : R → Γ₀ and a ring homomorphism O →+* R, we say that O is the integers of v\nif f is injective, and its range is exactly `v.integer`. -/\nstructure Integers : Prop where\n  hom_inj : Function.Injective (algebraMap O R)\n  map_le_one : ∀ x, v (algebraMap O R x) ≤ 1\n  exists_of_le_one : ∀ ⦃r⦄, v r ≤ 1 → ∃ x, algebraMap O R x = r\n\n-- typeclass shortcut\n"}
{"name":"Valuation.integer.integers","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"R : Type u\nΓ₀ : Type v\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation R Γ₀\n⊢ v.Integers (Subtype fun x => Membership.mem v.integer x)","decl":"theorem integer.integers : v.Integers v.integer :=\n  { hom_inj := Subtype.coe_injective\n    map_le_one := fun r => r.2\n    exists_of_le_one := fun r hr => ⟨⟨r, hr⟩, rfl⟩ }\n\n"}
{"name":"Valuation.Integers.one_of_isUnit'","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"R : Type u\nΓ₀ : Type v\ninst✝³ : CommRing R\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation R Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O R\nx : O\nhx : IsUnit x\nH : ∀ (x : O), LE.le (v ((algebraMap O R) x)) 1\n⊢ Eq (v ((algebraMap O R) x)) 1","decl":"theorem one_of_isUnit' {x : O} (hx : IsUnit x) (H : ∀ x, v (algebraMap O R x) ≤ 1) :\n    v (algebraMap O R x) = 1 :=\n  let ⟨u, hu⟩ := hx\n  le_antisymm (H _) <| by\n    rw [← v.map_one, ← (algebraMap O R).map_one, ← u.mul_inv, ← mul_one (v (algebraMap O R x)), hu,\n      (algebraMap O R).map_mul, v.map_mul]\n    exact mul_le_mul_left' (H (u⁻¹ : Units O)) _\n\n"}
{"name":"Valuation.Integers.one_of_isUnit","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"R : Type u\nΓ₀ : Type v\ninst✝³ : CommRing R\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation R Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O R\nhv : v.Integers O\nx : O\nhx : IsUnit x\n⊢ Eq (v ((algebraMap O R) x)) 1","decl":"theorem one_of_isUnit (hv : Integers v O) {x : O} (hx : IsUnit x) : v (algebraMap O R x) = 1 :=\n  one_of_isUnit' hx hv.map_le_one\n\n"}
{"name":"Valuation.Integers.isUnit_of_one","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"R : Type u\nΓ₀ : Type v\ninst✝³ : CommRing R\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation R Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O R\nhv : v.Integers O\nx : O\nhx : IsUnit ((algebraMap O R) x)\nhvx : Eq (v ((algebraMap O R) x)) 1\n⊢ IsUnit x","decl":"/--\nLet `O` be the integers of the valuation `v` on some commutative ring `R`. For every element `x` in\n`O`, `x` is a unit in `O` if and only if the image of `x` in `R` is a unit and has valuation 1.\n-/\ntheorem isUnit_of_one (hv : Integers v O) {x : O} (hx : IsUnit (algebraMap O R x))\n    (hvx : v (algebraMap O R x) = 1) : IsUnit x :=\n  let ⟨u, hu⟩ := hx\n  have h1 : v u ≤ 1 := hu.symm ▸ hv.2 x\n  have h2 : v (u⁻¹ : Rˣ) ≤ 1 := by\n    rw [← one_mul (v _), ← hvx, ← v.map_mul, ← hu, u.mul_inv, hu, hvx, v.map_one]\n  let ⟨r1, hr1⟩ := hv.3 h1\n  let ⟨r2, hr2⟩ := hv.3 h2\n  ⟨⟨r1, r2, hv.1 <| by rw [RingHom.map_mul, RingHom.map_one, hr1, hr2, Units.mul_inv],\n      hv.1 <| by rw [RingHom.map_mul, RingHom.map_one, hr1, hr2, Units.inv_mul]⟩,\n    hv.1 <| hr1.trans hu⟩\n\n"}
{"name":"Valuation.Integers.le_of_dvd","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"R : Type u\nΓ₀ : Type v\ninst✝³ : CommRing R\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation R Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O R\nhv : v.Integers O\nx y : O\nh : Dvd.dvd x y\n⊢ LE.le (v ((algebraMap O R) y)) (v ((algebraMap O R) x))","decl":"theorem le_of_dvd (hv : Integers v O) {x y : O} (h : x ∣ y) :\n    v (algebraMap O R y) ≤ v (algebraMap O R x) := by\n  let ⟨z, hz⟩ := h\n  rw [← mul_one (v (algebraMap O R x)), hz, RingHom.map_mul, v.map_mul]\n  exact mul_le_mul_left' (hv.2 z) _\n\n"}
{"name":"Valuation.Integers.dvd_of_le","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"F : Type u\nΓ₀ : Type v\ninst✝³ : Field F\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation F Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O F\nhv : v.Integers O\nx y : O\nh : LE.le (v ((algebraMap O F) x)) (v ((algebraMap O F) y))\n⊢ Dvd.dvd y x","decl":"theorem dvd_of_le (hv : Integers v O) {x y : O}\n    (h : v (algebraMap O F x) ≤ v (algebraMap O F y)) : y ∣ x :=\n  by_cases\n    (fun hy : algebraMap O F y = 0 =>\n      have hx : x = 0 :=\n        hv.1 <|\n          (algebraMap O F).map_zero.symm ▸ (v.zero_iff.1 <| le_zero_iff.1 (v.map_zero ▸ hy ▸ h))\n      hx.symm ▸ dvd_zero y)\n    fun hy : algebraMap O F y ≠ 0 =>\n    have : v ((algebraMap O F y)⁻¹ * algebraMap O F x) ≤ 1 := by\n      rw [← v.map_one, ← inv_mul_cancel₀ hy, v.map_mul, v.map_mul]\n      exact mul_le_mul_left' h _\n    let ⟨z, hz⟩ := hv.3 this\n    ⟨z, hv.1 <| ((algebraMap O F).map_mul y z).symm ▸ hz.symm ▸ (mul_inv_cancel_left₀ hy _).symm⟩\n\n"}
{"name":"Valuation.Integers.dvd_iff_le","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"F : Type u\nΓ₀ : Type v\ninst✝³ : Field F\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation F Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O F\nhv : v.Integers O\nx y : O\n⊢ Iff (Dvd.dvd x y) (LE.le (v ((algebraMap O F) y)) (v ((algebraMap O F) x)))","decl":"theorem dvd_iff_le (hv : Integers v O) {x y : O} :\n    x ∣ y ↔ v (algebraMap O F y) ≤ v (algebraMap O F x) :=\n  ⟨hv.le_of_dvd, hv.dvd_of_le⟩\n\n"}
{"name":"Valuation.Integers.le_iff_dvd","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"F : Type u\nΓ₀ : Type v\ninst✝³ : Field F\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation F Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O F\nhv : v.Integers O\nx y : O\n⊢ Iff (LE.le (v ((algebraMap O F) x)) (v ((algebraMap O F) y))) (Dvd.dvd y x)","decl":"theorem le_iff_dvd (hv : Integers v O) {x y : O} :\n    v (algebraMap O F x) ≤ v (algebraMap O F y) ↔ y ∣ x :=\n  ⟨hv.dvd_of_le, hv.le_of_dvd⟩\n\n"}
{"name":"Valuation.Integers.isUnit_of_one'","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"F : Type u\nΓ₀ : Type v\ninst✝³ : Field F\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation F Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O F\nhv : v.Integers O\nx : O\nhvx : Eq (v ((algebraMap O F) x)) 1\n⊢ IsUnit x","decl":"/--\nThis is the special case of `Valuation.Integers.isUnit_of_one` when the valuation is defined\nover a field. Let `v` be a valuation on some field `F` and `O` be its integers. For every element\n`x` in `O`, `x` is a unit in `O` if and only if the image of `x` in `F` has valuation 1.\n-/\ntheorem isUnit_of_one' (hv : Integers v O) {x : O} (hvx : v (algebraMap O F x) = 1) : IsUnit x := by\n  refine isUnit_of_one hv (IsUnit.mk0 _ ?_) hvx\n  simp only [← v.ne_zero_iff, hvx, ne_eq, one_ne_zero, not_false_eq_true]\n\n"}
{"name":"Valuation.Integers.isUnit_iff_valuation_eq_one","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"F : Type u\nΓ₀ : Type v\ninst✝³ : Field F\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation F Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O F\nhv : v.Integers O\nx : O\n⊢ Iff (IsUnit x) (Eq (v ((algebraMap O F) x)) 1)","decl":"lemma isUnit_iff_valuation_eq_one (hv : Integers v O) {x : O} :\n    IsUnit x ↔ v (algebraMap O F x) = 1 :=\n  ⟨hv.one_of_isUnit, hv.isUnit_of_one'⟩\n\n"}
{"name":"Valuation.Integers.valuation_unit","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"F : Type u\nΓ₀ : Type v\ninst✝³ : Field F\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation F Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O F\nhv : v.Integers O\nx : Units O\n⊢ Eq (v ((algebraMap O F) ↑x)) 1","decl":"lemma valuation_unit (hv : Integers v O) (x : Oˣ) :\n    v (algebraMap O F x) = 1 := by\n  simp [← hv.isUnit_iff_valuation_eq_one]\n\n"}
{"name":"Valuation.Integers.valuation_pos_iff_ne_zero","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"F : Type u\nΓ₀ : Type v\ninst✝³ : Field F\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation F Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O F\nhv : v.Integers O\nx : O\n⊢ Iff (LT.lt 0 (v ((algebraMap O F) x))) (Ne x 0)","decl":"lemma valuation_pos_iff_ne_zero (hv : Integers v O) {x : O} :\n    0 < v (algebraMap O F x) ↔ x ≠ 0 := by\n  rw [← not_le]\n  refine not_congr ?_\n  simp [map_eq_zero_iff _ hv.hom_inj]\n\n"}
{"name":"Valuation.Integers.dvdNotUnit_iff_lt","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"F : Type u\nΓ₀ : Type v\ninst✝³ : Field F\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation F Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O F\nhv : v.Integers O\nx y : O\n⊢ Iff (DvdNotUnit x y) (LT.lt (v ((algebraMap O F) y)) (v ((algebraMap O F) x)))","decl":"theorem dvdNotUnit_iff_lt (hv : Integers v O) {x y : O} :\n    DvdNotUnit x y ↔ v (algebraMap O F y) < v (algebraMap O F x) := by\n  rw [lt_iff_le_not_le, hv.le_iff_dvd, hv.le_iff_dvd]\n  refine ⟨?_, And.elim dvdNotUnit_of_dvd_of_not_dvd⟩\n  rintro ⟨hx0, d, hdu, rfl⟩\n  refine ⟨⟨d, rfl⟩, ?_⟩\n  rw [hv.isUnit_iff_valuation_eq_one, ← ne_eq, ne_iff_lt_iff_le.mpr (hv.map_le_one d)] at hdu\n  rw [dvd_iff_le hv]\n  simp only [_root_.map_mul, not_le]\n  contrapose! hdu\n  refine one_le_of_le_mul_left₀ ?_ hdu\n  simp [hv.valuation_pos_iff_ne_zero, hx0]\n\n"}
{"name":"Valuation.Integers.eq_algebraMap_or_inv_eq_algebraMap","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"F : Type u\nΓ₀ : Type v\ninst✝³ : Field F\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation F Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O F\nhv : v.Integers O\nx : F\n⊢ Exists fun a => Or (Eq x ((algebraMap O F) a)) (Eq (Inv.inv x) ((algebraMap O F) a))","decl":"theorem eq_algebraMap_or_inv_eq_algebraMap (hv : Integers v O) (x : F) :\n    ∃ a : O, x = algebraMap O F a ∨ x⁻¹ = algebraMap O F a := by\n  rcases val_le_one_or_val_inv_le_one v x with h | h <;>\n  obtain ⟨a, ha⟩ := exists_of_le_one hv h\n  exacts [⟨a, Or.inl ha.symm⟩, ⟨a, Or.inr ha.symm⟩]\n\n"}
{"name":"Valuation.Integers.bijective_algebraMap_of_subsingleton_units_mrange","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"F : Type u\nΓ₀ : Type v\ninst✝⁴ : Field F\ninst✝³ : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation F Γ₀\nO : Type w\ninst✝² : CommRing O\ninst✝¹ : Algebra O F\nhv : v.Integers O\ninst✝ : Subsingleton (Units (Subtype fun x => Membership.mem (MonoidHom.mrange v) x))\n⊢ Function.Bijective ⇑(algebraMap O F)","decl":"lemma bijective_algebraMap_of_subsingleton_units_mrange (hv : Integers v O)\n    [Subsingleton (MonoidHom.mrange v)ˣ] :\n    Function.Bijective (algebraMap O F) := by\n  refine ⟨hv.hom_inj, fun x ↦ hv.exists_of_le_one ?_⟩\n  rcases eq_or_ne x 0 with rfl|hx\n  · simp\n  · exact (congr_arg Units.val (Subsingleton.elim (α := (MonoidHom.mrange v)ˣ)\n      ((isUnit_iff_ne_zero.mpr hx).unit.map v.toMonoidHom.mrangeRestrict) 1)).le\n\n"}
{"name":"Valuation.Integers.isPrincipal_iff_exists_isGreatest","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"F : Type u\nΓ₀ : Type v\ninst✝³ : Field F\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation F Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O F\nhv : v.Integers O\nI : Ideal O\n⊢ Iff (Submodule.IsPrincipal I) (Exists fun x => IsGreatest (Set.image (Function.comp ⇑v ⇑(algebraMap O F)) ↑I) x)","decl":"lemma isPrincipal_iff_exists_isGreatest (hv : Integers v O) {I : Ideal O} :\n    I.IsPrincipal ↔ ∃ x, IsGreatest (v ∘ algebraMap O F '' I) x := by\n  constructor <;> rintro ⟨x, hx⟩\n  · refine ⟨(v ∘ algebraMap O F) x, ?_, ?_⟩\n    · refine Set.mem_image_of_mem _ ?_\n      simp [hx, Ideal.mem_span_singleton_self]\n    · intro y hy\n      simp only [Function.comp_apply, hx, Ideal.submodule_span_eq, Set.mem_image,\n        SetLike.mem_coe, Ideal.mem_span_singleton] at hy\n      obtain ⟨y, hy, rfl⟩ := hy\n      exact le_of_dvd hv hy\n  · obtain ⟨a, ha, rfl⟩ : ∃ a ∈ I, (v ∘ algebraMap O F) a = x := by simpa using hx.left\n    refine ⟨a, ?_⟩\n    ext b\n    simp only [Ideal.submodule_span_eq, Ideal.mem_span_singleton]\n    exact ⟨fun hb ↦ dvd_of_le hv (hx.2 <| mem_image_of_mem _ hb), fun hb ↦ I.mem_of_dvd hb ha⟩\n\n"}
{"name":"Valuation.Integers.isPrincipal_iff_exists_eq_setOf_valuation_le","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"F : Type u\nΓ₀ : Type v\ninst✝³ : Field F\ninst✝² : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation F Γ₀\nO : Type w\ninst✝¹ : CommRing O\ninst✝ : Algebra O F\nhv : v.Integers O\nI : Ideal O\n⊢ Iff (Submodule.IsPrincipal I) (Exists fun x => Eq (↑I) (setOf fun y => LE.le (v ((algebraMap O F) y)) (v ((algebraMap O F) x))))","decl":"lemma isPrincipal_iff_exists_eq_setOf_valuation_le (hv : Integers v O) {I : Ideal O} :\n    I.IsPrincipal ↔ ∃ x, (I : Set O) = {y | v (algebraMap O F y) ≤ v (algebraMap O F x)} := by\n  rw [isPrincipal_iff_exists_isGreatest hv]\n  constructor <;> rintro ⟨x, hx⟩\n  · obtain ⟨a, ha, rfl⟩ : ∃ a ∈ I, (v ∘ algebraMap O F) a = x := by simpa using hx.left\n    refine ⟨a, ?_⟩\n    ext b\n    simp only [SetLike.mem_coe, mem_setOf_eq]\n    constructor <;> intro h\n    · exact hx.right (Set.mem_image_of_mem _ h)\n    · rw [le_iff_dvd hv] at h\n      exact Ideal.mem_of_dvd I h ha\n  · refine ⟨v (algebraMap O F x), Set.mem_image_of_mem _ ?_, ?_⟩\n    · simp [hx]\n    · simp [hx, mem_upperBounds]\n\n"}
{"name":"Valuation.Integers.not_denselyOrdered_of_isPrincipalIdealRing","module":"Mathlib.RingTheory.Valuation.Integers","initialProofState":"F : Type u\nΓ₀ : Type v\ninst✝⁴ : Field F\ninst✝³ : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation F Γ₀\nO : Type w\ninst✝² : CommRing O\ninst✝¹ : Algebra O F\ninst✝ : IsPrincipalIdealRing O\nhv : v.Integers O\n⊢ Not (DenselyOrdered ↑(Set.range ⇑v))","decl":"lemma not_denselyOrdered_of_isPrincipalIdealRing [IsPrincipalIdealRing O] (hv : Integers v O) :\n    ¬ DenselyOrdered (range v) := by\n  intro H\n  -- nonunits as an ideal isn't defined here, nor shown to be equivalent to `v x < 1`\n  set I : Ideal O := {\n    carrier := v ∘ algebraMap O F ⁻¹' Iio (1 : Γ₀)\n    add_mem' := fun {a b} ha hb ↦ by simpa using map_add_lt v ha hb\n    zero_mem' := by simp\n    smul_mem' := by\n      intro c x\n      simp only [mem_preimage, Function.comp_apply, mem_Iio, smul_eq_mul, _root_.map_mul]\n      intro hx\n      exact Right.mul_lt_one_of_le_of_lt (hv.map_le_one c) hx\n  }\n  obtain ⟨x, hx₁, hx⟩ :\n    ∃ x, v (algebraMap O F x) < 1 ∧\n      v (algebraMap O F x) ∈ upperBounds (Iio 1 ∩ range (v ∘ algebraMap O F)) := by\n    simpa [I, IsGreatest, hv.isPrincipal_iff_exists_isGreatest, ← image_preimage_eq_inter_range]\n      using IsPrincipalIdealRing.principal I\n  obtain ⟨y, hy, hy₁⟩ : ∃ y, v (algebraMap O F x) < v y ∧ v y < 1 := by\n    simpa only [Subtype.exists, Subtype.mk_lt_mk, exists_range_iff, exists_prop]\n      using H.dense ⟨v (algebraMap O F x), mem_range_self _⟩ ⟨1, 1, v.map_one⟩ hx₁\n  obtain ⟨z, rfl⟩ := hv.exists_of_le_one hy₁.le\n  exact hy.not_le <| hx ⟨hy₁, mem_range_self _⟩\n\n"}
