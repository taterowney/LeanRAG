{"name":"MeasureTheory.condExp_ae_eq_restrict_zero","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Indicator","initialProofState":"α : Type u_1\nE : Type u_2\nm m0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nμ : MeasureTheory.Measure α\nf : α → E\ns : Set α\nhs : MeasurableSet s\nhf : (MeasureTheory.ae (μ.restrict s)).EventuallyEq f 0\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq (MeasureTheory.condExp m μ f) 0","decl":"theorem condExp_ae_eq_restrict_zero (hs : MeasurableSet[m] s) (hf : f =ᵐ[μ.restrict s] 0) :\n    μ[f|m] =ᵐ[μ.restrict s] 0 := by\n  by_cases hm : m ≤ m0\n  swap; · simp_rw [condExp_of_not_le hm]; rfl\n  by_cases hμm : SigmaFinite (μ.trim hm)\n  swap; · simp_rw [condExp_of_not_sigmaFinite hm hμm]; rfl\n  haveI : SigmaFinite (μ.trim hm) := hμm\n  have : SigmaFinite ((μ.restrict s).trim hm) := by\n    rw [← restrict_trim hm _ hs]\n    exact Restrict.sigmaFinite _ s\n  by_cases hf_int : Integrable f μ\n  swap; · rw [condExp_of_not_integrable hf_int]\n  refine ae_eq_of_forall_setIntegral_eq_of_sigmaFinite' hm ?_ ?_ ?_ ?_ ?_\n  · exact fun t _ _ => integrable_condExp.integrableOn.integrableOn\n  · exact fun t _ _ => (integrable_zero _ _ _).integrableOn\n  · intro t ht _\n    rw [Measure.restrict_restrict (hm _ ht), setIntegral_condExp hm hf_int (ht.inter hs), ←\n      Measure.restrict_restrict (hm _ ht)]\n    refine setIntegral_congr_ae (hm _ ht) ?_\n    filter_upwards [hf] with x hx _ using hx\n  · exact stronglyMeasurable_condExp.aestronglyMeasurable\n  · exact stronglyMeasurable_zero.aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.condexp_ae_eq_restrict_zero","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Indicator","initialProofState":"α : Type u_1\nE : Type u_2\nm m0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nμ : MeasureTheory.Measure α\nf : α → E\ns : Set α\nhs : MeasurableSet s\nhf : (MeasureTheory.ae (μ.restrict s)).EventuallyEq f 0\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq (MeasureTheory.condExp m μ f) 0","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_ae_eq_restrict_zero := condExp_ae_eq_restrict_zero\n\n"}
{"name":"MeasureTheory.condExp_indicator_aux","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Indicator","initialProofState":"α : Type u_1\nE : Type u_2\nm m0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nμ : MeasureTheory.Measure α\nf : α → E\ns : Set α\nhs : MeasurableSet s\nhf : (MeasureTheory.ae (μ.restrict (HasCompl.compl s))).EventuallyEq f 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (s.indicator f)) (s.indicator (MeasureTheory.condExp m μ f))","decl":"/-- Auxiliary lemma for `condExp_indicator`. -/\ntheorem condExp_indicator_aux (hs : MeasurableSet[m] s) (hf : f =ᵐ[μ.restrict sᶜ] 0) :\n    μ[s.indicator f|m] =ᵐ[μ] s.indicator (μ[f|m]) := by\n  by_cases hm : m ≤ m0\n  swap; · simp_rw [condExp_of_not_le hm, Set.indicator_zero']; rfl\n  have hsf_zero : ∀ g : α → E, g =ᵐ[μ.restrict sᶜ] 0 → s.indicator g =ᵐ[μ] g := fun g =>\n    indicator_ae_eq_of_restrict_compl_ae_eq_zero (hm _ hs)\n  refine ((hsf_zero (μ[f|m]) (condExp_ae_eq_restrict_zero hs.compl hf)).trans ?_).symm\n  exact condExp_congr_ae (hsf_zero f hf).symm\n\n"}
{"name":"MeasureTheory.condexp_indicator_aux","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Indicator","initialProofState":"α : Type u_1\nE : Type u_2\nm m0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nμ : MeasureTheory.Measure α\nf : α → E\ns : Set α\nhs : MeasurableSet s\nhf : (MeasureTheory.ae (μ.restrict (HasCompl.compl s))).EventuallyEq f 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (s.indicator f)) (s.indicator (MeasureTheory.condExp m μ f))","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_indicator_aux := condExp_indicator_aux\n\n"}
{"name":"MeasureTheory.condExp_indicator","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Indicator","initialProofState":"α : Type u_1\nE : Type u_2\nm m0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nμ : MeasureTheory.Measure α\nf : α → E\ns : Set α\nhf_int : MeasureTheory.Integrable f μ\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (s.indicator f)) (s.indicator (MeasureTheory.condExp m μ f))","decl":"/-- The conditional expectation of the indicator of a function over an `m`-measurable set with\nrespect to the σ-algebra `m` is a.e. equal to the indicator of the conditional expectation. -/\ntheorem condExp_indicator (hf_int : Integrable f μ) (hs : MeasurableSet[m] s) :\n    μ[s.indicator f|m] =ᵐ[μ] s.indicator (μ[f|m]) := by\n  by_cases hm : m ≤ m0\n  swap; · simp_rw [condExp_of_not_le hm, Set.indicator_zero']; rfl\n  by_cases hμm : SigmaFinite (μ.trim hm)\n  swap; · simp_rw [condExp_of_not_sigmaFinite hm hμm, Set.indicator_zero']; rfl\n  haveI : SigmaFinite (μ.trim hm) := hμm\n  -- use `have` to perform what should be the first calc step because of an error I don't\n  -- understand\n  have : s.indicator (μ[f|m]) =ᵐ[μ] s.indicator (μ[s.indicator f + sᶜ.indicator f|m]) := by\n    rw [Set.indicator_self_add_compl s f]\n  refine (this.trans ?_).symm\n  calc\n    s.indicator (μ[s.indicator f + sᶜ.indicator f|m]) =ᵐ[μ]\n        s.indicator (μ[s.indicator f|m] + μ[sᶜ.indicator f|m]) := by\n      filter_upwards [condExp_add (hf_int.indicator (hm _ hs)) (hf_int.indicator (hm _ hs.compl)) m]\n        with x hx\n      classical rw [Set.indicator_apply, Set.indicator_apply, hx]\n    _ = s.indicator (μ[s.indicator f|m]) + s.indicator (μ[sᶜ.indicator f|m]) :=\n      (s.indicator_add' _ _)\n    _ =ᵐ[μ] s.indicator (μ[s.indicator f|m]) +\n        s.indicator (sᶜ.indicator (μ[sᶜ.indicator f|m])) := by\n      refine Filter.EventuallyEq.rfl.add ?_\n      have : sᶜ.indicator (μ[sᶜ.indicator f|m]) =ᵐ[μ] μ[sᶜ.indicator f|m] := by\n        refine (condExp_indicator_aux hs.compl ?_).symm.trans ?_\n        · exact indicator_ae_eq_restrict_compl (hm _ hs.compl)\n        · rw [Set.indicator_indicator, Set.inter_self]\n      filter_upwards [this] with x hx\n      by_cases hxs : x ∈ s\n      · simp only [hx, hxs, Set.indicator_of_mem]\n      · simp only [hxs, Set.indicator_of_not_mem, not_false_iff]\n    _ =ᵐ[μ] s.indicator (μ[s.indicator f|m]) := by\n      rw [Set.indicator_indicator, Set.inter_compl_self, Set.indicator_empty', add_zero]\n    _ =ᵐ[μ] μ[s.indicator f|m] := by\n      refine (condExp_indicator_aux hs ?_).symm.trans ?_\n      · exact indicator_ae_eq_restrict_compl (hm _ hs)\n      · rw [Set.indicator_indicator, Set.inter_self]\n\n"}
{"name":"MeasureTheory.condexp_indicator","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Indicator","initialProofState":"α : Type u_1\nE : Type u_2\nm m0 : MeasurableSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nμ : MeasureTheory.Measure α\nf : α → E\ns : Set α\nhf_int : MeasureTheory.Integrable f μ\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m μ (s.indicator f)) (s.indicator (MeasureTheory.condExp m μ f))","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_indicator := condExp_indicator\n\n"}
{"name":"MeasureTheory.condExp_restrict_ae_eq_restrict","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Indicator","initialProofState":"α : Type u_1\nE : Type u_2\nm m0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\nf : α → E\ns : Set α\nhm : LE.le m m0\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hm)\nhs_m : MeasurableSet s\nhf_int : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq (MeasureTheory.condExp m (μ.restrict s) f) (MeasureTheory.condExp m μ f)","decl":"theorem condExp_restrict_ae_eq_restrict (hm : m ≤ m0) [SigmaFinite (μ.trim hm)]\n    (hs_m : MeasurableSet[m] s) (hf_int : Integrable f μ) :\n    (μ.restrict s)[f|m] =ᵐ[μ.restrict s] μ[f|m] := by\n  have : SigmaFinite ((μ.restrict s).trim hm) := by rw [← restrict_trim hm _ hs_m]; infer_instance\n  rw [ae_eq_restrict_iff_indicator_ae_eq (hm _ hs_m)]\n  refine EventuallyEq.trans ?_ (condExp_indicator hf_int hs_m)\n  refine ae_eq_condExp_of_forall_setIntegral_eq hm (hf_int.indicator (hm _ hs_m)) ?_ ?_ ?_\n  · intro t ht _\n    rw [← integrable_indicator_iff (hm _ ht), Set.indicator_indicator, Set.inter_comm, ←\n      Set.indicator_indicator]\n    suffices h_int_restrict : Integrable (t.indicator ((μ.restrict s)[f|m])) (μ.restrict s) by\n      rw [integrable_indicator_iff (hm _ hs_m), IntegrableOn]\n      exact h_int_restrict\n    exact integrable_condExp.indicator (hm _ ht)\n  · intro t ht _\n    calc\n      ∫ x in t, s.indicator ((μ.restrict s)[f|m]) x ∂μ =\n          ∫ x in t, ((μ.restrict s)[f|m]) x ∂μ.restrict s := by\n        rw [integral_indicator (hm _ hs_m), Measure.restrict_restrict (hm _ hs_m),\n          Measure.restrict_restrict (hm _ ht), Set.inter_comm]\n      _ = ∫ x in t, f x ∂μ.restrict s := setIntegral_condExp hm hf_int.integrableOn ht\n      _ = ∫ x in t, s.indicator f x ∂μ := by\n        rw [integral_indicator (hm _ hs_m), Measure.restrict_restrict (hm _ hs_m),\n          Measure.restrict_restrict (hm _ ht), Set.inter_comm]\n  · exact (stronglyMeasurable_condExp.indicator hs_m).aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.condexp_restrict_ae_eq_restrict","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Indicator","initialProofState":"α : Type u_1\nE : Type u_2\nm m0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure α\nf : α → E\ns : Set α\nhm : LE.le m m0\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hm)\nhs_m : MeasurableSet s\nhf_int : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq (MeasureTheory.condExp m (μ.restrict s) f) (MeasureTheory.condExp m μ f)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_restrict_ae_eq_restrict := condExp_restrict_ae_eq_restrict\n\n"}
{"name":"MeasureTheory.condExp_ae_eq_restrict_of_measurableSpace_eq_on","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Indicator","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\nf : α → E\ns : Set α\nm m₂ m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\nhm₂ : LE.le m₂ m0\ninst✝¹ : MeasureTheory.SigmaFinite (μ.trim hm)\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hm₂)\nhs_m : MeasurableSet s\nhs : ∀ (t : Set α), Iff (MeasurableSet (Inter.inter s t)) (MeasurableSet (Inter.inter s t))\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq (MeasureTheory.condExp m μ f) (MeasureTheory.condExp m₂ μ f)","decl":"/-- If the restriction to an `m`-measurable set `s` of a σ-algebra `m` is equal to the restriction\nto `s` of another σ-algebra `m₂` (hypothesis `hs`), then `μ[f | m] =ᵐ[μ.restrict s] μ[f | m₂]`. -/\ntheorem condExp_ae_eq_restrict_of_measurableSpace_eq_on {m m₂ m0 : MeasurableSpace α}\n    {μ : Measure α} (hm : m ≤ m0) (hm₂ : m₂ ≤ m0) [SigmaFinite (μ.trim hm)]\n    [SigmaFinite (μ.trim hm₂)] (hs_m : MeasurableSet[m] s)\n    (hs : ∀ t, MeasurableSet[m] (s ∩ t) ↔ MeasurableSet[m₂] (s ∩ t)) :\n    μ[f|m] =ᵐ[μ.restrict s] μ[f|m₂] := by\n  rw [ae_eq_restrict_iff_indicator_ae_eq (hm _ hs_m)]\n  have hs_m₂ : MeasurableSet[m₂] s := by rwa [← Set.inter_univ s, ← hs Set.univ, Set.inter_univ]\n  by_cases hf_int : Integrable f μ\n  swap; · simp_rw [condExp_of_not_integrable hf_int]; rfl\n  refine ((condExp_indicator hf_int hs_m).symm.trans ?_).trans (condExp_indicator hf_int hs_m₂)\n  refine ae_eq_of_forall_setIntegral_eq_of_sigmaFinite' hm₂\n    (fun s _ _ => integrable_condExp.integrableOn)\n    (fun s _ _ => integrable_condExp.integrableOn) ?_ ?_\n    stronglyMeasurable_condExp.aestronglyMeasurable\n  swap\n  · have : StronglyMeasurable[m] (μ[s.indicator f|m]) := stronglyMeasurable_condExp\n    refine this.aestronglyMeasurable.of_measurableSpace_le_on hm hs_m (fun t => (hs t).mp) ?_\n    exact condExp_ae_eq_restrict_zero hs_m.compl (indicator_ae_eq_restrict_compl (hm _ hs_m))\n  intro t ht _\n  have : ∫ x in t, (μ[s.indicator f|m]) x ∂μ = ∫ x in s ∩ t, (μ[s.indicator f|m]) x ∂μ := by\n    rw [← integral_add_compl (hm _ hs_m) integrable_condExp.integrableOn]\n    suffices ∫ x in sᶜ, (μ[s.indicator f|m]) x ∂μ.restrict t = 0 by\n      rw [this, add_zero, Measure.restrict_restrict (hm _ hs_m)]\n    rw [Measure.restrict_restrict (MeasurableSet.compl (hm _ hs_m))]\n    suffices μ[s.indicator f|m] =ᵐ[μ.restrict sᶜ] 0 by\n      rw [Set.inter_comm, ← Measure.restrict_restrict (hm₂ _ ht)]\n      calc\n        ∫ x : α in t, (μ[s.indicator f|m]) x ∂μ.restrict sᶜ =\n            ∫ x : α in t, 0 ∂μ.restrict sᶜ := by\n          refine setIntegral_congr_ae (hm₂ _ ht) ?_\n          filter_upwards [this] with x hx _ using hx\n        _ = 0 := integral_zero _ _\n    refine condExp_ae_eq_restrict_zero hs_m.compl ?_\n    exact indicator_ae_eq_restrict_compl (hm _ hs_m)\n  have hst_m : MeasurableSet[m] (s ∩ t) := (hs _).mpr (hs_m₂.inter ht)\n  simp_rw [this, setIntegral_condExp hm₂ (hf_int.indicator (hm _ hs_m)) ht,\n    setIntegral_condExp hm (hf_int.indicator (hm _ hs_m)) hst_m, integral_indicator (hm _ hs_m),\n    Measure.restrict_restrict (hm _ hs_m), ← Set.inter_assoc, Set.inter_self]\n\n"}
{"name":"MeasureTheory.condexp_ae_eq_restrict_of_measurableSpace_eq_on","module":"Mathlib.MeasureTheory.Function.ConditionalExpectation.Indicator","initialProofState":"α : Type u_1\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\nf : α → E\ns : Set α\nm m₂ m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\nhm₂ : LE.le m₂ m0\ninst✝¹ : MeasureTheory.SigmaFinite (μ.trim hm)\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hm₂)\nhs_m : MeasurableSet s\nhs : ∀ (t : Set α), Iff (MeasurableSet (Inter.inter s t)) (MeasurableSet (Inter.inter s t))\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq (MeasureTheory.condExp m μ f) (MeasureTheory.condExp m₂ μ f)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_ae_eq_restrict_of_measurableSpace_eq_on :=\n  condExp_ae_eq_restrict_of_measurableSpace_eq_on\n\n"}
