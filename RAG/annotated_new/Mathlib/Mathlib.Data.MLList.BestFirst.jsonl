{"name":"BestFirstNode.mk.sizeOf_spec","module":"Mathlib.Data.MLList.BestFirst","initialProofState":"α : Sort u_1\nω : Type u_2\nprio : α → Thunk ω\nε : α → Type\ninst✝² : SizeOf α\ninst✝¹ : SizeOf ω\ninst✝ : (a : α) → SizeOf (ε a)\nkey : α\nestimator : ε key\n⊢ Eq (SizeOf.sizeOf { key := key, estimator := estimator }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf key)) (SizeOf.sizeOf estimator))","decl":"/-- A node in a `BestFirstQueue`. -/\nstructure BestFirstNode {α : Sort*} {ω : Type*} (prio : α → Thunk ω) (ε : α → Type) where\n  /-- The data to store at a node, from which we can calculate a priority using `prio`. -/\n  key : α\n  /-- An estimator for the priority of the key.\n  (We will assume we have `[∀ a : α, Estimator (prio a) (ε a)]`.) -/\n  estimator : ε key\n\n"}
{"name":"BestFirstNode.mk.injEq","module":"Mathlib.Data.MLList.BestFirst","initialProofState":"α : Sort u_1\nω : Type u_2\nprio : α → Thunk ω\nε : α → Type\nkey✝ : α\nestimator✝ : ε key✝\nkey : α\nestimator : ε key\n⊢ Eq (Eq { key := key✝, estimator := estimator✝ } { key := key, estimator := estimator }) (And (Eq key✝ key) (HEq estimator✝ estimator))","decl":"/-- A node in a `BestFirstQueue`. -/\nstructure BestFirstNode {α : Sort*} {ω : Type*} (prio : α → Thunk ω) (ε : α → Type) where\n  /-- The data to store at a node, from which we can calculate a priority using `prio`. -/\n  key : α\n  /-- An estimator for the priority of the key.\n  (We will assume we have `[∀ a : α, Estimator (prio a) (ε a)]`.) -/\n  estimator : ε key\n\n"}
{"name":"BestFirstNode.mk.inj","module":"Mathlib.Data.MLList.BestFirst","initialProofState":"α : Sort u_1\nω : Type u_2\nprio : α → Thunk ω\nε : α → Type\nkey✝ : α\nestimator✝ : ε key✝\nkey : α\nestimator : ε key\nx✝ : Eq { key := key✝, estimator := estimator✝ } { key := key, estimator := estimator }\n⊢ And (Eq key✝ key) (HEq estimator✝ estimator)","decl":"/-- A node in a `BestFirstQueue`. -/\nstructure BestFirstNode {α : Sort*} {ω : Type*} (prio : α → Thunk ω) (ε : α → Type) where\n  /-- The data to store at a node, from which we can calculate a priority using `prio`. -/\n  key : α\n  /-- An estimator for the priority of the key.\n  (We will assume we have `[∀ a : α, Estimator (prio a) (ε a)]`.) -/\n  estimator : ε key\n\n"}
