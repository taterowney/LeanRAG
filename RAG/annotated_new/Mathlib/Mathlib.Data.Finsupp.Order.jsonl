{"name":"Finsupp.sum_le_sum","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : Zero α\ninst✝ : OrderedAddCommMonoid β\nf : Finsupp ι α\nh₁ h₂ : ι → α → β\nh : ∀ (i : ι), Membership.mem f.support i → LE.le (h₁ i (f i)) (h₂ i (f i))\n⊢ LE.le (f.sum h₁) (f.sum h₂)","decl":"@[gcongr]\nlemma sum_le_sum (h : ∀ i ∈ f.support, h₁ i (f i) ≤ h₂ i (f i)) : f.sum h₁ ≤ f.sum h₂ :=\n  Finset.sum_le_sum h\n\n"}
{"name":"Finsupp.le_def","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : LE α\nf g : Finsupp ι α\n⊢ Iff (LE.le f g) (∀ (i : ι), LE.le (f i) (g i))","decl":"lemma le_def : f ≤ g ↔ ∀ i, f i ≤ g i := Iff.rfl\n\n"}
{"name":"Finsupp.coe_le_coe","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : LE α\nf g : Finsupp ι α\n⊢ Iff (LE.le ⇑f ⇑g) (LE.le f g)","decl":"@[simp, norm_cast] lemma coe_le_coe : ⇑f ≤ g ↔ f ≤ g := Iff.rfl\n\n"}
{"name":"Finsupp.orderEmbeddingToFun_apply","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : LE α\nf : Finsupp ι α\ni : ι\n⊢ Eq (Finsupp.orderEmbeddingToFun f i) (f i)","decl":"@[simp]\ntheorem orderEmbeddingToFun_apply {f : ι →₀ α} {i : ι} : orderEmbeddingToFun f i = f i :=\n  rfl\n\n"}
{"name":"Finsupp.lt_def","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : Preorder α\nf g : Finsupp ι α\n⊢ Iff (LT.lt f g) (And (LE.le f g) (Exists fun i => LT.lt (f i) (g i)))","decl":"lemma lt_def : f < g ↔ f ≤ g ∧ ∃ i, f i < g i := Pi.lt_def\n"}
{"name":"Finsupp.coe_lt_coe","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : Preorder α\nf g : Finsupp ι α\n⊢ Iff (LT.lt ⇑f ⇑g) (LT.lt f g)","decl":"@[simp, norm_cast] lemma coe_lt_coe : ⇑f < g ↔ f < g := Iff.rfl\n\n"}
{"name":"Finsupp.coe_mono","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : Preorder α\n⊢ Monotone Finsupp.toFun","decl":"lemma coe_mono : Monotone (Finsupp.toFun : (ι →₀ α) → ι → α) := fun _ _ ↦ id\n\n"}
{"name":"Finsupp.coe_strictMono","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : Preorder α\n⊢ Monotone Finsupp.toFun","decl":"lemma coe_strictMono : Monotone (Finsupp.toFun : (ι →₀ α) → ι → α) := fun _ _ ↦ id\n\n"}
{"name":"Finsupp.single_le_single","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : Preorder α\ni : ι\na b : α\n⊢ Iff (LE.le (Finsupp.single i a) (Finsupp.single i b)) (LE.le a b)","decl":"@[simp] lemma single_le_single : single i a ≤ single i b ↔ a ≤ b := by\n  classical exact Pi.single_le_single\n\n"}
{"name":"Finsupp.single_mono","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : Preorder α\ni : ι\n⊢ Monotone (Finsupp.single i)","decl":"lemma single_mono : Monotone (single i : α → ι →₀ α) := fun _ _ ↦ single_le_single.2\n\n"}
{"name":"Finsupp.GCongr.single_mono","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : Preorder α\ni : ι\na b : α\na✝ : LE.le a b\n⊢ LE.le (Finsupp.single i a) (Finsupp.single i b)","decl":"@[gcongr] protected alias ⟨_, GCongr.single_mono⟩ := single_le_single\n\n"}
{"name":"Finsupp.single_nonneg","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : Preorder α\ni : ι\na : α\n⊢ Iff (LE.le 0 (Finsupp.single i a)) (LE.le 0 a)","decl":"@[simp] lemma single_nonneg : 0 ≤ single i a ↔ 0 ≤ a := by classical exact Pi.single_nonneg\n"}
{"name":"Finsupp.single_nonpos","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : Preorder α\ni : ι\na : α\n⊢ Iff (LE.le (Finsupp.single i a) 0) (LE.le a 0)","decl":"@[simp] lemma single_nonpos : single i a ≤ 0 ↔ a ≤ 0 := by classical exact Pi.single_nonpos\n\n"}
{"name":"Finsupp.sum_le_sum_index","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝³ : Zero α\ninst✝² : Preorder α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : DecidableEq ι\nf₁ f₂ : Finsupp ι α\nh : ι → α → β\nhf : LE.le f₁ f₂\nhh : ∀ (i : ι), Membership.mem (Union.union f₁.support f₂.support) i → Monotone (h i)\nhh₀ : ∀ (i : ι), Membership.mem (Union.union f₁.support f₂.support) i → Eq (h i 0) 0\n⊢ LE.le (f₁.sum h) (f₂.sum h)","decl":"lemma sum_le_sum_index [DecidableEq ι] {f₁ f₂ : ι →₀ α} {h : ι → α → β} (hf : f₁ ≤ f₂)\n    (hh : ∀ i ∈ f₁.support ∪ f₂.support, Monotone (h i))\n    (hh₀ : ∀ i ∈ f₁.support ∪ f₂.support, h i 0 = 0) : f₁.sum h ≤ f₂.sum h := by\n  classical\n  rw [sum_of_support_subset _ Finset.subset_union_left _ hh₀,\n    sum_of_support_subset _ Finset.subset_union_right _ hh₀]\n  exact Finset.sum_le_sum fun i hi ↦ hh _ hi <| hf _\n\n"}
{"name":"Finsupp.inf_apply","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : SemilatticeInf α\ni : ι\nf g : Finsupp ι α\n⊢ Eq ((Min.min f g) i) (Min.min (f i) (g i))","decl":"@[simp]\ntheorem inf_apply [SemilatticeInf α] {i : ι} {f g : ι →₀ α} : (f ⊓ g) i = f i ⊓ g i :=\n  rfl\n\n"}
{"name":"Finsupp.sup_apply","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : Zero α\ninst✝ : SemilatticeSup α\ni : ι\nf g : Finsupp ι α\n⊢ Eq ((Max.max f g) i) (Max.max (f i) (g i))","decl":"@[simp]\ntheorem sup_apply [SemilatticeSup α] {i : ι} {f g : ι →₀ α} : (f ⊔ g) i = f i ⊔ g i :=\n  rfl\n\n"}
{"name":"Finsupp.support_inf_union_support_sup","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : Zero α\ninst✝¹ : DecidableEq ι\ninst✝ : Lattice α\nf g : Finsupp ι α\n⊢ Eq (Union.union (Min.min f g).support (Max.max f g).support) (Union.union f.support g.support)","decl":"theorem support_inf_union_support_sup : (f ⊓ g).support ∪ (f ⊔ g).support = f.support ∪ g.support :=\n  coe_injective <| compl_injective <| by ext; simp [inf_eq_and_sup_eq_iff]\n\n"}
{"name":"Finsupp.support_sup_union_support_inf","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : Zero α\ninst✝¹ : DecidableEq ι\ninst✝ : Lattice α\nf g : Finsupp ι α\n⊢ Eq (Union.union (Max.max f g).support (Min.min f g).support) (Union.union f.support g.support)","decl":"theorem support_sup_union_support_inf : (f ⊔ g).support ∪ (f ⊓ g).support = f.support ∪ g.support :=\n  (union_comm _ _).trans <| support_inf_union_support_sup _ _\n\n"}
{"name":"Finsupp.mapDomain_mono","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nκ : Type u_2\nα : Type u_3\ninst✝ : OrderedAddCommMonoid α\nf : ι → κ\n⊢ Monotone (Finsupp.mapDomain f)","decl":"lemma mapDomain_mono : Monotone (mapDomain f : (ι →₀ α) → (κ →₀ α)) := by\n  classical exact fun g₁ g₂ h ↦ sum_le_sum_index h (fun _ _ ↦ single_mono) (by simp)\n\n"}
{"name":"Finsupp.GCongr.mapDomain_mono","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nκ : Type u_2\nα : Type u_3\ninst✝ : OrderedAddCommMonoid α\nf : ι → κ\ng₁ g₂ : Finsupp ι α\nhg : LE.le g₁ g₂\n⊢ LE.le (Finsupp.mapDomain f g₁) (Finsupp.mapDomain f g₂)","decl":"@[gcongr] protected lemma GCongr.mapDomain_mono (hg : g₁ ≤ g₂) : g₁.mapDomain f ≤ g₂.mapDomain f :=\n  mapDomain_mono hg\n\n"}
{"name":"Finsupp.mapDomain_nonneg","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nκ : Type u_2\nα : Type u_3\ninst✝ : OrderedAddCommMonoid α\nf : ι → κ\ng : Finsupp ι α\nhg : LE.le 0 g\n⊢ LE.le 0 (Finsupp.mapDomain f g)","decl":"lemma mapDomain_nonneg (hg : 0 ≤ g) : 0 ≤ g.mapDomain f := by simpa using mapDomain_mono hg\n"}
{"name":"Finsupp.mapDomain_nonpos","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nκ : Type u_2\nα : Type u_3\ninst✝ : OrderedAddCommMonoid α\nf : ι → κ\ng : Finsupp ι α\nhg : LE.le g 0\n⊢ LE.le (Finsupp.mapDomain f g) 0","decl":"lemma mapDomain_nonpos (hg : g ≤ 0) : g.mapDomain f ≤ 0 := by simpa using mapDomain_mono hg\n\n"}
{"name":"Finsupp.addLeftReflectLE","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : OrderedAddCommMonoid α\ninst✝ : AddLeftReflectLE α\n⊢ AddLeftReflectLE (Finsupp ι α)","decl":"instance addLeftReflectLE [OrderedAddCommMonoid α] [AddLeftReflectLE α] :\n    AddLeftReflectLE (ι →₀ α) :=\n  ⟨fun _f _g _h H x => le_of_add_le_add_left <| H x⟩\n\n"}
{"name":"Finsupp.instPosSMulMono","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝⁵ : Zero α\ninst✝⁴ : Preorder α\ninst✝³ : Zero β\ninst✝² : Preorder β\ninst✝¹ : SMulZeroClass α β\ninst✝ : PosSMulMono α β\n⊢ PosSMulMono α (Finsupp ι β)","decl":"instance instPosSMulMono [PosSMulMono α β] : PosSMulMono α (ι →₀ β) :=\n  PosSMulMono.lift _ coe_le_coe coe_smul\n\n"}
{"name":"Finsupp.instSMulPosMono","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝⁴ : Preorder α\ninst✝³ : Zero β\ninst✝² : Preorder β\ninst✝¹ : SMulZeroClass α β\ninst✝ : SMulPosMono α β\n⊢ SMulPosMono α (Finsupp ι β)","decl":"instance instSMulPosMono [SMulPosMono α β] : SMulPosMono α (ι →₀ β) :=\n  SMulPosMono.lift _ coe_le_coe coe_smul coe_zero\n\n"}
{"name":"Finsupp.instPosSMulReflectLE","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝⁵ : Zero α\ninst✝⁴ : Preorder α\ninst✝³ : Zero β\ninst✝² : Preorder β\ninst✝¹ : SMulZeroClass α β\ninst✝ : PosSMulReflectLE α β\n⊢ PosSMulReflectLE α (Finsupp ι β)","decl":"instance instPosSMulReflectLE [PosSMulReflectLE α β] : PosSMulReflectLE α (ι →₀ β) :=\n  PosSMulReflectLE.lift _ coe_le_coe coe_smul\n\n"}
{"name":"Finsupp.instSMulPosReflectLE","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝⁴ : Preorder α\ninst✝³ : Zero β\ninst✝² : Preorder β\ninst✝¹ : SMulZeroClass α β\ninst✝ : SMulPosReflectLE α β\n⊢ SMulPosReflectLE α (Finsupp ι β)","decl":"instance instSMulPosReflectLE [SMulPosReflectLE α β] : SMulPosReflectLE α (ι →₀ β) :=\n  SMulPosReflectLE.lift _ coe_le_coe coe_smul coe_zero\n\n"}
{"name":"Finsupp.instPosSMulStrictMono","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝⁵ : Zero α\ninst✝⁴ : PartialOrder α\ninst✝³ : Zero β\ninst✝² : PartialOrder β\ninst✝¹ : SMulWithZero α β\ninst✝ : PosSMulStrictMono α β\n⊢ PosSMulStrictMono α (Finsupp ι β)","decl":"instance instPosSMulStrictMono [PosSMulStrictMono α β] : PosSMulStrictMono α (ι →₀ β) :=\n  PosSMulStrictMono.lift _ coe_le_coe coe_smul\n\n"}
{"name":"Finsupp.instSMulPosStrictMono","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝⁵ : Zero α\ninst✝⁴ : PartialOrder α\ninst✝³ : Zero β\ninst✝² : PartialOrder β\ninst✝¹ : SMulWithZero α β\ninst✝ : SMulPosStrictMono α β\n⊢ SMulPosStrictMono α (Finsupp ι β)","decl":"instance instSMulPosStrictMono [SMulPosStrictMono α β] : SMulPosStrictMono α (ι →₀ β) :=\n  SMulPosStrictMono.lift _ coe_le_coe coe_smul coe_zero\n\n-- `PosSMulReflectLT α (ι →₀ β)` already follows from the other instances\n\n"}
{"name":"Finsupp.instSMulPosReflectLT","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝⁵ : Zero α\ninst✝⁴ : PartialOrder α\ninst✝³ : Zero β\ninst✝² : PartialOrder β\ninst✝¹ : SMulWithZero α β\ninst✝ : SMulPosReflectLT α β\n⊢ SMulPosReflectLT α (Finsupp ι β)","decl":"instance instSMulPosReflectLT [SMulPosReflectLT α β] : SMulPosReflectLT α (ι →₀ β) :=\n  SMulPosReflectLT.lift _ coe_le_coe coe_smul coe_zero\n\n"}
{"name":"Finsupp.bot_eq_zero","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : AddCommMonoid α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\n⊢ Eq Bot.bot 0","decl":"protected theorem bot_eq_zero : (⊥ : ι →₀ α) = 0 :=\n  rfl\n\n"}
{"name":"Finsupp.add_eq_zero_iff","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : AddCommMonoid α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\nf g : Finsupp ι α\n⊢ Iff (Eq (HAdd.hAdd f g) 0) (And (Eq f 0) (Eq g 0))","decl":"@[simp]\ntheorem add_eq_zero_iff (f g : ι →₀ α) : f + g = 0 ↔ f = 0 ∧ g = 0 := by\n  simp [DFunLike.ext_iff, forall_and]\n\n"}
{"name":"Finsupp.le_iff'","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : AddCommMonoid α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\nf g : Finsupp ι α\ns : Finset ι\nhf : HasSubset.Subset f.support s\n⊢ Iff (LE.le f g) (∀ (i : ι), Membership.mem s i → LE.le (f i) (g i))","decl":"theorem le_iff' (f g : ι →₀ α) {s : Finset ι} (hf : f.support ⊆ s) : f ≤ g ↔ ∀ i ∈ s, f i ≤ g i :=\n  ⟨fun h s _hs => h s, fun h s => by\n    classical exact\n        if H : s ∈ f.support then h s (hf H) else (not_mem_support_iff.1 H).symm ▸ zero_le (g s)⟩\n\n"}
{"name":"Finsupp.le_iff","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : AddCommMonoid α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\nf g : Finsupp ι α\n⊢ Iff (LE.le f g) (∀ (i : ι), Membership.mem f.support i → LE.le (f i) (g i))","decl":"theorem le_iff (f g : ι →₀ α) : f ≤ g ↔ ∀ i ∈ f.support, f i ≤ g i :=\n  le_iff' f g <| Subset.refl _\n\n"}
{"name":"Finsupp.support_monotone","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : AddCommMonoid α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\n⊢ Monotone Finsupp.support","decl":"lemma support_monotone : Monotone (support (α := ι) (M := α)) :=\n  fun f g h a ha ↦ by rw [mem_support_iff, ← pos_iff_ne_zero] at ha ⊢; exact ha.trans_le (h _)\n\n"}
{"name":"Finsupp.support_mono","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : AddCommMonoid α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\nf g : Finsupp ι α\nhfg : LE.le f g\n⊢ HasSubset.Subset f.support g.support","decl":"lemma support_mono (hfg : f ≤ g) : f.support ⊆ g.support := support_monotone hfg\n\n"}
{"name":"Finsupp.single_le_iff","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : AddCommMonoid α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\ni : ι\nx : α\nf : Finsupp ι α\n⊢ Iff (LE.le (Finsupp.single i x) f) (LE.le x (f i))","decl":"@[simp]\ntheorem single_le_iff {i : ι} {x : α} {f : ι →₀ α} : single i x ≤ f ↔ x ≤ f i :=\n  (le_iff' _ _ support_single_subset).trans <| by simp\n\n"}
{"name":"Finsupp.orderedSub","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝⁴ : AddCommMonoid α\ninst✝³ : PartialOrder α\ninst✝² : CanonicallyOrderedAdd α\ninst✝¹ : Sub α\ninst✝ : OrderedSub α\n⊢ OrderedSub (Finsupp ι α)","decl":"instance orderedSub : OrderedSub (ι →₀ α) :=\n  ⟨fun _n _m _k => forall_congr' fun _x => tsub_le_iff_right⟩\n\n"}
{"name":"Finsupp.instCanonicallyOrderedAddOfCovariantClassHAddLe","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : PartialOrder α\ninst✝³ : CanonicallyOrderedAdd α\ninst✝² : Sub α\ninst✝¹ : OrderedSub α\ninst✝ : CovariantClass α α (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\n⊢ CanonicallyOrderedAdd (Finsupp ι α)","decl":"instance [CovariantClass α α (· + ·) (· ≤ ·)] : CanonicallyOrderedAdd (ι →₀ α) where\n  exists_add_of_le := fun {f g} h => ⟨g - f, ext fun x => (add_tsub_cancel_of_le <| h x).symm⟩\n  le_self_add := fun _f _g _x => le_self_add\n\n"}
{"name":"Finsupp.coe_tsub","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝⁴ : AddCommMonoid α\ninst✝³ : PartialOrder α\ninst✝² : CanonicallyOrderedAdd α\ninst✝¹ : Sub α\ninst✝ : OrderedSub α\nf g : Finsupp ι α\n⊢ Eq (⇑(HSub.hSub f g)) (HSub.hSub ⇑f ⇑g)","decl":"@[simp, norm_cast] lemma coe_tsub (f g : ι →₀ α) : ⇑(f - g) = f - g := rfl\n\n"}
{"name":"Finsupp.tsub_apply","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝⁴ : AddCommMonoid α\ninst✝³ : PartialOrder α\ninst✝² : CanonicallyOrderedAdd α\ninst✝¹ : Sub α\ninst✝ : OrderedSub α\nf g : Finsupp ι α\na : ι\n⊢ Eq ((HSub.hSub f g) a) (HSub.hSub (f a) (g a))","decl":"theorem tsub_apply (f g : ι →₀ α) (a : ι) : (f - g) a = f a - g a :=\n  rfl\n\n"}
{"name":"Finsupp.single_tsub","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝⁴ : AddCommMonoid α\ninst✝³ : PartialOrder α\ninst✝² : CanonicallyOrderedAdd α\ninst✝¹ : Sub α\ninst✝ : OrderedSub α\ni : ι\na b : α\n⊢ Eq (Finsupp.single i (HSub.hSub a b)) (HSub.hSub (Finsupp.single i a) (Finsupp.single i b))","decl":"@[simp]\ntheorem single_tsub : single i (a - b) = single i a - single i b := by\n  ext j\n  obtain rfl | h := eq_or_ne i j\n  · rw [tsub_apply, single_eq_same, single_eq_same, single_eq_same]\n  · rw [tsub_apply, single_eq_of_ne h, single_eq_of_ne h, single_eq_of_ne h, tsub_self]\n\n"}
{"name":"Finsupp.support_tsub","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝⁴ : AddCommMonoid α\ninst✝³ : PartialOrder α\ninst✝² : CanonicallyOrderedAdd α\ninst✝¹ : Sub α\ninst✝ : OrderedSub α\nf1 f2 : Finsupp ι α\n⊢ HasSubset.Subset (HSub.hSub f1 f2).support f1.support","decl":"theorem support_tsub {f1 f2 : ι →₀ α} : (f1 - f2).support ⊆ f1.support := by\n  simp +contextual only [subset_iff, tsub_eq_zero_iff_le, mem_support_iff,\n    Ne, coe_tsub, Pi.sub_apply, not_imp_not, zero_le, imp_true_iff]\n\n"}
{"name":"Finsupp.subset_support_tsub","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : PartialOrder α\ninst✝³ : CanonicallyOrderedAdd α\ninst✝² : Sub α\ninst✝¹ : OrderedSub α\ninst✝ : DecidableEq ι\nf1 f2 : Finsupp ι α\n⊢ HasSubset.Subset (SDiff.sdiff f1.support f2.support) (HSub.hSub f1 f2).support","decl":"theorem subset_support_tsub [DecidableEq ι] {f1 f2 : ι →₀ α} :\n    f1.support \\ f2.support ⊆ (f1 - f2).support := by\n  simp +contextual [subset_iff]\n\n"}
{"name":"Finsupp.support_inf","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝³ : AddCommMonoid α\ninst✝² : LinearOrder α\ninst✝¹ : CanonicallyOrderedAdd α\ninst✝ : DecidableEq ι\nf g : Finsupp ι α\n⊢ Eq (Min.min f g).support (Inter.inter f.support g.support)","decl":"@[simp]\ntheorem support_inf [DecidableEq ι] (f g : ι →₀ α) : (f ⊓ g).support = f.support ∩ g.support := by\n  ext\n  simp only [inf_apply, mem_support_iff, Ne, Finset.mem_union, Finset.mem_filter,\n    Finset.mem_inter]\n  simp only [← nonpos_iff_eq_zero, min_le_iff, not_or]\n\n"}
{"name":"Finsupp.support_sup","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝³ : AddCommMonoid α\ninst✝² : LinearOrder α\ninst✝¹ : CanonicallyOrderedAdd α\ninst✝ : DecidableEq ι\nf g : Finsupp ι α\n⊢ Eq (Max.max f g).support (Union.union f.support g.support)","decl":"@[simp]\ntheorem support_sup [DecidableEq ι] (f g : ι →₀ α) : (f ⊔ g).support = f.support ∪ g.support := by\n  ext\n  simp only [Finset.mem_union, mem_support_iff, sup_apply, Ne, ← bot_eq_zero]\n  rw [_root_.sup_eq_bot_iff, not_and_or]\n\n"}
{"name":"Finsupp.disjoint_iff","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : AddCommMonoid α\ninst✝¹ : LinearOrder α\ninst✝ : CanonicallyOrderedAdd α\nf g : Finsupp ι α\n⊢ Iff (Disjoint f g) (Disjoint f.support g.support)","decl":"nonrec theorem disjoint_iff {f g : ι →₀ α} : Disjoint f g ↔ Disjoint f.support g.support := by\n  classical\n    rw [disjoint_iff, disjoint_iff, Finsupp.bot_eq_zero, ← Finsupp.support_eq_empty,\n      Finsupp.support_inf]\n    rfl\n\n"}
{"name":"Finsupp.sub_single_one_add","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\na : ι\nu u' : Finsupp ι Nat\nh : Ne (u a) 0\n⊢ Eq (HAdd.hAdd (HSub.hSub u (Finsupp.single a 1)) u') (HSub.hSub (HAdd.hAdd u u') (Finsupp.single a 1))","decl":"theorem sub_single_one_add {a : ι} {u u' : ι →₀ ℕ} (h : u a ≠ 0) :\n    u - single a 1 + u' = u + u' - single a 1 :=\n  tsub_add_eq_add_tsub <| single_le_iff.mpr <| Nat.one_le_iff_ne_zero.mpr h\n\n"}
{"name":"Finsupp.add_sub_single_one","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\na : ι\nu u' : Finsupp ι Nat\nh : Ne (u' a) 0\n⊢ Eq (HAdd.hAdd u (HSub.hSub u' (Finsupp.single a 1))) (HSub.hSub (HAdd.hAdd u u') (Finsupp.single a 1))","decl":"theorem add_sub_single_one {a : ι} {u u' : ι →₀ ℕ} (h : u' a ≠ 0) :\n    u + (u' - single a 1) = u + u' - single a 1 :=\n  (add_tsub_assoc_of_le (single_le_iff.mpr <| Nat.one_le_iff_ne_zero.mpr h) _).symm\n\n"}
{"name":"Finsupp.sub_add_single_one_cancel","module":"Mathlib.Data.Finsupp.Order","initialProofState":"ι : Type u_1\nu : Finsupp ι Nat\ni : ι\nh : Ne (u i) 0\n⊢ Eq (HAdd.hAdd (HSub.hSub u (Finsupp.single i 1)) (Finsupp.single i 1)) u","decl":"lemma sub_add_single_one_cancel {u : ι →₀ ℕ} {i : ι} (h : u i ≠ 0) :\n    u - single i 1 + single i 1 = u := by\n  rw [sub_single_one_add h, add_tsub_cancel_right]\n\n"}
