{"name":"Algebra.TensorProduct.basisAux_tmul","module":"Mathlib.RingTheory.TensorProduct.Free","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type uM\nι : Type uι\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\na : A\nm : M\n⊢ Eq ((Algebra.TensorProduct.basisAux A b) (TensorProduct.tmul R a m)) (HSMul.hSMul a (Finsupp.mapRange ⇑(algebraMap R A) ⋯ (b.repr m)))","decl":"theorem basisAux_tmul (a : A) (m : M) :\n    basisAux A b (a ⊗ₜ m) = a • Finsupp.mapRange (algebraMap R A) (map_zero _) (b.repr m) := by\n  ext\n  simp [basisAux, ← Algebra.commutes, Algebra.smul_def]\n\n"}
{"name":"Algebra.TensorProduct.basisAux_map_smul","module":"Mathlib.RingTheory.TensorProduct.Free","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type uM\nι : Type uι\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\na : A\nx : TensorProduct R A M\n⊢ Eq ((Algebra.TensorProduct.basisAux A b) (HSMul.hSMul a x)) (HSMul.hSMul a ((Algebra.TensorProduct.basisAux A b) x))","decl":"theorem basisAux_map_smul (a : A) (x : A ⊗[R] M) : basisAux A b (a • x) = a • basisAux A b x :=\n  TensorProduct.induction_on x (by simp)\n    (fun x y => by simp only [TensorProduct.smul_tmul', basisAux_tmul, smul_assoc])\n    fun x y hx hy => by simp [hx, hy]\n\n"}
{"name":"Algebra.TensorProduct.basis_repr_tmul","module":"Mathlib.RingTheory.TensorProduct.Free","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type uM\nι : Type uι\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\na : A\nm : M\n⊢ Eq ((Algebra.TensorProduct.basis A b).repr (TensorProduct.tmul R a m)) (HSMul.hSMul a (Finsupp.mapRange ⇑(algebraMap R A) ⋯ (b.repr m)))","decl":"@[simp]\ntheorem basis_repr_tmul (a : A) (m : M) :\n    (basis A b).repr (a ⊗ₜ m) = a • Finsupp.mapRange (algebraMap R A) (map_zero _) (b.repr m) :=\n  basisAux_tmul b a m -- Porting note: Lean 3 had _ _ _\n\n"}
{"name":"Algebra.TensorProduct.basis_repr_symm_apply","module":"Mathlib.RingTheory.TensorProduct.Free","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type uM\nι : Type uι\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\na : A\ni : ι\n⊢ Eq ((Algebra.TensorProduct.basis A b).repr.symm (Finsupp.single i a)) (TensorProduct.tmul R a (b.repr.symm (Finsupp.single i 1)))","decl":"theorem basis_repr_symm_apply (a : A) (i : ι) :\n    (basis A b).repr.symm (Finsupp.single i a) = a ⊗ₜ b.repr.symm (Finsupp.single i 1) := by\n  rw [basis, LinearEquiv.coe_symm_mk] -- Porting note: `coe_symm_mk` isn't firing in `simp`\n  simp [Equiv.uniqueProd_symm_apply, basisAux]\n\n"}
{"name":"Algebra.TensorProduct.basis_apply","module":"Mathlib.RingTheory.TensorProduct.Free","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type uM\nι : Type uι\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ni : ι\n⊢ Eq ((Algebra.TensorProduct.basis A b) i) (TensorProduct.tmul R 1 (b i))","decl":"@[simp]\ntheorem basis_apply (i : ι) : basis A b i = 1 ⊗ₜ b i := basis_repr_symm_apply b 1 i\n\n"}
{"name":"Algebra.TensorProduct.basis_repr_symm_apply'","module":"Mathlib.RingTheory.TensorProduct.Free","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type uM\nι : Type uι\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\na : A\ni : ι\n⊢ Eq (HSMul.hSMul a ((Algebra.TensorProduct.basis A b) i)) (TensorProduct.tmul R a (b i))","decl":"theorem basis_repr_symm_apply' (a : A) (i : ι) : a • basis A b i = a ⊗ₜ b i := by\n  simpa using basis_repr_symm_apply b a i\n\n"}
{"name":"Basis.baseChange_linearMap","module":"Mathlib.RingTheory.TensorProduct.Free","initialProofState":"R : Type u_1\nM : Type uM\nι : Type uι\ninst✝⁹ : CommSemiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : Fintype ι\nι' : Type u_3\nN : Type u_4\ninst✝⁵ : Fintype ι'\ninst✝⁴ : DecidableEq ι'\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nA : Type u_5\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nb : Basis ι R M\nb' : Basis ι' R N\nij : Prod ι ι'\n⊢ Eq (LinearMap.baseChange A ((b'.linearMap b) ij)) (((Algebra.TensorProduct.basis A b').linearMap (Algebra.TensorProduct.basis A b)) ij)","decl":"lemma _root_.Basis.baseChange_linearMap (b : Basis ι R M) (b' : Basis ι' R N) (ij : ι × ι') :\n    baseChange A (b'.linearMap b ij) = (basis A b').linearMap (basis A b) ij := by\n  apply (basis A b').ext\n  intro k\n  conv_lhs => simp only [basis_apply, baseChange_tmul]\n  simp_rw [Basis.linearMap_apply_apply, basis_apply]\n  split <;> simp only [TensorProduct.tmul_zero]\n\n"}
{"name":"Basis.baseChange_end","module":"Mathlib.RingTheory.TensorProduct.Free","initialProofState":"R : Type u_1\nM : Type uM\nι : Type uι\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Fintype ι\nA : Type u_5\ninst✝² : CommSemiring A\ninst✝¹ : Algebra R A\ninst✝ : DecidableEq ι\nb : Basis ι R M\nij : Prod ι ι\n⊢ Eq (LinearMap.baseChange A (b.end ij)) ((Algebra.TensorProduct.basis A b).end ij)","decl":"lemma _root_.Basis.baseChange_end (b : Basis ι R M) (ij : ι × ι) :\n    baseChange A (b.end ij) = (basis A b).end ij :=\n  b.baseChange_linearMap A b ij\n\n"}
{"name":"Algebra.TensorProduct.instFree","module":"Mathlib.RingTheory.TensorProduct.Free","initialProofState":"R : Type u_3\nA : Type u_4\nM : Type u_5\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Module.Free R M\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\n⊢ Module.Free A (TensorProduct R A M)","decl":"instance instFree (R A M : Type*)\n    [CommSemiring R] [AddCommMonoid M] [Module R M] [Module.Free R M]\n    [CommSemiring A] [Algebra R A] :\n    Module.Free A (A ⊗[R] M) :=\n  Module.Free.of_basis <| Algebra.TensorProduct.basis A (Module.Free.chooseBasis R M)\n\n"}
{"name":"LinearMap.toMatrix_baseChange","module":"Mathlib.RingTheory.TensorProduct.Free","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\nι : Type u_4\nι₂ : Type u_5\nA : Type u_6\ninst✝⁹ : Fintype ι\ninst✝⁸ : Finite ι₂\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\nb₁ : Basis ι R M₁\nb₂ : Basis ι₂ R M₂\n⊢ Eq ((LinearMap.toMatrix (Algebra.TensorProduct.basis A b₁) (Algebra.TensorProduct.basis A b₂)) (LinearMap.baseChange A f)) (((LinearMap.toMatrix b₁ b₂) f).map ⇑(algebraMap R A))","decl":"@[simp]\nlemma toMatrix_baseChange (f : M₁ →ₗ[R] M₂) (b₁ : Basis ι R M₁) (b₂ : Basis ι₂ R M₂) :\n    toMatrix (basis A b₁) (basis A b₂) (f.baseChange A) =\n    (toMatrix b₁ b₂ f).map (algebraMap R A) := by\n  ext; simp [toMatrix_apply]\n\n"}
