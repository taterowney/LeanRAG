{"name":"Filter.HasBasis.subsingleton_iff","module":"Mathlib.Order.Filter.Subsingleton","initialProofState":"α : Type u_1\nl : Filter α\nι : Sort u_3\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ Iff l.Subsingleton (Exists fun i => And (p i) (s i).Subsingleton)","decl":"theorem HasBasis.subsingleton_iff {ι : Sort*} {p : ι → Prop} {s : ι → Set α} (h : l.HasBasis p s) :\n    l.Subsingleton ↔ ∃ i, p i ∧ (s i).Subsingleton :=\n  h.exists_iff fun _ _ hsub h ↦ h.anti hsub\n\n"}
{"name":"Filter.Subsingleton.anti","module":"Mathlib.Order.Filter.Subsingleton","initialProofState":"α : Type u_1\nl l' : Filter α\nhl : l.Subsingleton\nhl' : LE.le l' l\n⊢ l'.Subsingleton","decl":"theorem Subsingleton.anti {l'} (hl : l.Subsingleton) (hl' : l' ≤ l) : l'.Subsingleton :=\n  let ⟨s, hsl, hs⟩ := hl; ⟨s, hl' hsl, hs⟩\n\n"}
{"name":"Filter.Subsingleton.of_subsingleton","module":"Mathlib.Order.Filter.Subsingleton","initialProofState":"α : Type u_1\nl : Filter α\ninst✝ : Subsingleton α\n⊢ l.Subsingleton","decl":"@[nontriviality]\ntheorem Subsingleton.of_subsingleton [Subsingleton α] : l.Subsingleton :=\n  ⟨univ, univ_mem, subsingleton_univ⟩\n\n"}
{"name":"Filter.Subsingleton.map","module":"Mathlib.Order.Filter.Subsingleton","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nhl : l.Subsingleton\nf : α → β\n⊢ (Filter.map f l).Subsingleton","decl":"theorem Subsingleton.map (hl : l.Subsingleton) (f : α → β) : (map f l).Subsingleton :=\n  let ⟨s, hsl, hs⟩ := hl; ⟨f '' s, image_mem_map hsl, hs.image f⟩\n\n"}
{"name":"Filter.Subsingleton.prod","module":"Mathlib.Order.Filter.Subsingleton","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nhl : l.Subsingleton\nl' : Filter β\nhl' : l'.Subsingleton\n⊢ (SProd.sprod l l').Subsingleton","decl":"theorem Subsingleton.prod (hl : l.Subsingleton) {l' : Filter β} (hl' : l'.Subsingleton) :\n    (l ×ˢ l').Subsingleton :=\n  let ⟨s, hsl, hs⟩ := hl; let ⟨t, htl', ht⟩ := hl'; ⟨s ×ˢ t, prod_mem_prod hsl htl', hs.prod ht⟩\n\n"}
{"name":"Filter.subsingleton_pure","module":"Mathlib.Order.Filter.Subsingleton","initialProofState":"α : Type u_1\na : α\n⊢ (Pure.pure a).Subsingleton","decl":"@[simp]\ntheorem subsingleton_pure {a : α} : Filter.Subsingleton (pure a) :=\n  ⟨{a}, rfl, subsingleton_singleton⟩\n\n"}
{"name":"Filter.subsingleton_bot","module":"Mathlib.Order.Filter.Subsingleton","initialProofState":"α : Type u_1\n⊢ Bot.bot.Subsingleton","decl":"@[simp]\ntheorem subsingleton_bot : Filter.Subsingleton (⊥ : Filter α) :=\n  ⟨∅, trivial, subsingleton_empty⟩\n\n"}
{"name":"Filter.Subsingleton.exists_eq_pure","module":"Mathlib.Order.Filter.Subsingleton","initialProofState":"α : Type u_1\nl : Filter α\ninst✝ : l.NeBot\nhl : l.Subsingleton\n⊢ Exists fun a => Eq l (Pure.pure a)","decl":"/-- A nontrivial subsingleton filter is equal to `pure a` for some `a`. -/\ntheorem Subsingleton.exists_eq_pure [l.NeBot] (hl : l.Subsingleton) : ∃ a, l = pure a := by\n  rcases hl with ⟨s, hsl, hs⟩\n  rcases exists_eq_singleton_iff_nonempty_subsingleton.2 ⟨nonempty_of_mem hsl, hs⟩ with ⟨a, rfl⟩\n  refine ⟨a, (NeBot.le_pure_iff ‹_›).1 ?_⟩\n  rwa [le_pure_iff]\n\n"}
{"name":"Filter.subsingleton_iff_bot_or_pure","module":"Mathlib.Order.Filter.Subsingleton","initialProofState":"α : Type u_1\nl : Filter α\n⊢ Iff l.Subsingleton (Or (Eq l Bot.bot) (Exists fun a => Eq l (Pure.pure a)))","decl":"/-- A filter is a subsingleton iff it is equal to `⊥` or to `pure a` for some `a`. -/\ntheorem subsingleton_iff_bot_or_pure : l.Subsingleton ↔ l = ⊥ ∨ ∃ a, l = pure a := by\n  refine ⟨fun hl ↦ ?_, ?_⟩\n  · exact (eq_or_neBot l).imp_right (@Subsingleton.exists_eq_pure _ _ · hl)\n  · rintro (rfl | ⟨a, rfl⟩) <;> simp\n\n"}
{"name":"Filter.subsingleton_iff_exists_le_pure","module":"Mathlib.Order.Filter.Subsingleton","initialProofState":"α : Type u_1\nl : Filter α\ninst✝ : Nonempty α\n⊢ Iff l.Subsingleton (Exists fun a => LE.le l (Pure.pure a))","decl":"/-- In a nonempty type, a filter is a subsingleton iff\nit is less than or equal to a pure filter. -/\ntheorem subsingleton_iff_exists_le_pure [Nonempty α] : l.Subsingleton ↔ ∃ a, l ≤ pure a := by\n  rcases eq_or_neBot l with rfl | hbot\n  · simp\n  · simp [subsingleton_iff_bot_or_pure, ← hbot.le_pure_iff, hbot.ne]\n\n"}
{"name":"Filter.subsingleton_iff_exists_singleton_mem","module":"Mathlib.Order.Filter.Subsingleton","initialProofState":"α : Type u_1\nl : Filter α\ninst✝ : Nonempty α\n⊢ Iff l.Subsingleton (Exists fun a => Membership.mem l (Singleton.singleton a))","decl":"theorem subsingleton_iff_exists_singleton_mem [Nonempty α] : l.Subsingleton ↔ ∃ a, {a} ∈ l := by\n  simp only [subsingleton_iff_exists_le_pure, le_pure_iff]\n\n"}
{"name":"Filter.Subsingleton.exists_le_pure","module":"Mathlib.Order.Filter.Subsingleton","initialProofState":"α : Type u_1\nl : Filter α\ninst✝ : Nonempty α\na✝ : l.Subsingleton\n⊢ Exists fun a => LE.le l (Pure.pure a)","decl":"/-- A subsingleton filter on a nonempty type is less than or equal to `pure a` for some `a`. -/\nalias ⟨Subsingleton.exists_le_pure, _⟩ := subsingleton_iff_exists_le_pure\n\n"}
{"name":"Filter.Subsingleton.isCountablyGenerated","module":"Mathlib.Order.Filter.Subsingleton","initialProofState":"α : Type u_1\nl : Filter α\nhl : l.Subsingleton\n⊢ l.IsCountablyGenerated","decl":"lemma Subsingleton.isCountablyGenerated (hl : l.Subsingleton) : IsCountablyGenerated l := by\n  rcases subsingleton_iff_bot_or_pure.1 hl with rfl|⟨x, rfl⟩\n  · exact isCountablyGenerated_bot\n  · exact isCountablyGenerated_pure x\n\n"}
