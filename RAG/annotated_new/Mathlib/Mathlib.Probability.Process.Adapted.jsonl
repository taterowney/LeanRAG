{"name":"MeasureTheory.Adapted.mul","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder ι\nu v : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝¹ : Mul β\ninst✝ : ContinuousMul β\nhu : MeasureTheory.Adapted f u\nhv : MeasureTheory.Adapted f v\n⊢ MeasureTheory.Adapted f (HMul.hMul u v)","decl":"@[to_additive]\nprotected theorem mul [Mul β] [ContinuousMul β] (hu : Adapted f u) (hv : Adapted f v) :\n    Adapted f (u * v) := fun i => (hu i).mul (hv i)\n\n"}
{"name":"MeasureTheory.Adapted.add","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder ι\nu v : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝¹ : Add β\ninst✝ : ContinuousAdd β\nhu : MeasureTheory.Adapted f u\nhv : MeasureTheory.Adapted f v\n⊢ MeasureTheory.Adapted f (HAdd.hAdd u v)","decl":"@[to_additive]\nprotected theorem mul [Mul β] [ContinuousMul β] (hu : Adapted f u) (hv : Adapted f v) :\n    Adapted f (u * v) := fun i => (hu i).mul (hv i)\n\n"}
{"name":"MeasureTheory.Adapted.sub","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder ι\nu v : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝¹ : Sub β\ninst✝ : ContinuousSub β\nhu : MeasureTheory.Adapted f u\nhv : MeasureTheory.Adapted f v\n⊢ MeasureTheory.Adapted f (HSub.hSub u v)","decl":"@[to_additive]\nprotected theorem div [Div β] [ContinuousDiv β] (hu : Adapted f u) (hv : Adapted f v) :\n    Adapted f (u / v) := fun i => (hu i).div (hv i)\n\n"}
{"name":"MeasureTheory.Adapted.div","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder ι\nu v : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝¹ : Div β\ninst✝ : ContinuousDiv β\nhu : MeasureTheory.Adapted f u\nhv : MeasureTheory.Adapted f v\n⊢ MeasureTheory.Adapted f (HDiv.hDiv u v)","decl":"@[to_additive]\nprotected theorem div [Div β] [ContinuousDiv β] (hu : Adapted f u) (hv : Adapted f v) :\n    Adapted f (u / v) := fun i => (hu i).div (hv i)\n\n"}
{"name":"MeasureTheory.Adapted.neg","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder ι\nu : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝¹ : AddGroup β\ninst✝ : TopologicalAddGroup β\nhu : MeasureTheory.Adapted f u\n⊢ MeasureTheory.Adapted f (Neg.neg u)","decl":"@[to_additive]\nprotected theorem inv [Group β] [TopologicalGroup β] (hu : Adapted f u) :\n    Adapted f u⁻¹ := fun i => (hu i).inv\n\n"}
{"name":"MeasureTheory.Adapted.inv","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder ι\nu : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝¹ : Group β\ninst✝ : TopologicalGroup β\nhu : MeasureTheory.Adapted f u\n⊢ MeasureTheory.Adapted f (Inv.inv u)","decl":"@[to_additive]\nprotected theorem inv [Group β] [TopologicalGroup β] (hu : Adapted f u) :\n    Adapted f u⁻¹ := fun i => (hu i).inv\n\n"}
{"name":"MeasureTheory.Adapted.smul","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder ι\nu : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝¹ : SMul Real β\ninst✝ : ContinuousSMul Real β\nc : Real\nhu : MeasureTheory.Adapted f u\n⊢ MeasureTheory.Adapted f (HSMul.hSMul c u)","decl":"protected theorem smul [SMul ℝ β] [ContinuousSMul ℝ β] (c : ℝ) (hu : Adapted f u) :\n    Adapted f (c • u) := fun i => (hu i).const_smul c\n\n"}
{"name":"MeasureTheory.Adapted.stronglyMeasurable","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder ι\nu : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ni : ι\nhf : MeasureTheory.Adapted f u\n⊢ MeasureTheory.StronglyMeasurable (u i)","decl":"protected theorem stronglyMeasurable {i : ι} (hf : Adapted f u) : StronglyMeasurable[m] (u i) :=\n  (hf i).mono (f.le i)\n\n"}
{"name":"MeasureTheory.Adapted.stronglyMeasurable_le","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder ι\nu : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ni j : ι\nhf : MeasureTheory.Adapted f u\nhij : LE.le i j\n⊢ MeasureTheory.StronglyMeasurable (u i)","decl":"theorem stronglyMeasurable_le {i j : ι} (hf : Adapted f u) (hij : i ≤ j) :\n    StronglyMeasurable[f j] (u i) := (hf i).mono (f.mono hij)\n\n"}
{"name":"MeasureTheory.adapted_const","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace β\ninst✝ : Preorder ι\nf : MeasureTheory.Filtration ι m\nx : β\n⊢ MeasureTheory.Adapted f fun x_1 x_2 => x","decl":"theorem adapted_const (f : Filtration ι m) (x : β) : Adapted f fun _ _ => x := fun _ =>\n  stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.adapted_zero","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝² : TopologicalSpace β\ninst✝¹ : Preorder ι\ninst✝ : Zero β\nf : MeasureTheory.Filtration ι m\n⊢ MeasureTheory.Adapted f 0","decl":"theorem adapted_zero [Zero β] (f : Filtration ι m) : Adapted f (0 : ι → Ω → β) := fun i =>\n  @stronglyMeasurable_zero Ω β (f i) _ _\n\n"}
{"name":"MeasureTheory.Filtration.adapted_natural","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder ι\ninst✝¹ : TopologicalSpace.MetrizableSpace β\nmβ : MeasurableSpace β\ninst✝ : BorelSpace β\nu : ι → Ω → β\nhum : ∀ (i : ι), MeasureTheory.StronglyMeasurable (u i)\n⊢ MeasureTheory.Adapted (MeasureTheory.Filtration.natural u hum) u","decl":"theorem Filtration.adapted_natural [MetrizableSpace β] [mβ : MeasurableSpace β] [BorelSpace β]\n    {u : ι → Ω → β} (hum : ∀ i, StronglyMeasurable[m] (u i)) :\n    Adapted (Filtration.natural u hum) u := by\n  intro i\n  refine StronglyMeasurable.mono ?_ (le_iSup₂_of_le i (le_refl i) le_rfl)\n  rw [stronglyMeasurable_iff_measurable_separable]\n  exact ⟨measurable_iff_comap_le.2 le_rfl, (hum i).isSeparable_range⟩\n\n"}
{"name":"MeasureTheory.progMeasurable_const","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝² : TopologicalSpace β\ninst✝¹ : Preorder ι\ninst✝ : MeasurableSpace ι\nf : MeasureTheory.Filtration ι m\nb : β\n⊢ MeasureTheory.ProgMeasurable f fun x x => b","decl":"theorem progMeasurable_const [MeasurableSpace ι] (f : Filtration ι m) (b : β) :\n    ProgMeasurable f (fun _ _ => b : ι → Ω → β) := fun i =>\n  @stronglyMeasurable_const _ _ (Subtype.instMeasurableSpace.prod (f i)) _ _\n\n"}
{"name":"MeasureTheory.ProgMeasurable.adapted","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝² : TopologicalSpace β\ninst✝¹ : Preorder ι\nu : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝ : MeasurableSpace ι\nh : MeasureTheory.ProgMeasurable f u\n⊢ MeasureTheory.Adapted f u","decl":"protected theorem adapted (h : ProgMeasurable f u) : Adapted f u := by\n  intro i\n  have : u i = (fun p : Set.Iic i × Ω => u p.1 p.2) ∘ fun x => (⟨i, Set.mem_Iic.mpr le_rfl⟩, x) :=\n    rfl\n  rw [this]\n  exact (h i).comp_measurable measurable_prod_mk_left\n\n"}
{"name":"MeasureTheory.ProgMeasurable.comp","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁵ : TopologicalSpace β\ninst✝⁴ : Preorder ι\nu : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝³ : MeasurableSpace ι\nt : ι → Ω → ι\ninst✝² : TopologicalSpace ι\ninst✝¹ : BorelSpace ι\ninst✝ : TopologicalSpace.MetrizableSpace ι\nh : MeasureTheory.ProgMeasurable f u\nht : MeasureTheory.ProgMeasurable f t\nht_le : ∀ (i : ι) (ω : Ω), LE.le (t i ω) i\n⊢ MeasureTheory.ProgMeasurable f fun i ω => u (t i ω) ω","decl":"protected theorem comp {t : ι → Ω → ι} [TopologicalSpace ι] [BorelSpace ι] [MetrizableSpace ι]\n    (h : ProgMeasurable f u) (ht : ProgMeasurable f t) (ht_le : ∀ i ω, t i ω ≤ i) :\n    ProgMeasurable f fun i ω => u (t i ω) ω := by\n  intro i\n  have : (fun p : ↥(Set.Iic i) × Ω => u (t (p.fst : ι) p.snd) p.snd) =\n    (fun p : ↥(Set.Iic i) × Ω => u (p.fst : ι) p.snd) ∘ fun p : ↥(Set.Iic i) × Ω =>\n      (⟨t (p.fst : ι) p.snd, Set.mem_Iic.mpr ((ht_le _ _).trans p.fst.prop)⟩, p.snd) := rfl\n  rw [this]\n  exact (h i).comp_measurable ((ht i).measurable.subtype_mk.prod_mk measurable_snd)\n\n"}
{"name":"MeasureTheory.ProgMeasurable.mul","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁴ : TopologicalSpace β\ninst✝³ : Preorder ι\nu v : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝² : MeasurableSpace ι\ninst✝¹ : Mul β\ninst✝ : ContinuousMul β\nhu : MeasureTheory.ProgMeasurable f u\nhv : MeasureTheory.ProgMeasurable f v\n⊢ MeasureTheory.ProgMeasurable f fun i ω => HMul.hMul (u i ω) (v i ω)","decl":"@[to_additive]\nprotected theorem mul [Mul β] [ContinuousMul β] (hu : ProgMeasurable f u)\n    (hv : ProgMeasurable f v) : ProgMeasurable f fun i ω => u i ω * v i ω := fun i =>\n  (hu i).mul (hv i)\n\n"}
{"name":"MeasureTheory.ProgMeasurable.add","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁴ : TopologicalSpace β\ninst✝³ : Preorder ι\nu v : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝² : MeasurableSpace ι\ninst✝¹ : Add β\ninst✝ : ContinuousAdd β\nhu : MeasureTheory.ProgMeasurable f u\nhv : MeasureTheory.ProgMeasurable f v\n⊢ MeasureTheory.ProgMeasurable f fun i ω => HAdd.hAdd (u i ω) (v i ω)","decl":"@[to_additive]\nprotected theorem mul [Mul β] [ContinuousMul β] (hu : ProgMeasurable f u)\n    (hv : ProgMeasurable f v) : ProgMeasurable f fun i ω => u i ω * v i ω := fun i =>\n  (hu i).mul (hv i)\n\n"}
{"name":"MeasureTheory.ProgMeasurable.finset_prod'","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁴ : TopologicalSpace β\ninst✝³ : Preorder ι\nf : MeasureTheory.Filtration ι m\ninst✝² : MeasurableSpace ι\nγ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : ContinuousMul β\nU : γ → ι → Ω → β\ns : Finset γ\nh : ∀ (c : γ), Membership.mem s c → MeasureTheory.ProgMeasurable f (U c)\n⊢ MeasureTheory.ProgMeasurable f (s.prod fun c => U c)","decl":"@[to_additive]\nprotected theorem finset_prod' {γ} [CommMonoid β] [ContinuousMul β] {U : γ → ι → Ω → β}\n    {s : Finset γ} (h : ∀ c ∈ s, ProgMeasurable f (U c)) : ProgMeasurable f (∏ c ∈ s, U c) :=\n  Finset.prod_induction U (ProgMeasurable f) (fun _ _ => ProgMeasurable.mul)\n    (progMeasurable_const _ 1) h\n\n"}
{"name":"MeasureTheory.ProgMeasurable.finset_sum'","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁴ : TopologicalSpace β\ninst✝³ : Preorder ι\nf : MeasureTheory.Filtration ι m\ninst✝² : MeasurableSpace ι\nγ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : ContinuousAdd β\nU : γ → ι → Ω → β\ns : Finset γ\nh : ∀ (c : γ), Membership.mem s c → MeasureTheory.ProgMeasurable f (U c)\n⊢ MeasureTheory.ProgMeasurable f (s.sum fun c => U c)","decl":"@[to_additive]\nprotected theorem finset_prod' {γ} [CommMonoid β] [ContinuousMul β] {U : γ → ι → Ω → β}\n    {s : Finset γ} (h : ∀ c ∈ s, ProgMeasurable f (U c)) : ProgMeasurable f (∏ c ∈ s, U c) :=\n  Finset.prod_induction U (ProgMeasurable f) (fun _ _ => ProgMeasurable.mul)\n    (progMeasurable_const _ 1) h\n\n"}
{"name":"MeasureTheory.ProgMeasurable.finset_prod","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁴ : TopologicalSpace β\ninst✝³ : Preorder ι\nf : MeasureTheory.Filtration ι m\ninst✝² : MeasurableSpace ι\nγ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : ContinuousMul β\nU : γ → ι → Ω → β\ns : Finset γ\nh : ∀ (c : γ), Membership.mem s c → MeasureTheory.ProgMeasurable f (U c)\n⊢ MeasureTheory.ProgMeasurable f fun i a => s.prod fun c => U c i a","decl":"@[to_additive]\nprotected theorem finset_prod {γ} [CommMonoid β] [ContinuousMul β] {U : γ → ι → Ω → β}\n    {s : Finset γ} (h : ∀ c ∈ s, ProgMeasurable f (U c)) :\n    ProgMeasurable f fun i a => ∏ c ∈ s, U c i a := by\n  convert ProgMeasurable.finset_prod' h using 1; ext (i a); simp only [Finset.prod_apply]\n\n"}
{"name":"MeasureTheory.ProgMeasurable.finset_sum","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁴ : TopologicalSpace β\ninst✝³ : Preorder ι\nf : MeasureTheory.Filtration ι m\ninst✝² : MeasurableSpace ι\nγ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : ContinuousAdd β\nU : γ → ι → Ω → β\ns : Finset γ\nh : ∀ (c : γ), Membership.mem s c → MeasureTheory.ProgMeasurable f (U c)\n⊢ MeasureTheory.ProgMeasurable f fun i a => s.sum fun c => U c i a","decl":"@[to_additive]\nprotected theorem finset_prod {γ} [CommMonoid β] [ContinuousMul β] {U : γ → ι → Ω → β}\n    {s : Finset γ} (h : ∀ c ∈ s, ProgMeasurable f (U c)) :\n    ProgMeasurable f fun i a => ∏ c ∈ s, U c i a := by\n  convert ProgMeasurable.finset_prod' h using 1; ext (i a); simp only [Finset.prod_apply]\n\n"}
{"name":"MeasureTheory.ProgMeasurable.inv","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁴ : TopologicalSpace β\ninst✝³ : Preorder ι\nu : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝² : MeasurableSpace ι\ninst✝¹ : Group β\ninst✝ : TopologicalGroup β\nhu : MeasureTheory.ProgMeasurable f u\n⊢ MeasureTheory.ProgMeasurable f fun i ω => Inv.inv (u i ω)","decl":"@[to_additive]\nprotected theorem inv [Group β] [TopologicalGroup β] (hu : ProgMeasurable f u) :\n    ProgMeasurable f fun i ω => (u i ω)⁻¹ := fun i => (hu i).inv\n\n"}
{"name":"MeasureTheory.ProgMeasurable.neg","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁴ : TopologicalSpace β\ninst✝³ : Preorder ι\nu : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝² : MeasurableSpace ι\ninst✝¹ : AddGroup β\ninst✝ : TopologicalAddGroup β\nhu : MeasureTheory.ProgMeasurable f u\n⊢ MeasureTheory.ProgMeasurable f fun i ω => Neg.neg (u i ω)","decl":"@[to_additive]\nprotected theorem inv [Group β] [TopologicalGroup β] (hu : ProgMeasurable f u) :\n    ProgMeasurable f fun i ω => (u i ω)⁻¹ := fun i => (hu i).inv\n\n"}
{"name":"MeasureTheory.ProgMeasurable.sub","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁴ : TopologicalSpace β\ninst✝³ : Preorder ι\nu v : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝² : MeasurableSpace ι\ninst✝¹ : AddGroup β\ninst✝ : TopologicalAddGroup β\nhu : MeasureTheory.ProgMeasurable f u\nhv : MeasureTheory.ProgMeasurable f v\n⊢ MeasureTheory.ProgMeasurable f fun i ω => HSub.hSub (u i ω) (v i ω)","decl":"@[to_additive]\nprotected theorem div [Group β] [TopologicalGroup β] (hu : ProgMeasurable f u)\n    (hv : ProgMeasurable f v) : ProgMeasurable f fun i ω => u i ω / v i ω := fun i =>\n  (hu i).div (hv i)\n\n"}
{"name":"MeasureTheory.ProgMeasurable.div","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁴ : TopologicalSpace β\ninst✝³ : Preorder ι\nu v : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝² : MeasurableSpace ι\ninst✝¹ : Group β\ninst✝ : TopologicalGroup β\nhu : MeasureTheory.ProgMeasurable f u\nhv : MeasureTheory.ProgMeasurable f v\n⊢ MeasureTheory.ProgMeasurable f fun i ω => HDiv.hDiv (u i ω) (v i ω)","decl":"@[to_additive]\nprotected theorem div [Group β] [TopologicalGroup β] (hu : ProgMeasurable f u)\n    (hv : ProgMeasurable f v) : ProgMeasurable f fun i ω => u i ω / v i ω := fun i =>\n  (hu i).div (hv i)\n\n"}
{"name":"MeasureTheory.progMeasurable_of_tendsto'","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁵ : TopologicalSpace β\ninst✝⁴ : Preorder ι\nu : ι → Ω → β\nf : MeasureTheory.Filtration ι m\nγ : Type u_4\ninst✝³ : MeasurableSpace ι\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\nfltr : Filter γ\ninst✝¹ : fltr.NeBot\ninst✝ : fltr.IsCountablyGenerated\nU : γ → ι → Ω → β\nh : ∀ (l : γ), MeasureTheory.ProgMeasurable f (U l)\nh_tendsto : Filter.Tendsto U fltr (nhds u)\n⊢ MeasureTheory.ProgMeasurable f u","decl":"theorem progMeasurable_of_tendsto' {γ} [MeasurableSpace ι] [PseudoMetrizableSpace β]\n    (fltr : Filter γ) [fltr.NeBot] [fltr.IsCountablyGenerated] {U : γ → ι → Ω → β}\n    (h : ∀ l, ProgMeasurable f (U l)) (h_tendsto : Tendsto U fltr (𝓝 u)) : ProgMeasurable f u := by\n  intro i\n  apply @stronglyMeasurable_of_tendsto (Set.Iic i × Ω) β γ\n    (MeasurableSpace.prod _ (f i)) _ _ fltr _ _ _ _ fun l => h l i\n  rw [tendsto_pi_nhds] at h_tendsto ⊢\n  intro x\n  specialize h_tendsto x.fst\n  rw [tendsto_nhds] at h_tendsto ⊢\n  exact fun s hs h_mem => h_tendsto {g | g x.snd ∈ s} (hs.preimage (continuous_apply x.snd)) h_mem\n\n"}
{"name":"MeasureTheory.progMeasurable_of_tendsto","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : TopologicalSpace β\ninst✝² : Preorder ι\nu : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝¹ : MeasurableSpace ι\ninst✝ : TopologicalSpace.PseudoMetrizableSpace β\nU : Nat → ι → Ω → β\nh : ∀ (l : Nat), MeasureTheory.ProgMeasurable f (U l)\nh_tendsto : Filter.Tendsto U Filter.atTop (nhds u)\n⊢ MeasureTheory.ProgMeasurable f u","decl":"theorem progMeasurable_of_tendsto [MeasurableSpace ι] [PseudoMetrizableSpace β] {U : ℕ → ι → Ω → β}\n    (h : ∀ l, ProgMeasurable f (U l)) (h_tendsto : Tendsto U atTop (𝓝 u)) : ProgMeasurable f u :=\n  progMeasurable_of_tendsto' atTop h h_tendsto\n\n"}
{"name":"MeasureTheory.Adapted.progMeasurable_of_continuous","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁷ : TopologicalSpace β\ninst✝⁶ : Preorder ι\nu : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝⁵ : TopologicalSpace ι\ninst✝⁴ : TopologicalSpace.MetrizableSpace ι\ninst✝³ : SecondCountableTopology ι\ninst✝² : MeasurableSpace ι\ninst✝¹ : OpensMeasurableSpace ι\ninst✝ : TopologicalSpace.PseudoMetrizableSpace β\nh : MeasureTheory.Adapted f u\nhu_cont : ∀ (ω : Ω), Continuous fun i => u i ω\n⊢ MeasureTheory.ProgMeasurable f u","decl":"/-- A continuous and adapted process is progressively measurable. -/\ntheorem Adapted.progMeasurable_of_continuous [TopologicalSpace ι] [MetrizableSpace ι]\n    [SecondCountableTopology ι] [MeasurableSpace ι] [OpensMeasurableSpace ι]\n    [PseudoMetrizableSpace β] (h : Adapted f u) (hu_cont : ∀ ω, Continuous fun i => u i ω) :\n    ProgMeasurable f u := fun i =>\n  @stronglyMeasurable_uncurry_of_continuous_of_stronglyMeasurable _ _ (Set.Iic i) _ _ _ _ _ _ _\n    (f i) _ (fun ω => (hu_cont ω).comp continuous_induced_dom) fun j => (h j).mono (f.mono j.prop)\n\n"}
{"name":"MeasureTheory.Adapted.progMeasurable_of_discrete","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁷ : TopologicalSpace β\ninst✝⁶ : Preorder ι\nu : ι → Ω → β\nf : MeasureTheory.Filtration ι m\ninst✝⁵ : TopologicalSpace ι\ninst✝⁴ : DiscreteTopology ι\ninst✝³ : SecondCountableTopology ι\ninst✝² : MeasurableSpace ι\ninst✝¹ : OpensMeasurableSpace ι\ninst✝ : TopologicalSpace.PseudoMetrizableSpace β\nh : MeasureTheory.Adapted f u\n⊢ MeasureTheory.ProgMeasurable f u","decl":"/-- For filtrations indexed by a discrete order, `Adapted` and `ProgMeasurable` are equivalent.\nThis lemma provides `Adapted f u → ProgMeasurable f u`.\nSee `ProgMeasurable.adapted` for the reverse direction, which is true more generally. -/\ntheorem Adapted.progMeasurable_of_discrete [TopologicalSpace ι] [DiscreteTopology ι]\n    [SecondCountableTopology ι] [MeasurableSpace ι] [OpensMeasurableSpace ι]\n    [PseudoMetrizableSpace β] (h : Adapted f u) : ProgMeasurable f u :=\n  h.progMeasurable_of_continuous fun _ => continuous_of_discreteTopology\n\n-- this dot notation will make more sense once we have a more general definition for predictable\n"}
{"name":"MeasureTheory.Predictable.adapted","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Ω : Type u_1\nβ : Type u_2\nm : MeasurableSpace Ω\ninst✝ : TopologicalSpace β\nf : MeasureTheory.Filtration Nat m\nu : Nat → Ω → β\nhu : MeasureTheory.Adapted f fun n => u (HAdd.hAdd n 1)\nhu0 : MeasureTheory.StronglyMeasurable (u 0)\n⊢ MeasureTheory.Adapted f u","decl":"theorem Predictable.adapted {f : Filtration ℕ m} {u : ℕ → Ω → β} (hu : Adapted f fun n => u (n + 1))\n    (hu0 : StronglyMeasurable[f 0] (u 0)) : Adapted f u := fun n =>\n  match n with\n  | 0 => hu0\n  | n + 1 => (hu n).mono (f.mono n.le_succ)\n\n"}
