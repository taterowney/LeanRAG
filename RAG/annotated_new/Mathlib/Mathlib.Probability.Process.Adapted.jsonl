{"name":"MeasureTheory.Adapted.mul","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : Preorder Î¹\nu v : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ¹ : Mul Î²\ninstâœ : ContinuousMul Î²\nhu : MeasureTheory.Adapted f u\nhv : MeasureTheory.Adapted f v\nâŠ¢ MeasureTheory.Adapted f (HMul.hMul u v)","decl":"@[to_additive]\nprotected theorem mul [Mul Î²] [ContinuousMul Î²] (hu : Adapted f u) (hv : Adapted f v) :\n    Adapted f (u * v) := fun i => (hu i).mul (hv i)\n\n"}
{"name":"MeasureTheory.Adapted.add","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : Preorder Î¹\nu v : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ¹ : Add Î²\ninstâœ : ContinuousAdd Î²\nhu : MeasureTheory.Adapted f u\nhv : MeasureTheory.Adapted f v\nâŠ¢ MeasureTheory.Adapted f (HAdd.hAdd u v)","decl":"@[to_additive]\nprotected theorem mul [Mul Î²] [ContinuousMul Î²] (hu : Adapted f u) (hv : Adapted f v) :\n    Adapted f (u * v) := fun i => (hu i).mul (hv i)\n\n"}
{"name":"MeasureTheory.Adapted.sub","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : Preorder Î¹\nu v : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ¹ : Sub Î²\ninstâœ : ContinuousSub Î²\nhu : MeasureTheory.Adapted f u\nhv : MeasureTheory.Adapted f v\nâŠ¢ MeasureTheory.Adapted f (HSub.hSub u v)","decl":"@[to_additive]\nprotected theorem div [Div Î²] [ContinuousDiv Î²] (hu : Adapted f u) (hv : Adapted f v) :\n    Adapted f (u / v) := fun i => (hu i).div (hv i)\n\n"}
{"name":"MeasureTheory.Adapted.div","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : Preorder Î¹\nu v : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ¹ : Div Î²\ninstâœ : ContinuousDiv Î²\nhu : MeasureTheory.Adapted f u\nhv : MeasureTheory.Adapted f v\nâŠ¢ MeasureTheory.Adapted f (HDiv.hDiv u v)","decl":"@[to_additive]\nprotected theorem div [Div Î²] [ContinuousDiv Î²] (hu : Adapted f u) (hv : Adapted f v) :\n    Adapted f (u / v) := fun i => (hu i).div (hv i)\n\n"}
{"name":"MeasureTheory.Adapted.neg","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : Preorder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ¹ : AddGroup Î²\ninstâœ : TopologicalAddGroup Î²\nhu : MeasureTheory.Adapted f u\nâŠ¢ MeasureTheory.Adapted f (Neg.neg u)","decl":"@[to_additive]\nprotected theorem inv [Group Î²] [TopologicalGroup Î²] (hu : Adapted f u) :\n    Adapted f uâ»Â¹ := fun i => (hu i).inv\n\n"}
{"name":"MeasureTheory.Adapted.inv","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : Preorder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ¹ : Group Î²\ninstâœ : TopologicalGroup Î²\nhu : MeasureTheory.Adapted f u\nâŠ¢ MeasureTheory.Adapted f (Inv.inv u)","decl":"@[to_additive]\nprotected theorem inv [Group Î²] [TopologicalGroup Î²] (hu : Adapted f u) :\n    Adapted f uâ»Â¹ := fun i => (hu i).inv\n\n"}
{"name":"MeasureTheory.Adapted.smul","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : Preorder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ¹ : SMul Real Î²\ninstâœ : ContinuousSMul Real Î²\nc : Real\nhu : MeasureTheory.Adapted f u\nâŠ¢ MeasureTheory.Adapted f (HSMul.hSMul c u)","decl":"protected theorem smul [SMul â„ Î²] [ContinuousSMul â„ Î²] (c : â„) (hu : Adapted f u) :\n    Adapted f (c â€¢ u) := fun i => (hu i).const_smul c\n\n"}
{"name":"MeasureTheory.Adapted.stronglyMeasurable","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : Preorder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ni : Î¹\nhf : MeasureTheory.Adapted f u\nâŠ¢ MeasureTheory.StronglyMeasurable (u i)","decl":"protected theorem stronglyMeasurable {i : Î¹} (hf : Adapted f u) : StronglyMeasurable[m] (u i) :=\n  (hf i).mono (f.le i)\n\n"}
{"name":"MeasureTheory.Adapted.stronglyMeasurable_le","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : Preorder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ni j : Î¹\nhf : MeasureTheory.Adapted f u\nhij : LE.le i j\nâŠ¢ MeasureTheory.StronglyMeasurable (u i)","decl":"theorem stronglyMeasurable_le {i j : Î¹} (hf : Adapted f u) (hij : i â‰¤ j) :\n    StronglyMeasurable[f j] (u i) := (hf i).mono (f.mono hij)\n\n"}
{"name":"MeasureTheory.adapted_const","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\nx : Î²\nâŠ¢ MeasureTheory.Adapted f fun x_1 x_2 => x","decl":"theorem adapted_const (f : Filtration Î¹ m) (x : Î²) : Adapted f fun _ _ => x := fun _ =>\n  stronglyMeasurable_const\n\n"}
{"name":"MeasureTheory.adapted_zero","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Preorder Î¹\ninstâœ : Zero Î²\nf : MeasureTheory.Filtration Î¹ m\nâŠ¢ MeasureTheory.Adapted f 0","decl":"theorem adapted_zero [Zero Î²] (f : Filtration Î¹ m) : Adapted f (0 : Î¹ â†’ Î© â†’ Î²) := fun i =>\n  @stronglyMeasurable_zero Î© Î² (f i) _ _\n\n"}
{"name":"MeasureTheory.Filtration.adapted_natural","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : Preorder Î¹\ninstâœÂ¹ : TopologicalSpace.MetrizableSpace Î²\nmÎ² : MeasurableSpace Î²\ninstâœ : BorelSpace Î²\nu : Î¹ â†’ Î© â†’ Î²\nhum : âˆ€ (i : Î¹), MeasureTheory.StronglyMeasurable (u i)\nâŠ¢ MeasureTheory.Adapted (MeasureTheory.Filtration.natural u hum) u","decl":"theorem Filtration.adapted_natural [MetrizableSpace Î²] [mÎ² : MeasurableSpace Î²] [BorelSpace Î²]\n    {u : Î¹ â†’ Î© â†’ Î²} (hum : âˆ€ i, StronglyMeasurable[m] (u i)) :\n    Adapted (Filtration.natural u hum) u := by\n  intro i\n  refine StronglyMeasurable.mono ?_ (le_iSupâ‚‚_of_le i (le_refl i) le_rfl)\n  rw [stronglyMeasurable_iff_measurable_separable]\n  exact âŸ¨measurable_iff_comap_le.2 le_rfl, (hum i).isSeparable_rangeâŸ©\n\n"}
{"name":"MeasureTheory.progMeasurable_const","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Preorder Î¹\ninstâœ : MeasurableSpace Î¹\nf : MeasureTheory.Filtration Î¹ m\nb : Î²\nâŠ¢ MeasureTheory.ProgMeasurable f fun x x => b","decl":"theorem progMeasurable_const [MeasurableSpace Î¹] (f : Filtration Î¹ m) (b : Î²) :\n    ProgMeasurable f (fun _ _ => b : Î¹ â†’ Î© â†’ Î²) := fun i =>\n  @stronglyMeasurable_const _ _ (Subtype.instMeasurableSpace.prod (f i)) _ _\n\n"}
{"name":"MeasureTheory.ProgMeasurable.adapted","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : Preorder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœ : MeasurableSpace Î¹\nh : MeasureTheory.ProgMeasurable f u\nâŠ¢ MeasureTheory.Adapted f u","decl":"protected theorem adapted (h : ProgMeasurable f u) : Adapted f u := by\n  intro i\n  have : u i = (fun p : Set.Iic i Ã— Î© => u p.1 p.2) âˆ˜ fun x => (âŸ¨i, Set.mem_Iic.mpr le_rflâŸ©, x) :=\n    rfl\n  rw [this]\n  exact (h i).comp_measurable measurable_prod_mk_left\n\n"}
{"name":"MeasureTheory.ProgMeasurable.comp","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâµ : TopologicalSpace Î²\ninstâœâ´ : Preorder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ³ : MeasurableSpace Î¹\nt : Î¹ â†’ Î© â†’ Î¹\ninstâœÂ² : TopologicalSpace Î¹\ninstâœÂ¹ : BorelSpace Î¹\ninstâœ : TopologicalSpace.MetrizableSpace Î¹\nh : MeasureTheory.ProgMeasurable f u\nht : MeasureTheory.ProgMeasurable f t\nht_le : âˆ€ (i : Î¹) (Ï‰ : Î©), LE.le (t i Ï‰) i\nâŠ¢ MeasureTheory.ProgMeasurable f fun i Ï‰ => u (t i Ï‰) Ï‰","decl":"protected theorem comp {t : Î¹ â†’ Î© â†’ Î¹} [TopologicalSpace Î¹] [BorelSpace Î¹] [MetrizableSpace Î¹]\n    (h : ProgMeasurable f u) (ht : ProgMeasurable f t) (ht_le : âˆ€ i Ï‰, t i Ï‰ â‰¤ i) :\n    ProgMeasurable f fun i Ï‰ => u (t i Ï‰) Ï‰ := by\n  intro i\n  have : (fun p : â†¥(Set.Iic i) Ã— Î© => u (t (p.fst : Î¹) p.snd) p.snd) =\n    (fun p : â†¥(Set.Iic i) Ã— Î© => u (p.fst : Î¹) p.snd) âˆ˜ fun p : â†¥(Set.Iic i) Ã— Î© =>\n      (âŸ¨t (p.fst : Î¹) p.snd, Set.mem_Iic.mpr ((ht_le _ _).trans p.fst.prop)âŸ©, p.snd) := rfl\n  rw [this]\n  exact (h i).comp_measurable ((ht i).measurable.subtype_mk.prod_mk measurable_snd)\n\n"}
{"name":"MeasureTheory.ProgMeasurable.mul","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Preorder Î¹\nu v : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ² : MeasurableSpace Î¹\ninstâœÂ¹ : Mul Î²\ninstâœ : ContinuousMul Î²\nhu : MeasureTheory.ProgMeasurable f u\nhv : MeasureTheory.ProgMeasurable f v\nâŠ¢ MeasureTheory.ProgMeasurable f fun i Ï‰ => HMul.hMul (u i Ï‰) (v i Ï‰)","decl":"@[to_additive]\nprotected theorem mul [Mul Î²] [ContinuousMul Î²] (hu : ProgMeasurable f u)\n    (hv : ProgMeasurable f v) : ProgMeasurable f fun i Ï‰ => u i Ï‰ * v i Ï‰ := fun i =>\n  (hu i).mul (hv i)\n\n"}
{"name":"MeasureTheory.ProgMeasurable.add","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Preorder Î¹\nu v : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ² : MeasurableSpace Î¹\ninstâœÂ¹ : Add Î²\ninstâœ : ContinuousAdd Î²\nhu : MeasureTheory.ProgMeasurable f u\nhv : MeasureTheory.ProgMeasurable f v\nâŠ¢ MeasureTheory.ProgMeasurable f fun i Ï‰ => HAdd.hAdd (u i Ï‰) (v i Ï‰)","decl":"@[to_additive]\nprotected theorem mul [Mul Î²] [ContinuousMul Î²] (hu : ProgMeasurable f u)\n    (hv : ProgMeasurable f v) : ProgMeasurable f fun i Ï‰ => u i Ï‰ * v i Ï‰ := fun i =>\n  (hu i).mul (hv i)\n\n"}
{"name":"MeasureTheory.ProgMeasurable.finset_prod'","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ² : MeasurableSpace Î¹\nÎ³ : Type u_4\ninstâœÂ¹ : CommMonoid Î²\ninstâœ : ContinuousMul Î²\nU : Î³ â†’ Î¹ â†’ Î© â†’ Î²\ns : Finset Î³\nh : âˆ€ (c : Î³), Membership.mem s c â†’ MeasureTheory.ProgMeasurable f (U c)\nâŠ¢ MeasureTheory.ProgMeasurable f (s.prod fun c => U c)","decl":"@[to_additive]\nprotected theorem finset_prod' {Î³} [CommMonoid Î²] [ContinuousMul Î²] {U : Î³ â†’ Î¹ â†’ Î© â†’ Î²}\n    {s : Finset Î³} (h : âˆ€ c âˆˆ s, ProgMeasurable f (U c)) : ProgMeasurable f (âˆ c âˆˆ s, U c) :=\n  Finset.prod_induction U (ProgMeasurable f) (fun _ _ => ProgMeasurable.mul)\n    (progMeasurable_const _ 1) h\n\n"}
{"name":"MeasureTheory.ProgMeasurable.finset_sum'","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ² : MeasurableSpace Î¹\nÎ³ : Type u_4\ninstâœÂ¹ : AddCommMonoid Î²\ninstâœ : ContinuousAdd Î²\nU : Î³ â†’ Î¹ â†’ Î© â†’ Î²\ns : Finset Î³\nh : âˆ€ (c : Î³), Membership.mem s c â†’ MeasureTheory.ProgMeasurable f (U c)\nâŠ¢ MeasureTheory.ProgMeasurable f (s.sum fun c => U c)","decl":"@[to_additive]\nprotected theorem finset_prod' {Î³} [CommMonoid Î²] [ContinuousMul Î²] {U : Î³ â†’ Î¹ â†’ Î© â†’ Î²}\n    {s : Finset Î³} (h : âˆ€ c âˆˆ s, ProgMeasurable f (U c)) : ProgMeasurable f (âˆ c âˆˆ s, U c) :=\n  Finset.prod_induction U (ProgMeasurable f) (fun _ _ => ProgMeasurable.mul)\n    (progMeasurable_const _ 1) h\n\n"}
{"name":"MeasureTheory.ProgMeasurable.finset_prod","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ² : MeasurableSpace Î¹\nÎ³ : Type u_4\ninstâœÂ¹ : CommMonoid Î²\ninstâœ : ContinuousMul Î²\nU : Î³ â†’ Î¹ â†’ Î© â†’ Î²\ns : Finset Î³\nh : âˆ€ (c : Î³), Membership.mem s c â†’ MeasureTheory.ProgMeasurable f (U c)\nâŠ¢ MeasureTheory.ProgMeasurable f fun i a => s.prod fun c => U c i a","decl":"@[to_additive]\nprotected theorem finset_prod {Î³} [CommMonoid Î²] [ContinuousMul Î²] {U : Î³ â†’ Î¹ â†’ Î© â†’ Î²}\n    {s : Finset Î³} (h : âˆ€ c âˆˆ s, ProgMeasurable f (U c)) :\n    ProgMeasurable f fun i a => âˆ c âˆˆ s, U c i a := by\n  convert ProgMeasurable.finset_prod' h using 1; ext (i a); simp only [Finset.prod_apply]\n\n"}
{"name":"MeasureTheory.ProgMeasurable.finset_sum","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ² : MeasurableSpace Î¹\nÎ³ : Type u_4\ninstâœÂ¹ : AddCommMonoid Î²\ninstâœ : ContinuousAdd Î²\nU : Î³ â†’ Î¹ â†’ Î© â†’ Î²\ns : Finset Î³\nh : âˆ€ (c : Î³), Membership.mem s c â†’ MeasureTheory.ProgMeasurable f (U c)\nâŠ¢ MeasureTheory.ProgMeasurable f fun i a => s.sum fun c => U c i a","decl":"@[to_additive]\nprotected theorem finset_prod {Î³} [CommMonoid Î²] [ContinuousMul Î²] {U : Î³ â†’ Î¹ â†’ Î© â†’ Î²}\n    {s : Finset Î³} (h : âˆ€ c âˆˆ s, ProgMeasurable f (U c)) :\n    ProgMeasurable f fun i a => âˆ c âˆˆ s, U c i a := by\n  convert ProgMeasurable.finset_prod' h using 1; ext (i a); simp only [Finset.prod_apply]\n\n"}
{"name":"MeasureTheory.ProgMeasurable.inv","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Preorder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ² : MeasurableSpace Î¹\ninstâœÂ¹ : Group Î²\ninstâœ : TopologicalGroup Î²\nhu : MeasureTheory.ProgMeasurable f u\nâŠ¢ MeasureTheory.ProgMeasurable f fun i Ï‰ => Inv.inv (u i Ï‰)","decl":"@[to_additive]\nprotected theorem inv [Group Î²] [TopologicalGroup Î²] (hu : ProgMeasurable f u) :\n    ProgMeasurable f fun i Ï‰ => (u i Ï‰)â»Â¹ := fun i => (hu i).inv\n\n"}
{"name":"MeasureTheory.ProgMeasurable.neg","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Preorder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ² : MeasurableSpace Î¹\ninstâœÂ¹ : AddGroup Î²\ninstâœ : TopologicalAddGroup Î²\nhu : MeasureTheory.ProgMeasurable f u\nâŠ¢ MeasureTheory.ProgMeasurable f fun i Ï‰ => Neg.neg (u i Ï‰)","decl":"@[to_additive]\nprotected theorem inv [Group Î²] [TopologicalGroup Î²] (hu : ProgMeasurable f u) :\n    ProgMeasurable f fun i Ï‰ => (u i Ï‰)â»Â¹ := fun i => (hu i).inv\n\n"}
{"name":"MeasureTheory.ProgMeasurable.sub","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Preorder Î¹\nu v : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ² : MeasurableSpace Î¹\ninstâœÂ¹ : AddGroup Î²\ninstâœ : TopologicalAddGroup Î²\nhu : MeasureTheory.ProgMeasurable f u\nhv : MeasureTheory.ProgMeasurable f v\nâŠ¢ MeasureTheory.ProgMeasurable f fun i Ï‰ => HSub.hSub (u i Ï‰) (v i Ï‰)","decl":"@[to_additive]\nprotected theorem div [Group Î²] [TopologicalGroup Î²] (hu : ProgMeasurable f u)\n    (hv : ProgMeasurable f v) : ProgMeasurable f fun i Ï‰ => u i Ï‰ / v i Ï‰ := fun i =>\n  (hu i).div (hv i)\n\n"}
{"name":"MeasureTheory.ProgMeasurable.div","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Preorder Î¹\nu v : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ² : MeasurableSpace Î¹\ninstâœÂ¹ : Group Î²\ninstâœ : TopologicalGroup Î²\nhu : MeasureTheory.ProgMeasurable f u\nhv : MeasureTheory.ProgMeasurable f v\nâŠ¢ MeasureTheory.ProgMeasurable f fun i Ï‰ => HDiv.hDiv (u i Ï‰) (v i Ï‰)","decl":"@[to_additive]\nprotected theorem div [Group Î²] [TopologicalGroup Î²] (hu : ProgMeasurable f u)\n    (hv : ProgMeasurable f v) : ProgMeasurable f fun i Ï‰ => u i Ï‰ / v i Ï‰ := fun i =>\n  (hu i).div (hv i)\n\n"}
{"name":"MeasureTheory.progMeasurable_of_tendsto'","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâµ : TopologicalSpace Î²\ninstâœâ´ : Preorder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\nÎ³ : Type u_4\ninstâœÂ³ : MeasurableSpace Î¹\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\nfltr : Filter Î³\ninstâœÂ¹ : fltr.NeBot\ninstâœ : fltr.IsCountablyGenerated\nU : Î³ â†’ Î¹ â†’ Î© â†’ Î²\nh : âˆ€ (l : Î³), MeasureTheory.ProgMeasurable f (U l)\nh_tendsto : Filter.Tendsto U fltr (nhds u)\nâŠ¢ MeasureTheory.ProgMeasurable f u","decl":"theorem progMeasurable_of_tendsto' {Î³} [MeasurableSpace Î¹] [PseudoMetrizableSpace Î²]\n    (fltr : Filter Î³) [fltr.NeBot] [fltr.IsCountablyGenerated] {U : Î³ â†’ Î¹ â†’ Î© â†’ Î²}\n    (h : âˆ€ l, ProgMeasurable f (U l)) (h_tendsto : Tendsto U fltr (ð“ u)) : ProgMeasurable f u := by\n  intro i\n  apply @stronglyMeasurable_of_tendsto (Set.Iic i Ã— Î©) Î² Î³\n    (MeasurableSpace.prod _ (f i)) _ _ fltr _ _ _ _ fun l => h l i\n  rw [tendsto_pi_nhds] at h_tendsto âŠ¢\n  intro x\n  specialize h_tendsto x.fst\n  rw [tendsto_nhds] at h_tendsto âŠ¢\n  exact fun s hs h_mem => h_tendsto {g | g x.snd âˆˆ s} (hs.preimage (continuous_apply x.snd)) h_mem\n\n"}
{"name":"MeasureTheory.progMeasurable_of_tendsto","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : Preorder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ¹ : MeasurableSpace Î¹\ninstâœ : TopologicalSpace.PseudoMetrizableSpace Î²\nU : Nat â†’ Î¹ â†’ Î© â†’ Î²\nh : âˆ€ (l : Nat), MeasureTheory.ProgMeasurable f (U l)\nh_tendsto : Filter.Tendsto U Filter.atTop (nhds u)\nâŠ¢ MeasureTheory.ProgMeasurable f u","decl":"theorem progMeasurable_of_tendsto [MeasurableSpace Î¹] [PseudoMetrizableSpace Î²] {U : â„• â†’ Î¹ â†’ Î© â†’ Î²}\n    (h : âˆ€ l, ProgMeasurable f (U l)) (h_tendsto : Tendsto U atTop (ð“ u)) : ProgMeasurable f u :=\n  progMeasurable_of_tendsto' atTop h h_tendsto\n\n"}
{"name":"MeasureTheory.Adapted.progMeasurable_of_continuous","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ· : TopologicalSpace Î²\ninstâœâ¶ : Preorder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœâµ : TopologicalSpace Î¹\ninstâœâ´ : TopologicalSpace.MetrizableSpace Î¹\ninstâœÂ³ : SecondCountableTopology Î¹\ninstâœÂ² : MeasurableSpace Î¹\ninstâœÂ¹ : OpensMeasurableSpace Î¹\ninstâœ : TopologicalSpace.PseudoMetrizableSpace Î²\nh : MeasureTheory.Adapted f u\nhu_cont : âˆ€ (Ï‰ : Î©), Continuous fun i => u i Ï‰\nâŠ¢ MeasureTheory.ProgMeasurable f u","decl":"/-- A continuous and adapted process is progressively measurable. -/\ntheorem Adapted.progMeasurable_of_continuous [TopologicalSpace Î¹] [MetrizableSpace Î¹]\n    [SecondCountableTopology Î¹] [MeasurableSpace Î¹] [OpensMeasurableSpace Î¹]\n    [PseudoMetrizableSpace Î²] (h : Adapted f u) (hu_cont : âˆ€ Ï‰, Continuous fun i => u i Ï‰) :\n    ProgMeasurable f u := fun i =>\n  @stronglyMeasurable_uncurry_of_continuous_of_stronglyMeasurable _ _ (Set.Iic i) _ _ _ _ _ _ _\n    (f i) _ (fun Ï‰ => (hu_cont Ï‰).comp continuous_induced_dom) fun j => (h j).mono (f.mono j.prop)\n\n"}
{"name":"MeasureTheory.Adapted.progMeasurable_of_discrete","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ· : TopologicalSpace Î²\ninstâœâ¶ : Preorder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nf : MeasureTheory.Filtration Î¹ m\ninstâœâµ : TopologicalSpace Î¹\ninstâœâ´ : DiscreteTopology Î¹\ninstâœÂ³ : SecondCountableTopology Î¹\ninstâœÂ² : MeasurableSpace Î¹\ninstâœÂ¹ : OpensMeasurableSpace Î¹\ninstâœ : TopologicalSpace.PseudoMetrizableSpace Î²\nh : MeasureTheory.Adapted f u\nâŠ¢ MeasureTheory.ProgMeasurable f u","decl":"/-- For filtrations indexed by a discrete order, `Adapted` and `ProgMeasurable` are equivalent.\nThis lemma provides `Adapted f u â†’ ProgMeasurable f u`.\nSee `ProgMeasurable.adapted` for the reverse direction, which is true more generally. -/\ntheorem Adapted.progMeasurable_of_discrete [TopologicalSpace Î¹] [DiscreteTopology Î¹]\n    [SecondCountableTopology Î¹] [MeasurableSpace Î¹] [OpensMeasurableSpace Î¹]\n    [PseudoMetrizableSpace Î²] (h : Adapted f u) : ProgMeasurable f u :=\n  h.progMeasurable_of_continuous fun _ => continuous_of_discreteTopology\n\n-- this dot notation will make more sense once we have a more general definition for predictable\n"}
{"name":"MeasureTheory.Predictable.adapted","module":"Mathlib.Probability.Process.Adapted","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î©\ninstâœ : TopologicalSpace Î²\nf : MeasureTheory.Filtration Nat m\nu : Nat â†’ Î© â†’ Î²\nhu : MeasureTheory.Adapted f fun n => u (HAdd.hAdd n 1)\nhu0 : MeasureTheory.StronglyMeasurable (u 0)\nâŠ¢ MeasureTheory.Adapted f u","decl":"theorem Predictable.adapted {f : Filtration â„• m} {u : â„• â†’ Î© â†’ Î²} (hu : Adapted f fun n => u (n + 1))\n    (hu0 : StronglyMeasurable[f 0] (u 0)) : Adapted f u := fun n =>\n  match n with\n  | 0 => hu0\n  | n + 1 => (hu n).mono (f.mono n.le_succ)\n\n"}
