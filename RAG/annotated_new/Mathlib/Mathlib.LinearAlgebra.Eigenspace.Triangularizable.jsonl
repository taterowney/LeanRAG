{"name":"Module.End.exists_hasEigenvalue_of_genEigenspace_eq_top","module":"Mathlib.LinearAlgebra.Eigenspace.Triangularizable","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Nontrivial M\nf : Module.End R M\nk : ENat\nhf : Eq (iSup fun μ => (f.genEigenspace μ) k) Top.top\n⊢ Exists fun μ => f.HasEigenvalue μ","decl":"theorem exists_hasEigenvalue_of_genEigenspace_eq_top [Nontrivial M] {f : End R M} (k : ℕ∞)\n    (hf : ⨆ μ, f.genEigenspace μ k = ⊤) :\n    ∃ μ, f.HasEigenvalue μ := by\n  suffices ∃ μ, f.HasUnifEigenvalue μ k by\n    peel this with μ hμ\n    exact HasUnifEigenvalue.lt zero_lt_one hμ\n  simp [HasUnifEigenvalue, ← not_forall, ← iSup_eq_bot, hf]\n\n"}
{"name":"Module.End.exists_hasEigenvalue_of_iSup_genEigenspace_eq_top","module":"Mathlib.LinearAlgebra.Eigenspace.Triangularizable","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Nontrivial M\nf : Module.End R M\nhf : Eq (iSup fun μ => iSup fun k => (f.genEigenspace μ) ↑k) Top.top\n⊢ Exists fun μ => f.HasEigenvalue μ","decl":"@[deprecated exists_hasEigenvalue_of_genEigenspace_eq_top (since := \"2024-10-11\")]\ntheorem exists_hasEigenvalue_of_iSup_genEigenspace_eq_top [Nontrivial M] {f : End R M}\n    (hf : ⨆ μ, ⨆ k : ℕ, f.genEigenspace μ k = ⊤) :\n    ∃ μ, f.HasEigenvalue μ := by\n  simp_rw [iSup_genEigenspace_eq] at hf\n  apply exists_hasEigenvalue_of_genEigenspace_eq_top _ hf\n\n-- This is Lemma 5.21 of [axler2015], although we are no longer following that proof.\n"}
{"name":"Module.End.exists_eigenvalue","module":"Mathlib.LinearAlgebra.Eigenspace.Triangularizable","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝⁵ : Field K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\ninst✝² : IsAlgClosed K\ninst✝¹ : FiniteDimensional K V\ninst✝ : Nontrivial V\nf : Module.End K V\n⊢ Exists fun c => f.HasEigenvalue c","decl":"/-- In finite dimensions, over an algebraically closed field, every linear endomorphism has an\neigenvalue. -/\ntheorem exists_eigenvalue [IsAlgClosed K] [FiniteDimensional K V] [Nontrivial V] (f : End K V) :\n    ∃ c : K, f.HasEigenvalue c := by\n  simp_rw [hasEigenvalue_iff_mem_spectrum]\n  exact spectrum.nonempty_of_isAlgClosed_of_finiteDimensional K f\n\n"}
{"name":"Module.End.iSup_maxGenEigenspace_eq_top","module":"Mathlib.LinearAlgebra.Eigenspace.Triangularizable","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝⁴ : Field K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : IsAlgClosed K\ninst✝ : FiniteDimensional K V\nf : Module.End K V\n⊢ Eq (iSup fun μ => f.maxGenEigenspace μ) Top.top","decl":"/-- In finite dimensions, over an algebraically closed field, the generalized eigenspaces of any\nlinear endomorphism span the whole space. -/\ntheorem iSup_maxGenEigenspace_eq_top [IsAlgClosed K] [FiniteDimensional K V] (f : End K V) :\n    ⨆ (μ : K), f.maxGenEigenspace μ = ⊤ := by\n  -- We prove the claim by strong induction on the dimension of the vector space.\n  induction' h_dim : finrank K V using Nat.strong_induction_on with n ih generalizing V\n  cases' n with n\n  -- If the vector space is 0-dimensional, the result is trivial.\n  · rw [← top_le_iff]\n    simp only [Submodule.finrank_eq_zero.1 (Eq.trans (finrank_top _ _) h_dim), bot_le]\n  -- Otherwise the vector space is nontrivial.\n  · haveI : Nontrivial V := finrank_pos_iff.1 (by rw [h_dim]; apply Nat.zero_lt_succ)\n    -- Hence, `f` has an eigenvalue `μ₀`.\n    obtain ⟨μ₀, hμ₀⟩ : ∃ μ₀, f.HasEigenvalue μ₀ := exists_eigenvalue f\n    -- We define `ES` to be the generalized eigenspace\n    let ES := f.genEigenspace μ₀ (finrank K V)\n    -- and `ER` to be the generalized eigenrange.\n    let ER := f.genEigenrange μ₀ (finrank K V)\n    -- `f` maps `ER` into itself.\n    have h_f_ER : ∀ x : V, x ∈ ER → f x ∈ ER := fun x hx =>\n      map_genEigenrange_le (Submodule.mem_map_of_mem hx)\n    -- Therefore, we can define the restriction `f'` of `f` to `ER`.\n    let f' : End K ER := f.restrict h_f_ER\n    -- The dimension of `ES` is positive\n    have h_dim_ES_pos : 0 < finrank K ES := by\n      dsimp only [ES]\n      rw [h_dim]\n      apply pos_finrank_genEigenspace_of_hasEigenvalue hμ₀ (Nat.zero_lt_succ n)\n    -- and the dimensions of `ES` and `ER` add up to `finrank K V`.\n    have h_dim_add : finrank K ER + finrank K ES = finrank K V := by\n      dsimp only [ER, ES]\n      rw [Module.End.genEigenspace_nat, Module.End.genEigenrange_nat]\n      apply LinearMap.finrank_range_add_finrank_ker\n    -- Therefore the dimension `ER` mus be smaller than `finrank K V`.\n    have h_dim_ER : finrank K ER < n.succ := by omega\n    -- This allows us to apply the induction hypothesis on `ER`:\n    have ih_ER : ⨆ (μ : K), f'.maxGenEigenspace μ = ⊤ :=\n      ih (finrank K ER) h_dim_ER f' rfl\n    -- The induction hypothesis gives us a statement about subspaces of `ER`. We can transfer this\n    -- to a statement about subspaces of `V` via `Submodule.subtype`:\n    have ih_ER' : ⨆ (μ : K), (f'.maxGenEigenspace μ).map ER.subtype = ER := by\n      simp only [(Submodule.map_iSup _ _).symm, ih_ER, Submodule.map_subtype_top ER]\n    -- Moreover, every generalized eigenspace of `f'` is contained in the corresponding generalized\n    -- eigenspace of `f`.\n    have hff' :\n      ∀ μ, (f'.maxGenEigenspace μ).map ER.subtype ≤ f.maxGenEigenspace μ := by\n      intros\n      rw [maxGenEigenspace, genEigenspace_restrict]\n      apply Submodule.map_comap_le\n    -- It follows that `ER` is contained in the span of all generalized eigenvectors.\n    have hER : ER ≤ ⨆ (μ : K), f.maxGenEigenspace μ := by\n      rw [← ih_ER']\n      exact iSup_mono hff'\n    -- `ES` is contained in this span by definition.\n    have hES : ES ≤ ⨆ (μ : K), f.maxGenEigenspace μ :=\n      ((f.genEigenspace μ₀).mono le_top).trans (le_iSup f.maxGenEigenspace μ₀)\n    -- Moreover, we know that `ER` and `ES` are disjoint.\n    have h_disjoint : Disjoint ER ES := generalized_eigenvec_disjoint_range_ker f μ₀\n    -- Since the dimensions of `ER` and `ES` add up to the dimension of `V`, it follows that the\n    -- span of all generalized eigenvectors is all of `V`.\n    show ⨆ (μ : K), f.maxGenEigenspace μ = ⊤\n    rw [← top_le_iff, ← Submodule.eq_top_of_disjoint ER ES h_dim_add.ge h_disjoint]\n    apply sup_le hER hES\n\n-- Lemma 8.21 of [axler2015]\n"}
{"name":"Module.End.iSup_genEigenspace_eq_top","module":"Mathlib.LinearAlgebra.Eigenspace.Triangularizable","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝⁴ : Field K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : IsAlgClosed K\ninst✝ : FiniteDimensional K V\nf : Module.End K V\n⊢ Eq (iSup fun μ => iSup fun k => (f.genEigenspace μ) ↑k) Top.top","decl":"/-- In finite dimensions, over an algebraically closed field, the generalized eigenspaces of any\nlinear endomorphism span the whole space. -/\n@[deprecated iSup_maxGenEigenspace_eq_top (since := \"2024-10-11\")]\ntheorem iSup_genEigenspace_eq_top [IsAlgClosed K] [FiniteDimensional K V] (f : End K V) :\n    ⨆ (μ : K) (k : ℕ), f.genEigenspace μ k = ⊤ := by\n  simp_rw [iSup_genEigenspace_eq]\n  apply iSup_maxGenEigenspace_eq_top\n\n"}
{"name":"Submodule.inf_iSup_genEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Triangularizable","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\np : Submodule K V\nf : Module.End K V\ninst✝ : FiniteDimensional K V\nh : ∀ (x : V), Membership.mem p x → Membership.mem p (f x)\nk : ENat\n⊢ Eq (Min.min p (iSup fun μ => (f.genEigenspace μ) k)) (iSup fun μ => Min.min p ((f.genEigenspace μ) k))","decl":"theorem inf_iSup_genEigenspace [FiniteDimensional K V] (h : ∀ x ∈ p, f x ∈ p) (k : ℕ∞) :\n    p ⊓ ⨆ μ, f.genEigenspace μ k = ⨆ μ, p ⊓ f.genEigenspace μ k := by\n  refine le_antisymm (fun m hm ↦ ?_)\n    (le_inf_iff.mpr ⟨iSup_le fun μ ↦ inf_le_left, iSup_mono fun μ ↦ inf_le_right⟩)\n  classical\n  obtain ⟨hm₀ : m ∈ p, hm₁ : m ∈ ⨆ μ, f.genEigenspace μ k⟩ := hm\n  obtain ⟨m, hm₂, rfl⟩ := (mem_iSup_iff_exists_finsupp _ _).mp hm₁\n  suffices ∀ μ, (m μ : V) ∈ p by\n    exact (mem_iSup_iff_exists_finsupp _ _).mpr ⟨m, fun μ ↦ mem_inf.mp ⟨this μ, hm₂ μ⟩, rfl⟩\n  intro μ\n  by_cases hμ : μ ∈ m.support; swap\n  · simp only [Finsupp.not_mem_support_iff.mp hμ, p.zero_mem]\n  have hm₂_aux := hm₂\n  simp_rw [Module.End.mem_genEigenspace] at hm₂_aux\n  choose l hlk hl using hm₂_aux\n  let l₀ : ℕ := m.support.sup l\n  have h_comm : ∀ (μ₁ μ₂ : K),\n    Commute ((f - algebraMap K (End K V) μ₁) ^ l₀)\n            ((f - algebraMap K (End K V) μ₂) ^ l₀) := fun μ₁ μ₂ ↦\n    ((Commute.sub_right rfl <| Algebra.commute_algebraMap_right _ _).sub_left\n      (Algebra.commute_algebraMap_left _ _)).pow_pow _ _\n  let g : End K V := (m.support.erase μ).noncommProd _ fun μ₁ _ μ₂ _ _ ↦ h_comm μ₁ μ₂\n  have hfg : Commute f g := Finset.noncommProd_commute _ _ _ _ fun μ' _ ↦\n    (Commute.sub_right rfl <| Algebra.commute_algebraMap_right _ _).pow_right _\n  have hg₀ : g (m.sum fun _μ mμ ↦ mμ) = g (m μ) := by\n    suffices ∀ μ' ∈ m.support, g (m μ') = if μ' = μ then g (m μ) else 0 by\n      rw [map_finsupp_sum, Finsupp.sum_congr (g2 := fun μ' _ ↦ if μ' = μ then g (m μ) else 0) this,\n        Finsupp.sum_ite_eq', if_pos hμ]\n    rintro μ' hμ'\n    split_ifs with hμμ'\n    · rw [hμμ']\n    have hl₀ : ((f - algebraMap K (End K V) μ') ^ l₀) (m μ') = 0 := by\n      rw [← LinearMap.mem_ker, Algebra.algebraMap_eq_smul_one, ← End.mem_genEigenspace_nat]\n      simp_rw [← End.mem_genEigenspace_nat] at hl\n      suffices (l μ' : ℕ∞) ≤ l₀ from (f.genEigenspace μ').mono this (hl μ')\n      simpa only [Nat.cast_le] using Finset.le_sup hμ'\n    have : _ = g := (m.support.erase μ).noncommProd_erase_mul (Finset.mem_erase.mpr ⟨hμμ', hμ'⟩)\n      (fun μ ↦ (f - algebraMap K (End K V) μ) ^ l₀) (fun μ₁ _ μ₂ _ _ ↦ h_comm μ₁ μ₂)\n    rw [← this, LinearMap.mul_apply, hl₀, _root_.map_zero]\n  have hg₁ : MapsTo g p p := Finset.noncommProd_induction _ _ _ (fun g' : End K V ↦ MapsTo g' p p)\n      (fun f₁ f₂ ↦ MapsTo.comp) (mapsTo_id _) fun μ' _ ↦ by\n    suffices MapsTo (f - algebraMap K (End K V) μ') p p by\n      simp only [LinearMap.coe_pow]; exact this.iterate l₀\n    intro x hx\n    rw [LinearMap.sub_apply, algebraMap_end_apply]\n    exact p.sub_mem (h _ hx) (smul_mem p μ' hx)\n  have hg₂ : MapsTo g ↑(f.genEigenspace μ k) ↑(f.genEigenspace μ k) :=\n    f.mapsTo_genEigenspace_of_comm hfg μ k\n  have hg₃ : InjOn g ↑(f.genEigenspace μ k) := by\n    apply LinearMap.injOn_of_disjoint_ker (subset_refl _)\n    have this := f.independent_genEigenspace k\n    have aux (μ') (_hμ' : μ' ∈ m.support.erase μ) :\n        (f.genEigenspace μ') ↑l₀ ≤ (f.genEigenspace μ') k := by\n      apply (f.genEigenspace μ').mono\n      rintro k rfl\n      simp only [ENat.some_eq_coe, Nat.cast_inj, exists_eq_left']\n      apply Finset.sup_le\n      intro i _hi\n      simpa using hlk i\n    rw [LinearMap.ker_noncommProd_eq_of_supIndep_ker, ← Finset.sup_eq_iSup]\n    · have := Finset.supIndep_iff_disjoint_erase.mp (this.supIndep' m.support) μ hμ\n      apply this.mono_right\n      apply Finset.sup_mono_fun\n      intro μ' hμ'\n      rw [Algebra.algebraMap_eq_smul_one, ← End.genEigenspace_nat]\n      apply aux μ' hμ'\n    · have := this.supIndep' (m.support.erase μ)\n      apply this.antitone_fun\n      intro μ' hμ'\n      rw [Algebra.algebraMap_eq_smul_one, ← End.genEigenspace_nat]\n      apply aux μ' hμ'\n  have hg₄ : SurjOn g\n      ↑(p ⊓ f.genEigenspace μ k) ↑(p ⊓ f.genEigenspace μ k) := by\n    have : MapsTo g\n        ↑(p ⊓ f.genEigenspace μ k) ↑(p ⊓ f.genEigenspace μ k) :=\n      hg₁.inter_inter hg₂\n    rw [← LinearMap.injOn_iff_surjOn this]\n    exact hg₃.mono inter_subset_right\n  specialize hm₂ μ\n  obtain ⟨y, ⟨hy₀ : y ∈ p, hy₁ : y ∈ f.genEigenspace μ k⟩, hy₂ : g y = g (m μ)⟩ :=\n    hg₄ ⟨(hg₀ ▸ hg₁ hm₀), hg₂ hm₂⟩\n  rwa [← hg₃ hy₁ hm₂ hy₂]\n\n"}
{"name":"Submodule.eq_iSup_inf_genEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Triangularizable","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\np : Submodule K V\nf : Module.End K V\ninst✝ : FiniteDimensional K V\nk : ENat\nh : ∀ (x : V), Membership.mem p x → Membership.mem p (f x)\nh' : Eq (iSup fun μ => (f.genEigenspace μ) k) Top.top\n⊢ Eq p (iSup fun μ => Min.min p ((f.genEigenspace μ) k))","decl":"theorem eq_iSup_inf_genEigenspace [FiniteDimensional K V] (k : ℕ∞)\n    (h : ∀ x ∈ p, f x ∈ p) (h' : ⨆ μ, f.genEigenspace μ k = ⊤) :\n    p = ⨆ μ, p ⊓ f.genEigenspace μ k := by\n  rw [← inf_iSup_genEigenspace h, h', inf_top_eq]\n\n"}
{"name":"Module.End.genEigenspace_restrict_eq_top","module":"Mathlib.LinearAlgebra.Eigenspace.Triangularizable","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\np : Submodule K V\nf : Module.End K V\ninst✝ : FiniteDimensional K V\nk : ENat\nh : ∀ (x : V), Membership.mem p x → Membership.mem p (f x)\nh' : Eq (iSup fun μ => (f.genEigenspace μ) k) Top.top\n⊢ Eq (iSup fun μ => (Module.End.genEigenspace (LinearMap.restrict f h) μ) k) Top.top","decl":"/-- In finite dimensions, if the generalized eigenspaces of a linear endomorphism span the whole\nspace then the same is true of its restriction to any invariant submodule. -/\ntheorem Module.End.genEigenspace_restrict_eq_top\n    {p : Submodule K V} {f : Module.End K V} [FiniteDimensional K V] {k : ℕ∞}\n    (h : ∀ x ∈ p, f x ∈ p) (h' : ⨆ μ, f.genEigenspace μ k = ⊤) :\n    ⨆ μ, Module.End.genEigenspace (LinearMap.restrict f h) μ k = ⊤ := by\n  have := congr_arg (Submodule.comap p.subtype) (Submodule.eq_iSup_inf_genEigenspace k h h')\n  have h_inj : Function.Injective p.subtype := Subtype.coe_injective\n  simp_rw [Submodule.inf_genEigenspace f p h, Submodule.comap_subtype_self,\n    ← Submodule.map_iSup, Submodule.comap_map_eq_of_injective h_inj] at this\n  exact this.symm\n\n"}
{"name":"Module.End.iSup_genEigenspace_restrict_eq_top","module":"Mathlib.LinearAlgebra.Eigenspace.Triangularizable","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\np : Submodule K V\nf : Module.End K V\ninst✝ : FiniteDimensional K V\nh : ∀ (x : V), Membership.mem p x → Membership.mem p (f x)\nh' : Eq (iSup fun μ => iSup fun k => (f.genEigenspace μ) ↑k) Top.top\n⊢ Eq (iSup fun μ => iSup fun k => (Module.End.genEigenspace (LinearMap.restrict f h) μ) ↑k) Top.top","decl":"/-- In finite dimensions, if the generalized eigenspaces of a linear endomorphism span the whole\nspace then the same is true of its restriction to any invariant submodule. -/\n@[deprecated Module.End.genEigenspace_restrict_eq_top (since := \"2024-10-11\")]\ntheorem Module.End.iSup_genEigenspace_restrict_eq_top\n    {p : Submodule K V} {f : Module.End K V} [FiniteDimensional K V]\n    (h : ∀ x ∈ p, f x ∈ p) (h' : ⨆ μ, ⨆ k : ℕ, f.genEigenspace μ k = ⊤) :\n    ⨆ μ, ⨆ k : ℕ, Module.End.genEigenspace (LinearMap.restrict f h) μ k = ⊤ := by\n  simp_rw [iSup_genEigenspace_eq] at h' ⊢\n  apply Module.End.genEigenspace_restrict_eq_top h h'\n"}
