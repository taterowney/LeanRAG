{"name":"CategoryTheory.ShortComplex.toComposableArrows_map","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nX✝ Y✝ : Fin (HAdd.hAdd (HAdd.hAdd 1 1) 1)\ng : Quiver.Hom X✝ Y✝\n⊢ Eq (S.toComposableArrows.map g) (CategoryTheory.ComposableArrows.Precomp.map (CategoryTheory.ComposableArrows.mk₁ S.g) S.f X✝ Y✝ ⋯)","decl":"/-- The composable arrows associated to a short complex. -/\n@[simps!]\ndef ShortComplex.toComposableArrows (S : ShortComplex C) : ComposableArrows C 2 :=\n  ComposableArrows.mk₂ S.f S.g\n\n"}
{"name":"CategoryTheory.ShortComplex.toComposableArrows_obj","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\na✝ : Fin (HAdd.hAdd (HAdd.hAdd 1 1) 1)\n⊢ Eq (S.toComposableArrows.obj a✝) (CategoryTheory.ComposableArrows.Precomp.obj (CategoryTheory.ComposableArrows.mk₁ S.g) S.X₁ a✝)","decl":"/-- The composable arrows associated to a short complex. -/\n@[simps!]\ndef ShortComplex.toComposableArrows (S : ShortComplex C) : ComposableArrows C 2 :=\n  ComposableArrows.mk₂ S.f S.g\n\n"}
{"name":"CategoryTheory.ComposableArrows.IsComplex.zero","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS : CategoryTheory.ComposableArrows C n\nself : S.IsComplex\ni : Nat\nhi : autoParam (LE.le (HAdd.hAdd i 2) n) _auto✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.map' i (HAdd.hAdd i 1) ⋯ ⋯) (S.map' (HAdd.hAdd i 1) (HAdd.hAdd i 2) ⋯ ⋯)) 0","decl":"/-- `F : ComposableArrows C n` is a complex if all compositions of\ntwo consecutive arrows are zero. -/\nstructure IsComplex : Prop where\n  /-- the composition of two consecutive arrows is zero -/\n  zero (i : ℕ) (hi : i + 2 ≤ n := by omega) :\n    S.map' i (i + 1) ≫ S.map' (i + 1) (i + 2) = 0\n\n"}
{"name":"CategoryTheory.ComposableArrows.IsComplex.zero_assoc","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS : CategoryTheory.ComposableArrows C n\nself : S.IsComplex\ni : Nat\nhi : autoParam (LE.le (HAdd.hAdd i 2) n) _auto✝\nZ : C\nh : Quiver.Hom (S.obj ⟨HAdd.hAdd i 2, ⋯⟩) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.map' i (HAdd.hAdd i 1) ⋯ ⋯) (CategoryTheory.CategoryStruct.comp (S.map' (HAdd.hAdd i 1) (HAdd.hAdd i 2) ⋯ ⋯) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc] IsComplex.zero\n\n"}
{"name":"CategoryTheory.ComposableArrows.IsComplex.zero'_assoc","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS : CategoryTheory.ComposableArrows C n\nhS : S.IsComplex\ni j k : Nat\nhij : autoParam (Eq (HAdd.hAdd i 1) j) _auto✝\nhjk : autoParam (Eq (HAdd.hAdd j 1) k) _auto✝\nhk : autoParam (LE.le k n) _auto✝\nZ : C\nh : Quiver.Hom (S.obj ⟨k, ⋯⟩) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.map' i j ⋯ ⋯) (CategoryTheory.CategoryStruct.comp (S.map' j k ⋯ ⋯) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma IsComplex.zero' (hS : S.IsComplex) (i j k : ℕ) (hij : i + 1 = j := by omega)\n    (hjk : j + 1 = k := by omega) (hk : k ≤ n := by omega) :\n    S.map' i j ≫ S.map' j k = 0 := by\n  subst hij hjk\n  exact hS.zero i hk\n\n"}
{"name":"CategoryTheory.ComposableArrows.IsComplex.zero'","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS : CategoryTheory.ComposableArrows C n\nhS : S.IsComplex\ni j k : Nat\nhij : autoParam (Eq (HAdd.hAdd i 1) j) _auto✝\nhjk : autoParam (Eq (HAdd.hAdd j 1) k) _auto✝\nhk : autoParam (LE.le k n) _auto✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.map' i j ⋯ ⋯) (S.map' j k ⋯ ⋯)) 0","decl":"@[reassoc]\nlemma IsComplex.zero' (hS : S.IsComplex) (i j k : ℕ) (hij : i + 1 = j := by omega)\n    (hjk : j + 1 = k := by omega) (hk : k ≤ n := by omega) :\n    S.map' i j ≫ S.map' j k = 0 := by\n  subst hij hjk\n  exact hS.zero i hk\n\n"}
{"name":"CategoryTheory.ComposableArrows.isComplex_of_iso","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.IsComplex\n⊢ S₂.IsComplex","decl":"lemma isComplex_of_iso {S₁ S₂ : ComposableArrows C n} (e : S₁ ≅ S₂) (h₁ : S₁.IsComplex) :\n    S₂.IsComplex where\n  zero i hi := by\n    rw [← cancel_epi (ComposableArrows.app' e.hom i), comp_zero,\n      ← NatTrans.naturality_assoc, ← NatTrans.naturality,\n      reassoc_of% (h₁.zero i hi), zero_comp]\n\n"}
{"name":"CategoryTheory.ComposableArrows.isComplex_iff_of_iso","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\ne : CategoryTheory.Iso S₁ S₂\n⊢ Iff S₁.IsComplex S₂.IsComplex","decl":"lemma isComplex_iff_of_iso {S₁ S₂ : ComposableArrows C n} (e : S₁ ≅ S₂) :\n    S₁.IsComplex ↔ S₂.IsComplex :=\n  ⟨isComplex_of_iso e, isComplex_of_iso e.symm⟩\n\n"}
{"name":"CategoryTheory.ComposableArrows.isComplex₀","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ComposableArrows C 0\n⊢ S.IsComplex","decl":"lemma isComplex₀ (S : ComposableArrows C 0) : S.IsComplex where\n  -- See https://github.com/leanprover/lean4/issues/2862\n  -- Without `decide := true`, simp gets stuck at `hi : autoParam False _auto✝`\n  zero i hi := by simp +decide at hi\n\n"}
{"name":"CategoryTheory.ComposableArrows.isComplex₁","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ComposableArrows C 1\n⊢ S.IsComplex","decl":"lemma isComplex₁ (S : ComposableArrows C 1) : S.IsComplex where\n  zero i hi := by omega\n\n"}
{"name":"CategoryTheory.ComposableArrows.Exact.exact","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS : CategoryTheory.ComposableArrows C n\nself : S.Exact\ni : Nat\nhi : autoParam (LE.le (HAdd.hAdd i 2) n) _auto✝\n⊢ (S.sc ⋯ i ⋯).Exact","decl":"/-- `F : ComposableArrows C n` is exact if it is a complex and that all short\ncomplexes consisting of two consecutive arrows are exact. -/\nstructure Exact extends S.IsComplex : Prop where\n  exact (i : ℕ) (hi : i + 2 ≤ n := by omega) : (S.sc toIsComplex i).Exact\n\n"}
{"name":"CategoryTheory.ComposableArrows.Exact.toIsComplex","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS : CategoryTheory.ComposableArrows C n\nself : S.Exact\n⊢ S.IsComplex","decl":"/-- `F : ComposableArrows C n` is exact if it is a complex and that all short\ncomplexes consisting of two consecutive arrows are exact. -/\nstructure Exact extends S.IsComplex : Prop where\n  exact (i : ℕ) (hi : i + 2 ≤ n := by omega) : (S.sc toIsComplex i).Exact\n\n"}
{"name":"CategoryTheory.ComposableArrows.Exact.exact'","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS : CategoryTheory.ComposableArrows C n\nhS : S.Exact\ni j k : Nat\nhij : autoParam (Eq (HAdd.hAdd i 1) j) _auto✝\nhjk : autoParam (Eq (HAdd.hAdd j 1) k) _auto✝\nhk : autoParam (LE.le k n) _auto✝\n⊢ (S.sc' ⋯ i j k ⋯ ⋯ ⋯).Exact","decl":"lemma Exact.exact' (hS : S.Exact) (i j k : ℕ) (hij : i + 1 = j := by omega)\n    (hjk : j + 1 = k := by omega) (hk : k ≤ n := by omega) :\n    (S.sc' hS.toIsComplex i j k).Exact := by\n  subst hij hjk\n  exact hS.exact i hk\n\n"}
{"name":"CategoryTheory.ComposableArrows.sc'Map_τ₃","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.IsComplex\nh₂ : S₂.IsComplex\ni j k : Nat\nhij : autoParam (Eq (HAdd.hAdd i 1) j) _auto✝\nhjk : autoParam (Eq (HAdd.hAdd j 1) k) _auto✝\nhk : autoParam (LE.le k n) _auto✝\n⊢ Eq (CategoryTheory.ComposableArrows.sc'Map φ h₁ h₂ i j k hij hjk hk).τ₃ (φ.app ⟨k, ⋯⟩)","decl":"/-- Functoriality maps for `ComposableArrows.sc'`. -/\n@[simps]\ndef sc'Map {S₁ S₂ : ComposableArrows C n} (φ : S₁ ⟶ S₂) (h₁ : S₁.IsComplex) (h₂ : S₂.IsComplex)\n    (i j k : ℕ) (hij : i + 1 = j := by omega)\n    (hjk : j + 1 = k := by omega) (hk : k ≤ n := by omega) :\n    S₁.sc' h₁ i j k ⟶ S₂.sc' h₂ i j k where\n  τ₁ := φ.app _\n  τ₂ := φ.app _\n  τ₃ := φ.app _\n\n"}
{"name":"CategoryTheory.ComposableArrows.sc'Map_τ₁","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.IsComplex\nh₂ : S₂.IsComplex\ni j k : Nat\nhij : autoParam (Eq (HAdd.hAdd i 1) j) _auto✝\nhjk : autoParam (Eq (HAdd.hAdd j 1) k) _auto✝\nhk : autoParam (LE.le k n) _auto✝\n⊢ Eq (CategoryTheory.ComposableArrows.sc'Map φ h₁ h₂ i j k hij hjk hk).τ₁ (φ.app ⟨i, ⋯⟩)","decl":"/-- Functoriality maps for `ComposableArrows.sc'`. -/\n@[simps]\ndef sc'Map {S₁ S₂ : ComposableArrows C n} (φ : S₁ ⟶ S₂) (h₁ : S₁.IsComplex) (h₂ : S₂.IsComplex)\n    (i j k : ℕ) (hij : i + 1 = j := by omega)\n    (hjk : j + 1 = k := by omega) (hk : k ≤ n := by omega) :\n    S₁.sc' h₁ i j k ⟶ S₂.sc' h₂ i j k where\n  τ₁ := φ.app _\n  τ₂ := φ.app _\n  τ₃ := φ.app _\n\n"}
{"name":"CategoryTheory.ComposableArrows.sc'Map_τ₂","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.IsComplex\nh₂ : S₂.IsComplex\ni j k : Nat\nhij : autoParam (Eq (HAdd.hAdd i 1) j) _auto✝\nhjk : autoParam (Eq (HAdd.hAdd j 1) k) _auto✝\nhk : autoParam (LE.le k n) _auto✝\n⊢ Eq (CategoryTheory.ComposableArrows.sc'Map φ h₁ h₂ i j k hij hjk hk).τ₂ (φ.app ⟨j, ⋯⟩)","decl":"/-- Functoriality maps for `ComposableArrows.sc'`. -/\n@[simps]\ndef sc'Map {S₁ S₂ : ComposableArrows C n} (φ : S₁ ⟶ S₂) (h₁ : S₁.IsComplex) (h₂ : S₂.IsComplex)\n    (i j k : ℕ) (hij : i + 1 = j := by omega)\n    (hjk : j + 1 = k := by omega) (hk : k ≤ n := by omega) :\n    S₁.sc' h₁ i j k ⟶ S₂.sc' h₂ i j k where\n  τ₁ := φ.app _\n  τ₂ := φ.app _\n  τ₃ := φ.app _\n\n"}
{"name":"CategoryTheory.ComposableArrows.scMap_τ₂","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.IsComplex\nh₂ : S₂.IsComplex\ni : Nat\nhi : autoParam (LE.le (HAdd.hAdd i 2) n) _auto✝\n⊢ Eq (CategoryTheory.ComposableArrows.scMap φ h₁ h₂ i hi).τ₂ (φ.app ⟨HAdd.hAdd i 1, ⋯⟩)","decl":"/-- Functoriality maps for `ComposableArrows.sc`. -/\n@[simps!]\ndef scMap {S₁ S₂ : ComposableArrows C n} (φ : S₁ ⟶ S₂) (h₁ : S₁.IsComplex) (h₂ : S₂.IsComplex)\n    (i : ℕ) (hi : i + 2 ≤ n := by omega) :\n    S₁.sc h₁ i ⟶ S₂.sc h₂ i :=\n  sc'Map φ h₁ h₂ i (i + 1) (i + 2)\n\n"}
{"name":"CategoryTheory.ComposableArrows.scMap_τ₃","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.IsComplex\nh₂ : S₂.IsComplex\ni : Nat\nhi : autoParam (LE.le (HAdd.hAdd i 2) n) _auto✝\n⊢ Eq (CategoryTheory.ComposableArrows.scMap φ h₁ h₂ i hi).τ₃ (φ.app ⟨HAdd.hAdd i 2, ⋯⟩)","decl":"/-- Functoriality maps for `ComposableArrows.sc`. -/\n@[simps!]\ndef scMap {S₁ S₂ : ComposableArrows C n} (φ : S₁ ⟶ S₂) (h₁ : S₁.IsComplex) (h₂ : S₂.IsComplex)\n    (i : ℕ) (hi : i + 2 ≤ n := by omega) :\n    S₁.sc h₁ i ⟶ S₂.sc h₂ i :=\n  sc'Map φ h₁ h₂ i (i + 1) (i + 2)\n\n"}
{"name":"CategoryTheory.ComposableArrows.scMap_τ₁","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.IsComplex\nh₂ : S₂.IsComplex\ni : Nat\nhi : autoParam (LE.le (HAdd.hAdd i 2) n) _auto✝\n⊢ Eq (CategoryTheory.ComposableArrows.scMap φ h₁ h₂ i hi).τ₁ (φ.app ⟨i, ⋯⟩)","decl":"/-- Functoriality maps for `ComposableArrows.sc`. -/\n@[simps!]\ndef scMap {S₁ S₂ : ComposableArrows C n} (φ : S₁ ⟶ S₂) (h₁ : S₁.IsComplex) (h₂ : S₂.IsComplex)\n    (i : ℕ) (hi : i + 2 ≤ n := by omega) :\n    S₁.sc h₁ i ⟶ S₂.sc h₂ i :=\n  sc'Map φ h₁ h₂ i (i + 1) (i + 2)\n\n"}
{"name":"CategoryTheory.ComposableArrows.sc'MapIso_hom","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.IsComplex\nh₂ : S₂.IsComplex\ni j k : Nat\nhij : autoParam (Eq (HAdd.hAdd i 1) j) _auto✝\nhjk : autoParam (Eq (HAdd.hAdd j 1) k) _auto✝\nhk : autoParam (LE.le k n) _auto✝\n⊢ Eq (CategoryTheory.ComposableArrows.sc'MapIso e h₁ h₂ i j k hij hjk hk).hom (CategoryTheory.ComposableArrows.sc'Map e.hom h₁ h₂ i j k ⋯ ⋯ ⋯)","decl":"/-- The isomorphism `S₁.sc' _ i j k ≅ S₂.sc' _ i j k` induced by an isomorphism `S₁ ≅ S₂`\nin `ComposableArrows C n`. -/\n@[simps]\ndef sc'MapIso {S₁ S₂ : ComposableArrows C n} (e : S₁ ≅ S₂)\n    (h₁ : S₁.IsComplex) (h₂ : S₂.IsComplex) (i j k : ℕ) (hij : i + 1 = j := by omega)\n    (hjk : j + 1 = k := by omega) (hk : k ≤ n := by omega) :\n    S₁.sc' h₁ i j k ≅ S₂.sc' h₂ i j k where\n  hom := sc'Map e.hom h₁ h₂ i j k\n  inv := sc'Map e.inv h₂ h₁ i j k\n  hom_inv_id := by ext <;> dsimp <;> simp\n  inv_hom_id := by ext <;> dsimp <;> simp\n\n"}
{"name":"CategoryTheory.ComposableArrows.sc'MapIso_inv","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.IsComplex\nh₂ : S₂.IsComplex\ni j k : Nat\nhij : autoParam (Eq (HAdd.hAdd i 1) j) _auto✝\nhjk : autoParam (Eq (HAdd.hAdd j 1) k) _auto✝\nhk : autoParam (LE.le k n) _auto✝\n⊢ Eq (CategoryTheory.ComposableArrows.sc'MapIso e h₁ h₂ i j k hij hjk hk).inv (CategoryTheory.ComposableArrows.sc'Map e.inv h₂ h₁ i j k ⋯ ⋯ ⋯)","decl":"/-- The isomorphism `S₁.sc' _ i j k ≅ S₂.sc' _ i j k` induced by an isomorphism `S₁ ≅ S₂`\nin `ComposableArrows C n`. -/\n@[simps]\ndef sc'MapIso {S₁ S₂ : ComposableArrows C n} (e : S₁ ≅ S₂)\n    (h₁ : S₁.IsComplex) (h₂ : S₂.IsComplex) (i j k : ℕ) (hij : i + 1 = j := by omega)\n    (hjk : j + 1 = k := by omega) (hk : k ≤ n := by omega) :\n    S₁.sc' h₁ i j k ≅ S₂.sc' h₂ i j k where\n  hom := sc'Map e.hom h₁ h₂ i j k\n  inv := sc'Map e.inv h₂ h₁ i j k\n  hom_inv_id := by ext <;> dsimp <;> simp\n  inv_hom_id := by ext <;> dsimp <;> simp\n\n"}
{"name":"CategoryTheory.ComposableArrows.scMapIso_inv","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.IsComplex\nh₂ : S₂.IsComplex\ni : Nat\nhi : autoParam (LE.le (HAdd.hAdd i 2) n) _auto✝\n⊢ Eq (CategoryTheory.ComposableArrows.scMapIso e h₁ h₂ i hi).inv (CategoryTheory.ComposableArrows.scMap e.inv h₂ h₁ i ⋯)","decl":"/-- The isomorphism `S₁.sc _ i ≅ S₂.sc _ i` induced by an isomorphism `S₁ ≅ S₂`\nin `ComposableArrows C n`. -/\n@[simps]\ndef scMapIso {S₁ S₂ : ComposableArrows C n} (e : S₁ ≅ S₂)\n    (h₁ : S₁.IsComplex) (h₂ : S₂.IsComplex)\n    (i : ℕ) (hi : i + 2 ≤ n := by omega) :\n    S₁.sc h₁ i ≅ S₂.sc h₂ i where\n  hom := scMap e.hom h₁ h₂ i\n  inv := scMap e.inv h₂ h₁ i\n  hom_inv_id := by ext <;> dsimp <;> simp\n  inv_hom_id := by ext <;> dsimp <;> simp\n\n"}
{"name":"CategoryTheory.ComposableArrows.scMapIso_hom","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.IsComplex\nh₂ : S₂.IsComplex\ni : Nat\nhi : autoParam (LE.le (HAdd.hAdd i 2) n) _auto✝\n⊢ Eq (CategoryTheory.ComposableArrows.scMapIso e h₁ h₂ i hi).hom (CategoryTheory.ComposableArrows.scMap e.hom h₁ h₂ i ⋯)","decl":"/-- The isomorphism `S₁.sc _ i ≅ S₂.sc _ i` induced by an isomorphism `S₁ ≅ S₂`\nin `ComposableArrows C n`. -/\n@[simps]\ndef scMapIso {S₁ S₂ : ComposableArrows C n} (e : S₁ ≅ S₂)\n    (h₁ : S₁.IsComplex) (h₂ : S₂.IsComplex)\n    (i : ℕ) (hi : i + 2 ≤ n := by omega) :\n    S₁.sc h₁ i ≅ S₂.sc h₂ i where\n  hom := scMap e.hom h₁ h₂ i\n  inv := scMap e.inv h₂ h₁ i\n  hom_inv_id := by ext <;> dsimp <;> simp\n  inv_hom_id := by ext <;> dsimp <;> simp\n\n"}
{"name":"CategoryTheory.ComposableArrows.exact_of_iso","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.Exact\n⊢ S₂.Exact","decl":"lemma exact_of_iso {S₁ S₂ : ComposableArrows C n} (e : S₁ ≅ S₂) (h₁ : S₁.Exact) :\n    S₂.Exact where\n  toIsComplex := isComplex_of_iso e h₁.toIsComplex\n  exact i hi := ShortComplex.exact_of_iso (scMapIso e h₁.toIsComplex\n    (isComplex_of_iso e h₁.toIsComplex) i) (h₁.exact i hi)\n\n"}
{"name":"CategoryTheory.ComposableArrows.exact_iff_of_iso","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS₁ S₂ : CategoryTheory.ComposableArrows C n\ne : CategoryTheory.Iso S₁ S₂\n⊢ Iff S₁.Exact S₂.Exact","decl":"lemma exact_iff_of_iso {S₁ S₂ : ComposableArrows C n} (e : S₁ ≅ S₂) :\n    S₁.Exact ↔ S₂.Exact :=\n  ⟨exact_of_iso e, exact_of_iso e.symm⟩\n\n"}
{"name":"CategoryTheory.ComposableArrows.exact₀","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ComposableArrows C 0\n⊢ S.Exact","decl":"lemma exact₀ (S : ComposableArrows C 0) : S.Exact where\n  toIsComplex := S.isComplex₀\n  -- See https://github.com/leanprover/lean4/issues/2862\n  exact i hi := by simp at hi\n\n"}
{"name":"CategoryTheory.ComposableArrows.exact₁","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ComposableArrows C 1\n⊢ S.Exact","decl":"lemma exact₁ (S : ComposableArrows C 1) : S.Exact where\n  toIsComplex := S.isComplex₁\n  exact i hi := by exfalso; omega\n\n"}
{"name":"CategoryTheory.ComposableArrows.isComplex₂_iff","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ComposableArrows C 2\n⊢ Iff S.IsComplex (Eq (CategoryTheory.CategoryStruct.comp (S.map' 0 1 ⋯ ⋯) (S.map' 1 2 ⋯ ⋯)) 0)","decl":"lemma isComplex₂_iff (S : ComposableArrows C 2) :\n    S.IsComplex ↔ S.map' 0 1 ≫ S.map' 1 2 = 0 := by\n  constructor\n  · intro h\n    exact h.zero 0 (by omega)\n  · intro h\n    refine IsComplex.mk (fun i hi => ?_)\n    obtain rfl : i = 0 := by omega\n    exact h\n\n"}
{"name":"CategoryTheory.ComposableArrows.isComplex₂_mk","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ComposableArrows C 2\nw : Eq (CategoryTheory.CategoryStruct.comp (S.map' 0 1 ⋯ ⋯) (S.map' 1 2 ⋯ ⋯)) 0\n⊢ S.IsComplex","decl":"lemma isComplex₂_mk (S : ComposableArrows C 2) (w : S.map' 0 1 ≫ S.map' 1 2 = 0) :\n    S.IsComplex :=\n  S.isComplex₂_iff.2 w\n\n"}
{"name":"CategoryTheory.ShortComplex.isComplex_toComposableArrows","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\n⊢ S.toComposableArrows.IsComplex","decl":"set_option simprocs false in\nlemma _root_.CategoryTheory.ShortComplex.isComplex_toComposableArrows (S : ShortComplex C) :\n    S.toComposableArrows.IsComplex :=\n  isComplex₂_mk _ (by simp)\n\n"}
{"name":"CategoryTheory.ComposableArrows.exact₂_iff","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ComposableArrows C 2\nhS : S.IsComplex\n⊢ Iff S.Exact (S.sc' hS 0 1 2 ⋯ ⋯ ⋯).Exact","decl":"lemma exact₂_iff (S : ComposableArrows C 2) (hS : S.IsComplex) :\n    S.Exact ↔ (S.sc' hS 0 1 2).Exact := by\n  constructor\n  · intro h\n    exact h.exact 0 (by omega)\n  · intro h\n    refine Exact.mk hS (fun i hi => ?_)\n    obtain rfl : i = 0 := by omega\n    exact h\n\n"}
{"name":"CategoryTheory.ComposableArrows.exact₂_mk","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ComposableArrows C 2\nw : Eq (CategoryTheory.CategoryStruct.comp (S.map' 0 1 ⋯ ⋯) (S.map' 1 2 ⋯ ⋯)) 0\nh : (CategoryTheory.ShortComplex.mk (S.map' 0 1 ⋯ ⋯) (S.map' 1 2 ⋯ ⋯) w).Exact\n⊢ S.Exact","decl":"lemma exact₂_mk (S : ComposableArrows C 2) (w : S.map' 0 1 ≫ S.map' 1 2 = 0)\n    (h : (ShortComplex.mk _ _ w).Exact) : S.Exact :=\n  (S.exact₂_iff (S.isComplex₂_mk w)).2 h\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.exact_toComposableArrows","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhS : S.Exact\n⊢ S.toComposableArrows.Exact","decl":"lemma _root_.CategoryTheory.ShortComplex.Exact.exact_toComposableArrows\n    {S : ShortComplex C} (hS : S.Exact) :\n    S.toComposableArrows.Exact :=\n  exact₂_mk _ _ hS\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_exact_toComposableArrows","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\n⊢ Iff S.Exact S.toComposableArrows.Exact","decl":"lemma _root_.CategoryTheory.ShortComplex.exact_iff_exact_toComposableArrows\n    (S : ShortComplex C) :\n    S.Exact ↔ S.toComposableArrows.Exact :=\n  (S.toComposableArrows.exact₂_iff S.isComplex_toComposableArrows).symm\n\n"}
{"name":"CategoryTheory.ComposableArrows.exact_iff_δ₀","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS : CategoryTheory.ComposableArrows C (HAdd.hAdd n 2)\n⊢ Iff S.Exact (And (CategoryTheory.ComposableArrows.mk₂ (S.map' 0 1 ⋯ ⋯) (S.map' 1 2 ⋯ ⋯)).Exact S.δ₀.Exact)","decl":"lemma exact_iff_δ₀ (S : ComposableArrows C (n + 2)) :\n    S.Exact ↔ (mk₂ (S.map' 0 1) (S.map' 1 2)).Exact ∧ S.δ₀.Exact := by\n  constructor\n  · intro h\n    constructor\n    · rw [exact₂_iff]; swap\n      · rw [isComplex₂_iff]\n        exact h.toIsComplex.zero 0\n      exact h.exact 0 (by omega)\n    · exact Exact.mk (IsComplex.mk (fun i hi => h.toIsComplex.zero (i + 1)))\n        (fun i hi => h.exact (i + 1))\n  · rintro ⟨h, h₀⟩\n    refine Exact.mk (IsComplex.mk (fun i hi => ?_)) (fun i hi => ?_)\n    · obtain _ | i := i\n      · exact h.toIsComplex.zero 0\n      · exact h₀.toIsComplex.zero i\n    · obtain _ | i := i\n      · exact h.exact 0\n      · exact h₀.exact i\n\n"}
{"name":"CategoryTheory.ComposableArrows.Exact.δ₀","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS : CategoryTheory.ComposableArrows C (HAdd.hAdd n 2)\nhS : S.Exact\n⊢ S.δ₀.Exact","decl":"lemma Exact.δ₀ {S : ComposableArrows C (n + 2)} (hS : S.Exact) :\n    S.δ₀.Exact := by\n  rw [exact_iff_δ₀] at hS\n  exact hS.2\n\n"}
{"name":"CategoryTheory.ComposableArrows.exact_of_δ₀","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS : CategoryTheory.ComposableArrows C (HAdd.hAdd n 2)\nh : (CategoryTheory.ComposableArrows.mk₂ (S.map' 0 1 ⋯ ⋯) (S.map' 1 2 ⋯ ⋯)).Exact\nh₀ : S.δ₀.Exact\n⊢ S.Exact","decl":"/-- If `S : ComposableArrows C (n + 2)` is such that the first two arrows form\nan exact sequence and that the tail `S.δ₀` is exact, then `S` is also exact.\nSee `ShortComplex.SnakeInput.snake_lemma` in `Algebra.Homology.ShortComplex.SnakeLemma`\nfor a use of this lemma. -/\nlemma exact_of_δ₀ {S : ComposableArrows C (n + 2)}\n    (h : (mk₂ (S.map' 0 1) (S.map' 1 2)).Exact) (h₀ : S.δ₀.Exact) : S.Exact := by\n  rw [exact_iff_δ₀]\n  constructor <;> assumption\n\n"}
{"name":"CategoryTheory.ComposableArrows.exact_iff_δlast","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS : CategoryTheory.ComposableArrows C (HAdd.hAdd n 2)\n⊢ Iff S.Exact (And S.δlast.Exact (CategoryTheory.ComposableArrows.mk₂ (S.map' n (HAdd.hAdd n 1) ⋯ ⋯) (S.map' (HAdd.hAdd n 1) (HAdd.hAdd n 2) ⋯ ⋯)).Exact)","decl":"lemma exact_iff_δlast {n : ℕ} (S : ComposableArrows C (n + 2)) :\n    S.Exact ↔ S.δlast.Exact ∧ (mk₂ (S.map' n (n + 1)) (S.map' (n + 1) (n + 2))).Exact := by\n  constructor\n  · intro h\n    constructor\n    · exact Exact.mk (IsComplex.mk (fun i hi => h.toIsComplex.zero i))\n        (fun i hi => h.exact i)\n    · rw [exact₂_iff]; swap\n      · rw [isComplex₂_iff]\n        exact h.toIsComplex.zero n\n      exact h.exact n (by omega)\n  · rintro ⟨h, h'⟩\n    refine Exact.mk (IsComplex.mk (fun i hi => ?_)) (fun i hi => ?_)\n    · simp only [Nat.add_le_add_iff_right] at hi\n      obtain hi | rfl := hi.lt_or_eq\n      · exact h.toIsComplex.zero i\n      · exact h'.toIsComplex.zero 0\n    · simp only [Nat.add_le_add_iff_right] at hi\n      obtain hi | rfl := hi.lt_or_eq\n      · exact h.exact i\n      · exact h'.exact 0\n\n"}
{"name":"CategoryTheory.ComposableArrows.Exact.δlast","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS : CategoryTheory.ComposableArrows C (HAdd.hAdd n 2)\nhS : S.Exact\n⊢ S.δlast.Exact","decl":"lemma Exact.δlast {S : ComposableArrows C (n + 2)} (hS : S.Exact) :\n    S.δlast.Exact := by\n  rw [exact_iff_δlast] at hS\n  exact hS.1\n\n"}
{"name":"CategoryTheory.ComposableArrows.exact_of_δlast","module":"Mathlib.Algebra.Homology.ExactSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nn : Nat\nS : CategoryTheory.ComposableArrows C (HAdd.hAdd n 2)\nh₁ : S.δlast.Exact\nh₂ : (CategoryTheory.ComposableArrows.mk₂ (S.map' n (HAdd.hAdd n 1) ⋯ ⋯) (S.map' (HAdd.hAdd n 1) (HAdd.hAdd n 2) ⋯ ⋯)).Exact\n⊢ S.Exact","decl":"lemma exact_of_δlast {n : ℕ} (S : ComposableArrows C (n + 2))\n    (h₁ : S.δlast.Exact) (h₂ : (mk₂ (S.map' n (n + 1)) (S.map' (n + 1) (n + 2))).Exact) :\n    S.Exact := by\n  rw [exact_iff_δlast]\n  constructor <;> assumption\n\n"}
