{"name":"fourierIntegral_half_period_translate","module":"Mathlib.Analysis.Fourier.RiemannLebesgueLemma","initialProofState":"E : Type u_1\nV : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nf : V â†’ E\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : MeasurableSpace V\ninstâœÂ² : BorelSpace V\ninstâœÂ¹ : InnerProductSpace Real V\ninstâœ : FiniteDimensional Real V\nw : V\nhw : Ne w 0\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (Inner.inner v w))) (f (HAdd.hAdd v ((fun w => HSMul.hSMul (HDiv.hDiv 1 (HMul.hMul 2 (HPow.hPow (Norm.norm w) 2))) w) w)))) (Neg.neg (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (Inner.inner v w))) (f v)))","decl":"/-- Shifting `f` by `(1 / (2 * â€–wâ€– ^ 2)) â€¢ w` negates the integral in the Riemann-Lebesgue lemma. -/\ntheorem fourierIntegral_half_period_translate {w : V} (hw : w â‰  0) :\n    (âˆ« v : V, ğ (-âŸªv, wâŸ«) â€¢ f (v + i w)) = -âˆ« v : V, ğ (-âŸªv, wâŸ«) â€¢ f v := by\n  have hiw : âŸªi w, wâŸ« = 1 / 2 := by\n    rw [inner_smul_left, inner_self_eq_norm_sq_to_K, RCLike.ofReal_real_eq_id, id,\n      RCLike.conj_to_real, â† div_div, div_mul_cancelâ‚€]\n    rwa [Ne, sq_eq_zero_iff, norm_eq_zero]\n  have :\n    (fun v : V => ğ (-âŸªv, wâŸ«) â€¢ f (v + i w)) =\n      fun v : V => (fun x : V => -(ğ (-âŸªx, wâŸ«) â€¢ f x)) (v + i w) := by\n    ext1 v\n    simp_rw [inner_add_left, hiw, Circle.smul_def, Real.fourierChar_apply, neg_add, mul_add,\n      ofReal_add, add_mul, exp_add]\n    have : 2 * Ï€ * -(1 / 2) = -Ï€ := by field_simp; ring\n    rw [this, ofReal_neg, neg_mul, exp_neg, exp_pi_mul_I, inv_neg, inv_one, mul_neg_one, neg_smul,\n      neg_neg]\n  rw [this]\n  -- Porting note:\n  -- The next three lines had just been\n  -- rw [integral_add_right_eq_self (fun (x : V) â†¦ -(ğ[-âŸªx, wâŸ«]) â€¢ f x)\n  --       ((fun w â†¦ (1 / (2 * â€–wâ€– ^ (2 : â„•))) â€¢ w) w)]\n  -- Unfortunately now we need to specify `volume`.\n  have := integral_add_right_eq_self (Î¼ := volume) (fun (x : V) â†¦ -(ğ (-âŸªx, wâŸ«) â€¢ f x))\n    ((fun w â†¦ (1 / (2 * â€–wâ€– ^ (2 : â„•))) â€¢ w) w)\n  rw [this]\n  simp only [neg_smul, integral_neg]\n\n"}
{"name":"fourierIntegral_eq_half_sub_half_period_translate","module":"Mathlib.Analysis.Fourier.RiemannLebesgueLemma","initialProofState":"E : Type u_1\nV : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nf : V â†’ E\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : MeasurableSpace V\ninstâœÂ² : BorelSpace V\ninstâœÂ¹ : InnerProductSpace Real V\ninstâœ : FiniteDimensional Real V\nw : V\nhw : Ne w 0\nhf : MeasureTheory.Integrable f MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (Inner.inner v w))) (f v)) (HSMul.hSMul (1 / 2) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (Inner.inner v w))) (HSub.hSub (f v) (f (HAdd.hAdd v ((fun w => HSMul.hSMul (HDiv.hDiv 1 (HMul.hMul 2 (HPow.hPow (Norm.norm w) 2))) w) w))))))","decl":"/-- Rewrite the Fourier integral in a form that allows us to use uniform continuity. -/\ntheorem fourierIntegral_eq_half_sub_half_period_translate {w : V} (hw : w â‰  0)\n    (hf : Integrable f) :\n    âˆ« v : V, ğ (-âŸªv, wâŸ«) â€¢ f v = (1 / (2 : â„‚)) â€¢ âˆ« v : V, ğ (-âŸªv, wâŸ«) â€¢ (f v - f (v + i w)) := by\n  simp_rw [smul_sub]\n  rw [integral_sub, fourierIntegral_half_period_translate hw, sub_eq_add_neg, neg_neg, â†\n    two_smul â„‚ _, â† @smul_assoc _ _ _ _ _ _ (IsScalarTower.left â„‚), smul_eq_mul]\n  Â· norm_num\n  exacts [(Real.fourierIntegral_convergent_iff w).2 hf,\n    (Real.fourierIntegral_convergent_iff w).2 (hf.comp_add_right _)]\n\n"}
{"name":"tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support","module":"Mathlib.Analysis.Fourier.RiemannLebesgueLemma","initialProofState":"E : Type u_1\nV : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nf : V â†’ E\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : MeasurableSpace V\ninstâœÂ² : BorelSpace V\ninstâœÂ¹ : InnerProductSpace Real V\ninstâœ : FiniteDimensional Real V\nhf1 : Continuous f\nhf2 : HasCompactSupport f\nâŠ¢ Filter.Tendsto (fun w => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (Inner.inner v w))) (f v)) (Filter.cocompact V) (nhds 0)","decl":"/-- Riemann-Lebesgue Lemma for continuous and compactly-supported functions: the integral\n`âˆ« v, exp (-2 * Ï€ * âŸªw, vâŸ« * I) â€¢ f v` tends to 0 wrt `cocompact V`. Note that this is primarily\nof interest as a preparatory step for the more general result\n`tendsto_integral_exp_inner_smul_cocompact` in which `f` can be arbitrary. -/\ntheorem tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support (hf1 : Continuous f)\n    (hf2 : HasCompactSupport f) :\n    Tendsto (fun w : V => âˆ« v : V, ğ (-âŸªv, wâŸ«) â€¢ f v) (cocompact V) (ğ“ 0) := by\n  refine NormedAddCommGroup.tendsto_nhds_zero.mpr fun Îµ hÎµ => ?_\n  suffices âˆƒ T : â„, âˆ€ w : V, T â‰¤ â€–wâ€– â†’ â€–âˆ« v : V, ğ (-âŸªv, wâŸ«) â€¢ f vâ€– < Îµ by\n    simp_rw [â† comap_dist_left_atTop_eq_cocompact (0 : V), eventually_comap, eventually_atTop,\n      dist_eq_norm', sub_zero]\n    exact\n      let âŸ¨T, hTâŸ© := this\n      âŸ¨T, fun b hb v hv => hT v (hv.symm â–¸ hb)âŸ©\n  obtain âŸ¨R, -, hR_bdâŸ© : âˆƒ R : â„, 0 < R âˆ§ âˆ€ x : V, R â‰¤ â€–xâ€– â†’ f x = 0 := hf2.exists_pos_le_norm\n  let A := {v : V | â€–vâ€– â‰¤ R + 1}\n  have mA : MeasurableSet A := by\n    suffices A = Metric.closedBall (0 : V) (R + 1) by\n      rw [this]\n      exact Metric.isClosed_ball.measurableSet\n    simp_rw [A, Metric.closedBall, dist_eq_norm, sub_zero]\n  obtain âŸ¨B, hB_pos, hB_volâŸ© : âˆƒ B : â„â‰¥0, 0 < B âˆ§ volume A â‰¤ B := by\n    have hc : IsCompact A := by\n      simpa only [Metric.closedBall, dist_eq_norm, sub_zero] using isCompact_closedBall (0 : V) _\n    let Bâ‚€ := volume A\n    replace hc : Bâ‚€ < âŠ¤ := hc.measure_lt_top\n    refine âŸ¨Bâ‚€.toNNReal + 1, add_pos_of_nonneg_of_pos Bâ‚€.toNNReal.coe_nonneg one_pos, ?_âŸ©\n    rw [ENNReal.coe_add, ENNReal.coe_one, ENNReal.coe_toNNReal hc.ne]\n    exact le_self_add\n  --* Use uniform continuity to choose Î´ such that `â€–x - yâ€– < Î´` implies `â€–f x - f yâ€– < Îµ / B`.\n  obtain âŸ¨Î´, hÎ´1, hÎ´2âŸ© :=\n    Metric.uniformContinuous_iff.mp (hf2.uniformContinuous_of_continuous hf1) (Îµ / B)\n      (div_pos hÎµ hB_pos)\n  refine âŸ¨1 / 2 + 1 / (2 * Î´), fun w hw_bd => ?_âŸ©\n  have hw_ne : w â‰  0 := by\n    contrapose! hw_bd; rw [hw_bd, norm_zero]\n    exact add_pos one_half_pos (one_div_pos.mpr <| mul_pos two_pos hÎ´1)\n  have hw'_nm : â€–i wâ€– = 1 / (2 * â€–wâ€–) := by\n    rw [norm_smul, norm_div, Real.norm_of_nonneg (mul_nonneg two_pos.le <| sq_nonneg _), norm_one,\n      sq, â† div_div, â† div_div, â† div_div, div_mul_cancelâ‚€ _ (norm_eq_zero.not.mpr hw_ne)]\n  --* Rewrite integral in terms of `f v - f (v + w')`.\n  have : â€–(1 / 2 : â„‚)â€– = 2â»Â¹ := by norm_num\n  rw [fourierIntegral_eq_half_sub_half_period_translate hw_ne\n      (hf1.integrable_of_hasCompactSupport hf2),\n    norm_smul, this, inv_mul_eq_div, div_lt_iffâ‚€' two_pos]\n  refine lt_of_le_of_lt (norm_integral_le_integral_norm _) ?_\n  simp_rw [Circle.norm_smul]\n  --* Show integral can be taken over A only.\n  have int_A : âˆ« v : V, â€–f v - f (v + i w)â€– = âˆ« v in A, â€–f v - f (v + i w)â€– := by\n    refine (setIntegral_eq_integral_of_forall_compl_eq_zero fun v hv => ?_).symm\n    dsimp only [A] at hv\n    simp only [mem_setOf, not_le] at hv\n    rw [hR_bd v _, hR_bd (v + i w) _, sub_zero, norm_zero]\n    Â· rw [â† sub_neg_eq_add]\n      refine le_trans ?_ (norm_sub_norm_le _ _)\n      rw [le_sub_iff_add_le, norm_neg]\n      refine le_trans ?_ hv.le\n      rw [add_le_add_iff_left, hw'_nm, â† div_div]\n      refine (div_le_one <| norm_pos_iff.mpr hw_ne).mpr ?_\n      refine le_trans (le_add_of_nonneg_right <| one_div_nonneg.mpr <| ?_) hw_bd\n      exact (mul_pos (zero_lt_two' â„) hÎ´1).le\n    Â· exact (le_add_of_nonneg_right zero_le_one).trans hv.le\n  rw [int_A]; clear int_A\n  --* Bound integral using fact that `â€–f v - f (v + w')â€–` is small.\n  have bdA : âˆ€ v : V, v âˆˆ A â†’ â€–â€–f v - f (v + i w)â€–â€– â‰¤ Îµ / B := by\n    simp_rw [norm_norm]\n    simp_rw [dist_eq_norm] at hÎ´2\n    refine fun x _ => (hÎ´2 ?_).le\n    rw [sub_add_cancel_left, norm_neg, hw'_nm, â† div_div, div_lt_iffâ‚€ (norm_pos_iff.mpr hw_ne), â†\n      div_lt_iffâ‚€' hÎ´1, div_div]\n    exact (lt_add_of_pos_left _ one_half_pos).trans_le hw_bd\n  have bdA2 := norm_setIntegral_le_of_norm_le_const (hB_vol.trans_lt ENNReal.coe_lt_top) bdA ?_\n  swap\n  Â· apply Continuous.aestronglyMeasurable\n    exact continuous_norm.comp <| hf1.sub <| hf1.comp <| continuous_id'.add continuous_const\n  have : â€–_â€– = âˆ« v : V in A, â€–f v - f (v + i w)â€– :=\n    Real.norm_of_nonneg (setIntegral_nonneg mA fun x _ => norm_nonneg _)\n  rw [this] at bdA2\n  refine bdA2.trans_lt ?_\n  rw [div_mul_eq_mul_div, div_lt_iffâ‚€ (NNReal.coe_pos.mpr hB_pos), mul_comm (2 : â„), mul_assoc,\n    mul_lt_mul_left hÎµ]\n  refine (ENNReal.toReal_mono ENNReal.coe_ne_top hB_vol).trans_lt ?_\n  rw [ENNReal.coe_toReal, two_mul]\n  exact lt_add_of_pos_left _ hB_pos\n\n"}
{"name":"tendsto_integral_exp_inner_smul_cocompact","module":"Mathlib.Analysis.Fourier.RiemannLebesgueLemma","initialProofState":"E : Type u_1\nV : Type u_2\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Complex E\nf : V â†’ E\ninstâœâ´ : NormedAddCommGroup V\ninstâœÂ³ : MeasurableSpace V\ninstâœÂ² : BorelSpace V\ninstâœÂ¹ : InnerProductSpace Real V\ninstâœ : FiniteDimensional Real V\nâŠ¢ Filter.Tendsto (fun w => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (Inner.inner v w))) (f v)) (Filter.cocompact V) (nhds 0)","decl":"/-- Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\n`âˆ« v, exp (-2 * Ï€ * âŸªw, vâŸ« * I) â€¢ f v` tends to 0 as `w â†’ âˆ`. -/\ntheorem tendsto_integral_exp_inner_smul_cocompact :\n    Tendsto (fun w : V => âˆ« v, ğ (-âŸªv, wâŸ«) â€¢ f v) (cocompact V) (ğ“ 0) := by\n  by_cases hfi : Integrable f; swap\n  Â· convert tendsto_const_nhds (x := (0 : E)) with w\n    apply integral_undef\n    rwa [Real.fourierIntegral_convergent_iff]\n  refine Metric.tendsto_nhds.mpr fun Îµ hÎµ => ?_\n  obtain âŸ¨g, hg_supp, hfg, hg_cont, -âŸ© :=\n    hfi.exists_hasCompactSupport_integral_sub_le (div_pos hÎµ two_pos)\n  refine\n    ((Metric.tendsto_nhds.mp\n            (tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support hg_cont\n              hg_supp))\n          _ (div_pos hÎµ two_pos)).mp\n      (Eventually.of_forall fun w hI => ?_)\n  rw [dist_eq_norm] at hI âŠ¢\n  have : â€–(âˆ« v, ğ (-âŸªv, wâŸ«) â€¢ f v) - âˆ« v, ğ (-âŸªv, wâŸ«) â€¢ g vâ€– â‰¤ Îµ / 2 := by\n    refine le_trans ?_ hfg\n    simp_rw [â† integral_sub ((Real.fourierIntegral_convergent_iff w).2 hfi)\n      ((Real.fourierIntegral_convergent_iff w).2 (hg_cont.integrable_of_hasCompactSupport hg_supp)),\n      â† smul_sub, â† Pi.sub_apply]\n    exact VectorFourier.norm_fourierIntegral_le_integral_norm ğ _ bilinFormOfRealInner (f - g) w\n  replace := add_lt_add_of_le_of_lt this hI\n  rw [add_halves] at this\n  refine ((le_of_eq ?_).trans (norm_add_le _ _)).trans_lt this\n  simp only [sub_zero, sub_add_cancel]\n\n"}
{"name":"Real.tendsto_integral_exp_smul_cocompact","module":"Mathlib.Analysis.Fourier.RiemannLebesgueLemma","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Real â†’ E\nâŠ¢ Filter.Tendsto (fun w => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (HMul.hMul v w))) (f v)) (Filter.cocompact Real) (nhds 0)","decl":"/-- The Riemann-Lebesgue lemma for functions on `â„`. -/\ntheorem Real.tendsto_integral_exp_smul_cocompact (f : â„ â†’ E) :\n    Tendsto (fun w : â„ => âˆ« v : â„, ğ (-(v * w)) â€¢ f v) (cocompact â„) (ğ“ 0) :=\n  tendsto_integral_exp_inner_smul_cocompact f\n\n"}
{"name":"Real.zero_at_infty_fourierIntegral","module":"Mathlib.Analysis.Fourier.RiemannLebesgueLemma","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Real â†’ E\nâŠ¢ Filter.Tendsto (Real.fourierIntegral f) (Filter.cocompact Real) (nhds 0)","decl":"/-- The Riemann-Lebesgue lemma for functions on `â„`, formulated via `Real.fourierIntegral`. -/\ntheorem Real.zero_at_infty_fourierIntegral (f : â„ â†’ E) : Tendsto (ğ“• f) (cocompact â„) (ğ“ 0) :=\n  tendsto_integral_exp_inner_smul_cocompact f\n\n"}
{"name":"tendsto_integral_exp_smul_cocompact_of_inner_product","module":"Mathlib.Analysis.Fourier.RiemannLebesgueLemma","initialProofState":"E : Type u_1\nV : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Complex E\nf : V â†’ E\ninstâœâµ : NormedAddCommGroup V\ninstâœâ´ : MeasurableSpace V\ninstâœÂ³ : BorelSpace V\ninstâœÂ² : InnerProductSpace Real V\ninstâœÂ¹ : FiniteDimensional Real V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : Î¼.IsAddHaarMeasure\nâŠ¢ Filter.Tendsto (fun w => MeasureTheory.integral Î¼ fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (w v))) (f v)) (Filter.cocompact (ContinuousLinearMap (RingHom.id Real) V Real)) (nhds 0)","decl":"/-- Riemann-Lebesgue lemma for functions on a finite-dimensional inner-product space, formulated\nvia dual space. **Do not use** -- it is only a stepping stone to\n`tendsto_integral_exp_smul_cocompact` where the inner-product-space structure isn't required. -/\ntheorem tendsto_integral_exp_smul_cocompact_of_inner_product (Î¼ : Measure V) [Î¼.IsAddHaarMeasure] :\n    Tendsto (fun w : V â†’L[â„] â„ => âˆ« v, ğ (-w v) â€¢ f v âˆ‚Î¼) (cocompact (V â†’L[â„] â„)) (ğ“ 0) := by\n  rw [Î¼.isAddLeftInvariant_eq_smul volume]\n  simp_rw [integral_smul_nnreal_measure]\n  rw [â† (smul_zero _ : Measure.addHaarScalarFactor Î¼ volume â€¢ (0 : E) = 0)]\n  apply Tendsto.const_smul\n  let A := (InnerProductSpace.toDual â„ V).symm\n  have : (fun w : V â†’L[â„] â„ â†¦ âˆ« v, ğ (-w v) â€¢ f v) = (fun w : V â†¦ âˆ« v, ğ (-âŸªv, wâŸ«) â€¢ f v) âˆ˜ A := by\n    ext1 w\n    congr 1 with v : 1\n    rw [â† inner_conj_symm, RCLike.conj_to_real, InnerProductSpace.toDual_symm_apply]\n  rw [this]\n  exact (tendsto_integral_exp_inner_smul_cocompact f).comp\n      A.toHomeomorph.toCocompactMap.cocompact_tendsto'\n\n"}
{"name":"tendsto_integral_exp_smul_cocompact","module":"Mathlib.Analysis.Fourier.RiemannLebesgueLemma","initialProofState":"E : Type u_1\nV : Type u_2\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace Complex E\nf : V â†’ E\ninstâœâ¹ : AddCommGroup V\ninstâœâ¸ : TopologicalSpace V\ninstâœâ· : TopologicalAddGroup V\ninstâœâ¶ : T2Space V\ninstâœâµ : MeasurableSpace V\ninstâœâ´ : BorelSpace V\ninstâœÂ³ : Module Real V\ninstâœÂ² : ContinuousSMul Real V\ninstâœÂ¹ : FiniteDimensional Real V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : Î¼.IsAddHaarMeasure\nâŠ¢ Filter.Tendsto (fun w => MeasureTheory.integral Î¼ fun v => HSMul.hSMul (Real.fourierChar (Neg.neg (w v))) (f v)) (Filter.cocompact (ContinuousLinearMap (RingHom.id Real) V Real)) (nhds 0)","decl":"/-- Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\ndual space. -/\ntheorem tendsto_integral_exp_smul_cocompact (Î¼ : Measure V) [Î¼.IsAddHaarMeasure] :\n    Tendsto (fun w : V â†’L[â„] â„ => âˆ« v, ğ (-w v) â€¢ f v âˆ‚Î¼) (cocompact (V â†’L[â„] â„)) (ğ“ 0) := by\n  -- We have already proved the result for inner-product spaces, formulated in a way which doesn't\n  -- refer to the inner product. So we choose an arbitrary inner-product space isomorphic to V\n  -- and port the result over from there.\n  let V' := EuclideanSpace â„ (Fin (finrank â„ V))\n  have A : V â‰ƒL[â„] V' := toEuclidean\n  borelize V'\n  -- various equivs derived from A\n  let Aâ‚˜ : MeasurableEquiv V V' := A.toHomeomorph.toMeasurableEquiv\n  -- isomorphism between duals derived from A\n  let Adual : (V â†’L[â„] â„) â‰ƒL[â„] V' â†’L[â„] â„ := A.arrowCongrSL (.refl _ _)\n  have : (Î¼.map Aâ‚˜).IsAddHaarMeasure := A.isAddHaarMeasure_map _\n  convert (tendsto_integral_exp_smul_cocompact_of_inner_product (f âˆ˜ A.symm) (Î¼.map Aâ‚˜)).comp\n    Adual.toHomeomorph.toCocompactMap.cocompact_tendsto' with w\n  rw [Function.comp_apply, integral_map_equiv]\n  congr 1 with v : 1\n  congr\n  Â· -- Porting note: added `congr_arg`\n    apply congr_arg w\n    exact (ContinuousLinearEquiv.symm_apply_apply A v).symm\n  Â· exact (ContinuousLinearEquiv.symm_apply_apply A v).symm\n\n"}
{"name":"Real.zero_at_infty_vector_fourierIntegral","module":"Mathlib.Analysis.Fourier.RiemannLebesgueLemma","initialProofState":"E : Type u_1\nV : Type u_2\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace Complex E\nf : V â†’ E\ninstâœâ¹ : AddCommGroup V\ninstâœâ¸ : TopologicalSpace V\ninstâœâ· : TopologicalAddGroup V\ninstâœâ¶ : T2Space V\ninstâœâµ : MeasurableSpace V\ninstâœâ´ : BorelSpace V\ninstâœÂ³ : Module Real V\ninstâœÂ² : ContinuousSMul Real V\ninstâœÂ¹ : FiniteDimensional Real V\nÎ¼ : MeasureTheory.Measure V\ninstâœ : Î¼.IsAddHaarMeasure\nâŠ¢ Filter.Tendsto (VectorFourier.fourierIntegral Real.fourierChar Î¼ (topDualPairing Real V).flip f) (Filter.cocompact (ContinuousLinearMap (RingHom.id Real) V Real)) (nhds 0)","decl":"/-- The Riemann-Lebesgue lemma, formulated in terms of `VectorFourier.fourierIntegral` (with the\npairing in the definition of `fourier_integral` taken to be the canonical pairing between `V` and\nits dual space). -/\ntheorem Real.zero_at_infty_vector_fourierIntegral (Î¼ : Measure V) [Î¼.IsAddHaarMeasure] :\n    Tendsto (VectorFourier.fourierIntegral ğ Î¼ (topDualPairing â„ V).flip f) (cocompact (V â†’L[â„] â„))\n      (ğ“ 0) :=\n  _root_.tendsto_integral_exp_smul_cocompact f Î¼\n\n"}
