{"name":"Finset.card_nsmul_quotient_add_nsmul_inter_addSubgroup_le","module":"Mathlib.Geometry.Group.Growth.QuotientInter","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : DecidableEq G\nH : AddSubgroup G\ninst✝¹ : DecidablePred fun x => Membership.mem H x\ninst✝ : H.Normal\nA : Finset G\nm n : Nat\n⊢ LE.le (HMul.hMul (Finset.image (⇑(QuotientAddGroup.mk' H)) (HSMul.hSMul m A)).card (Finset.filter (fun x => Membership.mem H x) (HSMul.hSMul n A)).card) (HSMul.hSMul (HAdd.hAdd m n) A).card","decl":"@[to_additive]\nlemma card_pow_quotient_mul_pow_inter_subgroup_le :\n    #((A ^ m).image <| QuotientGroup.mk' H) * #{x ∈ A ^ n | x ∈ H} ≤ #(A ^ (m + n)) := by\n  set π := QuotientGroup.mk' H\n  let φ := invFunOn π (A ^ m)\n  have hφ : Set.InjOn φ (π '' (A ^ m)) := invFunOn_injOn_image ..\n  have hφA {a} (ha : a ∈ π '' (A ^ m)) : φ a ∈ A ^ m := by\n    have := invFunOn_mem (by simpa using ha)\n    norm_cast at this\n    simpa using this\n  have hπφ {a} (ha : a ∈ π '' (A ^ m)) : π (φ a) = a := invFunOn_eq (by simpa using ha)\n  calc\n    #((A ^ m).image π) * #{x ∈ A ^ n | x ∈ H}\n    _ = #(((A ^ m).image π).image φ) * #{x ∈ A ^ n | x ∈ H} := by\n      rw [Finset.card_image_of_injOn (f := φ) (mod_cast hφ)]\n    _ ≤ #(((A ^ m).image π).image φ * {x ∈ A ^ n | x ∈ H}) := by\n      rw [Finset.card_mul_iff.2]\n      simp only [Set.InjOn, coe_image, coe_pow, coe_filter, Set.mem_prod, Set.mem_image,\n        exists_exists_and_eq_and, Set.mem_setOf_eq, and_imp, forall_exists_index, Prod.forall,\n        Prod.mk.injEq]\n      rintro _ a₁ b₁ hb₁ rfl - ha₁ _ a₂ b₂ hb₂ rfl - ha₂ hab\n      have hπa₁ : π a₁ = 1 := (QuotientGroup.eq_one_iff _).2 ha₁\n      have hπa₂ : π a₂ = 1 := (QuotientGroup.eq_one_iff _).2 ha₂\n      have hπb : π b₁ = π b₂ := by\n        simpa [hπφ, Set.mem_image_of_mem π, hb₁, hb₂, hπa₁, hπa₂] using congr(π $hab)\n      aesop\n    _ ≤ #(A ^ (m + n)) := by\n      gcongr\n      simp only [mul_subset_iff, mem_image, exists_exists_and_eq_and, Finset.mem_filter, and_imp,\n        forall_exists_index, forall_apply_eq_imp_iff₂, pow_add]\n      rintro a ha b hb -\n      exact mul_mem_mul (hφA <| Set.mem_image_of_mem _ <| mod_cast ha) hb\n\n"}
{"name":"Finset.card_pow_quotient_mul_pow_inter_subgroup_le","module":"Mathlib.Geometry.Group.Growth.QuotientInter","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : DecidableEq G\nH : Subgroup G\ninst✝¹ : DecidablePred fun x => Membership.mem H x\ninst✝ : H.Normal\nA : Finset G\nm n : Nat\n⊢ LE.le (HMul.hMul (Finset.image (⇑(QuotientGroup.mk' H)) (HPow.hPow A m)).card (Finset.filter (fun x => Membership.mem H x) (HPow.hPow A n)).card) (HPow.hPow A (HAdd.hAdd m n)).card","decl":"@[to_additive]\nlemma card_pow_quotient_mul_pow_inter_subgroup_le :\n    #((A ^ m).image <| QuotientGroup.mk' H) * #{x ∈ A ^ n | x ∈ H} ≤ #(A ^ (m + n)) := by\n  set π := QuotientGroup.mk' H\n  let φ := invFunOn π (A ^ m)\n  have hφ : Set.InjOn φ (π '' (A ^ m)) := invFunOn_injOn_image ..\n  have hφA {a} (ha : a ∈ π '' (A ^ m)) : φ a ∈ A ^ m := by\n    have := invFunOn_mem (by simpa using ha)\n    norm_cast at this\n    simpa using this\n  have hπφ {a} (ha : a ∈ π '' (A ^ m)) : π (φ a) = a := invFunOn_eq (by simpa using ha)\n  calc\n    #((A ^ m).image π) * #{x ∈ A ^ n | x ∈ H}\n    _ = #(((A ^ m).image π).image φ) * #{x ∈ A ^ n | x ∈ H} := by\n      rw [Finset.card_image_of_injOn (f := φ) (mod_cast hφ)]\n    _ ≤ #(((A ^ m).image π).image φ * {x ∈ A ^ n | x ∈ H}) := by\n      rw [Finset.card_mul_iff.2]\n      simp only [Set.InjOn, coe_image, coe_pow, coe_filter, Set.mem_prod, Set.mem_image,\n        exists_exists_and_eq_and, Set.mem_setOf_eq, and_imp, forall_exists_index, Prod.forall,\n        Prod.mk.injEq]\n      rintro _ a₁ b₁ hb₁ rfl - ha₁ _ a₂ b₂ hb₂ rfl - ha₂ hab\n      have hπa₁ : π a₁ = 1 := (QuotientGroup.eq_one_iff _).2 ha₁\n      have hπa₂ : π a₂ = 1 := (QuotientGroup.eq_one_iff _).2 ha₂\n      have hπb : π b₁ = π b₂ := by\n        simpa [hπφ, Set.mem_image_of_mem π, hb₁, hb₂, hπa₁, hπa₂] using congr(π $hab)\n      aesop\n    _ ≤ #(A ^ (m + n)) := by\n      gcongr\n      simp only [mul_subset_iff, mem_image, exists_exists_and_eq_and, Finset.mem_filter, and_imp,\n        forall_exists_index, forall_apply_eq_imp_iff₂, pow_add]\n      rintro a ha b hb -\n      exact mul_mem_mul (hφA <| Set.mem_image_of_mem _ <| mod_cast ha) hb\n\n"}
{"name":"Finset.le_card_quotient_mul_sq_inter_subgroup","module":"Mathlib.Geometry.Group.Growth.QuotientInter","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : DecidableEq G\nH : Subgroup G\ninst✝¹ : DecidablePred fun x => Membership.mem H x\ninst✝ : H.Normal\nA : Finset G\nhAsymm : Eq (Inv.inv A) A\n⊢ LE.le A.card (HMul.hMul (Finset.image (⇑(QuotientGroup.mk' H)) A).card (Finset.filter (fun x => Membership.mem H x) (HPow.hPow A 2)).card)","decl":"@[to_additive]\nlemma le_card_quotient_mul_sq_inter_subgroup (hAsymm : A⁻¹ = A) :\n    #A ≤ #(A.image <| QuotientGroup.mk' H) * #{x ∈ A ^ 2 | x ∈ H} := by\n  classical\n  set π := QuotientGroup.mk' H\n  rw [card_eq_sum_card_image π]\n  refine sum_le_card_nsmul _ _ _ <| forall_mem_image.2 fun a ha ↦ ?_\n  calc\n    #{a' ∈ A | π a' = π a}\n    _ ≤ #({a' ∈ A | π a' = π a}⁻¹ * {a' ∈ A | π a' = π a}) :=\n      card_le_card_mul_left ⟨a⁻¹, by simpa⟩\n    _ ≤ #{x ∈ A⁻¹ * A | x ∈ H} := by\n      gcongr\n      simp only [mul_subset_iff, mem_inv', map_inv, mem_filter, and_imp]\n      rintro x hx hxa y hy hya\n      refine ⟨mul_mem_mul (by simpa) hy, (QuotientGroup.eq_one_iff _).1 (?_ : π _ = _)⟩\n      simp [hya, ← hxa]\n    _ = #{x ∈ A ^ 2 | x ∈ H} := by simp [hAsymm, sq]\n\n"}
{"name":"Finset.le_card_quotient_add_sq_inter_addSubgroup","module":"Mathlib.Geometry.Group.Growth.QuotientInter","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : DecidableEq G\nH : AddSubgroup G\ninst✝¹ : DecidablePred fun x => Membership.mem H x\ninst✝ : H.Normal\nA : Finset G\nhAsymm : Eq (Neg.neg A) A\n⊢ LE.le A.card (HMul.hMul (Finset.image (⇑(QuotientAddGroup.mk' H)) A).card (Finset.filter (fun x => Membership.mem H x) (HSMul.hSMul 2 A)).card)","decl":"@[to_additive]\nlemma le_card_quotient_mul_sq_inter_subgroup (hAsymm : A⁻¹ = A) :\n    #A ≤ #(A.image <| QuotientGroup.mk' H) * #{x ∈ A ^ 2 | x ∈ H} := by\n  classical\n  set π := QuotientGroup.mk' H\n  rw [card_eq_sum_card_image π]\n  refine sum_le_card_nsmul _ _ _ <| forall_mem_image.2 fun a ha ↦ ?_\n  calc\n    #{a' ∈ A | π a' = π a}\n    _ ≤ #({a' ∈ A | π a' = π a}⁻¹ * {a' ∈ A | π a' = π a}) :=\n      card_le_card_mul_left ⟨a⁻¹, by simpa⟩\n    _ ≤ #{x ∈ A⁻¹ * A | x ∈ H} := by\n      gcongr\n      simp only [mul_subset_iff, mem_inv', map_inv, mem_filter, and_imp]\n      rintro x hx hxa y hy hya\n      refine ⟨mul_mem_mul (by simpa) hy, (QuotientGroup.eq_one_iff _).1 (?_ : π _ = _)⟩\n      simp [hya, ← hxa]\n    _ = #{x ∈ A ^ 2 | x ∈ H} := by simp [hAsymm, sq]\n\n"}
