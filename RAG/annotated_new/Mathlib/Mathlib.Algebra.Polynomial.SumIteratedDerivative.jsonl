{"name":"Polynomial.sumIDeriv_apply","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (Polynomial.sumIDeriv p) ((Finset.range (HAdd.hAdd p.natDegree 1)).sum fun i => Nat.iterate (⇑Polynomial.derivative) i p)","decl":"theorem sumIDeriv_apply (p : R[X]) :\n    sumIDeriv p = ∑ i ∈ range (p.natDegree + 1), derivative^[i] p := by\n  dsimp [sumIDeriv]\n  exact Finsupp.sum_of_support_subset _ (by simp) _ (by simp)\n\n"}
{"name":"Polynomial.sumIDeriv_apply_of_lt","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\nhn : LT.lt p.natDegree n\n⊢ Eq (Polynomial.sumIDeriv p) ((Finset.range n).sum fun i => Nat.iterate (⇑Polynomial.derivative) i p)","decl":"theorem sumIDeriv_apply_of_lt {p : R[X]} {n : ℕ} (hn : p.natDegree < n) :\n    sumIDeriv p = ∑ i ∈ range n, derivative^[i] p := by\n  dsimp [sumIDeriv]\n  exact Finsupp.sum_of_support_subset _ (by simp [hn]) _ (by simp)\n\n"}
{"name":"Polynomial.sumIDeriv_apply_of_le","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\nhn : LE.le p.natDegree n\n⊢ Eq (Polynomial.sumIDeriv p) ((Finset.range (HAdd.hAdd n 1)).sum fun i => Nat.iterate (⇑Polynomial.derivative) i p)","decl":"theorem sumIDeriv_apply_of_le {p : R[X]} {n : ℕ} (hn : p.natDegree ≤ n) :\n    sumIDeriv p = ∑ i ∈ range (n + 1), derivative^[i] p := by\n  dsimp [sumIDeriv]\n  exact Finsupp.sum_of_support_subset _ (by simp [Nat.lt_succ, hn]) _ (by simp)\n\n"}
{"name":"Polynomial.sumIDeriv_C","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝ : Semiring R\na : R\n⊢ Eq (Polynomial.sumIDeriv (Polynomial.C a)) (Polynomial.C a)","decl":"@[simp]\ntheorem sumIDeriv_C (a : R) : sumIDeriv (C a) = C a := by\n  rw [sumIDeriv_apply, natDegree_C, zero_add, sum_range_one, Function.iterate_zero_apply]\n\n"}
{"name":"Polynomial.sumIDeriv_X","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"⊢ Eq (Polynomial.sumIDeriv Polynomial.X) (HAdd.hAdd Polynomial.X (Polynomial.C 1))","decl":"@[simp]\ntheorem sumIDeriv_X : sumIDeriv X = X + C 1 := by\n  rw [sumIDeriv_apply, natDegree_X, sum_range_succ, sum_range_one, Function.iterate_zero_apply,\n    Function.iterate_one, derivative_X, eq_natCast, Nat.cast_one]\n\n"}
{"name":"Polynomial.sumIDeriv_map","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Semiring S\np : Polynomial R\nf : RingHom R S\n⊢ Eq (Polynomial.sumIDeriv (Polynomial.map f p)) (Polynomial.map f (Polynomial.sumIDeriv p))","decl":"@[simp]\ntheorem sumIDeriv_map (p : R[X]) (f : R →+* S) :\n    sumIDeriv (p.map f) = (sumIDeriv p).map f := by\n  let n := max (p.map f).natDegree p.natDegree\n  rw [sumIDeriv_apply_of_le (le_max_left _ _ : _ ≤ n)]\n  rw [sumIDeriv_apply_of_le (le_max_right _ _ : _ ≤ n)]\n  simp_rw [Polynomial.map_sum, iterate_derivative_map p f]\n\n"}
{"name":"Polynomial.sumIDeriv_derivative","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (Polynomial.sumIDeriv (Polynomial.derivative p)) (Polynomial.derivative (Polynomial.sumIDeriv p))","decl":"theorem sumIDeriv_derivative (p : R[X]) : sumIDeriv (derivative p) = derivative (sumIDeriv p) := by\n  rw [sumIDeriv_apply_of_le ((natDegree_derivative_le p).trans tsub_le_self), sumIDeriv_apply,\n    derivative_sum]\n  simp_rw [← Function.iterate_succ_apply, Function.iterate_succ_apply']\n\n"}
{"name":"Polynomial.sumIDeriv_eq_self_add","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (Polynomial.sumIDeriv p) (HAdd.hAdd p (Polynomial.derivative (Polynomial.sumIDeriv p)))","decl":"theorem sumIDeriv_eq_self_add (p : R[X]) : sumIDeriv p = p + derivative (sumIDeriv p) := by\n  rw [sumIDeriv_apply, derivative_sum, sum_range_succ', sum_range_succ,\n    add_comm, ← add_zero (Finset.sum _ _)]\n  simp_rw [← Function.iterate_succ_apply' derivative, Nat.succ_eq_add_one,\n    Function.iterate_zero_apply, iterate_derivative_eq_zero (Nat.lt_succ_self _)]\n\n"}
{"name":"Polynomial.exists_iterate_derivative_eq_factorial_smul","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\nk : Nat\n⊢ Exists fun gp => And (LE.le gp.natDegree (HSub.hSub p.natDegree k)) (Eq (Nat.iterate (⇑Polynomial.derivative) k p) (HSMul.hSMul k.factorial gp))","decl":"theorem exists_iterate_derivative_eq_factorial_smul (p : R[X]) (k : ℕ) :\n    ∃ gp : R[X], gp.natDegree ≤ p.natDegree - k ∧ derivative^[k] p = k ! • gp := by\n  refine ⟨_, (natDegree_sum_le _ _).trans ?_, iterate_derivative_eq_factorial_smul_sum p k⟩\n  rw [fold_max_le]\n  refine ⟨Nat.zero_le _, fun i hi => ?_⟩\n  dsimp only [Function.comp]\n  exact (natDegree_C_mul_le _ _).trans <| (natDegree_X_pow_le _).trans <|\n    (le_natDegree_of_mem_supp _ hi).trans <| natDegree_iterate_derivative _ _\n\n"}
{"name":"Polynomial.aeval_iterate_derivative_of_lt","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nA : Type u_3\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\np : Polynomial R\nq : Nat\nr : A\np' : Polynomial A\nhp : Eq (Polynomial.map (algebraMap R A) p) (HMul.hMul (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C r)) q) p')\nk : Nat\nhk : LT.lt k q\n⊢ Eq ((Polynomial.aeval r) (Nat.iterate (⇑Polynomial.derivative) k p)) 0","decl":"theorem aeval_iterate_derivative_of_lt (p : R[X]) (q : ℕ) (r : A) {p' : A[X]}\n    (hp : p.map (algebraMap R A) = (X - C r) ^ q * p') {k : ℕ} (hk : k < q) :\n    aeval r (derivative^[k] p) = 0 := by\n  have h (x) : (X - C r) ^ (q - (k - x)) = (X - C r) ^ 1 * (X - C r) ^ (q - (k - x) - 1) := by\n    rw [← pow_add, add_tsub_cancel_of_le]\n    rw [Nat.lt_iff_add_one_le] at hk\n    exact (le_tsub_of_add_le_left hk).trans (tsub_le_tsub_left (tsub_le_self : _ ≤ k) _)\n  rw [aeval_def, eval₂_eq_eval_map, ← iterate_derivative_map]\n  simp_rw [hp, iterate_derivative_mul, iterate_derivative_X_sub_pow, ← smul_mul_assoc, smul_smul,\n    h, ← mul_smul_comm, mul_assoc, ← mul_sum, eval_mul, pow_one, eval_sub, eval_X, eval_C, sub_self,\n    zero_mul]\n\n"}
{"name":"Polynomial.aeval_iterate_derivative_self","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nA : Type u_3\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\np : Polynomial R\nq : Nat\nr : A\np' : Polynomial A\nhp : Eq (Polynomial.map (algebraMap R A) p) (HMul.hMul (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C r)) q) p')\n⊢ Eq ((Polynomial.aeval r) (Nat.iterate (⇑Polynomial.derivative) q p)) (HSMul.hSMul q.factorial (Polynomial.eval r p'))","decl":"theorem aeval_iterate_derivative_self (p : R[X]) (q : ℕ) (r : A) {p' : A[X]}\n    (hp : p.map (algebraMap R A) = (X - C r) ^ q * p') :\n    aeval r (derivative^[q] p) = q ! • p'.eval r := by\n  have h (x) (h : 1 ≤ x) (h' : x ≤ q) :\n      (X - C r) ^ (q - (q - x)) = (X - C r) ^ 1 * (X - C r) ^ (q - (q - x) - 1) := by\n    rw [← pow_add, add_tsub_cancel_of_le]\n    rwa [tsub_tsub_cancel_of_le h']\n  rw [aeval_def, eval₂_eq_eval_map, ← iterate_derivative_map]\n  simp_rw [hp, iterate_derivative_mul, iterate_derivative_X_sub_pow, ← smul_mul_assoc, smul_smul]\n  rw [sum_range_succ', Nat.choose_zero_right, one_mul, tsub_zero, Nat.descFactorial_self, tsub_self,\n    pow_zero, smul_mul_assoc, one_mul, Function.iterate_zero_apply, eval_add, eval_smul]\n  convert zero_add _\n  rw [eval_finset_sum]\n  apply sum_eq_zero\n  intro x hx\n  rw [h (x + 1) le_add_self (Nat.add_one_le_iff.mpr (mem_range.mp hx)), pow_one,\n    eval_mul, eval_smul, eval_mul, eval_sub, eval_X, eval_C, sub_self, zero_mul,\n    smul_zero, zero_mul]\n\n"}
{"name":"Polynomial.aeval_iterate_derivative_of_ge","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nA : Type u_3\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\np : Polynomial R\nq k : Nat\nhk : LE.le q k\n⊢ Exists fun gp => And (LE.le gp.natDegree (HSub.hSub p.natDegree k)) (∀ (r : A), Eq ((Polynomial.aeval r) (Nat.iterate (⇑Polynomial.derivative) k p)) (HSMul.hSMul q.factorial ((Polynomial.aeval r) gp)))","decl":"theorem aeval_iterate_derivative_of_ge (p : R[X]) (q : ℕ) {k : ℕ} (hk : q ≤ k) :\n    ∃ gp : R[X], gp.natDegree ≤ p.natDegree - k ∧\n      ∀ r : A, aeval r (derivative^[k] p) = q ! • aeval r gp := by\n  obtain ⟨p', p'_le, hp'⟩ := exists_iterate_derivative_eq_factorial_smul p k\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le hk\n  refine ⟨((q + k).descFactorial k : R[X]) * p', (natDegree_C_mul_le _ _).trans p'_le, fun r => ?_⟩\n  simp_rw [hp', nsmul_eq_mul, map_mul, map_natCast, ← mul_assoc, ← Nat.cast_mul,\n    Nat.add_descFactorial_eq_ascFactorial, Nat.factorial_mul_ascFactorial]\n\n"}
{"name":"Polynomial.aeval_sumIDeriv_eq_eval","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nA : Type u_3\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\np : Polynomial R\nr : A\n⊢ Eq ((Polynomial.aeval r) (Polynomial.sumIDeriv p)) (Polynomial.eval r (Polynomial.sumIDeriv (Polynomial.map (algebraMap R A) p)))","decl":"theorem aeval_sumIDeriv_eq_eval (p : R[X]) (r : A) :\n    aeval r (sumIDeriv p) = eval r (sumIDeriv (map (algebraMap R A) p)) := by\n  rw [aeval_def, eval, sumIDeriv_map, eval₂_map, RingHom.id_comp]\n\n"}
{"name":"Polynomial.aeval_sumIDeriv","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nA : Type u_3\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\np : Polynomial R\nq : Nat\n⊢ Exists fun gp => And (LE.le gp.natDegree (HSub.hSub p.natDegree q)) (∀ (r : A), Dvd.dvd (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C r)) q) (Polynomial.map (algebraMap R A) p) → Eq ((Polynomial.aeval r) (Polynomial.sumIDeriv p)) (HSMul.hSMul q.factorial ((Polynomial.aeval r) gp)))","decl":"theorem aeval_sumIDeriv (p : R[X]) (q : ℕ) :\n    ∃ gp : R[X], gp.natDegree ≤ p.natDegree - q ∧\n      ∀ (r : A), (X - C r) ^ q ∣ p.map (algebraMap R A) →\n        aeval r (sumIDeriv p) = q ! • aeval r gp := by\n  have h (k) :\n      ∃ gp : R[X], gp.natDegree ≤ p.natDegree - q ∧\n        ∀ (r : A), (X - C r) ^ q ∣ p.map (algebraMap R A) →\n          aeval r (derivative^[k] p) = q ! • aeval r gp := by\n    cases lt_or_ge k q with\n    | inl hk =>\n      use 0\n      rw [natDegree_zero]\n      use Nat.zero_le _\n      intro r ⟨p', hp⟩\n      rw [map_zero, smul_zero, aeval_iterate_derivative_of_lt p q r hp hk]\n    | inr hk =>\n      obtain ⟨gp, gp_le, h⟩ := aeval_iterate_derivative_of_ge A p q hk\n      exact ⟨gp, gp_le.trans (tsub_le_tsub_left hk _), fun r _ => h r⟩\n  choose c h using h\n  choose c_le hc using h\n  refine ⟨(range (p.natDegree + 1)).sum c, ?_, ?_⟩\n  · refine (natDegree_sum_le _ _).trans ?_\n    rw [fold_max_le]\n    exact ⟨Nat.zero_le _, fun i _ => c_le i⟩\n  intro r ⟨p', hp⟩\n  rw [sumIDeriv_apply, map_sum]; simp_rw [hc _ r ⟨_, hp⟩, map_sum, smul_sum]\n\n"}
{"name":"Polynomial.aeval_sumIDeriv_of_pos","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nA : Type u_3\ninst✝³ : CommRing A\ninst✝² : Algebra R A\ninst✝¹ : Nontrivial A\ninst✝ : NoZeroDivisors A\np : Polynomial R\nq : Nat\nhq : LT.lt 0 q\ninj_amap : Function.Injective ⇑(algebraMap R A)\n⊢ Exists fun gp => And (LE.le gp.natDegree (HSub.hSub p.natDegree q)) (∀ (r : A) {p' : Polynomial A}, Eq (Polynomial.map (algebraMap R A) p) (HMul.hMul (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C r)) (HSub.hSub q 1)) p') → Eq ((Polynomial.aeval r) (Polynomial.sumIDeriv p)) (HAdd.hAdd (HSMul.hSMul (HSub.hSub q 1).factorial (Polynomial.eval r p')) (HSMul.hSMul q.factorial ((Polynomial.aeval r) gp))))","decl":"theorem aeval_sumIDeriv_of_pos [Nontrivial A] [NoZeroDivisors A] (p : R[X]) {q : ℕ} (hq : 0 < q)\n    (inj_amap : Function.Injective (algebraMap R A)) :\n    ∃ gp : R[X], gp.natDegree ≤ p.natDegree - q ∧\n      ∀ (r : A) {p' : A[X]},\n        p.map (algebraMap R A) = (X - C r) ^ (q - 1) * p' →\n        aeval r (sumIDeriv p) = (q - 1)! • p'.eval r + q ! • aeval r gp := by\n  rcases eq_or_ne p 0 with (rfl | p0)\n  · use 0\n    rw [natDegree_zero]\n    use Nat.zero_le _\n    intro r p' hp\n    rw [map_zero, map_zero, smul_zero, add_zero]\n    rw [Polynomial.map_zero] at hp\n    replace hp := (mul_eq_zero.mp hp.symm).resolve_left ?_\n    · rw [hp, eval_zero, smul_zero]\n    exact fun h => X_sub_C_ne_zero r (pow_eq_zero h)\n  let c k := if hk : q ≤ k then (aeval_iterate_derivative_of_ge A p q hk).choose else 0\n  have c_le (k) : (c k).natDegree ≤ p.natDegree - k := by\n    dsimp only [c]\n    split_ifs with h\n    · exact (aeval_iterate_derivative_of_ge A p q h).choose_spec.1\n    · rw [natDegree_zero]; exact Nat.zero_le _\n  have hc (k) (hk : q ≤ k) : ∀ (r : A), aeval r (derivative^[k] p) = q ! • aeval r (c k) := by\n    simp_rw [c, dif_pos hk]\n    exact (aeval_iterate_derivative_of_ge A p q hk).choose_spec.2\n  refine ⟨∑ x ∈ Ico q (p.natDegree + 1), c x, ?_, ?_⟩\n  · refine (natDegree_sum_le _ _).trans ?_\n    rw [fold_max_le]\n    exact ⟨Nat.zero_le _, fun i hi => (c_le i).trans (tsub_le_tsub_left (mem_Ico.mp hi).1 _)⟩\n  intro r p' hp\n  have : range (p.natDegree + 1) = range q ∪ Ico q (p.natDegree + 1) := by\n    rw [range_eq_Ico, Ico_union_Ico_eq_Ico hq.le]\n    rw [← tsub_le_iff_right]\n    calc\n      q - 1 ≤ q - 1 + p'.natDegree := le_self_add\n      _ = (p.map <| algebraMap R A).natDegree := by\n        rw [hp, natDegree_mul, natDegree_pow, natDegree_X_sub_C, mul_one,\n          ← Nat.sub_add_comm (Nat.one_le_of_lt hq)]\n        · exact pow_ne_zero _ (X_sub_C_ne_zero r)\n        · rintro rfl\n          rw [mul_zero, Polynomial.map_eq_zero_iff inj_amap] at hp\n          exact p0 hp\n      _ ≤ p.natDegree := natDegree_map_le\n  rw [← zero_add ((q - 1)! • p'.eval r)]\n  rw [sumIDeriv_apply, map_sum, map_sum, this]\n  have : range q = range (q - 1 + 1) := by rw [tsub_add_cancel_of_le (Nat.one_le_of_lt hq)]\n  rw [sum_union, this, sum_range_succ]\n  · congr 2\n    · apply sum_eq_zero\n      exact fun x hx => aeval_iterate_derivative_of_lt p _ r hp (mem_range.mp hx)\n    · rw [← aeval_iterate_derivative_self _ _ _ hp]\n    · rw [smul_sum, sum_congr rfl]\n      intro k hk\n      exact hc k (mem_Ico.mp hk).1 r\n  · rw [range_eq_Ico, disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem]\n    intro x hx\n    rw [mem_inter, mem_Ico, mem_Ico] at hx\n    exact hx.1.2.not_le hx.2.1\n\n"}
{"name":"Polynomial.eval_sumIDeriv_of_pos","module":"Mathlib.Algebra.Polynomial.SumIteratedDerivative","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroDivisors R\np : Polynomial R\nq : Nat\nhq : LT.lt 0 q\n⊢ Exists fun gp => And (LE.le gp.natDegree (HSub.hSub p.natDegree q)) (∀ (r : R) {p' : Polynomial R}, Eq p (HMul.hMul (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C r)) (HSub.hSub q 1)) p') → Eq (Polynomial.eval r (Polynomial.sumIDeriv p)) (HAdd.hAdd (HSMul.hSMul (HSub.hSub q 1).factorial (Polynomial.eval r p')) (HSMul.hSMul q.factorial (Polynomial.eval r gp))))","decl":"theorem eval_sumIDeriv_of_pos\n    [CommRing R] [Nontrivial R] [NoZeroDivisors R] (p : R[X]) {q : ℕ} (hq : 0 < q) :\n    ∃ gp : R[X], gp.natDegree ≤ p.natDegree - q ∧\n      ∀ (r : R) {p' : R[X]},\n        p = ((X : R[X]) - C r) ^ (q - 1) * p' →\n        eval r (sumIDeriv p) = (q - 1)! • p'.eval r + q ! • eval r gp := by\n  simpa using aeval_sumIDeriv_of_pos R p hq Function.injective_id\n\n"}
