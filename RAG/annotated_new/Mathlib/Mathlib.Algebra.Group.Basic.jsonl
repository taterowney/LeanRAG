{"name":"dite_smul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : SMul β α\np : Prop\ninst✝ : Decidable p\na : α\nb : p → β\nc : Not p → β\n⊢ Eq (HSMul.hSMul (dite p (fun h => b h) fun h => c h) a) (dite p (fun h => HSMul.hSMul (b h) a) fun h => HSMul.hSMul (c h) a)","decl":"@[to_additive (attr := simp) dite_smul]\nlemma pow_dite (p : Prop) [Decidable p] (a : α) (b : p → β) (c : ¬ p → β) :\n    a ^ (if h : p then b h else c h) = if h : p then a ^ b h else a ^ c h := by split_ifs <;> rfl\n\n"}
{"name":"pow_dite","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Pow α β\np : Prop\ninst✝ : Decidable p\na : α\nb : p → β\nc : Not p → β\n⊢ Eq (HPow.hPow a (dite p (fun h => b h) fun h => c h)) (dite p (fun h => HPow.hPow a (b h)) fun h => HPow.hPow a (c h))","decl":"@[to_additive (attr := simp) dite_smul]\nlemma pow_dite (p : Prop) [Decidable p] (a : α) (b : p → β) (c : ¬ p → β) :\n    a ^ (if h : p then b h else c h) = if h : p then a ^ b h else a ^ c h := by split_ifs <;> rfl\n\n"}
{"name":"dite_pow","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Pow α β\np : Prop\ninst✝ : Decidable p\na : p → α\nb : Not p → α\nc : β\n⊢ Eq (HPow.hPow (dite p (fun h => a h) fun h => b h) c) (dite p (fun h => HPow.hPow (a h) c) fun h => HPow.hPow (b h) c)","decl":"@[to_additive (attr := simp) smul_dite]\nlemma dite_pow (p : Prop) [Decidable p] (a : p → α) (b : ¬ p → α) (c : β) :\n    (if h : p then a h else b h) ^ c = if h : p then a h ^ c else b h ^ c := by split_ifs <;> rfl\n\n"}
{"name":"smul_dite","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : SMul β α\np : Prop\ninst✝ : Decidable p\na : p → α\nb : Not p → α\nc : β\n⊢ Eq (HSMul.hSMul c (dite p (fun h => a h) fun h => b h)) (dite p (fun h => HSMul.hSMul c (a h)) fun h => HSMul.hSMul c (b h))","decl":"@[to_additive (attr := simp) smul_dite]\nlemma dite_pow (p : Prop) [Decidable p] (a : p → α) (b : ¬ p → α) (c : β) :\n    (if h : p then a h else b h) ^ c = if h : p then a h ^ c else b h ^ c := by split_ifs <;> rfl\n\n"}
{"name":"ite_smul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : SMul β α\np : Prop\ninst✝ : Decidable p\na : α\nb c : β\n⊢ Eq (HSMul.hSMul (ite p b c) a) (ite p (HSMul.hSMul b a) (HSMul.hSMul c a))","decl":"@[to_additive (attr := simp) ite_smul]\nlemma pow_ite (p : Prop) [Decidable p] (a : α) (b c : β) :\n    a ^ (if p then b else c) = if p then a ^ b else a ^ c := pow_dite _ _ _ _\n\n"}
{"name":"pow_ite","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Pow α β\np : Prop\ninst✝ : Decidable p\na : α\nb c : β\n⊢ Eq (HPow.hPow a (ite p b c)) (ite p (HPow.hPow a b) (HPow.hPow a c))","decl":"@[to_additive (attr := simp) ite_smul]\nlemma pow_ite (p : Prop) [Decidable p] (a : α) (b c : β) :\n    a ^ (if p then b else c) = if p then a ^ b else a ^ c := pow_dite _ _ _ _\n\n"}
{"name":"ite_pow","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Pow α β\np : Prop\ninst✝ : Decidable p\na b : α\nc : β\n⊢ Eq (HPow.hPow (ite p a b) c) (ite p (HPow.hPow a c) (HPow.hPow b c))","decl":"@[to_additive (attr := simp) smul_ite]\nlemma ite_pow (p : Prop) [Decidable p] (a b : α) (c : β) :\n    (if p then a else b) ^ c = if p then a ^ c else b ^ c := dite_pow _ _ _ _\n\n"}
{"name":"smul_ite","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : SMul β α\np : Prop\ninst✝ : Decidable p\na b : α\nc : β\n⊢ Eq (HSMul.hSMul c (ite p a b)) (ite p (HSMul.hSMul c a) (HSMul.hSMul c b))","decl":"@[to_additive (attr := simp) smul_ite]\nlemma ite_pow (p : Prop) [Decidable p] (a b : α) (c : β) :\n    (if p then a else b) ^ c = if p then a ^ c else b ^ c := dite_pow _ _ _ _\n\n"}
{"name":"dite_vadd","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : VAdd β α\np : Prop\ninst✝ : Decidable p\na : α\nb : p → β\nc : Not p → β\n⊢ Eq (HVAdd.hVAdd (dite p (fun h => b h) fun h => c h) a) (dite p (fun h => HVAdd.hVAdd (b h) a) fun h => HVAdd.hVAdd (c h) a)","decl":"set_option linter.existingAttributeWarning false in\nattribute [to_additive (attr := simp)] dite_smul smul_dite ite_smul smul_ite\n\n"}
{"name":"vadd_dite","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : VAdd β α\np : Prop\ninst✝ : Decidable p\na : p → α\nb : Not p → α\nc : β\n⊢ Eq (HVAdd.hVAdd c (dite p (fun h => a h) fun h => b h)) (dite p (fun h => HVAdd.hVAdd c (a h)) fun h => HVAdd.hVAdd c (b h))","decl":"set_option linter.existingAttributeWarning false in\nattribute [to_additive (attr := simp)] dite_smul smul_dite ite_smul smul_ite\n\n"}
{"name":"ite_vadd","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : VAdd β α\np : Prop\ninst✝ : Decidable p\na : α\nb c : β\n⊢ Eq (HVAdd.hVAdd (ite p b c) a) (ite p (HVAdd.hVAdd b a) (HVAdd.hVAdd c a))","decl":"set_option linter.existingAttributeWarning false in\nattribute [to_additive (attr := simp)] dite_smul smul_dite ite_smul smul_ite\n\n"}
{"name":"vadd_ite","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : VAdd β α\np : Prop\ninst✝ : Decidable p\na b : α\nc : β\n⊢ Eq (HVAdd.hVAdd c (ite p a b)) (ite p (HVAdd.hVAdd c a) (HVAdd.hVAdd c b))","decl":"set_option linter.existingAttributeWarning false in\nattribute [to_additive (attr := simp)] dite_smul smul_dite ite_smul smul_ite\n\n"}
{"name":"mul_right_injective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝¹ : Mul G\ninst✝ : IsLeftCancelMul G\na : G\n⊢ Function.Injective fun x => HMul.hMul a x","decl":"@[to_additive]\ntheorem mul_right_injective (a : G) : Injective (a * ·) := fun _ _ ↦ mul_left_cancel\n\n"}
{"name":"add_right_injective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝¹ : Add G\ninst✝ : IsLeftCancelAdd G\na : G\n⊢ Function.Injective fun x => HAdd.hAdd a x","decl":"@[to_additive]\ntheorem mul_right_injective (a : G) : Injective (a * ·) := fun _ _ ↦ mul_left_cancel\n\n"}
{"name":"add_right_inj","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝¹ : Add G\ninst✝ : IsLeftCancelAdd G\na b c : G\n⊢ Iff (Eq (HAdd.hAdd a b) (HAdd.hAdd a c)) (Eq b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_right_inj (a : G) {b c : G} : a * b = a * c ↔ b = c :=\n  (mul_right_injective a).eq_iff\n\n"}
{"name":"mul_right_inj","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝¹ : Mul G\ninst✝ : IsLeftCancelMul G\na b c : G\n⊢ Iff (Eq (HMul.hMul a b) (HMul.hMul a c)) (Eq b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_right_inj (a : G) {b c : G} : a * b = a * c ↔ b = c :=\n  (mul_right_injective a).eq_iff\n\n"}
{"name":"add_ne_add_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝¹ : Add G\ninst✝ : IsLeftCancelAdd G\na b c : G\n⊢ Iff (Ne (HAdd.hAdd a b) (HAdd.hAdd a c)) (Ne b c)","decl":"@[to_additive]\ntheorem mul_ne_mul_right (a : G) {b c : G} : a * b ≠ a * c ↔ b ≠ c :=\n  (mul_right_injective a).ne_iff\n\n"}
{"name":"mul_ne_mul_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝¹ : Mul G\ninst✝ : IsLeftCancelMul G\na b c : G\n⊢ Iff (Ne (HMul.hMul a b) (HMul.hMul a c)) (Ne b c)","decl":"@[to_additive]\ntheorem mul_ne_mul_right (a : G) {b c : G} : a * b ≠ a * c ↔ b ≠ c :=\n  (mul_right_injective a).ne_iff\n\n"}
{"name":"add_left_injective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝¹ : Add G\ninst✝ : IsRightCancelAdd G\na : G\n⊢ Function.Injective fun x => HAdd.hAdd x a","decl":"@[to_additive]\ntheorem mul_left_injective (a : G) : Function.Injective (· * a) := fun _ _ ↦ mul_right_cancel\n\n"}
{"name":"mul_left_injective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝¹ : Mul G\ninst✝ : IsRightCancelMul G\na : G\n⊢ Function.Injective fun x => HMul.hMul x a","decl":"@[to_additive]\ntheorem mul_left_injective (a : G) : Function.Injective (· * a) := fun _ _ ↦ mul_right_cancel\n\n"}
{"name":"add_left_inj","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝¹ : Add G\ninst✝ : IsRightCancelAdd G\na b c : G\n⊢ Iff (Eq (HAdd.hAdd b a) (HAdd.hAdd c a)) (Eq b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_left_inj (a : G) {b c : G} : b * a = c * a ↔ b = c :=\n  (mul_left_injective a).eq_iff\n\n"}
{"name":"mul_left_inj","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝¹ : Mul G\ninst✝ : IsRightCancelMul G\na b c : G\n⊢ Iff (Eq (HMul.hMul b a) (HMul.hMul c a)) (Eq b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_left_inj (a : G) {b c : G} : b * a = c * a ↔ b = c :=\n  (mul_left_injective a).eq_iff\n\n"}
{"name":"add_ne_add_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝¹ : Add G\ninst✝ : IsRightCancelAdd G\na b c : G\n⊢ Iff (Ne (HAdd.hAdd b a) (HAdd.hAdd c a)) (Ne b c)","decl":"@[to_additive]\ntheorem mul_ne_mul_left (a : G) {b c : G} : b * a ≠ c * a ↔ b ≠ c :=\n  (mul_left_injective a).ne_iff\n\n"}
{"name":"mul_ne_mul_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝¹ : Mul G\ninst✝ : IsRightCancelMul G\na b c : G\n⊢ Iff (Ne (HMul.hMul b a) (HMul.hMul c a)) (Ne b c)","decl":"@[to_additive]\ntheorem mul_ne_mul_left (a : G) {b c : G} : b * a ≠ c * a ↔ b ≠ c :=\n  (mul_left_injective a).ne_iff\n\n"}
{"name":"AddSemigroup.to_isAssociative","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : AddSemigroup α\n⊢ Std.Associative fun x1 x2 => HAdd.hAdd x1 x2","decl":"@[to_additive]\ninstance Semigroup.to_isAssociative : Std.Associative (α := α) (· * ·) := ⟨mul_assoc⟩\n\n"}
{"name":"Semigroup.to_isAssociative","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\n⊢ Std.Associative fun x1 x2 => HMul.hMul x1 x2","decl":"@[to_additive]\ninstance Semigroup.to_isAssociative : Std.Associative (α := α) (· * ·) := ⟨mul_assoc⟩\n\n"}
{"name":"comp_mul_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\nx y : α\n⊢ Eq (Function.comp (fun x_1 => HMul.hMul x x_1) fun x => HMul.hMul y x) fun x_1 => HMul.hMul (HMul.hMul x y) x_1","decl":"/-- Composing two multiplications on the left by `y` then `x`\nis equal to a multiplication on the left by `x * y`.\n-/\n@[to_additive (attr := simp) \"Composing two additions on the left by `y` then `x`\nis equal to an addition on the left by `x + y`.\"]\ntheorem comp_mul_left (x y : α) : (x * ·) ∘ (y * ·) = (x * y * ·) := by\n  ext z\n  simp [mul_assoc]\n\n"}
{"name":"comp_add_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : AddSemigroup α\nx y : α\n⊢ Eq (Function.comp (fun x_1 => HAdd.hAdd x x_1) fun x => HAdd.hAdd y x) fun x_1 => HAdd.hAdd (HAdd.hAdd x y) x_1","decl":"/-- Composing two multiplications on the left by `y` then `x`\nis equal to a multiplication on the left by `x * y`.\n-/\n@[to_additive (attr := simp) \"Composing two additions on the left by `y` then `x`\nis equal to an addition on the left by `x + y`.\"]\ntheorem comp_mul_left (x y : α) : (x * ·) ∘ (y * ·) = (x * y * ·) := by\n  ext z\n  simp [mul_assoc]\n\n"}
{"name":"comp_mul_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\nx y : α\n⊢ Eq (Function.comp (fun x_1 => HMul.hMul x_1 x) fun x => HMul.hMul x y) fun x_1 => HMul.hMul x_1 (HMul.hMul y x)","decl":"/-- Composing two multiplications on the right by `y` and `x`\nis equal to a multiplication on the right by `y * x`.\n-/\n@[to_additive (attr := simp) \"Composing two additions on the right by `y` and `x`\nis equal to an addition on the right by `y + x`.\"]\ntheorem comp_mul_right (x y : α) : (· * x) ∘ (· * y) = (· * (y * x)) := by\n  ext z\n  simp [mul_assoc]\n\n"}
{"name":"comp_add_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : AddSemigroup α\nx y : α\n⊢ Eq (Function.comp (fun x_1 => HAdd.hAdd x_1 x) fun x => HAdd.hAdd x y) fun x_1 => HAdd.hAdd x_1 (HAdd.hAdd y x)","decl":"/-- Composing two multiplications on the right by `y` and `x`\nis equal to a multiplication on the right by `y * x`.\n-/\n@[to_additive (attr := simp) \"Composing two additions on the right by `y` and `x`\nis equal to an addition on the right by `y + x`.\"]\ntheorem comp_mul_right (x y : α) : (· * x) ∘ (· * y) = (· * (y * x)) := by\n  ext z\n  simp [mul_assoc]\n\n"}
{"name":"AddCommMagma.to_isCommutative","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommMagma G\n⊢ Std.Commutative fun x1 x2 => HAdd.hAdd x1 x2","decl":"@[to_additive]\ninstance CommMagma.to_isCommutative [CommMagma G] : Std.Commutative (α := G) (· * ·) := ⟨mul_comm⟩\n\n"}
{"name":"CommMagma.to_isCommutative","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommMagma G\n⊢ Std.Commutative fun x1 x2 => HMul.hMul x1 x2","decl":"@[to_additive]\ninstance CommMagma.to_isCommutative [CommMagma G] : Std.Commutative (α := G) (· * ·) := ⟨mul_comm⟩\n\n"}
{"name":"ite_mul_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝¹ : MulOneClass M\nP : Prop\ninst✝ : Decidable P\na b : M\n⊢ Eq (ite P (HMul.hMul a b) 1) (HMul.hMul (ite P a 1) (ite P b 1))","decl":"@[to_additive]\ntheorem ite_mul_one {P : Prop} [Decidable P] {a b : M} :\n    ite P (a * b) 1 = ite P a 1 * ite P b 1 := by\n  by_cases h : P <;> simp [h]\n\n"}
{"name":"ite_add_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝¹ : AddZeroClass M\nP : Prop\ninst✝ : Decidable P\na b : M\n⊢ Eq (ite P (HAdd.hAdd a b) 0) (HAdd.hAdd (ite P a 0) (ite P b 0))","decl":"@[to_additive]\ntheorem ite_mul_one {P : Prop} [Decidable P] {a b : M} :\n    ite P (a * b) 1 = ite P a 1 * ite P b 1 := by\n  by_cases h : P <;> simp [h]\n\n"}
{"name":"ite_one_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝¹ : MulOneClass M\nP : Prop\ninst✝ : Decidable P\na b : M\n⊢ Eq (ite P 1 (HMul.hMul a b)) (HMul.hMul (ite P 1 a) (ite P 1 b))","decl":"@[to_additive]\ntheorem ite_one_mul {P : Prop} [Decidable P] {a b : M} :\n    ite P 1 (a * b) = ite P 1 a * ite P 1 b := by\n  by_cases h : P <;> simp [h]\n\n"}
{"name":"ite_zero_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝¹ : AddZeroClass M\nP : Prop\ninst✝ : Decidable P\na b : M\n⊢ Eq (ite P 0 (HAdd.hAdd a b)) (HAdd.hAdd (ite P 0 a) (ite P 0 b))","decl":"@[to_additive]\ntheorem ite_one_mul {P : Prop} [Decidable P] {a b : M} :\n    ite P 1 (a * b) = ite P 1 a * ite P 1 b := by\n  by_cases h : P <;> simp [h]\n\n"}
{"name":"eq_zero_iff_eq_zero_of_add_eq_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\na b : M\nh : Eq (HAdd.hAdd a b) 0\n⊢ Iff (Eq a 0) (Eq b 0)","decl":"@[to_additive]\ntheorem eq_one_iff_eq_one_of_mul_eq_one {a b : M} (h : a * b = 1) : a = 1 ↔ b = 1 := by\n  constructor <;> (rintro rfl; simpa using h)\n\n"}
{"name":"eq_one_iff_eq_one_of_mul_eq_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\na b : M\nh : Eq (HMul.hMul a b) 1\n⊢ Iff (Eq a 1) (Eq b 1)","decl":"@[to_additive]\ntheorem eq_one_iff_eq_one_of_mul_eq_one {a b : M} (h : a * b = 1) : a = 1 ↔ b = 1 := by\n  constructor <;> (rintro rfl; simpa using h)\n\n"}
{"name":"one_mul_eq_id","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\n⊢ Eq (fun x => HMul.hMul 1 x) id","decl":"@[to_additive]\ntheorem one_mul_eq_id : ((1 : M) * ·) = id :=\n  funext one_mul\n\n"}
{"name":"zero_add_eq_id","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\n⊢ Eq (fun x => HAdd.hAdd 0 x) id","decl":"@[to_additive]\ntheorem one_mul_eq_id : ((1 : M) * ·) = id :=\n  funext one_mul\n\n"}
{"name":"add_zero_eq_id","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddZeroClass M\n⊢ Eq (fun x => HAdd.hAdd x 0) id","decl":"@[to_additive]\ntheorem mul_one_eq_id : (· * (1 : M)) = id :=\n  funext mul_one\n\n"}
{"name":"mul_one_eq_id","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : MulOneClass M\n⊢ Eq (fun x => HMul.hMul x 1) id","decl":"@[to_additive]\ntheorem mul_one_eq_id : (· * (1 : M)) = id :=\n  funext mul_one\n\n"}
{"name":"mul_left_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommSemigroup G\na b c : G\n⊢ Eq (HMul.hMul a (HMul.hMul b c)) (HMul.hMul b (HMul.hMul a c))","decl":"@[to_additive]\ntheorem mul_left_comm (a b c : G) : a * (b * c) = b * (a * c) := by\n  rw [← mul_assoc, mul_comm a, mul_assoc]\n\n"}
{"name":"add_left_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommSemigroup G\na b c : G\n⊢ Eq (HAdd.hAdd a (HAdd.hAdd b c)) (HAdd.hAdd b (HAdd.hAdd a c))","decl":"@[to_additive]\ntheorem mul_left_comm (a b c : G) : a * (b * c) = b * (a * c) := by\n  rw [← mul_assoc, mul_comm a, mul_assoc]\n\n"}
{"name":"mul_right_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommSemigroup G\na b c : G\n⊢ Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul (HMul.hMul a c) b)","decl":"@[to_additive]\ntheorem mul_right_comm (a b c : G) : a * b * c = a * c * b := by\n  rw [mul_assoc, mul_comm b, mul_assoc]\n\n"}
{"name":"add_right_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommSemigroup G\na b c : G\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) c) (HAdd.hAdd (HAdd.hAdd a c) b)","decl":"@[to_additive]\ntheorem mul_right_comm (a b c : G) : a * b * c = a * c * b := by\n  rw [mul_assoc, mul_comm b, mul_assoc]\n\n"}
{"name":"add_add_add_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommSemigroup G\na b c d : G\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) (HAdd.hAdd c d)) (HAdd.hAdd (HAdd.hAdd a c) (HAdd.hAdd b d))","decl":"@[to_additive]\ntheorem mul_mul_mul_comm (a b c d : G) : a * b * (c * d) = a * c * (b * d) := by\n  simp only [mul_left_comm, mul_assoc]\n\n"}
{"name":"mul_mul_mul_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommSemigroup G\na b c d : G\n⊢ Eq (HMul.hMul (HMul.hMul a b) (HMul.hMul c d)) (HMul.hMul (HMul.hMul a c) (HMul.hMul b d))","decl":"@[to_additive]\ntheorem mul_mul_mul_comm (a b c d : G) : a * b * (c * d) = a * c * (b * d) := by\n  simp only [mul_left_comm, mul_assoc]\n\n"}
{"name":"mul_rotate","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommSemigroup G\na b c : G\n⊢ Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul (HMul.hMul b c) a)","decl":"@[to_additive]\ntheorem mul_rotate (a b c : G) : a * b * c = b * c * a := by\n  simp only [mul_left_comm, mul_comm]\n\n"}
{"name":"add_rotate","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommSemigroup G\na b c : G\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) c) (HAdd.hAdd (HAdd.hAdd b c) a)","decl":"@[to_additive]\ntheorem mul_rotate (a b c : G) : a * b * c = b * c * a := by\n  simp only [mul_left_comm, mul_comm]\n\n"}
{"name":"add_rotate'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommSemigroup G\na b c : G\n⊢ Eq (HAdd.hAdd a (HAdd.hAdd b c)) (HAdd.hAdd b (HAdd.hAdd c a))","decl":"@[to_additive]\ntheorem mul_rotate' (a b c : G) : a * (b * c) = b * (c * a) := by\n  simp only [mul_left_comm, mul_comm]\n\n"}
{"name":"mul_rotate'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommSemigroup G\na b c : G\n⊢ Eq (HMul.hMul a (HMul.hMul b c)) (HMul.hMul b (HMul.hMul c a))","decl":"@[to_additive]\ntheorem mul_rotate' (a b c : G) : a * (b * c) = b * (c * a) := by\n  simp only [mul_left_comm, mul_comm]\n\n"}
{"name":"pow_boole","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝¹ : Monoid M\nP : Prop\ninst✝ : Decidable P\na : M\n⊢ Eq (HPow.hPow a (ite P 1 0)) (ite P a 1)","decl":"@[to_additive boole_nsmul]\nlemma pow_boole (P : Prop) [Decidable P] (a : M) :\n    (a ^ if P then 1 else 0) = if P then a else 1 := by simp only [pow_ite, pow_one, pow_zero]\n\n"}
{"name":"boole_nsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝¹ : AddMonoid M\nP : Prop\ninst✝ : Decidable P\na : M\n⊢ Eq (HSMul.hSMul (ite P 1 0) a) (ite P a 0)","decl":"@[to_additive boole_nsmul]\nlemma pow_boole (P : Prop) [Decidable P] (a : M) :\n    (a ^ if P then 1 else 0) = if P then a else 1 := by simp only [pow_ite, pow_one, pow_zero]\n\n"}
{"name":"pow_mul_pow_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nm n : Nat\na : M\nh : LE.le m n\n⊢ Eq (HMul.hMul (HPow.hPow a m) (HPow.hPow a (HSub.hSub n m))) (HPow.hPow a n)","decl":"@[to_additive nsmul_add_sub_nsmul]\nlemma pow_mul_pow_sub (a : M) (h : m ≤ n) : a ^ m * a ^ (n - m) = a ^ n := by\n  rw [← pow_add, Nat.add_comm, Nat.sub_add_cancel h]\n\n"}
{"name":"nsmul_add_sub_nsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nm n : Nat\na : M\nh : LE.le m n\n⊢ Eq (HAdd.hAdd (HSMul.hSMul m a) (HSMul.hSMul (HSub.hSub n m) a)) (HSMul.hSMul n a)","decl":"@[to_additive nsmul_add_sub_nsmul]\nlemma pow_mul_pow_sub (a : M) (h : m ≤ n) : a ^ m * a ^ (n - m) = a ^ n := by\n  rw [← pow_add, Nat.add_comm, Nat.sub_add_cancel h]\n\n"}
{"name":"pow_sub_mul_pow","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nm n : Nat\na : M\nh : LE.le m n\n⊢ Eq (HMul.hMul (HPow.hPow a (HSub.hSub n m)) (HPow.hPow a m)) (HPow.hPow a n)","decl":"@[to_additive sub_nsmul_nsmul_add]\nlemma pow_sub_mul_pow (a : M) (h : m ≤ n) : a ^ (n - m) * a ^ m = a ^ n := by\n  rw [← pow_add, Nat.sub_add_cancel h]\n\n"}
{"name":"sub_nsmul_nsmul_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nm n : Nat\na : M\nh : LE.le m n\n⊢ Eq (HAdd.hAdd (HSMul.hSMul (HSub.hSub n m) a) (HSMul.hSMul m a)) (HSMul.hSMul n a)","decl":"@[to_additive sub_nsmul_nsmul_add]\nlemma pow_sub_mul_pow (a : M) (h : m ≤ n) : a ^ (n - m) * a ^ m = a ^ n := by\n  rw [← pow_add, Nat.sub_add_cancel h]\n\n"}
{"name":"mul_pow_sub_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nn : Nat\nhn : Ne n 0\na : M\n⊢ Eq (HMul.hMul a (HPow.hPow a (HSub.hSub n 1))) (HPow.hPow a n)","decl":"@[to_additive sub_one_nsmul_add]\nlemma mul_pow_sub_one (hn : n ≠ 0) (a : M) : a * a ^ (n - 1) = a ^ n := by\n  rw [← pow_succ', Nat.sub_add_cancel <| Nat.one_le_iff_ne_zero.2 hn]\n\n"}
{"name":"sub_one_nsmul_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nn : Nat\nhn : Ne n 0\na : M\n⊢ Eq (HAdd.hAdd a (HSMul.hSMul (HSub.hSub n 1) a)) (HSMul.hSMul n a)","decl":"@[to_additive sub_one_nsmul_add]\nlemma mul_pow_sub_one (hn : n ≠ 0) (a : M) : a * a ^ (n - 1) = a ^ n := by\n  rw [← pow_succ', Nat.sub_add_cancel <| Nat.one_le_iff_ne_zero.2 hn]\n\n"}
{"name":"pow_sub_one_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nn : Nat\nhn : Ne n 0\na : M\n⊢ Eq (HMul.hMul (HPow.hPow a (HSub.hSub n 1)) a) (HPow.hPow a n)","decl":"@[to_additive add_sub_one_nsmul]\nlemma pow_sub_one_mul (hn : n ≠ 0) (a : M) : a ^ (n - 1) * a = a ^ n := by\n  rw [← pow_succ, Nat.sub_add_cancel <| Nat.one_le_iff_ne_zero.2 hn]\n\n"}
{"name":"add_sub_one_nsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nn : Nat\nhn : Ne n 0\na : M\n⊢ Eq (HAdd.hAdd (HSMul.hSMul (HSub.hSub n 1) a) a) (HSMul.hSMul n a)","decl":"@[to_additive add_sub_one_nsmul]\nlemma pow_sub_one_mul (hn : n ≠ 0) (a : M) : a ^ (n - 1) * a = a ^ n := by\n  rw [← pow_succ, Nat.sub_add_cancel <| Nat.one_le_iff_ne_zero.2 hn]\n\n"}
{"name":"pow_eq_pow_mod","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\na : M\nn m : Nat\nha : Eq (HPow.hPow a n) 1\n⊢ Eq (HPow.hPow a m) (HPow.hPow a (HMod.hMod m n))","decl":"/-- If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` -/\n@[to_additive nsmul_eq_mod_nsmul \"If `n • x = 0`, then `m • x` is the same as `(m % n) • x`\"]\nlemma pow_eq_pow_mod (m : ℕ) (ha : a ^ n = 1) : a ^ m = a ^ (m % n) := by\n  calc\n    a ^ m = a ^ (m % n + n * (m / n)) := by rw [Nat.mod_add_div]\n    _ = a ^ (m % n) := by simp [pow_add, pow_mul, ha]\n\n"}
{"name":"nsmul_eq_mod_nsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\na : M\nn m : Nat\nha : Eq (HSMul.hSMul n a) 0\n⊢ Eq (HSMul.hSMul m a) (HSMul.hSMul (HMod.hMod m n) a)","decl":"/-- If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` -/\n@[to_additive nsmul_eq_mod_nsmul \"If `n • x = 0`, then `m • x` is the same as `(m % n) • x`\"]\nlemma pow_eq_pow_mod (m : ℕ) (ha : a ^ n = 1) : a ^ m = a ^ (m % n) := by\n  calc\n    a ^ m = a ^ (m % n + n * (m / n)) := by rw [Nat.mod_add_div]\n    _ = a ^ (m % n) := by simp [pow_add, pow_mul, ha]\n\n"}
{"name":"pow_mul_pow_eq_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\na b : M\nn : Nat\na✝ : Eq (HMul.hMul a b) 1\n⊢ Eq (HMul.hMul (HPow.hPow a n) (HPow.hPow b n)) 1","decl":"@[to_additive] lemma pow_mul_pow_eq_one : ∀ n, a * b = 1 → a ^ n * b ^ n = 1\n  | 0, _ => by simp\n  | n + 1, h =>\n    calc\n      a ^ n.succ * b ^ n.succ = a ^ n * a * (b * b ^ n) := by rw [pow_succ, pow_succ']\n      _ = a ^ n * (a * b) * b ^ n := by simp only [mul_assoc]\n      _ = 1 := by simp [h, pow_mul_pow_eq_one]\n\n"}
{"name":"nsmul_add_nsmul_eq_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\na b : M\nn : Nat\na✝ : Eq (HAdd.hAdd a b) 0\n⊢ Eq (HAdd.hAdd (HSMul.hSMul n a) (HSMul.hSMul n b)) 0","decl":"@[to_additive] lemma pow_mul_pow_eq_one : ∀ n, a * b = 1 → a ^ n * b ^ n = 1\n  | 0, _ => by simp\n  | n + 1, h =>\n    calc\n      a ^ n.succ * b ^ n.succ = a ^ n * a * (b * b ^ n) := by rw [pow_succ, pow_succ']\n      _ = a ^ n * (a * b) * b ^ n := by simp only [mul_assoc]\n      _ = 1 := by simp [h, pow_mul_pow_eq_one]\n\n"}
{"name":"neg_unique","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddCommMonoid M\nx y z : M\nhy : Eq (HAdd.hAdd x y) 0\nhz : Eq (HAdd.hAdd x z) 0\n⊢ Eq y z","decl":"@[to_additive]\ntheorem inv_unique (hy : x * y = 1) (hz : x * z = 1) : y = z :=\n  left_inv_eq_right_inv (Trans.trans (mul_comm _ _) hy) hz\n\n"}
{"name":"inv_unique","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : CommMonoid M\nx y z : M\nhy : Eq (HMul.hMul x y) 1\nhz : Eq (HMul.hMul x z) 1\n⊢ Eq y z","decl":"@[to_additive]\ntheorem inv_unique (hy : x * y = 1) (hz : x * z = 1) : y = z :=\n  left_inv_eq_right_inv (Trans.trans (mul_comm _ _) hy) hz\n\n"}
{"name":"nsmul_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddCommMonoid M\na b : M\nn : Nat\n⊢ Eq (HSMul.hSMul n (HAdd.hAdd a b)) (HAdd.hAdd (HSMul.hSMul n a) (HSMul.hSMul n b))","decl":"@[to_additive nsmul_add] lemma mul_pow (a b : M) : ∀ n, (a * b) ^ n = a ^ n * b ^ n\n  | 0 => by rw [pow_zero, pow_zero, pow_zero, one_mul]\n  | n + 1 => by rw [pow_succ', pow_succ', pow_succ', mul_pow, mul_mul_mul_comm]\n\n"}
{"name":"mul_pow","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : CommMonoid M\na b : M\nn : Nat\n⊢ Eq (HPow.hPow (HMul.hMul a b) n) (HMul.hMul (HPow.hPow a n) (HPow.hPow b n))","decl":"@[to_additive nsmul_add] lemma mul_pow (a b : M) : ∀ n, (a * b) ^ n = a ^ n * b ^ n\n  | 0 => by rw [pow_zero, pow_zero, pow_zero, one_mul]\n  | n + 1 => by rw [pow_succ', pow_succ', pow_succ', mul_pow, mul_mul_mul_comm]\n\n"}
{"name":"add_right_eq_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddLeftCancelMonoid M\na b : M\n⊢ Iff (Eq (HAdd.hAdd a b) a) (Eq b 0)","decl":"@[to_additive (attr := simp)]\ntheorem mul_right_eq_self : a * b = a ↔ b = 1 := calc\n  a * b = a ↔ a * b = a * 1 := by rw [mul_one]\n  _ ↔ b = 1 := mul_left_cancel_iff\n\n"}
{"name":"mul_right_eq_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : LeftCancelMonoid M\na b : M\n⊢ Iff (Eq (HMul.hMul a b) a) (Eq b 1)","decl":"@[to_additive (attr := simp)]\ntheorem mul_right_eq_self : a * b = a ↔ b = 1 := calc\n  a * b = a ↔ a * b = a * 1 := by rw [mul_one]\n  _ ↔ b = 1 := mul_left_cancel_iff\n\n"}
{"name":"self_eq_mul_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : LeftCancelMonoid M\na b : M\n⊢ Iff (Eq a (HMul.hMul a b)) (Eq b 1)","decl":"@[to_additive (attr := simp)]\ntheorem self_eq_mul_right : a = a * b ↔ b = 1 :=\n  eq_comm.trans mul_right_eq_self\n\n"}
{"name":"self_eq_add_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddLeftCancelMonoid M\na b : M\n⊢ Iff (Eq a (HAdd.hAdd a b)) (Eq b 0)","decl":"@[to_additive (attr := simp)]\ntheorem self_eq_mul_right : a = a * b ↔ b = 1 :=\n  eq_comm.trans mul_right_eq_self\n\n"}
{"name":"mul_right_ne_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : LeftCancelMonoid M\na b : M\n⊢ Iff (Ne (HMul.hMul a b) a) (Ne b 1)","decl":"@[to_additive]\ntheorem mul_right_ne_self : a * b ≠ a ↔ b ≠ 1 := mul_right_eq_self.not\n\n"}
{"name":"add_right_ne_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddLeftCancelMonoid M\na b : M\n⊢ Iff (Ne (HAdd.hAdd a b) a) (Ne b 0)","decl":"@[to_additive]\ntheorem mul_right_ne_self : a * b ≠ a ↔ b ≠ 1 := mul_right_eq_self.not\n\n"}
{"name":"self_ne_add_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddLeftCancelMonoid M\na b : M\n⊢ Iff (Ne a (HAdd.hAdd a b)) (Ne b 0)","decl":"@[to_additive]\ntheorem self_ne_mul_right : a ≠ a * b ↔ b ≠ 1 := self_eq_mul_right.not\n\n"}
{"name":"self_ne_mul_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : LeftCancelMonoid M\na b : M\n⊢ Iff (Ne a (HMul.hMul a b)) (Ne b 1)","decl":"@[to_additive]\ntheorem self_ne_mul_right : a ≠ a * b ↔ b ≠ 1 := self_eq_mul_right.not\n\n"}
{"name":"mul_left_eq_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : RightCancelMonoid M\na b : M\n⊢ Iff (Eq (HMul.hMul a b) b) (Eq a 1)","decl":"@[to_additive (attr := simp)]\ntheorem mul_left_eq_self : a * b = b ↔ a = 1 := calc\n  a * b = b ↔ a * b = 1 * b := by rw [one_mul]\n  _ ↔ a = 1 := mul_right_cancel_iff\n\n"}
{"name":"add_left_eq_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddRightCancelMonoid M\na b : M\n⊢ Iff (Eq (HAdd.hAdd a b) b) (Eq a 0)","decl":"@[to_additive (attr := simp)]\ntheorem mul_left_eq_self : a * b = b ↔ a = 1 := calc\n  a * b = b ↔ a * b = 1 * b := by rw [one_mul]\n  _ ↔ a = 1 := mul_right_cancel_iff\n\n"}
{"name":"self_eq_mul_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : RightCancelMonoid M\na b : M\n⊢ Iff (Eq b (HMul.hMul a b)) (Eq a 1)","decl":"@[to_additive (attr := simp)]\ntheorem self_eq_mul_left : b = a * b ↔ a = 1 :=\n  eq_comm.trans mul_left_eq_self\n\n"}
{"name":"self_eq_add_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddRightCancelMonoid M\na b : M\n⊢ Iff (Eq b (HAdd.hAdd a b)) (Eq a 0)","decl":"@[to_additive (attr := simp)]\ntheorem self_eq_mul_left : b = a * b ↔ a = 1 :=\n  eq_comm.trans mul_left_eq_self\n\n"}
{"name":"add_left_ne_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddRightCancelMonoid M\na b : M\n⊢ Iff (Ne (HAdd.hAdd a b) b) (Ne a 0)","decl":"@[to_additive]\ntheorem mul_left_ne_self : a * b ≠ b ↔ a ≠ 1 := mul_left_eq_self.not\n\n"}
{"name":"mul_left_ne_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : RightCancelMonoid M\na b : M\n⊢ Iff (Ne (HMul.hMul a b) b) (Ne a 1)","decl":"@[to_additive]\ntheorem mul_left_ne_self : a * b ≠ b ↔ a ≠ 1 := mul_left_eq_self.not\n\n"}
{"name":"self_ne_add_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : AddRightCancelMonoid M\na b : M\n⊢ Iff (Ne b (HAdd.hAdd a b)) (Ne a 0)","decl":"@[to_additive]\ntheorem self_ne_mul_left : b ≠ a * b ↔ a ≠ 1 := self_eq_mul_left.not\n\n"}
{"name":"self_ne_mul_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"M : Type u_4\ninst✝ : RightCancelMonoid M\na b : M\n⊢ Iff (Ne b (HMul.hMul a b)) (Ne a 1)","decl":"@[to_additive]\ntheorem self_ne_mul_left : b ≠ a * b ↔ a ≠ 1 := self_eq_mul_left.not\n\n"}
{"name":"eq_iff_eq_of_mul_eq_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoid α\na b c d : α\nh : Eq (HMul.hMul a b) (HMul.hMul c d)\n⊢ Iff (Eq a c) (Eq b d)","decl":"@[to_additive] lemma eq_iff_eq_of_mul_eq_mul (h : a * b = c * d) : a = c ↔ b = d := by aesop\n"}
{"name":"eq_iff_eq_of_add_eq_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : AddCancelCommMonoid α\na b c d : α\nh : Eq (HAdd.hAdd a b) (HAdd.hAdd c d)\n⊢ Iff (Eq a c) (Eq b d)","decl":"@[to_additive] lemma eq_iff_eq_of_mul_eq_mul (h : a * b = c * d) : a = c ↔ b = d := by aesop\n"}
{"name":"ne_iff_ne_of_add_eq_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : AddCancelCommMonoid α\na b c d : α\nh : Eq (HAdd.hAdd a b) (HAdd.hAdd c d)\n⊢ Iff (Ne a c) (Ne b d)","decl":"@[to_additive] lemma ne_iff_ne_of_mul_eq_mul (h : a * b = c * d) : a ≠ c ↔ b ≠ d := by aesop\n\n"}
{"name":"ne_iff_ne_of_mul_eq_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoid α\na b c d : α\nh : Eq (HMul.hMul a b) (HMul.hMul c d)\n⊢ Iff (Ne a c) (Ne b d)","decl":"@[to_additive] lemma ne_iff_ne_of_mul_eq_mul (h : a * b = c * d) : a ≠ c ↔ b ≠ d := by aesop\n\n"}
{"name":"inv_involutive","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveInv G\n⊢ Function.Involutive Inv.inv","decl":"@[to_additive (attr := simp)]\ntheorem inv_involutive : Function.Involutive (Inv.inv : G → G) :=\n  inv_inv\n\n"}
{"name":"neg_involutive","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveNeg G\n⊢ Function.Involutive Neg.neg","decl":"@[to_additive (attr := simp)]\ntheorem inv_involutive : Function.Involutive (Inv.inv : G → G) :=\n  inv_inv\n\n"}
{"name":"neg_surjective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveNeg G\n⊢ Function.Surjective Neg.neg","decl":"@[to_additive (attr := simp)]\ntheorem inv_surjective : Function.Surjective (Inv.inv : G → G) :=\n  inv_involutive.surjective\n\n"}
{"name":"inv_surjective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveInv G\n⊢ Function.Surjective Inv.inv","decl":"@[to_additive (attr := simp)]\ntheorem inv_surjective : Function.Surjective (Inv.inv : G → G) :=\n  inv_involutive.surjective\n\n"}
{"name":"inv_injective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveInv G\n⊢ Function.Injective Inv.inv","decl":"@[to_additive]\ntheorem inv_injective : Function.Injective (Inv.inv : G → G) :=\n  inv_involutive.injective\n\n"}
{"name":"neg_injective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveNeg G\n⊢ Function.Injective Neg.neg","decl":"@[to_additive]\ntheorem inv_injective : Function.Injective (Inv.inv : G → G) :=\n  inv_involutive.injective\n\n"}
{"name":"inv_inj","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveInv G\na b : G\n⊢ Iff (Eq (Inv.inv a) (Inv.inv b)) (Eq a b)","decl":"@[to_additive (attr := simp)]\ntheorem inv_inj : a⁻¹ = b⁻¹ ↔ a = b :=\n  inv_injective.eq_iff\n\n"}
{"name":"neg_inj","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveNeg G\na b : G\n⊢ Iff (Eq (Neg.neg a) (Neg.neg b)) (Eq a b)","decl":"@[to_additive (attr := simp)]\ntheorem inv_inj : a⁻¹ = b⁻¹ ↔ a = b :=\n  inv_injective.eq_iff\n\n"}
{"name":"neg_eq_iff_eq_neg","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveNeg G\na b : G\n⊢ Iff (Eq (Neg.neg a) b) (Eq a (Neg.neg b))","decl":"@[to_additive]\ntheorem inv_eq_iff_eq_inv : a⁻¹ = b ↔ a = b⁻¹ :=\n  ⟨fun h => h ▸ (inv_inv a).symm, fun h => h.symm ▸ inv_inv b⟩\n\n"}
{"name":"inv_eq_iff_eq_inv","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveInv G\na b : G\n⊢ Iff (Eq (Inv.inv a) b) (Eq a (Inv.inv b))","decl":"@[to_additive]\ntheorem inv_eq_iff_eq_inv : a⁻¹ = b ↔ a = b⁻¹ :=\n  ⟨fun h => h ▸ (inv_inv a).symm, fun h => h.symm ▸ inv_inv b⟩\n\n"}
{"name":"neg_comp_neg","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveNeg G\n⊢ Eq (Function.comp Neg.neg Neg.neg) id","decl":"@[to_additive]\ntheorem inv_comp_inv : Inv.inv ∘ Inv.inv = @id G :=\n  inv_involutive.comp_self\n\n"}
{"name":"inv_comp_inv","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveInv G\n⊢ Eq (Function.comp Inv.inv Inv.inv) id","decl":"@[to_additive]\ntheorem inv_comp_inv : Inv.inv ∘ Inv.inv = @id G :=\n  inv_involutive.comp_self\n\n"}
{"name":"leftInverse_neg","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveNeg G\n⊢ Function.LeftInverse (fun a => Neg.neg a) fun a => Neg.neg a","decl":"@[to_additive]\ntheorem leftInverse_inv : LeftInverse (fun a : G ↦ a⁻¹) fun a ↦ a⁻¹ :=\n  inv_inv\n\n"}
{"name":"leftInverse_inv","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveInv G\n⊢ Function.LeftInverse (fun a => Inv.inv a) fun a => Inv.inv a","decl":"@[to_additive]\ntheorem leftInverse_inv : LeftInverse (fun a : G ↦ a⁻¹) fun a ↦ a⁻¹ :=\n  inv_inv\n\n"}
{"name":"rightInverse_neg","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveNeg G\n⊢ Function.RightInverse (fun a => Neg.neg a) fun a => Neg.neg a","decl":"@[to_additive]\ntheorem rightInverse_inv : RightInverse (fun a : G ↦ a⁻¹) fun a ↦ a⁻¹ :=\n  inv_inv\n\n"}
{"name":"rightInverse_inv","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : InvolutiveInv G\n⊢ Function.RightInverse (fun a => Inv.inv a) fun a => Inv.inv a","decl":"@[to_additive]\ntheorem rightInverse_inv : RightInverse (fun a : G ↦ a⁻¹) fun a ↦ a⁻¹ :=\n  inv_inv\n\n"}
{"name":"inv_eq_one_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\nx : G\n⊢ Eq (Inv.inv x) (HDiv.hDiv 1 x)","decl":"@[to_additive, field_simps] -- The attributes are out of order on purpose\ntheorem inv_eq_one_div (x : G) : x⁻¹ = 1 / x := by rw [div_eq_mul_inv, one_mul]\n\n"}
{"name":"neg_eq_zero_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : SubNegMonoid G\nx : G\n⊢ Eq (Neg.neg x) (HSub.hSub 0 x)","decl":"@[to_additive, field_simps] -- The attributes are out of order on purpose\ntheorem inv_eq_one_div (x : G) : x⁻¹ = 1 / x := by rw [div_eq_mul_inv, one_mul]\n\n"}
{"name":"add_zero_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : SubNegMonoid G\nx y : G\n⊢ Eq (HAdd.hAdd x (HSub.hSub 0 y)) (HSub.hSub x y)","decl":"@[to_additive]\ntheorem mul_one_div (x y : G) : x * (1 / y) = x / y := by\n  rw [div_eq_mul_inv, one_mul, div_eq_mul_inv]\n\n"}
{"name":"mul_one_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\nx y : G\n⊢ Eq (HMul.hMul x (HDiv.hDiv 1 y)) (HDiv.hDiv x y)","decl":"@[to_additive]\ntheorem mul_one_div (x y : G) : x * (1 / y) = x / y := by\n  rw [div_eq_mul_inv, one_mul, div_eq_mul_inv]\n\n"}
{"name":"add_sub_assoc","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : SubNegMonoid G\na b c : G\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) c) (HAdd.hAdd a (HSub.hSub b c))","decl":"@[to_additive]\ntheorem mul_div_assoc (a b c : G) : a * b / c = a * (b / c) := by\n  rw [div_eq_mul_inv, div_eq_mul_inv, mul_assoc _ _ _]\n\n"}
{"name":"mul_div_assoc","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\na b c : G\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) c) (HMul.hMul a (HDiv.hDiv b c))","decl":"@[to_additive]\ntheorem mul_div_assoc (a b c : G) : a * b / c = a * (b / c) := by\n  rw [div_eq_mul_inv, div_eq_mul_inv, mul_assoc _ _ _]\n\n"}
{"name":"add_sub_assoc'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : SubNegMonoid G\na b c : G\n⊢ Eq (HAdd.hAdd a (HSub.hSub b c)) (HSub.hSub (HAdd.hAdd a b) c)","decl":"@[to_additive, field_simps] -- The attributes are out of order on purpose\ntheorem mul_div_assoc' (a b c : G) : a * (b / c) = a * b / c :=\n  (mul_div_assoc _ _ _).symm\n\n"}
{"name":"mul_div_assoc'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\na b c : G\n⊢ Eq (HMul.hMul a (HDiv.hDiv b c)) (HDiv.hDiv (HMul.hMul a b) c)","decl":"@[to_additive, field_simps] -- The attributes are out of order on purpose\ntheorem mul_div_assoc' (a b c : G) : a * (b / c) = a * b / c :=\n  (mul_div_assoc _ _ _).symm\n\n"}
{"name":"zero_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : SubNegMonoid G\na : G\n⊢ Eq (HSub.hSub 0 a) (Neg.neg a)","decl":"@[to_additive (attr := simp)]\ntheorem one_div (a : G) : 1 / a = a⁻¹ :=\n  (inv_eq_one_div a).symm\n\n"}
{"name":"one_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\na : G\n⊢ Eq (HDiv.hDiv 1 a) (Inv.inv a)","decl":"@[to_additive (attr := simp)]\ntheorem one_div (a : G) : 1 / a = a⁻¹ :=\n  (inv_eq_one_div a).symm\n\n"}
{"name":"add_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : SubNegMonoid G\na b c : G\n⊢ Eq (HAdd.hAdd a (HSub.hSub b c)) (HSub.hSub (HAdd.hAdd a b) c)","decl":"@[to_additive]\ntheorem mul_div (a b c : G) : a * (b / c) = a * b / c := by simp only [mul_assoc, div_eq_mul_inv]\n\n"}
{"name":"mul_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\na b c : G\n⊢ Eq (HMul.hMul a (HDiv.hDiv b c)) (HDiv.hDiv (HMul.hMul a b) c)","decl":"@[to_additive]\ntheorem mul_div (a b c : G) : a * (b / c) = a * b / c := by simp only [mul_assoc, div_eq_mul_inv]\n\n"}
{"name":"div_eq_mul_one_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : DivInvMonoid G\na b : G\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul a (HDiv.hDiv 1 b))","decl":"@[to_additive]\ntheorem div_eq_mul_one_div (a b : G) : a / b = a * (1 / b) := by rw [div_eq_mul_inv, one_div]\n\n"}
{"name":"sub_eq_add_zero_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : SubNegMonoid G\na b : G\n⊢ Eq (HSub.hSub a b) (HAdd.hAdd a (HSub.hSub 0 b))","decl":"@[to_additive]\ntheorem div_eq_mul_one_div (a b : G) : a / b = a * (1 / b) := by rw [div_eq_mul_inv, one_div]\n\n"}
{"name":"sub_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : SubNegZeroMonoid G\na : G\n⊢ Eq (HSub.hSub a 0) a","decl":"@[to_additive (attr := simp)]\ntheorem div_one (a : G) : a / 1 = a := by simp [div_eq_mul_inv]\n\n"}
{"name":"div_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : DivInvOneMonoid G\na : G\n⊢ Eq (HDiv.hDiv a 1) a","decl":"@[to_additive (attr := simp)]\ntheorem div_one (a : G) : a / 1 = a := by simp [div_eq_mul_inv]\n\n"}
{"name":"one_div_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : DivInvOneMonoid G\n⊢ Eq (1 / 1) 1","decl":"@[to_additive]\ntheorem one_div_one : (1 : G) / 1 = 1 :=\n  div_one _\n\n"}
{"name":"zero_sub_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : SubNegZeroMonoid G\n⊢ Eq (HSub.hSub 0 0) 0","decl":"@[to_additive]\ntheorem one_div_one : (1 : G) / 1 = 1 :=\n  div_one _\n\n"}
{"name":"eq_neg_of_add_eq_zero_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq b (Neg.neg a)","decl":"@[to_additive]\ntheorem eq_inv_of_mul_eq_one_right (h : a * b = 1) : b = a⁻¹ :=\n  (inv_eq_of_mul_eq_one_right h).symm\n\n"}
{"name":"eq_inv_of_mul_eq_one_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\nh : Eq (HMul.hMul a b) 1\n⊢ Eq b (Inv.inv a)","decl":"@[to_additive]\ntheorem eq_inv_of_mul_eq_one_right (h : a * b = 1) : b = a⁻¹ :=\n  (inv_eq_of_mul_eq_one_right h).symm\n\n"}
{"name":"eq_one_div_of_mul_eq_one_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\nh : Eq (HMul.hMul b a) 1\n⊢ Eq b (HDiv.hDiv 1 a)","decl":"@[to_additive]\ntheorem eq_one_div_of_mul_eq_one_left (h : b * a = 1) : b = 1 / a := by\n  rw [eq_inv_of_mul_eq_one_left h, one_div]\n\n"}
{"name":"eq_zero_sub_of_add_eq_zero_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\nh : Eq (HAdd.hAdd b a) 0\n⊢ Eq b (HSub.hSub 0 a)","decl":"@[to_additive]\ntheorem eq_one_div_of_mul_eq_one_left (h : b * a = 1) : b = 1 / a := by\n  rw [eq_inv_of_mul_eq_one_left h, one_div]\n\n"}
{"name":"eq_zero_sub_of_add_eq_zero_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq b (HSub.hSub 0 a)","decl":"@[to_additive]\ntheorem eq_one_div_of_mul_eq_one_right (h : a * b = 1) : b = 1 / a := by\n  rw [eq_inv_of_mul_eq_one_right h, one_div]\n\n"}
{"name":"eq_one_div_of_mul_eq_one_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\nh : Eq (HMul.hMul a b) 1\n⊢ Eq b (HDiv.hDiv 1 a)","decl":"@[to_additive]\ntheorem eq_one_div_of_mul_eq_one_right (h : a * b = 1) : b = 1 / a := by\n  rw [eq_inv_of_mul_eq_one_right h, one_div]\n\n"}
{"name":"eq_of_div_eq_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\nh : Eq (HDiv.hDiv a b) 1\n⊢ Eq a b","decl":"@[to_additive]\ntheorem eq_of_div_eq_one (h : a / b = 1) : a = b :=\n  inv_injective <| inv_eq_of_mul_eq_one_right <| by rwa [← div_eq_mul_inv]\n\n"}
{"name":"eq_of_sub_eq_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\nh : Eq (HSub.hSub a b) 0\n⊢ Eq a b","decl":"@[to_additive]\ntheorem eq_of_div_eq_one (h : a / b = 1) : a = b :=\n  inv_injective <| inv_eq_of_mul_eq_one_right <| by rwa [← div_eq_mul_inv]\n\n"}
{"name":"eq_of_neg_add_eq_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\nh : Eq (HAdd.hAdd (Neg.neg a) b) 0\n⊢ Eq a b","decl":"@[to_additive]\nlemma eq_of_inv_mul_eq_one (h : a⁻¹ * b = 1) : a = b := by simpa using eq_inv_of_mul_eq_one_left h\n\n"}
{"name":"eq_of_inv_mul_eq_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\nh : Eq (HMul.hMul (Inv.inv a) b) 1\n⊢ Eq a b","decl":"@[to_additive]\nlemma eq_of_inv_mul_eq_one (h : a⁻¹ * b = 1) : a = b := by simpa using eq_inv_of_mul_eq_one_left h\n\n"}
{"name":"eq_of_add_neg_eq_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\nh : Eq (HAdd.hAdd a (Neg.neg b)) 0\n⊢ Eq a b","decl":"@[to_additive]\nlemma eq_of_mul_inv_eq_one (h : a * b⁻¹ = 1) : a = b := by simpa using eq_inv_of_mul_eq_one_left h\n\n"}
{"name":"eq_of_mul_inv_eq_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\nh : Eq (HMul.hMul a (Inv.inv b)) 1\n⊢ Eq a b","decl":"@[to_additive]\nlemma eq_of_mul_inv_eq_one (h : a * b⁻¹ = 1) : a = b := by simpa using eq_inv_of_mul_eq_one_left h\n\n"}
{"name":"div_ne_one_of_ne","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\na✝ : Ne a b\n⊢ Ne (HDiv.hDiv a b) 1","decl":"@[to_additive]\ntheorem div_ne_one_of_ne : a ≠ b → a / b ≠ 1 :=\n  mt eq_of_div_eq_one\n\n"}
{"name":"sub_ne_zero_of_ne","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\na✝ : Ne a b\n⊢ Ne (HSub.hSub a b) 0","decl":"@[to_additive]\ntheorem div_ne_one_of_ne : a ≠ b → a / b ≠ 1 :=\n  mt eq_of_div_eq_one\n\n"}
{"name":"one_div_mul_one_div_rev","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\n⊢ Eq (HMul.hMul (HDiv.hDiv 1 a) (HDiv.hDiv 1 b)) (HDiv.hDiv 1 (HMul.hMul b a))","decl":"@[to_additive]\ntheorem one_div_mul_one_div_rev : 1 / a * (1 / b) = 1 / (b * a) := by simp\n\n"}
{"name":"zero_sub_add_zero_sub_rev","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\n⊢ Eq (HAdd.hAdd (HSub.hSub 0 a) (HSub.hSub 0 b)) (HSub.hSub 0 (HAdd.hAdd b a))","decl":"@[to_additive]\ntheorem one_div_mul_one_div_rev : 1 / a * (1 / b) = 1 / (b * a) := by simp\n\n"}
{"name":"inv_div_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\n⊢ Eq (HDiv.hDiv (Inv.inv a) b) (Inv.inv (HMul.hMul b a))","decl":"@[to_additive]\ntheorem inv_div_left : a⁻¹ / b = (b * a)⁻¹ := by simp\n\n"}
{"name":"neg_sub_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\n⊢ Eq (HSub.hSub (Neg.neg a) b) (Neg.neg (HAdd.hAdd b a))","decl":"@[to_additive]\ntheorem inv_div_left : a⁻¹ / b = (b * a)⁻¹ := by simp\n\n"}
{"name":"neg_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\n⊢ Eq (Neg.neg (HSub.hSub a b)) (HSub.hSub b a)","decl":"@[to_additive (attr := simp)]\ntheorem inv_div : (a / b)⁻¹ = b / a := by simp\n\n"}
{"name":"inv_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\n⊢ Eq (Inv.inv (HDiv.hDiv a b)) (HDiv.hDiv b a)","decl":"@[to_additive (attr := simp)]\ntheorem inv_div : (a / b)⁻¹ = b / a := by simp\n\n"}
{"name":"zero_sub_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\n⊢ Eq (HSub.hSub 0 (HSub.hSub a b)) (HSub.hSub b a)","decl":"@[to_additive]\ntheorem one_div_div : 1 / (a / b) = b / a := by simp\n\n"}
{"name":"one_div_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\n⊢ Eq (HDiv.hDiv 1 (HDiv.hDiv a b)) (HDiv.hDiv b a)","decl":"@[to_additive]\ntheorem one_div_div : 1 / (a / b) = b / a := by simp\n\n"}
{"name":"zero_sub_zero_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na : α\n⊢ Eq (HSub.hSub 0 (HSub.hSub 0 a)) a","decl":"@[to_additive]\ntheorem one_div_one_div : 1 / (1 / a) = a := by simp\n\n"}
{"name":"one_div_one_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na : α\n⊢ Eq (HDiv.hDiv 1 (HDiv.hDiv 1 a)) a","decl":"@[to_additive]\ntheorem one_div_one_div : 1 / (1 / a) = a := by simp\n\n"}
{"name":"div_eq_div_iff_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b c d : α\n⊢ Iff (Eq (HDiv.hDiv a b) (HDiv.hDiv c d)) (Eq (HDiv.hDiv b a) (HDiv.hDiv d c))","decl":"@[to_additive]\ntheorem div_eq_div_iff_comm : a / b = c / d ↔ b / a = d / c :=\n  inv_inj.symm.trans <| by simp only [inv_div]\n\n"}
{"name":"sub_eq_sub_iff_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b c d : α\n⊢ Iff (Eq (HSub.hSub a b) (HSub.hSub c d)) (Eq (HSub.hSub b a) (HSub.hSub d c))","decl":"@[to_additive]\ntheorem div_eq_div_iff_comm : a / b = c / d ↔ b / a = d / c :=\n  inv_inj.symm.trans <| by simp only [inv_div]\n\n"}
{"name":"neg_nsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na : α\nn : Nat\n⊢ Eq (HSMul.hSMul n (Neg.neg a)) (Neg.neg (HSMul.hSMul n a))","decl":"@[to_additive (attr := simp)]\nlemma inv_pow (a : α) : ∀ n : ℕ, a⁻¹ ^ n = (a ^ n)⁻¹\n  | 0 => by rw [pow_zero, pow_zero, inv_one]\n  | n + 1 => by rw [pow_succ', pow_succ, inv_pow _ n, mul_inv_rev]\n\n-- the attributes are intentionally out of order. `smul_zero` proves `zsmul_zero`.\n"}
{"name":"inv_pow","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na : α\nn : Nat\n⊢ Eq (HPow.hPow (Inv.inv a) n) (Inv.inv (HPow.hPow a n))","decl":"@[to_additive (attr := simp)]\nlemma inv_pow (a : α) : ∀ n : ℕ, a⁻¹ ^ n = (a ^ n)⁻¹\n  | 0 => by rw [pow_zero, pow_zero, inv_one]\n  | n + 1 => by rw [pow_succ', pow_succ, inv_pow _ n, mul_inv_rev]\n\n-- the attributes are intentionally out of order. `smul_zero` proves `zsmul_zero`.\n"}
{"name":"one_zpow","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\nn : Int\n⊢ Eq (HPow.hPow 1 n) 1","decl":"@[to_additive zsmul_zero, simp]\nlemma one_zpow : ∀ n : ℤ, (1 : α) ^ n = 1\n  | (n : ℕ)    => by rw [zpow_natCast, one_pow]\n  | .negSucc n => by rw [zpow_negSucc, one_pow, inv_one]\n\n"}
{"name":"zsmul_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\nn : Int\n⊢ Eq (HSMul.hSMul n 0) 0","decl":"@[to_additive zsmul_zero, simp]\nlemma one_zpow : ∀ n : ℤ, (1 : α) ^ n = 1\n  | (n : ℕ)    => by rw [zpow_natCast, one_pow]\n  | .negSucc n => by rw [zpow_negSucc, one_pow, inv_one]\n\n"}
{"name":"zpow_neg","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na : α\nn : Int\n⊢ Eq (HPow.hPow a (Neg.neg n)) (Inv.inv (HPow.hPow a n))","decl":"@[to_additive (attr := simp) neg_zsmul]\nlemma zpow_neg (a : α) : ∀ n : ℤ, a ^ (-n) = (a ^ n)⁻¹\n  | (_ + 1 : ℕ) => DivInvMonoid.zpow_neg' _ _\n  | 0 => by\n    change a ^ (0 : ℤ) = (a ^ (0 : ℤ))⁻¹\n    simp\n  | Int.negSucc n => by\n    rw [zpow_negSucc, inv_inv, ← zpow_natCast]\n    rfl\n\n"}
{"name":"neg_zsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na : α\nn : Int\n⊢ Eq (HSMul.hSMul (Neg.neg n) a) (Neg.neg (HSMul.hSMul n a))","decl":"@[to_additive (attr := simp) neg_zsmul]\nlemma zpow_neg (a : α) : ∀ n : ℤ, a ^ (-n) = (a ^ n)⁻¹\n  | (_ + 1 : ℕ) => DivInvMonoid.zpow_neg' _ _\n  | 0 => by\n    change a ^ (0 : ℤ) = (a ^ (0 : ℤ))⁻¹\n    simp\n  | Int.negSucc n => by\n    rw [zpow_negSucc, inv_inv, ← zpow_natCast]\n    rfl\n\n"}
{"name":"mul_zpow_neg_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\n⊢ Eq (HPow.hPow (HMul.hMul a b) (-1)) (HMul.hMul (HPow.hPow b (-1)) (HPow.hPow a (-1)))","decl":"@[to_additive neg_one_zsmul_add]\nlemma mul_zpow_neg_one (a b : α) : (a * b) ^ (-1 : ℤ) = b ^ (-1 : ℤ) * a ^ (-1 : ℤ) := by\n  simp only [zpow_neg, zpow_one, mul_inv_rev]\n\n"}
{"name":"neg_one_zsmul_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\n⊢ Eq (HSMul.hSMul (-1) (HAdd.hAdd a b)) (HAdd.hAdd (HSMul.hSMul (-1) b) (HSMul.hSMul (-1) a))","decl":"@[to_additive neg_one_zsmul_add]\nlemma mul_zpow_neg_one (a b : α) : (a * b) ^ (-1 : ℤ) = b ^ (-1 : ℤ) * a ^ (-1 : ℤ) := by\n  simp only [zpow_neg, zpow_one, mul_inv_rev]\n\n"}
{"name":"inv_zpow","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na : α\nn : Int\n⊢ Eq (HPow.hPow (Inv.inv a) n) (Inv.inv (HPow.hPow a n))","decl":"@[to_additive zsmul_neg]\nlemma inv_zpow (a : α) : ∀ n : ℤ, a⁻¹ ^ n = (a ^ n)⁻¹\n  | (n : ℕ)    => by rw [zpow_natCast, zpow_natCast, inv_pow]\n  | .negSucc n => by rw [zpow_negSucc, zpow_negSucc, inv_pow]\n\n"}
{"name":"zsmul_neg","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na : α\nn : Int\n⊢ Eq (HSMul.hSMul n (Neg.neg a)) (Neg.neg (HSMul.hSMul n a))","decl":"@[to_additive zsmul_neg]\nlemma inv_zpow (a : α) : ∀ n : ℤ, a⁻¹ ^ n = (a ^ n)⁻¹\n  | (n : ℕ)    => by rw [zpow_natCast, zpow_natCast, inv_pow]\n  | .negSucc n => by rw [zpow_negSucc, zpow_negSucc, inv_pow]\n\n"}
{"name":"inv_zpow'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na : α\nn : Int\n⊢ Eq (HPow.hPow (Inv.inv a) n) (HPow.hPow a (Neg.neg n))","decl":"@[to_additive (attr := simp) zsmul_neg']\nlemma inv_zpow' (a : α) (n : ℤ) : a⁻¹ ^ n = a ^ (-n) := by rw [inv_zpow, zpow_neg]\n\n"}
{"name":"zsmul_neg'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na : α\nn : Int\n⊢ Eq (HSMul.hSMul n (Neg.neg a)) (HSMul.hSMul (Neg.neg n) a)","decl":"@[to_additive (attr := simp) zsmul_neg']\nlemma inv_zpow' (a : α) (n : ℤ) : a⁻¹ ^ n = a ^ (-n) := by rw [inv_zpow, zpow_neg]\n\n"}
{"name":"nsmul_zero_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na : α\nn : Nat\n⊢ Eq (HSMul.hSMul n (HSub.hSub 0 a)) (HSub.hSub 0 (HSMul.hSMul n a))","decl":"@[to_additive nsmul_zero_sub]\nlemma one_div_pow (a : α) (n : ℕ) : (1 / a) ^ n = 1 / a ^ n := by simp only [one_div, inv_pow]\n\n"}
{"name":"one_div_pow","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na : α\nn : Nat\n⊢ Eq (HPow.hPow (HDiv.hDiv 1 a) n) (HDiv.hDiv 1 (HPow.hPow a n))","decl":"@[to_additive nsmul_zero_sub]\nlemma one_div_pow (a : α) (n : ℕ) : (1 / a) ^ n = 1 / a ^ n := by simp only [one_div, inv_pow]\n\n"}
{"name":"one_div_zpow","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na : α\nn : Int\n⊢ Eq (HPow.hPow (HDiv.hDiv 1 a) n) (HDiv.hDiv 1 (HPow.hPow a n))","decl":"@[to_additive zsmul_zero_sub]\nlemma one_div_zpow (a : α) (n : ℤ) : (1 / a) ^ n = 1 / a ^ n := by simp only [one_div, inv_zpow]\n\n"}
{"name":"zsmul_zero_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na : α\nn : Int\n⊢ Eq (HSMul.hSMul n (HSub.hSub 0 a)) (HSub.hSub 0 (HSMul.hSMul n a))","decl":"@[to_additive zsmul_zero_sub]\nlemma one_div_zpow (a : α) (n : ℤ) : (1 / a) ^ n = 1 / a ^ n := by simp only [one_div, inv_zpow]\n\n"}
{"name":"inv_eq_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na : α\n⊢ Iff (Eq (Inv.inv a) 1) (Eq a 1)","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_one : a⁻¹ = 1 ↔ a = 1 :=\n  inv_injective.eq_iff' inv_one\n\n"}
{"name":"neg_eq_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na : α\n⊢ Iff (Eq (Neg.neg a) 0) (Eq a 0)","decl":"@[to_additive (attr := simp)]\ntheorem inv_eq_one : a⁻¹ = 1 ↔ a = 1 :=\n  inv_injective.eq_iff' inv_one\n\n"}
{"name":"one_eq_inv","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na : α\n⊢ Iff (Eq 1 (Inv.inv a)) (Eq a 1)","decl":"@[to_additive (attr := simp)]\ntheorem one_eq_inv : 1 = a⁻¹ ↔ a = 1 :=\n  eq_comm.trans inv_eq_one\n\n"}
{"name":"zero_eq_neg","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na : α\n⊢ Iff (Eq 0 (Neg.neg a)) (Eq a 0)","decl":"@[to_additive (attr := simp)]\ntheorem one_eq_inv : 1 = a⁻¹ ↔ a = 1 :=\n  eq_comm.trans inv_eq_one\n\n"}
{"name":"inv_ne_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na : α\n⊢ Iff (Ne (Inv.inv a) 1) (Ne a 1)","decl":"@[to_additive]\ntheorem inv_ne_one : a⁻¹ ≠ 1 ↔ a ≠ 1 :=\n  inv_eq_one.not\n\n"}
{"name":"neg_ne_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na : α\n⊢ Iff (Ne (Neg.neg a) 0) (Ne a 0)","decl":"@[to_additive]\ntheorem inv_ne_one : a⁻¹ ≠ 1 ↔ a ≠ 1 :=\n  inv_eq_one.not\n\n"}
{"name":"eq_of_zero_sub_eq_zero_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\nh : Eq (HSub.hSub 0 a) (HSub.hSub 0 b)\n⊢ Eq a b","decl":"@[to_additive]\ntheorem eq_of_one_div_eq_one_div (h : 1 / a = 1 / b) : a = b := by\n  rw [← one_div_one_div a, h, one_div_one_div]\n\n-- Note that `mul_zsmul` and `zpow_mul` have the primes swapped\n-- when additivised since their argument order,\n-- and therefore the more \"natural\" choice of lemma, is reversed.\n"}
{"name":"eq_of_one_div_eq_one_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\nh : Eq (HDiv.hDiv 1 a) (HDiv.hDiv 1 b)\n⊢ Eq a b","decl":"@[to_additive]\ntheorem eq_of_one_div_eq_one_div (h : 1 / a = 1 / b) : a = b := by\n  rw [← one_div_one_div a, h, one_div_one_div]\n\n-- Note that `mul_zsmul` and `zpow_mul` have the primes swapped\n-- when additivised since their argument order,\n-- and therefore the more \"natural\" choice of lemma, is reversed.\n"}
{"name":"mul_zsmul'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na : α\nm n : Int\n⊢ Eq (HSMul.hSMul (HMul.hMul m n) a) (HSMul.hSMul n (HSMul.hSMul m a))","decl":"@[to_additive mul_zsmul'] lemma zpow_mul (a : α) : ∀ m n : ℤ, a ^ (m * n) = (a ^ m) ^ n\n  | (m : ℕ), (n : ℕ) => by\n    rw [zpow_natCast, zpow_natCast, ← pow_mul, ← zpow_natCast]\n    rfl\n  | (m : ℕ), .negSucc n => by\n    rw [zpow_natCast, zpow_negSucc, ← pow_mul, Int.ofNat_mul_negSucc, zpow_neg, inv_inj,\n      ← zpow_natCast]\n  | .negSucc m, (n : ℕ) => by\n    rw [zpow_natCast, zpow_negSucc, ← inv_pow, ← pow_mul, Int.negSucc_mul_ofNat, zpow_neg, inv_pow,\n      inv_inj, ← zpow_natCast]\n  | .negSucc m, .negSucc n => by\n    rw [zpow_negSucc, zpow_negSucc, Int.negSucc_mul_negSucc, inv_pow, inv_inv, ← pow_mul, ←\n      zpow_natCast]\n    rfl\n\n"}
{"name":"zpow_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na : α\nm n : Int\n⊢ Eq (HPow.hPow a (HMul.hMul m n)) (HPow.hPow (HPow.hPow a m) n)","decl":"@[to_additive mul_zsmul'] lemma zpow_mul (a : α) : ∀ m n : ℤ, a ^ (m * n) = (a ^ m) ^ n\n  | (m : ℕ), (n : ℕ) => by\n    rw [zpow_natCast, zpow_natCast, ← pow_mul, ← zpow_natCast]\n    rfl\n  | (m : ℕ), .negSucc n => by\n    rw [zpow_natCast, zpow_negSucc, ← pow_mul, Int.ofNat_mul_negSucc, zpow_neg, inv_inj,\n      ← zpow_natCast]\n  | .negSucc m, (n : ℕ) => by\n    rw [zpow_natCast, zpow_negSucc, ← inv_pow, ← pow_mul, Int.negSucc_mul_ofNat, zpow_neg, inv_pow,\n      inv_inj, ← zpow_natCast]\n  | .negSucc m, .negSucc n => by\n    rw [zpow_negSucc, zpow_negSucc, Int.negSucc_mul_negSucc, inv_pow, inv_inv, ← pow_mul, ←\n      zpow_natCast]\n    rfl\n\n"}
{"name":"mul_zsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na : α\nm n : Int\n⊢ Eq (HSMul.hSMul (HMul.hMul m n) a) (HSMul.hSMul m (HSMul.hSMul n a))","decl":"@[to_additive mul_zsmul]\nlemma zpow_mul' (a : α) (m n : ℤ) : a ^ (m * n) = (a ^ n) ^ m := by rw [Int.mul_comm, zpow_mul]\n\n"}
{"name":"zpow_mul'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na : α\nm n : Int\n⊢ Eq (HPow.hPow a (HMul.hMul m n)) (HPow.hPow (HPow.hPow a n) m)","decl":"@[to_additive mul_zsmul]\nlemma zpow_mul' (a : α) (m n : ℤ) : a ^ (m * n) = (a ^ n) ^ m := by rw [Int.mul_comm, zpow_mul]\n\n"}
{"name":"div_div_eq_mul_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b c : α\n⊢ Eq (HDiv.hDiv a (HDiv.hDiv b c)) (HDiv.hDiv (HMul.hMul a c) b)","decl":"@[to_additive, field_simps] -- The attributes are out of order on purpose\ntheorem div_div_eq_mul_div : a / (b / c) = a * c / b := by simp\n\n"}
{"name":"sub_sub_eq_add_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b c : α\n⊢ Eq (HSub.hSub a (HSub.hSub b c)) (HSub.hSub (HAdd.hAdd a c) b)","decl":"@[to_additive, field_simps] -- The attributes are out of order on purpose\ntheorem div_div_eq_mul_div : a / (b / c) = a * c / b := by simp\n\n"}
{"name":"sub_neg_eq_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b : α\n⊢ Eq (HSub.hSub a (Neg.neg b)) (HAdd.hAdd a b)","decl":"@[to_additive (attr := simp)]\ntheorem div_inv_eq_mul : a / b⁻¹ = a * b := by simp\n\n"}
{"name":"div_inv_eq_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b : α\n⊢ Eq (HDiv.hDiv a (Inv.inv b)) (HMul.hMul a b)","decl":"@[to_additive (attr := simp)]\ntheorem div_inv_eq_mul : a / b⁻¹ = a * b := by simp\n\n"}
{"name":"sub_add_eq_sub_sub_swap","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\na b c : α\n⊢ Eq (HSub.hSub a (HAdd.hAdd b c)) (HSub.hSub (HSub.hSub a c) b)","decl":"@[to_additive]\ntheorem div_mul_eq_div_div_swap : a / (b * c) = a / c / b := by\n  simp only [mul_assoc, mul_inv_rev, div_eq_mul_inv]\n\n"}
{"name":"div_mul_eq_div_div_swap","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\na b c : α\n⊢ Eq (HDiv.hDiv a (HMul.hMul b c)) (HDiv.hDiv (HDiv.hDiv a c) b)","decl":"@[to_additive]\ntheorem div_mul_eq_div_div_swap : a / (b * c) = a / c / b := by\n  simp only [mul_assoc, mul_inv_rev, div_eq_mul_inv]\n\n"}
{"name":"mul_inv","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b : α\n⊢ Eq (Inv.inv (HMul.hMul a b)) (HMul.hMul (Inv.inv a) (Inv.inv b))","decl":"@[to_additive neg_add]\ntheorem mul_inv : (a * b)⁻¹ = a⁻¹ * b⁻¹ := by simp\n\n"}
{"name":"neg_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b : α\n⊢ Eq (Neg.neg (HAdd.hAdd a b)) (HAdd.hAdd (Neg.neg a) (Neg.neg b))","decl":"@[to_additive neg_add]\ntheorem mul_inv : (a * b)⁻¹ = a⁻¹ * b⁻¹ := by simp\n\n"}
{"name":"inv_div'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b : α\n⊢ Eq (Inv.inv (HDiv.hDiv a b)) (HDiv.hDiv (Inv.inv a) (Inv.inv b))","decl":"@[to_additive]\ntheorem inv_div' : (a / b)⁻¹ = a⁻¹ / b⁻¹ := by simp\n\n"}
{"name":"neg_sub'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b : α\n⊢ Eq (Neg.neg (HSub.hSub a b)) (HSub.hSub (Neg.neg a) (Neg.neg b))","decl":"@[to_additive]\ntheorem inv_div' : (a / b)⁻¹ = a⁻¹ / b⁻¹ := by simp\n\n"}
{"name":"sub_eq_neg_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b : α\n⊢ Eq (HSub.hSub a b) (HAdd.hAdd (Neg.neg b) a)","decl":"@[to_additive]\ntheorem div_eq_inv_mul : a / b = b⁻¹ * a := by simp\n\n"}
{"name":"div_eq_inv_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b : α\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul (Inv.inv b) a)","decl":"@[to_additive]\ntheorem div_eq_inv_mul : a / b = b⁻¹ * a := by simp\n\n"}
{"name":"inv_mul_eq_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b : α\n⊢ Eq (HMul.hMul (Inv.inv a) b) (HDiv.hDiv b a)","decl":"@[to_additive]\ntheorem inv_mul_eq_div : a⁻¹ * b = b / a := by simp\n\n"}
{"name":"neg_add_eq_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b : α\n⊢ Eq (HAdd.hAdd (Neg.neg a) b) (HSub.hSub b a)","decl":"@[to_additive]\ntheorem inv_mul_eq_div : a⁻¹ * b = b / a := by simp\n\n"}
{"name":"inv_div_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b : α\n⊢ Eq (HDiv.hDiv (Inv.inv a) b) (HDiv.hDiv (Inv.inv b) a)","decl":"@[to_additive] lemma inv_div_comm (a b : α) : a⁻¹ / b = b⁻¹ / a := by simp\n\n"}
{"name":"neg_sub_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b : α\n⊢ Eq (HSub.hSub (Neg.neg a) b) (HSub.hSub (Neg.neg b) a)","decl":"@[to_additive] lemma inv_div_comm (a b : α) : a⁻¹ / b = b⁻¹ / a := by simp\n\n"}
{"name":"neg_add'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b : α\n⊢ Eq (Neg.neg (HAdd.hAdd a b)) (HSub.hSub (Neg.neg a) b)","decl":"@[to_additive]\ntheorem inv_mul' : (a * b)⁻¹ = a⁻¹ / b := by simp\n\n"}
{"name":"inv_mul'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b : α\n⊢ Eq (Inv.inv (HMul.hMul a b)) (HDiv.hDiv (Inv.inv a) b)","decl":"@[to_additive]\ntheorem inv_mul' : (a * b)⁻¹ = a⁻¹ / b := by simp\n\n"}
{"name":"inv_div_inv","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b : α\n⊢ Eq (HDiv.hDiv (Inv.inv a) (Inv.inv b)) (HDiv.hDiv b a)","decl":"@[to_additive]\ntheorem inv_div_inv : a⁻¹ / b⁻¹ = b / a := by simp\n\n"}
{"name":"neg_sub_neg","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b : α\n⊢ Eq (HSub.hSub (Neg.neg a) (Neg.neg b)) (HSub.hSub b a)","decl":"@[to_additive]\ntheorem inv_div_inv : a⁻¹ / b⁻¹ = b / a := by simp\n\n"}
{"name":"inv_inv_div_inv","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b : α\n⊢ Eq (Inv.inv (HDiv.hDiv (Inv.inv a) (Inv.inv b))) (HDiv.hDiv a b)","decl":"@[to_additive]\ntheorem inv_inv_div_inv : (a⁻¹ / b⁻¹)⁻¹ = a / b := by simp\n\n"}
{"name":"neg_neg_sub_neg","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b : α\n⊢ Eq (Neg.neg (HSub.hSub (Neg.neg a) (Neg.neg b))) (HSub.hSub a b)","decl":"@[to_additive]\ntheorem inv_inv_div_inv : (a⁻¹ / b⁻¹)⁻¹ = a / b := by simp\n\n"}
{"name":"zero_sub_add_zero_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b : α\n⊢ Eq (HAdd.hAdd (HSub.hSub 0 a) (HSub.hSub 0 b)) (HSub.hSub 0 (HAdd.hAdd a b))","decl":"@[to_additive]\ntheorem one_div_mul_one_div : 1 / a * (1 / b) = 1 / (a * b) := by simp\n\n"}
{"name":"one_div_mul_one_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b : α\n⊢ Eq (HMul.hMul (HDiv.hDiv 1 a) (HDiv.hDiv 1 b)) (HDiv.hDiv 1 (HMul.hMul a b))","decl":"@[to_additive]\ntheorem one_div_mul_one_div : 1 / a * (1 / b) = 1 / (a * b) := by simp\n\n"}
{"name":"div_right_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c : α\n⊢ Eq (HDiv.hDiv (HDiv.hDiv a b) c) (HDiv.hDiv (HDiv.hDiv a c) b)","decl":"@[to_additive]\ntheorem div_right_comm : a / b / c = a / c / b := by simp\n\n"}
{"name":"sub_right_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c : α\n⊢ Eq (HSub.hSub (HSub.hSub a b) c) (HSub.hSub (HSub.hSub a c) b)","decl":"@[to_additive]\ntheorem div_right_comm : a / b / c = a / c / b := by simp\n\n"}
{"name":"div_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c : α\n⊢ Eq (HDiv.hDiv (HDiv.hDiv a b) c) (HDiv.hDiv a (HMul.hMul b c))","decl":"@[to_additive, field_simps]\ntheorem div_div : a / b / c = a / (b * c) := by simp\n\n"}
{"name":"sub_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c : α\n⊢ Eq (HSub.hSub (HSub.hSub a b) c) (HSub.hSub a (HAdd.hAdd b c))","decl":"@[to_additive, field_simps]\ntheorem div_div : a / b / c = a / (b * c) := by simp\n\n"}
{"name":"sub_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c : α\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) c) (HSub.hSub a (HSub.hSub b c))","decl":"@[to_additive]\ntheorem div_mul : a / b * c = a / (b / c) := by simp\n\n"}
{"name":"div_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c : α\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) c) (HDiv.hDiv a (HDiv.hDiv b c))","decl":"@[to_additive]\ntheorem div_mul : a / b * c = a / (b / c) := by simp\n\n"}
{"name":"add_sub_left_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c : α\n⊢ Eq (HAdd.hAdd a (HSub.hSub b c)) (HAdd.hAdd b (HSub.hSub a c))","decl":"@[to_additive]\ntheorem mul_div_left_comm : a * (b / c) = b * (a / c) := by simp\n\n"}
{"name":"mul_div_left_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c : α\n⊢ Eq (HMul.hMul a (HDiv.hDiv b c)) (HMul.hMul b (HDiv.hDiv a c))","decl":"@[to_additive]\ntheorem mul_div_left_comm : a * (b / c) = b * (a / c) := by simp\n\n"}
{"name":"mul_div_right_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c : α\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) c) (HMul.hMul (HDiv.hDiv a c) b)","decl":"@[to_additive]\ntheorem mul_div_right_comm : a * b / c = a / c * b := by simp\n\n"}
{"name":"add_sub_right_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c : α\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) c) (HAdd.hAdd (HSub.hSub a c) b)","decl":"@[to_additive]\ntheorem mul_div_right_comm : a * b / c = a / c * b := by simp\n\n"}
{"name":"div_mul_eq_div_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c : α\n⊢ Eq (HDiv.hDiv a (HMul.hMul b c)) (HDiv.hDiv (HDiv.hDiv a b) c)","decl":"@[to_additive]\ntheorem div_mul_eq_div_div : a / (b * c) = a / b / c := by simp\n\n"}
{"name":"sub_add_eq_sub_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c : α\n⊢ Eq (HSub.hSub a (HAdd.hAdd b c)) (HSub.hSub (HSub.hSub a b) c)","decl":"@[to_additive]\ntheorem div_mul_eq_div_div : a / (b * c) = a / b / c := by simp\n\n"}
{"name":"div_mul_eq_mul_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c : α\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) c) (HDiv.hDiv (HMul.hMul a c) b)","decl":"@[to_additive, field_simps]\ntheorem div_mul_eq_mul_div : a / b * c = a * c / b := by simp\n\n"}
{"name":"sub_add_eq_add_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c : α\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) c) (HSub.hSub (HAdd.hAdd a c) b)","decl":"@[to_additive, field_simps]\ntheorem div_mul_eq_mul_div : a / b * c = a * c / b := by simp\n\n"}
{"name":"one_div_mul_eq_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b : α\n⊢ Eq (HMul.hMul (HDiv.hDiv 1 a) b) (HDiv.hDiv b a)","decl":"@[to_additive]\ntheorem one_div_mul_eq_div : 1 / a * b = b / a := by simp\n\n"}
{"name":"zero_sub_add_eq_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b : α\n⊢ Eq (HAdd.hAdd (HSub.hSub 0 a) b) (HSub.hSub b a)","decl":"@[to_additive]\ntheorem one_div_mul_eq_div : 1 / a * b = b / a := by simp\n\n"}
{"name":"add_comm_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c : α\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) c) (HAdd.hAdd a (HSub.hSub c b))","decl":"@[to_additive]\ntheorem mul_comm_div : a / b * c = a * (c / b) := by simp\n\n"}
{"name":"mul_comm_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c : α\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) c) (HMul.hMul a (HDiv.hDiv c b))","decl":"@[to_additive]\ntheorem mul_comm_div : a / b * c = a * (c / b) := by simp\n\n"}
{"name":"sub_add_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c : α\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) c) (HAdd.hAdd (HSub.hSub c b) a)","decl":"@[to_additive]\ntheorem div_mul_comm : a / b * c = c / b * a := by simp\n\n"}
{"name":"div_mul_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c : α\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) c) (HMul.hMul (HDiv.hDiv c b) a)","decl":"@[to_additive]\ntheorem div_mul_comm : a / b * c = c / b * a := by simp\n\n"}
{"name":"sub_add_eq_sub_add_zero_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c : α\n⊢ Eq (HSub.hSub a (HAdd.hAdd b c)) (HAdd.hAdd (HSub.hSub a b) (HSub.hSub 0 c))","decl":"@[to_additive]\ntheorem div_mul_eq_div_mul_one_div : a / (b * c) = a / b * (1 / c) := by simp\n\n"}
{"name":"div_mul_eq_div_mul_one_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c : α\n⊢ Eq (HDiv.hDiv a (HMul.hMul b c)) (HMul.hMul (HDiv.hDiv a b) (HDiv.hDiv 1 c))","decl":"@[to_additive]\ntheorem div_mul_eq_div_mul_one_div : a / (b * c) = a / b * (1 / c) := by simp\n\n"}
{"name":"sub_sub_sub_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c d : α\n⊢ Eq (HSub.hSub (HSub.hSub a b) (HSub.hSub c d)) (HSub.hSub (HAdd.hAdd a d) (HAdd.hAdd b c))","decl":"@[to_additive]\ntheorem div_div_div_eq : a / b / (c / d) = a * d / (b * c) := by simp\n\n"}
{"name":"div_div_div_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c d : α\n⊢ Eq (HDiv.hDiv (HDiv.hDiv a b) (HDiv.hDiv c d)) (HDiv.hDiv (HMul.hMul a d) (HMul.hMul b c))","decl":"@[to_additive]\ntheorem div_div_div_eq : a / b / (c / d) = a * d / (b * c) := by simp\n\n"}
{"name":"sub_sub_sub_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c d : α\n⊢ Eq (HSub.hSub (HSub.hSub a b) (HSub.hSub c d)) (HSub.hSub (HSub.hSub a c) (HSub.hSub b d))","decl":"@[to_additive]\ntheorem div_div_div_comm : a / b / (c / d) = a / c / (b / d) := by simp\n\n"}
{"name":"div_div_div_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c d : α\n⊢ Eq (HDiv.hDiv (HDiv.hDiv a b) (HDiv.hDiv c d)) (HDiv.hDiv (HDiv.hDiv a c) (HDiv.hDiv b d))","decl":"@[to_additive]\ntheorem div_div_div_comm : a / b / (c / d) = a / c / (b / d) := by simp\n\n"}
{"name":"div_mul_div_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c d : α\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) (HDiv.hDiv c d)) (HDiv.hDiv (HMul.hMul a c) (HMul.hMul b d))","decl":"@[to_additive]\ntheorem div_mul_div_comm : a / b * (c / d) = a * c / (b * d) := by simp\n\n"}
{"name":"sub_add_sub_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c d : α\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) (HSub.hSub c d)) (HSub.hSub (HAdd.hAdd a c) (HAdd.hAdd b d))","decl":"@[to_additive]\ntheorem div_mul_div_comm : a / b * (c / d) = a * c / (b * d) := by simp\n\n"}
{"name":"add_sub_add_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b c d : α\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) (HAdd.hAdd c d)) (HAdd.hAdd (HSub.hSub a c) (HSub.hSub b d))","decl":"@[to_additive]\ntheorem mul_div_mul_comm : a * b / (c * d) = a / c * (b / d) := by simp\n\n"}
{"name":"mul_div_mul_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b c d : α\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) (HMul.hMul c d)) (HMul.hMul (HDiv.hDiv a c) (HDiv.hDiv b d))","decl":"@[to_additive]\ntheorem mul_div_mul_comm : a * b / (c * d) = a / c * (b / d) := by simp\n\n"}
{"name":"mul_zpow","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b : α\nn : Int\n⊢ Eq (HPow.hPow (HMul.hMul a b) n) (HMul.hMul (HPow.hPow a n) (HPow.hPow b n))","decl":"@[to_additive zsmul_add] lemma mul_zpow : ∀ n : ℤ, (a * b) ^ n = a ^ n * b ^ n\n  | (n : ℕ) => by simp_rw [zpow_natCast, mul_pow]\n  | .negSucc n => by simp_rw [zpow_negSucc, ← inv_pow, mul_inv, mul_pow]\n\n"}
{"name":"zsmul_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b : α\nn : Int\n⊢ Eq (HSMul.hSMul n (HAdd.hAdd a b)) (HAdd.hAdd (HSMul.hSMul n a) (HSMul.hSMul n b))","decl":"@[to_additive zsmul_add] lemma mul_zpow : ∀ n : ℤ, (a * b) ^ n = a ^ n * b ^ n\n  | (n : ℕ) => by simp_rw [zpow_natCast, mul_pow]\n  | .negSucc n => by simp_rw [zpow_negSucc, ← inv_pow, mul_inv, mul_pow]\n\n"}
{"name":"nsmul_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b : α\nn : Nat\n⊢ Eq (HSMul.hSMul n (HSub.hSub a b)) (HSub.hSub (HSMul.hSMul n a) (HSMul.hSMul n b))","decl":"@[to_additive nsmul_sub]\nlemma div_pow (a b : α) (n : ℕ) : (a / b) ^ n = a ^ n / b ^ n := by\n  simp only [div_eq_mul_inv, mul_pow, inv_pow]\n\n"}
{"name":"div_pow","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b : α\nn : Nat\n⊢ Eq (HPow.hPow (HDiv.hDiv a b) n) (HDiv.hDiv (HPow.hPow a n) (HPow.hPow b n))","decl":"@[to_additive nsmul_sub]\nlemma div_pow (a b : α) (n : ℕ) : (a / b) ^ n = a ^ n / b ^ n := by\n  simp only [div_eq_mul_inv, mul_pow, inv_pow]\n\n"}
{"name":"div_zpow","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na b : α\nn : Int\n⊢ Eq (HPow.hPow (HDiv.hDiv a b) n) (HDiv.hDiv (HPow.hPow a n) (HPow.hPow b n))","decl":"@[to_additive zsmul_sub]\nlemma div_zpow (a b : α) (n : ℤ) : (a / b) ^ n = a ^ n / b ^ n := by\n  simp only [div_eq_mul_inv, mul_zpow, inv_zpow]\n\n"}
{"name":"zsmul_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\na b : α\nn : Int\n⊢ Eq (HSMul.hSMul n (HSub.hSub a b)) (HSub.hSub (HSMul.hSMul n a) (HSMul.hSMul n b))","decl":"@[to_additive zsmul_sub]\nlemma div_zpow (a b : α) (n : ℤ) : (a / b) ^ n = a ^ n / b ^ n := by\n  simp only [div_eq_mul_inv, mul_zpow, inv_zpow]\n\n"}
{"name":"div_eq_inv_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Iff (Eq (HDiv.hDiv a b) (Inv.inv b)) (Eq a 1)","decl":"@[to_additive (attr := simp)]\ntheorem div_eq_inv_self : a / b = b⁻¹ ↔ a = 1 := by rw [div_eq_mul_inv, mul_left_eq_self]\n\n"}
{"name":"sub_eq_neg_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Iff (Eq (HSub.hSub a b) (Neg.neg b)) (Eq a 0)","decl":"@[to_additive (attr := simp)]\ntheorem div_eq_inv_self : a / b = b⁻¹ ↔ a = 1 := by rw [div_eq_mul_inv, mul_left_eq_self]\n\n"}
{"name":"add_left_surjective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\n⊢ Function.Surjective fun x => HAdd.hAdd a x","decl":"@[to_additive]\ntheorem mul_left_surjective (a : G) : Surjective (a * ·) :=\n  fun x ↦ ⟨a⁻¹ * x, mul_inv_cancel_left a x⟩\n\n"}
{"name":"mul_left_surjective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\n⊢ Function.Surjective fun x => HMul.hMul a x","decl":"@[to_additive]\ntheorem mul_left_surjective (a : G) : Surjective (a * ·) :=\n  fun x ↦ ⟨a⁻¹ * x, mul_inv_cancel_left a x⟩\n\n"}
{"name":"add_right_surjective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\n⊢ Function.Surjective fun x => HAdd.hAdd x a","decl":"@[to_additive]\ntheorem mul_right_surjective (a : G) : Function.Surjective fun x ↦ x * a := fun x ↦\n  ⟨x * a⁻¹, inv_mul_cancel_right x a⟩\n\n"}
{"name":"mul_right_surjective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\n⊢ Function.Surjective fun x => HMul.hMul x a","decl":"@[to_additive]\ntheorem mul_right_surjective (a : G) : Function.Surjective fun x ↦ x * a := fun x ↦\n  ⟨x * a⁻¹, inv_mul_cancel_right x a⟩\n\n"}
{"name":"eq_add_neg_of_add_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\nh : Eq (HAdd.hAdd a c) b\n⊢ Eq a (HAdd.hAdd b (Neg.neg c))","decl":"@[to_additive]\ntheorem eq_mul_inv_of_mul_eq (h : a * c = b) : a = b * c⁻¹ := by simp [h.symm]\n\n"}
{"name":"eq_mul_inv_of_mul_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\nh : Eq (HMul.hMul a c) b\n⊢ Eq a (HMul.hMul b (Inv.inv c))","decl":"@[to_additive]\ntheorem eq_mul_inv_of_mul_eq (h : a * c = b) : a = b * c⁻¹ := by simp [h.symm]\n\n"}
{"name":"eq_inv_mul_of_mul_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\nh : Eq (HMul.hMul b a) c\n⊢ Eq a (HMul.hMul (Inv.inv b) c)","decl":"@[to_additive]\ntheorem eq_inv_mul_of_mul_eq (h : b * a = c) : a = b⁻¹ * c := by simp [h.symm]\n\n"}
{"name":"eq_neg_add_of_add_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\nh : Eq (HAdd.hAdd b a) c\n⊢ Eq a (HAdd.hAdd (Neg.neg b) c)","decl":"@[to_additive]\ntheorem eq_inv_mul_of_mul_eq (h : b * a = c) : a = b⁻¹ * c := by simp [h.symm]\n\n"}
{"name":"inv_mul_eq_of_eq_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\nh : Eq b (HMul.hMul a c)\n⊢ Eq (HMul.hMul (Inv.inv a) b) c","decl":"@[to_additive]\ntheorem inv_mul_eq_of_eq_mul (h : b = a * c) : a⁻¹ * b = c := by simp [h]\n\n"}
{"name":"neg_add_eq_of_eq_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\nh : Eq b (HAdd.hAdd a c)\n⊢ Eq (HAdd.hAdd (Neg.neg a) b) c","decl":"@[to_additive]\ntheorem inv_mul_eq_of_eq_mul (h : b = a * c) : a⁻¹ * b = c := by simp [h]\n\n"}
{"name":"mul_inv_eq_of_eq_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\nh : Eq a (HMul.hMul c b)\n⊢ Eq (HMul.hMul a (Inv.inv b)) c","decl":"@[to_additive]\ntheorem mul_inv_eq_of_eq_mul (h : a = c * b) : a * b⁻¹ = c := by simp [h]\n\n"}
{"name":"add_neg_eq_of_eq_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\nh : Eq a (HAdd.hAdd c b)\n⊢ Eq (HAdd.hAdd a (Neg.neg b)) c","decl":"@[to_additive]\ntheorem mul_inv_eq_of_eq_mul (h : a = c * b) : a * b⁻¹ = c := by simp [h]\n\n"}
{"name":"eq_add_of_add_neg_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\nh : Eq (HAdd.hAdd a (Neg.neg c)) b\n⊢ Eq a (HAdd.hAdd b c)","decl":"@[to_additive]\ntheorem eq_mul_of_mul_inv_eq (h : a * c⁻¹ = b) : a = b * c := by simp [h.symm]\n\n"}
{"name":"eq_mul_of_mul_inv_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\nh : Eq (HMul.hMul a (Inv.inv c)) b\n⊢ Eq a (HMul.hMul b c)","decl":"@[to_additive]\ntheorem eq_mul_of_mul_inv_eq (h : a * c⁻¹ = b) : a = b * c := by simp [h.symm]\n\n"}
{"name":"eq_add_of_neg_add_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\nh : Eq (HAdd.hAdd (Neg.neg b) a) c\n⊢ Eq a (HAdd.hAdd b c)","decl":"@[to_additive]\ntheorem eq_mul_of_inv_mul_eq (h : b⁻¹ * a = c) : a = b * c := by simp [h.symm, mul_inv_cancel_left]\n\n"}
{"name":"eq_mul_of_inv_mul_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\nh : Eq (HMul.hMul (Inv.inv b) a) c\n⊢ Eq a (HMul.hMul b c)","decl":"@[to_additive]\ntheorem eq_mul_of_inv_mul_eq (h : b⁻¹ * a = c) : a = b * c := by simp [h.symm, mul_inv_cancel_left]\n\n"}
{"name":"add_eq_of_eq_neg_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\nh : Eq b (HAdd.hAdd (Neg.neg a) c)\n⊢ Eq (HAdd.hAdd a b) c","decl":"@[to_additive]\ntheorem mul_eq_of_eq_inv_mul (h : b = a⁻¹ * c) : a * b = c := by rw [h, mul_inv_cancel_left]\n\n"}
{"name":"mul_eq_of_eq_inv_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\nh : Eq b (HMul.hMul (Inv.inv a) c)\n⊢ Eq (HMul.hMul a b) c","decl":"@[to_additive]\ntheorem mul_eq_of_eq_inv_mul (h : b = a⁻¹ * c) : a * b = c := by rw [h, mul_inv_cancel_left]\n\n"}
{"name":"add_eq_of_eq_add_neg","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\nh : Eq a (HAdd.hAdd c (Neg.neg b))\n⊢ Eq (HAdd.hAdd a b) c","decl":"@[to_additive]\ntheorem mul_eq_of_eq_mul_inv (h : a = c * b⁻¹) : a * b = c := by simp [h]\n\n"}
{"name":"mul_eq_of_eq_mul_inv","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\nh : Eq a (HMul.hMul c (Inv.inv b))\n⊢ Eq (HMul.hMul a b) c","decl":"@[to_additive]\ntheorem mul_eq_of_eq_mul_inv (h : a = c * b⁻¹) : a * b = c := by simp [h]\n\n"}
{"name":"add_eq_zero_iff_eq_neg","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Iff (Eq (HAdd.hAdd a b) 0) (Eq a (Neg.neg b))","decl":"@[to_additive]\ntheorem mul_eq_one_iff_eq_inv : a * b = 1 ↔ a = b⁻¹ :=\n  ⟨eq_inv_of_mul_eq_one_left, fun h ↦ by rw [h, inv_mul_cancel]⟩\n\n"}
{"name":"mul_eq_one_iff_eq_inv","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Iff (Eq (HMul.hMul a b) 1) (Eq a (Inv.inv b))","decl":"@[to_additive]\ntheorem mul_eq_one_iff_eq_inv : a * b = 1 ↔ a = b⁻¹ :=\n  ⟨eq_inv_of_mul_eq_one_left, fun h ↦ by rw [h, inv_mul_cancel]⟩\n\n"}
{"name":"mul_eq_one_iff_inv_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Iff (Eq (HMul.hMul a b) 1) (Eq (Inv.inv a) b)","decl":"@[to_additive]\ntheorem mul_eq_one_iff_inv_eq : a * b = 1 ↔ a⁻¹ = b := by\n  rw [mul_eq_one_iff_eq_inv, inv_eq_iff_eq_inv]\n\n"}
{"name":"add_eq_zero_iff_neg_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Iff (Eq (HAdd.hAdd a b) 0) (Eq (Neg.neg a) b)","decl":"@[to_additive]\ntheorem mul_eq_one_iff_inv_eq : a * b = 1 ↔ a⁻¹ = b := by\n  rw [mul_eq_one_iff_eq_inv, inv_eq_iff_eq_inv]\n\n"}
{"name":"mul_eq_one_iff_eq_inv'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Iff (Eq (HMul.hMul a b) 1) (Eq b (Inv.inv a))","decl":"/-- Variant of `mul_eq_one_iff_eq_inv` with swapped equality. -/\n@[to_additive]\ntheorem mul_eq_one_iff_eq_inv' : a * b = 1 ↔ b = a⁻¹ := by\n  rw [mul_eq_one_iff_inv_eq, eq_comm]\n\n"}
{"name":"add_eq_zero_iff_eq_neg'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Iff (Eq (HAdd.hAdd a b) 0) (Eq b (Neg.neg a))","decl":"/-- Variant of `mul_eq_one_iff_eq_inv` with swapped equality. -/\n@[to_additive]\ntheorem mul_eq_one_iff_eq_inv' : a * b = 1 ↔ b = a⁻¹ := by\n  rw [mul_eq_one_iff_inv_eq, eq_comm]\n\n"}
{"name":"add_eq_zero_iff_neg_eq'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Iff (Eq (HAdd.hAdd a b) 0) (Eq (Neg.neg b) a)","decl":"/-- Variant of `mul_eq_one_iff_inv_eq` with swapped equality. -/\n@[to_additive]\ntheorem mul_eq_one_iff_inv_eq' : a * b = 1 ↔ b⁻¹ = a := by\n  rw [mul_eq_one_iff_eq_inv, eq_comm]\n\n"}
{"name":"mul_eq_one_iff_inv_eq'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Iff (Eq (HMul.hMul a b) 1) (Eq (Inv.inv b) a)","decl":"/-- Variant of `mul_eq_one_iff_inv_eq` with swapped equality. -/\n@[to_additive]\ntheorem mul_eq_one_iff_inv_eq' : a * b = 1 ↔ b⁻¹ = a := by\n  rw [mul_eq_one_iff_eq_inv, eq_comm]\n\n"}
{"name":"eq_inv_iff_mul_eq_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Iff (Eq a (Inv.inv b)) (Eq (HMul.hMul a b) 1)","decl":"@[to_additive]\ntheorem eq_inv_iff_mul_eq_one : a = b⁻¹ ↔ a * b = 1 :=\n  mul_eq_one_iff_eq_inv.symm\n\n"}
{"name":"eq_neg_iff_add_eq_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Iff (Eq a (Neg.neg b)) (Eq (HAdd.hAdd a b) 0)","decl":"@[to_additive]\ntheorem eq_inv_iff_mul_eq_one : a = b⁻¹ ↔ a * b = 1 :=\n  mul_eq_one_iff_eq_inv.symm\n\n"}
{"name":"neg_eq_iff_add_eq_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Iff (Eq (Neg.neg a) b) (Eq (HAdd.hAdd a b) 0)","decl":"@[to_additive]\ntheorem inv_eq_iff_mul_eq_one : a⁻¹ = b ↔ a * b = 1 :=\n  mul_eq_one_iff_inv_eq.symm\n\n"}
{"name":"inv_eq_iff_mul_eq_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Iff (Eq (Inv.inv a) b) (Eq (HMul.hMul a b) 1)","decl":"@[to_additive]\ntheorem inv_eq_iff_mul_eq_one : a⁻¹ = b ↔ a * b = 1 :=\n  mul_eq_one_iff_inv_eq.symm\n\n"}
{"name":"eq_mul_inv_iff_mul_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\n⊢ Iff (Eq a (HMul.hMul b (Inv.inv c))) (Eq (HMul.hMul a c) b)","decl":"@[to_additive]\ntheorem eq_mul_inv_iff_mul_eq : a = b * c⁻¹ ↔ a * c = b :=\n  ⟨fun h ↦ by rw [h, inv_mul_cancel_right], fun h ↦ by rw [← h, mul_inv_cancel_right]⟩\n\n"}
{"name":"eq_add_neg_iff_add_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\n⊢ Iff (Eq a (HAdd.hAdd b (Neg.neg c))) (Eq (HAdd.hAdd a c) b)","decl":"@[to_additive]\ntheorem eq_mul_inv_iff_mul_eq : a = b * c⁻¹ ↔ a * c = b :=\n  ⟨fun h ↦ by rw [h, inv_mul_cancel_right], fun h ↦ by rw [← h, mul_inv_cancel_right]⟩\n\n"}
{"name":"eq_inv_mul_iff_mul_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\n⊢ Iff (Eq a (HMul.hMul (Inv.inv b) c)) (Eq (HMul.hMul b a) c)","decl":"@[to_additive]\ntheorem eq_inv_mul_iff_mul_eq : a = b⁻¹ * c ↔ b * a = c :=\n  ⟨fun h ↦ by rw [h, mul_inv_cancel_left], fun h ↦ by rw [← h, inv_mul_cancel_left]⟩\n\n"}
{"name":"eq_neg_add_iff_add_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\n⊢ Iff (Eq a (HAdd.hAdd (Neg.neg b) c)) (Eq (HAdd.hAdd b a) c)","decl":"@[to_additive]\ntheorem eq_inv_mul_iff_mul_eq : a = b⁻¹ * c ↔ b * a = c :=\n  ⟨fun h ↦ by rw [h, mul_inv_cancel_left], fun h ↦ by rw [← h, inv_mul_cancel_left]⟩\n\n"}
{"name":"inv_mul_eq_iff_eq_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\n⊢ Iff (Eq (HMul.hMul (Inv.inv a) b) c) (Eq b (HMul.hMul a c))","decl":"@[to_additive]\ntheorem inv_mul_eq_iff_eq_mul : a⁻¹ * b = c ↔ b = a * c :=\n  ⟨fun h ↦ by rw [← h, mul_inv_cancel_left], fun h ↦ by rw [h, inv_mul_cancel_left]⟩\n\n"}
{"name":"neg_add_eq_iff_eq_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\n⊢ Iff (Eq (HAdd.hAdd (Neg.neg a) b) c) (Eq b (HAdd.hAdd a c))","decl":"@[to_additive]\ntheorem inv_mul_eq_iff_eq_mul : a⁻¹ * b = c ↔ b = a * c :=\n  ⟨fun h ↦ by rw [← h, mul_inv_cancel_left], fun h ↦ by rw [h, inv_mul_cancel_left]⟩\n\n"}
{"name":"add_neg_eq_iff_eq_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\n⊢ Iff (Eq (HAdd.hAdd a (Neg.neg b)) c) (Eq a (HAdd.hAdd c b))","decl":"@[to_additive]\ntheorem mul_inv_eq_iff_eq_mul : a * b⁻¹ = c ↔ a = c * b :=\n  ⟨fun h ↦ by rw [← h, inv_mul_cancel_right], fun h ↦ by rw [h, mul_inv_cancel_right]⟩\n\n"}
{"name":"mul_inv_eq_iff_eq_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\n⊢ Iff (Eq (HMul.hMul a (Inv.inv b)) c) (Eq a (HMul.hMul c b))","decl":"@[to_additive]\ntheorem mul_inv_eq_iff_eq_mul : a * b⁻¹ = c ↔ a = c * b :=\n  ⟨fun h ↦ by rw [← h, inv_mul_cancel_right], fun h ↦ by rw [h, mul_inv_cancel_right]⟩\n\n"}
{"name":"mul_inv_eq_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Iff (Eq (HMul.hMul a (Inv.inv b)) 1) (Eq a b)","decl":"@[to_additive]\ntheorem mul_inv_eq_one : a * b⁻¹ = 1 ↔ a = b := by rw [mul_eq_one_iff_eq_inv, inv_inv]\n\n"}
{"name":"add_neg_eq_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Iff (Eq (HAdd.hAdd a (Neg.neg b)) 0) (Eq a b)","decl":"@[to_additive]\ntheorem mul_inv_eq_one : a * b⁻¹ = 1 ↔ a = b := by rw [mul_eq_one_iff_eq_inv, inv_inv]\n\n"}
{"name":"neg_add_eq_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Iff (Eq (HAdd.hAdd (Neg.neg a) b) 0) (Eq a b)","decl":"@[to_additive]\ntheorem inv_mul_eq_one : a⁻¹ * b = 1 ↔ a = b := by rw [mul_eq_one_iff_eq_inv, inv_inj]\n\n"}
{"name":"inv_mul_eq_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Iff (Eq (HMul.hMul (Inv.inv a) b) 1) (Eq a b)","decl":"@[to_additive]\ntheorem inv_mul_eq_one : a⁻¹ * b = 1 ↔ a = b := by rw [mul_eq_one_iff_eq_inv, inv_inj]\n\n"}
{"name":"conj_eq_one_iff","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Iff (Eq (HMul.hMul (HMul.hMul a b) (Inv.inv a)) 1) (Eq b 1)","decl":"@[to_additive (attr := simp)]\ntheorem conj_eq_one_iff : a * b * a⁻¹ = 1 ↔ b = 1 := by\n  rw [mul_inv_eq_one, mul_right_eq_self]\n\n"}
{"name":"conj_eq_zero_iff","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Iff (Eq (HAdd.hAdd (HAdd.hAdd a b) (Neg.neg a)) 0) (Eq b 0)","decl":"@[to_additive (attr := simp)]\ntheorem conj_eq_one_iff : a * b * a⁻¹ = 1 ↔ b = 1 := by\n  rw [mul_inv_eq_one, mul_right_eq_self]\n\n"}
{"name":"sub_left_injective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nb : G\n⊢ Function.Injective fun a => HSub.hSub a b","decl":"@[to_additive]\ntheorem div_left_injective : Function.Injective fun a ↦ a / b := by\n  -- FIXME this could be by `simpa`, but it fails. This is probably a bug in `simpa`.\n  simp only [div_eq_mul_inv]\n  exact fun a a' h ↦ mul_left_injective b⁻¹ h\n\n"}
{"name":"div_left_injective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\nb : G\n⊢ Function.Injective fun a => HDiv.hDiv a b","decl":"@[to_additive]\ntheorem div_left_injective : Function.Injective fun a ↦ a / b := by\n  -- FIXME this could be by `simpa`, but it fails. This is probably a bug in `simpa`.\n  simp only [div_eq_mul_inv]\n  exact fun a a' h ↦ mul_left_injective b⁻¹ h\n\n"}
{"name":"sub_right_injective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nb : G\n⊢ Function.Injective fun a => HSub.hSub b a","decl":"@[to_additive]\ntheorem div_right_injective : Function.Injective fun a ↦ b / a := by\n  -- FIXME see above\n  simp only [div_eq_mul_inv]\n  exact fun a a' h ↦ inv_injective (mul_right_injective b h)\n\n"}
{"name":"div_right_injective","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\nb : G\n⊢ Function.Injective fun a => HDiv.hDiv b a","decl":"@[to_additive]\ntheorem div_right_injective : Function.Injective fun a ↦ b / a := by\n  -- FIXME see above\n  simp only [div_eq_mul_inv]\n  exact fun a a' h ↦ inv_injective (mul_right_injective b h)\n\n"}
{"name":"div_mul_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) b) a","decl":"@[to_additive (attr := simp)]\ntheorem div_mul_cancel (a b : G) : a / b * b = a := by\n  rw [div_eq_mul_inv, inv_mul_cancel_right a b]\n\n"}
{"name":"sub_add_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) b) a","decl":"@[to_additive (attr := simp)]\ntheorem div_mul_cancel (a b : G) : a / b * b = a := by\n  rw [div_eq_mul_inv, inv_mul_cancel_right a b]\n\n"}
{"name":"div_self'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\n⊢ Eq (HDiv.hDiv a a) 1","decl":"@[to_additive (attr := simp) sub_self]\ntheorem div_self' (a : G) : a / a = 1 := by rw [div_eq_mul_inv, mul_inv_cancel a]\n\n"}
{"name":"sub_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\n⊢ Eq (HSub.hSub a a) 0","decl":"@[to_additive (attr := simp) sub_self]\ntheorem div_self' (a : G) : a / a = 1 := by rw [div_eq_mul_inv, mul_inv_cancel a]\n\n"}
{"name":"add_sub_cancel_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) b) a","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_cancel_right (a b : G) : a * b / b = a := by\n  rw [div_eq_mul_inv, mul_inv_cancel_right a b]\n\n"}
{"name":"mul_div_cancel_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) b) a","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_cancel_right (a b : G) : a * b / b = a := by\n  rw [div_eq_mul_inv, mul_inv_cancel_right a b]\n\n"}
{"name":"sub_add_cancel_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Eq (HSub.hSub a (HAdd.hAdd b a)) (Neg.neg b)","decl":"@[to_additive (attr := simp)]\nlemma div_mul_cancel_right (a b : G) : a / (b * a) = b⁻¹ := by rw [← inv_div, mul_div_cancel_right]\n\n"}
{"name":"div_mul_cancel_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Eq (HDiv.hDiv a (HMul.hMul b a)) (Inv.inv b)","decl":"@[to_additive (attr := simp)]\nlemma div_mul_cancel_right (a b : G) : a / (b * a) = b⁻¹ := by rw [← inv_div, mul_div_cancel_right]\n\n"}
{"name":"add_sub_add_right_eq_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\n⊢ Eq (HSub.hSub (HAdd.hAdd a c) (HAdd.hAdd b c)) (HSub.hSub a b)","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_mul_right_eq_div (a b c : G) : a * c / (b * c) = a / b := by\n  rw [div_mul_eq_div_div_swap]; simp only [mul_left_inj, eq_self_iff_true, mul_div_cancel_right]\n\n"}
{"name":"mul_div_mul_right_eq_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\n⊢ Eq (HDiv.hDiv (HMul.hMul a c) (HMul.hMul b c)) (HDiv.hDiv a b)","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_mul_right_eq_div (a b c : G) : a * c / (b * c) = a / b := by\n  rw [div_mul_eq_div_div_swap]; simp only [mul_left_inj, eq_self_iff_true, mul_div_cancel_right]\n\n"}
{"name":"eq_div_of_mul_eq'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\nh : Eq (HMul.hMul a c) b\n⊢ Eq a (HDiv.hDiv b c)","decl":"@[to_additive eq_sub_of_add_eq]\ntheorem eq_div_of_mul_eq' (h : a * c = b) : a = b / c := by simp [← h]\n\n"}
{"name":"eq_sub_of_add_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\nh : Eq (HAdd.hAdd a c) b\n⊢ Eq a (HSub.hSub b c)","decl":"@[to_additive eq_sub_of_add_eq]\ntheorem eq_div_of_mul_eq' (h : a * c = b) : a = b / c := by simp [← h]\n\n"}
{"name":"div_eq_of_eq_mul''","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\nh : Eq a (HMul.hMul c b)\n⊢ Eq (HDiv.hDiv a b) c","decl":"@[to_additive sub_eq_of_eq_add]\ntheorem div_eq_of_eq_mul'' (h : a = c * b) : a / b = c := by simp [h]\n\n"}
{"name":"sub_eq_of_eq_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\nh : Eq a (HAdd.hAdd c b)\n⊢ Eq (HSub.hSub a b) c","decl":"@[to_additive sub_eq_of_eq_add]\ntheorem div_eq_of_eq_mul'' (h : a = c * b) : a / b = c := by simp [h]\n\n"}
{"name":"eq_add_of_sub_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\nh : Eq (HSub.hSub a c) b\n⊢ Eq a (HAdd.hAdd b c)","decl":"@[to_additive]\ntheorem eq_mul_of_div_eq (h : a / c = b) : a = b * c := by simp [← h]\n\n"}
{"name":"eq_mul_of_div_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\nh : Eq (HDiv.hDiv a c) b\n⊢ Eq a (HMul.hMul b c)","decl":"@[to_additive]\ntheorem eq_mul_of_div_eq (h : a / c = b) : a = b * c := by simp [← h]\n\n"}
{"name":"mul_eq_of_eq_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\nh : Eq a (HDiv.hDiv c b)\n⊢ Eq (HMul.hMul a b) c","decl":"@[to_additive]\ntheorem mul_eq_of_eq_div (h : a = c / b) : a * b = c := by simp [h]\n\n"}
{"name":"add_eq_of_eq_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\nh : Eq a (HSub.hSub c b)\n⊢ Eq (HAdd.hAdd a b) c","decl":"@[to_additive]\ntheorem mul_eq_of_eq_div (h : a = c / b) : a * b = c := by simp [h]\n\n"}
{"name":"div_right_inj","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\n⊢ Iff (Eq (HDiv.hDiv a b) (HDiv.hDiv a c)) (Eq b c)","decl":"@[to_additive (attr := simp)]\ntheorem div_right_inj : a / b = a / c ↔ b = c :=\n  div_right_injective.eq_iff\n\n"}
{"name":"sub_right_inj","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\n⊢ Iff (Eq (HSub.hSub a b) (HSub.hSub a c)) (Eq b c)","decl":"@[to_additive (attr := simp)]\ntheorem div_right_inj : a / b = a / c ↔ b = c :=\n  div_right_injective.eq_iff\n\n"}
{"name":"sub_left_inj","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\n⊢ Iff (Eq (HSub.hSub b a) (HSub.hSub c a)) (Eq b c)","decl":"@[to_additive (attr := simp)]\ntheorem div_left_inj : b / a = c / a ↔ b = c := by\n  rw [div_eq_mul_inv, div_eq_mul_inv]\n  exact mul_left_inj _\n\n"}
{"name":"div_left_inj","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\n⊢ Iff (Eq (HDiv.hDiv b a) (HDiv.hDiv c a)) (Eq b c)","decl":"@[to_additive (attr := simp)]\ntheorem div_left_inj : b / a = c / a ↔ b = c := by\n  rw [div_eq_mul_inv, div_eq_mul_inv]\n  exact mul_left_inj _\n\n"}
{"name":"div_mul_div_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) (HDiv.hDiv b c)) (HDiv.hDiv a c)","decl":"@[to_additive (attr := simp)]\ntheorem div_mul_div_cancel (a b c : G) : a / b * (b / c) = a / c := by\n  rw [← mul_div_assoc, div_mul_cancel]\n\n"}
{"name":"sub_add_sub_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) (HSub.hSub b c)) (HSub.hSub a c)","decl":"@[to_additive (attr := simp)]\ntheorem div_mul_div_cancel (a b c : G) : a / b * (b / c) = a / c := by\n  rw [← mul_div_assoc, div_mul_cancel]\n\n"}
{"name":"div_div_div_cancel_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\n⊢ Eq (HDiv.hDiv (HDiv.hDiv a c) (HDiv.hDiv b c)) (HDiv.hDiv a b)","decl":"@[to_additive (attr := simp)]\ntheorem div_div_div_cancel_right (a b c : G) : a / c / (b / c) = a / b := by\n  rw [← inv_div c b, div_inv_eq_mul, div_mul_div_cancel]\n\n"}
{"name":"sub_sub_sub_cancel_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\n⊢ Eq (HSub.hSub (HSub.hSub a c) (HSub.hSub b c)) (HSub.hSub a b)","decl":"@[to_additive (attr := simp)]\ntheorem div_div_div_cancel_right (a b c : G) : a / c / (b / c) = a / b := by\n  rw [← inv_div c b, div_inv_eq_mul, div_mul_div_cancel]\n\n"}
{"name":"div_div_div_cancel_right'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\n⊢ Eq (HDiv.hDiv (HDiv.hDiv a c) (HDiv.hDiv b c)) (HDiv.hDiv a b)","decl":"@[deprecated (since := \"2024-08-24\")] alias div_div_div_cancel_right' := div_div_div_cancel_right\n\n"}
{"name":"sub_eq_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Iff (Eq (HSub.hSub a b) 0) (Eq a b)","decl":"@[to_additive]\ntheorem div_eq_one : a / b = 1 ↔ a = b :=\n  ⟨eq_of_div_eq_one, fun h ↦ by rw [h, div_self']⟩\n\n"}
{"name":"div_eq_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Iff (Eq (HDiv.hDiv a b) 1) (Eq a b)","decl":"@[to_additive]\ntheorem div_eq_one : a / b = 1 ↔ a = b :=\n  ⟨eq_of_div_eq_one, fun h ↦ by rw [h, div_self']⟩\n\n"}
{"name":"div_eq_one_of_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\na✝ : Eq a b\n⊢ Eq (HDiv.hDiv a b) 1","decl":"alias ⟨_, div_eq_one_of_eq⟩ := div_eq_one\n\n"}
{"name":"sub_eq_zero_of_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\na✝ : Eq a b\n⊢ Eq (HSub.hSub a b) 0","decl":"alias ⟨_, sub_eq_zero_of_eq⟩ := sub_eq_zero\n\n"}
{"name":"div_ne_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Iff (Ne (HDiv.hDiv a b) 1) (Ne a b)","decl":"@[to_additive]\ntheorem div_ne_one : a / b ≠ 1 ↔ a ≠ b :=\n  not_congr div_eq_one\n\n"}
{"name":"sub_ne_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Iff (Ne (HSub.hSub a b) 0) (Ne a b)","decl":"@[to_additive]\ntheorem div_ne_one : a / b ≠ 1 ↔ a ≠ b :=\n  not_congr div_eq_one\n\n"}
{"name":"div_eq_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b : G\n⊢ Iff (Eq (HDiv.hDiv a b) a) (Eq b 1)","decl":"@[to_additive (attr := simp)]\ntheorem div_eq_self : a / b = a ↔ b = 1 := by rw [div_eq_mul_inv, mul_right_eq_self, inv_eq_one]\n\n"}
{"name":"sub_eq_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b : G\n⊢ Iff (Eq (HSub.hSub a b) a) (Eq b 0)","decl":"@[to_additive (attr := simp)]\ntheorem div_eq_self : a / b = a ↔ b = 1 := by rw [div_eq_mul_inv, mul_right_eq_self, inv_eq_one]\n\n"}
{"name":"eq_sub_iff_add_eq","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\n⊢ Iff (Eq a (HSub.hSub b c)) (Eq (HAdd.hAdd a c) b)","decl":"@[to_additive eq_sub_iff_add_eq]\ntheorem eq_div_iff_mul_eq' : a = b / c ↔ a * c = b := by rw [div_eq_mul_inv, eq_mul_inv_iff_mul_eq]\n\n"}
{"name":"eq_div_iff_mul_eq'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\n⊢ Iff (Eq a (HDiv.hDiv b c)) (Eq (HMul.hMul a c) b)","decl":"@[to_additive eq_sub_iff_add_eq]\ntheorem eq_div_iff_mul_eq' : a = b / c ↔ a * c = b := by rw [div_eq_mul_inv, eq_mul_inv_iff_mul_eq]\n\n"}
{"name":"div_eq_iff_eq_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c : G\n⊢ Iff (Eq (HDiv.hDiv a b) c) (Eq a (HMul.hMul c b))","decl":"@[to_additive]\ntheorem div_eq_iff_eq_mul : a / b = c ↔ a = c * b := by rw [div_eq_mul_inv, mul_inv_eq_iff_eq_mul]\n\n"}
{"name":"sub_eq_iff_eq_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c : G\n⊢ Iff (Eq (HSub.hSub a b) c) (Eq a (HAdd.hAdd c b))","decl":"@[to_additive]\ntheorem div_eq_iff_eq_mul : a / b = c ↔ a = c * b := by rw [div_eq_mul_inv, mul_inv_eq_iff_eq_mul]\n\n"}
{"name":"eq_iff_eq_of_div_eq_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na b c d : G\nH : Eq (HDiv.hDiv a b) (HDiv.hDiv c d)\n⊢ Iff (Eq a b) (Eq c d)","decl":"@[to_additive]\ntheorem eq_iff_eq_of_div_eq_div (H : a / b = c / d) : a = b ↔ c = d := by\n  rw [← div_eq_one, H, div_eq_one]\n\n"}
{"name":"eq_iff_eq_of_sub_eq_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na b c d : G\nH : Eq (HSub.hSub a b) (HSub.hSub c d)\n⊢ Iff (Eq a b) (Eq c d)","decl":"@[to_additive]\ntheorem eq_iff_eq_of_div_eq_div (H : a / b = c / d) : a = b ↔ c = d := by\n  rw [← div_eq_one, H, div_eq_one]\n\n"}
{"name":"leftInverse_sub_add_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nc : G\n⊢ Function.LeftInverse (fun x => HSub.hSub x c) fun x => HAdd.hAdd x c","decl":"@[to_additive]\ntheorem leftInverse_div_mul_left (c : G) : Function.LeftInverse (fun x ↦ x / c) fun x ↦ x * c :=\n  fun x ↦ mul_div_cancel_right x c\n\n"}
{"name":"leftInverse_div_mul_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\nc : G\n⊢ Function.LeftInverse (fun x => HDiv.hDiv x c) fun x => HMul.hMul x c","decl":"@[to_additive]\ntheorem leftInverse_div_mul_left (c : G) : Function.LeftInverse (fun x ↦ x / c) fun x ↦ x * c :=\n  fun x ↦ mul_div_cancel_right x c\n\n"}
{"name":"leftInverse_add_left_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nc : G\n⊢ Function.LeftInverse (fun x => HAdd.hAdd x c) fun x => HSub.hSub x c","decl":"@[to_additive]\ntheorem leftInverse_mul_left_div (c : G) : Function.LeftInverse (fun x ↦ x * c) fun x ↦ x / c :=\n  fun x ↦ div_mul_cancel x c\n\n"}
{"name":"leftInverse_mul_left_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\nc : G\n⊢ Function.LeftInverse (fun x => HMul.hMul x c) fun x => HDiv.hDiv x c","decl":"@[to_additive]\ntheorem leftInverse_mul_left_div (c : G) : Function.LeftInverse (fun x ↦ x * c) fun x ↦ x / c :=\n  fun x ↦ div_mul_cancel x c\n\n"}
{"name":"leftInverse_add_right_neg_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nc : G\n⊢ Function.LeftInverse (fun x => HAdd.hAdd c x) fun x => HAdd.hAdd (Neg.neg c) x","decl":"@[to_additive]\ntheorem leftInverse_mul_right_inv_mul (c : G) :\n    Function.LeftInverse (fun x ↦ c * x) fun x ↦ c⁻¹ * x :=\n  fun x ↦ mul_inv_cancel_left c x\n\n"}
{"name":"leftInverse_mul_right_inv_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\nc : G\n⊢ Function.LeftInverse (fun x => HMul.hMul c x) fun x => HMul.hMul (Inv.inv c) x","decl":"@[to_additive]\ntheorem leftInverse_mul_right_inv_mul (c : G) :\n    Function.LeftInverse (fun x ↦ c * x) fun x ↦ c⁻¹ * x :=\n  fun x ↦ mul_inv_cancel_left c x\n\n"}
{"name":"leftInverse_neg_add_add_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nc : G\n⊢ Function.LeftInverse (fun x => HAdd.hAdd (Neg.neg c) x) fun x => HAdd.hAdd c x","decl":"@[to_additive]\ntheorem leftInverse_inv_mul_mul_right (c : G) :\n    Function.LeftInverse (fun x ↦ c⁻¹ * x) fun x ↦ c * x :=\n  fun x ↦ inv_mul_cancel_left c x\n\n"}
{"name":"leftInverse_inv_mul_mul_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\nc : G\n⊢ Function.LeftInverse (fun x => HMul.hMul (Inv.inv c) x) fun x => HMul.hMul c x","decl":"@[to_additive]\ntheorem leftInverse_inv_mul_mul_right (c : G) :\n    Function.LeftInverse (fun x ↦ c⁻¹ * x) fun x ↦ c * x :=\n  fun x ↦ inv_mul_cancel_left c x\n\n"}
{"name":"natAbs_nsmul_eq_zero","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nn : Int\n⊢ Iff (Eq (HSMul.hSMul n.natAbs a) 0) (Eq (HSMul.hSMul n a) 0)","decl":"@[to_additive (attr := simp) natAbs_nsmul_eq_zero]\nlemma pow_natAbs_eq_one : a ^ n.natAbs = 1 ↔ a ^ n = 1 := by cases n <;> simp\n\n"}
{"name":"pow_natAbs_eq_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nn : Int\n⊢ Iff (Eq (HPow.hPow a n.natAbs) 1) (Eq (HPow.hPow a n) 1)","decl":"@[to_additive (attr := simp) natAbs_nsmul_eq_zero]\nlemma pow_natAbs_eq_one : a ^ n.natAbs = 1 ↔ a ^ n = 1 := by cases n <;> simp\n\n"}
{"name":"sub_nsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nm n : Nat\nh : LE.le n m\n⊢ Eq (HSMul.hSMul (HSub.hSub m n) a) (HAdd.hAdd (HSMul.hSMul m a) (Neg.neg (HSMul.hSMul n a)))","decl":"@[to_additive sub_nsmul]\nlemma pow_sub (a : G) {m n : ℕ} (h : n ≤ m) : a ^ (m - n) = a ^ m * (a ^ n)⁻¹ :=\n  eq_mul_inv_of_mul_eq <| by rw [← pow_add, Nat.sub_add_cancel h]\n\n"}
{"name":"pow_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nm n : Nat\nh : LE.le n m\n⊢ Eq (HPow.hPow a (HSub.hSub m n)) (HMul.hMul (HPow.hPow a m) (Inv.inv (HPow.hPow a n)))","decl":"@[to_additive sub_nsmul]\nlemma pow_sub (a : G) {m n : ℕ} (h : n ≤ m) : a ^ (m - n) = a ^ m * (a ^ n)⁻¹ :=\n  eq_mul_inv_of_mul_eq <| by rw [← pow_add, Nat.sub_add_cancel h]\n\n"}
{"name":"inv_pow_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nm n : Nat\nh : LE.le n m\n⊢ Eq (HPow.hPow (Inv.inv a) (HSub.hSub m n)) (HMul.hMul (Inv.inv (HPow.hPow a m)) (HPow.hPow a n))","decl":"@[to_additive sub_nsmul_neg]\ntheorem inv_pow_sub (a : G) {m n : ℕ} (h : n ≤ m) : a⁻¹ ^ (m - n) = (a ^ m)⁻¹ * a ^ n := by\n  rw [pow_sub a⁻¹ h, inv_pow, inv_pow, inv_inv]\n\n"}
{"name":"sub_nsmul_neg","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nm n : Nat\nh : LE.le n m\n⊢ Eq (HSMul.hSMul (HSub.hSub m n) (Neg.neg a)) (HAdd.hAdd (Neg.neg (HSMul.hSMul m a)) (HSMul.hSMul n a))","decl":"@[to_additive sub_nsmul_neg]\ntheorem inv_pow_sub (a : G) {m n : ℕ} (h : n ≤ m) : a⁻¹ ^ (m - n) = (a ^ m)⁻¹ * a ^ n := by\n  rw [pow_sub a⁻¹ h, inv_pow, inv_pow, inv_inv]\n\n"}
{"name":"add_one_zsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nn : Int\n⊢ Eq (HSMul.hSMul (HAdd.hAdd n 1) a) (HAdd.hAdd (HSMul.hSMul n a) a)","decl":"@[to_additive add_one_zsmul]\nlemma zpow_add_one (a : G) : ∀ n : ℤ, a ^ (n + 1) = a ^ n * a\n  | (n : ℕ) => by simp only [← Int.ofNat_succ, zpow_natCast, pow_succ]\n  | .negSucc 0 => by simp [Int.negSucc_eq', Int.add_left_neg]\n  | .negSucc (n + 1) => by\n    rw [zpow_negSucc, pow_succ', mul_inv_rev, inv_mul_cancel_right]\n    rw [Int.negSucc_eq, Int.neg_add, Int.neg_add_cancel_right]\n    exact zpow_negSucc _ _\n\n"}
{"name":"zpow_add_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nn : Int\n⊢ Eq (HPow.hPow a (HAdd.hAdd n 1)) (HMul.hMul (HPow.hPow a n) a)","decl":"@[to_additive add_one_zsmul]\nlemma zpow_add_one (a : G) : ∀ n : ℤ, a ^ (n + 1) = a ^ n * a\n  | (n : ℕ) => by simp only [← Int.ofNat_succ, zpow_natCast, pow_succ]\n  | .negSucc 0 => by simp [Int.negSucc_eq', Int.add_left_neg]\n  | .negSucc (n + 1) => by\n    rw [zpow_negSucc, pow_succ', mul_inv_rev, inv_mul_cancel_right]\n    rw [Int.negSucc_eq, Int.neg_add, Int.neg_add_cancel_right]\n    exact zpow_negSucc _ _\n\n"}
{"name":"zpow_sub_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nn : Int\n⊢ Eq (HPow.hPow a (HSub.hSub n 1)) (HMul.hMul (HPow.hPow a n) (Inv.inv a))","decl":"@[to_additive sub_one_zsmul]\nlemma zpow_sub_one (a : G) (n : ℤ) : a ^ (n - 1) = a ^ n * a⁻¹ :=\n  calc\n    a ^ (n - 1) = a ^ (n - 1) * a * a⁻¹ := (mul_inv_cancel_right _ _).symm\n    _ = a ^ n * a⁻¹ := by rw [← zpow_add_one, Int.sub_add_cancel]\n\n"}
{"name":"sub_one_zsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nn : Int\n⊢ Eq (HSMul.hSMul (HSub.hSub n 1) a) (HAdd.hAdd (HSMul.hSMul n a) (Neg.neg a))","decl":"@[to_additive sub_one_zsmul]\nlemma zpow_sub_one (a : G) (n : ℤ) : a ^ (n - 1) = a ^ n * a⁻¹ :=\n  calc\n    a ^ (n - 1) = a ^ (n - 1) * a * a⁻¹ := (mul_inv_cancel_right _ _).symm\n    _ = a ^ n * a⁻¹ := by rw [← zpow_add_one, Int.sub_add_cancel]\n\n"}
{"name":"add_zsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nm n : Int\n⊢ Eq (HSMul.hSMul (HAdd.hAdd m n) a) (HAdd.hAdd (HSMul.hSMul m a) (HSMul.hSMul n a))","decl":"@[to_additive add_zsmul]\nlemma zpow_add (a : G) (m n : ℤ) : a ^ (m + n) = a ^ m * a ^ n := by\n  induction n using Int.induction_on with\n  | hz => simp\n  | hp n ihn => simp only [← Int.add_assoc, zpow_add_one, ihn, mul_assoc]\n  | hn n ihn => rw [zpow_sub_one, ← mul_assoc, ← ihn, ← zpow_sub_one, Int.add_sub_assoc]\n\n"}
{"name":"zpow_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nm n : Int\n⊢ Eq (HPow.hPow a (HAdd.hAdd m n)) (HMul.hMul (HPow.hPow a m) (HPow.hPow a n))","decl":"@[to_additive add_zsmul]\nlemma zpow_add (a : G) (m n : ℤ) : a ^ (m + n) = a ^ m * a ^ n := by\n  induction n using Int.induction_on with\n  | hz => simp\n  | hp n ihn => simp only [← Int.add_assoc, zpow_add_one, ihn, mul_assoc]\n  | hn n ihn => rw [zpow_sub_one, ← mul_assoc, ← ihn, ← zpow_sub_one, Int.add_sub_assoc]\n\n"}
{"name":"zpow_one_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nn : Int\n⊢ Eq (HPow.hPow a (HAdd.hAdd 1 n)) (HMul.hMul a (HPow.hPow a n))","decl":"@[to_additive one_add_zsmul]\nlemma zpow_one_add (a : G) (n : ℤ) : a ^ (1 + n) = a * a ^ n := by rw [zpow_add, zpow_one]\n\n"}
{"name":"one_add_zsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nn : Int\n⊢ Eq (HSMul.hSMul (HAdd.hAdd 1 n) a) (HAdd.hAdd a (HSMul.hSMul n a))","decl":"@[to_additive one_add_zsmul]\nlemma zpow_one_add (a : G) (n : ℤ) : a ^ (1 + n) = a * a ^ n := by rw [zpow_add, zpow_one]\n\n"}
{"name":"add_zsmul_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nn : Int\n⊢ Eq (HAdd.hAdd a (HSMul.hSMul n a)) (HSMul.hSMul (HAdd.hAdd n 1) a)","decl":"@[to_additive add_zsmul_self]\nlemma mul_self_zpow (a : G) (n : ℤ) : a * a ^ n = a ^ (n + 1) := by\n  rw [Int.add_comm, zpow_add, zpow_one]\n\n"}
{"name":"mul_self_zpow","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nn : Int\n⊢ Eq (HMul.hMul a (HPow.hPow a n)) (HPow.hPow a (HAdd.hAdd n 1))","decl":"@[to_additive add_zsmul_self]\nlemma mul_self_zpow (a : G) (n : ℤ) : a * a ^ n = a ^ (n + 1) := by\n  rw [Int.add_comm, zpow_add, zpow_one]\n\n"}
{"name":"mul_zpow_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nn : Int\n⊢ Eq (HMul.hMul (HPow.hPow a n) a) (HPow.hPow a (HAdd.hAdd n 1))","decl":"@[to_additive add_self_zsmul]\nlemma mul_zpow_self (a : G) (n : ℤ) : a ^ n * a = a ^ (n + 1) := (zpow_add_one ..).symm\n\n"}
{"name":"add_self_zsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nn : Int\n⊢ Eq (HAdd.hAdd (HSMul.hSMul n a) a) (HSMul.hSMul (HAdd.hAdd n 1) a)","decl":"@[to_additive add_self_zsmul]\nlemma mul_zpow_self (a : G) (n : ℤ) : a ^ n * a = a ^ (n + 1) := (zpow_add_one ..).symm\n\n"}
{"name":"zpow_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nm n : Int\n⊢ Eq (HPow.hPow a (HSub.hSub m n)) (HMul.hMul (HPow.hPow a m) (Inv.inv (HPow.hPow a n)))","decl":"@[to_additive sub_zsmul] lemma zpow_sub (a : G) (m n : ℤ) : a ^ (m - n) = a ^ m * (a ^ n)⁻¹ := by\n  rw [Int.sub_eq_add_neg, zpow_add, zpow_neg]\n\n"}
{"name":"sub_zsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nm n : Int\n⊢ Eq (HSMul.hSMul (HSub.hSub m n) a) (HAdd.hAdd (HSMul.hSMul m a) (Neg.neg (HSMul.hSMul n a)))","decl":"@[to_additive sub_zsmul] lemma zpow_sub (a : G) (m n : ℤ) : a ^ (m - n) = a ^ m * (a ^ n)⁻¹ := by\n  rw [Int.sub_eq_add_neg, zpow_add, zpow_neg]\n\n"}
{"name":"zpow_natCast_sub_natCast","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nm n : Nat\n⊢ Eq (HPow.hPow a (HSub.hSub ↑m ↑n)) (HDiv.hDiv (HPow.hPow a m) (HPow.hPow a n))","decl":"@[to_additive natCast_sub_natCast_zsmul]\nlemma zpow_natCast_sub_natCast (a : G) (m n : ℕ) : a ^ (m - n : ℤ) = a ^ m / a ^ n := by\n  simpa [div_eq_mul_inv] using zpow_sub a m n\n\n"}
{"name":"natCast_sub_natCast_zsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nm n : Nat\n⊢ Eq (HSMul.hSMul (HSub.hSub ↑m ↑n) a) (HSub.hSub (HSMul.hSMul m a) (HSMul.hSMul n a))","decl":"@[to_additive natCast_sub_natCast_zsmul]\nlemma zpow_natCast_sub_natCast (a : G) (m n : ℕ) : a ^ (m - n : ℤ) = a ^ m / a ^ n := by\n  simpa [div_eq_mul_inv] using zpow_sub a m n\n\n"}
{"name":"zpow_natCast_sub_one","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nn : Nat\n⊢ Eq (HPow.hPow a (HSub.hSub (↑n) 1)) (HDiv.hDiv (HPow.hPow a n) a)","decl":"@[to_additive natCast_sub_one_zsmul]\nlemma zpow_natCast_sub_one (a : G) (n : ℕ) : a ^ (n - 1 : ℤ) = a ^ n / a := by\n  simpa [div_eq_mul_inv] using zpow_sub a n 1\n\n"}
{"name":"natCast_sub_one_zsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nn : Nat\n⊢ Eq (HSMul.hSMul (HSub.hSub (↑n) 1) a) (HSub.hSub (HSMul.hSMul n a) a)","decl":"@[to_additive natCast_sub_one_zsmul]\nlemma zpow_natCast_sub_one (a : G) (n : ℕ) : a ^ (n - 1 : ℤ) = a ^ n / a := by\n  simpa [div_eq_mul_inv] using zpow_sub a n 1\n\n"}
{"name":"zpow_one_sub_natCast","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nn : Nat\n⊢ Eq (HPow.hPow a (HSub.hSub 1 ↑n)) (HDiv.hDiv a (HPow.hPow a n))","decl":"@[to_additive one_sub_natCast_zsmul]\nlemma zpow_one_sub_natCast (a : G) (n : ℕ) : a ^ (1 - n : ℤ) = a / a ^ n := by\n  simpa [div_eq_mul_inv] using zpow_sub a 1 n\n\n"}
{"name":"one_sub_natCast_zsmul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nn : Nat\n⊢ Eq (HSMul.hSMul (HSub.hSub 1 ↑n) a) (HSub.hSub a (HSMul.hSMul n a))","decl":"@[to_additive one_sub_natCast_zsmul]\nlemma zpow_one_sub_natCast (a : G) (n : ℕ) : a ^ (1 - n : ℤ) = a / a ^ n := by\n  simpa [div_eq_mul_inv] using zpow_sub a 1 n\n\n"}
{"name":"zpow_mul_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\na : G\nm n : Int\n⊢ Eq (HMul.hMul (HPow.hPow a m) (HPow.hPow a n)) (HMul.hMul (HPow.hPow a n) (HPow.hPow a m))","decl":"@[to_additive] lemma zpow_mul_comm (a : G) (m n : ℤ) : a ^ m * a ^ n = a ^ n * a ^ m := by\n  rw [← zpow_add, Int.add_comm, zpow_add]\n\n"}
{"name":"zsmul_add_comm","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\na : G\nm n : Int\n⊢ Eq (HAdd.hAdd (HSMul.hSMul m a) (HSMul.hSMul n a)) (HAdd.hAdd (HSMul.hSMul n a) (HSMul.hSMul m a))","decl":"@[to_additive] lemma zpow_mul_comm (a : G) (m n : ℤ) : a ^ m * a ^ n = a ^ n * a ^ m := by\n  rw [← zpow_add, Int.add_comm, zpow_add]\n\n"}
{"name":"zpow_eq_zpow_emod","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\nx : G\nm n : Int\nh : Eq (HPow.hPow x n) 1\n⊢ Eq (HPow.hPow x m) (HPow.hPow x (HMod.hMod m n))","decl":"theorem zpow_eq_zpow_emod {x : G} (m : ℤ) {n : ℤ} (h : x ^ n = 1) :\n    x ^ m = x ^ (m % n) :=\n  calc\n    x ^ m = x ^ (m % n + n * (m / n)) := by rw [Int.emod_add_ediv]\n    _ = x ^ (m % n) := by simp [zpow_add, zpow_mul, h]\n\n"}
{"name":"zpow_eq_zpow_emod'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\nx : G\nm : Int\nn : Nat\nh : Eq (HPow.hPow x n) 1\n⊢ Eq (HPow.hPow x m) (HPow.hPow x (HMod.hMod m ↑n))","decl":"theorem zpow_eq_zpow_emod' {x : G} (m : ℤ) {n : ℕ} (h : x ^ n = 1) :\n    x ^ m = x ^ (m % (n : ℤ)) := zpow_eq_zpow_emod m (by simpa)\n\n"}
{"name":"zpow_induction_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\ng : G\nP : G → Prop\nh_one : P 1\nh_mul : ∀ (a : G), P a → P (HMul.hMul g a)\nh_inv : ∀ (a : G), P a → P (HMul.hMul (Inv.inv g) a)\nn : Int\n⊢ P (HPow.hPow g n)","decl":"/-- To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `g⁻¹` on the left. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_left`. -/\n@[to_additive \"To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the left. For additive subgroups generated by more than one element, see\n`AddSubgroup.closure_induction_left`.\"]\nlemma zpow_induction_left {g : G} {P : G → Prop} (h_one : P (1 : G))\n    (h_mul : ∀ a, P a → P (g * a)) (h_inv : ∀ a, P a → P (g⁻¹ * a)) (n : ℤ) : P (g ^ n) := by\n  induction n using Int.induction_on with\n  | hz => rwa [zpow_zero]\n  | hp n ih =>\n    rw [Int.add_comm, zpow_add, zpow_one]\n    exact h_mul _ ih\n  | hn n ih =>\n    rw [Int.sub_eq_add_neg, Int.add_comm, zpow_add, zpow_neg_one]\n    exact h_inv _ ih\n\n"}
{"name":"zsmul_induction_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\ng : G\nP : G → Prop\nh_one : P 0\nh_mul : ∀ (a : G), P a → P (HAdd.hAdd g a)\nh_inv : ∀ (a : G), P a → P (HAdd.hAdd (Neg.neg g) a)\nn : Int\n⊢ P (HSMul.hSMul n g)","decl":"/-- To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `g⁻¹` on the left. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_left`. -/\n@[to_additive \"To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the left. For additive subgroups generated by more than one element, see\n`AddSubgroup.closure_induction_left`.\"]\nlemma zpow_induction_left {g : G} {P : G → Prop} (h_one : P (1 : G))\n    (h_mul : ∀ a, P a → P (g * a)) (h_inv : ∀ a, P a → P (g⁻¹ * a)) (n : ℤ) : P (g ^ n) := by\n  induction n using Int.induction_on with\n  | hz => rwa [zpow_zero]\n  | hp n ih =>\n    rw [Int.add_comm, zpow_add, zpow_one]\n    exact h_mul _ ih\n  | hn n ih =>\n    rw [Int.sub_eq_add_neg, Int.add_comm, zpow_add, zpow_neg_one]\n    exact h_inv _ ih\n\n"}
{"name":"zpow_induction_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : Group G\ng : G\nP : G → Prop\nh_one : P 1\nh_mul : ∀ (a : G), P a → P (HMul.hMul a g)\nh_inv : ∀ (a : G), P a → P (HMul.hMul a (Inv.inv g))\nn : Int\n⊢ P (HPow.hPow g n)","decl":"/-- To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `g⁻¹` on the right. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_right`. -/\n@[to_additive \"To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the right. For additive subgroups generated by more than one element,\nsee `AddSubgroup.closure_induction_right`.\"]\nlemma zpow_induction_right {g : G} {P : G → Prop} (h_one : P (1 : G))\n    (h_mul : ∀ a, P a → P (a * g)) (h_inv : ∀ a, P a → P (a * g⁻¹)) (n : ℤ) : P (g ^ n) := by\n  induction n using Int.induction_on with\n  | hz => rwa [zpow_zero]\n  | hp n ih =>\n    rw [zpow_add_one]\n    exact h_mul _ ih\n  | hn n ih =>\n    rw [zpow_sub_one]\n    exact h_inv _ ih\n\n"}
{"name":"zsmul_induction_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\ng : G\nP : G → Prop\nh_one : P 0\nh_mul : ∀ (a : G), P a → P (HAdd.hAdd a g)\nh_inv : ∀ (a : G), P a → P (HAdd.hAdd a (Neg.neg g))\nn : Int\n⊢ P (HSMul.hSMul n g)","decl":"/-- To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `g⁻¹` on the right. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_right`. -/\n@[to_additive \"To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the right. For additive subgroups generated by more than one element,\nsee `AddSubgroup.closure_induction_right`.\"]\nlemma zpow_induction_right {g : G} {P : G → Prop} (h_one : P (1 : G))\n    (h_mul : ∀ a, P a → P (a * g)) (h_inv : ∀ a, P a → P (a * g⁻¹)) (n : ℤ) : P (g ^ n) := by\n  induction n using Int.induction_on with\n  | hz => rwa [zpow_zero]\n  | hp n ih =>\n    rw [zpow_add_one]\n    exact h_mul _ ih\n  | hn n ih =>\n    rw [zpow_sub_one]\n    exact h_inv _ ih\n\n"}
{"name":"div_eq_of_eq_mul'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\nh : Eq a (HMul.hMul b c)\n⊢ Eq (HDiv.hDiv a b) c","decl":"@[to_additive]\ntheorem div_eq_of_eq_mul' {a b c : G} (h : a = b * c) : a / b = c := by\n  rw [h, div_eq_mul_inv, mul_comm, inv_mul_cancel_left]\n\n"}
{"name":"sub_eq_of_eq_add'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c : G\nh : Eq a (HAdd.hAdd b c)\n⊢ Eq (HSub.hSub a b) c","decl":"@[to_additive]\ntheorem div_eq_of_eq_mul' {a b c : G} (h : a = b * c) : a / b = c := by\n  rw [h, div_eq_mul_inv, mul_comm, inv_mul_cancel_left]\n\n"}
{"name":"add_sub_add_left_eq_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c : G\n⊢ Eq (HSub.hSub (HAdd.hAdd c a) (HAdd.hAdd c b)) (HSub.hSub a b)","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_mul_left_eq_div (a b c : G) : c * a / (c * b) = a / b := by\n  rw [div_eq_mul_inv, mul_inv_rev, mul_comm b⁻¹ c⁻¹, mul_comm c a, mul_assoc, ← mul_assoc c,\n    mul_inv_cancel, one_mul, div_eq_mul_inv]\n\n"}
{"name":"mul_div_mul_left_eq_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\n⊢ Eq (HDiv.hDiv (HMul.hMul c a) (HMul.hMul c b)) (HDiv.hDiv a b)","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_mul_left_eq_div (a b c : G) : c * a / (c * b) = a / b := by\n  rw [div_eq_mul_inv, mul_inv_rev, mul_comm b⁻¹ c⁻¹, mul_comm c a, mul_assoc, ← mul_assoc c,\n    mul_inv_cancel, one_mul, div_eq_mul_inv]\n\n"}
{"name":"eq_div_of_mul_eq''","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\nh : Eq (HMul.hMul c a) b\n⊢ Eq a (HDiv.hDiv b c)","decl":"@[to_additive eq_sub_of_add_eq']\ntheorem eq_div_of_mul_eq'' (h : c * a = b) : a = b / c := by simp [h.symm]\n\n"}
{"name":"eq_sub_of_add_eq'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c : G\nh : Eq (HAdd.hAdd c a) b\n⊢ Eq a (HSub.hSub b c)","decl":"@[to_additive eq_sub_of_add_eq']\ntheorem eq_div_of_mul_eq'' (h : c * a = b) : a = b / c := by simp [h.symm]\n\n"}
{"name":"eq_add_of_sub_eq'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c : G\nh : Eq (HSub.hSub a b) c\n⊢ Eq a (HAdd.hAdd b c)","decl":"@[to_additive]\ntheorem eq_mul_of_div_eq' (h : a / b = c) : a = b * c := by simp [h.symm]\n\n"}
{"name":"eq_mul_of_div_eq'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\nh : Eq (HDiv.hDiv a b) c\n⊢ Eq a (HMul.hMul b c)","decl":"@[to_additive]\ntheorem eq_mul_of_div_eq' (h : a / b = c) : a = b * c := by simp [h.symm]\n\n"}
{"name":"mul_eq_of_eq_div'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\nh : Eq b (HDiv.hDiv c a)\n⊢ Eq (HMul.hMul a b) c","decl":"@[to_additive]\ntheorem mul_eq_of_eq_div' (h : b = c / a) : a * b = c := by\n  rw [h, div_eq_mul_inv, mul_comm c, mul_inv_cancel_left]\n\n"}
{"name":"add_eq_of_eq_sub'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c : G\nh : Eq b (HSub.hSub c a)\n⊢ Eq (HAdd.hAdd a b) c","decl":"@[to_additive]\ntheorem mul_eq_of_eq_div' (h : b = c / a) : a * b = c := by\n  rw [h, div_eq_mul_inv, mul_comm c, mul_inv_cancel_left]\n\n"}
{"name":"div_div_self'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b : G\n⊢ Eq (HDiv.hDiv a (HDiv.hDiv a b)) b","decl":"@[to_additive sub_sub_self]\ntheorem div_div_self' (a b : G) : a / (a / b) = b := by simp\n\n"}
{"name":"sub_sub_self","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b : G\n⊢ Eq (HSub.hSub a (HSub.hSub a b)) b","decl":"@[to_additive sub_sub_self]\ntheorem div_div_self' (a b : G) : a / (a / b) = b := by simp\n\n"}
{"name":"div_eq_div_mul_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul (HDiv.hDiv c b) (HDiv.hDiv a c))","decl":"@[to_additive]\ntheorem div_eq_div_mul_div (a b c : G) : a / b = c / b * (a / c) := by simp [mul_left_comm c]\n\n"}
{"name":"sub_eq_sub_add_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c : G\n⊢ Eq (HSub.hSub a b) (HAdd.hAdd (HSub.hSub c b) (HSub.hSub a c))","decl":"@[to_additive]\ntheorem div_eq_div_mul_div (a b c : G) : a / b = c / b * (a / c) := by simp [mul_left_comm c]\n\n"}
{"name":"sub_sub_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b : G\n⊢ Eq (HSub.hSub a (HSub.hSub a b)) b","decl":"@[to_additive (attr := simp)]\ntheorem div_div_cancel (a b : G) : a / (a / b) = b :=\n  div_div_self' a b\n\n"}
{"name":"div_div_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b : G\n⊢ Eq (HDiv.hDiv a (HDiv.hDiv a b)) b","decl":"@[to_additive (attr := simp)]\ntheorem div_div_cancel (a b : G) : a / (a / b) = b :=\n  div_div_self' a b\n\n"}
{"name":"sub_sub_cancel_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b : G\n⊢ Eq (HSub.hSub (HSub.hSub a b) a) (Neg.neg b)","decl":"@[to_additive (attr := simp)]\ntheorem div_div_cancel_left (a b : G) : a / b / a = b⁻¹ := by simp\n\n"}
{"name":"div_div_cancel_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b : G\n⊢ Eq (HDiv.hDiv (HDiv.hDiv a b) a) (Inv.inv b)","decl":"@[to_additive (attr := simp)]\ntheorem div_div_cancel_left (a b : G) : a / b / a = b⁻¹ := by simp\n\n"}
{"name":"eq_sub_iff_add_eq'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c : G\n⊢ Iff (Eq a (HSub.hSub b c)) (Eq (HAdd.hAdd c a) b)","decl":"@[to_additive eq_sub_iff_add_eq']\ntheorem eq_div_iff_mul_eq'' : a = b / c ↔ c * a = b := by rw [eq_div_iff_mul_eq', mul_comm]\n\n"}
{"name":"eq_div_iff_mul_eq''","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\n⊢ Iff (Eq a (HDiv.hDiv b c)) (Eq (HMul.hMul c a) b)","decl":"@[to_additive eq_sub_iff_add_eq']\ntheorem eq_div_iff_mul_eq'' : a = b / c ↔ c * a = b := by rw [eq_div_iff_mul_eq', mul_comm]\n\n"}
{"name":"sub_eq_iff_eq_add'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c : G\n⊢ Iff (Eq (HSub.hSub a b) c) (Eq a (HAdd.hAdd b c))","decl":"@[to_additive]\ntheorem div_eq_iff_eq_mul' : a / b = c ↔ a = b * c := by rw [div_eq_iff_eq_mul, mul_comm]\n\n"}
{"name":"div_eq_iff_eq_mul'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\n⊢ Iff (Eq (HDiv.hDiv a b) c) (Eq a (HMul.hMul b c))","decl":"@[to_additive]\ntheorem div_eq_iff_eq_mul' : a / b = c ↔ a = b * c := by rw [div_eq_iff_eq_mul, mul_comm]\n\n"}
{"name":"mul_div_cancel_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b : G\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) a) b","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_cancel_left (a b : G) : a * b / a = b := by rw [div_eq_inv_mul, inv_mul_cancel_left]\n\n"}
{"name":"add_sub_cancel_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b : G\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) a) b","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_cancel_left (a b : G) : a * b / a = b := by rw [div_eq_inv_mul, inv_mul_cancel_left]\n\n"}
{"name":"add_sub_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b : G\n⊢ Eq (HAdd.hAdd a (HSub.hSub b a)) b","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_cancel (a b : G) : a * (b / a) = b := by\n  rw [← mul_div_assoc, mul_div_cancel_left]\n\n"}
{"name":"mul_div_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b : G\n⊢ Eq (HMul.hMul a (HDiv.hDiv b a)) b","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_cancel (a b : G) : a * (b / a) = b := by\n  rw [← mul_div_assoc, mul_div_cancel_left]\n\n"}
{"name":"sub_add_cancel_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b : G\n⊢ Eq (HSub.hSub a (HAdd.hAdd a b)) (Neg.neg b)","decl":"@[to_additive (attr := simp)]\ntheorem div_mul_cancel_left (a b : G) : a / (a * b) = b⁻¹ := by rw [← inv_div, mul_div_cancel_left]\n\n-- This lemma is in the `simp` set under the name `mul_inv_cancel_comm_assoc`,\n-- along with the additive version `add_neg_cancel_comm_assoc`,\n-- defined in `Algebra.Group.Commute`\n"}
{"name":"div_mul_cancel_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b : G\n⊢ Eq (HDiv.hDiv a (HMul.hMul a b)) (Inv.inv b)","decl":"@[to_additive (attr := simp)]\ntheorem div_mul_cancel_left (a b : G) : a / (a * b) = b⁻¹ := by rw [← inv_div, mul_div_cancel_left]\n\n-- This lemma is in the `simp` set under the name `mul_inv_cancel_comm_assoc`,\n-- along with the additive version `add_neg_cancel_comm_assoc`,\n-- defined in `Algebra.Group.Commute`\n"}
{"name":"add_add_neg_cancel'_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b : G\n⊢ Eq (HAdd.hAdd a (HAdd.hAdd b (Neg.neg a))) b","decl":"@[to_additive]\ntheorem mul_mul_inv_cancel'_right (a b : G) : a * (b * a⁻¹) = b := by\n  rw [← div_eq_mul_inv, mul_div_cancel a b]\n\n"}
{"name":"mul_mul_inv_cancel'_right","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b : G\n⊢ Eq (HMul.hMul a (HMul.hMul b (Inv.inv a))) b","decl":"@[to_additive]\ntheorem mul_mul_inv_cancel'_right (a b : G) : a * (b * a⁻¹) = b := by\n  rw [← div_eq_mul_inv, mul_div_cancel a b]\n\n"}
{"name":"mul_mul_div_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\n⊢ Eq (HMul.hMul (HMul.hMul a c) (HDiv.hDiv b c)) (HMul.hMul a b)","decl":"@[to_additive (attr := simp)]\ntheorem mul_mul_div_cancel (a b c : G) : a * c * (b / c) = a * b := by\n  rw [mul_assoc, mul_div_cancel]\n\n"}
{"name":"add_add_sub_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c : G\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a c) (HSub.hSub b c)) (HAdd.hAdd a b)","decl":"@[to_additive (attr := simp)]\ntheorem mul_mul_div_cancel (a b c : G) : a * c * (b / c) = a * b := by\n  rw [mul_assoc, mul_div_cancel]\n\n"}
{"name":"div_mul_mul_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\n⊢ Eq (HMul.hMul (HDiv.hDiv a c) (HMul.hMul b c)) (HMul.hMul a b)","decl":"@[to_additive (attr := simp)]\ntheorem div_mul_mul_cancel (a b c : G) : a / c * (b * c) = a * b := by\n  rw [mul_left_comm, div_mul_cancel, mul_comm]\n\n"}
{"name":"sub_add_add_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c : G\n⊢ Eq (HAdd.hAdd (HSub.hSub a c) (HAdd.hAdd b c)) (HAdd.hAdd a b)","decl":"@[to_additive (attr := simp)]\ntheorem div_mul_mul_cancel (a b c : G) : a / c * (b * c) = a * b := by\n  rw [mul_left_comm, div_mul_cancel, mul_comm]\n\n"}
{"name":"sub_add_sub_cancel'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c : G\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) (HSub.hSub c a)) (HSub.hSub c b)","decl":"@[to_additive (attr := simp)]\ntheorem div_mul_div_cancel' (a b c : G) : a / b * (c / a) = c / b := by\n  rw [mul_comm]; apply div_mul_div_cancel\n\n"}
{"name":"div_mul_div_cancel'","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) (HDiv.hDiv c a)) (HDiv.hDiv c b)","decl":"@[to_additive (attr := simp)]\ntheorem div_mul_div_cancel' (a b c : G) : a / b * (c / a) = c / b := by\n  rw [mul_comm]; apply div_mul_div_cancel\n\n"}
{"name":"div_mul_div_cancel''","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) (HDiv.hDiv c a)) (HDiv.hDiv c b)","decl":"@[deprecated (since := \"2024-08-24\")] alias div_mul_div_cancel'' := div_mul_div_cancel'\n\n"}
{"name":"add_sub_sub_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c : G\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) (HSub.hSub a c)) (HAdd.hAdd b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_div_cancel (a b c : G) : a * b / (a / c) = b * c := by\n  rw [← div_mul, mul_div_cancel_left]\n\n"}
{"name":"mul_div_div_cancel","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) (HDiv.hDiv a c)) (HMul.hMul b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_div_div_cancel (a b c : G) : a * b / (a / c) = b * c := by\n  rw [← div_mul, mul_div_cancel_left]\n\n"}
{"name":"div_div_div_cancel_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c : G\n⊢ Eq (HDiv.hDiv (HDiv.hDiv c a) (HDiv.hDiv c b)) (HDiv.hDiv b a)","decl":"@[to_additive (attr := simp)]\ntheorem div_div_div_cancel_left (a b c : G) : c / a / (c / b) = b / a := by\n  rw [← inv_div b c, div_inv_eq_mul, mul_comm, div_mul_div_cancel]\n\n"}
{"name":"sub_sub_sub_cancel_left","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c : G\n⊢ Eq (HSub.hSub (HSub.hSub c a) (HSub.hSub c b)) (HSub.hSub b a)","decl":"@[to_additive (attr := simp)]\ntheorem div_div_div_cancel_left (a b c : G) : c / a / (c / b) = b / a := by\n  rw [← inv_div b c, div_inv_eq_mul, mul_comm, div_mul_div_cancel]\n\n"}
{"name":"sub_eq_sub_iff_add_eq_add","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c d : G\n⊢ Iff (Eq (HSub.hSub a b) (HSub.hSub c d)) (Eq (HAdd.hAdd a d) (HAdd.hAdd c b))","decl":"@[to_additive]\ntheorem div_eq_div_iff_mul_eq_mul : a / b = c / d ↔ a * d = c * b := by\n  rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, eq_comm, div_eq_iff_eq_mul']\n  simp only [mul_comm, eq_comm]\n\n"}
{"name":"div_eq_div_iff_mul_eq_mul","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c d : G\n⊢ Iff (Eq (HDiv.hDiv a b) (HDiv.hDiv c d)) (Eq (HMul.hMul a d) (HMul.hMul c b))","decl":"@[to_additive]\ntheorem div_eq_div_iff_mul_eq_mul : a / b = c / d ↔ a * d = c * b := by\n  rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, eq_comm, div_eq_iff_eq_mul']\n  simp only [mul_comm, eq_comm]\n\n"}
{"name":"sub_eq_sub_iff_sub_eq_sub","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\na b c d : G\n⊢ Iff (Eq (HSub.hSub a b) (HSub.hSub c d)) (Eq (HSub.hSub a c) (HSub.hSub b d))","decl":"@[to_additive]\ntheorem div_eq_div_iff_div_eq_div : a / b = c / d ↔ a / c = b / d := by\n  rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, div_eq_iff_eq_mul', mul_div_assoc]\n\n"}
{"name":"div_eq_div_iff_div_eq_div","module":"Mathlib.Algebra.Group.Basic","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\na b c d : G\n⊢ Iff (Eq (HDiv.hDiv a b) (HDiv.hDiv c d)) (Eq (HDiv.hDiv a c) (HDiv.hDiv b d))","decl":"@[to_additive]\ntheorem div_eq_div_iff_div_eq_div : a / b = c / d ↔ a / c = b / d := by\n  rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, div_eq_iff_eq_mul', mul_div_assoc]\n\n"}
{"name":"multiplicative_of_symmetric_of_isTotal","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Monoid β\np r : α → α → Prop\ninst✝ : IsTotal α r\nf : α → α → β\nhsymm : Symmetric p\nhf_swap : ∀ {a b : α}, p a b → Eq (HMul.hMul (f a b) (f b a)) 1\nhmul : ∀ {a b c : α}, r a b → r b c → p a b → p b c → p a c → Eq (f a c) (HMul.hMul (f a b) (f b c))\na b c : α\npab : p a b\npbc : p b c\npac : p a c\n⊢ Eq (f a c) (HMul.hMul (f a b) (f b c))","decl":"@[to_additive additive_of_symmetric_of_isTotal]\nlemma multiplicative_of_symmetric_of_isTotal\n    (hsymm : Symmetric p) (hf_swap : ∀ {a b}, p a b → f a b * f b a = 1)\n    (hmul : ∀ {a b c}, r a b → r b c → p a b → p b c → p a c → f a c = f a b * f b c)\n    {a b c : α} (pab : p a b) (pbc : p b c) (pac : p a c) : f a c = f a b * f b c := by\n  have hmul' : ∀ {b c}, r b c → p a b → p b c → p a c → f a c = f a b * f b c := by\n    intros b c rbc pab pbc pac\n    obtain rab | rba := total_of r a b\n    · exact hmul rab rbc pab pbc pac\n    rw [← one_mul (f a c), ← hf_swap pab, mul_assoc]\n    obtain rac | rca := total_of r a c\n    · rw [hmul rba rac (hsymm pab) pac pbc]\n    · rw [hmul rbc rca pbc (hsymm pac) (hsymm pab), mul_assoc, hf_swap (hsymm pac), mul_one]\n  obtain rbc | rcb := total_of r b c\n  · exact hmul' rbc pab pbc pac\n  · rw [hmul' rcb pac (hsymm pbc) pab, mul_assoc, hf_swap (hsymm pbc), mul_one]\n\n"}
{"name":"additive_of_symmetric_of_isTotal","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddMonoid β\np r : α → α → Prop\ninst✝ : IsTotal α r\nf : α → α → β\nhsymm : Symmetric p\nhf_swap : ∀ {a b : α}, p a b → Eq (HAdd.hAdd (f a b) (f b a)) 0\nhmul : ∀ {a b c : α}, r a b → r b c → p a b → p b c → p a c → Eq (f a c) (HAdd.hAdd (f a b) (f b c))\na b c : α\npab : p a b\npbc : p b c\npac : p a c\n⊢ Eq (f a c) (HAdd.hAdd (f a b) (f b c))","decl":"@[to_additive additive_of_symmetric_of_isTotal]\nlemma multiplicative_of_symmetric_of_isTotal\n    (hsymm : Symmetric p) (hf_swap : ∀ {a b}, p a b → f a b * f b a = 1)\n    (hmul : ∀ {a b c}, r a b → r b c → p a b → p b c → p a c → f a c = f a b * f b c)\n    {a b c : α} (pab : p a b) (pbc : p b c) (pac : p a c) : f a c = f a b * f b c := by\n  have hmul' : ∀ {b c}, r b c → p a b → p b c → p a c → f a c = f a b * f b c := by\n    intros b c rbc pab pbc pac\n    obtain rab | rba := total_of r a b\n    · exact hmul rab rbc pab pbc pac\n    rw [← one_mul (f a c), ← hf_swap pab, mul_assoc]\n    obtain rac | rca := total_of r a c\n    · rw [hmul rba rac (hsymm pab) pac pbc]\n    · rw [hmul rbc rca pbc (hsymm pac) (hsymm pab), mul_assoc, hf_swap (hsymm pac), mul_one]\n  obtain rbc | rcb := total_of r b c\n  · exact hmul' rbc pab pbc pac\n  · rw [hmul' rcb pac (hsymm pbc) pab, mul_assoc, hf_swap (hsymm pbc), mul_one]\n\n"}
{"name":"additive_of_isTotal","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddMonoid β\nr : α → α → Prop\ninst✝ : IsTotal α r\nf : α → α → β\np : α → Prop\nhswap : ∀ {a b : α}, p a → p b → Eq (HAdd.hAdd (f a b) (f b a)) 0\nhmul : ∀ {a b c : α}, r a b → r b c → p a → p b → p c → Eq (f a c) (HAdd.hAdd (f a b) (f b c))\na b c : α\npa : p a\npb : p b\npc : p c\n⊢ Eq (f a c) (HAdd.hAdd (f a b) (f b c))","decl":"/-- If a binary function from a type equipped with a total relation `r` to a monoid is\n  anti-symmetric (i.e. satisfies `f a b * f b a = 1`), in order to show it is multiplicative\n  (i.e. satisfies `f a c = f a b * f b c`), we may assume `r a b` and `r b c` are satisfied.\n  We allow restricting to a subset specified by a predicate `p`. -/\n@[to_additive additive_of_isTotal \"If a binary function from a type equipped with a total relation\n`r` to an additive monoid is anti-symmetric (i.e. satisfies `f a b + f b a = 0`), in order to show\nit is additive (i.e. satisfies `f a c = f a b + f b c`), we may assume `r a b` and `r b c` are\nsatisfied. We allow restricting to a subset specified by a predicate `p`.\"]\ntheorem multiplicative_of_isTotal (p : α → Prop) (hswap : ∀ {a b}, p a → p b → f a b * f b a = 1)\n    (hmul : ∀ {a b c}, r a b → r b c → p a → p b → p c → f a c = f a b * f b c) {a b c : α}\n    (pa : p a) (pb : p b) (pc : p c) : f a c = f a b * f b c := by\n  apply multiplicative_of_symmetric_of_isTotal (fun a b => p a ∧ p b) r f fun _ _ => And.symm\n  · simp_rw [and_imp]; exact @hswap\n  · exact fun rab rbc pab _pbc pac => hmul rab rbc pab.1 pab.2 pac.2\n  exacts [⟨pa, pb⟩, ⟨pb, pc⟩, ⟨pa, pc⟩]\n\n"}
{"name":"multiplicative_of_isTotal","module":"Mathlib.Algebra.Group.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Monoid β\nr : α → α → Prop\ninst✝ : IsTotal α r\nf : α → α → β\np : α → Prop\nhswap : ∀ {a b : α}, p a → p b → Eq (HMul.hMul (f a b) (f b a)) 1\nhmul : ∀ {a b c : α}, r a b → r b c → p a → p b → p c → Eq (f a c) (HMul.hMul (f a b) (f b c))\na b c : α\npa : p a\npb : p b\npc : p c\n⊢ Eq (f a c) (HMul.hMul (f a b) (f b c))","decl":"/-- If a binary function from a type equipped with a total relation `r` to a monoid is\n  anti-symmetric (i.e. satisfies `f a b * f b a = 1`), in order to show it is multiplicative\n  (i.e. satisfies `f a c = f a b * f b c`), we may assume `r a b` and `r b c` are satisfied.\n  We allow restricting to a subset specified by a predicate `p`. -/\n@[to_additive additive_of_isTotal \"If a binary function from a type equipped with a total relation\n`r` to an additive monoid is anti-symmetric (i.e. satisfies `f a b + f b a = 0`), in order to show\nit is additive (i.e. satisfies `f a c = f a b + f b c`), we may assume `r a b` and `r b c` are\nsatisfied. We allow restricting to a subset specified by a predicate `p`.\"]\ntheorem multiplicative_of_isTotal (p : α → Prop) (hswap : ∀ {a b}, p a → p b → f a b * f b a = 1)\n    (hmul : ∀ {a b c}, r a b → r b c → p a → p b → p c → f a c = f a b * f b c) {a b c : α}\n    (pa : p a) (pb : p b) (pc : p c) : f a c = f a b * f b c := by\n  apply multiplicative_of_symmetric_of_isTotal (fun a b => p a ∧ p b) r f fun _ _ => And.symm\n  · simp_rw [and_imp]; exact @hswap\n  · exact fun rab rbc pab _pbc pac => hmul rab rbc pab.1 pab.2 pac.2\n  exacts [⟨pa, pb⟩, ⟨pb, pc⟩, ⟨pa, pc⟩]\n\n"}
