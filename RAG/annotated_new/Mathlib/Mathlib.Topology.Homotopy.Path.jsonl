{"name":"Path.Homotopy.coeFn_injective","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np₀ p₁ : Path x₀ x₁\n⊢ Function.Injective DFunLike.coe","decl":"theorem coeFn_injective : @Function.Injective (Homotopy p₀ p₁) (I × I → X) (⇑) :=\n  DFunLike.coe_injective\n\n"}
{"name":"Path.Homotopy.source","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np₀ p₁ : Path x₀ x₁\nF : p₀.Homotopy p₁\nt : ↑unitInterval\n⊢ Eq (F { fst := t, snd := 0 }) x₀","decl":"@[simp]\ntheorem source (F : Homotopy p₀ p₁) (t : I) : F (t, 0) = x₀ :=\n  calc F (t, 0) = p₀ 0 := ContinuousMap.HomotopyRel.eq_fst _ _ (.inl rfl)\n  _ = x₀ := p₀.source\n\n"}
{"name":"Path.Homotopy.target","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np₀ p₁ : Path x₀ x₁\nF : p₀.Homotopy p₁\nt : ↑unitInterval\n⊢ Eq (F { fst := t, snd := 1 }) x₁","decl":"@[simp]\ntheorem target (F : Homotopy p₀ p₁) (t : I) : F (t, 1) = x₁ :=\n  calc F (t, 1) = p₀ 1 := ContinuousMap.HomotopyRel.eq_fst _ _ (.inr rfl)\n  _ = x₁ := p₀.target\n\n"}
{"name":"Path.Homotopy.eval_zero","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np₀ p₁ : Path x₀ x₁\nF : p₀.Homotopy p₁\n⊢ Eq (F.eval 0) p₀","decl":"@[simp]\ntheorem eval_zero (F : Homotopy p₀ p₁) : F.eval 0 = p₀ := by\n  ext t\n  simp [eval]\n\n"}
{"name":"Path.Homotopy.eval_one","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np₀ p₁ : Path x₀ x₁\nF : p₀.Homotopy p₁\n⊢ Eq (F.eval 1) p₁","decl":"@[simp]\ntheorem eval_one (F : Homotopy p₀ p₁) : F.eval 1 = p₁ := by\n  ext t\n  simp [eval]\n\n"}
{"name":"Path.Homotopy.refl_apply","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np : Path x₀ x₁\nx : Prod ↑unitInterval ↑unitInterval\n⊢ Eq ((Path.Homotopy.refl p) x) (p x.2)","decl":"/-- Given a path `p`, we can define a `Homotopy p p` by `F (t, x) = p x`.\n-/\n@[simps!]\ndef refl (p : Path x₀ x₁) : Homotopy p p :=\n  ContinuousMap.HomotopyRel.refl p.toContinuousMap {0, 1}\n\n"}
{"name":"Path.Homotopy.symm_apply","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np₀ p₁ : Path x₀ x₁\nF : p₀.Homotopy p₁\nx : Prod ↑unitInterval ↑unitInterval\n⊢ Eq (F.symm x) (F { fst := unitInterval.symm x.1, snd := x.2 })","decl":"/-- Given a `Homotopy p₀ p₁`, we can define a `Homotopy p₁ p₀` by reversing the homotopy.\n-/\n@[simps!]\ndef symm (F : Homotopy p₀ p₁) : Homotopy p₁ p₀ :=\n  ContinuousMap.HomotopyRel.symm F\n\n"}
{"name":"Path.Homotopy.symm_symm","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np₀ p₁ : Path x₀ x₁\nF : p₀.Homotopy p₁\n⊢ Eq F.symm.symm F","decl":"@[simp]\ntheorem symm_symm (F : Homotopy p₀ p₁) : F.symm.symm = F :=\n  ContinuousMap.HomotopyRel.symm_symm F\n\n"}
{"name":"Path.Homotopy.symm_bijective","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np₀ p₁ : Path x₀ x₁\n⊢ Function.Bijective Path.Homotopy.symm","decl":"theorem symm_bijective : Function.Bijective (Homotopy.symm : Homotopy p₀ p₁ → Homotopy p₁ p₀) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"Path.Homotopy.trans_apply","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np₀ p₁ p₂ : Path x₀ x₁\nF : p₀.Homotopy p₁\nG : p₁.Homotopy p₂\nx : Prod ↑unitInterval ↑unitInterval\n⊢ Eq ((F.trans G) x) (dite (LE.le (↑x.1) (1 / 2)) (fun h => F { fst := ⟨HMul.hMul 2 ↑x.1, ⋯⟩, snd := x.2 }) fun h => G { fst := ⟨HSub.hSub (HMul.hMul 2 ↑x.1) 1, ⋯⟩, snd := x.2 })","decl":"theorem trans_apply (F : Homotopy p₀ p₁) (G : Homotopy p₁ p₂) (x : I × I) :\n    (F.trans G) x =\n      if h : (x.1 : ℝ) ≤ 1 / 2 then\n        F (⟨2 * x.1, (unitInterval.mul_pos_mem_iff zero_lt_two).2 ⟨x.1.2.1, h⟩⟩, x.2)\n      else\n        G (⟨2 * x.1 - 1, unitInterval.two_mul_sub_one_mem_iff.2 ⟨(not_le.1 h).le, x.1.2.2⟩⟩, x.2) :=\n  ContinuousMap.HomotopyRel.trans_apply _ _ _\n\n"}
{"name":"Path.Homotopy.symm_trans","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np₀ p₁ p₂ : Path x₀ x₁\nF : p₀.Homotopy p₁\nG : p₁.Homotopy p₂\n⊢ Eq (F.trans G).symm (G.symm.trans F.symm)","decl":"theorem symm_trans (F : Homotopy p₀ p₁) (G : Homotopy p₁ p₂) :\n    (F.trans G).symm = G.symm.trans F.symm :=\n  ContinuousMap.HomotopyRel.symm_trans _ _\n\n"}
{"name":"Path.Homotopy.cast_apply","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np₀ p₁ q₀ q₁ : Path x₀ x₁\nF : p₀.Homotopy p₁\nh₀ : Eq p₀ q₀\nh₁ : Eq p₁ q₁\na : Prod ↑unitInterval ↑unitInterval\n⊢ Eq ((F.cast h₀ h₁) a) (F a)","decl":"/-- Casting a `Homotopy p₀ p₁` to a `Homotopy q₀ q₁` where `p₀ = q₀` and `p₁ = q₁`. -/\n@[simps!]\ndef cast {p₀ p₁ q₀ q₁ : Path x₀ x₁} (F : Homotopy p₀ p₁) (h₀ : p₀ = q₀) (h₁ : p₁ = q₁) :\n    Homotopy q₀ q₁ :=\n  ContinuousMap.HomotopyRel.cast F (congr_arg _ h₀) (congr_arg _ h₁)\n\n"}
{"name":"Path.Homotopy.hcomp_apply","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ x₂ : X\np₀ q₀ : Path x₀ x₁\np₁ q₁ : Path x₁ x₂\nF : p₀.Homotopy q₀\nG : p₁.Homotopy q₁\nx : Prod ↑unitInterval ↑unitInterval\n⊢ Eq ((F.hcomp G) x) (dite (LE.le (↑x.2) (1 / 2)) (fun h => (F.eval x.1) ⟨HMul.hMul 2 ↑x.2, ⋯⟩) fun h => (G.eval x.1) ⟨HSub.hSub (HMul.hMul 2 ↑x.2) 1, ⋯⟩)","decl":"theorem hcomp_apply (F : Homotopy p₀ q₀) (G : Homotopy p₁ q₁) (x : I × I) :\n    F.hcomp G x =\n      if h : (x.2 : ℝ) ≤ 1 / 2 then\n        F.eval x.1 ⟨2 * x.2, (unitInterval.mul_pos_mem_iff zero_lt_two).2 ⟨x.2.2.1, h⟩⟩\n      else\n        G.eval x.1\n          ⟨2 * x.2 - 1, unitInterval.two_mul_sub_one_mem_iff.2 ⟨(not_le.1 h).le, x.2.2.2⟩⟩ :=\n  show ite _ _ _ = _ by split_ifs <;> exact Path.extend_extends _ _\n\n"}
{"name":"Path.Homotopy.hcomp_half","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ x₂ : X\np₀ q₀ : Path x₀ x₁\np₁ q₁ : Path x₁ x₂\nF : p₀.Homotopy q₀\nG : p₁.Homotopy q₁\nt : ↑unitInterval\n⊢ Eq ((F.hcomp G) { fst := t, snd := ⟨1 / 2, ⋯⟩ }) x₁","decl":"theorem hcomp_half (F : Homotopy p₀ q₀) (G : Homotopy p₁ q₁) (t : I) :\n    F.hcomp G (t, ⟨1 / 2, by norm_num, by norm_num⟩) = x₁ :=\n  show ite _ _ _ = _ by norm_num\n\n"}
{"name":"Path.Homotopy.symm₂_apply","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np q : Path x₀ x₁\nF : p.Homotopy q\nx : Prod ↑unitInterval ↑unitInterval\n⊢ Eq (F.symm₂ x) (F { fst := x.1, snd := unitInterval.symm x.2 })","decl":"/-- Suppose `F : Homotopy p q`. Then we have a `Homotopy p.symm q.symm` by reversing the second\nargument.\n-/\n@[simps]\ndef symm₂ {p q : Path x₀ x₁} (F : p.Homotopy q) : p.symm.Homotopy q.symm where\n  toFun x := F ⟨x.1, σ x.2⟩\n  map_zero_left := by simp [Path.symm]\n  map_one_left := by simp [Path.symm]\n  prop' t x hx := by\n    cases' hx with hx hx\n    · rw [hx]\n      simp\n    · rw [Set.mem_singleton_iff] at hx\n      rw [hx]\n      simp\n\n"}
{"name":"Path.Homotopy.map_apply","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx₀ x₁ : X\np q : Path x₀ x₁\nF : p.Homotopy q\nf : ContinuousMap X Y\na✝ : Prod ↑unitInterval ↑unitInterval\n⊢ Eq ((F.map f) a✝) (Function.comp (⇑f) (⇑F) a✝)","decl":"/--\nGiven `F : Homotopy p q`, and `f : C(X, Y)`, we can define a homotopy from `p.map f.continuous` to\n`q.map f.continuous`.\n-/\n@[simps]\ndef map {p q : Path x₀ x₁} (F : p.Homotopy q) (f : C(X, Y)) :\n    Homotopy (p.map f.continuous) (q.map f.continuous) where\n  toFun := f ∘ F\n  map_zero_left := by simp\n  map_one_left := by simp\n  prop' t x hx := by\n    cases' hx with hx hx\n    · simp [hx]\n    · rw [Set.mem_singleton_iff] at hx\n      simp [hx]\n\n"}
{"name":"Path.Homotopic.refl","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np : Path x₀ x₁\n⊢ p.Homotopic p","decl":"@[refl]\ntheorem refl (p : Path x₀ x₁) : p.Homotopic p :=\n  ⟨Homotopy.refl p⟩\n\n"}
{"name":"Path.Homotopic.symm","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np₀ p₁ : Path x₀ x₁\nh : p₀.Homotopic p₁\n⊢ p₁.Homotopic p₀","decl":"@[symm]\ntheorem symm ⦃p₀ p₁ : Path x₀ x₁⦄ (h : p₀.Homotopic p₁) : p₁.Homotopic p₀ :=\n  h.map Homotopy.symm\n\n"}
{"name":"Path.Homotopic.trans","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\np₀ p₁ p₂ : Path x₀ x₁\nh₀ : p₀.Homotopic p₁\nh₁ : p₁.Homotopic p₂\n⊢ p₀.Homotopic p₂","decl":"@[trans]\ntheorem trans ⦃p₀ p₁ p₂ : Path x₀ x₁⦄ (h₀ : p₀.Homotopic p₁) (h₁ : p₁.Homotopic p₂) :\n    p₀.Homotopic p₂ :=\n  h₀.map2 Homotopy.trans h₁\n\n"}
{"name":"Path.Homotopic.equivalence","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ : X\n⊢ Equivalence Path.Homotopic","decl":"theorem equivalence : Equivalence (@Homotopic X _ x₀ x₁) :=\n  ⟨refl, (symm ·), (trans · ·)⟩\n\n"}
{"name":"Path.Homotopic.map","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx₀ x₁ : X\np q : Path x₀ x₁\nh : p.Homotopic q\nf : ContinuousMap X Y\n⊢ (p.map ⋯).Homotopic (q.map ⋯)","decl":"nonrec theorem map {p q : Path x₀ x₁} (h : p.Homotopic q) (f : C(X, Y)) :\n    Homotopic (p.map f.continuous) (q.map f.continuous) :=\n  h.map fun F => F.map f\n\n"}
{"name":"Path.Homotopic.hcomp","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ x₂ : X\np₀ p₁ : Path x₀ x₁\nq₀ q₁ : Path x₁ x₂\nhp : p₀.Homotopic p₁\nhq : q₀.Homotopic q₁\n⊢ (p₀.trans q₀).Homotopic (p₁.trans q₁)","decl":"theorem hcomp {p₀ p₁ : Path x₀ x₁} {q₀ q₁ : Path x₁ x₂} (hp : p₀.Homotopic p₁)\n    (hq : q₀.Homotopic q₁) : (p₀.trans q₀).Homotopic (p₁.trans q₁) :=\n  hp.map2 Homotopy.hcomp hq\n\n"}
{"name":"Path.Homotopic.comp_lift","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ x₂ : X\nP₀ : Path x₀ x₁\nP₁ : Path x₁ x₂\n⊢ Eq (Quotient.mk (Path.Homotopic.setoid x₀ x₂) (P₀.trans P₁)) (Path.Homotopic.Quotient.comp (Quotient.mk (Path.Homotopic.setoid x₀ x₁) P₀) (Quotient.mk (Path.Homotopic.setoid x₁ x₂) P₁))","decl":"theorem comp_lift (P₀ : Path x₀ x₁) (P₁ : Path x₁ x₂) : ⟦P₀.trans P₁⟧ = Quotient.comp ⟦P₀⟧ ⟦P₁⟧ :=\n  rfl\n\n"}
{"name":"Path.Homotopic.map_lift","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx₀ x₁ : X\nP₀ : Path x₀ x₁\nf : ContinuousMap X Y\n⊢ Eq (Quotient.mk (Path.Homotopic.setoid (f x₀) (f x₁)) (P₀.map ⋯)) (Path.Homotopic.Quotient.mapFn (Quotient.mk (Path.Homotopic.setoid x₀ x₁) P₀) f)","decl":"theorem map_lift (P₀ : Path x₀ x₁) (f : C(X, Y)) : ⟦P₀.map f.continuous⟧ = Quotient.mapFn ⟦P₀⟧ f :=\n  rfl\n\n-- Porting note: Type was originally `HEq ⟦p₁⟧ ⟦p₂⟧`\n"}
{"name":"Path.Homotopic.hpath_hext","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx₀ x₁ x₂ x₃ : X\np₁ : Path x₀ x₁\np₂ : Path x₂ x₃\nhp : ∀ (t : ↑unitInterval), Eq (p₁ t) (p₂ t)\n⊢ HEq (Quotient.mk (Path.Homotopic.setoid x₀ x₁) p₁) (Quotient.mk (Path.Homotopic.setoid x₂ x₃) p₂)","decl":"theorem hpath_hext {p₁ : Path x₀ x₁} {p₂ : Path x₂ x₃} (hp : ∀ t, p₁ t = p₂ t) :\n    @HEq (Path.Homotopic.Quotient _ _) ⟦p₁⟧ (Path.Homotopic.Quotient _ _) ⟦p₂⟧ := by\n  obtain rfl : x₀ = x₂ := by convert hp 0 <;> simp\n  obtain rfl : x₁ = x₃ := by convert hp 1 <;> simp\n  rw [heq_iff_eq]; congr; ext t; exact hp t\n\n"}
{"name":"Path.toHomotopyConst_apply","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx₀ x₁ : X\np : Path x₀ x₁\na✝ : Prod (↑unitInterval) Y\n⊢ Eq (p.toHomotopyConst a✝) (p a✝.1)","decl":"/-- A path `Path x₀ x₁` generates a homotopy between constant functions `fun _ ↦ x₀` and\n`fun _ ↦ x₁`. -/\n@[simps!]\ndef toHomotopyConst (p : Path x₀ x₁) :\n    (ContinuousMap.const Y x₀).Homotopy (ContinuousMap.const Y x₁) where\n  toContinuousMap := p.toContinuousMap.comp ContinuousMap.fst\n  map_zero_left _ := p.source\n  map_one_left _ := p.target\n\n"}
{"name":"ContinuousMap.homotopic_const_iff","module":"Mathlib.Topology.Homotopy.Path","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\nx₀ x₁ : X\ninst✝ : Nonempty Y\n⊢ Iff ((ContinuousMap.const Y x₀).Homotopic (ContinuousMap.const Y x₁)) (Joined x₀ x₁)","decl":"/-- Two constant continuous maps with nonempty domain are homotopic if and only if their values are\njoined by a path in the codomain. -/\n@[simp]\ntheorem ContinuousMap.homotopic_const_iff [Nonempty Y] :\n    (ContinuousMap.const Y x₀).Homotopic (ContinuousMap.const Y x₁) ↔ Joined x₀ x₁ := by\n  inhabit Y\n  refine ⟨fun ⟨H⟩ ↦ ⟨⟨(H.toContinuousMap.comp .prodSwap).curry default, ?_, ?_⟩⟩,\n    fun ⟨p⟩ ↦ ⟨p.toHomotopyConst⟩⟩ <;> simp\n\n"}
