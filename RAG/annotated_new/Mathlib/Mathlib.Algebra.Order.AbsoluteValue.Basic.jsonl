{"name":"AbsoluteValue.mk.inj","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\ntoMulHom✝ : MulHom R S\nnonneg'✝ : ∀ (x : R), LE.le 0 (toMulHom✝.toFun x)\neq_zero'✝ : ∀ (x : R), Iff (Eq (toMulHom✝.toFun x) 0) (Eq x 0)\nadd_le'✝ : ∀ (x y : R), LE.le (toMulHom✝.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulHom✝.toFun x) (toMulHom✝.toFun y))\ntoMulHom : MulHom R S\nnonneg' : ∀ (x : R), LE.le 0 (toMulHom.toFun x)\neq_zero' : ∀ (x : R), Iff (Eq (toMulHom.toFun x) 0) (Eq x 0)\nadd_le' : ∀ (x y : R), LE.le (toMulHom.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulHom.toFun x) (toMulHom.toFun y))\nx✝ : Eq { toMulHom := toMulHom✝, nonneg' := nonneg'✝, eq_zero' := eq_zero'✝, add_le' := add_le'✝ } { toMulHom := toMulHom, nonneg' := nonneg', eq_zero' := eq_zero', add_le' := add_le' }\n⊢ Eq toMulHom✝ toMulHom","decl":"/-- `AbsoluteValue R S` is the type of absolute values on `R` mapping to `S`:\nthe maps that preserve `*`, are nonnegative, positive definite and satisfy the triangle equality. -/\nstructure AbsoluteValue (R S : Type*) [Semiring R] [OrderedSemiring S] extends R →ₙ* S where\n  /-- The absolute value is nonnegative -/\n  nonneg' : ∀ x, 0 ≤ toFun x\n  /-- The absolute value is positive definitive -/\n  eq_zero' : ∀ x, toFun x = 0 ↔ x = 0\n  /-- The absolute value satisfies the triangle inequality -/\n  add_le' : ∀ x y, toFun (x + y) ≤ toFun x + toFun y\n\n"}
{"name":"AbsoluteValue.mk.injEq","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\ntoMulHom✝ : MulHom R S\nnonneg'✝ : ∀ (x : R), LE.le 0 (toMulHom✝.toFun x)\neq_zero'✝ : ∀ (x : R), Iff (Eq (toMulHom✝.toFun x) 0) (Eq x 0)\nadd_le'✝ : ∀ (x y : R), LE.le (toMulHom✝.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulHom✝.toFun x) (toMulHom✝.toFun y))\ntoMulHom : MulHom R S\nnonneg' : ∀ (x : R), LE.le 0 (toMulHom.toFun x)\neq_zero' : ∀ (x : R), Iff (Eq (toMulHom.toFun x) 0) (Eq x 0)\nadd_le' : ∀ (x y : R), LE.le (toMulHom.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulHom.toFun x) (toMulHom.toFun y))\n⊢ Eq (Eq { toMulHom := toMulHom✝, nonneg' := nonneg'✝, eq_zero' := eq_zero'✝, add_le' := add_le'✝ } { toMulHom := toMulHom, nonneg' := nonneg', eq_zero' := eq_zero', add_le' := add_le' }) (Eq toMulHom✝ toMulHom)","decl":"/-- `AbsoluteValue R S` is the type of absolute values on `R` mapping to `S`:\nthe maps that preserve `*`, are nonnegative, positive definite and satisfy the triangle equality. -/\nstructure AbsoluteValue (R S : Type*) [Semiring R] [OrderedSemiring S] extends R →ₙ* S where\n  /-- The absolute value is nonnegative -/\n  nonneg' : ∀ x, 0 ≤ toFun x\n  /-- The absolute value is positive definitive -/\n  eq_zero' : ∀ x, toFun x = 0 ↔ x = 0\n  /-- The absolute value satisfies the triangle inequality -/\n  add_le' : ∀ x y, toFun (x + y) ≤ toFun x + toFun y\n\n"}
{"name":"AbsoluteValue.eq_zero'","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nself : AbsoluteValue R S\nx : R\n⊢ Iff (Eq (self.toFun x) 0) (Eq x 0)","decl":"/-- `AbsoluteValue R S` is the type of absolute values on `R` mapping to `S`:\nthe maps that preserve `*`, are nonnegative, positive definite and satisfy the triangle equality. -/\nstructure AbsoluteValue (R S : Type*) [Semiring R] [OrderedSemiring S] extends R →ₙ* S where\n  /-- The absolute value is nonnegative -/\n  nonneg' : ∀ x, 0 ≤ toFun x\n  /-- The absolute value is positive definitive -/\n  eq_zero' : ∀ x, toFun x = 0 ↔ x = 0\n  /-- The absolute value satisfies the triangle inequality -/\n  add_le' : ∀ x y, toFun (x + y) ≤ toFun x + toFun y\n\n"}
{"name":"AbsoluteValue.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝³ : Semiring R\ninst✝² : OrderedSemiring S\ninst✝¹ : SizeOf R\ninst✝ : SizeOf S\ntoMulHom : MulHom R S\nnonneg' : ∀ (x : R), LE.le 0 (toMulHom.toFun x)\neq_zero' : ∀ (x : R), Iff (Eq (toMulHom.toFun x) 0) (Eq x 0)\nadd_le' : ∀ (x y : R), LE.le (toMulHom.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulHom.toFun x) (toMulHom.toFun y))\n⊢ Eq (SizeOf.sizeOf { toMulHom := toMulHom, nonneg' := nonneg', eq_zero' := eq_zero', add_le' := add_le' }) (HAdd.hAdd 1 (SizeOf.sizeOf toMulHom))","decl":"/-- `AbsoluteValue R S` is the type of absolute values on `R` mapping to `S`:\nthe maps that preserve `*`, are nonnegative, positive definite and satisfy the triangle equality. -/\nstructure AbsoluteValue (R S : Type*) [Semiring R] [OrderedSemiring S] extends R →ₙ* S where\n  /-- The absolute value is nonnegative -/\n  nonneg' : ∀ x, 0 ≤ toFun x\n  /-- The absolute value is positive definitive -/\n  eq_zero' : ∀ x, toFun x = 0 ↔ x = 0\n  /-- The absolute value satisfies the triangle inequality -/\n  add_le' : ∀ x y, toFun (x + y) ≤ toFun x + toFun y\n\n"}
{"name":"AbsoluteValue.nonneg'","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nself : AbsoluteValue R S\nx : R\n⊢ LE.le 0 (self.toFun x)","decl":"/-- `AbsoluteValue R S` is the type of absolute values on `R` mapping to `S`:\nthe maps that preserve `*`, are nonnegative, positive definite and satisfy the triangle equality. -/\nstructure AbsoluteValue (R S : Type*) [Semiring R] [OrderedSemiring S] extends R →ₙ* S where\n  /-- The absolute value is nonnegative -/\n  nonneg' : ∀ x, 0 ≤ toFun x\n  /-- The absolute value is positive definitive -/\n  eq_zero' : ∀ x, toFun x = 0 ↔ x = 0\n  /-- The absolute value satisfies the triangle inequality -/\n  add_le' : ∀ x y, toFun (x + y) ≤ toFun x + toFun y\n\n"}
{"name":"AbsoluteValue.add_le'","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nself : AbsoluteValue R S\nx y : R\n⊢ LE.le (self.toFun (HAdd.hAdd x y)) (HAdd.hAdd (self.toFun x) (self.toFun y))","decl":"/-- `AbsoluteValue R S` is the type of absolute values on `R` mapping to `S`:\nthe maps that preserve `*`, are nonnegative, positive definite and satisfy the triangle equality. -/\nstructure AbsoluteValue (R S : Type*) [Semiring R] [OrderedSemiring S] extends R →ₙ* S where\n  /-- The absolute value is nonnegative -/\n  nonneg' : ∀ x, 0 ≤ toFun x\n  /-- The absolute value is positive definitive -/\n  eq_zero' : ∀ x, toFun x = 0 ↔ x = 0\n  /-- The absolute value satisfies the triangle inequality -/\n  add_le' : ∀ x y, toFun (x + y) ≤ toFun x + toFun y\n\n"}
{"name":"AbsoluteValue.zeroHomClass","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\n⊢ ZeroHomClass (AbsoluteValue R S) R S","decl":"instance zeroHomClass : ZeroHomClass (AbsoluteValue R S) R S where\n  map_zero f := (f.eq_zero' _).2 rfl\n\n"}
{"name":"AbsoluteValue.mulHomClass","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\n⊢ MulHomClass (AbsoluteValue R S) R S","decl":"instance mulHomClass : MulHomClass (AbsoluteValue R S) R S :=\n  { AbsoluteValue.zeroHomClass (R := R) (S := S) with map_mul := fun f => f.map_mul' }\n\n"}
{"name":"AbsoluteValue.nonnegHomClass","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\n⊢ NonnegHomClass (AbsoluteValue R S) R S","decl":"instance nonnegHomClass : NonnegHomClass (AbsoluteValue R S) R S :=\n  { AbsoluteValue.zeroHomClass (R := R) (S := S) with apply_nonneg := fun f => f.nonneg' }\n\n"}
{"name":"AbsoluteValue.subadditiveHomClass","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\n⊢ SubadditiveHomClass (AbsoluteValue R S) R S","decl":"instance subadditiveHomClass : SubadditiveHomClass (AbsoluteValue R S) R S :=\n  { AbsoluteValue.zeroHomClass (R := R) (S := S) with map_add_le_add := fun f => f.add_le' }\n\n"}
{"name":"AbsoluteValue.coe_mk","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nf : MulHom R S\nh₁ : ∀ (x : R), LE.le 0 (f.toFun x)\nh₂ : ∀ (x : R), Iff (Eq (f.toFun x) 0) (Eq x 0)\nh₃ : ∀ (x y : R), LE.le (f.toFun (HAdd.hAdd x y)) (HAdd.hAdd (f.toFun x) (f.toFun y))\n⊢ Eq ⇑{ toMulHom := f, nonneg' := h₁, eq_zero' := h₂, add_le' := h₃ } ⇑f","decl":"@[simp]\ntheorem coe_mk (f : R →ₙ* S) {h₁ h₂ h₃} : (AbsoluteValue.mk f h₁ h₂ h₃ : R → S) = f :=\n  rfl\n\n"}
{"name":"AbsoluteValue.ext_iff","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nf g : AbsoluteValue R S\n⊢ Iff (Eq f g) (∀ (x : R), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext ⦃f g : AbsoluteValue R S⦄ : (∀ x, f x = g x) → f = g :=\n  DFunLike.ext _ _\n\n"}
{"name":"AbsoluteValue.ext","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nf g : AbsoluteValue R S\na✝ : ∀ (x : R), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext ⦃f g : AbsoluteValue R S⦄ : (∀ x, f x = g x) → f = g :=\n  DFunLike.ext _ _\n\n"}
{"name":"AbsoluteValue.coe_toMulHom","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\n⊢ Eq ⇑abv.toMulHom ⇑abv","decl":"@[simp]\ntheorem coe_toMulHom : ⇑abv.toMulHom = abv :=\n  rfl\n\n"}
{"name":"AbsoluteValue.nonneg","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\nx : R\n⊢ LE.le 0 (abv x)","decl":"@[bound]\nprotected theorem nonneg (x : R) : 0 ≤ abv x :=\n  abv.nonneg' x\n\n"}
{"name":"AbsoluteValue.eq_zero","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\nx : R\n⊢ Iff (Eq (abv x) 0) (Eq x 0)","decl":"@[simp]\nprotected theorem eq_zero {x : R} : abv x = 0 ↔ x = 0 :=\n  abv.eq_zero' x\n\n"}
{"name":"AbsoluteValue.add_le","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\nx y : R\n⊢ LE.le (abv (HAdd.hAdd x y)) (HAdd.hAdd (abv x) (abv y))","decl":"@[bound]\nprotected theorem add_le (x y : R) : abv (x + y) ≤ abv x + abv y :=\n  abv.add_le' x y\n\n"}
{"name":"AbsoluteValue.listSum_le","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\nl : List R\n⊢ LE.le (abv l.sum) (List.map (⇑abv) l).sum","decl":"/-- The triangle inequality for an `AbsoluteValue` applied to a list. -/\nlemma listSum_le (l : List R) : abv l.sum ≤ (l.map abv).sum := by\n  induction l with\n  | nil => simp\n  | cons head tail ih => exact (abv.add_le ..).trans <| add_le_add_left ih (abv head)\n\n"}
{"name":"AbsoluteValue.map_mul","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\nx y : R\n⊢ Eq (abv (HMul.hMul x y)) (HMul.hMul (abv x) (abv y))","decl":"@[simp]\nprotected theorem map_mul (x y : R) : abv (x * y) = abv x * abv y :=\n  abv.map_mul' x y\n\n"}
{"name":"AbsoluteValue.ne_zero_iff","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\nx : R\n⊢ Iff (Ne (abv x) 0) (Ne x 0)","decl":"protected theorem ne_zero_iff {x : R} : abv x ≠ 0 ↔ x ≠ 0 :=\n  abv.eq_zero.not\n\n"}
{"name":"AbsoluteValue.pos","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\nx : R\nhx : Ne x 0\n⊢ LT.lt 0 (abv x)","decl":"protected theorem pos {x : R} (hx : x ≠ 0) : 0 < abv x :=\n  lt_of_le_of_ne (abv.nonneg x) (Ne.symm <| mt abv.eq_zero.mp hx)\n\n"}
{"name":"AbsoluteValue.pos_iff","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\nx : R\n⊢ Iff (LT.lt 0 (abv x)) (Ne x 0)","decl":"@[simp]\nprotected theorem pos_iff {x : R} : 0 < abv x ↔ x ≠ 0 :=\n  ⟨fun h₁ => mt abv.eq_zero.mpr h₁.ne', abv.pos⟩\n\n"}
{"name":"AbsoluteValue.ne_zero","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\nx : R\nhx : Ne x 0\n⊢ Ne (abv x) 0","decl":"protected theorem ne_zero {x : R} (hx : x ≠ 0) : abv x ≠ 0 :=\n  (abv.pos hx).ne'\n\n"}
{"name":"AbsoluteValue.map_one_of_isLeftRegular","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\nh : IsLeftRegular (abv 1)\n⊢ Eq (abv 1) 1","decl":"theorem map_one_of_isLeftRegular (h : IsLeftRegular (abv 1)) : abv 1 = 1 :=\n  h <| by simp [← abv.map_mul]\n\n"}
{"name":"AbsoluteValue.map_zero","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\n⊢ Eq (abv 0) 0","decl":"@[simp]\nprotected theorem map_zero : abv 0 = 0 :=\n  abv.eq_zero.2 rfl\n\n"}
{"name":"AbsoluteValue.sub_le","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Ring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\na b c : R\n⊢ LE.le (abv (HSub.hSub a c)) (HAdd.hAdd (abv (HSub.hSub a b)) (abv (HSub.hSub b c)))","decl":"protected theorem sub_le (a b c : R) : abv (a - c) ≤ abv (a - b) + abv (b - c) := by\n  simpa [sub_eq_add_neg, add_assoc] using abv.add_le (a - b) (b - c)\n\n"}
{"name":"AbsoluteValue.map_sub_eq_zero_iff","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Ring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\na b : R\n⊢ Iff (Eq (abv (HSub.hSub a b)) 0) (Eq a b)","decl":"@[simp high] -- Porting note: added `high` to apply it before `AbsoluteValue.eq_zero`\ntheorem map_sub_eq_zero_iff (a b : R) : abv (a - b) = 0 ↔ a = b :=\n  abv.eq_zero.trans sub_eq_zero\n\n"}
{"name":"AbsoluteValue.map_one","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝³ : Semiring R\ninst✝² : OrderedRing S\nabv : AbsoluteValue R S\ninst✝¹ : IsDomain S\ninst✝ : Nontrivial R\n⊢ Eq (abv 1) 1","decl":"@[simp]\nprotected theorem map_one : abv 1 = 1 :=\n  abv.map_one_of_isLeftRegular (isRegular_of_ne_zero <| abv.ne_zero one_ne_zero).left\n\n"}
{"name":"AbsoluteValue.monoidWithZeroHomClass","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝³ : Semiring R\ninst✝² : OrderedRing S\ninst✝¹ : IsDomain S\ninst✝ : Nontrivial R\n⊢ MonoidWithZeroHomClass (AbsoluteValue R S) R S","decl":"instance monoidWithZeroHomClass : MonoidWithZeroHomClass (AbsoluteValue R S) R S :=\n  { AbsoluteValue.mulHomClass with\n    map_zero := fun f => f.map_zero\n    map_one := fun f => f.map_one }\n\n"}
{"name":"AbsoluteValue.coe_toMonoidWithZeroHom","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝³ : Semiring R\ninst✝² : OrderedRing S\nabv : AbsoluteValue R S\ninst✝¹ : IsDomain S\ninst✝ : Nontrivial R\n⊢ Eq ⇑abv.toMonoidWithZeroHom ⇑abv","decl":"@[simp]\ntheorem coe_toMonoidWithZeroHom : ⇑abv.toMonoidWithZeroHom = abv :=\n  rfl\n\n"}
{"name":"AbsoluteValue.coe_toMonoidHom","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝³ : Semiring R\ninst✝² : OrderedRing S\nabv : AbsoluteValue R S\ninst✝¹ : IsDomain S\ninst✝ : Nontrivial R\n⊢ Eq ⇑abv.toMonoidHom ⇑abv","decl":"@[simp]\ntheorem coe_toMonoidHom : ⇑abv.toMonoidHom = abv :=\n  rfl\n\n"}
{"name":"AbsoluteValue.map_pow","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝³ : Semiring R\ninst✝² : OrderedRing S\nabv : AbsoluteValue R S\ninst✝¹ : IsDomain S\ninst✝ : Nontrivial R\na : R\nn : Nat\n⊢ Eq (abv (HPow.hPow a n)) (HPow.hPow (abv a) n)","decl":"@[simp]\nprotected theorem map_pow (a : R) (n : ℕ) : abv (a ^ n) = abv a ^ n :=\n  abv.toMonoidHom.map_pow a n\n\n"}
{"name":"AbsoluteValue.apply_nat_le_self","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝² : Semiring R\ninst✝¹ : OrderedRing S\nabv : AbsoluteValue R S\ninst✝ : IsDomain S\nn : Nat\n⊢ LE.le (abv ↑n) ↑n","decl":"omit [Nontrivial R] in\n/-- An absolute value satisfies `f (n : R) ≤ n` for every `n : ℕ`. -/\nlemma apply_nat_le_self (n : ℕ) : abv n ≤ n := by\n  cases subsingleton_or_nontrivial R\n  · simp [Subsingleton.eq_zero (n : R)]\n  induction n with\n  | zero => simp\n  | succ n hn =>\n    simp only [Nat.cast_succ]\n    calc\n      abv (n + 1) ≤ abv n + abv 1 := abv.add_le ..\n      _ = abv n + 1 := congrArg (abv n + ·) abv.map_one\n      _ ≤ n + 1 := add_le_add_right hn 1\n\n"}
{"name":"AbsoluteValue.le_sub","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Ring R\ninst✝ : OrderedRing S\nabv : AbsoluteValue R S\na b : R\n⊢ LE.le (HSub.hSub (abv a) (abv b)) (abv (HSub.hSub a b))","decl":"@[bound]\nprotected theorem le_sub (a b : R) : abv a - abv b ≤ abv (a - b) :=\n  sub_le_iff_le_add.2 <| by simpa using abv.add_le (a - b) b\n\n"}
{"name":"AbsoluteValue.map_neg","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝² : OrderedCommRing S\ninst✝¹ : Ring R\nabv : AbsoluteValue R S\ninst✝ : NoZeroDivisors S\na : R\n⊢ Eq (abv (Neg.neg a)) (abv a)","decl":"@[simp]\nprotected theorem map_neg (a : R) : abv (-a) = abv a := by\n  by_cases ha : a = 0; · simp [ha]\n  refine\n    (mul_self_eq_mul_self_iff.mp (by rw [← abv.map_mul, neg_mul_neg, abv.map_mul])).resolve_right ?_\n  exact ((neg_lt_zero.mpr (abv.pos ha)).trans (abv.pos (neg_ne_zero.mpr ha))).ne'\n\n"}
{"name":"AbsoluteValue.map_sub","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝² : OrderedCommRing S\ninst✝¹ : Ring R\nabv : AbsoluteValue R S\ninst✝ : NoZeroDivisors S\na b : R\n⊢ Eq (abv (HSub.hSub a b)) (abv (HSub.hSub b a))","decl":"protected theorem map_sub (a b : R) : abv (a - b) = abv (b - a) := by rw [← neg_sub, abv.map_neg]\n\n"}
{"name":"AbsoluteValue.le_add","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝² : OrderedCommRing S\ninst✝¹ : Ring R\nabv : AbsoluteValue R S\ninst✝ : NoZeroDivisors S\na b : R\n⊢ LE.le (HSub.hSub (abv a) (abv b)) (abv (HAdd.hAdd a b))","decl":"/-- Bound `abv (a + b)` from below -/\n@[bound]\nprotected theorem le_add (a b : R) : abv a - abv b ≤ abv (a + b) := by\n  simpa only [tsub_le_iff_right, add_neg_cancel_right, abv.map_neg] using abv.add_le (a + b) (-b)\n\n"}
{"name":"AbsoluteValue.sub_le_add","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝² : OrderedCommRing S\ninst✝¹ : Ring R\nabv : AbsoluteValue R S\ninst✝ : NoZeroDivisors S\na b : R\n⊢ LE.le (abv (HSub.hSub a b)) (HAdd.hAdd (abv a) (abv b))","decl":"/-- Bound `abv (a - b)` from above -/\n@[bound]\nlemma sub_le_add (a b : R) : abv (a - b) ≤ abv a + abv b := by\n  simpa only [← sub_eq_add_neg, AbsoluteValue.map_neg] using abv.add_le a (-b)\n\n"}
{"name":"AbsoluteValue.instMulRingNormClassOfNontrivialOfIsDomain","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝⁴ : OrderedCommRing S\ninst✝³ : Ring R\ninst✝² : NoZeroDivisors S\ninst✝¹ : Nontrivial R\ninst✝ : IsDomain S\n⊢ MulRingNormClass (AbsoluteValue R S) R S","decl":"instance [Nontrivial R] [IsDomain S] : MulRingNormClass (AbsoluteValue R S) R S :=\n  { AbsoluteValue.subadditiveHomClass,\n    AbsoluteValue.monoidWithZeroHomClass with\n    map_neg_eq_map := fun f => f.map_neg\n    eq_zero_of_map_eq_zero := fun f _ => f.eq_zero.1 }\n\n"}
{"name":"AbsoluteValue.apply_natAbs_eq","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝² : OrderedCommRing S\ninst✝¹ : Ring R\nabv : AbsoluteValue R S\ninst✝ : NoZeroDivisors S\nx : Int\n⊢ Eq (abv ↑x.natAbs) (abv ↑x)","decl":"open Int in\nlemma apply_natAbs_eq (x : ℤ) : abv (natAbs x) = abv x := by\n  obtain ⟨_, rfl | rfl⟩ := eq_nat_or_neg x <;> simp\n\n"}
{"name":"AbsoluteValue.eq_on_nat_iff_eq_on_int","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝² : OrderedCommRing S\ninst✝¹ : Ring R\ninst✝ : NoZeroDivisors S\nf g : AbsoluteValue R S\n⊢ Iff (∀ (n : Nat), Eq (f ↑n) (g ↑n)) (∀ (n : Int), Eq (f ↑n) (g ↑n))","decl":"open Int in\n/-- Values of an absolute value coincide on the image of `ℕ` in `R`\nif and only if they coincide on the image of `ℤ` in `R`. -/\nlemma eq_on_nat_iff_eq_on_int {f g : AbsoluteValue R S} :\n    (∀ n : ℕ , f n = g n) ↔ ∀ n : ℤ , f n = g n := by\n  refine ⟨fun h z ↦ ?_, fun a n ↦ mod_cast a n⟩\n  obtain ⟨n , rfl | rfl⟩ := eq_nat_or_neg z <;> simp [h n]\n\n"}
{"name":"AbsoluteValue.abs_apply","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_6\ninst✝ : LinearOrderedRing S\na : S\n⊢ Eq (AbsoluteValue.abs a) (abs a)","decl":"/-- `AbsoluteValue.abs` is `abs` as a bundled `AbsoluteValue`. -/\n@[simps]\nprotected def abs : AbsoluteValue S S where\n  toFun := abs\n  nonneg' := abs_nonneg\n  eq_zero' _ := abs_eq_zero\n  add_le' := abs_add\n  map_mul' := abs_mul\n\n"}
{"name":"AbsoluteValue.abs_abv_sub_le_abv_sub","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\nS : Type u_6\ninst✝¹ : Ring R\ninst✝ : LinearOrderedCommRing S\nabv : AbsoluteValue R S\na b : R\n⊢ LE.le (abs (HSub.hSub (abv a) (abv b))) (abv (HSub.hSub a b))","decl":"@[bound]\ntheorem abs_abv_sub_le_abv_sub (a b : R) : abs (abv a - abv b) ≤ abv (a - b) :=\n  abs_sub_le_iff.2 ⟨abv.le_sub _ _, by rw [abv.map_sub]; apply abv.le_sub⟩\n\n"}
{"name":"AbsoluteValue.trivial_apply","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : DecidablePred fun x => Eq x 0\ninst✝² : NoZeroDivisors R\nS : Type u_6\ninst✝¹ : OrderedSemiring S\ninst✝ : Nontrivial S\nx : R\nhx : Ne x 0\n⊢ Eq (AbsoluteValue.trivial x) 1","decl":"@[simp]\nlemma trivial_apply {x : R} (hx : x ≠ 0) : AbsoluteValue.trivial (S := S) x = 1 :=\n  if_neg hx\n\n"}
{"name":"AbsoluteValue.isNontrivial_iff_ne_trivial","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\ninst✝⁴ : Semiring R\nS : Type u_6\ninst✝³ : OrderedSemiring S\ninst✝² : DecidablePred fun x => Eq x 0\ninst✝¹ : NoZeroDivisors R\ninst✝ : Nontrivial S\nv : AbsoluteValue R S\n⊢ Iff v.IsNontrivial (Ne v AbsoluteValue.trivial)","decl":"lemma isNontrivial_iff_ne_trivial [DecidablePred fun x : R ↦ x = 0] [NoZeroDivisors R]\n    [Nontrivial S] (v : AbsoluteValue R S) :\n    v.IsNontrivial ↔ v ≠ .trivial := by\n  refine ⟨fun ⟨x, hx₀, hx₁⟩ h ↦ hx₁ <| h.symm ▸ trivial_apply hx₀, fun H ↦ ?_⟩\n  contrapose! H\n  simp only [IsNontrivial] at H\n  push_neg at H\n  ext1 x\n  rcases eq_or_ne x 0 with rfl | hx\n  · simp\n  · simp [H, hx]\n\n"}
{"name":"AbsoluteValue.not_isNontrivial_iff","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\ninst✝¹ : Semiring R\nS : Type u_6\ninst✝ : OrderedSemiring S\nv : AbsoluteValue R S\n⊢ Iff (Not v.IsNontrivial) (∀ (x : R), Ne x 0 → Eq (v x) 1)","decl":"lemma not_isNontrivial_iff (v : AbsoluteValue R S) :\n    ¬ v.IsNontrivial ↔ ∀ x ≠ 0, v x = 1 := by\n  simp only [IsNontrivial]\n  push_neg\n  rfl\n\n"}
{"name":"AbsoluteValue.not_isNontrivial_apply","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_5\ninst✝¹ : Semiring R\nS : Type u_6\ninst✝ : OrderedSemiring S\nv : AbsoluteValue R S\nhv : Not v.IsNontrivial\nx : R\nhx : Ne x 0\n⊢ Eq (v x) 1","decl":"@[simp]\nlemma not_isNontrivial_apply {v : AbsoluteValue R S} (hv : ¬ v.IsNontrivial) {x : R} (hx : x ≠ 0) :\n    v x = 1 :=\n  v.not_isNontrivial_iff.mp hv _ hx\n\n"}
{"name":"AbsoluteValue.IsNontrivial.exists_abv_gt_one","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"F : Type u_7\nS : Type u_8\ninst✝¹ : Field F\ninst✝ : LinearOrderedField S\nv : AbsoluteValue F S\nh : v.IsNontrivial\n⊢ Exists fun x => LT.lt 1 (v x)","decl":"lemma IsNontrivial.exists_abv_gt_one {F S : Type*} [Field F] [LinearOrderedField S]\n    {v : AbsoluteValue F S} (h : v.IsNontrivial) :\n    ∃ x, 1 < v x := by\n  obtain ⟨x, hx₀, hx₁⟩ := h\n  rcases hx₁.lt_or_lt with h | h\n  · refine ⟨x⁻¹, ?_⟩\n    rw [map_inv₀]\n    exact (one_lt_inv₀ <| v.pos hx₀).mpr h\n  · exact ⟨x, h⟩\n\n"}
{"name":"AbsoluteValue.IsNontrivial.exists_abv_lt_one","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"F : Type u_7\nS : Type u_8\ninst✝¹ : Field F\ninst✝ : LinearOrderedField S\nv : AbsoluteValue F S\nh : v.IsNontrivial\n⊢ Exists fun x => And (Ne x 0) (LT.lt (v x) 1)","decl":"lemma IsNontrivial.exists_abv_lt_one {F S : Type*} [Field F] [LinearOrderedField S]\n    {v : AbsoluteValue F S} (h : v.IsNontrivial) :\n    ∃ x ≠ 0, v x < 1 := by\n  obtain ⟨y, hy⟩ := h.exists_abv_gt_one\n  have hy₀ := v.ne_zero_iff.mp <| (zero_lt_one.trans hy).ne'\n  refine ⟨y⁻¹, inv_ne_zero hy₀, ?_⟩\n  rw [map_inv₀]\n  exact (inv_lt_one₀ <| v.pos hy₀).mpr hy\n\n"}
{"name":"IsAbsoluteValue.abv_add'","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝¹ : OrderedSemiring S\nR : Type u_6\ninst✝ : Semiring R\nf : R → S\nself : IsAbsoluteValue f\nx y : R\n⊢ LE.le (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))","decl":"/-- A function `f` is an absolute value if it is nonnegative, zero only at 0, additive, and\nmultiplicative.\n\nSee also the type `AbsoluteValue` which represents a bundled version of absolute values.\n-/\nclass IsAbsoluteValue {S} [OrderedSemiring S] {R} [Semiring R] (f : R → S) : Prop where\n  /-- The absolute value is nonnegative -/\n  abv_nonneg' : ∀ x, 0 ≤ f x\n  /-- The absolute value is positive definitive -/\n  abv_eq_zero' : ∀ {x}, f x = 0 ↔ x = 0\n  /-- The absolute value satisfies the triangle inequality -/\n  abv_add' : ∀ x y, f (x + y) ≤ f x + f y\n  /-- The absolute value is multiplicative -/\n  abv_mul' : ∀ x y, f (x * y) = f x * f y\n\n"}
{"name":"IsAbsoluteValue.abv_eq_zero'","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝¹ : OrderedSemiring S\nR : Type u_6\ninst✝ : Semiring R\nf : R → S\nself : IsAbsoluteValue f\nx : R\n⊢ Iff (Eq (f x) 0) (Eq x 0)","decl":"/-- A function `f` is an absolute value if it is nonnegative, zero only at 0, additive, and\nmultiplicative.\n\nSee also the type `AbsoluteValue` which represents a bundled version of absolute values.\n-/\nclass IsAbsoluteValue {S} [OrderedSemiring S] {R} [Semiring R] (f : R → S) : Prop where\n  /-- The absolute value is nonnegative -/\n  abv_nonneg' : ∀ x, 0 ≤ f x\n  /-- The absolute value is positive definitive -/\n  abv_eq_zero' : ∀ {x}, f x = 0 ↔ x = 0\n  /-- The absolute value satisfies the triangle inequality -/\n  abv_add' : ∀ x y, f (x + y) ≤ f x + f y\n  /-- The absolute value is multiplicative -/\n  abv_mul' : ∀ x y, f (x * y) = f x * f y\n\n"}
{"name":"IsAbsoluteValue.abv_nonneg'","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝¹ : OrderedSemiring S\nR : Type u_6\ninst✝ : Semiring R\nf : R → S\nself : IsAbsoluteValue f\nx : R\n⊢ LE.le 0 (f x)","decl":"/-- A function `f` is an absolute value if it is nonnegative, zero only at 0, additive, and\nmultiplicative.\n\nSee also the type `AbsoluteValue` which represents a bundled version of absolute values.\n-/\nclass IsAbsoluteValue {S} [OrderedSemiring S] {R} [Semiring R] (f : R → S) : Prop where\n  /-- The absolute value is nonnegative -/\n  abv_nonneg' : ∀ x, 0 ≤ f x\n  /-- The absolute value is positive definitive -/\n  abv_eq_zero' : ∀ {x}, f x = 0 ↔ x = 0\n  /-- The absolute value satisfies the triangle inequality -/\n  abv_add' : ∀ x y, f (x + y) ≤ f x + f y\n  /-- The absolute value is multiplicative -/\n  abv_mul' : ∀ x y, f (x * y) = f x * f y\n\n"}
{"name":"IsAbsoluteValue.abv_mul'","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝¹ : OrderedSemiring S\nR : Type u_6\ninst✝ : Semiring R\nf : R → S\nself : IsAbsoluteValue f\nx y : R\n⊢ Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))","decl":"/-- A function `f` is an absolute value if it is nonnegative, zero only at 0, additive, and\nmultiplicative.\n\nSee also the type `AbsoluteValue` which represents a bundled version of absolute values.\n-/\nclass IsAbsoluteValue {S} [OrderedSemiring S] {R} [Semiring R] (f : R → S) : Prop where\n  /-- The absolute value is nonnegative -/\n  abv_nonneg' : ∀ x, 0 ≤ f x\n  /-- The absolute value is positive definitive -/\n  abv_eq_zero' : ∀ {x}, f x = 0 ↔ x = 0\n  /-- The absolute value satisfies the triangle inequality -/\n  abv_add' : ∀ x y, f (x + y) ≤ f x + f y\n  /-- The absolute value is multiplicative -/\n  abv_mul' : ∀ x y, f (x * y) = f x * f y\n\n"}
{"name":"IsAbsoluteValue.abv_nonneg","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝² : OrderedSemiring S\nR : Type u_6\ninst✝¹ : Semiring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\nx : R\n⊢ LE.le 0 (abv x)","decl":"lemma abv_nonneg (x) : 0 ≤ abv x := abv_nonneg' x\n\n"}
{"name":"IsAbsoluteValue.abv_eq_zero","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝² : OrderedSemiring S\nR : Type u_6\ninst✝¹ : Semiring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\nx : R\n⊢ Iff (Eq (abv x) 0) (Eq x 0)","decl":"lemma abv_eq_zero {x} : abv x = 0 ↔ x = 0 := abv_eq_zero'\n\n"}
{"name":"IsAbsoluteValue.abv_add","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝² : OrderedSemiring S\nR : Type u_6\ninst✝¹ : Semiring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\nx y : R\n⊢ LE.le (abv (HAdd.hAdd x y)) (HAdd.hAdd (abv x) (abv y))","decl":"lemma abv_add (x y) : abv (x + y) ≤ abv x + abv y := abv_add' x y\n\n"}
{"name":"IsAbsoluteValue.abv_mul","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝² : OrderedSemiring S\nR : Type u_6\ninst✝¹ : Semiring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\nx y : R\n⊢ Eq (abv (HMul.hMul x y)) (HMul.hMul (abv x) (abv y))","decl":"lemma abv_mul (x y) : abv (x * y) = abv x * abv y := abv_mul' x y\n\n"}
{"name":"AbsoluteValue.isAbsoluteValue","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝¹ : OrderedSemiring S\nR : Type u_6\ninst✝ : Semiring R\nabv : AbsoluteValue R S\n⊢ IsAbsoluteValue ⇑abv","decl":"/-- A bundled absolute value is an absolute value. -/\ninstance _root_.AbsoluteValue.isAbsoluteValue (abv : AbsoluteValue R S) : IsAbsoluteValue abv where\n  abv_nonneg' := abv.nonneg\n  abv_eq_zero' := abv.eq_zero\n  abv_add' := abv.add_le\n  abv_mul' := abv.map_mul\n\n"}
{"name":"IsAbsoluteValue.toAbsoluteValue_apply","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝² : OrderedSemiring S\nR : Type u_6\ninst✝¹ : Semiring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\na✝ : R\n⊢ Eq ((IsAbsoluteValue.toAbsoluteValue abv) a✝) (abv a✝)","decl":"/-- Convert an unbundled `IsAbsoluteValue` to a bundled `AbsoluteValue`. -/\n@[simps]\ndef toAbsoluteValue : AbsoluteValue R S where\n  toFun := abv\n  add_le' := abv_add'\n  eq_zero' _ := abv_eq_zero'\n  nonneg' := abv_nonneg'\n  map_mul' := abv_mul'\n\n"}
{"name":"IsAbsoluteValue.abv_zero","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝² : OrderedSemiring S\nR : Type u_6\ninst✝¹ : Semiring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\n⊢ Eq (abv 0) 0","decl":"theorem abv_zero : abv 0 = 0 :=\n  (toAbsoluteValue abv).map_zero\n\n"}
{"name":"IsAbsoluteValue.abv_pos","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝² : OrderedSemiring S\nR : Type u_6\ninst✝¹ : Semiring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\na : R\n⊢ Iff (LT.lt 0 (abv a)) (Ne a 0)","decl":"theorem abv_pos {a : R} : 0 < abv a ↔ a ≠ 0 :=\n  (toAbsoluteValue abv).pos_iff\n\n"}
{"name":"IsAbsoluteValue.abs_isAbsoluteValue","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝ : LinearOrderedRing S\n⊢ IsAbsoluteValue abs","decl":"instance abs_isAbsoluteValue : IsAbsoluteValue (abs : S → S) :=\n  AbsoluteValue.abs.isAbsoluteValue\n\n"}
{"name":"IsAbsoluteValue.abv_one","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝⁴ : OrderedRing S\nR : Type u_6\ninst✝³ : Semiring R\nabv : R → S\ninst✝² : IsAbsoluteValue abv\ninst✝¹ : IsDomain S\ninst✝ : Nontrivial R\n⊢ Eq (abv 1) 1","decl":"theorem abv_one [Nontrivial R] : abv 1 = 1 :=\n  (toAbsoluteValue abv).map_one\n\n"}
{"name":"IsAbsoluteValue.abv_pow","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝⁴ : OrderedRing S\nR : Type u_6\ninst✝³ : Semiring R\ninst✝² : IsDomain S\ninst✝¹ : Nontrivial R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\na : R\nn : Nat\n⊢ Eq (abv (HPow.hPow a n)) (HPow.hPow (abv a) n)","decl":"theorem abv_pow [Nontrivial R] (abv : R → S) [IsAbsoluteValue abv] (a : R) (n : ℕ) :\n    abv (a ^ n) = abv a ^ n :=\n  (toAbsoluteValue abv).map_pow a n\n\n"}
{"name":"IsAbsoluteValue.abv_sub_le","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝² : OrderedRing S\nR : Type u_6\ninst✝¹ : Ring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\na b c : R\n⊢ LE.le (abv (HSub.hSub a c)) (HAdd.hAdd (abv (HSub.hSub a b)) (abv (HSub.hSub b c)))","decl":"theorem abv_sub_le (a b c : R) : abv (a - c) ≤ abv (a - b) + abv (b - c) := by\n  simpa [sub_eq_add_neg, add_assoc] using abv_add abv (a - b) (b - c)\n\n"}
{"name":"IsAbsoluteValue.sub_abv_le_abv_sub","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝² : OrderedRing S\nR : Type u_6\ninst✝¹ : Ring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\na b : R\n⊢ LE.le (HSub.hSub (abv a) (abv b)) (abv (HSub.hSub a b))","decl":"theorem sub_abv_le_abv_sub (a b : R) : abv a - abv b ≤ abv (a - b) :=\n  (toAbsoluteValue abv).le_sub a b\n\n"}
{"name":"IsAbsoluteValue.abv_neg","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝³ : OrderedCommRing S\ninst✝² : NoZeroDivisors S\ninst✝¹ : Ring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\na : R\n⊢ Eq (abv (Neg.neg a)) (abv a)","decl":"theorem abv_neg (a : R) : abv (-a) = abv a :=\n  (toAbsoluteValue abv).map_neg a\n\n"}
{"name":"IsAbsoluteValue.abv_sub","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝³ : OrderedCommRing S\ninst✝² : NoZeroDivisors S\ninst✝¹ : Ring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\na b : R\n⊢ Eq (abv (HSub.hSub a b)) (abv (HSub.hSub b a))","decl":"theorem abv_sub (a b : R) : abv (a - b) = abv (b - a) :=\n  (toAbsoluteValue abv).map_sub a b\n\n"}
{"name":"IsAbsoluteValue.abs_abv_sub_le_abv_sub","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝² : LinearOrderedCommRing S\nR : Type u_6\ninst✝¹ : Ring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\na b : R\n⊢ LE.le (abs (HSub.hSub (abv a) (abv b))) (abv (HSub.hSub a b))","decl":"theorem abs_abv_sub_le_abv_sub (a b : R) : abs (abv a - abv b) ≤ abv (a - b) :=\n  (toAbsoluteValue abv).abs_abv_sub_le_abv_sub a b\n\n"}
{"name":"IsAbsoluteValue.abv_one'","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝³ : LinearOrderedSemifield S\nR : Type u_6\ninst✝² : Semiring R\ninst✝¹ : Nontrivial R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\n⊢ Eq (abv 1) 1","decl":"theorem abv_one' : abv 1 = 1 :=\n  (toAbsoluteValue abv).map_one_of_isLeftRegular <|\n    (isRegular_of_ne_zero <| (toAbsoluteValue abv).ne_zero one_ne_zero).left\n\n"}
{"name":"IsAbsoluteValue.abv_inv","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝² : LinearOrderedSemifield S\nR : Type u_6\ninst✝¹ : DivisionSemiring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\na : R\n⊢ Eq (abv (Inv.inv a)) (Inv.inv (abv a))","decl":"theorem abv_inv (a : R) : abv a⁻¹ = (abv a)⁻¹ :=\n  map_inv₀ (abvHom' abv) a\n\n"}
{"name":"IsAbsoluteValue.abv_div","module":"Mathlib.Algebra.Order.AbsoluteValue.Basic","initialProofState":"S : Type u_5\ninst✝² : LinearOrderedSemifield S\nR : Type u_6\ninst✝¹ : DivisionSemiring R\nabv : R → S\ninst✝ : IsAbsoluteValue abv\na b : R\n⊢ Eq (abv (HDiv.hDiv a b)) (HDiv.hDiv (abv a) (abv b))","decl":"theorem abv_div (a b : R) : abv (a / b) = abv a / abv b :=\n  map_div₀ (abvHom' abv) a b\n\n"}
