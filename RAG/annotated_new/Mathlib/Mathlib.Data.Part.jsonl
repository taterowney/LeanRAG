{"name":"Part.mk.inj","module":"Mathlib.Data.Part","initialProofState":"α : Type u\nDom✝ : Prop\nget✝ : Dom✝ → α\nDom : Prop\nget : Dom → α\nx✝ : Eq { Dom := Dom✝, get := get✝ } { Dom := Dom, get := get }\n⊢ And (Eq Dom✝ Dom) (HEq get✝ get)","decl":"/-- `Part α` is the type of \"partial values\" of type `α`. It\n  is similar to `Option α` except the domain condition can be an\n  arbitrary proposition, not necessarily decidable. -/\nstructure Part.{u} (α : Type u) : Type u where\n  /-- The domain of a partial value -/\n  Dom : Prop\n  /-- Extract a value from a partial value given a proof of `Dom` -/\n  get : Dom → α\n\n"}
{"name":"Part.mk.sizeOf_spec","module":"Mathlib.Data.Part","initialProofState":"α : Type u\ninst✝ : SizeOf α\nDom : Prop\nget : Dom → α\n⊢ Eq (SizeOf.sizeOf { Dom := Dom, get := get }) (HAdd.hAdd 1 (SizeOf.sizeOf Dom))","decl":"/-- `Part α` is the type of \"partial values\" of type `α`. It\n  is similar to `Option α` except the domain condition can be an\n  arbitrary proposition, not necessarily decidable. -/\nstructure Part.{u} (α : Type u) : Type u where\n  /-- The domain of a partial value -/\n  Dom : Prop\n  /-- Extract a value from a partial value given a proof of `Dom` -/\n  get : Dom → α\n\n"}
{"name":"Part.mk.injEq","module":"Mathlib.Data.Part","initialProofState":"α : Type u\nDom✝ : Prop\nget✝ : Dom✝ → α\nDom : Prop\nget : Dom → α\n⊢ Eq (Eq { Dom := Dom✝, get := get✝ } { Dom := Dom, get := get }) (And (Eq Dom✝ Dom) (HEq get✝ get))","decl":"/-- `Part α` is the type of \"partial values\" of type `α`. It\n  is similar to `Option α` except the domain condition can be an\n  arbitrary proposition, not necessarily decidable. -/\nstructure Part.{u} (α : Type u) : Type u where\n  /-- The domain of a partial value -/\n  Dom : Prop\n  /-- Extract a value from a partial value given a proof of `Dom` -/\n  get : Dom → α\n\n"}
{"name":"Part.toOption_isSome","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\ninst✝ : Decidable o.Dom\n⊢ Iff (Eq o.toOption.isSome Bool.true) o.Dom","decl":"@[simp] lemma toOption_isSome (o : Part α) [Decidable o.Dom] : o.toOption.isSome ↔ o.Dom := by\n  by_cases h : o.Dom <;> simp [h, toOption]\n\n"}
{"name":"Part.toOption_eq_none","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\ninst✝ : Decidable o.Dom\n⊢ Iff (Eq o.toOption Option.none) (Not o.Dom)","decl":"@[simp] lemma toOption_eq_none (o : Part α) [Decidable o.Dom] : o.toOption = none ↔ ¬o.Dom := by\n  by_cases h : o.Dom <;> simp [h, toOption]\n\n"}
{"name":"Part.ext'","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no p : Part α\na✝¹ : Iff o.Dom p.Dom\na✝ : ∀ (h₁ : o.Dom) (h₂ : p.Dom), Eq (o.get h₁) (p.get h₂)\n⊢ Eq o p","decl":"/-- `Part` extensionality -/\ntheorem ext' : ∀ {o p : Part α}, (o.Dom ↔ p.Dom) → (∀ h₁ h₂, o.get h₁ = p.get h₂) → o = p\n  | ⟨od, o⟩, ⟨pd, p⟩, H1, H2 => by\n    have t : od = pd := propext H1\n    cases t; rw [show o = p from funext fun p => H2 p p]\n\n"}
{"name":"Part.eta","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\n⊢ Eq { Dom := o.Dom, get := fun h => o.get h } o","decl":"/-- `Part` eta expansion -/\n@[simp]\ntheorem eta : ∀ o : Part α, (⟨o.Dom, fun h => o.get h⟩ : Part α) = o\n  | ⟨_, _⟩ => rfl\n\n"}
{"name":"Part.mem_eq","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : α\no : Part α\n⊢ Eq (Membership.mem o a) (Exists fun h => Eq (o.get h) a)","decl":"theorem mem_eq (a : α) (o : Part α) : (a ∈ o) = ∃ h, o.get h = a :=\n  rfl\n\n"}
{"name":"Part.dom_iff_mem","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\n⊢ Iff o.Dom (Exists fun y => Membership.mem o y)","decl":"theorem dom_iff_mem : ∀ {o : Part α}, o.Dom ↔ ∃ y, y ∈ o\n  | ⟨_, f⟩ => ⟨fun h => ⟨f h, h, rfl⟩, fun ⟨_, h, rfl⟩ => h⟩\n\n"}
{"name":"Part.get_mem","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\nh : o.Dom\n⊢ Membership.mem o (o.get h)","decl":"theorem get_mem {o : Part α} (h) : get o h ∈ o :=\n  ⟨_, rfl⟩\n\n"}
{"name":"Part.mem_mk_iff","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\np : Prop\no : p → α\na : α\n⊢ Iff (Membership.mem { Dom := p, get := o } a) (Exists fun h => Eq (o h) a)","decl":"@[simp]\ntheorem mem_mk_iff {p : Prop} {o : p → α} {a : α} : a ∈ Part.mk p o ↔ ∃ h, o h = a :=\n  Iff.rfl\n\n"}
{"name":"Part.ext","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no p : Part α\nH : ∀ (a : α), Iff (Membership.mem o a) (Membership.mem p a)\n⊢ Eq o p","decl":"/-- `Part` extensionality -/\n@[ext]\ntheorem ext {o p : Part α} (H : ∀ a, a ∈ o ↔ a ∈ p) : o = p :=\n  (ext' ⟨fun h => ((H _).1 ⟨h, rfl⟩).fst, fun h => ((H _).2 ⟨h, rfl⟩).fst⟩) fun _ _ =>\n    ((H _).2 ⟨_, rfl⟩).snd\n\n"}
{"name":"Part.ext_iff","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no p : Part α\n⊢ Iff (Eq o p) (∀ (a : α), Iff (Membership.mem o a) (Membership.mem p a))","decl":"/-- `Part` extensionality -/\n@[ext]\ntheorem ext {o p : Part α} (H : ∀ a, a ∈ o ↔ a ∈ p) : o = p :=\n  (ext' ⟨fun h => ((H _).1 ⟨h, rfl⟩).fst, fun h => ((H _).2 ⟨h, rfl⟩).fst⟩) fun _ _ =>\n    ((H _).2 ⟨_, rfl⟩).snd\n\n"}
{"name":"Part.not_mem_none","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : α\n⊢ Not (Membership.mem Part.none a)","decl":"@[simp]\ntheorem not_mem_none (a : α) : a ∉ @none α := fun h => h.fst\n\n"}
{"name":"Part.some_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : α\n⊢ (Part.some a).Dom","decl":"@[simp]\ntheorem some_dom (a : α) : (some a).Dom :=\n  trivial\n\n"}
{"name":"Part.mem_unique","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na b : α\no : Part α\na✝¹ : Membership.mem o a\na✝ : Membership.mem o b\n⊢ Eq a b","decl":"theorem mem_unique : ∀ {a b : α} {o : Part α}, a ∈ o → b ∈ o → a = b\n  | _, _, ⟨_, _⟩, ⟨_, rfl⟩, ⟨_, rfl⟩ => rfl\n\n"}
{"name":"Part.Mem.left_unique","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\n⊢ Relator.LeftUnique fun x1 x2 => Membership.mem x2 x1","decl":"theorem Mem.left_unique : Relator.LeftUnique ((· ∈ ·) : α → Part α → Prop) := fun _ _ _ =>\n  mem_unique\n\n"}
{"name":"Part.get_eq_of_mem","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\na : α\nh : Membership.mem o a\nh' : o.Dom\n⊢ Eq (o.get h') a","decl":"theorem get_eq_of_mem {o : Part α} {a} (h : a ∈ o) (h') : get o h' = a :=\n  mem_unique ⟨_, rfl⟩ h\n\n"}
{"name":"Part.subsingleton","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\n⊢ (setOf fun a => Membership.mem o a).Subsingleton","decl":"protected theorem subsingleton (o : Part α) : Set.Subsingleton { a | a ∈ o } := fun _ ha _ hb =>\n  mem_unique ha hb\n\n"}
{"name":"Part.get_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : α\nha : (Part.some a).Dom\n⊢ Eq ((Part.some a).get ha) a","decl":"@[simp]\ntheorem get_some {a : α} (ha : (some a).Dom) : get (some a) ha = a :=\n  rfl\n\n"}
{"name":"Part.mem_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : α\n⊢ Membership.mem (Part.some a) a","decl":"theorem mem_some (a : α) : a ∈ some a :=\n  ⟨trivial, rfl⟩\n\n"}
{"name":"Part.mem_some_iff","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Membership.mem (Part.some a) b) (Eq b a)","decl":"@[simp]\ntheorem mem_some_iff {a b} : b ∈ (some a : Part α) ↔ b = a :=\n  ⟨fun ⟨_, e⟩ => e.symm, fun e => ⟨trivial, e.symm⟩⟩\n\n"}
{"name":"Part.eq_some_iff","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : α\no : Part α\n⊢ Iff (Eq o (Part.some a)) (Membership.mem o a)","decl":"theorem eq_some_iff {a : α} {o : Part α} : o = some a ↔ a ∈ o :=\n  ⟨fun e => e.symm ▸ mem_some _, fun ⟨h, e⟩ => e ▸ ext' (iff_true_intro h) fun _ _ => rfl⟩\n\n"}
{"name":"Part.eq_none_iff","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\n⊢ Iff (Eq o Part.none) (∀ (a : α), Not (Membership.mem o a))","decl":"theorem eq_none_iff {o : Part α} : o = none ↔ ∀ a, a ∉ o :=\n  ⟨fun e => e.symm ▸ not_mem_none, fun h => ext (by simpa)⟩\n\n"}
{"name":"Part.eq_none_iff'","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\n⊢ Iff (Eq o Part.none) (Not o.Dom)","decl":"theorem eq_none_iff' {o : Part α} : o = none ↔ ¬o.Dom :=\n  ⟨fun e => e.symm ▸ id, fun h => eq_none_iff.2 fun _ h' => h h'.fst⟩\n\n"}
{"name":"Part.not_none_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\n⊢ Not Part.none.Dom","decl":"@[simp]\ntheorem not_none_dom : ¬(none : Part α).Dom :=\n  id\n\n"}
{"name":"Part.some_ne_none","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nx : α\n⊢ Ne (Part.some x) Part.none","decl":"@[simp]\ntheorem some_ne_none (x : α) : some x ≠ none := by\n  intro h\n  exact true_ne_false (congr_arg Dom h)\n\n"}
{"name":"Part.none_ne_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nx : α\n⊢ Ne Part.none (Part.some x)","decl":"@[simp]\ntheorem none_ne_some (x : α) : none ≠ some x :=\n  (some_ne_none x).symm\n\n"}
{"name":"Part.ne_none_iff","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\n⊢ Iff (Ne o Part.none) (Exists fun x => Eq o (Part.some x))","decl":"theorem ne_none_iff {o : Part α} : o ≠ none ↔ ∃ x, o = some x := by\n  constructor\n  · rw [Ne, eq_none_iff', not_not]\n    exact fun h => ⟨o.get h, eq_some_iff.2 (get_mem h)⟩\n  · rintro ⟨x, rfl⟩\n    apply some_ne_none\n\n"}
{"name":"Part.eq_none_or_eq_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\n⊢ Or (Eq o Part.none) (Exists fun x => Eq o (Part.some x))","decl":"theorem eq_none_or_eq_some (o : Part α) : o = none ∨ ∃ x, o = some x :=\n  or_iff_not_imp_left.2 ne_none_iff.1\n\n"}
{"name":"Part.some_injective","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\n⊢ Function.Injective Part.some","decl":"theorem some_injective : Injective (@Part.some α) := fun _ _ h =>\n  congr_fun (eq_of_heq (Part.mk.inj h).2) trivial\n\n"}
{"name":"Part.some_inj","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Eq (Part.some a) (Part.some b)) (Eq a b)","decl":"@[simp]\ntheorem some_inj {a b : α} : Part.some a = some b ↔ a = b :=\n  some_injective.eq_iff\n\n"}
{"name":"Part.some_get","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : Part α\nha : a.Dom\n⊢ Eq (Part.some (a.get ha)) a","decl":"@[simp]\ntheorem some_get {a : Part α} (ha : a.Dom) : Part.some (Part.get a ha) = a :=\n  Eq.symm (eq_some_iff.2 ⟨ha, rfl⟩)\n\n"}
{"name":"Part.get_eq_iff_eq_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : Part α\nha : a.Dom\nb : α\n⊢ Iff (Eq (a.get ha) b) (Eq a (Part.some b))","decl":"theorem get_eq_iff_eq_some {a : Part α} {ha : a.Dom} {b : α} : a.get ha = b ↔ a = some b :=\n  ⟨fun h => by simp [h.symm], fun h => by simp [h]⟩\n\n"}
{"name":"Part.get_eq_get_of_eq","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : Part α\nha : a.Dom\nb : Part α\nh : Eq a b\n⊢ Eq (a.get ha) (b.get ⋯)","decl":"theorem get_eq_get_of_eq (a : Part α) (ha : a.Dom) {b : Part α} (h : a = b) :\n    a.get ha = b.get (h ▸ ha) := by\n  congr\n\n"}
{"name":"Part.get_eq_iff_mem","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\na : α\nh : o.Dom\n⊢ Iff (Eq (o.get h) a) (Membership.mem o a)","decl":"theorem get_eq_iff_mem {o : Part α} {a : α} (h : o.Dom) : o.get h = a ↔ a ∈ o :=\n  ⟨fun H => ⟨h, H⟩, fun ⟨_, H⟩ => H⟩\n\n"}
{"name":"Part.eq_get_iff_mem","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\na : α\nh : o.Dom\n⊢ Iff (Eq a (o.get h)) (Membership.mem o a)","decl":"theorem eq_get_iff_mem {o : Part α} {a : α} (h : o.Dom) : a = o.get h ↔ a ∈ o :=\n  eq_comm.trans (get_eq_iff_mem h)\n\n"}
{"name":"Part.none_toOption","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Decidable Part.none.Dom\n⊢ Eq Part.none.toOption Option.none","decl":"@[simp]\ntheorem none_toOption [Decidable (@none α).Dom] : (none : Part α).toOption = Option.none :=\n  dif_neg id\n\n"}
{"name":"Part.some_toOption","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : α\ninst✝ : Decidable (Part.some a).Dom\n⊢ Eq (Part.some a).toOption (Option.some a)","decl":"@[simp]\ntheorem some_toOption (a : α) [Decidable (some a).Dom] : (some a).toOption = Option.some a :=\n  dif_pos trivial\n\n"}
{"name":"Part.getOrElse_of_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : Part α\nh : a.Dom\ninst✝ : Decidable a.Dom\nd : α\n⊢ Eq (a.getOrElse d) (a.get h)","decl":"theorem getOrElse_of_dom (a : Part α) (h : a.Dom) [Decidable a.Dom] (d : α) :\n    getOrElse a d = a.get h :=\n  dif_pos h\n\n"}
{"name":"Part.getOrElse_of_not_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : Part α\nh : Not a.Dom\ninst✝ : Decidable a.Dom\nd : α\n⊢ Eq (a.getOrElse d) d","decl":"theorem getOrElse_of_not_dom (a : Part α) (h : ¬a.Dom) [Decidable a.Dom] (d : α) :\n    getOrElse a d = d :=\n  dif_neg h\n\n"}
{"name":"Part.getOrElse_none","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nd : α\ninst✝ : Decidable Part.none.Dom\n⊢ Eq (Part.none.getOrElse d) d","decl":"@[simp]\ntheorem getOrElse_none (d : α) [Decidable (none : Part α).Dom] : getOrElse none d = d :=\n  none.getOrElse_of_not_dom not_none_dom d\n\n"}
{"name":"Part.getOrElse_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na d : α\ninst✝ : Decidable (Part.some a).Dom\n⊢ Eq ((Part.some a).getOrElse d) a","decl":"@[simp]\ntheorem getOrElse_some (a : α) (d : α) [Decidable (some a).Dom] : getOrElse (some a) d = a :=\n  (some a).getOrElse_of_dom (some_dom a) d\n\n-- Porting note: removed `simp`\n"}
{"name":"Part.mem_toOption","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\ninst✝ : Decidable o.Dom\na : α\n⊢ Iff (Membership.mem o.toOption a) (Membership.mem o a)","decl":"theorem mem_toOption {o : Part α} [Decidable o.Dom] {a : α} : a ∈ toOption o ↔ a ∈ o := by\n  unfold toOption\n  by_cases h : o.Dom <;> simp [h]\n  · exact ⟨fun h => ⟨_, h⟩, fun ⟨_, h⟩ => h⟩\n  · exact mt Exists.fst h\n\n"}
{"name":"Part.toOption_eq_some_iff","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\ninst✝ : Decidable o.Dom\na : α\n⊢ Iff (Eq o.toOption (Option.some a)) (Membership.mem o a)","decl":"@[simp]\ntheorem toOption_eq_some_iff {o : Part α} [Decidable o.Dom] {a : α} :\n    toOption o = Option.some a ↔ a ∈ o := by\n  rw [← Option.mem_def, mem_toOption]\n\n"}
{"name":"Part.Dom.toOption","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\ninst✝ : Decidable o.Dom\nh : o.Dom\n⊢ Eq o.toOption (Option.some (o.get h))","decl":"protected theorem Dom.toOption {o : Part α} [Decidable o.Dom] (h : o.Dom) : o.toOption = o.get h :=\n  dif_pos h\n\n"}
{"name":"Part.toOption_eq_none_iff","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : Part α\ninst✝ : Decidable a.Dom\n⊢ Iff (Eq a.toOption Option.none) (Not a.Dom)","decl":"theorem toOption_eq_none_iff {a : Part α} [Decidable a.Dom] : a.toOption = Option.none ↔ ¬a.Dom :=\n  Ne.dite_eq_right_iff fun _ => Option.some_ne_none _\n\n/- Porting TODO: Removed `simp`. Maybe add `@[simp]` later if `@[simp]` is taken off definition of\n`Option.elim` -/\n"}
{"name":"Part.elim_toOption","module":"Mathlib.Data.Part","initialProofState":"α : Type u_4\nβ : Type u_5\na : Part α\ninst✝ : Decidable a.Dom\nb : β\nf : α → β\n⊢ Eq (a.toOption.elim b f) (dite a.Dom (fun h => f (a.get h)) fun h => b)","decl":"theorem elim_toOption {α β : Type*} (a : Part α) [Decidable a.Dom] (b : β) (f : α → β) :\n    a.toOption.elim b f = if h : a.Dom then f (a.get h) else b := by\n  split_ifs with h\n  · rw [h.toOption]\n    rfl\n  · rw [Part.toOption_eq_none_iff.2 h]\n    rfl\n\n"}
{"name":"Part.mem_ofOption","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : α\no : Option α\n⊢ Iff (Membership.mem (↑o) a) (Membership.mem o a)","decl":"@[simp]\ntheorem mem_ofOption {a : α} : ∀ {o : Option α}, a ∈ ofOption o ↔ a ∈ o\n  | Option.none => ⟨fun h => h.fst.elim, fun h => Option.noConfusion h⟩\n  | Option.some _ => ⟨fun h => congr_arg Option.some h.snd, fun h => ⟨trivial, Option.some.inj h⟩⟩\n\n"}
{"name":"Part.ofOption_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_4\no : Option α\n⊢ Iff (↑o).Dom (Eq o.isSome Bool.true)","decl":"@[simp]\ntheorem ofOption_dom {α} : ∀ o : Option α, (ofOption o).Dom ↔ o.isSome\n  | Option.none => by simp [ofOption, none]\n  | Option.some a => by simp [ofOption]\n\n"}
{"name":"Part.ofOption_eq_get","module":"Mathlib.Data.Part","initialProofState":"α : Type u_4\no : Option α\n⊢ Eq ↑o { Dom := Eq o.isSome Bool.true, get := o.get }","decl":"theorem ofOption_eq_get {α} (o : Option α) : ofOption o = ⟨_, @Option.get _ o⟩ :=\n  Part.ext' (ofOption_dom o) fun h₁ h₂ => by\n    cases o\n    · simp at h₂\n    · rfl\n\n"}
{"name":"Part.mem_coe","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : α\no : Option α\n⊢ Iff (Membership.mem (↑o) a) (Membership.mem o a)","decl":"theorem mem_coe {a : α} {o : Option α} : a ∈ (o : Part α) ↔ a ∈ o :=\n  mem_ofOption\n\n"}
{"name":"Part.coe_none","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\n⊢ Eq (↑Option.none) Part.none","decl":"@[simp]\ntheorem coe_none : (@Option.none α : Part α) = none :=\n  rfl\n\n"}
{"name":"Part.coe_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : α\n⊢ Eq (↑(Option.some a)) (Part.some a)","decl":"@[simp]\ntheorem coe_some (a : α) : (Option.some a : Part α) = some a :=\n  rfl\n\n"}
{"name":"Part.induction_on","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nP : Part α → Prop\na : Part α\nhnone : P Part.none\nhsome : ∀ (a : α), P (Part.some a)\n⊢ P a","decl":"@[elab_as_elim]\nprotected theorem induction_on {P : Part α → Prop} (a : Part α) (hnone : P none)\n    (hsome : ∀ a : α, P (some a)) : P a :=\n  (Classical.em a.Dom).elim (fun h => Part.some_get h ▸ hsome _) fun h =>\n    (eq_none_iff'.2 h).symm ▸ hnone\n\n"}
{"name":"Part.to_ofOption","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Option α\n⊢ Eq (↑o).toOption o","decl":"@[simp]\ntheorem to_ofOption (o : Option α) : toOption (ofOption o) = o := by cases o <;> rfl\n\n"}
{"name":"Part.of_toOption","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\no : Part α\ninst✝ : Decidable o.Dom\n⊢ Eq (↑o.toOption) o","decl":"@[simp]\ntheorem of_toOption (o : Part α) [Decidable o.Dom] : ofOption (toOption o) = o :=\n  ext fun _ => mem_ofOption.trans mem_toOption\n\n"}
{"name":"Part.le_total_of_le_of_le","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nx y z : Part α\nhx : LE.le x z\nhy : LE.le y z\n⊢ Or (LE.le x y) (LE.le y x)","decl":"theorem le_total_of_le_of_le {x y : Part α} (z : Part α) (hx : x ≤ z) (hy : y ≤ z) :\n    x ≤ y ∨ y ≤ x := by\n  rcases Part.eq_none_or_eq_some x with (h | ⟨b, h₀⟩)\n  · rw [h]\n    left\n    apply OrderBot.bot_le _\n  right; intro b' h₁\n  rw [Part.eq_some_iff] at h₀\n  have hx := hx _ h₀; have hy := hy _ h₁\n  have hx := Part.mem_unique hx hy; subst hx\n  exact h₀\n\n"}
{"name":"Part.map_Dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\no : Part α\n⊢ Eq (Part.map f o).Dom o.Dom","decl":"/-- The map operation for `Part` just maps the value and maintains the same domain. -/\n@[simps]\ndef map (f : α → β) (o : Part α) : Part β :=\n  ⟨o.Dom, f ∘ o.get⟩\n\n"}
{"name":"Part.map_get","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\no : Part α\na✝ : o.Dom\n⊢ Eq ((Part.map f o).get a✝) (Function.comp f o.get a✝)","decl":"/-- The map operation for `Part` just maps the value and maintains the same domain. -/\n@[simps]\ndef map (f : α → β) (o : Part α) : Part β :=\n  ⟨o.Dom, f ∘ o.get⟩\n\n"}
{"name":"Part.mem_map","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\no : Part α\na : α\na✝ : Membership.mem o a\n⊢ Membership.mem (Part.map f o) (f a)","decl":"theorem mem_map (f : α → β) {o : Part α} : ∀ {a}, a ∈ o → f a ∈ map f o\n  | _, ⟨_, rfl⟩ => ⟨_, rfl⟩\n\n"}
{"name":"Part.mem_map_iff","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\no : Part α\nb : β\n⊢ Iff (Membership.mem (Part.map f o) b) (Exists fun a => And (Membership.mem o a) (Eq (f a) b))","decl":"@[simp]\ntheorem mem_map_iff (f : α → β) {o : Part α} {b} : b ∈ map f o ↔ ∃ a ∈ o, f a = b :=\n  ⟨fun hb => match b, hb with\n    | _, ⟨_, rfl⟩ => ⟨_, ⟨_, rfl⟩, rfl⟩,\n    fun ⟨_, h₁, h₂⟩ => h₂ ▸ mem_map f h₁⟩\n\n"}
{"name":"Part.map_none","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Part.map f Part.none) Part.none","decl":"@[simp]\ntheorem map_none (f : α → β) : map f none = none :=\n  eq_none_iff.2 fun a => by simp\n\n"}
{"name":"Part.map_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\n⊢ Eq (Part.map f (Part.some a)) (Part.some (f a))","decl":"@[simp]\ntheorem map_some (f : α → β) (a : α) : map f (some a) = some (f a) :=\n  eq_some_iff.2 <| mem_map f <| mem_some _\n\n"}
{"name":"Part.mem_assert","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\np : Prop\nf : p → Part α\na : α\nh : p\na✝ : Membership.mem (f h) a\n⊢ Membership.mem (Part.assert p f) a","decl":"theorem mem_assert {p : Prop} {f : p → Part α} : ∀ {a} (h : p), a ∈ f h → a ∈ assert p f\n  | _, x, ⟨h, rfl⟩ => ⟨⟨x, h⟩, rfl⟩\n\n"}
{"name":"Part.mem_assert_iff","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\np : Prop\nf : p → Part α\na : α\n⊢ Iff (Membership.mem (Part.assert p f) a) (Exists fun h => Membership.mem (f h) a)","decl":"@[simp]\ntheorem mem_assert_iff {p : Prop} {f : p → Part α} {a} : a ∈ assert p f ↔ ∃ h : p, a ∈ f h :=\n  ⟨fun ha => match a, ha with\n    | _, ⟨_, rfl⟩ => ⟨_, ⟨_, rfl⟩⟩,\n    fun ⟨_, h⟩ => mem_assert _ h⟩\n\n"}
{"name":"Part.assert_pos","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\np : Prop\nf : p → Part α\nh : p\n⊢ Eq (Part.assert p f) (f h)","decl":"theorem assert_pos {p : Prop} {f : p → Part α} (h : p) : assert p f = f h := by\n  dsimp [assert]\n  cases h' : f h\n  simp only [h', mk.injEq, h, exists_prop_of_true, true_and]\n  apply Function.hfunext\n  · simp only [h, h', exists_prop_of_true]\n  · simp\n\n"}
{"name":"Part.assert_neg","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\np : Prop\nf : p → Part α\nh : Not p\n⊢ Eq (Part.assert p f) Part.none","decl":"theorem assert_neg {p : Prop} {f : p → Part α} (h : ¬p) : assert p f = none := by\n  dsimp [assert, none]; congr\n  · simp only [h, not_false_iff, exists_prop_of_false]\n  · apply Function.hfunext\n    · simp only [h, not_false_iff, exists_prop_of_false]\n    simp at *\n\n"}
{"name":"Part.mem_bind","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Part α\ng : α → Part β\na : α\nb : β\na✝¹ : Membership.mem f a\na✝ : Membership.mem (g a) b\n⊢ Membership.mem (f.bind g) b","decl":"theorem mem_bind {f : Part α} {g : α → Part β} : ∀ {a b}, a ∈ f → b ∈ g a → b ∈ f.bind g\n  | _, _, ⟨h, rfl⟩, ⟨h₂, rfl⟩ => ⟨⟨h, h₂⟩, rfl⟩\n\n"}
{"name":"Part.mem_bind_iff","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Part α\ng : α → Part β\nb : β\n⊢ Iff (Membership.mem (f.bind g) b) (Exists fun a => And (Membership.mem f a) (Membership.mem (g a) b))","decl":"@[simp]\ntheorem mem_bind_iff {f : Part α} {g : α → Part β} {b} : b ∈ f.bind g ↔ ∃ a ∈ f, b ∈ g a :=\n  ⟨fun hb => match b, hb with\n    | _, ⟨⟨_, _⟩, rfl⟩ => ⟨_, ⟨_, rfl⟩, ⟨_, rfl⟩⟩,\n    fun ⟨_, h₁, h₂⟩ => mem_bind h₁ h₂⟩\n\n"}
{"name":"Part.Dom.bind","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\no : Part α\nh : o.Dom\nf : α → Part β\n⊢ Eq (o.bind f) (f (o.get h))","decl":"protected theorem Dom.bind {o : Part α} (h : o.Dom) (f : α → Part β) : o.bind f = f (o.get h) := by\n  ext b\n  simp only [Part.mem_bind_iff, exists_prop]\n  refine ⟨?_, fun hb => ⟨o.get h, Part.get_mem _, hb⟩⟩\n  rintro ⟨a, ha, hb⟩\n  rwa [Part.get_eq_of_mem ha]\n\n"}
{"name":"Part.Dom.of_bind","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → Part β\na : Part α\nh : (a.bind f).Dom\n⊢ a.Dom","decl":"theorem Dom.of_bind {f : α → Part β} {a : Part α} (h : (a.bind f).Dom) : a.Dom :=\n  h.1\n\n"}
{"name":"Part.bind_none","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → Part β\n⊢ Eq (Part.none.bind f) Part.none","decl":"@[simp]\ntheorem bind_none (f : α → Part β) : none.bind f = none :=\n  eq_none_iff.2 fun a => by simp\n\n"}
{"name":"Part.bind_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nf : α → Part β\n⊢ Eq ((Part.some a).bind f) (f a)","decl":"@[simp]\ntheorem bind_some (a : α) (f : α → Part β) : (some a).bind f = f a :=\n  ext <| by simp\n\n"}
{"name":"Part.bind_of_mem","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\no : Part α\na : α\nh : Membership.mem o a\nf : α → Part β\n⊢ Eq (o.bind f) (f a)","decl":"theorem bind_of_mem {o : Part α} {a : α} (h : a ∈ o) (f : α → Part β) : o.bind f = f a := by\n  rw [eq_some_iff.2 h, bind_some]\n\n"}
{"name":"Part.bind_some_eq_map","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : Part α\n⊢ Eq (x.bind fun y => Part.some (f y)) (Part.map f x)","decl":"theorem bind_some_eq_map (f : α → β) (x : Part α) : x.bind (fun y => some (f y)) = map f x :=\n  ext <| by simp [eq_comm]\n\n"}
{"name":"Part.bind_toOption","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → Part β\no : Part α\ninst✝² : Decidable o.Dom\ninst✝¹ : (a : α) → Decidable (f a).Dom\ninst✝ : Decidable (o.bind f).Dom\n⊢ Eq (o.bind f).toOption (o.toOption.elim Option.none fun a => (f a).toOption)","decl":"theorem bind_toOption (f : α → Part β) (o : Part α) [Decidable o.Dom] [∀ a, Decidable (f a).Dom]\n    [Decidable (o.bind f).Dom] :\n    (o.bind f).toOption = o.toOption.elim Option.none fun a => (f a).toOption := by\n  by_cases h : o.Dom\n  · simp_rw [h.toOption, h.bind]\n    rfl\n  · rw [Part.toOption_eq_none_iff.2 h]\n    exact Part.toOption_eq_none_iff.2 fun ho => h ho.of_bind\n\n"}
{"name":"Part.bind_assoc","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_4\nf : Part α\ng : α → Part β\nk : β → Part γ\n⊢ Eq ((f.bind g).bind k) (f.bind fun x => (g x).bind k)","decl":"theorem bind_assoc {γ} (f : Part α) (g : α → Part β) (k : β → Part γ) :\n    (f.bind g).bind k = f.bind fun x => (g x).bind k :=\n  ext fun a => by\n    simp only [mem_bind_iff]\n    exact ⟨fun ⟨_, ⟨_, h₁, h₂⟩, h₃⟩ => ⟨_, h₁, _, h₂, h₃⟩,\n           fun ⟨_, h₁, _, h₂, h₃⟩ => ⟨_, ⟨_, h₁, h₂⟩, h₃⟩⟩\n\n"}
{"name":"Part.bind_map","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_4\nf : α → β\nx : Part α\ng : β → Part γ\n⊢ Eq ((Part.map f x).bind g) (x.bind fun y => g (f y))","decl":"@[simp]\ntheorem bind_map {γ} (f : α → β) (x) (g : β → Part γ) :\n    (map f x).bind g = x.bind fun y => g (f y) := by rw [← bind_some_eq_map, bind_assoc]; simp\n\n"}
{"name":"Part.map_bind","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_4\nf : α → Part β\nx : Part α\ng : β → γ\n⊢ Eq (Part.map g (x.bind f)) (x.bind fun y => Part.map g (f y))","decl":"@[simp]\ntheorem map_bind {γ} (f : α → Part β) (x : Part α) (g : β → γ) :\n    map g (x.bind f) = x.bind fun y => map g (f y) := by\n  rw [← bind_some_eq_map, bind_assoc]; simp [bind_some_eq_map]\n\n"}
{"name":"Part.map_map","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ng : β → γ\nf : α → β\no : Part α\n⊢ Eq (Part.map g (Part.map f o)) (Part.map (Function.comp g f) o)","decl":"theorem map_map (g : β → γ) (f : α → β) (o : Part α) : map g (map f o) = map (g ∘ f) o := by\n  erw [← bind_some_eq_map, bind_map, bind_some_eq_map]\n\n"}
{"name":"Part.instLawfulMonad","module":"Mathlib.Data.Part","initialProofState":"⊢ LawfulMonad Part","decl":"instance : LawfulMonad\n      Part where\n  bind_pure_comp := @bind_some_eq_map\n  id_map f := by cases f; rfl\n  pure_bind := @bind_some\n  bind_assoc := @bind_assoc\n  map_const := by simp [Functor.mapConst, Functor.map]\n  --Porting TODO : In Lean3 these were automatic by a tactic\n  seqLeft_eq x y := ext'\n    (by simp [SeqLeft.seqLeft, Part.bind, assert, Seq.seq, const, (· <$> ·), and_comm])\n    (fun _ _ => rfl)\n  seqRight_eq x y := ext'\n    (by simp [SeqRight.seqRight, Part.bind, assert, Seq.seq, const, (· <$> ·), and_comm])\n    (fun _ _ => rfl)\n  pure_seq x y := ext'\n    (by simp [Seq.seq, Part.bind, assert, (· <$> ·), pure])\n    (fun _ _ => rfl)\n  bind_map x y := ext'\n    (by simp [(· >>= ·), Part.bind, assert, Seq.seq, get, (· <$> ·)] )\n    (fun _ _ => rfl)\n\n"}
{"name":"Part.map_id'","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nf : α → α\nH : ∀ (x : α), Eq (f x) x\no : Part α\n⊢ Eq (Part.map f o) o","decl":"theorem map_id' {f : α → α} (H : ∀ x : α, f x = x) (o) : map f o = o := by\n  rw [show f = id from funext H]; exact id_map o\n\n"}
{"name":"Part.bind_some_right","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nx : Part α\n⊢ Eq (x.bind Part.some) x","decl":"@[simp]\ntheorem bind_some_right (x : Part α) : x.bind some = x := by\n  erw [bind_some_eq_map]; simp [map_id']\n\n"}
{"name":"Part.pure_eq_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Pure.pure a) (Part.some a)","decl":"@[simp]\ntheorem pure_eq_some (a : α) : pure a = some a :=\n  rfl\n\n"}
{"name":"Part.ret_eq_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Pure.pure a) (Part.some a)","decl":"@[simp]\ntheorem ret_eq_some (a : α) : (return a : Part α) = some a :=\n  rfl\n\n"}
{"name":"Part.map_eq_map","module":"Mathlib.Data.Part","initialProofState":"α β : Type u_4\nf : α → β\no : Part α\n⊢ Eq (Functor.map f o) (Part.map f o)","decl":"@[simp]\ntheorem map_eq_map {α β} (f : α → β) (o : Part α) : f <$> o = map f o :=\n  rfl\n\n"}
{"name":"Part.bind_eq_bind","module":"Mathlib.Data.Part","initialProofState":"α β : Type u_4\nf : Part α\ng : α → Part β\n⊢ Eq (Bind.bind f g) (f.bind g)","decl":"@[simp]\ntheorem bind_eq_bind {α β} (f : Part α) (g : α → Part β) : f >>= g = f.bind g :=\n  rfl\n\n"}
{"name":"Part.bind_le","module":"Mathlib.Data.Part","initialProofState":"β α : Type u_2\nx : Part α\nf : α → Part β\ny : Part β\n⊢ Iff (LE.le (Bind.bind x f) y) (∀ (a : α), Membership.mem x a → LE.le (f a) y)","decl":"theorem bind_le {α} (x : Part α) (f : α → Part β) (y : Part β) :\n    x >>= f ≤ y ↔ ∀ a, a ∈ x → f a ≤ y := by\n  constructor <;> intro h\n  · intro a h' b\n    have h := h b\n    simp only [and_imp, exists_prop, bind_eq_bind, mem_bind_iff, exists_imp] at h\n    apply h _ h'\n  · intro b h'\n    simp only [exists_prop, bind_eq_bind, mem_bind_iff] at h'\n    rcases h' with ⟨a, h₀, h₁⟩\n    apply h _ h₀ _ h₁\n\n-- Porting note: No MonadFail in Lean4 yet\n-- instance : MonadFail Part :=\n--   { Part.monad with fail := fun _ _ => none }\n\n"}
{"name":"Part.mem_restrict","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\np : Prop\no : Part α\nh : p → o.Dom\na : α\n⊢ Iff (Membership.mem (Part.restrict p o h) a) (And p (Membership.mem o a))","decl":"@[simp]\ntheorem mem_restrict (p : Prop) (o : Part α) (h : p → o.Dom) (a : α) :\n    a ∈ restrict p o h ↔ p ∧ a ∈ o := by\n  dsimp [restrict, mem_eq]; constructor\n  · rintro ⟨h₀, h₁⟩\n    exact ⟨h₀, ⟨_, h₁⟩⟩\n  rintro ⟨h₀, _, h₂⟩; exact ⟨h₀, h₂⟩\n\n"}
{"name":"Part.assert_defined","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\np : Prop\nf : p → Part α\nh : p\na✝ : (f h).Dom\n⊢ (Part.assert p f).Dom","decl":"theorem assert_defined {p : Prop} {f : p → Part α} : ∀ h : p, (f h).Dom → (assert p f).Dom :=\n  Exists.intro\n\n"}
{"name":"Part.bind_defined","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Part α\ng : α → Part β\nh : f.Dom\na✝ : (g (f.get h)).Dom\n⊢ (f.bind g).Dom","decl":"theorem bind_defined {f : Part α} {g : α → Part β} :\n    ∀ h : f.Dom, (g (f.get h)).Dom → (f.bind g).Dom :=\n  assert_defined\n\n"}
{"name":"Part.bind_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Part α\ng : α → Part β\n⊢ Iff (f.bind g).Dom (Exists fun h => (g (f.get h)).Dom)","decl":"@[simp]\ntheorem bind_dom {f : Part α} {g : α → Part β} : (f.bind g).Dom ↔ ∃ h : f.Dom, (g (f.get h)).Dom :=\n  Iff.rfl\n\n"}
{"name":"Part.mul_def","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Mul α\na b : Part α\n⊢ Eq (HMul.hMul a b) (Bind.bind a fun y => Part.map (fun x => HMul.hMul y x) b)","decl":"theorem mul_def [Mul α] (a b : Part α) : a * b = bind a fun y ↦ map (y * ·) b := rfl\n"}
{"name":"Part.one_def","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : One α\n⊢ Eq 1 (Part.some 1)","decl":"theorem one_def [One α] : (1 : Part α) = some 1 := rfl\n"}
{"name":"Part.inv_def","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Inv α\na : Part α\n⊢ Eq (Inv.inv a) (Part.map (fun x => Inv.inv x) a)","decl":"theorem inv_def [Inv α] (a : Part α) : a⁻¹ = Part.map (· ⁻¹) a := rfl\n"}
{"name":"Part.div_def","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Div α\na b : Part α\n⊢ Eq (HDiv.hDiv a b) (Bind.bind a fun y => Part.map (fun x => HDiv.hDiv y x) b)","decl":"theorem div_def [Div α] (a b : Part α) : a / b = bind a fun y => map (y / ·) b := rfl\n"}
{"name":"Part.mod_def","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Mod α\na b : Part α\n⊢ Eq (HMod.hMod a b) (Bind.bind a fun y => Part.map (fun x => HMod.hMod y x) b)","decl":"theorem mod_def [Mod α] (a b : Part α) : a % b = bind a fun y => map (y % ·) b := rfl\n"}
{"name":"Part.append_def","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Append α\na b : Part α\n⊢ Eq (HAppend.hAppend a b) (Bind.bind a fun y => Part.map (fun x => HAppend.hAppend y x) b)","decl":"theorem append_def [Append α] (a b : Part α) : a ++ b = bind a fun y => map (y ++ ·) b := rfl\n"}
{"name":"Part.inter_def","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Inter α\na b : Part α\n⊢ Eq (Inter.inter a b) (Bind.bind a fun y => Part.map (fun x => Inter.inter y x) b)","decl":"theorem inter_def [Inter α] (a b : Part α) : a ∩ b = bind a fun y => map (y ∩ ·) b := rfl\n"}
{"name":"Part.union_def","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Union α\na b : Part α\n⊢ Eq (Union.union a b) (Bind.bind a fun y => Part.map (fun x => Union.union y x) b)","decl":"theorem union_def [Union α] (a b : Part α) : a ∪ b = bind a fun y => map (y ∪ ·) b := rfl\n"}
{"name":"Part.sdiff_def","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : SDiff α\na b : Part α\n⊢ Eq (SDiff.sdiff a b) (Bind.bind a fun y => Part.map (fun x => SDiff.sdiff y x) b)","decl":"theorem sdiff_def [SDiff α] (a b : Part α) : a \\ b = bind a fun y => map (y \\ ·) b := rfl\n\n"}
{"name":"Part.zero_mem_zero","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Zero α\n⊢ Membership.mem 0 0","decl":"@[to_additive]\ntheorem one_mem_one [One α] : (1 : α) ∈ (1 : Part α) :=\n  ⟨trivial, rfl⟩\n\n"}
{"name":"Part.one_mem_one","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : One α\n⊢ Membership.mem 1 1","decl":"@[to_additive]\ntheorem one_mem_one [One α] : (1 : α) ∈ (1 : Part α) :=\n  ⟨trivial, rfl⟩\n\n"}
{"name":"Part.mul_mem_mul","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Mul α\na b : Part α\nma mb : α\nha : Membership.mem a ma\nhb : Membership.mem b mb\n⊢ Membership.mem (HMul.hMul a b) (HMul.hMul ma mb)","decl":"@[to_additive]\ntheorem mul_mem_mul [Mul α] (a b : Part α) (ma mb : α) (ha : ma ∈ a) (hb : mb ∈ b) :\n    ma * mb ∈ a * b := ⟨⟨ha.1, hb.1⟩, by simp only [← ha.2, ← hb.2]; rfl⟩\n\n"}
{"name":"Part.add_mem_add","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Add α\na b : Part α\nma mb : α\nha : Membership.mem a ma\nhb : Membership.mem b mb\n⊢ Membership.mem (HAdd.hAdd a b) (HAdd.hAdd ma mb)","decl":"@[to_additive]\ntheorem mul_mem_mul [Mul α] (a b : Part α) (ma mb : α) (ha : ma ∈ a) (hb : mb ∈ b) :\n    ma * mb ∈ a * b := ⟨⟨ha.1, hb.1⟩, by simp only [← ha.2, ← hb.2]; rfl⟩\n\n"}
{"name":"Part.left_dom_of_add_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Add α\na b : Part α\nhab : (HAdd.hAdd a b).Dom\n⊢ a.Dom","decl":"@[to_additive]\ntheorem left_dom_of_mul_dom [Mul α] {a b : Part α} (hab : Dom (a * b)) : a.Dom := hab.1\n\n"}
{"name":"Part.left_dom_of_mul_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Mul α\na b : Part α\nhab : (HMul.hMul a b).Dom\n⊢ a.Dom","decl":"@[to_additive]\ntheorem left_dom_of_mul_dom [Mul α] {a b : Part α} (hab : Dom (a * b)) : a.Dom := hab.1\n\n"}
{"name":"Part.right_dom_of_add_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Add α\na b : Part α\nhab : (HAdd.hAdd a b).Dom\n⊢ b.Dom","decl":"@[to_additive]\ntheorem right_dom_of_mul_dom [Mul α] {a b : Part α} (hab : Dom (a * b)) : b.Dom := hab.2\n\n"}
{"name":"Part.right_dom_of_mul_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Mul α\na b : Part α\nhab : (HMul.hMul a b).Dom\n⊢ b.Dom","decl":"@[to_additive]\ntheorem right_dom_of_mul_dom [Mul α] {a b : Part α} (hab : Dom (a * b)) : b.Dom := hab.2\n\n"}
{"name":"Part.mul_get_eq","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Mul α\na b : Part α\nhab : (HMul.hMul a b).Dom\n⊢ Eq ((HMul.hMul a b).get hab) (HMul.hMul (a.get ⋯) (b.get ⋯))","decl":"@[to_additive (attr := simp)]\ntheorem mul_get_eq [Mul α] (a b : Part α) (hab : Dom (a * b)) :\n    (a * b).get hab = a.get (left_dom_of_mul_dom hab) * b.get (right_dom_of_mul_dom hab) := rfl\n\n"}
{"name":"Part.add_get_eq","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Add α\na b : Part α\nhab : (HAdd.hAdd a b).Dom\n⊢ Eq ((HAdd.hAdd a b).get hab) (HAdd.hAdd (a.get ⋯) (b.get ⋯))","decl":"@[to_additive (attr := simp)]\ntheorem mul_get_eq [Mul α] (a b : Part α) (hab : Dom (a * b)) :\n    (a * b).get hab = a.get (left_dom_of_mul_dom hab) * b.get (right_dom_of_mul_dom hab) := rfl\n\n"}
{"name":"Part.some_mul_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Mul α\na b : α\n⊢ Eq (HMul.hMul (Part.some a) (Part.some b)) (Part.some (HMul.hMul a b))","decl":"@[to_additive]\ntheorem some_mul_some [Mul α] (a b : α) : some a * some b = some (a * b) := by simp [mul_def]\n\n"}
{"name":"Part.some_add_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Add α\na b : α\n⊢ Eq (HAdd.hAdd (Part.some a) (Part.some b)) (Part.some (HAdd.hAdd a b))","decl":"@[to_additive]\ntheorem some_mul_some [Mul α] (a b : α) : some a * some b = some (a * b) := by simp [mul_def]\n\n"}
{"name":"Part.inv_mem_inv","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Inv α\na : Part α\nma : α\nha : Membership.mem a ma\n⊢ Membership.mem (Inv.inv a) (Inv.inv ma)","decl":"@[to_additive]\ntheorem inv_mem_inv [Inv α] (a : Part α) (ma : α) (ha : ma ∈ a) : ma⁻¹ ∈ a⁻¹ := by\n  simp [inv_def]; aesop\n\n"}
{"name":"Part.neg_mem_neg","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Neg α\na : Part α\nma : α\nha : Membership.mem a ma\n⊢ Membership.mem (Neg.neg a) (Neg.neg ma)","decl":"@[to_additive]\ntheorem inv_mem_inv [Inv α] (a : Part α) (ma : α) (ha : ma ∈ a) : ma⁻¹ ∈ a⁻¹ := by\n  simp [inv_def]; aesop\n\n"}
{"name":"Part.neg_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Neg α\na : α\n⊢ Eq (Neg.neg (Part.some a)) (Part.some (Neg.neg a))","decl":"@[to_additive]\ntheorem inv_some [Inv α] (a : α) : (some a)⁻¹ = some a⁻¹ :=\n  rfl\n\n"}
{"name":"Part.inv_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Inv α\na : α\n⊢ Eq (Inv.inv (Part.some a)) (Part.some (Inv.inv a))","decl":"@[to_additive]\ntheorem inv_some [Inv α] (a : α) : (some a)⁻¹ = some a⁻¹ :=\n  rfl\n\n"}
{"name":"Part.sub_mem_sub","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Sub α\na b : Part α\nma mb : α\nha : Membership.mem a ma\nhb : Membership.mem b mb\n⊢ Membership.mem (HSub.hSub a b) (HSub.hSub ma mb)","decl":"@[to_additive]\ntheorem div_mem_div [Div α] (a b : Part α) (ma mb : α) (ha : ma ∈ a) (hb : mb ∈ b) :\n    ma / mb ∈ a / b := by simp [div_def]; aesop\n\n"}
{"name":"Part.div_mem_div","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Div α\na b : Part α\nma mb : α\nha : Membership.mem a ma\nhb : Membership.mem b mb\n⊢ Membership.mem (HDiv.hDiv a b) (HDiv.hDiv ma mb)","decl":"@[to_additive]\ntheorem div_mem_div [Div α] (a b : Part α) (ma mb : α) (ha : ma ∈ a) (hb : mb ∈ b) :\n    ma / mb ∈ a / b := by simp [div_def]; aesop\n\n"}
{"name":"Part.left_dom_of_div_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Div α\na b : Part α\nhab : (HDiv.hDiv a b).Dom\n⊢ a.Dom","decl":"@[to_additive]\ntheorem left_dom_of_div_dom [Div α] {a b : Part α} (hab : Dom (a / b)) : a.Dom := hab.1\n\n"}
{"name":"Part.left_dom_of_sub_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Sub α\na b : Part α\nhab : (HSub.hSub a b).Dom\n⊢ a.Dom","decl":"@[to_additive]\ntheorem left_dom_of_div_dom [Div α] {a b : Part α} (hab : Dom (a / b)) : a.Dom := hab.1\n\n"}
{"name":"Part.right_dom_of_sub_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Sub α\na b : Part α\nhab : (HSub.hSub a b).Dom\n⊢ b.Dom","decl":"@[to_additive]\ntheorem right_dom_of_div_dom [Div α] {a b : Part α} (hab : Dom (a / b)) : b.Dom := hab.2\n\n"}
{"name":"Part.right_dom_of_div_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Div α\na b : Part α\nhab : (HDiv.hDiv a b).Dom\n⊢ b.Dom","decl":"@[to_additive]\ntheorem right_dom_of_div_dom [Div α] {a b : Part α} (hab : Dom (a / b)) : b.Dom := hab.2\n\n"}
{"name":"Part.div_get_eq","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Div α\na b : Part α\nhab : (HDiv.hDiv a b).Dom\n⊢ Eq ((HDiv.hDiv a b).get hab) (HDiv.hDiv (a.get ⋯) (b.get ⋯))","decl":"@[to_additive (attr := simp)]\ntheorem div_get_eq [Div α] (a b : Part α) (hab : Dom (a / b)) :\n    (a / b).get hab = a.get (left_dom_of_div_dom hab) / b.get (right_dom_of_div_dom hab) := by\n  simp [div_def]; aesop\n\n"}
{"name":"Part.sub_get_eq","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Sub α\na b : Part α\nhab : (HSub.hSub a b).Dom\n⊢ Eq ((HSub.hSub a b).get hab) (HSub.hSub (a.get ⋯) (b.get ⋯))","decl":"@[to_additive (attr := simp)]\ntheorem div_get_eq [Div α] (a b : Part α) (hab : Dom (a / b)) :\n    (a / b).get hab = a.get (left_dom_of_div_dom hab) / b.get (right_dom_of_div_dom hab) := by\n  simp [div_def]; aesop\n\n"}
{"name":"Part.some_div_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Div α\na b : α\n⊢ Eq (HDiv.hDiv (Part.some a) (Part.some b)) (Part.some (HDiv.hDiv a b))","decl":"@[to_additive]\ntheorem some_div_some [Div α] (a b : α) : some a / some b = some (a / b) := by simp [div_def]\n\n"}
{"name":"Part.some_sub_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Sub α\na b : α\n⊢ Eq (HSub.hSub (Part.some a) (Part.some b)) (Part.some (HSub.hSub a b))","decl":"@[to_additive]\ntheorem some_div_some [Div α] (a b : α) : some a / some b = some (a / b) := by simp [div_def]\n\n"}
{"name":"Part.mod_mem_mod","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Mod α\na b : Part α\nma mb : α\nha : Membership.mem a ma\nhb : Membership.mem b mb\n⊢ Membership.mem (HMod.hMod a b) (HMod.hMod ma mb)","decl":"theorem mod_mem_mod [Mod α] (a b : Part α) (ma mb : α) (ha : ma ∈ a) (hb : mb ∈ b) :\n    ma % mb ∈ a % b := by simp [mod_def]; aesop\n\n"}
{"name":"Part.left_dom_of_mod_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Mod α\na b : Part α\nhab : (HMod.hMod a b).Dom\n⊢ a.Dom","decl":"theorem left_dom_of_mod_dom [Mod α] {a b : Part α} (hab : Dom (a % b)) : a.Dom := hab.1\n\n"}
{"name":"Part.right_dom_of_mod_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Mod α\na b : Part α\nhab : (HMod.hMod a b).Dom\n⊢ b.Dom","decl":"theorem right_dom_of_mod_dom [Mod α] {a b : Part α} (hab : Dom (a % b)) : b.Dom := hab.2\n\n"}
{"name":"Part.mod_get_eq","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Mod α\na b : Part α\nhab : (HMod.hMod a b).Dom\n⊢ Eq ((HMod.hMod a b).get hab) (HMod.hMod (a.get ⋯) (b.get ⋯))","decl":"@[simp]\ntheorem mod_get_eq [Mod α] (a b : Part α) (hab : Dom (a % b)) :\n    (a % b).get hab = a.get (left_dom_of_mod_dom hab) % b.get (right_dom_of_mod_dom hab) := by\n  simp [mod_def]; aesop\n\n"}
{"name":"Part.some_mod_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Mod α\na b : α\n⊢ Eq (HMod.hMod (Part.some a) (Part.some b)) (Part.some (HMod.hMod a b))","decl":"theorem some_mod_some [Mod α] (a b : α) : some a % some b = some (a % b) := by simp [mod_def]\n\n"}
{"name":"Part.append_mem_append","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Append α\na b : Part α\nma mb : α\nha : Membership.mem a ma\nhb : Membership.mem b mb\n⊢ Membership.mem (HAppend.hAppend a b) (HAppend.hAppend ma mb)","decl":"theorem append_mem_append [Append α] (a b : Part α) (ma mb : α) (ha : ma ∈ a) (hb : mb ∈ b) :\n    ma ++ mb ∈ a ++ b := by simp [append_def]; aesop\n\n"}
{"name":"Part.left_dom_of_append_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Append α\na b : Part α\nhab : (HAppend.hAppend a b).Dom\n⊢ a.Dom","decl":"theorem left_dom_of_append_dom [Append α] {a b : Part α} (hab : Dom (a ++ b)) : a.Dom := hab.1\n\n"}
{"name":"Part.right_dom_of_append_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Append α\na b : Part α\nhab : (HAppend.hAppend a b).Dom\n⊢ b.Dom","decl":"theorem right_dom_of_append_dom [Append α] {a b : Part α} (hab : Dom (a ++ b)) : b.Dom := hab.2\n\n"}
{"name":"Part.append_get_eq","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Append α\na b : Part α\nhab : (HAppend.hAppend a b).Dom\n⊢ Eq ((HAppend.hAppend a b).get hab) (HAppend.hAppend (a.get ⋯) (b.get ⋯))","decl":"@[simp]\ntheorem append_get_eq [Append α] (a b : Part α) (hab : Dom (a ++ b)) : (a ++ b).get hab =\n    a.get (left_dom_of_append_dom hab) ++ b.get (right_dom_of_append_dom hab) := by\n  simp [append_def]; aesop\n\n"}
{"name":"Part.some_append_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Append α\na b : α\n⊢ Eq (HAppend.hAppend (Part.some a) (Part.some b)) (Part.some (HAppend.hAppend a b))","decl":"theorem some_append_some [Append α] (a b : α) : some a ++ some b = some (a ++ b) := by\n  simp [append_def]\n\n"}
{"name":"Part.inter_mem_inter","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Inter α\na b : Part α\nma mb : α\nha : Membership.mem a ma\nhb : Membership.mem b mb\n⊢ Membership.mem (Inter.inter a b) (Inter.inter ma mb)","decl":"theorem inter_mem_inter [Inter α] (a b : Part α) (ma mb : α) (ha : ma ∈ a) (hb : mb ∈ b) :\n    ma ∩ mb ∈ a ∩ b := by simp [inter_def]; aesop\n\n"}
{"name":"Part.left_dom_of_inter_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Inter α\na b : Part α\nhab : (Inter.inter a b).Dom\n⊢ a.Dom","decl":"theorem left_dom_of_inter_dom [Inter α] {a b : Part α} (hab : Dom (a ∩ b)) : a.Dom := hab.1\n\n"}
{"name":"Part.right_dom_of_inter_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Inter α\na b : Part α\nhab : (Inter.inter a b).Dom\n⊢ b.Dom","decl":"theorem right_dom_of_inter_dom [Inter α] {a b : Part α} (hab : Dom (a ∩ b)) : b.Dom := hab.2\n\n"}
{"name":"Part.inter_get_eq","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Inter α\na b : Part α\nhab : (Inter.inter a b).Dom\n⊢ Eq ((Inter.inter a b).get hab) (Inter.inter (a.get ⋯) (b.get ⋯))","decl":"@[simp]\ntheorem inter_get_eq [Inter α] (a b : Part α) (hab : Dom (a ∩ b)) :\n    (a ∩ b).get hab = a.get (left_dom_of_inter_dom hab) ∩ b.get (right_dom_of_inter_dom hab) := by\n  simp [inter_def]; aesop\n\n"}
{"name":"Part.some_inter_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Inter α\na b : α\n⊢ Eq (Inter.inter (Part.some a) (Part.some b)) (Part.some (Inter.inter a b))","decl":"theorem some_inter_some [Inter α] (a b : α) : some a ∩ some b = some (a ∩ b) := by\n  simp [inter_def]\n\n"}
{"name":"Part.union_mem_union","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Union α\na b : Part α\nma mb : α\nha : Membership.mem a ma\nhb : Membership.mem b mb\n⊢ Membership.mem (Union.union a b) (Union.union ma mb)","decl":"theorem union_mem_union [Union α] (a b : Part α) (ma mb : α) (ha : ma ∈ a) (hb : mb ∈ b) :\n    ma ∪ mb ∈ a ∪ b := by simp [union_def]; aesop\n\n"}
{"name":"Part.left_dom_of_union_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Union α\na b : Part α\nhab : (Union.union a b).Dom\n⊢ a.Dom","decl":"theorem left_dom_of_union_dom [Union α] {a b : Part α} (hab : Dom (a ∪ b)) : a.Dom := hab.1\n\n"}
{"name":"Part.right_dom_of_union_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Union α\na b : Part α\nhab : (Union.union a b).Dom\n⊢ b.Dom","decl":"theorem right_dom_of_union_dom [Union α] {a b : Part α} (hab : Dom (a ∪ b)) : b.Dom := hab.2\n\n"}
{"name":"Part.union_get_eq","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Union α\na b : Part α\nhab : (Union.union a b).Dom\n⊢ Eq ((Union.union a b).get hab) (Union.union (a.get ⋯) (b.get ⋯))","decl":"@[simp]\ntheorem union_get_eq [Union α] (a b : Part α) (hab : Dom (a ∪ b)) :\n    (a ∪ b).get hab = a.get (left_dom_of_union_dom hab) ∪ b.get (right_dom_of_union_dom hab) := by\n  simp [union_def]; aesop\n\n"}
{"name":"Part.some_union_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : Union α\na b : α\n⊢ Eq (Union.union (Part.some a) (Part.some b)) (Part.some (Union.union a b))","decl":"theorem some_union_some [Union α] (a b : α) : some a ∪ some b = some (a ∪ b) := by simp [union_def]\n\n"}
{"name":"Part.sdiff_mem_sdiff","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : SDiff α\na b : Part α\nma mb : α\nha : Membership.mem a ma\nhb : Membership.mem b mb\n⊢ Membership.mem (SDiff.sdiff a b) (SDiff.sdiff ma mb)","decl":"theorem sdiff_mem_sdiff [SDiff α] (a b : Part α) (ma mb : α) (ha : ma ∈ a) (hb : mb ∈ b) :\n    ma \\ mb ∈ a \\ b := by simp [sdiff_def]; aesop\n\n"}
{"name":"Part.left_dom_of_sdiff_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : SDiff α\na b : Part α\nhab : (SDiff.sdiff a b).Dom\n⊢ a.Dom","decl":"theorem left_dom_of_sdiff_dom [SDiff α] {a b : Part α} (hab : Dom (a \\ b)) : a.Dom := hab.1\n\n"}
{"name":"Part.right_dom_of_sdiff_dom","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : SDiff α\na b : Part α\nhab : (SDiff.sdiff a b).Dom\n⊢ b.Dom","decl":"theorem right_dom_of_sdiff_dom [SDiff α] {a b : Part α} (hab : Dom (a \\ b)) : b.Dom := hab.2\n\n"}
{"name":"Part.sdiff_get_eq","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : SDiff α\na b : Part α\nhab : (SDiff.sdiff a b).Dom\n⊢ Eq ((SDiff.sdiff a b).get hab) (SDiff.sdiff (a.get ⋯) (b.get ⋯))","decl":"@[simp]\ntheorem sdiff_get_eq [SDiff α] (a b : Part α) (hab : Dom (a \\ b)) :\n    (a \\ b).get hab = a.get (left_dom_of_sdiff_dom hab) \\ b.get (right_dom_of_sdiff_dom hab) := by\n  simp [sdiff_def]; aesop\n\n"}
{"name":"Part.some_sdiff_some","module":"Mathlib.Data.Part","initialProofState":"α : Type u_1\ninst✝ : SDiff α\na b : α\n⊢ Eq (SDiff.sdiff (Part.some a) (Part.some b)) (Part.some (SDiff.sdiff a b))","decl":"theorem some_sdiff_some [SDiff α] (a b : α) : some a \\ some b = some (a \\ b) := by simp [sdiff_def]\n\n"}
