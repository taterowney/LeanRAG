{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor_map_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nT₁ T₂ : Opposite (CategoryTheory.Pretriangulated.Triangle C)\nφ : Quiver.Hom T₁ T₂\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor C).map φ).hom₃ φ.unop.hom₁.op","decl":"/-- The functor which sends a triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` in `C` to the triangle\n`op Z ⟶ op Y ⟶ op X ⟶ (op Z)⟦1⟧` in `Cᵒᵖ` (without introducing signs). -/\n@[simps]\nnoncomputable def functor : (Triangle C)ᵒᵖ ⥤ Triangle Cᵒᵖ where\n  obj T := Triangle.mk T.unop.mor₂.op T.unop.mor₁.op\n      ((opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op T.unop.obj₁) ≫\n        T.unop.mor₃.op⟦(1 : ℤ)⟧')\n  map {T₁ T₂} φ :=\n    { hom₁ := φ.unop.hom₃.op\n      hom₂ := φ.unop.hom₂.op\n      hom₃ := φ.unop.hom₁.op\n      comm₁ := Quiver.Hom.unop_inj φ.unop.comm₂.symm\n      comm₂ := Quiver.Hom.unop_inj φ.unop.comm₁.symm\n      comm₃ := by\n        dsimp\n        rw [assoc, ← Functor.map_comp, ← op_comp, ← φ.unop.comm₃, op_comp, Functor.map_comp,\n          opShiftFunctorEquivalence_counitIso_inv_naturality_assoc]\n        rfl }\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor_map_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nT₁ T₂ : Opposite (CategoryTheory.Pretriangulated.Triangle C)\nφ : Quiver.Hom T₁ T₂\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor C).map φ).hom₂ φ.unop.hom₂.op","decl":"/-- The functor which sends a triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` in `C` to the triangle\n`op Z ⟶ op Y ⟶ op X ⟶ (op Z)⟦1⟧` in `Cᵒᵖ` (without introducing signs). -/\n@[simps]\nnoncomputable def functor : (Triangle C)ᵒᵖ ⥤ Triangle Cᵒᵖ where\n  obj T := Triangle.mk T.unop.mor₂.op T.unop.mor₁.op\n      ((opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op T.unop.obj₁) ≫\n        T.unop.mor₃.op⟦(1 : ℤ)⟧')\n  map {T₁ T₂} φ :=\n    { hom₁ := φ.unop.hom₃.op\n      hom₂ := φ.unop.hom₂.op\n      hom₃ := φ.unop.hom₁.op\n      comm₁ := Quiver.Hom.unop_inj φ.unop.comm₂.symm\n      comm₂ := Quiver.Hom.unop_inj φ.unop.comm₁.symm\n      comm₃ := by\n        dsimp\n        rw [assoc, ← Functor.map_comp, ← op_comp, ← φ.unop.comm₃, op_comp, Functor.map_comp,\n          opShiftFunctorEquivalence_counitIso_inv_naturality_assoc]\n        rfl }\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor_map_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nT₁ T₂ : Opposite (CategoryTheory.Pretriangulated.Triangle C)\nφ : Quiver.Hom T₁ T₂\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor C).map φ).hom₁ φ.unop.hom₃.op","decl":"/-- The functor which sends a triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` in `C` to the triangle\n`op Z ⟶ op Y ⟶ op X ⟶ (op Z)⟦1⟧` in `Cᵒᵖ` (without introducing signs). -/\n@[simps]\nnoncomputable def functor : (Triangle C)ᵒᵖ ⥤ Triangle Cᵒᵖ where\n  obj T := Triangle.mk T.unop.mor₂.op T.unop.mor₁.op\n      ((opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op T.unop.obj₁) ≫\n        T.unop.mor₃.op⟦(1 : ℤ)⟧')\n  map {T₁ T₂} φ :=\n    { hom₁ := φ.unop.hom₃.op\n      hom₂ := φ.unop.hom₂.op\n      hom₃ := φ.unop.hom₁.op\n      comm₁ := Quiver.Hom.unop_inj φ.unop.comm₂.symm\n      comm₂ := Quiver.Hom.unop_inj φ.unop.comm₁.symm\n      comm₃ := by\n        dsimp\n        rw [assoc, ← Functor.map_comp, ← op_comp, ← φ.unop.comm₃, op_comp, Functor.map_comp,\n          opShiftFunctorEquivalence_counitIso_inv_naturality_assoc]\n        rfl }\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor_obj","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nT : Opposite (CategoryTheory.Pretriangulated.Triangle C)\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor C).obj T) (CategoryTheory.Pretriangulated.Triangle.mk (Opposite.unop T).mor₂.op (Opposite.unop T).mor₁.op (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 1).counitIso.inv.app { unop := (Opposite.unop T).obj₁ }) ((CategoryTheory.shiftFunctor (Opposite C) 1).map (Opposite.unop T).mor₃.op)))","decl":"/-- The functor which sends a triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` in `C` to the triangle\n`op Z ⟶ op Y ⟶ op X ⟶ (op Z)⟦1⟧` in `Cᵒᵖ` (without introducing signs). -/\n@[simps]\nnoncomputable def functor : (Triangle C)ᵒᵖ ⥤ Triangle Cᵒᵖ where\n  obj T := Triangle.mk T.unop.mor₂.op T.unop.mor₁.op\n      ((opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op T.unop.obj₁) ≫\n        T.unop.mor₃.op⟦(1 : ℤ)⟧')\n  map {T₁ T₂} φ :=\n    { hom₁ := φ.unop.hom₃.op\n      hom₂ := φ.unop.hom₂.op\n      hom₃ := φ.unop.hom₁.op\n      comm₁ := Quiver.Hom.unop_inj φ.unop.comm₂.symm\n      comm₂ := Quiver.Hom.unop_inj φ.unop.comm₁.symm\n      comm₃ := by\n        dsimp\n        rw [assoc, ← Functor.map_comp, ← op_comp, ← φ.unop.comm₃, op_comp, Functor.map_comp,\n          opShiftFunctorEquivalence_counitIso_inv_naturality_assoc]\n        rfl }\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.inverse_map","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle (Opposite C)\nφ : Quiver.Hom T₁ T₂\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.inverse C).map φ) (Quiver.Hom.op { hom₁ := φ.hom₃.unop, hom₂ := φ.hom₂.unop, hom₃ := φ.hom₁.unop, comm₁ := ⋯, comm₂ := ⋯, comm₃ := ⋯ })","decl":"/-- The functor which sends a triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` in `Cᵒᵖ` to the triangle\n`Z.unop ⟶ Y.unop ⟶ X.unop ⟶ Z.unop⟦1⟧` in `C` (without introducing signs). -/\n@[simps]\nnoncomputable def inverse : Triangle Cᵒᵖ ⥤ (Triangle C)ᵒᵖ where\n  obj T := Opposite.op (Triangle.mk T.mor₂.unop T.mor₁.unop\n      (((opShiftFunctorEquivalence C 1).unitIso.inv.app T.obj₁).unop ≫ T.mor₃.unop⟦(1 : ℤ)⟧'))\n  map {T₁ T₂} φ := Quiver.Hom.op\n    { hom₁ := φ.hom₃.unop\n      hom₂ := φ.hom₂.unop\n      hom₃ := φ.hom₁.unop\n      comm₁ := Quiver.Hom.op_inj φ.comm₂.symm\n      comm₂ := Quiver.Hom.op_inj φ.comm₁.symm\n      comm₃ := Quiver.Hom.op_inj (by\n        dsimp\n        rw [assoc, ← opShiftFunctorEquivalence_unitIso_inv_naturality,\n          ← op_comp_assoc, ← Functor.map_comp, ← unop_comp, ← φ.comm₃,\n          unop_comp, Functor.map_comp, op_comp, assoc]) }\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.inverse_obj","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.inverse C).obj T) { unop := CategoryTheory.Pretriangulated.Triangle.mk T.mor₂.unop T.mor₁.unop (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 1).unitIso.inv.app T.obj₁).unop ((CategoryTheory.shiftFunctor C 1).map T.mor₃.unop)) }","decl":"/-- The functor which sends a triangle `X ⟶ Y ⟶ Z ⟶ X⟦1⟧` in `Cᵒᵖ` to the triangle\n`Z.unop ⟶ Y.unop ⟶ X.unop ⟶ Z.unop⟦1⟧` in `C` (without introducing signs). -/\n@[simps]\nnoncomputable def inverse : Triangle Cᵒᵖ ⥤ (Triangle C)ᵒᵖ where\n  obj T := Opposite.op (Triangle.mk T.mor₂.unop T.mor₁.unop\n      (((opShiftFunctorEquivalence C 1).unitIso.inv.app T.obj₁).unop ≫ T.mor₃.unop⟦(1 : ℤ)⟧'))\n  map {T₁ T₂} φ := Quiver.Hom.op\n    { hom₁ := φ.hom₃.unop\n      hom₂ := φ.hom₂.unop\n      hom₃ := φ.hom₁.unop\n      comm₁ := Quiver.Hom.op_inj φ.comm₂.symm\n      comm₂ := Quiver.Hom.op_inj φ.comm₁.symm\n      comm₃ := Quiver.Hom.op_inj (by\n        dsimp\n        rw [assoc, ← opShiftFunctorEquivalence_unitIso_inv_naturality,\n          ← op_comp_assoc, ← Functor.map_comp, ← unop_comp, ← φ.comm₃,\n          unop_comp, Functor.map_comp, op_comp, assoc]) }\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.unitIso_hom_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : Opposite (CategoryTheory.Pretriangulated.Triangle C)\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.unitIso C).hom.app X) ((CategoryTheory.Pretriangulated.Triangle.mk (Opposite.unop X).mor₁ (Opposite.unop X).mor₂ (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 1).unitIso.inv.app { unop := (Opposite.unop X).obj₃ }).unop ((CategoryTheory.shiftFunctor C 1).map (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite C) 1).map (Opposite.unop X).mor₃.op).unop ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 1).counitIso.inv.app { unop := (Opposite.unop X).obj₁ }).unop)))).homMk (Opposite.unop X) (CategoryTheory.CategoryStruct.id (Opposite.unop X).obj₁) (CategoryTheory.CategoryStruct.id (Opposite.unop X).obj₂) (CategoryTheory.CategoryStruct.id (Opposite.unop X).obj₃) ⋯ ⋯ ⋯).op","decl":"/-- The unit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)ᵒᵖ ≌ Triangle Cᵒᵖ` . -/\n@[simps!]\nnoncomputable def unitIso : 𝟭 _ ≅ functor C ⋙ inverse C :=\n  NatIso.ofComponents (fun T => Iso.op\n    (Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) (by simp) (by simp)\n      (Quiver.Hom.op_inj\n        (by simp [shift_unop_opShiftFunctorEquivalence_counitIso_inv_app]))))\n    (fun {T₁ T₂} f => Quiver.Hom.unop_inj (by aesop_cat))\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.unitIso_inv_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : Opposite (CategoryTheory.Pretriangulated.Triangle C)\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.unitIso C).inv.app X) ((Opposite.unop X).homMk (CategoryTheory.Pretriangulated.Triangle.mk (Opposite.unop X).mor₁ (Opposite.unop X).mor₂ (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 1).unitIso.inv.app { unop := (Opposite.unop X).obj₃ }).unop ((CategoryTheory.shiftFunctor C 1).map (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite C) 1).map (Opposite.unop X).mor₃.op).unop ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 1).counitIso.inv.app { unop := (Opposite.unop X).obj₁ }).unop)))) (CategoryTheory.CategoryStruct.id (Opposite.unop X).obj₁) (CategoryTheory.CategoryStruct.id (Opposite.unop X).obj₂) (CategoryTheory.CategoryStruct.id (Opposite.unop X).obj₃) ⋯ ⋯ ⋯).op","decl":"/-- The unit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)ᵒᵖ ≌ Triangle Cᵒᵖ` . -/\n@[simps!]\nnoncomputable def unitIso : 𝟭 _ ≅ functor C ⋙ inverse C :=\n  NatIso.ofComponents (fun T => Iso.op\n    (Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) (by simp) (by simp)\n      (Quiver.Hom.op_inj\n        (by simp [shift_unop_opShiftFunctorEquivalence_counitIso_inv_app]))))\n    (fun {T₁ T₂} f => Quiver.Hom.unop_inj (by aesop_cat))\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso_hom_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C).hom.app X).hom₂ (CategoryTheory.CategoryStruct.id X.obj₂)","decl":"/-- The counit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)ᵒᵖ ≌ Triangle Cᵒᵖ` . -/\n@[simps!]\nnoncomputable def counitIso : inverse C ⋙ functor C ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun T => by\n    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_\n    · simp\n    · simp\n    · dsimp\n      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,\n        ← opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,\n        opShiftFunctorEquivalence_counitIso_inv_app_shift, ← Functor.map_comp,\n        Iso.hom_inv_id_app, Functor.map_id]\n      simp only [Functor.id_obj, comp_id])\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso_inv_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C).inv.app X).hom₃ (CategoryTheory.CategoryStruct.id X.obj₃)","decl":"/-- The counit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)ᵒᵖ ≌ Triangle Cᵒᵖ` . -/\n@[simps!]\nnoncomputable def counitIso : inverse C ⋙ functor C ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun T => by\n    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_\n    · simp\n    · simp\n    · dsimp\n      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,\n        ← opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,\n        opShiftFunctorEquivalence_counitIso_inv_app_shift, ← Functor.map_comp,\n        Iso.hom_inv_id_app, Functor.map_id]\n      simp only [Functor.id_obj, comp_id])\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso_hom_app_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C).hom.app X).hom₃ (CategoryTheory.CategoryStruct.id X.obj₃)","decl":"/-- The counit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)ᵒᵖ ≌ Triangle Cᵒᵖ` . -/\n@[simps!]\nnoncomputable def counitIso : inverse C ⋙ functor C ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun T => by\n    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_\n    · simp\n    · simp\n    · dsimp\n      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,\n        ← opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,\n        opShiftFunctorEquivalence_counitIso_inv_app_shift, ← Functor.map_comp,\n        Iso.hom_inv_id_app, Functor.map_id]\n      simp only [Functor.id_obj, comp_id])\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso_inv_app_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C).inv.app X).hom₂ (CategoryTheory.CategoryStruct.id X.obj₂)","decl":"/-- The counit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)ᵒᵖ ≌ Triangle Cᵒᵖ` . -/\n@[simps!]\nnoncomputable def counitIso : inverse C ⋙ functor C ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun T => by\n    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_\n    · simp\n    · simp\n    · dsimp\n      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,\n        ← opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,\n        opShiftFunctorEquivalence_counitIso_inv_app_shift, ← Functor.map_comp,\n        Iso.hom_inv_id_app, Functor.map_id]\n      simp only [Functor.id_obj, comp_id])\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso_hom_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C).hom.app X).hom₁ (CategoryTheory.CategoryStruct.id X.obj₁)","decl":"/-- The counit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)ᵒᵖ ≌ Triangle Cᵒᵖ` . -/\n@[simps!]\nnoncomputable def counitIso : inverse C ⋙ functor C ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun T => by\n    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_\n    · simp\n    · simp\n    · dsimp\n      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,\n        ← opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,\n        opShiftFunctorEquivalence_counitIso_inv_app_shift, ← Functor.map_comp,\n        Iso.hom_inv_id_app, Functor.map_id]\n      simp only [Functor.id_obj, comp_id])\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso_inv_app_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n⊢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C).inv.app X).hom₁ (CategoryTheory.CategoryStruct.id X.obj₁)","decl":"/-- The counit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)ᵒᵖ ≌ Triangle Cᵒᵖ` . -/\n@[simps!]\nnoncomputable def counitIso : inverse C ⋙ functor C ≅ 𝟭 _ :=\n  NatIso.ofComponents (fun T => by\n    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_\n    · simp\n    · simp\n    · dsimp\n      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,\n        ← opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,\n        opShiftFunctorEquivalence_counitIso_inv_app_shift, ← Functor.map_comp,\n        Iso.hom_inv_id_app, Functor.map_id]\n      simp only [Functor.id_obj, comp_id])\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleOpEquivalence_unitIso","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\n⊢ Eq (CategoryTheory.Pretriangulated.triangleOpEquivalence C).unitIso (CategoryTheory.Pretriangulated.TriangleOpEquivalence.unitIso C)","decl":"/-- An anti-equivalence between the categories of triangles in `C` and in `Cᵒᵖ`.\nA triangle in `Cᵒᵖ` shall be distinguished iff it correspond to a distinguished\ntriangle in `C` via this equivalence. -/\n@[simps]\nnoncomputable def triangleOpEquivalence :\n    (Triangle C)ᵒᵖ ≌ Triangle Cᵒᵖ where\n  functor := TriangleOpEquivalence.functor C\n  inverse := TriangleOpEquivalence.inverse C\n  unitIso := TriangleOpEquivalence.unitIso C\n  counitIso := TriangleOpEquivalence.counitIso C\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleOpEquivalence_inverse","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\n⊢ Eq (CategoryTheory.Pretriangulated.triangleOpEquivalence C).inverse (CategoryTheory.Pretriangulated.TriangleOpEquivalence.inverse C)","decl":"/-- An anti-equivalence between the categories of triangles in `C` and in `Cᵒᵖ`.\nA triangle in `Cᵒᵖ` shall be distinguished iff it correspond to a distinguished\ntriangle in `C` via this equivalence. -/\n@[simps]\nnoncomputable def triangleOpEquivalence :\n    (Triangle C)ᵒᵖ ≌ Triangle Cᵒᵖ where\n  functor := TriangleOpEquivalence.functor C\n  inverse := TriangleOpEquivalence.inverse C\n  unitIso := TriangleOpEquivalence.unitIso C\n  counitIso := TriangleOpEquivalence.counitIso C\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleOpEquivalence_counitIso","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\n⊢ Eq (CategoryTheory.Pretriangulated.triangleOpEquivalence C).counitIso (CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C)","decl":"/-- An anti-equivalence between the categories of triangles in `C` and in `Cᵒᵖ`.\nA triangle in `Cᵒᵖ` shall be distinguished iff it correspond to a distinguished\ntriangle in `C` via this equivalence. -/\n@[simps]\nnoncomputable def triangleOpEquivalence :\n    (Triangle C)ᵒᵖ ≌ Triangle Cᵒᵖ where\n  functor := TriangleOpEquivalence.functor C\n  inverse := TriangleOpEquivalence.inverse C\n  unitIso := TriangleOpEquivalence.unitIso C\n  counitIso := TriangleOpEquivalence.counitIso C\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleOpEquivalence_functor","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\n⊢ Eq (CategoryTheory.Pretriangulated.triangleOpEquivalence C).functor (CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor C)","decl":"/-- An anti-equivalence between the categories of triangles in `C` and in `Cᵒᵖ`.\nA triangle in `Cᵒᵖ` shall be distinguished iff it correspond to a distinguished\ntriangle in `C` via this equivalence. -/\n@[simps]\nnoncomputable def triangleOpEquivalence :\n    (Triangle C)ᵒᵖ ≌ Triangle Cᵒᵖ where\n  functor := TriangleOpEquivalence.functor C\n  inverse := TriangleOpEquivalence.inverse C\n  unitIso := TriangleOpEquivalence.unitIso C\n  counitIso := TriangleOpEquivalence.counitIso C\n\n"}
