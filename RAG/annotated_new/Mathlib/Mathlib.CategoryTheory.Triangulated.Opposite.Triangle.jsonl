{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor_map_hom‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nT‚ÇÅ T‚ÇÇ : Opposite (CategoryTheory.Pretriangulated.Triangle C)\nœÜ : Quiver.Hom T‚ÇÅ T‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor C).map œÜ).hom‚ÇÉ œÜ.unop.hom‚ÇÅ.op","decl":"/-- The functor which sends a triangle `X ‚ü∂ Y ‚ü∂ Z ‚ü∂ X‚ü¶1‚üß` in `C` to the triangle\n`op Z ‚ü∂ op Y ‚ü∂ op X ‚ü∂ (op Z)‚ü¶1‚üß` in `C·µí·µñ` (without introducing signs). -/\n@[simps]\nnoncomputable def functor : (Triangle C)·µí·µñ ‚•§ Triangle C·µí·µñ where\n  obj T := Triangle.mk T.unop.mor‚ÇÇ.op T.unop.mor‚ÇÅ.op\n      ((opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op T.unop.obj‚ÇÅ) ‚â´\n        T.unop.mor‚ÇÉ.op‚ü¶(1 : ‚Ñ§)‚üß')\n  map {T‚ÇÅ T‚ÇÇ} œÜ :=\n    { hom‚ÇÅ := œÜ.unop.hom‚ÇÉ.op\n      hom‚ÇÇ := œÜ.unop.hom‚ÇÇ.op\n      hom‚ÇÉ := œÜ.unop.hom‚ÇÅ.op\n      comm‚ÇÅ := Quiver.Hom.unop_inj œÜ.unop.comm‚ÇÇ.symm\n      comm‚ÇÇ := Quiver.Hom.unop_inj œÜ.unop.comm‚ÇÅ.symm\n      comm‚ÇÉ := by\n        dsimp\n        rw [assoc, ‚Üê Functor.map_comp, ‚Üê op_comp, ‚Üê œÜ.unop.comm‚ÇÉ, op_comp, Functor.map_comp,\n          opShiftFunctorEquivalence_counitIso_inv_naturality_assoc]\n        rfl }\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor_map_hom‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nT‚ÇÅ T‚ÇÇ : Opposite (CategoryTheory.Pretriangulated.Triangle C)\nœÜ : Quiver.Hom T‚ÇÅ T‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor C).map œÜ).hom‚ÇÇ œÜ.unop.hom‚ÇÇ.op","decl":"/-- The functor which sends a triangle `X ‚ü∂ Y ‚ü∂ Z ‚ü∂ X‚ü¶1‚üß` in `C` to the triangle\n`op Z ‚ü∂ op Y ‚ü∂ op X ‚ü∂ (op Z)‚ü¶1‚üß` in `C·µí·µñ` (without introducing signs). -/\n@[simps]\nnoncomputable def functor : (Triangle C)·µí·µñ ‚•§ Triangle C·µí·µñ where\n  obj T := Triangle.mk T.unop.mor‚ÇÇ.op T.unop.mor‚ÇÅ.op\n      ((opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op T.unop.obj‚ÇÅ) ‚â´\n        T.unop.mor‚ÇÉ.op‚ü¶(1 : ‚Ñ§)‚üß')\n  map {T‚ÇÅ T‚ÇÇ} œÜ :=\n    { hom‚ÇÅ := œÜ.unop.hom‚ÇÉ.op\n      hom‚ÇÇ := œÜ.unop.hom‚ÇÇ.op\n      hom‚ÇÉ := œÜ.unop.hom‚ÇÅ.op\n      comm‚ÇÅ := Quiver.Hom.unop_inj œÜ.unop.comm‚ÇÇ.symm\n      comm‚ÇÇ := Quiver.Hom.unop_inj œÜ.unop.comm‚ÇÅ.symm\n      comm‚ÇÉ := by\n        dsimp\n        rw [assoc, ‚Üê Functor.map_comp, ‚Üê op_comp, ‚Üê œÜ.unop.comm‚ÇÉ, op_comp, Functor.map_comp,\n          opShiftFunctorEquivalence_counitIso_inv_naturality_assoc]\n        rfl }\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor_map_hom‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nT‚ÇÅ T‚ÇÇ : Opposite (CategoryTheory.Pretriangulated.Triangle C)\nœÜ : Quiver.Hom T‚ÇÅ T‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor C).map œÜ).hom‚ÇÅ œÜ.unop.hom‚ÇÉ.op","decl":"/-- The functor which sends a triangle `X ‚ü∂ Y ‚ü∂ Z ‚ü∂ X‚ü¶1‚üß` in `C` to the triangle\n`op Z ‚ü∂ op Y ‚ü∂ op X ‚ü∂ (op Z)‚ü¶1‚üß` in `C·µí·µñ` (without introducing signs). -/\n@[simps]\nnoncomputable def functor : (Triangle C)·µí·µñ ‚•§ Triangle C·µí·µñ where\n  obj T := Triangle.mk T.unop.mor‚ÇÇ.op T.unop.mor‚ÇÅ.op\n      ((opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op T.unop.obj‚ÇÅ) ‚â´\n        T.unop.mor‚ÇÉ.op‚ü¶(1 : ‚Ñ§)‚üß')\n  map {T‚ÇÅ T‚ÇÇ} œÜ :=\n    { hom‚ÇÅ := œÜ.unop.hom‚ÇÉ.op\n      hom‚ÇÇ := œÜ.unop.hom‚ÇÇ.op\n      hom‚ÇÉ := œÜ.unop.hom‚ÇÅ.op\n      comm‚ÇÅ := Quiver.Hom.unop_inj œÜ.unop.comm‚ÇÇ.symm\n      comm‚ÇÇ := Quiver.Hom.unop_inj œÜ.unop.comm‚ÇÅ.symm\n      comm‚ÇÉ := by\n        dsimp\n        rw [assoc, ‚Üê Functor.map_comp, ‚Üê op_comp, ‚Üê œÜ.unop.comm‚ÇÉ, op_comp, Functor.map_comp,\n          opShiftFunctorEquivalence_counitIso_inv_naturality_assoc]\n        rfl }\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor_obj","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nT : Opposite (CategoryTheory.Pretriangulated.Triangle C)\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor C).obj T) (CategoryTheory.Pretriangulated.Triangle.mk (Opposite.unop T).mor‚ÇÇ.op (Opposite.unop T).mor‚ÇÅ.op (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 1).counitIso.inv.app { unop := (Opposite.unop T).obj‚ÇÅ }) ((CategoryTheory.shiftFunctor (Opposite C) 1).map (Opposite.unop T).mor‚ÇÉ.op)))","decl":"/-- The functor which sends a triangle `X ‚ü∂ Y ‚ü∂ Z ‚ü∂ X‚ü¶1‚üß` in `C` to the triangle\n`op Z ‚ü∂ op Y ‚ü∂ op X ‚ü∂ (op Z)‚ü¶1‚üß` in `C·µí·µñ` (without introducing signs). -/\n@[simps]\nnoncomputable def functor : (Triangle C)·µí·µñ ‚•§ Triangle C·µí·µñ where\n  obj T := Triangle.mk T.unop.mor‚ÇÇ.op T.unop.mor‚ÇÅ.op\n      ((opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op T.unop.obj‚ÇÅ) ‚â´\n        T.unop.mor‚ÇÉ.op‚ü¶(1 : ‚Ñ§)‚üß')\n  map {T‚ÇÅ T‚ÇÇ} œÜ :=\n    { hom‚ÇÅ := œÜ.unop.hom‚ÇÉ.op\n      hom‚ÇÇ := œÜ.unop.hom‚ÇÇ.op\n      hom‚ÇÉ := œÜ.unop.hom‚ÇÅ.op\n      comm‚ÇÅ := Quiver.Hom.unop_inj œÜ.unop.comm‚ÇÇ.symm\n      comm‚ÇÇ := Quiver.Hom.unop_inj œÜ.unop.comm‚ÇÅ.symm\n      comm‚ÇÉ := by\n        dsimp\n        rw [assoc, ‚Üê Functor.map_comp, ‚Üê op_comp, ‚Üê œÜ.unop.comm‚ÇÉ, op_comp, Functor.map_comp,\n          opShiftFunctorEquivalence_counitIso_inv_naturality_assoc]\n        rfl }\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.inverse_map","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Pretriangulated.Triangle (Opposite C)\nœÜ : Quiver.Hom T‚ÇÅ T‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.inverse C).map œÜ) (Quiver.Hom.op { hom‚ÇÅ := œÜ.hom‚ÇÉ.unop, hom‚ÇÇ := œÜ.hom‚ÇÇ.unop, hom‚ÇÉ := œÜ.hom‚ÇÅ.unop, comm‚ÇÅ := ‚ãØ, comm‚ÇÇ := ‚ãØ, comm‚ÇÉ := ‚ãØ })","decl":"/-- The functor which sends a triangle `X ‚ü∂ Y ‚ü∂ Z ‚ü∂ X‚ü¶1‚üß` in `C·µí·µñ` to the triangle\n`Z.unop ‚ü∂ Y.unop ‚ü∂ X.unop ‚ü∂ Z.unop‚ü¶1‚üß` in `C` (without introducing signs). -/\n@[simps]\nnoncomputable def inverse : Triangle C·µí·µñ ‚•§ (Triangle C)·µí·µñ where\n  obj T := Opposite.op (Triangle.mk T.mor‚ÇÇ.unop T.mor‚ÇÅ.unop\n      (((opShiftFunctorEquivalence C 1).unitIso.inv.app T.obj‚ÇÅ).unop ‚â´ T.mor‚ÇÉ.unop‚ü¶(1 : ‚Ñ§)‚üß'))\n  map {T‚ÇÅ T‚ÇÇ} œÜ := Quiver.Hom.op\n    { hom‚ÇÅ := œÜ.hom‚ÇÉ.unop\n      hom‚ÇÇ := œÜ.hom‚ÇÇ.unop\n      hom‚ÇÉ := œÜ.hom‚ÇÅ.unop\n      comm‚ÇÅ := Quiver.Hom.op_inj œÜ.comm‚ÇÇ.symm\n      comm‚ÇÇ := Quiver.Hom.op_inj œÜ.comm‚ÇÅ.symm\n      comm‚ÇÉ := Quiver.Hom.op_inj (by\n        dsimp\n        rw [assoc, ‚Üê opShiftFunctorEquivalence_unitIso_inv_naturality,\n          ‚Üê op_comp_assoc, ‚Üê Functor.map_comp, ‚Üê unop_comp, ‚Üê œÜ.comm‚ÇÉ,\n          unop_comp, Functor.map_comp, op_comp, assoc]) }\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.inverse_obj","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.inverse C).obj T) { unop := CategoryTheory.Pretriangulated.Triangle.mk T.mor‚ÇÇ.unop T.mor‚ÇÅ.unop (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 1).unitIso.inv.app T.obj‚ÇÅ).unop ((CategoryTheory.shiftFunctor C 1).map T.mor‚ÇÉ.unop)) }","decl":"/-- The functor which sends a triangle `X ‚ü∂ Y ‚ü∂ Z ‚ü∂ X‚ü¶1‚üß` in `C·µí·µñ` to the triangle\n`Z.unop ‚ü∂ Y.unop ‚ü∂ X.unop ‚ü∂ Z.unop‚ü¶1‚üß` in `C` (without introducing signs). -/\n@[simps]\nnoncomputable def inverse : Triangle C·µí·µñ ‚•§ (Triangle C)·µí·µñ where\n  obj T := Opposite.op (Triangle.mk T.mor‚ÇÇ.unop T.mor‚ÇÅ.unop\n      (((opShiftFunctorEquivalence C 1).unitIso.inv.app T.obj‚ÇÅ).unop ‚â´ T.mor‚ÇÉ.unop‚ü¶(1 : ‚Ñ§)‚üß'))\n  map {T‚ÇÅ T‚ÇÇ} œÜ := Quiver.Hom.op\n    { hom‚ÇÅ := œÜ.hom‚ÇÉ.unop\n      hom‚ÇÇ := œÜ.hom‚ÇÇ.unop\n      hom‚ÇÉ := œÜ.hom‚ÇÅ.unop\n      comm‚ÇÅ := Quiver.Hom.op_inj œÜ.comm‚ÇÇ.symm\n      comm‚ÇÇ := Quiver.Hom.op_inj œÜ.comm‚ÇÅ.symm\n      comm‚ÇÉ := Quiver.Hom.op_inj (by\n        dsimp\n        rw [assoc, ‚Üê opShiftFunctorEquivalence_unitIso_inv_naturality,\n          ‚Üê op_comp_assoc, ‚Üê Functor.map_comp, ‚Üê unop_comp, ‚Üê œÜ.comm‚ÇÉ,\n          unop_comp, Functor.map_comp, op_comp, assoc]) }\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.unitIso_hom_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite (CategoryTheory.Pretriangulated.Triangle C)\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.unitIso C).hom.app X) ((CategoryTheory.Pretriangulated.Triangle.mk (Opposite.unop X).mor‚ÇÅ (Opposite.unop X).mor‚ÇÇ (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 1).unitIso.inv.app { unop := (Opposite.unop X).obj‚ÇÉ }).unop ((CategoryTheory.shiftFunctor C 1).map (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite C) 1).map (Opposite.unop X).mor‚ÇÉ.op).unop ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 1).counitIso.inv.app { unop := (Opposite.unop X).obj‚ÇÅ }).unop)))).homMk (Opposite.unop X) (CategoryTheory.CategoryStruct.id (Opposite.unop X).obj‚ÇÅ) (CategoryTheory.CategoryStruct.id (Opposite.unop X).obj‚ÇÇ) (CategoryTheory.CategoryStruct.id (Opposite.unop X).obj‚ÇÉ) ‚ãØ ‚ãØ ‚ãØ).op","decl":"/-- The unit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ` . -/\n@[simps!]\nnoncomputable def unitIso : ùü≠ _ ‚âÖ functor C ‚ãô inverse C :=\n  NatIso.ofComponents (fun T => Iso.op\n    (Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) (by simp) (by simp)\n      (Quiver.Hom.op_inj\n        (by simp [shift_unop_opShiftFunctorEquivalence_counitIso_inv_app]))))\n    (fun {T‚ÇÅ T‚ÇÇ} f => Quiver.Hom.unop_inj (by aesop_cat))\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.unitIso_inv_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : Opposite (CategoryTheory.Pretriangulated.Triangle C)\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.unitIso C).inv.app X) ((Opposite.unop X).homMk (CategoryTheory.Pretriangulated.Triangle.mk (Opposite.unop X).mor‚ÇÅ (Opposite.unop X).mor‚ÇÇ (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 1).unitIso.inv.app { unop := (Opposite.unop X).obj‚ÇÉ }).unop ((CategoryTheory.shiftFunctor C 1).map (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite C) 1).map (Opposite.unop X).mor‚ÇÉ.op).unop ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C 1).counitIso.inv.app { unop := (Opposite.unop X).obj‚ÇÅ }).unop)))) (CategoryTheory.CategoryStruct.id (Opposite.unop X).obj‚ÇÅ) (CategoryTheory.CategoryStruct.id (Opposite.unop X).obj‚ÇÇ) (CategoryTheory.CategoryStruct.id (Opposite.unop X).obj‚ÇÉ) ‚ãØ ‚ãØ ‚ãØ).op","decl":"/-- The unit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ` . -/\n@[simps!]\nnoncomputable def unitIso : ùü≠ _ ‚âÖ functor C ‚ãô inverse C :=\n  NatIso.ofComponents (fun T => Iso.op\n    (Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) (by simp) (by simp)\n      (Quiver.Hom.op_inj\n        (by simp [shift_unop_opShiftFunctorEquivalence_counitIso_inv_app]))))\n    (fun {T‚ÇÅ T‚ÇÇ} f => Quiver.Hom.unop_inj (by aesop_cat))\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso_hom_app_hom‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C).hom.app X).hom‚ÇÇ (CategoryTheory.CategoryStruct.id X.obj‚ÇÇ)","decl":"/-- The counit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ` . -/\n@[simps!]\nnoncomputable def counitIso : inverse C ‚ãô functor C ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents (fun T => by\n    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_\n    ¬∑ simp\n    ¬∑ simp\n    ¬∑ dsimp\n      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,\n        ‚Üê opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,\n        opShiftFunctorEquivalence_counitIso_inv_app_shift, ‚Üê Functor.map_comp,\n        Iso.hom_inv_id_app, Functor.map_id]\n      simp only [Functor.id_obj, comp_id])\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso_inv_app_hom‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C).inv.app X).hom‚ÇÉ (CategoryTheory.CategoryStruct.id X.obj‚ÇÉ)","decl":"/-- The counit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ` . -/\n@[simps!]\nnoncomputable def counitIso : inverse C ‚ãô functor C ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents (fun T => by\n    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_\n    ¬∑ simp\n    ¬∑ simp\n    ¬∑ dsimp\n      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,\n        ‚Üê opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,\n        opShiftFunctorEquivalence_counitIso_inv_app_shift, ‚Üê Functor.map_comp,\n        Iso.hom_inv_id_app, Functor.map_id]\n      simp only [Functor.id_obj, comp_id])\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso_hom_app_hom‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C).hom.app X).hom‚ÇÉ (CategoryTheory.CategoryStruct.id X.obj‚ÇÉ)","decl":"/-- The counit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ` . -/\n@[simps!]\nnoncomputable def counitIso : inverse C ‚ãô functor C ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents (fun T => by\n    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_\n    ¬∑ simp\n    ¬∑ simp\n    ¬∑ dsimp\n      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,\n        ‚Üê opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,\n        opShiftFunctorEquivalence_counitIso_inv_app_shift, ‚Üê Functor.map_comp,\n        Iso.hom_inv_id_app, Functor.map_id]\n      simp only [Functor.id_obj, comp_id])\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso_inv_app_hom‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C).inv.app X).hom‚ÇÇ (CategoryTheory.CategoryStruct.id X.obj‚ÇÇ)","decl":"/-- The counit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ` . -/\n@[simps!]\nnoncomputable def counitIso : inverse C ‚ãô functor C ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents (fun T => by\n    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_\n    ¬∑ simp\n    ¬∑ simp\n    ¬∑ dsimp\n      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,\n        ‚Üê opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,\n        opShiftFunctorEquivalence_counitIso_inv_app_shift, ‚Üê Functor.map_comp,\n        Iso.hom_inv_id_app, Functor.map_id]\n      simp only [Functor.id_obj, comp_id])\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso_hom_app_hom‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C).hom.app X).hom‚ÇÅ (CategoryTheory.CategoryStruct.id X.obj‚ÇÅ)","decl":"/-- The counit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ` . -/\n@[simps!]\nnoncomputable def counitIso : inverse C ‚ãô functor C ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents (fun T => by\n    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_\n    ¬∑ simp\n    ¬∑ simp\n    ¬∑ dsimp\n      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,\n        ‚Üê opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,\n        opShiftFunctorEquivalence_counitIso_inv_app_shift, ‚Üê Functor.map_comp,\n        Iso.hom_inv_id_app, Functor.map_id]\n      simp only [Functor.id_obj, comp_id])\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso_inv_app_hom‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\nX : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n‚ä¢ Eq ((CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C).inv.app X).hom‚ÇÅ (CategoryTheory.CategoryStruct.id X.obj‚ÇÅ)","decl":"/-- The counit isomorphism of the\nequivalence `triangleOpEquivalence C : (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ` . -/\n@[simps!]\nnoncomputable def counitIso : inverse C ‚ãô functor C ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents (fun T => by\n    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_\n    ¬∑ simp\n    ¬∑ simp\n    ¬∑ dsimp\n      rw [Functor.map_id, comp_id, id_comp, Functor.map_comp,\n        ‚Üê opShiftFunctorEquivalence_counitIso_inv_naturality_assoc,\n        opShiftFunctorEquivalence_counitIso_inv_app_shift, ‚Üê Functor.map_comp,\n        Iso.hom_inv_id_app, Functor.map_id]\n      simp only [Functor.id_obj, comp_id])\n    (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleOpEquivalence_unitIso","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\n‚ä¢ Eq (CategoryTheory.Pretriangulated.triangleOpEquivalence C).unitIso (CategoryTheory.Pretriangulated.TriangleOpEquivalence.unitIso C)","decl":"/-- An anti-equivalence between the categories of triangles in `C` and in `C·µí·µñ`.\nA triangle in `C·µí·µñ` shall be distinguished iff it correspond to a distinguished\ntriangle in `C` via this equivalence. -/\n@[simps]\nnoncomputable def triangleOpEquivalence :\n    (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ where\n  functor := TriangleOpEquivalence.functor C\n  inverse := TriangleOpEquivalence.inverse C\n  unitIso := TriangleOpEquivalence.unitIso C\n  counitIso := TriangleOpEquivalence.counitIso C\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleOpEquivalence_inverse","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\n‚ä¢ Eq (CategoryTheory.Pretriangulated.triangleOpEquivalence C).inverse (CategoryTheory.Pretriangulated.TriangleOpEquivalence.inverse C)","decl":"/-- An anti-equivalence between the categories of triangles in `C` and in `C·µí·µñ`.\nA triangle in `C·µí·µñ` shall be distinguished iff it correspond to a distinguished\ntriangle in `C` via this equivalence. -/\n@[simps]\nnoncomputable def triangleOpEquivalence :\n    (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ where\n  functor := TriangleOpEquivalence.functor C\n  inverse := TriangleOpEquivalence.inverse C\n  unitIso := TriangleOpEquivalence.unitIso C\n  counitIso := TriangleOpEquivalence.counitIso C\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleOpEquivalence_counitIso","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\n‚ä¢ Eq (CategoryTheory.Pretriangulated.triangleOpEquivalence C).counitIso (CategoryTheory.Pretriangulated.TriangleOpEquivalence.counitIso C)","decl":"/-- An anti-equivalence between the categories of triangles in `C` and in `C·µí·µñ`.\nA triangle in `C·µí·µñ` shall be distinguished iff it correspond to a distinguished\ntriangle in `C` via this equivalence. -/\n@[simps]\nnoncomputable def triangleOpEquivalence :\n    (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ where\n  functor := TriangleOpEquivalence.functor C\n  inverse := TriangleOpEquivalence.inverse C\n  unitIso := TriangleOpEquivalence.unitIso C\n  counitIso := TriangleOpEquivalence.counitIso C\n\n"}
{"name":"CategoryTheory.Pretriangulated.triangleOpEquivalence_functor","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Triangle","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.HasShift C Int\n‚ä¢ Eq (CategoryTheory.Pretriangulated.triangleOpEquivalence C).functor (CategoryTheory.Pretriangulated.TriangleOpEquivalence.functor C)","decl":"/-- An anti-equivalence between the categories of triangles in `C` and in `C·µí·µñ`.\nA triangle in `C·µí·µñ` shall be distinguished iff it correspond to a distinguished\ntriangle in `C` via this equivalence. -/\n@[simps]\nnoncomputable def triangleOpEquivalence :\n    (Triangle C)·µí·µñ ‚âå Triangle C·µí·µñ where\n  functor := TriangleOpEquivalence.functor C\n  inverse := TriangleOpEquivalence.inverse C\n  unitIso := TriangleOpEquivalence.unitIso C\n  counitIso := TriangleOpEquivalence.counitIso C\n\n"}
