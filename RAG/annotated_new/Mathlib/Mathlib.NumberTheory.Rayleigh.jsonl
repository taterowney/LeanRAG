{"name":"compl_beattySeq","module":"Mathlib.NumberTheory.Rayleigh","initialProofState":"r s : Real\nhrs : r.IsConjExponent s\n⊢ Eq (HasCompl.compl (setOf fun x => Exists fun k => Eq (beattySeq r k) x)) (setOf fun x => Exists fun k => Eq (beattySeq' s k) x)","decl":"/-- Generalization of Rayleigh's theorem on Beatty sequences. Let `r` be a real number greater\nthan 1, and `1/r + 1/s = 1`. Then the complement of `B_r` is `B'_s`. -/\ntheorem compl_beattySeq {r s : ℝ} (hrs : r.IsConjExponent s) :\n    {beattySeq r k | k}ᶜ = {beattySeq' s k | k} := by\n  ext j\n  by_cases h₁ : j ∈ {beattySeq r k | k} <;> by_cases h₂ : j ∈ {beattySeq' s k | k}\n  · exact (Set.not_disjoint_iff.2 ⟨j, h₁, h₂⟩ (Beatty.no_collision hrs)).elim\n  · simp only [Set.mem_compl_iff, h₁, h₂, not_true_eq_false]\n  · simp only [Set.mem_compl_iff, h₁, h₂, not_false_eq_true]\n  · have ⟨k, h₁₁, h₁₂⟩ := (Beatty.hit_or_miss hrs.pos).resolve_left h₁\n    have ⟨m, h₂₁, h₂₂⟩ := (Beatty.hit_or_miss' hrs.symm.pos).resolve_left h₂\n    exact (Beatty.no_anticollision hrs ⟨j, k, m, h₁₁, h₁₂, h₂₁, h₂₂⟩).elim\n\n"}
{"name":"compl_beattySeq'","module":"Mathlib.NumberTheory.Rayleigh","initialProofState":"r s : Real\nhrs : r.IsConjExponent s\n⊢ Eq (HasCompl.compl (setOf fun x => Exists fun k => Eq (beattySeq' r k) x)) (setOf fun x => Exists fun k => Eq (beattySeq s k) x)","decl":"theorem compl_beattySeq' {r s : ℝ} (hrs : r.IsConjExponent s) :\n    {beattySeq' r k | k}ᶜ = {beattySeq s k | k} := by\n  rw [← compl_beattySeq hrs.symm, compl_compl]\n\n"}
{"name":"beattySeq_symmDiff_beattySeq'_pos","module":"Mathlib.NumberTheory.Rayleigh","initialProofState":"r s : Real\nhrs : r.IsConjExponent s\n⊢ Eq (symmDiff (setOf fun x => Exists fun k => And (GT.gt k 0) (Eq (beattySeq r k) x)) (setOf fun x => Exists fun k => And (GT.gt k 0) (Eq (beattySeq' s k) x))) (setOf fun n => LT.lt 0 n)","decl":"/-- Generalization of Rayleigh's theorem on Beatty sequences. Let `r` be a real number greater\nthan 1, and `1/r + 1/s = 1`. Then `B⁺_r` and `B⁺'_s` partition the positive integers. -/\ntheorem beattySeq_symmDiff_beattySeq'_pos {r s : ℝ} (hrs : r.IsConjExponent s) :\n    {beattySeq r k | k > 0} ∆ {beattySeq' s k | k > 0} = {n | 0 < n} := by\n  apply Set.eq_of_subset_of_subset\n  · rintro j (⟨⟨k, hk, hjk⟩, -⟩ | ⟨⟨k, hk, hjk⟩, -⟩)\n    · rw [Set.mem_setOf_eq, ← hjk, beattySeq, Int.floor_pos]\n      exact one_le_mul_of_one_le_of_one_le (by norm_cast) hrs.one_lt.le\n    · rw [Set.mem_setOf_eq, ← hjk, beattySeq', sub_pos, Int.lt_ceil, Int.cast_one]\n      exact one_lt_mul_of_le_of_lt (by norm_cast) hrs.symm.one_lt\n  intro j (hj : 0 < j)\n  have hb₁ : ∀ s ≥ 0, j ∈ {beattySeq s k | k > 0} ↔ j ∈ {beattySeq s k | k} := by\n    intro _ hs\n    refine ⟨fun ⟨k, _, hk⟩ ↦ ⟨k, hk⟩, fun ⟨k, hk⟩ ↦ ⟨k, ?_, hk⟩⟩\n    rw [← hk, beattySeq, Int.floor_pos] at hj\n    exact_mod_cast pos_of_mul_pos_left (zero_lt_one.trans_le hj) hs\n  have hb₂ : ∀ s ≥ 0, j ∈ {beattySeq' s k | k > 0} ↔ j ∈ {beattySeq' s k | k} := by\n    intro _ hs\n    refine ⟨fun ⟨k, _, hk⟩ ↦ ⟨k, hk⟩, fun ⟨k, hk⟩ ↦ ⟨k, ?_, hk⟩⟩\n    rw [← hk, beattySeq', sub_pos, Int.lt_ceil, Int.cast_one] at hj\n    exact_mod_cast pos_of_mul_pos_left (zero_lt_one.trans hj) hs\n  rw [Set.mem_symmDiff, hb₁ _ hrs.nonneg, hb₂ _ hrs.symm.nonneg, ← compl_beattySeq hrs,\n    Set.not_mem_compl_iff, Set.mem_compl_iff, and_self, and_self]\n  exact or_not\n\n"}
{"name":"beattySeq'_symmDiff_beattySeq_pos","module":"Mathlib.NumberTheory.Rayleigh","initialProofState":"r s : Real\nhrs : r.IsConjExponent s\n⊢ Eq (symmDiff (setOf fun x => Exists fun k => And (GT.gt k 0) (Eq (beattySeq' r k) x)) (setOf fun x => Exists fun k => And (GT.gt k 0) (Eq (beattySeq s k) x))) (setOf fun n => LT.lt 0 n)","decl":"theorem beattySeq'_symmDiff_beattySeq_pos {r s : ℝ} (hrs : r.IsConjExponent s) :\n    {beattySeq' r k | k > 0} ∆ {beattySeq s k | k > 0} = {n | 0 < n} := by\n  rw [symmDiff_comm, beattySeq_symmDiff_beattySeq'_pos hrs.symm]\n\n"}
{"name":"Irrational.beattySeq'_pos_eq","module":"Mathlib.NumberTheory.Rayleigh","initialProofState":"r : Real\nhr : Irrational r\n⊢ Eq (setOf fun x => Exists fun k => And (GT.gt k 0) (Eq (beattySeq' r k) x)) (setOf fun x => Exists fun k => And (GT.gt k 0) (Eq (beattySeq r k) x))","decl":"/-- Let `r` be an irrational number. Then `B⁺_r` and `B⁺'_r` are equal. -/\ntheorem Irrational.beattySeq'_pos_eq {r : ℝ} (hr : Irrational r) :\n    {beattySeq' r k | k > 0} = {beattySeq r k | k > 0} := by\n  dsimp only [beattySeq, beattySeq']\n  congr! 4; rename_i k; rw [and_congr_right_iff]; intro hk; congr!\n  rw [sub_eq_iff_eq_add, Int.ceil_eq_iff, Int.cast_add, Int.cast_one, add_sub_cancel_right]\n  refine ⟨(Int.floor_le _).lt_of_ne fun h ↦ ?_, (Int.lt_floor_add_one _).le⟩\n  exact (hr.int_mul hk.ne').ne_int ⌊k * r⌋ h.symm\n\n"}
{"name":"Irrational.beattySeq_symmDiff_beattySeq_pos","module":"Mathlib.NumberTheory.Rayleigh","initialProofState":"r s : Real\nhrs : r.IsConjExponent s\nhr : Irrational r\n⊢ Eq (symmDiff (setOf fun x => Exists fun k => And (GT.gt k 0) (Eq (beattySeq r k) x)) (setOf fun x => Exists fun k => And (GT.gt k 0) (Eq (beattySeq s k) x))) (setOf fun n => LT.lt 0 n)","decl":"/-- **Rayleigh's theorem** on Beatty sequences. Let `r` be an irrational number greater than 1, and\n`1/r + 1/s = 1`. Then `B⁺_r` and `B⁺_s` partition the positive integers. -/\ntheorem Irrational.beattySeq_symmDiff_beattySeq_pos {r s : ℝ}\n    (hrs : r.IsConjExponent s) (hr : Irrational r) :\n    {beattySeq r k | k > 0} ∆ {beattySeq s k | k > 0} = {n | 0 < n} := by\n  rw [← hr.beattySeq'_pos_eq, beattySeq'_symmDiff_beattySeq_pos hrs]\n"}
