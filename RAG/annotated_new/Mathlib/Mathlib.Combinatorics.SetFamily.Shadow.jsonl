{"name":"Finset.shadow_empty","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nâŠ¢ Eq EmptyCollection.emptyCollection.shadow EmptyCollection.emptyCollection","decl":"/-- The shadow of the empty set is empty. -/\n@[simp]\ntheorem shadow_empty : âˆ‚ (âˆ… : Finset (Finset Î±)) = âˆ… :=\n  rfl\n\n"}
{"name":"Finset.shadow_iterate_empty","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nk : Nat\nâŠ¢ Eq (Nat.iterate Finset.shadow k EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp] lemma shadow_iterate_empty (k : â„•) : âˆ‚^[k] (âˆ… : Finset (Finset Î±)) = âˆ… := by\n  induction' k <;> simp [*, shadow_empty]\n\n"}
{"name":"Finset.shadow_singleton_empty","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nâŠ¢ Eq (Singleton.singleton EmptyCollection.emptyCollection).shadow EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem shadow_singleton_empty : âˆ‚ ({âˆ…} : Finset (Finset Î±)) = âˆ… :=\n  rfl\n\n"}
{"name":"Finset.shadow_singleton","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\na : Î±\nâŠ¢ Eq (Singleton.singleton (Singleton.singleton a)).shadow (Singleton.singleton EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem shadow_singleton (a : Î±) : âˆ‚ {{a}} = {âˆ…} := by\n  simp [shadow]\n\n"}
{"name":"Finset.shadow_monotone","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nâŠ¢ Monotone Finset.shadow","decl":"/-- The shadow is monotone. -/\n@[mono]\ntheorem shadow_monotone : Monotone (shadow : Finset (Finset Î±) â†’ Finset (Finset Î±)) := fun _ _ =>\n  sup_mono\n\n"}
{"name":"Finset.shadow_mono","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ â„¬ : Finset (Finset Î±)\nhğ’œâ„¬ : HasSubset.Subset ğ’œ â„¬\nâŠ¢ HasSubset.Subset ğ’œ.shadow â„¬.shadow","decl":"@[gcongr] lemma shadow_mono (hğ’œâ„¬ : ğ’œ âŠ† â„¬) : âˆ‚ ğ’œ âŠ† âˆ‚ â„¬ := shadow_monotone hğ’œâ„¬\n\n"}
{"name":"Finset.mem_shadow_iff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nâŠ¢ Iff (Membership.mem ğ’œ.shadow t) (Exists fun s => And (Membership.mem ğ’œ s) (Exists fun a => And (Membership.mem s a) (Eq (s.erase a) t)))","decl":"/-- `t` is in the shadow of `ğ’œ` iff there is a `s âˆˆ ğ’œ` from which we can remove one element to\nget `t`. -/\nlemma mem_shadow_iff : t âˆˆ âˆ‚ ğ’œ â†” âˆƒ s âˆˆ ğ’œ, âˆƒ a âˆˆ s, erase s a = t := by\n  simp only [shadow, mem_sup, mem_image]\n\n"}
{"name":"Finset.erase_mem_shadow","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\na : Î±\nhs : Membership.mem ğ’œ s\nha : Membership.mem s a\nâŠ¢ Membership.mem ğ’œ.shadow (s.erase a)","decl":"theorem erase_mem_shadow (hs : s âˆˆ ğ’œ) (ha : a âˆˆ s) : erase s a âˆˆ âˆ‚ ğ’œ :=\n  mem_shadow_iff.2 âŸ¨s, hs, a, ha, rflâŸ©\n\n"}
{"name":"Finset.mem_shadow_iff_exists_sdiff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nâŠ¢ Iff (Membership.mem ğ’œ.shadow t) (Exists fun s => And (Membership.mem ğ’œ s) (And (HasSubset.Subset t s) (Eq (SDiff.sdiff s t).card 1)))","decl":"/-- `t âˆˆ âˆ‚ğ’œ` iff `t` is exactly one element less than something from `ğ’œ`.\n\nSee also `Finset.mem_shadow_iff_exists_mem_card_add_one`. -/\nlemma mem_shadow_iff_exists_sdiff : t âˆˆ âˆ‚ ğ’œ â†” âˆƒ s âˆˆ ğ’œ, t âŠ† s âˆ§ #(s \\ t) = 1 := by\n  simp_rw [mem_shadow_iff, â† covBy_iff_card_sdiff_eq_one, covBy_iff_exists_erase]\n\n"}
{"name":"Finset.mem_shadow_iff_insert_mem","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nâŠ¢ Iff (Membership.mem ğ’œ.shadow t) (Exists fun a => And (Not (Membership.mem t a)) (Membership.mem ğ’œ (Insert.insert a t)))","decl":"/-- `t` is in the shadow of `ğ’œ` iff we can add an element to it so that the resulting finset is in\n`ğ’œ`. -/\nlemma mem_shadow_iff_insert_mem : t âˆˆ âˆ‚ ğ’œ â†” âˆƒ a âˆ‰ t, insert a t âˆˆ ğ’œ := by\n  simp_rw [mem_shadow_iff_exists_sdiff, â† covBy_iff_card_sdiff_eq_one, covBy_iff_exists_insert]\n  aesop\n\n"}
{"name":"Finset.mem_shadow_iff_exists_mem_card_add_one","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nâŠ¢ Iff (Membership.mem ğ’œ.shadow t) (Exists fun s => And (Membership.mem ğ’œ s) (And (HasSubset.Subset t s) (Eq s.card (HAdd.hAdd t.card 1))))","decl":"/-- `s âˆˆ âˆ‚ ğ’œ` iff `s` is exactly one element less than something from `ğ’œ`.\n\nSee also `Finset.mem_shadow_iff_exists_sdiff`. -/\nlemma mem_shadow_iff_exists_mem_card_add_one : t âˆˆ âˆ‚ ğ’œ â†” âˆƒ s âˆˆ ğ’œ, t âŠ† s âˆ§ #s = #t + 1 := by\n  refine mem_shadow_iff_exists_sdiff.trans <| exists_congr fun t â†¦ and_congr_right fun _ â†¦\n    and_congr_right fun hst â†¦ ?_\n  rw [card_sdiff hst, tsub_eq_iff_eq_add_of_le, add_comm]\n  exact card_mono hst\n\n"}
{"name":"Finset.mem_shadow_iterate_iff_exists_card","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nk : Nat\nâŠ¢ Iff (Membership.mem (Nat.iterate Finset.shadow k ğ’œ) t) (Exists fun u => And (Eq u.card k) (And (Disjoint t u) (Membership.mem ğ’œ (Union.union t u))))","decl":"lemma mem_shadow_iterate_iff_exists_card :\n    t âˆˆ âˆ‚^[k] ğ’œ â†” âˆƒ u : Finset Î±, #u = k âˆ§ Disjoint t u âˆ§ t âˆª u âˆˆ ğ’œ := by\n  induction' k with k ih generalizing t\n  Â· simp\n  simp only [mem_shadow_iff_insert_mem, ih, Function.iterate_succ_apply', card_eq_succ]\n  aesop\n\n"}
{"name":"Finset.mem_shadow_iterate_iff_exists_sdiff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nk : Nat\nâŠ¢ Iff (Membership.mem (Nat.iterate Finset.shadow k ğ’œ) t) (Exists fun s => And (Membership.mem ğ’œ s) (And (HasSubset.Subset t s) (Eq (SDiff.sdiff s t).card k)))","decl":"/-- `t âˆˆ âˆ‚^k ğ’œ` iff `t` is exactly `k` elements less than something from `ğ’œ`.\n\nSee also `Finset.mem_shadow_iff_exists_mem_card_add`. -/\nlemma mem_shadow_iterate_iff_exists_sdiff : t âˆˆ âˆ‚^[k] ğ’œ â†” âˆƒ s âˆˆ ğ’œ, t âŠ† s âˆ§ #(s \\ t) = k := by\n  rw [mem_shadow_iterate_iff_exists_card]\n  constructor\n  Â· rintro âŸ¨u, rfl, htu, hsuAâŸ©\n    exact âŸ¨_, hsuA, subset_union_left, by rw [union_sdiff_cancel_left htu]âŸ©\n  Â· rintro âŸ¨s, hs, hts, rflâŸ©\n    refine âŸ¨s \\ t, rfl, disjoint_sdiff, ?_âŸ©\n    rwa [union_sdiff_self_eq_union, union_eq_right.2 hts]\n\n"}
{"name":"Finset.mem_shadow_iterate_iff_exists_mem_card_add","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nk : Nat\nâŠ¢ Iff (Membership.mem (Nat.iterate Finset.shadow k ğ’œ) t) (Exists fun s => And (Membership.mem ğ’œ s) (And (HasSubset.Subset t s) (Eq s.card (HAdd.hAdd t.card k))))","decl":"/-- `t âˆˆ âˆ‚^k ğ’œ` iff `t` is exactly `k` elements less than something in `ğ’œ`.\n\nSee also `Finset.mem_shadow_iterate_iff_exists_sdiff`. -/\nlemma mem_shadow_iterate_iff_exists_mem_card_add :\n    t âˆˆ âˆ‚^[k] ğ’œ â†” âˆƒ s âˆˆ ğ’œ, t âŠ† s âˆ§ #s = #t + k := by\n  refine mem_shadow_iterate_iff_exists_sdiff.trans <| exists_congr fun t â†¦ and_congr_right fun _ â†¦\n    and_congr_right fun hst â†¦ ?_\n  rw [card_sdiff hst, tsub_eq_iff_eq_add_of_le, add_comm]\n  exact card_mono hst\n\n"}
{"name":"Set.Sized.shadow","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nr : Nat\nhğ’œ : Set.Sized r â†‘ğ’œ\nâŠ¢ Set.Sized (HSub.hSub r 1) â†‘ğ’œ.shadow","decl":"/-- The shadow of a family of `r`-sets is a family of `r - 1`-sets. -/\nprotected theorem _root_.Set.Sized.shadow (hğ’œ : (ğ’œ : Set (Finset Î±)).Sized r) :\n    (âˆ‚ ğ’œ : Set (Finset Î±)).Sized (r - 1) := by\n  intro A h\n  obtain âŸ¨A, hA, i, hi, rflâŸ© := mem_shadow_iff.1 h\n  rw [card_erase_of_mem hi, hğ’œ hA]\n\n"}
{"name":"Set.Sized.shadow_iterate","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nk r : Nat\nhğ’œ : Set.Sized r â†‘ğ’œ\nâŠ¢ Set.Sized (HSub.hSub r k) â†‘(Nat.iterate Finset.shadow k ğ’œ)","decl":"/-- The `k`-th shadow of a family of `r`-sets is a family of `r - k`-sets. -/\nlemma _root_.Set.Sized.shadow_iterate (hğ’œ : (ğ’œ : Set (Finset Î±)).Sized r) :\n    (âˆ‚^[k] ğ’œ : Set (Finset Î±)).Sized (r - k) := by\n  simp_rw [Set.Sized, mem_coe, mem_shadow_iterate_iff_exists_sdiff]\n  rintro t âŸ¨s, hs, hts, rflâŸ©\n  rw [card_sdiff hts, â† hğ’œ hs, Nat.sub_sub_self (card_le_card hts)]\n\n"}
{"name":"Finset.sized_shadow_iff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nr : Nat\nh : Not (Membership.mem ğ’œ EmptyCollection.emptyCollection)\nâŠ¢ Iff (Set.Sized r â†‘ğ’œ.shadow) (Set.Sized (HAdd.hAdd r 1) â†‘ğ’œ)","decl":"theorem sized_shadow_iff (h : âˆ… âˆ‰ ğ’œ) :\n    (âˆ‚ ğ’œ : Set (Finset Î±)).Sized r â†” (ğ’œ : Set (Finset Î±)).Sized (r + 1) := by\n  refine âŸ¨fun hğ’œ s hs => ?_, Set.Sized.shadowâŸ©\n  obtain âŸ¨a, haâŸ© := nonempty_iff_ne_empty.2 (ne_of_mem_of_not_mem hs h)\n  rw [â† hğ’œ (erase_mem_shadow hs ha), card_erase_add_one ha]\n\n"}
{"name":"Finset.exists_subset_of_mem_shadow","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nhs : Membership.mem ğ’œ.shadow t\nâŠ¢ Exists fun s => And (Membership.mem ğ’œ s) (HasSubset.Subset t s)","decl":"/-- Being in the shadow of `ğ’œ` means we have a superset in `ğ’œ`. -/\nlemma exists_subset_of_mem_shadow (hs : t âˆˆ âˆ‚ ğ’œ) : âˆƒ s âˆˆ ğ’œ, t âŠ† s :=\n  let âŸ¨t, ht, hstâŸ© := mem_shadow_iff_exists_mem_card_add_one.1 hs\n  âŸ¨t, ht, hst.1âŸ©\n\n"}
{"name":"Finset.upShadow_empty","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nâŠ¢ Eq EmptyCollection.emptyCollection.upShadow EmptyCollection.emptyCollection","decl":"/-- The upper shadow of the empty set is empty. -/\n@[simp]\ntheorem upShadow_empty : âˆ‚âº (âˆ… : Finset (Finset Î±)) = âˆ… :=\n  rfl\n\n"}
{"name":"Finset.upShadow_monotone","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nâŠ¢ Monotone Finset.upShadow","decl":"/-- The upper shadow is monotone. -/\n@[mono]\ntheorem upShadow_monotone : Monotone (upShadow : Finset (Finset Î±) â†’ Finset (Finset Î±)) :=\n  fun _ _ => sup_mono\n\n"}
{"name":"Finset.mem_upShadow_iff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nâŠ¢ Iff (Membership.mem ğ’œ.upShadow t) (Exists fun s => And (Membership.mem ğ’œ s) (Exists fun a => And (Not (Membership.mem s a)) (Eq (Insert.insert a s) t)))","decl":"/-- `t` is in the upper shadow of `ğ’œ` iff there is a `s âˆˆ ğ’œ` from which we can remove one element\nto get `t`. -/\nlemma mem_upShadow_iff : t âˆˆ âˆ‚âº ğ’œ â†” âˆƒ s âˆˆ ğ’œ, âˆƒ a âˆ‰ s, insert a s = t := by\n  simp_rw [upShadow, mem_sup, mem_image, mem_compl]\n\n"}
{"name":"Finset.insert_mem_upShadow","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\na : Î±\nhs : Membership.mem ğ’œ s\nha : Not (Membership.mem s a)\nâŠ¢ Membership.mem ğ’œ.upShadow (Insert.insert a s)","decl":"theorem insert_mem_upShadow (hs : s âˆˆ ğ’œ) (ha : a âˆ‰ s) : insert a s âˆˆ âˆ‚âº ğ’œ :=\n  mem_upShadow_iff.2 âŸ¨s, hs, a, ha, rflâŸ©\n\n"}
{"name":"Finset.mem_upShadow_iff_exists_sdiff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nâŠ¢ Iff (Membership.mem ğ’œ.upShadow t) (Exists fun s => And (Membership.mem ğ’œ s) (And (HasSubset.Subset s t) (Eq (SDiff.sdiff t s).card 1)))","decl":"/-- `t` is in the upper shadow of `ğ’œ` iff `t` is exactly one element more than something from `ğ’œ`.\n\nSee also `Finset.mem_upShadow_iff_exists_mem_card_add_one`. -/\nlemma mem_upShadow_iff_exists_sdiff : t âˆˆ âˆ‚âº ğ’œ â†” âˆƒ s âˆˆ ğ’œ, s âŠ† t âˆ§ #(t \\ s) = 1 := by\n  simp_rw [mem_upShadow_iff, â† covBy_iff_card_sdiff_eq_one, covBy_iff_exists_insert]\n\n"}
{"name":"Finset.mem_upShadow_iff_erase_mem","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nâŠ¢ Iff (Membership.mem ğ’œ.upShadow t) (Exists fun a => And (Membership.mem t a) (Membership.mem ğ’œ (t.erase a)))","decl":"/-- `t` is in the upper shadow of `ğ’œ` iff we can remove an element from it so that the resulting\nfinset is in `ğ’œ`. -/\nlemma mem_upShadow_iff_erase_mem : t âˆˆ âˆ‚âº ğ’œ â†” âˆƒ a, a âˆˆ t âˆ§ erase t a âˆˆ ğ’œ := by\n  simp_rw [mem_upShadow_iff_exists_sdiff, â† covBy_iff_card_sdiff_eq_one, covBy_iff_exists_erase]\n  aesop\n\n"}
{"name":"Finset.mem_upShadow_iff_exists_mem_card_add_one","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nâŠ¢ Iff (Membership.mem ğ’œ.upShadow t) (Exists fun s => And (Membership.mem ğ’œ s) (And (HasSubset.Subset s t) (Eq t.card (HAdd.hAdd s.card 1))))","decl":"/-- `t` is in the upper shadow of `ğ’œ` iff `t` is exactly one element less than something from `ğ’œ`.\n\nSee also `Finset.mem_upShadow_iff_exists_sdiff`. -/\nlemma mem_upShadow_iff_exists_mem_card_add_one :\n    t âˆˆ âˆ‚âº ğ’œ â†” âˆƒ s âˆˆ ğ’œ, s âŠ† t âˆ§ #t = #s + 1 := by\n  refine mem_upShadow_iff_exists_sdiff.trans <| exists_congr fun t â†¦ and_congr_right fun _ â†¦\n    and_congr_right fun hst â†¦ ?_\n  rw [card_sdiff hst, tsub_eq_iff_eq_add_of_le, add_comm]\n  exact card_mono hst\n\n"}
{"name":"Finset.mem_upShadow_iterate_iff_exists_card","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nk : Nat\nâŠ¢ Iff (Membership.mem (Nat.iterate Finset.upShadow k ğ’œ) t) (Exists fun u => And (Eq u.card k) (And (HasSubset.Subset u t) (Membership.mem ğ’œ (SDiff.sdiff t u))))","decl":"lemma mem_upShadow_iterate_iff_exists_card :\n    t âˆˆ âˆ‚âº^[k] ğ’œ â†” âˆƒ u : Finset Î±, #u = k âˆ§ u âŠ† t âˆ§ t \\ u âˆˆ ğ’œ := by\n  induction' k with k ih generalizing t\n  Â· simp\n  simp only [mem_upShadow_iff_erase_mem, ih, Function.iterate_succ_apply', card_eq_succ,\n    subset_erase, erase_sdiff_comm, â† sdiff_insert]\n  constructor\n  Â· rintro âŸ¨a, hat, u, rfl, âŸ¨hut, hauâŸ©, htuâŸ©\n    exact âŸ¨_, âŸ¨_, _, hau, rfl, rflâŸ©, insert_subset hat hut, htuâŸ©\n  Â· rintro âŸ¨_, âŸ¨a, u, hau, rfl, rflâŸ©, hut, htuâŸ©\n    rw [insert_subset_iff] at hut\n    exact âŸ¨a, hut.1, _, rfl, âŸ¨hut.2, hauâŸ©, htuâŸ©\n\n"}
{"name":"Finset.mem_upShadow_iterate_iff_exists_sdiff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nk : Nat\nâŠ¢ Iff (Membership.mem (Nat.iterate Finset.upShadow k ğ’œ) t) (Exists fun s => And (Membership.mem ğ’œ s) (And (HasSubset.Subset s t) (Eq (SDiff.sdiff t s).card k)))","decl":"/-- `t` is in the upper shadow of `ğ’œ` iff `t` is exactly `k` elements less than something from `ğ’œ`.\n\nSee also `Finset.mem_upShadow_iff_exists_mem_card_add`. -/\nlemma mem_upShadow_iterate_iff_exists_sdiff : t âˆˆ âˆ‚âº^[k] ğ’œ â†” âˆƒ s âˆˆ ğ’œ, s âŠ† t âˆ§ #(t \\ s) = k := by\n  rw [mem_upShadow_iterate_iff_exists_card]\n  constructor\n  Â· rintro âŸ¨u, rfl, hut, htuâŸ©\n    exact âŸ¨_, htu, sdiff_subset, by rw [sdiff_sdiff_eq_self hut]âŸ©\n  Â· rintro âŸ¨s, hs, hst, rflâŸ©\n    exact âŸ¨_, rfl, sdiff_subset, by rwa [sdiff_sdiff_eq_self hst]âŸ©\n\n"}
{"name":"Finset.mem_upShadow_iterate_iff_exists_mem_card_add","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\nt : Finset Î±\nk : Nat\nâŠ¢ Iff (Membership.mem (Nat.iterate Finset.upShadow k ğ’œ) t) (Exists fun s => And (Membership.mem ğ’œ s) (And (HasSubset.Subset s t) (Eq t.card (HAdd.hAdd s.card k))))","decl":"/-- `t âˆˆ âˆ‚âº^k ğ’œ` iff `t` is exactly `k` elements less than something in `ğ’œ`.\n\nSee also `Finset.mem_upShadow_iterate_iff_exists_sdiff`. -/\nlemma mem_upShadow_iterate_iff_exists_mem_card_add :\n    t âˆˆ âˆ‚âº^[k] ğ’œ â†” âˆƒ s âˆˆ ğ’œ, s âŠ† t âˆ§ #t = #s + k := by\n  refine mem_upShadow_iterate_iff_exists_sdiff.trans <| exists_congr fun t â†¦ and_congr_right fun _ â†¦\n    and_congr_right fun hst â†¦ ?_\n  rw [card_sdiff hst, tsub_eq_iff_eq_add_of_le, add_comm]\n  exact card_mono hst\n\n"}
{"name":"Set.Sized.upShadow","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\nr : Nat\nhğ’œ : Set.Sized r â†‘ğ’œ\nâŠ¢ Set.Sized (HAdd.hAdd r 1) â†‘ğ’œ.upShadow","decl":"/-- The upper shadow of a family of `r`-sets is a family of `r + 1`-sets. -/\nprotected lemma _root_.Set.Sized.upShadow (hğ’œ : (ğ’œ : Set (Finset Î±)).Sized r) :\n    (âˆ‚âº ğ’œ : Set (Finset Î±)).Sized (r + 1) := by\n  intro A h\n  obtain âŸ¨A, hA, i, hi, rflâŸ© := mem_upShadow_iff.1 h\n  rw [card_insert_of_not_mem hi, hğ’œ hA]\n\n"}
{"name":"Finset.exists_subset_of_mem_upShadow","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\nhs : Membership.mem ğ’œ.upShadow s\nâŠ¢ Exists fun t => And (Membership.mem ğ’œ t) (HasSubset.Subset t s)","decl":"/-- Being in the upper shadow of `ğ’œ` means we have a superset in `ğ’œ`. -/\ntheorem exists_subset_of_mem_upShadow (hs : s âˆˆ âˆ‚âº ğ’œ) : âˆƒ t âˆˆ ğ’œ, t âŠ† s :=\n  let âŸ¨t, ht, hts, _âŸ© := mem_upShadow_iff_exists_mem_card_add_one.1 hs\n  âŸ¨t, ht, htsâŸ©\n\n"}
{"name":"Finset.mem_upShadow_iff_exists_mem_card_add","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\nk : Nat\nâŠ¢ Iff (Membership.mem (Nat.iterate Finset.upShadow k ğ’œ) s) (Exists fun t => And (Membership.mem ğ’œ t) (And (HasSubset.Subset t s) (Eq (HAdd.hAdd t.card k) s.card)))","decl":"/-- `t âˆˆ âˆ‚^k ğ’œ` iff `t` is exactly `k` elements more than something in `ğ’œ`. -/\ntheorem mem_upShadow_iff_exists_mem_card_add :\n    s âˆˆ âˆ‚âº ^[k] ğ’œ â†” âˆƒ t âˆˆ ğ’œ, t âŠ† s âˆ§ #t + k = #s := by\n  induction' k with k ih generalizing ğ’œ s\n  Â· refine âŸ¨fun hs => âŸ¨s, hs, Subset.refl _, rflâŸ©, ?_âŸ©\n    rintro âŸ¨t, ht, hst, hcardâŸ©\n    rwa [â† eq_of_subset_of_card_le hst hcard.ge]\n  simp only [exists_prop, Function.comp_apply, Function.iterate_succ]\n  refine ih.trans ?_\n  clear ih\n  constructor\n  Â· rintro âŸ¨t, ht, hts, hcardstâŸ©\n    obtain âŸ¨u, hu, hut, hcardtuâŸ© := mem_upShadow_iff_exists_mem_card_add_one.1 ht\n    refine âŸ¨u, hu, hut.trans hts, ?_âŸ©\n    rw [â† hcardst, hcardtu, add_right_comm]\n    rfl\n  Â· rintro âŸ¨t, ht, hts, hcardâŸ©\n    obtain âŸ¨u, htu, hus, huâŸ© := Finset.exists_subsuperset_card_eq hts (Nat.le_add_right _ 1)\n      (by omega)\n    refine âŸ¨u, mem_upShadow_iff_exists_mem_card_add_one.2 âŸ¨t, ht, htu, huâŸ©, hus, ?_âŸ©\n    rw [hu, â† hcard, add_right_comm]\n    rfl\n\n"}
{"name":"Finset.shadow_compls","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ Eq ğ’œ.compls.shadow ğ’œ.upShadow.compls","decl":"@[simp] lemma shadow_compls : âˆ‚ ğ’œá¶œË¢ = (âˆ‚âº ğ’œ)á¶œË¢ := by\n  ext s\n  simp only [mem_image, exists_prop, mem_shadow_iff, mem_upShadow_iff, mem_compls]\n  refine (compl_involutive.toPerm _).exists_congr_left.trans ?_\n  simp [â† compl_involutive.eq_iff]\n\n"}
{"name":"Finset.upShadow_compls","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ Eq ğ’œ.compls.upShadow ğ’œ.shadow.compls","decl":"@[simp] lemma upShadow_compls : âˆ‚âº ğ’œá¶œË¢ = (âˆ‚ ğ’œ)á¶œË¢ := by\n  ext s\n  simp only [mem_image, exists_prop, mem_shadow_iff, mem_upShadow_iff, mem_compls]\n  refine (compl_involutive.toPerm _).exists_congr_left.trans ?_\n  simp [â† compl_involutive.eq_iff]\n\n"}
