{"name":"Finset.shadow_empty","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq EmptyCollection.emptyCollection.shadow EmptyCollection.emptyCollection","decl":"/-- The shadow of the empty set is empty. -/\n@[simp]\ntheorem shadow_empty : ∂ (∅ : Finset (Finset α)) = ∅ :=\n  rfl\n\n"}
{"name":"Finset.shadow_iterate_empty","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nk : Nat\n⊢ Eq (Nat.iterate Finset.shadow k EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp] lemma shadow_iterate_empty (k : ℕ) : ∂^[k] (∅ : Finset (Finset α)) = ∅ := by\n  induction' k <;> simp [*, shadow_empty]\n\n"}
{"name":"Finset.shadow_singleton_empty","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq (Singleton.singleton EmptyCollection.emptyCollection).shadow EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem shadow_singleton_empty : ∂ ({∅} : Finset (Finset α)) = ∅ :=\n  rfl\n\n"}
{"name":"Finset.shadow_singleton","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Singleton.singleton (Singleton.singleton a)).shadow (Singleton.singleton EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem shadow_singleton (a : α) : ∂ {{a}} = {∅} := by\n  simp [shadow]\n\n"}
{"name":"Finset.shadow_monotone","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Monotone Finset.shadow","decl":"/-- The shadow is monotone. -/\n@[mono]\ntheorem shadow_monotone : Monotone (shadow : Finset (Finset α) → Finset (Finset α)) := fun _ _ =>\n  sup_mono\n\n"}
{"name":"Finset.shadow_mono","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 ℬ : Finset (Finset α)\nh𝒜ℬ : HasSubset.Subset 𝒜 ℬ\n⊢ HasSubset.Subset 𝒜.shadow ℬ.shadow","decl":"@[gcongr] lemma shadow_mono (h𝒜ℬ : 𝒜 ⊆ ℬ) : ∂ 𝒜 ⊆ ∂ ℬ := shadow_monotone h𝒜ℬ\n\n"}
{"name":"Finset.mem_shadow_iff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nt : Finset α\n⊢ Iff (Membership.mem 𝒜.shadow t) (Exists fun s => And (Membership.mem 𝒜 s) (Exists fun a => And (Membership.mem s a) (Eq (s.erase a) t)))","decl":"/-- `t` is in the shadow of `𝒜` iff there is a `s ∈ 𝒜` from which we can remove one element to\nget `t`. -/\nlemma mem_shadow_iff : t ∈ ∂ 𝒜 ↔ ∃ s ∈ 𝒜, ∃ a ∈ s, erase s a = t := by\n  simp only [shadow, mem_sup, mem_image]\n\n"}
{"name":"Finset.erase_mem_shadow","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\na : α\nhs : Membership.mem 𝒜 s\nha : Membership.mem s a\n⊢ Membership.mem 𝒜.shadow (s.erase a)","decl":"theorem erase_mem_shadow (hs : s ∈ 𝒜) (ha : a ∈ s) : erase s a ∈ ∂ 𝒜 :=\n  mem_shadow_iff.2 ⟨s, hs, a, ha, rfl⟩\n\n"}
{"name":"Finset.mem_shadow_iff_exists_sdiff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nt : Finset α\n⊢ Iff (Membership.mem 𝒜.shadow t) (Exists fun s => And (Membership.mem 𝒜 s) (And (HasSubset.Subset t s) (Eq (SDiff.sdiff s t).card 1)))","decl":"/-- `t ∈ ∂𝒜` iff `t` is exactly one element less than something from `𝒜`.\n\nSee also `Finset.mem_shadow_iff_exists_mem_card_add_one`. -/\nlemma mem_shadow_iff_exists_sdiff : t ∈ ∂ 𝒜 ↔ ∃ s ∈ 𝒜, t ⊆ s ∧ #(s \\ t) = 1 := by\n  simp_rw [mem_shadow_iff, ← covBy_iff_card_sdiff_eq_one, covBy_iff_exists_erase]\n\n"}
{"name":"Finset.mem_shadow_iff_insert_mem","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nt : Finset α\n⊢ Iff (Membership.mem 𝒜.shadow t) (Exists fun a => And (Not (Membership.mem t a)) (Membership.mem 𝒜 (Insert.insert a t)))","decl":"/-- `t` is in the shadow of `𝒜` iff we can add an element to it so that the resulting finset is in\n`𝒜`. -/\nlemma mem_shadow_iff_insert_mem : t ∈ ∂ 𝒜 ↔ ∃ a ∉ t, insert a t ∈ 𝒜 := by\n  simp_rw [mem_shadow_iff_exists_sdiff, ← covBy_iff_card_sdiff_eq_one, covBy_iff_exists_insert]\n  aesop\n\n"}
{"name":"Finset.mem_shadow_iff_exists_mem_card_add_one","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nt : Finset α\n⊢ Iff (Membership.mem 𝒜.shadow t) (Exists fun s => And (Membership.mem 𝒜 s) (And (HasSubset.Subset t s) (Eq s.card (HAdd.hAdd t.card 1))))","decl":"/-- `s ∈ ∂ 𝒜` iff `s` is exactly one element less than something from `𝒜`.\n\nSee also `Finset.mem_shadow_iff_exists_sdiff`. -/\nlemma mem_shadow_iff_exists_mem_card_add_one : t ∈ ∂ 𝒜 ↔ ∃ s ∈ 𝒜, t ⊆ s ∧ #s = #t + 1 := by\n  refine mem_shadow_iff_exists_sdiff.trans <| exists_congr fun t ↦ and_congr_right fun _ ↦\n    and_congr_right fun hst ↦ ?_\n  rw [card_sdiff hst, tsub_eq_iff_eq_add_of_le, add_comm]\n  exact card_mono hst\n\n"}
{"name":"Finset.mem_shadow_iterate_iff_exists_card","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nt : Finset α\nk : Nat\n⊢ Iff (Membership.mem (Nat.iterate Finset.shadow k 𝒜) t) (Exists fun u => And (Eq u.card k) (And (Disjoint t u) (Membership.mem 𝒜 (Union.union t u))))","decl":"lemma mem_shadow_iterate_iff_exists_card :\n    t ∈ ∂^[k] 𝒜 ↔ ∃ u : Finset α, #u = k ∧ Disjoint t u ∧ t ∪ u ∈ 𝒜 := by\n  induction' k with k ih generalizing t\n  · simp\n  simp only [mem_shadow_iff_insert_mem, ih, Function.iterate_succ_apply', card_eq_succ]\n  aesop\n\n"}
{"name":"Finset.mem_shadow_iterate_iff_exists_sdiff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nt : Finset α\nk : Nat\n⊢ Iff (Membership.mem (Nat.iterate Finset.shadow k 𝒜) t) (Exists fun s => And (Membership.mem 𝒜 s) (And (HasSubset.Subset t s) (Eq (SDiff.sdiff s t).card k)))","decl":"/-- `t ∈ ∂^k 𝒜` iff `t` is exactly `k` elements less than something from `𝒜`.\n\nSee also `Finset.mem_shadow_iff_exists_mem_card_add`. -/\nlemma mem_shadow_iterate_iff_exists_sdiff : t ∈ ∂^[k] 𝒜 ↔ ∃ s ∈ 𝒜, t ⊆ s ∧ #(s \\ t) = k := by\n  rw [mem_shadow_iterate_iff_exists_card]\n  constructor\n  · rintro ⟨u, rfl, htu, hsuA⟩\n    exact ⟨_, hsuA, subset_union_left, by rw [union_sdiff_cancel_left htu]⟩\n  · rintro ⟨s, hs, hts, rfl⟩\n    refine ⟨s \\ t, rfl, disjoint_sdiff, ?_⟩\n    rwa [union_sdiff_self_eq_union, union_eq_right.2 hts]\n\n"}
{"name":"Finset.mem_shadow_iterate_iff_exists_mem_card_add","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nt : Finset α\nk : Nat\n⊢ Iff (Membership.mem (Nat.iterate Finset.shadow k 𝒜) t) (Exists fun s => And (Membership.mem 𝒜 s) (And (HasSubset.Subset t s) (Eq s.card (HAdd.hAdd t.card k))))","decl":"/-- `t ∈ ∂^k 𝒜` iff `t` is exactly `k` elements less than something in `𝒜`.\n\nSee also `Finset.mem_shadow_iterate_iff_exists_sdiff`. -/\nlemma mem_shadow_iterate_iff_exists_mem_card_add :\n    t ∈ ∂^[k] 𝒜 ↔ ∃ s ∈ 𝒜, t ⊆ s ∧ #s = #t + k := by\n  refine mem_shadow_iterate_iff_exists_sdiff.trans <| exists_congr fun t ↦ and_congr_right fun _ ↦\n    and_congr_right fun hst ↦ ?_\n  rw [card_sdiff hst, tsub_eq_iff_eq_add_of_le, add_comm]\n  exact card_mono hst\n\n"}
{"name":"Set.Sized.shadow","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nr : Nat\nh𝒜 : Set.Sized r ↑𝒜\n⊢ Set.Sized (HSub.hSub r 1) ↑𝒜.shadow","decl":"/-- The shadow of a family of `r`-sets is a family of `r - 1`-sets. -/\nprotected theorem _root_.Set.Sized.shadow (h𝒜 : (𝒜 : Set (Finset α)).Sized r) :\n    (∂ 𝒜 : Set (Finset α)).Sized (r - 1) := by\n  intro A h\n  obtain ⟨A, hA, i, hi, rfl⟩ := mem_shadow_iff.1 h\n  rw [card_erase_of_mem hi, h𝒜 hA]\n\n"}
{"name":"Set.Sized.shadow_iterate","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nk r : Nat\nh𝒜 : Set.Sized r ↑𝒜\n⊢ Set.Sized (HSub.hSub r k) ↑(Nat.iterate Finset.shadow k 𝒜)","decl":"/-- The `k`-th shadow of a family of `r`-sets is a family of `r - k`-sets. -/\nlemma _root_.Set.Sized.shadow_iterate (h𝒜 : (𝒜 : Set (Finset α)).Sized r) :\n    (∂^[k] 𝒜 : Set (Finset α)).Sized (r - k) := by\n  simp_rw [Set.Sized, mem_coe, mem_shadow_iterate_iff_exists_sdiff]\n  rintro t ⟨s, hs, hts, rfl⟩\n  rw [card_sdiff hts, ← h𝒜 hs, Nat.sub_sub_self (card_le_card hts)]\n\n"}
{"name":"Finset.sized_shadow_iff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nr : Nat\nh : Not (Membership.mem 𝒜 EmptyCollection.emptyCollection)\n⊢ Iff (Set.Sized r ↑𝒜.shadow) (Set.Sized (HAdd.hAdd r 1) ↑𝒜)","decl":"theorem sized_shadow_iff (h : ∅ ∉ 𝒜) :\n    (∂ 𝒜 : Set (Finset α)).Sized r ↔ (𝒜 : Set (Finset α)).Sized (r + 1) := by\n  refine ⟨fun h𝒜 s hs => ?_, Set.Sized.shadow⟩\n  obtain ⟨a, ha⟩ := nonempty_iff_ne_empty.2 (ne_of_mem_of_not_mem hs h)\n  rw [← h𝒜 (erase_mem_shadow hs ha), card_erase_add_one ha]\n\n"}
{"name":"Finset.exists_subset_of_mem_shadow","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nt : Finset α\nhs : Membership.mem 𝒜.shadow t\n⊢ Exists fun s => And (Membership.mem 𝒜 s) (HasSubset.Subset t s)","decl":"/-- Being in the shadow of `𝒜` means we have a superset in `𝒜`. -/\nlemma exists_subset_of_mem_shadow (hs : t ∈ ∂ 𝒜) : ∃ s ∈ 𝒜, t ⊆ s :=\n  let ⟨t, ht, hst⟩ := mem_shadow_iff_exists_mem_card_add_one.1 hs\n  ⟨t, ht, hst.1⟩\n\n"}
{"name":"Finset.upShadow_empty","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Eq EmptyCollection.emptyCollection.upShadow EmptyCollection.emptyCollection","decl":"/-- The upper shadow of the empty set is empty. -/\n@[simp]\ntheorem upShadow_empty : ∂⁺ (∅ : Finset (Finset α)) = ∅ :=\n  rfl\n\n"}
{"name":"Finset.upShadow_monotone","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Monotone Finset.upShadow","decl":"/-- The upper shadow is monotone. -/\n@[mono]\ntheorem upShadow_monotone : Monotone (upShadow : Finset (Finset α) → Finset (Finset α)) :=\n  fun _ _ => sup_mono\n\n"}
{"name":"Finset.mem_upShadow_iff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nt : Finset α\n⊢ Iff (Membership.mem 𝒜.upShadow t) (Exists fun s => And (Membership.mem 𝒜 s) (Exists fun a => And (Not (Membership.mem s a)) (Eq (Insert.insert a s) t)))","decl":"/-- `t` is in the upper shadow of `𝒜` iff there is a `s ∈ 𝒜` from which we can remove one element\nto get `t`. -/\nlemma mem_upShadow_iff : t ∈ ∂⁺ 𝒜 ↔ ∃ s ∈ 𝒜, ∃ a ∉ s, insert a s = t := by\n  simp_rw [upShadow, mem_sup, mem_image, mem_compl]\n\n"}
{"name":"Finset.insert_mem_upShadow","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\ns : Finset α\na : α\nhs : Membership.mem 𝒜 s\nha : Not (Membership.mem s a)\n⊢ Membership.mem 𝒜.upShadow (Insert.insert a s)","decl":"theorem insert_mem_upShadow (hs : s ∈ 𝒜) (ha : a ∉ s) : insert a s ∈ ∂⁺ 𝒜 :=\n  mem_upShadow_iff.2 ⟨s, hs, a, ha, rfl⟩\n\n"}
{"name":"Finset.mem_upShadow_iff_exists_sdiff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nt : Finset α\n⊢ Iff (Membership.mem 𝒜.upShadow t) (Exists fun s => And (Membership.mem 𝒜 s) (And (HasSubset.Subset s t) (Eq (SDiff.sdiff t s).card 1)))","decl":"/-- `t` is in the upper shadow of `𝒜` iff `t` is exactly one element more than something from `𝒜`.\n\nSee also `Finset.mem_upShadow_iff_exists_mem_card_add_one`. -/\nlemma mem_upShadow_iff_exists_sdiff : t ∈ ∂⁺ 𝒜 ↔ ∃ s ∈ 𝒜, s ⊆ t ∧ #(t \\ s) = 1 := by\n  simp_rw [mem_upShadow_iff, ← covBy_iff_card_sdiff_eq_one, covBy_iff_exists_insert]\n\n"}
{"name":"Finset.mem_upShadow_iff_erase_mem","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nt : Finset α\n⊢ Iff (Membership.mem 𝒜.upShadow t) (Exists fun a => And (Membership.mem t a) (Membership.mem 𝒜 (t.erase a)))","decl":"/-- `t` is in the upper shadow of `𝒜` iff we can remove an element from it so that the resulting\nfinset is in `𝒜`. -/\nlemma mem_upShadow_iff_erase_mem : t ∈ ∂⁺ 𝒜 ↔ ∃ a, a ∈ t ∧ erase t a ∈ 𝒜 := by\n  simp_rw [mem_upShadow_iff_exists_sdiff, ← covBy_iff_card_sdiff_eq_one, covBy_iff_exists_erase]\n  aesop\n\n"}
{"name":"Finset.mem_upShadow_iff_exists_mem_card_add_one","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nt : Finset α\n⊢ Iff (Membership.mem 𝒜.upShadow t) (Exists fun s => And (Membership.mem 𝒜 s) (And (HasSubset.Subset s t) (Eq t.card (HAdd.hAdd s.card 1))))","decl":"/-- `t` is in the upper shadow of `𝒜` iff `t` is exactly one element less than something from `𝒜`.\n\nSee also `Finset.mem_upShadow_iff_exists_sdiff`. -/\nlemma mem_upShadow_iff_exists_mem_card_add_one :\n    t ∈ ∂⁺ 𝒜 ↔ ∃ s ∈ 𝒜, s ⊆ t ∧ #t = #s + 1 := by\n  refine mem_upShadow_iff_exists_sdiff.trans <| exists_congr fun t ↦ and_congr_right fun _ ↦\n    and_congr_right fun hst ↦ ?_\n  rw [card_sdiff hst, tsub_eq_iff_eq_add_of_le, add_comm]\n  exact card_mono hst\n\n"}
{"name":"Finset.mem_upShadow_iterate_iff_exists_card","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nt : Finset α\nk : Nat\n⊢ Iff (Membership.mem (Nat.iterate Finset.upShadow k 𝒜) t) (Exists fun u => And (Eq u.card k) (And (HasSubset.Subset u t) (Membership.mem 𝒜 (SDiff.sdiff t u))))","decl":"lemma mem_upShadow_iterate_iff_exists_card :\n    t ∈ ∂⁺^[k] 𝒜 ↔ ∃ u : Finset α, #u = k ∧ u ⊆ t ∧ t \\ u ∈ 𝒜 := by\n  induction' k with k ih generalizing t\n  · simp\n  simp only [mem_upShadow_iff_erase_mem, ih, Function.iterate_succ_apply', card_eq_succ,\n    subset_erase, erase_sdiff_comm, ← sdiff_insert]\n  constructor\n  · rintro ⟨a, hat, u, rfl, ⟨hut, hau⟩, htu⟩\n    exact ⟨_, ⟨_, _, hau, rfl, rfl⟩, insert_subset hat hut, htu⟩\n  · rintro ⟨_, ⟨a, u, hau, rfl, rfl⟩, hut, htu⟩\n    rw [insert_subset_iff] at hut\n    exact ⟨a, hut.1, _, rfl, ⟨hut.2, hau⟩, htu⟩\n\n"}
{"name":"Finset.mem_upShadow_iterate_iff_exists_sdiff","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nt : Finset α\nk : Nat\n⊢ Iff (Membership.mem (Nat.iterate Finset.upShadow k 𝒜) t) (Exists fun s => And (Membership.mem 𝒜 s) (And (HasSubset.Subset s t) (Eq (SDiff.sdiff t s).card k)))","decl":"/-- `t` is in the upper shadow of `𝒜` iff `t` is exactly `k` elements less than something from `𝒜`.\n\nSee also `Finset.mem_upShadow_iff_exists_mem_card_add`. -/\nlemma mem_upShadow_iterate_iff_exists_sdiff : t ∈ ∂⁺^[k] 𝒜 ↔ ∃ s ∈ 𝒜, s ⊆ t ∧ #(t \\ s) = k := by\n  rw [mem_upShadow_iterate_iff_exists_card]\n  constructor\n  · rintro ⟨u, rfl, hut, htu⟩\n    exact ⟨_, htu, sdiff_subset, by rw [sdiff_sdiff_eq_self hut]⟩\n  · rintro ⟨s, hs, hst, rfl⟩\n    exact ⟨_, rfl, sdiff_subset, by rwa [sdiff_sdiff_eq_self hst]⟩\n\n"}
{"name":"Finset.mem_upShadow_iterate_iff_exists_mem_card_add","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nt : Finset α\nk : Nat\n⊢ Iff (Membership.mem (Nat.iterate Finset.upShadow k 𝒜) t) (Exists fun s => And (Membership.mem 𝒜 s) (And (HasSubset.Subset s t) (Eq t.card (HAdd.hAdd s.card k))))","decl":"/-- `t ∈ ∂⁺^k 𝒜` iff `t` is exactly `k` elements less than something in `𝒜`.\n\nSee also `Finset.mem_upShadow_iterate_iff_exists_sdiff`. -/\nlemma mem_upShadow_iterate_iff_exists_mem_card_add :\n    t ∈ ∂⁺^[k] 𝒜 ↔ ∃ s ∈ 𝒜, s ⊆ t ∧ #t = #s + k := by\n  refine mem_upShadow_iterate_iff_exists_sdiff.trans <| exists_congr fun t ↦ and_congr_right fun _ ↦\n    and_congr_right fun hst ↦ ?_\n  rw [card_sdiff hst, tsub_eq_iff_eq_add_of_le, add_comm]\n  exact card_mono hst\n\n"}
{"name":"Set.Sized.upShadow","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\nr : Nat\nh𝒜 : Set.Sized r ↑𝒜\n⊢ Set.Sized (HAdd.hAdd r 1) ↑𝒜.upShadow","decl":"/-- The upper shadow of a family of `r`-sets is a family of `r + 1`-sets. -/\nprotected lemma _root_.Set.Sized.upShadow (h𝒜 : (𝒜 : Set (Finset α)).Sized r) :\n    (∂⁺ 𝒜 : Set (Finset α)).Sized (r + 1) := by\n  intro A h\n  obtain ⟨A, hA, i, hi, rfl⟩ := mem_upShadow_iff.1 h\n  rw [card_insert_of_not_mem hi, h𝒜 hA]\n\n"}
{"name":"Finset.exists_subset_of_mem_upShadow","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\ns : Finset α\nhs : Membership.mem 𝒜.upShadow s\n⊢ Exists fun t => And (Membership.mem 𝒜 t) (HasSubset.Subset t s)","decl":"/-- Being in the upper shadow of `𝒜` means we have a superset in `𝒜`. -/\ntheorem exists_subset_of_mem_upShadow (hs : s ∈ ∂⁺ 𝒜) : ∃ t ∈ 𝒜, t ⊆ s :=\n  let ⟨t, ht, hts, _⟩ := mem_upShadow_iff_exists_mem_card_add_one.1 hs\n  ⟨t, ht, hts⟩\n\n"}
{"name":"Finset.mem_upShadow_iff_exists_mem_card_add","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\ns : Finset α\nk : Nat\n⊢ Iff (Membership.mem (Nat.iterate Finset.upShadow k 𝒜) s) (Exists fun t => And (Membership.mem 𝒜 t) (And (HasSubset.Subset t s) (Eq (HAdd.hAdd t.card k) s.card)))","decl":"/-- `t ∈ ∂^k 𝒜` iff `t` is exactly `k` elements more than something in `𝒜`. -/\ntheorem mem_upShadow_iff_exists_mem_card_add :\n    s ∈ ∂⁺ ^[k] 𝒜 ↔ ∃ t ∈ 𝒜, t ⊆ s ∧ #t + k = #s := by\n  induction' k with k ih generalizing 𝒜 s\n  · refine ⟨fun hs => ⟨s, hs, Subset.refl _, rfl⟩, ?_⟩\n    rintro ⟨t, ht, hst, hcard⟩\n    rwa [← eq_of_subset_of_card_le hst hcard.ge]\n  simp only [exists_prop, Function.comp_apply, Function.iterate_succ]\n  refine ih.trans ?_\n  clear ih\n  constructor\n  · rintro ⟨t, ht, hts, hcardst⟩\n    obtain ⟨u, hu, hut, hcardtu⟩ := mem_upShadow_iff_exists_mem_card_add_one.1 ht\n    refine ⟨u, hu, hut.trans hts, ?_⟩\n    rw [← hcardst, hcardtu, add_right_comm]\n    rfl\n  · rintro ⟨t, ht, hts, hcard⟩\n    obtain ⟨u, htu, hus, hu⟩ := Finset.exists_subsuperset_card_eq hts (Nat.le_add_right _ 1)\n      (by omega)\n    refine ⟨u, mem_upShadow_iff_exists_mem_card_add_one.2 ⟨t, ht, htu, hu⟩, hus, ?_⟩\n    rw [hu, ← hcard, add_right_comm]\n    rfl\n\n"}
{"name":"Finset.shadow_compls","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\n⊢ Eq 𝒜.compls.shadow 𝒜.upShadow.compls","decl":"@[simp] lemma shadow_compls : ∂ 𝒜ᶜˢ = (∂⁺ 𝒜)ᶜˢ := by\n  ext s\n  simp only [mem_image, exists_prop, mem_shadow_iff, mem_upShadow_iff, mem_compls]\n  refine (compl_involutive.toPerm _).exists_congr_left.trans ?_\n  simp [← compl_involutive.eq_iff]\n\n"}
{"name":"Finset.upShadow_compls","module":"Mathlib.Combinatorics.SetFamily.Shadow","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 : Finset (Finset α)\n⊢ Eq 𝒜.compls.upShadow 𝒜.shadow.compls","decl":"@[simp] lemma upShadow_compls : ∂⁺ 𝒜ᶜˢ = (∂ 𝒜)ᶜˢ := by\n  ext s\n  simp only [mem_image, exists_prop, mem_shadow_iff, mem_upShadow_iff, mem_compls]\n  refine (compl_involutive.toPerm _).exists_congr_left.trans ?_\n  simp [← compl_involutive.eq_iff]\n\n"}
