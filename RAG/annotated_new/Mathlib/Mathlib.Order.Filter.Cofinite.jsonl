{"name":"Filter.mem_cofinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ns : Set Œ±\n‚ä¢ Iff (Membership.mem Filter.cofinite s) (HasCompl.compl s).Finite","decl":"@[simp]\ntheorem mem_cofinite {s : Set Œ±} : s ‚àà @cofinite Œ± ‚Üî s·∂ú.Finite :=\n  Iff.rfl\n\n"}
{"name":"Filter.eventually_cofinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\np : Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun x => p x) Filter.cofinite) (setOf fun x => Not (p x)).Finite","decl":"@[simp]\ntheorem eventually_cofinite {p : Œ± ‚Üí Prop} : (‚àÄ·∂† x in cofinite, p x) ‚Üî { x | ¬¨p x }.Finite :=\n  Iff.rfl\n\n"}
{"name":"Filter.hasBasis_cofinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\n‚ä¢ Filter.cofinite.HasBasis (fun s => s.Finite) HasCompl.compl","decl":"theorem hasBasis_cofinite : HasBasis cofinite (fun s : Set Œ± => s.Finite) compl :=\n  ‚ü®fun s =>\n    ‚ü®fun h => ‚ü®s·∂ú, h, (compl_compl s).subset‚ü©, fun ‚ü®_t, htf, hts‚ü© =>\n      htf.subset <| compl_subset_comm.2 hts‚ü©‚ü©\n\n"}
{"name":"Filter.cofinite_neBot","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ninst‚úù : Infinite Œ±\n‚ä¢ Filter.cofinite.NeBot","decl":"instance cofinite_neBot [Infinite Œ±] : NeBot (@cofinite Œ±) :=\n  hasBasis_cofinite.neBot_iff.2 fun hs => hs.infinite_compl.nonempty\n\n"}
{"name":"Filter.cofinite_eq_bot_iff","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\n‚ä¢ Iff (Eq Filter.cofinite Bot.bot) (Finite Œ±)","decl":"@[simp]\ntheorem cofinite_eq_bot_iff : @cofinite Œ± = ‚ä• ‚Üî Finite Œ± := by\n  simp [‚Üê empty_mem_iff_bot, finite_univ_iff]\n\n"}
{"name":"Filter.cofinite_eq_bot","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ninst‚úù : Finite Œ±\n‚ä¢ Eq Filter.cofinite Bot.bot","decl":"@[simp]\ntheorem cofinite_eq_bot [Finite Œ±] : @cofinite Œ± = ‚ä• := cofinite_eq_bot_iff.2 ‚Äπ_‚Ä∫\n\n"}
{"name":"Filter.frequently_cofinite_iff_infinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\np : Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Frequently (fun x => p x) Filter.cofinite) (setOf fun x => p x).Infinite","decl":"theorem frequently_cofinite_iff_infinite {p : Œ± ‚Üí Prop} :\n    (‚àÉ·∂† x in cofinite, p x) ‚Üî Set.Infinite { x | p x } := by\n  simp only [Filter.Frequently, eventually_cofinite, not_not, Set.Infinite]\n\n"}
{"name":"Filter.frequently_cofinite_mem_iff_infinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ns : Set Œ±\n‚ä¢ Iff (Filter.Frequently (fun x => Membership.mem s x) Filter.cofinite) s.Infinite","decl":"lemma frequently_cofinite_mem_iff_infinite {s : Set Œ±} : (‚àÉ·∂† x in cofinite, x ‚àà s) ‚Üî s.Infinite :=\n  frequently_cofinite_iff_infinite\n\n"}
{"name":"Set.Infinite.frequently_cofinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ns : Set Œ±\na‚úù : s.Infinite\n‚ä¢ Filter.Frequently (fun x => Membership.mem s x) Filter.cofinite","decl":"alias ‚ü®_, _root_.Set.Infinite.frequently_cofinite‚ü© := frequently_cofinite_mem_iff_infinite\n\n"}
{"name":"Filter.cofinite_inf_principal_neBot_iff","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ns : Set Œ±\n‚ä¢ Iff (Min.min Filter.cofinite (Filter.principal s)).NeBot s.Infinite","decl":"@[simp]\nlemma cofinite_inf_principal_neBot_iff {s : Set Œ±} : (cofinite ‚äì ùìü s).NeBot ‚Üî s.Infinite :=\n  frequently_mem_iff_neBot.symm.trans frequently_cofinite_mem_iff_infinite\n\n"}
{"name":"Set.Infinite.cofinite_inf_principal_neBot","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ns : Set Œ±\na‚úù : s.Infinite\n‚ä¢ (Min.min Filter.cofinite (Filter.principal s)).NeBot","decl":"alias ‚ü®_, _root_.Set.Infinite.cofinite_inf_principal_neBot‚ü© := cofinite_inf_principal_neBot_iff\n\n"}
{"name":"Set.Finite.compl_mem_cofinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ns : Set Œ±\nhs : s.Finite\n‚ä¢ Membership.mem Filter.cofinite (HasCompl.compl s)","decl":"theorem _root_.Set.Finite.compl_mem_cofinite {s : Set Œ±} (hs : s.Finite) : s·∂ú ‚àà @cofinite Œ± :=\n  mem_cofinite.2 <| (compl_compl s).symm ‚ñ∏ hs\n\n"}
{"name":"Set.Finite.eventually_cofinite_nmem","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ns : Set Œ±\nhs : s.Finite\n‚ä¢ Filter.Eventually (fun x => Not (Membership.mem s x)) Filter.cofinite","decl":"theorem _root_.Set.Finite.eventually_cofinite_nmem {s : Set Œ±} (hs : s.Finite) :\n    ‚àÄ·∂† x in cofinite, x ‚àâ s :=\n  hs.compl_mem_cofinite\n\n"}
{"name":"Finset.eventually_cofinite_nmem","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ns : Finset Œ±\n‚ä¢ Filter.Eventually (fun x => Not (Membership.mem s x)) Filter.cofinite","decl":"theorem _root_.Finset.eventually_cofinite_nmem (s : Finset Œ±) : ‚àÄ·∂† x in cofinite, x ‚àâ s :=\n  s.finite_toSet.eventually_cofinite_nmem\n\n"}
{"name":"Set.infinite_iff_frequently_cofinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ns : Set Œ±\n‚ä¢ Iff s.Infinite (Filter.Frequently (fun x => Membership.mem s x) Filter.cofinite)","decl":"theorem _root_.Set.infinite_iff_frequently_cofinite {s : Set Œ±} :\n    Set.Infinite s ‚Üî ‚àÉ·∂† x in cofinite, x ‚àà s :=\n  frequently_cofinite_iff_infinite.symm\n\n"}
{"name":"Filter.eventually_cofinite_ne","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nx : Œ±\n‚ä¢ Filter.Eventually (fun a => Ne a x) Filter.cofinite","decl":"theorem eventually_cofinite_ne (x : Œ±) : ‚àÄ·∂† a in cofinite, a ‚â† x :=\n  (Set.finite_singleton x).eventually_cofinite_nmem\n\n"}
{"name":"Filter.le_cofinite_iff_compl_singleton_mem","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nl : Filter Œ±\n‚ä¢ Iff (LE.le l Filter.cofinite) (‚àÄ (x : Œ±), Membership.mem l (HasCompl.compl (Singleton.singleton x)))","decl":"theorem le_cofinite_iff_compl_singleton_mem : l ‚â§ cofinite ‚Üî ‚àÄ x, {x}·∂ú ‚àà l := by\n  refine ‚ü®fun h x => h (finite_singleton x).compl_mem_cofinite, fun h s (hs : s·∂ú.Finite) => ?_‚ü©\n  rw [‚Üê compl_compl s, ‚Üê biUnion_of_singleton s·∂ú, compl_iUnion‚ÇÇ, Filter.biInter_mem hs]\n  exact fun x _ => h x\n\n"}
{"name":"Filter.le_cofinite_iff_eventually_ne","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nl : Filter Œ±\n‚ä¢ Iff (LE.le l Filter.cofinite) (‚àÄ (x : Œ±), Filter.Eventually (fun y => Ne y x) l)","decl":"theorem le_cofinite_iff_eventually_ne : l ‚â§ cofinite ‚Üî ‚àÄ x, ‚àÄ·∂† y in l, y ‚â† x :=\n  le_cofinite_iff_compl_singleton_mem\n\n"}
{"name":"Filter.atTop_le_cofinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : Preorder Œ±\ninst‚úù : NoMaxOrder Œ±\n‚ä¢ LE.le Filter.atTop Filter.cofinite","decl":"/-- If `Œ±` is a preorder with no maximal element, then `atTop ‚â§ cofinite`. -/\ntheorem atTop_le_cofinite [Preorder Œ±] [NoMaxOrder Œ±] : (atTop : Filter Œ±) ‚â§ cofinite :=\n  le_cofinite_iff_eventually_ne.mpr eventually_ne_atTop\n\n"}
{"name":"Filter.comap_cofinite_le","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nf : Œ± ‚Üí Œ≤\n‚ä¢ LE.le (Filter.comap f Filter.cofinite) Filter.cofinite","decl":"theorem comap_cofinite_le (f : Œ± ‚Üí Œ≤) : comap f cofinite ‚â§ cofinite :=\n  le_cofinite_iff_eventually_ne.mpr fun x =>\n    mem_comap.2 ‚ü®{f x}·∂ú, (finite_singleton _).compl_mem_cofinite, fun _ => ne_of_apply_ne f‚ü©\n\n"}
{"name":"Filter.coprod_cofinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\n‚ä¢ Eq (Filter.cofinite.coprod Filter.cofinite) Filter.cofinite","decl":"/-- The coproduct of the cofinite filters on two types is the cofinite filter on their product. -/\ntheorem coprod_cofinite : (cofinite : Filter Œ±).coprod (cofinite : Filter Œ≤) = cofinite :=\n  Filter.coext fun s => by\n    simp only [compl_mem_coprod, mem_cofinite, compl_compl, finite_image_fst_and_snd_iff]\n\n"}
{"name":"Filter.coprod·µ¢_cofinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œπ : Type u_1\nŒ± : Œπ ‚Üí Type u_4\ninst‚úù : Finite Œπ\n‚ä¢ Eq (Filter.coprod·µ¢ fun i => Filter.cofinite) Filter.cofinite","decl":"theorem coprod·µ¢_cofinite {Œ± : Œπ ‚Üí Type*} [Finite Œπ] :\n    (Filter.coprod·µ¢ fun i => (cofinite : Filter (Œ± i))) = cofinite :=\n  Filter.coext fun s => by\n    simp only [compl_mem_coprod·µ¢, mem_cofinite, compl_compl, forall_finite_image_eval_iff]\n\n"}
{"name":"Filter.disjoint_cofinite_left","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nl : Filter Œ±\n‚ä¢ Iff (Disjoint Filter.cofinite l) (Exists fun s => And (Membership.mem l s) s.Finite)","decl":"theorem disjoint_cofinite_left : Disjoint cofinite l ‚Üî ‚àÉ s ‚àà l, Set.Finite s := by\n  simp [l.basis_sets.disjoint_iff_right]\n\n"}
{"name":"Filter.disjoint_cofinite_right","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nl : Filter Œ±\n‚ä¢ Iff (Disjoint l Filter.cofinite) (Exists fun s => And (Membership.mem l s) s.Finite)","decl":"theorem disjoint_cofinite_right : Disjoint l cofinite ‚Üî ‚àÉ s ‚àà l, Set.Finite s :=\n  disjoint_comm.trans disjoint_cofinite_left\n\n"}
{"name":"Filter.countable_compl_ker","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nl : Filter Œ±\ninst‚úù : l.IsCountablyGenerated\nh : LE.le Filter.cofinite l\n‚ä¢ (HasCompl.compl l.ker).Countable","decl":"/-- If `l ‚â• Filter.cofinite` is a countably generated filter, then `l.ker` is cocountable. -/\ntheorem countable_compl_ker [l.IsCountablyGenerated] (h : cofinite ‚â§ l) : Set.Countable l.ker·∂ú := by\n  rcases exists_antitone_basis l with ‚ü®s, hs‚ü©\n  simp only [hs.ker, iInter_true, compl_iInter]\n  exact countable_iUnion fun n ‚Ü¶ Set.Finite.countable <| h <| hs.mem _\n\n"}
{"name":"Filter.Tendsto.countable_compl_preimage_ker","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nf : Œ± ‚Üí Œ≤\nl : Filter Œ≤\ninst‚úù : l.IsCountablyGenerated\nh : Filter.Tendsto f Filter.cofinite l\n‚ä¢ (HasCompl.compl (Set.preimage f l.ker)).Countable","decl":"/-- If `f` tends to a countably generated filter `l` along `Filter.cofinite`,\nthen for all but countably many elements, `f x ‚àà l.ker`. -/\ntheorem Tendsto.countable_compl_preimage_ker {f : Œ± ‚Üí Œ≤}\n    {l : Filter Œ≤} [l.IsCountablyGenerated] (h : Tendsto f cofinite l) :\n    Set.Countable (f ‚Åª¬π' l.ker)·∂ú := by rw [‚Üê ker_comap]; exact countable_compl_ker h.le_comap\n\n"}
{"name":"Filter.univ_pi_mem_pi","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œπ : Type u_1\nŒ± : Œπ ‚Üí Type u_4\ns : (i : Œπ) ‚Üí Set (Œ± i)\nl : (i : Œπ) ‚Üí Filter (Œ± i)\nh : ‚àÄ (i : Œπ), Membership.mem (l i) (s i)\nhfin : Filter.Eventually (fun i => Eq (s i) Set.univ) Filter.cofinite\n‚ä¢ Membership.mem (Filter.pi l) (Set.univ.pi s)","decl":"/-- Given a collection of filters `l i : Filter (Œ± i)` and sets `s i ‚àà l i`,\nif all but finitely many of `s i` are the whole space,\nthen their indexed product `Set.pi Set.univ s` belongs to the filter `Filter.pi l`. -/\ntheorem univ_pi_mem_pi {Œ± : Œπ ‚Üí Type*} {s : ‚àÄ i, Set (Œ± i)} {l : ‚àÄ i, Filter (Œ± i)}\n    (h : ‚àÄ i, s i ‚àà l i) (hfin : ‚àÄ·∂† i in cofinite, s i = univ) : univ.pi s ‚àà pi l := by\n  filter_upwards [pi_mem_pi hfin fun i _ ‚Ü¶ h i] with a ha i _\n  if hi : s i = univ then\n    simp [hi]\n  else\n    exact ha i hi\n\n"}
{"name":"Filter.map_piMap_pi","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œπ : Type u_1\nŒ± : Œπ ‚Üí Type u_4\nŒ≤ : Œπ ‚Üí Type u_5\nf : (i : Œπ) ‚Üí Œ± i ‚Üí Œ≤ i\nhf : Filter.Eventually (fun i => Function.Surjective (f i)) Filter.cofinite\nl : (i : Œπ) ‚Üí Filter (Œ± i)\n‚ä¢ Eq (Filter.map (Pi.map f) (Filter.pi l)) (Filter.pi fun i => Filter.map (f i) (l i))","decl":"/-- Given a family of maps `f i : Œ± i ‚Üí Œ≤ i` and a family of filters `l i : Filter (Œ± i)`,\nif all but finitely many of `f i` are surjective,\nthen the indexed product of `f i`s maps the indexed product of the filters `l i`\nto the indexed products of their pushforwards under individual `f i`s.\n\nSee also `map_piMap_pi_finite` for the case of a finite index type.\n-/\ntheorem map_piMap_pi {Œ± Œ≤ : Œπ ‚Üí Type*} {f : ‚àÄ i, Œ± i ‚Üí Œ≤ i}\n    (hf : ‚àÄ·∂† i in cofinite, Surjective (f i)) (l : ‚àÄ i, Filter (Œ± i)) :\n    map (Pi.map f) (pi l) = pi fun i ‚Ü¶ map (f i) (l i) := by\n  refine le_antisymm (tendsto_piMap_pi fun _ ‚Ü¶ tendsto_map) ?_\n  refine ((hasBasis_pi fun i ‚Ü¶ (l i).basis_sets).map _).ge_iff.2 ?_\n  rintro ‚ü®I, s‚ü© ‚ü®hI : I.Finite, hs : ‚àÄ i ‚àà I, s i ‚àà l i‚ü©\n  classical\n  rw [‚Üê univ_pi_piecewise_univ, piMap_image_univ_pi]\n  refine univ_pi_mem_pi (fun i ‚Ü¶ ?_) ?_\n  ¬∑ by_cases hi : i ‚àà I\n    ¬∑ simpa [hi] using image_mem_map (hs i hi)\n    ¬∑ simp [hi]\n  ¬∑ filter_upwards [hf, hI.compl_mem_cofinite] with i hsurj (hiI : i ‚àâ I)\n    simp [hiI, hsurj.range_eq]\n\n"}
{"name":"Filter.map_piMap_pi_finite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œπ : Type u_1\nŒ± : Œπ ‚Üí Type u_4\nŒ≤ : Œπ ‚Üí Type u_5\ninst‚úù : Finite Œπ\nf : (i : Œπ) ‚Üí Œ± i ‚Üí Œ≤ i\nl : (i : Œπ) ‚Üí Filter (Œ± i)\n‚ä¢ Eq (Filter.map (Pi.map f) (Filter.pi l)) (Filter.pi fun i => Filter.map (f i) (l i))","decl":"/-- Given finite families of maps `f i : Œ± i ‚Üí Œ≤ i` and of filters `l i : Filter (Œ± i)`,\nthe indexed product of `f i`s maps the indexed product of the filters `l i`\nto the indexed products of their pushforwards under individual `f i`s.\n\nSee also `map_piMap_pi` for a more general case.\n-/\ntheorem map_piMap_pi_finite {Œ± Œ≤ : Œπ ‚Üí Type*} [Finite Œπ]\n    (f : ‚àÄ i, Œ± i ‚Üí Œ≤ i) (l : ‚àÄ i, Filter (Œ± i)) :\n    map (Pi.map f) (pi l) = pi fun i ‚Ü¶ map (f i) (l i) :=\n  map_piMap_pi (by simp) l\n\n"}
{"name":"Set.Finite.cofinite_inf_principal_compl","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ns : Set Œ±\nhs : s.Finite\n‚ä¢ Eq (Min.min Filter.cofinite (Filter.principal (HasCompl.compl s))) Filter.cofinite","decl":"lemma Set.Finite.cofinite_inf_principal_compl {s : Set Œ±} (hs : s.Finite) :\n    cofinite ‚äì ùìü s·∂ú = cofinite := by\n  simpa using hs.compl_mem_cofinite\n\n"}
{"name":"Set.Finite.cofinite_inf_principal_diff","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\ns t : Set Œ±\nht : t.Finite\n‚ä¢ Eq (Min.min Filter.cofinite (Filter.principal (SDiff.sdiff s t))) (Min.min Filter.cofinite (Filter.principal s))","decl":"lemma Set.Finite.cofinite_inf_principal_diff {s t : Set Œ±} (ht : t.Finite) :\n    cofinite ‚äì ùìü (s \\ t) = cofinite ‚äì ùìü s := by\n  rw [diff_eq, ‚Üê inf_principal, ‚Üê inf_assoc, inf_right_comm, ht.cofinite_inf_principal_compl]\n\n"}
{"name":"Nat.cofinite_eq_atTop","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"‚ä¢ Eq Filter.cofinite Filter.atTop","decl":"/-- For natural numbers the filters `Filter.cofinite` and `Filter.atTop` coincide. -/\ntheorem Nat.cofinite_eq_atTop : @cofinite ‚Ñï = atTop := by\n  refine le_antisymm ?_ atTop_le_cofinite\n  refine atTop_basis.ge_iff.2 fun N _ => ?_\n  simpa only [mem_cofinite, compl_Ici] using finite_lt_nat N\n\n"}
{"name":"Nat.frequently_atTop_iff_infinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"p : Nat ‚Üí Prop\n‚ä¢ Iff (Filter.Frequently (fun n => p n) Filter.atTop) (setOf fun n => p n).Infinite","decl":"theorem Nat.frequently_atTop_iff_infinite {p : ‚Ñï ‚Üí Prop} :\n    (‚àÉ·∂† n in atTop, p n) ‚Üî Set.Infinite { n | p n } := by\n  rw [‚Üê Nat.cofinite_eq_atTop, frequently_cofinite_iff_infinite]\n\n"}
{"name":"Nat.eventually_pos","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"‚ä¢ Filter.Eventually (fun k => LT.lt 0 k) Filter.atTop","decl":"lemma Nat.eventually_pos : ‚àÄ·∂† (k : ‚Ñï) in Filter.atTop, 0 < k :=\n  Filter.eventually_of_mem (Filter.mem_atTop_sets.mpr ‚ü®1, fun _ hx ‚Ü¶ hx‚ü©) (fun _ hx ‚Ü¶ hx)\n\n"}
{"name":"Filter.Tendsto.exists_within_forall_le","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_4\nŒ≤ : Type u_5\ninst‚úù : LinearOrder Œ≤\ns : Set Œ±\nhs : s.Nonempty\nf : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f Filter.cofinite Filter.atTop\n‚ä¢ Exists fun a‚ÇÄ => And (Membership.mem s a‚ÇÄ) (‚àÄ (a : Œ±), Membership.mem s a ‚Üí LE.le (f a‚ÇÄ) (f a))","decl":"theorem Filter.Tendsto.exists_within_forall_le {Œ± Œ≤ : Type*} [LinearOrder Œ≤] {s : Set Œ±}\n    (hs : s.Nonempty) {f : Œ± ‚Üí Œ≤} (hf : Filter.Tendsto f Filter.cofinite Filter.atTop) :\n    ‚àÉ a‚ÇÄ ‚àà s, ‚àÄ a ‚àà s, f a‚ÇÄ ‚â§ f a := by\n  rcases em (‚àÉ y ‚àà s, ‚àÉ x, f y < x) with (‚ü®y, hys, x, hx‚ü© | not_all_top)\n  ¬∑ -- the set of points `{y | f y < x}` is nonempty and finite, so we take `min` over this set\n    have : { y | ¬¨x ‚â§ f y }.Finite := Filter.eventually_cofinite.mp (tendsto_atTop.1 hf x)\n    simp only [not_le] at this\n    obtain ‚ü®a‚ÇÄ, ‚ü®ha‚ÇÄ : f a‚ÇÄ < x, ha‚ÇÄs‚ü©, others_bigger‚ü© :=\n      exists_min_image _ f (this.inter_of_left s) ‚ü®y, hx, hys‚ü©\n    refine ‚ü®a‚ÇÄ, ha‚ÇÄs, fun a has => (lt_or_le (f a) x).elim ?_ (le_trans ha‚ÇÄ.le)‚ü©\n    exact fun h => others_bigger a ‚ü®h, has‚ü©\n  ¬∑ -- in this case, f is constant because all values are at top\n    push_neg at not_all_top\n    obtain ‚ü®a‚ÇÄ, ha‚ÇÄs‚ü© := hs\n    exact ‚ü®a‚ÇÄ, ha‚ÇÄs, fun a ha => not_all_top a ha (f a‚ÇÄ)‚ü©\n\n"}
{"name":"Filter.Tendsto.exists_forall_le","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : LinearOrder Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f Filter.cofinite Filter.atTop\n‚ä¢ Exists fun a‚ÇÄ => ‚àÄ (a : Œ±), LE.le (f a‚ÇÄ) (f a)","decl":"theorem Filter.Tendsto.exists_forall_le [Nonempty Œ±] [LinearOrder Œ≤] {f : Œ± ‚Üí Œ≤}\n    (hf : Tendsto f cofinite atTop) : ‚àÉ a‚ÇÄ, ‚àÄ a, f a‚ÇÄ ‚â§ f a :=\n  let ‚ü®a‚ÇÄ, _, ha‚ÇÄ‚ü© := hf.exists_within_forall_le univ_nonempty\n  ‚ü®a‚ÇÄ, fun a => ha‚ÇÄ a (mem_univ _)‚ü©\n\n"}
{"name":"Filter.Tendsto.exists_within_forall_ge","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù : LinearOrder Œ≤\ns : Set Œ±\nhs : s.Nonempty\nf : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f Filter.cofinite Filter.atBot\n‚ä¢ Exists fun a‚ÇÄ => And (Membership.mem s a‚ÇÄ) (‚àÄ (a : Œ±), Membership.mem s a ‚Üí LE.le (f a) (f a‚ÇÄ))","decl":"theorem Filter.Tendsto.exists_within_forall_ge [LinearOrder Œ≤] {s : Set Œ±} (hs : s.Nonempty)\n    {f : Œ± ‚Üí Œ≤} (hf : Filter.Tendsto f Filter.cofinite Filter.atBot) :\n    ‚àÉ a‚ÇÄ ‚àà s, ‚àÄ a ‚àà s, f a ‚â§ f a‚ÇÄ :=\n  @Filter.Tendsto.exists_within_forall_le _ Œ≤·µí·µà _ _ hs _ hf\n\n"}
{"name":"Filter.Tendsto.exists_forall_ge","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : LinearOrder Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f Filter.cofinite Filter.atBot\n‚ä¢ Exists fun a‚ÇÄ => ‚àÄ (a : Œ±), LE.le (f a) (f a‚ÇÄ)","decl":"theorem Filter.Tendsto.exists_forall_ge [Nonempty Œ±] [LinearOrder Œ≤] {f : Œ± ‚Üí Œ≤}\n    (hf : Tendsto f cofinite atBot) : ‚àÉ a‚ÇÄ, ‚àÄ a, f a ‚â§ f a‚ÇÄ :=\n  @Filter.Tendsto.exists_forall_le _ Œ≤·µí·µà _ _ _ hf\n\n"}
{"name":"Function.Surjective.le_map_cofinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nf : Œ± ‚Üí Œ≤\nhf : Function.Surjective f\n‚ä¢ LE.le Filter.cofinite (Filter.map f Filter.cofinite)","decl":"theorem Function.Surjective.le_map_cofinite {f : Œ± ‚Üí Œ≤} (hf : Surjective f) :\n    cofinite ‚â§ map f cofinite := fun _ h => .of_preimage h hf\n\n"}
{"name":"Function.Injective.tendsto_cofinite","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nf : Œ± ‚Üí Œ≤\nhf : Function.Injective f\n‚ä¢ Filter.Tendsto f Filter.cofinite Filter.cofinite","decl":"/-- For an injective function `f`, inverse images of finite sets are finite. See also\n`Filter.comap_cofinite_le` and `Function.Injective.comap_cofinite_eq`. -/\ntheorem Function.Injective.tendsto_cofinite {f : Œ± ‚Üí Œ≤} (hf : Injective f) :\n    Tendsto f cofinite cofinite := fun _ h => h.preimage hf.injOn\n\n"}
{"name":"Function.Injective.comap_cofinite_eq","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"Œ± : Type u_2\nŒ≤ : Type u_3\nf : Œ± ‚Üí Œ≤\nhf : Function.Injective f\n‚ä¢ Eq (Filter.comap f Filter.cofinite) Filter.cofinite","decl":"/-- The pullback of the `Filter.cofinite` under an injective function is equal to `Filter.cofinite`.\nSee also `Filter.comap_cofinite_le` and `Function.Injective.tendsto_cofinite`. -/\ntheorem Function.Injective.comap_cofinite_eq {f : Œ± ‚Üí Œ≤} (hf : Injective f) :\n    comap f cofinite = cofinite :=\n  (comap_cofinite_le f).antisymm hf.tendsto_cofinite.le_comap\n\n"}
{"name":"Function.Injective.nat_tendsto_atTop","module":"Mathlib.Order.Filter.Cofinite","initialProofState":"f : Nat ‚Üí Nat\nhf : Function.Injective f\n‚ä¢ Filter.Tendsto f Filter.atTop Filter.atTop","decl":"/-- An injective sequence `f : ‚Ñï ‚Üí ‚Ñï` tends to infinity at infinity. -/\ntheorem Function.Injective.nat_tendsto_atTop {f : ‚Ñï ‚Üí ‚Ñï} (hf : Injective f) :\n    Tendsto f atTop atTop :=\n  Nat.cofinite_eq_atTop ‚ñ∏ hf.tendsto_cofinite\n"}
