{"name":"NonemptyInterval.toProd_zero","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Zero α\n⊢ Eq (NonemptyInterval.toProd 0) 0","decl":"@[to_additive (attr := simp) toProd_zero]\ntheorem toProd_one : (1 : NonemptyInterval α).toProd = 1 :=\n  rfl\n\n"}
{"name":"NonemptyInterval.toProd_one","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : One α\n⊢ Eq (NonemptyInterval.toProd 1) 1","decl":"@[to_additive (attr := simp) toProd_zero]\ntheorem toProd_one : (1 : NonemptyInterval α).toProd = 1 :=\n  rfl\n\n"}
{"name":"NonemptyInterval.fst_zero","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Zero α\n⊢ Eq (NonemptyInterval.toProd 0).1 0","decl":"@[to_additive]\ntheorem fst_one : (1 : NonemptyInterval α).fst = 1 :=\n  rfl\n\n"}
{"name":"NonemptyInterval.fst_one","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : One α\n⊢ Eq (NonemptyInterval.toProd 1).1 1","decl":"@[to_additive]\ntheorem fst_one : (1 : NonemptyInterval α).fst = 1 :=\n  rfl\n\n"}
{"name":"NonemptyInterval.snd_one","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : One α\n⊢ Eq (NonemptyInterval.toProd 1).2 1","decl":"@[to_additive]\ntheorem snd_one : (1 : NonemptyInterval α).snd = 1 :=\n  rfl\n\n-- Porting note: Originally `@[simp, norm_cast, to_additive]`\n"}
{"name":"NonemptyInterval.snd_zero","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Zero α\n⊢ Eq (NonemptyInterval.toProd 0).2 0","decl":"@[to_additive]\ntheorem snd_one : (1 : NonemptyInterval α).snd = 1 :=\n  rfl\n\n-- Porting note: Originally `@[simp, norm_cast, to_additive]`\n"}
{"name":"NonemptyInterval.coe_one_interval","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : One α\n⊢ Eq (↑1) 1","decl":"@[to_additive (attr := push_cast, simp)]\ntheorem coe_one_interval : ((1 : NonemptyInterval α) : Interval α) = 1 :=\n  rfl\n\n"}
{"name":"NonemptyInterval.coe_zero_interval","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Zero α\n⊢ Eq (↑0) 0","decl":"@[to_additive (attr := push_cast, simp)]\ntheorem coe_one_interval : ((1 : NonemptyInterval α) : Interval α) = 1 :=\n  rfl\n\n"}
{"name":"NonemptyInterval.pure_one","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : One α\n⊢ Eq (NonemptyInterval.pure 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem pure_one : pure (1 : α) = 1 :=\n  rfl\n\n"}
{"name":"NonemptyInterval.pure_zero","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Zero α\n⊢ Eq (NonemptyInterval.pure 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem pure_one : pure (1 : α) = 1 :=\n  rfl\n\n"}
{"name":"Interval.pure_zero","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Zero α\n⊢ Eq (Interval.pure 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem pure_one : pure (1 : α) = 1 :=\n  rfl\n\n"}
{"name":"Interval.pure_one","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : One α\n⊢ Eq (Interval.pure 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem pure_one : pure (1 : α) = 1 :=\n  rfl\n\n"}
{"name":"Interval.one_ne_bot","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : One α\n⊢ Ne 1 Bot.bot","decl":"@[to_additive] lemma one_ne_bot : (1 : Interval α) ≠ ⊥ := pure_ne_bot\n\n"}
{"name":"Interval.zero_ne_bot","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Zero α\n⊢ Ne 0 Bot.bot","decl":"@[to_additive] lemma one_ne_bot : (1 : Interval α) ≠ ⊥ := pure_ne_bot\n\n"}
{"name":"Interval.bot_ne_one","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : One α\n⊢ Ne Bot.bot 1","decl":"@[to_additive] lemma bot_ne_one : (⊥ : Interval α) ≠ 1 := bot_ne_pure\n\n"}
{"name":"Interval.bot_ne_zero","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Zero α\n⊢ Ne Bot.bot 0","decl":"@[to_additive] lemma bot_ne_one : (⊥ : Interval α) ≠ 1 := bot_ne_pure\n\n"}
{"name":"NonemptyInterval.coe_zero","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : Zero α\n⊢ Eq (↑0) 0","decl":"@[to_additive (attr := simp)]\ntheorem coe_one : ((1 : NonemptyInterval α) : Set α) = 1 :=\n  coe_pure _\n\n"}
{"name":"NonemptyInterval.coe_one","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : One α\n⊢ Eq (↑1) 1","decl":"@[to_additive (attr := simp)]\ntheorem coe_one : ((1 : NonemptyInterval α) : Set α) = 1 :=\n  coe_pure _\n\n"}
{"name":"NonemptyInterval.zero_mem_zero","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : Zero α\n⊢ Membership.mem 0 0","decl":"@[to_additive]\ntheorem one_mem_one : (1 : α) ∈ (1 : NonemptyInterval α) :=\n  ⟨le_rfl, le_rfl⟩\n\n"}
{"name":"NonemptyInterval.one_mem_one","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : One α\n⊢ Membership.mem 1 1","decl":"@[to_additive]\ntheorem one_mem_one : (1 : α) ∈ (1 : NonemptyInterval α) :=\n  ⟨le_rfl, le_rfl⟩\n\n"}
{"name":"Interval.coe_zero","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : Zero α\n⊢ Eq (↑0) 0","decl":"@[to_additive (attr := simp)]\ntheorem coe_one : ((1 : Interval α) : Set α) = 1 :=\n  Icc_self _\n\n"}
{"name":"Interval.coe_one","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : One α\n⊢ Eq (↑1) 1","decl":"@[to_additive (attr := simp)]\ntheorem coe_one : ((1 : Interval α) : Set α) = 1 :=\n  Icc_self _\n\n"}
{"name":"Interval.one_mem_one","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : One α\n⊢ Membership.mem 1 1","decl":"@[to_additive]\ntheorem one_mem_one : (1 : α) ∈ (1 : Interval α) :=\n  ⟨le_rfl, le_rfl⟩\n\n"}
{"name":"Interval.zero_mem_zero","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : Zero α\n⊢ Membership.mem 0 0","decl":"@[to_additive]\ntheorem one_mem_one : (1 : α) ∈ (1 : Interval α) :=\n  ⟨le_rfl, le_rfl⟩\n\n"}
{"name":"NonemptyInterval.toProd_add","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Add α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\ns t : NonemptyInterval α\n⊢ Eq (HAdd.hAdd s t).toProd (HAdd.hAdd s.toProd t.toProd)","decl":"@[to_additive (attr := simp) toProd_add]\ntheorem toProd_mul : (s * t).toProd = s.toProd * t.toProd :=\n  rfl\n\n"}
{"name":"NonemptyInterval.toProd_mul","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Mul α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\ns t : NonemptyInterval α\n⊢ Eq (HMul.hMul s t).toProd (HMul.hMul s.toProd t.toProd)","decl":"@[to_additive (attr := simp) toProd_add]\ntheorem toProd_mul : (s * t).toProd = s.toProd * t.toProd :=\n  rfl\n\n"}
{"name":"NonemptyInterval.fst_mul","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Mul α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\ns t : NonemptyInterval α\n⊢ Eq (HMul.hMul s t).toProd.1 (HMul.hMul s.toProd.1 t.toProd.1)","decl":"@[to_additive]\ntheorem fst_mul : (s * t).fst = s.fst * t.fst :=\n  rfl\n\n"}
{"name":"NonemptyInterval.fst_add","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Add α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\ns t : NonemptyInterval α\n⊢ Eq (HAdd.hAdd s t).toProd.1 (HAdd.hAdd s.toProd.1 t.toProd.1)","decl":"@[to_additive]\ntheorem fst_mul : (s * t).fst = s.fst * t.fst :=\n  rfl\n\n"}
{"name":"NonemptyInterval.snd_mul","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Mul α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\ns t : NonemptyInterval α\n⊢ Eq (HMul.hMul s t).toProd.2 (HMul.hMul s.toProd.2 t.toProd.2)","decl":"@[to_additive]\ntheorem snd_mul : (s * t).snd = s.snd * t.snd :=\n  rfl\n\n"}
{"name":"NonemptyInterval.snd_add","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Add α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\ns t : NonemptyInterval α\n⊢ Eq (HAdd.hAdd s t).toProd.2 (HAdd.hAdd s.toProd.2 t.toProd.2)","decl":"@[to_additive]\ntheorem snd_mul : (s * t).snd = s.snd * t.snd :=\n  rfl\n\n"}
{"name":"NonemptyInterval.coe_add_interval","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Add α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\ns t : NonemptyInterval α\n⊢ Eq (↑(HAdd.hAdd s t)) (HAdd.hAdd ↑s ↑t)","decl":"@[to_additive (attr := simp)]\ntheorem coe_mul_interval : (↑(s * t) : Interval α) = s * t :=\n  rfl\n\n"}
{"name":"NonemptyInterval.coe_mul_interval","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Mul α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\ns t : NonemptyInterval α\n⊢ Eq (↑(HMul.hMul s t)) (HMul.hMul ↑s ↑t)","decl":"@[to_additive (attr := simp)]\ntheorem coe_mul_interval : (↑(s * t) : Interval α) = s * t :=\n  rfl\n\n"}
{"name":"NonemptyInterval.pure_add_pure","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Add α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na b : α\n⊢ Eq (HAdd.hAdd (NonemptyInterval.pure a) (NonemptyInterval.pure b)) (NonemptyInterval.pure (HAdd.hAdd a b))","decl":"@[to_additive (attr := simp)]\ntheorem pure_mul_pure : pure a * pure b = pure (a * b) :=\n  rfl\n\n"}
{"name":"NonemptyInterval.pure_mul_pure","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Mul α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na b : α\n⊢ Eq (HMul.hMul (NonemptyInterval.pure a) (NonemptyInterval.pure b)) (NonemptyInterval.pure (HMul.hMul a b))","decl":"@[to_additive (attr := simp)]\ntheorem pure_mul_pure : pure a * pure b = pure (a * b) :=\n  rfl\n\n"}
{"name":"Interval.bot_add","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Add α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\nt : Interval α\n⊢ Eq (HAdd.hAdd Bot.bot t) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_mul : ⊥ * t = ⊥ :=\n  rfl\n\n"}
{"name":"Interval.bot_mul","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Mul α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\nt : Interval α\n⊢ Eq (HMul.hMul Bot.bot t) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_mul : ⊥ * t = ⊥ :=\n  rfl\n\n"}
{"name":"Interval.add_bot","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Add α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\ns : Interval α\n⊢ Eq (HAdd.hAdd s Bot.bot) Bot.bot","decl":"@[to_additive]\ntheorem mul_bot : s * ⊥ = ⊥ :=\n  Option.map₂_none_right _ _\n\n-- simp can already prove `add_bot`\n"}
{"name":"Interval.mul_bot","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : Mul α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\ns : Interval α\n⊢ Eq (HMul.hMul s Bot.bot) Bot.bot","decl":"@[to_additive]\ntheorem mul_bot : s * ⊥ = ⊥ :=\n  Option.map₂_none_right _ _\n\n-- simp can already prove `add_bot`\n"}
{"name":"NonemptyInterval.toProd_nsmul","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : AddMonoid α\ninst✝² : Preorder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\ns : NonemptyInterval α\nn : Nat\n⊢ Eq (HSMul.hSMul n s).toProd (HSMul.hSMul n s.toProd)","decl":"@[to_additive (attr := simp) toProd_nsmul]\ntheorem toProd_pow : (s ^ n).toProd = s.toProd ^ n :=\n  rfl\n\n"}
{"name":"NonemptyInterval.toProd_pow","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Monoid α\ninst✝² : Preorder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\ns : NonemptyInterval α\nn : Nat\n⊢ Eq (HPow.hPow s n).toProd (HPow.hPow s.toProd n)","decl":"@[to_additive (attr := simp) toProd_nsmul]\ntheorem toProd_pow : (s ^ n).toProd = s.toProd ^ n :=\n  rfl\n\n"}
{"name":"NonemptyInterval.fst_pow","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Monoid α\ninst✝² : Preorder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\ns : NonemptyInterval α\nn : Nat\n⊢ Eq (HPow.hPow s n).toProd.1 (HPow.hPow s.toProd.1 n)","decl":"@[to_additive]\ntheorem fst_pow : (s ^ n).fst = s.fst ^ n :=\n  rfl\n\n"}
{"name":"NonemptyInterval.fst_nsmul","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : AddMonoid α\ninst✝² : Preorder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\ns : NonemptyInterval α\nn : Nat\n⊢ Eq (HSMul.hSMul n s).toProd.1 (HSMul.hSMul n s.toProd.1)","decl":"@[to_additive]\ntheorem fst_pow : (s ^ n).fst = s.fst ^ n :=\n  rfl\n\n"}
{"name":"NonemptyInterval.snd_nsmul","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : AddMonoid α\ninst✝² : Preorder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\ns : NonemptyInterval α\nn : Nat\n⊢ Eq (HSMul.hSMul n s).toProd.2 (HSMul.hSMul n s.toProd.2)","decl":"@[to_additive]\ntheorem snd_pow : (s ^ n).snd = s.snd ^ n :=\n  rfl\n\n"}
{"name":"NonemptyInterval.snd_pow","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Monoid α\ninst✝² : Preorder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\ns : NonemptyInterval α\nn : Nat\n⊢ Eq (HPow.hPow s n).toProd.2 (HPow.hPow s.toProd.2 n)","decl":"@[to_additive]\ntheorem snd_pow : (s ^ n).snd = s.snd ^ n :=\n  rfl\n\n"}
{"name":"NonemptyInterval.pure_nsmul","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : AddMonoid α\ninst✝² : Preorder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na : α\nn : Nat\n⊢ Eq (HSMul.hSMul n (NonemptyInterval.pure a)) (NonemptyInterval.pure (HSMul.hSMul n a))","decl":"@[to_additive (attr := simp)]\ntheorem pure_pow : pure a ^ n = pure (a ^ n) :=\n  rfl\n\n"}
{"name":"NonemptyInterval.pure_pow","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝³ : Monoid α\ninst✝² : Preorder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na : α\nn : Nat\n⊢ Eq (HPow.hPow (NonemptyInterval.pure a) n) (NonemptyInterval.pure (HPow.hPow a n))","decl":"@[to_additive (attr := simp)]\ntheorem pure_pow : pure a ^ n = pure (a ^ n) :=\n  rfl\n\n"}
{"name":"NonemptyInterval.coe_nsmul_interval","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommMonoid α\ns : NonemptyInterval α\nn : Nat\n⊢ Eq (↑(HSMul.hSMul n s)) (HSMul.hSMul n ↑s)","decl":"@[to_additive]\ntheorem coe_pow_interval [OrderedCommMonoid α] (s : NonemptyInterval α) (n : ℕ) :\n    ↑(s ^ n) = (s : Interval α) ^ n :=\n  map_pow (⟨⟨(↑), coe_one_interval⟩, coe_mul_interval⟩ : NonemptyInterval α →* Interval α) _ _\n\n-- simp can already prove `coe_nsmul_interval`\n"}
{"name":"NonemptyInterval.coe_pow_interval","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedCommMonoid α\ns : NonemptyInterval α\nn : Nat\n⊢ Eq (↑(HPow.hPow s n)) (HPow.hPow (↑s) n)","decl":"@[to_additive]\ntheorem coe_pow_interval [OrderedCommMonoid α] (s : NonemptyInterval α) (n : ℕ) :\n    ↑(s ^ n) = (s : Interval α) ^ n :=\n  map_pow (⟨⟨(↑), coe_one_interval⟩, coe_mul_interval⟩ : NonemptyInterval α →* Interval α) _ _\n\n-- simp can already prove `coe_nsmul_interval`\n"}
{"name":"Interval.bot_nsmul","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommMonoid α\nn : Nat\na✝ : Ne n 0\n⊢ Eq (HSMul.hSMul n Bot.bot) Bot.bot","decl":"@[to_additive]\ntheorem bot_pow : ∀ {n : ℕ}, n ≠ 0 → (⊥ : Interval α) ^ n = ⊥\n  | 0, h => (h rfl).elim\n  | Nat.succ n, _ => mul_bot (⊥ ^ n)\n\n"}
{"name":"Interval.bot_pow","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedCommMonoid α\nn : Nat\na✝ : Ne n 0\n⊢ Eq (HPow.hPow Bot.bot n) Bot.bot","decl":"@[to_additive]\ntheorem bot_pow : ∀ {n : ℕ}, n ≠ 0 → (⊥ : Interval α) ^ n = ⊥\n  | 0, h => (h rfl).elim\n  | Nat.succ n, _ => mul_bot (⊥ ^ n)\n\n"}
{"name":"NonemptyInterval.fst_natCast","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : NatCast α\nn : Nat\n⊢ Eq (↑n).toProd.1 ↑n","decl":"theorem fst_natCast (n : ℕ) : (n : NonemptyInterval α).fst = n := rfl\n\n"}
{"name":"NonemptyInterval.snd_natCast","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : NatCast α\nn : Nat\n⊢ Eq (↑n).toProd.2 ↑n","decl":"theorem snd_natCast (n : ℕ) : (n : NonemptyInterval α).snd = n := rfl\n\n"}
{"name":"NonemptyInterval.pure_natCast","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : NatCast α\nn : Nat\n⊢ Eq (NonemptyInterval.pure ↑n) ↑n","decl":"@[simp]\ntheorem pure_natCast (n : ℕ) : pure (n : α) = n := rfl\n\n"}
{"name":"NonemptyInterval.fst_sub","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝⁴ : Preorder α\ninst✝³ : AddCommSemigroup α\ninst✝² : Sub α\ninst✝¹ : OrderedSub α\ninst✝ : AddLeftMono α\ns t : NonemptyInterval α\n⊢ Eq (HSub.hSub s t).toProd.1 (HSub.hSub s.toProd.1 t.toProd.2)","decl":"@[simp]\ntheorem fst_sub : (s - t).fst = s.fst - t.snd :=\n  rfl\n\n"}
{"name":"NonemptyInterval.snd_sub","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝⁴ : Preorder α\ninst✝³ : AddCommSemigroup α\ninst✝² : Sub α\ninst✝¹ : OrderedSub α\ninst✝ : AddLeftMono α\ns t : NonemptyInterval α\n⊢ Eq (HSub.hSub s t).toProd.2 (HSub.hSub s.toProd.2 t.toProd.1)","decl":"@[simp]\ntheorem snd_sub : (s - t).snd = s.snd - t.fst :=\n  rfl\n\n"}
{"name":"NonemptyInterval.coe_sub_interval","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝⁴ : Preorder α\ninst✝³ : AddCommSemigroup α\ninst✝² : Sub α\ninst✝¹ : OrderedSub α\ninst✝ : AddLeftMono α\ns t : NonemptyInterval α\n⊢ Eq (↑(HSub.hSub s t)) (HSub.hSub ↑s ↑t)","decl":"@[simp]\ntheorem coe_sub_interval : (↑(s - t) : Interval α) = s - t :=\n  rfl\n\n"}
{"name":"NonemptyInterval.sub_mem_sub","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝⁴ : Preorder α\ninst✝³ : AddCommSemigroup α\ninst✝² : Sub α\ninst✝¹ : OrderedSub α\ninst✝ : AddLeftMono α\ns t : NonemptyInterval α\na b : α\nha : Membership.mem s a\nhb : Membership.mem t b\n⊢ Membership.mem (HSub.hSub s t) (HSub.hSub a b)","decl":"theorem sub_mem_sub (ha : a ∈ s) (hb : b ∈ t) : a - b ∈ s - t :=\n  ⟨tsub_le_tsub ha.1 hb.2, tsub_le_tsub ha.2 hb.1⟩\n\n"}
{"name":"NonemptyInterval.pure_sub_pure","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝⁴ : Preorder α\ninst✝³ : AddCommSemigroup α\ninst✝² : Sub α\ninst✝¹ : OrderedSub α\ninst✝ : AddLeftMono α\na b : α\n⊢ Eq (HSub.hSub (NonemptyInterval.pure a) (NonemptyInterval.pure b)) (NonemptyInterval.pure (HSub.hSub a b))","decl":"@[simp]\ntheorem pure_sub_pure (a b : α) : pure a - pure b = pure (a - b) :=\n  rfl\n\n"}
{"name":"Interval.bot_sub","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝⁴ : Preorder α\ninst✝³ : AddCommSemigroup α\ninst✝² : Sub α\ninst✝¹ : OrderedSub α\ninst✝ : AddLeftMono α\nt : Interval α\n⊢ Eq (HSub.hSub Bot.bot t) Bot.bot","decl":"@[simp]\ntheorem bot_sub : ⊥ - t = ⊥ :=\n  rfl\n\n"}
{"name":"Interval.sub_bot","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝⁴ : Preorder α\ninst✝³ : AddCommSemigroup α\ninst✝² : Sub α\ninst✝¹ : OrderedSub α\ninst✝ : AddLeftMono α\ns : Interval α\n⊢ Eq (HSub.hSub s Bot.bot) Bot.bot","decl":"@[simp]\ntheorem sub_bot : s - ⊥ = ⊥ :=\n  Option.map₂_none_right _ _\n\n"}
{"name":"NonemptyInterval.fst_div","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\ns t : NonemptyInterval α\n⊢ Eq (HDiv.hDiv s t).toProd.1 (HDiv.hDiv s.toProd.1 t.toProd.2)","decl":"@[to_additive existing (attr := simp)]\ntheorem fst_div : (s / t).fst = s.fst / t.snd :=\n  rfl\n\n"}
{"name":"NonemptyInterval.snd_div","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\ns t : NonemptyInterval α\n⊢ Eq (HDiv.hDiv s t).toProd.2 (HDiv.hDiv s.toProd.2 t.toProd.1)","decl":"@[to_additive existing (attr := simp)]\ntheorem snd_div : (s / t).snd = s.snd / t.fst :=\n  rfl\n\n"}
{"name":"NonemptyInterval.coe_div_interval","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\ns t : NonemptyInterval α\n⊢ Eq (↑(HDiv.hDiv s t)) (HDiv.hDiv ↑s ↑t)","decl":"@[to_additive existing (attr := simp)]\ntheorem coe_div_interval : (↑(s / t) : Interval α) = s / t :=\n  rfl\n\n"}
{"name":"NonemptyInterval.div_mem_div","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\ns t : NonemptyInterval α\na b : α\nha : Membership.mem s a\nhb : Membership.mem t b\n⊢ Membership.mem (HDiv.hDiv s t) (HDiv.hDiv a b)","decl":"@[to_additive existing]\ntheorem div_mem_div (ha : a ∈ s) (hb : b ∈ t) : a / b ∈ s / t :=\n  ⟨div_le_div'' ha.1 hb.2, div_le_div'' ha.2 hb.1⟩\n\n"}
{"name":"NonemptyInterval.pure_div_pure","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\na b : α\n⊢ Eq (HDiv.hDiv (NonemptyInterval.pure a) (NonemptyInterval.pure b)) (NonemptyInterval.pure (HDiv.hDiv a b))","decl":"@[to_additive existing (attr := simp)]\ntheorem pure_div_pure : pure a / pure b = pure (a / b) :=\n  rfl\n\n"}
{"name":"Interval.bot_div","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\nt : Interval α\n⊢ Eq (HDiv.hDiv Bot.bot t) Bot.bot","decl":"@[to_additive existing (attr := simp)]\ntheorem bot_div : ⊥ / t = ⊥ :=\n  rfl\n\n"}
{"name":"Interval.div_bot","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\ns : Interval α\n⊢ Eq (HDiv.hDiv s Bot.bot) Bot.bot","decl":"@[to_additive existing (attr := simp)]\ntheorem div_bot : s / ⊥ = ⊥ :=\n  Option.map₂_none_right _ _\n\n"}
{"name":"NonemptyInterval.fst_neg","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns : NonemptyInterval α\n⊢ Eq (Neg.neg s).toProd.1 (Neg.neg s.toProd.2)","decl":"@[to_additive (attr := simp)]\ntheorem fst_inv : s⁻¹.fst = s.snd⁻¹ :=\n  rfl\n\n"}
{"name":"NonemptyInterval.fst_inv","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedCommGroup α\ns : NonemptyInterval α\n⊢ Eq (Inv.inv s).toProd.1 (Inv.inv s.toProd.2)","decl":"@[to_additive (attr := simp)]\ntheorem fst_inv : s⁻¹.fst = s.snd⁻¹ :=\n  rfl\n\n"}
{"name":"NonemptyInterval.snd_neg","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns : NonemptyInterval α\n⊢ Eq (Neg.neg s).toProd.2 (Neg.neg s.toProd.1)","decl":"@[to_additive (attr := simp)]\ntheorem snd_inv : s⁻¹.snd = s.fst⁻¹ :=\n  rfl\n\n"}
{"name":"NonemptyInterval.snd_inv","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedCommGroup α\ns : NonemptyInterval α\n⊢ Eq (Inv.inv s).toProd.2 (Inv.inv s.toProd.1)","decl":"@[to_additive (attr := simp)]\ntheorem snd_inv : s⁻¹.snd = s.fst⁻¹ :=\n  rfl\n\n"}
{"name":"NonemptyInterval.coe_neg_interval","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns : NonemptyInterval α\n⊢ Eq (↑(Neg.neg s)) (Neg.neg ↑s)","decl":"@[to_additive (attr := simp)]\ntheorem coe_inv_interval : (↑(s⁻¹) : Interval α) = (↑s)⁻¹ :=\n  rfl\n\n"}
{"name":"NonemptyInterval.coe_inv_interval","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedCommGroup α\ns : NonemptyInterval α\n⊢ Eq (↑(Inv.inv s)) (Inv.inv ↑s)","decl":"@[to_additive (attr := simp)]\ntheorem coe_inv_interval : (↑(s⁻¹) : Interval α) = (↑s)⁻¹ :=\n  rfl\n\n"}
{"name":"NonemptyInterval.inv_mem_inv","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedCommGroup α\ns : NonemptyInterval α\na : α\nha : Membership.mem s a\n⊢ Membership.mem (Inv.inv s) (Inv.inv a)","decl":"@[to_additive]\ntheorem inv_mem_inv (ha : a ∈ s) : a⁻¹ ∈ s⁻¹ :=\n  ⟨inv_le_inv' ha.2, inv_le_inv' ha.1⟩\n\n"}
{"name":"NonemptyInterval.neg_mem_neg","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns : NonemptyInterval α\na : α\nha : Membership.mem s a\n⊢ Membership.mem (Neg.neg s) (Neg.neg a)","decl":"@[to_additive]\ntheorem inv_mem_inv (ha : a ∈ s) : a⁻¹ ∈ s⁻¹ :=\n  ⟨inv_le_inv' ha.2, inv_le_inv' ha.1⟩\n\n"}
{"name":"NonemptyInterval.inv_pure","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedCommGroup α\na : α\n⊢ Eq (Inv.inv (NonemptyInterval.pure a)) (NonemptyInterval.pure (Inv.inv a))","decl":"@[to_additive (attr := simp)]\ntheorem inv_pure : (pure a)⁻¹ = pure a⁻¹ :=\n  rfl\n\n"}
{"name":"NonemptyInterval.neg_pure","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\na : α\n⊢ Eq (Neg.neg (NonemptyInterval.pure a)) (NonemptyInterval.pure (Neg.neg a))","decl":"@[to_additive (attr := simp)]\ntheorem inv_pure : (pure a)⁻¹ = pure a⁻¹ :=\n  rfl\n\n"}
{"name":"Interval.neg_bot","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\n⊢ Eq (Neg.neg Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem Interval.inv_bot : (⊥ : Interval α)⁻¹ = ⊥ :=\n  rfl\n\n"}
{"name":"Interval.inv_bot","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedCommGroup α\n⊢ Eq (Inv.inv Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem Interval.inv_bot : (⊥ : Interval α)⁻¹ = ⊥ :=\n  rfl\n\n"}
{"name":"NonemptyInterval.add_eq_zero_iff","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns t : NonemptyInterval α\n⊢ Iff (Eq (HAdd.hAdd s t) 0) (Exists fun a => Exists fun b => And (Eq s (NonemptyInterval.pure a)) (And (Eq t (NonemptyInterval.pure b)) (Eq (HAdd.hAdd a b) 0)))","decl":"@[to_additive]\nprotected theorem mul_eq_one_iff : s * t = 1 ↔ ∃ a b, s = pure a ∧ t = pure b ∧ a * b = 1 := by\n  refine ⟨fun h => ?_, ?_⟩\n  · rw [NonemptyInterval.ext_iff, Prod.ext_iff] at h\n    have := (mul_le_mul_iff_of_ge s.fst_le_snd t.fst_le_snd).1 (h.2.trans h.1.symm).le\n    refine ⟨s.fst, t.fst, ?_, ?_, h.1⟩ <;> apply NonemptyInterval.ext <;> dsimp [pure]\n    · nth_rw 2 [this.1]\n    · nth_rw 2 [this.2]\n  · rintro ⟨b, c, rfl, rfl, h⟩\n    rw [pure_mul_pure, h, pure_one]\n\n"}
{"name":"NonemptyInterval.mul_eq_one_iff","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedCommGroup α\ns t : NonemptyInterval α\n⊢ Iff (Eq (HMul.hMul s t) 1) (Exists fun a => Exists fun b => And (Eq s (NonemptyInterval.pure a)) (And (Eq t (NonemptyInterval.pure b)) (Eq (HMul.hMul a b) 1)))","decl":"@[to_additive]\nprotected theorem mul_eq_one_iff : s * t = 1 ↔ ∃ a b, s = pure a ∧ t = pure b ∧ a * b = 1 := by\n  refine ⟨fun h => ?_, ?_⟩\n  · rw [NonemptyInterval.ext_iff, Prod.ext_iff] at h\n    have := (mul_le_mul_iff_of_ge s.fst_le_snd t.fst_le_snd).1 (h.2.trans h.1.symm).le\n    refine ⟨s.fst, t.fst, ?_, ?_, h.1⟩ <;> apply NonemptyInterval.ext <;> dsimp [pure]\n    · nth_rw 2 [this.1]\n    · nth_rw 2 [this.2]\n  · rintro ⟨b, c, rfl, rfl, h⟩\n    rw [pure_mul_pure, h, pure_one]\n\n"}
{"name":"Interval.mul_eq_one_iff","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedCommGroup α\ns t : Interval α\n⊢ Iff (Eq (HMul.hMul s t) 1) (Exists fun a => Exists fun b => And (Eq s (Interval.pure a)) (And (Eq t (Interval.pure b)) (Eq (HMul.hMul a b) 1)))","decl":"@[to_additive]\nprotected theorem mul_eq_one_iff : s * t = 1 ↔ ∃ a b, s = pure a ∧ t = pure b ∧ a * b = 1 := by\n  cases s\n  · simp\n  cases t\n  · simp\n  · simp_rw [← NonemptyInterval.coe_mul_interval, ← NonemptyInterval.coe_one_interval,\n      WithBot.coe_inj, NonemptyInterval.coe_eq_pure]\n    exact NonemptyInterval.mul_eq_one_iff\n\n"}
{"name":"Interval.add_eq_zero_iff","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns t : Interval α\n⊢ Iff (Eq (HAdd.hAdd s t) 0) (Exists fun a => Exists fun b => And (Eq s (Interval.pure a)) (And (Eq t (Interval.pure b)) (Eq (HAdd.hAdd a b) 0)))","decl":"@[to_additive]\nprotected theorem mul_eq_one_iff : s * t = 1 ↔ ∃ a b, s = pure a ∧ t = pure b ∧ a * b = 1 := by\n  cases s\n  · simp\n  cases t\n  · simp\n  · simp_rw [← NonemptyInterval.coe_mul_interval, ← NonemptyInterval.coe_one_interval,\n      WithBot.coe_inj, NonemptyInterval.coe_eq_pure]\n    exact NonemptyInterval.mul_eq_one_iff\n\n"}
{"name":"NonemptyInterval.length_nonneg","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns : NonemptyInterval α\n⊢ LE.le 0 s.length","decl":"@[simp]\ntheorem length_nonneg : 0 ≤ s.length :=\n  sub_nonneg_of_le s.fst_le_snd\n\n"}
{"name":"NonemptyInterval.length_pure","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\na : α\n⊢ Eq (NonemptyInterval.pure a).length 0","decl":"@[simp]\ntheorem length_pure : (pure a).length = 0 :=\n  sub_self _\n\n"}
{"name":"NonemptyInterval.length_zero","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\n⊢ Eq (NonemptyInterval.length 0) 0","decl":"@[simp]\ntheorem length_zero : (0 : NonemptyInterval α).length = 0 :=\n  length_pure _\n\n"}
{"name":"NonemptyInterval.length_neg","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns : NonemptyInterval α\n⊢ Eq (Neg.neg s).length s.length","decl":"@[simp]\ntheorem length_neg : (-s).length = s.length :=\n  neg_sub_neg _ _\n\n"}
{"name":"NonemptyInterval.length_add","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns t : NonemptyInterval α\n⊢ Eq (HAdd.hAdd s t).length (HAdd.hAdd s.length t.length)","decl":"@[simp]\ntheorem length_add : (s + t).length = s.length + t.length :=\n  add_sub_add_comm _ _ _ _\n\n"}
{"name":"NonemptyInterval.length_sub","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns t : NonemptyInterval α\n⊢ Eq (HSub.hSub s t).length (HAdd.hAdd s.length t.length)","decl":"@[simp]\ntheorem length_sub : (s - t).length = s.length + t.length := by simp [sub_eq_add_neg]\n\n"}
{"name":"NonemptyInterval.length_sum","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : OrderedAddCommGroup α\nf : ι → NonemptyInterval α\ns : Finset ι\n⊢ Eq (s.sum fun i => f i).length (s.sum fun i => (f i).length)","decl":"@[simp]\ntheorem length_sum (f : ι → NonemptyInterval α) (s : Finset ι) :\n    (∑ i ∈ s, f i).length = ∑ i ∈ s, (f i).length :=\n  map_sum (⟨⟨length, length_zero⟩, length_add⟩ : NonemptyInterval α →+ α) _ _\n\n"}
{"name":"Interval.length_nonneg","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns : Interval α\n⊢ LE.le 0 s.length","decl":"@[simp]\ntheorem length_nonneg : ∀ s : Interval α, 0 ≤ s.length\n  | ⊥ => le_rfl\n  | (s : NonemptyInterval α) => s.length_nonneg\n\n"}
{"name":"Interval.length_pure","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\na : α\n⊢ Eq (Interval.pure a).length 0","decl":"@[simp]\ntheorem length_pure : (pure a).length = 0 :=\n  NonemptyInterval.length_pure _\n\n"}
{"name":"Interval.length_zero","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\n⊢ Eq (Interval.length 0) 0","decl":"@[simp]\ntheorem length_zero : (0 : Interval α).length = 0 :=\n  length_pure _\n\n"}
{"name":"Interval.length_neg","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns : Interval α\n⊢ Eq (Neg.neg s).length s.length","decl":"@[simp]\ntheorem length_neg : ∀ s : Interval α, (-s).length = s.length\n  | ⊥ => rfl\n  | (s : NonemptyInterval α) => s.length_neg\n\n"}
{"name":"Interval.length_add_le","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns t : Interval α\n⊢ LE.le (HAdd.hAdd s t).length (HAdd.hAdd s.length t.length)","decl":"theorem length_add_le : ∀ s t : Interval α, (s + t).length ≤ s.length + t.length\n  | ⊥, _ => by simp\n  | _, ⊥ => by simp\n  | (s : NonemptyInterval α), (t : NonemptyInterval α) => (s.length_add t).le\n\n"}
{"name":"Interval.length_sub_le","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"α : Type u_2\ninst✝ : OrderedAddCommGroup α\ns t : Interval α\n⊢ LE.le (HSub.hSub s t).length (HAdd.hAdd s.length t.length)","decl":"theorem length_sub_le : (s - t).length ≤ s.length + t.length := by\n  simpa [sub_eq_add_neg] using length_add_le s (-t)\n\n"}
{"name":"Interval.length_sum_le","module":"Mathlib.Algebra.Order.Interval.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : OrderedAddCommGroup α\nf : ι → Interval α\ns : Finset ι\n⊢ LE.le (s.sum fun i => f i).length (s.sum fun i => (f i).length)","decl":"theorem length_sum_le (f : ι → Interval α) (s : Finset ι) :\n    (∑ i ∈ s, f i).length ≤ ∑ i ∈ s, (f i).length :=\n  Finset.le_sum_of_subadditive _ length_zero length_add_le _ _\n\n"}
