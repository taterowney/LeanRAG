{"name":"ContinuousLinearMap.coe_prod","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁹ : Semiring R\nM₁ : Type u_2\ninst✝⁸ : TopologicalSpace M₁\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : Module R M₁\nM₂ : Type u_3\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\nM₃ : Type u_4\ninst✝² : TopologicalSpace M₃\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nf₁ : ContinuousLinearMap (RingHom.id R) M₁ M₂\nf₂ : ContinuousLinearMap (RingHom.id R) M₁ M₃\n⊢ Eq (↑(f₁.prod f₂)) ((↑f₁).prod ↑f₂)","decl":"@[simp, norm_cast]\ntheorem coe_prod (f₁ : M₁ →L[R] M₂) (f₂ : M₁ →L[R] M₃) :\n    (f₁.prod f₂ : M₁ →ₗ[R] M₂ × M₃) = LinearMap.prod f₁ f₂ :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.prod_apply","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁹ : Semiring R\nM₁ : Type u_2\ninst✝⁸ : TopologicalSpace M₁\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : Module R M₁\nM₂ : Type u_3\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\nM₃ : Type u_4\ninst✝² : TopologicalSpace M₃\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nf₁ : ContinuousLinearMap (RingHom.id R) M₁ M₂\nf₂ : ContinuousLinearMap (RingHom.id R) M₁ M₃\nx : M₁\n⊢ Eq ((f₁.prod f₂) x) { fst := f₁ x, snd := f₂ x }","decl":"@[simp, norm_cast]\ntheorem prod_apply (f₁ : M₁ →L[R] M₂) (f₂ : M₁ →L[R] M₃) (x : M₁) :\n    f₁.prod f₂ x = (f₁ x, f₂ x) :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.inl_apply","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM₁ : Type u_2\ninst✝⁵ : TopologicalSpace M₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R M₁\nM₂ : Type u_3\ninst✝² : TopologicalSpace M₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nx : M₁\n⊢ Eq ((ContinuousLinearMap.inl R M₁ M₂) x) { fst := x, snd := 0 }","decl":"@[simp]\ntheorem inl_apply (x : M₁) : inl R M₁ M₂ x = (x, 0) :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.inr_apply","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM₁ : Type u_2\ninst✝⁵ : TopologicalSpace M₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R M₁\nM₂ : Type u_3\ninst✝² : TopologicalSpace M₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nx : M₂\n⊢ Eq ((ContinuousLinearMap.inr R M₁ M₂) x) { fst := 0, snd := x }","decl":"@[simp]\ntheorem inr_apply (x : M₂) : inr R M₁ M₂ x = (0, x) :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_inl","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM₁ : Type u_2\ninst✝⁵ : TopologicalSpace M₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R M₁\nM₂ : Type u_3\ninst✝² : TopologicalSpace M₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\n⊢ Eq (↑(ContinuousLinearMap.inl R M₁ M₂)) (LinearMap.inl R M₁ M₂)","decl":"@[simp, norm_cast]\ntheorem coe_inl : (inl R M₁ M₂ : M₁ →ₗ[R] M₁ × M₂) = LinearMap.inl R M₁ M₂ :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_inr","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM₁ : Type u_2\ninst✝⁵ : TopologicalSpace M₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R M₁\nM₂ : Type u_3\ninst✝² : TopologicalSpace M₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\n⊢ Eq (↑(ContinuousLinearMap.inr R M₁ M₂)) (LinearMap.inr R M₁ M₂)","decl":"@[simp, norm_cast]\ntheorem coe_inr : (inr R M₁ M₂ : M₂ →ₗ[R] M₁ × M₂) = LinearMap.inr R M₁ M₂ :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.ker_prod","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁹ : Semiring R\nM₁ : Type u_2\ninst✝⁸ : TopologicalSpace M₁\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : Module R M₁\nM₂ : Type u_3\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\nM₃ : Type u_4\ninst✝² : TopologicalSpace M₃\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nf : ContinuousLinearMap (RingHom.id R) M₁ M₂\ng : ContinuousLinearMap (RingHom.id R) M₁ M₃\n⊢ Eq (LinearMap.ker (f.prod g)) (Min.min (LinearMap.ker f) (LinearMap.ker g))","decl":"@[simp]\ntheorem ker_prod (f : M₁ →L[R] M₂) (g : M₁ →L[R] M₃) :\n    ker (f.prod g) = ker f ⊓ ker g :=\n  LinearMap.ker_prod (f : M₁ →ₗ[R] M₂) (g : M₁ →ₗ[R] M₃)\n\n"}
{"name":"ContinuousLinearMap.coe_fst","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM₁ : Type u_2\ninst✝⁵ : TopologicalSpace M₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R M₁\nM₂ : Type u_3\ninst✝² : TopologicalSpace M₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\n⊢ Eq (↑(ContinuousLinearMap.fst R M₁ M₂)) (LinearMap.fst R M₁ M₂)","decl":"@[simp, norm_cast]\ntheorem coe_fst : ↑(fst R M₁ M₂) = LinearMap.fst R M₁ M₂ :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_fst'","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM₁ : Type u_2\ninst✝⁵ : TopologicalSpace M₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R M₁\nM₂ : Type u_3\ninst✝² : TopologicalSpace M₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\n⊢ Eq (⇑(ContinuousLinearMap.fst R M₁ M₂)) Prod.fst","decl":"@[simp, norm_cast]\ntheorem coe_fst' : ⇑(fst R M₁ M₂) = Prod.fst :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_snd","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM₁ : Type u_2\ninst✝⁵ : TopologicalSpace M₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R M₁\nM₂ : Type u_3\ninst✝² : TopologicalSpace M₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\n⊢ Eq (↑(ContinuousLinearMap.snd R M₁ M₂)) (LinearMap.snd R M₁ M₂)","decl":"@[simp, norm_cast]\ntheorem coe_snd : ↑(snd R M₁ M₂) = LinearMap.snd R M₁ M₂ :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_snd'","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM₁ : Type u_2\ninst✝⁵ : TopologicalSpace M₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R M₁\nM₂ : Type u_3\ninst✝² : TopologicalSpace M₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\n⊢ Eq (⇑(ContinuousLinearMap.snd R M₁ M₂)) Prod.snd","decl":"@[simp, norm_cast]\ntheorem coe_snd' : ⇑(snd R M₁ M₂) = Prod.snd :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.fst_prod_snd","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM₁ : Type u_2\ninst✝⁵ : TopologicalSpace M₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R M₁\nM₂ : Type u_3\ninst✝² : TopologicalSpace M₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\n⊢ Eq ((ContinuousLinearMap.fst R M₁ M₂).prod (ContinuousLinearMap.snd R M₁ M₂)) (ContinuousLinearMap.id R (Prod M₁ M₂))","decl":"@[simp]\ntheorem fst_prod_snd : (fst R M₁ M₂).prod (snd R M₁ M₂) = id R (M₁ × M₂) :=\n  ext fun ⟨_x, _y⟩ => rfl\n\n"}
{"name":"ContinuousLinearMap.fst_comp_prod","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁹ : Semiring R\nM₁ : Type u_2\ninst✝⁸ : TopologicalSpace M₁\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : Module R M₁\nM₂ : Type u_3\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\nM₃ : Type u_4\ninst✝² : TopologicalSpace M₃\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nf : ContinuousLinearMap (RingHom.id R) M₁ M₂\ng : ContinuousLinearMap (RingHom.id R) M₁ M₃\n⊢ Eq ((ContinuousLinearMap.fst R M₂ M₃).comp (f.prod g)) f","decl":"@[simp]\ntheorem fst_comp_prod (f : M₁ →L[R] M₂) (g : M₁ →L[R] M₃) :\n    (fst R M₂ M₃).comp (f.prod g) = f :=\n  ext fun _x => rfl\n\n"}
{"name":"ContinuousLinearMap.snd_comp_prod","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁹ : Semiring R\nM₁ : Type u_2\ninst✝⁸ : TopologicalSpace M₁\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : Module R M₁\nM₂ : Type u_3\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\nM₃ : Type u_4\ninst✝² : TopologicalSpace M₃\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nf : ContinuousLinearMap (RingHom.id R) M₁ M₂\ng : ContinuousLinearMap (RingHom.id R) M₁ M₃\n⊢ Eq ((ContinuousLinearMap.snd R M₂ M₃).comp (f.prod g)) g","decl":"@[simp]\ntheorem snd_comp_prod (f : M₁ →L[R] M₂) (g : M₁ →L[R] M₃) :\n    (snd R M₂ M₃).comp (f.prod g) = g :=\n  ext fun _x => rfl\n\n"}
{"name":"ContinuousLinearMap.coe_prodMap","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝¹² : Semiring R\nM₁ : Type u_2\ninst✝¹¹ : TopologicalSpace M₁\ninst✝¹⁰ : AddCommMonoid M₁\ninst✝⁹ : Module R M₁\nM₂ : Type u_3\ninst✝⁸ : TopologicalSpace M₂\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M₂\nM₃ : Type u_4\ninst✝⁵ : TopologicalSpace M₃\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M₃\nM₄ : Type u_5\ninst✝² : TopologicalSpace M₄\ninst✝¹ : AddCommMonoid M₄\ninst✝ : Module R M₄\nf₁ : ContinuousLinearMap (RingHom.id R) M₁ M₂\nf₂ : ContinuousLinearMap (RingHom.id R) M₃ M₄\n⊢ Eq (↑(f₁.prodMap f₂)) ((↑f₁).prodMap ↑f₂)","decl":"@[simp, norm_cast]\ntheorem coe_prodMap (f₁ : M₁ →L[R] M₂)\n    (f₂ : M₃ →L[R] M₄) : ↑(f₁.prodMap f₂) = (f₁ : M₁ →ₗ[R] M₂).prodMap (f₂ : M₃ →ₗ[R] M₄) :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_prodMap'","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝¹² : Semiring R\nM₁ : Type u_2\ninst✝¹¹ : TopologicalSpace M₁\ninst✝¹⁰ : AddCommMonoid M₁\ninst✝⁹ : Module R M₁\nM₂ : Type u_3\ninst✝⁸ : TopologicalSpace M₂\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M₂\nM₃ : Type u_4\ninst✝⁵ : TopologicalSpace M₃\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M₃\nM₄ : Type u_5\ninst✝² : TopologicalSpace M₄\ninst✝¹ : AddCommMonoid M₄\ninst✝ : Module R M₄\nf₁ : ContinuousLinearMap (RingHom.id R) M₁ M₂\nf₂ : ContinuousLinearMap (RingHom.id R) M₃ M₄\n⊢ Eq (⇑(f₁.prodMap f₂)) (Prod.map ⇑f₁ ⇑f₂)","decl":"@[simp, norm_cast]\ntheorem coe_prodMap' (f₁ : M₁ →L[R] M₂)\n    (f₂ : M₃ →L[R] M₄) : ⇑(f₁.prodMap f₂) = Prod.map f₁ f₂ :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_pi'","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nι : Type u_4\nφ : ι → Type u_5\ninst✝² : (i : ι) → TopologicalSpace (φ i)\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nf : (i : ι) → ContinuousLinearMap (RingHom.id R) M (φ i)\n⊢ Eq ⇑(ContinuousLinearMap.pi f) fun c i => (f i) c","decl":"@[simp]\ntheorem coe_pi' (f : ∀ i, M →L[R] φ i) : ⇑(pi f) = fun c i => f i c :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_pi","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nι : Type u_4\nφ : ι → Type u_5\ninst✝² : (i : ι) → TopologicalSpace (φ i)\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nf : (i : ι) → ContinuousLinearMap (RingHom.id R) M (φ i)\n⊢ Eq (↑(ContinuousLinearMap.pi f)) (LinearMap.pi fun i => ↑(f i))","decl":"@[simp]\ntheorem coe_pi (f : ∀ i, M →L[R] φ i) : (pi f : M →ₗ[R] ∀ i, φ i) = LinearMap.pi fun i => f i :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.pi_apply","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nι : Type u_4\nφ : ι → Type u_5\ninst✝² : (i : ι) → TopologicalSpace (φ i)\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nf : (i : ι) → ContinuousLinearMap (RingHom.id R) M (φ i)\nc : M\ni : ι\n⊢ Eq ((ContinuousLinearMap.pi f) c i) ((f i) c)","decl":"theorem pi_apply (f : ∀ i, M →L[R] φ i) (c : M) (i : ι) : pi f c i = f i c :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.pi_eq_zero","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nι : Type u_4\nφ : ι → Type u_5\ninst✝² : (i : ι) → TopologicalSpace (φ i)\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nf : (i : ι) → ContinuousLinearMap (RingHom.id R) M (φ i)\n⊢ Iff (Eq (ContinuousLinearMap.pi f) 0) (∀ (i : ι), Eq (f i) 0)","decl":"theorem pi_eq_zero (f : ∀ i, M →L[R] φ i) : pi f = 0 ↔ ∀ i, f i = 0 := by\n  simp only [ContinuousLinearMap.ext_iff, pi_apply, funext_iff]\n  exact forall_swap\n\n"}
{"name":"ContinuousLinearMap.pi_zero","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nι : Type u_4\nφ : ι → Type u_5\ninst✝² : (i : ι) → TopologicalSpace (φ i)\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\n⊢ Eq (ContinuousLinearMap.pi fun x => 0) 0","decl":"theorem pi_zero : pi (fun _ => 0 : ∀ i, M →L[R] φ i) = 0 :=\n  ext fun _ => rfl\n\n"}
{"name":"ContinuousLinearMap.pi_comp","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁹ : Semiring R\nM : Type u_2\ninst✝⁸ : TopologicalSpace M\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nM₂ : Type u_3\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\nι : Type u_4\nφ : ι → Type u_5\ninst✝² : (i : ι) → TopologicalSpace (φ i)\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nf : (i : ι) → ContinuousLinearMap (RingHom.id R) M (φ i)\ng : ContinuousLinearMap (RingHom.id R) M₂ M\n⊢ Eq ((ContinuousLinearMap.pi f).comp g) (ContinuousLinearMap.pi fun i => (f i).comp g)","decl":"theorem pi_comp (f : ∀ i, M →L[R] φ i) (g : M₂ →L[R] M) :\n    (pi f).comp g = pi fun i => (f i).comp g :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.proj_apply","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nι : Type u_4\nφ : ι → Type u_5\ninst✝² : (i : ι) → TopologicalSpace (φ i)\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\ni : ι\nb : (i : ι) → φ i\n⊢ Eq ((ContinuousLinearMap.proj i) b) (b i)","decl":"@[simp]\ntheorem proj_apply (i : ι) (b : ∀ i, φ i) : (proj i : (∀ i, φ i) →L[R] φ i) b = b i :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.proj_pi","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nM₂ : Type u_3\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\nι : Type u_4\nφ : ι → Type u_5\ninst✝² : (i : ι) → TopologicalSpace (φ i)\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nf : (i : ι) → ContinuousLinearMap (RingHom.id R) M₂ (φ i)\ni : ι\n⊢ Eq ((ContinuousLinearMap.proj i).comp (ContinuousLinearMap.pi f)) (f i)","decl":"theorem proj_pi (f : ∀ i, M₂ →L[R] φ i) (i : ι) : (proj i).comp (pi f) = f i :=\n  ext fun _c => rfl\n\n"}
{"name":"ContinuousLinearMap.iInf_ker_proj","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nι : Type u_4\nφ : ι → Type u_5\ninst✝² : (i : ι) → TopologicalSpace (φ i)\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\n⊢ Eq (iInf fun i => LinearMap.ker (ContinuousLinearMap.proj i)) Bot.bot","decl":"theorem iInf_ker_proj : (⨅ i, ker (proj i : (∀ i, φ i) →L[R] φ i) : Submodule R (∀ i, φ i)) = ⊥ :=\n  LinearMap.iInf_ker_proj\n\n"}
{"name":"Pi.compRightL_apply","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nι : Type u_4\nφ : ι → Type u_5\ninst✝² : (i : ι) → TopologicalSpace (φ i)\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nα : Type u_6\nf : α → ι\nv : (i : ι) → φ i\ni : α\n⊢ Eq ((Pi.compRightL R φ f) v i) (v (f i))","decl":"@[simp] lemma _root_.Pi.compRightL_apply {α : Type*} (f : α → ι) (v : (i : ι) → φ i) (i : α) :\n    Pi.compRightL R φ f v i = v (f i) := rfl\n\n"}
{"name":"ContinuousLinearMap.range_prod_eq","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁹ : Ring R\nM : Type u_2\ninst✝⁸ : TopologicalSpace M\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nM₂ : Type u_3\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Module R M₂\nM₃ : Type u_4\ninst✝² : TopologicalSpace M₃\ninst✝¹ : AddCommGroup M₃\ninst✝ : Module R M₃\nf : ContinuousLinearMap (RingHom.id R) M M₂\ng : ContinuousLinearMap (RingHom.id R) M M₃\nh : Eq (Max.max (LinearMap.ker f) (LinearMap.ker g)) Top.top\n⊢ Eq (LinearMap.range (f.prod g)) ((LinearMap.range f).prod (LinearMap.range g))","decl":"theorem range_prod_eq {f : M →L[R] M₂} {g : M →L[R] M₃} (h : ker f ⊔ ker g = ⊤) :\n    range (f.prod g) = (range f).prod (range g) :=\n  LinearMap.range_prod_eq h\n\n"}
{"name":"ContinuousLinearMap.ker_prod_ker_le_ker_coprod","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁹ : Ring R\nM : Type u_2\ninst✝⁸ : TopologicalSpace M\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\nM₂ : Type u_3\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Module R M₂\nM₃ : Type u_4\ninst✝² : TopologicalSpace M₃\ninst✝¹ : AddCommGroup M₃\ninst✝ : Module R M₃\nf : ContinuousLinearMap (RingHom.id R) M M₃\ng : ContinuousLinearMap (RingHom.id R) M₂ M₃\n⊢ LE.le ((LinearMap.ker f).prod (LinearMap.ker g)) (LinearMap.ker ((↑f).coprod ↑g))","decl":"theorem ker_prod_ker_le_ker_coprod (f : M →L[R] M₃) (g : M₂ →L[R] M₃) :\n    (LinearMap.ker f).prod (LinearMap.ker g) ≤ LinearMap.ker (f.coprod g) :=\n  LinearMap.ker_prod_ker_le_ker_coprod f.toLinearMap g.toLinearMap\n\n"}
{"name":"ContinuousLinearMap.prodEquiv_apply","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁹ : Semiring R\nM : Type u_2\ninst✝⁸ : TopologicalSpace M\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nM₂ : Type u_3\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\nM₃ : Type u_4\ninst✝² : TopologicalSpace M₃\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nf : Prod (ContinuousLinearMap (RingHom.id R) M M₂) (ContinuousLinearMap (RingHom.id R) M M₃)\n⊢ Eq (ContinuousLinearMap.prodEquiv f) (f.1.prod f.2)","decl":"/-- `ContinuousLinearMap.prod` as an `Equiv`. -/\n@[simps apply]\ndef prodEquiv : (M →L[R] M₂) × (M →L[R] M₃) ≃ (M →L[R] M₂ × M₃) where\n  toFun f := f.1.prod f.2\n  invFun f := ⟨(fst _ _ _).comp f, (snd _ _ _).comp f⟩\n  left_inv f := by ext <;> rfl\n  right_inv f := by ext <;> rfl\n\n"}
{"name":"ContinuousLinearMap.prod_ext_iff","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁹ : Semiring R\nM : Type u_2\ninst✝⁸ : TopologicalSpace M\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nM₂ : Type u_3\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\nM₃ : Type u_4\ninst✝² : TopologicalSpace M₃\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nf g : ContinuousLinearMap (RingHom.id R) (Prod M M₂) M₃\n⊢ Iff (Eq f g) (And (Eq (f.comp (ContinuousLinearMap.inl R M M₂)) (g.comp (ContinuousLinearMap.inl R M M₂))) (Eq (f.comp (ContinuousLinearMap.inr R M M₂)) (g.comp (ContinuousLinearMap.inr R M M₂))))","decl":"theorem prod_ext_iff {f g : M × M₂ →L[R] M₃} :\n    f = g ↔ f.comp (inl _ _ _) = g.comp (inl _ _ _) ∧ f.comp (inr _ _ _) = g.comp (inr _ _ _) := by\n  simp only [← coe_inj, LinearMap.prod_ext_iff]\n  rfl\n\n"}
{"name":"ContinuousLinearMap.prod_ext","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝⁹ : Semiring R\nM : Type u_2\ninst✝⁸ : TopologicalSpace M\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nM₂ : Type u_3\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\nM₃ : Type u_4\ninst✝² : TopologicalSpace M₃\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nf g : ContinuousLinearMap (RingHom.id R) (Prod M M₂) M₃\nhl : Eq (f.comp (ContinuousLinearMap.inl R M M₂)) (g.comp (ContinuousLinearMap.inl R M M₂))\nhr : Eq (f.comp (ContinuousLinearMap.inr R M M₂)) (g.comp (ContinuousLinearMap.inr R M M₂))\n⊢ Eq f g","decl":"@[ext]\ntheorem prod_ext {f g : M × M₂ →L[R] M₃} (hl : f.comp (inl _ _ _) = g.comp (inl _ _ _))\n    (hr : f.comp (inr _ _ _) = g.comp (inr _ _ _)) : f = g :=\n  prod_ext_iff.2 ⟨hl, hr⟩\n\n"}
{"name":"ContinuousLinearMap.prodₗ_apply","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\ninst✝¹⁸ : Semiring R\nM : Type u_2\ninst✝¹⁷ : TopologicalSpace M\ninst✝¹⁶ : AddCommMonoid M\ninst✝¹⁵ : Module R M\nM₂ : Type u_3\ninst✝¹⁴ : TopologicalSpace M₂\ninst✝¹³ : AddCommMonoid M₂\ninst✝¹² : Module R M₂\nM₃ : Type u_4\ninst✝¹¹ : TopologicalSpace M₃\ninst✝¹⁰ : AddCommMonoid M₃\ninst✝⁹ : Module R M₃\nS : Type u_5\ninst✝⁸ : Semiring S\ninst✝⁷ : Module S M₂\ninst✝⁶ : ContinuousAdd M₂\ninst✝⁵ : SMulCommClass R S M₂\ninst✝⁴ : ContinuousConstSMul S M₂\ninst✝³ : Module S M₃\ninst✝² : ContinuousAdd M₃\ninst✝¹ : SMulCommClass R S M₃\ninst✝ : ContinuousConstSMul S M₃\na✝ : Prod (ContinuousLinearMap (RingHom.id R) M M₂) (ContinuousLinearMap (RingHom.id R) M M₃)\n⊢ Eq ((ContinuousLinearMap.prodₗ S) a✝) (ContinuousLinearMap.prodEquiv.toFun a✝)","decl":"/-- `ContinuousLinearMap.prod` as a `LinearEquiv`. -/\n@[simps apply]\ndef prodₗ : ((M →L[R] M₂) × (M →L[R] M₃)) ≃ₗ[S] M →L[R] M₂ × M₃ :=\n  { prodEquiv with\n    map_add' := fun _f _g => rfl\n    map_smul' := fun _c _f => rfl }\n\n"}
{"name":"ContinuousLinearMap.coprod_apply","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\nM : Type u_3\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝¹⁰ : Semiring R\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : TopologicalSpace M₁\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : ContinuousAdd M\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf₁ : ContinuousLinearMap (RingHom.id R) M₁ M\nf₂ : ContinuousLinearMap (RingHom.id R) M₂ M\na : Prod M₁ M₂\n⊢ Eq ((f₁.coprod f₂) a) (HAdd.hAdd (f₁ a.1) (f₂ a.2))","decl":"/-- The continuous linear map given by `(x, y) ↦ f₁ x + f₂ y`. -/\n@[simps! coe apply]\ndef coprod (f₁ : M₁ →L[R] M) (f₂ : M₂ →L[R] M) : M₁ × M₂ →L[R] M :=\n  ⟨.coprod f₁ f₂, (f₁.cont.comp continuous_fst).add (f₂.cont.comp continuous_snd)⟩\n\n"}
{"name":"ContinuousLinearMap.coe_coprod","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\nM : Type u_3\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝¹⁰ : Semiring R\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : TopologicalSpace M₁\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : ContinuousAdd M\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf₁ : ContinuousLinearMap (RingHom.id R) M₁ M\nf₂ : ContinuousLinearMap (RingHom.id R) M₂ M\n⊢ Eq (↑(f₁.coprod f₂)) ((↑f₁).coprod ↑f₂)","decl":"/-- The continuous linear map given by `(x, y) ↦ f₁ x + f₂ y`. -/\n@[simps! coe apply]\ndef coprod (f₁ : M₁ →L[R] M) (f₂ : M₂ →L[R] M) : M₁ × M₂ →L[R] M :=\n  ⟨.coprod f₁ f₂, (f₁.cont.comp continuous_fst).add (f₂.cont.comp continuous_snd)⟩\n\n"}
{"name":"ContinuousLinearMap.coprod_add","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\nM : Type u_3\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝¹⁰ : Semiring R\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : TopologicalSpace M₁\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : ContinuousAdd M\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf₁ g₁ : ContinuousLinearMap (RingHom.id R) M₁ M\nf₂ g₂ : ContinuousLinearMap (RingHom.id R) M₂ M\n⊢ Eq ((HAdd.hAdd f₁ g₁).coprod (HAdd.hAdd f₂ g₂)) (HAdd.hAdd (f₁.coprod f₂) (g₁.coprod g₂))","decl":"@[simp] lemma coprod_add (f₁ g₁ : M₁ →L[R] M) (f₂ g₂ : M₂ →L[R] M) :\n    (f₁ + g₁).coprod (f₂ + g₂) = f₁.coprod f₂ + g₁.coprod g₂ := by ext <;> simp\n\n"}
{"name":"ContinuousLinearMap.range_coprod","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\nM : Type u_3\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝¹⁰ : Semiring R\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : TopologicalSpace M₁\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : ContinuousAdd M\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf₁ : ContinuousLinearMap (RingHom.id R) M₁ M\nf₂ : ContinuousLinearMap (RingHom.id R) M₂ M\n⊢ Eq (LinearMap.range (f₁.coprod f₂)) (Max.max (LinearMap.range f₁) (LinearMap.range f₂))","decl":"lemma range_coprod (f₁ : M₁ →L[R] M) (f₂ : M₂ →L[R] M) :\n    range (f₁.coprod f₂) = range f₁ ⊔ range f₂ := LinearMap.range_coprod ..\n\n"}
{"name":"ContinuousLinearMap.comp_fst_add_comp_snd","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\nM : Type u_3\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝¹⁰ : Semiring R\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : TopologicalSpace M₁\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : ContinuousAdd M\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf₁ : ContinuousLinearMap (RingHom.id R) M₁ M\nf₂ : ContinuousLinearMap (RingHom.id R) M₂ M\n⊢ Eq (HAdd.hAdd (f₁.comp (ContinuousLinearMap.fst R M₁ M₂)) (f₂.comp (ContinuousLinearMap.snd R M₁ M₂))) (f₁.coprod f₂)","decl":"lemma comp_fst_add_comp_snd (f₁ : M₁ →L[R] M) (f₂ : M₂ →L[R] M) :\n    f₁.comp (.fst _ _ _) + f₂.comp (.snd _ _ _) = f₁.coprod f₂ := rfl\n\n"}
{"name":"ContinuousLinearMap.comp_coprod","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝¹⁴ : Semiring R\ninst✝¹³ : TopologicalSpace M\ninst✝¹² : TopologicalSpace N\ninst✝¹¹ : TopologicalSpace M₁\ninst✝¹⁰ : TopologicalSpace M₂\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : ContinuousAdd M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R N\ninst✝⁴ : ContinuousAdd N\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf : ContinuousLinearMap (RingHom.id R) M N\ng₁ : ContinuousLinearMap (RingHom.id R) M₁ M\ng₂ : ContinuousLinearMap (RingHom.id R) M₂ M\n⊢ Eq (f.comp (g₁.coprod g₂)) ((f.comp g₁).coprod (f.comp g₂))","decl":"lemma comp_coprod (f : M →L[R] N) (g₁ : M₁ →L[R] M) (g₂ : M₂ →L[R] M) :\n    f.comp (g₁.coprod g₂) = (f.comp g₁).coprod (f.comp g₂) :=\n  coe_injective <| LinearMap.comp_coprod ..\n\n"}
{"name":"ContinuousLinearMap.coprod_comp_inl","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\nM : Type u_3\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝¹⁰ : Semiring R\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : TopologicalSpace M₁\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : ContinuousAdd M\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf₁ : ContinuousLinearMap (RingHom.id R) M₁ M\nf₂ : ContinuousLinearMap (RingHom.id R) M₂ M\n⊢ Eq ((f₁.coprod f₂).comp (ContinuousLinearMap.inl R M₁ M₂)) f₁","decl":"@[simp] lemma coprod_comp_inl (f₁ : M₁ →L[R] M) (f₂ : M₂ →L[R] M) :\n    (f₁.coprod f₂).comp (.inl _ _ _) = f₁ := coe_injective <| LinearMap.coprod_inl ..\n\n"}
{"name":"ContinuousLinearMap.coprod_comp_inr","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\nM : Type u_3\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝¹⁰ : Semiring R\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : TopologicalSpace M₁\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : ContinuousAdd M\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R M₂\nf₁ : ContinuousLinearMap (RingHom.id R) M₁ M\nf₂ : ContinuousLinearMap (RingHom.id R) M₂ M\n⊢ Eq ((f₁.coprod f₂).comp (ContinuousLinearMap.inr R M₁ M₂)) f₂","decl":"@[simp] lemma coprod_comp_inr (f₁ : M₁ →L[R] M) (f₂ : M₂ →L[R] M) :\n    (f₁.coprod f₂).comp (.inr _ _ _) = f₂ := coe_injective <| LinearMap.coprod_inr ..\n\n"}
{"name":"ContinuousLinearMap.coprod_inl_inr","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝⁸ : Semiring R\ninst✝⁷ : TopologicalSpace M\ninst✝⁶ : TopologicalSpace N\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : ContinuousAdd M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : ContinuousAdd N\n⊢ Eq ((ContinuousLinearMap.inl R M N).coprod (ContinuousLinearMap.inr R M N)) (ContinuousLinearMap.id R (Prod M N))","decl":"@[simp]\nlemma coprod_inl_inr : ContinuousLinearMap.coprod (.inl R M N) (.inr R M N) = .id R (M × N) :=\n  coe_injective <| LinearMap.coprod_inl_inr\n\n"}
{"name":"ContinuousLinearMap.coprodEquiv_symm_apply","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝¹⁶ : Semiring R\ninst✝¹⁵ : TopologicalSpace M\ninst✝¹⁴ : TopologicalSpace M₁\ninst✝¹³ : TopologicalSpace M₂\ninst✝¹² : AddCommMonoid M\ninst✝¹¹ : Module R M\ninst✝¹⁰ : ContinuousAdd M\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : Module R M₁\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : ContinuousAdd M₁\ninst✝⁴ : ContinuousAdd M₂\ninst✝³ : Semiring S\ninst✝² : Module S M\ninst✝¹ : ContinuousConstSMul S M\ninst✝ : SMulCommClass R S M\nf : ContinuousLinearMap (RingHom.id R) (Prod M₁ M₂) M\n⊢ Eq (ContinuousLinearMap.coprodEquiv.symm f) { fst := f.comp (ContinuousLinearMap.inl R M₁ M₂), snd := f.comp (ContinuousLinearMap.inr R M₁ M₂) }","decl":"/-- Taking the product of two maps with the same codomain is equivalent to taking the product of\ntheir domains.\nSee note [bundled maps over different rings] for why separate `R` and `S` semirings are used.\n\nTODO: Upgrade this to a `ContinuousLinearEquiv`. This should be true for any topological\nvector space over a normed field thanks to `ContinuousLinearMap.precomp` and\n`ContinuousLinearMap.postcomp`. -/\n@[simps]\ndef coprodEquiv [ContinuousAdd M₁] [ContinuousAdd M₂] [Semiring S] [Module S M]\n    [ContinuousConstSMul S M] [SMulCommClass R S M] :\n    ((M₁ →L[R] M) × (M₂ →L[R] M)) ≃ₗ[S] M₁ × M₂ →L[R] M where\n  toFun f := f.1.coprod f.2\n  invFun f := (f.comp (.inl ..), f.comp (.inr ..))\n  left_inv f := by simp\n  right_inv f := by simp [← comp_coprod f (.inl R M₁ M₂)]\n  map_add' a b := coprod_add ..\n  map_smul' r a := by\n    dsimp\n    ext <;> simp [smul_add, smul_apply, Prod.smul_snd, Prod.smul_fst, coprod_apply]\n\n"}
{"name":"ContinuousLinearMap.coprodEquiv_apply","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝¹⁶ : Semiring R\ninst✝¹⁵ : TopologicalSpace M\ninst✝¹⁴ : TopologicalSpace M₁\ninst✝¹³ : TopologicalSpace M₂\ninst✝¹² : AddCommMonoid M\ninst✝¹¹ : Module R M\ninst✝¹⁰ : ContinuousAdd M\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : Module R M₁\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : ContinuousAdd M₁\ninst✝⁴ : ContinuousAdd M₂\ninst✝³ : Semiring S\ninst✝² : Module S M\ninst✝¹ : ContinuousConstSMul S M\ninst✝ : SMulCommClass R S M\nf : Prod (ContinuousLinearMap (RingHom.id R) M₁ M) (ContinuousLinearMap (RingHom.id R) M₂ M)\n⊢ Eq (ContinuousLinearMap.coprodEquiv f) (f.1.coprod f.2)","decl":"/-- Taking the product of two maps with the same codomain is equivalent to taking the product of\ntheir domains.\nSee note [bundled maps over different rings] for why separate `R` and `S` semirings are used.\n\nTODO: Upgrade this to a `ContinuousLinearEquiv`. This should be true for any topological\nvector space over a normed field thanks to `ContinuousLinearMap.precomp` and\n`ContinuousLinearMap.postcomp`. -/\n@[simps]\ndef coprodEquiv [ContinuousAdd M₁] [ContinuousAdd M₂] [Semiring S] [Module S M]\n    [ContinuousConstSMul S M] [SMulCommClass R S M] :\n    ((M₁ →L[R] M) × (M₂ →L[R] M)) ≃ₗ[S] M₁ × M₂ →L[R] M where\n  toFun f := f.1.coprod f.2\n  invFun f := (f.comp (.inl ..), f.comp (.inr ..))\n  left_inv f := by simp\n  right_inv f := by simp [← comp_coprod f (.inl R M₁ M₂)]\n  map_add' a b := coprod_add ..\n  map_smul' r a := by\n    dsimp\n    ext <;> simp [smul_add, smul_apply, Prod.smul_snd, Prod.smul_fst, coprod_apply]\n\n"}
{"name":"ContinuousLinearMap.ker_coprod_of_disjoint_range","module":"Mathlib.Topology.Algebra.Module.LinearMapPiProd","initialProofState":"R : Type u_1\nM : Type u_3\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝¹⁰ : Semiring R\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : TopologicalSpace M₁\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : ContinuousAdd M\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\nf₁ : ContinuousLinearMap (RingHom.id R) M₁ M\nf₂ : ContinuousLinearMap (RingHom.id R) M₂ M\nhf : Disjoint (LinearMap.range f₁) (LinearMap.range f₂)\n⊢ Eq (LinearMap.ker (f₁.coprod f₂)) ((LinearMap.ker f₁).prod (LinearMap.ker f₂))","decl":"lemma ker_coprod_of_disjoint_range {f₁ : M₁ →L[R] M} {f₂ : M₂ →L[R] M}\n    (hf : Disjoint (range f₁) (range f₂)) :\n    LinearMap.ker (f₁.coprod f₂) = (LinearMap.ker f₁).prod (LinearMap.ker f₂) :=\n  LinearMap.ker_coprod_of_disjoint_range f₁.toLinearMap f₂.toLinearMap hf\n\n"}
