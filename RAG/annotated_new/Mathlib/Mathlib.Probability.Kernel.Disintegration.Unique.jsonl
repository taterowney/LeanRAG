{"name":"ProbabilityTheory.eq_condKernel_of_measure_eq_compProd'","module":"Mathlib.Probability.Kernel.Disintegration.Unique","initialProofState":"α : Type u_1\nΩ : Type u_3\nmα : MeasurableSpace α\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\nρ : MeasureTheory.Measure (Prod α Ω)\ninst✝¹ : MeasureTheory.IsFiniteMeasure ρ\nκ : ProbabilityTheory.Kernel α Ω\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nhκ : Eq ρ (ρ.fst.compProd κ)\ns : Set Ω\nhs : MeasurableSet s\n⊢ Filter.Eventually (fun x => Eq ((κ x) s) ((ρ.condKernel x) s)) (MeasureTheory.ae ρ.fst)","decl":"/-- A s-finite kernel which satisfy the disintegration property of the given measure `ρ` is almost\neverywhere equal to the disintegration kernel of `ρ` when evaluated on a measurable set.\n\nThis theorem in the case of finite kernels is weaker than `eq_condKernel_of_measure_eq_compProd`\nwhich asserts that the kernels are equal almost everywhere and not just on a given measurable\nset. -/\ntheorem eq_condKernel_of_measure_eq_compProd' (κ : Kernel α Ω) [IsSFiniteKernel κ]\n    (hκ : ρ = ρ.fst ⊗ₘ κ) {s : Set Ω} (hs : MeasurableSet s) :\n    ∀ᵐ x ∂ρ.fst, κ x s = ρ.condKernel x s := by\n  refine ae_eq_of_forall_setLIntegral_eq_of_sigmaFinite\n    (Kernel.measurable_coe κ hs) (Kernel.measurable_coe ρ.condKernel hs) (fun t ht _ ↦ ?_)\n  conv_rhs => rw [Measure.setLIntegral_condKernel_eq_measure_prod ht hs, hκ]\n  simp only [Measure.compProd_apply (ht.prod hs), Set.mem_prod, ← lintegral_indicator ht]\n  congr with x\n  by_cases hx : x ∈ t\n  all_goals simp [hx]\n\n"}
{"name":"ProbabilityTheory.eq_condKernel_of_measure_eq_compProd_real","module":"Mathlib.Probability.Kernel.Disintegration.Unique","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nρ : MeasureTheory.Measure (Prod α Real)\ninst✝¹ : MeasureTheory.IsFiniteMeasure ρ\nκ : ProbabilityTheory.Kernel α Real\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nhκ : Eq ρ (ρ.fst.compProd κ)\n⊢ Filter.Eventually (fun x => Eq (κ x) (ρ.condKernel x)) (MeasureTheory.ae ρ.fst)","decl":"/-- Auxiliary lemma for `eq_condKernel_of_measure_eq_compProd`.\nUniqueness of the disintegration kernel on ℝ. -/\nlemma eq_condKernel_of_measure_eq_compProd_real {ρ : Measure (α × ℝ)} [IsFiniteMeasure ρ]\n    (κ : Kernel α ℝ) [IsFiniteKernel κ] (hκ : ρ = ρ.fst ⊗ₘ κ) :\n    ∀ᵐ x ∂ρ.fst, κ x = ρ.condKernel x := by\n  have huniv : ∀ᵐ x ∂ρ.fst, κ x Set.univ = ρ.condKernel x Set.univ :=\n    eq_condKernel_of_measure_eq_compProd' κ hκ MeasurableSet.univ\n  suffices ∀ᵐ x ∂ρ.fst, ∀ ⦃t⦄, MeasurableSet t → κ x t = ρ.condKernel x t by\n    filter_upwards [this] with x hx\n    ext t ht; exact hx ht\n  apply MeasurableSpace.ae_induction_on_inter Real.borel_eq_generateFrom_Iic_rat\n    Real.isPiSystem_Iic_rat\n  · simp\n  · simp only [iUnion_singleton_eq_range, mem_range, forall_exists_index, forall_apply_eq_imp_iff]\n    exact ae_all_iff.2 fun q ↦ eq_condKernel_of_measure_eq_compProd' κ hκ measurableSet_Iic\n  · filter_upwards [huniv] with x hxuniv t ht heq\n    rw [measure_compl ht <| measure_ne_top _ _, heq, hxuniv, measure_compl ht <| measure_ne_top _ _]\n  · refine ae_of_all _ (fun x f hdisj hf heq ↦ ?_)\n    rw [measure_iUnion hdisj hf, measure_iUnion hdisj hf]\n    exact tsum_congr heq\n\n"}
{"name":"ProbabilityTheory.eq_condKernel_of_measure_eq_compProd","module":"Mathlib.Probability.Kernel.Disintegration.Unique","initialProofState":"α : Type u_1\nΩ : Type u_3\nmα : MeasurableSpace α\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\nρ : MeasureTheory.Measure (Prod α Ω)\ninst✝¹ : MeasureTheory.IsFiniteMeasure ρ\nκ : ProbabilityTheory.Kernel α Ω\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nhκ : Eq ρ (ρ.fst.compProd κ)\n⊢ Filter.Eventually (fun x => Eq (κ x) (ρ.condKernel x)) (MeasureTheory.ae ρ.fst)","decl":"/-- A finite kernel which satisfies the disintegration property is almost everywhere equal to the\ndisintegration kernel. -/\ntheorem eq_condKernel_of_measure_eq_compProd (κ : Kernel α Ω) [IsFiniteKernel κ]\n    (hκ : ρ = ρ.fst ⊗ₘ κ) :\n    ∀ᵐ x ∂ρ.fst, κ x = ρ.condKernel x := by\n  -- The idea is to transport the question to `ℝ` from `Ω` using `embeddingReal`\n  -- and then construct a measure on `α × ℝ`\n  let f := embeddingReal Ω\n  have hf := measurableEmbedding_embeddingReal Ω\n  set ρ' : Measure (α × ℝ) := ρ.map (Prod.map id f) with hρ'def\n  have hρ' : ρ'.fst = ρ.fst := by\n    ext s hs\n    rw [hρ'def, Measure.fst_apply, Measure.fst_apply, Measure.map_apply]\n    exacts [rfl, Measurable.prod measurable_fst <| hf.measurable.comp measurable_snd,\n      measurable_fst hs, hs, hs]\n  have hρ'' : ∀ᵐ x ∂ρ.fst, Kernel.map κ f x = ρ'.condKernel x := by\n    rw [← hρ']\n    refine eq_condKernel_of_measure_eq_compProd_real (Kernel.map κ f) ?_\n    ext s hs\n    conv_lhs => rw [hρ'def, hκ]\n    rw [Measure.map_apply (measurable_id.prod_map hf.measurable) hs, hρ',\n      Measure.compProd_apply hs, Measure.compProd_apply (measurable_id.prod_map hf.measurable hs)]\n    congr with a\n    rw [Kernel.map_apply' _ hf.measurable]\n    exacts [rfl, measurable_prod_mk_left hs]\n  suffices ∀ᵐ x ∂ρ.fst, ∀ s, MeasurableSet s → ρ'.condKernel x s = ρ.condKernel x (f ⁻¹' s) by\n    filter_upwards [hρ'', this] with x hx h\n    rw [Kernel.map_apply _ hf.measurable] at hx\n    ext s hs\n    rw [← Set.preimage_image_eq s hf.injective,\n      ← Measure.map_apply hf.measurable <| hf.measurableSet_image.2 hs, hx,\n      h _ <| hf.measurableSet_image.2 hs]\n  suffices ρ.map (Prod.map id f) = (ρ.fst ⊗ₘ (Kernel.map ρ.condKernel f)) by\n    rw [← hρ'] at this\n    have heq := eq_condKernel_of_measure_eq_compProd_real _ this\n    rw [hρ'] at heq\n    filter_upwards [heq] with x hx s hs\n    rw [← hx, Kernel.map_apply _ hf.measurable, Measure.map_apply hf.measurable hs]\n  ext s hs\n  conv_lhs => rw [← ρ.disintegrate ρ.condKernel]\n  rw [Measure.compProd_apply hs, Measure.map_apply (measurable_id.prod_map hf.measurable) hs,\n    Measure.compProd_apply]\n  · congr with a\n    rw [Kernel.map_apply' _ hf.measurable]\n    exacts [rfl, measurable_prod_mk_left hs]\n  · exact measurable_id.prod_map hf.measurable hs\n\n"}
{"name":"ProbabilityTheory.Kernel.apply_eq_measure_condKernel_of_compProd_eq","module":"Mathlib.Probability.Kernel.Disintegration.Unique","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\nρ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝¹ : ProbabilityTheory.IsFiniteKernel ρ\nκ : ProbabilityTheory.Kernel (Prod α β) Ω\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nhκ : Eq (ρ.fst.compProd κ) ρ\na : α\n⊢ (MeasureTheory.ae (ρ.fst a)).EventuallyEq (fun b => κ { fst := a, snd := b }) ⇑(ρ a).condKernel","decl":"lemma Kernel.apply_eq_measure_condKernel_of_compProd_eq\n    {ρ : Kernel α (β × Ω)} [IsFiniteKernel ρ] {κ : Kernel (α × β) Ω} [IsFiniteKernel κ]\n    (hκ : Kernel.fst ρ ⊗ₖ κ = ρ) (a : α) :\n    (fun b ↦ κ (a, b)) =ᵐ[Kernel.fst ρ a] (ρ a).condKernel := by\n  have : ρ a = (ρ a).fst ⊗ₘ Kernel.comap κ (fun b ↦ (a, b)) measurable_prod_mk_left := by\n    ext s hs\n    conv_lhs => rw [← hκ]\n    rw [Measure.compProd_apply hs, Kernel.compProd_apply hs]\n    rfl\n  have h := eq_condKernel_of_measure_eq_compProd _ this\n  rw [Kernel.fst_apply]\n  filter_upwards [h] with b hb\n  rw [← hb, Kernel.comap_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.condKernel_apply_eq_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Unique","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\na : α\n⊢ (MeasureTheory.ae (κ.fst a)).EventuallyEq (fun b => κ.condKernel { fst := a, snd := b }) ⇑(κ a).condKernel","decl":"/-- For `fst κ a`-almost all `b`, the conditional kernel `Kernel.condKernel κ` applied to `(a, b)`\nis equal to the conditional kernel of the measure `κ a` applied to `b`. -/\nlemma Kernel.condKernel_apply_eq_condKernel [CountableOrCountablyGenerated α β]\n    (κ : Kernel α (β × Ω)) [IsFiniteKernel κ] (a : α) :\n    (fun b ↦ Kernel.condKernel κ (a, b)) =ᵐ[Kernel.fst κ a] (κ a).condKernel :=\n  Kernel.apply_eq_measure_condKernel_of_compProd_eq (κ.disintegrate _) a\n\n"}
{"name":"ProbabilityTheory.condKernel_const","module":"Mathlib.Probability.Kernel.Disintegration.Unique","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : MeasurableSpace.CountableOrCountablyGenerated α β\nρ : MeasureTheory.Measure (Prod β Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\na : α\n⊢ (MeasureTheory.ae ρ.fst).EventuallyEq (fun b => (ProbabilityTheory.Kernel.const α ρ).condKernel { fst := a, snd := b }) ⇑ρ.condKernel","decl":"lemma condKernel_const [CountableOrCountablyGenerated α β] (ρ : Measure (β × Ω)) [IsFiniteMeasure ρ]\n    (a : α) :\n    (fun b ↦ Kernel.condKernel (Kernel.const α ρ) (a, b)) =ᵐ[ρ.fst] ρ.condKernel := by\n  have h := Kernel.condKernel_apply_eq_condKernel (Kernel.const α ρ) a\n  simp_rw [Kernel.fst_apply, Kernel.const_apply] at h\n  filter_upwards [h] with b hb using hb\n\n"}
{"name":"ProbabilityTheory.eq_condKernel_of_kernel_eq_compProd","module":"Mathlib.Probability.Kernel.Disintegration.Unique","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\ninst✝² : MeasurableSpace.CountableOrCountablyGenerated α β\nρ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝¹ : ProbabilityTheory.IsFiniteKernel ρ\nκ : ProbabilityTheory.Kernel (Prod α β) Ω\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nhκ : Eq (ρ.fst.compProd κ) ρ\na : α\n⊢ Filter.Eventually (fun x => Eq (κ { fst := a, snd := x }) (ρ.condKernel { fst := a, snd := x })) (MeasureTheory.ae (ρ.fst a))","decl":"/-- A finite kernel which satisfies the disintegration property is almost everywhere equal to the\ndisintegration kernel. -/\ntheorem eq_condKernel_of_kernel_eq_compProd [CountableOrCountablyGenerated α β]\n    {ρ : Kernel α (β × Ω)} [IsFiniteKernel ρ] {κ : Kernel (α × β) Ω} [IsFiniteKernel κ]\n    (hκ : Kernel.fst ρ ⊗ₖ κ = ρ) (a : α) :\n    ∀ᵐ x ∂(Kernel.fst ρ a), κ (a, x) = Kernel.condKernel ρ (a, x) := by\n  filter_upwards [Kernel.condKernel_apply_eq_condKernel ρ a,\n    Kernel.apply_eq_measure_condKernel_of_compProd_eq hκ a] with a h1 h2\n  rw [h1, h2]\n\n"}
