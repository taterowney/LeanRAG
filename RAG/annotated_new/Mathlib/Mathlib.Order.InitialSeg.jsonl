{"name":"InitialSeg.mem_range_of_rel'","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_4\nβ : Type u_5\nr : α → α → Prop\ns : β → β → Prop\nself : InitialSeg r s\na : α\nb : β\na✝ : s b (self.toRelEmbedding a)\n⊢ Membership.mem (Set.range ⇑self.toRelEmbedding) b","decl":"/-- If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≼i s` is an order\nembedding whose `Set.range` is a lower set. That is, whenever `b < f a` in `β` then `b` is in the\nrange of `f`. -/\nstructure InitialSeg {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends r ↪r s where\n  /-- The order embedding is an initial segment -/\n  mem_range_of_rel' : ∀ a b, s b (toRelEmbedding a) → b ∈ Set.range toRelEmbedding\n\n-- Porting note: Deleted `scoped[InitialSeg]`\n"}
{"name":"InitialSeg.mk.injEq","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_4\nβ : Type u_5\nr : α → α → Prop\ns : β → β → Prop\ntoRelEmbedding✝ : RelEmbedding r s\nmem_range_of_rel'✝ : ∀ (a : α) (b : β), s b (toRelEmbedding✝ a) → Membership.mem (Set.range ⇑toRelEmbedding✝) b\ntoRelEmbedding : RelEmbedding r s\nmem_range_of_rel' : ∀ (a : α) (b : β), s b (toRelEmbedding a) → Membership.mem (Set.range ⇑toRelEmbedding) b\n⊢ Eq (Eq { toRelEmbedding := toRelEmbedding✝, mem_range_of_rel' := mem_range_of_rel'✝ } { toRelEmbedding := toRelEmbedding, mem_range_of_rel' := mem_range_of_rel' }) (Eq toRelEmbedding✝ toRelEmbedding)","decl":"/-- If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≼i s` is an order\nembedding whose `Set.range` is a lower set. That is, whenever `b < f a` in `β` then `b` is in the\nrange of `f`. -/\nstructure InitialSeg {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends r ↪r s where\n  /-- The order embedding is an initial segment -/\n  mem_range_of_rel' : ∀ a b, s b (toRelEmbedding a) → b ∈ Set.range toRelEmbedding\n\n-- Porting note: Deleted `scoped[InitialSeg]`\n"}
{"name":"InitialSeg.mk.sizeOf_spec","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_4\nβ : Type u_5\nr : α → α → Prop\ns : β → β → Prop\ninst✝³ : SizeOf α\ninst✝² : SizeOf β\ninst✝¹ : (a a_1 : α) → SizeOf (r a a_1)\ninst✝ : (a a_1 : β) → SizeOf (s a a_1)\ntoRelEmbedding : RelEmbedding r s\nmem_range_of_rel' : ∀ (a : α) (b : β), s b (toRelEmbedding a) → Membership.mem (Set.range ⇑toRelEmbedding) b\n⊢ Eq (SizeOf.sizeOf { toRelEmbedding := toRelEmbedding, mem_range_of_rel' := mem_range_of_rel' }) (HAdd.hAdd 1 (SizeOf.sizeOf toRelEmbedding))","decl":"/-- If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≼i s` is an order\nembedding whose `Set.range` is a lower set. That is, whenever `b < f a` in `β` then `b` is in the\nrange of `f`. -/\nstructure InitialSeg {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends r ↪r s where\n  /-- The order embedding is an initial segment -/\n  mem_range_of_rel' : ∀ a b, s b (toRelEmbedding a) → b ∈ Set.range toRelEmbedding\n\n-- Porting note: Deleted `scoped[InitialSeg]`\n"}
{"name":"InitialSeg.mk.inj","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_4\nβ : Type u_5\nr : α → α → Prop\ns : β → β → Prop\ntoRelEmbedding✝ : RelEmbedding r s\nmem_range_of_rel'✝ : ∀ (a : α) (b : β), s b (toRelEmbedding✝ a) → Membership.mem (Set.range ⇑toRelEmbedding✝) b\ntoRelEmbedding : RelEmbedding r s\nmem_range_of_rel' : ∀ (a : α) (b : β), s b (toRelEmbedding a) → Membership.mem (Set.range ⇑toRelEmbedding) b\nx✝ : Eq { toRelEmbedding := toRelEmbedding✝, mem_range_of_rel' := mem_range_of_rel'✝ } { toRelEmbedding := toRelEmbedding, mem_range_of_rel' := mem_range_of_rel' }\n⊢ Eq toRelEmbedding✝ toRelEmbedding","decl":"/-- If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≼i s` is an order\nembedding whose `Set.range` is a lower set. That is, whenever `b < f a` in `β` then `b` is in the\nrange of `f`. -/\nstructure InitialSeg {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends r ↪r s where\n  /-- The order embedding is an initial segment -/\n  mem_range_of_rel' : ∀ a b, s b (toRelEmbedding a) → b ∈ Set.range toRelEmbedding\n\n-- Porting note: Deleted `scoped[InitialSeg]`\n"}
{"name":"InitialSeg.instEmbeddingLike","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\n⊢ EmbeddingLike (InitialSeg r s) α β","decl":"instance : EmbeddingLike (r ≼i s) α β where\n  injective' f := f.inj'\n\n"}
{"name":"InitialSeg.instRelHomClass","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\n⊢ RelHomClass (InitialSeg r s) r s","decl":"instance : RelHomClass (r ≼i s) r s where\n  map_rel f := f.map_rel_iff.2\n\n"}
{"name":"InitialSeg.toOrderEmbedding_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\nx : α\n⊢ Eq (f.toOrderEmbedding x) (f x)","decl":"@[simp]\ntheorem toOrderEmbedding_apply [PartialOrder α] [PartialOrder β] (f : α ≤i β) (x : α) :\n    f.toOrderEmbedding x = f x :=\n  rfl\n\n"}
{"name":"InitialSeg.coe_toOrderEmbedding","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Eq ⇑f.toOrderEmbedding ⇑f","decl":"@[simp]\ntheorem coe_toOrderEmbedding [PartialOrder α] [PartialOrder β] (f : α ≤i β) :\n    (f.toOrderEmbedding : α → β) = f :=\n  rfl\n\n"}
{"name":"InitialSeg.instOrderHomClassLt","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\n⊢ OrderHomClass (InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2) α β","decl":"instance [PartialOrder α] [PartialOrder β] : OrderHomClass (α ≤i β) α β where\n  map_rel f := f.toOrderEmbedding.map_rel_iff.2\n\n"}
{"name":"InitialSeg.ext_iff","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf g : InitialSeg r s\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f x) (g x))","decl":"@[ext] lemma ext {f g : r ≼i s} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"InitialSeg.ext","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf g : InitialSeg r s\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext] lemma ext {f g : r ≼i s} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"InitialSeg.coe_coe_fn","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : InitialSeg r s\n⊢ Eq ⇑f.toRelEmbedding ⇑f","decl":"@[simp]\ntheorem coe_coe_fn (f : r ≼i s) : ((f : r ↪r s) : α → β) = f :=\n  rfl\n\n"}
{"name":"InitialSeg.mem_range_of_rel","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : InitialSeg r s\na : α\nb : β\na✝ : s b (f a)\n⊢ Membership.mem (Set.range ⇑f) b","decl":"theorem mem_range_of_rel (f : r ≼i s) {a : α} {b : β} : s b (f a) → b ∈ Set.range f :=\n  f.mem_range_of_rel' _ _\n\n"}
{"name":"InitialSeg.init","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : InitialSeg r s\na : α\nb : β\na✝ : s b (f a)\n⊢ Membership.mem (Set.range ⇑f) b","decl":"@[deprecated mem_range_of_rel (since := \"2024-09-21\")]\nalias init := mem_range_of_rel\n\n"}
{"name":"InitialSeg.map_rel_iff","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\na b : α\nf : InitialSeg r s\n⊢ Iff (s (f a) (f b)) (r a b)","decl":"theorem map_rel_iff {a b : α} (f : r ≼i s) : s (f a) (f b) ↔ r a b :=\n  f.map_rel_iff'\n\n"}
{"name":"InitialSeg.inj","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : InitialSeg r s\na b : α\n⊢ Iff (Eq (f a) (f b)) (Eq a b)","decl":"theorem inj (f : r ≼i s) {a b : α} : f a = f b ↔ a = b :=\n  f.toRelEmbedding.inj\n\n"}
{"name":"InitialSeg.exists_eq_iff_rel","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : InitialSeg r s\na : α\nb : β\n⊢ Iff (s b (f a)) (Exists fun a' => And (Eq (f a') b) (r a' a))","decl":"theorem exists_eq_iff_rel (f : r ≼i s) {a : α} {b : β} : s b (f a) ↔ ∃ a', f a' = b ∧ r a' a :=\n  ⟨fun h => by\n    rcases f.mem_range_of_rel h with ⟨a', rfl⟩\n    exact ⟨a', rfl, f.map_rel_iff.1 h⟩,\n    fun ⟨_, e, h⟩ => e ▸ f.map_rel_iff.2 h⟩\n\n"}
{"name":"InitialSeg.init_iff","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : InitialSeg r s\na : α\nb : β\n⊢ Iff (s b (f a)) (Exists fun a' => And (Eq (f a') b) (r a' a))","decl":"@[deprecated exists_eq_iff_rel (since := \"2024-09-21\")]\nalias init_iff := exists_eq_iff_rel\n\n"}
{"name":"RelIso.toInitialSeg_toFun","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelIso r s\na : α\n⊢ Eq (f.toInitialSeg a) (f a)","decl":"/-- A relation isomorphism is an initial segment embedding -/\n@[simps!]\ndef _root_.RelIso.toInitialSeg (f : r ≃r s) : r ≼i s :=\n  ⟨f, by simp⟩\n\n"}
{"name":"InitialSeg.refl_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nr : α → α → Prop\nx : α\n⊢ Eq ((InitialSeg.refl r) x) x","decl":"@[simp]\ntheorem refl_apply (x : α) : InitialSeg.refl r x = x :=\n  rfl\n\n"}
{"name":"InitialSeg.trans_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : InitialSeg r s\ng : InitialSeg s t\na : α\n⊢ Eq ((f.trans g) a) (g (f a))","decl":"@[simp]\ntheorem trans_apply (f : r ≼i s) (g : s ≼i t) (a : α) : (f.trans g) a = g (f a) :=\n  rfl\n\n"}
{"name":"InitialSeg.subsingleton_of_trichotomous_of_irrefl","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝² : IsTrichotomous β s\ninst✝¹ : IsIrrefl β s\ninst✝ : IsWellFounded α r\n⊢ Subsingleton (InitialSeg r s)","decl":"instance subsingleton_of_trichotomous_of_irrefl [IsTrichotomous β s] [IsIrrefl β s]\n    [IsWellFounded α r] : Subsingleton (r ≼i s) where\n  allEq f g := by\n    ext a\n    refine IsWellFounded.induction r a fun b IH =>\n      extensional_of_trichotomous_of_irrefl s fun x => ?_\n    rw [f.exists_eq_iff_rel, g.exists_eq_iff_rel]\n    exact exists_congr fun x => and_congr_left fun hx => IH _ hx ▸ Iff.rfl\n\n"}
{"name":"InitialSeg.instSubsingletonOfIsWellOrder","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsWellOrder β s\n⊢ Subsingleton (InitialSeg r s)","decl":"/-- Given a well order `s`, there is at most one initial segment embedding of `r` into `s`. -/\ninstance [IsWellOrder β s] : Subsingleton (r ≼i s) :=\n  ⟨fun a => have := a.isWellFounded; Subsingleton.elim a⟩\n\n"}
{"name":"InitialSeg.eq","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsWellOrder β s\nf g : InitialSeg r s\na : α\n⊢ Eq (f a) (g a)","decl":"protected theorem eq [IsWellOrder β s] (f g : r ≼i s) (a) : f a = g a := by\n  rw [Subsingleton.elim f g]\n\n"}
{"name":"InitialSeg.eq_relIso","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsWellOrder β s\nf : InitialSeg r s\ng : RelIso r s\na : α\n⊢ Eq (g a) (f a)","decl":"theorem eq_relIso [IsWellOrder β s] (f : r ≼i s) (g : r ≃r s) (a : α) : g a = f a :=\n  InitialSeg.eq g.toInitialSeg f a\n\n"}
{"name":"InitialSeg.ltOrEq_apply_right","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsWellOrder β s\nf : InitialSeg r s\ng : RelIso r s\na : α\n⊢ Eq (g a) (f a)","decl":"@[deprecated eq_relIso (since := \"2024-10-20\")]\nalias ltOrEq_apply_right := eq_relIso\n\n"}
{"name":"InitialSeg.antisymm_toFun","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsWellOrder β s\nf : InitialSeg r s\ng : InitialSeg s r\n⊢ Eq ⇑(f.antisymm g) ⇑f","decl":"@[simp]\ntheorem antisymm_toFun [IsWellOrder β s] (f : r ≼i s) (g : s ≼i r) : (antisymm f g : α → β) = f :=\n  rfl\n\n"}
{"name":"InitialSeg.antisymm_symm","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\nf : InitialSeg r s\ng : InitialSeg s r\n⊢ Eq (f.antisymm g).symm (g.antisymm f)","decl":"@[simp]\ntheorem antisymm_symm [IsWellOrder α r] [IsWellOrder β s] (f : r ≼i s) (g : s ≼i r) :\n    (antisymm f g).symm = antisymm g f :=\n  RelIso.coe_fn_injective rfl\n\n"}
{"name":"InitialSeg.eq_or_principal","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsWellOrder β s\nf : InitialSeg r s\n⊢ Or (Function.Surjective ⇑f) (Exists fun b => ∀ (x : β), Iff (Membership.mem (Set.range ⇑f) x) (s x b))","decl":"/-- An initial segment embedding is either an isomorphism, or a principal segment embedding.\n\nSee also `InitialSeg.ltOrEq`. -/\ntheorem eq_or_principal [IsWellOrder β s] (f : r ≼i s) :\n    Surjective f ∨ ∃ b, ∀ x, x ∈ Set.range f ↔ s x b := by\n  apply or_iff_not_imp_right.2\n  intro h b\n  push_neg at h\n  apply IsWellFounded.induction s b\n  intro x IH\n  obtain ⟨y, ⟨hy, hs⟩ | ⟨hy, hs⟩⟩ := h x\n  · obtain (rfl | h) := (trichotomous y x).resolve_left hs\n    · exact hy\n    · obtain ⟨z, rfl⟩ := hy\n      exact f.mem_range_of_rel h\n  · obtain ⟨z, rfl⟩ := IH y hs\n    cases hy (Set.mem_range_self z)\n\n"}
{"name":"InitialSeg.codRestrict_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\np : Set β\nf : InitialSeg r s\nH : ∀ (a : α), Membership.mem p (f a)\na : α\n⊢ Eq ((InitialSeg.codRestrict p f H) a) ⟨f a, ⋯⟩","decl":"@[simp]\ntheorem codRestrict_apply (p) (f : r ≼i s) (H a) : codRestrict p f H a = ⟨f a, H a⟩ :=\n  rfl\n\n"}
{"name":"InitialSeg.leAdd_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\na : α\n⊢ Eq ((InitialSeg.leAdd r s) a) (Sum.inl a)","decl":"@[simp]\ntheorem leAdd_apply (r : α → α → Prop) (s : β → β → Prop) (a) : leAdd r s a = Sum.inl a :=\n  rfl\n\n"}
{"name":"InitialSeg.acc","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : InitialSeg r s\na : α\n⊢ Iff (Acc r a) (Acc s (f a))","decl":"protected theorem acc (f : r ≼i s) (a : α) : Acc r a ↔ Acc s (f a) :=\n  ⟨by\n    refine fun h => Acc.recOn h fun a _ ha => Acc.intro _ fun b hb => ?_\n    obtain ⟨a', rfl⟩ := f.mem_range_of_rel hb\n    exact ha _ (f.map_rel_iff.mp hb), f.toRelEmbedding.acc a⟩\n\n"}
{"name":"PrincipalSeg.mk.sizeOf_spec","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_4\nβ : Type u_5\nr : α → α → Prop\ns : β → β → Prop\ninst✝³ : SizeOf α\ninst✝² : SizeOf β\ninst✝¹ : (a a_1 : α) → SizeOf (r a a_1)\ninst✝ : (a a_1 : β) → SizeOf (s a a_1)\ntoRelEmbedding : RelEmbedding r s\ntop : β\nmem_range_iff_rel' : ∀ (b : β), Iff (Membership.mem (Set.range ⇑toRelEmbedding) b) (s b top)\n⊢ Eq (SizeOf.sizeOf { toRelEmbedding := toRelEmbedding, top := top, mem_range_iff_rel' := mem_range_iff_rel' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toRelEmbedding)) (SizeOf.sizeOf top))","decl":"/-- If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≺i s` is an initial\nsegment embedding whose range is `Set.Iio x` for some element `x`. If `β` is a well order, this is\nequivalent to the embedding not being surjective. -/\nstructure PrincipalSeg {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends r ↪r s where\n  /-- The supremum of the principal segment -/\n  top : β\n  /-- The range of the order embedding is the set of elements `b` such that `s b top` -/\n  mem_range_iff_rel' : ∀ b, b ∈ Set.range toRelEmbedding ↔ s b top\n\n-- Porting note: deleted `scoped[InitialSeg]`\n"}
{"name":"PrincipalSeg.mk.inj","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_4\nβ : Type u_5\nr : α → α → Prop\ns : β → β → Prop\ntoRelEmbedding✝ : RelEmbedding r s\ntop✝ : β\nmem_range_iff_rel'✝ : ∀ (b : β), Iff (Membership.mem (Set.range ⇑toRelEmbedding✝) b) (s b top✝)\ntoRelEmbedding : RelEmbedding r s\ntop : β\nmem_range_iff_rel' : ∀ (b : β), Iff (Membership.mem (Set.range ⇑toRelEmbedding) b) (s b top)\nx✝ : Eq { toRelEmbedding := toRelEmbedding✝, top := top✝, mem_range_iff_rel' := mem_range_iff_rel'✝ } { toRelEmbedding := toRelEmbedding, top := top, mem_range_iff_rel' := mem_range_iff_rel' }\n⊢ And (Eq toRelEmbedding✝ toRelEmbedding) (Eq top✝ top)","decl":"/-- If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≺i s` is an initial\nsegment embedding whose range is `Set.Iio x` for some element `x`. If `β` is a well order, this is\nequivalent to the embedding not being surjective. -/\nstructure PrincipalSeg {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends r ↪r s where\n  /-- The supremum of the principal segment -/\n  top : β\n  /-- The range of the order embedding is the set of elements `b` such that `s b top` -/\n  mem_range_iff_rel' : ∀ b, b ∈ Set.range toRelEmbedding ↔ s b top\n\n-- Porting note: deleted `scoped[InitialSeg]`\n"}
{"name":"PrincipalSeg.mem_range_iff_rel'","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_4\nβ : Type u_5\nr : α → α → Prop\ns : β → β → Prop\nself : PrincipalSeg r s\nb : β\n⊢ Iff (Membership.mem (Set.range ⇑self.toRelEmbedding) b) (s b self.top)","decl":"/-- If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≺i s` is an initial\nsegment embedding whose range is `Set.Iio x` for some element `x`. If `β` is a well order, this is\nequivalent to the embedding not being surjective. -/\nstructure PrincipalSeg {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends r ↪r s where\n  /-- The supremum of the principal segment -/\n  top : β\n  /-- The range of the order embedding is the set of elements `b` such that `s b top` -/\n  mem_range_iff_rel' : ∀ b, b ∈ Set.range toRelEmbedding ↔ s b top\n\n-- Porting note: deleted `scoped[InitialSeg]`\n"}
{"name":"PrincipalSeg.mk.injEq","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_4\nβ : Type u_5\nr : α → α → Prop\ns : β → β → Prop\ntoRelEmbedding✝ : RelEmbedding r s\ntop✝ : β\nmem_range_iff_rel'✝ : ∀ (b : β), Iff (Membership.mem (Set.range ⇑toRelEmbedding✝) b) (s b top✝)\ntoRelEmbedding : RelEmbedding r s\ntop : β\nmem_range_iff_rel' : ∀ (b : β), Iff (Membership.mem (Set.range ⇑toRelEmbedding) b) (s b top)\n⊢ Eq (Eq { toRelEmbedding := toRelEmbedding✝, top := top✝, mem_range_iff_rel' := mem_range_iff_rel'✝ } { toRelEmbedding := toRelEmbedding, top := top, mem_range_iff_rel' := mem_range_iff_rel' }) (And (Eq toRelEmbedding✝ toRelEmbedding) (Eq top✝ top))","decl":"/-- If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≺i s` is an initial\nsegment embedding whose range is `Set.Iio x` for some element `x`. If `β` is a well order, this is\nequivalent to the embedding not being surjective. -/\nstructure PrincipalSeg {α β : Type*} (r : α → α → Prop) (s : β → β → Prop) extends r ↪r s where\n  /-- The supremum of the principal segment -/\n  top : β\n  /-- The range of the order embedding is the set of elements `b` such that `s b top` -/\n  mem_range_iff_rel' : ∀ b, b ∈ Set.range toRelEmbedding ↔ s b top\n\n-- Porting note: deleted `scoped[InitialSeg]`\n"}
{"name":"PrincipalSeg.toRelEmbedding_injective","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsIrrefl β s\ninst✝ : IsTrichotomous β s\n⊢ Function.Injective PrincipalSeg.toRelEmbedding","decl":"theorem toRelEmbedding_injective [IsIrrefl β s] [IsTrichotomous β s] :\n    Function.Injective (@toRelEmbedding α β r s) := by\n  rintro ⟨f, a, hf⟩ ⟨g, b, hg⟩ rfl\n  congr\n  refine extensional_of_trichotomous_of_irrefl s fun x ↦ ?_\n  rw [← hf, hg]\n\n"}
{"name":"PrincipalSeg.toRelEmbedding_inj","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsIrrefl β s\ninst✝ : IsTrichotomous β s\nf g : PrincipalSeg r s\n⊢ Iff (Eq f.toRelEmbedding g.toRelEmbedding) (Eq f g)","decl":"@[simp]\ntheorem toRelEmbedding_inj [IsIrrefl β s] [IsTrichotomous β s] {f g : r ≺i s} :\n    f.toRelEmbedding = g.toRelEmbedding ↔ f = g :=\n  toRelEmbedding_injective.eq_iff\n\n"}
{"name":"PrincipalSeg.ext","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsIrrefl β s\ninst✝ : IsTrichotomous β s\nf g : PrincipalSeg r s\nh : ∀ (x : α), Eq (f.toRelEmbedding x) (g.toRelEmbedding x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext [IsIrrefl β s] [IsTrichotomous β s] {f g : r ≺i s} (h : ∀ x, f x = g x) : f = g := by\n  rw [← toRelEmbedding_inj]\n  ext\n  exact h _\n\n"}
{"name":"PrincipalSeg.ext_iff","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsIrrefl β s\ninst✝ : IsTrichotomous β s\nf g : PrincipalSeg r s\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f.toRelEmbedding x) (g.toRelEmbedding x))","decl":"@[ext]\ntheorem ext [IsIrrefl β s] [IsTrichotomous β s] {f g : r ≺i s} (h : ∀ x, f x = g x) : f = g := by\n  rw [← toRelEmbedding_inj]\n  ext\n  exact h _\n\n"}
{"name":"PrincipalSeg.coe_fn_mk","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : RelEmbedding r s\nt : β\no : ∀ (b : β), Iff (Membership.mem (Set.range ⇑f) b) (s b t)\n⊢ Eq ⇑{ toRelEmbedding := f, top := t, mem_range_iff_rel' := o }.toRelEmbedding ⇑f","decl":"@[simp]\ntheorem coe_fn_mk (f : r ↪r s) (t o) : (@PrincipalSeg.mk _ _ r s f t o : α → β) = f :=\n  rfl\n\n"}
{"name":"PrincipalSeg.mem_range_iff_rel","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : PrincipalSeg r s\nb : β\n⊢ Iff (Membership.mem (Set.range ⇑f.toRelEmbedding) b) (s b f.top)","decl":"theorem mem_range_iff_rel (f : r ≺i s) : ∀ {b : β}, b ∈ Set.range f ↔ s b f.top :=\n  f.mem_range_iff_rel' _\n\n"}
{"name":"PrincipalSeg.down","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : PrincipalSeg r s\nb : β\n⊢ Iff (s b f.top) (Exists fun a => Eq (f.toRelEmbedding a) b)","decl":"@[deprecated mem_range_iff_rel (since := \"2024-10-07\")]\ntheorem down (f : r ≺i s) : ∀ {b : β}, s b f.top ↔ ∃ a, f a = b :=\n  f.mem_range_iff_rel.symm\n\n"}
{"name":"PrincipalSeg.lt_top","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : PrincipalSeg r s\na : α\n⊢ s (f.toRelEmbedding a) f.top","decl":"theorem lt_top (f : r ≺i s) (a : α) : s (f a) f.top :=\n  f.mem_range_iff_rel.1 ⟨_, rfl⟩\n\n"}
{"name":"PrincipalSeg.mem_range_of_rel_top","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : PrincipalSeg r s\nb : β\nh : s b f.top\n⊢ Membership.mem (Set.range ⇑f.toRelEmbedding) b","decl":"theorem mem_range_of_rel_top (f : r ≺i s) {b : β} (h : s b f.top) : b ∈ Set.range f :=\n  f.mem_range_iff_rel.2 h\n\n"}
{"name":"PrincipalSeg.mem_range_of_rel","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsTrans β s\nf : PrincipalSeg r s\na : α\nb : β\nh : s b (f.toRelEmbedding a)\n⊢ Membership.mem (Set.range ⇑f.toRelEmbedding) b","decl":"theorem mem_range_of_rel [IsTrans β s] (f : r ≺i s) {a : α} {b : β} (h : s b (f a)) :\n    b ∈ Set.range f :=\n  f.mem_range_of_rel_top <| _root_.trans h <| f.lt_top _\n\n"}
{"name":"PrincipalSeg.init","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsTrans β s\nf : PrincipalSeg r s\na : α\nb : β\nh : s b (f.toRelEmbedding a)\n⊢ Membership.mem (Set.range ⇑f.toRelEmbedding) b","decl":"@[deprecated mem_range_of_rel (since := \"2024-09-21\")]\nalias init := mem_range_of_rel\n\n"}
{"name":"PrincipalSeg.surjOn","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : PrincipalSeg r s\n⊢ Set.SurjOn (⇑f.toRelEmbedding) Set.univ (setOf fun b => s b f.top)","decl":"theorem surjOn (f : r ≺i s) : Set.SurjOn f Set.univ { b | s b f.top } := by\n  intro b h\n  simpa using mem_range_of_rel_top _ h\n\n"}
{"name":"PrincipalSeg.coe_coe_fn'","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsTrans β s\nf : PrincipalSeg r s\n⊢ Eq ⇑{ toRelEmbedding := f.toRelEmbedding, mem_range_of_rel' := ⋯ } ⇑f.toRelEmbedding","decl":"theorem coe_coe_fn' [IsTrans β s] (f : r ≺i s) : ((f : r ≼i s) : α → β) = f :=\n  rfl\n\n"}
{"name":"InitialSeg.eq_principalSeg","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsWellOrder β s\nf : InitialSeg r s\ng : PrincipalSeg r s\na : α\n⊢ Eq (g.toRelEmbedding a) (f a)","decl":"theorem _root_.InitialSeg.eq_principalSeg [IsWellOrder β s] (f : r ≼i s) (g : r ≺i s) (a : α) :\n    g a = f a :=\n  InitialSeg.eq g f a\n\n"}
{"name":"InitialSeg.ltOrEq_apply_left","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsWellOrder β s\nf : InitialSeg r s\ng : PrincipalSeg r s\na : α\n⊢ Eq (g.toRelEmbedding a) (f a)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias _root_.InitialSeg.ltOrEq_apply_left := InitialSeg.eq_principalSeg\n\n"}
{"name":"PrincipalSeg.exists_eq_iff_rel","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsTrans β s\nf : PrincipalSeg r s\na : α\nb : β\n⊢ Iff (s b (f.toRelEmbedding a)) (Exists fun a' => And (Eq (f.toRelEmbedding a') b) (r a' a))","decl":"theorem exists_eq_iff_rel [IsTrans β s] (f : r ≺i s) {a : α} {b : β} :\n    s b (f a) ↔ ∃ a', f a' = b ∧ r a' a :=\n  @InitialSeg.exists_eq_iff_rel α β r s f a b\n\n"}
{"name":"PrincipalSeg.init_iff","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsTrans β s\nf : PrincipalSeg r s\na : α\nb : β\n⊢ Iff (s b (f.toRelEmbedding a)) (Exists fun a' => And (Eq (f.toRelEmbedding a') b) (r a' a))","decl":"@[deprecated exists_eq_iff_rel (since := \"2024-09-21\")]\nalias init_iff := exists_eq_iff_rel\n\n"}
{"name":"InitialSeg.toPrincipalSeg_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsWellOrder β s\nf : InitialSeg r s\nhf : Not (Function.Surjective ⇑f)\nx : α\n⊢ Eq ((f.toPrincipalSeg hf).toRelEmbedding x) (f x)","decl":"@[simp]\ntheorem _root_.InitialSeg.toPrincipalSeg_apply [IsWellOrder β s] (f : r ≼i s)\n    (hf : ¬ Surjective f) (x : α) : f.toPrincipalSeg hf x = f x :=\n  rfl\n\n"}
{"name":"PrincipalSeg.irrefl","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nf : PrincipalSeg r r\n⊢ False","decl":"theorem irrefl {r : α → α → Prop} [IsWellOrder α r] (f : r ≺i r) : False := by\n  have h := f.lt_top f.top\n  rw [show f f.top = f.top from InitialSeg.eq f (InitialSeg.refl r) f.top] at h\n  exact _root_.irrefl _ h\n\n"}
{"name":"PrincipalSeg.instIsEmptyOfIsWellOrder","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ IsEmpty (PrincipalSeg r r)","decl":"instance (r : α → α → Prop) [IsWellOrder α r] : IsEmpty (r ≺i r) :=\n  ⟨fun f => f.irrefl⟩\n\n"}
{"name":"PrincipalSeg.transInitial_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : PrincipalSeg r s\ng : InitialSeg s t\na : α\n⊢ Eq ((f.transInitial g).toRelEmbedding a) (g (f.toRelEmbedding a))","decl":"@[simp]\ntheorem transInitial_apply (f : r ≺i s) (g : s ≼i t) (a : α) : f.transInitial g a = g (f a) :=\n  rfl\n\n"}
{"name":"PrincipalSeg.transInitial_top","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : PrincipalSeg r s\ng : InitialSeg s t\n⊢ Eq (f.transInitial g).top (g f.top)","decl":"@[simp]\ntheorem transInitial_top (f : r ≺i s) (g : s ≼i t) : (f.transInitial g).top = g f.top :=\n  rfl\n\n"}
{"name":"PrincipalSeg.lt_le_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : PrincipalSeg r s\ng : InitialSeg s t\na : α\n⊢ Eq ((f.ltLe g).toRelEmbedding a) (g (f.toRelEmbedding a))","decl":"set_option linter.deprecated false in\n@[deprecated transInitial_apply (since := \"2024-10-20\")]\ntheorem lt_le_apply (f : r ≺i s) (g : s ≼i t) (a : α) : (f.ltLe g) a = g (f a) :=\n  rfl\n\n"}
{"name":"PrincipalSeg.lt_le_top","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : PrincipalSeg r s\ng : InitialSeg s t\n⊢ Eq (f.ltLe g).top (g f.top)","decl":"set_option linter.deprecated false in\n@[deprecated transInitial_top (since := \"2024-10-20\")]\ntheorem lt_le_top (f : r ≺i s) (g : s ≼i t) : (f.ltLe g).top = g f.top :=\n  rfl\n\n"}
{"name":"PrincipalSeg.trans_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\ninst✝ : IsTrans γ t\nf : PrincipalSeg r s\ng : PrincipalSeg s t\na : α\n⊢ Eq ((f.trans g).toRelEmbedding a) (g.toRelEmbedding (f.toRelEmbedding a))","decl":"@[simp]\ntheorem trans_apply [IsTrans γ t] (f : r ≺i s) (g : s ≺i t) (a : α) : f.trans g a = g (f a) :=\n  rfl\n\n"}
{"name":"PrincipalSeg.trans_top","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\ninst✝ : IsTrans γ t\nf : PrincipalSeg r s\ng : PrincipalSeg s t\n⊢ Eq (f.trans g).top (g.toRelEmbedding f.top)","decl":"@[simp]\ntheorem trans_top [IsTrans γ t] (f : r ≺i s) (g : s ≺i t) : (f.trans g).top = g f.top :=\n  rfl\n\n"}
{"name":"PrincipalSeg.relIsoTrans_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : RelIso r s\ng : PrincipalSeg s t\na : α\n⊢ Eq ((PrincipalSeg.relIsoTrans f g).toRelEmbedding a) (g.toRelEmbedding (f a))","decl":"@[simp]\ntheorem relIsoTrans_apply (f : r ≃r s) (g : s ≺i t) (a : α) : relIsoTrans f g a = g (f a) :=\n  rfl\n\n"}
{"name":"PrincipalSeg.relIsoTrans_top","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : RelIso r s\ng : PrincipalSeg s t\n⊢ Eq (PrincipalSeg.relIsoTrans f g).top g.top","decl":"@[simp]\ntheorem relIsoTrans_top (f : r ≃r s) (g : s ≺i t) : (relIsoTrans f g).top = g.top :=\n  rfl\n\n"}
{"name":"PrincipalSeg.equivLT_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : RelIso r s\ng : PrincipalSeg s t\na : α\n⊢ Eq ((PrincipalSeg.equivLT f g).toRelEmbedding a) (g.toRelEmbedding (f a))","decl":"set_option linter.deprecated false in\n@[deprecated transInitial_top (since := \"2024-10-20\")]\ntheorem equivLT_apply (f : r ≃r s) (g : s ≺i t) (a : α) : (equivLT f g) a = g (f a) :=\n  rfl\n\n"}
{"name":"PrincipalSeg.equivLT_top","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : RelIso r s\ng : PrincipalSeg s t\n⊢ Eq (PrincipalSeg.equivLT f g).top g.top","decl":"set_option linter.deprecated false in\n@[deprecated transInitial_top (since := \"2024-10-20\")]\ntheorem equivLT_top (f : r ≃r s) (g : s ≺i t) : (equivLT f g).top = g.top :=\n  rfl\n\n"}
{"name":"PrincipalSeg.transRelIso_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : PrincipalSeg r s\ng : RelIso s t\na : α\n⊢ Eq ((f.transRelIso g).toRelEmbedding a) (g (f.toRelEmbedding a))","decl":"@[simp]\ntheorem transRelIso_apply (f : r ≺i s) (g : s ≃r t) (a : α) : transRelIso f g a = g (f a) :=\n  rfl\n\n"}
{"name":"PrincipalSeg.transRelIso_top","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\nf : PrincipalSeg r s\ng : RelIso s t\n⊢ Eq (f.transRelIso g).top (g f.top)","decl":"@[simp]\ntheorem transRelIso_top (f : r ≺i s) (g : s ≃r t) : (transRelIso f g).top = g f.top :=\n  rfl\n\n"}
{"name":"PrincipalSeg.instSubsingletonOfIsWellOrder","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsWellOrder β s\n⊢ Subsingleton (PrincipalSeg r s)","decl":"/-- Given a well order `s`, there is a most one principal segment embedding of `r` into `s`. -/\ninstance [IsWellOrder β s] : Subsingleton (r ≺i s) where\n  allEq f g := ext ((f : r ≼i s).eq g)\n\n"}
{"name":"PrincipalSeg.eq","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsWellOrder β s\nf g : PrincipalSeg r s\na : α\n⊢ Eq (f.toRelEmbedding a) (g.toRelEmbedding a)","decl":"protected theorem eq [IsWellOrder β s] (f g : r ≺i s) (a) : f a = g a := by\n  rw [Subsingleton.elim f g]\n\n"}
{"name":"PrincipalSeg.top_eq","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\ninst✝ : IsWellOrder γ t\ne : RelIso r s\nf : PrincipalSeg r t\ng : PrincipalSeg s t\n⊢ Eq f.top g.top","decl":"theorem top_eq [IsWellOrder γ t] (e : r ≃r s) (f : r ≺i t) (g : s ≺i t) : f.top = g.top := by\n  rw [Subsingleton.elim f (PrincipalSeg.relIsoTrans e g)]; rfl\n\n"}
{"name":"PrincipalSeg.top_rel_top","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\ninst✝ : IsWellOrder γ t\nf : PrincipalSeg r s\ng : PrincipalSeg s t\nh : PrincipalSeg r t\n⊢ t h.top g.top","decl":"theorem top_rel_top {r : α → α → Prop} {s : β → β → Prop} {t : γ → γ → Prop} [IsWellOrder γ t]\n    (f : r ≺i s) (g : s ≺i t) (h : r ≺i t) : t h.top g.top := by\n  rw [Subsingleton.elim h (f.trans g)]\n  apply PrincipalSeg.lt_top\n\n"}
{"name":"PrincipalSeg.topLTTop","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\ninst✝ : IsWellOrder γ t\nf : PrincipalSeg r s\ng : PrincipalSeg s t\nh : PrincipalSeg r t\n⊢ t h.top g.top","decl":"@[deprecated top_rel_top (since := \"2024-10-10\")]\nalias topLTTop := top_rel_top\n\n"}
{"name":"PrincipalSeg.ofElement_top","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_4\nr : α → α → Prop\na : α\n⊢ Eq (PrincipalSeg.ofElement r a).top a","decl":"/-- Any element of a well order yields a principal segment. -/\n@[simps!]\ndef ofElement {α : Type*} (r : α → α → Prop) (a : α) : Subrel r (r · a) ≺i r :=\n  ⟨Subrel.relEmbedding _ _, a, fun _ => ⟨fun ⟨⟨_, h⟩, rfl⟩ => h, fun h => ⟨⟨_, h⟩, rfl⟩⟩⟩\n\n"}
{"name":"PrincipalSeg.ofElement_toFun","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_4\nr : α → α → Prop\na : α\nself : Subtype fun x => r x a\n⊢ Eq ((PrincipalSeg.ofElement r a).toFun self) ↑self","decl":"/-- Any element of a well order yields a principal segment. -/\n@[simps!]\ndef ofElement {α : Type*} (r : α → α → Prop) (a : α) : Subrel r (r · a) ≺i r :=\n  ⟨Subrel.relEmbedding _ _, a, fun _ => ⟨fun ⟨⟨_, h⟩, rfl⟩ => h, fun h => ⟨⟨_, h⟩, rfl⟩⟩⟩\n\n"}
{"name":"PrincipalSeg.ofElement_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_4\nr : α → α → Prop\na : α\nb : Subtype fun x => r x a\n⊢ Eq ((PrincipalSeg.ofElement r a).toRelEmbedding b) ↑b","decl":"@[simp]\ntheorem ofElement_apply {α : Type*} (r : α → α → Prop) (a : α) (b) : ofElement r a b = b.1 :=\n  rfl\n\n"}
{"name":"PrincipalSeg.subrelIso_symm_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : PrincipalSeg r s\na✝ : α\n⊢ Eq (f.subrelIso.symm a✝) ((Equiv.setCongr ⋯) ⟨f.toRelEmbedding a✝, ⋯⟩)","decl":"/-- For any principal segment `r ≺i s`, there is a `Subrel` of `s` order isomorphic to `r`. -/\n@[simps! symm_apply]\nnoncomputable def subrelIso (f : r ≺i s) : Subrel s (s · f.top) ≃r r :=\n  RelIso.symm ⟨(Equiv.ofInjective f f.injective).trans\n    (Equiv.setCongr (funext fun _ ↦ propext f.mem_range_iff_rel)), f.map_rel_iff⟩\n\n"}
{"name":"PrincipalSeg.apply_subrelIso","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : PrincipalSeg r s\nb : Subtype fun b => s b f.top\n⊢ Eq (f.toRelEmbedding (f.subrelIso b)) ↑b","decl":"@[simp]\ntheorem apply_subrelIso (f : r ≺i s) (b : {b // s b f.top}) : f (f.subrelIso b) = b :=\n  Equiv.apply_ofInjective_symm f.injective _\n\n"}
{"name":"PrincipalSeg.subrelIso_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : PrincipalSeg r s\na : α\n⊢ Eq (f.subrelIso ⟨f.toRelEmbedding a, ⋯⟩) a","decl":"@[simp]\ntheorem subrelIso_apply (f : r ≺i s) (a : α) : f.subrelIso ⟨f a, f.lt_top a⟩ = a :=\n  Equiv.ofInjective_symm_apply f.injective _\n\n"}
{"name":"PrincipalSeg.codRestrict_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\np : Set β\nf : PrincipalSeg r s\nH : ∀ (a : α), Membership.mem p (f.toRelEmbedding a)\nH₂ : Membership.mem p f.top\na : α\n⊢ Eq ((PrincipalSeg.codRestrict p f H H₂).toRelEmbedding a) ⟨f.toRelEmbedding a, ⋯⟩","decl":"@[simp]\ntheorem codRestrict_apply (p) (f : r ≺i s) (H H₂ a) : codRestrict p f H H₂ a = ⟨f a, H a⟩ :=\n  rfl\n\n"}
{"name":"PrincipalSeg.codRestrict_top","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\np : Set β\nf : PrincipalSeg r s\nH : ∀ (a : α), Membership.mem p (f.toRelEmbedding a)\nH₂ : Membership.mem p f.top\n⊢ Eq (PrincipalSeg.codRestrict p f H H₂).top ⟨f.top, H₂⟩","decl":"@[simp]\ntheorem codRestrict_top (p) (f : r ≺i s) (H H₂) : (codRestrict p f H H₂).top = ⟨f.top, H₂⟩ :=\n  rfl\n\n"}
{"name":"PrincipalSeg.ofIsEmpty_top","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ns : β → β → Prop\nr : α → α → Prop\ninst✝ : IsEmpty α\nb : β\nH : ∀ (b' : β), Not (s b' b)\n⊢ Eq (PrincipalSeg.ofIsEmpty r H).top b","decl":"@[simp]\ntheorem ofIsEmpty_top (r : α → α → Prop) [IsEmpty α] {b : β} (H : ∀ b', ¬s b' b) :\n    (ofIsEmpty r H).top = b :=\n  rfl\n\n"}
{"name":"PrincipalSeg.acc","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsTrans β s\nf : PrincipalSeg r s\na : α\n⊢ Iff (Acc r a) (Acc s (f.toRelEmbedding a))","decl":"protected theorem acc [IsTrans β s] (f : r ≺i s) (a : α) : Acc r a ↔ Acc s (f a) :=\n  (f : r ≼i s).acc a\n\n"}
{"name":"wellFounded_iff_principalSeg","module":"Mathlib.Order.InitialSeg","initialProofState":"β : Type u\ns : β → β → Prop\ninst✝ : IsTrans β s\n⊢ Iff (WellFounded s) (∀ (α : Type u) (r : α → α → Prop), PrincipalSeg r s → WellFounded r)","decl":"theorem wellFounded_iff_principalSeg.{u} {β : Type u} {s : β → β → Prop} [IsTrans β s] :\n    WellFounded s ↔ ∀ (α : Type u) (r : α → α → Prop) (_ : r ≺i s), WellFounded r :=\n  ⟨fun wf _ _ f => RelHomClass.wellFounded f.toRelEmbedding wf, fun h =>\n    wellFounded_iff_wellFounded_subrel.mpr fun b => h _ _ (PrincipalSeg.ofElement s b)⟩\n\n"}
{"name":"InitialSeg.transPrincipal_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\ninst✝¹ : IsWellOrder β s\ninst✝ : IsTrans γ t\nf : InitialSeg r s\ng : PrincipalSeg s t\na : α\n⊢ Eq ((f.transPrincipal g).toRelEmbedding a) (g.toRelEmbedding (f a))","decl":"@[simp]\ntheorem transPrincipal_apply [IsWellOrder β s] [IsTrans γ t] (f : r ≼i s) (g : s ≺i t) (a : α) :\n    f.transPrincipal g a = g (f a) := by\n  rw [InitialSeg.transPrincipal]\n  obtain f' | f' := f.principalSumRelIso\n  · rw [PrincipalSeg.trans_apply, f.eq_principalSeg]\n  · rw [PrincipalSeg.relIsoTrans_apply, f.eq_relIso]\n\n"}
{"name":"InitialSeg.leLT_apply","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\ns : β → β → Prop\nt : γ → γ → Prop\ninst✝¹ : IsWellOrder β s\ninst✝ : IsTrans γ t\nf : InitialSeg r s\ng : PrincipalSeg s t\na : α\n⊢ Eq ((f.leLT g).toRelEmbedding a) (g.toRelEmbedding (f a))","decl":"set_option linter.deprecated false in\n@[deprecated transPrincipal_apply (since := \"2024-10-20\")]\ntheorem leLT_apply [IsWellOrder β s] [IsTrans γ t] (f : r ≼i s) (g : s ≺i t) (a : α) :\n    f.leLT g a = g (f a) :=\n  transPrincipal_apply f g a\n\n"}
{"name":"OrderIso.toInitialSeg_toFun","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\na : α\n⊢ Eq (f.toInitialSeg a) (f a)","decl":"/-- An order isomorphism is an initial segment -/\n@[simps!]\ndef _root_.OrderIso.toInitialSeg [Preorder α] [Preorder β] (f : α ≃o β) : α ≤i β :=\n  f.toRelIsoLT.toInitialSeg\n\n"}
{"name":"InitialSeg.mem_range_of_le","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na : α\nb : β\ninst✝ : Preorder α\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\nh : LE.le b (f a)\n⊢ Membership.mem (Set.range ⇑f) b","decl":"theorem mem_range_of_le [Preorder α] (f : α ≤i β) (h : b ≤ f a) : b ∈ Set.range f := by\n  obtain rfl | hb := h.eq_or_lt\n  exacts [⟨a, rfl⟩, f.mem_range_of_rel hb]\n\n"}
{"name":"InitialSeg.isLowerSet_range","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\ninst✝ : Preorder α\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ IsLowerSet (Set.range ⇑f)","decl":"theorem isLowerSet_range [Preorder α] (f : α ≤i β) : IsLowerSet (Set.range f) := by\n  rintro _ b h ⟨a, rfl⟩\n  exact mem_range_of_le f h\n\n-- TODO: this would follow immediately if we had a `RelEmbeddingClass`\n"}
{"name":"InitialSeg.le_iff_le","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na a' : α\ninst✝ : PartialOrder α\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Iff (LE.le (f a) (f a')) (LE.le a a')","decl":"@[simp]\ntheorem le_iff_le [PartialOrder α] (f : α ≤i β) : f a ≤ f a' ↔ a ≤ a' :=\n  f.toOrderEmbedding.le_iff_le\n\n-- TODO: this would follow immediately if we had a `RelEmbeddingClass`\n"}
{"name":"InitialSeg.lt_iff_lt","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na a' : α\ninst✝ : PartialOrder α\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Iff (LT.lt (f a) (f a')) (LT.lt a a')","decl":"@[simp]\ntheorem lt_iff_lt [PartialOrder α] (f : α ≤i β) : f a < f a' ↔ a < a' :=\n  f.toOrderEmbedding.lt_iff_lt\n\n"}
{"name":"InitialSeg.monotone","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\ninst✝ : PartialOrder α\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Monotone ⇑f","decl":"theorem monotone [PartialOrder α] (f : α ≤i β) : Monotone f :=\n  f.toOrderEmbedding.monotone\n\n"}
{"name":"InitialSeg.strictMono","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\ninst✝ : PartialOrder α\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ StrictMono ⇑f","decl":"theorem strictMono [PartialOrder α] (f : α ≤i β) : StrictMono f :=\n  f.toOrderEmbedding.strictMono\n\n"}
{"name":"InitialSeg.isMin_apply_iff","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na : α\ninst✝ : PartialOrder α\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Iff (IsMin (f a)) (IsMin a)","decl":"@[simp]\ntheorem isMin_apply_iff [PartialOrder α] (f : α ≤i β) : IsMin (f a) ↔ IsMin a := by\n  refine ⟨StrictMono.isMin_of_apply f.strictMono, fun h b hb ↦ ?_⟩\n  obtain ⟨x, rfl⟩ := f.mem_range_of_le hb\n  rw [f.le_iff_le] at hb ⊢\n  exact h hb\n\n"}
{"name":"InitialSeg.map_isMin","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na : α\ninst✝ : PartialOrder α\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\na✝ : IsMin a\n⊢ IsMin (f a)","decl":"alias ⟨_, map_isMin⟩ := isMin_apply_iff\n\n"}
{"name":"InitialSeg.map_bot","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : PartialOrder β\ninst✝² : PartialOrder α\ninst✝¹ : OrderBot α\ninst✝ : OrderBot β\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Eq (f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem map_bot [PartialOrder α] [OrderBot α] [OrderBot β] (f : α ≤i β) : f ⊥ = ⊥ :=\n  (map_isMin f isMin_bot).eq_bot\n\n"}
{"name":"InitialSeg.image_Iio","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\ninst✝ : PartialOrder α\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\na : α\n⊢ Eq (Set.image (⇑f) (Set.Iio a)) (Set.Iio (f a))","decl":"theorem image_Iio [PartialOrder α] (f : α ≤i β) (a : α) : f '' Set.Iio a = Set.Iio (f a) :=\n  f.toOrderEmbedding.image_Iio f.isLowerSet_range a\n\n"}
{"name":"InitialSeg.le_apply_iff","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na : α\nb : β\ninst✝ : LinearOrder α\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Iff (LE.le b (f a)) (Exists fun c => And (LE.le c a) (Eq (f c) b))","decl":"theorem le_apply_iff [LinearOrder α] (f : α ≤i β) : b ≤ f a ↔ ∃ c ≤ a, f c = b := by\n  constructor\n  · intro h\n    obtain ⟨c, hc⟩ := f.mem_range_of_le h\n    refine ⟨c, ?_, hc⟩\n    rwa [← hc, f.le_iff_le] at h\n  · rintro ⟨c, hc, rfl⟩\n    exact f.monotone hc\n\n"}
{"name":"InitialSeg.lt_apply_iff","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na : α\nb : β\ninst✝ : LinearOrder α\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Iff (LT.lt b (f a)) (Exists fun a' => And (LT.lt a' a) (Eq (f a') b))","decl":"theorem lt_apply_iff [LinearOrder α] (f : α ≤i β) : b < f a ↔ ∃ a' < a, f a' = b := by\n  constructor\n  · intro h\n    obtain ⟨c, hc⟩ := f.mem_range_of_rel h\n    refine ⟨c, ?_, hc⟩\n    rwa [← hc, f.lt_iff_lt] at h\n  · rintro ⟨c, hc, rfl⟩\n    exact f.strictMono hc\n\n"}
{"name":"PrincipalSeg.mem_range_of_le","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na : α\nb : β\ninst✝ : Preorder α\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\nh : LE.le b (f.toRelEmbedding a)\n⊢ Membership.mem (Set.range ⇑f.toRelEmbedding) b","decl":"theorem mem_range_of_le [Preorder α] (f : α <i β) (h : b ≤ f a) : b ∈ Set.range f :=\n  (f : α ≤i β).mem_range_of_le h\n\n"}
{"name":"PrincipalSeg.isLowerSet_range","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\ninst✝ : Preorder α\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ IsLowerSet (Set.range ⇑f.toRelEmbedding)","decl":"theorem isLowerSet_range [Preorder α] (f : α <i β) : IsLowerSet (Set.range f) :=\n  (f : α ≤i β).isLowerSet_range\n\n-- TODO: this would follow immediately if we had a `RelEmbeddingClass`\n"}
{"name":"PrincipalSeg.le_iff_le","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na a' : α\ninst✝ : PartialOrder α\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Iff (LE.le (f.toRelEmbedding a) (f.toRelEmbedding a')) (LE.le a a')","decl":"@[simp]\ntheorem le_iff_le [PartialOrder α] (f : α <i β) : f a ≤ f a' ↔ a ≤ a' :=\n  (f : α ≤i β).le_iff_le\n\n-- TODO: this would follow immediately if we had a `RelEmbeddingClass`\n"}
{"name":"PrincipalSeg.lt_iff_lt","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na a' : α\ninst✝ : PartialOrder α\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Iff (LT.lt (f.toRelEmbedding a) (f.toRelEmbedding a')) (LT.lt a a')","decl":"@[simp]\ntheorem lt_iff_lt [PartialOrder α] (f : α <i β) : f a < f a' ↔ a < a' :=\n  (f : α ≤i β).lt_iff_lt\n\n"}
{"name":"PrincipalSeg.monotone","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\ninst✝ : PartialOrder α\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Monotone ⇑f.toRelEmbedding","decl":"theorem monotone [PartialOrder α] (f : α <i β) : Monotone f :=\n  (f : α ≤i β).monotone\n\n"}
{"name":"PrincipalSeg.strictMono","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\ninst✝ : PartialOrder α\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ StrictMono ⇑f.toRelEmbedding","decl":"theorem strictMono [PartialOrder α] (f : α <i β) : StrictMono f :=\n  (f : α ≤i β).strictMono\n\n"}
{"name":"PrincipalSeg.isMin_apply_iff","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na : α\ninst✝ : PartialOrder α\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Iff (IsMin (f.toRelEmbedding a)) (IsMin a)","decl":"@[simp]\ntheorem isMin_apply_iff [PartialOrder α] (f : α <i β) : IsMin (f a) ↔ IsMin a :=\n  (f : α ≤i β).isMin_apply_iff\n\n"}
{"name":"PrincipalSeg.map_isMin","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na : α\ninst✝ : PartialOrder α\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\na✝ : IsMin a\n⊢ IsMin (f.toRelEmbedding a)","decl":"alias ⟨_, map_isMin⟩ := isMin_apply_iff\n\n"}
{"name":"PrincipalSeg.map_bot","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : PartialOrder β\ninst✝² : PartialOrder α\ninst✝¹ : OrderBot α\ninst✝ : OrderBot β\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Eq (f.toRelEmbedding Bot.bot) Bot.bot","decl":"@[simp]\ntheorem map_bot [PartialOrder α] [OrderBot α] [OrderBot β] (f : α <i β) : f ⊥ = ⊥ :=\n  (f : α ≤i β).map_bot\n\n"}
{"name":"PrincipalSeg.image_Iio","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\ninst✝ : PartialOrder α\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\na : α\n⊢ Eq (Set.image (⇑f.toRelEmbedding) (Set.Iio a)) (Set.Iio (f.toRelEmbedding a))","decl":"theorem image_Iio [PartialOrder α] (f : α <i β) (a : α) : f '' Set.Iio a = Set.Iio (f a) :=\n  (f : α ≤i β).image_Iio a\n\n"}
{"name":"PrincipalSeg.le_apply_iff","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na : α\nb : β\ninst✝ : LinearOrder α\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Iff (LE.le b (f.toRelEmbedding a)) (Exists fun c => And (LE.le c a) (Eq (f.toRelEmbedding c) b))","decl":"theorem le_apply_iff [LinearOrder α] (f : α <i β) : b ≤ f a ↔ ∃ c ≤ a, f c = b :=\n  (f : α ≤i β).le_apply_iff\n\n"}
{"name":"PrincipalSeg.lt_apply_iff","module":"Mathlib.Order.InitialSeg","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder β\na : α\nb : β\ninst✝ : LinearOrder α\nf : PrincipalSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\n⊢ Iff (LT.lt b (f.toRelEmbedding a)) (Exists fun a' => And (LT.lt a' a) (Eq (f.toRelEmbedding a') b))","decl":"theorem lt_apply_iff [LinearOrder α] (f : α <i β) : b < f a ↔ ∃ a' < a, f a' = b :=\n  (f : α ≤i β).lt_apply_iff\n\n"}
