{"name":"CategoryTheory.ShortComplex.instPreservesHomologyModuleCatAbForget₂","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ (CategoryTheory.forget₂ (ModuleCat R) Ab).PreservesHomology","decl":"noncomputable instance : (forget₂ (ModuleCat.{v} R) Ab).PreservesHomology where\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMk_X₃_carrier","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nX₁ X₂ X₃ : Type v\ninst✝⁵ : AddCommGroup X₁\ninst✝⁴ : AddCommGroup X₂\ninst✝³ : AddCommGroup X₃\ninst✝² : Module R X₁\ninst✝¹ : Module R X₂\ninst✝ : Module R X₃\nf : LinearMap (RingHom.id R) X₁ X₂\ng : LinearMap (RingHom.id R) X₂ X₃\nhfg : Eq (g.comp f) 0\n⊢ Eq (↑(CategoryTheory.ShortComplex.moduleCatMk f g hfg).X₃) X₃","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nlinear maps `f` and `g` and the vanishing of their composition. -/\n@[simps]\ndef moduleCatMk {X₁ X₂ X₃ : Type v} [AddCommGroup X₁] [AddCommGroup X₂] [AddCommGroup X₃]\n    [Module R X₁] [Module R X₂] [Module R X₃] (f : X₁ →ₗ[R] X₂) (g : X₂ →ₗ[R] X₃)\n    (hfg : g.comp f = 0) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk (ModuleCat.ofHom f) (ModuleCat.ofHom g) (ModuleCat.hom_ext hfg)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMk_X₂_carrier","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nX₁ X₂ X₃ : Type v\ninst✝⁵ : AddCommGroup X₁\ninst✝⁴ : AddCommGroup X₂\ninst✝³ : AddCommGroup X₃\ninst✝² : Module R X₁\ninst✝¹ : Module R X₂\ninst✝ : Module R X₃\nf : LinearMap (RingHom.id R) X₁ X₂\ng : LinearMap (RingHom.id R) X₂ X₃\nhfg : Eq (g.comp f) 0\n⊢ Eq (↑(CategoryTheory.ShortComplex.moduleCatMk f g hfg).X₂) X₂","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nlinear maps `f` and `g` and the vanishing of their composition. -/\n@[simps]\ndef moduleCatMk {X₁ X₂ X₃ : Type v} [AddCommGroup X₁] [AddCommGroup X₂] [AddCommGroup X₃]\n    [Module R X₁] [Module R X₂] [Module R X₃] (f : X₁ →ₗ[R] X₂) (g : X₂ →ₗ[R] X₃)\n    (hfg : g.comp f = 0) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk (ModuleCat.ofHom f) (ModuleCat.ofHom g) (ModuleCat.hom_ext hfg)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMk_X₁_carrier","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nX₁ X₂ X₃ : Type v\ninst✝⁵ : AddCommGroup X₁\ninst✝⁴ : AddCommGroup X₂\ninst✝³ : AddCommGroup X₃\ninst✝² : Module R X₁\ninst✝¹ : Module R X₂\ninst✝ : Module R X₃\nf : LinearMap (RingHom.id R) X₁ X₂\ng : LinearMap (RingHom.id R) X₂ X₃\nhfg : Eq (g.comp f) 0\n⊢ Eq (↑(CategoryTheory.ShortComplex.moduleCatMk f g hfg).X₁) X₁","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nlinear maps `f` and `g` and the vanishing of their composition. -/\n@[simps]\ndef moduleCatMk {X₁ X₂ X₃ : Type v} [AddCommGroup X₁] [AddCommGroup X₂] [AddCommGroup X₃]\n    [Module R X₁] [Module R X₂] [Module R X₃] (f : X₁ →ₗ[R] X₂) (g : X₂ →ₗ[R] X₃)\n    (hfg : g.comp f = 0) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk (ModuleCat.ofHom f) (ModuleCat.ofHom g) (ModuleCat.hom_ext hfg)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMk_X₂_isAddCommGroup","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nX₁ X₂ X₃ : Type v\ninst✝⁵ : AddCommGroup X₁\ninst✝⁴ : AddCommGroup X₂\ninst✝³ : AddCommGroup X₃\ninst✝² : Module R X₁\ninst✝¹ : Module R X₂\ninst✝ : Module R X₃\nf : LinearMap (RingHom.id R) X₁ X₂\ng : LinearMap (RingHom.id R) X₂ X₃\nhfg : Eq (g.comp f) 0\n⊢ Eq (CategoryTheory.ShortComplex.moduleCatMk f g hfg).X₂.isAddCommGroup inst✝⁴","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nlinear maps `f` and `g` and the vanishing of their composition. -/\n@[simps]\ndef moduleCatMk {X₁ X₂ X₃ : Type v} [AddCommGroup X₁] [AddCommGroup X₂] [AddCommGroup X₃]\n    [Module R X₁] [Module R X₂] [Module R X₃] (f : X₁ →ₗ[R] X₂) (g : X₂ →ₗ[R] X₃)\n    (hfg : g.comp f = 0) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk (ModuleCat.ofHom f) (ModuleCat.ofHom g) (ModuleCat.hom_ext hfg)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMk_X₃_isAddCommGroup","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nX₁ X₂ X₃ : Type v\ninst✝⁵ : AddCommGroup X₁\ninst✝⁴ : AddCommGroup X₂\ninst✝³ : AddCommGroup X₃\ninst✝² : Module R X₁\ninst✝¹ : Module R X₂\ninst✝ : Module R X₃\nf : LinearMap (RingHom.id R) X₁ X₂\ng : LinearMap (RingHom.id R) X₂ X₃\nhfg : Eq (g.comp f) 0\n⊢ Eq (CategoryTheory.ShortComplex.moduleCatMk f g hfg).X₃.isAddCommGroup inst✝³","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nlinear maps `f` and `g` and the vanishing of their composition. -/\n@[simps]\ndef moduleCatMk {X₁ X₂ X₃ : Type v} [AddCommGroup X₁] [AddCommGroup X₂] [AddCommGroup X₃]\n    [Module R X₁] [Module R X₂] [Module R X₃] (f : X₁ →ₗ[R] X₂) (g : X₂ →ₗ[R] X₃)\n    (hfg : g.comp f = 0) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk (ModuleCat.ofHom f) (ModuleCat.ofHom g) (ModuleCat.hom_ext hfg)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMk_X₁_isAddCommGroup","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nX₁ X₂ X₃ : Type v\ninst✝⁵ : AddCommGroup X₁\ninst✝⁴ : AddCommGroup X₂\ninst✝³ : AddCommGroup X₃\ninst✝² : Module R X₁\ninst✝¹ : Module R X₂\ninst✝ : Module R X₃\nf : LinearMap (RingHom.id R) X₁ X₂\ng : LinearMap (RingHom.id R) X₂ X₃\nhfg : Eq (g.comp f) 0\n⊢ Eq (CategoryTheory.ShortComplex.moduleCatMk f g hfg).X₁.isAddCommGroup inst✝⁵","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nlinear maps `f` and `g` and the vanishing of their composition. -/\n@[simps]\ndef moduleCatMk {X₁ X₂ X₃ : Type v} [AddCommGroup X₁] [AddCommGroup X₂] [AddCommGroup X₃]\n    [Module R X₁] [Module R X₂] [Module R X₃] (f : X₁ →ₗ[R] X₂) (g : X₂ →ₗ[R] X₃)\n    (hfg : g.comp f = 0) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk (ModuleCat.ofHom f) (ModuleCat.ofHom g) (ModuleCat.hom_ext hfg)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMk_X₁_isModule","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nX₁ X₂ X₃ : Type v\ninst✝⁵ : AddCommGroup X₁\ninst✝⁴ : AddCommGroup X₂\ninst✝³ : AddCommGroup X₃\ninst✝² : Module R X₁\ninst✝¹ : Module R X₂\ninst✝ : Module R X₃\nf : LinearMap (RingHom.id R) X₁ X₂\ng : LinearMap (RingHom.id R) X₂ X₃\nhfg : Eq (g.comp f) 0\n⊢ Eq (CategoryTheory.ShortComplex.moduleCatMk f g hfg).X₁.isModule inst✝²","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nlinear maps `f` and `g` and the vanishing of their composition. -/\n@[simps]\ndef moduleCatMk {X₁ X₂ X₃ : Type v} [AddCommGroup X₁] [AddCommGroup X₂] [AddCommGroup X₃]\n    [Module R X₁] [Module R X₂] [Module R X₃] (f : X₁ →ₗ[R] X₂) (g : X₂ →ₗ[R] X₃)\n    (hfg : g.comp f = 0) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk (ModuleCat.ofHom f) (ModuleCat.ofHom g) (ModuleCat.hom_ext hfg)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMk_X₃_isModule","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nX₁ X₂ X₃ : Type v\ninst✝⁵ : AddCommGroup X₁\ninst✝⁴ : AddCommGroup X₂\ninst✝³ : AddCommGroup X₃\ninst✝² : Module R X₁\ninst✝¹ : Module R X₂\ninst✝ : Module R X₃\nf : LinearMap (RingHom.id R) X₁ X₂\ng : LinearMap (RingHom.id R) X₂ X₃\nhfg : Eq (g.comp f) 0\n⊢ Eq (CategoryTheory.ShortComplex.moduleCatMk f g hfg).X₃.isModule inst✝","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nlinear maps `f` and `g` and the vanishing of their composition. -/\n@[simps]\ndef moduleCatMk {X₁ X₂ X₃ : Type v} [AddCommGroup X₁] [AddCommGroup X₂] [AddCommGroup X₃]\n    [Module R X₁] [Module R X₂] [Module R X₃] (f : X₁ →ₗ[R] X₂) (g : X₂ →ₗ[R] X₃)\n    (hfg : g.comp f = 0) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk (ModuleCat.ofHom f) (ModuleCat.ofHom g) (ModuleCat.hom_ext hfg)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMk_g","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nX₁ X₂ X₃ : Type v\ninst✝⁵ : AddCommGroup X₁\ninst✝⁴ : AddCommGroup X₂\ninst✝³ : AddCommGroup X₃\ninst✝² : Module R X₁\ninst✝¹ : Module R X₂\ninst✝ : Module R X₃\nf : LinearMap (RingHom.id R) X₁ X₂\ng : LinearMap (RingHom.id R) X₂ X₃\nhfg : Eq (g.comp f) 0\n⊢ Eq (CategoryTheory.ShortComplex.moduleCatMk f g hfg).g (ModuleCat.ofHom g)","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nlinear maps `f` and `g` and the vanishing of their composition. -/\n@[simps]\ndef moduleCatMk {X₁ X₂ X₃ : Type v} [AddCommGroup X₁] [AddCommGroup X₂] [AddCommGroup X₃]\n    [Module R X₁] [Module R X₂] [Module R X₃] (f : X₁ →ₗ[R] X₂) (g : X₂ →ₗ[R] X₃)\n    (hfg : g.comp f = 0) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk (ModuleCat.ofHom f) (ModuleCat.ofHom g) (ModuleCat.hom_ext hfg)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMk_f","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nX₁ X₂ X₃ : Type v\ninst✝⁵ : AddCommGroup X₁\ninst✝⁴ : AddCommGroup X₂\ninst✝³ : AddCommGroup X₃\ninst✝² : Module R X₁\ninst✝¹ : Module R X₂\ninst✝ : Module R X₃\nf : LinearMap (RingHom.id R) X₁ X₂\ng : LinearMap (RingHom.id R) X₂ X₃\nhfg : Eq (g.comp f) 0\n⊢ Eq (CategoryTheory.ShortComplex.moduleCatMk f g hfg).f (ModuleCat.ofHom f)","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nlinear maps `f` and `g` and the vanishing of their composition. -/\n@[simps]\ndef moduleCatMk {X₁ X₂ X₃ : Type v} [AddCommGroup X₁] [AddCommGroup X₂] [AddCommGroup X₃]\n    [Module R X₁] [Module R X₂] [Module R X₃] (f : X₁ →ₗ[R] X₂) (g : X₂ →ₗ[R] X₃)\n    (hfg : g.comp f = 0) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk (ModuleCat.ofHom f) (ModuleCat.ofHom g) (ModuleCat.hom_ext hfg)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMk_X₂_isModule","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nX₁ X₂ X₃ : Type v\ninst✝⁵ : AddCommGroup X₁\ninst✝⁴ : AddCommGroup X₂\ninst✝³ : AddCommGroup X₃\ninst✝² : Module R X₁\ninst✝¹ : Module R X₂\ninst✝ : Module R X₃\nf : LinearMap (RingHom.id R) X₁ X₂\ng : LinearMap (RingHom.id R) X₂ X₃\nhfg : Eq (g.comp f) 0\n⊢ Eq (CategoryTheory.ShortComplex.moduleCatMk f g hfg).X₂.isModule inst✝¹","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nlinear maps `f` and `g` and the vanishing of their composition. -/\n@[simps]\ndef moduleCatMk {X₁ X₂ X₃ : Type v} [AddCommGroup X₁] [AddCommGroup X₂] [AddCommGroup X₃]\n    [Module R X₁] [Module R X₂] [Module R X₃] (f : X₁ →ₗ[R] X₂) (g : X₂ →ₗ[R] X₃)\n    (hfg : g.comp f = 0) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk (ModuleCat.ofHom f) (ModuleCat.ofHom g) (ModuleCat.hom_ext hfg)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCat_zero_apply","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nx : ↑S.X₁\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom S.g) ((CategoryTheory.ConcreteCategory.hom S.f) x)) 0","decl":"@[simp]\nlemma moduleCat_zero_apply (x : S.X₁) : S.g (S.f x) = 0 :=\n  S.zero_apply x\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCat_exact_iff","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Iff S.Exact (∀ (x₂ : ↑S.X₂), Eq ((CategoryTheory.ConcreteCategory.hom S.g) x₂) 0 → Exists fun x₁ => Eq ((CategoryTheory.ConcreteCategory.hom S.f) x₁) x₂)","decl":"lemma moduleCat_exact_iff :\n    S.Exact ↔ ∀ (x₂ : S.X₂) (_ : S.g x₂ = 0), ∃ (x₁ : S.X₁), S.f x₁ = x₂ :=\n  S.exact_iff_of_hasForget\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCat_exact_iff_ker_sub_range","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Iff S.Exact (LE.le (LinearMap.ker (ModuleCat.Hom.hom S.g)) (LinearMap.range (ModuleCat.Hom.hom S.f)))","decl":"lemma moduleCat_exact_iff_ker_sub_range :\n    S.Exact ↔ LinearMap.ker S.g.hom ≤ LinearMap.range S.f.hom := by\n  rw [moduleCat_exact_iff]\n  aesop\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCat_exact_iff_range_eq_ker","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Iff S.Exact (Eq (LinearMap.range (ModuleCat.Hom.hom S.f)) (LinearMap.ker (ModuleCat.Hom.hom S.g)))","decl":"lemma moduleCat_exact_iff_range_eq_ker :\n    S.Exact ↔ LinearMap.range S.f.hom = LinearMap.ker S.g.hom := by\n  rw [moduleCat_exact_iff_ker_sub_range]\n  aesop\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.moduleCat_range_eq_ker","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nhS : S.Exact\n⊢ Eq (LinearMap.range (ModuleCat.Hom.hom S.f)) (LinearMap.ker (ModuleCat.Hom.hom S.g))","decl":"lemma Exact.moduleCat_range_eq_ker (hS : S.Exact) :\n    LinearMap.range S.f.hom = LinearMap.ker S.g.hom := by\n  simpa only [moduleCat_exact_iff_range_eq_ker] using hS\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.moduleCat_injective_f","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nhS : S.ShortExact\n⊢ Function.Injective ⇑(CategoryTheory.ConcreteCategory.hom S.f)","decl":"lemma ShortExact.moduleCat_injective_f (hS : S.ShortExact) :\n    Function.Injective S.f :=\n  hS.injective_f\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.moduleCat_surjective_g","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nhS : S.ShortExact\n⊢ Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom S.g)","decl":"lemma ShortExact.moduleCat_surjective_g (hS : S.ShortExact) :\n    Function.Surjective S.g :=\n  hS.surjective_g\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.moduleCat_exact_iff_function_exact","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Iff S.Exact (Function.Exact ⇑(CategoryTheory.ConcreteCategory.hom S.f) ⇑(CategoryTheory.ConcreteCategory.hom S.g))","decl":"lemma ShortExact.moduleCat_exact_iff_function_exact :\n    S.Exact ↔ Function.Exact S.f S.g := by\n  rw [moduleCat_exact_iff_range_eq_ker, LinearMap.exact_iff]\n  tauto\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMkOfKerLERange_f","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nX₁ X₂ X₃ : ModuleCat R\nf : Quiver.Hom X₁ X₂\ng : Quiver.Hom X₂ X₃\nhfg : LE.le (LinearMap.range (ModuleCat.Hom.hom f)) (LinearMap.ker (ModuleCat.Hom.hom g))\n⊢ Eq (CategoryTheory.ShortComplex.moduleCatMkOfKerLERange f g hfg).f f","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nmorphisms `f` and `g` and the assumption `LinearMap.range f ≤ LinearMap.ker g`. -/\n@[simps]\ndef moduleCatMkOfKerLERange {X₁ X₂ X₃ : ModuleCat.{v} R} (f : X₁ ⟶ X₂) (g : X₂ ⟶ X₃)\n    (hfg : LinearMap.range f.hom ≤ LinearMap.ker g.hom) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk f g (by aesop)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMkOfKerLERange_g","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nX₁ X₂ X₃ : ModuleCat R\nf : Quiver.Hom X₁ X₂\ng : Quiver.Hom X₂ X₃\nhfg : LE.le (LinearMap.range (ModuleCat.Hom.hom f)) (LinearMap.ker (ModuleCat.Hom.hom g))\n⊢ Eq (CategoryTheory.ShortComplex.moduleCatMkOfKerLERange f g hfg).g g","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nmorphisms `f` and `g` and the assumption `LinearMap.range f ≤ LinearMap.ker g`. -/\n@[simps]\ndef moduleCatMkOfKerLERange {X₁ X₂ X₃ : ModuleCat.{v} R} (f : X₁ ⟶ X₂) (g : X₂ ⟶ X₃)\n    (hfg : LinearMap.range f.hom ≤ LinearMap.ker g.hom) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk f g (by aesop)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMkOfKerLERange_X₃","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nX₁ X₂ X₃ : ModuleCat R\nf : Quiver.Hom X₁ X₂\ng : Quiver.Hom X₂ X₃\nhfg : LE.le (LinearMap.range (ModuleCat.Hom.hom f)) (LinearMap.ker (ModuleCat.Hom.hom g))\n⊢ Eq (CategoryTheory.ShortComplex.moduleCatMkOfKerLERange f g hfg).X₃ X₃","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nmorphisms `f` and `g` and the assumption `LinearMap.range f ≤ LinearMap.ker g`. -/\n@[simps]\ndef moduleCatMkOfKerLERange {X₁ X₂ X₃ : ModuleCat.{v} R} (f : X₁ ⟶ X₂) (g : X₂ ⟶ X₃)\n    (hfg : LinearMap.range f.hom ≤ LinearMap.ker g.hom) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk f g (by aesop)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMkOfKerLERange_X₁","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nX₁ X₂ X₃ : ModuleCat R\nf : Quiver.Hom X₁ X₂\ng : Quiver.Hom X₂ X₃\nhfg : LE.le (LinearMap.range (ModuleCat.Hom.hom f)) (LinearMap.ker (ModuleCat.Hom.hom g))\n⊢ Eq (CategoryTheory.ShortComplex.moduleCatMkOfKerLERange f g hfg).X₁ X₁","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nmorphisms `f` and `g` and the assumption `LinearMap.range f ≤ LinearMap.ker g`. -/\n@[simps]\ndef moduleCatMkOfKerLERange {X₁ X₂ X₃ : ModuleCat.{v} R} (f : X₁ ⟶ X₂) (g : X₂ ⟶ X₃)\n    (hfg : LinearMap.range f.hom ≤ LinearMap.ker g.hom) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk f g (by aesop)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatMkOfKerLERange_X₂","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nX₁ X₂ X₃ : ModuleCat R\nf : Quiver.Hom X₁ X₂\ng : Quiver.Hom X₂ X₃\nhfg : LE.le (LinearMap.range (ModuleCat.Hom.hom f)) (LinearMap.ker (ModuleCat.Hom.hom g))\n⊢ Eq (CategoryTheory.ShortComplex.moduleCatMkOfKerLERange f g hfg).X₂ X₂","decl":"/-- Constructor for short complexes in `ModuleCat.{v} R` taking as inputs\nmorphisms `f` and `g` and the assumption `LinearMap.range f ≤ LinearMap.ker g`. -/\n@[simps]\ndef moduleCatMkOfKerLERange {X₁ X₂ X₃ : ModuleCat.{v} R} (f : X₁ ⟶ X₂) (g : X₂ ⟶ X₃)\n    (hfg : LinearMap.range f.hom ≤ LinearMap.ker g.hom) : ShortComplex (ModuleCat.{v} R) :=\n  ShortComplex.mk f g (by aesop)\n\n"}
{"name":"CategoryTheory.ShortComplex.Exact.moduleCat_of_range_eq_ker","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nX₁ X₂ X₃ : ModuleCat R\nf : Quiver.Hom X₁ X₂\ng : Quiver.Hom X₂ X₃\nhfg : Eq (LinearMap.range (ModuleCat.Hom.hom f)) (LinearMap.ker (ModuleCat.Hom.hom g))\n⊢ (CategoryTheory.ShortComplex.moduleCatMkOfKerLERange f g ⋯).Exact","decl":"lemma Exact.moduleCat_of_range_eq_ker {X₁ X₂ X₃ : ModuleCat.{v} R}\n    (f : X₁ ⟶ X₂) (g : X₂ ⟶ X₃) (hfg : LinearMap.range f.hom = LinearMap.ker g.hom) :\n    (moduleCatMkOfKerLERange f g (by rw [hfg])).Exact := by\n  simpa only [moduleCat_exact_iff_range_eq_ker] using hfg\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatToCycles_apply_coe","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nx : ↑S.X₁\n⊢ Eq (↑(S.moduleCatToCycles x)) ((CategoryTheory.ConcreteCategory.hom S.f) x)","decl":"/-- The canonical linear map `S.X₁ →ₗ[R] LinearMap.ker S.g` induced by `S.f`. -/\n@[simps]\ndef moduleCatToCycles : S.X₁ →ₗ[R] LinearMap.ker S.g.hom where\n  toFun x := ⟨S.f x, S.moduleCat_zero_apply x⟩\n  map_add' x y := by aesop\n  map_smul' a x := by aesop\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatLeftHomologyData_i","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Eq S.moduleCatLeftHomologyData.i (ModuleCat.ofHom (LinearMap.ker (ModuleCat.Hom.hom S.g)).subtype)","decl":"/-- The explicit left homology data of a short complex of modules that is\ngiven by a kernel and a quotient given by the `LinearMap` API. -/\n@[simps K H i π]\ndef moduleCatLeftHomologyData : S.LeftHomologyData where\n  K := ModuleCat.of R (LinearMap.ker S.g.hom)\n  H := S.moduleCatHomology\n  i := ModuleCat.ofHom (LinearMap.ker S.g.hom).subtype\n  π := S.moduleCatHomologyπ\n  wi := by aesop\n  hi := ModuleCat.kernelIsLimit _\n  wπ := by aesop\n  hπ := ModuleCat.cokernelIsColimit (ModuleCat.ofHom S.moduleCatToCycles)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatLeftHomologyData_H","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Eq S.moduleCatLeftHomologyData.H S.moduleCatHomology","decl":"/-- The explicit left homology data of a short complex of modules that is\ngiven by a kernel and a quotient given by the `LinearMap` API. -/\n@[simps K H i π]\ndef moduleCatLeftHomologyData : S.LeftHomologyData where\n  K := ModuleCat.of R (LinearMap.ker S.g.hom)\n  H := S.moduleCatHomology\n  i := ModuleCat.ofHom (LinearMap.ker S.g.hom).subtype\n  π := S.moduleCatHomologyπ\n  wi := by aesop\n  hi := ModuleCat.kernelIsLimit _\n  wπ := by aesop\n  hπ := ModuleCat.cokernelIsColimit (ModuleCat.ofHom S.moduleCatToCycles)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatLeftHomologyData_K","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Eq S.moduleCatLeftHomologyData.K (ModuleCat.of R (Subtype fun x => Membership.mem (LinearMap.ker (ModuleCat.Hom.hom S.g)) x))","decl":"/-- The explicit left homology data of a short complex of modules that is\ngiven by a kernel and a quotient given by the `LinearMap` API. -/\n@[simps K H i π]\ndef moduleCatLeftHomologyData : S.LeftHomologyData where\n  K := ModuleCat.of R (LinearMap.ker S.g.hom)\n  H := S.moduleCatHomology\n  i := ModuleCat.ofHom (LinearMap.ker S.g.hom).subtype\n  π := S.moduleCatHomologyπ\n  wi := by aesop\n  hi := ModuleCat.kernelIsLimit _\n  wπ := by aesop\n  hπ := ModuleCat.cokernelIsColimit (ModuleCat.ofHom S.moduleCatToCycles)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatLeftHomologyData_π","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Eq S.moduleCatLeftHomologyData.π S.moduleCatHomologyπ","decl":"/-- The explicit left homology data of a short complex of modules that is\ngiven by a kernel and a quotient given by the `LinearMap` API. -/\n@[simps K H i π]\ndef moduleCatLeftHomologyData : S.LeftHomologyData where\n  K := ModuleCat.of R (LinearMap.ker S.g.hom)\n  H := S.moduleCatHomology\n  i := ModuleCat.ofHom (LinearMap.ker S.g.hom).subtype\n  π := S.moduleCatHomologyπ\n  wi := by aesop\n  hi := ModuleCat.kernelIsLimit _\n  wπ := by aesop\n  hπ := ModuleCat.cokernelIsColimit (ModuleCat.ofHom S.moduleCatToCycles)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatLeftHomologyData_f'","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Eq S.moduleCatLeftHomologyData.f' (ModuleCat.ofHom S.moduleCatToCycles)","decl":"@[simp]\nlemma moduleCatLeftHomologyData_f' :\n    S.moduleCatLeftHomologyData.f' = ModuleCat.ofHom S.moduleCatToCycles := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.instEpiModuleCatModuleCatHomologyπ","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ CategoryTheory.Epi S.moduleCatHomologyπ","decl":"instance : Epi S.moduleCatHomologyπ :=\n  (inferInstance : Epi S.moduleCatLeftHomologyData.π)\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatCyclesIso_hom_subtype","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.moduleCatCyclesIso.hom (ModuleCat.ofHom (LinearMap.ker (ModuleCat.Hom.hom S.g)).subtype)) S.iCycles","decl":"@[reassoc (attr := simp, elementwise)]\nlemma moduleCatCyclesIso_hom_subtype :\n    S.moduleCatCyclesIso.hom ≫ ModuleCat.ofHom (LinearMap.ker S.g.hom).subtype = S.iCycles :=\n  S.moduleCatLeftHomologyData.cyclesIso_hom_comp_i\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatCyclesIso_hom_subtype_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nZ : ModuleCat R\nh : Quiver.Hom (ModuleCat.of R ↑S.X₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.moduleCatCyclesIso.hom (CategoryTheory.CategoryStruct.comp (ModuleCat.ofHom (LinearMap.ker (ModuleCat.Hom.hom S.g)).subtype) h)) (CategoryTheory.CategoryStruct.comp S.iCycles h)","decl":"@[reassoc (attr := simp, elementwise)]\nlemma moduleCatCyclesIso_hom_subtype :\n    S.moduleCatCyclesIso.hom ≫ ModuleCat.ofHom (LinearMap.ker S.g.hom).subtype = S.iCycles :=\n  S.moduleCatLeftHomologyData.cyclesIso_hom_comp_i\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatCyclesIso_hom_subtype_apply","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nx : CategoryTheory.ToType S.cycles\n⊢ Eq (↑((CategoryTheory.ConcreteCategory.hom S.moduleCatCyclesIso.hom) x)) ((CategoryTheory.ConcreteCategory.hom S.iCycles) x)","decl":"@[reassoc (attr := simp, elementwise)]\nlemma moduleCatCyclesIso_hom_subtype :\n    S.moduleCatCyclesIso.hom ≫ ModuleCat.ofHom (LinearMap.ker S.g.hom).subtype = S.iCycles :=\n  S.moduleCatLeftHomologyData.cyclesIso_hom_comp_i\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatCyclesIso_hom_subtype_assoc_apply","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nZ : ModuleCat R\nh : Quiver.Hom (ModuleCat.of R ↑S.X₂) Z\nx : CategoryTheory.ToType S.cycles\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom h) ↑((CategoryTheory.ConcreteCategory.hom S.moduleCatCyclesIso.hom) x)) ((CategoryTheory.ConcreteCategory.hom h) ((CategoryTheory.ConcreteCategory.hom S.iCycles) x))","decl":"@[reassoc (attr := simp, elementwise)]\nlemma moduleCatCyclesIso_hom_subtype :\n    S.moduleCatCyclesIso.hom ≫ ModuleCat.ofHom (LinearMap.ker S.g.hom).subtype = S.iCycles :=\n  S.moduleCatLeftHomologyData.cyclesIso_hom_comp_i\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatCyclesIso_inv_iCycles_assoc_apply","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nZ : ModuleCat R\nh : Quiver.Hom S.X₂ Z\nx : CategoryTheory.ToType (ModuleCat.of R (Subtype fun x => Membership.mem (LinearMap.ker (ModuleCat.Hom.hom S.g)) x))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom h) ((CategoryTheory.ConcreteCategory.hom S.iCycles) ((CategoryTheory.ConcreteCategory.hom S.moduleCatCyclesIso.inv) x))) ((CategoryTheory.ConcreteCategory.hom h) ↑x)","decl":"@[reassoc (attr := simp, elementwise)]\nlemma moduleCatCyclesIso_inv_iCycles :\n    S.moduleCatCyclesIso.inv ≫ S.iCycles = ModuleCat.ofHom (LinearMap.ker S.g.hom).subtype :=\n  S.moduleCatLeftHomologyData.cyclesIso_inv_comp_iCycles\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatCyclesIso_inv_iCycles","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.moduleCatCyclesIso.inv S.iCycles) (ModuleCat.ofHom (LinearMap.ker (ModuleCat.Hom.hom S.g)).subtype)","decl":"@[reassoc (attr := simp, elementwise)]\nlemma moduleCatCyclesIso_inv_iCycles :\n    S.moduleCatCyclesIso.inv ≫ S.iCycles = ModuleCat.ofHom (LinearMap.ker S.g.hom).subtype :=\n  S.moduleCatLeftHomologyData.cyclesIso_inv_comp_iCycles\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatCyclesIso_inv_iCycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nZ : ModuleCat R\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.moduleCatCyclesIso.inv (CategoryTheory.CategoryStruct.comp S.iCycles h)) (CategoryTheory.CategoryStruct.comp (ModuleCat.ofHom (LinearMap.ker (ModuleCat.Hom.hom S.g)).subtype) h)","decl":"@[reassoc (attr := simp, elementwise)]\nlemma moduleCatCyclesIso_inv_iCycles :\n    S.moduleCatCyclesIso.inv ≫ S.iCycles = ModuleCat.ofHom (LinearMap.ker S.g.hom).subtype :=\n  S.moduleCatLeftHomologyData.cyclesIso_inv_comp_iCycles\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatCyclesIso_inv_iCycles_apply","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nx : CategoryTheory.ToType (ModuleCat.of R (Subtype fun x => Membership.mem (LinearMap.ker (ModuleCat.Hom.hom S.g)) x))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom S.iCycles) ((CategoryTheory.ConcreteCategory.hom S.moduleCatCyclesIso.inv) x)) ↑x","decl":"@[reassoc (attr := simp, elementwise)]\nlemma moduleCatCyclesIso_inv_iCycles :\n    S.moduleCatCyclesIso.inv ≫ S.iCycles = ModuleCat.ofHom (LinearMap.ker S.g.hom).subtype :=\n  S.moduleCatLeftHomologyData.cyclesIso_inv_comp_iCycles\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_moduleCatCyclesIso_hom_apply","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nx : CategoryTheory.ToType S.X₁\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom S.moduleCatCyclesIso.hom) ((CategoryTheory.ConcreteCategory.hom S.toCycles) x)) (S.moduleCatToCycles x)","decl":"@[reassoc (attr := simp, elementwise)]\nlemma toCycles_moduleCatCyclesIso_hom :\n    S.toCycles ≫ S.moduleCatCyclesIso.hom = ModuleCat.ofHom S.moduleCatToCycles := by\n  rw [← cancel_mono S.moduleCatLeftHomologyData.i, moduleCatLeftHomologyData_i,\n    Category.assoc, S.moduleCatCyclesIso_hom_subtype, toCycles_i]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_moduleCatCyclesIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.toCycles S.moduleCatCyclesIso.hom) (ModuleCat.ofHom S.moduleCatToCycles)","decl":"@[reassoc (attr := simp, elementwise)]\nlemma toCycles_moduleCatCyclesIso_hom :\n    S.toCycles ≫ S.moduleCatCyclesIso.hom = ModuleCat.ofHom S.moduleCatToCycles := by\n  rw [← cancel_mono S.moduleCatLeftHomologyData.i, moduleCatLeftHomologyData_i,\n    Category.assoc, S.moduleCatCyclesIso_hom_subtype, toCycles_i]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_moduleCatCyclesIso_hom_assoc_apply","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nZ : ModuleCat R\nh : Quiver.Hom (ModuleCat.of R (Subtype fun x => Membership.mem (LinearMap.ker (ModuleCat.Hom.hom S.g)) x)) Z\nx : CategoryTheory.ToType S.X₁\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom h) ((CategoryTheory.ConcreteCategory.hom S.moduleCatCyclesIso.hom) ((CategoryTheory.ConcreteCategory.hom S.toCycles) x))) ((CategoryTheory.ConcreteCategory.hom h) (S.moduleCatToCycles x))","decl":"@[reassoc (attr := simp, elementwise)]\nlemma toCycles_moduleCatCyclesIso_hom :\n    S.toCycles ≫ S.moduleCatCyclesIso.hom = ModuleCat.ofHom S.moduleCatToCycles := by\n  rw [← cancel_mono S.moduleCatLeftHomologyData.i, moduleCatLeftHomologyData_i,\n    Category.assoc, S.moduleCatCyclesIso_hom_subtype, toCycles_i]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_moduleCatCyclesIso_hom_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nZ : ModuleCat R\nh : Quiver.Hom (ModuleCat.of R (Subtype fun x => Membership.mem (LinearMap.ker (ModuleCat.Hom.hom S.g)) x)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.toCycles (CategoryTheory.CategoryStruct.comp S.moduleCatCyclesIso.hom h)) (CategoryTheory.CategoryStruct.comp (ModuleCat.ofHom S.moduleCatToCycles) h)","decl":"@[reassoc (attr := simp, elementwise)]\nlemma toCycles_moduleCatCyclesIso_hom :\n    S.toCycles ≫ S.moduleCatCyclesIso.hom = ModuleCat.ofHom S.moduleCatToCycles := by\n  rw [← cancel_mono S.moduleCatLeftHomologyData.i, moduleCatLeftHomologyData_i,\n    Category.assoc, S.moduleCatCyclesIso_hom_subtype, toCycles_i]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.π_moduleCatCyclesIso_hom_assoc_apply","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nZ : ModuleCat R\nh : Quiver.Hom S.moduleCatHomology Z\nx : CategoryTheory.ToType S.cycles\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom h) ((CategoryTheory.ConcreteCategory.hom S.moduleCatHomologyIso.hom) ((CategoryTheory.ConcreteCategory.hom S.homologyπ) x))) ((CategoryTheory.ConcreteCategory.hom h) (Submodule.Quotient.mk ((CategoryTheory.ConcreteCategory.hom S.moduleCatCyclesIso.hom) x)))","decl":"@[reassoc (attr := simp, elementwise)]\nlemma π_moduleCatCyclesIso_hom :\n    S.homologyπ ≫ S.moduleCatHomologyIso.hom =\n      S.moduleCatCyclesIso.hom ≫ S.moduleCatHomologyπ :=\n  S.moduleCatLeftHomologyData.homologyπ_comp_homologyIso_hom\n\n"}
{"name":"CategoryTheory.ShortComplex.π_moduleCatCyclesIso_hom_apply","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nx : CategoryTheory.ToType S.cycles\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom S.moduleCatHomologyIso.hom) ((CategoryTheory.ConcreteCategory.hom S.homologyπ) x)) (Submodule.Quotient.mk ((CategoryTheory.ConcreteCategory.hom S.moduleCatCyclesIso.hom) x))","decl":"@[reassoc (attr := simp, elementwise)]\nlemma π_moduleCatCyclesIso_hom :\n    S.homologyπ ≫ S.moduleCatHomologyIso.hom =\n      S.moduleCatCyclesIso.hom ≫ S.moduleCatHomologyπ :=\n  S.moduleCatLeftHomologyData.homologyπ_comp_homologyIso_hom\n\n"}
{"name":"CategoryTheory.ShortComplex.π_moduleCatCyclesIso_hom_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nZ : ModuleCat R\nh : Quiver.Hom S.moduleCatHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyπ (CategoryTheory.CategoryStruct.comp S.moduleCatHomologyIso.hom h)) (CategoryTheory.CategoryStruct.comp S.moduleCatCyclesIso.hom (CategoryTheory.CategoryStruct.comp S.moduleCatHomologyπ h))","decl":"@[reassoc (attr := simp, elementwise)]\nlemma π_moduleCatCyclesIso_hom :\n    S.homologyπ ≫ S.moduleCatHomologyIso.hom =\n      S.moduleCatCyclesIso.hom ≫ S.moduleCatHomologyπ :=\n  S.moduleCatLeftHomologyData.homologyπ_comp_homologyIso_hom\n\n"}
{"name":"CategoryTheory.ShortComplex.π_moduleCatCyclesIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyπ S.moduleCatHomologyIso.hom) (CategoryTheory.CategoryStruct.comp S.moduleCatCyclesIso.hom S.moduleCatHomologyπ)","decl":"@[reassoc (attr := simp, elementwise)]\nlemma π_moduleCatCyclesIso_hom :\n    S.homologyπ ≫ S.moduleCatHomologyIso.hom =\n      S.moduleCatCyclesIso.hom ≫ S.moduleCatHomologyπ :=\n  S.moduleCatLeftHomologyData.homologyπ_comp_homologyIso_hom\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatCyclesIso_inv_π_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nZ : ModuleCat R\nh : Quiver.Hom S.homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.moduleCatCyclesIso.inv (CategoryTheory.CategoryStruct.comp S.homologyπ h)) (CategoryTheory.CategoryStruct.comp S.moduleCatHomologyπ (CategoryTheory.CategoryStruct.comp S.moduleCatHomologyIso.inv h))","decl":"@[reassoc (attr := simp, elementwise)]\nlemma moduleCatCyclesIso_inv_π :\n    S.moduleCatCyclesIso.inv ≫ S.homologyπ =\n       S.moduleCatHomologyπ ≫ S.moduleCatHomologyIso.inv :=\n  S.moduleCatLeftHomologyData.π_comp_homologyIso_inv\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatCyclesIso_inv_π","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.moduleCatCyclesIso.inv S.homologyπ) (CategoryTheory.CategoryStruct.comp S.moduleCatHomologyπ S.moduleCatHomologyIso.inv)","decl":"@[reassoc (attr := simp, elementwise)]\nlemma moduleCatCyclesIso_inv_π :\n    S.moduleCatCyclesIso.inv ≫ S.homologyπ =\n       S.moduleCatHomologyπ ≫ S.moduleCatHomologyIso.inv :=\n  S.moduleCatLeftHomologyData.π_comp_homologyIso_inv\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatCyclesIso_inv_π_assoc_apply","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nZ : ModuleCat R\nh : Quiver.Hom S.homology Z\nx : CategoryTheory.ToType (ModuleCat.of R (Subtype fun x => Membership.mem (LinearMap.ker (ModuleCat.Hom.hom S.g)) x))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom h) ((CategoryTheory.ConcreteCategory.hom S.homologyπ) ((CategoryTheory.ConcreteCategory.hom S.moduleCatCyclesIso.inv) x))) ((CategoryTheory.ConcreteCategory.hom h) ((CategoryTheory.ConcreteCategory.hom S.moduleCatHomologyIso.inv) (Submodule.Quotient.mk x)))","decl":"@[reassoc (attr := simp, elementwise)]\nlemma moduleCatCyclesIso_inv_π :\n    S.moduleCatCyclesIso.inv ≫ S.homologyπ =\n       S.moduleCatHomologyπ ≫ S.moduleCatHomologyIso.inv :=\n  S.moduleCatLeftHomologyData.π_comp_homologyIso_inv\n\n"}
{"name":"CategoryTheory.ShortComplex.moduleCatCyclesIso_inv_π_apply","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\nx : CategoryTheory.ToType (ModuleCat.of R (Subtype fun x => Membership.mem (LinearMap.ker (ModuleCat.Hom.hom S.g)) x))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom S.homologyπ) ((CategoryTheory.ConcreteCategory.hom S.moduleCatCyclesIso.inv) x)) ((CategoryTheory.ConcreteCategory.hom S.moduleCatHomologyIso.inv) (Submodule.Quotient.mk x))","decl":"@[reassoc (attr := simp, elementwise)]\nlemma moduleCatCyclesIso_inv_π :\n    S.moduleCatCyclesIso.inv ≫ S.homologyπ =\n       S.moduleCatHomologyπ ≫ S.moduleCatHomologyIso.inv :=\n  S.moduleCatLeftHomologyData.π_comp_homologyIso_inv\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_surjective_moduleCatToCycles","module":"Mathlib.Algebra.Homology.ShortComplex.ModuleCat","initialProofState":"R : Type u\ninst✝ : Ring R\nS : CategoryTheory.ShortComplex (ModuleCat R)\n⊢ Iff S.Exact (Function.Surjective ⇑S.moduleCatToCycles)","decl":"lemma exact_iff_surjective_moduleCatToCycles :\n    S.Exact ↔ Function.Surjective S.moduleCatToCycles := by\n  rw [S.moduleCatLeftHomologyData.exact_iff_epi_f', moduleCatLeftHomologyData_f',\n    ModuleCat.epi_iff_surjective]\n  rfl\n\n"}
