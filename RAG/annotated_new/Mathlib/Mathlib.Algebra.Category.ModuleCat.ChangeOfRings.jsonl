{"name":"ModuleCat.instFaithfulRestrictScalars","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\n‚ä¢ (ModuleCat.restrictScalars f).Faithful","decl":"instance {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [Ring R] [Ring S] (f : R ‚Üí+* S) :\n    (restrictScalars.{v} f).Faithful where\n  map_injective h := by\n    ext x\n    simpa only using DFunLike.congr_fun (ModuleCat.hom_ext_iff.mp h) x\n\n"}
{"name":"ModuleCat.instPreservesMonomorphismsRestrictScalars","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\n‚ä¢ (ModuleCat.restrictScalars f).PreservesMonomorphisms","decl":"instance {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [Ring R] [Ring S] (f : R ‚Üí+* S) :\n    (restrictScalars.{v} f).PreservesMonomorphisms where\n  preserves _ h := by rwa [mono_iff_injective] at h ‚ä¢\n\n-- Porting note: this should be automatic\n-- TODO: this instance gives diamonds if `f : S ‚Üí+* S`, see `PresheafOfModules.pushforward‚ÇÄ`.\n-- The correct solution is probably to define explicit maps between `M` and\n-- `(restrictScalars f).obj M`.\n"}
{"name":"ModuleCat.restrictScalars.map_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nM M' : ModuleCat S\ng : Quiver.Hom M M'\nx : ‚Üë((ModuleCat.restrictScalars f).obj M)\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom ((ModuleCat.restrictScalars f).map g)) x) ((CategoryTheory.ConcreteCategory.hom g) x)","decl":"@[simp]\ntheorem restrictScalars.map_apply {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [Ring R] [Ring S] (f : R ‚Üí+* S)\n    {M M' : ModuleCat.{v} S} (g : M ‚ü∂ M') (x) : (restrictScalars f).map g x = g x :=\n  rfl\n\n"}
{"name":"ModuleCat.restrictScalars.smul_def","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nM : ModuleCat S\nr : R\nm : ‚Üë((ModuleCat.restrictScalars f).obj M)\n‚ä¢ Eq (HSMul.hSMul r m) (HSMul.hSMul (f r) (letFun m fun this => this))","decl":"@[simp]\ntheorem restrictScalars.smul_def {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [Ring R] [Ring S] (f : R ‚Üí+* S)\n    {M : ModuleCat.{v} S} (r : R) (m : (restrictScalars f).obj M) : r ‚Ä¢ m = f r ‚Ä¢ show M from m :=\n  rfl\n\n"}
{"name":"ModuleCat.restrictScalars.smul_def'","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nM : ModuleCat S\nr : R\nm : ‚ÜëM\n‚ä¢ Eq (HSMul.hSMul r (letFun m fun this => this)) (HSMul.hSMul (f r) m)","decl":"theorem restrictScalars.smul_def' {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [Ring R] [Ring S] (f : R ‚Üí+* S)\n    {M : ModuleCat.{v} S} (r : R) (m : M) :\n    r ‚Ä¢ (show (restrictScalars f).obj M from m) = f r ‚Ä¢ m :=\n  rfl\n\n\n"}
{"name":"ModuleCat.sMulCommClass_mk","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬≤ : Ring R\ninst‚úù¬π : CommRing S\nf : RingHom R S\nM : Type v\nI : AddCommGroup M\ninst‚úù : Module S M\n‚ä¢ SMulCommClass R S M","decl":"instance (priority := 100) sMulCommClass_mk {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [Ring R] [CommRing S]\n    (f : R ‚Üí+* S) (M : Type v) [I : AddCommGroup M] [Module S M] :\n    haveI : SMul R M := (RestrictScalars.obj' f (ModuleCat.of S M)).isModule.toSMul\n    SMulCommClass R S M :=\n  @SMulCommClass.mk R S M (_) _\n   fun r s m => (by simp [‚Üê mul_smul, mul_comm] : f r ‚Ä¢ s ‚Ä¢ m = s ‚Ä¢ f r ‚Ä¢ m)\n\n"}
{"name":"ModuleCat.semilinearMapAddEquiv_symm_apply_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nM : ModuleCat R\nN : ModuleCat S\ng : Quiver.Hom M ((ModuleCat.restrictScalars f).obj N)\na : ‚ÜëM\n‚ä¢ Eq (((ModuleCat.semilinearMapAddEquiv f M N).symm g) a) ((CategoryTheory.ConcreteCategory.hom g) a)","decl":"/-- Semilinear maps `M ‚Üí‚Çõ‚Çó[f] N` identify to\nmorphisms `M ‚ü∂ (ModuleCat.restrictScalars f).obj N`. -/\n@[simps]\ndef semilinearMapAddEquiv {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [Ring R] [Ring S] (f : R ‚Üí+* S)\n    (M : ModuleCat.{v} R) (N : ModuleCat.{v} S) :\n    (M ‚Üí‚Çõ‚Çó[f] N) ‚âÉ+ (M ‚ü∂ (ModuleCat.restrictScalars f).obj N) where\n  -- TODO: after https://github.com/leanprover-community/mathlib4/pull/19511 we need to hint `(Y := ...)`.\n  -- This suggests `restrictScalars` needs to be redesigned.\n  toFun g := ofHom (Y := (ModuleCat.restrictScalars f).obj N) <|\n    { toFun := g\n      map_add' := by simp\n      map_smul' := by simp }\n  invFun g :=\n    { toFun := g\n      map_add' := by simp\n      map_smul' := g.hom.map_smul }\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"ModuleCat.semilinearMapAddEquiv_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nM : ModuleCat R\nN : ModuleCat S\ng : LinearMap f ‚ÜëM ‚ÜëN\n‚ä¢ Eq ((ModuleCat.semilinearMapAddEquiv f M N) g) (ModuleCat.ofHom { toFun := ‚áëg, map_add' := ‚ãØ, map_smul' := ‚ãØ })","decl":"/-- Semilinear maps `M ‚Üí‚Çõ‚Çó[f] N` identify to\nmorphisms `M ‚ü∂ (ModuleCat.restrictScalars f).obj N`. -/\n@[simps]\ndef semilinearMapAddEquiv {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [Ring R] [Ring S] (f : R ‚Üí+* S)\n    (M : ModuleCat.{v} R) (N : ModuleCat.{v} S) :\n    (M ‚Üí‚Çõ‚Çó[f] N) ‚âÉ+ (M ‚ü∂ (ModuleCat.restrictScalars f).obj N) where\n  -- TODO: after https://github.com/leanprover-community/mathlib4/pull/19511 we need to hint `(Y := ...)`.\n  -- This suggests `restrictScalars` needs to be redesigned.\n  toFun g := ofHom (Y := (ModuleCat.restrictScalars f).obj N) <|\n    { toFun := g\n      map_add' := by simp\n      map_smul' := by simp }\n  invFun g :=\n    { toFun := g\n      map_add' := by simp\n      map_smul' := g.hom.map_smul }\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"ModuleCat.restrictScalarsId'App_hom_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\ninst‚úù : Ring R\nf : RingHom R R\nhf : Eq f (RingHom.id R)\nM : ModuleCat R\nx : ‚ÜëM\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (ModuleCat.restrictScalarsId'App f hf M).hom) x) x","decl":"@[simp] lemma restrictScalarsId'App_hom_apply (M : ModuleCat R) (x : M) :\n    (restrictScalarsId'App f hf M).hom x = x :=\n  rfl\n\n"}
{"name":"ModuleCat.restrictScalarsId'App_inv_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\ninst‚úù : Ring R\nf : RingHom R R\nhf : Eq f (RingHom.id R)\nM : ModuleCat R\nx : ‚ÜëM\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (ModuleCat.restrictScalarsId'App f hf M).inv) x) x","decl":"@[simp] lemma restrictScalarsId'App_inv_apply (M : ModuleCat R) (x : M) :\n    (restrictScalarsId'App f hf M).inv x = x :=\n  rfl\n\n"}
{"name":"ModuleCat.restrictScalarsId'_hom_app","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\ninst‚úù : Ring R\nf : RingHom R R\nhf : Eq f (RingHom.id R)\nX : ModuleCat R\n‚ä¢ Eq ((ModuleCat.restrictScalarsId' f hf).hom.app X) (ModuleCat.restrictScalarsId'App f hf X).hom","decl":"/-- The restriction of scalars by a ring morphism that is the identity identify to the\nidentity functor. -/\n@[simps! hom_app inv_app]\ndef restrictScalarsId' : ModuleCat.restrictScalars.{v} f ‚âÖ ùü≠ _ :=\n    NatIso.ofComponents <| fun M ‚Ü¶ restrictScalarsId'App f hf M\n\n"}
{"name":"ModuleCat.restrictScalarsId'_inv_app","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\ninst‚úù : Ring R\nf : RingHom R R\nhf : Eq f (RingHom.id R)\nX : ModuleCat R\n‚ä¢ Eq ((ModuleCat.restrictScalarsId' f hf).inv.app X) (ModuleCat.restrictScalarsId'App f hf X).inv","decl":"/-- The restriction of scalars by a ring morphism that is the identity identify to the\nidentity functor. -/\n@[simps! hom_app inv_app]\ndef restrictScalarsId' : ModuleCat.restrictScalars.{v} f ‚âÖ ùü≠ _ :=\n    NatIso.ofComponents <| fun M ‚Ü¶ restrictScalarsId'App f hf M\n\n"}
{"name":"ModuleCat.restrictScalarsId'App_hom_naturality","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\ninst‚úù : Ring R\nf : RingHom R R\nhf : Eq f (RingHom.id R)\nM N : ModuleCat R\nœÜ : Quiver.Hom M N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars f).map œÜ) (ModuleCat.restrictScalarsId'App f hf N).hom) (CategoryTheory.CategoryStruct.comp (ModuleCat.restrictScalarsId'App f hf M).hom œÜ)","decl":"@[reassoc]\nlemma restrictScalarsId'App_hom_naturality {M N : ModuleCat R} (œÜ : M ‚ü∂ N) :\n    (restrictScalars f).map œÜ ‚â´ (restrictScalarsId'App f hf N).hom =\n      (restrictScalarsId'App f hf M).hom ‚â´ œÜ :=\n  (restrictScalarsId' f hf).hom.naturality œÜ\n\n"}
{"name":"ModuleCat.restrictScalarsId'App_hom_naturality_assoc","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\ninst‚úù : Ring R\nf : RingHom R R\nhf : Eq f (RingHom.id R)\nM N : ModuleCat R\nœÜ : Quiver.Hom M N\nZ : ModuleCat R\nh : Quiver.Hom N Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars f).map œÜ) (CategoryTheory.CategoryStruct.comp (ModuleCat.restrictScalarsId'App f hf N).hom h)) (CategoryTheory.CategoryStruct.comp (ModuleCat.restrictScalarsId'App f hf M).hom (CategoryTheory.CategoryStruct.comp œÜ h))","decl":"@[reassoc]\nlemma restrictScalarsId'App_hom_naturality {M N : ModuleCat R} (œÜ : M ‚ü∂ N) :\n    (restrictScalars f).map œÜ ‚â´ (restrictScalarsId'App f hf N).hom =\n      (restrictScalarsId'App f hf M).hom ‚â´ œÜ :=\n  (restrictScalarsId' f hf).hom.naturality œÜ\n\n"}
{"name":"ModuleCat.restrictScalarsId'App_inv_naturality_assoc","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\ninst‚úù : Ring R\nf : RingHom R R\nhf : Eq f (RingHom.id R)\nM N : ModuleCat R\nœÜ : Quiver.Hom M N\nZ : ModuleCat R\nh : Quiver.Hom ((ModuleCat.restrictScalars f).obj N) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp œÜ (CategoryTheory.CategoryStruct.comp (ModuleCat.restrictScalarsId'App f hf N).inv h)) (CategoryTheory.CategoryStruct.comp (ModuleCat.restrictScalarsId'App f hf M).inv (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars f).map œÜ) h))","decl":"@[reassoc]\nlemma restrictScalarsId'App_inv_naturality {M N : ModuleCat R} (œÜ : M ‚ü∂ N) :\n    œÜ ‚â´ (restrictScalarsId'App f hf N).inv =\n      (restrictScalarsId'App f hf M).inv ‚â´ (restrictScalars f).map œÜ :=\n  (restrictScalarsId' f hf).inv.naturality œÜ\n\n"}
{"name":"ModuleCat.restrictScalarsId'App_inv_naturality","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\ninst‚úù : Ring R\nf : RingHom R R\nhf : Eq f (RingHom.id R)\nM N : ModuleCat R\nœÜ : Quiver.Hom M N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp œÜ (ModuleCat.restrictScalarsId'App f hf N).inv) (CategoryTheory.CategoryStruct.comp (ModuleCat.restrictScalarsId'App f hf M).inv ((ModuleCat.restrictScalars f).map œÜ))","decl":"@[reassoc]\nlemma restrictScalarsId'App_inv_naturality {M N : ModuleCat R} (œÜ : M ‚ü∂ N) :\n    œÜ ‚â´ (restrictScalarsId'App f hf N).inv =\n      (restrictScalarsId'App f hf M).inv ‚â´ (restrictScalars f).map œÜ :=\n  (restrictScalarsId' f hf).inv.naturality œÜ\n\n"}
{"name":"ModuleCat.restrictScalarsComp'App_hom_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ : Type u‚ÇÅ\nR‚ÇÇ : Type u‚ÇÇ\nR‚ÇÉ : Type u‚ÇÉ\ninst‚úù¬≤ : Ring R‚ÇÅ\ninst‚úù¬π : Ring R‚ÇÇ\ninst‚úù : Ring R‚ÇÉ\nf : RingHom R‚ÇÅ R‚ÇÇ\ng : RingHom R‚ÇÇ R‚ÇÉ\ngf : RingHom R‚ÇÅ R‚ÇÉ\nhgf : Eq gf (g.comp f)\nM : ModuleCat R‚ÇÉ\nx : ‚ÜëM\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (ModuleCat.restrictScalarsComp'App f g gf hgf M).hom) x) x","decl":"@[simp] lemma restrictScalarsComp'App_hom_apply (M : ModuleCat R‚ÇÉ) (x : M) :\n    (restrictScalarsComp'App f g gf hgf M).hom x = x :=\n  rfl\n\n"}
{"name":"ModuleCat.restrictScalarsComp'App_inv_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ : Type u‚ÇÅ\nR‚ÇÇ : Type u‚ÇÇ\nR‚ÇÉ : Type u‚ÇÉ\ninst‚úù¬≤ : Ring R‚ÇÅ\ninst‚úù¬π : Ring R‚ÇÇ\ninst‚úù : Ring R‚ÇÉ\nf : RingHom R‚ÇÅ R‚ÇÇ\ng : RingHom R‚ÇÇ R‚ÇÉ\ngf : RingHom R‚ÇÅ R‚ÇÉ\nhgf : Eq gf (g.comp f)\nM : ModuleCat R‚ÇÉ\nx : ‚ÜëM\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (ModuleCat.restrictScalarsComp'App f g gf hgf M).inv) x) x","decl":"@[simp] lemma restrictScalarsComp'App_inv_apply (M : ModuleCat R‚ÇÉ) (x : M) :\n    (restrictScalarsComp'App f g gf hgf M).inv x = x :=\n  rfl\n\n"}
{"name":"ModuleCat.restrictScalarsComp'_hom_app","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ : Type u‚ÇÅ\nR‚ÇÇ : Type u‚ÇÇ\nR‚ÇÉ : Type u‚ÇÉ\ninst‚úù¬≤ : Ring R‚ÇÅ\ninst‚úù¬π : Ring R‚ÇÇ\ninst‚úù : Ring R‚ÇÉ\nf : RingHom R‚ÇÅ R‚ÇÇ\ng : RingHom R‚ÇÇ R‚ÇÉ\ngf : RingHom R‚ÇÅ R‚ÇÉ\nhgf : Eq gf (g.comp f)\nX : ModuleCat R‚ÇÉ\n‚ä¢ Eq ((ModuleCat.restrictScalarsComp' f g gf hgf).hom.app X) (ModuleCat.restrictScalarsComp'App f g gf hgf X).hom","decl":"/-- The restriction of scalars by a composition of ring morphisms identify to the\ncomposition of the restriction of scalars functors. -/\n@[simps! hom_app inv_app]\ndef restrictScalarsComp' :\n    ModuleCat.restrictScalars.{v} gf ‚âÖ\n      ModuleCat.restrictScalars g ‚ãô ModuleCat.restrictScalars f :=\n  NatIso.ofComponents <| fun M ‚Ü¶ restrictScalarsComp'App f g gf hgf M\n\n"}
{"name":"ModuleCat.restrictScalarsComp'_inv_app","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ : Type u‚ÇÅ\nR‚ÇÇ : Type u‚ÇÇ\nR‚ÇÉ : Type u‚ÇÉ\ninst‚úù¬≤ : Ring R‚ÇÅ\ninst‚úù¬π : Ring R‚ÇÇ\ninst‚úù : Ring R‚ÇÉ\nf : RingHom R‚ÇÅ R‚ÇÇ\ng : RingHom R‚ÇÇ R‚ÇÉ\ngf : RingHom R‚ÇÅ R‚ÇÉ\nhgf : Eq gf (g.comp f)\nX : ModuleCat R‚ÇÉ\n‚ä¢ Eq ((ModuleCat.restrictScalarsComp' f g gf hgf).inv.app X) (ModuleCat.restrictScalarsComp'App f g gf hgf X).inv","decl":"/-- The restriction of scalars by a composition of ring morphisms identify to the\ncomposition of the restriction of scalars functors. -/\n@[simps! hom_app inv_app]\ndef restrictScalarsComp' :\n    ModuleCat.restrictScalars.{v} gf ‚âÖ\n      ModuleCat.restrictScalars g ‚ãô ModuleCat.restrictScalars f :=\n  NatIso.ofComponents <| fun M ‚Ü¶ restrictScalarsComp'App f g gf hgf M\n\n"}
{"name":"ModuleCat.restrictScalarsComp'App_hom_naturality","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ : Type u‚ÇÅ\nR‚ÇÇ : Type u‚ÇÇ\nR‚ÇÉ : Type u‚ÇÉ\ninst‚úù¬≤ : Ring R‚ÇÅ\ninst‚úù¬π : Ring R‚ÇÇ\ninst‚úù : Ring R‚ÇÉ\nf : RingHom R‚ÇÅ R‚ÇÇ\ng : RingHom R‚ÇÇ R‚ÇÉ\ngf : RingHom R‚ÇÅ R‚ÇÉ\nhgf : Eq gf (g.comp f)\nM N : ModuleCat R‚ÇÉ\nœÜ : Quiver.Hom M N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars gf).map œÜ) (ModuleCat.restrictScalarsComp'App f g gf hgf N).hom) (CategoryTheory.CategoryStruct.comp (ModuleCat.restrictScalarsComp'App f g gf hgf M).hom ((ModuleCat.restrictScalars f).map ((ModuleCat.restrictScalars g).map œÜ)))","decl":"@[reassoc]\nlemma restrictScalarsComp'App_hom_naturality {M N : ModuleCat R‚ÇÉ} (œÜ : M ‚ü∂ N) :\n    (restrictScalars gf).map œÜ ‚â´ (restrictScalarsComp'App f g gf hgf N).hom =\n      (restrictScalarsComp'App f g gf hgf M).hom ‚â´\n        (restrictScalars f).map ((restrictScalars g).map œÜ) :=\n  (restrictScalarsComp' f g gf hgf).hom.naturality œÜ\n\n"}
{"name":"ModuleCat.restrictScalarsComp'App_hom_naturality_assoc","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ : Type u‚ÇÅ\nR‚ÇÇ : Type u‚ÇÇ\nR‚ÇÉ : Type u‚ÇÉ\ninst‚úù¬≤ : Ring R‚ÇÅ\ninst‚úù¬π : Ring R‚ÇÇ\ninst‚úù : Ring R‚ÇÉ\nf : RingHom R‚ÇÅ R‚ÇÇ\ng : RingHom R‚ÇÇ R‚ÇÉ\ngf : RingHom R‚ÇÅ R‚ÇÉ\nhgf : Eq gf (g.comp f)\nM N : ModuleCat R‚ÇÉ\nœÜ : Quiver.Hom M N\nZ : ModuleCat R‚ÇÅ\nh : Quiver.Hom ((ModuleCat.restrictScalars f).obj ((ModuleCat.restrictScalars g).obj N)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars gf).map œÜ) (CategoryTheory.CategoryStruct.comp (ModuleCat.restrictScalarsComp'App f g gf hgf N).hom h)) (CategoryTheory.CategoryStruct.comp (ModuleCat.restrictScalarsComp'App f g gf hgf M).hom (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars f).map ((ModuleCat.restrictScalars g).map œÜ)) h))","decl":"@[reassoc]\nlemma restrictScalarsComp'App_hom_naturality {M N : ModuleCat R‚ÇÉ} (œÜ : M ‚ü∂ N) :\n    (restrictScalars gf).map œÜ ‚â´ (restrictScalarsComp'App f g gf hgf N).hom =\n      (restrictScalarsComp'App f g gf hgf M).hom ‚â´\n        (restrictScalars f).map ((restrictScalars g).map œÜ) :=\n  (restrictScalarsComp' f g gf hgf).hom.naturality œÜ\n\n"}
{"name":"ModuleCat.restrictScalarsComp'App_inv_naturality","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ : Type u‚ÇÅ\nR‚ÇÇ : Type u‚ÇÇ\nR‚ÇÉ : Type u‚ÇÉ\ninst‚úù¬≤ : Ring R‚ÇÅ\ninst‚úù¬π : Ring R‚ÇÇ\ninst‚úù : Ring R‚ÇÉ\nf : RingHom R‚ÇÅ R‚ÇÇ\ng : RingHom R‚ÇÇ R‚ÇÉ\ngf : RingHom R‚ÇÅ R‚ÇÉ\nhgf : Eq gf (g.comp f)\nM N : ModuleCat R‚ÇÉ\nœÜ : Quiver.Hom M N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars f).map ((ModuleCat.restrictScalars g).map œÜ)) (ModuleCat.restrictScalarsComp'App f g gf hgf N).inv) (CategoryTheory.CategoryStruct.comp (ModuleCat.restrictScalarsComp'App f g gf hgf M).inv ((ModuleCat.restrictScalars gf).map œÜ))","decl":"@[reassoc]\nlemma restrictScalarsComp'App_inv_naturality {M N : ModuleCat R‚ÇÉ} (œÜ : M ‚ü∂ N) :\n    (restrictScalars f).map ((restrictScalars g).map œÜ) ‚â´\n        (restrictScalarsComp'App f g gf hgf N).inv =\n      (restrictScalarsComp'App f g gf hgf M).inv ‚â´ (restrictScalars gf).map œÜ :=\n  (restrictScalarsComp' f g gf hgf).inv.naturality œÜ\n\n"}
{"name":"ModuleCat.restrictScalarsComp'App_inv_naturality_assoc","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ : Type u‚ÇÅ\nR‚ÇÇ : Type u‚ÇÇ\nR‚ÇÉ : Type u‚ÇÉ\ninst‚úù¬≤ : Ring R‚ÇÅ\ninst‚úù¬π : Ring R‚ÇÇ\ninst‚úù : Ring R‚ÇÉ\nf : RingHom R‚ÇÅ R‚ÇÇ\ng : RingHom R‚ÇÇ R‚ÇÉ\ngf : RingHom R‚ÇÅ R‚ÇÉ\nhgf : Eq gf (g.comp f)\nM N : ModuleCat R‚ÇÉ\nœÜ : Quiver.Hom M N\nZ : ModuleCat R‚ÇÅ\nh : Quiver.Hom ((ModuleCat.restrictScalars gf).obj N) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars f).map ((ModuleCat.restrictScalars g).map œÜ)) (CategoryTheory.CategoryStruct.comp (ModuleCat.restrictScalarsComp'App f g gf hgf N).inv h)) (CategoryTheory.CategoryStruct.comp (ModuleCat.restrictScalarsComp'App f g gf hgf M).inv (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars gf).map œÜ) h))","decl":"@[reassoc]\nlemma restrictScalarsComp'App_inv_naturality {M N : ModuleCat R‚ÇÉ} (œÜ : M ‚ü∂ N) :\n    (restrictScalars f).map ((restrictScalars g).map œÜ) ‚â´\n        (restrictScalarsComp'App f g gf hgf N).inv =\n      (restrictScalarsComp'App f g gf hgf M).inv ‚â´ (restrictScalars gf).map œÜ :=\n  (restrictScalarsComp' f g gf hgf).inv.naturality œÜ\n\n"}
{"name":"ModuleCat.restrictScalars_isEquivalence_of_ringEquiv","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u_1\nS : Type u_2\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\ne : RingEquiv R S\n‚ä¢ (ModuleCat.restrictScalars e.toRingHom).IsEquivalence","decl":"instance restrictScalars_isEquivalence_of_ringEquiv {R S} [Ring R] [Ring S] (e : R ‚âÉ+* S) :\n    (ModuleCat.restrictScalars e.toRingHom).IsEquivalence :=\n  (restrictScalarsEquivalenceOfRingEquiv e).isEquivalence_functor\n\n"}
{"name":"ModuleCat.ExtendScalars.map'_id","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nM : ModuleCat R\n‚ä¢ Eq (ModuleCat.ExtendScalars.map' f (CategoryTheory.CategoryStruct.id M)) (CategoryTheory.CategoryStruct.id (ModuleCat.ExtendScalars.obj' f M))","decl":"theorem map'_id {M : ModuleCat.{v} R} : map' f (ùüô M) = ùüô _ := by\n  ext x\n  simp [map', obj']\n\n"}
{"name":"ModuleCat.ExtendScalars.map'_comp","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nM‚ÇÅ M‚ÇÇ M‚ÇÉ : ModuleCat R\nl‚ÇÅ‚ÇÇ : Quiver.Hom M‚ÇÅ M‚ÇÇ\nl‚ÇÇ‚ÇÉ : Quiver.Hom M‚ÇÇ M‚ÇÉ\n‚ä¢ Eq (ModuleCat.ExtendScalars.map' f (CategoryTheory.CategoryStruct.comp l‚ÇÅ‚ÇÇ l‚ÇÇ‚ÇÉ)) (CategoryTheory.CategoryStruct.comp (ModuleCat.ExtendScalars.map' f l‚ÇÅ‚ÇÇ) (ModuleCat.ExtendScalars.map' f l‚ÇÇ‚ÇÉ))","decl":"theorem map'_comp {M‚ÇÅ M‚ÇÇ M‚ÇÉ : ModuleCat.{v} R} (l‚ÇÅ‚ÇÇ : M‚ÇÅ ‚ü∂ M‚ÇÇ) (l‚ÇÇ‚ÇÉ : M‚ÇÇ ‚ü∂ M‚ÇÉ) :\n    map' f (l‚ÇÅ‚ÇÇ ‚â´ l‚ÇÇ‚ÇÉ) = map' f l‚ÇÅ‚ÇÇ ‚â´ map' f l‚ÇÇ‚ÇÉ := by\n  ext x\n  dsimp only [map']\n  induction x using TensorProduct.induction_on with\n  | zero => rfl\n  | tmul => rfl\n  | add _ _ ihx ihy => rw [map_add, map_add, ihx, ihy]\n\n"}
{"name":"ModuleCat.ExtendScalars.smul_tmul","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nM : ModuleCat R\ns s' : S\nm : ‚ÜëM\n‚ä¢ Eq (HSMul.hSMul s (TensorProduct.tmul R s' m)) (TensorProduct.tmul R (HMul.hMul s s') m)","decl":"@[simp]\nprotected theorem smul_tmul {M : ModuleCat.{v} R} (s s' : S) (m : M) :\n    s ‚Ä¢ (s'‚äó‚Çú[R,f]m : (extendScalars f).obj M) = (s * s')‚äó‚Çú[R,f]m :=\n  rfl\n\n"}
{"name":"ModuleCat.ExtendScalars.map_tmul","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nM M' : ModuleCat R\ng : Quiver.Hom M M'\ns : S\nm : ‚ÜëM\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom ((ModuleCat.extendScalars f).map g)) (TensorProduct.tmul R s m)) (TensorProduct.tmul R s ((CategoryTheory.ConcreteCategory.hom g) m))","decl":"@[simp]\ntheorem map_tmul {M M' : ModuleCat.{v} R} (g : M ‚ü∂ M') (s : S) (m : M) :\n    (extendScalars f).map g (s‚äó‚Çú[R,f]m) = s‚äó‚Çú[R,f]g m :=\n  rfl\n\n"}
{"name":"ModuleCat.ExtendScalars.hom_ext_iff","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nM : ModuleCat R\nN : ModuleCat S\nŒ± Œ≤ : Quiver.Hom ((ModuleCat.extendScalars f).obj M) N\n‚ä¢ Iff (Eq Œ± Œ≤) (‚àÄ (m : ‚ÜëM), Eq ((CategoryTheory.ConcreteCategory.hom Œ±) (TensorProduct.tmul R 1 m)) ((CategoryTheory.ConcreteCategory.hom Œ≤) (TensorProduct.tmul R 1 m)))","decl":"@[ext]\nlemma hom_ext {M : ModuleCat R} {N : ModuleCat S}\n    {Œ± Œ≤ : (extendScalars f).obj M ‚ü∂ N}\n    (h : ‚àÄ (m : M), Œ± ((1 : S) ‚äó‚Çú m) = Œ≤ ((1 : S) ‚äó‚Çú m)) : Œ± = Œ≤ := by\n  apply (restrictScalars f).map_injective\n  letI := f.toAlgebra\n  ext : 1\n  apply TensorProduct.ext'\n  intro (s : S) m\n  change Œ± (s ‚äó‚Çú m) = Œ≤ (s ‚äó‚Çú m)\n  have : s ‚äó‚Çú[R] (m : M) = s ‚Ä¢ (1 : S) ‚äó‚Çú[R] m := by\n    rw [ExtendScalars.smul_tmul, mul_one]\n  simp only [this, map_smul, h]\n\n"}
{"name":"ModuleCat.ExtendScalars.hom_ext","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nM : ModuleCat R\nN : ModuleCat S\nŒ± Œ≤ : Quiver.Hom ((ModuleCat.extendScalars f).obj M) N\nh : ‚àÄ (m : ‚ÜëM), Eq ((CategoryTheory.ConcreteCategory.hom Œ±) (TensorProduct.tmul R 1 m)) ((CategoryTheory.ConcreteCategory.hom Œ≤) (TensorProduct.tmul R 1 m))\n‚ä¢ Eq Œ± Œ≤","decl":"@[ext]\nlemma hom_ext {M : ModuleCat R} {N : ModuleCat S}\n    {Œ± Œ≤ : (extendScalars f).obj M ‚ü∂ N}\n    (h : ‚àÄ (m : M), Œ± ((1 : S) ‚äó‚Çú m) = Œ≤ ((1 : S) ‚äó‚Çú m)) : Œ± = Œ≤ := by\n  apply (restrictScalars f).map_injective\n  letI := f.toAlgebra\n  ext : 1\n  apply TensorProduct.ext'\n  intro (s : S) m\n  change Œ± (s ‚äó‚Çú m) = Œ≤ (s ‚äó‚Çú m)\n  have : s ‚äó‚Çú[R] (m : M) = s ‚Ä¢ (1 : S) ‚äó‚Çú[R] m := by\n    rw [ExtendScalars.smul_tmul, mul_one]\n  simp only [this, map_smul, h]\n\n"}
{"name":"ModuleCat.CoextendScalars.smul_apply'","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬≥ : Ring R\ninst‚úù¬≤ : Ring S\nf : RingHom R S\nM : Type v\ninst‚úù¬π : AddCommMonoid M\ninst‚úù : Module R M\ns : S\ng : LinearMap (RingHom.id R) (‚Üë((ModuleCat.restrictScalars f).obj (ModuleCat.of S S))) M\ns' : S\n‚ä¢ Eq ((HSMul.hSMul s g) s') (g (HMul.hMul s' s))","decl":"@[simp]\ntheorem smul_apply' (s : S) (g : (restrictScalars f).obj (of _ S) ‚Üí‚Çó[R] M) (s' : S) :\n    (s ‚Ä¢ g) s' = g (s' * s : S) :=\n  rfl\n\n"}
{"name":"ModuleCat.CoextendScalars.map'_hom_apply_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nM M' : ModuleCat R\ng : Quiver.Hom M M'\nh : LinearMap (RingHom.id R) ‚Üë((ModuleCat.restrictScalars f).obj (ModuleCat.of S S)) ‚ÜëM\na‚úù : ‚Üë((ModuleCat.restrictScalars f).obj (ModuleCat.of S S))\n‚ä¢ Eq (((ModuleCat.Hom.hom (ModuleCat.CoextendScalars.map' f g)) h) a‚úù) ((ModuleCat.Hom.hom g) (h a‚úù))","decl":"/-- If `M, M'` are `R`-modules, then any `R`-linear map `g : M ‚ü∂ M'` induces an `S`-linear map\n`(S ‚Üí‚Çó[R] M) ‚ü∂ (S ‚Üí‚Çó[R] M')` defined by `h ‚Ü¶ g ‚àò h`-/\n@[simps!]\ndef map' {M M' : ModuleCat R} (g : M ‚ü∂ M') : obj' f M ‚ü∂ obj' f M' :=\n  ofHom\n  { toFun := fun h => g.hom.comp h\n    map_add' := fun _ _ => LinearMap.comp_add _ _ _\n    map_smul' := fun s h => by ext; simp }\n\n"}
{"name":"ModuleCat.CoextendScalars.smul_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nM : ModuleCat R\ng : ‚Üë((ModuleCat.coextendScalars f).obj M)\ns s' : S\n‚ä¢ Eq ((HSMul.hSMul s g) s') (g (HMul.hMul s' s))","decl":"theorem smul_apply (M : ModuleCat R) (g : (coextendScalars f).obj M) (s s' : S) :\n    (s ‚Ä¢ g) s' = g (s' * s) :=\n  rfl\n\n"}
{"name":"ModuleCat.CoextendScalars.map_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nM M' : ModuleCat R\ng : Quiver.Hom M M'\nx : ‚Üë((ModuleCat.coextendScalars f).obj M)\ns : S\n‚ä¢ Eq (((CategoryTheory.ConcreteCategory.hom ((ModuleCat.coextendScalars f).map g)) x) s) ((CategoryTheory.ConcreteCategory.hom g) (x s))","decl":"@[simp]\ntheorem map_apply {M M' : ModuleCat R} (g : M ‚ü∂ M') (x) (s : S) :\n    (coextendScalars f).map g x s = g (x s) :=\n  rfl\n\n"}
{"name":"ModuleCat.RestrictionCoextensionAdj.HomEquiv.fromRestriction_hom_apply_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nX : ModuleCat R\nY : ModuleCat S\ng : Quiver.Hom ((ModuleCat.restrictScalars f).obj Y) X\ny : ‚ÜëY\ns : S\n‚ä¢ Eq (((ModuleCat.Hom.hom (ModuleCat.RestrictionCoextensionAdj.HomEquiv.fromRestriction f g)) y) s) ((CategoryTheory.ConcreteCategory.hom g) (HSMul.hSMul s y))","decl":"/-- This should be autogenerated by `@[simps]` but we need to give `s` the correct type here. -/\n@[simp] lemma HomEquiv.fromRestriction_hom_apply_apply {X : ModuleCat R} {Y : ModuleCat S}\n    (g : (restrictScalars f).obj Y ‚ü∂ X) (y) (s : S) :\n    (HomEquiv.fromRestriction f g).hom y s = g (s ‚Ä¢ y) := rfl\n\n"}
{"name":"ModuleCat.RestrictionCoextensionAdj.HomEquiv.toRestriction_hom_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nX : ModuleCat R\nY : ModuleCat S\ng : Quiver.Hom Y ((ModuleCat.coextendScalars f).obj X)\ny : ‚Üë((ModuleCat.restrictScalars f).obj Y)\n‚ä¢ Eq ((ModuleCat.Hom.hom (ModuleCat.RestrictionCoextensionAdj.HomEquiv.toRestriction f g)) y) (((ModuleCat.Hom.hom g) y) 1)","decl":"/-- This should be autogenerated by `@[simps]` but we need to give `1` the correct type here. -/\n@[simp] lemma HomEquiv.toRestriction_hom_apply {X : ModuleCat R} {Y : ModuleCat S}\n    (g : Y ‚ü∂ (coextendScalars f).obj X) (y) :\n    (HomEquiv.toRestriction f g).hom y = g.hom y (1 : S) := rfl\n\n-- Porting note: add to address timeout in unit'\n"}
{"name":"ModuleCat.RestrictionCoextensionAdj.unit'_app","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nY : ModuleCat S\n‚ä¢ Eq ((ModuleCat.RestrictionCoextensionAdj.unit' f).app Y) (ModuleCat.ofHom (ModuleCat.RestrictionCoextensionAdj.app' f Y))","decl":"/--\nThe natural transformation from identity functor to the composition of restriction and coextension\nof scalars.\n-/\n@[simps]\nprotected def unit' : ùü≠ (ModuleCat S) ‚ü∂ restrictScalars f ‚ãô coextendScalars f where\n  app Y := ofHom (app' f Y)\n  naturality Y Y' g :=\n    hom_ext <| LinearMap.ext fun y : Y => LinearMap.ext fun s : S => by\n      -- Porting note (https://github.com/leanprover-community/mathlib4/pull/10745): previously simp [CoextendScalars.map_apply]\n      simp only [ModuleCat.hom_comp, Functor.id_map, Functor.id_obj, Functor.comp_obj,\n        Functor.comp_map, LinearMap.coe_comp, Function.comp, CoextendScalars.map_apply,\n        restrictScalars.map_apply f]\n      change s ‚Ä¢ (g y) = g (s ‚Ä¢ y)\n      rw [map_smul]\n\n"}
{"name":"ModuleCat.RestrictionCoextensionAdj.counit'_app","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\nX : ModuleCat R\n‚ä¢ Eq ((ModuleCat.RestrictionCoextensionAdj.counit' f).app X) (ModuleCat.ofHom { toFun := fun g => g.toFun 1, map_add' := ‚ãØ, map_smul' := ‚ãØ })","decl":"/-- The natural transformation from the composition of coextension and restriction of scalars to\nidentity functor.\n-/\n@[simps]\nprotected def counit' : coextendScalars f ‚ãô restrictScalars f ‚ü∂ ùü≠ (ModuleCat R) where\n  -- TODO: after https://github.com/leanprover-community/mathlib4/pull/19511 we need to hint `(X := ...)`.\n  -- This suggests `restrictScalars` needs to be redesigned.\n  app X := ofHom (X := (restrictScalars f).obj ((coextendScalars f).obj X))\n    { toFun := fun g => g.toFun (1 : S)\n      map_add' := fun x1 x2 => by\n        dsimp\n        rw [LinearMap.add_apply]\n      map_smul' := fun r (g : (restrictScalars f).obj ((coextendScalars f).obj X)) => by\n        dsimp\n        rw [CoextendScalars.smul_apply, one_mul, ‚Üê LinearMap.map_smul]\n        congr\n        change f r = (f r) ‚Ä¢ (1 : S)\n        rw [smul_eq_mul (a := f r) (a' := 1), mul_one] }\n\n"}
{"name":"ModuleCat.instIsLeftAdjointRestrictScalars","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\n‚ä¢ (ModuleCat.restrictScalars f).IsLeftAdjoint","decl":"instance {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [Ring R] [Ring S] (f : R ‚Üí+* S) :\n    (restrictScalars.{max u‚ÇÇ w} f).IsLeftAdjoint  :=\n  (restrictCoextendScalarsAdj f).isLeftAdjoint\n\n"}
{"name":"ModuleCat.instIsRightAdjointCoextendScalars","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : Ring R\ninst‚úù : Ring S\nf : RingHom R S\n‚ä¢ (ModuleCat.coextendScalars f).IsRightAdjoint","decl":"instance {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [Ring R] [Ring S] (f : R ‚Üí+* S) :\n    (coextendScalars.{u‚ÇÅ, u‚ÇÇ, max u‚ÇÇ w} f).IsRightAdjoint  :=\n  (restrictCoextendScalarsAdj f).isRightAdjoint\n\n"}
{"name":"ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.toRestrictScalars_hom_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nX : ModuleCat R\nY : ModuleCat S\ng : Quiver.Hom ((ModuleCat.extendScalars f).obj X) Y\nx : ‚ÜëX\n‚ä¢ Eq ((ModuleCat.Hom.hom (ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.toRestrictScalars f g)) x) ((CategoryTheory.ConcreteCategory.hom g) (TensorProduct.tmul R 1 x))","decl":"/--\nGiven `R`-module X and `S`-module Y and a map `g : (extendScalars f).obj X ‚ü∂ Y`, i.e. `S`-linear\nmap `S ‚®Ç X ‚Üí Y`, there is a `X ‚ü∂ (restrictScalars f).obj Y`, i.e. `R`-linear map `X ‚ü∂ Y` by\n`x ‚Ü¶ g (1 ‚äó x)`.\n-/\n@[simps! hom_apply]\ndef HomEquiv.toRestrictScalars {X Y} (g : (extendScalars f).obj X ‚ü∂ Y) :\n    X ‚ü∂ (restrictScalars f).obj Y :=\n  -- TODO: after https://github.com/leanprover-community/mathlib4/pull/19511 we need to hint `(Y := ...)`.\n  -- This suggests `restrictScalars` needs to be redesigned.\n  ofHom (Y := (restrictScalars f).obj Y)\n  { toFun := fun x => g <| (1 : S)‚äó‚Çú[R,f]x\n    map_add' := fun _ _ => by dsimp; rw [tmul_add, map_add]\n    map_smul' := fun r s => by\n      letI : Module R S := Module.compHom S f\n      letI : Module R Y := Module.compHom Y f\n      dsimp\n      erw [RestrictScalars.smul_def, ‚Üê LinearMap.map_smul, tmul_smul]\n      congr }\n\n-- Porting note: forced to break apart fromExtendScalars due to timeouts\n"}
{"name":"ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.evalAt_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nX : ModuleCat R\nY : ModuleCat S\ns : S\ng : Quiver.Hom X ((ModuleCat.restrictScalars f).obj Y)\nx : ‚ÜëX\n‚ä¢ Eq ((ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.evalAt f s g) x) (HSMul.hSMul s ((CategoryTheory.ConcreteCategory.hom g) x))","decl":"/--\nThe map `S ‚Üí X ‚Üí‚Çó[R] Y` given by `fun s x => s ‚Ä¢ (g x)`\n-/\n@[simps]\ndef HomEquiv.evalAt {X : ModuleCat R} {Y : ModuleCat S} (s : S)\n    (g : X ‚ü∂ (restrictScalars f).obj Y) : have : Module R Y := Module.compHom Y f\n    X ‚Üí‚Çó[R] Y :=\n  @LinearMap.mk _ _ _ _ (RingHom.id R) X Y _ _ _ (_)\n    { toFun := fun x => s ‚Ä¢ (g x : Y)\n      map_add' := by\n        intros\n        dsimp only\n        rw [map_add, smul_add] }\n    (by\n      intros r x\n      rw [AddHom.toFun_eq_coe, AddHom.coe_mk, RingHom.id_apply,\n        LinearMap.map_smul, smul_comm r s (g x : Y)] )\n\n"}
{"name":"ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.fromExtendScalars_hom_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nX : ModuleCat R\nY : ModuleCat S\ng : Quiver.Hom X ((ModuleCat.restrictScalars f).obj Y)\nz : TensorProduct R ‚Üë((ModuleCat.restrictScalars f).obj (ModuleCat.of S S)) ‚ÜëX\n‚ä¢ Eq ((ModuleCat.Hom.hom (ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.fromExtendScalars f g)) z) ((TensorProduct.lift { toFun := fun s => ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.evalAt f s g, map_add' := ‚ãØ, map_smul' := ‚ãØ }) z)","decl":"/--\nGiven `R`-module X and `S`-module Y and a map `X ‚ü∂ (restrictScalars f).obj Y`, i.e `R`-linear map\n`X ‚ü∂ Y`, there is a map `(extend_scalars f).obj X ‚ü∂ Y`, i.e `S`-linear map `S ‚®Ç X ‚Üí Y` by\n`s ‚äó x ‚Ü¶ s ‚Ä¢ g x`.\n-/\n@[simps! hom_apply]\ndef HomEquiv.fromExtendScalars {X Y} (g : X ‚ü∂ (restrictScalars f).obj Y) :\n    (extendScalars f).obj X ‚ü∂ Y := by\n  letI m1 : Module R S := Module.compHom S f; letI m2 : Module R Y := Module.compHom Y f\n  refine ofHom {toFun := fun z => TensorProduct.lift ?_ z, map_add' := ?_, map_smul' := ?_}\n  ¬∑ refine\n    {toFun := fun s => HomEquiv.evalAt f s g, map_add' := fun (s‚ÇÅ s‚ÇÇ : S) => ?_,\n      map_smul' := fun (r : R) (s : S) => ?_}\n    ¬∑ ext\n      dsimp only [m2, evalAt_apply, LinearMap.add_apply]\n      rw [‚Üê add_smul]\n    ¬∑ ext x\n      apply mul_smul (f r) s (g x)\n  ¬∑ intros z‚ÇÅ z‚ÇÇ\n    change lift _ (z‚ÇÅ + z‚ÇÇ) = lift _ z‚ÇÅ + lift _ z‚ÇÇ\n    rw [map_add]\n  ¬∑ intro s z\n    change lift _ (s ‚Ä¢ z) = s ‚Ä¢ lift _ z\n    induction z using TensorProduct.induction_on with\n    | zero => rw [smul_zero, map_zero, smul_zero]\n    | tmul s' x =>\n      rw [LinearMap.coe_mk, ExtendScalars.smul_tmul]\n      erw [lift.tmul, lift.tmul]\n      set s' : S := s'\n      change (s * s') ‚Ä¢ (g x) = s ‚Ä¢ s' ‚Ä¢ (g x)\n      rw [mul_smul]\n    | add _ _ ih1 ih2 => rw [smul_add, map_add, ih1, ih2, map_add, smul_add]\n\n"}
{"name":"ModuleCat.ExtendRestrictScalarsAdj.homEquiv_symm_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nX : ModuleCat R\nY : ModuleCat S\ng : Quiver.Hom X ((ModuleCat.restrictScalars f).obj Y)\n‚ä¢ Eq ((ModuleCat.ExtendRestrictScalarsAdj.homEquiv f).symm g) (ModuleCat.ExtendRestrictScalarsAdj.HomEquiv.fromExtendScalars f g)","decl":"/-- Given `R`-module X and `S`-module Y, `S`-linear linear maps `(extendScalars f).obj X ‚ü∂ Y`\nbijectively correspond to `R`-linear maps `X ‚ü∂ (restrictScalars f).obj Y`.\n-/\n@[simps symm_apply]\ndef homEquiv {X Y} :\n    ((extendScalars f).obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ (restrictScalars.{max v u‚ÇÇ,u‚ÇÅ,u‚ÇÇ} f).obj Y) where\n  toFun := HomEquiv.toRestrictScalars.{u‚ÇÅ,u‚ÇÇ,v} f\n  invFun := HomEquiv.fromExtendScalars.{u‚ÇÅ,u‚ÇÇ,v} f\n  left_inv g := by\n    letI m1 : Module R S := Module.compHom S f; letI m2 : Module R Y := Module.compHom Y f\n    apply hom_ext\n    apply LinearMap.ext; intro z\n    induction z using TensorProduct.induction_on with\n    | zero => rw [map_zero, map_zero]\n    | tmul x s =>\n      erw [TensorProduct.lift.tmul]\n      simp only [LinearMap.coe_mk]\n      change S at x\n      dsimp\n      erw [‚Üê LinearMap.map_smul, ExtendScalars.smul_tmul, mul_one x]\n      rfl\n    | add _ _ ih1 ih2 => rw [map_add, map_add, ih1, ih2]\n  right_inv g := by\n    letI m1 : Module R S := Module.compHom S f; letI m2 : Module R Y := Module.compHom Y f\n    ext x\n    rw [HomEquiv.toRestrictScalars_hom_apply]\n    -- This needs to be `erw` because of some unfolding in `fromExtendScalars`\n    erw [HomEquiv.fromExtendScalars_hom_apply]\n    rw [lift.tmul, LinearMap.coe_mk, LinearMap.coe_mk]\n    dsimp\n    rw [one_smul]\n\n"}
{"name":"ModuleCat.ExtendRestrictScalarsAdj.unit_app","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nx‚úù : ModuleCat R\n‚ä¢ Eq ((ModuleCat.ExtendRestrictScalarsAdj.unit f).app x‚úù) (ModuleCat.ExtendRestrictScalarsAdj.Unit.map f)","decl":"/--\nThe natural transformation from identity functor on `R`-module to the composition of extension and\nrestriction of scalars.\n-/\n@[simps]\ndef unit : ùü≠ (ModuleCat R) ‚ü∂ extendScalars f ‚ãô restrictScalars.{max v u‚ÇÇ,u‚ÇÅ,u‚ÇÇ} f where\n  app _ := Unit.map.{u‚ÇÅ,u‚ÇÇ,v} f\n\n"}
{"name":"ModuleCat.ExtendRestrictScalarsAdj.Counit.map_hom_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nY : ModuleCat S\na : TensorProduct R S ‚ÜëY\n‚ä¢ Eq ((ModuleCat.Hom.hom (ModuleCat.ExtendRestrictScalarsAdj.Counit.map f)) a) ((TensorProduct.lift { toFun := fun s => { toFun := fun y => HSMul.hSMul s y, map_add' := ‚ãØ, map_smul' := ‚ãØ }, map_add' := ‚ãØ, map_smul' := ‚ãØ }) a)","decl":"/-- For any `S`-module Y, there is a natural `R`-linear map from `S ‚®Ç Y` to `Y` by\n`s ‚äó y ‚Ü¶ s ‚Ä¢ y` -/\n@[simps! hom_apply]\ndef Counit.map {Y} : (restrictScalars f ‚ãô extendScalars f).obj Y ‚ü∂ Y :=\n  ofHom\n  { toFun :=\n      letI m1 : Module R S := Module.compHom S f\n      letI m2 : Module R Y := Module.compHom Y f\n      TensorProduct.lift\n      { toFun := fun s : S =>\n        { toFun := fun y : Y => s ‚Ä¢ y,\n          map_add' := smul_add _\n          map_smul' := fun r y => by\n            change s ‚Ä¢ f r ‚Ä¢ y = f r ‚Ä¢ s ‚Ä¢ y\n            rw [‚Üê mul_smul, mul_comm, mul_smul] },\n        map_add' := fun s‚ÇÅ s‚ÇÇ => by\n          ext y\n          change (s‚ÇÅ + s‚ÇÇ) ‚Ä¢ y = s‚ÇÅ ‚Ä¢ y + s‚ÇÇ ‚Ä¢ y\n          rw [add_smul]\n        map_smul' := fun r s => by\n          ext y\n          change (f r ‚Ä¢ s) ‚Ä¢ y = (f r) ‚Ä¢ s ‚Ä¢ y\n          rw [smul_eq_mul, mul_smul] }\n    map_add' := fun _ _ => by rw [map_add]\n    map_smul' := fun s z => by\n      letI m1 : Module R S := Module.compHom S f\n      letI m2 : Module R Y := Module.compHom Y f\n      dsimp only\n      induction z using TensorProduct.induction_on with\n      | zero => rw [smul_zero, map_zero, smul_zero]\n      | tmul s' y =>\n        rw [ExtendScalars.smul_tmul, LinearMap.coe_mk]\n        erw [TensorProduct.lift.tmul, TensorProduct.lift.tmul]\n        set s' : S := s'\n        change (s * s') ‚Ä¢ y = s ‚Ä¢ s' ‚Ä¢ y\n        rw [mul_smul]\n      | add _ _ ih1 ih2 => rw [smul_add, map_add, map_add, ih1, ih2, smul_add] }\n\n"}
{"name":"ModuleCat.ExtendRestrictScalarsAdj.counit_app","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nx‚úù : ModuleCat S\n‚ä¢ Eq ((ModuleCat.ExtendRestrictScalarsAdj.counit f).app x‚úù) (ModuleCat.ExtendRestrictScalarsAdj.Counit.map f)","decl":"/-- The natural transformation from the composition of restriction and extension of scalars to the\nidentity functor on `S`-module.\n-/\n@[simps app]\ndef counit : restrictScalars.{max v u‚ÇÇ,u‚ÇÅ,u‚ÇÇ} f ‚ãô extendScalars f ‚ü∂ ùü≠ (ModuleCat S) where\n  app _ := Counit.map.{u‚ÇÅ,u‚ÇÇ,v} f\n  naturality Y Y' g := by\n    -- Porting note: this is very annoying; fix instances in concrete categories\n    letI m1 : Module R S := Module.compHom S f\n    letI m2 : Module R Y := Module.compHom Y f\n    letI m2 : Module R Y' := Module.compHom Y' f\n    ext z\n    induction z using TensorProduct.induction_on with\n    | zero => rw [map_zero, map_zero]\n    | tmul s' y =>\n      dsimp\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      erw [Counit.map_hom_apply]\n      rw [lift.tmul, LinearMap.coe_mk, LinearMap.coe_mk]\n      set s' : S := s'\n      change s' ‚Ä¢ g y = g (s' ‚Ä¢ y)\n      rw [map_smul]\n    | add _ _ ih‚ÇÅ ih‚ÇÇ => rw [map_add, map_add]; congr 1\n"}
{"name":"ModuleCat.extendRestrictScalarsAdj_homEquiv_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nM : ModuleCat R\nN : ModuleCat S\nœÜ : Quiver.Hom ((ModuleCat.extendScalars f).obj M) N\nm : ‚ÜëM\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (((ModuleCat.extendRestrictScalarsAdj f).homEquiv M N) œÜ)) m) ((CategoryTheory.ConcreteCategory.hom œÜ) (TensorProduct.tmul R 1 m))","decl":"lemma extendRestrictScalarsAdj_homEquiv_apply\n    {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [CommRing R] [CommRing S]\n    {f : R ‚Üí+* S} {M : ModuleCat.{max v u‚ÇÇ} R} {N : ModuleCat S}\n    (œÜ : (extendScalars f).obj M ‚ü∂ N) (m : M):\n    (extendRestrictScalarsAdj f).homEquiv _ _ œÜ m = œÜ ((1 : S) ‚äó‚Çú m) :=\n  rfl\n\n"}
{"name":"ModuleCat.extendRestrictScalarsAdj_unit_app_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\nM : ModuleCat R\nm : ‚ÜëM\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom ((ModuleCat.extendRestrictScalarsAdj f).unit.app M)) m) (TensorProduct.tmul R 1 m)","decl":"lemma extendRestrictScalarsAdj_unit_app_apply\n    {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [CommRing R] [CommRing S]\n    (f : R ‚Üí+* S) (M : ModuleCat.{max v u‚ÇÇ} R) (m : M):\n    (extendRestrictScalarsAdj f).unit.app M m = (1 : S) ‚äó‚Çú[R,f] m :=\n  rfl\n\n"}
{"name":"ModuleCat.instIsLeftAdjointExtendScalars","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\n‚ä¢ (ModuleCat.extendScalars f).IsLeftAdjoint","decl":"instance {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [CommRing R] [CommRing S] (f : R ‚Üí+* S) :\n    (extendScalars.{u‚ÇÅ, u‚ÇÇ, max u‚ÇÇ w} f).IsLeftAdjoint :=\n  (extendRestrictScalarsAdj f).isLeftAdjoint\n\n"}
{"name":"ModuleCat.instIsRightAdjointRestrictScalars","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\nS : Type u‚ÇÇ\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nf : RingHom R S\n‚ä¢ (ModuleCat.restrictScalars f).IsRightAdjoint","decl":"instance {R : Type u‚ÇÅ} {S : Type u‚ÇÇ} [CommRing R] [CommRing S] (f : R ‚Üí+* S) :\n    (restrictScalars.{max u‚ÇÇ w, u‚ÇÅ, u‚ÇÇ} f).IsRightAdjoint :=\n  (extendRestrictScalarsAdj f).isRightAdjoint\n\n"}
{"name":"ModuleCat.preservesLimit_restrictScalars","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u_1\nS : Type u_2\ninst‚úù¬≥ : Ring R\ninst‚úù¬≤ : Ring S\nf : RingHom R S\nJ : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_3} J\nF : CategoryTheory.Functor J (ModuleCat S)\ninst‚úù : Small.{v, max u_3 v} ‚Üë(F.comp (CategoryTheory.forget (ModuleCat S))).sections\n‚ä¢ CategoryTheory.Limits.PreservesLimit F (ModuleCat.restrictScalars f)","decl":"noncomputable instance preservesLimit_restrictScalars\n    {R : Type*} {S : Type*} [Ring R] [Ring S] (f : R ‚Üí+* S) {J : Type*} [Category J]\n    (F : J ‚•§ ModuleCat.{v} S) [Small.{v} (F ‚ãô forget _).sections] :\n    PreservesLimit F (restrictScalars f) :=\n  ‚ü®fun {c} hc => ‚ü®by\n    have hc' := isLimitOfPreserves (forget‚ÇÇ _ AddCommGrp) hc\n    exact isLimitOfReflects (forget‚ÇÇ _ AddCommGrp) hc'‚ü©‚ü©\n\n"}
{"name":"ModuleCat.preservesColimit_restrictScalars","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u_1\nS : Type u_2\ninst‚úù¬≥ : Ring R\ninst‚úù¬≤ : Ring S\nf : RingHom R S\nJ : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_3} J\nF : CategoryTheory.Functor J (ModuleCat S)\ninst‚úù : CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.forget‚ÇÇ (ModuleCat S) AddCommGrp))\n‚ä¢ CategoryTheory.Limits.PreservesColimit F (ModuleCat.restrictScalars f)","decl":"instance preservesColimit_restrictScalars {R S : Type*} [Ring R] [Ring S]\n    (f : R ‚Üí+* S) {J : Type*} [Category J] (F : J ‚•§ ModuleCat.{v} S)\n    [HasColimit (F ‚ãô forget‚ÇÇ _ AddCommGrp)] :\n    PreservesColimit F (ModuleCat.restrictScalars.{v} f) := by\n  have : HasColimit ((F ‚ãô restrictScalars f) ‚ãô forget‚ÇÇ (ModuleCat R) AddCommGrp) :=\n    inferInstanceAs (HasColimit (F ‚ãô forget‚ÇÇ _ AddCommGrp))\n  apply preservesColimit_of_preserves_colimit_cocone (HasColimit.isColimitColimitCocone F)\n  apply isColimitOfReflects (forget‚ÇÇ _ AddCommGrp)\n  apply isColimitOfPreserves (forget‚ÇÇ (ModuleCat.{v} S) AddCommGrp.{v})\n  exact HasColimit.isColimitColimitCocone F\n\n"}
{"name":"ModuleCat.extendScalarsId_inv_app_apply","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\ninst‚úù : CommRing R\nM : ModuleCat R\nm : ‚ÜëM\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom ((ModuleCat.extendScalarsId R).inv.app M)) m) (TensorProduct.tmul R 1 m)","decl":"lemma extendScalarsId_inv_app_apply (M : ModuleCat R) (m : M):\n    (extendScalarsId R).inv.app M m = (1 : R) ‚äó‚Çú m := rfl\n\n"}
{"name":"ModuleCat.homEquiv_extendScalarsId","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\ninst‚úù : CommRing R\nM : ModuleCat R\n‚ä¢ Eq (((ModuleCat.extendRestrictScalarsAdj (RingHom.id R)).homEquiv M ((CategoryTheory.Functor.id (ModuleCat R)).obj M)) ((ModuleCat.extendScalarsId R).hom.app M)) ((ModuleCat.restrictScalarsId R).inv.app M)","decl":"lemma homEquiv_extendScalarsId (M : ModuleCat R) :\n    (extendRestrictScalarsAdj (RingHom.id R)).homEquiv _ _ ((extendScalarsId R).hom.app M) =\n      (restrictScalarsId R).inv.app M := by\n  ext m\n  rw [extendRestrictScalarsAdj_homEquiv_apply, ‚Üê extendScalarsId_inv_app_apply, ‚Üê comp_apply]\n  simp\n\n"}
{"name":"ModuleCat.extendScalarsId_hom_app_one_tmul","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R : Type u‚ÇÅ\ninst‚úù : CommRing R\nM : ModuleCat R\nm : ‚ÜëM\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom ((ModuleCat.extendScalarsId R).hom.app M)) (TensorProduct.tmul R 1 m)) m","decl":"lemma extendScalarsId_hom_app_one_tmul (M : ModuleCat R) (m : M) :\n    (extendScalarsId R).hom.app M ((1 : R) ‚äó‚Çú m) = m := by\n  rw [‚Üê extendRestrictScalarsAdj_homEquiv_apply,\n    homEquiv_extendScalarsId]\n  dsimp\n\n"}
{"name":"ModuleCat.homEquiv_extendScalarsComp","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ R‚ÇÇ R‚ÇÉ : Type u‚ÇÅ\ninst‚úù¬≤ : CommRing R‚ÇÅ\ninst‚úù¬π : CommRing R‚ÇÇ\ninst‚úù : CommRing R‚ÇÉ\nf‚ÇÅ‚ÇÇ : RingHom R‚ÇÅ R‚ÇÇ\nf‚ÇÇ‚ÇÉ : RingHom R‚ÇÇ R‚ÇÉ\nM : ModuleCat R‚ÇÅ\n‚ä¢ Eq (((ModuleCat.extendRestrictScalarsAdj (f‚ÇÇ‚ÇÉ.comp f‚ÇÅ‚ÇÇ)).homEquiv M (((ModuleCat.extendScalars f‚ÇÅ‚ÇÇ).comp (ModuleCat.extendScalars f‚ÇÇ‚ÇÉ)).obj M)) ((ModuleCat.extendScalarsComp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ).hom.app M)) (CategoryTheory.CategoryStruct.comp ((ModuleCat.extendRestrictScalarsAdj f‚ÇÅ‚ÇÇ).unit.app M) (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars f‚ÇÅ‚ÇÇ).map ((ModuleCat.extendRestrictScalarsAdj f‚ÇÇ‚ÇÉ).unit.app (ModuleCat.ExtendScalars.obj' f‚ÇÅ‚ÇÇ M))) ((ModuleCat.restrictScalarsComp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ).inv.app ((ModuleCat.extendScalars f‚ÇÇ‚ÇÉ).obj (ModuleCat.ExtendScalars.obj' f‚ÇÅ‚ÇÇ M)))))","decl":"lemma homEquiv_extendScalarsComp (M : ModuleCat R‚ÇÅ) :\n    (extendRestrictScalarsAdj (f‚ÇÇ‚ÇÉ.comp f‚ÇÅ‚ÇÇ)).homEquiv _ _\n      ((extendScalarsComp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ).hom.app M) =\n      (extendRestrictScalarsAdj f‚ÇÅ‚ÇÇ).unit.app M ‚â´\n        (restrictScalars f‚ÇÅ‚ÇÇ).map ((extendRestrictScalarsAdj f‚ÇÇ‚ÇÉ).unit.app _) ‚â´\n        (restrictScalarsComp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ).inv.app _ := by\n  dsimp [extendScalarsComp, conjugateIsoEquiv, conjugateEquiv]\n  simp only [Category.assoc, Category.id_comp, Category.comp_id,\n    Adjunction.comp_unit_app, Adjunction.homEquiv_unit,\n    Functor.map_comp, Adjunction.unit_naturality_assoc,\n    Adjunction.right_triangle_components]\n  rfl\n\n"}
{"name":"ModuleCat.extendScalarsComp_hom_app_one_tmul","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ R‚ÇÇ R‚ÇÉ : Type u‚ÇÅ\ninst‚úù¬≤ : CommRing R‚ÇÅ\ninst‚úù¬π : CommRing R‚ÇÇ\ninst‚úù : CommRing R‚ÇÉ\nf‚ÇÅ‚ÇÇ : RingHom R‚ÇÅ R‚ÇÇ\nf‚ÇÇ‚ÇÉ : RingHom R‚ÇÇ R‚ÇÉ\nM : ModuleCat R‚ÇÅ\nm : ‚ÜëM\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom ((ModuleCat.extendScalarsComp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ).hom.app M)) (TensorProduct.tmul R‚ÇÅ 1 m)) (TensorProduct.tmul R‚ÇÇ 1 (TensorProduct.tmul R‚ÇÅ 1 m))","decl":"lemma extendScalarsComp_hom_app_one_tmul (M : ModuleCat R‚ÇÅ) (m : M) :\n    (extendScalarsComp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ).hom.app M ((1 : R‚ÇÉ) ‚äó‚Çú m) =\n      (1 : R‚ÇÉ) ‚äó‚Çú[R‚ÇÇ,f‚ÇÇ‚ÇÉ] ((1 : R‚ÇÇ) ‚äó‚Çú[R‚ÇÅ,f‚ÇÅ‚ÇÇ] m) := by\n  rw [‚Üê extendRestrictScalarsAdj_homEquiv_apply, homEquiv_extendScalarsComp]\n  rfl\n\n"}
{"name":"ModuleCat.extendScalars_assoc_assoc","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ R‚ÇÇ R‚ÇÉ R‚ÇÑ : Type u‚ÇÅ\ninst‚úù¬≥ : CommRing R‚ÇÅ\ninst‚úù¬≤ : CommRing R‚ÇÇ\ninst‚úù¬π : CommRing R‚ÇÉ\ninst‚úù : CommRing R‚ÇÑ\nf‚ÇÅ‚ÇÇ : RingHom R‚ÇÅ R‚ÇÇ\nf‚ÇÇ‚ÇÉ : RingHom R‚ÇÇ R‚ÇÉ\nf‚ÇÉ‚ÇÑ : RingHom R‚ÇÉ R‚ÇÑ\nZ : CategoryTheory.Functor (ModuleCat R‚ÇÅ) (ModuleCat R‚ÇÑ)\nh : Quiver.Hom (((ModuleCat.extendScalars f‚ÇÅ‚ÇÇ).comp (ModuleCat.extendScalars f‚ÇÇ‚ÇÉ)).comp (ModuleCat.extendScalars f‚ÇÉ‚ÇÑ)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (ModuleCat.extendScalarsComp (f‚ÇÇ‚ÇÉ.comp f‚ÇÅ‚ÇÇ) f‚ÇÉ‚ÇÑ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (ModuleCat.extendScalarsComp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ).hom (ModuleCat.extendScalars f‚ÇÉ‚ÇÑ)) h)) (CategoryTheory.CategoryStruct.comp (ModuleCat.extendScalarsComp f‚ÇÅ‚ÇÇ (f‚ÇÉ‚ÇÑ.comp f‚ÇÇ‚ÇÉ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (ModuleCat.extendScalars f‚ÇÅ‚ÇÇ) (ModuleCat.extendScalarsComp f‚ÇÇ‚ÇÉ f‚ÇÉ‚ÇÑ).hom) (CategoryTheory.CategoryStruct.comp ((ModuleCat.extendScalars f‚ÇÅ‚ÇÇ).associator (ModuleCat.extendScalars f‚ÇÇ‚ÇÉ) (ModuleCat.extendScalars f‚ÇÉ‚ÇÑ)).inv h)))","decl":"@[reassoc]\nlemma extendScalars_assoc :\n    (extendScalarsComp (f‚ÇÇ‚ÇÉ.comp f‚ÇÅ‚ÇÇ) f‚ÇÉ‚ÇÑ).hom ‚â´ whiskerRight (extendScalarsComp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ).hom _ =\n      (extendScalarsComp f‚ÇÅ‚ÇÇ (f‚ÇÉ‚ÇÑ.comp f‚ÇÇ‚ÇÉ)).hom ‚â´ whiskerLeft _ (extendScalarsComp f‚ÇÇ‚ÇÉ f‚ÇÉ‚ÇÑ).hom ‚â´\n        (Functor.associator _ _ _).inv := by\n  ext M m\n  have h‚ÇÅ := extendScalarsComp_hom_app_one_tmul (f‚ÇÇ‚ÇÉ.comp f‚ÇÅ‚ÇÇ) f‚ÇÉ‚ÇÑ M m\n  have h‚ÇÇ := extendScalarsComp_hom_app_one_tmul f‚ÇÅ‚ÇÇ (f‚ÇÉ‚ÇÑ.comp f‚ÇÇ‚ÇÉ) M m\n  have h‚ÇÉ := extendScalarsComp_hom_app_one_tmul f‚ÇÇ‚ÇÉ f‚ÇÉ‚ÇÑ\n  have h‚ÇÑ := extendScalarsComp_hom_app_one_tmul f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ M m\n  dsimp at h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ ‚ä¢\n  rw [h‚ÇÅ]\n  erw [h‚ÇÇ]\n  rw [h‚ÇÉ, ExtendScalars.map_tmul, h‚ÇÑ]\n\n"}
{"name":"ModuleCat.extendScalars_assoc","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ R‚ÇÇ R‚ÇÉ R‚ÇÑ : Type u‚ÇÅ\ninst‚úù¬≥ : CommRing R‚ÇÅ\ninst‚úù¬≤ : CommRing R‚ÇÇ\ninst‚úù¬π : CommRing R‚ÇÉ\ninst‚úù : CommRing R‚ÇÑ\nf‚ÇÅ‚ÇÇ : RingHom R‚ÇÅ R‚ÇÇ\nf‚ÇÇ‚ÇÉ : RingHom R‚ÇÇ R‚ÇÉ\nf‚ÇÉ‚ÇÑ : RingHom R‚ÇÉ R‚ÇÑ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (ModuleCat.extendScalarsComp (f‚ÇÇ‚ÇÉ.comp f‚ÇÅ‚ÇÇ) f‚ÇÉ‚ÇÑ).hom (CategoryTheory.whiskerRight (ModuleCat.extendScalarsComp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ).hom (ModuleCat.extendScalars f‚ÇÉ‚ÇÑ))) (CategoryTheory.CategoryStruct.comp (ModuleCat.extendScalarsComp f‚ÇÅ‚ÇÇ (f‚ÇÉ‚ÇÑ.comp f‚ÇÇ‚ÇÉ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (ModuleCat.extendScalars f‚ÇÅ‚ÇÇ) (ModuleCat.extendScalarsComp f‚ÇÇ‚ÇÉ f‚ÇÉ‚ÇÑ).hom) ((ModuleCat.extendScalars f‚ÇÅ‚ÇÇ).associator (ModuleCat.extendScalars f‚ÇÇ‚ÇÉ) (ModuleCat.extendScalars f‚ÇÉ‚ÇÑ)).inv))","decl":"@[reassoc]\nlemma extendScalars_assoc :\n    (extendScalarsComp (f‚ÇÇ‚ÇÉ.comp f‚ÇÅ‚ÇÇ) f‚ÇÉ‚ÇÑ).hom ‚â´ whiskerRight (extendScalarsComp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ).hom _ =\n      (extendScalarsComp f‚ÇÅ‚ÇÇ (f‚ÇÉ‚ÇÑ.comp f‚ÇÇ‚ÇÉ)).hom ‚â´ whiskerLeft _ (extendScalarsComp f‚ÇÇ‚ÇÉ f‚ÇÉ‚ÇÑ).hom ‚â´\n        (Functor.associator _ _ _).inv := by\n  ext M m\n  have h‚ÇÅ := extendScalarsComp_hom_app_one_tmul (f‚ÇÇ‚ÇÉ.comp f‚ÇÅ‚ÇÇ) f‚ÇÉ‚ÇÑ M m\n  have h‚ÇÇ := extendScalarsComp_hom_app_one_tmul f‚ÇÅ‚ÇÇ (f‚ÇÉ‚ÇÑ.comp f‚ÇÇ‚ÇÉ) M m\n  have h‚ÇÉ := extendScalarsComp_hom_app_one_tmul f‚ÇÇ‚ÇÉ f‚ÇÉ‚ÇÑ\n  have h‚ÇÑ := extendScalarsComp_hom_app_one_tmul f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ M m\n  dsimp at h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ ‚ä¢\n  rw [h‚ÇÅ]\n  erw [h‚ÇÇ]\n  rw [h‚ÇÉ, ExtendScalars.map_tmul, h‚ÇÑ]\n\n"}
{"name":"ModuleCat.extendScalars_assoc'","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ R‚ÇÇ R‚ÇÉ R‚ÇÑ : Type u‚ÇÅ\ninst‚úù¬≥ : CommRing R‚ÇÅ\ninst‚úù¬≤ : CommRing R‚ÇÇ\ninst‚úù¬π : CommRing R‚ÇÉ\ninst‚úù : CommRing R‚ÇÑ\nf‚ÇÅ‚ÇÇ : RingHom R‚ÇÅ R‚ÇÇ\nf‚ÇÇ‚ÇÉ : RingHom R‚ÇÇ R‚ÇÉ\nf‚ÇÉ‚ÇÑ : RingHom R‚ÇÉ R‚ÇÑ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (ModuleCat.extendScalarsComp (f‚ÇÇ‚ÇÉ.comp f‚ÇÅ‚ÇÇ) f‚ÇÉ‚ÇÑ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (ModuleCat.extendScalarsComp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ).hom (ModuleCat.extendScalars f‚ÇÉ‚ÇÑ)) (CategoryTheory.CategoryStruct.comp ((ModuleCat.extendScalars f‚ÇÅ‚ÇÇ).associator (ModuleCat.extendScalars f‚ÇÇ‚ÇÉ) (ModuleCat.extendScalars f‚ÇÉ‚ÇÑ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (ModuleCat.extendScalars f‚ÇÅ‚ÇÇ) (ModuleCat.extendScalarsComp f‚ÇÇ‚ÇÉ f‚ÇÉ‚ÇÑ).inv) (ModuleCat.extendScalarsComp f‚ÇÅ‚ÇÇ (f‚ÇÉ‚ÇÑ.comp f‚ÇÇ‚ÇÉ)).inv)))) (CategoryTheory.CategoryStruct.id (ModuleCat.extendScalars (f‚ÇÉ‚ÇÑ.comp (f‚ÇÇ‚ÇÉ.comp f‚ÇÅ‚ÇÇ))))","decl":"/-- The associativity compatibility for the extension of scalars, in the exact form\nthat is needed in the definition `CommRingCat.moduleCatExtendScalarsPseudofunctor`\nin the file `Algebra.Category.ModuleCat.Pseudofunctor` -/\nlemma extendScalars_assoc' :\n    (extendScalarsComp (f‚ÇÇ‚ÇÉ.comp f‚ÇÅ‚ÇÇ) f‚ÇÉ‚ÇÑ).hom ‚â´ whiskerRight (extendScalarsComp f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÉ).hom _ ‚â´\n      (Functor.associator _ _ _).hom ‚â´ whiskerLeft _ (extendScalarsComp f‚ÇÇ‚ÇÉ f‚ÇÉ‚ÇÑ).inv ‚â´\n        (extendScalarsComp f‚ÇÅ‚ÇÇ (f‚ÇÉ‚ÇÑ.comp f‚ÇÇ‚ÇÉ)).inv = ùüô _ := by\n  rw [extendScalars_assoc_assoc]\n  simp only [Iso.inv_hom_id_assoc, ‚Üê whiskerLeft_comp_assoc, Iso.hom_inv_id,\n    whiskerLeft_id', Category.id_comp]\n\n"}
{"name":"ModuleCat.extendScalars_id_comp_assoc","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ R‚ÇÇ : Type u‚ÇÅ\ninst‚úù¬π : CommRing R‚ÇÅ\ninst‚úù : CommRing R‚ÇÇ\nf‚ÇÅ‚ÇÇ : RingHom R‚ÇÅ R‚ÇÇ\nZ : CategoryTheory.Functor (ModuleCat R‚ÇÅ) (ModuleCat R‚ÇÇ)\nh : Quiver.Hom (ModuleCat.extendScalars f‚ÇÅ‚ÇÇ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (ModuleCat.extendScalarsComp (RingHom.id R‚ÇÅ) f‚ÇÅ‚ÇÇ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (ModuleCat.extendScalarsId R‚ÇÅ).hom (ModuleCat.extendScalars f‚ÇÅ‚ÇÇ)) (CategoryTheory.CategoryStruct.comp (ModuleCat.extendScalars f‚ÇÅ‚ÇÇ).leftUnitor.hom h))) h","decl":"@[reassoc]\nlemma extendScalars_id_comp :\n    (extendScalarsComp (RingHom.id R‚ÇÅ) f‚ÇÅ‚ÇÇ).hom ‚â´ whiskerRight (extendScalarsId R‚ÇÅ).hom _ ‚â´\n      (Functor.leftUnitor _).hom = ùüô _ := by\n  ext M m\n  dsimp\n  erw [extendScalarsComp_hom_app_one_tmul (RingHom.id R‚ÇÅ) f‚ÇÅ‚ÇÇ M m]\n  rw [ExtendScalars.map_tmul]\n  erw [extendScalarsId_hom_app_one_tmul]\n  rfl\n\n"}
{"name":"ModuleCat.extendScalars_id_comp","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ R‚ÇÇ : Type u‚ÇÅ\ninst‚úù¬π : CommRing R‚ÇÅ\ninst‚úù : CommRing R‚ÇÇ\nf‚ÇÅ‚ÇÇ : RingHom R‚ÇÅ R‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (ModuleCat.extendScalarsComp (RingHom.id R‚ÇÅ) f‚ÇÅ‚ÇÇ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (ModuleCat.extendScalarsId R‚ÇÅ).hom (ModuleCat.extendScalars f‚ÇÅ‚ÇÇ)) (ModuleCat.extendScalars f‚ÇÅ‚ÇÇ).leftUnitor.hom)) (CategoryTheory.CategoryStruct.id (ModuleCat.extendScalars (f‚ÇÅ‚ÇÇ.comp (RingHom.id R‚ÇÅ))))","decl":"@[reassoc]\nlemma extendScalars_id_comp :\n    (extendScalarsComp (RingHom.id R‚ÇÅ) f‚ÇÅ‚ÇÇ).hom ‚â´ whiskerRight (extendScalarsId R‚ÇÅ).hom _ ‚â´\n      (Functor.leftUnitor _).hom = ùüô _ := by\n  ext M m\n  dsimp\n  erw [extendScalarsComp_hom_app_one_tmul (RingHom.id R‚ÇÅ) f‚ÇÅ‚ÇÇ M m]\n  rw [ExtendScalars.map_tmul]\n  erw [extendScalarsId_hom_app_one_tmul]\n  rfl\n\n"}
{"name":"ModuleCat.extendScalars_comp_id_assoc","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ R‚ÇÇ : Type u‚ÇÅ\ninst‚úù¬π : CommRing R‚ÇÅ\ninst‚úù : CommRing R‚ÇÇ\nf‚ÇÅ‚ÇÇ : RingHom R‚ÇÅ R‚ÇÇ\nZ : CategoryTheory.Functor (ModuleCat R‚ÇÅ) (ModuleCat R‚ÇÇ)\nh : Quiver.Hom (ModuleCat.extendScalars f‚ÇÅ‚ÇÇ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (ModuleCat.extendScalarsComp f‚ÇÅ‚ÇÇ (RingHom.id R‚ÇÇ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (ModuleCat.extendScalars f‚ÇÅ‚ÇÇ) (ModuleCat.extendScalarsId R‚ÇÇ).hom) (CategoryTheory.CategoryStruct.comp (ModuleCat.extendScalars f‚ÇÅ‚ÇÇ).rightUnitor.hom h))) h","decl":"@[reassoc]\nlemma extendScalars_comp_id :\n    (extendScalarsComp f‚ÇÅ‚ÇÇ (RingHom.id R‚ÇÇ)).hom ‚â´ whiskerLeft _ (extendScalarsId R‚ÇÇ).hom ‚â´\n      (Functor.rightUnitor _).hom = ùüô _ := by\n  ext M m\n  dsimp\n  erw [extendScalarsComp_hom_app_one_tmul f‚ÇÅ‚ÇÇ (RingHom.id R‚ÇÇ) M m,\n    extendScalarsId_hom_app_one_tmul]\n  rfl\n\n"}
{"name":"ModuleCat.extendScalars_comp_id","module":"Mathlib.Algebra.Category.ModuleCat.ChangeOfRings","initialProofState":"R‚ÇÅ R‚ÇÇ : Type u‚ÇÅ\ninst‚úù¬π : CommRing R‚ÇÅ\ninst‚úù : CommRing R‚ÇÇ\nf‚ÇÅ‚ÇÇ : RingHom R‚ÇÅ R‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (ModuleCat.extendScalarsComp f‚ÇÅ‚ÇÇ (RingHom.id R‚ÇÇ)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (ModuleCat.extendScalars f‚ÇÅ‚ÇÇ) (ModuleCat.extendScalarsId R‚ÇÇ).hom) (ModuleCat.extendScalars f‚ÇÅ‚ÇÇ).rightUnitor.hom)) (CategoryTheory.CategoryStruct.id (ModuleCat.extendScalars ((RingHom.id R‚ÇÇ).comp f‚ÇÅ‚ÇÇ)))","decl":"@[reassoc]\nlemma extendScalars_comp_id :\n    (extendScalarsComp f‚ÇÅ‚ÇÇ (RingHom.id R‚ÇÇ)).hom ‚â´ whiskerLeft _ (extendScalarsId R‚ÇÇ).hom ‚â´\n      (Functor.rightUnitor _).hom = ùüô _ := by\n  ext M m\n  dsimp\n  erw [extendScalarsComp_hom_app_one_tmul f‚ÇÅ‚ÇÇ (RingHom.id R‚ÇÇ) M m,\n    extendScalarsId_hom_app_one_tmul]\n  rfl\n\n"}
