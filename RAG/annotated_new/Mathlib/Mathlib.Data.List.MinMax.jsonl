{"name":"List.foldl_argAux_eq_none","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : DecidableRel r\nl : List α\no : Option α\n⊢ Iff (Eq (List.foldl (List.argAux r) o l) Option.none) (And (Eq l List.nil) (Eq o Option.none))","decl":"@[simp]\ntheorem foldl_argAux_eq_none : l.foldl (argAux r) o = none ↔ l = [] ∧ o = none :=\n  List.reverseRecOn l (by simp) fun tl hd => by\n    simp only [foldl_append, foldl_cons, argAux, foldl_nil, append_eq_nil_iff, and_false, false_and,\n      iff_false]\n    cases foldl (argAux r) o tl\n    · simp\n    · simp only [false_iff, not_and]\n      split_ifs <;> simp\n\n"}
{"name":"List.argAux_self","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : DecidableRel r\nhr₀ : Irreflexive r\na : α\n⊢ Eq (List.argAux r (Option.some a) a) (Option.some a)","decl":"@[simp]\ntheorem argAux_self (hr₀ : Irreflexive r) (a : α) : argAux r (some a) a = a :=\n  if_neg <| hr₀ _\n\n"}
{"name":"List.not_of_mem_foldl_argAux","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : DecidableRel r\nl : List α\nhr₀ : Irreflexive r\nhr₁ : Transitive r\na m : α\no : Option α\na✝¹ : Membership.mem l a\na✝ : Membership.mem (List.foldl (List.argAux r) o l) m\n⊢ Not (r a m)","decl":"theorem not_of_mem_foldl_argAux (hr₀ : Irreflexive r) (hr₁ : Transitive r) :\n    ∀ {a m : α} {o : Option α}, a ∈ l → m ∈ foldl (argAux r) o l → ¬r a m := by\n  induction' l using List.reverseRecOn with tl a ih\n  · simp\n  intro b m o hb ho\n  rw [foldl_append, foldl_cons, foldl_nil, argAux] at ho\n  cases' hf : foldl (argAux r) o tl with c\n  · rw [hf] at ho\n    rw [foldl_argAux_eq_none] at hf\n    simp_all [hf.1, hf.2, hr₀ _]\n  rw [hf, Option.mem_def] at ho\n  dsimp only at ho\n  split_ifs at ho with hac <;> cases' mem_append.1 hb with h h <;>\n    injection ho with ho <;> subst ho\n  · exact fun hba => ih h hf (hr₁ hba hac)\n  · simp_all [hr₀ _]\n  · exact ih h hf\n  · simp_all\n\n"}
{"name":"List.argmax_nil","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nf : α → β\n⊢ Eq (List.argmax f List.nil) Option.none","decl":"@[simp]\ntheorem argmax_nil (f : α → β) : argmax f [] = none :=\n  rfl\n\n"}
{"name":"List.argmin_nil","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nf : α → β\n⊢ Eq (List.argmin f List.nil) Option.none","decl":"@[simp]\ntheorem argmin_nil (f : α → β) : argmin f [] = none :=\n  rfl\n\n"}
{"name":"List.argmax_singleton","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nf : α → β\na : α\n⊢ Eq (List.argmax f (List.cons a List.nil)) (Option.some a)","decl":"@[simp]\ntheorem argmax_singleton {f : α → β} {a : α} : argmax f [a] = a :=\n  rfl\n\n"}
{"name":"List.argmin_singleton","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nf : α → β\na : α\n⊢ Eq (List.argmin f (List.cons a List.nil)) (Option.some a)","decl":"@[simp]\ntheorem argmin_singleton {f : α → β} {a : α} : argmin f [a] = a :=\n  rfl\n\n"}
{"name":"List.not_lt_of_mem_argmax","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nf : α → β\nl : List α\na m : α\na✝¹ : Membership.mem l a\na✝ : Membership.mem (List.argmax f l) m\n⊢ Not (LT.lt (f m) (f a))","decl":"theorem not_lt_of_mem_argmax : a ∈ l → m ∈ argmax f l → ¬f m < f a :=\n  not_of_mem_foldl_argAux _ (fun x h => lt_irrefl (f x) h)\n    (fun _ _ z hxy hyz => lt_trans (a := f z) hyz hxy)\n\n"}
{"name":"List.not_lt_of_mem_argmin","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nf : α → β\nl : List α\na m : α\na✝¹ : Membership.mem l a\na✝ : Membership.mem (List.argmin f l) m\n⊢ Not (LT.lt (f a) (f m))","decl":"theorem not_lt_of_mem_argmin : a ∈ l → m ∈ argmin f l → ¬f a < f m :=\n  not_of_mem_foldl_argAux _ (fun x h => lt_irrefl (f x) h)\n    (fun x _ _ hxy hyz => lt_trans (a := f x) hxy hyz)\n\n"}
{"name":"List.argmax_concat","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nf : α → β\na : α\nl : List α\n⊢ Eq (List.argmax f (HAppend.hAppend l (List.cons a List.nil))) (Option.casesOn (List.argmax f l) (Option.some a) fun c => ite (LT.lt (f c) (f a)) (Option.some a) (Option.some c))","decl":"theorem argmax_concat (f : α → β) (a : α) (l : List α) :\n    argmax f (l ++ [a]) =\n      Option.casesOn (argmax f l) (some a) fun c => if f c < f a then some a else some c := by\n  rw [argmax, argmax]; simp [argAux]\n\n"}
{"name":"List.argmin_concat","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nf : α → β\na : α\nl : List α\n⊢ Eq (List.argmin f (HAppend.hAppend l (List.cons a List.nil))) (Option.casesOn (List.argmin f l) (Option.some a) fun c => ite (LT.lt (f a) (f c)) (Option.some a) (Option.some c))","decl":"theorem argmin_concat (f : α → β) (a : α) (l : List α) :\n    argmin f (l ++ [a]) =\n      Option.casesOn (argmin f l) (some a) fun c => if f a < f c then some a else some c :=\n  @argmax_concat _ βᵒᵈ _ _ _ _ _\n\n"}
{"name":"List.argmax_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nf : α → β\nl : List α\nm : α\na✝ : Membership.mem (List.argmax f l) m\n⊢ Membership.mem l m","decl":"theorem argmax_mem : ∀ {l : List α} {m : α}, m ∈ argmax f l → m ∈ l\n  | [], m => by simp\n  | hd :: tl, m => by simpa [argmax, argAux] using foldl_argAux_mem _ tl hd m\n\n"}
{"name":"List.argmin_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nf : α → β\nl : List α\nm : α\na✝ : Membership.mem (List.argmin f l) m\n⊢ Membership.mem l m","decl":"theorem argmin_mem : ∀ {l : List α} {m : α}, m ∈ argmin f l → m ∈ l :=\n  @argmax_mem _ βᵒᵈ _ _ _\n\n"}
{"name":"List.argmax_eq_none","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nf : α → β\nl : List α\n⊢ Iff (Eq (List.argmax f l) Option.none) (Eq l List.nil)","decl":"@[simp]\ntheorem argmax_eq_none : l.argmax f = none ↔ l = [] := by simp [argmax]\n\n"}
{"name":"List.argmin_eq_none","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nf : α → β\nl : List α\n⊢ Iff (Eq (List.argmin f l) Option.none) (Eq l List.nil)","decl":"@[simp]\ntheorem argmin_eq_none : l.argmin f = none ↔ l = [] :=\n  @argmax_eq_none _ βᵒᵈ _ _ _ _\n\n"}
{"name":"List.le_of_mem_argmax","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder β\nf : α → β\nl : List α\na m : α\na✝¹ : Membership.mem l a\na✝ : Membership.mem (List.argmax f l) m\n⊢ LE.le (f a) (f m)","decl":"theorem le_of_mem_argmax : a ∈ l → m ∈ argmax f l → f a ≤ f m := fun ha hm =>\n  le_of_not_lt <| not_lt_of_mem_argmax ha hm\n\n"}
{"name":"List.le_of_mem_argmin","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder β\nf : α → β\nl : List α\na m : α\na✝¹ : Membership.mem l a\na✝ : Membership.mem (List.argmin f l) m\n⊢ LE.le (f m) (f a)","decl":"theorem le_of_mem_argmin : a ∈ l → m ∈ argmin f l → f m ≤ f a :=\n  @le_of_mem_argmax _ βᵒᵈ _ _ _ _ _\n\n"}
{"name":"List.argmax_cons","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder β\nf : α → β\na : α\nl : List α\n⊢ Eq (List.argmax f (List.cons a l)) (Option.casesOn (List.argmax f l) (Option.some a) fun c => ite (LT.lt (f a) (f c)) (Option.some c) (Option.some a))","decl":"theorem argmax_cons (f : α → β) (a : α) (l : List α) :\n    argmax f (a :: l) =\n      Option.casesOn (argmax f l) (some a) fun c => if f a < f c then some c else some a :=\n  List.reverseRecOn l rfl fun hd tl ih => by\n    rw [← cons_append, argmax_concat, ih, argmax_concat]\n    cases' h : argmax f hd with m\n    · simp [h]\n    dsimp\n    rw [← apply_ite, ← apply_ite]\n    dsimp\n    split_ifs <;> try rfl\n    · exact absurd (lt_trans ‹f a < f m› ‹_›) ‹_›\n    · cases (‹f a < f tl›.lt_or_lt _).elim ‹_› ‹_›\n\n"}
{"name":"List.argmin_cons","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder β\nf : α → β\na : α\nl : List α\n⊢ Eq (List.argmin f (List.cons a l)) (Option.casesOn (List.argmin f l) (Option.some a) fun c => ite (LT.lt (f c) (f a)) (Option.some c) (Option.some a))","decl":"theorem argmin_cons (f : α → β) (a : α) (l : List α) :\n    argmin f (a :: l) =\n      Option.casesOn (argmin f l) (some a) fun c => if f c < f a then some c else some a :=\n  @argmax_cons α βᵒᵈ _ _ _ _\n\n"}
{"name":"List.index_of_argmax","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder β\nf : α → β\ninst✝ : DecidableEq α\nl : List α\nm : α\na✝² : Membership.mem (List.argmax f l) m\na : α\na✝¹ : Membership.mem l a\na✝ : LE.le (f m) (f a)\n⊢ LE.le (List.indexOf m l) (List.indexOf a l)","decl":"theorem index_of_argmax :\n    ∀ {l : List α} {m : α}, m ∈ argmax f l → ∀ {a}, a ∈ l → f m ≤ f a → l.indexOf m ≤ l.indexOf a\n  | [], m, _, _, _, _ => by simp\n  | hd :: tl, m, hm, a, ha, ham => by\n    simp only [indexOf_cons, argmax_cons, Option.mem_def] at hm ⊢\n    cases h : argmax f tl\n    · rw [h] at hm\n      simp_all\n    rw [h] at hm\n    dsimp only at hm\n    simp only [cond_eq_if, beq_iff_eq]\n    obtain ha | ha := ha <;> split_ifs at hm <;> injection hm with hm <;> subst hm\n    · cases not_le_of_lt ‹_› ‹_›\n    · rw [if_pos rfl]\n    · rw [if_neg, if_neg]\n      · exact Nat.succ_le_succ (index_of_argmax h (by assumption) ham)\n      · exact ne_of_apply_ne f (lt_of_lt_of_le ‹_› ‹_›).ne\n      · exact ne_of_apply_ne _ ‹f hd < f _›.ne\n    · rw [if_pos rfl]\n      exact Nat.zero_le _\n\n"}
{"name":"List.index_of_argmin","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder β\nf : α → β\ninst✝ : DecidableEq α\nl : List α\nm : α\na✝² : Membership.mem (List.argmin f l) m\na : α\na✝¹ : Membership.mem l a\na✝ : LE.le (f a) (f m)\n⊢ LE.le (List.indexOf m l) (List.indexOf a l)","decl":"theorem index_of_argmin :\n    ∀ {l : List α} {m : α}, m ∈ argmin f l → ∀ {a}, a ∈ l → f a ≤ f m → l.indexOf m ≤ l.indexOf a :=\n  @index_of_argmax _ βᵒᵈ _ _ _\n\n"}
{"name":"List.mem_argmax_iff","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder β\nf : α → β\nl : List α\nm : α\ninst✝ : DecidableEq α\n⊢ Iff (Membership.mem (List.argmax f l) m) (And (Membership.mem l m) (And (∀ (a : α), Membership.mem l a → LE.le (f a) (f m)) (∀ (a : α), Membership.mem l a → LE.le (f m) (f a) → LE.le (List.indexOf m l) (List.indexOf a l))))","decl":"theorem mem_argmax_iff :\n    m ∈ argmax f l ↔\n      m ∈ l ∧ (∀ a ∈ l, f a ≤ f m) ∧ ∀ a ∈ l, f m ≤ f a → l.indexOf m ≤ l.indexOf a :=\n  ⟨fun hm => ⟨argmax_mem hm, fun _ ha => le_of_mem_argmax ha hm, fun _ => index_of_argmax hm⟩,\n    by\n      rintro ⟨hml, ham, hma⟩\n      cases' harg : argmax f l with n\n      · simp_all\n      · have :=\n          _root_.le_antisymm (hma n (argmax_mem harg) (le_of_mem_argmax hml harg))\n            (index_of_argmax harg hml (ham _ (argmax_mem harg)))\n        rw [(indexOf_inj hml (argmax_mem harg)).1 this, Option.mem_def]⟩\n\n"}
{"name":"List.argmax_eq_some_iff","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder β\nf : α → β\nl : List α\nm : α\ninst✝ : DecidableEq α\n⊢ Iff (Eq (List.argmax f l) (Option.some m)) (And (Membership.mem l m) (And (∀ (a : α), Membership.mem l a → LE.le (f a) (f m)) (∀ (a : α), Membership.mem l a → LE.le (f m) (f a) → LE.le (List.indexOf m l) (List.indexOf a l))))","decl":"theorem argmax_eq_some_iff :\n    argmax f l = some m ↔\n      m ∈ l ∧ (∀ a ∈ l, f a ≤ f m) ∧ ∀ a ∈ l, f m ≤ f a → l.indexOf m ≤ l.indexOf a :=\n  mem_argmax_iff\n\n"}
{"name":"List.mem_argmin_iff","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder β\nf : α → β\nl : List α\nm : α\ninst✝ : DecidableEq α\n⊢ Iff (Membership.mem (List.argmin f l) m) (And (Membership.mem l m) (And (∀ (a : α), Membership.mem l a → LE.le (f m) (f a)) (∀ (a : α), Membership.mem l a → LE.le (f a) (f m) → LE.le (List.indexOf m l) (List.indexOf a l))))","decl":"theorem mem_argmin_iff :\n    m ∈ argmin f l ↔\n      m ∈ l ∧ (∀ a ∈ l, f m ≤ f a) ∧ ∀ a ∈ l, f a ≤ f m → l.indexOf m ≤ l.indexOf a :=\n  @mem_argmax_iff _ βᵒᵈ _ _ _ _ _\n\n"}
{"name":"List.argmin_eq_some_iff","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder β\nf : α → β\nl : List α\nm : α\ninst✝ : DecidableEq α\n⊢ Iff (Eq (List.argmin f l) (Option.some m)) (And (Membership.mem l m) (And (∀ (a : α), Membership.mem l a → LE.le (f m) (f a)) (∀ (a : α), Membership.mem l a → LE.le (f a) (f m) → LE.le (List.indexOf m l) (List.indexOf a l))))","decl":"theorem argmin_eq_some_iff :\n    argmin f l = some m ↔\n      m ∈ l ∧ (∀ a ∈ l, f m ≤ f a) ∧ ∀ a ∈ l, f a ≤ f m → l.indexOf m ≤ l.indexOf a :=\n  mem_argmin_iff\n\n"}
{"name":"List.maximum_nil","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\n⊢ Eq List.nil.maximum Bot.bot","decl":"@[simp]\ntheorem maximum_nil : maximum ([] : List α) = ⊥ :=\n  rfl\n\n"}
{"name":"List.minimum_nil","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\n⊢ Eq List.nil.minimum Top.top","decl":"@[simp]\ntheorem minimum_nil : minimum ([] : List α) = ⊤ :=\n  rfl\n\n"}
{"name":"List.maximum_singleton","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\na : α\n⊢ Eq (List.cons a List.nil).maximum ↑a","decl":"@[simp]\ntheorem maximum_singleton (a : α) : maximum [a] = a :=\n  rfl\n\n"}
{"name":"List.minimum_singleton","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\na : α\n⊢ Eq (List.cons a List.nil).minimum ↑a","decl":"@[simp]\ntheorem minimum_singleton (a : α) : minimum [a] = a :=\n  rfl\n\n"}
{"name":"List.maximum_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nl : List α\nm : α\na✝ : Eq l.maximum ↑m\n⊢ Membership.mem l m","decl":"theorem maximum_mem {l : List α} {m : α} : (maximum l : WithTop α) = m → m ∈ l :=\n  argmax_mem\n\n"}
{"name":"List.minimum_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nl : List α\nm : α\na✝ : Eq l.minimum ↑m\n⊢ Membership.mem l m","decl":"theorem minimum_mem {l : List α} {m : α} : (minimum l : WithBot α) = m → m ∈ l :=\n  argmin_mem\n\n"}
{"name":"List.maximum_eq_bot","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nl : List α\n⊢ Iff (Eq l.maximum Bot.bot) (Eq l List.nil)","decl":"@[simp]\ntheorem maximum_eq_bot {l : List α} : l.maximum = ⊥ ↔ l = [] :=\n  argmax_eq_none\n\n"}
{"name":"List.minimum_eq_top","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nl : List α\n⊢ Iff (Eq l.minimum Top.top) (Eq l List.nil)","decl":"@[simp]\ntheorem minimum_eq_top {l : List α} : l.minimum = ⊤ ↔ l = [] :=\n  argmin_eq_none\n\n"}
{"name":"List.not_maximum_lt_of_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nl : List α\na m : α\na✝¹ : Membership.mem l a\na✝ : Eq l.maximum ↑m\n⊢ Not (LT.lt m a)","decl":"theorem not_maximum_lt_of_mem : a ∈ l → (maximum l : WithBot α) = m → ¬m < a :=\n  not_lt_of_mem_argmax\n\n"}
{"name":"List.not_lt_maximum_of_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nl : List α\na m : α\na✝¹ : Membership.mem l a\na✝ : Eq l.maximum ↑m\n⊢ Not (LT.lt m a)","decl":"@[deprecated (since := \"2024-12-29\")] alias not_lt_maximum_of_mem := not_maximum_lt_of_mem\n\n"}
{"name":"List.not_lt_minimum_of_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nl : List α\na m : α\na✝¹ : Membership.mem l a\na✝ : Eq l.minimum ↑m\n⊢ Not (LT.lt a m)","decl":"theorem not_lt_minimum_of_mem : a ∈ l → (minimum l : WithTop α) = m → ¬a < m :=\n  not_lt_of_mem_argmin\n\n"}
{"name":"List.minimum_not_lt_of_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nl : List α\na m : α\na✝¹ : Membership.mem l a\na✝ : Eq l.minimum ↑m\n⊢ Not (LT.lt a m)","decl":"@[deprecated (since := \"2024-12-29\")] alias minimum_not_lt_of_mem := not_lt_minimum_of_mem\n\n"}
{"name":"List.not_maximum_lt_of_mem'","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nl : List α\na : α\nha : Membership.mem l a\n⊢ Not (LT.lt l.maximum ↑a)","decl":"theorem not_maximum_lt_of_mem' (ha : a ∈ l) : ¬maximum l < (a : WithBot α) := by\n  cases h : l.maximum <;> simp_all [not_maximum_lt_of_mem ha]\n\n"}
{"name":"List.not_lt_maximum_of_mem'","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nl : List α\na : α\nha : Membership.mem l a\n⊢ Not (LT.lt l.maximum ↑a)","decl":"@[deprecated (since := \"2024-12-29\")] alias not_lt_maximum_of_mem' := not_maximum_lt_of_mem'\n\n"}
{"name":"List.not_lt_minimum_of_mem'","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nl : List α\na : α\nha : Membership.mem l a\n⊢ Not (LT.lt (↑a) l.minimum)","decl":"theorem not_lt_minimum_of_mem' (ha : a ∈ l) : ¬(a : WithTop α) < minimum l := by\n  cases h : l.minimum <;> simp_all [not_lt_minimum_of_mem ha]\n\n"}
{"name":"List.maximum_concat","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\nl : List α\n⊢ Eq (HAppend.hAppend l (List.cons a List.nil)).maximum (Max.max l.maximum ↑a)","decl":"theorem maximum_concat (a : α) (l : List α) : maximum (l ++ [a]) = max (maximum l) a := by\n  simp only [maximum, argmax_concat, id]\n  cases argmax id l\n  · exact (max_eq_right bot_le).symm\n  · simp [WithBot.some_eq_coe, max_def_lt, WithBot.coe_lt_coe]\n\n"}
{"name":"List.le_maximum_of_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\na m : α\na✝¹ : Membership.mem l a\na✝ : Eq l.maximum ↑m\n⊢ LE.le a m","decl":"theorem le_maximum_of_mem : a ∈ l → (maximum l : WithBot α) = m → a ≤ m :=\n  le_of_mem_argmax\n\n"}
{"name":"List.minimum_le_of_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\na m : α\na✝¹ : Membership.mem l a\na✝ : Eq l.minimum ↑m\n⊢ LE.le m a","decl":"theorem minimum_le_of_mem : a ∈ l → (minimum l : WithTop α) = m → m ≤ a :=\n  le_of_mem_argmin\n\n"}
{"name":"List.le_maximum_of_mem'","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\na : α\nha : Membership.mem l a\n⊢ LE.le (↑a) l.maximum","decl":"theorem le_maximum_of_mem' (ha : a ∈ l) : (a : WithBot α) ≤ maximum l :=\n  le_of_not_lt <| not_maximum_lt_of_mem' ha\n\n"}
{"name":"List.minimum_le_of_mem'","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\na : α\nha : Membership.mem l a\n⊢ LE.le l.minimum ↑a","decl":"theorem minimum_le_of_mem' (ha : a ∈ l) : minimum l ≤ (a : WithTop α) :=\n  le_of_not_lt <| not_lt_minimum_of_mem' ha\n\n"}
{"name":"List.minimum_concat","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\nl : List α\n⊢ Eq (HAppend.hAppend l (List.cons a List.nil)).minimum (Min.min l.minimum ↑a)","decl":"theorem minimum_concat (a : α) (l : List α) : minimum (l ++ [a]) = min (minimum l) a :=\n  @maximum_concat αᵒᵈ _ _ _\n\n"}
{"name":"List.maximum_cons","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\nl : List α\n⊢ Eq (List.cons a l).maximum (Max.max (↑a) l.maximum)","decl":"theorem maximum_cons (a : α) (l : List α) : maximum (a :: l) = max ↑a (maximum l) :=\n  List.reverseRecOn l (by simp [@max_eq_left (WithBot α) _ _ _ bot_le]) fun tl hd ih => by\n    rw [← cons_append, maximum_concat, ih, maximum_concat, max_assoc]\n\n"}
{"name":"List.minimum_cons","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\nl : List α\n⊢ Eq (List.cons a l).minimum (Min.min (↑a) l.minimum)","decl":"theorem minimum_cons (a : α) (l : List α) : minimum (a :: l) = min ↑a (minimum l) :=\n  @maximum_cons αᵒᵈ _ _ _\n\n"}
{"name":"List.maximum_le_of_forall_le","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nb : WithBot α\nh : ∀ (a : α), Membership.mem l a → LE.le (↑a) b\n⊢ LE.le l.maximum b","decl":"theorem maximum_le_of_forall_le {b : WithBot α} (h : ∀ a ∈ l, a ≤ b) : l.maximum ≤ b := by\n  induction l with\n  | nil => simp\n  | cons a l ih =>\n    simp only [maximum_cons, max_le_iff]\n    exact ⟨h a (by simp), ih fun a w => h a (mem_cons.mpr (Or.inr w))⟩\n\n"}
{"name":"List.le_minimum_of_forall_le","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nb : WithTop α\nh : ∀ (a : α), Membership.mem l a → LE.le b ↑a\n⊢ LE.le b l.minimum","decl":"theorem le_minimum_of_forall_le {b : WithTop α} (h : ∀ a ∈ l, b ≤ a) : b ≤ l.minimum := by\n  induction l with\n  | nil => simp\n  | cons a l ih =>\n    simp only [minimum_cons, le_min_iff]\n    exact ⟨h a (by simp), ih fun a w => h a (mem_cons.mpr (Or.inr w))⟩\n\n"}
{"name":"List.maximum_eq_coe_iff","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nm : α\n⊢ Iff (Eq l.maximum ↑m) (And (Membership.mem l m) (∀ (a : α), Membership.mem l a → LE.le a m))","decl":"theorem maximum_eq_coe_iff : maximum l = m ↔ m ∈ l ∧ ∀ a ∈ l, a ≤ m := by\n  rw [maximum, ← WithBot.some_eq_coe, argmax_eq_some_iff]\n  simp only [id_eq, and_congr_right_iff, and_iff_left_iff_imp]\n  intro _ h a hal hma\n  rw [_root_.le_antisymm hma (h a hal)]\n\n"}
{"name":"List.minimum_eq_coe_iff","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nm : α\n⊢ Iff (Eq l.minimum ↑m) (And (Membership.mem l m) (∀ (a : α), Membership.mem l a → LE.le m a))","decl":"theorem minimum_eq_coe_iff : minimum l = m ↔ m ∈ l ∧ ∀ a ∈ l, m ≤ a :=\n  @maximum_eq_coe_iff αᵒᵈ _ _ _\n\n"}
{"name":"List.coe_le_maximum_iff","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\na : α\n⊢ Iff (LE.le (↑a) l.maximum) (Exists fun b => And (Membership.mem l b) (LE.le a b))","decl":"theorem coe_le_maximum_iff : a ≤ l.maximum ↔ ∃ b, b ∈ l ∧ a ≤ b := by\n  induction' l <;> simp [maximum_cons, *]\n\n"}
{"name":"List.minimum_le_coe_iff","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\na : α\n⊢ Iff (LE.le l.minimum ↑a) (Exists fun b => And (Membership.mem l b) (LE.le b a))","decl":"theorem minimum_le_coe_iff : l.minimum ≤ a ↔ ∃ b, b ∈ l ∧ b ≤ a := by\n  induction' l <;> simp [minimum_cons, *]\n\n"}
{"name":"List.maximum_ne_bot_of_ne_nil","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nh : Ne l List.nil\n⊢ Ne l.maximum Bot.bot","decl":"theorem maximum_ne_bot_of_ne_nil (h : l ≠ []) : l.maximum ≠ ⊥ :=\n  match l, h with | _ :: _, _ => by simp [maximum_cons]\n\n"}
{"name":"List.minimum_ne_top_of_ne_nil","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nh : Ne l List.nil\n⊢ Ne l.minimum Top.top","decl":"theorem minimum_ne_top_of_ne_nil (h : l ≠ []) : l.minimum ≠ ⊤ :=\n  @maximum_ne_bot_of_ne_nil αᵒᵈ _ _ h\n\n"}
{"name":"List.maximum_ne_bot_of_length_pos","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nh : LT.lt 0 l.length\n⊢ Ne l.maximum Bot.bot","decl":"theorem maximum_ne_bot_of_length_pos (h : 0 < l.length) : l.maximum ≠ ⊥ :=\n  match l, h with | _ :: _, _ => by simp [maximum_cons]\n\n"}
{"name":"List.minimum_ne_top_of_length_pos","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nh : LT.lt 0 l.length\n⊢ Ne l.minimum Top.top","decl":"theorem minimum_ne_top_of_length_pos (h : 0 < l.length) : l.minimum ≠ ⊤ :=\n  maximum_ne_bot_of_length_pos (α := αᵒᵈ) h\n\n"}
{"name":"List.coe_maximum_of_length_pos","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nh : LT.lt 0 l.length\n⊢ Eq (↑(List.maximum_of_length_pos h)) l.maximum","decl":"@[simp]\nlemma coe_maximum_of_length_pos (h : 0 < l.length) :\n    (l.maximum_of_length_pos h : α) = l.maximum :=\n  WithBot.coe_unbot _ _\n\n"}
{"name":"List.coe_minimum_of_length_pos","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nh : LT.lt 0 l.length\n⊢ Eq (↑(List.minimum_of_length_pos h)) l.minimum","decl":"@[simp]\nlemma coe_minimum_of_length_pos (h : 0 < l.length) :\n    (l.minimum_of_length_pos h : α) = l.minimum :=\n  WithTop.coe_untop _ _\n\n"}
{"name":"List.le_maximum_of_length_pos_iff","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nb : α\nh : LT.lt 0 l.length\n⊢ Iff (LE.le b (List.maximum_of_length_pos h)) (LE.le (↑b) l.maximum)","decl":"@[simp]\ntheorem le_maximum_of_length_pos_iff {b : α} (h : 0 < l.length) :\n    b ≤ maximum_of_length_pos h ↔ b ≤ l.maximum :=\n  WithBot.le_unbot_iff _\n\n"}
{"name":"List.minimum_of_length_pos_le_iff","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nb : α\nh : LT.lt 0 l.length\n⊢ Iff (LE.le (List.minimum_of_length_pos h) b) (LE.le l.minimum ↑b)","decl":"@[simp]\ntheorem minimum_of_length_pos_le_iff {b : α} (h : 0 < l.length) :\n    minimum_of_length_pos h ≤ b ↔ l.minimum ≤ b :=\n  WithTop.untop_le_iff _\n\n"}
{"name":"List.maximum_of_length_pos_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nh : LT.lt 0 l.length\n⊢ Membership.mem l (List.maximum_of_length_pos h)","decl":"theorem maximum_of_length_pos_mem (h : 0 < l.length) :\n    maximum_of_length_pos h ∈ l := by\n  apply maximum_mem\n  simp only [coe_maximum_of_length_pos]\n\n"}
{"name":"List.minimum_of_length_pos_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nh : LT.lt 0 l.length\n⊢ Membership.mem l (List.minimum_of_length_pos h)","decl":"theorem minimum_of_length_pos_mem (h : 0 < l.length) :\n    minimum_of_length_pos h ∈ l :=\n  maximum_of_length_pos_mem (α := αᵒᵈ) h\n\n"}
{"name":"List.le_maximum_of_length_pos_of_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\na : α\nh : Membership.mem l a\nw : LT.lt 0 l.length\n⊢ LE.le a (List.maximum_of_length_pos w)","decl":"theorem le_maximum_of_length_pos_of_mem (h : a ∈ l) (w : 0 < l.length) :\n    a ≤ l.maximum_of_length_pos w := by\n  simp only [le_maximum_of_length_pos_iff]\n  exact le_maximum_of_mem' h\n\n"}
{"name":"List.minimum_of_length_pos_le_of_mem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\na : α\nh : Membership.mem l a\nw : LT.lt 0 l.length\n⊢ LE.le (List.minimum_of_length_pos w) a","decl":"theorem minimum_of_length_pos_le_of_mem (h : a ∈ l) (w : 0 < l.length) :\n    l.minimum_of_length_pos w ≤ a :=\n  le_maximum_of_length_pos_of_mem (α := αᵒᵈ) h w\n\n"}
{"name":"List.getElem_le_maximum_of_length_pos","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\ni : Nat\nw : LT.lt i l.length\nh : optParam (LT.lt 0 l.length) ⋯\n⊢ LE.le (GetElem.getElem l i ⋯) (List.maximum_of_length_pos h)","decl":"theorem getElem_le_maximum_of_length_pos {i : ℕ} (w : i < l.length) (h := (Nat.zero_lt_of_lt w)) :\n    l[i] ≤ l.maximum_of_length_pos h := by\n  apply le_maximum_of_length_pos_of_mem\n  exact getElem_mem _\n\n"}
{"name":"List.minimum_of_length_pos_le_getElem","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\ni : Nat\nw : LT.lt i l.length\nh : optParam (LT.lt 0 l.length) ⋯\n⊢ LE.le (List.minimum_of_length_pos h) (GetElem.getElem l i ⋯)","decl":"theorem minimum_of_length_pos_le_getElem {i : ℕ} (w : i < l.length) (h := (Nat.zero_lt_of_lt w)) :\n    l.minimum_of_length_pos h ≤ l[i] :=\n  getElem_le_maximum_of_length_pos (α := αᵒᵈ) w\n\n"}
{"name":"List.getD_max?_eq_unbot'_maximum","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nd : α\n⊢ Eq (l.max?.getD d) (WithBot.unbot' d l.maximum)","decl":"lemma getD_max?_eq_unbot'_maximum (l : List α) (d : α) :\n    l.max?.getD d = l.maximum.unbot' d := by\n  cases hy : l.maximum with\n  | bot => simp [List.maximum_eq_bot.mp hy]\n  | coe y =>\n    rw [List.maximum_eq_coe_iff] at hy\n    simp only [WithBot.unbot'_coe]\n    cases hz : l.max? with\n    | none => simp [List.max?_eq_none_iff.mp hz] at hy\n    | some z =>\n      have : Std.Antisymm (α := α) (· ≤ ·) := ⟨fun _ _ => _root_.le_antisymm⟩\n      rw [List.max?_eq_some_iff] at hz\n      · rw [Option.getD_some]\n        exact _root_.le_antisymm (hy.right _ hz.left) (hz.right _ hy.left)\n      all_goals simp [le_total]\n\n"}
{"name":"List.getD_maximum?_eq_unbot'_maximum","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nd : α\n⊢ Eq (l.max?.getD d) (WithBot.unbot' d l.maximum)","decl":"@[deprecated (since := \"2024-09-29\")]\nalias getD_maximum?_eq_unbot'_maximum := getD_max?_eq_unbot'_maximum\n\n"}
{"name":"List.getD_min?_eq_untop'_minimum","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nd : α\n⊢ Eq (l.min?.getD d) (WithTop.untop' d l.minimum)","decl":"lemma getD_min?_eq_untop'_minimum (l : List α) (d : α) :\n    l.min?.getD d = l.minimum.untop' d :=\n  getD_max?_eq_unbot'_maximum (α := αᵒᵈ) _ _\n\n"}
{"name":"List.getD_minimum?_eq_untop'_minimum","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nl : List α\nd : α\n⊢ Eq (l.min?.getD d) (WithTop.untop' d l.minimum)","decl":"@[deprecated (since := \"2024-09-29\")]\nalias getD_minimum?_eq_untop'_minimum := getD_min?_eq_untop'_minimum\n\n"}
{"name":"List.foldr_max_of_ne_nil","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : OrderBot α\nl : List α\nh : Ne l List.nil\n⊢ Eq (↑(List.foldr Max.max Bot.bot l)) l.maximum","decl":"@[simp]\ntheorem foldr_max_of_ne_nil (h : l ≠ []) : ↑(l.foldr max ⊥) = l.maximum := by\n  induction' l with hd tl IH\n  · contradiction\n  · rw [maximum_cons, foldr, WithBot.coe_max]\n    by_cases h : tl = []\n    · simp [h]\n    · simp [IH h]\n\n"}
{"name":"List.max_le_of_forall_le","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : OrderBot α\nl : List α\na : α\nh : ∀ (x : α), Membership.mem l x → LE.le x a\n⊢ LE.le (List.foldr Max.max Bot.bot l) a","decl":"theorem max_le_of_forall_le (l : List α) (a : α) (h : ∀ x ∈ l, x ≤ a) : l.foldr max ⊥ ≤ a := by\n  induction' l with y l IH\n  · simp\n  · simpa [h y (mem_cons_self _ _)] using IH fun x hx => h x <| mem_cons_of_mem _ hx\n\n"}
{"name":"List.le_max_of_le","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : OrderBot α\nl : List α\na x : α\nhx : Membership.mem l x\nh : LE.le a x\n⊢ LE.le a (List.foldr Max.max Bot.bot l)","decl":"theorem le_max_of_le {l : List α} {a x : α} (hx : x ∈ l) (h : a ≤ x) : a ≤ l.foldr max ⊥ := by\n  induction' l with y l IH\n  · exact absurd hx (not_mem_nil _)\n  · obtain hl | hl := hx\n    · simp only [foldr, foldr_cons]\n      exact le_max_of_le_left h\n    · exact le_max_of_le_right (IH (by assumption))\n\n"}
{"name":"List.foldr_min_of_ne_nil","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : OrderTop α\nl : List α\nh : Ne l List.nil\n⊢ Eq (↑(List.foldr Min.min Top.top l)) l.minimum","decl":"@[simp]\ntheorem foldr_min_of_ne_nil (h : l ≠ []) : ↑(l.foldr min ⊤) = l.minimum :=\n  @foldr_max_of_ne_nil αᵒᵈ _ _ _ h\n\n"}
{"name":"List.le_min_of_forall_le","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : OrderTop α\nl : List α\na : α\nh : ∀ (x : α), Membership.mem l x → LE.le a x\n⊢ LE.le a (List.foldr Min.min Top.top l)","decl":"theorem le_min_of_forall_le (l : List α) (a : α) (h : ∀ x ∈ l, a ≤ x) : a ≤ l.foldr min ⊤ :=\n  @max_le_of_forall_le αᵒᵈ _ _ _ _ h\n\n"}
{"name":"List.min_le_of_le","module":"Mathlib.Data.List.MinMax","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : OrderTop α\nl : List α\na x : α\nhx : Membership.mem l x\nh : LE.le x a\n⊢ LE.le (List.foldr Min.min Top.top l) a","decl":"theorem min_le_of_le (l : List α) (a : α) {x : α} (hx : x ∈ l) (h : x ≤ a) : l.foldr min ⊤ ≤ a :=\n  @le_max_of_le αᵒᵈ _ _ _ _ _ hx h\n\n"}
