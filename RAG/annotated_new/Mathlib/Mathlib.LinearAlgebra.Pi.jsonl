{"name":"LinearMap.pi_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM₂ : Type w\nι : Type x\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\nφ : ι → Type i\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nf : (i : ι) → LinearMap (RingHom.id R) M₂ (φ i)\nc : M₂\ni : ι\n⊢ Eq ((LinearMap.pi f) c i) ((f i) c)","decl":"@[simp]\ntheorem pi_apply (f : (i : ι) → M₂ →ₗ[R] φ i) (c : M₂) (i : ι) : pi f c i = f i c :=\n  rfl\n\n"}
{"name":"LinearMap.ker_pi","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM₂ : Type w\nι : Type x\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\nφ : ι → Type i\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nf : (i : ι) → LinearMap (RingHom.id R) M₂ (φ i)\n⊢ Eq (LinearMap.ker (LinearMap.pi f)) (iInf fun i => LinearMap.ker (f i))","decl":"theorem ker_pi (f : (i : ι) → M₂ →ₗ[R] φ i) : ker (pi f) = ⨅ i : ι, ker (f i) := by\n  ext c; simp [funext_iff]\n\n"}
{"name":"LinearMap.pi_eq_zero","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM₂ : Type w\nι : Type x\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\nφ : ι → Type i\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nf : (i : ι) → LinearMap (RingHom.id R) M₂ (φ i)\n⊢ Iff (Eq (LinearMap.pi f) 0) (∀ (i : ι), Eq (f i) 0)","decl":"theorem pi_eq_zero (f : (i : ι) → M₂ →ₗ[R] φ i) : pi f = 0 ↔ ∀ i, f i = 0 := by\n  simp only [LinearMap.ext_iff, pi_apply, funext_iff]\n  exact ⟨fun h a b => h b a, fun h a b => h b a⟩\n\n"}
{"name":"LinearMap.pi_zero","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM₂ : Type w\nι : Type x\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\nφ : ι → Type i\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\n⊢ Eq (LinearMap.pi fun x => 0) 0","decl":"theorem pi_zero : pi (fun _ => 0 : (i : ι) → M₂ →ₗ[R] φ i) = 0 := by ext; rfl\n\n"}
{"name":"LinearMap.pi_comp","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM₂ : Type w\nM₃ : Type y\nι : Type x\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M₃\nφ : ι → Type i\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nf : (i : ι) → LinearMap (RingHom.id R) M₂ (φ i)\ng : LinearMap (RingHom.id R) M₃ M₂\n⊢ Eq ((LinearMap.pi f).comp g) (LinearMap.pi fun i => (f i).comp g)","decl":"theorem pi_comp (f : (i : ι) → M₂ →ₗ[R] φ i) (g : M₃ →ₗ[R] M₂) :\n    (pi f).comp g = pi fun i => (f i).comp g :=\n  rfl\n\n"}
{"name":"LinearMap.coe_proj","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝² : Semiring R\nφ : ι → Type i\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\ni : ι\n⊢ Eq (⇑(LinearMap.proj i)) (Function.eval i)","decl":"@[simp]\ntheorem coe_proj (i : ι) : ⇑(proj i : ((i : ι) → φ i) →ₗ[R] φ i) = Function.eval i :=\n  rfl\n\n"}
{"name":"LinearMap.proj_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝² : Semiring R\nφ : ι → Type i\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\ni : ι\nb : (i : ι) → φ i\n⊢ Eq ((LinearMap.proj i) b) (b i)","decl":"theorem proj_apply (i : ι) (b : (i : ι) → φ i) : (proj i : ((i : ι) → φ i) →ₗ[R] φ i) b = b i :=\n  rfl\n\n"}
{"name":"LinearMap.proj_pi","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM₂ : Type w\nι : Type x\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\nφ : ι → Type i\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nf : (i : ι) → LinearMap (RingHom.id R) M₂ (φ i)\ni : ι\n⊢ Eq ((LinearMap.proj i).comp (LinearMap.pi f)) (f i)","decl":"theorem proj_pi (f : (i : ι) → M₂ →ₗ[R] φ i) (i : ι) : (proj i).comp (pi f) = f i :=\n  ext fun _ => rfl\n\n"}
{"name":"LinearMap.iInf_ker_proj","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝² : Semiring R\nφ : ι → Type i\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\n⊢ Eq (iInf fun i => LinearMap.ker (LinearMap.proj i)) Bot.bot","decl":"theorem iInf_ker_proj : (⨅ i, ker (proj i : ((i : ι) → φ i) →ₗ[R] φ i) :\n    Submodule R ((i : ι) → φ i)) = ⊥ :=\n  bot_unique <|\n    SetLike.le_def.2 fun a h => by\n      simp only [mem_iInf, mem_ker, proj_apply] at h\n      exact (mem_bot _).2 (funext fun i => h i)\n\n"}
{"name":"LinearMap.CompatibleSMul.pi","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\nι : Type u_5\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : SMul R M\ninst✝³ : SMul R N\ninst✝² : Module S M\ninst✝¹ : Module S N\ninst✝ : LinearMap.CompatibleSMul M N R S\n⊢ LinearMap.CompatibleSMul M (ι → N) R S","decl":"instance CompatibleSMul.pi (R S M N ι : Type*) [Semiring S]\n    [AddCommMonoid M] [AddCommMonoid N] [SMul R M] [SMul R N] [Module S M] [Module S N]\n    [LinearMap.CompatibleSMul M N R S] : LinearMap.CompatibleSMul M (ι → N) R S where\n  map_smul f r m := by ext i; apply ((LinearMap.proj i).comp f).map_smul_of_tower\n\n"}
{"name":"LinearMap.compLeft_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM₂ : Type w\nM₃ : Type y\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M₂ M₃\nI : Type u_1\nh : I → M₂\na✝ : I\n⊢ Eq ((f.compLeft I) h a✝) (Function.comp (⇑f) h a✝)","decl":"/-- Linear map between the function spaces `I → M₂` and `I → M₃`, induced by a linear map `f`\nbetween `M₂` and `M₃`. -/\n@[simps]\nprotected def compLeft (f : M₂ →ₗ[R] M₃) (I : Type*) : (I → M₂) →ₗ[R] I → M₃ :=\n  { f.toAddMonoidHom.compLeft I with\n    toFun := fun h => f ∘ h\n    map_smul' := fun c h => by\n      ext x\n      exact f.map_smul' c (h x) }\n\n"}
{"name":"LinearMap.apply_single","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\nι : Type x\ninst✝⁵ : Semiring R\nφ : ι → Type i\ninst✝⁴ : (i : ι) → AddCommMonoid (φ i)\ninst✝³ : (i : ι) → Module R (φ i)\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq ι\nf : (i : ι) → LinearMap (RingHom.id R) (φ i) M\ni j : ι\nx : φ i\n⊢ Eq ((f j) (Pi.single i x j)) (Pi.single i ((f i) x) j)","decl":"theorem apply_single [AddCommMonoid M] [Module R M] [DecidableEq ι] (f : (i : ι) → φ i →ₗ[R] M)\n    (i j : ι) (x : φ i) : f j (Pi.single i x j) = (Pi.single i (f i x) : ι → M) j :=\n  Pi.apply_single (fun i => f i) (fun i => (f i).map_zero) _ _ _\n\n"}
{"name":"LinearMap.single_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝³ : Semiring R\nφ : ι → Type i\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni : ι\nv : φ i\n⊢ Eq ((LinearMap.single R φ i) v) (Pi.single i v)","decl":"lemma single_apply [DecidableEq ι] {i : ι} (v : φ i) :\n    single R φ i v = Pi.single i v :=\n  rfl\n\n"}
{"name":"LinearMap.coe_single","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝³ : Semiring R\nφ : ι → Type i\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq (⇑(LinearMap.single R φ i)) (Pi.single i)","decl":"@[simp]\ntheorem coe_single [DecidableEq ι] (i : ι) :\n    ⇑(single R φ i : φ i →ₗ[R] (i : ι) → φ i) = Pi.single i :=\n  rfl\n\n"}
{"name":"LinearMap.proj_comp_single_same","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝³ : Semiring R\nφ : ι → Type i\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq ((LinearMap.proj i).comp (LinearMap.single R φ i)) LinearMap.id","decl":"theorem proj_comp_single_same (i : ι) : (proj i).comp (single R φ i) = id :=\n  LinearMap.ext <| Pi.single_eq_same i\n\n"}
{"name":"LinearMap.proj_comp_single_ne","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝³ : Semiring R\nφ : ι → Type i\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni j : ι\nh : Ne i j\n⊢ Eq ((LinearMap.proj i).comp (LinearMap.single R φ j)) 0","decl":"theorem proj_comp_single_ne (i j : ι) (h : i ≠ j) : (proj i).comp (single R φ j) = 0 :=\n  LinearMap.ext <| Pi.single_eq_of_ne h\n\n"}
{"name":"LinearMap.iSup_range_single_le_iInf_ker_proj","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝³ : Semiring R\nφ : ι → Type i\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\nI J : Set ι\nh : Disjoint I J\n⊢ LE.le (iSup fun i => iSup fun h => LinearMap.range (LinearMap.single R φ i)) (iInf fun i => iInf fun h => LinearMap.ker (LinearMap.proj i))","decl":"theorem iSup_range_single_le_iInf_ker_proj (I J : Set ι) (h : Disjoint I J) :\n    ⨆ i ∈ I, range (single R φ i) ≤ ⨅ i ∈ J, ker (proj i : (∀ i, φ i) →ₗ[R] φ i) := by\n  refine iSup_le fun i => iSup_le fun hi => range_le_iff_comap.2 ?_\n  simp only [← ker_comp, eq_top_iff, SetLike.le_def, mem_ker, comap_iInf, mem_iInf]\n  rintro b - j hj\n  rw [proj_comp_single_ne R φ j i, zero_apply]\n  rintro rfl\n  exact h.le_bot ⟨hi, hj⟩\n\n"}
{"name":"LinearMap.iInf_ker_proj_le_iSup_range_single","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝³ : Semiring R\nφ : ι → Type i\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\nI : Finset ι\nJ : Set ι\nhu : HasSubset.Subset Set.univ (Union.union (↑I) J)\n⊢ LE.le (iInf fun i => iInf fun h => LinearMap.ker (LinearMap.proj i)) (iSup fun i => iSup fun h => LinearMap.range (LinearMap.single R φ i))","decl":"theorem iInf_ker_proj_le_iSup_range_single {I : Finset ι} {J : Set ι} (hu : Set.univ ⊆ ↑I ∪ J) :\n    ⨅ i ∈ J, ker (proj i : (∀ i, φ i) →ₗ[R] φ i) ≤ ⨆ i ∈ I, range (single R φ i) :=\n  SetLike.le_def.2\n    (by\n      intro b hb\n      simp only [mem_iInf, mem_ker, proj_apply] at hb\n      rw [←\n        show (∑ i ∈ I, Pi.single i (b i)) = b by\n          ext i\n          rw [Finset.sum_apply, ← Pi.single_eq_same i (b i)]\n          refine Finset.sum_eq_single i (fun j _ ne => Pi.single_eq_of_ne ne.symm _) ?_\n          intro hiI\n          rw [Pi.single_eq_same]\n          exact hb _ ((hu trivial).resolve_left hiI)]\n      exact sum_mem_biSup fun i _ => mem_range_self (single R φ i) (b i))\n\n"}
{"name":"LinearMap.iSup_range_single_eq_iInf_ker_proj","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝³ : Semiring R\nφ : ι → Type i\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\nI J : Set ι\nhd : Disjoint I J\nhu : HasSubset.Subset Set.univ (Union.union I J)\nhI : I.Finite\n⊢ Eq (iSup fun i => iSup fun h => LinearMap.range (LinearMap.single R φ i)) (iInf fun i => iInf fun h => LinearMap.ker (LinearMap.proj i))","decl":"theorem iSup_range_single_eq_iInf_ker_proj {I J : Set ι} (hd : Disjoint I J)\n    (hu : Set.univ ⊆ I ∪ J) (hI : Set.Finite I) :\n    ⨆ i ∈ I, range (single R φ i) = ⨅ i ∈ J, ker (proj i : (∀ i, φ i) →ₗ[R] φ i) := by\n  refine le_antisymm (iSup_range_single_le_iInf_ker_proj _ _ _ _ hd) ?_\n  have : Set.univ ⊆ ↑hI.toFinset ∪ J := by rwa [hI.coe_toFinset]\n  refine le_trans (iInf_ker_proj_le_iSup_range_single R φ this) (iSup_mono fun i => ?_)\n  rw [Set.Finite.mem_toFinset]\n\n"}
{"name":"LinearMap.iSup_range_single","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝⁴ : Semiring R\nφ : ι → Type i\ninst✝³ : (i : ι) → AddCommMonoid (φ i)\ninst✝² : (i : ι) → Module R (φ i)\ninst✝¹ : DecidableEq ι\ninst✝ : Finite ι\n⊢ Eq (iSup fun i => LinearMap.range (LinearMap.single R φ i)) Top.top","decl":"theorem iSup_range_single [Finite ι] : ⨆ i, range (single R φ i) = ⊤ := by\n  cases nonempty_fintype ι\n  convert top_unique (iInf_emptyset.ge.trans <| iInf_ker_proj_le_iSup_range_single R φ _)\n  · rename_i i\n    exact ((@iSup_pos _ _ _ fun _ => range <| single R φ i) <| Finset.mem_univ i).symm\n  · rw [Finset.coe_univ, Set.union_empty]\n\n"}
{"name":"LinearMap.disjoint_single_single","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝³ : Semiring R\nφ : ι → Type i\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\nI J : Set ι\nh : Disjoint I J\n⊢ Disjoint (iSup fun i => iSup fun h => LinearMap.range (LinearMap.single R φ i)) (iSup fun i => iSup fun h => LinearMap.range (LinearMap.single R φ i))","decl":"theorem disjoint_single_single (I J : Set ι) (h : Disjoint I J) :\n    Disjoint (⨆ i ∈ I, range (single R φ i)) (⨆ i ∈ J, range (single R φ i)) := by\n  refine\n    Disjoint.mono (iSup_range_single_le_iInf_ker_proj _ _ _ _ <| disjoint_compl_right)\n      (iSup_range_single_le_iInf_ker_proj _ _ _ _ <| disjoint_compl_right) ?_\n  simp only [disjoint_iff_inf_le, SetLike.le_def, mem_iInf, mem_inf, mem_ker, mem_bot, proj_apply,\n    funext_iff]\n  rintro b ⟨hI, hJ⟩ i\n  classical\n    by_cases hiI : i ∈ I\n    · by_cases hiJ : i ∈ J\n      · exact (h.le_bot ⟨hiI, hiJ⟩).elim\n      · exact hJ i hiJ\n    · exact hI i hiI\n\n"}
{"name":"LinearMap.lsum_symm_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\nι : Type x\ninst✝⁹ : Semiring R\nφ : ι → Type i\ninst✝⁸ : (i : ι) → AddCommMonoid (φ i)\ninst✝⁷ : (i : ι) → Module R (φ i)\ninst✝⁶ : DecidableEq ι\nS : Type u_1\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Fintype ι\ninst✝² : Semiring S\ninst✝¹ : Module S M\ninst✝ : SMulCommClass R S M\nf : LinearMap (RingHom.id R) ((i : ι) → φ i) M\ni : ι\n⊢ Eq ((LinearMap.lsum R φ S).symm f i) (f.comp (LinearMap.single R φ i))","decl":"/-- The linear equivalence between linear functions on a finite product of modules and\nfamilies of functions on these modules. See note [bundled maps over different rings]. -/\n@[simps symm_apply]\ndef lsum (S) [AddCommMonoid M] [Module R M] [Fintype ι] [Semiring S] [Module S M]\n    [SMulCommClass R S M] : ((i : ι) → φ i →ₗ[R] M) ≃ₗ[S] ((i : ι) → φ i) →ₗ[R] M where\n  toFun f := ∑ i : ι, (f i).comp (proj i)\n  invFun f i := f.comp (single R φ i)\n  map_add' f g := by simp only [Pi.add_apply, add_comp, Finset.sum_add_distrib]\n  map_smul' c f := by simp only [Pi.smul_apply, smul_comp, Finset.smul_sum, RingHom.id_apply]\n  left_inv f := by\n    ext i x\n    simp [apply_single]\n  right_inv f := by\n    ext x\n    suffices f (∑ j, Pi.single j (x j)) = f x by simpa [apply_single]\n    rw [Finset.univ_sum_single]\n\n"}
{"name":"LinearMap.lsum_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\nι : Type x\ninst✝⁹ : Semiring R\nφ : ι → Type i\ninst✝⁸ : (i : ι) → AddCommMonoid (φ i)\ninst✝⁷ : (i : ι) → Module R (φ i)\ninst✝⁶ : DecidableEq ι\nS : Type u_1\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Fintype ι\ninst✝² : Semiring S\ninst✝¹ : Module S M\ninst✝ : SMulCommClass R S M\nf : (i : ι) → LinearMap (RingHom.id R) (φ i) M\n⊢ Eq ((LinearMap.lsum R φ S) f) (Finset.univ.sum fun i => (f i).comp (LinearMap.proj i))","decl":"@[simp]\ntheorem lsum_apply (S) [AddCommMonoid M] [Module R M] [Fintype ι] [Semiring S]\n    [Module S M] [SMulCommClass R S M] (f : (i : ι) → φ i →ₗ[R] M) :\n    lsum R φ S f = ∑ i : ι, (f i).comp (proj i) := rfl\n\n"}
{"name":"LinearMap.lsum_single","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : Fintype ι\ninst✝³ : DecidableEq ι\ninst✝² : CommSemiring R\nM : ι → Type u_3\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\n⊢ Eq ((LinearMap.lsum R M R) (LinearMap.single R M)) LinearMap.id","decl":"@[simp high]\ntheorem lsum_single {ι R : Type*} [Fintype ι] [DecidableEq ι] [CommSemiring R] {M : ι → Type*}\n    [(i : ι) → AddCommMonoid (M i)] [(i : ι) → Module R (M i)] :\n    LinearMap.lsum R M R (LinearMap.single R M) = LinearMap.id :=\n  LinearMap.ext fun x => by simp [Finset.univ_sum_single]\n\n"}
{"name":"LinearMap.pi_ext","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\nι : Type x\ninst✝⁶ : Semiring R\nφ : ι → Type i\ninst✝⁵ : (i : ι) → AddCommMonoid (φ i)\ninst✝⁴ : (i : ι) → Module R (φ i)\ninst✝³ : DecidableEq ι\ninst✝² : Finite ι\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearMap (RingHom.id R) ((i : ι) → φ i) M\nh : ∀ (i : ι) (x : φ i), Eq (f (Pi.single i x)) (g (Pi.single i x))\n⊢ Eq f g","decl":"theorem pi_ext (h : ∀ i x, f (Pi.single i x) = g (Pi.single i x)) : f = g :=\n  toAddMonoidHom_injective <| AddMonoidHom.functions_ext _ _ _ h\n\n"}
{"name":"LinearMap.pi_ext_iff","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\nι : Type x\ninst✝⁶ : Semiring R\nφ : ι → Type i\ninst✝⁵ : (i : ι) → AddCommMonoid (φ i)\ninst✝⁴ : (i : ι) → Module R (φ i)\ninst✝³ : DecidableEq ι\ninst✝² : Finite ι\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearMap (RingHom.id R) ((i : ι) → φ i) M\n⊢ Iff (Eq f g) (∀ (i : ι) (x : φ i), Eq (f (Pi.single i x)) (g (Pi.single i x)))","decl":"theorem pi_ext_iff : f = g ↔ ∀ i x, f (Pi.single i x) = g (Pi.single i x) :=\n  ⟨fun h _ _ => h ▸ rfl, pi_ext⟩\n\n"}
{"name":"LinearMap.pi_ext'","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\nι : Type x\ninst✝⁶ : Semiring R\nφ : ι → Type i\ninst✝⁵ : (i : ι) → AddCommMonoid (φ i)\ninst✝⁴ : (i : ι) → Module R (φ i)\ninst✝³ : DecidableEq ι\ninst✝² : Finite ι\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearMap (RingHom.id R) ((i : ι) → φ i) M\nh : ∀ (i : ι), Eq (f.comp (LinearMap.single R φ i)) (g.comp (LinearMap.single R φ i))\n⊢ Eq f g","decl":"/-- This is used as the ext lemma instead of `LinearMap.pi_ext` for reasons explained in\nnote [partially-applied ext lemmas]. -/\n@[ext]\ntheorem pi_ext' (h : ∀ i, f.comp (single R φ i) = g.comp (single R φ i)) : f = g := by\n  refine pi_ext fun i x => ?_\n  convert LinearMap.congr_fun (h i) x\n\n"}
{"name":"LinearMap.pi_ext'_iff","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\nι : Type x\ninst✝⁶ : Semiring R\nφ : ι → Type i\ninst✝⁵ : (i : ι) → AddCommMonoid (φ i)\ninst✝⁴ : (i : ι) → Module R (φ i)\ninst✝³ : DecidableEq ι\ninst✝² : Finite ι\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearMap (RingHom.id R) ((i : ι) → φ i) M\n⊢ Iff (Eq f g) (∀ (i : ι), Eq (f.comp (LinearMap.single R φ i)) (g.comp (LinearMap.single R φ i)))","decl":"/-- This is used as the ext lemma instead of `LinearMap.pi_ext` for reasons explained in\nnote [partially-applied ext lemmas]. -/\n@[ext]\ntheorem pi_ext' (h : ∀ i, f.comp (single R φ i) = g.comp (single R φ i)) : f = g := by\n  refine pi_ext fun i x => ?_\n  convert LinearMap.congr_fun (h i) x\n\n"}
{"name":"LinearMap.update_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM₂ : Type w\nι : Type x\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\nφ : ι → Type i\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\nf : (i : ι) → LinearMap (RingHom.id R) M₂ (φ i)\nc : M₂\ni j : ι\nb : LinearMap (RingHom.id R) M₂ (φ i)\n⊢ Eq ((Function.update f i b j) c) (Function.update (fun i => (f i) c) i (b c) j)","decl":"theorem update_apply (f : (i : ι) → M₂ →ₗ[R] φ i) (c : M₂) (i j : ι) (b : M₂ →ₗ[R] φ i) :\n    (update f i b j) c = update (fun i => f i c) i (b c) j := by\n  by_cases h : j = i\n  · rw [h, update_self, update_self]\n  · rw [update_of_ne h, update_of_ne h]\n\n"}
{"name":"LinearMap.single_eq_pi_diag","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝³ : Semiring R\nφ : ι → Type i\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq (LinearMap.single R φ i) (LinearMap.pi (LinearMap.diag i))","decl":"theorem single_eq_pi_diag (i : ι) : single R φ i = pi (diag i) := by\n  ext x j\n  -- Porting note: made types explicit\n  convert (update_apply (R := R) (φ := φ) (ι := ι) 0 x i j _).symm\n  rfl\n\n"}
{"name":"LinearMap.ker_single","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝³ : Semiring R\nφ : ι → Type i\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Eq (LinearMap.ker (LinearMap.single R φ i)) Bot.bot","decl":"theorem ker_single (i : ι) : ker (single R φ i) = ⊥ :=\n  ker_eq_bot_of_injective <| Pi.single_injective _ _\n\n"}
{"name":"LinearMap.proj_comp_single","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝³ : Semiring R\nφ : ι → Type i\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\ni j : ι\n⊢ Eq ((LinearMap.proj i).comp (LinearMap.single R φ j)) (LinearMap.diag j i)","decl":"theorem proj_comp_single (i j : ι) : (proj i).comp (single R φ j) = diag j i := by\n  rw [single_eq_pi_diag, proj_pi]\n\n"}
{"name":"LinearMap.pi_apply_eq_sum_univ","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM₂ : Type w\nι : Type x\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nf : LinearMap (RingHom.id R) (ι → R) M₂\nx : ι → R\n⊢ Eq (f x) (Finset.univ.sum fun i => HSMul.hSMul (x i) (f fun j => ite (Eq i j) 1 0))","decl":"/-- A linear map `f` applied to `x : ι → R` can be computed using the image under `f` of elements\nof the canonical basis. -/\ntheorem pi_apply_eq_sum_univ [Fintype ι] (f : (ι → R) →ₗ[R] M₂) (x : ι → R) :\n    f x = ∑ i, x i • f fun j => if i = j then 1 else 0 := by\n  conv_lhs => rw [pi_eq_sum_univ x, map_sum]\n  refine Finset.sum_congr rfl (fun _ _ => ?_)\n  rw [map_smul]\n\n"}
{"name":"Submodule.coe_pi","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝² : Semiring R\nφ : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nI : Set ι\np : (i : ι) → Submodule R (φ i)\n⊢ Eq (↑(Submodule.pi I p)) (I.pi fun i => ↑(p i))","decl":"/-- A version of `Set.pi` for submodules. Given an index set `I` and a family of submodules\n`p : (i : ι) → Submodule R (φ i)`, `pi I s` is the submodule of dependent functions\n`f : (i : ι) → φ i` such that `f i` belongs to `p a` whenever `i ∈ I`. -/\n@[simps]\ndef pi (I : Set ι) (p : (i : ι) → Submodule R (φ i)) : Submodule R ((i : ι) → φ i) where\n  carrier := Set.pi I fun i => p i\n  zero_mem' i _ := (p i).zero_mem\n  add_mem' {_ _} hx hy i hi := (p i).add_mem (hx i hi) (hy i hi)\n  smul_mem' c _ hx i hi := (p i).smul_mem c (hx i hi)\n\n"}
{"name":"Submodule.mem_pi","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝² : Semiring R\nφ : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nI : Set ι\np : (i : ι) → Submodule R (φ i)\nx : (i : ι) → φ i\n⊢ Iff (Membership.mem (Submodule.pi I p) x) (∀ (i : ι), Membership.mem I i → Membership.mem (p i) (x i))","decl":"@[simp]\ntheorem mem_pi : x ∈ pi I p ↔ ∀ i ∈ I, x i ∈ p i :=\n  Iff.rfl\n\n"}
{"name":"Submodule.pi_empty","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝² : Semiring R\nφ : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\np : (i : ι) → Submodule R (φ i)\n⊢ Eq (Submodule.pi EmptyCollection.emptyCollection p) Top.top","decl":"@[simp]\ntheorem pi_empty (p : (i : ι) → Submodule R (φ i)) : pi ∅ p = ⊤ :=\n  SetLike.coe_injective <| Set.empty_pi _\n\n"}
{"name":"Submodule.pi_top","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝² : Semiring R\nφ : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\ns : Set ι\n⊢ Eq (Submodule.pi s fun i => Top.top) Top.top","decl":"@[simp]\ntheorem pi_top (s : Set ι) : (pi s fun i : ι => (⊤ : Submodule R (φ i))) = ⊤ :=\n  SetLike.coe_injective <| Set.pi_univ _\n\n"}
{"name":"Submodule.pi_mono","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝² : Semiring R\nφ : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\np q : (i : ι) → Submodule R (φ i)\ns : Set ι\nh : ∀ (i : ι), Membership.mem s i → LE.le (p i) (q i)\n⊢ LE.le (Submodule.pi s p) (Submodule.pi s q)","decl":"@[gcongr]\ntheorem pi_mono {s : Set ι} (h : ∀ i ∈ s, p i ≤ q i) : pi s p ≤ pi s q :=\n  Set.pi_mono h\n\n"}
{"name":"Submodule.biInf_comap_proj","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝² : Semiring R\nφ : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\nI : Set ι\np : (i : ι) → Submodule R (φ i)\n⊢ Eq (iInf fun i => iInf fun h => Submodule.comap (LinearMap.proj i) (p i)) (Submodule.pi I p)","decl":"theorem biInf_comap_proj :\n    ⨅ i ∈ I, comap (proj i : ((i : ι) → φ i) →ₗ[R] φ i) (p i) = pi I p := by\n  ext x\n  simp\n\n"}
{"name":"Submodule.iInf_comap_proj","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝² : Semiring R\nφ : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\np : (i : ι) → Submodule R (φ i)\n⊢ Eq (iInf fun i => Submodule.comap (LinearMap.proj i) (p i)) (Submodule.pi Set.univ p)","decl":"theorem iInf_comap_proj :\n    ⨅ i, comap (proj i : ((i : ι) → φ i) →ₗ[R] φ i) (p i) = pi Set.univ p := by\n  ext x\n  simp\n\n"}
{"name":"Submodule.iSup_map_single","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝⁴ : Semiring R\nφ : ι → Type u_1\ninst✝³ : (i : ι) → AddCommMonoid (φ i)\ninst✝² : (i : ι) → Module R (φ i)\np : (i : ι) → Submodule R (φ i)\ninst✝¹ : DecidableEq ι\ninst✝ : Finite ι\n⊢ Eq (iSup fun i => Submodule.map (LinearMap.single R φ i) (p i)) (Submodule.pi Set.univ p)","decl":"theorem iSup_map_single [DecidableEq ι] [Finite ι] :\n    ⨆ i, map (LinearMap.single R φ i : φ i →ₗ[R] (i : ι) → φ i) (p i) = pi Set.univ p := by\n  cases nonempty_fintype ι\n  refine (iSup_le fun i => ?_).antisymm ?_\n  · rintro _ ⟨x, hx : x ∈ p i, rfl⟩ j -\n    rcases em (j = i) with (rfl | hj) <;> simp [*]\n  · intro x hx\n    rw [← Finset.univ_sum_single x]\n    exact sum_mem_iSup fun i => mem_map_of_mem (hx i trivial)\n\n"}
{"name":"Submodule.le_comap_single_pi","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝³ : Semiring R\nφ : ι → Type u_1\ninst✝² : (i : ι) → AddCommMonoid (φ i)\ninst✝¹ : (i : ι) → Module R (φ i)\ninst✝ : DecidableEq ι\np : (i : ι) → Submodule R (φ i)\ni : ι\n⊢ LE.le (p i) (Submodule.comap (LinearMap.single R φ i) (Submodule.pi Set.univ p))","decl":"theorem le_comap_single_pi [DecidableEq ι] (p : (i : ι) → Submodule R (φ i)) {i} :\n    p i ≤ Submodule.comap (LinearMap.single R φ i : φ i →ₗ[R] _) (Submodule.pi Set.univ p) := by\n  intro x hx\n  rw [Submodule.mem_comap, Submodule.mem_pi]\n  rintro j -\n  by_cases h : j = i\n  · rwa [h, LinearMap.coe_single, Pi.single_eq_same]\n  · rw [LinearMap.coe_single, Pi.single_eq_of_ne h]\n    exact (p j).zero_mem\n\n"}
{"name":"LinearEquiv.piCongrRight_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝⁴ : Semiring R\nφ : ι → Type u_1\nψ : ι → Type u_2\ninst✝³ : (i : ι) → AddCommMonoid (φ i)\ninst✝² : (i : ι) → Module R (φ i)\ninst✝¹ : (i : ι) → AddCommMonoid (ψ i)\ninst✝ : (i : ι) → Module R (ψ i)\ne : (i : ι) → LinearEquiv (RingHom.id R) (φ i) (ψ i)\nf : (i : ι) → φ i\ni : ι\n⊢ Eq ((LinearEquiv.piCongrRight e) f i) ((e i) (f i))","decl":"@[simp]\ntheorem piCongrRight_apply (e : (i : ι) → φ i ≃ₗ[R] ψ i) (f i) :\n    piCongrRight e f i = e i (f i) := rfl\n\n"}
{"name":"LinearEquiv.piCongrRight_refl","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝² : Semiring R\nφ : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\n⊢ Eq (LinearEquiv.piCongrRight fun j => LinearEquiv.refl R (φ j)) (LinearEquiv.refl R ((i : ι) → φ i))","decl":"@[simp]\ntheorem piCongrRight_refl : (piCongrRight fun j => refl R (φ j)) = refl _ _ :=\n  rfl\n\n"}
{"name":"LinearEquiv.piCongrRight_symm","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝⁴ : Semiring R\nφ : ι → Type u_1\nψ : ι → Type u_2\ninst✝³ : (i : ι) → AddCommMonoid (φ i)\ninst✝² : (i : ι) → Module R (φ i)\ninst✝¹ : (i : ι) → AddCommMonoid (ψ i)\ninst✝ : (i : ι) → Module R (ψ i)\ne : (i : ι) → LinearEquiv (RingHom.id R) (φ i) (ψ i)\n⊢ Eq (LinearEquiv.piCongrRight e).symm (LinearEquiv.piCongrRight fun i => (e i).symm)","decl":"@[simp]\ntheorem piCongrRight_symm (e : (i : ι) → φ i ≃ₗ[R] ψ i) :\n    (piCongrRight e).symm = piCongrRight fun i => (e i).symm :=\n  rfl\n\n"}
{"name":"LinearEquiv.piCongrRight_trans","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\ninst✝⁶ : Semiring R\nφ : ι → Type u_1\nψ : ι → Type u_2\nχ : ι → Type u_3\ninst✝⁵ : (i : ι) → AddCommMonoid (φ i)\ninst✝⁴ : (i : ι) → Module R (φ i)\ninst✝³ : (i : ι) → AddCommMonoid (ψ i)\ninst✝² : (i : ι) → Module R (ψ i)\ninst✝¹ : (i : ι) → AddCommMonoid (χ i)\ninst✝ : (i : ι) → Module R (χ i)\ne : (i : ι) → LinearEquiv (RingHom.id R) (φ i) (ψ i)\nf : (i : ι) → LinearEquiv (RingHom.id R) (ψ i) (χ i)\n⊢ Eq ((LinearEquiv.piCongrRight e).trans (LinearEquiv.piCongrRight f)) (LinearEquiv.piCongrRight fun i => (e i).trans (f i))","decl":"@[simp]\ntheorem piCongrRight_trans (e : (i : ι) → φ i ≃ₗ[R] ψ i) (f : (i : ι) → ψ i ≃ₗ[R] χ i) :\n    (piCongrRight e).trans (piCongrRight f) = piCongrRight fun i => (e i).trans (f i) :=\n  rfl\n\n"}
{"name":"LinearEquiv.piCongrLeft'_symm_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\nι' : Type x'\ninst✝² : Semiring R\nφ : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\ne : Equiv ι ι'\na✝ : (b : ι') → φ (e.symm b)\na : ι\n⊢ Eq ((LinearEquiv.piCongrLeft' R φ e).symm a✝ a) ((Equiv.piCongrLeft' φ e).symm a✝ a)","decl":"/-- Transport dependent functions through an equivalence of the base space.\n\nThis is `Equiv.piCongrLeft'` as a `LinearEquiv`. -/\n@[simps (config := { simpRhs := true })]\ndef piCongrLeft' (e : ι ≃ ι') : ((i' : ι) → φ i') ≃ₗ[R] (i : ι') → φ <| e.symm i :=\n  { Equiv.piCongrLeft' φ e with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }\n\n"}
{"name":"LinearEquiv.piCongrLeft'_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι : Type x\nι' : Type x'\ninst✝² : Semiring R\nφ : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (φ i)\ninst✝ : (i : ι) → Module R (φ i)\ne : Equiv ι ι'\na✝ : (a : ι) → φ a\nb : ι'\n⊢ Eq ((LinearEquiv.piCongrLeft' R φ e) a✝ b) (a✝ (e.symm b))","decl":"/-- Transport dependent functions through an equivalence of the base space.\n\nThis is `Equiv.piCongrLeft'` as a `LinearEquiv`. -/\n@[simps (config := { simpRhs := true })]\ndef piCongrLeft' (e : ι ≃ ι') : ((i' : ι) → φ i') ≃ₗ[R] (i : ι') → φ <| e.symm i :=\n  { Equiv.piCongrLeft' φ e with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }\n\n"}
{"name":"LinearEquiv.piCurry_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type u_4\nκ : ι → Type u_5\nα : (i : ι) → κ i → Type u_6\ninst✝¹ : (i : ι) → (k : κ i) → AddCommMonoid (α i k)\ninst✝ : (i : ι) → (k : κ i) → Module R (α i k)\nf : (x : Sigma fun i => κ i) → α x.fst x.snd\n⊢ Eq ((LinearEquiv.piCurry R α) f) (Sigma.curry f)","decl":"@[simp] theorem piCurry_apply {ι : Type*} {κ : ι → Type*} (α : ∀ i, κ i → Type*)\n    [∀ i k, AddCommMonoid (α i k)] [∀ i k, Module R (α i k)]\n    (f : ∀ x : Σ i, κ i, α x.1 x.2) :\n    piCurry R α f = Sigma.curry f :=\n  rfl\n\n"}
{"name":"LinearEquiv.piCurry_symm_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\ninst✝² : Semiring R\nι : Type u_4\nκ : ι → Type u_5\nα : (i : ι) → κ i → Type u_6\ninst✝¹ : (i : ι) → (k : κ i) → AddCommMonoid (α i k)\ninst✝ : (i : ι) → (k : κ i) → Module R (α i k)\nf : (a : ι) → (b : κ a) → α a b\n⊢ Eq ((LinearEquiv.piCurry R α).symm f) (Sigma.uncurry f)","decl":"@[simp] theorem piCurry_symm_apply {ι : Type*} {κ : ι → Type*} (α : ∀ i, κ i → Type*)\n    [∀ i k, AddCommMonoid (α i k)] [∀ i k, Module R (α i k)]\n    (f : ∀ a b, α a b) :\n    (piCurry R α).symm f = Sigma.uncurry f :=\n  rfl\n\n"}
{"name":"LinearEquiv.piRing_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\nι : Type x\ninst✝⁷ : Semiring R\nS : Type u_4\ninst✝⁶ : Fintype ι\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : SMulCommClass R S M\nf : LinearMap (RingHom.id R) (ι → R) M\ni : ι\n⊢ Eq ((LinearEquiv.piRing R M ι S) f i) (f (Pi.single i 1))","decl":"@[simp]\ntheorem piRing_apply (f : (ι → R) →ₗ[R] M) (i : ι) : piRing R M ι S f i = f (Pi.single i 1) :=\n  rfl\n\n"}
{"name":"LinearEquiv.piRing_symm_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\nι : Type x\ninst✝⁷ : Semiring R\nS : Type u_4\ninst✝⁶ : Fintype ι\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : SMulCommClass R S M\nf : ι → M\ng : ι → R\n⊢ Eq (((LinearEquiv.piRing R M ι S).symm f) g) (Finset.univ.sum fun i => HSMul.hSMul (g i) (f i))","decl":"@[simp]\ntheorem piRing_symm_apply (f : ι → M) (g : ι → R) : (piRing R M ι S).symm f g = ∑ i, g i • f i := by\n  simp [piRing, LinearMap.lsum_apply]\n\n-- TODO additive version?\n"}
{"name":"LinearEquiv.sumArrowLequivProdArrow_apply_fst","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα : Type u_5\nβ : Type u_6\nf : Sum α β → M\na : α\n⊢ Eq (((LinearEquiv.sumArrowLequivProdArrow α β R M) f).1 a) (f (Sum.inl a))","decl":"@[simp]\ntheorem sumArrowLequivProdArrow_apply_fst {α β} (f : α ⊕ β → M) (a : α) :\n    (sumArrowLequivProdArrow α β R M f).1 a = f (Sum.inl a) :=\n  rfl\n\n"}
{"name":"LinearEquiv.sumArrowLequivProdArrow_apply_snd","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα : Type u_5\nβ : Type u_6\nf : Sum α β → M\nb : β\n⊢ Eq (((LinearEquiv.sumArrowLequivProdArrow α β R M) f).2 b) (f (Sum.inr b))","decl":"@[simp]\ntheorem sumArrowLequivProdArrow_apply_snd {α β} (f : α ⊕ β → M) (b : β) :\n    (sumArrowLequivProdArrow α β R M f).2 b = f (Sum.inr b) :=\n  rfl\n\n"}
{"name":"LinearEquiv.sumArrowLequivProdArrow_symm_apply_inl","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα : Type u_5\nβ : Type u_6\nf : α → M\ng : β → M\na : α\n⊢ Eq ((LinearEquiv.sumArrowLequivProdArrow α β R M).symm { fst := f, snd := g } (Sum.inl a)) (f a)","decl":"@[simp]\ntheorem sumArrowLequivProdArrow_symm_apply_inl {α β} (f : α → M) (g : β → M) (a : α) :\n    ((sumArrowLequivProdArrow α β R M).symm (f, g)) (Sum.inl a) = f a :=\n  rfl\n\n"}
{"name":"LinearEquiv.sumArrowLequivProdArrow_symm_apply_inr","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα : Type u_5\nβ : Type u_6\nf : α → M\ng : β → M\nb : β\n⊢ Eq ((LinearEquiv.sumArrowLequivProdArrow α β R M).symm { fst := f, snd := g } (Sum.inr b)) (g b)","decl":"@[simp]\ntheorem sumArrowLequivProdArrow_symm_apply_inr {α β} (f : α → M) (g : β → M) (b : β) :\n    ((sumArrowLequivProdArrow α β R M).symm (f, g)) (Sum.inr b) = g b :=\n  rfl\n\n"}
{"name":"LinearEquiv.funUnique_symm_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"ι : Type u_5\nR : Type u_6\nM : Type u_7\ninst✝³ : Unique ι\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (⇑(LinearEquiv.funUnique ι R M).symm) uniqueElim","decl":"/-- If `ι` has a unique element, then `ι → M` is linearly equivalent to `M`. -/\n@[simps (config := { simpRhs := true, fullyApplied := false }) symm_apply]\ndef funUnique (ι R M : Type*) [Unique ι] [Semiring R] [AddCommMonoid M] [Module R M] :\n    (ι → M) ≃ₗ[R] M :=\n  { Equiv.funUnique ι M with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }\n\n"}
{"name":"LinearEquiv.funUnique_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"ι : Type u_5\nR : Type u_6\nM : Type u_7\ninst✝³ : Unique ι\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (⇑(LinearEquiv.funUnique ι R M)) (Function.eval Inhabited.default)","decl":"@[simp]\ntheorem funUnique_apply (ι R M : Type*) [Unique ι] [Semiring R] [AddCommMonoid M] [Module R M] :\n    (funUnique ι R M : (ι → M) → M) = eval default := rfl\n\n"}
{"name":"LinearEquiv.piFinTwo_symm_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\ninst✝² : Semiring R\nM : Fin 2 → Type v\ninst✝¹ : (i : Fin 2) → AddCommMonoid (M i)\ninst✝ : (i : Fin 2) → Module R (M i)\n⊢ Eq ⇑(LinearEquiv.piFinTwo R M).symm fun p => Fin.cons p.1 (Fin.cons p.2 finZeroElim)","decl":"/-- Linear equivalence between dependent functions `(i : Fin 2) → M i` and `M 0 × M 1`. -/\n@[simps (config := { simpRhs := true, fullyApplied := false }) symm_apply]\ndef piFinTwo (M : Fin 2 → Type v)\n    [(i : Fin 2) → AddCommMonoid (M i)] [(i : Fin 2) → Module R (M i)] :\n    ((i : Fin 2) → M i) ≃ₗ[R] M 0 × M 1 :=\n  { piFinTwoEquiv M with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }\n\n"}
{"name":"LinearEquiv.piFinTwo_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\ninst✝² : Semiring R\nM : Fin 2 → Type v\ninst✝¹ : (i : Fin 2) → AddCommMonoid (M i)\ninst✝ : (i : Fin 2) → Module R (M i)\n⊢ Eq ⇑(LinearEquiv.piFinTwo R M) fun f => { fst := f 0, snd := f 1 }","decl":"@[simp]\ntheorem piFinTwo_apply (M : Fin 2 → Type v)\n    [(i : Fin 2) → AddCommMonoid (M i)] [(i : Fin 2) → Module R (M i)] :\n    (piFinTwo R M : ((i : Fin 2) → M i) → M 0 × M 1) = fun f => (f 0, f 1) := rfl\n\n"}
{"name":"LinearEquiv.finTwoArrow_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq ⇑(LinearEquiv.finTwoArrow R M) fun f => { fst := f 0, snd := f 1 }","decl":"/-- Linear equivalence between vectors in `M² = Fin 2 → M` and `M × M`. -/\n@[simps! (config := .asFn)]\ndef finTwoArrow : (Fin 2 → M) ≃ₗ[R] M × M :=\n  { finTwoArrowEquiv M, piFinTwo R fun _ => M with }\n\n"}
{"name":"LinearEquiv.finTwoArrow_symm_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq ⇑(LinearEquiv.finTwoArrow R M).symm fun x => Matrix.vecCons x.1 (Matrix.vecCons x.2 Matrix.vecEmpty)","decl":"/-- Linear equivalence between vectors in `M² = Fin 2 → M` and `M × M`. -/\n@[simps! (config := .asFn)]\ndef finTwoArrow : (Fin 2 → M) ≃ₗ[R] M × M :=\n  { finTwoArrowEquiv M, piFinTwo R fun _ => M with }\n\n"}
{"name":"Function.ExtendByZero.linearMap_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nι η : Type x\ninst✝ : Semiring R\ns : ι → η\nf : ι → R\na✝ : η\n⊢ Eq ((Function.ExtendByZero.linearMap R s) f a✝) (Function.extend s f 0 a✝)","decl":"/-- `Function.extend s f 0` as a bundled linear map. -/\n@[simps]\nnoncomputable def Function.ExtendByZero.linearMap : (ι → R) →ₗ[R] η → R :=\n  { Function.ExtendByZero.hom R s with\n    toFun := fun f => Function.extend s f 0\n    map_smul' := fun r f => by simpa using Function.extend_smul r s f 0 }\n\n"}
{"name":"Fin.consLinearEquiv_symm_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nn : Nat\nM : Fin n.succ → Type u_1\ninst✝² : Semiring R\ninst✝¹ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝ : (i : Fin n.succ) → Module R (M i)\na✝ : (i : Fin (HAdd.hAdd n 1)) → M i\n⊢ Eq ((Fin.consLinearEquiv R M).symm a✝) ((Fin.consEquiv M).invFun a✝)","decl":"variable (R) in\n/-- `Fin.consEquiv` as a continuous linear equivalence.  -/\n@[simps]\ndef Fin.consLinearEquiv\n    {n : ℕ} (M : Fin n.succ → Type*) [Semiring R] [∀ i, AddCommMonoid (M i)] [∀ i, Module R (M i)] :\n    (M 0 × Π i, M (Fin.succ i)) ≃ₗ[R] (Π i, M i) where\n  __ := Fin.consEquiv M\n  map_add' x y := funext <| Fin.cases rfl (by simp)\n  map_smul' c x := funext <| Fin.cases rfl (by simp)\n\n\n"}
{"name":"Fin.consLinearEquiv_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nn : Nat\nM : Fin n.succ → Type u_1\ninst✝² : Semiring R\ninst✝¹ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝ : (i : Fin n.succ) → Module R (M i)\na✝ : Prod (M 0) ((i : Fin n) → M i.succ)\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq ((Fin.consLinearEquiv R M) a✝ i) ((Fin.consEquiv M).toFun a✝ i)","decl":"variable (R) in\n/-- `Fin.consEquiv` as a continuous linear equivalence.  -/\n@[simps]\ndef Fin.consLinearEquiv\n    {n : ℕ} (M : Fin n.succ → Type*) [Semiring R] [∀ i, AddCommMonoid (M i)] [∀ i, Module R (M i)] :\n    (M 0 × Π i, M (Fin.succ i)) ≃ₗ[R] (Π i, M i) where\n  __ := Fin.consEquiv M\n  map_add' x y := funext <| Fin.cases rfl (by simp)\n  map_smul' c x := funext <| Fin.cases rfl (by simp)\n\n\n"}
{"name":"LinearMap.vecEmpty_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\nM₃ : Type y\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M\ninst✝ : Module R M₃\nm : M\n⊢ Eq (LinearMap.vecEmpty m) Matrix.vecEmpty","decl":"@[simp]\ntheorem LinearMap.vecEmpty_apply (m : M) : (LinearMap.vecEmpty : M →ₗ[R] Fin 0 → M₃) m = ![] :=\n  rfl\n\n"}
{"name":"LinearMap.vecCons_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nn : Nat\nf : LinearMap (RingHom.id R) M M₂\ng : LinearMap (RingHom.id R) M (Fin n → M₂)\nm : M\n⊢ Eq ((f.vecCons g) m) (Matrix.vecCons (f m) (g m))","decl":"@[simp]\ntheorem LinearMap.vecCons_apply {n} (f : M →ₗ[R] M₂) (g : M →ₗ[R] Fin n → M₂) (m : M) :\n    f.vecCons g m = Matrix.vecCons (f m) (g m) :=\n  rfl\n\n"}
{"name":"LinearMap.vecEmpty₂_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nx✝ : M\n⊢ Eq (LinearMap.vecEmpty₂ x✝) LinearMap.vecEmpty","decl":"/-- The empty bilinear map defeq to `Matrix.vecEmpty` -/\n@[simps]\ndef LinearMap.vecEmpty₂ : M →ₗ[R] M₂ →ₗ[R] Fin 0 → M₃ where\n  toFun _ := LinearMap.vecEmpty\n  map_add' _ _ := LinearMap.ext fun _ => Subsingleton.elim _ _\n  map_smul' _ _ := LinearMap.ext fun _ => Subsingleton.elim _ _\n\n"}
{"name":"LinearMap.vecCons₂_apply","module":"Mathlib.LinearAlgebra.Pi","initialProofState":"R : Type u\nM : Type v\nM₂ : Type w\nM₃ : Type y\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nn : Nat\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M₂ M₃)\ng : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M₂ (Fin n → M₃))\nm : M\n⊢ Eq ((f.vecCons₂ g) m) ((f m).vecCons (g m))","decl":"/-- A bilinear map into `Fin n.succ → M₃` can be built out of a map into `M₃` and a map into\n`Fin n → M₃` -/\n@[simps]\ndef LinearMap.vecCons₂ {n} (f : M →ₗ[R] M₂ →ₗ[R] M₃) (g : M →ₗ[R] M₂ →ₗ[R] Fin n → M₃) :\n    M →ₗ[R] M₂ →ₗ[R] Fin n.succ → M₃ where\n  toFun m := LinearMap.vecCons (f m) (g m)\n  map_add' x y :=\n    LinearMap.ext fun z => by\n      simp only [f.map_add, g.map_add, LinearMap.add_apply, LinearMap.vecCons_apply,\n        Matrix.cons_add_cons (f x z)]\n  map_smul' r x := LinearMap.ext fun z => by simp [Matrix.smul_cons r (f x z)]\n\n"}
