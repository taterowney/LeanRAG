{"name":"NNReal.strictConcaveOn_rpow","module":"Mathlib.Analysis.Convex.SpecificFunctions.Pow","initialProofState":"p : Real\nhp₀ : LT.lt 0 p\nhp₁ : LT.lt p 1\n⊢ StrictConcaveOn NNReal Set.univ fun x => HPow.hPow x p","decl":"lemma strictConcaveOn_rpow {p : ℝ} (hp₀ : 0 < p) (hp₁ : p < 1) :\n    StrictConcaveOn ℝ≥0 univ fun x : ℝ≥0 ↦ x ^ p := by\n  have hp₀' : 0 < 1 / p := div_pos zero_lt_one hp₀\n  have hp₁' : 1 < 1 / p := by rw [one_lt_div hp₀]; exact hp₁\n  let f := NNReal.orderIsoRpow (1 / p) hp₀'\n  have h₁ : StrictConvexOn ℝ≥0 univ f := by\n    refine ⟨convex_univ, fun x _ y _ hxy a b ha hb hab => ?_⟩\n    exact (strictConvexOn_rpow hp₁').2 x.2 y.2 (by simp [hxy]) ha hb (by simp; norm_cast)\n  have h₂ : ∀ x, f.symm x = x ^ p := by simp [f, NNReal.orderIsoRpow_symm_eq]\n  refine ⟨convex_univ, fun x mx y my hxy a b ha hb hab => ?_⟩\n  simp only [← h₂]\n  exact (f.strictConcaveOn_symm h₁).2 mx my hxy ha hb hab\n\n"}
{"name":"NNReal.concaveOn_rpow","module":"Mathlib.Analysis.Convex.SpecificFunctions.Pow","initialProofState":"p : Real\nhp₀ : LE.le 0 p\nhp₁ : LE.le p 1\n⊢ ConcaveOn NNReal Set.univ fun x => HPow.hPow x p","decl":"lemma concaveOn_rpow {p : ℝ} (hp₀ : 0 ≤ p) (hp₁ : p ≤ 1) :\n    ConcaveOn ℝ≥0 univ fun x : ℝ≥0 ↦ x ^ p := by\n  rcases eq_or_lt_of_le hp₀ with (rfl | hp₀)\n  · simpa only [rpow_zero] using concaveOn_const (c := 1) convex_univ\n  rcases eq_or_lt_of_le hp₁ with (rfl | hp₁)\n  · simpa only [rpow_one] using concaveOn_id convex_univ\n  exact (strictConcaveOn_rpow hp₀ hp₁).concaveOn\n\n"}
{"name":"NNReal.strictConcaveOn_sqrt","module":"Mathlib.Analysis.Convex.SpecificFunctions.Pow","initialProofState":"⊢ StrictConcaveOn NNReal Set.univ ⇑NNReal.sqrt","decl":"lemma strictConcaveOn_sqrt : StrictConcaveOn ℝ≥0 univ NNReal.sqrt := by\n  have : NNReal.sqrt = fun x : ℝ≥0 ↦ x ^ (1 / (2 : ℝ)) := by\n    ext x; exact mod_cast NNReal.sqrt_eq_rpow x\n  rw [this]\n  exact strictConcaveOn_rpow (by positivity) (by linarith)\n\n"}
{"name":"Real.strictConcaveOn_rpow","module":"Mathlib.Analysis.Convex.SpecificFunctions.Pow","initialProofState":"p : Real\nhp₀ : LT.lt 0 p\nhp₁ : LT.lt p 1\n⊢ StrictConcaveOn Real (Set.Ici 0) fun x => HPow.hPow x p","decl":"lemma strictConcaveOn_rpow {p : ℝ} (hp₀ : 0 < p) (hp₁ : p < 1) :\n    StrictConcaveOn ℝ (Set.Ici 0) fun x : ℝ ↦ x ^ p := by\n  refine ⟨convex_Ici _, fun x hx y hy hxy a b ha hb hab => ?_⟩\n  let x' : ℝ≥0 := ⟨x, hx⟩\n  let y' : ℝ≥0 := ⟨y, hy⟩\n  let a' : ℝ≥0 := ⟨a, ha.le⟩\n  let b' : ℝ≥0 := ⟨b, hb.le⟩\n  have hxy' : x' ≠ y' := Subtype.coe_ne_coe.1 hxy\n  have hab' : a' + b' = 1 := by ext; simp [a', b', hab]\n  exact_mod_cast (NNReal.strictConcaveOn_rpow hp₀ hp₁).2 (Set.mem_univ x') (Set.mem_univ y')\n    hxy' (mod_cast ha) (mod_cast hb) hab'\n\n"}
{"name":"Real.concaveOn_rpow","module":"Mathlib.Analysis.Convex.SpecificFunctions.Pow","initialProofState":"p : Real\nhp₀ : LE.le 0 p\nhp₁ : LE.le p 1\n⊢ ConcaveOn Real (Set.Ici 0) fun x => HPow.hPow x p","decl":"lemma concaveOn_rpow {p : ℝ} (hp₀ : 0 ≤ p) (hp₁ : p ≤ 1) :\n    ConcaveOn ℝ (Set.Ici 0) fun x : ℝ ↦ x ^ p := by\n  rcases eq_or_lt_of_le hp₀ with (rfl | hp₀)\n  · simpa only [rpow_zero] using concaveOn_const (c := 1) (convex_Ici _)\n  rcases eq_or_lt_of_le hp₁ with (rfl | hp₁)\n  · simpa only [rpow_one] using concaveOn_id (convex_Ici _)\n  exact (strictConcaveOn_rpow hp₀ hp₁).concaveOn\n\n"}
{"name":"Real.strictConcaveOn_sqrt","module":"Mathlib.Analysis.Convex.SpecificFunctions.Pow","initialProofState":"⊢ StrictConcaveOn Real (Set.Ici 0) fun x => x.sqrt","decl":"lemma strictConcaveOn_sqrt : StrictConcaveOn ℝ (Set.Ici 0) (√· : ℝ → ℝ) := by\n  rw [funext Real.sqrt_eq_rpow]\n  exact strictConcaveOn_rpow (by positivity) (by linarith)\n\n"}
