{"name":"CategoryTheory.Presieve.Extensive.arrows_nonempty_isColimit","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveSheaves","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_3, u_1} C\nX : C\nR : CategoryTheory.Presieve X\nself : R.Extensive\n‚ä¢ Exists fun Œ± => Exists fun x => Exists fun Z => Exists fun œÄ => And (Eq R (CategoryTheory.Presieve.ofArrows Z œÄ)) (Nonempty (CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.Cofan.mk X œÄ)))","decl":"/-- A presieve is *extensive* if it is finite and its arrows induce an isomorphism from the\ncoproduct to the target. -/\nclass Presieve.Extensive {X : C} (R : Presieve X) : Prop where\n  /-- `R` consists of a finite collection of arrows that together induce an isomorphism from the\n  coproduct of their sources. -/\n  arrows_nonempty_isColimit : ‚àÉ (Œ± : Type) (_ : Finite Œ±) (Z : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (Z a ‚ü∂ X)),\n    R = Presieve.ofArrows Z œÄ ‚àß Nonempty (IsColimit (Cofan.mk X œÄ))\n\n"}
{"name":"CategoryTheory.instHasPullbacksOfExtensive","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveSheaves","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\nX : C\nS : CategoryTheory.Presieve X\ninst‚úù : S.Extensive\n‚ä¢ S.hasPullbacks","decl":"instance {X : C} (S : Presieve X) [S.Extensive] : S.hasPullbacks where\n  has_pullbacks := by\n    obtain ‚ü®_, _, _, _, rfl, ‚ü®hc‚ü©‚ü© := Presieve.Extensive.arrows_nonempty_isColimit (R := S)\n    intro _ _ _ _ _ hg\n    cases hg\n    apply FinitaryPreExtensive.hasPullbacks_of_is_coproduct hc\n\n"}
{"name":"CategoryTheory.isSheafFor_extensive_of_preservesFiniteProducts","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveSheaves","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.FinitaryPreExtensive C\nX : C\nS : CategoryTheory.Presieve X\ninst‚úù¬π : S.Extensive\nF : CategoryTheory.Functor (Opposite C) (Type w)\ninst‚úù : CategoryTheory.Limits.PreservesFiniteProducts F\n‚ä¢ CategoryTheory.Presieve.IsSheafFor F S","decl":"/--\nA finite product preserving presheaf is a sheaf for the extensive topology on a category which is\n`FinitaryPreExtensive`.\n-/\ntheorem isSheafFor_extensive_of_preservesFiniteProducts {X : C} (S : Presieve X) [S.Extensive]\n    (F : C·µí·µñ ‚•§ Type w) [PreservesFiniteProducts F] : S.IsSheafFor F  := by\n  obtain ‚ü®Œ±, _, Z, œÄ, rfl, ‚ü®hc‚ü©‚ü© := Extensive.arrows_nonempty_isColimit (R := S)\n  have : (ofArrows Z (Cofan.mk X œÄ).inj).hasPullbacks :=\n    (inferInstance : (ofArrows Z œÄ).hasPullbacks)\n  cases nonempty_fintype Œ±\n  exact isSheafFor_of_preservesProduct _ _ hc\n\n"}
{"name":"CategoryTheory.instExtensiveOfArrowsŒπ","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveSheaves","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.FinitaryPreExtensive C\nŒ± : Type\ninst‚úù : Finite Œ±\nZ : Œ± ‚Üí C\n‚ä¢ (CategoryTheory.Presieve.ofArrows Z fun i => CategoryTheory.Limits.Sigma.Œπ Z i).Extensive","decl":"instance {Œ± : Type} [Finite Œ±] (Z : Œ± ‚Üí C) : (ofArrows Z (fun i ‚Ü¶ Sigma.Œπ Z i)).Extensive :=\n  ‚ü®‚ü®Œ±, inferInstance, Z, (fun i ‚Ü¶ Sigma.Œπ Z i), rfl, ‚ü®coproductIsCoproduct _‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.extensiveTopology.isSheaf_yoneda_obj","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveSheaves","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.FinitaryPreExtensive C\nW : C\n‚ä¢ CategoryTheory.Presieve.IsSheaf (CategoryTheory.extensiveTopology C) (CategoryTheory.yoneda.obj W)","decl":"/-- Every Yoneda-presheaf is a sheaf for the extensive topology. -/\ntheorem extensiveTopology.isSheaf_yoneda_obj (W : C) : Presieve.IsSheaf (extensiveTopology C)\n    (yoneda.obj W) := by\n  rw [extensiveTopology, isSheaf_coverage]\n  intro X R ‚ü®Y, Œ±, Z, œÄ, hR, hi‚ü©\n  have : IsIso (Sigma.desc (Cofan.inj (Cofan.mk X œÄ))) := hi\n  have : R.Extensive := ‚ü®Y, Œ±, Z, œÄ, hR, ‚ü®Cofan.isColimitOfIsIsoSigmaDesc (Cofan.mk X œÄ)‚ü©‚ü©\n  exact isSheafFor_extensive_of_preservesFiniteProducts _ _\n\n"}
{"name":"CategoryTheory.extensiveTopology.subcanonical","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveSheaves","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.FinitaryPreExtensive C\n‚ä¢ (CategoryTheory.extensiveTopology C).Subcanonical","decl":"/-- The extensive topology on a finitary pre-extensive category is subcanonical. -/\ninstance extensiveTopology.subcanonical : (extensiveTopology C).Subcanonical :=\n  GrothendieckTopology.Subcanonical.of_isSheaf_yoneda_obj _ isSheaf_yoneda_obj\n\n"}
{"name":"CategoryTheory.Presieve.isSheaf_iff_preservesFiniteProducts","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveSheaves","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.FinitaryPreExtensive C\ninst‚úù : CategoryTheory.FinitaryExtensive C\nF : CategoryTheory.Functor (Opposite C) (Type w)\n‚ä¢ Iff (CategoryTheory.Presieve.IsSheaf (CategoryTheory.extensiveTopology C) F) (Nonempty (CategoryTheory.Limits.PreservesFiniteProducts F))","decl":"/--\nA presheaf of sets on a category which is `FinitaryExtensive` is a sheaf iff it preserves finite\nproducts.\n-/\ntheorem Presieve.isSheaf_iff_preservesFiniteProducts (F : C·µí·µñ ‚•§ Type w) :\n    Presieve.IsSheaf (extensiveTopology C) F ‚Üî\n    Nonempty (PreservesFiniteProducts F) := by\n  refine ‚ü®fun hF ‚Ü¶ ‚ü®‚ü®fun Œ± _ ‚Ü¶ ‚ü®fun {K} ‚Ü¶ ?_‚ü©‚ü©‚ü©, fun hF ‚Ü¶ ?_‚ü©\n  ¬∑ rw [extensiveTopology, isSheaf_coverage] at hF\n    let Z : Œ± ‚Üí C := fun i ‚Ü¶ unop (K.obj ‚ü®i‚ü©)\n    have : (ofArrows Z (Cofan.mk (‚àê Z) (Sigma.Œπ Z)).inj).hasPullbacks :=\n      inferInstanceAs (ofArrows Z (Sigma.Œπ Z)).hasPullbacks\n    have : ‚àÄ (i : Œ±), Mono (Cofan.inj (Cofan.mk (‚àê Z) (Sigma.Œπ Z)) i) :=\n      inferInstanceAs <| ‚àÄ (i : Œ±), Mono (Sigma.Œπ Z i)\n    let i : K ‚âÖ Discrete.functor (fun i ‚Ü¶ op (Z i)) := Discrete.natIsoFunctor\n    let _ : PreservesLimit (Discrete.functor (fun i ‚Ü¶ op (Z i))) F :=\n        Presieve.preservesProduct_of_isSheafFor F ?_ initialIsInitial _ (coproductIsCoproduct Z)\n        (FinitaryExtensive.isPullback_initial_to_sigma_Œπ Z)\n        (hF (Presieve.ofArrows Z (fun i ‚Ü¶ Sigma.Œπ Z i)) ?_)\n    ¬∑ exact preservesLimit_of_iso_diagram F i.symm\n    ¬∑ apply hF\n      refine ‚ü®Empty, inferInstance, Empty.elim, IsEmpty.elim inferInstance, rfl, ‚ü®default,?_, ?_‚ü©‚ü©\n      ¬∑ ext b\n        cases b\n      ¬∑ simp only [eq_iff_true_of_subsingleton]\n    ¬∑ refine ‚ü®Œ±, inferInstance, Z, (fun i ‚Ü¶ Sigma.Œπ Z i), rfl, ?_‚ü©\n      suffices Sigma.desc (fun i ‚Ü¶ Sigma.Œπ Z i) = ùüô _ by rw [this]; infer_instance\n      ext\n      simp\n  ¬∑ let _ := hF.some\n    rw [extensiveTopology, Presieve.isSheaf_coverage]\n    intro X R ‚ü®Y, Œ±, Z, œÄ, hR, hi‚ü©\n    have : IsIso (Sigma.desc (Cofan.inj (Cofan.mk X œÄ))) := hi\n    have : R.Extensive := ‚ü®Y, Œ±, Z, œÄ, hR, ‚ü®Cofan.isColimitOfIsIsoSigmaDesc (Cofan.mk X œÄ)‚ü©‚ü©\n    exact isSheafFor_extensive_of_preservesFiniteProducts R F\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_preservesFiniteProducts","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveSheaves","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù¬π : CategoryTheory.FinitaryPreExtensive C\ninst‚úù : CategoryTheory.FinitaryExtensive C\nF : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Iff (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.extensiveTopology C) F) (CategoryTheory.Limits.PreservesFiniteProducts F)","decl":"/--\nA presheaf on a category which is `FinitaryExtensive` is a sheaf iff it preserves finite products.\n-/\ntheorem Presheaf.isSheaf_iff_preservesFiniteProducts (F : C·µí·µñ ‚•§ D) :\n    IsSheaf (extensiveTopology C) F ‚Üî PreservesFiniteProducts F := by\n  constructor\n  ¬∑ intro h\n    rw [IsSheaf] at h\n    refine ‚ü®fun J _ ‚Ü¶ ‚ü®fun {K} ‚Ü¶ ‚ü®fun {c} hc ‚Ü¶ ?_‚ü©‚ü©‚ü©\n    constructor\n    apply coyonedaJointlyReflectsLimits\n    intro ‚ü®E‚ü©\n    specialize h E\n    rw [Presieve.isSheaf_iff_preservesFiniteProducts] at h\n    have : PreservesLimit K (F.comp (coyoneda.obj ‚ü®E‚ü©)) := (h.some.preserves J).preservesLimit\n    exact isLimitOfPreserves (F.comp (coyoneda.obj ‚ü®E‚ü©)) hc\n  ¬∑ intro _ E\n    rw [Presieve.isSheaf_iff_preservesFiniteProducts]\n    exact ‚ü®inferInstance‚ü©\n\n"}
{"name":"CategoryTheory.instPreservesFiniteProductsOppositeVal","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveSheaves","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù¬π : CategoryTheory.FinitaryPreExtensive C\ninst‚úù : CategoryTheory.FinitaryExtensive C\nF : CategoryTheory.Sheaf (CategoryTheory.extensiveTopology C) D\n‚ä¢ CategoryTheory.Limits.PreservesFiniteProducts F.val","decl":"instance (F : Sheaf (extensiveTopology C) D) : PreservesFiniteProducts F.val :=\n  (Presheaf.isSheaf_iff_preservesFiniteProducts F.val).mp F.cond\n\n"}
