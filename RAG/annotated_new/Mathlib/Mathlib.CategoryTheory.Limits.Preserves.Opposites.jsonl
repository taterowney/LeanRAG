{"name":"CategoryTheory.Limits.preservesLimit_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J (Opposite C)\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimit K.leftOp F\n⊢ CategoryTheory.Limits.PreservesLimit K F.op","decl":"/-- If `F : C ⥤ D` preserves colimits of `K.leftOp : Jᵒᵖ ⥤ C`, then `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves\n    limits of `K : J ⥤ Cᵒᵖ`. -/\nlemma preservesLimit_op (K : J ⥤ Cᵒᵖ) (F : C ⥤ D) [PreservesColimit K.leftOp F] :\n    PreservesLimit K F.op where\n  preserves {_} hc :=\n    ⟨isLimitConeRightOpOfCocone _ (isColimitOfPreserves F (isColimitCoconeLeftOpOfCone _ hc))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_of_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimit K.op F.op\n⊢ CategoryTheory.Limits.PreservesLimit K F","decl":"/-- If `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits of `K.op : Jᵒᵖ ⥤ Cᵒᵖ`, then `F : C ⥤ D` preserves\n    limits of `K : J ⥤ C`. -/\nlemma preservesLimit_of_op (K : J ⥤ C) (F : C ⥤ D) [PreservesColimit K.op F.op] :\n    PreservesLimit K F where\n  preserves {_} hc := ⟨isLimitOfOp (isColimitOfPreserves F.op (IsLimit.op hc))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J (Opposite C)\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimit K.leftOp F\n⊢ CategoryTheory.Limits.PreservesLimit K F.leftOp","decl":"/-- If `F : C ⥤ Dᵒᵖ` preserves colimits of `K.leftOp : Jᵒᵖ ⥤ C`, then `F.leftOp : Cᵒᵖ ⥤ D`\n    preserves limits of `K : J ⥤ Cᵒᵖ`. -/\nlemma preservesLimit_leftOp (K : J ⥤ Cᵒᵖ) (F : C ⥤ Dᵒᵖ) [PreservesColimit K.leftOp F] :\n    PreservesLimit K F.leftOp where\n  preserves {_} hc :=\n    ⟨isLimitConeUnopOfCocone _ (isColimitOfPreserves F (isColimitCoconeLeftOpOfCone _ hc))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_of_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimit K.op F.leftOp\n⊢ CategoryTheory.Limits.PreservesLimit K F","decl":"/-- If `F.leftOp : Cᵒᵖ ⥤ D` preserves colimits of `K.op : Jᵒᵖ ⥤ Cᵒᵖ`, then `F : C ⥤ Dᵒᵖ` preserves\n    limits of `K : J ⥤ C`. -/\nlemma preservesLimit_of_leftOp (K : J ⥤ C) (F : C ⥤ Dᵒᵖ) [PreservesColimit K.op F.leftOp] :\n    PreservesLimit K F where\n  preserves {_} hc :=\n    ⟨isLimitOfCoconeLeftOpOfCone _ (isColimitOfPreserves F.leftOp (IsLimit.op hc))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesColimit K.op F\n⊢ CategoryTheory.Limits.PreservesLimit K F.rightOp","decl":"/-- If `F : Cᵒᵖ ⥤ D` preserves colimits of `K.op : Jᵒᵖ ⥤ Cᵒᵖ`, then `F.rightOp : C ⥤ Dᵒᵖ` preserves\n    limits of `K : J ⥤ C`. -/\nlemma preservesLimit_rightOp (K : J ⥤ C) (F : Cᵒᵖ ⥤ D) [PreservesColimit K.op F] :\n    PreservesLimit K F.rightOp where\n  preserves {_} hc :=\n    ⟨isLimitConeRightOpOfCocone _ (isColimitOfPreserves F hc.op)⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_of_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J (Opposite C)\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesColimit K.leftOp F.rightOp\n⊢ CategoryTheory.Limits.PreservesLimit K F","decl":"/-- If `F.rightOp : C ⥤ Dᵒᵖ` preserves colimits of `K.leftOp : Jᵒᵖ ⥤ Cᵒᵖ`, then `F : Cᵒᵖ ⥤ D`\n    preserves limits of `K : J ⥤ Cᵒᵖ`. -/\nlemma preservesLimit_of_rightOp (K : J ⥤ Cᵒᵖ) (F : Cᵒᵖ ⥤ D) [PreservesColimit K.leftOp F.rightOp] :\n    PreservesLimit K F where\n  preserves {_} hc :=\n    ⟨isLimitOfOp (isColimitOfPreserves F.rightOp (isColimitCoconeLeftOpOfCone _ hc))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimit K.op F\n⊢ CategoryTheory.Limits.PreservesLimit K F.unop","decl":"/-- If `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits of `K.op : Jᵒᵖ ⥤ Cᵒᵖ`, then `F.unop : C ⥤ D` preserves\n    limits of `K : J ⥤ C`. -/\nlemma preservesLimit_unop (K : J ⥤ C) (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesColimit K.op F] :\n    PreservesLimit K F.unop where\n  preserves {_} hc :=\n    ⟨isLimitConeUnopOfCocone _ (isColimitOfPreserves F hc.op)⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_of_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J (Opposite C)\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimit K.leftOp F.unop\n⊢ CategoryTheory.Limits.PreservesLimit K F","decl":"/-- If `F.unop : C ⥤ D` preserves colimits of `K.leftOp : Jᵒᵖ ⥤ C`, then `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves\n    limits of `K : J ⥤ Cᵒᵖ`. -/\nlemma preservesLimit_of_unop (K : J ⥤ Cᵒᵖ) (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesColimit K.leftOp F.unop] :\n    PreservesLimit K F where\n  preserves {_} hc :=\n    ⟨isLimitOfCoconeLeftOpOfCone _ (isColimitOfPreserves F.unop (isColimitCoconeLeftOpOfCone _ hc))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J (Opposite C)\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimit K.leftOp F\n⊢ CategoryTheory.Limits.PreservesColimit K F.op","decl":"/-- If `F : C ⥤ D` preserves limits of `K.leftOp : Jᵒᵖ ⥤ C`, then `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves\n    colimits of `K : J ⥤ Cᵒᵖ`. -/\nlemma preservesColimit_op (K : J ⥤ Cᵒᵖ) (F : C ⥤ D) [PreservesLimit K.leftOp F] :\n    PreservesColimit K F.op where\n  preserves {_} hc :=\n    ⟨isColimitCoconeRightOpOfCone _ (isLimitOfPreserves F (isLimitConeLeftOpOfCocone _ hc))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_of_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimit K.op F.op\n⊢ CategoryTheory.Limits.PreservesColimit K F","decl":"/-- If `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits of `K.op : Jᵒᵖ ⥤ Cᵒᵖ`, then `F : C ⥤ D` preserves\n    colimits of `K : J ⥤ C`. -/\nlemma preservesColimit_of_op (K : J ⥤ C) (F : C ⥤ D) [PreservesLimit K.op F.op] :\n    PreservesColimit K F where\n  preserves {_} hc := ⟨isColimitOfOp (isLimitOfPreserves F.op (IsColimit.op hc))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J (Opposite C)\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimit K.leftOp F\n⊢ CategoryTheory.Limits.PreservesColimit K F.leftOp","decl":"/-- If `F : C ⥤ Dᵒᵖ` preserves limits of `K.leftOp : Jᵒᵖ ⥤ C`, then `F.leftOp : Cᵒᵖ ⥤ D` preserves\n    colimits of `K : J ⥤ Cᵒᵖ`. -/\nlemma preservesColimit_leftOp (K : J ⥤ Cᵒᵖ) (F : C ⥤ Dᵒᵖ) [PreservesLimit K.leftOp F] :\n    PreservesColimit K F.leftOp where\n  preserves {_} hc :=\n    ⟨isColimitCoconeUnopOfCone _ (isLimitOfPreserves F (isLimitConeLeftOpOfCocone _ hc))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_of_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimit K.op F.leftOp\n⊢ CategoryTheory.Limits.PreservesColimit K F","decl":"/-- If `F.leftOp : Cᵒᵖ ⥤ D` preserves limits of `K.op : Jᵒᵖ ⥤ Cᵒᵖ`, then `F : C ⥤ Dᵒᵖ` preserves\n    colimits of `K : J ⥤ C`. -/\nlemma preservesColimit_of_leftOp (K : J ⥤ C) (F : C ⥤ Dᵒᵖ) [PreservesLimit K.op F.leftOp] :\n    PreservesColimit K F where\n  preserves {_} hc :=\n    ⟨isColimitOfConeLeftOpOfCocone _ (isLimitOfPreserves F.leftOp (IsColimit.op hc))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesLimit K.op F\n⊢ CategoryTheory.Limits.PreservesColimit K F.rightOp","decl":"/-- If `F : Cᵒᵖ ⥤ D` preserves limits of `K.op : Jᵒᵖ ⥤ Cᵒᵖ`, then `F.rightOp : C ⥤ Dᵒᵖ` preserves\n    colimits of `K : J ⥤ C`. -/\nlemma preservesColimit_rightOp (K : J ⥤ C) (F : Cᵒᵖ ⥤ D) [PreservesLimit K.op F] :\n    PreservesColimit K F.rightOp where\n  preserves {_} hc :=\n    ⟨isColimitCoconeRightOpOfCone _ (isLimitOfPreserves F hc.op)⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_of_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J (Opposite C)\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesLimit K.leftOp F.rightOp\n⊢ CategoryTheory.Limits.PreservesColimit K F","decl":"/-- If `F.rightOp : C ⥤ Dᵒᵖ` preserves limits of `K.leftOp : Jᵒᵖ ⥤ C`, then `F : Cᵒᵖ ⥤ D`\n    preserves colimits of `K : J ⥤ Cᵒᵖ`. -/\nlemma preservesColimit_of_rightOp (K : J ⥤ Cᵒᵖ) (F : Cᵒᵖ ⥤ D) [PreservesLimit K.leftOp F.rightOp] :\n    PreservesColimit K F where\n  preserves {_} hc :=\n    ⟨isColimitOfOp (isLimitOfPreserves F.rightOp (isLimitConeLeftOpOfCocone _ hc))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimit K.op F\n⊢ CategoryTheory.Limits.PreservesColimit K F.unop","decl":"/-- If `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits of `K.op : Jᵒᵖ ⥤ Cᵒᵖ`, then `F.unop : C ⥤ D` preserves\n    colimits of `K : J ⥤ C`. -/\nlemma preservesColimit_unop (K : J ⥤ C) (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesLimit K.op F] :\n    PreservesColimit K F.unop where\n  preserves {_} hc :=\n    ⟨isColimitCoconeUnopOfCone _ (isLimitOfPreserves F hc.op)⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_of_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nK : CategoryTheory.Functor J (Opposite C)\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimit K.leftOp F.unop\n⊢ CategoryTheory.Limits.PreservesColimit K F","decl":"/-- If `F.unop : C ⥤ D` preserves limits of `K.op : Jᵒᵖ ⥤ C`, then `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves\n    colimits of `K : J ⥤ Cᵒᵖ`. -/\nlemma preservesColimit_of_unop (K : J ⥤ Cᵒᵖ) (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesLimit K.leftOp F.unop] :\n    PreservesColimit K F where\n  preserves {_} hc :=\n    ⟨isColimitOfConeLeftOpOfCocone _ (isLimitOfPreserves F.unop (isLimitConeLeftOpOfCocone _ hc))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape (Opposite J) F\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F.op","decl":"/-- If `F : C ⥤ D` preserves colimits of shape `Jᵒᵖ`, then `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits of\n    shape `J`. -/\nlemma preservesLimitsOfShape_op (F : C ⥤ D) [PreservesColimitsOfShape Jᵒᵖ F] :\n    PreservesLimitsOfShape J F.op where preservesLimit {K} := preservesLimit_op K F\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape (Opposite J) F\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F.leftOp","decl":"/-- If `F : C ⥤ Dᵒᵖ` preserves colimits of shape `Jᵒᵖ`, then `F.leftOp : Cᵒᵖ ⥤ D` preserves limits\n    of shape `J`. -/\nlemma preservesLimitsOfShape_leftOp (F : C ⥤ Dᵒᵖ) [PreservesColimitsOfShape Jᵒᵖ F] :\n    PreservesLimitsOfShape J F.leftOp where preservesLimit {K} := preservesLimit_leftOp K F\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape (Opposite J) F\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F.rightOp","decl":"/-- If `F : Cᵒᵖ ⥤ D` preserves colimits of shape `Jᵒᵖ`, then `F.rightOp : C ⥤ Dᵒᵖ` preserves limits\n    of shape `J`. -/\nlemma preservesLimitsOfShape_rightOp (F : Cᵒᵖ ⥤ D) [PreservesColimitsOfShape Jᵒᵖ F] :\n    PreservesLimitsOfShape J F.rightOp where preservesLimit {K} := preservesLimit_rightOp K F\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape (Opposite J) F\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F.unop","decl":"/-- If `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits of shape `Jᵒᵖ`, then `F.unop : C ⥤ D` preserves limits of\n    shape `J`. -/\nlemma preservesLimitsOfShape_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesColimitsOfShape Jᵒᵖ F] :\n    PreservesLimitsOfShape J F.unop where preservesLimit {K} := preservesLimit_unop K F\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (Opposite J) F\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F.op","decl":"/-- If `F : C ⥤ D` preserves limits of shape `Jᵒᵖ`, then `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits of\n    shape `J`. -/\nlemma preservesColimitsOfShape_op (F : C ⥤ D) [PreservesLimitsOfShape Jᵒᵖ F] :\n    PreservesColimitsOfShape J F.op where preservesColimit {K} := preservesColimit_op K F\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (Opposite J) F\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F.leftOp","decl":"/-- If `F : C ⥤ Dᵒᵖ` preserves limits of shape `Jᵒᵖ`, then `F.leftOp : Cᵒᵖ ⥤ D` preserves colimits\n    of shape `J`. -/\nlemma preservesColimitsOfShape_leftOp (F : C ⥤ Dᵒᵖ) [PreservesLimitsOfShape Jᵒᵖ F] :\n    PreservesColimitsOfShape J F.leftOp where preservesColimit {K} := preservesColimit_leftOp K F\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (Opposite J) F\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F.rightOp","decl":"/-- If `F : Cᵒᵖ ⥤ D` preserves limits of shape `Jᵒᵖ`, then `F.rightOp : C ⥤ Dᵒᵖ` preserves colimits\n    of shape `J`. -/\nlemma preservesColimitsOfShape_rightOp (F : Cᵒᵖ ⥤ D) [PreservesLimitsOfShape Jᵒᵖ F] :\n    PreservesColimitsOfShape J F.rightOp where preservesColimit {K} := preservesColimit_rightOp K F\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (Opposite J) F\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F.unop","decl":"/-- If `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits of shape `Jᵒᵖ`, then `F.unop : C ⥤ D` preserves colimits\n    of shape `J`. -/\nlemma preservesColimitsOfShape_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesLimitsOfShape Jᵒᵖ F] :\n    PreservesColimitsOfShape J F.unop where preservesColimit {K} := preservesColimit_unop K F\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_of_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape (Opposite J) F.op\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/-- If `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits of shape `Jᵒᵖ`, then `F : C ⥤ D` preserves limits\n    of shape `J`. -/\nlemma preservesLimitsOfShape_of_op (F : C ⥤ D) [PreservesColimitsOfShape Jᵒᵖ F.op] :\n    PreservesLimitsOfShape J F where preservesLimit {K} := preservesLimit_of_op K F\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_of_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape (Opposite J) F.leftOp\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/-- If `F.leftOp : Cᵒᵖ ⥤ D` preserves colimits of shape `Jᵒᵖ`, then `F : C ⥤ Dᵒᵖ` preserves limits\n    of shape `J`. -/\nlemma preservesLimitsOfShape_of_leftOp (F : C ⥤ Dᵒᵖ) [PreservesColimitsOfShape Jᵒᵖ F.leftOp] :\n    PreservesLimitsOfShape J F where preservesLimit {K} := preservesLimit_of_leftOp K F\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_of_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape (Opposite J) F.rightOp\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/-- If `F.rightOp : C ⥤ Dᵒᵖ` preserves colimits of shape `Jᵒᵖ`, then `F : Cᵒᵖ ⥤ D` preserves limits\n    of shape `J`. -/\nlemma preservesLimitsOfShape_of_rightOp (F : Cᵒᵖ ⥤ D) [PreservesColimitsOfShape Jᵒᵖ F.rightOp] :\n    PreservesLimitsOfShape J F where preservesLimit {K} := preservesLimit_of_rightOp K F\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_of_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape (Opposite J) F.unop\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/-- If `F.unop : C ⥤ D` preserves colimits of shape `Jᵒᵖ`, then `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits\n    of shape `J`. -/\nlemma preservesLimitsOfShape_of_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesColimitsOfShape Jᵒᵖ F.unop] :\n    PreservesLimitsOfShape J F where preservesLimit {K} := preservesLimit_of_unop K F\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_of_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (Opposite J) F.op\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"/-- If `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits of shape `Jᵒᵖ`, then `F : C ⥤ D` preserves colimits\n    of shape `J`. -/\nlemma preservesColimitsOfShape_of_op (F : C ⥤ D) [PreservesLimitsOfShape Jᵒᵖ F.op] :\n    PreservesColimitsOfShape J F where preservesColimit {K} := preservesColimit_of_op K F\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_of_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (Opposite J) F.leftOp\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"/-- If `F.leftOp : Cᵒᵖ ⥤ D` preserves limits of shape `Jᵒᵖ`, then `F : C ⥤ Dᵒᵖ` preserves colimits\n    of shape `J`. -/\nlemma preservesColimitsOfShape_of_leftOp (F : C ⥤ Dᵒᵖ) [PreservesLimitsOfShape Jᵒᵖ F.leftOp] :\n    PreservesColimitsOfShape J F where preservesColimit {K} := preservesColimit_of_leftOp K F\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_of_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (Opposite J) F.rightOp\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"/-- If `F.rightOp : C ⥤ Dᵒᵖ` preserves limits of shape `Jᵒᵖ`, then `F : Cᵒᵖ ⥤ D` preserves colimits\n    of shape `J`. -/\nlemma preservesColimitsOfShape_of_rightOp (F : Cᵒᵖ ⥤ D) [PreservesLimitsOfShape Jᵒᵖ F.rightOp] :\n    PreservesColimitsOfShape J F where preservesColimit {K} := preservesColimit_of_rightOp K F\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_of_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (Opposite J) F.unop\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"/-- If `F.unop : C ⥤ D` preserves limits of shape `Jᵒᵖ`, then `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits\n    of shape `J`. -/\nlemma preservesColimitsOfShape_of_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesLimitsOfShape Jᵒᵖ F.unop] :\n    PreservesColimitsOfShape J F where preservesColimit {K} := preservesColimit_of_unop K F\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfSize_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.op","decl":"/-- If `F : C ⥤ D` preserves colimits, then `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits. -/\nlemma preservesLimitsOfSize_op (F : C ⥤ D) [PreservesColimitsOfSize.{w, w'} F] :\n    PreservesLimitsOfSize.{w, w'} F.op where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_op _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfSize_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.leftOp","decl":"/-- If `F : C ⥤ Dᵒᵖ` preserves colimits, then `F.leftOp : Cᵒᵖ ⥤ D` preserves limits. -/\nlemma preservesLimitsOfSize_leftOp (F : C ⥤ Dᵒᵖ) [PreservesColimitsOfSize.{w, w'} F] :\n    PreservesLimitsOfSize.{w, w'} F.leftOp where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_leftOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfSize_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.rightOp","decl":"/-- If `F : Cᵒᵖ ⥤ D` preserves colimits, then `F.rightOp : C ⥤ Dᵒᵖ` preserves limits. -/\nlemma preservesLimitsOfSize_rightOp (F : Cᵒᵖ ⥤ D) [PreservesColimitsOfSize.{w, w'} F] :\n    PreservesLimitsOfSize.{w, w'} F.rightOp where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_rightOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfSize_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.unop","decl":"/-- If `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits, then `F.unop : C ⥤ D` preserves limits. -/\nlemma preservesLimitsOfSize_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesColimitsOfSize.{w, w'} F] :\n    PreservesLimitsOfSize.{w, w'} F.unop where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_unop _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfSize_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.op","decl":"/-- If `F : C ⥤ D` preserves limits, then `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits. -/\nlemma preservesColimitsOfSize_op (F : C ⥤ D) [PreservesLimitsOfSize.{w, w'} F] :\n    PreservesColimitsOfSize.{w, w'} F.op where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_op _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfSize_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.leftOp","decl":"/-- If `F : C ⥤ Dᵒᵖ` preserves limits, then `F.leftOp : Cᵒᵖ ⥤ D` preserves colimits. -/\nlemma preservesColimitsOfSize_leftOp (F : C ⥤ Dᵒᵖ) [PreservesLimitsOfSize.{w, w'} F] :\n    PreservesColimitsOfSize.{w, w'} F.leftOp where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_leftOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfSize_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.rightOp","decl":"/-- If `F : Cᵒᵖ ⥤ D` preserves limits, then `F.rightOp : C ⥤ Dᵒᵖ` preserves colimits. -/\nlemma preservesColimitsOfSize_rightOp (F : Cᵒᵖ ⥤ D) [PreservesLimitsOfSize.{w, w'} F] :\n    PreservesColimitsOfSize.{w, w'} F.rightOp where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_rightOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfSize_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.unop","decl":"/-- If `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits, then `F.unop : C ⥤ D` preserves colimits. -/\nlemma preservesColimitsOfSize_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesLimitsOfSize.{w, w'} F] :\n    PreservesColimitsOfSize.{w, w'} F.unop where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_unop _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfSize_of_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.op\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"/-- If `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits, then `F : C ⥤ D` preserves limits. -/\nlemma preservesLimitsOfSize_of_op (F : C ⥤ D) [PreservesColimitsOfSize.{w, w'} F.op] :\n    PreservesLimitsOfSize.{w, w'} F where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_of_op _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfSize_of_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.leftOp\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"/-- If `F.leftOp : Cᵒᵖ ⥤ D` preserves colimits, then `F : C ⥤ Dᵒᵖ` preserves limits. -/\nlemma preservesLimitsOfSize_of_leftOp (F : C ⥤ Dᵒᵖ) [PreservesColimitsOfSize.{w, w'} F.leftOp] :\n    PreservesLimitsOfSize.{w, w'} F where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_of_leftOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfSize_of_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.rightOp\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"/-- If `F.rightOp : C ⥤ Dᵒᵖ` preserves colimits, then `F : Cᵒᵖ ⥤ D` preserves limits. -/\nlemma preservesLimitsOfSize_of_rightOp (F : Cᵒᵖ ⥤ D) [PreservesColimitsOfSize.{w, w'} F.rightOp] :\n    PreservesLimitsOfSize.{w, w'} F where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_of_rightOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfSize_of_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.unop\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"/-- If `F.unop : C ⥤ D` preserves colimits, then `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits. -/\nlemma preservesLimitsOfSize_of_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesColimitsOfSize.{w, w'} F.unop] :\n    PreservesLimitsOfSize.{w, w'} F where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_of_unop _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfSize_of_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.op\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"/-- If `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits, then `F : C ⥤ D` preserves colimits. -/\nlemma preservesColimitsOfSize_of_op (F : C ⥤ D) [PreservesLimitsOfSize.{w, w'} F.op] :\n    PreservesColimitsOfSize.{w, w'} F where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_of_op _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfSize_of_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.leftOp\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"/-- If `F.leftOp : Cᵒᵖ ⥤ D` preserves limits, then `F : C ⥤ Dᵒᵖ` preserves colimits. -/\nlemma preservesColimitsOfSize_of_leftOp (F : C ⥤ Dᵒᵖ) [PreservesLimitsOfSize.{w, w'} F.leftOp] :\n    PreservesColimitsOfSize.{w, w'} F where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_of_leftOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfSize_of_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.rightOp\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"/-- If `F.rightOp : C ⥤ Dᵒᵖ` preserves limits, then `F : Cᵒᵖ ⥤ D` preserves colimits. -/\nlemma preservesColimitsOfSize_of_rightOp (F : Cᵒᵖ ⥤ D) [PreservesLimitsOfSize.{w, w'} F.rightOp] :\n    PreservesColimitsOfSize.{w, w'} F where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_of_rightOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfSize_of_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F.unop\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v₁, v₂, u₁, u₂} F","decl":"/-- If `F.unop : C ⥤ D` preserves limits, then `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits. -/\nlemma preservesColimitsOfSize_of_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesLimitsOfSize.{w, w'} F.unop] :\n    PreservesColimitsOfSize.{w, w'} F where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_of_unop _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimits_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimits F\n⊢ CategoryTheory.Limits.PreservesLimits F.op","decl":"/-- If `F : C ⥤ D` preserves colimits, then `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits. -/\nlemma preservesLimits_op (F : C ⥤ D) [PreservesColimits F] : PreservesLimits F.op where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_op _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimits_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimits F\n⊢ CategoryTheory.Limits.PreservesLimits F.leftOp","decl":"/-- If `F : C ⥤ Dᵒᵖ` preserves colimits, then `F.leftOp : Cᵒᵖ ⥤ D` preserves limits. -/\nlemma preservesLimits_leftOp (F : C ⥤ Dᵒᵖ) [PreservesColimits F] : PreservesLimits F.leftOp where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_leftOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimits_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesColimits F\n⊢ CategoryTheory.Limits.PreservesLimits F.rightOp","decl":"/-- If `F : Cᵒᵖ ⥤ D` preserves colimits, then `F.rightOp : C ⥤ Dᵒᵖ` preserves limits. -/\nlemma preservesLimits_rightOp (F : Cᵒᵖ ⥤ D) [PreservesColimits F] : PreservesLimits F.rightOp where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_rightOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimits_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimits F\n⊢ CategoryTheory.Limits.PreservesLimits F.unop","decl":"/-- If `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits, then `F.unop : C ⥤ D` preserves limits. -/\nlemma preservesLimits_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesColimits F] : PreservesLimits F.unop where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_unop _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimits_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimits F\n⊢ CategoryTheory.Limits.PreservesColimits F.op","decl":"/-- If `F : C ⥤ D` preserves limits, then `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits. -/\nlemma preservesColimits_op (F : C ⥤ D) [PreservesLimits F] : PreservesColimits F.op where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_op _ _\n\n"}
{"name":"CategoryTheory.Limits.perservesColimits_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimits F\n⊢ CategoryTheory.Limits.PreservesColimits F.op","decl":"@[deprecated (since := \"2024-12-25\")] alias perservesColimits_op := preservesColimits_op\n\n"}
{"name":"CategoryTheory.Limits.preservesColimits_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimits F\n⊢ CategoryTheory.Limits.PreservesColimits F.leftOp","decl":"/-- If `F : C ⥤ Dᵒᵖ` preserves limits, then `F.leftOp : Cᵒᵖ ⥤ D` preserves colimits. -/\nlemma preservesColimits_leftOp (F : C ⥤ Dᵒᵖ) [PreservesLimits F] : PreservesColimits F.leftOp where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_leftOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimits_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesLimits F\n⊢ CategoryTheory.Limits.PreservesColimits F.rightOp","decl":"/-- If `F : Cᵒᵖ ⥤ D` preserves limits, then `F.rightOp : C ⥤ Dᵒᵖ` preserves colimits. -/\nlemma preservesColimits_rightOp (F : Cᵒᵖ ⥤ D) [PreservesLimits F] :\n    PreservesColimits F.rightOp where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_rightOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimits_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimits F\n⊢ CategoryTheory.Limits.PreservesColimits F.unop","decl":"/-- If `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits, then `F.unop : C ⥤ D` preserves colimits. -/\nlemma preservesColimits_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesLimits F] : PreservesColimits F.unop where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_unop _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimits_of_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimits F.op\n⊢ CategoryTheory.Limits.PreservesLimits F","decl":"/-- If `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits, then `F : C ⥤ D` preserves limits. -/\nlemma preservesLimits_of_op (F : C ⥤ D) [PreservesColimits F.op] : PreservesLimits F where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_of_op _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimits_of_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimits F.leftOp\n⊢ CategoryTheory.Limits.PreservesLimits F","decl":"/-- If `F.leftOp : Cᵒᵖ ⥤ D` preserves colimits, then `F : C ⥤ Dᵒᵖ` preserves limits. -/\nlemma preservesLimits_of_leftOp (F : C ⥤ Dᵒᵖ) [PreservesColimits F.leftOp] : PreservesLimits F where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_of_leftOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimits_of_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesColimits F.rightOp\n⊢ CategoryTheory.Limits.PreservesLimits F","decl":"/-- If `F.rightOp : C ⥤ Dᵒᵖ` preserves colimits, then `F : Cᵒᵖ ⥤ D` preserves limits. -/\nlemma preservesLimits_of_rightOp (F : Cᵒᵖ ⥤ D) [PreservesColimits F.rightOp] :\n    PreservesLimits F where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_of_rightOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesLimits_of_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesColimits F.unop\n⊢ CategoryTheory.Limits.PreservesLimits F","decl":"/-- If `F.unop : C ⥤ D` preserves colimits, then `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits. -/\nlemma preservesLimits_of_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesColimits F.unop] : PreservesLimits F where\n  preservesLimitsOfShape {_} _ := preservesLimitsOfShape_of_unop _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimits_of_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimits F.op\n⊢ CategoryTheory.Limits.PreservesColimits F","decl":"/-- If `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves limits, then `F : C ⥤ D` preserves colimits. -/\nlemma preservesColimits_of_op (F : C ⥤ D) [PreservesLimits F.op] : PreservesColimits F where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_of_op _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimits_of_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimits F.leftOp\n⊢ CategoryTheory.Limits.PreservesColimits F","decl":"/-- If `F.leftOp : Cᵒᵖ ⥤ D` preserves limits, then `F : C ⥤ Dᵒᵖ` preserves colimits. -/\nlemma preservesColimits_of_leftOp (F : C ⥤ Dᵒᵖ) [PreservesLimits F.leftOp] :\n    PreservesColimits F where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_of_leftOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimits_of_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesLimits F.rightOp\n⊢ CategoryTheory.Limits.PreservesColimits F","decl":"/-- If `F.rightOp : C ⥤ Dᵒᵖ` preserves limits, then `F : Cᵒᵖ ⥤ D` preserves colimits. -/\nlemma preservesColimits_of_rightOp (F : Cᵒᵖ ⥤ D) [PreservesLimits F.rightOp] :\n    PreservesColimits F where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_of_rightOp _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesColimits_of_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesLimits F.unop\n⊢ CategoryTheory.Limits.PreservesColimits F","decl":"/-- If `F.unop : C ⥤ D` preserves limits, then `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves colimits. -/\nlemma preservesColimits_of_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesLimits F.unop] : PreservesColimits F where\n  preservesColimitsOfShape {_} _ := preservesColimitsOfShape_of_unop _ _\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F.op","decl":"/-- If `F : C ⥤ D` preserves finite colimits, then `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves finite\n    limits. -/\nlemma preservesFiniteLimits_op (F : C ⥤ D) [PreservesFiniteColimits F] :\n    PreservesFiniteLimits F.op where\n  preservesFiniteLimits J _ _ := preservesLimitsOfShape_op J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F.leftOp","decl":"/-- If `F : C ⥤ Dᵒᵖ` preserves finite colimits, then `F.leftOp : Cᵒᵖ ⥤ D` preserves finite\n    limits. -/\nlemma preservesFiniteLimits_leftOp (F : C ⥤ Dᵒᵖ) [PreservesFiniteColimits F] :\n    PreservesFiniteLimits F.leftOp where\n  preservesFiniteLimits J _ _ := preservesLimitsOfShape_leftOp J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F.rightOp","decl":"/-- If `F : Cᵒᵖ ⥤ D` preserves finite colimits, then `F.rightOp : C ⥤ Dᵒᵖ` preserves finite\n    limits. -/\nlemma preservesFiniteLimits_rightOp (F : Cᵒᵖ ⥤ D) [PreservesFiniteColimits F] :\n    PreservesFiniteLimits F.rightOp where\n  preservesFiniteLimits J _ _ := preservesLimitsOfShape_rightOp J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F.unop","decl":"/-- If `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves finite colimits, then `F.unop : C ⥤ D` preserves finite\n    limits. -/\nlemma preservesFiniteLimits_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesFiniteColimits F] :\n    PreservesFiniteLimits F.unop where\n  preservesFiniteLimits J _ _ := preservesLimitsOfShape_unop J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteColimits_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F.op","decl":"/-- If `F : C ⥤ D` preserves finite limits, then `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves finite\n    colimits. -/\nlemma preservesFiniteColimits_op (F : C ⥤ D) [PreservesFiniteLimits F] :\n    PreservesFiniteColimits F.op where\n  preservesFiniteColimits J _ _ := preservesColimitsOfShape_op J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteColimits_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F.leftOp","decl":"/-- If `F : C ⥤ Dᵒᵖ` preserves finite limits, then `F.leftOp : Cᵒᵖ ⥤ D` preserves finite\n    colimits. -/\nlemma preservesFiniteColimits_leftOp (F : C ⥤ Dᵒᵖ) [PreservesFiniteLimits F] :\n    PreservesFiniteColimits F.leftOp where\n  preservesFiniteColimits J _ _ := preservesColimitsOfShape_leftOp J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteColimits_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F.rightOp","decl":"/-- If `F : Cᵒᵖ ⥤ D` preserves finite limits, then `F.rightOp : C ⥤ Dᵒᵖ` preserves finite\n    colimits. -/\nlemma preservesFiniteColimits_rightOp (F : Cᵒᵖ ⥤ D) [PreservesFiniteLimits F] :\n    PreservesFiniteColimits F.rightOp where\n  preservesFiniteColimits J _ _ := preservesColimitsOfShape_rightOp J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteColimits_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F.unop","decl":"/-- If `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves finite limits, then `F.unop : C ⥤ D` preserves finite\n    colimits. -/\nlemma preservesFiniteColimits_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesFiniteLimits F] :\n    PreservesFiniteColimits F.unop where\n  preservesFiniteColimits J _ _ := preservesColimitsOfShape_unop J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_of_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F.op\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"/-- If `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves finite colimits, then `F : C ⥤ D` preserves finite limits. -/\nlemma preservesFiniteLimits_of_op (F : C ⥤ D) [PreservesFiniteColimits F.op] :\n    PreservesFiniteLimits F where\n  preservesFiniteLimits J _ _ := preservesLimitsOfShape_of_op J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_of_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F.leftOp\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"/-- If `F.leftOp : Cᵒᵖ ⥤ D` preserves finite colimits, then `F : C ⥤ Dᵒᵖ` preserves finite\n    limits. -/\nlemma preservesFiniteLimits_of_leftOp (F : C ⥤ Dᵒᵖ) [PreservesFiniteColimits F.leftOp] :\n    PreservesFiniteLimits F where\n  preservesFiniteLimits J _ _ := preservesLimitsOfShape_of_leftOp J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_of_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F.rightOp\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"/-- If `F.rightOp : C ⥤ Dᵒᵖ` preserves finite colimits, then `F : Cᵒᵖ ⥤ D` preserves finite\n    limits. -/\nlemma preservesFiniteLimits_of_rightOp (F : Cᵒᵖ ⥤ D) [PreservesFiniteColimits F.rightOp] :\n    PreservesFiniteLimits F where\n  preservesFiniteLimits J _ _ := preservesLimitsOfShape_of_rightOp J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_of_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits F.unop\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"/-- If `F.unop : C ⥤ D` preserves finite colimits, then `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves finite limits. -/\nlemma preservesFiniteLimits_of_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesFiniteColimits F.unop] :\n    PreservesFiniteLimits F where\n  preservesFiniteLimits J _ _ := preservesLimitsOfShape_of_unop J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteColimits_of_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F.op\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"/-- If `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves finite limits, then `F : C ⥤ D` preserves finite colimits. -/\nlemma preservesFiniteColimits_of_op (F : C ⥤ D) [PreservesFiniteLimits F.op] :\n    PreservesFiniteColimits F where\n  preservesFiniteColimits J _ _ := preservesColimitsOfShape_of_op J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteColimits_of_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F.leftOp\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"/-- If `F.leftOp : Cᵒᵖ ⥤ D` preserves finite limits, then `F : C ⥤ Dᵒᵖ` preserves finite\n    colimits. -/\nlemma preservesFiniteColimits_of_leftOp (F : C ⥤ Dᵒᵖ) [PreservesFiniteLimits F.leftOp] :\n    PreservesFiniteColimits F where\n  preservesFiniteColimits J _ _ := preservesColimitsOfShape_of_leftOp J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteColimits_of_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F.rightOp\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"/-- If `F.rightOp : C ⥤ Dᵒᵖ` preserves finite limits, then `F : Cᵒᵖ ⥤ D` preserves finite\n    colimits. -/\nlemma preservesFiniteColimits_of_rightOp (F : Cᵒᵖ ⥤ D) [PreservesFiniteLimits F.rightOp] :\n    PreservesFiniteColimits F where\n  preservesFiniteColimits J _ _ := preservesColimitsOfShape_of_rightOp J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteColimits_of_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F.unop\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"/-- If `F.unop : C ⥤ D` preserves finite limits, then `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves finite colimits. -/\nlemma preservesFiniteColimits_of_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesFiniteLimits F.unop] :\n    PreservesFiniteColimits F where\n  preservesFiniteColimits J _ _ := preservesColimitsOfShape_of_unop J F\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteProducts_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFiniteCoproducts F\n⊢ CategoryTheory.Limits.PreservesFiniteProducts F.op","decl":"/-- If `F : C ⥤ D` preserves finite coproducts, then `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves finite\n    products. -/\nlemma preservesFiniteProducts_op (F : C ⥤ D) [PreservesFiniteCoproducts F] :\n    PreservesFiniteProducts F.op where\n  preserves J _ := by\n    apply (config := { allowSynthFailures := true }) preservesLimitsOfShape_op\n    exact preservesColimitsOfShape_of_equiv (Discrete.opposite J).symm _\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteProducts_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesFiniteCoproducts F\n⊢ CategoryTheory.Limits.PreservesFiniteProducts F.leftOp","decl":"/-- If `F : C ⥤ Dᵒᵖ` preserves finite coproducts, then `F.leftOp : Cᵒᵖ ⥤ D` preserves finite\n    products. -/\nlemma preservesFiniteProducts_leftOp (F : C ⥤ Dᵒᵖ) [PreservesFiniteCoproducts F] :\n    PreservesFiniteProducts F.leftOp where\n  preserves J _ := by\n    apply (config := { allowSynthFailures := true }) preservesLimitsOfShape_leftOp\n    exact preservesColimitsOfShape_of_equiv (Discrete.opposite J).symm _\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteProducts_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesFiniteCoproducts F\n⊢ CategoryTheory.Limits.PreservesFiniteProducts F.rightOp","decl":"/-- If `F : Cᵒᵖ ⥤ D` preserves finite coproducts, then `F.rightOp : C ⥤ Dᵒᵖ` preserves finite\n    products. -/\nlemma preservesFiniteProducts_rightOp (F : Cᵒᵖ ⥤ D) [PreservesFiniteCoproducts F] :\n    PreservesFiniteProducts F.rightOp where\n  preserves J _ := by\n    apply (config := { allowSynthFailures := true }) preservesLimitsOfShape_rightOp\n    exact preservesColimitsOfShape_of_equiv (Discrete.opposite J).symm _\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteProducts_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesFiniteCoproducts F\n⊢ CategoryTheory.Limits.PreservesFiniteProducts F.unop","decl":"/-- If `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves finite coproducts, then `F.unop : C ⥤ D` preserves finite\n    products. -/\nlemma preservesFiniteProducts_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesFiniteCoproducts F] :\n    PreservesFiniteProducts F.unop where\n  preserves J _ := by\n    apply (config := { allowSynthFailures := true }) preservesLimitsOfShape_unop\n    exact preservesColimitsOfShape_of_equiv (Discrete.opposite J).symm _\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteCoproducts_op","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts F\n⊢ CategoryTheory.Limits.PreservesFiniteCoproducts F.op","decl":"/-- If `F : C ⥤ D` preserves finite products, then `F.op : Cᵒᵖ ⥤ Dᵒᵖ` preserves finite\n    coproducts. -/\nlemma preservesFiniteCoproducts_op (F : C ⥤ D) [PreservesFiniteProducts F] :\n    PreservesFiniteCoproducts F.op where\n  preserves J _ := by\n    apply (config := { allowSynthFailures := true }) preservesColimitsOfShape_op\n    exact preservesLimitsOfShape_of_equiv (Discrete.opposite J).symm _\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteCoproducts_leftOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts F\n⊢ CategoryTheory.Limits.PreservesFiniteCoproducts F.leftOp","decl":"/-- If `F : C ⥤ Dᵒᵖ` preserves finite products, then `F.leftOp : Cᵒᵖ ⥤ D` preserves finite\n    coproducts. -/\nlemma preservesFiniteCoproducts_leftOp (F : C ⥤ Dᵒᵖ) [PreservesFiniteProducts F] :\n    PreservesFiniteCoproducts F.leftOp where\n  preserves J _ := by\n    apply (config := { allowSynthFailures := true }) preservesColimitsOfShape_leftOp\n    exact preservesLimitsOfShape_of_equiv (Discrete.opposite J).symm _\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteCoproducts_rightOp","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts F\n⊢ CategoryTheory.Limits.PreservesFiniteCoproducts F.rightOp","decl":"/-- If `F : Cᵒᵖ ⥤ D` preserves finite products, then `F.rightOp : C ⥤ Dᵒᵖ` preserves finite\n    coproducts. -/\nlemma preservesFiniteCoproducts_rightOp (F : Cᵒᵖ ⥤ D) [PreservesFiniteProducts F] :\n    PreservesFiniteCoproducts F.rightOp where\n  preserves J _ := by\n    apply (config := { allowSynthFailures := true }) preservesColimitsOfShape_rightOp\n    exact preservesLimitsOfShape_of_equiv (Discrete.opposite J).symm _\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteCoproducts_unop","module":"Mathlib.CategoryTheory.Limits.Preserves.Opposites","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts F\n⊢ CategoryTheory.Limits.PreservesFiniteCoproducts F.unop","decl":"/-- If `F : Cᵒᵖ ⥤ Dᵒᵖ` preserves finite products, then `F.unop : C ⥤ D` preserves finite\n    coproducts. -/\nlemma preservesFiniteCoproducts_unop (F : Cᵒᵖ ⥤ Dᵒᵖ) [PreservesFiniteProducts F] :\n    PreservesFiniteCoproducts F.unop where\n  preserves J _ := by\n    apply (config := { allowSynthFailures := true }) preservesColimitsOfShape_unop\n    exact preservesLimitsOfShape_of_equiv (Discrete.opposite J).symm _\n\n"}
