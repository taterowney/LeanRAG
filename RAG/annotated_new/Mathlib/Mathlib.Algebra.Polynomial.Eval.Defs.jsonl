{"name":"Polynomial.eval₂_def","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\np : Polynomial R\n⊢ Eq (Polynomial.eval₂ f x p) (p.sum fun e a => HMul.hMul (f a) (HPow.hPow x e))","decl":"/-- Evaluate a polynomial `p` given a ring hom `f` from the scalar ring\n  to the target and a value `x` for the variable in the target -/\nirreducible_def eval₂ (p : R[X]) : S :=\n  p.sum fun e a => f a * x ^ e\n\n"}
{"name":"Polynomial.eval₂_eq_sum","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x p) (p.sum fun e a => HMul.hMul (f a) (HPow.hPow x e))","decl":"theorem eval₂_eq_sum {f : R →+* S} {x : S} : p.eval₂ f x = p.sum fun e a => f a * x ^ e := by\n  rw [eval₂_def]\n\n"}
{"name":"Polynomial.eval₂_congr","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf g : RingHom R S\ns t : S\nφ ψ : Polynomial R\na✝² : Eq f g\na✝¹ : Eq s t\na✝ : Eq φ ψ\n⊢ Eq (Polynomial.eval₂ f s φ) (Polynomial.eval₂ g t ψ)","decl":"theorem eval₂_congr {R S : Type*} [Semiring R] [Semiring S] {f g : R →+* S} {s t : S}\n    {φ ψ : R[X]} : f = g → s = t → φ = ψ → eval₂ f s φ = eval₂ g t ψ := by\n  rintro rfl rfl rfl; rfl\n\n"}
{"name":"Polynomial.eval₂_zero","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x 0) 0","decl":"@[simp]\ntheorem eval₂_zero : (0 : R[X]).eval₂ f x = 0 := by simp [eval₂_eq_sum]\n\n"}
{"name":"Polynomial.eval₂_C","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\na : R\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x (Polynomial.C a)) (f a)","decl":"@[simp]\ntheorem eval₂_C : (C a).eval₂ f x = f a := by simp [eval₂_eq_sum]\n\n"}
{"name":"Polynomial.eval₂_X","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x Polynomial.X) x","decl":"@[simp]\ntheorem eval₂_X : X.eval₂ f x = x := by simp [eval₂_eq_sum]\n\n"}
{"name":"Polynomial.eval₂_monomial","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\nn : Nat\nr : R\n⊢ Eq (Polynomial.eval₂ f x ((Polynomial.monomial n) r)) (HMul.hMul (f r) (HPow.hPow x n))","decl":"@[simp]\ntheorem eval₂_monomial {n : ℕ} {r : R} : (monomial n r).eval₂ f x = f r * x ^ n := by\n  simp [eval₂_eq_sum]\n\n"}
{"name":"Polynomial.eval₂_X_pow","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\nn : Nat\n⊢ Eq (Polynomial.eval₂ f x (HPow.hPow Polynomial.X n)) (HPow.hPow x n)","decl":"@[simp]\ntheorem eval₂_X_pow {n : ℕ} : (X ^ n).eval₂ f x = x ^ n := by\n  rw [X_pow_eq_monomial]\n  convert eval₂_monomial f x (n := n) (r := 1)\n  simp\n\n"}
{"name":"Polynomial.eval₂_add","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np q : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x (HAdd.hAdd p q)) (HAdd.hAdd (Polynomial.eval₂ f x p) (Polynomial.eval₂ f x q))","decl":"@[simp]\ntheorem eval₂_add : (p + q).eval₂ f x = p.eval₂ f x + q.eval₂ f x := by\n  simp only [eval₂_eq_sum]\n  apply sum_add_index <;> simp [add_mul]\n\n"}
{"name":"Polynomial.eval₂_one","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x 1) 1","decl":"@[simp]\ntheorem eval₂_one : (1 : R[X]).eval₂ f x = 1 := by rw [← C_1, eval₂_C, f.map_one]\n\n"}
{"name":"Polynomial.eval₂AddMonoidHom_apply","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\np : Polynomial R\n⊢ Eq ((Polynomial.eval₂AddMonoidHom f x) p) (Polynomial.eval₂ f x p)","decl":"/-- `eval₂AddMonoidHom (f : R →+* S) (x : S)` is the `AddMonoidHom` from\n`R[X]` to `S` obtained by evaluating the pushforward of `p` along `f` at `x`. -/\n@[simps]\ndef eval₂AddMonoidHom : R[X] →+ S where\n  toFun := eval₂ f x\n  map_zero' := eval₂_zero _ _\n  map_add' _ _ := eval₂_add _ _\n\n"}
{"name":"Polynomial.eval₂_natCast","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\nn : Nat\n⊢ Eq (Polynomial.eval₂ f x ↑n) ↑n","decl":"@[simp]\ntheorem eval₂_natCast (n : ℕ) : (n : R[X]).eval₂ f x = n := by\n  induction n with\n  | zero => simp only [eval₂_zero, Nat.cast_zero]\n  | succ n ih => rw [n.cast_succ, eval₂_add, ih, eval₂_one, n.cast_succ]\n\n"}
{"name":"Polynomial.eval₂_ofNat","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝² : Semiring R\nS : Type u_1\ninst✝¹ : Semiring S\nn : Nat\ninst✝ : n.AtLeastTwo\nf : RingHom R S\na : S\n⊢ Eq (Polynomial.eval₂ f a (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\nlemma eval₂_ofNat {S : Type*} [Semiring S] (n : ℕ) [n.AtLeastTwo] (f : R →+* S) (a : S) :\n    (ofNat(n) : R[X]).eval₂ f a = ofNat(n) := by\n  simp [OfNat.ofNat]\n\n"}
{"name":"Polynomial.eval₂_sum","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝² : Semiring R\ninst✝¹ : Semiring S\nf : RingHom R S\ninst✝ : Semiring T\np : Polynomial T\ng : Nat → T → Polynomial R\nx : S\n⊢ Eq (Polynomial.eval₂ f x (p.sum g)) (p.sum fun n a => Polynomial.eval₂ f x (g n a))","decl":"theorem eval₂_sum (p : T[X]) (g : ℕ → T → R[X]) (x : S) :\n    (p.sum g).eval₂ f x = p.sum fun n a => (g n a).eval₂ f x := by\n  let T : R[X] →+ S :=\n    { toFun := eval₂ f x\n      map_zero' := eval₂_zero _ _\n      map_add' := fun p q => eval₂_add _ _ }\n  have A : ∀ y, eval₂ f x y = T y := fun y => rfl\n  simp only [A]\n  rw [sum, map_sum, sum]\n\n"}
{"name":"Polynomial.eval₂_list_sum","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nl : List (Polynomial R)\nx : S\n⊢ Eq (Polynomial.eval₂ f x l.sum) (List.map (Polynomial.eval₂ f x) l).sum","decl":"theorem eval₂_list_sum (l : List R[X]) (x : S) : eval₂ f x l.sum = (l.map (eval₂ f x)).sum :=\n  map_list_sum (eval₂AddMonoidHom f x) l\n\n"}
{"name":"Polynomial.eval₂_multiset_sum","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\ns : Multiset (Polynomial R)\nx : S\n⊢ Eq (Polynomial.eval₂ f x s.sum) (Multiset.map (Polynomial.eval₂ f x) s).sum","decl":"theorem eval₂_multiset_sum (s : Multiset R[X]) (x : S) :\n    eval₂ f x s.sum = (s.map (eval₂ f x)).sum :=\n  map_multiset_sum (eval₂AddMonoidHom f x) s\n\n"}
{"name":"Polynomial.eval₂_finset_sum","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\nι : Type y\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\ns : Finset ι\ng : ι → Polynomial R\nx : S\n⊢ Eq (Polynomial.eval₂ f x (s.sum fun i => g i)) (s.sum fun i => Polynomial.eval₂ f x (g i))","decl":"theorem eval₂_finset_sum (s : Finset ι) (g : ι → R[X]) (x : S) :\n    (∑ i ∈ s, g i).eval₂ f x = ∑ i ∈ s, (g i).eval₂ f x :=\n  map_sum (eval₂AddMonoidHom f x) _ _\n\n"}
{"name":"Polynomial.eval₂_ofFinsupp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\np : AddMonoidAlgebra R Nat\n⊢ Eq (Polynomial.eval₂ f x { toFinsupp := p }) ((AddMonoidAlgebra.liftNC ↑f ⇑((powersHom S) x)) p)","decl":"theorem eval₂_ofFinsupp {f : R →+* S} {x : S} {p : R[ℕ]} :\n    eval₂ f x (⟨p⟩ : R[X]) = liftNC (↑f) (powersHom S x) p := by\n  simp only [eval₂_eq_sum, sum, toFinsupp_sum, support, coeff]\n  rfl\n\n"}
{"name":"Polynomial.eval₂_mul_noncomm","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np q : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\nhf : ∀ (k : Nat), Commute (f (q.coeff k)) x\n⊢ Eq (Polynomial.eval₂ f x (HMul.hMul p q)) (HMul.hMul (Polynomial.eval₂ f x p) (Polynomial.eval₂ f x q))","decl":"theorem eval₂_mul_noncomm (hf : ∀ k, Commute (f <| q.coeff k) x) :\n    eval₂ f x (p * q) = eval₂ f x p * eval₂ f x q := by\n  rcases p with ⟨p⟩; rcases q with ⟨q⟩\n  simp only [coeff] at hf\n  simp only [← ofFinsupp_mul, eval₂_ofFinsupp]\n  exact liftNC_mul _ _ p q fun {k n} _hn => (hf k).pow_right n\n\n"}
{"name":"Polynomial.eval₂_mul_X","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x (HMul.hMul p Polynomial.X)) (HMul.hMul (Polynomial.eval₂ f x p) x)","decl":"@[simp]\ntheorem eval₂_mul_X : eval₂ f x (p * X) = eval₂ f x p * x := by\n  refine _root_.trans (eval₂_mul_noncomm _ _ fun k => ?_) (by rw [eval₂_X])\n  rcases em (k = 1) with (rfl | hk)\n  · simp\n  · simp [coeff_X_of_ne_one hk]\n\n"}
{"name":"Polynomial.eval₂_X_mul","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x (HMul.hMul Polynomial.X p)) (HMul.hMul (Polynomial.eval₂ f x p) x)","decl":"@[simp]\ntheorem eval₂_X_mul : eval₂ f x (X * p) = eval₂ f x p * x := by rw [X_mul, eval₂_mul_X]\n\n"}
{"name":"Polynomial.eval₂_mul_C'","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\na : R\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\nh : Commute (f a) x\n⊢ Eq (Polynomial.eval₂ f x (HMul.hMul p (Polynomial.C a))) (HMul.hMul (Polynomial.eval₂ f x p) (f a))","decl":"theorem eval₂_mul_C' (h : Commute (f a) x) : eval₂ f x (p * C a) = eval₂ f x p * f a := by\n  rw [eval₂_mul_noncomm, eval₂_C]\n  intro k\n  by_cases hk : k = 0\n  · simp only [hk, h, coeff_C_zero, coeff_C_ne_zero]\n  · simp only [coeff_C_ne_zero hk, RingHom.map_zero, Commute.zero_left]\n\n"}
{"name":"Polynomial.eval₂_list_prod_noncomm","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\nps : List (Polynomial R)\nhf : ∀ (p : Polynomial R), Membership.mem ps p → ∀ (k : Nat), Commute (f (p.coeff k)) x\n⊢ Eq (Polynomial.eval₂ f x ps.prod) (List.map (Polynomial.eval₂ f x) ps).prod","decl":"theorem eval₂_list_prod_noncomm (ps : List R[X])\n    (hf : ∀ p ∈ ps, ∀ (k), Commute (f <| coeff p k) x) :\n    eval₂ f x ps.prod = (ps.map (Polynomial.eval₂ f x)).prod := by\n  induction' ps using List.reverseRecOn with ps p ihp\n  · simp\n  · simp only [List.forall_mem_append, List.forall_mem_singleton] at hf\n    simp [eval₂_mul_noncomm _ _ hf.2, ihp hf.1]\n\n"}
{"name":"Polynomial.eval₂RingHom'_apply","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\nhf : ∀ (a : R), Commute (f a) x\np : Polynomial R\n⊢ Eq ((Polynomial.eval₂RingHom' f x hf) p) (Polynomial.eval₂ f x p)","decl":"/-- `eval₂` as a `RingHom` for noncommutative rings -/\n@[simps]\ndef eval₂RingHom' (f : R →+* S) (x : S) (hf : ∀ a, Commute (f a) x) : R[X] →+* S where\n  toFun := eval₂ f x\n  map_add' _ _ := eval₂_add _ _\n  map_zero' := eval₂_zero _ _\n  map_mul' _p q := eval₂_mul_noncomm f x fun k => hf <| coeff q k\n  map_one' := eval₂_one _ _\n\n"}
{"name":"Polynomial.eval₂_mul","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np q : Polynomial R\ninst✝ : CommSemiring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x (HMul.hMul p q)) (HMul.hMul (Polynomial.eval₂ f x p) (Polynomial.eval₂ f x q))","decl":"@[simp]\ntheorem eval₂_mul : (p * q).eval₂ f x = p.eval₂ f x * q.eval₂ f x :=\n  eval₂_mul_noncomm _ _ fun _k => Commute.all _ _\n\n"}
{"name":"Polynomial.eval₂_mul_eq_zero_of_left","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : CommSemiring S\nf : RingHom R S\nx : S\nq : Polynomial R\nhp : Eq (Polynomial.eval₂ f x p) 0\n⊢ Eq (Polynomial.eval₂ f x (HMul.hMul p q)) 0","decl":"theorem eval₂_mul_eq_zero_of_left (q : R[X]) (hp : p.eval₂ f x = 0) : (p * q).eval₂ f x = 0 := by\n  rw [eval₂_mul f x]\n  exact mul_eq_zero_of_left hp (q.eval₂ f x)\n\n"}
{"name":"Polynomial.eval₂_mul_eq_zero_of_right","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\nq : Polynomial R\ninst✝ : CommSemiring S\nf : RingHom R S\nx : S\np : Polynomial R\nhq : Eq (Polynomial.eval₂ f x q) 0\n⊢ Eq (Polynomial.eval₂ f x (HMul.hMul p q)) 0","decl":"theorem eval₂_mul_eq_zero_of_right (p : R[X]) (hq : q.eval₂ f x = 0) : (p * q).eval₂ f x = 0 := by\n  rw [eval₂_mul f x]\n  exact mul_eq_zero_of_right (p.eval₂ f x) hq\n\n"}
{"name":"Polynomial.coe_eval₂RingHom","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nx : S\n⊢ Eq (⇑(Polynomial.eval₂RingHom f x)) (Polynomial.eval₂ f x)","decl":"@[simp]\ntheorem coe_eval₂RingHom (f : R →+* S) (x) : ⇑(eval₂RingHom f x) = eval₂ f x :=\n  rfl\n\n"}
{"name":"Polynomial.eval₂_pow","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : CommSemiring S\nf : RingHom R S\nx : S\nn : Nat\n⊢ Eq (Polynomial.eval₂ f x (HPow.hPow p n)) (HPow.hPow (Polynomial.eval₂ f x p) n)","decl":"theorem eval₂_pow (n : ℕ) : (p ^ n).eval₂ f x = p.eval₂ f x ^ n :=\n  (eval₂RingHom _ _).map_pow _ _\n\n"}
{"name":"Polynomial.eval₂_dvd","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np q : Polynomial R\ninst✝ : CommSemiring S\nf : RingHom R S\nx : S\na✝ : Dvd.dvd p q\n⊢ Dvd.dvd (Polynomial.eval₂ f x p) (Polynomial.eval₂ f x q)","decl":"theorem eval₂_dvd : p ∣ q → eval₂ f x p ∣ eval₂ f x q :=\n  (eval₂RingHom f x).map_dvd\n\n"}
{"name":"Polynomial.eval₂_eq_zero_of_dvd_of_eval₂_eq_zero","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np q : Polynomial R\ninst✝ : CommSemiring S\nf : RingHom R S\nx : S\nh : Dvd.dvd p q\nh0 : Eq (Polynomial.eval₂ f x p) 0\n⊢ Eq (Polynomial.eval₂ f x q) 0","decl":"theorem eval₂_eq_zero_of_dvd_of_eval₂_eq_zero (h : p ∣ q) (h0 : eval₂ f x p = 0) :\n    eval₂ f x q = 0 :=\n  zero_dvd_iff.mp (h0 ▸ eval₂_dvd f x h)\n\n"}
{"name":"Polynomial.eval₂_list_prod","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nl : List (Polynomial R)\nx : S\n⊢ Eq (Polynomial.eval₂ f x l.prod) (List.map (Polynomial.eval₂ f x) l).prod","decl":"theorem eval₂_list_prod (l : List R[X]) (x : S) : eval₂ f x l.prod = (l.map (eval₂ f x)).prod :=\n  map_list_prod (eval₂RingHom f x) l\n\n"}
{"name":"Polynomial.eval_eq_sum","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nx : R\n⊢ Eq (Polynomial.eval x p) (p.sum fun e a => HMul.hMul a (HPow.hPow x e))","decl":"theorem eval_eq_sum : p.eval x = p.sum fun e a => a * x ^ e := by\n  rw [eval, eval₂_eq_sum]\n  rfl\n\n"}
{"name":"Polynomial.eval₂_at_apply","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝¹ : Semiring R\np : Polynomial R\nS : Type u_1\ninst✝ : Semiring S\nf : RingHom R S\nr : R\n⊢ Eq (Polynomial.eval₂ f (f r) p) (f (Polynomial.eval r p))","decl":"@[simp]\ntheorem eval₂_at_apply {S : Type*} [Semiring S] (f : R →+* S) (r : R) :\n    p.eval₂ f (f r) = f (p.eval r) := by\n  rw [eval₂_eq_sum, eval_eq_sum, sum, sum, map_sum f]\n  simp only [f.map_mul, f.map_pow]\n\n"}
{"name":"Polynomial.eval₂_at_one","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝¹ : Semiring R\np : Polynomial R\nS : Type u_1\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Eq (Polynomial.eval₂ f 1 p) (f (Polynomial.eval 1 p))","decl":"@[simp]\ntheorem eval₂_at_one {S : Type*} [Semiring S] (f : R →+* S) : p.eval₂ f 1 = f (p.eval 1) := by\n  convert eval₂_at_apply (p := p) f 1\n  simp\n\n"}
{"name":"Polynomial.eval₂_at_natCast","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝¹ : Semiring R\np : Polynomial R\nS : Type u_1\ninst✝ : Semiring S\nf : RingHom R S\nn : Nat\n⊢ Eq (Polynomial.eval₂ f (↑n) p) (f (Polynomial.eval (↑n) p))","decl":"@[simp]\ntheorem eval₂_at_natCast {S : Type*} [Semiring S] (f : R →+* S) (n : ℕ) :\n    p.eval₂ f n = f (p.eval n) := by\n  convert eval₂_at_apply (p := p) f n\n  simp\n\n"}
{"name":"Polynomial.eval₂_at_ofNat","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝² : Semiring R\np : Polynomial R\nS : Type u_1\ninst✝¹ : Semiring S\nf : RingHom R S\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Polynomial.eval₂ f (OfNat.ofNat n) p) (f (Polynomial.eval (OfNat.ofNat n) p))","decl":"@[simp]\ntheorem eval₂_at_ofNat {S : Type*} [Semiring S] (f : R →+* S) (n : ℕ) [n.AtLeastTwo] :\n    p.eval₂ f ofNat(n) = f (p.eval (ofNat(n))) := by\n  simp [OfNat.ofNat]\n\n"}
{"name":"Polynomial.eval_C","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\nx : R\n⊢ Eq (Polynomial.eval x (Polynomial.C a)) a","decl":"@[simp]\ntheorem eval_C : (C a).eval x = a :=\n  eval₂_C _ _\n\n"}
{"name":"Polynomial.eval_natCast","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\nx : R\nn : Nat\n⊢ Eq (Polynomial.eval x ↑n) ↑n","decl":"@[simp]\ntheorem eval_natCast {n : ℕ} : (n : R[X]).eval x = n := by simp only [← C_eq_natCast, eval_C]\n\n"}
{"name":"Polynomial.eval_ofNat","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nn : Nat\ninst✝ : n.AtLeastTwo\na : R\n⊢ Eq (Polynomial.eval a (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\nlemma eval_ofNat (n : ℕ) [n.AtLeastTwo] (a : R) :\n    (ofNat(n) : R[X]).eval a = ofNat(n) := by\n  simp only [OfNat.ofNat, eval_natCast]\n\n"}
{"name":"Polynomial.eval_X","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\nx : R\n⊢ Eq (Polynomial.eval x Polynomial.X) x","decl":"@[simp]\ntheorem eval_X : X.eval x = x :=\n  eval₂_X _ _\n\n"}
{"name":"Polynomial.eval_monomial","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\nx : R\nn : Nat\na : R\n⊢ Eq (Polynomial.eval x ((Polynomial.monomial n) a)) (HMul.hMul a (HPow.hPow x n))","decl":"@[simp]\ntheorem eval_monomial {n a} : (monomial n a).eval x = a * x ^ n :=\n  eval₂_monomial _ _\n\n"}
{"name":"Polynomial.eval_zero","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\nx : R\n⊢ Eq (Polynomial.eval x 0) 0","decl":"@[simp]\ntheorem eval_zero : (0 : R[X]).eval x = 0 :=\n  eval₂_zero _ _\n\n"}
{"name":"Polynomial.eval_add","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nx : R\n⊢ Eq (Polynomial.eval x (HAdd.hAdd p q)) (HAdd.hAdd (Polynomial.eval x p) (Polynomial.eval x q))","decl":"@[simp]\ntheorem eval_add : (p + q).eval x = p.eval x + q.eval x :=\n  eval₂_add _ _\n\n"}
{"name":"Polynomial.eval_one","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\nx : R\n⊢ Eq (Polynomial.eval x 1) 1","decl":"@[simp]\ntheorem eval_one : (1 : R[X]).eval x = 1 :=\n  eval₂_one _ _\n\n"}
{"name":"Polynomial.eval_C_mul","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np : Polynomial R\nx : R\n⊢ Eq (Polynomial.eval x (HMul.hMul (Polynomial.C a) p)) (HMul.hMul a (Polynomial.eval x p))","decl":"@[simp]\ntheorem eval_C_mul : (C a * p).eval x = a * p.eval x := by\n  induction p using Polynomial.induction_on' with\n  | h_add p q ph qh =>\n    simp only [mul_add, eval_add, ph, qh]\n  | h_monomial n b =>\n    simp only [mul_assoc, C_mul_monomial, eval_monomial]\n\n"}
{"name":"Polynomial.eval_natCast_mul","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nx : R\nn : Nat\n⊢ Eq (Polynomial.eval x (HMul.hMul (↑n) p)) (HMul.hMul (↑n) (Polynomial.eval x p))","decl":"@[simp]\ntheorem eval_natCast_mul {n : ℕ} : ((n : R[X]) * p).eval x = n * p.eval x := by\n  rw [← C_eq_natCast, eval_C_mul]\n\n"}
{"name":"Polynomial.eval_mul_X","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nx : R\n⊢ Eq (Polynomial.eval x (HMul.hMul p Polynomial.X)) (HMul.hMul (Polynomial.eval x p) x)","decl":"@[simp]\ntheorem eval_mul_X : (p * X).eval x = p.eval x * x := by\n  induction p using Polynomial.induction_on' with\n  | h_add p q ph qh =>\n    simp only [add_mul, eval_add, ph, qh]\n  | h_monomial n a =>\n    simp only [← monomial_one_one_eq_X, monomial_mul_monomial, eval_monomial, mul_one, pow_succ,\n      mul_assoc]\n\n"}
{"name":"Polynomial.eval_mul_X_pow","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nx : R\nk : Nat\n⊢ Eq (Polynomial.eval x (HMul.hMul p (HPow.hPow Polynomial.X k))) (HMul.hMul (Polynomial.eval x p) (HPow.hPow x k))","decl":"@[simp]\ntheorem eval_mul_X_pow {k : ℕ} : (p * X ^ k).eval x = p.eval x * x ^ k := by\n  induction k with\n  | zero => simp\n  | succ k ih => simp [pow_succ, ← mul_assoc, ih]\n\n"}
{"name":"Polynomial.eval_sum","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nf : Nat → R → Polynomial R\nx : R\n⊢ Eq (Polynomial.eval x (p.sum f)) (p.sum fun n a => Polynomial.eval x (f n a))","decl":"theorem eval_sum (p : R[X]) (f : ℕ → R → R[X]) (x : R) :\n    (p.sum f).eval x = p.sum fun n a => (f n a).eval x :=\n  eval₂_sum _ _ _ _\n\n"}
{"name":"Polynomial.eval_finset_sum","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nι : Type y\ninst✝ : Semiring R\ns : Finset ι\ng : ι → Polynomial R\nx : R\n⊢ Eq (Polynomial.eval x (s.sum fun i => g i)) (s.sum fun i => Polynomial.eval x (g i))","decl":"theorem eval_finset_sum (s : Finset ι) (g : ι → R[X]) (x : R) :\n    (∑ i ∈ s, g i).eval x = ∑ i ∈ s, (g i).eval x :=\n  eval₂_finset_sum _ _ _ _\n\n"}
{"name":"Polynomial.IsRoot.def","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np : Polynomial R\n⊢ Iff (p.IsRoot a) (Eq (Polynomial.eval a p) 0)","decl":"@[simp]\ntheorem IsRoot.def : IsRoot p a ↔ p.eval a = 0 :=\n  Iff.rfl\n\n"}
{"name":"Polynomial.IsRoot.eq_zero","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nx : R\nh : p.IsRoot x\n⊢ Eq (Polynomial.eval x p) 0","decl":"theorem IsRoot.eq_zero (h : IsRoot p x) : eval x p = 0 :=\n  h\n\n"}
{"name":"Polynomial.IsRoot.dvd","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np q : Polynomial R\nx : R\nh : p.IsRoot x\nhpq : Dvd.dvd p q\n⊢ q.IsRoot x","decl":"theorem IsRoot.dvd {R : Type*} [CommSemiring R] {p q : R[X]} {x : R} (h : p.IsRoot x)\n    (hpq : p ∣ q) : q.IsRoot x := by\n  rwa [IsRoot, eval, eval₂_eq_zero_of_dvd_of_eval₂_eq_zero _ _ hpq]\n\n"}
{"name":"Polynomial.not_isRoot_C","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\nr a : R\nhr : Ne r 0\n⊢ Not ((Polynomial.C r).IsRoot a)","decl":"theorem not_isRoot_C (r a : R) (hr : r ≠ 0) : ¬IsRoot (C r) a := by simpa using hr\n\n"}
{"name":"Polynomial.eval_surjective","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\nx : R\n⊢ Function.Surjective (Polynomial.eval x)","decl":"theorem eval_surjective (x : R) : Function.Surjective <| eval x := fun y => ⟨C y, eval_C⟩\n\n"}
{"name":"Polynomial.comp_eq_sum_left","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\n⊢ Eq (p.comp q) (p.sum fun e a => HMul.hMul (Polynomial.C a) (HPow.hPow q e))","decl":"theorem comp_eq_sum_left : p.comp q = p.sum fun e a => C a * q ^ e := by rw [comp, eval₂_eq_sum]\n\n"}
{"name":"Polynomial.comp_X","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (p.comp Polynomial.X) p","decl":"@[simp]\ntheorem comp_X : p.comp X = p := by\n  simp only [comp, eval₂_def, C_mul_X_pow_eq_monomial]\n  exact sum_monomial_eq _\n\n"}
{"name":"Polynomial.X_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (Polynomial.X.comp p) p","decl":"@[simp]\ntheorem X_comp : X.comp p = p :=\n  eval₂_X _ _\n\n"}
{"name":"Polynomial.comp_C","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (p.comp (Polynomial.C a)) (Polynomial.C (Polynomial.eval a p))","decl":"@[simp]\ntheorem comp_C : p.comp (C a) = C (p.eval a) := by simp [comp, map_sum (C : R →+* _)]\n\n"}
{"name":"Polynomial.C_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq ((Polynomial.C a).comp p) (Polynomial.C a)","decl":"@[simp]\ntheorem C_comp : (C a).comp p = C a :=\n  eval₂_C _ _\n\n"}
{"name":"Polynomial.natCast_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Eq ((↑n).comp p) ↑n","decl":"@[simp]\ntheorem natCast_comp {n : ℕ} : (n : R[X]).comp p = n := by rw [← C_eq_natCast, C_comp]\n\n"}
{"name":"Polynomial.ofNat_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝¹ : Semiring R\np : Polynomial R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq ((OfNat.ofNat n).comp p) ↑n","decl":"@[simp]\ntheorem ofNat_comp (n : ℕ) [n.AtLeastTwo] : (ofNat(n) : R[X]).comp p = n :=\n  natCast_comp\n\n"}
{"name":"Polynomial.comp_zero","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (p.comp 0) (Polynomial.C (Polynomial.eval 0 p))","decl":"@[simp]\ntheorem comp_zero : p.comp (0 : R[X]) = C (p.eval 0) := by rw [← C_0, comp_C]\n\n"}
{"name":"Polynomial.zero_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (Polynomial.comp 0 p) 0","decl":"@[simp]\ntheorem zero_comp : comp (0 : R[X]) p = 0 := by rw [← C_0, C_comp]\n\n"}
{"name":"Polynomial.comp_one","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (p.comp 1) (Polynomial.C (Polynomial.eval 1 p))","decl":"@[simp]\ntheorem comp_one : p.comp 1 = C (p.eval 1) := by rw [← C_1, comp_C]\n\n"}
{"name":"Polynomial.one_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (Polynomial.comp 1 p) 1","decl":"@[simp]\ntheorem one_comp : comp (1 : R[X]) p = 1 := by rw [← C_1, C_comp]\n\n"}
{"name":"Polynomial.add_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np q r : Polynomial R\n⊢ Eq ((HAdd.hAdd p q).comp r) (HAdd.hAdd (p.comp r) (q.comp r))","decl":"@[simp]\ntheorem add_comp : (p + q).comp r = p.comp r + q.comp r :=\n  eval₂_add _ _\n\n"}
{"name":"Polynomial.monomial_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Eq (((Polynomial.monomial n) a).comp p) (HMul.hMul (Polynomial.C a) (HPow.hPow p n))","decl":"@[simp]\ntheorem monomial_comp (n : ℕ) : (monomial n a).comp p = C a * p ^ n :=\n  eval₂_monomial _ _\n\n"}
{"name":"Polynomial.mul_X_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np r : Polynomial R\n⊢ Eq ((HMul.hMul p Polynomial.X).comp r) (HMul.hMul (p.comp r) r)","decl":"@[simp]\ntheorem mul_X_comp : (p * X).comp r = p.comp r * r := by\n  induction p using Polynomial.induction_on' with\n  | h_add p q hp hq =>\n    simp only [hp, hq, add_mul, add_comp]\n  | h_monomial n b =>\n    simp only [pow_succ, mul_assoc, monomial_mul_X, monomial_comp]\n\n"}
{"name":"Polynomial.X_pow_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nk : Nat\n⊢ Eq ((HPow.hPow Polynomial.X k).comp p) (HPow.hPow p k)","decl":"@[simp]\ntheorem X_pow_comp {k : ℕ} : (X ^ k).comp p = p ^ k := by\n  induction k with\n  | zero => simp\n  | succ k ih => simp [pow_succ, mul_X_comp, ih]\n\n"}
{"name":"Polynomial.mul_X_pow_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np r : Polynomial R\nk : Nat\n⊢ Eq ((HMul.hMul p (HPow.hPow Polynomial.X k)).comp r) (HMul.hMul (p.comp r) (HPow.hPow r k))","decl":"@[simp]\ntheorem mul_X_pow_comp {k : ℕ} : (p * X ^ k).comp r = p.comp r * r ^ k := by\n  induction k with\n  | zero => simp\n  | succ k ih => simp [ih, pow_succ, ← mul_assoc, mul_X_comp]\n\n"}
{"name":"Polynomial.C_mul_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np r : Polynomial R\n⊢ Eq ((HMul.hMul (Polynomial.C a) p).comp r) (HMul.hMul (Polynomial.C a) (p.comp r))","decl":"@[simp]\ntheorem C_mul_comp : (C a * p).comp r = C a * p.comp r := by\n  induction p using Polynomial.induction_on' with\n  | h_add p q hp hq =>\n    simp [hp, hq, mul_add]\n  | h_monomial n b =>\n    simp [mul_assoc]\n\n"}
{"name":"Polynomial.natCast_mul_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np r : Polynomial R\nn : Nat\n⊢ Eq ((HMul.hMul (↑n) p).comp r) (HMul.hMul (↑n) (p.comp r))","decl":"@[simp]\ntheorem natCast_mul_comp {n : ℕ} : ((n : R[X]) * p).comp r = n * p.comp r := by\n  rw [← C_eq_natCast, C_mul_comp]\n\n"}
{"name":"Polynomial.mul_X_add_natCast_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nn : Nat\n⊢ Eq ((HMul.hMul p (HAdd.hAdd Polynomial.X ↑n)).comp q) (HMul.hMul (p.comp q) (HAdd.hAdd q ↑n))","decl":"theorem mul_X_add_natCast_comp {n : ℕ} :\n    (p * (X + (n : R[X]))).comp q = p.comp q * (q + n) := by\n  rw [mul_add, add_comp, mul_X_comp, ← Nat.cast_comm, natCast_mul_comp, Nat.cast_comm, mul_add]\n\n"}
{"name":"Polynomial.mul_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np q r : Polynomial R\n⊢ Eq ((HMul.hMul p q).comp r) (HMul.hMul (p.comp r) (q.comp r))","decl":"@[simp]\ntheorem mul_comp {R : Type*} [CommSemiring R] (p q r : R[X]) :\n    (p * q).comp r = p.comp r * q.comp r :=\n  eval₂_mul _ _\n\n"}
{"name":"Polynomial.pow_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np q : Polynomial R\nn : Nat\n⊢ Eq ((HPow.hPow p n).comp q) (HPow.hPow (p.comp q) n)","decl":"@[simp]\ntheorem pow_comp {R : Type*} [CommSemiring R] (p q : R[X]) (n : ℕ) :\n    (p ^ n).comp q = p.comp q ^ n :=\n  (MonoidHom.mk (OneHom.mk (fun r : R[X] => r.comp q) one_comp) fun r s => mul_comp r s q).map_pow\n    p n\n\n"}
{"name":"Polynomial.comp_assoc","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nφ ψ χ : Polynomial R\n⊢ Eq ((φ.comp ψ).comp χ) (φ.comp (ψ.comp χ))","decl":"theorem comp_assoc {R : Type*} [CommSemiring R] (φ ψ χ : R[X]) :\n    (φ.comp ψ).comp χ = φ.comp (ψ.comp χ) := by\n  refine Polynomial.induction_on φ ?_ ?_ ?_ <;>\n    · intros\n      simp_all only [add_comp, mul_comp, C_comp, X_comp, pow_succ, ← mul_assoc]\n\n"}
{"name":"Polynomial.sum_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nι : Type y\ninst✝ : Semiring R\ns : Finset ι\np : ι → Polynomial R\nq : Polynomial R\n⊢ Eq ((s.sum fun i => p i).comp q) (s.sum fun i => (p i).comp q)","decl":"@[simp] lemma sum_comp (s : Finset ι) (p : ι → R[X]) (q : R[X]) :\n    (∑ i ∈ s, p i).comp q = ∑ i ∈ s, (p i).comp q := Polynomial.eval₂_finset_sum _ _ _ _\n\n"}
{"name":"Polynomial.map_C","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\na : R\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Eq (Polynomial.map f (Polynomial.C a)) (Polynomial.C (f a))","decl":"@[simp]\ntheorem map_C : (C a).map f = C (f a) :=\n  eval₂_C _ _\n\n"}
{"name":"Polynomial.map_X","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Eq (Polynomial.map f Polynomial.X) Polynomial.X","decl":"@[simp]\ntheorem map_X : X.map f = X :=\n  eval₂_X _ _\n\n"}
{"name":"Polynomial.map_monomial","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nn : Nat\na : R\n⊢ Eq (Polynomial.map f ((Polynomial.monomial n) a)) ((Polynomial.monomial n) (f a))","decl":"@[simp]\ntheorem map_monomial {n a} : (monomial n a).map f = monomial n (f a) := by\n  dsimp only [map]\n  rw [eval₂_monomial, ← C_mul_X_pow_eq_monomial]; rfl\n\n"}
{"name":"Polynomial.map_zero","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Eq (Polynomial.map f 0) 0","decl":"@[simp]\nprotected theorem map_zero : (0 : R[X]).map f = 0 :=\n  eval₂_zero _ _\n\n"}
{"name":"Polynomial.map_add","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np q : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Eq (Polynomial.map f (HAdd.hAdd p q)) (HAdd.hAdd (Polynomial.map f p) (Polynomial.map f q))","decl":"@[simp]\nprotected theorem map_add : (p + q).map f = p.map f + q.map f :=\n  eval₂_add _ _\n\n"}
{"name":"Polynomial.map_one","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Eq (Polynomial.map f 1) 1","decl":"@[simp]\nprotected theorem map_one : (1 : R[X]).map f = 1 :=\n  eval₂_one _ _\n\n"}
{"name":"Polynomial.map_mul","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np q : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Eq (Polynomial.map f (HMul.hMul p q)) (HMul.hMul (Polynomial.map f p) (Polynomial.map f q))","decl":"@[simp]\nprotected theorem map_mul : (p * q).map f = p.map f * q.map f := by\n  rw [map, eval₂_mul_noncomm]\n  exact fun k => (commute_X _).symm\n\n-- `map` is a ring-hom unconditionally, and theoretically the definition could be replaced,\n-- but this turns out not to be easy because `p.map f` does not resolve to `Polynomial.map`\n-- if `map` is a `RingHom` instead of a plain function; the elaborator does not try to coerce\n-- to a function before trying field (dot) notation (this may be technically infeasible);\n-- the relevant code is (both lines): https://github.com/leanprover-community/\n-- lean/blob/487ac5d7e9b34800502e1ddf3c7c806c01cf9d51/src/frontends/lean/elaborator.cpp#L1876-L1913\n"}
{"name":"Polynomial.coe_mapRingHom","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Eq (⇑(Polynomial.mapRingHom f)) (Polynomial.map f)","decl":"@[simp]\ntheorem coe_mapRingHom (f : R →+* S) : ⇑(mapRingHom f) = map f :=\n  rfl\n\n-- This is protected to not clash with the global `map_natCast`.\n"}
{"name":"Polynomial.map_natCast","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nn : Nat\n⊢ Eq (Polynomial.map f ↑n) ↑n","decl":"@[simp]\nprotected theorem map_natCast (n : ℕ) : (n : R[X]).map f = n :=\n  map_natCast (mapRingHom f) n\n\n"}
{"name":"Polynomial.map_ofNat","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝² : Semiring R\ninst✝¹ : Semiring S\nf : RingHom R S\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Polynomial.map f (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\nprotected theorem map_ofNat (n : ℕ) [n.AtLeastTwo] :\n    (ofNat(n) : R[X]).map f = ofNat(n) :=\n  show (n : R[X]).map f = n by rw [Polynomial.map_natCast]\n\n--TODO rename to `map_dvd_map`\n"}
{"name":"Polynomial.map_dvd","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nx y : Polynomial R\na✝ : Dvd.dvd x y\n⊢ Dvd.dvd (Polynomial.map f x) (Polynomial.map f y)","decl":"theorem map_dvd (f : R →+* S) {x y : R[X]} : x ∣ y → x.map f ∣ y.map f :=\n  (mapRingHom f).map_dvd\n\n"}
{"name":"Polynomial.mapRingHom_comp_C","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\n⊢ Eq ((Polynomial.mapRingHom f).comp Polynomial.C) (Polynomial.C.comp f)","decl":"lemma mapRingHom_comp_C {R S} [CommRing R] [CommRing S] (f : R →+* S) :\n    (mapRingHom f).comp C = C.comp f := by ext; simp\n\n"}
{"name":"Polynomial.eval₂_eq_eval_map","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x p) (Polynomial.eval x (Polynomial.map f p))","decl":"theorem eval₂_eq_eval_map {x : S} : p.eval₂ f x = (p.map f).eval x := by\n  induction p using Polynomial.induction_on' with\n  | h_add p q hp hq =>\n    simp [hp, hq]\n  | h_monomial n r =>\n    simp\n\n"}
{"name":"Polynomial.map_list_prod","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nL : List (Polynomial R)\n⊢ Eq (Polynomial.map f L.prod) (List.map (Polynomial.map f) L).prod","decl":"protected theorem map_list_prod (L : List R[X]) : L.prod.map f = (L.map <| map f).prod :=\n  Eq.symm <| List.prod_hom _ (mapRingHom f).toMonoidHom\n\n"}
{"name":"Polynomial.map_pow","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nn : Nat\n⊢ Eq (Polynomial.map f (HPow.hPow p n)) (HPow.hPow (Polynomial.map f p) n)","decl":"@[simp]\nprotected theorem map_pow (n : ℕ) : (p ^ n).map f = p.map f ^ n :=\n  (mapRingHom f).map_pow _ _\n\n"}
{"name":"Polynomial.eval_map","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval x (Polynomial.map f p)) (Polynomial.eval₂ f x p)","decl":"theorem eval_map (x : S) : (p.map f).eval x = p.eval₂ f x :=\n  (eval₂_eq_eval_map f).symm\n\n"}
{"name":"Polynomial.map_sum","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nι : Type u_1\ng : ι → Polynomial R\ns : Finset ι\n⊢ Eq (Polynomial.map f (s.sum fun i => g i)) (s.sum fun i => Polynomial.map f (g i))","decl":"protected theorem map_sum {ι : Type*} (g : ι → R[X]) (s : Finset ι) :\n    (∑ i ∈ s, g i).map f = ∑ i ∈ s, (g i).map f :=\n  map_sum (mapRingHom f) _ _\n\n"}
{"name":"Polynomial.map_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np q : Polynomial R\n⊢ Eq (Polynomial.map f (p.comp q)) ((Polynomial.map f p).comp (Polynomial.map f q))","decl":"theorem map_comp (p q : R[X]) : map f (p.comp q) = (map f p).comp (map f q) :=\n  Polynomial.induction_on p (by simp only [map_C, forall_const, C_comp, eq_self_iff_true])\n    (by\n      simp +contextual only [Polynomial.map_add, add_comp, forall_const,\n        imp_true_iff, eq_self_iff_true])\n    (by\n      simp +contextual only [pow_succ, ← mul_assoc, comp, forall_const,\n        eval₂_mul_X, imp_true_iff, eq_self_iff_true, map_X, Polynomial.map_mul])\n\n"}
{"name":"Polynomial.eval_mul","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\nx : R\n⊢ Eq (Polynomial.eval x (HMul.hMul p q)) (HMul.hMul (Polynomial.eval x p) (Polynomial.eval x q))","decl":"@[simp]\ntheorem eval_mul : (p * q).eval x = p.eval x * q.eval x :=\n  eval₂_mul _ _\n\n"}
{"name":"Polynomial.coe_evalRingHom","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nr : R\n⊢ Eq (⇑(Polynomial.evalRingHom r)) (Polynomial.eval r)","decl":"@[simp]\ntheorem coe_evalRingHom (r : R) : (evalRingHom r : R[X] → R) = eval r :=\n  rfl\n\n"}
{"name":"Polynomial.eval_pow","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Polynomial R\nx : R\nn : Nat\n⊢ Eq (Polynomial.eval x (HPow.hPow p n)) (HPow.hPow (Polynomial.eval x p) n)","decl":"@[simp]\ntheorem eval_pow (n : ℕ) : (p ^ n).eval x = p.eval x ^ n :=\n  eval₂_pow _ _ _\n\n"}
{"name":"Polynomial.eval_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\nx : R\n⊢ Eq (Polynomial.eval x (p.comp q)) (Polynomial.eval (Polynomial.eval x q) p)","decl":"@[simp]\ntheorem eval_comp : (p.comp q).eval x = p.eval (q.eval x) := by\n  induction p using Polynomial.induction_on' with\n  | h_add r s hr hs =>\n    simp [add_comp, hr, hs]\n  | h_monomial n a =>\n    simp\n\n"}
{"name":"Polynomial.isRoot_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np q : Polynomial R\nr : R\n⊢ Iff ((p.comp q).IsRoot r) (p.IsRoot (Polynomial.eval r q))","decl":"lemma isRoot_comp {R} [CommSemiring R] {p q : R[X]} {r : R} :\n    (p.comp q).IsRoot r ↔ p.IsRoot (q.eval r) := by simp_rw [IsRoot, eval_comp]\n\n"}
{"name":"Polynomial.coe_compRingHom","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nq : Polynomial R\n⊢ Eq ⇑q.compRingHom fun p => p.comp q","decl":"@[simp]\ntheorem coe_compRingHom (q : R[X]) : (compRingHom q : R[X] → R[X]) = fun p => comp p q :=\n  rfl\n\n"}
{"name":"Polynomial.coe_compRingHom_apply","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\n⊢ Eq (q.compRingHom p) (p.comp q)","decl":"theorem coe_compRingHom_apply (p q : R[X]) : (compRingHom q : R[X] → R[X]) p = comp p q :=\n  rfl\n\n"}
{"name":"Polynomial.root_mul_left_of_isRoot","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\na : R\ninst✝ : CommSemiring R\np q : Polynomial R\na✝ : q.IsRoot a\n⊢ (HMul.hMul p q).IsRoot a","decl":"theorem root_mul_left_of_isRoot (p : R[X]) {q : R[X]} : IsRoot q a → IsRoot (p * q) a := fun H => by\n  rw [IsRoot, eval_mul, IsRoot.def.1 H, mul_zero]\n\n"}
{"name":"Polynomial.root_mul_right_of_isRoot","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\na : R\ninst✝ : CommSemiring R\np q : Polynomial R\na✝ : p.IsRoot a\n⊢ (HMul.hMul p q).IsRoot a","decl":"theorem root_mul_right_of_isRoot {p : R[X]} (q : R[X]) : IsRoot p a → IsRoot (p * q) a := fun H =>\n  by rw [IsRoot, eval_mul, IsRoot.def.1 H, zero_mul]\n\n"}
{"name":"Polynomial.eval₂_multiset_prod","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\ns : Multiset (Polynomial R)\nx : S\n⊢ Eq (Polynomial.eval₂ f x s.prod) (Multiset.map (Polynomial.eval₂ f x) s).prod","decl":"theorem eval₂_multiset_prod (s : Multiset R[X]) (x : S) :\n    eval₂ f x s.prod = (s.map (eval₂ f x)).prod :=\n  map_multiset_prod (eval₂RingHom f x) s\n\n"}
{"name":"Polynomial.eval₂_finset_prod","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\nι : Type y\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\ns : Finset ι\ng : ι → Polynomial R\nx : S\n⊢ Eq (Polynomial.eval₂ f x (s.prod fun i => g i)) (s.prod fun i => Polynomial.eval₂ f x (g i))","decl":"theorem eval₂_finset_prod (s : Finset ι) (g : ι → R[X]) (x : S) :\n    (∏ i ∈ s, g i).eval₂ f x = ∏ i ∈ s, (g i).eval₂ f x :=\n  map_prod (eval₂RingHom f x) _ _\n\n"}
{"name":"Polynomial.eval_list_prod","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nl : List (Polynomial R)\nx : R\n⊢ Eq (Polynomial.eval x l.prod) (List.map (Polynomial.eval x) l).prod","decl":"/-- Polynomial evaluation commutes with `List.prod`\n-/\ntheorem eval_list_prod (l : List R[X]) (x : R) : eval x l.prod = (l.map (eval x)).prod :=\n  map_list_prod (evalRingHom x) l\n\n"}
{"name":"Polynomial.eval_multiset_prod","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Multiset (Polynomial R)\nx : R\n⊢ Eq (Polynomial.eval x s.prod) (Multiset.map (Polynomial.eval x) s).prod","decl":"/-- Polynomial evaluation commutes with `Multiset.prod`\n-/\ntheorem eval_multiset_prod (s : Multiset R[X]) (x : R) : eval x s.prod = (s.map (eval x)).prod :=\n  (evalRingHom x).map_multiset_prod s\n\n"}
{"name":"Polynomial.eval_prod","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Type u_1\ns : Finset ι\np : ι → Polynomial R\nx : R\n⊢ Eq (Polynomial.eval x (s.prod fun j => p j)) (s.prod fun j => Polynomial.eval x (p j))","decl":"/-- Polynomial evaluation commutes with `Finset.prod`\n-/\ntheorem eval_prod {ι : Type*} (s : Finset ι) (p : ι → R[X]) (x : R) :\n    eval x (∏ j ∈ s, p j) = ∏ j ∈ s, eval x (p j) :=\n  map_prod (evalRingHom x) _ _\n\n"}
{"name":"Polynomial.list_prod_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nl : List (Polynomial R)\nq : Polynomial R\n⊢ Eq (l.prod.comp q) (List.map (fun p => p.comp q) l).prod","decl":"theorem list_prod_comp (l : List R[X]) (q : R[X]) :\n    l.prod.comp q = (l.map fun p : R[X] => p.comp q).prod :=\n  map_list_prod (compRingHom q) _\n\n"}
{"name":"Polynomial.multiset_prod_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\ns : Multiset (Polynomial R)\nq : Polynomial R\n⊢ Eq (s.prod.comp q) (Multiset.map (fun p => p.comp q) s).prod","decl":"theorem multiset_prod_comp (s : Multiset R[X]) (q : R[X]) :\n    s.prod.comp q = (s.map fun p : R[X] => p.comp q).prod :=\n  map_multiset_prod (compRingHom q) _\n\n"}
{"name":"Polynomial.prod_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nι : Type u_1\ns : Finset ι\np : ι → Polynomial R\nq : Polynomial R\n⊢ Eq ((s.prod fun j => p j).comp q) (s.prod fun j => (p j).comp q)","decl":"theorem prod_comp {ι : Type*} (s : Finset ι) (p : ι → R[X]) (q : R[X]) :\n    (∏ j ∈ s, p j).comp q = ∏ j ∈ s, (p j).comp q :=\n  map_prod (compRingHom q) _ _\n\n"}
{"name":"Polynomial.isRoot_prod","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u_2\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nι : Type u_1\ns : Finset ι\np : ι → Polynomial R\nx : R\n⊢ Iff ((s.prod fun j => p j).IsRoot x) (Exists fun i => And (Membership.mem s i) ((p i).IsRoot x))","decl":"theorem isRoot_prod {R} [CommRing R] [IsDomain R] {ι : Type*} (s : Finset ι) (p : ι → R[X])\n    (x : R) : IsRoot (∏ j ∈ s, p j) x ↔ ∃ i ∈ s, IsRoot (p i) x := by\n  simp only [IsRoot, eval_prod, Finset.prod_eq_zero_iff]\n\n"}
{"name":"Polynomial.eval_dvd","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\nx : R\na✝ : Dvd.dvd p q\n⊢ Dvd.dvd (Polynomial.eval x p) (Polynomial.eval x q)","decl":"theorem eval_dvd : p ∣ q → eval x p ∣ eval x q :=\n  eval₂_dvd _ _\n\n"}
{"name":"Polynomial.eval_eq_zero_of_dvd_of_eval_eq_zero","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\nx : R\na✝¹ : Dvd.dvd p q\na✝ : Eq (Polynomial.eval x p) 0\n⊢ Eq (Polynomial.eval x q) 0","decl":"theorem eval_eq_zero_of_dvd_of_eval_eq_zero : p ∣ q → eval x p = 0 → eval x q = 0 :=\n  eval₂_eq_zero_of_dvd_of_eval₂_eq_zero _ _\n\n"}
{"name":"Polynomial.eval_geom_sum","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nn : Nat\nx : R\n⊢ Eq (Polynomial.eval x ((Finset.range n).sum fun i => HPow.hPow Polynomial.X i)) ((Finset.range n).sum fun i => HPow.hPow x i)","decl":"@[simp]\ntheorem eval_geom_sum {R} [CommSemiring R] {n : ℕ} {x : R} :\n    eval x (∑ i ∈ range n, X ^ i) = ∑ i ∈ range n, x ^ i := by simp [eval_finset_sum]\n\n"}
{"name":"Polynomial.root_mul","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\na : R\ninst✝¹ : CommSemiring R\np q : Polynomial R\ninst✝ : NoZeroDivisors R\n⊢ Iff ((HMul.hMul p q).IsRoot a) (Or (p.IsRoot a) (q.IsRoot a))","decl":"lemma root_mul : IsRoot (p * q) a ↔ IsRoot p a ∨ IsRoot q a := by\n  simp_rw [IsRoot, eval_mul, mul_eq_zero]\n\n"}
{"name":"Polynomial.root_or_root_of_root_mul","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\na : R\ninst✝¹ : CommSemiring R\np q : Polynomial R\ninst✝ : NoZeroDivisors R\nh : (HMul.hMul p q).IsRoot a\n⊢ Or (p.IsRoot a) (q.IsRoot a)","decl":"lemma root_or_root_of_root_mul (h : IsRoot (p * q) a) : IsRoot p a ∨ IsRoot q a :=\n  root_mul.1 h\n\n"}
{"name":"Polynomial.map_multiset_prod","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nm : Multiset (Polynomial R)\n⊢ Eq (Polynomial.map f m.prod) (Multiset.map (Polynomial.map f) m).prod","decl":"protected theorem map_multiset_prod (m : Multiset R[X]) : m.prod.map f = (m.map <| map f).prod :=\n  Eq.symm <| Multiset.prod_hom _ (mapRingHom f).toMonoidHom\n\n"}
{"name":"Polynomial.map_prod","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nι : Type u_1\ng : ι → Polynomial R\ns : Finset ι\n⊢ Eq (Polynomial.map f (s.prod fun i => g i)) (s.prod fun i => Polynomial.map f (g i))","decl":"protected theorem map_prod {ι : Type*} (g : ι → R[X]) (s : Finset ι) :\n    (∏ i ∈ s, g i).map f = ∏ i ∈ s, (g i).map f :=\n  map_prod (mapRingHom f) _ _\n\n"}
{"name":"Polynomial.map_sub","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝¹ : Ring R\np q : Polynomial R\nS : Type u_1\ninst✝ : Ring S\nf : RingHom R S\n⊢ Eq (Polynomial.map f (HSub.hSub p q)) (HSub.hSub (Polynomial.map f p) (Polynomial.map f q))","decl":"@[simp]\nprotected theorem map_sub {S} [Ring S] (f : R →+* S) : (p - q).map f = p.map f - q.map f :=\n  (mapRingHom f).map_sub p q\n\n"}
{"name":"Polynomial.map_neg","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝¹ : Ring R\np : Polynomial R\nS : Type u_1\ninst✝ : Ring S\nf : RingHom R S\n⊢ Eq (Polynomial.map f (Neg.neg p)) (Neg.neg (Polynomial.map f p))","decl":"@[simp]\nprotected theorem map_neg {S} [Ring S] (f : R →+* S) : (-p).map f = -p.map f :=\n  (mapRingHom f).map_neg p\n\n"}
{"name":"Polynomial.map_intCast","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝¹ : Ring R\nS : Type u_1\ninst✝ : Ring S\nf : RingHom R S\nn : Int\n⊢ Eq (Polynomial.map f ↑n) ↑n","decl":"@[simp] protected lemma map_intCast {S} [Ring S] (f : R →+* S) (n : ℤ) : map f ↑n = ↑n :=\n  map_intCast (mapRingHom f) n\n\n"}
{"name":"Polynomial.eval_intCast","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\nn : Int\nx : R\n⊢ Eq (Polynomial.eval x ↑n) ↑n","decl":"@[simp]\ntheorem eval_intCast {n : ℤ} {x : R} : (n : R[X]).eval x = n := by\n  simp only [← C_eq_intCast, eval_C]\n\n"}
{"name":"Polynomial.eval₂_neg","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝¹ : Ring R\np : Polynomial R\nS : Type u_1\ninst✝ : Ring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x (Neg.neg p)) (Neg.neg (Polynomial.eval₂ f x p))","decl":"@[simp]\ntheorem eval₂_neg {S} [Ring S] (f : R →+* S) {x : S} : (-p).eval₂ f x = -p.eval₂ f x := by\n  rw [eq_neg_iff_add_eq_zero, ← eval₂_add, neg_add_cancel, eval₂_zero]\n\n"}
{"name":"Polynomial.eval₂_sub","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝¹ : Ring R\np q : Polynomial R\nS : Type u_1\ninst✝ : Ring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x (HSub.hSub p q)) (HSub.hSub (Polynomial.eval₂ f x p) (Polynomial.eval₂ f x q))","decl":"@[simp]\ntheorem eval₂_sub {S} [Ring S] (f : R →+* S) {x : S} :\n    (p - q).eval₂ f x = p.eval₂ f x - q.eval₂ f x := by\n  rw [sub_eq_add_neg, eval₂_add, eval₂_neg, sub_eq_add_neg]\n\n"}
{"name":"Polynomial.eval_neg","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nx : R\n⊢ Eq (Polynomial.eval x (Neg.neg p)) (Neg.neg (Polynomial.eval x p))","decl":"@[simp]\ntheorem eval_neg (p : R[X]) (x : R) : (-p).eval x = -p.eval x :=\n  eval₂_neg _\n\n"}
{"name":"Polynomial.eval_sub","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nx : R\n⊢ Eq (Polynomial.eval x (HSub.hSub p q)) (HSub.hSub (Polynomial.eval x p) (Polynomial.eval x q))","decl":"@[simp]\ntheorem eval_sub (p q : R[X]) (x : R) : (p - q).eval x = p.eval x - q.eval x :=\n  eval₂_sub _\n\n"}
{"name":"Polynomial.root_X_sub_C","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\na b : R\ninst✝ : Ring R\n⊢ Iff ((HSub.hSub Polynomial.X (Polynomial.C a)).IsRoot b) (Eq a b)","decl":"theorem root_X_sub_C : IsRoot (X - C a) b ↔ a = b := by\n  rw [IsRoot.def, eval_sub, eval_X, eval_C, sub_eq_zero, eq_comm]\n\n"}
{"name":"Polynomial.neg_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\n⊢ Eq ((Neg.neg p).comp q) (Neg.neg (p.comp q))","decl":"@[simp]\ntheorem neg_comp : (-p).comp q = -p.comp q :=\n  eval₂_neg _\n\n"}
{"name":"Polynomial.sub_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\np q r : Polynomial R\n⊢ Eq ((HSub.hSub p q).comp r) (HSub.hSub (p.comp r) (q.comp r))","decl":"@[simp]\ntheorem sub_comp : (p - q).comp r = p.comp r - q.comp r :=\n  eval₂_sub _\n\n"}
{"name":"Polynomial.intCast_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\ni : Int\n⊢ Eq ((↑i).comp p) ↑i","decl":"@[simp]\ntheorem intCast_comp (i : ℤ) : comp (i : R[X]) p = i := by cases i <;> simp\n\n"}
{"name":"Polynomial.eval₂_at_intCast","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝¹ : Ring R\np : Polynomial R\nS : Type u_1\ninst✝ : Ring S\nf : RingHom R S\nn : Int\n⊢ Eq (Polynomial.eval₂ f (↑n) p) (f (Polynomial.eval (↑n) p))","decl":"@[simp]\ntheorem eval₂_at_intCast {S : Type*} [Ring S] (f : R →+* S) (n : ℤ) :\n    p.eval₂ f n = f (p.eval n) := by\n  convert eval₂_at_apply (p := p) f n\n  simp\n\n"}
{"name":"Polynomial.mul_X_sub_intCast_comp","module":"Mathlib.Algebra.Polynomial.Eval.Defs","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nn : Nat\n⊢ Eq ((HMul.hMul p (HSub.hSub Polynomial.X ↑n)).comp q) (HMul.hMul (p.comp q) (HSub.hSub q ↑n))","decl":"theorem mul_X_sub_intCast_comp {n : ℕ} :\n    (p * (X - (n : R[X]))).comp q = p.comp q * (q - n) := by\n  rw [mul_sub, sub_comp, mul_X_comp, ← Nat.cast_comm, natCast_mul_comp, Nat.cast_comm, mul_sub]\n\n"}
