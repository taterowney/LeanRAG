{"name":"MonoidHom.coe_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\n⊢ Eq (↑f.range) (Set.range ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_range (f : G →* N) : (f.range : Set N) = Set.range f :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ Eq (↑f.range) (Set.range ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_range (f : G →* N) : (f.range : Set N) = Set.range f :=\n  rfl\n\n"}
{"name":"MonoidHom.mem_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\ny : N\n⊢ Iff (Membership.mem f.range y) (Exists fun x => Eq (f x) y)","decl":"@[to_additive (attr := simp)]\ntheorem mem_range {f : G →* N} {y : N} : y ∈ f.range ↔ ∃ x, f x = y :=\n  Iff.rfl\n\n"}
{"name":"AddMonoidHom.mem_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\ny : N\n⊢ Iff (Membership.mem f.range y) (Exists fun x => Eq (f x) y)","decl":"@[to_additive (attr := simp)]\ntheorem mem_range {f : G →* N} {y : N} : y ∈ f.range ↔ ∃ x, f x = y :=\n  Iff.rfl\n\n"}
{"name":"AddMonoidHom.range_eq_map","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ Eq f.range (AddSubgroup.map f Top.top)","decl":"@[to_additive]\ntheorem range_eq_map (f : G →* N) : f.range = (⊤ : Subgroup G).map f := by ext; simp\n\n"}
{"name":"MonoidHom.range_eq_map","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\n⊢ Eq f.range (Subgroup.map f Top.top)","decl":"@[to_additive]\ntheorem range_eq_map (f : G →* N) : f.range = (⊤ : Subgroup G).map f := by ext; simp\n\n"}
{"name":"MonoidHom.range_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_7\ninst✝¹ : CommGroup G\nN : Type u_8\ninst✝ : Group N\nf : MonoidHom G N\n⊢ f.range.IsCommutative","decl":"@[to_additive]\ninstance range_isCommutative {G : Type*} [CommGroup G] {N : Type*} [Group N] (f : G →* N) :\n    f.range.IsCommutative :=\n  range_eq_map f ▸ Subgroup.map_isCommutative ⊤ f\n\n"}
{"name":"AddMonoidHom.range_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_7\ninst✝¹ : AddCommGroup G\nN : Type u_8\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ f.range.IsCommutative","decl":"@[to_additive]\ninstance range_isCommutative {G : Type*} [CommGroup G] {N : Type*} [Group N] (f : G →* N) :\n    f.range.IsCommutative :=\n  range_eq_map f ▸ Subgroup.map_isCommutative ⊤ f\n\n"}
{"name":"AddMonoidHom.restrict_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nK : AddSubgroup G\nf : AddMonoidHom G N\n⊢ Eq (f.restrict K).range (AddSubgroup.map f K)","decl":"@[to_additive (attr := simp)]\ntheorem restrict_range (f : G →* N) : (f.restrict K).range = K.map f := by\n  simp_rw [SetLike.ext_iff, mem_range, mem_map, restrict_apply, SetLike.exists,\n    exists_prop, forall_const]\n\n"}
{"name":"MonoidHom.restrict_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nK : Subgroup G\nf : MonoidHom G N\n⊢ Eq (f.restrict K).range (Subgroup.map f K)","decl":"@[to_additive (attr := simp)]\ntheorem restrict_range (f : G →* N) : (f.restrict K).range = K.map f := by\n  simp_rw [SetLike.ext_iff, mem_range, mem_map, restrict_apply, SetLike.exists,\n    exists_prop, forall_const]\n\n"}
{"name":"MonoidHom.coe_rangeRestrict","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\ng : G\n⊢ Eq (↑(f.rangeRestrict g)) (f g)","decl":"@[to_additive (attr := simp)]\ntheorem coe_rangeRestrict (f : G →* N) (g : G) : (f.rangeRestrict g : N) = f g :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_rangeRestrict","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\ng : G\n⊢ Eq (↑(f.rangeRestrict g)) (f g)","decl":"@[to_additive (attr := simp)]\ntheorem coe_rangeRestrict (f : G →* N) (g : G) : (f.rangeRestrict g : N) = f g :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_comp_rangeRestrict","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ Eq (Function.comp Subtype.val ⇑f.rangeRestrict) ⇑f","decl":"@[to_additive]\ntheorem coe_comp_rangeRestrict (f : G →* N) :\n    ((↑) : f.range → N) ∘ (⇑f.rangeRestrict : G → f.range) = f :=\n  rfl\n\n"}
{"name":"MonoidHom.coe_comp_rangeRestrict","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\n⊢ Eq (Function.comp Subtype.val ⇑f.rangeRestrict) ⇑f","decl":"@[to_additive]\ntheorem coe_comp_rangeRestrict (f : G →* N) :\n    ((↑) : f.range → N) ∘ (⇑f.rangeRestrict : G → f.range) = f :=\n  rfl\n\n"}
{"name":"AddMonoidHom.subtype_comp_rangeRestrict","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ Eq (f.range.subtype.comp f.rangeRestrict) f","decl":"@[to_additive]\ntheorem subtype_comp_rangeRestrict (f : G →* N) : f.range.subtype.comp f.rangeRestrict = f :=\n  ext <| f.coe_rangeRestrict\n\n"}
{"name":"MonoidHom.subtype_comp_rangeRestrict","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\n⊢ Eq (f.range.subtype.comp f.rangeRestrict) f","decl":"@[to_additive]\ntheorem subtype_comp_rangeRestrict (f : G →* N) : f.range.subtype.comp f.rangeRestrict = f :=\n  ext <| f.coe_rangeRestrict\n\n"}
{"name":"MonoidHom.rangeRestrict_surjective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\n⊢ Function.Surjective ⇑f.rangeRestrict","decl":"@[to_additive]\ntheorem rangeRestrict_surjective (f : G →* N) : Function.Surjective f.rangeRestrict :=\n  fun ⟨_, g, rfl⟩ => ⟨g, rfl⟩\n\n"}
{"name":"AddMonoidHom.rangeRestrict_surjective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ Function.Surjective ⇑f.rangeRestrict","decl":"@[to_additive]\ntheorem rangeRestrict_surjective (f : G →* N) : Function.Surjective f.rangeRestrict :=\n  fun ⟨_, g, rfl⟩ => ⟨g, rfl⟩\n\n"}
{"name":"MonoidHom.rangeRestrict_injective_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\n⊢ Iff (Function.Injective ⇑f.rangeRestrict) (Function.Injective ⇑f)","decl":"@[to_additive (attr := simp)]\nlemma rangeRestrict_injective_iff {f : G →* N} : Injective f.rangeRestrict ↔ Injective f := by\n  convert Set.injective_codRestrict _\n\n"}
{"name":"AddMonoidHom.rangeRestrict_injective_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ Iff (Function.Injective ⇑f.rangeRestrict) (Function.Injective ⇑f)","decl":"@[to_additive (attr := simp)]\nlemma rangeRestrict_injective_iff {f : G →* N} : Injective f.rangeRestrict ↔ Injective f := by\n  convert Set.injective_codRestrict _\n\n"}
{"name":"AddMonoidHom.map_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nN : Type u_5\nP : Type u_6\ninst✝¹ : AddGroup N\ninst✝ : AddGroup P\ng : AddMonoidHom N P\nf : AddMonoidHom G N\n⊢ Eq (AddSubgroup.map g f.range) (g.comp f).range","decl":"@[to_additive]\ntheorem map_range (g : N →* P) (f : G →* N) : f.range.map g = (g.comp f).range := by\n  rw [range_eq_map, range_eq_map]; exact (⊤ : Subgroup G).map_map g f\n\n"}
{"name":"MonoidHom.map_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝² : Group G\nN : Type u_5\nP : Type u_6\ninst✝¹ : Group N\ninst✝ : Group P\ng : MonoidHom N P\nf : MonoidHom G N\n⊢ Eq (Subgroup.map g f.range) (g.comp f).range","decl":"@[to_additive]\ntheorem map_range (g : N →* P) (f : G →* N) : f.range.map g = (g.comp f).range := by\n  rw [range_eq_map, range_eq_map]; exact (⊤ : Subgroup G).map_map g f\n\n"}
{"name":"AddMonoidHom.range_comp","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nN : Type u_5\nP : Type u_6\ninst✝¹ : AddGroup N\ninst✝ : AddGroup P\ng : AddMonoidHom N P\nf : AddMonoidHom G N\n⊢ Eq (g.comp f).range (AddSubgroup.map g f.range)","decl":"@[to_additive]\nlemma range_comp (g : N →* P) (f : G →* N) : (g.comp f).range = f.range.map g := (map_range ..).symm\n\n"}
{"name":"MonoidHom.range_comp","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝² : Group G\nN : Type u_5\nP : Type u_6\ninst✝¹ : Group N\ninst✝ : Group P\ng : MonoidHom N P\nf : MonoidHom G N\n⊢ Eq (g.comp f).range (Subgroup.map g f.range)","decl":"@[to_additive]\nlemma range_comp (g : N →* P) (f : G →* N) : (g.comp f).range = f.range.map g := (map_range ..).symm\n\n"}
{"name":"MonoidHom.range_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_7\ninst✝ : Group N\nf : MonoidHom G N\n⊢ Iff (Eq f.range Top.top) (Function.Surjective ⇑f)","decl":"@[to_additive]\ntheorem range_eq_top {N} [Group N] {f : G →* N} :\n    f.range = (⊤ : Subgroup N) ↔ Function.Surjective f :=\n  SetLike.ext'_iff.trans <| Iff.trans (by rw [coe_range, coe_top]) Set.range_eq_univ\n\n"}
{"name":"AddMonoidHom.range_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_7\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ Iff (Eq f.range Top.top) (Function.Surjective ⇑f)","decl":"@[to_additive]\ntheorem range_eq_top {N} [Group N] {f : G →* N} :\n    f.range = (⊤ : Subgroup N) ↔ Function.Surjective f :=\n  SetLike.ext'_iff.trans <| Iff.trans (by rw [coe_range, coe_top]) Set.range_eq_univ\n\n"}
{"name":"MonoidHom.range_top_iff_surjective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_7\ninst✝ : Group N\nf : MonoidHom G N\n⊢ Iff (Eq f.range Top.top) (Function.Surjective ⇑f)","decl":"@[deprecated (since := \"2024-11-11\")] alias range_top_iff_surjective := range_eq_top\n\n"}
{"name":"MonoidHom.range_eq_top_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_7\ninst✝ : Group N\nf : MonoidHom G N\nhf : Function.Surjective ⇑f\n⊢ Eq f.range Top.top","decl":"/-- The range of a surjective monoid homomorphism is the whole of the codomain. -/\n@[to_additive (attr := simp)\n  \"The range of a surjective `AddMonoid` homomorphism is the whole of the codomain.\"]\ntheorem range_eq_top_of_surjective {N} [Group N] (f : G →* N) (hf : Function.Surjective f) :\n    f.range = (⊤ : Subgroup N) :=\n  range_eq_top.2 hf\n\n"}
{"name":"AddMonoidHom.range_eq_top_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_7\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nhf : Function.Surjective ⇑f\n⊢ Eq f.range Top.top","decl":"/-- The range of a surjective monoid homomorphism is the whole of the codomain. -/\n@[to_additive (attr := simp)\n  \"The range of a surjective `AddMonoid` homomorphism is the whole of the codomain.\"]\ntheorem range_eq_top_of_surjective {N} [Group N] (f : G →* N) (hf : Function.Surjective f) :\n    f.range = (⊤ : Subgroup N) :=\n  range_eq_top.2 hf\n\n"}
{"name":"MonoidHom.range_top_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_7\ninst✝ : Group N\nf : MonoidHom G N\nhf : Function.Surjective ⇑f\n⊢ Eq f.range Top.top","decl":"@[deprecated (since := \"2024-11-11\")] alias range_top_of_surjective := range_eq_top_of_surjective\n\n"}
{"name":"MonoidHom.range_one","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\n⊢ Eq (MonoidHom.range 1) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem range_one : (1 : G →* N).range = ⊥ :=\n  SetLike.ext fun x => by simpa using @comm _ (· = ·) _ 1 x\n\n"}
{"name":"AddMonoidHom.range_zero","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\n⊢ Eq (AddMonoidHom.range 0) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem range_one : (1 : G →* N).range = ⊥ :=\n  SetLike.ext fun x => by simpa using @comm _ (· = ·) _ 1 x\n\n"}
{"name":"Subgroup.range_subtype","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq H.subtype.range H","decl":"@[to_additive (attr := simp)]\ntheorem _root_.Subgroup.range_subtype (H : Subgroup G) : H.subtype.range = H :=\n  SetLike.coe_injective <| (coe_range _).trans <| Subtype.range_coe\n\n"}
{"name":"AddSubgroup.range_subtype","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq H.subtype.range H","decl":"@[to_additive (attr := simp)]\ntheorem _root_.Subgroup.range_subtype (H : Subgroup G) : H.subtype.range = H :=\n  SetLike.coe_injective <| (coe_range _).trans <| Subtype.range_coe\n\n"}
{"name":"Subgroup.subtype_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq H.subtype.range H","decl":"@[to_additive]\nalias _root_.Subgroup.subtype_range := Subgroup.range_subtype\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"AddSubgroup.subtype_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq H.subtype.range H","decl":"@[to_additive]\nalias _root_.Subgroup.subtype_range := Subgroup.range_subtype\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"AddSubgroup.inclusion_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh_le : LE.le H K\n⊢ Eq (AddSubgroup.inclusion h_le).range (H.addSubgroupOf K)","decl":"@[to_additive (attr := simp)]\ntheorem _root_.Subgroup.inclusion_range {H K : Subgroup G} (h_le : H ≤ K) :\n    (inclusion h_le).range = H.subgroupOf K :=\n  Subgroup.ext fun g => Set.ext_iff.mp (Set.range_inclusion h_le) g\n\n"}
{"name":"Subgroup.inclusion_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh_le : LE.le H K\n⊢ Eq (Subgroup.inclusion h_le).range (H.subgroupOf K)","decl":"@[to_additive (attr := simp)]\ntheorem _root_.Subgroup.inclusion_range {H K : Subgroup G} (h_le : H ≤ K) :\n    (inclusion h_le).range = H.subgroupOf K :=\n  Subgroup.ext fun g => Set.ext_iff.mp (Set.range_inclusion h_le) g\n\n"}
{"name":"AddMonoidHom.addSubgroupOf_range_eq_of_le","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G₁ : Type u_7\nG₂ : Type u_8\ninst✝¹ : AddGroup G₁\ninst✝ : AddGroup G₂\nK : AddSubgroup G₂\nf : AddMonoidHom G₁ G₂\nh : LE.le f.range K\n⊢ Eq (f.range.addSubgroupOf K) (f.codRestrict K ⋯).range","decl":"@[to_additive]\ntheorem subgroupOf_range_eq_of_le {G₁ G₂ : Type*} [Group G₁] [Group G₂] {K : Subgroup G₂}\n    (f : G₁ →* G₂) (h : f.range ≤ K) :\n    f.range.subgroupOf K = (f.codRestrict K fun x => h ⟨x, rfl⟩).range := by\n  ext k\n  refine exists_congr ?_\n  simp [Subtype.ext_iff]\n\n"}
{"name":"MonoidHom.subgroupOf_range_eq_of_le","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G₁ : Type u_7\nG₂ : Type u_8\ninst✝¹ : Group G₁\ninst✝ : Group G₂\nK : Subgroup G₂\nf : MonoidHom G₁ G₂\nh : LE.le f.range K\n⊢ Eq (f.range.subgroupOf K) (f.codRestrict K ⋯).range","decl":"@[to_additive]\ntheorem subgroupOf_range_eq_of_le {G₁ G₂ : Type*} [Group G₁] [Group G₂] {K : Subgroup G₂}\n    (f : G₁ →* G₂) (h : f.range ≤ K) :\n    f.range.subgroupOf K = (f.codRestrict K fun x => h ⟨x, rfl⟩).range := by\n  ext k\n  refine exists_congr ?_\n  simp [Subtype.ext_iff]\n\n"}
{"name":"AddMonoidHom.ofLeftInverse_apply","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\ng : AddMonoidHom N G\nh : Function.LeftInverse ⇑g ⇑f\nx : G\n⊢ Eq (↑((AddMonoidHom.ofLeftInverse h) x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem ofLeftInverse_apply {f : G →* N} {g : N →* G} (h : Function.LeftInverse g f) (x : G) :\n    ↑(ofLeftInverse h x) = f x :=\n  rfl\n\n"}
{"name":"MonoidHom.ofLeftInverse_apply","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\ng : MonoidHom N G\nh : Function.LeftInverse ⇑g ⇑f\nx : G\n⊢ Eq (↑((MonoidHom.ofLeftInverse h) x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem ofLeftInverse_apply {f : G →* N} {g : N →* G} (h : Function.LeftInverse g f) (x : G) :\n    ↑(ofLeftInverse h x) = f x :=\n  rfl\n\n"}
{"name":"MonoidHom.ofLeftInverse_symm_apply","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\ng : MonoidHom N G\nh : Function.LeftInverse ⇑g ⇑f\nx : Subtype fun x => Membership.mem f.range x\n⊢ Eq ((MonoidHom.ofLeftInverse h).symm x) (g ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem ofLeftInverse_symm_apply {f : G →* N} {g : N →* G} (h : Function.LeftInverse g f)\n    (x : f.range) : (ofLeftInverse h).symm x = g x :=\n  rfl\n\n"}
{"name":"AddMonoidHom.ofLeftInverse_symm_apply","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\ng : AddMonoidHom N G\nh : Function.LeftInverse ⇑g ⇑f\nx : Subtype fun x => Membership.mem f.range x\n⊢ Eq ((AddMonoidHom.ofLeftInverse h).symm x) (g ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem ofLeftInverse_symm_apply {f : G →* N} {g : N →* G} (h : Function.LeftInverse g f)\n    (x : f.range) : (ofLeftInverse h).symm x = g x :=\n  rfl\n\n"}
{"name":"AddMonoidHom.ofInjective_apply","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nhf : Function.Injective ⇑f\nx : G\n⊢ Eq (↑((AddMonoidHom.ofInjective hf) x)) (f x)","decl":"@[to_additive]\ntheorem ofInjective_apply {f : G →* N} (hf : Function.Injective f) {x : G} :\n    ↑(ofInjective hf x) = f x :=\n  rfl\n\n"}
{"name":"MonoidHom.ofInjective_apply","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nhf : Function.Injective ⇑f\nx : G\n⊢ Eq (↑((MonoidHom.ofInjective hf) x)) (f x)","decl":"@[to_additive]\ntheorem ofInjective_apply {f : G →* N} (hf : Function.Injective f) {x : G} :\n    ↑(ofInjective hf x) = f x :=\n  rfl\n\n"}
{"name":"AddMonoidHom.apply_ofInjective_symm","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nhf : Function.Injective ⇑f\nx : Subtype fun x => Membership.mem f.range x\n⊢ Eq (f ((AddMonoidHom.ofInjective hf).symm x)) ↑x","decl":"@[to_additive (attr := simp)]\ntheorem apply_ofInjective_symm {f : G →* N} (hf : Function.Injective f) (x : f.range) :\n    f ((ofInjective hf).symm x) = x :=\n  Subtype.ext_iff.1 <| (ofInjective hf).apply_symm_apply x\n\n"}
{"name":"MonoidHom.apply_ofInjective_symm","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nhf : Function.Injective ⇑f\nx : Subtype fun x => Membership.mem f.range x\n⊢ Eq (f ((MonoidHom.ofInjective hf).symm x)) ↑x","decl":"@[to_additive (attr := simp)]\ntheorem apply_ofInjective_symm {f : G →* N} (hf : Function.Injective f) (x : f.range) :\n    f ((ofInjective hf).symm x) = x :=\n  Subtype.ext_iff.1 <| (ofInjective hf).apply_symm_apply x\n\n"}
{"name":"MonoidHom.coe_toAdditive_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nf : MonoidHom G G'\n⊢ Eq (MonoidHom.toAdditive f).range (Subgroup.toAddSubgroup f.range)","decl":"@[simp]\ntheorem coe_toAdditive_range (f : G →* G') :\n    (MonoidHom.toAdditive f).range = Subgroup.toAddSubgroup f.range := rfl\n\n"}
{"name":"MonoidHom.coe_toMultiplicative_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"A : Type u_7\nA' : Type u_8\ninst✝¹ : AddGroup A\ninst✝ : AddGroup A'\nf : AddMonoidHom A A'\n⊢ Eq (AddMonoidHom.toMultiplicative f).range (AddSubgroup.toSubgroup f.range)","decl":"@[simp]\ntheorem coe_toMultiplicative_range {A A' : Type*} [AddGroup A] [AddGroup A'] (f : A →+ A') :\n    (AddMonoidHom.toMultiplicative f).range = AddSubgroup.toSubgroup f.range := rfl\n\n"}
{"name":"AddMonoidHom.mem_ker","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nM : Type u_7\ninst✝ : AddZeroClass M\nf : AddMonoidHom G M\nx : G\n⊢ Iff (Membership.mem f.ker x) (Eq (f x) 0)","decl":"@[to_additive (attr := simp)]\ntheorem mem_ker {f : G →* M} {x : G} : x ∈ f.ker ↔ f x = 1 :=\n  Iff.rfl\n\n"}
{"name":"MonoidHom.mem_ker","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nM : Type u_7\ninst✝ : MulOneClass M\nf : MonoidHom G M\nx : G\n⊢ Iff (Membership.mem f.ker x) (Eq (f x) 1)","decl":"@[to_additive (attr := simp)]\ntheorem mem_ker {f : G →* M} {x : G} : x ∈ f.ker ↔ f x = 1 :=\n  Iff.rfl\n\n"}
{"name":"AddMonoidHom.sub_mem_ker_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nx y : G\n⊢ Iff (Membership.mem f.ker (HSub.hSub x y)) (Eq (f x) (f y))","decl":"@[to_additive]\ntheorem div_mem_ker_iff (f : G →* N) {x y : G} : x / y ∈ ker f ↔ f x = f y := by\n  rw [mem_ker, map_div, div_eq_one]\n\n"}
{"name":"MonoidHom.div_mem_ker_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nx y : G\n⊢ Iff (Membership.mem f.ker (HDiv.hDiv x y)) (Eq (f x) (f y))","decl":"@[to_additive]\ntheorem div_mem_ker_iff (f : G →* N) {x y : G} : x / y ∈ ker f ↔ f x = f y := by\n  rw [mem_ker, map_div, div_eq_one]\n\n"}
{"name":"MonoidHom.coe_ker","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nM : Type u_7\ninst✝ : MulOneClass M\nf : MonoidHom G M\n⊢ Eq (↑f.ker) (Set.preimage (⇑f) (Singleton.singleton 1))","decl":"@[to_additive]\ntheorem coe_ker (f : G →* M) : (f.ker : Set G) = (f : G → M) ⁻¹' {1} :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_ker","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nM : Type u_7\ninst✝ : AddZeroClass M\nf : AddMonoidHom G M\n⊢ Eq (↑f.ker) (Set.preimage (⇑f) (Singleton.singleton 0))","decl":"@[to_additive]\ntheorem coe_ker (f : G →* M) : (f.ker : Set G) = (f : G → M) ⁻¹' {1} :=\n  rfl\n\n"}
{"name":"AddMonoidHom.ker_toHomAddUnits","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nM : Type u_8\ninst✝ : AddMonoid M\nf : AddMonoidHom G M\n⊢ Eq f.toHomAddUnits.ker f.ker","decl":"@[to_additive (attr := simp)]\ntheorem ker_toHomUnits {M} [Monoid M] (f : G →* M) : f.toHomUnits.ker = f.ker := by\n  ext x\n  simp [mem_ker, Units.ext_iff]\n\n"}
{"name":"MonoidHom.ker_toHomUnits","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nM : Type u_8\ninst✝ : Monoid M\nf : MonoidHom G M\n⊢ Eq f.toHomUnits.ker f.ker","decl":"@[to_additive (attr := simp)]\ntheorem ker_toHomUnits {M} [Monoid M] (f : G →* M) : f.toHomUnits.ker = f.ker := by\n  ext x\n  simp [mem_ker, Units.ext_iff]\n\n"}
{"name":"MonoidHom.eq_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nM : Type u_7\ninst✝ : MulOneClass M\nf : MonoidHom G M\nx y : G\n⊢ Iff (Eq (f x) (f y)) (Membership.mem f.ker (HMul.hMul (Inv.inv y) x))","decl":"@[to_additive]\ntheorem eq_iff (f : G →* M) {x y : G} : f x = f y ↔ y⁻¹ * x ∈ f.ker := by\n  constructor <;> intro h\n  · rw [mem_ker, map_mul, h, ← map_mul, inv_mul_cancel, map_one]\n  · rw [← one_mul x, ← mul_inv_cancel y, mul_assoc, map_mul, mem_ker.1 h, mul_one]\n\n"}
{"name":"AddMonoidHom.eq_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nM : Type u_7\ninst✝ : AddZeroClass M\nf : AddMonoidHom G M\nx y : G\n⊢ Iff (Eq (f x) (f y)) (Membership.mem f.ker (HAdd.hAdd (Neg.neg y) x))","decl":"@[to_additive]\ntheorem eq_iff (f : G →* M) {x y : G} : f x = f y ↔ y⁻¹ * x ∈ f.ker := by\n  constructor <;> intro h\n  · rw [mem_ker, map_mul, h, ← map_mul, inv_mul_cancel, map_one]\n  · rw [← one_mul x, ← mul_inv_cancel y, mul_assoc, map_mul, mem_ker.1 h, mul_one]\n\n"}
{"name":"MonoidHom.comap_ker","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝² : Group G\nN : Type u_5\nP : Type u_6\ninst✝¹ : Group N\ninst✝ : Group P\ng : MonoidHom N P\nf : MonoidHom G N\n⊢ Eq (Subgroup.comap f g.ker) (g.comp f).ker","decl":"@[to_additive]\ntheorem comap_ker (g : N →* P) (f : G →* N) : g.ker.comap f = (g.comp f).ker :=\n  rfl\n\n"}
{"name":"AddMonoidHom.comap_ker","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nN : Type u_5\nP : Type u_6\ninst✝¹ : AddGroup N\ninst✝ : AddGroup P\ng : AddMonoidHom N P\nf : AddMonoidHom G N\n⊢ Eq (AddSubgroup.comap f g.ker) (g.comp f).ker","decl":"@[to_additive]\ntheorem comap_ker (g : N →* P) (f : G →* N) : g.ker.comap f = (g.comp f).ker :=\n  rfl\n\n"}
{"name":"AddMonoidHom.comap_bot","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ Eq (AddSubgroup.comap f Bot.bot) f.ker","decl":"@[to_additive (attr := simp)]\ntheorem comap_bot (f : G →* N) : (⊥ : Subgroup N).comap f = f.ker :=\n  rfl\n\n"}
{"name":"MonoidHom.comap_bot","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\n⊢ Eq (Subgroup.comap f Bot.bot) f.ker","decl":"@[to_additive (attr := simp)]\ntheorem comap_bot (f : G →* N) : (⊥ : Subgroup N).comap f = f.ker :=\n  rfl\n\n"}
{"name":"MonoidHom.ker_restrict","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nK : Subgroup G\nf : MonoidHom G N\n⊢ Eq (f.restrict K).ker (f.ker.subgroupOf K)","decl":"@[to_additive (attr := simp)]\ntheorem ker_restrict (f : G →* N) : (f.restrict K).ker = f.ker.subgroupOf K :=\n  rfl\n\n"}
{"name":"AddMonoidHom.ker_restrict","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nK : AddSubgroup G\nf : AddMonoidHom G N\n⊢ Eq (f.restrict K).ker (f.ker.addSubgroupOf K)","decl":"@[to_additive (attr := simp)]\ntheorem ker_restrict (f : G →* N) : (f.restrict K).ker = f.ker.subgroupOf K :=\n  rfl\n\n"}
{"name":"AddMonoidHom.ker_codRestrict","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\nN : Type u_5\ninst✝² : AddGroup N\nS : Type u_8\ninst✝¹ : SetLike S N\ninst✝ : AddSubmonoidClass S N\nf : AddMonoidHom G N\ns : S\nh : ∀ (x : G), Membership.mem s (f x)\n⊢ Eq (f.codRestrict s h).ker f.ker","decl":"@[to_additive (attr := simp)]\ntheorem ker_codRestrict {S} [SetLike S N] [SubmonoidClass S N] (f : G →* N) (s : S)\n    (h : ∀ x, f x ∈ s) : (f.codRestrict s h).ker = f.ker :=\n  SetLike.ext fun _x => Subtype.ext_iff\n\n"}
{"name":"MonoidHom.ker_codRestrict","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝³ : Group G\nN : Type u_5\ninst✝² : Group N\nS : Type u_8\ninst✝¹ : SetLike S N\ninst✝ : SubmonoidClass S N\nf : MonoidHom G N\ns : S\nh : ∀ (x : G), Membership.mem s (f x)\n⊢ Eq (f.codRestrict s h).ker f.ker","decl":"@[to_additive (attr := simp)]\ntheorem ker_codRestrict {S} [SetLike S N] [SubmonoidClass S N] (f : G →* N) (s : S)\n    (h : ∀ x, f x ∈ s) : (f.codRestrict s h).ker = f.ker :=\n  SetLike.ext fun _x => Subtype.ext_iff\n\n"}
{"name":"MonoidHom.ker_rangeRestrict","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\n⊢ Eq f.rangeRestrict.ker f.ker","decl":"@[to_additive (attr := simp)]\ntheorem ker_rangeRestrict (f : G →* N) : ker (rangeRestrict f) = ker f :=\n  ker_codRestrict _ _ _\n\n"}
{"name":"AddMonoidHom.ker_rangeRestrict","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ Eq f.rangeRestrict.ker f.ker","decl":"@[to_additive (attr := simp)]\ntheorem ker_rangeRestrict (f : G →* N) : ker (rangeRestrict f) = ker f :=\n  ker_codRestrict _ _ _\n\n"}
{"name":"AddMonoidHom.ker_zero","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nM : Type u_7\ninst✝ : AddZeroClass M\n⊢ Eq (AddMonoidHom.ker 0) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem ker_one : (1 : G →* M).ker = ⊤ :=\n  SetLike.ext fun _x => eq_self_iff_true _\n\n"}
{"name":"MonoidHom.ker_one","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nM : Type u_7\ninst✝ : MulOneClass M\n⊢ Eq (MonoidHom.ker 1) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem ker_one : (1 : G →* M).ker = ⊤ :=\n  SetLike.ext fun _x => eq_self_iff_true _\n\n"}
{"name":"MonoidHom.ker_id","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (MonoidHom.id G).ker Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem ker_id : (MonoidHom.id G).ker = ⊥ :=\n  rfl\n\n"}
{"name":"AddMonoidHom.ker_id","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Eq (AddMonoidHom.id G).ker Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem ker_id : (MonoidHom.id G).ker = ⊥ :=\n  rfl\n\n"}
{"name":"MonoidHom.ker_eq_bot_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nM : Type u_7\ninst✝ : MulOneClass M\nf : MonoidHom G M\n⊢ Iff (Eq f.ker Bot.bot) (Function.Injective ⇑f)","decl":"@[to_additive]\ntheorem ker_eq_bot_iff (f : G →* M) : f.ker = ⊥ ↔ Function.Injective f :=\n  ⟨fun h x y hxy => by rwa [eq_iff, h, mem_bot, inv_mul_eq_one, eq_comm] at hxy, fun h =>\n    bot_unique fun _ hx => h (hx.trans f.map_one.symm)⟩\n\n"}
{"name":"AddMonoidHom.ker_eq_bot_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nM : Type u_7\ninst✝ : AddZeroClass M\nf : AddMonoidHom G M\n⊢ Iff (Eq f.ker Bot.bot) (Function.Injective ⇑f)","decl":"@[to_additive]\ntheorem ker_eq_bot_iff (f : G →* M) : f.ker = ⊥ ↔ Function.Injective f :=\n  ⟨fun h x y hxy => by rwa [eq_iff, h, mem_bot, inv_mul_eq_one, eq_comm] at hxy, fun h =>\n    bot_unique fun _ hx => h (hx.trans f.map_one.symm)⟩\n\n"}
{"name":"AddSubgroup.ker_subtype","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq H.subtype.ker Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem _root_.Subgroup.ker_subtype (H : Subgroup G) : H.subtype.ker = ⊥ :=\n  H.subtype.ker_eq_bot_iff.mpr Subtype.coe_injective\n\n"}
{"name":"Subgroup.ker_subtype","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq H.subtype.ker Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem _root_.Subgroup.ker_subtype (H : Subgroup G) : H.subtype.ker = ⊥ :=\n  H.subtype.ker_eq_bot_iff.mpr Subtype.coe_injective\n\n"}
{"name":"Subgroup.ker_inclusion","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : LE.le H K\n⊢ Eq (Subgroup.inclusion h).ker Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem _root_.Subgroup.ker_inclusion {H K : Subgroup G} (h : H ≤ K) : (inclusion h).ker = ⊥ :=\n  (inclusion h).ker_eq_bot_iff.mpr (Set.inclusion_injective h)\n\n"}
{"name":"AddSubgroup.ker_inclusion","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : LE.le H K\n⊢ Eq (AddSubgroup.inclusion h).ker Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem _root_.Subgroup.ker_inclusion {H K : Subgroup G} (h : H ≤ K) : (inclusion h).ker = ⊥ :=\n  (inclusion h).ker_eq_bot_iff.mpr (Set.inclusion_injective h)\n\n"}
{"name":"MonoidHom.ker_prod","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝² : Group G\nM : Type u_8\nN : Type u_9\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom G M\ng : MonoidHom G N\n⊢ Eq (f.prod g).ker (Min.min f.ker g.ker)","decl":"@[to_additive]\ntheorem ker_prod {M N : Type*} [MulOneClass M] [MulOneClass N] (f : G →* M) (g : G →* N) :\n    (f.prod g).ker = f.ker ⊓ g.ker :=\n  SetLike.ext fun _ => Prod.mk_eq_one\n\n"}
{"name":"AddMonoidHom.ker_sum","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nM : Type u_8\nN : Type u_9\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom G M\ng : AddMonoidHom G N\n⊢ Eq (f.prod g).ker (Min.min f.ker g.ker)","decl":"@[to_additive]\ntheorem ker_prod {M N : Type*} [MulOneClass M] [MulOneClass N] (f : G →* M) (g : G →* N) :\n    (f.prod g).ker = f.ker ⊓ g.ker :=\n  SetLike.ext fun _ => Prod.mk_eq_one\n\n"}
{"name":"AddMonoidHom.range_le_ker_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddGroup G'\ninst✝ : AddGroup G''\nf : AddMonoidHom G G'\ng : AddMonoidHom G' G''\n⊢ Iff (LE.le f.range g.ker) (Eq (g.comp f) 0)","decl":"@[to_additive]\ntheorem range_le_ker_iff (f : G →* G') (g : G' →* G'') : f.range ≤ g.ker ↔ g.comp f = 1 :=\n  ⟨fun h => ext fun x => h ⟨x, rfl⟩, by rintro h _ ⟨y, rfl⟩; exact DFunLike.congr_fun h y⟩\n\n"}
{"name":"MonoidHom.range_le_ker_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst✝² : Group G\ninst✝¹ : Group G'\ninst✝ : Group G''\nf : MonoidHom G G'\ng : MonoidHom G' G''\n⊢ Iff (LE.le f.range g.ker) (Eq (g.comp f) 1)","decl":"@[to_additive]\ntheorem range_le_ker_iff (f : G →* G') (g : G' →* G'') : f.range ≤ g.ker ↔ g.comp f = 1 :=\n  ⟨fun h => ext fun x => h ⟨x, rfl⟩, by rintro h _ ⟨y, rfl⟩; exact DFunLike.congr_fun h y⟩\n\n"}
{"name":"AddMonoidHom.normal_ker","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nM : Type u_7\ninst✝ : AddZeroClass M\nf : AddMonoidHom G M\n⊢ f.ker.Normal","decl":"@[to_additive]\ninstance (priority := 100) normal_ker (f : G →* M) : f.ker.Normal :=\n  ⟨fun x hx y => by\n    rw [mem_ker, map_mul, map_mul, mem_ker.1 hx, mul_one, map_mul_eq_one f (mul_inv_cancel y)]⟩\n\n"}
{"name":"MonoidHom.normal_ker","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nM : Type u_7\ninst✝ : MulOneClass M\nf : MonoidHom G M\n⊢ f.ker.Normal","decl":"@[to_additive]\ninstance (priority := 100) normal_ker (f : G →* M) : f.ker.Normal :=\n  ⟨fun x hx y => by\n    rw [mem_ker, map_mul, map_mul, mem_ker.1 hx, mul_one, map_mul_eq_one f (mul_inv_cancel y)]⟩\n\n"}
{"name":"MonoidHom.coe_toAdditive_ker","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nf : MonoidHom G G'\n⊢ Eq (MonoidHom.toAdditive f).ker (Subgroup.toAddSubgroup f.ker)","decl":"@[simp]\ntheorem coe_toAdditive_ker (f : G →* G') :\n    (MonoidHom.toAdditive f).ker = Subgroup.toAddSubgroup f.ker := rfl\n\n"}
{"name":"MonoidHom.coe_toMultiplicative_ker","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"A : Type u_8\nA' : Type u_9\ninst✝¹ : AddGroup A\ninst✝ : AddGroup A'\nf : AddMonoidHom A A'\n⊢ Eq (AddMonoidHom.toMultiplicative f).ker (AddSubgroup.toSubgroup f.ker)","decl":"@[simp]\ntheorem coe_toMultiplicative_ker {A A' : Type*} [AddGroup A] [AddGroup A'] (f : A →+ A') :\n    (AddMonoidHom.toMultiplicative f).ker = AddSubgroup.toSubgroup f.ker := rfl\n\n"}
{"name":"MonoidHom.eqLocus_same","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\n⊢ Eq (f.eqLocus f) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem eqLocus_same (f : G →* N) : f.eqLocus f = ⊤ :=\n  SetLike.ext fun _ => eq_self_iff_true _\n\n"}
{"name":"AddMonoidHom.eqLocus_same","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ Eq (f.eqLocus f) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem eqLocus_same (f : G →* N) : f.eqLocus f = ⊤ :=\n  SetLike.ext fun _ => eq_self_iff_true _\n\n"}
{"name":"MonoidHom.eqOn_closure","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nM : Type u_7\ninst✝ : Monoid M\nf g : MonoidHom G M\ns : Set G\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Set.EqOn ⇑f ⇑g ↑(Subgroup.closure s)","decl":"/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\n@[to_additive\n      \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup\n      closure.\"]\ntheorem eqOn_closure {f g : G →* M} {s : Set G} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eqLocus g from (closure_le _).2 h\n\n"}
{"name":"AddMonoidHom.eqOn_closure","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nM : Type u_7\ninst✝ : AddMonoid M\nf g : AddMonoidHom G M\ns : Set G\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Set.EqOn ⇑f ⇑g ↑(AddSubgroup.closure s)","decl":"/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\n@[to_additive\n      \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup\n      closure.\"]\ntheorem eqOn_closure {f g : G →* M} {s : Set G} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eqLocus g from (closure_le _).2 h\n\n"}
{"name":"MonoidHom.eq_of_eqOn_top","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nM : Type u_7\ninst✝ : Monoid M\nf g : MonoidHom G M\nh : Set.EqOn ⇑f ⇑g ↑Top.top\n⊢ Eq f g","decl":"@[to_additive]\ntheorem eq_of_eqOn_top {f g : G →* M} (h : Set.EqOn f g (⊤ : Subgroup G)) : f = g :=\n  ext fun _x => h trivial\n\n"}
{"name":"AddMonoidHom.eq_of_eqOn_top","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nM : Type u_7\ninst✝ : AddMonoid M\nf g : AddMonoidHom G M\nh : Set.EqOn ⇑f ⇑g ↑Top.top\n⊢ Eq f g","decl":"@[to_additive]\ntheorem eq_of_eqOn_top {f g : G →* M} (h : Set.EqOn f g (⊤ : Subgroup G)) : f = g :=\n  ext fun _x => h trivial\n\n"}
{"name":"AddMonoidHom.eq_of_eqOn_dense","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nM : Type u_7\ninst✝ : AddMonoid M\ns : Set G\nhs : Eq (AddSubgroup.closure s) Top.top\nf g : AddMonoidHom G M\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Eq f g","decl":"@[to_additive]\ntheorem eq_of_eqOn_dense {s : Set G} (hs : closure s = ⊤) {f g : G →* M} (h : s.EqOn f g) : f = g :=\n  eq_of_eqOn_top <| hs ▸ eqOn_closure h\n\n"}
{"name":"MonoidHom.eq_of_eqOn_dense","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nM : Type u_7\ninst✝ : Monoid M\ns : Set G\nhs : Eq (Subgroup.closure s) Top.top\nf g : MonoidHom G M\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Eq f g","decl":"@[to_additive]\ntheorem eq_of_eqOn_dense {s : Set G} (hs : closure s = ⊤) {f g : G →* M} (h : s.EqOn f g) : f = g :=\n  eq_of_eqOn_top <| hs ▸ eqOn_closure h\n\n"}
{"name":"Subgroup.map_eq_bot_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nf : MonoidHom G N\n⊢ Iff (Eq (Subgroup.map f H) Bot.bot) (LE.le H f.ker)","decl":"@[to_additive]\ntheorem map_eq_bot_iff {f : G →* N} : H.map f = ⊥ ↔ H ≤ f.ker :=\n  (gc_map_comap f).l_eq_bot\n\n"}
{"name":"AddSubgroup.map_eq_bot_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nf : AddMonoidHom G N\n⊢ Iff (Eq (AddSubgroup.map f H) Bot.bot) (LE.le H f.ker)","decl":"@[to_additive]\ntheorem map_eq_bot_iff {f : G →* N} : H.map f = ⊥ ↔ H ≤ f.ker :=\n  (gc_map_comap f).l_eq_bot\n\n"}
{"name":"Subgroup.map_eq_bot_iff_of_injective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nf : MonoidHom G N\nhf : Function.Injective ⇑f\n⊢ Iff (Eq (Subgroup.map f H) Bot.bot) (Eq H Bot.bot)","decl":"@[to_additive]\ntheorem map_eq_bot_iff_of_injective {f : G →* N} (hf : Function.Injective f) :\n    H.map f = ⊥ ↔ H = ⊥ := by rw [map_eq_bot_iff, f.ker_eq_bot_iff.mpr hf, le_bot_iff]\n\n"}
{"name":"AddSubgroup.map_eq_bot_iff_of_injective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nf : AddMonoidHom G N\nhf : Function.Injective ⇑f\n⊢ Iff (Eq (AddSubgroup.map f H) Bot.bot) (Eq H Bot.bot)","decl":"@[to_additive]\ntheorem map_eq_bot_iff_of_injective {f : G →* N} (hf : Function.Injective f) :\n    H.map f = ⊥ ↔ H = ⊥ := by rw [map_eq_bot_iff, f.ker_eq_bot_iff.mpr hf, le_bot_iff]\n\n"}
{"name":"Subgroup.map_le_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH : Subgroup G\n⊢ LE.le (Subgroup.map f H) f.range","decl":"@[to_additive]\ntheorem map_le_range (H : Subgroup G) : map f H ≤ f.range :=\n  (range_eq_map f).symm ▸ map_mono le_top\n\n"}
{"name":"AddSubgroup.map_le_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH : AddSubgroup G\n⊢ LE.le (AddSubgroup.map f H) f.range","decl":"@[to_additive]\ntheorem map_le_range (H : Subgroup G) : map f H ≤ f.range :=\n  (range_eq_map f).symm ▸ map_mono le_top\n\n"}
{"name":"AddSubgroup.map_subtype_le","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nK : AddSubgroup (Subtype fun x => Membership.mem H x)\n⊢ LE.le (AddSubgroup.map H.subtype K) H","decl":"@[to_additive]\ntheorem map_subtype_le {H : Subgroup G} (K : Subgroup H) : K.map H.subtype ≤ H :=\n  (K.map_le_range H.subtype).trans_eq H.range_subtype\n\n"}
{"name":"Subgroup.map_subtype_le","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nK : Subgroup (Subtype fun x => Membership.mem H x)\n⊢ LE.le (Subgroup.map H.subtype K) H","decl":"@[to_additive]\ntheorem map_subtype_le {H : Subgroup G} (K : Subgroup H) : K.map H.subtype ≤ H :=\n  (K.map_le_range H.subtype).trans_eq H.range_subtype\n\n"}
{"name":"AddSubgroup.ker_le_comap","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH : AddSubgroup N\n⊢ LE.le f.ker (AddSubgroup.comap f H)","decl":"@[to_additive]\ntheorem ker_le_comap (H : Subgroup N) : f.ker ≤ comap f H :=\n  comap_bot f ▸ comap_mono bot_le\n\n"}
{"name":"Subgroup.ker_le_comap","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH : Subgroup N\n⊢ LE.le f.ker (Subgroup.comap f H)","decl":"@[to_additive]\ntheorem ker_le_comap (H : Subgroup N) : f.ker ≤ comap f H :=\n  comap_bot f ▸ comap_mono bot_le\n\n"}
{"name":"AddSubgroup.map_comap_eq","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH : AddSubgroup N\n⊢ Eq (AddSubgroup.map f (AddSubgroup.comap f H)) (Min.min f.range H)","decl":"@[to_additive]\ntheorem map_comap_eq (H : Subgroup N) : map f (comap f H) = f.range ⊓ H :=\n  SetLike.ext' <| by\n    rw [coe_map, coe_comap, Set.image_preimage_eq_inter_range, coe_inf, coe_range, Set.inter_comm]\n\n"}
{"name":"Subgroup.map_comap_eq","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH : Subgroup N\n⊢ Eq (Subgroup.map f (Subgroup.comap f H)) (Min.min f.range H)","decl":"@[to_additive]\ntheorem map_comap_eq (H : Subgroup N) : map f (comap f H) = f.range ⊓ H :=\n  SetLike.ext' <| by\n    rw [coe_map, coe_comap, Set.image_preimage_eq_inter_range, coe_inf, coe_range, Set.inter_comm]\n\n"}
{"name":"AddSubgroup.comap_map_eq","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH : AddSubgroup G\n⊢ Eq (AddSubgroup.comap f (AddSubgroup.map f H)) (Max.max H f.ker)","decl":"@[to_additive]\ntheorem comap_map_eq (H : Subgroup G) : comap f (map f H) = H ⊔ f.ker := by\n  refine le_antisymm ?_ (sup_le (le_comap_map _ _) (ker_le_comap _ _))\n  intro x hx; simp only [exists_prop, mem_map, mem_comap] at hx\n  rcases hx with ⟨y, hy, hy'⟩\n  rw [← mul_inv_cancel_left y x]\n  exact mul_mem_sup hy (by simp [mem_ker, hy'])\n\n"}
{"name":"Subgroup.comap_map_eq","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH : Subgroup G\n⊢ Eq (Subgroup.comap f (Subgroup.map f H)) (Max.max H f.ker)","decl":"@[to_additive]\ntheorem comap_map_eq (H : Subgroup G) : comap f (map f H) = H ⊔ f.ker := by\n  refine le_antisymm ?_ (sup_le (le_comap_map _ _) (ker_le_comap _ _))\n  intro x hx; simp only [exists_prop, mem_map, mem_comap] at hx\n  rcases hx with ⟨y, hy, hy'⟩\n  rw [← mul_inv_cancel_left y x]\n  exact mul_mem_sup hy (by simp [mem_ker, hy'])\n\n"}
{"name":"AddSubgroup.map_comap_eq_self","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH : AddSubgroup N\nh : LE.le H f.range\n⊢ Eq (AddSubgroup.map f (AddSubgroup.comap f H)) H","decl":"@[to_additive]\ntheorem map_comap_eq_self {f : G →* N} {H : Subgroup N} (h : H ≤ f.range) :\n    map f (comap f H) = H := by\n  rwa [map_comap_eq, inf_eq_right]\n\n"}
{"name":"Subgroup.map_comap_eq_self","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH : Subgroup N\nh : LE.le H f.range\n⊢ Eq (Subgroup.map f (Subgroup.comap f H)) H","decl":"@[to_additive]\ntheorem map_comap_eq_self {f : G →* N} {H : Subgroup N} (h : H ≤ f.range) :\n    map f (comap f H) = H := by\n  rwa [map_comap_eq, inf_eq_right]\n\n"}
{"name":"Subgroup.map_comap_eq_self_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nh : Function.Surjective ⇑f\nH : Subgroup N\n⊢ Eq (Subgroup.map f (Subgroup.comap f H)) H","decl":"@[to_additive]\ntheorem map_comap_eq_self_of_surjective {f : G →* N} (h : Function.Surjective f) (H : Subgroup N) :\n    map f (comap f H) = H :=\n  map_comap_eq_self (range_eq_top.2 h ▸ le_top)\n\n"}
{"name":"AddSubgroup.map_comap_eq_self_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nh : Function.Surjective ⇑f\nH : AddSubgroup N\n⊢ Eq (AddSubgroup.map f (AddSubgroup.comap f H)) H","decl":"@[to_additive]\ntheorem map_comap_eq_self_of_surjective {f : G →* N} (h : Function.Surjective f) (H : Subgroup N) :\n    map f (comap f H) = H :=\n  map_comap_eq_self (range_eq_top.2 h ▸ le_top)\n\n"}
{"name":"Subgroup.comap_le_comap_of_le_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nK L : Subgroup N\nhf : LE.le K f.range\n⊢ Iff (LE.le (Subgroup.comap f K) (Subgroup.comap f L)) (LE.le K L)","decl":"@[to_additive]\ntheorem comap_le_comap_of_le_range {f : G →* N} {K L : Subgroup N} (hf : K ≤ f.range) :\n    K.comap f ≤ L.comap f ↔ K ≤ L :=\n  ⟨(map_comap_eq_self hf).ge.trans ∘ map_le_iff_le_comap.mpr, comap_mono⟩\n\n"}
{"name":"AddSubgroup.comap_le_comap_of_le_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nK L : AddSubgroup N\nhf : LE.le K f.range\n⊢ Iff (LE.le (AddSubgroup.comap f K) (AddSubgroup.comap f L)) (LE.le K L)","decl":"@[to_additive]\ntheorem comap_le_comap_of_le_range {f : G →* N} {K L : Subgroup N} (hf : K ≤ f.range) :\n    K.comap f ≤ L.comap f ↔ K ≤ L :=\n  ⟨(map_comap_eq_self hf).ge.trans ∘ map_le_iff_le_comap.mpr, comap_mono⟩\n\n"}
{"name":"Subgroup.comap_le_comap_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nK L : Subgroup N\nhf : Function.Surjective ⇑f\n⊢ Iff (LE.le (Subgroup.comap f K) (Subgroup.comap f L)) (LE.le K L)","decl":"@[to_additive]\ntheorem comap_le_comap_of_surjective {f : G →* N} {K L : Subgroup N} (hf : Function.Surjective f) :\n    K.comap f ≤ L.comap f ↔ K ≤ L :=\n  comap_le_comap_of_le_range (range_eq_top.2 hf ▸ le_top)\n\n"}
{"name":"AddSubgroup.comap_le_comap_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nK L : AddSubgroup N\nhf : Function.Surjective ⇑f\n⊢ Iff (LE.le (AddSubgroup.comap f K) (AddSubgroup.comap f L)) (LE.le K L)","decl":"@[to_additive]\ntheorem comap_le_comap_of_surjective {f : G →* N} {K L : Subgroup N} (hf : Function.Surjective f) :\n    K.comap f ≤ L.comap f ↔ K ≤ L :=\n  comap_le_comap_of_le_range (range_eq_top.2 hf ▸ le_top)\n\n"}
{"name":"AddSubgroup.comap_lt_comap_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nK L : AddSubgroup N\nhf : Function.Surjective ⇑f\n⊢ Iff (LT.lt (AddSubgroup.comap f K) (AddSubgroup.comap f L)) (LT.lt K L)","decl":"@[to_additive]\ntheorem comap_lt_comap_of_surjective {f : G →* N} {K L : Subgroup N} (hf : Function.Surjective f) :\n    K.comap f < L.comap f ↔ K < L := by simp_rw [lt_iff_le_not_le, comap_le_comap_of_surjective hf]\n\n"}
{"name":"Subgroup.comap_lt_comap_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nK L : Subgroup N\nhf : Function.Surjective ⇑f\n⊢ Iff (LT.lt (Subgroup.comap f K) (Subgroup.comap f L)) (LT.lt K L)","decl":"@[to_additive]\ntheorem comap_lt_comap_of_surjective {f : G →* N} {K L : Subgroup N} (hf : Function.Surjective f) :\n    K.comap f < L.comap f ↔ K < L := by simp_rw [lt_iff_le_not_le, comap_le_comap_of_surjective hf]\n\n"}
{"name":"Subgroup.comap_injective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nh : Function.Surjective ⇑f\n⊢ Function.Injective (Subgroup.comap f)","decl":"@[to_additive]\ntheorem comap_injective {f : G →* N} (h : Function.Surjective f) : Function.Injective (comap f) :=\n  fun K L => by simp only [le_antisymm_iff, comap_le_comap_of_surjective h, imp_self]\n\n"}
{"name":"AddSubgroup.comap_injective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nh : Function.Surjective ⇑f\n⊢ Function.Injective (AddSubgroup.comap f)","decl":"@[to_additive]\ntheorem comap_injective {f : G →* N} (h : Function.Surjective f) : Function.Injective (comap f) :=\n  fun K L => by simp only [le_antisymm_iff, comap_le_comap_of_surjective h, imp_self]\n\n"}
{"name":"Subgroup.comap_map_eq_self","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH : Subgroup G\nh : LE.le f.ker H\n⊢ Eq (Subgroup.comap f (Subgroup.map f H)) H","decl":"@[to_additive]\ntheorem comap_map_eq_self {f : G →* N} {H : Subgroup G} (h : f.ker ≤ H) :\n    comap f (map f H) = H := by\n  rwa [comap_map_eq, sup_eq_left]\n\n"}
{"name":"AddSubgroup.comap_map_eq_self","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH : AddSubgroup G\nh : LE.le f.ker H\n⊢ Eq (AddSubgroup.comap f (AddSubgroup.map f H)) H","decl":"@[to_additive]\ntheorem comap_map_eq_self {f : G →* N} {H : Subgroup G} (h : f.ker ≤ H) :\n    comap f (map f H) = H := by\n  rwa [comap_map_eq, sup_eq_left]\n\n"}
{"name":"Subgroup.comap_map_eq_self_of_injective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nh : Function.Injective ⇑f\nH : Subgroup G\n⊢ Eq (Subgroup.comap f (Subgroup.map f H)) H","decl":"@[to_additive]\ntheorem comap_map_eq_self_of_injective {f : G →* N} (h : Function.Injective f) (H : Subgroup G) :\n    comap f (map f H) = H :=\n  comap_map_eq_self (((ker_eq_bot_iff _).mpr h).symm ▸ bot_le)\n\n"}
{"name":"AddSubgroup.comap_map_eq_self_of_injective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nh : Function.Injective ⇑f\nH : AddSubgroup G\n⊢ Eq (AddSubgroup.comap f (AddSubgroup.map f H)) H","decl":"@[to_additive]\ntheorem comap_map_eq_self_of_injective {f : G →* N} (h : Function.Injective f) (H : Subgroup G) :\n    comap f (map f H) = H :=\n  comap_map_eq_self (((ker_eq_bot_iff _).mpr h).symm ▸ bot_le)\n\n"}
{"name":"Subgroup.map_le_map_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH K : Subgroup G\n⊢ Iff (LE.le (Subgroup.map f H) (Subgroup.map f K)) (LE.le H (Max.max K f.ker))","decl":"@[to_additive]\ntheorem map_le_map_iff {f : G →* N} {H K : Subgroup G} : H.map f ≤ K.map f ↔ H ≤ K ⊔ f.ker := by\n  rw [map_le_iff_le_comap, comap_map_eq]\n\n"}
{"name":"AddSubgroup.map_le_map_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH K : AddSubgroup G\n⊢ Iff (LE.le (AddSubgroup.map f H) (AddSubgroup.map f K)) (LE.le H (Max.max K f.ker))","decl":"@[to_additive]\ntheorem map_le_map_iff {f : G →* N} {H K : Subgroup G} : H.map f ≤ K.map f ↔ H ≤ K ⊔ f.ker := by\n  rw [map_le_iff_le_comap, comap_map_eq]\n\n"}
{"name":"AddSubgroup.map_le_map_iff'","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH K : AddSubgroup G\n⊢ Iff (LE.le (AddSubgroup.map f H) (AddSubgroup.map f K)) (LE.le (Max.max H f.ker) (Max.max K f.ker))","decl":"@[to_additive]\ntheorem map_le_map_iff' {f : G →* N} {H K : Subgroup G} :\n    H.map f ≤ K.map f ↔ H ⊔ f.ker ≤ K ⊔ f.ker := by\n  simp only [map_le_map_iff, sup_le_iff, le_sup_right, and_true]\n\n"}
{"name":"Subgroup.map_le_map_iff'","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH K : Subgroup G\n⊢ Iff (LE.le (Subgroup.map f H) (Subgroup.map f K)) (LE.le (Max.max H f.ker) (Max.max K f.ker))","decl":"@[to_additive]\ntheorem map_le_map_iff' {f : G →* N} {H K : Subgroup G} :\n    H.map f ≤ K.map f ↔ H ⊔ f.ker ≤ K ⊔ f.ker := by\n  simp only [map_le_map_iff, sup_le_iff, le_sup_right, and_true]\n\n"}
{"name":"Subgroup.map_eq_map_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH K : Subgroup G\n⊢ Iff (Eq (Subgroup.map f H) (Subgroup.map f K)) (Eq (Max.max H f.ker) (Max.max K f.ker))","decl":"@[to_additive]\ntheorem map_eq_map_iff {f : G →* N} {H K : Subgroup G} :\n    H.map f = K.map f ↔ H ⊔ f.ker = K ⊔ f.ker := by simp only [le_antisymm_iff, map_le_map_iff']\n\n"}
{"name":"AddSubgroup.map_eq_map_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH K : AddSubgroup G\n⊢ Iff (Eq (AddSubgroup.map f H) (AddSubgroup.map f K)) (Eq (Max.max H f.ker) (Max.max K f.ker))","decl":"@[to_additive]\ntheorem map_eq_map_iff {f : G →* N} {H K : Subgroup G} :\n    H.map f = K.map f ↔ H ⊔ f.ker = K ⊔ f.ker := by simp only [le_antisymm_iff, map_le_map_iff']\n\n"}
{"name":"AddSubgroup.map_eq_range_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH : AddSubgroup G\n⊢ Iff (Eq (AddSubgroup.map f H) f.range) (Codisjoint H f.ker)","decl":"@[to_additive]\ntheorem map_eq_range_iff {f : G →* N} {H : Subgroup G} :\n    H.map f = f.range ↔ Codisjoint H f.ker := by\n  rw [f.range_eq_map, map_eq_map_iff, codisjoint_iff, top_sup_eq]\n\n"}
{"name":"Subgroup.map_eq_range_iff","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH : Subgroup G\n⊢ Iff (Eq (Subgroup.map f H) f.range) (Codisjoint H f.ker)","decl":"@[to_additive]\ntheorem map_eq_range_iff {f : G →* N} {H : Subgroup G} :\n    H.map f = f.range ↔ Codisjoint H f.ker := by\n  rw [f.range_eq_map, map_eq_map_iff, codisjoint_iff, top_sup_eq]\n\n"}
{"name":"AddSubgroup.map_le_map_iff_of_injective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nhf : Function.Injective ⇑f\nH K : AddSubgroup G\n⊢ Iff (LE.le (AddSubgroup.map f H) (AddSubgroup.map f K)) (LE.le H K)","decl":"@[to_additive]\ntheorem map_le_map_iff_of_injective {f : G →* N} (hf : Function.Injective f) {H K : Subgroup G} :\n    H.map f ≤ K.map f ↔ H ≤ K := by rw [map_le_iff_le_comap, comap_map_eq_self_of_injective hf]\n\n"}
{"name":"Subgroup.map_le_map_iff_of_injective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nhf : Function.Injective ⇑f\nH K : Subgroup G\n⊢ Iff (LE.le (Subgroup.map f H) (Subgroup.map f K)) (LE.le H K)","decl":"@[to_additive]\ntheorem map_le_map_iff_of_injective {f : G →* N} (hf : Function.Injective f) {H K : Subgroup G} :\n    H.map f ≤ K.map f ↔ H ≤ K := by rw [map_le_iff_le_comap, comap_map_eq_self_of_injective hf]\n\n"}
{"name":"Subgroup.map_subtype_le_map_subtype","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : Group G\nG' : Subgroup G\nH K : Subgroup (Subtype fun x => Membership.mem G' x)\n⊢ Iff (LE.le (Subgroup.map G'.subtype H) (Subgroup.map G'.subtype K)) (LE.le H K)","decl":"@[to_additive (attr := simp)]\ntheorem map_subtype_le_map_subtype {G' : Subgroup G} {H K : Subgroup G'} :\n    H.map G'.subtype ≤ K.map G'.subtype ↔ H ≤ K :=\n  map_le_map_iff_of_injective G'.subtype_injective\n\n"}
{"name":"AddSubgroup.map_subtype_le_map_subtype","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nG' : AddSubgroup G\nH K : AddSubgroup (Subtype fun x => Membership.mem G' x)\n⊢ Iff (LE.le (AddSubgroup.map G'.subtype H) (AddSubgroup.map G'.subtype K)) (LE.le H K)","decl":"@[to_additive (attr := simp)]\ntheorem map_subtype_le_map_subtype {G' : Subgroup G} {H K : Subgroup G'} :\n    H.map G'.subtype ≤ K.map G'.subtype ↔ H ≤ K :=\n  map_le_map_iff_of_injective G'.subtype_injective\n\n"}
{"name":"Subgroup.map_lt_map_iff_of_injective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nhf : Function.Injective ⇑f\nH K : Subgroup G\n⊢ Iff (LT.lt (Subgroup.map f H) (Subgroup.map f K)) (LT.lt H K)","decl":"@[to_additive]\ntheorem map_lt_map_iff_of_injective {f : G →* N} (hf : Function.Injective f) {H K : Subgroup G} :\n    H.map f < K.map f ↔ H < K :=\n  lt_iff_lt_of_le_iff_le' (map_le_map_iff_of_injective hf) (map_le_map_iff_of_injective hf)\n\n"}
{"name":"AddSubgroup.map_lt_map_iff_of_injective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nhf : Function.Injective ⇑f\nH K : AddSubgroup G\n⊢ Iff (LT.lt (AddSubgroup.map f H) (AddSubgroup.map f K)) (LT.lt H K)","decl":"@[to_additive]\ntheorem map_lt_map_iff_of_injective {f : G →* N} (hf : Function.Injective f) {H K : Subgroup G} :\n    H.map f < K.map f ↔ H < K :=\n  lt_iff_lt_of_le_iff_le' (map_le_map_iff_of_injective hf) (map_le_map_iff_of_injective hf)\n\n"}
{"name":"Subgroup.map_subtype_lt_map_subtype","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : Group G\nG' : Subgroup G\nH K : Subgroup (Subtype fun x => Membership.mem G' x)\n⊢ Iff (LT.lt (Subgroup.map G'.subtype H) (Subgroup.map G'.subtype K)) (LT.lt H K)","decl":"@[to_additive (attr := simp)]\ntheorem map_subtype_lt_map_subtype {G' : Subgroup G} {H K : Subgroup G'} :\n    H.map G'.subtype < K.map G'.subtype ↔ H < K :=\n  map_lt_map_iff_of_injective G'.subtype_injective\n\n"}
{"name":"AddSubgroup.map_subtype_lt_map_subtype","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nG' : AddSubgroup G\nH K : AddSubgroup (Subtype fun x => Membership.mem G' x)\n⊢ Iff (LT.lt (AddSubgroup.map G'.subtype H) (AddSubgroup.map G'.subtype K)) (LT.lt H K)","decl":"@[to_additive (attr := simp)]\ntheorem map_subtype_lt_map_subtype {G' : Subgroup G} {H K : Subgroup G'} :\n    H.map G'.subtype < K.map G'.subtype ↔ H < K :=\n  map_lt_map_iff_of_injective G'.subtype_injective\n\n"}
{"name":"Subgroup.map_injective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nh : Function.Injective ⇑f\n⊢ Function.Injective (Subgroup.map f)","decl":"@[to_additive]\ntheorem map_injective {f : G →* N} (h : Function.Injective f) : Function.Injective (map f) :=\n  Function.LeftInverse.injective <| comap_map_eq_self_of_injective h\n\n"}
{"name":"AddSubgroup.map_injective","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nh : Function.Injective ⇑f\n⊢ Function.Injective (AddSubgroup.map f)","decl":"@[to_additive]\ntheorem map_injective {f : G →* N} (h : Function.Injective f) : Function.Injective (map f) :=\n  Function.LeftInverse.injective <| comap_map_eq_self_of_injective h\n\n"}
{"name":"AddSubgroup.map_injective_of_ker_le","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH K : AddSubgroup G\nhH : LE.le f.ker H\nhK : LE.le f.ker K\nhf : Eq (AddSubgroup.map f H) (AddSubgroup.map f K)\n⊢ Eq H K","decl":"/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\n@[to_additive \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`.\"]\ntheorem map_injective_of_ker_le {H K : Subgroup G} (hH : f.ker ≤ H) (hK : f.ker ≤ K)\n    (hf : map f H = map f K) : H = K := by\n  apply_fun comap f at hf\n  rwa [comap_map_eq, comap_map_eq, sup_of_le_left hH, sup_of_le_left hK] at hf\n\n"}
{"name":"Subgroup.map_injective_of_ker_le","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH K : Subgroup G\nhH : LE.le f.ker H\nhK : LE.le f.ker K\nhf : Eq (Subgroup.map f H) (Subgroup.map f K)\n⊢ Eq H K","decl":"/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\n@[to_additive \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`.\"]\ntheorem map_injective_of_ker_le {H K : Subgroup G} (hH : f.ker ≤ H) (hK : f.ker ≤ K)\n    (hf : map f H = map f K) : H = K := by\n  apply_fun comap f at hf\n  rwa [comap_map_eq, comap_map_eq, sup_of_le_left hH, sup_of_le_left hK] at hf\n\n"}
{"name":"Subgroup.ker_subgroupMap","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nf : MonoidHom G N\n⊢ Eq (f.subgroupMap H).ker (f.ker.subgroupOf H)","decl":"@[to_additive]\ntheorem ker_subgroupMap : (f.subgroupMap H).ker = f.ker.subgroupOf H :=\n  ext fun _ ↦ Subtype.ext_iff\n\n"}
{"name":"AddSubgroup.ker_addSubgroupMap","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nf : AddMonoidHom G N\n⊢ Eq (f.addSubgroupMap H).ker (f.ker.addSubgroupOf H)","decl":"@[to_additive]\ntheorem ker_subgroupMap : (f.subgroupMap H).ker = f.ker.subgroupOf H :=\n  ext fun _ ↦ Subtype.ext_iff\n\n"}
{"name":"Subgroup.closure_preimage_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Set G\n⊢ Eq (Subgroup.closure (Set.preimage (⇑(Subgroup.closure s).subtype) s)) Top.top","decl":"@[to_additive]\ntheorem closure_preimage_eq_top (s : Set G) : closure ((closure s).subtype ⁻¹' s) = ⊤ := by\n  apply map_injective (closure s).subtype_injective\n  rw [MonoidHom.map_closure, ← MonoidHom.range_eq_map, range_subtype,\n    Set.image_preimage_eq_of_subset]\n  rw [coeSubtype, Subtype.range_coe_subtype]\n  exact subset_closure\n\n"}
{"name":"AddSubgroup.closure_preimage_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ns : Set G\n⊢ Eq (AddSubgroup.closure (Set.preimage (⇑(AddSubgroup.closure s).subtype) s)) Top.top","decl":"@[to_additive]\ntheorem closure_preimage_eq_top (s : Set G) : closure ((closure s).subtype ⁻¹' s) = ⊤ := by\n  apply map_injective (closure s).subtype_injective\n  rw [MonoidHom.map_closure, ← MonoidHom.range_eq_map, range_subtype,\n    Set.image_preimage_eq_of_subset]\n  rw [coeSubtype, Subtype.range_coe_subtype]\n  exact subset_closure\n\n"}
{"name":"AddSubgroup.comap_sup_eq_of_le_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH K : AddSubgroup N\nhH : LE.le H f.range\nhK : LE.le K f.range\n⊢ Eq (Max.max (AddSubgroup.comap f H) (AddSubgroup.comap f K)) (AddSubgroup.comap f (Max.max H K))","decl":"@[to_additive]\ntheorem comap_sup_eq_of_le_range {H K : Subgroup N} (hH : H ≤ f.range) (hK : K ≤ f.range) :\n    comap f H ⊔ comap f K = comap f (H ⊔ K) :=\n  map_injective_of_ker_le f ((ker_le_comap f H).trans le_sup_left) (ker_le_comap f (H ⊔ K))\n    (by\n      rw [map_comap_eq, map_sup, map_comap_eq, map_comap_eq, inf_eq_right.mpr hH,\n        inf_eq_right.mpr hK, inf_eq_right.mpr (sup_le hH hK)])\n\n"}
{"name":"Subgroup.comap_sup_eq_of_le_range","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH K : Subgroup N\nhH : LE.le H f.range\nhK : LE.le K f.range\n⊢ Eq (Max.max (Subgroup.comap f H) (Subgroup.comap f K)) (Subgroup.comap f (Max.max H K))","decl":"@[to_additive]\ntheorem comap_sup_eq_of_le_range {H K : Subgroup N} (hH : H ≤ f.range) (hK : K ≤ f.range) :\n    comap f H ⊔ comap f K = comap f (H ⊔ K) :=\n  map_injective_of_ker_le f ((ker_le_comap f H).trans le_sup_left) (ker_le_comap f (H ⊔ K))\n    (by\n      rw [map_comap_eq, map_sup, map_comap_eq, map_comap_eq, inf_eq_right.mpr hH,\n        inf_eq_right.mpr hK, inf_eq_right.mpr (sup_le hH hK)])\n\n"}
{"name":"Subgroup.comap_sup_eq","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\nH K : Subgroup N\nhf : Function.Surjective ⇑f\n⊢ Eq (Max.max (Subgroup.comap f H) (Subgroup.comap f K)) (Subgroup.comap f (Max.max H K))","decl":"@[to_additive]\ntheorem comap_sup_eq (H K : Subgroup N) (hf : Function.Surjective f) :\n    comap f H ⊔ comap f K = comap f (H ⊔ K) :=\n  comap_sup_eq_of_le_range f (range_eq_top.2 hf ▸ le_top) (range_eq_top.2 hf ▸ le_top)\n\n"}
{"name":"AddSubgroup.comap_sup_eq","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\nH K : AddSubgroup N\nhf : Function.Surjective ⇑f\n⊢ Eq (Max.max (AddSubgroup.comap f H) (AddSubgroup.comap f K)) (AddSubgroup.comap f (Max.max H K))","decl":"@[to_additive]\ntheorem comap_sup_eq (H K : Subgroup N) (hf : Function.Surjective f) :\n    comap f H ⊔ comap f K = comap f (H ⊔ K) :=\n  comap_sup_eq_of_le_range f (range_eq_top.2 hf ▸ le_top) (range_eq_top.2 hf ▸ le_top)\n\n"}
{"name":"Subgroup.sup_subgroupOf_eq","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K L : Subgroup G\nhH : LE.le H L\nhK : LE.le K L\n⊢ Eq (Max.max (H.subgroupOf L) (K.subgroupOf L)) ((Max.max H K).subgroupOf L)","decl":"@[to_additive]\ntheorem sup_subgroupOf_eq {H K L : Subgroup G} (hH : H ≤ L) (hK : K ≤ L) :\n    H.subgroupOf L ⊔ K.subgroupOf L = (H ⊔ K).subgroupOf L :=\n  comap_sup_eq_of_le_range L.subtype (hH.trans_eq L.range_subtype.symm)\n     (hK.trans_eq L.range_subtype.symm)\n\n"}
{"name":"AddSubgroup.sup_addSubgroupOf_eq","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K L : AddSubgroup G\nhH : LE.le H L\nhK : LE.le K L\n⊢ Eq (Max.max (H.addSubgroupOf L) (K.addSubgroupOf L)) ((Max.max H K).addSubgroupOf L)","decl":"@[to_additive]\ntheorem sup_subgroupOf_eq {H K L : Subgroup G} (hH : H ≤ L) (hK : K ≤ L) :\n    H.subgroupOf L ⊔ K.subgroupOf L = (H ⊔ K).subgroupOf L :=\n  comap_sup_eq_of_le_range L.subtype (hH.trans_eq L.range_subtype.symm)\n     (hK.trans_eq L.range_subtype.symm)\n\n"}
{"name":"AddSubgroup.codisjoint_addSubgroupOf_sup","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Codisjoint (H.addSubgroupOf (Max.max H K)) (K.addSubgroupOf (Max.max H K))","decl":"@[to_additive]\ntheorem codisjoint_subgroupOf_sup (H K : Subgroup G) :\n    Codisjoint (H.subgroupOf (H ⊔ K)) (K.subgroupOf (H ⊔ K)) := by\n  rw [codisjoint_iff, sup_subgroupOf_eq, subgroupOf_self]\n  exacts [le_sup_left, le_sup_right]\n\n"}
{"name":"Subgroup.codisjoint_subgroupOf_sup","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Codisjoint (H.subgroupOf (Max.max H K)) (K.subgroupOf (Max.max H K))","decl":"@[to_additive]\ntheorem codisjoint_subgroupOf_sup (H K : Subgroup G) :\n    Codisjoint (H.subgroupOf (H ⊔ K)) (K.subgroupOf (H ⊔ K)) := by\n  rw [codisjoint_iff, sup_subgroupOf_eq, subgroupOf_self]\n  exacts [le_sup_left, le_sup_right]\n\n"}
{"name":"Subgroup.subgroupOf_sup","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : Group G\nA A' B : Subgroup G\nhA : LE.le A B\nhA' : LE.le A' B\n⊢ Eq ((Max.max A A').subgroupOf B) (Max.max (A.subgroupOf B) (A'.subgroupOf B))","decl":"@[to_additive]\ntheorem subgroupOf_sup (A A' B : Subgroup G) (hA : A ≤ B) (hA' : A' ≤ B) :\n    (A ⊔ A').subgroupOf B = A.subgroupOf B ⊔ A'.subgroupOf B := by\n  refine\n    map_injective_of_ker_le B.subtype (ker_le_comap _ _)\n      (le_trans (ker_le_comap B.subtype _) le_sup_left) ?_\n  simp only [subgroupOf, map_comap_eq, map_sup, range_subtype]\n  rw [inf_of_le_right (sup_le hA hA'), inf_of_le_right hA', inf_of_le_right hA]\n\n"}
{"name":"AddSubgroup.addSubgroupOf_sup","module":"Mathlib.Algebra.Group.Subgroup.Ker","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nA A' B : AddSubgroup G\nhA : LE.le A B\nhA' : LE.le A' B\n⊢ Eq ((Max.max A A').addSubgroupOf B) (Max.max (A.addSubgroupOf B) (A'.addSubgroupOf B))","decl":"@[to_additive]\ntheorem subgroupOf_sup (A A' B : Subgroup G) (hA : A ≤ B) (hA' : A' ≤ B) :\n    (A ⊔ A').subgroupOf B = A.subgroupOf B ⊔ A'.subgroupOf B := by\n  refine\n    map_injective_of_ker_le B.subtype (ker_le_comap _ _)\n      (le_trans (ker_le_comap B.subtype _) le_sup_left) ?_\n  simp only [subgroupOf, map_comap_eq, map_sup, range_subtype]\n  rw [inf_of_le_right (sup_le hA hA'), inf_of_le_right hA', inf_of_le_right hA]\n\n"}
