{"name":"Equiv.id_map","module":"Mathlib.Control.Traversable.Equiv","initialProofState":"t t' : Type u → Type u\neqv : (α : Type u) → Equiv (t α) (t' α)\ninst✝¹ : Functor t\ninst✝ : LawfulFunctor t\nα : Type u\nx : t' α\n⊢ Eq (Equiv.map eqv id x) x","decl":"protected theorem id_map {α : Type u} (x : t' α) : Equiv.map eqv id x = x := by\n  simp [Equiv.map, id_map]\n\n"}
{"name":"Equiv.comp_map","module":"Mathlib.Control.Traversable.Equiv","initialProofState":"t t' : Type u → Type u\neqv : (α : Type u) → Equiv (t α) (t' α)\ninst✝¹ : Functor t\ninst✝ : LawfulFunctor t\nα β γ : Type u\ng : α → β\nh : β → γ\nx : t' α\n⊢ Eq (Equiv.map eqv (Function.comp h g) x) (Equiv.map eqv h (Equiv.map eqv g x))","decl":"protected theorem comp_map {α β γ : Type u} (g : α → β) (h : β → γ) (x : t' α) :\n    Equiv.map eqv (h ∘ g) x = Equiv.map eqv h (Equiv.map eqv g x) := by\n  simp [Equiv.map, Function.comp_def]\n\n"}
{"name":"Equiv.lawfulFunctor","module":"Mathlib.Control.Traversable.Equiv","initialProofState":"t t' : Type u → Type u\neqv : (α : Type u) → Equiv (t α) (t' α)\ninst✝¹ : Functor t\ninst✝ : LawfulFunctor t\n⊢ LawfulFunctor t'","decl":"protected theorem lawfulFunctor : @LawfulFunctor _ (Equiv.functor eqv) :=\n  -- Porting note: why is `_inst` required here?\n  let _inst := Equiv.functor eqv; {\n    map_const := fun {_ _} => rfl\n    id_map := Equiv.id_map eqv\n    comp_map := Equiv.comp_map eqv }\n\n"}
{"name":"Equiv.lawfulFunctor'","module":"Mathlib.Control.Traversable.Equiv","initialProofState":"t t' : Type u → Type u\neqv : (α : Type u) → Equiv (t α) (t' α)\ninst✝¹ : Functor t\ninst✝ : LawfulFunctor t\nF : Functor t'\nh₀ : ∀ {α β : Type u} (f : α → β), Eq (Functor.map f) (Equiv.map eqv f)\nh₁ : ∀ {α β : Type u} (f : β), Eq (Functor.mapConst f) (Function.comp (Equiv.map eqv) (Function.const α) f)\n⊢ LawfulFunctor t'","decl":"protected theorem lawfulFunctor' [F : Functor t']\n    (h₀ : ∀ {α β} (f : α → β), Functor.map f = Equiv.map eqv f)\n    (h₁ : ∀ {α β} (f : β), Functor.mapConst f = (Equiv.map eqv ∘ Function.const α) f) :\n    LawfulFunctor t' := by\n  have : F = Equiv.functor eqv := by\n    cases F\n    dsimp [Equiv.functor]\n    congr <;> ext <;> dsimp only <;> [rw [← h₀]; rw [← h₁]] <;> rfl\n  subst this\n  exact Equiv.lawfulFunctor eqv\n\n"}
{"name":"Equiv.traverse_def","module":"Mathlib.Control.Traversable.Equiv","initialProofState":"t t' : Type u → Type u\neqv : (α : Type u) → Equiv (t α) (t' α)\ninst✝¹ : Traversable t\nm : Type u → Type u\ninst✝ : Applicative m\nα β : Type u\nf : α → m β\nx : t' α\n⊢ Eq (Equiv.traverse eqv f x) (Functor.map (⇑(eqv β)) (Traversable.traverse f ((eqv α).symm x)))","decl":"theorem traverse_def (f : α → m β) (x : t' α) :\n    Equiv.traverse eqv f x = eqv β <$> traverse f ((eqv α).symm x) :=\n  rfl\n\n"}
{"name":"Equiv.id_traverse","module":"Mathlib.Control.Traversable.Equiv","initialProofState":"t t' : Type u → Type u\neqv : (α : Type u) → Equiv (t α) (t' α)\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\nα : Type u\nx : t' α\n⊢ Eq (Equiv.traverse eqv Pure.pure x) x","decl":"protected theorem id_traverse (x : t' α) : Equiv.traverse eqv (pure : α → Id α) x = x := by\n  rw [Equiv.traverse, id_traverse, Id.map_eq, apply_symm_apply]\n\n"}
{"name":"Equiv.traverse_eq_map_id","module":"Mathlib.Control.Traversable.Equiv","initialProofState":"t t' : Type u → Type u\neqv : (α : Type u) → Equiv (t α) (t' α)\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\nα β : Type u\nf : α → β\nx : t' α\n⊢ Eq (Equiv.traverse eqv (Function.comp Pure.pure f) x) (Pure.pure (Equiv.map eqv f x))","decl":"protected theorem traverse_eq_map_id (f : α → β) (x : t' α) :\n    Equiv.traverse eqv ((pure : β → Id β) ∘ f) x = pure (Equiv.map eqv f x) := by\n  simp only [Equiv.traverse, traverse_eq_map_id, Id.map_eq, Id.pure_eq]; rfl\n\n"}
{"name":"Equiv.comp_traverse","module":"Mathlib.Control.Traversable.Equiv","initialProofState":"t t' : Type u → Type u\neqv : (α : Type u) → Equiv (t α) (t' α)\ninst✝⁵ : Traversable t\ninst✝⁴ : LawfulTraversable t\nF G : Type u → Type u\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα β γ : Type u\nf : β → F γ\ng : α → G β\nx : t' α\n⊢ Eq (Equiv.traverse eqv (Function.comp Functor.Comp.mk (Function.comp (Functor.map f) g)) x) (Functor.Comp.mk (Functor.map (Equiv.traverse eqv f) (Equiv.traverse eqv g x)))","decl":"protected theorem comp_traverse (f : β → F γ) (g : α → G β) (x : t' α) :\n    Equiv.traverse eqv (Comp.mk ∘ Functor.map f ∘ g) x =\n      Comp.mk (Equiv.traverse eqv f <$> Equiv.traverse eqv g x) := by\n  rw [traverse_def, comp_traverse, Comp.map_mk]\n  simp only [map_map, Function.comp_def, traverse_def, symm_apply_apply]\n\n"}
{"name":"Equiv.naturality","module":"Mathlib.Control.Traversable.Equiv","initialProofState":"t t' : Type u → Type u\neqv : (α : Type u) → Equiv (t α) (t' α)\ninst✝⁵ : Traversable t\ninst✝⁴ : LawfulTraversable t\nF G : Type u → Type u\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nη : ApplicativeTransformation F G\nα β : Type u\nf : α → F β\nx : t' α\n⊢ Eq ((fun {α} => η.app α) (Equiv.traverse eqv f x)) (Equiv.traverse eqv (Function.comp (fun {α} => η.app α) f) x)","decl":"protected theorem naturality (f : α → F β) (x : t' α) :\n    η (Equiv.traverse eqv f x) = Equiv.traverse eqv (@η _ ∘ f) x := by\n  simp only [Equiv.traverse, functor_norm]\n\n"}
{"name":"Equiv.isLawfulTraversable","module":"Mathlib.Control.Traversable.Equiv","initialProofState":"t t' : Type u → Type u\neqv : (α : Type u) → Equiv (t α) (t' α)\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\n⊢ LawfulTraversable t'","decl":"/-- The fact that `t` is a lawful traversable functor carries over the\nequivalences to `t'`, with the traversable functor structure given by\n`Equiv.traversable`. -/\nprotected theorem isLawfulTraversable : @LawfulTraversable t' (Equiv.traversable eqv) :=\n  -- Porting note: Same `_inst` local variable problem.\n  let _inst := Equiv.traversable eqv; {\n    toLawfulFunctor := Equiv.lawfulFunctor eqv\n    id_traverse := Equiv.id_traverse eqv\n    comp_traverse := Equiv.comp_traverse eqv\n    traverse_eq_map_id := Equiv.traverse_eq_map_id eqv\n    naturality := Equiv.naturality eqv }\n\n"}
{"name":"Equiv.isLawfulTraversable'","module":"Mathlib.Control.Traversable.Equiv","initialProofState":"t t' : Type u → Type u\neqv : (α : Type u) → Equiv (t α) (t' α)\ninst✝² : Traversable t\ninst✝¹ : LawfulTraversable t\ninst✝ : Traversable t'\nh₀ : ∀ {α β : Type u} (f : α → β), Eq (Functor.map f) (Equiv.map eqv f)\nh₁ : ∀ {α β : Type u} (f : β), Eq (Functor.mapConst f) (Function.comp (Equiv.map eqv) (Function.const α) f)\nh₂ : ∀ {F : Type u → Type u} [inst : Applicative F] [inst_1 : LawfulApplicative F] {α β : Type u} (f : α → F β), Eq (Traversable.traverse f) (Equiv.traverse eqv f)\n⊢ LawfulTraversable t'","decl":"/-- If the `Traversable t'` instance has the properties that `map`,\n`map_const`, and `traverse` are equal to the ones that come from\ncarrying the traversable functor structure from `t` over the\nequivalences, then the fact that `t` is a lawful traversable functor\ncarries over as well. -/\nprotected theorem isLawfulTraversable' [Traversable t']\n    (h₀ : ∀ {α β} (f : α → β), map f = Equiv.map eqv f)\n    (h₁ : ∀ {α β} (f : β), mapConst f = (Equiv.map eqv ∘ Function.const α) f)\n    (h₂ : ∀ {F : Type u → Type u} [Applicative F],\n      ∀ [LawfulApplicative F] {α β} (f : α → F β), traverse f = Equiv.traverse eqv f) :\n    LawfulTraversable t' where\n  -- we can't use the same approach as for `lawful_functor'` because\n  -- h₂ needs a `LawfulApplicative` assumption\n  toLawfulFunctor := Equiv.lawfulFunctor' eqv @h₀ @h₁\n  id_traverse _ := by rw [h₂, Equiv.id_traverse]\n  comp_traverse _ _ _ := by rw [h₂, Equiv.comp_traverse, h₂]; congr; rw [h₂]\n  traverse_eq_map_id _ _ := by rw [h₂, Equiv.traverse_eq_map_id, h₀]; rfl\n  naturality _ _ _ _ _ := by rw [h₂, Equiv.naturality, h₂]\n\n"}
