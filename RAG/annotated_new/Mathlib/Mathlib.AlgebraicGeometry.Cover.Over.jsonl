{"name":"AlgebraicGeometry.Scheme.Cover.Over.isOver_map","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"S : AlgebraicGeometry.Scheme\nP : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nX : AlgebraicGeometry.Scheme\ninst✝ : X.Over S\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nself : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\nj : 𝒰.J\n⊢ AlgebraicGeometry.Scheme.Hom.IsOver (𝒰.map j) S","decl":"/-- A `P`-cover of a scheme `X` over `S` is a cover, where the components are over `S` and the\ncomponent maps commute with the structure morphisms. -/\nprotected class Cover.Over {P : MorphismProperty Scheme.{u}} {X : Scheme.{u}} [X.Over S]\n    (𝒰 : X.Cover P) where\n  over (j : 𝒰.J) : (𝒰.obj j).Over S := by infer_instance\n  isOver_map (j : 𝒰.J) : (𝒰.map j).IsOver S := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOver_map","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁵ : P.IsStableUnderBaseChange\ninst✝⁴ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝³ : W.Over S\ninst✝² : X.Over S\ninst✝¹ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nx : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.pullbackCoverOver S 𝒰 f).map x) (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Hom.asOver f S) (AlgebraicGeometry.Scheme.Hom.asOver (𝒰.map x) S)).left","decl":"/-- The pullback of a cover of `S`-schemes along a morphism of `S`-schemes. This is not\ndefinitionally equal to `AlgebraicGeometry.Scheme.Cover.pullbackCover`, as here we take\nthe pullback in `Over S`, whose underlying scheme is only isomorphic but not equal to the\npullback in `Scheme`. -/\n@[simps]\ndef Cover.pullbackCoverOver : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback (f.asOver S) ((𝒰.map x).asOver S)).left\n  map x := (pullback.fst (f.asOver S) ((𝒰.map x).asOver S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (Over.forget S) (f.asOver S) ((𝒰.map _).asOver S)).inv)\n    (PreservesPullback.iso_inv_fst _ _ _) x).mp ((𝒰.pullbackCover f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, ← PreservesPullback.iso_hom_fst, P.cancel_left_of_respectsIso]\n    exact P.pullback_fst _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOver_f","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁵ : P.IsStableUnderBaseChange\ninst✝⁴ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝³ : W.Over S\ninst✝² : X.Over S\ninst✝¹ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nx : ↑↑W.toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.pullbackCoverOver S 𝒰 f).f x) (𝒰.f (f.base x))","decl":"/-- The pullback of a cover of `S`-schemes along a morphism of `S`-schemes. This is not\ndefinitionally equal to `AlgebraicGeometry.Scheme.Cover.pullbackCover`, as here we take\nthe pullback in `Over S`, whose underlying scheme is only isomorphic but not equal to the\npullback in `Scheme`. -/\n@[simps]\ndef Cover.pullbackCoverOver : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback (f.asOver S) ((𝒰.map x).asOver S)).left\n  map x := (pullback.fst (f.asOver S) ((𝒰.map x).asOver S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (Over.forget S) (f.asOver S) ((𝒰.map _).asOver S)).inv)\n    (PreservesPullback.iso_inv_fst _ _ _) x).mp ((𝒰.pullbackCover f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, ← PreservesPullback.iso_hom_fst, P.cancel_left_of_respectsIso]\n    exact P.pullback_fst _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOver_obj","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁵ : P.IsStableUnderBaseChange\ninst✝⁴ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝³ : W.Over S\ninst✝² : X.Over S\ninst✝¹ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nx : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.pullbackCoverOver S 𝒰 f).obj x) (CategoryTheory.Limits.pullback (AlgebraicGeometry.Scheme.Hom.asOver f S) (AlgebraicGeometry.Scheme.Hom.asOver (𝒰.map x) S)).left","decl":"/-- The pullback of a cover of `S`-schemes along a morphism of `S`-schemes. This is not\ndefinitionally equal to `AlgebraicGeometry.Scheme.Cover.pullbackCover`, as here we take\nthe pullback in `Over S`, whose underlying scheme is only isomorphic but not equal to the\npullback in `Scheme`. -/\n@[simps]\ndef Cover.pullbackCoverOver : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback (f.asOver S) ((𝒰.map x).asOver S)).left\n  map x := (pullback.fst (f.asOver S) ((𝒰.map x).asOver S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (Over.forget S) (f.asOver S) ((𝒰.map _).asOver S)).inv)\n    (PreservesPullback.iso_inv_fst _ _ _) x).mp ((𝒰.pullbackCover f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, ← PreservesPullback.iso_hom_fst, P.cancel_left_of_respectsIso]\n    exact P.pullback_fst _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOver_J","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁵ : P.IsStableUnderBaseChange\ninst✝⁴ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝³ : W.Over S\ninst✝² : X.Over S\ninst✝¹ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝ : AlgebraicGeometry.Scheme.Hom.IsOver f S\n⊢ Eq (AlgebraicGeometry.Scheme.Cover.pullbackCoverOver S 𝒰 f).J 𝒰.J","decl":"/-- The pullback of a cover of `S`-schemes along a morphism of `S`-schemes. This is not\ndefinitionally equal to `AlgebraicGeometry.Scheme.Cover.pullbackCover`, as here we take\nthe pullback in `Over S`, whose underlying scheme is only isomorphic but not equal to the\npullback in `Scheme`. -/\n@[simps]\ndef Cover.pullbackCoverOver : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback (f.asOver S) ((𝒰.map x).asOver S)).left\n  map x := (pullback.fst (f.asOver S) ((𝒰.map x).asOver S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (Over.forget S) (f.asOver S) ((𝒰.map _).asOver S)).inv)\n    (PreservesPullback.iso_inv_fst _ _ _) x).mp ((𝒰.pullbackCover f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, ← PreservesPullback.iso_hom_fst, P.cancel_left_of_respectsIso]\n    exact P.pullback_fst _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOver'_f","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁵ : P.IsStableUnderBaseChange\ninst✝⁴ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝³ : W.Over S\ninst✝² : X.Over S\ninst✝¹ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nx : ↑↑W.toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.pullbackCoverOver' S 𝒰 f).f x) (𝒰.f (f.base x))","decl":"/-- A variant of `AlgebraicGeometry.Scheme.Cover.pullbackCoverOver` with the arguments in the\nfiber products flipped. -/\n@[simps]\ndef Cover.pullbackCoverOver' : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback ((𝒰.map x).asOver S) (f.asOver S)).left\n  map x := (pullback.snd ((𝒰.map x).asOver S) (f.asOver S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover' f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (Over.forget S) ((𝒰.map _).asOver S) (f.asOver S)).inv)\n    (PreservesPullback.iso_inv_snd _ _ _) x).mp ((𝒰.pullbackCover' f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, ← PreservesPullback.iso_hom_snd, P.cancel_left_of_respectsIso]\n    exact P.pullback_snd _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOver'_J","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁵ : P.IsStableUnderBaseChange\ninst✝⁴ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝³ : W.Over S\ninst✝² : X.Over S\ninst✝¹ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝ : AlgebraicGeometry.Scheme.Hom.IsOver f S\n⊢ Eq (AlgebraicGeometry.Scheme.Cover.pullbackCoverOver' S 𝒰 f).J 𝒰.J","decl":"/-- A variant of `AlgebraicGeometry.Scheme.Cover.pullbackCoverOver` with the arguments in the\nfiber products flipped. -/\n@[simps]\ndef Cover.pullbackCoverOver' : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback ((𝒰.map x).asOver S) (f.asOver S)).left\n  map x := (pullback.snd ((𝒰.map x).asOver S) (f.asOver S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover' f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (Over.forget S) ((𝒰.map _).asOver S) (f.asOver S)).inv)\n    (PreservesPullback.iso_inv_snd _ _ _) x).mp ((𝒰.pullbackCover' f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, ← PreservesPullback.iso_hom_snd, P.cancel_left_of_respectsIso]\n    exact P.pullback_snd _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOver'_map","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁵ : P.IsStableUnderBaseChange\ninst✝⁴ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝³ : W.Over S\ninst✝² : X.Over S\ninst✝¹ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nx : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.pullbackCoverOver' S 𝒰 f).map x) (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Hom.asOver (𝒰.map x) S) (AlgebraicGeometry.Scheme.Hom.asOver f S)).left","decl":"/-- A variant of `AlgebraicGeometry.Scheme.Cover.pullbackCoverOver` with the arguments in the\nfiber products flipped. -/\n@[simps]\ndef Cover.pullbackCoverOver' : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback ((𝒰.map x).asOver S) (f.asOver S)).left\n  map x := (pullback.snd ((𝒰.map x).asOver S) (f.asOver S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover' f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (Over.forget S) ((𝒰.map _).asOver S) (f.asOver S)).inv)\n    (PreservesPullback.iso_inv_snd _ _ _) x).mp ((𝒰.pullbackCover' f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, ← PreservesPullback.iso_hom_snd, P.cancel_left_of_respectsIso]\n    exact P.pullback_snd _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOver'_obj","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁵ : P.IsStableUnderBaseChange\ninst✝⁴ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝³ : W.Over S\ninst✝² : X.Over S\ninst✝¹ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nx : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.pullbackCoverOver' S 𝒰 f).obj x) (CategoryTheory.Limits.pullback (AlgebraicGeometry.Scheme.Hom.asOver (𝒰.map x) S) (AlgebraicGeometry.Scheme.Hom.asOver f S)).left","decl":"/-- A variant of `AlgebraicGeometry.Scheme.Cover.pullbackCoverOver` with the arguments in the\nfiber products flipped. -/\n@[simps]\ndef Cover.pullbackCoverOver' : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback ((𝒰.map x).asOver S) (f.asOver S)).left\n  map x := (pullback.snd ((𝒰.map x).asOver S) (f.asOver S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover' f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (Over.forget S) ((𝒰.map _).asOver S) (f.asOver S)).inv)\n    (PreservesPullback.iso_inv_snd _ _ _) x).mp ((𝒰.pullbackCover' f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, ← PreservesPullback.iso_hom_snd, P.cancel_left_of_respectsIso]\n    exact P.pullback_snd _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp_map","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁸ : P.IsStableUnderBaseChange\ninst✝⁷ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝⁶ : W.Over S\ninst✝⁵ : X.Over S\ninst✝⁴ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝³ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nQ : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : Q.HasOfPostcompProperty Q\ninst✝¹ : Q.IsStableUnderBaseChange\ninst✝ : Q.IsStableUnderComposition\nhX : Q (CategoryTheory.over X S inferInstance)\nhW : Q (CategoryTheory.over W S inferInstance)\nhQ : ∀ (j : 𝒰.J), Q (CategoryTheory.over (𝒰.obj j) S inferInstance)\nx : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp S 𝒰 f hX hW hQ).map x) (CategoryTheory.Limits.pullback.fst (AlgebraicGeometry.Scheme.Hom.asOverProp f S) (AlgebraicGeometry.Scheme.Hom.asOverProp (𝒰.map x) S)).left","decl":"/-- The pullback of a cover of `S`-schemes with `Q` along a morphism of `S`-schemes. This is not\ndefinitionally equal to `AlgebraicGeometry.Scheme.Cover.pullbackCover`, as here we take\nthe pullback in `Q.Over ⊤ S`, whose underlying scheme is only isomorphic but not equal to the\npullback in `Scheme`. -/\n@[simps (config := .lemmasOnly)]\ndef Cover.pullbackCoverOverProp : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback (f.asOverProp (hX := hW) (hY := hX) S)\n    ((𝒰.map x).asOverProp (hX := hQ x) (hY := hX) S)).left\n  map x := (pullback.fst (f.asOverProp S) ((𝒰.map x).asOverProp S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (MorphismProperty.Over.forget Q _ _ ⋙ Over.forget S)\n      (f.asOverProp S) ((𝒰.map _).asOverProp S)).inv)\n    (PreservesPullback.iso_inv_fst _ _ _) x).mp ((𝒰.pullbackCover f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, MorphismProperty.Comma.toCommaMorphism_eq_hom,\n      ← MorphismProperty.Comma.forget_map, ← Functor.comp_map]\n    rw [← PreservesPullback.iso_hom_fst, P.cancel_left_of_respectsIso]\n    exact P.pullback_fst _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp_f","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁸ : P.IsStableUnderBaseChange\ninst✝⁷ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝⁶ : W.Over S\ninst✝⁵ : X.Over S\ninst✝⁴ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝³ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nQ : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : Q.HasOfPostcompProperty Q\ninst✝¹ : Q.IsStableUnderBaseChange\ninst✝ : Q.IsStableUnderComposition\nhX : Q (CategoryTheory.over X S inferInstance)\nhW : Q (CategoryTheory.over W S inferInstance)\nhQ : ∀ (j : 𝒰.J), Q (CategoryTheory.over (𝒰.obj j) S inferInstance)\nx : ↑↑W.toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp S 𝒰 f hX hW hQ).f x) (𝒰.f (f.base x))","decl":"/-- The pullback of a cover of `S`-schemes with `Q` along a morphism of `S`-schemes. This is not\ndefinitionally equal to `AlgebraicGeometry.Scheme.Cover.pullbackCover`, as here we take\nthe pullback in `Q.Over ⊤ S`, whose underlying scheme is only isomorphic but not equal to the\npullback in `Scheme`. -/\n@[simps (config := .lemmasOnly)]\ndef Cover.pullbackCoverOverProp : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback (f.asOverProp (hX := hW) (hY := hX) S)\n    ((𝒰.map x).asOverProp (hX := hQ x) (hY := hX) S)).left\n  map x := (pullback.fst (f.asOverProp S) ((𝒰.map x).asOverProp S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (MorphismProperty.Over.forget Q _ _ ⋙ Over.forget S)\n      (f.asOverProp S) ((𝒰.map _).asOverProp S)).inv)\n    (PreservesPullback.iso_inv_fst _ _ _) x).mp ((𝒰.pullbackCover f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, MorphismProperty.Comma.toCommaMorphism_eq_hom,\n      ← MorphismProperty.Comma.forget_map, ← Functor.comp_map]\n    rw [← PreservesPullback.iso_hom_fst, P.cancel_left_of_respectsIso]\n    exact P.pullback_fst _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp_J","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁸ : P.IsStableUnderBaseChange\ninst✝⁷ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝⁶ : W.Over S\ninst✝⁵ : X.Over S\ninst✝⁴ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝³ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nQ : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : Q.HasOfPostcompProperty Q\ninst✝¹ : Q.IsStableUnderBaseChange\ninst✝ : Q.IsStableUnderComposition\nhX : Q (CategoryTheory.over X S inferInstance)\nhW : Q (CategoryTheory.over W S inferInstance)\nhQ : ∀ (j : 𝒰.J), Q (CategoryTheory.over (𝒰.obj j) S inferInstance)\n⊢ Eq (AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp S 𝒰 f hX hW hQ).J 𝒰.J","decl":"/-- The pullback of a cover of `S`-schemes with `Q` along a morphism of `S`-schemes. This is not\ndefinitionally equal to `AlgebraicGeometry.Scheme.Cover.pullbackCover`, as here we take\nthe pullback in `Q.Over ⊤ S`, whose underlying scheme is only isomorphic but not equal to the\npullback in `Scheme`. -/\n@[simps (config := .lemmasOnly)]\ndef Cover.pullbackCoverOverProp : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback (f.asOverProp (hX := hW) (hY := hX) S)\n    ((𝒰.map x).asOverProp (hX := hQ x) (hY := hX) S)).left\n  map x := (pullback.fst (f.asOverProp S) ((𝒰.map x).asOverProp S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (MorphismProperty.Over.forget Q _ _ ⋙ Over.forget S)\n      (f.asOverProp S) ((𝒰.map _).asOverProp S)).inv)\n    (PreservesPullback.iso_inv_fst _ _ _) x).mp ((𝒰.pullbackCover f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, MorphismProperty.Comma.toCommaMorphism_eq_hom,\n      ← MorphismProperty.Comma.forget_map, ← Functor.comp_map]\n    rw [← PreservesPullback.iso_hom_fst, P.cancel_left_of_respectsIso]\n    exact P.pullback_fst _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp_obj","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁸ : P.IsStableUnderBaseChange\ninst✝⁷ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝⁶ : W.Over S\ninst✝⁵ : X.Over S\ninst✝⁴ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝³ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nQ : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : Q.HasOfPostcompProperty Q\ninst✝¹ : Q.IsStableUnderBaseChange\ninst✝ : Q.IsStableUnderComposition\nhX : Q (CategoryTheory.over X S inferInstance)\nhW : Q (CategoryTheory.over W S inferInstance)\nhQ : ∀ (j : 𝒰.J), Q (CategoryTheory.over (𝒰.obj j) S inferInstance)\nx : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp S 𝒰 f hX hW hQ).obj x) (CategoryTheory.Limits.pullback (AlgebraicGeometry.Scheme.Hom.asOverProp f S) (AlgebraicGeometry.Scheme.Hom.asOverProp (𝒰.map x) S)).left","decl":"/-- The pullback of a cover of `S`-schemes with `Q` along a morphism of `S`-schemes. This is not\ndefinitionally equal to `AlgebraicGeometry.Scheme.Cover.pullbackCover`, as here we take\nthe pullback in `Q.Over ⊤ S`, whose underlying scheme is only isomorphic but not equal to the\npullback in `Scheme`. -/\n@[simps (config := .lemmasOnly)]\ndef Cover.pullbackCoverOverProp : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback (f.asOverProp (hX := hW) (hY := hX) S)\n    ((𝒰.map x).asOverProp (hX := hQ x) (hY := hX) S)).left\n  map x := (pullback.fst (f.asOverProp S) ((𝒰.map x).asOverProp S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (MorphismProperty.Over.forget Q _ _ ⋙ Over.forget S)\n      (f.asOverProp S) ((𝒰.map _).asOverProp S)).inv)\n    (PreservesPullback.iso_inv_fst _ _ _) x).mp ((𝒰.pullbackCover f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, MorphismProperty.Comma.toCommaMorphism_eq_hom,\n      ← MorphismProperty.Comma.forget_map, ← Functor.comp_map]\n    rw [← PreservesPullback.iso_hom_fst, P.cancel_left_of_respectsIso]\n    exact P.pullback_fst _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp'_f","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁸ : P.IsStableUnderBaseChange\ninst✝⁷ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝⁶ : W.Over S\ninst✝⁵ : X.Over S\ninst✝⁴ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝³ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nQ : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : Q.HasOfPostcompProperty Q\ninst✝¹ : Q.IsStableUnderBaseChange\ninst✝ : Q.IsStableUnderComposition\nhX : Q (CategoryTheory.over X S inferInstance)\nhW : Q (CategoryTheory.over W S inferInstance)\nhQ : ∀ (j : 𝒰.J), Q (CategoryTheory.over (𝒰.obj j) S inferInstance)\nx : ↑↑W.toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp' S 𝒰 f hX hW hQ).f x) (𝒰.f (f.base x))","decl":"/-- A variant of `AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp` with the arguments in the\nfiber products flipped. -/\n@[simps (config := .lemmasOnly)]\ndef Cover.pullbackCoverOverProp' : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback ((𝒰.map x).asOverProp (hX := hQ x) (hY := hX) S)\n    (f.asOverProp (hX := hW) (hY := hX) S)).left\n  map x := (pullback.snd ((𝒰.map x).asOverProp S) (f.asOverProp S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover' f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (MorphismProperty.Over.forget Q _ _ ⋙ Over.forget S)\n      ((𝒰.map _).asOverProp S) (f.asOverProp S)).inv)\n    (PreservesPullback.iso_inv_snd _ _ _) x).mp ((𝒰.pullbackCover' f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, MorphismProperty.Comma.toCommaMorphism_eq_hom,\n      ← MorphismProperty.Comma.forget_map, ← Functor.comp_map]\n    rw [← PreservesPullback.iso_hom_snd, P.cancel_left_of_respectsIso]\n    exact P.pullback_snd _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp'_obj","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁸ : P.IsStableUnderBaseChange\ninst✝⁷ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝⁶ : W.Over S\ninst✝⁵ : X.Over S\ninst✝⁴ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝³ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nQ : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : Q.HasOfPostcompProperty Q\ninst✝¹ : Q.IsStableUnderBaseChange\ninst✝ : Q.IsStableUnderComposition\nhX : Q (CategoryTheory.over X S inferInstance)\nhW : Q (CategoryTheory.over W S inferInstance)\nhQ : ∀ (j : 𝒰.J), Q (CategoryTheory.over (𝒰.obj j) S inferInstance)\nx : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp' S 𝒰 f hX hW hQ).obj x) (CategoryTheory.Limits.pullback (AlgebraicGeometry.Scheme.Hom.asOverProp (𝒰.map x) S) (AlgebraicGeometry.Scheme.Hom.asOverProp f S)).left","decl":"/-- A variant of `AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp` with the arguments in the\nfiber products flipped. -/\n@[simps (config := .lemmasOnly)]\ndef Cover.pullbackCoverOverProp' : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback ((𝒰.map x).asOverProp (hX := hQ x) (hY := hX) S)\n    (f.asOverProp (hX := hW) (hY := hX) S)).left\n  map x := (pullback.snd ((𝒰.map x).asOverProp S) (f.asOverProp S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover' f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (MorphismProperty.Over.forget Q _ _ ⋙ Over.forget S)\n      ((𝒰.map _).asOverProp S) (f.asOverProp S)).inv)\n    (PreservesPullback.iso_inv_snd _ _ _) x).mp ((𝒰.pullbackCover' f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, MorphismProperty.Comma.toCommaMorphism_eq_hom,\n      ← MorphismProperty.Comma.forget_map, ← Functor.comp_map]\n    rw [← PreservesPullback.iso_hom_snd, P.cancel_left_of_respectsIso]\n    exact P.pullback_snd _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp'_map","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁸ : P.IsStableUnderBaseChange\ninst✝⁷ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝⁶ : W.Over S\ninst✝⁵ : X.Over S\ninst✝⁴ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝³ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nQ : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : Q.HasOfPostcompProperty Q\ninst✝¹ : Q.IsStableUnderBaseChange\ninst✝ : Q.IsStableUnderComposition\nhX : Q (CategoryTheory.over X S inferInstance)\nhW : Q (CategoryTheory.over W S inferInstance)\nhQ : ∀ (j : 𝒰.J), Q (CategoryTheory.over (𝒰.obj j) S inferInstance)\nx : 𝒰.J\n⊢ Eq ((AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp' S 𝒰 f hX hW hQ).map x) (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Scheme.Hom.asOverProp (𝒰.map x) S) (AlgebraicGeometry.Scheme.Hom.asOverProp f S)).left","decl":"/-- A variant of `AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp` with the arguments in the\nfiber products flipped. -/\n@[simps (config := .lemmasOnly)]\ndef Cover.pullbackCoverOverProp' : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback ((𝒰.map x).asOverProp (hX := hQ x) (hY := hX) S)\n    (f.asOverProp (hX := hW) (hY := hX) S)).left\n  map x := (pullback.snd ((𝒰.map x).asOverProp S) (f.asOverProp S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover' f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (MorphismProperty.Over.forget Q _ _ ⋙ Over.forget S)\n      ((𝒰.map _).asOverProp S) (f.asOverProp S)).inv)\n    (PreservesPullback.iso_inv_snd _ _ _) x).mp ((𝒰.pullbackCover' f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, MorphismProperty.Comma.toCommaMorphism_eq_hom,\n      ← MorphismProperty.Comma.forget_map, ← Functor.comp_map]\n    rw [← PreservesPullback.iso_hom_snd, P.cancel_left_of_respectsIso]\n    exact P.pullback_snd _ _ (𝒰.map_prop j)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp'_J","module":"Mathlib.AlgebraicGeometry.Cover.Over","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nS : AlgebraicGeometry.Scheme\ninst✝⁸ : P.IsStableUnderBaseChange\ninst✝⁷ : AlgebraicGeometry.Scheme.IsJointlySurjectivePreserving P\nX W : AlgebraicGeometry.Scheme\n𝒰 : AlgebraicGeometry.Scheme.Cover P X\nf : Quiver.Hom W X\ninst✝⁶ : W.Over S\ninst✝⁵ : X.Over S\ninst✝⁴ : AlgebraicGeometry.Scheme.Cover.Over S 𝒰\ninst✝³ : AlgebraicGeometry.Scheme.Hom.IsOver f S\nQ : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝² : Q.HasOfPostcompProperty Q\ninst✝¹ : Q.IsStableUnderBaseChange\ninst✝ : Q.IsStableUnderComposition\nhX : Q (CategoryTheory.over X S inferInstance)\nhW : Q (CategoryTheory.over W S inferInstance)\nhQ : ∀ (j : 𝒰.J), Q (CategoryTheory.over (𝒰.obj j) S inferInstance)\n⊢ Eq (AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp' S 𝒰 f hX hW hQ).J 𝒰.J","decl":"/-- A variant of `AlgebraicGeometry.Scheme.Cover.pullbackCoverOverProp` with the arguments in the\nfiber products flipped. -/\n@[simps (config := .lemmasOnly)]\ndef Cover.pullbackCoverOverProp' : W.Cover P where\n  J := 𝒰.J\n  obj x := (pullback ((𝒰.map x).asOverProp (hX := hQ x) (hY := hX) S)\n    (f.asOverProp (hX := hW) (hY := hX) S)).left\n  map x := (pullback.snd ((𝒰.map x).asOverProp S) (f.asOverProp S)).left\n  f x := 𝒰.f (f.base x)\n  covers x := (mem_range_iff_of_surjective ((𝒰.pullbackCover' f).map (𝒰.f (f.base x))) _\n    ((PreservesPullback.iso (MorphismProperty.Over.forget Q _ _ ⋙ Over.forget S)\n      ((𝒰.map _).asOverProp S) (f.asOverProp S)).inv)\n    (PreservesPullback.iso_inv_snd _ _ _) x).mp ((𝒰.pullbackCover' f).covers x)\n  map_prop j := by\n    dsimp only\n    rw [← Over.forget_map, MorphismProperty.Comma.toCommaMorphism_eq_hom,\n      ← MorphismProperty.Comma.forget_map, ← Functor.comp_map]\n    rw [← PreservesPullback.iso_hom_snd, P.cancel_left_of_respectsIso]\n    exact P.pullback_snd _ _ (𝒰.map_prop j)\n\n"}
