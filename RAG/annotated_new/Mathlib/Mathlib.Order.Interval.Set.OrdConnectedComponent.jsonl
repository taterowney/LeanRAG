{"name":"Set.mem_ordConnectedComponent","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx y : α\n⊢ Iff (Membership.mem (s.ordConnectedComponent x) y) (HasSubset.Subset (Set.uIcc x y) s)","decl":"theorem mem_ordConnectedComponent : y ∈ ordConnectedComponent s x ↔ [[x, y]] ⊆ s :=\n  Iff.rfl\n\n"}
{"name":"Set.dual_ordConnectedComponent","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx : α\n⊢ Eq ((Set.preimage (⇑OrderDual.ofDual) s).ordConnectedComponent (OrderDual.toDual x)) (Set.preimage (⇑OrderDual.ofDual) (s.ordConnectedComponent x))","decl":"theorem dual_ordConnectedComponent :\n    ordConnectedComponent (ofDual ⁻¹' s) (toDual x) = ofDual ⁻¹' ordConnectedComponent s x :=\n  ext <| (Surjective.forall toDual.surjective).2 fun x => by\n    rw [mem_ordConnectedComponent, dual_uIcc]\n    rfl\n\n"}
{"name":"Set.ordConnectedComponent_subset","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx : α\n⊢ HasSubset.Subset (s.ordConnectedComponent x) s","decl":"theorem ordConnectedComponent_subset : ordConnectedComponent s x ⊆ s := fun _ hy =>\n  hy right_mem_uIcc\n\n"}
{"name":"Set.subset_ordConnectedComponent","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx : α\nt : Set α\nh : s.OrdConnected\nhs : Membership.mem s x\nht : HasSubset.Subset s t\n⊢ HasSubset.Subset s (t.ordConnectedComponent x)","decl":"theorem subset_ordConnectedComponent {t} [h : OrdConnected s] (hs : x ∈ s) (ht : s ⊆ t) :\n    s ⊆ ordConnectedComponent t x := fun _ hy => (h.uIcc_subset hs hy).trans ht\n\n"}
{"name":"Set.self_mem_ordConnectedComponent","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx : α\n⊢ Iff (Membership.mem (s.ordConnectedComponent x) x) (Membership.mem s x)","decl":"@[simp]\ntheorem self_mem_ordConnectedComponent : x ∈ ordConnectedComponent s x ↔ x ∈ s := by\n  rw [mem_ordConnectedComponent, uIcc_self, singleton_subset_iff]\n\n"}
{"name":"Set.nonempty_ordConnectedComponent","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx : α\n⊢ Iff (s.ordConnectedComponent x).Nonempty (Membership.mem s x)","decl":"@[simp]\ntheorem nonempty_ordConnectedComponent : (ordConnectedComponent s x).Nonempty ↔ x ∈ s :=\n  ⟨fun ⟨_, hy⟩ => hy <| left_mem_uIcc, fun h => ⟨x, self_mem_ordConnectedComponent.2 h⟩⟩\n\n"}
{"name":"Set.ordConnectedComponent_eq_empty","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx : α\n⊢ Iff (Eq (s.ordConnectedComponent x) EmptyCollection.emptyCollection) (Not (Membership.mem s x))","decl":"@[simp]\ntheorem ordConnectedComponent_eq_empty : ordConnectedComponent s x = ∅ ↔ x ∉ s := by\n  rw [← not_nonempty_iff_eq_empty, nonempty_ordConnectedComponent]\n\n"}
{"name":"Set.ordConnectedComponent_empty","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx : α\n⊢ Eq (EmptyCollection.emptyCollection.ordConnectedComponent x) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem ordConnectedComponent_empty : ordConnectedComponent ∅ x = ∅ :=\n  ordConnectedComponent_eq_empty.2 (not_mem_empty x)\n\n"}
{"name":"Set.ordConnectedComponent_univ","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx : α\n⊢ Eq (Set.univ.ordConnectedComponent x) Set.univ","decl":"@[simp]\ntheorem ordConnectedComponent_univ : ordConnectedComponent univ x = univ := by\n  simp [ordConnectedComponent]\n\n"}
{"name":"Set.ordConnectedComponent_inter","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Set α\nx : α\n⊢ Eq ((Inter.inter s t).ordConnectedComponent x) (Inter.inter (s.ordConnectedComponent x) (t.ordConnectedComponent x))","decl":"theorem ordConnectedComponent_inter (s t : Set α) (x : α) :\n    ordConnectedComponent (s ∩ t) x = ordConnectedComponent s x ∩ ordConnectedComponent t x := by\n  simp [ordConnectedComponent, setOf_and]\n\n"}
{"name":"Set.mem_ordConnectedComponent_comm","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx y : α\n⊢ Iff (Membership.mem (s.ordConnectedComponent x) y) (Membership.mem (s.ordConnectedComponent y) x)","decl":"theorem mem_ordConnectedComponent_comm :\n    y ∈ ordConnectedComponent s x ↔ x ∈ ordConnectedComponent s y := by\n  rw [mem_ordConnectedComponent, mem_ordConnectedComponent, uIcc_comm]\n\n"}
{"name":"Set.mem_ordConnectedComponent_trans","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx y z : α\nhxy : Membership.mem (s.ordConnectedComponent x) y\nhyz : Membership.mem (s.ordConnectedComponent y) z\n⊢ Membership.mem (s.ordConnectedComponent x) z","decl":"theorem mem_ordConnectedComponent_trans (hxy : y ∈ ordConnectedComponent s x)\n    (hyz : z ∈ ordConnectedComponent s y) : z ∈ ordConnectedComponent s x :=\n  calc\n    [[x, z]] ⊆ [[x, y]] ∪ [[y, z]] := uIcc_subset_uIcc_union_uIcc\n    _ ⊆ s := union_subset hxy hyz\n\n"}
{"name":"Set.ordConnectedComponent_eq","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx y : α\nh : HasSubset.Subset (Set.uIcc x y) s\n⊢ Eq (s.ordConnectedComponent x) (s.ordConnectedComponent y)","decl":"theorem ordConnectedComponent_eq (h : [[x, y]] ⊆ s) :\n    ordConnectedComponent s x = ordConnectedComponent s y :=\n  ext fun _ =>\n    ⟨mem_ordConnectedComponent_trans (mem_ordConnectedComponent_comm.2 h),\n      mem_ordConnectedComponent_trans h⟩\n\n"}
{"name":"Set.instOrdConnectedOrdConnectedComponent","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx : α\n⊢ (s.ordConnectedComponent x).OrdConnected","decl":"instance : OrdConnected (ordConnectedComponent s x) :=\n  ordConnected_of_uIcc_subset_left fun _ hy _ hz => (uIcc_subset_uIcc_left hz).trans hy\n\n"}
{"name":"Set.ordConnectedProj_mem_ordConnectedComponent","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx : ↑s\n⊢ Membership.mem (s.ordConnectedComponent ↑x) (s.ordConnectedProj x)","decl":"theorem ordConnectedProj_mem_ordConnectedComponent (s : Set α) (x : s) :\n    ordConnectedProj s x ∈ ordConnectedComponent s x :=\n  Nonempty.some_mem _\n\n"}
{"name":"Set.mem_ordConnectedComponent_ordConnectedProj","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx : ↑s\n⊢ Membership.mem (s.ordConnectedComponent (s.ordConnectedProj x)) ↑x","decl":"theorem mem_ordConnectedComponent_ordConnectedProj (s : Set α) (x : s) :\n    ↑x ∈ ordConnectedComponent s (ordConnectedProj s x) :=\n  mem_ordConnectedComponent_comm.2 <| ordConnectedProj_mem_ordConnectedComponent s x\n\n"}
{"name":"Set.ordConnectedComponent_ordConnectedProj","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx : ↑s\n⊢ Eq (s.ordConnectedComponent (s.ordConnectedProj x)) (s.ordConnectedComponent ↑x)","decl":"@[simp]\ntheorem ordConnectedComponent_ordConnectedProj (s : Set α) (x : s) :\n    ordConnectedComponent s (ordConnectedProj s x) = ordConnectedComponent s x :=\n  ordConnectedComponent_eq <| mem_ordConnectedComponent_ordConnectedProj _ _\n\n"}
{"name":"Set.ordConnectedProj_eq","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx y : ↑s\n⊢ Iff (Eq (s.ordConnectedProj x) (s.ordConnectedProj y)) (HasSubset.Subset (Set.uIcc ↑x ↑y) s)","decl":"@[simp]\ntheorem ordConnectedProj_eq {x y : s} :\n    ordConnectedProj s x = ordConnectedProj s y ↔ [[(x : α), y]] ⊆ s := by\n  constructor <;> intro h\n  · rw [← mem_ordConnectedComponent, ← ordConnectedComponent_ordConnectedProj, h,\n      ordConnectedComponent_ordConnectedProj, self_mem_ordConnectedComponent]\n    exact y.2\n  · simp only [ordConnectedProj, ordConnectedComponent_eq h]\n\n"}
{"name":"Set.dual_ordConnectedSection","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\n⊢ Eq (Set.preimage (⇑OrderDual.ofDual) s).ordConnectedSection (Set.preimage (⇑OrderDual.ofDual) s.ordConnectedSection)","decl":"theorem dual_ordConnectedSection (s : Set α) :\n    ordConnectedSection (ofDual ⁻¹' s) = ofDual ⁻¹' ordConnectedSection s := by\n  simp only [ordConnectedSection]\n  simp (config := { unfoldPartialApp := true }) only [ordConnectedProj]\n  ext x\n  simp only [mem_range, Subtype.exists, mem_preimage, OrderDual.exists, dual_ordConnectedComponent,\n    ofDual_toDual]\n  tauto\n\n"}
{"name":"Set.ordConnectedSection_subset","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\n⊢ HasSubset.Subset s.ordConnectedSection s","decl":"theorem ordConnectedSection_subset : ordConnectedSection s ⊆ s :=\n  range_subset_iff.2 fun _ => ordConnectedComponent_subset <| Nonempty.some_mem _\n\n"}
{"name":"Set.eq_of_mem_ordConnectedSection_of_uIcc_subset","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx y : α\nhx : Membership.mem s.ordConnectedSection x\nhy : Membership.mem s.ordConnectedSection y\nh : HasSubset.Subset (Set.uIcc x y) s\n⊢ Eq x y","decl":"theorem eq_of_mem_ordConnectedSection_of_uIcc_subset (hx : x ∈ ordConnectedSection s)\n    (hy : y ∈ ordConnectedSection s) (h : [[x, y]] ⊆ s) : x = y := by\n  rcases hx with ⟨x, rfl⟩; rcases hy with ⟨y, rfl⟩\n  exact\n    ordConnectedProj_eq.2\n      (mem_ordConnectedComponent_trans\n        (mem_ordConnectedComponent_trans (ordConnectedProj_mem_ordConnectedComponent _ _) h)\n        (mem_ordConnectedComponent_ordConnectedProj _ _))\n\n"}
{"name":"Set.ordSeparatingSet_comm","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Set α\n⊢ Eq (s.ordSeparatingSet t) (t.ordSeparatingSet s)","decl":"theorem ordSeparatingSet_comm (s t : Set α) : ordSeparatingSet s t = ordSeparatingSet t s :=\n  inter_comm _ _\n\n"}
{"name":"Set.disjoint_left_ordSeparatingSet","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Set α\n⊢ Disjoint s (s.ordSeparatingSet t)","decl":"theorem disjoint_left_ordSeparatingSet : Disjoint s (ordSeparatingSet s t) :=\n  Disjoint.inter_right' _ <|\n    disjoint_iUnion₂_right.2 fun _ _ =>\n      disjoint_compl_right.mono_right <| ordConnectedComponent_subset\n\n"}
{"name":"Set.disjoint_right_ordSeparatingSet","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Set α\n⊢ Disjoint t (s.ordSeparatingSet t)","decl":"theorem disjoint_right_ordSeparatingSet : Disjoint t (ordSeparatingSet s t) :=\n  ordSeparatingSet_comm t s ▸ disjoint_left_ordSeparatingSet\n\n"}
{"name":"Set.dual_ordSeparatingSet","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Set α\n⊢ Eq ((Set.preimage (⇑OrderDual.ofDual) s).ordSeparatingSet (Set.preimage (⇑OrderDual.ofDual) t)) (Set.preimage (⇑OrderDual.ofDual) (s.ordSeparatingSet t))","decl":"theorem dual_ordSeparatingSet :\n    ordSeparatingSet (ofDual ⁻¹' s) (ofDual ⁻¹' t) = ofDual ⁻¹' ordSeparatingSet s t := by\n  simp only [ordSeparatingSet, mem_preimage, ← toDual.surjective.iUnion_comp, ofDual_toDual,\n    dual_ordConnectedComponent, ← preimage_compl, preimage_inter, preimage_iUnion]\n\n"}
{"name":"Set.disjoint_ordT5Nhd","module":"Mathlib.Order.Interval.Set.OrdConnectedComponent","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Set α\n⊢ Disjoint (s.ordT5Nhd t) (t.ordT5Nhd s)","decl":"theorem disjoint_ordT5Nhd : Disjoint (ordT5Nhd s t) (ordT5Nhd t s) := by\n  rw [disjoint_iff_inf_le]\n  rintro x ⟨hx₁, hx₂⟩\n  rcases mem_iUnion₂.1 hx₁ with ⟨a, has, ha⟩\n  clear hx₁\n  rcases mem_iUnion₂.1 hx₂ with ⟨b, hbt, hb⟩\n  clear hx₂\n  rw [mem_ordConnectedComponent, subset_inter_iff] at ha hb\n  wlog hab : a ≤ b with H\n  · exact H b hbt hb a has ha (le_of_not_le hab)\n  cases' ha with ha ha'\n  cases' hb with hb hb'\n  have hsub : [[a, b]] ⊆ (ordSeparatingSet s t).ordConnectedSectionᶜ := by\n    rw [ordSeparatingSet_comm, uIcc_comm] at hb'\n    calc\n      [[a, b]] ⊆ [[a, x]] ∪ [[x, b]] := uIcc_subset_uIcc_union_uIcc\n      _ ⊆ (ordSeparatingSet s t).ordConnectedSectionᶜ := union_subset ha' hb'\n  clear ha' hb'\n  rcases le_total x a with hxa | hax\n  · exact hb (Icc_subset_uIcc' ⟨hxa, hab⟩) has\n  rcases le_total b x with hbx | hxb\n  · exact ha (Icc_subset_uIcc ⟨hab, hbx⟩) hbt\n  have h' : x ∈ ordSeparatingSet s t := ⟨mem_iUnion₂.2 ⟨a, has, ha⟩, mem_iUnion₂.2 ⟨b, hbt, hb⟩⟩\n  lift x to ordSeparatingSet s t using h'\n  suffices ordConnectedComponent (ordSeparatingSet s t) x ⊆ [[a, b]] from\n    hsub (this <| ordConnectedProj_mem_ordConnectedComponent _ x) (mem_range_self _)\n  rintro y hy\n  rw [uIcc_of_le hab, mem_Icc, ← not_lt, ← not_lt]\n  have sol1 := fun (hya : y < a) =>\n      (disjoint_left (t := ordSeparatingSet s t)).1 disjoint_left_ordSeparatingSet has\n        (hy <| Icc_subset_uIcc' ⟨hya.le, hax⟩)\n  have sol2 := fun (hby : b < y) =>\n      (disjoint_left (t := ordSeparatingSet s t)).1 disjoint_right_ordSeparatingSet hbt\n        (hy <| Icc_subset_uIcc ⟨hxb, hby.le⟩)\n  exact ⟨sol1, sol2⟩\n\n"}
