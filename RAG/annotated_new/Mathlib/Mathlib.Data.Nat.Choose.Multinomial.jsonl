{"name":"Nat.multinomial_pos","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Nat\n⊢ LT.lt 0 (Nat.multinomial s f)","decl":"theorem multinomial_pos : 0 < multinomial s f :=\n  Nat.div_pos (le_of_dvd (factorial_pos _) (prod_factorial_dvd_factorial_sum s f))\n    (prod_factorial_pos s f)\n\n"}
{"name":"Nat.multinomial_spec","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Nat\n⊢ Eq (HMul.hMul (s.prod fun i => (f i).factorial) (Nat.multinomial s f)) (s.sum fun i => f i).factorial","decl":"theorem multinomial_spec : (∏ i ∈ s, (f i)!) * multinomial s f = (∑ i ∈ s, f i)! :=\n  Nat.mul_div_cancel' (prod_factorial_dvd_factorial_sum s f)\n\n"}
{"name":"Nat.multinomial_empty","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\nf : α → Nat\n⊢ Eq (Nat.multinomial EmptyCollection.emptyCollection f) 1","decl":"@[simp] lemma multinomial_empty : multinomial ∅ f = 1 := by simp [multinomial]\n\n"}
{"name":"Nat.multinomial_cons","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\ns : Finset α\na : α\nha : Not (Membership.mem s a)\nf : α → Nat\n⊢ Eq (Nat.multinomial (Finset.cons a s ha) f) (HMul.hMul ((HAdd.hAdd (f a) (s.sum fun i => f i)).choose (f a)) (Nat.multinomial s f))","decl":"lemma multinomial_cons (ha : a ∉ s) (f : α → ℕ) :\n    multinomial (s.cons a ha) f = (f a + ∑ i ∈ s, f i).choose (f a) * multinomial s f := by\n  rw [multinomial, Nat.div_eq_iff_eq_mul_left _ (prod_factorial_dvd_factorial_sum _ _), prod_cons,\n    multinomial, mul_assoc, mul_left_comm _ (f a)!,\n    Nat.div_mul_cancel (prod_factorial_dvd_factorial_sum _ _), ← mul_assoc, Nat.choose_symm_add,\n    Nat.add_choose_mul_factorial_mul_factorial, Finset.sum_cons]\n  positivity\n\n"}
{"name":"Nat.multinomial_insert","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\nha : Not (Membership.mem s a)\nf : α → Nat\n⊢ Eq (Nat.multinomial (Insert.insert a s) f) (HMul.hMul ((HAdd.hAdd (f a) (s.sum fun i => f i)).choose (f a)) (Nat.multinomial s f))","decl":"lemma multinomial_insert [DecidableEq α] (ha : a ∉ s) (f : α → ℕ) :\n    multinomial (insert a s) f = (f a + ∑ i ∈ s, f i).choose (f a) * multinomial s f := by\n  rw [← cons_eq_insert _ _ ha, multinomial_cons]\n\n"}
{"name":"Nat.multinomial_singleton","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\na : α\nf : α → Nat\n⊢ Eq (Nat.multinomial (Singleton.singleton a) f) 1","decl":"@[simp] lemma multinomial_singleton (a : α) (f : α → ℕ) : multinomial {a} f = 1 := by\n  rw [← cons_empty, multinomial_cons]; simp\n\n"}
{"name":"Nat.multinomial_insert_one","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Nat\na : α\ninst✝ : DecidableEq α\nh : Not (Membership.mem s a)\nh₁ : Eq (f a) 1\n⊢ Eq (Nat.multinomial (Insert.insert a s) f) (HMul.hMul (s.sum f).succ (Nat.multinomial s f))","decl":"@[simp]\ntheorem multinomial_insert_one [DecidableEq α] (h : a ∉ s) (h₁ : f a = 1) :\n    multinomial (insert a s) f = (s.sum f).succ * multinomial s f := by\n  simp only [multinomial]\n  rw [Finset.sum_insert h, Finset.prod_insert h, h₁, add_comm, ← succ_eq_add_one, factorial_succ]\n  simp only [factorial, succ_eq_add_one, zero_add, mul_one, one_mul]\n  rw [Nat.mul_div_assoc _ (prod_factorial_dvd_factorial_sum _ _)]\n\n"}
{"name":"Nat.multinomial_congr","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\ns : Finset α\nf g : α → Nat\nh : ∀ (a : α), Membership.mem s a → Eq (f a) (g a)\n⊢ Eq (Nat.multinomial s f) (Nat.multinomial s g)","decl":"theorem multinomial_congr {f g : α → ℕ} (h : ∀ a ∈ s, f a = g a) :\n    multinomial s f = multinomial s g := by\n  simp only [multinomial]; congr 1\n  · rw [Finset.sum_congr rfl h]\n  · exact Finset.prod_congr rfl fun a ha => by rw [h a ha]\n\n"}
{"name":"Nat.binomial_eq","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\nf : α → Nat\na b : α\ninst✝ : DecidableEq α\nh : Ne a b\n⊢ Eq (Nat.multinomial (Insert.insert a (Singleton.singleton b)) f) (HDiv.hDiv (HAdd.hAdd (f a) (f b)).factorial (HMul.hMul (f a).factorial (f b).factorial))","decl":"theorem binomial_eq [DecidableEq α] (h : a ≠ b) :\n    multinomial {a, b} f = (f a + f b)! / ((f a)! * (f b)!) := by\n  simp [multinomial, Finset.sum_pair h, Finset.prod_pair h]\n\n"}
{"name":"Nat.binomial_eq_choose","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\nf : α → Nat\na b : α\ninst✝ : DecidableEq α\nh : Ne a b\n⊢ Eq (Nat.multinomial (Insert.insert a (Singleton.singleton b)) f) ((HAdd.hAdd (f a) (f b)).choose (f a))","decl":"theorem binomial_eq_choose [DecidableEq α] (h : a ≠ b) :\n    multinomial {a, b} f = (f a + f b).choose (f a) := by\n  simp [binomial_eq h, choose_eq_factorial_div_factorial (Nat.le_add_right _ _)]\n\n"}
{"name":"Nat.binomial_spec","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\nf : α → Nat\na b : α\ninst✝ : DecidableEq α\nhab : Ne a b\n⊢ Eq (HMul.hMul (HMul.hMul (f a).factorial (f b).factorial) (Nat.multinomial (Insert.insert a (Singleton.singleton b)) f)) (HAdd.hAdd (f a) (f b)).factorial","decl":"theorem binomial_spec [DecidableEq α] (hab : a ≠ b) :\n    (f a)! * (f b)! * multinomial {a, b} f = (f a + f b)! := by\n  simpa [Finset.sum_pair hab, Finset.prod_pair hab] using multinomial_spec {a, b} f\n\n"}
{"name":"Nat.binomial_one","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\nf : α → Nat\na b : α\ninst✝ : DecidableEq α\nh : Ne a b\nh₁ : Eq (f a) 1\n⊢ Eq (Nat.multinomial (Insert.insert a (Singleton.singleton b)) f) (f b).succ","decl":"@[simp]\ntheorem binomial_one [DecidableEq α] (h : a ≠ b) (h₁ : f a = 1) :\n    multinomial {a, b} f = (f b).succ := by\n  simp [multinomial_insert_one (Finset.not_mem_singleton.mpr h) h₁]\n\n"}
{"name":"Nat.binomial_succ_succ","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\nf : α → Nat\na b : α\ninst✝ : DecidableEq α\nh : Ne a b\n⊢ Eq (Nat.multinomial (Insert.insert a (Singleton.singleton b)) (Function.update (Function.update f a (f a).succ) b (f b).succ)) (HAdd.hAdd (Nat.multinomial (Insert.insert a (Singleton.singleton b)) (Function.update f a (f a).succ)) (Nat.multinomial (Insert.insert a (Singleton.singleton b)) (Function.update f b (f b).succ)))","decl":"theorem binomial_succ_succ [DecidableEq α] (h : a ≠ b) :\n    multinomial {a, b} (Function.update (Function.update f a (f a).succ) b (f b).succ) =\n      multinomial {a, b} (Function.update f a (f a).succ) +\n      multinomial {a, b} (Function.update f b (f b).succ) := by\n  simp only [binomial_eq_choose, Function.update_apply,\n    h, Ne, ite_true, ite_false, not_false_eq_true]\n  rw [if_neg h.symm]\n  rw [add_succ, choose_succ_succ, succ_add_eq_add_succ]\n  ring\n\n"}
{"name":"Nat.succ_mul_binomial","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\nf : α → Nat\na b : α\ninst✝ : DecidableEq α\nh : Ne a b\n⊢ Eq (HMul.hMul (HAdd.hAdd (f a) (f b)).succ (Nat.multinomial (Insert.insert a (Singleton.singleton b)) f)) (HMul.hMul (f a).succ (Nat.multinomial (Insert.insert a (Singleton.singleton b)) (Function.update f a (f a).succ)))","decl":"theorem succ_mul_binomial [DecidableEq α] (h : a ≠ b) :\n    (f a + f b).succ * multinomial {a, b} f =\n      (f a).succ * multinomial {a, b} (Function.update f a (f a).succ) := by\n  rw [binomial_eq_choose h, binomial_eq_choose h, mul_comm (f a).succ, Function.update_self,\n    Function.update_of_ne h.symm]\n  rw [succ_mul_choose_eq (f a + f b) (f a), succ_add (f a) (f b)]\n\n"}
{"name":"Nat.multinomial_univ_two","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"a b : Nat\n⊢ Eq (Nat.multinomial Finset.univ (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty))) (HDiv.hDiv (HAdd.hAdd a b).factorial (HMul.hMul a.factorial b.factorial))","decl":"theorem multinomial_univ_two (a b : ℕ) :\n    multinomial Finset.univ ![a, b] = (a + b)! / (a ! * b !) := by\n  rw [multinomial, Fin.sum_univ_two, Fin.prod_univ_two, Matrix.cons_val_zero, Matrix.cons_val_one,\n    Matrix.head_cons]\n\n"}
{"name":"Nat.multinomial_univ_three","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"a b c : Nat\n⊢ Eq (Nat.multinomial Finset.univ (Matrix.vecCons a (Matrix.vecCons b (Matrix.vecCons c Matrix.vecEmpty)))) (HDiv.hDiv (HAdd.hAdd (HAdd.hAdd a b) c).factorial (HMul.hMul (HMul.hMul a.factorial b.factorial) c.factorial))","decl":"theorem multinomial_univ_three (a b c : ℕ) :\n    multinomial Finset.univ ![a, b, c] = (a + b + c)! / (a ! * b ! * c !) := by\n  rw [multinomial, Fin.sum_univ_three, Fin.prod_univ_three]\n  rfl\n\n"}
{"name":"Finsupp.multinomial_eq","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\nf : Finsupp α Nat\n⊢ Eq f.multinomial (Nat.multinomial f.support ⇑f)","decl":"theorem multinomial_eq (f : α →₀ ℕ) : f.multinomial = Nat.multinomial f.support f :=\n  rfl\n\n"}
{"name":"Finsupp.multinomial_update","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\na : α\nf : Finsupp α Nat\n⊢ Eq f.multinomial (HMul.hMul ((f.sum fun x => id).choose (f a)) (f.update a 0).multinomial)","decl":"theorem multinomial_update (a : α) (f : α →₀ ℕ) :\n    f.multinomial = (f.sum fun _ => id).choose (f a) * (f.update a 0).multinomial := by\n  simp only [multinomial_eq]\n  classical\n    by_cases h : a ∈ f.support\n    · rw [← Finset.insert_erase h, Nat.multinomial_insert (Finset.not_mem_erase a _),\n        Finset.add_sum_erase _ f h, support_update_zero]\n      congr 1\n      exact Nat.multinomial_congr fun _ h ↦ (Function.update_of_ne (mem_erase.1 h).1 0 f).symm\n    rw [not_mem_support_iff] at h\n    rw [h, Nat.choose_zero_right, one_mul, ← h, update_self]\n\n"}
{"name":"Multiset.multinomial_filter_ne","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nm : Multiset α\n⊢ Eq m.multinomial (HMul.hMul (m.card.choose (Multiset.count a m)) (Multiset.filter (fun x => Ne a x) m).multinomial)","decl":"theorem multinomial_filter_ne [DecidableEq α] (a : α) (m : Multiset α) :\n    m.multinomial = m.card.choose (m.count a) * (m.filter (a ≠ ·)).multinomial := by\n  dsimp only [multinomial]\n  convert Finsupp.multinomial_update a _\n  · rw [← Finsupp.card_toMultiset, m.toFinsupp_toMultiset]\n  · ext1 a\n    rw [toFinsupp_apply, count_filter, Finsupp.coe_update]\n    split_ifs with h\n    · rw [Function.update_of_ne h.symm, toFinsupp_apply]\n    · rw [not_ne_iff.1 h, Function.update_self]\n\n"}
{"name":"Multiset.multinomial_zero","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq (Multiset.multinomial 0) 1","decl":"@[simp]\ntheorem multinomial_zero [DecidableEq α] : multinomial (0 : Multiset α) = 1 := by\n  simp [multinomial, Finsupp.multinomial]\n\n"}
{"name":"Finset.sum_pow_eq_sum_piAntidiag_of_commute","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Semiring R\ns : Finset α\nf : α → R\nhc : (↑s).Pairwise (Function.onFun Commute f)\nn : Nat\n⊢ Eq (HPow.hPow (s.sum fun i => f i) n) ((s.piAntidiag n).sum fun k => HMul.hMul (↑(Nat.multinomial s k)) (s.noncommProd (fun i => HPow.hPow (f i) (k i)) ⋯))","decl":"/-- The **multinomial theorem**. -/\nlemma sum_pow_eq_sum_piAntidiag_of_commute (s : Finset α) (f : α → R)\n    (hc : (s : Set α).Pairwise (Commute on f)) (n : ℕ) :\n    (∑ i ∈ s, f i) ^ n = ∑ k ∈ piAntidiag s n, multinomial s k *\n      s.noncommProd (fun i ↦ f i ^ k i) (hc.mono' fun _ _ h ↦ h.pow_pow ..) := by\n  classical\n  induction' s using Finset.cons_induction with a s has ih generalizing n\n  · cases n <;> simp\n  rw [Finset.sum_cons, piAntidiag_cons, sum_disjiUnion]\n  simp only [sum_map, Function.Embedding.coeFn_mk, Pi.add_apply, multinomial_cons,\n    Pi.add_apply, eq_self_iff_true, if_true, Nat.cast_mul, noncommProd_cons, eq_self_iff_true,\n    if_true, sum_add_distrib, sum_ite_eq', has, if_false, add_zero,\n    addLeftEmbedding_eq_addRightEmbedding, addRightEmbedding_apply]\n  suffices ∀ p : ℕ × ℕ, p ∈ antidiagonal n →\n    ∑ g ∈ piAntidiag s p.2, ((g a + p.1 + s.sum g).choose (g a + p.1) : R) *\n      multinomial s (g + fun i ↦ ite (i = a) p.1 0) *\n        (f a ^ (g a + p.1) * s.noncommProd (fun i ↦ f i ^ (g i + ite (i = a) p.1 0))\n          ((hc.mono (by simp)).mono' fun i j h ↦ h.pow_pow ..)) =\n      ∑ g ∈ piAntidiag s p.2, n.choose p.1 * multinomial s g * (f a ^ p.1 *\n        s.noncommProd (fun i ↦ f i ^ g i) ((hc.mono (by simp)).mono' fun i j h ↦ h.pow_pow ..)) by\n    rw [sum_congr rfl this]\n    simp only [Nat.antidiagonal_eq_map, sum_map, Function.Embedding.coeFn_mk]\n    rw [(Commute.sum_right _ _ _ fun i hi ↦ hc (by simp) (by simp [hi])\n      (by simpa [eq_comm] using ne_of_mem_of_not_mem hi has)).add_pow]\n    simp only [ih (hc.mono (by simp)), sum_mul, mul_sum]\n    refine sum_congr rfl fun i _ ↦ sum_congr rfl fun g _ ↦ ?_\n    rw [← Nat.cast_comm, (Nat.commute_cast (f a ^ i) _).left_comm, mul_assoc]\n  refine fun p hp ↦ sum_congr rfl fun f hf ↦ ?_\n  rw [mem_piAntidiag] at hf\n  rw [not_imp_comm.1 (hf.2 _) has, zero_add, hf.1]\n  congr 2\n  · rw [mem_antidiagonal.1 hp]\n  · rw [multinomial_congr]\n    intro t ht\n    rw [Pi.add_apply, if_neg, add_zero]\n    exact ne_of_mem_of_not_mem ht has\n  refine noncommProd_congr rfl (fun t ht ↦ ?_) _\n  rw [if_neg, add_zero]\n  exact ne_of_mem_of_not_mem ht has\n\n"}
{"name":"Finset.sum_pow_of_commute","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Semiring R\nx : α → R\ns : Finset α\nhc : (↑s).Pairwise (Function.onFun Commute x)\nn : Nat\n⊢ Eq (HPow.hPow (s.sum x) n) (Finset.univ.sum fun k => HMul.hMul (↑(↑↑k).multinomial) ((Multiset.map x ↑↑k).noncommProd ⋯))","decl":"/-- The **multinomial theorem**. -/\ntheorem sum_pow_of_commute (x : α → R) (s : Finset α)\n    (hc : (s : Set α).Pairwise (Commute on x)) :\n    ∀ n,\n      s.sum x ^ n =\n        ∑ k : s.sym n,\n          k.1.1.multinomial *\n            (k.1.1.map <| x).noncommProd\n              (Multiset.map_set_pairwise <| hc.mono <| mem_sym_iff.1 k.2) := by\n  induction' s using Finset.induction with a s ha ih\n  · rw [sum_empty]\n    rintro (_ | n)\n      -- Porting note: Lean cannot infer this instance by itself\n    · haveI : Subsingleton (Sym α 0) := Unique.instSubsingleton\n      rw [_root_.pow_zero, Fintype.sum_subsingleton]\n      swap\n        -- Porting note: Lean cannot infer this instance by itself\n      · have : Zero (Sym α 0) := Sym.instZeroSym\n        exact ⟨0, by simp [eq_iff_true_of_subsingleton]⟩\n      convert (@one_mul R _ _).symm\n      convert @Nat.cast_one R _\n      simp\n    · rw [_root_.pow_succ, mul_zero]\n      -- Porting note: Lean cannot infer this instance by itself\n      haveI : IsEmpty (Finset.sym (∅ : Finset α) n.succ) := Finset.instIsEmpty\n      apply (Fintype.sum_empty _).symm\n  intro n; specialize ih (hc.mono <| s.subset_insert a)\n  rw [sum_insert ha, (Commute.sum_right s _ _ _).add_pow, sum_range]; swap\n  · exact fun _ hb => hc (mem_insert_self a s) (mem_insert_of_mem hb)\n      (ne_of_mem_of_not_mem hb ha).symm\n  · simp_rw [ih, mul_sum, sum_mul, sum_sigma', univ_sigma_univ]\n    refine (Fintype.sum_equiv (symInsertEquiv ha) _ _ fun m => ?_).symm\n    rw [m.1.1.multinomial_filter_ne a]\n    conv in m.1.1.map _ => rw [← m.1.1.filter_add_not (a = ·), Multiset.map_add]\n    simp_rw [Multiset.noncommProd_add, m.1.1.filter_eq, Multiset.map_replicate, m.1.2]\n    rw [Multiset.noncommProd_eq_pow_card _ _ _ fun _ => Multiset.eq_of_mem_replicate]\n    rw [Multiset.card_replicate, Nat.cast_mul, mul_assoc, Nat.cast_comm]\n    congr 1; simp_rw [← mul_assoc, Nat.cast_comm]; rfl\n\n"}
{"name":"Finset.sum_pow_eq_sum_piAntidiag","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : CommSemiring R\ns : Finset α\nf : α → R\nn : Nat\n⊢ Eq (HPow.hPow (s.sum fun i => f i) n) ((s.piAntidiag n).sum fun k => HMul.hMul (↑(Nat.multinomial s k)) (s.prod fun i => HPow.hPow (f i) (k i)))","decl":"lemma sum_pow_eq_sum_piAntidiag (s : Finset α) (f : α → R) (n : ℕ) :\n    (∑ i ∈ s, f i) ^ n = ∑ k ∈ piAntidiag s n, multinomial s k * ∏ i ∈ s, f i ^ k i := by\n  simp_rw [← noncommProd_eq_prod]\n  rw [← sum_pow_eq_sum_piAntidiag_of_commute _ _ fun _ _ _ _ _ ↦ Commute.all ..]\n\n"}
{"name":"Finset.sum_pow","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : CommSemiring R\ns : Finset α\nx : α → R\nn : Nat\n⊢ Eq (HPow.hPow (s.sum x) n) ((s.sym n).sum fun k => HMul.hMul (↑(↑k).multinomial) (Multiset.map x ↑k).prod)","decl":"theorem sum_pow (x : α → R) (n : ℕ) :\n    s.sum x ^ n = ∑ k ∈ s.sym n, k.val.multinomial * (k.val.map x).prod := by\n  conv_rhs => rw [← sum_coe_sort]\n  convert sum_pow_of_commute x s (fun _ _ _ _ _ ↦ Commute.all ..) n\n  rw [Multiset.noncommProd_eq_prod]\n\n"}
{"name":"Nat.multinomial_two_mul_le_mul_multinomial","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → Nat\n⊢ LE.le (Nat.multinomial s fun i => HMul.hMul 2 (f i)) (HMul.hMul (HPow.hPow (s.sum fun i => f i) (s.sum fun i => f i)) (Nat.multinomial s f))","decl":"lemma multinomial_two_mul_le_mul_multinomial :\n    multinomial s (fun i ↦ 2 * f i) ≤ ((∑ i ∈ s, f i) ^ ∑ i ∈ s, f i) * multinomial s f := by\n  rw [multinomial, multinomial, ← mul_sum,\n    ← Nat.mul_div_assoc _ (prod_factorial_dvd_factorial_sum ..)]\n  refine Nat.div_le_div_of_mul_le_mul (by positivity)\n    ((prod_factorial_dvd_factorial_sum ..).trans (Nat.dvd_mul_left ..)) ?_\n  calc\n    (2 * ∑ i ∈ s, f i)! * ∏ i ∈ s, (f i)!\n      ≤ ((2 * ∑ i ∈ s, f i) ^ (∑ i ∈ s, f i) * (∑ i ∈ s, f i)!) * ∏ i ∈ s, (f i)! := by\n      gcongr; exact Nat.factorial_two_mul_le _\n    _ = ((∑ i ∈ s, f i) ^ ∑ i ∈ s, f i) * (∑ i ∈ s, f i)! * ∏ i ∈ s, 2 ^ f i * (f i)! := by\n      rw [mul_pow, ← prod_pow_eq_pow_sum, prod_mul_distrib]; ring\n    _ ≤ ((∑ i ∈ s, f i) ^ ∑ i ∈ s, f i) * (∑ i ∈ s, f i)! * ∏ i ∈ s, (2 * f i)! := by\n      gcongr\n      rw [← doubleFactorial_two_mul]\n      exact doubleFactorial_le_factorial _\n\n"}
{"name":"Sym.multinomial_coe_fill_of_not_mem","module":"Mathlib.Data.Nat.Choose.Multinomial","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : DecidableEq α\nm : Fin (HAdd.hAdd n 1)\ns : Sym α (HSub.hSub n ↑m)\nx : α\nhx : Not (Membership.mem s x)\n⊢ Eq (↑(Sym.fill x m s)).multinomial (HMul.hMul (n.choose ↑m) (↑s).multinomial)","decl":"theorem multinomial_coe_fill_of_not_mem {m : Fin (n + 1)} {s : Sym α (n - m)} {x : α} (hx : x ∉ s) :\n    (fill x m s : Multiset α).multinomial = n.choose m * (s : Multiset α).multinomial := by\n  rw [Multiset.multinomial_filter_ne x]\n  rw [← mem_coe] at hx\n  refine congrArg₂ _ ?_ ?_\n  · rw [card_coe, count_coe_fill_self_of_not_mem hx]\n  · refine congrArg _ ?_\n    rw [coe_fill, coe_replicate, Multiset.filter_add]\n    rw [Multiset.filter_eq_self.mpr]\n    · rw [add_right_eq_self]\n      rw [Multiset.filter_eq_nil]\n      exact fun j hj ↦ by simp [Multiset.mem_replicate.mp hj]\n    · exact fun j hj h ↦ hx <| by simpa [h] using hj\n\n"}
