{"name":"isUnit_iff_not_dvd_char_of_ringChar_ne_zero","module":"Mathlib.Algebra.CharP.CharAndCard","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\np : Nat\ninst✝ : Fact (Nat.Prime p)\nhR : Ne (ringChar R) 0\n⊢ Iff (IsUnit ↑p) (Not (Dvd.dvd p (ringChar R)))","decl":"/-- A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\nthe characteristic. -/\ntheorem isUnit_iff_not_dvd_char_of_ringChar_ne_zero (R : Type*) [CommRing R] (p : ℕ) [Fact p.Prime]\n    (hR : ringChar R ≠ 0) : IsUnit (p : R) ↔ ¬p ∣ ringChar R := by\n  have hch := CharP.cast_eq_zero R (ringChar R)\n  have hp : p.Prime := Fact.out\n  constructor\n  · rintro h₁ ⟨q, hq⟩\n    rcases IsUnit.exists_left_inv h₁ with ⟨a, ha⟩\n    have h₃ : ¬ringChar R ∣ q := by\n      rintro ⟨r, hr⟩\n      rw [hr, ← mul_assoc, mul_comm p, mul_assoc] at hq\n      nth_rw 1 [← mul_one (ringChar R)] at hq\n      exact Nat.Prime.not_dvd_one hp ⟨r, mul_left_cancel₀ hR hq⟩\n    have h₄ := mt (CharP.intCast_eq_zero_iff R (ringChar R) q).mp\n    apply_fun ((↑) : ℕ → R) at hq\n    apply_fun (· * ·) a at hq\n    rw [Nat.cast_mul, hch, mul_zero, ← mul_assoc, ha, one_mul] at hq\n    norm_cast at h₄\n    exact h₄ h₃ hq.symm\n  · intro h\n    rcases (hp.coprime_iff_not_dvd.mpr h).isCoprime with ⟨a, b, hab⟩\n    apply_fun ((↑) : ℤ → R) at hab\n    push_cast at hab\n    rw [hch, mul_zero, add_zero, mul_comm] at hab\n    exact isUnit_of_mul_eq_one (p : R) a hab\n\n"}
{"name":"isUnit_iff_not_dvd_char","module":"Mathlib.Algebra.CharP.CharAndCard","initialProofState":"R : Type u_1\ninst✝² : CommRing R\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite R\n⊢ Iff (IsUnit ↑p) (Not (Dvd.dvd p (ringChar R)))","decl":"/-- A prime `p` is a unit in a finite commutative ring `R`\niff it does not divide the characteristic. -/\ntheorem isUnit_iff_not_dvd_char (R : Type*) [CommRing R] (p : ℕ) [Fact p.Prime] [Finite R] :\n    IsUnit (p : R) ↔ ¬p ∣ ringChar R :=\n  isUnit_iff_not_dvd_char_of_ringChar_ne_zero R p <| CharP.char_ne_zero_of_finite R (ringChar R)\n\n"}
{"name":"prime_dvd_char_iff_dvd_card","module":"Mathlib.Algebra.CharP.CharAndCard","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : Fintype R\np : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Iff (Dvd.dvd p (ringChar R)) (Dvd.dvd p (Fintype.card R))","decl":"/-- The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. -/\ntheorem prime_dvd_char_iff_dvd_card {R : Type*} [CommRing R] [Fintype R] (p : ℕ) [Fact p.Prime] :\n    p ∣ ringChar R ↔ p ∣ Fintype.card R := by\n  refine\n    ⟨fun h =>\n      h.trans <|\n        Int.natCast_dvd_natCast.mp <|\n          (CharP.intCast_eq_zero_iff R (ringChar R) (Fintype.card R)).mp <|\n            mod_cast Nat.cast_card_eq_zero R,\n      fun h => ?_⟩\n  by_contra h₀\n  rcases exists_prime_addOrderOf_dvd_card p h with ⟨r, hr⟩\n  have hr₁ := addOrderOf_nsmul_eq_zero r\n  rw [hr, nsmul_eq_mul] at hr₁\n  rcases IsUnit.exists_left_inv ((isUnit_iff_not_dvd_char R p).mpr h₀) with ⟨u, hu⟩\n  apply_fun (· * ·) u at hr₁\n  rw [mul_zero, ← mul_assoc, hu, one_mul] at hr₁\n  exact mt AddMonoid.addOrderOf_eq_one_iff.mpr (ne_of_eq_of_ne hr (Nat.Prime.ne_one Fact.out)) hr₁\n\n"}
{"name":"not_isUnit_prime_of_dvd_card","module":"Mathlib.Algebra.CharP.CharAndCard","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : Fintype R\np : Nat\ninst✝ : Fact (Nat.Prime p)\nhp : Dvd.dvd p (Fintype.card R)\n⊢ Not (IsUnit ↑p)","decl":"/-- A prime that divides the cardinality of a finite commutative ring `R`\nisn't a unit in `R`. -/\ntheorem not_isUnit_prime_of_dvd_card {R : Type*} [CommRing R] [Fintype R] (p : ℕ) [Fact p.Prime]\n    (hp : p ∣ Fintype.card R) : ¬IsUnit (p : R) :=\n  mt (isUnit_iff_not_dvd_char R p).mp\n    (Classical.not_not.mpr ((prime_dvd_char_iff_dvd_card p).mpr hp))\n\n"}
{"name":"charP_of_card_eq_prime","module":"Mathlib.Algebra.CharP.CharAndCard","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocRing R\ninst✝ : Fintype R\np : Nat\nhp : Fact (Nat.Prime p)\nhR : Eq (Fintype.card R) p\n⊢ CharP R p","decl":"lemma charP_of_card_eq_prime {R : Type*} [NonAssocRing R] [Fintype R] (p : ℕ) [hp : Fact p.Prime]\n    (hR : Fintype.card R = p) : CharP R p :=\n  have := Fintype.one_lt_card_iff_nontrivial.1 (hR ▸ hp.1.one_lt)\n  (CharP.charP_iff_prime_eq_zero hp.1).2 (hR ▸ Nat.cast_card_eq_zero R)\n"}
