{"name":"ContractingWith.toLipschitzWith","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\n‚ä¢ LipschitzWith K f","decl":"theorem toLipschitzWith (hf : ContractingWith K f) : LipschitzWith K f := hf.2\n\n"}
{"name":"ContractingWith.one_sub_K_pos'","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\n‚ä¢ LT.lt 0 (HSub.hSub 1 ‚ÜëK)","decl":"theorem one_sub_K_pos' (hf : ContractingWith K f) : (0 : ‚Ñù‚â•0‚àû) < 1 - K := by simp [hf.1]\n\n"}
{"name":"ContractingWith.one_sub_K_ne_zero","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\n‚ä¢ Ne (HSub.hSub 1 ‚ÜëK) 0","decl":"theorem one_sub_K_ne_zero (hf : ContractingWith K f) : (1 : ‚Ñù‚â•0‚àû) - K ‚â† 0 :=\n  ne_of_gt hf.one_sub_K_pos'\n\n"}
{"name":"ContractingWith.one_sub_K_ne_top","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"K : NNReal\n‚ä¢ Ne (HSub.hSub 1 ‚ÜëK) Top.top","decl":"theorem one_sub_K_ne_top : (1 : ‚Ñù‚â•0‚àû) - K ‚â† ‚àû := by\n  norm_cast\n  exact ENNReal.coe_ne_top\n\n"}
{"name":"ContractingWith.edist_inequality","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\nx y : Œ±\nh : Ne (EDist.edist x y) Top.top\n‚ä¢ LE.le (EDist.edist x y) (HDiv.hDiv (HAdd.hAdd (EDist.edist x (f x)) (EDist.edist y (f y))) (HSub.hSub 1 ‚ÜëK))","decl":"theorem edist_inequality (hf : ContractingWith K f) {x y} (h : edist x y ‚â† ‚àû) :\n    edist x y ‚â§ (edist x (f x) + edist y (f y)) / (1 - K) :=\n  suffices edist x y ‚â§ edist x (f x) + edist y (f y) + K * edist x y by\n    rwa [ENNReal.le_div_iff_mul_le (Or.inl hf.one_sub_K_ne_zero) (Or.inl one_sub_K_ne_top),\n      mul_comm, ENNReal.sub_mul fun _ _ ‚Ü¶ h, one_mul, tsub_le_iff_right]\n  calc\n    edist x y ‚â§ edist x (f x) + edist (f x) (f y) + edist (f y) y := edist_triangle4 _ _ _ _\n    _ = edist x (f x) + edist y (f y) + edist (f x) (f y) := by rw [edist_comm y, add_right_comm]\n    _ ‚â§ edist x (f x) + edist y (f y) + K * edist x y := add_le_add le_rfl (hf.2 _ _)\n\n"}
{"name":"ContractingWith.edist_le_of_fixedPoint","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\nx y : Œ±\nh : Ne (EDist.edist x y) Top.top\nhy : Function.IsFixedPt f y\n‚ä¢ LE.le (EDist.edist x y) (HDiv.hDiv (EDist.edist x (f x)) (HSub.hSub 1 ‚ÜëK))","decl":"theorem edist_le_of_fixedPoint (hf : ContractingWith K f) {x y} (h : edist x y ‚â† ‚àû)\n    (hy : IsFixedPt f y) : edist x y ‚â§ edist x (f x) / (1 - K) := by\n  simpa only [hy.eq, edist_self, add_zero] using hf.edist_inequality h\n\n"}
{"name":"ContractingWith.eq_or_edist_eq_top_of_fixedPoints","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\nx y : Œ±\nhx : Function.IsFixedPt f x\nhy : Function.IsFixedPt f y\n‚ä¢ Or (Eq x y) (Eq (EDist.edist x y) Top.top)","decl":"theorem eq_or_edist_eq_top_of_fixedPoints (hf : ContractingWith K f) {x y} (hx : IsFixedPt f x)\n    (hy : IsFixedPt f y) : x = y ‚à® edist x y = ‚àû := by\n  refine or_iff_not_imp_right.2 fun h ‚Ü¶ edist_le_zero.1 ?_\n  simpa only [hx.eq, edist_self, add_zero, ENNReal.zero_div] using hf.edist_le_of_fixedPoint h hy\n\n"}
{"name":"ContractingWith.restrict","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\ns : Set Œ±\nhs : Set.MapsTo f s s\n‚ä¢ ContractingWith K (Set.MapsTo.restrict f s s hs)","decl":"/-- If a map `f` is `ContractingWith K`, and `s` is a forward-invariant set, then\nrestriction of `f` to `s` is `ContractingWith K` as well. -/\ntheorem restrict (hf : ContractingWith K f) {s : Set Œ±} (hs : MapsTo f s s) :\n    ContractingWith K (hs.restrict f s s) :=\n  ‚ü®hf.1, fun x y ‚Ü¶ hf.2 x y‚ü©\n\n"}
{"name":"ContractingWith.exists_fixedPoint","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ninst‚úù : CompleteSpace Œ±\nhf : ContractingWith K f\nx : Œ±\nhx : Ne (EDist.edist x (f x)) Top.top\n‚ä¢ Exists fun y => And (Function.IsFixedPt f y) (And (Filter.Tendsto (fun n => Nat.iterate f n x) Filter.atTop (nhds y)) (‚àÄ (n : Nat), LE.le (EDist.edist (Nat.iterate f n x) y) (HDiv.hDiv (HMul.hMul (EDist.edist x (f x)) (HPow.hPow (‚ÜëK) n)) (HSub.hSub 1 ‚ÜëK))))","decl":"/-- Banach fixed-point theorem, contraction mapping theorem, `EMetricSpace` version.\nA contracting map on a complete metric space has a fixed point.\nWe include more conclusions in this theorem to avoid proving them again later.\n\nThe main API for this theorem are the functions `efixedPoint` and `fixedPoint`,\nand lemmas about these functions. -/\ntheorem exists_fixedPoint (hf : ContractingWith K f) (x : Œ±) (hx : edist x (f x) ‚â† ‚àû) :\n    ‚àÉ y, IsFixedPt f y ‚àß Tendsto (fun n ‚Ü¶ f^[n] x) atTop (ùìù y) ‚àß\n      ‚àÄ n : ‚Ñï, edist (f^[n] x) y ‚â§ edist x (f x) * (K : ‚Ñù‚â•0‚àû) ^ n / (1 - K) :=\n  have : CauchySeq fun n ‚Ü¶ f^[n] x :=\n    cauchySeq_of_edist_le_geometric K (edist x (f x)) (ENNReal.coe_lt_one_iff.2 hf.1) hx\n      (hf.toLipschitzWith.edist_iterate_succ_le_geometric x)\n  let ‚ü®y, hy‚ü© := cauchySeq_tendsto_of_complete this\n  ‚ü®y, isFixedPt_of_tendsto_iterate hy hf.2.continuous.continuousAt, hy,\n    edist_le_of_edist_le_geometric_of_tendsto K (edist x (f x))\n      (hf.toLipschitzWith.edist_iterate_succ_le_geometric x) hy‚ü©\n\n"}
{"name":"ContractingWith.efixedPoint_isFixedPt","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ninst‚úù : CompleteSpace Œ±\nhf : ContractingWith K f\nx : Œ±\nhx : Ne (EDist.edist x (f x)) Top.top\n‚ä¢ Function.IsFixedPt f (ContractingWith.efixedPoint f hf x hx)","decl":"theorem efixedPoint_isFixedPt (hf : ContractingWith K f) {x : Œ±} (hx : edist x (f x) ‚â† ‚àû) :\n    IsFixedPt f (efixedPoint f hf x hx) :=\n  (Classical.choose_spec <| hf.exists_fixedPoint x hx).1\n\n"}
{"name":"ContractingWith.tendsto_iterate_efixedPoint","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ninst‚úù : CompleteSpace Œ±\nhf : ContractingWith K f\nx : Œ±\nhx : Ne (EDist.edist x (f x)) Top.top\n‚ä¢ Filter.Tendsto (fun n => Nat.iterate f n x) Filter.atTop (nhds (ContractingWith.efixedPoint f hf x hx))","decl":"theorem tendsto_iterate_efixedPoint (hf : ContractingWith K f) {x : Œ±} (hx : edist x (f x) ‚â† ‚àû) :\n    Tendsto (fun n ‚Ü¶ f^[n] x) atTop (ùìù <| efixedPoint f hf x hx) :=\n  (Classical.choose_spec <| hf.exists_fixedPoint x hx).2.1\n\n"}
{"name":"ContractingWith.apriori_edist_iterate_efixedPoint_le","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ninst‚úù : CompleteSpace Œ±\nhf : ContractingWith K f\nx : Œ±\nhx : Ne (EDist.edist x (f x)) Top.top\nn : Nat\n‚ä¢ LE.le (EDist.edist (Nat.iterate f n x) (ContractingWith.efixedPoint f hf x hx)) (HDiv.hDiv (HMul.hMul (EDist.edist x (f x)) (HPow.hPow (‚ÜëK) n)) (HSub.hSub 1 ‚ÜëK))","decl":"theorem apriori_edist_iterate_efixedPoint_le (hf : ContractingWith K f) {x : Œ±}\n    (hx : edist x (f x) ‚â† ‚àû) (n : ‚Ñï) :\n    edist (f^[n] x) (efixedPoint f hf x hx) ‚â§ edist x (f x) * (K : ‚Ñù‚â•0‚àû) ^ n / (1 - K) :=\n  (Classical.choose_spec <| hf.exists_fixedPoint x hx).2.2 n\n\n"}
{"name":"ContractingWith.edist_efixedPoint_le","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ninst‚úù : CompleteSpace Œ±\nhf : ContractingWith K f\nx : Œ±\nhx : Ne (EDist.edist x (f x)) Top.top\n‚ä¢ LE.le (EDist.edist x (ContractingWith.efixedPoint f hf x hx)) (HDiv.hDiv (EDist.edist x (f x)) (HSub.hSub 1 ‚ÜëK))","decl":"theorem edist_efixedPoint_le (hf : ContractingWith K f) {x : Œ±} (hx : edist x (f x) ‚â† ‚àû) :\n    edist x (efixedPoint f hf x hx) ‚â§ edist x (f x) / (1 - K) := by\n  convert hf.apriori_edist_iterate_efixedPoint_le hx 0\n  simp only [pow_zero, mul_one]\n\n"}
{"name":"ContractingWith.edist_efixedPoint_lt_top","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ninst‚úù : CompleteSpace Œ±\nhf : ContractingWith K f\nx : Œ±\nhx : Ne (EDist.edist x (f x)) Top.top\n‚ä¢ LT.lt (EDist.edist x (ContractingWith.efixedPoint f hf x hx)) Top.top","decl":"theorem edist_efixedPoint_lt_top (hf : ContractingWith K f) {x : Œ±} (hx : edist x (f x) ‚â† ‚àû) :\n    edist x (efixedPoint f hf x hx) < ‚àû :=\n  (hf.edist_efixedPoint_le hx).trans_lt\n    (ENNReal.mul_ne_top hx <| ENNReal.inv_ne_top.2 hf.one_sub_K_ne_zero).lt_top\n\n"}
{"name":"ContractingWith.efixedPoint_eq_of_edist_lt_top","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ninst‚úù : CompleteSpace Œ±\nhf : ContractingWith K f\nx : Œ±\nhx : Ne (EDist.edist x (f x)) Top.top\ny : Œ±\nhy : Ne (EDist.edist y (f y)) Top.top\nh : Ne (EDist.edist x y) Top.top\n‚ä¢ Eq (ContractingWith.efixedPoint f hf x hx) (ContractingWith.efixedPoint f hf y hy)","decl":"theorem efixedPoint_eq_of_edist_lt_top (hf : ContractingWith K f) {x : Œ±} (hx : edist x (f x) ‚â† ‚àû)\n    {y : Œ±} (hy : edist y (f y) ‚â† ‚àû) (h : edist x y ‚â† ‚àû) :\n    efixedPoint f hf x hx = efixedPoint f hf y hy := by\n  refine (hf.eq_or_edist_eq_top_of_fixedPoints ?_ ?_).elim id fun h' ‚Ü¶ False.elim (ne_of_lt ?_ h')\n    <;> try apply efixedPoint_isFixedPt\n  change edistLtTopSetoid _ _\n  trans x\n  ¬∑ apply Setoid.symm' -- Porting note: Originally `symm`\n    exact hf.edist_efixedPoint_lt_top hx\n  trans y\n  exacts [lt_top_iff_ne_top.2 h, hf.edist_efixedPoint_lt_top hy]\n\n"}
{"name":"ContractingWith.exists_fixedPoint'","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ns : Set Œ±\nhsc : IsComplete s\nhsf : Set.MapsTo f s s\nhf : ContractingWith K (Set.MapsTo.restrict f s s hsf)\nx : Œ±\nhxs : Membership.mem s x\nhx : Ne (EDist.edist x (f x)) Top.top\n‚ä¢ Exists fun y => And (Membership.mem s y) (And (Function.IsFixedPt f y) (And (Filter.Tendsto (fun n => Nat.iterate f n x) Filter.atTop (nhds y)) (‚àÄ (n : Nat), LE.le (EDist.edist (Nat.iterate f n x) y) (HDiv.hDiv (HMul.hMul (EDist.edist x (f x)) (HPow.hPow (‚ÜëK) n)) (HSub.hSub 1 ‚ÜëK)))))","decl":"/-- Banach fixed-point theorem for maps contracting on a complete subset. -/\ntheorem exists_fixedPoint' {s : Set Œ±} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : Œ±} (hxs : x ‚àà s) (hx : edist x (f x) ‚â† ‚àû) :\n    ‚àÉ y ‚àà s, IsFixedPt f y ‚àß Tendsto (fun n ‚Ü¶ f^[n] x) atTop (ùìù y) ‚àß\n      ‚àÄ n : ‚Ñï, edist (f^[n] x) y ‚â§ edist x (f x) * (K : ‚Ñù‚â•0‚àû) ^ n / (1 - K) := by\n  haveI := hsc.completeSpace_coe\n  rcases hf.exists_fixedPoint ‚ü®x, hxs‚ü© hx with ‚ü®y, hfy, h_tendsto, hle‚ü©\n  refine ‚ü®y, y.2, Subtype.ext_iff_val.1 hfy, ?_, fun n ‚Ü¶ ?_‚ü©\n  ¬∑ convert (continuous_subtype_val.tendsto _).comp h_tendsto\n    simp only [(¬∑ ‚àò ¬∑), MapsTo.iterate_restrict, MapsTo.val_restrict_apply]\n  ¬∑ convert hle n\n    rw [MapsTo.iterate_restrict]\n    rfl\n\n"}
{"name":"ContractingWith.efixedPoint_mem'","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ns : Set Œ±\nhsc : IsComplete s\nhsf : Set.MapsTo f s s\nhf : ContractingWith K (Set.MapsTo.restrict f s s hsf)\nx : Œ±\nhxs : Membership.mem s x\nhx : Ne (EDist.edist x (f x)) Top.top\n‚ä¢ Membership.mem s (ContractingWith.efixedPoint' f hsc hsf hf x hxs hx)","decl":"theorem efixedPoint_mem' {s : Set Œ±} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : Œ±} (hxs : x ‚àà s) (hx : edist x (f x) ‚â† ‚àû) :\n    efixedPoint' f hsc hsf hf x hxs hx ‚àà s :=\n  (Classical.choose_spec <| hf.exists_fixedPoint' hsc hsf hxs hx).1\n\n"}
{"name":"ContractingWith.efixedPoint_isFixedPt'","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ns : Set Œ±\nhsc : IsComplete s\nhsf : Set.MapsTo f s s\nhf : ContractingWith K (Set.MapsTo.restrict f s s hsf)\nx : Œ±\nhxs : Membership.mem s x\nhx : Ne (EDist.edist x (f x)) Top.top\n‚ä¢ Function.IsFixedPt f (ContractingWith.efixedPoint' f hsc hsf hf x hxs hx)","decl":"theorem efixedPoint_isFixedPt' {s : Set Œ±} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : Œ±} (hxs : x ‚àà s) (hx : edist x (f x) ‚â† ‚àû) :\n    IsFixedPt f (efixedPoint' f hsc hsf hf x hxs hx) :=\n  (Classical.choose_spec <| hf.exists_fixedPoint' hsc hsf hxs hx).2.1\n\n"}
{"name":"ContractingWith.tendsto_iterate_efixedPoint'","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ns : Set Œ±\nhsc : IsComplete s\nhsf : Set.MapsTo f s s\nhf : ContractingWith K (Set.MapsTo.restrict f s s hsf)\nx : Œ±\nhxs : Membership.mem s x\nhx : Ne (EDist.edist x (f x)) Top.top\n‚ä¢ Filter.Tendsto (fun n => Nat.iterate f n x) Filter.atTop (nhds (ContractingWith.efixedPoint' f hsc hsf hf x hxs hx))","decl":"theorem tendsto_iterate_efixedPoint' {s : Set Œ±} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : Œ±} (hxs : x ‚àà s) (hx : edist x (f x) ‚â† ‚àû) :\n    Tendsto (fun n ‚Ü¶ f^[n] x) atTop (ùìù <| efixedPoint' f hsc hsf hf x hxs hx) :=\n  (Classical.choose_spec <| hf.exists_fixedPoint' hsc hsf hxs hx).2.2.1\n\n"}
{"name":"ContractingWith.apriori_edist_iterate_efixedPoint_le'","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ns : Set Œ±\nhsc : IsComplete s\nhsf : Set.MapsTo f s s\nhf : ContractingWith K (Set.MapsTo.restrict f s s hsf)\nx : Œ±\nhxs : Membership.mem s x\nhx : Ne (EDist.edist x (f x)) Top.top\nn : Nat\n‚ä¢ LE.le (EDist.edist (Nat.iterate f n x) (ContractingWith.efixedPoint' f hsc hsf hf x hxs hx)) (HDiv.hDiv (HMul.hMul (EDist.edist x (f x)) (HPow.hPow (‚ÜëK) n)) (HSub.hSub 1 ‚ÜëK))","decl":"theorem apriori_edist_iterate_efixedPoint_le' {s : Set Œ±} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : Œ±} (hxs : x ‚àà s) (hx : edist x (f x) ‚â† ‚àû)\n    (n : ‚Ñï) :\n    edist (f^[n] x) (efixedPoint' f hsc hsf hf x hxs hx) ‚â§\n      edist x (f x) * (K : ‚Ñù‚â•0‚àû) ^ n / (1 - K) :=\n  (Classical.choose_spec <| hf.exists_fixedPoint' hsc hsf hxs hx).2.2.2 n\n\n"}
{"name":"ContractingWith.edist_efixedPoint_le'","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ns : Set Œ±\nhsc : IsComplete s\nhsf : Set.MapsTo f s s\nhf : ContractingWith K (Set.MapsTo.restrict f s s hsf)\nx : Œ±\nhxs : Membership.mem s x\nhx : Ne (EDist.edist x (f x)) Top.top\n‚ä¢ LE.le (EDist.edist x (ContractingWith.efixedPoint' f hsc hsf hf x hxs hx)) (HDiv.hDiv (EDist.edist x (f x)) (HSub.hSub 1 ‚ÜëK))","decl":"theorem edist_efixedPoint_le' {s : Set Œ±} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : Œ±} (hxs : x ‚àà s) (hx : edist x (f x) ‚â† ‚àû) :\n    edist x (efixedPoint' f hsc hsf hf x hxs hx) ‚â§ edist x (f x) / (1 - K) := by\n  convert hf.apriori_edist_iterate_efixedPoint_le' hsc hsf hxs hx 0\n  rw [pow_zero, mul_one]\n\n"}
{"name":"ContractingWith.edist_efixedPoint_lt_top'","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ns : Set Œ±\nhsc : IsComplete s\nhsf : Set.MapsTo f s s\nhf : ContractingWith K (Set.MapsTo.restrict f s s hsf)\nx : Œ±\nhxs : Membership.mem s x\nhx : Ne (EDist.edist x (f x)) Top.top\n‚ä¢ LT.lt (EDist.edist x (ContractingWith.efixedPoint' f hsc hsf hf x hxs hx)) Top.top","decl":"theorem edist_efixedPoint_lt_top' {s : Set Œ±} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : Œ±} (hxs : x ‚àà s) (hx : edist x (f x) ‚â† ‚àû) :\n    edist x (efixedPoint' f hsc hsf hf x hxs hx) < ‚àû :=\n  (hf.edist_efixedPoint_le' hsc hsf hxs hx).trans_lt\n    (ENNReal.mul_ne_top hx <| ENNReal.inv_ne_top.2 hf.one_sub_K_ne_zero).lt_top\n\n"}
{"name":"ContractingWith.efixedPoint_eq_of_edist_lt_top'","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : EMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\ns : Set Œ±\nhsc : IsComplete s\nhsf : Set.MapsTo f s s\nhfs : ContractingWith K (Set.MapsTo.restrict f s s hsf)\nx : Œ±\nhxs : Membership.mem s x\nhx : Ne (EDist.edist x (f x)) Top.top\nt : Set Œ±\nhtc : IsComplete t\nhtf : Set.MapsTo f t t\nhft : ContractingWith K (Set.MapsTo.restrict f t t htf)\ny : Œ±\nhyt : Membership.mem t y\nhy : Ne (EDist.edist y (f y)) Top.top\nhxy : Ne (EDist.edist x y) Top.top\n‚ä¢ Eq (ContractingWith.efixedPoint' f hsc hsf hfs x hxs hx) (ContractingWith.efixedPoint' f htc htf hft y hyt hy)","decl":"/-- If a globally contracting map `f` has two complete forward-invariant sets `s`, `t`,\nand `x ‚àà s` is at a finite distance from `y ‚àà t`, then the `efixedPoint'` constructed by `x`\nis the same as the `efixedPoint'` constructed by `y`.\n\nThis lemma takes additional arguments stating that `f` contracts on `s` and `t` because this way\nit can be used to prove the desired equality with non-trivial proofs of these facts. -/\ntheorem efixedPoint_eq_of_edist_lt_top' (hf : ContractingWith K f) {s : Set Œ±} (hsc : IsComplete s)\n    (hsf : MapsTo f s s) (hfs : ContractingWith K <| hsf.restrict f s s) {x : Œ±} (hxs : x ‚àà s)\n    (hx : edist x (f x) ‚â† ‚àû) {t : Set Œ±} (htc : IsComplete t) (htf : MapsTo f t t)\n    (hft : ContractingWith K <| htf.restrict f t t) {y : Œ±} (hyt : y ‚àà t) (hy : edist y (f y) ‚â† ‚àû)\n    (hxy : edist x y ‚â† ‚àû) :\n    efixedPoint' f hsc hsf hfs x hxs hx = efixedPoint' f htc htf hft y hyt hy := by\n  refine (hf.eq_or_edist_eq_top_of_fixedPoints ?_ ?_).elim id fun h' ‚Ü¶ False.elim (ne_of_lt ?_ h')\n    <;> try apply efixedPoint_isFixedPt'\n  change edistLtTopSetoid _ _\n  trans x\n  ¬∑ apply Setoid.symm' -- Porting note: Originally `symm`\n    apply edist_efixedPoint_lt_top'\n  trans y\n  ¬∑ exact lt_top_iff_ne_top.2 hxy\n  ¬∑ apply edist_efixedPoint_lt_top'\n\n"}
{"name":"ContractingWith.one_sub_K_pos","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\n‚ä¢ LT.lt 0 (HSub.hSub 1 ‚ÜëK)","decl":"theorem one_sub_K_pos (hf : ContractingWith K f) : (0 : ‚Ñù) < 1 - K :=\n  sub_pos.2 hf.1\n\n"}
{"name":"ContractingWith.dist_le_mul","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\nx y : Œ±\n‚ä¢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul (‚ÜëK) (Dist.dist x y))","decl":"theorem dist_le_mul (x y : Œ±) : dist (f x) (f y) ‚â§ K * dist x y :=\n  hf.toLipschitzWith.dist_le_mul x y\n\n"}
{"name":"ContractingWith.dist_inequality","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\nx y : Œ±\n‚ä¢ LE.le (Dist.dist x y) (HDiv.hDiv (HAdd.hAdd (Dist.dist x (f x)) (Dist.dist y (f y))) (HSub.hSub 1 ‚ÜëK))","decl":"theorem dist_inequality (x y) : dist x y ‚â§ (dist x (f x) + dist y (f y)) / (1 - K) :=\n  suffices dist x y ‚â§ dist x (f x) + dist y (f y) + K * dist x y by\n    rwa [le_div_iff‚ÇÄ hf.one_sub_K_pos, mul_comm, _root_.sub_mul, one_mul, sub_le_iff_le_add]\n  calc\n    dist x y ‚â§ dist x (f x) + dist y (f y) + dist (f x) (f y) := dist_triangle4_right _ _ _ _\n    _ ‚â§ dist x (f x) + dist y (f y) + K * dist x y := add_le_add_left (hf.dist_le_mul _ _) _\n\n"}
{"name":"ContractingWith.dist_le_of_fixedPoint","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\nx y : Œ±\nhy : Function.IsFixedPt f y\n‚ä¢ LE.le (Dist.dist x y) (HDiv.hDiv (Dist.dist x (f x)) (HSub.hSub 1 ‚ÜëK))","decl":"theorem dist_le_of_fixedPoint (x) {y} (hy : IsFixedPt f y) : dist x y ‚â§ dist x (f x) / (1 - K) := by\n  simpa only [hy.eq, dist_self, add_zero] using hf.dist_inequality x y\n\n"}
{"name":"ContractingWith.fixedPoint_unique'","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\nx y : Œ±\nhx : Function.IsFixedPt f x\nhy : Function.IsFixedPt f y\n‚ä¢ Eq x y","decl":"theorem fixedPoint_unique' {x y} (hx : IsFixedPt f x) (hy : IsFixedPt f y) : x = y :=\n  (hf.eq_or_edist_eq_top_of_fixedPoints hx hy).resolve_right (edist_ne_top _ _)\n\n"}
{"name":"ContractingWith.dist_fixedPoint_fixedPoint_of_dist_le'","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\ng : Œ± ‚Üí Œ±\nx y : Œ±\nhx : Function.IsFixedPt f x\nhy : Function.IsFixedPt g y\nC : Real\nhfg : ‚àÄ (z : Œ±), LE.le (Dist.dist (f z) (g z)) C\n‚ä¢ LE.le (Dist.dist x y) (HDiv.hDiv C (HSub.hSub 1 ‚ÜëK))","decl":"/-- Let `f` be a contracting map with constant `K`; let `g` be another map uniformly\n`C`-close to `f`. If `x` and `y` are their fixed points, then `dist x y ‚â§ C / (1 - K)`. -/\ntheorem dist_fixedPoint_fixedPoint_of_dist_le' (g : Œ± ‚Üí Œ±) {x y} (hx : IsFixedPt f x)\n    (hy : IsFixedPt g y) {C} (hfg : ‚àÄ z, dist (f z) (g z) ‚â§ C) : dist x y ‚â§ C / (1 - K) :=\n  calc\n    dist x y = dist y x := dist_comm x y\n    _ ‚â§ dist y (f y) / (1 - K) := hf.dist_le_of_fixedPoint y hx\n    _ = dist (f y) (g y) / (1 - K) := by rw [hy.eq, dist_comm]\n    _ ‚â§ C / (1 - K) := (div_le_div_iff_of_pos_right hf.one_sub_K_pos).2 (hfg y)\n\n"}
{"name":"ContractingWith.fixedPoint_isFixedPt","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : CompleteSpace Œ±\n‚ä¢ Function.IsFixedPt f (ContractingWith.fixedPoint f hf)","decl":"/-- The point provided by `ContractingWith.fixedPoint` is actually a fixed point. -/\ntheorem fixedPoint_isFixedPt : IsFixedPt f (fixedPoint f hf) :=\n  hf.efixedPoint_isFixedPt _\n\n"}
{"name":"ContractingWith.fixedPoint_unique","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : CompleteSpace Œ±\nx : Œ±\nhx : Function.IsFixedPt f x\n‚ä¢ Eq x (ContractingWith.fixedPoint f hf)","decl":"theorem fixedPoint_unique {x} (hx : IsFixedPt f x) : x = fixedPoint f hf :=\n  hf.fixedPoint_unique' hx hf.fixedPoint_isFixedPt\n\n"}
{"name":"ContractingWith.dist_fixedPoint_le","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : CompleteSpace Œ±\nx : Œ±\n‚ä¢ LE.le (Dist.dist x (ContractingWith.fixedPoint f hf)) (HDiv.hDiv (Dist.dist x (f x)) (HSub.hSub 1 ‚ÜëK))","decl":"theorem dist_fixedPoint_le (x) : dist x (fixedPoint f hf) ‚â§ dist x (f x) / (1 - K) :=\n  hf.dist_le_of_fixedPoint x hf.fixedPoint_isFixedPt\n\n"}
{"name":"ContractingWith.aposteriori_dist_iterate_fixedPoint_le","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : CompleteSpace Œ±\nx : Œ±\nn : Nat\n‚ä¢ LE.le (Dist.dist (Nat.iterate f n x) (ContractingWith.fixedPoint f hf)) (HDiv.hDiv (Dist.dist (Nat.iterate f n x) (Nat.iterate f (HAdd.hAdd n 1) x)) (HSub.hSub 1 ‚ÜëK))","decl":"/-- Aposteriori estimates on the convergence of iterates to the fixed point. -/\ntheorem aposteriori_dist_iterate_fixedPoint_le (x n) :\n    dist (f^[n] x) (fixedPoint f hf) ‚â§ dist (f^[n] x) (f^[n + 1] x) / (1 - K) := by\n  rw [iterate_succ']\n  apply hf.dist_fixedPoint_le\n\n"}
{"name":"ContractingWith.apriori_dist_iterate_fixedPoint_le","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : CompleteSpace Œ±\nx : Œ±\nn : Nat\n‚ä¢ LE.le (Dist.dist (Nat.iterate f n x) (ContractingWith.fixedPoint f hf)) (HDiv.hDiv (HMul.hMul (Dist.dist x (f x)) (HPow.hPow (‚ÜëK) n)) (HSub.hSub 1 ‚ÜëK))","decl":"theorem apriori_dist_iterate_fixedPoint_le (x n) :\n    dist (f^[n] x) (fixedPoint f hf) ‚â§ dist x (f x) * (K : ‚Ñù) ^ n / (1 - K) :=\n  calc\n    _ ‚â§ dist (f^[n] x) (f^[n + 1] x) / (1 - K) := hf.aposteriori_dist_iterate_fixedPoint_le x n\n    _ ‚â§ _ := by\n      gcongr; exacts [hf.one_sub_K_pos.le, hf.toLipschitzWith.dist_iterate_succ_le_geometric x n]\n\n"}
{"name":"ContractingWith.tendsto_iterate_fixedPoint","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : CompleteSpace Œ±\nx : Œ±\n‚ä¢ Filter.Tendsto (fun n => Nat.iterate f n x) Filter.atTop (nhds (ContractingWith.fixedPoint f hf))","decl":"theorem tendsto_iterate_fixedPoint (x) :\n    Tendsto (fun n ‚Ü¶ f^[n] x) atTop (ùìù <| fixedPoint f hf) := by\n  convert tendsto_iterate_efixedPoint hf (edist_ne_top x _)\n  refine (fixedPoint_unique _ ?_).symm\n  apply efixedPoint_isFixedPt\n\n"}
{"name":"ContractingWith.fixedPoint_lipschitz_in_map","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : ContractingWith K f\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : CompleteSpace Œ±\ng : Œ± ‚Üí Œ±\nhg : ContractingWith K g\nC : Real\nhfg : ‚àÄ (z : Œ±), LE.le (Dist.dist (f z) (g z)) C\n‚ä¢ LE.le (Dist.dist (ContractingWith.fixedPoint f hf) (ContractingWith.fixedPoint g hg)) (HDiv.hDiv C (HSub.hSub 1 ‚ÜëK))","decl":"theorem fixedPoint_lipschitz_in_map {g : Œ± ‚Üí Œ±} (hg : ContractingWith K g) {C}\n    (hfg : ‚àÄ z, dist (f z) (g z) ‚â§ C) : dist (fixedPoint f hf) (fixedPoint g hg) ‚â§ C / (1 - K) :=\n  hf.dist_fixedPoint_fixedPoint_of_dist_le' g hf.fixedPoint_isFixedPt hg.fixedPoint_isFixedPt hfg\n\n"}
{"name":"ContractingWith.isFixedPt_fixedPoint_iterate","module":"Mathlib.Topology.MetricSpace.Contracting","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : CompleteSpace Œ±\nn : Nat\nhf : ContractingWith K (Nat.iterate f n)\n‚ä¢ Function.IsFixedPt f (ContractingWith.fixedPoint (Nat.iterate f n) hf)","decl":"/-- If a map `f` has a contracting iterate `f^[n]`, then the fixed point of `f^[n]` is also a fixed\npoint of `f`. -/\ntheorem isFixedPt_fixedPoint_iterate {n : ‚Ñï} (hf : ContractingWith K f^[n]) :\n    IsFixedPt f (hf.fixedPoint f^[n]) := by\n  set x := hf.fixedPoint f^[n]\n  have hx : f^[n] x = x := hf.fixedPoint_isFixedPt\n  have := hf.toLipschitzWith.dist_le_mul x (f x)\n  rw [‚Üê iterate_succ_apply, iterate_succ_apply', hx] at this\n  -- Porting note: Originally `contrapose! this`\n  revert this\n  contrapose!\n  intro this\n  have := dist_pos.2 (Ne.symm this)\n  simpa only [NNReal.coe_one, one_mul, NNReal.val_eq_coe] using (mul_lt_mul_right this).mpr hf.left\n\n"}
