{"name":"PowerSeries.binomialSeries_coeff","module":"Mathlib.RingTheory.PowerSeries.Binomial","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : BinomialRing R\ninst✝¹ : Semiring A\ninst✝ : SMul R A\nr : R\nn : Nat\n⊢ Eq ((PowerSeries.coeff A n) (PowerSeries.binomialSeries A r)) (HSMul.hSMul (Ring.choose r n) 1)","decl":"@[simp]\nlemma binomialSeries_coeff [Semiring A] [SMul R A] (r : R) (n : ℕ) :\n    (coeff A n) (binomialSeries A r) = Ring.choose r n • 1 :=\n  coeff_mk n fun n ↦ Ring.choose r n • 1\n\n"}
{"name":"PowerSeries.binomialSeries_add","module":"Mathlib.RingTheory.PowerSeries.Binomial","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : BinomialRing R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nr s : R\n⊢ Eq (PowerSeries.binomialSeries A (HAdd.hAdd r s)) (HMul.hMul (PowerSeries.binomialSeries A r) (PowerSeries.binomialSeries A s))","decl":"@[simp]\nlemma binomialSeries_add [Semiring A] [Algebra R A] (r s : R) :\n    binomialSeries A (r + s) = binomialSeries A r * binomialSeries A s := by\n  ext n\n  simp only [binomialSeries_coeff, Ring.add_choose_eq n (Commute.all r s), coeff_mul,\n    Algebra.mul_smul_comm, mul_one, sum_smul]\n  refine sum_congr rfl fun ab hab => ?_\n  rw [mul_comm, mul_smul]\n\n"}
{"name":"PowerSeries.binomialSeries_nat","module":"Mathlib.RingTheory.PowerSeries.Binomial","initialProofState":"A : Type u_2\ninst✝ : CommRing A\nd : Nat\n⊢ Eq (PowerSeries.binomialSeries A ↑d) (HPow.hPow (HAdd.hAdd 1 PowerSeries.X) d)","decl":"@[simp]\nlemma binomialSeries_nat [CommRing A] (d : ℕ) :\n    binomialSeries A (d : ℤ) = (1 + X) ^ d := by\n  ext n\n  by_cases h : d < n\n  · rw [binomialSeries_coeff, add_comm, add_pow, map_sum, Ring.choose_natCast, natCast_zsmul,\n      Nat.choose_eq_zero_of_lt h, zero_nsmul, sum_eq_zero]\n    intro k hk\n    rw [one_pow, mul_one, coeff_X_pow_mul']\n    have hkd : k ≤ d := mem_range_succ_iff.mp hk\n    simp only [hkd.trans (le_of_lt h), ↓reduceIte]\n    rw [show d.choose k = C A (d.choose k) by rfl, coeff_ne_zero_C (by omega)]\n  · rw [binomialSeries_coeff, add_comm, add_pow]\n    simp only [zsmul_eq_mul, mul_one, one_pow, map_sum]\n    rw [sum_eq_single_of_mem n (by simp only [mem_range]; omega) ?_, coeff_X_pow_mul',\n      Ring.choose_eq_nat_choose]\n    · simp\n    · intro k hk hkn\n      rw [mul_comm, show d.choose k = C A (d.choose k) by rfl, coeff_C_mul_X_pow]\n      exact if_neg (Ne.symm hkn)\n\n"}
{"name":"PowerSeries.rescale_neg_one_invOneSubPow","module":"Mathlib.RingTheory.PowerSeries.Binomial","initialProofState":"A : Type u_2\ninst✝ : CommRing A\nd : Nat\n⊢ Eq ((PowerSeries.rescale (-1)) ↑(PowerSeries.invOneSubPow A d)) (PowerSeries.binomialSeries A (Neg.neg ↑d))","decl":"lemma rescale_neg_one_invOneSubPow [CommRing A] (d : ℕ) :\n    rescale (-1 : A) (invOneSubPow A d) = binomialSeries A (-d : ℤ) := by\n  ext n\n  rw [coeff_rescale, binomialSeries_coeff, ← Int.cast_negOnePow_natCast, ← zsmul_eq_mul]\n  cases d with\n  | zero =>\n    by_cases hn : n = 0 <;> simp [invOneSubPow, Ring.choose_zero_ite, hn]\n  | succ d =>\n    simp only [invOneSubPow, coeff_mk, Nat.cast_add, Nat.cast_one, neg_add_rev, Int.reduceNeg,\n      zsmul_eq_mul, mul_one]\n    rw [show (-1 : ℤ) + -d = -(d + 1) by abel, Ring.choose_neg, Nat.choose_symm_add, Units.smul_def,\n      show (d : ℤ) + 1 + n - 1 = d + n by omega, ← Nat.cast_add, Ring.choose_eq_nat_choose]\n    norm_cast\n\n"}
