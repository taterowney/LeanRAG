{"name":"CanonicallyOrderedAdd.le_self_add","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ninst✝¹ : Add α\ninst✝ : LE α\nself : CanonicallyOrderedAdd α\na b : α\n⊢ LE.le a (HAdd.hAdd a b)","decl":"/-- An ordered additive monoid is `CanonicallyOrderedAdd`\n  if the ordering coincides with the subtractibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a + c`.\n  This is satisfied by the natural numbers, for example, but not\n  the integers or other nontrivial `OrderedAddCommGroup`s. -/\nclass CanonicallyOrderedAdd (α : Type*) [Add α] [LE α] extends\n  ExistsAddOfLE α : Prop where\n  /-- For any `a` and `b`, `a ≤ a + b` -/\n  protected le_self_add : ∀ a b : α, a ≤ a + b\n\n"}
{"name":"CanonicallyOrderedAdd.toExistsAddOfLE","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ninst✝¹ : Add α\ninst✝ : LE α\nself : CanonicallyOrderedAdd α\n⊢ ExistsAddOfLE α","decl":"/-- An ordered additive monoid is `CanonicallyOrderedAdd`\n  if the ordering coincides with the subtractibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a + c`.\n  This is satisfied by the natural numbers, for example, but not\n  the integers or other nontrivial `OrderedAddCommGroup`s. -/\nclass CanonicallyOrderedAdd (α : Type*) [Add α] [LE α] extends\n  ExistsAddOfLE α : Prop where\n  /-- For any `a` and `b`, `a ≤ a + b` -/\n  protected le_self_add : ∀ a b : α, a ≤ a + b\n\n"}
{"name":"CanonicallyOrderedMul.le_self_mul","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ninst✝¹ : Mul α\ninst✝ : LE α\nself : CanonicallyOrderedMul α\na b : α\n⊢ LE.le a (HMul.hMul a b)","decl":"/-- An ordered monoid is `CanonicallyOrderedMul`\n  if the ordering coincides with the divisibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a * c`.\n  Examples seem rare; it seems more likely that the `OrderDual`\n  of a naturally-occurring lattice satisfies this than the lattice\n  itself (for example, dual of the lattice of ideals of a PID or\n  Dedekind domain satisfy this; collections of all things ≤ 1 seem to\n  be more natural that collections of all things ≥ 1). -/\n@[to_additive]\nclass CanonicallyOrderedMul (α : Type*) [Mul α] [LE α] extends\n  ExistsMulOfLE α : Prop where\n  /-- For any `a` and `b`, `a ≤ a * b` -/\n  protected le_self_mul : ∀ a b : α, a ≤ a * b\n\n"}
{"name":"CanonicallyOrderedMul.toExistsMulOfLE","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ninst✝¹ : Mul α\ninst✝ : LE α\nself : CanonicallyOrderedMul α\n⊢ ExistsMulOfLE α","decl":"/-- An ordered monoid is `CanonicallyOrderedMul`\n  if the ordering coincides with the divisibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a * c`.\n  Examples seem rare; it seems more likely that the `OrderDual`\n  of a naturally-occurring lattice satisfies this than the lattice\n  itself (for example, dual of the lattice of ideals of a PID or\n  Dedekind domain satisfy this; collections of all things ≤ 1 seem to\n  be more natural that collections of all things ≥ 1). -/\n@[to_additive]\nclass CanonicallyOrderedMul (α : Type*) [Mul α] [LE α] extends\n  ExistsMulOfLE α : Prop where\n  /-- For any `a` and `b`, `a ≤ a * b` -/\n  protected le_self_mul : ∀ a b : α, a ≤ a * b\n\n"}
{"name":"CanonicallyOrderedAddCommMonoid.exists_add_of_le","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\nself : CanonicallyOrderedAddCommMonoid α\na b : α\na✝ : LE.le a b\n⊢ Exists fun c => Eq b (HAdd.hAdd a c)","decl":"/-- A canonically ordered additive monoid is an ordered commutative additive monoid\n  in which the ordering coincides with the subtractibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a + c`.\n  This is satisfied by the natural numbers, for example, but not\n  the integers or other nontrivial `OrderedAddCommGroup`s. -/\n@[deprecated \"Use `[OrderedAddCommMonoid α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedAddCommMonoid (α : Type*) extends\n    OrderedAddCommMonoid α, OrderBot α where\n  /-- For `a ≤ b`, there is a `c` so `b = a + c`. -/\n  protected exists_add_of_le : ∀ {a b : α}, a ≤ b → ∃ c, b = a + c\n  /-- For any `a` and `b`, `a ≤ a + b` -/\n  protected le_self_add : ∀ a b : α, a ≤ a + b\n\n"}
{"name":"CanonicallyOrderedAddCommMonoid.le_self_add","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\nself : CanonicallyOrderedAddCommMonoid α\na b : α\n⊢ LE.le a (HAdd.hAdd a b)","decl":"/-- A canonically ordered additive monoid is an ordered commutative additive monoid\n  in which the ordering coincides with the subtractibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a + c`.\n  This is satisfied by the natural numbers, for example, but not\n  the integers or other nontrivial `OrderedAddCommGroup`s. -/\n@[deprecated \"Use `[OrderedAddCommMonoid α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedAddCommMonoid (α : Type*) extends\n    OrderedAddCommMonoid α, OrderBot α where\n  /-- For `a ≤ b`, there is a `c` so `b = a + c`. -/\n  protected exists_add_of_le : ∀ {a b : α}, a ≤ b → ∃ c, b = a + c\n  /-- For any `a` and `b`, `a ≤ a + b` -/\n  protected le_self_add : ∀ a b : α, a ≤ a + b\n\n"}
{"name":"CanonicallyOrderedAddCommMonoid.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ninst✝ : SizeOf α\ntoOrderedAddCommMonoid : OrderedAddCommMonoid α\ntoOrderBot : OrderBot α\nexists_add_of_le : ∀ {a b : α}, LE.le a b → Exists fun c => Eq b (HAdd.hAdd a c)\nle_self_add : ∀ (a b : α), LE.le a (HAdd.hAdd a b)\n⊢ Eq (SizeOf.sizeOf { toOrderedAddCommMonoid := toOrderedAddCommMonoid, toOrderBot := toOrderBot, exists_add_of_le := exists_add_of_le, le_self_add := le_self_add }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toOrderedAddCommMonoid)) (SizeOf.sizeOf toOrderBot))","decl":"/-- A canonically ordered additive monoid is an ordered commutative additive monoid\n  in which the ordering coincides with the subtractibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a + c`.\n  This is satisfied by the natural numbers, for example, but not\n  the integers or other nontrivial `OrderedAddCommGroup`s. -/\n@[deprecated \"Use `[OrderedAddCommMonoid α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedAddCommMonoid (α : Type*) extends\n    OrderedAddCommMonoid α, OrderBot α where\n  /-- For `a ≤ b`, there is a `c` so `b = a + c`. -/\n  protected exists_add_of_le : ∀ {a b : α}, a ≤ b → ∃ c, b = a + c\n  /-- For any `a` and `b`, `a ≤ a + b` -/\n  protected le_self_add : ∀ a b : α, a ≤ a + b\n\n"}
{"name":"CanonicallyOrderedAddCommMonoid.mk.injEq","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ntoOrderedAddCommMonoid✝ : OrderedAddCommMonoid α\ntoOrderBot✝ : OrderBot α\nexists_add_of_le✝ : ∀ {a b : α}, LE.le a b → Exists fun c => Eq b (HAdd.hAdd a c)\nle_self_add✝ : ∀ (a b : α), LE.le a (HAdd.hAdd a b)\ntoOrderedAddCommMonoid : OrderedAddCommMonoid α\ntoOrderBot : OrderBot α\nexists_add_of_le : ∀ {a b : α}, LE.le a b → Exists fun c => Eq b (HAdd.hAdd a c)\nle_self_add : ∀ (a b : α), LE.le a (HAdd.hAdd a b)\n⊢ Eq (Eq { toOrderedAddCommMonoid := toOrderedAddCommMonoid✝, toOrderBot := toOrderBot✝, exists_add_of_le := exists_add_of_le✝, le_self_add := le_self_add✝ } { toOrderedAddCommMonoid := toOrderedAddCommMonoid, toOrderBot := toOrderBot, exists_add_of_le := exists_add_of_le, le_self_add := le_self_add }) (And (Eq toOrderedAddCommMonoid✝ toOrderedAddCommMonoid) (HEq toOrderBot✝ toOrderBot))","decl":"/-- A canonically ordered additive monoid is an ordered commutative additive monoid\n  in which the ordering coincides with the subtractibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a + c`.\n  This is satisfied by the natural numbers, for example, but not\n  the integers or other nontrivial `OrderedAddCommGroup`s. -/\n@[deprecated \"Use `[OrderedAddCommMonoid α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedAddCommMonoid (α : Type*) extends\n    OrderedAddCommMonoid α, OrderBot α where\n  /-- For `a ≤ b`, there is a `c` so `b = a + c`. -/\n  protected exists_add_of_le : ∀ {a b : α}, a ≤ b → ∃ c, b = a + c\n  /-- For any `a` and `b`, `a ≤ a + b` -/\n  protected le_self_add : ∀ a b : α, a ≤ a + b\n\n"}
{"name":"CanonicallyOrderedAddCommMonoid.mk.inj","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ntoOrderedAddCommMonoid✝ : OrderedAddCommMonoid α\ntoOrderBot✝ : OrderBot α\nexists_add_of_le✝ : ∀ {a b : α}, LE.le a b → Exists fun c => Eq b (HAdd.hAdd a c)\nle_self_add✝ : ∀ (a b : α), LE.le a (HAdd.hAdd a b)\ntoOrderedAddCommMonoid : OrderedAddCommMonoid α\ntoOrderBot : OrderBot α\nexists_add_of_le : ∀ {a b : α}, LE.le a b → Exists fun c => Eq b (HAdd.hAdd a c)\nle_self_add : ∀ (a b : α), LE.le a (HAdd.hAdd a b)\nx✝ : Eq { toOrderedAddCommMonoid := toOrderedAddCommMonoid✝, toOrderBot := toOrderBot✝, exists_add_of_le := exists_add_of_le✝, le_self_add := le_self_add✝ } { toOrderedAddCommMonoid := toOrderedAddCommMonoid, toOrderBot := toOrderBot, exists_add_of_le := exists_add_of_le, le_self_add := le_self_add }\n⊢ And (Eq toOrderedAddCommMonoid✝ toOrderedAddCommMonoid) (HEq toOrderBot✝ toOrderBot)","decl":"/-- A canonically ordered additive monoid is an ordered commutative additive monoid\n  in which the ordering coincides with the subtractibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a + c`.\n  This is satisfied by the natural numbers, for example, but not\n  the integers or other nontrivial `OrderedAddCommGroup`s. -/\n@[deprecated \"Use `[OrderedAddCommMonoid α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedAddCommMonoid (α : Type*) extends\n    OrderedAddCommMonoid α, OrderBot α where\n  /-- For `a ≤ b`, there is a `c` so `b = a + c`. -/\n  protected exists_add_of_le : ∀ {a b : α}, a ≤ b → ∃ c, b = a + c\n  /-- For any `a` and `b`, `a ≤ a + b` -/\n  protected le_self_add : ∀ a b : α, a ≤ a + b\n\n"}
{"name":"CanonicallyOrderedCommMonoid.mk.inj","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ntoOrderedCommMonoid✝ : OrderedCommMonoid α\ntoOrderBot✝ : OrderBot α\nexists_mul_of_le✝ : ∀ {a b : α}, LE.le a b → Exists fun c => Eq b (HMul.hMul a c)\nle_self_mul✝ : ∀ (a b : α), LE.le a (HMul.hMul a b)\ntoOrderedCommMonoid : OrderedCommMonoid α\ntoOrderBot : OrderBot α\nexists_mul_of_le : ∀ {a b : α}, LE.le a b → Exists fun c => Eq b (HMul.hMul a c)\nle_self_mul : ∀ (a b : α), LE.le a (HMul.hMul a b)\nx✝ : Eq { toOrderedCommMonoid := toOrderedCommMonoid✝, toOrderBot := toOrderBot✝, exists_mul_of_le := exists_mul_of_le✝, le_self_mul := le_self_mul✝ } { toOrderedCommMonoid := toOrderedCommMonoid, toOrderBot := toOrderBot, exists_mul_of_le := exists_mul_of_le, le_self_mul := le_self_mul }\n⊢ And (Eq toOrderedCommMonoid✝ toOrderedCommMonoid) (HEq toOrderBot✝ toOrderBot)","decl":"set_option linter.existingAttributeWarning false in\n/-- A canonically ordered monoid is an ordered commutative monoid\n  in which the ordering coincides with the divisibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a * c`.\n  Examples seem rare; it seems more likely that the `OrderDual`\n  of a naturally-occurring lattice satisfies this than the lattice\n  itself (for example, dual of the lattice of ideals of a PID or\n  Dedekind domain satisfy this; collections of all things ≤ 1 seem to\n  be more natural that collections of all things ≥ 1).\n-/\n@[to_additive,\n  deprecated \"Use `[OrderedCommMonoid α] [CanonicallyOrderedMul α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommMonoid (α : Type*) extends OrderedCommMonoid α, OrderBot α where\n  /-- For `a ≤ b`, there is a `c` so `b = a * c`. -/\n  protected exists_mul_of_le : ∀ {a b : α}, a ≤ b → ∃ c, b = a * c\n  /-- For any `a` and `b`, `a ≤ a * b` -/\n  protected le_self_mul : ∀ a b : α, a ≤ a * b\n\n"}
{"name":"CanonicallyOrderedCommMonoid.mk.injEq","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ntoOrderedCommMonoid✝ : OrderedCommMonoid α\ntoOrderBot✝ : OrderBot α\nexists_mul_of_le✝ : ∀ {a b : α}, LE.le a b → Exists fun c => Eq b (HMul.hMul a c)\nle_self_mul✝ : ∀ (a b : α), LE.le a (HMul.hMul a b)\ntoOrderedCommMonoid : OrderedCommMonoid α\ntoOrderBot : OrderBot α\nexists_mul_of_le : ∀ {a b : α}, LE.le a b → Exists fun c => Eq b (HMul.hMul a c)\nle_self_mul : ∀ (a b : α), LE.le a (HMul.hMul a b)\n⊢ Eq (Eq { toOrderedCommMonoid := toOrderedCommMonoid✝, toOrderBot := toOrderBot✝, exists_mul_of_le := exists_mul_of_le✝, le_self_mul := le_self_mul✝ } { toOrderedCommMonoid := toOrderedCommMonoid, toOrderBot := toOrderBot, exists_mul_of_le := exists_mul_of_le, le_self_mul := le_self_mul }) (And (Eq toOrderedCommMonoid✝ toOrderedCommMonoid) (HEq toOrderBot✝ toOrderBot))","decl":"set_option linter.existingAttributeWarning false in\n/-- A canonically ordered monoid is an ordered commutative monoid\n  in which the ordering coincides with the divisibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a * c`.\n  Examples seem rare; it seems more likely that the `OrderDual`\n  of a naturally-occurring lattice satisfies this than the lattice\n  itself (for example, dual of the lattice of ideals of a PID or\n  Dedekind domain satisfy this; collections of all things ≤ 1 seem to\n  be more natural that collections of all things ≥ 1).\n-/\n@[to_additive,\n  deprecated \"Use `[OrderedCommMonoid α] [CanonicallyOrderedMul α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommMonoid (α : Type*) extends OrderedCommMonoid α, OrderBot α where\n  /-- For `a ≤ b`, there is a `c` so `b = a * c`. -/\n  protected exists_mul_of_le : ∀ {a b : α}, a ≤ b → ∃ c, b = a * c\n  /-- For any `a` and `b`, `a ≤ a * b` -/\n  protected le_self_mul : ∀ a b : α, a ≤ a * b\n\n"}
{"name":"CanonicallyOrderedCommMonoid.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ninst✝ : SizeOf α\ntoOrderedCommMonoid : OrderedCommMonoid α\ntoOrderBot : OrderBot α\nexists_mul_of_le : ∀ {a b : α}, LE.le a b → Exists fun c => Eq b (HMul.hMul a c)\nle_self_mul : ∀ (a b : α), LE.le a (HMul.hMul a b)\n⊢ Eq (SizeOf.sizeOf { toOrderedCommMonoid := toOrderedCommMonoid, toOrderBot := toOrderBot, exists_mul_of_le := exists_mul_of_le, le_self_mul := le_self_mul }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toOrderedCommMonoid)) (SizeOf.sizeOf toOrderBot))","decl":"set_option linter.existingAttributeWarning false in\n/-- A canonically ordered monoid is an ordered commutative monoid\n  in which the ordering coincides with the divisibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a * c`.\n  Examples seem rare; it seems more likely that the `OrderDual`\n  of a naturally-occurring lattice satisfies this than the lattice\n  itself (for example, dual of the lattice of ideals of a PID or\n  Dedekind domain satisfy this; collections of all things ≤ 1 seem to\n  be more natural that collections of all things ≥ 1).\n-/\n@[to_additive,\n  deprecated \"Use `[OrderedCommMonoid α] [CanonicallyOrderedMul α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommMonoid (α : Type*) extends OrderedCommMonoid α, OrderBot α where\n  /-- For `a ≤ b`, there is a `c` so `b = a * c`. -/\n  protected exists_mul_of_le : ∀ {a b : α}, a ≤ b → ∃ c, b = a * c\n  /-- For any `a` and `b`, `a ≤ a * b` -/\n  protected le_self_mul : ∀ a b : α, a ≤ a * b\n\n"}
{"name":"CanonicallyOrderedCommMonoid.exists_mul_of_le","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommMonoid α\na b : α\na✝ : LE.le a b\n⊢ Exists fun c => Eq b (HMul.hMul a c)","decl":"set_option linter.existingAttributeWarning false in\n/-- A canonically ordered monoid is an ordered commutative monoid\n  in which the ordering coincides with the divisibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a * c`.\n  Examples seem rare; it seems more likely that the `OrderDual`\n  of a naturally-occurring lattice satisfies this than the lattice\n  itself (for example, dual of the lattice of ideals of a PID or\n  Dedekind domain satisfy this; collections of all things ≤ 1 seem to\n  be more natural that collections of all things ≥ 1).\n-/\n@[to_additive,\n  deprecated \"Use `[OrderedCommMonoid α] [CanonicallyOrderedMul α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommMonoid (α : Type*) extends OrderedCommMonoid α, OrderBot α where\n  /-- For `a ≤ b`, there is a `c` so `b = a * c`. -/\n  protected exists_mul_of_le : ∀ {a b : α}, a ≤ b → ∃ c, b = a * c\n  /-- For any `a` and `b`, `a ≤ a * b` -/\n  protected le_self_mul : ∀ a b : α, a ≤ a * b\n\n"}
{"name":"CanonicallyOrderedCommMonoid.le_self_mul","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommMonoid α\na b : α\n⊢ LE.le a (HMul.hMul a b)","decl":"set_option linter.existingAttributeWarning false in\n/-- A canonically ordered monoid is an ordered commutative monoid\n  in which the ordering coincides with the divisibility relation,\n  which is to say, `a ≤ b` iff there exists `c` with `b = a * c`.\n  Examples seem rare; it seems more likely that the `OrderDual`\n  of a naturally-occurring lattice satisfies this than the lattice\n  itself (for example, dual of the lattice of ideals of a PID or\n  Dedekind domain satisfy this; collections of all things ≤ 1 seem to\n  be more natural that collections of all things ≥ 1).\n-/\n@[to_additive,\n  deprecated \"Use `[OrderedCommMonoid α] [CanonicallyOrderedMul α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommMonoid (α : Type*) extends OrderedCommMonoid α, OrderBot α where\n  /-- For `a ≤ b`, there is a `c` so `b = a * c`. -/\n  protected exists_mul_of_le : ∀ {a b : α}, a ≤ b → ∃ c, b = a * c\n  /-- For any `a` and `b`, `a ≤ a * b` -/\n  protected le_self_mul : ∀ a b : α, a ≤ a * b\n\n"}
{"name":"le_self_mul","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : Mul α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedMul α\na b : α\n⊢ LE.le a (HMul.hMul a b)","decl":"@[to_additive]\ntheorem le_self_mul : a ≤ a * b :=\n  CanonicallyOrderedMul.le_self_mul _ _\n\n"}
{"name":"le_self_add","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedAdd α\na b : α\n⊢ LE.le a (HAdd.hAdd a b)","decl":"@[to_additive]\ntheorem le_self_mul : a ≤ a * b :=\n  CanonicallyOrderedMul.le_self_mul _ _\n\n"}
{"name":"self_le_add_right","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedAdd α\na b : α\n⊢ LE.le a (HAdd.hAdd a b)","decl":"@[to_additive (attr := simp)]\ntheorem self_le_mul_right (a b : α) : a ≤ a * b :=\n  le_self_mul\n\n"}
{"name":"self_le_mul_right","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : Mul α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedMul α\na b : α\n⊢ LE.le a (HMul.hMul a b)","decl":"@[to_additive (attr := simp)]\ntheorem self_le_mul_right (a b : α) : a ≤ a * b :=\n  le_self_mul\n\n"}
{"name":"le_iff_exists_add","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedAdd α\na b : α\n⊢ Iff (LE.le a b) (Exists fun c => Eq b (HAdd.hAdd a c))","decl":"@[to_additive]\ntheorem le_iff_exists_mul : a ≤ b ↔ ∃ c, b = a * c :=\n  ⟨exists_mul_of_le, by\n    rintro ⟨c, rfl⟩\n    exact le_self_mul⟩\n\n"}
{"name":"le_iff_exists_mul","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : Mul α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedMul α\na b : α\n⊢ Iff (LE.le a b) (Exists fun c => Eq b (HMul.hMul a c))","decl":"@[to_additive]\ntheorem le_iff_exists_mul : a ≤ b ↔ ∃ c, b = a * c :=\n  ⟨exists_mul_of_le, by\n    rintro ⟨c, rfl⟩\n    exact le_self_mul⟩\n\n"}
{"name":"le_of_add_le_left","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedAdd α\na b c : α\na✝ : LE.le (HAdd.hAdd a b) c\n⊢ LE.le a c","decl":"@[to_additive]\ntheorem le_of_mul_le_left : a * b ≤ c → a ≤ c :=\n  le_self_mul.trans\n\n"}
{"name":"le_of_mul_le_left","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedMul α\na b c : α\na✝ : LE.le (HMul.hMul a b) c\n⊢ LE.le a c","decl":"@[to_additive]\ntheorem le_of_mul_le_left : a * b ≤ c → a ≤ c :=\n  le_self_mul.trans\n\n"}
{"name":"le_mul_of_le_left","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedMul α\na b c : α\na✝ : LE.le a b\n⊢ LE.le a (HMul.hMul b c)","decl":"@[to_additive]\ntheorem le_mul_of_le_left : a ≤ b → a ≤ b * c :=\n  le_self_mul.trans'\n\n"}
{"name":"le_add_of_le_left","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedAdd α\na b c : α\na✝ : LE.le a b\n⊢ LE.le a (HAdd.hAdd b c)","decl":"@[to_additive]\ntheorem le_mul_of_le_left : a ≤ b → a ≤ b * c :=\n  le_self_mul.trans'\n\n"}
{"name":"le_add_right","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedAdd α\na b c : α\na✝ : LE.le a b\n⊢ LE.le a (HAdd.hAdd b c)","decl":"@[to_additive] alias le_mul_right := le_mul_of_le_left\n\n"}
{"name":"le_mul_right","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedMul α\na b c : α\na✝ : LE.le a b\n⊢ LE.le a (HMul.hMul b c)","decl":"@[to_additive] alias le_mul_right := le_mul_of_le_left\n\n"}
{"name":"le_add_self","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddCommMagma α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedAdd α\na b : α\n⊢ LE.le a (HAdd.hAdd b a)","decl":"@[to_additive]\ntheorem le_mul_self : a ≤ b * a := by\n  rw [mul_comm]\n  exact le_self_mul\n\n"}
{"name":"le_mul_self","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : CommMagma α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedMul α\na b : α\n⊢ LE.le a (HMul.hMul b a)","decl":"@[to_additive]\ntheorem le_mul_self : a ≤ b * a := by\n  rw [mul_comm]\n  exact le_self_mul\n\n"}
{"name":"self_le_add_left","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddCommMagma α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedAdd α\na b : α\n⊢ LE.le a (HAdd.hAdd b a)","decl":"@[to_additive (attr := simp)]\ntheorem self_le_mul_left (a b : α) : a ≤ b * a :=\n  le_mul_self\n\n"}
{"name":"self_le_mul_left","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : CommMagma α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedMul α\na b : α\n⊢ LE.le a (HMul.hMul b a)","decl":"@[to_additive (attr := simp)]\ntheorem self_le_mul_left (a b : α) : a ≤ b * a :=\n  le_mul_self\n\n"}
{"name":"le_of_mul_le_right","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : CommMagma α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedMul α\na b c : α\na✝ : LE.le (HMul.hMul a b) c\n⊢ LE.le b c","decl":"@[to_additive]\ntheorem le_of_mul_le_right : a * b ≤ c → b ≤ c :=\n  le_mul_self.trans\n\n"}
{"name":"le_of_add_le_right","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddCommMagma α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedAdd α\na b c : α\na✝ : LE.le (HAdd.hAdd a b) c\n⊢ LE.le b c","decl":"@[to_additive]\ntheorem le_of_mul_le_right : a * b ≤ c → b ≤ c :=\n  le_mul_self.trans\n\n"}
{"name":"le_mul_of_le_right","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : CommMagma α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedMul α\na b c : α\na✝ : LE.le a c\n⊢ LE.le a (HMul.hMul b c)","decl":"@[to_additive]\ntheorem le_mul_of_le_right : a ≤ c → a ≤ b * c :=\n  le_mul_self.trans'\n\n"}
{"name":"le_add_of_le_right","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddCommMagma α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedAdd α\na b c : α\na✝ : LE.le a c\n⊢ LE.le a (HAdd.hAdd b c)","decl":"@[to_additive]\ntheorem le_mul_of_le_right : a ≤ c → a ≤ b * c :=\n  le_mul_self.trans'\n\n"}
{"name":"le_add_left","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddCommMagma α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedAdd α\na b c : α\na✝ : LE.le a c\n⊢ LE.le a (HAdd.hAdd b c)","decl":"@[to_additive] alias le_mul_left := le_mul_of_le_right\n\n"}
{"name":"le_mul_left","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : CommMagma α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedMul α\na b c : α\na✝ : LE.le a c\n⊢ LE.le a (HMul.hMul b c)","decl":"@[to_additive] alias le_mul_left := le_mul_of_le_right\n\n"}
{"name":"le_iff_exists_mul'","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : CommMagma α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedMul α\na b : α\n⊢ Iff (LE.le a b) (Exists fun c => Eq b (HMul.hMul c a))","decl":"@[to_additive]\ntheorem le_iff_exists_mul' : a ≤ b ↔ ∃ c, b = c * a := by\n  simp only [mul_comm _ a, le_iff_exists_mul]\n\n"}
{"name":"le_iff_exists_add'","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddCommMagma α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedAdd α\na b : α\n⊢ Iff (LE.le a b) (Exists fun c => Eq b (HAdd.hAdd c a))","decl":"@[to_additive]\ntheorem le_iff_exists_mul' : a ≤ b ↔ ∃ c, b = c * a := by\n  simp only [mul_comm _ a, le_iff_exists_mul]\n\n"}
{"name":"zero_le","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddZeroClass α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedAdd α\na : α\n⊢ LE.le 0 a","decl":"@[to_additive (attr := simp) zero_le]\ntheorem one_le (a : α) : 1 ≤ a :=\n  le_self_mul.trans_eq (one_mul _)\n\n"}
{"name":"one_le","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : MulOneClass α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedMul α\na : α\n⊢ LE.le 1 a","decl":"@[to_additive (attr := simp) zero_le]\ntheorem one_le (a : α) : 1 ≤ a :=\n  le_self_mul.trans_eq (one_mul _)\n\n"}
{"name":"one_lt_of_gt","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedMul α\na b : α\nh : LT.lt a b\n⊢ LT.lt 1 b","decl":"@[to_additive (attr := simp)]\ntheorem one_lt_of_gt (h : a < b) : 1 < b :=\n  (one_le _).trans_lt h\n\n"}
{"name":"pos_of_gt","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedAdd α\na b : α\nh : LT.lt a b\n⊢ LT.lt 0 b","decl":"@[to_additive (attr := simp)]\ntheorem one_lt_of_gt (h : a < b) : 1 < b :=\n  (one_le _).trans_lt h\n\n"}
{"name":"bot_eq_zero","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddZeroClass α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\n⊢ Eq Bot.bot 0","decl":"@[to_additive]\ntheorem bot_eq_one : (⊥ : α) = 1 :=\n  le_antisymm bot_le (one_le ⊥)\n\n"}
{"name":"bot_eq_one","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : MulOneClass α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedMul α\n⊢ Eq Bot.bot 1","decl":"@[to_additive]\ntheorem bot_eq_one : (⊥ : α) = 1 :=\n  le_antisymm bot_le (one_le ⊥)\n\n"}
{"name":"le_one_iff_eq_one","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : MulOneClass α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedMul α\na : α\n⊢ Iff (LE.le a 1) (Eq a 1)","decl":"@[to_additive (attr := simp)]\ntheorem le_one_iff_eq_one : a ≤ 1 ↔ a = 1 :=\n  (one_le a).le_iff_eq\n\n"}
{"name":"nonpos_iff_eq_zero","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddZeroClass α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\na : α\n⊢ Iff (LE.le a 0) (Eq a 0)","decl":"@[to_additive (attr := simp)]\ntheorem le_one_iff_eq_one : a ≤ 1 ↔ a = 1 :=\n  (one_le a).le_iff_eq\n\n"}
{"name":"one_lt_iff_ne_one","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : MulOneClass α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedMul α\na : α\n⊢ Iff (LT.lt 1 a) (Ne a 1)","decl":"@[to_additive]\ntheorem one_lt_iff_ne_one : 1 < a ↔ a ≠ 1 :=\n  (one_le a).lt_iff_ne.trans ne_comm\n\n"}
{"name":"pos_iff_ne_zero","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddZeroClass α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\na : α\n⊢ Iff (LT.lt 0 a) (Ne a 0)","decl":"@[to_additive]\ntheorem one_lt_iff_ne_one : 1 < a ↔ a ≠ 1 :=\n  (one_le a).lt_iff_ne.trans ne_comm\n\n"}
{"name":"eq_zero_or_pos","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddZeroClass α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\na : α\n⊢ Or (Eq a 0) (LT.lt 0 a)","decl":"@[to_additive]\ntheorem eq_one_or_one_lt (a : α) : a = 1 ∨ 1 < a := (one_le a).eq_or_lt.imp_left Eq.symm\n\n"}
{"name":"eq_one_or_one_lt","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : MulOneClass α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedMul α\na : α\n⊢ Or (Eq a 1) (LT.lt 1 a)","decl":"@[to_additive]\ntheorem eq_one_or_one_lt (a : α) : a = 1 ∨ 1 < a := (one_le a).eq_or_lt.imp_left Eq.symm\n\n"}
{"name":"one_not_mem_iff","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : MulOneClass α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedMul α\ns : Set α\n⊢ Iff (Not (Membership.mem s 1)) (∀ (x : α), Membership.mem s x → LT.lt 1 x)","decl":"@[to_additive]\nlemma one_not_mem_iff {s : Set α} : 1 ∉ s ↔ ∀ x ∈ s, 1 < x :=\n  bot_eq_one (α := α) ▸ bot_not_mem_iff\n\n"}
{"name":"zero_not_mem_iff","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddZeroClass α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\ns : Set α\n⊢ Iff (Not (Membership.mem s 0)) (∀ (x : α), Membership.mem s x → LT.lt 0 x)","decl":"@[to_additive]\nlemma one_not_mem_iff {s : Set α} : 1 ∉ s ↔ ∀ x ∈ s, 1 < x :=\n  bot_eq_one (α := α) ▸ bot_not_mem_iff\n\n"}
{"name":"exists_one_lt_mul_of_lt","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : MulOneClass α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedMul α\na b : α\nh : LT.lt a b\n⊢ Exists fun c => Exists fun x => Eq (HMul.hMul a c) b","decl":"@[to_additive]\ntheorem exists_one_lt_mul_of_lt (h : a < b) : ∃ (c : _) (_ : 1 < c), a * c = b := by\n  obtain ⟨c, hc⟩ := le_iff_exists_mul.1 h.le\n  refine ⟨c, one_lt_iff_ne_one.2 ?_, hc.symm⟩\n  rintro rfl\n  simp [hc, lt_irrefl] at h\n\n"}
{"name":"exists_pos_add_of_lt","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddZeroClass α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\na b : α\nh : LT.lt a b\n⊢ Exists fun c => Exists fun x => Eq (HAdd.hAdd a c) b","decl":"@[to_additive]\ntheorem exists_one_lt_mul_of_lt (h : a < b) : ∃ (c : _) (_ : 1 < c), a * c = b := by\n  obtain ⟨c, hc⟩ := le_iff_exists_mul.1 h.le\n  refine ⟨c, one_lt_iff_ne_one.2 ?_, hc.symm⟩\n  rintro rfl\n  simp [hc, lt_irrefl] at h\n\n"}
{"name":"lt_iff_exists_add","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝³ : AddZeroClass α\ninst✝² : PartialOrder α\ninst✝¹ : CanonicallyOrderedAdd α\na b : α\ninst✝ : AddLeftStrictMono α\n⊢ Iff (LT.lt a b) (Exists fun c => And (GT.gt c 0) (Eq b (HAdd.hAdd a c)))","decl":"@[to_additive]\ntheorem lt_iff_exists_mul [MulLeftStrictMono α] : a < b ↔ ∃ c > 1, b = a * c := by\n  rw [lt_iff_le_and_ne, le_iff_exists_mul, ← exists_and_right]\n  apply exists_congr\n  intro c\n  rw [and_comm, and_congr_left_iff, gt_iff_lt]\n  rintro rfl\n  constructor\n  · rw [one_lt_iff_ne_one]\n    apply mt\n    rintro rfl\n    rw [mul_one]\n  · rw [← (self_le_mul_right a c).lt_iff_ne]\n    apply lt_mul_of_one_lt_right'\n\n"}
{"name":"lt_iff_exists_mul","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝³ : MulOneClass α\ninst✝² : PartialOrder α\ninst✝¹ : CanonicallyOrderedMul α\na b : α\ninst✝ : MulLeftStrictMono α\n⊢ Iff (LT.lt a b) (Exists fun c => And (GT.gt c 1) (Eq b (HMul.hMul a c)))","decl":"@[to_additive]\ntheorem lt_iff_exists_mul [MulLeftStrictMono α] : a < b ↔ ∃ c > 1, b = a * c := by\n  rw [lt_iff_le_and_ne, le_iff_exists_mul, ← exists_and_right]\n  apply exists_congr\n  intro c\n  rw [and_comm, and_congr_left_iff, gt_iff_lt]\n  rintro rfl\n  constructor\n  · rw [one_lt_iff_ne_one]\n    apply mt\n    rintro rfl\n    rw [mul_one]\n  · rw [← (self_le_mul_right a c).lt_iff_ne]\n    apply lt_mul_of_one_lt_right'\n\n"}
{"name":"CanonicallyOrderedMul.toMulLeftMono","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝¹ : Semigroup α\ninst✝ : LE α\n⊢ MulLeftMono α","decl":"@[to_additive]\ninstance (priority := 10) CanonicallyOrderedMul.toMulLeftMono :\n    MulLeftMono α where\n  elim a b c hbc := by\n    obtain ⟨c, hc, rfl⟩ := exists_mul_of_le hbc\n    rw [le_iff_exists_mul]\n    exact ⟨c, (mul_assoc _ _ _).symm⟩\n\n"}
{"name":"CanonicallyOrderedAdd.toAddLeftMono","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝¹ : AddSemigroup α\ninst✝ : LE α\n⊢ AddLeftMono α","decl":"@[to_additive]\ninstance (priority := 10) CanonicallyOrderedMul.toMulLeftMono :\n    MulLeftMono α where\n  elim a b c hbc := by\n    obtain ⟨c, hc, rfl⟩ := exists_mul_of_le hbc\n    rw [le_iff_exists_mul]\n    exact ⟨c, (mul_assoc _ _ _).symm⟩\n\n"}
{"name":"add_pos_iff","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : AddCommMonoid α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedAdd α\na b : α\n⊢ Iff (LT.lt 0 (HAdd.hAdd a b)) (Or (LT.lt 0 a) (LT.lt 0 b))","decl":"@[to_additive (attr := simp) add_pos_iff]\ntheorem one_lt_mul_iff : 1 < a * b ↔ 1 < a ∨ 1 < b := by\n  simp only [one_lt_iff_ne_one, Ne, mul_eq_one, not_and_or]\n\n"}
{"name":"one_lt_mul_iff","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝² : CommMonoid α\ninst✝¹ : PartialOrder α\ninst✝ : CanonicallyOrderedMul α\na b : α\n⊢ Iff (LT.lt 1 (HMul.hMul a b)) (Or (LT.lt 1 a) (LT.lt 1 b))","decl":"@[to_additive (attr := simp) add_pos_iff]\ntheorem one_lt_mul_iff : 1 < a * b ↔ 1 < a ∨ 1 < b := by\n  simp only [one_lt_iff_ne_one, Ne, mul_eq_one, not_and_or]\n\n"}
{"name":"NeZero.pos","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"M : Type u_1\ninst✝³ : AddZeroClass M\ninst✝² : PartialOrder M\ninst✝¹ : CanonicallyOrderedAdd M\na : M\ninst✝ : NeZero a\n⊢ LT.lt 0 a","decl":"theorem pos {M} [AddZeroClass M] [PartialOrder M] [CanonicallyOrderedAdd M]\n    (a : M) [NeZero a] : 0 < a :=\n  (zero_le a).lt_of_ne <| NeZero.out.symm\n\n"}
{"name":"NeZero.of_gt","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"M : Type u_1\ninst✝² : AddZeroClass M\ninst✝¹ : Preorder M\ninst✝ : CanonicallyOrderedAdd M\nx y : M\nh : LT.lt x y\n⊢ NeZero y","decl":"theorem of_gt {M} [AddZeroClass M] [Preorder M] [CanonicallyOrderedAdd M]\n    {x y : M} (h : x < y) : NeZero y :=\n  of_pos <| pos_of_gt h\n\n-- 1 < p is still an often-used `Fact`, due to `Nat.Prime` implying it, and it implying `Nontrivial`\n-- on `ZMod`'s ring structure. We cannot just set this to be any `x < y`, else that becomes a\n-- metavariable and it will hugely slow down typeclass inference.\n"}
{"name":"NeZero.of_gt'","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"M : Type u_1\ninst✝⁴ : AddZeroClass M\ninst✝³ : Preorder M\ninst✝² : CanonicallyOrderedAdd M\ninst✝¹ : One M\ny : M\ninst✝ : Fact (LT.lt 1 y)\n⊢ NeZero y","decl":"instance (priority := 10) of_gt' {M : Type*} [AddZeroClass M] [Preorder M] [CanonicallyOrderedAdd M]\n    [One M] {y : M}\n    -- Porting note: Fact.out has different type signature from mathlib3\n    [Fact (1 < y)] : NeZero y := of_gt <| @Fact.out (1 < y) _\n\n"}
{"name":"CanonicallyLinearOrderedAddCommMonoid.compare_eq_compareOfLessAndEq","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedAddCommMonoid α\na b : α\n⊢ Eq (Ord.compare a b) (compareOfLessAndEq a b)","decl":"set_option linter.deprecated false in\n/-- A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n    whose ordering is a linear order. -/\n@[deprecated \"Use `[LinearOrderedAddCommMonoid α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedAddCommMonoid (α : Type*)\n  extends CanonicallyOrderedAddCommMonoid α, LinearOrderedAddCommMonoid α\n\n"}
{"name":"CanonicallyLinearOrderedAddCommMonoid.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ninst✝ : SizeOf α\ntoCanonicallyOrderedAddCommMonoid : CanonicallyOrderedAddCommMonoid α\ntoMin : Min α\ntoMax : Max α\ntoOrd : Ord α\nle_total : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq : DecidableEq α\ndecidableLT : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\n⊢ Eq (SizeOf.sizeOf (CanonicallyLinearOrderedAddCommMonoid.mk toCanonicallyOrderedAddCommMonoid le_total decidableLE decidableEq decidableLT min_def max_def compare_eq_compareOfLessAndEq)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toCanonicallyOrderedAddCommMonoid)) (SizeOf.sizeOf toMin)) (SizeOf.sizeOf toMax)) (SizeOf.sizeOf toOrd))","decl":"set_option linter.deprecated false in\n/-- A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n    whose ordering is a linear order. -/\n@[deprecated \"Use `[LinearOrderedAddCommMonoid α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedAddCommMonoid (α : Type*)\n  extends CanonicallyOrderedAddCommMonoid α, LinearOrderedAddCommMonoid α\n\n"}
{"name":"CanonicallyLinearOrderedAddCommMonoid.mk.injEq","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ntoCanonicallyOrderedAddCommMonoid✝ : CanonicallyOrderedAddCommMonoid α\ntoMin✝ : Min α\ntoMax✝ : Max α\ntoOrd✝ : Ord α\nle_total✝ : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE✝ : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq✝ : DecidableEq α\ndecidableLT✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def✝ : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def✝ : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq✝ : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\ntoCanonicallyOrderedAddCommMonoid : CanonicallyOrderedAddCommMonoid α\ntoMin : Min α\ntoMax : Max α\ntoOrd : Ord α\nle_total : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq : DecidableEq α\ndecidableLT : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\n⊢ Eq (Eq (CanonicallyLinearOrderedAddCommMonoid.mk toCanonicallyOrderedAddCommMonoid✝ le_total✝ decidableLE✝ decidableEq✝ decidableLT✝ min_def✝ max_def✝ compare_eq_compareOfLessAndEq✝) (CanonicallyLinearOrderedAddCommMonoid.mk toCanonicallyOrderedAddCommMonoid le_total decidableLE decidableEq decidableLT min_def max_def compare_eq_compareOfLessAndEq)) (And (Eq toCanonicallyOrderedAddCommMonoid✝ toCanonicallyOrderedAddCommMonoid) (And (Eq toMin✝ toMin) (And (Eq toMax✝ toMax) (And (Eq toOrd✝ toOrd) (And (HEq decidableLE✝ decidableLE) (And (Eq decidableEq✝ decidableEq) (HEq decidableLT✝ decidableLT)))))))","decl":"set_option linter.deprecated false in\n/-- A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n    whose ordering is a linear order. -/\n@[deprecated \"Use `[LinearOrderedAddCommMonoid α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedAddCommMonoid (α : Type*)\n  extends CanonicallyOrderedAddCommMonoid α, LinearOrderedAddCommMonoid α\n\n"}
{"name":"CanonicallyLinearOrderedAddCommMonoid.le_total","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedAddCommMonoid α\na b : α\n⊢ Or (LE.le a b) (LE.le b a)","decl":"set_option linter.deprecated false in\n/-- A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n    whose ordering is a linear order. -/\n@[deprecated \"Use `[LinearOrderedAddCommMonoid α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedAddCommMonoid (α : Type*)\n  extends CanonicallyOrderedAddCommMonoid α, LinearOrderedAddCommMonoid α\n\n"}
{"name":"CanonicallyLinearOrderedAddCommMonoid.min_def","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedAddCommMonoid α\na b : α\n⊢ Eq (Min.min a b) (ite (LE.le a b) a b)","decl":"set_option linter.deprecated false in\n/-- A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n    whose ordering is a linear order. -/\n@[deprecated \"Use `[LinearOrderedAddCommMonoid α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedAddCommMonoid (α : Type*)\n  extends CanonicallyOrderedAddCommMonoid α, LinearOrderedAddCommMonoid α\n\n"}
{"name":"CanonicallyLinearOrderedAddCommMonoid.max_def","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedAddCommMonoid α\na b : α\n⊢ Eq (Max.max a b) (ite (LE.le a b) b a)","decl":"set_option linter.deprecated false in\n/-- A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n    whose ordering is a linear order. -/\n@[deprecated \"Use `[LinearOrderedAddCommMonoid α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedAddCommMonoid (α : Type*)\n  extends CanonicallyOrderedAddCommMonoid α, LinearOrderedAddCommMonoid α\n\n"}
{"name":"CanonicallyLinearOrderedAddCommMonoid.mk.inj","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ntoCanonicallyOrderedAddCommMonoid✝ : CanonicallyOrderedAddCommMonoid α\ntoMin✝ : Min α\ntoMax✝ : Max α\ntoOrd✝ : Ord α\nle_total✝ : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE✝ : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq✝ : DecidableEq α\ndecidableLT✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def✝ : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def✝ : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq✝ : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\ntoCanonicallyOrderedAddCommMonoid : CanonicallyOrderedAddCommMonoid α\ntoMin : Min α\ntoMax : Max α\ntoOrd : Ord α\nle_total : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq : DecidableEq α\ndecidableLT : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\nx✝ : Eq (CanonicallyLinearOrderedAddCommMonoid.mk toCanonicallyOrderedAddCommMonoid✝ le_total✝ decidableLE✝ decidableEq✝ decidableLT✝ min_def✝ max_def✝ compare_eq_compareOfLessAndEq✝) (CanonicallyLinearOrderedAddCommMonoid.mk toCanonicallyOrderedAddCommMonoid le_total decidableLE decidableEq decidableLT min_def max_def compare_eq_compareOfLessAndEq)\n⊢ And (Eq toCanonicallyOrderedAddCommMonoid✝ toCanonicallyOrderedAddCommMonoid) (And (Eq toMin✝ toMin) (And (Eq toMax✝ toMax) (And (Eq toOrd✝ toOrd) (And (HEq decidableLE✝ decidableLE) (And (Eq decidableEq✝ decidableEq) (HEq decidableLT✝ decidableLT))))))","decl":"set_option linter.deprecated false in\n/-- A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n    whose ordering is a linear order. -/\n@[deprecated \"Use `[LinearOrderedAddCommMonoid α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedAddCommMonoid (α : Type*)\n  extends CanonicallyOrderedAddCommMonoid α, LinearOrderedAddCommMonoid α\n\n"}
{"name":"CanonicallyLinearOrderedCommMonoid.compare_eq_compareOfLessAndEq","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedCommMonoid α\na b : α\n⊢ Eq (Ord.compare a b) (compareOfLessAndEq a b)","decl":"set_option linter.deprecated false in\nset_option linter.existingAttributeWarning false in\n/-- A canonically linear-ordered monoid is a canonically ordered monoid\n    whose ordering is a linear order. -/\n@[to_additive,\n  deprecated \"Use `[LinearOrderedCommMonoid α] [CanonicallyOrderedMul α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedCommMonoid (α : Type*)\n  extends CanonicallyOrderedCommMonoid α, LinearOrderedCommMonoid α\n\n"}
{"name":"CanonicallyLinearOrderedCommMonoid.min_def","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedCommMonoid α\na b : α\n⊢ Eq (Min.min a b) (ite (LE.le a b) a b)","decl":"set_option linter.deprecated false in\nset_option linter.existingAttributeWarning false in\n/-- A canonically linear-ordered monoid is a canonically ordered monoid\n    whose ordering is a linear order. -/\n@[to_additive,\n  deprecated \"Use `[LinearOrderedCommMonoid α] [CanonicallyOrderedMul α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedCommMonoid (α : Type*)\n  extends CanonicallyOrderedCommMonoid α, LinearOrderedCommMonoid α\n\n"}
{"name":"CanonicallyLinearOrderedCommMonoid.le_total","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedCommMonoid α\na b : α\n⊢ Or (LE.le a b) (LE.le b a)","decl":"set_option linter.deprecated false in\nset_option linter.existingAttributeWarning false in\n/-- A canonically linear-ordered monoid is a canonically ordered monoid\n    whose ordering is a linear order. -/\n@[to_additive,\n  deprecated \"Use `[LinearOrderedCommMonoid α] [CanonicallyOrderedMul α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedCommMonoid (α : Type*)\n  extends CanonicallyOrderedCommMonoid α, LinearOrderedCommMonoid α\n\n"}
{"name":"CanonicallyLinearOrderedCommMonoid.mk.injEq","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ntoCanonicallyOrderedCommMonoid✝ : CanonicallyOrderedCommMonoid α\ntoMin✝ : Min α\ntoMax✝ : Max α\ntoOrd✝ : Ord α\nle_total✝ : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE✝ : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq✝ : DecidableEq α\ndecidableLT✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def✝ : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def✝ : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq✝ : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\ntoCanonicallyOrderedCommMonoid : CanonicallyOrderedCommMonoid α\ntoMin : Min α\ntoMax : Max α\ntoOrd : Ord α\nle_total : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq : DecidableEq α\ndecidableLT : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\n⊢ Eq (Eq (CanonicallyLinearOrderedCommMonoid.mk toCanonicallyOrderedCommMonoid✝ le_total✝ decidableLE✝ decidableEq✝ decidableLT✝ min_def✝ max_def✝ compare_eq_compareOfLessAndEq✝) (CanonicallyLinearOrderedCommMonoid.mk toCanonicallyOrderedCommMonoid le_total decidableLE decidableEq decidableLT min_def max_def compare_eq_compareOfLessAndEq)) (And (Eq toCanonicallyOrderedCommMonoid✝ toCanonicallyOrderedCommMonoid) (And (Eq toMin✝ toMin) (And (Eq toMax✝ toMax) (And (Eq toOrd✝ toOrd) (And (HEq decidableLE✝ decidableLE) (And (Eq decidableEq✝ decidableEq) (HEq decidableLT✝ decidableLT)))))))","decl":"set_option linter.deprecated false in\nset_option linter.existingAttributeWarning false in\n/-- A canonically linear-ordered monoid is a canonically ordered monoid\n    whose ordering is a linear order. -/\n@[to_additive,\n  deprecated \"Use `[LinearOrderedCommMonoid α] [CanonicallyOrderedMul α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedCommMonoid (α : Type*)\n  extends CanonicallyOrderedCommMonoid α, LinearOrderedCommMonoid α\n\n"}
{"name":"CanonicallyLinearOrderedCommMonoid.max_def","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedCommMonoid α\na b : α\n⊢ Eq (Max.max a b) (ite (LE.le a b) b a)","decl":"set_option linter.deprecated false in\nset_option linter.existingAttributeWarning false in\n/-- A canonically linear-ordered monoid is a canonically ordered monoid\n    whose ordering is a linear order. -/\n@[to_additive,\n  deprecated \"Use `[LinearOrderedCommMonoid α] [CanonicallyOrderedMul α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedCommMonoid (α : Type*)\n  extends CanonicallyOrderedCommMonoid α, LinearOrderedCommMonoid α\n\n"}
{"name":"CanonicallyLinearOrderedCommMonoid.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ninst✝ : SizeOf α\ntoCanonicallyOrderedCommMonoid : CanonicallyOrderedCommMonoid α\ntoMin : Min α\ntoMax : Max α\ntoOrd : Ord α\nle_total : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq : DecidableEq α\ndecidableLT : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\n⊢ Eq (SizeOf.sizeOf (CanonicallyLinearOrderedCommMonoid.mk toCanonicallyOrderedCommMonoid le_total decidableLE decidableEq decidableLT min_def max_def compare_eq_compareOfLessAndEq)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toCanonicallyOrderedCommMonoid)) (SizeOf.sizeOf toMin)) (SizeOf.sizeOf toMax)) (SizeOf.sizeOf toOrd))","decl":"set_option linter.deprecated false in\nset_option linter.existingAttributeWarning false in\n/-- A canonically linear-ordered monoid is a canonically ordered monoid\n    whose ordering is a linear order. -/\n@[to_additive,\n  deprecated \"Use `[LinearOrderedCommMonoid α] [CanonicallyOrderedMul α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedCommMonoid (α : Type*)\n  extends CanonicallyOrderedCommMonoid α, LinearOrderedCommMonoid α\n\n"}
{"name":"CanonicallyLinearOrderedCommMonoid.mk.inj","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u_1\ntoCanonicallyOrderedCommMonoid✝ : CanonicallyOrderedCommMonoid α\ntoMin✝ : Min α\ntoMax✝ : Max α\ntoOrd✝ : Ord α\nle_total✝ : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE✝ : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq✝ : DecidableEq α\ndecidableLT✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def✝ : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def✝ : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq✝ : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\ntoCanonicallyOrderedCommMonoid : CanonicallyOrderedCommMonoid α\ntoMin : Min α\ntoMax : Max α\ntoOrd : Ord α\nle_total : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq : DecidableEq α\ndecidableLT : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\nx✝ : Eq (CanonicallyLinearOrderedCommMonoid.mk toCanonicallyOrderedCommMonoid✝ le_total✝ decidableLE✝ decidableEq✝ decidableLT✝ min_def✝ max_def✝ compare_eq_compareOfLessAndEq✝) (CanonicallyLinearOrderedCommMonoid.mk toCanonicallyOrderedCommMonoid le_total decidableLE decidableEq decidableLT min_def max_def compare_eq_compareOfLessAndEq)\n⊢ And (Eq toCanonicallyOrderedCommMonoid✝ toCanonicallyOrderedCommMonoid) (And (Eq toMin✝ toMin) (And (Eq toMax✝ toMax) (And (Eq toOrd✝ toOrd) (And (HEq decidableLE✝ decidableLE) (And (Eq decidableEq✝ decidableEq) (HEq decidableLT✝ decidableLT))))))","decl":"set_option linter.deprecated false in\nset_option linter.existingAttributeWarning false in\n/-- A canonically linear-ordered monoid is a canonically ordered monoid\n    whose ordering is a linear order. -/\n@[to_additive,\n  deprecated \"Use `[LinearOrderedCommMonoid α] [CanonicallyOrderedMul α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedCommMonoid (α : Type*)\n  extends CanonicallyOrderedCommMonoid α, LinearOrderedCommMonoid α\n\n"}
{"name":"min_mul_distrib","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedCommMonoid α\ninst✝ : CanonicallyOrderedMul α\na b c : α\n⊢ Eq (Min.min a (HMul.hMul b c)) (Min.min a (HMul.hMul (Min.min a b) (Min.min a c)))","decl":"@[to_additive]\ntheorem min_mul_distrib (a b c : α) : min a (b * c) = min a (min a b * min a c) := by\n  rcases le_total a b with hb | hb\n  · simp [hb, le_mul_right]\n  · rcases le_total a c with hc | hc\n    · simp [hc, le_mul_left]\n    · simp [hb, hc]\n\n"}
{"name":"min_add_distrib","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedAddCommMonoid α\ninst✝ : CanonicallyOrderedAdd α\na b c : α\n⊢ Eq (Min.min a (HAdd.hAdd b c)) (Min.min a (HAdd.hAdd (Min.min a b) (Min.min a c)))","decl":"@[to_additive]\ntheorem min_mul_distrib (a b c : α) : min a (b * c) = min a (min a b * min a c) := by\n  rcases le_total a b with hb | hb\n  · simp [hb, le_mul_right]\n  · rcases le_total a c with hc | hc\n    · simp [hc, le_mul_left]\n    · simp [hb, hc]\n\n"}
{"name":"min_add_distrib'","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedAddCommMonoid α\ninst✝ : CanonicallyOrderedAdd α\na b c : α\n⊢ Eq (Min.min (HAdd.hAdd a b) c) (Min.min (HAdd.hAdd (Min.min a c) (Min.min b c)) c)","decl":"@[to_additive]\ntheorem min_mul_distrib' (a b c : α) : min (a * b) c = min (min a c * min b c) c := by\n  simpa [min_comm _ c] using min_mul_distrib c a b\n\n"}
{"name":"min_mul_distrib'","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedCommMonoid α\ninst✝ : CanonicallyOrderedMul α\na b c : α\n⊢ Eq (Min.min (HMul.hMul a b) c) (Min.min (HMul.hMul (Min.min a c) (Min.min b c)) c)","decl":"@[to_additive]\ntheorem min_mul_distrib' (a b c : α) : min (a * b) c = min (min a c * min b c) c := by\n  simpa [min_comm _ c] using min_mul_distrib c a b\n\n"}
{"name":"one_min","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedCommMonoid α\ninst✝ : CanonicallyOrderedMul α\na : α\n⊢ Eq (Min.min 1 a) 1","decl":"@[to_additive]\ntheorem one_min (a : α) : min 1 a = 1 :=\n  min_eq_left (one_le a)\n\n"}
{"name":"zero_min","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedAddCommMonoid α\ninst✝ : CanonicallyOrderedAdd α\na : α\n⊢ Eq (Min.min 0 a) 0","decl":"@[to_additive]\ntheorem one_min (a : α) : min 1 a = 1 :=\n  min_eq_left (one_le a)\n\n"}
{"name":"min_zero","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedAddCommMonoid α\ninst✝ : CanonicallyOrderedAdd α\na : α\n⊢ Eq (Min.min a 0) 0","decl":"@[to_additive]\ntheorem min_one (a : α) : min a 1 = 1 :=\n  min_eq_right (one_le a)\n\n"}
{"name":"min_one","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedCommMonoid α\ninst✝ : CanonicallyOrderedMul α\na : α\n⊢ Eq (Min.min a 1) 1","decl":"@[to_additive]\ntheorem min_one (a : α) : min a 1 = 1 :=\n  min_eq_right (one_le a)\n\n"}
{"name":"bot_eq_one'","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedCommMonoid α\ninst✝ : CanonicallyOrderedMul α\n⊢ Eq Bot.bot 1","decl":"/-- In a linearly ordered monoid, we are happy for `bot_eq_one` to be a `@[simp]` lemma. -/\n@[to_additive (attr := simp)\n  \"In a linearly ordered monoid, we are happy for `bot_eq_zero` to be a `@[simp]` lemma\"]\ntheorem bot_eq_one' : (⊥ : α) = 1 :=\n  bot_eq_one\n\n"}
{"name":"bot_eq_zero'","module":"Mathlib.Algebra.Order.Monoid.Canonical.Defs","initialProofState":"α : Type u\ninst✝¹ : LinearOrderedAddCommMonoid α\ninst✝ : CanonicallyOrderedAdd α\n⊢ Eq Bot.bot 0","decl":"/-- In a linearly ordered monoid, we are happy for `bot_eq_one` to be a `@[simp]` lemma. -/\n@[to_additive (attr := simp)\n  \"In a linearly ordered monoid, we are happy for `bot_eq_zero` to be a `@[simp]` lemma\"]\ntheorem bot_eq_one' : (⊥ : α) = 1 :=\n  bot_eq_one\n\n"}
