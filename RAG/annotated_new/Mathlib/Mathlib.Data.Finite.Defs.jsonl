{"name":"finite_iff_exists_equiv_fin","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_3\n⊢ Iff (Finite α) (Exists fun n => Nonempty (Equiv α (Fin n)))","decl":"theorem finite_iff_exists_equiv_fin {α : Sort*} : Finite α ↔ ∃ n, Nonempty (α ≃ Fin n) :=\n  ⟨fun ⟨e⟩ => ⟨_, ⟨e⟩⟩, fun ⟨_, ⟨e⟩⟩ => ⟨e⟩⟩\n\n"}
{"name":"Finite.exists_equiv_fin","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_3\nh : Finite α\n⊢ Exists fun n => Nonempty (Equiv α (Fin n))","decl":"theorem Finite.exists_equiv_fin (α : Sort*) [h : Finite α] : ∃ n : ℕ, Nonempty (α ≃ Fin n) :=\n  finite_iff_exists_equiv_fin.mp h\n\n"}
{"name":"Finite.of_equiv","module":"Mathlib.Data.Finite.Defs","initialProofState":"β : Sort u_2\nα : Sort u_3\nh : Finite α\nf : Equiv α β\n⊢ Finite β","decl":"theorem Finite.of_equiv (α : Sort*) [h : Finite α] (f : α ≃ β) : Finite β :=\n  let ⟨e⟩ := h; ⟨f.symm.trans e⟩\n\n"}
{"name":"Equiv.finite_iff","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : Equiv α β\n⊢ Iff (Finite α) (Finite β)","decl":"theorem Equiv.finite_iff (f : α ≃ β) : Finite α ↔ Finite β :=\n  ⟨fun _ => Finite.of_equiv _ f, fun _ => Finite.of_equiv _ f.symm⟩\n\n"}
{"name":"Function.Bijective.finite_iff","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nh : Function.Bijective f\n⊢ Iff (Finite α) (Finite β)","decl":"theorem Function.Bijective.finite_iff {f : α → β} (h : Bijective f) : Finite α ↔ Finite β :=\n  (Equiv.ofBijective f h).finite_iff\n\n"}
{"name":"Finite.ofBijective","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Finite α\nf : α → β\nh : Function.Bijective f\n⊢ Finite β","decl":"theorem Finite.ofBijective [Finite α] {f : α → β} (h : Bijective f) : Finite β :=\n  h.finite_iff.mp ‹_›\n\n"}
{"name":"Finite.nonempty_decidableEq","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_1\ninst✝ : Finite α\n⊢ Nonempty (DecidableEq α)","decl":"variable (α) in\ntheorem Finite.nonempty_decidableEq [Finite α] : Nonempty (DecidableEq α) :=\n  let ⟨_n, ⟨e⟩⟩ := Finite.exists_equiv_fin α; ⟨e.decidableEq⟩\n\n"}
{"name":"instFinitePLift","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_1\ninst✝ : Finite α\n⊢ Finite (PLift α)","decl":"instance [Finite α] : Finite (PLift α) :=\n  Finite.of_equiv α Equiv.plift.symm\n\n"}
{"name":"instFiniteULift","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Type v\ninst✝ : Finite α\n⊢ Finite (ULift.{u, v} α)","decl":"instance {α : Type v} [Finite α] : Finite (ULift.{u} α) :=\n  Finite.of_equiv α Equiv.ulift.symm\n\n"}
{"name":"Infinite.not_finite","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_3\nself : Infinite α\n⊢ Not (Finite α)","decl":"/-- A type is said to be infinite if it is not finite. Note that `Infinite α` is equivalent to\n`IsEmpty (Fintype α)` or `IsEmpty (Finite α)`. -/\nclass Infinite (α : Sort*) : Prop where\n  /-- assertion that `α` is `¬Finite`-/\n  not_finite : ¬Finite α\n\n"}
{"name":"not_finite_iff_infinite","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_1\n⊢ Iff (Not (Finite α)) (Infinite α)","decl":"@[simp]\ntheorem not_finite_iff_infinite : ¬Finite α ↔ Infinite α :=\n  ⟨Infinite.mk, fun h => h.1⟩\n\n"}
{"name":"not_infinite_iff_finite","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_1\n⊢ Iff (Not (Infinite α)) (Finite α)","decl":"@[simp]\ntheorem not_infinite_iff_finite : ¬Infinite α ↔ Finite α :=\n  not_finite_iff_infinite.not_right.symm\n\n"}
{"name":"Equiv.infinite_iff","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\ne : Equiv α β\n⊢ Iff (Infinite α) (Infinite β)","decl":"theorem Equiv.infinite_iff (e : α ≃ β) : Infinite α ↔ Infinite β :=\n  not_finite_iff_infinite.symm.trans <| e.finite_iff.not.trans not_finite_iff_infinite\n\n"}
{"name":"instInfinitePLift","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_1\ninst✝ : Infinite α\n⊢ Infinite (PLift α)","decl":"instance [Infinite α] : Infinite (PLift α) :=\n  Equiv.plift.infinite_iff.2 ‹_›\n\n"}
{"name":"instInfiniteULift","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Type v\ninst✝ : Infinite α\n⊢ Infinite (ULift.{u, v} α)","decl":"instance {α : Type v} [Infinite α] : Infinite (ULift.{u} α) :=\n  Equiv.ulift.infinite_iff.2 ‹_›\n\n"}
{"name":"finite_or_infinite","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_3\n⊢ Or (Finite α) (Infinite α)","decl":"theorem finite_or_infinite (α : Sort*) : Finite α ∨ Infinite α :=\n  or_iff_not_imp_left.2 not_finite_iff_infinite.1\n\n"}
{"name":"not_finite","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_3\ninst✝¹ : Infinite α\ninst✝ : Finite α\n⊢ False","decl":"/-- `Infinite α` is not `Finite`-/\ntheorem not_finite (α : Sort*) [Infinite α] [Finite α] : False :=\n  @Infinite.not_finite α ‹_› ‹_›\n\n"}
{"name":"Finite.false","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_1\ninst✝ : Infinite α\nx✝ : Finite α\n⊢ False","decl":"protected theorem Finite.false [Infinite α] (_ : Finite α) : False :=\n  not_finite α\n\n"}
{"name":"Infinite.false","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_1\ninst✝ : Finite α\nx✝ : Infinite α\n⊢ False","decl":"protected theorem Infinite.false [Finite α] (_ : Infinite α) : False :=\n  @Infinite.not_finite α ‹_› ‹_›\n\n"}
{"name":"Finite.not_infinite","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_1\na✝ : Finite α\n⊢ Not (Infinite α)","decl":"alias ⟨Finite.of_not_infinite, Finite.not_infinite⟩ := not_infinite_iff_finite\n\n"}
{"name":"Finite.of_not_infinite","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Sort u_1\na✝ : Not (Infinite α)\n⊢ Finite α","decl":"alias ⟨Finite.of_not_infinite, Finite.not_infinite⟩ := not_infinite_iff_finite\n\n"}
{"name":"Bool.instFinite","module":"Mathlib.Data.Finite.Defs","initialProofState":"⊢ Finite Bool","decl":"instance Bool.instFinite : Finite Bool := .intro finTwoEquiv.symm\n"}
{"name":"Prop.instFinite","module":"Mathlib.Data.Finite.Defs","initialProofState":"⊢ Finite Prop","decl":"instance Prop.instFinite : Finite Prop := .of_equiv _ Equiv.propEquivBool.symm\n\n"}
{"name":"Set.finite_coe_iff","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Finite ↑s) s.Finite","decl":"theorem finite_coe_iff {s : Set α} : Finite s ↔ s.Finite := .rfl\n\n"}
{"name":"Set.toFinite","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Type u\ns : Set α\ninst✝ : Finite ↑s\n⊢ s.Finite","decl":"/-- Constructor for `Set.Finite` using a `Finite` instance. -/\ntheorem toFinite (s : Set α) [Finite s] : s.Finite := ‹_›\n\n"}
{"name":"Set.Finite.to_subtype","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Type u\ns : Set α\nh : s.Finite\n⊢ Finite ↑s","decl":"/-- Projection of `Set.Finite` to its `Finite` instance.\nThis is intended to be used with dot notation.\nSee also `Set.Finite.Fintype` and `Set.Finite.nonempty_fintype`. -/\nprotected theorem Finite.to_subtype {s : Set α} (h : s.Finite) : Finite s := h\n\n"}
{"name":"Set.not_infinite","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Not s.Infinite) s.Finite","decl":"@[simp]\ntheorem not_infinite {s : Set α} : ¬s.Infinite ↔ s.Finite :=\n  not_not\n\n"}
{"name":"Set.Finite.not_infinite","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Type u\ns : Set α\na✝ : s.Finite\n⊢ Not s.Infinite","decl":"alias ⟨_, Finite.not_infinite⟩ := not_infinite\n\n"}
{"name":"Set.finite_or_infinite","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Type u\ns : Set α\n⊢ Or s.Finite s.Infinite","decl":"/-- See also `finite_or_infinite`, `fintypeOrInfinite`. -/\nprotected theorem finite_or_infinite (s : Set α) : s.Finite ∨ s.Infinite :=\n  em _\n\n"}
{"name":"Set.infinite_or_finite","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Type u\ns : Set α\n⊢ Or s.Infinite s.Finite","decl":"protected theorem infinite_or_finite (s : Set α) : s.Infinite ∨ s.Finite :=\n  em' _\n\n"}
{"name":"Equiv.set_finite_iff","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nt : Set β\nhst : Equiv ↑s ↑t\n⊢ Iff s.Finite t.Finite","decl":"theorem Equiv.set_finite_iff {s : Set α} {t : Set β} (hst : s ≃ t) : s.Finite ↔ t.Finite := by\n  simp_rw [← Set.finite_coe_iff, hst.finite_iff]\n\n"}
{"name":"Set.infinite_coe_iff","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Infinite ↑s) s.Infinite","decl":"theorem infinite_coe_iff {s : Set α} : Infinite s ↔ s.Infinite :=\n  not_finite_iff_infinite.symm.trans finite_coe_iff.not\n\n-- Porting note: something weird happened here\n"}
{"name":"Set.Infinite.to_subtype","module":"Mathlib.Data.Finite.Defs","initialProofState":"α : Type u\ns : Set α\na✝ : s.Infinite\n⊢ Infinite ↑s","decl":"alias ⟨_, Infinite.to_subtype⟩ := infinite_coe_iff\n\n"}
