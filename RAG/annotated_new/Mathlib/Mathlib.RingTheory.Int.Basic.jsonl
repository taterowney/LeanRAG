{"name":"Int.gcd_eq_one_iff_coprime","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"a b : Int\n⊢ Iff (Eq (a.gcd b) 1) (IsCoprime a b)","decl":"@[deprecated \"use `isCoprime_iff_gcd_eq_one.symm` instead\" (since := \"2025-01-23\")]\ntheorem gcd_eq_one_iff_coprime {a b : ℤ} : Int.gcd a b = 1 ↔ IsCoprime a b :=\n  isCoprime_iff_gcd_eq_one.symm\n\n\n"}
{"name":"Int.isCoprime_iff_nat_coprime","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"a b : Int\n⊢ Iff (IsCoprime a b) (a.natAbs.Coprime b.natAbs)","decl":"theorem isCoprime_iff_nat_coprime {a b : ℤ} : IsCoprime a b ↔ Nat.Coprime a.natAbs b.natAbs := by\n  rw [isCoprime_iff_gcd_eq_one, Nat.coprime_iff_gcd_eq_one, gcd_eq_natAbs]\n\n"}
{"name":"Int.coprime_iff_nat_coprime","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"a b : Int\n⊢ Iff (IsCoprime a b) (a.natAbs.Coprime b.natAbs)","decl":"@[deprecated (since := \"2025-01-23\")] alias coprime_iff_nat_coprime := isCoprime_iff_nat_coprime\n\n"}
{"name":"Int.gcd_ne_one_iff_gcd_mul_right_ne_one","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"a : Int\nm n : Nat\n⊢ Iff (Ne (a.gcd (HMul.hMul ↑m ↑n)) 1) (Or (Ne (a.gcd ↑m) 1) (Ne (a.gcd ↑n) 1))","decl":"/-- If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. -/\ntheorem gcd_ne_one_iff_gcd_mul_right_ne_one {a : ℤ} {m n : ℕ} :\n    a.gcd (m * n) ≠ 1 ↔ a.gcd m ≠ 1 ∨ a.gcd n ≠ 1 := by\n  simp only [← isCoprime_iff_gcd_eq_one, ← not_and_or, not_iff_not, IsCoprime.mul_right_iff]\n\n"}
{"name":"Int.sq_of_gcd_eq_one","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"a b c : Int\nh : Eq (a.gcd b) 1\nheq : Eq (HMul.hMul a b) (HPow.hPow c 2)\n⊢ Exists fun a0 => Or (Eq a (HPow.hPow a0 2)) (Eq a (Neg.neg (HPow.hPow a0 2)))","decl":"theorem sq_of_gcd_eq_one {a b c : ℤ} (h : Int.gcd a b = 1) (heq : a * b = c ^ 2) :\n    ∃ a0 : ℤ, a = a0 ^ 2 ∨ a = -a0 ^ 2 := by\n  have h' : IsUnit (GCDMonoid.gcd a b) := by\n    rw [← coe_gcd, h, Int.ofNat_one]\n    exact isUnit_one\n  obtain ⟨d, ⟨u, hu⟩⟩ := exists_associated_pow_of_mul_eq_pow h' heq\n  use d\n  rw [← hu]\n  cases' Int.units_eq_one_or u with hu' hu' <;>\n    · rw [hu']\n      simp\n\n"}
{"name":"Int.sq_of_isCoprime","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"a b c : Int\nh : IsCoprime a b\nheq : Eq (HMul.hMul a b) (HPow.hPow c 2)\n⊢ Exists fun a0 => Or (Eq a (HPow.hPow a0 2)) (Eq a (Neg.neg (HPow.hPow a0 2)))","decl":"theorem sq_of_isCoprime {a b c : ℤ} (h : IsCoprime a b) (heq : a * b = c ^ 2) :\n    ∃ a0 : ℤ, a = a0 ^ 2 ∨ a = -a0 ^ 2 :=\n  sq_of_gcd_eq_one (isCoprime_iff_gcd_eq_one.mp h) heq\n\n"}
{"name":"Int.sq_of_coprime","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"a b c : Int\nh : IsCoprime a b\nheq : Eq (HMul.hMul a b) (HPow.hPow c 2)\n⊢ Exists fun a0 => Or (Eq a (HPow.hPow a0 2)) (Eq a (Neg.neg (HPow.hPow a0 2)))","decl":"@[deprecated (since := \"2025-01-23\")] alias sq_of_coprime := sq_of_isCoprime\n\n"}
{"name":"Int.natAbs_euclideanDomain_gcd","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"a b : Int\n⊢ Eq (EuclideanDomain.gcd a b).natAbs (a.gcd b)","decl":"theorem natAbs_euclideanDomain_gcd (a b : ℤ) :\n    Int.natAbs (EuclideanDomain.gcd a b) = Int.gcd a b := by\n  apply Nat.dvd_antisymm <;> rw [← Int.natCast_dvd_natCast]\n  · rw [Int.natAbs_dvd]\n    exact Int.dvd_gcd (EuclideanDomain.gcd_dvd_left _ _) (EuclideanDomain.gcd_dvd_right _ _)\n  · rw [Int.dvd_natAbs]\n    exact EuclideanDomain.dvd_gcd Int.gcd_dvd_left Int.gcd_dvd_right\n\n"}
{"name":"Int.Prime.dvd_mul","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"m n : Int\np : Nat\nhp : Nat.Prime p\nh : Dvd.dvd (↑p) (HMul.hMul m n)\n⊢ Or (Dvd.dvd p m.natAbs) (Dvd.dvd p n.natAbs)","decl":"theorem Int.Prime.dvd_mul {m n : ℤ} {p : ℕ} (hp : Nat.Prime p) (h : (p : ℤ) ∣ m * n) :\n    p ∣ m.natAbs ∨ p ∣ n.natAbs := by\n  rwa [← hp.dvd_mul, ← Int.natAbs_mul, ← Int.natCast_dvd]\n\n"}
{"name":"Int.Prime.dvd_mul'","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"m n : Int\np : Nat\nhp : Nat.Prime p\nh : Dvd.dvd (↑p) (HMul.hMul m n)\n⊢ Or (Dvd.dvd (↑p) m) (Dvd.dvd (↑p) n)","decl":"theorem Int.Prime.dvd_mul' {m n : ℤ} {p : ℕ} (hp : Nat.Prime p) (h : (p : ℤ) ∣ m * n) :\n    (p : ℤ) ∣ m ∨ (p : ℤ) ∣ n := by\n  rw [Int.natCast_dvd, Int.natCast_dvd]\n  exact Int.Prime.dvd_mul hp h\n\n"}
{"name":"Int.Prime.dvd_pow","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"n : Int\nk p : Nat\nhp : Nat.Prime p\nh : Dvd.dvd (↑p) (HPow.hPow n k)\n⊢ Dvd.dvd p n.natAbs","decl":"theorem Int.Prime.dvd_pow {n : ℤ} {k p : ℕ} (hp : Nat.Prime p) (h : (p : ℤ) ∣ n ^ k) :\n    p ∣ n.natAbs := by\n  rw [Int.natCast_dvd, Int.natAbs_pow] at h\n  exact hp.dvd_of_dvd_pow h\n\n"}
{"name":"Int.Prime.dvd_pow'","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"n : Int\nk p : Nat\nhp : Nat.Prime p\nh : Dvd.dvd (↑p) (HPow.hPow n k)\n⊢ Dvd.dvd (↑p) n","decl":"theorem Int.Prime.dvd_pow' {n : ℤ} {k p : ℕ} (hp : Nat.Prime p) (h : (p : ℤ) ∣ n ^ k) :\n    (p : ℤ) ∣ n := by\n  rw [Int.natCast_dvd]\n  exact Int.Prime.dvd_pow hp h\n\n"}
{"name":"prime_two_or_dvd_of_dvd_two_mul_pow_self_two","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"m : Int\np : Nat\nhp : Nat.Prime p\nh : Dvd.dvd (↑p) (HMul.hMul 2 (HPow.hPow m 2))\n⊢ Or (Eq p 2) (Dvd.dvd p m.natAbs)","decl":"theorem prime_two_or_dvd_of_dvd_two_mul_pow_self_two {m : ℤ} {p : ℕ} (hp : Nat.Prime p)\n    (h : (p : ℤ) ∣ 2 * m ^ 2) : p = 2 ∨ p ∣ Int.natAbs m := by\n  cases' Int.Prime.dvd_mul hp h with hp2 hpp\n  · apply Or.intro_left\n    exact le_antisymm (Nat.le_of_dvd zero_lt_two hp2) (Nat.Prime.two_le hp)\n  · apply Or.intro_right\n    rw [sq, Int.natAbs_mul] at hpp\n    exact or_self_iff.mp ((Nat.Prime.dvd_mul hp).mp hpp)\n\n"}
{"name":"Int.exists_prime_and_dvd","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"n : Int\nhn : Ne n.natAbs 1\n⊢ Exists fun p => And (Prime p) (Dvd.dvd p n)","decl":"theorem Int.exists_prime_and_dvd {n : ℤ} (hn : n.natAbs ≠ 1) : ∃ p, Prime p ∧ p ∣ n := by\n  obtain ⟨p, pp, pd⟩ := Nat.exists_prime_and_dvd hn\n  exact ⟨p, Nat.prime_iff_prime_int.mp pp, Int.natCast_dvd.mpr pd⟩\n\n\n"}
{"name":"Int.prime_iff_natAbs_prime","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"k : Int\n⊢ Iff (Prime k) (Nat.Prime k.natAbs)","decl":"theorem Int.prime_iff_natAbs_prime {k : ℤ} : Prime k ↔ Nat.Prime k.natAbs :=\n  (Int.associated_natAbs k).prime_iff.trans Nat.prime_iff_prime_int.symm\n\n"}
{"name":"Int.zmultiples_natAbs","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"a : Int\n⊢ Eq (AddSubgroup.zmultiples ↑a.natAbs) (AddSubgroup.zmultiples a)","decl":"theorem zmultiples_natAbs (a : ℤ) :\n    AddSubgroup.zmultiples (a.natAbs : ℤ) = AddSubgroup.zmultiples a :=\n  le_antisymm (AddSubgroup.zmultiples_le_of_mem (mem_zmultiples_iff.mpr (dvd_natAbs.mpr dvd_rfl)))\n    (AddSubgroup.zmultiples_le_of_mem (mem_zmultiples_iff.mpr (natAbs_dvd.mpr dvd_rfl)))\n\n"}
{"name":"Int.span_natAbs","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"a : Int\n⊢ Eq (Ideal.span (Singleton.singleton ↑a.natAbs)) (Ideal.span (Singleton.singleton a))","decl":"theorem span_natAbs (a : ℤ) : Ideal.span ({(a.natAbs : ℤ)} : Set ℤ) = Ideal.span {a} := by\n  rw [Ideal.span_singleton_eq_span_singleton]\n  exact (associated_natAbs _).symm\n\n"}
{"name":"Int.eq_pow_of_mul_eq_pow_odd_left","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"a b c : Int\nhab : IsCoprime a b\nk : Nat\nhk : Odd k\nh : Eq (HMul.hMul a b) (HPow.hPow c k)\n⊢ Exists fun d => Eq a (HPow.hPow d k)","decl":"theorem eq_pow_of_mul_eq_pow_odd_left {a b c : ℤ} (hab : IsCoprime a b) {k : ℕ} (hk : Odd k)\n    (h : a * b = c ^ k) : ∃ d, a = d ^ k := by\n  obtain ⟨d, hd⟩ := exists_associated_pow_of_mul_eq_pow' hab h\n  replace hd := hd.symm\n  rw [associated_iff_natAbs, natAbs_eq_natAbs_iff, ← hk.neg_pow] at hd\n  obtain rfl | rfl := hd <;> exact ⟨_, rfl⟩\n\n"}
{"name":"Int.eq_pow_of_mul_eq_pow_odd_right","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"a b c : Int\nhab : IsCoprime a b\nk : Nat\nhk : Odd k\nh : Eq (HMul.hMul a b) (HPow.hPow c k)\n⊢ Exists fun d => Eq b (HPow.hPow d k)","decl":"theorem eq_pow_of_mul_eq_pow_odd_right {a b c : ℤ} (hab : IsCoprime a b) {k : ℕ} (hk : Odd k)\n    (h : a * b = c ^ k) : ∃ d, b = d ^ k :=\n  eq_pow_of_mul_eq_pow_odd_left (c := c) hab.symm hk (by rwa [mul_comm] at h)\n\n"}
{"name":"Int.eq_pow_of_mul_eq_pow_odd","module":"Mathlib.RingTheory.Int.Basic","initialProofState":"a b c : Int\nhab : IsCoprime a b\nk : Nat\nhk : Odd k\nh : Eq (HMul.hMul a b) (HPow.hPow c k)\n⊢ And (Exists fun d => Eq a (HPow.hPow d k)) (Exists fun e => Eq b (HPow.hPow e k))","decl":"theorem eq_pow_of_mul_eq_pow_odd {a b c : ℤ} (hab : IsCoprime a b) {k : ℕ} (hk : Odd k)\n    (h : a * b = c ^ k) : (∃ d, a = d ^ k) ∧ ∃ e, b = e ^ k :=\n  ⟨eq_pow_of_mul_eq_pow_odd_left hab hk h, eq_pow_of_mul_eq_pow_odd_right hab hk h⟩\n\n"}
