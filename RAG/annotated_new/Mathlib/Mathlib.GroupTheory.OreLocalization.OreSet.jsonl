{"name":"AddOreLocalization.AddOreSet.ore_eq","module":"Mathlib.GroupTheory.OreLocalization.OreSet","initialProofState":"R : Type u_1\ninst✝ : AddMonoid R\nS : AddSubmonoid R\nself : AddOreLocalization.AddOreSet S\nr : R\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (↑(AddOreLocalization.AddOreSet.oreSubtra r s)) r) (HAdd.hAdd (AddOreLocalization.AddOreSet.oreMin r s) ↑s)","decl":"/-- A submonoid `S` of an additive monoid `R` is (left) Ore if common summands on the right can be\nturned into common summands on the left, and if each pair of `r : R` and `s : S` admits an Ore\nminuend `v : R` and an Ore subtrahend `u : S` such that `u + r = v + s`. -/\nclass AddOreSet {R : Type*} [AddMonoid R] (S : AddSubmonoid R) where\n  /-- Common summands on the right can be turned into common summands on the left, a weak form of\ncancellability. -/\n  ore_right_cancel : ∀ (r₁ r₂ : R) (s : S), r₁ + s = r₂ + s → ∃ s' : S, s' + r₁ = s' + r₂\n  /-- The Ore minuend of a difference. -/\n  oreMin : R → S → R\n  /-- The Ore subtrahend of a difference. -/\n  oreSubtra : R → S → S\n  /-- The Ore condition of a difference, expressed in terms of `oreMin` and `oreSubtra`. -/\n  ore_eq : ∀ (r : R) (s : S), oreSubtra r s + r = oreMin r s + s\n\n"}
{"name":"AddOreLocalization.AddOreSet.ore_right_cancel","module":"Mathlib.GroupTheory.OreLocalization.OreSet","initialProofState":"R : Type u_1\ninst✝ : AddMonoid R\nS : AddSubmonoid R\nself : AddOreLocalization.AddOreSet S\nr₁ r₂ : R\ns : Subtype fun x => Membership.mem S x\na✝ : Eq (HAdd.hAdd r₁ ↑s) (HAdd.hAdd r₂ ↑s)\n⊢ Exists fun s' => Eq (HAdd.hAdd (↑s') r₁) (HAdd.hAdd (↑s') r₂)","decl":"/-- A submonoid `S` of an additive monoid `R` is (left) Ore if common summands on the right can be\nturned into common summands on the left, and if each pair of `r : R` and `s : S` admits an Ore\nminuend `v : R` and an Ore subtrahend `u : S` such that `u + r = v + s`. -/\nclass AddOreSet {R : Type*} [AddMonoid R] (S : AddSubmonoid R) where\n  /-- Common summands on the right can be turned into common summands on the left, a weak form of\ncancellability. -/\n  ore_right_cancel : ∀ (r₁ r₂ : R) (s : S), r₁ + s = r₂ + s → ∃ s' : S, s' + r₁ = s' + r₂\n  /-- The Ore minuend of a difference. -/\n  oreMin : R → S → R\n  /-- The Ore subtrahend of a difference. -/\n  oreSubtra : R → S → S\n  /-- The Ore condition of a difference, expressed in terms of `oreMin` and `oreSubtra`. -/\n  ore_eq : ∀ (r : R) (s : S), oreSubtra r s + r = oreMin r s + s\n\n"}
{"name":"OreLocalization.OreSet.ore_eq","module":"Mathlib.GroupTheory.OreLocalization.OreSet","initialProofState":"R : Type u_1\ninst✝ : Monoid R\nS : Submonoid R\nself : OreLocalization.OreSet S\nr : R\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (↑(OreLocalization.OreSet.oreDenom r s)) r) (HMul.hMul (OreLocalization.OreSet.oreNum r s) ↑s)","decl":"/-- A submonoid `S` of a monoid `R` is (left) Ore if common factors on the right can be turned\ninto common factors on the left, and if each pair of `r : R` and `s : S` admits an Ore numerator\n`v : R` and an Ore denominator `u : S` such that `u * r = v * s`. -/\n@[to_additive AddOreLocalization.AddOreSet]\nclass OreSet {R : Type*} [Monoid R] (S : Submonoid R) where\n  /-- Common factors on the right can be turned into common factors on the left, a weak form of\ncancellability. -/\n  ore_right_cancel : ∀ (r₁ r₂ : R) (s : S), r₁ * s = r₂ * s → ∃ s' : S, s' * r₁ = s' * r₂\n  /-- The Ore numerator of a fraction. -/\n  oreNum : R → S → R\n  /-- The Ore denominator of a fraction. -/\n  oreDenom : R → S → S\n  /-- The Ore condition of a fraction, expressed in terms of `oreNum` and `oreDenom`. -/\n  ore_eq : ∀ (r : R) (s : S), oreDenom r s * r = oreNum r s * s\n\n-- TODO: use this once it's available.\n-- run_cmd to_additive.map_namespace `OreLocalization `AddOreLocalization\n\n"}
{"name":"OreLocalization.OreSet.ore_right_cancel","module":"Mathlib.GroupTheory.OreLocalization.OreSet","initialProofState":"R : Type u_1\ninst✝ : Monoid R\nS : Submonoid R\nself : OreLocalization.OreSet S\nr₁ r₂ : R\ns : Subtype fun x => Membership.mem S x\na✝ : Eq (HMul.hMul r₁ ↑s) (HMul.hMul r₂ ↑s)\n⊢ Exists fun s' => Eq (HMul.hMul (↑s') r₁) (HMul.hMul (↑s') r₂)","decl":"/-- A submonoid `S` of a monoid `R` is (left) Ore if common factors on the right can be turned\ninto common factors on the left, and if each pair of `r : R` and `s : S` admits an Ore numerator\n`v : R` and an Ore denominator `u : S` such that `u * r = v * s`. -/\n@[to_additive AddOreLocalization.AddOreSet]\nclass OreSet {R : Type*} [Monoid R] (S : Submonoid R) where\n  /-- Common factors on the right can be turned into common factors on the left, a weak form of\ncancellability. -/\n  ore_right_cancel : ∀ (r₁ r₂ : R) (s : S), r₁ * s = r₂ * s → ∃ s' : S, s' * r₁ = s' * r₂\n  /-- The Ore numerator of a fraction. -/\n  oreNum : R → S → R\n  /-- The Ore denominator of a fraction. -/\n  oreDenom : R → S → S\n  /-- The Ore condition of a fraction, expressed in terms of `oreNum` and `oreDenom`. -/\n  ore_eq : ∀ (r : R) (s : S), oreDenom r s * r = oreNum r s * s\n\n-- TODO: use this once it's available.\n-- run_cmd to_additive.map_namespace `OreLocalization `AddOreLocalization\n\n"}
{"name":"OreLocalization.ore_right_cancel","module":"Mathlib.GroupTheory.OreLocalization.OreSet","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nr₁ r₂ : R\ns : Subtype fun x => Membership.mem S x\nh : Eq (HMul.hMul r₁ ↑s) (HMul.hMul r₂ ↑s)\n⊢ Exists fun s' => Eq (HMul.hMul (↑s') r₁) (HMul.hMul (↑s') r₂)","decl":"/-- Common factors on the right can be turned into common factors on the left, a weak form of\ncancellability. -/\n@[to_additive AddOreLocalization.ore_right_cancel]\ntheorem ore_right_cancel (r₁ r₂ : R) (s : S) (h : r₁ * s = r₂ * s) : ∃ s' : S, s' * r₁ = s' * r₂ :=\n  OreSet.ore_right_cancel r₁ r₂ s h\n\n"}
{"name":"AddOreLocalization.ore_right_cancel","module":"Mathlib.GroupTheory.OreLocalization.OreSet","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nr₁ r₂ : R\ns : Subtype fun x => Membership.mem S x\nh : Eq (HAdd.hAdd r₁ ↑s) (HAdd.hAdd r₂ ↑s)\n⊢ Exists fun s' => Eq (HAdd.hAdd (↑s') r₁) (HAdd.hAdd (↑s') r₂)","decl":"/-- Common factors on the right can be turned into common factors on the left, a weak form of\ncancellability. -/\n@[to_additive AddOreLocalization.ore_right_cancel]\ntheorem ore_right_cancel (r₁ r₂ : R) (s : S) (h : r₁ * s = r₂ * s) : ∃ s' : S, s' * r₁ = s' * r₂ :=\n  OreSet.ore_right_cancel r₁ r₂ s h\n\n"}
{"name":"AddOreLocalization.add_ore_eq","module":"Mathlib.GroupTheory.OreLocalization.OreSet","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\nS : AddSubmonoid R\ninst✝ : AddOreLocalization.AddOreSet S\nr : R\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (↑(AddOreLocalization.oreSubtra r s)) r) (HAdd.hAdd (AddOreLocalization.oreMin r s) ↑s)","decl":"/-- The Ore condition of a fraction, expressed in terms of `oreNum` and `oreDenom`. -/\n@[to_additive AddOreLocalization.add_ore_eq\n  \"The Ore condition of a difference, expressed in terms of `oreMin` and `oreSubtra`.\"]\ntheorem ore_eq (r : R) (s : S) : oreDenom r s * r = oreNum r s * s :=\n  OreSet.ore_eq r s\n\n"}
{"name":"OreLocalization.ore_eq","module":"Mathlib.GroupTheory.OreLocalization.OreSet","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\nS : Submonoid R\ninst✝ : OreLocalization.OreSet S\nr : R\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (↑(OreLocalization.oreDenom r s)) r) (HMul.hMul (OreLocalization.oreNum r s) ↑s)","decl":"/-- The Ore condition of a fraction, expressed in terms of `oreNum` and `oreDenom`. -/\n@[to_additive AddOreLocalization.add_ore_eq\n  \"The Ore condition of a difference, expressed in terms of `oreMin` and `oreSubtra`.\"]\ntheorem ore_eq (r : R) (s : S) : oreDenom r s * r = oreNum r s * s :=\n  OreSet.ore_eq r s\n\n"}
