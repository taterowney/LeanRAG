{"name":"CategoryTheory.Presieve.CoverByImageStructure.mk.inj","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nG : CategoryTheory.Functor C D\nV U : D\nf : Quiver.Hom V U\nobj‚úù : C\nlift‚úù : Quiver.Hom V (G.obj obj‚úù)\nmap‚úù : Quiver.Hom (G.obj obj‚úù) U\nfac‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp lift‚úù map‚úù) f) _auto‚úù\nobj : C\nlift : Quiver.Hom V (G.obj obj)\nmap : Quiver.Hom (G.obj obj) U\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp lift map) f) _auto‚úù\nx‚úù : Eq { obj := obj‚úù, lift := lift‚úù, map := map‚úù, fac := fac‚úù } { obj := obj, lift := lift, map := map, fac := fac }\n‚ä¢ And (Eq obj‚úù obj) (And (HEq lift‚úù lift) (HEq map‚úù map))","decl":"/-- An auxiliary structure that witnesses the fact that `f` factors through an image object of `G`.\n-/\nstructure Presieve.CoverByImageStructure (G : C ‚•§ D) {V U : D} (f : V ‚ü∂ U) where\n  obj : C\n  lift : V ‚ü∂ G.obj obj\n  map : G.obj obj ‚ü∂ U\n  fac : lift ‚â´ map = f := by aesop_cat\n"}
{"name":"CategoryTheory.Presieve.CoverByImageStructure.fac","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nG : CategoryTheory.Functor C D\nV U : D\nf : Quiver.Hom V U\nself : CategoryTheory.Presieve.CoverByImageStructure G f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.lift self.map) f","decl":"/-- An auxiliary structure that witnesses the fact that `f` factors through an image object of `G`.\n-/\nstructure Presieve.CoverByImageStructure (G : C ‚•§ D) {V U : D} (f : V ‚ü∂ U) where\n  obj : C\n  lift : V ‚ü∂ G.obj obj\n  map : G.obj obj ‚ü∂ U\n  fac : lift ‚â´ map = f := by aesop_cat\n"}
{"name":"CategoryTheory.Presieve.CoverByImageStructure.mk.injEq","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nG : CategoryTheory.Functor C D\nV U : D\nf : Quiver.Hom V U\nobj‚úù : C\nlift‚úù : Quiver.Hom V (G.obj obj‚úù)\nmap‚úù : Quiver.Hom (G.obj obj‚úù) U\nfac‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp lift‚úù map‚úù) f) _auto‚úù\nobj : C\nlift : Quiver.Hom V (G.obj obj)\nmap : Quiver.Hom (G.obj obj) U\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp lift map) f) _auto‚úù\n‚ä¢ Eq (Eq { obj := obj‚úù, lift := lift‚úù, map := map‚úù, fac := fac‚úù } { obj := obj, lift := lift, map := map, fac := fac }) (And (Eq obj‚úù obj) (And (HEq lift‚úù lift) (HEq map‚úù map)))","decl":"/-- An auxiliary structure that witnesses the fact that `f` factors through an image object of `G`.\n-/\nstructure Presieve.CoverByImageStructure (G : C ‚•§ D) {V U : D} (f : V ‚ü∂ U) where\n  obj : C\n  lift : V ‚ü∂ G.obj obj\n  map : G.obj obj ‚ü∂ U\n  fac : lift ‚â´ map = f := by aesop_cat\n"}
{"name":"CategoryTheory.Presieve.CoverByImageStructure.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nG : CategoryTheory.Functor C D\nV U : D\nf : Quiver.Hom V U\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf D\nobj : C\nlift : Quiver.Hom V (G.obj obj)\nmap : Quiver.Hom (G.obj obj) U\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp lift map) f) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { obj := obj, lift := lift, map := map, fac := fac }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf obj)) (SizeOf.sizeOf lift)) (SizeOf.sizeOf map)) (SizeOf.sizeOf fac))","decl":"/-- An auxiliary structure that witnesses the fact that `f` factors through an image object of `G`.\n-/\nstructure Presieve.CoverByImageStructure (G : C ‚•§ D) {V U : D} (f : V ‚ü∂ U) where\n  obj : C\n  lift : V ‚ü∂ G.obj obj\n  map : G.obj obj ‚ü∂ U\n  fac : lift ‚â´ map = f := by aesop_cat\n"}
{"name":"CategoryTheory.Presieve.CoverByImageStructure.fac_assoc","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nG : CategoryTheory.Functor C D\nV U : D\nf : Quiver.Hom V U\nself : CategoryTheory.Presieve.CoverByImageStructure G f\nZ : D\nh : Quiver.Hom U Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.lift (CategoryTheory.CategoryStruct.comp self.map h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"attribute [reassoc (attr := simp)] Presieve.CoverByImageStructure.fac\n\n"}
{"name":"CategoryTheory.Presieve.in_coverByImage","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nG : CategoryTheory.Functor C D\nX : D\nY : C\nf : Quiver.Hom (G.obj Y) X\n‚ä¢ CategoryTheory.Presieve.coverByImage G X f","decl":"theorem Presieve.in_coverByImage (G : C ‚•§ D) {X : D} {Y : C} (f : G.obj Y ‚ü∂ X) :\n    Presieve.coverByImage G X f :=\n  ‚ü®‚ü®Y, ùüô _, f, by simp‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.is_cover","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nG : CategoryTheory.Functor C D\nK : CategoryTheory.GrothendieckTopology D\nself : G.IsCoverDense K\nU : D\n‚ä¢ Membership.mem (K U) (CategoryTheory.Sieve.coverByImage G U)","decl":"/-- A functor `G : (C, J) ‚•§ (D, K)` is cover dense if for each object in `D`,\n  there exists a covering sieve in `D` that factors through images of `G`.\n\nThis definition can be found in https://ncatlab.org/nlab/show/dense+sub-site Definition 2.2.\n-/\nclass Functor.IsCoverDense (G : C ‚•§ D) (K : GrothendieckTopology D) : Prop where\n  is_cover : ‚àÄ U : D, Sieve.coverByImage G U ‚àà K U\n\n"}
{"name":"CategoryTheory.Functor.is_cover_of_isCoverDense","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nG : CategoryTheory.Functor C D\nK : CategoryTheory.GrothendieckTopology D\ninst‚úù : G.IsCoverDense K\nU : D\n‚ä¢ Membership.mem (K U) (CategoryTheory.Sieve.coverByImage G U)","decl":"lemma Functor.is_cover_of_isCoverDense (G : C ‚•§ D) (K : GrothendieckTopology D)\n    [G.IsCoverDense K] (U : D) : Sieve.coverByImage G U ‚àà K U := by\n  apply Functor.IsCoverDense.is_cover\n\n"}
{"name":"CategoryTheory.Functor.isCoverDense_of_generate_singleton_functor_œÄ_mem","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nG : CategoryTheory.Functor C D\nK : CategoryTheory.GrothendieckTopology D\nh : ‚àÄ (B : D), Exists fun X => Exists fun f => Membership.mem (K B) (CategoryTheory.Sieve.generate (CategoryTheory.Presieve.singleton f))\n‚ä¢ G.IsCoverDense K","decl":"lemma Functor.isCoverDense_of_generate_singleton_functor_œÄ_mem (G : C ‚•§ D)\n    (K : GrothendieckTopology D)\n    (h : ‚àÄ B, ‚àÉ (X : C) (f : G.obj X ‚ü∂ B), Sieve.generate (Presieve.singleton f) ‚àà K B) :\n    G.IsCoverDense K where\n  is_cover B := by\n    obtain ‚ü®X, f, h‚ü© := h B\n    refine K.superset_covering ?_ h\n    intro Y f ‚ü®Z, g, _, h, w‚ü©\n    cases h\n    exact ‚ü®‚ü®_, g, _, w‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.ext","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù : G.IsCoverDense K\n‚Ñ± : CategoryTheory.Sheaf K (Type u_7)\nX : D\ns t : ‚Ñ±.val.obj { unop := X }\nh : ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Quiver.Hom (G.obj Y) X), Eq (‚Ñ±.val.map f.op s) (‚Ñ±.val.map f.op t)\n‚ä¢ Eq s t","decl":"theorem ext [G.IsCoverDense K] (‚Ñ± : Sheaf K (Type _)) (X : D) {s t : ‚Ñ±.val.obj (op X)}\n    (h : ‚àÄ ‚¶ÉY : C‚¶Ñ (f : G.obj Y ‚ü∂ X), ‚Ñ±.val.map f.op s = ‚Ñ±.val.map f.op t) : s = t := by\n  apply ((isSheaf_iff_isSheaf_of_type _ _ ).1 ‚Ñ±.cond\n    (Sieve.coverByImage G X) (G.is_cover_of_isCoverDense K X)).isSeparatedFor.ext\n  rintro Y _ ‚ü®Z, f‚ÇÅ, f‚ÇÇ, ‚ü®rfl‚ü©‚ü©\n  simp [h f‚ÇÇ]\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.functorPullback_pushforward_covering","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\nX : C\nT : ‚Üë(K (G.obj X))\n‚ä¢ Membership.mem (K (G.obj X)) (CategoryTheory.Sieve.functorPushforward G (CategoryTheory.Sieve.functorPullback G ‚ÜëT))","decl":"theorem functorPullback_pushforward_covering [G.IsCoverDense K] [G.IsLocallyFull K] {X : C}\n    (T : K (G.obj X)) : (T.val.functorPullback G).functorPushforward G ‚àà K (G.obj X) := by\n  refine K.transitive T.2 _ fun Y iYX hiYX ‚Ü¶ ?_\n  apply K.transitive (G.is_cover_of_isCoverDense _ _) _\n  rintro W _ ‚ü®Z, iWZ, iZY, rfl‚ü©\n  rw [Sieve.pullback_comp]; apply K.pullback_stable; clear W iWZ\n  apply K.superset_covering ?_ (G.functorPushforward_imageSieve_mem _ (iZY ‚â´ iYX))\n  rintro W _ ‚ü®V, iVZ, iWV, ‚ü®iVX, e‚ü©, rfl‚ü©\n  exact ‚ü®_, iVX, iWV, by simpa [e] using T.1.downward_closed hiYX (G.map iVZ ‚â´ iZY), by simp [e]‚ü©\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.homOver_app","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù : CategoryTheory.Category.{u_7, u_4} A\nG : CategoryTheory.Functor C D\n‚Ñ± : CategoryTheory.Functor (Opposite D) A\n‚Ñ±' : CategoryTheory.Sheaf K A\nŒ± : Quiver.Hom (G.op.comp ‚Ñ±) (G.op.comp ‚Ñ±'.val)\nX‚úù : A\nX : Opposite C\na‚úù : (CategoryTheory.coyoneda.obj { unop := X‚úù }).obj ((G.op.comp ‚Ñ±).obj X)\n‚ä¢ Eq ((CategoryTheory.Functor.IsCoverDense.homOver Œ± X‚úù).app X a‚úù) (CategoryTheory.CategoryStruct.comp a‚úù (Œ±.app X))","decl":"/-- (Implementation). Given a hom between the pullbacks of two sheaves, we can whisker it with\n`coyoneda` to obtain a hom between the pullbacks of the sheaves of maps from `X`.\n-/\n@[simps!]\ndef homOver {‚Ñ± : D·µí·µñ ‚•§ A} {‚Ñ±' : Sheaf K A} (Œ± : G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) (X : A) :\n    G.op ‚ãô ‚Ñ± ‚ãô coyoneda.obj (op X) ‚ü∂ G.op ‚ãô (sheafOver ‚Ñ±' X).val :=\n  whiskerRight Œ± (coyoneda.obj (op X))\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.isoOver_hom_app","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù : CategoryTheory.Category.{u_7, u_4} A\nG : CategoryTheory.Functor C D\n‚Ñ± ‚Ñ±' : CategoryTheory.Sheaf K A\nŒ± : CategoryTheory.Iso (G.op.comp ‚Ñ±.val) (G.op.comp ‚Ñ±'.val)\nX‚úù : A\nX : Opposite C\na‚úù : (CategoryTheory.coyoneda.obj { unop := X‚úù }).obj ((G.op.comp ‚Ñ±.val).obj X)\n‚ä¢ Eq ((CategoryTheory.Functor.IsCoverDense.isoOver Œ± X‚úù).hom.app X a‚úù) (CategoryTheory.CategoryStruct.comp a‚úù (Œ±.hom.app X))","decl":"/-- (Implementation). Given an iso between the pullbacks of two sheaves, we can whisker it with\n`coyoneda` to obtain an iso between the pullbacks of the sheaves of maps from `X`.\n-/\n@[simps!]\ndef isoOver {‚Ñ± ‚Ñ±' : Sheaf K A} (Œ± : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) (X : A) :\n    G.op ‚ãô (sheafOver ‚Ñ± X).val ‚âÖ G.op ‚ãô (sheafOver ‚Ñ±' X).val :=\n  isoWhiskerRight Œ± (coyoneda.obj (op X))\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.isoOver_inv_app","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù : CategoryTheory.Category.{u_7, u_4} A\nG : CategoryTheory.Functor C D\n‚Ñ± ‚Ñ±' : CategoryTheory.Sheaf K A\nŒ± : CategoryTheory.Iso (G.op.comp ‚Ñ±.val) (G.op.comp ‚Ñ±'.val)\nX‚úù : A\nX : Opposite C\na‚úù : (CategoryTheory.coyoneda.obj { unop := X‚úù }).obj ((G.op.comp ‚Ñ±'.val).obj X)\n‚ä¢ Eq ((CategoryTheory.Functor.IsCoverDense.isoOver Œ± X‚úù).inv.app X a‚úù) (CategoryTheory.CategoryStruct.comp a‚úù (Œ±.inv.app X))","decl":"/-- (Implementation). Given an iso between the pullbacks of two sheaves, we can whisker it with\n`coyoneda` to obtain an iso between the pullbacks of the sheaves of maps from `X`.\n-/\n@[simps!]\ndef isoOver {‚Ñ± ‚Ñ±' : Sheaf K A} (Œ± : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) (X : A) :\n    G.op ‚ãô (sheafOver ‚Ñ± X).val ‚âÖ G.op ‚ãô (sheafOver ‚Ñ±' X).val :=\n  isoWhiskerRight Œ± (coyoneda.obj (op X))\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.sheaf_eq_amalgamation","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"D : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù : CategoryTheory.Category.{u_6, u_4} A\n‚Ñ± : CategoryTheory.Sheaf K A\nX : A\nU : D\nT : CategoryTheory.Sieve U\nhT : Membership.mem (K U) T\nx : CategoryTheory.Presieve.FamilyOfElements (‚Ñ±.val.comp (CategoryTheory.coyoneda.obj { unop := X })) T.arrows\nhx : x.Compatible\nt : (‚Ñ±.val.comp (CategoryTheory.coyoneda.obj { unop := X })).obj { unop := U }\nh : x.IsAmalgamation t\n‚ä¢ Eq t (‚ãØ.amalgamate x hx)","decl":"theorem sheaf_eq_amalgamation (‚Ñ± : Sheaf K A) {X : A} {U : D} {T : Sieve U} (hT)\n    (x : FamilyOfElements _ T) (hx) (t) (h : x.IsAmalgamation t) :\n    t = (‚Ñ±.cond X T hT).amalgamate x hx :=\n  (‚Ñ±.cond X T hT).isSeparatedFor x t _ h ((‚Ñ±.cond X T hT).isAmalgamation hx)\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.naturality_apply","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\n‚Ñ± : CategoryTheory.Functor (Opposite D) (Type v)\n‚Ñ±' : CategoryTheory.Sheaf K (Type v)\nŒ± : Quiver.Hom (G.op.comp ‚Ñ±) (G.op.comp ‚Ñ±'.val)\ninst‚úù : G.IsLocallyFull K\nX Y : C\ni : Quiver.Hom (G.obj X) (G.obj Y)\nx : (G.op.comp ‚Ñ±).obj { unop := Y }\n‚ä¢ Eq (‚Ñ±'.val.map i.op (Œ±.app { unop := Y } x)) (Œ±.app { unop := X } (‚Ñ±.map i.op x))","decl":"theorem naturality_apply [G.IsLocallyFull K] {X Y : C} (i : G.obj X ‚ü∂ G.obj Y) (x) :\n    ‚Ñ±'.1.map i.op (Œ±.app _ x) = Œ±.app _ (‚Ñ±.map i.op x) := by\n  have {X Y} (i : X ‚ü∂ Y) (x) :\n      ‚Ñ±'.1.map (G.map i).op (Œ±.app _ x) = Œ±.app _ (‚Ñ±.map (G.map i).op x) := by\n    exact congr_fun (Œ±.naturality i.op).symm x\n  refine IsLocallyFull.ext G _ i fun V iVX iVY e ‚Ü¶ ?_\n  simp only [comp_obj, types_comp_apply, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, ‚Üê e, this]\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.naturality_assoc","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\n‚Ñ± : CategoryTheory.Functor (Opposite D) (Type v)\n‚Ñ±' : CategoryTheory.Sheaf K (Type v)\nŒ± : Quiver.Hom (G.op.comp ‚Ñ±) (G.op.comp ‚Ñ±'.val)\ninst‚úù : G.IsLocallyFull K\nX Y : C\ni : Quiver.Hom (G.obj X) (G.obj Y)\nZ : Type v\nh : Quiver.Hom (‚Ñ±'.val.obj { unop := G.obj X }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.app { unop := Y }) (CategoryTheory.CategoryStruct.comp (‚Ñ±'.val.map i.op) h)) (CategoryTheory.CategoryStruct.comp (‚Ñ±.map i.op) (CategoryTheory.CategoryStruct.comp (Œ±.app { unop := X }) h))","decl":"@[reassoc]\ntheorem naturality [G.IsLocallyFull K] {X Y : C} (i : G.obj X ‚ü∂ G.obj Y) :\n    Œ±.app _ ‚â´ ‚Ñ±'.1.map i.op = ‚Ñ±.map i.op ‚â´ Œ±.app _ := types_ext _ _ (naturality_apply Œ± i)\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.naturality","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\n‚Ñ± : CategoryTheory.Functor (Opposite D) (Type v)\n‚Ñ±' : CategoryTheory.Sheaf K (Type v)\nŒ± : Quiver.Hom (G.op.comp ‚Ñ±) (G.op.comp ‚Ñ±'.val)\ninst‚úù : G.IsLocallyFull K\nX Y : C\ni : Quiver.Hom (G.obj X) (G.obj Y)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.app { unop := Y }) (‚Ñ±'.val.map i.op)) (CategoryTheory.CategoryStruct.comp (‚Ñ±.map i.op) (Œ±.app { unop := X }))","decl":"@[reassoc]\ntheorem naturality [G.IsLocallyFull K] {X Y : C} (i : G.obj X ‚ü∂ G.obj Y) :\n    Œ±.app _ ‚â´ ‚Ñ±'.1.map i.op = ‚Ñ±.map i.op ‚â´ Œ±.app _ := types_ext _ _ (naturality_apply Œ± i)\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.pushforwardFamily_def","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\n‚Ñ± : CategoryTheory.Functor (Opposite D) (Type v)\n‚Ñ±' : CategoryTheory.Sheaf K (Type v)\nŒ± : Quiver.Hom (G.op.comp ‚Ñ±) (G.op.comp ‚Ñ±'.val)\nX : D\nx : ‚Ñ±.obj { unop := X }\n‚ä¢ Eq (CategoryTheory.Functor.IsCoverDense.Types.pushforwardFamily Œ± x) fun x_1 x_2 hf => ‚Ñ±'.val.map (Nonempty.some hf).lift.op (Œ±.app { unop := (Nonempty.some hf).1 } (‚Ñ±.map (Nonempty.some hf).map.op x))","decl":"@[simp] theorem pushforwardFamily_def {X} (x : ‚Ñ±.obj (op X)) :\n    pushforwardFamily Œ± x = fun _ _ hf =>\n  ‚Ñ±'.val.map hf.some.lift.op <| Œ±.app (op _) (‚Ñ±.map hf.some.map.op x) := rfl\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.pushforwardFamily_apply","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\n‚Ñ± : CategoryTheory.Functor (Opposite D) (Type v)\n‚Ñ±' : CategoryTheory.Sheaf K (Type v)\nŒ± : Quiver.Hom (G.op.comp ‚Ñ±) (G.op.comp ‚Ñ±'.val)\ninst‚úù : G.IsLocallyFull K\nX : D\nx : ‚Ñ±.obj { unop := X }\nY : C\nf : Quiver.Hom (G.obj Y) X\n‚ä¢ Eq (CategoryTheory.Functor.IsCoverDense.Types.pushforwardFamily Œ± x f ‚ãØ) (Œ±.app { unop := Y } (‚Ñ±.map f.op x))","decl":"@[simp]\ntheorem pushforwardFamily_apply [G.IsLocallyFull K]\n    {X} (x : ‚Ñ±.obj (op X)) {Y : C} (f : G.obj Y ‚ü∂ X) :\n    pushforwardFamily Œ± x f (Presieve.in_coverByImage G f) = Œ±.app (op Y) (‚Ñ±.map f.op x) := by\n  simp only [pushforwardFamily_def, op_obj]\n  generalize Nonempty.some (Presieve.in_coverByImage G f) = l\n  obtain ‚ü®W, iYW, iWX, rfl‚ü© := l\n  simp only [‚Üê op_comp, ‚Üê FunctorToTypes.map_comp_apply, naturality_apply]\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.pushforwardFamily_compatible","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\n‚Ñ± : CategoryTheory.Functor (Opposite D) (Type v)\n‚Ñ±' : CategoryTheory.Sheaf K (Type v)\nŒ± : Quiver.Hom (G.op.comp ‚Ñ±) (G.op.comp ‚Ñ±'.val)\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\nX : D\nx : ‚Ñ±.obj { unop := X }\n‚ä¢ (CategoryTheory.Functor.IsCoverDense.Types.pushforwardFamily Œ± x).Compatible","decl":"/-- (Implementation). The `pushforwardFamily` defined is compatible. -/\ntheorem pushforwardFamily_compatible {X} (x : ‚Ñ±.obj (op X)) :\n    (pushforwardFamily Œ± x).Compatible := by\n  suffices ‚àÄ {Z W‚ÇÅ W‚ÇÇ} (iWX‚ÇÅ : G.obj W‚ÇÅ ‚ü∂ X) (iWX‚ÇÇ : G.obj W‚ÇÇ ‚ü∂ X) (iZW‚ÇÅ : Z ‚ü∂ G.obj W‚ÇÅ)\n      (iZW‚ÇÇ : Z ‚ü∂ G.obj W‚ÇÇ), iZW‚ÇÅ ‚â´ iWX‚ÇÅ = iZW‚ÇÇ ‚â´ iWX‚ÇÇ ‚Üí\n      ‚Ñ±'.1.map iZW‚ÇÅ.op (Œ±.app _ (‚Ñ±.map iWX‚ÇÅ.op x)) = ‚Ñ±'.1.map iZW‚ÇÇ.op (Œ±.app _ (‚Ñ±.map iWX‚ÇÇ.op x)) by\n    rintro Y‚ÇÅ Y‚ÇÇ Z iZY‚ÇÅ iZY‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ e\n    simp only [pushforwardFamily, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp]\n    generalize Nonempty.some h‚ÇÅ = l‚ÇÅ\n    generalize Nonempty.some h‚ÇÇ = l‚ÇÇ\n    obtain ‚ü®W‚ÇÅ, iYW‚ÇÅ, iWX‚ÇÅ, rfl‚ü© := l‚ÇÅ\n    obtain ‚ü®W‚ÇÇ, iYW‚ÇÇ, iWX‚ÇÇ, rfl‚ü© := l‚ÇÇ\n    exact this _ _ _ _ (by simpa only [Category.assoc] using e)\n  introv e\n  refine ext G _ _ fun V iVZ ‚Ü¶ ?_\n  simp only [‚Üê op_comp, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê Functor.map_comp, naturality_apply,\n    Category.assoc, e]\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.appHom_restrict","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\n‚Ñ± : CategoryTheory.Functor (Opposite D) (Type v)\n‚Ñ±' : CategoryTheory.Sheaf K (Type v)\nŒ± : Quiver.Hom (G.op.comp ‚Ñ±) (G.op.comp ‚Ñ±'.val)\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\nX : D\nY : C\nf : Quiver.Hom { unop := X } { unop := G.obj Y }\nx : ‚Ñ±.obj { unop := X }\n‚ä¢ Eq (‚Ñ±'.val.map f (CategoryTheory.Functor.IsCoverDense.Types.appHom Œ± X x)) (Œ±.app { unop := Y } (‚Ñ±.map f x))","decl":"@[simp]\ntheorem appHom_restrict {X : D} {Y : C} (f : op X ‚ü∂ op (G.obj Y)) (x) :\n    ‚Ñ±'.val.map f (appHom Œ± X x) = Œ±.app (op Y) (‚Ñ±.map f x) :=\n  (((isSheaf_iff_isSheaf_of_type _ _ ).1 ‚Ñ±'.cond _ (G.is_cover_of_isCoverDense _ X)).valid_glue\n      (pushforwardFamily_compatible Œ± x) f.unop\n          (Presieve.in_coverByImage G f.unop)).trans (pushforwardFamily_apply _ _ _)\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.appHom_valid_glue","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\n‚Ñ± : CategoryTheory.Functor (Opposite D) (Type v)\n‚Ñ±' : CategoryTheory.Sheaf K (Type v)\nŒ± : Quiver.Hom (G.op.comp ‚Ñ±) (G.op.comp ‚Ñ±'.val)\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\nX : D\nY : C\nf : Quiver.Hom { unop := X } { unop := G.obj Y }\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.IsCoverDense.Types.appHom Œ± X) (‚Ñ±'.val.map f)) (CategoryTheory.CategoryStruct.comp (‚Ñ±.map f) (Œ±.app { unop := Y }))","decl":"@[simp]\ntheorem appHom_valid_glue {X : D} {Y : C} (f : op X ‚ü∂ op (G.obj Y)) :\n    appHom Œ± X ‚â´ ‚Ñ±'.val.map f = ‚Ñ±.map f ‚â´ Œ±.app (op Y) := by\n  ext\n  apply appHom_restrict\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.appIso_inv","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± ‚Ñ±' : CategoryTheory.Sheaf K (Type v)\ni : CategoryTheory.Iso (G.op.comp ‚Ñ±.val) (G.op.comp ‚Ñ±'.val)\nX : D\na‚úù : ‚Ñ±'.val.obj { unop := X }\n‚ä¢ Eq ((CategoryTheory.Functor.IsCoverDense.Types.appIso i X).inv a‚úù) (CategoryTheory.Functor.IsCoverDense.Types.appHom i.inv X a‚úù)","decl":"/--\n(Implementation). The maps given in `appIso` is inverse to each other and gives a `‚Ñ±(X) ‚âÖ ‚Ñ±'(X)`.\n-/\n@[simps]\nnoncomputable def appIso {‚Ñ± ‚Ñ±' : Sheaf K (Type v)} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val)\n    (X : D) : ‚Ñ±.val.obj (op X) ‚âÖ ‚Ñ±'.val.obj (op X) where\n  hom := appHom i.hom X\n  inv := appHom i.inv X\n  hom_inv_id := by\n    ext x\n    apply Functor.IsCoverDense.ext G\n    intro Y f\n    simp\n  inv_hom_id := by\n    ext x\n    apply Functor.IsCoverDense.ext G\n    intro Y f\n    simp\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.appIso_hom","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± ‚Ñ±' : CategoryTheory.Sheaf K (Type v)\ni : CategoryTheory.Iso (G.op.comp ‚Ñ±.val) (G.op.comp ‚Ñ±'.val)\nX : D\na‚úù : ‚Ñ±.val.obj { unop := X }\n‚ä¢ Eq ((CategoryTheory.Functor.IsCoverDense.Types.appIso i X).hom a‚úù) (CategoryTheory.Functor.IsCoverDense.Types.appHom i.hom X a‚úù)","decl":"/--\n(Implementation). The maps given in `appIso` is inverse to each other and gives a `‚Ñ±(X) ‚âÖ ‚Ñ±'(X)`.\n-/\n@[simps]\nnoncomputable def appIso {‚Ñ± ‚Ñ±' : Sheaf K (Type v)} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val)\n    (X : D) : ‚Ñ±.val.obj (op X) ‚âÖ ‚Ñ±'.val.obj (op X) where\n  hom := appHom i.hom X\n  inv := appHom i.inv X\n  hom_inv_id := by\n    ext x\n    apply Functor.IsCoverDense.ext G\n    intro Y f\n    simp\n  inv_hom_id := by\n    ext x\n    apply Functor.IsCoverDense.ext G\n    intro Y f\n    simp\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.presheafHom_app","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\n‚Ñ± : CategoryTheory.Functor (Opposite D) (Type v)\n‚Ñ±' : CategoryTheory.Sheaf K (Type v)\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\nŒ± : Quiver.Hom (G.op.comp ‚Ñ±) (G.op.comp ‚Ñ±'.val)\nX : Opposite D\na‚úù : ‚Ñ±.obj { unop := Opposite.unop X }\n‚ä¢ Eq ((CategoryTheory.Functor.IsCoverDense.Types.presheafHom Œ±).app X a‚úù) (CategoryTheory.Functor.IsCoverDense.Types.appHom Œ± (Opposite.unop X) a‚úù)","decl":"/--\nGiven a natural transformation `G ‚ãô ‚Ñ± ‚ü∂ G ‚ãô ‚Ñ±'` between presheaves of types,\nwhere `G` is locally-full and cover-dense, and `‚Ñ±'` is a sheaf,\nwe may obtain a natural transformation between sheaves.\n-/\n@[simps]\nnoncomputable def presheafHom (Œ± : G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) : ‚Ñ± ‚ü∂ ‚Ñ±'.val where\n  app X := appHom Œ± (unop X)\n  naturality X Y f := by\n    ext x\n    apply Functor.IsCoverDense.ext G\n    intro Y' f'\n    simp only [appHom_restrict, types_comp_apply, ‚Üê FunctorToTypes.map_comp_apply]\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.presheafIso_inv_app","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± ‚Ñ±' : CategoryTheory.Sheaf K (Type v)\ni : CategoryTheory.Iso (G.op.comp ‚Ñ±.val) (G.op.comp ‚Ñ±'.val)\nX : Opposite D\na‚úù : ‚Ñ±'.val.obj X\n‚ä¢ Eq ((CategoryTheory.Functor.IsCoverDense.Types.presheafIso i).inv.app X a‚úù) (CategoryTheory.Functor.IsCoverDense.Types.appHom i.inv (Opposite.unop X) a‚úù)","decl":"/--\nGiven a natural isomorphism `G ‚ãô ‚Ñ± ‚âÖ G ‚ãô ‚Ñ±'` between presheaves of types,\nwhere `G` is locally-full and cover-dense, and `‚Ñ±, ‚Ñ±'` are sheaves,\nwe may obtain a natural isomorphism between presheaves.\n-/\n@[simps!]\nnoncomputable def presheafIso {‚Ñ± ‚Ñ±' : Sheaf K (Type v)} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) :\n    ‚Ñ±.val ‚âÖ ‚Ñ±'.val :=\n  NatIso.ofComponents (fun X => appIso i (unop X)) @(presheafHom i.hom).naturality\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.presheafIso_hom_app","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± ‚Ñ±' : CategoryTheory.Sheaf K (Type v)\ni : CategoryTheory.Iso (G.op.comp ‚Ñ±.val) (G.op.comp ‚Ñ±'.val)\nX : Opposite D\na‚úù : ‚Ñ±.val.obj X\n‚ä¢ Eq ((CategoryTheory.Functor.IsCoverDense.Types.presheafIso i).hom.app X a‚úù) (CategoryTheory.Functor.IsCoverDense.Types.appHom i.hom (Opposite.unop X) a‚úù)","decl":"/--\nGiven a natural isomorphism `G ‚ãô ‚Ñ± ‚âÖ G ‚ãô ‚Ñ±'` between presheaves of types,\nwhere `G` is locally-full and cover-dense, and `‚Ñ±, ‚Ñ±'` are sheaves,\nwe may obtain a natural isomorphism between presheaves.\n-/\n@[simps!]\nnoncomputable def presheafIso {‚Ñ± ‚Ñ±' : Sheaf K (Type v)} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) :\n    ‚Ñ±.val ‚âÖ ‚Ñ±'.val :=\n  NatIso.ofComponents (fun X => appIso i (unop X)) @(presheafHom i.hom).naturality\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.sheafIso_hom_val","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± ‚Ñ±' : CategoryTheory.Sheaf K (Type v)\ni : CategoryTheory.Iso (G.op.comp ‚Ñ±.val) (G.op.comp ‚Ñ±'.val)\n‚ä¢ Eq (CategoryTheory.Functor.IsCoverDense.Types.sheafIso i).hom.val (CategoryTheory.Functor.IsCoverDense.Types.presheafIso i).hom","decl":"/--\nGiven a natural isomorphism `G ‚ãô ‚Ñ± ‚âÖ G ‚ãô ‚Ñ±'` between presheaves of types,\nwhere `G` is locally-full and cover-dense, and `‚Ñ±, ‚Ñ±'` are sheaves,\nwe may obtain a natural isomorphism between sheaves.\n-/\n@[simps]\nnoncomputable def sheafIso {‚Ñ± ‚Ñ±' : Sheaf K (Type v)} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) :\n    ‚Ñ± ‚âÖ ‚Ñ±' where\n  hom := ‚ü®(presheafIso i).hom‚ü©\n  inv := ‚ü®(presheafIso i).inv‚ü©\n  hom_inv_id := by\n    ext1\n    apply (presheafIso i).hom_inv_id\n  inv_hom_id := by\n    ext1\n    apply (presheafIso i).inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.Types.sheafIso_inv_val","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± ‚Ñ±' : CategoryTheory.Sheaf K (Type v)\ni : CategoryTheory.Iso (G.op.comp ‚Ñ±.val) (G.op.comp ‚Ñ±'.val)\n‚ä¢ Eq (CategoryTheory.Functor.IsCoverDense.Types.sheafIso i).inv.val (CategoryTheory.Functor.IsCoverDense.Types.presheafIso i).inv","decl":"/--\nGiven a natural isomorphism `G ‚ãô ‚Ñ± ‚âÖ G ‚ãô ‚Ñ±'` between presheaves of types,\nwhere `G` is locally-full and cover-dense, and `‚Ñ±, ‚Ñ±'` are sheaves,\nwe may obtain a natural isomorphism between sheaves.\n-/\n@[simps]\nnoncomputable def sheafIso {‚Ñ± ‚Ñ±' : Sheaf K (Type v)} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) :\n    ‚Ñ± ‚âÖ ‚Ñ±' where\n  hom := ‚ü®(presheafIso i).hom‚ü©\n  inv := ‚ü®(presheafIso i).inv‚ü©\n  hom_inv_id := by\n    ext1\n    apply (presheafIso i).hom_inv_id\n  inv_hom_id := by\n    ext1\n    apply (presheafIso i).inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.sheafCoyonedaHom_app","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_4} A\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± : CategoryTheory.Functor (Opposite D) A\n‚Ñ±' : CategoryTheory.Sheaf K A\nŒ± : Quiver.Hom (G.op.comp ‚Ñ±) (G.op.comp ‚Ñ±'.val)\nX : Opposite A\n‚ä¢ Eq ((CategoryTheory.Functor.IsCoverDense.sheafCoyonedaHom Œ±).app X) (CategoryTheory.Functor.IsCoverDense.Types.presheafHom (CategoryTheory.Functor.IsCoverDense.homOver Œ± (Opposite.unop X)))","decl":"/-- (Implementation). The sheaf map given in `types.sheaf_hom` is natural in terms of `X`. -/\n@[simps]\nnoncomputable def sheafCoyonedaHom (Œ± : G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) :\n    coyoneda ‚ãô (whiskeringLeft D·µí·µñ A (Type _)).obj ‚Ñ± ‚ü∂\n      coyoneda ‚ãô (whiskeringLeft D·µí·µñ A (Type _)).obj ‚Ñ±'.val where\n  app X := presheafHom (homOver Œ± (unop X))\n  naturality X Y f := by\n    ext U x\n    change\n      appHom (homOver Œ± (unop Y)) (unop U) (f.unop ‚â´ x) =\n        f.unop ‚â´ appHom (homOver Œ± (unop X)) (unop U) x\n    symm\n    apply sheaf_eq_amalgamation\n    ¬∑ apply G.is_cover_of_isCoverDense\n    -- Porting note: the following line closes a goal which didn't exist before reenableeta\n    ¬∑ exact pushforwardFamily_compatible (homOver Œ± Y.unop) (f.unop ‚â´ x)\n    intro Y' f' hf'\n    change unop X ‚ü∂ ‚Ñ±.obj (op (unop _)) at x\n    dsimp\n    simp only [pushforwardFamily, Functor.comp_map, coyoneda_obj_map, homOver_app, Category.assoc]\n    congr 1\n    conv_lhs => rw [‚Üê hf'.some.fac]\n    simp only [‚Üê Category.assoc, op_comp, Functor.map_comp]\n    congr 1\n    exact (appHom_restrict (homOver Œ± (unop X)) hf'.some.map.op x).trans (by simp)\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.presheafIso_inv","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_4} A\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± ‚Ñ±' : CategoryTheory.Sheaf K A\ni : CategoryTheory.Iso (G.op.comp ‚Ñ±.val) (G.op.comp ‚Ñ±'.val)\n‚ä¢ Eq (CategoryTheory.Functor.IsCoverDense.presheafIso i).inv (CategoryTheory.inv (CategoryTheory.Functor.IsCoverDense.sheafHom i.hom))","decl":"/--\nGiven a natural isomorphism `G ‚ãô ‚Ñ± ‚âÖ G ‚ãô ‚Ñ±'` between presheaves of arbitrary category,\nwhere `G` is locally-full and cover-dense, and `‚Ñ±', ‚Ñ±` are sheaves,\nwe may obtain a natural isomorphism between presheaves.\n-/\n@[simps!]\nnoncomputable def presheafIso {‚Ñ± ‚Ñ±' : Sheaf K A} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) :\n    ‚Ñ±.val ‚âÖ ‚Ñ±'.val := by\n  have : ‚àÄ X : D·µí·µñ, IsIso ((sheafHom i.hom).app X) := by\n    intro X\n    rw [‚Üê isIso_iff_of_reflects_iso _ yoneda]\n    use (sheafYonedaHom i.inv).app X\n    constructor <;> ext x : 2 <;>\n      simp only [sheafHom, NatTrans.comp_app, NatTrans.id_app, Functor.map_preimage]\n    ¬∑ exact ((Types.presheafIso (isoOver i (unop x))).app X).hom_inv_id\n    ¬∑ exact ((Types.presheafIso (isoOver i (unop x))).app X).inv_hom_id\n  haveI : IsIso (sheafHom i.hom) := by apply NatIso.isIso_of_isIso_app\n  apply asIso (sheafHom i.hom)\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.presheafIso_hom_app","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_4} A\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± ‚Ñ±' : CategoryTheory.Sheaf K A\ni : CategoryTheory.Iso (G.op.comp ‚Ñ±.val) (G.op.comp ‚Ñ±'.val)\nX : Opposite D\n‚ä¢ Eq ((CategoryTheory.Functor.IsCoverDense.presheafIso i).hom.app X) (CategoryTheory.yoneda.preimage ((CategoryTheory.Functor.IsCoverDense.sheafYonedaHom i.hom).app X))","decl":"/--\nGiven a natural isomorphism `G ‚ãô ‚Ñ± ‚âÖ G ‚ãô ‚Ñ±'` between presheaves of arbitrary category,\nwhere `G` is locally-full and cover-dense, and `‚Ñ±', ‚Ñ±` are sheaves,\nwe may obtain a natural isomorphism between presheaves.\n-/\n@[simps!]\nnoncomputable def presheafIso {‚Ñ± ‚Ñ±' : Sheaf K A} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) :\n    ‚Ñ±.val ‚âÖ ‚Ñ±'.val := by\n  have : ‚àÄ X : D·µí·µñ, IsIso ((sheafHom i.hom).app X) := by\n    intro X\n    rw [‚Üê isIso_iff_of_reflects_iso _ yoneda]\n    use (sheafYonedaHom i.inv).app X\n    constructor <;> ext x : 2 <;>\n      simp only [sheafHom, NatTrans.comp_app, NatTrans.id_app, Functor.map_preimage]\n    ¬∑ exact ((Types.presheafIso (isoOver i (unop x))).app X).hom_inv_id\n    ¬∑ exact ((Types.presheafIso (isoOver i (unop x))).app X).inv_hom_id\n  haveI : IsIso (sheafHom i.hom) := by apply NatIso.isIso_of_isIso_app\n  apply asIso (sheafHom i.hom)\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.sheafIso_hom_val","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_4} A\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± ‚Ñ±' : CategoryTheory.Sheaf K A\ni : CategoryTheory.Iso (G.op.comp ‚Ñ±.val) (G.op.comp ‚Ñ±'.val)\n‚ä¢ Eq (CategoryTheory.Functor.IsCoverDense.sheafIso i).hom.val (CategoryTheory.Functor.IsCoverDense.presheafIso i).hom","decl":"/--\nGiven a natural isomorphism `G ‚ãô ‚Ñ± ‚âÖ G ‚ãô ‚Ñ±'` between presheaves of arbitrary category,\nwhere `G` is locally-full and cover-dense, and `‚Ñ±', ‚Ñ±` are sheaves,\nwe may obtain a natural isomorphism between presheaves.\n-/\n@[simps]\nnoncomputable def sheafIso {‚Ñ± ‚Ñ±' : Sheaf K A} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) : ‚Ñ± ‚âÖ ‚Ñ±' where\n  hom := ‚ü®(presheafIso i).hom‚ü©\n  inv := ‚ü®(presheafIso i).inv‚ü©\n  hom_inv_id := by\n    ext1\n    apply (presheafIso i).hom_inv_id\n  inv_hom_id := by\n    ext1\n    apply (presheafIso i).inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.sheafIso_inv_val","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_4} A\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± ‚Ñ±' : CategoryTheory.Sheaf K A\ni : CategoryTheory.Iso (G.op.comp ‚Ñ±.val) (G.op.comp ‚Ñ±'.val)\n‚ä¢ Eq (CategoryTheory.Functor.IsCoverDense.sheafIso i).inv.val (CategoryTheory.Functor.IsCoverDense.presheafIso i).inv","decl":"/--\nGiven a natural isomorphism `G ‚ãô ‚Ñ± ‚âÖ G ‚ãô ‚Ñ±'` between presheaves of arbitrary category,\nwhere `G` is locally-full and cover-dense, and `‚Ñ±', ‚Ñ±` are sheaves,\nwe may obtain a natural isomorphism between presheaves.\n-/\n@[simps]\nnoncomputable def sheafIso {‚Ñ± ‚Ñ±' : Sheaf K A} (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) : ‚Ñ± ‚âÖ ‚Ñ±' where\n  hom := ‚ü®(presheafIso i).hom‚ü©\n  inv := ‚ü®(presheafIso i).inv‚ü©\n  hom_inv_id := by\n    ext1\n    apply (presheafIso i).hom_inv_id\n  inv_hom_id := by\n    ext1\n    apply (presheafIso i).inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.sheafHom_restrict_eq","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_4} A\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± : CategoryTheory.Functor (Opposite D) A\n‚Ñ±' : CategoryTheory.Sheaf K A\nŒ± : Quiver.Hom (G.op.comp ‚Ñ±) (G.op.comp ‚Ñ±'.val)\n‚ä¢ Eq (CategoryTheory.whiskerLeft G.op (CategoryTheory.Functor.IsCoverDense.sheafHom Œ±)) Œ±","decl":"/-- The constructed `sheafHom Œ±` is equal to `Œ±` when restricted onto `C`. -/\ntheorem sheafHom_restrict_eq (Œ± : G.op ‚ãô ‚Ñ± ‚ü∂ G.op ‚ãô ‚Ñ±'.val) :\n    whiskerLeft G.op (sheafHom Œ±) = Œ± := by\n  ext X\n  apply yoneda.map_injective\n  ext U\n  erw [yoneda.map_preimage]\n  symm\n  change (show (‚Ñ±'.val ‚ãô coyoneda.obj (op (unop U))).obj (op (G.obj (unop X))) from _) = _\n  apply sheaf_eq_amalgamation ‚Ñ±' (G.is_cover_of_isCoverDense _ _)\n  -- Porting note: next line was not needed in mathlib3\n  ¬∑ exact (pushforwardFamily_compatible _ _)\n  intro Y f hf\n  conv_lhs => rw [‚Üê hf.some.fac]\n  simp only [pushforwardFamily, Functor.comp_map, yoneda_map_app, coyoneda_obj_map, op_comp,\n    FunctorToTypes.map_comp_apply, homOver_app, ‚Üê Category.assoc]\n  congr 1\n  simp only [Category.assoc]\n  congr 1\n  have := naturality_apply (G := G) (‚Ñ± := ‚Ñ± ‚ãô coyoneda.obj (op <| (G.op ‚ãô ‚Ñ±).obj X))\n    (‚Ñ±' := ‚ü®_, Presheaf.isSheaf_comp_of_isSheaf K ‚Ñ±'.val\n      (coyoneda.obj (op ((G.op ‚ãô ‚Ñ±).obj X))) ‚Ñ±'.cond‚ü©)\n    (whiskerRight Œ± (coyoneda.obj _)) hf.some.map (ùüô _)\n  simpa using this\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.sheafHom_eq","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_7, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_4} A\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± : CategoryTheory.Functor (Opposite D) A\n‚Ñ±' : CategoryTheory.Sheaf K A\nŒ± : Quiver.Hom ‚Ñ± ‚Ñ±'.val\n‚ä¢ Eq (CategoryTheory.Functor.IsCoverDense.sheafHom (CategoryTheory.whiskerLeft G.op Œ±)) Œ±","decl":"/--\nIf the pullback map is obtained via whiskering,\nthen the result `sheaf_hom (whisker_left G.op Œ±)` is equal to `Œ±`.\n-/\ntheorem sheafHom_eq (Œ± : ‚Ñ± ‚ü∂ ‚Ñ±'.val) : sheafHom (whiskerLeft G.op Œ±) = Œ± := by\n  ext X\n  apply yoneda.map_injective\n  ext U\n  erw [yoneda.map_preimage]\n  symm\n  change (show (‚Ñ±'.val ‚ãô coyoneda.obj (op (unop U))).obj (op (unop X)) from _) = _\n  apply sheaf_eq_amalgamation ‚Ñ±' (G.is_cover_of_isCoverDense _ _)\n  -- Porting note: next line was not needed in mathlib3\n  ¬∑ exact (pushforwardFamily_compatible _ _)\n  intro Y f hf\n  conv_lhs => rw [‚Üê hf.some.fac]\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.iso_of_restrict_iso","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_7, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_4} A\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.IsCoverDense K\ninst‚úù : G.IsLocallyFull K\n‚Ñ± ‚Ñ±' : CategoryTheory.Sheaf K A\nŒ± : Quiver.Hom ‚Ñ± ‚Ñ±'\ni : CategoryTheory.IsIso (CategoryTheory.whiskerLeft G.op Œ±.val)\n‚ä¢ CategoryTheory.IsIso Œ±","decl":"/-- Given a locally-full and cover-dense functor `G` and a natural transformation of sheaves\n`Œ± : ‚Ñ± ‚ü∂ ‚Ñ±'`, if the pullback of `Œ±` along `G` is iso, then `Œ±` is also iso.\n-/\ntheorem iso_of_restrict_iso {‚Ñ± ‚Ñ±' : Sheaf K A} (Œ± : ‚Ñ± ‚ü∂ ‚Ñ±') (i : IsIso (whiskerLeft G.op Œ±.val)) :\n    IsIso Œ± := by\n  convert (sheafIso (asIso (whiskerLeft G.op Œ±.val))).isIso_hom using 1\n  ext1\n  apply (sheafHom_eq _ _).symm\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.compatiblePreserving","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.IsCoverDense K\ninst‚úù¬π : G.IsLocallyFull K\ninst‚úù : G.IsLocallyFaithful K\n‚ä¢ CategoryTheory.CompatiblePreserving K G","decl":"/-- A locally-fully-faithful and cover-dense functor preserves compatible families. -/\nlemma compatiblePreserving [G.IsLocallyFaithful K] : CompatiblePreserving K G := by\n  constructor\n  intro ‚Ñ± Z T x hx Y‚ÇÅ Y‚ÇÇ X f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ eq\n  apply Functor.IsCoverDense.ext G\n  intro W i\n  refine IsLocallyFull.ext G _ (i ‚â´ f‚ÇÅ) fun V‚ÇÅ iVW iV‚ÇÅY‚ÇÅ e‚ÇÅ ‚Ü¶ ?_\n  refine IsLocallyFull.ext G _ (G.map iVW ‚â´ i ‚â´ f‚ÇÇ) fun V‚ÇÇ iV‚ÇÇV‚ÇÅ iV‚ÇÇY‚ÇÇ e‚ÇÇ ‚Ü¶ ?_\n  refine IsLocallyFaithful.ext G _ (iV‚ÇÇV‚ÇÅ ‚â´ iV‚ÇÅY‚ÇÅ ‚â´ g‚ÇÅ) (iV‚ÇÇY‚ÇÇ ‚â´ g‚ÇÇ) (by simp [e‚ÇÅ, e‚ÇÇ, eq]) ?_\n  intro V‚ÇÉ iV‚ÇÉ e‚ÇÑ\n  simp only [‚Üê op_comp, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê e‚ÇÅ, ‚Üê e‚ÇÇ, ‚Üê Functor.map_comp]\n  apply hx\n  simpa using e‚ÇÑ\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.isContinuous","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.IsCoverDense K\ninst‚úù¬π : G.IsLocallyFull K\ninst‚úù : G.IsLocallyFaithful K\nHp : CategoryTheory.CoverPreserving J K G\n‚ä¢ G.IsContinuous J K","decl":"lemma isContinuous [G.IsLocallyFaithful K] (Hp : CoverPreserving J K G) : G.IsContinuous J K :=\n  isContinuous_of_coverPreserving (compatiblePreserving K G) Hp\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.full_sheafPushforwardContinuous","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_1} C\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_7, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_4} A\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.IsCoverDense K\ninst‚úù¬π : G.IsLocallyFull K\ninst‚úù : G.IsContinuous J K\n‚ä¢ (G.sheafPushforwardContinuous A J K).Full","decl":"instance full_sheafPushforwardContinuous [G.IsContinuous J K] :\n    Full (G.sheafPushforwardContinuous A J K) where\n  map_surjective Œ± := ‚ü®‚ü®sheafHom Œ±.val‚ü©, Sheaf.Hom.ext <| sheafHom_restrict_eq Œ±.val‚ü©\n\n"}
{"name":"CategoryTheory.Functor.IsCoverDense.faithful_sheafPushforwardContinuous","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} A\nG : CategoryTheory.Functor C D\ninst‚úù : G.IsContinuous J K\n‚ä¢ (G.sheafPushforwardContinuous A J K).Faithful","decl":"instance faithful_sheafPushforwardContinuous [G.IsContinuous J K] :\n    Faithful (G.sheafPushforwardContinuous A J K) where\n  map_injective := by\n    intro ‚Ñ± ‚Ñ±' Œ± Œ≤ e\n    ext1\n    apply_fun fun e => e.val at e\n    dsimp [sheafPushforwardContinuous] at e\n    rw [‚Üê sheafHom_eq G Œ±.val, ‚Üê sheafHom_eq G Œ≤.val, e]\n\n"}
{"name":"CategoryTheory.Functor.whiskerLeft_obj_map_bijective_of_isCoverDense","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.IsCoverDense K\ninst‚úù¬π : G.IsLocallyFull K\nA : Type u_4\ninst‚úù : CategoryTheory.Category.{u_7, u_4} A\nP Q : CategoryTheory.Functor (Opposite D) A\nhQ : CategoryTheory.Presheaf.IsSheaf K Q\n‚ä¢ Function.Bijective ((CategoryTheory.whiskeringLeft (Opposite C) (Opposite D) A).obj G.op).map","decl":"/-- If `G : C ‚•§ D` is cover dense and full, then the\nmap `(P ‚ü∂ Q) ‚Üí (G.op ‚ãô P ‚ü∂ G.op ‚ãô Q)` is bijective when `Q` is a sheaf`. -/\nlemma whiskerLeft_obj_map_bijective_of_isCoverDense (G : C ‚•§ D)\n    [G.IsCoverDense K] [G.IsLocallyFull K] {A : Type*} [Category A]\n    (P Q : D·µí·µñ ‚•§ A) (hQ : Presheaf.IsSheaf K Q) :\n    Function.Bijective (((whiskeringLeft C·µí·µñ D·µí·µñ A).obj G.op).map : (P ‚ü∂ Q) ‚Üí _) :=\n  (IsCoverDense.restrictHomEquivHom (‚Ñ±' := ‚ü®Q, hQ‚ü©)).symm.bijective\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.isCoverDense'","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\nself : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ G.IsCoverDense K","decl":"/-- The functor `G : C ‚•§ D` exhibits `(C, J)` as a dense subsite of `(D, K)`\nif `G` is cover-dense, locally fully-faithful,\nand `S` is a cover of `C` if and only if the image of `S` in `D` is a cover. -/\nclass IsDenseSubsite : Prop where\n  isCoverDense' : G.IsCoverDense K := by infer_instance\n  isLocallyFull' : G.IsLocallyFull K := by infer_instance\n  isLocallyFaithful' : G.IsLocallyFaithful K := by infer_instance\n  functorPushforward_mem_iff : ‚àÄ {X : C} {S : Sieve X}, S.functorPushforward G ‚àà K _ ‚Üî S ‚àà J _\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.isLocallyFull'","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\nself : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ G.IsLocallyFull K","decl":"/-- The functor `G : C ‚•§ D` exhibits `(C, J)` as a dense subsite of `(D, K)`\nif `G` is cover-dense, locally fully-faithful,\nand `S` is a cover of `C` if and only if the image of `S` in `D` is a cover. -/\nclass IsDenseSubsite : Prop where\n  isCoverDense' : G.IsCoverDense K := by infer_instance\n  isLocallyFull' : G.IsLocallyFull K := by infer_instance\n  isLocallyFaithful' : G.IsLocallyFaithful K := by infer_instance\n  functorPushforward_mem_iff : ‚àÄ {X : C} {S : Sieve X}, S.functorPushforward G ‚àà K _ ‚Üî S ‚àà J _\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.functorPushforward_mem_iff","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\nself : CategoryTheory.Functor.IsDenseSubsite J K G\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Iff (Membership.mem (K (G.obj X)) (CategoryTheory.Sieve.functorPushforward G S)) (Membership.mem (J X) S)","decl":"/-- The functor `G : C ‚•§ D` exhibits `(C, J)` as a dense subsite of `(D, K)`\nif `G` is cover-dense, locally fully-faithful,\nand `S` is a cover of `C` if and only if the image of `S` in `D` is a cover. -/\nclass IsDenseSubsite : Prop where\n  isCoverDense' : G.IsCoverDense K := by infer_instance\n  isLocallyFull' : G.IsLocallyFull K := by infer_instance\n  isLocallyFaithful' : G.IsLocallyFaithful K := by infer_instance\n  functorPushforward_mem_iff : ‚àÄ {X : C} {S : Sieve X}, S.functorPushforward G ‚àà K _ ‚Üî S ‚àà J _\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.isLocallyFaithful'","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\nself : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ G.IsLocallyFaithful K","decl":"/-- The functor `G : C ‚•§ D` exhibits `(C, J)` as a dense subsite of `(D, K)`\nif `G` is cover-dense, locally fully-faithful,\nand `S` is a cover of `C` if and only if the image of `S` in `D` is a cover. -/\nclass IsDenseSubsite : Prop where\n  isCoverDense' : G.IsCoverDense K := by infer_instance\n  isLocallyFull' : G.IsLocallyFull K := by infer_instance\n  isLocallyFaithful' : G.IsLocallyFaithful K := by infer_instance\n  functorPushforward_mem_iff : ‚àÄ {X : C} {S : Sieve X}, S.functorPushforward G ‚àà K _ ‚Üî S ‚àà J _\n\n"}
{"name":"CategoryTheory.Functor.functorPushforward_mem_iff","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\nX : C\nS : CategoryTheory.Sieve X\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ Iff (Membership.mem (K (G.obj X)) (CategoryTheory.Sieve.functorPushforward G S)) (Membership.mem (J X) S)","decl":"lemma functorPushforward_mem_iff {X : C} {S : Sieve X} [G.IsDenseSubsite J K]:\n    S.functorPushforward G ‚àà K _ ‚Üî S ‚àà J _ := IsDenseSubsite.functorPushforward_mem_iff\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.isCoverDense","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ G.IsCoverDense K","decl":"lemma isCoverDense : G.IsCoverDense K := isCoverDense' J\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.isLocallyFull","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ G.IsLocallyFull K","decl":"lemma isLocallyFull : G.IsLocallyFull K := isLocallyFull' J\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.isLocallyFaithful","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ G.IsLocallyFaithful K","decl":"lemma isLocallyFaithful : G.IsLocallyFaithful K := isLocallyFaithful' J\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.coverPreserving","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ CategoryTheory.CoverPreserving J K G","decl":"lemma coverPreserving : CoverPreserving J K G :=\n  ‚ü®functorPushforward_mem_iff.mpr‚ü©\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.instIsContinuous","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ G.IsContinuous J K","decl":"instance (priority := 900) : G.IsContinuous J K :=\n  letI := IsDenseSubsite.isCoverDense J K G\n  letI := IsDenseSubsite.isLocallyFull J K G\n  letI := IsDenseSubsite.isLocallyFaithful J K G\n  IsCoverDense.isContinuous J K G (IsDenseSubsite.coverPreserving J K G)\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.instIsCocontinuous","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ G.IsCocontinuous J K","decl":"instance (priority := 900) : G.IsCocontinuous J K where\n  cover_lift hS :=\n    letI := IsDenseSubsite.isCoverDense J K G\n    letI := IsDenseSubsite.isLocallyFull J K G\n    IsDenseSubsite.functorPushforward_mem_iff.mp\n      (IsCoverDense.functorPullback_pushforward_covering ‚ü®_, hS‚ü©)\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.full_sheafPushforwardContinuous","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} A\nG : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ (G.sheafPushforwardContinuous A J K).Full","decl":"instance full_sheafPushforwardContinuous :\n    Full (G.sheafPushforwardContinuous A J K) :=\n  letI := IsDenseSubsite.isCoverDense J K G\n  letI := IsDenseSubsite.isLocallyFull J K G\n  inferInstance\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.faithful_sheafPushforwardContinuous","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_1} C\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nA : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} A\nG : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\n‚ä¢ (G.sheafPushforwardContinuous A J K).Faithful","decl":"instance faithful_sheafPushforwardContinuous :\n    Faithful (G.sheafPushforwardContinuous A J K) :=\n  letI := IsDenseSubsite.isCoverDense J K G\n  letI := IsDenseSubsite.isLocallyFull J K G\n  inferInstance\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.imageSieve_mem","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\nU V : C\nf : Quiver.Hom (G.obj U) (G.obj V)\n‚ä¢ Membership.mem (J U) (G.imageSieve f)","decl":"lemma imageSieve_mem {U V} (f : G.obj U ‚ü∂ G.obj V) :\n    G.imageSieve f ‚àà J _ :=\n  letI := IsDenseSubsite.isLocallyFull J K G\n  IsDenseSubsite.functorPushforward_mem_iff.mp (G.functorPushforward_imageSieve_mem K f)\n\n"}
{"name":"CategoryTheory.Functor.IsDenseSubsite.equalizer_mem","module":"Mathlib.CategoryTheory.Sites.DenseSubsite.Basic","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_2} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Functor.IsDenseSubsite J K G\nU V : C\nf‚ÇÅ f‚ÇÇ : Quiver.Hom U V\ne : Eq (G.map f‚ÇÅ) (G.map f‚ÇÇ)\n‚ä¢ Membership.mem (J U) (CategoryTheory.Sieve.equalizer f‚ÇÅ f‚ÇÇ)","decl":"lemma equalizer_mem {U V} (f‚ÇÅ f‚ÇÇ : U ‚ü∂ V) (e : G.map f‚ÇÅ = G.map f‚ÇÇ) :\n    Sieve.equalizer f‚ÇÅ f‚ÇÇ ‚àà J _ :=\n  letI := IsDenseSubsite.isLocallyFaithful J K G\n  IsDenseSubsite.functorPushforward_mem_iff.mp (G.functorPushforward_equalizer_mem K f‚ÇÅ f‚ÇÇ e)\n\n"}
