{"name":"Equiv.asEmbedding_range","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Sort u_1\nβ : Type u_2\np : β → Prop\ne : Equiv α (Subtype p)\n⊢ Eq (Set.range ⇑e.asEmbedding) (setOf p)","decl":"@[simp]\ntheorem Equiv.asEmbedding_range {α β : Sort _} {p : β → Prop} (e : α ≃ Subtype p) :\n    Set.range e.asEmbedding = setOf p :=\n  Set.ext fun x ↦ ⟨fun ⟨y, h⟩ ↦ h ▸ Subtype.coe_prop (e y), fun hs ↦ ⟨e.symm ⟨x, hs⟩, by simp⟩⟩\n\n"}
{"name":"Function.Embedding.coeWithTop_apply","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\na✝ : α\n⊢ Eq (Function.Embedding.coeWithTop a✝) ↑a✝","decl":"/-- Embedding into `WithTop α`. -/\n@[simps]\ndef coeWithTop {α} : α ↪ WithTop α :=\n  { Embedding.some with toFun := WithTop.some }\n\n"}
{"name":"Function.Embedding.optionElim_apply","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\nx : β\nh : Not (Membership.mem (Set.range ⇑f) x)\na✝ : Option α\n⊢ Eq ((f.optionElim x h) a✝) (Option.elim' x (⇑f) a✝)","decl":"/-- Given an embedding `f : α ↪ β` and a point outside of `Set.range f`, construct an embedding\n`Option α ↪ β`. -/\n@[simps]\ndef optionElim {α β} (f : α ↪ β) (x : β) (h : x ∉ Set.range f) : Option α ↪ β :=\n  ⟨Option.elim' x f, Option.injective_iff.2 ⟨f.2, h⟩⟩\n\n"}
{"name":"Function.Embedding.optionEmbeddingEquiv_apply_fst","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding (Option α) β\n⊢ Eq ((Function.Embedding.optionEmbeddingEquiv α β) f).fst (Function.Embedding.coeWithTop.trans f)","decl":"/-- Equivalence between embeddings of `Option α` and a sigma type over the embeddings of `α`. -/\n@[simps]\ndef optionEmbeddingEquiv (α β) : (Option α ↪ β) ≃ Σ f : α ↪ β, ↥(Set.range f)ᶜ where\n  toFun f := ⟨coeWithTop.trans f, f none, fun ⟨x, hx⟩ ↦ Option.some_ne_none x <| f.injective hx⟩\n  invFun f := f.1.optionElim f.2 f.2.2\n  left_inv f := ext <| by rintro (_ | _) <;> simp [Option.coe_def]; rfl\n  right_inv := fun ⟨f, y, hy⟩ ↦ by ext <;> simp [Option.coe_def]; rfl\n\n"}
{"name":"Function.Embedding.optionEmbeddingEquiv_symm_apply","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Sigma fun f => ↑(HasCompl.compl (Set.range ⇑f))\n⊢ Eq ((Function.Embedding.optionEmbeddingEquiv α β).symm f) (f.fst.optionElim ↑f.snd ⋯)","decl":"/-- Equivalence between embeddings of `Option α` and a sigma type over the embeddings of `α`. -/\n@[simps]\ndef optionEmbeddingEquiv (α β) : (Option α ↪ β) ≃ Σ f : α ↪ β, ↥(Set.range f)ᶜ where\n  toFun f := ⟨coeWithTop.trans f, f none, fun ⟨x, hx⟩ ↦ Option.some_ne_none x <| f.injective hx⟩\n  invFun f := f.1.optionElim f.2 f.2.2\n  left_inv f := ext <| by rintro (_ | _) <;> simp [Option.coe_def]; rfl\n  right_inv := fun ⟨f, y, hy⟩ ↦ by ext <;> simp [Option.coe_def]; rfl\n\n"}
{"name":"Function.Embedding.optionEmbeddingEquiv_apply_snd_coe","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding (Option α) β\n⊢ Eq (↑((Function.Embedding.optionEmbeddingEquiv α β) f).snd) (f Option.none)","decl":"/-- Equivalence between embeddings of `Option α` and a sigma type over the embeddings of `α`. -/\n@[simps]\ndef optionEmbeddingEquiv (α β) : (Option α ↪ β) ≃ Σ f : α ↪ β, ↥(Set.range f)ᶜ where\n  toFun f := ⟨coeWithTop.trans f, f none, fun ⟨x, hx⟩ ↦ Option.some_ne_none x <| f.injective hx⟩\n  invFun f := f.1.optionElim f.2 f.2.2\n  left_inv f := ext <| by rintro (_ | _) <;> simp [Option.coe_def]; rfl\n  right_inv := fun ⟨f, y, hy⟩ ↦ by ext <;> simp [Option.coe_def]; rfl\n\n"}
{"name":"Function.Embedding.codRestrict_apply","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Sort u_1\nβ : Type u_2\np : Set β\nf : Function.Embedding α β\nH : ∀ (a : α), Membership.mem p (f a)\na : α\n⊢ Eq ((Function.Embedding.codRestrict p f H) a) ⟨f a, ⋯⟩","decl":"@[simp]\ntheorem codRestrict_apply {α β} (p) (f : α ↪ β) (H a) : codRestrict p f H a = ⟨f a, H a⟩ :=\n  rfl\n\n"}
{"name":"Function.Embedding.image_apply","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ns : Set α\n⊢ Eq (f.image s) (Set.image (⇑f) s)","decl":"/-- `Set.image` as an embedding `Set α ↪ Set β`. -/\n@[simps apply]\nprotected def image {α β} (f : α ↪ β) : Set α ↪ Set β :=\n  ⟨image f, f.2.image_injective⟩\n\n"}
{"name":"Set.embeddingOfSubset_apply_coe","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\nx : ↑s\n⊢ Eq ↑((s.embeddingOfSubset t h) x) ↑x","decl":"/-- The injection map is an embedding between subsets. -/\n@[simps apply_coe]\ndef embeddingOfSubset {α} (s t : Set α) (h : s ⊆ t) : s ↪ t :=\n  ⟨fun x ↦ ⟨x.1, h x.2⟩, fun ⟨x, hx⟩ ⟨y, hy⟩ h ↦ by\n    congr\n    injection h⟩\n\n"}
{"name":"subtypeOrEquiv_apply","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝ : DecidablePred p\nh : Disjoint p q\na : Subtype fun x => Or (p x) (q x)\n⊢ Eq ((subtypeOrEquiv p q h) a) ((subtypeOrLeftEmbedding p q) a)","decl":"/-- A subtype `{x // p x ∨ q x}` over a disjunction of `p q : α → Prop` is equivalent to a sum of\nsubtypes `{x // p x} ⊕ {x // q x}` such that `¬ p x` is sent to the right, when\n`Disjoint p q`.\n\nSee also `Equiv.sumCompl`, for when `IsCompl p q`. -/\n@[simps apply]\ndef subtypeOrEquiv (p q : α → Prop) [DecidablePred p] (h : Disjoint p q) :\n    { x // p x ∨ q x } ≃ { x // p x } ⊕ { x // q x } where\n  toFun := subtypeOrLeftEmbedding p q\n  invFun :=\n    Sum.elim (Subtype.impEmbedding _ _ fun x hx ↦ (Or.inl hx : p x ∨ q x))\n      (Subtype.impEmbedding _ _ fun x hx ↦ (Or.inr hx : p x ∨ q x))\n  left_inv x := by\n    by_cases hx : p x\n    · rw [subtypeOrLeftEmbedding_apply_left _ hx]\n      simp [Subtype.ext_iff]\n    · rw [subtypeOrLeftEmbedding_apply_right _ hx]\n      simp [Subtype.ext_iff]\n  right_inv x := by\n    cases x with\n    | inl x =>\n        simp only [Sum.elim_inl]\n        rw [subtypeOrLeftEmbedding_apply_left]\n        · simp\n        · simpa using x.prop\n    | inr x =>\n        simp only [Sum.elim_inr]\n        rw [subtypeOrLeftEmbedding_apply_right]\n        · simp\n        · suffices ¬p x by simpa\n          intro hp\n          simpa using h.le_bot x ⟨hp, x.prop⟩\n\n"}
{"name":"subtypeOrEquiv_symm_inl","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝ : DecidablePred p\nh : Disjoint p q\nx : Subtype fun x => p x\n⊢ Eq ((subtypeOrEquiv p q h).symm (Sum.inl x)) ⟨↑x, ⋯⟩","decl":"@[simp]\ntheorem subtypeOrEquiv_symm_inl (p q : α → Prop) [DecidablePred p] (h : Disjoint p q)\n    (x : { x // p x }) : (subtypeOrEquiv p q h).symm (Sum.inl x) = ⟨x, Or.inl x.prop⟩ :=\n  rfl\n\n"}
{"name":"subtypeOrEquiv_symm_inr","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝ : DecidablePred p\nh : Disjoint p q\nx : Subtype fun x => q x\n⊢ Eq ((subtypeOrEquiv p q h).symm (Sum.inr x)) ⟨↑x, ⋯⟩","decl":"@[simp]\ntheorem subtypeOrEquiv_symm_inr (p q : α → Prop) [DecidablePred p] (h : Disjoint p q)\n    (x : { x // q x }) : (subtypeOrEquiv p q h).symm (Sum.inr x) = ⟨x, Or.inr x.prop⟩ :=\n  rfl\n\n"}
{"name":"Function.Embedding.sumSet_apply","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\ns t : Set α\nh : Disjoint s t\na✝ : Sum ↑s ↑t\n⊢ Eq ((Function.Embedding.sumSet h) a✝) (Sum.elim Subtype.val Subtype.val a✝)","decl":"/-- For disjoint `s t : Set α`, the natural injection from `↑s ⊕ ↑t` to `α`. -/\n@[simps] def Function.Embedding.sumSet (h : Disjoint s t) : s ⊕ t ↪ α where\n  toFun := Sum.elim (↑) (↑)\n  inj' := by\n    rintro (⟨a, ha⟩ | ⟨a, ha⟩) (⟨b, hb⟩ | ⟨b, hb⟩)\n    · simp [Subtype.val_inj]\n    · simpa using h.ne_of_mem ha hb\n    · simpa using h.symm.ne_of_mem ha hb\n    simp [Subtype.val_inj]\n\n"}
{"name":"Function.Embedding.coe_sumSet","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\ns t : Set α\nh : Disjoint s t\n⊢ Eq (⇑(Function.Embedding.sumSet h)) (Sum.elim Subtype.val Subtype.val)","decl":"@[norm_cast] lemma Function.Embedding.coe_sumSet (h : Disjoint s t) :\n    (Function.Embedding.sumSet h : s ⊕ t → α) = Sum.elim (↑) (↑) := rfl\n\n"}
{"name":"Function.Embedding.sumSet_preimage_inl","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\ns t r : Set α\nh : Disjoint s t\n⊢ Eq (Set.image Subtype.val (Set.preimage Sum.inl (Set.preimage (⇑(Function.Embedding.sumSet h)) r))) (Inter.inter r s)","decl":"@[simp] theorem Function.Embedding.sumSet_preimage_inl (h : Disjoint s t) :\n    .inl ⁻¹' (Function.Embedding.sumSet h ⁻¹' r) = r ∩ s := by\n  simp [Set.ext_iff]\n\n"}
{"name":"Function.Embedding.sumSet_preimage_inr","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\ns t r : Set α\nh : Disjoint s t\n⊢ Eq (Set.image Subtype.val (Set.preimage Sum.inr (Set.preimage (⇑(Function.Embedding.sumSet h)) r))) (Inter.inter r t)","decl":"@[simp] theorem Function.Embedding.sumSet_preimage_inr (h : Disjoint s t) :\n    .inr ⁻¹' (Function.Embedding.sumSet h ⁻¹' r) = r ∩ t := by\n  simp [Set.ext_iff]\n\n"}
{"name":"Function.Embedding.sumSet_range","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\ns t : Set α\nh : Disjoint s t\n⊢ Eq (Set.range ⇑(Function.Embedding.sumSet h)) (Union.union s t)","decl":"@[simp] theorem Function.Embedding.sumSet_range {s t : Set α} (h : Disjoint s t) :\n    range (Function.Embedding.sumSet h) = s ∪ t := by\n  simp [Set.ext_iff]\n\n"}
{"name":"Function.Embedding.sigmaSet_apply","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\nι : Type u_2\ns : ι → Set α\nh : Pairwise (Function.onFun Disjoint s)\nx : Sigma fun i => ↑(s i)\n⊢ Eq ((Function.Embedding.sigmaSet h) x) ↑x.snd","decl":"/-- For an indexed family `s : ι → Set α` of disjoint sets,\nthe natural injection from the sigma-type `(i : ι) × ↑(s i)` to `α`. -/\n@[simps] def Function.Embedding.sigmaSet {s : ι → Set α} (h : Pairwise (Disjoint on s)) :\n    (i : ι) × s i ↪ α where\n  toFun x := x.2.1\n  inj' := by\n    rintro ⟨i, x, hx⟩ ⟨j, -, hx'⟩ rfl\n    obtain rfl : i = j := h.eq (not_disjoint_iff.2 ⟨_, hx, hx'⟩)\n    rfl\n\n"}
{"name":"Function.Embedding.coe_sigmaSet","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\nι : Type u_2\ns : ι → Set α\nh : Pairwise (Function.onFun Disjoint s)\n⊢ Eq ⇑(Function.Embedding.sigmaSet h) fun x => ↑x.snd","decl":"@[norm_cast] lemma Function.Embedding.coe_sigmaSet {s : ι → Set α} (h) :\n    (Function.Embedding.sigmaSet h : ((i : ι) × s i) → α) = fun x ↦ x.2.1 := rfl\n\n"}
{"name":"Function.Embedding.sigmaSet_preimage","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\nι : Type u_2\ns : ι → Set α\nh : Pairwise (Function.onFun Disjoint s)\ni : ι\nr : Set α\n⊢ Eq (Set.image Subtype.val (Set.preimage (Sigma.mk i) (Set.preimage (⇑(Function.Embedding.sigmaSet h)) r))) (Inter.inter r (s i))","decl":"@[simp] theorem Function.Embedding.sigmaSet_preimage {s : ι → Set α}\n    (h : Pairwise (Disjoint on s)) (i : ι) (r : Set α) :\n    Sigma.mk i ⁻¹' (Function.Embedding.sigmaSet h ⁻¹' r) = r ∩ s i := by\n  simp [Set.ext_iff]\n\n"}
{"name":"Function.Embedding.sigmaSet_range","module":"Mathlib.Logic.Embedding.Set","initialProofState":"α : Type u_1\nι : Type u_2\ns : ι → Set α\nh : Pairwise (Function.onFun Disjoint s)\n⊢ Eq (Set.range ⇑(Function.Embedding.sigmaSet h)) (Set.iUnion fun i => s i)","decl":"@[simp] theorem Function.Embedding.sigmaSet_range {s : ι → Set α}\n    (h : Pairwise (Disjoint on s)) : Set.range (Function.Embedding.sigmaSet h) = ⋃ i, s i := by\n  simp [Set.ext_iff]\n\n"}
