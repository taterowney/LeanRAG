{"name":"LieAlgebra.engel_isBot_of_isMin.lieCharpoly_monic","module":"Mathlib.Algebra.Lie.CartanExists","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : Module.Finite R L\ninst✝² : Module.Free R L\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Free R M\nx y : L\n⊢ (LieAlgebra.engel_isBot_of_isMin.lieCharpoly R M x y).Monic","decl":"lemma lieCharpoly_monic : (lieCharpoly R M x y).Monic :=\n  (polyCharpoly_monic _ _).map _\n\n"}
{"name":"LieAlgebra.engel_isBot_of_isMin.lieCharpoly_natDegree","module":"Mathlib.Algebra.Lie.CartanExists","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : Module.Finite R L\ninst✝³ : Module.Free R L\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Free R M\nx y : L\ninst✝ : Nontrivial R\n⊢ Eq (LieAlgebra.engel_isBot_of_isMin.lieCharpoly R M x y).natDegree (Module.finrank R M)","decl":"lemma lieCharpoly_natDegree [Nontrivial R] : (lieCharpoly R M x y).natDegree = finrank R M := by\n  rw [lieCharpoly, (polyCharpoly_monic _ _).natDegree_map, polyCharpoly_natDegree]\n\n"}
{"name":"LieAlgebra.engel_isBot_of_isMin.lieCharpoly_map_eval","module":"Mathlib.Algebra.Lie.CartanExists","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : Module.Finite R L\ninst✝² : Module.Free R L\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Free R M\nx y : L\nr : R\n⊢ Eq (Polynomial.map (Polynomial.evalRingHom r) (LieAlgebra.engel_isBot_of_isMin.lieCharpoly R M x y)) (LinearMap.charpoly ((LieModule.toEnd R L M) (HAdd.hAdd (HSMul.hSMul r y) x)))","decl":"variable {R} in\nlemma lieCharpoly_map_eval (r : R) :\n    (lieCharpoly R M x y).map (evalRingHom r) = (φ (r • y + x)).charpoly := by\n  rw [lieCharpoly, map_map]\n  set b := chooseBasis R L\n  have aux : (fun i ↦ (b.repr y) i * r + (b.repr x) i) = b.repr (r • y + x) := by\n    ext i; simp [mul_comm r]\n  simp_rw [← coe_aeval_eq_evalRingHom, ← AlgHom.comp_toRingHom, MvPolynomial.comp_aeval,\n    map_add, map_mul, aeval_C, Algebra.id.map_eq_id, RingHom.id_apply, aeval_X, aux,\n    MvPolynomial.coe_aeval_eq_eval, polyCharpoly_map_eq_charpoly, LieHom.coe_toLinearMap]\n\n"}
{"name":"LieAlgebra.engel_isBot_of_isMin.lieCharpoly_coeff_natDegree","module":"Mathlib.Algebra.Lie.CartanExists","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : Module.Finite R L\ninst✝³ : Module.Free R L\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Free R M\nx y : L\ninst✝ : Nontrivial R\ni j : Nat\nhij : Eq (HAdd.hAdd i j) (Module.finrank R M)\n⊢ LE.le ((LieAlgebra.engel_isBot_of_isMin.lieCharpoly R M x y).coeff i).natDegree j","decl":"lemma lieCharpoly_coeff_natDegree [Nontrivial R] (i j : ℕ) (hij : i + j = finrank R M) :\n    ((lieCharpoly R M x y).coeff i).natDegree ≤ j := by\n  classical\n  rw [← mul_one j, lieCharpoly, coeff_map]\n  apply MvPolynomial.aeval_natDegree_le\n  · apply (polyCharpoly_coeff_isHomogeneous φ (chooseBasis R L) _ _ hij).totalDegree_le\n  intro k\n  apply Polynomial.natDegree_add_le_of_degree_le\n  · apply (Polynomial.natDegree_C_mul_le _ _).trans\n    simp only [natDegree_X, le_rfl]\n  · simp only [natDegree_C, zero_le]\n\n"}
{"name":"LieAlgebra.engel_isBot_of_isMin","module":"Mathlib.Algebra.Lie.CartanExists","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra K L\ninst✝ : Module.Finite K L\nhLK : LE.le (↑(Module.finrank K L)) (Cardinal.mk K)\nU : LieSubalgebra K L\nE : ↑(setOf fun x => Exists fun x_1 => And (Membership.mem U x_1) (Eq (LieSubalgebra.engel K x_1) x))\nhUle : LE.le U ↑E\nhmin : IsMin E\n⊢ IsBot E","decl":"/-- Let `L` be a Lie algebra of dimension `n` over a field `K` with at least `n` elements.\nGiven a Lie subalgebra `U` of `L`, and an element `x ∈ U` such that `U ≤ engel K x`.\nSuppose that `engel K x` is minimal amongst the Engel subalgebras `engel K y` for `y ∈ U`.\nThen `engel K x ≤ engel K y` for all `y ∈ U`.\n\nLemma 2 in [barnes1967]. -/\nlemma engel_isBot_of_isMin (hLK : finrank K L ≤ #K) (U : LieSubalgebra K L)\n    (E : {engel K x | x ∈ U}) (hUle : U ≤ E) (hmin : IsMin E) :\n    IsBot E := by\n  rcases E with ⟨_, x, hxU, rfl⟩\n  rintro ⟨_, y, hyU, rfl⟩\n  -- It will be useful to repackage the Engel subalgebras\n  set Ex : {engel K x | x ∈ U} := ⟨engel K x, x, hxU, rfl⟩\n  set Ey : {engel K y | y ∈ U} := ⟨engel K y, y, hyU, rfl⟩\n  replace hUle : U ≤ Ex := hUle\n  replace hmin : ∀ E, E ≤ Ex → Ex ≤ E := @hmin\n  -- We also repackage the Engel subalgebra `engel K x`\n  -- as Lie submodule `E` of `L` over the Lie algebra `U`.\n  let E : LieSubmodule K U L :=\n  { engel K x with\n    lie_mem := by rintro ⟨u, hu⟩ y hy; exact (engel K x).lie_mem (hUle hu) hy }\n  -- We may and do assume that `x ≠ 0`, since otherwise the statement is trivial.\n  obtain rfl|hx₀ := eq_or_ne x 0\n  · simpa [Ex, Ey] using hmin Ey\n  -- We denote by `Q` the quotient `L / E`, and by `r` the dimension of `E`.\n  let Q := L ⧸ E\n  let r := finrank K E\n  -- If `r = finrank K L`, then `E = L`, and the statement is trivial.\n  obtain hr|hr : r = finrank K L ∨ r < finrank K L := (Submodule.finrank_le _).eq_or_lt\n  · suffices engel K y ≤ engel K x from hmin Ey this\n    suffices engel K x = ⊤ by simp_rw [this, le_top]\n    apply LieSubalgebra.toSubmodule_injective\n    apply Submodule.eq_top_of_finrank_eq hr\n  -- So from now on, we assume that `r < finrank K L`.\n  -- We denote by `x'` and `y'` the elements `x` and `y` viewed as terms of `U`.\n  set x' : U := ⟨x, hxU⟩\n  set y' : U := ⟨y, hyU⟩\n  -- Let `u : U` denote `y - x`.\n  let u : U := y' - x'\n  -- We denote by `χ r` the characteristic polynomial of `⁅r • u + x, _⁆`\n  --   viewed as endomorphism of `E`. Note that `χ` is polynomial in its argument `r`.\n  -- Similarly: `ψ r` is the characteristic polynomial of `⁅r • u + x, _⁆`\n  --   viewed as endomorphism of `Q`. Note that `ψ` is polynomial in its argument `r`.\n  let χ : Polynomial (K[X]) := lieCharpoly K E x' u\n  let ψ : Polynomial (K[X]) := lieCharpoly K Q x' u\n  -- It suffices to show that `χ` is the monomial `X ^ r`.\n  suffices χ = X ^ r by\n    -- Indeed, by evaluating the coefficients at `1`\n    apply_fun (fun p ↦ p.map (evalRingHom 1)) at this\n    -- we find that the characteristic polynomial `χ 1` of `⁅y, _⁆` is equal to `X ^ r`\n    simp_rw [Polynomial.map_pow, map_X, χ, lieCharpoly_map_eval, one_smul, u, sub_add_cancel,\n      -- and therefore the endomorphism `⁅y, _⁆` acts nilpotently on `E`.\n      r, LinearMap.charpoly_eq_X_pow_iff,\n      Subtype.ext_iff, coe_toEnd_pow _ _ _ E, ZeroMemClass.coe_zero] at this\n    -- We ultimately want to show `engel K x ≤ engel K y`\n    intro z hz\n    -- which holds by definition of Engel subalgebra and the nilpotency that we just established.\n    rw [mem_engel_iff]\n    exact this ⟨z, hz⟩\n  -- To show that `χ = X ^ r`, it suffices to show that all coefficients in degrees `< r` are `0`.\n  suffices ∀ i < r, χ.coeff i = 0 by\n    simp_rw [r, ← lieCharpoly_natDegree K E x' u] at this ⊢\n    rw [(lieCharpoly_monic K E x' u).eq_X_pow_iff_natDegree_le_natTrailingDegree]\n    exact le_natTrailingDegree (lieCharpoly_monic K E x' u).ne_zero this\n  -- Let us consider the `i`-th coefficient of `χ`, for `i < r`.\n  intro i hi\n  -- We separately consider the case `i = 0`.\n  obtain rfl|hi0 := eq_or_ne i 0\n  · -- `The polynomial `coeff χ 0` is zero if it evaluates to zero on all elements of `K`,\n    -- provided that its degree is stictly less than `#K`.\n    apply eq_zero_of_forall_eval_zero_of_natDegree_lt_card _ _ ?deg\n    case deg =>\n      -- We need to show `(natDegree (coeff χ 0)) < #K` and know that `finrank K L ≤ #K`\n      apply lt_of_lt_of_le _ hLK\n      rw [Nat.cast_lt]\n      -- So we are left with showing `natDegree (coeff χ 0) < finrank K L`\n      apply lt_of_le_of_lt _ hr\n      apply lieCharpoly_coeff_natDegree _ _ _ _ 0 r (zero_add r)\n    -- Fix an element of `K`.\n    intro α\n    -- We want to show that `α` is a root of `coeff χ 0`.\n    -- So we need to show that there is a `z ≠ 0` in `E` satisfying `⁅α • u + x, z⁆ = 0`.\n    rw [← coe_evalRingHom, ← coeff_map, lieCharpoly_map_eval,\n      ← constantCoeff_apply, LinearMap.charpoly_constantCoeff_eq_zero_iff]\n    -- We consider `z = α • u + x`, and split into the cases `z = 0` and `z ≠ 0`.\n    let z := α • u + x'\n    obtain hz₀|hz₀ := eq_or_ne z 0\n    · -- If `z = 0`, then `⁅α • u + x, x⁆` vanishes and we use our assumption `x ≠ 0`.\n      refine ⟨⟨x, self_mem_engel K x⟩, ?_, ?_⟩\n      · exact Subtype.coe_ne_coe.mp hx₀\n      · dsimp only [z] at hz₀\n        simp only [coe_bracket_of_module, hz₀, LieHom.map_zero, LinearMap.zero_apply]\n    -- If `z ≠ 0`, then `⁅α • u + x, z⁆` vanishes per axiom of Lie algebras\n    refine ⟨⟨z, hUle z.2⟩, ?_, ?_⟩\n    · simpa only [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero, Subtype.ext_iff] using hz₀\n    · show ⁅z, _⁆ = (0 : E)\n      ext\n      exact lie_self z.1\n  -- We are left with the case `i ≠ 0`, and want to show `coeff χ i = 0`.\n  -- We will do this once again by showing that `coeff χ i` vanishes\n  -- on a sufficiently large subset `s` of `K`.\n  -- But we first need to get our hands on that subset `s`.\n  -- We start by observing that `ψ` has non-trivial constant coefficient.\n  have hψ : constantCoeff ψ ≠ 0 := by\n    -- Suppose that `ψ` in fact has trivial constant coefficient.\n    intro H\n    -- Then there exists a `z ≠ 0` in `Q` such that `⁅x, z⁆ = 0`.\n    obtain ⟨z, hz0, hxz⟩ : ∃ z : Q, z ≠ 0 ∧ ⁅x', z⁆ = 0 := by\n      -- Indeed, if the constant coefficient of `ψ` is trivial,\n      -- then `0` is a root of the characteristic polynomial of `⁅0 • u + x, _⁆` acting on `Q`,\n      -- and hence we find an eigenvector `z` as desired.\n      apply_fun (evalRingHom 0) at H\n      rw [constantCoeff_apply, ← coeff_map, lieCharpoly_map_eval,\n        ← constantCoeff_apply, map_zero, LinearMap.charpoly_constantCoeff_eq_zero_iff] at H\n      simpa only [coe_bracket_of_module, ne_eq, zero_smul, zero_add, toEnd_apply_apply]\n        using H\n    -- It suffices to show `z = 0` (in `Q`) to obtain a contradiction.\n    apply hz0\n    -- We replace `z : Q` by a representative in `L`.\n    obtain ⟨z, rfl⟩ := LieSubmodule.Quotient.surjective_mk' E z\n    -- The assumption `⁅x, z⁆ = 0` is equivalent to `⁅x, z⁆ ∈ E`.\n    have : ⁅x, z⁆ ∈ E := by rwa [← LieSubmodule.Quotient.mk_eq_zero']\n    -- From this we deduce that there exists an `n` such that `⁅x, _⁆ ^ n` vanishes on `⁅x, z⁆`.\n    -- On the other hand, our goal is to show `z = 0` in `Q`,\n    -- which is equivalent to showing that `⁅x, _⁆ ^ n` vanishes on `z`, for some `n`.\n    simp only [coe_bracket_of_module, LieSubmodule.mem_mk_iff', LieSubalgebra.mem_toSubmodule,\n      mem_engel_iff, LieSubmodule.Quotient.mk'_apply, LieSubmodule.Quotient.mk_eq_zero', E, Q]\n      at this ⊢\n    -- Hence we win.\n    obtain ⟨n, hn⟩ := this\n    use n+1\n    rwa [pow_succ]\n  -- Now we find a subset `s` of `K` of size `≥ r`\n  -- such that `constantCoeff ψ` takes non-zero values on all of `s`.\n  -- This turns out to be the subset that we alluded to earlier.\n  obtain ⟨s, hs, hsψ⟩ : ∃ s : Finset K, r ≤ s.card ∧ ∀ α ∈ s, (constantCoeff ψ).eval α ≠ 0 := by\n    classical\n    -- Let `t` denote the set of roots of `constantCoeff ψ`.\n    let t := (constantCoeff ψ).roots.toFinset\n    -- We show that `t` has cardinality at most `finrank K L - r`.\n    have ht : t.card ≤ finrank K L - r := by\n      refine (Multiset.toFinset_card_le _).trans ?_\n      refine (card_roots' _).trans ?_\n      rw [constantCoeff_apply]\n      -- Indeed, `constantCoeff ψ` has degree at most `finrank K Q = finrank K L - r`.\n      apply lieCharpoly_coeff_natDegree\n      suffices finrank K Q + r = finrank K L by rw [← this, zero_add, Nat.add_sub_cancel]\n      apply Submodule.finrank_quotient_add_finrank\n    -- Hence there exists a subset of size `≥ r` in the complement of `t`,\n    -- and `constantCoeff ψ` takes non-zero values on all of this subset.\n    obtain ⟨s, hs⟩ := exists_finset_le_card K _ hLK\n    use s \\ t\n    refine ⟨?_, ?_⟩\n    · refine le_trans ?_ (Finset.le_card_sdiff _ _)\n      omega\n    · intro α hα\n      simp only [Finset.mem_sdiff, Multiset.mem_toFinset, mem_roots', IsRoot.def, not_and, t] at hα\n      exact hα.2 hψ\n  -- So finally we can continue our proof strategy by showing that `coeff χ i` vanishes on `s`.\n  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero' _ s _ ?hcard\n  case hcard =>\n    -- We need to show that `natDegree (coeff χ i) < s.card`\n    -- Which follows from our assumptions `i < r` and `r ≤ s.card`\n    -- and the fact that the degree of `coeff χ i` is less than or equal to `r - i`.\n    apply lt_of_le_of_lt (lieCharpoly_coeff_natDegree _ _ _ _ i (r - i) _)\n    · omega\n    · dsimp only [r] at hi ⊢\n      rw [Nat.add_sub_cancel' hi.le]\n  -- We need to show that for all `α ∈ s`, the polynomial `coeff χ i` evaluates to zero at `α`.\n  intro α hα\n  -- Once again, we are left with showing that `⁅y, _⁆` acts nilpotently on `E`.\n  rw [← coe_evalRingHom, ← coeff_map, lieCharpoly_map_eval,\n    (LinearMap.charpoly_eq_X_pow_iff _).mpr, coeff_X_pow, if_neg hi.ne]\n  -- To do so, it suffices to show that the Engel subalgebra of `v = a • u + x` is contained in `E`.\n  let v := α • u + x'\n  suffices engel K (v : L) ≤ engel K x by\n    -- Indeed, in that case the minimality assumption on `E` implies\n    -- that `E` is contained in the Engel subalgebra of `v`.\n    replace this : engel K x ≤ engel K (v : L) := (hmin ⟨_, v, v.2, rfl⟩ this).ge\n    intro z\n    -- And so we are done, by the definition of Engel subalgebra.\n    simpa only [mem_engel_iff, Subtype.ext_iff, coe_toEnd_pow _ _ _ E] using this z.2\n  -- Now we are in good shape.\n  -- Fix an element `z` in the Engel subalgebra of `y`.\n  intro z hz\n  -- We need to show that `z` is in `E`, or alternatively that `z = 0` in `Q`.\n  show z ∈ E\n  rw [← LieSubmodule.Quotient.mk_eq_zero]\n  -- We denote the image of `z` in `Q` by `z'`.\n  set z' : Q := LieSubmodule.Quotient.mk' E z\n  -- First we observe that `z'` is killed by a power of `⁅v, _⁆`.\n  have hz' : ∃ n : ℕ, (toEnd K U Q v ^ n) z' = 0 := by\n    rw [mem_engel_iff] at hz\n    obtain ⟨n, hn⟩ := hz\n    use n\n    apply_fun LieSubmodule.Quotient.mk' E at hn\n    rw [LieModuleHom.map_zero] at hn\n    rw [← hn]\n    clear hn\n    induction n with\n    | zero => simp only [z', pow_zero, LinearMap.one_apply]\n    | succ n ih => rw [pow_succ', pow_succ', LinearMap.mul_apply, ih]; rfl\n  classical\n  -- Now let `n` be the smallest power such that `⁅v, _⁆ ^ n` kills `z'`.\n  set n := Nat.find hz' with _hn\n  have hn : (toEnd K U Q v ^ n) z' = 0 := Nat.find_spec hz'\n  -- If `n = 0`, then we are done.\n  obtain hn₀|⟨k, hk⟩ : n = 0 ∨ ∃ k, n = k + 1 := by cases n <;> simp\n  · simpa only [hn₀, pow_zero, LinearMap.one_apply] using hn\n  -- If `n = k + 1`, then we can write `⁅v, _⁆ ^ n = ⁅v, _⁆ ∘ ⁅v, _⁆ ^ k`.\n  -- Recall that `constantCoeff ψ` is non-zero on `α`, and `v = α • u + x`.\n  specialize hsψ α hα\n  -- Hence `⁅v, _⁆` acts injectively on `Q`.\n  rw [← coe_evalRingHom, constantCoeff_apply, ← coeff_map, lieCharpoly_map_eval,\n    ← constantCoeff_apply, ne_eq, LinearMap.charpoly_constantCoeff_eq_zero_iff] at hsψ\n  -- We deduce from this that `z' = 0`, arguing by contraposition.\n  contrapose! hsψ\n  -- Indeed `⁅v, _⁆` kills `⁅v, _⁆ ^ k` applied to `z'`.\n  use (toEnd K U Q v ^ k) z'\n  refine ⟨?_, ?_⟩\n  · -- And `⁅v, _⁆ ^ k` applied to `z'` is non-zero by definition of `n`.\n    apply Nat.find_min hz'; omega\n  · rw [← hn, hk, pow_succ', LinearMap.mul_apply]\n\n"}
{"name":"LieAlgebra.exists_isCartanSubalgebra_engel_of_finrank_le_card","module":"Mathlib.Algebra.Lie.CartanExists","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra K L\ninst✝ : Module.Finite K L\nh : LE.le (↑(Module.finrank K L)) (Cardinal.mk K)\n⊢ Exists fun x => (LieSubalgebra.engel K x).IsCartanSubalgebra","decl":"lemma exists_isCartanSubalgebra_engel_of_finrank_le_card (h : finrank K L ≤ #K) :\n    ∃ x : L, IsCartanSubalgebra (engel K x) := by\n  obtain ⟨x, hx⟩ := exists_isRegular_of_finrank_le_card K L h\n  use x\n  refine ⟨?_, normalizer_engel _ _⟩\n  apply isNilpotent_of_forall_le_engel\n  intro y hy\n  set Ex : {engel K z | z ∈ engel K x} := ⟨engel K x, x, self_mem_engel _ _, rfl⟩\n  suffices IsBot Ex from @this ⟨engel K y, y, hy, rfl⟩\n  apply engel_isBot_of_isMin h (engel K x) Ex le_rfl\n  rintro ⟨_, y, hy, rfl⟩ hyx\n  suffices finrank K (engel K x) ≤ finrank K (engel K y) by\n    suffices engel K y = engel K x from this.ge\n    apply LieSubalgebra.toSubmodule_injective\n    exact Submodule.eq_of_le_of_finrank_le hyx this\n  rw [(isRegular_iff_finrank_engel_eq_rank K x).mp hx]\n  apply rank_le_finrank_engel\n\n"}
{"name":"LieAlgebra.exists_isCartanSubalgebra_engel","module":"Mathlib.Algebra.Lie.CartanExists","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : Field K\ninst✝³ : LieRing L\ninst✝² : LieAlgebra K L\ninst✝¹ : Module.Finite K L\ninst✝ : Infinite K\n⊢ Exists fun x => (LieSubalgebra.engel K x).IsCartanSubalgebra","decl":"lemma exists_isCartanSubalgebra_engel [Infinite K] :\n    ∃ x : L, IsCartanSubalgebra (engel K x) := by\n  apply exists_isCartanSubalgebra_engel_of_finrank_le_card\n  exact (Cardinal.nat_lt_aleph0 _).le.trans <| Cardinal.infinite_iff.mp ‹Infinite K›\n\n"}
