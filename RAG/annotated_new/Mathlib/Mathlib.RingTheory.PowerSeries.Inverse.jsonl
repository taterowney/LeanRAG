{"name":"PowerSeries.coeff_inv_aux","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"R : Type u_1\ninst✝ : Ring R\nn : Nat\na : R\nφ : PowerSeries R\n⊢ Eq ((PowerSeries.coeff R n) (PowerSeries.inv.aux a φ)) (ite (Eq n 0) a (HMul.hMul (Neg.neg a) ((Finset.HasAntidiagonal.antidiagonal n).sum fun x => ite (LT.lt x.2 n) (HMul.hMul ((PowerSeries.coeff R x.1) φ) ((PowerSeries.coeff R x.2) (PowerSeries.inv.aux a φ))) 0)))","decl":"theorem coeff_inv_aux (n : ℕ) (a : R) (φ : R⟦X⟧) :\n    coeff R n (inv.aux a φ) =\n      if n = 0 then a\n      else\n        -a *\n          ∑ x ∈ antidiagonal n,\n            if x.2 < n then coeff R x.1 φ * coeff R x.2 (inv.aux a φ) else 0 := by\n  rw [coeff, inv.aux, MvPowerSeries.coeff_inv_aux]\n  simp only [Finsupp.single_eq_zero]\n  split_ifs; · rfl\n  congr 1\n  symm\n  apply Finset.sum_nbij' (fun (a, b) ↦ (single () a, single () b))\n    fun (f, g) ↦ (f (), g ())\n  · aesop\n  · aesop\n  · aesop\n  · aesop\n  · rintro ⟨i, j⟩ _hij\n    obtain H | H := le_or_lt n j\n    · aesop\n    rw [if_pos H, if_pos]\n    · rfl\n    refine ⟨?_, fun hh ↦ H.not_le ?_⟩\n    · rintro ⟨⟩\n      simpa [Finsupp.single_eq_same] using le_of_lt H\n    · simpa [Finsupp.single_eq_same] using hh ()\n\n"}
{"name":"PowerSeries.coeff_invOfUnit","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"R : Type u_1\ninst✝ : Ring R\nn : Nat\nφ : PowerSeries R\nu : Units R\n⊢ Eq ((PowerSeries.coeff R n) (φ.invOfUnit u)) (ite (Eq n 0) (↑(Inv.inv u)) (HMul.hMul (Neg.neg ↑(Inv.inv u)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun x => ite (LT.lt x.2 n) (HMul.hMul ((PowerSeries.coeff R x.1) φ) ((PowerSeries.coeff R x.2) (φ.invOfUnit u))) 0)))","decl":"theorem coeff_invOfUnit (n : ℕ) (φ : R⟦X⟧) (u : Rˣ) :\n    coeff R n (invOfUnit φ u) =\n      if n = 0 then ↑u⁻¹\n      else\n        -↑u⁻¹ *\n          ∑ x ∈ antidiagonal n,\n            if x.2 < n then coeff R x.1 φ * coeff R x.2 (invOfUnit φ u) else 0 :=\n  coeff_inv_aux n (↑u⁻¹ : R) φ\n\n"}
{"name":"PowerSeries.constantCoeff_invOfUnit","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"R : Type u_1\ninst✝ : Ring R\nφ : PowerSeries R\nu : Units R\n⊢ Eq ((PowerSeries.constantCoeff R) (φ.invOfUnit u)) ↑(Inv.inv u)","decl":"@[simp]\ntheorem constantCoeff_invOfUnit (φ : R⟦X⟧) (u : Rˣ) :\n    constantCoeff R (invOfUnit φ u) = ↑u⁻¹ := by\n  rw [← coeff_zero_eq_constantCoeff_apply, coeff_invOfUnit, if_pos rfl]\n\n"}
{"name":"PowerSeries.mul_invOfUnit","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"R : Type u_1\ninst✝ : Ring R\nφ : PowerSeries R\nu : Units R\nh : Eq ((PowerSeries.constantCoeff R) φ) ↑u\n⊢ Eq (HMul.hMul φ (φ.invOfUnit u)) 1","decl":"@[simp]\ntheorem mul_invOfUnit (φ : R⟦X⟧) (u : Rˣ) (h : constantCoeff R φ = u) :\n    φ * invOfUnit φ u = 1 :=\n  MvPowerSeries.mul_invOfUnit φ u <| h\n\n"}
{"name":"PowerSeries.invOfUnit_mul","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"R : Type u_1\ninst✝ : Ring R\nφ : PowerSeries R\nu : Units R\nh : Eq ((PowerSeries.constantCoeff R) φ) ↑u\n⊢ Eq (HMul.hMul (φ.invOfUnit u) φ) 1","decl":"@[simp]\ntheorem invOfUnit_mul (φ : R⟦X⟧) (u : Rˣ) (h : constantCoeff R φ = u) :\n    invOfUnit φ u * φ = 1 :=\n  MvPowerSeries.invOfUnit_mul φ u h\n\n"}
{"name":"PowerSeries.isUnit_iff_constantCoeff","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"R : Type u_1\ninst✝ : Ring R\nφ : PowerSeries R\n⊢ Iff (IsUnit φ) (IsUnit ((PowerSeries.constantCoeff R) φ))","decl":"theorem isUnit_iff_constantCoeff {φ : R⟦X⟧} :\n    IsUnit φ ↔ IsUnit (constantCoeff R φ) :=\n  MvPowerSeries.isUnit_iff_constantCoeff\n\n"}
{"name":"PowerSeries.sub_const_eq_shift_mul_X","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"R : Type u_1\ninst✝ : Ring R\nφ : PowerSeries R\n⊢ Eq (HSub.hSub φ ((PowerSeries.C R) ((PowerSeries.constantCoeff R) φ))) (HMul.hMul (PowerSeries.mk fun p => (PowerSeries.coeff R (HAdd.hAdd p 1)) φ) PowerSeries.X)","decl":"/-- Two ways of removing the constant coefficient of a power series are the same. -/\ntheorem sub_const_eq_shift_mul_X (φ : R⟦X⟧) :\n    φ - C R (constantCoeff R φ) = (mk fun p ↦ coeff R (p + 1) φ) * X :=\n  sub_eq_iff_eq_add.mpr (eq_shift_mul_X_add_const φ)\n\n"}
{"name":"PowerSeries.sub_const_eq_X_mul_shift","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"R : Type u_1\ninst✝ : Ring R\nφ : PowerSeries R\n⊢ Eq (HSub.hSub φ ((PowerSeries.C R) ((PowerSeries.constantCoeff R) φ))) (HMul.hMul PowerSeries.X (PowerSeries.mk fun p => (PowerSeries.coeff R (HAdd.hAdd p 1)) φ))","decl":"theorem sub_const_eq_X_mul_shift (φ : R⟦X⟧) :\n    φ - C R (constantCoeff R φ) = X * mk fun p ↦ coeff R (p + 1) φ :=\n  sub_eq_iff_eq_add.mpr (eq_X_mul_shift_add_const φ)\n\n"}
{"name":"PowerSeries.inv_eq_inv_aux","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nφ : PowerSeries k\n⊢ Eq (Inv.inv φ) (PowerSeries.inv.aux (Inv.inv ((PowerSeries.constantCoeff k) φ)) φ)","decl":"theorem inv_eq_inv_aux (φ : k⟦X⟧) : φ⁻¹ = inv.aux (constantCoeff k φ)⁻¹ φ :=\n  rfl\n\n"}
{"name":"PowerSeries.coeff_inv","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nn : Nat\nφ : PowerSeries k\n⊢ Eq ((PowerSeries.coeff k n) (Inv.inv φ)) (ite (Eq n 0) (Inv.inv ((PowerSeries.constantCoeff k) φ)) (HMul.hMul (Neg.neg (Inv.inv ((PowerSeries.constantCoeff k) φ))) ((Finset.HasAntidiagonal.antidiagonal n).sum fun x => ite (LT.lt x.2 n) (HMul.hMul ((PowerSeries.coeff k x.1) φ) ((PowerSeries.coeff k x.2) (Inv.inv φ))) 0)))","decl":"theorem coeff_inv (n) (φ : k⟦X⟧) :\n    coeff k n φ⁻¹ =\n      if n = 0 then (constantCoeff k φ)⁻¹\n      else\n        -(constantCoeff k φ)⁻¹ *\n          ∑ x ∈ antidiagonal n,\n            if x.2 < n then coeff k x.1 φ * coeff k x.2 φ⁻¹ else 0 := by\n  rw [inv_eq_inv_aux, coeff_inv_aux n (constantCoeff k φ)⁻¹ φ]\n\n"}
{"name":"PowerSeries.constantCoeff_inv","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nφ : PowerSeries k\n⊢ Eq ((PowerSeries.constantCoeff k) (Inv.inv φ)) (Inv.inv ((PowerSeries.constantCoeff k) φ))","decl":"@[simp]\ntheorem constantCoeff_inv (φ : k⟦X⟧) : constantCoeff k φ⁻¹ = (constantCoeff k φ)⁻¹ :=\n  MvPowerSeries.constantCoeff_inv φ\n\n"}
{"name":"PowerSeries.inv_eq_zero","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nφ : PowerSeries k\n⊢ Iff (Eq (Inv.inv φ) 0) (Eq ((PowerSeries.constantCoeff k) φ) 0)","decl":"theorem inv_eq_zero {φ : k⟦X⟧} : φ⁻¹ = 0 ↔ constantCoeff k φ = 0 :=\n  MvPowerSeries.inv_eq_zero\n\n"}
{"name":"PowerSeries.zero_inv","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\n⊢ Eq (Inv.inv 0) 0","decl":"theorem zero_inv : (0 : k⟦X⟧)⁻¹ = 0 :=\n  MvPowerSeries.zero_inv\n\n"}
{"name":"PowerSeries.invOfUnit_eq","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nφ : PowerSeries k\nh : Ne ((PowerSeries.constantCoeff k) φ) 0\n⊢ Eq (φ.invOfUnit (Units.mk0 ((PowerSeries.constantCoeff k) φ) h)) (Inv.inv φ)","decl":"@[simp]\ntheorem invOfUnit_eq (φ : k⟦X⟧) (h : constantCoeff k φ ≠ 0) :\n    invOfUnit φ (Units.mk0 _ h) = φ⁻¹ :=\n  MvPowerSeries.invOfUnit_eq _ _\n\n"}
{"name":"PowerSeries.invOfUnit_eq'","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nφ : PowerSeries k\nu : Units k\nh : Eq ((PowerSeries.constantCoeff k) φ) ↑u\n⊢ Eq (φ.invOfUnit u) (Inv.inv φ)","decl":"@[simp]\ntheorem invOfUnit_eq' (φ : k⟦X⟧) (u : Units k) (h : constantCoeff k φ = u) :\n    invOfUnit φ u = φ⁻¹ :=\n  MvPowerSeries.invOfUnit_eq' φ _ h\n\n"}
{"name":"PowerSeries.mul_inv_cancel","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nφ : PowerSeries k\nh : Ne ((PowerSeries.constantCoeff k) φ) 0\n⊢ Eq (HMul.hMul φ (Inv.inv φ)) 1","decl":"@[simp]\nprotected theorem mul_inv_cancel (φ : k⟦X⟧) (h : constantCoeff k φ ≠ 0) : φ * φ⁻¹ = 1 :=\n  MvPowerSeries.mul_inv_cancel φ h\n\n"}
{"name":"PowerSeries.inv_mul_cancel","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nφ : PowerSeries k\nh : Ne ((PowerSeries.constantCoeff k) φ) 0\n⊢ Eq (HMul.hMul (Inv.inv φ) φ) 1","decl":"@[simp]\nprotected theorem inv_mul_cancel (φ : k⟦X⟧) (h : constantCoeff k φ ≠ 0) : φ⁻¹ * φ = 1 :=\n  MvPowerSeries.inv_mul_cancel φ h\n\n"}
{"name":"PowerSeries.eq_mul_inv_iff_mul_eq","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nφ₁ φ₂ φ₃ : PowerSeries k\nh : Ne ((PowerSeries.constantCoeff k) φ₃) 0\n⊢ Iff (Eq φ₁ (HMul.hMul φ₂ (Inv.inv φ₃))) (Eq (HMul.hMul φ₁ φ₃) φ₂)","decl":"theorem eq_mul_inv_iff_mul_eq {φ₁ φ₂ φ₃ : k⟦X⟧} (h : constantCoeff k φ₃ ≠ 0) :\n    φ₁ = φ₂ * φ₃⁻¹ ↔ φ₁ * φ₃ = φ₂ :=\n  MvPowerSeries.eq_mul_inv_iff_mul_eq h\n\n"}
{"name":"PowerSeries.eq_inv_iff_mul_eq_one","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nφ ψ : PowerSeries k\nh : Ne ((PowerSeries.constantCoeff k) ψ) 0\n⊢ Iff (Eq φ (Inv.inv ψ)) (Eq (HMul.hMul φ ψ) 1)","decl":"theorem eq_inv_iff_mul_eq_one {φ ψ : k⟦X⟧} (h : constantCoeff k ψ ≠ 0) :\n    φ = ψ⁻¹ ↔ φ * ψ = 1 :=\n  MvPowerSeries.eq_inv_iff_mul_eq_one h\n\n"}
{"name":"PowerSeries.inv_eq_iff_mul_eq_one","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nφ ψ : PowerSeries k\nh : Ne ((PowerSeries.constantCoeff k) ψ) 0\n⊢ Iff (Eq (Inv.inv ψ) φ) (Eq (HMul.hMul φ ψ) 1)","decl":"theorem inv_eq_iff_mul_eq_one {φ ψ : k⟦X⟧} (h : constantCoeff k ψ ≠ 0) :\n    ψ⁻¹ = φ ↔ φ * ψ = 1 :=\n  MvPowerSeries.inv_eq_iff_mul_eq_one h\n\n"}
{"name":"PowerSeries.mul_inv_rev","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nφ ψ : PowerSeries k\n⊢ Eq (Inv.inv (HMul.hMul φ ψ)) (HMul.hMul (Inv.inv ψ) (Inv.inv φ))","decl":"protected theorem mul_inv_rev (φ ψ : k⟦X⟧) : (φ * ψ)⁻¹ = ψ⁻¹ * φ⁻¹ :=\n  MvPowerSeries.mul_inv_rev _ _\n\n"}
{"name":"PowerSeries.C_inv","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nr : k\n⊢ Eq (Inv.inv ((PowerSeries.C k) r)) ((PowerSeries.C k) (Inv.inv r))","decl":"@[simp]\ntheorem C_inv (r : k) : (C k r)⁻¹ = C k r⁻¹ :=\n  MvPowerSeries.C_inv _\n\n"}
{"name":"PowerSeries.X_inv","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\n⊢ Eq (Inv.inv PowerSeries.X) 0","decl":"@[simp]\ntheorem X_inv : (X : k⟦X⟧)⁻¹ = 0 :=\n  MvPowerSeries.X_inv _\n\n"}
{"name":"PowerSeries.smul_inv","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nr : k\nφ : PowerSeries k\n⊢ Eq (Inv.inv (HSMul.hSMul r φ)) (HSMul.hSMul (Inv.inv r) (Inv.inv φ))","decl":"theorem smul_inv (r : k) (φ : k⟦X⟧) : (r • φ)⁻¹ = r⁻¹ • φ⁻¹ :=\n  MvPowerSeries.smul_inv _ _\n\n"}
{"name":"PowerSeries.Inv_divided_by_X_pow_order_rightInv","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nf : PowerSeries k\nhf : Ne f 0\n⊢ Eq (HMul.hMul (PowerSeries.divided_by_X_pow_order hf) (PowerSeries.Inv_divided_by_X_pow_order hf)) 1","decl":"@[simp]\ntheorem Inv_divided_by_X_pow_order_rightInv {f : k⟦X⟧} (hf : f ≠ 0) :\n    divided_by_X_pow_order hf * Inv_divided_by_X_pow_order hf = 1 :=\n  mul_invOfUnit (divided_by_X_pow_order hf) (firstUnitCoeff hf) rfl\n\n"}
{"name":"PowerSeries.Inv_divided_by_X_pow_order_leftInv","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nf : PowerSeries k\nhf : Ne f 0\n⊢ Eq (HMul.hMul (PowerSeries.Inv_divided_by_X_pow_order hf) (PowerSeries.divided_by_X_pow_order hf)) 1","decl":"@[simp]\ntheorem Inv_divided_by_X_pow_order_leftInv {f : k⟦X⟧} (hf : f ≠ 0) :\n    (Inv_divided_by_X_pow_order hf) * (divided_by_X_pow_order hf) = 1 := by\n  rw [mul_comm]\n  exact mul_invOfUnit (divided_by_X_pow_order hf) (firstUnitCoeff hf) rfl\n\n"}
{"name":"PowerSeries.isUnit_divided_by_X_pow_order","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nf : PowerSeries k\nhf : Ne f 0\n⊢ IsUnit (PowerSeries.divided_by_X_pow_order hf)","decl":"theorem isUnit_divided_by_X_pow_order {f : k⟦X⟧} (hf : f ≠ 0) :\n    IsUnit (divided_by_X_pow_order hf) :=\n  ⟨Unit_of_divided_by_X_pow_order f,\n    by simp only [Unit_of_divided_by_X_pow_order, dif_neg hf, Units.val_mk]⟩\n\n"}
{"name":"PowerSeries.Unit_of_divided_by_X_pow_order_nonzero","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nf : PowerSeries k\nhf : Ne f 0\n⊢ Eq (↑f.Unit_of_divided_by_X_pow_order) (PowerSeries.divided_by_X_pow_order hf)","decl":"theorem Unit_of_divided_by_X_pow_order_nonzero {f : k⟦X⟧} (hf : f ≠ 0) :\n    ↑(Unit_of_divided_by_X_pow_order f) = divided_by_X_pow_order hf := by\n  simp only [Unit_of_divided_by_X_pow_order, dif_neg hf, Units.val_mk]\n\n"}
{"name":"PowerSeries.Unit_of_divided_by_X_pow_order_zero","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\n⊢ Eq (PowerSeries.Unit_of_divided_by_X_pow_order 0) 1","decl":"@[simp]\ntheorem Unit_of_divided_by_X_pow_order_zero : Unit_of_divided_by_X_pow_order (0 : k⟦X⟧) = 1 := by\n  simp only [Unit_of_divided_by_X_pow_order, dif_pos]\n\n"}
{"name":"PowerSeries.eq_divided_by_X_pow_order_Iff_Unit","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nf : PowerSeries k\nhf : Ne f 0\n⊢ Iff (Eq f (PowerSeries.divided_by_X_pow_order hf)) (IsUnit f)","decl":"theorem eq_divided_by_X_pow_order_Iff_Unit {f : k⟦X⟧} (hf : f ≠ 0) :\n    f = divided_by_X_pow_order hf ↔ IsUnit f :=\n  ⟨fun h ↦ by rw [h]; exact isUnit_divided_by_X_pow_order hf, fun h ↦ by\n    have : f.order.lift (order_finite_iff_ne_zero.mpr hf) = 0 := by\n      simp [order_zero_of_unit h]\n    convert (self_eq_X_pow_order_mul_divided_by_X_pow_order hf).symm\n    simp only [this, pow_zero, one_mul]⟩\n\n"}
{"name":"PowerSeries.map.isLocalHom","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\nf : RingHom R S\ninst✝ : IsLocalHom f\n⊢ IsLocalHom (PowerSeries.map f)","decl":"@[instance]\ntheorem map.isLocalHom : IsLocalHom (map f) :=\n  MvPowerSeries.map.isLocalHom f\n\n"}
{"name":"PowerSeries.map.isLocalRingHom","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\nf : RingHom R S\ninst✝ : IsLocalHom f\n⊢ IsLocalHom (PowerSeries.map f)","decl":"@[deprecated (since := \"2024-10-10\")]\nalias map.isLocalRingHom := map.isLocalHom\n\n"}
{"name":"PowerSeries.instIsLocalRing","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsLocalRing R\n⊢ IsLocalRing (PowerSeries R)","decl":"instance : IsLocalRing R⟦X⟧ :=\n  { inferInstanceAs <| IsLocalRing <| MvPowerSeries Unit R with }\n\n\n"}
{"name":"PowerSeries.hasUnitMulPowIrreducibleFactorization","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\n⊢ IsDiscreteValuationRing.HasUnitMulPowIrreducibleFactorization (PowerSeries k)","decl":"theorem hasUnitMulPowIrreducibleFactorization :\n    HasUnitMulPowIrreducibleFactorization k⟦X⟧ :=\n  ⟨X, And.intro X_irreducible\n      (by\n        intro f hf\n        use f.order.lift (order_finite_iff_ne_zero.mpr hf)\n        use Unit_of_divided_by_X_pow_order f\n        simp only [Unit_of_divided_by_X_pow_order_nonzero hf]\n        exact self_eq_X_pow_order_mul_divided_by_X_pow_order hf)⟩\n\n"}
{"name":"PowerSeries.instUniqueFactorizationMonoid","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\n⊢ UniqueFactorizationMonoid (PowerSeries k)","decl":"instance : UniqueFactorizationMonoid k⟦X⟧ :=\n  hasUnitMulPowIrreducibleFactorization.toUniqueFactorizationMonoid\n\n"}
{"name":"PowerSeries.instIsDiscreteValuationRing","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\n⊢ IsDiscreteValuationRing (PowerSeries k)","decl":"instance : IsDiscreteValuationRing k⟦X⟧ :=\n  ofHasUnitMulPowIrreducibleFactorization hasUnitMulPowIrreducibleFactorization\n\n"}
{"name":"PowerSeries.isNoetherianRing","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\n⊢ IsNoetherianRing (PowerSeries k)","decl":"instance isNoetherianRing : IsNoetherianRing k⟦X⟧ :=\n  PrincipalIdealRing.isNoetherianRing\n\n"}
{"name":"PowerSeries.maximalIdeal_eq_span_X","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\n⊢ Eq (IsLocalRing.maximalIdeal (PowerSeries k)) (Ideal.span (Singleton.singleton PowerSeries.X))","decl":"/-- The maximal ideal of `k⟦X⟧` is generated by `X`. -/\ntheorem maximalIdeal_eq_span_X : IsLocalRing.maximalIdeal (k⟦X⟧) = Ideal.span {X} := by\n  have hX : (Ideal.span {(X : k⟦X⟧)}).IsMaximal := by\n    rw [Ideal.isMaximal_iff]\n    constructor\n    · rw [Ideal.mem_span_singleton]\n      exact Prime.not_dvd_one X_prime\n    · intro I f hI hfX hfI\n      rw [Ideal.mem_span_singleton, X_dvd_iff] at hfX\n      have hfI0 : C k (f 0) ∈ I := by\n        have : C k (f 0) = f - (f - C k (f 0)) := by rw [sub_sub_cancel]\n        rw [this]\n        apply Ideal.sub_mem I hfI\n        apply hI\n        rw [Ideal.mem_span_singleton, X_dvd_iff, map_sub, constantCoeff_C, ←\n          coeff_zero_eq_constantCoeff_apply, sub_eq_zero, coeff_zero_eq_constantCoeff]\n        rfl\n      rw [← Ideal.eq_top_iff_one]\n      apply Ideal.eq_top_of_isUnit_mem I hfI0 (IsUnit.map (C k) (Ne.isUnit hfX))\n  rw [IsLocalRing.eq_maximalIdeal hX]\n\n"}
{"name":"PowerSeries.normUnit_X","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\n⊢ Eq (NormalizationMonoid.normUnit PowerSeries.X) 1","decl":"theorem normUnit_X : normUnit (X : k⟦X⟧) = 1 := by\n  simp [normUnit, ← Units.val_eq_one, Unit_of_divided_by_X_pow_order_nonzero]\n\n"}
{"name":"PowerSeries.X_eq_normalizeX","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\n⊢ Eq PowerSeries.X (normalize PowerSeries.X)","decl":"theorem X_eq_normalizeX : (X : k⟦X⟧) = normalize X := by\n  simp only [normalize_apply, normUnit_X, Units.val_one, mul_one]\n\n"}
{"name":"PowerSeries.normalized_count_X_eq_of_coe","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\nP : Polynomial k\nhP : Ne P 0\n⊢ Eq (Multiset.count PowerSeries.X (UniqueFactorizationMonoid.normalizedFactors ↑P)) (Multiset.count Polynomial.X (UniqueFactorizationMonoid.normalizedFactors P))","decl":"open scoped Classical in\ntheorem normalized_count_X_eq_of_coe {P : k[X]} (hP : P ≠ 0) :\n    Multiset.count PowerSeries.X (normalizedFactors (P : k⟦X⟧)) =\n      Multiset.count Polynomial.X (normalizedFactors P) := by\n  apply eq_of_forall_le_iff\n  simp only [← Nat.cast_le (α := ℕ∞)]\n  rw [X_eq_normalize, PowerSeries.X_eq_normalizeX, ← emultiplicity_eq_count_normalizedFactors\n    irreducible_X hP, ← emultiplicity_eq_count_normalizedFactors X_irreducible] <;>\n  simp only [← pow_dvd_iff_le_emultiplicity, Polynomial.X_pow_dvd_iff,\n    PowerSeries.X_pow_dvd_iff, Polynomial.coeff_coe P, implies_true, ne_eq, coe_eq_zero_iff, hP,\n    not_false_eq_true]\n\n"}
{"name":"PowerSeries.ker_coeff_eq_max_ideal","module":"Mathlib.RingTheory.PowerSeries.Inverse","initialProofState":"k : Type u_2\ninst✝ : Field k\n⊢ Eq (RingHom.ker (PowerSeries.constantCoeff k)) (IsLocalRing.maximalIdeal (PowerSeries k))","decl":"theorem ker_coeff_eq_max_ideal : RingHom.ker (constantCoeff k) = maximalIdeal _ :=\n  Ideal.ext fun _ ↦ by\n    rw [RingHom.mem_ker, maximalIdeal_eq_span_X, Ideal.mem_span_singleton, X_dvd_iff]\n\n"}
