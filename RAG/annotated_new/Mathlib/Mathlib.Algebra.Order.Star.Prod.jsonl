{"name":"Prod.instStarOrderedRing","module":"Mathlib.Algebra.Order.Star.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁷ : NonUnitalSemiring α\ninst✝⁶ : NonUnitalSemiring β\ninst✝⁵ : PartialOrder α\ninst✝⁴ : PartialOrder β\ninst✝³ : StarRing α\ninst✝² : StarRing β\ninst✝¹ : StarOrderedRing α\ninst✝ : StarOrderedRing β\n⊢ StarOrderedRing (Prod α β)","decl":"open AddSubmonoid in\ninstance Prod.instStarOrderedRing\n    [NonUnitalSemiring α] [NonUnitalSemiring β] [PartialOrder α] [PartialOrder β]\n    [StarRing α] [StarRing β] [StarOrderedRing α] [StarOrderedRing β] :\n    StarOrderedRing (α × β) where\n  le_iff := Prod.forall.2 fun xa xy => Prod.forall.2 fun ya yb => by\n    have :\n        closure (Set.range fun s : α × β ↦ star s * s) =\n          (closure <| Set.range fun s : α ↦ star s * s).prod\n          (closure <| Set.range fun s : β ↦ star s * s) := by\n      rw [← closure_prod (Set.mem_range.2 ⟨0, by simp⟩) (Set.mem_range.2 ⟨0, by simp⟩),\n        Set.prod_range_range_eq]\n      simp_rw [Prod.mul_def, Prod.star_def]\n    simp only [mk_le_mk, Prod.exists, mk_add_mk, mk.injEq, StarOrderedRing.le_iff, this,\n      AddSubmonoid.mem_prod, exists_and_exists_comm, and_and_and_comm]\n"}
