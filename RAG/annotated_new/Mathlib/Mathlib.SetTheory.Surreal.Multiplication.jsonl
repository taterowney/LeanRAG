{"name":"Surreal.Multiplication.P3_comm","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y₁ y₂ : SetTheory.PGame\n⊢ Iff (Surreal.Multiplication.P3 x₁ x₂ y₁ y₂) (Surreal.Multiplication.P3 y₁ y₂ x₁ x₂)","decl":"lemma P3_comm : P3 x₁ x₂ y₁ y₂ ↔ P3 y₁ y₂ x₁ x₂ := by\n  rw [P3, P3, add_comm]\n  congr! 2 <;> rw [quot_mul_comm]\n\n"}
{"name":"Surreal.Multiplication.P3.trans","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ x₃ y₁ y₂ : SetTheory.PGame\nh₁ : Surreal.Multiplication.P3 x₁ x₂ y₁ y₂\nh₂ : Surreal.Multiplication.P3 x₂ x₃ y₁ y₂\n⊢ Surreal.Multiplication.P3 x₁ x₃ y₁ y₂","decl":"lemma P3.trans (h₁ : P3 x₁ x₂ y₁ y₂) (h₂ : P3 x₂ x₃ y₁ y₂) : P3 x₁ x₃ y₁ y₂ := by\n  rw [P3] at h₁ h₂\n  rw [P3, ← add_lt_add_iff_left (⟦x₂ * y₁⟧ + ⟦x₂ * y₂⟧)]\n  convert add_lt_add h₁ h₂ using 1 <;> abel\n\n"}
{"name":"Surreal.Multiplication.P3_neg","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y₁ y₂ : SetTheory.PGame\n⊢ Iff (Surreal.Multiplication.P3 x₁ x₂ y₁ y₂) (Surreal.Multiplication.P3 (Neg.neg x₂) (Neg.neg x₁) y₁ y₂)","decl":"lemma P3_neg : P3 x₁ x₂ y₁ y₂ ↔ P3 (-x₂) (-x₁) y₁ y₂ := by\n  simp_rw [P3, quot_neg_mul]\n  rw [← _root_.neg_lt_neg_iff]\n  abel_nf\n\n"}
{"name":"Surreal.Multiplication.P2_neg_left","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\n⊢ Iff (Surreal.Multiplication.P2 x₁ x₂ y) (Surreal.Multiplication.P2 (Neg.neg x₂) (Neg.neg x₁) y)","decl":"lemma P2_neg_left : P2 x₁ x₂ y ↔ P2 (-x₂) (-x₁) y := by\n  rw [P2, P2]\n  constructor\n  · rw [quot_neg_mul, quot_neg_mul, eq_comm, neg_inj, neg_equiv_neg_iff, PGame.equiv_comm]\n    exact (· ·)\n  · rw [PGame.equiv_comm, neg_equiv_neg_iff, quot_neg_mul, quot_neg_mul, neg_inj, eq_comm]\n    exact (· ·)\n\n"}
{"name":"Surreal.Multiplication.P2_neg_right","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\n⊢ Iff (Surreal.Multiplication.P2 x₁ x₂ y) (Surreal.Multiplication.P2 x₁ x₂ (Neg.neg y))","decl":"lemma P2_neg_right : P2 x₁ x₂ y ↔ P2 x₁ x₂ (-y) := by\n  rw [P2, P2, quot_mul_neg, quot_mul_neg, neg_inj]\n\n"}
{"name":"Surreal.Multiplication.P4_neg_left","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\n⊢ Iff (Surreal.Multiplication.P4 x₁ x₂ y) (Surreal.Multiplication.P4 (Neg.neg x₂) (Neg.neg x₁) y)","decl":"lemma P4_neg_left : P4 x₁ x₂ y ↔ P4 (-x₂) (-x₁) y := by\n  simp_rw [P4, PGame.neg_lt_neg_iff, moveLeft_neg, ← P3_neg]\n\n"}
{"name":"Surreal.Multiplication.P4_neg_right","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\n⊢ Iff (Surreal.Multiplication.P4 x₁ x₂ y) (Surreal.Multiplication.P4 x₁ x₂ (Neg.neg y))","decl":"lemma P4_neg_right : P4 x₁ x₂ y ↔ P4 x₁ x₂ (-y) := by\n  rw [P4, P4, neg_neg, and_comm]\n\n"}
{"name":"Surreal.Multiplication.P24_neg_left","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\n⊢ Iff (Surreal.Multiplication.P24 x₁ x₂ y) (Surreal.Multiplication.P24 (Neg.neg x₂) (Neg.neg x₁) y)","decl":"lemma P24_neg_left : P24 x₁ x₂ y ↔ P24 (-x₂) (-x₁) y := by rw [P24, P24, P2_neg_left, P4_neg_left]\n"}
{"name":"Surreal.Multiplication.P24_neg_right","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\n⊢ Iff (Surreal.Multiplication.P24 x₁ x₂ y) (Surreal.Multiplication.P24 x₁ x₂ (Neg.neg y))","decl":"lemma P24_neg_right : P24 x₁ x₂ y ↔ P24 x₁ x₂ (-y) := by rw [P24, P24, P2_neg_right, P4_neg_right]\n\n"}
{"name":"Surreal.Multiplication.mulOption_lt_iff_P1","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\ni j : x.LeftMoves\nk : y.LeftMoves\nl : (Neg.neg y).LeftMoves\n⊢ Iff (LT.lt (Quotient.mk SetTheory.PGame.setoid (x.mulOption y i k)) (Neg.neg (Quotient.mk SetTheory.PGame.setoid (x.mulOption (Neg.neg y) j l)))) (Surreal.Multiplication.P1 (x.moveLeft i) x (x.moveLeft j) y (y.moveLeft k) (Neg.neg ((Neg.neg y).moveLeft l)))","decl":"lemma mulOption_lt_iff_P1 {i j k l} :\n    (⟦mulOption x y i k⟧ : Game) < -⟦mulOption x (-y) j l⟧ ↔\n    P1 (x.moveLeft i) x (x.moveLeft j) y (y.moveLeft k) (-(-y).moveLeft l) := by\n  dsimp only [P1, mulOption, quot_sub, quot_add]\n  simp_rw [neg_sub', neg_add, quot_mul_neg, neg_neg]\n\n"}
{"name":"Surreal.Multiplication.mulOption_lt_mul_iff_P3","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\ni : x.LeftMoves\nj : y.LeftMoves\n⊢ Iff (LT.lt (Quotient.mk SetTheory.PGame.setoid (x.mulOption y i j)) (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x y))) (Surreal.Multiplication.P3 (x.moveLeft i) x (y.moveLeft j) y)","decl":"lemma mulOption_lt_mul_iff_P3 {i j} :\n    ⟦mulOption x y i j⟧ < (⟦x * y⟧ : Game) ↔ P3 (x.moveLeft i) x (y.moveLeft j) y := by\n  dsimp only [mulOption, quot_sub, quot_add]\n  exact sub_lt_iff_lt_add'\n\n"}
{"name":"Surreal.Multiplication.P1_of_eq","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ x₃ y₁ y₂ y₃ : SetTheory.PGame\nhe : HasEquiv.Equiv x₁ x₃\nh₁ : Surreal.Multiplication.P2 x₁ x₃ y₁\nh₃ : Surreal.Multiplication.P2 x₁ x₃ y₃\nh3 : Surreal.Multiplication.P3 x₁ x₂ y₂ y₃\n⊢ Surreal.Multiplication.P1 x₁ x₂ x₃ y₁ y₂ y₃","decl":"lemma P1_of_eq (he : x₁ ≈ x₃) (h₁ : P2 x₁ x₃ y₁) (h₃ : P2 x₁ x₃ y₃) (h3 : P3 x₁ x₂ y₂ y₃) :\n    P1 x₁ x₂ x₃ y₁ y₂ y₃ := by\n  rw [P1, ← h₁ he, ← h₃ he, sub_lt_sub_iff]\n  convert add_lt_add_left h3 ⟦x₁ * y₁⟧ using 1 <;> abel\n\n"}
{"name":"Surreal.Multiplication.P1_of_lt","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ x₃ y₁ y₂ y₃ : SetTheory.PGame\nh₁ : Surreal.Multiplication.P3 x₃ x₂ y₂ y₃\nh₂ : Surreal.Multiplication.P3 x₁ x₃ y₂ y₁\n⊢ Surreal.Multiplication.P1 x₁ x₂ x₃ y₁ y₂ y₃","decl":"lemma P1_of_lt (h₁ : P3 x₃ x₂ y₂ y₃) (h₂ : P3 x₁ x₃ y₂ y₁) : P1 x₁ x₂ x₃ y₁ y₂ y₃ := by\n  rw [P1, sub_lt_sub_iff, ← add_lt_add_iff_left ⟦x₃ * y₂⟧]\n  convert add_lt_add h₁ h₂ using 1 <;> abel\n\n"}
{"name":"Surreal.Multiplication.Args.P24.injEq","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁✝ x₂✝ y✝ x₁ x₂ y : SetTheory.PGame\n⊢ Eq (Eq (Surreal.Multiplication.Args.P24 x₁✝ x₂✝ y✝) (Surreal.Multiplication.Args.P24 x₁ x₂ y)) (And (Eq x₁✝ x₁) (And (Eq x₂✝ x₂) (Eq y✝ y)))","decl":"/-- The type of lists of arguments for P1, P2, and P4. -/\ninductive Args : Type (u+1)\n  | P1 (x y : PGame.{u}) : Args\n  | P24 (x₁ x₂ y : PGame.{u}) : Args\n\n"}
{"name":"Surreal.Multiplication.Args.P24.inj","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁✝ x₂✝ y✝ x₁ x₂ y : SetTheory.PGame\nx✝ : Eq (Surreal.Multiplication.Args.P24 x₁✝ x₂✝ y✝) (Surreal.Multiplication.Args.P24 x₁ x₂ y)\n⊢ And (Eq x₁✝ x₁) (And (Eq x₂✝ x₂) (Eq y✝ y))","decl":"/-- The type of lists of arguments for P1, P2, and P4. -/\ninductive Args : Type (u+1)\n  | P1 (x y : PGame.{u}) : Args\n  | P24 (x₁ x₂ y : PGame.{u}) : Args\n\n"}
{"name":"Surreal.Multiplication.Args.P1.sizeOf_spec","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (SizeOf.sizeOf (Surreal.Multiplication.Args.P1 x y)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf x)) (SizeOf.sizeOf y))","decl":"/-- The type of lists of arguments for P1, P2, and P4. -/\ninductive Args : Type (u+1)\n  | P1 (x y : PGame.{u}) : Args\n  | P24 (x₁ x₂ y : PGame.{u}) : Args\n\n"}
{"name":"Surreal.Multiplication.Args.P1.inj","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x✝¹ y✝ x y : SetTheory.PGame\nx✝ : Eq (Surreal.Multiplication.Args.P1 x✝¹ y✝) (Surreal.Multiplication.Args.P1 x y)\n⊢ And (Eq x✝¹ x) (Eq y✝ y)","decl":"/-- The type of lists of arguments for P1, P2, and P4. -/\ninductive Args : Type (u+1)\n  | P1 (x y : PGame.{u}) : Args\n  | P24 (x₁ x₂ y : PGame.{u}) : Args\n\n"}
{"name":"Surreal.Multiplication.Args.P24.sizeOf_spec","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\n⊢ Eq (SizeOf.sizeOf (Surreal.Multiplication.Args.P24 x₁ x₂ y)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf x₁)) (SizeOf.sizeOf x₂)) (SizeOf.sizeOf y))","decl":"/-- The type of lists of arguments for P1, P2, and P4. -/\ninductive Args : Type (u+1)\n  | P1 (x y : PGame.{u}) : Args\n  | P24 (x₁ x₂ y : PGame.{u}) : Args\n\n"}
{"name":"Surreal.Multiplication.Args.P1.injEq","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x✝ y✝ x y : SetTheory.PGame\n⊢ Eq (Eq (Surreal.Multiplication.Args.P1 x✝ y✝) (Surreal.Multiplication.Args.P1 x y)) (And (Eq x✝ x) (Eq y✝ y))","decl":"/-- The type of lists of arguments for P1, P2, and P4. -/\ninductive Args : Type (u+1)\n  | P1 (x y : PGame.{u}) : Args\n  | P24 (x₁ x₂ y : PGame.{u}) : Args\n\n"}
{"name":"Surreal.Multiplication.Args.numeric_P1","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (Surreal.Multiplication.Args.P1 x y).Numeric (And x.Numeric y.Numeric)","decl":"lemma Args.numeric_P1 {x y} : (Args.P1 x y).Numeric ↔ x.Numeric ∧ y.Numeric := by\n  simp [Args.Numeric, Args.toMultiset]\n\n"}
{"name":"Surreal.Multiplication.Args.numeric_P24","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\n⊢ Iff (Surreal.Multiplication.Args.P24 x₁ x₂ y).Numeric (And x₁.Numeric (And x₂.Numeric y.Numeric))","decl":"lemma Args.numeric_P24 {x₁ x₂ y} :\n    (Args.P24 x₁ x₂ y).Numeric ↔ x₁.Numeric ∧ x₂.Numeric ∧ y.Numeric := by\n  simp [Args.Numeric, Args.toMultiset]\n\n"}
{"name":"Surreal.Multiplication.argsRel_wf","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"⊢ WellFounded Surreal.Multiplication.ArgsRel","decl":"/-- `ArgsRel` is well-founded. -/\ntheorem argsRel_wf : WellFounded ArgsRel := InvImage.wf _ wf_isOption.cutExpand.transGen\n\n"}
{"name":"Surreal.Multiplication.ArgsRel.numeric_closed","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"a' a : Surreal.Multiplication.Args\na✝¹ : Surreal.Multiplication.ArgsRel a' a\na✝ : a.Numeric\n⊢ a'.Numeric","decl":"/-- The property that all arguments are numeric is leftward-closed under `ArgsRel`. -/\nlemma ArgsRel.numeric_closed {a' a} : ArgsRel a' a → a.Numeric → a'.Numeric :=\n  TransGen.closed' <| @cutExpand_closed _ IsOption ⟨wf_isOption.isIrrefl.1⟩ _ Numeric.isOption\n\n"}
{"name":"Surreal.Multiplication.ih1_neg_left","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\na✝ : Surreal.Multiplication.IH1 x y\n⊢ Surreal.Multiplication.IH1 (Neg.neg x) y","decl":"lemma ih1_neg_left : IH1 x y → IH1 (-x) y :=\n  fun h x₁ x₂ y' h₁ h₂ hy ↦ by\n    rw [isOption_neg] at h₁ h₂\n    exact P24_neg_left.2 (h h₂ h₁ hy)\n\n"}
{"name":"Surreal.Multiplication.ih1_neg_right","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\na✝ : Surreal.Multiplication.IH1 x y\n⊢ Surreal.Multiplication.IH1 x (Neg.neg y)","decl":"lemma ih1_neg_right : IH1 x y → IH1 x (-y) :=\n  fun h x₁ x₂ y' ↦ by\n    rw [← neg_eq_iff_eq_neg, isOption_neg, P24_neg_right]\n    apply h\n\n"}
{"name":"Surreal.Multiplication.numeric_option_mul","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x x' y : SetTheory.PGame\nih : ∀ (a : Surreal.Multiplication.Args), Surreal.Multiplication.ArgsRel a (Surreal.Multiplication.Args.P1 x y) → Surreal.Multiplication.P124 a\nh : x'.IsOption x\n⊢ (HMul.hMul x' y).Numeric","decl":"lemma numeric_option_mul (ih : ∀ a, ArgsRel a (Args.P1 x y) → P124 a) (h : IsOption x' x) :\n    (x' * y).Numeric :=\n  ih (Args.P1 x' y) (TransGen.single <| cutExpand_pair_left h)\n\n"}
{"name":"Surreal.Multiplication.numeric_mul_option","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y y' : SetTheory.PGame\nih : ∀ (a : Surreal.Multiplication.Args), Surreal.Multiplication.ArgsRel a (Surreal.Multiplication.Args.P1 x y) → Surreal.Multiplication.P124 a\nh : y'.IsOption y\n⊢ (HMul.hMul x y').Numeric","decl":"lemma numeric_mul_option (ih : ∀ a, ArgsRel a (Args.P1 x y) → P124 a) (h : IsOption y' y) :\n    (x * y').Numeric :=\n  ih (Args.P1 x y') (TransGen.single <| cutExpand_pair_right h)\n\n"}
{"name":"Surreal.Multiplication.numeric_option_mul_option","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x x' y y' : SetTheory.PGame\nih : ∀ (a : Surreal.Multiplication.Args), Surreal.Multiplication.ArgsRel a (Surreal.Multiplication.Args.P1 x y) → Surreal.Multiplication.P124 a\nhx : x'.IsOption x\nhy : y'.IsOption y\n⊢ (HMul.hMul x' y').Numeric","decl":"lemma numeric_option_mul_option (ih : ∀ a, ArgsRel a (Args.P1 x y) → P124 a) (hx : IsOption x' x)\n    (hy : IsOption y' y) : (x' * y').Numeric :=\n  ih (Args.P1 x' y') ((TransGen.single <| cutExpand_pair_right hy).tail <| cutExpand_pair_left hx)\n\n"}
{"name":"Surreal.Multiplication.ih1","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\nih : ∀ (a : Surreal.Multiplication.Args), Surreal.Multiplication.ArgsRel a (Surreal.Multiplication.Args.P1 x y) → Surreal.Multiplication.P124 a\n⊢ Surreal.Multiplication.IH1 x y","decl":"lemma ih1 (ih : ∀ a, ArgsRel a (Args.P1 x y) → P124 a) : IH1 x y := by\n  rintro x₁ x₂ y' h₁ h₂ (rfl|hy) <;> apply ih (Args.P24 _ _ _)\n  on_goal 2 => refine TransGen.tail ?_ (cutExpand_pair_right hy)\n  all_goals exact TransGen.single (cutExpand_double_left h₁ h₂)\n\n"}
{"name":"Surreal.Multiplication.ih1_swap","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\nih : ∀ (a : Surreal.Multiplication.Args), Surreal.Multiplication.ArgsRel a (Surreal.Multiplication.Args.P1 x y) → Surreal.Multiplication.P124 a\n⊢ Surreal.Multiplication.IH1 y x","decl":"lemma ih1_swap (ih : ∀ a, ArgsRel a (Args.P1 x y) → P124 a) : IH1 y x := ih1 <| by\n  simp_rw [ArgsRel, InvImage, Args.toMultiset, Multiset.pair_comm] at ih ⊢\n  exact ih\n\n"}
{"name":"Surreal.Multiplication.P3_of_ih","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\nhy : y.Numeric\nihyx : Surreal.Multiplication.IH1 y x\ni : x.LeftMoves\nk : y.LeftMoves\nl : (Neg.neg y).LeftMoves\n⊢ Surreal.Multiplication.P3 (x.moveLeft i) x (y.moveLeft k) (Neg.neg ((Neg.neg y).moveLeft l))","decl":"lemma P3_of_ih (hy : Numeric y) (ihyx : IH1 y x) (i k l) :\n    P3 (x.moveLeft i) x (y.moveLeft k) (-(-y).moveLeft l) :=\n  P3_comm.2 <| ((ihyx (IsOption.moveLeft k) (isOption_neg.1 <| .moveLeft l) <| Or.inl rfl).2\n    (by rw [moveLeft_neg, neg_neg]; apply hy.left_lt_right)).1 i\n\n"}
{"name":"Surreal.Multiplication.P24_of_ih","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\nihxy : Surreal.Multiplication.IH1 x y\ni j : x.LeftMoves\n⊢ Surreal.Multiplication.P24 (x.moveLeft i) (x.moveLeft j) y","decl":"lemma P24_of_ih (ihxy : IH1 x y) (i j) : P24 (x.moveLeft i) (x.moveLeft j) y :=\n  ihxy (IsOption.moveLeft i) (IsOption.moveLeft j) (Or.inl rfl)\n\n"}
{"name":"Surreal.Multiplication.mulOption_lt_of_lt","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\nhy : y.Numeric\nihxy : Surreal.Multiplication.IH1 x y\nihyx : Surreal.Multiplication.IH1 y x\ni j : x.LeftMoves\nk : y.LeftMoves\nl : (Neg.neg y).LeftMoves\nh : LT.lt (x.moveLeft i) (x.moveLeft j)\n⊢ LT.lt (Quotient.mk SetTheory.PGame.setoid (x.mulOption y i k)) (Neg.neg (Quotient.mk SetTheory.PGame.setoid (x.mulOption (Neg.neg y) j l)))","decl":"lemma mulOption_lt_of_lt (hy : y.Numeric) (ihxy : IH1 x y) (ihyx : IH1 y x) (i j k l)\n    (h : x.moveLeft i < x.moveLeft j) :\n    (⟦mulOption x y i k⟧ : Game) < -⟦mulOption x (-y) j l⟧ :=\n  mulOption_lt_iff_P1.2 <| P1_of_lt (P3_of_ih hy ihyx j k l) <| ((P24_of_ih ihxy i j).2 h).1 k\n\n"}
{"name":"Surreal.Multiplication.mulOption_lt","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\nhx : x.Numeric\nhy : y.Numeric\nihxy : Surreal.Multiplication.IH1 x y\nihyx : Surreal.Multiplication.IH1 y x\ni j : x.LeftMoves\nk : y.LeftMoves\nl : (Neg.neg y).LeftMoves\n⊢ LT.lt (Quotient.mk SetTheory.PGame.setoid (x.mulOption y i k)) (Neg.neg (Quotient.mk SetTheory.PGame.setoid (x.mulOption (Neg.neg y) j l)))","decl":"lemma mulOption_lt (hx : x.Numeric) (hy : y.Numeric) (ihxy : IH1 x y) (ihyx : IH1 y x) (i j k l) :\n    (⟦mulOption x y i k⟧ : Game) < -⟦mulOption x (-y) j l⟧ := by\n  obtain (h|h|h) := lt_or_equiv_or_gt (hx.moveLeft i) (hx.moveLeft j)\n  · exact mulOption_lt_of_lt hy ihxy ihyx i j k l h\n  · have ml := @IsOption.moveLeft\n    exact mulOption_lt_iff_P1.2 (P1_of_eq h (P24_of_ih ihxy i j).1\n      (ihxy (ml i) (ml j) <| Or.inr <| isOption_neg.1 <| ml l).1 <| P3_of_ih hy ihyx i k l)\n  · rw [mulOption_neg_neg, lt_neg]\n    exact mulOption_lt_of_lt hy.neg (ih1_neg_right ihxy) (ih1_neg_left ihyx) j i l _ h\n\n"}
{"name":"Surreal.Multiplication.P1_of_ih","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\nih : ∀ (a : Surreal.Multiplication.Args), Surreal.Multiplication.ArgsRel a (Surreal.Multiplication.Args.P1 x y) → Surreal.Multiplication.P124 a\nhx : x.Numeric\nhy : y.Numeric\n⊢ (HMul.hMul x y).Numeric","decl":"/-- P1 follows from the induction hypothesis. -/\ntheorem P1_of_ih (ih : ∀ a, ArgsRel a (Args.P1 x y) → P124 a) (hx : x.Numeric) (hy : y.Numeric) :\n    (x * y).Numeric := by\n  have ihxy := ih1 ih\n  have ihyx := ih1_swap ih\n  have ihxyn := ih1_neg_left (ih1_neg_right ihxy)\n  have ihyxn := ih1_neg_left (ih1_neg_right ihyx)\n  refine numeric_def.mpr ⟨?_, ?_, ?_⟩\n  · simp_rw [lt_iff_game_lt]\n    intro i\n    rw [rightMoves_mul_iff]\n    constructor <;> (intro j l; revert i; rw [leftMoves_mul_iff (_ > ·)]; constructor <;> intro i k)\n    · apply mulOption_lt hx hy ihxy ihyx\n    · simp_rw [← mulOption_symm (-y), mulOption_neg_neg x]\n      apply mulOption_lt hy.neg hx.neg ihyxn ihxyn\n    · simp only [← mulOption_symm y]\n      apply mulOption_lt hy hx ihyx ihxy\n    · rw [mulOption_neg_neg y]\n      apply mulOption_lt hx.neg hy.neg ihxyn ihyxn\n  all_goals\n    cases x; cases y\n    rintro (⟨i,j⟩|⟨i,j⟩) <;>\n    refine ((numeric_option_mul ih ?_).add <| numeric_mul_option ih ?_).sub\n      (numeric_option_mul_option ih ?_ ?_) <;>\n    solve_by_elim [IsOption.mk_left, IsOption.mk_right]\n\n"}
{"name":"Surreal.Multiplication.ih₁₂","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\nih' : ∀ (a : Surreal.Multiplication.Args), Surreal.Multiplication.ArgsRel a (Surreal.Multiplication.Args.P24 x₁ x₂ y) → Surreal.Multiplication.P124 a\n⊢ Surreal.Multiplication.IH24 x₁ x₂ y","decl":"lemma ih₁₂ (ih' : ∀ a, ArgsRel a (Args.P24 x₁ x₂ y) → P124 a) : IH24 x₁ x₂ y := by\n  rw [IH24]\n  refine fun z ↦ ⟨?_, ?_, ?_⟩ <;>\n    refine fun h ↦ ih' (Args.P24 _ _ _) (TransGen.single ?_)\n  · exact (cutExpand_add_right {y}).2 (cutExpand_pair_left h)\n  · exact (cutExpand_add_left {x₁}).2 (cutExpand_pair_left h)\n  · exact (cutExpand_add_left {x₁}).2 (cutExpand_pair_right h)\n\n"}
{"name":"Surreal.Multiplication.ih₂₁","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\nih' : ∀ (a : Surreal.Multiplication.Args), Surreal.Multiplication.ArgsRel a (Surreal.Multiplication.Args.P24 x₁ x₂ y) → Surreal.Multiplication.P124 a\n⊢ Surreal.Multiplication.IH24 x₂ x₁ y","decl":"lemma ih₂₁ (ih' : ∀ a, ArgsRel a (Args.P24 x₁ x₂ y) → P124 a) : IH24 x₂ x₁ y := ih₁₂ <| by\n  simp_rw [ArgsRel, InvImage, Args.toMultiset, Multiset.pair_comm] at ih' ⊢\n  suffices {x₁, y, x₂} = {x₂, y, x₁} by rwa [← this]\n  dsimp only [Multiset.insert_eq_cons, ← Multiset.singleton_add] at ih' ⊢\n  abel\n\n"}
{"name":"Surreal.Multiplication.ih4","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\nih' : ∀ (a : Surreal.Multiplication.Args), Surreal.Multiplication.ArgsRel a (Surreal.Multiplication.Args.P24 x₁ x₂ y) → Surreal.Multiplication.P124 a\n⊢ Surreal.Multiplication.IH4 x₁ x₂ y","decl":"lemma ih4 (ih' : ∀ a, ArgsRel a (Args.P24 x₁ x₂ y) → P124 a) : IH4 x₁ x₂ y := by\n  refine fun z w h ↦ ⟨?_, ?_⟩\n  all_goals\n    intro h'\n    apply (ih' (Args.P24 _ _ _) <| (TransGen.single _).tail <|\n      (cutExpand_add_left {x₁}).2 <| cutExpand_pair_right h).1\n    try exact (cutExpand_add_right {w}).2 <| cutExpand_pair_left h'\n    try exact (cutExpand_add_right {w}).2 <| cutExpand_pair_right h'\n\n"}
{"name":"Surreal.Multiplication.numeric_of_ih","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\nih' : ∀ (a : Surreal.Multiplication.Args), Surreal.Multiplication.ArgsRel a (Surreal.Multiplication.Args.P24 x₁ x₂ y) → Surreal.Multiplication.P124 a\n⊢ And (HMul.hMul x₁ y).Numeric (HMul.hMul x₂ y).Numeric","decl":"lemma numeric_of_ih (ih' : ∀ a, ArgsRel a (Args.P24 x₁ x₂ y) → P124 a) :\n    (x₁ * y).Numeric ∧ (x₂ * y).Numeric := by\n  constructor <;> refine ih' (Args.P1 _ _) (TransGen.single ?_)\n  · exact (cutExpand_add_right {y}).2 <| (cutExpand_add_left {x₁}).2 cutExpand_zero\n  · exact (cutExpand_add_right {x₂, y}).2 cutExpand_zero\n\n"}
{"name":"Surreal.Multiplication.ih24_neg","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\na✝ : Surreal.Multiplication.IH24 x₁ x₂ y\n⊢ And (Surreal.Multiplication.IH24 (Neg.neg x₂) (Neg.neg x₁) y) (Surreal.Multiplication.IH24 x₁ x₂ (Neg.neg y))","decl":"/-- Symmetry properties of `IH24`. -/\nlemma ih24_neg : IH24 x₁ x₂ y → IH24 (-x₂) (-x₁) y ∧ IH24 x₁ x₂ (-y) := by\n  simp_rw [IH24, ← P24_neg_right, isOption_neg]\n  refine fun h ↦ ⟨fun z ↦ ⟨?_, ?_, ?_⟩,\n    fun z ↦ ⟨(@h z).1, (@h z).2.1, P24_neg_right.2 ∘ (@h <| -z).2.2⟩⟩\n  all_goals\n    rw [P24_neg_left]\n    simp only [neg_neg]\n    first | exact (@h <| -z).2.1 | exact (@h <| -z).1 | exact (@h z).2.2\n\n"}
{"name":"Surreal.Multiplication.ih4_neg","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\na✝ : Surreal.Multiplication.IH4 x₁ x₂ y\n⊢ And (Surreal.Multiplication.IH4 (Neg.neg x₂) (Neg.neg x₁) y) (Surreal.Multiplication.IH4 x₁ x₂ (Neg.neg y))","decl":"/-- Symmetry properties of `IH4`. -/\nlemma ih4_neg : IH4 x₁ x₂ y → IH4 (-x₂) (-x₁) y ∧ IH4 x₁ x₂ (-y) := by\n  simp_rw [IH4, isOption_neg]\n  refine fun h ↦ ⟨fun z w h' ↦ ?_, fun z w h' ↦ ?_⟩\n  · convert (h h').symm using 2 <;> rw [P2_neg_left, neg_neg]\n  · convert h h' using 2 <;> rw [P2_neg_right]\n\n"}
{"name":"Surreal.Multiplication.mulOption_lt_mul_of_equiv","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\nhn : x₁.Numeric\nh : Surreal.Multiplication.IH24 x₁ x₂ y\nhe : HasEquiv.Equiv x₁ x₂\ni : x₁.LeftMoves\nj : y.LeftMoves\n⊢ LT.lt (Quotient.mk SetTheory.PGame.setoid (x₁.mulOption y i j)) (Quotient.mk SetTheory.PGame.setoid (HMul.hMul x₂ y))","decl":"lemma mulOption_lt_mul_of_equiv (hn : x₁.Numeric) (h : IH24 x₁ x₂ y) (he : x₁ ≈ x₂) (i j) :\n    ⟦mulOption x₁ y i j⟧ < (⟦x₂ * y⟧ : Game) := by\n  convert sub_lt_iff_lt_add'.2 ((((@h _).1 <| IsOption.moveLeft i).2 _).1 j) using 1\n  · rw [← ((@h _).2.2 <| IsOption.moveLeft j).1 he]\n    rfl\n  · rw [← lt_congr_right he]\n    apply hn.moveLeft_lt\n\n"}
{"name":"Surreal.Multiplication.mul_right_le_of_equiv","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\nh₁ : x₁.Numeric\nh₂ : x₂.Numeric\nh₁₂ : Surreal.Multiplication.IH24 x₁ x₂ y\nh₂₁ : Surreal.Multiplication.IH24 x₂ x₁ y\nhe : HasEquiv.Equiv x₁ x₂\n⊢ LE.le (HMul.hMul x₁ y) (HMul.hMul x₂ y)","decl":"/-- P2 follows from specialized induction hypotheses (one half of the equality). -/\ntheorem mul_right_le_of_equiv (h₁ : x₁.Numeric) (h₂ : x₂.Numeric)\n    (h₁₂ : IH24 x₁ x₂ y) (h₂₁ : IH24 x₂ x₁ y) (he : x₁ ≈ x₂) : x₁ * y ≤ x₂ * y := by\n  have he' := neg_equiv_neg_iff.2 he\n  apply PGame.le_of_forall_lt <;> simp_rw [lt_iff_game_lt]\n  · rw [leftMoves_mul_iff (_ > ·)]\n    refine ⟨mulOption_lt_mul_of_equiv h₁ h₁₂ he, ?_⟩\n    rw [← quot_neg_mul_neg]\n    exact mulOption_lt_mul_of_equiv h₁.neg (ih24_neg <| (ih24_neg h₂₁).1).2 he'\n  · rw [rightMoves_mul_iff]\n    constructor <;> intros <;> rw [lt_neg]\n    · rw [← quot_mul_neg]\n      apply mulOption_lt_mul_of_equiv h₂ (ih24_neg h₂₁).2 (symm he)\n    · rw [← quot_neg_mul]\n      apply mulOption_lt_mul_of_equiv h₂.neg (ih24_neg h₁₂).1 (symm he')\n\n"}
{"name":"Surreal.Multiplication.mulOptionsLTMul_of_numeric","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\nhn : (HMul.hMul x y).Numeric\n⊢ And (And (Surreal.Multiplication.MulOptionsLTMul x y) (Surreal.Multiplication.MulOptionsLTMul (Neg.neg x) (Neg.neg y))) (And (Surreal.Multiplication.MulOptionsLTMul x (Neg.neg y)) (Surreal.Multiplication.MulOptionsLTMul (Neg.neg x) y))","decl":"/-- That the left options of `x * y` are less than itself and the right options are greater, which\n  is part of the condition that `x * y` is numeric, is equivalent to the conjunction of various\n  `MulOptionsLTMul` statements for `x`, `y` and their negations. We only show the forward\n  direction. -/\nlemma mulOptionsLTMul_of_numeric (hn : (x * y).Numeric) :\n    (MulOptionsLTMul x y ∧ MulOptionsLTMul (-x) (-y)) ∧\n    (MulOptionsLTMul x (-y) ∧ MulOptionsLTMul (-x) y) := by\n  constructor\n  · have h := hn.moveLeft_lt\n    simp_rw [lt_iff_game_lt] at h\n    convert (leftMoves_mul_iff <| GT.gt _).1 h\n    rw [← quot_neg_mul_neg]\n    rfl\n  · have h := hn.lt_moveRight\n    simp_rw [lt_iff_game_lt, rightMoves_mul_iff] at h\n    refine h.imp ?_ ?_ <;> refine forall₂_imp fun a b ↦ ?_\n    all_goals\n      rw [lt_neg]\n      first | rw [quot_mul_neg] | rw [quot_neg_mul]\n      exact id\n\n"}
{"name":"Surreal.Multiplication.ih3_of_ih","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\nh24 : Surreal.Multiplication.IH24 x₁ x₂ y\nh4 : Surreal.Multiplication.IH4 x₁ x₂ y\nhl : Surreal.Multiplication.MulOptionsLTMul x₂ y\ni : x₂.LeftMoves\nj : y.LeftMoves\n⊢ Surreal.Multiplication.IH3 x₁ (x₂.moveLeft i) x₂ (y.moveLeft j) y","decl":"lemma ih3_of_ih (h24 : IH24 x₁ x₂ y) (h4 : IH4 x₁ x₂ y) (hl : MulOptionsLTMul x₂ y) (i j) :\n    IH3 x₁ (x₂.moveLeft i) x₂ (y.moveLeft j) y :=\n  have ml := @IsOption.moveLeft\n  have h24 := (@h24 _).2.1 (ml i)\n  ⟨(h4 <| ml j).2 (ml i), h24.1, mulOption_lt_mul_iff_P3.1 (@hl i j), fun l ↦ (h24.2 l).1 _⟩\n\n"}
{"name":"Surreal.Multiplication.P3_of_le_left","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y₁ y₂ : SetTheory.PGame\ni : x₂.LeftMoves\nh : Surreal.Multiplication.IH3 x₁ (x₂.moveLeft i) x₂ y₁ y₂\nhl : LE.le x₁ (x₂.moveLeft i)\n⊢ Surreal.Multiplication.P3 x₁ x₂ y₁ y₂","decl":"lemma P3_of_le_left {y₁ y₂} (i) (h : IH3 x₁ (x₂.moveLeft i) x₂ y₁ y₂) (hl : x₁ ≤ x₂.moveLeft i) :\n    P3 x₁ x₂ y₁ y₂ := by\n  obtain (hl|he) := lt_or_equiv_of_le hl\n  · exact (h.2.2.2 hl).trans h.2.2.1\n  · rw [P3, h.1 he, h.2.1 he]\n    exact h.2.2.1\n\n"}
{"name":"Surreal.Multiplication.P3_of_lt","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y₁ y₂ : SetTheory.PGame\nh : ∀ (i : x₂.LeftMoves), Surreal.Multiplication.IH3 x₁ (x₂.moveLeft i) x₂ y₁ y₂\nhs : ∀ (i : (Neg.neg x₁).LeftMoves), Surreal.Multiplication.IH3 (Neg.neg x₂) ((Neg.neg x₁).moveLeft i) (Neg.neg x₁) y₁ y₂\nhl : LT.lt x₁ x₂\n⊢ Surreal.Multiplication.P3 x₁ x₂ y₁ y₂","decl":"/-- P3 follows from `IH3` (so P4 (with `y₁` a left option of `y₂`) follows from the induction\n  hypothesis). -/\ntheorem P3_of_lt {y₁ y₂} (h : ∀ i, IH3 x₁ (x₂.moveLeft i) x₂ y₁ y₂)\n    (hs : ∀ i, IH3 (-x₂) ((-x₁).moveLeft i) (-x₁) y₁ y₂) (hl : x₁ < x₂) :\n    P3 x₁ x₂ y₁ y₂ := by\n  obtain (⟨i,hi⟩|⟨i,hi⟩) := lf_iff_exists_le.1 (lf_of_lt hl)\n  · exact P3_of_le_left i (h i) hi\n  · apply P3_neg.2 <| P3_of_le_left _ (hs (toLeftMovesNeg i)) _\n    simpa\n\n"}
{"name":"Surreal.Multiplication.main","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"a : Surreal.Multiplication.Args\na✝ : a.Numeric\n⊢ Surreal.Multiplication.P124 a","decl":"/-- The main chunk of Theorem 8 in [Conway2001] / Theorem 3.8 in [SchleicherStoll]. -/\ntheorem main (a : Args) : a.Numeric → P124 a := by\n  apply argsRel_wf.induction a\n  intros a ih ha\n  replace ih : ∀ a', ArgsRel a' a → P124 a' := fun a' hr ↦ ih a' hr (hr.numeric_closed ha)\n  cases a with\n  /- P1 -/\n  | P1 x y =>\n    rw [Args.numeric_P1] at ha\n    exact P1_of_ih ih ha.1 ha.2\n  | P24 x₁ x₂ y =>\n    have h₁₂ := ih₁₂ ih\n    have h₂₁ := ih₂₁ ih\n    have h4 := ih4 ih\n    obtain ⟨h₁₂x, h₁₂y⟩ := ih24_neg h₁₂\n    obtain ⟨h4x, h4y⟩ := ih4_neg h4\n    refine ⟨fun he ↦ Quotient.sound ?_, fun hl ↦ ?_⟩\n    · /- P2 -/\n      rw [Args.numeric_P24] at ha\n      exact ⟨mul_right_le_of_equiv ha.1 ha.2.1 h₁₂ h₂₁ he,\n        mul_right_le_of_equiv ha.2.1 ha.1 h₂₁ h₁₂ (symm he)⟩\n    · /- P4 -/\n      obtain ⟨hn₁, hn₂⟩ := numeric_of_ih ih\n      obtain ⟨⟨h₁, -⟩, h₂, -⟩ := mulOptionsLTMul_of_numeric hn₂\n      obtain ⟨⟨-, h₃⟩, -, h₄⟩ := mulOptionsLTMul_of_numeric hn₁\n      constructor <;> intro <;> refine P3_of_lt ?_ ?_ hl <;> intro <;> apply ih3_of_ih\n      any_goals assumption\n      exacts [(ih24_neg h₁₂y).1, (ih4_neg h4y).1]\n\n"}
{"name":"SetTheory.PGame.Numeric.mul","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y : SetTheory.PGame\nhx : x.Numeric\nhy : y.Numeric\n⊢ (HMul.hMul x y).Numeric","decl":"theorem Numeric.mul (hx : x.Numeric) (hy : y.Numeric) : Numeric (x * y) :=\n  main _ <| Args.numeric_P1.mpr ⟨hx, hy⟩\n\n"}
{"name":"SetTheory.PGame.P24","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\nhx₁ : x₁.Numeric\nhx₂ : x₂.Numeric\nhy : y.Numeric\n⊢ Surreal.Multiplication.P24 x₁ x₂ y","decl":"theorem P24 (hx₁ : x₁.Numeric) (hx₂ : x₂.Numeric) (hy : y.Numeric) : P24 x₁ x₂ y :=\n  main _ <| Args.numeric_P24.mpr ⟨hx₁, hx₂, hy⟩\n\n"}
{"name":"SetTheory.PGame.Equiv.mul_congr_left","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y : SetTheory.PGame\nhx₁ : x₁.Numeric\nhx₂ : x₂.Numeric\nhy : y.Numeric\nhe : HasEquiv.Equiv x₁ x₂\n⊢ HasEquiv.Equiv (HMul.hMul x₁ y) (HMul.hMul x₂ y)","decl":"theorem Equiv.mul_congr_left (hx₁ : x₁.Numeric) (hx₂ : x₂.Numeric) (hy : y.Numeric)\n    (he : x₁ ≈ x₂) : x₁ * y ≈ x₂ * y :=\n  equiv_iff_game_eq.2 <| (P24 hx₁ hx₂ hy).1 he\n\n"}
{"name":"SetTheory.PGame.Equiv.mul_congr_right","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x y₁ y₂ : SetTheory.PGame\nhx : x.Numeric\nhy₁ : y₁.Numeric\nhy₂ : y₂.Numeric\nhe : HasEquiv.Equiv y₁ y₂\n⊢ HasEquiv.Equiv (HMul.hMul x y₁) (HMul.hMul x y₂)","decl":"theorem Equiv.mul_congr_right (hx : x.Numeric) (hy₁ : y₁.Numeric) (hy₂ : y₂.Numeric)\n    (he : y₁ ≈ y₂) : x * y₁ ≈ x * y₂ :=\n  .trans (mul_comm_equiv _ _) <| .trans (mul_congr_left hy₁ hy₂ hx he) (mul_comm_equiv _ _)\n\n"}
{"name":"SetTheory.PGame.Equiv.mul_congr","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y₁ y₂ : SetTheory.PGame\nhx₁ : x₁.Numeric\nhx₂ : x₂.Numeric\nhy₁ : y₁.Numeric\nhy₂ : y₂.Numeric\nhx : HasEquiv.Equiv x₁ x₂\nhy : HasEquiv.Equiv y₁ y₂\n⊢ HasEquiv.Equiv (HMul.hMul x₁ y₁) (HMul.hMul x₂ y₂)","decl":"theorem Equiv.mul_congr (hx₁ : x₁.Numeric) (hx₂ : x₂.Numeric)\n    (hy₁ : y₁.Numeric) (hy₂ : y₂.Numeric) (hx : x₁ ≈ x₂) (hy : y₁ ≈ y₂) : x₁ * y₁ ≈ x₂ * y₂ :=\n  .trans (mul_congr_left hx₁ hx₂ hy₁ hx) (mul_congr_right hx₂ hy₁ hy₂ hy)\n\n"}
{"name":"SetTheory.PGame.P3_of_lt_of_lt","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ y₁ y₂ : SetTheory.PGame\nhx₁ : x₁.Numeric\nhx₂ : x₂.Numeric\nhy₁ : y₁.Numeric\nhy₂ : y₂.Numeric\nhx : LT.lt x₁ x₂\nhy : LT.lt y₁ y₂\n⊢ Surreal.Multiplication.P3 x₁ x₂ y₁ y₂","decl":"/-- One additional inductive argument that supplies the last missing part of Theorem 8. -/\ntheorem P3_of_lt_of_lt (hx₁ : x₁.Numeric) (hx₂ : x₂.Numeric) (hy₁ : y₁.Numeric) (hy₂ : y₂.Numeric)\n    (hx : x₁ < x₂) (hy : y₁ < y₂) : P3 x₁ x₂ y₁ y₂ := by\n  revert x₁ x₂\n  rw [← Prod.forall']\n  refine (wf_isOption.prod_gameAdd wf_isOption).fix ?_\n  rintro ⟨x₁, x₂⟩ ih hx₁ hx₂ hx\n  refine P3_of_lt ?_ ?_ hx <;> intro i\n  · have hi := hx₂.moveLeft i\n    exact ⟨(P24 hx₁ hi hy₁).1, (P24 hx₁ hi hy₂).1,\n      P3_comm.2 <| ((P24 hy₁ hy₂ hx₂).2 hy).1 _,\n      ih _ (snd <| IsOption.moveLeft i) hx₁ hi⟩\n  · have hi := hx₁.neg.moveLeft i\n    exact ⟨(P24 hx₂.neg hi hy₁).1, (P24 hx₂.neg hi hy₂).1,\n      P3_comm.2 <| ((P24 hy₁ hy₂ hx₁).2 hy).2 _, by\n        rw [moveLeft_neg, ← P3_neg, neg_lt_neg_iff]\n        exact ih _ (fst <| IsOption.moveRight _) (hx₁.moveRight _) hx₂⟩\n\n"}
{"name":"SetTheory.PGame.Numeric.mul_pos","module":"Mathlib.SetTheory.Surreal.Multiplication","initialProofState":"x₁ x₂ : SetTheory.PGame\nhx₁ : x₁.Numeric\nhx₂ : x₂.Numeric\nhp₁ : LT.lt 0 x₁\nhp₂ : LT.lt 0 x₂\n⊢ LT.lt 0 (HMul.hMul x₁ x₂)","decl":"theorem Numeric.mul_pos (hx₁ : x₁.Numeric) (hx₂ : x₂.Numeric) (hp₁ : 0 < x₁) (hp₂ : 0 < x₂) :\n    0 < x₁ * x₂ := by\n  rw [lt_iff_game_lt]\n  have := P3_of_lt_of_lt numeric_zero hx₁ numeric_zero hx₂ hp₁ hp₂\n  simp_rw [P3, quot_zero_mul, quot_mul_zero, add_lt_add_iff_left] at this\n  exact this\n\n"}
