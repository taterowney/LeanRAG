{"name":"List.Vector.snoc_cons","module":"Mathlib.Data.Vector.Snoc","initialProofState":"α : Type u_1\nn : Nat\nx : α\nxs : List.Vector α n\ny : α\n⊢ Eq ((List.Vector.cons x xs).snoc y) (List.Vector.cons x (xs.snoc y))","decl":"@[simp]\ntheorem snoc_cons : (x ::ᵥ xs).snoc y = x ::ᵥ (xs.snoc y) :=\n  rfl\n\n"}
{"name":"List.Vector.snoc_nil","module":"Mathlib.Data.Vector.Snoc","initialProofState":"α : Type u_1\nx : α\n⊢ Eq (List.Vector.nil.snoc x) (List.Vector.cons x List.Vector.nil)","decl":"@[simp]\ntheorem snoc_nil : (nil.snoc x) = x ::ᵥ nil :=\n  rfl\n\n"}
{"name":"List.Vector.reverse_cons","module":"Mathlib.Data.Vector.Snoc","initialProofState":"α : Type u_1\nn : Nat\nx : α\nxs : List.Vector α n\n⊢ Eq (List.Vector.cons x xs).reverse (xs.reverse.snoc x)","decl":"@[simp]\ntheorem reverse_cons : reverse (x ::ᵥ xs) = (reverse xs).snoc x := by\n  cases xs\n  simp only [reverse, cons, toList_mk, List.reverse_cons, snoc]\n  congr\n\n"}
{"name":"List.Vector.reverse_snoc","module":"Mathlib.Data.Vector.Snoc","initialProofState":"α : Type u_1\nn : Nat\nx : α\nxs : List.Vector α n\n⊢ Eq (xs.snoc x).reverse (List.Vector.cons x xs.reverse)","decl":"@[simp]\ntheorem reverse_snoc : reverse (xs.snoc x) = x ::ᵥ (reverse xs) := by\n  cases xs\n  simp only [reverse, snoc, cons, toList_mk]\n  congr\n  simp [toList, Vector.append, Append.append]\n\n"}
{"name":"List.Vector.replicate_succ_to_snoc","module":"Mathlib.Data.Vector.Snoc","initialProofState":"α : Type u_1\nn : Nat\nval : α\n⊢ Eq (List.Vector.replicate (HAdd.hAdd n 1) val) ((List.Vector.replicate n val).snoc val)","decl":"theorem replicate_succ_to_snoc (val : α) :\n    replicate (n+1) val = (replicate n val).snoc val := by\n  induction n with\n  | zero => rfl\n  | succ n ih =>\n    rw [replicate_succ]\n    conv => rhs; rw [replicate_succ]\n    rw [snoc_cons, ih]\n\n"}
{"name":"List.Vector.map_snoc","module":"Mathlib.Data.Vector.Snoc","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\nx : α\nxs : List.Vector α n\nf : α → β\n⊢ Eq (List.Vector.map f (xs.snoc x)) ((List.Vector.map f xs).snoc (f x))","decl":"@[simp]\ntheorem map_snoc {f : α → β} : map f (xs.snoc x) = (map f xs).snoc (f x) := by\n  induction xs <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr_nil","module":"Mathlib.Data.Vector.Snoc","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\nf : α → σ → Prod σ β\ns : σ\n⊢ Eq (List.Vector.mapAccumr f List.Vector.nil s) { fst := s, snd := List.Vector.nil }","decl":"@[simp]\ntheorem mapAccumr_nil {f : α → σ → σ × β} {s : σ} : mapAccumr f Vector.nil s = (s, Vector.nil) :=\n  rfl\n\n"}
{"name":"List.Vector.mapAccumr_snoc","module":"Mathlib.Data.Vector.Snoc","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\nn : Nat\nx : α\nxs : List.Vector α n\nf : α → σ → Prod σ β\ns : σ\n⊢ Eq (List.Vector.mapAccumr f (xs.snoc x) s)\n    (let q := f x s;\n    let r := List.Vector.mapAccumr f xs q.1;\n    { fst := r.1, snd := r.2.snoc q.2 })","decl":"@[simp]\ntheorem mapAccumr_snoc {f : α → σ → σ × β} {s : σ} :\n    mapAccumr f (xs.snoc x) s\n    = let q := f x s\n      let r := mapAccumr f xs q.1\n      (r.1, r.2.snoc q.2) := by\n  induction xs\n  · rfl\n  · simp [*]\n\n"}
{"name":"List.Vector.map₂_snoc","module":"Mathlib.Data.Vector.Snoc","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\nn : Nat\nx : α\nxs : List.Vector α n\nys : List.Vector β n\nf : α → β → σ\ny : β\n⊢ Eq (List.Vector.map₂ f (xs.snoc x) (ys.snoc y)) ((List.Vector.map₂ f xs ys).snoc (f x y))","decl":"@[simp]\ntheorem map₂_snoc {f : α → β → σ} {y : β} :\n    map₂ f (xs.snoc x) (ys.snoc y) = (map₂ f xs ys).snoc (f x y) := by\n  induction xs, ys using Vector.inductionOn₂ <;> simp_all\n\n"}
{"name":"List.Vector.mapAccumr₂_nil","module":"Mathlib.Data.Vector.Snoc","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\nφ : Type u_4\ns : σ\nf : α → β → σ → Prod σ φ\n⊢ Eq (List.Vector.mapAccumr₂ f List.Vector.nil List.Vector.nil s) { fst := s, snd := List.Vector.nil }","decl":"@[simp]\ntheorem mapAccumr₂_nil {f : α → β → σ → σ × φ} :\n    mapAccumr₂ f Vector.nil Vector.nil s = (s, Vector.nil) :=\n  rfl\n\n"}
{"name":"List.Vector.mapAccumr₂_snoc","module":"Mathlib.Data.Vector.Snoc","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_3\nφ : Type u_4\nn : Nat\ns : σ\nxs : List.Vector α n\nys : List.Vector β n\nf : α → β → σ → Prod σ φ\nx : α\ny : β\n⊢ Eq (List.Vector.mapAccumr₂ f (xs.snoc x) (ys.snoc y) s)\n    (let q := f x y s;\n    let r := List.Vector.mapAccumr₂ f xs ys q.1;\n    { fst := r.1, snd := r.2.snoc q.2 })","decl":"@[simp]\ntheorem mapAccumr₂_snoc (f : α → β → σ → σ × φ) (x : α) (y : β) :\n    mapAccumr₂ f (xs.snoc x) (ys.snoc y) s\n    = let q := f x y s\n      let r := mapAccumr₂ f xs ys q.1\n      (r.1, r.2.snoc q.2) := by\n  induction xs, ys using Vector.inductionOn₂ <;> simp_all\n\n"}
