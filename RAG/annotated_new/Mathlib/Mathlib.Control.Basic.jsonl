{"name":"pure_id'_seq","module":"Mathlib.Control.Basic","initialProofState":"α : Type u\nF : Type u → Type v\ninst✝¹ : Applicative F\ninst✝ : LawfulApplicative F\nx : F α\n⊢ Eq (Seq.seq (Pure.pure fun x => x) fun x_1 => x) x","decl":"@[simp]\ntheorem pure_id'_seq (x : F α) : (pure fun x => x) <*> x = x :=\n  pure_id_seq x\n\n"}
{"name":"seq_map_assoc","module":"Mathlib.Control.Basic","initialProofState":"α β γ : Type u\nF : Type u → Type v\ninst✝¹ : Applicative F\ninst✝ : LawfulApplicative F\nx : F (α → β)\nf : γ → α\ny : F γ\n⊢ Eq (Seq.seq x fun x => Functor.map f y) (Seq.seq (Functor.map (fun x => Function.comp x f) x) fun x => y)","decl":"@[functor_norm]\ntheorem seq_map_assoc (x : F (α → β)) (f : γ → α) (y : F γ) :\n    x <*> f <$> y = (· ∘ f) <$> x <*> y := by\n  simp only [← pure_seq]\n  simp only [seq_assoc, Function.comp, seq_pure, ← comp_map]\n  simp [pure_seq]\n  rfl\n\n"}
{"name":"map_seq","module":"Mathlib.Control.Basic","initialProofState":"α β γ : Type u\nF : Type u → Type v\ninst✝¹ : Applicative F\ninst✝ : LawfulApplicative F\nf : β → γ\nx : F (α → β)\ny : F α\n⊢ Eq (Functor.map f (Seq.seq x fun x => y)) (Seq.seq (Functor.map (fun x => Function.comp f x) x) fun x => y)","decl":"@[functor_norm]\ntheorem map_seq (f : β → γ) (x : F (α → β)) (y : F α) :\n    f <$> (x <*> y) = (f ∘ ·) <$> x <*> y := by\n  simp only [← pure_seq]; simp [seq_assoc]\n\n"}
{"name":"seq_bind_eq","module":"Mathlib.Control.Basic","initialProofState":"α β γ : Type u\nm : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nx : m α\ng : β → m γ\nf : α → β\n⊢ Eq (Bind.bind (Functor.map f x) g) (Bind.bind x (Function.comp g f))","decl":"theorem seq_bind_eq (x : m α) {g : β → m γ} {f : α → β} :\n    f <$> x >>= g = x >>= g ∘ f :=\n  show bind (f <$> x) g = bind x (g ∘ f) by\n    rw [← bind_pure_comp, bind_assoc]\n    simp [pure_bind, Function.comp_def]\n-- order of implicits and `Seq.seq` has a lazily evaluated second argument using `Unit`\n\n"}
{"name":"fish_pure","module":"Mathlib.Control.Basic","initialProofState":"m : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nα : Type u_1\nβ : Type u\nf : α → m β\n⊢ Eq (Bind.kleisliRight f Pure.pure) f","decl":"@[functor_norm]\ntheorem fish_pure {α β} (f : α → m β) : f >=> pure = f := by\n  simp (config := { unfoldPartialApp := true }) only [(· >=> ·), functor_norm]\n\n"}
{"name":"fish_pipe","module":"Mathlib.Control.Basic","initialProofState":"m : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nα β : Type u\nf : α → m β\n⊢ Eq (Bind.kleisliRight Pure.pure f) f","decl":"@[functor_norm]\ntheorem fish_pipe {α β} (f : α → m β) : pure >=> f = f := by\n  simp (config := { unfoldPartialApp := true }) only [(· >=> ·), functor_norm]\n\n-- note: in Lean 3 `>=>` is left-associative, but in Lean 4 it is right-associative.\n"}
{"name":"fish_assoc","module":"Mathlib.Control.Basic","initialProofState":"m : Type u → Type v\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nα : Type u_1\nβ γ φ : Type u\nf : α → m β\ng : β → m γ\nh : γ → m φ\n⊢ Eq (Bind.kleisliRight (Bind.kleisliRight f g) h) (Bind.kleisliRight f (Bind.kleisliRight g h))","decl":"@[functor_norm]\ntheorem fish_assoc {α β γ φ} (f : α → m β) (g : β → m γ) (h : γ → m φ) :\n    (f >=> g) >=> h = f >=> g >=> h := by\n  simp (config := { unfoldPartialApp := true }) only [(· >=> ·), functor_norm]\n\n"}
{"name":"joinM_map_map","module":"Mathlib.Control.Basic","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nα β : Type u\nf : α → β\na : m (m α)\n⊢ Eq (joinM (Functor.map (Functor.map f) a)) (Functor.map f (joinM a))","decl":"theorem joinM_map_map {α β : Type u} (f : α → β) (a : m (m α)) :\n    joinM (Functor.map f <$> a) = f <$> joinM a := by\n  simp only [joinM, (· ∘ ·), id, ← bind_pure_comp, bind_assoc, map_bind, pure_bind]\n\n"}
{"name":"joinM_map_joinM","module":"Mathlib.Control.Basic","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nα : Type u\na : m (m (m α))\n⊢ Eq (joinM (Functor.map joinM a)) (joinM (joinM a))","decl":"theorem joinM_map_joinM {α : Type u} (a : m (m (m α))) : joinM (joinM <$> a) = joinM (joinM a) := by\n  simp only [joinM, (· ∘ ·), id, map_bind, ← bind_pure_comp, bind_assoc, pure_bind]\n\n"}
{"name":"joinM_map_pure","module":"Mathlib.Control.Basic","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nα : Type u\na : m α\n⊢ Eq (joinM (Functor.map Pure.pure a)) a","decl":"@[simp]\ntheorem joinM_map_pure {α : Type u} (a : m α) : joinM (pure <$> a) = a := by\n  simp only [joinM, (· ∘ ·), id, map_bind, ← bind_pure_comp, bind_assoc, pure_bind, bind_pure]\n\n"}
{"name":"joinM_pure","module":"Mathlib.Control.Basic","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nα : Type u\na : m α\n⊢ Eq (joinM (Pure.pure a)) a","decl":"@[simp]\ntheorem joinM_pure {α : Type u} (a : m α) : joinM (pure a) = a :=\n  LawfulMonad.pure_bind a id\n\n"}
{"name":"guard_true","module":"Mathlib.Control.Basic","initialProofState":"F : Type → Type v\ninst✝ : Alternative F\nh : Decidable True\n⊢ Eq (guard True) (Pure.pure Unit.unit)","decl":"@[simp]\ntheorem guard_true {h : Decidable True} : @guard F _ True h = pure () := by simp [guard, if_pos]\n\n"}
{"name":"guard_false","module":"Mathlib.Control.Basic","initialProofState":"F : Type → Type v\ninst✝ : Alternative F\nh : Decidable False\n⊢ Eq (guard False) Alternative.failure","decl":"@[simp]\ntheorem guard_false {h : Decidable False} : @guard F _ False h = failure := by\n  simp [guard, if_neg not_false]\n\n"}
{"name":"Sum.instLawfulFunctor","module":"Mathlib.Control.Basic","initialProofState":"e : Type v\n⊢ LawfulFunctor (Sum e)","decl":"instance : LawfulFunctor (Sum.{v, u} e) := by\n  constructor <;> intros <;> (try casesm Sum _ _) <;> rfl\n\n"}
{"name":"Sum.instLawfulMonad","module":"Mathlib.Control.Basic","initialProofState":"e : Type v\n⊢ LawfulMonad (Sum e)","decl":"instance : LawfulMonad (Sum.{v, u} e) where\n  seqRight_eq := by\n    intros\n    casesm Sum _ _ <;> casesm Sum _ _ <;> rfl\n  seqLeft_eq := by\n    intros\n    casesm Sum _ _ <;> rfl\n  pure_seq := by\n    intros\n    rfl\n  bind_assoc := by\n    intros\n    casesm Sum _ _ <;> rfl\n  pure_bind := by\n    intros\n    rfl\n  bind_pure_comp := by\n    intros\n    casesm Sum _ _ <;> rfl\n  bind_map := by\n    intros\n    casesm Sum _ _ <;> rfl\n\n"}
{"name":"CommApplicative.toLawfulApplicative","module":"Mathlib.Control.Basic","initialProofState":"m : Type u → Type v\ninst✝ : Applicative m\nself : CommApplicative m\n⊢ LawfulApplicative m","decl":"/-- A `CommApplicative` functor `m` is a (lawful) applicative functor which behaves identically on\n`α × β` and `β × α`, so computations can occur in either order. -/\nclass CommApplicative (m : Type u → Type v) [Applicative m] extends LawfulApplicative m : Prop where\n  /-- Computations performed first on `a : α` and then on `b : β` are equal to those performed in\n  the reverse order. -/\n  commutative_prod : ∀ {α β} (a : m α) (b : m β),\n    Prod.mk <$> a <*> b = (fun (b : β) a => (a, b)) <$> b <*> a\n\n"}
{"name":"CommApplicative.commutative_prod","module":"Mathlib.Control.Basic","initialProofState":"m : Type u → Type v\ninst✝ : Applicative m\nself : CommApplicative m\nα β : Type u\na : m α\nb : m β\n⊢ Eq (Seq.seq (Functor.map Prod.mk a) fun x => b) (Seq.seq (Functor.map (fun b a => { fst := a, snd := b }) b) fun x => a)","decl":"/-- A `CommApplicative` functor `m` is a (lawful) applicative functor which behaves identically on\n`α × β` and `β × α`, so computations can occur in either order. -/\nclass CommApplicative (m : Type u → Type v) [Applicative m] extends LawfulApplicative m : Prop where\n  /-- Computations performed first on `a : α` and then on `b : β` are equal to those performed in\n  the reverse order. -/\n  commutative_prod : ∀ {α β} (a : m α) (b : m β),\n    Prod.mk <$> a <*> b = (fun (b : β) a => (a, b)) <$> b <*> a\n\n"}
{"name":"CommApplicative.commutative_map","module":"Mathlib.Control.Basic","initialProofState":"m : Type u → Type v\nh : Applicative m\ninst✝ : CommApplicative m\nα β γ : Type u\na : m α\nb : m β\nf : α → β → γ\n⊢ Eq (Seq.seq (Functor.map f a) fun x => b) (Seq.seq (Functor.map (flip f) b) fun x => a)","decl":"theorem CommApplicative.commutative_map {m : Type u → Type v} [h : Applicative m]\n    [CommApplicative m] {α β γ} (a : m α) (b : m β) {f : α → β → γ} :\n  f <$> a <*> b = flip f <$> b <*> a :=\n  calc\n    f <$> a <*> b = (fun p : α × β => f p.1 p.2) <$> (Prod.mk <$> a <*> b) := by\n      simp only [map_seq, map_map, Function.comp_def]\n    _ = (fun b a => f a b) <$> b <*> a := by\n      rw [@CommApplicative.commutative_prod m h]\n      simp [seq_map_assoc, map_seq, seq_assoc, seq_pure, map_map, (· ∘ ·)]\n      rfl\n"}
