{"name":"WithOne.coeMulHom_apply","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\ninst✝ : Mul α\na✝ : α\n⊢ Eq (WithOne.coeMulHom a✝) ↑a✝","decl":"/-- `WithOne.coe` as a bundled morphism -/\n@[to_additive (attr := simps apply) \"`WithZero.coe` as a bundled morphism\"]\ndef coeMulHom [Mul α] : α →ₙ* WithOne α where\n  toFun := coe\n  map_mul' _ _ := rfl\n\n"}
{"name":"WithZero.coeAddHom_apply","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\ninst✝ : Add α\na✝ : α\n⊢ Eq (WithZero.coeAddHom a✝) ↑a✝","decl":"/-- `WithOne.coe` as a bundled morphism -/\n@[to_additive (attr := simps apply) \"`WithZero.coe` as a bundled morphism\"]\ndef coeMulHom [Mul α] : α →ₙ* WithOne α where\n  toFun := coe\n  map_mul' _ _ := rfl\n\n"}
{"name":"WithZero.lift_coe","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Add α\ninst✝ : AddZeroClass β\nf : AddHom α β\nx : α\n⊢ Eq ((WithZero.lift f) ↑x) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_coe (x : α) : lift f x = f x :=\n  rfl\n\n"}
{"name":"WithOne.lift_coe","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Mul α\ninst✝ : MulOneClass β\nf : MulHom α β\nx : α\n⊢ Eq ((WithOne.lift f) ↑x) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_coe (x : α) : lift f x = f x :=\n  rfl\n\n"}
{"name":"WithOne.lift_one","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Mul α\ninst✝ : MulOneClass β\nf : MulHom α β\n⊢ Eq ((WithOne.lift f) 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem lift_one : lift f 1 = 1 :=\n  rfl\n\n"}
{"name":"WithZero.lift_zero","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Add α\ninst✝ : AddZeroClass β\nf : AddHom α β\n⊢ Eq ((WithZero.lift f) 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem lift_one : lift f 1 = 1 :=\n  rfl\n\n"}
{"name":"WithZero.lift_unique","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Add α\ninst✝ : AddZeroClass β\nf : AddMonoidHom (WithZero α) β\n⊢ Eq f (WithZero.lift ((↑f).comp WithZero.coeAddHom))","decl":"@[to_additive]\ntheorem lift_unique (f : WithOne α →* β) : f = lift (f.toMulHom.comp coeMulHom) :=\n  (lift.apply_symm_apply f).symm\n\n"}
{"name":"WithOne.lift_unique","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Mul α\ninst✝ : MulOneClass β\nf : MonoidHom (WithOne α) β\n⊢ Eq f (WithOne.lift ((↑f).comp WithOne.coeMulHom))","decl":"@[to_additive]\ntheorem lift_unique (f : WithOne α →* β) : f = lift (f.toMulHom.comp coeMulHom) :=\n  (lift.apply_symm_apply f).symm\n\n"}
{"name":"WithZero.map_coe","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Add α\ninst✝ : Add β\nf : AddHom α β\na : α\n⊢ Eq ((WithZero.map f) ↑a) ↑(f a)","decl":"@[to_additive (attr := simp)]\ntheorem map_coe (f : α →ₙ* β) (a : α) : map f (a : WithOne α) = f a :=\n  rfl\n\n"}
{"name":"WithOne.map_coe","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : MulHom α β\na : α\n⊢ Eq ((WithOne.map f) ↑a) ↑(f a)","decl":"@[to_additive (attr := simp)]\ntheorem map_coe (f : α →ₙ* β) (a : α) : map f (a : WithOne α) = f a :=\n  rfl\n\n"}
{"name":"WithZero.map_id","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\ninst✝ : Add α\n⊢ Eq (WithZero.map (AddHom.id α)) (AddMonoidHom.id (WithZero α))","decl":"@[to_additive (attr := simp)]\ntheorem map_id : map (MulHom.id α) = MonoidHom.id (WithOne α) := by\n  ext x\n  induction x <;> rfl\n\n"}
{"name":"WithOne.map_id","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\ninst✝ : Mul α\n⊢ Eq (WithOne.map (MulHom.id α)) (MonoidHom.id (WithOne α))","decl":"@[to_additive (attr := simp)]\ntheorem map_id : map (MulHom.id α) = MonoidHom.id (WithOne α) := by\n  ext x\n  induction x <;> rfl\n\n"}
{"name":"WithOne.map_map","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Mul α\ninst✝¹ : Mul β\ninst✝ : Mul γ\nf : MulHom α β\ng : MulHom β γ\nx : WithOne α\n⊢ Eq ((WithOne.map g) ((WithOne.map f) x)) ((WithOne.map (g.comp f)) x)","decl":"@[to_additive]\ntheorem map_map (f : α →ₙ* β) (g : β →ₙ* γ) (x) : map g (map f x) = map (g.comp f) x := by\n  induction x <;> rfl\n\n"}
{"name":"WithZero.map_map","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : Add γ\nf : AddHom α β\ng : AddHom β γ\nx : WithZero α\n⊢ Eq ((WithZero.map g) ((WithZero.map f) x)) ((WithZero.map (g.comp f)) x)","decl":"@[to_additive]\ntheorem map_map (f : α →ₙ* β) (g : β →ₙ* γ) (x) : map g (map f x) = map (g.comp f) x := by\n  induction x <;> rfl\n\n"}
{"name":"WithZero.map_comp","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : Add γ\nf : AddHom α β\ng : AddHom β γ\n⊢ Eq (WithZero.map (g.comp f)) ((WithZero.map g).comp (WithZero.map f))","decl":"@[to_additive (attr := simp)]\ntheorem map_comp (f : α →ₙ* β) (g : β →ₙ* γ) : map (g.comp f) = (map g).comp (map f) :=\n  MonoidHom.ext fun x => (map_map f g x).symm\n\n"}
{"name":"WithOne.map_comp","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Mul α\ninst✝¹ : Mul β\ninst✝ : Mul γ\nf : MulHom α β\ng : MulHom β γ\n⊢ Eq (WithOne.map (g.comp f)) ((WithOne.map g).comp (WithOne.map f))","decl":"@[to_additive (attr := simp)]\ntheorem map_comp (f : α →ₙ* β) (g : β →ₙ* γ) : map (g.comp f) = (map g).comp (map f) :=\n  MonoidHom.ext fun x => (map_map f g x).symm\n\n"}
{"name":"MulEquiv.withOneCongr_apply","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Mul α\ninst✝ : Mul β\ne : MulEquiv α β\na : WithOne α\n⊢ Eq (e.withOneCongr a) ((WithOne.map e.toMulHom) a)","decl":"/-- A version of `Equiv.optionCongr` for `WithOne`. -/\n@[to_additive (attr := simps apply) \"A version of `Equiv.optionCongr` for `WithZero`.\"]\ndef _root_.MulEquiv.withOneCongr (e : α ≃* β) : WithOne α ≃* WithOne β :=\n  { map e.toMulHom with\n    toFun := map e.toMulHom, invFun := map e.symm.toMulHom,\n    left_inv := (by induction · <;> simp)\n    right_inv := (by induction · <;> simp) }\n\n"}
{"name":"AddEquiv.withZeroCongr_apply","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Add α\ninst✝ : Add β\ne : AddEquiv α β\na : WithZero α\n⊢ Eq (e.withZeroCongr a) ((WithZero.map e.toAddHom) a)","decl":"/-- A version of `Equiv.optionCongr` for `WithOne`. -/\n@[to_additive (attr := simps apply) \"A version of `Equiv.optionCongr` for `WithZero`.\"]\ndef _root_.MulEquiv.withOneCongr (e : α ≃* β) : WithOne α ≃* WithOne β :=\n  { map e.toMulHom with\n    toFun := map e.toMulHom, invFun := map e.symm.toMulHom,\n    left_inv := (by induction · <;> simp)\n    right_inv := (by induction · <;> simp) }\n\n"}
{"name":"AddEquiv.withZeroCongr_refl","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\ninst✝ : Add α\n⊢ Eq (AddEquiv.refl α).withZeroCongr (AddEquiv.refl (WithZero α))","decl":"@[to_additive (attr := simp)]\ntheorem _root_.MulEquiv.withOneCongr_refl : (MulEquiv.refl α).withOneCongr = MulEquiv.refl _ :=\n  MulEquiv.toMonoidHom_injective map_id\n\n"}
{"name":"MulEquiv.withOneCongr_refl","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\ninst✝ : Mul α\n⊢ Eq (MulEquiv.refl α).withOneCongr (MulEquiv.refl (WithOne α))","decl":"@[to_additive (attr := simp)]\ntheorem _root_.MulEquiv.withOneCongr_refl : (MulEquiv.refl α).withOneCongr = MulEquiv.refl _ :=\n  MulEquiv.toMonoidHom_injective map_id\n\n"}
{"name":"MulEquiv.withOneCongr_symm","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Mul α\ninst✝ : Mul β\ne : MulEquiv α β\n⊢ Eq e.withOneCongr.symm e.symm.withOneCongr","decl":"@[to_additive (attr := simp)]\ntheorem _root_.MulEquiv.withOneCongr_symm (e : α ≃* β) :\n    e.withOneCongr.symm = e.symm.withOneCongr :=\n  rfl\n\n"}
{"name":"AddEquiv.withZeroCongr_symm","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Add α\ninst✝ : Add β\ne : AddEquiv α β\n⊢ Eq e.withZeroCongr.symm e.symm.withZeroCongr","decl":"@[to_additive (attr := simp)]\ntheorem _root_.MulEquiv.withOneCongr_symm (e : α ≃* β) :\n    e.withOneCongr.symm = e.symm.withOneCongr :=\n  rfl\n\n"}
{"name":"MulEquiv.withOneCongr_trans","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Mul α\ninst✝¹ : Mul β\ninst✝ : Mul γ\ne₁ : MulEquiv α β\ne₂ : MulEquiv β γ\n⊢ Eq (e₁.withOneCongr.trans e₂.withOneCongr) (e₁.trans e₂).withOneCongr","decl":"@[to_additive (attr := simp)]\ntheorem _root_.MulEquiv.withOneCongr_trans (e₁ : α ≃* β) (e₂ : β ≃* γ) :\n    e₁.withOneCongr.trans e₂.withOneCongr = (e₁.trans e₂).withOneCongr :=\n  MulEquiv.toMonoidHom_injective (map_comp _ _).symm\n\n"}
{"name":"AddEquiv.withZeroCongr_trans","module":"Mathlib.Algebra.Group.WithOne.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Add α\ninst✝¹ : Add β\ninst✝ : Add γ\ne₁ : AddEquiv α β\ne₂ : AddEquiv β γ\n⊢ Eq (e₁.withZeroCongr.trans e₂.withZeroCongr) (e₁.trans e₂).withZeroCongr","decl":"@[to_additive (attr := simp)]\ntheorem _root_.MulEquiv.withOneCongr_trans (e₁ : α ≃* β) (e₂ : β ≃* γ) :\n    e₁.withOneCongr.trans e₂.withOneCongr = (e₁.trans e₂).withOneCongr :=\n  MulEquiv.toMonoidHom_injective (map_comp _ _).symm\n\n"}
