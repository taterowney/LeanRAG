{"name":"TietzeExtension.exists_restrict_eq'","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type v\ninst✝² : TopologicalSpace Y\nself : TietzeExtension Y\nX : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : NormalSpace X\ns : Set X\nhs : IsClosed s\nf : ContinuousMap (↑s) Y\n⊢ Exists fun g => Eq (ContinuousMap.restrict s g) f","decl":"/-- A class encoding the concept that a space satisfies the Tietze extension property. -/\nclass TietzeExtension (Y : Type v) [TopologicalSpace Y] : Prop where\n  exists_restrict_eq' {X : Type u} [TopologicalSpace X] [NormalSpace X] (s : Set X)\n    (hs : IsClosed s) (f : C(s, Y)) : ∃ (g : C(X, Y)), g.restrict s = f\n\n"}
{"name":"ContinuousMap.exists_restrict_eq","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u\ninst✝³ : TopologicalSpace X\ninst✝² : NormalSpace X\ns : Set X\nY : Type v\ninst✝¹ : TopologicalSpace Y\ninst✝ : TietzeExtension Y\nhs : IsClosed s\nf : ContinuousMap (↑s) Y\n⊢ Exists fun g => Eq (ContinuousMap.restrict s g) f","decl":"/-- **Tietze extension theorem** for `TietzeExtension` spaces, a version for a closed set. Let\n`s` be a closed set in a normal topological space `X`. Let `f` be a continuous function\non `s` with values in a `TietzeExtension` space `Y`. Then there exists a continuous function\n`g : C(X, Y)` such that `g.restrict s = f`. -/\ntheorem ContinuousMap.exists_restrict_eq (hs : IsClosed s) (f : C(s, Y)) :\n    ∃ (g : C(X, Y)), g.restrict s = f :=\n  TietzeExtension.exists_restrict_eq' s hs f\n\n"}
{"name":"ContinuousMap.exists_extension","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X₁ : Type u₁\ninst✝⁴ : TopologicalSpace X₁\nX : Type u\ninst✝³ : TopologicalSpace X\ninst✝² : NormalSpace X\ne : X₁ → X\nY : Type v\ninst✝¹ : TopologicalSpace Y\ninst✝ : TietzeExtension Y\nhe : Topology.IsClosedEmbedding e\nf : ContinuousMap X₁ Y\n⊢ Exists fun g => Eq (g.comp { toFun := e, continuous_toFun := ⋯ }) f","decl":"/-- **Tietze extension theorem** for `TietzeExtension` spaces. Let `e` be a closed embedding of a\nnonempty topological space `X₁` into a normal topological space `X`. Let `f` be a continuous\nfunction on `X₁` with values in a `TietzeExtension` space `Y`. Then there exists a\ncontinuous function `g : C(X, Y)` such that `g ∘ e = f`. -/\ntheorem ContinuousMap.exists_extension (he : IsClosedEmbedding e) (f : C(X₁, Y)) :\n    ∃ (g : C(X, Y)), g.comp ⟨e, he.continuous⟩ = f := by\n  let e' : X₁ ≃ₜ Set.range e := Homeomorph.ofIsEmbedding _ he.isEmbedding\n  obtain ⟨g, hg⟩ := (f.comp e'.symm).exists_restrict_eq he.isClosed_range\n  exact ⟨g, by ext x; simpa using congr($(hg) ⟨e' x, x, rfl⟩)⟩\n\n"}
{"name":"ContinuousMap.exists_extension'","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X₁ : Type u₁\ninst✝⁴ : TopologicalSpace X₁\nX : Type u\ninst✝³ : TopologicalSpace X\ninst✝² : NormalSpace X\ne : X₁ → X\nY : Type v\ninst✝¹ : TopologicalSpace Y\ninst✝ : TietzeExtension Y\nhe : Topology.IsClosedEmbedding e\nf : ContinuousMap X₁ Y\n⊢ Exists fun g => Eq (Function.comp (⇑g) e) ⇑f","decl":"/-- **Tietze extension theorem** for `TietzeExtension` spaces. Let `e` be a closed embedding of a\nnonempty topological space `X₁` into a normal topological space `X`. Let `f` be a continuous\nfunction on `X₁` with values in a `TietzeExtension` space `Y`. Then there exists a\ncontinuous function `g : C(X, Y)` such that `g ∘ e = f`.\n\nThis version is provided for convenience and backwards compatibility. Here the composition is\nphrased in terms of bare functions. -/\ntheorem ContinuousMap.exists_extension' (he : IsClosedEmbedding e) (f : C(X₁, Y)) :\n    ∃ (g : C(X, Y)), g ∘ e = f :=\n  f.exists_extension he |>.imp fun g hg ↦ by ext x; congrm($(hg) x)\n\n"}
{"name":"ContinuousMap.exists_forall_mem_restrict_eq","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u\ninst✝² : TopologicalSpace X\ninst✝¹ : NormalSpace X\ns : Set X\nhs : IsClosed s\nY : Type v\ninst✝ : TopologicalSpace Y\nf : ContinuousMap (↑s) Y\nt : Set Y\nhf : ∀ (x : ↑s), Membership.mem t (f x)\nht : TietzeExtension ↑t\n⊢ Exists fun g => And (∀ (x : X), Membership.mem t (g x)) (Eq (ContinuousMap.restrict s g) f)","decl":"/-- This theorem is not intended to be used directly because it is rare for a set alone to\nsatisfy `[TietzeExtension t]`. For example, `Metric.ball` in `ℝ` only satisfies it when\nthe radius is strictly positive, so finding this as an instance will fail.\n\nInstead, it is intended to be used as a constructor for theorems about sets which *do* satisfy\n`[TietzeExtension t]` under some hypotheses. -/\ntheorem ContinuousMap.exists_forall_mem_restrict_eq (hs : IsClosed s)\n    {Y : Type v} [TopologicalSpace Y] (f : C(s, Y))\n    {t : Set Y} (hf : ∀ x, f x ∈ t) [ht : TietzeExtension.{u, v} t] :\n    ∃ (g : C(X, Y)), (∀ x, g x ∈ t) ∧ g.restrict s = f := by\n  obtain ⟨g, hg⟩ := mk _ (map_continuous f |>.codRestrict hf) |>.exists_restrict_eq hs\n  exact ⟨comp ⟨Subtype.val, by continuity⟩ g, by simp, by ext x; congrm(($(hg) x : Y))⟩\n\n"}
{"name":"ContinuousMap.exists_extension_forall_mem","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X₁ : Type u₁\ninst✝³ : TopologicalSpace X₁\nX : Type u\ninst✝² : TopologicalSpace X\ninst✝¹ : NormalSpace X\ne : X₁ → X\nhe : Topology.IsClosedEmbedding e\nY : Type v\ninst✝ : TopologicalSpace Y\nf : ContinuousMap X₁ Y\nt : Set Y\nhf : ∀ (x : X₁), Membership.mem t (f x)\nht : TietzeExtension ↑t\n⊢ Exists fun g => And (∀ (x : X), Membership.mem t (g x)) (Eq (g.comp { toFun := e, continuous_toFun := ⋯ }) f)","decl":"/-- This theorem is not intended to be used directly because it is rare for a set alone to\nsatisfy `[TietzeExtension t]`. For example, `Metric.ball` in `ℝ` only satisfies it when\nthe radius is strictly positive, so finding this as an instance will fail.\n\nInstead, it is intended to be used as a constructor for theorems about sets which *do* satisfy\n`[TietzeExtension t]` under some hypotheses. -/\ntheorem ContinuousMap.exists_extension_forall_mem (he : IsClosedEmbedding e)\n    {Y : Type v} [TopologicalSpace Y] (f : C(X₁, Y))\n    {t : Set Y} (hf : ∀ x, f x ∈ t) [ht : TietzeExtension.{u, v} t] :\n    ∃ (g : C(X, Y)), (∀ x, g x ∈ t) ∧ g.comp ⟨e, he.continuous⟩ = f := by\n  obtain ⟨g, hg⟩ := mk _ (map_continuous f |>.codRestrict hf) |>.exists_extension he\n  exact ⟨comp ⟨Subtype.val, by continuity⟩ g, by simp, by ext x; congrm(($(hg) x : Y))⟩\n\n"}
{"name":"Pi.instTietzeExtension","module":"Mathlib.Topology.TietzeExtension","initialProofState":"ι : Type u_1\nY : ι → Type v\ninst✝¹ : (i : ι) → TopologicalSpace (Y i)\ninst✝ : ∀ (i : ι), TietzeExtension (Y i)\n⊢ TietzeExtension ((i : ι) → Y i)","decl":"instance Pi.instTietzeExtension {ι : Type*} {Y : ι → Type v} [∀ i, TopologicalSpace (Y i)]\n    [∀ i, TietzeExtension.{u} (Y i)] : TietzeExtension.{u} (∀ i, Y i) where\n  exists_restrict_eq' s hs f := by\n    obtain ⟨g', hg'⟩ := Classical.skolem.mp <| fun i ↦\n      ContinuousMap.exists_restrict_eq hs (ContinuousMap.piEquiv _ _ |>.symm f i)\n    exact ⟨ContinuousMap.piEquiv _ _ g', by ext x i; congrm($(hg' i) x)⟩\n\n"}
{"name":"Prod.instTietzeExtension","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type v\nZ : Type w\ninst✝³ : TopologicalSpace Y\ninst✝² : TietzeExtension Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TietzeExtension Z\n⊢ TietzeExtension (Prod Y Z)","decl":"instance Prod.instTietzeExtension {Y : Type v} {Z : Type w} [TopologicalSpace Y]\n    [TietzeExtension.{u, v} Y] [TopologicalSpace Z] [TietzeExtension.{u, w} Z] :\n    TietzeExtension.{u, max w v} (Y × Z) where\n  exists_restrict_eq' s hs f := by\n    obtain ⟨g₁, hg₁⟩ := (ContinuousMap.fst.comp f).exists_restrict_eq hs\n    obtain ⟨g₂, hg₂⟩ := (ContinuousMap.snd.comp f).exists_restrict_eq hs\n    exact ⟨g₁.prodMk g₂, by ext1 x; congrm(($(hg₁) x), $(hg₂) x)⟩\n\n"}
{"name":"Unique.instTietzeExtension","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type v\ninst✝² : TopologicalSpace Y\ninst✝¹ : Nonempty Y\ninst✝ : Subsingleton Y\n⊢ TietzeExtension Y","decl":"instance Unique.instTietzeExtension {Y : Type v} [TopologicalSpace Y]\n    [Nonempty Y] [Subsingleton Y] : TietzeExtension.{u, v} Y where\n  exists_restrict_eq' _ _ f := ‹Nonempty Y›.elim fun y ↦ ⟨.const _ y, by ext; subsingleton⟩\n\n"}
{"name":"TietzeExtension.of_retract","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type v\nZ : Type w\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TietzeExtension Z\nι : ContinuousMap Y Z\nr : ContinuousMap Z Y\nh : Eq (r.comp ι) (ContinuousMap.id Y)\n⊢ TietzeExtension Y","decl":"/-- Any retract of a `TietzeExtension` space is one itself. -/\ntheorem TietzeExtension.of_retract {Y : Type v} {Z : Type w} [TopologicalSpace Y]\n    [TopologicalSpace Z] [TietzeExtension.{u, w} Z] (ι : C(Y, Z)) (r : C(Z, Y))\n    (h : r.comp ι = .id Y) : TietzeExtension.{u, v} Y where\n  exists_restrict_eq' s hs f := by\n    obtain ⟨g, hg⟩ := (ι.comp f).exists_restrict_eq hs\n    use r.comp g\n    ext1 x\n    have := congr(r.comp $(hg))\n    rw [← r.comp_assoc ι, h, f.id_comp] at this\n    congrm($this x)\n\n"}
{"name":"TietzeExtension.of_homeo","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type v\nZ : Type w\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TietzeExtension Z\ne : Homeomorph Y Z\n⊢ TietzeExtension Y","decl":"/-- Any homeomorphism from a `TietzeExtension` space is one itself. -/\ntheorem TietzeExtension.of_homeo {Y : Type v} {Z : Type w} [TopologicalSpace Y]\n    [TopologicalSpace Z] [TietzeExtension.{u, w} Z] (e : Y ≃ₜ Z) :\n    TietzeExtension.{u, v} Y :=\n  .of_retract (e : C(Y, Z)) (e.symm : C(Z, Y)) <| by simp\n\n"}
{"name":"BoundedContinuousFunction.tietze_extension_step","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NormalSpace Y\nf : BoundedContinuousFunction X Real\ne : ContinuousMap X Y\nhe : Topology.IsClosedEmbedding ⇑e\n⊢ Exists fun g => And (LE.le (Norm.norm g) (HDiv.hDiv (Norm.norm f) 3)) (LE.le (Dist.dist (g.compContinuous e) f) (HMul.hMul (2 / 3) (Norm.norm f)))","decl":"/-- One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\nof a topological space into a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous\nfunction, then there exists a bounded continuous function `g : Y →ᵇ ℝ` of the norm `‖g‖ ≤ ‖f‖ / 3`\nsuch that the distance between `g ∘ e` and `f` is at most `(2 / 3) * ‖f‖`. -/\ntheorem tietze_extension_step (f : X →ᵇ ℝ) (e : C(X, Y)) (he : IsClosedEmbedding e) :\n    ∃ g : Y →ᵇ ℝ, ‖g‖ ≤ ‖f‖ / 3 ∧ dist (g.compContinuous e) f ≤ 2 / 3 * ‖f‖ := by\n  have h3 : (0 : ℝ) < 3 := by norm_num1\n  have h23 : 0 < (2 / 3 : ℝ) := by norm_num1\n  -- In the trivial case `f = 0`, we take `g = 0`\n  rcases eq_or_ne f 0 with (rfl | hf)\n  · use 0\n    simp\n  replace hf : 0 < ‖f‖ := norm_pos_iff.2 hf\n  /- Otherwise, the closed sets `e '' (f ⁻¹' (Iic (-‖f‖ / 3)))` and `e '' (f ⁻¹' (Ici (‖f‖ / 3)))`\n    are disjoint, hence by Urysohn's lemma there exists a function `g` that is equal to `-‖f‖ / 3`\n    on the former set and is equal to `‖f‖ / 3` on the latter set. This function `g` satisfies the\n    assertions of the lemma. -/\n  have hf3 : -‖f‖ / 3 < ‖f‖ / 3 := (div_lt_div_iff_of_pos_right h3).2 (Left.neg_lt_self hf)\n  have hc₁ : IsClosed (e '' (f ⁻¹' Iic (-‖f‖ / 3))) :=\n    he.isClosedMap _ (isClosed_Iic.preimage f.continuous)\n  have hc₂ : IsClosed (e '' (f ⁻¹' Ici (‖f‖ / 3))) :=\n    he.isClosedMap _ (isClosed_Ici.preimage f.continuous)\n  have hd : Disjoint (e '' (f ⁻¹' Iic (-‖f‖ / 3))) (e '' (f ⁻¹' Ici (‖f‖ / 3))) := by\n    refine disjoint_image_of_injective he.injective (Disjoint.preimage _ ?_)\n    rwa [Iic_disjoint_Ici, not_le]\n  rcases exists_bounded_mem_Icc_of_closed_of_le hc₁ hc₂ hd hf3.le with ⟨g, hg₁, hg₂, hgf⟩\n  refine ⟨g, ?_, ?_⟩\n  · refine (norm_le <| div_nonneg hf.le h3.le).mpr fun y => ?_\n    simpa [abs_le, neg_div] using hgf y\n  · refine (dist_le <| mul_nonneg h23.le hf.le).mpr fun x => ?_\n    have hfx : -‖f‖ ≤ f x ∧ f x ≤ ‖f‖ := by\n      simpa only [Real.norm_eq_abs, abs_le] using f.norm_coe_le_norm x\n    rcases le_total (f x) (-‖f‖ / 3) with hle₁ | hle₁\n    · calc\n        |g (e x) - f x| = -‖f‖ / 3 - f x := by\n          rw [hg₁ (mem_image_of_mem _ hle₁), Function.const_apply,\n            abs_of_nonneg (sub_nonneg.2 hle₁)]\n        _ ≤ 2 / 3 * ‖f‖ := by linarith\n    · rcases le_total (f x) (‖f‖ / 3) with hle₂ | hle₂\n      · simp only [neg_div] at *\n        calc\n          dist (g (e x)) (f x) ≤ |g (e x)| + |f x| := dist_le_norm_add_norm _ _\n          _ ≤ ‖f‖ / 3 + ‖f‖ / 3 := (add_le_add (abs_le.2 <| hgf _) (abs_le.2 ⟨hle₁, hle₂⟩))\n          _ = 2 / 3 * ‖f‖ := by linarith\n      · calc\n          |g (e x) - f x| = f x - ‖f‖ / 3 := by\n            rw [hg₂ (mem_image_of_mem _ hle₂), abs_sub_comm, Function.const_apply,\n              abs_of_nonneg (sub_nonneg.2 hle₂)]\n          _ ≤ 2 / 3 * ‖f‖ := by linarith\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_norm_eq_of_isClosedEmbedding'","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NormalSpace Y\nf : BoundedContinuousFunction X Real\ne : ContinuousMap X Y\nhe : Topology.IsClosedEmbedding ⇑e\n⊢ Exists fun g => And (Eq (Norm.norm g) (Norm.norm f)) (Eq (g.compContinuous e) f)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous function, then there exists\na bounded continuous function `g : Y →ᵇ ℝ` of the same norm such that `g ∘ e = f`. -/\ntheorem exists_extension_norm_eq_of_isClosedEmbedding' (f : X →ᵇ ℝ) (e : C(X, Y))\n    (he : IsClosedEmbedding e) : ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.compContinuous e = f := by\n  /- For the proof, we iterate `tietze_extension_step`. Each time we apply it to the difference\n    between the previous approximation and `f`. -/\n  choose F hF_norm hF_dist using fun f : X →ᵇ ℝ => tietze_extension_step f e he\n  set g : ℕ → Y →ᵇ ℝ := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0\n  have g0 : g 0 = 0 := rfl\n  have g_succ : ∀ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>\n    Function.iterate_succ_apply' _ _ _\n  have hgf : ∀ n, dist ((g n).compContinuous e) f ≤ (2 / 3) ^ n * ‖f‖ := by\n    intro n\n    induction n with\n    | zero => simp [g0]\n    | succ n ihn =>\n      rw [g_succ n, add_compContinuous, ← dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]\n      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))\n      rwa [← dist_eq_norm']\n  have hg_dist : ∀ n, dist (g n) (g (n + 1)) ≤ 1 / 3 * ‖f‖ * (2 / 3) ^ n := by\n    intro n\n    calc\n      dist (g n) (g (n + 1)) = ‖F (f - (g n).compContinuous e)‖ := by\n        rw [g_succ, dist_eq_norm', add_sub_cancel_left]\n      _ ≤ ‖f - (g n).compContinuous e‖ / 3 := hF_norm _\n      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]\n      _ ≤ 1 / 3 * ((2 / 3) ^ n * ‖f‖) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)\n      _ = 1 / 3 * ‖f‖ * (2 / 3) ^ n := by ac_rfl\n  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist\n  have :\n    Tendsto (fun n => (g n).compContinuous e) atTop\n      (𝓝 <| (limUnder atTop g).compContinuous e) :=\n    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder\n  have hge : (limUnder atTop g).compContinuous e = f := by\n    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)\n    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_\n    rw [← zero_mul ‖f‖]\n    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1\n  refine ⟨limUnder atTop g, le_antisymm ?_ ?_, hge⟩\n  · rw [← dist_zero_left, ← g0]\n    refine\n      (dist_le_of_le_geometric_of_tendsto₀ _ _ (by norm_num1)\n        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_\n    field_simp [show (3 - 2 : ℝ) = 1 by norm_num1]\n  · rw [← hge]\n    exact norm_compContinuous_le _ _\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding'","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NormalSpace Y\nf : BoundedContinuousFunction X Real\ne : ContinuousMap X Y\nhe : Topology.IsClosedEmbedding ⇑e\n⊢ Exists fun g => And (Eq (Norm.norm g) (Norm.norm f)) (Eq (g.compContinuous e) f)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_norm_eq_of_closedEmbedding' := exists_extension_norm_eq_of_isClosedEmbedding'\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_norm_eq_of_isClosedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NormalSpace Y\nf : BoundedContinuousFunction X Real\ne : X → Y\nhe : Topology.IsClosedEmbedding e\n⊢ Exists fun g => And (Eq (Norm.norm g) (Norm.norm f)) (Eq (Function.comp (⇑g) e) ⇑f)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and unbundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous function, then there exists\na bounded continuous function `g : Y →ᵇ ℝ` of the same norm such that `g ∘ e = f`. -/\ntheorem exists_extension_norm_eq_of_isClosedEmbedding (f : X →ᵇ ℝ) {e : X → Y}\n    (he : IsClosedEmbedding e) : ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g ∘ e = f := by\n  rcases exists_extension_norm_eq_of_isClosedEmbedding' f ⟨e, he.continuous⟩ he with ⟨g, hg, rfl⟩\n  exact ⟨g, hg, rfl⟩\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NormalSpace Y\nf : BoundedContinuousFunction X Real\ne : X → Y\nhe : Topology.IsClosedEmbedding e\n⊢ Exists fun g => And (Eq (Norm.norm g) (Norm.norm f)) (Eq (Function.comp (⇑g) e) ⇑f)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_norm_eq_of_closedEmbedding := exists_extension_norm_eq_of_isClosedEmbedding\n\n"}
{"name":"BoundedContinuousFunction.exists_norm_eq_restrict_eq_of_closed","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type u_2\ninst✝¹ : TopologicalSpace Y\ninst✝ : NormalSpace Y\ns : Set Y\nf : BoundedContinuousFunction (↑s) Real\nhs : IsClosed s\n⊢ Exists fun g => And (Eq (Norm.norm g) (Norm.norm f)) (Eq (g.restrict s) f)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nset. If `f` is a bounded continuous real-valued function defined on a closed set in a normal\ntopological space, then it can be extended to a bounded continuous function of the same norm defined\non the whole space. -/\ntheorem exists_norm_eq_restrict_eq_of_closed {s : Set Y} (f : s →ᵇ ℝ) (hs : IsClosed s) :\n    ∃ g : Y →ᵇ ℝ, ‖g‖ = ‖f‖ ∧ g.restrict s = f :=\n  exists_extension_norm_eq_of_isClosedEmbedding' f ((ContinuousMap.id _).restrict s)\n    hs.isClosedEmbedding_subtypeVal\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_forall_mem_Icc_of_isClosedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NormalSpace Y\nf : BoundedContinuousFunction X Real\na b : Real\ne : X → Y\nhf : ∀ (x : X), Membership.mem (Set.Icc a b) (f x)\nhle : LE.le a b\nhe : Topology.IsClosedEmbedding e\n⊢ Exists fun g => And (∀ (y : Y), Membership.mem (Set.Icc a b) (g y)) (Eq (Function.comp (⇑g) e) ⇑f)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nembedding and a bounded continuous function that takes values in a non-trivial closed interval.\nSee also `exists_extension_forall_mem_of_isClosedEmbedding` for a more general statement that works\nfor any interval (finite or infinite, open or closed).\n\nIf `e : X → Y` is a closed embedding and `f : X →ᵇ ℝ` is a bounded continuous function such that\n`f x ∈ [a, b]` for all `x`, where `a ≤ b`, then there exists a bounded continuous function\n`g : Y →ᵇ ℝ` such that `g y ∈ [a, b]` for all `y` and `g ∘ e = f`. -/\ntheorem exists_extension_forall_mem_Icc_of_isClosedEmbedding (f : X →ᵇ ℝ) {a b : ℝ} {e : X → Y}\n    (hf : ∀ x, f x ∈ Icc a b) (hle : a ≤ b) (he : IsClosedEmbedding e) :\n    ∃ g : Y →ᵇ ℝ, (∀ y, g y ∈ Icc a b) ∧ g ∘ e = f := by\n  rcases exists_extension_norm_eq_of_isClosedEmbedding (f - const X ((a + b) / 2)) he with\n    ⟨g, hgf, hge⟩\n  refine ⟨const Y ((a + b) / 2) + g, fun y => ?_, ?_⟩\n  · suffices ‖f - const X ((a + b) / 2)‖ ≤ (b - a) / 2 by\n      simpa [Real.Icc_eq_closedBall, add_mem_closedBall_iff_norm] using\n        (norm_coe_le_norm g y).trans (hgf.trans_le this)\n    refine (norm_le <| div_nonneg (sub_nonneg.2 hle) zero_le_two).2 fun x => ?_\n    simpa only [Real.Icc_eq_closedBall] using hf x\n  · ext x\n    have : g (e x) = f x - (a + b) / 2 := congr_fun hge x\n    simp [this]\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_forall_mem_Icc_of_closedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NormalSpace Y\nf : BoundedContinuousFunction X Real\na b : Real\ne : X → Y\nhf : ∀ (x : X), Membership.mem (Set.Icc a b) (f x)\nhle : LE.le a b\nhe : Topology.IsClosedEmbedding e\n⊢ Exists fun g => And (∀ (y : Y), Membership.mem (Set.Icc a b) (g y)) (Eq (Function.comp (⇑g) e) ⇑f)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_forall_mem_Icc_of_closedEmbedding :=\n  exists_extension_forall_mem_Icc_of_isClosedEmbedding\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_isClosedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : NormalSpace Y\ninst✝ : Nonempty X\nf : BoundedContinuousFunction X Real\ne : X → Y\nhe : Topology.IsClosedEmbedding e\n⊢ Exists fun g => And (∀ (y : Y), Exists fun x₁ => Exists fun x₂ => Membership.mem (Set.Icc (f x₁) (f x₂)) (g y)) (Eq (Function.comp (⇑g) e) ⇑f)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a bounded continuous real-valued function on `X`. Then there\nexists a bounded continuous function `g : Y →ᵇ ℝ` such that `g ∘ e = f` and each value `g y` belongs\nto a closed interval `[f x₁, f x₂]` for some `x₁` and `x₂`. -/\ntheorem exists_extension_forall_exists_le_ge_of_isClosedEmbedding [Nonempty X] (f : X →ᵇ ℝ)\n    {e : X → Y} (he : IsClosedEmbedding e) :\n    ∃ g : Y →ᵇ ℝ, (∀ y, ∃ x₁ x₂, g y ∈ Icc (f x₁) (f x₂)) ∧ g ∘ e = f := by\n  inhabit X\n  -- Put `a = ⨅ x, f x` and `b = ⨆ x, f x`\n  obtain ⟨a, ha⟩ : ∃ a, IsGLB (range f) a := ⟨_, isGLB_ciInf f.isBounded_range.bddBelow⟩\n  obtain ⟨b, hb⟩ : ∃ b, IsLUB (range f) b := ⟨_, isLUB_ciSup f.isBounded_range.bddAbove⟩\n  -- Then `f x ∈ [a, b]` for all `x`\n  have hmem : ∀ x, f x ∈ Icc a b := fun x => ⟨ha.1 ⟨x, rfl⟩, hb.1 ⟨x, rfl⟩⟩\n  -- Rule out the trivial case `a = b`\n  have hle : a ≤ b := (hmem default).1.trans (hmem default).2\n  rcases hle.eq_or_lt with (rfl | hlt)\n  · have : ∀ x, f x = a := by simpa using hmem\n    use const Y a\n    simp [this, funext_iff]\n  -- Put `c = (a + b) / 2`. Then `a < c < b` and `c - a = b - c`.\n  set c := (a + b) / 2\n  have hac : a < c := left_lt_add_div_two.2 hlt\n  have hcb : c < b := add_div_two_lt_right.2 hlt\n  have hsub : c - a = b - c := by\n    field_simp [c]\n    ring\n  /- Due to `exists_extension_forall_mem_Icc_of_isClosedEmbedding`, there exists an extension `g`\n    such that `g y ∈ [a, b]` for all `y`. However, if `a` and/or `b` do not belong to the range of\n    `f`, then we need to ensure that these points do not belong to the range of `g`. This is done\n    in two almost identical steps. First we deal with the case `∀ x, f x ≠ a`. -/\n  obtain ⟨g, hg_mem, hgf⟩ : ∃ g : Y →ᵇ ℝ, (∀ y, ∃ x, g y ∈ Icc (f x) b) ∧ g ∘ e = f := by\n    rcases exists_extension_forall_mem_Icc_of_isClosedEmbedding f hmem hle he with ⟨g, hg_mem, hgf⟩\n    -- If `a ∈ range f`, then we are done.\n    rcases em (∃ x, f x = a) with (⟨x, rfl⟩ | ha')\n    · exact ⟨g, fun y => ⟨x, hg_mem _⟩, hgf⟩\n    /- Otherwise, `g ⁻¹' {a}` is disjoint with `range e ∪ g ⁻¹' (Ici c)`, hence there exists a\n        function `dg : Y → ℝ` such that `dg ∘ e = 0`, `dg y = 0` whenever `c ≤ g y`, `dg y = c - a`\n        whenever `g y = a`, and `0 ≤ dg y ≤ c - a` for all `y`. -/\n    have hd : Disjoint (range e ∪ g ⁻¹' Ici c) (g ⁻¹' {a}) := by\n      refine disjoint_union_left.2 ⟨?_, Disjoint.preimage _ ?_⟩\n      · rw [Set.disjoint_left]\n        rintro _ ⟨x, rfl⟩ (rfl : g (e x) = a)\n        exact ha' ⟨x, (congr_fun hgf x).symm⟩\n      · exact Set.disjoint_singleton_right.2 hac.not_le\n    rcases exists_bounded_mem_Icc_of_closed_of_le\n        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)\n        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with\n      ⟨dg, dg0, dga, dgmem⟩\n    replace hgf : ∀ x, (g + dg) (e x) = f x := by\n      intro x\n      simp [dg0 (Or.inl <| mem_range_self _), ← hgf]\n    refine ⟨g + dg, fun y => ?_, funext hgf⟩\n    have hay : a < (g + dg) y := by\n      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)\n      · refine (lt_add_iff_pos_right _).2 ?_\n        calc\n          0 < c - g y := sub_pos.2 hac\n          _ = dg y := (dga rfl).symm\n      · exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)\n    rcases ha.exists_between hay with ⟨_, ⟨x, rfl⟩, _, hxy⟩\n    refine ⟨x, hxy.le, ?_⟩\n    rcases le_total c (g y) with hc | hc\n    · simp [dg0 (Or.inr hc), (hg_mem y).2]\n    · calc\n        g y + dg y ≤ c + (c - a) := add_le_add hc (dgmem _).2\n        _ = b := by rw [hsub, add_sub_cancel]\n  /- Now we deal with the case `∀ x, f x ≠ b`. The proof is the same as in the first case, with\n    minor modifications that make it hard to deduplicate code. -/\n  choose xl hxl hgb using hg_mem\n  rcases em (∃ x, f x = b) with (⟨x, rfl⟩ | hb')\n  · exact ⟨g, fun y => ⟨xl y, x, hxl y, hgb y⟩, hgf⟩\n  have hd : Disjoint (range e ∪ g ⁻¹' Iic c) (g ⁻¹' {b}) := by\n    refine disjoint_union_left.2 ⟨?_, Disjoint.preimage _ ?_⟩\n    · rw [Set.disjoint_left]\n      rintro _ ⟨x, rfl⟩ (rfl : g (e x) = b)\n      exact hb' ⟨x, (congr_fun hgf x).symm⟩\n    · exact Set.disjoint_singleton_right.2 hcb.not_le\n  rcases exists_bounded_mem_Icc_of_closed_of_le\n      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)\n      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with\n    ⟨dg, dg0, dgb, dgmem⟩\n  replace hgf : ∀ x, (g - dg) (e x) = f x := by\n    intro x\n    simp [dg0 (Or.inl <| mem_range_self _), ← hgf]\n  refine ⟨g - dg, fun y => ?_, funext hgf⟩\n  have hyb : (g - dg) y < b := by\n    rcases (hgb y).eq_or_lt with (rfl | hlt)\n    · refine (sub_lt_self_iff _).2 ?_\n      calc\n        0 < g y - c := sub_pos.2 hcb\n        _ = dg y := (dgb rfl).symm\n    · exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt\n  rcases hb.exists_between hyb with ⟨_, ⟨xu, rfl⟩, hyxu, _⟩\n  cases' lt_or_le c (g y) with hc hc\n  · rcases em (a ∈ range f) with (⟨x, rfl⟩ | _)\n    · refine ⟨x, xu, ?_, hyxu.le⟩\n      calc\n        f x = c - (b - c) := by rw [← hsub, sub_sub_cancel]\n        _ ≤ g y - dg y := sub_le_sub hc.le (dgmem _).2\n    · have hay : a < (g - dg) y := by\n        calc\n          a = c - (b - c) := by rw [← hsub, sub_sub_cancel]\n          _ < g y - (b - c) := sub_lt_sub_right hc _\n          _ ≤ g y - dg y := sub_le_sub_left (dgmem _).2 _\n      rcases ha.exists_between hay with ⟨_, ⟨x, rfl⟩, _, hxy⟩\n      exact ⟨x, xu, hxy.le, hyxu.le⟩\n  · refine ⟨xl y, xu, ?_, hyxu.le⟩\n    simp [dg0 (Or.inr hc), hxl]\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : NormalSpace Y\ninst✝ : Nonempty X\nf : BoundedContinuousFunction X Real\ne : X → Y\nhe : Topology.IsClosedEmbedding e\n⊢ Exists fun g => And (∀ (y : Y), Exists fun x₁ => Exists fun x₂ => Membership.mem (Set.Icc (f x₁) (f x₂)) (g y)) (Eq (Function.comp (⇑g) e) ⇑f)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_forall_exists_le_ge_of_closedEmbedding :=\n  exists_extension_forall_exists_le_ge_of_isClosedEmbedding\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_forall_mem_of_isClosedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NormalSpace Y\nf : BoundedContinuousFunction X Real\nt : Set Real\ne : X → Y\nhs : t.OrdConnected\nhf : ∀ (x : X), Membership.mem t (f x)\nhne : t.Nonempty\nhe : Topology.IsClosedEmbedding e\n⊢ Exists fun g => And (∀ (y : Y), Membership.mem t (g y)) (Eq (Function.comp (⇑g) e) ⇑f)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a bounded continuous real-valued function on `X`. Let `t` be\na nonempty convex set of real numbers (we use `OrdConnected` instead of `Convex` to automatically\ndeduce this argument by typeclass search) such that `f x ∈ t` for all `x`. Then there exists\na bounded continuous real-valued function `g : Y →ᵇ ℝ` such that `g y ∈ t` for all `y` and\n`g ∘ e = f`. -/\ntheorem exists_extension_forall_mem_of_isClosedEmbedding (f : X →ᵇ ℝ) {t : Set ℝ} {e : X → Y}\n    [hs : OrdConnected t] (hf : ∀ x, f x ∈ t) (hne : t.Nonempty) (he : IsClosedEmbedding e) :\n    ∃ g : Y →ᵇ ℝ, (∀ y, g y ∈ t) ∧ g ∘ e = f := by\n  cases isEmpty_or_nonempty X\n  · rcases hne with ⟨c, hc⟩\n    exact ⟨const Y c, fun _ => hc, funext fun x => isEmptyElim x⟩\n  rcases exists_extension_forall_exists_le_ge_of_isClosedEmbedding f he with ⟨g, hg, hgf⟩\n  refine ⟨g, fun y => ?_, hgf⟩\n  rcases hg y with ⟨xl, xu, h⟩\n  exact hs.out (hf _) (hf _) h\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_forall_mem_of_closedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NormalSpace Y\nf : BoundedContinuousFunction X Real\nt : Set Real\ne : X → Y\nhs : t.OrdConnected\nhf : ∀ (x : X), Membership.mem t (f x)\nhne : t.Nonempty\nhe : Topology.IsClosedEmbedding e\n⊢ Exists fun g => And (∀ (y : Y), Membership.mem t (g y)) (Eq (Function.comp (⇑g) e) ⇑f)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_forall_mem_of_closedEmbedding :=\n  exists_extension_forall_mem_of_isClosedEmbedding\n\n"}
{"name":"BoundedContinuousFunction.exists_forall_mem_restrict_eq_of_closed","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type u_2\ninst✝² : TopologicalSpace Y\ninst✝¹ : NormalSpace Y\ns : Set Y\nf : BoundedContinuousFunction (↑s) Real\nhs : IsClosed s\nt : Set Real\ninst✝ : t.OrdConnected\nhf : ∀ (x : ↑s), Membership.mem t (f x)\nhne : t.Nonempty\n⊢ Exists fun g => And (∀ (y : Y), Membership.mem t (g y)) (Eq (g.restrict s) f)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nset. Let `s` be a closed set in a normal topological space `Y`. Let `f` be a bounded continuous\nreal-valued function on `s`. Let `t` be a nonempty convex set of real numbers (we use\n`OrdConnected` instead of `Convex` to automatically deduce this argument by typeclass search) such\nthat `f x ∈ t` for all `x : s`. Then there exists a bounded continuous real-valued function\n`g : Y →ᵇ ℝ` such that `g y ∈ t` for all `y` and `g.restrict s = f`. -/\ntheorem exists_forall_mem_restrict_eq_of_closed {s : Set Y} (f : s →ᵇ ℝ) (hs : IsClosed s)\n    {t : Set ℝ} [OrdConnected t] (hf : ∀ x, f x ∈ t) (hne : t.Nonempty) :\n    ∃ g : Y →ᵇ ℝ, (∀ y, g y ∈ t) ∧ g.restrict s = f := by\n  obtain ⟨g, hg, hgf⟩ :=\n    exists_extension_forall_mem_of_isClosedEmbedding f hf hne hs.isClosedEmbedding_subtypeVal\n  exact ⟨g, hg, DFunLike.coe_injective hgf⟩\n\n"}
{"name":"ContinuousMap.exists_extension_forall_mem_of_isClosedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NormalSpace Y\nf : ContinuousMap X Real\nt : Set Real\ne : X → Y\nhs : t.OrdConnected\nhf : ∀ (x : X), Membership.mem t (f x)\nhne : t.Nonempty\nhe : Topology.IsClosedEmbedding e\n⊢ Exists fun g => And (∀ (y : Y), Membership.mem t (g y)) (Eq (Function.comp (⇑g) e) ⇑f)","decl":"/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Let `t` be a nonempty\nconvex set of real numbers (we use `OrdConnected` instead of `Convex` to automatically deduce this\nargument by typeclass search) such that `f x ∈ t` for all `x`. Then there exists a continuous\nreal-valued function `g : C(Y, ℝ)` such that `g y ∈ t` for all `y` and `g ∘ e = f`. -/\ntheorem exists_extension_forall_mem_of_isClosedEmbedding (f : C(X, ℝ)) {t : Set ℝ} {e : X → Y}\n    [hs : OrdConnected t] (hf : ∀ x, f x ∈ t) (hne : t.Nonempty) (he : IsClosedEmbedding e) :\n    ∃ g : C(Y, ℝ), (∀ y, g y ∈ t) ∧ g ∘ e = f := by\n  have h : ℝ ≃o Ioo (-1 : ℝ) 1 := orderIsoIooNegOneOne ℝ\n  let F : X →ᵇ ℝ :=\n    { toFun := (↑) ∘ h ∘ f\n      continuous_toFun := continuous_subtype_val.comp (h.continuous.comp f.continuous)\n      map_bounded' := isBounded_range_iff.1\n        ((isBounded_Ioo (-1 : ℝ) 1).subset <| range_subset_iff.2 fun x => (h (f x)).2) }\n  let t' : Set ℝ := (↑) ∘ h '' t\n  have ht_sub : t' ⊆ Ioo (-1 : ℝ) 1 := image_subset_iff.2 fun x _ => (h x).2\n  have : OrdConnected t' := by\n    constructor\n    rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩ z hz\n    lift z to Ioo (-1 : ℝ) 1 using Icc_subset_Ioo (h x).2.1 (h y).2.2 hz\n    change z ∈ Icc (h x) (h y) at hz\n    rw [← h.image_Icc] at hz\n    rcases hz with ⟨z, hz, rfl⟩\n    exact ⟨z, hs.out hx hy hz, rfl⟩\n  have hFt : ∀ x, F x ∈ t' := fun x => mem_image_of_mem _ (hf x)\n  rcases F.exists_extension_forall_mem_of_isClosedEmbedding hFt (hne.image _) he with ⟨G, hG, hGF⟩\n  let g : C(Y, ℝ) :=\n    ⟨h.symm ∘ codRestrict G _ fun y => ht_sub (hG y),\n      h.symm.continuous.comp <| G.continuous.subtype_mk _⟩\n  have hgG : ∀ {y a}, g y = a ↔ G y = h a := @fun y a =>\n    h.toEquiv.symm_apply_eq.trans Subtype.ext_iff\n  refine ⟨g, fun y => ?_, ?_⟩\n  · rcases hG y with ⟨a, ha, hay⟩\n    convert ha\n    exact hgG.2 hay.symm\n  · ext x\n    exact hgG.2 (congr_fun hGF _)\n\n"}
{"name":"ContinuousMap.exists_extension_forall_mem_of_closedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : NormalSpace Y\nf : ContinuousMap X Real\nt : Set Real\ne : X → Y\nhs : t.OrdConnected\nhf : ∀ (x : X), Membership.mem t (f x)\nhne : t.Nonempty\nhe : Topology.IsClosedEmbedding e\n⊢ Exists fun g => And (∀ (y : Y), Membership.mem t (g y)) (Eq (Function.comp (⇑g) e) ⇑f)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_forall_mem_of_closedEmbedding :=\n  exists_extension_forall_mem_of_isClosedEmbedding\n\n"}
{"name":"ContinuousMap.exists_extension_of_closedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X₁ : Type u₁\ninst✝⁴ : TopologicalSpace X₁\nX : Type u\ninst✝³ : TopologicalSpace X\ninst✝² : NormalSpace X\ne : X₁ → X\nY : Type v\ninst✝¹ : TopologicalSpace Y\ninst✝ : TietzeExtension Y\nhe : Topology.IsClosedEmbedding e\nf : ContinuousMap X₁ Y\n⊢ Exists fun g => Eq (Function.comp (⇑g) e) ⇑f","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_of_closedEmbedding := exists_extension'\n\n"}
{"name":"ContinuousMap.exists_restrict_eq_forall_mem_of_closed","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type u_2\ninst✝² : TopologicalSpace Y\ninst✝¹ : NormalSpace Y\ns : Set Y\nf : ContinuousMap (↑s) Real\nt : Set Real\ninst✝ : t.OrdConnected\nht : ∀ (x : ↑s), Membership.mem t (f x)\nhne : t.Nonempty\nhs : IsClosed s\n⊢ Exists fun g => And (∀ (y : Y), Membership.mem t (g y)) (Eq (ContinuousMap.restrict s g) f)","decl":"/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\non `s`. Let `t` be a nonempty convex set of real numbers (we use `OrdConnected` instead of `Convex`\nto automatically deduce this argument by typeclass search) such that `f x ∈ t` for all `x : s`. Then\nthere exists a continuous real-valued function `g : C(Y, ℝ)` such that `g y ∈ t` for all `y` and\n`g.restrict s = f`. -/\ntheorem exists_restrict_eq_forall_mem_of_closed {s : Set Y} (f : C(s, ℝ)) {t : Set ℝ}\n    [OrdConnected t] (ht : ∀ x, f x ∈ t) (hne : t.Nonempty) (hs : IsClosed s) :\n    ∃ g : C(Y, ℝ), (∀ y, g y ∈ t) ∧ g.restrict s = f :=\n  let ⟨g, hgt, hgf⟩ :=\n    exists_extension_forall_mem_of_isClosedEmbedding f ht hne hs.isClosedEmbedding_subtypeVal\n  ⟨g, hgt, coe_injective hgf⟩\n\n"}
{"name":"Real.instTietzeExtension","module":"Mathlib.Topology.TietzeExtension","initialProofState":"⊢ TietzeExtension Real","decl":"/-- **Tietze extension theorem** for real-valued continuous maps.\n`ℝ` is a `TietzeExtension` space. -/\ninstance Real.instTietzeExtension : TietzeExtension ℝ where\n  exists_restrict_eq' _s hs f :=\n    f.exists_restrict_eq_forall_mem_of_closed (fun _ => mem_univ _) univ_nonempty hs |>.imp\n      fun _ ↦ (And.right ·)\n\n"}
{"name":"NNReal.instTietzeExtension","module":"Mathlib.Topology.TietzeExtension","initialProofState":"⊢ TietzeExtension NNReal","decl":"open NNReal in\n/-- **Tietze extension theorem** for nonnegative real-valued continuous maps.\n`ℝ≥0` is a `TietzeExtension` space. -/\ninstance NNReal.instTietzeExtension : TietzeExtension ℝ≥0 :=\n  .of_retract ⟨((↑) : ℝ≥0 → ℝ), by continuity⟩ ⟨Real.toNNReal, continuous_real_toNNReal⟩ <| by\n    ext; simp\n"}
