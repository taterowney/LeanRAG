{"name":"TietzeExtension.exists_restrict_eq'","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type v\ninst‚úù¬≤ : TopologicalSpace Y\nself : TietzeExtension Y\nX : Type u\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : NormalSpace X\ns : Set X\nhs : IsClosed s\nf : ContinuousMap (‚Üës) Y\n‚ä¢ Exists fun g => Eq (ContinuousMap.restrict s g) f","decl":"/-- A class encoding the concept that a space satisfies the Tietze extension property. -/\nclass TietzeExtension (Y : Type v) [TopologicalSpace Y] : Prop where\n  exists_restrict_eq' {X : Type u} [TopologicalSpace X] [NormalSpace X] (s : Set X)\n    (hs : IsClosed s) (f : C(s, Y)) : ‚àÉ (g : C(X, Y)), g.restrict s = f\n\n"}
{"name":"ContinuousMap.exists_restrict_eq","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : NormalSpace X\ns : Set X\nY : Type v\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TietzeExtension Y\nhs : IsClosed s\nf : ContinuousMap (‚Üës) Y\n‚ä¢ Exists fun g => Eq (ContinuousMap.restrict s g) f","decl":"/-- **Tietze extension theorem** for `TietzeExtension` spaces, a version for a closed set. Let\n`s` be a closed set in a normal topological space `X`. Let `f` be a continuous function\non `s` with values in a `TietzeExtension` space `Y`. Then there exists a continuous function\n`g : C(X, Y)` such that `g.restrict s = f`. -/\ntheorem ContinuousMap.exists_restrict_eq (hs : IsClosed s) (f : C(s, Y)) :\n    ‚àÉ (g : C(X, Y)), g.restrict s = f :=\n  TietzeExtension.exists_restrict_eq' s hs f\n\n"}
{"name":"ContinuousMap.exists_extension","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X‚ÇÅ : Type u‚ÇÅ\ninst‚úù‚Å¥ : TopologicalSpace X‚ÇÅ\nX : Type u\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : NormalSpace X\ne : X‚ÇÅ ‚Üí X\nY : Type v\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TietzeExtension Y\nhe : Topology.IsClosedEmbedding e\nf : ContinuousMap X‚ÇÅ Y\n‚ä¢ Exists fun g => Eq (g.comp { toFun := e, continuous_toFun := ‚ãØ }) f","decl":"/-- **Tietze extension theorem** for `TietzeExtension` spaces. Let `e` be a closed embedding of a\nnonempty topological space `X‚ÇÅ` into a normal topological space `X`. Let `f` be a continuous\nfunction on `X‚ÇÅ` with values in a `TietzeExtension` space `Y`. Then there exists a\ncontinuous function `g : C(X, Y)` such that `g ‚àò e = f`. -/\ntheorem ContinuousMap.exists_extension (he : IsClosedEmbedding e) (f : C(X‚ÇÅ, Y)) :\n    ‚àÉ (g : C(X, Y)), g.comp ‚ü®e, he.continuous‚ü© = f := by\n  let e' : X‚ÇÅ ‚âÉ‚Çú Set.range e := Homeomorph.ofIsEmbedding _ he.isEmbedding\n  obtain ‚ü®g, hg‚ü© := (f.comp e'.symm).exists_restrict_eq he.isClosed_range\n  exact ‚ü®g, by ext x; simpa using congr($(hg) ‚ü®e' x, x, rfl‚ü©)‚ü©\n\n"}
{"name":"ContinuousMap.exists_extension'","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X‚ÇÅ : Type u‚ÇÅ\ninst‚úù‚Å¥ : TopologicalSpace X‚ÇÅ\nX : Type u\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : NormalSpace X\ne : X‚ÇÅ ‚Üí X\nY : Type v\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TietzeExtension Y\nhe : Topology.IsClosedEmbedding e\nf : ContinuousMap X‚ÇÅ Y\n‚ä¢ Exists fun g => Eq (Function.comp (‚áëg) e) ‚áëf","decl":"/-- **Tietze extension theorem** for `TietzeExtension` spaces. Let `e` be a closed embedding of a\nnonempty topological space `X‚ÇÅ` into a normal topological space `X`. Let `f` be a continuous\nfunction on `X‚ÇÅ` with values in a `TietzeExtension` space `Y`. Then there exists a\ncontinuous function `g : C(X, Y)` such that `g ‚àò e = f`.\n\nThis version is provided for convenience and backwards compatibility. Here the composition is\nphrased in terms of bare functions. -/\ntheorem ContinuousMap.exists_extension' (he : IsClosedEmbedding e) (f : C(X‚ÇÅ, Y)) :\n    ‚àÉ (g : C(X, Y)), g ‚àò e = f :=\n  f.exists_extension he |>.imp fun g hg ‚Ü¶ by ext x; congrm($(hg) x)\n\n"}
{"name":"ContinuousMap.exists_forall_mem_restrict_eq","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : NormalSpace X\ns : Set X\nhs : IsClosed s\nY : Type v\ninst‚úù : TopologicalSpace Y\nf : ContinuousMap (‚Üës) Y\nt : Set Y\nhf : ‚àÄ (x : ‚Üës), Membership.mem t (f x)\nht : TietzeExtension ‚Üët\n‚ä¢ Exists fun g => And (‚àÄ (x : X), Membership.mem t (g x)) (Eq (ContinuousMap.restrict s g) f)","decl":"/-- This theorem is not intended to be used directly because it is rare for a set alone to\nsatisfy `[TietzeExtension t]`. For example, `Metric.ball` in `‚Ñù` only satisfies it when\nthe radius is strictly positive, so finding this as an instance will fail.\n\nInstead, it is intended to be used as a constructor for theorems about sets which *do* satisfy\n`[TietzeExtension t]` under some hypotheses. -/\ntheorem ContinuousMap.exists_forall_mem_restrict_eq (hs : IsClosed s)\n    {Y : Type v} [TopologicalSpace Y] (f : C(s, Y))\n    {t : Set Y} (hf : ‚àÄ x, f x ‚àà t) [ht : TietzeExtension.{u, v} t] :\n    ‚àÉ (g : C(X, Y)), (‚àÄ x, g x ‚àà t) ‚àß g.restrict s = f := by\n  obtain ‚ü®g, hg‚ü© := mk _ (map_continuous f |>.codRestrict hf) |>.exists_restrict_eq hs\n  exact ‚ü®comp ‚ü®Subtype.val, by continuity‚ü© g, by simp, by ext x; congrm(($(hg) x : Y))‚ü©\n\n"}
{"name":"ContinuousMap.exists_extension_forall_mem","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X‚ÇÅ : Type u‚ÇÅ\ninst‚úù¬≥ : TopologicalSpace X‚ÇÅ\nX : Type u\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : NormalSpace X\ne : X‚ÇÅ ‚Üí X\nhe : Topology.IsClosedEmbedding e\nY : Type v\ninst‚úù : TopologicalSpace Y\nf : ContinuousMap X‚ÇÅ Y\nt : Set Y\nhf : ‚àÄ (x : X‚ÇÅ), Membership.mem t (f x)\nht : TietzeExtension ‚Üët\n‚ä¢ Exists fun g => And (‚àÄ (x : X), Membership.mem t (g x)) (Eq (g.comp { toFun := e, continuous_toFun := ‚ãØ }) f)","decl":"/-- This theorem is not intended to be used directly because it is rare for a set alone to\nsatisfy `[TietzeExtension t]`. For example, `Metric.ball` in `‚Ñù` only satisfies it when\nthe radius is strictly positive, so finding this as an instance will fail.\n\nInstead, it is intended to be used as a constructor for theorems about sets which *do* satisfy\n`[TietzeExtension t]` under some hypotheses. -/\ntheorem ContinuousMap.exists_extension_forall_mem (he : IsClosedEmbedding e)\n    {Y : Type v} [TopologicalSpace Y] (f : C(X‚ÇÅ, Y))\n    {t : Set Y} (hf : ‚àÄ x, f x ‚àà t) [ht : TietzeExtension.{u, v} t] :\n    ‚àÉ (g : C(X, Y)), (‚àÄ x, g x ‚àà t) ‚àß g.comp ‚ü®e, he.continuous‚ü© = f := by\n  obtain ‚ü®g, hg‚ü© := mk _ (map_continuous f |>.codRestrict hf) |>.exists_extension he\n  exact ‚ü®comp ‚ü®Subtype.val, by continuity‚ü© g, by simp, by ext x; congrm(($(hg) x : Y))‚ü©\n\n"}
{"name":"Pi.instTietzeExtension","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Œπ : Type u_1\nY : Œπ ‚Üí Type v\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (Y i)\ninst‚úù : ‚àÄ (i : Œπ), TietzeExtension (Y i)\n‚ä¢ TietzeExtension ((i : Œπ) ‚Üí Y i)","decl":"instance Pi.instTietzeExtension {Œπ : Type*} {Y : Œπ ‚Üí Type v} [‚àÄ i, TopologicalSpace (Y i)]\n    [‚àÄ i, TietzeExtension.{u} (Y i)] : TietzeExtension.{u} (‚àÄ i, Y i) where\n  exists_restrict_eq' s hs f := by\n    obtain ‚ü®g', hg'‚ü© := Classical.skolem.mp <| fun i ‚Ü¶\n      ContinuousMap.exists_restrict_eq hs (ContinuousMap.piEquiv _ _ |>.symm f i)\n    exact ‚ü®ContinuousMap.piEquiv _ _ g', by ext x i; congrm($(hg' i) x)‚ü©\n\n"}
{"name":"Prod.instTietzeExtension","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type v\nZ : Type w\ninst‚úù¬≥ : TopologicalSpace Y\ninst‚úù¬≤ : TietzeExtension Y\ninst‚úù¬π : TopologicalSpace Z\ninst‚úù : TietzeExtension Z\n‚ä¢ TietzeExtension (Prod Y Z)","decl":"instance Prod.instTietzeExtension {Y : Type v} {Z : Type w} [TopologicalSpace Y]\n    [TietzeExtension.{u, v} Y] [TopologicalSpace Z] [TietzeExtension.{u, w} Z] :\n    TietzeExtension.{u, max w v} (Y √ó Z) where\n  exists_restrict_eq' s hs f := by\n    obtain ‚ü®g‚ÇÅ, hg‚ÇÅ‚ü© := (ContinuousMap.fst.comp f).exists_restrict_eq hs\n    obtain ‚ü®g‚ÇÇ, hg‚ÇÇ‚ü© := (ContinuousMap.snd.comp f).exists_restrict_eq hs\n    exact ‚ü®g‚ÇÅ.prodMk g‚ÇÇ, by ext1 x; congrm(($(hg‚ÇÅ) x), $(hg‚ÇÇ) x)‚ü©\n\n"}
{"name":"Unique.instTietzeExtension","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type v\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : Nonempty Y\ninst‚úù : Subsingleton Y\n‚ä¢ TietzeExtension Y","decl":"instance Unique.instTietzeExtension {Y : Type v} [TopologicalSpace Y]\n    [Nonempty Y] [Subsingleton Y] : TietzeExtension.{u, v} Y where\n  exists_restrict_eq' _ _ f := ‚ÄπNonempty Y‚Ä∫.elim fun y ‚Ü¶ ‚ü®.const _ y, by ext; subsingleton‚ü©\n\n"}
{"name":"TietzeExtension.of_retract","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type v\nZ : Type w\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace Z\ninst‚úù : TietzeExtension Z\nŒπ : ContinuousMap Y Z\nr : ContinuousMap Z Y\nh : Eq (r.comp Œπ) (ContinuousMap.id Y)\n‚ä¢ TietzeExtension Y","decl":"/-- Any retract of a `TietzeExtension` space is one itself. -/\ntheorem TietzeExtension.of_retract {Y : Type v} {Z : Type w} [TopologicalSpace Y]\n    [TopologicalSpace Z] [TietzeExtension.{u, w} Z] (Œπ : C(Y, Z)) (r : C(Z, Y))\n    (h : r.comp Œπ = .id Y) : TietzeExtension.{u, v} Y where\n  exists_restrict_eq' s hs f := by\n    obtain ‚ü®g, hg‚ü© := (Œπ.comp f).exists_restrict_eq hs\n    use r.comp g\n    ext1 x\n    have := congr(r.comp $(hg))\n    rw [‚Üê r.comp_assoc Œπ, h, f.id_comp] at this\n    congrm($this x)\n\n"}
{"name":"TietzeExtension.of_homeo","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type v\nZ : Type w\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace Z\ninst‚úù : TietzeExtension Z\ne : Homeomorph Y Z\n‚ä¢ TietzeExtension Y","decl":"/-- Any homeomorphism from a `TietzeExtension` space is one itself. -/\ntheorem TietzeExtension.of_homeo {Y : Type v} {Z : Type w} [TopologicalSpace Y]\n    [TopologicalSpace Z] [TietzeExtension.{u, w} Z] (e : Y ‚âÉ‚Çú Z) :\n    TietzeExtension.{u, v} Y :=\n  .of_retract (e : C(Y, Z)) (e.symm : C(Z, Y)) <| by simp\n\n"}
{"name":"BoundedContinuousFunction.tietze_extension_step","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\nf : BoundedContinuousFunction X Real\ne : ContinuousMap X Y\nhe : Topology.IsClosedEmbedding ‚áëe\n‚ä¢ Exists fun g => And (LE.le (Norm.norm g) (HDiv.hDiv (Norm.norm f) 3)) (LE.le (Dist.dist (g.compContinuous e) f) (HMul.hMul (2 / 3) (Norm.norm f)))","decl":"/-- One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\nof a topological space into a normal topological space and `f : X ‚Üí·µá ‚Ñù` is a bounded continuous\nfunction, then there exists a bounded continuous function `g : Y ‚Üí·µá ‚Ñù` of the norm `‚Äñg‚Äñ ‚â§ ‚Äñf‚Äñ / 3`\nsuch that the distance between `g ‚àò e` and `f` is at most `(2 / 3) * ‚Äñf‚Äñ`. -/\ntheorem tietze_extension_step (f : X ‚Üí·µá ‚Ñù) (e : C(X, Y)) (he : IsClosedEmbedding e) :\n    ‚àÉ g : Y ‚Üí·µá ‚Ñù, ‚Äñg‚Äñ ‚â§ ‚Äñf‚Äñ / 3 ‚àß dist (g.compContinuous e) f ‚â§ 2 / 3 * ‚Äñf‚Äñ := by\n  have h3 : (0 : ‚Ñù) < 3 := by norm_num1\n  have h23 : 0 < (2 / 3 : ‚Ñù) := by norm_num1\n  -- In the trivial case `f = 0`, we take `g = 0`\n  rcases eq_or_ne f 0 with (rfl | hf)\n  ¬∑ use 0\n    simp\n  replace hf : 0 < ‚Äñf‚Äñ := norm_pos_iff.2 hf\n  /- Otherwise, the closed sets `e '' (f ‚Åª¬π' (Iic (-‚Äñf‚Äñ / 3)))` and `e '' (f ‚Åª¬π' (Ici (‚Äñf‚Äñ / 3)))`\n    are disjoint, hence by Urysohn's lemma there exists a function `g` that is equal to `-‚Äñf‚Äñ / 3`\n    on the former set and is equal to `‚Äñf‚Äñ / 3` on the latter set. This function `g` satisfies the\n    assertions of the lemma. -/\n  have hf3 : -‚Äñf‚Äñ / 3 < ‚Äñf‚Äñ / 3 := (div_lt_div_iff_of_pos_right h3).2 (Left.neg_lt_self hf)\n  have hc‚ÇÅ : IsClosed (e '' (f ‚Åª¬π' Iic (-‚Äñf‚Äñ / 3))) :=\n    he.isClosedMap _ (isClosed_Iic.preimage f.continuous)\n  have hc‚ÇÇ : IsClosed (e '' (f ‚Åª¬π' Ici (‚Äñf‚Äñ / 3))) :=\n    he.isClosedMap _ (isClosed_Ici.preimage f.continuous)\n  have hd : Disjoint (e '' (f ‚Åª¬π' Iic (-‚Äñf‚Äñ / 3))) (e '' (f ‚Åª¬π' Ici (‚Äñf‚Äñ / 3))) := by\n    refine disjoint_image_of_injective he.injective (Disjoint.preimage _ ?_)\n    rwa [Iic_disjoint_Ici, not_le]\n  rcases exists_bounded_mem_Icc_of_closed_of_le hc‚ÇÅ hc‚ÇÇ hd hf3.le with ‚ü®g, hg‚ÇÅ, hg‚ÇÇ, hgf‚ü©\n  refine ‚ü®g, ?_, ?_‚ü©\n  ¬∑ refine (norm_le <| div_nonneg hf.le h3.le).mpr fun y => ?_\n    simpa [abs_le, neg_div] using hgf y\n  ¬∑ refine (dist_le <| mul_nonneg h23.le hf.le).mpr fun x => ?_\n    have hfx : -‚Äñf‚Äñ ‚â§ f x ‚àß f x ‚â§ ‚Äñf‚Äñ := by\n      simpa only [Real.norm_eq_abs, abs_le] using f.norm_coe_le_norm x\n    rcases le_total (f x) (-‚Äñf‚Äñ / 3) with hle‚ÇÅ | hle‚ÇÅ\n    ¬∑ calc\n        |g (e x) - f x| = -‚Äñf‚Äñ / 3 - f x := by\n          rw [hg‚ÇÅ (mem_image_of_mem _ hle‚ÇÅ), Function.const_apply,\n            abs_of_nonneg (sub_nonneg.2 hle‚ÇÅ)]\n        _ ‚â§ 2 / 3 * ‚Äñf‚Äñ := by linarith\n    ¬∑ rcases le_total (f x) (‚Äñf‚Äñ / 3) with hle‚ÇÇ | hle‚ÇÇ\n      ¬∑ simp only [neg_div] at *\n        calc\n          dist (g (e x)) (f x) ‚â§ |g (e x)| + |f x| := dist_le_norm_add_norm _ _\n          _ ‚â§ ‚Äñf‚Äñ / 3 + ‚Äñf‚Äñ / 3 := (add_le_add (abs_le.2 <| hgf _) (abs_le.2 ‚ü®hle‚ÇÅ, hle‚ÇÇ‚ü©))\n          _ = 2 / 3 * ‚Äñf‚Äñ := by linarith\n      ¬∑ calc\n          |g (e x) - f x| = f x - ‚Äñf‚Äñ / 3 := by\n            rw [hg‚ÇÇ (mem_image_of_mem _ hle‚ÇÇ), abs_sub_comm, Function.const_apply,\n              abs_of_nonneg (sub_nonneg.2 hle‚ÇÇ)]\n          _ ‚â§ 2 / 3 * ‚Äñf‚Äñ := by linarith\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_norm_eq_of_isClosedEmbedding'","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\nf : BoundedContinuousFunction X Real\ne : ContinuousMap X Y\nhe : Topology.IsClosedEmbedding ‚áëe\n‚ä¢ Exists fun g => And (Eq (Norm.norm g) (Norm.norm f)) (Eq (g.compContinuous e) f)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X ‚Üí·µá ‚Ñù` is a bounded continuous function, then there exists\na bounded continuous function `g : Y ‚Üí·µá ‚Ñù` of the same norm such that `g ‚àò e = f`. -/\ntheorem exists_extension_norm_eq_of_isClosedEmbedding' (f : X ‚Üí·µá ‚Ñù) (e : C(X, Y))\n    (he : IsClosedEmbedding e) : ‚àÉ g : Y ‚Üí·µá ‚Ñù, ‚Äñg‚Äñ = ‚Äñf‚Äñ ‚àß g.compContinuous e = f := by\n  /- For the proof, we iterate `tietze_extension_step`. Each time we apply it to the difference\n    between the previous approximation and `f`. -/\n  choose F hF_norm hF_dist using fun f : X ‚Üí·µá ‚Ñù => tietze_extension_step f e he\n  set g : ‚Ñï ‚Üí Y ‚Üí·µá ‚Ñù := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0\n  have g0 : g 0 = 0 := rfl\n  have g_succ : ‚àÄ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>\n    Function.iterate_succ_apply' _ _ _\n  have hgf : ‚àÄ n, dist ((g n).compContinuous e) f ‚â§ (2 / 3) ^ n * ‚Äñf‚Äñ := by\n    intro n\n    induction n with\n    | zero => simp [g0]\n    | succ n ihn =>\n      rw [g_succ n, add_compContinuous, ‚Üê dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]\n      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))\n      rwa [‚Üê dist_eq_norm']\n  have hg_dist : ‚àÄ n, dist (g n) (g (n + 1)) ‚â§ 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by\n    intro n\n    calc\n      dist (g n) (g (n + 1)) = ‚ÄñF (f - (g n).compContinuous e)‚Äñ := by\n        rw [g_succ, dist_eq_norm', add_sub_cancel_left]\n      _ ‚â§ ‚Äñf - (g n).compContinuous e‚Äñ / 3 := hF_norm _\n      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]\n      _ ‚â§ 1 / 3 * ((2 / 3) ^ n * ‚Äñf‚Äñ) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)\n      _ = 1 / 3 * ‚Äñf‚Äñ * (2 / 3) ^ n := by ac_rfl\n  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist\n  have :\n    Tendsto (fun n => (g n).compContinuous e) atTop\n      (ùìù <| (limUnder atTop g).compContinuous e) :=\n    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder\n  have hge : (limUnder atTop g).compContinuous e = f := by\n    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)\n    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_\n    rw [‚Üê zero_mul ‚Äñf‚Äñ]\n    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1\n  refine ‚ü®limUnder atTop g, le_antisymm ?_ ?_, hge‚ü©\n  ¬∑ rw [‚Üê dist_zero_left, ‚Üê g0]\n    refine\n      (dist_le_of_le_geometric_of_tendsto‚ÇÄ _ _ (by norm_num1)\n        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_\n    field_simp [show (3 - 2 : ‚Ñù) = 1 by norm_num1]\n  ¬∑ rw [‚Üê hge]\n    exact norm_compContinuous_le _ _\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding'","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\nf : BoundedContinuousFunction X Real\ne : ContinuousMap X Y\nhe : Topology.IsClosedEmbedding ‚áëe\n‚ä¢ Exists fun g => And (Eq (Norm.norm g) (Norm.norm f)) (Eq (g.compContinuous e) f)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_norm_eq_of_closedEmbedding' := exists_extension_norm_eq_of_isClosedEmbedding'\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_norm_eq_of_isClosedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\nf : BoundedContinuousFunction X Real\ne : X ‚Üí Y\nhe : Topology.IsClosedEmbedding e\n‚ä¢ Exists fun g => And (Eq (Norm.norm g) (Norm.norm f)) (Eq (Function.comp (‚áëg) e) ‚áëf)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and unbundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X ‚Üí·µá ‚Ñù` is a bounded continuous function, then there exists\na bounded continuous function `g : Y ‚Üí·µá ‚Ñù` of the same norm such that `g ‚àò e = f`. -/\ntheorem exists_extension_norm_eq_of_isClosedEmbedding (f : X ‚Üí·µá ‚Ñù) {e : X ‚Üí Y}\n    (he : IsClosedEmbedding e) : ‚àÉ g : Y ‚Üí·µá ‚Ñù, ‚Äñg‚Äñ = ‚Äñf‚Äñ ‚àß g ‚àò e = f := by\n  rcases exists_extension_norm_eq_of_isClosedEmbedding' f ‚ü®e, he.continuous‚ü© he with ‚ü®g, hg, rfl‚ü©\n  exact ‚ü®g, hg, rfl‚ü©\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\nf : BoundedContinuousFunction X Real\ne : X ‚Üí Y\nhe : Topology.IsClosedEmbedding e\n‚ä¢ Exists fun g => And (Eq (Norm.norm g) (Norm.norm f)) (Eq (Function.comp (‚áëg) e) ‚áëf)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_norm_eq_of_closedEmbedding := exists_extension_norm_eq_of_isClosedEmbedding\n\n"}
{"name":"BoundedContinuousFunction.exists_norm_eq_restrict_eq_of_closed","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type u_2\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\ns : Set Y\nf : BoundedContinuousFunction (‚Üës) Real\nhs : IsClosed s\n‚ä¢ Exists fun g => And (Eq (Norm.norm g) (Norm.norm f)) (Eq (g.restrict s) f)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nset. If `f` is a bounded continuous real-valued function defined on a closed set in a normal\ntopological space, then it can be extended to a bounded continuous function of the same norm defined\non the whole space. -/\ntheorem exists_norm_eq_restrict_eq_of_closed {s : Set Y} (f : s ‚Üí·µá ‚Ñù) (hs : IsClosed s) :\n    ‚àÉ g : Y ‚Üí·µá ‚Ñù, ‚Äñg‚Äñ = ‚Äñf‚Äñ ‚àß g.restrict s = f :=\n  exists_extension_norm_eq_of_isClosedEmbedding' f ((ContinuousMap.id _).restrict s)\n    hs.isClosedEmbedding_subtypeVal\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_forall_mem_Icc_of_isClosedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\nf : BoundedContinuousFunction X Real\na b : Real\ne : X ‚Üí Y\nhf : ‚àÄ (x : X), Membership.mem (Set.Icc a b) (f x)\nhle : LE.le a b\nhe : Topology.IsClosedEmbedding e\n‚ä¢ Exists fun g => And (‚àÄ (y : Y), Membership.mem (Set.Icc a b) (g y)) (Eq (Function.comp (‚áëg) e) ‚áëf)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nembedding and a bounded continuous function that takes values in a non-trivial closed interval.\nSee also `exists_extension_forall_mem_of_isClosedEmbedding` for a more general statement that works\nfor any interval (finite or infinite, open or closed).\n\nIf `e : X ‚Üí Y` is a closed embedding and `f : X ‚Üí·µá ‚Ñù` is a bounded continuous function such that\n`f x ‚àà [a, b]` for all `x`, where `a ‚â§ b`, then there exists a bounded continuous function\n`g : Y ‚Üí·µá ‚Ñù` such that `g y ‚àà [a, b]` for all `y` and `g ‚àò e = f`. -/\ntheorem exists_extension_forall_mem_Icc_of_isClosedEmbedding (f : X ‚Üí·µá ‚Ñù) {a b : ‚Ñù} {e : X ‚Üí Y}\n    (hf : ‚àÄ x, f x ‚àà Icc a b) (hle : a ‚â§ b) (he : IsClosedEmbedding e) :\n    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, g y ‚àà Icc a b) ‚àß g ‚àò e = f := by\n  rcases exists_extension_norm_eq_of_isClosedEmbedding (f - const X ((a + b) / 2)) he with\n    ‚ü®g, hgf, hge‚ü©\n  refine ‚ü®const Y ((a + b) / 2) + g, fun y => ?_, ?_‚ü©\n  ¬∑ suffices ‚Äñf - const X ((a + b) / 2)‚Äñ ‚â§ (b - a) / 2 by\n      simpa [Real.Icc_eq_closedBall, add_mem_closedBall_iff_norm] using\n        (norm_coe_le_norm g y).trans (hgf.trans_le this)\n    refine (norm_le <| div_nonneg (sub_nonneg.2 hle) zero_le_two).2 fun x => ?_\n    simpa only [Real.Icc_eq_closedBall] using hf x\n  ¬∑ ext x\n    have : g (e x) = f x - (a + b) / 2 := congr_fun hge x\n    simp [this]\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_forall_mem_Icc_of_closedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\nf : BoundedContinuousFunction X Real\na b : Real\ne : X ‚Üí Y\nhf : ‚àÄ (x : X), Membership.mem (Set.Icc a b) (f x)\nhle : LE.le a b\nhe : Topology.IsClosedEmbedding e\n‚ä¢ Exists fun g => And (‚àÄ (y : Y), Membership.mem (Set.Icc a b) (g y)) (Eq (Function.comp (‚áëg) e) ‚áëf)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_forall_mem_Icc_of_closedEmbedding :=\n  exists_extension_forall_mem_Icc_of_isClosedEmbedding\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_isClosedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : NormalSpace Y\ninst‚úù : Nonempty X\nf : BoundedContinuousFunction X Real\ne : X ‚Üí Y\nhe : Topology.IsClosedEmbedding e\n‚ä¢ Exists fun g => And (‚àÄ (y : Y), Exists fun x‚ÇÅ => Exists fun x‚ÇÇ => Membership.mem (Set.Icc (f x‚ÇÅ) (f x‚ÇÇ)) (g y)) (Eq (Function.comp (‚áëg) e) ‚áëf)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a bounded continuous real-valued function on `X`. Then there\nexists a bounded continuous function `g : Y ‚Üí·µá ‚Ñù` such that `g ‚àò e = f` and each value `g y` belongs\nto a closed interval `[f x‚ÇÅ, f x‚ÇÇ]` for some `x‚ÇÅ` and `x‚ÇÇ`. -/\ntheorem exists_extension_forall_exists_le_ge_of_isClosedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)\n    {e : X ‚Üí Y} (he : IsClosedEmbedding e) :\n    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f := by\n  inhabit X\n  -- Put `a = ‚®Ö x, f x` and `b = ‚®Ü x, f x`\n  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©\n  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©\n  -- Then `f x ‚àà [a, b]` for all `x`\n  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©\n  -- Rule out the trivial case `a = b`\n  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2\n  rcases hle.eq_or_lt with (rfl | hlt)\n  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem\n    use const Y a\n    simp [this, funext_iff]\n  -- Put `c = (a + b) / 2`. Then `a < c < b` and `c - a = b - c`.\n  set c := (a + b) / 2\n  have hac : a < c := left_lt_add_div_two.2 hlt\n  have hcb : c < b := add_div_two_lt_right.2 hlt\n  have hsub : c - a = b - c := by\n    field_simp [c]\n    ring\n  /- Due to `exists_extension_forall_mem_Icc_of_isClosedEmbedding`, there exists an extension `g`\n    such that `g y ‚àà [a, b]` for all `y`. However, if `a` and/or `b` do not belong to the range of\n    `f`, then we need to ensure that these points do not belong to the range of `g`. This is done\n    in two almost identical steps. First we deal with the case `‚àÄ x, f x ‚â† a`. -/\n  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by\n    rcases exists_extension_forall_mem_Icc_of_isClosedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©\n    -- If `a ‚àà range f`, then we are done.\n    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')\n    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©\n    /- Otherwise, `g ‚Åª¬π' {a}` is disjoint with `range e ‚à™ g ‚Åª¬π' (Ici c)`, hence there exists a\n        function `dg : Y ‚Üí ‚Ñù` such that `dg ‚àò e = 0`, `dg y = 0` whenever `c ‚â§ g y`, `dg y = c - a`\n        whenever `g y = a`, and `0 ‚â§ dg y ‚â§ c - a` for all `y`. -/\n    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by\n      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©\n      ¬∑ rw [Set.disjoint_left]\n        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)\n        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©\n      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le\n    rcases exists_bounded_mem_Icc_of_closed_of_le\n        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)\n        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with\n      ‚ü®dg, dg0, dga, dgmem‚ü©\n    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by\n      intro x\n      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]\n    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©\n    have hay : a < (g + dg) y := by\n      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)\n      ¬∑ refine (lt_add_iff_pos_right _).2 ?_\n        calc\n          0 < c - g y := sub_pos.2 hac\n          _ = dg y := (dga rfl).symm\n      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)\n    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©\n    refine ‚ü®x, hxy.le, ?_‚ü©\n    rcases le_total c (g y) with hc | hc\n    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]\n    ¬∑ calc\n        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2\n        _ = b := by rw [hsub, add_sub_cancel]\n  /- Now we deal with the case `‚àÄ x, f x ‚â† b`. The proof is the same as in the first case, with\n    minor modifications that make it hard to deduplicate code. -/\n  choose xl hxl hgb using hg_mem\n  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')\n  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©\n  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by\n    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©\n    ¬∑ rw [Set.disjoint_left]\n      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)\n      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©\n    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le\n  rcases exists_bounded_mem_Icc_of_closed_of_le\n      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)\n      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with\n    ‚ü®dg, dg0, dgb, dgmem‚ü©\n  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by\n    intro x\n    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]\n  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©\n  have hyb : (g - dg) y < b := by\n    rcases (hgb y).eq_or_lt with (rfl | hlt)\n    ¬∑ refine (sub_lt_self_iff _).2 ?_\n      calc\n        0 < g y - c := sub_pos.2 hcb\n        _ = dg y := (dgb rfl).symm\n    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt\n  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©\n  cases' lt_or_le c (g y) with hc hc\n  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)\n    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©\n      calc\n        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]\n        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2\n    ¬∑ have hay : a < (g - dg) y := by\n        calc\n          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]\n          _ < g y - (b - c) := sub_lt_sub_right hc _\n          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _\n      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©\n      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©\n  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©\n    simp [dg0 (Or.inr hc), hxl]\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : NormalSpace Y\ninst‚úù : Nonempty X\nf : BoundedContinuousFunction X Real\ne : X ‚Üí Y\nhe : Topology.IsClosedEmbedding e\n‚ä¢ Exists fun g => And (‚àÄ (y : Y), Exists fun x‚ÇÅ => Exists fun x‚ÇÇ => Membership.mem (Set.Icc (f x‚ÇÅ) (f x‚ÇÇ)) (g y)) (Eq (Function.comp (‚áëg) e) ‚áëf)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_forall_exists_le_ge_of_closedEmbedding :=\n  exists_extension_forall_exists_le_ge_of_isClosedEmbedding\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_forall_mem_of_isClosedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\nf : BoundedContinuousFunction X Real\nt : Set Real\ne : X ‚Üí Y\nhs : t.OrdConnected\nhf : ‚àÄ (x : X), Membership.mem t (f x)\nhne : t.Nonempty\nhe : Topology.IsClosedEmbedding e\n‚ä¢ Exists fun g => And (‚àÄ (y : Y), Membership.mem t (g y)) (Eq (Function.comp (‚áëg) e) ‚áëf)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a bounded continuous real-valued function on `X`. Let `t` be\na nonempty convex set of real numbers (we use `OrdConnected` instead of `Convex` to automatically\ndeduce this argument by typeclass search) such that `f x ‚àà t` for all `x`. Then there exists\na bounded continuous real-valued function `g : Y ‚Üí·µá ‚Ñù` such that `g y ‚àà t` for all `y` and\n`g ‚àò e = f`. -/\ntheorem exists_extension_forall_mem_of_isClosedEmbedding (f : X ‚Üí·µá ‚Ñù) {t : Set ‚Ñù} {e : X ‚Üí Y}\n    [hs : OrdConnected t] (hf : ‚àÄ x, f x ‚àà t) (hne : t.Nonempty) (he : IsClosedEmbedding e) :\n    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, g y ‚àà t) ‚àß g ‚àò e = f := by\n  cases isEmpty_or_nonempty X\n  ¬∑ rcases hne with ‚ü®c, hc‚ü©\n    exact ‚ü®const Y c, fun _ => hc, funext fun x => isEmptyElim x‚ü©\n  rcases exists_extension_forall_exists_le_ge_of_isClosedEmbedding f he with ‚ü®g, hg, hgf‚ü©\n  refine ‚ü®g, fun y => ?_, hgf‚ü©\n  rcases hg y with ‚ü®xl, xu, h‚ü©\n  exact hs.out (hf _) (hf _) h\n\n"}
{"name":"BoundedContinuousFunction.exists_extension_forall_mem_of_closedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\nf : BoundedContinuousFunction X Real\nt : Set Real\ne : X ‚Üí Y\nhs : t.OrdConnected\nhf : ‚àÄ (x : X), Membership.mem t (f x)\nhne : t.Nonempty\nhe : Topology.IsClosedEmbedding e\n‚ä¢ Exists fun g => And (‚àÄ (y : Y), Membership.mem t (g y)) (Eq (Function.comp (‚áëg) e) ‚áëf)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_forall_mem_of_closedEmbedding :=\n  exists_extension_forall_mem_of_isClosedEmbedding\n\n"}
{"name":"BoundedContinuousFunction.exists_forall_mem_restrict_eq_of_closed","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type u_2\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : NormalSpace Y\ns : Set Y\nf : BoundedContinuousFunction (‚Üës) Real\nhs : IsClosed s\nt : Set Real\ninst‚úù : t.OrdConnected\nhf : ‚àÄ (x : ‚Üës), Membership.mem t (f x)\nhne : t.Nonempty\n‚ä¢ Exists fun g => And (‚àÄ (y : Y), Membership.mem t (g y)) (Eq (g.restrict s) f)","decl":"/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nset. Let `s` be a closed set in a normal topological space `Y`. Let `f` be a bounded continuous\nreal-valued function on `s`. Let `t` be a nonempty convex set of real numbers (we use\n`OrdConnected` instead of `Convex` to automatically deduce this argument by typeclass search) such\nthat `f x ‚àà t` for all `x : s`. Then there exists a bounded continuous real-valued function\n`g : Y ‚Üí·µá ‚Ñù` such that `g y ‚àà t` for all `y` and `g.restrict s = f`. -/\ntheorem exists_forall_mem_restrict_eq_of_closed {s : Set Y} (f : s ‚Üí·µá ‚Ñù) (hs : IsClosed s)\n    {t : Set ‚Ñù} [OrdConnected t] (hf : ‚àÄ x, f x ‚àà t) (hne : t.Nonempty) :\n    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, g y ‚àà t) ‚àß g.restrict s = f := by\n  obtain ‚ü®g, hg, hgf‚ü© :=\n    exists_extension_forall_mem_of_isClosedEmbedding f hf hne hs.isClosedEmbedding_subtypeVal\n  exact ‚ü®g, hg, DFunLike.coe_injective hgf‚ü©\n\n"}
{"name":"ContinuousMap.exists_extension_forall_mem_of_isClosedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\nf : ContinuousMap X Real\nt : Set Real\ne : X ‚Üí Y\nhs : t.OrdConnected\nhf : ‚àÄ (x : X), Membership.mem t (f x)\nhne : t.Nonempty\nhe : Topology.IsClosedEmbedding e\n‚ä¢ Exists fun g => And (‚àÄ (y : Y), Membership.mem t (g y)) (Eq (Function.comp (‚áëg) e) ‚áëf)","decl":"/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Let `t` be a nonempty\nconvex set of real numbers (we use `OrdConnected` instead of `Convex` to automatically deduce this\nargument by typeclass search) such that `f x ‚àà t` for all `x`. Then there exists a continuous\nreal-valued function `g : C(Y, ‚Ñù)` such that `g y ‚àà t` for all `y` and `g ‚àò e = f`. -/\ntheorem exists_extension_forall_mem_of_isClosedEmbedding (f : C(X, ‚Ñù)) {t : Set ‚Ñù} {e : X ‚Üí Y}\n    [hs : OrdConnected t] (hf : ‚àÄ x, f x ‚àà t) (hne : t.Nonempty) (he : IsClosedEmbedding e) :\n    ‚àÉ g : C(Y, ‚Ñù), (‚àÄ y, g y ‚àà t) ‚àß g ‚àò e = f := by\n  have h : ‚Ñù ‚âÉo Ioo (-1 : ‚Ñù) 1 := orderIsoIooNegOneOne ‚Ñù\n  let F : X ‚Üí·µá ‚Ñù :=\n    { toFun := (‚Üë) ‚àò h ‚àò f\n      continuous_toFun := continuous_subtype_val.comp (h.continuous.comp f.continuous)\n      map_bounded' := isBounded_range_iff.1\n        ((isBounded_Ioo (-1 : ‚Ñù) 1).subset <| range_subset_iff.2 fun x => (h (f x)).2) }\n  let t' : Set ‚Ñù := (‚Üë) ‚àò h '' t\n  have ht_sub : t' ‚äÜ Ioo (-1 : ‚Ñù) 1 := image_subset_iff.2 fun x _ => (h x).2\n  have : OrdConnected t' := by\n    constructor\n    rintro _ ‚ü®x, hx, rfl‚ü© _ ‚ü®y, hy, rfl‚ü© z hz\n    lift z to Ioo (-1 : ‚Ñù) 1 using Icc_subset_Ioo (h x).2.1 (h y).2.2 hz\n    change z ‚àà Icc (h x) (h y) at hz\n    rw [‚Üê h.image_Icc] at hz\n    rcases hz with ‚ü®z, hz, rfl‚ü©\n    exact ‚ü®z, hs.out hx hy hz, rfl‚ü©\n  have hFt : ‚àÄ x, F x ‚àà t' := fun x => mem_image_of_mem _ (hf x)\n  rcases F.exists_extension_forall_mem_of_isClosedEmbedding hFt (hne.image _) he with ‚ü®G, hG, hGF‚ü©\n  let g : C(Y, ‚Ñù) :=\n    ‚ü®h.symm ‚àò codRestrict G _ fun y => ht_sub (hG y),\n      h.symm.continuous.comp <| G.continuous.subtype_mk _‚ü©\n  have hgG : ‚àÄ {y a}, g y = a ‚Üî G y = h a := @fun y a =>\n    h.toEquiv.symm_apply_eq.trans Subtype.ext_iff\n  refine ‚ü®g, fun y => ?_, ?_‚ü©\n  ¬∑ rcases hG y with ‚ü®a, ha, hay‚ü©\n    convert ha\n    exact hgG.2 hay.symm\n  ¬∑ ext x\n    exact hgG.2 (congr_fun hGF _)\n\n"}
{"name":"ContinuousMap.exists_extension_forall_mem_of_closedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\nf : ContinuousMap X Real\nt : Set Real\ne : X ‚Üí Y\nhs : t.OrdConnected\nhf : ‚àÄ (x : X), Membership.mem t (f x)\nhne : t.Nonempty\nhe : Topology.IsClosedEmbedding e\n‚ä¢ Exists fun g => And (‚àÄ (y : Y), Membership.mem t (g y)) (Eq (Function.comp (‚áëg) e) ‚áëf)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_forall_mem_of_closedEmbedding :=\n  exists_extension_forall_mem_of_isClosedEmbedding\n\n"}
{"name":"ContinuousMap.exists_extension_of_closedEmbedding","module":"Mathlib.Topology.TietzeExtension","initialProofState":"X‚ÇÅ : Type u‚ÇÅ\ninst‚úù‚Å¥ : TopologicalSpace X‚ÇÅ\nX : Type u\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : NormalSpace X\ne : X‚ÇÅ ‚Üí X\nY : Type v\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TietzeExtension Y\nhe : Topology.IsClosedEmbedding e\nf : ContinuousMap X‚ÇÅ Y\n‚ä¢ Exists fun g => Eq (Function.comp (‚áëg) e) ‚áëf","decl":"@[deprecated (since := \"2024-10-20\")]\nalias exists_extension_of_closedEmbedding := exists_extension'\n\n"}
{"name":"ContinuousMap.exists_restrict_eq_forall_mem_of_closed","module":"Mathlib.Topology.TietzeExtension","initialProofState":"Y : Type u_2\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : NormalSpace Y\ns : Set Y\nf : ContinuousMap (‚Üës) Real\nt : Set Real\ninst‚úù : t.OrdConnected\nht : ‚àÄ (x : ‚Üës), Membership.mem t (f x)\nhne : t.Nonempty\nhs : IsClosed s\n‚ä¢ Exists fun g => And (‚àÄ (y : Y), Membership.mem t (g y)) (Eq (ContinuousMap.restrict s g) f)","decl":"/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\non `s`. Let `t` be a nonempty convex set of real numbers (we use `OrdConnected` instead of `Convex`\nto automatically deduce this argument by typeclass search) such that `f x ‚àà t` for all `x : s`. Then\nthere exists a continuous real-valued function `g : C(Y, ‚Ñù)` such that `g y ‚àà t` for all `y` and\n`g.restrict s = f`. -/\ntheorem exists_restrict_eq_forall_mem_of_closed {s : Set Y} (f : C(s, ‚Ñù)) {t : Set ‚Ñù}\n    [OrdConnected t] (ht : ‚àÄ x, f x ‚àà t) (hne : t.Nonempty) (hs : IsClosed s) :\n    ‚àÉ g : C(Y, ‚Ñù), (‚àÄ y, g y ‚àà t) ‚àß g.restrict s = f :=\n  let ‚ü®g, hgt, hgf‚ü© :=\n    exists_extension_forall_mem_of_isClosedEmbedding f ht hne hs.isClosedEmbedding_subtypeVal\n  ‚ü®g, hgt, coe_injective hgf‚ü©\n\n"}
{"name":"Real.instTietzeExtension","module":"Mathlib.Topology.TietzeExtension","initialProofState":"‚ä¢ TietzeExtension Real","decl":"/-- **Tietze extension theorem** for real-valued continuous maps.\n`‚Ñù` is a `TietzeExtension` space. -/\ninstance Real.instTietzeExtension : TietzeExtension ‚Ñù where\n  exists_restrict_eq' _s hs f :=\n    f.exists_restrict_eq_forall_mem_of_closed (fun _ => mem_univ _) univ_nonempty hs |>.imp\n      fun _ ‚Ü¶ (And.right ¬∑)\n\n"}
{"name":"NNReal.instTietzeExtension","module":"Mathlib.Topology.TietzeExtension","initialProofState":"‚ä¢ TietzeExtension NNReal","decl":"open NNReal in\n/-- **Tietze extension theorem** for nonnegative real-valued continuous maps.\n`‚Ñù‚â•0` is a `TietzeExtension` space. -/\ninstance NNReal.instTietzeExtension : TietzeExtension ‚Ñù‚â•0 :=\n  .of_retract ‚ü®((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù), by continuity‚ü© ‚ü®Real.toNNReal, continuous_real_toNNReal‚ü© <| by\n    ext; simp\n"}
