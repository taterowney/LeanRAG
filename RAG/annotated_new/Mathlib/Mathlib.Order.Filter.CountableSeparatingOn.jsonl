{"name":"HasCountableSeparatingOn.exists_countable_separating","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\np : Set α → Prop\nt : Set α\nself : HasCountableSeparatingOn α p t\n⊢ Exists fun S => And S.Countable (And (∀ (s : Set α), Membership.mem S s → p s) (∀ (x : α), Membership.mem t x → ∀ (y : α), Membership.mem t y → (∀ (s : Set α), Membership.mem S s → Iff (Membership.mem s x) (Membership.mem s y)) → Eq x y))","decl":"/-- We say that a type `α` has a *countable separating family of sets* satisfying a predicate\n`p : Set α → Prop` on a set `t` if there exists a countable family of sets `S : Set (Set α)` such\nthat all sets `s ∈ S` satisfy `p` and any two distinct points `x y ∈ t`, `x ≠ y`, can be separated\nby `s ∈ S`: there exists `s ∈ S` such that exactly one of `x` and `y` belongs to `s`.\n\nE.g., if `α` is a `T₀` topological space with second countable topology, then it has a countable\nseparating family of open sets and a countable separating family of closed sets.\n-/\nclass HasCountableSeparatingOn (α : Type*) (p : Set α → Prop) (t : Set α) : Prop where\n  exists_countable_separating : ∃ S : Set (Set α), S.Countable ∧ (∀ s ∈ S, p s) ∧\n    ∀ x ∈ t, ∀ y ∈ t, (∀ s ∈ S, x ∈ s ↔ y ∈ s) → x = y\n\n"}
{"name":"exists_countable_separating","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\np : Set α → Prop\nt : Set α\nh : HasCountableSeparatingOn α p t\n⊢ Exists fun S => And S.Countable (And (∀ (s : Set α), Membership.mem S s → p s) (∀ (x : α), Membership.mem t x → ∀ (y : α), Membership.mem t y → (∀ (s : Set α), Membership.mem S s → Iff (Membership.mem s x) (Membership.mem s y)) → Eq x y))","decl":"theorem exists_countable_separating (α : Type*) (p : Set α → Prop) (t : Set α)\n    [h : HasCountableSeparatingOn α p t] :\n    ∃ S : Set (Set α), S.Countable ∧ (∀ s ∈ S, p s) ∧\n      ∀ x ∈ t, ∀ y ∈ t, (∀ s ∈ S, x ∈ s ↔ y ∈ s) → x = y :=\n  h.1\n\n"}
{"name":"exists_nonempty_countable_separating","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\np : Set α → Prop\ns₀ : Set α\nhp : p s₀\nt : Set α\ninst✝ : HasCountableSeparatingOn α p t\n⊢ Exists fun S => And S.Nonempty (And S.Countable (And (∀ (s : Set α), Membership.mem S s → p s) (∀ (x : α), Membership.mem t x → ∀ (y : α), Membership.mem t y → (∀ (s : Set α), Membership.mem S s → Iff (Membership.mem s x) (Membership.mem s y)) → Eq x y)))","decl":"theorem exists_nonempty_countable_separating (α : Type*) {p : Set α → Prop} {s₀} (hp : p s₀)\n    (t : Set α) [HasCountableSeparatingOn α p t] :\n    ∃ S : Set (Set α), S.Nonempty ∧ S.Countable ∧ (∀ s ∈ S, p s) ∧\n      ∀ x ∈ t, ∀ y ∈ t, (∀ s ∈ S, x ∈ s ↔ y ∈ s) → x = y :=\n  let ⟨S, hSc, hSp, hSt⟩ := exists_countable_separating α p t\n  ⟨insert s₀ S, insert_nonempty _ _, hSc.insert _, forall_insert_of_forall hSp hp,\n    fun x hx y hy hxy ↦ hSt x hx y hy <| forall_of_forall_insert hxy⟩\n\n"}
{"name":"exists_seq_separating","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\np : Set α → Prop\ns₀ : Set α\nhp : p s₀\nt : Set α\ninst✝ : HasCountableSeparatingOn α p t\n⊢ Exists fun S => And (∀ (n : Nat), p (S n)) (∀ (x : α), Membership.mem t x → ∀ (y : α), Membership.mem t y → (∀ (n : Nat), Iff (Membership.mem (S n) x) (Membership.mem (S n) y)) → Eq x y)","decl":"theorem exists_seq_separating (α : Type*) {p : Set α → Prop} {s₀} (hp : p s₀) (t : Set α)\n    [HasCountableSeparatingOn α p t] :\n    ∃ S : ℕ → Set α, (∀ n, p (S n)) ∧ ∀ x ∈ t, ∀ y ∈ t, (∀ n, x ∈ S n ↔ y ∈ S n) → x = y := by\n  rcases exists_nonempty_countable_separating α hp t with ⟨S, hSne, hSc, hS⟩\n  rcases hSc.exists_eq_range hSne with ⟨S, rfl⟩\n  use S\n  simpa only [forall_mem_range] using hS\n\n"}
{"name":"HasCountableSeparatingOn.mono","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\np₁ p₂ : Set α → Prop\nt₁ t₂ : Set α\nh : HasCountableSeparatingOn α p₁ t₁\nhp : ∀ (s : Set α), p₁ s → p₂ s\nht : HasSubset.Subset t₂ t₁\n⊢ HasCountableSeparatingOn α p₂ t₂","decl":"theorem HasCountableSeparatingOn.mono {α} {p₁ p₂ : Set α → Prop} {t₁ t₂ : Set α}\n    [h : HasCountableSeparatingOn α p₁ t₁] (hp : ∀ s, p₁ s → p₂ s) (ht : t₂ ⊆ t₁) :\n    HasCountableSeparatingOn α p₂ t₂ where\n  exists_countable_separating :=\n    let ⟨S, hSc, hSp, hSt⟩ := h.1\n    ⟨S, hSc, fun s hs ↦ hp s (hSp s hs), fun x hx y hy ↦ hSt x (ht hx) y (ht hy)⟩\n\n"}
{"name":"HasCountableSeparatingOn.of_subtype","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\np : Set α → Prop\nt : Set α\nq : Set ↑t → Prop\nh : HasCountableSeparatingOn (↑t) q Set.univ\nhpq : ∀ (U : Set ↑t), q U → Exists fun V => And (p V) (Eq (Set.preimage Subtype.val V) U)\n⊢ HasCountableSeparatingOn α p t","decl":"theorem HasCountableSeparatingOn.of_subtype {α : Type*} {p : Set α → Prop} {t : Set α}\n    {q : Set t → Prop} [h : HasCountableSeparatingOn t q univ]\n    (hpq : ∀ U, q U → ∃ V, p V ∧ (↑) ⁻¹' V = U) : HasCountableSeparatingOn α p t := by\n  rcases h.1 with ⟨S, hSc, hSq, hS⟩\n  choose! V hpV hV using fun s hs ↦ hpq s (hSq s hs)\n  refine ⟨⟨V '' S, hSc.image _, forall_mem_image.2 hpV, fun x hx y hy h ↦ ?_⟩⟩\n  refine congr_arg Subtype.val (hS ⟨x, hx⟩ trivial ⟨y, hy⟩ trivial fun U hU ↦ ?_)\n  rw [← hV U hU]\n  exact h _ (mem_image_of_mem _ hU)\n\n"}
{"name":"HasCountableSeparatingOn.subtype_iff","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\np : Set α → Prop\nt : Set α\n⊢ Iff (HasCountableSeparatingOn (↑t) (fun u => Exists fun v => And (p v) (Eq (Set.preimage Subtype.val v) u)) Set.univ) (HasCountableSeparatingOn α p t)","decl":"theorem HasCountableSeparatingOn.subtype_iff {α : Type*} {p : Set α → Prop} {t : Set α} :\n    HasCountableSeparatingOn t (fun u ↦ ∃ v, p v ∧ (↑) ⁻¹' v = u) univ ↔\n    HasCountableSeparatingOn α p t := by\n  constructor <;> intro h\n  · exact h.of_subtype <| fun s ↦ id\n  rcases h with ⟨S, Sct, Sp, hS⟩\n  use {Subtype.val ⁻¹' s | s ∈ S}, Sct.image _, ?_, ?_\n  · rintro u ⟨t, tS, rfl⟩\n    exact ⟨t, Sp _ tS, rfl⟩\n  rintro x - y - hxy\n  exact Subtype.val_injective <| hS _ (Subtype.coe_prop _) _ (Subtype.coe_prop _)\n    fun s hs ↦ hxy (Subtype.val ⁻¹' s) ⟨s, hs, rfl⟩\n\n"}
{"name":"Filter.exists_subset_subsingleton_mem_of_forall_separating","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\nl : Filter α\ninst✝ : CountableInterFilter l\np : Set α → Prop\ns : Set α\nh : HasCountableSeparatingOn α p s\nhs : Membership.mem l s\nhl : ∀ (U : Set α), p U → Or (Membership.mem l U) (Membership.mem l (HasCompl.compl U))\n⊢ Exists fun t => And (HasSubset.Subset t s) (And t.Subsingleton (Membership.mem l t))","decl":"theorem exists_subset_subsingleton_mem_of_forall_separating (p : Set α → Prop)\n    {s : Set α} [h : HasCountableSeparatingOn α p s] (hs : s ∈ l)\n    (hl : ∀ U, p U → U ∈ l ∨ Uᶜ ∈ l) : ∃ t, t ⊆ s ∧ t.Subsingleton ∧ t ∈ l := by\n  rcases h.1 with ⟨S, hSc, hSp, hS⟩\n  refine ⟨s ∩ ⋂₀ (S ∩ l.sets) ∩ ⋂ (U ∈ S) (_ : Uᶜ ∈ l), Uᶜ, ?_, ?_, ?_⟩\n  · exact fun _ h ↦ h.1.1\n  · intro x hx y hy\n    simp only [mem_sInter, mem_inter_iff, mem_iInter, mem_compl_iff] at hx hy\n    refine hS x hx.1.1 y hy.1.1 (fun s hsS ↦ ?_)\n    cases hl s (hSp s hsS) with\n    | inl hsl => simp only [hx.1.2 s ⟨hsS, hsl⟩, hy.1.2 s ⟨hsS, hsl⟩]\n    | inr hsl => simp only [hx.2 s hsS hsl, hy.2 s hsS hsl]\n  · exact inter_mem\n      (inter_mem hs ((countable_sInter_mem (hSc.mono inter_subset_left)).2 fun _ h ↦ h.2))\n      ((countable_bInter_mem hSc).2 fun U hU ↦ iInter_mem'.2 id)\n\n"}
{"name":"Filter.exists_mem_singleton_mem_of_mem_of_nonempty_of_forall_separating","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\nl : Filter α\ninst✝¹ : CountableInterFilter l\np : Set α → Prop\ns : Set α\ninst✝ : HasCountableSeparatingOn α p s\nhs : Membership.mem l s\nhne : s.Nonempty\nhl : ∀ (U : Set α), p U → Or (Membership.mem l U) (Membership.mem l (HasCompl.compl U))\n⊢ Exists fun a => And (Membership.mem s a) (Membership.mem l (Singleton.singleton a))","decl":"theorem exists_mem_singleton_mem_of_mem_of_nonempty_of_forall_separating (p : Set α → Prop)\n    {s : Set α} [HasCountableSeparatingOn α p s] (hs : s ∈ l) (hne : s.Nonempty)\n    (hl : ∀ U, p U → U ∈ l ∨ Uᶜ ∈ l) : ∃ a ∈ s, {a} ∈ l := by\n  rcases exists_subset_subsingleton_mem_of_forall_separating p hs hl with ⟨t, hts, ht, htl⟩\n  rcases ht.eq_empty_or_singleton with rfl | ⟨x, rfl⟩\n  · exact hne.imp fun a ha ↦ ⟨ha, mem_of_superset htl (empty_subset _)⟩\n  · exact ⟨x, hts rfl, htl⟩\n\n"}
{"name":"Filter.exists_singleton_mem_of_mem_of_forall_separating","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\nl : Filter α\ninst✝² : CountableInterFilter l\ninst✝¹ : Nonempty α\np : Set α → Prop\ns : Set α\ninst✝ : HasCountableSeparatingOn α p s\nhs : Membership.mem l s\nhl : ∀ (U : Set α), p U → Or (Membership.mem l U) (Membership.mem l (HasCompl.compl U))\n⊢ Exists fun a => Membership.mem l (Singleton.singleton a)","decl":"theorem exists_singleton_mem_of_mem_of_forall_separating [Nonempty α] (p : Set α → Prop)\n    {s : Set α} [HasCountableSeparatingOn α p s] (hs : s ∈ l) (hl : ∀ U, p U → U ∈ l ∨ Uᶜ ∈ l) :\n    ∃ a, {a} ∈ l := by\n  rcases s.eq_empty_or_nonempty with rfl | hne\n  · exact ‹Nonempty α›.elim fun a ↦ ⟨a, mem_of_superset hs (empty_subset _)⟩\n  · exact (exists_mem_singleton_mem_of_mem_of_nonempty_of_forall_separating p hs hne hl).imp fun _ ↦\n      And.right\n\n"}
{"name":"Filter.exists_subsingleton_mem_of_forall_separating","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\nl : Filter α\ninst✝¹ : CountableInterFilter l\np : Set α → Prop\ninst✝ : HasCountableSeparatingOn α p Set.univ\nhl : ∀ (U : Set α), p U → Or (Membership.mem l U) (Membership.mem l (HasCompl.compl U))\n⊢ Exists fun s => And s.Subsingleton (Membership.mem l s)","decl":"theorem exists_subsingleton_mem_of_forall_separating (p : Set α → Prop)\n    [HasCountableSeparatingOn α p univ] (hl : ∀ U, p U → U ∈ l ∨ Uᶜ ∈ l) :\n    ∃ s : Set α, s.Subsingleton ∧ s ∈ l :=\n  let ⟨t, _, hts, htl⟩ := exists_subset_subsingleton_mem_of_forall_separating p univ_mem hl\n  ⟨t, hts, htl⟩\n\n"}
{"name":"Filter.exists_singleton_mem_of_forall_separating","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\nl : Filter α\ninst✝² : CountableInterFilter l\ninst✝¹ : Nonempty α\np : Set α → Prop\ninst✝ : HasCountableSeparatingOn α p Set.univ\nhl : ∀ (U : Set α), p U → Or (Membership.mem l U) (Membership.mem l (HasCompl.compl U))\n⊢ Exists fun x => Membership.mem l (Singleton.singleton x)","decl":"theorem exists_singleton_mem_of_forall_separating [Nonempty α] (p : Set α → Prop)\n    [HasCountableSeparatingOn α p univ] (hl : ∀ U, p U → U ∈ l ∨ Uᶜ ∈ l) :\n    ∃ x : α, {x} ∈ l :=\n  exists_singleton_mem_of_mem_of_forall_separating p univ_mem hl\n\n"}
{"name":"Filter.exists_mem_eventuallyEq_const_of_eventually_mem_of_forall_separating","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝¹ : CountableInterFilter l\nf : α → β\np : Set β → Prop\ns : Set β\ninst✝ : HasCountableSeparatingOn β p s\nhs : Filter.Eventually (fun x => Membership.mem s (f x)) l\nhne : s.Nonempty\nh : ∀ (U : Set β), p U → Or (Filter.Eventually (fun x => Membership.mem U (f x)) l) (Filter.Eventually (fun x => Not (Membership.mem U (f x))) l)\n⊢ Exists fun a => And (Membership.mem s a) (l.EventuallyEq f (Function.const α a))","decl":"theorem exists_mem_eventuallyEq_const_of_eventually_mem_of_forall_separating (p : Set β → Prop)\n    {s : Set β} [HasCountableSeparatingOn β p s] (hs : ∀ᶠ x in l, f x ∈ s) (hne : s.Nonempty)\n    (h : ∀ U, p U → (∀ᶠ x in l, f x ∈ U) ∨ (∀ᶠ x in l, f x ∉ U)) :\n    ∃ a ∈ s, f =ᶠ[l] const α a :=\n  exists_mem_singleton_mem_of_mem_of_nonempty_of_forall_separating p (l := map f l) hs hne h\n\n"}
{"name":"Filter.exists_eventuallyEq_const_of_eventually_mem_of_forall_separating","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝² : CountableInterFilter l\nf : α → β\ninst✝¹ : Nonempty β\np : Set β → Prop\ns : Set β\ninst✝ : HasCountableSeparatingOn β p s\nhs : Filter.Eventually (fun x => Membership.mem s (f x)) l\nh : ∀ (U : Set β), p U → Or (Filter.Eventually (fun x => Membership.mem U (f x)) l) (Filter.Eventually (fun x => Not (Membership.mem U (f x))) l)\n⊢ Exists fun a => l.EventuallyEq f (Function.const α a)","decl":"theorem exists_eventuallyEq_const_of_eventually_mem_of_forall_separating [Nonempty β]\n    (p : Set β → Prop) {s : Set β} [HasCountableSeparatingOn β p s] (hs : ∀ᶠ x in l, f x ∈ s)\n    (h : ∀ U, p U → (∀ᶠ x in l, f x ∈ U) ∨ (∀ᶠ x in l, f x ∉ U)) :\n    ∃ a, f =ᶠ[l] const α a :=\n  exists_singleton_mem_of_mem_of_forall_separating (l := map f l) p hs h\n\n"}
{"name":"Filter.exists_eventuallyEq_const_of_forall_separating","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝² : CountableInterFilter l\nf : α → β\ninst✝¹ : Nonempty β\np : Set β → Prop\ninst✝ : HasCountableSeparatingOn β p Set.univ\nh : ∀ (U : Set β), p U → Or (Filter.Eventually (fun x => Membership.mem U (f x)) l) (Filter.Eventually (fun x => Not (Membership.mem U (f x))) l)\n⊢ Exists fun a => l.EventuallyEq f (Function.const α a)","decl":"theorem exists_eventuallyEq_const_of_forall_separating [Nonempty β] (p : Set β → Prop)\n    [HasCountableSeparatingOn β p univ]\n    (h : ∀ U, p U → (∀ᶠ x in l, f x ∈ U) ∨ (∀ᶠ x in l, f x ∉ U)) :\n    ∃ a, f =ᶠ[l] const α a :=\n  exists_singleton_mem_of_forall_separating (l := map f l) p h\n\n"}
{"name":"Filter.EventuallyEq.of_eventually_mem_of_forall_separating_mem_iff","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : CountableInterFilter l\nf g : α → β\np : Set β → Prop\ns : Set β\nh' : HasCountableSeparatingOn β p s\nhf : Filter.Eventually (fun x => Membership.mem s (f x)) l\nhg : Filter.Eventually (fun x => Membership.mem s (g x)) l\nh : ∀ (U : Set β), p U → Filter.Eventually (fun x => Iff (Membership.mem U (f x)) (Membership.mem U (g x))) l\n⊢ l.EventuallyEq f g","decl":"theorem of_eventually_mem_of_forall_separating_mem_iff (p : Set β → Prop) {s : Set β}\n    [h' : HasCountableSeparatingOn β p s] (hf : ∀ᶠ x in l, f x ∈ s) (hg : ∀ᶠ x in l, g x ∈ s)\n    (h : ∀ U : Set β, p U → ∀ᶠ x in l, f x ∈ U ↔ g x ∈ U) : f =ᶠ[l] g := by\n  rcases h'.1 with ⟨S, hSc, hSp, hS⟩\n  have H : ∀ᶠ x in l, ∀ s ∈ S, f x ∈ s ↔ g x ∈ s :=\n    (eventually_countable_ball hSc).2 fun s hs ↦ (h _ (hSp _ hs))\n  filter_upwards [H, hf, hg] with x hx hxf hxg using hS _ hxf _ hxg hx\n\n"}
{"name":"Filter.EventuallyEq.of_forall_separating_mem_iff","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝¹ : CountableInterFilter l\nf g : α → β\np : Set β → Prop\ninst✝ : HasCountableSeparatingOn β p Set.univ\nh : ∀ (U : Set β), p U → Filter.Eventually (fun x => Iff (Membership.mem U (f x)) (Membership.mem U (g x))) l\n⊢ l.EventuallyEq f g","decl":"theorem of_forall_separating_mem_iff (p : Set β → Prop)\n    [HasCountableSeparatingOn β p univ] (h : ∀ U : Set β, p U → ∀ᶠ x in l, f x ∈ U ↔ g x ∈ U) :\n    f =ᶠ[l] g :=\n  of_eventually_mem_of_forall_separating_mem_iff p (s := univ) univ_mem univ_mem h\n\n"}
{"name":"Filter.EventuallyEq.of_eventually_mem_of_forall_separating_preimage","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝¹ : CountableInterFilter l\nf g : α → β\np : Set β → Prop\ns : Set β\ninst✝ : HasCountableSeparatingOn β p s\nhf : Filter.Eventually (fun x => Membership.mem s (f x)) l\nhg : Filter.Eventually (fun x => Membership.mem s (g x)) l\nh : ∀ (U : Set β), p U → l.EventuallyEq (Set.preimage f U) (Set.preimage g U)\n⊢ l.EventuallyEq f g","decl":"theorem of_eventually_mem_of_forall_separating_preimage (p : Set β → Prop) {s : Set β}\n    [HasCountableSeparatingOn β p s] (hf : ∀ᶠ x in l, f x ∈ s) (hg : ∀ᶠ x in l, g x ∈ s)\n    (h : ∀ U : Set β, p U → f ⁻¹' U =ᶠ[l] g ⁻¹' U) : f =ᶠ[l] g :=\n  of_eventually_mem_of_forall_separating_mem_iff p hf hg fun U hU ↦ (h U hU).mem_iff\n\n"}
{"name":"Filter.EventuallyEq.of_forall_separating_preimage","module":"Mathlib.Order.Filter.CountableSeparatingOn","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝¹ : CountableInterFilter l\nf g : α → β\np : Set β → Prop\ninst✝ : HasCountableSeparatingOn β p Set.univ\nh : ∀ (U : Set β), p U → l.EventuallyEq (Set.preimage f U) (Set.preimage g U)\n⊢ l.EventuallyEq f g","decl":"theorem of_forall_separating_preimage (p : Set β → Prop) [HasCountableSeparatingOn β p univ]\n    (h : ∀ U : Set β, p U → f ⁻¹' U =ᶠ[l] g ⁻¹' U) : f =ᶠ[l] g :=\n  of_eventually_mem_of_forall_separating_preimage p (s := univ) univ_mem univ_mem h\n\n"}
