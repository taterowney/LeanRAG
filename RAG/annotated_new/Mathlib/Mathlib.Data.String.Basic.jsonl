{"name":"String.endPos_empty","module":"Mathlib.Data.String.Basic","initialProofState":"⊢ Eq \"\".endPos 0","decl":"@[simp] theorem endPos_empty : \"\".endPos = 0 := rfl\n\n"}
{"name":"String.ltb_cons_addChar","module":"Mathlib.Data.String.Basic","initialProofState":"c : Char\ncs₁ cs₂ : List Char\ni₁ i₂ : String.Pos\n⊢ Eq (String.ltb { s := { data := List.cons c cs₁ }, i := HAdd.hAdd i₁ c } { s := { data := List.cons c cs₂ }, i := HAdd.hAdd i₂ c }) (String.ltb { s := { data := cs₁ }, i := i₁ } { s := { data := cs₂ }, i := i₂ })","decl":"theorem ltb_cons_addChar (c : Char) (cs₁ cs₂ : List Char) (i₁ i₂ : Pos) :\n    ltb ⟨⟨c :: cs₁⟩, i₁ + c⟩ ⟨⟨c :: cs₂⟩, i₂ + c⟩ = ltb ⟨⟨cs₁⟩, i₁⟩ ⟨⟨cs₂⟩, i₂⟩ := by\n  apply ltb.inductionOn ⟨⟨cs₁⟩, i₁⟩ ⟨⟨cs₂⟩, i₂⟩ (motive := fun ⟨⟨cs₁⟩, i₁⟩ ⟨⟨cs₂⟩, i₂⟩ ↦\n    ltb ⟨⟨c :: cs₁⟩, i₁ + c⟩ ⟨⟨c :: cs₂⟩, i₂ + c⟩ =\n    ltb ⟨⟨cs₁⟩, i₁⟩ ⟨⟨cs₂⟩, i₂⟩) <;> simp only <;>\n  intro ⟨cs₁⟩ ⟨cs₂⟩ i₁ i₂ <;>\n  intros <;>\n  (conv => lhs; unfold ltb) <;> (conv => rhs; unfold ltb) <;>\n  simp only [Iterator.hasNext_cons_addChar, ite_false, ite_true, *, reduceCtorEq]\n  · rename_i h₂ h₁ heq ih\n    simp only [Iterator.next, next, heq, Iterator.curr, get_cons_addChar, ite_true] at ih ⊢\n    repeat rw [Pos.addChar_right_comm _ c]\n    exact ih\n  · rename_i h₂ h₁ hne\n    simp [Iterator.curr, get_cons_addChar, hne]\n\n"}
{"name":"String.lt_iff_toList_lt","module":"Mathlib.Data.String.Basic","initialProofState":"s₁ s₂ : String\n⊢ Iff (LT.lt s₁ s₂) (LT.lt s₁.toList s₂.toList)","decl":"@[simp]\ntheorem lt_iff_toList_lt : ∀ {s₁ s₂ : String}, s₁ < s₂ ↔ s₁.toList < s₂.toList\n  | ⟨s₁⟩, ⟨s₂⟩ => show ltb ⟨⟨s₁⟩, 0⟩ ⟨⟨s₂⟩, 0⟩ ↔ s₁ < s₂ by\n    induction s₁ generalizing s₂ <;> cases s₂\n    · unfold ltb; decide\n    · rename_i c₂ cs₂; apply iff_of_true\n      · unfold ltb\n        simp [Iterator.hasNext, Char.utf8Size_pos]\n      · apply List.nil_lt_cons\n    · rename_i c₁ cs₁ ih; apply iff_of_false\n      · unfold ltb\n        simp [Iterator.hasNext]\n      · apply not_lt_of_lt; apply List.nil_lt_cons\n    · rename_i c₁ cs₁ ih c₂ cs₂; unfold ltb\n      simp only [Iterator.hasNext, Pos.byteIdx_zero, endPos, utf8ByteSize, utf8ByteSize.go,\n        add_pos_iff, Char.utf8Size_pos, or_true, decide_eq_true_eq, ↓reduceIte, Iterator.curr, get,\n        utf8GetAux, Iterator.next, next, Bool.ite_eq_true_distrib]\n      split_ifs with h\n      · subst c₂\n        suffices ltb ⟨⟨c₁ :: cs₁⟩, (0 : Pos) + c₁⟩ ⟨⟨c₁ :: cs₂⟩, (0 : Pos) + c₁⟩ =\n          ltb ⟨⟨cs₁⟩, 0⟩ ⟨⟨cs₂⟩, 0⟩ by rw [this]; exact (ih cs₂).trans List.Lex.cons_iff.symm\n        apply ltb_cons_addChar\n      · refine ⟨List.Lex.rel, fun e ↦ ?_⟩\n        cases e <;> rename_i h'\n        · contradiction\n        · assumption\n\n"}
{"name":"String.le_iff_toList_le","module":"Mathlib.Data.String.Basic","initialProofState":"s₁ s₂ : String\n⊢ Iff (LE.le s₁ s₂) (LE.le s₁.toList s₂.toList)","decl":"@[simp]\ntheorem le_iff_toList_le {s₁ s₂ : String} : s₁ ≤ s₂ ↔ s₁.toList ≤ s₂.toList :=\n  (not_congr lt_iff_toList_lt).trans not_lt\n\n"}
{"name":"String.toList_inj","module":"Mathlib.Data.String.Basic","initialProofState":"s₁ s₂ : String\n⊢ Iff (Eq s₁.toList s₂.toList) (Eq s₁ s₂)","decl":"theorem toList_inj {s₁ s₂ : String} : s₁.toList = s₂.toList ↔ s₁ = s₂ :=\n  ⟨congr_arg mk, congr_arg toList⟩\n\n"}
{"name":"String.asString_nil","module":"Mathlib.Data.String.Basic","initialProofState":"⊢ Eq List.nil.asString \"\"","decl":"theorem asString_nil : [].asString = \"\" :=\n  rfl\n\n"}
{"name":"String.toList_empty","module":"Mathlib.Data.String.Basic","initialProofState":"⊢ Eq \"\".toList List.nil","decl":"@[simp]\ntheorem toList_empty : \"\".toList = [] :=\n  rfl\n\n"}
{"name":"String.asString_toList","module":"Mathlib.Data.String.Basic","initialProofState":"s : String\n⊢ Eq s.toList.asString s","decl":"theorem asString_toList (s : String) : s.toList.asString = s :=\n  rfl\n\n"}
{"name":"String.toList_nonempty","module":"Mathlib.Data.String.Basic","initialProofState":"s : String\na✝ : Ne s \"\"\n⊢ Eq s.toList (List.cons s.head (s.drop 1).toList)","decl":"theorem toList_nonempty : ∀ {s : String}, s ≠ \"\" → s.toList = s.head :: (s.drop 1).toList\n  | ⟨s⟩, h => by\n    cases s with\n    | nil => simp at h\n    | cons c cs =>\n      simp only [toList, data_drop, List.drop_succ_cons, List.drop_zero, List.cons.injEq, and_true]\n      rfl\n\n"}
{"name":"String.head_empty","module":"Mathlib.Data.String.Basic","initialProofState":"⊢ Eq \"\".data.head! Inhabited.default","decl":"@[simp]\ntheorem head_empty : \"\".data.head! = default :=\n  rfl\n\n"}
{"name":"List.toList_asString","module":"Mathlib.Data.String.Basic","initialProofState":"l : List Char\n⊢ Eq l.asString.toList l","decl":"theorem toList_asString (l : List Char) : l.asString.toList = l :=\n  rfl\n\n"}
{"name":"List.length_asString","module":"Mathlib.Data.String.Basic","initialProofState":"l : List Char\n⊢ Eq l.asString.length l.length","decl":"@[simp]\ntheorem length_asString (l : List Char) : l.asString.length = l.length :=\n  rfl\n\n"}
{"name":"List.asString_inj","module":"Mathlib.Data.String.Basic","initialProofState":"l l' : List Char\n⊢ Iff (Eq l.asString l'.asString) (Eq l l')","decl":"@[simp]\ntheorem asString_inj {l l' : List Char} : l.asString = l'.asString ↔ l = l' :=\n  ⟨fun h ↦ by rw [← toList_asString l, ← toList_asString l', toList_inj, h],\n   fun h ↦ h ▸ rfl⟩\n\n"}
{"name":"List.asString_eq","module":"Mathlib.Data.String.Basic","initialProofState":"l : List Char\ns : String\n⊢ Iff (Eq l.asString s) (Eq l s.toList)","decl":"theorem asString_eq {l : List Char} {s : String} : l.asString = s ↔ l = s.toList := by\n  rw [← asString_toList s, asString_inj, asString_toList s]\n\n"}
{"name":"String.length_data","module":"Mathlib.Data.String.Basic","initialProofState":"s : String\n⊢ Eq s.data.length s.length","decl":"@[simp]\ntheorem String.length_data (s : String) : s.data.length = s.length :=\n  rfl\n"}
