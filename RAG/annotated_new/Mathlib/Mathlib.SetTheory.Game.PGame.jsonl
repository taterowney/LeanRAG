{"name":"SetTheory.PGame.mk.sizeOf_spec","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"α β : Type u\na✝¹ : α → SetTheory.PGame\na✝ : β → SetTheory.PGame\n⊢ Eq (SizeOf.sizeOf (SetTheory.PGame.mk α β a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf α)) (SizeOf.sizeOf β))","decl":"/-- The type of pre-games, before we have quotiented\n  by equivalence (`PGame.Setoid`). In ZFC, a combinatorial game is constructed from\n  two sets of combinatorial games that have been constructed at an earlier\n  stage. To do this in type theory, we say that a pre-game is built\n  inductively from two families of pre-games indexed over any type\n  in Type u. The resulting type `PGame.{u}` lives in `Type (u+1)`,\n  reflecting that it is a proper class in ZFC. -/\ninductive PGame : Type (u + 1)\n  | mk : ∀ α β : Type u, (α → PGame) → (β → PGame) → PGame\n"}
{"name":"SetTheory.PGame.mk.inj","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"α✝ β✝ : Type u\na✝³ : α✝ → SetTheory.PGame\na✝² : β✝ → SetTheory.PGame\nα β : Type u\na✝¹ : α → SetTheory.PGame\na✝ : β → SetTheory.PGame\nx✝ : Eq (SetTheory.PGame.mk α✝ β✝ a✝³ a✝²) (SetTheory.PGame.mk α β a✝¹ a✝)\n⊢ And (Eq α✝ α) (And (Eq β✝ β) (And (HEq a✝³ a✝¹) (HEq a✝² a✝)))","decl":"/-- The type of pre-games, before we have quotiented\n  by equivalence (`PGame.Setoid`). In ZFC, a combinatorial game is constructed from\n  two sets of combinatorial games that have been constructed at an earlier\n  stage. To do this in type theory, we say that a pre-game is built\n  inductively from two families of pre-games indexed over any type\n  in Type u. The resulting type `PGame.{u}` lives in `Type (u+1)`,\n  reflecting that it is a proper class in ZFC. -/\ninductive PGame : Type (u + 1)\n  | mk : ∀ α β : Type u, (α → PGame) → (β → PGame) → PGame\n"}
{"name":"SetTheory.PGame.mk.injEq","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"α✝ β✝ : Type u\na✝³ : α✝ → SetTheory.PGame\na✝² : β✝ → SetTheory.PGame\nα β : Type u\na✝¹ : α → SetTheory.PGame\na✝ : β → SetTheory.PGame\n⊢ Eq (Eq (SetTheory.PGame.mk α✝ β✝ a✝³ a✝²) (SetTheory.PGame.mk α β a✝¹ a✝)) (And (Eq α✝ α) (And (Eq β✝ β) (And (HEq a✝³ a✝¹) (HEq a✝² a✝))))","decl":"/-- The type of pre-games, before we have quotiented\n  by equivalence (`PGame.Setoid`). In ZFC, a combinatorial game is constructed from\n  two sets of combinatorial games that have been constructed at an earlier\n  stage. To do this in type theory, we say that a pre-game is built\n  inductively from two families of pre-games indexed over any type\n  in Type u. The resulting type `PGame.{u}` lives in `Type (u+1)`,\n  reflecting that it is a proper class in ZFC. -/\ninductive PGame : Type (u + 1)\n  | mk : ∀ α β : Type u, (α → PGame) → (β → PGame) → PGame\n"}
{"name":"SetTheory.PGame.leftMoves_mk","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\n⊢ Eq (SetTheory.PGame.mk xl xr xL xR).LeftMoves xl","decl":"@[simp]\ntheorem leftMoves_mk {xl xr xL xR} : (⟨xl, xr, xL, xR⟩ : PGame).LeftMoves = xl :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.moveLeft_mk","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\n⊢ Eq (SetTheory.PGame.mk xl xr xL xR).moveLeft xL","decl":"@[simp]\ntheorem moveLeft_mk {xl xr xL xR} : (⟨xl, xr, xL, xR⟩ : PGame).moveLeft = xL :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.rightMoves_mk","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\n⊢ Eq (SetTheory.PGame.mk xl xr xL xR).RightMoves xr","decl":"@[simp]\ntheorem rightMoves_mk {xl xr xL xR} : (⟨xl, xr, xL, xR⟩ : PGame).RightMoves = xr :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.moveRight_mk","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\n⊢ Eq (SetTheory.PGame.mk xl xr xL xR).moveRight xR","decl":"@[simp]\ntheorem moveRight_mk {xl xr xL xR} : (⟨xl, xr, xL, xR⟩ : PGame).moveRight = xR :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.ext","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nhl : Eq x.LeftMoves y.LeftMoves\nhr : Eq x.RightMoves y.RightMoves\nhL : ∀ (i : x.LeftMoves) (j : y.LeftMoves), HEq i j → Eq (x.moveLeft i) (y.moveLeft j)\nhR : ∀ (i : x.RightMoves) (j : y.RightMoves), HEq i j → Eq (x.moveRight i) (y.moveRight j)\n⊢ Eq x y","decl":"lemma ext {x y : PGame} (hl : x.LeftMoves = y.LeftMoves) (hr : x.RightMoves = y.RightMoves)\n    (hL : ∀ i j, HEq i j → x.moveLeft i = y.moveLeft j)\n    (hR : ∀ i j, HEq i j → x.moveRight i = y.moveRight j) :\n    x = y := by\n  cases x\n  cases y\n  subst hl hr\n  simp only [leftMoves_mk, rightMoves_mk, heq_eq_eq, forall_eq', mk.injEq, true_and] at *\n  exact ⟨funext hL, funext hR⟩\n\n-- TODO define this at the level of games, as well, and perhaps also for finsets of games.\n"}
{"name":"SetTheory.PGame.leftMoves_ofLists","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"L R : List SetTheory.PGame\n⊢ Eq (SetTheory.PGame.ofLists L R).LeftMoves (ULift.{u_1, 0} (Fin L.length))","decl":"theorem leftMoves_ofLists (L R : List PGame) : (ofLists L R).LeftMoves = ULift (Fin L.length) :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.rightMoves_ofLists","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"L R : List SetTheory.PGame\n⊢ Eq (SetTheory.PGame.ofLists L R).RightMoves (ULift.{u_1, 0} (Fin R.length))","decl":"theorem rightMoves_ofLists (L R : List PGame) : (ofLists L R).RightMoves = ULift (Fin R.length) :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.ofLists_moveLeft'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"L R : List SetTheory.PGame\ni : (SetTheory.PGame.ofLists L R).LeftMoves\n⊢ Eq ((SetTheory.PGame.ofLists L R).moveLeft i) (GetElem.getElem L ↑i.down ⋯)","decl":"@[simp]\ntheorem ofLists_moveLeft' {L R : List PGame} (i : (ofLists L R).LeftMoves) :\n    (ofLists L R).moveLeft i = L[i.down.val] :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.ofLists_moveLeft","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"L R : List SetTheory.PGame\ni : Fin L.length\n⊢ Eq ((SetTheory.PGame.ofLists L R).moveLeft { down := i }) (GetElem.getElem L i ⋯)","decl":"theorem ofLists_moveLeft {L R : List PGame} (i : Fin L.length) :\n    (ofLists L R).moveLeft (ULift.up i) = L[i] :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.ofLists_moveRight'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"L R : List SetTheory.PGame\ni : (SetTheory.PGame.ofLists L R).RightMoves\n⊢ Eq ((SetTheory.PGame.ofLists L R).moveRight i) (GetElem.getElem R ↑i.down ⋯)","decl":"@[simp]\ntheorem ofLists_moveRight' {L R : List PGame} (i : (ofLists L R).RightMoves) :\n    (ofLists L R).moveRight i = R[i.down.val] :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.ofLists_moveRight","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"L R : List SetTheory.PGame\ni : Fin R.length\n⊢ Eq ((SetTheory.PGame.ofLists L R).moveRight { down := i }) (GetElem.getElem R i ⋯)","decl":"theorem ofLists_moveRight {L R : List PGame} (i : Fin R.length) :\n    (ofLists L R).moveRight (ULift.up i) = R[i] :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.isOption_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"a✝¹ a✝ : SetTheory.PGame\n⊢ Iff (a✝¹.IsOption a✝) (Or (Exists fun i => Eq a✝¹ (a✝.moveLeft i)) (Exists fun i => Eq a✝¹ (a✝.moveRight i)))","decl":"/-- `IsOption x y` means that `x` is either a left or right option for `y`. -/\n@[mk_iff]\ninductive IsOption : PGame → PGame → Prop\n  | moveLeft {x : PGame} (i : x.LeftMoves) : IsOption (x.moveLeft i) x\n  | moveRight {x : PGame} (i : x.RightMoves) : IsOption (x.moveRight i) x\n\n"}
{"name":"SetTheory.PGame.IsOption.mk_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\ni : xl\n⊢ (xL i).IsOption (SetTheory.PGame.mk xl xr xL xR)","decl":"theorem IsOption.mk_left {xl xr : Type u} (xL : xl → PGame) (xR : xr → PGame) (i : xl) :\n    (xL i).IsOption (mk xl xr xL xR) :=\n  @IsOption.moveLeft (mk _ _ _ _) i\n\n"}
{"name":"SetTheory.PGame.IsOption.mk_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\ni : xr\n⊢ (xR i).IsOption (SetTheory.PGame.mk xl xr xL xR)","decl":"theorem IsOption.mk_right {xl xr : Type u} (xL : xl → PGame) (xR : xr → PGame) (i : xr) :\n    (xR i).IsOption (mk xl xr xL xR) :=\n  @IsOption.moveRight (mk _ _ _ _) i\n\n"}
{"name":"SetTheory.PGame.wf_isOption","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ WellFounded SetTheory.PGame.IsOption","decl":"theorem wf_isOption : WellFounded IsOption :=\n  ⟨fun x =>\n    moveRecOn x fun x IHl IHr =>\n      Acc.intro x fun y h => by\n        induction h with\n        | moveLeft i => exact IHl i\n        | moveRight j => exact IHr j⟩\n\n"}
{"name":"SetTheory.PGame.instIsTransSubsequent","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ IsTrans SetTheory.PGame SetTheory.PGame.Subsequent","decl":"instance : IsTrans _ Subsequent :=\n  inferInstanceAs <| IsTrans _ (TransGen _)\n\n"}
{"name":"SetTheory.PGame.Subsequent.trans","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\na✝¹ : x.Subsequent y\na✝ : y.Subsequent z\n⊢ x.Subsequent z","decl":"@[trans]\ntheorem Subsequent.trans {x y z} : Subsequent x y → Subsequent y z → Subsequent x z :=\n  TransGen.trans\n\n"}
{"name":"SetTheory.PGame.wf_subsequent","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ WellFounded SetTheory.PGame.Subsequent","decl":"theorem wf_subsequent : WellFounded Subsequent :=\n  wf_isOption.transGen\n\n"}
{"name":"SetTheory.PGame.Subsequent.moveLeft","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ni : x.LeftMoves\n⊢ (x.moveLeft i).Subsequent x","decl":"@[simp]\ntheorem Subsequent.moveLeft {x : PGame} (i : x.LeftMoves) : Subsequent (x.moveLeft i) x :=\n  TransGen.single (IsOption.moveLeft i)\n\n"}
{"name":"SetTheory.PGame.Subsequent.moveRight","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nj : x.RightMoves\n⊢ (x.moveRight j).Subsequent x","decl":"@[simp]\ntheorem Subsequent.moveRight {x : PGame} (j : x.RightMoves) : Subsequent (x.moveRight j) x :=\n  TransGen.single (IsOption.moveRight j)\n\n"}
{"name":"SetTheory.PGame.Subsequent.mk_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\ni : xl\n⊢ (xL i).Subsequent (SetTheory.PGame.mk xl xr xL xR)","decl":"@[simp]\ntheorem Subsequent.mk_left {xl xr} (xL : xl → PGame) (xR : xr → PGame) (i : xl) :\n    Subsequent (xL i) (mk xl xr xL xR) :=\n  @Subsequent.moveLeft (mk _ _ _ _) i\n\n"}
{"name":"SetTheory.PGame.Subsequent.mk_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nj : xr\n⊢ (xR j).Subsequent (SetTheory.PGame.mk xl xr xL xR)","decl":"@[simp]\ntheorem Subsequent.mk_right {xl xr} (xL : xl → PGame) (xR : xr → PGame) (j : xr) :\n    Subsequent (xR j) (mk xl xr xL xR) :=\n  @Subsequent.moveRight (mk _ _ _ _) j\n\n"}
{"name":"SetTheory.PGame.Subsequent.mk_right'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nj : (SetTheory.PGame.mk xl xr xL xR).RightMoves\n⊢ (xR j).Subsequent (SetTheory.PGame.mk xl xr xL xR)","decl":"@[simp]\ntheorem Subsequent.mk_right' (xL : xl → PGame) (xR : xr → PGame) (j : RightMoves (mk xl xr xL xR)) :\n    Subsequent (xR j) (mk xl xr xL xR) := by\n  pgame_wf_tac\n\n"}
{"name":"SetTheory.PGame.Subsequent.moveRight_mk_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u\nxR : xr → SetTheory.PGame\ni : xl\nxL : xl → SetTheory.PGame\nj : (xL i).RightMoves\n⊢ ((xL i).moveRight j).Subsequent (SetTheory.PGame.mk xl xr xL xR)","decl":"@[simp] theorem Subsequent.moveRight_mk_left {xR : xr → PGame} {i : xl} (xL : xl → PGame) (j) :\n    Subsequent ((xL i).moveRight j) (mk xl xr xL xR) := by\n  pgame_wf_tac\n\n"}
{"name":"SetTheory.PGame.Subsequent.moveRight_mk_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u\nxL : xl → SetTheory.PGame\ni : xr\nxR : xr → SetTheory.PGame\nj : (xR i).RightMoves\n⊢ ((xR i).moveRight j).Subsequent (SetTheory.PGame.mk xl xr xL xR)","decl":"@[simp] theorem Subsequent.moveRight_mk_right {xL : xl → PGame} {i : xr} (xR : xr → PGame) (j) :\n    Subsequent ((xR i).moveRight j) (mk xl xr xL xR) := by\n  pgame_wf_tac\n\n"}
{"name":"SetTheory.PGame.Subsequent.moveLeft_mk_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u\nxR : xr → SetTheory.PGame\ni : xl\nxL : xl → SetTheory.PGame\nj : (xL i).LeftMoves\n⊢ ((xL i).moveLeft j).Subsequent (SetTheory.PGame.mk xl xr xL xR)","decl":"@[simp] theorem Subsequent.moveLeft_mk_left {xR : xr → PGame} {i : xl} (xL : xl → PGame) (j) :\n    Subsequent ((xL i).moveLeft j) (mk xl xr xL xR) := by\n  pgame_wf_tac\n\n"}
{"name":"SetTheory.PGame.Subsequent.moveLeft_mk_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u\nxL : xl → SetTheory.PGame\ni : xr\nxR : xr → SetTheory.PGame\nj : (xR i).LeftMoves\n⊢ ((xR i).moveLeft j).Subsequent (SetTheory.PGame.mk xl xr xL xR)","decl":"@[simp] theorem Subsequent.moveLeft_mk_right {xL : xl → PGame} {i : xr} (xR : xr → PGame) (j) :\n    Subsequent ((xR i).moveLeft j) (mk xl xr xL xR) := by\n  pgame_wf_tac\n\n"}
{"name":"SetTheory.PGame.zero_leftMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ Eq (SetTheory.PGame.LeftMoves 0) PEmpty.{u_1 + 1}","decl":"@[simp]\ntheorem zero_leftMoves : LeftMoves 0 = PEmpty :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.zero_rightMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ Eq (SetTheory.PGame.RightMoves 0) PEmpty.{u_1 + 1}","decl":"@[simp]\ntheorem zero_rightMoves : RightMoves 0 = PEmpty :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.isEmpty_zero_leftMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ IsEmpty (SetTheory.PGame.LeftMoves 0)","decl":"instance isEmpty_zero_leftMoves : IsEmpty (LeftMoves 0) :=\n  PEmpty.instIsEmpty\n\n"}
{"name":"SetTheory.PGame.isEmpty_zero_rightMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ IsEmpty (SetTheory.PGame.RightMoves 0)","decl":"instance isEmpty_zero_rightMoves : IsEmpty (RightMoves 0) :=\n  PEmpty.instIsEmpty\n\n"}
{"name":"SetTheory.PGame.one_leftMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ Eq (SetTheory.PGame.LeftMoves 1) PUnit.{u_1 + 1}","decl":"@[simp]\ntheorem one_leftMoves : LeftMoves 1 = PUnit :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.one_moveLeft","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame.LeftMoves 1\n⊢ Eq (SetTheory.PGame.moveLeft 1 x) 0","decl":"@[simp]\ntheorem one_moveLeft (x) : moveLeft 1 x = 0 :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.one_rightMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ Eq (SetTheory.PGame.RightMoves 1) PEmpty.{u_1 + 1}","decl":"@[simp]\ntheorem one_rightMoves : RightMoves 1 = PEmpty :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.isEmpty_one_rightMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ IsEmpty (SetTheory.PGame.RightMoves 1)","decl":"instance isEmpty_one_rightMoves : IsEmpty (RightMoves 1) :=\n  PEmpty.instIsEmpty\n\n"}
{"name":"SetTheory.PGame.identical_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.Identical y) (And (Relator.BiTotal fun x1 x2 => (x.moveLeft x1).Identical (y.moveLeft x2)) (Relator.BiTotal fun x1 x2 => (x.moveRight x1).Identical (y.moveRight x2)))","decl":"theorem identical_iff : ∀ {x y : PGame}, x ≡ y ↔\n    Relator.BiTotal (x.moveLeft · ≡ y.moveLeft ·) ∧ Relator.BiTotal (x.moveRight · ≡ y.moveRight ·)\n  | mk _ _ _ _, mk _ _ _ _ => Iff.rfl\n\n"}
{"name":"SetTheory.PGame.Identical.refl","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ x.Identical x","decl":"@[refl, simp] protected theorem Identical.refl (x) : x ≡ x :=\n  PGame.recOn x fun _ _ _ _ IHL IHR ↦ ⟨Relator.BiTotal.refl IHL, Relator.BiTotal.refl IHR⟩\n\n"}
{"name":"SetTheory.PGame.Identical.rfl","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ x.Identical x","decl":"protected theorem Identical.rfl {x} : x ≡ x := Identical.refl x\n\n"}
{"name":"SetTheory.PGame.Identical.symm","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝ : x.Identical y\n⊢ y.Identical x","decl":"@[symm] protected theorem Identical.symm : ∀ {x y}, x ≡ y → y ≡ x\n  | mk _ _ _ _, mk _ _ _ _, ⟨hL, hR⟩ => ⟨hL.symm fun _ _ h ↦ h.symm, hR.symm fun _ _ h ↦ h.symm⟩\n\n"}
{"name":"SetTheory.PGame.identical_comm","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.Identical y) (y.Identical x)","decl":"theorem identical_comm {x y} : x ≡ y ↔ y ≡ x :=\n  ⟨.symm, .symm⟩\n\n"}
{"name":"SetTheory.PGame.Identical.trans","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\na✝¹ : x.Identical y\na✝ : y.Identical z\n⊢ x.Identical z","decl":"@[trans] protected theorem Identical.trans : ∀ {x y z}, x ≡ y → y ≡ z → x ≡ z\n  | mk _ _ _ _, mk _ _ _ _, mk _ _ _ _, ⟨hL₁, hR₁⟩, ⟨hL₂, hR₂⟩ =>\n    ⟨hL₁.trans (fun _ _ _ h₁ h₂ ↦ h₁.trans h₂) hL₂, hR₁.trans (fun _ _ _ h₁ h₂ ↦ h₁.trans h₂) hR₂⟩\n\n"}
{"name":"SetTheory.PGame.memₗ_def","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.memₗ y) (Exists fun b => x.Identical (y.moveLeft b))","decl":"theorem memₗ_def {x y : PGame} : x ∈ₗ y ↔ ∃ b, x ≡ y.moveLeft b := .rfl\n"}
{"name":"SetTheory.PGame.memᵣ_def","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.memᵣ y) (Exists fun b => x.Identical (y.moveRight b))","decl":"theorem memᵣ_def {x y : PGame} : x ∈ᵣ y ↔ ∃ b, x ≡ y.moveRight b := .rfl\n"}
{"name":"SetTheory.PGame.moveLeft_memₗ","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nb : x.LeftMoves\n⊢ (x.moveLeft b).memₗ x","decl":"theorem moveLeft_memₗ (x : PGame) (b) : x.moveLeft b ∈ₗ x := ⟨_, .rfl⟩\n"}
{"name":"SetTheory.PGame.moveRight_memᵣ","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nb : x.RightMoves\n⊢ (x.moveRight b).memᵣ x","decl":"theorem moveRight_memᵣ (x : PGame) (b) : x.moveRight b ∈ᵣ x := ⟨_, .rfl⟩\n\n"}
{"name":"SetTheory.PGame.identical_of_isEmpty","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\ninst✝³ : IsEmpty x.LeftMoves\ninst✝² : IsEmpty x.RightMoves\ninst✝¹ : IsEmpty y.LeftMoves\ninst✝ : IsEmpty y.RightMoves\n⊢ x.Identical y","decl":"theorem identical_of_isEmpty (x y : PGame)\n    [IsEmpty x.LeftMoves] [IsEmpty x.RightMoves]\n    [IsEmpty y.LeftMoves] [IsEmpty y.RightMoves] : x ≡ y :=\n  identical_iff.2 (by simp [biTotal_empty])\n\n"}
{"name":"SetTheory.PGame.instIsReflIdentical","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ IsRefl SetTheory.PGame fun x1 x2 => x1.Identical x2","decl":"instance : IsRefl PGame (· ≡ ·) := ⟨Identical.refl⟩\n"}
{"name":"SetTheory.PGame.instIsSymmIdentical","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ IsSymm SetTheory.PGame fun x1 x2 => x1.Identical x2","decl":"instance : IsSymm PGame (· ≡ ·) := ⟨fun _ _ ↦ Identical.symm⟩\n"}
{"name":"SetTheory.PGame.instIsTransIdentical","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ IsTrans SetTheory.PGame fun x1 x2 => x1.Identical x2","decl":"instance : IsTrans PGame (· ≡ ·) := ⟨fun _ _ _ ↦ Identical.trans⟩\n"}
{"name":"SetTheory.PGame.instIsEquivIdentical","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ IsEquiv SetTheory.PGame fun x1 x2 => x1.Identical x2","decl":"instance : IsEquiv PGame (· ≡ ·) := { }\n\n"}
{"name":"SetTheory.PGame.Identical.moveLeft","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝ : x.Identical y\ni : x.LeftMoves\n⊢ Exists fun j => (x.moveLeft i).Identical (y.moveLeft j)","decl":"/-- If `x` and `y` are identical, then a left move of `x` is identical to some left move of `y`. -/\nlemma Identical.moveLeft : ∀ {x y}, x ≡ y →\n    ∀ i, ∃ j, x.moveLeft i ≡ y.moveLeft j\n  | mk _ _ _ _, mk _ _ _ _, ⟨hl, _⟩, i => hl.1 i\n\n"}
{"name":"SetTheory.PGame.Identical.moveRight","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝ : x.Identical y\ni : x.RightMoves\n⊢ Exists fun j => (x.moveRight i).Identical (y.moveRight j)","decl":"/-- If `x` and `y` are identical, then a right move of `x` is identical to some right move of `y`.\n-/\nlemma Identical.moveRight : ∀ {x y}, x ≡ y →\n    ∀ i, ∃ j, x.moveRight i ≡ y.moveRight j\n  | mk _ _ _ _, mk _ _ _ _, ⟨_, hr⟩, i => hr.1 i\n\n"}
{"name":"SetTheory.PGame.identical_of_eq","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : Eq x y\n⊢ x.Identical y","decl":"theorem identical_of_eq {x y : PGame} (h : x = y) : x ≡ y := by subst h; rfl\n\n"}
{"name":"SetTheory.PGame.identical_iff'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.Identical y) (And (And (∀ (i : x.LeftMoves), (x.moveLeft i).memₗ y) (∀ (j : y.LeftMoves), (y.moveLeft j).memₗ x)) (And (∀ (i : x.RightMoves), (x.moveRight i).memᵣ y) (∀ (j : y.RightMoves), (y.moveRight j).memᵣ x)))","decl":"/-- Uses `∈ₗ` and `∈ᵣ` instead of `≡`. -/\ntheorem identical_iff' : ∀ {x y : PGame}, x ≡ y ↔\n    ((∀ i, x.moveLeft i ∈ₗ y) ∧ (∀ j, y.moveLeft j ∈ₗ x)) ∧\n      ((∀ i, x.moveRight i ∈ᵣ y) ∧ (∀ j, y.moveRight j ∈ᵣ x))\n  | mk xl xr xL xR, mk yl yr yL yR => by\n    convert identical_iff <;>\n    dsimp [Relator.BiTotal, Relator.LeftTotal, Relator.RightTotal] <;>\n    congr! <;>\n    exact exists_congr <| fun _ ↦ identical_comm\n\n"}
{"name":"SetTheory.PGame.memₗ.congr_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝ : x.Identical y\nw : SetTheory.PGame\n⊢ Iff (w.memₗ x) (w.memₗ y)","decl":"theorem memₗ.congr_right : ∀ {x y : PGame},\n    x ≡ y → (∀ {w : PGame}, w ∈ₗ x ↔ w ∈ₗ y)\n  | mk _ _ _ _, mk _ _ _ _, ⟨⟨h₁, h₂⟩, _⟩, _w =>\n    ⟨fun ⟨i, hi⟩ ↦ (h₁ i).imp (fun _ ↦ hi.trans),\n      fun ⟨j, hj⟩ ↦ (h₂ j).imp (fun _ hi ↦ hj.trans hi.symm)⟩\n\n"}
{"name":"SetTheory.PGame.memᵣ.congr_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝ : x.Identical y\nw : SetTheory.PGame\n⊢ Iff (w.memᵣ x) (w.memᵣ y)","decl":"theorem memᵣ.congr_right : ∀ {x y : PGame},\n    x ≡ y → (∀ {w : PGame}, w ∈ᵣ x ↔ w ∈ᵣ y)\n  | mk _ _ _ _, mk _ _ _ _, ⟨_, ⟨h₁, h₂⟩⟩, _w =>\n    ⟨fun ⟨i, hi⟩ ↦ (h₁ i).imp (fun _ ↦ hi.trans),\n      fun ⟨j, hj⟩ ↦ (h₂ j).imp (fun _ hi ↦ hj.trans hi.symm)⟩\n\n"}
{"name":"SetTheory.PGame.memₗ.congr_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝ : x.Identical y\nw : SetTheory.PGame\n⊢ Iff (x.memₗ w) (y.memₗ w)","decl":"theorem memₗ.congr_left : ∀ {x y : PGame},\n    x ≡ y → (∀ {w : PGame}, x ∈ₗ w ↔ y ∈ₗ w)\n  | _, _, h, mk _ _ _ _ => ⟨fun ⟨i, hi⟩ ↦ ⟨i, h.symm.trans hi⟩, fun ⟨i, hi⟩ ↦ ⟨i, h.trans hi⟩⟩\n\n"}
{"name":"SetTheory.PGame.memᵣ.congr_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝ : x.Identical y\nw : SetTheory.PGame\n⊢ Iff (x.memᵣ w) (y.memᵣ w)","decl":"theorem memᵣ.congr_left : ∀ {x y : PGame},\n    x ≡ y → (∀ {w : PGame}, x ∈ᵣ w ↔ y ∈ᵣ w)\n  | _, _, h, mk _ _ _ _ => ⟨fun ⟨i, hi⟩ ↦ ⟨i, h.symm.trans hi⟩, fun ⟨i, hi⟩ ↦ ⟨i, h.trans hi⟩⟩\n\n"}
{"name":"SetTheory.PGame.Identical.ext","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝¹ : ∀ (z : SetTheory.PGame), Iff (z.memₗ x) (z.memₗ y)\na✝ : ∀ (z : SetTheory.PGame), Iff (z.memᵣ x) (z.memᵣ y)\n⊢ x.Identical y","decl":"lemma Identical.ext : ∀ {x y}, (∀ z, z ∈ₗ x ↔ z ∈ₗ y) → (∀ z, z ∈ᵣ x ↔ z ∈ᵣ y) → x ≡ y\n  | mk _ _ _ _, mk _ _ _ _, hl, hr => identical_iff'.mpr\n    ⟨⟨fun i ↦ (hl _).mp ⟨i, refl _⟩, fun j ↦ (hl _).mpr ⟨j, refl _⟩⟩,\n      ⟨fun i ↦ (hr _).mp ⟨i, refl _⟩, fun j ↦ (hr _).mpr ⟨j, refl _⟩⟩⟩\n\n"}
{"name":"SetTheory.PGame.Identical.ext_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.Identical y) (And (∀ (z : SetTheory.PGame), Iff (z.memₗ x) (z.memₗ y)) (∀ (z : SetTheory.PGame), Iff (z.memᵣ x) (z.memᵣ y)))","decl":"lemma Identical.ext_iff {x y} : x ≡ y ↔ (∀ z, z ∈ₗ x ↔ z ∈ₗ y) ∧ (∀ z, z ∈ᵣ x ↔ z ∈ᵣ y) :=\n  ⟨fun h ↦ ⟨@memₗ.congr_right _ _ h, @memᵣ.congr_right _ _ h⟩, fun h ↦ h.elim Identical.ext⟩\n\n"}
{"name":"SetTheory.PGame.Identical.congr_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh : x.Identical y\n⊢ Iff (z.Identical x) (z.Identical y)","decl":"lemma Identical.congr_right {x y z} (h : x ≡ y) : z ≡ x ↔ z ≡ y :=\n  ⟨fun hz ↦ hz.trans h, fun hz ↦ hz.trans h.symm⟩\n\n"}
{"name":"SetTheory.PGame.Identical.congr_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh : x.Identical y\n⊢ Iff (x.Identical z) (y.Identical z)","decl":"lemma Identical.congr_left {x y z} (h : x ≡ y) : x ≡ z ↔ y ≡ z :=\n  ⟨fun hz ↦ h.symm.trans hz, fun hz ↦ h.trans hz⟩\n\n"}
{"name":"SetTheory.PGame.Identical.of_fn","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nl : x.LeftMoves → y.LeftMoves\nil : y.LeftMoves → x.LeftMoves\nr : x.RightMoves → y.RightMoves\nir : y.RightMoves → x.RightMoves\nhl : ∀ (i : x.LeftMoves), (x.moveLeft i).Identical (y.moveLeft (l i))\nhil : ∀ (i : y.LeftMoves), (x.moveLeft (il i)).Identical (y.moveLeft i)\nhr : ∀ (i : x.RightMoves), (x.moveRight i).Identical (y.moveRight (r i))\nhir : ∀ (i : y.RightMoves), (x.moveRight (ir i)).Identical (y.moveRight i)\n⊢ x.Identical y","decl":"/-- Show `x ≡ y` by giving an explicit correspondence between the moves of `x` and `y`. -/\nlemma Identical.of_fn {x y : PGame}\n    (l : x.LeftMoves → y.LeftMoves) (il : y.LeftMoves → x.LeftMoves)\n    (r : x.RightMoves → y.RightMoves) (ir : y.RightMoves → x.RightMoves)\n    (hl : ∀ i, x.moveLeft i ≡ y.moveLeft (l i))\n    (hil : ∀ i, x.moveLeft (il i) ≡ y.moveLeft i)\n    (hr : ∀ i, x.moveRight i ≡ y.moveRight (r i))\n    (hir : ∀ i, x.moveRight (ir i) ≡ y.moveRight i) : x ≡ y :=\n  identical_iff.mpr\n    ⟨⟨fun i ↦ ⟨l i, hl i⟩, fun i ↦ ⟨il i, hil i⟩⟩, ⟨fun i ↦ ⟨r i, hr i⟩, fun i ↦ ⟨ir i, hir i⟩⟩⟩\n\n"}
{"name":"SetTheory.PGame.Identical.of_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nl : Equiv x.LeftMoves y.LeftMoves\nr : Equiv x.RightMoves y.RightMoves\nhl : ∀ (i : x.LeftMoves), (x.moveLeft i).Identical (y.moveLeft (l i))\nhr : ∀ (i : x.RightMoves), (x.moveRight i).Identical (y.moveRight (r i))\n⊢ x.Identical y","decl":"lemma Identical.of_equiv {x y : PGame}\n    (l : x.LeftMoves ≃ y.LeftMoves) (r : x.RightMoves ≃ y.RightMoves)\n    (hl : ∀ i, x.moveLeft i ≡ y.moveLeft (l i)) (hr : ∀ i, x.moveRight i ≡ y.moveRight (r i)) :\n    x ≡ y :=\n  .of_fn l l.symm r r.symm hl (by simpa using hl <| l.symm ·) hr (by simpa using hr <| r.symm ·)\n\n"}
{"name":"SetTheory.PGame.not_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (Not (LE.le x y)) (y.LF x)","decl":"@[simp]\nprotected theorem not_le {x y : PGame} : ¬x ≤ y ↔ y ⧏ x :=\n  Iff.rfl\n\n"}
{"name":"SetTheory.PGame.not_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (Not (x.LF y)) (LE.le y x)","decl":"@[simp]\ntheorem not_lf {x y : PGame} : ¬x ⧏ y ↔ y ≤ x :=\n  Classical.not_not\n\n"}
{"name":"LE.le.not_gf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝ : LE.le x y\n⊢ Not (y.LF x)","decl":"theorem _root_.LE.le.not_gf {x y : PGame} : x ≤ y → ¬y ⧏ x :=\n  not_lf.2\n\n"}
{"name":"SetTheory.PGame.LF.not_ge","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝ : x.LF y\n⊢ Not (LE.le y x)","decl":"theorem LF.not_ge {x y : PGame} : x ⧏ y → ¬y ≤ x :=\n  id\n\n"}
{"name":"SetTheory.PGame.le_iff_forall_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (LE.le x y) (And (∀ (i : x.LeftMoves), (x.moveLeft i).LF y) (∀ (j : y.RightMoves), x.LF (y.moveRight j)))","decl":"/-- Definition of `x ≤ y` on pre-games, in terms of `⧏`.\n\nThe ordering here is chosen so that `And.left` refer to moves by Left, and `And.right` refer to\nmoves by Right. -/\ntheorem le_iff_forall_lf {x y : PGame} :\n    x ≤ y ↔ (∀ i, x.moveLeft i ⧏ y) ∧ ∀ j, x ⧏ y.moveRight j := by\n  unfold LE.le le\n  simp only\n  rw [Sym2.GameAdd.fix_eq]\n  rfl\n\n"}
{"name":"SetTheory.PGame.mk_le_mk","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyl yr : Type u_1\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\n⊢ Iff (LE.le (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR)) (And (∀ (i : xl), (xL i).LF (SetTheory.PGame.mk yl yr yL yR)) (∀ (j : yr), (SetTheory.PGame.mk xl xr xL xR).LF (yR j)))","decl":"/-- Definition of `x ≤ y` on pre-games built using the constructor. -/\n@[simp]\ntheorem mk_le_mk {xl xr xL xR yl yr yL yR} :\n    mk xl xr xL xR ≤ mk yl yr yL yR ↔ (∀ i, xL i ⧏ mk yl yr yL yR) ∧ ∀ j, mk xl xr xL xR ⧏ yR j :=\n  le_iff_forall_lf\n\n"}
{"name":"SetTheory.PGame.le_of_forall_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh₁ : ∀ (i : x.LeftMoves), (x.moveLeft i).LF y\nh₂ : ∀ (j : y.RightMoves), x.LF (y.moveRight j)\n⊢ LE.le x y","decl":"theorem le_of_forall_lf {x y : PGame} (h₁ : ∀ i, x.moveLeft i ⧏ y) (h₂ : ∀ j, x ⧏ y.moveRight j) :\n    x ≤ y :=\n  le_iff_forall_lf.2 ⟨h₁, h₂⟩\n\n"}
{"name":"SetTheory.PGame.lf_iff_exists_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.LF y) (Or (Exists fun i => LE.le x (y.moveLeft i)) (Exists fun j => LE.le (x.moveRight j) y))","decl":"/-- Definition of `x ⧏ y` on pre-games, in terms of `≤`.\n\nThe ordering here is chosen so that `or.inl` refer to moves by Left, and `or.inr` refer to\nmoves by Right. -/\ntheorem lf_iff_exists_le {x y : PGame} :\n    x ⧏ y ↔ (∃ i, x ≤ y.moveLeft i) ∨ ∃ j, x.moveRight j ≤ y := by\n  rw [LF, le_iff_forall_lf, not_and_or]\n  simp\n\n"}
{"name":"SetTheory.PGame.mk_lf_mk","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyl yr : Type u_1\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\n⊢ Iff ((SetTheory.PGame.mk xl xr xL xR).LF (SetTheory.PGame.mk yl yr yL yR)) (Or (Exists fun i => LE.le (SetTheory.PGame.mk xl xr xL xR) (yL i)) (Exists fun j => LE.le (xR j) (SetTheory.PGame.mk yl yr yL yR)))","decl":"/-- Definition of `x ⧏ y` on pre-games built using the constructor. -/\n@[simp]\ntheorem mk_lf_mk {xl xr xL xR yl yr yL yR} :\n    mk xl xr xL xR ⧏ mk yl yr yL yR ↔ (∃ i, mk xl xr xL xR ≤ yL i) ∨ ∃ j, xR j ≤ mk yl yr yL yR :=\n  lf_iff_exists_le\n\n"}
{"name":"SetTheory.PGame.le_or_gf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Or (LE.le x y) (y.LF x)","decl":"theorem le_or_gf (x y : PGame) : x ≤ y ∨ y ⧏ x := by\n  rw [← PGame.not_le]\n  apply em\n\n"}
{"name":"SetTheory.PGame.moveLeft_lf_of_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : LE.le x y\ni : x.LeftMoves\n⊢ (x.moveLeft i).LF y","decl":"theorem moveLeft_lf_of_le {x y : PGame} (h : x ≤ y) (i) : x.moveLeft i ⧏ y :=\n  (le_iff_forall_lf.1 h).1 i\n\n"}
{"name":"LE.le.moveLeft_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : LE.le x y\ni : x.LeftMoves\n⊢ (x.moveLeft i).LF y","decl":"alias _root_.LE.le.moveLeft_lf := moveLeft_lf_of_le\n\n"}
{"name":"SetTheory.PGame.lf_moveRight_of_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : LE.le x y\nj : y.RightMoves\n⊢ x.LF (y.moveRight j)","decl":"theorem lf_moveRight_of_le {x y : PGame} (h : x ≤ y) (j) : x ⧏ y.moveRight j :=\n  (le_iff_forall_lf.1 h).2 j\n\n"}
{"name":"LE.le.lf_moveRight","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : LE.le x y\nj : y.RightMoves\n⊢ x.LF (y.moveRight j)","decl":"alias _root_.LE.le.lf_moveRight := lf_moveRight_of_le\n\n"}
{"name":"SetTheory.PGame.lf_of_moveRight_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nj : x.RightMoves\nh : LE.le (x.moveRight j) y\n⊢ x.LF y","decl":"theorem lf_of_moveRight_le {x y : PGame} {j} (h : x.moveRight j ≤ y) : x ⧏ y :=\n  lf_iff_exists_le.2 <| Or.inr ⟨j, h⟩\n\n"}
{"name":"SetTheory.PGame.lf_of_le_moveLeft","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\ni : y.LeftMoves\nh : LE.le x (y.moveLeft i)\n⊢ x.LF y","decl":"theorem lf_of_le_moveLeft {x y : PGame} {i} (h : x ≤ y.moveLeft i) : x ⧏ y :=\n  lf_iff_exists_le.2 <| Or.inl ⟨i, h⟩\n\n"}
{"name":"SetTheory.PGame.lf_of_le_mk","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\ny : SetTheory.PGame\na✝ : LE.le (SetTheory.PGame.mk xl xr xL xR) y\ni : xl\n⊢ (xL i).LF y","decl":"theorem lf_of_le_mk {xl xr xL xR y} : mk xl xr xL xR ≤ y → ∀ i, xL i ⧏ y :=\n  moveLeft_lf_of_le\n\n"}
{"name":"SetTheory.PGame.lf_of_mk_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nyl yr : Type u_1\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\na✝ : LE.le x (SetTheory.PGame.mk yl yr yL yR)\nj : yr\n⊢ x.LF (yR j)","decl":"theorem lf_of_mk_le {x yl yr yL yR} : x ≤ mk yl yr yL yR → ∀ j, x ⧏ yR j :=\n  lf_moveRight_of_le\n\n"}
{"name":"SetTheory.PGame.mk_lf_of_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u_1\ny : SetTheory.PGame\nj : xr\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\na✝ : LE.le (xR j) y\n⊢ (SetTheory.PGame.mk xl xr xL xR).LF y","decl":"theorem mk_lf_of_le {xl xr y j} (xL) {xR : xr → PGame} : xR j ≤ y → mk xl xr xL xR ⧏ y :=\n  @lf_of_moveRight_le (mk _ _ _ _) y j\n\n"}
{"name":"SetTheory.PGame.lf_mk_of_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nyl yr : Type u_1\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : yl\na✝ : LE.le x (yL i)\n⊢ x.LF (SetTheory.PGame.mk yl yr yL yR)","decl":"theorem lf_mk_of_le {x yl yr} {yL : yl → PGame} (yR) {i} : x ≤ yL i → x ⧏ mk yl yr yL yR :=\n  @lf_of_le_moveLeft x (mk _ _ _ _) i\n\n/- We prove that `x ≤ y → y ≤ z → x ≤ z` inductively, by also simultaneously proving its cyclic\nreorderings. This auxiliary lemma is used during said induction. -/\n"}
{"name":"SetTheory.PGame.Identical.le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝ : x.Identical y\n⊢ LE.le x y","decl":"lemma Identical.le : ∀ {x y}, x ≡ y → x ≤ y\n  | mk _ _ _ _, mk _ _ _ _, ⟨hL, hR⟩ => le_of_forall_lf\n    (fun i ↦ let ⟨_, hj⟩ := hL.1 i; lf_of_le_moveLeft hj.le)\n    (fun i ↦ let ⟨_, hj⟩ := hR.2 i; lf_of_moveRight_le hj.le)\n\n"}
{"name":"SetTheory.PGame.Identical.ge","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : x.Identical y\n⊢ LE.le y x","decl":"lemma Identical.ge {x y} (h : x ≡ y) : y ≤ x := h.symm.le\n\n"}
{"name":"SetTheory.PGame.lt_iff_le_and_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (LT.lt x y) (And (LE.le x y) (x.LF y))","decl":"theorem lt_iff_le_and_lf {x y : PGame} : x < y ↔ x ≤ y ∧ x ⧏ y :=\n  Iff.rfl\n\n"}
{"name":"SetTheory.PGame.lt_of_le_of_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh₁ : LE.le x y\nh₂ : x.LF y\n⊢ LT.lt x y","decl":"theorem lt_of_le_of_lf {x y : PGame} (h₁ : x ≤ y) (h₂ : x ⧏ y) : x < y :=\n  ⟨h₁, h₂⟩\n\n"}
{"name":"SetTheory.PGame.lf_of_lt","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : LT.lt x y\n⊢ x.LF y","decl":"theorem lf_of_lt {x y : PGame} (h : x < y) : x ⧏ y :=\n  h.2\n\n"}
{"name":"LT.lt.lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : LT.lt x y\n⊢ x.LF y","decl":"alias _root_.LT.lt.lf := lf_of_lt\n\n"}
{"name":"SetTheory.PGame.lf_irrefl","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Not (x.LF x)","decl":"theorem lf_irrefl (x : PGame) : ¬x ⧏ x :=\n  le_rfl.not_gf\n\n"}
{"name":"SetTheory.PGame.instIsIrreflLF","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ IsIrrefl SetTheory.PGame fun x1 x2 => x1.LF x2","decl":"instance : IsIrrefl _ (· ⧏ ·) :=\n  ⟨lf_irrefl⟩\n\n"}
{"name":"SetTheory.PGame.not_lt","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (Not (LT.lt x y)) (Or (y.LF x) (LE.le y x))","decl":"protected theorem not_lt {x y : PGame} : ¬ x < y ↔ y ⧏ x ∨ y ≤ x := not_lt_iff_not_le_or_ge\n\n"}
{"name":"SetTheory.PGame.lf_of_le_of_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : LE.le x y\nh₂ : y.LF z\n⊢ x.LF z","decl":"@[trans]\ntheorem lf_of_le_of_lf {x y z : PGame} (h₁ : x ≤ y) (h₂ : y ⧏ z) : x ⧏ z := by\n  rw [← PGame.not_le] at h₂ ⊢\n  exact fun h₃ => h₂ (h₃.trans h₁)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10754): added instance\n"}
{"name":"SetTheory.PGame.lf_of_lf_of_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : x.LF y\nh₂ : LE.le y z\n⊢ x.LF z","decl":"@[trans]\ntheorem lf_of_lf_of_le {x y z : PGame} (h₁ : x ⧏ y) (h₂ : y ≤ z) : x ⧏ z := by\n  rw [← PGame.not_le] at h₁ ⊢\n  exact fun h₃ => h₁ (h₂.trans h₃)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10754): added instance\n"}
{"name":"LE.le.trans_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : LE.le x y\nh₂ : y.LF z\n⊢ x.LF z","decl":"alias _root_.LE.le.trans_lf := lf_of_le_of_lf\n\n"}
{"name":"SetTheory.PGame.LF.trans_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : x.LF y\nh₂ : LE.le y z\n⊢ x.LF z","decl":"alias LF.trans_le := lf_of_lf_of_le\n\n"}
{"name":"SetTheory.PGame.lf_of_lt_of_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : LT.lt x y\nh₂ : y.LF z\n⊢ x.LF z","decl":"@[trans]\ntheorem lf_of_lt_of_lf {x y z : PGame} (h₁ : x < y) (h₂ : y ⧏ z) : x ⧏ z :=\n  h₁.le.trans_lf h₂\n\n"}
{"name":"SetTheory.PGame.lf_of_lf_of_lt","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : x.LF y\nh₂ : LT.lt y z\n⊢ x.LF z","decl":"@[trans]\ntheorem lf_of_lf_of_lt {x y z : PGame} (h₁ : x ⧏ y) (h₂ : y < z) : x ⧏ z :=\n  h₁.trans_le h₂.le\n\n"}
{"name":"LT.lt.trans_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : LT.lt x y\nh₂ : y.LF z\n⊢ x.LF z","decl":"alias _root_.LT.lt.trans_lf := lf_of_lt_of_lf\n\n"}
{"name":"SetTheory.PGame.LF.trans_lt","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : x.LF y\nh₂ : LT.lt y z\n⊢ x.LF z","decl":"alias LF.trans_lt := lf_of_lf_of_lt\n\n"}
{"name":"SetTheory.PGame.moveLeft_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ni : x.LeftMoves\n⊢ (x.moveLeft i).LF x","decl":"theorem moveLeft_lf {x : PGame} : ∀ i, x.moveLeft i ⧏ x :=\n  le_rfl.moveLeft_lf\n\n"}
{"name":"SetTheory.PGame.lf_moveRight","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nj : x.RightMoves\n⊢ x.LF (x.moveRight j)","decl":"theorem lf_moveRight {x : PGame} : ∀ j, x ⧏ x.moveRight j :=\n  le_rfl.lf_moveRight\n\n"}
{"name":"SetTheory.PGame.lf_mk","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\ni : xl\n⊢ (xL i).LF (SetTheory.PGame.mk xl xr xL xR)","decl":"theorem lf_mk {xl xr} (xL : xl → PGame) (xR : xr → PGame) (i) : xL i ⧏ mk xl xr xL xR :=\n  @moveLeft_lf (mk _ _ _ _) i\n\n"}
{"name":"SetTheory.PGame.mk_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nj : xr\n⊢ (SetTheory.PGame.mk xl xr xL xR).LF (xR j)","decl":"theorem mk_lf {xl xr} (xL : xl → PGame) (xR : xr → PGame) (j) : mk xl xr xL xR ⧏ xR j :=\n  @lf_moveRight (mk _ _ _ _) j\n\n"}
{"name":"SetTheory.PGame.le_of_forall_lt","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh₁ : ∀ (i : x.LeftMoves), LT.lt (x.moveLeft i) y\nh₂ : ∀ (j : y.RightMoves), LT.lt x (y.moveRight j)\n⊢ LE.le x y","decl":"/-- This special case of `PGame.le_of_forall_lf` is useful when dealing with surreals, where `<` is\npreferred over `⧏`. -/\ntheorem le_of_forall_lt {x y : PGame} (h₁ : ∀ i, x.moveLeft i < y) (h₂ : ∀ j, x < y.moveRight j) :\n    x ≤ y :=\n  le_of_forall_lf (fun i => (h₁ i).lf) fun i => (h₂ i).lf\n\n"}
{"name":"SetTheory.PGame.le_def","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (LE.le x y) (And (∀ (i : x.LeftMoves), Or (Exists fun i' => LE.le (x.moveLeft i) (y.moveLeft i')) (Exists fun j => LE.le ((x.moveLeft i).moveRight j) y)) (∀ (j : y.RightMoves), Or (Exists fun i => LE.le x ((y.moveRight j).moveLeft i)) (Exists fun j' => LE.le (x.moveRight j') (y.moveRight j))))","decl":"/-- The definition of `x ≤ y` on pre-games, in terms of `≤` two moves later.\n\nNote that it's often more convenient to use `le_iff_forall_lf`, which only unfolds the definition by\none step. -/\ntheorem le_def {x y : PGame} :\n    x ≤ y ↔\n      (∀ i, (∃ i', x.moveLeft i ≤ y.moveLeft i') ∨ ∃ j, (x.moveLeft i).moveRight j ≤ y) ∧\n        ∀ j, (∃ i, x ≤ (y.moveRight j).moveLeft i) ∨ ∃ j', x.moveRight j' ≤ y.moveRight j := by\n  rw [le_iff_forall_lf]\n  conv =>\n    lhs\n    simp only [lf_iff_exists_le]\n\n"}
{"name":"SetTheory.PGame.lf_def","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.LF y) (Or (Exists fun i => And (∀ (i' : x.LeftMoves), (x.moveLeft i').LF (y.moveLeft i)) (∀ (j : (y.moveLeft i).RightMoves), x.LF ((y.moveLeft i).moveRight j))) (Exists fun j => And (∀ (i : (x.moveRight j).LeftMoves), ((x.moveRight j).moveLeft i).LF y) (∀ (j' : y.RightMoves), (x.moveRight j).LF (y.moveRight j'))))","decl":"/-- The definition of `x ⧏ y` on pre-games, in terms of `⧏` two moves later.\n\nNote that it's often more convenient to use `lf_iff_exists_le`, which only unfolds the definition by\none step. -/\ntheorem lf_def {x y : PGame} :\n    x ⧏ y ↔\n      (∃ i, (∀ i', x.moveLeft i' ⧏ y.moveLeft i) ∧ ∀ j, x ⧏ (y.moveLeft i).moveRight j) ∨\n        ∃ j, (∀ i, (x.moveRight j).moveLeft i ⧏ y) ∧ ∀ j', x.moveRight j ⧏ y.moveRight j' := by\n  rw [lf_iff_exists_le]\n  conv =>\n    lhs\n    simp only [le_iff_forall_lf]\n\n"}
{"name":"SetTheory.PGame.zero_le_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (LE.le 0 x) (∀ (j : x.RightMoves), SetTheory.PGame.LF 0 (x.moveRight j))","decl":"/-- The definition of `0 ≤ x` on pre-games, in terms of `0 ⧏`. -/\ntheorem zero_le_lf {x : PGame} : 0 ≤ x ↔ ∀ j, 0 ⧏ x.moveRight j := by\n  rw [le_iff_forall_lf]\n  simp\n\n"}
{"name":"SetTheory.PGame.le_zero_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (LE.le x 0) (∀ (i : x.LeftMoves), (x.moveLeft i).LF 0)","decl":"/-- The definition of `x ≤ 0` on pre-games, in terms of `⧏ 0`. -/\ntheorem le_zero_lf {x : PGame} : x ≤ 0 ↔ ∀ i, x.moveLeft i ⧏ 0 := by\n  rw [le_iff_forall_lf]\n  simp\n\n"}
{"name":"SetTheory.PGame.zero_lf_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (SetTheory.PGame.LF 0 x) (Exists fun i => LE.le 0 (x.moveLeft i))","decl":"/-- The definition of `0 ⧏ x` on pre-games, in terms of `0 ≤`. -/\ntheorem zero_lf_le {x : PGame} : 0 ⧏ x ↔ ∃ i, 0 ≤ x.moveLeft i := by\n  rw [lf_iff_exists_le]\n  simp\n\n"}
{"name":"SetTheory.PGame.lf_zero_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (x.LF 0) (Exists fun j => LE.le (x.moveRight j) 0)","decl":"/-- The definition of `x ⧏ 0` on pre-games, in terms of `≤ 0`. -/\ntheorem lf_zero_le {x : PGame} : x ⧏ 0 ↔ ∃ j, x.moveRight j ≤ 0 := by\n  rw [lf_iff_exists_le]\n  simp\n\n"}
{"name":"SetTheory.PGame.zero_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (LE.le 0 x) (∀ (j : x.RightMoves), Exists fun i => LE.le 0 ((x.moveRight j).moveLeft i))","decl":"/-- The definition of `0 ≤ x` on pre-games, in terms of `0 ≤` two moves later. -/\ntheorem zero_le {x : PGame} : 0 ≤ x ↔ ∀ j, ∃ i, 0 ≤ (x.moveRight j).moveLeft i := by\n  rw [le_def]\n  simp\n\n"}
{"name":"SetTheory.PGame.le_zero","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (LE.le x 0) (∀ (i : x.LeftMoves), Exists fun j => LE.le ((x.moveLeft i).moveRight j) 0)","decl":"/-- The definition of `x ≤ 0` on pre-games, in terms of `≤ 0` two moves later. -/\ntheorem le_zero {x : PGame} : x ≤ 0 ↔ ∀ i, ∃ j, (x.moveLeft i).moveRight j ≤ 0 := by\n  rw [le_def]\n  simp\n\n"}
{"name":"SetTheory.PGame.zero_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (SetTheory.PGame.LF 0 x) (Exists fun i => ∀ (j : (x.moveLeft i).RightMoves), SetTheory.PGame.LF 0 ((x.moveLeft i).moveRight j))","decl":"/-- The definition of `0 ⧏ x` on pre-games, in terms of `0 ⧏` two moves later. -/\ntheorem zero_lf {x : PGame} : 0 ⧏ x ↔ ∃ i, ∀ j, 0 ⧏ (x.moveLeft i).moveRight j := by\n  rw [lf_def]\n  simp\n\n"}
{"name":"SetTheory.PGame.lf_zero","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (x.LF 0) (Exists fun j => ∀ (i : (x.moveRight j).LeftMoves), ((x.moveRight j).moveLeft i).LF 0)","decl":"/-- The definition of `x ⧏ 0` on pre-games, in terms of `⧏ 0` two moves later. -/\ntheorem lf_zero {x : PGame} : x ⧏ 0 ↔ ∃ j, ∀ i, (x.moveRight j).moveLeft i ⧏ 0 := by\n  rw [lf_def]\n  simp\n\n"}
{"name":"SetTheory.PGame.zero_le_of_isEmpty_rightMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ninst✝ : IsEmpty x.RightMoves\n⊢ LE.le 0 x","decl":"@[simp]\ntheorem zero_le_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves] : 0 ≤ x :=\n  zero_le.2 isEmptyElim\n\n"}
{"name":"SetTheory.PGame.le_zero_of_isEmpty_leftMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ninst✝ : IsEmpty x.LeftMoves\n⊢ LE.le x 0","decl":"@[simp]\ntheorem le_zero_of_isEmpty_leftMoves (x : PGame) [IsEmpty x.LeftMoves] : x ≤ 0 :=\n  le_zero.2 isEmptyElim\n\n"}
{"name":"SetTheory.PGame.rightResponse_spec","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nh : LE.le x 0\ni : x.LeftMoves\n⊢ LE.le ((x.moveLeft i).moveRight (SetTheory.PGame.rightResponse h i)) 0","decl":"/-- Show that the response for right provided by `rightResponse` preserves the right-player-wins\ncondition. -/\ntheorem rightResponse_spec {x : PGame} (h : x ≤ 0) (i : x.LeftMoves) :\n    (x.moveLeft i).moveRight (rightResponse h i) ≤ 0 :=\n  Classical.choose_spec <| (le_zero.1 h) i\n\n"}
{"name":"SetTheory.PGame.leftResponse_spec","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nh : LE.le 0 x\nj : x.RightMoves\n⊢ LE.le 0 ((x.moveRight j).moveLeft (SetTheory.PGame.leftResponse h j))","decl":"/-- Show that the response for left provided by `leftResponse` preserves the left-player-wins\ncondition. -/\ntheorem leftResponse_spec {x : PGame} (h : 0 ≤ x) (j : x.RightMoves) :\n    0 ≤ (x.moveRight j).moveLeft (leftResponse h j) :=\n  Classical.choose_spec <| (zero_le.1 h) j\n\n"}
{"name":"SetTheory.PGame.bddAbove_range_of_small","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"ι : Type u_1\ninst✝ : Small.{u, u_1} ι\nf : ι → SetTheory.PGame\n⊢ BddAbove (Set.range f)","decl":"/-- A small family of pre-games is bounded above. -/\nlemma bddAbove_range_of_small {ι : Type*} [Small.{u} ι] (f : ι → PGame.{u}) :\n    BddAbove (Set.range f) := by\n  let x : PGame.{u} := ⟨Σ i, (f <| (equivShrink.{u} ι).symm i).LeftMoves, PEmpty,\n    fun x ↦ moveLeft _ x.2, PEmpty.elim⟩\n  refine ⟨x, Set.forall_mem_range.2 fun i ↦ ?_⟩\n  rw [← (equivShrink ι).symm_apply_apply i, le_iff_forall_lf]\n  simpa [x] using fun j ↦ @moveLeft_lf x ⟨equivShrink ι i, j⟩\n\n"}
{"name":"SetTheory.PGame.bddAbove_of_small","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"s : Set SetTheory.PGame\ninst✝ : Small.{u, u + 1} ↑s\n⊢ BddAbove s","decl":"/-- A small set of pre-games is bounded above. -/\nlemma bddAbove_of_small (s : Set PGame.{u}) [Small.{u} s] : BddAbove s := by\n  simpa using bddAbove_range_of_small (Subtype.val : s → PGame.{u})\n\n"}
{"name":"SetTheory.PGame.bddBelow_range_of_small","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"ι : Type u_1\ninst✝ : Small.{u, u_1} ι\nf : ι → SetTheory.PGame\n⊢ BddBelow (Set.range f)","decl":"/-- A small family of pre-games is bounded below. -/\nlemma bddBelow_range_of_small {ι : Type*} [Small.{u} ι] (f : ι → PGame.{u}) :\n    BddBelow (Set.range f) := by\n  let x : PGame.{u} := ⟨PEmpty, Σ i, (f <| (equivShrink.{u} ι).symm i).RightMoves, PEmpty.elim,\n    fun x ↦ moveRight _ x.2⟩\n  refine ⟨x, Set.forall_mem_range.2 fun i ↦ ?_⟩\n  rw [← (equivShrink ι).symm_apply_apply i, le_iff_forall_lf]\n  simpa [x] using fun j ↦ @lf_moveRight x ⟨equivShrink ι i, j⟩\n\n"}
{"name":"SetTheory.PGame.bddBelow_of_small","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"s : Set SetTheory.PGame\ninst✝ : Small.{u, u + 1} ↑s\n⊢ BddBelow s","decl":"/-- A small set of pre-games is bounded below. -/\nlemma bddBelow_of_small (s : Set PGame.{u}) [Small.{u} s] : BddBelow s := by\n  simpa using bddBelow_range_of_small (Subtype.val : s → PGame.{u})\n\n"}
{"name":"SetTheory.PGame.instIsEquivEquiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ IsEquiv SetTheory.PGame SetTheory.PGame.Equiv","decl":"instance : IsEquiv _ PGame.Equiv where\n  refl _ := ⟨le_rfl, le_rfl⟩\n  trans := fun _ _ _ ⟨xy, yx⟩ ⟨yz, zy⟩ => ⟨xy.trans yz, zy.trans yx⟩\n  symm _ _ := And.symm\n\n-- Porting note: moved the setoid instance from Basic.lean to here\n\n"}
{"name":"SetTheory.PGame.equiv_def","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (HasEquiv.Equiv x y) (And (LE.le x y) (LE.le y x))","decl":"theorem equiv_def {x y : PGame} : x ≈ y ↔ x ≤ y ∧ y ≤ x := Iff.rfl\n\n"}
{"name":"SetTheory.PGame.Equiv.le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : HasEquiv.Equiv x y\n⊢ LE.le x y","decl":"theorem Equiv.le {x y : PGame} (h : x ≈ y) : x ≤ y :=\n  h.1\n\n"}
{"name":"SetTheory.PGame.Equiv.ge","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : HasEquiv.Equiv x y\n⊢ LE.le y x","decl":"theorem Equiv.ge {x y : PGame} (h : x ≈ y) : y ≤ x :=\n  h.2\n\n"}
{"name":"SetTheory.PGame.equiv_rfl","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ HasEquiv.Equiv x x","decl":"@[refl, simp]\ntheorem equiv_rfl {x : PGame} : x ≈ x :=\n  refl x\n\n"}
{"name":"SetTheory.PGame.equiv_refl","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ HasEquiv.Equiv x x","decl":"theorem equiv_refl (x : PGame) : x ≈ x :=\n  refl x\n\n"}
{"name":"SetTheory.PGame.Equiv.symm","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝ : HasEquiv.Equiv x y\n⊢ HasEquiv.Equiv y x","decl":"@[symm]\nprotected theorem Equiv.symm {x y : PGame} : (x ≈ y) → (y ≈ x) :=\n  symm\n\n"}
{"name":"SetTheory.PGame.Equiv.trans","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\na✝¹ : HasEquiv.Equiv x y\na✝ : HasEquiv.Equiv y z\n⊢ HasEquiv.Equiv x z","decl":"@[trans]\nprotected theorem Equiv.trans {x y z : PGame} : (x ≈ y) → (y ≈ z) → (x ≈ z) :=\n  _root_.trans\n\n"}
{"name":"SetTheory.PGame.equiv_comm","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (HasEquiv.Equiv x y) (HasEquiv.Equiv y x)","decl":"protected theorem equiv_comm {x y : PGame} : (x ≈ y) ↔ (y ≈ x) :=\n  comm\n\n"}
{"name":"SetTheory.PGame.equiv_of_eq","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : Eq x y\n⊢ HasEquiv.Equiv x y","decl":"theorem equiv_of_eq {x y : PGame} (h : x = y) : x ≈ y := by subst h; rfl\n\n"}
{"name":"SetTheory.PGame.Identical.equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : x.Identical y\n⊢ HasEquiv.Equiv x y","decl":"lemma Identical.equiv {x y} (h : x ≡ y) : x ≈ y := ⟨h.le, h.ge⟩\n\n"}
{"name":"SetTheory.PGame.le_of_le_of_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : LE.le x y\nh₂ : HasEquiv.Equiv y z\n⊢ LE.le x z","decl":"@[trans]\ntheorem le_of_le_of_equiv {x y z : PGame} (h₁ : x ≤ y) (h₂ : y ≈ z) : x ≤ z :=\n  h₁.trans h₂.1\n\n"}
{"name":"SetTheory.PGame.le_of_equiv_of_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : HasEquiv.Equiv x y\na✝ : LE.le y z\n⊢ LE.le x z","decl":"@[trans]\ntheorem le_of_equiv_of_le {x y z : PGame} (h₁ : x ≈ y) : y ≤ z → x ≤ z :=\n  h₁.1.trans\n\n"}
{"name":"SetTheory.PGame.LF.not_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : x.LF y\n⊢ Not (HasEquiv.Equiv x y)","decl":"theorem LF.not_equiv {x y : PGame} (h : x ⧏ y) : ¬(x ≈ y) := fun h' => h.not_ge h'.2\n\n"}
{"name":"SetTheory.PGame.LF.not_equiv'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : x.LF y\n⊢ Not (HasEquiv.Equiv y x)","decl":"theorem LF.not_equiv' {x y : PGame} (h : x ⧏ y) : ¬(y ≈ x) := fun h' => h.not_ge h'.1\n\n"}
{"name":"SetTheory.PGame.LF.not_gt","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : x.LF y\n⊢ Not (LT.lt y x)","decl":"theorem LF.not_gt {x y : PGame} (h : x ⧏ y) : ¬y < x := fun h' => h.not_ge h'.le\n\n"}
{"name":"SetTheory.PGame.le_congr_imp","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ y₁ x₂ y₂ : SetTheory.PGame\nhx : HasEquiv.Equiv x₁ x₂\nhy : HasEquiv.Equiv y₁ y₂\nh : LE.le x₁ y₁\n⊢ LE.le x₂ y₂","decl":"theorem le_congr_imp {x₁ y₁ x₂ y₂ : PGame} (hx : x₁ ≈ x₂) (hy : y₁ ≈ y₂) (h : x₁ ≤ y₁) : x₂ ≤ y₂ :=\n  hx.2.trans (h.trans hy.1)\n\n"}
{"name":"SetTheory.PGame.le_congr","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ y₁ x₂ y₂ : SetTheory.PGame\nhx : HasEquiv.Equiv x₁ x₂\nhy : HasEquiv.Equiv y₁ y₂\n⊢ Iff (LE.le x₁ y₁) (LE.le x₂ y₂)","decl":"theorem le_congr {x₁ y₁ x₂ y₂ : PGame} (hx : x₁ ≈ x₂) (hy : y₁ ≈ y₂) : x₁ ≤ y₁ ↔ x₂ ≤ y₂ :=\n  ⟨le_congr_imp hx hy, le_congr_imp (Equiv.symm hx) (Equiv.symm hy)⟩\n\n"}
{"name":"SetTheory.PGame.le_congr_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ x₂ y : SetTheory.PGame\nhx : HasEquiv.Equiv x₁ x₂\n⊢ Iff (LE.le x₁ y) (LE.le x₂ y)","decl":"theorem le_congr_left {x₁ x₂ y : PGame} (hx : x₁ ≈ x₂) : x₁ ≤ y ↔ x₂ ≤ y :=\n  le_congr hx equiv_rfl\n\n"}
{"name":"SetTheory.PGame.le_congr_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y₁ y₂ : SetTheory.PGame\nhy : HasEquiv.Equiv y₁ y₂\n⊢ Iff (LE.le x y₁) (LE.le x y₂)","decl":"theorem le_congr_right {x y₁ y₂ : PGame} (hy : y₁ ≈ y₂) : x ≤ y₁ ↔ x ≤ y₂ :=\n  le_congr equiv_rfl hy\n\n"}
{"name":"SetTheory.PGame.lf_congr","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ y₁ x₂ y₂ : SetTheory.PGame\nhx : HasEquiv.Equiv x₁ x₂\nhy : HasEquiv.Equiv y₁ y₂\n⊢ Iff (x₁.LF y₁) (x₂.LF y₂)","decl":"theorem lf_congr {x₁ y₁ x₂ y₂ : PGame} (hx : x₁ ≈ x₂) (hy : y₁ ≈ y₂) : x₁ ⧏ y₁ ↔ x₂ ⧏ y₂ :=\n  PGame.not_le.symm.trans <| (not_congr (le_congr hy hx)).trans PGame.not_le\n\n"}
{"name":"SetTheory.PGame.lf_congr_imp","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ y₁ x₂ y₂ : SetTheory.PGame\nhx : HasEquiv.Equiv x₁ x₂\nhy : HasEquiv.Equiv y₁ y₂\na✝ : x₁.LF y₁\n⊢ x₂.LF y₂","decl":"theorem lf_congr_imp {x₁ y₁ x₂ y₂ : PGame} (hx : x₁ ≈ x₂) (hy : y₁ ≈ y₂) : x₁ ⧏ y₁ → x₂ ⧏ y₂ :=\n  (lf_congr hx hy).1\n\n"}
{"name":"SetTheory.PGame.lf_congr_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ x₂ y : SetTheory.PGame\nhx : HasEquiv.Equiv x₁ x₂\n⊢ Iff (x₁.LF y) (x₂.LF y)","decl":"theorem lf_congr_left {x₁ x₂ y : PGame} (hx : x₁ ≈ x₂) : x₁ ⧏ y ↔ x₂ ⧏ y :=\n  lf_congr hx equiv_rfl\n\n"}
{"name":"SetTheory.PGame.lf_congr_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y₁ y₂ : SetTheory.PGame\nhy : HasEquiv.Equiv y₁ y₂\n⊢ Iff (x.LF y₁) (x.LF y₂)","decl":"theorem lf_congr_right {x y₁ y₂ : PGame} (hy : y₁ ≈ y₂) : x ⧏ y₁ ↔ x ⧏ y₂ :=\n  lf_congr equiv_rfl hy\n\n"}
{"name":"SetTheory.PGame.lf_of_lf_of_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : x.LF y\nh₂ : HasEquiv.Equiv y z\n⊢ x.LF z","decl":"@[trans]\ntheorem lf_of_lf_of_equiv {x y z : PGame} (h₁ : x ⧏ y) (h₂ : y ≈ z) : x ⧏ z :=\n  lf_congr_imp equiv_rfl h₂ h₁\n\n"}
{"name":"SetTheory.PGame.lf_of_equiv_of_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : HasEquiv.Equiv x y\na✝ : y.LF z\n⊢ x.LF z","decl":"@[trans]\ntheorem lf_of_equiv_of_lf {x y z : PGame} (h₁ : x ≈ y) : y ⧏ z → x ⧏ z :=\n  lf_congr_imp (Equiv.symm h₁) equiv_rfl\n\n"}
{"name":"SetTheory.PGame.lt_of_lt_of_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : LT.lt x y\nh₂ : HasEquiv.Equiv y z\n⊢ LT.lt x z","decl":"@[trans]\ntheorem lt_of_lt_of_equiv {x y z : PGame} (h₁ : x < y) (h₂ : y ≈ z) : x < z :=\n  h₁.trans_le h₂.1\n\n"}
{"name":"SetTheory.PGame.lt_of_equiv_of_lt","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : HasEquiv.Equiv x y\na✝ : LT.lt y z\n⊢ LT.lt x z","decl":"@[trans]\ntheorem lt_of_equiv_of_lt {x y z : PGame} (h₁ : x ≈ y) : y < z → x < z :=\n  h₁.1.trans_lt\n\n"}
{"name":"SetTheory.PGame.lt_congr_imp","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ y₁ x₂ y₂ : SetTheory.PGame\nhx : HasEquiv.Equiv x₁ x₂\nhy : HasEquiv.Equiv y₁ y₂\nh : LT.lt x₁ y₁\n⊢ LT.lt x₂ y₂","decl":"theorem lt_congr_imp {x₁ y₁ x₂ y₂ : PGame} (hx : x₁ ≈ x₂) (hy : y₁ ≈ y₂) (h : x₁ < y₁) : x₂ < y₂ :=\n  hx.2.trans_lt (h.trans_le hy.1)\n\n"}
{"name":"SetTheory.PGame.lt_congr","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ y₁ x₂ y₂ : SetTheory.PGame\nhx : HasEquiv.Equiv x₁ x₂\nhy : HasEquiv.Equiv y₁ y₂\n⊢ Iff (LT.lt x₁ y₁) (LT.lt x₂ y₂)","decl":"theorem lt_congr {x₁ y₁ x₂ y₂ : PGame} (hx : x₁ ≈ x₂) (hy : y₁ ≈ y₂) : x₁ < y₁ ↔ x₂ < y₂ :=\n  ⟨lt_congr_imp hx hy, lt_congr_imp (Equiv.symm hx) (Equiv.symm hy)⟩\n\n"}
{"name":"SetTheory.PGame.lt_congr_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ x₂ y : SetTheory.PGame\nhx : HasEquiv.Equiv x₁ x₂\n⊢ Iff (LT.lt x₁ y) (LT.lt x₂ y)","decl":"theorem lt_congr_left {x₁ x₂ y : PGame} (hx : x₁ ≈ x₂) : x₁ < y ↔ x₂ < y :=\n  lt_congr hx equiv_rfl\n\n"}
{"name":"SetTheory.PGame.lt_congr_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y₁ y₂ : SetTheory.PGame\nhy : HasEquiv.Equiv y₁ y₂\n⊢ Iff (LT.lt x y₁) (LT.lt x y₂)","decl":"theorem lt_congr_right {x y₁ y₂ : PGame} (hy : y₁ ≈ y₂) : x < y₁ ↔ x < y₂ :=\n  lt_congr equiv_rfl hy\n\n"}
{"name":"SetTheory.PGame.lt_or_equiv_of_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : LE.le x y\n⊢ Or (LT.lt x y) (HasEquiv.Equiv x y)","decl":"theorem lt_or_equiv_of_le {x y : PGame} (h : x ≤ y) : x < y ∨ (x ≈ y) :=\n  and_or_left.mp ⟨h, (em <| y ≤ x).symm.imp_left PGame.not_le.1⟩\n\n"}
{"name":"SetTheory.PGame.lf_or_equiv_or_gf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Or (x.LF y) (Or (HasEquiv.Equiv x y) (y.LF x))","decl":"theorem lf_or_equiv_or_gf (x y : PGame) : x ⧏ y ∨ (x ≈ y) ∨ y ⧏ x := by\n  by_cases h : x ⧏ y\n  · exact Or.inl h\n  · right\n    cases' lt_or_equiv_of_le (PGame.not_lf.1 h) with h' h'\n    · exact Or.inr h'.lf\n    · exact Or.inl (Equiv.symm h')\n\n"}
{"name":"SetTheory.PGame.equiv_congr_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"y₁ y₂ : SetTheory.PGame\n⊢ Iff (HasEquiv.Equiv y₁ y₂) (∀ (x₁ : SetTheory.PGame), Iff (HasEquiv.Equiv x₁ y₁) (HasEquiv.Equiv x₁ y₂))","decl":"theorem equiv_congr_left {y₁ y₂ : PGame} : (y₁ ≈ y₂) ↔ ∀ x₁, (x₁ ≈ y₁) ↔ (x₁ ≈ y₂) :=\n  ⟨fun h _ => ⟨fun h' => Equiv.trans h' h, fun h' => Equiv.trans h' (Equiv.symm h)⟩,\n   fun h => (h y₁).1 <| equiv_rfl⟩\n\n"}
{"name":"SetTheory.PGame.equiv_congr_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ x₂ : SetTheory.PGame\n⊢ Iff (HasEquiv.Equiv x₁ x₂) (∀ (y₁ : SetTheory.PGame), Iff (HasEquiv.Equiv x₁ y₁) (HasEquiv.Equiv x₂ y₁))","decl":"theorem equiv_congr_right {x₁ x₂ : PGame} : (x₁ ≈ x₂) ↔ ∀ y₁, (x₁ ≈ y₁) ↔ (x₂ ≈ y₁) :=\n  ⟨fun h _ => ⟨fun h' => Equiv.trans (Equiv.symm h) h', fun h' => Equiv.trans h h'⟩,\n   fun h => (h x₂).2 <| equiv_rfl⟩\n\n"}
{"name":"SetTheory.PGame.Equiv.of_exists","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nhl₁ : ∀ (i : x.LeftMoves), Exists fun j => HasEquiv.Equiv (x.moveLeft i) (y.moveLeft j)\nhr₁ : ∀ (i : x.RightMoves), Exists fun j => HasEquiv.Equiv (x.moveRight i) (y.moveRight j)\nhl₂ : ∀ (j : y.LeftMoves), Exists fun i => HasEquiv.Equiv (x.moveLeft i) (y.moveLeft j)\nhr₂ : ∀ (j : y.RightMoves), Exists fun i => HasEquiv.Equiv (x.moveRight i) (y.moveRight j)\n⊢ HasEquiv.Equiv x y","decl":"theorem Equiv.of_exists {x y : PGame}\n    (hl₁ : ∀ i, ∃ j, x.moveLeft i ≈ y.moveLeft j) (hr₁ : ∀ i, ∃ j, x.moveRight i ≈ y.moveRight j)\n    (hl₂ : ∀ j, ∃ i, x.moveLeft i ≈ y.moveLeft j) (hr₂ : ∀ j, ∃ i, x.moveRight i ≈ y.moveRight j) :\n    x ≈ y := by\n  constructor <;> refine le_def.2 ⟨?_, ?_⟩ <;> intro i\n  · obtain ⟨j, hj⟩ := hl₁ i\n    exact Or.inl ⟨j, Equiv.le hj⟩\n  · obtain ⟨j, hj⟩ := hr₂ i\n    exact Or.inr ⟨j, Equiv.le hj⟩\n  · obtain ⟨j, hj⟩ := hl₂ i\n    exact Or.inl ⟨j, Equiv.ge hj⟩\n  · obtain ⟨j, hj⟩ := hr₁ i\n    exact Or.inr ⟨j, Equiv.ge hj⟩\n\n"}
{"name":"SetTheory.PGame.Equiv.of_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nL : Equiv x.LeftMoves y.LeftMoves\nR : Equiv x.RightMoves y.RightMoves\nhl : ∀ (i : x.LeftMoves), HasEquiv.Equiv (x.moveLeft i) (y.moveLeft (L i))\nhr : ∀ (j : x.RightMoves), HasEquiv.Equiv (x.moveRight j) (y.moveRight (R j))\n⊢ HasEquiv.Equiv x y","decl":"theorem Equiv.of_equiv {x y : PGame} (L : x.LeftMoves ≃ y.LeftMoves)\n    (R : x.RightMoves ≃ y.RightMoves) (hl : ∀ i, x.moveLeft i ≈ y.moveLeft (L i))\n    (hr : ∀ j, x.moveRight j ≈ y.moveRight (R j)) : x ≈ y := by\n  apply Equiv.of_exists <;> intro i\n  exacts [⟨_, hl i⟩, ⟨_, hr i⟩,\n    ⟨_, by simpa using hl (L.symm i)⟩, ⟨_, by simpa using hr (R.symm i)⟩]\n\n"}
{"name":"SetTheory.PGame.equiv_of_mk_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nL : Equiv x.LeftMoves y.LeftMoves\nR : Equiv x.RightMoves y.RightMoves\nhl : ∀ (i : x.LeftMoves), HasEquiv.Equiv (x.moveLeft i) (y.moveLeft (L i))\nhr : ∀ (j : x.RightMoves), HasEquiv.Equiv (x.moveRight j) (y.moveRight (R j))\n⊢ HasEquiv.Equiv x y","decl":"@[deprecated (since := \"2024-09-26\")] alias equiv_of_mk_equiv := Equiv.of_equiv\n\n"}
{"name":"SetTheory.PGame.Fuzzy.swap","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝ : x.Fuzzy y\n⊢ y.Fuzzy x","decl":"@[symm]\ntheorem Fuzzy.swap {x y : PGame} : x ‖ y → y ‖ x :=\n  And.symm\n\n"}
{"name":"SetTheory.PGame.instIsSymmFuzzy","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ IsSymm SetTheory.PGame fun x1 x2 => x1.Fuzzy x2","decl":"instance : IsSymm _ (· ‖ ·) :=\n  ⟨fun _ _ => Fuzzy.swap⟩\n\n"}
{"name":"SetTheory.PGame.Fuzzy.swap_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.Fuzzy y) (y.Fuzzy x)","decl":"theorem Fuzzy.swap_iff {x y : PGame} : x ‖ y ↔ y ‖ x :=\n  ⟨Fuzzy.swap, Fuzzy.swap⟩\n\n"}
{"name":"SetTheory.PGame.fuzzy_irrefl","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Not (x.Fuzzy x)","decl":"theorem fuzzy_irrefl (x : PGame) : ¬x ‖ x := fun h => lf_irrefl x h.1\n\n"}
{"name":"SetTheory.PGame.instIsIrreflFuzzy","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ IsIrrefl SetTheory.PGame fun x1 x2 => x1.Fuzzy x2","decl":"instance : IsIrrefl _ (· ‖ ·) :=\n  ⟨fuzzy_irrefl⟩\n\n"}
{"name":"SetTheory.PGame.lf_iff_lt_or_fuzzy","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.LF y) (Or (LT.lt x y) (x.Fuzzy y))","decl":"theorem lf_iff_lt_or_fuzzy {x y : PGame} : x ⧏ y ↔ x < y ∨ x ‖ y := by\n  simp only [lt_iff_le_and_lf, Fuzzy, ← PGame.not_le]\n  tauto\n\n"}
{"name":"SetTheory.PGame.lf_of_fuzzy","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : x.Fuzzy y\n⊢ x.LF y","decl":"theorem lf_of_fuzzy {x y : PGame} (h : x ‖ y) : x ⧏ y :=\n  lf_iff_lt_or_fuzzy.2 (Or.inr h)\n\n"}
{"name":"SetTheory.PGame.Fuzzy.lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : x.Fuzzy y\n⊢ x.LF y","decl":"alias Fuzzy.lf := lf_of_fuzzy\n\n"}
{"name":"SetTheory.PGame.lt_or_fuzzy_of_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\na✝ : x.LF y\n⊢ Or (LT.lt x y) (x.Fuzzy y)","decl":"theorem lt_or_fuzzy_of_lf {x y : PGame} : x ⧏ y → x < y ∨ x ‖ y :=\n  lf_iff_lt_or_fuzzy.1\n\n"}
{"name":"SetTheory.PGame.Fuzzy.not_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : x.Fuzzy y\n⊢ Not (HasEquiv.Equiv x y)","decl":"theorem Fuzzy.not_equiv {x y : PGame} (h : x ‖ y) : ¬(x ≈ y) := fun h' => h'.1.not_gf h.2\n\n"}
{"name":"SetTheory.PGame.Fuzzy.not_equiv'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : x.Fuzzy y\n⊢ Not (HasEquiv.Equiv y x)","decl":"theorem Fuzzy.not_equiv' {x y : PGame} (h : x ‖ y) : ¬(y ≈ x) := fun h' => h'.2.not_gf h.2\n\n"}
{"name":"SetTheory.PGame.not_fuzzy_of_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : LE.le x y\n⊢ Not (x.Fuzzy y)","decl":"theorem not_fuzzy_of_le {x y : PGame} (h : x ≤ y) : ¬x ‖ y := fun h' => h'.2.not_ge h\n\n"}
{"name":"SetTheory.PGame.not_fuzzy_of_ge","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : LE.le y x\n⊢ Not (x.Fuzzy y)","decl":"theorem not_fuzzy_of_ge {x y : PGame} (h : y ≤ x) : ¬x ‖ y := fun h' => h'.1.not_ge h\n\n"}
{"name":"SetTheory.PGame.Equiv.not_fuzzy","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : HasEquiv.Equiv x y\n⊢ Not (x.Fuzzy y)","decl":"theorem Equiv.not_fuzzy {x y : PGame} (h : x ≈ y) : ¬x ‖ y :=\n  not_fuzzy_of_le h.1\n\n"}
{"name":"SetTheory.PGame.Equiv.not_fuzzy'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nh : HasEquiv.Equiv x y\n⊢ Not (y.Fuzzy x)","decl":"theorem Equiv.not_fuzzy' {x y : PGame} (h : x ≈ y) : ¬y ‖ x :=\n  not_fuzzy_of_le h.2\n\n"}
{"name":"SetTheory.PGame.fuzzy_congr","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ y₁ x₂ y₂ : SetTheory.PGame\nhx : HasEquiv.Equiv x₁ x₂\nhy : HasEquiv.Equiv y₁ y₂\n⊢ Iff (x₁.Fuzzy y₁) (x₂.Fuzzy y₂)","decl":"theorem fuzzy_congr {x₁ y₁ x₂ y₂ : PGame} (hx : x₁ ≈ x₂) (hy : y₁ ≈ y₂) : x₁ ‖ y₁ ↔ x₂ ‖ y₂ :=\n  show _ ∧ _ ↔ _ ∧ _ by rw [lf_congr hx hy, lf_congr hy hx]\n\n"}
{"name":"SetTheory.PGame.fuzzy_congr_imp","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ y₁ x₂ y₂ : SetTheory.PGame\nhx : HasEquiv.Equiv x₁ x₂\nhy : HasEquiv.Equiv y₁ y₂\na✝ : x₁.Fuzzy y₁\n⊢ x₂.Fuzzy y₂","decl":"theorem fuzzy_congr_imp {x₁ y₁ x₂ y₂ : PGame} (hx : x₁ ≈ x₂) (hy : y₁ ≈ y₂) : x₁ ‖ y₁ → x₂ ‖ y₂ :=\n  (fuzzy_congr hx hy).1\n\n"}
{"name":"SetTheory.PGame.fuzzy_congr_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ x₂ y : SetTheory.PGame\nhx : HasEquiv.Equiv x₁ x₂\n⊢ Iff (x₁.Fuzzy y) (x₂.Fuzzy y)","decl":"theorem fuzzy_congr_left {x₁ x₂ y : PGame} (hx : x₁ ≈ x₂) : x₁ ‖ y ↔ x₂ ‖ y :=\n  fuzzy_congr hx equiv_rfl\n\n"}
{"name":"SetTheory.PGame.fuzzy_congr_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y₁ y₂ : SetTheory.PGame\nhy : HasEquiv.Equiv y₁ y₂\n⊢ Iff (x.Fuzzy y₁) (x.Fuzzy y₂)","decl":"theorem fuzzy_congr_right {x y₁ y₂ : PGame} (hy : y₁ ≈ y₂) : x ‖ y₁ ↔ x ‖ y₂ :=\n  fuzzy_congr equiv_rfl hy\n\n"}
{"name":"SetTheory.PGame.fuzzy_of_fuzzy_of_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : x.Fuzzy y\nh₂ : HasEquiv.Equiv y z\n⊢ x.Fuzzy z","decl":"@[trans]\ntheorem fuzzy_of_fuzzy_of_equiv {x y z : PGame} (h₁ : x ‖ y) (h₂ : y ≈ z) : x ‖ z :=\n  (fuzzy_congr_right h₂).1 h₁\n\n"}
{"name":"SetTheory.PGame.fuzzy_of_equiv_of_fuzzy","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh₁ : HasEquiv.Equiv x y\nh₂ : y.Fuzzy z\n⊢ x.Fuzzy z","decl":"@[trans]\ntheorem fuzzy_of_equiv_of_fuzzy {x y z : PGame} (h₁ : x ≈ y) (h₂ : y ‖ z) : x ‖ z :=\n  (fuzzy_congr_left h₁).2 h₂\n\n"}
{"name":"SetTheory.PGame.lt_or_equiv_or_gt_or_fuzzy","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Or (LT.lt x y) (Or (HasEquiv.Equiv x y) (Or (LT.lt y x) (x.Fuzzy y)))","decl":"/-- Exactly one of the following is true (although we don't prove this here). -/\ntheorem lt_or_equiv_or_gt_or_fuzzy (x y : PGame) : x < y ∨ (x ≈ y) ∨ y < x ∨ x ‖ y := by\n  cases' le_or_gf x y with h₁ h₁ <;> cases' le_or_gf y x with h₂ h₂\n  · right\n    left\n    exact ⟨h₁, h₂⟩\n  · left\n    exact ⟨h₁, h₂⟩\n  · right\n    right\n    left\n    exact ⟨h₂, h₁⟩\n  · right\n    right\n    right\n    exact ⟨h₂, h₁⟩\n\n"}
{"name":"SetTheory.PGame.lt_or_equiv_or_gf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Or (LT.lt x y) (Or (HasEquiv.Equiv x y) (y.LF x))","decl":"theorem lt_or_equiv_or_gf (x y : PGame) : x < y ∨ (x ≈ y) ∨ y ⧏ x := by\n  rw [lf_iff_lt_or_fuzzy, Fuzzy.swap_iff]\n  exact lt_or_equiv_or_gt_or_fuzzy x y\n\n"}
{"name":"SetTheory.PGame.Relabelling.mk.sizeOf_spec","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nL : Equiv x.LeftMoves y.LeftMoves\nR : Equiv x.RightMoves y.RightMoves\na✝¹ : (i : x.LeftMoves) → (x.moveLeft i).Relabelling (y.moveLeft (L i))\na✝ : (j : x.RightMoves) → (x.moveRight j).Relabelling (y.moveRight (R j))\n⊢ Eq (SizeOf.sizeOf (SetTheory.PGame.Relabelling.mk L R a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf x)) (SizeOf.sizeOf y)) (SizeOf.sizeOf L)) (SizeOf.sizeOf R))","decl":"/-- `Relabelling x y` says that `x` and `y` are really the same game, just dressed up differently.\nSpecifically, there is a bijection between the moves for Left in `x` and in `y`, and similarly\nfor Right, and under these bijections we inductively have `Relabelling`s for the consequent games.\n-/\ninductive Relabelling : PGame.{u} → PGame.{u} → Type (u + 1)\n  |\n  mk :\n    ∀ {x y : PGame} (L : x.LeftMoves ≃ y.LeftMoves) (R : x.RightMoves ≃ y.RightMoves),\n      (∀ i, Relabelling (x.moveLeft i) (y.moveLeft (L i))) →\n        (∀ j, Relabelling (x.moveRight j) (y.moveRight (R j))) → Relabelling x y\n\n"}
{"name":"SetTheory.PGame.Relabelling.mk.inj","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nL✝ : Equiv x.LeftMoves y.LeftMoves\nR✝ : Equiv x.RightMoves y.RightMoves\na✝³ : (i : x.LeftMoves) → (x.moveLeft i).Relabelling (y.moveLeft (L✝ i))\na✝² : (j : x.RightMoves) → (x.moveRight j).Relabelling (y.moveRight (R✝ j))\nL : Equiv x.LeftMoves y.LeftMoves\nR : Equiv x.RightMoves y.RightMoves\na✝¹ : (i : x.LeftMoves) → (x.moveLeft i).Relabelling (y.moveLeft (L i))\na✝ : (j : x.RightMoves) → (x.moveRight j).Relabelling (y.moveRight (R j))\nx✝ : Eq (SetTheory.PGame.Relabelling.mk L✝ R✝ a✝³ a✝²) (SetTheory.PGame.Relabelling.mk L R a✝¹ a✝)\n⊢ And (Eq L✝ L) (And (Eq R✝ R) (And (HEq a✝³ a✝¹) (HEq a✝² a✝)))","decl":"/-- `Relabelling x y` says that `x` and `y` are really the same game, just dressed up differently.\nSpecifically, there is a bijection between the moves for Left in `x` and in `y`, and similarly\nfor Right, and under these bijections we inductively have `Relabelling`s for the consequent games.\n-/\ninductive Relabelling : PGame.{u} → PGame.{u} → Type (u + 1)\n  |\n  mk :\n    ∀ {x y : PGame} (L : x.LeftMoves ≃ y.LeftMoves) (R : x.RightMoves ≃ y.RightMoves),\n      (∀ i, Relabelling (x.moveLeft i) (y.moveLeft (L i))) →\n        (∀ j, Relabelling (x.moveRight j) (y.moveRight (R j))) → Relabelling x y\n\n"}
{"name":"SetTheory.PGame.Relabelling.mk.injEq","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nL✝ : Equiv x.LeftMoves y.LeftMoves\nR✝ : Equiv x.RightMoves y.RightMoves\na✝³ : (i : x.LeftMoves) → (x.moveLeft i).Relabelling (y.moveLeft (L✝ i))\na✝² : (j : x.RightMoves) → (x.moveRight j).Relabelling (y.moveRight (R✝ j))\nL : Equiv x.LeftMoves y.LeftMoves\nR : Equiv x.RightMoves y.RightMoves\na✝¹ : (i : x.LeftMoves) → (x.moveLeft i).Relabelling (y.moveLeft (L i))\na✝ : (j : x.RightMoves) → (x.moveRight j).Relabelling (y.moveRight (R j))\n⊢ Eq (Eq (SetTheory.PGame.Relabelling.mk L✝ R✝ a✝³ a✝²) (SetTheory.PGame.Relabelling.mk L R a✝¹ a✝)) (And (Eq L✝ L) (And (Eq R✝ R) (And (HEq a✝³ a✝¹) (HEq a✝² a✝))))","decl":"/-- `Relabelling x y` says that `x` and `y` are really the same game, just dressed up differently.\nSpecifically, there is a bijection between the moves for Left in `x` and in `y`, and similarly\nfor Right, and under these bijections we inductively have `Relabelling`s for the consequent games.\n-/\ninductive Relabelling : PGame.{u} → PGame.{u} → Type (u + 1)\n  |\n  mk :\n    ∀ {x y : PGame} (L : x.LeftMoves ≃ y.LeftMoves) (R : x.RightMoves ≃ y.RightMoves),\n      (∀ i, Relabelling (x.moveLeft i) (y.moveLeft (L i))) →\n        (∀ j, Relabelling (x.moveRight j) (y.moveRight (R j))) → Relabelling x y\n\n"}
{"name":"SetTheory.PGame.Relabelling.mk_leftMovesEquiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nL : Equiv x.LeftMoves y.LeftMoves\nR : Equiv x.RightMoves y.RightMoves\nhL : (i : x.LeftMoves) → (x.moveLeft i).Relabelling (y.moveLeft (L i))\nhR : (j : x.RightMoves) → (x.moveRight j).Relabelling (y.moveRight (R j))\n⊢ Eq (SetTheory.PGame.Relabelling.mk L R hL hR).leftMovesEquiv L","decl":"@[simp]\ntheorem mk_leftMovesEquiv {x y L R hL hR} : (@Relabelling.mk x y L R hL hR).leftMovesEquiv = L :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.Relabelling.mk'_leftMovesEquiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nL : Equiv y.LeftMoves x.LeftMoves\nR : Equiv y.RightMoves x.RightMoves\nhL : (i : y.LeftMoves) → (x.moveLeft (L i)).Relabelling (y.moveLeft i)\nhR : (j : y.RightMoves) → (x.moveRight (R j)).Relabelling (y.moveRight j)\n⊢ Eq (SetTheory.PGame.Relabelling.mk' L R hL hR).leftMovesEquiv L.symm","decl":"@[simp]\ntheorem mk'_leftMovesEquiv {x y L R hL hR} :\n    (@Relabelling.mk' x y L R hL hR).leftMovesEquiv = L.symm :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.Relabelling.mk_rightMovesEquiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nL : Equiv x.LeftMoves y.LeftMoves\nR : Equiv x.RightMoves y.RightMoves\nhL : (i : x.LeftMoves) → (x.moveLeft i).Relabelling (y.moveLeft (L i))\nhR : (j : x.RightMoves) → (x.moveRight j).Relabelling (y.moveRight (R j))\n⊢ Eq (SetTheory.PGame.Relabelling.mk L R hL hR).rightMovesEquiv R","decl":"@[simp]\ntheorem mk_rightMovesEquiv {x y L R hL hR} : (@Relabelling.mk x y L R hL hR).rightMovesEquiv = R :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.Relabelling.mk'_rightMovesEquiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nL : Equiv y.LeftMoves x.LeftMoves\nR : Equiv y.RightMoves x.RightMoves\nhL : (i : y.LeftMoves) → (x.moveLeft (L i)).Relabelling (y.moveLeft i)\nhR : (j : y.RightMoves) → (x.moveRight (R j)).Relabelling (y.moveRight j)\n⊢ Eq (SetTheory.PGame.Relabelling.mk' L R hL hR).rightMovesEquiv R.symm","decl":"@[simp]\ntheorem mk'_rightMovesEquiv {x y L R hL hR} :\n    (@Relabelling.mk' x y L R hL hR).rightMovesEquiv = R.symm :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.Relabelling.le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nr : x.Relabelling y\n⊢ LE.le x y","decl":"theorem le {x y : PGame} (r : x ≡r y) : x ≤ y :=\n  le_def.2\n    ⟨fun i => Or.inl ⟨_, (r.moveLeft i).le⟩, fun j =>\n      Or.inr ⟨_, (r.moveRightSymm j).le⟩⟩\ntermination_by x\n\n"}
{"name":"SetTheory.PGame.Relabelling.ge","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nr : x.Relabelling y\n⊢ LE.le y x","decl":"theorem ge {x y : PGame} (r : x ≡r y) : y ≤ x :=\n  r.symm.le\n\n"}
{"name":"SetTheory.PGame.Relabelling.equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nr : x.Relabelling y\n⊢ HasEquiv.Equiv x y","decl":"/-- A relabelling lets us prove equivalence of games. -/\ntheorem equiv (r : x ≡r y) : x ≈ y :=\n  ⟨r.le, r.ge⟩\n\n"}
{"name":"SetTheory.PGame.Equiv.isEmpty","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ninst✝¹ : IsEmpty x.LeftMoves\ninst✝ : IsEmpty x.RightMoves\n⊢ HasEquiv.Equiv x 0","decl":"theorem Equiv.isEmpty (x : PGame) [IsEmpty x.LeftMoves] [IsEmpty x.RightMoves] : x ≈ 0 :=\n  (Relabelling.isEmpty x).equiv\n\n"}
{"name":"SetTheory.PGame.relabel_moveLeft'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nxl' xr' : Type u_1\nel : Equiv xl' x.LeftMoves\ner : Equiv xr' x.RightMoves\ni : xl'\n⊢ Eq ((SetTheory.PGame.relabel el er).moveLeft i) (x.moveLeft (el i))","decl":"@[simp]\ntheorem relabel_moveLeft' {x : PGame} {xl' xr'} (el : xl' ≃ x.LeftMoves) (er : xr' ≃ x.RightMoves)\n    (i : xl') : moveLeft (relabel el er) i = x.moveLeft (el i) :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.relabel_moveLeft","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nxl' xr' : Type u_1\nel : Equiv xl' x.LeftMoves\ner : Equiv xr' x.RightMoves\ni : x.LeftMoves\n⊢ Eq ((SetTheory.PGame.relabel el er).moveLeft (el.symm i)) (x.moveLeft i)","decl":"theorem relabel_moveLeft {x : PGame} {xl' xr'} (el : xl' ≃ x.LeftMoves) (er : xr' ≃ x.RightMoves)\n    (i : x.LeftMoves) : moveLeft (relabel el er) (el.symm i) = x.moveLeft i := by simp\n\n"}
{"name":"SetTheory.PGame.relabel_moveRight'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nxl' xr' : Type u_1\nel : Equiv xl' x.LeftMoves\ner : Equiv xr' x.RightMoves\nj : xr'\n⊢ Eq ((SetTheory.PGame.relabel el er).moveRight j) (x.moveRight (er j))","decl":"@[simp]\ntheorem relabel_moveRight' {x : PGame} {xl' xr'} (el : xl' ≃ x.LeftMoves) (er : xr' ≃ x.RightMoves)\n    (j : xr') : moveRight (relabel el er) j = x.moveRight (er j) :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.relabel_moveRight","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nxl' xr' : Type u_1\nel : Equiv xl' x.LeftMoves\ner : Equiv xr' x.RightMoves\nj : x.RightMoves\n⊢ Eq ((SetTheory.PGame.relabel el er).moveRight (er.symm j)) (x.moveRight j)","decl":"theorem relabel_moveRight {x : PGame} {xl' xr'} (el : xl' ≃ x.LeftMoves) (er : xr' ≃ x.RightMoves)\n    (j : x.RightMoves) : moveRight (relabel el er) (er.symm j) = x.moveRight j := by simp\n\n"}
{"name":"SetTheory.PGame.neg_def","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\n⊢ Eq (Neg.neg (SetTheory.PGame.mk xl xr xL xR)) (SetTheory.PGame.mk xr xl (fun x => Neg.neg (xR x)) fun x => Neg.neg (xL x))","decl":"@[simp]\ntheorem neg_def {xl xr xL xR} : -mk xl xr xL xR = mk xr xl (-xR ·) (-xL ·) :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.neg_ofLists","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"L R : List SetTheory.PGame\n⊢ Eq (Neg.neg (SetTheory.PGame.ofLists L R)) (SetTheory.PGame.ofLists (List.map (fun x => Neg.neg x) R) (List.map (fun x => Neg.neg x) L))","decl":"@[simp]\ntheorem neg_ofLists (L R : List PGame) :\n    -ofLists L R = ofLists (R.map fun x => -x) (L.map fun x => -x) := by\n  simp only [ofLists, neg_def, List.getElem_map, mk.injEq, List.length_map, true_and]\n  constructor\n  all_goals\n    apply hfunext\n    · simp\n    · rintro ⟨⟨a, ha⟩⟩ ⟨⟨b, hb⟩⟩ h\n      have :\n        ∀ {m n} (_ : m = n) {b : ULift (Fin m)} {c : ULift (Fin n)} (_ : HEq b c),\n          (b.down : ℕ) = ↑c.down := by\n        rintro m n rfl b c\n        simp only [heq_eq_eq]\n        rintro rfl\n        rfl\n      simp only [heq_eq_eq]\n      congr 5\n      exact this (List.length_map _ _).symm h\n\n"}
{"name":"SetTheory.PGame.isOption_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.IsOption (Neg.neg y)) ((Neg.neg x).IsOption y)","decl":"theorem isOption_neg {x y : PGame} : IsOption x (-y) ↔ IsOption (-x) y := by\n  rw [isOption_iff, isOption_iff, or_comm]\n  cases y\n  apply or_congr <;>\n    · apply exists_congr\n      intro\n      rw [neg_eq_iff_eq_neg]\n      rfl\n\n"}
{"name":"SetTheory.PGame.isOption_neg_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff ((Neg.neg x).IsOption (Neg.neg y)) (x.IsOption y)","decl":"@[simp]\ntheorem isOption_neg_neg {x y : PGame} : IsOption (-x) (-y) ↔ IsOption x y := by\n  rw [isOption_neg, neg_neg]\n\n"}
{"name":"SetTheory.PGame.leftMoves_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Eq (Neg.neg x).LeftMoves x.RightMoves","decl":"/-- Use `toLeftMovesNeg` to cast between these two types. -/\ntheorem leftMoves_neg : ∀ x : PGame, (-x).LeftMoves = x.RightMoves\n  | ⟨_, _, _, _⟩ => rfl\n\n"}
{"name":"SetTheory.PGame.rightMoves_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Eq (Neg.neg x).RightMoves x.LeftMoves","decl":"/-- Use `toRightMovesNeg` to cast between these two types. -/\ntheorem rightMoves_neg : ∀ x : PGame, (-x).RightMoves = x.LeftMoves\n  | ⟨_, _, _, _⟩ => rfl\n\n"}
{"name":"SetTheory.PGame.moveLeft_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ni : (Neg.neg x).LeftMoves\n⊢ Eq ((Neg.neg x).moveLeft i) (Neg.neg (x.moveRight (SetTheory.PGame.toLeftMovesNeg.symm i)))","decl":"@[simp]\ntheorem moveLeft_neg {x : PGame} (i) :\n    (-x).moveLeft i = -x.moveRight (toLeftMovesNeg.symm i) := by\n  cases x\n  rfl\n\n"}
{"name":"SetTheory.PGame.moveLeft_neg'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ni : (Neg.neg x).LeftMoves\n⊢ Eq ((Neg.neg x).moveLeft i) (Neg.neg (x.moveRight (SetTheory.PGame.toLeftMovesNeg.symm i)))","decl":"@[deprecated moveLeft_neg (since := \"2024-10-30\")]\nalias moveLeft_neg' := moveLeft_neg\n\n"}
{"name":"SetTheory.PGame.moveLeft_neg_toLeftMovesNeg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ni : x.RightMoves\n⊢ Eq ((Neg.neg x).moveLeft (SetTheory.PGame.toLeftMovesNeg i)) (Neg.neg (x.moveRight i))","decl":"theorem moveLeft_neg_toLeftMovesNeg {x : PGame} (i) :\n    (-x).moveLeft (toLeftMovesNeg i) = -x.moveRight i := by simp\n\n"}
{"name":"SetTheory.PGame.moveRight_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ni : (Neg.neg x).RightMoves\n⊢ Eq ((Neg.neg x).moveRight i) (Neg.neg (x.moveLeft (SetTheory.PGame.toRightMovesNeg.symm i)))","decl":"@[simp]\ntheorem moveRight_neg {x : PGame} (i) :\n    (-x).moveRight i = -x.moveLeft (toRightMovesNeg.symm i) := by\n  cases x\n  rfl\n\n"}
{"name":"SetTheory.PGame.moveRight_neg'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ni : (Neg.neg x).RightMoves\n⊢ Eq ((Neg.neg x).moveRight i) (Neg.neg (x.moveLeft (SetTheory.PGame.toRightMovesNeg.symm i)))","decl":"@[deprecated moveRight_neg (since := \"2024-10-30\")]\nalias moveRight_neg' := moveRight_neg\n\n"}
{"name":"SetTheory.PGame.moveRight_neg_toRightMovesNeg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ni : x.LeftMoves\n⊢ Eq ((Neg.neg x).moveRight (SetTheory.PGame.toRightMovesNeg i)) (Neg.neg (x.moveLeft i))","decl":"theorem moveRight_neg_toRightMovesNeg {x : PGame} (i) :\n    (-x).moveRight (toRightMovesNeg i) = -x.moveLeft i := by simp\n\n"}
{"name":"SetTheory.PGame.moveLeft_neg_symm","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ni : (Neg.neg x).RightMoves\n⊢ Eq (x.moveLeft (SetTheory.PGame.toRightMovesNeg.symm i)) (Neg.neg ((Neg.neg x).moveRight i))","decl":"@[deprecated moveRight_neg (since := \"2024-10-30\")]\ntheorem moveLeft_neg_symm {x : PGame} (i) :\n    x.moveLeft (toRightMovesNeg.symm i) = -(-x).moveRight i := by simp\n\n"}
{"name":"SetTheory.PGame.moveLeft_neg_symm'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ni : x.LeftMoves\n⊢ Eq (x.moveLeft i) (Neg.neg ((Neg.neg x).moveRight (SetTheory.PGame.toRightMovesNeg i)))","decl":"@[deprecated moveRight_neg (since := \"2024-10-30\")]\ntheorem moveLeft_neg_symm' {x : PGame} (i) :\n    x.moveLeft i = -(-x).moveRight (toRightMovesNeg i) := by simp\n\n"}
{"name":"SetTheory.PGame.moveRight_neg_symm","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ni : (Neg.neg x).LeftMoves\n⊢ Eq (x.moveRight (SetTheory.PGame.toLeftMovesNeg.symm i)) (Neg.neg ((Neg.neg x).moveLeft i))","decl":"@[deprecated moveLeft_neg (since := \"2024-10-30\")]\ntheorem moveRight_neg_symm {x : PGame} (i) :\n    x.moveRight (toLeftMovesNeg.symm i) = -(-x).moveLeft i := by simp\n\n"}
{"name":"SetTheory.PGame.moveRight_neg_symm'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ni : x.RightMoves\n⊢ Eq (x.moveRight i) (Neg.neg ((Neg.neg x).moveLeft (SetTheory.PGame.toLeftMovesNeg i)))","decl":"@[deprecated moveLeft_neg (since := \"2024-10-30\")]\ntheorem moveRight_neg_symm' {x : PGame} (i) :\n    x.moveRight i = -(-x).moveLeft (toLeftMovesNeg i) := by simp\n\n"}
{"name":"SetTheory.PGame.forall_leftMoves_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\np : (Neg.neg x).LeftMoves → Prop\n⊢ Iff (∀ (i : (Neg.neg x).LeftMoves), p i) (∀ (i : x.RightMoves), p (SetTheory.PGame.toLeftMovesNeg i))","decl":"@[simp]\ntheorem forall_leftMoves_neg {x : PGame} {p : (-x).LeftMoves → Prop} :\n    (∀ i : (-x).LeftMoves, p i) ↔ (∀ i : x.RightMoves, p (toLeftMovesNeg i)) :=\n  toLeftMovesNeg.forall_congr_right.symm\n\n"}
{"name":"SetTheory.PGame.exists_leftMoves_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\np : (Neg.neg x).LeftMoves → Prop\n⊢ Iff (Exists fun i => p i) (Exists fun i => p (SetTheory.PGame.toLeftMovesNeg i))","decl":"@[simp]\ntheorem exists_leftMoves_neg {x : PGame} {p : (-x).LeftMoves → Prop} :\n    (∃ i : (-x).LeftMoves, p i) ↔ (∃ i : x.RightMoves, p (toLeftMovesNeg i)) :=\n  toLeftMovesNeg.exists_congr_right.symm\n\n"}
{"name":"SetTheory.PGame.forall_rightMoves_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\np : (Neg.neg x).RightMoves → Prop\n⊢ Iff (∀ (i : (Neg.neg x).RightMoves), p i) (∀ (i : x.LeftMoves), p (SetTheory.PGame.toRightMovesNeg i))","decl":"@[simp]\ntheorem forall_rightMoves_neg {x : PGame} {p : (-x).RightMoves → Prop} :\n    (∀ i : (-x).RightMoves, p i) ↔ (∀ i : x.LeftMoves, p (toRightMovesNeg i)) :=\n  toRightMovesNeg.forall_congr_right.symm\n\n"}
{"name":"SetTheory.PGame.exists_rightMoves_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\np : (Neg.neg x).RightMoves → Prop\n⊢ Iff (Exists fun i => p i) (Exists fun i => p (SetTheory.PGame.toRightMovesNeg i))","decl":"@[simp]\ntheorem exists_rightMoves_neg {x : PGame} {p : (-x).RightMoves → Prop} :\n    (∃ i : (-x).RightMoves, p i) ↔ (∃ i : x.LeftMoves, p (toRightMovesNeg i)) :=\n  toRightMovesNeg.exists_congr_right.symm\n\n"}
{"name":"SetTheory.PGame.leftMoves_neg_cases","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nk : (Neg.neg x).LeftMoves\nP : (Neg.neg x).LeftMoves → Prop\nh : ∀ (i : x.RightMoves), P (SetTheory.PGame.toLeftMovesNeg i)\n⊢ P k","decl":"theorem leftMoves_neg_cases {x : PGame} (k) {P : (-x).LeftMoves → Prop}\n    (h : ∀ i, P <| toLeftMovesNeg i) :\n    P k := by\n  rw [← toLeftMovesNeg.apply_symm_apply k]\n  exact h _\n\n"}
{"name":"SetTheory.PGame.rightMoves_neg_cases","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\nk : (Neg.neg x).RightMoves\nP : (Neg.neg x).RightMoves → Prop\nh : ∀ (i : x.LeftMoves), P (SetTheory.PGame.toRightMovesNeg i)\n⊢ P k","decl":"theorem rightMoves_neg_cases {x : PGame} (k) {P : (-x).RightMoves → Prop}\n    (h : ∀ i, P <| toRightMovesNeg i) :\n    P k := by\n  rw [← toRightMovesNeg.apply_symm_apply k]\n  exact h _\n\n"}
{"name":"SetTheory.PGame.Identical.neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ x₂ : SetTheory.PGame\na✝ : x₁.Identical x₂\n⊢ (Neg.neg x₁).Identical (Neg.neg x₂)","decl":"/-- If `x` has the same moves as `y`, then `-x` has the sames moves as `-y`. -/\nlemma Identical.neg : ∀ {x₁ x₂ : PGame}, x₁ ≡ x₂ → -x₁ ≡ -x₂\n  | mk _ _ _ _, mk _ _ _ _, ⟨⟨hL₁, hL₂⟩, ⟨hR₁, hR₂⟩⟩ =>\n    ⟨⟨fun i ↦ (hR₁ i).imp (fun _ ↦ Identical.neg), fun j ↦ (hR₂ j).imp (fun _ ↦ Identical.neg)⟩,\n      ⟨fun i ↦ (hL₁ i).imp (fun _ ↦ Identical.neg), fun j ↦ (hL₂ j).imp (fun _ ↦ Identical.neg)⟩⟩\n\n"}
{"name":"SetTheory.PGame.Identical.of_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ x₂ : SetTheory.PGame\na✝ : (Neg.neg x₁).Identical (Neg.neg x₂)\n⊢ x₁.Identical x₂","decl":"/-- If `-x` has the same moves as `-y`, then `x` has the sames moves as `y`. -/\nlemma Identical.of_neg : ∀ {x₁ x₂ : PGame}, -x₁ ≡ -x₂ → x₁ ≡ x₂\n  | mk x₁l x₁r x₁L x₁R, mk x₂l x₂r x₂L x₂R => by\n    simpa using Identical.neg (x₁ := mk _ _ (-x₁R ·) (-x₁L ·)) (x₂ := mk _ _ (-x₂R ·) (-x₂L ·))\n\n"}
{"name":"SetTheory.PGame.memₗ_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.memₗ (Neg.neg y)) (Exists fun z => And (z.memᵣ y) (x.Identical (Neg.neg z)))","decl":"lemma memₗ_neg_iff : ∀ {x y : PGame},\n    x ∈ₗ -y ↔ ∃ z ∈ᵣ y, x ≡ -z\n  | mk _ _ _ _, mk _ _ _ _ =>\n    ⟨fun ⟨_i, hi⟩ ↦ ⟨_, ⟨_, refl _⟩, hi⟩, fun ⟨_, ⟨i, hi⟩, h⟩ ↦ ⟨i, h.trans hi.neg⟩⟩\n\n"}
{"name":"SetTheory.PGame.memᵣ_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.memᵣ (Neg.neg y)) (Exists fun z => And (z.memₗ y) (x.Identical (Neg.neg z)))","decl":"lemma memᵣ_neg_iff : ∀ {x y : PGame},\n    x ∈ᵣ -y ↔ ∃ z ∈ₗ y, x ≡ -z\n  | mk _ _ _ _, mk _ _ _ _ =>\n    ⟨fun ⟨_i, hi⟩ ↦ ⟨_, ⟨_, refl _⟩, hi⟩, fun ⟨_, ⟨i, hi⟩, h⟩ ↦ ⟨i, h.trans hi.neg⟩⟩\n\n"}
{"name":"SetTheory.PGame.neg_le_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (LE.le (Neg.neg y) (Neg.neg x)) (LE.le x y)","decl":"@[simp]\ntheorem neg_le_neg_iff {x y : PGame} : -y ≤ -x ↔ x ≤ y :=\n  neg_le_lf_neg_iff.1\n\n"}
{"name":"SetTheory.PGame.neg_lf_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff ((Neg.neg y).LF (Neg.neg x)) (x.LF y)","decl":"@[simp]\ntheorem neg_lf_neg_iff {x y : PGame} : -y ⧏ -x ↔ x ⧏ y :=\n  neg_le_lf_neg_iff.2\n\n"}
{"name":"SetTheory.PGame.neg_lt_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (LT.lt (Neg.neg y) (Neg.neg x)) (LT.lt x y)","decl":"@[simp]\ntheorem neg_lt_neg_iff {x y : PGame} : -y < -x ↔ x < y := by\n  rw [lt_iff_le_and_lf, lt_iff_le_and_lf, neg_le_neg_iff, neg_lf_neg_iff]\n\n"}
{"name":"SetTheory.PGame.neg_identical_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff ((Neg.neg x).Identical (Neg.neg y)) (x.Identical y)","decl":"@[simp]\ntheorem neg_identical_neg {x y : PGame} : -x ≡ -y ↔ x ≡ y :=\n  ⟨Identical.of_neg, Identical.neg⟩\n\n"}
{"name":"SetTheory.PGame.neg_equiv_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (HasEquiv.Equiv (Neg.neg x) (Neg.neg y)) (HasEquiv.Equiv x y)","decl":"@[simp]\ntheorem neg_equiv_neg_iff {x y : PGame} : -x ≈ -y ↔ x ≈ y := by\n  show Equiv (-x) (-y) ↔ Equiv x y\n  rw [Equiv, Equiv, neg_le_neg_iff, neg_le_neg_iff, and_comm]\n\n"}
{"name":"SetTheory.PGame.neg_fuzzy_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff ((Neg.neg x).Fuzzy (Neg.neg y)) (x.Fuzzy y)","decl":"@[simp]\ntheorem neg_fuzzy_neg_iff {x y : PGame} : -x ‖ -y ↔ x ‖ y := by\n  rw [Fuzzy, Fuzzy, neg_lf_neg_iff, neg_lf_neg_iff, and_comm]\n\n"}
{"name":"SetTheory.PGame.neg_le_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (LE.le (Neg.neg y) x) (LE.le (Neg.neg x) y)","decl":"theorem neg_le_iff {x y : PGame} : -y ≤ x ↔ -x ≤ y := by rw [← neg_neg x, neg_le_neg_iff, neg_neg]\n\n"}
{"name":"SetTheory.PGame.neg_lf_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff ((Neg.neg y).LF x) ((Neg.neg x).LF y)","decl":"theorem neg_lf_iff {x y : PGame} : -y ⧏ x ↔ -x ⧏ y := by rw [← neg_neg x, neg_lf_neg_iff, neg_neg]\n\n"}
{"name":"SetTheory.PGame.neg_lt_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (LT.lt (Neg.neg y) x) (LT.lt (Neg.neg x) y)","decl":"theorem neg_lt_iff {x y : PGame} : -y < x ↔ -x < y := by rw [← neg_neg x, neg_lt_neg_iff, neg_neg]\n\n"}
{"name":"SetTheory.PGame.neg_equiv_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (HasEquiv.Equiv (Neg.neg x) y) (HasEquiv.Equiv x (Neg.neg y))","decl":"theorem neg_equiv_iff {x y : PGame} : (-x ≈ y) ↔ (x ≈ -y) := by\n  rw [← neg_neg y, neg_equiv_neg_iff, neg_neg]\n\n"}
{"name":"SetTheory.PGame.neg_fuzzy_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff ((Neg.neg x).Fuzzy y) (x.Fuzzy (Neg.neg y))","decl":"theorem neg_fuzzy_iff {x y : PGame} : -x ‖ y ↔ x ‖ -y := by\n  rw [← neg_neg y, neg_fuzzy_neg_iff, neg_neg]\n\n"}
{"name":"SetTheory.PGame.le_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (LE.le y (Neg.neg x)) (LE.le x (Neg.neg y))","decl":"theorem le_neg_iff {x y : PGame} : y ≤ -x ↔ x ≤ -y := by rw [← neg_neg x, neg_le_neg_iff, neg_neg]\n\n"}
{"name":"SetTheory.PGame.lf_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (y.LF (Neg.neg x)) (x.LF (Neg.neg y))","decl":"theorem lf_neg_iff {x y : PGame} : y ⧏ -x ↔ x ⧏ -y := by rw [← neg_neg x, neg_lf_neg_iff, neg_neg]\n\n"}
{"name":"SetTheory.PGame.lt_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (LT.lt y (Neg.neg x)) (LT.lt x (Neg.neg y))","decl":"theorem lt_neg_iff {x y : PGame} : y < -x ↔ x < -y := by rw [← neg_neg x, neg_lt_neg_iff, neg_neg]\n\n"}
{"name":"SetTheory.PGame.neg_le_zero_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (LE.le (Neg.neg x) 0) (LE.le 0 x)","decl":"@[simp]\ntheorem neg_le_zero_iff {x : PGame} : -x ≤ 0 ↔ 0 ≤ x := by rw [neg_le_iff, neg_zero]\n\n"}
{"name":"SetTheory.PGame.zero_le_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (LE.le 0 (Neg.neg x)) (LE.le x 0)","decl":"@[simp]\ntheorem zero_le_neg_iff {x : PGame} : 0 ≤ -x ↔ x ≤ 0 := by rw [le_neg_iff, neg_zero]\n\n"}
{"name":"SetTheory.PGame.neg_lf_zero_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff ((Neg.neg x).LF 0) (SetTheory.PGame.LF 0 x)","decl":"@[simp]\ntheorem neg_lf_zero_iff {x : PGame} : -x ⧏ 0 ↔ 0 ⧏ x := by rw [neg_lf_iff, neg_zero]\n\n"}
{"name":"SetTheory.PGame.zero_lf_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (SetTheory.PGame.LF 0 (Neg.neg x)) (x.LF 0)","decl":"@[simp]\ntheorem zero_lf_neg_iff {x : PGame} : 0 ⧏ -x ↔ x ⧏ 0 := by rw [lf_neg_iff, neg_zero]\n\n"}
{"name":"SetTheory.PGame.neg_lt_zero_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (LT.lt (Neg.neg x) 0) (LT.lt 0 x)","decl":"@[simp]\ntheorem neg_lt_zero_iff {x : PGame} : -x < 0 ↔ 0 < x := by rw [neg_lt_iff, neg_zero]\n\n"}
{"name":"SetTheory.PGame.zero_lt_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (LT.lt 0 (Neg.neg x)) (LT.lt x 0)","decl":"@[simp]\ntheorem zero_lt_neg_iff {x : PGame} : 0 < -x ↔ x < 0 := by rw [lt_neg_iff, neg_zero]\n\n"}
{"name":"SetTheory.PGame.neg_equiv_zero_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (HasEquiv.Equiv (Neg.neg x) 0) (HasEquiv.Equiv x 0)","decl":"@[simp]\ntheorem neg_equiv_zero_iff {x : PGame} : (-x ≈ 0) ↔ (x ≈ 0) := by rw [neg_equiv_iff, neg_zero]\n\n"}
{"name":"SetTheory.PGame.neg_fuzzy_zero_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff ((Neg.neg x).Fuzzy 0) (x.Fuzzy 0)","decl":"@[simp]\ntheorem neg_fuzzy_zero_iff {x : PGame} : -x ‖ 0 ↔ x ‖ 0 := by rw [neg_fuzzy_iff, neg_zero]\n\n"}
{"name":"SetTheory.PGame.zero_equiv_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (HasEquiv.Equiv 0 (Neg.neg x)) (HasEquiv.Equiv 0 x)","decl":"@[simp]\ntheorem zero_equiv_neg_iff {x : PGame} : (0 ≈ -x) ↔ (0 ≈ x) := by rw [← neg_equiv_iff, neg_zero]\n\n"}
{"name":"SetTheory.PGame.zero_fuzzy_neg_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (SetTheory.PGame.Fuzzy 0 (Neg.neg x)) (SetTheory.PGame.Fuzzy 0 x)","decl":"@[simp]\ntheorem zero_fuzzy_neg_iff {x : PGame} : 0 ‖ -x ↔ 0 ‖ x := by rw [← neg_fuzzy_iff, neg_zero]\n\n"}
{"name":"SetTheory.PGame.mk_add_moveLeft","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : (HAdd.hAdd (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR)).LeftMoves\n⊢ Eq ((HAdd.hAdd (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR)).moveLeft i) (Sum.rec (fun x => HAdd.hAdd (xL x) (SetTheory.PGame.mk yl yr yL yR)) (fun x => HAdd.hAdd (SetTheory.PGame.mk xl xr xL xR) (yL x)) i)","decl":"theorem mk_add_moveLeft {xl xr yl yr} {xL xR yL yR} {i} :\n    (mk xl xr xL xR + mk yl yr yL yR).moveLeft i =\n      i.rec (xL · + mk yl yr yL yR) (mk xl xr xL xR + yL ·) :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.mk_add_moveRight","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : (HAdd.hAdd (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR)).RightMoves\n⊢ Eq ((HAdd.hAdd (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR)).moveRight i) (Sum.rec (fun x => HAdd.hAdd (xR x) (SetTheory.PGame.mk yl yr yL yR)) (fun x => HAdd.hAdd (SetTheory.PGame.mk xl xr xL xR) (yR x)) i)","decl":"theorem mk_add_moveRight {xl xr yl yr} {xL xR yL yR} {i} :\n    (mk xl xr xL xR + mk yl yr yL yR).moveRight i =\n      i.rec (xR · + mk yl yr yL yR) (mk xl xr xL xR + yR ·) :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.nat_succ","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"n : Nat\n⊢ Eq (↑(HAdd.hAdd n 1)) (HAdd.hAdd (↑n) 1)","decl":"@[simp]\nprotected theorem nat_succ (n : ℕ) : ((n + 1 : ℕ) : PGame) = n + 1 :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.isEmpty_leftMoves_add","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\ninst✝¹ : IsEmpty x.LeftMoves\ninst✝ : IsEmpty y.LeftMoves\n⊢ IsEmpty (HAdd.hAdd x y).LeftMoves","decl":"instance isEmpty_leftMoves_add (x y : PGame.{u}) [IsEmpty x.LeftMoves] [IsEmpty y.LeftMoves] :\n    IsEmpty (x + y).LeftMoves := by\n  cases x\n  cases y\n  apply isEmpty_sum.2 ⟨_, _⟩\n  assumption'\n\n"}
{"name":"SetTheory.PGame.isEmpty_rightMoves_add","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\ninst✝¹ : IsEmpty x.RightMoves\ninst✝ : IsEmpty y.RightMoves\n⊢ IsEmpty (HAdd.hAdd x y).RightMoves","decl":"instance isEmpty_rightMoves_add (x y : PGame.{u}) [IsEmpty x.RightMoves] [IsEmpty y.RightMoves] :\n    IsEmpty (x + y).RightMoves := by\n  cases x\n  cases y\n  apply isEmpty_sum.2 ⟨_, _⟩\n  assumption'\n\n"}
{"name":"SetTheory.PGame.add_zero_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ HasEquiv.Equiv (HAdd.hAdd x 0) x","decl":"/-- `x + 0` is equivalent to `x`. -/\ntheorem add_zero_equiv (x : PGame.{u}) : x + 0 ≈ x :=\n  (addZeroRelabelling x).equiv\n\n"}
{"name":"SetTheory.PGame.zero_add_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ HasEquiv.Equiv (HAdd.hAdd 0 x) x","decl":"/-- `0 + x` is equivalent to `x`. -/\ntheorem zero_add_equiv (x : PGame.{u}) : 0 + x ≈ x :=\n  (zeroAddRelabelling x).equiv\n\n"}
{"name":"SetTheory.PGame.leftMoves_add","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (HAdd.hAdd x y).LeftMoves (Sum x.LeftMoves y.LeftMoves)","decl":"/-- Use `toLeftMovesAdd` to cast between these two types. -/\ntheorem leftMoves_add : ∀ x y : PGame.{u}, (x + y).LeftMoves = (x.LeftMoves ⊕ y.LeftMoves)\n  | ⟨_, _, _, _⟩, ⟨_, _, _, _⟩ => rfl\n\n"}
{"name":"SetTheory.PGame.rightMoves_add","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (HAdd.hAdd x y).RightMoves (Sum x.RightMoves y.RightMoves)","decl":"/-- Use `toRightMovesAdd` to cast between these two types. -/\ntheorem rightMoves_add : ∀ x y : PGame.{u}, (x + y).RightMoves = (x.RightMoves ⊕ y.RightMoves)\n  | ⟨_, _, _, _⟩, ⟨_, _, _, _⟩ => rfl\n\n"}
{"name":"SetTheory.PGame.mk_add_moveLeft_inl","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : xl\n⊢ Eq ((HAdd.hAdd (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR)).moveLeft (Sum.inl i)) (HAdd.hAdd ((SetTheory.PGame.mk xl xr xL xR).moveLeft i) (SetTheory.PGame.mk yl yr yL yR))","decl":"@[simp]\ntheorem mk_add_moveLeft_inl {xl xr yl yr} {xL xR yL yR} {i} :\n    (mk xl xr xL xR + mk yl yr yL yR).moveLeft (Sum.inl i) =\n      (mk xl xr xL xR).moveLeft i + mk yl yr yL yR :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.add_moveLeft_inl","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\ni : x.LeftMoves\n⊢ Eq ((HAdd.hAdd x y).moveLeft (SetTheory.PGame.toLeftMovesAdd (Sum.inl i))) (HAdd.hAdd (x.moveLeft i) y)","decl":"@[simp]\ntheorem add_moveLeft_inl {x : PGame} (y : PGame) (i) :\n    (x + y).moveLeft (toLeftMovesAdd (Sum.inl i)) = x.moveLeft i + y := by\n  cases x\n  cases y\n  rfl\n\n"}
{"name":"SetTheory.PGame.mk_add_moveRight_inl","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : xr\n⊢ Eq ((HAdd.hAdd (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR)).moveRight (Sum.inl i)) (HAdd.hAdd ((SetTheory.PGame.mk xl xr xL xR).moveRight i) (SetTheory.PGame.mk yl yr yL yR))","decl":"@[simp]\ntheorem mk_add_moveRight_inl {xl xr yl yr} {xL xR yL yR} {i} :\n    (mk xl xr xL xR + mk yl yr yL yR).moveRight (Sum.inl i) =\n      (mk xl xr xL xR).moveRight i + mk yl yr yL yR :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.add_moveRight_inl","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\ni : x.RightMoves\n⊢ Eq ((HAdd.hAdd x y).moveRight (SetTheory.PGame.toRightMovesAdd (Sum.inl i))) (HAdd.hAdd (x.moveRight i) y)","decl":"@[simp]\ntheorem add_moveRight_inl {x : PGame} (y : PGame) (i) :\n    (x + y).moveRight (toRightMovesAdd (Sum.inl i)) = x.moveRight i + y := by\n  cases x\n  cases y\n  rfl\n\n"}
{"name":"SetTheory.PGame.mk_add_moveLeft_inr","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : yl\n⊢ Eq ((HAdd.hAdd (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR)).moveLeft (Sum.inr i)) (HAdd.hAdd (SetTheory.PGame.mk xl xr xL xR) ((SetTheory.PGame.mk yl yr yL yR).moveLeft i))","decl":"@[simp]\ntheorem mk_add_moveLeft_inr {xl xr yl yr} {xL xR yL yR} {i} :\n    (mk xl xr xL xR + mk yl yr yL yR).moveLeft (Sum.inr i) =\n      mk xl xr xL xR + (mk yl yr yL yR).moveLeft i :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.add_moveLeft_inr","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\ni : y.LeftMoves\n⊢ Eq ((HAdd.hAdd x y).moveLeft (SetTheory.PGame.toLeftMovesAdd (Sum.inr i))) (HAdd.hAdd x (y.moveLeft i))","decl":"@[simp]\ntheorem add_moveLeft_inr (x : PGame) {y : PGame} (i) :\n    (x + y).moveLeft (toLeftMovesAdd (Sum.inr i)) = x + y.moveLeft i := by\n  cases x\n  cases y\n  rfl\n\n"}
{"name":"SetTheory.PGame.mk_add_moveRight_inr","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"xl xr yl yr : Type u_1\nxL : xl → SetTheory.PGame\nxR : xr → SetTheory.PGame\nyL : yl → SetTheory.PGame\nyR : yr → SetTheory.PGame\ni : yr\n⊢ Eq ((HAdd.hAdd (SetTheory.PGame.mk xl xr xL xR) (SetTheory.PGame.mk yl yr yL yR)).moveRight (Sum.inr i)) (HAdd.hAdd (SetTheory.PGame.mk xl xr xL xR) ((SetTheory.PGame.mk yl yr yL yR).moveRight i))","decl":"@[simp]\ntheorem mk_add_moveRight_inr {xl xr yl yr} {xL xR yL yR} {i} :\n    (mk xl xr xL xR + mk yl yr yL yR).moveRight (Sum.inr i) =\n      mk xl xr xL xR + (mk yl yr yL yR).moveRight i :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.add_moveRight_inr","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\ni : y.RightMoves\n⊢ Eq ((HAdd.hAdd x y).moveRight (SetTheory.PGame.toRightMovesAdd (Sum.inr i))) (HAdd.hAdd x (y.moveRight i))","decl":"@[simp]\ntheorem add_moveRight_inr (x : PGame) {y : PGame} (i) :\n    (x + y).moveRight (toRightMovesAdd (Sum.inr i)) = x + y.moveRight i := by\n  cases x\n  cases y\n  rfl\n\n"}
{"name":"SetTheory.PGame.leftMoves_add_cases","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nk : (HAdd.hAdd x y).LeftMoves\nP : (HAdd.hAdd x y).LeftMoves → Prop\nhl : ∀ (i : x.LeftMoves), P (SetTheory.PGame.toLeftMovesAdd (Sum.inl i))\nhr : ∀ (i : y.LeftMoves), P (SetTheory.PGame.toLeftMovesAdd (Sum.inr i))\n⊢ P k","decl":"/-- Case on possible left moves of `x + y`. -/\ntheorem leftMoves_add_cases {x y : PGame} (k) {P : (x + y).LeftMoves → Prop}\n    (hl : ∀ i, P <| toLeftMovesAdd (Sum.inl i)) (hr : ∀ i, P <| toLeftMovesAdd (Sum.inr i)) :\n    P k := by\n  rw [← toLeftMovesAdd.apply_symm_apply k]\n  cases' toLeftMovesAdd.symm k with i i\n  · exact hl i\n  · exact hr i\n\n"}
{"name":"SetTheory.PGame.rightMoves_add_cases","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\nk : (HAdd.hAdd x y).RightMoves\nP : (HAdd.hAdd x y).RightMoves → Prop\nhl : ∀ (j : x.RightMoves), P (SetTheory.PGame.toRightMovesAdd (Sum.inl j))\nhr : ∀ (j : y.RightMoves), P (SetTheory.PGame.toRightMovesAdd (Sum.inr j))\n⊢ P k","decl":"/-- Case on possible right moves of `x + y`. -/\ntheorem rightMoves_add_cases {x y : PGame} (k) {P : (x + y).RightMoves → Prop}\n    (hl : ∀ j, P <| toRightMovesAdd (Sum.inl j)) (hr : ∀ j, P <| toRightMovesAdd (Sum.inr j)) :\n    P k := by\n  rw [← toRightMovesAdd.apply_symm_apply k]\n  cases' toRightMovesAdd.symm k with i i\n  · exact hl i\n  · exact hr i\n\n"}
{"name":"SetTheory.PGame.isEmpty_nat_rightMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"n : Nat\n⊢ IsEmpty (↑n).RightMoves","decl":"instance isEmpty_nat_rightMoves : ∀ n : ℕ, IsEmpty (RightMoves n)\n  | 0 => inferInstanceAs (IsEmpty PEmpty)\n  | n + 1 => by\n    haveI := isEmpty_nat_rightMoves n\n    rw [PGame.nat_succ, rightMoves_add]\n    infer_instance\n\n"}
{"name":"SetTheory.PGame.add_comm","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ (HAdd.hAdd x y).Identical (HAdd.hAdd y x)","decl":"/-- `x + y` has exactly the same moves as `y + x`. -/\nprotected lemma add_comm (x y : PGame) : x + y ≡ y + x :=\n  match x, y with\n  | mk xl xr xL xR, mk yl yr yL yR => by\n    refine Identical.of_equiv (Equiv.sumComm _ _) (Equiv.sumComm _ _) ?_ ?_ <;>\n    · rintro (_ | _) <;>\n      · dsimp; exact PGame.add_comm _ _\n  termination_by (x, y)\n\n"}
{"name":"SetTheory.PGame.add_assoc","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\n⊢ (HAdd.hAdd (HAdd.hAdd x y) z).Identical (HAdd.hAdd x (HAdd.hAdd y z))","decl":"/-- `(x + y) + z` has exactly the same moves as `x + (y + z)`. -/\nprotected lemma add_assoc (x y z : PGame) : x + y + z ≡ x + (y + z) :=\n  match x, y, z with\n  | mk xl xr xL xR, mk yl yr yL yR, mk zl zr zL zR => by\n    refine Identical.of_equiv (Equiv.sumAssoc _ _ _) (Equiv.sumAssoc _ _ _) ?_ ?_ <;>\n    · rintro ((_ | _) | _)\n      · exact PGame.add_assoc _ _ _\n      · exact PGame.add_assoc (mk _ _ _ _) _ _\n      · exact PGame.add_assoc (mk _ _ _ _) (mk _ _ _ _) _\n  termination_by (x, y, z)\n\n"}
{"name":"SetTheory.PGame.add_zero","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ (HAdd.hAdd x 0).Identical x","decl":"/-- `x + 0` has exactly the same moves as `x`. -/\nprotected lemma add_zero : ∀ (x : PGame), x + 0 ≡ x\n  | mk xl xr xL xR => by\n    refine Identical.of_equiv (Equiv.sumEmpty _ _) (Equiv.sumEmpty _ _) ?_ ?_ <;>\n    · rintro (_ | ⟨⟨⟩⟩)\n      exact PGame.add_zero _\n\n"}
{"name":"SetTheory.PGame.zero_add","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ (HAdd.hAdd 0 x).Identical x","decl":"/-- `0 + x` has exactly the same moves as `x`. -/\nprotected lemma zero_add (x : PGame) : 0 + x ≡ x :=\n  (PGame.add_comm _ _).trans x.add_zero\n\n"}
{"name":"SetTheory.PGame.neg_add","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (Neg.neg (HAdd.hAdd x y)) (HAdd.hAdd (Neg.neg x) (Neg.neg y))","decl":"/-- `-(x + y)` has exactly the same moves as `-x + -y`. -/\nprotected lemma neg_add (x y : PGame) : -(x + y) = -x + -y :=\n  match x, y with\n  | mk xl xr xL xR, mk yl yr yL yR => by\n    refine ext rfl rfl ?_ ?_ <;>\n    · rintro (i | i) _ ⟨rfl⟩\n      · exact PGame.neg_add _ _\n      · simpa [Equiv.refl, mk_add_moveLeft, mk_add_moveRight] using PGame.neg_add _ _\n  termination_by (x, y)\n\n"}
{"name":"SetTheory.PGame.neg_add_rev","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ (Neg.neg (HAdd.hAdd x y)).Identical (HAdd.hAdd (Neg.neg y) (Neg.neg x))","decl":"/-- `-(x + y)` has exactly the same moves as `-y + -x`. -/\nprotected lemma neg_add_rev (x y : PGame) : -(x + y) ≡ -y + -x :=\n  Identical.trans (of_eq (x.neg_add y)) (PGame.add_comm _ _)\n\n"}
{"name":"SetTheory.PGame.identical_zero_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Iff (x.Identical 0) (And (IsEmpty x.LeftMoves) (IsEmpty x.RightMoves))","decl":"lemma identical_zero_iff : ∀ (x : PGame),\n    x ≡ 0 ↔ IsEmpty x.LeftMoves ∧ IsEmpty x.RightMoves\n  | mk xl xr xL xR => by\n    constructor\n    · rintro ⟨h₁, h₂⟩\n      dsimp [Relator.BiTotal, Relator.LeftTotal, Relator.RightTotal] at h₁ h₂\n      simp_rw [IsEmpty.forall_iff, and_true, IsEmpty.exists_iff] at h₁ h₂\n      exact ⟨⟨h₁⟩, ⟨h₂⟩⟩\n    · rintro ⟨h₁, h₂⟩\n      exact identical_of_isEmpty _ _\n\n"}
{"name":"SetTheory.PGame.identical_zero","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\ninst✝¹ : IsEmpty x.LeftMoves\ninst✝ : IsEmpty x.RightMoves\n⊢ x.Identical 0","decl":"/-- Any game without left or right moves is identical to 0. -/\nlemma identical_zero (x : PGame) [IsEmpty x.LeftMoves] [IsEmpty x.RightMoves] : x ≡ 0 :=\n  x.identical_zero_iff.mpr ⟨by infer_instance, by infer_instance⟩\n\n"}
{"name":"SetTheory.PGame.add_eq_zero","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff ((HAdd.hAdd x y).Identical 0) (And (x.Identical 0) (y.Identical 0))","decl":"protected lemma add_eq_zero : ∀ {x y : PGame}, x + y ≡ 0 ↔ x ≡ 0 ∧ y ≡ 0\n  | mk xl xr xL xR, mk yl yr yL yR => by\n    simp_rw [identical_zero_iff, leftMoves_add, rightMoves_add, isEmpty_sum]\n    tauto\n\n"}
{"name":"SetTheory.PGame.Identical.add_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ x₂ y : SetTheory.PGame\na✝ : x₁.Identical x₂\n⊢ (HAdd.hAdd x₁ y).Identical (HAdd.hAdd x₂ y)","decl":"lemma Identical.add_right {x₁ x₂ y} : x₁ ≡ x₂ → x₁ + y ≡ x₂ + y :=\n  match x₁, x₂, y with\n  | mk x₁l x₁r x₁L x₁R, mk x₂l x₂r x₂L x₂R, mk yl yr yL yR => by\n    intro h\n    refine ⟨⟨?_, ?_⟩, ⟨?_, ?_⟩⟩ <;> rintro (_ | _) <;> try exact ⟨.inr _, h.add_right⟩\n    · exact (h.1.1 _).elim (⟨.inl ·, ·.add_right⟩)\n    · exact (h.1.2 _).elim (⟨.inl ·, ·.add_right⟩)\n    · exact (h.2.1 _).elim (⟨.inl ·, ·.add_right⟩)\n    · exact (h.2.2 _).elim (⟨.inl ·, ·.add_right⟩)\n  termination_by (x₁, x₂, y)\n\n"}
{"name":"SetTheory.PGame.Identical.add_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y₁ y₂ : SetTheory.PGame\nhy : y₁.Identical y₂\n⊢ (HAdd.hAdd x y₁).Identical (HAdd.hAdd x y₂)","decl":"lemma Identical.add_left {x y₁ y₂} (hy : y₁ ≡ y₂) : x + y₁ ≡ x + y₂ :=\n  (x.add_comm y₁).trans (hy.add_right.trans (y₂.add_comm x))\n\n"}
{"name":"SetTheory.PGame.Identical.add","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ x₂ y₁ y₂ : SetTheory.PGame\nhx : x₁.Identical x₂\nhy : y₁.Identical y₂\n⊢ (HAdd.hAdd x₁ y₁).Identical (HAdd.hAdd x₂ y₂)","decl":"/-- If `w` has the same moves as `x` and `y` has the same moves as `z`,\nthen `w + y` has the same moves as `x + z`. -/\nlemma Identical.add {x₁ x₂ y₁ y₂ : PGame.{u}} (hx : x₁ ≡ x₂) (hy : y₁ ≡ y₂) : x₁ + y₁ ≡ x₂ + y₂ :=\n  hx.add_right.trans hy.add_left\n\n"}
{"name":"SetTheory.PGame.memₗ_add_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y₁ y₂ : SetTheory.PGame\n⊢ Iff (x.memₗ (HAdd.hAdd y₁ y₂)) (Or (Exists fun z => And (z.memₗ y₁) (x.Identical (HAdd.hAdd z y₂))) (Exists fun z => And (z.memₗ y₂) (x.Identical (HAdd.hAdd y₁ z))))","decl":"lemma memₗ_add_iff {x y₁ y₂ : PGame} :\n    x ∈ₗ y₁ + y₂ ↔ (∃ z ∈ₗ y₁, x ≡ z + y₂) ∨ (∃ z ∈ₗ y₂, x ≡ y₁ + z) := by\n  cases' y₁ with y₁l y₁r y₁L y₁R\n  cases' y₂ with y₂l y₂r y₂L y₂R\n  constructor\n  · rintro ⟨(i | i), hi⟩\n    exacts [.inl ⟨y₁L i, moveLeft_memₗ _ _, hi⟩, .inr ⟨y₂L i, moveLeft_memₗ _ _, hi⟩]\n  · rintro (⟨_, ⟨i, hi⟩, h⟩ | ⟨_, ⟨i, hi⟩, h⟩)\n    exacts [⟨.inl i, h.trans hi.add_right⟩, ⟨.inr i, h.trans hi.add_left⟩]\n\n"}
{"name":"SetTheory.PGame.memᵣ_add_iff","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y₁ y₂ : SetTheory.PGame\n⊢ Iff (x.memᵣ (HAdd.hAdd y₁ y₂)) (Or (Exists fun z => And (z.memᵣ y₁) (x.Identical (HAdd.hAdd z y₂))) (Exists fun z => And (z.memᵣ y₂) (x.Identical (HAdd.hAdd y₁ z))))","decl":"lemma memᵣ_add_iff {x y₁ y₂ : PGame} :\n    x ∈ᵣ y₁ + y₂ ↔ (∃ z ∈ᵣ y₁, x ≡ z + y₂) ∨ (∃ z ∈ᵣ y₂, x ≡ y₁ + z) := by\n  cases' y₁ with y₁l y₁r y₁L y₁R\n  cases' y₂ with y₂l y₂r y₂L y₂R\n  constructor\n  · rintro ⟨(i | i), hi⟩\n    exacts [.inl ⟨y₁R i, moveRight_memᵣ _ _, hi⟩, .inr ⟨y₂R i, moveRight_memᵣ _ _, hi⟩]\n  · rintro (⟨_, ⟨i, hi⟩, h⟩ | ⟨_, ⟨i, hi⟩, h⟩)\n    exacts [⟨.inl i, h.trans hi.add_right⟩, ⟨.inr i, h.trans hi.add_left⟩]\n\n"}
{"name":"SetTheory.PGame.sub_zero_eq_add_zero","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ Eq (HSub.hSub x 0) (HAdd.hAdd x 0)","decl":"@[simp]\ntheorem sub_zero_eq_add_zero (x : PGame) : x - 0 = x + 0 :=\n  show x + -0 = x + 0 by rw [neg_zero]\n\n"}
{"name":"SetTheory.PGame.sub_zero","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ (HSub.hSub x 0).Identical x","decl":"protected lemma sub_zero (x : PGame) : x - 0 ≡ x :=\n  _root_.trans (of_eq x.sub_zero_eq_add_zero) x.add_zero\n\n"}
{"name":"SetTheory.PGame.neg_sub'","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (Neg.neg (HSub.hSub x y)) (HSub.hSub (Neg.neg x) (Neg.neg y))","decl":"/-- This lemma is named to match `neg_sub'`. -/\nprotected lemma neg_sub' (x y : PGame) : -(x - y) = -x - -y := PGame.neg_add _ _\n\n"}
{"name":"SetTheory.PGame.Identical.sub","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x₁ x₂ y₁ y₂ : SetTheory.PGame\nhx : x₁.Identical x₂\nhy : y₁.Identical y₂\n⊢ (HSub.hSub x₁ y₁).Identical (HSub.hSub x₂ y₂)","decl":"/-- If `w` has the same moves as `x` and `y` has the same moves as `z`,\nthen `w - y` has the same moves as `x - z`. -/\nlemma Identical.sub {x₁ x₂ y₁ y₂ : PGame.{u}} (hx : x₁ ≡ x₂) (hy : y₁ ≡ y₂) : x₁ - y₁ ≡ x₂ - y₂ :=\n  hx.add hy.neg\n\n"}
{"name":"SetTheory.PGame.neg_add_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ LE.le (Neg.neg (HAdd.hAdd x y)) (HAdd.hAdd (Neg.neg x) (Neg.neg y))","decl":"theorem neg_add_le {x y : PGame} : -(x + y) ≤ -x + -y :=\n  (negAddRelabelling x y).le\n\n"}
{"name":"SetTheory.PGame.add_comm_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ LE.le (HAdd.hAdd x y) (HAdd.hAdd y x)","decl":"theorem add_comm_le {x y : PGame} : x + y ≤ y + x :=\n  (addCommRelabelling x y).le\n\n"}
{"name":"SetTheory.PGame.add_comm_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ HasEquiv.Equiv (HAdd.hAdd x y) (HAdd.hAdd y x)","decl":"theorem add_comm_equiv {x y : PGame} : x + y ≈ y + x :=\n  (addCommRelabelling x y).equiv\n\n"}
{"name":"SetTheory.PGame.add_assoc_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\n⊢ HasEquiv.Equiv (HAdd.hAdd (HAdd.hAdd x y) z) (HAdd.hAdd x (HAdd.hAdd y z))","decl":"theorem add_assoc_equiv {x y z : PGame} : x + y + z ≈ x + (y + z) :=\n  (addAssocRelabelling x y z).equiv\n\n"}
{"name":"SetTheory.PGame.neg_add_cancel_le_zero","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ LE.le (HAdd.hAdd (Neg.neg x) x) 0","decl":"theorem neg_add_cancel_le_zero : ∀ x : PGame, -x + x ≤ 0\n  | ⟨xl, xr, xL, xR⟩ =>\n    le_zero.2 fun i => by\n      cases' i with i i\n      · -- If Left played in -x, Right responds with the same move in x.\n        refine ⟨@toRightMovesAdd _ ⟨_, _, _, _⟩ (Sum.inr i), ?_⟩\n        convert @neg_add_cancel_le_zero (xR i)\n        apply add_moveRight_inr\n      · -- If Left in x, Right responds with the same move in -x.\n        dsimp\n        refine ⟨@toRightMovesAdd ⟨_, _, _, _⟩ _ (Sum.inl i), ?_⟩\n        convert @neg_add_cancel_le_zero (xL i)\n        apply add_moveRight_inl\n\n"}
{"name":"SetTheory.PGame.zero_le_neg_add_cancel","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ LE.le 0 (HAdd.hAdd (Neg.neg x) x)","decl":"theorem zero_le_neg_add_cancel (x : PGame) : 0 ≤ -x + x := by\n  rw [← neg_le_neg_iff, neg_zero]\n  exact neg_add_le.trans (neg_add_cancel_le_zero _)\n\n"}
{"name":"SetTheory.PGame.neg_add_cancel_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ HasEquiv.Equiv (HAdd.hAdd (Neg.neg x) x) 0","decl":"theorem neg_add_cancel_equiv (x : PGame) : -x + x ≈ 0 :=\n  ⟨neg_add_cancel_le_zero x, zero_le_neg_add_cancel x⟩\n\n"}
{"name":"SetTheory.PGame.add_neg_cancel_le_zero","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ LE.le (HAdd.hAdd x (Neg.neg x)) 0","decl":"theorem add_neg_cancel_le_zero (x : PGame) : x + -x ≤ 0 :=\n  add_comm_le.trans (neg_add_cancel_le_zero x)\n\n"}
{"name":"SetTheory.PGame.zero_le_add_neg_cancel","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ LE.le 0 (HAdd.hAdd x (Neg.neg x))","decl":"theorem zero_le_add_neg_cancel (x : PGame) : 0 ≤ x + -x :=\n  (zero_le_neg_add_cancel x).trans add_comm_le\n\n"}
{"name":"SetTheory.PGame.add_neg_cancel_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ HasEquiv.Equiv (HAdd.hAdd x (Neg.neg x)) 0","decl":"theorem add_neg_cancel_equiv (x : PGame) : x + -x ≈ 0 :=\n  ⟨add_neg_cancel_le_zero x, zero_le_add_neg_cancel x⟩\n\n"}
{"name":"SetTheory.PGame.sub_self_equiv","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame\n⊢ HasEquiv.Equiv (HSub.hSub x x) 0","decl":"theorem sub_self_equiv : ∀ (x : PGame), x - x ≈ 0 :=\n  add_neg_cancel_equiv\n\n"}
{"name":"SetTheory.PGame.addRightMono","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ AddRightMono SetTheory.PGame","decl":"instance addRightMono : AddRightMono PGame :=\n  ⟨fun _ _ _ => add_le_add_right'⟩\n\n"}
{"name":"SetTheory.PGame.addLeftMono","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ AddLeftMono SetTheory.PGame","decl":"instance addLeftMono : AddLeftMono PGame :=\n  ⟨fun x _ _ h => (add_comm_le.trans (add_le_add_right h x)).trans add_comm_le⟩\n\n"}
{"name":"SetTheory.PGame.add_lf_add_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"y z : SetTheory.PGame\nh : y.LF z\nx : SetTheory.PGame\n⊢ (HAdd.hAdd y x).LF (HAdd.hAdd z x)","decl":"theorem add_lf_add_right {y z : PGame} (h : y ⧏ z) (x) : y + x ⧏ z + x :=\n  suffices z + x ≤ y + x → z ≤ y by\n    rw [← PGame.not_le] at h ⊢\n    exact mt this h\n  fun w =>\n  calc\n    z ≤ z + 0 := (addZeroRelabelling _).symm.le\n    _ ≤ z + (x + -x) := add_le_add_left (zero_le_add_neg_cancel x) _\n    _ ≤ z + x + -x := (addAssocRelabelling _ _ _).symm.le\n    _ ≤ y + x + -x := add_le_add_right w _\n    _ ≤ y + (x + -x) := (addAssocRelabelling _ _ _).le\n    _ ≤ y + 0 := add_le_add_left (add_neg_cancel_le_zero x) _\n    _ ≤ y := (addZeroRelabelling _).le\n\n"}
{"name":"SetTheory.PGame.add_lf_add_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"y z : SetTheory.PGame\nh : y.LF z\nx : SetTheory.PGame\n⊢ (HAdd.hAdd x y).LF (HAdd.hAdd x z)","decl":"theorem add_lf_add_left {y z : PGame} (h : y ⧏ z) (x) : x + y ⧏ x + z := by\n  rw [lf_congr add_comm_equiv add_comm_equiv]\n  apply add_lf_add_right h\n\n"}
{"name":"SetTheory.PGame.addRightStrictMono","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ AddRightStrictMono SetTheory.PGame","decl":"instance addRightStrictMono : AddRightStrictMono PGame :=\n  ⟨fun x _ _ h => ⟨add_le_add_right h.1 x, add_lf_add_right h.2 x⟩⟩\n\n"}
{"name":"SetTheory.PGame.addLeftStrictMono","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ AddLeftStrictMono SetTheory.PGame","decl":"instance addLeftStrictMono : AddLeftStrictMono PGame :=\n  ⟨fun x _ _ h => ⟨add_le_add_left h.1 x, add_lf_add_left h.2 x⟩⟩\n\n"}
{"name":"SetTheory.PGame.add_lf_add_of_lf_of_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"w x y z : SetTheory.PGame\nhwx : w.LF x\nhyz : LE.le y z\n⊢ (HAdd.hAdd w y).LF (HAdd.hAdd x z)","decl":"theorem add_lf_add_of_lf_of_le {w x y z : PGame} (hwx : w ⧏ x) (hyz : y ≤ z) : w + y ⧏ x + z :=\n  lf_of_lf_of_le (add_lf_add_right hwx y) (add_le_add_left hyz x)\n\n"}
{"name":"SetTheory.PGame.add_lf_add_of_le_of_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"w x y z : SetTheory.PGame\nhwx : LE.le w x\nhyz : y.LF z\n⊢ (HAdd.hAdd w y).LF (HAdd.hAdd x z)","decl":"theorem add_lf_add_of_le_of_lf {w x y z : PGame} (hwx : w ≤ x) (hyz : y ⧏ z) : w + y ⧏ x + z :=\n  lf_of_le_of_lf (add_le_add_right hwx y) (add_lf_add_left hyz x)\n\n"}
{"name":"SetTheory.PGame.add_congr","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"w x y z : SetTheory.PGame\nh₁ : HasEquiv.Equiv w x\nh₂ : HasEquiv.Equiv y z\n⊢ HasEquiv.Equiv (HAdd.hAdd w y) (HAdd.hAdd x z)","decl":"theorem add_congr {w x y z : PGame} (h₁ : w ≈ x) (h₂ : y ≈ z) : w + y ≈ x + z :=\n  ⟨(add_le_add_left h₂.1 w).trans (add_le_add_right h₁.1 z),\n    (add_le_add_left h₂.2 x).trans (add_le_add_right h₁.2 y)⟩\n\n"}
{"name":"SetTheory.PGame.add_congr_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh : HasEquiv.Equiv x y\n⊢ HasEquiv.Equiv (HAdd.hAdd x z) (HAdd.hAdd y z)","decl":"theorem add_congr_left {x y z : PGame} (h : x ≈ y) : x + z ≈ y + z :=\n  add_congr h equiv_rfl\n\n"}
{"name":"SetTheory.PGame.add_congr_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\na✝ : HasEquiv.Equiv y z\n⊢ HasEquiv.Equiv (HAdd.hAdd x y) (HAdd.hAdd x z)","decl":"theorem add_congr_right {x y z : PGame} : (y ≈ z) → (x + y ≈ x + z) :=\n  add_congr equiv_rfl\n\n"}
{"name":"SetTheory.PGame.sub_congr","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"w x y z : SetTheory.PGame\nh₁ : HasEquiv.Equiv w x\nh₂ : HasEquiv.Equiv y z\n⊢ HasEquiv.Equiv (HSub.hSub w y) (HSub.hSub x z)","decl":"theorem sub_congr {w x y z : PGame} (h₁ : w ≈ x) (h₂ : y ≈ z) : w - y ≈ x - z :=\n  add_congr h₁ (neg_equiv_neg_iff.2 h₂)\n\n"}
{"name":"SetTheory.PGame.sub_congr_left","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\nh : HasEquiv.Equiv x y\n⊢ HasEquiv.Equiv (HSub.hSub x z) (HSub.hSub y z)","decl":"theorem sub_congr_left {x y z : PGame} (h : x ≈ y) : x - z ≈ y - z :=\n  sub_congr h equiv_rfl\n\n"}
{"name":"SetTheory.PGame.sub_congr_right","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y z : SetTheory.PGame\na✝ : HasEquiv.Equiv y z\n⊢ HasEquiv.Equiv (HSub.hSub x y) (HSub.hSub x z)","decl":"theorem sub_congr_right {x y z : PGame} : (y ≈ z) → (x - y ≈ x - z) :=\n  sub_congr equiv_rfl\n\n"}
{"name":"SetTheory.PGame.le_iff_sub_nonneg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (LE.le x y) (LE.le 0 (HSub.hSub y x))","decl":"theorem le_iff_sub_nonneg {x y : PGame} : x ≤ y ↔ 0 ≤ y - x :=\n  ⟨fun h => (zero_le_add_neg_cancel x).trans (add_le_add_right h _), fun h =>\n    calc\n      x ≤ 0 + x := (zeroAddRelabelling x).symm.le\n      _ ≤ y - x + x := add_le_add_right h _\n      _ ≤ y + (-x + x) := (addAssocRelabelling _ _ _).le\n      _ ≤ y + 0 := add_le_add_left (neg_add_cancel_le_zero x) _\n      _ ≤ y := (addZeroRelabelling y).le\n      ⟩\n\n"}
{"name":"SetTheory.PGame.lf_iff_sub_zero_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (x.LF y) (SetTheory.PGame.LF 0 (HSub.hSub y x))","decl":"theorem lf_iff_sub_zero_lf {x y : PGame} : x ⧏ y ↔ 0 ⧏ y - x :=\n  ⟨fun h => (zero_le_add_neg_cancel x).trans_lf (add_lf_add_right h _), fun h =>\n    calc\n      x ≤ 0 + x := (zeroAddRelabelling x).symm.le\n      _ ⧏ y - x + x := add_lf_add_right h _\n      _ ≤ y + (-x + x) := (addAssocRelabelling _ _ _).le\n      _ ≤ y + 0 := add_le_add_left (neg_add_cancel_le_zero x) _\n      _ ≤ y := (addZeroRelabelling y).le\n      ⟩\n\n"}
{"name":"SetTheory.PGame.lt_iff_sub_pos","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x y : SetTheory.PGame\n⊢ Iff (LT.lt x y) (LT.lt 0 (HSub.hSub y x))","decl":"theorem lt_iff_sub_pos {x y : PGame} : x < y ↔ 0 < y - x :=\n  ⟨fun h => lt_of_le_of_lt (zero_le_add_neg_cancel x) (add_lt_add_right h _), fun h =>\n    calc\n      x ≤ 0 + x := (zeroAddRelabelling x).symm.le\n      _ < y - x + x := add_lt_add_right h _\n      _ ≤ y + (-x + x) := (addAssocRelabelling _ _ _).le\n      _ ≤ y + 0 := add_le_add_left (neg_add_cancel_le_zero x) _\n      _ ≤ y := (addZeroRelabelling y).le\n      ⟩\n\n"}
{"name":"SetTheory.PGame.le_insertLeft","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x x' : SetTheory.PGame\n⊢ LE.le x (x.insertLeft x')","decl":"/-- A new left option cannot hurt Left. -/\nlemma le_insertLeft (x x' : PGame) : x ≤ insertLeft x x' := by\n  rw [le_def]\n  constructor\n  · intro i\n    left\n    rcases x with ⟨xl, xr, xL, xR⟩\n    simp only [insertLeft, leftMoves_mk, moveLeft_mk, Sum.exists, Sum.elim_inl]\n    left\n    use i\n  · intro j\n    right\n    rcases x with ⟨xl, xr, xL, xR⟩\n    simp only [rightMoves_mk, moveRight_mk, insertLeft]\n    use j\n\n"}
{"name":"SetTheory.PGame.insertLeft_equiv_of_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x x' : SetTheory.PGame\nh : x'.LF x\n⊢ HasEquiv.Equiv (x.insertLeft x') x","decl":"/-- Adding a gift horse left option does not change the value of `x`. A gift horse left option is\n a game `x'` with `x' ⧏ x`. It is called \"gift horse\" because it seems like Left has gotten the\n \"gift\" of a new option, but actually the value of the game did not change. -/\nlemma insertLeft_equiv_of_lf {x x' : PGame} (h : x' ⧏ x) : insertLeft x x' ≈ x := by\n  rw [equiv_def]\n  constructor\n  · rw [le_def]\n    constructor\n    · intro i\n      rcases x with ⟨xl, xr, xL, xR⟩\n      simp only [insertLeft, leftMoves_mk, moveLeft_mk] at i ⊢\n      rcases i with i | _\n      · simp only [Sum.elim_inl]\n        left\n        use i\n      · simp only [Sum.elim_inr]\n        rw [lf_iff_exists_le] at h\n        simp only [leftMoves_mk, moveLeft_mk] at h\n        exact h\n    · intro j\n      right\n      rcases x with ⟨xl, xr, xL, xR⟩\n      simp only [insertLeft, rightMoves_mk, moveRight_mk]\n      use j\n  · apply le_insertLeft\n\n"}
{"name":"SetTheory.PGame.neg_insertRight_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x x' : SetTheory.PGame\n⊢ Eq ((Neg.neg x).insertRight (Neg.neg x')) (Neg.neg (x.insertLeft x'))","decl":"theorem neg_insertRight_neg (x x' : PGame.{u}) : (-x).insertRight (-x') = -x.insertLeft x' := by\n  cases x\n  cases x'\n  dsimp [insertRight, insertLeft]\n  congr! with (i | j)\n\n"}
{"name":"SetTheory.PGame.neg_insertLeft_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x x' : SetTheory.PGame\n⊢ Eq ((Neg.neg x).insertLeft (Neg.neg x')) (Neg.neg (x.insertRight x'))","decl":"theorem neg_insertLeft_neg (x x' : PGame.{u}) : (-x).insertLeft (-x') = -x.insertRight x' := by\n  rw [← neg_eq_iff_eq_neg, ← neg_insertRight_neg, neg_neg, neg_neg]\n\n"}
{"name":"SetTheory.PGame.insertRight_le","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x x' : SetTheory.PGame\n⊢ LE.le (x.insertRight x') x","decl":"/-- A new right option cannot hurt Right. -/\nlemma insertRight_le (x x' : PGame) : insertRight x x' ≤ x := by\n  rw [← neg_le_neg_iff, ← neg_insertLeft_neg]\n  exact le_insertLeft _ _\n\n"}
{"name":"SetTheory.PGame.insertRight_equiv_of_lf","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x x' : SetTheory.PGame\nh : x.LF x'\n⊢ HasEquiv.Equiv (x.insertRight x') x","decl":"/-- Adding a gift horse right option does not change the value of `x`. A gift horse right option is\n a game `x'` with `x ⧏ x'`. It is called \"gift horse\" because it seems like Right has gotten the\n \"gift\" of a new option, but actually the value of the game did not change. -/\nlemma insertRight_equiv_of_lf {x x' : PGame} (h : x ⧏ x') : insertRight x x' ≈ x := by\n  rw [← neg_equiv_neg_iff, ← neg_insertLeft_neg]\n  exact insertLeft_equiv_of_lf (neg_lf_neg_iff.mpr h)\n\n"}
{"name":"SetTheory.PGame.insertRight_insertLeft","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x x' x'' : SetTheory.PGame\n⊢ Eq ((x.insertLeft x').insertRight x'') ((x.insertRight x'').insertLeft x')","decl":"/-- Inserting on the left and right commutes. -/\ntheorem insertRight_insertLeft {x x' x'' : PGame} :\n    insertRight (insertLeft x x') x'' = insertLeft (insertRight x x'') x' := by\n  cases x; cases x'; cases x''\n  dsimp [insertLeft, insertRight]\n\n"}
{"name":"SetTheory.PGame.star_leftMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ Eq SetTheory.PGame.star.LeftMoves PUnit.{u_1 + 1}","decl":"@[simp]\ntheorem star_leftMoves : star.LeftMoves = PUnit :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.star_rightMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ Eq SetTheory.PGame.star.RightMoves PUnit.{u_1 + 1}","decl":"@[simp]\ntheorem star_rightMoves : star.RightMoves = PUnit :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.star_moveLeft","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame.star.LeftMoves\n⊢ Eq (SetTheory.PGame.star.moveLeft x) 0","decl":"@[simp]\ntheorem star_moveLeft (x) : star.moveLeft x = 0 :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.star_moveRight","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame.star.RightMoves\n⊢ Eq (SetTheory.PGame.star.moveRight x) 0","decl":"@[simp]\ntheorem star_moveRight (x) : star.moveRight x = 0 :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.zero_lf_star","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ SetTheory.PGame.LF 0 SetTheory.PGame.star","decl":"theorem zero_lf_star : 0 ⧏ star := by\n  rw [zero_lf]\n  use default\n  rintro ⟨⟩\n\n"}
{"name":"SetTheory.PGame.star_lf_zero","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ SetTheory.PGame.star.LF 0","decl":"theorem star_lf_zero : star ⧏ 0 := by\n  rw [lf_zero]\n  use default\n  rintro ⟨⟩\n\n"}
{"name":"SetTheory.PGame.star_fuzzy_zero","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ SetTheory.PGame.star.Fuzzy 0","decl":"theorem star_fuzzy_zero : star ‖ 0 :=\n  ⟨star_lf_zero, zero_lf_star⟩\n\n"}
{"name":"SetTheory.PGame.neg_star","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ Eq (Neg.neg SetTheory.PGame.star) SetTheory.PGame.star","decl":"@[simp]\ntheorem neg_star : -star = star := by simp [star]\n\n"}
{"name":"SetTheory.PGame.zero_lt_one","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ LT.lt 0 1","decl":"@[simp]\nprotected theorem zero_lt_one : (0 : PGame) < 1 :=\n  lt_of_le_of_lf (zero_le_of_isEmpty_rightMoves 1) (zero_lf_le.2 ⟨default, le_rfl⟩)\n\n"}
{"name":"SetTheory.PGame.up_leftMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ Eq SetTheory.PGame.up.LeftMoves PUnit.{u_1 + 1}","decl":"@[simp]\ntheorem up_leftMoves : up.LeftMoves = PUnit :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.up_rightMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ Eq SetTheory.PGame.up.RightMoves PUnit.{u_1 + 1}","decl":"@[simp]\ntheorem up_rightMoves : up.RightMoves = PUnit :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.up_moveLeft","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame.up.LeftMoves\n⊢ Eq (SetTheory.PGame.up.moveLeft x) 0","decl":"@[simp]\ntheorem up_moveLeft (x) : up.moveLeft x = 0 :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.up_moveRight","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame.up.RightMoves\n⊢ Eq (SetTheory.PGame.up.moveRight x) SetTheory.PGame.star","decl":"@[simp]\ntheorem up_moveRight (x) : up.moveRight x = star :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.up_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ LT.lt 0 SetTheory.PGame.up","decl":"@[simp]\ntheorem up_neg : 0 < up := by\n  rw [lt_iff_le_and_lf, zero_lf]\n  simp [zero_le_lf, zero_lf_star]\n\n"}
{"name":"SetTheory.PGame.star_fuzzy_up","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ SetTheory.PGame.star.Fuzzy SetTheory.PGame.up","decl":"theorem star_fuzzy_up : star ‖ up := by\n  unfold Fuzzy\n  simp only [← PGame.not_le]\n  simp [le_iff_forall_lf]\n\n"}
{"name":"SetTheory.PGame.down_leftMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ Eq SetTheory.PGame.down.LeftMoves PUnit.{u_1 + 1}","decl":"@[simp]\ntheorem down_leftMoves : down.LeftMoves = PUnit :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.down_rightMoves","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ Eq SetTheory.PGame.down.RightMoves PUnit.{u_1 + 1}","decl":"@[simp]\ntheorem down_rightMoves : down.RightMoves = PUnit :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.down_moveLeft","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame.down.LeftMoves\n⊢ Eq (SetTheory.PGame.down.moveLeft x) SetTheory.PGame.star","decl":"@[simp]\ntheorem down_moveLeft (x) : down.moveLeft x = star :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.down_moveRight","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"x : SetTheory.PGame.down.RightMoves\n⊢ Eq (SetTheory.PGame.down.moveRight x) 0","decl":"@[simp]\ntheorem down_moveRight (x) : down.moveRight x = 0 :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.down_neg","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ LT.lt SetTheory.PGame.down 0","decl":"@[simp]\ntheorem down_neg : down < 0 := by\n  rw [lt_iff_le_and_lf, lf_zero]\n  simp [le_zero_lf, star_lf_zero]\n\n"}
{"name":"SetTheory.PGame.neg_down","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ Eq (Neg.neg SetTheory.PGame.down) SetTheory.PGame.up","decl":"@[simp]\ntheorem neg_down : -down = up := by simp [up, down]\n\n"}
{"name":"SetTheory.PGame.neg_up","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ Eq (Neg.neg SetTheory.PGame.up) SetTheory.PGame.down","decl":"@[simp]\ntheorem neg_up : -up = down := by simp [up, down]\n\n"}
{"name":"SetTheory.PGame.star_fuzzy_down","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ SetTheory.PGame.star.Fuzzy SetTheory.PGame.down","decl":"theorem star_fuzzy_down : star ‖ down := by\n  rw [← neg_fuzzy_neg_iff, neg_down, neg_star]\n  exact star_fuzzy_up\n\n"}
{"name":"SetTheory.PGame.instZeroLEOneClass","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ ZeroLEOneClass SetTheory.PGame","decl":"instance : ZeroLEOneClass PGame :=\n  ⟨PGame.zero_lt_one.le⟩\n\n"}
{"name":"SetTheory.PGame.zero_lf_one","module":"Mathlib.SetTheory.Game.PGame","initialProofState":"⊢ SetTheory.PGame.LF 0 1","decl":"@[simp]\ntheorem zero_lf_one : (0 : PGame) ⧏ 1 :=\n  PGame.zero_lt_one.lf\n\n"}
