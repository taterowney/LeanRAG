{"name":"CategoryTheory.Idempotents.app_idem_assoc","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nP : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\nX : J\nZ : C\nh : Quiver.Hom (P.X.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.p.app X) (CategoryTheory.CategoryStruct.comp (P.p.app X) h)) (CategoryTheory.CategoryStruct.comp (P.p.app X) h)","decl":"@[reassoc (attr := simp)]\ntheorem app_idem : P.p.app X ‚â´ P.p.app X = P.p.app X :=\n  congr_app P.idem X\n\n"}
{"name":"CategoryTheory.Idempotents.app_idem","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nP : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\nX : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.p.app X) (P.p.app X)) (P.p.app X)","decl":"@[reassoc (attr := simp)]\ntheorem app_idem : P.p.app X ‚â´ P.p.app X = P.p.app X :=\n  congr_app P.idem X\n\n"}
{"name":"CategoryTheory.Idempotents.app_p_comp","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nP Q : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\nf : Quiver.Hom P Q\nX : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.p.app X) (f.f.app X)) (f.f.app X)","decl":"@[reassoc (attr := simp)]\ntheorem app_p_comp : P.p.app X ‚â´ f.f.app X = f.f.app X :=\n  congr_app (p_comp f) X\n\n"}
{"name":"CategoryTheory.Idempotents.app_p_comp_assoc","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nP Q : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\nf : Quiver.Hom P Q\nX : J\nZ : C\nh : Quiver.Hom (Q.X.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.p.app X) (CategoryTheory.CategoryStruct.comp (f.f.app X) h)) (CategoryTheory.CategoryStruct.comp (f.f.app X) h)","decl":"@[reassoc (attr := simp)]\ntheorem app_p_comp : P.p.app X ‚â´ f.f.app X = f.f.app X :=\n  congr_app (p_comp f) X\n\n"}
{"name":"CategoryTheory.Idempotents.app_comp_p","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nP Q : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\nf : Quiver.Hom P Q\nX : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f.f.app X) (Q.p.app X)) (f.f.app X)","decl":"@[reassoc (attr := simp)]\ntheorem app_comp_p : f.f.app X ‚â´ Q.p.app X = f.f.app X :=\n  congr_app (comp_p f) X\n\n"}
{"name":"CategoryTheory.Idempotents.app_comp_p_assoc","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nP Q : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\nf : Quiver.Hom P Q\nX : J\nZ : C\nh : Quiver.Hom (Q.X.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f.f.app X) (CategoryTheory.CategoryStruct.comp (Q.p.app X) h)) (CategoryTheory.CategoryStruct.comp (f.f.app X) h)","decl":"@[reassoc (attr := simp)]\ntheorem app_comp_p : f.f.app X ‚â´ Q.p.app X = f.f.app X :=\n  congr_app (comp_p f) X\n\n"}
{"name":"CategoryTheory.Idempotents.app_p_comm_assoc","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nP Q : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\nf : Quiver.Hom P Q\nX : J\nZ : C\nh : Quiver.Hom (Q.X.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.p.app X) (CategoryTheory.CategoryStruct.comp (f.f.app X) h)) (CategoryTheory.CategoryStruct.comp (f.f.app X) (CategoryTheory.CategoryStruct.comp (Q.p.app X) h))","decl":"@[reassoc]\ntheorem app_p_comm : P.p.app X ‚â´ f.f.app X = f.f.app X ‚â´ Q.p.app X :=\n  congr_app (p_comm f) X\n\n"}
{"name":"CategoryTheory.Idempotents.app_p_comm","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\nP Q : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\nf : Quiver.Hom P Q\nX : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.p.app X) (f.f.app X)) (CategoryTheory.CategoryStruct.comp (f.f.app X) (Q.p.app X))","decl":"@[reassoc]\ntheorem app_p_comm : P.p.app X ‚â´ f.f.app X = f.f.app X ‚â´ Q.p.app X :=\n  congr_app (p_comm f) X\n\n"}
{"name":"CategoryTheory.Idempotents.functor_category_isIdempotentComplete","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_2} C\ninst‚úù : CategoryTheory.IsIdempotentComplete C\n‚ä¢ CategoryTheory.IsIdempotentComplete (CategoryTheory.Functor J C)","decl":"instance functor_category_isIdempotentComplete [IsIdempotentComplete C] :\n    IsIdempotentComplete (J ‚•§ C) := by\n  refine ‚ü®fun F p hp => ?_‚ü©\n  have hC := (isIdempotentComplete_iff_hasEqualizer_of_id_and_idempotent C).mp inferInstance\n  haveI : ‚àÄ j : J, HasEqualizer (ùüô _) (p.app j) := fun j => hC _ _ (congr_app hp j)\n  /- We construct the direct factor `Y` associated to `p : F ‚ü∂ F` by computing\n      the equalizer of the identity and `p.app j` on each object `(j : J)`. -/\n  let Y : J ‚•§ C :=\n    { obj := fun j => Limits.equalizer (ùüô _) (p.app j)\n      map := fun {j j'} œÜ =>\n        equalizer.lift (Limits.equalizer.Œπ (ùüô _) (p.app j) ‚â´ F.map œÜ)\n          (by rw [comp_id, assoc, p.naturality œÜ, ‚Üê assoc, ‚Üê Limits.equalizer.condition, comp_id]) }\n  let i : Y ‚ü∂ F :=\n    { app := fun j => equalizer.Œπ _ _\n      naturality := fun _ _ _ => by rw [equalizer.lift_Œπ] }\n  let e : F ‚ü∂ Y :=\n    { app := fun j =>\n        equalizer.lift (p.app j) (by simpa only [comp_id] using (congr_app hp j).symm)\n      naturality := fun j j' œÜ => equalizer.hom_ext (by simp [Y]) }\n  use Y, i, e\n  constructor\n  ¬∑ ext j\n    dsimp\n    rw [assoc, equalizer.lift_Œπ, ‚Üê equalizer.condition, id_comp, comp_id]\n  ¬∑ ext j\n    simp [Y, i, e]\n"}
{"name":"CategoryTheory.Idempotents.KaroubiFunctorCategoryEmbedding.obj_map_f","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nP : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\nj j' : J\nœÜ : Quiver.Hom j j'\n‚ä¢ Eq ((CategoryTheory.Idempotents.KaroubiFunctorCategoryEmbedding.obj P).map œÜ).f (CategoryTheory.CategoryStruct.comp (P.p.app j) (P.X.map œÜ))","decl":"/-- On objects, the functor which sends a formal direct factor `P` of a\nfunctor `F : J ‚•§ C` to the functor `J ‚•§ Karoubi C` which sends `(j : J)` to\nthe corresponding direct factor of `F.obj j`. -/\n@[simps]\ndef obj (P : Karoubi (J ‚•§ C)) : J ‚•§ Karoubi C where\n  obj j := ‚ü®P.X.obj j, P.p.app j, congr_app P.idem j‚ü©\n  map {j j'} œÜ :=\n    { f := P.p.app j ‚â´ P.X.map œÜ\n      comm := by\n        simp only [NatTrans.naturality, assoc]\n        have h := congr_app P.idem j\n        rw [NatTrans.comp_app] at h\n        rw [reassoc_of% h, reassoc_of% h] }\n\n"}
{"name":"CategoryTheory.Idempotents.KaroubiFunctorCategoryEmbedding.obj_obj_p","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nP : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\nj : J\n‚ä¢ Eq ((CategoryTheory.Idempotents.KaroubiFunctorCategoryEmbedding.obj P).obj j).p (P.p.app j)","decl":"/-- On objects, the functor which sends a formal direct factor `P` of a\nfunctor `F : J ‚•§ C` to the functor `J ‚•§ Karoubi C` which sends `(j : J)` to\nthe corresponding direct factor of `F.obj j`. -/\n@[simps]\ndef obj (P : Karoubi (J ‚•§ C)) : J ‚•§ Karoubi C where\n  obj j := ‚ü®P.X.obj j, P.p.app j, congr_app P.idem j‚ü©\n  map {j j'} œÜ :=\n    { f := P.p.app j ‚â´ P.X.map œÜ\n      comm := by\n        simp only [NatTrans.naturality, assoc]\n        have h := congr_app P.idem j\n        rw [NatTrans.comp_app] at h\n        rw [reassoc_of% h, reassoc_of% h] }\n\n"}
{"name":"CategoryTheory.Idempotents.KaroubiFunctorCategoryEmbedding.obj_obj_X","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nP : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\nj : J\n‚ä¢ Eq ((CategoryTheory.Idempotents.KaroubiFunctorCategoryEmbedding.obj P).obj j).X (P.X.obj j)","decl":"/-- On objects, the functor which sends a formal direct factor `P` of a\nfunctor `F : J ‚•§ C` to the functor `J ‚•§ Karoubi C` which sends `(j : J)` to\nthe corresponding direct factor of `F.obj j`. -/\n@[simps]\ndef obj (P : Karoubi (J ‚•§ C)) : J ‚•§ Karoubi C where\n  obj j := ‚ü®P.X.obj j, P.p.app j, congr_app P.idem j‚ü©\n  map {j j'} œÜ :=\n    { f := P.p.app j ‚â´ P.X.map œÜ\n      comm := by\n        simp only [NatTrans.naturality, assoc]\n        have h := congr_app P.idem j\n        rw [NatTrans.comp_app] at h\n        rw [reassoc_of% h, reassoc_of% h] }\n\n"}
{"name":"CategoryTheory.Idempotents.KaroubiFunctorCategoryEmbedding.map_app_f","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nP Q : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\nf : Quiver.Hom P Q\nj : J\n‚ä¢ Eq ((CategoryTheory.Idempotents.KaroubiFunctorCategoryEmbedding.map f).app j).f (f.f.app j)","decl":"/-- Tautological action on maps of the functor `Karoubi (J ‚•§ C) ‚•§ (J ‚•§ Karoubi C)`. -/\n@[simps]\ndef map {P Q : Karoubi (J ‚•§ C)} (f : P ‚ü∂ Q) : obj P ‚ü∂ obj Q where\n  app j := ‚ü®f.f.app j, congr_app f.comm j‚ü©\n\n"}
{"name":"CategoryTheory.Idempotents.karoubiFunctorCategoryEmbedding_obj","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nP : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\n‚ä¢ Eq ((CategoryTheory.Idempotents.karoubiFunctorCategoryEmbedding J C).obj P) (CategoryTheory.Idempotents.KaroubiFunctorCategoryEmbedding.obj P)","decl":"/-- The tautological fully faithful functor `Karoubi (J ‚•§ C) ‚•§ (J ‚•§ Karoubi C)`. -/\n@[simps]\ndef karoubiFunctorCategoryEmbedding : Karoubi (J ‚•§ C) ‚•§ J ‚•§ Karoubi C where\n  obj := KaroubiFunctorCategoryEmbedding.obj\n  map := KaroubiFunctorCategoryEmbedding.map\n\n"}
{"name":"CategoryTheory.Idempotents.karoubiFunctorCategoryEmbedding_map","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\nX‚úù Y‚úù : CategoryTheory.Idempotents.Karoubi (CategoryTheory.Functor J C)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Idempotents.karoubiFunctorCategoryEmbedding J C).map f) (CategoryTheory.Idempotents.KaroubiFunctorCategoryEmbedding.map f)","decl":"/-- The tautological fully faithful functor `Karoubi (J ‚•§ C) ‚•§ (J ‚•§ Karoubi C)`. -/\n@[simps]\ndef karoubiFunctorCategoryEmbedding : Karoubi (J ‚•§ C) ‚•§ J ‚•§ Karoubi C where\n  obj := KaroubiFunctorCategoryEmbedding.obj\n  map := KaroubiFunctorCategoryEmbedding.map\n\n"}
{"name":"CategoryTheory.Idempotents.instFullKaroubiFunctorKaroubiFunctorCategoryEmbedding","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\n‚ä¢ (CategoryTheory.Idempotents.karoubiFunctorCategoryEmbedding J C).Full","decl":"instance : (karoubiFunctorCategoryEmbedding J C).Full where\n  map_surjective {P Q} f :=\n   ‚ü®{ f :=\n        { app := fun j => (f.app j).f\n          naturality := fun j j' œÜ => by\n            rw [‚Üê Karoubi.comp_p_assoc]\n            have h := hom_ext_iff.mp (f.naturality œÜ)\n            simp only [comp_f] at h\n            dsimp [karoubiFunctorCategoryEmbedding] at h\n            erw [‚Üê h, assoc, ‚Üê P.p.naturality_assoc œÜ, p_comp (f.app j')] }\n      comm := by\n        ext j\n        exact (f.app j).comm }, rfl‚ü©\n\n"}
{"name":"CategoryTheory.Idempotents.instFaithfulKaroubiFunctorKaroubiFunctorCategoryEmbedding","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} J\ninst‚úù : CategoryTheory.Category.{u_3, u_2} C\n‚ä¢ (CategoryTheory.Idempotents.karoubiFunctorCategoryEmbedding J C).Faithful","decl":"instance : (karoubiFunctorCategoryEmbedding J C).Faithful where\n  map_injective h := by\n    ext j\n    exact hom_ext_iff.mp (congr_app h j)\n\n"}
{"name":"CategoryTheory.Idempotents.toKaroubi_comp_karoubiFunctorCategoryEmbedding","module":"Mathlib.CategoryTheory.Idempotents.FunctorCategories","initialProofState":"J : Type u_1\nC : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} J\ninst‚úù : CategoryTheory.Category.{u_4, u_2} C\n‚ä¢ Eq ((CategoryTheory.Idempotents.toKaroubi (CategoryTheory.Functor J C)).comp (CategoryTheory.Idempotents.karoubiFunctorCategoryEmbedding J C)) ((CategoryTheory.whiskeringRight J C (CategoryTheory.Idempotents.Karoubi C)).obj (CategoryTheory.Idempotents.toKaroubi C))","decl":"/-- The composition of `(J ‚•§ C) ‚•§ Karoubi (J ‚•§ C)` and `Karoubi (J ‚•§ C) ‚•§ (J ‚•§ Karoubi C)`\nequals the functor `(J ‚•§ C) ‚•§ (J ‚•§ Karoubi C)` given by the composition with\n`toKaroubi C : C ‚•§ Karoubi C`. -/\ntheorem toKaroubi_comp_karoubiFunctorCategoryEmbedding :\n    toKaroubi _ ‚ãô karoubiFunctorCategoryEmbedding J C =\n      (whiskeringRight J _ _).obj (toKaroubi C) := by\n  apply Functor.ext\n  ¬∑ intro X Y f\n    ext j\n    simp\n  ¬∑ intro X\n    apply Functor.ext\n    ¬∑ intro j j' œÜ\n      ext\n      simp\n    ¬∑ intro j\n      rfl\n\n"}
