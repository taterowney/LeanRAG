{"name":"Finite.exists_minimal_le","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\na : α\np : α → Prop\ninst✝ : Finite α\nh : p a\n⊢ Exists fun b => And (LE.le b a) (Minimal p b)","decl":"lemma Finite.exists_minimal_le [Finite α] (h : p a) : ∃ b, b ≤ a ∧ Minimal p b := by\n  obtain ⟨b, ⟨hba, hb⟩, hbmin⟩ :=\n    Set.Finite.exists_minimal_wrt id {x | x ≤ a ∧ p x} (Set.toFinite _) ⟨a, rfl.le, h⟩\n  exact ⟨b, hba, hb, fun x hx hxb ↦ (hbmin x ⟨hxb.trans hba, hx⟩ hxb).le⟩\n\n"}
{"name":"Finite.exists_ge_minimal","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\na : α\np : α → Prop\ninst✝ : Finite α\nh : p a\n⊢ Exists fun b => And (LE.le b a) (Minimal p b)","decl":"@[deprecated (since := \"2024-09-23\")] alias Finite.exists_ge_minimal := Finite.exists_minimal_le\n\n"}
{"name":"Finite.exists_le_maximal","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\na : α\np : α → Prop\ninst✝ : Finite α\nh : p a\n⊢ Exists fun b => And (LE.le a b) (Maximal p b)","decl":"lemma Finite.exists_le_maximal [Finite α] (h : p a) : ∃ b, a ≤ b ∧ Maximal p b :=\n  Finite.exists_minimal_le (α := αᵒᵈ) h\n\n"}
{"name":"Finset.exists_minimal_le","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\ns : Finset α\nh : Membership.mem s a\n⊢ Exists fun b => And (LE.le b a) (Minimal (fun x => Membership.mem s x) b)","decl":"lemma Finset.exists_minimal_le (s : Finset α) (h : a ∈ s) : ∃ b, b ≤ a ∧ Minimal (· ∈ s) b := by\n  obtain ⟨⟨b, _⟩, lb, minb⟩ := @Finite.exists_minimal_le s _ ⟨a, h⟩ (·.1 ∈ s) _ h\n  use b, lb; rwa [minimal_subtype, inf_idem] at minb\n\n"}
{"name":"Finset.exists_le_maximal","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\ns : Finset α\nh : Membership.mem s a\n⊢ Exists fun b => And (LE.le a b) (Maximal (fun x => Membership.mem s x) b)","decl":"lemma Finset.exists_le_maximal (s : Finset α) (h : a ∈ s) : ∃ b, a ≤ b ∧ Maximal (· ∈ s) b :=\n  s.exists_minimal_le (α := αᵒᵈ) h\n\n"}
{"name":"Set.Finite.exists_minimal_le","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\ns : Set α\nhs : s.Finite\nh : Membership.mem s a\n⊢ Exists fun b => And (LE.le b a) (Minimal (fun x => Membership.mem s x) b)","decl":"lemma Set.Finite.exists_minimal_le {s : Set α} (hs : s.Finite) (h : a ∈ s) :\n    ∃ b, b ≤ a ∧ Minimal (· ∈ s) b := by\n  obtain ⟨b, lb, minb⟩ := hs.toFinset.exists_minimal_le (hs.mem_toFinset.mpr h)\n  use b, lb; simpa using minb\n\n"}
{"name":"Set.Finite.exists_le_maximal","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\ns : Set α\nhs : s.Finite\nh : Membership.mem s a\n⊢ Exists fun b => And (LE.le a b) (Maximal (fun x => Membership.mem s x) b)","decl":"lemma Set.Finite.exists_le_maximal {s : Set α} (hs : s.Finite) (h : a ∈ s) :\n    ∃ b, a ≤ b ∧ Maximal (· ∈ s) b :=\n  hs.exists_minimal_le (α := αᵒᵈ) h\n\n"}
{"name":"Directed.finite_set_le","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝¹ : IsTrans α r\nγ : Type u_3\ninst✝ : Nonempty γ\nf : γ → α\nD : Directed r f\ns : Set γ\nhs : s.Finite\n⊢ Exists fun z => ∀ (i : γ), Membership.mem s i → r (f i) (f z)","decl":"theorem Directed.finite_set_le (D : Directed r f) {s : Set γ} (hs : s.Finite) :\n    ∃ z, ∀ i ∈ s, r (f i) (f z) := by\n  convert D.finset_le hs.toFinset using 3; rw [Set.Finite.mem_toFinset]\n\n"}
{"name":"Directed.finite_le","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝² : IsTrans α r\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : Nonempty γ\nf : γ → α\ninst✝ : Finite β\nD : Directed r f\ng : β → γ\n⊢ Exists fun z => ∀ (i : β), r (f (g i)) (f z)","decl":"theorem Directed.finite_le (D : Directed r f) (g : β → γ) : ∃ z, ∀ i, r (f (g i)) (f z) := by\n  classical\n    obtain ⟨z, hz⟩ := D.finite_set_le (Set.finite_range g)\n    exact ⟨z, fun i => hz (g i) ⟨i, rfl⟩⟩\n\n"}
{"name":"Finite.exists_le","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Finite β\ninst✝² : Nonempty α\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\nf : β → α\n⊢ Exists fun M => ∀ (i : β), LE.le (f i) M","decl":"theorem Finite.exists_le [IsDirected α (· ≤ ·)] (f : β → α) : ∃ M, ∀ i, f i ≤ M :=\n  directed_id.finite_le _\n\n"}
{"name":"Finite.exists_ge","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Finite β\ninst✝² : Nonempty α\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\nf : β → α\n⊢ Exists fun M => ∀ (i : β), LE.le M (f i)","decl":"theorem Finite.exists_ge [IsDirected α (· ≥ ·)] (f : β → α) : ∃ M, ∀ i, M ≤ f i :=\n  directed_id.finite_le (r := (· ≥ ·)) _\n\n"}
{"name":"Set.Finite.exists_le","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\ninst✝² : Nonempty α\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\ns : Set α\nhs : s.Finite\n⊢ Exists fun M => ∀ (i : α), Membership.mem s i → LE.le i M","decl":"theorem Set.Finite.exists_le [IsDirected α (· ≤ ·)] {s : Set α} (hs : s.Finite) :\n    ∃ M, ∀ i ∈ s, i ≤ M :=\n  directed_id.finite_set_le hs\n\n"}
{"name":"Set.Finite.exists_ge","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\ninst✝² : Nonempty α\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\ns : Set α\nhs : s.Finite\n⊢ Exists fun M => ∀ (i : α), Membership.mem s i → LE.le M i","decl":"theorem Set.Finite.exists_ge [IsDirected α (· ≥ ·)] {s : Set α} (hs : s.Finite) :\n    ∃ M, ∀ i ∈ s, M ≤ i :=\n  directed_id.finite_set_le (r := (· ≥ ·)) hs\n\n"}
{"name":"Finite.bddAbove_range","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Finite β\ninst✝² : Nonempty α\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\nf : β → α\n⊢ BddAbove (Set.range f)","decl":"@[simp]\ntheorem Finite.bddAbove_range [IsDirected α (· ≤ ·)] (f : β → α) : BddAbove (Set.range f) := by\n  obtain ⟨M, hM⟩ := Finite.exists_le f\n  refine ⟨M, fun a ha => ?_⟩\n  obtain ⟨b, rfl⟩ := ha\n  exact hM b\n\n"}
{"name":"Finite.bddBelow_range","module":"Mathlib.Data.Fintype.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Finite β\ninst✝² : Nonempty α\ninst✝¹ : Preorder α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\nf : β → α\n⊢ BddBelow (Set.range f)","decl":"@[simp]\ntheorem Finite.bddBelow_range [IsDirected α (· ≥ ·)] (f : β → α) : BddBelow (Set.range f) := by\n  obtain ⟨M, hM⟩ := Finite.exists_ge f\n  refine ⟨M, fun a ha => ?_⟩\n  obtain ⟨b, rfl⟩ := ha\n  exact hM b\n"}
