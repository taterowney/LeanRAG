{"name":"spectrum.exists_mem_of_not_isUnit_aeval_prod","module":"Mathlib.FieldTheory.IsAlgClosed.Spectrum","initialProofState":"R : Type u\nA : Type v\ninstâœÂ³ : CommRing R\ninstâœÂ² : Ring A\ninstâœÂ¹ : Algebra R A\ninstâœ : IsDomain R\np : Polynomial R\na : A\nh : Not (IsUnit ((Polynomial.aeval a) (Multiset.map (fun x => HSub.hSub Polynomial.X (Polynomial.C x)) p.roots).prod))\nâŠ¢ Exists fun k => And (Membership.mem (spectrum R a) k) (Eq (Polynomial.eval k p) 0)","decl":"theorem exists_mem_of_not_isUnit_aeval_prod [IsDomain R] {p : R[X]} {a : A}\n    (h : Â¬IsUnit (aeval a (Multiset.map (fun x : R => X - C x) p.roots).prod)) :\n    âˆƒ k : R, k âˆˆ Ïƒ a âˆ§ eval k p = 0 := by\n  rw [â† Multiset.prod_toList, map_list_prod] at h\n  replace h := mt List.prod_isUnit h\n  simp only [not_forall, exists_prop, aeval_C, Multiset.mem_toList, List.mem_map, aeval_X,\n    exists_exists_and_eq_and, Multiset.mem_map, map_sub] at h\n  rcases h with âŸ¨r, r_mem, r_nuâŸ©\n  exact âŸ¨r, by rwa [mem_iff, â† IsUnit.sub_iff], (mem_roots'.1 r_mem).2âŸ©\n\n"}
{"name":"spectrum.subset_polynomial_aeval","module":"Mathlib.FieldTheory.IsAlgClosed.Spectrum","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\na : A\np : Polynomial ğ•œ\nâŠ¢ HasSubset.Subset (Set.image (fun x => Polynomial.eval x p) (spectrum ğ•œ a)) (spectrum ğ•œ ((Polynomial.aeval a) p))","decl":"/-- Half of the spectral mapping theorem for polynomials. We prove it separately\nbecause it holds over any field, whereas `spectrum.map_polynomial_aeval_of_degree_pos` and\n`spectrum.map_polynomial_aeval_of_nonempty` need the field to be algebraically closed. -/\ntheorem subset_polynomial_aeval (a : A) (p : ğ•œ[X]) : (eval Â· p) '' Ïƒ a âŠ† Ïƒ (aeval a p) := by\n  rintro _ âŸ¨k, hk, rflâŸ©\n  let q := C (eval k p) - p\n  have hroot : IsRoot q k := by simp only [q, eval_C, eval_sub, sub_self, IsRoot.def]\n  rw [â† mul_div_eq_iff_isRoot, â† neg_mul_neg, neg_sub] at hroot\n  have aeval_q_eq : â†‘â‚ (eval k p) - aeval a p = aeval a q := by\n    simp only [q, aeval_C, map_sub, sub_left_inj]\n  rw [mem_iff, aeval_q_eq, â† hroot, aeval_mul]\n  have hcomm := (Commute.all (C k - X) (-(q / (X - C k)))).map (aeval a : ğ•œ[X] â†’â‚[ğ•œ] A)\n  apply mt fun h => (hcomm.isUnit_mul_iff.mp h).1\n  simpa only [aeval_X, aeval_C, map_sub] using hk\n\n"}
{"name":"spectrum.map_polynomial_aeval_of_degree_pos","module":"Mathlib.FieldTheory.IsAlgClosed.Spectrum","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœÂ³ : Field ğ•œ\ninstâœÂ² : Ring A\ninstâœÂ¹ : Algebra ğ•œ A\ninstâœ : IsAlgClosed ğ•œ\na : A\np : Polynomial ğ•œ\nhdeg : LT.lt 0 p.degree\nâŠ¢ Eq (spectrum ğ•œ ((Polynomial.aeval a) p)) (Set.image (fun x => Polynomial.eval x p) (spectrum ğ•œ a))","decl":"/-- The *spectral mapping theorem* for polynomials.  Note: the assumption `degree p > 0`\nis necessary in case `Ïƒ a = âˆ…`, for then the left-hand side is `âˆ…` and the right-hand side,\nassuming `[Nontrivial A]`, is `{k}` where `p = Polynomial.C k`. -/\ntheorem map_polynomial_aeval_of_degree_pos [IsAlgClosed ğ•œ] (a : A) (p : ğ•œ[X])\n    (hdeg : 0 < degree p) : Ïƒ (aeval a p) = (eval Â· p) '' Ïƒ a := by\n  -- handle the easy direction via `spectrum.subset_polynomial_aeval`\n  refine Set.eq_of_subset_of_subset (fun k hk => ?_) (subset_polynomial_aeval a p)\n  -- write `C k - p` product of linear factors and a constant; show `C k - p â‰  0`.\n  have hprod := eq_prod_roots_of_splits_id (IsAlgClosed.splits (C k - p))\n  have h_ne : C k - p â‰  0 := ne_zero_of_degree_gt <| by\n    rwa [degree_sub_eq_right_of_degree_lt (lt_of_le_of_lt degree_C_le hdeg)]\n  have lead_ne := leadingCoeff_ne_zero.mpr h_ne\n  have lead_unit := (Units.map â†‘â‚.toMonoidHom (Units.mk0 _ lead_ne)).isUnit\n  /- leading coefficient is a unit so product of linear factors is not a unit;\n    apply `exists_mem_of_not_is_unit_aeval_prod`. -/\n  have p_a_eq : aeval a (C k - p) = â†‘â‚ k - aeval a p := by\n    simp only [aeval_C, map_sub, sub_left_inj]\n  rw [mem_iff, â† p_a_eq, hprod, aeval_mul,\n    ((Commute.all _ _).map (aeval a : ğ•œ[X] â†’â‚[ğ•œ] A)).isUnit_mul_iff, aeval_C] at hk\n  replace hk := exists_mem_of_not_isUnit_aeval_prod (not_and.mp hk lead_unit)\n  rcases hk with âŸ¨r, r_mem, r_evâŸ©\n  exact âŸ¨r, r_mem, symm (by simpa [eval_sub, eval_C, sub_eq_zero] using r_ev)âŸ©\n\n"}
{"name":"spectrum.map_polynomial_aeval_of_nonempty","module":"Mathlib.FieldTheory.IsAlgClosed.Spectrum","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœÂ³ : Field ğ•œ\ninstâœÂ² : Ring A\ninstâœÂ¹ : Algebra ğ•œ A\ninstâœ : IsAlgClosed ğ•œ\na : A\np : Polynomial ğ•œ\nhnon : (spectrum ğ•œ a).Nonempty\nâŠ¢ Eq (spectrum ğ•œ ((Polynomial.aeval a) p)) (Set.image (fun k => Polynomial.eval k p) (spectrum ğ•œ a))","decl":"/-- In this version of the spectral mapping theorem, we assume the spectrum\nis nonempty instead of assuming the degree of the polynomial is positive. -/\ntheorem map_polynomial_aeval_of_nonempty [IsAlgClosed ğ•œ] (a : A) (p : ğ•œ[X])\n    (hnon : (Ïƒ a).Nonempty) : Ïƒ (aeval a p) = (fun k => eval k p) '' Ïƒ a := by\n  nontriviality A\n  refine Or.elim (le_or_gt (degree p) 0) (fun h => ?_) (map_polynomial_aeval_of_degree_pos a p)\n  rw [eq_C_of_degree_le_zero h]\n  simp only [Set.image_congr, eval_C, aeval_C, scalar_eq, Set.Nonempty.image_const hnon]\n\n"}
{"name":"spectrum.pow_image_subset","module":"Mathlib.FieldTheory.IsAlgClosed.Spectrum","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : Ring A\ninstâœ : Algebra ğ•œ A\na : A\nn : Nat\nâŠ¢ HasSubset.Subset (Set.image (fun x => HPow.hPow x n) (spectrum ğ•œ a)) (spectrum ğ•œ (HPow.hPow a n))","decl":"/-- A specialization of `spectrum.subset_polynomial_aeval` to monic monomials for convenience. -/\ntheorem pow_image_subset (a : A) (n : â„•) : (fun x => x ^ n) '' Ïƒ a âŠ† Ïƒ (a ^ n) := by\n  simpa only [eval_pow, eval_X, aeval_X_pow] using subset_polynomial_aeval a (X ^ n : ğ•œ[X])\n\n"}
{"name":"spectrum.map_pow_of_pos","module":"Mathlib.FieldTheory.IsAlgClosed.Spectrum","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœÂ³ : Field ğ•œ\ninstâœÂ² : Ring A\ninstâœÂ¹ : Algebra ğ•œ A\ninstâœ : IsAlgClosed ğ•œ\na : A\nn : Nat\nhn : LT.lt 0 n\nâŠ¢ Eq (spectrum ğ•œ (HPow.hPow a n)) (Set.image (fun x => HPow.hPow x n) (spectrum ğ•œ a))","decl":"/-- A specialization of `spectrum.map_polynomial_aeval_of_nonempty` to monic monomials for\nconvenience. -/\ntheorem map_pow_of_pos [IsAlgClosed ğ•œ] (a : A) {n : â„•} (hn : 0 < n) :\n    Ïƒ (a ^ n) = (Â· ^ n) '' Ïƒ a := by\n  simpa only [aeval_X_pow, eval_pow, eval_X]\n    using map_polynomial_aeval_of_degree_pos a (X ^ n : ğ•œ[X]) (by rwa [degree_X_pow, Nat.cast_pos])\n\n"}
{"name":"spectrum.map_pow_of_nonempty","module":"Mathlib.FieldTheory.IsAlgClosed.Spectrum","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœÂ³ : Field ğ•œ\ninstâœÂ² : Ring A\ninstâœÂ¹ : Algebra ğ•œ A\ninstâœ : IsAlgClosed ğ•œ\na : A\nha : (spectrum ğ•œ a).Nonempty\nn : Nat\nâŠ¢ Eq (spectrum ğ•œ (HPow.hPow a n)) (Set.image (fun x => HPow.hPow x n) (spectrum ğ•œ a))","decl":"/-- A specialization of `spectrum.map_polynomial_aeval_of_nonempty` to monic monomials for\nconvenience. -/\ntheorem map_pow_of_nonempty [IsAlgClosed ğ•œ] {a : A} (ha : (Ïƒ a).Nonempty) (n : â„•) :\n    Ïƒ (a ^ n) = (Â· ^ n) '' Ïƒ a := by\n  simpa only [aeval_X_pow, eval_pow, eval_X] using map_polynomial_aeval_of_nonempty a (X ^ n) ha\n\n"}
{"name":"spectrum.nonempty_of_isAlgClosed_of_finiteDimensional","module":"Mathlib.FieldTheory.IsAlgClosed.Spectrum","initialProofState":"ğ•œ : Type u\nA : Type v\ninstâœâ´ : Field ğ•œ\ninstâœÂ³ : Ring A\ninstâœÂ² : Algebra ğ•œ A\ninstâœÂ¹ : IsAlgClosed ğ•œ\ninstâœ : Nontrivial A\nI : FiniteDimensional ğ•œ A\na : A\nâŠ¢ (spectrum ğ•œ a).Nonempty","decl":"/-- Every element `a` in a nontrivial finite-dimensional algebra `A`\nover an algebraically closed field `ğ•œ` has non-empty spectrum. -/\ntheorem nonempty_of_isAlgClosed_of_finiteDimensional [IsAlgClosed ğ•œ] [Nontrivial A]\n    [I : FiniteDimensional ğ•œ A] (a : A) : (Ïƒ a).Nonempty := by\n  obtain âŸ¨p, âŸ¨h_mon, h_eval_pâŸ©âŸ© := isIntegral_of_noetherian (IsNoetherian.iff_fg.2 I) a\n  have nu : Â¬IsUnit (aeval a p) := by rw [â† aeval_def] at h_eval_p; rw [h_eval_p]; simp\n  rw [eq_prod_roots_of_monic_of_splits_id h_mon (IsAlgClosed.splits p)] at nu\n  obtain âŸ¨k, hk, _âŸ© := exists_mem_of_not_isUnit_aeval_prod nu\n  exact âŸ¨k, hkâŸ©\n\n"}
