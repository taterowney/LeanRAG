{"name":"PerfectRing.bijective_frobenius","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝¹ : CommSemiring R\ninst✝ : ExpChar R p\nself : PerfectRing R p\n⊢ Function.Bijective ⇑(frobenius R p)","decl":"/-- A perfect ring of characteristic `p` (prime) in the sense of Serre.\n\nNB: This is not related to the concept with the same name introduced by Bass (related to projective\ncovers of modules). -/\nclass PerfectRing (R : Type*) (p : ℕ) [CommSemiring R] [ExpChar R p] : Prop where\n  /-- A ring is perfect if the Frobenius map is bijective. -/\n  bijective_frobenius : Bijective <| frobenius R p\n\n"}
{"name":"PerfectRing.ofSurjective","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_2\np : Nat\ninst✝² : CommRing R\ninst✝¹ : ExpChar R p\ninst✝ : IsReduced R\nh : Function.Surjective ⇑(frobenius R p)\n⊢ PerfectRing R p","decl":"/-- For a reduced ring, surjectivity of the Frobenius map is a sufficient condition for perfection.\n-/\nlemma PerfectRing.ofSurjective (R : Type*) (p : ℕ) [CommRing R] [ExpChar R p]\n    [IsReduced R] (h : Surjective <| frobenius R p) : PerfectRing R p :=\n  ⟨frobenius_inj R p, h⟩\n\n"}
{"name":"PerfectRing.ofFiniteOfIsReduced","module":"Mathlib.FieldTheory.Perfect","initialProofState":"p : Nat\nR : Type u_2\ninst✝³ : CommRing R\ninst✝² : ExpChar R p\ninst✝¹ : Finite R\ninst✝ : IsReduced R\n⊢ PerfectRing R p","decl":"instance PerfectRing.ofFiniteOfIsReduced (R : Type*) [CommRing R] [ExpChar R p]\n    [Finite R] [IsReduced R] : PerfectRing R p :=\n  ofSurjective _ _ <| Finite.surjective_of_injective (frobenius_inj R p)\n\n"}
{"name":"bijective_frobenius","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Function.Bijective ⇑(frobenius R p)","decl":"@[simp]\ntheorem bijective_frobenius : Bijective (frobenius R p) := PerfectRing.bijective_frobenius\n\n"}
{"name":"bijective_iterateFrobenius","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np n : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Function.Bijective ⇑(iterateFrobenius R p n)","decl":"theorem bijective_iterateFrobenius : Bijective (iterateFrobenius R p n) :=\n  coe_iterateFrobenius R p n ▸ (bijective_frobenius R p).iterate n\n\n"}
{"name":"injective_frobenius","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Function.Injective ⇑(frobenius R p)","decl":"@[simp]\ntheorem injective_frobenius : Injective (frobenius R p) := (bijective_frobenius R p).1\n\n"}
{"name":"surjective_frobenius","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Function.Surjective ⇑(frobenius R p)","decl":"@[simp]\ntheorem surjective_frobenius : Surjective (frobenius R p) := (bijective_frobenius R p).2\n\n"}
{"name":"frobeniusEquiv_apply","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\na : R\n⊢ Eq ((frobeniusEquiv R p) a) ((frobenius R p) a)","decl":"/-- The Frobenius automorphism for a perfect ring. -/\n@[simps! apply]\nnoncomputable def frobeniusEquiv : R ≃+* R :=\n  RingEquiv.ofBijective (frobenius R p) PerfectRing.bijective_frobenius\n\n"}
{"name":"coe_frobeniusEquiv","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Eq ⇑(frobeniusEquiv R p) ⇑(frobenius R p)","decl":"@[simp]\ntheorem coe_frobeniusEquiv : ⇑(frobeniusEquiv R p) = frobenius R p := rfl\n\n"}
{"name":"frobeniusEquiv_def","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\nx : R\n⊢ Eq ((frobeniusEquiv R p) x) (HPow.hPow x p)","decl":"theorem frobeniusEquiv_def (x : R) : frobeniusEquiv R p x = x ^ p := rfl\n\n"}
{"name":"iterateFrobeniusEquiv_apply","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np n : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\na : R\n⊢ Eq ((iterateFrobeniusEquiv R p n) a) ((iterateFrobenius R p n) a)","decl":"/-- The iterated Frobenius automorphism for a perfect ring. -/\n@[simps! apply]\nnoncomputable def iterateFrobeniusEquiv : R ≃+* R :=\n  RingEquiv.ofBijective (iterateFrobenius R p n) (bijective_iterateFrobenius R p n)\n\n"}
{"name":"coe_iterateFrobeniusEquiv","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np n : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Eq ⇑(iterateFrobeniusEquiv R p n) ⇑(iterateFrobenius R p n)","decl":"@[simp]\ntheorem coe_iterateFrobeniusEquiv : ⇑(iterateFrobeniusEquiv R p n) = iterateFrobenius R p n := rfl\n\n"}
{"name":"iterateFrobeniusEquiv_def","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np n : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\nx : R\n⊢ Eq ((iterateFrobeniusEquiv R p n) x) (HPow.hPow x (HPow.hPow p n))","decl":"theorem iterateFrobeniusEquiv_def (x : R) : iterateFrobeniusEquiv R p n x = x ^ p ^ n := rfl\n\n"}
{"name":"iterateFrobeniusEquiv_add_apply","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np m n : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\nx : R\n⊢ Eq ((iterateFrobeniusEquiv R p (HAdd.hAdd m n)) x) ((iterateFrobeniusEquiv R p m) ((iterateFrobeniusEquiv R p n) x))","decl":"theorem iterateFrobeniusEquiv_add_apply (x : R) : iterateFrobeniusEquiv R p (m + n) x =\n    iterateFrobeniusEquiv R p m (iterateFrobeniusEquiv R p n x) :=\n  iterateFrobenius_add_apply R p m n x\n\n"}
{"name":"iterateFrobeniusEquiv_add","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np m n : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Eq (iterateFrobeniusEquiv R p (HAdd.hAdd m n)) ((iterateFrobeniusEquiv R p n).trans (iterateFrobeniusEquiv R p m))","decl":"theorem iterateFrobeniusEquiv_add : iterateFrobeniusEquiv R p (m + n) =\n    (iterateFrobeniusEquiv R p n).trans (iterateFrobeniusEquiv R p m) :=\n  RingEquiv.ext (iterateFrobeniusEquiv_add_apply R p m n)\n\n"}
{"name":"iterateFrobeniusEquiv_symm_add_apply","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np m n : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\nx : R\n⊢ Eq ((iterateFrobeniusEquiv R p (HAdd.hAdd m n)).symm x) ((iterateFrobeniusEquiv R p m).symm ((iterateFrobeniusEquiv R p n).symm x))","decl":"theorem iterateFrobeniusEquiv_symm_add_apply (x : R) : (iterateFrobeniusEquiv R p (m + n)).symm x =\n    (iterateFrobeniusEquiv R p m).symm ((iterateFrobeniusEquiv R p n).symm x) :=\n  (iterateFrobeniusEquiv R p (m + n)).injective <| by rw [RingEquiv.apply_symm_apply, add_comm,\n    iterateFrobeniusEquiv_add_apply, RingEquiv.apply_symm_apply, RingEquiv.apply_symm_apply]\n\n"}
{"name":"iterateFrobeniusEquiv_symm_add","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np m n : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Eq (iterateFrobeniusEquiv R p (HAdd.hAdd m n)).symm ((iterateFrobeniusEquiv R p n).symm.trans (iterateFrobeniusEquiv R p m).symm)","decl":"theorem iterateFrobeniusEquiv_symm_add : (iterateFrobeniusEquiv R p (m + n)).symm =\n    (iterateFrobeniusEquiv R p n).symm.trans (iterateFrobeniusEquiv R p m).symm :=\n  RingEquiv.ext (iterateFrobeniusEquiv_symm_add_apply R p m n)\n\n"}
{"name":"iterateFrobeniusEquiv_zero_apply","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\nx : R\n⊢ Eq ((iterateFrobeniusEquiv R p 0) x) x","decl":"theorem iterateFrobeniusEquiv_zero_apply (x : R) : iterateFrobeniusEquiv R p 0 x = x := by\n  rw [iterateFrobeniusEquiv_def, pow_zero, pow_one]\n\n"}
{"name":"iterateFrobeniusEquiv_one_apply","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\nx : R\n⊢ Eq ((iterateFrobeniusEquiv R p 1) x) (HPow.hPow x p)","decl":"theorem iterateFrobeniusEquiv_one_apply (x : R) : iterateFrobeniusEquiv R p 1 x = x ^ p := by\n  rw [iterateFrobeniusEquiv_def, pow_one]\n\n"}
{"name":"iterateFrobeniusEquiv_zero","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Eq (iterateFrobeniusEquiv R p 0) (RingEquiv.refl R)","decl":"@[simp]\ntheorem iterateFrobeniusEquiv_zero  : iterateFrobeniusEquiv R p 0 = RingEquiv.refl R :=\n  RingEquiv.ext (iterateFrobeniusEquiv_zero_apply R p)\n\n"}
{"name":"iterateFrobeniusEquiv_one","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Eq (iterateFrobeniusEquiv R p 1) (frobeniusEquiv R p)","decl":"@[simp]\ntheorem iterateFrobeniusEquiv_one : iterateFrobeniusEquiv R p 1 = frobeniusEquiv R p :=\n  RingEquiv.ext (iterateFrobeniusEquiv_one_apply R p)\n\n"}
{"name":"iterateFrobeniusEquiv_eq_pow","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np n : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Eq (iterateFrobeniusEquiv R p n) (HPow.hPow (frobeniusEquiv R p) n)","decl":"theorem iterateFrobeniusEquiv_eq_pow : iterateFrobeniusEquiv R p n = frobeniusEquiv R p ^ n :=\n  DFunLike.ext' <| show _ = ⇑(RingAut.toPerm _ _) by\n    rw [map_pow, Equiv.Perm.coe_pow]; exact (pow_iterate p n).symm\n\n"}
{"name":"iterateFrobeniusEquiv_symm","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np n : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Eq (iterateFrobeniusEquiv R p n).symm (HPow.hPow (frobeniusEquiv R p).symm n)","decl":"theorem iterateFrobeniusEquiv_symm :\n    (iterateFrobeniusEquiv R p n).symm = (frobeniusEquiv R p).symm ^ n := by\n  rw [iterateFrobeniusEquiv_eq_pow]; exact (inv_pow _ _).symm\n\n"}
{"name":"frobeniusEquiv_symm_apply_frobenius","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\nx : R\n⊢ Eq ((frobeniusEquiv R p).symm ((frobenius R p) x)) x","decl":"@[simp]\ntheorem frobeniusEquiv_symm_apply_frobenius (x : R) :\n    (frobeniusEquiv R p).symm (frobenius R p x) = x :=\n  leftInverse_surjInv PerfectRing.bijective_frobenius x\n\n"}
{"name":"frobenius_apply_frobeniusEquiv_symm","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\nx : R\n⊢ Eq ((frobenius R p) ((frobeniusEquiv R p).symm x)) x","decl":"@[simp]\ntheorem frobenius_apply_frobeniusEquiv_symm (x : R) :\n    frobenius R p ((frobeniusEquiv R p).symm x) = x :=\n  surjInv_eq _ _\n\n"}
{"name":"frobenius_comp_frobeniusEquiv_symm","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Eq ((frobenius R p).comp ↑(frobeniusEquiv R p).symm) (RingHom.id R)","decl":"@[simp]\ntheorem frobenius_comp_frobeniusEquiv_symm :\n    (frobenius R p).comp (frobeniusEquiv R p).symm = RingHom.id R := by\n  ext; simp\n\n"}
{"name":"frobeniusEquiv_symm_comp_frobenius","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\n⊢ Eq ((↑(frobeniusEquiv R p).symm).comp (frobenius R p)) (RingHom.id R)","decl":"@[simp]\ntheorem frobeniusEquiv_symm_comp_frobenius :\n    ((frobeniusEquiv R p).symm : R →+* R).comp (frobenius R p) = RingHom.id R := by\n  ext; simp\n\n"}
{"name":"frobeniusEquiv_symm_pow_p","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\nx : R\n⊢ Eq (HPow.hPow ((frobeniusEquiv R p).symm x) p) x","decl":"@[simp]\ntheorem frobeniusEquiv_symm_pow_p (x : R) : ((frobeniusEquiv R p).symm x) ^ p = x :=\n  frobenius_apply_frobeniusEquiv_symm R p x\n\n"}
{"name":"injective_pow_p","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\nx y : R\nh : Eq (HPow.hPow x p) (HPow.hPow y p)\n⊢ Eq x y","decl":"theorem injective_pow_p {x y : R} (h : x ^ p = y ^ p) : x = y := (frobeniusEquiv R p).injective h\n\n"}
{"name":"polynomial_expand_eq","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝² : CommSemiring R\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\nf : Polynomial R\n⊢ Eq ((Polynomial.expand R p) f) (HPow.hPow (Polynomial.map (↑(frobeniusEquiv R p).symm) f) p)","decl":"lemma polynomial_expand_eq (f : R[X]) :\n    expand R p f = (f.map (frobeniusEquiv R p).symm) ^ p := by\n  rw [← (f.map (S := R) (frobeniusEquiv R p).symm).expand_char p, map_expand, map_map,\n    frobenius_comp_frobeniusEquiv_symm, map_id]\n\n"}
{"name":"not_irreducible_expand","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_2\np : Nat\ninst✝³ : CommSemiring R\ninst✝² : Fact (Nat.Prime p)\ninst✝¹ : CharP R p\ninst✝ : PerfectRing R p\nf : Polynomial R\n⊢ Not (Irreducible ((Polynomial.expand R p) f))","decl":"@[simp]\ntheorem not_irreducible_expand (R p) [CommSemiring R] [Fact p.Prime] [CharP R p] [PerfectRing R p]\n    (f : R[X]) : ¬ Irreducible (expand R p f) := by\n  rw [polynomial_expand_eq]\n  exact not_irreducible_pow (Fact.out : p.Prime).ne_one\n\n"}
{"name":"instPerfectRingProd","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\np : Nat\ninst✝⁵ : CommSemiring R\ninst✝⁴ : ExpChar R p\ninst✝³ : PerfectRing R p\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : ExpChar S p\ninst✝ : PerfectRing S p\n⊢ PerfectRing (Prod R S) p","decl":"instance instPerfectRingProd (S : Type*) [CommSemiring S] [ExpChar S p] [PerfectRing S p] :\n    PerfectRing (R × S) p where\n  bijective_frobenius := (bijective_frobenius R p).prodMap (bijective_frobenius S p)\n\n"}
{"name":"PerfectField.separable_of_irreducible","module":"Mathlib.FieldTheory.Perfect","initialProofState":"K : Type u_1\ninst✝ : Field K\nself : PerfectField K\nf : Polynomial K\na✝ : Irreducible f\n⊢ f.Separable","decl":"/-- A perfect field.\n\nSee also `PerfectRing` for a generalisation in positive characteristic. -/\nclass PerfectField (K : Type*) [Field K] : Prop where\n  /-- A field is perfect if every irreducible polynomial is separable. -/\n  separable_of_irreducible : ∀ {f : K[X]}, Irreducible f → f.Separable\n\n"}
{"name":"PerfectRing.toPerfectField","module":"Mathlib.FieldTheory.Perfect","initialProofState":"K : Type u_1\np : Nat\ninst✝² : Field K\ninst✝¹ : ExpChar K p\ninst✝ : PerfectRing K p\n⊢ PerfectField K","decl":"lemma PerfectRing.toPerfectField (K : Type*) (p : ℕ)\n    [Field K] [ExpChar K p] [PerfectRing K p] : PerfectField K := by\n  obtain hp | ⟨hp⟩ := ‹ExpChar K p›\n  · exact ⟨Irreducible.separable⟩\n  refine PerfectField.mk fun hf ↦ ?_\n  rcases separable_or p hf with h | ⟨-, g, -, rfl⟩\n  · assumption\n  · exfalso; revert hf; haveI := Fact.mk hp; simp\n\n"}
{"name":"PerfectField.ofCharZero","module":"Mathlib.FieldTheory.Perfect","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : CharZero K\n⊢ PerfectField K","decl":"instance ofCharZero [CharZero K] : PerfectField K := ⟨Irreducible.separable⟩\n\n"}
{"name":"PerfectField.ofFinite","module":"Mathlib.FieldTheory.Perfect","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : Finite K\n⊢ PerfectField K","decl":"instance ofFinite [Finite K] : PerfectField K := by\n  obtain ⟨p, _instP⟩ := CharP.exists K\n  have : Fact p.Prime := ⟨CharP.char_is_prime K p⟩\n  exact PerfectRing.toPerfectField K p\n\n"}
{"name":"PerfectField.toPerfectRing","module":"Mathlib.FieldTheory.Perfect","initialProofState":"K : Type u_1\ninst✝ : Field K\np : Nat\nhp : ExpChar K p\n⊢ PerfectRing K p","decl":"/-- A perfect field of characteristic `p` (prime) is a perfect ring. -/\ninstance toPerfectRing (p : ℕ) [hp : ExpChar K p] : PerfectRing K p := by\n  refine PerfectRing.ofSurjective _ _ fun y ↦ ?_\n  rcases hp with _ | hp\n  · simp [frobenius]\n  rw [← not_forall_not]\n  apply mt (X_pow_sub_C_irreducible_of_prime hp)\n  apply mt separable_of_irreducible\n  simp [separable_def, isCoprime_zero_right, isUnit_iff_degree_eq_zero,\n    degree_X_pow_sub_C hp.pos, hp.ne_zero]\n\n"}
{"name":"PerfectField.separable_iff_squarefree","module":"Mathlib.FieldTheory.Perfect","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : PerfectField K\ng : Polynomial K\n⊢ Iff g.Separable (Squarefree g)","decl":"theorem separable_iff_squarefree {g : K[X]} : g.Separable ↔ Squarefree g := by\n  refine ⟨Separable.squarefree, fun sqf ↦ isCoprime_of_irreducible_dvd (sqf.ne_zero ·.1) ?_⟩\n  rintro p (h : Irreducible p) ⟨q, rfl⟩ (dvd : p ∣ derivative (p * q))\n  replace dvd : p ∣ q := by\n    rw [derivative_mul, dvd_add_left (dvd_mul_right p _)] at dvd\n    exact (separable_of_irreducible h).dvd_of_dvd_mul_left dvd\n  exact (h.1 : ¬ IsUnit p) (sqf _ <| mul_dvd_mul_left _ dvd)\n\n"}
{"name":"Algebra.IsAlgebraic.isSeparable_of_perfectField","module":"Mathlib.FieldTheory.Perfect","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : Algebra.IsAlgebraic K L\ninst✝ : PerfectField K\n⊢ Algebra.IsSeparable K L","decl":"/-- If `L / K` is an algebraic extension, `K` is a perfect field, then `L / K` is separable. -/\ninstance Algebra.IsAlgebraic.isSeparable_of_perfectField {K L : Type*} [Field K] [Field L]\n    [Algebra K L] [Algebra.IsAlgebraic K L] [PerfectField K] : Algebra.IsSeparable K L :=\n  ⟨fun x ↦ PerfectField.separable_of_irreducible <|\n    minpoly.irreducible (Algebra.IsIntegral.isIntegral x)⟩\n\n"}
{"name":"Algebra.IsAlgebraic.perfectField","module":"Mathlib.FieldTheory.Perfect","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : Algebra.IsAlgebraic K L\ninst✝ : PerfectField K\n⊢ PerfectField L","decl":"/-- If `L / K` is an algebraic extension, `K` is a perfect field, then so is `L`. -/\ntheorem Algebra.IsAlgebraic.perfectField {K L : Type*} [Field K] [Field L] [Algebra K L]\n    [Algebra.IsAlgebraic K L] [PerfectField K] : PerfectField L := ⟨fun {f} hf ↦ by\n  obtain ⟨_, _, hi, h⟩ := hf.exists_dvd_monic_irreducible_of_isIntegral (K := K)\n  exact (PerfectField.separable_of_irreducible hi).map |>.of_dvd h⟩\n\n"}
{"name":"Polynomial.roots_expand_pow_map_iterateFrobenius_le","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\np n : Nat\ninst✝ : ExpChar R p\nf : Polynomial R\n⊢ LE.le (Multiset.map (⇑(iterateFrobenius R p n)) ((Polynomial.expand R (HPow.hPow p n)) f).roots) (HSMul.hSMul (HPow.hPow p n) f.roots)","decl":"theorem roots_expand_pow_map_iterateFrobenius_le :\n    (expand R (p ^ n) f).roots.map (iterateFrobenius R p n) ≤ p ^ n • f.roots := by\n  classical\n  refine le_iff_count.2 fun r ↦ ?_\n  by_cases h : ∃ s, r = s ^ p ^ n\n  · obtain ⟨s, rfl⟩ := h\n    simp_rw [count_nsmul, count_roots, ← rootMultiplicity_expand_pow, ← count_roots, count_map,\n      count_eq_card_filter_eq]\n    exact card_le_card (monotone_filter_right _ fun _ h ↦ iterateFrobenius_inj R p n h)\n  convert Nat.zero_le _\n  simp_rw [count_map, card_eq_zero]\n  exact ext' fun t ↦ count_zero t ▸ count_filter_of_neg fun h' ↦ h ⟨t, h'⟩\n\n"}
{"name":"Polynomial.roots_expand_map_frobenius_le","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\np : Nat\ninst✝ : ExpChar R p\nf : Polynomial R\n⊢ LE.le (Multiset.map (⇑(frobenius R p)) ((Polynomial.expand R p) f).roots) (HSMul.hSMul p f.roots)","decl":"theorem roots_expand_map_frobenius_le :\n    (expand R p f).roots.map (frobenius R p) ≤ p • f.roots := by\n  rw [← iterateFrobenius_one]\n  convert ← roots_expand_pow_map_iterateFrobenius_le p 1 f <;> apply pow_one\n\n"}
{"name":"Polynomial.roots_expand_pow_image_iterateFrobenius_subset","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\np n : Nat\ninst✝¹ : ExpChar R p\nf : Polynomial R\ninst✝ : DecidableEq R\n⊢ HasSubset.Subset (Finset.image (⇑(iterateFrobenius R p n)) ((Polynomial.expand R (HPow.hPow p n)) f).roots.toFinset) f.roots.toFinset","decl":"theorem roots_expand_pow_image_iterateFrobenius_subset [DecidableEq R] :\n    (expand R (p ^ n) f).roots.toFinset.image (iterateFrobenius R p n) ⊆ f.roots.toFinset := by\n  rw [Finset.image_toFinset, ← (roots f).toFinset_nsmul _ (expChar_pow_pos R p n).ne',\n    toFinset_subset]\n  exact subset_of_le (roots_expand_pow_map_iterateFrobenius_le p n f)\n\n"}
{"name":"Polynomial.roots_expand_image_frobenius_subset","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\np : Nat\ninst✝¹ : ExpChar R p\nf : Polynomial R\ninst✝ : DecidableEq R\n⊢ HasSubset.Subset (Finset.image (⇑(frobenius R p)) ((Polynomial.expand R p) f).roots.toFinset) f.roots.toFinset","decl":"theorem roots_expand_image_frobenius_subset [DecidableEq R] :\n    (expand R p f).roots.toFinset.image (frobenius R p) ⊆ f.roots.toFinset := by\n  rw [← iterateFrobenius_one]\n  convert ← roots_expand_pow_image_iterateFrobenius_subset p 1 f\n  apply pow_one\n\n"}
{"name":"Polynomial.roots_expand_pow","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\np n : Nat\ninst✝¹ : ExpChar R p\nf : Polynomial R\ninst✝ : PerfectRing R p\n⊢ Eq ((Polynomial.expand R (HPow.hPow p n)) f).roots (HSMul.hSMul (HPow.hPow p n) (Multiset.map (⇑(iterateFrobeniusEquiv R p n).symm) f.roots))","decl":"theorem roots_expand_pow :\n    (expand R (p ^ n) f).roots = p ^ n • f.roots.map (iterateFrobeniusEquiv R p n).symm := by\n  classical\n  refine ext' fun r ↦ ?_\n  rw [count_roots, rootMultiplicity_expand_pow, ← count_roots, count_nsmul, count_map,\n    count_eq_card_filter_eq]; congr; ext\n  exact (iterateFrobeniusEquiv R p n).eq_symm_apply.symm\n\n"}
{"name":"Polynomial.roots_expand","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\np : Nat\ninst✝¹ : ExpChar R p\nf : Polynomial R\ninst✝ : PerfectRing R p\n⊢ Eq ((Polynomial.expand R p) f).roots (HSMul.hSMul p (Multiset.map (⇑(frobeniusEquiv R p).symm) f.roots))","decl":"theorem roots_expand : (expand R p f).roots = p • f.roots.map (frobeniusEquiv R p).symm := by\n  conv_lhs => rw [← pow_one p, roots_expand_pow, iterateFrobeniusEquiv_eq_pow, pow_one]\n  rfl\n\n"}
{"name":"Polynomial.roots_X_pow_char_pow_sub_C","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\np n : Nat\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\ny : R\n⊢ Eq (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow p n)) (Polynomial.C y)).roots (HSMul.hSMul (HPow.hPow p n) (Singleton.singleton ((iterateFrobeniusEquiv R p n).symm y)))","decl":"theorem roots_X_pow_char_pow_sub_C {y : R} :\n    (X ^ p ^ n - C y).roots = p ^ n • {(iterateFrobeniusEquiv R p n).symm y} := by\n  have H := roots_expand_pow (p := p) (n := n) (f := X - C y)\n  rwa [roots_X_sub_C, Multiset.map_singleton, map_sub, expand_X, expand_C] at H\n\n"}
{"name":"Polynomial.roots_X_pow_char_pow_sub_C_pow","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\np n : Nat\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\ny : R\nm : Nat\n⊢ Eq (HPow.hPow (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow p n)) (Polynomial.C y)) m).roots (HSMul.hSMul (HMul.hMul m (HPow.hPow p n)) (Singleton.singleton ((iterateFrobeniusEquiv R p n).symm y)))","decl":"theorem roots_X_pow_char_pow_sub_C_pow {y : R} {m : ℕ} :\n    ((X ^ p ^ n - C y) ^ m).roots = (m * p ^ n) • {(iterateFrobeniusEquiv R p n).symm y} := by\n  rw [roots_pow, roots_X_pow_char_pow_sub_C, mul_smul]\n\n"}
{"name":"Polynomial.roots_X_pow_char_sub_C","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\np : Nat\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\ny : R\n⊢ Eq (HSub.hSub (HPow.hPow Polynomial.X p) (Polynomial.C y)).roots (HSMul.hSMul p (Singleton.singleton ((frobeniusEquiv R p).symm y)))","decl":"theorem roots_X_pow_char_sub_C {y : R} :\n    (X ^ p - C y).roots = p • {(frobeniusEquiv R p).symm y} := by\n  have H := roots_X_pow_char_pow_sub_C (p := p) (n := 1) (y := y)\n  rwa [pow_one, iterateFrobeniusEquiv_one] at H\n\n"}
{"name":"Polynomial.roots_X_pow_char_sub_C_pow","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\np : Nat\ninst✝¹ : ExpChar R p\ninst✝ : PerfectRing R p\ny : R\nm : Nat\n⊢ Eq (HPow.hPow (HSub.hSub (HPow.hPow Polynomial.X p) (Polynomial.C y)) m).roots (HSMul.hSMul (HMul.hMul m p) (Singleton.singleton ((frobeniusEquiv R p).symm y)))","decl":"theorem roots_X_pow_char_sub_C_pow {y : R} {m : ℕ} :\n    ((X ^ p - C y) ^ m).roots = (m * p) • {(frobeniusEquiv R p).symm y} := by\n  have H := roots_X_pow_char_pow_sub_C_pow (p := p) (n := 1) (y := y) (m := m)\n  rwa [pow_one, iterateFrobeniusEquiv_one] at H\n\n"}
{"name":"Polynomial.roots_expand_pow_map_iterateFrobenius","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\np n : Nat\ninst✝¹ : ExpChar R p\nf : Polynomial R\ninst✝ : PerfectRing R p\n⊢ Eq (Multiset.map (⇑(iterateFrobenius R p n)) ((Polynomial.expand R (HPow.hPow p n)) f).roots) (HSMul.hSMul (HPow.hPow p n) f.roots)","decl":"theorem roots_expand_pow_map_iterateFrobenius :\n    (expand R (p ^ n) f).roots.map (iterateFrobenius R p n) = p ^ n • f.roots := by\n  simp_rw [← coe_iterateFrobeniusEquiv, roots_expand_pow, Multiset.map_nsmul,\n    Multiset.map_map, comp_apply, RingEquiv.apply_symm_apply, map_id']\n\n"}
{"name":"Polynomial.roots_expand_map_frobenius","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\np : Nat\ninst✝¹ : ExpChar R p\nf : Polynomial R\ninst✝ : PerfectRing R p\n⊢ Eq (Multiset.map (⇑(frobenius R p)) ((Polynomial.expand R p) f).roots) (HSMul.hSMul p f.roots)","decl":"theorem roots_expand_map_frobenius : (expand R p f).roots.map (frobenius R p) = p • f.roots := by\n  simp [roots_expand, Multiset.map_nsmul]\n\n"}
{"name":"Polynomial.roots_expand_image_iterateFrobenius","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\np n : Nat\ninst✝² : ExpChar R p\nf : Polynomial R\ninst✝¹ : PerfectRing R p\ninst✝ : DecidableEq R\n⊢ Eq (Finset.image (⇑(iterateFrobenius R p n)) ((Polynomial.expand R (HPow.hPow p n)) f).roots.toFinset) f.roots.toFinset","decl":"theorem roots_expand_image_iterateFrobenius [DecidableEq R] :\n    (expand R (p ^ n) f).roots.toFinset.image (iterateFrobenius R p n) = f.roots.toFinset := by\n  rw [Finset.image_toFinset, roots_expand_pow_map_iterateFrobenius,\n    (roots f).toFinset_nsmul _ (expChar_pow_pos R p n).ne']\n\n"}
{"name":"Polynomial.roots_expand_image_frobenius","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\np : Nat\ninst✝² : ExpChar R p\nf : Polynomial R\ninst✝¹ : PerfectRing R p\ninst✝ : DecidableEq R\n⊢ Eq (Finset.image (⇑(frobenius R p)) ((Polynomial.expand R p) f).roots.toFinset) f.roots.toFinset","decl":"theorem roots_expand_image_frobenius [DecidableEq R] :\n    (expand R p f).roots.toFinset.image (frobenius R p) = f.roots.toFinset := by\n  rw [Finset.image_toFinset, roots_expand_map_frobenius,\n      (roots f).toFinset_nsmul _ (expChar_pos R p).ne']\n\n"}
{"name":"Polynomial.rootsExpandToRoots_apply","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\np : Nat\ninst✝¹ : ExpChar R p\nf : Polynomial R\ninst✝ : DecidableEq R\nx : Subtype fun x => Membership.mem ((Polynomial.expand R p) f).roots.toFinset x\n⊢ Eq (↑((Polynomial.rootsExpandToRoots p f) x)) (HPow.hPow (↑x) p)","decl":"@[simp]\ntheorem rootsExpandToRoots_apply (x) : (rootsExpandToRoots p f x : R) = x ^ p := rfl\n\n"}
{"name":"Polynomial.rootsExpandPowToRoots_apply","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsDomain R\np n : Nat\ninst✝¹ : ExpChar R p\nf : Polynomial R\ninst✝ : DecidableEq R\nx : Subtype fun x => Membership.mem ((Polynomial.expand R (HPow.hPow p n)) f).roots.toFinset x\n⊢ Eq (↑((Polynomial.rootsExpandPowToRoots p n f) x)) (HPow.hPow (↑x) (HPow.hPow p n))","decl":"@[simp]\ntheorem rootsExpandPowToRoots_apply (x) : (rootsExpandPowToRoots p n f x : R) = x ^ p ^ n := rfl\n\n"}
{"name":"Polynomial.rootsExpandEquivRoots_apply","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\np : Nat\ninst✝² : ExpChar R p\nf : Polynomial R\ninst✝¹ : DecidableEq R\ninst✝ : PerfectRing R p\nx : Subtype fun x => Membership.mem ((Polynomial.expand R p) f).roots.toFinset x\n⊢ Eq (↑((Polynomial.rootsExpandEquivRoots p f) x)) (HPow.hPow (↑x) p)","decl":"@[simp]\ntheorem rootsExpandEquivRoots_apply (x) : (rootsExpandEquivRoots p f x : R) = x ^ p := rfl\n\n"}
{"name":"Polynomial.rootsExpandPowEquivRoots_apply","module":"Mathlib.FieldTheory.Perfect","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\np : Nat\ninst✝² : ExpChar R p\nf : Polynomial R\ninst✝¹ : DecidableEq R\ninst✝ : PerfectRing R p\nn : Nat\nx : Subtype fun x => Membership.mem ((Polynomial.expand R (HPow.hPow p n)) f).roots.toFinset x\n⊢ Eq (↑((Polynomial.rootsExpandPowEquivRoots p f n) x)) (HPow.hPow (↑x) (HPow.hPow p n))","decl":"@[simp]\ntheorem rootsExpandPowEquivRoots_apply (n : ℕ) (x) :\n    (rootsExpandPowEquivRoots p f n x : R) = x ^ p ^ n := rfl\n\n"}
