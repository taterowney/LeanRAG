{"name":"dirSupInaccOn_univ","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (DirSupInaccOn Set.univ s) (DirSupInacc s)","decl":"@[simp] lemma dirSupInaccOn_univ : DirSupInaccOn univ s ↔ DirSupInacc s := by\n  simp [DirSupInaccOn, DirSupInacc]\n\n"}
{"name":"DirSupInacc.dirSupInaccOn","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nD : Set (Set α)\na✝ : DirSupInacc s\n⊢ DirSupInaccOn D s","decl":"@[simp] lemma DirSupInacc.dirSupInaccOn {D : Set (Set α)} :\n    DirSupInacc s → DirSupInaccOn D s := fun h _ _ d₂ d₃ _ hda => h d₂ d₃ hda\n\n"}
{"name":"DirSupInaccOn.mono","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nD₁ D₂ : Set (Set α)\nhD : HasSubset.Subset D₁ D₂\nhf : DirSupInaccOn D₂ s\n⊢ DirSupInaccOn D₁ s","decl":"lemma DirSupInaccOn.mono {D₁ D₂ : Set (Set α)} (hD : D₁ ⊆ D₂) (hf : DirSupInaccOn D₂ s) :\n    DirSupInaccOn D₁ s := fun ⦃_⦄ a ↦ hf (hD a)\n\n"}
{"name":"dirSupInacc_compl","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (DirSupInacc (HasCompl.compl s)) (DirSupClosed s)","decl":"@[simp] lemma dirSupInacc_compl : DirSupInacc sᶜ ↔ DirSupClosed s := by\n  simp [DirSupInacc, DirSupClosed, ← not_disjoint_iff_nonempty_inter, not_imp_not,\n    disjoint_compl_right_iff]\n\n"}
{"name":"dirSupClosed_compl","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (DirSupClosed (HasCompl.compl s)) (DirSupInacc s)","decl":"@[simp] lemma dirSupClosed_compl : DirSupClosed sᶜ ↔ DirSupInacc s := by\n  rw [← dirSupInacc_compl, compl_compl]\n\n"}
{"name":"DirSupClosed.compl","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\na✝ : DirSupClosed s\n⊢ DirSupInacc (HasCompl.compl s)","decl":"alias ⟨DirSupInacc.of_compl, DirSupClosed.compl⟩ := dirSupInacc_compl\n"}
{"name":"DirSupInacc.of_compl","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\na✝ : DirSupInacc (HasCompl.compl s)\n⊢ DirSupClosed s","decl":"alias ⟨DirSupInacc.of_compl, DirSupClosed.compl⟩ := dirSupInacc_compl\n"}
{"name":"DirSupClosed.of_compl","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\na✝ : DirSupClosed (HasCompl.compl s)\n⊢ DirSupInacc s","decl":"alias ⟨DirSupClosed.of_compl, DirSupInacc.compl⟩ := dirSupClosed_compl\n\n"}
{"name":"DirSupInacc.compl","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\na✝ : DirSupInacc s\n⊢ DirSupClosed (HasCompl.compl s)","decl":"alias ⟨DirSupClosed.of_compl, DirSupInacc.compl⟩ := dirSupClosed_compl\n\n"}
{"name":"DirSupClosed.inter","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\nhs : DirSupClosed s\nht : DirSupClosed t\n⊢ DirSupClosed (Inter.inter s t)","decl":"lemma DirSupClosed.inter (hs : DirSupClosed s) (ht : DirSupClosed t) : DirSupClosed (s ∩ t) :=\n  fun _d hd hd' _a ha hds ↦ ⟨hs hd hd' ha <| hds.trans inter_subset_left,\n    ht hd hd' ha <| hds.trans inter_subset_right⟩\n\n"}
{"name":"DirSupInacc.union","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\nhs : DirSupInacc s\nht : DirSupInacc t\n⊢ DirSupInacc (Union.union s t)","decl":"lemma DirSupInacc.union (hs : DirSupInacc s) (ht : DirSupInacc t) : DirSupInacc (s ∪ t) := by\n  rw [← dirSupClosed_compl, compl_union]; exact hs.compl.inter ht.compl\n\n"}
{"name":"IsUpperSet.dirSupClosed","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nhs : IsUpperSet s\n⊢ DirSupClosed s","decl":"lemma IsUpperSet.dirSupClosed (hs : IsUpperSet s) : DirSupClosed s :=\n  fun _d ⟨_b, hb⟩ _ _a ha hds ↦ hs (ha.1 hb) <| hds hb\n\n"}
{"name":"IsLowerSet.dirSupInacc","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nhs : IsLowerSet s\n⊢ DirSupInacc s","decl":"lemma IsLowerSet.dirSupInacc (hs : IsLowerSet s) : DirSupInacc s := hs.compl.dirSupClosed.of_compl\n\n"}
{"name":"dirSupClosed_Iic","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ DirSupClosed (Set.Iic a)","decl":"lemma dirSupClosed_Iic (a : α) : DirSupClosed (Iic a) := fun _d _ _ _a ha ↦ (isLUB_le_iff ha).2\n\n"}
{"name":"dirSupInacc_iff_forall_sSup","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Iff (DirSupInacc s) (∀ ⦃d : Set α⦄, d.Nonempty → DirectedOn (fun x1 x2 => LE.le x1 x2) d → Membership.mem s (SupSet.sSup d) → (Inter.inter d s).Nonempty)","decl":"lemma dirSupInacc_iff_forall_sSup :\n    DirSupInacc s ↔ ∀ ⦃d⦄, d.Nonempty → DirectedOn (· ≤ ·) d → sSup d ∈ s → (d ∩ s).Nonempty := by\n  simp [DirSupInacc, isLUB_iff_sSup_eq]\n\n"}
{"name":"dirSupClosed_iff_forall_sSup","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Iff (DirSupClosed s) (∀ ⦃d : Set α⦄, d.Nonempty → DirectedOn (fun x1 x2 => LE.le x1 x2) d → HasSubset.Subset d s → Membership.mem s (SupSet.sSup d))","decl":"lemma dirSupClosed_iff_forall_sSup :\n    DirSupClosed s ↔ ∀ ⦃d⦄, d.Nonempty → DirectedOn (· ≤ ·) d → d ⊆ s → sSup d ∈ s := by\n  simp [DirSupClosed, isLUB_iff_sSup_eq]\n\n"}
{"name":"Topology.IsScottHausdorff.topology_eq_scottHausdorff","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\nD : Set (Set α)\ninst✝¹ : Preorder α\ninst✝ : TopologicalSpace α\nself : Topology.IsScottHausdorff α D\n⊢ Eq inst✝ (Topology.scottHausdorff α D)","decl":"/-- Predicate for an ordered topological space to be equipped with its Scott-Hausdorff topology.\n\nA set `u` is open in the Scott-Hausdorff topology iff when the least upper bound of a directed set\n`d` lies in `u` then there is a tail of `d` which is a subset of `u`. -/\nclass IsScottHausdorff : Prop where\n  topology_eq_scottHausdorff : ‹TopologicalSpace α› = scottHausdorff α D\n\n"}
{"name":"Topology.instIsScottHausdorff","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\nD : Set (Set α)\ninst✝ : Preorder α\n⊢ Topology.IsScottHausdorff α D","decl":"instance : @IsScottHausdorff α D _ (scottHausdorff α D) :=\n  @IsScottHausdorff.mk _ _ _ (scottHausdorff α D) rfl\n\n"}
{"name":"Topology.IsScottHausdorff.topology_eq","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\nD : Set (Set α)\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsScottHausdorff α D\n⊢ Eq inst✝¹ (Topology.scottHausdorff α D)","decl":"lemma topology_eq [IsScottHausdorff α D] : ‹_› = scottHausdorff α D := topology_eq_scottHausdorff\n\n"}
{"name":"Topology.IsScottHausdorff.isOpen_iff","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\nD : Set (Set α)\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ns : Set α\ninst✝ : Topology.IsScottHausdorff α D\n⊢ Iff (IsOpen s) (∀ ⦃d : Set α⦄, Membership.mem D d → d.Nonempty → DirectedOn (fun x1 x2 => LE.le x1 x2) d → ∀ ⦃a : α⦄, IsLUB d a → Membership.mem s a → Exists fun b => And (Membership.mem d b) (HasSubset.Subset (Inter.inter (Set.Ici b) d) s))","decl":"lemma isOpen_iff [IsScottHausdorff α D] :\n    IsOpen s ↔ ∀ ⦃d : Set α⦄, d ∈ D → d.Nonempty → DirectedOn (· ≤ ·) d → ∀ ⦃a : α⦄, IsLUB d a →\n      a ∈ s → ∃ b ∈ d, Ici b ∩ d ⊆ s := by\n  simp [topology_eq_scottHausdorff (α := α) (D := D), IsOpen, scottHausdorff]\n\n"}
{"name":"Topology.IsScottHausdorff.dirSupInaccOn_of_isOpen","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\nD : Set (Set α)\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ns : Set α\ninst✝ : Topology.IsScottHausdorff α D\nh : IsOpen s\n⊢ DirSupInaccOn D s","decl":"lemma dirSupInaccOn_of_isOpen [IsScottHausdorff α D] (h : IsOpen s) : DirSupInaccOn D s :=\n  fun d hd₀ hd₁ hd₂ a hda hd₃ ↦ by\n    obtain ⟨b, hbd, hb⟩ := isOpen_iff.mp h hd₀ hd₁ hd₂ hda hd₃; exact ⟨b, hbd, hb ⟨le_rfl, hbd⟩⟩\n\n"}
{"name":"Topology.IsScottHausdorff.dirSupClosed_of_isClosed","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ns : Set α\ninst✝ : Topology.IsScottHausdorff α Set.univ\nh : IsClosed s\n⊢ DirSupClosed s","decl":"lemma dirSupClosed_of_isClosed [IsScottHausdorff α univ] (h : IsClosed s) : DirSupClosed s := by\n  apply DirSupInacc.of_compl\n  rw [← dirSupInaccOn_univ]\n  exact (dirSupInaccOn_of_isOpen h.isOpen_compl)\n\n"}
{"name":"Topology.IsScottHausdorff.isOpen_of_isLowerSet","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : Preorder α\nt : TopologicalSpace α\ninst✝ : Topology.IsScottHausdorff α Set.univ\nh : IsLowerSet s\n⊢ IsOpen s","decl":"lemma isOpen_of_isLowerSet (h : IsLowerSet s) : IsOpen s :=\n  (isOpen_iff (D := univ)).2 fun _d _ ⟨b, hb⟩ _ _ hda ha ↦\n    ⟨b, hb, fun _ hc ↦ h (mem_upperBounds.1 hda.1 _ hc.2) ha⟩\n\n"}
{"name":"Topology.IsScottHausdorff.isClosed_of_isUpperSet","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : Preorder α\nt : TopologicalSpace α\ninst✝ : Topology.IsScottHausdorff α Set.univ\nh : IsUpperSet s\n⊢ IsClosed s","decl":"lemma isClosed_of_isUpperSet (h : IsUpperSet s) : IsClosed s :=\n  isOpen_compl_iff.1 <| isOpen_of_isLowerSet h.compl\n\n"}
{"name":"Topology.upperSet_le_scott","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ LE.le (Topology.upperSet α) (Topology.scott α Set.univ)","decl":"lemma upperSet_le_scott [Preorder α] : upperSet α ≤ scott α univ := le_sup_left\n\n"}
{"name":"Topology.scottHausdorff_le_scott","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ LE.le (Topology.scottHausdorff α Set.univ) (Topology.scott α Set.univ)","decl":"lemma scottHausdorff_le_scott [Preorder α] : scottHausdorff α univ ≤ scott α univ:= le_sup_right\n\n"}
{"name":"Topology.IsScott.topology_eq_scott","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\nD : Set (Set α)\ninst✝¹ : Preorder α\ninst✝ : TopologicalSpace α\nself : Topology.IsScott α D\n⊢ Eq inst✝ (Topology.scott α D)","decl":"/-- Predicate for an ordered topological space to be equipped with its Scott topology.\n\nThe Scott topology is defined as the join of the topology of upper sets and the Scott Hausdorff\ntopology. -/\nclass IsScott : Prop where\n  topology_eq_scott : ‹TopologicalSpace α› = scott α D\n\n"}
{"name":"Topology.IsScott.topology_eq","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\nD : Set (Set α)\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsScott α D\n⊢ Eq inst✝¹ (Topology.scott α D)","decl":"lemma topology_eq [IsScott α D] : ‹_› = scott α D := topology_eq_scott\n\n"}
{"name":"Topology.IsScott.isOpen_iff_isUpperSet_and_scottHausdorff_open","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\nD : Set (Set α)\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ns : Set α\ninst✝ : Topology.IsScott α D\n⊢ Iff (IsOpen s) (And (IsUpperSet s) (IsOpen s))","decl":"lemma isOpen_iff_isUpperSet_and_scottHausdorff_open [IsScott α D] :\n    IsOpen s ↔ IsUpperSet s ∧ IsOpen[scottHausdorff α D] s := by rw [topology_eq α D]; rfl\n\n"}
{"name":"Topology.IsScott.isOpen_iff_isUpperSet_and_dirSupInaccOn","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\nD : Set (Set α)\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ns : Set α\ninst✝ : Topology.IsScott α D\n⊢ Iff (IsOpen s) (And (IsUpperSet s) (DirSupInaccOn D s))","decl":"lemma isOpen_iff_isUpperSet_and_dirSupInaccOn [IsScott α D] :\n    IsOpen s ↔ IsUpperSet s ∧ DirSupInaccOn D s := by\n  rw [isOpen_iff_isUpperSet_and_scottHausdorff_open (D := D)]\n  refine and_congr_right fun h ↦\n    ⟨@IsScottHausdorff.dirSupInaccOn_of_isOpen _ _ _ (scottHausdorff α D) _ _,\n      fun h' d d₀ d₁ d₂ _ d₃ ha ↦ ?_⟩\n  obtain ⟨b, hbd, hbu⟩ := h' d₀ d₁ d₂ d₃ ha\n  exact ⟨b, hbd, Subset.trans inter_subset_left (h.Ici_subset hbu)⟩\n\n"}
{"name":"Topology.IsScott.isClosed_iff_isLowerSet_and_dirSupClosed","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ns : Set α\ninst✝ : Topology.IsScott α Set.univ\n⊢ Iff (IsClosed s) (And (IsLowerSet s) (DirSupClosed s))","decl":"lemma isClosed_iff_isLowerSet_and_dirSupClosed [IsScott α univ] :\n    IsClosed s ↔ IsLowerSet s ∧ DirSupClosed s := by\n  rw [← isOpen_compl_iff, isOpen_iff_isUpperSet_and_dirSupInaccOn (D := univ), isUpperSet_compl,\n    dirSupInaccOn_univ, dirSupInacc_compl]\n\n"}
{"name":"Topology.IsScott.isUpperSet_of_isOpen","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\nD : Set (Set α)\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ns : Set α\ninst✝ : Topology.IsScott α D\na✝ : IsOpen s\n⊢ IsUpperSet s","decl":"lemma isUpperSet_of_isOpen [IsScott α D] : IsOpen s → IsUpperSet s := fun h ↦\n  (isOpen_iff_isUpperSet_and_scottHausdorff_open (D := D).mp h).left\n\n"}
{"name":"Topology.IsScott.isLowerSet_of_isClosed","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ns : Set α\ninst✝ : Topology.IsScott α Set.univ\na✝ : IsClosed s\n⊢ IsLowerSet s","decl":"lemma isLowerSet_of_isClosed [IsScott α univ] : IsClosed s → IsLowerSet s := fun h ↦\n  (isClosed_iff_isLowerSet_and_dirSupClosed.mp h).left\n\n"}
{"name":"Topology.IsScott.dirSupClosed_of_isClosed","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ns : Set α\ninst✝ : Topology.IsScott α Set.univ\na✝ : IsClosed s\n⊢ DirSupClosed s","decl":"lemma dirSupClosed_of_isClosed [IsScott α univ] : IsClosed s → DirSupClosed s := fun h ↦\n  (isClosed_iff_isLowerSet_and_dirSupClosed.mp h).right\n\n"}
{"name":"Topology.IsScott.lowerClosure_subset_closure","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ns : Set α\ninst✝ : Topology.IsScott α Set.univ\n⊢ HasSubset.Subset (↑(lowerClosure s)) (closure s)","decl":"lemma lowerClosure_subset_closure [IsScott α univ] : ↑(lowerClosure s) ⊆ closure s := by\n  convert closure.mono (@upperSet_le_scott α _)\n  · rw [@IsUpperSet.closure_eq_lowerClosure α _ (upperSet α) ?_ s]\n    infer_instance\n  · exact topology_eq α univ\n\n"}
{"name":"Topology.IsScott.isClosed_Iic","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\na : α\ninst✝ : Topology.IsScott α Set.univ\n⊢ IsClosed (Set.Iic a)","decl":"lemma isClosed_Iic [IsScott α univ] : IsClosed (Iic a) :=\n  isClosed_iff_isLowerSet_and_dirSupClosed.2 ⟨isLowerSet_Iic _, dirSupClosed_Iic _⟩\n\n"}
{"name":"Topology.IsScott.closure_singleton","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\na : α\ninst✝ : Topology.IsScott α Set.univ\n⊢ Eq (closure (Singleton.singleton a)) (Set.Iic a)","decl":"/--\nThe closure of a singleton `{a}` in the Scott topology is the right-closed left-infinite interval\n`(-∞,a]`.\n-/\n@[simp] lemma closure_singleton [IsScott α univ] : closure {a} = Iic a := le_antisymm\n  (closure_minimal (by rw [singleton_subset_iff, mem_Iic]) isClosed_Iic) <| by\n    rw [← LowerSet.coe_Iic, ← lowerClosure_singleton]\n    apply lowerClosure_subset_closure\n\n"}
{"name":"Topology.IsScott.monotone_of_continuous","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\nβ : Type u_2\nD : Set (Set α)\ninst✝⁵ : Preorder α\ninst✝⁴ : TopologicalSpace α\ninst✝³ : Preorder β\ninst✝² : TopologicalSpace β\ninst✝¹ : Topology.IsScott β Set.univ\nf : α → β\ninst✝ : Topology.IsScott α D\nhf : Continuous f\n⊢ Monotone f","decl":"lemma monotone_of_continuous [IsScott α D] (hf : Continuous f) : Monotone f := fun _ b hab ↦ by\n  by_contra h\n  simpa only [mem_compl_iff, mem_preimage, mem_Iic, le_refl, not_true]\n    using isUpperSet_of_isOpen (D := D) ((isOpen_compl_iff.2 isClosed_Iic).preimage hf) hab h\n\n"}
{"name":"Topology.IsScott.scottContinuous_iff_continuous","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Preorder α\ninst✝⁴ : TopologicalSpace α\ninst✝³ : Preorder β\ninst✝² : TopologicalSpace β\ninst✝¹ : Topology.IsScott β Set.univ\nf : α → β\nD : Set (Set α)\ninst✝ : Topology.IsScott α D\nhD : ∀ (a b : α), LE.le a b → Membership.mem D (Insert.insert a (Singleton.singleton b))\n⊢ Iff (ScottContinuousOn D f) (Continuous f)","decl":"@[simp] lemma scottContinuous_iff_continuous {D : Set (Set α)} [Topology.IsScott α D]\n    (hD : ∀ a b : α, a ≤ b → {a, b} ∈ D) : ScottContinuousOn D f ↔ Continuous f := by\n  refine ⟨fun h ↦ continuous_def.2 fun u hu ↦ ?_, ?_⟩\n  · rw [isOpen_iff_isUpperSet_and_dirSupInaccOn (D := D)]\n    exact ⟨(isUpperSet_of_isOpen (D := univ) hu).preimage (h.monotone D hD),\n      fun t h₀ hd₁ hd₂ a hd₃ ha ↦ image_inter_nonempty_iff.mp <|\n        (isOpen_iff_isUpperSet_and_dirSupInaccOn (D := univ).mp hu).2 trivial (Nonempty.image f hd₁)\n        (directedOn_image.mpr (hd₂.mono @(h.monotone D hD))) (h h₀ hd₁ hd₂ hd₃) ha⟩\n  · refine fun hf t h₀ d₁ d₂ a d₃ ↦\n      ⟨(monotone_of_continuous (D := D) hf).mem_upperBounds_image d₃.1,\n      fun b hb ↦ ?_⟩\n    by_contra h\n    let u := (Iic b)ᶜ\n    have hu : IsOpen (f ⁻¹' u) := (isOpen_compl_iff.2 Topology.IsScott.isClosed_Iic).preimage hf\n    rw [isOpen_iff_isUpperSet_and_dirSupInaccOn (D := D)] at hu\n    obtain ⟨c, hcd, hfcb⟩ := hu.2 h₀ d₁ d₂ d₃ h\n    simp only [upperBounds, mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂,\n      mem_setOf] at hb\n    exact hfcb <| hb _ hcd\n\n"}
{"name":"Topology.IsScott.instT0Space","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : TopologicalSpace α\n⊢ T0Space α","decl":"/--\nThe Scott topology on a partial order is T₀.\n-/\n-- see Note [lower instance priority]\ninstance (priority := 90) : T0Space α :=\n  (t0Space_iff_inseparable α).2 fun x y h ↦ Iic_injective <| by\n    simpa only [inseparable_iff_closure_eq, IsScott.closure_singleton] using h\n\n"}
{"name":"Topology.IsScott.isOpen_iff_Iic_compl_or_univ","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝² : CompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsScott α Set.univ\nU : Set α\n⊢ Iff (IsOpen U) (Or (Eq U Set.univ) (Exists fun a => Eq (HasCompl.compl (Set.Iic a)) U))","decl":"lemma isOpen_iff_Iic_compl_or_univ [TopologicalSpace α] [Topology.IsScott α univ] (U : Set α) :\n    IsOpen U ↔ U = univ ∨ ∃ a, (Iic a)ᶜ = U := by\n  constructor\n  · intro hU\n    rcases eq_empty_or_nonempty Uᶜ with eUc | neUc\n    · exact Or.inl (compl_empty_iff.mp eUc)\n    · apply Or.inr\n      use sSup Uᶜ\n      rw [compl_eq_comm, le_antisymm_iff]\n      exact ⟨fun _ ha ↦ le_sSup ha, (isLowerSet_of_isClosed hU.isClosed_compl).Iic_subset\n        (dirSupClosed_iff_forall_sSup.mp (dirSupClosed_of_isClosed hU.isClosed_compl)\n        neUc (isChain_of_trichotomous Uᶜ).directedOn le_rfl)⟩\n  · rintro (rfl | ⟨a, rfl⟩)\n    · exact isOpen_univ\n    · exact isClosed_Iic.isOpen_compl\n\n-- N.B. A number of conditions equivalent to `scott α = upper α` are given in Gierz _et al_,\n-- Chapter III, Exercise 3.23.\n"}
{"name":"Topology.IsScott.scott_eq_upper_of_completeLinearOrder","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : CompleteLinearOrder α\n⊢ Eq (Topology.scott α Set.univ) (Topology.upper α)","decl":"lemma scott_eq_upper_of_completeLinearOrder : scott α univ = upper α := by\n  letI := upper α\n  ext U\n  rw [@Topology.IsUpper.isTopologicalSpace_basis _ _ (upper α)\n    ({ topology_eq_upperTopology := rfl }) U]\n  letI := scott α univ\n  rw [@isOpen_iff_Iic_compl_or_univ _ _ (scott α univ) ({ topology_eq_scott := rfl }) U]\n\n/- The upper topology on a complete linear order is the Scott topology -/\n"}
{"name":"Topology.IsScott.instUnivSetOfIsUpper","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝² : CompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\n⊢ Topology.IsScott α Set.univ","decl":"instance [TopologicalSpace α] [IsUpper α] : IsScott α univ where\n  topology_eq_scott := by\n    rw [scott_eq_upper_of_completeLinearOrder]\n    exact IsUpper.topology_eq α\n\n"}
{"name":"Topology.IsScott.isOpen_iff_scottContinuous_mem","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ns : Set α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsScott α Set.univ\n⊢ Iff (IsOpen s) (ScottContinuous fun x => Membership.mem s x)","decl":"lemma isOpen_iff_scottContinuous_mem [Preorder α] {s : Set α} [TopologicalSpace α]\n    [IsScott α univ] : IsOpen s ↔ ScottContinuous fun x ↦ x ∈ s := by\n  rw [← scottContinuousOn_univ, scottContinuous_iff_continuous (fun _ _ _ ↦ by trivial)]\n  exact isOpen_iff_continuous_mem\n\n"}
{"name":"Topology.WithScott.toScott_symm_eq","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\n⊢ Eq Topology.WithScott.toScott.symm Topology.WithScott.ofScott","decl":"@[simp] lemma toScott_symm_eq : (@toScott α).symm = ofScott := rfl\n"}
{"name":"Topology.WithScott.ofScott_symm_eq","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\n⊢ Eq Topology.WithScott.ofScott.symm Topology.WithScott.toScott","decl":"@[simp] lemma ofScott_symm_eq : (@ofScott α).symm = toScott := rfl\n"}
{"name":"Topology.WithScott.toScott_ofScott","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\na : Topology.WithScott α\n⊢ Eq (Topology.WithScott.toScott (Topology.WithScott.ofScott a)) a","decl":"@[simp] lemma toScott_ofScott (a : WithScott α) : toScott (ofScott a) = a := rfl\n"}
{"name":"Topology.WithScott.ofScott_toScott","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Topology.WithScott.ofScott (Topology.WithScott.toScott a)) a","decl":"@[simp] lemma ofScott_toScott (a : α) : ofScott (toScott a) = a := rfl\n\n"}
{"name":"Topology.WithScott.toScott_inj","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Eq (Topology.WithScott.toScott a) (Topology.WithScott.toScott b)) (Eq a b)","decl":"lemma toScott_inj {a b : α} : toScott a = toScott b ↔ a = b := Iff.rfl\n\n"}
{"name":"Topology.WithScott.ofScott_inj","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\na b : Topology.WithScott α\n⊢ Iff (Eq (Topology.WithScott.ofScott a) (Topology.WithScott.ofScott b)) (Eq a b)","decl":"lemma ofScott_inj {a b : WithScott α} : ofScott a = ofScott b ↔ a = b := Iff.rfl\n"}
{"name":"Topology.WithScott.instNonempty","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ Nonempty (Topology.WithScott α)","decl":"instance [Nonempty α] : Nonempty (WithScott α) := ‹Nonempty α›\n"}
{"name":"Topology.WithScott.instIsScottUnivSet","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Topology.IsScott (Topology.WithScott α) Set.univ","decl":"instance : IsScott (WithScott α) univ := ⟨rfl⟩\n\n"}
{"name":"Topology.WithScott.isOpen_iff_isUpperSet_and_scottHausdorff_open'","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nu : Set α\n⊢ Iff (IsOpen (Set.preimage (⇑Topology.WithScott.ofScott) u)) (And (IsUpperSet u) (TopologicalSpace.IsOpen u))","decl":"lemma isOpen_iff_isUpperSet_and_scottHausdorff_open' {u : Set α} :\n    IsOpen (WithScott.ofScott ⁻¹' u) ↔ IsUpperSet u ∧ (scottHausdorff α univ).IsOpen u := Iff.rfl\n\n"}
{"name":"Topology.scottHausdorff_le_lower","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ LE.le (Topology.scottHausdorff α Set.univ) (Topology.lower α)","decl":"lemma scottHausdorff_le_lower : scottHausdorff α univ ≤ lower α :=\n  fun s h => IsScottHausdorff.isOpen_of_isLowerSet (t := scottHausdorff α univ)\n      <| (@IsLower.isLowerSet_of_isOpen (Topology.WithLower α) _ _ _ s h)\n\n"}
{"name":"Topology.IsScott.scottHausdorff_le","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsScott α Set.univ\n⊢ LE.le (Topology.scottHausdorff α Set.univ) inst✝¹","decl":"lemma IsScott.scottHausdorff_le [IsScott α univ] :\n    scottHausdorff α univ ≤ ‹TopologicalSpace α› := by\n  rw [IsScott.topology_eq α univ, scott]; exact le_sup_right\n\n"}
{"name":"Topology.IsLower.scottHausdorff_le","module":"Mathlib.Topology.Order.ScottTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\n⊢ LE.le (Topology.scottHausdorff α Set.univ) inst✝¹","decl":"lemma IsLower.scottHausdorff_le [IsLower α] : scottHausdorff α univ ≤ ‹TopologicalSpace α› :=\n  fun _ h ↦\n    IsScottHausdorff.isOpen_of_isLowerSet (t := scottHausdorff α univ)\n      <| IsLower.isLowerSet_of_isOpen h\n\n"}
