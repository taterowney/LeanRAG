{"name":"Set.mem_smulAntidiagonal","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : SMul G P\ns : Set G\nt : Set P\na : P\nx : Prod G P\n⊢ Iff (Membership.mem (s.smulAntidiagonal t a) x) (And (Membership.mem s x.1) (And (Membership.mem t x.2) (Eq (HSMul.hSMul x.1 x.2) a)))","decl":"@[to_additive (attr := simp)]\ntheorem mem_smulAntidiagonal : x ∈ smulAntidiagonal s t a ↔ x.1 ∈ s ∧ x.2 ∈ t ∧ x.1 • x.2 = a :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_vaddAntidiagonal","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : VAdd G P\ns : Set G\nt : Set P\na : P\nx : Prod G P\n⊢ Iff (Membership.mem (s.vaddAntidiagonal t a) x) (And (Membership.mem s x.1) (And (Membership.mem t x.2) (Eq (HVAdd.hVAdd x.1 x.2) a)))","decl":"@[to_additive (attr := simp)]\ntheorem mem_smulAntidiagonal : x ∈ smulAntidiagonal s t a ↔ x.1 ∈ s ∧ x.2 ∈ t ∧ x.1 • x.2 = a :=\n  Iff.rfl\n\n"}
{"name":"Set.smulAntidiagonal_mono_left","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : SMul G P\ns₁ s₂ : Set G\nt : Set P\na : P\nh : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (s₁.smulAntidiagonal t a) (s₂.smulAntidiagonal t a)","decl":"@[to_additive]\ntheorem smulAntidiagonal_mono_left (h : s₁ ⊆ s₂) :\n    smulAntidiagonal s₁ t a ⊆ smulAntidiagonal s₂ t a :=\n  fun _ hx => ⟨h hx.1, hx.2.1, hx.2.2⟩\n\n"}
{"name":"Set.vaddAntidiagonal_mono_left","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : VAdd G P\ns₁ s₂ : Set G\nt : Set P\na : P\nh : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (s₁.vaddAntidiagonal t a) (s₂.vaddAntidiagonal t a)","decl":"@[to_additive]\ntheorem smulAntidiagonal_mono_left (h : s₁ ⊆ s₂) :\n    smulAntidiagonal s₁ t a ⊆ smulAntidiagonal s₂ t a :=\n  fun _ hx => ⟨h hx.1, hx.2.1, hx.2.2⟩\n\n"}
{"name":"Set.vaddAntidiagonal_mono_right","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : VAdd G P\ns : Set G\nt₁ t₂ : Set P\na : P\nh : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (s.vaddAntidiagonal t₁ a) (s.vaddAntidiagonal t₂ a)","decl":"@[to_additive]\ntheorem smulAntidiagonal_mono_right (h : t₁ ⊆ t₂) :\n    smulAntidiagonal s t₁ a ⊆ smulAntidiagonal s t₂ a := fun _ hx => ⟨hx.1, h hx.2.1, hx.2.2⟩\n\n"}
{"name":"Set.smulAntidiagonal_mono_right","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝ : SMul G P\ns : Set G\nt₁ t₂ : Set P\na : P\nh : HasSubset.Subset t₁ t₂\n⊢ HasSubset.Subset (s.smulAntidiagonal t₁ a) (s.smulAntidiagonal t₂ a)","decl":"@[to_additive]\ntheorem smulAntidiagonal_mono_right (h : t₁ ⊆ t₂) :\n    smulAntidiagonal s t₁ a ⊆ smulAntidiagonal s t₂ a := fun _ hx => ⟨hx.1, h hx.2.1, hx.2.2⟩\n\n"}
{"name":"Set.VAddAntidiagonal.fst_eq_fst_iff_snd_eq_snd","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ns : Set G\nt : Set P\na : P\ninst✝¹ : VAdd G P\ninst✝ : IsCancelVAdd G P\nx y : ↑(s.vaddAntidiagonal t a)\n⊢ Iff (Eq (↑x).1 (↑y).1) (Eq (↑x).2 (↑y).2)","decl":"@[to_additive VAddAntidiagonal.fst_eq_fst_iff_snd_eq_snd]\ntheorem fst_eq_fst_iff_snd_eq_snd :\n    (x : G × P).1 = (y : G × P).1 ↔ (x : G × P).2 = (y : G × P).2 :=\n  ⟨fun h =>\n    IsCancelSMul.left_cancel _ _ _\n      (y.2.2.2.trans <| by\n          rw [← h]\n          exact x.2.2.2.symm).symm,\n    fun h =>\n    IsCancelSMul.right_cancel _ _ _\n      (y.2.2.2.trans <| by\n          rw [← h]\n          exact x.2.2.2.symm).symm⟩\n\n"}
{"name":"Set.SMulAntidiagonal.fst_eq_fst_iff_snd_eq_snd","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ns : Set G\nt : Set P\na : P\ninst✝¹ : SMul G P\ninst✝ : IsCancelSMul G P\nx y : ↑(s.smulAntidiagonal t a)\n⊢ Iff (Eq (↑x).1 (↑y).1) (Eq (↑x).2 (↑y).2)","decl":"@[to_additive VAddAntidiagonal.fst_eq_fst_iff_snd_eq_snd]\ntheorem fst_eq_fst_iff_snd_eq_snd :\n    (x : G × P).1 = (y : G × P).1 ↔ (x : G × P).2 = (y : G × P).2 :=\n  ⟨fun h =>\n    IsCancelSMul.left_cancel _ _ _\n      (y.2.2.2.trans <| by\n          rw [← h]\n          exact x.2.2.2.symm).symm,\n    fun h =>\n    IsCancelSMul.right_cancel _ _ _\n      (y.2.2.2.trans <| by\n          rw [← h]\n          exact x.2.2.2.symm).symm⟩\n\n"}
{"name":"Set.VAddAntidiagonal.eq_of_fst_eq_fst","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ns : Set G\nt : Set P\na : P\ninst✝¹ : VAdd G P\ninst✝ : IsCancelVAdd G P\nx y : ↑(s.vaddAntidiagonal t a)\nh : Eq (↑x).1 (↑y).1\n⊢ Eq x y","decl":"@[to_additive VAddAntidiagonal.eq_of_fst_eq_fst]\ntheorem eq_of_fst_eq_fst (h : (x : G × P).fst = (y : G × P).fst) : x = y :=\n  Subtype.ext <| Prod.ext h <| fst_eq_fst_iff_snd_eq_snd.1 h\n\n"}
{"name":"Set.SMulAntidiagonal.eq_of_fst_eq_fst","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ns : Set G\nt : Set P\na : P\ninst✝¹ : SMul G P\ninst✝ : IsCancelSMul G P\nx y : ↑(s.smulAntidiagonal t a)\nh : Eq (↑x).1 (↑y).1\n⊢ Eq x y","decl":"@[to_additive VAddAntidiagonal.eq_of_fst_eq_fst]\ntheorem eq_of_fst_eq_fst (h : (x : G × P).fst = (y : G × P).fst) : x = y :=\n  Subtype.ext <| Prod.ext h <| fst_eq_fst_iff_snd_eq_snd.1 h\n\n"}
{"name":"Set.VAddAntidiagonal.eq_of_snd_eq_snd","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ns : Set G\nt : Set P\na : P\ninst✝¹ : VAdd G P\ninst✝ : IsCancelVAdd G P\nx y : ↑(s.vaddAntidiagonal t a)\nh : Eq (↑x).2 (↑y).2\n⊢ Eq x y","decl":"@[to_additive VAddAntidiagonal.eq_of_snd_eq_snd]\ntheorem eq_of_snd_eq_snd (h : (x : G × P).snd = (y : G × P).snd) : x = y :=\n  Subtype.ext <| Prod.ext (fst_eq_fst_iff_snd_eq_snd.2 h) h\n\n"}
{"name":"Set.SMulAntidiagonal.eq_of_snd_eq_snd","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ns : Set G\nt : Set P\na : P\ninst✝¹ : SMul G P\ninst✝ : IsCancelSMul G P\nx y : ↑(s.smulAntidiagonal t a)\nh : Eq (↑x).2 (↑y).2\n⊢ Eq x y","decl":"@[to_additive VAddAntidiagonal.eq_of_snd_eq_snd]\ntheorem eq_of_snd_eq_snd (h : (x : G × P).snd = (y : G × P).snd) : x = y :=\n  Subtype.ext <| Prod.ext (fst_eq_fst_iff_snd_eq_snd.2 h) h\n\n"}
{"name":"Set.SMulAntidiagonal.eq_of_fst_le_fst_of_snd_le_snd","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ns : Set G\nt : Set P\na : P\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\nx y : ↑(s.smulAntidiagonal t a)\nh₁ : LE.le (↑x).1 (↑y).1\nh₂ : LE.le (↑x).2 (↑y).2\n⊢ Eq x y","decl":"@[to_additive VAddAntidiagonal.eq_of_fst_le_fst_of_snd_le_snd]\ntheorem eq_of_fst_le_fst_of_snd_le_snd (h₁ : (x : G × P).1 ≤ (y : G × P).1)\n    (h₂ : (x : G × P).2 ≤ (y : G × P).2) : x = y :=\n  eq_of_fst_eq_fst <|\n    h₁.eq_of_not_lt fun hlt =>\n      (smul_lt_smul_of_lt_of_le hlt h₂).ne <|\n        (mem_smulAntidiagonal.1 x.2).2.2.trans (mem_smulAntidiagonal.1 y.2).2.2.symm\n\n"}
{"name":"Set.VAddAntidiagonal.eq_of_fst_le_fst_of_snd_le_snd","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ns : Set G\nt : Set P\na : P\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\nx y : ↑(s.vaddAntidiagonal t a)\nh₁ : LE.le (↑x).1 (↑y).1\nh₂ : LE.le (↑x).2 (↑y).2\n⊢ Eq x y","decl":"@[to_additive VAddAntidiagonal.eq_of_fst_le_fst_of_snd_le_snd]\ntheorem eq_of_fst_le_fst_of_snd_le_snd (h₁ : (x : G × P).1 ≤ (y : G × P).1)\n    (h₂ : (x : G × P).2 ≤ (y : G × P).2) : x = y :=\n  eq_of_fst_eq_fst <|\n    h₁.eq_of_not_lt fun hlt =>\n      (smul_lt_smul_of_lt_of_le hlt h₂).ne <|\n        (mem_smulAntidiagonal.1 x.2).2.2.trans (mem_smulAntidiagonal.1 y.2).2.2.symm\n\n"}
{"name":"Set.SMulAntidiagonal.finite_of_isPWO","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ns : Set G\nt : Set P\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\nhs : s.IsPWO\nht : t.IsPWO\na : P\n⊢ (s.smulAntidiagonal t a).Finite","decl":"@[to_additive VAddAntidiagonal.finite_of_isPWO]\ntheorem finite_of_isPWO (hs : s.IsPWO) (ht : t.IsPWO) (a) : (smulAntidiagonal s t a).Finite := by\n  refine Set.not_infinite.1 fun h => ?_\n  have h1 : (smulAntidiagonal s t a).PartiallyWellOrderedOn (Prod.fst ⁻¹'o (· ≤ ·)) := fun f hf =>\n    hs (Prod.fst ∘ f) fun n => (mem_smulAntidiagonal.1 (hf n)).1\n  have h2 : (smulAntidiagonal s t a).PartiallyWellOrderedOn (Prod.snd ⁻¹'o (· ≤ ·)) := fun f hf =>\n    ht (Prod.snd ∘ f) fun n => (mem_smulAntidiagonal.1 (hf n)).2.1\n  have isrfl : IsRefl (G × P) (Prod.fst ⁻¹'o fun x x_1 ↦ x ≤ x_1) := by\n    refine { refl := ?refl }\n    simp_all only [Order.Preimage, le_refl, Prod.forall, implies_true]\n  have istrns : IsTrans (G × P) (Prod.fst ⁻¹'o fun x x_1 ↦ x ≤ x_1) := by\n    refine { trans := ?trans }\n    simp_all only [Order.Preimage, Prod.forall]\n    exact fun a _ a_1 _ a_2 _ a_3 a_4 ↦ Preorder.le_trans a a_1 a_2 a_3 a_4\n  obtain ⟨g, hg⟩ :=\n    h1.exists_monotone_subseq (fun n => h.natEmbedding _ n) fun n => (h.natEmbedding _ n).2\n  obtain ⟨m, n, mn, h2'⟩ := h2 (fun x => (h.natEmbedding _) (g x)) fun n => (h.natEmbedding _ _).2\n  refine mn.ne (g.injective <| (h.natEmbedding _).injective ?_)\n  exact eq_of_fst_le_fst_of_snd_le_snd (hg _ _ mn.le) h2'\n\n"}
{"name":"Set.VAddAntidiagonal.finite_of_isPWO","module":"Mathlib.Data.Set.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ns : Set G\nt : Set P\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\nhs : s.IsPWO\nht : t.IsPWO\na : P\n⊢ (s.vaddAntidiagonal t a).Finite","decl":"@[to_additive VAddAntidiagonal.finite_of_isPWO]\ntheorem finite_of_isPWO (hs : s.IsPWO) (ht : t.IsPWO) (a) : (smulAntidiagonal s t a).Finite := by\n  refine Set.not_infinite.1 fun h => ?_\n  have h1 : (smulAntidiagonal s t a).PartiallyWellOrderedOn (Prod.fst ⁻¹'o (· ≤ ·)) := fun f hf =>\n    hs (Prod.fst ∘ f) fun n => (mem_smulAntidiagonal.1 (hf n)).1\n  have h2 : (smulAntidiagonal s t a).PartiallyWellOrderedOn (Prod.snd ⁻¹'o (· ≤ ·)) := fun f hf =>\n    ht (Prod.snd ∘ f) fun n => (mem_smulAntidiagonal.1 (hf n)).2.1\n  have isrfl : IsRefl (G × P) (Prod.fst ⁻¹'o fun x x_1 ↦ x ≤ x_1) := by\n    refine { refl := ?refl }\n    simp_all only [Order.Preimage, le_refl, Prod.forall, implies_true]\n  have istrns : IsTrans (G × P) (Prod.fst ⁻¹'o fun x x_1 ↦ x ≤ x_1) := by\n    refine { trans := ?trans }\n    simp_all only [Order.Preimage, Prod.forall]\n    exact fun a _ a_1 _ a_2 _ a_3 a_4 ↦ Preorder.le_trans a a_1 a_2 a_3 a_4\n  obtain ⟨g, hg⟩ :=\n    h1.exists_monotone_subseq (fun n => h.natEmbedding _ n) fun n => (h.natEmbedding _ n).2\n  obtain ⟨m, n, mn, h2'⟩ := h2 (fun x => (h.natEmbedding _) (g x)) fun n => (h.natEmbedding _ _).2\n  refine mn.ne (g.injective <| (h.natEmbedding _).injective ?_)\n  exact eq_of_fst_le_fst_of_snd_le_snd (hg _ _ mn.le) h2'\n\n"}
