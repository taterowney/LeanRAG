{"name":"ae_eq_zero_of_integral_smooth_smul_eq_zero","module":"Mathlib.Analysis.Distribution.AEEqOfIntegralContDiff","initialProofState":"E : Type u_1\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedSpace Real E\ninstâœÂ¹Â¹ : FiniteDimensional Real E\nF : Type u_2\ninstâœÂ¹â° : NormedAddCommGroup F\ninstâœâ¹ : NormedSpace Real F\ninstâœâ¸ : CompleteSpace F\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\ninstâœâ´ : IsManifold I (â†‘Top.top) M\ninstâœÂ³ : MeasurableSpace M\ninstâœÂ² : BorelSpace M\ninstâœÂ¹ : T2Space M\nf : M â†’ F\nÎ¼ : MeasureTheory.Measure M\ninstâœ : SigmaCompactSpace M\nhf : MeasureTheory.LocallyIntegrable f Î¼\nh : âˆ€ (g : M â†’ Real), ContMDiff I (modelWithCornersSelf Real Real) (â†‘Top.top) g â†’ HasCompactSupport g â†’ Eq (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (g x) (f x)) 0\nâŠ¢ Filter.Eventually (fun x => Eq (f x) 0) (MeasureTheory.ae Î¼)","decl":"/-- If a locally integrable function `f` on a finite-dimensional real manifold has zero integral\nwhen multiplied by any smooth compactly supported function, then `f` vanishes almost everywhere. -/\ntheorem ae_eq_zero_of_integral_smooth_smul_eq_zero [SigmaCompactSpace M]\n    (hf : LocallyIntegrable f Î¼)\n    (h : âˆ€ g : M â†’ â„, ContMDiff I ğ“˜(â„) âˆ g â†’ HasCompactSupport g â†’ âˆ« x, g x â€¢ f x âˆ‚Î¼ = 0) :\n    âˆ€áµ x âˆ‚Î¼, f x = 0 := by\n  -- record topological properties of `M`\n  have := I.locallyCompactSpace\n  have := ChartedSpace.locallyCompactSpace H M\n  have := I.secondCountableTopology\n  have := ChartedSpace.secondCountable_of_sigmaCompact H M\n  have := Manifold.metrizableSpace I M\n  let _ : MetricSpace M := TopologicalSpace.metrizableSpaceMetric M\n  -- it suffices to show that the integral of the function vanishes on any compact set `s`\n  apply ae_eq_zero_of_forall_setIntegral_isCompact_eq_zero' hf (fun s hs â†¦ Eq.symm ?_)\n  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´, 0 < Î´ âˆ§ IsCompact (cthickening Î´ s) := hs.exists_isCompact_cthickening\n  -- choose a sequence of smooth functions `gâ‚™` equal to `1` on `s` and vanishing outside of the\n  -- `uâ‚™`-neighborhood of `s`, where `uâ‚™` tends to zero. Then each integral `âˆ« gâ‚™ f` vanishes,\n  -- and by dominated convergence these integrals converge to `âˆ« x in s, f`.\n  obtain âŸ¨u, -, u_pos, u_limâŸ© : âˆƒ u, StrictAnti u âˆ§ (âˆ€ (n : â„•), u n âˆˆ Ioo 0 Î´)\n    âˆ§ Tendsto u atTop (ğ“ 0) := exists_seq_strictAnti_tendsto' Î´pos\n  let v : â„• â†’ Set M := fun n â†¦ thickening (u n) s\n  obtain âŸ¨K, K_compact, vKâŸ© : âˆƒ K, IsCompact K âˆ§ âˆ€ n, v n âŠ† K :=\n    âŸ¨_, hÎ´, fun n â†¦ thickening_subset_cthickening_of_le (u_pos n).2.le _âŸ©\n  have : âˆ€ n, âˆƒ (g : M â†’ â„), support g = v n âˆ§ ContMDiff I ğ“˜(â„) âˆ g âˆ§ Set.range g âŠ† Set.Icc 0 1\n          âˆ§ âˆ€ x âˆˆ s, g x = 1 := by\n    intro n\n    rcases exists_msmooth_support_eq_eq_one_iff I isOpen_thickening hs.isClosed\n      (self_subset_thickening (u_pos n).1 s) with âŸ¨g, g_smooth, g_range, g_supp, hgâŸ©\n    exact âŸ¨g, g_supp, g_smooth, g_range, fun x hx â†¦ (hg x).1 hxâŸ©\n  choose g g_supp g_diff g_range hg using this\n  -- main fact: the integral of `âˆ« gâ‚™ f` tends to `âˆ« x in s, f`.\n  have L : Tendsto (fun n â†¦ âˆ« x, g n x â€¢ f x âˆ‚Î¼) atTop (ğ“ (âˆ« x in s, f x âˆ‚Î¼)) := by\n    rw [â† integral_indicator hs.measurableSet]\n    let bound : M â†’ â„ := K.indicator (fun x â†¦ â€–f xâ€–)\n    have A : âˆ€ n, AEStronglyMeasurable (fun x â†¦ g n x â€¢ f x) Î¼ :=\n      fun n â†¦ (g_diff n).continuous.aestronglyMeasurable.smul hf.aestronglyMeasurable\n    have B : Integrable bound Î¼ := by\n      rw [integrable_indicator_iff K_compact.measurableSet]\n      exact (hf.integrableOn_isCompact K_compact).norm\n    have C : âˆ€ n, âˆ€áµ x âˆ‚Î¼, â€–g n x â€¢ f xâ€– â‰¤ bound x := by\n      intro n\n      filter_upwards with x\n      rw [norm_smul]\n      refine le_indicator_apply (fun _ â†¦ ?_) (fun hxK â†¦ ?_)\n      Â· have : â€–g n xâ€– â‰¤ 1 := by\n          have := g_range n (mem_range_self (f := g n) x)\n          rw [Real.norm_of_nonneg this.1]\n          exact this.2\n        exact mul_le_of_le_one_left (norm_nonneg _) this\n      Â· have : g n x = 0 := by rw [â† nmem_support, g_supp]; contrapose! hxK; exact vK n hxK\n        simp [this]\n    have D : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => g n x â€¢ f x) atTop (ğ“ (s.indicator f x)) := by\n      filter_upwards with x\n      by_cases hxs : x âˆˆ s\n      Â· have : âˆ€ n, g n x = 1 := fun n â†¦ hg n x hxs\n        simp [this, indicator_of_mem hxs f]\n      Â· simp_rw [indicator_of_not_mem hxs f]\n        apply tendsto_const_nhds.congr'\n        suffices H : âˆ€á¶  n in atTop, g n x = 0 by\n          filter_upwards [H] with n hn using by simp [hn]\n        obtain âŸ¨Îµ, Îµpos, hÎµâŸ© : âˆƒ Îµ, 0 < Îµ âˆ§ x âˆ‰ thickening Îµ s := by\n          rw [â† hs.isClosed.closure_eq, closure_eq_iInter_thickening s] at hxs\n          simpa using hxs\n        filter_upwards [(tendsto_order.1 u_lim).2 _ Îµpos] with n hn\n        rw [â† nmem_support, g_supp]\n        contrapose! hÎµ\n        exact thickening_mono hn.le s hÎµ\n    exact tendsto_integral_of_dominated_convergence bound A B C D\n  -- deduce that `âˆ« x in s, f = 0` as each integral `âˆ« gâ‚™ f` vanishes by assumption\n  have : âˆ€ n, âˆ« x, g n x â€¢ f x âˆ‚Î¼ = 0 := by\n    refine fun n â†¦ h _ (g_diff n) ?_\n    apply HasCompactSupport.of_support_subset_isCompact K_compact\n    simpa [g_supp] using vK n\n  simpa [this] using L\n\n-- An instance with keys containing `Opens`\n"}
{"name":"instBorelSpaceSubtypeMemOpens","module":"Mathlib.Analysis.Distribution.AEEqOfIntegralContDiff","initialProofState":"M : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : MeasurableSpace M\ninstâœ : BorelSpace M\nU : TopologicalSpace.Opens M\nâŠ¢ BorelSpace (Subtype fun x => Membership.mem U x)","decl":"instance (U : Opens M) : BorelSpace U := inferInstanceAs (BorelSpace (U : Set M))\n\n"}
{"name":"IsOpen.ae_eq_zero_of_integral_smooth_smul_eq_zero'","module":"Mathlib.Analysis.Distribution.AEEqOfIntegralContDiff","initialProofState":"E : Type u_1\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedSpace Real E\ninstâœÂ¹â° : FiniteDimensional Real E\nF : Type u_2\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace Real F\ninstâœâ· : CompleteSpace F\nH : Type u_3\ninstâœâ¶ : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_4\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace H M\ninstâœÂ³ : IsManifold I (â†‘Top.top) M\ninstâœÂ² : MeasurableSpace M\ninstâœÂ¹ : BorelSpace M\ninstâœ : T2Space M\nf : M â†’ F\nÎ¼ : MeasureTheory.Measure M\nU : Set M\nhU : IsOpen U\nhSig : IsSigmaCompact U\nhf : MeasureTheory.LocallyIntegrableOn f U Î¼\nh : âˆ€ (g : M â†’ Real), ContMDiff I (modelWithCornersSelf Real Real) (â†‘Top.top) g â†’ HasCompactSupport g â†’ HasSubset.Subset (tsupport g) U â†’ Eq (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (g x) (f x)) 0\nâŠ¢ Filter.Eventually (fun x => Membership.mem U x â†’ Eq (f x) 0) (MeasureTheory.ae Î¼)","decl":"/-- If a function `f` locally integrable on an open subset `U` of a finite-dimensional real\n  manifold has zero integral when multiplied by any smooth function compactly supported\n  in `U`, then `f` vanishes almost everywhere in `U`. -/\nnonrec theorem IsOpen.ae_eq_zero_of_integral_smooth_smul_eq_zero' {U : Set M} (hU : IsOpen U)\n    (hSig : IsSigmaCompact U) (hf : LocallyIntegrableOn f U Î¼)\n    (h : âˆ€ g : M â†’ â„,\n      ContMDiff I ğ“˜(â„) âˆ g â†’ HasCompactSupport g â†’ tsupport g âŠ† U â†’ âˆ« x, g x â€¢ f x âˆ‚Î¼ = 0) :\n    âˆ€áµ x âˆ‚Î¼, x âˆˆ U â†’ f x = 0 := by\n  have meas_U := hU.measurableSet\n  rw [â† ae_restrict_iff' meas_U, ae_restrict_iff_subtype meas_U]\n  let U : Opens M := âŸ¨U, hUâŸ©\n  change âˆ€áµ (x : U) âˆ‚_, _\n  haveI : SigmaCompactSpace U := isSigmaCompact_iff_sigmaCompactSpace.mp hSig\n  refine ae_eq_zero_of_integral_smooth_smul_eq_zero I ?_ fun g g_smth g_supp â†¦ ?_\n  Â· exact (locallyIntegrable_comap meas_U).mpr hf\n  specialize h (Subtype.val.extend g 0) (g_smth.extend_zero g_supp)\n    (g_supp.extend_zero continuous_subtype_val) ((g_supp.tsupport_extend_zero_subset\n      continuous_subtype_val).trans <| Subtype.coe_image_subset _ _)\n  rw [â† setIntegral_eq_integral_of_forall_compl_eq_zero (s := U) fun x hx â†¦ ?_] at h\n  Â· rw [â† integral_subtype_comap] at h\n    Â· simp_rw [Subtype.val_injective.extend_apply] at h; exact h\n    Â· exact meas_U\n  rw [Function.extend_apply' _ _ _ (mt _ hx)]\n  Â· apply zero_smul\n  Â· rintro âŸ¨x, rflâŸ©; exact x.2\n\n"}
{"name":"IsOpen.ae_eq_zero_of_integral_smooth_smul_eq_zero","module":"Mathlib.Analysis.Distribution.AEEqOfIntegralContDiff","initialProofState":"E : Type u_1\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedSpace Real E\ninstâœÂ¹Â¹ : FiniteDimensional Real E\nF : Type u_2\ninstâœÂ¹â° : NormedAddCommGroup F\ninstâœâ¹ : NormedSpace Real F\ninstâœâ¸ : CompleteSpace F\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\ninstâœâ´ : IsManifold I (â†‘Top.top) M\ninstâœÂ³ : MeasurableSpace M\ninstâœÂ² : BorelSpace M\ninstâœÂ¹ : T2Space M\nf : M â†’ F\nÎ¼ : MeasureTheory.Measure M\ninstâœ : SigmaCompactSpace M\nU : Set M\nhU : IsOpen U\nhf : MeasureTheory.LocallyIntegrableOn f U Î¼\nh : âˆ€ (g : M â†’ Real), ContMDiff I (modelWithCornersSelf Real Real) (â†‘Top.top) g â†’ HasCompactSupport g â†’ HasSubset.Subset (tsupport g) U â†’ Eq (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (g x) (f x)) 0\nâŠ¢ Filter.Eventually (fun x => Membership.mem U x â†’ Eq (f x) 0) (MeasureTheory.ae Î¼)","decl":"theorem IsOpen.ae_eq_zero_of_integral_smooth_smul_eq_zero {U : Set M} (hU : IsOpen U)\n    (hf : LocallyIntegrableOn f U Î¼)\n    (h : âˆ€ g : M â†’ â„,\n      ContMDiff I ğ“˜(â„) âˆ g â†’ HasCompactSupport g â†’ tsupport g âŠ† U â†’ âˆ« x, g x â€¢ f x âˆ‚Î¼ = 0) :\n    âˆ€áµ x âˆ‚Î¼, x âˆˆ U â†’ f x = 0 :=\n  haveI := I.locallyCompactSpace\n  haveI := ChartedSpace.locallyCompactSpace H M\n  haveI := hU.locallyCompactSpace\n  haveI := I.secondCountableTopology\n  haveI := ChartedSpace.secondCountable_of_sigmaCompact H M\n  hU.ae_eq_zero_of_integral_smooth_smul_eq_zero' _\n    (isSigmaCompact_iff_sigmaCompactSpace.mpr inferInstance) hf h\n\n"}
{"name":"ae_eq_of_integral_smooth_smul_eq","module":"Mathlib.Analysis.Distribution.AEEqOfIntegralContDiff","initialProofState":"E : Type u_1\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedSpace Real E\ninstâœÂ¹Â¹ : FiniteDimensional Real E\nF : Type u_2\ninstâœÂ¹â° : NormedAddCommGroup F\ninstâœâ¹ : NormedSpace Real F\ninstâœâ¸ : CompleteSpace F\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\ninstâœâ´ : IsManifold I (â†‘Top.top) M\ninstâœÂ³ : MeasurableSpace M\ninstâœÂ² : BorelSpace M\ninstâœÂ¹ : T2Space M\nf f' : M â†’ F\nÎ¼ : MeasureTheory.Measure M\ninstâœ : SigmaCompactSpace M\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhf' : MeasureTheory.LocallyIntegrable f' Î¼\nh : âˆ€ (g : M â†’ Real), ContMDiff I (modelWithCornersSelf Real Real) (â†‘Top.top) g â†’ HasCompactSupport g â†’ Eq (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (g x) (f x)) (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (g x) (f' x))\nâŠ¢ Filter.Eventually (fun x => Eq (f x) (f' x)) (MeasureTheory.ae Î¼)","decl":"/-- If two locally integrable functions on a finite-dimensional real manifold have the same integral\nwhen multiplied by any smooth compactly supported function, then they coincide almost everywhere. -/\ntheorem ae_eq_of_integral_smooth_smul_eq\n    (hf : LocallyIntegrable f Î¼) (hf' : LocallyIntegrable f' Î¼) (h : âˆ€ (g : M â†’ â„),\n      ContMDiff I ğ“˜(â„) âˆ g â†’ HasCompactSupport g â†’ âˆ« x, g x â€¢ f x âˆ‚Î¼ = âˆ« x, g x â€¢ f' x âˆ‚Î¼) :\n    âˆ€áµ x âˆ‚Î¼, f x = f' x := by\n  have : âˆ€áµ x âˆ‚Î¼, (f - f') x = 0 := by\n    apply ae_eq_zero_of_integral_smooth_smul_eq_zero I (hf.sub hf')\n    intro g g_diff g_supp\n    simp only [Pi.sub_apply, smul_sub]\n    rw [integral_sub, sub_eq_zero]\n    Â· exact h g g_diff g_supp\n    Â· exact hf.integrable_smul_left_of_hasCompactSupport g_diff.continuous g_supp\n    Â· exact hf'.integrable_smul_left_of_hasCompactSupport g_diff.continuous g_supp\n  filter_upwards [this] with x hx\n  simpa [sub_eq_zero] using hx\n\n"}
{"name":"ae_eq_zero_of_integral_contDiff_smul_eq_zero","module":"Mathlib.Analysis.Distribution.AEEqOfIntegralContDiff","initialProofState":"E : Type u_1\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : FiniteDimensional Real E\nF : Type u_2\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : BorelSpace E\nf : E â†’ F\nÎ¼ : MeasureTheory.Measure E\nhf : MeasureTheory.LocallyIntegrable f Î¼\nh : âˆ€ (g : E â†’ Real), ContDiff Real (â†‘Top.top) g â†’ HasCompactSupport g â†’ Eq (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (g x) (f x)) 0\nâŠ¢ Filter.Eventually (fun x => Eq (f x) 0) (MeasureTheory.ae Î¼)","decl":"/-- If a locally integrable function `f` on a finite-dimensional real vector space has zero integral\nwhen multiplied by any smooth compactly supported function, then `f` vanishes almost everywhere. -/\ntheorem ae_eq_zero_of_integral_contDiff_smul_eq_zero (hf : LocallyIntegrable f Î¼)\n    (h : âˆ€ (g : E â†’ â„), ContDiff â„ âˆ g â†’ HasCompactSupport g â†’ âˆ« x, g x â€¢ f x âˆ‚Î¼ = 0) :\n    âˆ€áµ x âˆ‚Î¼, f x = 0 :=\n  ae_eq_zero_of_integral_smooth_smul_eq_zero ğ“˜(â„, E) hf\n    (fun g g_diff g_supp â†¦ h g g_diff.contDiff g_supp)\n\n"}
{"name":"ae_eq_of_integral_contDiff_smul_eq","module":"Mathlib.Analysis.Distribution.AEEqOfIntegralContDiff","initialProofState":"E : Type u_1\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : FiniteDimensional Real E\nF : Type u_2\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : BorelSpace E\nf f' : E â†’ F\nÎ¼ : MeasureTheory.Measure E\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhf' : MeasureTheory.LocallyIntegrable f' Î¼\nh : âˆ€ (g : E â†’ Real), ContDiff Real (â†‘Top.top) g â†’ HasCompactSupport g â†’ Eq (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (g x) (f x)) (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (g x) (f' x))\nâŠ¢ Filter.Eventually (fun x => Eq (f x) (f' x)) (MeasureTheory.ae Î¼)","decl":"/-- If two locally integrable functions on a finite-dimensional real vector space have the same\nintegral when multiplied by any smooth compactly supported function, then they coincide almost\neverywhere. -/\ntheorem ae_eq_of_integral_contDiff_smul_eq\n    (hf : LocallyIntegrable f Î¼) (hf' : LocallyIntegrable f' Î¼) (h : âˆ€ (g : E â†’ â„),\n      ContDiff â„ âˆ g â†’ HasCompactSupport g â†’ âˆ« x, g x â€¢ f x âˆ‚Î¼ = âˆ« x, g x â€¢ f' x âˆ‚Î¼) :\n    âˆ€áµ x âˆ‚Î¼, f x = f' x :=\n  ae_eq_of_integral_smooth_smul_eq ğ“˜(â„, E) hf hf'\n    (fun g g_diff g_supp â†¦ h g g_diff.contDiff g_supp)\n\n"}
{"name":"IsOpen.ae_eq_zero_of_integral_contDiff_smul_eq_zero","module":"Mathlib.Analysis.Distribution.AEEqOfIntegralContDiff","initialProofState":"E : Type u_1\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : FiniteDimensional Real E\nF : Type u_2\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : BorelSpace E\nf : E â†’ F\nÎ¼ : MeasureTheory.Measure E\nU : Set E\nhU : IsOpen U\nhf : MeasureTheory.LocallyIntegrableOn f U Î¼\nh : âˆ€ (g : E â†’ Real), ContDiff Real (â†‘Top.top) g â†’ HasCompactSupport g â†’ HasSubset.Subset (tsupport g) U â†’ Eq (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (g x) (f x)) 0\nâŠ¢ Filter.Eventually (fun x => Membership.mem U x â†’ Eq (f x) 0) (MeasureTheory.ae Î¼)","decl":"/-- If a function `f` locally integrable on an open subset `U` of a finite-dimensional real\n  vector space has zero integral when multiplied by any smooth function compactly supported\n  in `U`, then `f` vanishes almost everywhere in `U`. -/\ntheorem IsOpen.ae_eq_zero_of_integral_contDiff_smul_eq_zero {U : Set E} (hU : IsOpen U)\n    (hf : LocallyIntegrableOn f U Î¼)\n    (h : âˆ€ (g : E â†’ â„), ContDiff â„ âˆ g â†’ HasCompactSupport g â†’ tsupport g âŠ† U â†’\n        âˆ« x, g x â€¢ f x âˆ‚Î¼ = 0) :\n    âˆ€áµ x âˆ‚Î¼, x âˆˆ U â†’ f x = 0 :=\n  hU.ae_eq_zero_of_integral_smooth_smul_eq_zero ğ“˜(â„, E) hf\n    (fun g g_diff g_supp â†¦ h g g_diff.contDiff g_supp)\n\n"}
