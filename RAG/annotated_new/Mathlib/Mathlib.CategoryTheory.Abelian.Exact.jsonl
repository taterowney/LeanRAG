{"name":"CategoryTheory.ShortComplex.exact_iff_epi_imageToKernel'","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n‚ä¢ Iff S.Exact (CategoryTheory.Epi (imageToKernel' S.f S.g ‚ãØ))","decl":"theorem exact_iff_epi_imageToKernel' : S.Exact ‚Üî Epi (imageToKernel' S.f S.g S.zero) := by\n  rw [S.exact_iff_epi_kernel_lift]\n  have : factorThruImage S.f ‚â´ imageToKernel' S.f S.g S.zero = kernel.lift S.g S.f S.zero := by\n    simp only [‚Üê cancel_mono (kernel.Œπ _), kernel.lift_Œπ, imageToKernel',\n      Category.assoc, image.fac]\n  constructor\n  ¬∑ intro\n    exact epi_of_epi_fac this\n  ¬∑ intro\n    rw [‚Üê this]\n    apply epi_comp\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_epi_imageToKernel","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n‚ä¢ Iff S.Exact (CategoryTheory.Epi (imageToKernel S.f S.g ‚ãØ))","decl":"theorem exact_iff_epi_imageToKernel : S.Exact ‚Üî Epi (imageToKernel S.f S.g S.zero) := by\n  rw [S.exact_iff_epi_imageToKernel']\n  apply (MorphismProperty.epimorphisms C).arrow_mk_iso_iff\n  exact Arrow.isoMk (imageSubobjectIso S.f).symm (kernelSubobjectIso S.g).symm\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_isIso_imageToKernel","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n‚ä¢ Iff S.Exact (CategoryTheory.IsIso (imageToKernel S.f S.g ‚ãØ))","decl":"theorem exact_iff_isIso_imageToKernel : S.Exact ‚Üî IsIso (imageToKernel S.f S.g S.zero) := by\n  rw [S.exact_iff_epi_imageToKernel]\n  constructor\n  ¬∑ intro\n    apply isIso_of_mono_of_epi\n  ¬∑ intro\n    infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_image_eq_kernel","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n‚ä¢ Iff S.Exact (Eq (CategoryTheory.Limits.imageSubobject S.f) (CategoryTheory.Limits.kernelSubobject S.g))","decl":"/-- In an abelian category, a short complex `S` is exact\niff `imageSubobject S.f = kernelSubobject S.g`.\n-/\ntheorem exact_iff_image_eq_kernel : S.Exact ‚Üî imageSubobject S.f = kernelSubobject S.g := by\n  rw [exact_iff_isIso_imageToKernel]\n  constructor\n  ¬∑ intro\n    exact Subobject.eq_of_comm (asIso (imageToKernel _ _ S.zero)) (by simp)\n  ¬∑ intro h\n    exact ‚ü®Subobject.ofLE _ _ h.ge, by ext; simp, by ext; simp‚ü©\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_of_forks","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\ncg : CategoryTheory.Limits.KernelFork S.g\nhg : CategoryTheory.Limits.IsLimit cg\ncf : CategoryTheory.Limits.CokernelCofork S.f\nhf : CategoryTheory.Limits.IsColimit cf\n‚ä¢ Iff S.Exact (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Œπ cg) (CategoryTheory.Limits.Cofork.œÄ cf)) 0)","decl":"theorem exact_iff_of_forks {cg : KernelFork S.g} (hg : IsLimit cg) {cf : CokernelCofork S.f}\n    (hf : IsColimit cf) : S.Exact ‚Üî cg.Œπ ‚â´ cf.œÄ = 0 := by\n  rw [exact_iff_kernel_Œπ_comp_cokernel_œÄ_zero]\n  let e‚ÇÅ := IsLimit.conePointUniqueUpToIso (kernelIsKernel S.g) hg\n  let e‚ÇÇ := IsColimit.coconePointUniqueUpToIso (cokernelIsCokernel S.f) hf\n  have : cg.Œπ ‚â´ cf.œÄ = e‚ÇÅ.inv ‚â´ kernel.Œπ S.g ‚â´ cokernel.œÄ S.f ‚â´ e‚ÇÇ.hom := by\n    have eq‚ÇÅ := IsLimit.conePointUniqueUpToIso_inv_comp (kernelIsKernel S.g) hg (.zero)\n    have eq‚ÇÇ := IsColimit.comp_coconePointUniqueUpToIso_hom (cokernelIsCokernel S.f) hf (.one)\n    dsimp at eq‚ÇÅ eq‚ÇÇ\n    rw [‚Üê eq‚ÇÅ, ‚Üê eq‚ÇÇ, Category.assoc]\n  rw [this, IsIso.comp_left_eq_zero e‚ÇÅ.inv, ‚Üê Category.assoc,\n    IsIso.comp_right_eq_zero _ e‚ÇÇ.hom]\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_kernel","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ (CategoryTheory.ShortComplex.mk (CategoryTheory.Limits.kernel.Œπ f) f ‚ãØ).Exact","decl":"theorem exact_kernel {X Y : C} (f : X ‚ü∂ Y) :\n    (ShortComplex.mk (kernel.Œπ f) f (by simp)).Exact :=\n  exact_of_f_is_kernel _ (kernelIsKernel f)\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_cokernel","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ (CategoryTheory.ShortComplex.mk f (CategoryTheory.Limits.cokernel.œÄ f) ‚ãØ).Exact","decl":"theorem exact_cokernel {X Y : C} (f : X ‚ü∂ Y) :\n    (ShortComplex.mk f (cokernel.œÄ f) (by simp)).Exact :=\n  exact_of_g_is_cokernel _ (cokernelIsCokernel f)\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_exact_image_Œπ","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n‚ä¢ Iff S.Exact (CategoryTheory.ShortComplex.mk (CategoryTheory.Abelian.image.Œπ S.f) S.g ‚ãØ).Exact","decl":"theorem exact_iff_exact_image_Œπ :\n    S.Exact ‚Üî (ShortComplex.mk (Abelian.image.Œπ S.f) S.g\n      (Abelian.image_Œπ_comp_eq_zero S.zero)).Exact :=\n  ShortComplex.exact_iff_of_epi_of_isIso_of_mono\n    { œÑ‚ÇÅ := Abelian.factorThruImage S.f\n      œÑ‚ÇÇ := ùüô _\n      œÑ‚ÇÉ := ùüô _ }\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_exact_coimage_œÄ","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n‚ä¢ Iff S.Exact (CategoryTheory.ShortComplex.mk S.f (CategoryTheory.Abelian.coimage.œÄ S.g) ‚ãØ).Exact","decl":"theorem exact_iff_exact_coimage_œÄ :\n    S.Exact ‚Üî (ShortComplex.mk S.f (Abelian.coimage.œÄ S.g)\n      (Abelian.comp_coimage_œÄ_eq_zero S.zero)).Exact := by\n  symm\n  exact ShortComplex.exact_iff_of_epi_of_isIso_of_mono\n    { œÑ‚ÇÅ := ùüô _\n      œÑ‚ÇÇ := ùüô _\n      œÑ‚ÇÉ := Abelian.factorThruCoimage S.g }\n\n"}
{"name":"CategoryTheory.Abelian.tfae_mono","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\n‚ä¢ (List.cons (CategoryTheory.Mono f) (List.cons (Eq (CategoryTheory.Limits.kernel.Œπ f) 0) (List.cons (CategoryTheory.ShortComplex.mk 0 f ‚ãØ).Exact List.nil))).TFAE","decl":"open List in\ntheorem Abelian.tfae_mono {X Y : C} (f : X ‚ü∂ Y) (Z : C) :\n    TFAE [Mono f, kernel.Œπ f = 0, (ShortComplex.mk (0 : Z ‚ü∂ X) f zero_comp).Exact] := by\n  tfae_have 2 ‚Üí 1 := mono_of_kernel_Œπ_eq_zero _\n  tfae_have 1 ‚Üí 2\n  | _ => by rw [‚Üê cancel_mono f, kernel.condition, zero_comp]\n  tfae_have 3 ‚Üî 1 := ShortComplex.exact_iff_mono _ (by simp)\n  tfae_finish\n\n"}
{"name":"CategoryTheory.Abelian.tfae_epi","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\n‚ä¢ (List.cons (CategoryTheory.Epi f) (List.cons (Eq (CategoryTheory.Limits.cokernel.œÄ f) 0) (List.cons (CategoryTheory.ShortComplex.mk f 0 ‚ãØ).Exact List.nil))).TFAE","decl":"open List in\ntheorem Abelian.tfae_epi {X Y : C} (f : X ‚ü∂ Y) (Z : C ) :\n    TFAE [Epi f, cokernel.œÄ f = 0, (ShortComplex.mk f (0 : Y ‚ü∂ Z) comp_zero).Exact] := by\n  tfae_have 2 ‚Üí 1 := epi_of_cokernel_œÄ_eq_zero _\n  tfae_have 1 ‚Üí 2\n  | _ => by rw [‚Üê cancel_epi f, cokernel.condition, comp_zero]\n  tfae_have 3 ‚Üî 1 := ShortComplex.exact_iff_epi _ (by simp)\n  tfae_finish\n\n"}
{"name":"CategoryTheory.Functor.reflects_exact_of_faithful","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : F.Faithful\nS : CategoryTheory.ShortComplex C\nhS : (S.map F).Exact\n‚ä¢ S.Exact","decl":"lemma reflects_exact_of_faithful [F.Faithful] (S : ShortComplex C) (hS : (S.map F).Exact) :\n    S.Exact := by\n  rw [ShortComplex.exact_iff_kernel_Œπ_comp_cokernel_œÄ_zero] at hS ‚ä¢\n  dsimp at hS\n  apply F.zero_of_map_zero\n  obtain ‚ü®k, hk‚ü© :=\n    kernel.lift' (F.map S.g) (F.map (kernel.Œπ S.g))\n      (by simp only [‚Üê F.map_comp, kernel.condition, CategoryTheory.Functor.map_zero])\n  obtain ‚ü®l, hl‚ü© :=\n    cokernel.desc' (F.map S.f) (F.map (cokernel.œÄ S.f))\n      (by simp only [‚Üê F.map_comp, cokernel.condition, CategoryTheory.Functor.map_zero])\n  rw [F.map_comp, ‚Üê hl, ‚Üê hk, Category.assoc, reassoc_of% hS, zero_comp, comp_zero]\n\n"}
{"name":"CategoryTheory.Functor.preservesMonomorphisms_of_map_exact","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù¬≤ : CategoryTheory.Abelian A\ninst‚úù¬π : CategoryTheory.Abelian B\nL : CategoryTheory.Functor A B\ninst‚úù : L.PreservesZeroMorphisms\nhL : ‚àÄ (S : CategoryTheory.ShortComplex A), S.Exact ‚Üí (S.map L).Exact\n‚ä¢ L.PreservesMonomorphisms","decl":"/-- A functor which preserves exactness preserves monomorphisms. -/\ntheorem preservesMonomorphisms_of_map_exact : L.PreservesMonomorphisms where\n  preserves f hf := by\n    apply ((Abelian.tfae_mono (L.map f) (L.obj 0)).out 2 0).mp\n    refine ShortComplex.exact_of_iso ?_ (hL _ (((tfae_mono f 0).out 0 2).mp hf))\n    exact ShortComplex.isoMk (Iso.refl _) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.preservesEpimorphisms_of_map_exact","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù¬≤ : CategoryTheory.Abelian A\ninst‚úù¬π : CategoryTheory.Abelian B\nL : CategoryTheory.Functor A B\ninst‚úù : L.PreservesZeroMorphisms\nhL : ‚àÄ (S : CategoryTheory.ShortComplex A), S.Exact ‚Üí (S.map L).Exact\n‚ä¢ L.PreservesEpimorphisms","decl":"/-- A functor which preserves exactness preserves epimorphisms. -/\ntheorem preservesEpimorphisms_of_map_exact : L.PreservesEpimorphisms where\n  preserves f hf := by\n    apply ((Abelian.tfae_epi (L.map f) (L.obj 0)).out 2 0).mp\n    refine ShortComplex.exact_of_iso ?_ (hL _ (((tfae_epi f 0).out 0 2).mp hf))\n    exact ShortComplex.isoMk (Iso.refl _) (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.preservesHomology_of_map_exact","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù¬≤ : CategoryTheory.Abelian A\ninst‚úù¬π : CategoryTheory.Abelian B\nL : CategoryTheory.Functor A B\ninst‚úù : L.PreservesZeroMorphisms\nhL : ‚àÄ (S : CategoryTheory.ShortComplex A), S.Exact ‚Üí (S.map L).Exact\n‚ä¢ L.PreservesHomology","decl":"/-- A functor which preserves the exactness of short complexes preserves homology. -/\nlemma preservesHomology_of_map_exact : L.PreservesHomology where\n  preservesCokernels X Y f := by\n    have := preservesEpimorphisms_of_map_exact _ hL\n    apply preservesColimit_of_preserves_colimit_cocone (cokernelIsCokernel f)\n    apply (CokernelCofork.isColimitMapCoconeEquiv _ L).2\n    have : Epi ((ShortComplex.mk _ _ (cokernel.condition f)).map L).g := by\n      dsimp\n      infer_instance\n    exact (hL (ShortComplex.mk _ _ (cokernel.condition f))\n      (ShortComplex.exact_of_g_is_cokernel _ (cokernelIsCokernel f))).gIsCokernel\n  preservesKernels X Y f := by\n    have := preservesMonomorphisms_of_map_exact _ hL\n    apply preservesLimit_of_preserves_limit_cone (kernelIsKernel f)\n    apply (KernelFork.isLimitMapConeEquiv _ L).2\n    have : Mono ((ShortComplex.mk _ _ (kernel.condition f)).map L).f := by\n      dsimp\n      infer_instance\n    exact (hL (ShortComplex.mk _ _ (kernel.condition f))\n      (ShortComplex.exact_of_f_is_kernel _ (kernelIsKernel f))).fIsKernel\n\n"}
{"name":"CategoryTheory.Functor.preservesHomology_of_preservesMonos_and_cokernels","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù‚Å¥ : CategoryTheory.Abelian A\ninst‚úù¬≥ : CategoryTheory.Abelian B\nL : CategoryTheory.Functor A B\ninst‚úù¬≤ : L.PreservesZeroMorphisms\ninst‚úù¬π : L.PreservesMonomorphisms\ninst‚úù : ‚àÄ {X Y : A} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) L\n‚ä¢ L.PreservesHomology","decl":"/-- A functor preserving zero morphisms, monos, and cokernels preserves homology. -/\nlemma preservesHomology_of_preservesMonos_and_cokernels [PreservesZeroMorphisms L]\n    [PreservesMonomorphisms L] [‚àÄ {X Y} (f : X ‚ü∂ Y), PreservesColimit (parallelPair f 0) L] :\n    PreservesHomology L := by\n  apply preservesHomology_of_map_exact\n  intro S hS\n  let œÜ : (ShortComplex.mk _ _ (Abelian.comp_coimage_œÄ_eq_zero S.zero)).map L ‚ü∂ S.map L :=\n    { œÑ‚ÇÅ := ùüô _\n      œÑ‚ÇÇ := ùüô _\n      œÑ‚ÇÉ := L.map (Abelian.factorThruCoimage S.g)\n      comm‚ÇÇ‚ÇÉ := by\n        dsimp\n        rw [Category.id_comp, ‚Üê L.map_comp, cokernel.œÄ_desc] }\n  apply (ShortComplex.exact_iff_of_epi_of_isIso_of_mono œÜ).1\n  apply ShortComplex.exact_of_g_is_cokernel\n  exact CokernelCofork.mapIsColimit _ ((S.exact_iff_exact_coimage_œÄ).1 hS).gIsCokernel L\n\n"}
{"name":"CategoryTheory.Functor.preservesHomology_of_preservesEpis_and_kernels","module":"Mathlib.CategoryTheory.Abelian.Exact","initialProofState":"A : Type u‚ÇÅ\nB : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\ninst‚úù‚Å¥ : CategoryTheory.Abelian A\ninst‚úù¬≥ : CategoryTheory.Abelian B\nL : CategoryTheory.Functor A B\ninst‚úù¬≤ : L.PreservesZeroMorphisms\ninst‚úù¬π : L.PreservesEpimorphisms\ninst‚úù : ‚àÄ {X Y : A} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) L\n‚ä¢ L.PreservesHomology","decl":"/-- A functor preserving zero morphisms, epis, and kernels preserves homology. -/\nlemma preservesHomology_of_preservesEpis_and_kernels [PreservesZeroMorphisms L]\n    [PreservesEpimorphisms L] [‚àÄ {X Y} (f : X ‚ü∂ Y), PreservesLimit (parallelPair f 0) L] :\n    PreservesHomology L := by\n  apply preservesHomology_of_map_exact\n  intro S hS\n  let œÜ : S.map L ‚ü∂ (ShortComplex.mk _ _ (Abelian.image_Œπ_comp_eq_zero S.zero)).map L :=\n    { œÑ‚ÇÅ := L.map (Abelian.factorThruImage S.f)\n      œÑ‚ÇÇ := ùüô _\n      œÑ‚ÇÉ := ùüô _\n      comm‚ÇÅ‚ÇÇ := by\n        dsimp\n        rw [Category.comp_id, ‚Üê L.map_comp, kernel.lift_Œπ] }\n  apply (ShortComplex.exact_iff_of_epi_of_isIso_of_mono œÜ).2\n  apply ShortComplex.exact_of_f_is_kernel\n  exact KernelFork.mapIsLimit _ ((S.exact_iff_exact_image_Œπ).1 hS).fIsKernel L\n\n"}
