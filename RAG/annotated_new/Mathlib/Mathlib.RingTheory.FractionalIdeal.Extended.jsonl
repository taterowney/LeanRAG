{"name":"FractionalIdeal.mem_extended_iff","module":"Mathlib.RingTheory.FractionalIdeal.Extended","initialProofState":"A : Type u_1\ninst✝⁷ : CommRing A\nB : Type u_2\ninst✝⁶ : CommRing B\nf : RingHom A B\nK : Type u_3\nM : Submonoid A\ninst✝⁵ : CommRing K\ninst✝⁴ : Algebra A K\ninst✝³ : IsLocalization M K\nL : Type u_4\nN : Submonoid B\ninst✝² : CommRing L\ninst✝¹ : Algebra B L\ninst✝ : IsLocalization N L\nhf : LE.le M (Submonoid.comap f N)\nI : FractionalIdeal M K\nx : L\n⊢ Iff (Membership.mem (FractionalIdeal.extended L hf I) x) (Membership.mem (Submodule.span B (Set.image ⇑(IsLocalization.map L f hf) ↑I)) x)","decl":"lemma mem_extended_iff (x : L) : (x ∈ I.extended L hf) ↔ x ∈ span B (map_f '' I) := by\n  constructor <;> { intro hx; simpa }\n\n"}
{"name":"FractionalIdeal.coe_extended_eq_span","module":"Mathlib.RingTheory.FractionalIdeal.Extended","initialProofState":"A : Type u_1\ninst✝⁷ : CommRing A\nB : Type u_2\ninst✝⁶ : CommRing B\nf : RingHom A B\nK : Type u_3\nM : Submonoid A\ninst✝⁵ : CommRing K\ninst✝⁴ : Algebra A K\ninst✝³ : IsLocalization M K\nL : Type u_4\nN : Submonoid B\ninst✝² : CommRing L\ninst✝¹ : Algebra B L\ninst✝ : IsLocalization N L\nhf : LE.le M (Submonoid.comap f N)\nI : FractionalIdeal M K\n⊢ Eq (↑(FractionalIdeal.extended L hf I)) (Submodule.span B (Set.image ⇑(IsLocalization.map L f hf) ↑I))","decl":"@[simp]\nlemma coe_extended_eq_span : I.extended L hf = span B (map_f '' I) := by\n  ext; simp [mem_coe, mem_extended_iff]\n\n"}
{"name":"FractionalIdeal.extended_zero","module":"Mathlib.RingTheory.FractionalIdeal.Extended","initialProofState":"A : Type u_1\ninst✝⁷ : CommRing A\nB : Type u_2\ninst✝⁶ : CommRing B\nf : RingHom A B\nK : Type u_3\nM : Submonoid A\ninst✝⁵ : CommRing K\ninst✝⁴ : Algebra A K\ninst✝³ : IsLocalization M K\nL : Type u_4\nN : Submonoid B\ninst✝² : CommRing L\ninst✝¹ : Algebra B L\ninst✝ : IsLocalization N L\nhf : LE.le M (Submonoid.comap f N)\n⊢ Eq (FractionalIdeal.extended L hf 0) 0","decl":"@[simp]\ntheorem extended_zero : extended L hf (0 : FractionalIdeal M K) = 0 :=\n  have : ((0 : FractionalIdeal M K) : Set K) = {0} := by ext; simp\n  coeToSubmodule_injective (by simp [this])\n\n"}
{"name":"FractionalIdeal.extended_one","module":"Mathlib.RingTheory.FractionalIdeal.Extended","initialProofState":"A : Type u_1\ninst✝⁷ : CommRing A\nB : Type u_2\ninst✝⁶ : CommRing B\nf : RingHom A B\nK : Type u_3\nM : Submonoid A\ninst✝⁵ : CommRing K\ninst✝⁴ : Algebra A K\ninst✝³ : IsLocalization M K\nL : Type u_4\nN : Submonoid B\ninst✝² : CommRing L\ninst✝¹ : Algebra B L\ninst✝ : IsLocalization N L\nhf : LE.le M (Submonoid.comap f N)\n⊢ Eq (FractionalIdeal.extended L hf 1) 1","decl":"@[simp]\ntheorem extended_one : extended L hf (1 : FractionalIdeal M K) = 1 := by\n  refine coeToSubmodule_injective <| Submodule.ext fun x ↦ ⟨fun hx ↦ span_induction\n    ?_ (zero_mem _) (fun y z _ _ hy hz ↦ add_mem hy hz) (fun b y _ hy ↦ smul_mem _ b hy) hx, ?_⟩\n  · rintro ⟨b, _, rfl⟩\n    rw [Algebra.linearMap_apply, Algebra.algebraMap_eq_smul_one]\n    exact smul_mem _ _ <| subset_span ⟨1, by simp [one_mem_one]⟩\n  · rintro _ ⟨_, ⟨a, ha, rfl⟩, rfl⟩\n    exact ⟨f a, ha, by rw [Algebra.linearMap_apply, Algebra.linearMap_apply, map_eq]⟩\n\n"}
{"name":"FractionalIdeal.extended_add","module":"Mathlib.RingTheory.FractionalIdeal.Extended","initialProofState":"A : Type u_1\ninst✝⁷ : CommRing A\nB : Type u_2\ninst✝⁶ : CommRing B\nf : RingHom A B\nK : Type u_3\nM : Submonoid A\ninst✝⁵ : CommRing K\ninst✝⁴ : Algebra A K\ninst✝³ : IsLocalization M K\nL : Type u_4\nN : Submonoid B\ninst✝² : CommRing L\ninst✝¹ : Algebra B L\ninst✝ : IsLocalization N L\nhf : LE.le M (Submonoid.comap f N)\nI J : FractionalIdeal M K\n⊢ Eq (FractionalIdeal.extended L hf (HAdd.hAdd I J)) (HAdd.hAdd (FractionalIdeal.extended L hf I) (FractionalIdeal.extended L hf J))","decl":"theorem extended_add : (I + J).extended L hf = (I.extended L hf) + (J.extended L hf) := by\n  apply coeToSubmodule_injective\n  simp only [coe_extended_eq_span, coe_add, Submodule.add_eq_sup, ← span_union, ← Set.image_union]\n  apply Submodule.span_eq_span\n  · rintro _ ⟨y, hy, rfl⟩\n    obtain ⟨i, hi, j, hj, rfl⟩ := (mem_add I J y).mp <| SetLike.mem_coe.mp hy\n    rw [RingHom.map_add]\n    exact add_mem (Submodule.subset_span ⟨i, Set.mem_union_left _ hi, by simp⟩)\n      (Submodule.subset_span ⟨j, Set.mem_union_right _ hj, by simp⟩)\n  · rintro _ ⟨y, hy, rfl⟩\n    suffices y ∈ I + J from SetLike.mem_coe.mpr <| Submodule.subset_span ⟨y, by simp [this]⟩\n    exact hy.elim (fun h ↦ (mem_add I J y).mpr ⟨y, h, 0, zero_mem J, add_zero y⟩)\n      (fun h ↦ (mem_add I J y).mpr ⟨0, zero_mem I, y, h, zero_add y⟩)\n\n"}
{"name":"FractionalIdeal.extended_mul","module":"Mathlib.RingTheory.FractionalIdeal.Extended","initialProofState":"A : Type u_1\ninst✝⁷ : CommRing A\nB : Type u_2\ninst✝⁶ : CommRing B\nf : RingHom A B\nK : Type u_3\nM : Submonoid A\ninst✝⁵ : CommRing K\ninst✝⁴ : Algebra A K\ninst✝³ : IsLocalization M K\nL : Type u_4\nN : Submonoid B\ninst✝² : CommRing L\ninst✝¹ : Algebra B L\ninst✝ : IsLocalization N L\nhf : LE.le M (Submonoid.comap f N)\nI J : FractionalIdeal M K\n⊢ Eq (FractionalIdeal.extended L hf (HMul.hMul I J)) (HMul.hMul (FractionalIdeal.extended L hf I) (FractionalIdeal.extended L hf J))","decl":"theorem extended_mul : (I * J).extended L hf = (I.extended L hf) * (J.extended L hf) := by\n  apply coeToSubmodule_injective\n  simp only [coe_extended_eq_span, coe_mul, span_mul_span]\n  refine Submodule.span_eq_span (fun _ h ↦ ?_) (fun _ h ↦ ?_)\n  · rcases h with ⟨x, hx, rfl⟩\n    replace hx : x ∈ (I : Submodule A K) * (J : Submodule A K) := coe_mul I J ▸ hx\n    rw [Submodule.mul_eq_span_mul_set] at hx\n    refine span_induction (fun y hy ↦ ?_) (by simp) (fun y z _ _ hy hz ↦ ?_)\n      (fun a y _ hy ↦ ?_) hx\n    · rcases Set.mem_mul.mp hy with ⟨i, hi, j, hj, rfl⟩\n      exact subset_span <| Set.mem_mul.mpr\n        ⟨map_f i, ⟨i, hi, by simp [hi]⟩, map_f j, ⟨j, hj, by simp [hj]⟩, by simp⟩\n    · exact map_add map_f y z ▸ Submodule.add_mem _ hy hz\n    · rw [Algebra.smul_def, map_mul, map_eq, ← Algebra.smul_def]\n      exact smul_mem _ (f a) hy\n  · rcases Set.mem_mul.mp h with ⟨y, ⟨i, hi, rfl⟩, z, ⟨j, hj, rfl⟩, rfl⟩\n    exact Submodule.subset_span ⟨i * j, mul_mem_mul hi hj, by simp⟩\n\n"}
