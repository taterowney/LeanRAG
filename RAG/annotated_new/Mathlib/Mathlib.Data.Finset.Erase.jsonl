{"name":"Finset.erase_val","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ Eq (s.erase a).val (s.val.erase a)","decl":"@[simp]\ntheorem erase_val (s : Finset α) (a : α) : (erase s a).1 = s.1.erase a :=\n  rfl\n\n"}
{"name":"Finset.mem_erase","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Finset α\n⊢ Iff (Membership.mem (s.erase b) a) (And (Ne a b) (Membership.mem s a))","decl":"@[simp]\ntheorem mem_erase {a b : α} {s : Finset α} : a ∈ erase s b ↔ a ≠ b ∧ a ∈ s :=\n  s.2.mem_erase_iff\n\n"}
{"name":"Finset.not_mem_erase","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Not (Membership.mem (s.erase a) a)","decl":"theorem not_mem_erase (a : α) (s : Finset α) : a ∉ erase s a :=\n  s.2.not_mem_erase\n\n"}
{"name":"Finset.ne_of_mem_erase","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na b : α\na✝ : Membership.mem (s.erase a) b\n⊢ Ne b a","decl":"theorem ne_of_mem_erase : b ∈ erase s a → b ≠ a := fun h => (mem_erase.1 h).1\n\n"}
{"name":"Finset.mem_of_mem_erase","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na b : α\na✝ : Membership.mem (s.erase a) b\n⊢ Membership.mem s b","decl":"theorem mem_of_mem_erase : b ∈ erase s a → b ∈ s :=\n  Multiset.mem_of_mem_erase\n\n"}
{"name":"Finset.mem_erase_of_ne_of_mem","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na b : α\na✝¹ : Ne a b\na✝ : Membership.mem s a\n⊢ Membership.mem (s.erase b) a","decl":"theorem mem_erase_of_ne_of_mem : a ≠ b → a ∈ s → a ∈ erase s b := by\n  simp only [mem_erase]; exact And.intro\n\n"}
{"name":"Finset.eq_of_mem_of_not_mem_erase","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na b : α\nhs : Membership.mem s b\nhsa : Not (Membership.mem (s.erase a) b)\n⊢ Eq b a","decl":"/-- An element of `s` that is not an element of `erase s a` must be`a`. -/\ntheorem eq_of_mem_of_not_mem_erase (hs : b ∈ s) (hsa : b ∉ s.erase a) : b = a := by\n  rw [mem_erase, not_and] at hsa\n  exact not_imp_not.mp hsa hs\n\n"}
{"name":"Finset.erase_eq_of_not_mem","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\nh : Not (Membership.mem s a)\n⊢ Eq (s.erase a) s","decl":"@[simp]\ntheorem erase_eq_of_not_mem {a : α} {s : Finset α} (h : a ∉ s) : erase s a = s :=\n  eq_of_veq <| erase_of_not_mem h\n\n"}
{"name":"Finset.erase_eq_self","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ Iff (Eq (s.erase a) s) (Not (Membership.mem s a))","decl":"@[simp]\ntheorem erase_eq_self : s.erase a = s ↔ a ∉ s :=\n  ⟨fun h => h ▸ not_mem_erase _ _, erase_eq_of_not_mem⟩\n\n"}
{"name":"Finset.erase_ne_self","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ Iff (Ne (s.erase a) s) (Membership.mem s a)","decl":"theorem erase_ne_self : s.erase a ≠ s ↔ a ∈ s :=\n  erase_eq_self.not_left\n\n"}
{"name":"Finset.erase_subset_erase","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (s.erase a) (t.erase a)","decl":"theorem erase_subset_erase (a : α) {s t : Finset α} (h : s ⊆ t) : erase s a ⊆ erase t a :=\n  val_le_iff.1 <| erase_le_erase _ <| val_le_iff.2 h\n\n"}
{"name":"Finset.erase_subset","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ HasSubset.Subset (s.erase a) s","decl":"theorem erase_subset (a : α) (s : Finset α) : erase s a ⊆ s :=\n  Multiset.erase_subset _ _\n\n"}
{"name":"Finset.subset_erase","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Finset α\n⊢ Iff (HasSubset.Subset s (t.erase a)) (And (HasSubset.Subset s t) (Not (Membership.mem s a)))","decl":"theorem subset_erase {a : α} {s t : Finset α} : s ⊆ t.erase a ↔ s ⊆ t ∧ a ∉ s :=\n  ⟨fun h => ⟨h.trans (erase_subset _ _), fun ha => not_mem_erase _ _ (h ha)⟩,\n   fun h _b hb => mem_erase.2 ⟨ne_of_mem_of_not_mem hb h.2, h.1 hb⟩⟩\n\n"}
{"name":"Finset.coe_erase","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (↑(s.erase a)) (SDiff.sdiff (↑s) (Singleton.singleton a))","decl":"@[simp, norm_cast]\ntheorem coe_erase (a : α) (s : Finset α) : ↑(erase s a) = (s \\ {a} : Set α) :=\n  Set.ext fun _ => mem_erase.trans <| by rw [and_comm, Set.mem_diff, Set.mem_singleton_iff, mem_coe]\n\n"}
{"name":"Finset.erase_idem","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq ((s.erase a).erase a) (s.erase a)","decl":"theorem erase_idem {a : α} {s : Finset α} : erase (erase s a) a = erase s a := by simp\n\n"}
{"name":"Finset.erase_right_comm","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Finset α\n⊢ Eq ((s.erase a).erase b) ((s.erase b).erase a)","decl":"theorem erase_right_comm {a b : α} {s : Finset α} : erase (erase s a) b = erase (erase s b) a := by\n  ext x\n  simp only [mem_erase, ← and_assoc]\n  rw [@and_comm (x ≠ a)]\n\n"}
{"name":"Finset.erase_inj","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y : α\ns : Finset α\nhx : Membership.mem s x\n⊢ Iff (Eq (s.erase x) (s.erase y)) (Eq x y)","decl":"theorem erase_inj {x y : α} (s : Finset α) (hx : x ∈ s) : s.erase x = s.erase y ↔ x = y := by\n  refine ⟨fun h => eq_of_mem_of_not_mem_erase hx ?_, congr_arg _⟩\n  rw [← h]\n  simp\n\n"}
{"name":"Finset.erase_injOn","module":"Mathlib.Data.Finset.Erase","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Set.InjOn s.erase ↑s","decl":"theorem erase_injOn (s : Finset α) : Set.InjOn s.erase s := fun _ _ _ _ => (erase_inj s ‹_›).mp\n\n"}
