{"name":"Matroid.sigma_indep_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nM : (i : ι) → Matroid (α i)\nI : Set (Sigma fun i => α i)\n⊢ Iff ((Matroid.sigma M).Indep I) (∀ (i : ι), (M i).Indep (Set.preimage (Sigma.mk i) I))","decl":"@[simp] lemma sigma_indep_iff {I} :\n    (Matroid.sigma M).Indep I ↔ ∀ i, (M i).Indep (Sigma.mk i ⁻¹' I) := Iff.rfl\n\n"}
{"name":"Matroid.sigma_base_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nM : (i : ι) → Matroid (α i)\nB : Set (Sigma fun i => α i)\n⊢ Iff ((Matroid.sigma M).Base B) (∀ (i : ι), (M i).Base (Set.preimage (Sigma.mk i) B))","decl":"@[simp] lemma sigma_base_iff {B} :\n    (Matroid.sigma M).Base B ↔ ∀ i, (M i).Base (Sigma.mk i ⁻¹' B) := Iff.rfl\n\n"}
{"name":"Matroid.sigma_ground_eq","module":"Mathlib.Data.Matroid.Sum","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nM : (i : ι) → Matroid (α i)\n⊢ Eq (Matroid.sigma M).E (Set.univ.sigma fun i => (M i).E)","decl":"@[simp] lemma sigma_ground_eq : (Matroid.sigma M).E = univ.sigma fun i ↦ (M i).E := rfl\n\n"}
{"name":"Matroid.sigma_basis_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nM : (i : ι) → Matroid (α i)\nI X : Set (Sigma fun i => α i)\n⊢ Iff ((Matroid.sigma M).Basis I X) (∀ (i : ι), (M i).Basis (Set.preimage (Sigma.mk i) I) (Set.preimage (Sigma.mk i) X))","decl":"@[simp] lemma sigma_basis_iff {I X} :\n    (Matroid.sigma M).Basis I X ↔ ∀ i, (M i).Basis (Sigma.mk i ⁻¹' I) (Sigma.mk i ⁻¹' X) := by\n  simp only [Basis, sigma_indep_iff, maximal_subset_iff, and_imp, and_assoc, sigma_ground_eq,\n    forall_and, and_congr_right_iff]\n  refine fun hI ↦ ⟨fun ⟨hIX, h, h'⟩ ↦ ⟨fun i ↦ preimage_mono hIX, fun i I₀ hI₀ hI₀X hII₀ ↦ ?_, ?_⟩,\n    fun ⟨hIX, h', h''⟩ ↦ ⟨?_, ?_, ?_⟩⟩\n  · refine hII₀.antisymm ?_\n    specialize h (t := I ∪ Sigma.mk i '' I₀)\n    simp only [preimage_union, union_subset_iff, hIX, image_subset_iff, hI₀X, and_self,\n      subset_union_left, true_implies] at h\n    rw [h, preimage_union, sigma_mk_preimage_image_eq_self]\n    · exact subset_union_right\n    intro j\n    obtain (rfl | hij) := eq_or_ne i j\n    · rwa [sigma_mk_preimage_image_eq_self, union_eq_self_of_subset_left hII₀]\n    rw [sigma_mk_preimage_image' hij, union_empty]\n    apply hI\n  · exact fun i ↦ by simpa using preimage_mono (f := Sigma.mk i) h'\n  · exact fun ⟨i, x⟩ hx ↦ by simpa using hIX i hx\n  · refine fun J hJ hJX hIJ ↦ hIJ.antisymm fun ⟨i,x⟩ hx ↦ ?_\n    simpa using (h' i (hJ i) (preimage_mono hJX) (preimage_mono hIJ)).symm.subset hx\n  exact fun ⟨i,x⟩ hx ↦ by simpa using h'' i hx\n\n"}
{"name":"Matroid.Finitary.sigma","module":"Mathlib.Data.Matroid.Sum","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nM : (i : ι) → Matroid (α i)\nh : ∀ (i : ι), (M i).Finitary\n⊢ (Matroid.sigma M).Finitary","decl":"lemma Finitary.sigma (h : ∀ i, (M i).Finitary) : (Matroid.sigma M).Finitary := by\n  refine ⟨fun I hI ↦ ?_⟩\n  simp only [sigma_indep_iff] at hI ⊢\n  intro i\n  apply indep_of_forall_finite_subset_indep\n  intro J hJI hJ\n  convert hI (Sigma.mk i '' J) (by simpa) (hJ.image _) i\n  rw [sigma_mk_preimage_image_eq_self]\n\n"}
{"name":"Matroid.sum'_indep_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nι : Type u_2\nM : ι → Matroid α\nI : Set (Prod ι α)\n⊢ Iff ((Matroid.sum' M).Indep I) (∀ (i : ι), (M i).Indep (Set.preimage (Prod.mk i) I))","decl":"@[simp] lemma sum'_indep_iff {I} :\n    (Matroid.sum' M).Indep I ↔ ∀ i, (M i).Indep (Prod.mk i ⁻¹' I) := by\n  simp only [Matroid.sum', mapEquiv_indep_iff, Equiv.sigmaEquivProd_symm_apply, sigma_indep_iff]\n  convert Iff.rfl\n  ext\n  simp\n\n"}
{"name":"Matroid.sum'_ground_eq","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nι : Type u_2\nM : ι → Matroid α\n⊢ Eq (Matroid.sum' M).E (Set.iUnion fun i => Set.image (Prod.mk i) (M i).E)","decl":"@[simp] lemma sum'_ground_eq (M : ι → Matroid α) :\n    (Matroid.sum' M).E = ⋃ i, Prod.mk i '' (M i).E := by\n  ext\n  simp [Matroid.sum']\n\n"}
{"name":"Matroid.sum'_base_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nι : Type u_2\nM : ι → Matroid α\nB : Set (Prod ι α)\n⊢ Iff ((Matroid.sum' M).Base B) (∀ (i : ι), (M i).Base (Set.preimage (Prod.mk i) B))","decl":"@[simp] lemma sum'_base_iff {B} : (Matroid.sum' M).Base B ↔ ∀ i, (M i).Base (Prod.mk i ⁻¹' B) := by\n  simp only [Matroid.sum', mapEquiv_base_iff, Equiv.sigmaEquivProd_symm_apply, sigma_base_iff]\n  convert Iff.rfl\n  ext\n  simp\n\n"}
{"name":"Matroid.sum'_basis_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nι : Type u_2\nM : ι → Matroid α\nI X : Set (Prod ι α)\n⊢ Iff ((Matroid.sum' M).Basis I X) (∀ (i : ι), (M i).Basis (Set.preimage (Prod.mk i) I) (Set.preimage (Prod.mk i) X))","decl":"@[simp] lemma sum'_basis_iff {I X} :\n    (Matroid.sum' M).Basis I X ↔ ∀ i, (M i).Basis (Prod.mk i ⁻¹' I) (Prod.mk i ⁻¹' X) := by\n  simp [Matroid.sum']\n  convert Iff.rfl <;>\n  exact ext <| by simp\n\n"}
{"name":"Matroid.Finitary.sum'","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nι : Type u_2\nM : ι → Matroid α\nh : ∀ (i : ι), (M i).Finitary\n⊢ (Matroid.sum' M).Finitary","decl":"lemma Finitary.sum' (h : ∀ i, (M i).Finitary) : (Matroid.sum' M).Finitary := by\n  have := Finitary.sigma h\n  rw [Matroid.sum']\n  infer_instance\n\n"}
{"name":"Matroid.disjointSigma_ground_eq","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nι : Type u_2\nM : ι → Matroid α\nh : Pairwise (Function.onFun Disjoint fun i => (M i).E)\n⊢ Eq (Matroid.disjointSigma M h).E (Set.iUnion fun i => (M i).E)","decl":"@[simp] lemma disjointSigma_ground_eq {h} : (Matroid.disjointSigma M h).E = ⋃ i : ι, (M i).E := by\n  ext; simp [Matroid.disjointSigma, mapEmbedding, restrictSubtype]\n\n"}
{"name":"Matroid.disjointSigma_indep_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nι : Type u_2\nM : ι → Matroid α\nh : Pairwise (Function.onFun Disjoint fun i => (M i).E)\nI : Set α\n⊢ Iff ((Matroid.disjointSigma M h).Indep I) (And (∀ (i : ι), (M i).Indep (Inter.inter I (M i).E)) (HasSubset.Subset I (Set.iUnion fun i => (M i).E)))","decl":"@[simp] lemma disjointSigma_indep_iff {h I} :\n    (Matroid.disjointSigma M h).Indep I ↔\n      (∀ i, (M i).Indep (I ∩ (M i).E)) ∧ I ⊆ ⋃ i, (M i).E := by\n  simp [Matroid.disjointSigma, (Function.Embedding.sigmaSet_preimage h)]\n\n"}
{"name":"Matroid.disjointSigma_base_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nι : Type u_2\nM : ι → Matroid α\nh : Pairwise (Function.onFun Disjoint fun i => (M i).E)\nB : Set α\n⊢ Iff ((Matroid.disjointSigma M h).Base B) (And (∀ (i : ι), (M i).Base (Inter.inter B (M i).E)) (HasSubset.Subset B (Set.iUnion fun i => (M i).E)))","decl":"@[simp] lemma disjointSigma_base_iff {h B} :\n    (Matroid.disjointSigma M h).Base B ↔\n      (∀ i, (M i).Base (B ∩ (M i).E)) ∧ B ⊆ ⋃ i, (M i).E := by\n  simp [Matroid.disjointSigma, (Function.Embedding.sigmaSet_preimage h)]\n\n"}
{"name":"Matroid.disjointSigma_basis_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nι : Type u_2\nM : ι → Matroid α\nh : Pairwise (Function.onFun Disjoint fun i => (M i).E)\nI X : Set α\n⊢ Iff ((Matroid.disjointSigma M h).Basis I X) (And (∀ (i : ι), (M i).Basis (Inter.inter I (M i).E) (Inter.inter X (M i).E)) (And (HasSubset.Subset I X) (HasSubset.Subset X (Set.iUnion fun i => (M i).E))))","decl":"@[simp] lemma disjointSigma_basis_iff {h I X} :\n    (Matroid.disjointSigma M h).Basis I X ↔\n      (∀ i, (M i).Basis (I ∩ (M i).E) (X ∩ (M i).E)) ∧ I ⊆ X ∧ X ⊆ ⋃ i, (M i).E := by\n  simp [Matroid.disjointSigma, Function.Embedding.sigmaSet_preimage h]\n\n"}
{"name":"Matroid.sum_ground","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u\nβ : Type v\nM : Matroid α\nN : Matroid β\n⊢ Eq (M.sum N).E (Union.union (Set.image Sum.inl M.E) (Set.image Sum.inr N.E))","decl":"@[simp] lemma sum_ground (M : Matroid α) (N : Matroid β) :\n    (M.sum N).E = (.inl '' M.E) ∪ (.inr '' N.E) := by\n  simp [Matroid.sum, Set.ext_iff, mapEquiv, mapEmbedding, Equiv.ulift, Equiv.sumEquivSigmaBool]\n\n"}
{"name":"Matroid.sum_indep_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u\nβ : Type v\nM : Matroid α\nN : Matroid β\nI : Set (Sum α β)\n⊢ Iff ((M.sum N).Indep I) (And (M.Indep (Set.preimage Sum.inl I)) (N.Indep (Set.preimage Sum.inr I)))","decl":"@[simp] lemma sum_indep_iff (M : Matroid α) (N : Matroid β) {I : Set (α ⊕ β)} :\n    (M.sum N).Indep I ↔ M.Indep (.inl ⁻¹' I) ∧ N.Indep (.inr ⁻¹' I) := by\n  simp only [Matroid.sum, mapEquiv_indep_iff, Equiv.sumCongr_symm, Equiv.sumCongr_apply,\n    Equiv.symm_symm, sigma_indep_iff, Bool.forall_bool, Equiv.ulift_apply]\n  convert Iff.rfl <;>\n    simp [Set.ext_iff, Equiv.ulift, Equiv.sumEquivSigmaBool]\n\n"}
{"name":"Matroid.sum_base_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u\nβ : Type v\nM : Matroid α\nN : Matroid β\nB : Set (Sum α β)\n⊢ Iff ((M.sum N).Base B) (And (M.Base (Set.preimage Sum.inl B)) (N.Base (Set.preimage Sum.inr B)))","decl":"@[simp] lemma sum_base_iff {M : Matroid α} {N : Matroid β} {B : Set (α ⊕ β)} :\n    (M.sum N).Base B ↔ M.Base (.inl ⁻¹' B) ∧ N.Base (.inr ⁻¹' B) := by\n  simp only [Matroid.sum, mapEquiv_base_iff, Equiv.sumCongr_symm, Equiv.sumCongr_apply,\n    Equiv.symm_symm, sigma_base_iff, Bool.forall_bool, Equiv.ulift_apply]\n  convert Iff.rfl <;>\n    simp [Set.ext_iff, Equiv.ulift, Equiv.sumEquivSigmaBool]\n\n"}
{"name":"Matroid.sum_basis_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u\nβ : Type v\nM : Matroid α\nN : Matroid β\nI X : Set (Sum α β)\n⊢ Iff ((M.sum N).Basis I X) (And (M.Basis (Set.preimage Sum.inl I) (Set.preimage Sum.inl X)) (N.Basis (Set.preimage Sum.inr I) (Set.preimage Sum.inr X)))","decl":"@[simp] lemma sum_basis_iff {M : Matroid α} {N : Matroid β} {I X : Set (α ⊕ β)} :\n    (M.sum N).Basis I X ↔\n      (M.Basis (Sum.inl ⁻¹' I) (Sum.inl ⁻¹' X) ∧ N.Basis (Sum.inr ⁻¹' I) (Sum.inr ⁻¹' X)) := by\n  simp only [Matroid.sum, mapEquiv_basis_iff, Equiv.sumCongr_symm,\n    Equiv.sumCongr_apply, Equiv.symm_symm, sigma_basis_iff, Bool.forall_bool, Equiv.ulift_apply,\n    Equiv.sumEquivSigmaBool, Equiv.coe_fn_mk, Equiv.ulift]\n  convert Iff.rfl <;> exact ext <| by simp\n\n"}
{"name":"Matroid.disjointSum_ground_eq","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nM N : Matroid α\nh : Disjoint M.E N.E\n⊢ Eq (M.disjointSum N h).E (Union.union M.E N.E)","decl":"@[simp] lemma disjointSum_ground_eq {h} : (M.disjointSum N h).E = M.E ∪ N.E := by\n  simp [disjointSum, restrictSubtype, mapEmbedding]\n\n"}
{"name":"Matroid.disjointSum_indep_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nM N : Matroid α\nh : Disjoint M.E N.E\nI : Set α\n⊢ Iff ((M.disjointSum N h).Indep I) (And (M.Indep (Inter.inter I M.E)) (And (N.Indep (Inter.inter I N.E)) (HasSubset.Subset I (Union.union M.E N.E))))","decl":"@[simp] lemma disjointSum_indep_iff {h I} :\n    (M.disjointSum N h).Indep I ↔ M.Indep (I ∩ M.E) ∧ N.Indep (I ∩ N.E) ∧ I ⊆ M.E ∪ N.E := by\n  simp [disjointSum, and_assoc]\n\n"}
{"name":"Matroid.disjointSum_base_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nM N : Matroid α\nh : Disjoint M.E N.E\nB : Set α\n⊢ Iff ((M.disjointSum N h).Base B) (And (M.Base (Inter.inter B M.E)) (And (N.Base (Inter.inter B N.E)) (HasSubset.Subset B (Union.union M.E N.E))))","decl":"@[simp] lemma disjointSum_base_iff {h B} :\n    (M.disjointSum N h).Base B ↔ M.Base (B ∩ M.E) ∧ N.Base (B ∩ N.E) ∧ B ⊆ M.E ∪ N.E := by\n  simp [disjointSum, and_assoc]\n\n"}
{"name":"Matroid.disjointSum_basis_iff","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nM N : Matroid α\nh : Disjoint M.E N.E\nI X : Set α\n⊢ Iff ((M.disjointSum N h).Basis I X) (And (M.Basis (Inter.inter I M.E) (Inter.inter X M.E)) (And (N.Basis (Inter.inter I N.E) (Inter.inter X N.E)) (And (HasSubset.Subset I X) (HasSubset.Subset X (Union.union M.E N.E)))))","decl":"@[simp] lemma disjointSum_basis_iff {h I X} :\n    (M.disjointSum N h).Basis I X ↔ M.Basis (I ∩ M.E) (X ∩ M.E) ∧\n      N.Basis (I ∩ N.E) (X ∩ N.E) ∧ I ⊆ X ∧ X ⊆ M.E ∪ N.E := by\n  simp [disjointSum, and_assoc]\n\n"}
{"name":"Matroid.disjointSum_comm","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nM N : Matroid α\nh : Disjoint M.E N.E\n⊢ Eq (M.disjointSum N h) (N.disjointSum M ⋯)","decl":"lemma disjointSum_comm {h} : M.disjointSum N h = N.disjointSum M h.symm := by\n  ext\n  · simp [union_comm]\n  repeat simpa [union_comm] using ⟨fun ⟨m, n, h⟩ ↦ ⟨n, m, M.E.union_comm N.E ▸ h⟩,\n    fun ⟨n, m, h⟩ ↦ ⟨m, n, M.E.union_comm N.E ▸ h⟩⟩\n\n"}
{"name":"Matroid.Indep.eq_union_image_of_disjointSum","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nM N : Matroid α\nh : Disjoint M.E N.E\nI : Set α\nhI : (M.disjointSum N h).Indep I\n⊢ Exists fun IM => Exists fun IN => And (M.Indep IM) (And (N.Indep IN) (And (Disjoint IM IN) (Eq I (Union.union IM IN))))","decl":"lemma Indep.eq_union_image_of_disjointSum {h I} (hI : (disjointSum M N h).Indep I) :\n    ∃ IM IN, M.Indep IM ∧ N.Indep IN ∧ Disjoint IM IN ∧ I = IM ∪ IN := by\n  rw [disjointSum_indep_iff] at hI\n  refine ⟨_, _, hI.1, hI.2.1, h.mono inter_subset_right inter_subset_right, ?_⟩\n  rw [← inter_union_distrib_left, inter_eq_self_of_subset_left hI.2.2]\n\n"}
{"name":"Matroid.Base.eq_union_image_of_disjointSum","module":"Mathlib.Data.Matroid.Sum","initialProofState":"α : Type u_1\nM N : Matroid α\nh : Disjoint M.E N.E\nB : Set α\nhB : (M.disjointSum N h).Base B\n⊢ Exists fun BM => Exists fun BN => And (M.Base BM) (And (N.Base BN) (And (Disjoint BM BN) (Eq B (Union.union BM BN))))","decl":"lemma Base.eq_union_image_of_disjointSum {h B} (hB : (disjointSum M N h).Base B) :\n    ∃ BM BN, M.Base BM ∧ N.Base BN ∧ Disjoint BM BN ∧ B = BM ∪ BN := by\n  rw [disjointSum_base_iff] at hB\n  refine ⟨_, _, hB.1, hB.2.1, h.mono inter_subset_right inter_subset_right, ?_⟩\n  rw [← inter_union_distrib_left, inter_eq_self_of_subset_left hB.2.2]\n\n"}
