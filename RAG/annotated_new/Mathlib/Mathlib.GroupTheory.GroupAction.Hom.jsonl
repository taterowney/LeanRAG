{"name":"AddActionHom.mk.injEq","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_8\nN : Type u_9\nφ : M → N\nX : Type u_10\ninst✝¹ : VAdd M X\nY : Type u_11\ninst✝ : VAdd N Y\ntoFun✝ : X → Y\nmap_vadd'✝ : ∀ (m : M) (x : X), Eq (toFun✝ (HVAdd.hVAdd m x)) (HVAdd.hVAdd (φ m) (toFun✝ x))\ntoFun : X → Y\nmap_vadd' : ∀ (m : M) (x : X), Eq (toFun (HVAdd.hVAdd m x)) (HVAdd.hVAdd (φ m) (toFun x))\n⊢ Eq (Eq { toFun := toFun✝, map_vadd' := map_vadd'✝ } { toFun := toFun, map_vadd' := map_vadd' }) (Eq toFun✝ toFun)","decl":"/-- Equivariant functions :\nWhen `φ : M → N` is a function, and types `X` and `Y` are endowed with additive actions\nof `M` and `N`, a function `f : X → Y` is `φ`-equivariant if `f (m +ᵥ x) = (φ m) +ᵥ (f x)`. -/\nstructure AddActionHom {M N : Type*} (φ: M → N) (X : Type*) [VAdd M X] (Y : Type*) [VAdd N Y] where\n  /-- The underlying function. -/\n  protected toFun : X → Y\n  /-- The proposition that the function commutes with the additive actions. -/\n  protected map_vadd' : ∀ (m : M) (x : X), toFun (m +ᵥ x) = (φ m) +ᵥ toFun x\n\n"}
{"name":"AddActionHom.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_8\nN : Type u_9\nφ : M → N\nX : Type u_10\ninst✝⁵ : VAdd M X\nY : Type u_11\ninst✝⁴ : VAdd N Y\ninst✝³ : SizeOf M\ninst✝² : SizeOf N\ninst✝¹ : SizeOf X\ninst✝ : SizeOf Y\ntoFun : X → Y\nmap_vadd' : ∀ (m : M) (x : X), Eq (toFun (HVAdd.hVAdd m x)) (HVAdd.hVAdd (φ m) (toFun x))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_vadd' := map_vadd' }) 1","decl":"/-- Equivariant functions :\nWhen `φ : M → N` is a function, and types `X` and `Y` are endowed with additive actions\nof `M` and `N`, a function `f : X → Y` is `φ`-equivariant if `f (m +ᵥ x) = (φ m) +ᵥ (f x)`. -/\nstructure AddActionHom {M N : Type*} (φ: M → N) (X : Type*) [VAdd M X] (Y : Type*) [VAdd N Y] where\n  /-- The underlying function. -/\n  protected toFun : X → Y\n  /-- The proposition that the function commutes with the additive actions. -/\n  protected map_vadd' : ∀ (m : M) (x : X), toFun (m +ᵥ x) = (φ m) +ᵥ toFun x\n\n"}
{"name":"AddActionHom.mk.inj","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_8\nN : Type u_9\nφ : M → N\nX : Type u_10\ninst✝¹ : VAdd M X\nY : Type u_11\ninst✝ : VAdd N Y\ntoFun✝ : X → Y\nmap_vadd'✝ : ∀ (m : M) (x : X), Eq (toFun✝ (HVAdd.hVAdd m x)) (HVAdd.hVAdd (φ m) (toFun✝ x))\ntoFun : X → Y\nmap_vadd' : ∀ (m : M) (x : X), Eq (toFun (HVAdd.hVAdd m x)) (HVAdd.hVAdd (φ m) (toFun x))\nx✝ : Eq { toFun := toFun✝, map_vadd' := map_vadd'✝ } { toFun := toFun, map_vadd' := map_vadd' }\n⊢ Eq toFun✝ toFun","decl":"/-- Equivariant functions :\nWhen `φ : M → N` is a function, and types `X` and `Y` are endowed with additive actions\nof `M` and `N`, a function `f : X → Y` is `φ`-equivariant if `f (m +ᵥ x) = (φ m) +ᵥ (f x)`. -/\nstructure AddActionHom {M N : Type*} (φ: M → N) (X : Type*) [VAdd M X] (Y : Type*) [VAdd N Y] where\n  /-- The underlying function. -/\n  protected toFun : X → Y\n  /-- The proposition that the function commutes with the additive actions. -/\n  protected map_vadd' : ∀ (m : M) (x : X), toFun (m +ᵥ x) = (φ m) +ᵥ toFun x\n\n"}
{"name":"AddActionHom.map_vadd'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_8\nN : Type u_9\nφ : M → N\nX : Type u_10\ninst✝¹ : VAdd M X\nY : Type u_11\ninst✝ : VAdd N Y\nself : AddActionHom φ X Y\nm : M\nx : X\n⊢ Eq (self.toFun (HVAdd.hVAdd m x)) (HVAdd.hVAdd (φ m) (self.toFun x))","decl":"/-- Equivariant functions :\nWhen `φ : M → N` is a function, and types `X` and `Y` are endowed with additive actions\nof `M` and `N`, a function `f : X → Y` is `φ`-equivariant if `f (m +ᵥ x) = (φ m) +ᵥ (f x)`. -/\nstructure AddActionHom {M N : Type*} (φ: M → N) (X : Type*) [VAdd M X] (Y : Type*) [VAdd N Y] where\n  /-- The underlying function. -/\n  protected toFun : X → Y\n  /-- The proposition that the function commutes with the additive actions. -/\n  protected map_vadd' : ∀ (m : M) (x : X), toFun (m +ᵥ x) = (φ m) +ᵥ toFun x\n\n"}
{"name":"MulActionHom.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝⁵ : SMul M X\nY : Type u_6\ninst✝⁴ : SMul N Y\ninst✝³ : SizeOf M\ninst✝² : SizeOf N\ninst✝¹ : SizeOf X\ninst✝ : SizeOf Y\ntoFun : X → Y\nmap_smul' : ∀ (m : M) (x : X), Eq (toFun (HSMul.hSMul m x)) (HSMul.hSMul (φ m) (toFun x))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_smul' := map_smul' }) 1","decl":"/-- Equivariant functions :\nWhen `φ : M → N` is a function, and types `X` and `Y` are endowed with actions of `M` and `N`,\na function `f : X → Y` is `φ`-equivariant if `f (m • x) = (φ m) • (f x)`. -/\n@[to_additive]\nstructure MulActionHom where\n  /-- The underlying function. -/\n  protected toFun : X → Y\n  /-- The proposition that the function commutes with the actions. -/\n  protected map_smul' : ∀ (m : M) (x : X), toFun (m • x) = (φ m) • toFun x\n\n/- Porting note: local notation given a name, conflict with Algebra.Hom.GroupAction\n see https://github.com/leanprover/lean4/issues/2000 -/\n"}
{"name":"MulActionHom.map_smul'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\nself : MulActionHom φ X Y\nm : M\nx : X\n⊢ Eq (self.toFun (HSMul.hSMul m x)) (HSMul.hSMul (φ m) (self.toFun x))","decl":"/-- Equivariant functions :\nWhen `φ : M → N` is a function, and types `X` and `Y` are endowed with actions of `M` and `N`,\na function `f : X → Y` is `φ`-equivariant if `f (m • x) = (φ m) • (f x)`. -/\n@[to_additive]\nstructure MulActionHom where\n  /-- The underlying function. -/\n  protected toFun : X → Y\n  /-- The proposition that the function commutes with the actions. -/\n  protected map_smul' : ∀ (m : M) (x : X), toFun (m • x) = (φ m) • toFun x\n\n/- Porting note: local notation given a name, conflict with Algebra.Hom.GroupAction\n see https://github.com/leanprover/lean4/issues/2000 -/\n"}
{"name":"MulActionHom.mk.injEq","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\ntoFun✝ : X → Y\nmap_smul'✝ : ∀ (m : M) (x : X), Eq (toFun✝ (HSMul.hSMul m x)) (HSMul.hSMul (φ m) (toFun✝ x))\ntoFun : X → Y\nmap_smul' : ∀ (m : M) (x : X), Eq (toFun (HSMul.hSMul m x)) (HSMul.hSMul (φ m) (toFun x))\n⊢ Eq (Eq { toFun := toFun✝, map_smul' := map_smul'✝ } { toFun := toFun, map_smul' := map_smul' }) (Eq toFun✝ toFun)","decl":"/-- Equivariant functions :\nWhen `φ : M → N` is a function, and types `X` and `Y` are endowed with actions of `M` and `N`,\na function `f : X → Y` is `φ`-equivariant if `f (m • x) = (φ m) • (f x)`. -/\n@[to_additive]\nstructure MulActionHom where\n  /-- The underlying function. -/\n  protected toFun : X → Y\n  /-- The proposition that the function commutes with the actions. -/\n  protected map_smul' : ∀ (m : M) (x : X), toFun (m • x) = (φ m) • toFun x\n\n/- Porting note: local notation given a name, conflict with Algebra.Hom.GroupAction\n see https://github.com/leanprover/lean4/issues/2000 -/\n"}
{"name":"MulActionHom.mk.inj","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\ntoFun✝ : X → Y\nmap_smul'✝ : ∀ (m : M) (x : X), Eq (toFun✝ (HSMul.hSMul m x)) (HSMul.hSMul (φ m) (toFun✝ x))\ntoFun : X → Y\nmap_smul' : ∀ (m : M) (x : X), Eq (toFun (HSMul.hSMul m x)) (HSMul.hSMul (φ m) (toFun x))\nx✝ : Eq { toFun := toFun✝, map_smul' := map_smul'✝ } { toFun := toFun, map_smul' := map_smul' }\n⊢ Eq toFun✝ toFun","decl":"/-- Equivariant functions :\nWhen `φ : M → N` is a function, and types `X` and `Y` are endowed with actions of `M` and `N`,\na function `f : X → Y` is `φ`-equivariant if `f (m • x) = (φ m) • (f x)`. -/\n@[to_additive]\nstructure MulActionHom where\n  /-- The underlying function. -/\n  protected toFun : X → Y\n  /-- The proposition that the function commutes with the actions. -/\n  protected map_smul' : ∀ (m : M) (x : X), toFun (m • x) = (φ m) • toFun x\n\n/- Porting note: local notation given a name, conflict with Algebra.Hom.GroupAction\n see https://github.com/leanprover/lean4/issues/2000 -/\n"}
{"name":"AddActionSemiHomClass.map_vaddₛₗ","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"F : Type u_8\nM : outParam (Type u_9)\nN : outParam (Type u_10)\nφ : outParam (M → N)\nX : outParam (Type u_11)\nY : outParam (Type u_12)\ninst✝² : VAdd M X\ninst✝¹ : VAdd N Y\ninst✝ : FunLike F X Y\nself : AddActionSemiHomClass F φ X Y\nf : F\nc : M\nx : X\n⊢ Eq (f (HVAdd.hVAdd c x)) (HVAdd.hVAdd (φ c) (f x))","decl":"/-- `AddActionSemiHomClass F φ X Y` states that\n  `F` is a type of morphisms which are `φ`-equivariant.\n\nYou should extend this class when you extend `AddActionHom`. -/\nclass AddActionSemiHomClass (F : Type*)\n    {M N : outParam Type*} (φ : outParam (M → N))\n    (X Y : outParam Type*) [VAdd M X] [VAdd N Y] [FunLike F X Y] : Prop where\n  /-- The proposition that the function preserves the action. -/\n  map_vaddₛₗ : ∀ (f : F) (c : M) (x : X), f (c +ᵥ x) = (φ c) +ᵥ (f x)\n\n"}
{"name":"MulActionSemiHomClass.map_smulₛₗ","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"F : Type u_8\nM : outParam (Type u_9)\nN : outParam (Type u_10)\nφ : outParam (M → N)\nX : outParam (Type u_11)\nY : outParam (Type u_12)\ninst✝² : SMul M X\ninst✝¹ : SMul N Y\ninst✝ : FunLike F X Y\nself : MulActionSemiHomClass F φ X Y\nf : F\nc : M\nx : X\n⊢ Eq (f (HSMul.hSMul c x)) (HSMul.hSMul (φ c) (f x))","decl":"/-- `MulActionSemiHomClass F φ X Y` states that\n  `F` is a type of morphisms which are `φ`-equivariant.\n\nYou should extend this class when you extend `MulActionHom`. -/\n@[to_additive]\nclass MulActionSemiHomClass (F : Type*)\n    {M N : outParam Type*} (φ : outParam (M → N))\n    (X Y : outParam Type*) [SMul M X] [SMul N Y] [FunLike F X Y] : Prop where\n  /-- The proposition that the function preserves the action. -/\n  map_smulₛₗ : ∀ (f : F) (c : M) (x : X), f (c • x) = (φ c) • (f x)\n\n"}
{"name":"map_vadd","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"F : Type u_8\nM : Type u_9\nX : Type u_10\nY : Type u_11\ninst✝³ : VAdd M X\ninst✝² : VAdd M Y\ninst✝¹ : FunLike F X Y\ninst✝ : AddActionHomClass F M X Y\nf : F\nc : M\nx : X\n⊢ Eq (f (HVAdd.hVAdd c x)) (HVAdd.hVAdd c (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_smul {F M X Y : Type*} [SMul M X] [SMul M Y]\n    [FunLike F X Y] [MulActionHomClass F M X Y]\n    (f : F) (c : M) (x : X) : f (c • x) = c • f x :=\n  map_smulₛₗ f c x\n\n"}
{"name":"map_smul","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"F : Type u_8\nM : Type u_9\nX : Type u_10\nY : Type u_11\ninst✝³ : SMul M X\ninst✝² : SMul M Y\ninst✝¹ : FunLike F X Y\ninst✝ : MulActionHomClass F M X Y\nf : F\nc : M\nx : X\n⊢ Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_smul {F M X Y : Type*} [SMul M X] [SMul M Y]\n    [FunLike F X Y] [MulActionHomClass F M X Y]\n    (f : F) (c : M) (x : X) : f (c • x) = c • f x :=\n  map_smulₛₗ f c x\n\n"}
{"name":"instAddActionSemiHomClassAddActionHom","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : VAdd M X\nY : Type u_6\ninst✝ : VAdd N Y\n⊢ AddActionSemiHomClass (AddActionHom φ X Y) φ X Y","decl":"@[to_additive]\ninstance : MulActionSemiHomClass (X →ₑ[φ] Y) φ X Y where\n  map_smulₛₗ := MulActionHom.map_smul'\n\n"}
{"name":"instMulActionSemiHomClassMulActionHom","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\n⊢ MulActionSemiHomClass (MulActionHom φ X Y) φ X Y","decl":"@[to_additive]\ninstance : MulActionSemiHomClass (X →ₑ[φ] Y) φ X Y where\n  map_smulₛₗ := MulActionHom.map_smul'\n\n"}
{"name":"IsScalarTower.smulHomClass","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M' : Type u_1\nX : Type u_5\ninst✝⁶ : SMul M' X\nY : Type u_6\ninst✝⁵ : SMul M' Y\nF : Type u_8\ninst✝⁴ : FunLike F X Y\ninst✝³ : MulOneClass X\ninst✝² : SMul X Y\ninst✝¹ : IsScalarTower M' X Y\ninst✝ : MulActionHomClass F X X Y\n⊢ MulActionHomClass F M' X Y","decl":"variable (M' X Y F) in\n/-- If Y/X/M forms a scalar tower, any map X → Y preserving X-action also preserves M-action. -/\n@[to_additive]\ntheorem _root_.IsScalarTower.smulHomClass [MulOneClass X] [SMul X Y] [IsScalarTower M' X Y]\n    [MulActionHomClass F X X Y] : MulActionHomClass F M' X Y where\n  map_smulₛₗ f m x := by\n    rw [← mul_one (m • x), ← smul_eq_mul, map_smul, smul_assoc, ← map_smul,\n      smul_eq_mul, mul_one, id_eq]\n\n"}
{"name":"VAddAssocClass.vaddHomClass","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M' : Type u_1\nX : Type u_5\ninst✝⁶ : VAdd M' X\nY : Type u_6\ninst✝⁵ : VAdd M' Y\nF : Type u_8\ninst✝⁴ : FunLike F X Y\ninst✝³ : AddZeroClass X\ninst✝² : VAdd X Y\ninst✝¹ : VAddAssocClass M' X Y\ninst✝ : AddActionHomClass F X X Y\n⊢ AddActionHomClass F M' X Y","decl":"variable (M' X Y F) in\n/-- If Y/X/M forms a scalar tower, any map X → Y preserving X-action also preserves M-action. -/\n@[to_additive]\ntheorem _root_.IsScalarTower.smulHomClass [MulOneClass X] [SMul X Y] [IsScalarTower M' X Y]\n    [MulActionHomClass F X X Y] : MulActionHomClass F M' X Y where\n  map_smulₛₗ f m x := by\n    rw [← mul_one (m • x), ← smul_eq_mul, map_smul, smul_assoc, ← map_smul,\n      smul_eq_mul, mul_one, id_eq]\n\n"}
{"name":"MulActionHom.map_smul","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M' : Type u_1\nX : Type u_5\ninst✝¹ : SMul M' X\nY : Type u_6\ninst✝ : SMul M' Y\nf : MulActionHom id X Y\nm : M'\nx : X\n⊢ Eq (f (HSMul.hSMul m x)) (HSMul.hSMul m (f x))","decl":"@[to_additive]\nprotected theorem map_smul (f : X →[M'] Y) (m : M') (x : X) : f (m • x) = m • f x :=\n  map_smul f m x\n\n"}
{"name":"AddActionHom.map_vadd","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M' : Type u_1\nX : Type u_5\ninst✝¹ : VAdd M' X\nY : Type u_6\ninst✝ : VAdd M' Y\nf : AddActionHom id X Y\nm : M'\nx : X\n⊢ Eq (f (HVAdd.hVAdd m x)) (HVAdd.hVAdd m (f x))","decl":"@[to_additive]\nprotected theorem map_smul (f : X →[M'] Y) (m : M') (x : X) : f (m • x) = m • f x :=\n  map_smul f m x\n\n"}
{"name":"AddActionHom.ext","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : VAdd M X\nY : Type u_6\ninst✝ : VAdd N Y\nf g : AddActionHom φ X Y\na✝ : ∀ (x : X), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem ext {f g : X →ₑ[φ] Y} :\n    (∀ x, f x = g x) → f = g :=\n  DFunLike.ext f g\n\n"}
{"name":"MulActionHom.ext","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\nf g : MulActionHom φ X Y\na✝ : ∀ (x : X), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem ext {f g : X →ₑ[φ] Y} :\n    (∀ x, f x = g x) → f = g :=\n  DFunLike.ext f g\n\n"}
{"name":"AddActionHom.ext_iff","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : VAdd M X\nY : Type u_6\ninst✝ : VAdd N Y\nf g : AddActionHom φ X Y\n⊢ Iff (Eq f g) (∀ (x : X), Eq (f x) (g x))","decl":"@[to_additive (attr := ext)]\ntheorem ext {f g : X →ₑ[φ] Y} :\n    (∀ x, f x = g x) → f = g :=\n  DFunLike.ext f g\n\n"}
{"name":"MulActionHom.ext_iff","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\nf g : MulActionHom φ X Y\n⊢ Iff (Eq f g) (∀ (x : X), Eq (f x) (g x))","decl":"@[to_additive (attr := ext)]\ntheorem ext {f g : X →ₑ[φ] Y} :\n    (∀ x, f x = g x) → f = g :=\n  DFunLike.ext f g\n\n"}
{"name":"MulActionHom.congr_fun","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\nf g : MulActionHom φ X Y\nh : Eq f g\nx : X\n⊢ Eq (f x) (g x)","decl":"@[to_additive]\nprotected theorem congr_fun {f g : X →ₑ[φ] Y} (h : f = g) (x : X) :\n    f x = g x :=\n  DFunLike.congr_fun h _\n\n"}
{"name":"AddActionHom.congr_fun","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : VAdd M X\nY : Type u_6\ninst✝ : VAdd N Y\nf g : AddActionHom φ X Y\nh : Eq f g\nx : X\n⊢ Eq (f x) (g x)","decl":"@[to_additive]\nprotected theorem congr_fun {f g : X →ₑ[φ] Y} (h : f = g) (x : X) :\n    f x = g x :=\n  DFunLike.congr_fun h _\n\n"}
{"name":"MulActionHom.ofEq_coe","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\nφ' : M → N\nh : Eq φ φ'\nf : MulActionHom φ X Y\n⊢ Eq (MulActionHom.ofEq h f).toFun f.toFun","decl":"@[to_additive (attr := simp)]\ntheorem ofEq_coe {φ' : M → N} (h : φ = φ') (f : X →ₑ[φ] Y) :\n    (f.ofEq h).toFun = f.toFun := rfl\n\n"}
{"name":"AddActionHom.ofEq_coe","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : VAdd M X\nY : Type u_6\ninst✝ : VAdd N Y\nφ' : M → N\nh : Eq φ φ'\nf : AddActionHom φ X Y\n⊢ Eq (AddActionHom.ofEq h f).toFun f.toFun","decl":"@[to_additive (attr := simp)]\ntheorem ofEq_coe {φ' : M → N} (h : φ = φ') (f : X →ₑ[φ] Y) :\n    (f.ofEq h).toFun = f.toFun := rfl\n\n"}
{"name":"AddActionHom.ofEq_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : VAdd M X\nY : Type u_6\ninst✝ : VAdd N Y\nφ' : M → N\nh : Eq φ φ'\nf : AddActionHom φ X Y\na : X\n⊢ Eq ((AddActionHom.ofEq h f) a) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem ofEq_apply {φ' : M → N} (h : φ = φ') (f : X →ₑ[φ] Y) (a : X) :\n    (f.ofEq h) a = f a :=\n  rfl\n\n\n"}
{"name":"MulActionHom.ofEq_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\nφ' : M → N\nh : Eq φ φ'\nf : MulActionHom φ X Y\na : X\n⊢ Eq ((MulActionHom.ofEq h f) a) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem ofEq_apply {φ' : M → N} (h : φ = φ') (f : X →ₑ[φ] Y) (a : X) :\n    (f.ofEq h) a = f a :=\n  rfl\n\n\n"}
{"name":"AddActionHom.id_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nX : Type u_5\ninst✝ : VAdd M X\nx : X\n⊢ Eq ((AddActionHom.id M) x) x","decl":"@[to_additive (attr := simp)]\ntheorem id_apply (x : X) :\n    MulActionHom.id M x = x :=\n  rfl\n\n"}
{"name":"MulActionHom.id_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nX : Type u_5\ninst✝ : SMul M X\nx : X\n⊢ Eq ((MulActionHom.id M) x) x","decl":"@[to_additive (attr := simp)]\ntheorem id_apply (x : X) :\n    MulActionHom.id M x = x :=\n  rfl\n\n"}
{"name":"MulActionHom.comp_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nP : Type u_4\nφ : M → N\nψ : N → P\nχ : M → P\nX : Type u_5\ninst✝³ : SMul M X\nY : Type u_6\ninst✝² : SMul N Y\nZ : Type u_7\ninst✝¹ : SMul P Z\ng : MulActionHom ψ Y Z\nf : MulActionHom φ X Y\ninst✝ : CompTriple φ ψ χ\nx : X\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[to_additive (attr := simp)]\ntheorem comp_apply\n    (g : Y →ₑ[ψ] Z) (f : X →ₑ[φ] Y) [CompTriple φ ψ χ] (x : X) :\n    g.comp f x = g (f x) := rfl\n\n"}
{"name":"AddActionHom.comp_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nP : Type u_4\nφ : M → N\nψ : N → P\nχ : M → P\nX : Type u_5\ninst✝³ : VAdd M X\nY : Type u_6\ninst✝² : VAdd N Y\nZ : Type u_7\ninst✝¹ : VAdd P Z\ng : AddActionHom ψ Y Z\nf : AddActionHom φ X Y\ninst✝ : CompTriple φ ψ χ\nx : X\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[to_additive (attr := simp)]\ntheorem comp_apply\n    (g : Y →ₑ[ψ] Z) (f : X →ₑ[φ] Y) [CompTriple φ ψ χ] (x : X) :\n    g.comp f x = g (f x) := rfl\n\n"}
{"name":"AddActionHom.id_comp","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : VAdd M X\nY : Type u_6\ninst✝ : VAdd N Y\nf : AddActionHom φ X Y\n⊢ Eq ((AddActionHom.id N).comp f) f","decl":"@[to_additive (attr := simp)]\ntheorem id_comp (f : X →ₑ[φ] Y) :\n    (MulActionHom.id N).comp f = f :=\n  ext fun x => by rw [comp_apply, id_apply]\n\n"}
{"name":"MulActionHom.id_comp","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\nf : MulActionHom φ X Y\n⊢ Eq ((MulActionHom.id N).comp f) f","decl":"@[to_additive (attr := simp)]\ntheorem id_comp (f : X →ₑ[φ] Y) :\n    (MulActionHom.id N).comp f = f :=\n  ext fun x => by rw [comp_apply, id_apply]\n\n"}
{"name":"MulActionHom.comp_id","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\nf : MulActionHom φ X Y\n⊢ Eq (f.comp (MulActionHom.id M)) f","decl":"@[to_additive (attr := simp)]\ntheorem comp_id (f : X →ₑ[φ] Y) :\n    f.comp (MulActionHom.id M) = f :=\n  ext fun x => by rw [comp_apply, id_apply]\n\n"}
{"name":"AddActionHom.comp_id","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : VAdd M X\nY : Type u_6\ninst✝ : VAdd N Y\nf : AddActionHom φ X Y\n⊢ Eq (f.comp (AddActionHom.id M)) f","decl":"@[to_additive (attr := simp)]\ntheorem comp_id (f : X →ₑ[φ] Y) :\n    f.comp (MulActionHom.id M) = f :=\n  ext fun x => by rw [comp_apply, id_apply]\n\n"}
{"name":"AddActionHom.comp_assoc","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nP : Type u_4\nφ : M → N\nψ : N → P\nχ : M → P\nX : Type u_5\ninst✝⁷ : VAdd M X\nY : Type u_6\ninst✝⁶ : VAdd N Y\nZ : Type u_7\ninst✝⁵ : VAdd P Z\nQ : Type u_8\nT : Type u_9\ninst✝⁴ : VAdd Q T\nη : P → Q\nθ : M → Q\nζ : N → Q\nh : AddActionHom η Z T\ng : AddActionHom ψ Y Z\nf : AddActionHom φ X Y\ninst✝³ : CompTriple φ ψ χ\ninst✝² : CompTriple χ η θ\ninst✝¹ : CompTriple ψ η ζ\ninst✝ : CompTriple φ ζ θ\n⊢ Eq (h.comp (g.comp f)) ((h.comp g).comp f)","decl":"@[to_additive (attr := simp)]\ntheorem comp_assoc {Q T : Type*} [SMul Q T]\n    {η : P → Q} {θ : M → Q} {ζ : N → Q}\n    (h : Z →ₑ[η] T) (g : Y →ₑ[ψ] Z) (f : X →ₑ[φ] Y)\n    [CompTriple φ ψ χ] [CompTriple χ η θ]\n    [CompTriple ψ η ζ] [CompTriple φ ζ θ] :\n    h.comp (g.comp f) = (h.comp g).comp f :=\n  ext fun _ => rfl\n\n"}
{"name":"MulActionHom.comp_assoc","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nP : Type u_4\nφ : M → N\nψ : N → P\nχ : M → P\nX : Type u_5\ninst✝⁷ : SMul M X\nY : Type u_6\ninst✝⁶ : SMul N Y\nZ : Type u_7\ninst✝⁵ : SMul P Z\nQ : Type u_8\nT : Type u_9\ninst✝⁴ : SMul Q T\nη : P → Q\nθ : M → Q\nζ : N → Q\nh : MulActionHom η Z T\ng : MulActionHom ψ Y Z\nf : MulActionHom φ X Y\ninst✝³ : CompTriple φ ψ χ\ninst✝² : CompTriple χ η θ\ninst✝¹ : CompTriple ψ η ζ\ninst✝ : CompTriple φ ζ θ\n⊢ Eq (h.comp (g.comp f)) ((h.comp g).comp f)","decl":"@[to_additive (attr := simp)]\ntheorem comp_assoc {Q T : Type*} [SMul Q T]\n    {η : P → Q} {θ : M → Q} {ζ : N → Q}\n    (h : Z →ₑ[η] T) (g : Y →ₑ[ψ] Z) (f : X →ₑ[φ] Y)\n    [CompTriple φ ψ χ] [CompTriple χ η θ]\n    [CompTriple ψ η ζ] [CompTriple φ ζ θ] :\n    h.comp (g.comp f) = (h.comp g).comp f :=\n  ext fun _ => rfl\n\n"}
{"name":"MulActionHom.inverse_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nX : Type u_5\ninst✝¹ : SMul M X\nY₁ : Type u_8\ninst✝ : SMul M Y₁\nf : MulActionHom id X Y₁\ng : Y₁ → X\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\na✝ : Y₁\n⊢ Eq ((f.inverse g h₁ h₂) a✝) (g a✝)","decl":"/-- The inverse of a bijective equivariant map is equivariant. -/\n@[to_additive (attr := simps) \"The inverse of a bijective equivariant map is equivariant.\"]\ndef inverse (f : X →[M] Y₁) (g : Y₁ → X)\n    (h₁ : Function.LeftInverse g f) (h₂ : Function.RightInverse g f) : Y₁ →[M] X where\n  toFun := g\n  map_smul' m x :=\n    calc\n      g (m • x) = g (m • f (g x)) := by rw [h₂]\n      _ = g (f (m • g x)) := by simp only [map_smul, id_eq]\n      _ = m • g x := by rw [h₁]\n\n\n"}
{"name":"AddActionHom.inverse_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nX : Type u_5\ninst✝¹ : VAdd M X\nY₁ : Type u_8\ninst✝ : VAdd M Y₁\nf : AddActionHom id X Y₁\ng : Y₁ → X\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\na✝ : Y₁\n⊢ Eq ((f.inverse g h₁ h₂) a✝) (g a✝)","decl":"/-- The inverse of a bijective equivariant map is equivariant. -/\n@[to_additive (attr := simps) \"The inverse of a bijective equivariant map is equivariant.\"]\ndef inverse (f : X →[M] Y₁) (g : Y₁ → X)\n    (h₁ : Function.LeftInverse g f) (h₂ : Function.RightInverse g f) : Y₁ →[M] X where\n  toFun := g\n  map_smul' m x :=\n    calc\n      g (m • x) = g (m • f (g x)) := by rw [h₂]\n      _ = g (f (m • g x)) := by simp only [map_smul, id_eq]\n      _ = m • g x := by rw [h₁]\n\n\n"}
{"name":"MulActionHom.inverse'_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\nφ' : N → M\nf : MulActionHom φ X Y\ng : Y → X\nk : Function.RightInverse φ' φ\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\na✝ : Y\n⊢ Eq ((f.inverse' g k h₁ h₂) a✝) (g a✝)","decl":"/-- The inverse of a bijective equivariant map is equivariant. -/\n@[to_additive (attr := simps) \"The inverse of a bijective equivariant map is equivariant.\"]\ndef inverse' (f : X →ₑ[φ] Y) (g : Y → X) (k : Function.RightInverse φ' φ)\n    (h₁ : Function.LeftInverse g f) (h₂ : Function.RightInverse g f) :\n    Y →ₑ[φ'] X where\n  toFun := g\n  map_smul' m x :=\n    calc\n      g (m • x) = g (m • f (g x)) := by rw [h₂]\n      _ = g ((φ (φ' m)) • f (g x)) := by rw [k]\n      _ = g (f (φ' m • g x)) := by rw [map_smulₛₗ]\n      _ = φ' m • g x := by rw [h₁]\n\n"}
{"name":"AddActionHom.inverse'_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : VAdd M X\nY : Type u_6\ninst✝ : VAdd N Y\nφ' : N → M\nf : AddActionHom φ X Y\ng : Y → X\nk : Function.RightInverse φ' φ\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\na✝ : Y\n⊢ Eq ((f.inverse' g k h₁ h₂) a✝) (g a✝)","decl":"/-- The inverse of a bijective equivariant map is equivariant. -/\n@[to_additive (attr := simps) \"The inverse of a bijective equivariant map is equivariant.\"]\ndef inverse' (f : X →ₑ[φ] Y) (g : Y → X) (k : Function.RightInverse φ' φ)\n    (h₁ : Function.LeftInverse g f) (h₂ : Function.RightInverse g f) :\n    Y →ₑ[φ'] X where\n  toFun := g\n  map_smul' m x :=\n    calc\n      g (m • x) = g (m • f (g x)) := by rw [h₂]\n      _ = g ((φ (φ' m)) • f (g x)) := by rw [k]\n      _ = g (f (φ' m • g x)) := by rw [map_smulₛₗ]\n      _ = φ' m • g x := by rw [h₁]\n\n"}
{"name":"AddActionHom.inverse_eq_inverse'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nX : Type u_5\ninst✝¹ : VAdd M X\nY₁ : Type u_8\ninst✝ : VAdd M Y₁\nf : AddActionHom id X Y₁\ng : Y₁ → X\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\n⊢ Eq (f.inverse g h₁ h₂) (f.inverse' g ⋯ h₁ h₂)","decl":"@[to_additive]\nlemma inverse_eq_inverse' (f : X →[M] Y₁) (g : Y₁ → X)\n    (h₁ : Function.LeftInverse g f) (h₂ : Function.RightInverse g f) :\n  inverse f g h₁ h₂ =  inverse' f g (congrFun rfl) h₁ h₂ := by\n  rfl\n\n"}
{"name":"MulActionHom.inverse_eq_inverse'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nX : Type u_5\ninst✝¹ : SMul M X\nY₁ : Type u_8\ninst✝ : SMul M Y₁\nf : MulActionHom id X Y₁\ng : Y₁ → X\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\n⊢ Eq (f.inverse g h₁ h₂) (f.inverse' g ⋯ h₁ h₂)","decl":"@[to_additive]\nlemma inverse_eq_inverse' (f : X →[M] Y₁) (g : Y₁ → X)\n    (h₁ : Function.LeftInverse g f) (h₂ : Function.RightInverse g f) :\n  inverse f g h₁ h₂ =  inverse' f g (congrFun rfl) h₁ h₂ := by\n  rfl\n\n"}
{"name":"AddActionHom.inverse'_inverse'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : VAdd M X\nY : Type u_6\ninst✝ : VAdd N Y\nφ' : N → M\nf : AddActionHom φ X Y\ng : Y → X\nk₁ : Function.LeftInverse φ' φ\nk₂ : Function.RightInverse φ' φ\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\n⊢ Eq ((f.inverse' g k₂ h₁ h₂).inverse' (⇑f) k₁ h₂ h₁) f","decl":"@[to_additive]\ntheorem inverse'_inverse'\n    {f : X →ₑ[φ] Y} {g : Y → X}\n    {k₁ : Function.LeftInverse φ' φ} {k₂ : Function.RightInverse φ' φ}\n    {h₁ : Function.LeftInverse g f} {h₂ : Function.RightInverse g f} :\n    inverse' (inverse' f g k₂ h₁ h₂) f k₁ h₂ h₁ = f :=\n  ext fun _ => rfl\n\n"}
{"name":"MulActionHom.inverse'_inverse'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\nφ' : N → M\nf : MulActionHom φ X Y\ng : Y → X\nk₁ : Function.LeftInverse φ' φ\nk₂ : Function.RightInverse φ' φ\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\n⊢ Eq ((f.inverse' g k₂ h₁ h₂).inverse' (⇑f) k₁ h₂ h₁) f","decl":"@[to_additive]\ntheorem inverse'_inverse'\n    {f : X →ₑ[φ] Y} {g : Y → X}\n    {k₁ : Function.LeftInverse φ' φ} {k₂ : Function.RightInverse φ' φ}\n    {h₁ : Function.LeftInverse g f} {h₂ : Function.RightInverse g f} :\n    inverse' (inverse' f g k₂ h₁ h₂) f k₁ h₂ h₁ = f :=\n  ext fun _ => rfl\n\n"}
{"name":"AddActionHom.comp_inverse'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : VAdd M X\nY : Type u_6\ninst✝ : VAdd N Y\nφ' : N → M\nf : AddActionHom φ X Y\ng : Y → X\nk₁ : Function.LeftInverse φ' φ\nk₂ : Function.RightInverse φ' φ\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\n⊢ Eq ((f.inverse' g k₂ h₁ h₂).comp f) (AddActionHom.id M)","decl":"@[to_additive]\ntheorem comp_inverse' {f : X →ₑ[φ] Y} {g : Y → X}\n    {k₁ : Function.LeftInverse φ' φ} {k₂ : Function.RightInverse φ' φ}\n    {h₁ : Function.LeftInverse g f} {h₂ : Function.RightInverse g f} :\n    (inverse' f g k₂ h₁ h₂).comp f (κ := CompTriple.comp_inv k₁)\n      = MulActionHom.id M := by\n  rw [MulActionHom.ext_iff]\n  intro x\n  simp only [comp_apply, inverse_apply, id_apply]\n  exact h₁ x\n\n"}
{"name":"MulActionHom.comp_inverse'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\nφ' : N → M\nf : MulActionHom φ X Y\ng : Y → X\nk₁ : Function.LeftInverse φ' φ\nk₂ : Function.RightInverse φ' φ\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\n⊢ Eq ((f.inverse' g k₂ h₁ h₂).comp f) (MulActionHom.id M)","decl":"@[to_additive]\ntheorem comp_inverse' {f : X →ₑ[φ] Y} {g : Y → X}\n    {k₁ : Function.LeftInverse φ' φ} {k₂ : Function.RightInverse φ' φ}\n    {h₁ : Function.LeftInverse g f} {h₂ : Function.RightInverse g f} :\n    (inverse' f g k₂ h₁ h₂).comp f (κ := CompTriple.comp_inv k₁)\n      = MulActionHom.id M := by\n  rw [MulActionHom.ext_iff]\n  intro x\n  simp only [comp_apply, inverse_apply, id_apply]\n  exact h₁ x\n\n"}
{"name":"MulActionHom.inverse'_comp","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : SMul M X\nY : Type u_6\ninst✝ : SMul N Y\nφ' : N → M\nf : MulActionHom φ X Y\ng : Y → X\nk₂ : Function.RightInverse φ' φ\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\n⊢ Eq (f.comp (f.inverse' g k₂ h₁ h₂)) (MulActionHom.id N)","decl":"@[to_additive]\ntheorem inverse'_comp {f : X →ₑ[φ] Y} {g : Y → X}\n    {k₂ : Function.RightInverse φ' φ}\n    {h₁ : Function.LeftInverse g f} {h₂ : Function.RightInverse g f} :\n    f.comp (inverse' f g k₂ h₁ h₂) (κ := CompTriple.comp_inv k₂) = MulActionHom.id N := by\n  rw [MulActionHom.ext_iff]\n  intro x\n  simp only [comp_apply, inverse_apply, id_apply]\n  exact h₂ x\n\n"}
{"name":"AddActionHom.inverse'_comp","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_2\nN : Type u_3\nφ : M → N\nX : Type u_5\ninst✝¹ : VAdd M X\nY : Type u_6\ninst✝ : VAdd N Y\nφ' : N → M\nf : AddActionHom φ X Y\ng : Y → X\nk₂ : Function.RightInverse φ' φ\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\n⊢ Eq (f.comp (f.inverse' g k₂ h₁ h₂)) (AddActionHom.id N)","decl":"@[to_additive]\ntheorem inverse'_comp {f : X →ₑ[φ] Y} {g : Y → X}\n    {k₂ : Function.RightInverse φ' φ}\n    {h₁ : Function.LeftInverse g f} {h₂ : Function.RightInverse g f} :\n    f.comp (inverse' f g k₂ h₁ h₂) (κ := CompTriple.comp_inv k₂) = MulActionHom.id N := by\n  rw [MulActionHom.ext_iff]\n  intro x\n  simp only [comp_apply, inverse_apply, id_apply]\n  exact h₂ x\n\n"}
{"name":"VAddCommClass.toAddActionHom_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_11\nN : Type u_9\nα : Type u_10\ninst✝² : VAdd M α\ninst✝¹ : VAdd N α\ninst✝ : VAddCommClass M N α\nc : M\nx✝ : α\n⊢ Eq ((VAddCommClass.toAddActionHom N α c) x✝) (HVAdd.hVAdd c x✝)","decl":"/-- If actions of `M` and `N` on `α` commute,\n  then for `c : M`, `(c • · : α → α)` is an `N`-action homomorphism. -/\n@[to_additive (attr := simps) \"If additive actions of `M` and `N` on `α` commute,\n  then for `c : M`, `(c • · : α → α)` is an `N`-additive action homomorphism.\"]\ndef _root_.SMulCommClass.toMulActionHom {M} (N α : Type*)\n    [SMul M α] [SMul N α] [SMulCommClass M N α] (c : M) :\n    α →[N] α where\n  toFun := (c • ·)\n  map_smul' := smul_comm _\n\n"}
{"name":"SMulCommClass.toMulActionHom_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_11\nN : Type u_9\nα : Type u_10\ninst✝² : SMul M α\ninst✝¹ : SMul N α\ninst✝ : SMulCommClass M N α\nc : M\nx✝ : α\n⊢ Eq ((SMulCommClass.toMulActionHom N α c) x✝) (HSMul.hSMul c x✝)","decl":"/-- If actions of `M` and `N` on `α` commute,\n  then for `c : M`, `(c • · : α → α)` is an `N`-action homomorphism. -/\n@[to_additive (attr := simps) \"If additive actions of `M` and `N` on `α` commute,\n  then for `c : M`, `(c • · : α → α)` is an `N`-additive action homomorphism.\"]\ndef _root_.SMulCommClass.toMulActionHom {M} (N α : Type*)\n    [SMul M α] [SMul N α] [SMulCommClass M N α] (c : M) :\n    α →[N] α where\n  toFun := (c • ·)\n  map_smul' := smul_comm _\n\n"}
{"name":"DistribMulActionHom.mk.injEq","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\ntoMulActionHom✝ : MulActionHom (⇑φ) A B\nmap_zero'✝ : Eq (toMulActionHom✝.toFun 0) 0\nmap_add'✝ : ∀ (x y : A), Eq (toMulActionHom✝.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulActionHom✝.toFun x) (toMulActionHom✝.toFun y))\ntoMulActionHom : MulActionHom (⇑φ) A B\nmap_zero' : Eq (toMulActionHom.toFun 0) 0\nmap_add' : ∀ (x y : A), Eq (toMulActionHom.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulActionHom.toFun x) (toMulActionHom.toFun y))\n⊢ Eq (Eq { toMulActionHom := toMulActionHom✝, map_zero' := map_zero'✝, map_add' := map_add'✝ } { toMulActionHom := toMulActionHom, map_zero' := map_zero', map_add' := map_add' }) (Eq toMulActionHom✝ toMulActionHom)","decl":"/-- Equivariant additive monoid homomorphisms. -/\nstructure DistribMulActionHom extends A →ₑ[φ] B, A →+ B\n\n"}
{"name":"DistribMulActionHom.map_add'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nself : DistribMulActionHom φ A B\nx y : A\n⊢ Eq (self.toFun (HAdd.hAdd x y)) (HAdd.hAdd (self.toFun x) (self.toFun y))","decl":"/-- Equivariant additive monoid homomorphisms. -/\nstructure DistribMulActionHom extends A →ₑ[φ] B, A →+ B\n\n"}
{"name":"DistribMulActionHom.mk.inj","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\ntoMulActionHom✝ : MulActionHom (⇑φ) A B\nmap_zero'✝ : Eq (toMulActionHom✝.toFun 0) 0\nmap_add'✝ : ∀ (x y : A), Eq (toMulActionHom✝.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulActionHom✝.toFun x) (toMulActionHom✝.toFun y))\ntoMulActionHom : MulActionHom (⇑φ) A B\nmap_zero' : Eq (toMulActionHom.toFun 0) 0\nmap_add' : ∀ (x y : A), Eq (toMulActionHom.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulActionHom.toFun x) (toMulActionHom.toFun y))\nx✝ : Eq { toMulActionHom := toMulActionHom✝, map_zero' := map_zero'✝, map_add' := map_add'✝ } { toMulActionHom := toMulActionHom, map_zero' := map_zero', map_add' := map_add' }\n⊢ Eq toMulActionHom✝ toMulActionHom","decl":"/-- Equivariant additive monoid homomorphisms. -/\nstructure DistribMulActionHom extends A →ₑ[φ] B, A →+ B\n\n"}
{"name":"DistribMulActionHom.map_zero'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nself : DistribMulActionHom φ A B\n⊢ Eq (self.toFun 0) 0","decl":"/-- Equivariant additive monoid homomorphisms. -/\nstructure DistribMulActionHom extends A →ₑ[φ] B, A →+ B\n\n"}
{"name":"DistribMulActionHom.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁹ : Monoid M\nN : Type u_2\ninst✝⁸ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝⁷ : AddMonoid A\ninst✝⁶ : DistribMulAction M A\nB : Type u_5\ninst✝⁵ : AddMonoid B\ninst✝⁴ : DistribMulAction N B\ninst✝³ : SizeOf M\ninst✝² : SizeOf N\ninst✝¹ : SizeOf A\ninst✝ : SizeOf B\ntoMulActionHom : MulActionHom (⇑φ) A B\nmap_zero' : Eq (toMulActionHom.toFun 0) 0\nmap_add' : ∀ (x y : A), Eq (toMulActionHom.toFun (HAdd.hAdd x y)) (HAdd.hAdd (toMulActionHom.toFun x) (toMulActionHom.toFun y))\n⊢ Eq (SizeOf.sizeOf { toMulActionHom := toMulActionHom, map_zero' := map_zero', map_add' := map_add' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toMulActionHom)) (SizeOf.sizeOf map_zero'))","decl":"/-- Equivariant additive monoid homomorphisms. -/\nstructure DistribMulActionHom extends A →ₑ[φ] B, A →+ B\n\n"}
{"name":"DistribMulActionSemiHomClass.toAddMonoidHomClass","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"F : Type u_10\nM : outParam (Type u_11)\nN : outParam (Type u_12)\nφ : outParam (M → N)\nA : outParam (Type u_13)\nB : outParam (Type u_14)\ninst✝⁶ : Monoid M\ninst✝⁵ : Monoid N\ninst✝⁴ : AddMonoid A\ninst✝³ : AddMonoid B\ninst✝² : DistribMulAction M A\ninst✝¹ : DistribMulAction N B\ninst✝ : FunLike F A B\nself : DistribMulActionSemiHomClass F φ A B\n⊢ AddMonoidHomClass F A B","decl":"/-- `DistribMulActionSemiHomClass F φ A B` states that `F` is a type of morphisms\n  preserving the additive monoid structure and equivariant with respect to `φ`.\n    You should extend this class when you extend `DistribMulActionSemiHom`. -/\nclass DistribMulActionSemiHomClass (F : Type*)\n    {M N : outParam Type*} (φ : outParam (M → N))\n    (A B : outParam Type*)\n    [Monoid M] [Monoid N]\n    [AddMonoid A] [AddMonoid B] [DistribMulAction M A] [DistribMulAction N B]\n    [FunLike F A B]\n    extends MulActionSemiHomClass F φ A B, AddMonoidHomClass F A B : Prop\n\n"}
{"name":"DistribMulActionSemiHomClass.toMulActionSemiHomClass","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"F : Type u_10\nM : outParam (Type u_11)\nN : outParam (Type u_12)\nφ : outParam (M → N)\nA : outParam (Type u_13)\nB : outParam (Type u_14)\ninst✝⁶ : Monoid M\ninst✝⁵ : Monoid N\ninst✝⁴ : AddMonoid A\ninst✝³ : AddMonoid B\ninst✝² : DistribMulAction M A\ninst✝¹ : DistribMulAction N B\ninst✝ : FunLike F A B\nself : DistribMulActionSemiHomClass F φ A B\n⊢ MulActionSemiHomClass F φ A B","decl":"/-- `DistribMulActionSemiHomClass F φ A B` states that `F` is a type of morphisms\n  preserving the additive monoid structure and equivariant with respect to `φ`.\n    You should extend this class when you extend `DistribMulActionSemiHom`. -/\nclass DistribMulActionSemiHomClass (F : Type*)\n    {M N : outParam Type*} (φ : outParam (M → N))\n    (A B : outParam Type*)\n    [Monoid M] [Monoid N]\n    [AddMonoid A] [AddMonoid B] [DistribMulAction M A] [DistribMulAction N B]\n    [FunLike F A B]\n    extends MulActionSemiHomClass F φ A B, AddMonoidHomClass F A B : Prop\n\n"}
{"name":"DistribMulActionHom.instDistribMulActionSemiHomClassCoeMonoidHom","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\n⊢ DistribMulActionSemiHomClass (DistribMulActionHom φ A B) (⇑φ) A B","decl":"instance : DistribMulActionSemiHomClass (A →ₑ+[φ] B) φ A B where\n  map_smulₛₗ m := m.map_smul'\n  map_zero := DistribMulActionHom.map_zero'\n  map_add := DistribMulActionHom.map_add'\n\n"}
{"name":"SMulCommClass.toDistribMulActionHom_toFun","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_13\nN : Type u_11\nA : Type u_12\ninst✝⁴ : Monoid N\ninst✝³ : AddMonoid A\ninst✝² : DistribSMul M A\ninst✝¹ : DistribMulAction N A\ninst✝ : SMulCommClass M N A\nc : M\nx✝ : A\n⊢ Eq ((SMulCommClass.toDistribMulActionHom N A c) x✝) (HSMul.hSMul c x✝)","decl":"/-- If `DistribMulAction` of `M` and `N` on `A` commute,\n  then for each `c : M`, `(c • ·)` is an `N`-action additive homomorphism. -/\n@[simps]\ndef _root_.SMulCommClass.toDistribMulActionHom {M} (N A : Type*) [Monoid N] [AddMonoid A]\n    [DistribSMul M A] [DistribMulAction N A] [SMulCommClass M N A] (c : M) : A →+[N] A :=\n  { SMulCommClass.toMulActionHom N A c,\n    DistribSMul.toAddMonoidHom _ c with\n    toFun := (c • ·) }\n\n"}
{"name":"DistribMulActionHom.toFun_eq_coe","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nf : DistribMulActionHom φ A B\n⊢ Eq f.toFun ⇑f","decl":"@[simp]\ntheorem toFun_eq_coe (f : A →ₑ+[φ] B) : f.toFun = f := rfl\n\n"}
{"name":"DistribMulActionHom.coe_fn_coe","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nf : DistribMulActionHom φ A B\n⊢ Eq ⇑↑f ⇑f","decl":"@[norm_cast]\ntheorem coe_fn_coe (f : A →ₑ+[φ] B) : ⇑(f : A →+ B) = f :=\n  rfl\n\n"}
{"name":"DistribMulActionHom.coe_fn_coe'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nf : DistribMulActionHom φ A B\n⊢ Eq ⇑↑f ⇑f","decl":"@[norm_cast]\ntheorem coe_fn_coe' (f : A →ₑ+[φ] B) : ⇑(f : A →ₑ[φ] B) = f :=\n  rfl\n\n"}
{"name":"DistribMulActionHom.ext_iff","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nf g : DistribMulActionHom φ A B\n⊢ Iff (Eq f g) (∀ (x : A), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : A →ₑ+[φ] B} : (∀ x, f x = g x) → f = g :=\n  DFunLike.ext f g\n\n"}
{"name":"DistribMulActionHom.ext","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nf g : DistribMulActionHom φ A B\na✝ : ∀ (x : A), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : A →ₑ+[φ] B} : (∀ x, f x = g x) → f = g :=\n  DFunLike.ext f g\n\n"}
{"name":"DistribMulActionHom.congr_fun","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nf g : DistribMulActionHom φ A B\nh : Eq f g\nx : A\n⊢ Eq (f x) (g x)","decl":"protected theorem congr_fun {f g : A →ₑ+[φ] B} (h : f = g) (x : A) : f x = g x :=\n  DFunLike.congr_fun h _\n\n"}
{"name":"DistribMulActionHom.toMulActionHom_injective","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nf g : DistribMulActionHom φ A B\nh : Eq ↑f ↑g\n⊢ Eq f g","decl":"theorem toMulActionHom_injective {f g : A →ₑ+[φ] B} (h : (f : A →ₑ[φ] B) = (g : A →ₑ[φ] B)) :\n    f = g := by\n  ext a\n  exact MulActionHom.congr_fun h a\n\n"}
{"name":"DistribMulActionHom.toAddMonoidHom_injective","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nf g : DistribMulActionHom φ A B\nh : Eq ↑f ↑g\n⊢ Eq f g","decl":"theorem toAddMonoidHom_injective {f g : A →ₑ+[φ] B} (h : (f : A →+ B) = (g : A →+ B)) : f = g := by\n  ext a\n  exact DFunLike.congr_fun h a\n\n"}
{"name":"DistribMulActionHom.map_zero","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nf : DistribMulActionHom φ A B\n⊢ Eq (f 0) 0","decl":"protected theorem map_zero (f : A →ₑ+[φ] B) : f 0 = 0 :=\n  map_zero f\n\n"}
{"name":"DistribMulActionHom.map_add","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nf : DistribMulActionHom φ A B\nx y : A\n⊢ Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))","decl":"protected theorem map_add (f : A →ₑ+[φ] B) (x y : A) : f (x + y) = f x + f y :=\n  map_add f x y\n\n"}
{"name":"DistribMulActionHom.map_neg","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA' : Type u_8\ninst✝³ : AddGroup A'\ninst✝² : DistribMulAction M A'\nB' : Type u_9\ninst✝¹ : AddGroup B'\ninst✝ : DistribMulAction N B'\nf : DistribMulActionHom φ A' B'\nx : A'\n⊢ Eq (f (Neg.neg x)) (Neg.neg (f x))","decl":"protected theorem map_neg (f : A' →ₑ+[φ] B') (x : A') : f (-x) = -f x :=\n  map_neg f x\n\n"}
{"name":"DistribMulActionHom.map_sub","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA' : Type u_8\ninst✝³ : AddGroup A'\ninst✝² : DistribMulAction M A'\nB' : Type u_9\ninst✝¹ : AddGroup B'\ninst✝ : DistribMulAction N B'\nf : DistribMulActionHom φ A' B'\nx y : A'\n⊢ Eq (f (HSub.hSub x y)) (HSub.hSub (f x) (f y))","decl":"protected theorem map_sub (f : A' →ₑ+[φ] B') (x y : A') : f (x - y) = f x - f y :=\n  map_sub f x y\n\n"}
{"name":"DistribMulActionHom.map_smulₑ","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nf : DistribMulActionHom φ A B\nm : M\nx : A\n⊢ Eq (f (HSMul.hSMul m x)) (HSMul.hSMul (φ m) (f x))","decl":"protected theorem map_smulₑ (f : A →ₑ+[φ] B) (m : M) (x : A) : f (m • x) = (φ m) • f x :=\n  map_smulₛₗ f m x\n\n"}
{"name":"DistribMulActionHom.id_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝² : Monoid M\nA : Type u_4\ninst✝¹ : AddMonoid A\ninst✝ : DistribMulAction M A\nx : A\n⊢ Eq ((DistribMulActionHom.id M) x) x","decl":"@[simp]\ntheorem id_apply (x : A) : DistribMulActionHom.id M x = x := by\n  rfl\n\n"}
{"name":"DistribMulActionHom.coe_zero","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\n⊢ Eq (⇑0) 0","decl":"@[simp]\ntheorem coe_zero : ⇑(0 : A →ₑ+[φ] B) = 0 :=\n  rfl\n\n"}
{"name":"DistribMulActionHom.coe_one","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝² : Monoid M\nA : Type u_4\ninst✝¹ : AddMonoid A\ninst✝ : DistribMulAction M A\n⊢ Eq (⇑1) id","decl":"@[simp]\ntheorem coe_one : ⇑(1 : A →+[M] A) = id :=\n  rfl\n\n"}
{"name":"DistribMulActionHom.zero_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\na : A\n⊢ Eq (0 a) 0","decl":"theorem zero_apply (a : A) : (0 : A →ₑ+[φ] B) a = 0 :=\n  rfl\n\n"}
{"name":"DistribMulActionHom.one_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝² : Monoid M\nA : Type u_4\ninst✝¹ : AddMonoid A\ninst✝ : DistribMulAction M A\na : A\n⊢ Eq (1 a) a","decl":"theorem one_apply (a : A) : (1 : A →+[M] A) a = a :=\n  rfl\n\n"}
{"name":"DistribMulActionHom.comp_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁹ : Monoid M\nN : Type u_2\ninst✝⁸ : Monoid N\nP : Type u_3\ninst✝⁷ : Monoid P\nφ : MonoidHom M N\nψ : MonoidHom N P\nχ : MonoidHom M P\nA : Type u_4\ninst✝⁶ : AddMonoid A\ninst✝⁵ : DistribMulAction M A\nB : Type u_5\ninst✝⁴ : AddMonoid B\ninst✝³ : DistribMulAction N B\nC : Type u_7\ninst✝² : AddMonoid C\ninst✝¹ : DistribMulAction P C\ng : DistribMulActionHom ψ B C\nf : DistribMulActionHom φ A B\ninst✝ : φ.CompTriple ψ χ\nx : A\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[simp]\ntheorem comp_apply\n    (g : B →ₑ+[ψ] C) (f : A →ₑ+[φ] B) [MonoidHom.CompTriple φ ψ χ] (x : A) : g.comp f x = g (f x) :=\n  rfl\n\n"}
{"name":"DistribMulActionHom.id_comp","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nf : DistribMulActionHom φ A B\n⊢ Eq ((DistribMulActionHom.id N).comp f) f","decl":"@[simp]\ntheorem id_comp (f : A →ₑ+[φ] B) : comp (DistribMulActionHom.id N) f = f :=\n  ext fun x => by rw [comp_apply, id_apply]\n\n"}
{"name":"DistribMulActionHom.comp_id","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB : Type u_5\ninst✝¹ : AddMonoid B\ninst✝ : DistribMulAction N B\nf : DistribMulActionHom φ A B\n⊢ Eq (f.comp (DistribMulActionHom.id M)) f","decl":"@[simp]\ntheorem comp_id (f : A →ₑ+[φ] B) : f.comp (DistribMulActionHom.id M) = f :=\n  ext fun x => by rw [comp_apply, id_apply]\n\n"}
{"name":"DistribMulActionHom.comp_assoc","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝¹⁵ : Monoid M\nN : Type u_2\ninst✝¹⁴ : Monoid N\nP : Type u_3\ninst✝¹³ : Monoid P\nφ : MonoidHom M N\nψ : MonoidHom N P\nχ : MonoidHom M P\nA : Type u_4\ninst✝¹² : AddMonoid A\ninst✝¹¹ : DistribMulAction M A\nB : Type u_5\ninst✝¹⁰ : AddMonoid B\ninst✝⁹ : DistribMulAction N B\nC : Type u_7\ninst✝⁸ : AddMonoid C\ninst✝⁷ : DistribMulAction P C\nQ : Type u_11\nD : Type u_12\ninst✝⁶ : Monoid Q\ninst✝⁵ : AddMonoid D\ninst✝⁴ : DistribMulAction Q D\nη : MonoidHom P Q\nθ : MonoidHom M Q\nζ : MonoidHom N Q\nh : DistribMulActionHom η C D\ng : DistribMulActionHom ψ B C\nf : DistribMulActionHom φ A B\ninst✝³ : φ.CompTriple ψ χ\ninst✝² : χ.CompTriple η θ\ninst✝¹ : ψ.CompTriple η ζ\ninst✝ : φ.CompTriple ζ θ\n⊢ Eq (h.comp (g.comp f)) ((h.comp g).comp f)","decl":"@[simp]\ntheorem comp_assoc {Q D : Type*} [Monoid Q] [AddMonoid D] [DistribMulAction Q D]\n    {η : P →* Q} {θ : M →* Q} {ζ : N →* Q}\n    (h : C →ₑ+[η] D) (g : B →ₑ+[ψ] C) (f : A →ₑ+[φ] B)\n    [MonoidHom.CompTriple φ ψ χ] [MonoidHom.CompTriple χ η θ]\n    [MonoidHom.CompTriple ψ η ζ] [MonoidHom.CompTriple φ ζ θ] :\n    h.comp (g.comp f) = (h.comp g).comp f :=\n  ext fun _ => rfl\n\n"}
{"name":"DistribMulActionHom.inverse_toFun","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁴ : Monoid M\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : DistribMulAction M A\nB₁ : Type u_6\ninst✝¹ : AddMonoid B₁\ninst✝ : DistribMulAction M B₁\nf : DistribMulActionHom (MonoidHom.id M) A B₁\ng : B₁ → A\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\na✝ : B₁\n⊢ Eq ((f.inverse g h₁ h₂) a✝) (g a✝)","decl":"/-- The inverse of a bijective `DistribMulActionHom` is a `DistribMulActionHom`. -/\n@[simps]\ndef inverse (f : A →+[M] B₁) (g : B₁ → A) (h₁ : Function.LeftInverse g f)\n    (h₂ : Function.RightInverse g f) : B₁ →+[M] A :=\n  { (f : A →+ B₁).inverse g h₁ h₂, f.toMulActionHom.inverse g h₁ h₂ with toFun := g }\n\n"}
{"name":"DistribMulActionHom.ext_ring_iff","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"R : Type u_11\ninst✝³ : Semiring R\nS : Type u_12\ninst✝² : Semiring S\nN' : Type u_14\ninst✝¹ : AddMonoid N'\ninst✝ : DistribMulAction S N'\nσ : MonoidHom R S\nf g : DistribMulActionHom σ R N'\n⊢ Iff (Eq f g) (Eq (f 1) (g 1))","decl":"@[ext]\ntheorem ext_ring {f g : R →ₑ+[σ] N'} (h : f 1 = g 1) : f = g := by\n  ext x\n  rw [← mul_one x, ← smul_eq_mul R, f.map_smulₑ, g.map_smulₑ, h]\n\n\n"}
{"name":"DistribMulActionHom.ext_ring","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"R : Type u_11\ninst✝³ : Semiring R\nS : Type u_12\ninst✝² : Semiring S\nN' : Type u_14\ninst✝¹ : AddMonoid N'\ninst✝ : DistribMulAction S N'\nσ : MonoidHom R S\nf g : DistribMulActionHom σ R N'\nh : Eq (f 1) (g 1)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext_ring {f g : R →ₑ+[σ] N'} (h : f 1 = g 1) : f = g := by\n  ext x\n  rw [← mul_one x, ← smul_eq_mul R, f.map_smulₑ, g.map_smulₑ, h]\n\n\n"}
{"name":"MulSemiringActionHom.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁹ : Monoid M\nN : Type u_2\ninst✝⁸ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝⁷ : Semiring R\ninst✝⁶ : MulSemiringAction M R\nS : Type u_12\ninst✝⁵ : Semiring S\ninst✝⁴ : MulSemiringAction N S\ninst✝³ : SizeOf M\ninst✝² : SizeOf N\ninst✝¹ : SizeOf R\ninst✝ : SizeOf S\ntoDistribMulActionHom : DistribMulActionHom φ R S\nmap_one' : Eq (toDistribMulActionHom.toFun 1) 1\nmap_mul' : ∀ (x y : R), Eq (toDistribMulActionHom.toFun (HMul.hMul x y)) (HMul.hMul (toDistribMulActionHom.toFun x) (toDistribMulActionHom.toFun y))\n⊢ Eq (SizeOf.sizeOf { toDistribMulActionHom := toDistribMulActionHom, map_one' := map_one', map_mul' := map_mul' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toDistribMulActionHom)) (SizeOf.sizeOf map_one'))","decl":"/-- Equivariant ring homomorphisms. -/\nstructure MulSemiringActionHom extends R →ₑ+[φ] S, R →+* S\n\n/-\n/-- Equivariant ring homomorphism -/\nabbrev MulSemiringActionHom\n  (M : Type*) [Monoid M]\n  (R : Type*) [Semiring R] [MulSemiringAction M R]\n  (S : Type*) [Semiring S] [MulSemiringAction M S]:= MulSemiringActionHom (MonoidHom.id M) R S\n-/\n\n"}
{"name":"MulSemiringActionHom.mk.injEq","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\ntoDistribMulActionHom✝ : DistribMulActionHom φ R S\nmap_one'✝ : Eq (toDistribMulActionHom✝.toFun 1) 1\nmap_mul'✝ : ∀ (x y : R), Eq (toDistribMulActionHom✝.toFun (HMul.hMul x y)) (HMul.hMul (toDistribMulActionHom✝.toFun x) (toDistribMulActionHom✝.toFun y))\ntoDistribMulActionHom : DistribMulActionHom φ R S\nmap_one' : Eq (toDistribMulActionHom.toFun 1) 1\nmap_mul' : ∀ (x y : R), Eq (toDistribMulActionHom.toFun (HMul.hMul x y)) (HMul.hMul (toDistribMulActionHom.toFun x) (toDistribMulActionHom.toFun y))\n⊢ Eq (Eq { toDistribMulActionHom := toDistribMulActionHom✝, map_one' := map_one'✝, map_mul' := map_mul'✝ } { toDistribMulActionHom := toDistribMulActionHom, map_one' := map_one', map_mul' := map_mul' }) (Eq toDistribMulActionHom✝ toDistribMulActionHom)","decl":"/-- Equivariant ring homomorphisms. -/\nstructure MulSemiringActionHom extends R →ₑ+[φ] S, R →+* S\n\n/-\n/-- Equivariant ring homomorphism -/\nabbrev MulSemiringActionHom\n  (M : Type*) [Monoid M]\n  (R : Type*) [Semiring R] [MulSemiringAction M R]\n  (S : Type*) [Semiring S] [MulSemiringAction M S]:= MulSemiringActionHom (MonoidHom.id M) R S\n-/\n\n"}
{"name":"MulSemiringActionHom.map_mul'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nself : MulSemiringActionHom φ R S\nx y : R\n⊢ Eq (self.toFun (HMul.hMul x y)) (HMul.hMul (self.toFun x) (self.toFun y))","decl":"/-- Equivariant ring homomorphisms. -/\nstructure MulSemiringActionHom extends R →ₑ+[φ] S, R →+* S\n\n/-\n/-- Equivariant ring homomorphism -/\nabbrev MulSemiringActionHom\n  (M : Type*) [Monoid M]\n  (R : Type*) [Semiring R] [MulSemiringAction M R]\n  (S : Type*) [Semiring S] [MulSemiringAction M S]:= MulSemiringActionHom (MonoidHom.id M) R S\n-/\n\n"}
{"name":"MulSemiringActionHom.mk.inj","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\ntoDistribMulActionHom✝ : DistribMulActionHom φ R S\nmap_one'✝ : Eq (toDistribMulActionHom✝.toFun 1) 1\nmap_mul'✝ : ∀ (x y : R), Eq (toDistribMulActionHom✝.toFun (HMul.hMul x y)) (HMul.hMul (toDistribMulActionHom✝.toFun x) (toDistribMulActionHom✝.toFun y))\ntoDistribMulActionHom : DistribMulActionHom φ R S\nmap_one' : Eq (toDistribMulActionHom.toFun 1) 1\nmap_mul' : ∀ (x y : R), Eq (toDistribMulActionHom.toFun (HMul.hMul x y)) (HMul.hMul (toDistribMulActionHom.toFun x) (toDistribMulActionHom.toFun y))\nx✝ : Eq { toDistribMulActionHom := toDistribMulActionHom✝, map_one' := map_one'✝, map_mul' := map_mul'✝ } { toDistribMulActionHom := toDistribMulActionHom, map_one' := map_one', map_mul' := map_mul' }\n⊢ Eq toDistribMulActionHom✝ toDistribMulActionHom","decl":"/-- Equivariant ring homomorphisms. -/\nstructure MulSemiringActionHom extends R →ₑ+[φ] S, R →+* S\n\n/-\n/-- Equivariant ring homomorphism -/\nabbrev MulSemiringActionHom\n  (M : Type*) [Monoid M]\n  (R : Type*) [Semiring R] [MulSemiringAction M R]\n  (S : Type*) [Semiring S] [MulSemiringAction M S]:= MulSemiringActionHom (MonoidHom.id M) R S\n-/\n\n"}
{"name":"MulSemiringActionHom.map_one'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nself : MulSemiringActionHom φ R S\n⊢ Eq (self.toFun 1) 1","decl":"/-- Equivariant ring homomorphisms. -/\nstructure MulSemiringActionHom extends R →ₑ+[φ] S, R →+* S\n\n/-\n/-- Equivariant ring homomorphism -/\nabbrev MulSemiringActionHom\n  (M : Type*) [Monoid M]\n  (R : Type*) [Semiring R] [MulSemiringAction M R]\n  (S : Type*) [Semiring S] [MulSemiringAction M S]:= MulSemiringActionHom (MonoidHom.id M) R S\n-/\n\n"}
{"name":"MulSemiringActionSemiHomClass.toMonoidHomClass","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"F : Type u_15\nM : outParam (Type u_16)\nN : outParam (Type u_17)\ninst✝⁶ : Monoid M\ninst✝⁵ : Monoid N\nφ : outParam (M → N)\nR : outParam (Type u_18)\nS : outParam (Type u_19)\ninst✝⁴ : Semiring R\ninst✝³ : Semiring S\ninst✝² : DistribMulAction M R\ninst✝¹ : DistribMulAction N S\ninst✝ : FunLike F R S\nself : MulSemiringActionSemiHomClass F φ R S\n⊢ MonoidHomClass F R S","decl":"/-- `MulSemiringActionHomClass F φ R S` states that `F` is a type of morphisms preserving\nthe ring structure and equivariant with respect to `φ`.\n\nYou should extend this class when you extend `MulSemiringActionHom`. -/\nclass MulSemiringActionSemiHomClass (F : Type*)\n    {M N : outParam Type*} [Monoid M] [Monoid N]\n    (φ : outParam (M → N))\n    (R S : outParam Type*) [Semiring R] [Semiring S]\n    [DistribMulAction M R] [DistribMulAction N S] [FunLike F R S]\n    extends DistribMulActionSemiHomClass F φ R S, RingHomClass F R S : Prop\n\n"}
{"name":"MulSemiringActionSemiHomClass.toDistribMulActionSemiHomClass","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"F : Type u_15\nM : outParam (Type u_16)\nN : outParam (Type u_17)\ninst✝⁶ : Monoid M\ninst✝⁵ : Monoid N\nφ : outParam (M → N)\nR : outParam (Type u_18)\nS : outParam (Type u_19)\ninst✝⁴ : Semiring R\ninst✝³ : Semiring S\ninst✝² : DistribMulAction M R\ninst✝¹ : DistribMulAction N S\ninst✝ : FunLike F R S\nself : MulSemiringActionSemiHomClass F φ R S\n⊢ DistribMulActionSemiHomClass F φ R S","decl":"/-- `MulSemiringActionHomClass F φ R S` states that `F` is a type of morphisms preserving\nthe ring structure and equivariant with respect to `φ`.\n\nYou should extend this class when you extend `MulSemiringActionHom`. -/\nclass MulSemiringActionSemiHomClass (F : Type*)\n    {M N : outParam Type*} [Monoid M] [Monoid N]\n    (φ : outParam (M → N))\n    (R S : outParam Type*) [Semiring R] [Semiring S]\n    [DistribMulAction M R] [DistribMulAction N S] [FunLike F R S]\n    extends DistribMulActionSemiHomClass F φ R S, RingHomClass F R S : Prop\n\n"}
{"name":"MulSemiringActionSemiHomClass.toRingHomClass","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"F : Type u_15\nM : outParam (Type u_16)\nN : outParam (Type u_17)\ninst✝⁶ : Monoid M\ninst✝⁵ : Monoid N\nφ : outParam (M → N)\nR : outParam (Type u_18)\nS : outParam (Type u_19)\ninst✝⁴ : Semiring R\ninst✝³ : Semiring S\ninst✝² : DistribMulAction M R\ninst✝¹ : DistribMulAction N S\ninst✝ : FunLike F R S\nself : MulSemiringActionSemiHomClass F φ R S\n⊢ RingHomClass F R S","decl":"/-- `MulSemiringActionHomClass F φ R S` states that `F` is a type of morphisms preserving\nthe ring structure and equivariant with respect to `φ`.\n\nYou should extend this class when you extend `MulSemiringActionHom`. -/\nclass MulSemiringActionSemiHomClass (F : Type*)\n    {M N : outParam Type*} [Monoid M] [Monoid N]\n    (φ : outParam (M → N))\n    (R S : outParam Type*) [Semiring R] [Semiring S]\n    [DistribMulAction M R] [DistribMulAction N S] [FunLike F R S]\n    extends DistribMulActionSemiHomClass F φ R S, RingHomClass F R S : Prop\n\n"}
{"name":"MulSemiringActionHom.instMulSemiringActionSemiHomClassCoeMonoidHom","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\n⊢ MulSemiringActionSemiHomClass (MulSemiringActionHom φ R S) (⇑φ) R S","decl":"instance : MulSemiringActionSemiHomClass (R →ₑ+*[φ] S) φ R S where\n  map_zero m := m.map_zero'\n  map_add m := m.map_add'\n  map_one := MulSemiringActionHom.map_one'\n  map_mul := MulSemiringActionHom.map_mul'\n  map_smulₛₗ m := m.map_smul'\n\n"}
{"name":"MulSemiringActionHom.coe_fn_coe","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nf : MulSemiringActionHom φ R S\n⊢ Eq ⇑↑f ⇑f","decl":"@[norm_cast]\ntheorem coe_fn_coe (f : R →ₑ+*[φ] S) : ⇑(f : R →+* S) = f :=\n  rfl\n\n"}
{"name":"MulSemiringActionHom.coe_fn_coe'","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nf : MulSemiringActionHom φ R S\n⊢ Eq ⇑↑f ⇑f","decl":"@[norm_cast]\ntheorem coe_fn_coe' (f : R →ₑ+*[φ] S) : ⇑(f : R →ₑ+[φ] S) = f :=\n  rfl\n\n"}
{"name":"MulSemiringActionHom.ext_iff","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nf g : MulSemiringActionHom φ R S\n⊢ Iff (Eq f g) (∀ (x : R), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {f g : R →ₑ+*[φ] S} : (∀ x, f x = g x) → f = g :=\n  DFunLike.ext f g\n\n"}
{"name":"MulSemiringActionHom.ext","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nf g : MulSemiringActionHom φ R S\na✝ : ∀ (x : R), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : R →ₑ+*[φ] S} : (∀ x, f x = g x) → f = g :=\n  DFunLike.ext f g\n\n"}
{"name":"MulSemiringActionHom.map_zero","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nf : MulSemiringActionHom φ R S\n⊢ Eq (f 0) 0","decl":"protected theorem map_zero (f : R →ₑ+*[φ] S) : f 0 = 0 :=\n  map_zero f\n\n"}
{"name":"MulSemiringActionHom.map_add","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nf : MulSemiringActionHom φ R S\nx y : R\n⊢ Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))","decl":"protected theorem map_add (f : R →ₑ+*[φ] S) (x y : R) : f (x + y) = f x + f y :=\n  map_add f x y\n\n"}
{"name":"MulSemiringActionHom.map_neg","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR' : Type u_11\ninst✝³ : Ring R'\ninst✝² : MulSemiringAction M R'\nS' : Type u_13\ninst✝¹ : Ring S'\ninst✝ : MulSemiringAction N S'\nf : MulSemiringActionHom φ R' S'\nx : R'\n⊢ Eq (f (Neg.neg x)) (Neg.neg (f x))","decl":"protected theorem map_neg (f : R' →ₑ+*[φ] S') (x : R') : f (-x) = -f x :=\n  map_neg f x\n\n"}
{"name":"MulSemiringActionHom.map_sub","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR' : Type u_11\ninst✝³ : Ring R'\ninst✝² : MulSemiringAction M R'\nS' : Type u_13\ninst✝¹ : Ring S'\ninst✝ : MulSemiringAction N S'\nf : MulSemiringActionHom φ R' S'\nx y : R'\n⊢ Eq (f (HSub.hSub x y)) (HSub.hSub (f x) (f y))","decl":"protected theorem map_sub (f : R' →ₑ+*[φ] S') (x y : R') : f (x - y) = f x - f y :=\n  map_sub f x y\n\n"}
{"name":"MulSemiringActionHom.map_one","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nf : MulSemiringActionHom φ R S\n⊢ Eq (f 1) 1","decl":"protected theorem map_one (f : R →ₑ+*[φ] S) : f 1 = 1 :=\n  map_one f\n\n"}
{"name":"MulSemiringActionHom.map_mul","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nf : MulSemiringActionHom φ R S\nx y : R\n⊢ Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))","decl":"protected theorem map_mul (f : R →ₑ+*[φ] S) (x y : R) : f (x * y) = f x * f y :=\n  map_mul f x y\n\n"}
{"name":"MulSemiringActionHom.map_smulₛₗ","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nf : MulSemiringActionHom φ R S\nm : M\nx : R\n⊢ Eq (f (HSMul.hSMul m x)) (HSMul.hSMul (φ m) (f x))","decl":"protected theorem map_smulₛₗ (f : R →ₑ+*[φ] S) (m : M) (x : R) : f (m • x) = φ m • f x :=\n  map_smulₛₗ f m x\n\n"}
{"name":"MulSemiringActionHom.map_smul","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁴ : Monoid M\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction M S\nf : MulSemiringActionHom (MonoidHom.id M) R S\nm : M\nx : R\n⊢ Eq (f (HSMul.hSMul m x)) (HSMul.hSMul m (f x))","decl":"protected theorem map_smul [MulSemiringAction M S] (f : R →+*[M] S) (m : M) (x : R) :\n    f (m • x) = m • f x :=\n  map_smulₛₗ f m x\n\n"}
{"name":"MulSemiringActionHom.id_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝² : Monoid M\nR : Type u_10\ninst✝¹ : Semiring R\ninst✝ : MulSemiringAction M R\nx : R\n⊢ Eq ((MulSemiringActionHom.id M) x) x","decl":"@[simp]\ntheorem id_apply (x : R) : MulSemiringActionHom.id M x = x :=\n  rfl\n\n\n"}
{"name":"MulSemiringActionHom.comp_apply","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁹ : Monoid M\nN : Type u_2\ninst✝⁸ : Monoid N\nP : Type u_3\ninst✝⁷ : Monoid P\nφ : MonoidHom M N\nψ : MonoidHom N P\nχ : MonoidHom M P\nR : Type u_10\ninst✝⁶ : Semiring R\ninst✝⁵ : MulSemiringAction M R\nS : Type u_12\ninst✝⁴ : Semiring S\ninst✝³ : MulSemiringAction N S\nT : Type u_14\ninst✝² : Semiring T\ninst✝¹ : MulSemiringAction P T\ng : MulSemiringActionHom ψ S T\nf : MulSemiringActionHom φ R S\ninst✝ : φ.CompTriple ψ χ\nx : R\n⊢ Eq ((g.comp f) x) (g (f x))","decl":"@[simp]\ntheorem comp_apply (g : S →ₑ+*[ψ] T) (f : R →ₑ+*[φ] S) [MonoidHom.CompTriple φ ψ χ] (x : R) :\n    g.comp f x = g (f x) := rfl\n\n"}
{"name":"MulSemiringActionHom.id_comp","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nf : MulSemiringActionHom φ R S\n⊢ Eq ((MulSemiringActionHom.id N).comp f) f","decl":"@[simp]\ntheorem id_comp (f : R →ₑ+*[φ] S) : (MulSemiringActionHom.id N).comp f = f :=\n  ext fun x => by rw [comp_apply, id_apply]\n\n"}
{"name":"MulSemiringActionHom.comp_id","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nf : MulSemiringActionHom φ R S\n⊢ Eq (f.comp (MulSemiringActionHom.id M)) f","decl":"@[simp]\ntheorem comp_id (f : R →ₑ+*[φ] S) : f.comp (MulSemiringActionHom.id M) = f :=\n  ext fun x => by rw [comp_apply, id_apply]\n\n"}
{"name":"MulSemiringActionHom.inverse'_toFun","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁵ : Monoid M\nN : Type u_2\ninst✝⁴ : Monoid N\nφ : MonoidHom M N\nφ' : MonoidHom N M\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS : Type u_12\ninst✝¹ : Semiring S\ninst✝ : MulSemiringAction N S\nf : MulSemiringActionHom φ R S\ng : S → R\nk : Function.RightInverse ⇑φ' ⇑φ\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\na✝ : S\n⊢ Eq ((f.inverse' g k h₁ h₂) a✝) (g a✝)","decl":"/-- The inverse of a bijective `MulSemiringActionHom` is a `MulSemiringActionHom`. -/\n@[simps]\ndef inverse' (f : R →ₑ+*[φ] S) (g : S → R) (k : Function.RightInverse φ' φ)\n    (h₁ : Function.LeftInverse g f) (h₂ : Function.RightInverse g f) :\n    S →ₑ+*[φ'] R :=\n  { (f : R →+ S).inverse g h₁ h₂,\n    (f : R →* S).inverse g h₁ h₂,\n    (f : R →ₑ[φ] S).inverse' g k h₁ h₂ with\n    toFun := g }\n\n"}
{"name":"MulSemiringActionHom.inverse_toFun","module":"Mathlib.GroupTheory.GroupAction.Hom","initialProofState":"M : Type u_1\ninst✝⁴ : Monoid M\nR : Type u_10\ninst✝³ : Semiring R\ninst✝² : MulSemiringAction M R\nS₁ : Type u_15\ninst✝¹ : Semiring S₁\ninst✝ : MulSemiringAction M S₁\nf : MulSemiringActionHom (MonoidHom.id M) R S₁\ng : S₁ → R\nh₁ : Function.LeftInverse g ⇑f\nh₂ : Function.RightInverse g ⇑f\na✝ : S₁\n⊢ Eq ((f.inverse g h₁ h₂) a✝) (g a✝)","decl":"/-- The inverse of a bijective `MulSemiringActionHom` is a `MulSemiringActionHom`. -/\n@[simps]\ndef inverse {S₁ : Type*} [Semiring S₁] [MulSemiringAction M S₁]\n    (f : R →+*[M] S₁) (g : S₁ → R)\n    (h₁ : Function.LeftInverse g f) (h₂ : Function.RightInverse g f) :\n    S₁ →+*[M] R :=\n  { (f : R →+ S₁).inverse g h₁ h₂,\n    (f : R →* S₁).inverse g h₁ h₂,\n    f.toMulActionHom.inverse g h₁ h₂ with\n    toFun := g }\n\n"}
