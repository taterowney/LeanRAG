{"name":"Nucleus.mk.sizeOf_spec","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_2\ninst✝¹ : SemilatticeInf X\ninst✝ : SizeOf X\ntoInfHom : InfHom X X\nidempotent' : ∀ (x : X), LE.le (toInfHom.toFun (toInfHom.toFun x)) (toInfHom.toFun x)\nle_apply' : ∀ (x : X), LE.le x (toInfHom.toFun x)\n⊢ Eq (SizeOf.sizeOf { toInfHom := toInfHom, idempotent' := idempotent', le_apply' := le_apply' }) (HAdd.hAdd 1 (SizeOf.sizeOf toInfHom))","decl":"/-- A nucleus is an inflationary idempotent `inf`-preserving endomorphism of a semilattice.\nIn a frame, nuclei correspond to sublocales. -/ -- TODO: Formalise that claim\nstructure Nucleus (X : Type*) [SemilatticeInf X] extends InfHom X X where\n  /-- A `Nucleus` is idempotent.\n\n  Do not use this directly. Instead use `NucleusClass.idempotent`. -/\n  idempotent' (x : X) : toFun (toFun x) ≤ toFun x\n  /-- A `Nucleus` is increasing.\n\n  Do not use this directly. Instead use `NucleusClass.le_apply`. -/\n  le_apply' (x : X) : x ≤ toFun x\n\n"}
{"name":"Nucleus.mk.injEq","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_2\ninst✝ : SemilatticeInf X\ntoInfHom✝ : InfHom X X\nidempotent'✝ : ∀ (x : X), LE.le (toInfHom✝.toFun (toInfHom✝.toFun x)) (toInfHom✝.toFun x)\nle_apply'✝ : ∀ (x : X), LE.le x (toInfHom✝.toFun x)\ntoInfHom : InfHom X X\nidempotent' : ∀ (x : X), LE.le (toInfHom.toFun (toInfHom.toFun x)) (toInfHom.toFun x)\nle_apply' : ∀ (x : X), LE.le x (toInfHom.toFun x)\n⊢ Eq (Eq { toInfHom := toInfHom✝, idempotent' := idempotent'✝, le_apply' := le_apply'✝ } { toInfHom := toInfHom, idempotent' := idempotent', le_apply' := le_apply' }) (Eq toInfHom✝ toInfHom)","decl":"/-- A nucleus is an inflationary idempotent `inf`-preserving endomorphism of a semilattice.\nIn a frame, nuclei correspond to sublocales. -/ -- TODO: Formalise that claim\nstructure Nucleus (X : Type*) [SemilatticeInf X] extends InfHom X X where\n  /-- A `Nucleus` is idempotent.\n\n  Do not use this directly. Instead use `NucleusClass.idempotent`. -/\n  idempotent' (x : X) : toFun (toFun x) ≤ toFun x\n  /-- A `Nucleus` is increasing.\n\n  Do not use this directly. Instead use `NucleusClass.le_apply`. -/\n  le_apply' (x : X) : x ≤ toFun x\n\n"}
{"name":"Nucleus.mk.inj","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_2\ninst✝ : SemilatticeInf X\ntoInfHom✝ : InfHom X X\nidempotent'✝ : ∀ (x : X), LE.le (toInfHom✝.toFun (toInfHom✝.toFun x)) (toInfHom✝.toFun x)\nle_apply'✝ : ∀ (x : X), LE.le x (toInfHom✝.toFun x)\ntoInfHom : InfHom X X\nidempotent' : ∀ (x : X), LE.le (toInfHom.toFun (toInfHom.toFun x)) (toInfHom.toFun x)\nle_apply' : ∀ (x : X), LE.le x (toInfHom.toFun x)\nx✝ : Eq { toInfHom := toInfHom✝, idempotent' := idempotent'✝, le_apply' := le_apply'✝ } { toInfHom := toInfHom, idempotent' := idempotent', le_apply' := le_apply' }\n⊢ Eq toInfHom✝ toInfHom","decl":"/-- A nucleus is an inflationary idempotent `inf`-preserving endomorphism of a semilattice.\nIn a frame, nuclei correspond to sublocales. -/ -- TODO: Formalise that claim\nstructure Nucleus (X : Type*) [SemilatticeInf X] extends InfHom X X where\n  /-- A `Nucleus` is idempotent.\n\n  Do not use this directly. Instead use `NucleusClass.idempotent`. -/\n  idempotent' (x : X) : toFun (toFun x) ≤ toFun x\n  /-- A `Nucleus` is increasing.\n\n  Do not use this directly. Instead use `NucleusClass.le_apply`. -/\n  le_apply' (x : X) : x ≤ toFun x\n\n"}
{"name":"Nucleus.le_apply'","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_2\ninst✝ : SemilatticeInf X\nself : Nucleus X\nx : X\n⊢ LE.le x (self.toFun x)","decl":"/-- A nucleus is an inflationary idempotent `inf`-preserving endomorphism of a semilattice.\nIn a frame, nuclei correspond to sublocales. -/ -- TODO: Formalise that claim\nstructure Nucleus (X : Type*) [SemilatticeInf X] extends InfHom X X where\n  /-- A `Nucleus` is idempotent.\n\n  Do not use this directly. Instead use `NucleusClass.idempotent`. -/\n  idempotent' (x : X) : toFun (toFun x) ≤ toFun x\n  /-- A `Nucleus` is increasing.\n\n  Do not use this directly. Instead use `NucleusClass.le_apply`. -/\n  le_apply' (x : X) : x ≤ toFun x\n\n"}
{"name":"Nucleus.idempotent'","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_2\ninst✝ : SemilatticeInf X\nself : Nucleus X\nx : X\n⊢ LE.le (self.toFun (self.toFun x)) (self.toFun x)","decl":"/-- A nucleus is an inflationary idempotent `inf`-preserving endomorphism of a semilattice.\nIn a frame, nuclei correspond to sublocales. -/ -- TODO: Formalise that claim\nstructure Nucleus (X : Type*) [SemilatticeInf X] extends InfHom X X where\n  /-- A `Nucleus` is idempotent.\n\n  Do not use this directly. Instead use `NucleusClass.idempotent`. -/\n  idempotent' (x : X) : toFun (toFun x) ≤ toFun x\n  /-- A `Nucleus` is increasing.\n\n  Do not use this directly. Instead use `NucleusClass.le_apply`. -/\n  le_apply' (x : X) : x ≤ toFun x\n\n"}
{"name":"NucleusClass.toInfHomClass","module":"Mathlib.Order.Nucleus","initialProofState":"F : Type u_2\nX : Type u_3\ninst✝¹ : SemilatticeInf X\ninst✝ : FunLike F X X\nself : NucleusClass F X\n⊢ InfHomClass F X X","decl":"/-- `NucleusClass F X` states that F is a type of nuclei. -/\nclass NucleusClass (F X : Type*) [SemilatticeInf X] [FunLike F X X] extends InfHomClass F X X :\n    Prop where\n  /-- A nucleus is idempotent. -/\n  idempotent (x : X) (f : F) : f (f x) ≤ f x\n  /-- A nucleus is increasing. -/\n  le_apply (x : X) (f : F) : x ≤ f x\n\n"}
{"name":"NucleusClass.idempotent","module":"Mathlib.Order.Nucleus","initialProofState":"F : Type u_2\nX : Type u_3\ninst✝¹ : SemilatticeInf X\ninst✝ : FunLike F X X\nself : NucleusClass F X\nx : X\nf : F\n⊢ LE.le (f (f x)) (f x)","decl":"/-- `NucleusClass F X` states that F is a type of nuclei. -/\nclass NucleusClass (F X : Type*) [SemilatticeInf X] [FunLike F X X] extends InfHomClass F X X :\n    Prop where\n  /-- A nucleus is idempotent. -/\n  idempotent (x : X) (f : F) : f (f x) ≤ f x\n  /-- A nucleus is increasing. -/\n  le_apply (x : X) (f : F) : x ≤ f x\n\n"}
{"name":"NucleusClass.le_apply","module":"Mathlib.Order.Nucleus","initialProofState":"F : Type u_2\nX : Type u_3\ninst✝¹ : SemilatticeInf X\ninst✝ : FunLike F X X\nself : NucleusClass F X\nx : X\nf : F\n⊢ LE.le x (f x)","decl":"/-- `NucleusClass F X` states that F is a type of nuclei. -/\nclass NucleusClass (F X : Type*) [SemilatticeInf X] [FunLike F X X] extends InfHomClass F X X :\n    Prop where\n  /-- A nucleus is idempotent. -/\n  idempotent (x : X) (f : F) : f (f x) ≤ f x\n  /-- A nucleus is increasing. -/\n  le_apply (x : X) (f : F) : x ≤ f x\n\n"}
{"name":"Nucleus.toFun_eq_coe","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\nn : Nucleus X\n⊢ Eq n.toFun ⇑n","decl":"lemma toFun_eq_coe (n : Nucleus X) : n.toFun = n := rfl\n"}
{"name":"Nucleus.coe_toInfHom","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\nn : Nucleus X\n⊢ Eq ⇑n.toInfHom ⇑n","decl":"@[simp] lemma coe_toInfHom (n : Nucleus X) : ⇑n.toInfHom = n := rfl\n"}
{"name":"Nucleus.coe_mk","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\nf : InfHom X X\nh1 : ∀ (x : X), LE.le (f.toFun (f.toFun x)) (f.toFun x)\nh2 : ∀ (x : X), LE.le x (f.toFun x)\n⊢ Eq ⇑{ toInfHom := f, idempotent' := h1, le_apply' := h2 } ⇑f","decl":"@[simp] lemma coe_mk (f : InfHom X X) (h1 h2) : ⇑(mk f h1 h2) = f := rfl\n\n"}
{"name":"Nucleus.instNucleusClass","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\n⊢ NucleusClass (Nucleus X) X","decl":"instance : NucleusClass (Nucleus X) X where\n  idempotent _ _ := idempotent' ..\n  le_apply _ _ := le_apply' ..\n  map_inf _ _ _ := map_inf' ..\n\n"}
{"name":"Nucleus.idempotent","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\nn : Nucleus X\nx : X\n⊢ Eq (n (n x)) (n x)","decl":"lemma idempotent : n (n x) = n x :=\n  n.toClosureOperator.idempotent x\n\n"}
{"name":"Nucleus.le_apply","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\nn : Nucleus X\nx : X\n⊢ LE.le x (n x)","decl":"lemma le_apply : x ≤ n x :=\n  n.toClosureOperator.le_closure x\n\n"}
{"name":"Nucleus.map_inf","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\nn : Nucleus X\nx y : X\n⊢ Eq (n (Min.min x y)) (Min.min (n x) (n y))","decl":"lemma map_inf : n (x ⊓ y) = n x ⊓ n y :=\n  InfHomClass.map_inf n x y\n\n"}
{"name":"Nucleus.ext_iff","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\nm n : Nucleus X\n⊢ Iff (Eq m n) (∀ (a : X), Eq (m a) (n a))","decl":"@[ext] lemma ext {m n : Nucleus X} (h : ∀ a, m a = n a) : m = n :=\n  DFunLike.ext m n h\n\n"}
{"name":"Nucleus.ext","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\nm n : Nucleus X\nh : ∀ (a : X), Eq (m a) (n a)\n⊢ Eq m n","decl":"@[ext] lemma ext {m n : Nucleus X} (h : ∀ a, m a = n a) : m = n :=\n  DFunLike.ext m n h\n\n"}
{"name":"Nucleus.instTopHomClass","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\n⊢ TopHomClass (Nucleus X) X X","decl":"/-- A `Nucleus` preserves ⊤. -/\ninstance : TopHomClass (Nucleus X) X X where\n  map_top _ := eq_top_iff.mpr le_apply\n\n"}
{"name":"Nucleus.coe_le_coe","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\nn m : Nucleus X\n⊢ Iff (LE.le ⇑m ⇑n) (LE.le m n)","decl":"@[simp, norm_cast] lemma coe_le_coe : ⇑m ≤ n ↔ m ≤ n := .rfl\n"}
{"name":"Nucleus.coe_lt_coe","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\nn m : Nucleus X\n⊢ Iff (LT.lt ⇑m ⇑n) (LT.lt m n)","decl":"@[simp, norm_cast] lemma coe_lt_coe : ⇑m < n ↔ m < n := .rfl\n\n"}
{"name":"Nucleus.coe_bot","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\n⊢ Eq (⇑Bot.bot) id","decl":"@[simp, norm_cast] lemma coe_bot : ⇑(⊥ : Nucleus X) = id := rfl\n"}
{"name":"Nucleus.coe_top","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\n⊢ Eq (⇑Top.top) Top.top","decl":"@[simp, norm_cast] lemma coe_top : ⇑(⊤ : Nucleus X) = ⊤ := rfl\n\n"}
{"name":"Nucleus.bot_apply","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\nx : X\n⊢ Eq (Bot.bot x) x","decl":"@[simp] lemma bot_apply (x : X) : (⊥ : Nucleus X) x = x := rfl\n"}
{"name":"Nucleus.top_apply","module":"Mathlib.Order.Nucleus","initialProofState":"X : Type u_1\ninst✝ : CompleteLattice X\nx : X\n⊢ Eq (Top.top x) Top.top","decl":"@[simp] lemma top_apply (x : X) : (⊤ : Nucleus X) x = ⊤ := rfl\n\n"}
