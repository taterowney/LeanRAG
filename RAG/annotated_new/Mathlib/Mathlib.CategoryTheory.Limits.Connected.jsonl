{"name":"CategoryTheory.widePullbackShape_connected","module":"Mathlib.CategoryTheory.Limits.Connected","initialProofState":"J : Type v₁\n⊢ CategoryTheory.IsConnected (CategoryTheory.Limits.WidePullbackShape J)","decl":"instance widePullbackShape_connected (J : Type v₁) : IsConnected (WidePullbackShape J) := by\n  apply IsConnected.of_induct\n  · introv hp t\n    cases j\n    · exact hp\n    · rwa [t (WidePullbackShape.Hom.term _)]\n\n"}
{"name":"CategoryTheory.widePushoutShape_connected","module":"Mathlib.CategoryTheory.Limits.Connected","initialProofState":"J : Type v₁\n⊢ CategoryTheory.IsConnected (CategoryTheory.Limits.WidePushoutShape J)","decl":"instance widePushoutShape_connected (J : Type v₁) : IsConnected (WidePushoutShape J) := by\n  apply IsConnected.of_induct\n  · introv hp t\n    cases j\n    · exact hp\n    · rwa [← t (WidePushoutShape.Hom.init _)]\n\n"}
{"name":"CategoryTheory.parallel_pair_connected","module":"Mathlib.CategoryTheory.Limits.Connected","initialProofState":"⊢ CategoryTheory.IsConnected CategoryTheory.Limits.WalkingParallelPair","decl":"instance parallel_pair_connected : IsConnected WalkingParallelPair := by\n  apply IsConnected.of_induct\n  · introv _ t\n    cases j\n    · rwa [t WalkingParallelPairHom.left]\n    · assumption\n\n"}
{"name":"CategoryTheory.ProdPreservesConnectedLimits.γ₂_app","module":"Mathlib.CategoryTheory.Limits.Connected","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProducts C\nJ : Type v₂\ninst✝ : CategoryTheory.SmallCategory J\nK : CategoryTheory.Functor J C\nX : C\nx✝ : J\n⊢ Eq ((CategoryTheory.ProdPreservesConnectedLimits.γ₂ X).app x✝) CategoryTheory.Limits.prod.snd","decl":"/-- (Impl). The obvious natural transformation from (X × K -) to K. -/\n@[simps]\ndef γ₂ {K : J ⥤ C} (X : C) : K ⋙ prod.functor.obj X ⟶ K where app _ := Limits.prod.snd\n\n"}
{"name":"CategoryTheory.ProdPreservesConnectedLimits.γ₁_app","module":"Mathlib.CategoryTheory.Limits.Connected","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProducts C\nJ : Type v₂\ninst✝ : CategoryTheory.SmallCategory J\nK : CategoryTheory.Functor J C\nX : C\nx✝ : J\n⊢ Eq ((CategoryTheory.ProdPreservesConnectedLimits.γ₁ X).app x✝) CategoryTheory.Limits.prod.fst","decl":"/-- (Impl). The obvious natural transformation from (X × K -) to X -/\n@[simps]\ndef γ₁ {K : J ⥤ C} (X : C) : K ⋙ prod.functor.obj X ⟶ (Functor.const J).obj X where\n  app _ := Limits.prod.fst\n\n"}
{"name":"CategoryTheory.ProdPreservesConnectedLimits.forgetCone_π","module":"Mathlib.CategoryTheory.Limits.Connected","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProducts C\nJ : Type v₂\ninst✝ : CategoryTheory.SmallCategory J\nX : C\nK : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone (K.comp (CategoryTheory.Limits.prod.functor.obj X))\n⊢ Eq (CategoryTheory.ProdPreservesConnectedLimits.forgetCone s).π (CategoryTheory.CategoryStruct.comp s.π (CategoryTheory.ProdPreservesConnectedLimits.γ₂ X))","decl":"/-- (Impl).\nGiven a cone for (X × K -), produce a cone for K using the natural transformation `γ₂` -/\n@[simps]\ndef forgetCone {X : C} {K : J ⥤ C} (s : Cone (K ⋙ prod.functor.obj X)) : Cone K where\n  pt := s.pt\n  π := s.π ≫ γ₂ X\n\n"}
{"name":"CategoryTheory.ProdPreservesConnectedLimits.forgetCone_pt","module":"Mathlib.CategoryTheory.Limits.Connected","initialProofState":"C : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProducts C\nJ : Type v₂\ninst✝ : CategoryTheory.SmallCategory J\nX : C\nK : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone (K.comp (CategoryTheory.Limits.prod.functor.obj X))\n⊢ Eq (CategoryTheory.ProdPreservesConnectedLimits.forgetCone s).pt s.pt","decl":"/-- (Impl).\nGiven a cone for (X × K -), produce a cone for K using the natural transformation `γ₂` -/\n@[simps]\ndef forgetCone {X : C} {K : J ⥤ C} (s : Cone (K ⋙ prod.functor.obj X)) : Cone K where\n  pt := s.pt\n  π := s.π ≫ γ₂ X\n\n"}
{"name":"CategoryTheory.prod_preservesConnectedLimits","module":"Mathlib.CategoryTheory.Limits.Connected","initialProofState":"C : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C\ninst✝² : CategoryTheory.Limits.HasBinaryProducts C\nJ : Type v₂\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.IsConnected J\nX : C\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.Limits.prod.functor.obj X)","decl":"/-- The functor `(X × -)` preserves any connected limit.\nNote that this functor does not preserve the two most obvious disconnected limits - that is,\n`(X × -)` does not preserve products or terminal object, eg `(X ⨯ A) ⨯ (X ⨯ B)` is not isomorphic to\n`X ⨯ (A ⨯ B)` and `X ⨯ 1` is not isomorphic to `1`.\n-/\nlemma prod_preservesConnectedLimits [IsConnected J] (X : C) :\n    PreservesLimitsOfShape J (prod.functor.obj X) where\n  preservesLimit {K} :=\n    { preserves := fun {c} l => ⟨{\n          lift := fun s =>\n            prod.lift (s.π.app (Classical.arbitrary _) ≫ Limits.prod.fst) (l.lift (forgetCone s))\n          fac := fun s j => by\n            apply Limits.prod.hom_ext\n            · erw [assoc, limMap_π, comp_id, limit.lift_π]\n              exact (nat_trans_from_is_connected (s.π ≫ γ₁ X) j (Classical.arbitrary _)).symm\n            · simp [← l.fac (forgetCone s) j]\n          uniq := fun s m L => by\n            apply Limits.prod.hom_ext\n            · erw [limit.lift_π, ← L (Classical.arbitrary J), assoc, limMap_π, comp_id]\n              rfl\n            · rw [limit.lift_π]\n              apply l.uniq (forgetCone s)\n              intro j\n              simp [← L j] }⟩ }\n\n"}
