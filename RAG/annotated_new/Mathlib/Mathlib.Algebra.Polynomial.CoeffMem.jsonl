{"name":"Polynomial.coeff_divModByMonicAux_mem_span_pow_mul_span","module":"Mathlib.Algebra.Polynomial.CoeffMem","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\np q : Polynomial S\nhq : q.Monic\ni : Nat\n⊢ And (Membership.mem (HMul.hMul (HPow.hPow (Max.max 1 (Submodule.span R (Set.range q.coeff))) p.natDegree) (Max.max 1 (Submodule.span R (Set.range p.coeff)))) ((p.divModByMonicAux hq).1.coeff i)) (Membership.mem (HMul.hMul (HPow.hPow (Max.max 1 (Submodule.span R (Set.range q.coeff))) p.natDegree) (Max.max 1 (Submodule.span R (Set.range p.coeff)))) ((p.divModByMonicAux hq).2.coeff i))","decl":"open Submodule Set in\nlemma coeff_divModByMonicAux_mem_span_pow_mul_span : ∀ (p q : S[X]) (hq : q.Monic) (i),\n    (p.divModByMonicAux hq).1.coeff i ∈ spanCoeffs(q) ^ deg(p) * spanCoeffs(p) ∧\n    (p.divModByMonicAux hq).2.coeff i ∈ spanCoeffs(q) ^ deg(p) * spanCoeffs(p)\n  | p, q, hq, i => by\n    rw [divModByMonicAux]\n    have H₀ (i) : p.coeff i ∈ spanCoeffs(q) ^ deg(p) * spanCoeffs(p) := by\n      refine Submodule.mul_le_mul_left (pow_le_pow_left' le_sup_left _) ?_\n      simp only [one_pow, one_mul]\n      exact SetLike.le_def.mp le_sup_right (subset_span (mem_range_self i))\n    split_ifs with hpq; swap\n    · simpa using H₀ _\n    simp only [coeff_add, coeff_C_mul, coeff_X_pow]\n    generalize hr : (p - q * (C p.leadingCoeff * X ^ (deg(p) - deg(q)))) = r\n    by_cases hr' : r = 0\n    · simp only [mul_ite, mul_one, mul_zero, hr', divModByMonicAux, degree_zero, le_bot_iff,\n        degree_eq_bot, ne_eq, not_true_eq_false, and_false, ↓reduceDIte, Prod.mk_zero_zero,\n        Prod.fst_zero, coeff_zero, add_zero, Prod.snd_zero, Submodule.zero_mem, and_true]\n      split_ifs\n      exacts [H₀ _, zero_mem _]\n    have H : span R coeffs(r) ≤ span R coeffs(p) ⊔ span R coeffs(q) * span R coeffs(p) := by\n      rw [span_le, ← hr]\n      rintro _ ⟨i, rfl⟩\n      rw [coeff_sub, ← mul_assoc, coeff_mul_X_pow', coeff_mul_C]\n      apply sub_mem\n      · exact SetLike.le_def.mp le_sup_left (subset_span (mem_range_self _))\n      · split_ifs\n        · refine SetLike.le_def.mp le_sup_right (mul_mem_mul ?_ ?_) <;> exact subset_span ⟨_, rfl⟩\n        · exact zero_mem _\n    have deg_r_lt_deg_p : deg(r) < deg(p) := natDegree_lt_natDegree hr' (hr ▸ div_wf_lemma hpq hq)\n    have H'' := calc\n      spanCoeffs(q) ^ deg(r) * spanCoeffs(r)\n      _ ≤ spanCoeffs(q) ^ deg(r) *\n          (1 ⊔ (span R coeffs(p) ⊔ span R coeffs(q) * span R coeffs(p))) := by gcongr\n      _ ≤ spanCoeffs(q) ^ deg(r) * (spanCoeffs(q) * spanCoeffs(p)) := by\n        gcongr\n        simp only [sup_le_iff]\n        refine ⟨one_le_mul le_sup_left le_sup_left, ?_, mul_le_mul' le_sup_right le_sup_right⟩\n        rw [Submodule.sup_mul, one_mul]\n        exact le_sup_of_le_left le_sup_right\n      _ = spanCoeffs(q) ^ (deg(r) + 1) * spanCoeffs(p) := by rw [pow_succ, mul_assoc]\n      _ ≤ spanCoeffs(q) ^ deg(p) * spanCoeffs(p) := by gcongr; exacts [le_sup_left, deg_r_lt_deg_p]\n    refine ⟨add_mem ?_ ?_, ?_⟩\n    · split_ifs <;> simp only [mul_one, mul_zero]\n      exacts [H₀ _, zero_mem _]\n    · exact H'' (coeff_divModByMonicAux_mem_span_pow_mul_span r _ hq i).1\n    · exact H'' (coeff_divModByMonicAux_mem_span_pow_mul_span _ _ hq i).2\n  termination_by p => deg(p)\n\n"}
{"name":"Polynomial.coeff_modByMonic_mem_pow_natDegree_mul","module":"Mathlib.Algebra.Polynomial.CoeffMem","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\np q : Polynomial S\nMp : Submodule R S\nhp : ∀ (i : Nat), Membership.mem Mp (p.coeff i)\nhp' : Membership.mem Mp 1\nMq : Submodule R S\nhq : ∀ (i : Nat), Membership.mem Mq (q.coeff i)\nhq' : Membership.mem Mq 1\ni : Nat\n⊢ Membership.mem (HMul.hMul (HPow.hPow Mq p.natDegree) Mp) ((p.modByMonic q).coeff i)","decl":"/-- For polynomials `p q : R[X]`, the coefficients of `p %ₘ q` can be written as sums of products of\ncoefficients of `p` and `q`.\n\nPrecisely, each summand needs at most one coefficient of `p` and `deg p` coefficients of `q`. -/\nlemma coeff_modByMonic_mem_pow_natDegree_mul (p q : S[X])\n    (Mp : Submodule R S) (hp : ∀ i, p.coeff i ∈ Mp) (hp' : 1 ∈ Mp)\n    (Mq : Submodule R S) (hq : ∀ i, q.coeff i ∈ Mq) (hq' : 1 ∈ Mq) (i : ℕ) :\n    (p %ₘ q).coeff i ∈ Mq ^ p.natDegree * Mp := by\n  delta modByMonic\n  split_ifs with H\n  · refine SetLike.le_def.mp ?_ (coeff_divModByMonicAux_mem_span_pow_mul_span (R := R) p q H i).2\n    gcongr <;> exact sup_le (by simpa) (by simpa [Submodule.span_le, Set.range_subset_iff])\n  · rw [← one_mul (p.coeff i), ← one_pow p.natDegree]\n    exact Submodule.mul_mem_mul (Submodule.pow_mem_pow Mq hq' _) (hp i)\n\n"}
{"name":"Polynomial.coeff_divByMonic_mem_pow_natDegree_mul","module":"Mathlib.Algebra.Polynomial.CoeffMem","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\np q : Polynomial S\nMp : Submodule R S\nhp : ∀ (i : Nat), Membership.mem Mp (p.coeff i)\nhp' : Membership.mem Mp 1\nMq : Submodule R S\nhq : ∀ (i : Nat), Membership.mem Mq (q.coeff i)\nhq' : Membership.mem Mq 1\ni : Nat\n⊢ Membership.mem (HMul.hMul (HPow.hPow Mq p.natDegree) Mp) ((p.divByMonic q).coeff i)","decl":"/-- For polynomials `p q : R[X]`, the coefficients of `p /ₘ q` can be written as sums of products of\ncoefficients of `p` and `q`.\n\nPrecisely, each summand needs at most one coefficient of `p` and `deg p` coefficients of `q`. -/\nlemma coeff_divByMonic_mem_pow_natDegree_mul (p q : S[X])\n    (Mp : Submodule R S) (hp : ∀ i, p.coeff i ∈ Mp) (hp' : 1 ∈ Mp)\n    (Mq : Submodule R S) (hq : ∀ i, q.coeff i ∈ Mq) (hq' : 1 ∈ Mq) (i : ℕ) :\n    (p /ₘ q).coeff i ∈ Mq ^ p.natDegree * Mp := by\n  delta divByMonic\n  split_ifs with H\n  · refine SetLike.le_def.mp ?_ (coeff_divModByMonicAux_mem_span_pow_mul_span (R := R) p q H i).1\n    gcongr <;> exact sup_le (by simpa) (by simpa [Submodule.span_le, Set.range_subset_iff])\n  · simp\n\n"}
{"name":"Polynomial.idealSpan_range_update_divByMonic","module":"Mathlib.Algebra.Polynomial.CoeffMem","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝¹ : CommRing R\ninst✝ : DecidableEq ι\ni j : ι\nhij : Ne i j\nv : ι → Polynomial R\nhi : (v i).Monic\n⊢ Eq (Ideal.span (Set.range (Function.update v j ((v j).modByMonic (v i))))) (Ideal.span (Set.range v))","decl":"open Function Ideal in\nlemma idealSpan_range_update_divByMonic (hij : i ≠ j) (v : ι → R[X]) (hi : (v i).Monic) :\n    span (Set.range (Function.update v j (v j %ₘ v i))) = span (Set.range v) := by\n  rw [modByMonic_eq_sub_mul_div _ hi, mul_comm, ← smul_eq_mul, Ideal.span, Ideal.span,\n    Submodule.span_range_update_sub_smul hij]\n\n"}
