{"name":"associated_norm_prod_smith","module":"Mathlib.LinearAlgebra.FreeModule.Norm","initialProofState":"R : Type u_1\nS : Type u_2\nι : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDomain R\ninst✝⁴ : IsPrincipalIdealRing R\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra R S\ninst✝ : Fintype ι\nb : Basis ι R S\nf : S\nhf : Ne f 0\n⊢ Associated ((Algebra.norm R) f) (Finset.univ.prod fun i => Ideal.smithCoeffs b (Ideal.span (Singleton.singleton f)) ⋯ i)","decl":"/-- For a nonzero element `f` in an algebra `S` over a principal ideal domain `R` that is finite and\nfree as an `R`-module, the norm of `f` relative to `R` is associated to the product of the Smith\ncoefficients of the ideal generated by `f`. -/\ntheorem associated_norm_prod_smith [Fintype ι] (b : Basis ι R S) {f : S} (hf : f ≠ 0) :\n    Associated (Algebra.norm R f) (∏ i, smithCoeffs b _ (span_singleton_eq_bot.not.2 hf) i) := by\n  have hI := span_singleton_eq_bot.not.2 hf\n  let b' := ringBasis b (span {f}) hI\n  classical\n  rw [← Matrix.det_diagonal, ← LinearMap.det_toLin b']\n  let e :=\n    (b'.equiv ((span {f}).selfBasis b hI) <| Equiv.refl _).trans\n      ((LinearEquiv.coord S S f hf).restrictScalars R)\n  refine (LinearMap.associated_det_of_eq_comp e _ _ ?_).symm\n  dsimp only [e, LinearEquiv.trans_apply]\n  simp_rw [← LinearEquiv.coe_toLinearMap, ← LinearMap.comp_apply, ← LinearMap.ext_iff]\n  refine b'.ext fun i => ?_\n  simp_rw [LinearMap.comp_apply, LinearEquiv.coe_toLinearMap, Matrix.toLin_apply, Basis.repr_self,\n    Finsupp.single_eq_pi_single, Matrix.diagonal_mulVec_single, Pi.single_apply, ite_smul,\n    zero_smul, Finset.sum_ite_eq', mul_one, if_pos (Finset.mem_univ _), b'.equiv_apply]\n  change _ = f * _\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [mul_comm, ← smul_eq_mul, LinearEquiv.restrictScalars_apply, LinearEquiv.coord_apply_smul,\n    Ideal.selfBasis_def]\n  rfl\n\n"}
{"name":"instFiniteDimensionalQuotientPolynomialIdealSpanSingletonSetSmithCoeffs","module":"Mathlib.LinearAlgebra.FreeModule.Norm","initialProofState":"S : Type u_2\nι : Type u_3\ninst✝⁴ : CommRing S\ninst✝³ : IsDomain S\nF : Type u_4\ninst✝² : Field F\ninst✝¹ : Algebra (Polynomial F) S\ninst✝ : Finite ι\nb : Basis ι (Polynomial F) S\nI : Ideal S\nhI : Ne I Bot.bot\ni : ι\n⊢ FiniteDimensional F (HasQuotient.Quotient (Polynomial F) (Ideal.span (Singleton.singleton (Ideal.smithCoeffs b I hI i))))","decl":"instance (b : Basis ι F[X] S) {I : Ideal S} (hI : I ≠ ⊥) (i : ι) :\n    FiniteDimensional F (F[X] ⧸ span ({I.smithCoeffs b hI i} : Set F[X])) := by\n  -- Porting note: we need to do this proof in two stages otherwise it times out\n  -- original proof: (AdjoinRoot.powerBasis <| I.smithCoeffs_ne_zero b hI i).FiniteDimensional\n  -- The first tactic takes over 10 seconds, spending a lot of time in checking\n  -- that instances on the quotient commute.  My guess is that we unfold\n  -- operations to the `Quotient.lift` level and then end up comparing huge\n  -- terms.  We should probably make most of the quotient operations\n  -- irreducible so that they don't expose `Quotient.lift` accidentally.\n  refine PowerBasis.finite ?_\n  refine AdjoinRoot.powerBasis ?_\n  exact I.smithCoeffs_ne_zero b hI i\n\n"}
{"name":"finrank_quotient_span_eq_natDegree_norm","module":"Mathlib.LinearAlgebra.FreeModule.Norm","initialProofState":"S : Type u_2\nι : Type u_3\ninst✝⁶ : CommRing S\ninst✝⁵ : IsDomain S\nF : Type u_4\ninst✝⁴ : Field F\ninst✝³ : Algebra (Polynomial F) S\ninst✝² : Finite ι\ninst✝¹ : Algebra F S\ninst✝ : IsScalarTower F (Polynomial F) S\nb : Basis ι (Polynomial F) S\nf : S\nhf : Ne f 0\n⊢ Eq (Module.finrank F (HasQuotient.Quotient S (Ideal.span (Singleton.singleton f)))) ((Algebra.norm (Polynomial F)) f).natDegree","decl":"/-- For a nonzero element `f` in a `F[X]`-module `S`, the dimension of $S/\\langle f \\rangle$ as an\n`F`-vector space is the degree of the norm of `f` relative to `F[X]`. -/\ntheorem finrank_quotient_span_eq_natDegree_norm [Algebra F S] [IsScalarTower F F[X] S]\n    (b : Basis ι F[X] S) {f : S} (hf : f ≠ 0) :\n    Module.finrank F (S ⧸ span ({f} : Set S)) = (Algebra.norm F[X] f).natDegree := by\n  haveI := Fintype.ofFinite ι\n  have h := span_singleton_eq_bot.not.2 hf\n  rw [natDegree_eq_of_degree_eq\n      (degree_eq_degree_of_associated <| associated_norm_prod_smith b hf)]\n  rw [natDegree_prod _ _ fun i _ => smithCoeffs_ne_zero b _ h i, finrank_quotient_eq_sum F h b]\n  -- finrank_quotient_eq_sum slow\n  congr with i\n  exact (AdjoinRoot.powerBasis <| smithCoeffs_ne_zero b _ h i).finrank\n\n"}
