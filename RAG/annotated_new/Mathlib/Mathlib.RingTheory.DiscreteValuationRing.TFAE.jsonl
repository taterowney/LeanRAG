{"name":"exists_maximalIdeal_pow_eq_of_principal","module":"Mathlib.RingTheory.DiscreteValuationRing.TFAE","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsNoetherianRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsDomain R\nh' : Submodule.IsPrincipal (IsLocalRing.maximalIdeal R)\nI : Ideal R\nhI : Ne I Bot.bot\n⊢ Exists fun n => Eq I (HPow.hPow (IsLocalRing.maximalIdeal R) n)","decl":"theorem exists_maximalIdeal_pow_eq_of_principal [IsNoetherianRing R] [IsLocalRing R] [IsDomain R]\n    (h' : (maximalIdeal R).IsPrincipal) (I : Ideal R) (hI : I ≠ ⊥) :\n    ∃ n : ℕ, I = maximalIdeal R ^ n := by\n  by_cases h : IsField R\n  · exact ⟨0, by simp [letI := h.toField; (eq_bot_or_eq_top I).resolve_left hI]⟩\n  classical\n  obtain ⟨x, hx : _ = Ideal.span _⟩ := h'\n  by_cases hI' : I = ⊤\n  · use 0; rw [pow_zero, hI', Ideal.one_eq_top]\n  have H : ∀ r : R, ¬IsUnit r ↔ x ∣ r := fun r =>\n    (SetLike.ext_iff.mp hx r).trans Ideal.mem_span_singleton\n  have : x ≠ 0 := by\n    rintro rfl\n    apply Ring.ne_bot_of_isMaximal_of_not_isField (maximalIdeal.isMaximal R) h\n    simp [hx]\n  have hx' := IsDiscreteValuationRing.irreducible_of_span_eq_maximalIdeal x this hx\n  have H' : ∀ r : R, r ≠ 0 → r ∈ nonunits R → ∃ n : ℕ, Associated (x ^ n) r := by\n    intro r hr₁ hr₂\n    obtain ⟨f, hf₁, rfl, hf₂⟩ := (WfDvdMonoid.not_unit_iff_exists_factors_eq r hr₁).mp hr₂\n    have : ∀ b ∈ f, Associated x b := by\n      intro b hb\n      exact Irreducible.associated_of_dvd hx' (hf₁ b hb) ((H b).mp (hf₁ b hb).1)\n    clear hr₁ hr₂ hf₁\n    induction' f using Multiset.induction with fa fs fh\n    · exact (hf₂ rfl).elim\n    rcases eq_or_ne fs ∅ with (rfl | hf')\n    · use 1\n      rw [pow_one, Multiset.prod_cons, Multiset.empty_eq_zero, Multiset.prod_zero, mul_one]\n      exact this _ (Multiset.mem_cons_self _ _)\n    · obtain ⟨n, hn⟩ := fh hf' fun b hb => this _ (Multiset.mem_cons_of_mem hb)\n      use n + 1\n      rw [pow_add, Multiset.prod_cons, mul_comm, pow_one]\n      exact Associated.mul_mul (this _ (Multiset.mem_cons_self _ _)) hn\n  have : ∃ n : ℕ, x ^ n ∈ I := by\n    obtain ⟨r, hr₁, hr₂⟩ : ∃ r : R, r ∈ I ∧ r ≠ 0 := by\n      by_contra! h; apply hI; rw [eq_bot_iff]; exact h\n    obtain ⟨n, u, rfl⟩ := H' r hr₂ (le_maximalIdeal hI' hr₁)\n    use n\n    rwa [← I.unit_mul_mem_iff_mem u.isUnit, mul_comm]\n  use Nat.find this\n  apply le_antisymm\n  · change ∀ s ∈ I, s ∈ _\n    by_contra! hI''\n    obtain ⟨s, hs₁, hs₂⟩ := hI''\n    apply hs₂\n    by_cases hs₃ : s = 0; · rw [hs₃]; exact zero_mem _\n    obtain ⟨n, u, rfl⟩ := H' s hs₃ (le_maximalIdeal hI' hs₁)\n    rw [mul_comm, Ideal.unit_mul_mem_iff_mem _ u.isUnit] at hs₁ ⊢\n    apply Ideal.pow_le_pow_right (Nat.find_min' this hs₁)\n    apply Ideal.pow_mem_pow\n    exact (H _).mpr (dvd_refl _)\n  · rw [hx, Ideal.span_singleton_pow, Ideal.span_le, Set.singleton_subset_iff]\n    exact Nat.find_spec this\n\n"}
{"name":"maximalIdeal_isPrincipal_of_isDedekindDomain","module":"Mathlib.RingTheory.DiscreteValuationRing.TFAE","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsLocalRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDedekindDomain R\n⊢ Submodule.IsPrincipal (IsLocalRing.maximalIdeal R)","decl":"theorem maximalIdeal_isPrincipal_of_isDedekindDomain [IsLocalRing R] [IsDomain R]\n    [IsDedekindDomain R] : (maximalIdeal R).IsPrincipal := by\n  classical\n  by_cases ne_bot : maximalIdeal R = ⊥\n  · rw [ne_bot]; infer_instance\n  obtain ⟨a, ha₁, ha₂⟩ : ∃ a ∈ maximalIdeal R, a ≠ (0 : R) := by\n    by_contra! h'; apply ne_bot; rwa [eq_bot_iff]\n  have hle : Ideal.span {a} ≤ maximalIdeal R := by rwa [Ideal.span_le, Set.singleton_subset_iff]\n  have : (Ideal.span {a}).radical = maximalIdeal R := by\n    rw [Ideal.radical_eq_sInf]\n    apply le_antisymm\n    · exact sInf_le ⟨hle, inferInstance⟩\n    · refine\n        le_sInf fun I hI =>\n          (eq_maximalIdeal <| hI.2.isMaximal (fun e => ha₂ ?_)).ge\n      rw [← Ideal.span_singleton_eq_bot, eq_bot_iff, ← e]; exact hI.1\n  have : ∃ n, maximalIdeal R ^ n ≤ Ideal.span {a} := by\n    rw [← this]; apply Ideal.exists_radical_pow_le_of_fg; exact IsNoetherian.noetherian _\n  cases' hn : Nat.find this with n\n  · have := Nat.find_spec this\n    rw [hn, pow_zero, Ideal.one_eq_top] at this\n    exact (Ideal.IsMaximal.ne_top inferInstance (eq_top_iff.mpr <| this.trans hle)).elim\n  obtain ⟨b, hb₁, hb₂⟩ : ∃ b ∈ maximalIdeal R ^ n, ¬b ∈ Ideal.span {a} := by\n    by_contra! h'; rw [Nat.find_eq_iff] at hn; exact hn.2 n n.lt_succ_self fun x hx => h' x hx\n  have hb₃ : ∀ m ∈ maximalIdeal R, ∃ k : R, k * a = b * m := by\n    intro m hm; rw [← Ideal.mem_span_singleton']; apply Nat.find_spec this\n    rw [hn, pow_succ]; exact Ideal.mul_mem_mul hb₁ hm\n  have hb₄ : b ≠ 0 := by rintro rfl; apply hb₂; exact zero_mem _\n  let K := FractionRing R\n  let x : K := algebraMap R K b / algebraMap R K a\n  let M := Submodule.map (Algebra.linearMap R K) (maximalIdeal R)\n  have ha₃ : algebraMap R K a ≠ 0 := IsFractionRing.to_map_eq_zero_iff.not.mpr ha₂\n  by_cases hx : ∀ y ∈ M, x * y ∈ M\n  · have := isIntegral_of_smul_mem_submodule M ?_ ?_ x hx\n    · obtain ⟨y, e⟩ := IsIntegrallyClosed.algebraMap_eq_of_integral this\n      refine (hb₂ (Ideal.mem_span_singleton'.mpr ⟨y, ?_⟩)).elim\n      apply IsFractionRing.injective R K\n      rw [map_mul, e, div_mul_cancel₀ _ ha₃]\n    · rw [Submodule.ne_bot_iff]; refine ⟨_, ⟨a, ha₁, rfl⟩, ?_⟩\n      exact (IsFractionRing.to_map_eq_zero_iff (K := K)).not.mpr ha₂\n    · apply Submodule.FG.map; exact IsNoetherian.noetherian _\n  · have :\n        (M.map (DistribMulAction.toLinearMap R K x)).comap (Algebra.linearMap R K) = ⊤ := by\n      by_contra h; apply hx\n      rintro m' ⟨m, hm, rfl : algebraMap R K m = m'⟩\n      obtain ⟨k, hk⟩ := hb₃ m hm\n      have hk' : x * algebraMap R K m = algebraMap R K k := by\n        rw [← mul_div_right_comm, ← map_mul, ← hk, map_mul, mul_div_cancel_right₀ _ ha₃]\n      exact ⟨k, le_maximalIdeal h ⟨_, ⟨_, hm, rfl⟩, hk'⟩, hk'.symm⟩\n    obtain ⟨y, hy₁, hy₂⟩ : ∃ y ∈ maximalIdeal R, b * y = a := by\n      rw [Ideal.eq_top_iff_one, Submodule.mem_comap] at this\n      obtain ⟨_, ⟨y, hy, rfl⟩, hy' : x * algebraMap R K y = algebraMap R K 1⟩ := this\n      rw [map_one, ← mul_div_right_comm, div_eq_one_iff_eq ha₃, ← map_mul] at hy'\n      exact ⟨y, hy, IsFractionRing.injective R K hy'⟩\n    refine ⟨⟨y, ?_⟩⟩\n    apply le_antisymm\n    · intro m hm; obtain ⟨k, hk⟩ := hb₃ m hm; rw [← hy₂, mul_comm, mul_assoc] at hk\n      rw [← mul_left_cancel₀ hb₄ hk, mul_comm]; exact Ideal.mem_span_singleton'.mpr ⟨_, rfl⟩\n    · rwa [Submodule.span_le, Set.singleton_subset_iff]\n\n"}
{"name":"tfae_of_isNoetherianRing_of_isLocalRing_of_isDomain","module":"Mathlib.RingTheory.DiscreteValuationRing.TFAE","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsNoetherianRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsDomain R\n⊢ (List.cons (IsPrincipalIdealRing R) (List.cons (ValuationRing R) (List.cons (IsDedekindDomain R) (List.cons (And (IsIntegrallyClosed R) (∀ (P : Ideal R), Ne P Bot.bot → P.IsPrime → Eq P (IsLocalRing.maximalIdeal R))) (List.cons (Submodule.IsPrincipal (IsLocalRing.maximalIdeal R)) (List.cons (LE.le (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)) 1) (List.cons (∀ (I : Ideal R), Ne I Bot.bot → Exists fun n => Eq I (HPow.hPow (IsLocalRing.maximalIdeal R) n)) List.nil))))))).TFAE","decl":"/--\nLet `(R, m, k)` be a noetherian local domain (possibly a field).\nThe following are equivalent:\n0. `R` is a PID\n1. `R` is a valuation ring\n2. `R` is a dedekind domain\n3. `R` is integrally closed with at most one non-zero prime ideal\n4. `m` is principal\n5. `dimₖ m/m² ≤ 1`\n6. Every nonzero ideal is a power of `m`.\n\nAlso see `IsDiscreteValuationRing.TFAE` for a version assuming `¬ IsField R`.\n-/\ntheorem tfae_of_isNoetherianRing_of_isLocalRing_of_isDomain\n    [IsNoetherianRing R] [IsLocalRing R] [IsDomain R] :\n    List.TFAE\n      [IsPrincipalIdealRing R, ValuationRing R, IsDedekindDomain R,\n        IsIntegrallyClosed R ∧ ∀ P : Ideal R, P ≠ ⊥ → P.IsPrime → P = maximalIdeal R,\n        (maximalIdeal R).IsPrincipal,\n        finrank (ResidueField R) (CotangentSpace R) ≤ 1,\n        ∀ (I) (_ : I ≠ ⊥), ∃ n : ℕ, I = maximalIdeal R ^ n] := by\n  tfae_have 1 → 2 := fun _ ↦ inferInstance\n  tfae_have 2 → 1 := fun _ ↦ ((IsBezout.TFAE (R := R)).out 0 1).mp ‹_›\n  tfae_have 1 → 4\n  | H => ⟨inferInstance, fun P hP hP' ↦ eq_maximalIdeal (hP'.isMaximal hP)⟩\n  tfae_have 4 → 3 :=\n    fun ⟨h₁, h₂⟩ ↦ { h₁ with maximalOfPrime := (h₂ _ · · ▸ maximalIdeal.isMaximal R) }\n  tfae_have 3 → 5 := fun h ↦ maximalIdeal_isPrincipal_of_isDedekindDomain R\n  tfae_have 6 ↔ 5 := finrank_cotangentSpace_le_one_iff\n  tfae_have 5 → 7 := exists_maximalIdeal_pow_eq_of_principal R\n  tfae_have 7 → 2 := by\n    rw [ValuationRing.iff_ideal_total]\n    intro H\n    constructor\n    intro I J\n    -- `by_cases` should invoke `classical` by itself if it can't find a `Decidable` instance,\n    -- however the `tfae` hypotheses trigger a looping instance search.\n    -- See also:\n    -- https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/.60by_cases.60.20trying.20to.20find.20a.20weird.20instance\n    -- As a workaround, add the desired instance ourselves.\n    let _ := Classical.decEq (Ideal R)\n    by_cases hI : I = ⊥; · subst hI; left; exact bot_le\n    by_cases hJ : J = ⊥; · subst hJ; right; exact bot_le\n    obtain ⟨n, rfl⟩ := H I hI\n    obtain ⟨m, rfl⟩ := H J hJ\n    exact (le_total m n).imp Ideal.pow_le_pow_right Ideal.pow_le_pow_right\n  tfae_finish\n\n"}
{"name":"IsDiscreteValuationRing.TFAE","module":"Mathlib.RingTheory.DiscreteValuationRing.TFAE","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsNoetherianRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsDomain R\nh : Not (IsField R)\n⊢ (List.cons (IsDiscreteValuationRing R) (List.cons (ValuationRing R) (List.cons (IsDedekindDomain R) (List.cons (And (IsIntegrallyClosed R) (ExistsUnique fun P => And (Ne P Bot.bot) P.IsPrime)) (List.cons (Submodule.IsPrincipal (IsLocalRing.maximalIdeal R)) (List.cons (Eq (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)) 1) (List.cons (∀ (I : Ideal R), Ne I Bot.bot → Exists fun n => Eq I (HPow.hPow (IsLocalRing.maximalIdeal R) n)) List.nil))))))).TFAE","decl":"/--\nThe following are equivalent for a\nnoetherian local domain that is not a field `(R, m, k)`:\n0. `R` is a discrete valuation ring\n1. `R` is a valuation ring\n2. `R` is a dedekind domain\n3. `R` is integrally closed with a unique non-zero prime ideal\n4. `m` is principal\n5. `dimₖ m/m² = 1`\n6. Every nonzero ideal is a power of `m`.\n\nAlso see `tfae_of_isNoetherianRing_of_isLocalRing_of_isDomain` for a version without `¬ IsField R`.\n-/\ntheorem IsDiscreteValuationRing.TFAE [IsNoetherianRing R] [IsLocalRing R] [IsDomain R]\n    (h : ¬IsField R) :\n    List.TFAE\n      [IsDiscreteValuationRing R, ValuationRing R, IsDedekindDomain R,\n        IsIntegrallyClosed R ∧ ∃! P : Ideal R, P ≠ ⊥ ∧ P.IsPrime, (maximalIdeal R).IsPrincipal,\n        finrank (ResidueField R) (CotangentSpace R) = 1,\n        ∀ (I) (_ : I ≠ ⊥), ∃ n : ℕ, I = maximalIdeal R ^ n] := by\n  have : finrank (ResidueField R) (CotangentSpace R) = 1 ↔\n      finrank (ResidueField R) (CotangentSpace R) ≤ 1 := by\n    simp [Nat.le_one_iff_eq_zero_or_eq_one, finrank_cotangentSpace_eq_zero_iff, h]\n  rw [this]\n  have : maximalIdeal R ≠ ⊥ := isField_iff_maximalIdeal_eq.not.mp h\n  convert tfae_of_isNoetherianRing_of_isLocalRing_of_isDomain R\n  · exact ⟨fun _ ↦ inferInstance, fun h ↦ { h with not_a_field' := this }⟩\n  · exact ⟨fun h P h₁ h₂ ↦ h.unique ⟨h₁, h₂⟩ ⟨this, inferInstance⟩,\n      fun H ↦ ⟨_, ⟨this, inferInstance⟩, fun P hP ↦ H P hP.1 hP.2⟩⟩\n\n"}
{"name":"IsLocalRing.finrank_CotangentSpace_eq_one_iff","module":"Mathlib.RingTheory.DiscreteValuationRing.TFAE","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsNoetherianRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsDomain R\n⊢ Iff (Eq (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)) 1) (IsDiscreteValuationRing R)","decl":"lemma IsLocalRing.finrank_CotangentSpace_eq_one_iff [IsNoetherianRing R] [IsLocalRing R]\n    [IsDomain R] : finrank (ResidueField R) (CotangentSpace R) = 1 ↔ IsDiscreteValuationRing R := by\n  by_cases hR : IsField R\n  · letI := hR.toField\n    simp only [finrank_cotangentSpace_eq_zero, zero_ne_one, false_iff]\n    exact fun h ↦ h.3 maximalIdeal_eq_bot\n  · exact (IsDiscreteValuationRing.TFAE R hR).out 5 0\n\n"}
{"name":"LocalRing.finrank_CotangentSpace_eq_one_iff","module":"Mathlib.RingTheory.DiscreteValuationRing.TFAE","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsNoetherianRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsDomain R\n⊢ Iff (Eq (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)) 1) (IsDiscreteValuationRing R)","decl":"@[deprecated (since := \"2024-11-09\")]\nalias LocalRing.finrank_CotangentSpace_eq_one_iff := IsLocalRing.finrank_CotangentSpace_eq_one_iff\n\n"}
{"name":"IsLocalRing.finrank_CotangentSpace_eq_one","module":"Mathlib.RingTheory.DiscreteValuationRing.TFAE","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\n⊢ Eq (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)) 1","decl":"lemma IsLocalRing.finrank_CotangentSpace_eq_one [IsDomain R] [IsDiscreteValuationRing R] :\n    finrank (ResidueField R) (CotangentSpace R) = 1 :=\n  finrank_CotangentSpace_eq_one_iff.mpr ‹_›\n\n"}
{"name":"LocalRing.finrank_CotangentSpace_eq_one","module":"Mathlib.RingTheory.DiscreteValuationRing.TFAE","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\n⊢ Eq (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)) 1","decl":"@[deprecated (since := \"2024-11-09\")]\nalias LocalRing.finrank_CotangentSpace_eq_one := IsLocalRing.finrank_CotangentSpace_eq_one\n\n"}
{"name":"IsDedekindDomain.isPrincipalIdealRing","module":"Mathlib.RingTheory.DiscreteValuationRing.TFAE","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsDedekindDomain R\n⊢ IsPrincipalIdealRing R","decl":"instance (priority := 100) IsDedekindDomain.isPrincipalIdealRing\n    [IsLocalRing R] [IsDedekindDomain R] : IsPrincipalIdealRing R :=\n  ((tfae_of_isNoetherianRing_of_isLocalRing_of_isDomain R).out 2 0).mp ‹_›\n"}
