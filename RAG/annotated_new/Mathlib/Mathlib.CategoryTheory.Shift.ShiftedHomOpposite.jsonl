{"name":"CategoryTheory.ShiftedHom.opEquiv_symm_apply","module":"Mathlib.CategoryTheory.Shift.ShiftedHomOpposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX Y : C\nn : Int\nf : CategoryTheory.ShiftedHom { unop := Y } { unop := X } n\n⊢ Eq ((CategoryTheory.ShiftedHom.opEquiv n).symm f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.inv.app { unop := X }).unop ((CategoryTheory.shiftFunctor C n).map (Quiver.Hom.unop f)))","decl":"lemma opEquiv_symm_apply {n : ℤ} (f : ShiftedHom (Opposite.op Y) (Opposite.op X) n) :\n    (opEquiv n).symm f =\n      ((opShiftFunctorEquivalence C n).unitIso.inv.app (Opposite.op X)).unop ≫ f.unop⟦n⟧' := by\n  rfl\n\n"}
{"name":"CategoryTheory.ShiftedHom.opEquiv_symm_apply_comp","module":"Mathlib.CategoryTheory.Shift.ShiftedHomOpposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX Y : C\na : Int\nf : CategoryTheory.ShiftedHom { unop := X } { unop := Y } a\nb : Int\nZ : C\nz : CategoryTheory.ShiftedHom X Z b\nc : Int\nh : Eq (HAdd.hAdd b a) c\n⊢ Eq (((CategoryTheory.ShiftedHom.opEquiv a).symm f).comp z h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ShiftedHom.opEquiv a).symm (CategoryTheory.CategoryStruct.comp (Quiver.Hom.op z) f)) ((CategoryTheory.shiftFunctorAdd' C b a c h).inv.app Z))","decl":"lemma opEquiv_symm_apply_comp {X Y : C} {a : ℤ}\n    (f : ShiftedHom (Opposite.op X) (Opposite.op Y) a) {b : ℤ} {Z : C}\n    (z : ShiftedHom X Z b) {c : ℤ} (h : b + a = c) :\n    ((ShiftedHom.opEquiv a).symm f).comp z h =\n      (ShiftedHom.opEquiv a).symm (z.op ≫ f) ≫\n        (shiftFunctorAdd' C b a c h).inv.app Z := by\n  rw [ShiftedHom.opEquiv_symm_apply, ShiftedHom.opEquiv_symm_apply,\n    ShiftedHom.comp]\n  dsimp\n  simp only [assoc, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.ShiftedHom.opEquiv_symm_comp","module":"Mathlib.CategoryTheory.Shift.ShiftedHomOpposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX Y Z : C\na b : Int\nf : CategoryTheory.ShiftedHom { unop := Z } { unop := Y } a\ng : CategoryTheory.ShiftedHom { unop := Y } { unop := X } b\nc : Int\nh : Eq (HAdd.hAdd b a) c\n⊢ Eq ((CategoryTheory.ShiftedHom.opEquiv c).symm (f.comp g h)) (((CategoryTheory.ShiftedHom.opEquiv b).symm g).comp ((CategoryTheory.ShiftedHom.opEquiv a).symm f) ⋯)","decl":"lemma opEquiv_symm_comp {a b : ℤ}\n    (f : ShiftedHom (Opposite.op Z) (Opposite.op Y) a)\n    (g : ShiftedHom (Opposite.op Y) (Opposite.op X) b)\n    {c : ℤ} (h : b + a = c) :\n    (opEquiv _).symm (f.comp g h) =\n      ((opEquiv _).symm g).comp ((opEquiv _).symm f) (by omega) := by\n  rw [opEquiv_symm_apply, opEquiv_symm_apply,\n    opShiftFunctorEquivalence_unitIso_inv_app_eq _ _ _ _ (show a + b = c by omega), comp, comp]\n  dsimp\n  rw [assoc, assoc, assoc, assoc, ← Functor.map_comp, ← unop_comp_assoc,\n    Iso.inv_hom_id_app]\n  dsimp\n  rw [assoc, id_comp, Functor.map_comp, ← NatTrans.naturality_assoc,\n    ← NatTrans.naturality, opEquiv_symm_apply]\n  dsimp\n  rw [← Functor.map_comp_assoc, ← Functor.map_comp_assoc,\n    ← Functor.map_comp_assoc]\n  rw [← unop_comp_assoc]\n  erw [← NatTrans.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.ShiftedHom.opEquiv'_symm_apply","module":"Mathlib.CategoryTheory.Shift.ShiftedHomOpposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX Y : C\nn a : Int\nf : Quiver.Hom { unop := (CategoryTheory.shiftFunctor C a).obj Y } ((CategoryTheory.shiftFunctor (Opposite C) n).obj { unop := X })\na' : Int\nh : Eq (HAdd.hAdd n a) a'\n⊢ Eq ((CategoryTheory.ShiftedHom.opEquiv' n a a' h).symm f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ShiftedHom.opEquiv n).symm f) ((CategoryTheory.shiftFunctorAdd' C a n a' ⋯).inv.app Y))","decl":"lemma opEquiv'_symm_apply {n a : ℤ} (f : Opposite.op (Y⟦a⟧) ⟶ (Opposite.op X)⟦n⟧)\n    (a' : ℤ) (h : n + a = a') :\n    (opEquiv' n a a' h).symm f =\n      (opEquiv n).symm f ≫ (shiftFunctorAdd' C a n a' (by omega)).inv.app _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.ShiftedHom.opEquiv'_apply","module":"Mathlib.CategoryTheory.Shift.ShiftedHomOpposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX Y : C\na' : Int\nf : CategoryTheory.ShiftedHom X Y a'\nn a : Int\nh : Eq (HAdd.hAdd n a) a'\n⊢ Eq ((CategoryTheory.ShiftedHom.opEquiv' n a a' h) f) ((CategoryTheory.ShiftedHom.opEquiv n) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.shiftFunctorAdd' C a n a' ⋯).hom.app Y)))","decl":"lemma opEquiv'_apply {a' : ℤ} (f : ShiftedHom X Y a') (n a : ℤ) (h : n + a = a') :\n    opEquiv' n a a' h f =\n      opEquiv n (f ≫ (shiftFunctorAdd' C a n a' (by omega)).hom.app Y) := by\n  rfl\n\n"}
{"name":"CategoryTheory.ShiftedHom.opEquiv'_symm_op_opShiftFunctorEquivalence_counitIso_inv_app_op_shift","module":"Mathlib.CategoryTheory.Shift.ShiftedHomOpposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX Y Z : C\nn m : Int\nf : CategoryTheory.ShiftedHom X Y n\ng : CategoryTheory.ShiftedHom Y Z m\nq : Int\nhq : Eq (HAdd.hAdd n m) q\n⊢ Eq ((CategoryTheory.ShiftedHom.opEquiv' n m q hq).symm (CategoryTheory.CategoryStruct.comp (Quiver.Hom.op g) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.inv.app { unop := Y }) ((CategoryTheory.shiftFunctor (Opposite C) n).map (Quiver.Hom.op f))))) (f.comp g ⋯)","decl":"lemma opEquiv'_symm_op_opShiftFunctorEquivalence_counitIso_inv_app_op_shift\n    {n m : ℤ} (f : ShiftedHom X Y n) (g : ShiftedHom Y Z m)\n    (q : ℤ) (hq : n + m = q) :\n    (opEquiv' n m q hq).symm\n        (g.op ≫ (opShiftFunctorEquivalence C n).counitIso.inv.app _ ≫ f.op⟦n⟧') =\n      f.comp g (by omega) := by\n  rw [opEquiv'_symm_apply, opEquiv_symm_apply]\n  dsimp [comp]\n  apply Quiver.Hom.op_inj\n  simp only [assoc, Functor.map_comp, op_comp, Quiver.Hom.op_unop,\n    opShiftFunctorEquivalence_unitIso_inv_naturality]\n  erw [(opShiftFunctorEquivalence C n).inverse_counitInv_comp_assoc (Opposite.op Y)]\n\n"}
{"name":"CategoryTheory.ShiftedHom.opEquiv'_symm_comp","module":"Mathlib.CategoryTheory.Shift.ShiftedHomOpposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX Y Z : C\nf : Quiver.Hom Y X\nn a : Int\nx : Quiver.Hom { unop := (CategoryTheory.shiftFunctor C a).obj Z } ((CategoryTheory.shiftFunctor (Opposite C) n).obj { unop := X })\na' : Int\nh : Eq (HAdd.hAdd n a) a'\n⊢ Eq ((CategoryTheory.ShiftedHom.opEquiv' n a a' h).symm (CategoryTheory.CategoryStruct.comp x ((CategoryTheory.shiftFunctor (Opposite C) n).map f.op))) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.ShiftedHom.opEquiv' n a a' h).symm x))","decl":"lemma opEquiv'_symm_comp (f : Y ⟶ X) {n a : ℤ} (x : Opposite.op (Z⟦a⟧) ⟶ (Opposite.op X⟦n⟧))\n    (a' : ℤ) (h : n + a = a') :\n    (opEquiv' n a a' h).symm (x ≫ f.op⟦n⟧') = f ≫ (opEquiv' n a a' h).symm x :=\n  Quiver.Hom.op_inj (by simp [opEquiv'_symm_apply, opEquiv_symm_apply])\n\n"}
{"name":"CategoryTheory.ShiftedHom.opEquiv'_zero_add_symm","module":"Mathlib.CategoryTheory.Shift.ShiftedHomOpposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX Y : C\na : Int\nf : Quiver.Hom { unop := (CategoryTheory.shiftFunctor C a).obj Y } ((CategoryTheory.shiftFunctor (Opposite C) 0).obj { unop := X })\n⊢ Eq ((CategoryTheory.ShiftedHom.opEquiv' 0 a a ⋯).symm f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero (Opposite C) Int).hom.app { unop := X }).unop f.unop)","decl":"lemma opEquiv'_zero_add_symm (a : ℤ) (f : Opposite.op (Y⟦a⟧) ⟶ (Opposite.op X)⟦(0 : ℤ)⟧) :\n    (opEquiv' 0 a a (zero_add a)).symm f =\n      ((shiftFunctorZero Cᵒᵖ ℤ).hom.app _).unop ≫ f.unop := by\n  simp [opEquiv'_symm_apply, opEquiv_symm_apply, shiftFunctorAdd'_add_zero,\n    opShiftFunctorEquivalence_zero_unitIso_inv_app]\n\n"}
{"name":"CategoryTheory.ShiftedHom.opEquiv'_add_symm","module":"Mathlib.CategoryTheory.Shift.ShiftedHomOpposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.HasShift C Int\nX Y : C\nn m a a' a'' : Int\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nx : Quiver.Hom { unop := (CategoryTheory.shiftFunctor C a).obj Y } ((CategoryTheory.shiftFunctor (Opposite C) (HAdd.hAdd m n)).obj { unop := X })\n⊢ Eq ((CategoryTheory.ShiftedHom.opEquiv' (HAdd.hAdd m n) a a'' ⋯).symm x) ((CategoryTheory.ShiftedHom.opEquiv' m a' a'' ha'').symm (Quiver.Hom.op ((CategoryTheory.ShiftedHom.opEquiv' n a a' ha').symm (CategoryTheory.CategoryStruct.comp x ((CategoryTheory.shiftFunctorAdd (Opposite C) m n).hom.app { unop := X })))))","decl":"lemma opEquiv'_add_symm (n m a a' a'' : ℤ) (ha' : n + a = a') (ha'' : m + a' = a'')\n    (x : (Opposite.op (Y⟦a⟧) ⟶ (Opposite.op X)⟦m + n⟧)) :\n    (opEquiv' (m + n) a a'' (by omega)).symm x =\n      (opEquiv' m a' a'' ha'').symm ((opEquiv' n a a' ha').symm\n        (x ≫ (shiftFunctorAdd Cᵒᵖ m n).hom.app _)).op := by\n  simp only [opEquiv'_symm_apply, opEquiv_symm_apply,\n    opShiftFunctorEquivalence_unitIso_inv_app_eq _ _ _ _ (add_comm n m)]\n  dsimp\n  simp only [assoc, Functor.map_comp, ← shiftFunctorAdd'_eq_shiftFunctorAdd,\n    ← NatTrans.naturality_assoc,\n    shiftFunctorAdd'_assoc_inv_app a n m a' (m + n) a'' (by omega) (by omega) (by omega)]\n  rfl\n\n"}
{"name":"CategoryTheory.ShiftedHom.opEquiv_symm_add","module":"Mathlib.CategoryTheory.Shift.ShiftedHomOpposite","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.HasShift C Int\nX Y : C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nn : Int\nx y : CategoryTheory.ShiftedHom { unop := Y } { unop := X } n\n⊢ Eq ((CategoryTheory.ShiftedHom.opEquiv n).symm (HAdd.hAdd x y)) (HAdd.hAdd ((CategoryTheory.ShiftedHom.opEquiv n).symm x) ((CategoryTheory.ShiftedHom.opEquiv n).symm y))","decl":"@[simp]\nlemma opEquiv_symm_add {n : ℤ} (x y : ShiftedHom (Opposite.op Y) (Opposite.op X) n) :\n    (opEquiv n).symm (x + y) = (opEquiv n).symm x + (opEquiv n).symm y := by\n  dsimp [opEquiv_symm_apply]\n  rw [← Preadditive.comp_add, ← Functor.map_add]\n  rfl\n\n"}
{"name":"CategoryTheory.ShiftedHom.opEquiv'_symm_add","module":"Mathlib.CategoryTheory.Shift.ShiftedHomOpposite","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.HasShift C Int\nX Y : C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nn a : Int\nx y : Quiver.Hom { unop := (CategoryTheory.shiftFunctor C a).obj Y } ((CategoryTheory.shiftFunctor (Opposite C) n).obj { unop := X })\na' : Int\nh : Eq (HAdd.hAdd n a) a'\n⊢ Eq ((CategoryTheory.ShiftedHom.opEquiv' n a a' h).symm (HAdd.hAdd x y)) (HAdd.hAdd ((CategoryTheory.ShiftedHom.opEquiv' n a a' h).symm x) ((CategoryTheory.ShiftedHom.opEquiv' n a a' h).symm y))","decl":"@[simp]\nlemma opEquiv'_symm_add {n a : ℤ} (x y : (Opposite.op (Y⟦a⟧) ⟶ (Opposite.op X)⟦n⟧))\n    (a' : ℤ) (h : n + a = a') :\n    (opEquiv' n a a' h).symm (x + y) =\n      (opEquiv' n a a' h).symm x + (opEquiv' n a a' h).symm y := by\n  dsimp [opEquiv']\n  erw [opEquiv_symm_add, Iso.homToEquiv_apply, Iso.homToEquiv_apply, Iso.homToEquiv_apply]\n  rw [Preadditive.add_comp]\n  rfl\n\n"}
