{"name":"continuous_right_toIcoMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝³ : LinearOrderedAddCommGroup 𝕜\ninst✝² : Archimedean 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\np : 𝕜\nhp : LT.lt 0 p\na x : 𝕜\n⊢ ContinuousWithinAt (toIcoMod hp a) (Set.Ici x) x","decl":"theorem continuous_right_toIcoMod : ContinuousWithinAt (toIcoMod hp a) (Ici x) x := by\n  intro s h\n  rw [Filter.mem_map, mem_nhdsWithin_iff_exists_mem_nhds_inter]\n  haveI : Nontrivial 𝕜 := ⟨⟨0, p, hp.ne⟩⟩\n  simp_rw [mem_nhds_iff_exists_Ioo_subset] at h ⊢\n  obtain ⟨l, u, hxI, hIs⟩ := h\n  let d := toIcoDiv hp a x • p\n  have hd := toIcoMod_mem_Ico hp a x\n  simp_rw [subset_def, mem_inter_iff]\n  refine ⟨_, ⟨l + d, min (a + p) u + d, ?_, fun x => id⟩, fun y => ?_⟩ <;>\n    simp_rw [← sub_mem_Ioo_iff_left, mem_Ioo, lt_min_iff]\n  · exact ⟨hxI.1, hd.2, hxI.2⟩\n  · rintro ⟨h, h'⟩\n    apply hIs\n    rw [← toIcoMod_sub_zsmul, (toIcoMod_eq_self _).2]\n    exacts [⟨h.1, h.2.2⟩, ⟨hd.1.trans (sub_le_sub_right h' _), h.2.1⟩]\n\n"}
{"name":"continuous_left_toIocMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝³ : LinearOrderedAddCommGroup 𝕜\ninst✝² : Archimedean 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\np : 𝕜\nhp : LT.lt 0 p\na x : 𝕜\n⊢ ContinuousWithinAt (toIocMod hp a) (Set.Iic x) x","decl":"theorem continuous_left_toIocMod : ContinuousWithinAt (toIocMod hp a) (Iic x) x := by\n  rw [(funext fun y => Eq.trans (by rw [neg_neg]) <| toIocMod_neg _ _ _ :\n      toIocMod hp a = (fun x => p - x) ∘ toIcoMod hp (-a) ∘ Neg.neg)]\n  -- Porting note: added\n  have : ContinuousNeg 𝕜 := TopologicalAddGroup.toContinuousNeg\n  exact\n    (continuous_sub_left _).continuousAt.comp_continuousWithinAt <|\n      (continuous_right_toIcoMod _ _ _).comp continuous_neg.continuousWithinAt fun y => neg_le_neg\n\n"}
{"name":"toIcoMod_eventuallyEq_toIocMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝³ : LinearOrderedAddCommGroup 𝕜\ninst✝² : Archimedean 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\np : 𝕜\nhp : LT.lt 0 p\na x : 𝕜\nhx : Ne ↑x ↑a\n⊢ (nhds x).EventuallyEq (toIcoMod hp a) (toIocMod hp a)","decl":"theorem toIcoMod_eventuallyEq_toIocMod (hx : (x : 𝕜 ⧸ zmultiples p) ≠ a) :\n    toIcoMod hp a =ᶠ[𝓝 x] toIocMod hp a :=\n  IsOpen.mem_nhds\n      (by\n        rw [Ico_eq_locus_Ioc_eq_iUnion_Ioo]\n        exact isOpen_iUnion fun i => isOpen_Ioo) <|\n    (not_modEq_iff_toIcoMod_eq_toIocMod hp).1 <| not_modEq_iff_ne_mod_zmultiples.2 hx\n\n"}
{"name":"continuousAt_toIcoMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝³ : LinearOrderedAddCommGroup 𝕜\ninst✝² : Archimedean 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\np : 𝕜\nhp : LT.lt 0 p\na x : 𝕜\nhx : Ne ↑x ↑a\n⊢ ContinuousAt (toIcoMod hp a) x","decl":"theorem continuousAt_toIcoMod (hx : (x : 𝕜 ⧸ zmultiples p) ≠ a) : ContinuousAt (toIcoMod hp a) x :=\n  let h := toIcoMod_eventuallyEq_toIocMod hp a hx\n  continuousAt_iff_continuous_left_right.2 <|\n    ⟨(continuous_left_toIocMod hp a x).congr_of_eventuallyEq (h.filter_mono nhdsWithin_le_nhds)\n        h.eq_of_nhds,\n      continuous_right_toIcoMod hp a x⟩\n\n"}
{"name":"continuousAt_toIocMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝³ : LinearOrderedAddCommGroup 𝕜\ninst✝² : Archimedean 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\np : 𝕜\nhp : LT.lt 0 p\na x : 𝕜\nhx : Ne ↑x ↑a\n⊢ ContinuousAt (toIocMod hp a) x","decl":"theorem continuousAt_toIocMod (hx : (x : 𝕜 ⧸ zmultiples p) ≠ a) : ContinuousAt (toIocMod hp a) x :=\n  let h := toIcoMod_eventuallyEq_toIocMod hp a hx\n  continuousAt_iff_continuous_left_right.2 <|\n    ⟨continuous_left_toIocMod hp a x,\n      (continuous_right_toIcoMod hp a x).congr_of_eventuallyEq\n        (h.symm.filter_mono nhdsWithin_le_nhds) h.symm.eq_of_nhds⟩\n\n"}
{"name":"AddCircle.coe_nsmul","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nn : Nat\nx : 𝕜\n⊢ Eq (↑(HSMul.hSMul n x)) (HSMul.hSMul n ↑x)","decl":"theorem coe_nsmul {n : ℕ} {x : 𝕜} : (↑(n • x) : AddCircle p) = n • (x : AddCircle p) :=\n  rfl\n\n"}
{"name":"AddCircle.coe_zsmul","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nn : Int\nx : 𝕜\n⊢ Eq (↑(HSMul.hSMul n x)) (HSMul.hSMul n ↑x)","decl":"theorem coe_zsmul {n : ℤ} {x : 𝕜} : (↑(n • x) : AddCircle p) = n • (x : AddCircle p) :=\n  rfl\n\n"}
{"name":"AddCircle.coe_add","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedAddCommGroup 𝕜\np x y : 𝕜\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"theorem coe_add (x y : 𝕜) : (↑(x + y) : AddCircle p) = (x : AddCircle p) + (y : AddCircle p) :=\n  rfl\n\n"}
{"name":"AddCircle.coe_sub","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedAddCommGroup 𝕜\np x y : 𝕜\n⊢ Eq (↑(HSub.hSub x y)) (HSub.hSub ↑x ↑y)","decl":"theorem coe_sub (x y : 𝕜) : (↑(x - y) : AddCircle p) = (x : AddCircle p) - (y : AddCircle p) :=\n  rfl\n\n"}
{"name":"AddCircle.coe_neg","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedAddCommGroup 𝕜\np x : 𝕜\n⊢ Eq (↑(Neg.neg x)) (Neg.neg ↑x)","decl":"theorem coe_neg {x : 𝕜} : (↑(-x) : AddCircle p) = -(x : AddCircle p) :=\n  rfl\n\n"}
{"name":"AddCircle.coe_eq_zero_iff","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedAddCommGroup 𝕜\np x : 𝕜\n⊢ Iff (Eq (↑x) 0) (Exists fun n => Eq (HSMul.hSMul n p) x)","decl":"theorem coe_eq_zero_iff {x : 𝕜} : (x : AddCircle p) = 0 ↔ ∃ n : ℤ, n • p = x := by\n  simp [AddSubgroup.mem_zmultiples_iff]\n\n"}
{"name":"AddCircle.coe_eq_zero_of_pos_iff","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : LT.lt 0 p\nx : 𝕜\nhx : LT.lt 0 x\n⊢ Iff (Eq (↑x) 0) (Exists fun n => Eq (HSMul.hSMul n p) x)","decl":"theorem coe_eq_zero_of_pos_iff (hp : 0 < p) {x : 𝕜} (hx : 0 < x) :\n    (x : AddCircle p) = 0 ↔ ∃ n : ℕ, n • p = x := by\n  rw [coe_eq_zero_iff]\n  constructor <;> rintro ⟨n, rfl⟩\n  · replace hx : 0 < n := by\n      contrapose! hx\n      simpa only [← neg_nonneg, ← zsmul_neg, zsmul_neg'] using zsmul_nonneg hp.le (neg_nonneg.2 hx)\n    exact ⟨n.toNat, by rw [← natCast_zsmul, Int.toNat_of_nonneg hx.le]⟩\n  · exact ⟨(n : ℤ), by simp⟩\n\n"}
{"name":"AddCircle.coe_period","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\n⊢ Eq (↑p) 0","decl":"theorem coe_period : (p : AddCircle p) = 0 :=\n  (QuotientAddGroup.eq_zero_iff p).2 <| mem_zmultiples p\n\n"}
{"name":"AddCircle.coe_add_period","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedAddCommGroup 𝕜\np x : 𝕜\n⊢ Eq ↑(HAdd.hAdd x p) ↑x","decl":"theorem coe_add_period (x : 𝕜) : ((x + p : 𝕜) : AddCircle p) = x := by\n  rw [coe_add, ← eq_sub_iff_add_eq', sub_self, coe_period]\n\n"}
{"name":"AddCircle.continuous_mk'","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\ninst✝ : TopologicalSpace 𝕜\n⊢ Continuous ⇑(QuotientAddGroup.mk' (AddSubgroup.zmultiples p))","decl":"@[continuity, nolint unusedArguments]\nprotected theorem continuous_mk' [TopologicalSpace 𝕜] :\n    Continuous (QuotientAddGroup.mk' (zmultiples p) : 𝕜 → AddCircle p) :=\n  continuous_coinduced_rng\n\n"}
{"name":"AddCircle.coe_eq_coe_iff_of_mem_Ico","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝ : Archimedean 𝕜\nx y : 𝕜\nhx : Membership.mem (Set.Ico a (HAdd.hAdd a p)) x\nhy : Membership.mem (Set.Ico a (HAdd.hAdd a p)) y\n⊢ Iff (Eq ↑x ↑y) (Eq x y)","decl":"theorem coe_eq_coe_iff_of_mem_Ico {x y : 𝕜} (hx : x ∈ Ico a (a + p)) (hy : y ∈ Ico a (a + p)) :\n    (x : AddCircle p) = y ↔ x = y := by\n  refine ⟨fun h => ?_, by tauto⟩\n  suffices (⟨x, hx⟩ : Ico a (a + p)) = ⟨y, hy⟩ by exact Subtype.mk.inj this\n  apply_fun equivIco p a at h\n  rw [← (equivIco p a).right_inv ⟨x, hx⟩, ← (equivIco p a).right_inv ⟨y, hy⟩]\n  exact h\n\n"}
{"name":"AddCircle.liftIco_coe_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\nB : Type u_2\ninst✝¹ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝ : Archimedean 𝕜\nf : 𝕜 → B\nx : 𝕜\nhx : Membership.mem (Set.Ico a (HAdd.hAdd a p)) x\n⊢ Eq (AddCircle.liftIco p a f ↑x) (f x)","decl":"theorem liftIco_coe_apply {f : 𝕜 → B} {x : 𝕜} (hx : x ∈ Ico a (a + p)) :\n    liftIco p a f ↑x = f x := by\n  have : (equivIco p a) x = ⟨x, hx⟩ := by\n    rw [Equiv.apply_eq_iff_eq_symm_apply]\n    rfl\n  rw [liftIco, comp_apply, this]\n  rfl\n\n"}
{"name":"AddCircle.liftIoc_coe_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\nB : Type u_2\ninst✝¹ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝ : Archimedean 𝕜\nf : 𝕜 → B\nx : 𝕜\nhx : Membership.mem (Set.Ioc a (HAdd.hAdd a p)) x\n⊢ Eq (AddCircle.liftIoc p a f ↑x) (f x)","decl":"theorem liftIoc_coe_apply {f : 𝕜 → B} {x : 𝕜} (hx : x ∈ Ioc a (a + p)) :\n    liftIoc p a f ↑x = f x := by\n  have : (equivIoc p a) x = ⟨x, hx⟩ := by\n    rw [Equiv.apply_eq_iff_eq_symm_apply]\n    rfl\n  rw [liftIoc, comp_apply, this]\n  rfl\n\n"}
{"name":"AddCircle.eq_coe_Ico","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\ninst✝ : Archimedean 𝕜\na : AddCircle p\n⊢ Exists fun b => And (Membership.mem (Set.Ico 0 p) b) (Eq (↑b) a)","decl":"lemma eq_coe_Ico (a : AddCircle p) : ∃ b, b ∈ Ico 0 p ∧ ↑b = a := by\n  let b := QuotientAddGroup.equivIcoMod hp.out 0 a\n  exact ⟨b.1, by simpa only [zero_add] using b.2,\n    (QuotientAddGroup.equivIcoMod hp.out 0).symm_apply_apply a⟩\n\n"}
{"name":"AddCircle.coe_eq_zero_iff_of_mem_Ico","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝ : Archimedean 𝕜\nha : Membership.mem (Set.Ico 0 p) a\n⊢ Iff (Eq (↑a) 0) (Eq a 0)","decl":"lemma coe_eq_zero_iff_of_mem_Ico (ha : a ∈ Ico 0 p) :\n    (a : AddCircle p) = 0 ↔ a = 0 := by\n  have h0 : 0 ∈ Ico 0 (0 + p) := by simpa [zero_add, left_mem_Ico] using hp.out\n  have ha' : a ∈ Ico 0 (0 + p) := by rwa [zero_add]\n  rw [← AddCircle.coe_eq_coe_iff_of_mem_Ico ha' h0, QuotientAddGroup.mk_zero]\n\n"}
{"name":"AddCircle.continuous_equivIco_symm","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝¹ : Archimedean 𝕜\ninst✝ : TopologicalSpace 𝕜\n⊢ Continuous ⇑(AddCircle.equivIco p a).symm","decl":"@[continuity]\ntheorem continuous_equivIco_symm : Continuous (equivIco p a).symm :=\n  continuous_quotient_mk'.comp continuous_subtype_val\n\n"}
{"name":"AddCircle.continuous_equivIoc_symm","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝¹ : Archimedean 𝕜\ninst✝ : TopologicalSpace 𝕜\n⊢ Continuous ⇑(AddCircle.equivIoc p a).symm","decl":"@[continuity]\ntheorem continuous_equivIoc_symm : Continuous (equivIoc p a).symm :=\n  continuous_quotient_mk'.comp continuous_subtype_val\n\n"}
{"name":"AddCircle.continuousAt_equivIco","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝³ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝² : Archimedean 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nx : AddCircle p\nhx : Ne x ↑a\n⊢ ContinuousAt (⇑(AddCircle.equivIco p a)) x","decl":"theorem continuousAt_equivIco (hx : x ≠ a) : ContinuousAt (equivIco p a) x := by\n  induction x using QuotientAddGroup.induction_on\n  rw [ContinuousAt, Filter.Tendsto, QuotientAddGroup.nhds_eq, Filter.map_map]\n  exact (continuousAt_toIcoMod hp.out a hx).codRestrict _\n\n"}
{"name":"AddCircle.continuousAt_equivIoc","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝³ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝² : Archimedean 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nx : AddCircle p\nhx : Ne x ↑a\n⊢ ContinuousAt (⇑(AddCircle.equivIoc p a)) x","decl":"theorem continuousAt_equivIoc (hx : x ≠ a) : ContinuousAt (equivIoc p a) x := by\n  induction x using QuotientAddGroup.induction_on\n  rw [ContinuousAt, Filter.Tendsto, QuotientAddGroup.nhds_eq, Filter.map_map]\n  exact (continuousAt_toIocMod hp.out a hx).codRestrict _\n\n"}
{"name":"AddCircle.partialHomeomorphCoe_source","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝³ : Archimedean 𝕜\ninst✝² : TopologicalSpace 𝕜\ninst✝¹ : OrderTopology 𝕜\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem (AddSubgroup.zmultiples p) x)\n⊢ Eq (AddCircle.partialHomeomorphCoe p a).source (Set.Ioo a (HAdd.hAdd a p))","decl":"/-- The quotient map `𝕜 → AddCircle p` as a partial homeomorphism. -/\n@[simps] def partialHomeomorphCoe [DiscreteTopology (zmultiples p)] :\n    PartialHomeomorph 𝕜 (AddCircle p) where\n  toFun := (↑)\n  invFun := fun x ↦ equivIco p a x\n  source := Ioo a (a + p)\n  target := {↑a}ᶜ\n  map_source' := by\n    intro x hx hx'\n    exact hx.1.ne' ((coe_eq_coe_iff_of_mem_Ico (Ioo_subset_Ico_self hx)\n      (left_mem_Ico.mpr (lt_add_of_pos_right a hp.out))).mp hx')\n  map_target' := by\n    intro x hx\n    exact (eq_left_or_mem_Ioo_of_mem_Ico (equivIco p a x).2).resolve_left\n      (hx ∘ ((equivIco p a).symm_apply_apply x).symm.trans ∘ congrArg _)\n  left_inv' :=\n    fun x hx ↦ congrArg _ ((equivIco p a).apply_symm_apply ⟨x, Ioo_subset_Ico_self hx⟩)\n  right_inv' := fun x _ ↦ (equivIco p a).symm_apply_apply x\n  open_source := isOpen_Ioo\n  open_target := isOpen_compl_singleton\n  continuousOn_toFun := (AddCircle.continuous_mk' p).continuousOn\n  continuousOn_invFun := by\n    exact continuousOn_of_forall_continuousAt\n      (fun _ ↦ continuousAt_subtype_val.comp ∘ continuousAt_equivIco p a)\n\n"}
{"name":"AddCircle.partialHomeomorphCoe_symm_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝³ : Archimedean 𝕜\ninst✝² : TopologicalSpace 𝕜\ninst✝¹ : OrderTopology 𝕜\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem (AddSubgroup.zmultiples p) x)\nx : AddCircle p\n⊢ Eq (↑(AddCircle.partialHomeomorphCoe p a).symm x) ↑((AddCircle.equivIco p a) x)","decl":"/-- The quotient map `𝕜 → AddCircle p` as a partial homeomorphism. -/\n@[simps] def partialHomeomorphCoe [DiscreteTopology (zmultiples p)] :\n    PartialHomeomorph 𝕜 (AddCircle p) where\n  toFun := (↑)\n  invFun := fun x ↦ equivIco p a x\n  source := Ioo a (a + p)\n  target := {↑a}ᶜ\n  map_source' := by\n    intro x hx hx'\n    exact hx.1.ne' ((coe_eq_coe_iff_of_mem_Ico (Ioo_subset_Ico_self hx)\n      (left_mem_Ico.mpr (lt_add_of_pos_right a hp.out))).mp hx')\n  map_target' := by\n    intro x hx\n    exact (eq_left_or_mem_Ioo_of_mem_Ico (equivIco p a x).2).resolve_left\n      (hx ∘ ((equivIco p a).symm_apply_apply x).symm.trans ∘ congrArg _)\n  left_inv' :=\n    fun x hx ↦ congrArg _ ((equivIco p a).apply_symm_apply ⟨x, Ioo_subset_Ico_self hx⟩)\n  right_inv' := fun x _ ↦ (equivIco p a).symm_apply_apply x\n  open_source := isOpen_Ioo\n  open_target := isOpen_compl_singleton\n  continuousOn_toFun := (AddCircle.continuous_mk' p).continuousOn\n  continuousOn_invFun := by\n    exact continuousOn_of_forall_continuousAt\n      (fun _ ↦ continuousAt_subtype_val.comp ∘ continuousAt_equivIco p a)\n\n"}
{"name":"AddCircle.partialHomeomorphCoe_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na✝ : 𝕜\ninst✝³ : Archimedean 𝕜\ninst✝² : TopologicalSpace 𝕜\ninst✝¹ : OrderTopology 𝕜\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem (AddSubgroup.zmultiples p) x)\na : 𝕜\n⊢ Eq (↑(AddCircle.partialHomeomorphCoe p a✝) a) ↑a","decl":"/-- The quotient map `𝕜 → AddCircle p` as a partial homeomorphism. -/\n@[simps] def partialHomeomorphCoe [DiscreteTopology (zmultiples p)] :\n    PartialHomeomorph 𝕜 (AddCircle p) where\n  toFun := (↑)\n  invFun := fun x ↦ equivIco p a x\n  source := Ioo a (a + p)\n  target := {↑a}ᶜ\n  map_source' := by\n    intro x hx hx'\n    exact hx.1.ne' ((coe_eq_coe_iff_of_mem_Ico (Ioo_subset_Ico_self hx)\n      (left_mem_Ico.mpr (lt_add_of_pos_right a hp.out))).mp hx')\n  map_target' := by\n    intro x hx\n    exact (eq_left_or_mem_Ioo_of_mem_Ico (equivIco p a x).2).resolve_left\n      (hx ∘ ((equivIco p a).symm_apply_apply x).symm.trans ∘ congrArg _)\n  left_inv' :=\n    fun x hx ↦ congrArg _ ((equivIco p a).apply_symm_apply ⟨x, Ioo_subset_Ico_self hx⟩)\n  right_inv' := fun x _ ↦ (equivIco p a).symm_apply_apply x\n  open_source := isOpen_Ioo\n  open_target := isOpen_compl_singleton\n  continuousOn_toFun := (AddCircle.continuous_mk' p).continuousOn\n  continuousOn_invFun := by\n    exact continuousOn_of_forall_continuousAt\n      (fun _ ↦ continuousAt_subtype_val.comp ∘ continuousAt_equivIco p a)\n\n"}
{"name":"AddCircle.partialHomeomorphCoe_target","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝³ : Archimedean 𝕜\ninst✝² : TopologicalSpace 𝕜\ninst✝¹ : OrderTopology 𝕜\ninst✝ : DiscreteTopology (Subtype fun x => Membership.mem (AddSubgroup.zmultiples p) x)\n⊢ Eq (AddCircle.partialHomeomorphCoe p a).target (HasCompl.compl (Singleton.singleton ↑a))","decl":"/-- The quotient map `𝕜 → AddCircle p` as a partial homeomorphism. -/\n@[simps] def partialHomeomorphCoe [DiscreteTopology (zmultiples p)] :\n    PartialHomeomorph 𝕜 (AddCircle p) where\n  toFun := (↑)\n  invFun := fun x ↦ equivIco p a x\n  source := Ioo a (a + p)\n  target := {↑a}ᶜ\n  map_source' := by\n    intro x hx hx'\n    exact hx.1.ne' ((coe_eq_coe_iff_of_mem_Ico (Ioo_subset_Ico_self hx)\n      (left_mem_Ico.mpr (lt_add_of_pos_right a hp.out))).mp hx')\n  map_target' := by\n    intro x hx\n    exact (eq_left_or_mem_Ioo_of_mem_Ico (equivIco p a x).2).resolve_left\n      (hx ∘ ((equivIco p a).symm_apply_apply x).symm.trans ∘ congrArg _)\n  left_inv' :=\n    fun x hx ↦ congrArg _ ((equivIco p a).apply_symm_apply ⟨x, Ioo_subset_Ico_self hx⟩)\n  right_inv' := fun x _ ↦ (equivIco p a).symm_apply_apply x\n  open_source := isOpen_Ioo\n  open_target := isOpen_compl_singleton\n  continuousOn_toFun := (AddCircle.continuous_mk' p).continuousOn\n  continuousOn_invFun := by\n    exact continuousOn_of_forall_continuousAt\n      (fun _ ↦ continuousAt_subtype_val.comp ∘ continuousAt_equivIco p a)\n\n"}
{"name":"AddCircle.isLocalHomeomorph_coe","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\ninst✝⁴ : Archimedean 𝕜\ninst✝³ : TopologicalSpace 𝕜\ninst✝² : OrderTopology 𝕜\ninst✝¹ : DiscreteTopology (Subtype fun x => Membership.mem (AddSubgroup.zmultiples p) x)\ninst✝ : DenselyOrdered 𝕜\n⊢ IsLocalHomeomorph QuotientAddGroup.mk","decl":"lemma isLocalHomeomorph_coe [DiscreteTopology (zmultiples p)] [DenselyOrdered 𝕜] :\n    IsLocalHomeomorph ((↑) : 𝕜 → AddCircle p) := by\n  intro a\n  obtain ⟨b, hb1, hb2⟩ := exists_between (sub_lt_self a hp.out)\n  exact ⟨partialHomeomorphCoe p b, ⟨hb2, lt_add_of_sub_right_lt hb1⟩, rfl⟩\n\n"}
{"name":"AddCircle.coe_image_Ico_eq","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝ : Archimedean 𝕜\n⊢ Eq (Set.image QuotientAddGroup.mk (Set.Ico a (HAdd.hAdd a p))) Set.univ","decl":"/-- The image of the closed-open interval `[a, a + p)` under the quotient map `𝕜 → AddCircle p` is\nthe entire space. -/\n@[simp]\ntheorem coe_image_Ico_eq : ((↑) : 𝕜 → AddCircle p) '' Ico a (a + p) = univ := by\n  rw [image_eq_range]\n  exact (equivIco p a).symm.range_eq_univ\n\n"}
{"name":"AddCircle.coe_image_Ioc_eq","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝ : Archimedean 𝕜\n⊢ Eq (Set.image QuotientAddGroup.mk (Set.Ioc a (HAdd.hAdd a p))) Set.univ","decl":"/-- The image of the closed-open interval `[a, a + p)` under the quotient map `𝕜 → AddCircle p` is\nthe entire space. -/\n@[simp]\ntheorem coe_image_Ioc_eq : ((↑) : 𝕜 → AddCircle p) '' Ioc a (a + p) = univ := by\n  rw [image_eq_range]\n  exact (equivIoc p a).symm.range_eq_univ\n\n"}
{"name":"AddCircle.coe_image_Icc_eq","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\na : 𝕜\ninst✝ : Archimedean 𝕜\n⊢ Eq (Set.image QuotientAddGroup.mk (Set.Icc a (HAdd.hAdd a p))) Set.univ","decl":"/-- The image of the closed interval `[0, p]` under the quotient map `𝕜 → AddCircle p` is the\nentire space. -/\n@[simp]\ntheorem coe_image_Icc_eq : ((↑) : 𝕜 → AddCircle p) '' Icc a (a + p) = univ :=\n  eq_top_mono (image_subset _ Ico_subset_Icc_self) <| coe_image_Ico_eq _ _\n\n"}
{"name":"AddCircle.equivAddCircle_apply_mk","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np q : 𝕜\nhp : Ne p 0\nhq : Ne q 0\nx : 𝕜\n⊢ Eq ((AddCircle.equivAddCircle p q hp hq) ↑x) ↑(HMul.hMul x (HMul.hMul (Inv.inv p) q))","decl":"@[simp]\ntheorem equivAddCircle_apply_mk (hp : p ≠ 0) (hq : q ≠ 0) (x : 𝕜) :\n    equivAddCircle p q hp hq (x : 𝕜) = (x * (p⁻¹ * q) : 𝕜) :=\n  rfl\n\n"}
{"name":"AddCircle.equivAddCircle_symm_apply_mk","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np q : 𝕜\nhp : Ne p 0\nhq : Ne q 0\nx : 𝕜\n⊢ Eq ((AddCircle.equivAddCircle p q hp hq).symm ↑x) ↑(HMul.hMul x (HMul.hMul (Inv.inv q) p))","decl":"@[simp]\ntheorem equivAddCircle_symm_apply_mk (hp : p ≠ 0) (hq : q ≠ 0) (x : 𝕜) :\n    (equivAddCircle p q hp hq).symm (x : 𝕜) = (x * (q⁻¹ * p) : 𝕜) :=\n  rfl\n\n"}
{"name":"AddCircle.homeomorphAddCircle_apply_mk","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\np q : 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nhp : Ne p 0\nhq : Ne q 0\nx : 𝕜\n⊢ Eq ((AddCircle.homeomorphAddCircle p q hp hq) ↑x) ↑(HMul.hMul x (HMul.hMul (Inv.inv p) q))","decl":"@[simp]\ntheorem homeomorphAddCircle_apply_mk (hp : p ≠ 0) (hq : q ≠ 0) (x : 𝕜) :\n    homeomorphAddCircle p q hp hq (x : 𝕜) = (x * (p⁻¹ * q) : 𝕜) :=\n  rfl\n\n"}
{"name":"AddCircle.homeomorphAddCircle_symm_apply_mk","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝² : LinearOrderedField 𝕜\np q : 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : OrderTopology 𝕜\nhp : Ne p 0\nhq : Ne q 0\nx : 𝕜\n⊢ Eq ((AddCircle.homeomorphAddCircle p q hp hq).symm ↑x) ↑(HMul.hMul x (HMul.hMul (Inv.inv q) p))","decl":"@[simp]\ntheorem homeomorphAddCircle_symm_apply_mk (hp : p ≠ 0) (hq : q ≠ 0) (x : 𝕜) :\n    (homeomorphAddCircle p q hp hq).symm (x : 𝕜) = (x * (q⁻¹ * p) : 𝕜) :=\n  rfl\n"}
{"name":"AddCircle.coe_equivIco_mk_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝¹ : LinearOrderedField 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\ninst✝ : FloorRing 𝕜\nx : 𝕜\n⊢ Eq (↑((AddCircle.equivIco p 0) ↑x)) (HMul.hMul (Int.fract (HDiv.hDiv x p)) p)","decl":"@[simp]\ntheorem coe_equivIco_mk_apply (x : 𝕜) :\n    (equivIco p 0 <| QuotientAddGroup.mk x : 𝕜) = Int.fract (x / p) * p :=\n  toIcoMod_eq_fract_mul _ x\n\n"}
{"name":"AddCircle.addOrderOf_period_div","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\nn : Nat\nh : LT.lt 0 n\n⊢ Eq (addOrderOf ↑(HDiv.hDiv p ↑n)) n","decl":"theorem addOrderOf_period_div {n : ℕ} (h : 0 < n) : addOrderOf ((p / n : 𝕜) : AddCircle p) = n := by\n  rw [addOrderOf_eq_iff h]\n  replace h : 0 < (n : 𝕜) := Nat.cast_pos.2 h\n  refine ⟨?_, fun m hn h0 => ?_⟩ <;> simp only [Ne, ← coe_nsmul, nsmul_eq_mul]\n  · rw [mul_div_cancel₀ _ h.ne', coe_period]\n  rw [coe_eq_zero_of_pos_iff p hp.out (mul_pos (Nat.cast_pos.2 h0) <| div_pos hp.out h)]\n  rintro ⟨k, hk⟩\n  rw [mul_div, eq_div_iff h.ne', nsmul_eq_mul, mul_right_comm, ← Nat.cast_mul,\n    (mul_left_injective₀ hp.out.ne').eq_iff, Nat.cast_inj, mul_comm] at hk\n  exact (Nat.le_of_dvd h0 ⟨_, hk.symm⟩).not_lt hn\n\n"}
{"name":"AddCircle.gcd_mul_addOrderOf_div_eq","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\nn m : Nat\nhn : LT.lt 0 n\n⊢ Eq (HMul.hMul (m.gcd n) (addOrderOf ↑(HMul.hMul (HDiv.hDiv ↑m ↑n) p))) n","decl":"theorem gcd_mul_addOrderOf_div_eq {n : ℕ} (m : ℕ) (hn : 0 < n) :\n    m.gcd n * addOrderOf (↑(↑m / ↑n * p) : AddCircle p) = n := by\n  rw [mul_comm_div, ← nsmul_eq_mul, coe_nsmul, IsOfFinAddOrder.addOrderOf_nsmul]\n  · rw [addOrderOf_period_div hn, Nat.gcd_comm, Nat.mul_div_cancel']\n    exact n.gcd_dvd_left m\n  · rwa [← addOrderOf_pos_iff, addOrderOf_period_div hn]\n\n"}
{"name":"AddCircle.addOrderOf_div_of_gcd_eq_one","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\nm n : Nat\nhn : LT.lt 0 n\nh : Eq (m.gcd n) 1\n⊢ Eq (addOrderOf ↑(HMul.hMul (HDiv.hDiv ↑m ↑n) p)) n","decl":"theorem addOrderOf_div_of_gcd_eq_one {m n : ℕ} (hn : 0 < n) (h : m.gcd n = 1) :\n    addOrderOf (↑(↑m / ↑n * p) : AddCircle p) = n := by\n  convert gcd_mul_addOrderOf_div_eq p m hn\n  rw [h, one_mul]\n\n"}
{"name":"AddCircle.addOrderOf_div_of_gcd_eq_one'","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\nm : Int\nn : Nat\nhn : LT.lt 0 n\nh : Eq (m.natAbs.gcd n) 1\n⊢ Eq (addOrderOf ↑(HMul.hMul (HDiv.hDiv ↑m ↑n) p)) n","decl":"theorem addOrderOf_div_of_gcd_eq_one' {m : ℤ} {n : ℕ} (hn : 0 < n) (h : m.natAbs.gcd n = 1) :\n    addOrderOf (↑(↑m / ↑n * p) : AddCircle p) = n := by\n  induction m\n  · simp only [Int.ofNat_eq_coe, Int.cast_natCast, Int.natAbs_ofNat] at h ⊢\n    exact addOrderOf_div_of_gcd_eq_one hn h\n  · simp only [Int.cast_negSucc, neg_div, neg_mul, coe_neg, addOrderOf_neg]\n    exact addOrderOf_div_of_gcd_eq_one hn h\n\n"}
{"name":"AddCircle.addOrderOf_coe_rat","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\nq : Rat\n⊢ Eq (addOrderOf ↑(HMul.hMul (↑q) p)) q.den","decl":"theorem addOrderOf_coe_rat {q : ℚ} : addOrderOf (↑(↑q * p) : AddCircle p) = q.den := by\n  have : (↑(q.den : ℤ) : 𝕜) ≠ 0 := by\n    norm_cast\n    exact q.pos.ne.symm\n  rw [← q.num_divInt_den, Rat.cast_divInt_of_ne_zero _ this, Int.cast_natCast, Rat.num_divInt_den,\n    addOrderOf_div_of_gcd_eq_one' q.pos q.reduced]\n\n"}
{"name":"AddCircle.addOrderOf_eq_pos_iff","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\nu : AddCircle p\nn : Nat\nh : LT.lt 0 n\n⊢ Iff (Eq (addOrderOf u) n) (Exists fun m => And (LT.lt m n) (And (Eq (m.gcd n) 1) (Eq (↑(HMul.hMul (HDiv.hDiv ↑m ↑n) p)) u)))","decl":"theorem addOrderOf_eq_pos_iff {u : AddCircle p} {n : ℕ} (h : 0 < n) :\n    addOrderOf u = n ↔ ∃ m < n, m.gcd n = 1 ∧ ↑(↑m / ↑n * p) = u := by\n  refine ⟨QuotientAddGroup.induction_on u fun k hk => ?_, ?_⟩\n  · rintro ⟨m, _, h₁, rfl⟩\n    exact addOrderOf_div_of_gcd_eq_one h h₁\n  have h0 := addOrderOf_nsmul_eq_zero (k : AddCircle p)\n  rw [hk, ← coe_nsmul, coe_eq_zero_iff] at h0\n  obtain ⟨a, ha⟩ := h0\n  have h0 : (_ : 𝕜) ≠ 0 := Nat.cast_ne_zero.2 h.ne'\n  rw [nsmul_eq_mul, mul_comm, ← div_eq_iff h0, ← a.ediv_add_emod' n, add_smul, add_div,\n    zsmul_eq_mul, Int.cast_mul, Int.cast_natCast, mul_assoc, ← mul_div, mul_comm _ p,\n    mul_div_cancel_right₀ p h0] at ha\n  have han : _ = a % n := Int.toNat_of_nonneg (Int.emod_nonneg _ <| mod_cast h.ne')\n  have he : (↑(↑((a % n).toNat) / ↑n * p) : AddCircle p) = k := by\n    convert congr_arg (QuotientAddGroup.mk : 𝕜 → (AddCircle p)) ha using 1\n    rw [coe_add, ← Int.cast_natCast, han, zsmul_eq_mul, mul_div_right_comm, eq_comm,\n      add_left_eq_self, ← zsmul_eq_mul, coe_zsmul, coe_period, smul_zero]\n  refine ⟨(a % n).toNat, ?_, ?_, he⟩\n  · rw [← Int.ofNat_lt, han]\n    exact Int.emod_lt_of_pos _ (Int.ofNat_lt.2 h)\n  · have := (gcd_mul_addOrderOf_div_eq p (Int.toNat (a % ↑n)) h).trans\n      ((congr_arg addOrderOf he).trans hk).symm\n    rw [he, Nat.mul_left_eq_self_iff] at this\n    · exact this\n    · rwa [hk]\n\n"}
{"name":"AddCircle.exists_gcd_eq_one_of_isOfFinAddOrder","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\nu : AddCircle p\nh : IsOfFinAddOrder u\n⊢ Exists fun m => And (Eq (m.gcd (addOrderOf u)) 1) (And (LT.lt m (addOrderOf u)) (Eq (↑(HMul.hMul (HDiv.hDiv ↑m ↑(addOrderOf u)) p)) u))","decl":"theorem exists_gcd_eq_one_of_isOfFinAddOrder {u : AddCircle p} (h : IsOfFinAddOrder u) :\n    ∃ m : ℕ, m.gcd (addOrderOf u) = 1 ∧ m < addOrderOf u ∧ ↑((m : 𝕜) / addOrderOf u * p) = u :=\n  let ⟨m, hl, hg, he⟩ := (addOrderOf_eq_pos_iff h.addOrderOf_pos).1 rfl\n  ⟨m, hg, hl, he⟩\n\n"}
{"name":"AddCircle.card_addOrderOf_eq_totient","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\nn : Nat\n⊢ Eq (Nat.card (Subtype fun u => Eq (addOrderOf u) n)) n.totient","decl":"@[simp]\ntheorem card_addOrderOf_eq_totient {n : ℕ} :\n    Nat.card { u : AddCircle p // addOrderOf u = n } = n.totient := by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · simp only [Nat.totient_zero, addOrderOf_eq_zero_iff]\n    rcases em (∃ u : AddCircle p, ¬IsOfFinAddOrder u) with (⟨u, hu⟩ | h)\n    · have : Infinite { u : AddCircle p // ¬IsOfFinAddOrder u } := by\n        erw [infinite_coe_iff]\n        exact infinite_not_isOfFinAddOrder hu\n      exact Nat.card_eq_zero_of_infinite\n    · have : IsEmpty { u : AddCircle p // ¬IsOfFinAddOrder u } := by simpa [isEmpty_subtype] using h\n      exact Nat.card_of_isEmpty\n  · rw [← coe_setOf, Nat.card_congr (setAddOrderOfEquiv p hn),\n      n.totient_eq_card_lt_and_coprime]\n    simp only [Nat.gcd_comm]\n\n"}
{"name":"AddCircle.finite_setOf_add_order_eq","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : LinearOrderedField 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\nn : Nat\nhn : LT.lt 0 n\n⊢ (setOf fun u => Eq (addOrderOf u) n).Finite","decl":"theorem finite_setOf_add_order_eq {n : ℕ} (hn : 0 < n) :\n    { u : AddCircle p | addOrderOf u = n }.Finite :=\n  finite_coe_iff.mp <| Nat.finite_of_card_ne_zero <| by simp [hn.ne']\n\n"}
{"name":"AddCircle.pathConnectedSpace","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"p : Real\n⊢ PathConnectedSpace (AddCircle p)","decl":"instance pathConnectedSpace : PathConnectedSpace <| AddCircle p :=\n  (inferInstance : PathConnectedSpace (Quotient _))\n\n"}
{"name":"AddCircle.compactSpace","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"p : Real\ninst✝ : Fact (LT.lt 0 p)\n⊢ CompactSpace (AddCircle p)","decl":"/-- The \"additive circle\" `ℝ ⧸ (ℤ ∙ p)` is compact. -/\ninstance compactSpace [Fact (0 < p)] : CompactSpace <| AddCircle p := by\n  rw [← isCompact_univ_iff, ← coe_image_Icc_eq p 0]\n  exact isCompact_Icc.image (AddCircle.continuous_mk' p)\n\n"}
{"name":"AddCircle.instProperlyDiscontinuousVAddSubtypeAddOppositeRealMemAddSubgroupOpZmultiples","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"p : Real\n⊢ ProperlyDiscontinuousVAdd (Subtype fun x => Membership.mem (AddSubgroup.zmultiples p).op x) Real","decl":"/-- The action on `ℝ` by right multiplication of its the subgroup `zmultiples p` (the multiples of\n`p:ℝ`) is properly discontinuous. -/\ninstance : ProperlyDiscontinuousVAdd (zmultiples p).op ℝ :=\n  (zmultiples p).properlyDiscontinuousVAdd_opposite_of_tendsto_cofinite\n    (AddSubgroup.tendsto_zmultiples_subtype_cofinite p)\n\n"}
{"name":"instZeroLTOne","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝ : StrictOrderedSemiring 𝕜\n⊢ Fact (LT.lt 0 1)","decl":"instance instZeroLTOne [StrictOrderedSemiring 𝕜] : Fact ((0 : 𝕜) < 1) := ⟨zero_lt_one⟩\n\n"}
{"name":"AddCircle.equivIccQuot_comp_mk_eq_toIcoMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup 𝕜\np a : 𝕜\nhp : Fact (LT.lt 0 p)\ninst✝ : Archimedean 𝕜\n⊢ Eq (Function.comp (⇑(AddCircle.equivIccQuot p a)) Quotient.mk'') fun x => Quot.mk (AddCircle.EndpointIdent p a) ⟨toIcoMod ⋯ a x, ⋯⟩","decl":"theorem equivIccQuot_comp_mk_eq_toIcoMod :\n    equivIccQuot p a ∘ Quotient.mk'' = fun x =>\n      Quot.mk _ ⟨toIcoMod hp.out a x, Ico_subset_Icc_self <| toIcoMod_mem_Ico _ _ x⟩ :=\n  rfl\n\n"}
{"name":"AddCircle.equivIccQuot_comp_mk_eq_toIocMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup 𝕜\np a : 𝕜\nhp : Fact (LT.lt 0 p)\ninst✝ : Archimedean 𝕜\n⊢ Eq (Function.comp (⇑(AddCircle.equivIccQuot p a)) Quotient.mk'') fun x => Quot.mk (AddCircle.EndpointIdent p a) ⟨toIocMod ⋯ a x, ⋯⟩","decl":"theorem equivIccQuot_comp_mk_eq_toIocMod :\n    equivIccQuot p a ∘ Quotient.mk'' = fun x =>\n      Quot.mk _ ⟨toIocMod hp.out a x, Ioc_subset_Icc_self <| toIocMod_mem_Ioc _ _ x⟩ := by\n  rw [equivIccQuot_comp_mk_eq_toIcoMod]\n  funext x\n  by_cases h : a ≡ x [PMOD p]\n  · simp_rw [(modEq_iff_toIcoMod_eq_left hp.out).1 h, (modEq_iff_toIocMod_eq_right hp.out).1 h]\n    exact Quot.sound EndpointIdent.mk\n  · simp_rw [(not_modEq_iff_toIcoMod_eq_toIocMod hp.out).1 h]\n\n"}
{"name":"AddCircle.liftIco_eq_lift_Icc","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\nB : Type u_2\ninst✝¹ : LinearOrderedAddCommGroup 𝕜\np a : 𝕜\nhp : Fact (LT.lt 0 p)\ninst✝ : Archimedean 𝕜\nf : 𝕜 → B\nh : Eq (f a) (f (HAdd.hAdd a p))\n⊢ Eq (AddCircle.liftIco p a f) (Function.comp (Quot.lift ((Set.Icc a (HAdd.hAdd a p)).restrict f) ⋯) ⇑(AddCircle.equivIccQuot p a))","decl":"theorem liftIco_eq_lift_Icc {f : 𝕜 → B} (h : f a = f (a + p)) :\n    liftIco p a f =\n      Quot.lift (restrict (Icc a <| a + p) f)\n          (by\n            rintro _ _ ⟨_⟩\n            exact h) ∘\n        equivIccQuot p a :=\n  rfl\n\n"}
{"name":"AddCircle.liftIco_zero_coe_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\nB : Type u_2\ninst✝¹ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\ninst✝ : Archimedean 𝕜\nf : 𝕜 → B\nx : 𝕜\nhx : Membership.mem (Set.Ico 0 p) x\n⊢ Eq (AddCircle.liftIco p 0 f ↑x) (f x)","decl":"theorem liftIco_zero_coe_apply {f : 𝕜 → B} {x : 𝕜} (hx : x ∈ Ico 0 p) : liftIco p 0 f ↑x = f x :=\n  liftIco_coe_apply (by rwa [zero_add])\n\n"}
{"name":"AddCircle.liftIco_continuous","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\nB : Type u_2\ninst✝⁴ : LinearOrderedAddCommGroup 𝕜\np a : 𝕜\nhp : Fact (LT.lt 0 p)\ninst✝³ : Archimedean 𝕜\ninst✝² : TopologicalSpace 𝕜\ninst✝¹ : OrderTopology 𝕜\ninst✝ : TopologicalSpace B\nf : 𝕜 → B\nhf : Eq (f a) (f (HAdd.hAdd a p))\nhc : ContinuousOn f (Set.Icc a (HAdd.hAdd a p))\n⊢ Continuous (AddCircle.liftIco p a f)","decl":"theorem liftIco_continuous [TopologicalSpace B] {f : 𝕜 → B} (hf : f a = f (a + p))\n    (hc : ContinuousOn f <| Icc a (a + p)) : Continuous (liftIco p a f) := by\n  rw [liftIco_eq_lift_Icc hf]\n  refine Continuous.comp ?_ (homeoIccQuot p a).continuous_toFun\n  exact continuous_coinduced_dom.mpr (continuousOn_iff_continuous_restrict.mp hc)\n\n"}
{"name":"AddCircle.liftIco_zero_continuous","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"𝕜 : Type u_1\nB : Type u_2\ninst✝⁴ : LinearOrderedAddCommGroup 𝕜\np : 𝕜\nhp : Fact (LT.lt 0 p)\ninst✝³ : Archimedean 𝕜\ninst✝² : TopologicalSpace 𝕜\ninst✝¹ : OrderTopology 𝕜\ninst✝ : TopologicalSpace B\nf : 𝕜 → B\nhf : Eq (f 0) (f p)\nhc : ContinuousOn f (Set.Icc 0 p)\n⊢ Continuous (AddCircle.liftIco p 0 f)","decl":"theorem liftIco_zero_continuous [TopologicalSpace B] {f : 𝕜 → B} (hf : f 0 = f p)\n    (hc : ContinuousOn f <| Icc 0 p) : Continuous (liftIco p 0 f) :=\n  liftIco_continuous (by rwa [zero_add] : f 0 = f (0 + p)) (by rwa [zero_add])\n\n"}
{"name":"ZMod.toAddCircle_intCast","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"N : Nat\ninst✝ : NeZero N\nj : Int\n⊢ Eq (ZMod.toAddCircle ↑j) ↑(HDiv.hDiv ↑j ↑N)","decl":"lemma toAddCircle_intCast (j : ℤ) :\n    toAddCircle (j : ZMod N) = ↑(j / N : ℝ) := by\n  simp [toAddCircle]\n\n"}
{"name":"ZMod.toAddCircle_natCast","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"N : Nat\ninst✝ : NeZero N\nj : Nat\n⊢ Eq (ZMod.toAddCircle ↑j) ↑(HDiv.hDiv ↑j ↑N)","decl":"lemma toAddCircle_natCast (j : ℕ) :\n    toAddCircle (j : ZMod N) = ↑(j / N : ℝ) := by\n  simpa using toAddCircle_intCast (N := N) j\n\n"}
{"name":"ZMod.toAddCircle_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"N : Nat\ninst✝ : NeZero N\nj : ZMod N\n⊢ Eq (ZMod.toAddCircle j) ↑(HDiv.hDiv ↑j.val ↑N)","decl":"/--\nExplicit formula for `toCircle j`. Note that this is \"evil\" because it uses `ZMod.val`. Where\npossible, it is recommended to lift `j` to `ℤ` and use `toAddCircle_intCast` instead.\n-/\nlemma toAddCircle_apply (j : ZMod N) :\n    toAddCircle j = ↑(j.val / N : ℝ) := by\n  rw [← toAddCircle_natCast, natCast_zmod_val]\n\n"}
{"name":"ZMod.toAddCircle_injective","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"N : Nat\ninst✝ : NeZero N\n⊢ Function.Injective ⇑ZMod.toAddCircle","decl":"variable (N) in\nlemma toAddCircle_injective : Function.Injective (toAddCircle : ZMod N → _) := by\n  intro x y hxy\n  have : (0 : ℝ) < N := Nat.cast_pos.mpr (NeZero.pos _)\n  rwa [toAddCircle_apply, toAddCircle_apply, AddCircle.coe_eq_coe_iff_of_mem_Ico\n    (hp := Real.fact_zero_lt_one) (a := 0), div_left_inj' this.ne', Nat.cast_inj,\n    (val_injective N).eq_iff] at hxy <;>\n  exact ⟨by positivity, by simpa only [zero_add, div_lt_one this, Nat.cast_lt] using val_lt _⟩\n\n"}
{"name":"ZMod.toAddCircle_inj","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"N : Nat\ninst✝ : NeZero N\nj k : ZMod N\n⊢ Iff (Eq (ZMod.toAddCircle j) (ZMod.toAddCircle k)) (Eq j k)","decl":"@[simp] lemma toAddCircle_inj {j k : ZMod N} : toAddCircle j = toAddCircle k ↔ j = k :=\n  (toAddCircle_injective N).eq_iff\n\n"}
{"name":"ZMod.toAddCircle_eq_zero","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"N : Nat\ninst✝ : NeZero N\nj : ZMod N\n⊢ Iff (Eq (ZMod.toAddCircle j) 0) (Eq j 0)","decl":"@[simp] lemma toAddCircle_eq_zero {j : ZMod N} : toAddCircle j = 0 ↔ j = 0 :=\n  map_eq_zero_iff _ (toAddCircle_injective N)\n\n"}
