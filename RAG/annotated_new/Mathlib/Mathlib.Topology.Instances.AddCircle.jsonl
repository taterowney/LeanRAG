{"name":"continuous_right_toIcoMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : LinearOrderedAddCommGroup ğ•œ\ninstâœÂ² : Archimedean ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : OrderTopology ğ•œ\np : ğ•œ\nhp : LT.lt 0 p\na x : ğ•œ\nâŠ¢ ContinuousWithinAt (toIcoMod hp a) (Set.Ici x) x","decl":"theorem continuous_right_toIcoMod : ContinuousWithinAt (toIcoMod hp a) (Ici x) x := by\n  intro s h\n  rw [Filter.mem_map, mem_nhdsWithin_iff_exists_mem_nhds_inter]\n  haveI : Nontrivial ğ•œ := âŸ¨âŸ¨0, p, hp.neâŸ©âŸ©\n  simp_rw [mem_nhds_iff_exists_Ioo_subset] at h âŠ¢\n  obtain âŸ¨l, u, hxI, hIsâŸ© := h\n  let d := toIcoDiv hp a x â€¢ p\n  have hd := toIcoMod_mem_Ico hp a x\n  simp_rw [subset_def, mem_inter_iff]\n  refine âŸ¨_, âŸ¨l + d, min (a + p) u + d, ?_, fun x => idâŸ©, fun y => ?_âŸ© <;>\n    simp_rw [â† sub_mem_Ioo_iff_left, mem_Ioo, lt_min_iff]\n  Â· exact âŸ¨hxI.1, hd.2, hxI.2âŸ©\n  Â· rintro âŸ¨h, h'âŸ©\n    apply hIs\n    rw [â† toIcoMod_sub_zsmul, (toIcoMod_eq_self _).2]\n    exacts [âŸ¨h.1, h.2.2âŸ©, âŸ¨hd.1.trans (sub_le_sub_right h' _), h.2.1âŸ©]\n\n"}
{"name":"continuous_left_toIocMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : LinearOrderedAddCommGroup ğ•œ\ninstâœÂ² : Archimedean ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : OrderTopology ğ•œ\np : ğ•œ\nhp : LT.lt 0 p\na x : ğ•œ\nâŠ¢ ContinuousWithinAt (toIocMod hp a) (Set.Iic x) x","decl":"theorem continuous_left_toIocMod : ContinuousWithinAt (toIocMod hp a) (Iic x) x := by\n  rw [(funext fun y => Eq.trans (by rw [neg_neg]) <| toIocMod_neg _ _ _ :\n      toIocMod hp a = (fun x => p - x) âˆ˜ toIcoMod hp (-a) âˆ˜ Neg.neg)]\n  -- Porting note: added\n  have : ContinuousNeg ğ•œ := TopologicalAddGroup.toContinuousNeg\n  exact\n    (continuous_sub_left _).continuousAt.comp_continuousWithinAt <|\n      (continuous_right_toIcoMod _ _ _).comp continuous_neg.continuousWithinAt fun y => neg_le_neg\n\n"}
{"name":"toIcoMod_eventuallyEq_toIocMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : LinearOrderedAddCommGroup ğ•œ\ninstâœÂ² : Archimedean ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : OrderTopology ğ•œ\np : ğ•œ\nhp : LT.lt 0 p\na x : ğ•œ\nhx : Ne â†‘x â†‘a\nâŠ¢ (nhds x).EventuallyEq (toIcoMod hp a) (toIocMod hp a)","decl":"theorem toIcoMod_eventuallyEq_toIocMod (hx : (x : ğ•œ â§¸ zmultiples p) â‰  a) :\n    toIcoMod hp a =á¶ [ğ“ x] toIocMod hp a :=\n  IsOpen.mem_nhds\n      (by\n        rw [Ico_eq_locus_Ioc_eq_iUnion_Ioo]\n        exact isOpen_iUnion fun i => isOpen_Ioo) <|\n    (not_modEq_iff_toIcoMod_eq_toIocMod hp).1 <| not_modEq_iff_ne_mod_zmultiples.2 hx\n\n"}
{"name":"continuousAt_toIcoMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : LinearOrderedAddCommGroup ğ•œ\ninstâœÂ² : Archimedean ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : OrderTopology ğ•œ\np : ğ•œ\nhp : LT.lt 0 p\na x : ğ•œ\nhx : Ne â†‘x â†‘a\nâŠ¢ ContinuousAt (toIcoMod hp a) x","decl":"theorem continuousAt_toIcoMod (hx : (x : ğ•œ â§¸ zmultiples p) â‰  a) : ContinuousAt (toIcoMod hp a) x :=\n  let h := toIcoMod_eventuallyEq_toIocMod hp a hx\n  continuousAt_iff_continuous_left_right.2 <|\n    âŸ¨(continuous_left_toIocMod hp a x).congr_of_eventuallyEq (h.filter_mono nhdsWithin_le_nhds)\n        h.eq_of_nhds,\n      continuous_right_toIcoMod hp a xâŸ©\n\n"}
{"name":"continuousAt_toIocMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : LinearOrderedAddCommGroup ğ•œ\ninstâœÂ² : Archimedean ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : OrderTopology ğ•œ\np : ğ•œ\nhp : LT.lt 0 p\na x : ğ•œ\nhx : Ne â†‘x â†‘a\nâŠ¢ ContinuousAt (toIocMod hp a) x","decl":"theorem continuousAt_toIocMod (hx : (x : ğ•œ â§¸ zmultiples p) â‰  a) : ContinuousAt (toIocMod hp a) x :=\n  let h := toIcoMod_eventuallyEq_toIocMod hp a hx\n  continuousAt_iff_continuous_left_right.2 <|\n    âŸ¨continuous_left_toIocMod hp a x,\n      (continuous_right_toIcoMod hp a x).congr_of_eventuallyEq\n        (h.symm.filter_mono nhdsWithin_le_nhds) h.symm.eq_of_nhdsâŸ©\n\n"}
{"name":"AddCircle.coe_nsmul","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nn : Nat\nx : ğ•œ\nâŠ¢ Eq (â†‘(HSMul.hSMul n x)) (HSMul.hSMul n â†‘x)","decl":"theorem coe_nsmul {n : â„•} {x : ğ•œ} : (â†‘(n â€¢ x) : AddCircle p) = n â€¢ (x : AddCircle p) :=\n  rfl\n\n"}
{"name":"AddCircle.coe_zsmul","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nn : Int\nx : ğ•œ\nâŠ¢ Eq (â†‘(HSMul.hSMul n x)) (HSMul.hSMul n â†‘x)","decl":"theorem coe_zsmul {n : â„¤} {x : ğ•œ} : (â†‘(n â€¢ x) : AddCircle p) = n â€¢ (x : AddCircle p) :=\n  rfl\n\n"}
{"name":"AddCircle.coe_add","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedAddCommGroup ğ•œ\np x y : ğ•œ\nâŠ¢ Eq (â†‘(HAdd.hAdd x y)) (HAdd.hAdd â†‘x â†‘y)","decl":"theorem coe_add (x y : ğ•œ) : (â†‘(x + y) : AddCircle p) = (x : AddCircle p) + (y : AddCircle p) :=\n  rfl\n\n"}
{"name":"AddCircle.coe_sub","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedAddCommGroup ğ•œ\np x y : ğ•œ\nâŠ¢ Eq (â†‘(HSub.hSub x y)) (HSub.hSub â†‘x â†‘y)","decl":"theorem coe_sub (x y : ğ•œ) : (â†‘(x - y) : AddCircle p) = (x : AddCircle p) - (y : AddCircle p) :=\n  rfl\n\n"}
{"name":"AddCircle.coe_neg","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedAddCommGroup ğ•œ\np x : ğ•œ\nâŠ¢ Eq (â†‘(Neg.neg x)) (Neg.neg â†‘x)","decl":"theorem coe_neg {x : ğ•œ} : (â†‘(-x) : AddCircle p) = -(x : AddCircle p) :=\n  rfl\n\n"}
{"name":"AddCircle.coe_eq_zero_iff","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedAddCommGroup ğ•œ\np x : ğ•œ\nâŠ¢ Iff (Eq (â†‘x) 0) (Exists fun n => Eq (HSMul.hSMul n p) x)","decl":"theorem coe_eq_zero_iff {x : ğ•œ} : (x : AddCircle p) = 0 â†” âˆƒ n : â„¤, n â€¢ p = x := by\n  simp [AddSubgroup.mem_zmultiples_iff]\n\n"}
{"name":"AddCircle.coe_eq_zero_of_pos_iff","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : LT.lt 0 p\nx : ğ•œ\nhx : LT.lt 0 x\nâŠ¢ Iff (Eq (â†‘x) 0) (Exists fun n => Eq (HSMul.hSMul n p) x)","decl":"theorem coe_eq_zero_of_pos_iff (hp : 0 < p) {x : ğ•œ} (hx : 0 < x) :\n    (x : AddCircle p) = 0 â†” âˆƒ n : â„•, n â€¢ p = x := by\n  rw [coe_eq_zero_iff]\n  constructor <;> rintro âŸ¨n, rflâŸ©\n  Â· replace hx : 0 < n := by\n      contrapose! hx\n      simpa only [â† neg_nonneg, â† zsmul_neg, zsmul_neg'] using zsmul_nonneg hp.le (neg_nonneg.2 hx)\n    exact âŸ¨n.toNat, by rw [â† natCast_zsmul, Int.toNat_of_nonneg hx.le]âŸ©\n  Â· exact âŸ¨(n : â„¤), by simpâŸ©\n\n"}
{"name":"AddCircle.coe_period","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nâŠ¢ Eq (â†‘p) 0","decl":"theorem coe_period : (p : AddCircle p) = 0 :=\n  (QuotientAddGroup.eq_zero_iff p).2 <| mem_zmultiples p\n\n"}
{"name":"AddCircle.coe_add_period","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedAddCommGroup ğ•œ\np x : ğ•œ\nâŠ¢ Eq â†‘(HAdd.hAdd x p) â†‘x","decl":"theorem coe_add_period (x : ğ•œ) : ((x + p : ğ•œ) : AddCircle p) = x := by\n  rw [coe_add, â† eq_sub_iff_add_eq', sub_self, coe_period]\n\n"}
{"name":"AddCircle.continuous_mk'","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\ninstâœ : TopologicalSpace ğ•œ\nâŠ¢ Continuous â‡‘(QuotientAddGroup.mk' (AddSubgroup.zmultiples p))","decl":"@[continuity, nolint unusedArguments]\nprotected theorem continuous_mk' [TopologicalSpace ğ•œ] :\n    Continuous (QuotientAddGroup.mk' (zmultiples p) : ğ•œ â†’ AddCircle p) :=\n  continuous_coinduced_rng\n\n"}
{"name":"AddCircle.coe_eq_coe_iff_of_mem_Ico","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœ : Archimedean ğ•œ\nx y : ğ•œ\nhx : Membership.mem (Set.Ico a (HAdd.hAdd a p)) x\nhy : Membership.mem (Set.Ico a (HAdd.hAdd a p)) y\nâŠ¢ Iff (Eq â†‘x â†‘y) (Eq x y)","decl":"theorem coe_eq_coe_iff_of_mem_Ico {x y : ğ•œ} (hx : x âˆˆ Ico a (a + p)) (hy : y âˆˆ Ico a (a + p)) :\n    (x : AddCircle p) = y â†” x = y := by\n  refine âŸ¨fun h => ?_, by tautoâŸ©\n  suffices (âŸ¨x, hxâŸ© : Ico a (a + p)) = âŸ¨y, hyâŸ© by exact Subtype.mk.inj this\n  apply_fun equivIco p a at h\n  rw [â† (equivIco p a).right_inv âŸ¨x, hxâŸ©, â† (equivIco p a).right_inv âŸ¨y, hyâŸ©]\n  exact h\n\n"}
{"name":"AddCircle.liftIco_coe_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\ninstâœÂ¹ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœ : Archimedean ğ•œ\nf : ğ•œ â†’ B\nx : ğ•œ\nhx : Membership.mem (Set.Ico a (HAdd.hAdd a p)) x\nâŠ¢ Eq (AddCircle.liftIco p a f â†‘x) (f x)","decl":"theorem liftIco_coe_apply {f : ğ•œ â†’ B} {x : ğ•œ} (hx : x âˆˆ Ico a (a + p)) :\n    liftIco p a f â†‘x = f x := by\n  have : (equivIco p a) x = âŸ¨x, hxâŸ© := by\n    rw [Equiv.apply_eq_iff_eq_symm_apply]\n    rfl\n  rw [liftIco, comp_apply, this]\n  rfl\n\n"}
{"name":"AddCircle.liftIoc_coe_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\ninstâœÂ¹ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœ : Archimedean ğ•œ\nf : ğ•œ â†’ B\nx : ğ•œ\nhx : Membership.mem (Set.Ioc a (HAdd.hAdd a p)) x\nâŠ¢ Eq (AddCircle.liftIoc p a f â†‘x) (f x)","decl":"theorem liftIoc_coe_apply {f : ğ•œ â†’ B} {x : ğ•œ} (hx : x âˆˆ Ioc a (a + p)) :\n    liftIoc p a f â†‘x = f x := by\n  have : (equivIoc p a) x = âŸ¨x, hxâŸ© := by\n    rw [Equiv.apply_eq_iff_eq_symm_apply]\n    rfl\n  rw [liftIoc, comp_apply, this]\n  rfl\n\n"}
{"name":"AddCircle.eq_coe_Ico","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\ninstâœ : Archimedean ğ•œ\na : AddCircle p\nâŠ¢ Exists fun b => And (Membership.mem (Set.Ico 0 p) b) (Eq (â†‘b) a)","decl":"lemma eq_coe_Ico (a : AddCircle p) : âˆƒ b, b âˆˆ Ico 0 p âˆ§ â†‘b = a := by\n  let b := QuotientAddGroup.equivIcoMod hp.out 0 a\n  exact âŸ¨b.1, by simpa only [zero_add] using b.2,\n    (QuotientAddGroup.equivIcoMod hp.out 0).symm_apply_apply aâŸ©\n\n"}
{"name":"AddCircle.coe_eq_zero_iff_of_mem_Ico","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœ : Archimedean ğ•œ\nha : Membership.mem (Set.Ico 0 p) a\nâŠ¢ Iff (Eq (â†‘a) 0) (Eq a 0)","decl":"lemma coe_eq_zero_iff_of_mem_Ico (ha : a âˆˆ Ico 0 p) :\n    (a : AddCircle p) = 0 â†” a = 0 := by\n  have h0 : 0 âˆˆ Ico 0 (0 + p) := by simpa [zero_add, left_mem_Ico] using hp.out\n  have ha' : a âˆˆ Ico 0 (0 + p) := by rwa [zero_add]\n  rw [â† AddCircle.coe_eq_coe_iff_of_mem_Ico ha' h0, QuotientAddGroup.mk_zero]\n\n"}
{"name":"AddCircle.continuous_equivIco_symm","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœÂ¹ : Archimedean ğ•œ\ninstâœ : TopologicalSpace ğ•œ\nâŠ¢ Continuous â‡‘(AddCircle.equivIco p a).symm","decl":"@[continuity]\ntheorem continuous_equivIco_symm : Continuous (equivIco p a).symm :=\n  continuous_quotient_mk'.comp continuous_subtype_val\n\n"}
{"name":"AddCircle.continuous_equivIoc_symm","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœÂ¹ : Archimedean ğ•œ\ninstâœ : TopologicalSpace ğ•œ\nâŠ¢ Continuous â‡‘(AddCircle.equivIoc p a).symm","decl":"@[continuity]\ntheorem continuous_equivIoc_symm : Continuous (equivIoc p a).symm :=\n  continuous_quotient_mk'.comp continuous_subtype_val\n\n"}
{"name":"AddCircle.continuousAt_equivIco","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœÂ² : Archimedean ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : OrderTopology ğ•œ\nx : AddCircle p\nhx : Ne x â†‘a\nâŠ¢ ContinuousAt (â‡‘(AddCircle.equivIco p a)) x","decl":"theorem continuousAt_equivIco (hx : x â‰  a) : ContinuousAt (equivIco p a) x := by\n  induction x using QuotientAddGroup.induction_on\n  rw [ContinuousAt, Filter.Tendsto, QuotientAddGroup.nhds_eq, Filter.map_map]\n  exact (continuousAt_toIcoMod hp.out a hx).codRestrict _\n\n"}
{"name":"AddCircle.continuousAt_equivIoc","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœÂ² : Archimedean ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : OrderTopology ğ•œ\nx : AddCircle p\nhx : Ne x â†‘a\nâŠ¢ ContinuousAt (â‡‘(AddCircle.equivIoc p a)) x","decl":"theorem continuousAt_equivIoc (hx : x â‰  a) : ContinuousAt (equivIoc p a) x := by\n  induction x using QuotientAddGroup.induction_on\n  rw [ContinuousAt, Filter.Tendsto, QuotientAddGroup.nhds_eq, Filter.map_map]\n  exact (continuousAt_toIocMod hp.out a hx).codRestrict _\n\n"}
{"name":"AddCircle.partialHomeomorphCoe_source","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœÂ³ : Archimedean ğ•œ\ninstâœÂ² : TopologicalSpace ğ•œ\ninstâœÂ¹ : OrderTopology ğ•œ\ninstâœ : DiscreteTopology (Subtype fun x => Membership.mem (AddSubgroup.zmultiples p) x)\nâŠ¢ Eq (AddCircle.partialHomeomorphCoe p a).source (Set.Ioo a (HAdd.hAdd a p))","decl":"/-- The quotient map `ğ•œ â†’ AddCircle p` as a partial homeomorphism. -/\n@[simps] def partialHomeomorphCoe [DiscreteTopology (zmultiples p)] :\n    PartialHomeomorph ğ•œ (AddCircle p) where\n  toFun := (â†‘)\n  invFun := fun x â†¦ equivIco p a x\n  source := Ioo a (a + p)\n  target := {â†‘a}á¶œ\n  map_source' := by\n    intro x hx hx'\n    exact hx.1.ne' ((coe_eq_coe_iff_of_mem_Ico (Ioo_subset_Ico_self hx)\n      (left_mem_Ico.mpr (lt_add_of_pos_right a hp.out))).mp hx')\n  map_target' := by\n    intro x hx\n    exact (eq_left_or_mem_Ioo_of_mem_Ico (equivIco p a x).2).resolve_left\n      (hx âˆ˜ ((equivIco p a).symm_apply_apply x).symm.trans âˆ˜ congrArg _)\n  left_inv' :=\n    fun x hx â†¦ congrArg _ ((equivIco p a).apply_symm_apply âŸ¨x, Ioo_subset_Ico_self hxâŸ©)\n  right_inv' := fun x _ â†¦ (equivIco p a).symm_apply_apply x\n  open_source := isOpen_Ioo\n  open_target := isOpen_compl_singleton\n  continuousOn_toFun := (AddCircle.continuous_mk' p).continuousOn\n  continuousOn_invFun := by\n    exact continuousOn_of_forall_continuousAt\n      (fun _ â†¦ continuousAt_subtype_val.comp âˆ˜ continuousAt_equivIco p a)\n\n"}
{"name":"AddCircle.partialHomeomorphCoe_symm_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœÂ³ : Archimedean ğ•œ\ninstâœÂ² : TopologicalSpace ğ•œ\ninstâœÂ¹ : OrderTopology ğ•œ\ninstâœ : DiscreteTopology (Subtype fun x => Membership.mem (AddSubgroup.zmultiples p) x)\nx : AddCircle p\nâŠ¢ Eq (â†‘(AddCircle.partialHomeomorphCoe p a).symm x) â†‘((AddCircle.equivIco p a) x)","decl":"/-- The quotient map `ğ•œ â†’ AddCircle p` as a partial homeomorphism. -/\n@[simps] def partialHomeomorphCoe [DiscreteTopology (zmultiples p)] :\n    PartialHomeomorph ğ•œ (AddCircle p) where\n  toFun := (â†‘)\n  invFun := fun x â†¦ equivIco p a x\n  source := Ioo a (a + p)\n  target := {â†‘a}á¶œ\n  map_source' := by\n    intro x hx hx'\n    exact hx.1.ne' ((coe_eq_coe_iff_of_mem_Ico (Ioo_subset_Ico_self hx)\n      (left_mem_Ico.mpr (lt_add_of_pos_right a hp.out))).mp hx')\n  map_target' := by\n    intro x hx\n    exact (eq_left_or_mem_Ioo_of_mem_Ico (equivIco p a x).2).resolve_left\n      (hx âˆ˜ ((equivIco p a).symm_apply_apply x).symm.trans âˆ˜ congrArg _)\n  left_inv' :=\n    fun x hx â†¦ congrArg _ ((equivIco p a).apply_symm_apply âŸ¨x, Ioo_subset_Ico_self hxâŸ©)\n  right_inv' := fun x _ â†¦ (equivIco p a).symm_apply_apply x\n  open_source := isOpen_Ioo\n  open_target := isOpen_compl_singleton\n  continuousOn_toFun := (AddCircle.continuous_mk' p).continuousOn\n  continuousOn_invFun := by\n    exact continuousOn_of_forall_continuousAt\n      (fun _ â†¦ continuousAt_subtype_val.comp âˆ˜ continuousAt_equivIco p a)\n\n"}
{"name":"AddCircle.partialHomeomorphCoe_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\naâœ : ğ•œ\ninstâœÂ³ : Archimedean ğ•œ\ninstâœÂ² : TopologicalSpace ğ•œ\ninstâœÂ¹ : OrderTopology ğ•œ\ninstâœ : DiscreteTopology (Subtype fun x => Membership.mem (AddSubgroup.zmultiples p) x)\na : ğ•œ\nâŠ¢ Eq (â†‘(AddCircle.partialHomeomorphCoe p aâœ) a) â†‘a","decl":"/-- The quotient map `ğ•œ â†’ AddCircle p` as a partial homeomorphism. -/\n@[simps] def partialHomeomorphCoe [DiscreteTopology (zmultiples p)] :\n    PartialHomeomorph ğ•œ (AddCircle p) where\n  toFun := (â†‘)\n  invFun := fun x â†¦ equivIco p a x\n  source := Ioo a (a + p)\n  target := {â†‘a}á¶œ\n  map_source' := by\n    intro x hx hx'\n    exact hx.1.ne' ((coe_eq_coe_iff_of_mem_Ico (Ioo_subset_Ico_self hx)\n      (left_mem_Ico.mpr (lt_add_of_pos_right a hp.out))).mp hx')\n  map_target' := by\n    intro x hx\n    exact (eq_left_or_mem_Ioo_of_mem_Ico (equivIco p a x).2).resolve_left\n      (hx âˆ˜ ((equivIco p a).symm_apply_apply x).symm.trans âˆ˜ congrArg _)\n  left_inv' :=\n    fun x hx â†¦ congrArg _ ((equivIco p a).apply_symm_apply âŸ¨x, Ioo_subset_Ico_self hxâŸ©)\n  right_inv' := fun x _ â†¦ (equivIco p a).symm_apply_apply x\n  open_source := isOpen_Ioo\n  open_target := isOpen_compl_singleton\n  continuousOn_toFun := (AddCircle.continuous_mk' p).continuousOn\n  continuousOn_invFun := by\n    exact continuousOn_of_forall_continuousAt\n      (fun _ â†¦ continuousAt_subtype_val.comp âˆ˜ continuousAt_equivIco p a)\n\n"}
{"name":"AddCircle.partialHomeomorphCoe_target","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœÂ³ : Archimedean ğ•œ\ninstâœÂ² : TopologicalSpace ğ•œ\ninstâœÂ¹ : OrderTopology ğ•œ\ninstâœ : DiscreteTopology (Subtype fun x => Membership.mem (AddSubgroup.zmultiples p) x)\nâŠ¢ Eq (AddCircle.partialHomeomorphCoe p a).target (HasCompl.compl (Singleton.singleton â†‘a))","decl":"/-- The quotient map `ğ•œ â†’ AddCircle p` as a partial homeomorphism. -/\n@[simps] def partialHomeomorphCoe [DiscreteTopology (zmultiples p)] :\n    PartialHomeomorph ğ•œ (AddCircle p) where\n  toFun := (â†‘)\n  invFun := fun x â†¦ equivIco p a x\n  source := Ioo a (a + p)\n  target := {â†‘a}á¶œ\n  map_source' := by\n    intro x hx hx'\n    exact hx.1.ne' ((coe_eq_coe_iff_of_mem_Ico (Ioo_subset_Ico_self hx)\n      (left_mem_Ico.mpr (lt_add_of_pos_right a hp.out))).mp hx')\n  map_target' := by\n    intro x hx\n    exact (eq_left_or_mem_Ioo_of_mem_Ico (equivIco p a x).2).resolve_left\n      (hx âˆ˜ ((equivIco p a).symm_apply_apply x).symm.trans âˆ˜ congrArg _)\n  left_inv' :=\n    fun x hx â†¦ congrArg _ ((equivIco p a).apply_symm_apply âŸ¨x, Ioo_subset_Ico_self hxâŸ©)\n  right_inv' := fun x _ â†¦ (equivIco p a).symm_apply_apply x\n  open_source := isOpen_Ioo\n  open_target := isOpen_compl_singleton\n  continuousOn_toFun := (AddCircle.continuous_mk' p).continuousOn\n  continuousOn_invFun := by\n    exact continuousOn_of_forall_continuousAt\n      (fun _ â†¦ continuousAt_subtype_val.comp âˆ˜ continuousAt_equivIco p a)\n\n"}
{"name":"AddCircle.isLocalHomeomorph_coe","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\ninstâœâ´ : Archimedean ğ•œ\ninstâœÂ³ : TopologicalSpace ğ•œ\ninstâœÂ² : OrderTopology ğ•œ\ninstâœÂ¹ : DiscreteTopology (Subtype fun x => Membership.mem (AddSubgroup.zmultiples p) x)\ninstâœ : DenselyOrdered ğ•œ\nâŠ¢ IsLocalHomeomorph QuotientAddGroup.mk","decl":"lemma isLocalHomeomorph_coe [DiscreteTopology (zmultiples p)] [DenselyOrdered ğ•œ] :\n    IsLocalHomeomorph ((â†‘) : ğ•œ â†’ AddCircle p) := by\n  intro a\n  obtain âŸ¨b, hb1, hb2âŸ© := exists_between (sub_lt_self a hp.out)\n  exact âŸ¨partialHomeomorphCoe p b, âŸ¨hb2, lt_add_of_sub_right_lt hb1âŸ©, rflâŸ©\n\n"}
{"name":"AddCircle.coe_image_Ico_eq","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœ : Archimedean ğ•œ\nâŠ¢ Eq (Set.image QuotientAddGroup.mk (Set.Ico a (HAdd.hAdd a p))) Set.univ","decl":"/-- The image of the closed-open interval `[a, a + p)` under the quotient map `ğ•œ â†’ AddCircle p` is\nthe entire space. -/\n@[simp]\ntheorem coe_image_Ico_eq : ((â†‘) : ğ•œ â†’ AddCircle p) '' Ico a (a + p) = univ := by\n  rw [image_eq_range]\n  exact (equivIco p a).symm.range_eq_univ\n\n"}
{"name":"AddCircle.coe_image_Ioc_eq","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœ : Archimedean ğ•œ\nâŠ¢ Eq (Set.image QuotientAddGroup.mk (Set.Ioc a (HAdd.hAdd a p))) Set.univ","decl":"/-- The image of the closed-open interval `[a, a + p)` under the quotient map `ğ•œ â†’ AddCircle p` is\nthe entire space. -/\n@[simp]\ntheorem coe_image_Ioc_eq : ((â†‘) : ğ•œ â†’ AddCircle p) '' Ioc a (a + p) = univ := by\n  rw [image_eq_range]\n  exact (equivIoc p a).symm.range_eq_univ\n\n"}
{"name":"AddCircle.coe_image_Icc_eq","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\na : ğ•œ\ninstâœ : Archimedean ğ•œ\nâŠ¢ Eq (Set.image QuotientAddGroup.mk (Set.Icc a (HAdd.hAdd a p))) Set.univ","decl":"/-- The image of the closed interval `[0, p]` under the quotient map `ğ•œ â†’ AddCircle p` is the\nentire space. -/\n@[simp]\ntheorem coe_image_Icc_eq : ((â†‘) : ğ•œ â†’ AddCircle p) '' Icc a (a + p) = univ :=\n  eq_top_mono (image_subset _ Ico_subset_Icc_self) <| coe_image_Ico_eq _ _\n\n"}
{"name":"AddCircle.equivAddCircle_apply_mk","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np q : ğ•œ\nhp : Ne p 0\nhq : Ne q 0\nx : ğ•œ\nâŠ¢ Eq ((AddCircle.equivAddCircle p q hp hq) â†‘x) â†‘(HMul.hMul x (HMul.hMul (Inv.inv p) q))","decl":"@[simp]\ntheorem equivAddCircle_apply_mk (hp : p â‰  0) (hq : q â‰  0) (x : ğ•œ) :\n    equivAddCircle p q hp hq (x : ğ•œ) = (x * (pâ»Â¹ * q) : ğ•œ) :=\n  rfl\n\n"}
{"name":"AddCircle.equivAddCircle_symm_apply_mk","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np q : ğ•œ\nhp : Ne p 0\nhq : Ne q 0\nx : ğ•œ\nâŠ¢ Eq ((AddCircle.equivAddCircle p q hp hq).symm â†‘x) â†‘(HMul.hMul x (HMul.hMul (Inv.inv q) p))","decl":"@[simp]\ntheorem equivAddCircle_symm_apply_mk (hp : p â‰  0) (hq : q â‰  0) (x : ğ•œ) :\n    (equivAddCircle p q hp hq).symm (x : ğ•œ) = (x * (qâ»Â¹ * p) : ğ•œ) :=\n  rfl\n\n"}
{"name":"AddCircle.homeomorphAddCircle_apply_mk","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : LinearOrderedField ğ•œ\np q : ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : OrderTopology ğ•œ\nhp : Ne p 0\nhq : Ne q 0\nx : ğ•œ\nâŠ¢ Eq ((AddCircle.homeomorphAddCircle p q hp hq) â†‘x) â†‘(HMul.hMul x (HMul.hMul (Inv.inv p) q))","decl":"@[simp]\ntheorem homeomorphAddCircle_apply_mk (hp : p â‰  0) (hq : q â‰  0) (x : ğ•œ) :\n    homeomorphAddCircle p q hp hq (x : ğ•œ) = (x * (pâ»Â¹ * q) : ğ•œ) :=\n  rfl\n\n"}
{"name":"AddCircle.homeomorphAddCircle_symm_apply_mk","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : LinearOrderedField ğ•œ\np q : ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : OrderTopology ğ•œ\nhp : Ne p 0\nhq : Ne q 0\nx : ğ•œ\nâŠ¢ Eq ((AddCircle.homeomorphAddCircle p q hp hq).symm â†‘x) â†‘(HMul.hMul x (HMul.hMul (Inv.inv q) p))","decl":"@[simp]\ntheorem homeomorphAddCircle_symm_apply_mk (hp : p â‰  0) (hq : q â‰  0) (x : ğ•œ) :\n    (homeomorphAddCircle p q hp hq).symm (x : ğ•œ) = (x * (qâ»Â¹ * p) : ğ•œ) :=\n  rfl\n"}
{"name":"AddCircle.coe_equivIco_mk_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : LinearOrderedField ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\ninstâœ : FloorRing ğ•œ\nx : ğ•œ\nâŠ¢ Eq (â†‘((AddCircle.equivIco p 0) â†‘x)) (HMul.hMul (Int.fract (HDiv.hDiv x p)) p)","decl":"@[simp]\ntheorem coe_equivIco_mk_apply (x : ğ•œ) :\n    (equivIco p 0 <| QuotientAddGroup.mk x : ğ•œ) = Int.fract (x / p) * p :=\n  toIcoMod_eq_fract_mul _ x\n\n"}
{"name":"AddCircle.addOrderOf_period_div","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\nn : Nat\nh : LT.lt 0 n\nâŠ¢ Eq (addOrderOf â†‘(HDiv.hDiv p â†‘n)) n","decl":"theorem addOrderOf_period_div {n : â„•} (h : 0 < n) : addOrderOf ((p / n : ğ•œ) : AddCircle p) = n := by\n  rw [addOrderOf_eq_iff h]\n  replace h : 0 < (n : ğ•œ) := Nat.cast_pos.2 h\n  refine âŸ¨?_, fun m hn h0 => ?_âŸ© <;> simp only [Ne, â† coe_nsmul, nsmul_eq_mul]\n  Â· rw [mul_div_cancelâ‚€ _ h.ne', coe_period]\n  rw [coe_eq_zero_of_pos_iff p hp.out (mul_pos (Nat.cast_pos.2 h0) <| div_pos hp.out h)]\n  rintro âŸ¨k, hkâŸ©\n  rw [mul_div, eq_div_iff h.ne', nsmul_eq_mul, mul_right_comm, â† Nat.cast_mul,\n    (mul_left_injectiveâ‚€ hp.out.ne').eq_iff, Nat.cast_inj, mul_comm] at hk\n  exact (Nat.le_of_dvd h0 âŸ¨_, hk.symmâŸ©).not_lt hn\n\n"}
{"name":"AddCircle.gcd_mul_addOrderOf_div_eq","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\nn m : Nat\nhn : LT.lt 0 n\nâŠ¢ Eq (HMul.hMul (m.gcd n) (addOrderOf â†‘(HMul.hMul (HDiv.hDiv â†‘m â†‘n) p))) n","decl":"theorem gcd_mul_addOrderOf_div_eq {n : â„•} (m : â„•) (hn : 0 < n) :\n    m.gcd n * addOrderOf (â†‘(â†‘m / â†‘n * p) : AddCircle p) = n := by\n  rw [mul_comm_div, â† nsmul_eq_mul, coe_nsmul, IsOfFinAddOrder.addOrderOf_nsmul]\n  Â· rw [addOrderOf_period_div hn, Nat.gcd_comm, Nat.mul_div_cancel']\n    exact n.gcd_dvd_left m\n  Â· rwa [â† addOrderOf_pos_iff, addOrderOf_period_div hn]\n\n"}
{"name":"AddCircle.addOrderOf_div_of_gcd_eq_one","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\nm n : Nat\nhn : LT.lt 0 n\nh : Eq (m.gcd n) 1\nâŠ¢ Eq (addOrderOf â†‘(HMul.hMul (HDiv.hDiv â†‘m â†‘n) p)) n","decl":"theorem addOrderOf_div_of_gcd_eq_one {m n : â„•} (hn : 0 < n) (h : m.gcd n = 1) :\n    addOrderOf (â†‘(â†‘m / â†‘n * p) : AddCircle p) = n := by\n  convert gcd_mul_addOrderOf_div_eq p m hn\n  rw [h, one_mul]\n\n"}
{"name":"AddCircle.addOrderOf_div_of_gcd_eq_one'","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\nm : Int\nn : Nat\nhn : LT.lt 0 n\nh : Eq (m.natAbs.gcd n) 1\nâŠ¢ Eq (addOrderOf â†‘(HMul.hMul (HDiv.hDiv â†‘m â†‘n) p)) n","decl":"theorem addOrderOf_div_of_gcd_eq_one' {m : â„¤} {n : â„•} (hn : 0 < n) (h : m.natAbs.gcd n = 1) :\n    addOrderOf (â†‘(â†‘m / â†‘n * p) : AddCircle p) = n := by\n  induction m\n  Â· simp only [Int.ofNat_eq_coe, Int.cast_natCast, Int.natAbs_ofNat] at h âŠ¢\n    exact addOrderOf_div_of_gcd_eq_one hn h\n  Â· simp only [Int.cast_negSucc, neg_div, neg_mul, coe_neg, addOrderOf_neg]\n    exact addOrderOf_div_of_gcd_eq_one hn h\n\n"}
{"name":"AddCircle.addOrderOf_coe_rat","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\nq : Rat\nâŠ¢ Eq (addOrderOf â†‘(HMul.hMul (â†‘q) p)) q.den","decl":"theorem addOrderOf_coe_rat {q : â„š} : addOrderOf (â†‘(â†‘q * p) : AddCircle p) = q.den := by\n  have : (â†‘(q.den : â„¤) : ğ•œ) â‰  0 := by\n    norm_cast\n    exact q.pos.ne.symm\n  rw [â† q.num_divInt_den, Rat.cast_divInt_of_ne_zero _ this, Int.cast_natCast, Rat.num_divInt_den,\n    addOrderOf_div_of_gcd_eq_one' q.pos q.reduced]\n\n"}
{"name":"AddCircle.addOrderOf_eq_pos_iff","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\nu : AddCircle p\nn : Nat\nh : LT.lt 0 n\nâŠ¢ Iff (Eq (addOrderOf u) n) (Exists fun m => And (LT.lt m n) (And (Eq (m.gcd n) 1) (Eq (â†‘(HMul.hMul (HDiv.hDiv â†‘m â†‘n) p)) u)))","decl":"theorem addOrderOf_eq_pos_iff {u : AddCircle p} {n : â„•} (h : 0 < n) :\n    addOrderOf u = n â†” âˆƒ m < n, m.gcd n = 1 âˆ§ â†‘(â†‘m / â†‘n * p) = u := by\n  refine âŸ¨QuotientAddGroup.induction_on u fun k hk => ?_, ?_âŸ©\n  Â· rintro âŸ¨m, _, hâ‚, rflâŸ©\n    exact addOrderOf_div_of_gcd_eq_one h hâ‚\n  have h0 := addOrderOf_nsmul_eq_zero (k : AddCircle p)\n  rw [hk, â† coe_nsmul, coe_eq_zero_iff] at h0\n  obtain âŸ¨a, haâŸ© := h0\n  have h0 : (_ : ğ•œ) â‰  0 := Nat.cast_ne_zero.2 h.ne'\n  rw [nsmul_eq_mul, mul_comm, â† div_eq_iff h0, â† a.ediv_add_emod' n, add_smul, add_div,\n    zsmul_eq_mul, Int.cast_mul, Int.cast_natCast, mul_assoc, â† mul_div, mul_comm _ p,\n    mul_div_cancel_rightâ‚€ p h0] at ha\n  have han : _ = a % n := Int.toNat_of_nonneg (Int.emod_nonneg _ <| mod_cast h.ne')\n  have he : (â†‘(â†‘((a % n).toNat) / â†‘n * p) : AddCircle p) = k := by\n    convert congr_arg (QuotientAddGroup.mk : ğ•œ â†’ (AddCircle p)) ha using 1\n    rw [coe_add, â† Int.cast_natCast, han, zsmul_eq_mul, mul_div_right_comm, eq_comm,\n      add_left_eq_self, â† zsmul_eq_mul, coe_zsmul, coe_period, smul_zero]\n  refine âŸ¨(a % n).toNat, ?_, ?_, heâŸ©\n  Â· rw [â† Int.ofNat_lt, han]\n    exact Int.emod_lt_of_pos _ (Int.ofNat_lt.2 h)\n  Â· have := (gcd_mul_addOrderOf_div_eq p (Int.toNat (a % â†‘n)) h).trans\n      ((congr_arg addOrderOf he).trans hk).symm\n    rw [he, Nat.mul_left_eq_self_iff] at this\n    Â· exact this\n    Â· rwa [hk]\n\n"}
{"name":"AddCircle.exists_gcd_eq_one_of_isOfFinAddOrder","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\nu : AddCircle p\nh : IsOfFinAddOrder u\nâŠ¢ Exists fun m => And (Eq (m.gcd (addOrderOf u)) 1) (And (LT.lt m (addOrderOf u)) (Eq (â†‘(HMul.hMul (HDiv.hDiv â†‘m â†‘(addOrderOf u)) p)) u))","decl":"theorem exists_gcd_eq_one_of_isOfFinAddOrder {u : AddCircle p} (h : IsOfFinAddOrder u) :\n    âˆƒ m : â„•, m.gcd (addOrderOf u) = 1 âˆ§ m < addOrderOf u âˆ§ â†‘((m : ğ•œ) / addOrderOf u * p) = u :=\n  let âŸ¨m, hl, hg, heâŸ© := (addOrderOf_eq_pos_iff h.addOrderOf_pos).1 rfl\n  âŸ¨m, hg, hl, heâŸ©\n\n"}
{"name":"AddCircle.card_addOrderOf_eq_totient","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\nn : Nat\nâŠ¢ Eq (Nat.card (Subtype fun u => Eq (addOrderOf u) n)) n.totient","decl":"@[simp]\ntheorem card_addOrderOf_eq_totient {n : â„•} :\n    Nat.card { u : AddCircle p // addOrderOf u = n } = n.totient := by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  Â· simp only [Nat.totient_zero, addOrderOf_eq_zero_iff]\n    rcases em (âˆƒ u : AddCircle p, Â¬IsOfFinAddOrder u) with (âŸ¨u, huâŸ© | h)\n    Â· have : Infinite { u : AddCircle p // Â¬IsOfFinAddOrder u } := by\n        erw [infinite_coe_iff]\n        exact infinite_not_isOfFinAddOrder hu\n      exact Nat.card_eq_zero_of_infinite\n    Â· have : IsEmpty { u : AddCircle p // Â¬IsOfFinAddOrder u } := by simpa [isEmpty_subtype] using h\n      exact Nat.card_of_isEmpty\n  Â· rw [â† coe_setOf, Nat.card_congr (setAddOrderOfEquiv p hn),\n      n.totient_eq_card_lt_and_coprime]\n    simp only [Nat.gcd_comm]\n\n"}
{"name":"AddCircle.finite_setOf_add_order_eq","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : LinearOrderedField ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\nn : Nat\nhn : LT.lt 0 n\nâŠ¢ (setOf fun u => Eq (addOrderOf u) n).Finite","decl":"theorem finite_setOf_add_order_eq {n : â„•} (hn : 0 < n) :\n    { u : AddCircle p | addOrderOf u = n }.Finite :=\n  finite_coe_iff.mp <| Nat.finite_of_card_ne_zero <| by simp [hn.ne']\n\n"}
{"name":"AddCircle.pathConnectedSpace","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"p : Real\nâŠ¢ PathConnectedSpace (AddCircle p)","decl":"instance pathConnectedSpace : PathConnectedSpace <| AddCircle p :=\n  (inferInstance : PathConnectedSpace (Quotient _))\n\n"}
{"name":"AddCircle.compactSpace","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"p : Real\ninstâœ : Fact (LT.lt 0 p)\nâŠ¢ CompactSpace (AddCircle p)","decl":"/-- The \"additive circle\" `â„ â§¸ (â„¤ âˆ™ p)` is compact. -/\ninstance compactSpace [Fact (0 < p)] : CompactSpace <| AddCircle p := by\n  rw [â† isCompact_univ_iff, â† coe_image_Icc_eq p 0]\n  exact isCompact_Icc.image (AddCircle.continuous_mk' p)\n\n"}
{"name":"AddCircle.instProperlyDiscontinuousVAddSubtypeAddOppositeRealMemAddSubgroupOpZmultiples","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"p : Real\nâŠ¢ ProperlyDiscontinuousVAdd (Subtype fun x => Membership.mem (AddSubgroup.zmultiples p).op x) Real","decl":"/-- The action on `â„` by right multiplication of its the subgroup `zmultiples p` (the multiples of\n`p:â„`) is properly discontinuous. -/\ninstance : ProperlyDiscontinuousVAdd (zmultiples p).op â„ :=\n  (zmultiples p).properlyDiscontinuousVAdd_opposite_of_tendsto_cofinite\n    (AddSubgroup.tendsto_zmultiples_subtype_cofinite p)\n\n"}
{"name":"instZeroLTOne","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœ : StrictOrderedSemiring ğ•œ\nâŠ¢ Fact (LT.lt 0 1)","decl":"instance instZeroLTOne [StrictOrderedSemiring ğ•œ] : Fact ((0 : ğ•œ) < 1) := âŸ¨zero_lt_oneâŸ©\n\n"}
{"name":"AddCircle.equivIccQuot_comp_mk_eq_toIcoMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : LinearOrderedAddCommGroup ğ•œ\np a : ğ•œ\nhp : Fact (LT.lt 0 p)\ninstâœ : Archimedean ğ•œ\nâŠ¢ Eq (Function.comp (â‡‘(AddCircle.equivIccQuot p a)) Quotient.mk'') fun x => Quot.mk (AddCircle.EndpointIdent p a) âŸ¨toIcoMod â‹¯ a x, â‹¯âŸ©","decl":"theorem equivIccQuot_comp_mk_eq_toIcoMod :\n    equivIccQuot p a âˆ˜ Quotient.mk'' = fun x =>\n      Quot.mk _ âŸ¨toIcoMod hp.out a x, Ico_subset_Icc_self <| toIcoMod_mem_Ico _ _ xâŸ© :=\n  rfl\n\n"}
{"name":"AddCircle.equivIccQuot_comp_mk_eq_toIocMod","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : LinearOrderedAddCommGroup ğ•œ\np a : ğ•œ\nhp : Fact (LT.lt 0 p)\ninstâœ : Archimedean ğ•œ\nâŠ¢ Eq (Function.comp (â‡‘(AddCircle.equivIccQuot p a)) Quotient.mk'') fun x => Quot.mk (AddCircle.EndpointIdent p a) âŸ¨toIocMod â‹¯ a x, â‹¯âŸ©","decl":"theorem equivIccQuot_comp_mk_eq_toIocMod :\n    equivIccQuot p a âˆ˜ Quotient.mk'' = fun x =>\n      Quot.mk _ âŸ¨toIocMod hp.out a x, Ioc_subset_Icc_self <| toIocMod_mem_Ioc _ _ xâŸ© := by\n  rw [equivIccQuot_comp_mk_eq_toIcoMod]\n  funext x\n  by_cases h : a â‰¡ x [PMOD p]\n  Â· simp_rw [(modEq_iff_toIcoMod_eq_left hp.out).1 h, (modEq_iff_toIocMod_eq_right hp.out).1 h]\n    exact Quot.sound EndpointIdent.mk\n  Â· simp_rw [(not_modEq_iff_toIcoMod_eq_toIocMod hp.out).1 h]\n\n"}
{"name":"AddCircle.liftIco_eq_lift_Icc","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\ninstâœÂ¹ : LinearOrderedAddCommGroup ğ•œ\np a : ğ•œ\nhp : Fact (LT.lt 0 p)\ninstâœ : Archimedean ğ•œ\nf : ğ•œ â†’ B\nh : Eq (f a) (f (HAdd.hAdd a p))\nâŠ¢ Eq (AddCircle.liftIco p a f) (Function.comp (Quot.lift ((Set.Icc a (HAdd.hAdd a p)).restrict f) â‹¯) â‡‘(AddCircle.equivIccQuot p a))","decl":"theorem liftIco_eq_lift_Icc {f : ğ•œ â†’ B} (h : f a = f (a + p)) :\n    liftIco p a f =\n      Quot.lift (restrict (Icc a <| a + p) f)\n          (by\n            rintro _ _ âŸ¨_âŸ©\n            exact h) âˆ˜\n        equivIccQuot p a :=\n  rfl\n\n"}
{"name":"AddCircle.liftIco_zero_coe_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\ninstâœÂ¹ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\ninstâœ : Archimedean ğ•œ\nf : ğ•œ â†’ B\nx : ğ•œ\nhx : Membership.mem (Set.Ico 0 p) x\nâŠ¢ Eq (AddCircle.liftIco p 0 f â†‘x) (f x)","decl":"theorem liftIco_zero_coe_apply {f : ğ•œ â†’ B} {x : ğ•œ} (hx : x âˆˆ Ico 0 p) : liftIco p 0 f â†‘x = f x :=\n  liftIco_coe_apply (by rwa [zero_add])\n\n"}
{"name":"AddCircle.liftIco_continuous","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\ninstâœâ´ : LinearOrderedAddCommGroup ğ•œ\np a : ğ•œ\nhp : Fact (LT.lt 0 p)\ninstâœÂ³ : Archimedean ğ•œ\ninstâœÂ² : TopologicalSpace ğ•œ\ninstâœÂ¹ : OrderTopology ğ•œ\ninstâœ : TopologicalSpace B\nf : ğ•œ â†’ B\nhf : Eq (f a) (f (HAdd.hAdd a p))\nhc : ContinuousOn f (Set.Icc a (HAdd.hAdd a p))\nâŠ¢ Continuous (AddCircle.liftIco p a f)","decl":"theorem liftIco_continuous [TopologicalSpace B] {f : ğ•œ â†’ B} (hf : f a = f (a + p))\n    (hc : ContinuousOn f <| Icc a (a + p)) : Continuous (liftIco p a f) := by\n  rw [liftIco_eq_lift_Icc hf]\n  refine Continuous.comp ?_ (homeoIccQuot p a).continuous_toFun\n  exact continuous_coinduced_dom.mpr (continuousOn_iff_continuous_restrict.mp hc)\n\n"}
{"name":"AddCircle.liftIco_zero_continuous","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\ninstâœâ´ : LinearOrderedAddCommGroup ğ•œ\np : ğ•œ\nhp : Fact (LT.lt 0 p)\ninstâœÂ³ : Archimedean ğ•œ\ninstâœÂ² : TopologicalSpace ğ•œ\ninstâœÂ¹ : OrderTopology ğ•œ\ninstâœ : TopologicalSpace B\nf : ğ•œ â†’ B\nhf : Eq (f 0) (f p)\nhc : ContinuousOn f (Set.Icc 0 p)\nâŠ¢ Continuous (AddCircle.liftIco p 0 f)","decl":"theorem liftIco_zero_continuous [TopologicalSpace B] {f : ğ•œ â†’ B} (hf : f 0 = f p)\n    (hc : ContinuousOn f <| Icc 0 p) : Continuous (liftIco p 0 f) :=\n  liftIco_continuous (by rwa [zero_add] : f 0 = f (0 + p)) (by rwa [zero_add])\n\n"}
{"name":"ZMod.toAddCircle_intCast","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"N : Nat\ninstâœ : NeZero N\nj : Int\nâŠ¢ Eq (ZMod.toAddCircle â†‘j) â†‘(HDiv.hDiv â†‘j â†‘N)","decl":"lemma toAddCircle_intCast (j : â„¤) :\n    toAddCircle (j : ZMod N) = â†‘(j / N : â„) := by\n  simp [toAddCircle]\n\n"}
{"name":"ZMod.toAddCircle_natCast","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"N : Nat\ninstâœ : NeZero N\nj : Nat\nâŠ¢ Eq (ZMod.toAddCircle â†‘j) â†‘(HDiv.hDiv â†‘j â†‘N)","decl":"lemma toAddCircle_natCast (j : â„•) :\n    toAddCircle (j : ZMod N) = â†‘(j / N : â„) := by\n  simpa using toAddCircle_intCast (N := N) j\n\n"}
{"name":"ZMod.toAddCircle_apply","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"N : Nat\ninstâœ : NeZero N\nj : ZMod N\nâŠ¢ Eq (ZMod.toAddCircle j) â†‘(HDiv.hDiv â†‘j.val â†‘N)","decl":"/--\nExplicit formula for `toCircle j`. Note that this is \"evil\" because it uses `ZMod.val`. Where\npossible, it is recommended to lift `j` to `â„¤` and use `toAddCircle_intCast` instead.\n-/\nlemma toAddCircle_apply (j : ZMod N) :\n    toAddCircle j = â†‘(j.val / N : â„) := by\n  rw [â† toAddCircle_natCast, natCast_zmod_val]\n\n"}
{"name":"ZMod.toAddCircle_injective","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"N : Nat\ninstâœ : NeZero N\nâŠ¢ Function.Injective â‡‘ZMod.toAddCircle","decl":"variable (N) in\nlemma toAddCircle_injective : Function.Injective (toAddCircle : ZMod N â†’ _) := by\n  intro x y hxy\n  have : (0 : â„) < N := Nat.cast_pos.mpr (NeZero.pos _)\n  rwa [toAddCircle_apply, toAddCircle_apply, AddCircle.coe_eq_coe_iff_of_mem_Ico\n    (hp := Real.fact_zero_lt_one) (a := 0), div_left_inj' this.ne', Nat.cast_inj,\n    (val_injective N).eq_iff] at hxy <;>\n  exact âŸ¨by positivity, by simpa only [zero_add, div_lt_one this, Nat.cast_lt] using val_lt _âŸ©\n\n"}
{"name":"ZMod.toAddCircle_inj","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"N : Nat\ninstâœ : NeZero N\nj k : ZMod N\nâŠ¢ Iff (Eq (ZMod.toAddCircle j) (ZMod.toAddCircle k)) (Eq j k)","decl":"@[simp] lemma toAddCircle_inj {j k : ZMod N} : toAddCircle j = toAddCircle k â†” j = k :=\n  (toAddCircle_injective N).eq_iff\n\n"}
{"name":"ZMod.toAddCircle_eq_zero","module":"Mathlib.Topology.Instances.AddCircle","initialProofState":"N : Nat\ninstâœ : NeZero N\nj : ZMod N\nâŠ¢ Iff (Eq (ZMod.toAddCircle j) 0) (Eq j 0)","decl":"@[simp] lemma toAddCircle_eq_zero {j : ZMod N} : toAddCircle j = 0 â†” j = 0 :=\n  map_eq_zero_iff _ (toAddCircle_injective N)\n\n"}
