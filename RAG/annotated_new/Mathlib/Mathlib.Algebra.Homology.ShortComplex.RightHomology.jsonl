{"name":"CategoryTheory.ShortComplex.RightHomologyData.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : SizeOf C\nQ H : C\np : Quiver.Hom S.X₂ Q\nι : Quiver.Hom H Q\nwp : Eq (CategoryTheory.CategoryStruct.comp S.f p) 0\nhp : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ p wp)\nwι : Eq (CategoryTheory.CategoryStruct.comp ι (hp.desc (CategoryTheory.Limits.CokernelCofork.ofπ S.g ⋯))) 0\nhι : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι ι wι)\n⊢ Eq (SizeOf.sizeOf { Q := Q, H := H, p := p, ι := ι, wp := wp, hp := hp, wι := wι, hι := hι }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Q)) (SizeOf.sizeOf H)) (SizeOf.sizeOf p)) (SizeOf.sizeOf ι)) (SizeOf.sizeOf wp)) (SizeOf.sizeOf hp)) (SizeOf.sizeOf wι)) (SizeOf.sizeOf hι))","decl":"/-- A right homology data for a short complex `S` consists of morphisms `p : S.X₂ ⟶ Q` and\n`ι : H ⟶ Q` such that `p` identifies `Q` to the kernel of `f : S.X₁ ⟶ S.X₂`,\nand that `ι` identifies `H` to the kernel of the induced map `g' : Q ⟶ S.X₃` -/\nstructure RightHomologyData where\n  /-- a choice of cokernel of `S.f : S.X₁ ⟶ S.X₂`-/\n  Q : C\n  /-- a choice of kernel of the induced morphism `S.g' : S.Q ⟶ X₃`-/\n  H : C\n  /-- the projection from `S.X₂` -/\n  p : S.X₂ ⟶ Q\n  /-- the inclusion of the (right) homology in the chosen cokernel of `S.f` -/\n  ι : H ⟶ Q\n  /-- the cokernel condition for `p` -/\n  wp : S.f ≫ p = 0\n  /-- `p : S.X₂ ⟶ Q` is a cokernel of `S.f : S.X₁ ⟶ S.X₂` -/\n  hp : IsColimit (CokernelCofork.ofπ p wp)\n  /-- the kernel condition for `ι` -/\n  wι : ι ≫ hp.desc (CokernelCofork.ofπ _ S.zero) = 0\n  /-- `ι : H ⟶ Q` is a kernel of `S.g' : Q ⟶ S.X₃` -/\n  hι : IsLimit (KernelFork.ofι ι wι)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.mk.inj","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nQ✝ H✝ : C\np✝ : Quiver.Hom S.X₂ Q✝\nι✝ : Quiver.Hom H✝ Q✝\nwp✝ : Eq (CategoryTheory.CategoryStruct.comp S.f p✝) 0\nhp✝ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ p✝ wp✝)\nwι✝ : Eq (CategoryTheory.CategoryStruct.comp ι✝ (hp✝.desc (CategoryTheory.Limits.CokernelCofork.ofπ S.g ⋯))) 0\nhι✝ : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι ι✝ wι✝)\nQ H : C\np : Quiver.Hom S.X₂ Q\nι : Quiver.Hom H Q\nwp : Eq (CategoryTheory.CategoryStruct.comp S.f p) 0\nhp : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ p wp)\nwι : Eq (CategoryTheory.CategoryStruct.comp ι (hp.desc (CategoryTheory.Limits.CokernelCofork.ofπ S.g ⋯))) 0\nhι : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι ι wι)\nx✝ : Eq { Q := Q✝, H := H✝, p := p✝, ι := ι✝, wp := wp✝, hp := hp✝, wι := wι✝, hι := hι✝ } { Q := Q, H := H, p := p, ι := ι, wp := wp, hp := hp, wι := wι, hι := hι }\n⊢ And (Eq Q✝ Q) (And (Eq H✝ H) (And (HEq p✝ p) (And (HEq ι✝ ι) (And (HEq hp✝ hp) (HEq hι✝ hι)))))","decl":"/-- A right homology data for a short complex `S` consists of morphisms `p : S.X₂ ⟶ Q` and\n`ι : H ⟶ Q` such that `p` identifies `Q` to the kernel of `f : S.X₁ ⟶ S.X₂`,\nand that `ι` identifies `H` to the kernel of the induced map `g' : Q ⟶ S.X₃` -/\nstructure RightHomologyData where\n  /-- a choice of cokernel of `S.f : S.X₁ ⟶ S.X₂`-/\n  Q : C\n  /-- a choice of kernel of the induced morphism `S.g' : S.Q ⟶ X₃`-/\n  H : C\n  /-- the projection from `S.X₂` -/\n  p : S.X₂ ⟶ Q\n  /-- the inclusion of the (right) homology in the chosen cokernel of `S.f` -/\n  ι : H ⟶ Q\n  /-- the cokernel condition for `p` -/\n  wp : S.f ≫ p = 0\n  /-- `p : S.X₂ ⟶ Q` is a cokernel of `S.f : S.X₁ ⟶ S.X₂` -/\n  hp : IsColimit (CokernelCofork.ofπ p wp)\n  /-- the kernel condition for `ι` -/\n  wι : ι ≫ hp.desc (CokernelCofork.ofπ _ S.zero) = 0\n  /-- `ι : H ⟶ Q` is a kernel of `S.g' : Q ⟶ S.X₃` -/\n  hι : IsLimit (KernelFork.ofι ι wι)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.mk.injEq","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nQ✝ H✝ : C\np✝ : Quiver.Hom S.X₂ Q✝\nι✝ : Quiver.Hom H✝ Q✝\nwp✝ : Eq (CategoryTheory.CategoryStruct.comp S.f p✝) 0\nhp✝ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ p✝ wp✝)\nwι✝ : Eq (CategoryTheory.CategoryStruct.comp ι✝ (hp✝.desc (CategoryTheory.Limits.CokernelCofork.ofπ S.g ⋯))) 0\nhι✝ : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι ι✝ wι✝)\nQ H : C\np : Quiver.Hom S.X₂ Q\nι : Quiver.Hom H Q\nwp : Eq (CategoryTheory.CategoryStruct.comp S.f p) 0\nhp : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ p wp)\nwι : Eq (CategoryTheory.CategoryStruct.comp ι (hp.desc (CategoryTheory.Limits.CokernelCofork.ofπ S.g ⋯))) 0\nhι : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι ι wι)\n⊢ Eq (Eq { Q := Q✝, H := H✝, p := p✝, ι := ι✝, wp := wp✝, hp := hp✝, wι := wι✝, hι := hι✝ } { Q := Q, H := H, p := p, ι := ι, wp := wp, hp := hp, wι := wι, hι := hι }) (And (Eq Q✝ Q) (And (Eq H✝ H) (And (HEq p✝ p) (And (HEq ι✝ ι) (And (HEq hp✝ hp) (HEq hι✝ hι))))))","decl":"/-- A right homology data for a short complex `S` consists of morphisms `p : S.X₂ ⟶ Q` and\n`ι : H ⟶ Q` such that `p` identifies `Q` to the kernel of `f : S.X₁ ⟶ S.X₂`,\nand that `ι` identifies `H` to the kernel of the induced map `g' : Q ⟶ S.X₃` -/\nstructure RightHomologyData where\n  /-- a choice of cokernel of `S.f : S.X₁ ⟶ S.X₂`-/\n  Q : C\n  /-- a choice of kernel of the induced morphism `S.g' : S.Q ⟶ X₃`-/\n  H : C\n  /-- the projection from `S.X₂` -/\n  p : S.X₂ ⟶ Q\n  /-- the inclusion of the (right) homology in the chosen cokernel of `S.f` -/\n  ι : H ⟶ Q\n  /-- the cokernel condition for `p` -/\n  wp : S.f ≫ p = 0\n  /-- `p : S.X₂ ⟶ Q` is a cokernel of `S.f : S.X₁ ⟶ S.X₂` -/\n  hp : IsColimit (CokernelCofork.ofπ p wp)\n  /-- the kernel condition for `ι` -/\n  wι : ι ≫ hp.desc (CokernelCofork.ofπ _ S.zero) = 0\n  /-- `ι : H ⟶ Q` is a kernel of `S.g' : Q ⟶ S.X₃` -/\n  hι : IsLimit (KernelFork.ofι ι wι)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.wι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.ι (self.hp.desc (CategoryTheory.Limits.CokernelCofork.ofπ S.g ⋯))) 0","decl":"/-- A right homology data for a short complex `S` consists of morphisms `p : S.X₂ ⟶ Q` and\n`ι : H ⟶ Q` such that `p` identifies `Q` to the kernel of `f : S.X₁ ⟶ S.X₂`,\nand that `ι` identifies `H` to the kernel of the induced map `g' : Q ⟶ S.X₃` -/\nstructure RightHomologyData where\n  /-- a choice of cokernel of `S.f : S.X₁ ⟶ S.X₂`-/\n  Q : C\n  /-- a choice of kernel of the induced morphism `S.g' : S.Q ⟶ X₃`-/\n  H : C\n  /-- the projection from `S.X₂` -/\n  p : S.X₂ ⟶ Q\n  /-- the inclusion of the (right) homology in the chosen cokernel of `S.f` -/\n  ι : H ⟶ Q\n  /-- the cokernel condition for `p` -/\n  wp : S.f ≫ p = 0\n  /-- `p : S.X₂ ⟶ Q` is a cokernel of `S.f : S.X₁ ⟶ S.X₂` -/\n  hp : IsColimit (CokernelCofork.ofπ p wp)\n  /-- the kernel condition for `ι` -/\n  wι : ι ≫ hp.desc (CokernelCofork.ofπ _ S.zero) = 0\n  /-- `ι : H ⟶ Q` is a kernel of `S.g' : Q ⟶ S.X₃` -/\n  hι : IsLimit (KernelFork.ofι ι wι)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.wp","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.f self.p) 0","decl":"/-- A right homology data for a short complex `S` consists of morphisms `p : S.X₂ ⟶ Q` and\n`ι : H ⟶ Q` such that `p` identifies `Q` to the kernel of `f : S.X₁ ⟶ S.X₂`,\nand that `ι` identifies `H` to the kernel of the induced map `g' : Q ⟶ S.X₃` -/\nstructure RightHomologyData where\n  /-- a choice of cokernel of `S.f : S.X₁ ⟶ S.X₂`-/\n  Q : C\n  /-- a choice of kernel of the induced morphism `S.g' : S.Q ⟶ X₃`-/\n  H : C\n  /-- the projection from `S.X₂` -/\n  p : S.X₂ ⟶ Q\n  /-- the inclusion of the (right) homology in the chosen cokernel of `S.f` -/\n  ι : H ⟶ Q\n  /-- the cokernel condition for `p` -/\n  wp : S.f ≫ p = 0\n  /-- `p : S.X₂ ⟶ Q` is a cokernel of `S.f : S.X₁ ⟶ S.X₂` -/\n  hp : IsColimit (CokernelCofork.ofπ p wp)\n  /-- the kernel condition for `ι` -/\n  wι : ι ≫ hp.desc (CokernelCofork.ofπ _ S.zero) = 0\n  /-- `ι : H ⟶ Q` is a kernel of `S.g' : Q ⟶ S.X₃` -/\n  hι : IsLimit (KernelFork.ofι ι wι)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofHasCokernelOfHasKernel_p","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Limits.HasCokernel S.f\ninst✝ : CategoryTheory.Limits.HasKernel (CategoryTheory.Limits.cokernel.desc S.f S.g ⋯)\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofHasCokernelOfHasKernel S).p (CategoryTheory.Limits.cokernel.π S.f)","decl":"/-- The chosen cokernels and kernels of the limits API give a `RightHomologyData` -/\n@[simps]\nnoncomputable def ofHasCokernelOfHasKernel\n    [HasCokernel S.f] [HasKernel (cokernel.desc S.f S.g S.zero)] :\n    S.RightHomologyData :=\n{ Q := cokernel S.f,\n  H := kernel (cokernel.desc S.f S.g S.zero),\n  p := cokernel.π _,\n  ι := kernel.ι _,\n  wp := cokernel.condition _,\n  hp := cokernelIsCokernel _,\n  wι := kernel.condition _,\n  hι := kernelIsKernel _, }\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofHasCokernelOfHasKernel_H","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Limits.HasCokernel S.f\ninst✝ : CategoryTheory.Limits.HasKernel (CategoryTheory.Limits.cokernel.desc S.f S.g ⋯)\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofHasCokernelOfHasKernel S).H (CategoryTheory.Limits.kernel (CategoryTheory.Limits.cokernel.desc S.f S.g ⋯))","decl":"/-- The chosen cokernels and kernels of the limits API give a `RightHomologyData` -/\n@[simps]\nnoncomputable def ofHasCokernelOfHasKernel\n    [HasCokernel S.f] [HasKernel (cokernel.desc S.f S.g S.zero)] :\n    S.RightHomologyData :=\n{ Q := cokernel S.f,\n  H := kernel (cokernel.desc S.f S.g S.zero),\n  p := cokernel.π _,\n  ι := kernel.ι _,\n  wp := cokernel.condition _,\n  hp := cokernelIsCokernel _,\n  wι := kernel.condition _,\n  hι := kernelIsKernel _, }\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofHasCokernelOfHasKernel_Q","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Limits.HasCokernel S.f\ninst✝ : CategoryTheory.Limits.HasKernel (CategoryTheory.Limits.cokernel.desc S.f S.g ⋯)\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofHasCokernelOfHasKernel S).Q (CategoryTheory.Limits.cokernel S.f)","decl":"/-- The chosen cokernels and kernels of the limits API give a `RightHomologyData` -/\n@[simps]\nnoncomputable def ofHasCokernelOfHasKernel\n    [HasCokernel S.f] [HasKernel (cokernel.desc S.f S.g S.zero)] :\n    S.RightHomologyData :=\n{ Q := cokernel S.f,\n  H := kernel (cokernel.desc S.f S.g S.zero),\n  p := cokernel.π _,\n  ι := kernel.ι _,\n  wp := cokernel.condition _,\n  hp := cokernelIsCokernel _,\n  wι := kernel.condition _,\n  hι := kernelIsKernel _, }\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofHasCokernelOfHasKernel_ι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Limits.HasCokernel S.f\ninst✝ : CategoryTheory.Limits.HasKernel (CategoryTheory.Limits.cokernel.desc S.f S.g ⋯)\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofHasCokernelOfHasKernel S).ι (CategoryTheory.Limits.kernel.ι (CategoryTheory.Limits.cokernel.desc S.f S.g ⋯))","decl":"/-- The chosen cokernels and kernels of the limits API give a `RightHomologyData` -/\n@[simps]\nnoncomputable def ofHasCokernelOfHasKernel\n    [HasCokernel S.f] [HasKernel (cokernel.desc S.f S.g S.zero)] :\n    S.RightHomologyData :=\n{ Q := cokernel S.f,\n  H := kernel (cokernel.desc S.f S.g S.zero),\n  p := cokernel.π _,\n  ι := kernel.ι _,\n  wp := cokernel.condition _,\n  hp := cokernelIsCokernel _,\n  wι := kernel.condition _,\n  hι := kernelIsKernel _, }\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.wp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.RightHomologyData\nZ : C\nh : Quiver.Hom self.Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.f (CategoryTheory.CategoryStruct.comp self.p h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)] wp wι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.wι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.RightHomologyData\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.CokernelCofork.ofπ S.g ⋯).pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.ι (CategoryTheory.CategoryStruct.comp (self.hp.desc (CategoryTheory.Limits.CokernelCofork.ofπ S.g ⋯)) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)] wp wι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.instEpiP","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ CategoryTheory.Epi h.p","decl":"instance : Epi h.p := ⟨fun _ _ => Cofork.IsColimit.hom_ext h.hp⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.instMonoι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ CategoryTheory.Mono h.ι","decl":"instance : Mono h.ι := ⟨fun _ _ => Fork.IsLimit.hom_ext h.hι⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.p_descQ_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.RightHomologyData\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.p (CategoryTheory.CategoryStruct.comp (h✝.descQ k hk) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma p_descQ (k : S.X₂ ⟶ A) (hk : S.f ≫ k = 0) : h.p ≫ h.descQ k hk = k :=\n  h.hp.fac _ WalkingParallelPair.one\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.p_descQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.p (h.descQ k hk)) k","decl":"@[reassoc (attr := simp)]\nlemma p_descQ (k : S.X₂ ⟶ A) (hk : S.f ≫ k = 0) : h.p ≫ h.descQ k hk = k :=\n  h.hp.fac _ WalkingParallelPair.one\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.p_g'_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.RightHomologyData\nZ : C\nh : Quiver.Hom S.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.p (CategoryTheory.CategoryStruct.comp h✝.g' h)) (CategoryTheory.CategoryStruct.comp S.g h)","decl":"@[reassoc (attr := simp)] lemma p_g' : h.p ≫ h.g' = S.g := p_descQ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.p_g'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.p h.g') S.g","decl":"@[reassoc (attr := simp)] lemma p_g' : h.p ≫ h.g' = S.g := p_descQ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ι_g'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.ι h.g') 0","decl":"@[reassoc (attr := simp)] lemma ι_g' : h.ι ≫ h.g' = 0 := h.wι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ι_g'_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.RightHomologyData\nZ : C\nh : Quiver.Hom S.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.ι (CategoryTheory.CategoryStruct.comp h✝.g' h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)] lemma ι_g' : h.ι ≫ h.g' = 0 := h.wι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ι_descQ_eq_zero_of_boundary","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nA : C\nk : Quiver.Hom S.X₂ A\nx : Quiver.Hom S.X₃ A\nhx : Eq k (CategoryTheory.CategoryStruct.comp S.g x)\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.ι (h.descQ k ⋯)) 0","decl":"@[reassoc]\nlemma ι_descQ_eq_zero_of_boundary (k : S.X₂ ⟶ A) (x : S.X₃ ⟶ A) (hx : k = S.g ≫ x) :\n    h.ι ≫ h.descQ k (by rw [hx, S.zero_assoc, zero_comp]) = 0 := by\n  rw [show 0 = h.ι ≫ h.g' ≫ x by simp]\n  congr 1\n  simp only [← cancel_epi h.p, hx, p_descQ, p_g'_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ι_descQ_eq_zero_of_boundary_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.RightHomologyData\nA : C\nk : Quiver.Hom S.X₂ A\nx : Quiver.Hom S.X₃ A\nhx : Eq k (CategoryTheory.CategoryStruct.comp S.g x)\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.ι (CategoryTheory.CategoryStruct.comp (h✝.descQ k ⋯) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma ι_descQ_eq_zero_of_boundary (k : S.X₂ ⟶ A) (x : S.X₃ ⟶ A) (hx : k = S.g ≫ x) :\n    h.ι ≫ h.descQ k (by rw [hx, S.zero_assoc, zero_comp]) = 0 := by\n  rw [show 0 = h.ι ≫ h.g' ≫ x by simp]\n  congr 1\n  simp only [← cancel_epi h.p, hx, p_descQ, p_g'_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.liftH_ι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nA : C\nk : Quiver.Hom A h.Q\nhk : Eq (CategoryTheory.CategoryStruct.comp k h.g') 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (h.liftH k hk) h.ι) k","decl":"@[reassoc (attr := simp)]\nlemma liftH_ι (k : A ⟶ h.Q) (hk : k ≫ h.g' = 0) : h.liftH k hk ≫ h.ι = k :=\n  h.hι.fac (KernelFork.ofι k hk) WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.liftH_ι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.RightHomologyData\nA : C\nk : Quiver.Hom A h✝.Q\nhk : Eq (CategoryTheory.CategoryStruct.comp k h✝.g') 0\nZ : C\nh : Quiver.Hom h✝.Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (h✝.liftH k hk) (CategoryTheory.CategoryStruct.comp h✝.ι h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma liftH_ι (k : A ⟶ h.Q) (hk : k ≫ h.g' = 0) : h.liftH k hk ≫ h.ι = k :=\n  h.hι.fac (KernelFork.ofι k hk) WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.isIso_p","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nhf : Eq S.f 0\n⊢ CategoryTheory.IsIso h.p","decl":"lemma isIso_p (hf : S.f = 0) : IsIso h.p :=\n  ⟨h.descQ (𝟙 S.X₂) (by rw [hf, comp_id]), p_descQ _ _ _, by\n    simp only [← cancel_epi h.p, p_descQ_assoc, id_comp, comp_id]⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.isIso_ι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nhg : Eq S.g 0\n⊢ CategoryTheory.IsIso h.ι","decl":"lemma isIso_ι (hg : S.g = 0) : IsIso h.ι := by\n  have ⟨φ, hφ⟩ := KernelFork.IsLimit.lift' h.hι' (𝟙 _)\n    (by rw [← cancel_epi h.p, id_comp, p_g', comp_zero, hg])\n  dsimp at hφ\n  exact ⟨φ, by rw [← cancel_mono h.ι, assoc, hφ, comp_id, id_comp], hφ⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork_ι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork S hf c hc).ι (CategoryTheory.Limits.Fork.ι c)","decl":"/-- When the first map `S.f` is zero, this is the right homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.RightHomologyData where\n  Q := S.X₂\n  H := c.pt\n  p := 𝟙 _\n  ι := c.ι\n  wp := by rw [comp_id, hf]\n  hp := CokernelCofork.IsColimit.ofId _ hf\n  wι := KernelFork.condition _\n  hι := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork_H","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork S hf c hc).H c.pt","decl":"/-- When the first map `S.f` is zero, this is the right homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.RightHomologyData where\n  Q := S.X₂\n  H := c.pt\n  p := 𝟙 _\n  ι := c.ι\n  wp := by rw [comp_id, hf]\n  hp := CokernelCofork.IsColimit.ofId _ hf\n  wι := KernelFork.condition _\n  hι := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork_Q","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork S hf c hc).Q S.X₂","decl":"/-- When the first map `S.f` is zero, this is the right homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.RightHomologyData where\n  Q := S.X₂\n  H := c.pt\n  p := 𝟙 _\n  ι := c.ι\n  wp := by rw [comp_id, hf]\n  hp := CokernelCofork.IsColimit.ofId _ hf\n  wι := KernelFork.condition _\n  hι := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork_p","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork S hf c hc).p (CategoryTheory.CategoryStruct.id S.X₂)","decl":"/-- When the first map `S.f` is zero, this is the right homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.RightHomologyData where\n  Q := S.X₂\n  H := c.pt\n  p := 𝟙 _\n  ι := c.ι\n  wp := by rw [comp_id, hf]\n  hp := CokernelCofork.IsColimit.ofId _ hf\n  wι := KernelFork.condition _\n  hι := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _) (by simp))\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork_g'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork S hf c hc).g' S.g","decl":"@[simp] lemma ofIsLimitKernelFork_g' (hf : S.f = 0) (c : KernelFork S.g)\n    (hc : IsLimit c) : (ofIsLimitKernelFork S hf c hc).g' = S.g := by\n  rw [← cancel_epi (ofIsLimitKernelFork S hf c hc).p, p_g',\n    ofIsLimitKernelFork_p, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofHasKernel_p","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasKernel S.g\nhf : Eq S.f 0\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofHasKernel S hf).p (CategoryTheory.CategoryStruct.id S.X₂)","decl":"/-- When the first map `S.f` is zero, this is the right homology data on `S` given by\nthe chosen `kernel S.g` -/\n@[simps!]\nnoncomputable def ofHasKernel [HasKernel S.g] (hf : S.f = 0) : S.RightHomologyData :=\nofIsLimitKernelFork S hf _ (kernelIsKernel _)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofHasKernel_H","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasKernel S.g\nhf : Eq S.f 0\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofHasKernel S hf).H (CategoryTheory.Limits.kernel S.g)","decl":"/-- When the first map `S.f` is zero, this is the right homology data on `S` given by\nthe chosen `kernel S.g` -/\n@[simps!]\nnoncomputable def ofHasKernel [HasKernel S.g] (hf : S.f = 0) : S.RightHomologyData :=\nofIsLimitKernelFork S hf _ (kernelIsKernel _)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofHasKernel_Q","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasKernel S.g\nhf : Eq S.f 0\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofHasKernel S hf).Q S.X₂","decl":"/-- When the first map `S.f` is zero, this is the right homology data on `S` given by\nthe chosen `kernel S.g` -/\n@[simps!]\nnoncomputable def ofHasKernel [HasKernel S.g] (hf : S.f = 0) : S.RightHomologyData :=\nofIsLimitKernelFork S hf _ (kernelIsKernel _)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofHasKernel_ι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasKernel S.g\nhf : Eq S.f 0\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofHasKernel S hf).ι (CategoryTheory.Limits.kernel.ι S.g)","decl":"/-- When the first map `S.f` is zero, this is the right homology data on `S` given by\nthe chosen `kernel S.g` -/\n@[simps!]\nnoncomputable def ofHasKernel [HasKernel S.g] (hf : S.f = 0) : S.RightHomologyData :=\nofIsLimitKernelFork S hf _ (kernelIsKernel _)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofIsColimitCokernelCofork_Q","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofIsColimitCokernelCofork S hg c hc).Q c.pt","decl":"/-- When the second map `S.g` is zero, this is the right homology data on `S` given\nby any colimit cokernel cofork of `S.g` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.RightHomologyData where\n  Q := c.pt\n  H := c.pt\n  p := c.π\n  ι := 𝟙 _\n  wp := CokernelCofork.condition _\n  hp := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _) (by simp))\n  wι := Cofork.IsColimit.hom_ext hc (by simp [hg])\n  hι := KernelFork.IsLimit.ofId _ (Cofork.IsColimit.hom_ext hc (by simp [hg]))\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofIsColimitCokernelCofork_H","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofIsColimitCokernelCofork S hg c hc).H c.pt","decl":"/-- When the second map `S.g` is zero, this is the right homology data on `S` given\nby any colimit cokernel cofork of `S.g` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.RightHomologyData where\n  Q := c.pt\n  H := c.pt\n  p := c.π\n  ι := 𝟙 _\n  wp := CokernelCofork.condition _\n  hp := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _) (by simp))\n  wι := Cofork.IsColimit.hom_ext hc (by simp [hg])\n  hι := KernelFork.IsLimit.ofId _ (Cofork.IsColimit.hom_ext hc (by simp [hg]))\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofIsColimitCokernelCofork_ι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofIsColimitCokernelCofork S hg c hc).ι (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- When the second map `S.g` is zero, this is the right homology data on `S` given\nby any colimit cokernel cofork of `S.g` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.RightHomologyData where\n  Q := c.pt\n  H := c.pt\n  p := c.π\n  ι := 𝟙 _\n  wp := CokernelCofork.condition _\n  hp := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _) (by simp))\n  wι := Cofork.IsColimit.hom_ext hc (by simp [hg])\n  hι := KernelFork.IsLimit.ofId _ (Cofork.IsColimit.hom_ext hc (by simp [hg]))\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofIsColimitCokernelCofork_p","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofIsColimitCokernelCofork S hg c hc).p (CategoryTheory.Limits.Cofork.π c)","decl":"/-- When the second map `S.g` is zero, this is the right homology data on `S` given\nby any colimit cokernel cofork of `S.g` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.RightHomologyData where\n  Q := c.pt\n  H := c.pt\n  p := c.π\n  ι := 𝟙 _\n  wp := CokernelCofork.condition _\n  hp := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _) (by simp))\n  wι := Cofork.IsColimit.hom_ext hc (by simp [hg])\n  hι := KernelFork.IsLimit.ofId _ (Cofork.IsColimit.hom_ext hc (by simp [hg]))\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofIsColimitCokernelCofork_g'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofIsColimitCokernelCofork S hg c hc).g' 0","decl":"@[simp] lemma ofIsColimitCokernelCofork_g' (hg : S.g = 0) (c : CokernelCofork S.f)\n  (hc : IsColimit c) : (ofIsColimitCokernelCofork S hg c hc).g' = 0 := by\n  rw [← cancel_epi (ofIsColimitCokernelCofork S hg c hc).p, p_g', hg, comp_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofZeros_p","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofZeros S hf hg).p (CategoryTheory.CategoryStruct.id S.X₂)","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X₂`\ngives a right homology data on S -/\n@[simps]\ndef ofZeros (hf : S.f = 0) (hg : S.g = 0) : S.RightHomologyData where\n  Q := S.X₂\n  H := S.X₂\n  p := 𝟙 _\n  ι := 𝟙 _\n  wp := by rw [comp_id, hf]\n  hp := CokernelCofork.IsColimit.ofId _ hf\n  wι := by\n    change 𝟙 _ ≫ S.g = 0\n    simp only [hg, comp_zero]\n  hι := KernelFork.IsLimit.ofId _ hg\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofZeros_ι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofZeros S hf hg).ι (CategoryTheory.CategoryStruct.id S.X₂)","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X₂`\ngives a right homology data on S -/\n@[simps]\ndef ofZeros (hf : S.f = 0) (hg : S.g = 0) : S.RightHomologyData where\n  Q := S.X₂\n  H := S.X₂\n  p := 𝟙 _\n  ι := 𝟙 _\n  wp := by rw [comp_id, hf]\n  hp := CokernelCofork.IsColimit.ofId _ hf\n  wι := by\n    change 𝟙 _ ≫ S.g = 0\n    simp only [hg, comp_zero]\n  hι := KernelFork.IsLimit.ofId _ hg\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofZeros_Q","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofZeros S hf hg).Q S.X₂","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X₂`\ngives a right homology data on S -/\n@[simps]\ndef ofZeros (hf : S.f = 0) (hg : S.g = 0) : S.RightHomologyData where\n  Q := S.X₂\n  H := S.X₂\n  p := 𝟙 _\n  ι := 𝟙 _\n  wp := by rw [comp_id, hf]\n  hp := CokernelCofork.IsColimit.ofId _ hf\n  wι := by\n    change 𝟙 _ ≫ S.g = 0\n    simp only [hg, comp_zero]\n  hι := KernelFork.IsLimit.ofId _ hg\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofZeros_H","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofZeros S hf hg).H S.X₂","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X₂`\ngives a right homology data on S -/\n@[simps]\ndef ofZeros (hf : S.f = 0) (hg : S.g = 0) : S.RightHomologyData where\n  Q := S.X₂\n  H := S.X₂\n  p := 𝟙 _\n  ι := 𝟙 _\n  wp := by rw [comp_id, hf]\n  hp := CokernelCofork.IsColimit.ofId _ hf\n  wι := by\n    change 𝟙 _ ≫ S.g = 0\n    simp only [hg, comp_zero]\n  hι := KernelFork.IsLimit.ofId _ hg\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofZeros_g'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofZeros S hf hg).g' 0","decl":"@[simp]\nlemma ofZeros_g' (hf : S.f = 0) (hg : S.g = 0) :\n    (ofZeros S hf hg).g' = 0 := by\n  rw [← cancel_epi ((ofZeros S hf hg).p), comp_zero, p_g', hg]\n\n"}
{"name":"CategoryTheory.ShortComplex.HasRightHomology.condition","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.HasRightHomology\n⊢ Nonempty S.RightHomologyData","decl":"/-- A short complex `S` has right homology when there exists a `S.RightHomologyData` -/\nclass HasRightHomology : Prop where\n  condition : Nonempty S.RightHomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.HasRightHomology.mk'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ S.HasRightHomology","decl":"lemma mk' (h : S.RightHomologyData) : HasRightHomology S := ⟨Nonempty.intro h⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.HasRightHomology.of_hasCokernel_of_hasKernel","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : CategoryTheory.Limits.HasCokernel S.f\ninst✝ : CategoryTheory.Limits.HasKernel (CategoryTheory.Limits.cokernel.desc S.f S.g ⋯)\n⊢ S.HasRightHomology","decl":"instance of_hasCokernel_of_hasKernel\n    [HasCokernel S.f] [HasKernel (cokernel.desc S.f S.g S.zero)] :\n  S.HasRightHomology := HasRightHomology.mk' (RightHomologyData.ofHasCokernelOfHasKernel S)\n\n"}
{"name":"CategoryTheory.ShortComplex.HasRightHomology.of_hasKernel","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nY Z : C\ng : Quiver.Hom Y Z\nX : C\ninst✝ : CategoryTheory.Limits.HasKernel g\n⊢ (CategoryTheory.ShortComplex.mk 0 g ⋯).HasRightHomology","decl":"instance of_hasKernel {Y Z : C} (g : Y ⟶ Z) (X : C) [HasKernel g] :\n    (ShortComplex.mk (0 : X ⟶ Y) g zero_comp).HasRightHomology :=\n  HasRightHomology.mk' (RightHomologyData.ofHasKernel _ rfl)\n\n"}
{"name":"CategoryTheory.ShortComplex.HasRightHomology.of_hasCokernel","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ninst✝ : CategoryTheory.Limits.HasCokernel f\n⊢ (CategoryTheory.ShortComplex.mk f 0 ⋯).HasRightHomology","decl":"instance of_hasCokernel {X Y : C} (f : X ⟶ Y) (Z : C) [HasCokernel f] :\n    (ShortComplex.mk f (0 : Y ⟶ Z) comp_zero).HasRightHomology :=\n  HasRightHomology.mk' (RightHomologyData.ofHasCokernel _ rfl)\n\n"}
{"name":"CategoryTheory.ShortComplex.HasRightHomology.of_zeros","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\n⊢ (CategoryTheory.ShortComplex.mk 0 0 ⋯).HasRightHomology","decl":"instance of_zeros (X Y Z : C) :\n    (ShortComplex.mk (0 : X ⟶ Y) (0 : Y ⟶ Z) zero_comp).HasRightHomology :=\n  HasRightHomology.mk' (RightHomologyData.ofZeros _ rfl rfl)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.op_π","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ Eq h.op.π h.ι.op","decl":"/-- A right homology data for a short complex `S` induces a left homology data for `S.op`. -/\n@[simps]\ndef op (h : S.RightHomologyData) : S.op.LeftHomologyData where\n  K := Opposite.op h.Q\n  H := Opposite.op h.H\n  i := h.p.op\n  π := h.ι.op\n  wi := Quiver.Hom.unop_inj h.wp\n  hi := CokernelCofork.IsColimit.ofπOp _ _ h.hp\n  wπ := Quiver.Hom.unop_inj h.wι\n  hπ := KernelFork.IsLimit.ofιOp _ _ h.hι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.op_K","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ Eq h.op.K { unop := h.Q }","decl":"/-- A right homology data for a short complex `S` induces a left homology data for `S.op`. -/\n@[simps]\ndef op (h : S.RightHomologyData) : S.op.LeftHomologyData where\n  K := Opposite.op h.Q\n  H := Opposite.op h.H\n  i := h.p.op\n  π := h.ι.op\n  wi := Quiver.Hom.unop_inj h.wp\n  hi := CokernelCofork.IsColimit.ofπOp _ _ h.hp\n  wπ := Quiver.Hom.unop_inj h.wι\n  hπ := KernelFork.IsLimit.ofιOp _ _ h.hι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.op_i","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ Eq h.op.i h.p.op","decl":"/-- A right homology data for a short complex `S` induces a left homology data for `S.op`. -/\n@[simps]\ndef op (h : S.RightHomologyData) : S.op.LeftHomologyData where\n  K := Opposite.op h.Q\n  H := Opposite.op h.H\n  i := h.p.op\n  π := h.ι.op\n  wi := Quiver.Hom.unop_inj h.wp\n  hi := CokernelCofork.IsColimit.ofπOp _ _ h.hp\n  wπ := Quiver.Hom.unop_inj h.wι\n  hπ := KernelFork.IsLimit.ofιOp _ _ h.hι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.op_H","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ Eq h.op.H { unop := h.H }","decl":"/-- A right homology data for a short complex `S` induces a left homology data for `S.op`. -/\n@[simps]\ndef op (h : S.RightHomologyData) : S.op.LeftHomologyData where\n  K := Opposite.op h.Q\n  H := Opposite.op h.H\n  i := h.p.op\n  π := h.ι.op\n  wi := Quiver.Hom.unop_inj h.wp\n  hi := CokernelCofork.IsColimit.ofπOp _ _ h.hp\n  wπ := Quiver.Hom.unop_inj h.wι\n  hπ := KernelFork.IsLimit.ofιOp _ _ h.hι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.op_f'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ Eq h.op.f' h.g'.op","decl":"@[simp] lemma op_f' (h : S.RightHomologyData) :\n    h.op.f' = h.g'.op := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.unop_i","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.RightHomologyData\n⊢ Eq h.unop.i h.p.unop","decl":"/-- A right homology data for a short complex `S` in the opposite category\ninduces a left homology data for `S.unop`. -/\n@[simps]\ndef unop {S : ShortComplex Cᵒᵖ} (h : S.RightHomologyData) : S.unop.LeftHomologyData where\n  K := Opposite.unop h.Q\n  H := Opposite.unop h.H\n  i := h.p.unop\n  π := h.ι.unop\n  wi := Quiver.Hom.op_inj h.wp\n  hi := CokernelCofork.IsColimit.ofπUnop _ _ h.hp\n  wπ := Quiver.Hom.op_inj h.wι\n  hπ := KernelFork.IsLimit.ofιUnop _ _ h.hι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.unop_H","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.RightHomologyData\n⊢ Eq h.unop.H (Opposite.unop h.H)","decl":"/-- A right homology data for a short complex `S` in the opposite category\ninduces a left homology data for `S.unop`. -/\n@[simps]\ndef unop {S : ShortComplex Cᵒᵖ} (h : S.RightHomologyData) : S.unop.LeftHomologyData where\n  K := Opposite.unop h.Q\n  H := Opposite.unop h.H\n  i := h.p.unop\n  π := h.ι.unop\n  wi := Quiver.Hom.op_inj h.wp\n  hi := CokernelCofork.IsColimit.ofπUnop _ _ h.hp\n  wπ := Quiver.Hom.op_inj h.wι\n  hπ := KernelFork.IsLimit.ofιUnop _ _ h.hι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.unop_π","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.RightHomologyData\n⊢ Eq h.unop.π h.ι.unop","decl":"/-- A right homology data for a short complex `S` in the opposite category\ninduces a left homology data for `S.unop`. -/\n@[simps]\ndef unop {S : ShortComplex Cᵒᵖ} (h : S.RightHomologyData) : S.unop.LeftHomologyData where\n  K := Opposite.unop h.Q\n  H := Opposite.unop h.H\n  i := h.p.unop\n  π := h.ι.unop\n  wi := Quiver.Hom.op_inj h.wp\n  hi := CokernelCofork.IsColimit.ofπUnop _ _ h.hp\n  wπ := Quiver.Hom.op_inj h.wι\n  hπ := KernelFork.IsLimit.ofιUnop _ _ h.hι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.unop_K","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.RightHomologyData\n⊢ Eq h.unop.K (Opposite.unop h.Q)","decl":"/-- A right homology data for a short complex `S` in the opposite category\ninduces a left homology data for `S.unop`. -/\n@[simps]\ndef unop {S : ShortComplex Cᵒᵖ} (h : S.RightHomologyData) : S.unop.LeftHomologyData where\n  K := Opposite.unop h.Q\n  H := Opposite.unop h.H\n  i := h.p.unop\n  π := h.ι.unop\n  wi := Quiver.Hom.op_inj h.wp\n  hi := CokernelCofork.IsColimit.ofπUnop _ _ h.hp\n  wπ := Quiver.Hom.op_inj h.wι\n  hπ := KernelFork.IsLimit.ofιUnop _ _ h.hι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.unop_f'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.RightHomologyData\n⊢ Eq h.unop.f' h.g'.unop","decl":"@[simp] lemma unop_f' {S : ShortComplex Cᵒᵖ} (h : S.RightHomologyData) :\n    h.unop.f' = h.g'.unop := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.op_ι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ Eq h.op.ι h.π.op","decl":"/-- A left homology data for a short complex `S` induces a right homology data for `S.op`. -/\n@[simps]\ndef op (h : S.LeftHomologyData) : S.op.RightHomologyData where\n  Q := Opposite.op h.K\n  H := Opposite.op h.H\n  p := h.i.op\n  ι := h.π.op\n  wp := Quiver.Hom.unop_inj h.wi\n  hp := KernelFork.IsLimit.ofιOp _ _ h.hi\n  wι := Quiver.Hom.unop_inj h.wπ\n  hι := CokernelCofork.IsColimit.ofπOp _ _ h.hπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.op_p","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ Eq h.op.p h.i.op","decl":"/-- A left homology data for a short complex `S` induces a right homology data for `S.op`. -/\n@[simps]\ndef op (h : S.LeftHomologyData) : S.op.RightHomologyData where\n  Q := Opposite.op h.K\n  H := Opposite.op h.H\n  p := h.i.op\n  ι := h.π.op\n  wp := Quiver.Hom.unop_inj h.wi\n  hp := KernelFork.IsLimit.ofιOp _ _ h.hi\n  wι := Quiver.Hom.unop_inj h.wπ\n  hι := CokernelCofork.IsColimit.ofπOp _ _ h.hπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.op_H","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ Eq h.op.H { unop := h.H }","decl":"/-- A left homology data for a short complex `S` induces a right homology data for `S.op`. -/\n@[simps]\ndef op (h : S.LeftHomologyData) : S.op.RightHomologyData where\n  Q := Opposite.op h.K\n  H := Opposite.op h.H\n  p := h.i.op\n  ι := h.π.op\n  wp := Quiver.Hom.unop_inj h.wi\n  hp := KernelFork.IsLimit.ofιOp _ _ h.hi\n  wι := Quiver.Hom.unop_inj h.wπ\n  hι := CokernelCofork.IsColimit.ofπOp _ _ h.hπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.op_Q","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ Eq h.op.Q { unop := h.K }","decl":"/-- A left homology data for a short complex `S` induces a right homology data for `S.op`. -/\n@[simps]\ndef op (h : S.LeftHomologyData) : S.op.RightHomologyData where\n  Q := Opposite.op h.K\n  H := Opposite.op h.H\n  p := h.i.op\n  ι := h.π.op\n  wp := Quiver.Hom.unop_inj h.wi\n  hp := KernelFork.IsLimit.ofιOp _ _ h.hi\n  wι := Quiver.Hom.unop_inj h.wπ\n  hι := CokernelCofork.IsColimit.ofπOp _ _ h.hπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.op_g'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.LeftHomologyData\n⊢ Eq h.op.g' h.f'.op","decl":"@[simp] lemma op_g' (h : S.LeftHomologyData) :\n    h.op.g' = h.f'.op := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.unop_ι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.LeftHomologyData\n⊢ Eq h.unop.ι h.π.unop","decl":"/-- A left homology data for a short complex `S` in the opposite category\ninduces a right homology data for `S.unop`. -/\n@[simps]\ndef unop {S : ShortComplex Cᵒᵖ} (h : S.LeftHomologyData) : S.unop.RightHomologyData where\n  Q := Opposite.unop h.K\n  H := Opposite.unop h.H\n  p := h.i.unop\n  ι := h.π.unop\n  wp := Quiver.Hom.op_inj h.wi\n  hp := KernelFork.IsLimit.ofιUnop _ _ h.hi\n  wι := Quiver.Hom.op_inj h.wπ\n  hι := CokernelCofork.IsColimit.ofπUnop _ _ h.hπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.unop_p","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.LeftHomologyData\n⊢ Eq h.unop.p h.i.unop","decl":"/-- A left homology data for a short complex `S` in the opposite category\ninduces a right homology data for `S.unop`. -/\n@[simps]\ndef unop {S : ShortComplex Cᵒᵖ} (h : S.LeftHomologyData) : S.unop.RightHomologyData where\n  Q := Opposite.unop h.K\n  H := Opposite.unop h.H\n  p := h.i.unop\n  ι := h.π.unop\n  wp := Quiver.Hom.op_inj h.wi\n  hp := KernelFork.IsLimit.ofιUnop _ _ h.hi\n  wι := Quiver.Hom.op_inj h.wπ\n  hι := CokernelCofork.IsColimit.ofπUnop _ _ h.hπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.unop_Q","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.LeftHomologyData\n⊢ Eq h.unop.Q (Opposite.unop h.K)","decl":"/-- A left homology data for a short complex `S` in the opposite category\ninduces a right homology data for `S.unop`. -/\n@[simps]\ndef unop {S : ShortComplex Cᵒᵖ} (h : S.LeftHomologyData) : S.unop.RightHomologyData where\n  Q := Opposite.unop h.K\n  H := Opposite.unop h.H\n  p := h.i.unop\n  ι := h.π.unop\n  wp := Quiver.Hom.op_inj h.wi\n  hp := KernelFork.IsLimit.ofιUnop _ _ h.hi\n  wι := Quiver.Hom.op_inj h.wπ\n  hι := CokernelCofork.IsColimit.ofπUnop _ _ h.hπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.unop_H","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.LeftHomologyData\n⊢ Eq h.unop.H (Opposite.unop h.H)","decl":"/-- A left homology data for a short complex `S` in the opposite category\ninduces a right homology data for `S.unop`. -/\n@[simps]\ndef unop {S : ShortComplex Cᵒᵖ} (h : S.LeftHomologyData) : S.unop.RightHomologyData where\n  Q := Opposite.unop h.K\n  H := Opposite.unop h.H\n  p := h.i.unop\n  ι := h.π.unop\n  wp := Quiver.Hom.op_inj h.wi\n  hp := KernelFork.IsLimit.ofιUnop _ _ h.hi\n  wι := Quiver.Hom.op_inj h.wπ\n  hι := CokernelCofork.IsColimit.ofπUnop _ _ h.hπ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.unop_g'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.LeftHomologyData\n⊢ Eq h.unop.g' h.f'.unop","decl":"@[simp] lemma unop_g' {S : ShortComplex Cᵒᵖ} (h : S.LeftHomologyData) :\n    h.unop.g' = h.f'.unop := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.instHasRightHomologyOppositeOpOfHasLeftHomology","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\n⊢ S.op.HasRightHomology","decl":"instance [S.HasLeftHomology] : HasRightHomology S.op :=\n  HasRightHomology.mk' S.leftHomologyData.op\n\n"}
{"name":"CategoryTheory.ShortComplex.instHasLeftHomologyOppositeOpOfHasRightHomology","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\n⊢ S.op.HasLeftHomology","decl":"instance [S.HasRightHomology] : HasLeftHomology S.op :=\n  HasLeftHomology.mk' S.rightHomologyData.op\n\n"}
{"name":"CategoryTheory.ShortComplex.hasLeftHomology_iff_op","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\n⊢ Iff S.HasLeftHomology S.op.HasRightHomology","decl":"lemma hasLeftHomology_iff_op (S : ShortComplex C) :\n    S.HasLeftHomology ↔ S.op.HasRightHomology :=\n  ⟨fun _ => inferInstance, fun _ => HasLeftHomology.mk' S.op.rightHomologyData.unop⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.hasRightHomology_iff_op","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\n⊢ Iff S.HasRightHomology S.op.HasLeftHomology","decl":"lemma hasRightHomology_iff_op (S : ShortComplex C) :\n    S.HasRightHomology ↔ S.op.HasLeftHomology :=\n  ⟨fun _ => inferInstance, fun _ => HasRightHomology.mk' S.op.leftHomologyData.unop⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.hasLeftHomology_iff_unop","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\n⊢ Iff S.HasLeftHomology S.unop.HasRightHomology","decl":"lemma hasLeftHomology_iff_unop (S : ShortComplex Cᵒᵖ) :\n    S.HasLeftHomology ↔ S.unop.HasRightHomology :=\n  S.unop.hasRightHomology_iff_op.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.hasRightHomology_iff_unop","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\n⊢ Iff S.HasRightHomology S.unop.HasLeftHomology","decl":"lemma hasRightHomology_iff_unop (S : ShortComplex Cᵒᵖ) :\n    S.HasRightHomology ↔ S.unop.HasLeftHomology :=\n  S.unop.hasLeftHomology_iff_op.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.commg'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nself : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.φQ h₂.g') (CategoryTheory.CategoryStruct.comp h₁.g' φ.τ₃)","decl":"/-- Given right homology data `h₁` and `h₂` for two short complexes `S₁` and `S₂`,\na `RightHomologyMapData` for a morphism `φ : S₁ ⟶ S₂`\nconsists of a description of the induced morphisms on the `Q` (opcycles)\nand `H` (right homology) fields of `h₁` and `h₂`. -/\nstructure RightHomologyMapData where\n  /-- the induced map on opcycles -/\n  φQ : h₁.Q ⟶ h₂.Q\n  /-- the induced map on right homology -/\n  φH : h₁.H ⟶ h₂.H\n  /-- commutation with `p` -/\n  commp : h₁.p ≫ φQ = φ.τ₂ ≫ h₂.p := by aesop_cat\n  /-- commutation with `g'` -/\n  commg' : φQ ≫ h₂.g' = h₁.g' ≫ φ.τ₃ := by aesop_cat\n  /-- commutation with `ι` -/\n  commι : φH ≫ h₂.ι = h₁.ι ≫ φQ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.commι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nself : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.φH h₂.ι) (CategoryTheory.CategoryStruct.comp h₁.ι self.φQ)","decl":"/-- Given right homology data `h₁` and `h₂` for two short complexes `S₁` and `S₂`,\na `RightHomologyMapData` for a morphism `φ : S₁ ⟶ S₂`\nconsists of a description of the induced morphisms on the `Q` (opcycles)\nand `H` (right homology) fields of `h₁` and `h₂`. -/\nstructure RightHomologyMapData where\n  /-- the induced map on opcycles -/\n  φQ : h₁.Q ⟶ h₂.Q\n  /-- the induced map on right homology -/\n  φH : h₁.H ⟶ h₂.H\n  /-- commutation with `p` -/\n  commp : h₁.p ≫ φQ = φ.τ₂ ≫ h₂.p := by aesop_cat\n  /-- commutation with `g'` -/\n  commg' : φQ ≫ h₂.g' = h₁.g' ≫ φ.τ₃ := by aesop_cat\n  /-- commutation with `ι` -/\n  commι : φH ≫ h₂.ι = h₁.ι ≫ φQ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.commp","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nself : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.p self.φQ) (CategoryTheory.CategoryStruct.comp φ.τ₂ h₂.p)","decl":"/-- Given right homology data `h₁` and `h₂` for two short complexes `S₁` and `S₂`,\na `RightHomologyMapData` for a morphism `φ : S₁ ⟶ S₂`\nconsists of a description of the induced morphisms on the `Q` (opcycles)\nand `H` (right homology) fields of `h₁` and `h₂`. -/\nstructure RightHomologyMapData where\n  /-- the induced map on opcycles -/\n  φQ : h₁.Q ⟶ h₂.Q\n  /-- the induced map on right homology -/\n  φH : h₁.H ⟶ h₂.H\n  /-- commutation with `p` -/\n  commp : h₁.p ≫ φQ = φ.τ₂ ≫ h₂.p := by aesop_cat\n  /-- commutation with `g'` -/\n  commg' : φQ ≫ h₂.g' = h₁.g' ≫ φ.τ₃ := by aesop_cat\n  /-- commutation with `ι` -/\n  commι : φH ≫ h₂.ι = h₁.ι ≫ φQ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.mk.inj","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nφQ✝ : Quiver.Hom h₁.Q h₂.Q\nφH✝ : Quiver.Hom h₁.H h₂.H\ncommp✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.p φQ✝) (CategoryTheory.CategoryStruct.comp φ.τ₂ h₂.p)) _auto✝\ncommg'✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp φQ✝ h₂.g') (CategoryTheory.CategoryStruct.comp h₁.g' φ.τ₃)) _auto✝\ncommι✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp φH✝ h₂.ι) (CategoryTheory.CategoryStruct.comp h₁.ι φQ✝)) _auto✝\nφQ : Quiver.Hom h₁.Q h₂.Q\nφH : Quiver.Hom h₁.H h₂.H\ncommp : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.p φQ) (CategoryTheory.CategoryStruct.comp φ.τ₂ h₂.p)) _auto✝\ncommg' : autoParam (Eq (CategoryTheory.CategoryStruct.comp φQ h₂.g') (CategoryTheory.CategoryStruct.comp h₁.g' φ.τ₃)) _auto✝\ncommι : autoParam (Eq (CategoryTheory.CategoryStruct.comp φH h₂.ι) (CategoryTheory.CategoryStruct.comp h₁.ι φQ)) _auto✝\nx✝ : Eq { φQ := φQ✝, φH := φH✝, commp := commp✝, commg' := commg'✝, commι := commι✝ } { φQ := φQ, φH := φH, commp := commp, commg' := commg', commι := commι }\n⊢ And (Eq φQ✝ φQ) (Eq φH✝ φH)","decl":"/-- Given right homology data `h₁` and `h₂` for two short complexes `S₁` and `S₂`,\na `RightHomologyMapData` for a morphism `φ : S₁ ⟶ S₂`\nconsists of a description of the induced morphisms on the `Q` (opcycles)\nand `H` (right homology) fields of `h₁` and `h₂`. -/\nstructure RightHomologyMapData where\n  /-- the induced map on opcycles -/\n  φQ : h₁.Q ⟶ h₂.Q\n  /-- the induced map on right homology -/\n  φH : h₁.H ⟶ h₂.H\n  /-- commutation with `p` -/\n  commp : h₁.p ≫ φQ = φ.τ₂ ≫ h₂.p := by aesop_cat\n  /-- commutation with `g'` -/\n  commg' : φQ ≫ h₂.g' = h₁.g' ≫ φ.τ₃ := by aesop_cat\n  /-- commutation with `ι` -/\n  commι : φH ≫ h₂.ι = h₁.ι ≫ φQ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\ninst✝ : SizeOf C\nφQ : Quiver.Hom h₁.Q h₂.Q\nφH : Quiver.Hom h₁.H h₂.H\ncommp : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.p φQ) (CategoryTheory.CategoryStruct.comp φ.τ₂ h₂.p)) _auto✝\ncommg' : autoParam (Eq (CategoryTheory.CategoryStruct.comp φQ h₂.g') (CategoryTheory.CategoryStruct.comp h₁.g' φ.τ₃)) _auto✝\ncommι : autoParam (Eq (CategoryTheory.CategoryStruct.comp φH h₂.ι) (CategoryTheory.CategoryStruct.comp h₁.ι φQ)) _auto✝\n⊢ Eq (SizeOf.sizeOf { φQ := φQ, φH := φH, commp := commp, commg' := commg', commι := commι }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf φQ)) (SizeOf.sizeOf φH)) (SizeOf.sizeOf commp)) (SizeOf.sizeOf commg')) (SizeOf.sizeOf commι))","decl":"/-- Given right homology data `h₁` and `h₂` for two short complexes `S₁` and `S₂`,\na `RightHomologyMapData` for a morphism `φ : S₁ ⟶ S₂`\nconsists of a description of the induced morphisms on the `Q` (opcycles)\nand `H` (right homology) fields of `h₁` and `h₂`. -/\nstructure RightHomologyMapData where\n  /-- the induced map on opcycles -/\n  φQ : h₁.Q ⟶ h₂.Q\n  /-- the induced map on right homology -/\n  φH : h₁.H ⟶ h₂.H\n  /-- commutation with `p` -/\n  commp : h₁.p ≫ φQ = φ.τ₂ ≫ h₂.p := by aesop_cat\n  /-- commutation with `g'` -/\n  commg' : φQ ≫ h₂.g' = h₁.g' ≫ φ.τ₃ := by aesop_cat\n  /-- commutation with `ι` -/\n  commι : φH ≫ h₂.ι = h₁.ι ≫ φQ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.mk.injEq","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nφQ✝ : Quiver.Hom h₁.Q h₂.Q\nφH✝ : Quiver.Hom h₁.H h₂.H\ncommp✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.p φQ✝) (CategoryTheory.CategoryStruct.comp φ.τ₂ h₂.p)) _auto✝\ncommg'✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp φQ✝ h₂.g') (CategoryTheory.CategoryStruct.comp h₁.g' φ.τ₃)) _auto✝\ncommι✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp φH✝ h₂.ι) (CategoryTheory.CategoryStruct.comp h₁.ι φQ✝)) _auto✝\nφQ : Quiver.Hom h₁.Q h₂.Q\nφH : Quiver.Hom h₁.H h₂.H\ncommp : autoParam (Eq (CategoryTheory.CategoryStruct.comp h₁.p φQ) (CategoryTheory.CategoryStruct.comp φ.τ₂ h₂.p)) _auto✝\ncommg' : autoParam (Eq (CategoryTheory.CategoryStruct.comp φQ h₂.g') (CategoryTheory.CategoryStruct.comp h₁.g' φ.τ₃)) _auto✝\ncommι : autoParam (Eq (CategoryTheory.CategoryStruct.comp φH h₂.ι) (CategoryTheory.CategoryStruct.comp h₁.ι φQ)) _auto✝\n⊢ Eq (Eq { φQ := φQ✝, φH := φH✝, commp := commp✝, commg' := commg'✝, commι := commι✝ } { φQ := φQ, φH := φH, commp := commp, commg' := commg', commι := commι }) (And (Eq φQ✝ φQ) (Eq φH✝ φH))","decl":"/-- Given right homology data `h₁` and `h₂` for two short complexes `S₁` and `S₂`,\na `RightHomologyMapData` for a morphism `φ : S₁ ⟶ S₂`\nconsists of a description of the induced morphisms on the `Q` (opcycles)\nand `H` (right homology) fields of `h₁` and `h₂`. -/\nstructure RightHomologyMapData where\n  /-- the induced map on opcycles -/\n  φQ : h₁.Q ⟶ h₂.Q\n  /-- the induced map on right homology -/\n  φH : h₁.H ⟶ h₂.H\n  /-- commutation with `p` -/\n  commp : h₁.p ≫ φQ = φ.τ₂ ≫ h₂.p := by aesop_cat\n  /-- commutation with `g'` -/\n  commg' : φQ ≫ h₂.g' = h₁.g' ≫ φ.τ₃ := by aesop_cat\n  /-- commutation with `ι` -/\n  commι : φH ≫ h₂.ι = h₁.ι ≫ φQ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.commp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nself : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\nZ : C\nh : Quiver.Hom h₂.Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.p (CategoryTheory.CategoryStruct.comp self.φQ h)) (CategoryTheory.CategoryStruct.comp φ.τ₂ (CategoryTheory.CategoryStruct.comp h₂.p h))","decl":"attribute [reassoc (attr := simp)] commp commg' commι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.commι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nself : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\nZ : C\nh : Quiver.Hom h₂.Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.φH (CategoryTheory.CategoryStruct.comp h₂.ι h)) (CategoryTheory.CategoryStruct.comp h₁.ι (CategoryTheory.CategoryStruct.comp self.φQ h))","decl":"attribute [reassoc (attr := simp)] commp commg' commι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.commg'_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nself : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\nZ : C\nh : Quiver.Hom S₂.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.φQ (CategoryTheory.CategoryStruct.comp h₂.g' h)) (CategoryTheory.CategoryStruct.comp h₁.g' (CategoryTheory.CategoryStruct.comp φ.τ₃ h))","decl":"attribute [reassoc (attr := simp)] commp commg' commι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.zero_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.zero h₁ h₂).φQ 0","decl":"/-- The right homology map data associated to the zero morphism between two short complexes. -/\n@[simps]\ndef zero (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) :\n    RightHomologyMapData 0 h₁ h₂ where\n  φQ := 0\n  φH := 0\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.zero_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.zero h₁ h₂).φH 0","decl":"/-- The right homology map data associated to the zero morphism between two short complexes. -/\n@[simps]\ndef zero (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) :\n    RightHomologyMapData 0 h₁ h₂ where\n  φQ := 0\n  φH := 0\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.id_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.id h).φH (CategoryTheory.CategoryStruct.id h.H)","decl":"/-- The right homology map data associated to the identity morphism of a short complex. -/\n@[simps]\ndef id (h : S.RightHomologyData) : RightHomologyMapData (𝟙 S) h h where\n  φQ := 𝟙 _\n  φH := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.id_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.id h).φQ (CategoryTheory.CategoryStruct.id h.Q)","decl":"/-- The right homology map data associated to the identity morphism of a short complex. -/\n@[simps]\ndef id (h : S.RightHomologyData) : RightHomologyMapData (𝟙 S) h h where\n  φQ := 𝟙 _\n  φH := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.comp_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nφ' : Quiver.Hom S₂ S₃\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nh₃ : S₃.RightHomologyData\nψ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\nψ' : CategoryTheory.ShortComplex.RightHomologyMapData φ' h₂ h₃\n⊢ Eq (ψ.comp ψ').φH (CategoryTheory.CategoryStruct.comp ψ.φH ψ'.φH)","decl":"/-- The composition of right homology map data. -/\n@[simps]\ndef comp {φ : S₁ ⟶ S₂} {φ' : S₂ ⟶ S₃} {h₁ : S₁.RightHomologyData}\n    {h₂ : S₂.RightHomologyData} {h₃ : S₃.RightHomologyData}\n    (ψ : RightHomologyMapData φ h₁ h₂) (ψ' : RightHomologyMapData φ' h₂ h₃) :\n    RightHomologyMapData (φ ≫ φ') h₁ h₃ where\n  φQ := ψ.φQ ≫ ψ'.φQ\n  φH := ψ.φH ≫ ψ'.φH\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.comp_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nφ' : Quiver.Hom S₂ S₃\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nh₃ : S₃.RightHomologyData\nψ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\nψ' : CategoryTheory.ShortComplex.RightHomologyMapData φ' h₂ h₃\n⊢ Eq (ψ.comp ψ').φQ (CategoryTheory.CategoryStruct.comp ψ.φQ ψ'.φQ)","decl":"/-- The composition of right homology map data. -/\n@[simps]\ndef comp {φ : S₁ ⟶ S₂} {φ' : S₂ ⟶ S₃} {h₁ : S₁.RightHomologyData}\n    {h₂ : S₂.RightHomologyData} {h₃ : S₃.RightHomologyData}\n    (ψ : RightHomologyMapData φ h₁ h₂) (ψ' : RightHomologyMapData φ' h₂ h₃) :\n    RightHomologyMapData (φ ≫ φ') h₁ h₃ where\n  φQ := ψ.φQ ≫ ψ'.φQ\n  φH := ψ.φH ≫ ψ'.φH\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.instSubsingleton","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Subsingleton (CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂)","decl":"instance : Subsingleton (RightHomologyMapData φ h₁ h₂) :=\n  ⟨fun ψ₁ ψ₂ => by\n    have hQ : ψ₁.φQ = ψ₂.φQ := by rw [← cancel_epi h₁.p, commp, commp]\n    have hH : ψ₁.φH = ψ₂.φH := by rw [← cancel_mono h₂.ι, commι, commι, hQ]\n    cases ψ₁\n    cases ψ₂\n    congr⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.congr_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ₁ γ₂ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\neq : Eq γ₁ γ₂\n⊢ Eq γ₁.φH γ₂.φH","decl":"lemma congr_φH {γ₁ γ₂ : RightHomologyMapData φ h₁ h₂} (eq : γ₁ = γ₂) : γ₁.φH = γ₂.φH := by rw [eq]\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.congr_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ₁ γ₂ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\neq : Eq γ₁ γ₂\n⊢ Eq γ₁.φQ γ₂.φQ","decl":"lemma congr_φQ {γ₁ γ₂ : RightHomologyMapData φ h₁ h₂} (eq : γ₁ = γ₂) : γ₁.φQ = γ₂.φQ := by rw [eq]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.ofZeros_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhf₁ : Eq S₁.f 0\nhg₁ : Eq S₁.g 0\nhf₂ : Eq S₂.f 0\nhg₂ : Eq S₂.g 0\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.ofZeros φ hf₁ hg₁ hf₂ hg₂).φH φ.τ₂","decl":"/-- When `S₁.f`, `S₁.g`, `S₂.f` and `S₂.g` are all zero, the action on right homology of a\nmorphism `φ : S₁ ⟶ S₂` is given by the action `φ.τ₂` on the middle objects. -/\n@[simps]\ndef ofZeros (φ : S₁ ⟶ S₂) (hf₁ : S₁.f = 0) (hg₁ : S₁.g = 0) (hf₂ : S₂.f = 0) (hg₂ : S₂.g = 0) :\n    RightHomologyMapData φ (RightHomologyData.ofZeros S₁ hf₁ hg₁)\n    (RightHomologyData.ofZeros S₂ hf₂ hg₂) where\n  φQ := φ.τ₂\n  φH := φ.τ₂\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.ofZeros_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhf₁ : Eq S₁.f 0\nhg₁ : Eq S₁.g 0\nhf₂ : Eq S₂.f 0\nhg₂ : Eq S₂.g 0\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.ofZeros φ hf₁ hg₁ hf₂ hg₂).φQ φ.τ₂","decl":"/-- When `S₁.f`, `S₁.g`, `S₂.f` and `S₂.g` are all zero, the action on right homology of a\nmorphism `φ : S₁ ⟶ S₂` is given by the action `φ.τ₂` on the middle objects. -/\n@[simps]\ndef ofZeros (φ : S₁ ⟶ S₂) (hf₁ : S₁.f = 0) (hg₁ : S₁.g = 0) (hf₂ : S₂.f = 0) (hg₂ : S₂.g = 0) :\n    RightHomologyMapData φ (RightHomologyData.ofZeros S₁ hf₁ hg₁)\n    (RightHomologyData.ofZeros S₂ hf₂ hg₂) where\n  φQ := φ.τ₂\n  φH := φ.τ₂\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.ofIsLimitKernelFork_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhf₁ : Eq S₁.f 0\nc₁ : CategoryTheory.Limits.KernelFork S₁.g\nhc₁ : CategoryTheory.Limits.IsLimit c₁\nhf₂ : Eq S₂.f 0\nc₂ : CategoryTheory.Limits.KernelFork S₂.g\nhc₂ : CategoryTheory.Limits.IsLimit c₂\nf : Quiver.Hom c₁.pt c₂.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.ι c₁) φ.τ₂) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Fork.ι c₂))\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.ofIsLimitKernelFork φ hf₁ c₁ hc₁ hf₂ c₂ hc₂ f comm).φH f","decl":"/-- When `S₁.f` and `S₂.f` are zero and we have chosen limit kernel forks `c₁` and `c₂`\nfor `S₁.g` and `S₂.g` respectively, the action on right homology of a morphism `φ : S₁ ⟶ S₂` of\nshort complexes is given by the unique morphism `f : c₁.pt ⟶ c₂.pt` such that\n`c₁.ι ≫ φ.τ₂ = f ≫ c₂.ι`. -/\n@[simps]\ndef ofIsLimitKernelFork (φ : S₁ ⟶ S₂)\n    (hf₁ : S₁.f = 0) (c₁ : KernelFork S₁.g) (hc₁ : IsLimit c₁)\n    (hf₂ : S₂.f = 0) (c₂ : KernelFork S₂.g) (hc₂ : IsLimit c₂) (f : c₁.pt ⟶ c₂.pt)\n    (comm : c₁.ι ≫ φ.τ₂ = f ≫ c₂.ι) :\n    RightHomologyMapData φ (RightHomologyData.ofIsLimitKernelFork S₁ hf₁ c₁ hc₁)\n      (RightHomologyData.ofIsLimitKernelFork S₂ hf₂ c₂ hc₂) where\n  φQ := φ.τ₂\n  φH := f\n  commg' := by simp only [RightHomologyData.ofIsLimitKernelFork_g', φ.comm₂₃]\n  commι := comm.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.ofIsLimitKernelFork_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhf₁ : Eq S₁.f 0\nc₁ : CategoryTheory.Limits.KernelFork S₁.g\nhc₁ : CategoryTheory.Limits.IsLimit c₁\nhf₂ : Eq S₂.f 0\nc₂ : CategoryTheory.Limits.KernelFork S₂.g\nhc₂ : CategoryTheory.Limits.IsLimit c₂\nf : Quiver.Hom c₁.pt c₂.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.ι c₁) φ.τ₂) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Fork.ι c₂))\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.ofIsLimitKernelFork φ hf₁ c₁ hc₁ hf₂ c₂ hc₂ f comm).φQ φ.τ₂","decl":"/-- When `S₁.f` and `S₂.f` are zero and we have chosen limit kernel forks `c₁` and `c₂`\nfor `S₁.g` and `S₂.g` respectively, the action on right homology of a morphism `φ : S₁ ⟶ S₂` of\nshort complexes is given by the unique morphism `f : c₁.pt ⟶ c₂.pt` such that\n`c₁.ι ≫ φ.τ₂ = f ≫ c₂.ι`. -/\n@[simps]\ndef ofIsLimitKernelFork (φ : S₁ ⟶ S₂)\n    (hf₁ : S₁.f = 0) (c₁ : KernelFork S₁.g) (hc₁ : IsLimit c₁)\n    (hf₂ : S₂.f = 0) (c₂ : KernelFork S₂.g) (hc₂ : IsLimit c₂) (f : c₁.pt ⟶ c₂.pt)\n    (comm : c₁.ι ≫ φ.τ₂ = f ≫ c₂.ι) :\n    RightHomologyMapData φ (RightHomologyData.ofIsLimitKernelFork S₁ hf₁ c₁ hc₁)\n      (RightHomologyData.ofIsLimitKernelFork S₂ hf₂ c₂ hc₂) where\n  φQ := φ.τ₂\n  φH := f\n  commg' := by simp only [RightHomologyData.ofIsLimitKernelFork_g', φ.comm₂₃]\n  commι := comm.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.ofIsColimitCokernelCofork_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhg₁ : Eq S₁.g 0\nc₁ : CategoryTheory.Limits.CokernelCofork S₁.f\nhc₁ : CategoryTheory.Limits.IsColimit c₁\nhg₂ : Eq S₂.g 0\nc₂ : CategoryTheory.Limits.CokernelCofork S₂.f\nhc₂ : CategoryTheory.Limits.IsColimit c₂\nf : Quiver.Hom c₁.pt c₂.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp φ.τ₂ (CategoryTheory.Limits.Cofork.π c₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.π c₁) f)\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.ofIsColimitCokernelCofork φ hg₁ c₁ hc₁ hg₂ c₂ hc₂ f comm).φQ f","decl":"/-- When `S₁.g` and `S₂.g` are zero and we have chosen colimit cokernel coforks `c₁` and `c₂`\nfor `S₁.f` and `S₂.f` respectively, the action on right homology of a morphism `φ : S₁ ⟶ S₂` of\nshort complexes is given by the unique morphism `f : c₁.pt ⟶ c₂.pt` such that\n`φ.τ₂ ≫ c₂.π = c₁.π ≫ f`. -/\n@[simps]\ndef ofIsColimitCokernelCofork (φ : S₁ ⟶ S₂)\n    (hg₁ : S₁.g = 0) (c₁ : CokernelCofork S₁.f) (hc₁ : IsColimit c₁)\n    (hg₂ : S₂.g = 0) (c₂ : CokernelCofork S₂.f) (hc₂ : IsColimit c₂) (f : c₁.pt ⟶ c₂.pt)\n    (comm : φ.τ₂ ≫ c₂.π = c₁.π ≫ f) :\n    RightHomologyMapData φ (RightHomologyData.ofIsColimitCokernelCofork S₁ hg₁ c₁ hc₁)\n      (RightHomologyData.ofIsColimitCokernelCofork S₂ hg₂ c₂ hc₂) where\n  φQ := f\n  φH := f\n  commp := comm.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.ofIsColimitCokernelCofork_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhg₁ : Eq S₁.g 0\nc₁ : CategoryTheory.Limits.CokernelCofork S₁.f\nhc₁ : CategoryTheory.Limits.IsColimit c₁\nhg₂ : Eq S₂.g 0\nc₂ : CategoryTheory.Limits.CokernelCofork S₂.f\nhc₂ : CategoryTheory.Limits.IsColimit c₂\nf : Quiver.Hom c₁.pt c₂.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp φ.τ₂ (CategoryTheory.Limits.Cofork.π c₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.π c₁) f)\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.ofIsColimitCokernelCofork φ hg₁ c₁ hc₁ hg₂ c₂ hc₂ f comm).φH f","decl":"/-- When `S₁.g` and `S₂.g` are zero and we have chosen colimit cokernel coforks `c₁` and `c₂`\nfor `S₁.f` and `S₂.f` respectively, the action on right homology of a morphism `φ : S₁ ⟶ S₂` of\nshort complexes is given by the unique morphism `f : c₁.pt ⟶ c₂.pt` such that\n`φ.τ₂ ≫ c₂.π = c₁.π ≫ f`. -/\n@[simps]\ndef ofIsColimitCokernelCofork (φ : S₁ ⟶ S₂)\n    (hg₁ : S₁.g = 0) (c₁ : CokernelCofork S₁.f) (hc₁ : IsColimit c₁)\n    (hg₂ : S₂.g = 0) (c₂ : CokernelCofork S₂.f) (hc₂ : IsColimit c₂) (f : c₁.pt ⟶ c₂.pt)\n    (comm : φ.τ₂ ≫ c₂.π = c₁.π ≫ f) :\n    RightHomologyMapData φ (RightHomologyData.ofIsColimitCokernelCofork S₁ hg₁ c₁ hc₁)\n      (RightHomologyData.ofIsColimitCokernelCofork S₂ hg₂ c₂ hc₂) where\n  φQ := f\n  φH := f\n  commp := comm.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc).φH (CategoryTheory.Limits.Fork.ι c)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the right homology map\ndata (for the identity of `S`) which relates the right homology data\n`RightHomologyData.ofIsLimitKernelFork` and `ofZeros` . -/\n@[simps]\ndef compatibilityOfZerosOfIsLimitKernelFork (hf : S.f = 0) (hg : S.g = 0)\n    (c : KernelFork S.g) (hc : IsLimit c) :\n    RightHomologyMapData (𝟙 S)\n      (RightHomologyData.ofIsLimitKernelFork S hf c hc)\n      (RightHomologyData.ofZeros S hf hg) where\n  φQ := 𝟙 _\n  φH := c.ι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc).φQ (CategoryTheory.CategoryStruct.id (CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork S hf c hc).Q)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the right homology map\ndata (for the identity of `S`) which relates the right homology data\n`RightHomologyData.ofIsLimitKernelFork` and `ofZeros` . -/\n@[simps]\ndef compatibilityOfZerosOfIsLimitKernelFork (hf : S.f = 0) (hg : S.g = 0)\n    (c : KernelFork S.g) (hc : IsLimit c) :\n    RightHomologyMapData (𝟙 S)\n      (RightHomologyData.ofIsLimitKernelFork S hf c hc)\n      (RightHomologyData.ofZeros S hf hg) where\n  φQ := 𝟙 _\n  φH := c.ι\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork S hf hg c hc).φQ (CategoryTheory.Limits.Cofork.π c)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the right homology map\ndata (for the identity of `S`) which relates the right homology data `ofZeros` and\n`ofIsColimitCokernelCofork`. -/\n@[simps]\ndef compatibilityOfZerosOfIsColimitCokernelCofork (hf : S.f = 0) (hg : S.g = 0)\n    (c : CokernelCofork S.f) (hc : IsColimit c) :\n    RightHomologyMapData (𝟙 S)\n      (RightHomologyData.ofZeros S hf hg)\n      (RightHomologyData.ofIsColimitCokernelCofork S hg c hc) where\n  φQ := c.π\n  φH := c.π\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork S hf hg c hc).φH (CategoryTheory.Limits.Cofork.π c)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the right homology map\ndata (for the identity of `S`) which relates the right homology data `ofZeros` and\n`ofIsColimitCokernelCofork`. -/\n@[simps]\ndef compatibilityOfZerosOfIsColimitCokernelCofork (hf : S.f = 0) (hg : S.g = 0)\n    (c : CokernelCofork S.f) (hc : IsColimit c) :\n    RightHomologyMapData (𝟙 S)\n      (RightHomologyData.ofZeros S hf hg)\n      (RightHomologyData.ofIsColimitCokernelCofork S hg c hc) where\n  φQ := c.π\n  φH := c.π\n\n"}
{"name":"CategoryTheory.ShortComplex.f_pOpcycles","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.f S.pOpcycles) 0","decl":"@[reassoc (attr := simp)]\nlemma f_pOpcycles : S.f ≫ S.pOpcycles = 0 := S.rightHomologyData.wp\n\n"}
{"name":"CategoryTheory.ShortComplex.f_pOpcycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nZ : C\nh : Quiver.Hom S.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.f (CategoryTheory.CategoryStruct.comp S.pOpcycles h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma f_pOpcycles : S.f ≫ S.pOpcycles = 0 := S.rightHomologyData.wp\n\n"}
{"name":"CategoryTheory.ShortComplex.p_fromOpcycles","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.pOpcycles S.fromOpcycles) S.g","decl":"@[reassoc (attr := simp)]\nlemma p_fromOpcycles : S.pOpcycles ≫ S.fromOpcycles = S.g := S.rightHomologyData.p_g'\n\n"}
{"name":"CategoryTheory.ShortComplex.p_fromOpcycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nZ : C\nh : Quiver.Hom S.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.pOpcycles (CategoryTheory.CategoryStruct.comp S.fromOpcycles h)) (CategoryTheory.CategoryStruct.comp S.g h)","decl":"@[reassoc (attr := simp)]\nlemma p_fromOpcycles : S.pOpcycles ≫ S.fromOpcycles = S.g := S.rightHomologyData.p_g'\n\n"}
{"name":"CategoryTheory.ShortComplex.instEpiPOpcycles","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\n⊢ CategoryTheory.Epi S.pOpcycles","decl":"instance : Epi S.pOpcycles := by\n  dsimp only [pOpcycles]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.instMonoRightHomologyι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\n⊢ CategoryTheory.Mono S.rightHomologyι","decl":"instance : Mono S.rightHomologyι := by\n  dsimp only [rightHomologyι]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomology_ext_iff","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nA : C\nf₁ f₂ : Quiver.Hom A S.rightHomology\n⊢ Iff (Eq f₁ f₂) (Eq (CategoryTheory.CategoryStruct.comp f₁ S.rightHomologyι) (CategoryTheory.CategoryStruct.comp f₂ S.rightHomologyι))","decl":"lemma rightHomology_ext_iff {A : C} (f₁ f₂ : A ⟶ S.rightHomology) :\n    f₁ = f₂ ↔ f₁ ≫ S.rightHomologyι = f₂ ≫ S.rightHomologyι := by\n  rw [cancel_mono]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomology_ext","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nA : C\nf₁ f₂ : Quiver.Hom A S.rightHomology\nh : Eq (CategoryTheory.CategoryStruct.comp f₁ S.rightHomologyι) (CategoryTheory.CategoryStruct.comp f₂ S.rightHomologyι)\n⊢ Eq f₁ f₂","decl":"@[ext]\nlemma rightHomology_ext {A : C} (f₁ f₂ : A ⟶ S.rightHomology)\n    (h : f₁ ≫ S.rightHomologyι = f₂ ≫ S.rightHomologyι) : f₁ = f₂ := by\n  simpa only [rightHomology_ext_iff]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcycles_ext_iff","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nA : C\nf₁ f₂ : Quiver.Hom S.opcycles A\n⊢ Iff (Eq f₁ f₂) (Eq (CategoryTheory.CategoryStruct.comp S.pOpcycles f₁) (CategoryTheory.CategoryStruct.comp S.pOpcycles f₂))","decl":"lemma opcycles_ext_iff {A : C} (f₁ f₂ : S.opcycles ⟶ A) :\n    f₁ = f₂ ↔ S.pOpcycles ≫ f₁ = S.pOpcycles ≫ f₂ := by\n  rw [cancel_epi]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcycles_ext","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nA : C\nf₁ f₂ : Quiver.Hom S.opcycles A\nh : Eq (CategoryTheory.CategoryStruct.comp S.pOpcycles f₁) (CategoryTheory.CategoryStruct.comp S.pOpcycles f₂)\n⊢ Eq f₁ f₂","decl":"@[ext]\nlemma opcycles_ext {A : C} (f₁ f₂ : S.opcycles ⟶ A)\n    (h : S.pOpcycles ≫ f₁ = S.pOpcycles ≫ f₂) : f₁ = f₂ := by\n  simpa only [opcycles_ext_iff]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_pOpcycles","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nhf : Eq S.f 0\n⊢ CategoryTheory.IsIso S.pOpcycles","decl":"lemma isIso_pOpcycles (hf : S.f = 0) : IsIso S.pOpcycles :=\n  RightHomologyData.isIso_p _ hf\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesIsoX₂_inv","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nhf : Eq S.f 0\n⊢ Eq (S.opcyclesIsoX₂ hf).inv S.pOpcycles","decl":"/-- When `S.f = 0`, this is the canonical isomorphism `S.opcycles ≅ S.X₂`\ninduced by `S.pOpcycles`. -/\n@[simps! inv]\nnoncomputable def opcyclesIsoX₂ (hf : S.f = 0) : S.opcycles ≅ S.X₂ := by\n  have := S.isIso_pOpcycles hf\n  exact (asIso S.pOpcycles).symm\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesIsoX₂_inv_hom_id_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nhf : Eq S.f 0\nZ : C\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.pOpcycles (CategoryTheory.CategoryStruct.comp (S.opcyclesIsoX₂ hf).hom h)) h","decl":"@[reassoc (attr := simp)]\nlemma opcyclesIsoX₂_inv_hom_id (hf : S.f = 0) :\n    S.pOpcycles ≫ (S.opcyclesIsoX₂ hf).hom = 𝟙 _ := (S.opcyclesIsoX₂ hf).inv_hom_id\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesIsoX₂_inv_hom_id","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nhf : Eq S.f 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.pOpcycles (S.opcyclesIsoX₂ hf).hom) (CategoryTheory.CategoryStruct.id S.X₂)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesIsoX₂_inv_hom_id (hf : S.f = 0) :\n    S.pOpcycles ≫ (S.opcyclesIsoX₂ hf).hom = 𝟙 _ := (S.opcyclesIsoX₂ hf).inv_hom_id\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesIsoX₂_hom_inv_id_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nhf : Eq S.f 0\nZ : C\nh : Quiver.Hom S.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.opcyclesIsoX₂ hf).hom (CategoryTheory.CategoryStruct.comp S.pOpcycles h)) h","decl":"@[reassoc (attr := simp)]\nlemma opcyclesIsoX₂_hom_inv_id (hf : S.f = 0) :\n    (S.opcyclesIsoX₂ hf).hom ≫ S.pOpcycles = 𝟙 _ := (S.opcyclesIsoX₂ hf).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesIsoX₂_hom_inv_id","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nhf : Eq S.f 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.opcyclesIsoX₂ hf).hom S.pOpcycles) (CategoryTheory.CategoryStruct.id S.opcycles)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesIsoX₂_hom_inv_id (hf : S.f = 0) :\n    (S.opcyclesIsoX₂ hf).hom ≫ S.pOpcycles = 𝟙 _ := (S.opcyclesIsoX₂ hf).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_rightHomologyι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nhg : Eq S.g 0\n⊢ CategoryTheory.IsIso S.rightHomologyι","decl":"lemma isIso_rightHomologyι (hg : S.g = 0) : IsIso S.rightHomologyι :=\n  RightHomologyData.isIso_ι _ hg\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesIsoRightHomology_inv","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nhg : Eq S.g 0\n⊢ Eq (S.opcyclesIsoRightHomology hg).inv S.rightHomologyι","decl":"/-- When `S.g = 0`, this is the canonical isomorphism `S.opcycles ≅ S.rightHomology` induced\nby `S.rightHomologyι`. -/\n@[simps! inv]\nnoncomputable def opcyclesIsoRightHomology (hg : S.g = 0) : S.opcycles ≅ S.rightHomology := by\n  have := S.isIso_rightHomologyι hg\n  exact (asIso S.rightHomologyι).symm\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesIsoRightHomology_inv_hom_id_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nhg : Eq S.g 0\nZ : C\nh : Quiver.Hom S.rightHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.rightHomologyι (CategoryTheory.CategoryStruct.comp (S.opcyclesIsoRightHomology hg).hom h)) h","decl":"@[reassoc (attr := simp)]\nlemma opcyclesIsoRightHomology_inv_hom_id (hg : S.g = 0) :\n    S.rightHomologyι ≫ (S.opcyclesIsoRightHomology hg).hom = 𝟙 _ :=\n  (S.opcyclesIsoRightHomology hg).inv_hom_id\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesIsoRightHomology_inv_hom_id","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.rightHomologyι (S.opcyclesIsoRightHomology hg).hom) (CategoryTheory.CategoryStruct.id S.rightHomology)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesIsoRightHomology_inv_hom_id (hg : S.g = 0) :\n    S.rightHomologyι ≫ (S.opcyclesIsoRightHomology hg).hom = 𝟙 _ :=\n  (S.opcyclesIsoRightHomology hg).inv_hom_id\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesIsoRightHomology_hom_inv_id_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nhg : Eq S.g 0\nZ : C\nh : Quiver.Hom S.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.opcyclesIsoRightHomology hg).hom (CategoryTheory.CategoryStruct.comp S.rightHomologyι h)) h","decl":"@[reassoc (attr := simp)]\nlemma opcyclesIsoRightHomology_hom_inv_id (hg : S.g = 0) :\n    (S.opcyclesIsoRightHomology hg).hom ≫ S.rightHomologyι  = 𝟙 _ :=\n  (S.opcyclesIsoRightHomology hg).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesIsoRightHomology_hom_inv_id","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.opcyclesIsoRightHomology hg).hom S.rightHomologyι) (CategoryTheory.CategoryStruct.id S.opcycles)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesIsoRightHomology_hom_inv_id (hg : S.g = 0) :\n    (S.opcyclesIsoRightHomology hg).hom ≫ S.rightHomologyι  = 𝟙 _ :=\n  (S.opcyclesIsoRightHomology hg).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.p_opcyclesMap'_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nZ : C\nh : Quiver.Hom h₂.Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.p (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap' φ h₁ h₂) h)) (CategoryTheory.CategoryStruct.comp φ.τ₂ (CategoryTheory.CategoryStruct.comp h₂.p h))","decl":"@[reassoc (attr := simp)]\nlemma p_opcyclesMap' : h₁.p ≫ opcyclesMap' φ h₁ h₂ = φ.τ₂ ≫ h₂.p :=\n  RightHomologyMapData.commp _\n\n"}
{"name":"CategoryTheory.ShortComplex.p_opcyclesMap'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.p (CategoryTheory.ShortComplex.opcyclesMap' φ h₁ h₂)) (CategoryTheory.CategoryStruct.comp φ.τ₂ h₂.p)","decl":"@[reassoc (attr := simp)]\nlemma p_opcyclesMap' : h₁.p ≫ opcyclesMap' φ h₁ h₂ = φ.τ₂ ≫ h₂.p :=\n  RightHomologyMapData.commp _\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap'_g'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap' φ h₁ h₂) h₂.g') (CategoryTheory.CategoryStruct.comp h₁.g' φ.τ₃)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesMap'_g' : opcyclesMap' φ h₁ h₂ ≫ h₂.g' = h₁.g' ≫ φ.τ₃ := by\n  simp only [← cancel_epi h₁.p, assoc, φ.comm₂₃, p_opcyclesMap'_assoc,\n    RightHomologyData.p_g'_assoc, RightHomologyData.p_g']\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap'_g'_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nZ : C\nh : Quiver.Hom S₂.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap' φ h₁ h₂) (CategoryTheory.CategoryStruct.comp h₂.g' h)) (CategoryTheory.CategoryStruct.comp h₁.g' (CategoryTheory.CategoryStruct.comp φ.τ₃ h))","decl":"@[reassoc (attr := simp)]\nlemma opcyclesMap'_g' : opcyclesMap' φ h₁ h₂ ≫ h₂.g' = h₁.g' ≫ φ.τ₃ := by\n  simp only [← cancel_epi h₁.p, assoc, φ.comm₂₃, p_opcyclesMap'_assoc,\n    RightHomologyData.p_g'_assoc, RightHomologyData.p_g']\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyι_naturality'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap' φ h₁ h₂) h₂.ι) (CategoryTheory.CategoryStruct.comp h₁.ι (CategoryTheory.ShortComplex.opcyclesMap' φ h₁ h₂))","decl":"@[reassoc (attr := simp)]\nlemma rightHomologyι_naturality' :\n    rightHomologyMap' φ h₁ h₂ ≫ h₂.ι = h₁.ι ≫ opcyclesMap' φ h₁ h₂ :=\n  RightHomologyMapData.commι _\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyι_naturality'_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nZ : C\nh : Quiver.Hom h₂.Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap' φ h₁ h₂) (CategoryTheory.CategoryStruct.comp h₂.ι h)) (CategoryTheory.CategoryStruct.comp h₁.ι (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap' φ h₁ h₂) h))","decl":"@[reassoc (attr := simp)]\nlemma rightHomologyι_naturality' :\n    rightHomologyMap' φ h₁ h₂ ≫ h₂.ι = h₁.ι ≫ opcyclesMap' φ h₁ h₂ :=\n  RightHomologyMapData.commι _\n\n"}
{"name":"CategoryTheory.ShortComplex.p_opcyclesMap_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\nφ : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.pOpcycles (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap φ) h)) (CategoryTheory.CategoryStruct.comp φ.τ₂ (CategoryTheory.CategoryStruct.comp S₂.pOpcycles h))","decl":"@[reassoc (attr := simp)]\nlemma p_opcyclesMap : S₁.pOpcycles ≫ opcyclesMap φ = φ.τ₂ ≫ S₂.pOpcycles :=\n  p_opcyclesMap' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.p_opcyclesMap","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.pOpcycles (CategoryTheory.ShortComplex.opcyclesMap φ)) (CategoryTheory.CategoryStruct.comp φ.τ₂ S₂.pOpcycles)","decl":"@[reassoc (attr := simp)]\nlemma p_opcyclesMap : S₁.pOpcycles ≫ opcyclesMap φ = φ.τ₂ ≫ S₂.pOpcycles :=\n  p_opcyclesMap' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.fromOpcycles_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\nφ : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap φ) (CategoryTheory.CategoryStruct.comp S₂.fromOpcycles h)) (CategoryTheory.CategoryStruct.comp S₁.fromOpcycles (CategoryTheory.CategoryStruct.comp φ.τ₃ h))","decl":"@[reassoc (attr := simp)]\nlemma fromOpcycles_naturality : opcyclesMap φ ≫ S₂.fromOpcycles = S₁.fromOpcycles ≫ φ.τ₃ :=\n  opcyclesMap'_g' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.fromOpcycles_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap φ) S₂.fromOpcycles) (CategoryTheory.CategoryStruct.comp S₁.fromOpcycles φ.τ₃)","decl":"@[reassoc (attr := simp)]\nlemma fromOpcycles_naturality : opcyclesMap φ ≫ S₂.fromOpcycles = S₁.fromOpcycles ≫ φ.τ₃ :=\n  opcyclesMap'_g' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyι_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\nφ : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap φ) (CategoryTheory.CategoryStruct.comp S₂.rightHomologyι h)) (CategoryTheory.CategoryStruct.comp S₁.rightHomologyι (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap φ) h))","decl":"@[reassoc (attr := simp)]\nlemma rightHomologyι_naturality :\n    rightHomologyMap φ ≫ S₂.rightHomologyι = S₁.rightHomologyι ≫ opcyclesMap φ :=\n  rightHomologyι_naturality' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyι_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap φ) S₂.rightHomologyι) (CategoryTheory.CategoryStruct.comp S₁.rightHomologyι (CategoryTheory.ShortComplex.opcyclesMap φ))","decl":"@[reassoc (attr := simp)]\nlemma rightHomologyι_naturality :\n    rightHomologyMap φ ≫ S₂.rightHomologyι = S₁.rightHomologyι ≫ opcyclesMap φ :=\n  rightHomologyι_naturality' _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.rightHomologyMap'_eq","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap' φ h₁ h₂) γ.φH","decl":"lemma rightHomologyMap'_eq : rightHomologyMap' φ h₁ h₂ = γ.φH :=\n  RightHomologyMapData.congr_φH (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.opcyclesMap'_eq","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap' φ h₁ h₂) γ.φQ","decl":"lemma opcyclesMap'_eq : opcyclesMap' φ h₁ h₂ = γ.φQ :=\n  RightHomologyMapData.congr_φQ (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap'_id","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap' (CategoryTheory.CategoryStruct.id S) h h) (CategoryTheory.CategoryStruct.id h.H)","decl":"@[simp]\nlemma rightHomologyMap'_id (h : S.RightHomologyData) :\n    rightHomologyMap' (𝟙 S) h h = 𝟙 _ :=\n  (RightHomologyMapData.id h).rightHomologyMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap'_id","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap' (CategoryTheory.CategoryStruct.id S) h h) (CategoryTheory.CategoryStruct.id h.Q)","decl":"@[simp]\nlemma opcyclesMap'_id (h : S.RightHomologyData) :\n    opcyclesMap' (𝟙 S) h h = 𝟙 _ :=\n  (RightHomologyMapData.id h).opcyclesMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap_id","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap (CategoryTheory.CategoryStruct.id S)) (CategoryTheory.CategoryStruct.id S.rightHomology)","decl":"@[simp]\nlemma rightHomologyMap_id [HasRightHomology S] :\n    rightHomologyMap (𝟙 S) = 𝟙 _ :=\n  rightHomologyMap'_id _\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap_id","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap (CategoryTheory.CategoryStruct.id S)) (CategoryTheory.CategoryStruct.id S.opcycles)","decl":"@[simp]\nlemma opcyclesMap_id [HasRightHomology S] :\n    opcyclesMap (𝟙 S) = 𝟙 _ :=\n  opcyclesMap'_id _\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap'_zero","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap' 0 h₁ h₂) 0","decl":"@[simp]\nlemma rightHomologyMap'_zero (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) :\n    rightHomologyMap' 0 h₁ h₂ = 0 :=\n  (RightHomologyMapData.zero h₁ h₂).rightHomologyMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap'_zero","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap' 0 h₁ h₂) 0","decl":"@[simp]\nlemma opcyclesMap'_zero (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) :\n    opcyclesMap' 0 h₁ h₂ = 0 :=\n  (RightHomologyMapData.zero h₁ h₂).opcyclesMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap_zero","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap 0) 0","decl":"@[simp]\nlemma rightHomologyMap_zero [HasRightHomology S₁] [HasRightHomology S₂] :\n    rightHomologyMap (0 : S₁ ⟶ S₂) = 0 :=\n  rightHomologyMap'_zero _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap_zero","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap 0) 0","decl":"@[simp]\nlemma opcyclesMap_zero [HasRightHomology S₁] [HasRightHomology S₂] :\n    opcyclesMap (0 : S₁ ⟶ S₂) = 0 :=\n  opcyclesMap'_zero _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap'_comp","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nh₃ : S₃.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap' (CategoryTheory.CategoryStruct.comp φ₁ φ₂) h₁ h₃) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap' φ₁ h₁ h₂) (CategoryTheory.ShortComplex.rightHomologyMap' φ₂ h₂ h₃))","decl":"@[reassoc]\nlemma rightHomologyMap'_comp (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃)\n    (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) (h₃ : S₃.RightHomologyData) :\n    rightHomologyMap' (φ₁ ≫ φ₂) h₁ h₃ = rightHomologyMap' φ₁ h₁ h₂ ≫\n      rightHomologyMap' φ₂ h₂ h₃ := by\n  let γ₁ := rightHomologyMapData φ₁ h₁ h₂\n  let γ₂ := rightHomologyMapData φ₂ h₂ h₃\n  rw [γ₁.rightHomologyMap'_eq, γ₂.rightHomologyMap'_eq, (γ₁.comp γ₂).rightHomologyMap'_eq,\n    RightHomologyMapData.comp_φH]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap'_comp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nh₃ : S₃.RightHomologyData\nZ : C\nh : Quiver.Hom h₃.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap' (CategoryTheory.CategoryStruct.comp φ₁ φ₂) h₁ h₃) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap' φ₁ h₁ h₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap' φ₂ h₂ h₃) h))","decl":"@[reassoc]\nlemma rightHomologyMap'_comp (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃)\n    (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) (h₃ : S₃.RightHomologyData) :\n    rightHomologyMap' (φ₁ ≫ φ₂) h₁ h₃ = rightHomologyMap' φ₁ h₁ h₂ ≫\n      rightHomologyMap' φ₂ h₂ h₃ := by\n  let γ₁ := rightHomologyMapData φ₁ h₁ h₂\n  let γ₂ := rightHomologyMapData φ₂ h₂ h₃\n  rw [γ₁.rightHomologyMap'_eq, γ₂.rightHomologyMap'_eq, (γ₁.comp γ₂).rightHomologyMap'_eq,\n    RightHomologyMapData.comp_φH]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap'_comp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nh₃ : S₃.RightHomologyData\nZ : C\nh : Quiver.Hom h₃.Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap' (CategoryTheory.CategoryStruct.comp φ₁ φ₂) h₁ h₃) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap' φ₁ h₁ h₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap' φ₂ h₂ h₃) h))","decl":"@[reassoc]\nlemma opcyclesMap'_comp (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃)\n    (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) (h₃ : S₃.RightHomologyData) :\n    opcyclesMap' (φ₁ ≫ φ₂) h₁ h₃ = opcyclesMap' φ₁ h₁ h₂ ≫ opcyclesMap' φ₂ h₂ h₃ := by\n  let γ₁ := rightHomologyMapData φ₁ h₁ h₂\n  let γ₂ := rightHomologyMapData φ₂ h₂ h₃\n  rw [γ₁.opcyclesMap'_eq, γ₂.opcyclesMap'_eq, (γ₁.comp γ₂).opcyclesMap'_eq,\n    RightHomologyMapData.comp_φQ]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap'_comp","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nh₃ : S₃.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap' (CategoryTheory.CategoryStruct.comp φ₁ φ₂) h₁ h₃) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap' φ₁ h₁ h₂) (CategoryTheory.ShortComplex.opcyclesMap' φ₂ h₂ h₃))","decl":"@[reassoc]\nlemma opcyclesMap'_comp (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃)\n    (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) (h₃ : S₃.RightHomologyData) :\n    opcyclesMap' (φ₁ ≫ φ₂) h₁ h₃ = opcyclesMap' φ₁ h₁ h₂ ≫ opcyclesMap' φ₂ h₂ h₃ := by\n  let γ₁ := rightHomologyMapData φ₁ h₁ h₂\n  let γ₂ := rightHomologyMapData φ₂ h₂ h₃\n  rw [γ₁.opcyclesMap'_eq, γ₂.opcyclesMap'_eq, (γ₁.comp γ₂).opcyclesMap'_eq,\n    RightHomologyMapData.comp_φQ]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap_comp","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\ninst✝² : S₁.HasRightHomology\ninst✝¹ : S₂.HasRightHomology\ninst✝ : S₃.HasRightHomology\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap (CategoryTheory.CategoryStruct.comp φ₁ φ₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap φ₁) (CategoryTheory.ShortComplex.rightHomologyMap φ₂))","decl":"@[simp]\nlemma rightHomologyMap_comp [HasRightHomology S₁] [HasRightHomology S₂] [HasRightHomology S₃]\n    (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃) :\n    rightHomologyMap (φ₁ ≫ φ₂) = rightHomologyMap φ₁ ≫ rightHomologyMap φ₂ :=\nrightHomologyMap'_comp _ _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap_comp","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\ninst✝² : S₁.HasRightHomology\ninst✝¹ : S₂.HasRightHomology\ninst✝ : S₃.HasRightHomology\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap (CategoryTheory.CategoryStruct.comp φ₁ φ₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap φ₁) (CategoryTheory.ShortComplex.opcyclesMap φ₂))","decl":"@[simp]\nlemma opcyclesMap_comp [HasRightHomology S₁] [HasRightHomology S₂] [HasRightHomology S₃]\n    (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃) :\n    opcyclesMap (φ₁ ≫ φ₂) = opcyclesMap φ₁ ≫ opcyclesMap φ₂ :=\n  opcyclesMap'_comp _ _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMapIso'_hom","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMapIso' e h₁ h₂).hom (CategoryTheory.ShortComplex.rightHomologyMap' e.hom h₁ h₂)","decl":"/-- An isomorphism of short complexes `S₁ ≅ S₂` induces an isomorphism on the `H` fields\nof right homology data of `S₁` and `S₂`. -/\n@[simps]\ndef rightHomologyMapIso' (e : S₁ ≅ S₂) (h₁ : S₁.RightHomologyData)\n    (h₂ : S₂.RightHomologyData) : h₁.H ≅ h₂.H where\n  hom := rightHomologyMap' e.hom h₁ h₂\n  inv := rightHomologyMap' e.inv h₂ h₁\n  hom_inv_id := by rw [← rightHomologyMap'_comp, e.hom_inv_id, rightHomologyMap'_id]\n  inv_hom_id := by rw [← rightHomologyMap'_comp, e.inv_hom_id, rightHomologyMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMapIso'_inv","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMapIso' e h₁ h₂).inv (CategoryTheory.ShortComplex.rightHomologyMap' e.inv h₂ h₁)","decl":"/-- An isomorphism of short complexes `S₁ ≅ S₂` induces an isomorphism on the `H` fields\nof right homology data of `S₁` and `S₂`. -/\n@[simps]\ndef rightHomologyMapIso' (e : S₁ ≅ S₂) (h₁ : S₁.RightHomologyData)\n    (h₂ : S₂.RightHomologyData) : h₁.H ≅ h₂.H where\n  hom := rightHomologyMap' e.hom h₁ h₂\n  inv := rightHomologyMap' e.inv h₂ h₁\n  hom_inv_id := by rw [← rightHomologyMap'_comp, e.hom_inv_id, rightHomologyMap'_id]\n  inv_hom_id := by rw [← rightHomologyMap'_comp, e.inv_hom_id, rightHomologyMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_rightHomologyMap'_of_isIso","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝ : CategoryTheory.IsIso φ\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.rightHomologyMap' φ h₁ h₂)","decl":"instance isIso_rightHomologyMap'_of_isIso (φ : S₁ ⟶ S₂) [IsIso φ]\n    (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) :\n    IsIso (rightHomologyMap' φ h₁ h₂) :=\n  (inferInstance : IsIso (rightHomologyMapIso' (asIso φ) h₁ h₂).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMapIso'_hom","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMapIso' e h₁ h₂).hom (CategoryTheory.ShortComplex.opcyclesMap' e.hom h₁ h₂)","decl":"/-- An isomorphism of short complexes `S₁ ≅ S₂` induces an isomorphism on the `Q` fields\nof right homology data of `S₁` and `S₂`. -/\n@[simps]\ndef opcyclesMapIso' (e : S₁ ≅ S₂) (h₁ : S₁.RightHomologyData)\n    (h₂ : S₂.RightHomologyData) : h₁.Q ≅ h₂.Q where\n  hom := opcyclesMap' e.hom h₁ h₂\n  inv := opcyclesMap' e.inv h₂ h₁\n  hom_inv_id := by rw [← opcyclesMap'_comp, e.hom_inv_id, opcyclesMap'_id]\n  inv_hom_id := by rw [← opcyclesMap'_comp, e.inv_hom_id, opcyclesMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMapIso'_inv","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMapIso' e h₁ h₂).inv (CategoryTheory.ShortComplex.opcyclesMap' e.inv h₂ h₁)","decl":"/-- An isomorphism of short complexes `S₁ ≅ S₂` induces an isomorphism on the `Q` fields\nof right homology data of `S₁` and `S₂`. -/\n@[simps]\ndef opcyclesMapIso' (e : S₁ ≅ S₂) (h₁ : S₁.RightHomologyData)\n    (h₂ : S₂.RightHomologyData) : h₁.Q ≅ h₂.Q where\n  hom := opcyclesMap' e.hom h₁ h₂\n  inv := opcyclesMap' e.inv h₂ h₁\n  hom_inv_id := by rw [← opcyclesMap'_comp, e.hom_inv_id, opcyclesMap'_id]\n  inv_hom_id := by rw [← opcyclesMap'_comp, e.inv_hom_id, opcyclesMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_opcyclesMap'_of_isIso","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝ : CategoryTheory.IsIso φ\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.opcyclesMap' φ h₁ h₂)","decl":"instance isIso_opcyclesMap'_of_isIso (φ : S₁ ⟶ S₂) [IsIso φ]\n    (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) :\n    IsIso (opcyclesMap' φ h₁ h₂) :=\n  (inferInstance : IsIso (opcyclesMapIso' (asIso φ) h₁ h₂).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMapIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMapIso e).inv (CategoryTheory.ShortComplex.rightHomologyMap e.inv)","decl":"/-- The isomorphism `S₁.rightHomology ≅ S₂.rightHomology` induced by an isomorphism of\nshort complexes `S₁ ≅ S₂`. -/\n@[simps]\nnoncomputable def rightHomologyMapIso (e : S₁ ≅ S₂) [S₁.HasRightHomology]\n    [S₂.HasRightHomology] : S₁.rightHomology ≅ S₂.rightHomology where\n  hom := rightHomologyMap e.hom\n  inv := rightHomologyMap e.inv\n  hom_inv_id := by rw [← rightHomologyMap_comp, e.hom_inv_id, rightHomologyMap_id]\n  inv_hom_id := by rw [← rightHomologyMap_comp, e.inv_hom_id, rightHomologyMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMapIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMapIso e).hom (CategoryTheory.ShortComplex.rightHomologyMap e.hom)","decl":"/-- The isomorphism `S₁.rightHomology ≅ S₂.rightHomology` induced by an isomorphism of\nshort complexes `S₁ ≅ S₂`. -/\n@[simps]\nnoncomputable def rightHomologyMapIso (e : S₁ ≅ S₂) [S₁.HasRightHomology]\n    [S₂.HasRightHomology] : S₁.rightHomology ≅ S₂.rightHomology where\n  hom := rightHomologyMap e.hom\n  inv := rightHomologyMap e.inv\n  hom_inv_id := by rw [← rightHomologyMap_comp, e.hom_inv_id, rightHomologyMap_id]\n  inv_hom_id := by rw [← rightHomologyMap_comp, e.inv_hom_id, rightHomologyMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_rightHomologyMap_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝² : CategoryTheory.IsIso φ\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.rightHomologyMap φ)","decl":"instance isIso_rightHomologyMap_of_iso (φ : S₁ ⟶ S₂) [IsIso φ] [S₁.HasRightHomology]\n    [S₂.HasRightHomology] :\n    IsIso (rightHomologyMap φ) :=\n  (inferInstance : IsIso (rightHomologyMapIso (asIso φ)).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMapIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMapIso e).hom (CategoryTheory.ShortComplex.opcyclesMap e.hom)","decl":"/-- The isomorphism `S₁.opcycles ≅ S₂.opcycles` induced by an isomorphism\nof short complexes `S₁ ≅ S₂`. -/\n@[simps]\nnoncomputable def opcyclesMapIso (e : S₁ ≅ S₂) [S₁.HasRightHomology]\n    [S₂.HasRightHomology] : S₁.opcycles ≅ S₂.opcycles where\n  hom := opcyclesMap e.hom\n  inv := opcyclesMap e.inv\n  hom_inv_id := by rw [← opcyclesMap_comp, e.hom_inv_id, opcyclesMap_id]\n  inv_hom_id := by rw [← opcyclesMap_comp, e.inv_hom_id, opcyclesMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMapIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMapIso e).inv (CategoryTheory.ShortComplex.opcyclesMap e.inv)","decl":"/-- The isomorphism `S₁.opcycles ≅ S₂.opcycles` induced by an isomorphism\nof short complexes `S₁ ≅ S₂`. -/\n@[simps]\nnoncomputable def opcyclesMapIso (e : S₁ ≅ S₂) [S₁.HasRightHomology]\n    [S₂.HasRightHomology] : S₁.opcycles ≅ S₂.opcycles where\n  hom := opcyclesMap e.hom\n  inv := opcyclesMap e.inv\n  hom_inv_id := by rw [← opcyclesMap_comp, e.hom_inv_id, opcyclesMap_id]\n  inv_hom_id := by rw [← opcyclesMap_comp, e.inv_hom_id, opcyclesMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_opcyclesMap_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝² : CategoryTheory.IsIso φ\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.opcyclesMap φ)","decl":"instance isIso_opcyclesMap_of_iso (φ : S₁ ⟶ S₂) [IsIso φ] [S₁.HasRightHomology]\n    [S₂.HasRightHomology] : IsIso (opcyclesMap φ) :=\n  (inferInstance : IsIso (opcyclesMapIso (asIso φ)).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.p_comp_opcyclesIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.p h.opcyclesIso.inv) S.pOpcycles","decl":"@[reassoc (attr := simp)]\nlemma p_comp_opcyclesIso_inv : h.p ≫ h.opcyclesIso.inv = S.pOpcycles := by\n  dsimp [pOpcycles, RightHomologyData.opcyclesIso]\n  simp only [p_opcyclesMap', id_τ₂, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.p_comp_opcyclesIso_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.RightHomologyData\ninst✝ : S.HasRightHomology\nZ : C\nh : Quiver.Hom S.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.p (CategoryTheory.CategoryStruct.comp h✝.opcyclesIso.inv h)) (CategoryTheory.CategoryStruct.comp S.pOpcycles h)","decl":"@[reassoc (attr := simp)]\nlemma p_comp_opcyclesIso_inv : h.p ≫ h.opcyclesIso.inv = S.pOpcycles := by\n  dsimp [pOpcycles, RightHomologyData.opcyclesIso]\n  simp only [p_opcyclesMap', id_τ₂, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.pOpcycles_comp_opcyclesIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.pOpcycles h.opcyclesIso.hom) h.p","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_comp_opcyclesIso_hom : S.pOpcycles ≫ h.opcyclesIso.hom = h.p := by\n  simp only [← h.p_comp_opcyclesIso_inv, assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.pOpcycles_comp_opcyclesIso_hom_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.RightHomologyData\ninst✝ : S.HasRightHomology\nZ : C\nh : Quiver.Hom h✝.Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.pOpcycles (CategoryTheory.CategoryStruct.comp h✝.opcyclesIso.hom h)) (CategoryTheory.CategoryStruct.comp h✝.p h)","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_comp_opcyclesIso_hom : S.pOpcycles ≫ h.opcyclesIso.hom = h.p := by\n  simp only [← h.p_comp_opcyclesIso_inv, assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.rightHomologyIso_inv_comp_rightHomologyι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.rightHomologyIso.inv S.rightHomologyι) (CategoryTheory.CategoryStruct.comp h.ι h.opcyclesIso.inv)","decl":"@[reassoc (attr := simp)]\nlemma rightHomologyIso_inv_comp_rightHomologyι :\n    h.rightHomologyIso.inv ≫ S.rightHomologyι = h.ι ≫ h.opcyclesIso.inv := by\n  dsimp only [rightHomologyι, rightHomologyIso, opcyclesIso, rightHomologyMapIso',\n    opcyclesMapIso', Iso.refl]\n  rw [rightHomologyι_naturality']\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.rightHomologyIso_inv_comp_rightHomologyι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.RightHomologyData\ninst✝ : S.HasRightHomology\nZ : C\nh : Quiver.Hom S.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.rightHomologyIso.inv (CategoryTheory.CategoryStruct.comp S.rightHomologyι h)) (CategoryTheory.CategoryStruct.comp h✝.ι (CategoryTheory.CategoryStruct.comp h✝.opcyclesIso.inv h))","decl":"@[reassoc (attr := simp)]\nlemma rightHomologyIso_inv_comp_rightHomologyι :\n    h.rightHomologyIso.inv ≫ S.rightHomologyι = h.ι ≫ h.opcyclesIso.inv := by\n  dsimp only [rightHomologyι, rightHomologyIso, opcyclesIso, rightHomologyMapIso',\n    opcyclesMapIso', Iso.refl]\n  rw [rightHomologyι_naturality']\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.rightHomologyIso_hom_comp_ι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.rightHomologyIso.hom h.ι) (CategoryTheory.CategoryStruct.comp S.rightHomologyι h.opcyclesIso.hom)","decl":"@[reassoc (attr := simp)]\nlemma rightHomologyIso_hom_comp_ι :\n    h.rightHomologyIso.hom ≫ h.ι = S.rightHomologyι ≫ h.opcyclesIso.hom := by\n  simp only [← cancel_mono h.opcyclesIso.inv, ← cancel_epi h.rightHomologyIso.inv,\n    assoc, Iso.inv_hom_id_assoc, Iso.hom_inv_id, comp_id, rightHomologyIso_inv_comp_rightHomologyι]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.rightHomologyIso_hom_comp_ι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.RightHomologyData\ninst✝ : S.HasRightHomology\nZ : C\nh : Quiver.Hom h✝.Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.rightHomologyIso.hom (CategoryTheory.CategoryStruct.comp h✝.ι h)) (CategoryTheory.CategoryStruct.comp S.rightHomologyι (CategoryTheory.CategoryStruct.comp h✝.opcyclesIso.hom h))","decl":"@[reassoc (attr := simp)]\nlemma rightHomologyIso_hom_comp_ι :\n    h.rightHomologyIso.hom ≫ h.ι = S.rightHomologyι ≫ h.opcyclesIso.hom := by\n  simp only [← cancel_mono h.opcyclesIso.inv, ← cancel_epi h.rightHomologyIso.inv,\n    assoc, Iso.inv_hom_id_assoc, Iso.hom_inv_id, comp_id, rightHomologyIso_inv_comp_rightHomologyι]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.rightHomologyMap_eq","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap φ) (CategoryTheory.CategoryStruct.comp h₁.rightHomologyIso.hom (CategoryTheory.CategoryStruct.comp γ.φH h₂.rightHomologyIso.inv))","decl":"lemma rightHomologyMap_eq [S₁.HasRightHomology] [S₂.HasRightHomology] :\n    rightHomologyMap φ = h₁.rightHomologyIso.hom ≫ γ.φH ≫ h₂.rightHomologyIso.inv := by\n  dsimp [RightHomologyData.rightHomologyIso, rightHomologyMapIso']\n  rw [← γ.rightHomologyMap'_eq, ← rightHomologyMap'_comp,\n    ← rightHomologyMap'_comp, id_comp, comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.opcyclesMap_eq","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap φ) (CategoryTheory.CategoryStruct.comp h₁.opcyclesIso.hom (CategoryTheory.CategoryStruct.comp γ.φQ h₂.opcyclesIso.inv))","decl":"lemma opcyclesMap_eq [S₁.HasRightHomology] [S₂.HasRightHomology] :\n    opcyclesMap φ = h₁.opcyclesIso.hom ≫ γ.φQ ≫ h₂.opcyclesIso.inv := by\n  dsimp [RightHomologyData.opcyclesIso, cyclesMapIso']\n  rw [← γ.opcyclesMap'_eq, ← opcyclesMap'_comp, ← opcyclesMap'_comp, id_comp, comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.rightHomologyMap_comm","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap φ) h₂.rightHomologyIso.hom) (CategoryTheory.CategoryStruct.comp h₁.rightHomologyIso.hom γ.φH)","decl":"lemma rightHomologyMap_comm [S₁.HasRightHomology] [S₂.HasRightHomology] :\n    rightHomologyMap φ ≫ h₂.rightHomologyIso.hom = h₁.rightHomologyIso.hom ≫ γ.φH := by\n  simp only [γ.rightHomologyMap_eq, assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.opcyclesMap_comm","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap φ) h₂.opcyclesIso.hom) (CategoryTheory.CategoryStruct.comp h₁.opcyclesIso.hom γ.φQ)","decl":"lemma opcyclesMap_comm [S₁.HasRightHomology] [S₂.HasRightHomology] :\n    opcyclesMap φ ≫ h₂.opcyclesIso.hom = h₁.opcyclesIso.hom ≫ γ.φQ := by\n  simp only [γ.opcyclesMap_eq, assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyFunctor_obj","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n⊢ Eq ((CategoryTheory.ShortComplex.rightHomologyFunctor C).obj S) S.rightHomology","decl":"/-- The right homology functor `ShortComplex C ⥤ C`, where the right homology of a\nshort complex `S` is understood as a kernel of the obvious map `S.fromOpcycles : S.opcycles ⟶ S.X₃`\nwhere `S.opcycles` is a cokernel of `S.f : S.X₁ ⟶ S.X₂`. -/\n@[simps]\nnoncomputable def rightHomologyFunctor : ShortComplex C ⥤ C where\n  obj S := S.rightHomology\n  map := rightHomologyMap\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyFunctor_map","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nX✝ Y✝ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.ShortComplex.rightHomologyFunctor C).map φ) (CategoryTheory.ShortComplex.rightHomologyMap φ)","decl":"/-- The right homology functor `ShortComplex C ⥤ C`, where the right homology of a\nshort complex `S` is understood as a kernel of the obvious map `S.fromOpcycles : S.opcycles ⟶ S.X₃`\nwhere `S.opcycles` is a cokernel of `S.f : S.X₁ ⟶ S.X₂`. -/\n@[simps]\nnoncomputable def rightHomologyFunctor : ShortComplex C ⥤ C where\n  obj S := S.rightHomology\n  map := rightHomologyMap\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesFunctor_obj","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n⊢ Eq ((CategoryTheory.ShortComplex.opcyclesFunctor C).obj S) S.opcycles","decl":"/-- The opcycles functor `ShortComplex C ⥤ C` which sends a short complex `S` to `S.opcycles`\nwhich is a cokernel of `S.f : S.X₁ ⟶ S.X₂`. -/\n@[simps]\nnoncomputable def opcyclesFunctor :\n    ShortComplex C ⥤ C where\n  obj S := S.opcycles\n  map := opcyclesMap\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesFunctor_map","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nX✝ Y✝ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.ShortComplex.opcyclesFunctor C).map φ) (CategoryTheory.ShortComplex.opcyclesMap φ)","decl":"/-- The opcycles functor `ShortComplex C ⥤ C` which sends a short complex `S` to `S.opcycles`\nwhich is a cokernel of `S.f : S.X₁ ⟶ S.X₂`. -/\n@[simps]\nnoncomputable def opcyclesFunctor :\n    ShortComplex C ⥤ C where\n  obj S := S.opcycles\n  map := opcyclesMap\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyιNatTrans_app","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n⊢ Eq ((CategoryTheory.ShortComplex.rightHomologyιNatTrans C).app S) S.rightHomologyι","decl":"/-- The natural transformation `S.rightHomology ⟶ S.opcycles` for all short complexes `S`. -/\n@[simps]\nnoncomputable def rightHomologyιNatTrans :\n    rightHomologyFunctor C ⟶ opcyclesFunctor C where\n  app S := rightHomologyι S\n  naturality := fun _ _ φ => rightHomologyι_naturality φ\n\n"}
{"name":"CategoryTheory.ShortComplex.pOpcyclesNatTrans_app","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n⊢ Eq ((CategoryTheory.ShortComplex.pOpcyclesNatTrans C).app S) S.pOpcycles","decl":"/-- The natural transformation `S.X₂ ⟶ S.opcycles` for all short complexes `S`. -/\n@[simps]\nnoncomputable def pOpcyclesNatTrans :\n    ShortComplex.π₂ ⟶ opcyclesFunctor C where\n  app S := S.pOpcycles\n\n"}
{"name":"CategoryTheory.ShortComplex.fromOpcyclesNatTrans_app","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nS : CategoryTheory.ShortComplex C\n⊢ Eq ((CategoryTheory.ShortComplex.fromOpcyclesNatTrans C).app S) S.fromOpcycles","decl":"/-- The natural transformation `S.opcycles ⟶ S.X₃` for all short complexes `S`. -/\n@[simps]\nnoncomputable def fromOpcyclesNatTrans :\n    opcyclesFunctor C ⟶ π₃ where\n  app S := S.fromOpcycles\n  naturality := fun _ _  φ => fromOpcycles_naturality φ\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.op_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nψ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\n⊢ Eq ψ.op.φQ ψ.φK.op","decl":"/-- A left homology map data for a morphism of short complexes induces\na right homology map data in the opposite category. -/\n@[simps]\ndef LeftHomologyMapData.op {S₁ S₂ : ShortComplex C} {φ : S₁ ⟶ S₂}\n    {h₁ : S₁.LeftHomologyData} {h₂ : S₂.LeftHomologyData}\n    (ψ : LeftHomologyMapData φ h₁ h₂) : RightHomologyMapData (opMap φ) h₂.op h₁.op where\n  φQ := ψ.φK.op\n  φH := ψ.φH.op\n  commp := Quiver.Hom.unop_inj (by simp)\n  commg' := Quiver.Hom.unop_inj (by simp)\n  commι := Quiver.Hom.unop_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.op_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nψ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\n⊢ Eq ψ.op.φH ψ.φH.op","decl":"/-- A left homology map data for a morphism of short complexes induces\na right homology map data in the opposite category. -/\n@[simps]\ndef LeftHomologyMapData.op {S₁ S₂ : ShortComplex C} {φ : S₁ ⟶ S₂}\n    {h₁ : S₁.LeftHomologyData} {h₂ : S₂.LeftHomologyData}\n    (ψ : LeftHomologyMapData φ h₁ h₂) : RightHomologyMapData (opMap φ) h₂.op h₁.op where\n  φQ := ψ.φK.op\n  φH := ψ.φH.op\n  commp := Quiver.Hom.unop_inj (by simp)\n  commg' := Quiver.Hom.unop_inj (by simp)\n  commι := Quiver.Hom.unop_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.unop_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex (Opposite C)\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nψ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\n⊢ Eq ψ.unop.φH ψ.φH.unop","decl":"/-- A left homology map data for a morphism of short complexes in the opposite category\ninduces a right homology map data in the original category. -/\n@[simps]\ndef LeftHomologyMapData.unop {S₁ S₂ : ShortComplex Cᵒᵖ} {φ : S₁ ⟶ S₂}\n    {h₁ : S₁.LeftHomologyData} {h₂ : S₂.LeftHomologyData}\n    (ψ : LeftHomologyMapData φ h₁ h₂) : RightHomologyMapData (unopMap φ) h₂.unop h₁.unop where\n  φQ := ψ.φK.unop\n  φH := ψ.φH.unop\n  commp := Quiver.Hom.op_inj (by simp)\n  commg' := Quiver.Hom.op_inj (by simp)\n  commι := Quiver.Hom.op_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.unop_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex (Opposite C)\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nψ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\n⊢ Eq ψ.unop.φQ ψ.φK.unop","decl":"/-- A left homology map data for a morphism of short complexes in the opposite category\ninduces a right homology map data in the original category. -/\n@[simps]\ndef LeftHomologyMapData.unop {S₁ S₂ : ShortComplex Cᵒᵖ} {φ : S₁ ⟶ S₂}\n    {h₁ : S₁.LeftHomologyData} {h₂ : S₂.LeftHomologyData}\n    (ψ : LeftHomologyMapData φ h₁ h₂) : RightHomologyMapData (unopMap φ) h₂.unop h₁.unop where\n  φQ := ψ.φK.unop\n  φH := ψ.φH.unop\n  commp := Quiver.Hom.op_inj (by simp)\n  commg' := Quiver.Hom.op_inj (by simp)\n  commι := Quiver.Hom.op_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.op_φK","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nψ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\n⊢ Eq ψ.op.φK ψ.φQ.op","decl":"/-- A right homology map data for a morphism of short complexes induces\na left homology map data in the opposite category. -/\n@[simps]\ndef RightHomologyMapData.op {S₁ S₂ : ShortComplex C} {φ : S₁ ⟶ S₂}\n    {h₁ : S₁.RightHomologyData} {h₂ : S₂.RightHomologyData}\n    (ψ : RightHomologyMapData φ h₁ h₂) : LeftHomologyMapData (opMap φ) h₂.op h₁.op where\n  φK := ψ.φQ.op\n  φH := ψ.φH.op\n  commi := Quiver.Hom.unop_inj (by simp)\n  commf' := Quiver.Hom.unop_inj (by simp)\n  commπ := Quiver.Hom.unop_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.op_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nψ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\n⊢ Eq ψ.op.φH ψ.φH.op","decl":"/-- A right homology map data for a morphism of short complexes induces\na left homology map data in the opposite category. -/\n@[simps]\ndef RightHomologyMapData.op {S₁ S₂ : ShortComplex C} {φ : S₁ ⟶ S₂}\n    {h₁ : S₁.RightHomologyData} {h₂ : S₂.RightHomologyData}\n    (ψ : RightHomologyMapData φ h₁ h₂) : LeftHomologyMapData (opMap φ) h₂.op h₁.op where\n  φK := ψ.φQ.op\n  φH := ψ.φH.op\n  commi := Quiver.Hom.unop_inj (by simp)\n  commf' := Quiver.Hom.unop_inj (by simp)\n  commπ := Quiver.Hom.unop_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.unop_φK","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex (Opposite C)\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nψ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\n⊢ Eq ψ.unop.φK ψ.φQ.unop","decl":"/-- A right homology map data for a morphism of short complexes in the opposite category\ninduces a left homology map data in the original category. -/\n@[simps]\ndef RightHomologyMapData.unop {S₁ S₂ : ShortComplex Cᵒᵖ} {φ : S₁ ⟶ S₂}\n    {h₁ : S₁.RightHomologyData} {h₂ : S₂.RightHomologyData}\n    (ψ : RightHomologyMapData φ h₁ h₂) : LeftHomologyMapData (unopMap φ) h₂.unop h₁.unop where\n  φK := ψ.φQ.unop\n  φH := ψ.φH.unop\n  commi := Quiver.Hom.op_inj (by simp)\n  commf' := Quiver.Hom.op_inj (by simp)\n  commπ := Quiver.Hom.op_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.unop_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex (Opposite C)\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nψ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\n⊢ Eq ψ.unop.φH ψ.φH.unop","decl":"/-- A right homology map data for a morphism of short complexes in the opposite category\ninduces a left homology map data in the original category. -/\n@[simps]\ndef RightHomologyMapData.unop {S₁ S₂ : ShortComplex Cᵒᵖ} {φ : S₁ ⟶ S₂}\n    {h₁ : S₁.RightHomologyData} {h₂ : S₂.RightHomologyData}\n    (ψ : RightHomologyMapData φ h₁ h₂) : LeftHomologyMapData (unopMap φ) h₂.unop h₁.unop where\n  φK := ψ.φQ.unop\n  φH := ψ.φH.unop\n  commi := Quiver.Hom.op_inj (by simp)\n  commf' := Quiver.Hom.op_inj (by simp)\n  commπ := Quiver.Hom.op_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesOpIso_hom_toCycles_op_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nZ : Opposite C\nh : Quiver.Hom { unop := S.X₁ } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.opcyclesOpIso.hom (CategoryTheory.CategoryStruct.comp S.toCycles.op h)) (CategoryTheory.CategoryStruct.comp S.op.fromOpcycles h)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesOpIso_hom_toCycles_op [S.HasLeftHomology] :\n    S.opcyclesOpIso.hom ≫ S.toCycles.op = S.op.fromOpcycles := by\n  dsimp [opcyclesOpIso, toCycles]\n  rw [← cancel_epi S.op.pOpcycles, p_fromOpcycles,\n    RightHomologyData.pOpcycles_comp_opcyclesIso_hom_assoc,\n    LeftHomologyData.op_p, ← op_comp, LeftHomologyData.f'_i, op_g]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesOpIso_hom_toCycles_op","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.opcyclesOpIso.hom S.toCycles.op) S.op.fromOpcycles","decl":"@[reassoc (attr := simp)]\nlemma opcyclesOpIso_hom_toCycles_op [S.HasLeftHomology] :\n    S.opcyclesOpIso.hom ≫ S.toCycles.op = S.op.fromOpcycles := by\n  dsimp [opcyclesOpIso, toCycles]\n  rw [← cancel_epi S.op.pOpcycles, p_fromOpcycles,\n    RightHomologyData.pOpcycles_comp_opcyclesIso_hom_assoc,\n    LeftHomologyData.op_p, ← op_comp, LeftHomologyData.f'_i, op_g]\n\n"}
{"name":"CategoryTheory.ShortComplex.fromOpcycles_op_cyclesOpIso_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nZ : Opposite C\nh : Quiver.Hom S.op.cycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.fromOpcycles.op (CategoryTheory.CategoryStruct.comp S.cyclesOpIso.inv h)) (CategoryTheory.CategoryStruct.comp S.op.toCycles h)","decl":"@[reassoc (attr := simp)]\nlemma fromOpcycles_op_cyclesOpIso_inv [S.HasRightHomology]:\n    S.fromOpcycles.op ≫ S.cyclesOpIso.inv = S.op.toCycles := by\n  dsimp [cyclesOpIso, fromOpcycles]\n  rw [← cancel_mono S.op.iCycles, assoc, toCycles_i,\n    LeftHomologyData.cyclesIso_inv_comp_iCycles, RightHomologyData.op_i,\n    ← op_comp, RightHomologyData.p_g', op_f]\n\n"}
{"name":"CategoryTheory.ShortComplex.fromOpcycles_op_cyclesOpIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.fromOpcycles.op S.cyclesOpIso.inv) S.op.toCycles","decl":"@[reassoc (attr := simp)]\nlemma fromOpcycles_op_cyclesOpIso_inv [S.HasRightHomology]:\n    S.fromOpcycles.op ≫ S.cyclesOpIso.inv = S.op.toCycles := by\n  dsimp [cyclesOpIso, fromOpcycles]\n  rw [← cancel_mono S.op.iCycles, assoc, toCycles_i,\n    LeftHomologyData.cyclesIso_inv_comp_iCycles, RightHomologyData.op_i,\n    ← op_comp, RightHomologyData.p_g', op_f]\n\n"}
{"name":"CategoryTheory.ShortComplex.op_pOpcycles_opcyclesOpIso_hom_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\nZ : Opposite C\nh : Quiver.Hom { unop := S.cycles } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.op.pOpcycles (CategoryTheory.CategoryStruct.comp S.opcyclesOpIso.hom h)) (CategoryTheory.CategoryStruct.comp S.iCycles.op h)","decl":"@[reassoc (attr := simp)]\nlemma op_pOpcycles_opcyclesOpIso_hom [S.HasLeftHomology] :\n    S.op.pOpcycles ≫ S.opcyclesOpIso.hom = S.iCycles.op := by\n  dsimp [opcyclesOpIso]\n  rw [← S.leftHomologyData.op.p_comp_opcyclesIso_inv, assoc,\n    Iso.inv_hom_id, comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.op_pOpcycles_opcyclesOpIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.op.pOpcycles S.opcyclesOpIso.hom) S.iCycles.op","decl":"@[reassoc (attr := simp)]\nlemma op_pOpcycles_opcyclesOpIso_hom [S.HasLeftHomology] :\n    S.op.pOpcycles ≫ S.opcyclesOpIso.hom = S.iCycles.op := by\n  dsimp [opcyclesOpIso]\n  rw [← S.leftHomologyData.op.p_comp_opcyclesIso_inv, assoc,\n    Iso.inv_hom_id, comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesOpIso_inv_op_iCycles","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.cyclesOpIso.inv S.op.iCycles) S.pOpcycles.op","decl":"@[reassoc (attr := simp)]\nlemma cyclesOpIso_inv_op_iCycles [S.HasRightHomology] :\n    S.cyclesOpIso.inv ≫ S.op.iCycles = S.pOpcycles.op := by\n  dsimp [cyclesOpIso]\n  rw [← S.rightHomologyData.op.cyclesIso_hom_comp_i, Iso.inv_hom_id_assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesOpIso_inv_op_iCycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nZ : Opposite C\nh : Quiver.Hom S.op.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.cyclesOpIso.inv (CategoryTheory.CategoryStruct.comp S.op.iCycles h)) (CategoryTheory.CategoryStruct.comp S.pOpcycles.op h)","decl":"@[reassoc (attr := simp)]\nlemma cyclesOpIso_inv_op_iCycles [S.HasRightHomology] :\n    S.cyclesOpIso.inv ≫ S.op.iCycles = S.pOpcycles.op := by\n  dsimp [cyclesOpIso]\n  rw [← S.rightHomologyData.op.cyclesIso_hom_comp_i, Iso.inv_hom_id_assoc]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesOpIso_hom_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap (CategoryTheory.ShortComplex.opMap φ)) S₁.opcyclesOpIso.hom) (CategoryTheory.CategoryStruct.comp S₂.opcyclesOpIso.hom (CategoryTheory.ShortComplex.cyclesMap φ).op)","decl":"@[reassoc]\nlemma opcyclesOpIso_hom_naturality (φ : S₁ ⟶ S₂)\n    [S₁.HasLeftHomology] [S₂.HasLeftHomology] :\n    opcyclesMap (opMap φ) ≫ (S₁.opcyclesOpIso).hom =\n      S₂.opcyclesOpIso.hom ≫ (cyclesMap φ).op := by\n  rw [← cancel_epi S₂.op.pOpcycles, p_opcyclesMap_assoc, opMap_τ₂,\n    op_pOpcycles_opcyclesOpIso_hom, op_pOpcycles_opcyclesOpIso_hom_assoc, ← op_comp,\n    ← op_comp, cyclesMap_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesOpIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\nZ : Opposite C\nh : Quiver.Hom { unop := S₁.cycles } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap (CategoryTheory.ShortComplex.opMap φ)) (CategoryTheory.CategoryStruct.comp S₁.opcyclesOpIso.hom h)) (CategoryTheory.CategoryStruct.comp S₂.opcyclesOpIso.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ).op h))","decl":"@[reassoc]\nlemma opcyclesOpIso_hom_naturality (φ : S₁ ⟶ S₂)\n    [S₁.HasLeftHomology] [S₂.HasLeftHomology] :\n    opcyclesMap (opMap φ) ≫ (S₁.opcyclesOpIso).hom =\n      S₂.opcyclesOpIso.hom ≫ (cyclesMap φ).op := by\n  rw [← cancel_epi S₂.op.pOpcycles, p_opcyclesMap_assoc, opMap_τ₂,\n    op_pOpcycles_opcyclesOpIso_hom, op_pOpcycles_opcyclesOpIso_hom_assoc, ← op_comp,\n    ← op_comp, cyclesMap_i]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesOpIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\nZ : Opposite C\nh : Quiver.Hom S₁.op.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ).op (CategoryTheory.CategoryStruct.comp S₁.opcyclesOpIso.inv h)) (CategoryTheory.CategoryStruct.comp S₂.opcyclesOpIso.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap (CategoryTheory.ShortComplex.opMap φ)) h))","decl":"@[reassoc]\nlemma opcyclesOpIso_inv_naturality (φ : S₁ ⟶ S₂)\n    [S₁.HasLeftHomology] [S₂.HasLeftHomology] :\n    (cyclesMap φ).op ≫ (S₁.opcyclesOpIso).inv =\n      S₂.opcyclesOpIso.inv ≫ opcyclesMap (opMap φ) := by\n  rw [← cancel_epi (S₂.opcyclesOpIso.hom), Iso.hom_inv_id_assoc,\n    ← opcyclesOpIso_hom_naturality_assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesOpIso_inv_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ).op S₁.opcyclesOpIso.inv) (CategoryTheory.CategoryStruct.comp S₂.opcyclesOpIso.inv (CategoryTheory.ShortComplex.opcyclesMap (CategoryTheory.ShortComplex.opMap φ)))","decl":"@[reassoc]\nlemma opcyclesOpIso_inv_naturality (φ : S₁ ⟶ S₂)\n    [S₁.HasLeftHomology] [S₂.HasLeftHomology] :\n    (cyclesMap φ).op ≫ (S₁.opcyclesOpIso).inv =\n      S₂.opcyclesOpIso.inv ≫ opcyclesMap (opMap φ) := by\n  rw [← cancel_epi (S₂.opcyclesOpIso.hom), Iso.hom_inv_id_assoc,\n    ← opcyclesOpIso_hom_naturality_assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesOpIso_inv_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap φ).op S₁.cyclesOpIso.inv) (CategoryTheory.CategoryStruct.comp S₂.cyclesOpIso.inv (CategoryTheory.ShortComplex.cyclesMap (CategoryTheory.ShortComplex.opMap φ)))","decl":"@[reassoc]\nlemma cyclesOpIso_inv_naturality (φ : S₁ ⟶ S₂)\n    [S₁.HasRightHomology] [S₂.HasRightHomology] :\n    (opcyclesMap φ).op ≫ (S₁.cyclesOpIso).inv =\n      S₂.cyclesOpIso.inv ≫ cyclesMap (opMap φ) := by\n  rw [← cancel_mono S₁.op.iCycles, assoc, assoc, cyclesOpIso_inv_op_iCycles, cyclesMap_i,\n    cyclesOpIso_inv_op_iCycles_assoc, ← op_comp, p_opcyclesMap, op_comp, opMap_τ₂]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesOpIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\nZ : Opposite C\nh : Quiver.Hom S₁.op.cycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap φ).op (CategoryTheory.CategoryStruct.comp S₁.cyclesOpIso.inv h)) (CategoryTheory.CategoryStruct.comp S₂.cyclesOpIso.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap (CategoryTheory.ShortComplex.opMap φ)) h))","decl":"@[reassoc]\nlemma cyclesOpIso_inv_naturality (φ : S₁ ⟶ S₂)\n    [S₁.HasRightHomology] [S₂.HasRightHomology] :\n    (opcyclesMap φ).op ≫ (S₁.cyclesOpIso).inv =\n      S₂.cyclesOpIso.inv ≫ cyclesMap (opMap φ) := by\n  rw [← cancel_mono S₁.op.iCycles, assoc, assoc, cyclesOpIso_inv_op_iCycles, cyclesMap_i,\n    cyclesOpIso_inv_op_iCycles_assoc, ← op_comp, p_opcyclesMap, op_comp, opMap_τ₂]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesOpIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\nZ : Opposite C\nh : Quiver.Hom { unop := S₁.opcycles } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap (CategoryTheory.ShortComplex.opMap φ)) (CategoryTheory.CategoryStruct.comp S₁.cyclesOpIso.hom h)) (CategoryTheory.CategoryStruct.comp S₂.cyclesOpIso.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap φ).op h))","decl":"@[reassoc]\nlemma cyclesOpIso_hom_naturality (φ : S₁ ⟶ S₂)\n    [S₁.HasRightHomology] [S₂.HasRightHomology] :\n    cyclesMap (opMap φ) ≫ (S₁.cyclesOpIso).hom =\n      S₂.cyclesOpIso.hom ≫ (opcyclesMap φ).op := by\n  rw [← cancel_mono (S₁.cyclesOpIso).inv, assoc, assoc, Iso.hom_inv_id, comp_id,\n    cyclesOpIso_inv_naturality, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.cyclesOpIso_hom_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap (CategoryTheory.ShortComplex.opMap φ)) S₁.cyclesOpIso.hom) (CategoryTheory.CategoryStruct.comp S₂.cyclesOpIso.hom (CategoryTheory.ShortComplex.opcyclesMap φ).op)","decl":"@[reassoc]\nlemma cyclesOpIso_hom_naturality (φ : S₁ ⟶ S₂)\n    [S₁.HasRightHomology] [S₂.HasRightHomology] :\n    cyclesMap (opMap φ) ≫ (S₁.cyclesOpIso).hom =\n      S₂.cyclesOpIso.hom ≫ (opcyclesMap φ).op := by\n  rw [← cancel_mono (S₁.cyclesOpIso).inv, assoc, assoc, Iso.hom_inv_id, comp_id,\n    cyclesOpIso_inv_naturality, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap'_op","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₂).op (CategoryTheory.ShortComplex.rightHomologyMap' (CategoryTheory.ShortComplex.opMap φ) h₂.op h₁.op)","decl":"@[simp]\nlemma leftHomologyMap'_op\n    (φ : S₁ ⟶ S₂) (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) :\n    (leftHomologyMap' φ h₁ h₂).op = rightHomologyMap' (opMap φ) h₂.op h₁.op := by\n  let γ : LeftHomologyMapData φ h₁ h₂ := leftHomologyMapData φ h₁ h₂\n  simp only [γ.leftHomologyMap'_eq, γ.op.rightHomologyMap'_eq,\n    LeftHomologyMapData.op_φH]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyMap_op","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasLeftHomology\ninst✝ : S₂.HasLeftHomology\n⊢ Eq (CategoryTheory.ShortComplex.leftHomologyMap φ).op (CategoryTheory.CategoryStruct.comp S₂.rightHomologyOpIso.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap (CategoryTheory.ShortComplex.opMap φ)) S₁.rightHomologyOpIso.hom))","decl":"lemma leftHomologyMap_op (φ : S₁ ⟶ S₂) [S₁.HasLeftHomology] [S₂.HasLeftHomology] :\n    (leftHomologyMap φ).op = S₂.rightHomologyOpIso.inv ≫ rightHomologyMap (opMap φ) ≫\n      S₁.rightHomologyOpIso.hom := by\n  dsimp [rightHomologyOpIso, RightHomologyData.rightHomologyIso, rightHomologyMap,\n    leftHomologyMap]\n  simp only [← rightHomologyMap'_comp, comp_id, id_comp, leftHomologyMap'_op]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap'_op","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap' φ h₁ h₂).op (CategoryTheory.ShortComplex.leftHomologyMap' (CategoryTheory.ShortComplex.opMap φ) h₂.op h₁.op)","decl":"@[simp]\nlemma rightHomologyMap'_op\n    (φ : S₁ ⟶ S₂) (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) :\n    (rightHomologyMap' φ h₁ h₂).op = leftHomologyMap' (opMap φ) h₂.op h₁.op := by\n  let γ : RightHomologyMapData φ h₁ h₂ := rightHomologyMapData φ h₁ h₂\n  simp only [γ.rightHomologyMap'_eq, γ.op.leftHomologyMap'_eq,\n    RightHomologyMapData.op_φH]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyMap_op","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ Eq (CategoryTheory.ShortComplex.rightHomologyMap φ).op (CategoryTheory.CategoryStruct.comp S₂.leftHomologyOpIso.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap (CategoryTheory.ShortComplex.opMap φ)) S₁.leftHomologyOpIso.hom))","decl":"lemma rightHomologyMap_op (φ : S₁ ⟶ S₂) [S₁.HasRightHomology] [S₂.HasRightHomology] :\n    (rightHomologyMap φ).op = S₂.leftHomologyOpIso.inv ≫ leftHomologyMap (opMap φ) ≫\n      S₁.leftHomologyOpIso.hom := by\n  dsimp [leftHomologyOpIso, LeftHomologyData.leftHomologyIso, leftHomologyMap,\n    rightHomologyMap]\n  simp only [← leftHomologyMap'_comp, comp_id, id_comp, rightHomologyMap'_op]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono_Q","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono φ h).Q h.Q","decl":"@[simp] lemma ofEpiOfIsIsoOfMono_Q : (ofEpiOfIsIsoOfMono φ h).Q = h.Q := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono_H","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono φ h).H h.H","decl":"@[simp] lemma ofEpiOfIsIsoOfMono_H : (ofEpiOfIsIsoOfMono φ h).H = h.H := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono_p","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono φ h).p (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv φ.τ₂) h.p)","decl":"@[simp] lemma ofEpiOfIsIsoOfMono_p : (ofEpiOfIsIsoOfMono φ h).p = inv φ.τ₂ ≫ h.p := by\n  simp [ofEpiOfIsIsoOfMono, opMap]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono_ι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono φ h).ι h.ι","decl":"@[simp] lemma ofEpiOfIsIsoOfMono_ι : (ofEpiOfIsIsoOfMono φ h).ι = h.ι := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono_g'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono φ h).g' (CategoryTheory.CategoryStruct.comp h.g' φ.τ₃)","decl":"@[simp] lemma ofEpiOfIsIsoOfMono_g' : (ofEpiOfIsIsoOfMono φ h).g' = h.g' ≫ φ.τ₃ := by\n  simp [ofEpiOfIsIsoOfMono, opMap]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono'_Q","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono' φ h).Q h.Q","decl":"@[simp] lemma ofEpiOfIsIsoOfMono'_Q : (ofEpiOfIsIsoOfMono' φ h).Q = h.Q := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono'_H","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono' φ h).H h.H","decl":"@[simp] lemma ofEpiOfIsIsoOfMono'_H : (ofEpiOfIsIsoOfMono' φ h).H = h.H := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono'_p","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono' φ h).p (CategoryTheory.CategoryStruct.comp φ.τ₂ h.p)","decl":"@[simp] lemma ofEpiOfIsIsoOfMono'_p : (ofEpiOfIsIsoOfMono' φ h).p = φ.τ₂ ≫ h.p := by\n  simp [ofEpiOfIsIsoOfMono', opMap]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono'_ι","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono' φ h).ι h.ι","decl":"@[simp] lemma ofEpiOfIsIsoOfMono'_ι : (ofEpiOfIsIsoOfMono' φ h).ι = h.ι := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono'_g'_τ₃","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono' φ h).g' φ.τ₃) h.g'","decl":"@[simp] lemma ofEpiOfIsIsoOfMono'_g'_τ₃ : (ofEpiOfIsIsoOfMono' φ h).g' ≫ φ.τ₃ = h.g' := by\n  rw [← cancel_epi (ofEpiOfIsIsoOfMono' φ h).p, p_g'_assoc, ofEpiOfIsIsoOfMono'_p,\n    assoc, p_g', φ.comm₂₃]\n\n"}
{"name":"CategoryTheory.ShortComplex.hasRightHomology_of_epi_of_isIso_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝³ : S₁.HasRightHomology\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ S₂.HasRightHomology","decl":"lemma hasRightHomology_of_epi_of_isIso_of_mono (φ : S₁ ⟶ S₂) [HasRightHomology S₁]\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : HasRightHomology S₂ :=\n  HasRightHomology.mk' (RightHomologyData.ofEpiOfIsIsoOfMono φ S₁.rightHomologyData)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasRightHomology_of_epi_of_isIso_of_mono'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝³ : S₂.HasRightHomology\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ S₁.HasRightHomology","decl":"lemma hasRightHomology_of_epi_of_isIso_of_mono' (φ : S₁ ⟶ S₂) [HasRightHomology S₂]\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : HasRightHomology S₁ :=\nHasRightHomology.mk' (RightHomologyData.ofEpiOfIsIsoOfMono' φ S₂.rightHomologyData)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasRightHomology_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\ninst✝ : S₁.HasRightHomology\n⊢ S₂.HasRightHomology","decl":"lemma hasRightHomology_of_iso {S₁ S₂ : ShortComplex C}\n    (e : S₁ ≅ S₂) [HasRightHomology S₁] : HasRightHomology S₂ :=\n  hasRightHomology_of_epi_of_isIso_of_mono e.hom\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.ofEpiOfIsIsoOfMono_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.ofEpiOfIsIsoOfMono φ h).φH (CategoryTheory.CategoryStruct.id h.H)","decl":"/-- This right homology map data expresses compatibilities of the right homology data\nconstructed by `RightHomologyData.ofEpiOfIsIsoOfMono` -/\n@[simps]\ndef ofEpiOfIsIsoOfMono (φ : S₁ ⟶ S₂) (h : RightHomologyData S₁)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    RightHomologyMapData φ h (RightHomologyData.ofEpiOfIsIsoOfMono φ h) where\n  φQ := 𝟙 _\n  φH := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.ofEpiOfIsIsoOfMono_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.ofEpiOfIsIsoOfMono φ h).φQ (CategoryTheory.CategoryStruct.id h.Q)","decl":"/-- This right homology map data expresses compatibilities of the right homology data\nconstructed by `RightHomologyData.ofEpiOfIsIsoOfMono` -/\n@[simps]\ndef ofEpiOfIsIsoOfMono (φ : S₁ ⟶ S₂) (h : RightHomologyData S₁)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    RightHomologyMapData φ h (RightHomologyData.ofEpiOfIsIsoOfMono φ h) where\n  φQ := 𝟙 _\n  φH := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.ofEpiOfIsIsoOfMono'_φQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.ofEpiOfIsIsoOfMono' φ h).φQ (CategoryTheory.CategoryStruct.id (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono' φ h).Q)","decl":"/-- This right homology map data expresses compatibilities of the right homology data\nconstructed by `RightHomologyData.ofEpiOfIsIsoOfMono'` -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (φ : S₁ ⟶ S₂) (h : RightHomologyData S₂)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    RightHomologyMapData φ (RightHomologyData.ofEpiOfIsIsoOfMono' φ h) h where\n  φQ := 𝟙 _\n  φH := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.ofEpiOfIsIsoOfMono'_φH","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyMapData.ofEpiOfIsIsoOfMono' φ h).φH (CategoryTheory.CategoryStruct.id (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono' φ h).H)","decl":"/-- This right homology map data expresses compatibilities of the right homology data\nconstructed by `RightHomologyData.ofEpiOfIsIsoOfMono'` -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (φ : S₁ ⟶ S₂) (h : RightHomologyData S₂)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    RightHomologyMapData φ (RightHomologyData.ofEpiOfIsIsoOfMono' φ h) h where\n  φQ := 𝟙 _\n  φH := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.instIsIsoRightHomologyMap'OfEpiτ₁Ofτ₂OfMonoτ₃","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.rightHomologyMap' φ h₁ h₂)","decl":"instance (φ : S₁ ⟶ S₂) (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    IsIso (rightHomologyMap' φ h₁ h₂) := by\n  let h₂' := RightHomologyData.ofEpiOfIsIsoOfMono φ h₁\n  haveI : IsIso (rightHomologyMap' φ h₁ h₂') := by\n    rw [(RightHomologyMapData.ofEpiOfIsIsoOfMono φ h₁).rightHomologyMap'_eq]\n    dsimp\n    infer_instance\n  have eq := rightHomologyMap'_comp φ (𝟙 S₂) h₁ h₂' h₂\n  rw [comp_id] at eq\n  rw [eq]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.instIsIsoRightHomologyMapOfEpiτ₁Ofτ₂OfMonoτ₃","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝⁴ : S₁.HasRightHomology\ninst✝³ : S₂.HasRightHomology\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.rightHomologyMap φ)","decl":"/-- If a morphism of short complexes `φ : S₁ ⟶ S₂` is such that `φ.τ₁` is epi, `φ.τ₂` is an iso,\nand `φ.τ₃` is mono, then the induced morphism on right homology is an isomorphism. -/\ninstance (φ : S₁ ⟶ S₂) [S₁.HasRightHomology] [S₂.HasRightHomology]\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    IsIso (rightHomologyMap φ) := by\n  dsimp only [rightHomologyMap]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyFunctorOpNatIso_hom_app","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasKernels C\ninst✝² : CategoryTheory.Limits.HasCokernels C\ninst✝¹ : CategoryTheory.Limits.HasKernels (Opposite C)\ninst✝ : CategoryTheory.Limits.HasCokernels (Opposite C)\nX : Opposite (CategoryTheory.ShortComplex C)\n⊢ Eq ((CategoryTheory.ShortComplex.rightHomologyFunctorOpNatIso C).hom.app X) (Opposite.unop X).leftHomologyOpIso.inv","decl":"/-- The opposite of the right homology functor is the left homology functor. -/\n@[simps!]\nnoncomputable def rightHomologyFunctorOpNatIso :\n    (rightHomologyFunctor C).op ≅ opFunctor C ⋙ leftHomologyFunctor Cᵒᵖ :=\n  NatIso.ofComponents (fun S => (leftHomologyOpIso S.unop).symm)\n    (by simp [rightHomologyMap_op])\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyFunctorOpNatIso_inv_app","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasKernels C\ninst✝² : CategoryTheory.Limits.HasCokernels C\ninst✝¹ : CategoryTheory.Limits.HasKernels (Opposite C)\ninst✝ : CategoryTheory.Limits.HasCokernels (Opposite C)\nX : Opposite (CategoryTheory.ShortComplex C)\n⊢ Eq ((CategoryTheory.ShortComplex.rightHomologyFunctorOpNatIso C).inv.app X) (Opposite.unop X).leftHomologyOpIso.hom","decl":"/-- The opposite of the right homology functor is the left homology functor. -/\n@[simps!]\nnoncomputable def rightHomologyFunctorOpNatIso :\n    (rightHomologyFunctor C).op ≅ opFunctor C ⋙ leftHomologyFunctor Cᵒᵖ :=\n  NatIso.ofComponents (fun S => (leftHomologyOpIso S.unop).symm)\n    (by simp [rightHomologyMap_op])\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyFunctorOpNatIso_hom_app","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasKernels C\ninst✝² : CategoryTheory.Limits.HasCokernels C\ninst✝¹ : CategoryTheory.Limits.HasKernels (Opposite C)\ninst✝ : CategoryTheory.Limits.HasCokernels (Opposite C)\nX : Opposite (CategoryTheory.ShortComplex C)\n⊢ Eq ((CategoryTheory.ShortComplex.leftHomologyFunctorOpNatIso C).hom.app X) (Opposite.unop X).rightHomologyOpIso.inv","decl":"/-- The opposite of the left homology functor is the right homology functor. -/\n@[simps!]\nnoncomputable def leftHomologyFunctorOpNatIso :\n    (leftHomologyFunctor C).op ≅ opFunctor C ⋙ rightHomologyFunctor Cᵒᵖ :=\n  NatIso.ofComponents (fun S => (rightHomologyOpIso S.unop).symm)\n    (by simp [leftHomologyMap_op])\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyFunctorOpNatIso_inv_app","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasKernels C\ninst✝² : CategoryTheory.Limits.HasCokernels C\ninst✝¹ : CategoryTheory.Limits.HasKernels (Opposite C)\ninst✝ : CategoryTheory.Limits.HasCokernels (Opposite C)\nX : Opposite (CategoryTheory.ShortComplex C)\n⊢ Eq ((CategoryTheory.ShortComplex.leftHomologyFunctorOpNatIso C).inv.app X) (Opposite.unop X).rightHomologyOpIso.hom","decl":"/-- The opposite of the left homology functor is the right homology functor. -/\n@[simps!]\nnoncomputable def leftHomologyFunctorOpNatIso :\n    (leftHomologyFunctor C).op ≅ opFunctor C ⋙ rightHomologyFunctor Cᵒᵖ :=\n  NatIso.ofComponents (fun S => (rightHomologyOpIso S.unop).symm)\n    (by simp [leftHomologyMap_op])\n\n"}
{"name":"CategoryTheory.ShortComplex.p_descOpcycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\ninst✝ : S.HasRightHomology\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.pOpcycles (CategoryTheory.CategoryStruct.comp (S.descOpcycles k hk) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma p_descOpcycles : S.pOpcycles ≫ S.descOpcycles k hk = k :=\n  RightHomologyData.p_descQ _ k hk\n\n"}
{"name":"CategoryTheory.ShortComplex.p_descOpcycles","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.pOpcycles (S.descOpcycles k hk)) k","decl":"@[reassoc (attr := simp)]\nlemma p_descOpcycles : S.pOpcycles ≫ S.descOpcycles k hk = k :=\n  RightHomologyData.p_descQ _ k hk\n\n"}
{"name":"CategoryTheory.ShortComplex.descOpcycles_comp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\ninst✝ : S.HasRightHomology\nA' : C\nα : Quiver.Hom A A'\nZ : C\nh : Quiver.Hom A' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.descOpcycles k hk) (CategoryTheory.CategoryStruct.comp α h)) (CategoryTheory.CategoryStruct.comp (S.descOpcycles (CategoryTheory.CategoryStruct.comp k α) ⋯) h)","decl":"@[reassoc]\nlemma descOpcycles_comp {A' : C} (α : A ⟶ A') :\n    S.descOpcycles k hk ≫ α = S.descOpcycles (k ≫ α) (by rw [reassoc_of% hk, zero_comp]) := by\n  simp only [← cancel_epi S.pOpcycles, p_descOpcycles_assoc, p_descOpcycles]\n\n"}
{"name":"CategoryTheory.ShortComplex.descOpcycles_comp","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\ninst✝ : S.HasRightHomology\nA' : C\nα : Quiver.Hom A A'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.descOpcycles k hk) α) (S.descOpcycles (CategoryTheory.CategoryStruct.comp k α) ⋯)","decl":"@[reassoc]\nlemma descOpcycles_comp {A' : C} (α : A ⟶ A') :\n    S.descOpcycles k hk ≫ α = S.descOpcycles (k ≫ α) (by rw [reassoc_of% hk, zero_comp]) := by\n  simp only [← cancel_epi S.pOpcycles, p_descOpcycles_assoc, p_descOpcycles]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesIsoCokernel_inv","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : S.HasRightHomology\ninst✝ : CategoryTheory.Limits.HasCokernel S.f\n⊢ Eq S.opcyclesIsoCokernel.inv (CategoryTheory.Limits.cokernel.desc S.f S.pOpcycles ⋯)","decl":"/-- The canonical isomorphism `S.opcycles ≅ cokernel S.f`. -/\n@[simps]\nnoncomputable def opcyclesIsoCokernel [HasCokernel S.f] : S.opcycles ≅ cokernel S.f where\n  hom := S.descOpcycles (cokernel.π S.f) (by simp)\n  inv := cokernel.desc S.f S.pOpcycles (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesIsoCokernel_hom","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : S.HasRightHomology\ninst✝ : CategoryTheory.Limits.HasCokernel S.f\n⊢ Eq S.opcyclesIsoCokernel.hom (S.descOpcycles (CategoryTheory.Limits.cokernel.π S.f) ⋯)","decl":"/-- The canonical isomorphism `S.opcycles ≅ cokernel S.f`. -/\n@[simps]\nnoncomputable def opcyclesIsoCokernel [HasCokernel S.f] : S.opcycles ≅ cokernel S.f where\n  hom := S.descOpcycles (cokernel.π S.f) (by simp)\n  inv := cokernel.desc S.f S.pOpcycles (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyι_descOpcycles_π_eq_zero_of_boundary_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom S.X₂ A\ninst✝ : S.HasRightHomology\nx : Quiver.Hom S.X₃ A\nhx : Eq k (CategoryTheory.CategoryStruct.comp S.g x)\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.rightHomologyι (CategoryTheory.CategoryStruct.comp (S.descOpcycles k ⋯) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma rightHomologyι_descOpcycles_π_eq_zero_of_boundary (x : S.X₃ ⟶ A) (hx : k = S.g ≫ x) :\n    S.rightHomologyι ≫ S.descOpcycles k (by rw [hx, S.zero_assoc, zero_comp]) = 0 :=\n  RightHomologyData.ι_descQ_eq_zero_of_boundary _ k x hx\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyι_descOpcycles_π_eq_zero_of_boundary","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom S.X₂ A\ninst✝ : S.HasRightHomology\nx : Quiver.Hom S.X₃ A\nhx : Eq k (CategoryTheory.CategoryStruct.comp S.g x)\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.rightHomologyι (S.descOpcycles k ⋯)) 0","decl":"@[reassoc]\nlemma rightHomologyι_descOpcycles_π_eq_zero_of_boundary (x : S.X₃ ⟶ A) (hx : k = S.g ≫ x) :\n    S.rightHomologyι ≫ S.descOpcycles k (by rw [hx, S.zero_assoc, zero_comp]) = 0 :=\n  RightHomologyData.ι_descQ_eq_zero_of_boundary _ k x hx\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyι_comp_fromOpcycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\nZ : C\nh : Quiver.Hom S.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.rightHomologyι (CategoryTheory.CategoryStruct.comp S.fromOpcycles h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma rightHomologyι_comp_fromOpcycles :\n    S.rightHomologyι ≫ S.fromOpcycles = 0 :=\n  S.rightHomologyι_descOpcycles_π_eq_zero_of_boundary S.g (𝟙 _) (by rw [comp_id])\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyι_comp_fromOpcycles","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.rightHomologyι S.fromOpcycles) 0","decl":"@[reassoc (attr := simp)]\nlemma rightHomologyι_comp_fromOpcycles :\n    S.rightHomologyι ≫ S.fromOpcycles = 0 :=\n  S.rightHomologyι_descOpcycles_π_eq_zero_of_boundary S.g (𝟙 _) (by rw [comp_id])\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap_comp_descOpcycles","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS S₁ : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\ninst✝¹ : S.HasRightHomology\nφ : Quiver.Hom S₁ S\ninst✝ : S₁.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap φ) (S.descOpcycles k hk)) (S₁.descOpcycles (CategoryTheory.CategoryStruct.comp φ.τ₂ k) ⋯)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesMap_comp_descOpcycles (φ : S₁ ⟶ S) [S₁.HasRightHomology] :\n    opcyclesMap φ ≫ S.descOpcycles k hk =\n      S₁.descOpcycles (φ.τ₂ ≫ k) (by rw [← φ.comm₁₂_assoc, hk, comp_zero]) := by\n  simp only [← cancel_epi (S₁.pOpcycles), p_opcyclesMap_assoc, p_descOpcycles]\n\n"}
{"name":"CategoryTheory.ShortComplex.opcyclesMap_comp_descOpcycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS S₁ : CategoryTheory.ShortComplex C\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\ninst✝¹ : S.HasRightHomology\nφ : Quiver.Hom S₁ S\ninst✝ : S₁.HasRightHomology\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap φ) (CategoryTheory.CategoryStruct.comp (S.descOpcycles k hk) h)) (CategoryTheory.CategoryStruct.comp (S₁.descOpcycles (CategoryTheory.CategoryStruct.comp φ.τ₂ k) ⋯) h)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesMap_comp_descOpcycles (φ : S₁ ⟶ S) [S₁.HasRightHomology] :\n    opcyclesMap φ ≫ S.descOpcycles k hk =\n      S₁.descOpcycles (φ.τ₂ ≫ k) (by rw [← φ.comm₁₂_assoc, hk, comp_zero]) := by\n  simp only [← cancel_epi (S₁.pOpcycles), p_opcyclesMap_assoc, p_descOpcycles]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.opcyclesIso_inv_comp_descOpcycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh✝ : S.RightHomologyData\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\ninst✝ : S.HasRightHomology\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.opcyclesIso.inv (CategoryTheory.CategoryStruct.comp (S.descOpcycles k hk) h)) (CategoryTheory.CategoryStruct.comp (h✝.descQ k hk) h)","decl":"@[reassoc (attr := simp)]\nlemma RightHomologyData.opcyclesIso_inv_comp_descOpcycles :\n    h.opcyclesIso.inv ≫ S.descOpcycles k hk = h.descQ k hk := by\n  simp only [← cancel_epi h.p, p_comp_opcyclesIso_inv_assoc, p_descOpcycles, p_descQ]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.opcyclesIso_inv_comp_descOpcycles","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.opcyclesIso.inv (S.descOpcycles k hk)) (h.descQ k hk)","decl":"@[reassoc (attr := simp)]\nlemma RightHomologyData.opcyclesIso_inv_comp_descOpcycles :\n    h.opcyclesIso.inv ≫ S.descOpcycles k hk = h.descQ k hk := by\n  simp only [← cancel_epi h.p, p_comp_opcyclesIso_inv_assoc, p_descOpcycles, p_descQ]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.opcyclesIso_hom_comp_descQ","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.RightHomologyData\nA : C\nk : Quiver.Hom S.X₂ A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.f k) 0\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.opcyclesIso.hom (h.descQ k hk)) (S.descOpcycles k hk)","decl":"@[simp]\nlemma RightHomologyData.opcyclesIso_hom_comp_descQ :\n    h.opcyclesIso.hom ≫ h.descQ k hk = S.descOpcycles k hk := by\n  rw [← h.opcyclesIso_inv_comp_descOpcycles, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.HasRightHomology.hasCokernel","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasRightHomology\n⊢ CategoryTheory.Limits.HasCokernel S.f","decl":"lemma hasCokernel [S.HasRightHomology] : HasCokernel S.f :=\n  ⟨⟨⟨_, S.rightHomologyData.hp⟩⟩⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.HasRightHomology.hasKernel","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : S.HasRightHomology\ninst✝ : CategoryTheory.Limits.HasCokernel S.f\n⊢ CategoryTheory.Limits.HasKernel (CategoryTheory.Limits.cokernel.desc S.f S.g ⋯)","decl":"lemma hasKernel [S.HasRightHomology] [HasCokernel S.f] :\n    HasKernel (cokernel.desc S.f S.g S.zero) := by\n  let h := S.rightHomologyData\n  haveI : HasLimit (parallelPair h.g' 0) := ⟨⟨⟨_, h.hι'⟩⟩⟩\n  let e : parallelPair (cokernel.desc S.f S.g S.zero) 0 ≅ parallelPair h.g' 0 :=\n    parallelPair.ext (IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) h.hp)\n      (Iso.refl _) (coequalizer.hom_ext (by simp)) (by simp)\n  exact hasLimitOfIso e.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_opcyclesMap'_of_isIso_of_epi","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₂✝ : CategoryTheory.IsIso φ.τ₂\nh₁✝ : CategoryTheory.Epi φ.τ₁\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.opcyclesMap' φ h₁ h₂)","decl":"lemma isIso_opcyclesMap'_of_isIso_of_epi (φ : S₁ ⟶ S₂) (h₂ : IsIso φ.τ₂) (h₁ : Epi φ.τ₁)\n    (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) :\n    IsIso (opcyclesMap' φ h₁ h₂) := by\n  refine ⟨h₂.descQ (inv φ.τ₂ ≫ h₁.p) ?_, ?_, ?_⟩\n  · simp only [← cancel_epi φ.τ₁, comp_zero, φ.comm₁₂_assoc, IsIso.hom_inv_id_assoc, h₁.wp]\n  · simp only [← cancel_epi h₁.p, p_opcyclesMap'_assoc, h₂.p_descQ,\n      IsIso.hom_inv_id_assoc, comp_id]\n  · simp only [← cancel_epi h₂.p, h₂.p_descQ_assoc, assoc, p_opcyclesMap',\n      IsIso.inv_hom_id_assoc, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_opcyclesMap_of_isIso_of_epi'","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₂ : CategoryTheory.IsIso φ.τ₂\nh₁ : CategoryTheory.Epi φ.τ₁\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.opcyclesMap φ)","decl":"lemma isIso_opcyclesMap_of_isIso_of_epi' (φ : S₁ ⟶ S₂) (h₂ : IsIso φ.τ₂) (h₁ : Epi φ.τ₁)\n    [S₁.HasRightHomology] [S₂.HasRightHomology] :\n    IsIso (opcyclesMap φ) :=\n  isIso_opcyclesMap'_of_isIso_of_epi φ h₂ h₁ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_opcyclesMap_of_isIso_of_epi","module":"Mathlib.Algebra.Homology.ShortComplex.RightHomology","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝³ : CategoryTheory.IsIso φ.τ₂\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : S₁.HasRightHomology\ninst✝ : S₂.HasRightHomology\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.opcyclesMap φ)","decl":"instance isIso_opcyclesMap_of_isIso_of_epi (φ : S₁ ⟶ S₂) [IsIso φ.τ₂] [Epi φ.τ₁]\n    [S₁.HasRightHomology] [S₂.HasRightHomology] :\n    IsIso (opcyclesMap φ) :=\n  isIso_opcyclesMap_of_isIso_of_epi' φ inferInstance inferInstance\n\n"}
