{"name":"schnirelmannDensity_nonneg","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\n⊢ LE.le 0 (schnirelmannDensity A)","decl":"lemma schnirelmannDensity_nonneg : 0 ≤ schnirelmannDensity A :=\n  Real.iInf_nonneg (fun _ => by positivity)\n\n"}
{"name":"schnirelmannDensity_le_div","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\nn : Nat\nhn : Ne n 0\n⊢ LE.le (schnirelmannDensity A) (HDiv.hDiv ↑(Finset.filter (fun a => Membership.mem A a) (Finset.Ioc 0 n)).card ↑n)","decl":"lemma schnirelmannDensity_le_div {n : ℕ} (hn : n ≠ 0) :\n    schnirelmannDensity A ≤ #{a ∈ Ioc 0 n | a ∈ A} / n :=\n  ciInf_le ⟨0, fun _ ⟨_, hx⟩ => hx ▸ by positivity⟩ (⟨n, hn.bot_lt⟩ : {n : ℕ // 0 < n})\n\n"}
{"name":"schnirelmannDensity_mul_le_card_filter","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\nn : Nat\n⊢ LE.le (HMul.hMul (schnirelmannDensity A) ↑n) ↑(Finset.filter (fun a => Membership.mem A a) (Finset.Ioc 0 n)).card","decl":"/--\nFor any natural `n`, the Schnirelmann density multiplied by `n` is bounded by `|A ∩ {1, ..., n}|`.\nNote this property fails for the natural density.\n-/\nlemma schnirelmannDensity_mul_le_card_filter {n : ℕ} :\n    schnirelmannDensity A * n ≤ #{a ∈ Ioc 0 n | a ∈ A} := by\n  rcases eq_or_ne n 0 with rfl | hn\n  · simp\n  exact (le_div_iff₀ (by positivity)).1 (schnirelmannDensity_le_div hn)\n\n"}
{"name":"schnirelmannDensity_le_of_le","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\nx : Real\nn : Nat\nhn : Ne n 0\nhx : LE.le (HDiv.hDiv ↑(Finset.filter (fun a => Membership.mem A a) (Finset.Ioc 0 n)).card ↑n) x\n⊢ LE.le (schnirelmannDensity A) x","decl":"/--\nTo show the Schnirelmann density is upper bounded by `x`, it suffices to show\n`|A ∩ {1, ..., n}| / n ≤ x`, for any chosen positive value of `n`.\n\nWe provide `n` explicitly here to make this lemma more easily usable in `apply` or `refine`.\nThis lemma is analogous to `ciInf_le_of_le`.\n-/\nlemma schnirelmannDensity_le_of_le {x : ℝ} (n : ℕ) (hn : n ≠ 0)\n    (hx : #{a ∈ Ioc 0 n | a ∈ A} / n ≤ x) : schnirelmannDensity A ≤ x :=\n  (schnirelmannDensity_le_div hn).trans hx\n\n"}
{"name":"schnirelmannDensity_le_one","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\n⊢ LE.le (schnirelmannDensity A) 1","decl":"lemma schnirelmannDensity_le_one : schnirelmannDensity A ≤ 1 :=\n  schnirelmannDensity_le_of_le 1 one_ne_zero <|\n    by rw [Nat.cast_one, div_one, Nat.cast_le_one]; exact card_filter_le _ _\n\n"}
{"name":"schnirelmannDensity_le_of_not_mem","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\nk : Nat\nhk : Not (Membership.mem A k)\n⊢ LE.le (schnirelmannDensity A) (HSub.hSub 1 (Inv.inv ↑k))","decl":"/--\nIf `k` is omitted from the set, its Schnirelmann density is upper bounded by `1 - k⁻¹`.\n-/\nlemma schnirelmannDensity_le_of_not_mem {k : ℕ} (hk : k ∉ A) :\n    schnirelmannDensity A ≤ 1 - (k⁻¹ : ℝ) := by\n  rcases k.eq_zero_or_pos with rfl | hk'\n  · simpa using schnirelmannDensity_le_one\n  apply schnirelmannDensity_le_of_le k hk'.ne'\n  rw [← one_div, one_sub_div (Nat.cast_pos.2 hk').ne']\n  gcongr\n  rw [← Nat.cast_pred hk', Nat.cast_le]\n  suffices {a ∈ Ioc 0 k | a ∈ A} ⊆ Ioo 0 k from (card_le_card this).trans_eq (by simp)\n  rw [← Ioo_insert_right hk', filter_insert, if_neg hk]\n  exact filter_subset _ _\n\n"}
{"name":"schnirelmannDensity_eq_zero_of_one_not_mem","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\nh : Not (Membership.mem A 1)\n⊢ Eq (schnirelmannDensity A) 0","decl":"/-- The Schnirelmann density of a set not containing `1` is `0`. -/\nlemma schnirelmannDensity_eq_zero_of_one_not_mem (h : 1 ∉ A) : schnirelmannDensity A = 0 :=\n  ((schnirelmannDensity_le_of_not_mem h).trans (by simp)).antisymm schnirelmannDensity_nonneg\n\n"}
{"name":"schnirelmannDensity_le_of_subset","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝¹ : DecidablePred fun x => Membership.mem A x\nB : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem B x\nh : HasSubset.Subset A B\n⊢ LE.le (schnirelmannDensity A) (schnirelmannDensity B)","decl":"/-- The Schnirelmann density is increasing with the set. -/\nlemma schnirelmannDensity_le_of_subset {B : Set ℕ} [DecidablePred (· ∈ B)] (h : A ⊆ B) :\n    schnirelmannDensity A ≤ schnirelmannDensity B :=\n  ciInf_mono ⟨0, fun _ ⟨_, hx⟩ ↦ hx ▸ by positivity⟩ fun _ ↦ by\n    gcongr; exact h\n\n"}
{"name":"schnirelmannDensity_eq_one_iff","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\n⊢ Iff (Eq (schnirelmannDensity A) 1) (HasSubset.Subset (HasCompl.compl (Singleton.singleton 0)) A)","decl":"/-- The Schnirelmann density of `A` is `1` if and only if `A` contains all the positive naturals. -/\nlemma schnirelmannDensity_eq_one_iff : schnirelmannDensity A = 1 ↔ {0}ᶜ ⊆ A := by\n  rw [le_antisymm_iff, and_iff_right schnirelmannDensity_le_one]\n  constructor\n  · rw [← not_imp_not, not_le]\n    simp only [Set.not_subset, forall_exists_index, true_and, and_imp, Set.mem_singleton_iff]\n    intro x hx hx'\n    apply (schnirelmannDensity_le_of_not_mem hx').trans_lt\n    simpa only [one_div, sub_lt_self_iff, inv_pos, Nat.cast_pos, pos_iff_ne_zero] using hx\n  · intro h\n    refine le_ciInf fun ⟨n, hn⟩ => ?_\n    rw [one_le_div (Nat.cast_pos.2 hn), Nat.cast_le, filter_true_of_mem, Nat.card_Ioc, Nat.sub_zero]\n    rintro x hx\n    exact h (mem_Ioc.1 hx).1.ne'\n\n"}
{"name":"schnirelmannDensity_eq_one_iff_of_zero_mem","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\nhA : Membership.mem A 0\n⊢ Iff (Eq (schnirelmannDensity A) 1) (Eq A Set.univ)","decl":"/-- The Schnirelmann density of `A` containing `0` is `1` if and only if `A` is the naturals. -/\nlemma schnirelmannDensity_eq_one_iff_of_zero_mem (hA : 0 ∈ A) :\n    schnirelmannDensity A = 1 ↔ A = Set.univ := by\n  rw [schnirelmannDensity_eq_one_iff]\n  constructor\n  · refine fun h => Set.eq_univ_of_forall fun x => ?_\n    rcases eq_or_ne x 0 with rfl | hx\n    · exact hA\n    · exact h hx\n  · rintro rfl\n    exact Set.subset_univ {0}ᶜ\n\n"}
{"name":"le_schnirelmannDensity_iff","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\nx : Real\n⊢ Iff (LE.le x (schnirelmannDensity A)) (∀ (n : Nat), LT.lt 0 n → LE.le x (HDiv.hDiv ↑(Finset.filter (fun a => Membership.mem A a) (Finset.Ioc 0 n)).card ↑n))","decl":"lemma le_schnirelmannDensity_iff {x : ℝ} :\n    x ≤ schnirelmannDensity A ↔ ∀ n : ℕ, 0 < n → x ≤ #{a ∈ Ioc 0 n | a ∈ A} / n :=\n  (le_ciInf_iff ⟨0, fun _ ⟨_, hx⟩ => hx ▸ by positivity⟩).trans Subtype.forall\n\n"}
{"name":"schnirelmannDensity_lt_iff","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\nx : Real\n⊢ Iff (LT.lt (schnirelmannDensity A) x) (Exists fun n => And (LT.lt 0 n) (LT.lt (HDiv.hDiv ↑(Finset.filter (fun a => Membership.mem A a) (Finset.Ioc 0 n)).card ↑n) x))","decl":"lemma schnirelmannDensity_lt_iff {x : ℝ} :\n    schnirelmannDensity A < x ↔ ∃ n : ℕ, 0 < n ∧ #{a ∈ Ioc 0 n | a ∈ A} / n < x := by\n  rw [← not_le, le_schnirelmannDensity_iff]; simp\n\n"}
{"name":"schnirelmannDensity_le_iff_forall","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\nx : Real\n⊢ Iff (LE.le (schnirelmannDensity A) x) (∀ (ε : Real), LT.lt 0 ε → Exists fun n => And (LT.lt 0 n) (LT.lt (HDiv.hDiv ↑(Finset.filter (fun a => Membership.mem A a) (Finset.Ioc 0 n)).card ↑n) (HAdd.hAdd x ε)))","decl":"lemma schnirelmannDensity_le_iff_forall {x : ℝ} :\n    schnirelmannDensity A ≤ x ↔\n      ∀ ε : ℝ, 0 < ε → ∃ n : ℕ, 0 < n ∧ #{a ∈ Ioc 0 n | a ∈ A} / n < x + ε := by\n  rw [le_iff_forall_pos_lt_add]\n  simp only [schnirelmannDensity_lt_iff]\n\n"}
{"name":"schnirelmannDensity_congr'","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝¹ : DecidablePred fun x => Membership.mem A x\nB : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem B x\nh : ∀ (n : Nat), GT.gt n 0 → Iff (Membership.mem A n) (Membership.mem B n)\n⊢ Eq (schnirelmannDensity A) (schnirelmannDensity B)","decl":"lemma schnirelmannDensity_congr' {B : Set ℕ} [DecidablePred (· ∈ B)]\n    (h : ∀ n > 0, n ∈ A ↔ n ∈ B) : schnirelmannDensity A = schnirelmannDensity B := by\n  rw [schnirelmannDensity, schnirelmannDensity]; congr; ext ⟨n, hn⟩; congr 3; ext x; aesop\n\n"}
{"name":"schnirelmannDensity_insert_zero","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝¹ : DecidablePred fun x => Membership.mem A x\ninst✝ : DecidablePred fun x => Membership.mem (Insert.insert 0 A) x\n⊢ Eq (schnirelmannDensity (Insert.insert 0 A)) (schnirelmannDensity A)","decl":"/-- The Schnirelmann density is unaffected by adding `0`. -/\n@[simp] lemma schnirelmannDensity_insert_zero [DecidablePred (· ∈ insert 0 A)] :\n    schnirelmannDensity (insert 0 A) = schnirelmannDensity A :=\n  schnirelmannDensity_congr' (by aesop)\n\n"}
{"name":"schnirelmannDensity_diff_singleton_zero","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝¹ : DecidablePred fun x => Membership.mem A x\ninst✝ : DecidablePred fun x => Membership.mem (SDiff.sdiff A (Singleton.singleton 0)) x\n⊢ Eq (schnirelmannDensity (SDiff.sdiff A (Singleton.singleton 0))) (schnirelmannDensity A)","decl":"/-- The Schnirelmann density is unaffected by removing `0`. -/\nlemma schnirelmannDensity_diff_singleton_zero [DecidablePred (· ∈ A \\ {0})] :\n    schnirelmannDensity (A \\ {0}) = schnirelmannDensity A :=\n  schnirelmannDensity_congr' (by aesop)\n\n"}
{"name":"schnirelmannDensity_congr","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝¹ : DecidablePred fun x => Membership.mem A x\nB : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem B x\nh : Eq A B\n⊢ Eq (schnirelmannDensity A) (schnirelmannDensity B)","decl":"lemma schnirelmannDensity_congr {B : Set ℕ} [DecidablePred (· ∈ B)] (h : A = B) :\n    schnirelmannDensity A = schnirelmannDensity B :=\n  schnirelmannDensity_congr' (by aesop)\n\n"}
{"name":"exists_of_schnirelmannDensity_eq_zero","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\nε : Real\nhε : LT.lt 0 ε\nhA : Eq (schnirelmannDensity A) 0\n⊢ Exists fun n => And (LT.lt 0 n) (LT.lt (HDiv.hDiv ↑(Finset.filter (fun a => Membership.mem A a) (Finset.Ioc 0 n)).card ↑n) ε)","decl":"/--\nIf the Schnirelmann density is `0`, there is a positive natural for which\n`|A ∩ {1, ..., n}| / n < ε`, for any positive `ε`.\nNote this cannot be improved to `∃ᶠ n : ℕ in atTop`, as can be seen by `A = {1}ᶜ`.\n-/\nlemma exists_of_schnirelmannDensity_eq_zero {ε : ℝ} (hε : 0 < ε) (hA : schnirelmannDensity A = 0) :\n    ∃ n, 0 < n ∧ #{a ∈ Ioc 0 n | a ∈ A} / n < ε := by\n  by_contra! h\n  rw [← le_schnirelmannDensity_iff] at h\n  linarith\n\n"}
{"name":"schnirelmannDensity_empty","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"⊢ Eq (schnirelmannDensity EmptyCollection.emptyCollection) 0","decl":"@[simp] lemma schnirelmannDensity_empty : schnirelmannDensity ∅ = 0 :=\n  schnirelmannDensity_eq_zero_of_one_not_mem (by simp)\n\n"}
{"name":"schnirelmannDensity_finset","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Finset Nat\n⊢ Eq (schnirelmannDensity ↑A) 0","decl":"/-- The Schnirelmann density of any finset is `0`. -/\nlemma schnirelmannDensity_finset (A : Finset ℕ) : schnirelmannDensity A = 0 := by\n  refine le_antisymm ?_ schnirelmannDensity_nonneg\n  simp only [schnirelmannDensity_le_iff_forall, zero_add]\n  intro ε hε\n  wlog hε₁ : ε ≤ 1 generalizing ε\n  · obtain ⟨n, hn, hn'⟩ := this 1 zero_lt_one le_rfl\n    exact ⟨n, hn, hn'.trans_le (le_of_not_le hε₁)⟩\n  let n : ℕ := ⌊#A / ε⌋₊ + 1\n  have hn : 0 < n := Nat.succ_pos _\n  use n, hn\n  rw [div_lt_iff₀ (Nat.cast_pos.2 hn), ← div_lt_iff₀' hε, Nat.cast_add_one]\n  exact (Nat.lt_floor_add_one _).trans_le' <| by gcongr; simp [subset_iff]\n\n"}
{"name":"schnirelmannDensity_finite","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"A : Set Nat\ninst✝ : DecidablePred fun x => Membership.mem A x\nhA : A.Finite\n⊢ Eq (schnirelmannDensity A) 0","decl":"/-- The Schnirelmann density of any finite set is `0`. -/\nlemma schnirelmannDensity_finite {A : Set ℕ} [DecidablePred (· ∈ A)] (hA : A.Finite) :\n    schnirelmannDensity A = 0 := by simpa using schnirelmannDensity_finset hA.toFinset\n\n"}
{"name":"schnirelmannDensity_univ","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"⊢ Eq (schnirelmannDensity Set.univ) 1","decl":"@[simp] lemma schnirelmannDensity_univ : schnirelmannDensity Set.univ = 1 :=\n  (schnirelmannDensity_eq_one_iff_of_zero_mem (by simp)).2 (by simp)\n\n"}
{"name":"schnirelmannDensity_setOf_even","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"⊢ Eq (schnirelmannDensity (setOf Even)) 0","decl":"lemma schnirelmannDensity_setOf_even : schnirelmannDensity (setOf Even) = 0 :=\n  schnirelmannDensity_eq_zero_of_one_not_mem <| by simp\n\n"}
{"name":"schnirelmannDensity_setOf_prime","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"⊢ Eq (schnirelmannDensity (setOf Nat.Prime)) 0","decl":"lemma schnirelmannDensity_setOf_prime : schnirelmannDensity (setOf Nat.Prime) = 0 :=\n  schnirelmannDensity_eq_zero_of_one_not_mem <| by simp [Nat.not_prime_one]\n\n"}
{"name":"schnirelmannDensity_setOf_mod_eq_one","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"m : Nat\nhm : Ne m 1\n⊢ Eq (schnirelmannDensity (setOf fun n => Eq (HMod.hMod n m) 1)) (Inv.inv ↑m)","decl":"/--\nThe Schnirelmann density of the set of naturals which are `1 mod m` is `m⁻¹`, for any `m ≠ 1`.\n\nNote that if `m = 1`, this set is empty.\n-/\nlemma schnirelmannDensity_setOf_mod_eq_one {m : ℕ} (hm : m ≠ 1) :\n    schnirelmannDensity {n | n % m = 1} = (m⁻¹ : ℝ) := by\n  rcases m.eq_zero_or_pos with rfl | hm'\n  · simp only [Nat.cast_zero, inv_zero]\n    refine schnirelmannDensity_finite ?_\n    simp\n  apply le_antisymm (schnirelmannDensity_le_of_le m hm'.ne' _) _\n  · rw [← one_div, ← @Nat.cast_one ℝ]\n    gcongr\n    simp only [Set.mem_setOf_eq, card_le_one_iff_subset_singleton, subset_iff,\n      mem_filter, mem_Ioc, mem_singleton, and_imp]\n    use 1\n    intro x _ hxm h\n    rcases eq_or_lt_of_le hxm with rfl | hxm'\n    · simp at h\n    rwa [Nat.mod_eq_of_lt hxm'] at h\n  rw [le_schnirelmannDensity_iff]\n  intro n hn\n  simp only [Set.mem_setOf_eq]\n  have : (Icc 0 ((n - 1) / m)).image (· * m + 1) ⊆ {x ∈ Ioc 0 n | x % m = 1} := by\n    simp only [subset_iff, mem_image, forall_exists_index, mem_filter, mem_Ioc, mem_Icc, and_imp]\n    rintro _ y _ hy' rfl\n    have hm : 2 ≤ m := hm.lt_of_le' hm'\n    simp only [Nat.mul_add_mod', Nat.mod_eq_of_lt hm, add_pos_iff, or_true, and_true, true_and,\n      ← Nat.le_sub_iff_add_le hn, zero_lt_one]\n    exact Nat.mul_le_of_le_div _ _ _ hy'\n  rw [le_div_iff₀ (Nat.cast_pos.2 hn), mul_comm, ← div_eq_mul_inv]\n  apply (Nat.cast_le.2 (card_le_card this)).trans'\n  rw [card_image_of_injective, Nat.card_Icc, Nat.sub_zero, div_le_iff₀ (Nat.cast_pos.2 hm'),\n    ← Nat.cast_mul, Nat.cast_le, add_one_mul (α := ℕ)]\n  · have := @Nat.lt_div_mul_add n.pred m hm'\n    rwa [← Nat.succ_le, Nat.succ_pred hn.ne'] at this\n  intro a b\n  simp [hm'.ne']\n\n"}
{"name":"schnirelmannDensity_setOf_modeq_one","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"m : Nat\n⊢ Eq (schnirelmannDensity (setOf fun n => m.ModEq n 1)) (Inv.inv ↑m)","decl":"lemma schnirelmannDensity_setOf_modeq_one {m : ℕ} :\n    schnirelmannDensity {n | n ≡ 1 [MOD m]} = (m⁻¹ : ℝ) := by\n  rcases eq_or_ne m 1 with rfl | hm\n  · simp [Nat.modEq_one]\n  rw [← schnirelmannDensity_setOf_mod_eq_one hm]\n  apply schnirelmannDensity_congr\n  ext n\n  simp only [Set.mem_setOf_eq, Nat.ModEq, Nat.one_mod_eq_one.mpr hm]\n\n"}
{"name":"schnirelmannDensity_setOf_Odd","module":"Mathlib.Combinatorics.Schnirelmann","initialProofState":"⊢ Eq (schnirelmannDensity (setOf Odd)) (Inv.inv 2)","decl":"lemma schnirelmannDensity_setOf_Odd : schnirelmannDensity (setOf Odd) = 2⁻¹ := by\n  have h : setOf Odd = {n | n % 2 = 1} := Set.ext fun _ => Nat.odd_iff\n  simp only [h]\n  rw [schnirelmannDensity_setOf_mod_eq_one (by norm_num1), Nat.cast_two]\n"}
