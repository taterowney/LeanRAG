{"name":"List.permutationsAux2_fst","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α\nts : List α\nr : List β\nys : List α\nf : List α → β\n⊢ Eq (List.permutationsAux2 t ts r ys f).1 (HAppend.hAppend ys ts)","decl":"theorem permutationsAux2_fst (t : α) (ts : List α) (r : List β) :\n    ∀ (ys : List α) (f : List α → β), (permutationsAux2 t ts r ys f).1 = ys ++ ts\n  | [], _ => rfl\n  | y :: ys, f => by simp [permutationsAux2, permutationsAux2_fst t _ _ ys]\n\n"}
{"name":"List.permutationsAux2_snd_nil","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α\nts : List α\nr : List β\nf : List α → β\n⊢ Eq (List.permutationsAux2 t ts r List.nil f).2 r","decl":"@[simp]\ntheorem permutationsAux2_snd_nil (t : α) (ts : List α) (r : List β) (f : List α → β) :\n    (permutationsAux2 t ts r [] f).2 = r :=\n  rfl\n\n"}
{"name":"List.permutationsAux2_snd_cons","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α\nts : List α\nr : List β\ny : α\nys : List α\nf : List α → β\n⊢ Eq (List.permutationsAux2 t ts r (List.cons y ys) f).2 (List.cons (f (HAppend.hAppend (List.cons t (List.cons y ys)) ts)) (List.permutationsAux2 t ts r ys fun x => f (List.cons y x)).2)","decl":"@[simp]\ntheorem permutationsAux2_snd_cons (t : α) (ts : List α) (r : List β) (y : α) (ys : List α)\n    (f : List α → β) :\n    (permutationsAux2 t ts r (y :: ys) f).2 =\n      f (t :: y :: ys ++ ts) :: (permutationsAux2 t ts r ys fun x : List α => f (y :: x)).2 := by\n  simp [permutationsAux2, permutationsAux2_fst t _ _ ys]\n\n"}
{"name":"List.permutationsAux2_append","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α\nts : List α\nr : List β\nys : List α\nf : List α → β\n⊢ Eq (HAppend.hAppend (List.permutationsAux2 t ts List.nil ys f).2 r) (List.permutationsAux2 t ts r ys f).2","decl":"/-- The `r` argument to `permutationsAux2` is the same as appending. -/\ntheorem permutationsAux2_append (t : α) (ts : List α) (r : List β) (ys : List α) (f : List α → β) :\n    (permutationsAux2 t ts nil ys f).2 ++ r = (permutationsAux2 t ts r ys f).2 := by\n  induction ys generalizing f <;> simp [*]\n\n"}
{"name":"List.permutationsAux2_comp_append","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α\nts ys : List α\nr : List β\nf : List α → β\n⊢ Eq (List.permutationsAux2 t List.nil r ys fun x => f (HAppend.hAppend x ts)).2 (List.permutationsAux2 t ts r ys f).2","decl":"/-- The `ts` argument to `permutationsAux2` can be folded into the `f` argument. -/\ntheorem permutationsAux2_comp_append {t : α} {ts ys : List α} {r : List β} (f : List α → β) :\n    ((permutationsAux2 t [] r ys) fun x => f (x ++ ts)).2 = (permutationsAux2 t ts r ys f).2 := by\n  induction' ys with ys_hd _ ys_ih generalizing f\n  · simp\n  · simp [ys_ih fun xs => f (ys_hd :: xs)]\n\n"}
{"name":"List.map_permutationsAux2'","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nβ : Type u_2\nα' : Type u_3\nβ' : Type u_4\ng : α → α'\ng' : β → β'\nt : α\nts ys : List α\nr : List β\nf : List α → β\nf' : List α' → β'\nH : ∀ (a : List α), Eq (g' (f a)) (f' (List.map g a))\n⊢ Eq (List.map g' (List.permutationsAux2 t ts r ys f).2) (List.permutationsAux2 (g t) (List.map g ts) (List.map g' r) (List.map g ys) f').2","decl":"theorem map_permutationsAux2' {α' β'} (g : α → α') (g' : β → β') (t : α) (ts ys : List α)\n    (r : List β) (f : List α → β) (f' : List α' → β') (H : ∀ a, g' (f a) = f' (map g a)) :\n    map g' (permutationsAux2 t ts r ys f).2 =\n      (permutationsAux2 (g t) (map g ts) (map g' r) (map g ys) f').2 := by\n  induction' ys with ys_hd _ ys_ih generalizing f f'\n  · simp\n  · simp only [map, permutationsAux2_snd_cons, cons_append, cons.injEq]\n    rw [ys_ih]\n    · refine ⟨?_, rfl⟩\n      simp only [← map_cons, ← map_append]; apply H\n    · intro a; apply H\n\n"}
{"name":"List.map_permutationsAux2","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α\nts ys : List α\nf : List α → β\n⊢ Eq (List.map f (List.permutationsAux2 t ts List.nil ys id).2) (List.permutationsAux2 t ts List.nil ys f).2","decl":"/-- The `f` argument to `permutationsAux2` when `r = []` can be eliminated. -/\ntheorem map_permutationsAux2 (t : α) (ts : List α) (ys : List α) (f : List α → β) :\n    (permutationsAux2 t ts [] ys id).2.map f = (permutationsAux2 t ts [] ys f).2 := by\n  rw [map_permutationsAux2' id, map_id, map_id]\n  · rfl\n  simp\n\n"}
{"name":"List.permutationsAux2_snd_eq","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α\nts : List α\nr : List β\nys : List α\nf : List α → β\n⊢ Eq (List.permutationsAux2 t ts r ys f).2 (HAppend.hAppend (List.map (fun x => f (HAppend.hAppend x ts)) (List.permutationsAux2 t List.nil List.nil ys id).2) r)","decl":"/-- An expository lemma to show how all of `ts`, `r`, and `f` can be eliminated from\n`permutationsAux2`.\n\n`(permutationsAux2 t [] [] ys id).2`, which appears on the RHS, is a list whose elements are\nproduced by inserting `t` into every non-terminal position of `ys` in order. As an example:\n```lean\n#eval permutationsAux2 1 [] [] [2, 3, 4] id\n-- [[1, 2, 3, 4], [2, 1, 3, 4], [2, 3, 1, 4]]\n```\n-/\ntheorem permutationsAux2_snd_eq (t : α) (ts : List α) (r : List β) (ys : List α) (f : List α → β) :\n    (permutationsAux2 t ts r ys f).2 =\n      ((permutationsAux2 t [] [] ys id).2.map fun x => f (x ++ ts)) ++ r := by\n  rw [← permutationsAux2_append, map_permutationsAux2, permutationsAux2_comp_append]\n\n"}
{"name":"List.map_map_permutationsAux2","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nα' : Type u_3\ng : α → α'\nt : α\nts ys : List α\n⊢ Eq (List.map (List.map g) (List.permutationsAux2 t ts List.nil ys id).2) (List.permutationsAux2 (g t) (List.map g ts) List.nil (List.map g ys) id).2","decl":"theorem map_map_permutationsAux2 {α'} (g : α → α') (t : α) (ts ys : List α) :\n    map (map g) (permutationsAux2 t ts [] ys id).2 =\n      (permutationsAux2 (g t) (map g ts) [] (map g ys) id).2 :=\n  map_permutationsAux2' _ _ _ _ _ _ _ _ fun _ => rfl\n\n"}
{"name":"List.map_map_permutations'Aux","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nt : α\nts : List α\n⊢ Eq (List.map (List.map f) (List.permutations'Aux t ts)) (List.permutations'Aux (f t) (List.map f ts))","decl":"theorem map_map_permutations'Aux (f : α → β) (t : α) (ts : List α) :\n    map (map f) (permutations'Aux t ts) = permutations'Aux (f t) (map f ts) := by\n  induction' ts with a ts ih\n  · rfl\n  · simp only [permutations'Aux, map_cons, map_map, ← ih, cons.injEq, true_and, Function.comp_def]\n\n"}
{"name":"List.permutations'Aux_eq_permutationsAux2","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nt : α\nts : List α\n⊢ Eq (List.permutations'Aux t ts) (List.permutationsAux2 t List.nil (List.cons (HAppend.hAppend ts (List.cons t List.nil)) List.nil) ts id).2","decl":"theorem permutations'Aux_eq_permutationsAux2 (t : α) (ts : List α) :\n    permutations'Aux t ts = (permutationsAux2 t [] [ts ++ [t]] ts id).2 := by\n  induction' ts with a ts ih; · rfl\n  simp only [permutations'Aux, ih, cons_append, permutationsAux2_snd_cons, append_nil, id_eq,\n    cons.injEq, true_and]\n  simp (config := { singlePass := true }) only [← permutationsAux2_append]\n  simp [map_permutationsAux2]\n\n"}
{"name":"List.mem_permutationsAux2","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nt : α\nts ys l l' : List α\n⊢ Iff (Membership.mem (List.permutationsAux2 t ts List.nil ys fun x => HAppend.hAppend l x).2 l') (Exists fun l₁ => Exists fun l₂ => And (Ne l₂ List.nil) (And (Eq ys (HAppend.hAppend l₁ l₂)) (Eq l' (HAppend.hAppend (HAppend.hAppend (HAppend.hAppend l l₁) (List.cons t l₂)) ts))))","decl":"theorem mem_permutationsAux2 {t : α} {ts : List α} {ys : List α} {l l' : List α} :\n    l' ∈ (permutationsAux2 t ts [] ys (l ++ ·)).2 ↔\n      ∃ l₁ l₂, l₂ ≠ [] ∧ ys = l₁ ++ l₂ ∧ l' = l ++ l₁ ++ t :: l₂ ++ ts := by\n  induction' ys with y ys ih generalizing l\n  · simp +contextual\n  rw [permutationsAux2_snd_cons,\n    show (fun x : List α => l ++ y :: x) = (l ++ [y] ++ ·) by funext _; simp, mem_cons, ih]\n  constructor\n  · rintro (rfl | ⟨l₁, l₂, l0, rfl, rfl⟩)\n    · exact ⟨[], y :: ys, by simp⟩\n    · exact ⟨y :: l₁, l₂, l0, by simp⟩\n  · rintro ⟨_ | ⟨y', l₁⟩, l₂, l0, ye, rfl⟩\n    · simp [ye]\n    · simp only [cons_append] at ye\n      rcases ye with ⟨rfl, rfl⟩\n      exact Or.inr ⟨l₁, l₂, l0, by simp⟩\n\n"}
{"name":"List.mem_permutationsAux2'","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nt : α\nts ys l : List α\n⊢ Iff (Membership.mem (List.permutationsAux2 t ts List.nil ys id).2 l) (Exists fun l₁ => Exists fun l₂ => And (Ne l₂ List.nil) (And (Eq ys (HAppend.hAppend l₁ l₂)) (Eq l (HAppend.hAppend (HAppend.hAppend l₁ (List.cons t l₂)) ts))))","decl":"theorem mem_permutationsAux2' {t : α} {ts : List α} {ys : List α} {l : List α} :\n    l ∈ (permutationsAux2 t ts [] ys id).2 ↔\n      ∃ l₁ l₂, l₂ ≠ [] ∧ ys = l₁ ++ l₂ ∧ l = l₁ ++ t :: l₂ ++ ts := by\n  rw [show @id (List α) = ([] ++ ·) by funext _; rfl]; apply mem_permutationsAux2\n\n"}
{"name":"List.length_permutationsAux2","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α\nts ys : List α\nf : List α → β\n⊢ Eq (List.permutationsAux2 t ts List.nil ys f).2.length ys.length","decl":"theorem length_permutationsAux2 (t : α) (ts : List α) (ys : List α) (f : List α → β) :\n    length (permutationsAux2 t ts [] ys f).2 = length ys := by\n  induction ys generalizing f <;> simp [*]\n\n"}
{"name":"List.foldr_permutationsAux2","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nt : α\nts : List α\nr L : List (List α)\n⊢ Eq (List.foldr (fun y r => (List.permutationsAux2 t ts r y id).2) r L) (HAppend.hAppend (L.flatMap fun y => (List.permutationsAux2 t ts List.nil y id).2) r)","decl":"theorem foldr_permutationsAux2 (t : α) (ts : List α) (r L : List (List α)) :\n    foldr (fun y r => (permutationsAux2 t ts r y id).2) r L =\n      (L.flatMap fun y => (permutationsAux2 t ts [] y id).2) ++ r := by\n  induction' L with l L ih\n  · rfl\n  · simp_rw [foldr_cons, ih, flatMap_cons, append_assoc, permutationsAux2_append]\n\n"}
{"name":"List.mem_foldr_permutationsAux2","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nt : α\nts : List α\nr L : List (List α)\nl' : List α\n⊢ Iff (Membership.mem (List.foldr (fun y r => (List.permutationsAux2 t ts r y id).2) r L) l') (Or (Membership.mem r l') (Exists fun l₁ => Exists fun l₂ => And (Membership.mem L (HAppend.hAppend l₁ l₂)) (And (Ne l₂ List.nil) (Eq l' (HAppend.hAppend (HAppend.hAppend l₁ (List.cons t l₂)) ts)))))","decl":"theorem mem_foldr_permutationsAux2 {t : α} {ts : List α} {r L : List (List α)} {l' : List α} :\n    l' ∈ foldr (fun y r => (permutationsAux2 t ts r y id).2) r L ↔\n      l' ∈ r ∨ ∃ l₁ l₂, l₁ ++ l₂ ∈ L ∧ l₂ ≠ [] ∧ l' = l₁ ++ t :: l₂ ++ ts := by\n  have :\n    (∃ a : List α,\n        a ∈ L ∧ ∃ l₁ l₂ : List α, ¬l₂ = nil ∧ a = l₁ ++ l₂ ∧ l' = l₁ ++ t :: (l₂ ++ ts)) ↔\n      ∃ l₁ l₂ : List α, ¬l₂ = nil ∧ l₁ ++ l₂ ∈ L ∧ l' = l₁ ++ t :: (l₂ ++ ts) :=\n    ⟨fun ⟨_, aL, l₁, l₂, l0, e, h⟩ => ⟨l₁, l₂, l0, e ▸ aL, h⟩, fun ⟨l₁, l₂, l0, aL, h⟩ =>\n      ⟨_, aL, l₁, l₂, l0, rfl, h⟩⟩\n  rw [foldr_permutationsAux2]\n  simp only [mem_permutationsAux2', ← this, or_comm, and_left_comm, mem_append, mem_flatMap,\n    append_assoc, cons_append, exists_prop]\n\n"}
{"name":"List.length_foldr_permutationsAux2","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nt : α\nts : List α\nr L : List (List α)\n⊢ Eq (List.foldr (fun y r => (List.permutationsAux2 t ts r y id).2) r L).length (HAdd.hAdd (List.map List.length L).sum r.length)","decl":"theorem length_foldr_permutationsAux2 (t : α) (ts : List α) (r L : List (List α)) :\n    length (foldr (fun y r => (permutationsAux2 t ts r y id).2) r L) =\n      (map length L).sum + length r := by\n  simp [foldr_permutationsAux2, Function.comp_def, length_permutationsAux2, length_flatMap]\n\n"}
{"name":"List.length_foldr_permutationsAux2'","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nt : α\nts : List α\nr L : List (List α)\nn : Nat\nH : ∀ (l : List α), Membership.mem L l → Eq l.length n\n⊢ Eq (List.foldr (fun y r => (List.permutationsAux2 t ts r y id).2) r L).length (HAdd.hAdd (HMul.hMul n L.length) r.length)","decl":"theorem length_foldr_permutationsAux2' (t : α) (ts : List α) (r L : List (List α)) (n)\n    (H : ∀ l ∈ L, length l = n) :\n    length (foldr (fun y r => (permutationsAux2 t ts r y id).2) r L) = n * length L + length r := by\n  rw [length_foldr_permutationsAux2, (_ : (map length L).sum = n * length L)]\n  induction' L with l L ih\n  · simp\n  have sum_map : (map length L).sum = n * length L := ih fun l m => H l (mem_cons_of_mem _ m)\n  have length_l : length l = n := H _ (mem_cons_self _ _)\n  simp [sum_map, length_l, Nat.mul_add, Nat.add_comm, mul_succ]\n\n"}
{"name":"List.permutationsAux_nil","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nis : List α\n⊢ Eq (List.nil.permutationsAux is) List.nil","decl":"@[simp]\ntheorem permutationsAux_nil (is : List α) : permutationsAux [] is = [] := by\n  rw [permutationsAux, permutationsAux.rec]\n\n"}
{"name":"List.permutationsAux_cons","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nt : α\nts is : List α\n⊢ Eq ((List.cons t ts).permutationsAux is) (List.foldr (fun y r => (List.permutationsAux2 t ts r y id).2) (ts.permutationsAux (List.cons t is)) is.permutations)","decl":"@[simp]\ntheorem permutationsAux_cons (t : α) (ts is : List α) :\n    permutationsAux (t :: ts) is =\n      foldr (fun y r => (permutationsAux2 t ts r y id).2) (permutationsAux ts (t :: is))\n        (permutations is) := by\n  rw [permutationsAux, permutationsAux.rec]; rfl\n\n"}
{"name":"List.permutations_nil","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\n⊢ Eq List.nil.permutations (List.cons List.nil List.nil)","decl":"@[simp]\ntheorem permutations_nil : permutations ([] : List α) = [[]] := by\n  rw [permutations, permutationsAux_nil]\n\n"}
{"name":"List.map_permutationsAux","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nts is : List α\n⊢ Eq (List.map (List.map f) (ts.permutationsAux is)) ((List.map f ts).permutationsAux (List.map f is))","decl":"theorem map_permutationsAux (f : α → β) :\n    ∀ ts is :\n    List α, map (map f) (permutationsAux ts is) = permutationsAux (map f ts) (map f is) := by\n  refine permutationsAux.rec (by simp) ?_\n  introv IH1 IH2; rw [map] at IH2\n  simp only [foldr_permutationsAux2, map_append, map, map_map_permutationsAux2, permutations,\n    flatMap_map, IH1, append_assoc, permutationsAux_cons, flatMap_cons, ← IH2, map_flatMap]\n\n"}
{"name":"List.map_permutations","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nts : List α\n⊢ Eq (List.map (List.map f) ts.permutations) (List.map f ts).permutations","decl":"theorem map_permutations (f : α → β) (ts : List α) :\n    map (map f) (permutations ts) = permutations (map f ts) := by\n  rw [permutations, permutations, map, map_permutationsAux, map]\n\n"}
{"name":"List.map_permutations'","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nts : List α\n⊢ Eq (List.map (List.map f) ts.permutations') (List.map f ts).permutations'","decl":"theorem map_permutations' (f : α → β) (ts : List α) :\n    map (map f) (permutations' ts) = permutations' (map f ts) := by\n  induction' ts with t ts ih <;>\n    [rfl; simp [← ih, map_flatMap, ← map_map_permutations'Aux, flatMap_map]]\n\n"}
{"name":"List.permutationsAux_append","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nis is' ts : List α\n⊢ Eq ((HAppend.hAppend is ts).permutationsAux is') (HAppend.hAppend (List.map (fun x => HAppend.hAppend x ts) (is.permutationsAux is')) (ts.permutationsAux (HAppend.hAppend is.reverse is')))","decl":"theorem permutationsAux_append (is is' ts : List α) :\n    permutationsAux (is ++ ts) is' =\n      (permutationsAux is is').map (· ++ ts) ++ permutationsAux ts (is.reverse ++ is') := by\n  induction' is with t is ih generalizing is'; · simp\n  simp only [foldr_permutationsAux2, ih, map_flatMap, cons_append, permutationsAux_cons, map_append,\n    reverse_cons, append_assoc, singleton_append]\n  congr 2\n  funext _\n  rw [map_permutationsAux2]\n  simp (config := { singlePass := true }) only [← permutationsAux2_comp_append]\n  simp only [id, append_assoc]\n\n"}
{"name":"List.permutations_append","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nis ts : List α\n⊢ Eq (HAppend.hAppend is ts).permutations (HAppend.hAppend (List.map (fun x => HAppend.hAppend x ts) is.permutations) (ts.permutationsAux is.reverse))","decl":"theorem permutations_append (is ts : List α) :\n    permutations (is ++ ts) = (permutations is).map (· ++ ts) ++ permutationsAux ts is.reverse := by\n  simp [permutations, permutationsAux_append]\n\n"}
{"name":"List.perm_of_mem_permutationsAux","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nts is l : List α\na✝ : Membership.mem (ts.permutationsAux is) l\n⊢ l.Perm (HAppend.hAppend ts is)","decl":"theorem perm_of_mem_permutationsAux :\n    ∀ {ts is l : List α}, l ∈ permutationsAux ts is → l ~ ts ++ is := by\n  show ∀ (ts is l : List α), l ∈ permutationsAux ts is → l ~ ts ++ is\n  refine permutationsAux.rec (by simp) ?_\n  introv IH1 IH2 m\n  rw [permutationsAux_cons, permutations, mem_foldr_permutationsAux2] at m\n  rcases m with (m | ⟨l₁, l₂, m, _, rfl⟩)\n  · exact (IH1 _ m).trans perm_middle\n  · have p : l₁ ++ l₂ ~ is := by\n      simp only [mem_cons] at m\n      cases' m with e m\n      · simp [e]\n      exact is.append_nil ▸ IH2 _ m\n    exact ((perm_middle.trans (p.cons _)).append_right _).trans (perm_append_comm.cons _)\n\n"}
{"name":"List.perm_of_mem_permutations","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nl₁ l₂ : List α\nh : Membership.mem l₂.permutations l₁\n⊢ l₁.Perm l₂","decl":"theorem perm_of_mem_permutations {l₁ l₂ : List α} (h : l₁ ∈ permutations l₂) : l₁ ~ l₂ :=\n  (eq_or_mem_of_mem_cons h).elim (fun e => e ▸ Perm.refl _) fun m =>\n    append_nil l₂ ▸ perm_of_mem_permutationsAux m\n\n"}
{"name":"List.length_permutationsAux","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nts is : List α\n⊢ Eq (HAdd.hAdd (ts.permutationsAux is).length is.length.factorial) (HAdd.hAdd ts.length is.length).factorial","decl":"theorem length_permutationsAux :\n    ∀ ts is : List α, length (permutationsAux ts is) + is.length ! = (length ts + length is)! := by\n  refine permutationsAux.rec (by simp) ?_\n  intro t ts is IH1 IH2\n  have IH2 : length (permutationsAux is nil) + 1 = is.length ! := by simpa using IH2\n  simp only [length, factorial, Nat.mul_comm, add_eq] at IH1\n  rw [permutationsAux_cons,\n    length_foldr_permutationsAux2' _ _ _ _ _ fun l m => (perm_of_mem_permutations m).length_eq,\n    permutations, length, length, IH2, Nat.succ_add, Nat.factorial_succ, Nat.mul_comm (_ + 1),\n    ← Nat.succ_eq_add_one, ← IH1, Nat.add_comm (_ * _), Nat.add_assoc, Nat.mul_succ, Nat.mul_comm]\n\n"}
{"name":"List.length_permutations","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq l.permutations.length l.length.factorial","decl":"theorem length_permutations (l : List α) : length (permutations l) = (length l)! :=\n  length_permutationsAux l []\n\n"}
{"name":"List.mem_permutations_of_perm_lemma","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nis l : List α\nH : l.Perm (HAppend.hAppend List.nil is) → Or (Exists fun ts' => Exists fun x => Eq l (HAppend.hAppend ts' is)) (Membership.mem (is.permutationsAux List.nil) l)\na✝ : l.Perm is\n⊢ Membership.mem is.permutations l","decl":"theorem mem_permutations_of_perm_lemma {is l : List α}\n    (H : l ~ [] ++ is → (∃ (ts' : _) (_ : ts' ~ []), l = ts' ++ is) ∨ l ∈ permutationsAux is []) :\n    l ~ is → l ∈ permutations is := by simpa [permutations, perm_nil] using H\n\n"}
{"name":"List.mem_permutationsAux_of_perm","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nts is l : List α\na✝ : l.Perm (HAppend.hAppend is ts)\n⊢ Or (Exists fun is' => Exists fun x => Eq l (HAppend.hAppend is' ts)) (Membership.mem (ts.permutationsAux is) l)","decl":"theorem mem_permutationsAux_of_perm :\n    ∀ {ts is l : List α},\n      l ~ is ++ ts → (∃ (is' : _) (_ : is' ~ is), l = is' ++ ts) ∨ l ∈ permutationsAux ts is := by\n  show ∀ (ts is l : List α),\n      l ~ is ++ ts → (∃ (is' : _) (_ : is' ~ is), l = is' ++ ts) ∨ l ∈ permutationsAux ts is\n  refine permutationsAux.rec (by simp) ?_\n  intro t ts is IH1 IH2 l p\n  rw [permutationsAux_cons, mem_foldr_permutationsAux2]\n  rcases IH1 _ (p.trans perm_middle) with (⟨is', p', e⟩ | m)\n  · clear p\n    subst e\n    rcases append_of_mem (p'.symm.subset (mem_cons_self _ _)) with ⟨l₁, l₂, e⟩\n    subst is'\n    have p := (perm_middle.symm.trans p').cons_inv\n    cases' l₂ with a l₂'\n    · exact Or.inl ⟨l₁, by simpa using p⟩\n    · exact Or.inr (Or.inr ⟨l₁, a :: l₂', mem_permutations_of_perm_lemma (IH2 _) p, by simp⟩)\n  · exact Or.inr (Or.inl m)\n\n"}
{"name":"List.mem_permutations","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ns t : List α\n⊢ Iff (Membership.mem t.permutations s) (s.Perm t)","decl":"@[simp]\ntheorem mem_permutations {s t : List α} : s ∈ permutations t ↔ s ~ t :=\n  ⟨perm_of_mem_permutations, mem_permutations_of_perm_lemma mem_permutationsAux_of_perm⟩\n\n-- Porting note: temporary theorem to solve diamond issue\n"}
{"name":"List.perm_permutations'Aux_comm","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\na b : α\nl : List α\n⊢ ((List.permutations'Aux a l).flatMap (List.permutations'Aux b)).Perm ((List.permutations'Aux b l).flatMap (List.permutations'Aux a))","decl":"theorem perm_permutations'Aux_comm (a b : α) (l : List α) :\n    (permutations'Aux a l).flatMap (permutations'Aux b) ~\n      (permutations'Aux b l).flatMap (permutations'Aux a) := by\n  induction' l with c l ih\n  · exact Perm.swap [a, b] [b, a] []\n  simp only [permutations'Aux, flatMap_cons, map_cons, map_map, cons_append]\n  apply Perm.swap'\n  have :\n    ∀ a b,\n      (map (cons c) (permutations'Aux a l)).flatMap (permutations'Aux b) ~\n        map (cons b ∘ cons c) (permutations'Aux a l) ++\n          map (cons c) ((permutations'Aux a l).flatMap (permutations'Aux b)) := by\n    intros a' b'\n    simp only [flatMap_map, permutations'Aux]\n    show (permutations'Aux _ l).flatMap (fun a => ([b' :: c :: a] ++\n      map (cons c) (permutations'Aux _ a))) ~ _\n    refine (flatMap_append_perm _ (fun x => [b' :: c :: x]) _).symm.trans ?_\n    rw [← map_eq_flatMap, ← map_flatMap]\n    exact Perm.refl _\n  refine (((this _ _).append_left _).trans ?_).trans ((this _ _).append_left _).symm\n  rw [← append_assoc, ← append_assoc]\n  exact perm_append_comm.append (ih.map _)\n\n"}
{"name":"List.Perm.permutations'","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ns t : List α\np : s.Perm t\n⊢ s.permutations'.Perm t.permutations'","decl":"theorem Perm.permutations' {s t : List α} (p : s ~ t) : permutations' s ~ permutations' t := by\n  induction p with\n  | nil => simp\n  | cons _ _ IH => exact IH.flatMap_right _\n  | swap =>\n    dsimp\n    rw [flatMap_assoc, flatMap_assoc]\n    apply Perm.flatMap_left\n    intro l' _\n    apply perm_permutations'Aux_comm\n  | trans _ _ IH₁ IH₂ => exact IH₁.trans IH₂\n\n"}
{"name":"List.permutations_perm_permutations'","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nts : List α\n⊢ ts.permutations.Perm ts.permutations'","decl":"theorem permutations_perm_permutations' (ts : List α) : ts.permutations ~ ts.permutations' := by\n  obtain ⟨n, h⟩ : ∃ n, length ts < n := ⟨_, Nat.lt_succ_self _⟩\n  induction' n with n IH generalizing ts; · cases h\n  refine List.reverseRecOn ts (fun _ => ?_) (fun ts t _ h => ?_) h; · simp [permutations]\n  rw [← concat_eq_append, length_concat, Nat.succ_lt_succ_iff] at h\n  have IH₂ := (IH ts.reverse (by rwa [length_reverse])).trans (reverse_perm _).permutations'\n  simp only [permutations_append, foldr_permutationsAux2, permutationsAux_nil,\n    permutationsAux_cons, append_nil]\n  refine\n    (perm_append_comm.trans ((IH₂.flatMap_right _).append ((IH _ h).map _))).trans\n      (Perm.trans ?_ perm_append_comm.permutations')\n  rw [map_eq_flatMap, singleton_append, permutations']\n  refine (flatMap_append_perm _ _ _).trans ?_\n  refine Perm.of_eq ?_\n  congr\n  funext _\n  rw [permutations'Aux_eq_permutationsAux2, permutationsAux2_append]\n\n"}
{"name":"List.mem_permutations'","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ns t : List α\n⊢ Iff (Membership.mem t.permutations' s) (s.Perm t)","decl":"@[simp]\ntheorem mem_permutations' {s t : List α} : s ∈ permutations' t ↔ s ~ t :=\n  (permutations_perm_permutations' _).symm.mem_iff.trans mem_permutations\n\n"}
{"name":"List.Perm.permutations","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ns t : List α\nh : s.Perm t\n⊢ s.permutations.Perm t.permutations","decl":"theorem Perm.permutations {s t : List α} (h : s ~ t) : permutations s ~ permutations t :=\n  (permutations_perm_permutations' _).trans <|\n    h.permutations'.trans (permutations_perm_permutations' _).symm\n\n"}
{"name":"List.perm_permutations_iff","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ns t : List α\n⊢ Iff (s.permutations.Perm t.permutations) (s.Perm t)","decl":"@[simp]\ntheorem perm_permutations_iff {s t : List α} : permutations s ~ permutations t ↔ s ~ t :=\n  ⟨fun h => mem_permutations.1 <| h.mem_iff.1 <| mem_permutations.2 (Perm.refl _),\n    Perm.permutations⟩\n\n"}
{"name":"List.perm_permutations'_iff","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ns t : List α\n⊢ Iff (s.permutations'.Perm t.permutations') (s.Perm t)","decl":"@[simp]\ntheorem perm_permutations'_iff {s t : List α} : permutations' s ~ permutations' t ↔ s ~ t :=\n  ⟨fun h => mem_permutations'.1 <| h.mem_iff.1 <| mem_permutations'.2 (Perm.refl _),\n    Perm.permutations'⟩\n\n"}
{"name":"List.getElem_permutations'Aux","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ns : List α\nx : α\nn : Nat\nhn : LT.lt n (List.permutations'Aux x s).length\n⊢ Eq (GetElem.getElem (List.permutations'Aux x s) n ⋯) (List.insertIdx n x s)","decl":"theorem getElem_permutations'Aux (s : List α) (x : α) (n : ℕ)\n    (hn : n < length (permutations'Aux x s)) :\n    (permutations'Aux x s)[n] = s.insertIdx n x := by\n  induction' s with y s IH generalizing n\n  · simp only [permutations'Aux, length, Nat.zero_add, lt_one_iff] at hn\n    simp [hn]\n  · cases n\n    · simp [get]\n    · simpa [get] using IH _ _\n\n"}
{"name":"List.get_permutations'Aux","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ns : List α\nx : α\nn : Nat\nhn : LT.lt n (List.permutations'Aux x s).length\n⊢ Eq ((List.permutations'Aux x s).get ⟨n, hn⟩) (List.insertIdx n x s)","decl":"theorem get_permutations'Aux (s : List α) (x : α) (n : ℕ)\n    (hn : n < length (permutations'Aux x s)) :\n    (permutations'Aux x s).get ⟨n, hn⟩ = s.insertIdx n x := by\n  simp [getElem_permutations'Aux]\n\n"}
{"name":"List.count_permutations'Aux_self","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nx : α\n⊢ Eq (List.count (List.cons x l) (List.permutations'Aux x l)) (HAdd.hAdd (List.takeWhile (fun x_1 => Decidable.decide (Eq x x_1)) l).length 1)","decl":"theorem count_permutations'Aux_self [DecidableEq α] (l : List α) (x : α) :\n    count (x :: l) (permutations'Aux x l) = length (takeWhile (x = ·) l) + 1 := by\n  induction' l with y l IH generalizing x\n  · simp [takeWhile, count]\n  · rw [permutations'Aux, count_cons_self]\n    by_cases hx : x = y\n    · subst hx\n      simpa [takeWhile, Nat.succ_inj', DecEq_eq] using IH _\n    · rw [takeWhile]\n      simp only [mem_map, cons.injEq, Ne.symm hx, false_and, and_false, exists_false,\n        not_false_iff, count_eq_zero_of_not_mem, Nat.zero_add, hx, decide_false, length_nil]\n\n"}
{"name":"List.length_permutations'Aux","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ns : List α\nx : α\n⊢ Eq (List.permutations'Aux x s).length (HAdd.hAdd s.length 1)","decl":"@[simp]\ntheorem length_permutations'Aux (s : List α) (x : α) :\n    length (permutations'Aux x s) = length s + 1 := by\n  induction' s with y s IH\n  · simp\n  · simpa using IH\n\n"}
{"name":"List.injective_permutations'Aux","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nx : α\n⊢ Function.Injective (List.permutations'Aux x)","decl":"theorem injective_permutations'Aux (x : α) : Function.Injective (permutations'Aux x) := by\n  intro s t h\n  apply insertIdx_injective s.length x\n  have hl : s.length = t.length := by simpa using congr_arg length h\n  rw [← get_permutations'Aux s x s.length (by simp),\n    ← get_permutations'Aux t x s.length (by simp [hl])]\n  simp only [get_eq_getElem, h, hl]\n\n"}
{"name":"List.nodup_permutations'Aux_of_not_mem","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ns : List α\nx : α\nhx : Not (Membership.mem s x)\n⊢ (List.permutations'Aux x s).Nodup","decl":"theorem nodup_permutations'Aux_of_not_mem (s : List α) (x : α) (hx : x ∉ s) :\n    Nodup (permutations'Aux x s) := by\n  induction' s with y s IH\n  · simp\n  · simp only [not_or, mem_cons] at hx\n    simp only [permutations'Aux, nodup_cons, mem_map, cons.injEq, exists_eq_right_right, not_and]\n    refine ⟨fun _ => Ne.symm hx.left, ?_⟩\n    rw [nodup_map_iff]\n    · exact IH hx.right\n    · simp\n\n"}
{"name":"List.nodup_permutations'Aux_iff","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ns : List α\nx : α\n⊢ Iff (List.permutations'Aux x s).Nodup (Not (Membership.mem s x))","decl":"theorem nodup_permutations'Aux_iff {s : List α} {x : α} : Nodup (permutations'Aux x s) ↔ x ∉ s := by\n  refine ⟨fun h H ↦ ?_, nodup_permutations'Aux_of_not_mem _ _⟩\n  obtain ⟨⟨k, hk⟩, hk'⟩ := get_of_mem H\n  rw [nodup_iff_injective_get] at h\n  apply k.succ_ne_self.symm\n  have kl : k < (permutations'Aux x s).length := by simpa [Nat.lt_succ_iff] using hk.le\n  have k1l : k + 1 < (permutations'Aux x s).length := by simpa using hk\n  rw [← @Fin.mk.inj_iff _ _ _ kl k1l]; apply h\n  rw [get_permutations'Aux, get_permutations'Aux]\n  have hl : length (insertIdx k x s) = length (insertIdx (k + 1) x s) := by\n    rw [length_insertIdx_of_le_length hk.le, length_insertIdx_of_le_length (Nat.succ_le_of_lt hk)]\n  refine ext_get hl fun n hn hn' => ?_\n  rcases lt_trichotomy n k with (H | rfl | H)\n  · rw [get_insertIdx_of_lt _ _ _ _ H (H.trans hk),\n      get_insertIdx_of_lt _ _ _ _ (H.trans (Nat.lt_succ_self _))]\n  · rw [get_insertIdx_self _ _ _ hk.le, get_insertIdx_of_lt _ _ _ _ (Nat.lt_succ_self _) hk, hk']\n  · rcases (Nat.succ_le_of_lt H).eq_or_lt with (rfl | H')\n    · rw [get_insertIdx_self _ _ _ (Nat.succ_le_of_lt hk)]\n      convert hk' using 1\n      exact get_insertIdx_add_succ _ _ _ 0 _\n    · obtain ⟨m, rfl⟩ := Nat.exists_eq_add_of_lt H'\n      rw [length_insertIdx_of_le_length hk.le, Nat.succ_lt_succ_iff, Nat.succ_add] at hn\n      rw [get_insertIdx_add_succ]\n      · convert get_insertIdx_add_succ s x k m.succ (by simpa using hn) using 2\n        · simp [Nat.add_assoc, Nat.add_left_comm]\n        · simp [Nat.add_left_comm, Nat.add_comm]\n      · simpa [Nat.succ_add] using hn\n\n"}
{"name":"List.nodup_permutations","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ns : List α\nhs : s.Nodup\n⊢ s.permutations.Nodup","decl":"theorem nodup_permutations (s : List α) (hs : Nodup s) : Nodup s.permutations := by\n  rw [(permutations_perm_permutations' s).nodup_iff]\n  induction' hs with x l h h' IH\n  · simp\n  · rw [permutations']\n    rw [nodup_flatMap]\n    constructor\n    · intro ys hy\n      rw [mem_permutations'] at hy\n      rw [nodup_permutations'Aux_iff, hy.mem_iff]\n      exact fun H => h x H rfl\n    · refine IH.pairwise_of_forall_ne fun as ha bs hb H => ?_\n      rw [Function.onFun, disjoint_iff_ne]\n      rintro a ha' b hb' rfl\n      obtain ⟨⟨n, hn⟩, hn'⟩ := get_of_mem ha'\n      obtain ⟨⟨m, hm⟩, hm'⟩ := get_of_mem hb'\n      rw [mem_permutations'] at ha hb\n      have hl : as.length = bs.length := (ha.trans hb.symm).length_eq\n      simp only [Nat.lt_succ_iff, length_permutations'Aux] at hn hm\n      rw [get_permutations'Aux] at hn' hm'\n      have hx : (insertIdx n x as)[m]'(by\n          rwa [length_insertIdx_of_le_length hn, Nat.lt_succ_iff, hl]) = x := by\n        simp [hn', ← hm', hm]\n      have hx' : (insertIdx m x bs)[n]'(by\n          rwa [length_insertIdx_of_le_length hm, Nat.lt_succ_iff, ← hl]) = x := by\n        simp [hm', ← hn', hn]\n      rcases lt_trichotomy n m with (ht | ht | ht)\n      · suffices x ∈ bs by exact h x (hb.subset this) rfl\n        rw [← hx', getElem_insertIdx_of_lt ht]\n        exact getElem_mem _\n      · simp only [ht] at hm' hn'\n        rw [← hm'] at hn'\n        exact H (insertIdx_injective _ _ hn')\n      · suffices x ∈ as by exact h x (ha.subset this) rfl\n        rw [← hx, getElem_insertIdx_of_lt ht]\n        exact getElem_mem _\n\n"}
{"name":"List.permutations_take_two","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\nx y : α\ns : List α\n⊢ Eq (List.take 2 (List.cons x (List.cons y s)).permutations) (List.cons (List.cons x (List.cons y s)) (List.cons (List.cons y (List.cons x s)) List.nil))","decl":"lemma permutations_take_two (x y : α) (s : List α) :\n    (x :: y :: s).permutations.take 2 = [x :: y :: s, y :: x :: s] := by\n  induction s <;> simp [permutations, permutationsAux.rec]\n\n"}
{"name":"List.nodup_permutations_iff","module":"Mathlib.Data.List.Permutation","initialProofState":"α : Type u_1\ns : List α\n⊢ Iff s.permutations.Nodup s.Nodup","decl":"@[simp]\ntheorem nodup_permutations_iff {s : List α} : Nodup s.permutations ↔ Nodup s := by\n  refine ⟨?_, nodup_permutations s⟩\n  contrapose\n  rw [← exists_duplicate_iff_not_nodup]\n  intro ⟨x, hs⟩\n  rw [duplicate_iff_sublist] at hs\n  obtain ⟨l, ht⟩ := List.Sublist.exists_perm_append hs\n  rw [List.Perm.nodup_iff (List.Perm.permutations ht), ← exists_duplicate_iff_not_nodup]\n  use x :: x :: l\n  rw [List.duplicate_iff_sublist, ← permutations_take_two]\n  exact take_sublist 2 _\n\n-- TODO: `count s s.permutations = (zipWith count s s.tails).prod`\n\n"}
