{"name":"FirstOrder.Language.Term.listDecode_encode_list","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\nl : List (L.Term α)\n⊢ Eq (FirstOrder.Language.Term.listDecode (l.flatMap FirstOrder.Language.Term.listEncode)) l","decl":"theorem listDecode_encode_list (l : List (L.Term α)) :\n    listDecode (l.flatMap listEncode) = l := by\n  suffices h : ∀ (t : L.Term α) (l : List (α ⊕ (Σi, L.Functions i))),\n      listDecode (t.listEncode ++ l) = t::listDecode l by\n    induction' l with t l lih\n    · rfl\n    · rw [flatMap_cons, h t (l.flatMap listEncode), lih]\n  intro t\n  induction' t with a n f ts ih <;> intro l\n  · rw [listEncode, singleton_append, listDecode]\n  · rw [listEncode, cons_append, listDecode]\n    have h : listDecode (((finRange n).flatMap fun i : Fin n => (ts i).listEncode) ++ l) =\n        (finRange n).map ts ++ listDecode l := by\n      induction' finRange n with i l' l'ih\n      · rfl\n      · rw [flatMap_cons, List.append_assoc, ih, map_cons, l'ih, cons_append]\n    simp only [h, length_append, length_map, length_finRange, le_add_iff_nonneg_right,\n      _root_.zero_le, ↓reduceDIte, getElem_fin, cons.injEq, func.injEq, heq_eq_eq, true_and]\n    refine ⟨funext (fun i => ?_), ?_⟩\n    · simp only [length_map, length_finRange, is_lt, getElem_append_left, getElem_map,\n      getElem_finRange, cast_mk, Fin.eta]\n    · simp only [length_map, length_finRange, drop_left']\n\n"}
{"name":"FirstOrder.Language.Term.encoding_decode","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\nl : List (Sum α (Sigma fun i => L.Functions i))\n⊢ Eq (FirstOrder.Language.Term.encoding.decode l) (Bind.bind (FirstOrder.Language.Term.listDecode l).head? fun a => Pure.pure (Option.some a)).join","decl":"/-- An encoding of terms as lists. -/\n@[simps]\nprotected def encoding : Encoding (L.Term α) where\n  Γ := α ⊕ (Σi, L.Functions i)\n  encode := listEncode\n  decode l := (listDecode l).head?.join\n  decode_encode t := by\n    have h := listDecode_encode_list [t]\n    rw [flatMap_singleton] at h\n    simp only [Option.join, h, head?_cons, Option.pure_def, Option.bind_eq_bind, Option.some_bind,\n      id_eq]\n\n"}
{"name":"FirstOrder.Language.Term.encoding_Γ","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\n⊢ Eq FirstOrder.Language.Term.encoding.Γ (Sum α (Sigma fun i => L.Functions i))","decl":"/-- An encoding of terms as lists. -/\n@[simps]\nprotected def encoding : Encoding (L.Term α) where\n  Γ := α ⊕ (Σi, L.Functions i)\n  encode := listEncode\n  decode l := (listDecode l).head?.join\n  decode_encode t := by\n    have h := listDecode_encode_list [t]\n    rw [flatMap_singleton] at h\n    simp only [Option.join, h, head?_cons, Option.pure_def, Option.bind_eq_bind, Option.some_bind,\n      id_eq]\n\n"}
{"name":"FirstOrder.Language.Term.encoding_encode","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\na✝ : L.Term α\n⊢ Eq (FirstOrder.Language.Term.encoding.encode a✝) a✝.listEncode","decl":"/-- An encoding of terms as lists. -/\n@[simps]\nprotected def encoding : Encoding (L.Term α) where\n  Γ := α ⊕ (Σi, L.Functions i)\n  encode := listEncode\n  decode l := (listDecode l).head?.join\n  decode_encode t := by\n    have h := listDecode_encode_list [t]\n    rw [flatMap_singleton] at h\n    simp only [Option.join, h, head?_cons, Option.pure_def, Option.bind_eq_bind, Option.some_bind,\n      id_eq]\n\n"}
{"name":"FirstOrder.Language.Term.listEncode_injective","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\n⊢ Function.Injective FirstOrder.Language.Term.listEncode","decl":"theorem listEncode_injective :\n    Function.Injective (listEncode : L.Term α → List (α ⊕ (Σi, L.Functions i))) :=\n  Term.encoding.encode_injective\n\n"}
{"name":"FirstOrder.Language.Term.card_le","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\n⊢ LE.le (Cardinal.mk (L.Term α)) (Max.max Cardinal.aleph0 (Cardinal.mk (Sum α (Sigma fun i => L.Functions i))))","decl":"theorem card_le : #(L.Term α) ≤ max ℵ₀ #(α ⊕ (Σi, L.Functions i)) :=\n  lift_le.1 (_root_.trans Term.encoding.card_le_card_list (lift_le.2 (mk_list_le_max _)))\n\n"}
{"name":"FirstOrder.Language.Term.card_sigma","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\n⊢ Eq (Cardinal.mk (Sigma fun n => L.Term (Sum α (Fin n)))) (Max.max Cardinal.aleph0 (Cardinal.mk (Sum α (Sigma fun i => L.Functions i))))","decl":"theorem card_sigma : #(Σn, L.Term (α ⊕ (Fin n))) = max ℵ₀ #(α ⊕ (Σi, L.Functions i)) := by\n  refine le_antisymm ?_ ?_\n  · rw [mk_sigma]\n    refine (sum_le_iSup_lift _).trans ?_\n    rw [mk_nat, lift_aleph0, mul_eq_max_of_aleph0_le_left le_rfl, max_le_iff,\n      ciSup_le_iff' (bddAbove_range _)]\n    · refine ⟨le_max_left _ _, fun i => card_le.trans ?_⟩\n      refine max_le (le_max_left _ _) ?_\n      rw [← add_eq_max le_rfl, mk_sum, mk_sum, mk_sum, add_comm (Cardinal.lift #α), lift_add,\n        add_assoc, lift_lift, lift_lift, mk_fin, lift_natCast]\n      exact add_le_add_right (nat_lt_aleph0 _).le _\n    · rw [← one_le_iff_ne_zero]\n      refine _root_.trans ?_ (le_ciSup (bddAbove_range _) 1)\n      rw [one_le_iff_ne_zero, mk_ne_zero_iff]\n      exact ⟨var (Sum.inr 0)⟩\n  · rw [max_le_iff, ← infinite_iff]\n    refine ⟨Infinite.of_injective (fun i => ⟨i + 1, var (Sum.inr i)⟩) fun i j ij => ?_, ?_⟩\n    · cases ij\n      rfl\n    · rw [Cardinal.le_def]\n      refine ⟨⟨Sum.elim (fun i => ⟨0, var (Sum.inl i)⟩)\n        fun F => ⟨1, func F.2 fun _ => var (Sum.inr 0)⟩, ?_⟩⟩\n      rintro (a | a) (b | b) h\n      · simp only [Sum.elim_inl, Sigma.mk.inj_iff, heq_eq_eq, var.injEq, Sum.inl.injEq, true_and]\n          at h\n        rw [h]\n      · simp only [Sum.elim_inl, Sum.elim_inr, Sigma.mk.inj_iff, false_and, reduceCtorEq] at h\n      · simp only [Sum.elim_inr, Sum.elim_inl, Sigma.mk.inj_iff, false_and, reduceCtorEq] at h\n      · simp only [Sum.elim_inr, Sigma.mk.inj_iff, heq_eq_eq, func.injEq, true_and] at h\n        rw [Sigma.ext_iff.2 ⟨h.1, h.2.1⟩]\n\n"}
{"name":"FirstOrder.Language.Term.instCountableOfSigmaNatFunctions","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\nh1 : Countable α\nh2 : Countable (Sigma fun l => L.Functions l)\n⊢ Countable (L.Term α)","decl":"instance [h1 : Countable α] [h2 : Countable (Σl, L.Functions l)] : Countable (L.Term α) := by\n  refine mk_le_aleph0_iff.1 (card_le.trans (max_le_iff.2 ?_))\n  simp only [le_refl, mk_sum, add_le_aleph0, lift_le_aleph0, true_and]\n  exact ⟨Cardinal.mk_le_aleph0, Cardinal.mk_le_aleph0⟩\n\n"}
{"name":"FirstOrder.Language.Term.small","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\ninst✝ : Small.{u, u'} α\n⊢ Small.{u, max u u'} (L.Term α)","decl":"instance small [Small.{u} α] : Small.{u} (L.Term α) :=\n  small_of_injective listEncode_injective\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.sigmaAll_apply","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α (HAdd.hAdd n 1)\n⊢ Eq (FirstOrder.Language.BoundedFormula.sigmaAll ⟨HAdd.hAdd n 1, φ⟩) ⟨n, φ.all⟩","decl":"@[simp]\nlemma sigmaAll_apply {n} {φ : L.BoundedFormula α (n + 1)} :\n    sigmaAll ⟨n + 1, φ⟩ = ⟨n, φ.all⟩ := rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.sigmaImp_apply","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ ψ : L.BoundedFormula α n\n⊢ Eq (FirstOrder.Language.BoundedFormula.sigmaImp ⟨n, φ⟩ ⟨n, ψ⟩) ⟨n, φ.imp ψ⟩","decl":"/-- Decodes a list of symbols as a list of formulas. -/\n@[simp]\nlemma sigmaImp_apply {n} {φ ψ : L.BoundedFormula α n} :\n    sigmaImp ⟨n, φ⟩ ⟨n, ψ⟩ = ⟨n, φ.imp ψ⟩ := by\n  simp only [sigmaImp, ↓reduceDIte, eq_mp_eq_cast, cast_eq]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.listDecode_encode_list","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\nl : List (Sigma fun n => L.BoundedFormula α n)\n⊢ Eq (FirstOrder.Language.BoundedFormula.listDecode (l.flatMap fun φ => φ.snd.listEncode)) l","decl":"@[simp]\ntheorem listDecode_encode_list (l : List (Σn, L.BoundedFormula α n)) :\n    listDecode (l.flatMap (fun φ => φ.2.listEncode)) = l := by\n  suffices h : ∀ (φ : Σn, L.BoundedFormula α n)\n      (l' : List ((Σk, L.Term (α ⊕ Fin k)) ⊕ ((Σn, L.Relations n) ⊕ ℕ))),\n      (listDecode (listEncode φ.2 ++ l')) = φ::(listDecode l') by\n    induction' l with φ l ih\n    · rw [List.flatMap_nil]\n      simp [listDecode]\n    · rw [flatMap_cons, h φ _, ih]\n  rintro ⟨n, φ⟩\n  induction φ with\n  | falsum => intro l; rw [listEncode, singleton_append, listDecode]\n  | equal =>\n    intro l\n    rw [listEncode, cons_append, cons_append, listDecode, dif_pos]\n    · simp only [eq_mp_eq_cast, cast_eq, eq_self_iff_true, heq_iff_eq, and_self_iff, nil_append]\n    · simp only [eq_self_iff_true, heq_iff_eq, and_self_iff]\n  | @rel φ_n φ_l φ_R ts =>\n    intro l\n    rw [listEncode, cons_append, cons_append, singleton_append, cons_append, listDecode]\n    have h : ∀ i : Fin φ_l, ((List.map Sum.getLeft? (List.map (fun i : Fin φ_l =>\n      Sum.inl (⟨(⟨φ_n, rel φ_R ts⟩ : Σn, L.BoundedFormula α n).fst, ts i⟩ :\n        Σn, L.Term (α ⊕ (Fin n)))) (finRange φ_l) ++ l)).get? ↑i).join = some ⟨_, ts i⟩ := by\n      intro i\n      simp only [Option.join, map_append, map_map, Option.bind_eq_some, id, exists_eq_right,\n        get?_eq_some_iff, length_append, length_map, length_finRange]\n      refine ⟨lt_of_lt_of_le i.2 le_self_add, ?_⟩\n      rw [get_eq_getElem, getElem_append_left, getElem_map]\n      · simp only [getElem_finRange, cast_mk, Fin.eta, Function.comp_apply, Sum.getLeft?_inl]\n      · simp only [length_map, length_finRange, is_lt]\n    rw [dif_pos]\n    swap\n    · exact fun i => Option.isSome_iff_exists.2 ⟨⟨_, ts i⟩, h i⟩\n    rw [dif_pos]\n    swap\n    · intro i\n      obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n      rw [h2]\n    simp only [Option.join, eq_mp_eq_cast, cons.injEq, Sigma.mk.inj_iff, heq_eq_eq, rel.injEq,\n      true_and]\n    refine ⟨funext fun i => ?_, ?_⟩\n    · obtain ⟨h1, h2⟩ := Option.eq_some_iff_get_eq.1 (h i)\n      rw [cast_eq_iff_heq]\n      exact (Sigma.ext_iff.1 ((Sigma.eta (Option.get _ h1)).trans h2)).2\n    rw [List.drop_append_eq_append_drop, length_map, length_finRange, Nat.sub_self, drop,\n      drop_eq_nil_of_le, nil_append]\n    rw [length_map, length_finRange]\n  | imp _ _ ih1 ih2 =>\n    intro l\n    simp only [] at *\n    rw [listEncode, List.append_assoc, cons_append, listDecode]\n    simp only [ih1, ih2, length_cons, le_add_iff_nonneg_left, _root_.zero_le, ↓reduceDIte,\n      getElem_cons_zero, getElem_cons_succ, sigmaImp_apply, drop_succ_cons, drop_zero]\n  | all _ ih =>\n    intro l\n    simp only [] at *\n    rw [listEncode, cons_append, listDecode]\n    simp only [ih, length_cons, le_add_iff_nonneg_left, _root_.zero_le, ↓reduceDIte,\n      getElem_cons_zero, sigmaAll_apply, drop_succ_cons, drop_zero]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.encoding_encode","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\nφ : Sigma fun n => L.BoundedFormula α n\n⊢ Eq (FirstOrder.Language.BoundedFormula.encoding.encode φ) φ.snd.listEncode","decl":"/-- An encoding of bounded formulas as lists. -/\n@[simps]\nprotected def encoding : Encoding (Σn, L.BoundedFormula α n) where\n  Γ := (Σk, L.Term (α ⊕ Fin k)) ⊕ ((Σn, L.Relations n) ⊕ ℕ)\n  encode φ := φ.2.listEncode\n  decode l := (listDecode l)[0]?\n  decode_encode φ := by\n    have h := listDecode_encode_list [φ]\n    rw [flatMap_singleton] at h\n    simp only\n    rw [h]\n    rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.encoding_decode","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\nl : List (Sum (Sigma fun k => L.Term (Sum α (Fin k))) (Sum (Sigma fun n => L.Relations n) Nat))\n⊢ Eq (FirstOrder.Language.BoundedFormula.encoding.decode l) (GetElem?.getElem? (FirstOrder.Language.BoundedFormula.listDecode l) 0)","decl":"/-- An encoding of bounded formulas as lists. -/\n@[simps]\nprotected def encoding : Encoding (Σn, L.BoundedFormula α n) where\n  Γ := (Σk, L.Term (α ⊕ Fin k)) ⊕ ((Σn, L.Relations n) ⊕ ℕ)\n  encode φ := φ.2.listEncode\n  decode l := (listDecode l)[0]?\n  decode_encode φ := by\n    have h := listDecode_encode_list [φ]\n    rw [flatMap_singleton] at h\n    simp only\n    rw [h]\n    rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.encoding_Γ","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\n⊢ Eq FirstOrder.Language.BoundedFormula.encoding.Γ (Sum (Sigma fun k => L.Term (Sum α (Fin k))) (Sum (Sigma fun n => L.Relations n) Nat))","decl":"/-- An encoding of bounded formulas as lists. -/\n@[simps]\nprotected def encoding : Encoding (Σn, L.BoundedFormula α n) where\n  Γ := (Σk, L.Term (α ⊕ Fin k)) ⊕ ((Σn, L.Relations n) ⊕ ℕ)\n  encode φ := φ.2.listEncode\n  decode l := (listDecode l)[0]?\n  decode_encode φ := by\n    have h := listDecode_encode_list [φ]\n    rw [flatMap_singleton] at h\n    simp only\n    rw [h]\n    rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.listEncode_sigma_injective","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\n⊢ Function.Injective fun φ => φ.snd.listEncode","decl":"theorem listEncode_sigma_injective :\n    Function.Injective fun φ : Σn, L.BoundedFormula α n => φ.2.listEncode :=\n  BoundedFormula.encoding.encode_injective\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.card_le","module":"Mathlib.ModelTheory.Encoding","initialProofState":"L : FirstOrder.Language\nα : Type u'\n⊢ LE.le (Cardinal.mk (Sigma fun n => L.BoundedFormula α n)) (Max.max Cardinal.aleph0 (HAdd.hAdd (Cardinal.lift.{max u v, u'} (Cardinal.mk α)) (Cardinal.lift.{u', max u v} L.card)))","decl":"theorem card_le : #(Σn, L.BoundedFormula α n) ≤\n    max ℵ₀ (Cardinal.lift.{max u v} #α + Cardinal.lift.{u'} L.card) := by\n  refine lift_le.1 (BoundedFormula.encoding.card_le_card_list.trans ?_)\n  rw [encoding_Γ, mk_list_eq_max_mk_aleph0, lift_max, lift_aleph0, lift_max, lift_aleph0,\n    max_le_iff]\n  refine ⟨?_, le_max_left _ _⟩\n  rw [mk_sum, Term.card_sigma, mk_sum, ← add_eq_max le_rfl, mk_sum, mk_nat]\n  simp only [lift_add, lift_lift, lift_aleph0]\n  rw [← add_assoc, add_comm, ← add_assoc, ← add_assoc, aleph0_add_aleph0, add_assoc,\n    add_eq_max le_rfl, add_assoc, card, Symbols, mk_sum, lift_add, lift_lift, lift_lift]\n\n"}
