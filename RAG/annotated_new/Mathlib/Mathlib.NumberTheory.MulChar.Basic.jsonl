{"name":"MulChar.map_nonunit'","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nself : MulChar R R'\na : R\na✝ : Not (IsUnit a)\n⊢ Eq ((↑self.toMonoidHom).toFun a) 0","decl":"/-- Define a structure for multiplicative characters.\nA multiplicative character from a commutative monoid `R` to a commutative monoid with zero `R'`\nis a homomorphism of (multiplicative) monoids that sends non-units to zero. -/\nstructure MulChar extends MonoidHom R R' where\n  map_nonunit' : ∀ a : R, ¬IsUnit a → toFun a = 0\n\n"}
{"name":"MulChar.mk.inj","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\ntoMonoidHom✝ : MonoidHom R R'\nmap_nonunit'✝ : ∀ (a : R), Not (IsUnit a) → Eq ((↑toMonoidHom✝).toFun a) 0\ntoMonoidHom : MonoidHom R R'\nmap_nonunit' : ∀ (a : R), Not (IsUnit a) → Eq ((↑toMonoidHom).toFun a) 0\nx✝ : Eq { toMonoidHom := toMonoidHom✝, map_nonunit' := map_nonunit'✝ } { toMonoidHom := toMonoidHom, map_nonunit' := map_nonunit' }\n⊢ Eq toMonoidHom✝ toMonoidHom","decl":"/-- Define a structure for multiplicative characters.\nA multiplicative character from a commutative monoid `R` to a commutative monoid with zero `R'`\nis a homomorphism of (multiplicative) monoids that sends non-units to zero. -/\nstructure MulChar extends MonoidHom R R' where\n  map_nonunit' : ∀ a : R, ¬IsUnit a → toFun a = 0\n\n"}
{"name":"MulChar.mk.sizeOf_spec","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommMonoid R\nR' : Type u_2\ninst✝² : CommMonoidWithZero R'\ninst✝¹ : SizeOf R\ninst✝ : SizeOf R'\ntoMonoidHom : MonoidHom R R'\nmap_nonunit' : ∀ (a : R), Not (IsUnit a) → Eq ((↑toMonoidHom).toFun a) 0\n⊢ Eq (SizeOf.sizeOf { toMonoidHom := toMonoidHom, map_nonunit' := map_nonunit' }) (HAdd.hAdd 1 (SizeOf.sizeOf toMonoidHom))","decl":"/-- Define a structure for multiplicative characters.\nA multiplicative character from a commutative monoid `R` to a commutative monoid with zero `R'`\nis a homomorphism of (multiplicative) monoids that sends non-units to zero. -/\nstructure MulChar extends MonoidHom R R' where\n  map_nonunit' : ∀ a : R, ¬IsUnit a → toFun a = 0\n\n"}
{"name":"MulChar.mk.injEq","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\ntoMonoidHom✝ : MonoidHom R R'\nmap_nonunit'✝ : ∀ (a : R), Not (IsUnit a) → Eq ((↑toMonoidHom✝).toFun a) 0\ntoMonoidHom : MonoidHom R R'\nmap_nonunit' : ∀ (a : R), Not (IsUnit a) → Eq ((↑toMonoidHom).toFun a) 0\n⊢ Eq (Eq { toMonoidHom := toMonoidHom✝, map_nonunit' := map_nonunit'✝ } { toMonoidHom := toMonoidHom, map_nonunit' := map_nonunit' }) (Eq toMonoidHom✝ toMonoidHom)","decl":"/-- Define a structure for multiplicative characters.\nA multiplicative character from a commutative monoid `R` to a commutative monoid with zero `R'`\nis a homomorphism of (multiplicative) monoids that sends non-units to zero. -/\nstructure MulChar extends MonoidHom R R' where\n  map_nonunit' : ∀ a : R, ¬IsUnit a → toFun a = 0\n\n"}
{"name":"MulCharClass.toMonoidHomClass","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"F : Type u_3\nR : outParam (Type u_4)\nR' : outParam (Type u_5)\ninst✝² : CommMonoid R\ninst✝¹ : CommMonoidWithZero R'\ninst✝ : FunLike F R R'\nself : MulCharClass F R R'\n⊢ MonoidHomClass F R R'","decl":"/-- This is the corresponding extension of `MonoidHomClass`. -/\nclass MulCharClass (F : Type*) (R R' : outParam Type*) [CommMonoid R]\n  [CommMonoidWithZero R'] [FunLike F R R'] extends MonoidHomClass F R R' : Prop where\n  map_nonunit : ∀ (χ : F) {a : R} (_ : ¬IsUnit a), χ a = 0\n\n"}
{"name":"MulCharClass.map_nonunit","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"F : Type u_3\nR : outParam (Type u_4)\nR' : outParam (Type u_5)\ninst✝² : CommMonoid R\ninst✝¹ : CommMonoidWithZero R'\ninst✝ : FunLike F R R'\nself : MulCharClass F R R'\nχ : F\na : R\nx✝ : Not (IsUnit a)\n⊢ Eq (χ a) 0","decl":"/-- This is the corresponding extension of `MonoidHomClass`. -/\nclass MulCharClass (F : Type*) (R R' : outParam Type*) [CommMonoid R]\n  [CommMonoidWithZero R'] [FunLike F R R'] extends MonoidHomClass F R R' : Prop where\n  map_nonunit : ∀ (χ : F) {a : R} (_ : ¬IsUnit a), χ a = 0\n\n"}
{"name":"MulChar.trivial_apply","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nx : R\n⊢ Eq ((MulChar.trivial R R') x) (ite (IsUnit x) 1 0)","decl":"variable (R R') in\n/-- The trivial multiplicative character. It takes the value `0` on non-units and\nthe value `1` on units. -/\n@[simps]\nnoncomputable def trivial : MulChar R R' where\n  toFun := by classical exact fun x => if IsUnit x then 1 else 0\n  map_nonunit' := by\n    intro a ha\n    simp only [ha, if_false]\n  map_one' := by simp only [isUnit_one, if_true]\n  map_mul' := by\n    intro x y\n    classical\n      simp only [IsUnit.mul_iff, boole_mul]\n      split_ifs <;> tauto\n\n"}
{"name":"MulChar.coe_mk","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nf : MonoidHom R R'\nhf : ∀ (a : R), Not (IsUnit a) → Eq ((↑f).toFun a) 0\n⊢ Eq ⇑{ toMonoidHom := f, map_nonunit' := hf } ⇑f","decl":"@[simp]\ntheorem coe_mk (f : R →* R') (hf) : (MulChar.mk f hf : R → R') = f :=\n  rfl\n\n"}
{"name":"MulChar.ext'","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ χ' : MulChar R R'\nh : ∀ (a : R), Eq (χ a) (χ' a)\n⊢ Eq χ χ'","decl":"/-- Extensionality. See `ext` below for the version that will actually be used. -/\ntheorem ext' {χ χ' : MulChar R R'} (h : ∀ a, χ a = χ' a) : χ = χ' := by\n  cases χ\n  cases χ'\n  congr\n  exact MonoidHom.ext h\n\n"}
{"name":"MulChar.instMulCharClass","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\n⊢ MulCharClass (MulChar R R') R R'","decl":"instance : MulCharClass (MulChar R R') R R' where\n  map_mul χ := χ.map_mul'\n  map_one χ := χ.map_one'\n  map_nonunit χ := χ.map_nonunit' _\n\n"}
{"name":"MulChar.map_nonunit","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\na : R\nha : Not (IsUnit a)\n⊢ Eq (χ a) 0","decl":"theorem map_nonunit (χ : MulChar R R') {a : R} (ha : ¬IsUnit a) : χ a = 0 :=\n  χ.map_nonunit' a ha\n\n"}
{"name":"MulChar.ext","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ χ' : MulChar R R'\nh : ∀ (a : Units R), Eq (χ ↑a) (χ' ↑a)\n⊢ Eq χ χ'","decl":"/-- Extensionality. Since `MulChar`s always take the value zero on non-units, it is sufficient\nto compare the values on units. -/\n@[ext]\ntheorem ext {χ χ' : MulChar R R'} (h : ∀ a : Rˣ, χ a = χ' a) : χ = χ' := by\n  apply ext'\n  intro a\n  by_cases ha : IsUnit a\n  · exact h ha.unit\n  · rw [map_nonunit χ ha, map_nonunit χ' ha]\n\n"}
{"name":"MulChar.ext_iff","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ χ' : MulChar R R'\n⊢ Iff (Eq χ χ') (∀ (a : Units R), Eq (χ ↑a) (χ' ↑a))","decl":"/-- Extensionality. Since `MulChar`s always take the value zero on non-units, it is sufficient\nto compare the values on units. -/\n@[ext]\ntheorem ext {χ χ' : MulChar R R'} (h : ∀ a : Rˣ, χ a = χ' a) : χ = χ' := by\n  apply ext'\n  intro a\n  by_cases ha : IsUnit a\n  · exact h ha.unit\n  · rw [map_nonunit χ ha, map_nonunit χ' ha]\n\n"}
{"name":"MulChar.coe_toUnitHom","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\na : Units R\n⊢ Eq (↑(χ.toUnitHom a)) (χ ↑a)","decl":"theorem coe_toUnitHom (χ : MulChar R R') (a : Rˣ) : ↑(χ.toUnitHom a) = χ a :=\n  rfl\n\n"}
{"name":"MulChar.ofUnitHom_coe","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nf : MonoidHom (Units R) (Units R')\na : Units R\n⊢ Eq ((MulChar.ofUnitHom f) ↑a) ↑(f a)","decl":"theorem ofUnitHom_coe (f : Rˣ →* R'ˣ) (a : Rˣ) : ofUnitHom f ↑a = f a := by simp [ofUnitHom]\n\n"}
{"name":"MulChar.toUnitHom_eq","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\n⊢ Eq χ.toUnitHom (MulChar.equivToUnitHom χ)","decl":"@[simp]\ntheorem toUnitHom_eq (χ : MulChar R R') : toUnitHom χ = equivToUnitHom χ :=\n  rfl\n\n"}
{"name":"MulChar.ofUnitHom_eq","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MonoidHom (Units R) (Units R')\n⊢ Eq (MulChar.ofUnitHom χ) (MulChar.equivToUnitHom.symm χ)","decl":"@[simp]\ntheorem ofUnitHom_eq (χ : Rˣ →* R'ˣ) : ofUnitHom χ = equivToUnitHom.symm χ :=\n  rfl\n\n"}
{"name":"MulChar.coe_equivToUnitHom","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\na : Units R\n⊢ Eq (↑((MulChar.equivToUnitHom χ) a)) (χ ↑a)","decl":"@[simp]\ntheorem coe_equivToUnitHom (χ : MulChar R R') (a : Rˣ) : ↑(equivToUnitHom χ a) = χ a :=\n  coe_toUnitHom χ a\n\n"}
{"name":"MulChar.equivToUnitHom_symm_coe","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nf : MonoidHom (Units R) (Units R')\na : Units R\n⊢ Eq ((MulChar.equivToUnitHom.symm f) ↑a) ↑(f a)","decl":"@[simp]\ntheorem equivToUnitHom_symm_coe (f : Rˣ →* R'ˣ) (a : Rˣ) : equivToUnitHom.symm f ↑a = f a :=\n  ofUnitHom_coe f a\n\n"}
{"name":"MulChar.coe_toMonoidHom","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\nx : R\n⊢ Eq (χ.toMonoidHom x) (χ x)","decl":"@[simp]\nlemma coe_toMonoidHom (χ : MulChar R R')\n    (x : R) : χ.toMonoidHom x = χ x := rfl\n\n"}
{"name":"MulChar.map_one","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\n⊢ Eq (χ 1) 1","decl":"protected theorem map_one (χ : MulChar R R') : χ (1 : R) = 1 :=\n  χ.map_one'\n\n"}
{"name":"MulChar.map_zero","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R' : Type u_2\ninst✝² : CommMonoidWithZero R'\nR : Type u_3\ninst✝¹ : CommMonoidWithZero R\ninst✝ : Nontrivial R\nχ : MulChar R R'\n⊢ Eq (χ 0) 0","decl":"/-- If the domain has a zero (and is nontrivial), then `χ 0 = 0`. -/\nprotected theorem map_zero {R : Type*} [CommMonoidWithZero R] [Nontrivial R] (χ : MulChar R R') :\n    χ (0 : R) = 0 := by rw [map_nonunit χ not_isUnit_zero]\n\n"}
{"name":"MulChar.toMonoidWithZeroHom_apply","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R' : Type u_2\ninst✝² : CommMonoidWithZero R'\nR : Type u_3\ninst✝¹ : CommMonoidWithZero R\ninst✝ : Nontrivial R\nχ : MulChar R R'\na✝ : R\n⊢ Eq (↑χ a✝) ((↑χ.toMonoidHom).toFun a✝)","decl":"/-- We can convert a multiplicative character into a homomorphism of monoids with zero when\nthe source has a zero and another element. -/\n@[coe, simps]\ndef toMonoidWithZeroHom {R : Type*} [CommMonoidWithZero R] [Nontrivial R] (χ : MulChar R R') :\n    R →*₀ R' where\n  toFun := χ.toFun\n  map_zero' := χ.map_zero\n  map_one' := χ.map_one'\n  map_mul' := χ.map_mul'\n\n"}
{"name":"MulChar.map_ringChar","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R' : Type u_2\ninst✝² : CommMonoidWithZero R'\nR : Type u_3\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\nχ : MulChar R R'\n⊢ Eq (χ ↑(ringChar R)) 0","decl":"/-- If the domain is a ring `R`, then `χ (ringChar R) = 0`. -/\ntheorem map_ringChar {R : Type*} [CommRing R] [Nontrivial R] (χ : MulChar R R') :\n    χ (ringChar R) = 0 := by rw [ringChar.Nat.cast_ringChar, χ.map_zero]\n\n"}
{"name":"MulChar.one_apply_coe","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\na : Units R\n⊢ Eq (1 ↑a) 1","decl":"/-- Evaluation of the trivial character -/\n@[simp]\ntheorem one_apply_coe (a : Rˣ) : (1 : MulChar R R') a = 1 := by classical exact dif_pos a.isUnit\n\n"}
{"name":"MulChar.one_apply","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nx : R\nhx : IsUnit x\n⊢ Eq (1 x) 1","decl":"/-- Evaluation of the trivial character -/\nlemma one_apply {x : R} (hx : IsUnit x) : (1 : MulChar R R') x = 1 := one_apply_coe hx.unit\n\n"}
{"name":"MulChar.mul_apply","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ χ' : MulChar R R'\na : R\n⊢ Eq ((HMul.hMul χ χ') a) (HMul.hMul (χ a) (χ' a))","decl":"theorem mul_apply (χ χ' : MulChar R R') (a : R) : (χ * χ') a = χ a * χ' a :=\n  rfl\n\n"}
{"name":"MulChar.coeToFun_mul","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ χ' : MulChar R R'\n⊢ Eq (⇑(HMul.hMul χ χ')) (HMul.hMul ⇑χ ⇑χ')","decl":"@[simp]\ntheorem coeToFun_mul (χ χ' : MulChar R R') : ⇑(χ * χ') = χ * χ' :=\n  rfl\n\n"}
{"name":"MulChar.one_mul","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\n⊢ Eq (HMul.hMul 1 χ) χ","decl":"protected theorem one_mul (χ : MulChar R R') : (1 : MulChar R R') * χ = χ := by\n  ext\n  simp only [one_mul, Pi.mul_apply, MulChar.coeToFun_mul, MulChar.one_apply_coe]\n\n"}
{"name":"MulChar.mul_one","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\n⊢ Eq (HMul.hMul χ 1) χ","decl":"protected theorem mul_one (χ : MulChar R R') : χ * 1 = χ := by\n  ext\n  simp only [mul_one, Pi.mul_apply, MulChar.coeToFun_mul, MulChar.one_apply_coe]\n\n"}
{"name":"MulChar.inv_apply_eq_inv","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\na : R\n⊢ Eq ((Inv.inv χ) a) (Ring.inverse (χ a))","decl":"/-- The inverse of a multiplicative character `χ`, applied to `a`, is the inverse of `χ a`. -/\ntheorem inv_apply_eq_inv (χ : MulChar R R') (a : R) : χ⁻¹ a = Ring.inverse (χ a) :=\n  Eq.refl <| inv χ a\n\n"}
{"name":"MulChar.inv_apply_eq_inv'","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_3\ninst✝ : Field R'\nχ : MulChar R R'\na : R\n⊢ Eq ((Inv.inv χ) a) (Inv.inv (χ a))","decl":"/-- The inverse of a multiplicative character `χ`, applied to `a`, is the inverse of `χ a`.\nVariant when the target is a field -/\ntheorem inv_apply_eq_inv' {R' : Type*} [Field R'] (χ : MulChar R R') (a : R) : χ⁻¹ a = (χ a)⁻¹ :=\n  (inv_apply_eq_inv χ a).trans <| Ring.inverse_eq_inv (χ a)\n\n"}
{"name":"MulChar.inv_apply","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R' : Type u_2\ninst✝¹ : CommMonoidWithZero R'\nR : Type u_3\ninst✝ : CommMonoidWithZero R\nχ : MulChar R R'\na : R\n⊢ Eq ((Inv.inv χ) a) (χ (Ring.inverse a))","decl":"/-- When the domain has a zero, then the inverse of a multiplicative character `χ`,\napplied to `a`, is `χ` applied to the inverse of `a`. -/\ntheorem inv_apply {R : Type*} [CommMonoidWithZero R] (χ : MulChar R R') (a : R) :\n    χ⁻¹ a = χ (Ring.inverse a) := by\n  by_cases ha : IsUnit a\n  · rw [inv_apply_eq_inv]\n    have h := IsUnit.map χ ha\n    apply_fun (χ a * ·) using IsUnit.mul_right_injective h\n    dsimp only\n    rw [Ring.mul_inverse_cancel _ h, ← map_mul, Ring.mul_inverse_cancel _ ha, map_one]\n  · revert ha\n    nontriviality R\n    intro ha\n    -- `nontriviality R` by itself doesn't do it\n    rw [map_nonunit _ ha, Ring.inverse_non_unit a ha, MulChar.map_zero χ]\n\n"}
{"name":"MulChar.inv_apply'","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R' : Type u_2\ninst✝¹ : CommMonoidWithZero R'\nR : Type u_3\ninst✝ : Field R\nχ : MulChar R R'\na : R\n⊢ Eq ((Inv.inv χ) a) (χ (Inv.inv a))","decl":"/-- When the domain has a zero, then the inverse of a multiplicative character `χ`,\napplied to `a`, is `χ` applied to the inverse of `a`. -/\ntheorem inv_apply' {R : Type*} [Field R] (χ : MulChar R R') (a : R) : χ⁻¹ a = χ a⁻¹ :=\n  (inv_apply χ a).trans <| congr_arg _ (Ring.inverse_eq_inv a)\n\n"}
{"name":"MulChar.inv_mul","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\n⊢ Eq (HMul.hMul (Inv.inv χ) χ) 1","decl":"/-- The product of a character with its inverse is the trivial character. -/\ntheorem inv_mul (χ : MulChar R R') : χ⁻¹ * χ = 1 := by\n  ext x\n  rw [coeToFun_mul, Pi.mul_apply, inv_apply_eq_inv]\n  simp only [Ring.inverse_mul_cancel _ (IsUnit.map χ x.isUnit)]\n  rw [one_apply_coe]\n\n"}
{"name":"MulChar.pow_apply_coe","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\nn : Nat\na : Units R\n⊢ Eq ((HPow.hPow χ n) ↑a) (HPow.hPow (χ ↑a) n)","decl":"/-- If `a` is a unit and `n : ℕ`, then `(χ ^ n) a = (χ a) ^ n`. -/\ntheorem pow_apply_coe (χ : MulChar R R') (n : ℕ) (a : Rˣ) : (χ ^ n) a = χ a ^ n := by\n  induction' n with n ih\n  · rw [pow_zero, pow_zero, one_apply_coe]\n  · rw [pow_succ, pow_succ, mul_apply, ih]\n\n"}
{"name":"MulChar.pow_apply'","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\nn : Nat\nhn : Ne n 0\na : R\n⊢ Eq ((HPow.hPow χ n) a) (HPow.hPow (χ a) n)","decl":"/-- If `n` is positive, then `(χ ^ n) a = (χ a) ^ n`. -/\ntheorem pow_apply' (χ : MulChar R R') {n : ℕ} (hn : n ≠ 0) (a : R) : (χ ^ n) a = χ a ^ n := by\n  by_cases ha : IsUnit a\n  · exact pow_apply_coe χ n ha.unit\n  · rw [map_nonunit (χ ^ n) ha, map_nonunit χ ha, zero_pow hn]\n\n"}
{"name":"MulChar.equivToUnitHom_mul_apply","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ₁ χ₂ : MulChar R R'\na : Units R\n⊢ Eq ((MulChar.equivToUnitHom (HMul.hMul χ₁ χ₂)) a) (HMul.hMul ((MulChar.equivToUnitHom χ₁) a) ((MulChar.equivToUnitHom χ₂) a))","decl":"lemma equivToUnitHom_mul_apply (χ₁ χ₂ : MulChar R R') (a : Rˣ) :\n    equivToUnitHom (χ₁ * χ₂) a = equivToUnitHom χ₁ a * equivToUnitHom χ₂ a := by\n  apply_fun ((↑) : R'ˣ → R') using Units.ext\n  push_cast\n  simp_rw [coe_equivToUnitHom, coeToFun_mul, Pi.mul_apply]\n\n"}
{"name":"MulChar.eq_one_iff","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\n⊢ Iff (Eq χ 1) (∀ (a : Units R), Eq (χ ↑a) 1)","decl":"lemma eq_one_iff {χ : MulChar R R'} : χ = 1 ↔ ∀ a : Rˣ, χ a = 1 := by\n  simp only [MulChar.ext_iff, one_apply_coe]\n\n"}
{"name":"MulChar.ne_one_iff","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\n⊢ Iff (Ne χ 1) (Exists fun a => Ne (χ ↑a) 1)","decl":"lemma ne_one_iff {χ : MulChar R R'} : χ ≠ 1 ↔ ∃ a : Rˣ, χ a ≠ 1 := by\n  simp only [Ne, eq_one_iff, not_forall]\n\n"}
{"name":"MulChar.IsQuadratic.eq_of_eq_coe","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommMonoid R\nR' : Type u_2\ninst✝² : CommRing R'\nR'' : Type u_3\ninst✝¹ : CommRing R''\nχ : MulChar R Int\nhχ : χ.IsQuadratic\nχ' : MulChar R' Int\nhχ' : χ'.IsQuadratic\ninst✝ : Nontrivial R''\nhR'' : Ne (ringChar R'') 2\na : R\na' : R'\nh : Eq ↑(χ a) ↑(χ' a')\n⊢ Eq (χ a) (χ' a')","decl":"/-- If two values of quadratic characters with target `ℤ` agree after coercion into a ring\nof characteristic not `2`, then they agree in `ℤ`. -/\ntheorem IsQuadratic.eq_of_eq_coe {χ : MulChar R ℤ} (hχ : IsQuadratic χ) {χ' : MulChar R' ℤ}\n    (hχ' : IsQuadratic χ') [Nontrivial R''] (hR'' : ringChar R'' ≠ 2) {a : R} {a' : R'}\n    (h : (χ a : R'') = χ' a') : χ a = χ' a' :=\n  Int.cast_injOn_of_ringChar_ne_two hR'' (hχ a) (hχ' a') h\n\n"}
{"name":"MulChar.ringHomComp_apply","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝² : CommMonoid R\nR' : Type u_2\ninst✝¹ : CommRing R'\nR'' : Type u_3\ninst✝ : CommRing R''\nχ : MulChar R R'\nf : RingHom R' R''\na : R\n⊢ Eq ((χ.ringHomComp f) a) (f (χ a))","decl":"/-- We can post-compose a multiplicative character with a ring homomorphism. -/\n@[simps]\ndef ringHomComp (χ : MulChar R R') (f : R' →+* R'') : MulChar R R'' :=\n  { f.toMonoidHom.comp χ.toMonoidHom with\n    toFun := fun a => f (χ a)\n    map_nonunit' := fun a ha => by simp only [map_nonunit χ ha, map_zero] }\n\n"}
{"name":"MulChar.ringHomComp_one","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝² : CommMonoid R\nR' : Type u_2\ninst✝¹ : CommRing R'\nR'' : Type u_3\ninst✝ : CommRing R''\nf : RingHom R' R''\n⊢ Eq (MulChar.ringHomComp 1 f) 1","decl":"@[simp]\nlemma ringHomComp_one (f : R' →+* R'') : (1 : MulChar R R').ringHomComp f = 1 := by\n  ext1\n  simp only [MulChar.ringHomComp_apply, MulChar.one_apply_coe, map_one]\n\n"}
{"name":"MulChar.ringHomComp_inv","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R' : Type u_2\ninst✝² : CommRing R'\nR'' : Type u_3\ninst✝¹ : CommRing R''\nR : Type u_4\ninst✝ : CommRing R\nχ : MulChar R R'\nf : RingHom R' R''\n⊢ Eq (Inv.inv (χ.ringHomComp f)) ((Inv.inv χ).ringHomComp f)","decl":"lemma ringHomComp_inv {R : Type*} [CommRing R] (χ : MulChar R R') (f : R' →+* R'') :\n    (χ.ringHomComp f)⁻¹ = χ⁻¹.ringHomComp f := by\n  ext1\n  simp only [inv_apply, Ring.inverse_unit, ringHomComp_apply]\n\n"}
{"name":"MulChar.ringHomComp_mul","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝² : CommMonoid R\nR' : Type u_2\ninst✝¹ : CommRing R'\nR'' : Type u_3\ninst✝ : CommRing R''\nχ φ : MulChar R R'\nf : RingHom R' R''\n⊢ Eq ((HMul.hMul χ φ).ringHomComp f) (HMul.hMul (χ.ringHomComp f) (φ.ringHomComp f))","decl":"lemma ringHomComp_mul (χ φ : MulChar R R') (f : R' →+* R'') :\n    (χ * φ).ringHomComp f = χ.ringHomComp f * φ.ringHomComp f := by\n  ext1\n  simp only [ringHomComp_apply, coeToFun_mul, Pi.mul_apply, map_mul]\n\n"}
{"name":"MulChar.ringHomComp_pow","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝² : CommMonoid R\nR' : Type u_2\ninst✝¹ : CommRing R'\nR'' : Type u_3\ninst✝ : CommRing R''\nχ : MulChar R R'\nf : RingHom R' R''\nn : Nat\n⊢ Eq (HPow.hPow (χ.ringHomComp f) n) ((HPow.hPow χ n).ringHomComp f)","decl":"lemma ringHomComp_pow (χ : MulChar R R') (f : R' →+* R'') (n : ℕ) :\n    χ.ringHomComp f ^ n = (χ ^ n).ringHomComp f := by\n  induction n with\n  | zero => simp only [pow_zero, ringHomComp_one]\n  | succ n ih => simp only [pow_succ, ih, ringHomComp_mul]\n\n"}
{"name":"MulChar.injective_ringHomComp","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝² : CommMonoid R\nR' : Type u_2\ninst✝¹ : CommRing R'\nR'' : Type u_3\ninst✝ : CommRing R''\nf : RingHom R' R''\nhf : Function.Injective ⇑f\n⊢ Function.Injective fun x => x.ringHomComp f","decl":"lemma injective_ringHomComp {f : R' →+* R''} (hf : Function.Injective f) :\n    Function.Injective (ringHomComp (R := R) · f) := by\n  simpa\n    only [Function.Injective, MulChar.ext_iff, ringHomComp, coe_mk, MonoidHom.coe_mk, OneHom.coe_mk]\n    using fun χ χ' h a ↦ hf (h a)\n\n"}
{"name":"MulChar.ringHomComp_eq_one_iff","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝² : CommMonoid R\nR' : Type u_2\ninst✝¹ : CommRing R'\nR'' : Type u_3\ninst✝ : CommRing R''\nf : RingHom R' R''\nhf : Function.Injective ⇑f\nχ : MulChar R R'\n⊢ Iff (Eq (χ.ringHomComp f) 1) (Eq χ 1)","decl":"lemma ringHomComp_eq_one_iff {f : R' →+* R''} (hf : Function.Injective f) {χ : MulChar R R'} :\n    χ.ringHomComp f = 1 ↔ χ = 1 := by\n  conv_lhs => rw [← (show (1 : MulChar R R').ringHomComp f = 1 by ext; simp)]\n  exact (injective_ringHomComp hf).eq_iff\n\n"}
{"name":"MulChar.ringHomComp_ne_one_iff","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝² : CommMonoid R\nR' : Type u_2\ninst✝¹ : CommRing R'\nR'' : Type u_3\ninst✝ : CommRing R''\nf : RingHom R' R''\nhf : Function.Injective ⇑f\nχ : MulChar R R'\n⊢ Iff (Ne (χ.ringHomComp f) 1) (Ne χ 1)","decl":"lemma ringHomComp_ne_one_iff {f : R' →+* R''} (hf : Function.Injective f) {χ : MulChar R R'} :\n    χ.ringHomComp f ≠ 1 ↔ χ ≠ 1 :=\n  (ringHomComp_eq_one_iff hf).not\n\n"}
{"name":"MulChar.IsQuadratic.comp","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝² : CommMonoid R\nR' : Type u_2\ninst✝¹ : CommRing R'\nR'' : Type u_3\ninst✝ : CommRing R''\nχ : MulChar R R'\nhχ : χ.IsQuadratic\nf : RingHom R' R''\n⊢ (χ.ringHomComp f).IsQuadratic","decl":"/-- Composition with a ring homomorphism preserves the property of being a quadratic character. -/\ntheorem IsQuadratic.comp {χ : MulChar R R'} (hχ : χ.IsQuadratic) (f : R' →+* R'') :\n    (χ.ringHomComp f).IsQuadratic := by\n  intro a\n  rcases hχ a with (ha | ha | ha) <;> simp [ha]\n\n"}
{"name":"MulChar.IsQuadratic.inv","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommRing R'\nχ : MulChar R R'\nhχ : χ.IsQuadratic\n⊢ Eq (Inv.inv χ) χ","decl":"/-- The inverse of a quadratic character is itself. →  -/\ntheorem IsQuadratic.inv {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ⁻¹ = χ := by\n  ext x\n  rw [inv_apply_eq_inv]\n  rcases hχ x with (h₀ | h₁ | h₂)\n  · rw [h₀, Ring.inverse_zero]\n  · rw [h₁, Ring.inverse_one]\n  · -- Porting note: was `by norm_cast`\n    have : (-1 : R') = (-1 : R'ˣ) := by rw [Units.val_neg, Units.val_one]\n    rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]\n    rfl\n\n"}
{"name":"MulChar.IsQuadratic.sq_eq_one","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommRing R'\nχ : MulChar R R'\nhχ : χ.IsQuadratic\n⊢ Eq (HPow.hPow χ 2) 1","decl":"/-- The square of a quadratic character is the trivial character. -/\ntheorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by\n  rw [← inv_mul_cancel χ, pow_two, hχ.inv]\n\n"}
{"name":"MulChar.IsQuadratic.pow_char","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝² : CommMonoid R\nR' : Type u_2\ninst✝¹ : CommRing R'\nχ : MulChar R R'\nhχ : χ.IsQuadratic\np : Nat\nhp : Fact (Nat.Prime p)\ninst✝ : CharP R' p\n⊢ Eq (HPow.hPow χ p) χ","decl":"/-- The `p`th power of a quadratic character is itself, when `p` is the (prime) characteristic\nof the target ring. -/\ntheorem IsQuadratic.pow_char {χ : MulChar R R'} (hχ : χ.IsQuadratic) (p : ℕ) [hp : Fact p.Prime]\n    [CharP R' p] : χ ^ p = χ := by\n  ext x\n  rw [pow_apply_coe]\n  rcases hχ x with (hx | hx | hx) <;> rw [hx]\n  · rw [zero_pow (@Fact.out p.Prime).ne_zero]\n  · rw [one_pow]\n  · exact neg_one_pow_char R' p\n\n"}
{"name":"MulChar.IsQuadratic.pow_even","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommRing R'\nχ : MulChar R R'\nhχ : χ.IsQuadratic\nn : Nat\nhn : Even n\n⊢ Eq (HPow.hPow χ n) 1","decl":"/-- The `n`th power of a quadratic character is the trivial character, when `n` is even. -/\ntheorem IsQuadratic.pow_even {χ : MulChar R R'} (hχ : χ.IsQuadratic) {n : ℕ} (hn : Even n) :\n    χ ^ n = 1 := by\n  obtain ⟨n, rfl⟩ := even_iff_two_dvd.mp hn\n  rw [pow_mul, hχ.sq_eq_one, one_pow]\n\n"}
{"name":"MulChar.IsQuadratic.pow_odd","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\nR' : Type u_2\ninst✝ : CommRing R'\nχ : MulChar R R'\nhχ : χ.IsQuadratic\nn : Nat\nhn : Odd n\n⊢ Eq (HPow.hPow χ n) χ","decl":"/-- The `n`th power of a quadratic character is itself, when `n` is odd. -/\ntheorem IsQuadratic.pow_odd {χ : MulChar R R'} (hχ : χ.IsQuadratic) {n : ℕ} (hn : Odd n) :\n    χ ^ n = χ := by\n  obtain ⟨n, rfl⟩ := hn\n  rw [pow_add, pow_one, hχ.pow_even (even_two_mul _), one_mul]\n\n"}
{"name":"MulChar.isQuadratic_iff_sq_eq_one","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"M : Type u_4\nR : Type u_5\ninst✝³ : CommMonoid M\ninst✝² : CommRing R\ninst✝¹ : NoZeroDivisors R\ninst✝ : Nontrivial R\nχ : MulChar M R\n⊢ Iff χ.IsQuadratic (Eq (HPow.hPow χ 2) 1)","decl":"/-- A multiplicative character `χ` into an integral domain is quadratic\nif and only if `χ^2 = 1`. -/\nlemma isQuadratic_iff_sq_eq_one {M R : Type*} [CommMonoid M] [CommRing R] [NoZeroDivisors R]\n    [Nontrivial R] {χ : MulChar M R} :\n    IsQuadratic χ ↔ χ ^ 2 = 1:= by\n  refine ⟨fun h ↦ ext (fun x ↦ ?_), fun h x ↦ ?_⟩\n  · rw [one_apply_coe, χ.pow_apply_coe]\n    rcases h x with H | H | H\n    · exact (not_isUnit_zero <| H ▸ IsUnit.map χ <| x.isUnit).elim\n    · simp only [H, one_pow]\n    · simp only [H, even_two, Even.neg_pow, one_pow]\n  · by_cases hx : IsUnit x\n    · refine .inr <| sq_eq_one_iff.mp ?_\n      rw [← χ.pow_apply' two_ne_zero, h, MulChar.one_apply hx]\n    · exact .inl <| map_nonunit χ hx\n\n"}
{"name":"MulChar.pow_card_eq_one","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nR : Type u_2\ninst✝¹ : CommMonoidWithZero R\ninst✝ : Fintype (Units M)\nχ : MulChar M R\n⊢ Eq (HPow.hPow χ (Fintype.card (Units M))) 1","decl":"/-- If `χ` is a multiplicative character on a commutative monoid `M` with finitely many units,\nthen `χ ^ #Mˣ = 1`. -/\nprotected lemma pow_card_eq_one [Fintype Mˣ] (χ : MulChar M R) : χ ^ (Fintype.card Mˣ) = 1 := by\n  ext1\n  rw [pow_apply_coe, ← map_pow, one_apply_coe, ← Units.val_pow_eq_pow_val, pow_card_eq_one,\n    Units.val_eq_one.mpr rfl, map_one]\n\n"}
{"name":"MulChar.orderOf_pos","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nR : Type u_2\ninst✝¹ : CommMonoidWithZero R\ninst✝ : Finite (Units M)\nχ : MulChar M R\n⊢ LT.lt 0 (orderOf χ)","decl":"/-- A multiplicative character on a commutative monoid with finitely many units\nhas finite (= positive) order. -/\nlemma orderOf_pos [Finite Mˣ] (χ : MulChar M R) : 0 < orderOf χ := by\n  cases nonempty_fintype Mˣ\n  apply IsOfFinOrder.orderOf_pos\n  exact isOfFinOrder_iff_pow_eq_one.2 ⟨_, Fintype.card_pos, χ.pow_card_eq_one⟩\n\n"}
{"name":"MulChar.sum_eq_zero_of_ne_one","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommMonoid R\ninst✝² : Fintype R\nR' : Type u_2\ninst✝¹ : CommRing R'\ninst✝ : IsDomain R'\nχ : MulChar R R'\nhχ : Ne χ 1\n⊢ Eq (Finset.univ.sum fun a => χ a) 0","decl":"/-- The sum over all values of a nontrivial multiplicative character on a finite ring is zero\n(when the target is a domain). -/\ntheorem sum_eq_zero_of_ne_one [IsDomain R'] {χ : MulChar R R'} (hχ : χ ≠ 1) : ∑ a, χ a = 0 := by\n  rcases ne_one_iff.mp hχ with ⟨b, hb⟩\n  refine eq_zero_of_mul_eq_self_left hb ?_\n  simpa only [Finset.mul_sum, ← map_mul] using b.mulLeft_bijective.sum_comp _\n\n"}
{"name":"MulChar.sum_one_eq_card_units","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommMonoid R\ninst✝² : Fintype R\nR' : Type u_2\ninst✝¹ : CommRing R'\ninst✝ : DecidableEq R\n⊢ Eq (Finset.univ.sum fun a => 1 a) ↑(Fintype.card (Units R))","decl":"/-- The sum over all values of the trivial multiplicative character on a finite ring is\nthe cardinality of its unit group. -/\ntheorem sum_one_eq_card_units [DecidableEq R] :\n    (∑ a, (1 : MulChar R R') a) = Fintype.card Rˣ := by\n  calc\n    (∑ a, (1 : MulChar R R') a) = ∑ a : R, if IsUnit a then 1 else 0 :=\n      Finset.sum_congr rfl fun a _ => ?_\n    _ = ((Finset.univ : Finset R).filter IsUnit).card := Finset.sum_boole _ _\n    _ = (Finset.univ.map ⟨((↑) : Rˣ → R), Units.ext⟩).card := ?_\n    _ = Fintype.card Rˣ := congr_arg _ (Finset.card_map _)\n  · split_ifs with h\n    · exact one_apply_coe h.unit\n    · exact map_nonunit _ h\n  · congr\n    ext a\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and, Finset.mem_map,\n      Function.Embedding.coeFn_mk, exists_true_left, IsUnit]\n\n"}
{"name":"MulChar.val_neg_one_eq_one_of_odd_order","module":"Mathlib.NumberTheory.MulChar.Basic","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommMonoidWithZero R'\nχ : MulChar R R'\nn : Nat\nhn : Odd n\nhχ : Eq (HPow.hPow χ n) 1\n⊢ Eq (χ (-1)) 1","decl":"/-- If `χ` is of odd order, then `χ(-1) = 1` -/\nlemma val_neg_one_eq_one_of_odd_order {χ : MulChar R R'} {n : ℕ} (hn : Odd n) (hχ : χ ^ n = 1) :\n    χ (-1) = 1 := by\n  rw [← hn.neg_one_pow, map_pow, ← χ.pow_apply' (Nat.ne_of_odd_add hn), hχ]\n  exact MulChar.one_apply_coe (-1)\n\n"}
