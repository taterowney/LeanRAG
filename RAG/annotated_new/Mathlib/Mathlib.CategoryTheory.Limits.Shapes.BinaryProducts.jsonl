{"name":"CategoryTheory.Limits.WalkingPair.ofNat_toCtorIdx","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"x : CategoryTheory.Limits.WalkingPair\n‚ä¢ Eq (CategoryTheory.Limits.WalkingPair.ofNat x.toCtorIdx) x","decl":"/-- The type of objects for the diagram indexing a binary (co)product. -/\ninductive WalkingPair : Type\n  | left\n  | right\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.left.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"‚ä¢ Eq (SizeOf.sizeOf CategoryTheory.Limits.WalkingPair.left) 1","decl":"/-- The type of objects for the diagram indexing a binary (co)product. -/\ninductive WalkingPair : Type\n  | left\n  | right\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.right.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"‚ä¢ Eq (SizeOf.sizeOf CategoryTheory.Limits.WalkingPair.right) 1","decl":"/-- The type of objects for the diagram indexing a binary (co)product. -/\ninductive WalkingPair : Type\n  | left\n  | right\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.swap_apply_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.WalkingPair.swap CategoryTheory.Limits.WalkingPair.left) CategoryTheory.Limits.WalkingPair.right","decl":"@[simp]\ntheorem WalkingPair.swap_apply_left : WalkingPair.swap left = right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.swap_apply_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.WalkingPair.swap CategoryTheory.Limits.WalkingPair.right) CategoryTheory.Limits.WalkingPair.left","decl":"@[simp]\ntheorem WalkingPair.swap_apply_right : WalkingPair.swap right = left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.swap_symm_apply_tt","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.WalkingPair.swap.symm CategoryTheory.Limits.WalkingPair.left) CategoryTheory.Limits.WalkingPair.right","decl":"@[simp]\ntheorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.swap_symm_apply_ff","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.WalkingPair.swap.symm CategoryTheory.Limits.WalkingPair.right) CategoryTheory.Limits.WalkingPair.left","decl":"@[simp]\ntheorem WalkingPair.swap_symm_apply_ff : WalkingPair.swap.symm right = left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.equivBool_apply_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.WalkingPair.equivBool CategoryTheory.Limits.WalkingPair.left) Bool.true","decl":"@[simp]\ntheorem WalkingPair.equivBool_apply_left : WalkingPair.equivBool left = true :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.equivBool_apply_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.WalkingPair.equivBool CategoryTheory.Limits.WalkingPair.right) Bool.false","decl":"@[simp]\ntheorem WalkingPair.equivBool_apply_right : WalkingPair.equivBool right = false :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.equivBool_symm_apply_true","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.WalkingPair.equivBool.symm Bool.true) CategoryTheory.Limits.WalkingPair.left","decl":"@[simp]\ntheorem WalkingPair.equivBool_symm_apply_true : WalkingPair.equivBool.symm true = left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.equivBool_symm_apply_false","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.WalkingPair.equivBool.symm Bool.false) CategoryTheory.Limits.WalkingPair.right","decl":"@[simp]\ntheorem WalkingPair.equivBool_symm_apply_false : WalkingPair.equivBool.symm false = right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.pairFunction_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\nX Y : C\n‚ä¢ Eq (CategoryTheory.Limits.pairFunction X Y CategoryTheory.Limits.WalkingPair.left) X","decl":"@[simp]\ntheorem pairFunction_left (X Y : C) : pairFunction X Y left = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.pairFunction_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\nX Y : C\n‚ä¢ Eq (CategoryTheory.Limits.pairFunction X Y CategoryTheory.Limits.WalkingPair.right) Y","decl":"@[simp]\ntheorem pairFunction_right (X Y : C) : pairFunction X Y right = Y :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.pair_obj_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\n‚ä¢ Eq ((CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.left }) X","decl":"@[simp]\ntheorem pair_obj_left (X Y : C) : (pair X Y).obj ‚ü®left‚ü© = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.pair_obj_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\n‚ä¢ Eq ((CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.right }) Y","decl":"@[simp]\ntheorem pair_obj_right (X Y : C) : (pair X Y).obj ‚ü®right‚ü© = Y :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.mapPair_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nf : Quiver.Hom (F.obj { as := CategoryTheory.Limits.WalkingPair.left }) (G.obj { as := CategoryTheory.Limits.WalkingPair.left })\ng : Quiver.Hom (F.obj { as := CategoryTheory.Limits.WalkingPair.right }) (G.obj { as := CategoryTheory.Limits.WalkingPair.right })\n‚ä¢ Eq ((CategoryTheory.Limits.mapPair f g).app { as := CategoryTheory.Limits.WalkingPair.left }) f","decl":"@[simp]\ntheorem mapPair_left : (mapPair f g).app ‚ü®left‚ü© = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.mapPair_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nf : Quiver.Hom (F.obj { as := CategoryTheory.Limits.WalkingPair.left }) (G.obj { as := CategoryTheory.Limits.WalkingPair.left })\ng : Quiver.Hom (F.obj { as := CategoryTheory.Limits.WalkingPair.right }) (G.obj { as := CategoryTheory.Limits.WalkingPair.right })\n‚ä¢ Eq ((CategoryTheory.Limits.mapPair f g).app { as := CategoryTheory.Limits.WalkingPair.right }) g","decl":"@[simp]\ntheorem mapPair_right : (mapPair f g).app ‚ü®right‚ü© = g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.mapPairIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nf : CategoryTheory.Iso (F.obj { as := CategoryTheory.Limits.WalkingPair.left }) (G.obj { as := CategoryTheory.Limits.WalkingPair.left })\ng : CategoryTheory.Iso (F.obj { as := CategoryTheory.Limits.WalkingPair.right }) (G.obj { as := CategoryTheory.Limits.WalkingPair.right })\nX : CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair\n‚ä¢ Eq ((CategoryTheory.Limits.mapPairIso f g).inv.app X) (CategoryTheory.Limits.mapPair.match_1 (fun j => CategoryTheory.Iso (F.obj j) (G.obj j)) X (fun _ => f) fun _ => g).inv","decl":"/-- The natural isomorphism between two functors out of the walking pair, specified by its\ncomponents. -/\n@[simps!]\ndef mapPairIso (f : F.obj ‚ü®left‚ü© ‚âÖ G.obj ‚ü®left‚ü©) (g : F.obj ‚ü®right‚ü© ‚âÖ G.obj ‚ü®right‚ü©) : F ‚âÖ G :=\n  NatIso.ofComponents (fun j ‚Ü¶ match j with\n    | ‚ü®left‚ü© => f\n    | ‚ü®right‚ü© => g)\n    (fun ‚ü®‚ü®u‚ü©‚ü© => by aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.mapPairIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nf : CategoryTheory.Iso (F.obj { as := CategoryTheory.Limits.WalkingPair.left }) (G.obj { as := CategoryTheory.Limits.WalkingPair.left })\ng : CategoryTheory.Iso (F.obj { as := CategoryTheory.Limits.WalkingPair.right }) (G.obj { as := CategoryTheory.Limits.WalkingPair.right })\nX : CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair\n‚ä¢ Eq ((CategoryTheory.Limits.mapPairIso f g).hom.app X) (CategoryTheory.Limits.mapPair.match_1 (fun j => CategoryTheory.Iso (F.obj j) (G.obj j)) X (fun _ => f) fun _ => g).hom","decl":"/-- The natural isomorphism between two functors out of the walking pair, specified by its\ncomponents. -/\n@[simps!]\ndef mapPairIso (f : F.obj ‚ü®left‚ü© ‚âÖ G.obj ‚ü®left‚ü©) (g : F.obj ‚ü®right‚ü© ‚âÖ G.obj ‚ü®right‚ü©) : F ‚âÖ G :=\n  NatIso.ofComponents (fun j ‚Ü¶ match j with\n    | ‚ü®left‚ü© => f\n    | ‚ü®right‚ü© => g)\n    (fun ‚ü®‚ü®u‚ü©‚ü© => by aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.diagramIsoPair_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nX : CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair\n‚ä¢ Eq ((CategoryTheory.Limits.diagramIsoPair F).inv.app X) (CategoryTheory.Limits.mapPair.match_1 (fun j => CategoryTheory.Iso (F.obj j) ((CategoryTheory.Limits.pair (F.obj { as := CategoryTheory.Limits.WalkingPair.left }) (F.obj { as := CategoryTheory.Limits.WalkingPair.right })).obj j)) X (fun _ => CategoryTheory.Iso.refl (F.obj { as := CategoryTheory.Limits.WalkingPair.left })) fun _ => CategoryTheory.Iso.refl (F.obj { as := CategoryTheory.Limits.WalkingPair.right })).inv","decl":"/-- Every functor out of the walking pair is naturally isomorphic (actually, equal) to a `pair` -/\n@[simps!]\ndef diagramIsoPair (F : Discrete WalkingPair ‚•§ C) :\n    F ‚âÖ pair (F.obj ‚ü®WalkingPair.left‚ü©) (F.obj ‚ü®WalkingPair.right‚ü©) :=\n  mapPairIso (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.diagramIsoPair_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nX : CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair\n‚ä¢ Eq ((CategoryTheory.Limits.diagramIsoPair F).hom.app X) (CategoryTheory.Limits.mapPair.match_1 (fun j => CategoryTheory.Iso (F.obj j) ((CategoryTheory.Limits.pair (F.obj { as := CategoryTheory.Limits.WalkingPair.left }) (F.obj { as := CategoryTheory.Limits.WalkingPair.right })).obj j)) X (fun _ => CategoryTheory.Iso.refl (F.obj { as := CategoryTheory.Limits.WalkingPair.left })) fun _ => CategoryTheory.Iso.refl (F.obj { as := CategoryTheory.Limits.WalkingPair.right })).hom","decl":"/-- Every functor out of the walking pair is naturally isomorphic (actually, equal) to a `pair` -/\n@[simps!]\ndef diagramIsoPair (F : Discrete WalkingPair ‚•§ C) :\n    F ‚âÖ pair (F.obj ‚ü®WalkingPair.left‚ü©) (F.obj ‚ü®WalkingPair.right‚ü©) :=\n  mapPairIso (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.œÄ_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\ns : CategoryTheory.Limits.BinaryFan X Y\n‚ä¢ Eq (s.œÄ.app { as := CategoryTheory.Limits.WalkingPair.left }) s.fst","decl":"@[simp]\ntheorem BinaryFan.œÄ_app_left {X Y : C} (s : BinaryFan X Y) : s.œÄ.app ‚ü®WalkingPair.left‚ü© = s.fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.œÄ_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\ns : CategoryTheory.Limits.BinaryFan X Y\n‚ä¢ Eq (s.œÄ.app { as := CategoryTheory.Limits.WalkingPair.right }) s.snd","decl":"@[simp]\ntheorem BinaryFan.œÄ_app_right {X Y : C} (s : BinaryFan X Y) : s.œÄ.app ‚ü®WalkingPair.right‚ü© = s.snd :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.IsLimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Y : C\ns : CategoryTheory.Limits.BinaryFan X Y\nh : CategoryTheory.Limits.IsLimit s\nf g : Quiver.Hom W s.pt\nh‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f s.fst) (CategoryTheory.CategoryStruct.comp g s.fst)\nh‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp f s.snd) (CategoryTheory.CategoryStruct.comp g s.snd)\n‚ä¢ Eq f g","decl":"theorem BinaryFan.IsLimit.hom_ext {W X Y : C} {s : BinaryFan X Y} (h : IsLimit s) {f g : W ‚ü∂ s.pt}\n    (h‚ÇÅ : f ‚â´ s.fst = g ‚â´ s.fst) (h‚ÇÇ : f ‚â´ s.snd = g ‚â´ s.snd) : f = g :=\n  h.hom_ext fun j => Discrete.recOn j fun j => WalkingPair.casesOn j h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.Œπ_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\ns : CategoryTheory.Limits.BinaryCofan X Y\n‚ä¢ Eq (s.Œπ.app { as := CategoryTheory.Limits.WalkingPair.left }) s.inl","decl":"@[simp]\ntheorem BinaryCofan.Œπ_app_left {X Y : C} (s : BinaryCofan X Y) :\n    s.Œπ.app ‚ü®WalkingPair.left‚ü© = s.inl := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.Œπ_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\ns : CategoryTheory.Limits.BinaryCofan X Y\n‚ä¢ Eq (s.Œπ.app { as := CategoryTheory.Limits.WalkingPair.right }) s.inr","decl":"@[simp]\ntheorem BinaryCofan.Œπ_app_right {X Y : C} (s : BinaryCofan X Y) :\n    s.Œπ.app ‚ü®WalkingPair.right‚ü© = s.inr := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.IsColimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Y : C\ns : CategoryTheory.Limits.BinaryCofan X Y\nh : CategoryTheory.Limits.IsColimit s\nf g : Quiver.Hom s.pt W\nh‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp s.inl f) (CategoryTheory.CategoryStruct.comp s.inl g)\nh‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp s.inr f) (CategoryTheory.CategoryStruct.comp s.inr g)\n‚ä¢ Eq f g","decl":"theorem BinaryCofan.IsColimit.hom_ext {W X Y : C} {s : BinaryCofan X Y} (h : IsColimit s)\n    {f g : s.pt ‚ü∂ W} (h‚ÇÅ : s.inl ‚â´ f = s.inl ‚â´ g) (h‚ÇÇ : s.inr ‚â´ f = s.inr ‚â´ g) : f = g :=\n  h.hom_ext fun j => Discrete.recOn j fun j => WalkingPair.casesOn j h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.mk_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y P : C\nœÄ‚ÇÅ : Quiver.Hom P X\nœÄ‚ÇÇ : Quiver.Hom P Y\n‚ä¢ Eq (CategoryTheory.Limits.BinaryFan.mk œÄ‚ÇÅ œÄ‚ÇÇ).pt P","decl":"/-- A binary fan with vertex `P` consists of the two projections `œÄ‚ÇÅ : P ‚ü∂ X` and `œÄ‚ÇÇ : P ‚ü∂ Y`. -/\n@[simps pt]\ndef BinaryFan.mk {P : C} (œÄ‚ÇÅ : P ‚ü∂ X) (œÄ‚ÇÇ : P ‚ü∂ Y) : BinaryFan X Y where\n  pt := P\n  œÄ := { app := fun | { as := j } => match j with | left => œÄ‚ÇÅ | right => œÄ‚ÇÇ }\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.mk_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y P : C\nŒπ‚ÇÅ : Quiver.Hom X P\nŒπ‚ÇÇ : Quiver.Hom Y P\n‚ä¢ Eq (CategoryTheory.Limits.BinaryCofan.mk Œπ‚ÇÅ Œπ‚ÇÇ).pt P","decl":"/-- A binary cofan with vertex `P` consists of the two inclusions `Œπ‚ÇÅ : X ‚ü∂ P` and `Œπ‚ÇÇ : Y ‚ü∂ P`. -/\n@[simps pt]\ndef BinaryCofan.mk {P : C} (Œπ‚ÇÅ : X ‚ü∂ P) (Œπ‚ÇÇ : Y ‚ü∂ P) : BinaryCofan X Y where\n  pt := P\n  Œπ := { app := fun | { as := j } => match j with | left => Œπ‚ÇÅ | right => Œπ‚ÇÇ }\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.mk_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y P : C\nœÄ‚ÇÅ : Quiver.Hom P X\nœÄ‚ÇÇ : Quiver.Hom P Y\n‚ä¢ Eq (CategoryTheory.Limits.BinaryFan.mk œÄ‚ÇÅ œÄ‚ÇÇ).fst œÄ‚ÇÅ","decl":"@[simp]\ntheorem BinaryFan.mk_fst {P : C} (œÄ‚ÇÅ : P ‚ü∂ X) (œÄ‚ÇÇ : P ‚ü∂ Y) : (BinaryFan.mk œÄ‚ÇÅ œÄ‚ÇÇ).fst = œÄ‚ÇÅ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.mk_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y P : C\nœÄ‚ÇÅ : Quiver.Hom P X\nœÄ‚ÇÇ : Quiver.Hom P Y\n‚ä¢ Eq (CategoryTheory.Limits.BinaryFan.mk œÄ‚ÇÅ œÄ‚ÇÇ).snd œÄ‚ÇÇ","decl":"@[simp]\ntheorem BinaryFan.mk_snd {P : C} (œÄ‚ÇÅ : P ‚ü∂ X) (œÄ‚ÇÇ : P ‚ü∂ Y) : (BinaryFan.mk œÄ‚ÇÅ œÄ‚ÇÇ).snd = œÄ‚ÇÇ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.mk_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y P : C\nŒπ‚ÇÅ : Quiver.Hom X P\nŒπ‚ÇÇ : Quiver.Hom Y P\n‚ä¢ Eq (CategoryTheory.Limits.BinaryCofan.mk Œπ‚ÇÅ Œπ‚ÇÇ).inl Œπ‚ÇÅ","decl":"@[simp]\ntheorem BinaryCofan.mk_inl {P : C} (Œπ‚ÇÅ : X ‚ü∂ P) (Œπ‚ÇÇ : Y ‚ü∂ P) : (BinaryCofan.mk Œπ‚ÇÅ Œπ‚ÇÇ).inl = Œπ‚ÇÅ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.mk_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y P : C\nŒπ‚ÇÅ : Quiver.Hom X P\nŒπ‚ÇÇ : Quiver.Hom Y P\n‚ä¢ Eq (CategoryTheory.Limits.BinaryCofan.mk Œπ‚ÇÅ Œπ‚ÇÇ).inr Œπ‚ÇÇ","decl":"@[simp]\ntheorem BinaryCofan.mk_inr {P : C} (Œπ‚ÇÅ : X ‚ü∂ P) (Œπ‚ÇÇ : Y ‚ü∂ P) : (BinaryCofan.mk Œπ‚ÇÅ Œπ‚ÇÇ).inr = Œπ‚ÇÇ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.IsLimit.lift'_coe","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Y : C\ns : CategoryTheory.Limits.BinaryFan X Y\nh : CategoryTheory.Limits.IsLimit s\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\n‚ä¢ Eq (‚Üë(CategoryTheory.Limits.BinaryFan.IsLimit.lift' h f g)) (h.lift (CategoryTheory.Limits.BinaryFan.mk f g))","decl":"/-- If `s` is a limit binary fan over `X` and `Y`, then every pair of morphisms `f : W ‚ü∂ X` and\n    `g : W ‚ü∂ Y` induces a morphism `l : W ‚ü∂ s.pt` satisfying `l ‚â´ s.fst = f` and `l ‚â´ s.snd = g`.\n    -/\n@[simps]\ndef BinaryFan.IsLimit.lift' {W X Y : C} {s : BinaryFan X Y} (h : IsLimit s) (f : W ‚ü∂ X)\n    (g : W ‚ü∂ Y) : { l : W ‚ü∂ s.pt // l ‚â´ s.fst = f ‚àß l ‚â´ s.snd = g } :=\n  ‚ü®h.lift <| BinaryFan.mk f g, h.fac _ _, h.fac _ _‚ü©\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.IsColimit.desc'_coe","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Y : C\ns : CategoryTheory.Limits.BinaryCofan X Y\nh : CategoryTheory.Limits.IsColimit s\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\n‚ä¢ Eq (‚Üë(CategoryTheory.Limits.BinaryCofan.IsColimit.desc' h f g)) (h.desc (CategoryTheory.Limits.BinaryCofan.mk f g))","decl":"/-- If `s` is a colimit binary cofan over `X` and `Y`,, then every pair of morphisms `f : X ‚ü∂ W` and\n    `g : Y ‚ü∂ W` induces a morphism `l : s.pt ‚ü∂ W` satisfying `s.inl ‚â´ l = f` and `s.inr ‚â´ l = g`.\n    -/\n@[simps]\ndef BinaryCofan.IsColimit.desc' {W X Y : C} {s : BinaryCofan X Y} (h : IsColimit s) (f : X ‚ü∂ W)\n    (g : Y ‚ü∂ W) : { l : s.pt ‚ü∂ W // s.inl ‚â´ l = f ‚àß s.inr ‚â´ l = g } :=\n  ‚ü®h.desc <| BinaryCofan.mk f g, h.fac _ _, h.fac _ _‚ü©\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.isLimit_iff_isIso_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Limits.IsTerminal Y\nc : CategoryTheory.Limits.BinaryFan X Y\n‚ä¢ Iff (Nonempty (CategoryTheory.Limits.IsLimit c)) (CategoryTheory.IsIso c.fst)","decl":"theorem BinaryFan.isLimit_iff_isIso_fst {X Y : C} (h : IsTerminal Y) (c : BinaryFan X Y) :\n    Nonempty (IsLimit c) ‚Üî IsIso c.fst := by\n  constructor\n  ¬∑ rintro ‚ü®H‚ü©\n    obtain ‚ü®l, hl, -‚ü© := BinaryFan.IsLimit.lift' H (ùüô X) (h.from X)\n    exact\n      ‚ü®‚ü®l,\n          BinaryFan.IsLimit.hom_ext H (by simpa [hl, -Category.comp_id] using Category.comp_id _)\n            (h.hom_ext _ _),\n          hl‚ü©‚ü©\n  ¬∑ intro\n    exact\n      ‚ü®BinaryFan.IsLimit.mk _ (fun f _ => f ‚â´ inv c.fst) (fun _ _ => by simp)\n          (fun _ _ => h.hom_ext _ _) fun _ _ _ e _ => by simp [‚Üê e]‚ü©\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.isLimit_iff_isIso_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Limits.IsTerminal X\nc : CategoryTheory.Limits.BinaryFan X Y\n‚ä¢ Iff (Nonempty (CategoryTheory.Limits.IsLimit c)) (CategoryTheory.IsIso c.snd)","decl":"theorem BinaryFan.isLimit_iff_isIso_snd {X Y : C} (h : IsTerminal X) (c : BinaryFan X Y) :\n    Nonempty (IsLimit c) ‚Üî IsIso c.snd := by\n  refine Iff.trans ?_ (BinaryFan.isLimit_iff_isIso_fst h (BinaryFan.mk c.snd c.fst))\n  exact\n    ‚ü®fun h => ‚ü®BinaryFan.isLimitFlip h.some‚ü©, fun h =>\n      ‚ü®(BinaryFan.isLimitFlip h.some).ofIsoLimit (isoBinaryFanMk c).symm‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.isColimit_iff_isIso_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Limits.IsInitial Y\nc : CategoryTheory.Limits.BinaryCofan X Y\n‚ä¢ Iff (Nonempty (CategoryTheory.Limits.IsColimit c)) (CategoryTheory.IsIso c.inl)","decl":"theorem BinaryCofan.isColimit_iff_isIso_inl {X Y : C} (h : IsInitial Y) (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) ‚Üî IsIso c.inl := by\n  constructor\n  ¬∑ rintro ‚ü®H‚ü©\n    obtain ‚ü®l, hl, -‚ü© := BinaryCofan.IsColimit.desc' H (ùüô X) (h.to X)\n    refine ‚ü®‚ü®l, hl, BinaryCofan.IsColimit.hom_ext H (?_) (h.hom_ext _ _)‚ü©‚ü©\n    rw [Category.comp_id]\n    have e : (inl c ‚â´ l) ‚â´ inl c = ùüô X ‚â´ inl c := congrArg (¬∑‚â´inl c) hl\n    rwa [Category.assoc,Category.id_comp] at e\n  ¬∑ intro\n    exact\n      ‚ü®BinaryCofan.IsColimit.mk _ (fun f _ => inv c.inl ‚â´ f)\n          (fun _ _ => IsIso.hom_inv_id_assoc _ _) (fun _ _ => h.hom_ext _ _) fun _ _ _ e _ =>\n          (IsIso.eq_inv_comp _).mpr e‚ü©\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.isColimit_iff_isIso_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Limits.IsInitial X\nc : CategoryTheory.Limits.BinaryCofan X Y\n‚ä¢ Iff (Nonempty (CategoryTheory.Limits.IsColimit c)) (CategoryTheory.IsIso c.inr)","decl":"theorem BinaryCofan.isColimit_iff_isIso_inr {X Y : C} (h : IsInitial X) (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) ‚Üî IsIso c.inr := by\n  refine Iff.trans ?_ (BinaryCofan.isColimit_iff_isIso_inl h (BinaryCofan.mk c.inr c.inl))\n  exact\n    ‚ü®fun h => ‚ü®BinaryCofan.isColimitFlip h.some‚ü©, fun h =>\n      ‚ü®(BinaryCofan.isColimitFlip h.some).ofIsoColimit (isoBinaryCofanMk c).symm‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.prod.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct X Y\nf g : Quiver.Hom W (CategoryTheory.Limits.prod X Y)\nh‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.prod.fst)\nh‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.prod.snd) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.prod.snd)\n‚ä¢ Eq f g","decl":"@[ext 1100]\ntheorem prod.hom_ext {W X Y : C} [HasBinaryProduct X Y] {f g : W ‚ü∂ X ‚®Ø Y}\n    (h‚ÇÅ : f ‚â´ prod.fst = g ‚â´ prod.fst) (h‚ÇÇ : f ‚â´ prod.snd = g ‚â´ prod.snd) : f = g :=\n  BinaryFan.IsLimit.hom_ext (limit.isLimit _) h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"CategoryTheory.Limits.prod.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct X Y\nf g : Quiver.Hom W (CategoryTheory.Limits.prod X Y)\n‚ä¢ Iff (Eq f g) (And (Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.prod.fst)) (Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.prod.snd) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.prod.snd)))","decl":"@[ext 1100]\ntheorem prod.hom_ext {W X Y : C} [HasBinaryProduct X Y] {f g : W ‚ü∂ X ‚®Ø Y}\n    (h‚ÇÅ : f ‚â´ prod.fst = g ‚â´ prod.fst) (h‚ÇÇ : f ‚â´ prod.snd = g ‚â´ prod.snd) : f = g :=\n  BinaryFan.IsLimit.hom_ext (limit.isLimit _) h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"CategoryTheory.Limits.coprod.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf g : Quiver.Hom (CategoryTheory.Limits.coprod X Y) W\nh‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl g)\nh‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr g)\n‚ä¢ Eq f g","decl":"@[ext 1100]\ntheorem coprod.hom_ext {W X Y : C} [HasBinaryCoproduct X Y] {f g : X ‚®ø Y ‚ü∂ W}\n    (h‚ÇÅ : coprod.inl ‚â´ f = coprod.inl ‚â´ g) (h‚ÇÇ : coprod.inr ‚â´ f = coprod.inr ‚â´ g) : f = g :=\n  BinaryCofan.IsColimit.hom_ext (colimit.isColimit _) h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"CategoryTheory.Limits.coprod.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf g : Quiver.Hom (CategoryTheory.Limits.coprod X Y) W\n‚ä¢ Iff (Eq f g) (And (Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl g)) (Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr g)))","decl":"@[ext 1100]\ntheorem coprod.hom_ext {W X Y : C} [HasBinaryCoproduct X Y] {f g : X ‚®ø Y ‚ü∂ W}\n    (h‚ÇÅ : coprod.inl ‚â´ f = coprod.inl ‚â´ g) (h‚ÇÇ : coprod.inr ‚â´ f = coprod.inr ‚â´ g) : f = g :=\n  BinaryCofan.IsColimit.hom_ext (colimit.isColimit _) h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc]\ntheorem prod.lift_fst {W X Y : C} [HasBinaryProduct X Y] (f : W ‚ü∂ X) (g : W ‚ü∂ Y) :\n    prod.lift f g ‚â´ prod.fst = f :=\n  limit.lift_œÄ _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift f g) CategoryTheory.Limits.prod.fst) f","decl":"@[reassoc]\ntheorem prod.lift_fst {W X Y : C} [HasBinaryProduct X Y] (f : W ‚ü∂ X) (g : W ‚ü∂ Y) :\n    prod.lift f g ‚â´ prod.fst = f :=\n  limit.lift_œÄ _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc]\ntheorem prod.lift_snd {W X Y : C} [HasBinaryProduct X Y] (f : W ‚ü∂ X) (g : W ‚ü∂ Y) :\n    prod.lift f g ‚â´ prod.snd = g :=\n  limit.lift_œÄ _ _\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: it can also prove the og version\n"}
{"name":"CategoryTheory.Limits.prod.lift_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift f g) CategoryTheory.Limits.prod.snd) g","decl":"@[reassoc]\ntheorem prod.lift_snd {W X Y : C} [HasBinaryProduct X Y] (f : W ‚ü∂ X) (g : W ‚ü∂ Y) :\n    prod.lift f g ‚â´ prod.snd = g :=\n  limit.lift_œÄ _ _\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: it can also prove the og version\n"}
{"name":"CategoryTheory.Limits.coprod.inl_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.Limits.coprod.desc f g)) f","decl":"@[reassoc]\ntheorem coprod.inl_desc {W X Y : C} [HasBinaryCoproduct X Y] (f : X ‚ü∂ W) (g : Y ‚ü∂ W) :\n    coprod.inl ‚â´ coprod.desc f g = f :=\n  colimit.Œπ_desc _ _\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: it can also prove the og version\n"}
{"name":"CategoryTheory.Limits.coprod.inl_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\nZ : C\nh : Quiver.Hom W Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc f g) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc]\ntheorem coprod.inl_desc {W X Y : C} [HasBinaryCoproduct X Y] (f : X ‚ü∂ W) (g : Y ‚ü∂ W) :\n    coprod.inl ‚â´ coprod.desc f g = f :=\n  colimit.Œπ_desc _ _\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: it can also prove the og version\n"}
{"name":"CategoryTheory.Limits.coprod.inr_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\nZ : C\nh : Quiver.Hom W Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc f g) h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc]\ntheorem coprod.inr_desc {W X Y : C} [HasBinaryCoproduct X Y] (f : X ‚ü∂ W) (g : Y ‚ü∂ W) :\n    coprod.inr ‚â´ coprod.desc f g = g :=\n  colimit.Œπ_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.inr_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.Limits.coprod.desc f g)) g","decl":"@[reassoc]\ntheorem coprod.inr_desc {W X Y : C} [HasBinaryCoproduct X Y] (f : X ‚ü∂ W) (g : Y ‚ü∂ W) :\n    coprod.inr ‚â´ coprod.desc f g = g :=\n  colimit.Œπ_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.mono_lift_of_mono_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.prod.lift f g)","decl":"instance prod.mono_lift_of_mono_left {W X Y : C} [HasBinaryProduct X Y] (f : W ‚ü∂ X) (g : W ‚ü∂ Y)\n    [Mono f] : Mono (prod.lift f g) :=\n  mono_of_mono_fac <| prod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.mono_lift_of_mono_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst‚úù : CategoryTheory.Mono g\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.prod.lift f g)","decl":"instance prod.mono_lift_of_mono_right {W X Y : C} [HasBinaryProduct X Y] (f : W ‚ü∂ X) (g : W ‚ü∂ Y)\n    [Mono g] : Mono (prod.lift f g) :=\n  mono_of_mono_fac <| prod.lift_snd _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.epi_desc_of_epi_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.coprod.desc f g)","decl":"instance coprod.epi_desc_of_epi_left {W X Y : C} [HasBinaryCoproduct X Y] (f : X ‚ü∂ W) (g : Y ‚ü∂ W)\n    [Epi f] : Epi (coprod.desc f g) :=\n  epi_of_epi_fac <| coprod.inl_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.epi_desc_of_epi_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\ninst‚úù : CategoryTheory.Epi g\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.coprod.desc f g)","decl":"instance coprod.epi_desc_of_epi_right {W X Y : C} [HasBinaryCoproduct X Y] (f : X ‚ü∂ W) (g : Y ‚ü∂ W)\n    [Epi g] : Epi (coprod.desc f g) :=\n  epi_of_epi_fac <| coprod.inr_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.comp_lift_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nV W X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom V W\ng : Quiver.Hom W X\nh‚úù : Quiver.Hom W Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod X Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift g h‚úù) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h‚úù)) h)","decl":"@[reassoc, simp]\ntheorem prod.comp_lift {V W X Y : C} [HasBinaryProduct X Y] (f : V ‚ü∂ W) (g : W ‚ü∂ X) (h : W ‚ü∂ Y) :\n    f ‚â´ prod.lift g h = prod.lift (f ‚â´ g) (f ‚â´ h) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.comp_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nV W X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom V W\ng : Quiver.Hom W X\nh : Quiver.Hom W Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.prod.lift g h)) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc, simp]\ntheorem prod.comp_lift {V W X Y : C} [HasBinaryProduct X Y] (f : V ‚ü∂ W) (g : W ‚ü∂ X) (h : W ‚ü∂ Y) :\n    f ‚â´ prod.lift g h = prod.lift (f ‚â´ g) (f ‚â´ h) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.comp_diag","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Y\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.diag Y)) (CategoryTheory.Limits.prod.lift f f)","decl":"theorem prod.comp_diag {X Y : C} [HasBinaryProduct Y Y] (f : X ‚ü∂ Y) :\n    f ‚â´ diag Y = prod.lift f f := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.map_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst f)","decl":"@[reassoc (attr := simp)]\ntheorem prod.map_fst {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ‚ü∂ Y)\n    (g : X ‚ü∂ Z) : prod.map f g ‚â´ prod.fst = prod.fst ‚â´ f :=\n  limMap_œÄ _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.map_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z‚úù : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z‚úù\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z‚úù\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\ntheorem prod.map_fst {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ‚ü∂ Y)\n    (g : X ‚ü∂ Z) : prod.map f g ‚â´ prod.fst = prod.fst ‚â´ f :=\n  limMap_œÄ _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.map_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) CategoryTheory.Limits.prod.snd) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd g)","decl":"@[reassoc (attr := simp)]\ntheorem prod.map_snd {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ‚ü∂ Y)\n    (g : X ‚ü∂ Z) : prod.map f g ‚â´ prod.snd = prod.snd ‚â´ g :=\n  limMap_œÄ _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.map_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z‚úù : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z‚úù\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z‚úù\nZ : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc (attr := simp)]\ntheorem prod.map_snd {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ‚ü∂ Y)\n    (g : X ‚ü∂ Z) : prod.map f g ‚â´ prod.snd = prod.snd ‚â´ g :=\n  limMap_œÄ _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.map_id_id","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct X Y\n‚ä¢ Eq (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.prod X Y))","decl":"@[simp]\ntheorem prod.map_id_id {X Y : C} [HasBinaryProduct X Y] : prod.map (ùüô X) (ùüô Y) = ùüô _ := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_fst_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct X Y\n‚ä¢ Eq (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.prod X Y))","decl":"@[simp]\ntheorem prod.lift_fst_snd {X Y : C} [HasBinaryProduct X Y] :\n    prod.lift prod.fst prod.snd = ùüô (X ‚®Ø Y) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nV W X Y Z : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z\nf : Quiver.Hom V W\ng : Quiver.Hom V X\nh : Quiver.Hom W Y\nk : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift f g) (CategoryTheory.Limits.prod.map h k)) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k))","decl":"@[reassoc (attr := simp)]\ntheorem prod.lift_map {V W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : V ‚ü∂ W)\n    (g : V ‚ü∂ X) (h : W ‚ü∂ Y) (k : X ‚ü∂ Z) :\n    prod.lift f g ‚â´ prod.map h k = prod.lift (f ‚â´ h) (g ‚â´ k) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nV W X Y Z‚úù : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z‚úù\nf : Quiver.Hom V W\ng : Quiver.Hom V X\nh‚úù : Quiver.Hom W Y\nk : Quiver.Hom X Z‚úù\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map h‚úù k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp f h‚úù) (CategoryTheory.CategoryStruct.comp g k)) h)","decl":"@[reassoc (attr := simp)]\ntheorem prod.lift_map {V W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : V ‚ü∂ W)\n    (g : V ‚ü∂ X) (h : W ‚ü∂ Y) (k : X ‚ü∂ Z) :\n    prod.lift f g ‚â´ prod.map h k = prod.lift (f ‚â´ h) (g ‚â´ k) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_fst_comp_snd_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct W Y\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct X Z\ng : Quiver.Hom W X\ng' : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd g')) (CategoryTheory.Limits.prod.map g g')","decl":"@[simp]\ntheorem prod.lift_fst_comp_snd_comp {W X Y Z : C} [HasBinaryProduct W Y] [HasBinaryProduct X Z]\n    (g : W ‚ü∂ X) (g' : Y ‚ü∂ Z) : prod.lift (prod.fst ‚â´ g) (prod.snd ‚â´ g') = prod.map g g' := by\n  rw [‚Üê prod.lift_map]\n  simp\n\n-- We take the right hand side here to be simp normal form, as this way composition lemmas for\n-- `f ‚â´ h` and `g ‚â´ k` can fire (eg `id_comp`) , while `map_fst` and `map_snd` can still work just\n-- as well.\n"}
{"name":"CategoryTheory.Limits.prod.map_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nA‚ÇÅ A‚ÇÇ A‚ÇÉ B‚ÇÅ B‚ÇÇ B‚ÇÉ : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct A‚ÇÅ B‚ÇÅ\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct A‚ÇÇ B‚ÇÇ\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct A‚ÇÉ B‚ÇÉ\nf : Quiver.Hom A‚ÇÅ A‚ÇÇ\ng : Quiver.Hom B‚ÇÅ B‚ÇÇ\nh‚úù : Quiver.Hom A‚ÇÇ A‚ÇÉ\nk : Quiver.Hom B‚ÇÇ B‚ÇÉ\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod A‚ÇÉ B‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map h‚úù k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp f h‚úù) (CategoryTheory.CategoryStruct.comp g k)) h)","decl":"@[reassoc (attr := simp)]\ntheorem prod.map_map {A‚ÇÅ A‚ÇÇ A‚ÇÉ B‚ÇÅ B‚ÇÇ B‚ÇÉ : C} [HasBinaryProduct A‚ÇÅ B‚ÇÅ] [HasBinaryProduct A‚ÇÇ B‚ÇÇ]\n    [HasBinaryProduct A‚ÇÉ B‚ÇÉ] (f : A‚ÇÅ ‚ü∂ A‚ÇÇ) (g : B‚ÇÅ ‚ü∂ B‚ÇÇ) (h : A‚ÇÇ ‚ü∂ A‚ÇÉ) (k : B‚ÇÇ ‚ü∂ B‚ÇÉ) :\n    prod.map f g ‚â´ prod.map h k = prod.map (f ‚â´ h) (g ‚â´ k) := by ext <;> simp\n\n-- TODO: is it necessary to weaken the assumption here?\n"}
{"name":"CategoryTheory.Limits.prod.map_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nA‚ÇÅ A‚ÇÇ A‚ÇÉ B‚ÇÅ B‚ÇÇ B‚ÇÉ : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct A‚ÇÅ B‚ÇÅ\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct A‚ÇÇ B‚ÇÇ\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct A‚ÇÉ B‚ÇÉ\nf : Quiver.Hom A‚ÇÅ A‚ÇÇ\ng : Quiver.Hom B‚ÇÅ B‚ÇÇ\nh : Quiver.Hom A‚ÇÇ A‚ÇÉ\nk : Quiver.Hom B‚ÇÇ B‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) (CategoryTheory.Limits.prod.map h k)) (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k))","decl":"@[reassoc (attr := simp)]\ntheorem prod.map_map {A‚ÇÅ A‚ÇÇ A‚ÇÉ B‚ÇÅ B‚ÇÇ B‚ÇÉ : C} [HasBinaryProduct A‚ÇÅ B‚ÇÅ] [HasBinaryProduct A‚ÇÇ B‚ÇÇ]\n    [HasBinaryProduct A‚ÇÉ B‚ÇÉ] (f : A‚ÇÅ ‚ü∂ A‚ÇÇ) (g : B‚ÇÅ ‚ü∂ B‚ÇÇ) (h : A‚ÇÇ ‚ü∂ A‚ÇÉ) (k : B‚ÇÇ ‚ü∂ B‚ÇÉ) :\n    prod.map f g ‚â´ prod.map h k = prod.map (f ‚â´ h) (g ‚â´ k) := by ext <;> simp\n\n-- TODO: is it necessary to weaken the assumption here?\n"}
{"name":"CategoryTheory.Limits.prod.map_swap","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B X Y : C\nf : Quiver.Hom A B\ng : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) f) (CategoryTheory.Limits.prod.map g (CategoryTheory.CategoryStruct.id B))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map g (CategoryTheory.CategoryStruct.id A)) (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id Y) f))","decl":"@[reassoc]\ntheorem prod.map_swap {A B X Y : C} (f : A ‚ü∂ B) (g : X ‚ü∂ Y)\n    [HasLimitsOfShape (Discrete WalkingPair) C] :\n    prod.map (ùüô X) f ‚â´ prod.map g (ùüô B) = prod.map g (ùüô A) ‚â´ prod.map (ùüô Y) f := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.map_swap_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B X Y : C\nf : Quiver.Hom A B\ng : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y B) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map g (CategoryTheory.CategoryStruct.id B)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map g (CategoryTheory.CategoryStruct.id A)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id Y) f) h))","decl":"@[reassoc]\ntheorem prod.map_swap {A B X Y : C} (f : A ‚ü∂ B) (g : X ‚ü∂ Y)\n    [HasLimitsOfShape (Discrete WalkingPair) C] :\n    prod.map (ùüô X) f ‚â´ prod.map g (ùüô B) = prod.map g (ùüô A) ‚â´ prod.map (ùüô Y) f := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.map_comp_id_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z‚úù W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct X W\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct Z‚úù W\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y W\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Z‚úù W) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id W)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map g (CategoryTheory.CategoryStruct.id W)) h))","decl":"@[reassoc]\ntheorem prod.map_comp_id {X Y Z W : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasBinaryProduct X W]\n    [HasBinaryProduct Z W] [HasBinaryProduct Y W] :\n    prod.map (f ‚â´ g) (ùüô W) = prod.map f (ùüô W) ‚â´ prod.map g (ùüô W) := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.map_comp_id","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct X W\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct Z W\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y W\n‚ä¢ Eq (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.Limits.prod.map g (CategoryTheory.CategoryStruct.id W)))","decl":"@[reassoc]\ntheorem prod.map_comp_id {X Y Z W : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasBinaryProduct X W]\n    [HasBinaryProduct Z W] [HasBinaryProduct Y W] :\n    prod.map (f ‚â´ g) (ùüô W) = prod.map f (ùüô W) ‚â´ prod.map g (ùüô W) := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.map_id_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct W X\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct W Y\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct W Z\n‚ä¢ Eq (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) f) (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) g))","decl":"@[reassoc]\ntheorem prod.map_id_comp {X Y Z W : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasBinaryProduct W X]\n    [HasBinaryProduct W Y] [HasBinaryProduct W Z] :\n    prod.map (ùüô W) (f ‚â´ g) = prod.map (ùüô W) f ‚â´ prod.map (ùüô W) g := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.map_id_comp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z‚úù W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct W X\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct W Y\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct W Z‚úù\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod W Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) g) h))","decl":"@[reassoc]\ntheorem prod.map_id_comp {X Y Z W : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasBinaryProduct W X]\n    [HasBinaryProduct W Y] [HasBinaryProduct W Z] :\n    prod.map (ùüô W) (f ‚â´ g) = prod.map (ùüô W) f ‚â´ prod.map (ùüô W) g := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.mapIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z\nf : CategoryTheory.Iso W Y\ng : CategoryTheory.Iso X Z\n‚ä¢ Eq (CategoryTheory.Limits.prod.mapIso f g).inv (CategoryTheory.Limits.prod.map f.inv g.inv)","decl":"/-- If the products `W ‚®Ø X` and `Y ‚®Ø Z` exist, then every pair of isomorphisms `f : W ‚âÖ Y` and\n    `g : X ‚âÖ Z` induces an isomorphism `prod.mapIso f g : W ‚®Ø X ‚âÖ Y ‚®Ø Z`. -/\n@[simps]\ndef prod.mapIso {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ‚âÖ Y)\n    (g : X ‚âÖ Z) : W ‚®Ø X ‚âÖ Y ‚®Ø Z where\n  hom := prod.map f.hom g.hom\n  inv := prod.map f.inv g.inv\n\n"}
{"name":"CategoryTheory.Limits.prod.mapIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z\nf : CategoryTheory.Iso W Y\ng : CategoryTheory.Iso X Z\n‚ä¢ Eq (CategoryTheory.Limits.prod.mapIso f g).hom (CategoryTheory.Limits.prod.map f.hom g.hom)","decl":"/-- If the products `W ‚®Ø X` and `Y ‚®Ø Z` exist, then every pair of isomorphisms `f : W ‚âÖ Y` and\n    `g : X ‚âÖ Z` induces an isomorphism `prod.mapIso f g : W ‚®Ø X ‚âÖ Y ‚®Ø Z`. -/\n@[simps]\ndef prod.mapIso {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ‚âÖ Y)\n    (g : X ‚âÖ Z) : W ‚®Ø X ‚âÖ Y ‚®Ø Z where\n  hom := prod.map f.hom g.hom\n  inv := prod.map f.inv g.inv\n\n"}
{"name":"CategoryTheory.Limits.isIso_prod","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst‚úù¬≥ : CategoryTheory.Limits.HasBinaryProduct W X\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : CategoryTheory.IsIso g\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.prod.map f g)","decl":"instance isIso_prod {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ‚ü∂ Y)\n    (g : X ‚ü∂ Z) [IsIso f] [IsIso g] : IsIso (prod.map f g) :=\n  (prod.mapIso (asIso f) (asIso g)).isIso_hom\n\n"}
{"name":"CategoryTheory.Limits.prod.map_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst‚úù¬≥ : CategoryTheory.Mono f\ninst‚úù¬≤ : CategoryTheory.Mono g\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Z\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.prod.map f g)","decl":"instance prod.map_mono {C : Type*} [Category C] {W X Y Z : C} (f : W ‚ü∂ Y) (g : X ‚ü∂ Z) [Mono f]\n    [Mono g] [HasBinaryProduct W X] [HasBinaryProduct Y Z] : Mono (prod.map f g) :=\n  ‚ü®fun i‚ÇÅ i‚ÇÇ h => by\n    ext\n    ¬∑ rw [‚Üê cancel_mono f]\n      simpa using congr_arg (fun f => f ‚â´ prod.fst) h\n    ¬∑ rw [‚Üê cancel_mono g]\n      simpa using congr_arg (fun f => f ‚â´ prod.snd) h‚ü©\n\n"}
{"name":"CategoryTheory.Limits.prod.diag_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct X X\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f f) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag Y) h))","decl":"@[reassoc]\ntheorem prod.diag_map {X Y : C} (f : X ‚ü∂ Y) [HasBinaryProduct X X] [HasBinaryProduct Y Y] :\n    diag X ‚â´ prod.map f f = f ‚â´ diag Y := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.diag_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct X X\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Y Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag X) (CategoryTheory.Limits.prod.map f f)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.diag Y))","decl":"@[reassoc]\ntheorem prod.diag_map {X Y : C} (f : X ‚ü∂ Y) [HasBinaryProduct X X] [HasBinaryProduct Y Y] :\n    diag X ‚â´ prod.map f f = f ‚â´ diag Y := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.diag_map_fst_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct (CategoryTheory.Limits.prod X Y) (CategoryTheory.Limits.prod X Y)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag (CategoryTheory.Limits.prod X Y)) (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.prod X Y))","decl":"@[reassoc]\ntheorem prod.diag_map_fst_snd {X Y : C} [HasBinaryProduct X Y] [HasBinaryProduct (X ‚®Ø Y) (X ‚®Ø Y)] :\n    diag (X ‚®Ø Y) ‚â´ prod.map prod.fst prod.snd = ùüô (X ‚®Ø Y) := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.diag_map_fst_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct (CategoryTheory.Limits.prod X Y) (CategoryTheory.Limits.prod X Y)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod X Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag (CategoryTheory.Limits.prod X Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd) h)) h","decl":"@[reassoc]\ntheorem prod.diag_map_fst_snd {X Y : C} [HasBinaryProduct X Y] [HasBinaryProduct (X ‚®Ø Y) (X ‚®Ø Y)] :\n    diag (X ‚®Ø Y) ‚â´ prod.map prod.fst prod.snd = ùüô (X ‚®Ø Y) := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.diag_map_fst_snd_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nX X' Y Y' : C\ng : Quiver.Hom X Y\ng' : Quiver.Hom X' Y'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag (CategoryTheory.Limits.prod X X')) (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd g'))) (CategoryTheory.Limits.prod.map g g')","decl":"@[reassoc]\ntheorem prod.diag_map_fst_snd_comp [HasLimitsOfShape (Discrete WalkingPair) C] {X X' Y Y' : C}\n    (g : X ‚ü∂ Y) (g' : X' ‚ü∂ Y') :\n    diag (X ‚®Ø X') ‚â´ prod.map (prod.fst ‚â´ g) (prod.snd ‚â´ g') = prod.map g g' := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.diag_map_fst_snd_comp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nX X' Y Y' : C\ng : Quiver.Hom X Y\ng' : Quiver.Hom X' Y'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y Y') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag (CategoryTheory.Limits.prod X X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd g')) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map g g') h)","decl":"@[reassoc]\ntheorem prod.diag_map_fst_snd_comp [HasLimitsOfShape (Discrete WalkingPair) C] {X X' Y Y' : C}\n    (g : X ‚ü∂ Y) (g' : X' ‚ü∂ Y') :\n    diag (X ‚®Ø X') ‚â´ prod.map (prod.fst ‚â´ g) (prod.snd ‚â´ g') = prod.map g g' := by simp\n\n"}
{"name":"CategoryTheory.Limits.instIsSplitMonoDiag","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct X X\n‚ä¢ CategoryTheory.IsSplitMono (CategoryTheory.Limits.diag X)","decl":"instance {X : C} [HasBinaryProduct X X] : IsSplitMono (diag X) :=\n  IsSplitMono.mk' { retraction := prod.fst }\n\n"}
{"name":"CategoryTheory.Limits.coprod.desc_comp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nV W X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom V W\ng : Quiver.Hom X V\nh‚úù : Quiver.Hom Y V\nZ : C\nh : Quiver.Hom W Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc g h‚úù) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.comp h‚úù f)) h)","decl":"@[reassoc, simp]\ntheorem coprod.desc_comp {V W X Y : C} [HasBinaryCoproduct X Y] (f : V ‚ü∂ W) (g : X ‚ü∂ V)\n    (h : Y ‚ü∂ V) : coprod.desc g h ‚â´ f = coprod.desc (g ‚â´ f) (h ‚â´ f) := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.desc_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nV W X Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom V W\ng : Quiver.Hom X V\nh : Quiver.Hom Y V\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc g h) f) (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.comp h f))","decl":"@[reassoc, simp]\ntheorem coprod.desc_comp {V W X Y : C} [HasBinaryCoproduct X Y] (f : V ‚ü∂ W) (g : X ‚ü∂ V)\n    (h : Y ‚ü∂ V) : coprod.desc g h ‚â´ f = coprod.desc (g ‚â´ f) (h ‚â´ f) := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.diag_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X X\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.codiag X) f) (CategoryTheory.Limits.coprod.desc f f)","decl":"theorem coprod.diag_comp {X Y : C} [HasBinaryCoproduct X X] (f : X ‚ü∂ Y) :\n    codiag X ‚â´ f = coprod.desc f f := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.inl_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.Limits.coprod.map f g)) (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.coprod.inl)","decl":"@[reassoc (attr := simp)]\ntheorem coprod.inl_map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ‚ü∂ Y)\n    (g : X ‚ü∂ Z) : coprod.inl ‚â´ coprod.map f g = f ‚â´ coprod.inl :=\n  Œπ_colimMap _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.inl_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z‚úù : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct Y Z‚úù\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z‚úù\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod Y Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f g) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl h))","decl":"@[reassoc (attr := simp)]\ntheorem coprod.inl_map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ‚ü∂ Y)\n    (g : X ‚ü∂ Z) : coprod.inl ‚â´ coprod.map f g = f ‚â´ coprod.inl :=\n  Œπ_colimMap _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.inr_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z‚úù : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct Y Z‚úù\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z‚úù\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod Y Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f g) h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr h))","decl":"@[reassoc (attr := simp)]\ntheorem coprod.inr_map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ‚ü∂ Y)\n    (g : X ‚ü∂ Z) : coprod.inr ‚â´ coprod.map f g = g ‚â´ coprod.inr :=\n  Œπ_colimMap _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.inr_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.Limits.coprod.map f g)) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.coprod.inr)","decl":"@[reassoc (attr := simp)]\ntheorem coprod.inr_map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ‚ü∂ Y)\n    (g : X ‚ü∂ Z) : coprod.inr ‚â´ coprod.map f g = g ‚â´ coprod.inr :=\n  Œπ_colimMap _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_id_id","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X Y\n‚ä¢ Eq (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.coprod X Y))","decl":"@[simp]\ntheorem coprod.map_id_id {X Y : C} [HasBinaryCoproduct X Y] : coprod.map (ùüô X) (ùüô Y) = ùüô _ := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.desc_inl_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X Y\n‚ä¢ Eq (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inr) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.coprod X Y))","decl":"@[simp]\ntheorem coprod.desc_inl_inr {X Y : C} [HasBinaryCoproduct X Y] :\n    coprod.desc coprod.inl coprod.inr = ùüô (X ‚®ø Y) := by ext <;> simp\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n"}
{"name":"CategoryTheory.Limits.coprod.map_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nS T U V W : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct U W\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct T V\nf : Quiver.Hom U S\ng : Quiver.Hom W S\nh : Quiver.Hom T U\nk : Quiver.Hom V W\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map h k) (CategoryTheory.Limits.coprod.desc f g)) (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp k g))","decl":"@[reassoc, simp]\ntheorem coprod.map_desc {S T U V W : C} [HasBinaryCoproduct U W] [HasBinaryCoproduct T V]\n    (f : U ‚ü∂ S) (g : W ‚ü∂ S) (h : T ‚ü∂ U) (k : V ‚ü∂ W) :\n    coprod.map h k ‚â´ coprod.desc f g = coprod.desc (h ‚â´ f) (k ‚â´ g) := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nS T U V W : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct U W\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct T V\nf : Quiver.Hom U S\ng : Quiver.Hom W S\nh‚úù : Quiver.Hom T U\nk : Quiver.Hom V W\nZ : C\nh : Quiver.Hom S Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map h‚úù k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp h‚úù f) (CategoryTheory.CategoryStruct.comp k g)) h)","decl":"@[reassoc, simp]\ntheorem coprod.map_desc {S T U V W : C} [HasBinaryCoproduct U W] [HasBinaryCoproduct T V]\n    (f : U ‚ü∂ S) (g : W ‚ü∂ S) (h : T ‚ü∂ U) (k : V ‚ü∂ W) :\n    coprod.map h k ‚â´ coprod.desc f g = coprod.desc (h ‚â´ f) (k ‚â´ g) := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.desc_comp_inl_comp_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct W Y\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X Z\ng : Quiver.Hom W X\ng' : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.coprod.inl) (CategoryTheory.CategoryStruct.comp g' CategoryTheory.Limits.coprod.inr)) (CategoryTheory.Limits.coprod.map g g')","decl":"@[simp]\ntheorem coprod.desc_comp_inl_comp_inr {W X Y Z : C} [HasBinaryCoproduct W Y]\n    [HasBinaryCoproduct X Z] (g : W ‚ü∂ X) (g' : Y ‚ü∂ Z) :\n    coprod.desc (g ‚â´ coprod.inl) (g' ‚â´ coprod.inr) = coprod.map g g' := by\n  rw [‚Üê coprod.map_desc]; simp\n\n-- We take the right hand side here to be simp normal form, as this way composition lemmas for\n-- `f ‚â´ h` and `g ‚â´ k` can fire (eg `id_comp`) , while `inl_map` and `inr_map` can still work just\n-- as well.\n"}
{"name":"CategoryTheory.Limits.coprod.map_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nA‚ÇÅ A‚ÇÇ A‚ÇÉ B‚ÇÅ B‚ÇÇ B‚ÇÉ : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct A‚ÇÅ B‚ÇÅ\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct A‚ÇÇ B‚ÇÇ\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct A‚ÇÉ B‚ÇÉ\nf : Quiver.Hom A‚ÇÅ A‚ÇÇ\ng : Quiver.Hom B‚ÇÅ B‚ÇÇ\nh : Quiver.Hom A‚ÇÇ A‚ÇÉ\nk : Quiver.Hom B‚ÇÇ B‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f g) (CategoryTheory.Limits.coprod.map h k)) (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k))","decl":"@[reassoc (attr := simp)]\ntheorem coprod.map_map {A‚ÇÅ A‚ÇÇ A‚ÇÉ B‚ÇÅ B‚ÇÇ B‚ÇÉ : C} [HasBinaryCoproduct A‚ÇÅ B‚ÇÅ] [HasBinaryCoproduct A‚ÇÇ B‚ÇÇ]\n    [HasBinaryCoproduct A‚ÇÉ B‚ÇÉ] (f : A‚ÇÅ ‚ü∂ A‚ÇÇ) (g : B‚ÇÅ ‚ü∂ B‚ÇÇ) (h : A‚ÇÇ ‚ü∂ A‚ÇÉ) (k : B‚ÇÇ ‚ü∂ B‚ÇÉ) :\n    coprod.map f g ‚â´ coprod.map h k = coprod.map (f ‚â´ h) (g ‚â´ k) := by\n  ext <;> simp\n\n-- I don't think it's a good idea to make any of the following three simp lemmas.\n"}
{"name":"CategoryTheory.Limits.coprod.map_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nA‚ÇÅ A‚ÇÇ A‚ÇÉ B‚ÇÅ B‚ÇÇ B‚ÇÉ : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct A‚ÇÅ B‚ÇÅ\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct A‚ÇÇ B‚ÇÇ\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct A‚ÇÉ B‚ÇÉ\nf : Quiver.Hom A‚ÇÅ A‚ÇÇ\ng : Quiver.Hom B‚ÇÅ B‚ÇÇ\nh‚úù : Quiver.Hom A‚ÇÇ A‚ÇÉ\nk : Quiver.Hom B‚ÇÇ B‚ÇÉ\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod A‚ÇÉ B‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map h‚úù k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.comp f h‚úù) (CategoryTheory.CategoryStruct.comp g k)) h)","decl":"@[reassoc (attr := simp)]\ntheorem coprod.map_map {A‚ÇÅ A‚ÇÇ A‚ÇÉ B‚ÇÅ B‚ÇÇ B‚ÇÉ : C} [HasBinaryCoproduct A‚ÇÅ B‚ÇÅ] [HasBinaryCoproduct A‚ÇÇ B‚ÇÇ]\n    [HasBinaryCoproduct A‚ÇÉ B‚ÇÉ] (f : A‚ÇÅ ‚ü∂ A‚ÇÇ) (g : B‚ÇÅ ‚ü∂ B‚ÇÇ) (h : A‚ÇÇ ‚ü∂ A‚ÇÉ) (k : B‚ÇÇ ‚ü∂ B‚ÇÉ) :\n    coprod.map f g ‚â´ coprod.map h k = coprod.map (f ‚â´ h) (g ‚â´ k) := by\n  ext <;> simp\n\n-- I don't think it's a good idea to make any of the following three simp lemmas.\n"}
{"name":"CategoryTheory.Limits.coprod.map_swap_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B X Y : C\nf : Quiver.Hom A B\ng : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod Y B) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id X) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map g (CategoryTheory.CategoryStruct.id B)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map g (CategoryTheory.CategoryStruct.id A)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id Y) f) h))","decl":"@[reassoc]\ntheorem coprod.map_swap {A B X Y : C} (f : A ‚ü∂ B) (g : X ‚ü∂ Y)\n    [HasColimitsOfShape (Discrete WalkingPair) C] :\n    coprod.map (ùüô X) f ‚â´ coprod.map g (ùüô B) = coprod.map g (ùüô A) ‚â´ coprod.map (ùüô Y) f := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_swap","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B X Y : C\nf : Quiver.Hom A B\ng : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id X) f) (CategoryTheory.Limits.coprod.map g (CategoryTheory.CategoryStruct.id B))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map g (CategoryTheory.CategoryStruct.id A)) (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id Y) f))","decl":"@[reassoc]\ntheorem coprod.map_swap {A B X Y : C} (f : A ‚ü∂ B) (g : X ‚ü∂ Y)\n    [HasColimitsOfShape (Discrete WalkingPair) C] :\n    coprod.map (ùüô X) f ‚â´ coprod.map g (ùüô B) = coprod.map g (ùüô A) ‚â´ coprod.map (ùüô Y) f := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_comp_id_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z‚úù W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct Z‚úù W\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct Y W\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X W\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod Z‚úù W) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id W)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map g (CategoryTheory.CategoryStruct.id W)) h))","decl":"@[reassoc]\ntheorem coprod.map_comp_id {X Y Z W : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasBinaryCoproduct Z W]\n    [HasBinaryCoproduct Y W] [HasBinaryCoproduct X W] :\n    coprod.map (f ‚â´ g) (ùüô W) = coprod.map f (ùüô W) ‚â´ coprod.map g (ùüô W) := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_comp_id","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct Z W\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct Y W\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct X W\n‚ä¢ Eq (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.Limits.coprod.map g (CategoryTheory.CategoryStruct.id W)))","decl":"@[reassoc]\ntheorem coprod.map_comp_id {X Y Z W : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasBinaryCoproduct Z W]\n    [HasBinaryCoproduct Y W] [HasBinaryCoproduct X W] :\n    coprod.map (f ‚â´ g) (ùüô W) = coprod.map f (ùüô W) ‚â´ coprod.map g (ùüô W) := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_id_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct W Y\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct W Z\n‚ä¢ Eq (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) f) (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) g))","decl":"@[reassoc]\ntheorem coprod.map_id_comp {X Y Z W : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasBinaryCoproduct W X]\n    [HasBinaryCoproduct W Y] [HasBinaryCoproduct W Z] :\n    coprod.map (ùüô W) (f ‚â´ g) = coprod.map (ùüô W) f ‚â´ coprod.map (ùüô W) g := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_id_comp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y Z‚úù W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct W Y\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct W Z‚úù\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod W Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) g) h))","decl":"@[reassoc]\ntheorem coprod.map_id_comp {X Y Z W : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasBinaryCoproduct W X]\n    [HasBinaryCoproduct W Y] [HasBinaryCoproduct W Z] :\n    coprod.map (ùüô W) (f ‚â´ g) = coprod.map (ùüô W) f ‚â´ coprod.map (ùüô W) g := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.mapIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct Y Z\nf : CategoryTheory.Iso W Y\ng : CategoryTheory.Iso X Z\n‚ä¢ Eq (CategoryTheory.Limits.coprod.mapIso f g).hom (CategoryTheory.Limits.coprod.map f.hom g.hom)","decl":"/-- If the coproducts `W ‚®ø X` and `Y ‚®ø Z` exist, then every pair of isomorphisms `f : W ‚âÖ Y` and\n   `g : W ‚âÖ Z` induces an isomorphism `coprod.mapIso f g : W ‚®ø X ‚âÖ Y ‚®ø Z`. -/\n@[simps]\ndef coprod.mapIso {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ‚âÖ Y)\n    (g : X ‚âÖ Z) : W ‚®ø X ‚âÖ Y ‚®ø Z where\n  hom := coprod.map f.hom g.hom\n  inv := coprod.map f.inv g.inv\n\n"}
{"name":"CategoryTheory.Limits.coprod.mapIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct Y Z\nf : CategoryTheory.Iso W Y\ng : CategoryTheory.Iso X Z\n‚ä¢ Eq (CategoryTheory.Limits.coprod.mapIso f g).inv (CategoryTheory.Limits.coprod.map f.inv g.inv)","decl":"/-- If the coproducts `W ‚®ø X` and `Y ‚®ø Z` exist, then every pair of isomorphisms `f : W ‚âÖ Y` and\n   `g : W ‚âÖ Z` induces an isomorphism `coprod.mapIso f g : W ‚®ø X ‚âÖ Y ‚®ø Z`. -/\n@[simps]\ndef coprod.mapIso {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ‚âÖ Y)\n    (g : X ‚âÖ Z) : W ‚®ø X ‚âÖ Y ‚®ø Z where\n  hom := coprod.map f.hom g.hom\n  inv := coprod.map f.inv g.inv\n\n"}
{"name":"CategoryTheory.Limits.isIso_coprod","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst‚úù¬≥ : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : CategoryTheory.IsIso g\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.coprod.map f g)","decl":"instance isIso_coprod {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ‚ü∂ Y)\n    (g : X ‚ü∂ Z) [IsIso f] [IsIso g] : IsIso (coprod.map f g) :=\n  (coprod.mapIso (asIso f) (asIso g)).isIso_hom\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst‚úù¬≥ : CategoryTheory.Epi f\ninst‚úù¬≤ : CategoryTheory.Epi g\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct Y Z\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.coprod.map f g)","decl":"instance coprod.map_epi {C : Type*} [Category C] {W X Y Z : C} (f : W ‚ü∂ Y) (g : X ‚ü∂ Z) [Epi f]\n    [Epi g] [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] : Epi (coprod.map f g) :=\n  ‚ü®fun i‚ÇÅ i‚ÇÇ h => by\n    ext\n    ¬∑ rw [‚Üê cancel_epi f]\n      simpa using congr_arg (fun f => coprod.inl ‚â´ f) h\n    ¬∑ rw [‚Üê cancel_epi g]\n      simpa using congr_arg (fun f => coprod.inr ‚â´ f) h‚ü©\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: and the og version too\n"}
{"name":"CategoryTheory.Limits.coprod.map_codiag_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct X X\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct Y Y\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.codiag Y) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.codiag X) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc]\ntheorem coprod.map_codiag {X Y : C} (f : X ‚ü∂ Y) [HasBinaryCoproduct X X] [HasBinaryCoproduct Y Y] :\n    coprod.map f f ‚â´ codiag Y = codiag X ‚â´ f := by simp\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: and the og version too\n"}
{"name":"CategoryTheory.Limits.coprod.map_codiag","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct X X\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct Y Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f f) (CategoryTheory.Limits.codiag Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.codiag X) f)","decl":"@[reassoc]\ntheorem coprod.map_codiag {X Y : C} (f : X ‚ü∂ Y) [HasBinaryCoproduct X X] [HasBinaryCoproduct Y Y] :\n    coprod.map f f ‚â´ codiag Y = codiag X ‚â´ f := by simp\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: and the og version too\n"}
{"name":"CategoryTheory.Limits.coprod.map_inl_inr_codiag","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct (CategoryTheory.Limits.coprod X Y) (CategoryTheory.Limits.coprod X Y)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inr) (CategoryTheory.Limits.codiag (CategoryTheory.Limits.coprod X Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.coprod X Y))","decl":"@[reassoc]\ntheorem coprod.map_inl_inr_codiag {X Y : C} [HasBinaryCoproduct X Y]\n    [HasBinaryCoproduct (X ‚®ø Y) (X ‚®ø Y)] :\n    coprod.map coprod.inl coprod.inr ‚â´ codiag (X ‚®ø Y) = ùüô (X ‚®ø Y) := by simp\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: and the og version too\n"}
{"name":"CategoryTheory.Limits.coprod.map_inl_inr_codiag_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct (CategoryTheory.Limits.coprod X Y) (CategoryTheory.Limits.coprod X Y)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod X Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inr) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.codiag (CategoryTheory.Limits.coprod X Y)) h)) h","decl":"@[reassoc]\ntheorem coprod.map_inl_inr_codiag {X Y : C} [HasBinaryCoproduct X Y]\n    [HasBinaryCoproduct (X ‚®ø Y) (X ‚®ø Y)] :\n    coprod.map coprod.inl coprod.inr ‚â´ codiag (X ‚®ø Y) = ùüô (X ‚®ø Y) := by simp\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: and the og version too\n"}
{"name":"CategoryTheory.Limits.coprod.map_comp_inl_inr_codiag","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nX X' Y Y' : C\ng : Quiver.Hom X Y\ng' : Quiver.Hom X' Y'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.coprod.inl) (CategoryTheory.CategoryStruct.comp g' CategoryTheory.Limits.coprod.inr)) (CategoryTheory.Limits.codiag (CategoryTheory.Limits.coprod Y Y'))) (CategoryTheory.Limits.coprod.map g g')","decl":"@[reassoc]\ntheorem coprod.map_comp_inl_inr_codiag [HasColimitsOfShape (Discrete WalkingPair) C] {X X' Y Y' : C}\n    (g : X ‚ü∂ Y) (g' : X' ‚ü∂ Y') :\n    coprod.map (g ‚â´ coprod.inl) (g' ‚â´ coprod.inr) ‚â´ codiag (Y ‚®ø Y') = coprod.map g g' := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_comp_inl_inr_codiag_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nX X' Y Y' : C\ng : Quiver.Hom X Y\ng' : Quiver.Hom X' Y'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod Y Y') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.coprod.inl) (CategoryTheory.CategoryStruct.comp g' CategoryTheory.Limits.coprod.inr)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.codiag (CategoryTheory.Limits.coprod Y Y')) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map g g') h)","decl":"@[reassoc]\ntheorem coprod.map_comp_inl_inr_codiag [HasColimitsOfShape (Discrete WalkingPair) C] {X X' Y Y' : C}\n    (g : X ‚ü∂ Y) (g' : X' ‚ü∂ Y') :\n    coprod.map (g ‚â´ coprod.inl) (g' ‚â´ coprod.inr) ‚â´ codiag (Y ‚®ø Y') = coprod.map g g' := by simp\n\n"}
{"name":"CategoryTheory.Limits.hasBinaryProducts_of_hasLimit_pair","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : ‚àÄ {X Y : C}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)\n‚ä¢ CategoryTheory.Limits.HasBinaryProducts C","decl":"/-- If `C` has all limits of diagrams `pair X Y`, then it has all binary products -/\ntheorem hasBinaryProducts_of_hasLimit_pair [‚àÄ {X Y : C}, HasLimit (pair X Y)] :\n    HasBinaryProducts C :=\n  { has_limit := fun F => hasLimitOfIso (diagramIsoPair F).symm }\n\n"}
{"name":"CategoryTheory.Limits.hasBinaryCoproducts_of_hasColimit_pair","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : ‚àÄ {X Y : C}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)\n‚ä¢ CategoryTheory.Limits.HasBinaryCoproducts C","decl":"/-- If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts -/\ntheorem hasBinaryCoproducts_of_hasColimit_pair [‚àÄ {X Y : C}, HasColimit (pair X Y)] :\n    HasBinaryCoproducts C :=\n  { has_colimit := fun F => hasColimitOfIso (diagramIsoPair F) }\n\n"}
{"name":"CategoryTheory.Limits.prod.braiding_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP Q : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct P Q\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Q P\n‚ä¢ Eq (CategoryTheory.Limits.prod.braiding P Q).inv (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)","decl":"/-- The braiding isomorphism which swaps a binary product. -/\n@[simps]\ndef prod.braiding (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] : P ‚®Ø Q ‚âÖ Q ‚®Ø P where\n  hom := prod.lift prod.snd prod.fst\n  inv := prod.lift prod.snd prod.fst\n\n"}
{"name":"CategoryTheory.Limits.prod.braiding_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP Q : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct P Q\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Q P\n‚ä¢ Eq (CategoryTheory.Limits.prod.braiding P Q).hom (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)","decl":"/-- The braiding isomorphism which swaps a binary product. -/\n@[simps]\ndef prod.braiding (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] : P ‚®Ø Q ‚âÖ Q ‚®Ø P where\n  hom := prod.lift prod.snd prod.fst\n  inv := prod.lift prod.snd prod.fst\n\n"}
{"name":"CategoryTheory.Limits.braid_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nW X Y Z‚úù : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z‚úù W\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod W Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.braiding Y W).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.braiding X Z‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map g f) h))","decl":"/-- The braiding isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem braid_natural [HasBinaryProducts C] {W X Y Z : C} (f : X ‚ü∂ Y) (g : Z ‚ü∂ W) :\n    prod.map f g ‚â´ (prod.braiding _ _).hom = (prod.braiding _ _).hom ‚â´ prod.map g f := by simp\n\n"}
{"name":"CategoryTheory.Limits.braid_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) (CategoryTheory.Limits.prod.braiding Y W).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.braiding X Z).hom (CategoryTheory.Limits.prod.map g f))","decl":"/-- The braiding isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem braid_natural [HasBinaryProducts C] {W X Y Z : C} (f : X ‚ü∂ Y) (g : Z ‚ü∂ W) :\n    prod.map f g ‚â´ (prod.braiding _ _).hom = (prod.braiding _ _).hom ‚â´ prod.map g f := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.symmetry'","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP Q : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct P Q\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Q P\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst) (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.prod P Q))","decl":"@[reassoc]\ntheorem prod.symmetry' (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] :\n    prod.lift prod.snd prod.fst ‚â´ prod.lift prod.snd prod.fst = ùüô (P ‚®Ø Q) :=\n  (prod.braiding _ _).hom_inv_id\n\n"}
{"name":"CategoryTheory.Limits.prod.symmetry'_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP Q : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct P Q\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Q P\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod P Q) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst) h)) h","decl":"@[reassoc]\ntheorem prod.symmetry' (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] :\n    prod.lift prod.snd prod.fst ‚â´ prod.lift prod.snd prod.fst = ùüô (P ‚®Ø Q) :=\n  (prod.braiding _ _).hom_inv_id\n\n"}
{"name":"CategoryTheory.Limits.prod.symmetry_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP Q : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct P Q\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Q P\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod P Q) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.braiding P Q).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.braiding Q P).hom h)) h","decl":"/-- The braiding isomorphism is symmetric. -/\n@[reassoc]\ntheorem prod.symmetry (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] :\n    (prod.braiding P Q).hom ‚â´ (prod.braiding Q P).hom = ùüô _ :=\n  (prod.braiding _ _).hom_inv_id\n\n"}
{"name":"CategoryTheory.Limits.prod.symmetry","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP Q : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct P Q\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct Q P\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.braiding P Q).hom (CategoryTheory.Limits.prod.braiding Q P).hom) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.prod P Q))","decl":"/-- The braiding isomorphism is symmetric. -/\n@[reassoc]\ntheorem prod.symmetry (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] :\n    (prod.braiding P Q).hom ‚â´ (prod.braiding Q P).hom = ùüô _ :=\n  (prod.braiding _ _).hom_inv_id\n\n"}
{"name":"CategoryTheory.Limits.prod.associator_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nP Q R : C\n‚ä¢ Eq (CategoryTheory.Limits.prod.associator P Q R).hom (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd) CategoryTheory.Limits.prod.snd))","decl":"/-- The associator isomorphism for binary products. -/\n@[simps]\ndef prod.associator [HasBinaryProducts C] (P Q R : C) : (P ‚®Ø Q) ‚®Ø R ‚âÖ P ‚®Ø Q ‚®Ø R where\n  hom := prod.lift (prod.fst ‚â´ prod.fst) (prod.lift (prod.fst ‚â´ prod.snd) prod.snd)\n  inv := prod.lift (prod.lift prod.fst (prod.snd ‚â´ prod.fst)) (prod.snd ‚â´ prod.snd)\n\n"}
{"name":"CategoryTheory.Limits.prod.associator_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nP Q R : C\n‚ä¢ Eq (CategoryTheory.Limits.prod.associator P Q R).inv (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd))","decl":"/-- The associator isomorphism for binary products. -/\n@[simps]\ndef prod.associator [HasBinaryProducts C] (P Q R : C) : (P ‚®Ø Q) ‚®Ø R ‚âÖ P ‚®Ø Q ‚®Ø R where\n  hom := prod.lift (prod.fst ‚â´ prod.fst) (prod.lift (prod.fst ‚â´ prod.snd) prod.snd)\n  inv := prod.lift (prod.lift prod.fst (prod.snd ‚â´ prod.fst)) (prod.snd ‚â´ prod.snd)\n\n"}
{"name":"CategoryTheory.Limits.prod.pentagon","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nW X Y Z : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.Limits.prod.associator W X Y).hom (CategoryTheory.CategoryStruct.id Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator W (CategoryTheory.Limits.prod X Y) Z).hom (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.Limits.prod.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator (CategoryTheory.Limits.prod W X) Y Z).hom (CategoryTheory.Limits.prod.associator W X (CategoryTheory.Limits.prod Y Z)).hom)","decl":"@[reassoc]\ntheorem prod.pentagon [HasBinaryProducts C] (W X Y Z : C) :\n    prod.map (prod.associator W X Y).hom (ùüô Z) ‚â´\n        (prod.associator W (X ‚®Ø Y) Z).hom ‚â´ prod.map (ùüô W) (prod.associator X Y Z).hom =\n      (prod.associator (W ‚®Ø X) Y Z).hom ‚â´ (prod.associator W X (Y ‚®Ø Z)).hom := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.prod.pentagon_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nW X Y Z‚úù Z : C\nh : Quiver.Hom (CategoryTheory.Limits.prod W (CategoryTheory.Limits.prod X (CategoryTheory.Limits.prod Y Z‚úù))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.Limits.prod.associator W X Y).hom (CategoryTheory.CategoryStruct.id Z‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator W (CategoryTheory.Limits.prod X Y) Z‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.Limits.prod.associator X Y Z‚úù).hom) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator (CategoryTheory.Limits.prod W X) Y Z‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator W X (CategoryTheory.Limits.prod Y Z‚úù)).hom h))","decl":"@[reassoc]\ntheorem prod.pentagon [HasBinaryProducts C] (W X Y Z : C) :\n    prod.map (prod.associator W X Y).hom (ùüô Z) ‚â´\n        (prod.associator W (X ‚®Ø Y) Z).hom ‚â´ prod.map (ùüô W) (prod.associator X Y Z).hom =\n      (prod.associator (W ‚®Ø X) Y Z).hom ‚â´ (prod.associator W X (Y ‚®Ø Z)).hom := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.prod.associator_naturality","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C\nf‚ÇÅ : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nf‚ÇÇ : Quiver.Hom X‚ÇÇ Y‚ÇÇ\nf‚ÇÉ : Quiver.Hom X‚ÇÉ Y‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.Limits.prod.map f‚ÇÅ f‚ÇÇ) f‚ÇÉ) (CategoryTheory.Limits.prod.associator Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom (CategoryTheory.Limits.prod.map f‚ÇÅ (CategoryTheory.Limits.prod.map f‚ÇÇ f‚ÇÉ)))","decl":"@[reassoc]\ntheorem prod.associator_naturality [HasBinaryProducts C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ)\n    (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) :\n    prod.map (prod.map f‚ÇÅ f‚ÇÇ) f‚ÇÉ ‚â´ (prod.associator Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom =\n      (prod.associator X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom ‚â´ prod.map f‚ÇÅ (prod.map f‚ÇÇ f‚ÇÉ) := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.prod.associator_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C\nf‚ÇÅ : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nf‚ÇÇ : Quiver.Hom X‚ÇÇ Y‚ÇÇ\nf‚ÇÉ : Quiver.Hom X‚ÇÉ Y‚ÇÉ\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y‚ÇÅ (CategoryTheory.Limits.prod Y‚ÇÇ Y‚ÇÉ)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.Limits.prod.map f‚ÇÅ f‚ÇÇ) f‚ÇÉ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f‚ÇÅ (CategoryTheory.Limits.prod.map f‚ÇÇ f‚ÇÉ)) h))","decl":"@[reassoc]\ntheorem prod.associator_naturality [HasBinaryProducts C] {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ)\n    (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) :\n    prod.map (prod.map f‚ÇÅ f‚ÇÇ) f‚ÇÉ ‚â´ (prod.associator Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom =\n      (prod.associator X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom ‚â´ prod.map f‚ÇÅ (prod.map f‚ÇÇ f‚ÇÉ) := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.prod.leftUnitor_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasTerminal C\nP : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct (CategoryTheory.Limits.terminal C) P\n‚ä¢ Eq (CategoryTheory.Limits.prod.leftUnitor P).hom CategoryTheory.Limits.prod.snd","decl":"/-- The left unitor isomorphism for binary products with the terminal object. -/\n@[simps]\ndef prod.leftUnitor (P : C) [HasBinaryProduct (‚ä§_ C) P] : (‚ä§_ C) ‚®Ø P ‚âÖ P where\n  hom := prod.snd\n  inv := prod.lift (terminal.from P) (ùüô _)\n  hom_inv_id := by apply prod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.leftUnitor_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasTerminal C\nP : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct (CategoryTheory.Limits.terminal C) P\n‚ä¢ Eq (CategoryTheory.Limits.prod.leftUnitor P).inv (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.terminal.from P) (CategoryTheory.CategoryStruct.id P))","decl":"/-- The left unitor isomorphism for binary products with the terminal object. -/\n@[simps]\ndef prod.leftUnitor (P : C) [HasBinaryProduct (‚ä§_ C) P] : (‚ä§_ C) ‚®Ø P ‚âÖ P where\n  hom := prod.snd\n  inv := prod.lift (terminal.from P) (ùüô _)\n  hom_inv_id := by apply prod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.rightUnitor_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasTerminal C\nP : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct P (CategoryTheory.Limits.terminal C)\n‚ä¢ Eq (CategoryTheory.Limits.prod.rightUnitor P).inv (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id P) (CategoryTheory.Limits.terminal.from P))","decl":"/-- The right unitor isomorphism for binary products with the terminal object. -/\n@[simps]\ndef prod.rightUnitor (P : C) [HasBinaryProduct P (‚ä§_ C)] : P ‚®Ø ‚ä§_ C ‚âÖ P where\n  hom := prod.fst\n  inv := prod.lift (ùüô _) (terminal.from P)\n  hom_inv_id := by apply prod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.rightUnitor_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasTerminal C\nP : C\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct P (CategoryTheory.Limits.terminal C)\n‚ä¢ Eq (CategoryTheory.Limits.prod.rightUnitor P).hom CategoryTheory.Limits.prod.fst","decl":"/-- The right unitor isomorphism for binary products with the terminal object. -/\n@[simps]\ndef prod.rightUnitor (P : C) [HasBinaryProduct P (‚ä§_ C)] : P ‚®Ø ‚ä§_ C ‚âÖ P where\n  hom := prod.fst\n  inv := prod.lift (ùüô _) (terminal.from P)\n  hom_inv_id := by apply prod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.leftUnitor_hom_naturality","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasTerminal C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C)) f) (CategoryTheory.Limits.prod.leftUnitor Y).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor X).hom f)","decl":"@[reassoc]\ntheorem prod.leftUnitor_hom_naturality [HasBinaryProducts C] (f : X ‚ü∂ Y) :\n    prod.map (ùüô _) f ‚â´ (prod.leftUnitor Y).hom = (prod.leftUnitor X).hom ‚â´ f :=\n  prod.map_snd _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.leftUnitor_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasTerminal C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C)) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor Y).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor X).hom (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc]\ntheorem prod.leftUnitor_hom_naturality [HasBinaryProducts C] (f : X ‚ü∂ Y) :\n    prod.map (ùüô _) f ‚â´ (prod.leftUnitor Y).hom = (prod.leftUnitor X).hom ‚â´ f :=\n  prod.map_snd _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.leftUnitor_inv_naturality","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasTerminal C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor X).inv (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C)) f)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.prod.leftUnitor Y).inv)","decl":"@[reassoc]\ntheorem prod.leftUnitor_inv_naturality [HasBinaryProducts C] (f : X ‚ü∂ Y) :\n    (prod.leftUnitor X).inv ‚â´ prod.map (ùüô _) f = f ‚â´ (prod.leftUnitor Y).inv := by\n  rw [Iso.inv_comp_eq, ‚Üê Category.assoc, Iso.eq_comp_inv, prod.leftUnitor_hom_naturality]\n\n"}
{"name":"CategoryTheory.Limits.prod.leftUnitor_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasTerminal C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod (CategoryTheory.Limits.terminal C) Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C)) f) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor Y).inv h))","decl":"@[reassoc]\ntheorem prod.leftUnitor_inv_naturality [HasBinaryProducts C] (f : X ‚ü∂ Y) :\n    (prod.leftUnitor X).inv ‚â´ prod.map (ùüô _) f = f ‚â´ (prod.leftUnitor Y).inv := by\n  rw [Iso.inv_comp_eq, ‚Üê Category.assoc, Iso.eq_comp_inv, prod.leftUnitor_hom_naturality]\n\n"}
{"name":"CategoryTheory.Limits.prod.rightUnitor_hom_naturality","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasTerminal C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C))) (CategoryTheory.Limits.prod.rightUnitor Y).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.rightUnitor X).hom f)","decl":"@[reassoc]\ntheorem prod.rightUnitor_hom_naturality [HasBinaryProducts C] (f : X ‚ü∂ Y) :\n    prod.map f (ùüô _) ‚â´ (prod.rightUnitor Y).hom = (prod.rightUnitor X).hom ‚â´ f :=\n  prod.map_fst _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.rightUnitor_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasTerminal C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.rightUnitor Y).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.rightUnitor X).hom (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc]\ntheorem prod.rightUnitor_hom_naturality [HasBinaryProducts C] (f : X ‚ü∂ Y) :\n    prod.map f (ùüô _) ‚â´ (prod.rightUnitor Y).hom = (prod.rightUnitor X).hom ‚â´ f :=\n  prod.map_fst _ _\n\n"}
{"name":"CategoryTheory.Limits.prod_rightUnitor_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasTerminal C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y (CategoryTheory.Limits.terminal C)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.rightUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C))) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.rightUnitor Y).inv h))","decl":"@[reassoc]\ntheorem prod_rightUnitor_inv_naturality [HasBinaryProducts C] (f : X ‚ü∂ Y) :\n    (prod.rightUnitor X).inv ‚â´ prod.map f (ùüô _) = f ‚â´ (prod.rightUnitor Y).inv := by\n  rw [Iso.inv_comp_eq, ‚Üê Category.assoc, Iso.eq_comp_inv, prod.rightUnitor_hom_naturality]\n\n"}
{"name":"CategoryTheory.Limits.prod_rightUnitor_inv_naturality","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasTerminal C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.rightUnitor X).inv (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C)))) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.prod.rightUnitor Y).inv)","decl":"@[reassoc]\ntheorem prod_rightUnitor_inv_naturality [HasBinaryProducts C] (f : X ‚ü∂ Y) :\n    (prod.rightUnitor X).inv ‚â´ prod.map f (ùüô _) = f ‚â´ (prod.rightUnitor Y).inv := by\n  rw [Iso.inv_comp_eq, ‚Üê Category.assoc, Iso.eq_comp_inv, prod.rightUnitor_hom_naturality]\n\n"}
{"name":"CategoryTheory.Limits.prod.triangle","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasTerminal C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nX Y : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator X (CategoryTheory.Limits.terminal C) Y).hom (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) (CategoryTheory.Limits.prod.leftUnitor Y).hom)) (CategoryTheory.Limits.prod.map (CategoryTheory.Limits.prod.rightUnitor X).hom (CategoryTheory.CategoryStruct.id Y))","decl":"theorem prod.triangle [HasBinaryProducts C] (X Y : C) :\n    (prod.associator X (‚ä§_ C) Y).hom ‚â´ prod.map (ùüô X) (prod.leftUnitor Y).hom =\n      prod.map (prod.rightUnitor X).hom (ùüô Y) := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.braiding_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q : C\n‚ä¢ Eq (CategoryTheory.Limits.coprod.braiding P Q).inv (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl)","decl":"/-- The braiding isomorphism which swaps a binary coproduct. -/\n@[simps]\ndef coprod.braiding (P Q : C) : P ‚®ø Q ‚âÖ Q ‚®ø P where\n  hom := coprod.desc coprod.inr coprod.inl\n  inv := coprod.desc coprod.inr coprod.inl\n\n"}
{"name":"CategoryTheory.Limits.coprod.braiding_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q : C\n‚ä¢ Eq (CategoryTheory.Limits.coprod.braiding P Q).hom (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl)","decl":"/-- The braiding isomorphism which swaps a binary coproduct. -/\n@[simps]\ndef coprod.braiding (P Q : C) : P ‚®ø Q ‚âÖ Q ‚®ø P where\n  hom := coprod.desc coprod.inr coprod.inl\n  inv := coprod.desc coprod.inr coprod.inl\n\n"}
{"name":"CategoryTheory.Limits.coprod.symmetry'","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl) (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.coprod P Q))","decl":"@[reassoc]\ntheorem coprod.symmetry' (P Q : C) :\n    coprod.desc coprod.inr coprod.inl ‚â´ coprod.desc coprod.inr coprod.inl = ùüô (P ‚®ø Q) :=\n  (coprod.braiding _ _).hom_inv_id\n\n"}
{"name":"CategoryTheory.Limits.coprod.symmetry'_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q Z : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod P Q) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl) h)) h","decl":"@[reassoc]\ntheorem coprod.symmetry' (P Q : C) :\n    coprod.desc coprod.inr coprod.inl ‚â´ coprod.desc coprod.inr coprod.inl = ùüô (P ‚®ø Q) :=\n  (coprod.braiding _ _).hom_inv_id\n\n"}
{"name":"CategoryTheory.Limits.coprod.symmetry","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.braiding P Q).hom (CategoryTheory.Limits.coprod.braiding Q P).hom) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.coprod P Q))","decl":"/-- The braiding isomorphism is symmetric. -/\ntheorem coprod.symmetry (P Q : C) : (coprod.braiding P Q).hom ‚â´ (coprod.braiding Q P).hom = ùüô _ :=\n  coprod.symmetry' _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.associator_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q R : C\n‚ä¢ Eq (CategoryTheory.Limits.coprod.associator P Q R).hom (CategoryTheory.Limits.coprod.desc (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inl (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inr)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inr))","decl":"/-- The associator isomorphism for binary coproducts. -/\n@[simps]\ndef coprod.associator (P Q R : C) : (P ‚®ø Q) ‚®ø R ‚âÖ P ‚®ø Q ‚®ø R where\n  hom := coprod.desc (coprod.desc coprod.inl (coprod.inl ‚â´ coprod.inr)) (coprod.inr ‚â´ coprod.inr)\n  inv := coprod.desc (coprod.inl ‚â´ coprod.inl) (coprod.desc (coprod.inr ‚â´ coprod.inl) coprod.inr)\n\n"}
{"name":"CategoryTheory.Limits.coprod.associator_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q R : C\n‚ä¢ Eq (CategoryTheory.Limits.coprod.associator P Q R).inv (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inl) (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl) CategoryTheory.Limits.coprod.inr))","decl":"/-- The associator isomorphism for binary coproducts. -/\n@[simps]\ndef coprod.associator (P Q R : C) : (P ‚®ø Q) ‚®ø R ‚âÖ P ‚®ø Q ‚®ø R where\n  hom := coprod.desc (coprod.desc coprod.inl (coprod.inl ‚â´ coprod.inr)) (coprod.inr ‚â´ coprod.inr)\n  inv := coprod.desc (coprod.inl ‚â´ coprod.inl) (coprod.desc (coprod.inr ‚â´ coprod.inl) coprod.inr)\n\n"}
{"name":"CategoryTheory.Limits.coprod.pentagon","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nW X Y Z : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.Limits.coprod.associator W X Y).hom (CategoryTheory.CategoryStruct.id Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.associator W (CategoryTheory.Limits.coprod X Y) Z).hom (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.Limits.coprod.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.associator (CategoryTheory.Limits.coprod W X) Y Z).hom (CategoryTheory.Limits.coprod.associator W X (CategoryTheory.Limits.coprod Y Z)).hom)","decl":"theorem coprod.pentagon (W X Y Z : C) :\n    coprod.map (coprod.associator W X Y).hom (ùüô Z) ‚â´\n        (coprod.associator W (X ‚®ø Y) Z).hom ‚â´ coprod.map (ùüô W) (coprod.associator X Y Z).hom =\n      (coprod.associator (W ‚®ø X) Y Z).hom ‚â´ (coprod.associator W X (Y ‚®ø Z)).hom := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.associator_naturality","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C\nf‚ÇÅ : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nf‚ÇÇ : Quiver.Hom X‚ÇÇ Y‚ÇÇ\nf‚ÇÉ : Quiver.Hom X‚ÇÉ Y‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.Limits.coprod.map f‚ÇÅ f‚ÇÇ) f‚ÇÉ) (CategoryTheory.Limits.coprod.associator Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.associator X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom (CategoryTheory.Limits.coprod.map f‚ÇÅ (CategoryTheory.Limits.coprod.map f‚ÇÇ f‚ÇÉ)))","decl":"theorem coprod.associator_naturality {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ)\n    (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) :\n    coprod.map (coprod.map f‚ÇÅ f‚ÇÇ) f‚ÇÉ ‚â´ (coprod.associator Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom =\n      (coprod.associator X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom ‚â´ coprod.map f‚ÇÅ (coprod.map f‚ÇÇ f‚ÇÉ) := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.leftUnitor_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproducts C\ninst‚úù : CategoryTheory.Limits.HasInitial C\nP : C\n‚ä¢ Eq (CategoryTheory.Limits.coprod.leftUnitor P).hom (CategoryTheory.Limits.coprod.desc (CategoryTheory.Limits.initial.to P) (CategoryTheory.CategoryStruct.id P))","decl":"/-- The left unitor isomorphism for binary coproducts with the initial object. -/\n@[simps]\ndef coprod.leftUnitor (P : C) : (‚ä•_ C) ‚®ø P ‚âÖ P where\n  hom := coprod.desc (initial.to P) (ùüô _)\n  inv := coprod.inr\n  hom_inv_id := by apply coprod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.leftUnitor_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproducts C\ninst‚úù : CategoryTheory.Limits.HasInitial C\nP : C\n‚ä¢ Eq (CategoryTheory.Limits.coprod.leftUnitor P).inv CategoryTheory.Limits.coprod.inr","decl":"/-- The left unitor isomorphism for binary coproducts with the initial object. -/\n@[simps]\ndef coprod.leftUnitor (P : C) : (‚ä•_ C) ‚®ø P ‚âÖ P where\n  hom := coprod.desc (initial.to P) (ùüô _)\n  inv := coprod.inr\n  hom_inv_id := by apply coprod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.rightUnitor_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproducts C\ninst‚úù : CategoryTheory.Limits.HasInitial C\nP : C\n‚ä¢ Eq (CategoryTheory.Limits.coprod.rightUnitor P).hom (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.id P) (CategoryTheory.Limits.initial.to P))","decl":"/-- The right unitor isomorphism for binary coproducts with the initial object. -/\n@[simps]\ndef coprod.rightUnitor (P : C) : P ‚®ø ‚ä•_ C ‚âÖ P where\n  hom := coprod.desc (ùüô _) (initial.to P)\n  inv := coprod.inl\n  hom_inv_id := by apply coprod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.rightUnitor_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproducts C\ninst‚úù : CategoryTheory.Limits.HasInitial C\nP : C\n‚ä¢ Eq (CategoryTheory.Limits.coprod.rightUnitor P).inv CategoryTheory.Limits.coprod.inl","decl":"/-- The right unitor isomorphism for binary coproducts with the initial object. -/\n@[simps]\ndef coprod.rightUnitor (P : C) : P ‚®ø ‚ä•_ C ‚âÖ P where\n  hom := coprod.desc (ùüô _) (initial.to P)\n  inv := coprod.inl\n  hom_inv_id := by apply coprod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.triangle","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproducts C\ninst‚úù : CategoryTheory.Limits.HasInitial C\nX Y : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.associator X (CategoryTheory.Limits.initial C) Y).hom (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id X) (CategoryTheory.Limits.coprod.leftUnitor Y).hom)) (CategoryTheory.Limits.coprod.map (CategoryTheory.Limits.coprod.rightUnitor X).hom (CategoryTheory.CategoryStruct.id Y))","decl":"theorem coprod.triangle (X Y : C) :\n    (coprod.associator X (‚ä•_ C) Y).hom ‚â´ coprod.map (ùüô X) (coprod.leftUnitor Y).hom =\n      coprod.map (coprod.rightUnitor X).hom (ùüô Y) := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.functor_map_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\nT : C\n‚ä¢ Eq ((CategoryTheory.Limits.prod.functor.map f).app T) (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id T))","decl":"/-- The binary product functor. -/\n@[simps]\ndef prod.functor : C ‚•§ C ‚•§ C where\n  obj X :=\n    { obj := fun Y => X ‚®Ø Y\n      map := fun {_ _} => prod.map (ùüô X) }\n  map f :=\n    { app := fun T => prod.map f (ùüô T) }\n\n"}
{"name":"CategoryTheory.Limits.prod.functor_obj_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nX Y : C\n‚ä¢ Eq ((CategoryTheory.Limits.prod.functor.obj X).obj Y) (CategoryTheory.Limits.prod X Y)","decl":"/-- The binary product functor. -/\n@[simps]\ndef prod.functor : C ‚•§ C ‚•§ C where\n  obj X :=\n    { obj := fun Y => X ‚®Ø Y\n      map := fun {_ _} => prod.map (ùüô X) }\n  map f :=\n    { app := fun T => prod.map f (ùüô T) }\n\n"}
{"name":"CategoryTheory.Limits.prod.functor_obj_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts C\nX x‚úù¬π x‚úù : C\ng : Quiver.Hom x‚úù¬π x‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.prod.functor.obj X).map g) (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) g)","decl":"/-- The binary product functor. -/\n@[simps]\ndef prod.functor : C ‚•§ C ‚•§ C where\n  obj X :=\n    { obj := fun Y => X ‚®Ø Y\n      map := fun {_ _} => prod.map (ùüô X) }\n  map f :=\n    { app := fun T => prod.map f (ùüô T) }\n\n"}
{"name":"CategoryTheory.Limits.coprod.functor_obj_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nX x‚úù¬π x‚úù : C\ng : Quiver.Hom x‚úù¬π x‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.coprod.functor.obj X).map g) (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id X) g)","decl":"/-- The binary coproduct functor. -/\n@[simps]\ndef coprod.functor : C ‚•§ C ‚•§ C where\n  obj X :=\n    { obj := fun Y => X ‚®ø Y\n      map := fun {_ _} => coprod.map (ùüô X) }\n  map f := { app := fun T => coprod.map f (ùüô T) }\n\n"}
{"name":"CategoryTheory.Limits.coprod.functor_map_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\nT : C\n‚ä¢ Eq ((CategoryTheory.Limits.coprod.functor.map f).app T) (CategoryTheory.Limits.coprod.map f (CategoryTheory.CategoryStruct.id T))","decl":"/-- The binary coproduct functor. -/\n@[simps]\ndef coprod.functor : C ‚•§ C ‚•§ C where\n  obj X :=\n    { obj := fun Y => X ‚®ø Y\n      map := fun {_ _} => coprod.map (ùüô X) }\n  map f := { app := fun T => coprod.map f (ùüô T) }\n\n"}
{"name":"CategoryTheory.Limits.coprod.functor_obj_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nX Y : C\n‚ä¢ Eq ((CategoryTheory.Limits.coprod.functor.obj X).obj Y) (CategoryTheory.Limits.coprod X Y)","decl":"/-- The binary coproduct functor. -/\n@[simps]\ndef coprod.functor : C ‚•§ C ‚•§ C where\n  obj X :=\n    { obj := fun Y => X ‚®ø Y\n      map := fun {_ _} => coprod.map (ùüô X) }\n  map f := { app := fun T => coprod.map f (ùüô T) }\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct A B\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\nZ : D\nh : Quiver.Hom (F.obj A) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A B) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.prod.fst) h)","decl":"@[reassoc (attr := simp)]\ntheorem prodComparison_fst : prodComparison F A B ‚â´ prod.fst = F.map prod.fst :=\n  prod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct A B\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A B) CategoryTheory.Limits.prod.fst) (F.map CategoryTheory.Limits.prod.fst)","decl":"@[reassoc (attr := simp)]\ntheorem prodComparison_fst : prodComparison F A B ‚â´ prod.fst = F.map prod.fst :=\n  prod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct A B\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A B) CategoryTheory.Limits.prod.snd) (F.map CategoryTheory.Limits.prod.snd)","decl":"@[reassoc (attr := simp)]\ntheorem prodComparison_snd : prodComparison F A B ‚â´ prod.snd = F.map prod.snd :=\n  prod.lift_snd _ _\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct A B\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\nZ : D\nh : Quiver.Hom (F.obj B) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A B) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.prod.snd) h)","decl":"@[reassoc (attr := simp)]\ntheorem prodComparison_snd : prodComparison F A B ‚â´ prod.snd = F.map prod.snd :=\n  prod.lift_snd _ _\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst‚úù¬≥ : CategoryTheory.Limits.HasBinaryProduct A B\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct A' B'\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.prod.map f g)) (CategoryTheory.Limits.prodComparison F A' B')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A B) (CategoryTheory.Limits.prod.map (F.map f) (F.map g)))","decl":"/-- Naturality of the `prodComparison` morphism in both arguments. -/\n@[reassoc]\ntheorem prodComparison_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') :\n    F.map (prod.map f g) ‚â´ prodComparison F A' B' =\n      prodComparison F A B ‚â´ prod.map (F.map f) (F.map g) := by\n  rw [prodComparison, prodComparison, prod.lift_map, ‚Üê F.map_comp, ‚Üê F.map_comp, prod.comp_lift, ‚Üê\n    F.map_comp, prod.map_fst, ‚Üê F.map_comp, prod.map_snd]\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst‚úù¬≥ : CategoryTheory.Limits.HasBinaryProduct A B\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct A' B'\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.prod (F.obj A') (F.obj B')) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.prod.map f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A' B') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A B) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (F.map f) (F.map g)) h))","decl":"/-- Naturality of the `prodComparison` morphism in both arguments. -/\n@[reassoc]\ntheorem prodComparison_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') :\n    F.map (prod.map f g) ‚â´ prodComparison F A' B' =\n      prodComparison F A B ‚â´ prod.map (F.map f) (F.map g) := by\n  rw [prodComparison, prodComparison, prod.lift_map, ‚Üê F.map_comp, ‚Üê F.map_comp, prod.comp_lift, ‚Üê\n    F.map_comp, prod.map_fst, ‚Üê F.map_comp, prod.map_snd]\n\n"}
{"name":"CategoryTheory.Limits.prodComparisonNatTrans_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{w, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProducts C\ninst‚úù : CategoryTheory.Limits.HasBinaryProducts D\nF : CategoryTheory.Functor C D\nA B : C\n‚ä¢ Eq ((CategoryTheory.Limits.prodComparisonNatTrans F A).app B) (CategoryTheory.Limits.prodComparison F A B)","decl":"/-- The product comparison morphism from `F(A ‚®Ø -)` to `FA ‚®Ø F-`, whose components are given by\n`prodComparison`.\n-/\n@[simps]\ndef prodComparisonNatTrans [HasBinaryProducts C] [HasBinaryProducts D] (F : C ‚•§ D) (A : C) :\n    prod.functor.obj A ‚ãô F ‚ü∂ F ‚ãô prod.functor.obj (F.obj A) where\n  app B := prodComparison F A B\n  naturality f := by simp [prodComparison_natural]\n\n"}
{"name":"CategoryTheory.Limits.inv_prodComparison_map_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct A B\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B)) (F.map CategoryTheory.Limits.prod.fst)) CategoryTheory.Limits.prod.fst","decl":"@[reassoc]\ntheorem inv_prodComparison_map_fst [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) ‚â´ F.map prod.fst = prod.fst := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.inv_prodComparison_map_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct A B\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\nZ : D\nh : Quiver.Hom (F.obj A) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.prod.fst) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)","decl":"@[reassoc]\ntheorem inv_prodComparison_map_fst [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) ‚â´ F.map prod.fst = prod.fst := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.inv_prodComparison_map_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct A B\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B)) (F.map CategoryTheory.Limits.prod.snd)) CategoryTheory.Limits.prod.snd","decl":"@[reassoc]\ntheorem inv_prodComparison_map_snd [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) ‚â´ F.map prod.snd = prod.snd := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.inv_prodComparison_map_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct A B\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\nZ : D\nh : Quiver.Hom (F.obj B) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.prod.snd) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)","decl":"@[reassoc]\ntheorem inv_prodComparison_map_snd [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) ‚â´ F.map prod.snd = prod.snd := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_inv_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasBinaryProduct A B\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasBinaryProduct A' B'\ninst‚úù¬≥ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\ninst‚úù¬π : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A' B')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B)) (F.map (CategoryTheory.Limits.prod.map f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (F.map f) (F.map g)) (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A' B')))","decl":"/-- If the product comparison morphism is an iso, its inverse is natural. -/\n@[reassoc]\ntheorem prodComparison_inv_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') [IsIso (prodComparison F A B)]\n    [IsIso (prodComparison F A' B')] :\n    inv (prodComparison F A B) ‚â´ F.map (prod.map f g) =\n      prod.map (F.map f) (F.map g) ‚â´ inv (prodComparison F A' B') := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, prodComparison_natural]\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_inv_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasBinaryProduct A B\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasBinaryProduct A' B'\ninst‚úù¬≥ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\ninst‚úù¬π : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A' B')\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.prod A' B')) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.prod.map f g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (F.map f) (F.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A' B')) h))","decl":"/-- If the product comparison morphism is an iso, its inverse is natural. -/\n@[reassoc]\ntheorem prodComparison_inv_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') [IsIso (prodComparison F A B)]\n    [IsIso (prodComparison F A' B')] :\n    inv (prodComparison F A B) ‚â´ F.map (prod.map f g) =\n      prod.map (F.map f) (F.map g) ‚â´ inv (prodComparison F A' B') := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, prodComparison_natural]\n\n"}
{"name":"CategoryTheory.Limits.prodComparisonNatIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProducts C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProducts D\nA : C\ninst‚úù : ‚àÄ (B : C), CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\n‚ä¢ Eq (CategoryTheory.Limits.prodComparisonNatIso F A).hom (CategoryTheory.Limits.prodComparisonNatTrans F A)","decl":"/-- The natural isomorphism `F(A ‚®Ø -) ‚âÖ FA ‚®Ø F-`, provided each `prodComparison F A B` is an\nisomorphism (as `B` changes).\n-/\n-- @[simps (config := { rhsMd := semireducible })] -- Porting note: no config for semireducible\n@[simps]\ndef prodComparisonNatIso [HasBinaryProducts C] [HasBinaryProducts D] (A : C)\n    [‚àÄ B, IsIso (prodComparison F A B)] :\n    prod.functor.obj A ‚ãô F ‚âÖ F ‚ãô prod.functor.obj (F.obj A) := by\n  refine { @asIso _ _ _ _ _ (?_) with hom := prodComparisonNatTrans F A }\n  apply NatIso.isIso_of_isIso_app\n\n"}
{"name":"CategoryTheory.Limits.prodComparisonNatIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProducts C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProducts D\nA : C\ninst‚úù : ‚àÄ (B : C), CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\n‚ä¢ Eq (CategoryTheory.Limits.prodComparisonNatIso F A).inv (CategoryTheory.asIso { app := fun B => CategoryTheory.Limits.prodComparison F A B, naturality := ‚ãØ }).inv","decl":"/-- The natural isomorphism `F(A ‚®Ø -) ‚âÖ FA ‚®Ø F-`, provided each `prodComparison F A B` is an\nisomorphism (as `B` changes).\n-/\n-- @[simps (config := { rhsMd := semireducible })] -- Porting note: no config for semireducible\n@[simps]\ndef prodComparisonNatIso [HasBinaryProducts C] [HasBinaryProducts D] (A : C)\n    [‚àÄ B, IsIso (prodComparison F A B)] :\n    prod.functor.obj A ‚ãô F ‚âÖ F ‚ãô prod.functor.obj (F.obj A) := by\n  refine { @asIso _ _ _ _ _ (?_) with hom := prodComparisonNatTrans F A }\n  apply NatIso.isIso_of_isIso_app\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{w, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù‚Å¥ : CategoryTheory.Category.{w', u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nA B : C\ninst‚úù¬≥ : CategoryTheory.Limits.HasBinaryProduct A B\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProduct (G.obj (F.obj A)) (G.obj (F.obj B))\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct ((F.comp G).obj A) ((F.comp G).obj B)\n‚ä¢ Eq (CategoryTheory.Limits.prodComparison (F.comp G) A B) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.prodComparison F A B)) (CategoryTheory.Limits.prodComparison G (F.obj A) (F.obj B)))","decl":"theorem prodComparison_comp :\n    prodComparison (F ‚ãô G) A B =\n      G.map (prodComparison F A B) ‚â´ prodComparison G (F.obj A) (F.obj B) := by\n  unfold prodComparison\n  ext <;> simp <;> rw [‚Üê G.map_comp] <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_inl_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.coprod A B)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprodComparison F A B) h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.coprod.inl) h)","decl":"@[reassoc (attr := simp)]\ntheorem coprodComparison_inl : coprod.inl ‚â´ coprodComparison F A B = F.map coprod.inl :=\n  coprod.inl_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.Limits.coprodComparison F A B)) (F.map CategoryTheory.Limits.coprod.inl)","decl":"@[reassoc (attr := simp)]\ntheorem coprodComparison_inl : coprod.inl ‚â´ coprodComparison F A B = F.map coprod.inl :=\n  coprod.inl_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_inr_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.coprod A B)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprodComparison F A B) h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.coprod.inr) h)","decl":"@[reassoc (attr := simp)]\ntheorem coprodComparison_inr : coprod.inr ‚â´ coprodComparison F A B = F.map coprod.inr :=\n  coprod.inr_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.Limits.coprodComparison F A B)) (F.map CategoryTheory.Limits.coprod.inr)","decl":"@[reassoc (attr := simp)]\ntheorem coprodComparison_inr : coprod.inr ‚â´ coprodComparison F A B = F.map coprod.inr :=\n  coprod.inr_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst‚úù¬≥ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct A' B'\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.coprod A' B')) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprodComparison F A B) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.coprod.map f g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (F.map f) (F.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprodComparison F A' B') h))","decl":"/-- Naturality of the coprod_comparison morphism in both arguments. -/\n@[reassoc]\ntheorem coprodComparison_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') :\n    coprodComparison F A B ‚â´ F.map (coprod.map f g) =\n      coprod.map (F.map f) (F.map g) ‚â´ coprodComparison F A' B' := by\n  rw [coprodComparison, coprodComparison, coprod.map_desc, ‚Üê F.map_comp, ‚Üê F.map_comp,\n    coprod.desc_comp, ‚Üê F.map_comp, coprod.inl_map, ‚Üê F.map_comp, coprod.inr_map]\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst‚úù¬≥ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct A' B'\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprodComparison F A B) (F.map (CategoryTheory.Limits.coprod.map f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (F.map f) (F.map g)) (CategoryTheory.Limits.coprodComparison F A' B'))","decl":"/-- Naturality of the coprod_comparison morphism in both arguments. -/\n@[reassoc]\ntheorem coprodComparison_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') :\n    coprodComparison F A B ‚â´ F.map (coprod.map f g) =\n      coprod.map (F.map f) (F.map g) ‚â´ coprodComparison F A' B' := by\n  rw [coprodComparison, coprodComparison, coprod.map_desc, ‚Üê F.map_comp, ‚Üê F.map_comp,\n    coprod.desc_comp, ‚Üê F.map_comp, coprod.inl_map, ‚Üê F.map_comp, coprod.inr_map]\n\n"}
{"name":"CategoryTheory.Limits.coprodComparisonNatTrans_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{w, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproducts C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts D\nF : CategoryTheory.Functor C D\nA B : C\n‚ä¢ Eq ((CategoryTheory.Limits.coprodComparisonNatTrans F A).app B) (CategoryTheory.Limits.coprodComparison F A B)","decl":"/-- The coproduct comparison morphism from `FA ‚®ø F-` to `F(A ‚®ø -)`, whose components are given by\n`coprodComparison`.\n-/\n@[simps]\ndef coprodComparisonNatTrans [HasBinaryCoproducts C] [HasBinaryCoproducts D] (F : C ‚•§ D) (A : C) :\n    F ‚ãô coprod.functor.obj (F.obj A) ‚ü∂ coprod.functor.obj A ‚ãô F where\n  app B := coprodComparison F A B\n  naturality f := by simp [coprodComparison_natural]\n\n"}
{"name":"CategoryTheory.Limits.map_inl_inv_coprodComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.coprod.inl) (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B))) CategoryTheory.Limits.coprod.inl","decl":"@[reassoc]\ntheorem map_inl_inv_coprodComparison [IsIso (coprodComparison F A B)] :\n    F.map coprod.inl ‚â´ inv (coprodComparison F A B) = coprod.inl := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.map_inl_inv_coprodComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.coprod (F.obj A) (F.obj B)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.coprod.inl) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B)) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl h)","decl":"@[reassoc]\ntheorem map_inl_inv_coprodComparison [IsIso (coprodComparison F A B)] :\n    F.map coprod.inl ‚â´ inv (coprodComparison F A B) = coprod.inl := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.map_inr_inv_coprodComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.coprod (F.obj A) (F.obj B)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.coprod.inr) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B)) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr h)","decl":"@[reassoc]\ntheorem map_inr_inv_coprodComparison [IsIso (coprodComparison F A B)] :\n    F.map coprod.inr ‚â´ inv (coprodComparison F A B) = coprod.inr := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.map_inr_inv_coprodComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.coprod.inr) (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B))) CategoryTheory.Limits.coprod.inr","decl":"@[reassoc]\ntheorem map_inr_inv_coprodComparison [IsIso (coprodComparison F A B)] :\n    F.map coprod.inr ‚â´ inv (coprodComparison F A B) = coprod.inr := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_inv_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasBinaryCoproduct A' B'\ninst‚úù¬≥ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\ninst‚úù¬π : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A' B')\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.coprod (F.obj A') (F.obj B')) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (F.map f) (F.map g)) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.coprod.map f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A' B')) h))","decl":"/-- If the coproduct comparison morphism is an iso, its inverse is natural. -/\n@[reassoc]\ntheorem coprodComparison_inv_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') [IsIso (coprodComparison F A B)]\n    [IsIso (coprodComparison F A' B')] :\n    inv (coprodComparison F A B) ‚â´ coprod.map (F.map f) (F.map g) =\n      F.map (coprod.map f g) ‚â´ inv (coprodComparison F A' B') := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, coprodComparison_natural]\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_inv_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasBinaryCoproduct A' B'\ninst‚úù¬≥ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\ninst‚úù¬π : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A' B')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B)) (CategoryTheory.Limits.coprod.map (F.map f) (F.map g))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.coprod.map f g)) (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A' B')))","decl":"/-- If the coproduct comparison morphism is an iso, its inverse is natural. -/\n@[reassoc]\ntheorem coprodComparison_inv_natural (f : A ‚ü∂ A') (g : B ‚ü∂ B') [IsIso (coprodComparison F A B)]\n    [IsIso (coprodComparison F A' B')] :\n    inv (coprodComparison F A B) ‚â´ coprod.map (F.map f) (F.map g) =\n      F.map (coprod.map f g) ‚â´ inv (coprodComparison F A' B') := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, coprodComparison_natural]\n\n"}
{"name":"CategoryTheory.Limits.coprodComparisonNatIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproducts D\nA : C\ninst‚úù : ‚àÄ (B : C), CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\n‚ä¢ Eq (CategoryTheory.Limits.coprodComparisonNatIso F A).hom (CategoryTheory.Limits.coprodComparisonNatTrans F A)","decl":"/-- The natural isomorphism `FA ‚®ø F- ‚âÖ F(A ‚®ø -)`, provided each `coprodComparison F A B` is an\nisomorphism (as `B` changes).\n-/\n-- @[simps (config := { rhsMd := semireducible })] -- Porting note: no config for semireducible\n@[simps]\ndef coprodComparisonNatIso [HasBinaryCoproducts C] [HasBinaryCoproducts D] (A : C)\n    [‚àÄ B, IsIso (coprodComparison F A B)] :\n    F ‚ãô coprod.functor.obj (F.obj A) ‚âÖ coprod.functor.obj A ‚ãô F := by\n  refine { @asIso _ _ _ _ _ (?_) with hom := coprodComparisonNatTrans F A }\n  apply NatIso.isIso_of_isIso_app -- Porting note: this did not work inside { }\n\n"}
{"name":"CategoryTheory.Limits.coprodComparisonNatIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{w, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproducts D\nA : C\ninst‚úù : ‚àÄ (B : C), CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\n‚ä¢ Eq (CategoryTheory.Limits.coprodComparisonNatIso F A).inv (CategoryTheory.asIso { app := fun B => CategoryTheory.Limits.coprodComparison F A B, naturality := ‚ãØ }).inv","decl":"/-- The natural isomorphism `FA ‚®ø F- ‚âÖ F(A ‚®ø -)`, provided each `coprodComparison F A B` is an\nisomorphism (as `B` changes).\n-/\n-- @[simps (config := { rhsMd := semireducible })] -- Porting note: no config for semireducible\n@[simps]\ndef coprodComparisonNatIso [HasBinaryCoproducts C] [HasBinaryCoproducts D] (A : C)\n    [‚àÄ B, IsIso (coprodComparison F A B)] :\n    F ‚ãô coprod.functor.obj (F.obj A) ‚âÖ coprod.functor.obj A ‚ãô F := by\n  refine { @asIso _ _ _ _ _ (?_) with hom := coprodComparisonNatTrans F A }\n  apply NatIso.isIso_of_isIso_app -- Porting note: this did not work inside { }\n\n"}
{"name":"CategoryTheory.Over.coprodObj_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nA : C\na‚úù X‚úù Y‚úù : CategoryTheory.Over A\nk : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (a‚úù.coprodObj.map k) (CategoryTheory.Over.homMk (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj a‚úù.left)) k.left) ‚ãØ)","decl":"/-- Auxiliary definition for `Over.coprod`. -/\n@[simps]\nnoncomputable def Over.coprodObj [HasBinaryCoproducts C] {A : C} :\n    Over A ‚Üí Over A ‚•§ Over A :=\n  fun f =>\n  { obj := fun g => Over.mk (coprod.desc f.hom g.hom)\n    map := fun k => Over.homMk (coprod.map (ùüô _) k.left) }\n\n"}
{"name":"CategoryTheory.Over.coprodObj_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nA : C\na‚úù g : CategoryTheory.Over A\n‚ä¢ Eq (a‚úù.coprodObj.obj g) (CategoryTheory.Over.mk (CategoryTheory.Limits.coprod.desc a‚úù.hom g.hom))","decl":"/-- Auxiliary definition for `Over.coprod`. -/\n@[simps]\nnoncomputable def Over.coprodObj [HasBinaryCoproducts C] {A : C} :\n    Over A ‚Üí Over A ‚•§ Over A :=\n  fun f =>\n  { obj := fun g => Over.mk (coprod.desc f.hom g.hom)\n    map := fun k => Over.homMk (coprod.map (ùüô _) k.left) }\n\n"}
{"name":"CategoryTheory.Over.coprod_map_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nA : C\nX‚úù Y‚úù : CategoryTheory.Over A\nk : Quiver.Hom X‚úù Y‚úù\ng : CategoryTheory.Over A\n‚ä¢ Eq ((CategoryTheory.Over.coprod.map k).app g) (CategoryTheory.Over.homMk (CategoryTheory.Limits.coprod.map k.left (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj g.left))) ‚ãØ)","decl":"/-- A category with binary coproducts has a functorial `sup` operation on over categories. -/\n@[simps]\nnoncomputable def Over.coprod [HasBinaryCoproducts C] {A : C} : Over A ‚•§ Over A ‚•§ Over A where\n  obj f := Over.coprodObj f\n  map k :=\n    { app := fun g => Over.homMk (coprod.map k.left (ùüô _)) (by\n        dsimp; rw [coprod.map_desc, Category.id_comp, Over.w k])\n      naturality := fun f g k => by\n        ext\n        dsimp; simp }\n  map_id X := by\n    ext\n    dsimp; simp\n  map_comp f g := by\n    ext\n    dsimp; simp\n\n"}
{"name":"CategoryTheory.Over.coprod_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nA : C\nf : CategoryTheory.Over A\n‚ä¢ Eq (CategoryTheory.Over.coprod.obj f) f.coprodObj","decl":"/-- A category with binary coproducts has a functorial `sup` operation on over categories. -/\n@[simps]\nnoncomputable def Over.coprod [HasBinaryCoproducts C] {A : C} : Over A ‚•§ Over A ‚•§ Over A where\n  obj f := Over.coprodObj f\n  map k :=\n    { app := fun g => Over.homMk (coprod.map k.left (ùüô _)) (by\n        dsimp; rw [coprod.map_desc, Category.id_comp, Over.w k])\n      naturality := fun f g k => by\n        ext\n        dsimp; simp }\n  map_id X := by\n    ext\n    dsimp; simp\n  map_comp f g := by\n    ext\n    dsimp; simp\n\n"}
