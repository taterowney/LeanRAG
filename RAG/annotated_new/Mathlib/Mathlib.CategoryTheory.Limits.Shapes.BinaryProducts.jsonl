{"name":"CategoryTheory.Limits.WalkingPair.ofNat_toCtorIdx","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"x : CategoryTheory.Limits.WalkingPair\n⊢ Eq (CategoryTheory.Limits.WalkingPair.ofNat x.toCtorIdx) x","decl":"/-- The type of objects for the diagram indexing a binary (co)product. -/\ninductive WalkingPair : Type\n  | left\n  | right\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.left.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"⊢ Eq (SizeOf.sizeOf CategoryTheory.Limits.WalkingPair.left) 1","decl":"/-- The type of objects for the diagram indexing a binary (co)product. -/\ninductive WalkingPair : Type\n  | left\n  | right\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.right.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"⊢ Eq (SizeOf.sizeOf CategoryTheory.Limits.WalkingPair.right) 1","decl":"/-- The type of objects for the diagram indexing a binary (co)product. -/\ninductive WalkingPair : Type\n  | left\n  | right\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.swap_apply_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"⊢ Eq (CategoryTheory.Limits.WalkingPair.swap CategoryTheory.Limits.WalkingPair.left) CategoryTheory.Limits.WalkingPair.right","decl":"@[simp]\ntheorem WalkingPair.swap_apply_left : WalkingPair.swap left = right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.swap_apply_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"⊢ Eq (CategoryTheory.Limits.WalkingPair.swap CategoryTheory.Limits.WalkingPair.right) CategoryTheory.Limits.WalkingPair.left","decl":"@[simp]\ntheorem WalkingPair.swap_apply_right : WalkingPair.swap right = left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.swap_symm_apply_tt","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"⊢ Eq (CategoryTheory.Limits.WalkingPair.swap.symm CategoryTheory.Limits.WalkingPair.left) CategoryTheory.Limits.WalkingPair.right","decl":"@[simp]\ntheorem WalkingPair.swap_symm_apply_tt : WalkingPair.swap.symm left = right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.swap_symm_apply_ff","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"⊢ Eq (CategoryTheory.Limits.WalkingPair.swap.symm CategoryTheory.Limits.WalkingPair.right) CategoryTheory.Limits.WalkingPair.left","decl":"@[simp]\ntheorem WalkingPair.swap_symm_apply_ff : WalkingPair.swap.symm right = left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.equivBool_apply_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"⊢ Eq (CategoryTheory.Limits.WalkingPair.equivBool CategoryTheory.Limits.WalkingPair.left) Bool.true","decl":"@[simp]\ntheorem WalkingPair.equivBool_apply_left : WalkingPair.equivBool left = true :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.equivBool_apply_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"⊢ Eq (CategoryTheory.Limits.WalkingPair.equivBool CategoryTheory.Limits.WalkingPair.right) Bool.false","decl":"@[simp]\ntheorem WalkingPair.equivBool_apply_right : WalkingPair.equivBool right = false :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.equivBool_symm_apply_true","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"⊢ Eq (CategoryTheory.Limits.WalkingPair.equivBool.symm Bool.true) CategoryTheory.Limits.WalkingPair.left","decl":"@[simp]\ntheorem WalkingPair.equivBool_symm_apply_true : WalkingPair.equivBool.symm true = left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingPair.equivBool_symm_apply_false","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"⊢ Eq (CategoryTheory.Limits.WalkingPair.equivBool.symm Bool.false) CategoryTheory.Limits.WalkingPair.right","decl":"@[simp]\ntheorem WalkingPair.equivBool_symm_apply_false : WalkingPair.equivBool.symm false = right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.pairFunction_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\nX Y : C\n⊢ Eq (CategoryTheory.Limits.pairFunction X Y CategoryTheory.Limits.WalkingPair.left) X","decl":"@[simp]\ntheorem pairFunction_left (X Y : C) : pairFunction X Y left = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.pairFunction_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\nX Y : C\n⊢ Eq (CategoryTheory.Limits.pairFunction X Y CategoryTheory.Limits.WalkingPair.right) Y","decl":"@[simp]\ntheorem pairFunction_right (X Y : C) : pairFunction X Y right = Y :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.pair_obj_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\n⊢ Eq ((CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.left }) X","decl":"@[simp]\ntheorem pair_obj_left (X Y : C) : (pair X Y).obj ⟨left⟩ = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.pair_obj_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\n⊢ Eq ((CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.right }) Y","decl":"@[simp]\ntheorem pair_obj_right (X Y : C) : (pair X Y).obj ⟨right⟩ = Y :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.mapPair_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nf : Quiver.Hom (F.obj { as := CategoryTheory.Limits.WalkingPair.left }) (G.obj { as := CategoryTheory.Limits.WalkingPair.left })\ng : Quiver.Hom (F.obj { as := CategoryTheory.Limits.WalkingPair.right }) (G.obj { as := CategoryTheory.Limits.WalkingPair.right })\n⊢ Eq ((CategoryTheory.Limits.mapPair f g).app { as := CategoryTheory.Limits.WalkingPair.left }) f","decl":"@[simp]\ntheorem mapPair_left : (mapPair f g).app ⟨left⟩ = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.mapPair_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nf : Quiver.Hom (F.obj { as := CategoryTheory.Limits.WalkingPair.left }) (G.obj { as := CategoryTheory.Limits.WalkingPair.left })\ng : Quiver.Hom (F.obj { as := CategoryTheory.Limits.WalkingPair.right }) (G.obj { as := CategoryTheory.Limits.WalkingPair.right })\n⊢ Eq ((CategoryTheory.Limits.mapPair f g).app { as := CategoryTheory.Limits.WalkingPair.right }) g","decl":"@[simp]\ntheorem mapPair_right : (mapPair f g).app ⟨right⟩ = g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.mapPairIso_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nf : CategoryTheory.Iso (F.obj { as := CategoryTheory.Limits.WalkingPair.left }) (G.obj { as := CategoryTheory.Limits.WalkingPair.left })\ng : CategoryTheory.Iso (F.obj { as := CategoryTheory.Limits.WalkingPair.right }) (G.obj { as := CategoryTheory.Limits.WalkingPair.right })\nX : CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair\n⊢ Eq ((CategoryTheory.Limits.mapPairIso f g).inv.app X) (CategoryTheory.Limits.mapPair.match_1 (fun j => CategoryTheory.Iso (F.obj j) (G.obj j)) X (fun _ => f) fun _ => g).inv","decl":"/-- The natural isomorphism between two functors out of the walking pair, specified by its\ncomponents. -/\n@[simps!]\ndef mapPairIso (f : F.obj ⟨left⟩ ≅ G.obj ⟨left⟩) (g : F.obj ⟨right⟩ ≅ G.obj ⟨right⟩) : F ≅ G :=\n  NatIso.ofComponents (fun j ↦ match j with\n    | ⟨left⟩ => f\n    | ⟨right⟩ => g)\n    (fun ⟨⟨u⟩⟩ => by aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.mapPairIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nf : CategoryTheory.Iso (F.obj { as := CategoryTheory.Limits.WalkingPair.left }) (G.obj { as := CategoryTheory.Limits.WalkingPair.left })\ng : CategoryTheory.Iso (F.obj { as := CategoryTheory.Limits.WalkingPair.right }) (G.obj { as := CategoryTheory.Limits.WalkingPair.right })\nX : CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair\n⊢ Eq ((CategoryTheory.Limits.mapPairIso f g).hom.app X) (CategoryTheory.Limits.mapPair.match_1 (fun j => CategoryTheory.Iso (F.obj j) (G.obj j)) X (fun _ => f) fun _ => g).hom","decl":"/-- The natural isomorphism between two functors out of the walking pair, specified by its\ncomponents. -/\n@[simps!]\ndef mapPairIso (f : F.obj ⟨left⟩ ≅ G.obj ⟨left⟩) (g : F.obj ⟨right⟩ ≅ G.obj ⟨right⟩) : F ≅ G :=\n  NatIso.ofComponents (fun j ↦ match j with\n    | ⟨left⟩ => f\n    | ⟨right⟩ => g)\n    (fun ⟨⟨u⟩⟩ => by aesop_cat)\n\n"}
{"name":"CategoryTheory.Limits.diagramIsoPair_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nX : CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair\n⊢ Eq ((CategoryTheory.Limits.diagramIsoPair F).inv.app X) (CategoryTheory.Limits.mapPair.match_1 (fun j => CategoryTheory.Iso (F.obj j) ((CategoryTheory.Limits.pair (F.obj { as := CategoryTheory.Limits.WalkingPair.left }) (F.obj { as := CategoryTheory.Limits.WalkingPair.right })).obj j)) X (fun _ => CategoryTheory.Iso.refl (F.obj { as := CategoryTheory.Limits.WalkingPair.left })) fun _ => CategoryTheory.Iso.refl (F.obj { as := CategoryTheory.Limits.WalkingPair.right })).inv","decl":"/-- Every functor out of the walking pair is naturally isomorphic (actually, equal) to a `pair` -/\n@[simps!]\ndef diagramIsoPair (F : Discrete WalkingPair ⥤ C) :\n    F ≅ pair (F.obj ⟨WalkingPair.left⟩) (F.obj ⟨WalkingPair.right⟩) :=\n  mapPairIso (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.diagramIsoPair_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nX : CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair\n⊢ Eq ((CategoryTheory.Limits.diagramIsoPair F).hom.app X) (CategoryTheory.Limits.mapPair.match_1 (fun j => CategoryTheory.Iso (F.obj j) ((CategoryTheory.Limits.pair (F.obj { as := CategoryTheory.Limits.WalkingPair.left }) (F.obj { as := CategoryTheory.Limits.WalkingPair.right })).obj j)) X (fun _ => CategoryTheory.Iso.refl (F.obj { as := CategoryTheory.Limits.WalkingPair.left })) fun _ => CategoryTheory.Iso.refl (F.obj { as := CategoryTheory.Limits.WalkingPair.right })).hom","decl":"/-- Every functor out of the walking pair is naturally isomorphic (actually, equal) to a `pair` -/\n@[simps!]\ndef diagramIsoPair (F : Discrete WalkingPair ⥤ C) :\n    F ≅ pair (F.obj ⟨WalkingPair.left⟩) (F.obj ⟨WalkingPair.right⟩) :=\n  mapPairIso (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.π_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\ns : CategoryTheory.Limits.BinaryFan X Y\n⊢ Eq (s.π.app { as := CategoryTheory.Limits.WalkingPair.left }) s.fst","decl":"@[simp]\ntheorem BinaryFan.π_app_left {X Y : C} (s : BinaryFan X Y) : s.π.app ⟨WalkingPair.left⟩ = s.fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.π_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\ns : CategoryTheory.Limits.BinaryFan X Y\n⊢ Eq (s.π.app { as := CategoryTheory.Limits.WalkingPair.right }) s.snd","decl":"@[simp]\ntheorem BinaryFan.π_app_right {X Y : C} (s : BinaryFan X Y) : s.π.app ⟨WalkingPair.right⟩ = s.snd :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.IsLimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Y : C\ns : CategoryTheory.Limits.BinaryFan X Y\nh : CategoryTheory.Limits.IsLimit s\nf g : Quiver.Hom W s.pt\nh₁ : Eq (CategoryTheory.CategoryStruct.comp f s.fst) (CategoryTheory.CategoryStruct.comp g s.fst)\nh₂ : Eq (CategoryTheory.CategoryStruct.comp f s.snd) (CategoryTheory.CategoryStruct.comp g s.snd)\n⊢ Eq f g","decl":"theorem BinaryFan.IsLimit.hom_ext {W X Y : C} {s : BinaryFan X Y} (h : IsLimit s) {f g : W ⟶ s.pt}\n    (h₁ : f ≫ s.fst = g ≫ s.fst) (h₂ : f ≫ s.snd = g ≫ s.snd) : f = g :=\n  h.hom_ext fun j => Discrete.recOn j fun j => WalkingPair.casesOn j h₁ h₂\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.ι_app_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\ns : CategoryTheory.Limits.BinaryCofan X Y\n⊢ Eq (s.ι.app { as := CategoryTheory.Limits.WalkingPair.left }) s.inl","decl":"@[simp]\ntheorem BinaryCofan.ι_app_left {X Y : C} (s : BinaryCofan X Y) :\n    s.ι.app ⟨WalkingPair.left⟩ = s.inl := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.ι_app_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\ns : CategoryTheory.Limits.BinaryCofan X Y\n⊢ Eq (s.ι.app { as := CategoryTheory.Limits.WalkingPair.right }) s.inr","decl":"@[simp]\ntheorem BinaryCofan.ι_app_right {X Y : C} (s : BinaryCofan X Y) :\n    s.ι.app ⟨WalkingPair.right⟩ = s.inr := rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.IsColimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Y : C\ns : CategoryTheory.Limits.BinaryCofan X Y\nh : CategoryTheory.Limits.IsColimit s\nf g : Quiver.Hom s.pt W\nh₁ : Eq (CategoryTheory.CategoryStruct.comp s.inl f) (CategoryTheory.CategoryStruct.comp s.inl g)\nh₂ : Eq (CategoryTheory.CategoryStruct.comp s.inr f) (CategoryTheory.CategoryStruct.comp s.inr g)\n⊢ Eq f g","decl":"theorem BinaryCofan.IsColimit.hom_ext {W X Y : C} {s : BinaryCofan X Y} (h : IsColimit s)\n    {f g : s.pt ⟶ W} (h₁ : s.inl ≫ f = s.inl ≫ g) (h₂ : s.inr ≫ f = s.inr ≫ g) : f = g :=\n  h.hom_ext fun j => Discrete.recOn j fun j => WalkingPair.casesOn j h₁ h₂\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.mk_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y P : C\nπ₁ : Quiver.Hom P X\nπ₂ : Quiver.Hom P Y\n⊢ Eq (CategoryTheory.Limits.BinaryFan.mk π₁ π₂).pt P","decl":"/-- A binary fan with vertex `P` consists of the two projections `π₁ : P ⟶ X` and `π₂ : P ⟶ Y`. -/\n@[simps pt]\ndef BinaryFan.mk {P : C} (π₁ : P ⟶ X) (π₂ : P ⟶ Y) : BinaryFan X Y where\n  pt := P\n  π := { app := fun | { as := j } => match j with | left => π₁ | right => π₂ }\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.mk_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y P : C\nι₁ : Quiver.Hom X P\nι₂ : Quiver.Hom Y P\n⊢ Eq (CategoryTheory.Limits.BinaryCofan.mk ι₁ ι₂).pt P","decl":"/-- A binary cofan with vertex `P` consists of the two inclusions `ι₁ : X ⟶ P` and `ι₂ : Y ⟶ P`. -/\n@[simps pt]\ndef BinaryCofan.mk {P : C} (ι₁ : X ⟶ P) (ι₂ : Y ⟶ P) : BinaryCofan X Y where\n  pt := P\n  ι := { app := fun | { as := j } => match j with | left => ι₁ | right => ι₂ }\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.mk_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y P : C\nπ₁ : Quiver.Hom P X\nπ₂ : Quiver.Hom P Y\n⊢ Eq (CategoryTheory.Limits.BinaryFan.mk π₁ π₂).fst π₁","decl":"@[simp]\ntheorem BinaryFan.mk_fst {P : C} (π₁ : P ⟶ X) (π₂ : P ⟶ Y) : (BinaryFan.mk π₁ π₂).fst = π₁ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.mk_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y P : C\nπ₁ : Quiver.Hom P X\nπ₂ : Quiver.Hom P Y\n⊢ Eq (CategoryTheory.Limits.BinaryFan.mk π₁ π₂).snd π₂","decl":"@[simp]\ntheorem BinaryFan.mk_snd {P : C} (π₁ : P ⟶ X) (π₂ : P ⟶ Y) : (BinaryFan.mk π₁ π₂).snd = π₂ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.mk_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y P : C\nι₁ : Quiver.Hom X P\nι₂ : Quiver.Hom Y P\n⊢ Eq (CategoryTheory.Limits.BinaryCofan.mk ι₁ ι₂).inl ι₁","decl":"@[simp]\ntheorem BinaryCofan.mk_inl {P : C} (ι₁ : X ⟶ P) (ι₂ : Y ⟶ P) : (BinaryCofan.mk ι₁ ι₂).inl = ι₁ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.mk_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y P : C\nι₁ : Quiver.Hom X P\nι₂ : Quiver.Hom Y P\n⊢ Eq (CategoryTheory.Limits.BinaryCofan.mk ι₁ ι₂).inr ι₂","decl":"@[simp]\ntheorem BinaryCofan.mk_inr {P : C} (ι₁ : X ⟶ P) (ι₂ : Y ⟶ P) : (BinaryCofan.mk ι₁ ι₂).inr = ι₂ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.IsLimit.lift'_coe","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Y : C\ns : CategoryTheory.Limits.BinaryFan X Y\nh : CategoryTheory.Limits.IsLimit s\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\n⊢ Eq (↑(CategoryTheory.Limits.BinaryFan.IsLimit.lift' h f g)) (h.lift (CategoryTheory.Limits.BinaryFan.mk f g))","decl":"/-- If `s` is a limit binary fan over `X` and `Y`, then every pair of morphisms `f : W ⟶ X` and\n    `g : W ⟶ Y` induces a morphism `l : W ⟶ s.pt` satisfying `l ≫ s.fst = f` and `l ≫ s.snd = g`.\n    -/\n@[simps]\ndef BinaryFan.IsLimit.lift' {W X Y : C} {s : BinaryFan X Y} (h : IsLimit s) (f : W ⟶ X)\n    (g : W ⟶ Y) : { l : W ⟶ s.pt // l ≫ s.fst = f ∧ l ≫ s.snd = g } :=\n  ⟨h.lift <| BinaryFan.mk f g, h.fac _ _, h.fac _ _⟩\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.IsColimit.desc'_coe","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Y : C\ns : CategoryTheory.Limits.BinaryCofan X Y\nh : CategoryTheory.Limits.IsColimit s\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\n⊢ Eq (↑(CategoryTheory.Limits.BinaryCofan.IsColimit.desc' h f g)) (h.desc (CategoryTheory.Limits.BinaryCofan.mk f g))","decl":"/-- If `s` is a colimit binary cofan over `X` and `Y`,, then every pair of morphisms `f : X ⟶ W` and\n    `g : Y ⟶ W` induces a morphism `l : s.pt ⟶ W` satisfying `s.inl ≫ l = f` and `s.inr ≫ l = g`.\n    -/\n@[simps]\ndef BinaryCofan.IsColimit.desc' {W X Y : C} {s : BinaryCofan X Y} (h : IsColimit s) (f : X ⟶ W)\n    (g : Y ⟶ W) : { l : s.pt ⟶ W // s.inl ≫ l = f ∧ s.inr ≫ l = g } :=\n  ⟨h.desc <| BinaryCofan.mk f g, h.fac _ _, h.fac _ _⟩\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.isLimit_iff_isIso_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Limits.IsTerminal Y\nc : CategoryTheory.Limits.BinaryFan X Y\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsLimit c)) (CategoryTheory.IsIso c.fst)","decl":"theorem BinaryFan.isLimit_iff_isIso_fst {X Y : C} (h : IsTerminal Y) (c : BinaryFan X Y) :\n    Nonempty (IsLimit c) ↔ IsIso c.fst := by\n  constructor\n  · rintro ⟨H⟩\n    obtain ⟨l, hl, -⟩ := BinaryFan.IsLimit.lift' H (𝟙 X) (h.from X)\n    exact\n      ⟨⟨l,\n          BinaryFan.IsLimit.hom_ext H (by simpa [hl, -Category.comp_id] using Category.comp_id _)\n            (h.hom_ext _ _),\n          hl⟩⟩\n  · intro\n    exact\n      ⟨BinaryFan.IsLimit.mk _ (fun f _ => f ≫ inv c.fst) (fun _ _ => by simp)\n          (fun _ _ => h.hom_ext _ _) fun _ _ _ e _ => by simp [← e]⟩\n\n"}
{"name":"CategoryTheory.Limits.BinaryFan.isLimit_iff_isIso_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Limits.IsTerminal X\nc : CategoryTheory.Limits.BinaryFan X Y\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsLimit c)) (CategoryTheory.IsIso c.snd)","decl":"theorem BinaryFan.isLimit_iff_isIso_snd {X Y : C} (h : IsTerminal X) (c : BinaryFan X Y) :\n    Nonempty (IsLimit c) ↔ IsIso c.snd := by\n  refine Iff.trans ?_ (BinaryFan.isLimit_iff_isIso_fst h (BinaryFan.mk c.snd c.fst))\n  exact\n    ⟨fun h => ⟨BinaryFan.isLimitFlip h.some⟩, fun h =>\n      ⟨(BinaryFan.isLimitFlip h.some).ofIsoLimit (isoBinaryFanMk c).symm⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.isColimit_iff_isIso_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Limits.IsInitial Y\nc : CategoryTheory.Limits.BinaryCofan X Y\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsColimit c)) (CategoryTheory.IsIso c.inl)","decl":"theorem BinaryCofan.isColimit_iff_isIso_inl {X Y : C} (h : IsInitial Y) (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) ↔ IsIso c.inl := by\n  constructor\n  · rintro ⟨H⟩\n    obtain ⟨l, hl, -⟩ := BinaryCofan.IsColimit.desc' H (𝟙 X) (h.to X)\n    refine ⟨⟨l, hl, BinaryCofan.IsColimit.hom_ext H (?_) (h.hom_ext _ _)⟩⟩\n    rw [Category.comp_id]\n    have e : (inl c ≫ l) ≫ inl c = 𝟙 X ≫ inl c := congrArg (·≫inl c) hl\n    rwa [Category.assoc,Category.id_comp] at e\n  · intro\n    exact\n      ⟨BinaryCofan.IsColimit.mk _ (fun f _ => inv c.inl ≫ f)\n          (fun _ _ => IsIso.hom_inv_id_assoc _ _) (fun _ _ => h.hom_ext _ _) fun _ _ _ e _ =>\n          (IsIso.eq_inv_comp _).mpr e⟩\n\n"}
{"name":"CategoryTheory.Limits.BinaryCofan.isColimit_iff_isIso_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nh : CategoryTheory.Limits.IsInitial X\nc : CategoryTheory.Limits.BinaryCofan X Y\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsColimit c)) (CategoryTheory.IsIso c.inr)","decl":"theorem BinaryCofan.isColimit_iff_isIso_inr {X Y : C} (h : IsInitial X) (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) ↔ IsIso c.inr := by\n  refine Iff.trans ?_ (BinaryCofan.isColimit_iff_isIso_inl h (BinaryCofan.mk c.inr c.inl))\n  exact\n    ⟨fun h => ⟨BinaryCofan.isColimitFlip h.some⟩, fun h =>\n      ⟨(BinaryCofan.isColimitFlip h.some).ofIsoColimit (isoBinaryCofanMk c).symm⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.prod.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\nf g : Quiver.Hom W (CategoryTheory.Limits.prod X Y)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.prod.fst)\nh₂ : Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.prod.snd) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.prod.snd)\n⊢ Eq f g","decl":"@[ext 1100]\ntheorem prod.hom_ext {W X Y : C} [HasBinaryProduct X Y] {f g : W ⟶ X ⨯ Y}\n    (h₁ : f ≫ prod.fst = g ≫ prod.fst) (h₂ : f ≫ prod.snd = g ≫ prod.snd) : f = g :=\n  BinaryFan.IsLimit.hom_ext (limit.isLimit _) h₁ h₂\n\n"}
{"name":"CategoryTheory.Limits.prod.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\nf g : Quiver.Hom W (CategoryTheory.Limits.prod X Y)\n⊢ Iff (Eq f g) (And (Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.prod.fst)) (Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.prod.snd) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.prod.snd)))","decl":"@[ext 1100]\ntheorem prod.hom_ext {W X Y : C} [HasBinaryProduct X Y] {f g : W ⟶ X ⨯ Y}\n    (h₁ : f ≫ prod.fst = g ≫ prod.fst) (h₂ : f ≫ prod.snd = g ≫ prod.snd) : f = g :=\n  BinaryFan.IsLimit.hom_ext (limit.isLimit _) h₁ h₂\n\n"}
{"name":"CategoryTheory.Limits.coprod.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf g : Quiver.Hom (CategoryTheory.Limits.coprod X Y) W\nh₁ : Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl g)\nh₂ : Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr g)\n⊢ Eq f g","decl":"@[ext 1100]\ntheorem coprod.hom_ext {W X Y : C} [HasBinaryCoproduct X Y] {f g : X ⨿ Y ⟶ W}\n    (h₁ : coprod.inl ≫ f = coprod.inl ≫ g) (h₂ : coprod.inr ≫ f = coprod.inr ≫ g) : f = g :=\n  BinaryCofan.IsColimit.hom_ext (colimit.isColimit _) h₁ h₂\n\n"}
{"name":"CategoryTheory.Limits.coprod.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf g : Quiver.Hom (CategoryTheory.Limits.coprod X Y) W\n⊢ Iff (Eq f g) (And (Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl g)) (Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr f) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr g)))","decl":"@[ext 1100]\ntheorem coprod.hom_ext {W X Y : C} [HasBinaryCoproduct X Y] {f g : X ⨿ Y ⟶ W}\n    (h₁ : coprod.inl ≫ f = coprod.inl ≫ g) (h₂ : coprod.inr ≫ f = coprod.inr ≫ g) : f = g :=\n  BinaryCofan.IsColimit.hom_ext (colimit.isColimit _) h₁ h₂\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc]\ntheorem prod.lift_fst {W X Y : C} [HasBinaryProduct X Y] (f : W ⟶ X) (g : W ⟶ Y) :\n    prod.lift f g ≫ prod.fst = f :=\n  limit.lift_π _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift f g) CategoryTheory.Limits.prod.fst) f","decl":"@[reassoc]\ntheorem prod.lift_fst {W X Y : C} [HasBinaryProduct X Y] (f : W ⟶ X) (g : W ⟶ Y) :\n    prod.lift f g ≫ prod.fst = f :=\n  limit.lift_π _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc]\ntheorem prod.lift_snd {W X Y : C} [HasBinaryProduct X Y] (f : W ⟶ X) (g : W ⟶ Y) :\n    prod.lift f g ≫ prod.snd = g :=\n  limit.lift_π _ _\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: it can also prove the og version\n"}
{"name":"CategoryTheory.Limits.prod.lift_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift f g) CategoryTheory.Limits.prod.snd) g","decl":"@[reassoc]\ntheorem prod.lift_snd {W X Y : C} [HasBinaryProduct X Y] (f : W ⟶ X) (g : W ⟶ Y) :\n    prod.lift f g ≫ prod.snd = g :=\n  limit.lift_π _ _\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: it can also prove the og version\n"}
{"name":"CategoryTheory.Limits.coprod.inl_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.Limits.coprod.desc f g)) f","decl":"@[reassoc]\ntheorem coprod.inl_desc {W X Y : C} [HasBinaryCoproduct X Y] (f : X ⟶ W) (g : Y ⟶ W) :\n    coprod.inl ≫ coprod.desc f g = f :=\n  colimit.ι_desc _ _\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: it can also prove the og version\n"}
{"name":"CategoryTheory.Limits.coprod.inl_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc f g) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc]\ntheorem coprod.inl_desc {W X Y : C} [HasBinaryCoproduct X Y] (f : X ⟶ W) (g : Y ⟶ W) :\n    coprod.inl ≫ coprod.desc f g = f :=\n  colimit.ι_desc _ _\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: it can also prove the og version\n"}
{"name":"CategoryTheory.Limits.coprod.inr_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc f g) h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc]\ntheorem coprod.inr_desc {W X Y : C} [HasBinaryCoproduct X Y] (f : X ⟶ W) (g : Y ⟶ W) :\n    coprod.inr ≫ coprod.desc f g = g :=\n  colimit.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.inr_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.Limits.coprod.desc f g)) g","decl":"@[reassoc]\ntheorem coprod.inr_desc {W X Y : C} [HasBinaryCoproduct X Y] (f : X ⟶ W) (g : Y ⟶ W) :\n    coprod.inr ≫ coprod.desc f g = g :=\n  colimit.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.mono_lift_of_mono_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.prod.lift f g)","decl":"instance prod.mono_lift_of_mono_left {W X Y : C} [HasBinaryProduct X Y] (f : W ⟶ X) (g : W ⟶ Y)\n    [Mono f] : Mono (prod.lift f g) :=\n  mono_of_mono_fac <| prod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.mono_lift_of_mono_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝ : CategoryTheory.Mono g\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.prod.lift f g)","decl":"instance prod.mono_lift_of_mono_right {W X Y : C} [HasBinaryProduct X Y] (f : W ⟶ X) (g : W ⟶ Y)\n    [Mono g] : Mono (prod.lift f g) :=\n  mono_of_mono_fac <| prod.lift_snd _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.epi_desc_of_epi_left","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.coprod.desc f g)","decl":"instance coprod.epi_desc_of_epi_left {W X Y : C} [HasBinaryCoproduct X Y] (f : X ⟶ W) (g : Y ⟶ W)\n    [Epi f] : Epi (coprod.desc f g) :=\n  epi_of_epi_fac <| coprod.inl_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.epi_desc_of_epi_right","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\ninst✝ : CategoryTheory.Epi g\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.coprod.desc f g)","decl":"instance coprod.epi_desc_of_epi_right {W X Y : C} [HasBinaryCoproduct X Y] (f : X ⟶ W) (g : Y ⟶ W)\n    [Epi g] : Epi (coprod.desc f g) :=\n  epi_of_epi_fac <| coprod.inr_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.comp_lift_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nV W X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom V W\ng : Quiver.Hom W X\nh✝ : Quiver.Hom W Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift g h✝) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h✝)) h)","decl":"@[reassoc, simp]\ntheorem prod.comp_lift {V W X Y : C} [HasBinaryProduct X Y] (f : V ⟶ W) (g : W ⟶ X) (h : W ⟶ Y) :\n    f ≫ prod.lift g h = prod.lift (f ≫ g) (f ≫ h) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.comp_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nV W X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\nf : Quiver.Hom V W\ng : Quiver.Hom W X\nh : Quiver.Hom W Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.prod.lift g h)) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc, simp]\ntheorem prod.comp_lift {V W X Y : C} [HasBinaryProduct X Y] (f : V ⟶ W) (g : W ⟶ X) (h : W ⟶ Y) :\n    f ≫ prod.lift g h = prod.lift (f ≫ g) (f ≫ h) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.comp_diag","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Y\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.diag Y)) (CategoryTheory.Limits.prod.lift f f)","decl":"theorem prod.comp_diag {X Y : C} [HasBinaryProduct Y Y] (f : X ⟶ Y) :\n    f ≫ diag Y = prod.lift f f := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.map_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst f)","decl":"@[reassoc (attr := simp)]\ntheorem prod.map_fst {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : prod.map f g ≫ prod.fst = prod.fst ≫ f :=\n  limMap_π _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.map_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z✝\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z✝\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\ntheorem prod.map_fst {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : prod.map f g ≫ prod.fst = prod.fst ≫ f :=\n  limMap_π _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.map_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) CategoryTheory.Limits.prod.snd) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd g)","decl":"@[reassoc (attr := simp)]\ntheorem prod.map_snd {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : prod.map f g ≫ prod.snd = prod.snd ≫ g :=\n  limMap_π _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.map_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z✝\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z✝\nZ : C\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc (attr := simp)]\ntheorem prod.map_snd {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : prod.map f g ≫ prod.snd = prod.snd ≫ g :=\n  limMap_π _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.map_id_id","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\n⊢ Eq (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.prod X Y))","decl":"@[simp]\ntheorem prod.map_id_id {X Y : C} [HasBinaryProduct X Y] : prod.map (𝟙 X) (𝟙 Y) = 𝟙 _ := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_fst_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\n⊢ Eq (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.prod X Y))","decl":"@[simp]\ntheorem prod.lift_fst_snd {X Y : C} [HasBinaryProduct X Y] :\n    prod.lift prod.fst prod.snd = 𝟙 (X ⨯ Y) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nV W X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z\nf : Quiver.Hom V W\ng : Quiver.Hom V X\nh : Quiver.Hom W Y\nk : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift f g) (CategoryTheory.Limits.prod.map h k)) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k))","decl":"@[reassoc (attr := simp)]\ntheorem prod.lift_map {V W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : V ⟶ W)\n    (g : V ⟶ X) (h : W ⟶ Y) (k : X ⟶ Z) :\n    prod.lift f g ≫ prod.map h k = prod.lift (f ≫ h) (g ≫ k) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nV W X Y Z✝ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z✝\nf : Quiver.Hom V W\ng : Quiver.Hom V X\nh✝ : Quiver.Hom W Y\nk : Quiver.Hom X Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map h✝ k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp f h✝) (CategoryTheory.CategoryStruct.comp g k)) h)","decl":"@[reassoc (attr := simp)]\ntheorem prod.lift_map {V W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : V ⟶ W)\n    (g : V ⟶ X) (h : W ⟶ Y) (k : X ⟶ Z) :\n    prod.lift f g ≫ prod.map h k = prod.lift (f ≫ h) (g ≫ k) := by ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.lift_fst_comp_snd_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct W Y\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Z\ng : Quiver.Hom W X\ng' : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd g')) (CategoryTheory.Limits.prod.map g g')","decl":"@[simp]\ntheorem prod.lift_fst_comp_snd_comp {W X Y Z : C} [HasBinaryProduct W Y] [HasBinaryProduct X Z]\n    (g : W ⟶ X) (g' : Y ⟶ Z) : prod.lift (prod.fst ≫ g) (prod.snd ≫ g') = prod.map g g' := by\n  rw [← prod.lift_map]\n  simp\n\n-- We take the right hand side here to be simp normal form, as this way composition lemmas for\n-- `f ≫ h` and `g ≫ k` can fire (eg `id_comp`) , while `map_fst` and `map_snd` can still work just\n-- as well.\n"}
{"name":"CategoryTheory.Limits.prod.map_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nA₁ A₂ A₃ B₁ B₂ B₃ : C\ninst✝² : CategoryTheory.Limits.HasBinaryProduct A₁ B₁\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct A₂ B₂\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A₃ B₃\nf : Quiver.Hom A₁ A₂\ng : Quiver.Hom B₁ B₂\nh✝ : Quiver.Hom A₂ A₃\nk : Quiver.Hom B₂ B₃\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod A₃ B₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map h✝ k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp f h✝) (CategoryTheory.CategoryStruct.comp g k)) h)","decl":"@[reassoc (attr := simp)]\ntheorem prod.map_map {A₁ A₂ A₃ B₁ B₂ B₃ : C} [HasBinaryProduct A₁ B₁] [HasBinaryProduct A₂ B₂]\n    [HasBinaryProduct A₃ B₃] (f : A₁ ⟶ A₂) (g : B₁ ⟶ B₂) (h : A₂ ⟶ A₃) (k : B₂ ⟶ B₃) :\n    prod.map f g ≫ prod.map h k = prod.map (f ≫ h) (g ≫ k) := by ext <;> simp\n\n-- TODO: is it necessary to weaken the assumption here?\n"}
{"name":"CategoryTheory.Limits.prod.map_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nA₁ A₂ A₃ B₁ B₂ B₃ : C\ninst✝² : CategoryTheory.Limits.HasBinaryProduct A₁ B₁\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct A₂ B₂\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A₃ B₃\nf : Quiver.Hom A₁ A₂\ng : Quiver.Hom B₁ B₂\nh : Quiver.Hom A₂ A₃\nk : Quiver.Hom B₂ B₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) (CategoryTheory.Limits.prod.map h k)) (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k))","decl":"@[reassoc (attr := simp)]\ntheorem prod.map_map {A₁ A₂ A₃ B₁ B₂ B₃ : C} [HasBinaryProduct A₁ B₁] [HasBinaryProduct A₂ B₂]\n    [HasBinaryProduct A₃ B₃] (f : A₁ ⟶ A₂) (g : B₁ ⟶ B₂) (h : A₂ ⟶ A₃) (k : B₂ ⟶ B₃) :\n    prod.map f g ≫ prod.map h k = prod.map (f ≫ h) (g ≫ k) := by ext <;> simp\n\n-- TODO: is it necessary to weaken the assumption here?\n"}
{"name":"CategoryTheory.Limits.prod.map_swap","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B X Y : C\nf : Quiver.Hom A B\ng : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) f) (CategoryTheory.Limits.prod.map g (CategoryTheory.CategoryStruct.id B))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map g (CategoryTheory.CategoryStruct.id A)) (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id Y) f))","decl":"@[reassoc]\ntheorem prod.map_swap {A B X Y : C} (f : A ⟶ B) (g : X ⟶ Y)\n    [HasLimitsOfShape (Discrete WalkingPair) C] :\n    prod.map (𝟙 X) f ≫ prod.map g (𝟙 B) = prod.map g (𝟙 A) ≫ prod.map (𝟙 Y) f := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.map_swap_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B X Y : C\nf : Quiver.Hom A B\ng : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y B) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map g (CategoryTheory.CategoryStruct.id B)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map g (CategoryTheory.CategoryStruct.id A)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id Y) f) h))","decl":"@[reassoc]\ntheorem prod.map_swap {A B X Y : C} (f : A ⟶ B) (g : X ⟶ Y)\n    [HasLimitsOfShape (Discrete WalkingPair) C] :\n    prod.map (𝟙 X) f ≫ prod.map g (𝟙 B) = prod.map g (𝟙 A) ≫ prod.map (𝟙 Y) f := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.map_comp_id_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z✝ W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\ninst✝² : CategoryTheory.Limits.HasBinaryProduct X W\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct Z✝ W\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y W\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Z✝ W) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id W)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map g (CategoryTheory.CategoryStruct.id W)) h))","decl":"@[reassoc]\ntheorem prod.map_comp_id {X Y Z W : C} (f : X ⟶ Y) (g : Y ⟶ Z) [HasBinaryProduct X W]\n    [HasBinaryProduct Z W] [HasBinaryProduct Y W] :\n    prod.map (f ≫ g) (𝟙 W) = prod.map f (𝟙 W) ≫ prod.map g (𝟙 W) := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.map_comp_id","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝² : CategoryTheory.Limits.HasBinaryProduct X W\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct Z W\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y W\n⊢ Eq (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.Limits.prod.map g (CategoryTheory.CategoryStruct.id W)))","decl":"@[reassoc]\ntheorem prod.map_comp_id {X Y Z W : C} (f : X ⟶ Y) (g : Y ⟶ Z) [HasBinaryProduct X W]\n    [HasBinaryProduct Z W] [HasBinaryProduct Y W] :\n    prod.map (f ≫ g) (𝟙 W) = prod.map f (𝟙 W) ≫ prod.map g (𝟙 W) := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.map_id_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝² : CategoryTheory.Limits.HasBinaryProduct W X\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct W Y\ninst✝ : CategoryTheory.Limits.HasBinaryProduct W Z\n⊢ Eq (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) f) (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) g))","decl":"@[reassoc]\ntheorem prod.map_id_comp {X Y Z W : C} (f : X ⟶ Y) (g : Y ⟶ Z) [HasBinaryProduct W X]\n    [HasBinaryProduct W Y] [HasBinaryProduct W Z] :\n    prod.map (𝟙 W) (f ≫ g) = prod.map (𝟙 W) f ≫ prod.map (𝟙 W) g := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.map_id_comp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z✝ W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\ninst✝² : CategoryTheory.Limits.HasBinaryProduct W X\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct W Y\ninst✝ : CategoryTheory.Limits.HasBinaryProduct W Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod W Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) g) h))","decl":"@[reassoc]\ntheorem prod.map_id_comp {X Y Z W : C} (f : X ⟶ Y) (g : Y ⟶ Z) [HasBinaryProduct W X]\n    [HasBinaryProduct W Y] [HasBinaryProduct W Z] :\n    prod.map (𝟙 W) (f ≫ g) = prod.map (𝟙 W) f ≫ prod.map (𝟙 W) g := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.mapIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z\nf : CategoryTheory.Iso W Y\ng : CategoryTheory.Iso X Z\n⊢ Eq (CategoryTheory.Limits.prod.mapIso f g).inv (CategoryTheory.Limits.prod.map f.inv g.inv)","decl":"/-- If the products `W ⨯ X` and `Y ⨯ Z` exist, then every pair of isomorphisms `f : W ≅ Y` and\n    `g : X ≅ Z` induces an isomorphism `prod.mapIso f g : W ⨯ X ≅ Y ⨯ Z`. -/\n@[simps]\ndef prod.mapIso {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ≅ Y)\n    (g : X ≅ Z) : W ⨯ X ≅ Y ⨯ Z where\n  hom := prod.map f.hom g.hom\n  inv := prod.map f.inv g.inv\n\n"}
{"name":"CategoryTheory.Limits.prod.mapIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z\nf : CategoryTheory.Iso W Y\ng : CategoryTheory.Iso X Z\n⊢ Eq (CategoryTheory.Limits.prod.mapIso f g).hom (CategoryTheory.Limits.prod.map f.hom g.hom)","decl":"/-- If the products `W ⨯ X` and `Y ⨯ Z` exist, then every pair of isomorphisms `f : W ≅ Y` and\n    `g : X ≅ Z` induces an isomorphism `prod.mapIso f g : W ⨯ X ≅ Y ⨯ Z`. -/\n@[simps]\ndef prod.mapIso {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ≅ Y)\n    (g : X ≅ Z) : W ⨯ X ≅ Y ⨯ Z where\n  hom := prod.map f.hom g.hom\n  inv := prod.map f.inv g.inv\n\n"}
{"name":"CategoryTheory.Limits.isIso_prod","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst✝³ : CategoryTheory.Limits.HasBinaryProduct W X\ninst✝² : CategoryTheory.Limits.HasBinaryProduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.IsIso f\ninst✝ : CategoryTheory.IsIso g\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.prod.map f g)","decl":"instance isIso_prod {W X Y Z : C} [HasBinaryProduct W X] [HasBinaryProduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) [IsIso f] [IsIso g] : IsIso (prod.map f g) :=\n  (prod.mapIso (asIso f) (asIso g)).isIso_hom\n\n"}
{"name":"CategoryTheory.Limits.prod.map_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst✝³ : CategoryTheory.Mono f\ninst✝² : CategoryTheory.Mono g\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Z\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.prod.map f g)","decl":"instance prod.map_mono {C : Type*} [Category C] {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z) [Mono f]\n    [Mono g] [HasBinaryProduct W X] [HasBinaryProduct Y Z] : Mono (prod.map f g) :=\n  ⟨fun i₁ i₂ h => by\n    ext\n    · rw [← cancel_mono f]\n      simpa using congr_arg (fun f => f ≫ prod.fst) h\n    · rw [← cancel_mono g]\n      simpa using congr_arg (fun f => f ≫ prod.snd) h⟩\n\n"}
{"name":"CategoryTheory.Limits.prod.diag_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct X X\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f f) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag Y) h))","decl":"@[reassoc]\ntheorem prod.diag_map {X Y : C} (f : X ⟶ Y) [HasBinaryProduct X X] [HasBinaryProduct Y Y] :\n    diag X ≫ prod.map f f = f ≫ diag Y := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.diag_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct X X\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Y Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag X) (CategoryTheory.Limits.prod.map f f)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.diag Y))","decl":"@[reassoc]\ntheorem prod.diag_map {X Y : C} (f : X ⟶ Y) [HasBinaryProduct X X] [HasBinaryProduct Y Y] :\n    diag X ≫ prod.map f f = f ≫ diag Y := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.diag_map_fst_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryProduct (CategoryTheory.Limits.prod X Y) (CategoryTheory.Limits.prod X Y)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag (CategoryTheory.Limits.prod X Y)) (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.prod X Y))","decl":"@[reassoc]\ntheorem prod.diag_map_fst_snd {X Y : C} [HasBinaryProduct X Y] [HasBinaryProduct (X ⨯ Y) (X ⨯ Y)] :\n    diag (X ⨯ Y) ≫ prod.map prod.fst prod.snd = 𝟙 (X ⨯ Y) := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.diag_map_fst_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryProduct (CategoryTheory.Limits.prod X Y) (CategoryTheory.Limits.prod X Y)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag (CategoryTheory.Limits.prod X Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd) h)) h","decl":"@[reassoc]\ntheorem prod.diag_map_fst_snd {X Y : C} [HasBinaryProduct X Y] [HasBinaryProduct (X ⨯ Y) (X ⨯ Y)] :\n    diag (X ⨯ Y) ≫ prod.map prod.fst prod.snd = 𝟙 (X ⨯ Y) := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.diag_map_fst_snd_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nX X' Y Y' : C\ng : Quiver.Hom X Y\ng' : Quiver.Hom X' Y'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag (CategoryTheory.Limits.prod X X')) (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd g'))) (CategoryTheory.Limits.prod.map g g')","decl":"@[reassoc]\ntheorem prod.diag_map_fst_snd_comp [HasLimitsOfShape (Discrete WalkingPair) C] {X X' Y Y' : C}\n    (g : X ⟶ Y) (g' : X' ⟶ Y') :\n    diag (X ⨯ X') ≫ prod.map (prod.fst ≫ g) (prod.snd ≫ g') = prod.map g g' := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.diag_map_fst_snd_comp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nX X' Y Y' : C\ng : Quiver.Hom X Y\ng' : Quiver.Hom X' Y'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y Y') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.diag (CategoryTheory.Limits.prod X X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd g')) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map g g') h)","decl":"@[reassoc]\ntheorem prod.diag_map_fst_snd_comp [HasLimitsOfShape (Discrete WalkingPair) C] {X X' Y Y' : C}\n    (g : X ⟶ Y) (g' : X' ⟶ Y') :\n    diag (X ⨯ X') ≫ prod.map (prod.fst ≫ g) (prod.snd ≫ g') = prod.map g g' := by simp\n\n"}
{"name":"CategoryTheory.Limits.instIsSplitMonoDiag","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X X\n⊢ CategoryTheory.IsSplitMono (CategoryTheory.Limits.diag X)","decl":"instance {X : C} [HasBinaryProduct X X] : IsSplitMono (diag X) :=\n  IsSplitMono.mk' { retraction := prod.fst }\n\n"}
{"name":"CategoryTheory.Limits.coprod.desc_comp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nV W X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom V W\ng : Quiver.Hom X V\nh✝ : Quiver.Hom Y V\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc g h✝) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.comp h✝ f)) h)","decl":"@[reassoc, simp]\ntheorem coprod.desc_comp {V W X Y : C} [HasBinaryCoproduct X Y] (f : V ⟶ W) (g : X ⟶ V)\n    (h : Y ⟶ V) : coprod.desc g h ≫ f = coprod.desc (g ≫ f) (h ≫ f) := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.desc_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nV W X Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\nf : Quiver.Hom V W\ng : Quiver.Hom X V\nh : Quiver.Hom Y V\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc g h) f) (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.comp h f))","decl":"@[reassoc, simp]\ntheorem coprod.desc_comp {V W X Y : C} [HasBinaryCoproduct X Y] (f : V ⟶ W) (g : X ⟶ V)\n    (h : Y ⟶ V) : coprod.desc g h ≫ f = coprod.desc (g ≫ f) (h ≫ f) := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.diag_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X X\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.codiag X) f) (CategoryTheory.Limits.coprod.desc f f)","decl":"theorem coprod.diag_comp {X Y : C} [HasBinaryCoproduct X X] (f : X ⟶ Y) :\n    codiag X ≫ f = coprod.desc f f := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.inl_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.Limits.coprod.map f g)) (CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.coprod.inl)","decl":"@[reassoc (attr := simp)]\ntheorem coprod.inl_map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : coprod.inl ≫ coprod.map f g = f ≫ coprod.inl :=\n  ι_colimMap _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.inl_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct Y Z✝\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod Y Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f g) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl h))","decl":"@[reassoc (attr := simp)]\ntheorem coprod.inl_map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : coprod.inl ≫ coprod.map f g = f ≫ coprod.inl :=\n  ι_colimMap _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.inr_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct Y Z✝\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod Y Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f g) h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr h))","decl":"@[reassoc (attr := simp)]\ntheorem coprod.inr_map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : coprod.inr ≫ coprod.map f g = g ≫ coprod.inr :=\n  ι_colimMap _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.inr_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.Limits.coprod.map f g)) (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.coprod.inr)","decl":"@[reassoc (attr := simp)]\ntheorem coprod.inr_map {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) : coprod.inr ≫ coprod.map f g = g ≫ coprod.inr :=\n  ι_colimMap _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_id_id","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\n⊢ Eq (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.coprod X Y))","decl":"@[simp]\ntheorem coprod.map_id_id {X Y : C} [HasBinaryCoproduct X Y] : coprod.map (𝟙 X) (𝟙 Y) = 𝟙 _ := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.desc_inl_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Y\n⊢ Eq (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inr) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.coprod X Y))","decl":"@[simp]\ntheorem coprod.desc_inl_inr {X Y : C} [HasBinaryCoproduct X Y] :\n    coprod.desc coprod.inl coprod.inr = 𝟙 (X ⨿ Y) := by ext <;> simp\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n"}
{"name":"CategoryTheory.Limits.coprod.map_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nS T U V W : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct U W\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct T V\nf : Quiver.Hom U S\ng : Quiver.Hom W S\nh : Quiver.Hom T U\nk : Quiver.Hom V W\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map h k) (CategoryTheory.Limits.coprod.desc f g)) (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp k g))","decl":"@[reassoc, simp]\ntheorem coprod.map_desc {S T U V W : C} [HasBinaryCoproduct U W] [HasBinaryCoproduct T V]\n    (f : U ⟶ S) (g : W ⟶ S) (h : T ⟶ U) (k : V ⟶ W) :\n    coprod.map h k ≫ coprod.desc f g = coprod.desc (h ≫ f) (k ≫ g) := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nS T U V W : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct U W\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct T V\nf : Quiver.Hom U S\ng : Quiver.Hom W S\nh✝ : Quiver.Hom T U\nk : Quiver.Hom V W\nZ : C\nh : Quiver.Hom S Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map h✝ k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc f g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp h✝ f) (CategoryTheory.CategoryStruct.comp k g)) h)","decl":"@[reassoc, simp]\ntheorem coprod.map_desc {S T U V W : C} [HasBinaryCoproduct U W] [HasBinaryCoproduct T V]\n    (f : U ⟶ S) (g : W ⟶ S) (h : T ⟶ U) (k : V ⟶ W) :\n    coprod.map h k ≫ coprod.desc f g = coprod.desc (h ≫ f) (k ≫ g) := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.desc_comp_inl_comp_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct W Y\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X Z\ng : Quiver.Hom W X\ng' : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.coprod.inl) (CategoryTheory.CategoryStruct.comp g' CategoryTheory.Limits.coprod.inr)) (CategoryTheory.Limits.coprod.map g g')","decl":"@[simp]\ntheorem coprod.desc_comp_inl_comp_inr {W X Y Z : C} [HasBinaryCoproduct W Y]\n    [HasBinaryCoproduct X Z] (g : W ⟶ X) (g' : Y ⟶ Z) :\n    coprod.desc (g ≫ coprod.inl) (g' ≫ coprod.inr) = coprod.map g g' := by\n  rw [← coprod.map_desc]; simp\n\n-- We take the right hand side here to be simp normal form, as this way composition lemmas for\n-- `f ≫ h` and `g ≫ k` can fire (eg `id_comp`) , while `inl_map` and `inr_map` can still work just\n-- as well.\n"}
{"name":"CategoryTheory.Limits.coprod.map_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nA₁ A₂ A₃ B₁ B₂ B₃ : C\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct A₁ B₁\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct A₂ B₂\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct A₃ B₃\nf : Quiver.Hom A₁ A₂\ng : Quiver.Hom B₁ B₂\nh : Quiver.Hom A₂ A₃\nk : Quiver.Hom B₂ B₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f g) (CategoryTheory.Limits.coprod.map h k)) (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g k))","decl":"@[reassoc (attr := simp)]\ntheorem coprod.map_map {A₁ A₂ A₃ B₁ B₂ B₃ : C} [HasBinaryCoproduct A₁ B₁] [HasBinaryCoproduct A₂ B₂]\n    [HasBinaryCoproduct A₃ B₃] (f : A₁ ⟶ A₂) (g : B₁ ⟶ B₂) (h : A₂ ⟶ A₃) (k : B₂ ⟶ B₃) :\n    coprod.map f g ≫ coprod.map h k = coprod.map (f ≫ h) (g ≫ k) := by\n  ext <;> simp\n\n-- I don't think it's a good idea to make any of the following three simp lemmas.\n"}
{"name":"CategoryTheory.Limits.coprod.map_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nA₁ A₂ A₃ B₁ B₂ B₃ : C\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct A₁ B₁\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct A₂ B₂\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct A₃ B₃\nf : Quiver.Hom A₁ A₂\ng : Quiver.Hom B₁ B₂\nh✝ : Quiver.Hom A₂ A₃\nk : Quiver.Hom B₂ B₃\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod A₃ B₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map h✝ k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.comp f h✝) (CategoryTheory.CategoryStruct.comp g k)) h)","decl":"@[reassoc (attr := simp)]\ntheorem coprod.map_map {A₁ A₂ A₃ B₁ B₂ B₃ : C} [HasBinaryCoproduct A₁ B₁] [HasBinaryCoproduct A₂ B₂]\n    [HasBinaryCoproduct A₃ B₃] (f : A₁ ⟶ A₂) (g : B₁ ⟶ B₂) (h : A₂ ⟶ A₃) (k : B₂ ⟶ B₃) :\n    coprod.map f g ≫ coprod.map h k = coprod.map (f ≫ h) (g ≫ k) := by\n  ext <;> simp\n\n-- I don't think it's a good idea to make any of the following three simp lemmas.\n"}
{"name":"CategoryTheory.Limits.coprod.map_swap_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B X Y : C\nf : Quiver.Hom A B\ng : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod Y B) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id X) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map g (CategoryTheory.CategoryStruct.id B)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map g (CategoryTheory.CategoryStruct.id A)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id Y) f) h))","decl":"@[reassoc]\ntheorem coprod.map_swap {A B X Y : C} (f : A ⟶ B) (g : X ⟶ Y)\n    [HasColimitsOfShape (Discrete WalkingPair) C] :\n    coprod.map (𝟙 X) f ≫ coprod.map g (𝟙 B) = coprod.map g (𝟙 A) ≫ coprod.map (𝟙 Y) f := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_swap","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B X Y : C\nf : Quiver.Hom A B\ng : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id X) f) (CategoryTheory.Limits.coprod.map g (CategoryTheory.CategoryStruct.id B))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map g (CategoryTheory.CategoryStruct.id A)) (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id Y) f))","decl":"@[reassoc]\ntheorem coprod.map_swap {A B X Y : C} (f : A ⟶ B) (g : X ⟶ Y)\n    [HasColimitsOfShape (Discrete WalkingPair) C] :\n    coprod.map (𝟙 X) f ≫ coprod.map g (𝟙 B) = coprod.map g (𝟙 A) ≫ coprod.map (𝟙 Y) f := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_comp_id_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z✝ W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct Z✝ W\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct Y W\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X W\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod Z✝ W) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id W)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map g (CategoryTheory.CategoryStruct.id W)) h))","decl":"@[reassoc]\ntheorem coprod.map_comp_id {X Y Z W : C} (f : X ⟶ Y) (g : Y ⟶ Z) [HasBinaryCoproduct Z W]\n    [HasBinaryCoproduct Y W] [HasBinaryCoproduct X W] :\n    coprod.map (f ≫ g) (𝟙 W) = coprod.map f (𝟙 W) ≫ coprod.map g (𝟙 W) := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_comp_id","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct Z W\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct Y W\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct X W\n⊢ Eq (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.Limits.coprod.map g (CategoryTheory.CategoryStruct.id W)))","decl":"@[reassoc]\ntheorem coprod.map_comp_id {X Y Z W : C} (f : X ⟶ Y) (g : Y ⟶ Z) [HasBinaryCoproduct Z W]\n    [HasBinaryCoproduct Y W] [HasBinaryCoproduct X W] :\n    coprod.map (f ≫ g) (𝟙 W) = coprod.map f (𝟙 W) ≫ coprod.map g (𝟙 W) := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_id_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct W Y\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct W Z\n⊢ Eq (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) f) (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) g))","decl":"@[reassoc]\ntheorem coprod.map_id_comp {X Y Z W : C} (f : X ⟶ Y) (g : Y ⟶ Z) [HasBinaryCoproduct W X]\n    [HasBinaryCoproduct W Y] [HasBinaryCoproduct W Z] :\n    coprod.map (𝟙 W) (f ≫ g) = coprod.map (𝟙 W) f ≫ coprod.map (𝟙 W) g := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_id_comp_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nX Y Z✝ W : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct W Y\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct W Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod W Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) g) h))","decl":"@[reassoc]\ntheorem coprod.map_id_comp {X Y Z W : C} (f : X ⟶ Y) (g : Y ⟶ Z) [HasBinaryCoproduct W X]\n    [HasBinaryCoproduct W Y] [HasBinaryCoproduct W Z] :\n    coprod.map (𝟙 W) (f ≫ g) = coprod.map (𝟙 W) f ≫ coprod.map (𝟙 W) g := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.mapIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct Y Z\nf : CategoryTheory.Iso W Y\ng : CategoryTheory.Iso X Z\n⊢ Eq (CategoryTheory.Limits.coprod.mapIso f g).hom (CategoryTheory.Limits.coprod.map f.hom g.hom)","decl":"/-- If the coproducts `W ⨿ X` and `Y ⨿ Z` exist, then every pair of isomorphisms `f : W ≅ Y` and\n   `g : W ≅ Z` induces an isomorphism `coprod.mapIso f g : W ⨿ X ≅ Y ⨿ Z`. -/\n@[simps]\ndef coprod.mapIso {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ≅ Y)\n    (g : X ≅ Z) : W ⨿ X ≅ Y ⨿ Z where\n  hom := coprod.map f.hom g.hom\n  inv := coprod.map f.inv g.inv\n\n"}
{"name":"CategoryTheory.Limits.coprod.mapIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct Y Z\nf : CategoryTheory.Iso W Y\ng : CategoryTheory.Iso X Z\n⊢ Eq (CategoryTheory.Limits.coprod.mapIso f g).inv (CategoryTheory.Limits.coprod.map f.inv g.inv)","decl":"/-- If the coproducts `W ⨿ X` and `Y ⨿ Z` exist, then every pair of isomorphisms `f : W ≅ Y` and\n   `g : W ≅ Z` induces an isomorphism `coprod.mapIso f g : W ⨿ X ≅ Y ⨿ Z`. -/\n@[simps]\ndef coprod.mapIso {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ≅ Y)\n    (g : X ≅ Z) : W ⨿ X ≅ Y ⨿ Z where\n  hom := coprod.map f.hom g.hom\n  inv := coprod.map f.inv g.inv\n\n"}
{"name":"CategoryTheory.Limits.isIso_coprod","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\ninst✝³ : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct Y Z\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.IsIso f\ninst✝ : CategoryTheory.IsIso g\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.coprod.map f g)","decl":"instance isIso_coprod {W X Y Z : C} [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] (f : W ⟶ Y)\n    (g : X ⟶ Z) [IsIso f] [IsIso g] : IsIso (coprod.map f g) :=\n  (coprod.mapIso (asIso f) (asIso g)).isIso_hom\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\nW X Y Z : C\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\ninst✝³ : CategoryTheory.Epi f\ninst✝² : CategoryTheory.Epi g\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct W X\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct Y Z\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.coprod.map f g)","decl":"instance coprod.map_epi {C : Type*} [Category C] {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z) [Epi f]\n    [Epi g] [HasBinaryCoproduct W X] [HasBinaryCoproduct Y Z] : Epi (coprod.map f g) :=\n  ⟨fun i₁ i₂ h => by\n    ext\n    · rw [← cancel_epi f]\n      simpa using congr_arg (fun f => coprod.inl ≫ f) h\n    · rw [← cancel_epi g]\n      simpa using congr_arg (fun f => coprod.inr ≫ f) h⟩\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: and the og version too\n"}
{"name":"CategoryTheory.Limits.coprod.map_codiag_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct X X\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct Y Y\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.codiag Y) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.codiag X) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc]\ntheorem coprod.map_codiag {X Y : C} (f : X ⟶ Y) [HasBinaryCoproduct X X] [HasBinaryCoproduct Y Y] :\n    coprod.map f f ≫ codiag Y = codiag X ≫ f := by simp\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: and the og version too\n"}
{"name":"CategoryTheory.Limits.coprod.map_codiag","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct X X\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct Y Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map f f) (CategoryTheory.Limits.codiag Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.codiag X) f)","decl":"@[reassoc]\ntheorem coprod.map_codiag {X Y : C} (f : X ⟶ Y) [HasBinaryCoproduct X X] [HasBinaryCoproduct Y Y] :\n    coprod.map f f ≫ codiag Y = codiag X ≫ f := by simp\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: and the og version too\n"}
{"name":"CategoryTheory.Limits.coprod.map_inl_inr_codiag","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct (CategoryTheory.Limits.coprod X Y) (CategoryTheory.Limits.coprod X Y)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inr) (CategoryTheory.Limits.codiag (CategoryTheory.Limits.coprod X Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.coprod X Y))","decl":"@[reassoc]\ntheorem coprod.map_inl_inr_codiag {X Y : C} [HasBinaryCoproduct X Y]\n    [HasBinaryCoproduct (X ⨿ Y) (X ⨿ Y)] :\n    coprod.map coprod.inl coprod.inr ≫ codiag (X ⨿ Y) = 𝟙 (X ⨿ Y) := by simp\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: and the og version too\n"}
{"name":"CategoryTheory.Limits.coprod.map_inl_inr_codiag_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct (CategoryTheory.Limits.coprod X Y) (CategoryTheory.Limits.coprod X Y)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inr) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.codiag (CategoryTheory.Limits.coprod X Y)) h)) h","decl":"@[reassoc]\ntheorem coprod.map_inl_inr_codiag {X Y : C} [HasBinaryCoproduct X Y]\n    [HasBinaryCoproduct (X ⨿ Y) (X ⨿ Y)] :\n    coprod.map coprod.inl coprod.inr ≫ codiag (X ⨿ Y) = 𝟙 (X ⨿ Y) := by simp\n\n-- The simp linter says simp can prove the reassoc version of this lemma.\n-- Porting note: and the og version too\n"}
{"name":"CategoryTheory.Limits.coprod.map_comp_inl_inr_codiag","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nX X' Y Y' : C\ng : Quiver.Hom X Y\ng' : Quiver.Hom X' Y'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.coprod.inl) (CategoryTheory.CategoryStruct.comp g' CategoryTheory.Limits.coprod.inr)) (CategoryTheory.Limits.codiag (CategoryTheory.Limits.coprod Y Y'))) (CategoryTheory.Limits.coprod.map g g')","decl":"@[reassoc]\ntheorem coprod.map_comp_inl_inr_codiag [HasColimitsOfShape (Discrete WalkingPair) C] {X X' Y Y' : C}\n    (g : X ⟶ Y) (g' : X' ⟶ Y') :\n    coprod.map (g ≫ coprod.inl) (g' ≫ coprod.inr) ≫ codiag (Y ⨿ Y') = coprod.map g g' := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.map_comp_inl_inr_codiag_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nX X' Y Y' : C\ng : Quiver.Hom X Y\ng' : Quiver.Hom X' Y'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod Y Y') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.coprod.inl) (CategoryTheory.CategoryStruct.comp g' CategoryTheory.Limits.coprod.inr)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.codiag (CategoryTheory.Limits.coprod Y Y')) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map g g') h)","decl":"@[reassoc]\ntheorem coprod.map_comp_inl_inr_codiag [HasColimitsOfShape (Discrete WalkingPair) C] {X X' Y Y' : C}\n    (g : X ⟶ Y) (g' : X' ⟶ Y') :\n    coprod.map (g ≫ coprod.inl) (g' ≫ coprod.inr) ≫ codiag (Y ⨿ Y') = coprod.map g g' := by simp\n\n"}
{"name":"CategoryTheory.Limits.hasBinaryProducts_of_hasLimit_pair","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ {X Y : C}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)\n⊢ CategoryTheory.Limits.HasBinaryProducts C","decl":"/-- If `C` has all limits of diagrams `pair X Y`, then it has all binary products -/\ntheorem hasBinaryProducts_of_hasLimit_pair [∀ {X Y : C}, HasLimit (pair X Y)] :\n    HasBinaryProducts C :=\n  { has_limit := fun F => hasLimitOfIso (diagramIsoPair F).symm }\n\n"}
{"name":"CategoryTheory.Limits.hasBinaryCoproducts_of_hasColimit_pair","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : ∀ {X Y : C}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)\n⊢ CategoryTheory.Limits.HasBinaryCoproducts C","decl":"/-- If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts -/\ntheorem hasBinaryCoproducts_of_hasColimit_pair [∀ {X Y : C}, HasColimit (pair X Y)] :\n    HasBinaryCoproducts C :=\n  { has_colimit := fun F => hasColimitOfIso (diagramIsoPair F) }\n\n"}
{"name":"CategoryTheory.Limits.prod.braiding_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nP Q : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct P Q\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Q P\n⊢ Eq (CategoryTheory.Limits.prod.braiding P Q).inv (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)","decl":"/-- The braiding isomorphism which swaps a binary product. -/\n@[simps]\ndef prod.braiding (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] : P ⨯ Q ≅ Q ⨯ P where\n  hom := prod.lift prod.snd prod.fst\n  inv := prod.lift prod.snd prod.fst\n\n"}
{"name":"CategoryTheory.Limits.prod.braiding_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nP Q : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct P Q\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Q P\n⊢ Eq (CategoryTheory.Limits.prod.braiding P Q).hom (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)","decl":"/-- The braiding isomorphism which swaps a binary product. -/\n@[simps]\ndef prod.braiding (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] : P ⨯ Q ≅ Q ⨯ P where\n  hom := prod.lift prod.snd prod.fst\n  inv := prod.lift prod.snd prod.fst\n\n"}
{"name":"CategoryTheory.Limits.braid_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z✝ W\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod W Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.braiding Y W).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.braiding X Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map g f) h))","decl":"/-- The braiding isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem braid_natural [HasBinaryProducts C] {W X Y Z : C} (f : X ⟶ Y) (g : Z ⟶ W) :\n    prod.map f g ≫ (prod.braiding _ _).hom = (prod.braiding _ _).hom ≫ prod.map g f := by simp\n\n"}
{"name":"CategoryTheory.Limits.braid_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Z W\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f g) (CategoryTheory.Limits.prod.braiding Y W).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.braiding X Z).hom (CategoryTheory.Limits.prod.map g f))","decl":"/-- The braiding isomorphism can be passed through a map by swapping the order. -/\n@[reassoc]\ntheorem braid_natural [HasBinaryProducts C] {W X Y Z : C} (f : X ⟶ Y) (g : Z ⟶ W) :\n    prod.map f g ≫ (prod.braiding _ _).hom = (prod.braiding _ _).hom ≫ prod.map g f := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.symmetry'","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nP Q : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct P Q\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Q P\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst) (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.prod P Q))","decl":"@[reassoc]\ntheorem prod.symmetry' (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] :\n    prod.lift prod.snd prod.fst ≫ prod.lift prod.snd prod.fst = 𝟙 (P ⨯ Q) :=\n  (prod.braiding _ _).hom_inv_id\n\n"}
{"name":"CategoryTheory.Limits.prod.symmetry'_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nP Q : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct P Q\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Q P\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod P Q) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst) h)) h","decl":"@[reassoc]\ntheorem prod.symmetry' (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] :\n    prod.lift prod.snd prod.fst ≫ prod.lift prod.snd prod.fst = 𝟙 (P ⨯ Q) :=\n  (prod.braiding _ _).hom_inv_id\n\n"}
{"name":"CategoryTheory.Limits.prod.symmetry_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nP Q : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct P Q\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Q P\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod P Q) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.braiding P Q).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.braiding Q P).hom h)) h","decl":"/-- The braiding isomorphism is symmetric. -/\n@[reassoc]\ntheorem prod.symmetry (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] :\n    (prod.braiding P Q).hom ≫ (prod.braiding Q P).hom = 𝟙 _ :=\n  (prod.braiding _ _).hom_inv_id\n\n"}
{"name":"CategoryTheory.Limits.prod.symmetry","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nP Q : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct P Q\ninst✝ : CategoryTheory.Limits.HasBinaryProduct Q P\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.braiding P Q).hom (CategoryTheory.Limits.prod.braiding Q P).hom) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.prod P Q))","decl":"/-- The braiding isomorphism is symmetric. -/\n@[reassoc]\ntheorem prod.symmetry (P Q : C) [HasBinaryProduct P Q] [HasBinaryProduct Q P] :\n    (prod.braiding P Q).hom ≫ (prod.braiding Q P).hom = 𝟙 _ :=\n  (prod.braiding _ _).hom_inv_id\n\n"}
{"name":"CategoryTheory.Limits.prod.associator_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nP Q R : C\n⊢ Eq (CategoryTheory.Limits.prod.associator P Q R).hom (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd) CategoryTheory.Limits.prod.snd))","decl":"/-- The associator isomorphism for binary products. -/\n@[simps]\ndef prod.associator [HasBinaryProducts C] (P Q R : C) : (P ⨯ Q) ⨯ R ≅ P ⨯ Q ⨯ R where\n  hom := prod.lift (prod.fst ≫ prod.fst) (prod.lift (prod.fst ≫ prod.snd) prod.snd)\n  inv := prod.lift (prod.lift prod.fst (prod.snd ≫ prod.fst)) (prod.snd ≫ prod.snd)\n\n"}
{"name":"CategoryTheory.Limits.prod.associator_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nP Q R : C\n⊢ Eq (CategoryTheory.Limits.prod.associator P Q R).inv (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd))","decl":"/-- The associator isomorphism for binary products. -/\n@[simps]\ndef prod.associator [HasBinaryProducts C] (P Q R : C) : (P ⨯ Q) ⨯ R ≅ P ⨯ Q ⨯ R where\n  hom := prod.lift (prod.fst ≫ prod.fst) (prod.lift (prod.fst ≫ prod.snd) prod.snd)\n  inv := prod.lift (prod.lift prod.fst (prod.snd ≫ prod.fst)) (prod.snd ≫ prod.snd)\n\n"}
{"name":"CategoryTheory.Limits.prod.pentagon","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.Limits.prod.associator W X Y).hom (CategoryTheory.CategoryStruct.id Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator W (CategoryTheory.Limits.prod X Y) Z).hom (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.Limits.prod.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator (CategoryTheory.Limits.prod W X) Y Z).hom (CategoryTheory.Limits.prod.associator W X (CategoryTheory.Limits.prod Y Z)).hom)","decl":"@[reassoc]\ntheorem prod.pentagon [HasBinaryProducts C] (W X Y Z : C) :\n    prod.map (prod.associator W X Y).hom (𝟙 Z) ≫\n        (prod.associator W (X ⨯ Y) Z).hom ≫ prod.map (𝟙 W) (prod.associator X Y Z).hom =\n      (prod.associator (W ⨯ X) Y Z).hom ≫ (prod.associator W X (Y ⨯ Z)).hom := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.prod.pentagon_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nW X Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.Limits.prod W (CategoryTheory.Limits.prod X (CategoryTheory.Limits.prod Y Z✝))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.Limits.prod.associator W X Y).hom (CategoryTheory.CategoryStruct.id Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator W (CategoryTheory.Limits.prod X Y) Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.Limits.prod.associator X Y Z✝).hom) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator (CategoryTheory.Limits.prod W X) Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator W X (CategoryTheory.Limits.prod Y Z✝)).hom h))","decl":"@[reassoc]\ntheorem prod.pentagon [HasBinaryProducts C] (W X Y Z : C) :\n    prod.map (prod.associator W X Y).hom (𝟙 Z) ≫\n        (prod.associator W (X ⨯ Y) Z).hom ≫ prod.map (𝟙 W) (prod.associator X Y Z).hom =\n      (prod.associator (W ⨯ X) Y Z).hom ≫ (prod.associator W X (Y ⨯ Z)).hom := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.prod.associator_naturality","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nX₁ X₂ X₃ Y₁ Y₂ Y₃ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\nf₃ : Quiver.Hom X₃ Y₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.Limits.prod.map f₁ f₂) f₃) (CategoryTheory.Limits.prod.associator Y₁ Y₂ Y₃).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator X₁ X₂ X₃).hom (CategoryTheory.Limits.prod.map f₁ (CategoryTheory.Limits.prod.map f₂ f₃)))","decl":"@[reassoc]\ntheorem prod.associator_naturality [HasBinaryProducts C] {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁)\n    (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃) :\n    prod.map (prod.map f₁ f₂) f₃ ≫ (prod.associator Y₁ Y₂ Y₃).hom =\n      (prod.associator X₁ X₂ X₃).hom ≫ prod.map f₁ (prod.map f₂ f₃) := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.prod.associator_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nX₁ X₂ X₃ Y₁ Y₂ Y₃ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\nf₃ : Quiver.Hom X₃ Y₃\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y₁ (CategoryTheory.Limits.prod Y₂ Y₃)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.Limits.prod.map f₁ f₂) f₃) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator Y₁ Y₂ Y₃).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator X₁ X₂ X₃).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f₁ (CategoryTheory.Limits.prod.map f₂ f₃)) h))","decl":"@[reassoc]\ntheorem prod.associator_naturality [HasBinaryProducts C] {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁)\n    (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃) :\n    prod.map (prod.map f₁ f₂) f₃ ≫ (prod.associator Y₁ Y₂ Y₃).hom =\n      (prod.associator X₁ X₂ X₃).hom ≫ prod.map f₁ (prod.map f₂ f₃) := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.prod.leftUnitor_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\nP : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct (CategoryTheory.Limits.terminal C) P\n⊢ Eq (CategoryTheory.Limits.prod.leftUnitor P).hom CategoryTheory.Limits.prod.snd","decl":"/-- The left unitor isomorphism for binary products with the terminal object. -/\n@[simps]\ndef prod.leftUnitor (P : C) [HasBinaryProduct (⊤_ C) P] : (⊤_ C) ⨯ P ≅ P where\n  hom := prod.snd\n  inv := prod.lift (terminal.from P) (𝟙 _)\n  hom_inv_id := by apply prod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.leftUnitor_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\nP : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct (CategoryTheory.Limits.terminal C) P\n⊢ Eq (CategoryTheory.Limits.prod.leftUnitor P).inv (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.terminal.from P) (CategoryTheory.CategoryStruct.id P))","decl":"/-- The left unitor isomorphism for binary products with the terminal object. -/\n@[simps]\ndef prod.leftUnitor (P : C) [HasBinaryProduct (⊤_ C) P] : (⊤_ C) ⨯ P ≅ P where\n  hom := prod.snd\n  inv := prod.lift (terminal.from P) (𝟙 _)\n  hom_inv_id := by apply prod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.rightUnitor_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\nP : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct P (CategoryTheory.Limits.terminal C)\n⊢ Eq (CategoryTheory.Limits.prod.rightUnitor P).inv (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id P) (CategoryTheory.Limits.terminal.from P))","decl":"/-- The right unitor isomorphism for binary products with the terminal object. -/\n@[simps]\ndef prod.rightUnitor (P : C) [HasBinaryProduct P (⊤_ C)] : P ⨯ ⊤_ C ≅ P where\n  hom := prod.fst\n  inv := prod.lift (𝟙 _) (terminal.from P)\n  hom_inv_id := by apply prod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.rightUnitor_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\nP : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct P (CategoryTheory.Limits.terminal C)\n⊢ Eq (CategoryTheory.Limits.prod.rightUnitor P).hom CategoryTheory.Limits.prod.fst","decl":"/-- The right unitor isomorphism for binary products with the terminal object. -/\n@[simps]\ndef prod.rightUnitor (P : C) [HasBinaryProduct P (⊤_ C)] : P ⨯ ⊤_ C ≅ P where\n  hom := prod.fst\n  inv := prod.lift (𝟙 _) (terminal.from P)\n  hom_inv_id := by apply prod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.prod.leftUnitor_hom_naturality","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C)) f) (CategoryTheory.Limits.prod.leftUnitor Y).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor X).hom f)","decl":"@[reassoc]\ntheorem prod.leftUnitor_hom_naturality [HasBinaryProducts C] (f : X ⟶ Y) :\n    prod.map (𝟙 _) f ≫ (prod.leftUnitor Y).hom = (prod.leftUnitor X).hom ≫ f :=\n  prod.map_snd _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.leftUnitor_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C)) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor Y).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor X).hom (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc]\ntheorem prod.leftUnitor_hom_naturality [HasBinaryProducts C] (f : X ⟶ Y) :\n    prod.map (𝟙 _) f ≫ (prod.leftUnitor Y).hom = (prod.leftUnitor X).hom ≫ f :=\n  prod.map_snd _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.leftUnitor_inv_naturality","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor X).inv (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C)) f)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.prod.leftUnitor Y).inv)","decl":"@[reassoc]\ntheorem prod.leftUnitor_inv_naturality [HasBinaryProducts C] (f : X ⟶ Y) :\n    (prod.leftUnitor X).inv ≫ prod.map (𝟙 _) f = f ≫ (prod.leftUnitor Y).inv := by\n  rw [Iso.inv_comp_eq, ← Category.assoc, Iso.eq_comp_inv, prod.leftUnitor_hom_naturality]\n\n"}
{"name":"CategoryTheory.Limits.prod.leftUnitor_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod (CategoryTheory.Limits.terminal C) Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C)) f) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.leftUnitor Y).inv h))","decl":"@[reassoc]\ntheorem prod.leftUnitor_inv_naturality [HasBinaryProducts C] (f : X ⟶ Y) :\n    (prod.leftUnitor X).inv ≫ prod.map (𝟙 _) f = f ≫ (prod.leftUnitor Y).inv := by\n  rw [Iso.inv_comp_eq, ← Category.assoc, Iso.eq_comp_inv, prod.leftUnitor_hom_naturality]\n\n"}
{"name":"CategoryTheory.Limits.prod.rightUnitor_hom_naturality","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C))) (CategoryTheory.Limits.prod.rightUnitor Y).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.rightUnitor X).hom f)","decl":"@[reassoc]\ntheorem prod.rightUnitor_hom_naturality [HasBinaryProducts C] (f : X ⟶ Y) :\n    prod.map f (𝟙 _) ≫ (prod.rightUnitor Y).hom = (prod.rightUnitor X).hom ≫ f :=\n  prod.map_fst _ _\n\n"}
{"name":"CategoryTheory.Limits.prod.rightUnitor_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.rightUnitor Y).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.rightUnitor X).hom (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc]\ntheorem prod.rightUnitor_hom_naturality [HasBinaryProducts C] (f : X ⟶ Y) :\n    prod.map f (𝟙 _) ≫ (prod.rightUnitor Y).hom = (prod.rightUnitor X).hom ≫ f :=\n  prod.map_fst _ _\n\n"}
{"name":"CategoryTheory.Limits.prod_rightUnitor_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.prod Y (CategoryTheory.Limits.terminal C)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.rightUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C))) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.rightUnitor Y).inv h))","decl":"@[reassoc]\ntheorem prod_rightUnitor_inv_naturality [HasBinaryProducts C] (f : X ⟶ Y) :\n    (prod.rightUnitor X).inv ≫ prod.map f (𝟙 _) = f ≫ (prod.rightUnitor Y).inv := by\n  rw [Iso.inv_comp_eq, ← Category.assoc, Iso.eq_comp_inv, prod.rightUnitor_hom_naturality]\n\n"}
{"name":"CategoryTheory.Limits.prod_rightUnitor_inv_naturality","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.rightUnitor X).inv (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.terminal C)))) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.prod.rightUnitor Y).inv)","decl":"@[reassoc]\ntheorem prod_rightUnitor_inv_naturality [HasBinaryProducts C] (f : X ⟶ Y) :\n    (prod.rightUnitor X).inv ≫ prod.map f (𝟙 _) = f ≫ (prod.rightUnitor Y).inv := by\n  rw [Iso.inv_comp_eq, ← Category.assoc, Iso.eq_comp_inv, prod.rightUnitor_hom_naturality]\n\n"}
{"name":"CategoryTheory.Limits.prod.triangle","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.associator X (CategoryTheory.Limits.terminal C) Y).hom (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) (CategoryTheory.Limits.prod.leftUnitor Y).hom)) (CategoryTheory.Limits.prod.map (CategoryTheory.Limits.prod.rightUnitor X).hom (CategoryTheory.CategoryStruct.id Y))","decl":"theorem prod.triangle [HasBinaryProducts C] (X Y : C) :\n    (prod.associator X (⊤_ C) Y).hom ≫ prod.map (𝟙 X) (prod.leftUnitor Y).hom =\n      prod.map (prod.rightUnitor X).hom (𝟙 Y) := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.braiding_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q : C\n⊢ Eq (CategoryTheory.Limits.coprod.braiding P Q).inv (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl)","decl":"/-- The braiding isomorphism which swaps a binary coproduct. -/\n@[simps]\ndef coprod.braiding (P Q : C) : P ⨿ Q ≅ Q ⨿ P where\n  hom := coprod.desc coprod.inr coprod.inl\n  inv := coprod.desc coprod.inr coprod.inl\n\n"}
{"name":"CategoryTheory.Limits.coprod.braiding_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q : C\n⊢ Eq (CategoryTheory.Limits.coprod.braiding P Q).hom (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl)","decl":"/-- The braiding isomorphism which swaps a binary coproduct. -/\n@[simps]\ndef coprod.braiding (P Q : C) : P ⨿ Q ≅ Q ⨿ P where\n  hom := coprod.desc coprod.inr coprod.inl\n  inv := coprod.desc coprod.inr coprod.inl\n\n"}
{"name":"CategoryTheory.Limits.coprod.symmetry'","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl) (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.coprod P Q))","decl":"@[reassoc]\ntheorem coprod.symmetry' (P Q : C) :\n    coprod.desc coprod.inr coprod.inl ≫ coprod.desc coprod.inr coprod.inl = 𝟙 (P ⨿ Q) :=\n  (coprod.braiding _ _).hom_inv_id\n\n"}
{"name":"CategoryTheory.Limits.coprod.symmetry'_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q Z : C\nh : Quiver.Hom (CategoryTheory.Limits.coprod P Q) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl) h)) h","decl":"@[reassoc]\ntheorem coprod.symmetry' (P Q : C) :\n    coprod.desc coprod.inr coprod.inl ≫ coprod.desc coprod.inr coprod.inl = 𝟙 (P ⨿ Q) :=\n  (coprod.braiding _ _).hom_inv_id\n\n"}
{"name":"CategoryTheory.Limits.coprod.symmetry","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.braiding P Q).hom (CategoryTheory.Limits.coprod.braiding Q P).hom) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.coprod P Q))","decl":"/-- The braiding isomorphism is symmetric. -/\ntheorem coprod.symmetry (P Q : C) : (coprod.braiding P Q).hom ≫ (coprod.braiding Q P).hom = 𝟙 _ :=\n  coprod.symmetry' _ _\n\n"}
{"name":"CategoryTheory.Limits.coprod.associator_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q R : C\n⊢ Eq (CategoryTheory.Limits.coprod.associator P Q R).hom (CategoryTheory.Limits.coprod.desc (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.coprod.inl (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inr)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inr))","decl":"/-- The associator isomorphism for binary coproducts. -/\n@[simps]\ndef coprod.associator (P Q R : C) : (P ⨿ Q) ⨿ R ≅ P ⨿ Q ⨿ R where\n  hom := coprod.desc (coprod.desc coprod.inl (coprod.inl ≫ coprod.inr)) (coprod.inr ≫ coprod.inr)\n  inv := coprod.desc (coprod.inl ≫ coprod.inl) (coprod.desc (coprod.inr ≫ coprod.inl) coprod.inr)\n\n"}
{"name":"CategoryTheory.Limits.coprod.associator_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nP Q R : C\n⊢ Eq (CategoryTheory.Limits.coprod.associator P Q R).inv (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl CategoryTheory.Limits.coprod.inl) (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr CategoryTheory.Limits.coprod.inl) CategoryTheory.Limits.coprod.inr))","decl":"/-- The associator isomorphism for binary coproducts. -/\n@[simps]\ndef coprod.associator (P Q R : C) : (P ⨿ Q) ⨿ R ≅ P ⨿ Q ⨿ R where\n  hom := coprod.desc (coprod.desc coprod.inl (coprod.inl ≫ coprod.inr)) (coprod.inr ≫ coprod.inr)\n  inv := coprod.desc (coprod.inl ≫ coprod.inl) (coprod.desc (coprod.inr ≫ coprod.inl) coprod.inr)\n\n"}
{"name":"CategoryTheory.Limits.coprod.pentagon","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.Limits.coprod.associator W X Y).hom (CategoryTheory.CategoryStruct.id Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.associator W (CategoryTheory.Limits.coprod X Y) Z).hom (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id W) (CategoryTheory.Limits.coprod.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.associator (CategoryTheory.Limits.coprod W X) Y Z).hom (CategoryTheory.Limits.coprod.associator W X (CategoryTheory.Limits.coprod Y Z)).hom)","decl":"theorem coprod.pentagon (W X Y Z : C) :\n    coprod.map (coprod.associator W X Y).hom (𝟙 Z) ≫\n        (coprod.associator W (X ⨿ Y) Z).hom ≫ coprod.map (𝟙 W) (coprod.associator X Y Z).hom =\n      (coprod.associator (W ⨿ X) Y Z).hom ≫ (coprod.associator W X (Y ⨿ Z)).hom := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.associator_naturality","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nX₁ X₂ X₃ Y₁ Y₂ Y₃ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\nf₃ : Quiver.Hom X₃ Y₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (CategoryTheory.Limits.coprod.map f₁ f₂) f₃) (CategoryTheory.Limits.coprod.associator Y₁ Y₂ Y₃).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.associator X₁ X₂ X₃).hom (CategoryTheory.Limits.coprod.map f₁ (CategoryTheory.Limits.coprod.map f₂ f₃)))","decl":"theorem coprod.associator_naturality {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂)\n    (f₃ : X₃ ⟶ Y₃) :\n    coprod.map (coprod.map f₁ f₂) f₃ ≫ (coprod.associator Y₁ Y₂ Y₃).hom =\n      (coprod.associator X₁ X₂ X₃).hom ≫ coprod.map f₁ (coprod.map f₂ f₃) := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.leftUnitor_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst✝ : CategoryTheory.Limits.HasInitial C\nP : C\n⊢ Eq (CategoryTheory.Limits.coprod.leftUnitor P).hom (CategoryTheory.Limits.coprod.desc (CategoryTheory.Limits.initial.to P) (CategoryTheory.CategoryStruct.id P))","decl":"/-- The left unitor isomorphism for binary coproducts with the initial object. -/\n@[simps]\ndef coprod.leftUnitor (P : C) : (⊥_ C) ⨿ P ≅ P where\n  hom := coprod.desc (initial.to P) (𝟙 _)\n  inv := coprod.inr\n  hom_inv_id := by apply coprod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.leftUnitor_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst✝ : CategoryTheory.Limits.HasInitial C\nP : C\n⊢ Eq (CategoryTheory.Limits.coprod.leftUnitor P).inv CategoryTheory.Limits.coprod.inr","decl":"/-- The left unitor isomorphism for binary coproducts with the initial object. -/\n@[simps]\ndef coprod.leftUnitor (P : C) : (⊥_ C) ⨿ P ≅ P where\n  hom := coprod.desc (initial.to P) (𝟙 _)\n  inv := coprod.inr\n  hom_inv_id := by apply coprod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.rightUnitor_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst✝ : CategoryTheory.Limits.HasInitial C\nP : C\n⊢ Eq (CategoryTheory.Limits.coprod.rightUnitor P).hom (CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.id P) (CategoryTheory.Limits.initial.to P))","decl":"/-- The right unitor isomorphism for binary coproducts with the initial object. -/\n@[simps]\ndef coprod.rightUnitor (P : C) : P ⨿ ⊥_ C ≅ P where\n  hom := coprod.desc (𝟙 _) (initial.to P)\n  inv := coprod.inl\n  hom_inv_id := by apply coprod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.rightUnitor_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst✝ : CategoryTheory.Limits.HasInitial C\nP : C\n⊢ Eq (CategoryTheory.Limits.coprod.rightUnitor P).inv CategoryTheory.Limits.coprod.inl","decl":"/-- The right unitor isomorphism for binary coproducts with the initial object. -/\n@[simps]\ndef coprod.rightUnitor (P : C) : P ⨿ ⊥_ C ≅ P where\n  hom := coprod.desc (𝟙 _) (initial.to P)\n  inv := coprod.inl\n  hom_inv_id := by apply coprod.hom_ext <;> simp [eq_iff_true_of_subsingleton]\n  inv_hom_id := by simp\n\n"}
{"name":"CategoryTheory.Limits.coprod.triangle","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst✝ : CategoryTheory.Limits.HasInitial C\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.associator X (CategoryTheory.Limits.initial C) Y).hom (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id X) (CategoryTheory.Limits.coprod.leftUnitor Y).hom)) (CategoryTheory.Limits.coprod.map (CategoryTheory.Limits.coprod.rightUnitor X).hom (CategoryTheory.CategoryStruct.id Y))","decl":"theorem coprod.triangle (X Y : C) :\n    (coprod.associator X (⊥_ C) Y).hom ≫ coprod.map (𝟙 X) (coprod.leftUnitor Y).hom =\n      coprod.map (coprod.rightUnitor X).hom (𝟙 Y) := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Limits.prod.functor_map_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\nT : C\n⊢ Eq ((CategoryTheory.Limits.prod.functor.map f).app T) (CategoryTheory.Limits.prod.map f (CategoryTheory.CategoryStruct.id T))","decl":"/-- The binary product functor. -/\n@[simps]\ndef prod.functor : C ⥤ C ⥤ C where\n  obj X :=\n    { obj := fun Y => X ⨯ Y\n      map := fun {_ _} => prod.map (𝟙 X) }\n  map f :=\n    { app := fun T => prod.map f (𝟙 T) }\n\n"}
{"name":"CategoryTheory.Limits.prod.functor_obj_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nX Y : C\n⊢ Eq ((CategoryTheory.Limits.prod.functor.obj X).obj Y) (CategoryTheory.Limits.prod X Y)","decl":"/-- The binary product functor. -/\n@[simps]\ndef prod.functor : C ⥤ C ⥤ C where\n  obj X :=\n    { obj := fun Y => X ⨯ Y\n      map := fun {_ _} => prod.map (𝟙 X) }\n  map f :=\n    { app := fun T => prod.map f (𝟙 T) }\n\n"}
{"name":"CategoryTheory.Limits.prod.functor_obj_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nX x✝¹ x✝ : C\ng : Quiver.Hom x✝¹ x✝\n⊢ Eq ((CategoryTheory.Limits.prod.functor.obj X).map g) (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X) g)","decl":"/-- The binary product functor. -/\n@[simps]\ndef prod.functor : C ⥤ C ⥤ C where\n  obj X :=\n    { obj := fun Y => X ⨯ Y\n      map := fun {_ _} => prod.map (𝟙 X) }\n  map f :=\n    { app := fun T => prod.map f (𝟙 T) }\n\n"}
{"name":"CategoryTheory.Limits.coprod.functor_obj_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nX x✝¹ x✝ : C\ng : Quiver.Hom x✝¹ x✝\n⊢ Eq ((CategoryTheory.Limits.coprod.functor.obj X).map g) (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id X) g)","decl":"/-- The binary coproduct functor. -/\n@[simps]\ndef coprod.functor : C ⥤ C ⥤ C where\n  obj X :=\n    { obj := fun Y => X ⨿ Y\n      map := fun {_ _} => coprod.map (𝟙 X) }\n  map f := { app := fun T => coprod.map f (𝟙 T) }\n\n"}
{"name":"CategoryTheory.Limits.coprod.functor_map_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\nT : C\n⊢ Eq ((CategoryTheory.Limits.coprod.functor.map f).app T) (CategoryTheory.Limits.coprod.map f (CategoryTheory.CategoryStruct.id T))","decl":"/-- The binary coproduct functor. -/\n@[simps]\ndef coprod.functor : C ⥤ C ⥤ C where\n  obj X :=\n    { obj := fun Y => X ⨿ Y\n      map := fun {_ _} => coprod.map (𝟙 X) }\n  map f := { app := fun T => coprod.map f (𝟙 T) }\n\n"}
{"name":"CategoryTheory.Limits.coprod.functor_obj_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nX Y : C\n⊢ Eq ((CategoryTheory.Limits.coprod.functor.obj X).obj Y) (CategoryTheory.Limits.coprod X Y)","decl":"/-- The binary coproduct functor. -/\n@[simps]\ndef coprod.functor : C ⥤ C ⥤ C where\n  obj X :=\n    { obj := fun Y => X ⨿ Y\n      map := fun {_ _} => coprod.map (𝟙 X) }\n  map f := { app := fun T => coprod.map f (𝟙 T) }\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct A B\ninst✝ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\nZ : D\nh : Quiver.Hom (F.obj A) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A B) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.prod.fst) h)","decl":"@[reassoc (attr := simp)]\ntheorem prodComparison_fst : prodComparison F A B ≫ prod.fst = F.map prod.fst :=\n  prod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct A B\ninst✝ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A B) CategoryTheory.Limits.prod.fst) (F.map CategoryTheory.Limits.prod.fst)","decl":"@[reassoc (attr := simp)]\ntheorem prodComparison_fst : prodComparison F A B ≫ prod.fst = F.map prod.fst :=\n  prod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct A B\ninst✝ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A B) CategoryTheory.Limits.prod.snd) (F.map CategoryTheory.Limits.prod.snd)","decl":"@[reassoc (attr := simp)]\ntheorem prodComparison_snd : prodComparison F A B ≫ prod.snd = F.map prod.snd :=\n  prod.lift_snd _ _\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct A B\ninst✝ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\nZ : D\nh : Quiver.Hom (F.obj B) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A B) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.prod.snd) h)","decl":"@[reassoc (attr := simp)]\ntheorem prodComparison_snd : prodComparison F A B ≫ prod.snd = F.map prod.snd :=\n  prod.lift_snd _ _\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst✝³ : CategoryTheory.Limits.HasBinaryProduct A B\ninst✝² : CategoryTheory.Limits.HasBinaryProduct A' B'\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst✝ : CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.prod.map f g)) (CategoryTheory.Limits.prodComparison F A' B')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A B) (CategoryTheory.Limits.prod.map (F.map f) (F.map g)))","decl":"/-- Naturality of the `prodComparison` morphism in both arguments. -/\n@[reassoc]\ntheorem prodComparison_natural (f : A ⟶ A') (g : B ⟶ B') :\n    F.map (prod.map f g) ≫ prodComparison F A' B' =\n      prodComparison F A B ≫ prod.map (F.map f) (F.map g) := by\n  rw [prodComparison, prodComparison, prod.lift_map, ← F.map_comp, ← F.map_comp, prod.comp_lift, ←\n    F.map_comp, prod.map_fst, ← F.map_comp, prod.map_snd]\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst✝³ : CategoryTheory.Limits.HasBinaryProduct A B\ninst✝² : CategoryTheory.Limits.HasBinaryProduct A' B'\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst✝ : CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.prod (F.obj A') (F.obj B')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.prod.map f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A' B') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prodComparison F A B) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (F.map f) (F.map g)) h))","decl":"/-- Naturality of the `prodComparison` morphism in both arguments. -/\n@[reassoc]\ntheorem prodComparison_natural (f : A ⟶ A') (g : B ⟶ B') :\n    F.map (prod.map f g) ≫ prodComparison F A' B' =\n      prodComparison F A B ≫ prod.map (F.map f) (F.map g) := by\n  rw [prodComparison, prodComparison, prod.lift_map, ← F.map_comp, ← F.map_comp, prod.comp_lift, ←\n    F.map_comp, prod.map_fst, ← F.map_comp, prod.map_snd]\n\n"}
{"name":"CategoryTheory.Limits.prodComparisonNatTrans_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{w, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasBinaryProducts C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts D\nF : CategoryTheory.Functor C D\nA B : C\n⊢ Eq ((CategoryTheory.Limits.prodComparisonNatTrans F A).app B) (CategoryTheory.Limits.prodComparison F A B)","decl":"/-- The product comparison morphism from `F(A ⨯ -)` to `FA ⨯ F-`, whose components are given by\n`prodComparison`.\n-/\n@[simps]\ndef prodComparisonNatTrans [HasBinaryProducts C] [HasBinaryProducts D] (F : C ⥤ D) (A : C) :\n    prod.functor.obj A ⋙ F ⟶ F ⋙ prod.functor.obj (F.obj A) where\n  app B := prodComparison F A B\n  naturality f := by simp [prodComparison_natural]\n\n"}
{"name":"CategoryTheory.Limits.inv_prodComparison_map_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝² : CategoryTheory.Limits.HasBinaryProduct A B\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B)) (F.map CategoryTheory.Limits.prod.fst)) CategoryTheory.Limits.prod.fst","decl":"@[reassoc]\ntheorem inv_prodComparison_map_fst [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) ≫ F.map prod.fst = prod.fst := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.inv_prodComparison_map_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝² : CategoryTheory.Limits.HasBinaryProduct A B\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\nZ : D\nh : Quiver.Hom (F.obj A) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.prod.fst) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)","decl":"@[reassoc]\ntheorem inv_prodComparison_map_fst [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) ≫ F.map prod.fst = prod.fst := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.inv_prodComparison_map_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝² : CategoryTheory.Limits.HasBinaryProduct A B\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B)) (F.map CategoryTheory.Limits.prod.snd)) CategoryTheory.Limits.prod.snd","decl":"@[reassoc]\ntheorem inv_prodComparison_map_snd [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) ≫ F.map prod.snd = prod.snd := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.inv_prodComparison_map_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝² : CategoryTheory.Limits.HasBinaryProduct A B\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\nZ : D\nh : Quiver.Hom (F.obj B) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.prod.snd) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)","decl":"@[reassoc]\ntheorem inv_prodComparison_map_snd [IsIso (prodComparison F A B)] :\n    inv (prodComparison F A B) ≫ F.map prod.snd = prod.snd := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_inv_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst✝⁵ : CategoryTheory.Limits.HasBinaryProduct A B\ninst✝⁴ : CategoryTheory.Limits.HasBinaryProduct A' B'\ninst✝³ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst✝² : CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\ninst✝¹ : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A' B')\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B)) (F.map (CategoryTheory.Limits.prod.map f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (F.map f) (F.map g)) (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A' B')))","decl":"/-- If the product comparison morphism is an iso, its inverse is natural. -/\n@[reassoc]\ntheorem prodComparison_inv_natural (f : A ⟶ A') (g : B ⟶ B') [IsIso (prodComparison F A B)]\n    [IsIso (prodComparison F A' B')] :\n    inv (prodComparison F A B) ≫ F.map (prod.map f g) =\n      prod.map (F.map f) (F.map g) ≫ inv (prodComparison F A' B') := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, prodComparison_natural]\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_inv_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst✝⁵ : CategoryTheory.Limits.HasBinaryProduct A B\ninst✝⁴ : CategoryTheory.Limits.HasBinaryProduct A' B'\ninst✝³ : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst✝² : CategoryTheory.Limits.HasBinaryProduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\ninst✝¹ : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A' B')\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.prod A' B')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.prod.map f g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (F.map f) (F.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A' B')) h))","decl":"/-- If the product comparison morphism is an iso, its inverse is natural. -/\n@[reassoc]\ntheorem prodComparison_inv_natural (f : A ⟶ A') (g : B ⟶ B') [IsIso (prodComparison F A B)]\n    [IsIso (prodComparison F A' B')] :\n    inv (prodComparison F A B) ≫ F.map (prod.map f g) =\n      prod.map (F.map f) (F.map g) ≫ inv (prodComparison F A' B') := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, prodComparison_natural]\n\n"}
{"name":"CategoryTheory.Limits.prodComparisonNatIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.HasBinaryProducts C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProducts D\nA : C\ninst✝ : ∀ (B : C), CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\n⊢ Eq (CategoryTheory.Limits.prodComparisonNatIso F A).hom (CategoryTheory.Limits.prodComparisonNatTrans F A)","decl":"/-- The natural isomorphism `F(A ⨯ -) ≅ FA ⨯ F-`, provided each `prodComparison F A B` is an\nisomorphism (as `B` changes).\n-/\n-- @[simps (config := { rhsMd := semireducible })] -- Porting note: no config for semireducible\n@[simps]\ndef prodComparisonNatIso [HasBinaryProducts C] [HasBinaryProducts D] (A : C)\n    [∀ B, IsIso (prodComparison F A B)] :\n    prod.functor.obj A ⋙ F ≅ F ⋙ prod.functor.obj (F.obj A) := by\n  refine { @asIso _ _ _ _ _ (?_) with hom := prodComparisonNatTrans F A }\n  apply NatIso.isIso_of_isIso_app\n\n"}
{"name":"CategoryTheory.Limits.prodComparisonNatIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.HasBinaryProducts C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProducts D\nA : C\ninst✝ : ∀ (B : C), CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)\n⊢ Eq (CategoryTheory.Limits.prodComparisonNatIso F A).inv (CategoryTheory.asIso { app := fun B => CategoryTheory.Limits.prodComparison F A B, naturality := ⋯ }).inv","decl":"/-- The natural isomorphism `F(A ⨯ -) ≅ FA ⨯ F-`, provided each `prodComparison F A B` is an\nisomorphism (as `B` changes).\n-/\n-- @[simps (config := { rhsMd := semireducible })] -- Porting note: no config for semireducible\n@[simps]\ndef prodComparisonNatIso [HasBinaryProducts C] [HasBinaryProducts D] (A : C)\n    [∀ B, IsIso (prodComparison F A B)] :\n    prod.functor.obj A ⋙ F ≅ F ⋙ prod.functor.obj (F.obj A) := by\n  refine { @asIso _ _ _ _ _ (?_) with hom := prodComparisonNatTrans F A }\n  apply NatIso.isIso_of_isIso_app\n\n"}
{"name":"CategoryTheory.Limits.prodComparison_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{w, u₂} D\nE : Type u₃\ninst✝⁴ : CategoryTheory.Category.{w', u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nA B : C\ninst✝³ : CategoryTheory.Limits.HasBinaryProduct A B\ninst✝² : CategoryTheory.Limits.HasBinaryProduct (F.obj A) (F.obj B)\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct (G.obj (F.obj A)) (G.obj (F.obj B))\ninst✝ : CategoryTheory.Limits.HasBinaryProduct ((F.comp G).obj A) ((F.comp G).obj B)\n⊢ Eq (CategoryTheory.Limits.prodComparison (F.comp G) A B) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.prodComparison F A B)) (CategoryTheory.Limits.prodComparison G (F.obj A) (F.obj B)))","decl":"theorem prodComparison_comp :\n    prodComparison (F ⋙ G) A B =\n      G.map (prodComparison F A B) ≫ prodComparison G (F.obj A) (F.obj B) := by\n  unfold prodComparison\n  ext <;> simp <;> rw [← G.map_comp] <;> simp\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_inl_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.coprod A B)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprodComparison F A B) h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.coprod.inl) h)","decl":"@[reassoc (attr := simp)]\ntheorem coprodComparison_inl : coprod.inl ≫ coprodComparison F A B = F.map coprod.inl :=\n  coprod.inl_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.Limits.coprodComparison F A B)) (F.map CategoryTheory.Limits.coprod.inl)","decl":"@[reassoc (attr := simp)]\ntheorem coprodComparison_inl : coprod.inl ≫ coprodComparison F A B = F.map coprod.inl :=\n  coprod.inl_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_inr_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.coprod A B)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprodComparison F A B) h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.coprod.inr) h)","decl":"@[reassoc (attr := simp)]\ntheorem coprodComparison_inr : coprod.inr ≫ coprodComparison F A B = F.map coprod.inr :=\n  coprod.inr_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.Limits.coprodComparison F A B)) (F.map CategoryTheory.Limits.coprod.inr)","decl":"@[reassoc (attr := simp)]\ntheorem coprodComparison_inr : coprod.inr ≫ coprodComparison F A B = F.map coprod.inr :=\n  coprod.inr_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst✝³ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct A' B'\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.coprod A' B')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprodComparison F A B) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.coprod.map f g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (F.map f) (F.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprodComparison F A' B') h))","decl":"/-- Naturality of the coprod_comparison morphism in both arguments. -/\n@[reassoc]\ntheorem coprodComparison_natural (f : A ⟶ A') (g : B ⟶ B') :\n    coprodComparison F A B ≫ F.map (coprod.map f g) =\n      coprod.map (F.map f) (F.map g) ≫ coprodComparison F A' B' := by\n  rw [coprodComparison, coprodComparison, coprod.map_desc, ← F.map_comp, ← F.map_comp,\n    coprod.desc_comp, ← F.map_comp, coprod.inl_map, ← F.map_comp, coprod.inr_map]\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst✝³ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct A' B'\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprodComparison F A B) (F.map (CategoryTheory.Limits.coprod.map f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (F.map f) (F.map g)) (CategoryTheory.Limits.coprodComparison F A' B'))","decl":"/-- Naturality of the coprod_comparison morphism in both arguments. -/\n@[reassoc]\ntheorem coprodComparison_natural (f : A ⟶ A') (g : B ⟶ B') :\n    coprodComparison F A B ≫ F.map (coprod.map f g) =\n      coprod.map (F.map f) (F.map g) ≫ coprodComparison F A' B' := by\n  rw [coprodComparison, coprodComparison, coprod.map_desc, ← F.map_comp, ← F.map_comp,\n    coprod.desc_comp, ← F.map_comp, coprod.inl_map, ← F.map_comp, coprod.inr_map]\n\n"}
{"name":"CategoryTheory.Limits.coprodComparisonNatTrans_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{w, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts D\nF : CategoryTheory.Functor C D\nA B : C\n⊢ Eq ((CategoryTheory.Limits.coprodComparisonNatTrans F A).app B) (CategoryTheory.Limits.coprodComparison F A B)","decl":"/-- The coproduct comparison morphism from `FA ⨿ F-` to `F(A ⨿ -)`, whose components are given by\n`coprodComparison`.\n-/\n@[simps]\ndef coprodComparisonNatTrans [HasBinaryCoproducts C] [HasBinaryCoproducts D] (F : C ⥤ D) (A : C) :\n    F ⋙ coprod.functor.obj (F.obj A) ⟶ coprod.functor.obj A ⋙ F where\n  app B := coprodComparison F A B\n  naturality f := by simp [coprodComparison_natural]\n\n"}
{"name":"CategoryTheory.Limits.map_inl_inv_coprodComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.coprod.inl) (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B))) CategoryTheory.Limits.coprod.inl","decl":"@[reassoc]\ntheorem map_inl_inv_coprodComparison [IsIso (coprodComparison F A B)] :\n    F.map coprod.inl ≫ inv (coprodComparison F A B) = coprod.inl := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.map_inl_inv_coprodComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.coprod (F.obj A) (F.obj B)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.coprod.inl) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B)) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl h)","decl":"@[reassoc]\ntheorem map_inl_inv_coprodComparison [IsIso (coprodComparison F A B)] :\n    F.map coprod.inl ≫ inv (coprodComparison F A B) = coprod.inl := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.map_inr_inv_coprodComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.coprod (F.obj A) (F.obj B)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.coprod.inr) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B)) h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr h)","decl":"@[reassoc]\ntheorem map_inr_inv_coprodComparison [IsIso (coprodComparison F A B)] :\n    F.map coprod.inr ≫ inv (coprodComparison F A B) = coprod.inr := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.map_inr_inv_coprodComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.coprod.inr) (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B))) CategoryTheory.Limits.coprod.inr","decl":"@[reassoc]\ntheorem map_inr_inv_coprodComparison [IsIso (coprodComparison F A B)] :\n    F.map coprod.inr ≫ inv (coprodComparison F A B) = coprod.inr := by simp [IsIso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_inv_natural_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst✝⁵ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst✝⁴ : CategoryTheory.Limits.HasBinaryCoproduct A' B'\ninst✝³ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\ninst✝¹ : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A' B')\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.coprod (F.obj A') (F.obj B')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.map (F.map f) (F.map g)) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.coprod.map f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A' B')) h))","decl":"/-- If the coproduct comparison morphism is an iso, its inverse is natural. -/\n@[reassoc]\ntheorem coprodComparison_inv_natural (f : A ⟶ A') (g : B ⟶ B') [IsIso (coprodComparison F A B)]\n    [IsIso (coprodComparison F A' B')] :\n    inv (coprodComparison F A B) ≫ coprod.map (F.map f) (F.map g) =\n      F.map (coprod.map f g) ≫ inv (coprodComparison F A' B') := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, coprodComparison_natural]\n\n"}
{"name":"CategoryTheory.Limits.coprodComparison_inv_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\nA A' B B' : C\ninst✝⁵ : CategoryTheory.Limits.HasBinaryCoproduct A B\ninst✝⁴ : CategoryTheory.Limits.HasBinaryCoproduct A' B'\ninst✝³ : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A) (F.obj B)\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct (F.obj A') (F.obj B')\nf : Quiver.Hom A A'\ng : Quiver.Hom B B'\ninst✝¹ : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A' B')\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B)) (CategoryTheory.Limits.coprod.map (F.map f) (F.map g))) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.coprod.map f g)) (CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A' B')))","decl":"/-- If the coproduct comparison morphism is an iso, its inverse is natural. -/\n@[reassoc]\ntheorem coprodComparison_inv_natural (f : A ⟶ A') (g : B ⟶ B') [IsIso (coprodComparison F A B)]\n    [IsIso (coprodComparison F A' B')] :\n    inv (coprodComparison F A B) ≫ coprod.map (F.map f) (F.map g) =\n      F.map (coprod.map f g) ≫ inv (coprodComparison F A' B') := by\n  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, coprodComparison_natural]\n\n"}
{"name":"CategoryTheory.Limits.coprodComparisonNatIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.HasBinaryCoproducts C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproducts D\nA : C\ninst✝ : ∀ (B : C), CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\n⊢ Eq (CategoryTheory.Limits.coprodComparisonNatIso F A).hom (CategoryTheory.Limits.coprodComparisonNatTrans F A)","decl":"/-- The natural isomorphism `FA ⨿ F- ≅ F(A ⨿ -)`, provided each `coprodComparison F A B` is an\nisomorphism (as `B` changes).\n-/\n-- @[simps (config := { rhsMd := semireducible })] -- Porting note: no config for semireducible\n@[simps]\ndef coprodComparisonNatIso [HasBinaryCoproducts C] [HasBinaryCoproducts D] (A : C)\n    [∀ B, IsIso (coprodComparison F A B)] :\n    F ⋙ coprod.functor.obj (F.obj A) ≅ coprod.functor.obj A ⋙ F := by\n  refine { @asIso _ _ _ _ _ (?_) with hom := coprodComparisonNatTrans F A }\n  apply NatIso.isIso_of_isIso_app -- Porting note: this did not work inside { }\n\n"}
{"name":"CategoryTheory.Limits.coprodComparisonNatIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{w, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.HasBinaryCoproducts C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproducts D\nA : C\ninst✝ : ∀ (B : C), CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)\n⊢ Eq (CategoryTheory.Limits.coprodComparisonNatIso F A).inv (CategoryTheory.asIso { app := fun B => CategoryTheory.Limits.coprodComparison F A B, naturality := ⋯ }).inv","decl":"/-- The natural isomorphism `FA ⨿ F- ≅ F(A ⨿ -)`, provided each `coprodComparison F A B` is an\nisomorphism (as `B` changes).\n-/\n-- @[simps (config := { rhsMd := semireducible })] -- Porting note: no config for semireducible\n@[simps]\ndef coprodComparisonNatIso [HasBinaryCoproducts C] [HasBinaryCoproducts D] (A : C)\n    [∀ B, IsIso (coprodComparison F A B)] :\n    F ⋙ coprod.functor.obj (F.obj A) ≅ coprod.functor.obj A ⋙ F := by\n  refine { @asIso _ _ _ _ _ (?_) with hom := coprodComparisonNatTrans F A }\n  apply NatIso.isIso_of_isIso_app -- Porting note: this did not work inside { }\n\n"}
{"name":"CategoryTheory.Over.coprodObj_map","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nA : C\na✝ X✝ Y✝ : CategoryTheory.Over A\nk : Quiver.Hom X✝ Y✝\n⊢ Eq (a✝.coprodObj.map k) (CategoryTheory.Over.homMk (CategoryTheory.Limits.coprod.map (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj a✝.left)) k.left) ⋯)","decl":"/-- Auxiliary definition for `Over.coprod`. -/\n@[simps]\nnoncomputable def Over.coprodObj [HasBinaryCoproducts C] {A : C} :\n    Over A → Over A ⥤ Over A :=\n  fun f =>\n  { obj := fun g => Over.mk (coprod.desc f.hom g.hom)\n    map := fun k => Over.homMk (coprod.map (𝟙 _) k.left) }\n\n"}
{"name":"CategoryTheory.Over.coprodObj_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nA : C\na✝ g : CategoryTheory.Over A\n⊢ Eq (a✝.coprodObj.obj g) (CategoryTheory.Over.mk (CategoryTheory.Limits.coprod.desc a✝.hom g.hom))","decl":"/-- Auxiliary definition for `Over.coprod`. -/\n@[simps]\nnoncomputable def Over.coprodObj [HasBinaryCoproducts C] {A : C} :\n    Over A → Over A ⥤ Over A :=\n  fun f =>\n  { obj := fun g => Over.mk (coprod.desc f.hom g.hom)\n    map := fun k => Over.homMk (coprod.map (𝟙 _) k.left) }\n\n"}
{"name":"CategoryTheory.Over.coprod_map_app","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nA : C\nX✝ Y✝ : CategoryTheory.Over A\nk : Quiver.Hom X✝ Y✝\ng : CategoryTheory.Over A\n⊢ Eq ((CategoryTheory.Over.coprod.map k).app g) (CategoryTheory.Over.homMk (CategoryTheory.Limits.coprod.map k.left (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj g.left))) ⋯)","decl":"/-- A category with binary coproducts has a functorial `sup` operation on over categories. -/\n@[simps]\nnoncomputable def Over.coprod [HasBinaryCoproducts C] {A : C} : Over A ⥤ Over A ⥤ Over A where\n  obj f := Over.coprodObj f\n  map k :=\n    { app := fun g => Over.homMk (coprod.map k.left (𝟙 _)) (by\n        dsimp; rw [coprod.map_desc, Category.id_comp, Over.w k])\n      naturality := fun f g k => by\n        ext\n        dsimp; simp }\n  map_id X := by\n    ext\n    dsimp; simp\n  map_comp f g := by\n    ext\n    dsimp; simp\n\n"}
{"name":"CategoryTheory.Over.coprod_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproducts C\nA : C\nf : CategoryTheory.Over A\n⊢ Eq (CategoryTheory.Over.coprod.obj f) f.coprodObj","decl":"/-- A category with binary coproducts has a functorial `sup` operation on over categories. -/\n@[simps]\nnoncomputable def Over.coprod [HasBinaryCoproducts C] {A : C} : Over A ⥤ Over A ⥤ Over A where\n  obj f := Over.coprodObj f\n  map k :=\n    { app := fun g => Over.homMk (coprod.map k.left (𝟙 _)) (by\n        dsimp; rw [coprod.map_desc, Category.id_comp, Over.w k])\n      naturality := fun f g k => by\n        ext\n        dsimp; simp }\n  map_id X := by\n    ext\n    dsimp; simp\n  map_comp f g := by\n    ext\n    dsimp; simp\n\n"}
