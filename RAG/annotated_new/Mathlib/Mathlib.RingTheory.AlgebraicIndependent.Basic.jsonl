{"name":"algebraicIndependent_iff_ker_eq_bot","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Iff (AlgebraicIndependent R x) (Eq (RingHom.ker (MvPolynomial.aeval x).toRingHom) Bot.bot)","decl":"theorem algebraicIndependent_iff_ker_eq_bot :\n    AlgebraicIndependent R x ↔\n      RingHom.ker (MvPolynomial.aeval x : MvPolynomial ι R →ₐ[R] A).toRingHom = ⊥ :=\n  RingHom.injective_iff_ker_eq_bot _\n\n"}
{"name":"algebraicIndependent_empty_type_iff","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : IsEmpty ι\n⊢ Iff (AlgebraicIndependent R x) (Function.Injective ⇑(algebraMap R A))","decl":"@[simp]\ntheorem algebraicIndependent_empty_type_iff [IsEmpty ι] :\n    AlgebraicIndependent R x ↔ Injective (algebraMap R A) := by\n  rw [algebraicIndependent_iff_injective_aeval, MvPolynomial.aeval_injective_iff_of_isEmpty]\n\n"}
{"name":"AlgebraicIndependent.algebraMap_injective","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\n⊢ Function.Injective ⇑(algebraMap R A)","decl":"theorem algebraMap_injective : Injective (algebraMap R A) := by\n  simpa [Function.comp_def] using\n    (Injective.of_comp_iff (algebraicIndependent_iff_injective_aeval.1 hx) MvPolynomial.C).2\n      (MvPolynomial.C_injective _ _)\n\n"}
{"name":"AlgebraicIndependent.linearIndependent","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\n⊢ LinearIndependent R x","decl":"theorem linearIndependent : LinearIndependent R x := by\n  rw [linearIndependent_iff_injective_linearCombination]\n  have : Finsupp.linearCombination R x =\n      (MvPolynomial.aeval x).toLinearMap.comp (Finsupp.linearCombination R X) := by\n    ext\n    simp\n  rw [this]\n  refine (algebraicIndependent_iff_injective_aeval.mp hx).comp ?_\n  rw [← linearIndependent_iff_injective_linearCombination]\n  exact linearIndependent_X _ _\n\n"}
{"name":"AlgebraicIndependent.injective","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nhx : AlgebraicIndependent R x\ninst✝ : Nontrivial R\n⊢ Function.Injective x","decl":"protected theorem injective [Nontrivial R] : Injective x :=\n  hx.linearIndependent.injective\n\n"}
{"name":"AlgebraicIndependent.ne_zero","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nhx : AlgebraicIndependent R x\ninst✝ : Nontrivial R\ni : ι\n⊢ Ne (x i) 0","decl":"theorem ne_zero [Nontrivial R] (i : ι) : x i ≠ 0 :=\n  hx.linearIndependent.ne_zero i\n\n"}
{"name":"AlgebraicIndependent.map","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nA' : Type u_6\nx : ι → A\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing A'\ninst✝¹ : Algebra R A\ninst✝ : Algebra R A'\nhx : AlgebraicIndependent R x\nf : AlgHom R A A'\nhf_inj : Set.InjOn ⇑f ↑(Algebra.adjoin R (Set.range x))\n⊢ AlgebraicIndependent R (Function.comp (⇑f) x)","decl":"theorem map {f : A →ₐ[R] A'} (hf_inj : Set.InjOn f (adjoin R (range x))) :\n    AlgebraicIndependent R (f ∘ x) := by\n  have : aeval (f ∘ x) = f.comp (aeval x) := by ext; simp\n  have h : ∀ p : MvPolynomial ι R, aeval x p ∈ (@aeval R _ _ _ _ _ ((↑) : range x → A)).range := by\n    intro p\n    rw [AlgHom.mem_range]\n    refine ⟨MvPolynomial.rename (codRestrict x (range x) mem_range_self) p, ?_⟩\n    simp [Function.comp_def, aeval_rename]\n  intro x y hxy\n  rw [this] at hxy\n  rw [adjoin_eq_range] at hf_inj\n  exact hx (hf_inj (h x) (h y) hxy)\n\n"}
{"name":"AlgebraicIndependent.map'","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nA' : Type u_6\nx : ι → A\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing A'\ninst✝¹ : Algebra R A\ninst✝ : Algebra R A'\nhx : AlgebraicIndependent R x\nf : AlgHom R A A'\nhf_inj : Function.Injective ⇑f\n⊢ AlgebraicIndependent R (Function.comp (⇑f) x)","decl":"theorem map' {f : A →ₐ[R] A'} (hf_inj : Injective f) : AlgebraicIndependent R (f ∘ x) :=\n  hx.map hf_inj.injOn\n\n"}
{"name":"AlgebraicIndependent.aeval_of_algebraicIndependent","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\nf : ι → MvPolynomial ι R\nhf : AlgebraicIndependent R f\n⊢ AlgebraicIndependent R fun i => (MvPolynomial.aeval x) (f i)","decl":"/-- If `x = {x_i : A | i : ι}` and `f = {f_i : MvPolynomial ι R | i : ι}` are algebraically\nindependent over `R`, then `{f_i(x) | i : ι}` is also algebraically independent over `R`.\nFor the partial converse, see `AlgebraicIndependent.of_aeval`. -/\ntheorem aeval_of_algebraicIndependent\n    {f : ι → MvPolynomial ι R} (hf : AlgebraicIndependent R f) :\n    AlgebraicIndependent R fun i ↦ aeval x (f i) := by\n  rw [algebraicIndependent_iff] at hx hf ⊢\n  intro p hp\n  exact hf _ (hx _ (by rwa [← aeval_comp_bind₁, AlgHom.comp_apply] at hp))\n\n"}
{"name":"AlgebraicIndependent.of_aeval","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nf : ι → MvPolynomial ι R\nH : AlgebraicIndependent R fun i => (MvPolynomial.aeval x) (f i)\n⊢ AlgebraicIndependent R f","decl":"omit hx in\n/-- If `{f_i(x) | i : ι}` is algebraically independent over `R`, then\n`{f_i : MvPolynomial ι R | i : ι}` is also algebraically independent over `R`.\nIn fact, the `x = {x_i : A | i : ι}` is also transcendental over `R` provided that `R`\nis a field and `ι` is finite; the proof needs transcendence degree. -/\ntheorem of_aeval {f : ι → MvPolynomial ι R}\n    (H : AlgebraicIndependent R fun i ↦ aeval x (f i)) :\n    AlgebraicIndependent R f := by\n  rw [algebraicIndependent_iff] at H ⊢\n  intro p hp\n  exact H p (by rw [← aeval_comp_bind₁, AlgHom.comp_apply, bind₁, hp, map_zero])\n\n"}
{"name":"MvPolynomial.algebraicIndependent_X","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"σ : Type u_7\nR : Type u_8\ninst✝ : CommRing R\n⊢ AlgebraicIndependent R MvPolynomial.X","decl":"theorem MvPolynomial.algebraicIndependent_X (σ R : Type*) [CommRing R] :\n    AlgebraicIndependent R (X (R := R) (σ := σ)) := by\n  rw [AlgebraicIndependent, aeval_X_left]\n  exact injective_id\n\n"}
{"name":"AlgHom.algebraicIndependent_iff","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nA' : Type u_6\nx : ι → A\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing A'\ninst✝¹ : Algebra R A\ninst✝ : Algebra R A'\nf : AlgHom R A A'\nhf : Function.Injective ⇑f\n⊢ Iff (AlgebraicIndependent R (Function.comp (⇑f) x)) (AlgebraicIndependent R x)","decl":"theorem AlgHom.algebraicIndependent_iff (f : A →ₐ[R] A') (hf : Injective f) :\n    AlgebraicIndependent R (f ∘ x) ↔ AlgebraicIndependent R x :=\n  ⟨fun h => h.of_comp f, fun h => h.map hf.injOn⟩\n\n"}
{"name":"algebraicIndependent_of_subsingleton","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Subsingleton R\n⊢ AlgebraicIndependent R x","decl":"@[nontriviality]\ntheorem algebraicIndependent_of_subsingleton [Subsingleton R] : AlgebraicIndependent R x :=\n  algebraicIndependent_iff.2 fun _ _ => Subsingleton.elim _ _\n\n"}
{"name":"algebraicIndependent_adjoin","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhs : AlgebraicIndependent R x\n⊢ AlgebraicIndependent R fun i => ⟨x i, ⋯⟩","decl":"theorem algebraicIndependent_adjoin (hs : AlgebraicIndependent R x) :\n    @AlgebraicIndependent ι R (adjoin R (range x))\n      (fun i : ι => ⟨x i, subset_adjoin (mem_range_self i)⟩) _ _ _ :=\n  AlgebraicIndependent.of_comp (adjoin R (range x)).val hs\n\n"}
{"name":"AlgebraicIndependent.restrictScalars","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : Algebra R A\nK : Type u_7\ninst✝³ : CommRing K\ninst✝² : Algebra R K\ninst✝¹ : Algebra K A\ninst✝ : IsScalarTower R K A\nhinj : Function.Injective ⇑(algebraMap R K)\nai : AlgebraicIndependent K x\n⊢ AlgebraicIndependent R x","decl":"/-- A set of algebraically independent elements in an algebra `A` over a ring `K` is also\nalgebraically independent over a subring `R` of `K`. -/\ntheorem AlgebraicIndependent.restrictScalars {K : Type*} [CommRing K] [Algebra R K] [Algebra K A]\n    [IsScalarTower R K A] (hinj : Function.Injective (algebraMap R K))\n    (ai : AlgebraicIndependent K x) : AlgebraicIndependent R x := by\n  have : (aeval x : MvPolynomial ι K →ₐ[K] A).toRingHom.comp (MvPolynomial.map (algebraMap R K)) =\n      (aeval x : MvPolynomial ι R →ₐ[R] A).toRingHom := by\n    ext <;> simp [algebraMap_eq_smul_one]\n  show Injective (aeval x).toRingHom\n  rw [← this, RingHom.coe_comp]\n  exact Injective.comp ai (MvPolynomial.map_injective _ hinj)\n\n"}
{"name":"AlgebraicIndependent.of_ringHom_of_comp_eq","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing A\ninst✝⁷ : Algebra R A\nS : Type u_7\nB : Type u_8\nFRS : Type u_9\nFAB : Type u_10\ninst✝⁶ : CommRing S\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra S B\ninst✝³ : FunLike FRS R S\ninst✝² : RingHomClass FRS R S\ninst✝¹ : FunLike FAB A B\ninst✝ : RingHomClass FAB A B\nf : FRS\ng : FAB\nH : AlgebraicIndependent S (Function.comp (⇑g) x)\nhf : Function.Injective ⇑f\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\n⊢ AlgebraicIndependent R x","decl":"theorem AlgebraicIndependent.of_ringHom_of_comp_eq (H : AlgebraicIndependent S (g ∘ x))\n    (hf : Function.Injective f)\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) :\n    AlgebraicIndependent R x := by\n  rw [algebraicIndependent_iff] at H ⊢\n  intro p hp\n  have := H (p.map f) <| by\n    have : (g : A →+* B) _ = _ := congr(g $hp)\n    rwa [map_zero, map_aeval, ← h, ← eval₂Hom_map_hom, ← aeval_eq_eval₂Hom] at this\n  exact map_injective (f : R →+* S) hf (by rwa [map_zero])\n\n"}
{"name":"AlgebraicIndependent.ringHom_of_comp_eq","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing A\ninst✝⁷ : Algebra R A\nS : Type u_7\nB : Type u_8\nFRS : Type u_9\nFAB : Type u_10\ninst✝⁶ : CommRing S\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra S B\ninst✝³ : FunLike FRS R S\ninst✝² : RingHomClass FRS R S\ninst✝¹ : FunLike FAB A B\ninst✝ : RingHomClass FAB A B\nf : FRS\ng : FAB\nH : AlgebraicIndependent R x\nhf : Function.Surjective ⇑f\nhg : Function.Injective ⇑g\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\n⊢ AlgebraicIndependent S (Function.comp (⇑g) x)","decl":"theorem AlgebraicIndependent.ringHom_of_comp_eq (H : AlgebraicIndependent R x)\n    (hf : Function.Surjective f) (hg : Function.Injective g)\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) :\n    AlgebraicIndependent S (g ∘ x) := by\n  rw [algebraicIndependent_iff] at H ⊢\n  intro p hp\n  obtain ⟨q, rfl⟩ := map_surjective (f : R →+* S) hf p\n  rw [H q (hg (by rwa [map_zero, ← RingHom.coe_coe g, map_aeval, ← h, ← eval₂Hom_map_hom,\n    ← aeval_eq_eval₂Hom])), map_zero]\n\n"}
{"name":"algebraicIndependent_ringHom_iff_of_comp_eq","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing A\ninst✝⁷ : Algebra R A\nS : Type u_7\nB : Type u_8\nFRS : Type u_9\nFAB : Type u_10\ninst✝⁶ : CommRing S\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra S B\ninst✝³ : EquivLike FRS R S\ninst✝² : RingEquivClass FRS R S\ninst✝¹ : FunLike FAB A B\ninst✝ : RingHomClass FAB A B\nf : FRS\ng : FAB\nhg : Function.Injective ⇑g\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\n⊢ Iff (AlgebraicIndependent S (Function.comp (⇑g) x)) (AlgebraicIndependent R x)","decl":"theorem algebraicIndependent_ringHom_iff_of_comp_eq\n    (hg : Function.Injective g)\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) :\n    AlgebraicIndependent S (g ∘ x) ↔ AlgebraicIndependent R x :=\n  ⟨fun H ↦ H.of_ringHom_of_comp_eq f g (EquivLike.injective f) h,\n    fun H ↦ H.ringHom_of_comp_eq f g (EquivLike.surjective f) hg h⟩\n\n"}
{"name":"algebraicIndependent_finset_map_embedding_subtype","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"R : Type u_3\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\ns : Set A\nli : AlgebraicIndependent R Subtype.val\nt : Finset ↑s\n⊢ AlgebraicIndependent R Subtype.val","decl":"/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem algebraicIndependent_finset_map_embedding_subtype (s : Set A)\n    (li : AlgebraicIndependent R ((↑) : s → A)) (t : Finset s) :\n    AlgebraicIndependent R ((↑) : Finset.map (Embedding.subtype s) t → A) := by\n  let f : t.map (Embedding.subtype s) → s := fun x =>\n    ⟨x.1, by\n      obtain ⟨x, h⟩ := x\n      rw [Finset.mem_map] at h\n      obtain ⟨a, _, rfl⟩ := h\n      simp only [Subtype.coe_prop, Embedding.coe_subtype]⟩\n  convert AlgebraicIndependent.comp li f _\n  rintro ⟨x, hx⟩ ⟨y, hy⟩\n  rw [Finset.mem_map] at hx hy\n  obtain ⟨a, _, rfl⟩ := hx\n  obtain ⟨b, _, rfl⟩ := hy\n  simp only [f, imp_self, Subtype.mk_eq_mk]\n\n"}
{"name":"algebraicIndependent_bounded_of_finset_algebraicIndependent_bounded","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"R : Type u_3\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nn : Nat\nH : ∀ (s : Finset A), (AlgebraicIndependent R fun i => ↑i) → LE.le s.card n\ns : Set A\na✝ : AlgebraicIndependent R Subtype.val\n⊢ LE.le (Cardinal.mk ↑s) ↑n","decl":"/-- If every finite set of algebraically independent element has cardinality at most `n`,\nthen the same is true for arbitrary sets of algebraically independent elements. -/\ntheorem algebraicIndependent_bounded_of_finset_algebraicIndependent_bounded {n : ℕ}\n    (H : ∀ s : Finset A, (AlgebraicIndependent R fun i : s => (i : A)) → s.card ≤ n) :\n    ∀ s : Set A, AlgebraicIndependent R ((↑) : s → A) → Cardinal.mk s ≤ n := by\n  intro s li\n  apply Cardinal.card_le_of\n  intro t\n  rw [← Finset.card_map (Embedding.subtype s)]\n  apply H\n  apply algebraicIndependent_finset_map_embedding_subtype _ li\n\n"}
{"name":"AlgebraicIndependent.restrict_of_comp_subtype","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\ns : Set ι\nhs : AlgebraicIndependent R (Function.comp x Subtype.val)\n⊢ AlgebraicIndependent R (s.restrict x)","decl":"theorem AlgebraicIndependent.restrict_of_comp_subtype {s : Set ι}\n    (hs : AlgebraicIndependent R (x ∘ (↑) : s → A)) : AlgebraicIndependent R (s.restrict x) :=\n  hs\n\n"}
{"name":"algebraicIndependent_empty_iff","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"R : Type u_3\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Iff (AlgebraicIndependent R Subtype.val) (Function.Injective ⇑(algebraMap R A))","decl":"theorem algebraicIndependent_empty_iff :\n    AlgebraicIndependent R ((↑) : (∅ : Set A) → A) ↔ Injective (algebraMap R A) := by simp\n\n"}
{"name":"AlgebraicIndependent.to_subtype_range","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"R : Type u_3\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nι : Type u_7\nf : ι → A\nhf : AlgebraicIndependent R f\n⊢ AlgebraicIndependent R Subtype.val","decl":"theorem AlgebraicIndependent.to_subtype_range {ι} {f : ι → A} (hf : AlgebraicIndependent R f) :\n    AlgebraicIndependent R ((↑) : range f → A) := by\n  nontriviality R\n  rwa [algebraicIndependent_subtype_range hf.injective]\n\n"}
{"name":"AlgebraicIndependent.to_subtype_range'","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"R : Type u_3\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nι : Type u_7\nf : ι → A\nhf : AlgebraicIndependent R f\nt : Set A\nht : Eq (Set.range f) t\n⊢ AlgebraicIndependent R Subtype.val","decl":"theorem AlgebraicIndependent.to_subtype_range' {ι} {f : ι → A} (hf : AlgebraicIndependent R f) {t}\n    (ht : range f = t) : AlgebraicIndependent R ((↑) : t → A) :=\n  ht ▸ hf.to_subtype_range\n\n"}
{"name":"algebraicIndependent_comp_subtype","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\ns : Set ι\n⊢ Iff (AlgebraicIndependent R (Function.comp x Subtype.val)) (∀ (p : MvPolynomial ι R), Membership.mem (MvPolynomial.supported R s) p → Eq ((MvPolynomial.aeval x) p) 0 → Eq p 0)","decl":"theorem algebraicIndependent_comp_subtype {s : Set ι} :\n    AlgebraicIndependent R (x ∘ (↑) : s → A) ↔\n      ∀ p ∈ MvPolynomial.supported R s, aeval x p = 0 → p = 0 := by\n  have : (aeval (x ∘ (↑) : s → A) : _ →ₐ[R] _) = (aeval x).comp (rename (↑)) := by ext; simp\n  have : ∀ p : MvPolynomial s R, rename ((↑) : s → ι) p = 0 ↔ p = 0 :=\n    (injective_iff_map_eq_zero' (rename ((↑) : s → ι) : MvPolynomial s R →ₐ[R] _).toRingHom).1\n      (rename_injective _ Subtype.val_injective)\n  simp [algebraicIndependent_iff, supported_eq_range_rename, *]\n\n"}
{"name":"algebraicIndependent_subtype","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"R : Type u_3\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\ns : Set A\n⊢ Iff (AlgebraicIndependent R Subtype.val) (∀ (p : MvPolynomial A R), Membership.mem (MvPolynomial.supported R s) p → Eq ((MvPolynomial.aeval id) p) 0 → Eq p 0)","decl":"theorem algebraicIndependent_subtype {s : Set A} :\n    AlgebraicIndependent R ((↑) : s → A) ↔\n      ∀ p : MvPolynomial A R, p ∈ MvPolynomial.supported R s → aeval id p = 0 → p = 0 := by\n  apply @algebraicIndependent_comp_subtype _ _ _ id\n\n"}
{"name":"algebraicIndependent_of_finite","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"R : Type u_3\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\ns : Set A\nH : ∀ (t : Set A), HasSubset.Subset t s → t.Finite → AlgebraicIndependent R Subtype.val\n⊢ AlgebraicIndependent R Subtype.val","decl":"theorem algebraicIndependent_of_finite (s : Set A)\n    (H : ∀ t ⊆ s, t.Finite → AlgebraicIndependent R ((↑) : t → A)) :\n    AlgebraicIndependent R ((↑) : s → A) :=\n  algebraicIndependent_subtype.2 fun p hp ↦\n    algebraicIndependent_subtype.1 (H _ (mem_supported.1 hp) (Finset.finite_toSet _)) _ (by simp)\n\n"}
{"name":"algebraicIndependent_of_finite_type","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nH : ∀ (t : Set ι), t.Finite → AlgebraicIndependent R fun i => x ↑i\n⊢ AlgebraicIndependent R x","decl":"theorem algebraicIndependent_of_finite_type\n    (H : ∀ t : Set ι, t.Finite → AlgebraicIndependent R fun i : t ↦ x i) :\n    AlgebraicIndependent R x :=\n  (injective_iff_map_eq_zero _).mpr fun p ↦\n    algebraicIndependent_comp_subtype.1 (H _ p.vars.finite_toSet) _ p.mem_supported_vars\n\n"}
{"name":"AlgebraicIndependent.image_of_comp","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"R : Type u_3\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nι : Type u_7\nι' : Type u_8\ns : Set ι\nf : ι → ι'\ng : ι' → A\nhs : AlgebraicIndependent R fun x => g (f ↑x)\n⊢ AlgebraicIndependent R fun x => g ↑x","decl":"theorem AlgebraicIndependent.image_of_comp {ι ι'} (s : Set ι) (f : ι → ι') (g : ι' → A)\n    (hs : AlgebraicIndependent R fun x : s => g (f x)) :\n    AlgebraicIndependent R fun x : f '' s => g x := by\n  nontriviality R\n  have : InjOn f s := injOn_iff_injective.2 hs.injective.of_comp\n  exact (algebraicIndependent_equiv' (Equiv.Set.imageOfInjOn f s this) rfl).1 hs\n\n"}
{"name":"AlgebraicIndependent.image","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"R : Type u_3\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nι : Type u_7\ns : Set ι\nf : ι → A\nhs : AlgebraicIndependent R fun x => f ↑x\n⊢ AlgebraicIndependent R fun x => ↑x","decl":"theorem AlgebraicIndependent.image {ι} {s : Set ι} {f : ι → A}\n    (hs : AlgebraicIndependent R fun x : s => f x) :\n    AlgebraicIndependent R fun x : f '' s => (x : A) := by\n  convert AlgebraicIndependent.image_of_comp s f id hs\n\n"}
{"name":"algebraicIndependent_iUnion_of_directed","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"R : Type u_3\nA : Type u_5\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nη : Type u_7\ninst✝ : Nonempty η\ns : η → Set A\nhs : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\nh : ∀ (i : η), AlgebraicIndependent R Subtype.val\n⊢ AlgebraicIndependent R Subtype.val","decl":"theorem algebraicIndependent_iUnion_of_directed {η : Type*} [Nonempty η] {s : η → Set A}\n    (hs : Directed (· ⊆ ·) s) (h : ∀ i, AlgebraicIndependent R ((↑) : s i → A)) :\n    AlgebraicIndependent R ((↑) : (⋃ i, s i) → A) := by\n  refine algebraicIndependent_of_finite (⋃ i, s i) fun t ht ft => ?_\n  rcases finite_subset_iUnion ft ht with ⟨I, fi, hI⟩\n  rcases hs.finset_le fi.toFinset with ⟨i, hi⟩\n  exact (h i).mono (Subset.trans hI <| iUnion₂_subset fun j hj => hi j (fi.mem_toFinset.2 hj))\n\n"}
{"name":"algebraicIndependent_sUnion_of_directed","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"R : Type u_3\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\ns : Set (Set A)\nhsn : s.Nonempty\nhs : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) s\nh : ∀ (a : Set A), Membership.mem s a → AlgebraicIndependent R Subtype.val\n⊢ AlgebraicIndependent R Subtype.val","decl":"theorem algebraicIndependent_sUnion_of_directed {s : Set (Set A)} (hsn : s.Nonempty)\n    (hs : DirectedOn (· ⊆ ·) s) (h : ∀ a ∈ s, AlgebraicIndependent R ((↑) : a → A)) :\n    AlgebraicIndependent R ((↑) : ⋃₀ s → A) := by\n  letI : Nonempty s := Nonempty.to_subtype hsn\n  rw [sUnion_eq_iUnion]\n  exact algebraicIndependent_iUnion_of_directed hs.directed_val (by simpa using h)\n\n"}
{"name":"exists_maximal_algebraicIndependent","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"R : Type u_3\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\ns t : Set A\nhst : HasSubset.Subset s t\nhs : AlgebraicIndependent R Subtype.val\n⊢ Exists fun u => And (HasSubset.Subset s u) (Maximal (fun x => And (AlgebraicIndependent R Subtype.val) (HasSubset.Subset x t)) u)","decl":"theorem exists_maximal_algebraicIndependent (s t : Set A) (hst : s ⊆ t)\n    (hs : AlgebraicIndependent R ((↑) : s → A)) : ∃ u, s ⊆ u ∧\n      Maximal (fun (x : Set A) ↦ AlgebraicIndependent R ((↑) : x → A) ∧ x ⊆ t) u := by\n  refine zorn_subset_nonempty { u : Set A | AlgebraicIndependent R ((↑) : u → A) ∧ u ⊆ t}\n    (fun c hc chainc hcn ↦ ⟨⋃₀ c, ⟨?_, ?_⟩, fun _ ↦ subset_sUnion_of_mem⟩) s ⟨hs, hst⟩\n  · exact algebraicIndependent_sUnion_of_directed hcn chainc.directedOn (fun x hxc ↦ (hc hxc).1)\n  exact fun x ⟨w, hyc, hwy⟩ ↦ (hc hyc).2 hwy\n\n"}
{"name":"AlgebraicIndependent.repr_ker","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\n⊢ Eq (RingHom.ker ↑hx.repr) Bot.bot","decl":"theorem AlgebraicIndependent.repr_ker (hx : AlgebraicIndependent R x) :\n    RingHom.ker (hx.repr : adjoin R (range x) →+* MvPolynomial ι R) = ⊥ :=\n  (RingHom.injective_iff_ker_eq_bot _).1 (AlgEquiv.injective _)\n\n-- TODO - make this an `AlgEquiv`\n"}
{"name":"AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\ny : MvPolynomial (Option ι) R\n⊢ Eq (hx.mvPolynomialOptionEquivPolynomialAdjoin y) (Polynomial.map (↑hx.aevalEquiv) ((MvPolynomial.aeval fun o => o.elim Polynomial.X fun s => Polynomial.C (MvPolynomial.X s)) y))","decl":"@[simp]\ntheorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply\n    (hx : AlgebraicIndependent R x) (y) :\n    hx.mvPolynomialOptionEquivPolynomialAdjoin y =\n      Polynomial.map (hx.aevalEquiv : MvPolynomial ι R →+* adjoin R (range x))\n        (aeval (fun o : Option ι => o.elim Polynomial.X fun s : ι => Polynomial.C (X s)) y) :=\n  rfl\n\n"}
{"name":"AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_C'","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\nr : R\n⊢ Eq (Polynomial.C (hx.aevalEquiv (MvPolynomial.C r))) (Polynomial.C ((algebraMap R (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Set.range x)) x_1)) r))","decl":"/-- `simp`-normal form of `mvPolynomialOptionEquivPolynomialAdjoin_C` -/\n@[simp]\ntheorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_C'\n    (hx : AlgebraicIndependent R x) (r) :\n    Polynomial.C (hx.aevalEquiv (C r)) = Polynomial.C (algebraMap _ _ r) := by\n  congr\n  apply_fun Subtype.val using Subtype.val_injective\n  simp\n\n"}
{"name":"AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_C","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\nr : R\n⊢ Eq (hx.mvPolynomialOptionEquivPolynomialAdjoin (MvPolynomial.C r)) (Polynomial.C ((algebraMap R (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Set.range x)) x_1)) r))","decl":"theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_C\n    (hx : AlgebraicIndependent R x) (r) :\n    hx.mvPolynomialOptionEquivPolynomialAdjoin (C r) = Polynomial.C (algebraMap _ _ r) := by\n  simp\n\n"}
{"name":"AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_none","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\n⊢ Eq (hx.mvPolynomialOptionEquivPolynomialAdjoin (MvPolynomial.X Option.none)) Polynomial.X","decl":"theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_none\n    (hx : AlgebraicIndependent R x) :\n    hx.mvPolynomialOptionEquivPolynomialAdjoin (X none) = Polynomial.X := by\n  rw [AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply, aeval_X, Option.elim,\n    Polynomial.map_X]\n\n"}
{"name":"AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_some","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\ni : ι\n⊢ Eq (hx.mvPolynomialOptionEquivPolynomialAdjoin (MvPolynomial.X (Option.some i))) (Polynomial.C (hx.aevalEquiv (MvPolynomial.X i)))","decl":"theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_some\n    (hx : AlgebraicIndependent R x) (i) :\n    hx.mvPolynomialOptionEquivPolynomialAdjoin (X (some i)) =\n      Polynomial.C (hx.aevalEquiv (X i)) := by\n  rw [AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply, aeval_X, Option.elim,\n    Polynomial.map_C, RingHom.coe_coe]\n\n"}
{"name":"AlgebraicIndependent.aeval_comp_mvPolynomialOptionEquivPolynomialAdjoin","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_5\nx : ι → A\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhx : AlgebraicIndependent R x\na : A\n⊢ Eq ((↑(Polynomial.aeval a)).comp hx.mvPolynomialOptionEquivPolynomialAdjoin.toRingHom) ↑(MvPolynomial.aeval fun o => o.elim a x)","decl":"theorem AlgebraicIndependent.aeval_comp_mvPolynomialOptionEquivPolynomialAdjoin\n    (hx : AlgebraicIndependent R x) (a : A) :\n    RingHom.comp\n        (↑(Polynomial.aeval a : Polynomial (adjoin R (Set.range x)) →ₐ[_] A) :\n          Polynomial (adjoin R (Set.range x)) →+* A)\n        hx.mvPolynomialOptionEquivPolynomialAdjoin.toRingHom =\n      ↑(MvPolynomial.aeval fun o : Option ι => o.elim a x : MvPolynomial (Option ι) R →ₐ[R] A) := by\n  refine MvPolynomial.ringHom_ext ?_ ?_ <;>\n    simp only [RingHom.comp_apply, RingEquiv.toRingHom_eq_coe, RingEquiv.coe_toRingHom,\n      AlgHom.coe_toRingHom, AlgHom.coe_toRingHom]\n  · intro r\n    rw [hx.mvPolynomialOptionEquivPolynomialAdjoin_C, aeval_C, Polynomial.aeval_C,\n      IsScalarTower.algebraMap_apply R (adjoin R (range x)) A]\n  · rintro (⟨⟩ | ⟨i⟩)\n    · rw [hx.mvPolynomialOptionEquivPolynomialAdjoin_X_none, aeval_X, Polynomial.aeval_X,\n        Option.elim]\n    · rw [hx.mvPolynomialOptionEquivPolynomialAdjoin_X_some, Polynomial.aeval_C,\n        hx.algebraMap_aevalEquiv, aeval_X, aeval_X, Option.elim]\n\n"}
{"name":"algebraicIndependent_empty_type","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"ι : Type u_1\nK : Type u_4\nA : Type u_5\nx : ι → A\ninst✝⁴ : CommRing A\ninst✝³ : Field K\ninst✝² : Algebra K A\ninst✝¹ : IsEmpty ι\ninst✝ : Nontrivial A\n⊢ AlgebraicIndependent K x","decl":"theorem algebraicIndependent_empty_type [IsEmpty ι] [Nontrivial A] : AlgebraicIndependent K x := by\n  rw [algebraicIndependent_empty_type_iff]\n  exact RingHom.injective _\n\n"}
{"name":"algebraicIndependent_empty","module":"Mathlib.RingTheory.AlgebraicIndependent.Basic","initialProofState":"K : Type u_4\nA : Type u_5\ninst✝³ : CommRing A\ninst✝² : Field K\ninst✝¹ : Algebra K A\ninst✝ : Nontrivial A\n⊢ AlgebraicIndependent K Subtype.val","decl":"theorem algebraicIndependent_empty [Nontrivial A] :\n    AlgebraicIndependent K ((↑) : (∅ : Set A) → A) :=\n  algebraicIndependent_empty_type\n\n"}
