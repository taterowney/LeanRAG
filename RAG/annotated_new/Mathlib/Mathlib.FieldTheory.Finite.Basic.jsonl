{"name":"FiniteField.card_image_polynomial_eval","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"R : Type u_2\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : DecidableEq R\ninst✝ : Fintype R\np : Polynomial R\nhp : LT.lt 0 p.degree\n⊢ LE.le (Fintype.card R) (HMul.hMul p.natDegree (Finset.image (fun x => Polynomial.eval x p) Finset.univ).card)","decl":"/-- The cardinality of a field is at most `n` times the cardinality of the image of a degree `n`\n  polynomial -/\ntheorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : R[X]} (hp : 0 < p.degree) :\n    Fintype.card R ≤ natDegree p * #(univ.image fun x => eval x p) :=\n  Finset.card_le_mul_card_image _ _ (fun a _ =>\n    calc\n      _ = #(p - C a).roots.toFinset :=\n        congr_arg card (by simp [Finset.ext_iff, ← mem_roots_sub_C hp])\n      _ ≤ Multiset.card (p - C a).roots := Multiset.toFinset_card_le _\n      _ ≤ _ := card_roots_sub_C' hp)\n\n"}
{"name":"FiniteField.exists_root_sum_quadratic","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"R : Type u_2\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : Fintype R\nf g : Polynomial R\nhf2 : Eq f.degree 2\nhg2 : Eq g.degree 2\nhR : Eq (HMod.hMod (Fintype.card R) 2) 1\n⊢ Exists fun a => Exists fun b => Eq (HAdd.hAdd (Polynomial.eval a f) (Polynomial.eval b g)) 0","decl":"/-- If `f` and `g` are quadratic polynomials, then the `f.eval a + g.eval b = 0` has a solution. -/\ntheorem exists_root_sum_quadratic [Fintype R] {f g : R[X]} (hf2 : degree f = 2) (hg2 : degree g = 2)\n    (hR : Fintype.card R % 2 = 1) : ∃ a b, f.eval a + g.eval b = 0 :=\n  letI := Classical.decEq R\n  suffices ¬Disjoint (univ.image fun x : R => eval x f)\n    (univ.image fun x : R => eval x (-g)) by\n    simp only [disjoint_left, mem_image] at this\n    push_neg at this\n    rcases this with ⟨x, ⟨a, _, ha⟩, ⟨b, _, hb⟩⟩\n    exact ⟨a, b, by rw [ha, ← hb, eval_neg, neg_add_cancel]⟩\n  fun hd : Disjoint _ _ =>\n  lt_irrefl (2 * #((univ.image fun x : R => eval x f) ∪ univ.image fun x : R => eval x (-g))) <|\n    calc 2 * #((univ.image fun x : R => eval x f) ∪ univ.image fun x : R => eval x (-g))\n        ≤ 2 * Fintype.card R := Nat.mul_le_mul_left _ (Finset.card_le_univ _)\n      _ = Fintype.card R + Fintype.card R := two_mul _\n      _ < natDegree f * #(univ.image fun x : R => eval x f) +\n            natDegree (-g) * #(univ.image fun x : R => eval x (-g)) :=\n        (add_lt_add_of_lt_of_le\n          (lt_of_le_of_ne (card_image_polynomial_eval (by rw [hf2]; decide))\n            (mt (congr_arg (· % 2)) (by simp [natDegree_eq_of_degree_eq_some hf2, hR])))\n          (card_image_polynomial_eval (by rw [degree_neg, hg2]; decide)))\n      _ = 2 * #((univ.image fun x : R => eval x f) ∪ univ.image fun x : R => eval x (-g)) := by\n        rw [card_union_of_disjoint hd]\n        simp [natDegree_eq_of_degree_eq_some hf2, natDegree_eq_of_degree_eq_some hg2, mul_add]\n\n"}
{"name":"FiniteField.prod_univ_units_id_eq_neg_one","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝² : CommRing K\ninst✝¹ : IsDomain K\ninst✝ : Fintype (Units K)\n⊢ Eq (Finset.univ.prod fun x => x) (-1)","decl":"theorem prod_univ_units_id_eq_neg_one [CommRing K] [IsDomain K] [Fintype Kˣ] :\n    ∏ x : Kˣ, x = (-1 : Kˣ) := by\n  classical\n    have : (∏ x ∈ (@univ Kˣ _).erase (-1), x) = 1 :=\n      prod_involution (fun x _ => x⁻¹) (by simp)\n        (fun a => by simp +contextual [Units.inv_eq_self_iff])\n        (fun a => by simp [@inv_eq_iff_eq_inv _ _ a]) (by simp)\n    rw [← insert_erase (mem_univ (-1 : Kˣ)), prod_insert (not_mem_erase _ _), this, mul_one]\n\n"}
{"name":"FiniteField.card_cast_subgroup_card_ne_zero","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝³ : Ring K\ninst✝² : NoZeroDivisors K\ninst✝¹ : Nontrivial K\nG : Subgroup (Units K)\ninst✝ : Fintype (Subtype fun x => Membership.mem G x)\n⊢ Ne (↑(Fintype.card (Subtype fun x => Membership.mem G x))) 0","decl":"theorem card_cast_subgroup_card_ne_zero [Ring K] [NoZeroDivisors K] [Nontrivial K]\n    (G : Subgroup Kˣ) [Fintype G] : (Fintype.card G : K) ≠ 0 := by\n  let n := Fintype.card G\n  intro nzero\n  have ⟨p, char_p⟩ := CharP.exists K\n  have hd : p ∣ n := (CharP.cast_eq_zero_iff K p n).mp nzero\n  cases CharP.char_is_prime_or_zero K p with\n  | inr pzero =>\n    exact (Fintype.card_pos).ne' <| Nat.eq_zero_of_zero_dvd <| pzero ▸ hd\n  | inl pprime =>\n    have fact_pprime := Fact.mk pprime\n    -- G has an element x of order p by Cauchy's theorem\n    have ⟨x, hx⟩ := exists_prime_orderOf_dvd_card p hd\n    -- F has an element u (= ↑↑x) of order p\n    let u := ((x : Kˣ) : K)\n    have hu : orderOf u = p := by rwa [orderOf_units, Subgroup.orderOf_coe]\n    -- u ^ p = 1 implies (u - 1) ^ p = 0 and hence u = 1 ...\n    have h : u = 1 := by\n      rw [← sub_left_inj, sub_self 1]\n      apply pow_eq_zero (n := p)\n      rw [sub_pow_char_of_commute, one_pow, ← hu, pow_orderOf_eq_one, sub_self]\n      exact Commute.one_right u\n    -- ... meaning x didn't have order p after all, contradiction\n    apply pprime.one_lt.ne\n    rw [← hu, h, orderOf_one]\n\n"}
{"name":"FiniteField.sum_subgroup_units_eq_zero","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝² : Ring K\ninst✝¹ : NoZeroDivisors K\nG : Subgroup (Units K)\ninst✝ : Fintype (Subtype fun x => Membership.mem G x)\nhg : Ne G Bot.bot\n⊢ Eq (Finset.univ.sum fun x => ↑↑x) 0","decl":"/-- The sum of a nontrivial subgroup of the units of a field is zero. -/\ntheorem sum_subgroup_units_eq_zero [Ring K] [NoZeroDivisors K]\n    {G : Subgroup Kˣ} [Fintype G] (hg : G ≠ ⊥) :\n    ∑ x : G, (x.val : K) = 0 := by\n  rw [Subgroup.ne_bot_iff_exists_ne_one] at hg\n  rcases hg with ⟨a, ha⟩\n  -- The action of a on G as an embedding\n  let a_mul_emb : G ↪ G := mulLeftEmbedding a\n  -- ... and leaves G unchanged\n  have h_unchanged : Finset.univ.map a_mul_emb = Finset.univ := by simp\n  -- Therefore the sum of x over a G is the sum of a x over G\n  have h_sum_map := Finset.univ.sum_map a_mul_emb fun x => ((x : Kˣ) : K)\n  -- ... and the former is the sum of x over G.\n  -- By algebraic manipulation, we have Σ G, x = ∑ G, a x = a ∑ G, x\n  simp only [h_unchanged, mulLeftEmbedding_apply, Subgroup.coe_mul, Units.val_mul, ← mul_sum,\n    a_mul_emb] at h_sum_map\n  -- thus one of (a - 1) or ∑ G, x is zero\n  have hzero : (((a : Kˣ) : K) - 1) = 0 ∨ ∑ x : ↥G, ((x : Kˣ) : K) = 0 := by\n    rw [← mul_eq_zero, sub_mul, ← h_sum_map, one_mul, sub_self]\n  apply Or.resolve_left hzero\n  contrapose! ha\n  ext\n  rwa [← sub_eq_zero]\n\n"}
{"name":"FiniteField.sum_subgroup_units","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝³ : Ring K\ninst✝² : NoZeroDivisors K\nG : Subgroup (Units K)\ninst✝¹ : Fintype (Subtype fun x => Membership.mem G x)\ninst✝ : Decidable (Eq G Bot.bot)\n⊢ Eq (Finset.univ.sum fun x => ↑↑x) (ite (Eq G Bot.bot) 1 0)","decl":"/-- The sum of a subgroup of the units of a field is 1 if the subgroup is trivial and 1 otherwise -/\n@[simp]\ntheorem sum_subgroup_units [Ring K] [NoZeroDivisors K]\n    {G : Subgroup Kˣ} [Fintype G] [Decidable (G = ⊥)] :\n    ∑ x : G, (x.val : K) = if G = ⊥ then 1 else 0 := by\n  by_cases G_bot : G = ⊥\n  · subst G_bot\n    simp only [univ_unique, sum_singleton, ↓reduceIte, Units.val_eq_one, OneMemClass.coe_eq_one]\n    rw [Set.default_coe_singleton]\n    rfl\n  · simp only [G_bot, ite_false]\n    exact sum_subgroup_units_eq_zero G_bot\n\n"}
{"name":"FiniteField.sum_subgroup_pow_eq_zero","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝² : CommRing K\ninst✝¹ : NoZeroDivisors K\nG : Subgroup (Units K)\ninst✝ : Fintype (Subtype fun x => Membership.mem G x)\nk : Nat\nk_pos : Ne k 0\nk_lt_card_G : LT.lt k (Fintype.card (Subtype fun x => Membership.mem G x))\n⊢ Eq (Finset.univ.sum fun x => HPow.hPow (↑↑x) k) 0","decl":"@[simp]\ntheorem sum_subgroup_pow_eq_zero [CommRing K] [NoZeroDivisors K]\n    {G : Subgroup Kˣ} [Fintype G] {k : ℕ} (k_pos : k ≠ 0) (k_lt_card_G : k < Fintype.card G) :\n    ∑ x : G, ((x : Kˣ) : K) ^ k = 0 := by\n  rw [← Nat.card_eq_fintype_card] at k_lt_card_G\n  nontriviality K\n  have := NoZeroDivisors.to_isDomain K\n  rcases (exists_pow_ne_one_of_isCyclic k_pos k_lt_card_G) with ⟨a, ha⟩\n  rw [Finset.sum_eq_multiset_sum]\n  have h_multiset_map :\n    Finset.univ.val.map (fun x : G => ((x : Kˣ) : K) ^ k) =\n      Finset.univ.val.map (fun x : G => ((x : Kˣ) : K) ^ k * ((a : Kˣ) : K) ^ k) := by\n    simp_rw [← mul_pow]\n    have as_comp :\n      (fun x : ↥G => (((x : Kˣ) : K) * ((a : Kˣ) : K)) ^ k)\n        = (fun x : ↥G => ((x : Kˣ) : K) ^ k) ∘ fun x : ↥G => x * a := by\n      funext x\n      simp only [Function.comp_apply, Subgroup.coe_mul, Units.val_mul]\n    rw [as_comp, ← Multiset.map_map]\n    congr\n    rw [eq_comm]\n    exact Multiset.map_univ_val_equiv (Equiv.mulRight a)\n  have h_multiset_map_sum : (Multiset.map (fun x : G => ((x : Kˣ) : K) ^ k) Finset.univ.val).sum =\n    (Multiset.map (fun x : G => ((x : Kˣ) : K) ^ k * ((a : Kˣ) : K) ^ k) Finset.univ.val).sum := by\n    rw [h_multiset_map]\n  rw [Multiset.sum_map_mul_right] at h_multiset_map_sum\n  have hzero : (((a : Kˣ) : K) ^ k - 1 : K)\n                  * (Multiset.map (fun i : G => (i.val : K) ^ k) Finset.univ.val).sum = 0 := by\n    rw [sub_mul, mul_comm, ← h_multiset_map_sum, one_mul, sub_self]\n  rw [mul_eq_zero] at hzero\n  refine hzero.resolve_left fun h => ha ?_\n  ext\n  rw [← sub_eq_zero]\n  simp_rw [SubmonoidClass.coe_pow, Units.val_pow_eq_pow_val, OneMemClass.coe_one, Units.val_one, h]\n\n"}
{"name":"FiniteField.pow_card_sub_one_eq_one","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝¹ : GroupWithZero K\ninst✝ : Fintype K\na : K\nha : Ne a 0\n⊢ Eq (HPow.hPow a (HSub.hSub (Fintype.card K) 1)) 1","decl":"theorem pow_card_sub_one_eq_one (a : K) (ha : a ≠ 0) : a ^ (q - 1) = 1 := by\n  calc\n    a ^ (Fintype.card K - 1) = (Units.mk0 a ha ^ (Fintype.card K - 1) : Kˣ).1 := by\n      rw [Units.val_pow_eq_pow_val, Units.val_mk0]\n    _ = 1 := by\n      classical\n        rw [← Fintype.card_units, pow_card_eq_one]\n        rfl\n\n"}
{"name":"FiniteField.pow_card","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝¹ : GroupWithZero K\ninst✝ : Fintype K\na : K\n⊢ Eq (HPow.hPow a (Fintype.card K)) a","decl":"theorem pow_card (a : K) : a ^ q = a := by\n  by_cases h : a = 0; · rw [h]; apply zero_pow Fintype.card_ne_zero\n  rw [← Nat.succ_pred_eq_of_pos Fintype.card_pos, pow_succ, Nat.pred_eq_sub_one,\n    pow_card_sub_one_eq_one a h, one_mul]\n\n"}
{"name":"FiniteField.pow_card_pow","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝¹ : GroupWithZero K\ninst✝ : Fintype K\nn : Nat\na : K\n⊢ Eq (HPow.hPow a (HPow.hPow (Fintype.card K) n)) a","decl":"theorem pow_card_pow (n : ℕ) (a : K) : a ^ q ^ n = a := by\n  induction n with\n  | zero => simp\n  | succ n ih => simp [pow_succ, pow_mul, ih, pow_card]\n\n"}
{"name":"FiniteField.card","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝² : Field K\ninst✝¹ : Fintype K\np : Nat\ninst✝ : CharP K p\n⊢ Exists fun n => And (Nat.Prime p) (Eq (Fintype.card K) (HPow.hPow p ↑n))","decl":"/-- The cardinality `q` is a power of the characteristic of `K`. -/\n@[stacks 09HY \"first part\"]\ntheorem card (p : ℕ) [CharP K p] : ∃ n : ℕ+, Nat.Prime p ∧ q = p ^ (n : ℕ) := by\n  haveI hp : Fact p.Prime := ⟨CharP.char_is_prime K p⟩\n  letI : Module (ZMod p) K := { (ZMod.castHom dvd_rfl K : ZMod p →+* _).toModule with }\n  obtain ⟨n, h⟩ := VectorSpace.card_fintype (ZMod p) K\n  rw [ZMod.card] at h\n  refine ⟨⟨n, ?_⟩, hp.1, h⟩\n  apply Or.resolve_left (Nat.eq_zero_or_pos n)\n  rintro rfl\n  rw [pow_zero] at h\n  have : (0 : K) = 1 := by apply Fintype.card_le_one_iff.mp (le_of_eq h)\n  exact absurd this zero_ne_one\n\n-- this statement doesn't use `q` because we want `K` to be an explicit parameter\n"}
{"name":"FiniteField.card'","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : Fintype K\n⊢ Exists fun p => Exists fun n => And (Nat.Prime p) (Eq (Fintype.card K) (HPow.hPow p ↑n))","decl":"theorem card' : ∃ (p : ℕ) (n : ℕ+), Nat.Prime p ∧ Fintype.card K = p ^ (n : ℕ) :=\n  let ⟨p, hc⟩ := CharP.exists K\n  ⟨p, @FiniteField.card K _ _ p hc⟩\n\n"}
{"name":"FiniteField.isPrimePow_card","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : Fintype K\n⊢ IsPrimePow (Fintype.card K)","decl":"lemma isPrimePow_card : IsPrimePow (Fintype.card K) := by\n  obtain ⟨p, n, hp, hn⟩ := card' K\n  exact ⟨p, n, Nat.prime_iff.mp hp, n.prop, hn.symm⟩\n\n-- Porting note: this was a `simp` lemma with a 5 lines proof.\n"}
{"name":"FiniteField.cast_card_eq_zero","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : Fintype K\n⊢ Eq (↑(Fintype.card K)) 0","decl":"theorem cast_card_eq_zero : (q : K) = 0 := by\n  simp\n\n"}
{"name":"FiniteField.forall_pow_eq_one_iff","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : Fintype K\ni : Nat\n⊢ Iff (∀ (x : Units K), Eq (HPow.hPow x i) 1) (Dvd.dvd (HSub.hSub (Fintype.card K) 1) i)","decl":"theorem forall_pow_eq_one_iff (i : ℕ) : (∀ x : Kˣ, x ^ i = 1) ↔ q - 1 ∣ i := by\n  classical\n    obtain ⟨x, hx⟩ := IsCyclic.exists_generator (α := Kˣ)\n    rw [← Nat.card_eq_fintype_card, ← Nat.card_units, ← orderOf_eq_card_of_forall_mem_zpowers hx,\n      orderOf_dvd_iff_pow_eq_one]\n    constructor\n    · intro h; apply h\n    · intro h y\n      simp_rw [← mem_powers_iff_mem_zpowers] at hx\n      rcases hx y with ⟨j, rfl⟩\n      rw [← pow_mul, mul_comm, pow_mul, h, one_pow]\n\n"}
{"name":"FiniteField.sum_pow_units","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝² : Field K\ninst✝¹ : Fintype K\ninst✝ : DecidableEq K\ni : Nat\n⊢ Eq (Finset.univ.sum fun x => HPow.hPow (↑x) i) (ite (Dvd.dvd (HSub.hSub (Fintype.card K) 1) i) (-1) 0)","decl":"/-- The sum of `x ^ i` as `x` ranges over the units of a finite field of cardinality `q`\nis equal to `0` unless `(q - 1) ∣ i`, in which case the sum is `q - 1`. -/\ntheorem sum_pow_units [DecidableEq K] (i : ℕ) :\n    (∑ x : Kˣ, (x ^ i : K)) = if q - 1 ∣ i then -1 else 0 := by\n  let φ : Kˣ →* K :=\n    { toFun := fun x => x ^ i\n      map_one' := by simp\n      map_mul' := by intros; simp [mul_pow] }\n  have : Decidable (φ = 1) := by classical infer_instance\n  calc (∑ x : Kˣ, φ x) = if φ = 1 then Fintype.card Kˣ else 0 := sum_hom_units φ\n      _ = if q - 1 ∣ i then -1 else 0 := by\n        suffices q - 1 ∣ i ↔ φ = 1 by\n          simp only [this]\n          split_ifs; swap\n          · exact Nat.cast_zero\n          · rw [Fintype.card_units, Nat.cast_sub,\n              cast_card_eq_zero, Nat.cast_one, zero_sub]\n            show 1 ≤ q; exact Fintype.card_pos_iff.mpr ⟨0⟩\n        rw [← forall_pow_eq_one_iff, DFunLike.ext_iff]\n        apply forall_congr'; intro x; simp [φ, Units.ext_iff]\n\n"}
{"name":"FiniteField.sum_pow_lt_card_sub_one","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : Fintype K\ni : Nat\nh : LT.lt i (HSub.hSub (Fintype.card K) 1)\n⊢ Eq (Finset.univ.sum fun x => HPow.hPow x i) 0","decl":"/-- The sum of `x ^ i` as `x` ranges over a finite field of cardinality `q`\nis equal to `0` if `i < q - 1`. -/\ntheorem sum_pow_lt_card_sub_one (i : ℕ) (h : i < q - 1) : ∑ x : K, x ^ i = 0 := by\n  by_cases hi : i = 0\n  · simp only [hi, nsmul_one, sum_const, pow_zero, card_univ, cast_card_eq_zero]\n  classical\n    have hiq : ¬q - 1 ∣ i := by contrapose! h; exact Nat.le_of_dvd (Nat.pos_of_ne_zero hi) h\n    let φ : Kˣ ↪ K := ⟨fun x ↦ x, Units.ext⟩\n    have : univ.map φ = univ \\ {0} := by\n      ext x\n      simpa only [mem_map, mem_univ, Function.Embedding.coeFn_mk, true_and, mem_sdiff,\n        mem_singleton, φ] using isUnit_iff_ne_zero\n    calc\n      ∑ x : K, x ^ i = ∑ x ∈ univ \\ {(0 : K)}, x ^ i := by\n        rw [← sum_sdiff ({0} : Finset K).subset_univ, sum_singleton, zero_pow hi, add_zero]\n      _ = ∑ x : Kˣ, (x ^ i : K) := by simp [φ, ← this, univ.sum_map φ]\n      _ = 0 := by rw [sum_pow_units K i, if_neg]; exact hiq\n\n"}
{"name":"FiniteField.X_pow_card_sub_X_natDegree_eq","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K' : Type u_3\ninst✝ : Field K'\np : Nat\nhp : LT.lt 1 p\n⊢ Eq (HSub.hSub (HPow.hPow Polynomial.X p) Polynomial.X).natDegree p","decl":"theorem X_pow_card_sub_X_natDegree_eq (hp : 1 < p) : (X ^ p - X : K'[X]).natDegree = p := by\n  have h1 : (X : K'[X]).degree < (X ^ p : K'[X]).degree := by\n    rw [degree_X_pow, degree_X]\n    exact mod_cast hp\n  rw [natDegree_eq_of_degree_eq (degree_sub_eq_left_of_degree_lt h1), natDegree_X_pow]\n\n"}
{"name":"FiniteField.X_pow_card_pow_sub_X_natDegree_eq","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K' : Type u_3\ninst✝ : Field K'\np n : Nat\nhn : Ne n 0\nhp : LT.lt 1 p\n⊢ Eq (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow p n)) Polynomial.X).natDegree (HPow.hPow p n)","decl":"theorem X_pow_card_pow_sub_X_natDegree_eq (hn : n ≠ 0) (hp : 1 < p) :\n    (X ^ p ^ n - X : K'[X]).natDegree = p ^ n :=\n  X_pow_card_sub_X_natDegree_eq K' <| Nat.one_lt_pow hn hp\n\n"}
{"name":"FiniteField.X_pow_card_sub_X_ne_zero","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K' : Type u_3\ninst✝ : Field K'\np : Nat\nhp : LT.lt 1 p\n⊢ Ne (HSub.hSub (HPow.hPow Polynomial.X p) Polynomial.X) 0","decl":"theorem X_pow_card_sub_X_ne_zero (hp : 1 < p) : (X ^ p - X : K'[X]) ≠ 0 :=\n  ne_zero_of_natDegree_gt <|\n    calc\n      1 < _ := hp\n      _ = _ := (X_pow_card_sub_X_natDegree_eq K' hp).symm\n\n"}
{"name":"FiniteField.X_pow_card_pow_sub_X_ne_zero","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K' : Type u_3\ninst✝ : Field K'\np n : Nat\nhn : Ne n 0\nhp : LT.lt 1 p\n⊢ Ne (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow p n)) Polynomial.X) 0","decl":"theorem X_pow_card_pow_sub_X_ne_zero (hn : n ≠ 0) (hp : 1 < p) : (X ^ p ^ n - X : K'[X]) ≠ 0 :=\n  X_pow_card_sub_X_ne_zero K' <| Nat.one_lt_pow hn hp\n\n"}
{"name":"FiniteField.roots_X_pow_card_sub_X","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : Fintype K\n⊢ Eq (HSub.hSub (HPow.hPow Polynomial.X (Fintype.card K)) Polynomial.X).roots Finset.univ.val","decl":"theorem roots_X_pow_card_sub_X : roots (X ^ q - X : K[X]) = Finset.univ.val := by\n  classical\n    have aux : (X ^ q - X : K[X]) ≠ 0 := X_pow_card_sub_X_ne_zero K Fintype.one_lt_card\n    have : (roots (X ^ q - X : K[X])).toFinset = Finset.univ := by\n      rw [eq_univ_iff_forall]\n      intro x\n      rw [Multiset.mem_toFinset, mem_roots aux, IsRoot.def, eval_sub, eval_pow, eval_X,\n        sub_eq_zero, pow_card]\n    rw [← this, Multiset.toFinset_val, eq_comm, Multiset.dedup_eq_self]\n    apply nodup_roots\n    rw [separable_def]\n    convert isCoprime_one_right.neg_right (R := K[X]) using 1\n    rw [derivative_sub, derivative_X, derivative_X_pow, Nat.cast_card_eq_zero K, C_0,\n      zero_mul, zero_sub]\n\n"}
{"name":"FiniteField.frobenius_pow","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝³ : Field K\ninst✝² : Fintype K\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : CharP K p\nn : Nat\nhcard : Eq (Fintype.card K) (HPow.hPow p n)\n⊢ Eq (HPow.hPow (frobenius K p) n) 1","decl":"theorem frobenius_pow {p : ℕ} [Fact p.Prime] [CharP K p] {n : ℕ} (hcard : q = p ^ n) :\n    frobenius K p ^ n = 1 := by\n  ext x; conv_rhs => rw [RingHom.one_def, RingHom.id_apply, ← pow_card x, hcard]\n  clear hcard\n  induction n with\n  | zero => simp\n  | succ n hn =>\n    rw [pow_succ', pow_succ, pow_mul, RingHom.mul_def, RingHom.comp_apply, frobenius_def, hn]\n\n"}
{"name":"FiniteField.expand_card","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : Fintype K\nf : Polynomial K\n⊢ Eq ((Polynomial.expand K (Fintype.card K)) f) (HPow.hPow f (Fintype.card K))","decl":"theorem expand_card (f : K[X]) : expand K q f = f ^ q := by\n  cases' CharP.exists K with p hp\n  letI := hp\n  rcases FiniteField.card K p with ⟨⟨n, npos⟩, ⟨hp, hn⟩⟩\n  haveI : Fact p.Prime := ⟨hp⟩\n  dsimp at hn\n  rw [hn, ← map_expand_pow_char, frobenius_pow hn, RingHom.one_def, map_id]\n\n"}
{"name":"ZMod.sq_add_sq","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : ZMod p\n⊢ Exists fun a => Exists fun b => Eq (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2)) x","decl":"theorem sq_add_sq (p : ℕ) [hp : Fact p.Prime] (x : ZMod p) : ∃ a b : ZMod p, a ^ 2 + b ^ 2 = x := by\n  cases' hp.1.eq_two_or_odd with hp2 hp_odd\n  · subst p\n    change Fin 2 at x\n    fin_cases x\n    · use 0; simp\n    · use 0, 1; simp\n  let f : (ZMod p)[X] := X ^ 2\n  let g : (ZMod p)[X] := X ^ 2 - C x\n  obtain ⟨a, b, hab⟩ : ∃ a b, f.eval a + g.eval b = 0 :=\n    @exists_root_sum_quadratic _ _ _ _ f g (degree_X_pow 2) (degree_X_pow_sub_C (by decide) _)\n      (by rw [ZMod.card, hp_odd])\n  refine ⟨a, b, ?_⟩\n  rw [← sub_eq_zero]\n  simpa only [f, g, eval_C, eval_X, eval_pow, eval_sub, ← add_sub_assoc] using hab\n\n"}
{"name":"Nat.sq_add_sq_zmodEq","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nx : Int\n⊢ Exists fun a => Exists fun b => And (LE.le a (HDiv.hDiv p 2)) (And (LE.le b (HDiv.hDiv p 2)) ((↑p).ModEq (HAdd.hAdd (HPow.hPow (↑a) 2) (HPow.hPow (↑b) 2)) x))","decl":"/-- If `p` is a prime natural number and `x` is an integer number, then there exist natural numbers\n`a ≤ p / 2` and `b ≤ p / 2` such that `a ^ 2 + b ^ 2 ≡ x [ZMOD p]`. This is a version of\n`ZMod.sq_add_sq` with estimates on `a` and `b`. -/\ntheorem Nat.sq_add_sq_zmodEq (p : ℕ) [Fact p.Prime] (x : ℤ) :\n    ∃ a b : ℕ, a ≤ p / 2 ∧ b ≤ p / 2 ∧ (a : ℤ) ^ 2 + (b : ℤ) ^ 2 ≡ x [ZMOD p] := by\n  rcases ZMod.sq_add_sq p x with ⟨a, b, hx⟩\n  refine ⟨a.valMinAbs.natAbs, b.valMinAbs.natAbs, ZMod.natAbs_valMinAbs_le _,\n    ZMod.natAbs_valMinAbs_le _, ?_⟩\n  rw [← a.coe_valMinAbs, ← b.coe_valMinAbs] at hx\n  push_cast\n  rw [sq_abs, sq_abs, ← ZMod.intCast_eq_intCast_iff]\n  exact mod_cast hx\n\n"}
{"name":"Nat.sq_add_sq_modEq","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nx : Nat\n⊢ Exists fun a => Exists fun b => And (LE.le a (HDiv.hDiv p 2)) (And (LE.le b (HDiv.hDiv p 2)) (p.ModEq (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2)) x))","decl":"/-- If `p` is a prime natural number and `x` is a natural number, then there exist natural numbers\n`a ≤ p / 2` and `b ≤ p / 2` such that `a ^ 2 + b ^ 2 ≡ x [MOD p]`. This is a version of\n`ZMod.sq_add_sq` with estimates on `a` and `b`. -/\ntheorem Nat.sq_add_sq_modEq (p : ℕ) [Fact p.Prime] (x : ℕ) :\n    ∃ a b : ℕ, a ≤ p / 2 ∧ b ≤ p / 2 ∧ a ^ 2 + b ^ 2 ≡ x [MOD p] := by\n  simpa only [← Int.natCast_modEq_iff] using Nat.sq_add_sq_zmodEq p x\n\n"}
{"name":"CharP.sq_add_sq","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"R : Type u_3\ninst✝³ : CommRing R\ninst✝² : IsDomain R\np : Nat\ninst✝¹ : NeZero p\ninst✝ : CharP R p\nx : Int\n⊢ Exists fun a => Exists fun b => Eq (HAdd.hAdd (HPow.hPow (↑a) 2) (HPow.hPow (↑b) 2)) ↑x","decl":"theorem sq_add_sq (R : Type*) [CommRing R] [IsDomain R] (p : ℕ) [NeZero p] [CharP R p] (x : ℤ) :\n    ∃ a b : ℕ, ((a : R) ^ 2 + (b : R) ^ 2) = x := by\n  haveI := char_is_prime_of_pos R p\n  obtain ⟨a, b, hab⟩ := ZMod.sq_add_sq p x\n  refine ⟨a.val, b.val, ?_⟩\n  simpa using congr_arg (ZMod.castHom dvd_rfl R) hab\n\n"}
{"name":"ZMod.pow_totient","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"n : Nat\nx : Units (ZMod n)\n⊢ Eq (HPow.hPow x n.totient) 1","decl":"/-- The **Fermat-Euler totient theorem**. `Nat.ModEq.pow_totient` is an alternative statement\n  of the same theorem. -/\n@[simp]\ntheorem ZMod.pow_totient {n : ℕ} (x : (ZMod n)ˣ) : x ^ φ n = 1 := by\n  cases n\n  · rw [Nat.totient_zero, pow_zero]\n  · rw [← card_units_eq_totient, pow_card_eq_one]\n\n"}
{"name":"Nat.ModEq.pow_totient","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"x n : Nat\nh : x.Coprime n\n⊢ n.ModEq (HPow.hPow x n.totient) 1","decl":"/-- The **Fermat-Euler totient theorem**. `ZMod.pow_totient` is an alternative statement\n  of the same theorem. -/\ntheorem Nat.ModEq.pow_totient {x n : ℕ} (h : Nat.Coprime x n) : x ^ φ n ≡ 1 [MOD n] := by\n  rw [← ZMod.eq_iff_modEq_nat]\n  let x' : Units (ZMod n) := ZMod.unitOfCoprime _ h\n  have := ZMod.pow_totient x'\n  apply_fun ((fun (x : Units (ZMod n)) => (x : ZMod n)) : Units (ZMod n) → ZMod n) at this\n  simpa only [Nat.succ_eq_add_one, Nat.cast_pow, Units.val_one, Nat.cast_one,\n    coe_unitOfCoprime, Units.val_pow_eq_pow_val]\n\n"}
{"name":"instFiniteZModUnits","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"n : Nat\n⊢ Finite (Units (ZMod n))","decl":"/-- For each `n ≥ 0`, the unit group of `ZMod n` is finite. -/\ninstance instFiniteZModUnits : (n : ℕ) → Finite (ZMod n)ˣ\n| 0     => Finite.of_fintype ℤˣ\n| _ + 1 => inferInstance\n\n"}
{"name":"card_eq_pow_finrank","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"K : Type u_1\nV : Type u_3\ninst✝⁴ : Fintype K\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Fintype V\n⊢ Eq (Fintype.card V) (HPow.hPow (Fintype.card K) (Module.finrank K V))","decl":"theorem card_eq_pow_finrank [Fintype V] : Fintype.card V = q ^ Module.finrank K V := by\n  let b := IsNoetherian.finsetBasis K V\n  rw [Module.card_fintype b, ← Module.finrank_eq_card_basis b]\n\n"}
{"name":"ZMod.pow_card","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nx : ZMod p\n⊢ Eq (HPow.hPow x p) x","decl":"/-- A variation on Fermat's little theorem. See `ZMod.pow_card_sub_one_eq_one` -/\n@[simp]\ntheorem pow_card {p : ℕ} [Fact p.Prime] (x : ZMod p) : x ^ p = x := by\n  have h := FiniteField.pow_card x; rwa [ZMod.card p] at h\n\n"}
{"name":"ZMod.pow_card_pow","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"n p : Nat\ninst✝ : Fact (Nat.Prime p)\nx : ZMod p\n⊢ Eq (HPow.hPow x (HPow.hPow p n)) x","decl":"@[simp]\ntheorem pow_card_pow {n p : ℕ} [Fact p.Prime] (x : ZMod p) : x ^ p ^ n = x := by\n  induction n with\n  | zero => simp\n  | succ n ih => simp [pow_succ, pow_mul, ih, pow_card]\n\n"}
{"name":"ZMod.frobenius_zmod","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (frobenius (ZMod p) p) (RingHom.id (ZMod p))","decl":"@[simp]\ntheorem frobenius_zmod (p : ℕ) [Fact p.Prime] : frobenius (ZMod p) p = RingHom.id _ := by\n  ext a\n  rw [frobenius_def, ZMod.pow_card, RingHom.id_apply]\n\n-- Porting note: this was a `simp` lemma, but now the LHS simplify to `φ p`.\n"}
{"name":"ZMod.card_units","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (Fintype.card (Units (ZMod p))) (HSub.hSub p 1)","decl":"theorem card_units (p : ℕ) [Fact p.Prime] : Fintype.card (ZMod p)ˣ = p - 1 := by\n  rw [Fintype.card_units, card]\n\n"}
{"name":"ZMod.units_pow_card_sub_one_eq_one","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Units (ZMod p)\n⊢ Eq (HPow.hPow a (HSub.hSub p 1)) 1","decl":"/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem units_pow_card_sub_one_eq_one (p : ℕ) [Fact p.Prime] (a : (ZMod p)ˣ) : a ^ (p - 1) = 1 := by\n  rw [← card_units p, pow_card_eq_one]\n\n"}
{"name":"ZMod.pow_card_sub_one_eq_one","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : ZMod p\nha : Ne a 0\n⊢ Eq (HPow.hPow a (HSub.hSub p 1)) 1","decl":"/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem pow_card_sub_one_eq_one {p : ℕ} [Fact p.Prime] {a : ZMod p} (ha : a ≠ 0) :\n    a ^ (p - 1) = 1 := by\n    have h := FiniteField.pow_card_sub_one_eq_one a ha\n    rwa [ZMod.card p] at h\n\n"}
{"name":"ZMod.pow_card_sub_one","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : ZMod p\n⊢ Eq (HPow.hPow a (HSub.hSub p 1)) (ite (Ne a 0) 1 0)","decl":"lemma pow_card_sub_one {p : ℕ} [Fact p.Prime] (a : ZMod p) :\n    a ^ (p - 1) = if a ≠ 0 then 1 else 0 := by\n  split_ifs with ha\n  · exact pow_card_sub_one_eq_one ha\n  · simp [of_not_not ha, (Fact.out : p.Prime).one_lt, tsub_eq_zero_iff_le]\n\n"}
{"name":"ZMod.orderOf_units_dvd_card_sub_one","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nu : Units (ZMod p)\n⊢ Dvd.dvd (orderOf u) (HSub.hSub p 1)","decl":"theorem orderOf_units_dvd_card_sub_one {p : ℕ} [Fact p.Prime] (u : (ZMod p)ˣ) : orderOf u ∣ p - 1 :=\n  orderOf_dvd_of_pow_eq_one <| units_pow_card_sub_one_eq_one _ _\n\n"}
{"name":"ZMod.orderOf_dvd_card_sub_one","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : ZMod p\nha : Ne a 0\n⊢ Dvd.dvd (orderOf a) (HSub.hSub p 1)","decl":"theorem orderOf_dvd_card_sub_one {p : ℕ} [Fact p.Prime] {a : ZMod p} (ha : a ≠ 0) :\n    orderOf a ∣ p - 1 :=\n  orderOf_dvd_of_pow_eq_one <| pow_card_sub_one_eq_one ha\n\n"}
{"name":"ZMod.expand_card","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\nf : Polynomial (ZMod p)\n⊢ Eq ((Polynomial.expand (ZMod p) p) f) (HPow.hPow f p)","decl":"theorem expand_card {p : ℕ} [Fact p.Prime] (f : Polynomial (ZMod p)) :\n    expand (ZMod p) p f = f ^ p := by have h := FiniteField.expand_card f; rwa [ZMod.card p] at h\n\n"}
{"name":"Int.ModEq.pow_card_sub_one_eq_one","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p : Nat\nhp : Nat.Prime p\nn : Int\nhpn : IsCoprime n ↑p\n⊢ (↑p).ModEq (HPow.hPow n (HSub.hSub p 1)) 1","decl":"/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem Int.ModEq.pow_card_sub_one_eq_one {p : ℕ} (hp : Nat.Prime p) {n : ℤ} (hpn : IsCoprime n p) :\n    n ^ (p - 1) ≡ 1 [ZMOD p] := by\n  haveI : Fact p.Prime := ⟨hp⟩\n  have : ¬(n : ZMod p) = 0 := by\n    rw [CharP.intCast_eq_zero_iff _ p, ← (Nat.prime_iff_prime_int.mp hp).coprime_iff_not_dvd]\n    · exact hpn.symm\n  simpa [← ZMod.intCast_eq_intCast_iff] using ZMod.pow_card_sub_one_eq_one this\n\n"}
{"name":"pow_pow_modEq_one","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"p m a : Nat\n⊢ (HPow.hPow p m).ModEq (HPow.hPow (HAdd.hAdd 1 (HMul.hMul p a)) (HPow.hPow p m)) 1","decl":"theorem pow_pow_modEq_one (p m a : ℕ) : (1 + p * a) ^ (p ^ m) ≡ 1 [MOD p ^ m] := by\n  induction' m with m hm\n  · exact Nat.modEq_one\n  · rw [Nat.ModEq.comm, add_comm, Nat.modEq_iff_dvd' (Nat.one_le_pow' _ _)] at hm\n    obtain ⟨d, hd⟩ := hm\n    rw [tsub_eq_iff_eq_add_of_le (Nat.one_le_pow' _ _), add_comm] at hd\n    rw [pow_succ, pow_mul, hd, add_pow, Finset.sum_range_succ', pow_zero, one_mul, one_pow,\n      one_mul, Nat.choose_zero_right, Nat.cast_one]\n    refine Nat.ModEq.add_right 1 (Nat.modEq_zero_iff_dvd.mpr ?_)\n    simp_rw [one_pow, mul_one, pow_succ', mul_assoc, ← Finset.mul_sum]\n    refine mul_dvd_mul_left (p ^ m) (dvd_mul_of_dvd_right (Finset.dvd_sum fun k hk ↦ ?_) d)\n    cases m\n    · rw [pow_zero, pow_one, one_mul, add_comm, add_left_inj] at hd\n      cases k <;> simp [← hd, mul_assoc, pow_succ']\n    · cases k <;> simp [mul_assoc, pow_succ']\n\n"}
{"name":"ZMod.eq_one_or_isUnit_sub_one","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"n p k : Nat\ninst✝ : Fact (Nat.Prime p)\nhn : Eq n (HPow.hPow p k)\na : ZMod n\nha : (orderOf a).Coprime n\n⊢ Or (Eq a 1) (IsUnit (HSub.hSub a 1))","decl":"theorem ZMod.eq_one_or_isUnit_sub_one {n p k : ℕ} [Fact p.Prime] (hn : n = p ^ k) (a : ZMod n)\n    (ha : (orderOf a).Coprime n) : a = 1 ∨ IsUnit (a - 1) := by\n  rcases eq_or_ne n 0 with rfl | hn0\n  · exact Or.inl (orderOf_eq_one_iff.mp ((orderOf a).coprime_zero_right.mp ha))\n  rcases eq_or_ne a 0 with rfl | ha0\n  · exact Or.inr (zero_sub (1 : ZMod n) ▸ isUnit_neg_one)\n  have : NeZero n := ⟨hn0⟩\n  obtain ⟨a, rfl⟩ := ZMod.natCast_zmod_surjective a\n  rw [← orderOf_eq_one_iff, or_iff_not_imp_right]\n  refine fun h ↦ ha.eq_one_of_dvd ?_\n  rw [orderOf_dvd_iff_pow_eq_one, ← Nat.cast_pow, ← Nat.cast_one, ZMod.eq_iff_modEq_nat, hn]\n  replace ha0 : 1 ≤ a := by\n    contrapose! ha0\n    rw [Nat.lt_one_iff.mp ha0, Nat.cast_zero]\n  rw [← Nat.cast_one, ← Nat.cast_sub ha0, ZMod.isUnit_iff_coprime, hn] at h\n  obtain ⟨b, hb⟩ := not_imp_comm.mp (Nat.Prime.coprime_pow_of_not_dvd Fact.out) h\n  rw [tsub_eq_iff_eq_add_of_le ha0, add_comm] at hb\n  exact hb ▸ pow_pow_modEq_one p k b\n\n"}
{"name":"FiniteField.isSquare_of_char_two","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"F : Type u_3\ninst✝¹ : Field F\ninst✝ : Finite F\nhF : Eq (ringChar F) 2\na : F\n⊢ IsSquare a","decl":"/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem isSquare_of_char_two (hF : ringChar F = 2) (a : F) : IsSquare a :=\n  haveI hF' : CharP F 2 := ringChar.of_eq hF\n  isSquare_of_charTwo' a\n\n"}
{"name":"FiniteField.exists_nonsquare","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"F : Type u_3\ninst✝¹ : Field F\ninst✝ : Finite F\nhF : Ne (ringChar F) 2\n⊢ Exists fun a => Not (IsSquare a)","decl":"/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem exists_nonsquare (hF : ringChar F ≠ 2) : ∃ a : F, ¬IsSquare a := by\n  -- Idea: the squaring map on `F` is not injective, hence not surjective\n  have h : ¬Function.Injective fun x : F ↦ x * x := fun h ↦\n    h.ne (Ring.neg_one_ne_one_of_char_ne_two hF) <| by simp\n  simpa [Finite.injective_iff_surjective, Function.Surjective, IsSquare, eq_comm] using h\n\n"}
{"name":"FiniteField.even_card_iff_char_two","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"F : Type u_3\ninst✝¹ : Field F\ninst✝ : Fintype F\n⊢ Iff (Eq (ringChar F) 2) (Eq (HMod.hMod (Fintype.card F) 2) 0)","decl":"/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem even_card_iff_char_two : ringChar F = 2 ↔ Fintype.card F % 2 = 0 := by\n  rcases FiniteField.card F (ringChar F) with ⟨n, hp, h⟩\n  rw [h, ← Nat.even_iff, Nat.even_pow, hp.even_iff]\n  simp\n\n"}
{"name":"FiniteField.even_card_of_char_two","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"F : Type u_3\ninst✝¹ : Field F\ninst✝ : Fintype F\nhF : Eq (ringChar F) 2\n⊢ Eq (HMod.hMod (Fintype.card F) 2) 0","decl":"theorem even_card_of_char_two (hF : ringChar F = 2) : Fintype.card F % 2 = 0 :=\n  even_card_iff_char_two.mp hF\n\n"}
{"name":"FiniteField.odd_card_of_char_ne_two","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"F : Type u_3\ninst✝¹ : Field F\ninst✝ : Fintype F\nhF : Ne (ringChar F) 2\n⊢ Eq (HMod.hMod (Fintype.card F) 2) 1","decl":"theorem odd_card_of_char_ne_two (hF : ringChar F ≠ 2) : Fintype.card F % 2 = 1 :=\n  Nat.mod_two_ne_zero.mp (mt even_card_iff_char_two.mpr hF)\n\n"}
{"name":"FiniteField.pow_dichotomy","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"F : Type u_3\ninst✝¹ : Field F\ninst✝ : Fintype F\nhF : Ne (ringChar F) 2\na : F\nha : Ne a 0\n⊢ Or (Eq (HPow.hPow a (HDiv.hDiv (Fintype.card F) 2)) 1) (Eq (HPow.hPow a (HDiv.hDiv (Fintype.card F) 2)) (-1))","decl":"/-- If `F` has odd characteristic, then for nonzero `a : F`, we have that `a ^ (#F / 2) = ±1`. -/\ntheorem pow_dichotomy (hF : ringChar F ≠ 2) {a : F} (ha : a ≠ 0) :\n    a ^ (Fintype.card F / 2) = 1 ∨ a ^ (Fintype.card F / 2) = -1 := by\n  have h₁ := FiniteField.pow_card_sub_one_eq_one a ha\n  rw [← Nat.two_mul_odd_div_two (FiniteField.odd_card_of_char_ne_two hF), mul_comm, pow_mul,\n    pow_two] at h₁\n  exact mul_self_eq_one_iff.mp h₁\n\n"}
{"name":"FiniteField.unit_isSquare_iff","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"F : Type u_3\ninst✝¹ : Field F\ninst✝ : Fintype F\nhF : Ne (ringChar F) 2\na : Units F\n⊢ Iff (IsSquare a) (Eq (HPow.hPow a (HDiv.hDiv (Fintype.card F) 2)) 1)","decl":"/-- A unit `a` of a finite field `F` of odd characteristic is a square\nif and only if `a ^ (#F / 2) = 1`. -/\ntheorem unit_isSquare_iff (hF : ringChar F ≠ 2) (a : Fˣ) :\n    IsSquare a ↔ a ^ (Fintype.card F / 2) = 1 := by\n  classical\n    obtain ⟨g, hg⟩ := IsCyclic.exists_generator (α := Fˣ)\n    obtain ⟨n, hn⟩ : a ∈ Submonoid.powers g := by rw [mem_powers_iff_mem_zpowers]; apply hg\n    have hodd := Nat.two_mul_odd_div_two (FiniteField.odd_card_of_char_ne_two hF)\n    constructor\n    · rintro ⟨y, rfl⟩\n      rw [← pow_two, ← pow_mul, hodd]\n      apply_fun Units.val using Units.ext\n      push_cast\n      exact FiniteField.pow_card_sub_one_eq_one (y : F) (Units.ne_zero y)\n    · subst a; intro h\n      rw [← Nat.card_eq_fintype_card] at hodd h\n      have key : 2 * (Nat.card F / 2) ∣ n * (Nat.card F / 2) := by\n        rw [← pow_mul] at h\n        rw [hodd, ← Nat.card_units, ← orderOf_eq_card_of_forall_mem_zpowers hg]\n        apply orderOf_dvd_of_pow_eq_one h\n      have : 0 < Nat.card F / 2 := Nat.div_pos Finite.one_lt_card (by norm_num)\n      obtain ⟨m, rfl⟩ := Nat.dvd_of_mul_dvd_mul_right this key\n      refine ⟨g ^ m, ?_⟩\n      dsimp\n      rw [mul_comm, pow_mul, pow_two]\n\n"}
{"name":"FiniteField.isSquare_iff","module":"Mathlib.FieldTheory.Finite.Basic","initialProofState":"F : Type u_3\ninst✝¹ : Field F\ninst✝ : Fintype F\nhF : Ne (ringChar F) 2\na : F\nha : Ne a 0\n⊢ Iff (IsSquare a) (Eq (HPow.hPow a (HDiv.hDiv (Fintype.card F) 2)) 1)","decl":"/-- A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`. -/\ntheorem isSquare_iff (hF : ringChar F ≠ 2) {a : F} (ha : a ≠ 0) :\n    IsSquare a ↔ a ^ (Fintype.card F / 2) = 1 := by\n  apply\n    (iff_congr _ (by simp [Units.ext_iff])).mp (FiniteField.unit_isSquare_iff hF (Units.mk0 a ha))\n  simp only [IsSquare, Units.ext_iff, Units.val_mk0, Units.val_mul]\n  constructor\n  · rintro ⟨y, hy⟩; exact ⟨y, hy⟩\n  · rintro ⟨y, rfl⟩\n    have hy : y ≠ 0 := by rintro rfl; simp at ha\n    refine ⟨Units.mk0 y hy, ?_⟩; simp\n\n"}
