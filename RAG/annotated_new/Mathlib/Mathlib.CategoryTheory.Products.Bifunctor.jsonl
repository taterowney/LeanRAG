{"name":"CategoryTheory.Bifunctor.map_id","module":"Mathlib.CategoryTheory.Products.Bifunctor","initialProofState":"C : Type u₁\nD : Type u₂\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor (Prod C D) E\nX : C\nY : D\n⊢ Eq (F.map { fst := CategoryTheory.CategoryStruct.id X, snd := CategoryTheory.CategoryStruct.id Y }) (CategoryTheory.CategoryStruct.id (F.obj { fst := X, snd := Y }))","decl":"@[simp]\ntheorem map_id (F : C × D ⥤ E) (X : C) (Y : D) :\n    F.map ((𝟙 X, 𝟙 Y) : (X, Y) ⟶ (X, Y)) = 𝟙 (F.obj (X, Y)) :=\n  F.map_id (X, Y)\n\n"}
{"name":"CategoryTheory.Bifunctor.map_id_comp","module":"Mathlib.CategoryTheory.Products.Bifunctor","initialProofState":"C : Type u₁\nD : Type u₂\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor (Prod C D) E\nW : C\nX Y Z : D\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (F.map { fst := CategoryTheory.CategoryStruct.id W, snd := CategoryTheory.CategoryStruct.comp f g }) (CategoryTheory.CategoryStruct.comp (F.map { fst := CategoryTheory.CategoryStruct.id W, snd := f }) (F.map { fst := CategoryTheory.CategoryStruct.id W, snd := g }))","decl":"@[simp]\ntheorem map_id_comp (F : C × D ⥤ E) (W : C) {X Y Z : D} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    F.map ((𝟙 W, f ≫ g) : (W, X) ⟶ (W, Z)) =\n      F.map ((𝟙 W, f) : (W, X) ⟶ (W, Y)) ≫ F.map ((𝟙 W, g) : (W, Y) ⟶ (W, Z)) := by\n  rw [← Functor.map_comp, prod_comp, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Bifunctor.map_comp_id","module":"Mathlib.CategoryTheory.Products.Bifunctor","initialProofState":"C : Type u₁\nD : Type u₂\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor (Prod C D) E\nX Y Z : C\nW : D\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (F.map { fst := CategoryTheory.CategoryStruct.comp f g, snd := CategoryTheory.CategoryStruct.id W }) (CategoryTheory.CategoryStruct.comp (F.map { fst := f, snd := CategoryTheory.CategoryStruct.id W }) (F.map { fst := g, snd := CategoryTheory.CategoryStruct.id W }))","decl":"@[simp]\ntheorem map_comp_id (F : C × D ⥤ E) (X Y Z : C) (W : D) (f : X ⟶ Y) (g : Y ⟶ Z) :\n    F.map ((f ≫ g, 𝟙 W) : (X, W) ⟶ (Z, W)) =\n      F.map ((f, 𝟙 W) : (X, W) ⟶ (Y, W)) ≫ F.map ((g, 𝟙 W) : (Y, W) ⟶ (Z, W)) := by\n  rw [← Functor.map_comp, prod_comp, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Bifunctor.diagonal","module":"Mathlib.CategoryTheory.Products.Bifunctor","initialProofState":"C : Type u₁\nD : Type u₂\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor (Prod C D) E\nX X' : C\nf : Quiver.Hom X X'\nY Y' : D\ng : Quiver.Hom Y Y'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map { fst := CategoryTheory.CategoryStruct.id X, snd := g }) (F.map { fst := f, snd := CategoryTheory.CategoryStruct.id Y' })) (F.map { fst := f, snd := g })","decl":"@[simp]\ntheorem diagonal (F : C × D ⥤ E) (X X' : C) (f : X ⟶ X') (Y Y' : D) (g : Y ⟶ Y') :\n    F.map ((𝟙 X, g) : (X, Y) ⟶ (X, Y')) ≫ F.map ((f, 𝟙 Y') : (X, Y') ⟶ (X', Y')) =\n      F.map ((f, g) : (X, Y) ⟶ (X', Y')) := by\n  rw [← Functor.map_comp, prod_comp, Category.id_comp, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Bifunctor.diagonal'","module":"Mathlib.CategoryTheory.Products.Bifunctor","initialProofState":"C : Type u₁\nD : Type u₂\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor (Prod C D) E\nX X' : C\nf : Quiver.Hom X X'\nY Y' : D\ng : Quiver.Hom Y Y'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map { fst := f, snd := CategoryTheory.CategoryStruct.id Y }) (F.map { fst := CategoryTheory.CategoryStruct.id X', snd := g })) (F.map { fst := f, snd := g })","decl":"@[simp]\ntheorem diagonal' (F : C × D ⥤ E) (X X' : C) (f : X ⟶ X') (Y Y' : D) (g : Y ⟶ Y') :\n    F.map ((f, 𝟙 Y) : (X, Y) ⟶ (X', Y)) ≫ F.map ((𝟙 X', g) : (X', Y) ⟶ (X', Y')) =\n      F.map ((f, g) : (X, Y) ⟶ (X', Y')) := by\n  rw [← Functor.map_comp, prod_comp, Category.id_comp, Category.comp_id]\n\n"}
