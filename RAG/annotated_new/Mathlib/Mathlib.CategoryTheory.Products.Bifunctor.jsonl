{"name":"CategoryTheory.Bifunctor.map_id","module":"Mathlib.CategoryTheory.Products.Bifunctor","initialProofState":"C : Type uâ‚\nD : Type uâ‚‚\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor (Prod C D) E\nX : C\nY : D\nâŠ¢ Eq (F.map { fst := CategoryTheory.CategoryStruct.id X, snd := CategoryTheory.CategoryStruct.id Y }) (CategoryTheory.CategoryStruct.id (F.obj { fst := X, snd := Y }))","decl":"@[simp]\ntheorem map_id (F : C Ã— D â¥¤ E) (X : C) (Y : D) :\n    F.map ((ğŸ™ X, ğŸ™ Y) : (X, Y) âŸ¶ (X, Y)) = ğŸ™ (F.obj (X, Y)) :=\n  F.map_id (X, Y)\n\n"}
{"name":"CategoryTheory.Bifunctor.map_id_comp","module":"Mathlib.CategoryTheory.Products.Bifunctor","initialProofState":"C : Type uâ‚\nD : Type uâ‚‚\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor (Prod C D) E\nW : C\nX Y Z : D\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (F.map { fst := CategoryTheory.CategoryStruct.id W, snd := CategoryTheory.CategoryStruct.comp f g }) (CategoryTheory.CategoryStruct.comp (F.map { fst := CategoryTheory.CategoryStruct.id W, snd := f }) (F.map { fst := CategoryTheory.CategoryStruct.id W, snd := g }))","decl":"@[simp]\ntheorem map_id_comp (F : C Ã— D â¥¤ E) (W : C) {X Y Z : D} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) :\n    F.map ((ğŸ™ W, f â‰« g) : (W, X) âŸ¶ (W, Z)) =\n      F.map ((ğŸ™ W, f) : (W, X) âŸ¶ (W, Y)) â‰« F.map ((ğŸ™ W, g) : (W, Y) âŸ¶ (W, Z)) := by\n  rw [â† Functor.map_comp, prod_comp, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Bifunctor.map_comp_id","module":"Mathlib.CategoryTheory.Products.Bifunctor","initialProofState":"C : Type uâ‚\nD : Type uâ‚‚\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor (Prod C D) E\nX Y Z : C\nW : D\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (F.map { fst := CategoryTheory.CategoryStruct.comp f g, snd := CategoryTheory.CategoryStruct.id W }) (CategoryTheory.CategoryStruct.comp (F.map { fst := f, snd := CategoryTheory.CategoryStruct.id W }) (F.map { fst := g, snd := CategoryTheory.CategoryStruct.id W }))","decl":"@[simp]\ntheorem map_comp_id (F : C Ã— D â¥¤ E) (X Y Z : C) (W : D) (f : X âŸ¶ Y) (g : Y âŸ¶ Z) :\n    F.map ((f â‰« g, ğŸ™ W) : (X, W) âŸ¶ (Z, W)) =\n      F.map ((f, ğŸ™ W) : (X, W) âŸ¶ (Y, W)) â‰« F.map ((g, ğŸ™ W) : (Y, W) âŸ¶ (Z, W)) := by\n  rw [â† Functor.map_comp, prod_comp, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Bifunctor.diagonal","module":"Mathlib.CategoryTheory.Products.Bifunctor","initialProofState":"C : Type uâ‚\nD : Type uâ‚‚\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor (Prod C D) E\nX X' : C\nf : Quiver.Hom X X'\nY Y' : D\ng : Quiver.Hom Y Y'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map { fst := CategoryTheory.CategoryStruct.id X, snd := g }) (F.map { fst := f, snd := CategoryTheory.CategoryStruct.id Y' })) (F.map { fst := f, snd := g })","decl":"@[simp]\ntheorem diagonal (F : C Ã— D â¥¤ E) (X X' : C) (f : X âŸ¶ X') (Y Y' : D) (g : Y âŸ¶ Y') :\n    F.map ((ğŸ™ X, g) : (X, Y) âŸ¶ (X, Y')) â‰« F.map ((f, ğŸ™ Y') : (X, Y') âŸ¶ (X', Y')) =\n      F.map ((f, g) : (X, Y) âŸ¶ (X', Y')) := by\n  rw [â† Functor.map_comp, prod_comp, Category.id_comp, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Bifunctor.diagonal'","module":"Mathlib.CategoryTheory.Products.Bifunctor","initialProofState":"C : Type uâ‚\nD : Type uâ‚‚\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor (Prod C D) E\nX X' : C\nf : Quiver.Hom X X'\nY Y' : D\ng : Quiver.Hom Y Y'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map { fst := f, snd := CategoryTheory.CategoryStruct.id Y }) (F.map { fst := CategoryTheory.CategoryStruct.id X', snd := g })) (F.map { fst := f, snd := g })","decl":"@[simp]\ntheorem diagonal' (F : C Ã— D â¥¤ E) (X X' : C) (f : X âŸ¶ X') (Y Y' : D) (g : Y âŸ¶ Y') :\n    F.map ((f, ğŸ™ Y) : (X, Y) âŸ¶ (X', Y)) â‰« F.map ((ğŸ™ X', g) : (X', Y) âŸ¶ (X', Y')) =\n      F.map ((f, g) : (X, Y) âŸ¶ (X', Y')) := by\n  rw [â† Functor.map_comp, prod_comp, Category.id_comp, Category.comp_id]\n\n"}
