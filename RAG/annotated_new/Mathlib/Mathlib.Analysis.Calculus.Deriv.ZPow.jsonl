{"name":"hasStrictDerivAt_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nm : Int\nx : 𝕜\nh : Or (Ne x 0) (LE.le 0 m)\n⊢ HasStrictDerivAt (fun x => HPow.hPow x m) (HMul.hMul (↑m) (HPow.hPow x (HSub.hSub m 1))) x","decl":"theorem hasStrictDerivAt_zpow (m : ℤ) (x : 𝕜) (h : x ≠ 0 ∨ 0 ≤ m) :\n    HasStrictDerivAt (fun x => x ^ m) ((m : 𝕜) * x ^ (m - 1)) x := by\n  have : ∀ m : ℤ, 0 < m → HasStrictDerivAt (· ^ m) ((m : 𝕜) * x ^ (m - 1)) x := fun m hm ↦ by\n    lift m to ℕ using hm.le\n    simp only [zpow_natCast, Int.cast_natCast]\n    convert hasStrictDerivAt_pow m x using 2\n    rw [← Int.ofNat_one, ← Int.ofNat_sub, zpow_natCast]\n    norm_cast at hm\n  rcases lt_trichotomy m 0 with (hm | hm | hm)\n  · have hx : x ≠ 0 := h.resolve_right hm.not_le\n    have := (hasStrictDerivAt_inv ?_).scomp _ (this (-m) (neg_pos.2 hm)) <;>\n      [skip; exact zpow_ne_zero _ hx]\n    simp only [Function.comp_def, zpow_neg, one_div, inv_inv, smul_eq_mul] at this\n    convert this using 1\n    rw [sq, mul_inv, inv_inv, Int.cast_neg, neg_mul, neg_mul_neg, ← zpow_add₀ hx, mul_assoc, ←\n      zpow_add₀ hx]\n    congr\n    abel\n  · simp only [hm, zpow_zero, Int.cast_zero, zero_mul, hasStrictDerivAt_const]\n  · exact this m hm\n\n"}
{"name":"hasDerivAt_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nm : Int\nx : 𝕜\nh : Or (Ne x 0) (LE.le 0 m)\n⊢ HasDerivAt (fun x => HPow.hPow x m) (HMul.hMul (↑m) (HPow.hPow x (HSub.hSub m 1))) x","decl":"theorem hasDerivAt_zpow (m : ℤ) (x : 𝕜) (h : x ≠ 0 ∨ 0 ≤ m) :\n    HasDerivAt (fun x => x ^ m) ((m : 𝕜) * x ^ (m - 1)) x :=\n  (hasStrictDerivAt_zpow m x h).hasDerivAt\n\n"}
{"name":"hasDerivWithinAt_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nm : Int\nx : 𝕜\nh : Or (Ne x 0) (LE.le 0 m)\ns : Set 𝕜\n⊢ HasDerivWithinAt (fun x => HPow.hPow x m) (HMul.hMul (↑m) (HPow.hPow x (HSub.hSub m 1))) s x","decl":"theorem hasDerivWithinAt_zpow (m : ℤ) (x : 𝕜) (h : x ≠ 0 ∨ 0 ≤ m) (s : Set 𝕜) :\n    HasDerivWithinAt (fun x => x ^ m) ((m : 𝕜) * x ^ (m - 1)) s x :=\n  (hasDerivAt_zpow m x h).hasDerivWithinAt\n\n"}
{"name":"differentiableAt_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\nm : Int\n⊢ Iff (DifferentiableAt 𝕜 (fun x => HPow.hPow x m) x) (Or (Ne x 0) (LE.le 0 m))","decl":"theorem differentiableAt_zpow : DifferentiableAt 𝕜 (fun x => x ^ m) x ↔ x ≠ 0 ∨ 0 ≤ m :=\n  ⟨fun H => NormedField.continuousAt_zpow.1 H.continuousAt, fun H =>\n    (hasDerivAt_zpow m x H).differentiableAt⟩\n\n"}
{"name":"differentiableWithinAt_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\ns : Set 𝕜\nm : Int\nx : 𝕜\nh : Or (Ne x 0) (LE.le 0 m)\n⊢ DifferentiableWithinAt 𝕜 (fun x => HPow.hPow x m) s x","decl":"theorem differentiableWithinAt_zpow (m : ℤ) (x : 𝕜) (h : x ≠ 0 ∨ 0 ≤ m) :\n    DifferentiableWithinAt 𝕜 (fun x => x ^ m) s x :=\n  (differentiableAt_zpow.mpr h).differentiableWithinAt\n\n"}
{"name":"differentiableOn_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nm : Int\ns : Set 𝕜\nh : Or (Not (Membership.mem s 0)) (LE.le 0 m)\n⊢ DifferentiableOn 𝕜 (fun x => HPow.hPow x m) s","decl":"theorem differentiableOn_zpow (m : ℤ) (s : Set 𝕜) (h : (0 : 𝕜) ∉ s ∨ 0 ≤ m) :\n    DifferentiableOn 𝕜 (fun x => x ^ m) s := fun x hxs =>\n  differentiableWithinAt_zpow m x <| h.imp_left <| ne_of_mem_of_not_mem hxs\n\n"}
{"name":"deriv_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nm : Int\nx : 𝕜\n⊢ Eq (deriv (fun x => HPow.hPow x m) x) (HMul.hMul (↑m) (HPow.hPow x (HSub.hSub m 1)))","decl":"theorem deriv_zpow (m : ℤ) (x : 𝕜) : deriv (fun x => x ^ m) x = m * x ^ (m - 1) := by\n  by_cases H : x ≠ 0 ∨ 0 ≤ m\n  · exact (hasDerivAt_zpow m x H).deriv\n  · rw [deriv_zero_of_not_differentiableAt (mt differentiableAt_zpow.1 H)]\n    push_neg at H\n    rcases H with ⟨rfl, hm⟩\n    rw [zero_zpow _ ((sub_one_lt _).trans hm).ne, mul_zero]\n\n"}
{"name":"deriv_zpow'","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nm : Int\n⊢ Eq (deriv fun x => HPow.hPow x m) fun x => HMul.hMul (↑m) (HPow.hPow x (HSub.hSub m 1))","decl":"@[simp]\ntheorem deriv_zpow' (m : ℤ) : (deriv fun x : 𝕜 => x ^ m) = fun x => (m : 𝕜) * x ^ (m - 1) :=\n  funext <| deriv_zpow m\n\n"}
{"name":"derivWithin_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nm : Int\nhxs : UniqueDiffWithinAt 𝕜 s x\nh : Or (Ne x 0) (LE.le 0 m)\n⊢ Eq (derivWithin (fun x => HPow.hPow x m) s x) (HMul.hMul (↑m) (HPow.hPow x (HSub.hSub m 1)))","decl":"theorem derivWithin_zpow (hxs : UniqueDiffWithinAt 𝕜 s x) (h : x ≠ 0 ∨ 0 ≤ m) :\n    derivWithin (fun x => x ^ m) s x = (m : 𝕜) * x ^ (m - 1) :=\n  (hasDerivWithinAt_zpow m x h s).derivWithin hxs\n\n"}
{"name":"iter_deriv_zpow'","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nm : Int\nk : Nat\n⊢ Eq (Nat.iterate deriv k fun x => HPow.hPow x m) fun x => HMul.hMul ((Finset.range k).prod fun i => HSub.hSub ↑m ↑i) (HPow.hPow x (HSub.hSub m ↑k))","decl":"@[simp]\ntheorem iter_deriv_zpow' (m : ℤ) (k : ℕ) :\n    (deriv^[k] fun x : 𝕜 => x ^ m) =\n      fun x => (∏ i ∈ Finset.range k, ((m : 𝕜) - i)) * x ^ (m - k) := by\n  induction' k with k ihk\n  · simp only [one_mul, Int.ofNat_zero, id, sub_zero, Finset.prod_range_zero,\n      Function.iterate_zero]\n  · simp only [Function.iterate_succ_apply', ihk, deriv_const_mul_field', deriv_zpow',\n      Finset.prod_range_succ, Int.ofNat_succ, ← sub_sub, Int.cast_sub, Int.cast_natCast, mul_assoc]\n\n"}
{"name":"iter_deriv_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nm : Int\nx : 𝕜\nk : Nat\n⊢ Eq (Nat.iterate deriv k (fun y => HPow.hPow y m) x) (HMul.hMul ((Finset.range k).prod fun i => HSub.hSub ↑m ↑i) (HPow.hPow x (HSub.hSub m ↑k)))","decl":"theorem iter_deriv_zpow (m : ℤ) (x : 𝕜) (k : ℕ) :\n    deriv^[k] (fun y => y ^ m) x = (∏ i ∈ Finset.range k, ((m : 𝕜) - i)) * x ^ (m - k) :=\n  congr_fun (iter_deriv_zpow' m k) x\n\n"}
{"name":"iter_deriv_pow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nn : Nat\nx : 𝕜\nk : Nat\n⊢ Eq (Nat.iterate deriv k (fun x => HPow.hPow x n) x) (HMul.hMul ((Finset.range k).prod fun i => HSub.hSub ↑n ↑i) (HPow.hPow x (HSub.hSub n k)))","decl":"theorem iter_deriv_pow (n : ℕ) (x : 𝕜) (k : ℕ) :\n    deriv^[k] (fun x : 𝕜 => x ^ n) x = (∏ i ∈ Finset.range k, ((n : 𝕜) - i)) * x ^ (n - k) := by\n  simp only [← zpow_natCast, iter_deriv_zpow, Int.cast_natCast]\n  rcases le_or_lt k n with hkn | hnk\n  · rw [Int.ofNat_sub hkn]\n  · have : (∏ i ∈ Finset.range k, (n - i : 𝕜)) = 0 :=\n      Finset.prod_eq_zero (Finset.mem_range.2 hnk) (sub_self _)\n    simp only [this, zero_mul]\n\n"}
{"name":"iter_deriv_pow'","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nn k : Nat\n⊢ Eq (Nat.iterate deriv k fun x => HPow.hPow x n) fun x => HMul.hMul ((Finset.range k).prod fun i => HSub.hSub ↑n ↑i) (HPow.hPow x (HSub.hSub n k))","decl":"@[simp]\ntheorem iter_deriv_pow' (n k : ℕ) :\n    (deriv^[k] fun x : 𝕜 => x ^ n) =\n      fun x => (∏ i ∈ Finset.range k, ((n : 𝕜) - i)) * x ^ (n - k) :=\n  funext fun x => iter_deriv_pow n x k\n\n"}
{"name":"iter_deriv_inv","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nk : Nat\nx : 𝕜\n⊢ Eq (Nat.iterate deriv k Inv.inv x) (HMul.hMul ((Finset.range k).prod fun i => HSub.hSub (-1) ↑i) (HPow.hPow x (HSub.hSub (-1) ↑k)))","decl":"theorem iter_deriv_inv (k : ℕ) (x : 𝕜) :\n    deriv^[k] Inv.inv x = (∏ i ∈ Finset.range k, (-1 - i : 𝕜)) * x ^ (-1 - k : ℤ) := by\n  simpa only [zpow_neg_one, Int.cast_neg, Int.cast_one] using iter_deriv_zpow (-1) x k\n\n"}
{"name":"iter_deriv_inv'","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nk : Nat\n⊢ Eq (Nat.iterate deriv k Inv.inv) fun x => HMul.hMul ((Finset.range k).prod fun i => HSub.hSub (-1) ↑i) (HPow.hPow x (HSub.hSub (-1) ↑k))","decl":"@[simp]\ntheorem iter_deriv_inv' (k : ℕ) :\n    deriv^[k] Inv.inv = fun x : 𝕜 => (∏ i ∈ Finset.range k, (-1 - i : 𝕜)) * x ^ (-1 - k : ℤ) :=\n  funext (iter_deriv_inv k)\n\n"}
{"name":"DifferentiableWithinAt.zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nE : Type v\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nm : Int\nf : E → 𝕜\nt : Set E\na : E\nhf : DifferentiableWithinAt 𝕜 f t a\nh : Or (Ne (f a) 0) (LE.le 0 m)\n⊢ DifferentiableWithinAt 𝕜 (fun x => HPow.hPow (f x) m) t a","decl":"theorem DifferentiableWithinAt.zpow (hf : DifferentiableWithinAt 𝕜 f t a) (h : f a ≠ 0 ∨ 0 ≤ m) :\n    DifferentiableWithinAt 𝕜 (fun x => f x ^ m) t a :=\n  (differentiableAt_zpow.2 h).comp_differentiableWithinAt a hf\n\n"}
{"name":"DifferentiableAt.zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nE : Type v\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nm : Int\nf : E → 𝕜\na : E\nhf : DifferentiableAt 𝕜 f a\nh : Or (Ne (f a) 0) (LE.le 0 m)\n⊢ DifferentiableAt 𝕜 (fun x => HPow.hPow (f x) m) a","decl":"theorem DifferentiableAt.zpow (hf : DifferentiableAt 𝕜 f a) (h : f a ≠ 0 ∨ 0 ≤ m) :\n    DifferentiableAt 𝕜 (fun x => f x ^ m) a :=\n  (differentiableAt_zpow.2 h).comp a hf\n\n"}
{"name":"DifferentiableOn.zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nE : Type v\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nm : Int\nf : E → 𝕜\nt : Set E\nhf : DifferentiableOn 𝕜 f t\nh : Or (∀ (x : E), Membership.mem t x → Ne (f x) 0) (LE.le 0 m)\n⊢ DifferentiableOn 𝕜 (fun x => HPow.hPow (f x) m) t","decl":"theorem DifferentiableOn.zpow (hf : DifferentiableOn 𝕜 f t) (h : (∀ x ∈ t, f x ≠ 0) ∨ 0 ≤ m) :\n    DifferentiableOn 𝕜 (fun x => f x ^ m) t := fun x hx =>\n  (hf x hx).zpow <| h.imp_left fun h => h x hx\n\n"}
{"name":"Differentiable.zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nE : Type v\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nm : Int\nf : E → 𝕜\nhf : Differentiable 𝕜 f\nh : Or (∀ (x : E), Ne (f x) 0) (LE.le 0 m)\n⊢ Differentiable 𝕜 fun x => HPow.hPow (f x) m","decl":"theorem Differentiable.zpow (hf : Differentiable 𝕜 f) (h : (∀ x, f x ≠ 0) ∨ 0 ≤ m) :\n    Differentiable 𝕜 fun x => f x ^ m := fun x => (hf x).zpow <| h.imp_left fun h => h x\n"}
