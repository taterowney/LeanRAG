{"name":"hasStrictDerivAt_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nm : Int\nx : ğ•œ\nh : Or (Ne x 0) (LE.le 0 m)\nâŠ¢ HasStrictDerivAt (fun x => HPow.hPow x m) (HMul.hMul (â†‘m) (HPow.hPow x (HSub.hSub m 1))) x","decl":"theorem hasStrictDerivAt_zpow (m : â„¤) (x : ğ•œ) (h : x â‰  0 âˆ¨ 0 â‰¤ m) :\n    HasStrictDerivAt (fun x => x ^ m) ((m : ğ•œ) * x ^ (m - 1)) x := by\n  have : âˆ€ m : â„¤, 0 < m â†’ HasStrictDerivAt (Â· ^ m) ((m : ğ•œ) * x ^ (m - 1)) x := fun m hm â†¦ by\n    lift m to â„• using hm.le\n    simp only [zpow_natCast, Int.cast_natCast]\n    convert hasStrictDerivAt_pow m x using 2\n    rw [â† Int.ofNat_one, â† Int.ofNat_sub, zpow_natCast]\n    norm_cast at hm\n  rcases lt_trichotomy m 0 with (hm | hm | hm)\n  Â· have hx : x â‰  0 := h.resolve_right hm.not_le\n    have := (hasStrictDerivAt_inv ?_).scomp _ (this (-m) (neg_pos.2 hm)) <;>\n      [skip; exact zpow_ne_zero _ hx]\n    simp only [Function.comp_def, zpow_neg, one_div, inv_inv, smul_eq_mul] at this\n    convert this using 1\n    rw [sq, mul_inv, inv_inv, Int.cast_neg, neg_mul, neg_mul_neg, â† zpow_addâ‚€ hx, mul_assoc, â†\n      zpow_addâ‚€ hx]\n    congr\n    abel\n  Â· simp only [hm, zpow_zero, Int.cast_zero, zero_mul, hasStrictDerivAt_const]\n  Â· exact this m hm\n\n"}
{"name":"hasDerivAt_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nm : Int\nx : ğ•œ\nh : Or (Ne x 0) (LE.le 0 m)\nâŠ¢ HasDerivAt (fun x => HPow.hPow x m) (HMul.hMul (â†‘m) (HPow.hPow x (HSub.hSub m 1))) x","decl":"theorem hasDerivAt_zpow (m : â„¤) (x : ğ•œ) (h : x â‰  0 âˆ¨ 0 â‰¤ m) :\n    HasDerivAt (fun x => x ^ m) ((m : ğ•œ) * x ^ (m - 1)) x :=\n  (hasStrictDerivAt_zpow m x h).hasDerivAt\n\n"}
{"name":"hasDerivWithinAt_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nm : Int\nx : ğ•œ\nh : Or (Ne x 0) (LE.le 0 m)\ns : Set ğ•œ\nâŠ¢ HasDerivWithinAt (fun x => HPow.hPow x m) (HMul.hMul (â†‘m) (HPow.hPow x (HSub.hSub m 1))) s x","decl":"theorem hasDerivWithinAt_zpow (m : â„¤) (x : ğ•œ) (h : x â‰  0 âˆ¨ 0 â‰¤ m) (s : Set ğ•œ) :\n    HasDerivWithinAt (fun x => x ^ m) ((m : ğ•œ) * x ^ (m - 1)) s x :=\n  (hasDerivAt_zpow m x h).hasDerivWithinAt\n\n"}
{"name":"differentiableAt_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nm : Int\nâŠ¢ Iff (DifferentiableAt ğ•œ (fun x => HPow.hPow x m) x) (Or (Ne x 0) (LE.le 0 m))","decl":"theorem differentiableAt_zpow : DifferentiableAt ğ•œ (fun x => x ^ m) x â†” x â‰  0 âˆ¨ 0 â‰¤ m :=\n  âŸ¨fun H => NormedField.continuousAt_zpow.1 H.continuousAt, fun H =>\n    (hasDerivAt_zpow m x H).differentiableAtâŸ©\n\n"}
{"name":"differentiableWithinAt_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\ns : Set ğ•œ\nm : Int\nx : ğ•œ\nh : Or (Ne x 0) (LE.le 0 m)\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => HPow.hPow x m) s x","decl":"theorem differentiableWithinAt_zpow (m : â„¤) (x : ğ•œ) (h : x â‰  0 âˆ¨ 0 â‰¤ m) :\n    DifferentiableWithinAt ğ•œ (fun x => x ^ m) s x :=\n  (differentiableAt_zpow.mpr h).differentiableWithinAt\n\n"}
{"name":"differentiableOn_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nm : Int\ns : Set ğ•œ\nh : Or (Not (Membership.mem s 0)) (LE.le 0 m)\nâŠ¢ DifferentiableOn ğ•œ (fun x => HPow.hPow x m) s","decl":"theorem differentiableOn_zpow (m : â„¤) (s : Set ğ•œ) (h : (0 : ğ•œ) âˆ‰ s âˆ¨ 0 â‰¤ m) :\n    DifferentiableOn ğ•œ (fun x => x ^ m) s := fun x hxs =>\n  differentiableWithinAt_zpow m x <| h.imp_left <| ne_of_mem_of_not_mem hxs\n\n"}
{"name":"deriv_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nm : Int\nx : ğ•œ\nâŠ¢ Eq (deriv (fun x => HPow.hPow x m) x) (HMul.hMul (â†‘m) (HPow.hPow x (HSub.hSub m 1)))","decl":"theorem deriv_zpow (m : â„¤) (x : ğ•œ) : deriv (fun x => x ^ m) x = m * x ^ (m - 1) := by\n  by_cases H : x â‰  0 âˆ¨ 0 â‰¤ m\n  Â· exact (hasDerivAt_zpow m x H).deriv\n  Â· rw [deriv_zero_of_not_differentiableAt (mt differentiableAt_zpow.1 H)]\n    push_neg at H\n    rcases H with âŸ¨rfl, hmâŸ©\n    rw [zero_zpow _ ((sub_one_lt _).trans hm).ne, mul_zero]\n\n"}
{"name":"deriv_zpow'","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nm : Int\nâŠ¢ Eq (deriv fun x => HPow.hPow x m) fun x => HMul.hMul (â†‘m) (HPow.hPow x (HSub.hSub m 1))","decl":"@[simp]\ntheorem deriv_zpow' (m : â„¤) : (deriv fun x : ğ•œ => x ^ m) = fun x => (m : ğ•œ) * x ^ (m - 1) :=\n  funext <| deriv_zpow m\n\n"}
{"name":"derivWithin_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\ns : Set ğ•œ\nm : Int\nhxs : UniqueDiffWithinAt ğ•œ s x\nh : Or (Ne x 0) (LE.le 0 m)\nâŠ¢ Eq (derivWithin (fun x => HPow.hPow x m) s x) (HMul.hMul (â†‘m) (HPow.hPow x (HSub.hSub m 1)))","decl":"theorem derivWithin_zpow (hxs : UniqueDiffWithinAt ğ•œ s x) (h : x â‰  0 âˆ¨ 0 â‰¤ m) :\n    derivWithin (fun x => x ^ m) s x = (m : ğ•œ) * x ^ (m - 1) :=\n  (hasDerivWithinAt_zpow m x h s).derivWithin hxs\n\n"}
{"name":"iter_deriv_zpow'","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nm : Int\nk : Nat\nâŠ¢ Eq (Nat.iterate deriv k fun x => HPow.hPow x m) fun x => HMul.hMul ((Finset.range k).prod fun i => HSub.hSub â†‘m â†‘i) (HPow.hPow x (HSub.hSub m â†‘k))","decl":"@[simp]\ntheorem iter_deriv_zpow' (m : â„¤) (k : â„•) :\n    (deriv^[k] fun x : ğ•œ => x ^ m) =\n      fun x => (âˆ i âˆˆ Finset.range k, ((m : ğ•œ) - i)) * x ^ (m - k) := by\n  induction' k with k ihk\n  Â· simp only [one_mul, Int.ofNat_zero, id, sub_zero, Finset.prod_range_zero,\n      Function.iterate_zero]\n  Â· simp only [Function.iterate_succ_apply', ihk, deriv_const_mul_field', deriv_zpow',\n      Finset.prod_range_succ, Int.ofNat_succ, â† sub_sub, Int.cast_sub, Int.cast_natCast, mul_assoc]\n\n"}
{"name":"iter_deriv_zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nm : Int\nx : ğ•œ\nk : Nat\nâŠ¢ Eq (Nat.iterate deriv k (fun y => HPow.hPow y m) x) (HMul.hMul ((Finset.range k).prod fun i => HSub.hSub â†‘m â†‘i) (HPow.hPow x (HSub.hSub m â†‘k)))","decl":"theorem iter_deriv_zpow (m : â„¤) (x : ğ•œ) (k : â„•) :\n    deriv^[k] (fun y => y ^ m) x = (âˆ i âˆˆ Finset.range k, ((m : ğ•œ) - i)) * x ^ (m - k) :=\n  congr_fun (iter_deriv_zpow' m k) x\n\n"}
{"name":"iter_deriv_pow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nn : Nat\nx : ğ•œ\nk : Nat\nâŠ¢ Eq (Nat.iterate deriv k (fun x => HPow.hPow x n) x) (HMul.hMul ((Finset.range k).prod fun i => HSub.hSub â†‘n â†‘i) (HPow.hPow x (HSub.hSub n k)))","decl":"theorem iter_deriv_pow (n : â„•) (x : ğ•œ) (k : â„•) :\n    deriv^[k] (fun x : ğ•œ => x ^ n) x = (âˆ i âˆˆ Finset.range k, ((n : ğ•œ) - i)) * x ^ (n - k) := by\n  simp only [â† zpow_natCast, iter_deriv_zpow, Int.cast_natCast]\n  rcases le_or_lt k n with hkn | hnk\n  Â· rw [Int.ofNat_sub hkn]\n  Â· have : (âˆ i âˆˆ Finset.range k, (n - i : ğ•œ)) = 0 :=\n      Finset.prod_eq_zero (Finset.mem_range.2 hnk) (sub_self _)\n    simp only [this, zero_mul]\n\n"}
{"name":"iter_deriv_pow'","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nn k : Nat\nâŠ¢ Eq (Nat.iterate deriv k fun x => HPow.hPow x n) fun x => HMul.hMul ((Finset.range k).prod fun i => HSub.hSub â†‘n â†‘i) (HPow.hPow x (HSub.hSub n k))","decl":"@[simp]\ntheorem iter_deriv_pow' (n k : â„•) :\n    (deriv^[k] fun x : ğ•œ => x ^ n) =\n      fun x => (âˆ i âˆˆ Finset.range k, ((n : ğ•œ) - i)) * x ^ (n - k) :=\n  funext fun x => iter_deriv_pow n x k\n\n"}
{"name":"iter_deriv_inv","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nk : Nat\nx : ğ•œ\nâŠ¢ Eq (Nat.iterate deriv k Inv.inv x) (HMul.hMul ((Finset.range k).prod fun i => HSub.hSub (-1) â†‘i) (HPow.hPow x (HSub.hSub (-1) â†‘k)))","decl":"theorem iter_deriv_inv (k : â„•) (x : ğ•œ) :\n    deriv^[k] Inv.inv x = (âˆ i âˆˆ Finset.range k, (-1 - i : ğ•œ)) * x ^ (-1 - k : â„¤) := by\n  simpa only [zpow_neg_one, Int.cast_neg, Int.cast_one] using iter_deriv_zpow (-1) x k\n\n"}
{"name":"iter_deriv_inv'","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœ : NontriviallyNormedField ğ•œ\nk : Nat\nâŠ¢ Eq (Nat.iterate deriv k Inv.inv) fun x => HMul.hMul ((Finset.range k).prod fun i => HSub.hSub (-1) â†‘i) (HPow.hPow x (HSub.hSub (-1) â†‘k))","decl":"@[simp]\ntheorem iter_deriv_inv' (k : â„•) :\n    deriv^[k] Inv.inv = fun x : ğ•œ => (âˆ i âˆˆ Finset.range k, (-1 - i : ğ•œ)) * x ^ (-1 - k : â„¤) :=\n  funext (iter_deriv_inv k)\n\n"}
{"name":"DifferentiableWithinAt.zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nm : Int\nf : E â†’ ğ•œ\nt : Set E\na : E\nhf : DifferentiableWithinAt ğ•œ f t a\nh : Or (Ne (f a) 0) (LE.le 0 m)\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => HPow.hPow (f x) m) t a","decl":"theorem DifferentiableWithinAt.zpow (hf : DifferentiableWithinAt ğ•œ f t a) (h : f a â‰  0 âˆ¨ 0 â‰¤ m) :\n    DifferentiableWithinAt ğ•œ (fun x => f x ^ m) t a :=\n  (differentiableAt_zpow.2 h).comp_differentiableWithinAt a hf\n\n"}
{"name":"DifferentiableAt.zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nm : Int\nf : E â†’ ğ•œ\na : E\nhf : DifferentiableAt ğ•œ f a\nh : Or (Ne (f a) 0) (LE.le 0 m)\nâŠ¢ DifferentiableAt ğ•œ (fun x => HPow.hPow (f x) m) a","decl":"theorem DifferentiableAt.zpow (hf : DifferentiableAt ğ•œ f a) (h : f a â‰  0 âˆ¨ 0 â‰¤ m) :\n    DifferentiableAt ğ•œ (fun x => f x ^ m) a :=\n  (differentiableAt_zpow.2 h).comp a hf\n\n"}
{"name":"DifferentiableOn.zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nm : Int\nf : E â†’ ğ•œ\nt : Set E\nhf : DifferentiableOn ğ•œ f t\nh : Or (âˆ€ (x : E), Membership.mem t x â†’ Ne (f x) 0) (LE.le 0 m)\nâŠ¢ DifferentiableOn ğ•œ (fun x => HPow.hPow (f x) m) t","decl":"theorem DifferentiableOn.zpow (hf : DifferentiableOn ğ•œ f t) (h : (âˆ€ x âˆˆ t, f x â‰  0) âˆ¨ 0 â‰¤ m) :\n    DifferentiableOn ğ•œ (fun x => f x ^ m) t := fun x hx =>\n  (hf x hx).zpow <| h.imp_left fun h => h x hx\n\n"}
{"name":"Differentiable.zpow","module":"Mathlib.Analysis.Calculus.Deriv.ZPow","initialProofState":"ğ•œ : Type u\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nm : Int\nf : E â†’ ğ•œ\nhf : Differentiable ğ•œ f\nh : Or (âˆ€ (x : E), Ne (f x) 0) (LE.le 0 m)\nâŠ¢ Differentiable ğ•œ fun x => HPow.hPow (f x) m","decl":"theorem Differentiable.zpow (hf : Differentiable ğ•œ f) (h : (âˆ€ x, f x â‰  0) âˆ¨ 0 â‰¤ m) :\n    Differentiable ğ•œ fun x => f x ^ m := fun x => (hf x).zpow <| h.imp_left fun h => h x\n"}
