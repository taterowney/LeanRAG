{"name":"Nonempty.forall","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\np : Nonempty α → Prop\n⊢ Iff (∀ (h : Nonempty α), p h) (∀ (a : α), p ⋯)","decl":"@[simp]\ntheorem Nonempty.forall {α} {p : Nonempty α → Prop} : (∀ h : Nonempty α, p h) ↔ ∀ a, p ⟨a⟩ :=\n  Iff.intro (fun h _ ↦ h _) fun h ⟨a⟩ ↦ h a\n\n"}
{"name":"Nonempty.exists","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\np : Nonempty α → Prop\n⊢ Iff (Exists fun h => p h) (Exists fun a => p ⋯)","decl":"@[simp]\ntheorem Nonempty.exists {α} {p : Nonempty α → Prop} : (∃ h : Nonempty α, p h) ↔ ∃ a, p ⟨a⟩ :=\n  Iff.intro (fun ⟨⟨a⟩, h⟩ ↦ ⟨a, h⟩) fun ⟨a, h⟩ ↦ ⟨⟨a⟩, h⟩\n\n"}
{"name":"exists_true_iff_nonempty","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\n⊢ Iff (Exists fun x => True) (Nonempty α)","decl":"theorem exists_true_iff_nonempty {α : Sort*} : (∃ _ : α, True) ↔ Nonempty α :=\n  Iff.intro (fun ⟨a, _⟩ ↦ ⟨a⟩) fun ⟨a⟩ ↦ ⟨a, trivial⟩\n\n"}
{"name":"nonempty_Prop","module":"Mathlib.Logic.Nonempty","initialProofState":"p : Prop\n⊢ Iff (Nonempty p) p","decl":"@[deprecated (since := \"2024-08-30\")] alias nonempty_Prop := nonempty_prop\n\n"}
{"name":"Nonempty.imp","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\np : Prop\n⊢ Iff (Nonempty α → p) (α → p)","decl":"theorem Nonempty.imp {α} {p : Prop} : (Nonempty α → p) ↔ (α → p) :=\n  Nonempty.forall\n\n"}
{"name":"not_nonempty_iff_imp_false","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\n⊢ Iff (Not (Nonempty α)) (α → False)","decl":"theorem not_nonempty_iff_imp_false {α : Sort*} : ¬Nonempty α ↔ α → False :=\n  Nonempty.imp\n\n"}
{"name":"nonempty_psigma","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_4\nβ : α → Sort u_3\n⊢ Iff (Nonempty (PSigma β)) (Exists fun a => Nonempty (β a))","decl":"@[simp]\ntheorem nonempty_psigma {α} {β : α → Sort*} : Nonempty (PSigma β) ↔ ∃ a : α, Nonempty (β a) :=\n  Iff.intro (fun ⟨⟨a, c⟩⟩ ↦ ⟨a, ⟨c⟩⟩) fun ⟨a, ⟨c⟩⟩ ↦ ⟨⟨a, c⟩⟩\n\n"}
{"name":"nonempty_subtype","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\np : α → Prop\n⊢ Iff (Nonempty (Subtype p)) (Exists fun a => p a)","decl":"@[simp]\ntheorem nonempty_subtype {α} {p : α → Prop} : Nonempty (Subtype p) ↔ ∃ a : α, p a :=\n  Iff.intro (fun ⟨⟨a, h⟩⟩ ↦ ⟨a, h⟩) fun ⟨a, h⟩ ↦ ⟨⟨a, h⟩⟩\n\n"}
{"name":"nonempty_pprod","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\nβ : Sort u_4\n⊢ Iff (Nonempty (PProd α β)) (And (Nonempty α) (Nonempty β))","decl":"@[simp]\ntheorem nonempty_pprod {α β} : Nonempty (PProd α β) ↔ Nonempty α ∧ Nonempty β :=\n  Iff.intro (fun ⟨⟨a, b⟩⟩ ↦ ⟨⟨a⟩, ⟨b⟩⟩) fun ⟨⟨a⟩, ⟨b⟩⟩ ↦ ⟨⟨a, b⟩⟩\n\n"}
{"name":"nonempty_psum","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\nβ : Sort u_4\n⊢ Iff (Nonempty (PSum α β)) (Or (Nonempty α) (Nonempty β))","decl":"@[simp]\ntheorem nonempty_psum {α β} : Nonempty (α ⊕' β) ↔ Nonempty α ∨ Nonempty β :=\n  Iff.intro\n    (fun ⟨h⟩ ↦\n      match h with\n      | PSum.inl a => Or.inl ⟨a⟩\n      | PSum.inr b => Or.inr ⟨b⟩)\n    fun h ↦\n    match h with\n    | Or.inl ⟨a⟩ => ⟨PSum.inl a⟩\n    | Or.inr ⟨b⟩ => ⟨PSum.inr b⟩\n\n"}
{"name":"nonempty_plift","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\n⊢ Iff (Nonempty (PLift α)) (Nonempty α)","decl":"@[simp]\ntheorem nonempty_plift {α} : Nonempty (PLift α) ↔ Nonempty α :=\n  Iff.intro (fun ⟨⟨a⟩⟩ ↦ ⟨a⟩) fun ⟨a⟩ ↦ ⟨⟨a⟩⟩\n\n"}
{"name":"Nonempty.map","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\nβ : Sort u_4\nf : α → β\na✝ : Nonempty α\n⊢ Nonempty β","decl":"/-- Given `f : α → β`, if `α` is nonempty then `β` is also nonempty.\n  `Nonempty` cannot be a `functor`, because `Functor` is restricted to `Type`. -/\ntheorem Nonempty.map {α β} (f : α → β) : Nonempty α → Nonempty β\n  | ⟨h⟩ => ⟨f h⟩\n\n"}
{"name":"Nonempty.map2","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\nβ : Sort u_4\nγ : Sort u_5\nf : α → β → γ\na✝¹ : Nonempty α\na✝ : Nonempty β\n⊢ Nonempty γ","decl":"protected theorem Nonempty.map2 {α β γ : Sort*} (f : α → β → γ) :\n    Nonempty α → Nonempty β → Nonempty γ\n  | ⟨x⟩, ⟨y⟩ => ⟨f x y⟩\n\n"}
{"name":"Nonempty.congr","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\nβ : Sort u_4\nf : α → β\ng : β → α\n⊢ Iff (Nonempty α) (Nonempty β)","decl":"protected theorem Nonempty.congr {α β} (f : α → β) (g : β → α) : Nonempty α ↔ Nonempty β :=\n  ⟨Nonempty.map f, Nonempty.map g⟩\n\n"}
{"name":"Nonempty.elim_to_inhabited","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\nh : Nonempty α\np : Prop\nf : Inhabited α → p\n⊢ p","decl":"theorem Nonempty.elim_to_inhabited {α : Sort*} [h : Nonempty α] {p : Prop} (f : Inhabited α → p) :\n    p :=\n  h.elim <| f ∘ Inhabited.mk\n\n"}
{"name":"Classical.nonempty_pi","module":"Mathlib.Logic.Nonempty","initialProofState":"ι : Sort u_4\nα : ι → Sort u_3\n⊢ Iff (Nonempty ((i : ι) → α i)) (∀ (i : ι), Nonempty (α i))","decl":"theorem Classical.nonempty_pi {ι} {α : ι → Sort*} : Nonempty (∀ i, α i) ↔ ∀ i, Nonempty (α i) :=\n  ⟨fun ⟨f⟩ a ↦ ⟨f a⟩, @Pi.instNonempty _ _⟩\n\n"}
{"name":"subsingleton_of_not_nonempty","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_3\nh : Not (Nonempty α)\n⊢ Subsingleton α","decl":"theorem subsingleton_of_not_nonempty {α : Sort*} (h : ¬Nonempty α) : Subsingleton α :=\n  ⟨fun x ↦ False.elim <| not_nonempty_iff_imp_false.mp h x⟩\n\n"}
{"name":"Function.Surjective.nonempty","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Sort u_1\nβ : Sort u_2\nh : Nonempty β\nf : α → β\nhf : Function.Surjective f\n⊢ Nonempty α","decl":"theorem Function.Surjective.nonempty [h : Nonempty β] {f : α → β} (hf : Function.Surjective f) :\n    Nonempty α :=\n  let ⟨y⟩ := h\n  let ⟨x, _⟩ := hf y\n  ⟨x⟩\n\n"}
{"name":"nonempty_sigma","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Type u_1\nγ : α → Type u_3\n⊢ Iff (Nonempty (Sigma fun a => γ a)) (Exists fun a => Nonempty (γ a))","decl":"@[simp]\ntheorem nonempty_sigma : Nonempty (Σa : α, γ a) ↔ ∃ a : α, Nonempty (γ a) :=\n  Iff.intro (fun ⟨⟨a, c⟩⟩ ↦ ⟨a, ⟨c⟩⟩) fun ⟨a, ⟨c⟩⟩ ↦ ⟨⟨a, c⟩⟩\n\n"}
{"name":"nonempty_sum","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Iff (Nonempty (Sum α β)) (Or (Nonempty α) (Nonempty β))","decl":"@[simp]\ntheorem nonempty_sum : Nonempty (α ⊕ β) ↔ Nonempty α ∨ Nonempty β :=\n  Iff.intro\n    (fun ⟨h⟩ ↦\n      match h with\n      | Sum.inl a => Or.inl ⟨a⟩\n      | Sum.inr b => Or.inr ⟨b⟩)\n    fun h ↦\n    match h with\n    | Or.inl ⟨a⟩ => ⟨Sum.inl a⟩\n    | Or.inr ⟨b⟩ => ⟨Sum.inr b⟩\n\n"}
{"name":"nonempty_prod","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Iff (Nonempty (Prod α β)) (And (Nonempty α) (Nonempty β))","decl":"@[simp]\ntheorem nonempty_prod : Nonempty (α × β) ↔ Nonempty α ∧ Nonempty β :=\n  Iff.intro (fun ⟨⟨a, b⟩⟩ ↦ ⟨⟨a⟩, ⟨b⟩⟩) fun ⟨⟨a⟩, ⟨b⟩⟩ ↦ ⟨⟨a, b⟩⟩\n\n"}
{"name":"nonempty_ulift","module":"Mathlib.Logic.Nonempty","initialProofState":"α : Type u_1\n⊢ Iff (Nonempty (ULift α)) (Nonempty α)","decl":"@[simp]\ntheorem nonempty_ulift : Nonempty (ULift α) ↔ Nonempty α :=\n  Iff.intro (fun ⟨⟨a⟩⟩ ↦ ⟨a⟩) fun ⟨a⟩ ↦ ⟨⟨a⟩⟩\n\n"}
