{"name":"PosNum.lor_eq_or","module":"Mathlib.Data.Num.Bitwise","initialProofState":"p q : PosNum\n⊢ Eq (p.lor q) (HOr.hOr p q)","decl":"@[simp] lemma lor_eq_or (p q : PosNum) : p.lor q = p ||| q := rfl\n\n"}
{"name":"PosNum.land_eq_and","module":"Mathlib.Data.Num.Bitwise","initialProofState":"p q : PosNum\n⊢ Eq (p.land q) (HAnd.hAnd p q)","decl":"@[simp] lemma land_eq_and (p q : PosNum) : p.land q = p &&& q := rfl\n\n"}
{"name":"PosNum.lxor_eq_xor","module":"Mathlib.Data.Num.Bitwise","initialProofState":"p q : PosNum\n⊢ Eq (p.lxor q) (HXor.hXor p q)","decl":"@[simp] lemma lxor_eq_xor (p q : PosNum) : p.lxor q = p ^^^ q := rfl\n\n"}
{"name":"PosNum.shiftl_eq_shiftLeft","module":"Mathlib.Data.Num.Bitwise","initialProofState":"p : PosNum\nn : Nat\n⊢ Eq (p.shiftl n) (HShiftLeft.hShiftLeft p n)","decl":"@[simp] lemma shiftl_eq_shiftLeft (p : PosNum) (n : Nat) : p.shiftl n = p <<< n := rfl\n\n\n-- Porting note: `PosNum.shiftl` is defined as tail-recursive in Lean4.\n--               This theorem ensures the definition is same to one in Lean3.\n"}
{"name":"PosNum.shiftl_succ_eq_bit0_shiftl","module":"Mathlib.Data.Num.Bitwise","initialProofState":"p : PosNum\nn : Nat\n⊢ Eq (HShiftLeft.hShiftLeft p n.succ) (HShiftLeft.hShiftLeft p n).bit0","decl":"theorem shiftl_succ_eq_bit0_shiftl : ∀ (p : PosNum) (n : Nat), p <<< n.succ = bit0 (p <<< n)\n  | _, 0       => rfl\n  | p, .succ n => shiftl_succ_eq_bit0_shiftl p.bit0 n\n\n"}
{"name":"PosNum.shiftr_eq_shiftRight","module":"Mathlib.Data.Num.Bitwise","initialProofState":"p : PosNum\nn : Nat\n⊢ Eq (p.shiftr n) (HShiftRight.hShiftRight p n)","decl":"@[simp] lemma shiftr_eq_shiftRight (p : PosNum) (n : Nat) : p.shiftr n = p >>> n := rfl\n\n"}
{"name":"Num.lor_eq_or","module":"Mathlib.Data.Num.Bitwise","initialProofState":"p q : Num\n⊢ Eq (p.lor q) (HOr.hOr p q)","decl":"@[simp] lemma lor_eq_or (p q : Num) : p.lor q = p ||| q := rfl\n\n"}
{"name":"Num.land_eq_and","module":"Mathlib.Data.Num.Bitwise","initialProofState":"p q : Num\n⊢ Eq (p.land q) (HAnd.hAnd p q)","decl":"@[simp] lemma land_eq_and (p q : Num) : p.land q = p &&& q := rfl\n\n"}
{"name":"Num.lxor_eq_xor","module":"Mathlib.Data.Num.Bitwise","initialProofState":"p q : Num\n⊢ Eq (p.lxor q) (HXor.hXor p q)","decl":"@[simp] lemma lxor_eq_xor (p q : Num) : p.lxor q = p ^^^ q := rfl\n\n"}
{"name":"Num.shiftl_eq_shiftLeft","module":"Mathlib.Data.Num.Bitwise","initialProofState":"p : Num\nn : Nat\n⊢ Eq (p.shiftl n) (HShiftLeft.hShiftLeft p n)","decl":"@[simp] lemma shiftl_eq_shiftLeft (p : Num) (n : Nat) : p.shiftl n = p <<< n := rfl\n\n"}
{"name":"Num.shiftr_eq_shiftRight","module":"Mathlib.Data.Num.Bitwise","initialProofState":"p : Num\nn : Nat\n⊢ Eq (p.shiftr n) (HShiftRight.hShiftRight p n)","decl":"@[simp] lemma shiftr_eq_shiftRight (p : Num) (n : Nat) : p.shiftr n = p >>> n := rfl\n\n"}
{"name":"NzsNum.msb.inj","module":"Mathlib.Data.Num.Bitwise","initialProofState":"a✝¹ a✝ : Bool\nx✝ : Eq (NzsNum.msb a✝¹) (NzsNum.msb a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- This is a nonzero (and \"non minus one\") version of `SNum`.\n    See the documentation of `SNum` for more details. -/\ninductive NzsNum : Type\n  | msb : Bool → NzsNum\n  /-- Add a bit at the end of a `NzsNum`. -/\n  | bit : Bool → NzsNum → NzsNum\n  deriving DecidableEq  -- Porting note: Removed `deriving has_reflect`.\n\n"}
{"name":"NzsNum.msb.injEq","module":"Mathlib.Data.Num.Bitwise","initialProofState":"a✝¹ a✝ : Bool\n⊢ Eq (Eq (NzsNum.msb a✝¹) (NzsNum.msb a✝)) (Eq a✝¹ a✝)","decl":"/-- This is a nonzero (and \"non minus one\") version of `SNum`.\n    See the documentation of `SNum` for more details. -/\ninductive NzsNum : Type\n  | msb : Bool → NzsNum\n  /-- Add a bit at the end of a `NzsNum`. -/\n  | bit : Bool → NzsNum → NzsNum\n  deriving DecidableEq  -- Porting note: Removed `deriving has_reflect`.\n\n"}
{"name":"NzsNum.bit.injEq","module":"Mathlib.Data.Num.Bitwise","initialProofState":"a✝³ : Bool\na✝² : NzsNum\na✝¹ : Bool\na✝ : NzsNum\n⊢ Eq (Eq (NzsNum.bit a✝³ a✝²) (NzsNum.bit a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- This is a nonzero (and \"non minus one\") version of `SNum`.\n    See the documentation of `SNum` for more details. -/\ninductive NzsNum : Type\n  | msb : Bool → NzsNum\n  /-- Add a bit at the end of a `NzsNum`. -/\n  | bit : Bool → NzsNum → NzsNum\n  deriving DecidableEq  -- Porting note: Removed `deriving has_reflect`.\n\n"}
{"name":"NzsNum.bit.sizeOf_spec","module":"Mathlib.Data.Num.Bitwise","initialProofState":"a✝¹ : Bool\na✝ : NzsNum\n⊢ Eq (SizeOf.sizeOf (NzsNum.bit a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- This is a nonzero (and \"non minus one\") version of `SNum`.\n    See the documentation of `SNum` for more details. -/\ninductive NzsNum : Type\n  | msb : Bool → NzsNum\n  /-- Add a bit at the end of a `NzsNum`. -/\n  | bit : Bool → NzsNum → NzsNum\n  deriving DecidableEq  -- Porting note: Removed `deriving has_reflect`.\n\n"}
{"name":"NzsNum.bit.inj","module":"Mathlib.Data.Num.Bitwise","initialProofState":"a✝³ : Bool\na✝² : NzsNum\na✝¹ : Bool\na✝ : NzsNum\nx✝ : Eq (NzsNum.bit a✝³ a✝²) (NzsNum.bit a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- This is a nonzero (and \"non minus one\") version of `SNum`.\n    See the documentation of `SNum` for more details. -/\ninductive NzsNum : Type\n  | msb : Bool → NzsNum\n  /-- Add a bit at the end of a `NzsNum`. -/\n  | bit : Bool → NzsNum → NzsNum\n  deriving DecidableEq  -- Porting note: Removed `deriving has_reflect`.\n\n"}
{"name":"NzsNum.msb.sizeOf_spec","module":"Mathlib.Data.Num.Bitwise","initialProofState":"a✝ : Bool\n⊢ Eq (SizeOf.sizeOf (NzsNum.msb a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- This is a nonzero (and \"non minus one\") version of `SNum`.\n    See the documentation of `SNum` for more details. -/\ninductive NzsNum : Type\n  | msb : Bool → NzsNum\n  /-- Add a bit at the end of a `NzsNum`. -/\n  | bit : Bool → NzsNum → NzsNum\n  deriving DecidableEq  -- Porting note: Removed `deriving has_reflect`.\n\n"}
{"name":"SNum.nz.sizeOf_spec","module":"Mathlib.Data.Num.Bitwise","initialProofState":"a✝ : NzsNum\n⊢ Eq (SizeOf.sizeOf (SNum.nz a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- Alternative representation of integers using a sign bit at the end.\n  The convention on sign here is to have the argument to `msb` denote\n  the sign of the MSB itself, with all higher bits set to the negation\n  of this sign. The result is interpreted in two's complement.\n\n     13  = ..0001101(base 2) = nz (bit1 (bit0 (bit1 (msb true))))\n     -13 = ..1110011(base 2) = nz (bit1 (bit1 (bit0 (msb false))))\n\n  As with `Num`, a special case must be added for zero, which has no msb,\n  but by two's complement symmetry there is a second special case for -1.\n  Here the `Bool` field indicates the sign of the number.\n\n     0  = ..0000000(base 2) = zero false\n     -1 = ..1111111(base 2) = zero true -/\ninductive SNum : Type\n  | zero : Bool → SNum\n  | nz : NzsNum → SNum\n  deriving DecidableEq  -- Porting note: Removed `deriving has_reflect`.\n\n"}
{"name":"SNum.zero.injEq","module":"Mathlib.Data.Num.Bitwise","initialProofState":"a✝¹ a✝ : Bool\n⊢ Eq (Eq (SNum.zero a✝¹) (SNum.zero a✝)) (Eq a✝¹ a✝)","decl":"/-- Alternative representation of integers using a sign bit at the end.\n  The convention on sign here is to have the argument to `msb` denote\n  the sign of the MSB itself, with all higher bits set to the negation\n  of this sign. The result is interpreted in two's complement.\n\n     13  = ..0001101(base 2) = nz (bit1 (bit0 (bit1 (msb true))))\n     -13 = ..1110011(base 2) = nz (bit1 (bit1 (bit0 (msb false))))\n\n  As with `Num`, a special case must be added for zero, which has no msb,\n  but by two's complement symmetry there is a second special case for -1.\n  Here the `Bool` field indicates the sign of the number.\n\n     0  = ..0000000(base 2) = zero false\n     -1 = ..1111111(base 2) = zero true -/\ninductive SNum : Type\n  | zero : Bool → SNum\n  | nz : NzsNum → SNum\n  deriving DecidableEq  -- Porting note: Removed `deriving has_reflect`.\n\n"}
{"name":"SNum.zero.inj","module":"Mathlib.Data.Num.Bitwise","initialProofState":"a✝¹ a✝ : Bool\nx✝ : Eq (SNum.zero a✝¹) (SNum.zero a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- Alternative representation of integers using a sign bit at the end.\n  The convention on sign here is to have the argument to `msb` denote\n  the sign of the MSB itself, with all higher bits set to the negation\n  of this sign. The result is interpreted in two's complement.\n\n     13  = ..0001101(base 2) = nz (bit1 (bit0 (bit1 (msb true))))\n     -13 = ..1110011(base 2) = nz (bit1 (bit1 (bit0 (msb false))))\n\n  As with `Num`, a special case must be added for zero, which has no msb,\n  but by two's complement symmetry there is a second special case for -1.\n  Here the `Bool` field indicates the sign of the number.\n\n     0  = ..0000000(base 2) = zero false\n     -1 = ..1111111(base 2) = zero true -/\ninductive SNum : Type\n  | zero : Bool → SNum\n  | nz : NzsNum → SNum\n  deriving DecidableEq  -- Porting note: Removed `deriving has_reflect`.\n\n"}
{"name":"SNum.zero.sizeOf_spec","module":"Mathlib.Data.Num.Bitwise","initialProofState":"a✝ : Bool\n⊢ Eq (SizeOf.sizeOf (SNum.zero a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- Alternative representation of integers using a sign bit at the end.\n  The convention on sign here is to have the argument to `msb` denote\n  the sign of the MSB itself, with all higher bits set to the negation\n  of this sign. The result is interpreted in two's complement.\n\n     13  = ..0001101(base 2) = nz (bit1 (bit0 (bit1 (msb true))))\n     -13 = ..1110011(base 2) = nz (bit1 (bit1 (bit0 (msb false))))\n\n  As with `Num`, a special case must be added for zero, which has no msb,\n  but by two's complement symmetry there is a second special case for -1.\n  Here the `Bool` field indicates the sign of the number.\n\n     0  = ..0000000(base 2) = zero false\n     -1 = ..1111111(base 2) = zero true -/\ninductive SNum : Type\n  | zero : Bool → SNum\n  | nz : NzsNum → SNum\n  deriving DecidableEq  -- Porting note: Removed `deriving has_reflect`.\n\n"}
{"name":"SNum.nz.injEq","module":"Mathlib.Data.Num.Bitwise","initialProofState":"a✝¹ a✝ : NzsNum\n⊢ Eq (Eq (SNum.nz a✝¹) (SNum.nz a✝)) (Eq a✝¹ a✝)","decl":"/-- Alternative representation of integers using a sign bit at the end.\n  The convention on sign here is to have the argument to `msb` denote\n  the sign of the MSB itself, with all higher bits set to the negation\n  of this sign. The result is interpreted in two's complement.\n\n     13  = ..0001101(base 2) = nz (bit1 (bit0 (bit1 (msb true))))\n     -13 = ..1110011(base 2) = nz (bit1 (bit1 (bit0 (msb false))))\n\n  As with `Num`, a special case must be added for zero, which has no msb,\n  but by two's complement symmetry there is a second special case for -1.\n  Here the `Bool` field indicates the sign of the number.\n\n     0  = ..0000000(base 2) = zero false\n     -1 = ..1111111(base 2) = zero true -/\ninductive SNum : Type\n  | zero : Bool → SNum\n  | nz : NzsNum → SNum\n  deriving DecidableEq  -- Porting note: Removed `deriving has_reflect`.\n\n"}
{"name":"SNum.nz.inj","module":"Mathlib.Data.Num.Bitwise","initialProofState":"a✝¹ a✝ : NzsNum\nx✝ : Eq (SNum.nz a✝¹) (SNum.nz a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- Alternative representation of integers using a sign bit at the end.\n  The convention on sign here is to have the argument to `msb` denote\n  the sign of the MSB itself, with all higher bits set to the negation\n  of this sign. The result is interpreted in two's complement.\n\n     13  = ..0001101(base 2) = nz (bit1 (bit0 (bit1 (msb true))))\n     -13 = ..1110011(base 2) = nz (bit1 (bit1 (bit0 (msb false))))\n\n  As with `Num`, a special case must be added for zero, which has no msb,\n  but by two's complement symmetry there is a second special case for -1.\n  Here the `Bool` field indicates the sign of the number.\n\n     0  = ..0000000(base 2) = zero false\n     -1 = ..1111111(base 2) = zero true -/\ninductive SNum : Type\n  | zero : Bool → SNum\n  | nz : NzsNum → SNum\n  deriving DecidableEq  -- Porting note: Removed `deriving has_reflect`.\n\n"}
{"name":"SNum.bit_zero","module":"Mathlib.Data.Num.Bitwise","initialProofState":"b : Bool\n⊢ Eq (SNum.bit b (SNum.zero b)) (SNum.zero b)","decl":"theorem bit_zero (b : Bool) : (b :: zero b) = zero b := by cases b <;> rfl\n\n"}
{"name":"SNum.bit_one","module":"Mathlib.Data.Num.Bitwise","initialProofState":"b : Bool\n⊢ Eq (SNum.bit b (SNum.zero (Decidable.decide (Not (Eq b Bool.true))))) (SNum.nz (NzsNum.msb b))","decl":"theorem bit_one (b : Bool) : (b :: zero (Not b)) = msb b := by cases b <;> rfl\n\n"}
