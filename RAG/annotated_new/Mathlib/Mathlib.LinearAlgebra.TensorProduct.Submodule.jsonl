{"name":"Submodule.mulMap_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nm : Subtype fun x => Membership.mem M x\nn : Subtype fun x => Membership.mem N x\n⊢ Eq ((M.mulMap N) (TensorProduct.tmul R m n)) (HMul.hMul ↑m ↑n)","decl":"@[simp]\ntheorem mulMap_tmul (m : M) (n : N) : mulMap M N (m ⊗ₜ[R] n) = m.1 * n.1 := rfl\n\n"}
{"name":"Submodule.mulMap_map_comp_eq","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : Algebra R S\nM N : Submodule R S\nT : Type w\ninst✝³ : Semiring T\ninst✝² : Algebra R T\nF : Type u_1\ninst✝¹ : FunLike F S T\ninst✝ : AlgHomClass F R S T\nf : F\n⊢ Eq (((Submodule.map f M).mulMap (Submodule.map f N)).comp (TensorProduct.map ((↑f).submoduleMap M) ((↑f).submoduleMap N))) ((↑f).comp (M.mulMap N))","decl":"theorem mulMap_map_comp_eq {T : Type w} [Semiring T] [Algebra R T]\n    {F : Type*} [FunLike F S T] [AlgHomClass F R S T] (f : F) :\n    mulMap (M.map f) (N.map f) ∘ₗ\n      TensorProduct.map ((f : S →ₗ[R] T).submoduleMap M) ((f : S →ₗ[R] T).submoduleMap N)\n        = f ∘ₗ mulMap M N := by\n  ext\n  simp only [TensorProduct.AlgebraTensorModule.curry_apply, LinearMap.restrictScalars_comp,\n    TensorProduct.curry_apply, LinearMap.coe_comp, LinearMap.coe_restrictScalars,\n    Function.comp_apply, TensorProduct.map_tmul, mulMap_tmul, LinearMap.coe_coe, map_mul]\n  rfl\n\n"}
{"name":"Submodule.mulMap_op","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\n⊢ Eq ((Submodule.equivOpposite.symm (MulOpposite.op M)).mulMap (Submodule.equivOpposite.symm (MulOpposite.op N))) ((↑(MulOpposite.opLinearEquiv R)).comp ((N.mulMap M).comp ↑((TensorProduct.congr ((MulOpposite.opLinearEquiv R).symm.ofSubmodule' M) ((MulOpposite.opLinearEquiv R).symm.ofSubmodule' N)).trans (TensorProduct.comm R (Subtype fun x => Membership.mem M x) (Subtype fun x => Membership.mem N x)))))","decl":"theorem mulMap_op :\n    mulMap (equivOpposite.symm (MulOpposite.op M)) (equivOpposite.symm (MulOpposite.op N)) =\n    (MulOpposite.opLinearEquiv R).toLinearMap ∘ₗ mulMap N M ∘ₗ\n    (TensorProduct.congr\n      (LinearEquiv.ofSubmodule' (MulOpposite.opLinearEquiv R).symm M)\n      (LinearEquiv.ofSubmodule' (MulOpposite.opLinearEquiv R).symm N) ≪≫ₗ\n    TensorProduct.comm R M N).toLinearMap :=\n  TensorProduct.ext' fun _ _ ↦ rfl\n\n"}
{"name":"Submodule.mulMap_comm_of_commute","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nhc : ∀ (m : Subtype fun x => Membership.mem M x) (n : Subtype fun x => Membership.mem N x), Commute ↑m ↑n\n⊢ Eq (N.mulMap M) ((M.mulMap N).comp ↑(TensorProduct.comm R (Subtype fun x => Membership.mem N x) (Subtype fun x => Membership.mem M x)))","decl":"theorem mulMap_comm_of_commute (hc : ∀ (m : M) (n : N), Commute m.1 n.1) :\n    mulMap N M = mulMap M N ∘ₗ TensorProduct.comm R N M := by\n  refine TensorProduct.ext' fun n m ↦ ?_\n  simp_rw [LinearMap.comp_apply, LinearEquiv.coe_coe, TensorProduct.comm_tmul, mulMap_tmul]\n  exact (hc m n).symm\n\n"}
{"name":"Submodule.mulMap_comp_rTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N M' : Submodule R S\nhM : LE.le M' M\n⊢ Eq ((M.mulMap N).comp (LinearMap.rTensor (Subtype fun x => Membership.mem N x) (Submodule.inclusion hM))) (M'.mulMap N)","decl":"variable {M} in\ntheorem mulMap_comp_rTensor {M' : Submodule R S} (hM : M' ≤ M) :\n    mulMap M N ∘ₗ (inclusion hM).rTensor N = mulMap M' N :=\n  TensorProduct.ext' fun _ _ ↦ rfl\n\n"}
{"name":"Submodule.mulMap_comp_lTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N N' : Submodule R S\nhN : LE.le N' N\n⊢ Eq ((M.mulMap N).comp (LinearMap.lTensor (Subtype fun x => Membership.mem M x) (Submodule.inclusion hN))) (M.mulMap N')","decl":"variable {N} in\ntheorem mulMap_comp_lTensor {N' : Submodule R S} (hN : N' ≤ N) :\n    mulMap M N ∘ₗ (inclusion hN).lTensor M = mulMap M N' :=\n  TensorProduct.ext' fun _ _ ↦ rfl\n\n"}
{"name":"Submodule.mulMap_comp_map_inclusion","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N M' N' : Submodule R S\nhM : LE.le M' M\nhN : LE.le N' N\n⊢ Eq ((M.mulMap N).comp (TensorProduct.map (Submodule.inclusion hM) (Submodule.inclusion hN))) (M'.mulMap N')","decl":"variable {M N} in\ntheorem mulMap_comp_map_inclusion {M' N' : Submodule R S} (hM : M' ≤ M) (hN : N' ≤ N) :\n    mulMap M N ∘ₗ TensorProduct.map (inclusion hM) (inclusion hN) = mulMap M' N' :=\n  TensorProduct.ext' fun _ _ ↦ rfl\n\n"}
{"name":"Submodule.mulMap_eq_mul'_comp_mapIncl","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\n⊢ Eq (M.mulMap N) ((LinearMap.mul' R S).comp (TensorProduct.mapIncl M N))","decl":"theorem mulMap_eq_mul'_comp_mapIncl : mulMap M N = .mul' R S ∘ₗ TensorProduct.mapIncl M N :=\n  TensorProduct.ext' fun _ _ ↦ rfl\n\n"}
{"name":"Submodule.mulMap_range","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\n⊢ Eq (LinearMap.range (M.mulMap N)) (HMul.hMul M N)","decl":"theorem mulMap_range : LinearMap.range (mulMap M N) = M * N := by\n  refine le_antisymm ?_ (mul_le.2 fun m hm n hn ↦ ⟨⟨m, hm⟩ ⊗ₜ[R] ⟨n, hn⟩, rfl⟩)\n  rintro _ ⟨x, rfl⟩\n  induction x with\n  | zero => rw [_root_.map_zero]; exact zero_mem _\n  | tmul a b => exact mul_mem_mul a.2 b.2\n  | add a b ha hb => rw [_root_.map_add]; exact add_mem ha hb\n\n"}
{"name":"Submodule.val_mulMap'_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nm : Subtype fun x => Membership.mem M x\nn : Subtype fun x => Membership.mem N x\n⊢ Eq (↑((M.mulMap' N) (TensorProduct.tmul R m n))) (HMul.hMul ↑m ↑n)","decl":"variable {M N} in\n@[simp]\ntheorem val_mulMap'_tmul (m : M) (n : N) : (mulMap' M N (m ⊗ₜ[R] n) : S) = m.1 * n.1 := rfl\n\n"}
{"name":"Submodule.mulMap'_surjective","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\n⊢ Function.Surjective ⇑(M.mulMap' N)","decl":"theorem mulMap'_surjective : Function.Surjective (mulMap' M N) := by\n  simp_rw [mulMap', LinearMap.coe_comp, LinearEquiv.coe_coe, EquivLike.comp_surjective,\n    LinearMap.surjective_rangeRestrict]\n\n"}
{"name":"Submodule.lTensorOne'_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nN : Submodule R S\ny : R\nn : Subtype fun x => Membership.mem N x\n⊢ Eq (N.lTensorOne' (TensorProduct.tmul R ((algebraMap R (Subtype fun x => Membership.mem Bot.bot x)) y) n)) (HSMul.hSMul y n)","decl":"variable {N} in\n@[simp]\ntheorem lTensorOne'_tmul (y : R) (n : N) :\n    N.lTensorOne' (algebraMap R _ y ⊗ₜ[R] n) = y • n := Subtype.val_injective <| by\n  simp_rw [lTensorOne', LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,\n    LinearEquiv.coe_ofEq_apply, LinearMap.codRestrict_apply, SetLike.val_smul, Algebra.smul_def]\n  exact mulMap_tmul _ N _ _\n\n"}
{"name":"Submodule.lTensorOne'_one_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nN : Submodule R S\nn : Subtype fun x => Membership.mem N x\n⊢ Eq (N.lTensorOne' (TensorProduct.tmul R 1 n)) n","decl":"variable {N} in\n@[simp]\ntheorem lTensorOne'_one_tmul (n : N) : N.lTensorOne' (1 ⊗ₜ[R] n) = n := by\n  simpa using lTensorOne'_tmul 1 n\n\n"}
{"name":"Submodule.lTensorOne_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nN : Submodule R S\ny : R\nn : Subtype fun x => Membership.mem N x\n⊢ Eq (N.lTensorOne (TensorProduct.tmul R ((algebraMap R (Subtype fun x => Membership.mem Bot.bot x)) y) n)) (HSMul.hSMul y n)","decl":"variable {N} in\n@[simp]\ntheorem lTensorOne_tmul (y : R) (n : N) : N.lTensorOne (algebraMap R _ y ⊗ₜ[R] n) = y • n :=\n  N.lTensorOne'_tmul y n\n\n"}
{"name":"Submodule.lTensorOne_one_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nN : Submodule R S\nn : Subtype fun x => Membership.mem N x\n⊢ Eq (N.lTensorOne (TensorProduct.tmul R 1 n)) n","decl":"variable {N} in\n@[simp]\ntheorem lTensorOne_one_tmul (n : N) : N.lTensorOne (1 ⊗ₜ[R] n) = n :=\n  N.lTensorOne'_one_tmul n\n\n"}
{"name":"Submodule.lTensorOne_symm_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nN : Submodule R S\nn : Subtype fun x => Membership.mem N x\n⊢ Eq (N.lTensorOne.symm n) (TensorProduct.tmul R 1 n)","decl":"variable {N} in\n@[simp]\ntheorem lTensorOne_symm_apply (n : N) : N.lTensorOne.symm n = 1 ⊗ₜ[R] n := rfl\n\n"}
{"name":"Submodule.mulMap_one_left_eq","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nN : Submodule R S\n⊢ Eq ((Subalgebra.toSubmodule Bot.bot).mulMap N) (N.subtype.comp ↑N.lTensorOne)","decl":"theorem mulMap_one_left_eq :\n    mulMap (Subalgebra.toSubmodule ⊥) N = N.subtype ∘ₗ N.lTensorOne.toLinearMap :=\n  TensorProduct.ext' fun _ _ ↦ rfl\n\n"}
{"name":"Submodule.rTensorOne'_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM : Submodule R S\ny : R\nm : Subtype fun x => Membership.mem M x\n⊢ Eq (M.rTensorOne' (TensorProduct.tmul R m ((algebraMap R (Subtype fun x => Membership.mem Bot.bot x)) y))) (HSMul.hSMul y m)","decl":"variable {M} in\n@[simp]\ntheorem rTensorOne'_tmul (y : R) (m : M) :\n    M.rTensorOne' (m ⊗ₜ[R] algebraMap R _ y) = y • m := Subtype.val_injective <| by\n  simp_rw [rTensorOne', LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,\n    LinearEquiv.coe_ofEq_apply, LinearMap.codRestrict_apply, SetLike.val_smul]\n  rw [Algebra.smul_def, Algebra.commutes]\n  exact mulMap_tmul M _ _ _\n\n"}
{"name":"Submodule.rTensorOne'_tmul_one","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM : Submodule R S\nm : Subtype fun x => Membership.mem M x\n⊢ Eq (M.rTensorOne' (TensorProduct.tmul R m 1)) m","decl":"variable {M} in\n@[simp]\ntheorem rTensorOne'_tmul_one (m : M) : M.rTensorOne' (m ⊗ₜ[R] 1) = m := by\n  simpa using rTensorOne'_tmul 1 m\n\n"}
{"name":"Submodule.rTensorOne_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM : Submodule R S\ny : R\nm : Subtype fun x => Membership.mem M x\n⊢ Eq (M.rTensorOne (TensorProduct.tmul R m ((algebraMap R (Subtype fun x => Membership.mem Bot.bot x)) y))) (HSMul.hSMul y m)","decl":"variable {M} in\n@[simp]\ntheorem rTensorOne_tmul (y : R) (m : M) : M.rTensorOne (m ⊗ₜ[R] algebraMap R _ y) = y • m :=\n  M.rTensorOne'_tmul y m\n\n"}
{"name":"Submodule.rTensorOne_tmul_one","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM : Submodule R S\nm : Subtype fun x => Membership.mem M x\n⊢ Eq (M.rTensorOne (TensorProduct.tmul R m 1)) m","decl":"variable {M} in\n@[simp]\ntheorem rTensorOne_tmul_one (m : M) : M.rTensorOne (m ⊗ₜ[R] 1) = m :=\n  M.rTensorOne'_tmul_one m\n\n"}
{"name":"Submodule.rTensorOne_symm_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM : Submodule R S\nm : Subtype fun x => Membership.mem M x\n⊢ Eq (M.rTensorOne.symm m) (TensorProduct.tmul R m 1)","decl":"variable {M} in\n@[simp]\ntheorem rTensorOne_symm_apply (m : M) : M.rTensorOne.symm m = m ⊗ₜ[R] 1 := rfl\n\n"}
{"name":"Submodule.mulMap_one_right_eq","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM : Submodule R S\n⊢ Eq (M.mulMap (Subalgebra.toSubmodule Bot.bot)) (M.subtype.comp ↑M.rTensorOne)","decl":"theorem mulMap_one_right_eq :\n    mulMap M (Subalgebra.toSubmodule ⊥) = M.subtype ∘ₗ M.rTensorOne.toLinearMap :=\n  TensorProduct.ext' fun _ _ ↦ rfl\n\n"}
{"name":"Submodule.comm_trans_lTensorOne","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM : Submodule R S\n⊢ Eq ((TensorProduct.comm R (Subtype fun x => Membership.mem M x) (Subtype fun x => Membership.mem Bot.bot x)).trans M.lTensorOne) M.rTensorOne","decl":"@[simp]\ntheorem comm_trans_lTensorOne :\n    (TensorProduct.comm R _ _).trans M.lTensorOne = M.rTensorOne := by\n  refine LinearEquiv.toLinearMap_injective <| TensorProduct.ext' fun m r ↦ ?_\n  obtain ⟨x, h⟩ := Algebra.mem_bot.1 r.2\n  replace h : algebraMap R _ x = r := Subtype.val_injective h\n  rw [← h]; simp\n\n"}
{"name":"Submodule.comm_trans_rTensorOne","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM : Submodule R S\n⊢ Eq ((TensorProduct.comm R (Subtype fun x => Membership.mem Bot.bot x) (Subtype fun x => Membership.mem M x)).trans M.rTensorOne) M.lTensorOne","decl":"@[simp]\ntheorem comm_trans_rTensorOne :\n    (TensorProduct.comm R _ _).trans M.rTensorOne = M.lTensorOne := by\n  refine LinearEquiv.toLinearMap_injective <| TensorProduct.ext' fun r m ↦ ?_\n  obtain ⟨x, h⟩ := Algebra.mem_bot.1 r.2\n  replace h : algebraMap R _ x = r := Subtype.val_injective h\n  rw [← h]; simp\n\n"}
{"name":"Submodule.mulLeftMap_eq_mulMap_comp","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : Semiring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nι : Type u_1\ninst✝ : DecidableEq ι\nm : ι → Subtype fun x => Membership.mem M x\n⊢ Eq (Submodule.mulLeftMap N m) ((M.mulMap N).comp ((LinearMap.rTensor (Subtype fun x => Membership.mem N x) (Finsupp.linearCombination R m)).comp ↑(TensorProduct.finsuppScalarLeft R (Subtype fun x => Membership.mem N x) ι).symm))","decl":"variable {M} in\ntheorem mulLeftMap_eq_mulMap_comp {ι : Type*} [DecidableEq ι] (m : ι → M) :\n    mulLeftMap N m = mulMap M N ∘ₗ LinearMap.rTensor N (Finsupp.linearCombination R m) ∘ₗ\n      (TensorProduct.finsuppScalarLeft R N ι).symm.toLinearMap := by\n  ext; simp\n\n"}
{"name":"Submodule.mulRightMap_eq_mulMap_comp","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : Semiring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nι : Type u_1\ninst✝ : DecidableEq ι\nn : ι → Subtype fun x => Membership.mem N x\n⊢ Eq (M.mulRightMap n) ((M.mulMap N).comp ((LinearMap.lTensor (Subtype fun x => Membership.mem M x) (Finsupp.linearCombination R n)).comp ↑(TensorProduct.finsuppScalarRight R (Subtype fun x => Membership.mem M x) ι).symm))","decl":"variable {N} in\ntheorem mulRightMap_eq_mulMap_comp {ι : Type*} [DecidableEq ι] (n : ι → N) :\n    mulRightMap M n = mulMap M N ∘ₗ LinearMap.lTensor M (Finsupp.linearCombination R n) ∘ₗ\n      (TensorProduct.finsuppScalarRight R M ι).symm.toLinearMap := by\n  ext; simp\n\n"}
{"name":"Submodule.mulMap_comm","module":"Mathlib.LinearAlgebra.TensorProduct.Submodule","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nM N : Submodule R S\n⊢ Eq (N.mulMap M) ((M.mulMap N).comp ↑(TensorProduct.comm R (Subtype fun x => Membership.mem N x) (Subtype fun x => Membership.mem M x)))","decl":"theorem mulMap_comm : mulMap N M = (mulMap M N).comp (TensorProduct.comm R N M).toLinearMap :=\n  mulMap_comm_of_commute M N fun _ _ ↦ mul_comm _ _\n\n"}
