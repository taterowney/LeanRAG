{"name":"CochainComplex.homologySequenceδ_quotient_mapTriangle_obj_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShortExact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nT : CategoryTheory.Pretriangulated.Triangle (CochainComplex C Int)\nn₀ n₁ : Int\nh✝ : Eq (HAdd.hAdd n₀ 1) n₁\nZ : C\nh : Quiver.Hom (((HomotopyCategory.homologyFunctor C (ComplexShape.up Int) 0).shift n₁).obj ((HomotopyCategory.quotient C (ComplexShape.up Int)).mapTriangle.obj T).obj₁) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.homologyFunctor C (ComplexShape.up Int) 0).homologySequenceδ ((HomotopyCategory.quotient C (ComplexShape.up Int)).mapTriangle.obj T) n₀ n₁ h✝) h) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.homologyFunctorFactors C (ComplexShape.up Int) n₀).hom.app T.obj₃) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor C (ComplexShape.up Int) 0).shiftMap T.mor₃ n₀ n₁ ⋯) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.homologyFunctorFactors C (ComplexShape.up Int) n₁).inv.app T.obj₁) h)))","decl":"@[reassoc]\nlemma homologySequenceδ_quotient_mapTriangle_obj\n    (T : Triangle (CochainComplex C ℤ)) (n₀ n₁ : ℤ) (h : n₀ + 1 = n₁) :\n    (homologyFunctor C (up ℤ) 0).homologySequenceδ\n        ((quotient C (up ℤ)).mapTriangle.obj T) n₀ n₁ h =\n      (homologyFunctorFactors C (up ℤ) n₀).hom.app _ ≫\n        (HomologicalComplex.homologyFunctor C (up ℤ) 0).shiftMap T.mor₃ n₀ n₁ (by omega) ≫\n        (homologyFunctorFactors C (up ℤ) n₁).inv.app _ := by\n  apply homologyFunctor_shiftMap\n\n"}
{"name":"CochainComplex.homologySequenceδ_quotient_mapTriangle_obj","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShortExact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nT : CategoryTheory.Pretriangulated.Triangle (CochainComplex C Int)\nn₀ n₁ : Int\nh : Eq (HAdd.hAdd n₀ 1) n₁\n⊢ Eq ((HomotopyCategory.homologyFunctor C (ComplexShape.up Int) 0).homologySequenceδ ((HomotopyCategory.quotient C (ComplexShape.up Int)).mapTriangle.obj T) n₀ n₁ h) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.homologyFunctorFactors C (ComplexShape.up Int) n₀).hom.app T.obj₃) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor C (ComplexShape.up Int) 0).shiftMap T.mor₃ n₀ n₁ ⋯) ((HomotopyCategory.homologyFunctorFactors C (ComplexShape.up Int) n₁).inv.app T.obj₁)))","decl":"@[reassoc]\nlemma homologySequenceδ_quotient_mapTriangle_obj\n    (T : Triangle (CochainComplex C ℤ)) (n₀ n₁ : ℤ) (h : n₀ + 1 = n₁) :\n    (homologyFunctor C (up ℤ) 0).homologySequenceδ\n        ((quotient C (up ℤ)).mapTriangle.obj T) n₀ n₁ h =\n      (homologyFunctorFactors C (up ℤ) n₀).hom.app _ ≫\n        (HomologicalComplex.homologyFunctor C (up ℤ) 0).shiftMap T.mor₃ n₀ n₁ (by omega) ≫\n        (homologyFunctorFactors C (up ℤ) n₁).inv.app _ := by\n  apply homologyFunctor_shiftMap\n\n"}
{"name":"CochainComplex.mappingCone.inr_descShortComplex_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShortExact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex (CochainComplex C Int)\nZ : CochainComplex C Int\nh : Quiver.Hom S.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr S.f) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.descShortComplex S) h)) (CategoryTheory.CategoryStruct.comp S.g h)","decl":"@[reassoc (attr := simp)]\nlemma inr_descShortComplex : inr S.f ≫ descShortComplex S = S.g := by\n  simp [descShortComplex]\n\n"}
{"name":"CochainComplex.mappingCone.inr_descShortComplex","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShortExact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex (CochainComplex C Int)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr S.f) (CochainComplex.mappingCone.descShortComplex S)) S.g","decl":"@[reassoc (attr := simp)]\nlemma inr_descShortComplex : inr S.f ≫ descShortComplex S = S.g := by\n  simp [descShortComplex]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_descShortComplex_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShortExact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex (CochainComplex C Int)\nn : Int\nZ : C\nh : Quiver.Hom (S.X₃.X n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr S.f).f n) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.descShortComplex S).f n) h)) (CategoryTheory.CategoryStruct.comp (S.g.f n) h)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_descShortComplex_f (n : ℤ) : (inr S.f).f n ≫ (descShortComplex S).f n = S.g.f n := by\n  simp [descShortComplex]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_descShortComplex_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShortExact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex (CochainComplex C Int)\nn : Int\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr S.f).f n) ((CochainComplex.mappingCone.descShortComplex S).f n)) (S.g.f n)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_descShortComplex_f (n : ℤ) : (inr S.f).f n ≫ (descShortComplex S).f n = S.g.f n := by\n  simp [descShortComplex]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_descShortComplex_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShortExact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex (CochainComplex C Int)\ni j : Int\nh : Eq (HAdd.hAdd i (-1)) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl S.f).v i j h) ((CochainComplex.mappingCone.descShortComplex S).f j)) 0","decl":"@[reassoc (attr := simp)]\nlemma inl_v_descShortComplex_f (i j : ℤ) (h : i + (-1) = j) :\n    (inl S.f).v i j h ≫ (descShortComplex S).f j = 0 := by\n  simp [descShortComplex]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_descShortComplex_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShortExact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex (CochainComplex C Int)\ni j : Int\nh✝ : Eq (HAdd.hAdd i (-1)) j\nZ : C\nh : Quiver.Hom (S.X₃.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl S.f).v i j h✝) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.descShortComplex S).f j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_descShortComplex_f (i j : ℤ) (h : i + (-1) = j) :\n    (inl S.f).v i j h ≫ (descShortComplex S).f j = 0 := by\n  simp [descShortComplex]\n\n"}
{"name":"CochainComplex.mappingCone.homologySequenceδ_triangleh","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShortExact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex (CochainComplex C Int)\nhS : S.ShortExact\nn₀ n₁ : Int\nh : Eq (HAdd.hAdd n₀ 1) n₁\n⊢ Eq ((HomotopyCategory.homologyFunctor C (ComplexShape.up Int) 0).homologySequenceδ (CochainComplex.mappingCone.triangleh S.f) n₀ n₁ h) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.homologyFunctorFactors C (ComplexShape.up Int) n₀).hom.app (CochainComplex.mappingCone S.f)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyMap (CochainComplex.mappingCone.descShortComplex S) n₀) (CategoryTheory.CategoryStruct.comp (hS.δ n₀ n₁ h) ((HomotopyCategory.homologyFunctorFactors C (ComplexShape.up Int) n₁).inv.app S.X₁))))","decl":"lemma homologySequenceδ_triangleh (n₀ : ℤ) (n₁ : ℤ) (h : n₀ + 1 = n₁) :\n    (homologyFunctor C (up ℤ) 0).homologySequenceδ (triangleh S.f) n₀ n₁ h =\n      (homologyFunctorFactors C (up ℤ) n₀).hom.app _ ≫\n        HomologicalComplex.homologyMap (descShortComplex S) n₀ ≫ hS.δ n₀ n₁ h ≫\n          (homologyFunctorFactors C (up ℤ) n₁).inv.app _ := by\n  /- We proceed by diagram chase. We test the identity on\n     cocycles `x' : A' ⟶ (mappingCone S.f).X n₀` -/\n  dsimp\n  rw [← cancel_mono ((homologyFunctorFactors C (up ℤ) n₁).hom.app _),\n    assoc, assoc, assoc, Iso.inv_hom_id_app,\n    ← cancel_epi ((homologyFunctorFactors C (up ℤ) n₀).inv.app _), Iso.inv_hom_id_app_assoc]\n  apply yoneda.map_injective\n  ext ⟨A⟩ (x : A ⟶ _)\n  obtain ⟨A', π, _, x', w, hx'⟩ :=\n    (mappingCone S.f).eq_liftCycles_homologyπ_up_to_refinements x n₁ (by simpa using h)\n  erw [homologySequenceδ_quotient_mapTriangle_obj_assoc _ _ _ h]\n  dsimp\n  rw [comp_id, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app]\n  erw [comp_id]\n  rw [← cancel_epi π, reassoc_of% hx', reassoc_of% hx',\n    HomologicalComplex.homologyπ_naturality_assoc,\n    HomologicalComplex.liftCycles_comp_cyclesMap_assoc]\n  /- We decompose the cocycle `x'` into two morphisms `a : A' ⟶ S.X₁.X n₁`\n     and `b : A' ⟶ S.X₂.X n₀` satisfying certain relations. -/\n  obtain ⟨a, b, hab⟩ := decomp_to _ x' n₁ h\n  rw [hab, ext_to_iff _ n₁ (n₁ + 1) rfl, add_comp, assoc, assoc, inr_f_d, add_comp, assoc,\n    assoc, assoc, assoc, inr_f_fst_v, comp_zero, comp_zero, add_zero, zero_comp,\n    d_fst_v _ _ _ _ h, comp_neg, inl_v_fst_v_assoc, comp_neg, neg_eq_zero,\n    add_comp, assoc, assoc, assoc, assoc, inr_f_snd_v, comp_id, zero_comp,\n    d_snd_v _ _ _ h, comp_add, inl_v_fst_v_assoc, inl_v_snd_v_assoc, zero_comp, add_zero] at w\n  /- We simplify the RHS. -/\n  conv_rhs => simp only [hab, add_comp, assoc, inr_f_descShortComplex_f,\n    inl_v_descShortComplex_f, comp_zero, zero_add]\n  rw [hS.δ_eq n₀ n₁ (by simpa using h) (b ≫ S.g.f n₀) _ b rfl (-a)\n    (by simp only [neg_comp, neg_eq_iff_add_eq_zero, w.2]) (n₁ + 1) (by simp)]\n  /- We simplify the LHS. -/\n  dsimp [Functor.shiftMap, homologyFunctor_shift]\n  rw [HomologicalComplex.homologyπ_naturality_assoc,\n    HomologicalComplex.liftCycles_comp_cyclesMap_assoc,\n    S.X₁.liftCycles_shift_homologyπ_assoc _ _ _ _ n₁ (by omega) (n₁ + 1) (by simp),\n    Iso.inv_hom_id_app]\n  dsimp [homologyFunctor_shift]\n  simp only [hab, add_comp, assoc, inl_v_triangle_mor₃_f_assoc,\n    shiftFunctorObjXIso, neg_comp, Iso.inv_hom_id, comp_neg, comp_id,\n    inr_f_triangle_mor₃_f_assoc, zero_comp, comp_zero, add_zero]\n\n"}
{"name":"CochainComplex.mappingCone.quasiIso_descShortComplex","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShortExact","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex (CochainComplex C Int)\nhS : S.ShortExact\n⊢ QuasiIso (CochainComplex.mappingCone.descShortComplex S)","decl":"include hS in\nlemma quasiIso_descShortComplex : QuasiIso (descShortComplex S) where\n  quasiIsoAt n := by\n    rw [quasiIsoAt_iff_isIso_homologyMap]\n    let φ : ((homologyFunctor C (up ℤ) 0).homologySequenceComposableArrows₅\n        (triangleh S.f) n _ rfl).δlast ⟶ (composableArrows₅ hS n _ rfl).δlast :=\n      homMk₄ ((homologyFunctorFactors C (up ℤ) _).hom.app _)\n        ((homologyFunctorFactors C (up ℤ) _).hom.app _)\n        ((homologyFunctorFactors C (up ℤ) _).hom.app _ ≫\n          HomologicalComplex.homologyMap (descShortComplex S) n)\n        ((homologyFunctorFactors C (up ℤ) _).hom.app _)\n        ((homologyFunctorFactors C (up ℤ) _).hom.app _)\n        ((homologyFunctorFactors C (up ℤ) _).hom.naturality S.f)\n        (by\n          erw [(homologyFunctorFactors C (up ℤ) n).hom.naturality_assoc]\n          dsimp\n          rw [← HomologicalComplex.homologyMap_comp, inr_descShortComplex])\n        (by\n          dsimp\n          erw [homologySequenceδ_triangleh hS]\n          simp only [Functor.comp_obj, HomologicalComplex.homologyFunctor_obj, assoc,\n            Iso.inv_hom_id_app, comp_id])\n        ((homologyFunctorFactors C (up ℤ) _).hom.naturality S.f)\n    have : IsIso ((homologyFunctorFactors C (up ℤ) n).hom.app (mappingCone S.f) ≫\n        HomologicalComplex.homologyMap (descShortComplex S) n) := by\n      apply Abelian.isIso_of_epi_of_isIso_of_isIso_of_mono\n        ((homologyFunctor C (up ℤ) 0).homologySequenceComposableArrows₅_exact _\n          (mappingCone_triangleh_distinguished S.f) n _ rfl).δlast\n        (composableArrows₅_exact hS n _ rfl).δlast φ\n      all_goals dsimp [φ]; infer_instance\n    apply IsIso.of_isIso_comp_left ((homologyFunctorFactors C (up ℤ) n).hom.app (mappingCone S.f))\n\n"}
