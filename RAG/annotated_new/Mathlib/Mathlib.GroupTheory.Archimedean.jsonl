{"name":"Subgroup.cyclic_of_min","module":"Mathlib.GroupTheory.Archimedean","initialProofState":"G : Type u_1\ninst✝¹ : LinearOrderedCommGroup G\ninst✝ : MulArchimedean G\nH : Subgroup G\na : G\nha : IsLeast (setOf fun g => And (Membership.mem H g) (LT.lt 1 g)) a\n⊢ Eq H (Subgroup.closure (Singleton.singleton a))","decl":"/-- Given a subgroup `H` of a decidable linearly ordered mul-archimedean abelian group `G`, if there\nexists a minimal element `a` of `H ∩ G_{>1}` then `H` is generated by `a`. -/\n@[to_additive AddSubgroup.cyclic_of_min \"Given a subgroup `H` of a decidable linearly ordered\narchimedean abelian group `G`, if there exists a minimal element `a` of `H ∩ G_{>0}` then `H` is\ngenerated by `a`. \"]\ntheorem Subgroup.cyclic_of_min {H : Subgroup G} {a : G}\n    (ha : IsLeast { g : G | g ∈ H ∧ 1 < g } a) : H = closure {a} := by\n  obtain ⟨⟨a_in, a_pos⟩, a_min⟩ := ha\n  refine le_antisymm ?_ (H.closure_le.mpr <| by simp [a_in])\n  intro g g_in\n  obtain ⟨k, ⟨nonneg, lt⟩, _⟩ := existsUnique_zpow_near_of_one_lt a_pos g\n  have h_zero : g / (a ^ k) = 1 := by\n    by_contra h\n    have h : a ≤ g / (a ^ k) := by\n      refine a_min ⟨?_, ?_⟩\n      · exact Subgroup.div_mem H g_in (Subgroup.zpow_mem H a_in k)\n      · exact lt_of_le_of_ne (by simpa using nonneg) (Ne.symm h)\n    have h' : ¬a ≤ g / (a ^ k) := not_le.mpr (by simpa [zpow_add_one, div_lt_iff_lt_mul'] using lt)\n    contradiction\n  simp [div_eq_one.mp h_zero, mem_closure_singleton]\n\n"}
{"name":"AddSubgroup.cyclic_of_min","module":"Mathlib.GroupTheory.Archimedean","initialProofState":"G : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : Archimedean G\nH : AddSubgroup G\na : G\nha : IsLeast (setOf fun g => And (Membership.mem H g) (LT.lt 0 g)) a\n⊢ Eq H (AddSubgroup.closure (Singleton.singleton a))","decl":"/-- Given a subgroup `H` of a decidable linearly ordered mul-archimedean abelian group `G`, if there\nexists a minimal element `a` of `H ∩ G_{>1}` then `H` is generated by `a`. -/\n@[to_additive AddSubgroup.cyclic_of_min \"Given a subgroup `H` of a decidable linearly ordered\narchimedean abelian group `G`, if there exists a minimal element `a` of `H ∩ G_{>0}` then `H` is\ngenerated by `a`. \"]\ntheorem Subgroup.cyclic_of_min {H : Subgroup G} {a : G}\n    (ha : IsLeast { g : G | g ∈ H ∧ 1 < g } a) : H = closure {a} := by\n  obtain ⟨⟨a_in, a_pos⟩, a_min⟩ := ha\n  refine le_antisymm ?_ (H.closure_le.mpr <| by simp [a_in])\n  intro g g_in\n  obtain ⟨k, ⟨nonneg, lt⟩, _⟩ := existsUnique_zpow_near_of_one_lt a_pos g\n  have h_zero : g / (a ^ k) = 1 := by\n    by_contra h\n    have h : a ≤ g / (a ^ k) := by\n      refine a_min ⟨?_, ?_⟩\n      · exact Subgroup.div_mem H g_in (Subgroup.zpow_mem H a_in k)\n      · exact lt_of_le_of_ne (by simpa using nonneg) (Ne.symm h)\n    have h' : ¬a ≤ g / (a ^ k) := not_le.mpr (by simpa [zpow_add_one, div_lt_iff_lt_mul'] using lt)\n    contradiction\n  simp [div_eq_one.mp h_zero, mem_closure_singleton]\n\n"}
{"name":"AddSubgroup.exists_isLeast_pos","module":"Mathlib.GroupTheory.Archimedean","initialProofState":"G : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : Archimedean G\nH : AddSubgroup G\nhbot : Ne H Bot.bot\na : G\nh₀ : LT.lt 0 a\nhd : Disjoint (↑H) (Set.Ioo 0 a)\n⊢ Exists fun b => IsLeast (setOf fun g => And (Membership.mem H g) (LT.lt 0 g)) b","decl":"/-- If a nontrivial subgroup of a linear ordered commutative group is disjoint\nwith the interval `Set.Ioo 1 a` for some `1 < a`, then the set of elements greater than 1 of this\ngroup admits the least element. -/\n@[to_additive \"If a nontrivial additive subgroup of a linear ordered additive commutative group is\ndisjoint with the interval `Set.Ioo 0 a` for some positive `a`, then the set of positive elements of\nthis group admits the least element.\"]\ntheorem Subgroup.exists_isLeast_one_lt {H : Subgroup G} (hbot : H ≠ ⊥) {a : G} (h₀ : 1 < a)\n    (hd : Disjoint (H : Set G) (Ioo 1 a)) : ∃ b, IsLeast { g : G | g ∈ H ∧ 1 < g } b := by\n  -- todo: move to a lemma?\n  have hex : ∀ g > 1, ∃ n : ℕ, g ∈ Ioc (a ^ n) (a ^ (n + 1)) := fun g hg => by\n    rcases existsUnique_mul_zpow_mem_Ico h₀ 1 (g / a) with ⟨m, ⟨hm, hm'⟩, -⟩\n    simp only [one_mul, div_le_iff_le_mul, div_mul_cancel, ← zpow_add_one] at hm hm'\n    lift m to ℕ\n    · rw [← Int.lt_add_one_iff, ← zpow_lt_zpow_iff_right h₀, zpow_zero]\n      exact hg.trans_le hm\n    · simp only [← Nat.cast_succ, zpow_natCast] at hm hm'\n      exact ⟨m, hm', hm⟩\n  have : ∃ n : ℕ, Set.Nonempty (H ∩ Ioc (a ^ n) (a ^ (n + 1))) := by\n    rcases (bot_or_exists_ne_one H).resolve_left hbot with ⟨g, hgH, hg₀⟩\n    rcases hex |g|ₘ (one_lt_mabs.2 hg₀) with ⟨n, hn⟩\n    exact ⟨n, _, (@mabs_mem_iff (Subgroup G) G _ _).2 hgH, hn⟩\n  classical rcases Nat.findX this with ⟨n, ⟨x, hxH, hnx, hxn⟩, hmin⟩\n  by_contra hxmin\n  simp only [IsLeast, not_and, mem_setOf_eq, mem_lowerBounds, not_exists, not_forall,\n    not_le] at hxmin\n  rcases hxmin x ⟨hxH, (one_le_pow_of_one_le'  h₀.le _).trans_lt hnx⟩ with ⟨y, ⟨hyH, hy₀⟩, hxy⟩\n  rcases hex y hy₀ with ⟨m, hm⟩\n  cases' lt_or_le m n with hmn hnm\n  · exact hmin m hmn ⟨y, hyH, hm⟩\n  · refine disjoint_left.1 hd (div_mem hxH hyH) ⟨one_lt_div'.2 hxy, div_lt_iff_lt_mul'.2 ?_⟩\n    calc x ≤ a^ (n + 1) := hxn\n    _ ≤ a ^ (m + 1) := pow_le_pow_right' h₀.le (add_le_add_right hnm _)\n    _ = a ^ m * a := pow_succ _ _\n    _ < y * a := mul_lt_mul_right' hm.1 _\n\n"}
{"name":"Subgroup.exists_isLeast_one_lt","module":"Mathlib.GroupTheory.Archimedean","initialProofState":"G : Type u_1\ninst✝¹ : LinearOrderedCommGroup G\ninst✝ : MulArchimedean G\nH : Subgroup G\nhbot : Ne H Bot.bot\na : G\nh₀ : LT.lt 1 a\nhd : Disjoint (↑H) (Set.Ioo 1 a)\n⊢ Exists fun b => IsLeast (setOf fun g => And (Membership.mem H g) (LT.lt 1 g)) b","decl":"/-- If a nontrivial subgroup of a linear ordered commutative group is disjoint\nwith the interval `Set.Ioo 1 a` for some `1 < a`, then the set of elements greater than 1 of this\ngroup admits the least element. -/\n@[to_additive \"If a nontrivial additive subgroup of a linear ordered additive commutative group is\ndisjoint with the interval `Set.Ioo 0 a` for some positive `a`, then the set of positive elements of\nthis group admits the least element.\"]\ntheorem Subgroup.exists_isLeast_one_lt {H : Subgroup G} (hbot : H ≠ ⊥) {a : G} (h₀ : 1 < a)\n    (hd : Disjoint (H : Set G) (Ioo 1 a)) : ∃ b, IsLeast { g : G | g ∈ H ∧ 1 < g } b := by\n  -- todo: move to a lemma?\n  have hex : ∀ g > 1, ∃ n : ℕ, g ∈ Ioc (a ^ n) (a ^ (n + 1)) := fun g hg => by\n    rcases existsUnique_mul_zpow_mem_Ico h₀ 1 (g / a) with ⟨m, ⟨hm, hm'⟩, -⟩\n    simp only [one_mul, div_le_iff_le_mul, div_mul_cancel, ← zpow_add_one] at hm hm'\n    lift m to ℕ\n    · rw [← Int.lt_add_one_iff, ← zpow_lt_zpow_iff_right h₀, zpow_zero]\n      exact hg.trans_le hm\n    · simp only [← Nat.cast_succ, zpow_natCast] at hm hm'\n      exact ⟨m, hm', hm⟩\n  have : ∃ n : ℕ, Set.Nonempty (H ∩ Ioc (a ^ n) (a ^ (n + 1))) := by\n    rcases (bot_or_exists_ne_one H).resolve_left hbot with ⟨g, hgH, hg₀⟩\n    rcases hex |g|ₘ (one_lt_mabs.2 hg₀) with ⟨n, hn⟩\n    exact ⟨n, _, (@mabs_mem_iff (Subgroup G) G _ _).2 hgH, hn⟩\n  classical rcases Nat.findX this with ⟨n, ⟨x, hxH, hnx, hxn⟩, hmin⟩\n  by_contra hxmin\n  simp only [IsLeast, not_and, mem_setOf_eq, mem_lowerBounds, not_exists, not_forall,\n    not_le] at hxmin\n  rcases hxmin x ⟨hxH, (one_le_pow_of_one_le'  h₀.le _).trans_lt hnx⟩ with ⟨y, ⟨hyH, hy₀⟩, hxy⟩\n  rcases hex y hy₀ with ⟨m, hm⟩\n  cases' lt_or_le m n with hmn hnm\n  · exact hmin m hmn ⟨y, hyH, hm⟩\n  · refine disjoint_left.1 hd (div_mem hxH hyH) ⟨one_lt_div'.2 hxy, div_lt_iff_lt_mul'.2 ?_⟩\n    calc x ≤ a^ (n + 1) := hxn\n    _ ≤ a ^ (m + 1) := pow_le_pow_right' h₀.le (add_le_add_right hnm _)\n    _ = a ^ m * a := pow_succ _ _\n    _ < y * a := mul_lt_mul_right' hm.1 _\n\n"}
{"name":"Subgroup.cyclic_of_isolated_one","module":"Mathlib.GroupTheory.Archimedean","initialProofState":"G : Type u_1\ninst✝¹ : LinearOrderedCommGroup G\ninst✝ : MulArchimedean G\nH : Subgroup G\na : G\nh₀ : LT.lt 1 a\nhd : Disjoint (↑H) (Set.Ioo 1 a)\n⊢ Exists fun b => Eq H (Subgroup.closure (Singleton.singleton b))","decl":"/-- If a subgroup of a linear ordered commutative group is disjoint with the\ninterval `Set.Ioo 1 a` for some `1 < a`, then this is a cyclic subgroup. -/\n@[to_additive AddSubgroup.cyclic_of_isolated_zero \"If an additive subgroup of a linear ordered\nadditive commutative group is disjoint with the interval `Set.Ioo 0 a` for some positive `a`, then\nthis is a cyclic subgroup.\"]\ntheorem Subgroup.cyclic_of_isolated_one {H : Subgroup G} {a : G} (h₀ : 1 < a)\n    (hd : Disjoint (H : Set G) (Ioo 1 a)) : ∃ b, H = closure {b} := by\n  rcases eq_or_ne H ⊥ with rfl | hbot\n  · exact ⟨1, closure_singleton_one.symm⟩\n  · exact (exists_isLeast_one_lt hbot h₀ hd).imp fun _ => cyclic_of_min\n\n"}
{"name":"AddSubgroup.cyclic_of_isolated_zero","module":"Mathlib.GroupTheory.Archimedean","initialProofState":"G : Type u_1\ninst✝¹ : LinearOrderedAddCommGroup G\ninst✝ : Archimedean G\nH : AddSubgroup G\na : G\nh₀ : LT.lt 0 a\nhd : Disjoint (↑H) (Set.Ioo 0 a)\n⊢ Exists fun b => Eq H (AddSubgroup.closure (Singleton.singleton b))","decl":"/-- If a subgroup of a linear ordered commutative group is disjoint with the\ninterval `Set.Ioo 1 a` for some `1 < a`, then this is a cyclic subgroup. -/\n@[to_additive AddSubgroup.cyclic_of_isolated_zero \"If an additive subgroup of a linear ordered\nadditive commutative group is disjoint with the interval `Set.Ioo 0 a` for some positive `a`, then\nthis is a cyclic subgroup.\"]\ntheorem Subgroup.cyclic_of_isolated_one {H : Subgroup G} {a : G} (h₀ : 1 < a)\n    (hd : Disjoint (H : Set G) (Ioo 1 a)) : ∃ b, H = closure {b} := by\n  rcases eq_or_ne H ⊥ with rfl | hbot\n  · exact ⟨1, closure_singleton_one.symm⟩\n  · exact (exists_isLeast_one_lt hbot h₀ hd).imp fun _ => cyclic_of_min\n\n"}
{"name":"Int.subgroup_cyclic","module":"Mathlib.GroupTheory.Archimedean","initialProofState":"H : AddSubgroup Int\n⊢ Exists fun a => Eq H (AddSubgroup.closure (Singleton.singleton a))","decl":"/-- Every subgroup of `ℤ` is cyclic. -/\ntheorem Int.subgroup_cyclic (H : AddSubgroup ℤ) : ∃ a, H = AddSubgroup.closure {a} :=\n  have : Ioo (0 : ℤ) 1 = ∅ := eq_empty_of_forall_not_mem fun _ hm =>\n    hm.1.not_le (lt_add_one_iff.1 hm.2)\n  AddSubgroup.cyclic_of_isolated_zero one_pos <| by simp [this]\n"}
