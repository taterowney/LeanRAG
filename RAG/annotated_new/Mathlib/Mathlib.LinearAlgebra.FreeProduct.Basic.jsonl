{"name":"DirectSum.induction_lon","module":"Mathlib.LinearAlgebra.FreeProduct.Basic","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nι : Type u_2\ninst✝² : DecidableEq ι\nM : ι → Type u_3\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\nC : (DirectSum ι fun i => M i) → Prop\nx : DirectSum ι fun i => M i\nH_zero : C 0\nH_basic : ∀ (i : ι) (x : M i), C ((DirectSum.lof R ι M i) x)\nH_plus : ∀ (x y : DirectSum ι fun i => M i), C x → C y → C (HAdd.hAdd x y)\n⊢ C x","decl":"/--A variant of `DirectSum.induction_on` that uses `DirectSum.lof` instead of `.of`-/\ntheorem induction_lon {R : Type*} [Semiring R] {ι: Type*} [DecidableEq ι]\n    {M : ι → Type*} [(i: ι) → AddCommMonoid <| M i] [(i : ι) → Module R (M i)]\n    {C: (⨁ i, M i) → Prop} (x : ⨁ i, M i)\n    (H_zero : C 0)\n    (H_basic : ∀ i (x : M i), C (lof R ι M i x))\n    (H_plus : ∀ (x y : ⨁ i, M i), C x → C y → C (x + y)) : C x := by\n  induction x using DirectSum.induction_on with\n  | H_zero => exact H_zero\n  | H_basic => exact H_basic _ _\n  | H_plus x y hx hy => exact H_plus x y hx hy\n\n"}
{"name":"LinearAlgebra.FreeProduct.rel_id","module":"Mathlib.LinearAlgebra.FreeProduct.Basic","initialProofState":"I : Type u\ninst✝³ : DecidableEq I\nR : Type v\ninst✝² : CommSemiring R\nA : I → Type w\ninst✝¹ : (i : I) → Semiring (A i)\ninst✝ : (i : I) → Algebra R (A i)\ni : I\n⊢ LinearAlgebra.FreeProduct.rel R A ((TensorAlgebra.ι R) ((DirectSum.lof R I A i) 1)) 1","decl":"theorem rel_id (i : I) : rel R A (ι R <| lof R I A i 1) 1 := rel.id\n\n\n"}
{"name":"LinearAlgebra.FreeProduct.ι_apply","module":"Mathlib.LinearAlgebra.FreeProduct.Basic","initialProofState":"I : Type u\ninst✝³ : DecidableEq I\nR : Type v\ninst✝² : CommSemiring R\nA : I → Type w\ninst✝¹ : (i : I) → Semiring (A i)\ninst✝ : (i : I) → Algebra R (A i)\nx : DirectSum I fun i => A i\n⊢ Eq { toQuot := Quot.mk (RingQuot.Rel (LinearAlgebra.FreeProduct.rel R A)) ((TensorAlgebra.ι R) x) } ((LinearAlgebra.FreeProduct.ι' R A) x)","decl":"@[simp] theorem ι_apply (x : ⨁ i, A i) :\n  ⟨Quot.mk (Rel <| rel R A) (TensorAlgebra.ι R x)⟩ = ι' R A x := by\n    aesop (add simp [ι', mkAlgHom, RingQuot.mkAlgHom, mkRingHom])\n\n"}
{"name":"LinearAlgebra.FreeProduct.identify_one","module":"Mathlib.LinearAlgebra.FreeProduct.Basic","initialProofState":"I : Type u\ninst✝³ : DecidableEq I\nR : Type v\ninst✝² : CommSemiring R\nA : I → Type w\ninst✝¹ : (i : I) → Semiring (A i)\ninst✝ : (i : I) → Algebra R (A i)\ni : I\n⊢ Eq ((LinearAlgebra.FreeProduct.ι' R A) ((DirectSum.lof R I A i) 1)) 1","decl":"/--The injection into the free product of any `1 : A i` is the 1 of the free product.-/\ntheorem identify_one (i : I) : ι' R A (DirectSum.lof R I A i 1) = 1 := by\n  suffices ι' R A (DirectSum.lof R I A i 1) = mkAlgHom R A 1 by simpa\n  exact RingQuot.mkAlgHom_rel R <| rel_id R A (i := i)\n\n"}
{"name":"LinearAlgebra.FreeProduct.mul_injections","module":"Mathlib.LinearAlgebra.FreeProduct.Basic","initialProofState":"I : Type u\ninst✝³ : DecidableEq I\ni : I\nR : Type v\ninst✝² : CommSemiring R\nA : I → Type w\ninst✝¹ : (i : I) → Semiring (A i)\ninst✝ : (i : I) → Algebra R (A i)\na₁ a₂ : A i\n⊢ Eq (HMul.hMul ((LinearAlgebra.FreeProduct.ι' R A) ((DirectSum.lof R I A i) a₁)) ((LinearAlgebra.FreeProduct.ι' R A) ((DirectSum.lof R I A i) a₂))) ((LinearAlgebra.FreeProduct.ι' R A) ((DirectSum.lof R I A i) (HMul.hMul a₁ a₂)))","decl":"/--Multiplication in the free product of the injections of any two `aᵢ aᵢ': A i` for\nthe same `i` is just the injection of multiplication `aᵢ * aᵢ'` in `A i`.-/\ntheorem mul_injections (a₁ a₂ : A i) :\n    ι' R A (DirectSum.lof R I A i a₁) * ι' R A (DirectSum.lof R I A i a₂)\n      = ι' R A (DirectSum.lof R I A i (a₁ * a₂)) := by\n  convert RingQuot.mkAlgHom_rel R <| rel.prod\n  simp\n\n"}
{"name":"LinearAlgebra.FreeProduct.lof_map_one","module":"Mathlib.LinearAlgebra.FreeProduct.Basic","initialProofState":"I : Type u\ninst✝³ : DecidableEq I\nR : Type v\ninst✝² : CommSemiring R\nA : I → Type w\ninst✝¹ : (i : I) → Semiring (A i)\ninst✝ : (i : I) → Algebra R (A i)\ni : I\n⊢ Eq ((LinearAlgebra.FreeProduct.lof R A i) 1) 1","decl":"/--`lof R A i 1 = 1` for all `i`.-/\ntheorem lof_map_one (i : I) : lof R A i 1 = 1 := by\n  rw [lof]; dsimp [mkAlgHom]; exact identify_one R A i\n\n"}
{"name":"LinearAlgebra.FreeProduct.ι_def","module":"Mathlib.LinearAlgebra.FreeProduct.Basic","initialProofState":"I : Type u_1\ninst✝³ : DecidableEq I\nR : Type u_2\ninst✝² : CommSemiring R\nA : I → Type u_3\ninst✝¹ : (i : I) → Semiring (A i)\ninst✝ : (i : I) → Algebra R (A i)\ni : I\n⊢ Eq (LinearAlgebra.FreeProduct.ι R A i) (AlgHom.ofLinearMap ((LinearAlgebra.FreeProduct.ι' R A).comp (DirectSum.lof R I A i)) ⋯ ⋯)","decl":"/--The `i`th canonical injection, from `A i` to the free product.-/\nirreducible_def ι (i : I) : A i →ₐ[R] FreeProduct R A :=\n  AlgHom.ofLinearMap (ι' R A ∘ₗ DirectSum.lof R I A i)\n    (lof_map_one R A i) (mul_injections R A · · |>.symm)\n\n"}
{"name":"LinearAlgebra.FreeProduct.of_def","module":"Mathlib.LinearAlgebra.FreeProduct.Basic","initialProofState":"I : Type u_1\ninst✝³ : DecidableEq I\nR : Type u_2\ninst✝² : CommSemiring R\nA : I → Type u_3\ninst✝¹ : (i : I) → Semiring (A i)\ninst✝ : (i : I) → Algebra R (A i)\ni : I\n⊢ Eq (LinearAlgebra.FreeProduct.of R A) (LinearAlgebra.FreeProduct.ι R A i)","decl":"/--The family of canonical injection maps, with `i` left implicit.-/\nirreducible_def of {i : I} : A i →ₐ[R] FreeProduct R A := ι R A i\n\n\n"}
{"name":"LinearAlgebra.FreeProduct.lift_symm_apply","module":"Mathlib.LinearAlgebra.FreeProduct.Basic","initialProofState":"I : Type u\ninst✝⁵ : DecidableEq I\nR : Type v\ninst✝⁴ : CommSemiring R\nA : I → Type w\ninst✝³ : (i : I) → Semiring (A i)\ninst✝² : (i : I) → Algebra R (A i)\nB : Type w'\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\nπ : AlgHom R (LinearAlgebra.FreeProduct R A) B\ni : I\n⊢ Eq ((LinearAlgebra.FreeProduct.lift R A).symm π) (π.comp (LinearAlgebra.FreeProduct.ι R A i))","decl":"/--Universal property of the free product of algebras:\nfor every `R`-algebra `B`, every family of maps `maps : (i : I) → (A i →ₐ[R] B)` lifts\nto a unique arrow `π` from `FreeProduct R A` such that  `π ∘ ι i = maps i`.-/\n@[simps] def lift : ({i : I} → A i →ₐ[R] B) ≃ (FreeProduct R A →ₐ[R] B) where\n  toFun maps :=\n    RingQuot.liftAlgHom R ⟨\n        TensorAlgebra.lift R <|\n          DirectSum.toModule R I B <|\n            (@maps · |>.toLinearMap),\n        fun x y r ↦ by\n          cases r with\n          | id => simp\n          | prod => simp⟩\n  invFun π i := π ∘ₐ ι R A i\n  left_inv π := by\n    ext i aᵢ\n    aesop (add simp [ι, ι'])\n  right_inv maps := by\n    ext i a\n    aesop (add simp [ι, ι'])\n\n"}
{"name":"LinearAlgebra.FreeProduct.lift_apply","module":"Mathlib.LinearAlgebra.FreeProduct.Basic","initialProofState":"I : Type u\ninst✝⁵ : DecidableEq I\nR : Type v\ninst✝⁴ : CommSemiring R\nA : I → Type w\ninst✝³ : (i : I) → Semiring (A i)\ninst✝² : (i : I) → Algebra R (A i)\nB : Type w'\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\nmaps : {i : I} → AlgHom R (A i) B\n⊢ Eq ((LinearAlgebra.FreeProduct.lift R A) maps) ((RingQuot.liftAlgHom R) ⟨(TensorAlgebra.lift R) (DirectSum.toModule R I B fun x => maps.toLinearMap), ⋯⟩)","decl":"/--Universal property of the free product of algebras:\nfor every `R`-algebra `B`, every family of maps `maps : (i : I) → (A i →ₐ[R] B)` lifts\nto a unique arrow `π` from `FreeProduct R A` such that  `π ∘ ι i = maps i`.-/\n@[simps] def lift : ({i : I} → A i →ₐ[R] B) ≃ (FreeProduct R A →ₐ[R] B) where\n  toFun maps :=\n    RingQuot.liftAlgHom R ⟨\n        TensorAlgebra.lift R <|\n          DirectSum.toModule R I B <|\n            (@maps · |>.toLinearMap),\n        fun x y r ↦ by\n          cases r with\n          | id => simp\n          | prod => simp⟩\n  invFun π i := π ∘ₐ ι R A i\n  left_inv π := by\n    ext i aᵢ\n    aesop (add simp [ι, ι'])\n  right_inv maps := by\n    ext i a\n    aesop (add simp [ι, ι'])\n\n"}
{"name":"LinearAlgebra.FreeProduct.lift_comp_ι","module":"Mathlib.LinearAlgebra.FreeProduct.Basic","initialProofState":"I : Type u\ninst✝⁵ : DecidableEq I\ni : I\nR : Type v\ninst✝⁴ : CommSemiring R\nA : I → Type w\ninst✝³ : (i : I) → Semiring (A i)\ninst✝² : (i : I) → Algebra R (A i)\nB : Type w'\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\nmaps : {i : I} → AlgHom R (A i) B\n⊢ Eq (((LinearAlgebra.FreeProduct.lift R A) fun {i} => maps).comp (LinearAlgebra.FreeProduct.ι R A i)) maps","decl":"/--Universal property of the free product of algebras, property:\nfor every `R`-algebra `B`, every family of maps `maps : (i : I) → (A i →ₐ[R] B)` lifts\nto a unique arrow `π` from `FreeProduct R A` such that  `π ∘ ι i = maps i`.-/\ntheorem lift_comp_ι : (lift R A maps) ∘ₐ (ι R A i) = maps := by\n  ext a\n  simp [lift_apply, ι]\n\n"}
{"name":"LinearAlgebra.FreeProduct.lift_unique","module":"Mathlib.LinearAlgebra.FreeProduct.Basic","initialProofState":"I : Type u\ninst✝⁵ : DecidableEq I\nR : Type v\ninst✝⁴ : CommSemiring R\nA : I → Type w\ninst✝³ : (i : I) → Semiring (A i)\ninst✝² : (i : I) → Algebra R (A i)\nB : Type w'\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\nmaps : {i : I} → AlgHom R (A i) B\nf : AlgHom R (LinearAlgebra.FreeProduct R A) B\nh : ∀ (i : I), Eq (f.comp (LinearAlgebra.FreeProduct.ι R A i)) maps\n⊢ Eq f ((LinearAlgebra.FreeProduct.lift R A) fun {i} => maps)","decl":"@[aesop safe destruct] theorem lift_unique\n    (f : FreeProduct R A →ₐ[R] B) (h : ∀ i, f ∘ₐ ι R A i = maps) :\n    f = lift R A maps := by\n  ext i a; simp_rw [AlgHom.ext_iff] at h; specialize h i a\n  simp [h.symm, ι]\n\n"}
