{"name":"StarOrderedRing.le_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝² : NonUnitalSemiring R\ninst✝¹ : PartialOrder R\ninst✝ : StarRing R\nself : StarOrderedRing R\nx y : R\n⊢ Iff (LE.le x y) (Exists fun p => And (Membership.mem (AddSubmonoid.closure (Set.range fun s => HMul.hMul (Star.star s) s)) p) (Eq y (HAdd.hAdd x p)))","decl":"/-- An ordered `*`-ring is a `*`ring with a partial order such that the nonnegative elements\nconstitute precisely the `AddSubmonoid` generated by elements of the form `star s * s`.\n\nIf you are working with a `NonUnitalRing` and not a `NonUnitalSemiring`, it may be more\nconvenient to declare instances using `StarOrderedRing.of_nonneg_iff`.\n\nPorting note: dropped an unneeded assumption\n`add_le_add_left : ∀ {x y}, x ≤ y → ∀ z, z + x ≤ z + y` -/\nclass StarOrderedRing (R : Type u) [NonUnitalSemiring R] [PartialOrder R]\n    [StarRing R] : Prop where\n  /-- characterization of the order in terms of the `StarRing` structure. -/\n  le_iff :\n    ∀ x y : R, x ≤ y ↔ ∃ p, p ∈ AddSubmonoid.closure (Set.range fun s => star s * s) ∧ y = x + p\n\n"}
{"name":"StarOrderedRing.toExistsAddOfLE","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\n⊢ ExistsAddOfLE R","decl":"instance (priority := 100) toExistsAddOfLE [NonUnitalSemiring R] [PartialOrder R]\n    [StarRing R] [StarOrderedRing R] : ExistsAddOfLE R where\n  exists_add_of_le h :=\n    match (le_iff _ _).mp h with\n    | ⟨p, _, hp⟩ => ⟨p, hp⟩\n\n-- see note [lower instance priority]\n"}
{"name":"StarOrderedRing.of_le_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝² : NonUnitalSemiring R\ninst✝¹ : PartialOrder R\ninst✝ : StarRing R\nh_le_iff : ∀ (x y : R), Iff (LE.le x y) (Exists fun s => Eq y (HAdd.hAdd x (HMul.hMul (Star.star s) s)))\n⊢ StarOrderedRing R","decl":"/-- To construct a `StarOrderedRing` instance it suffices to show that `x ≤ y` if and only if\n`y = x + star s * s` for some `s : R`.\n\nThis is provided for convenience because it holds in some common scenarios (e.g.,`ℝ≥0`, `C(X, ℝ≥0)`)\nand obviates the hassle of `AddSubmonoid.closure_induction` when creating those instances.\n\nIf you are working with a `NonUnitalRing` and not a `NonUnitalSemiring`, see\n`StarOrderedRing.of_nonneg_iff` for a more convenient version.\n -/\nlemma of_le_iff [NonUnitalSemiring R] [PartialOrder R] [StarRing R]\n    (h_le_iff : ∀ x y : R, x ≤ y ↔ ∃ s, y = x + star s * s) : StarOrderedRing R where\n  le_iff x y := by\n    refine ⟨fun h => ?_, ?_⟩\n    · obtain ⟨p, hp⟩ := (h_le_iff x y).mp h\n      exact ⟨star p * p, AddSubmonoid.subset_closure ⟨p, rfl⟩, hp⟩\n    · rintro ⟨p, hp, hpxy⟩\n      revert x y hpxy\n      refine AddSubmonoid.closure_induction ?_ (fun x y h => add_zero x ▸ h.ge) ?_ hp\n      · rintro _ ⟨s, rfl⟩ x y rfl\n        exact (h_le_iff _ _).mpr ⟨s, rfl⟩\n      · rintro _ _ _ _ ha hb x y rfl\n        rw [← add_assoc]\n        exact (ha _ _ rfl).trans (hb _ _ rfl)\n\n"}
{"name":"StarOrderedRing.of_nonneg_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝² : NonUnitalRing R\ninst✝¹ : PartialOrder R\ninst✝ : StarRing R\nh_add : ∀ {x y : R}, LE.le x y → ∀ (z : R), LE.le (HAdd.hAdd z x) (HAdd.hAdd z y)\nh_nonneg_iff : ∀ (x : R), Iff (LE.le 0 x) (Membership.mem (AddSubmonoid.closure (Set.range fun s => HMul.hMul (Star.star s) s)) x)\n⊢ StarOrderedRing R","decl":"/-- When `R` is a non-unital ring, to construct a `StarOrderedRing` instance it suffices to\nshow that the nonnegative elements are precisely those elements in the `AddSubmonoid` generated\nby `star s * s` for `s : R`. -/\nlemma of_nonneg_iff [NonUnitalRing R] [PartialOrder R] [StarRing R]\n    (h_add : ∀ {x y : R}, x ≤ y → ∀ z, z + x ≤ z + y)\n    (h_nonneg_iff : ∀ x : R, 0 ≤ x ↔ x ∈ AddSubmonoid.closure (Set.range fun s : R => star s * s)) :\n    StarOrderedRing R where\n  le_iff x y := by\n    have : AddLeftMono R := ⟨fun _ _ _ h => h_add h _⟩\n    simpa only [← sub_eq_iff_eq_add', sub_nonneg, exists_eq_right'] using h_nonneg_iff (y - x)\n\n"}
{"name":"StarOrderedRing.of_nonneg_iff'","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝² : NonUnitalRing R\ninst✝¹ : PartialOrder R\ninst✝ : StarRing R\nh_add : ∀ {x y : R}, LE.le x y → ∀ (z : R), LE.le (HAdd.hAdd z x) (HAdd.hAdd z y)\nh_nonneg_iff : ∀ (x : R), Iff (LE.le 0 x) (Exists fun s => Eq x (HMul.hMul (Star.star s) s))\n⊢ StarOrderedRing R","decl":"/-- When `R` is a non-unital ring, to construct a `StarOrderedRing` instance it suffices to\nshow that the nonnegative elements are precisely those elements of the form `star s * s`\nfor `s : R`.\n\nThis is provided for convenience because it holds in many common scenarios (e.g.,`ℝ`, `ℂ`, or\nany C⋆-algebra), and obviates the hassle of `AddSubmonoid.closure_induction` when creating those\ninstances. -/\nlemma of_nonneg_iff' [NonUnitalRing R] [PartialOrder R] [StarRing R]\n    (h_add : ∀ {x y : R}, x ≤ y → ∀ z, z + x ≤ z + y)\n    (h_nonneg_iff : ∀ x : R, 0 ≤ x ↔ ∃ s, x = star s * s) : StarOrderedRing R :=\n  of_le_iff <| by\n    have : AddLeftMono R := ⟨fun _ _ _ h => h_add h _⟩\n    simpa [sub_eq_iff_eq_add', sub_nonneg] using fun x y => h_nonneg_iff (y - x)\n\n"}
{"name":"StarOrderedRing.nonneg_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx : R\n⊢ Iff (LE.le 0 x) (Membership.mem (AddSubmonoid.closure (Set.range fun s => HMul.hMul (Star.star s) s)) x)","decl":"theorem nonneg_iff [NonUnitalSemiring R] [PartialOrder R] [StarRing R] [StarOrderedRing R] {x : R} :\n    0 ≤ x ↔ x ∈ AddSubmonoid.closure (Set.range fun s : R => star s * s) := by\n  simp only [le_iff, zero_add, exists_eq_right']\n\n"}
{"name":"IsSelfAdjoint.mono","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx y : R\nh : LE.le x y\nhx : IsSelfAdjoint x\n⊢ IsSelfAdjoint y","decl":"lemma IsSelfAdjoint.mono {x y : R} (h : x ≤ y) (hx : IsSelfAdjoint x) : IsSelfAdjoint y := by\n  rw [StarOrderedRing.le_iff] at h\n  obtain ⟨d, hd, rfl⟩ := h\n  rw [IsSelfAdjoint, star_add, hx.star_eq]\n  congr\n  refine AddMonoidHom.eqOn_closureM (f := starAddEquiv (R := R)) (g := .id R) ?_ hd\n  rintro - ⟨s, rfl⟩\n  simp\n\n"}
{"name":"IsSelfAdjoint.of_nonneg","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx : R\nhx : LE.le 0 x\n⊢ IsSelfAdjoint x","decl":"@[aesop 10% apply]\nlemma IsSelfAdjoint.of_nonneg {x : R} (hx : 0 ≤ x) : IsSelfAdjoint x :=\n  .mono hx <| .zero R\n\n"}
{"name":"LE.le.isSelfAdjoint","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx : R\nhx : LE.le 0 x\n⊢ IsSelfAdjoint x","decl":"/-- An alias of `IsSelfAdjoint.of_nonneg` for use with dot notation. -/\nalias LE.le.isSelfAdjoint := IsSelfAdjoint.of_nonneg\n\n"}
{"name":"LE.le.star_eq","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx : R\nhx : LE.le 0 x\n⊢ Eq (Star.star x) x","decl":"/-- The combination `(IsSelfAdjoint.star_eq <| .of_nonneg ·)` for use with dot notation. -/\nlemma LE.le.star_eq {x : R} (hx : 0 ≤ x) : star x = x :=\n  hx.isSelfAdjoint.star_eq\n\n"}
{"name":"star_mul_self_nonneg","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nr : R\n⊢ LE.le 0 (HMul.hMul (Star.star r) r)","decl":"@[simp]\ntheorem star_mul_self_nonneg (r : R) : 0 ≤ star r * r :=\n  StarOrderedRing.nonneg_iff.mpr <| AddSubmonoid.subset_closure ⟨r, rfl⟩\n\n"}
{"name":"mul_star_self_nonneg","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nr : R\n⊢ LE.le 0 (HMul.hMul r (Star.star r))","decl":"@[simp]\ntheorem mul_star_self_nonneg (r : R) : 0 ≤ r * star r := by\n  simpa only [star_star] using star_mul_self_nonneg (star r)\n\n"}
{"name":"IsSelfAdjoint.mul_self_nonneg","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na : R\nha : IsSelfAdjoint a\n⊢ LE.le 0 (HMul.hMul a a)","decl":"@[aesop safe apply (rule_sets := [CStarAlgebra])]\nprotected theorem IsSelfAdjoint.mul_self_nonneg {a : R} (ha : IsSelfAdjoint a) : 0 ≤ a * a := by\n  simpa [ha.star_eq] using star_mul_self_nonneg a\n\n"}
{"name":"conjugate_nonneg","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na : R\nha : LE.le 0 a\nc : R\n⊢ LE.le 0 (HMul.hMul (HMul.hMul (Star.star c) a) c)","decl":"@[aesop safe apply]\ntheorem conjugate_nonneg {a : R} (ha : 0 ≤ a) (c : R) : 0 ≤ star c * a * c := by\n  rw [StarOrderedRing.nonneg_iff] at ha\n  refine AddSubmonoid.closure_induction (fun x hx => ?_)\n    (by rw [mul_zero, zero_mul]) (fun x y _ _ hx hy => ?_) ha\n  · obtain ⟨x, rfl⟩ := hx\n    convert star_mul_self_nonneg (x * c) using 1\n    rw [star_mul, ← mul_assoc, mul_assoc _ _ c]\n  · calc\n      0 ≤ star c * x * c + 0 := by rw [add_zero]; exact hx\n      _ ≤ star c * x * c + star c * y * c := add_le_add_left hy _\n      _ ≤ _ := by rw [mul_add, add_mul]\n\n"}
{"name":"conjugate_nonneg'","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na : R\nha : LE.le 0 a\nc : R\n⊢ LE.le 0 (HMul.hMul (HMul.hMul c a) (Star.star c))","decl":"@[aesop safe apply]\ntheorem conjugate_nonneg' {a : R} (ha : 0 ≤ a) (c : R) : 0 ≤ c * a * star c := by\n  simpa only [star_star] using conjugate_nonneg ha (star c)\n\n"}
{"name":"IsSelfAdjoint.conjugate_nonneg","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na : R\nha : LE.le 0 a\nc : R\nhc : IsSelfAdjoint c\n⊢ LE.le 0 (HMul.hMul (HMul.hMul c a) c)","decl":"@[aesop 90% apply (rule_sets := [CStarAlgebra])]\nprotected theorem IsSelfAdjoint.conjugate_nonneg {a : R} (ha : 0 ≤ a) {c : R}\n    (hc : IsSelfAdjoint c) : 0 ≤ c * a * c := by\n  nth_rewrite 2 [← hc]; exact conjugate_nonneg' ha c\n\n"}
{"name":"conjugate_nonneg_of_nonneg","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na : R\nha : LE.le 0 a\nc : R\nhc : LE.le 0 c\n⊢ LE.le 0 (HMul.hMul (HMul.hMul c a) c)","decl":"theorem conjugate_nonneg_of_nonneg {a : R} (ha : 0 ≤ a) {c : R} (hc : 0 ≤ c) :\n    0 ≤ c * a * c :=\n  IsSelfAdjoint.of_nonneg hc |>.conjugate_nonneg ha\n\n"}
{"name":"conjugate_le_conjugate","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na b : R\nhab : LE.le a b\nc : R\n⊢ LE.le (HMul.hMul (HMul.hMul (Star.star c) a) c) (HMul.hMul (HMul.hMul (Star.star c) b) c)","decl":"theorem conjugate_le_conjugate {a b : R} (hab : a ≤ b) (c : R) :\n    star c * a * c ≤ star c * b * c := by\n  rw [StarOrderedRing.le_iff] at hab ⊢\n  obtain ⟨p, hp, rfl⟩ := hab\n  simp_rw [← StarOrderedRing.nonneg_iff] at hp ⊢\n  exact ⟨star c * p * c, conjugate_nonneg hp c, by simp only [add_mul, mul_add]⟩\n\n"}
{"name":"conjugate_le_conjugate'","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na b : R\nhab : LE.le a b\nc : R\n⊢ LE.le (HMul.hMul (HMul.hMul c a) (Star.star c)) (HMul.hMul (HMul.hMul c b) (Star.star c))","decl":"theorem conjugate_le_conjugate' {a b : R} (hab : a ≤ b) (c : R) :\n    c * a * star c ≤ c * b * star c := by\n  simpa only [star_star] using conjugate_le_conjugate hab (star c)\n\n"}
{"name":"IsSelfAdjoint.conjugate_le_conjugate","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na b : R\nhab : LE.le a b\nc : R\nhc : IsSelfAdjoint c\n⊢ LE.le (HMul.hMul (HMul.hMul c a) c) (HMul.hMul (HMul.hMul c b) c)","decl":"protected theorem IsSelfAdjoint.conjugate_le_conjugate {a b : R} (hab : a ≤ b) {c : R}\n    (hc : IsSelfAdjoint c) : c * a * c ≤ c * b * c := by\n  simpa only [hc.star_eq] using conjugate_le_conjugate hab c\n\n"}
{"name":"conjugate_le_conjugate_of_nonneg","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na b : R\nhab : LE.le a b\nc : R\nhc : LE.le 0 c\n⊢ LE.le (HMul.hMul (HMul.hMul c a) c) (HMul.hMul (HMul.hMul c b) c)","decl":"theorem conjugate_le_conjugate_of_nonneg {a b : R} (hab : a ≤ b) {c : R} (hc : 0 ≤ c) :\n    c * a * c ≤ c * b * c :=\n  IsSelfAdjoint.of_nonneg hc |>.conjugate_le_conjugate hab\n\n"}
{"name":"star_le_star_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx y : R\n⊢ Iff (LE.le (Star.star x) (Star.star y)) (LE.le x y)","decl":"@[simp]\nlemma star_le_star_iff {x y : R} : star x ≤ star y ↔ x ≤ y := by\n  suffices ∀ x y, x ≤ y → star x ≤ star y from\n    ⟨by simpa only [star_star] using this (star x) (star y), this x y⟩\n  intro x y h\n  rw [StarOrderedRing.le_iff] at h ⊢\n  obtain ⟨d, hd, rfl⟩ := h\n  refine ⟨starAddEquiv d, ?_, star_add _ _⟩\n  refine AddMonoidHom.mclosure_preimage_le _ _ <| AddSubmonoid.closure_mono ?_ hd\n  rintro - ⟨s, rfl⟩\n  exact ⟨s, by simp⟩\n\n"}
{"name":"star_lt_star_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx y : R\n⊢ Iff (LT.lt (Star.star x) (Star.star y)) (LT.lt x y)","decl":"@[simp]\nlemma star_lt_star_iff {x y : R} : star x < star y ↔ x < y := by\n  by_cases h : x = y\n  · simp [h]\n  · simpa [le_iff_lt_or_eq, h] using star_le_star_iff (x := x) (y := y)\n\n"}
{"name":"star_le_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx y : R\n⊢ Iff (LE.le (Star.star x) y) (LE.le x (Star.star y))","decl":"lemma star_le_iff {x y : R} : star x ≤ y ↔ x ≤ star y := by rw [← star_le_star_iff, star_star]\n\n"}
{"name":"star_lt_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx y : R\n⊢ Iff (LT.lt (Star.star x) y) (LT.lt x (Star.star y))","decl":"lemma star_lt_iff {x y : R} : star x < y ↔ x < star y := by rw [← star_lt_star_iff, star_star]\n\n"}
{"name":"star_nonneg_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx : R\n⊢ Iff (LE.le 0 (Star.star x)) (LE.le 0 x)","decl":"@[simp]\nlemma star_nonneg_iff {x : R} : 0 ≤ star x ↔ 0 ≤ x := by\n  simpa using star_le_star_iff (x := 0) (y := x)\n\n"}
{"name":"star_nonpos_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx : R\n⊢ Iff (LE.le (Star.star x) 0) (LE.le x 0)","decl":"@[simp]\nlemma star_nonpos_iff {x : R} : star x ≤ 0 ↔ x ≤ 0 := by\n  simpa using star_le_star_iff (x := x) (y := 0)\n\n"}
{"name":"star_pos_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx : R\n⊢ Iff (LT.lt 0 (Star.star x)) (LT.lt 0 x)","decl":"@[simp]\nlemma star_pos_iff {x : R} : 0 < star x ↔ 0 < x := by\n  simpa using star_lt_star_iff (x := 0) (y := x)\n\n"}
{"name":"star_neg_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx : R\n⊢ Iff (LT.lt (Star.star x) 0) (LT.lt x 0)","decl":"@[simp]\nlemma star_neg_iff {x : R} : star x < 0 ↔ x < 0 := by\n  simpa using star_lt_star_iff (x := x) (y := 0)\n\n"}
{"name":"conjugate_lt_conjugate","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na b : R\nhab : LT.lt a b\nc : R\nhc : IsRegular c\n⊢ LT.lt (HMul.hMul (HMul.hMul (Star.star c) a) c) (HMul.hMul (HMul.hMul (Star.star c) b) c)","decl":"theorem conjugate_lt_conjugate {a b : R} (hab : a < b) {c : R} (hc : IsRegular c) :\n    star c * a * c < star c * b * c := by\n  rw [(conjugate_le_conjugate hab.le _).lt_iff_ne, hc.right.ne_iff, hc.star.left.ne_iff]\n  exact hab.ne\n\n"}
{"name":"conjugate_lt_conjugate'","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na b : R\nhab : LT.lt a b\nc : R\nhc : IsRegular c\n⊢ LT.lt (HMul.hMul (HMul.hMul c a) (Star.star c)) (HMul.hMul (HMul.hMul c b) (Star.star c))","decl":"theorem conjugate_lt_conjugate' {a b : R} (hab : a < b) {c : R} (hc : IsRegular c) :\n    c * a * star c < c * b * star c := by\n  simpa only [star_star] using conjugate_lt_conjugate hab hc.star\n\n"}
{"name":"conjugate_pos","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na : R\nha : LT.lt 0 a\nc : R\nhc : IsRegular c\n⊢ LT.lt 0 (HMul.hMul (HMul.hMul (Star.star c) a) c)","decl":"theorem conjugate_pos {a : R} (ha : 0 < a) {c : R} (hc : IsRegular c) : 0 < star c * a * c := by\n  simpa only [mul_zero, zero_mul] using conjugate_lt_conjugate ha hc\n\n"}
{"name":"conjugate_pos'","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : NonUnitalSemiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na : R\nha : LT.lt 0 a\nc : R\nhc : IsRegular c\n⊢ LT.lt 0 (HMul.hMul (HMul.hMul c a) (Star.star c))","decl":"theorem conjugate_pos' {a : R} (ha : 0 < a) {c : R} (hc : IsRegular c) : 0 < c * a * star c := by\n  simpa only [star_star] using conjugate_pos ha hc.star\n\n"}
{"name":"star_mul_self_pos","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝⁴ : NonUnitalSemiring R\ninst✝³ : PartialOrder R\ninst✝² : StarRing R\ninst✝¹ : StarOrderedRing R\ninst✝ : Nontrivial R\nx : R\nhx : IsRegular x\n⊢ LT.lt 0 (HMul.hMul (Star.star x) x)","decl":"theorem star_mul_self_pos [Nontrivial R] {x : R} (hx : IsRegular x) : 0 < star x * x := by\n  rw [(star_mul_self_nonneg _).lt_iff_ne, ← mul_zero (star x), hx.star.left.ne_iff]\n  exact hx.ne_zero.symm\n\n"}
{"name":"mul_star_self_pos","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝⁴ : NonUnitalSemiring R\ninst✝³ : PartialOrder R\ninst✝² : StarRing R\ninst✝¹ : StarOrderedRing R\ninst✝ : Nontrivial R\nx : R\nhx : IsRegular x\n⊢ LT.lt 0 (HMul.hMul x (Star.star x))","decl":"theorem mul_star_self_pos [Nontrivial R] {x : R} (hx : IsRegular x) : 0 < x * star x := by\n  simpa using star_mul_self_pos hx.star\n\n"}
{"name":"instZeroLEOneClass","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : PartialOrder R\n⊢ ZeroLEOneClass R","decl":"instance : ZeroLEOneClass R where\n  zero_le_one := by simpa using star_mul_self_nonneg (1 : R)\n\n"}
{"name":"one_le_star_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : Semiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx : R\n⊢ Iff (LE.le 1 (Star.star x)) (LE.le 1 x)","decl":"@[simp]\nlemma one_le_star_iff {x : R} : 1 ≤ star x ↔ 1 ≤ x := by\n  simpa using star_le_star_iff (x := 1) (y := x)\n\n"}
{"name":"star_le_one_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : Semiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx : R\n⊢ Iff (LE.le (Star.star x) 1) (LE.le x 1)","decl":"@[simp]\nlemma star_le_one_iff {x : R} : star x ≤ 1 ↔ x ≤ 1 := by\n  simpa using star_le_star_iff (x := x) (y := 1)\n\n"}
{"name":"one_lt_star_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : Semiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx : R\n⊢ Iff (LT.lt 1 (Star.star x)) (LT.lt 1 x)","decl":"@[simp]\nlemma one_lt_star_iff {x : R} : 1 < star x ↔ 1 < x := by\n  simpa using star_lt_star_iff (x := 1) (y := x)\n\n"}
{"name":"star_lt_one_iff","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : Semiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\nx : R\n⊢ Iff (LT.lt (Star.star x) 1) (LT.lt x 1)","decl":"@[simp]\nlemma star_lt_one_iff {x : R} : star x < 1 ↔ x < 1 := by\n  simpa using star_lt_star_iff (x := x) (y := 1)\n\n"}
{"name":"IsSelfAdjoint.sq_nonneg","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\ninst✝³ : Semiring R\ninst✝² : PartialOrder R\ninst✝¹ : StarRing R\ninst✝ : StarOrderedRing R\na : R\nha : IsSelfAdjoint a\n⊢ LE.le 0 (HPow.hPow a 2)","decl":"@[aesop safe apply (rule_sets := [CStarAlgebra])]\nprotected theorem IsSelfAdjoint.sq_nonneg {a : R} (ha : IsSelfAdjoint a) : 0 ≤ a ^ 2 := by\n  simp [sq, ha.mul_self_nonneg]\n\n"}
{"name":"StarModule.smul_lt_smul_of_pos","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u\nA : Type u_1\ninst✝¹² : Semiring R\ninst✝¹¹ : PartialOrder R\ninst✝¹⁰ : StarRing R\ninst✝⁹ : StarOrderedRing R\ninst✝⁸ : NonUnitalRing A\ninst✝⁷ : StarRing A\ninst✝⁶ : PartialOrder A\ninst✝⁵ : StarOrderedRing A\ninst✝⁴ : Module R A\ninst✝³ : StarModule R A\ninst✝² : NoZeroSMulDivisors R A\ninst✝¹ : IsScalarTower R A A\ninst✝ : SMulCommClass R A A\na b : A\nc : R\nhab : LT.lt a b\nhc : LT.lt 0 c\n⊢ LT.lt (HSMul.hSMul c a) (HSMul.hSMul c b)","decl":"lemma StarModule.smul_lt_smul_of_pos {a b : A} {c : R} (hab : a < b) (hc : 0 < c) :\n    c • a < c • b := by\n  rw [← sub_pos] at hab ⊢\n  rw [← smul_sub]\n  refine lt_of_le_of_ne ?le ?ne\n  case le =>\n    have hab := le_of_lt hab\n    rw [StarOrderedRing.nonneg_iff] at hab ⊢\n    refine AddSubmonoid.closure_induction ?mem ?zero ?add hab\n    case mem =>\n      intro x hx\n      have hc := le_of_lt hc\n      rw [StarOrderedRing.nonneg_iff] at hc\n      refine AddSubmonoid.closure_induction ?memc ?zeroc ?addc hc\n      case memc =>\n        intro c' hc'\n        obtain ⟨z, hz⟩ := hc'\n        obtain ⟨y, hy⟩ := hx\n        apply AddSubmonoid.subset_closure\n        refine ⟨z • y, ?_⟩\n        simp only [star_smul, smul_mul_smul_comm, hz, hy]\n      case zeroc => simpa only [zero_smul] using zero_mem _\n      case addc => exact fun c' d _ _ ↦ by simpa only [add_smul] using add_mem\n    case zero => simpa only [smul_zero] using zero_mem _\n    case add => exact fun x y _ _ ↦ by simpa only [smul_add] using add_mem\n  case ne =>\n    refine (smul_ne_zero ?_ ?_).symm\n    · exact (ne_of_lt hc).symm\n    · exact (ne_of_lt hab).symm\n\n"}
{"name":"NonUnitalStarRingHom.map_le_map_of_map_star","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"R : Type u_2\nS : Type u_3\ninst✝⁷ : NonUnitalSemiring R\ninst✝⁶ : PartialOrder R\ninst✝⁵ : StarRing R\ninst✝⁴ : StarOrderedRing R\ninst✝³ : NonUnitalSemiring S\ninst✝² : PartialOrder S\ninst✝¹ : StarRing S\ninst✝ : StarOrderedRing S\nf : NonUnitalStarRingHom R S\nx y : R\nhxy : LE.le x y\n⊢ LE.le (f x) (f y)","decl":"lemma NonUnitalStarRingHom.map_le_map_of_map_star (f : R →⋆ₙ+* S) {x y : R} (hxy : x ≤ y) :\n    f x ≤ f y := by\n  rw [StarOrderedRing.le_iff] at hxy ⊢\n  obtain ⟨p, hp, rfl⟩ := hxy\n  refine ⟨f p, ?_, map_add f _ _⟩\n  have hf : ∀ r, f (star r) = star (f r) := map_star _\n  induction hp using AddSubmonoid.closure_induction\n  all_goals aesop\n\n"}
{"name":"StarRingHomClass.instOrderHomClass","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"F : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝¹⁰ : PartialOrder R\ninst✝⁹ : PartialOrder S\ninst✝⁸ : FunLike F R S\ninst✝⁷ : NonUnitalSemiring R\ninst✝⁶ : StarRing R\ninst✝⁵ : StarOrderedRing R\ninst✝⁴ : NonUnitalSemiring S\ninst✝³ : StarRing S\ninst✝² : StarOrderedRing S\ninst✝¹ : NonUnitalRingHomClass F R S\ninst✝ : NonUnitalStarRingHomClass F R S\n⊢ OrderHomClass F R S","decl":"instance (priority := 100) StarRingHomClass.instOrderHomClass [FunLike F R S]\n    [NonUnitalSemiring R] [StarRing R] [StarOrderedRing R] [NonUnitalSemiring S]\n    [StarRing S] [StarOrderedRing S] [NonUnitalRingHomClass F R S]\n    [NonUnitalStarRingHomClass F R S] : OrderHomClass F R S where\n  map_rel f := (f : R →⋆ₙ+* S).map_le_map_of_map_star\n\n"}
{"name":"StarRingEquivClass.instOrderIsoClass","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"F : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝⁷ : NonUnitalSemiring R\ninst✝⁶ : PartialOrder R\ninst✝⁵ : StarRing R\ninst✝⁴ : NonUnitalSemiring S\ninst✝³ : PartialOrder S\ninst✝² : StarRing S\ninst✝¹ : EquivLike F R S\ninst✝ : StarRingEquivClass F R S\n⊢ OrderIsoClass F R S","decl":"instance (priority := 100) StarRingEquivClass.instOrderIsoClass [EquivLike F R S]\n    [StarRingEquivClass F R S] : OrderIsoClass F R S where\n  map_le_map_iff f x y := by\n    refine ⟨fun h ↦ ?_, map_rel f⟩\n    let f_inv : S →⋆ₙ+* R := (f : R ≃⋆+* S).symm\n    have f_inv_f (r : R) : f_inv (f r) = r := EquivLike.inv_apply_apply f r\n    rw [← f_inv_f x, ← f_inv_f y]\n    exact NonUnitalStarRingHom.map_le_map_of_map_star f_inv h\n\n"}
{"name":"Nat.instStarOrderedRing","module":"Mathlib.Algebra.Order.Star.Basic","initialProofState":"⊢ StarOrderedRing Nat","decl":"instance Nat.instStarOrderedRing : StarOrderedRing ℕ where\n  le_iff a b := by\n    have : AddSubmonoid.closure (range fun x : ℕ ↦ x * x) = ⊤ :=\n      eq_top_mono\n        (AddSubmonoid.closure_mono <| singleton_subset_iff.2 <| mem_range.2 ⟨1, one_mul _⟩)\n        Nat.addSubmonoid_closure_one\n    simp [this, le_iff_exists_add]\n"}
