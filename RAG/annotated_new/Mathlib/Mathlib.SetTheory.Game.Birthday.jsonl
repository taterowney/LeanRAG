{"name":"SetTheory.PGame.birthday_def","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.PGame\n⊢ Eq x.birthday (Max.max (Ordinal.lsub fun i => (x.moveLeft i).birthday) (Ordinal.lsub fun i => (x.moveRight i).birthday))","decl":"theorem birthday_def (x : PGame) :\n    birthday x =\n      max (lsub.{u, u} fun i => birthday (x.moveLeft i))\n        (lsub.{u, u} fun i => birthday (x.moveRight i)) := by\n  cases x; rw [birthday]; rfl\n\n"}
{"name":"SetTheory.PGame.birthday_moveLeft_lt","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.PGame\ni : x.LeftMoves\n⊢ LT.lt (x.moveLeft i).birthday x.birthday","decl":"theorem birthday_moveLeft_lt {x : PGame} (i : x.LeftMoves) :\n    (x.moveLeft i).birthday < x.birthday := by\n  cases x; rw [birthday]; exact lt_max_of_lt_left (lt_lsub _ i)\n\n"}
{"name":"SetTheory.PGame.birthday_moveRight_lt","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.PGame\ni : x.RightMoves\n⊢ LT.lt (x.moveRight i).birthday x.birthday","decl":"theorem birthday_moveRight_lt {x : PGame} (i : x.RightMoves) :\n    (x.moveRight i).birthday < x.birthday := by\n  cases x; rw [birthday]; exact lt_max_of_lt_right (lt_lsub _ i)\n\n"}
{"name":"SetTheory.PGame.lt_birthday_iff","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.PGame\no : Ordinal.{u_1}\n⊢ Iff (LT.lt o x.birthday) (Or (Exists fun i => LE.le o (x.moveLeft i).birthday) (Exists fun i => LE.le o (x.moveRight i).birthday))","decl":"theorem lt_birthday_iff {x : PGame} {o : Ordinal} :\n    o < x.birthday ↔\n      (∃ i : x.LeftMoves, o ≤ (x.moveLeft i).birthday) ∨\n        ∃ i : x.RightMoves, o ≤ (x.moveRight i).birthday := by\n  constructor\n  · rw [birthday_def]\n    intro h\n    cases' lt_max_iff.1 h with h' h'\n    · left\n      rwa [lt_lsub_iff] at h'\n    · right\n      rwa [lt_lsub_iff] at h'\n  · rintro (⟨i, hi⟩ | ⟨i, hi⟩)\n    · exact hi.trans_lt (birthday_moveLeft_lt i)\n    · exact hi.trans_lt (birthday_moveRight_lt i)\n\n"}
{"name":"SetTheory.PGame.Relabelling.birthday_congr","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x y : SetTheory.PGame\na✝ : x.Relabelling y\n⊢ Eq x.birthday y.birthday","decl":"theorem Relabelling.birthday_congr : ∀ {x y : PGame.{u}}, x ≡r y → birthday x = birthday y\n  | ⟨xl, xr, xL, xR⟩, ⟨yl, yr, yL, yR⟩, r => by\n    unfold birthday\n    congr 1\n    all_goals\n      apply lsub_eq_of_range_eq.{u, u, u}\n      ext i; constructor\n    all_goals rintro ⟨j, rfl⟩\n    · exact ⟨_, (r.moveLeft j).birthday_congr.symm⟩\n    · exact ⟨_, (r.moveLeftSymm j).birthday_congr⟩\n    · exact ⟨_, (r.moveRight j).birthday_congr.symm⟩\n    · exact ⟨_, (r.moveRightSymm j).birthday_congr⟩\n\n"}
{"name":"SetTheory.PGame.birthday_eq_zero","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.PGame\n⊢ Iff (Eq x.birthday 0) (And (IsEmpty x.LeftMoves) (IsEmpty x.RightMoves))","decl":"@[simp]\ntheorem birthday_eq_zero {x : PGame} :\n    birthday x = 0 ↔ IsEmpty x.LeftMoves ∧ IsEmpty x.RightMoves := by\n  rw [birthday_def, max_eq_zero, lsub_eq_zero_iff, lsub_eq_zero_iff]\n\n"}
{"name":"SetTheory.PGame.birthday_zero","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"⊢ Eq (SetTheory.PGame.birthday 0) 0","decl":"@[simp]\ntheorem birthday_zero : birthday 0 = 0 := by simp [inferInstanceAs (IsEmpty PEmpty)]\n\n"}
{"name":"SetTheory.PGame.birthday_one","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"⊢ Eq (SetTheory.PGame.birthday 1) 1","decl":"@[simp]\ntheorem birthday_one : birthday 1 = 1 := by rw [birthday_def]; simp\n\n"}
{"name":"SetTheory.PGame.birthday_star","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"⊢ Eq SetTheory.PGame.star.birthday 1","decl":"@[simp]\ntheorem birthday_star : birthday star = 1 := by rw [birthday_def]; simp\n\n"}
{"name":"SetTheory.PGame.birthday_neg","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.PGame\n⊢ Eq (Neg.neg x).birthday x.birthday","decl":"@[simp]\ntheorem birthday_neg : ∀ x : PGame, (-x).birthday = x.birthday\n  | ⟨xl, xr, xL, xR⟩ => by\n    rw [birthday_def, birthday_def, max_comm]\n    congr <;> funext <;> apply birthday_neg\n\n"}
{"name":"SetTheory.PGame.birthday_ordinalToPGame","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq o.toPGame.birthday o","decl":"@[simp]\ntheorem birthday_ordinalToPGame (o : Ordinal) : o.toPGame.birthday = o := by\n  induction' o using Ordinal.induction with o IH\n  rw [toPGame, PGame.birthday]\n  simp only [lsub_empty, max_zero_right]\n  conv_rhs => rw [← lsub_typein o]\n  congr with x\n  exact IH _ (typein_lt_self x)\n\n"}
{"name":"SetTheory.PGame.le_birthday","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.PGame\n⊢ LE.le x x.birthday.toPGame","decl":"theorem le_birthday : ∀ x : PGame, x ≤ x.birthday.toPGame\n  | ⟨xl, _, xL, _⟩ =>\n    le_def.2\n      ⟨fun i =>\n        Or.inl ⟨toLeftMovesToPGame ⟨_, birthday_moveLeft_lt i⟩, by simp [le_birthday (xL i)]⟩,\n        isEmptyElim⟩\n\n"}
{"name":"SetTheory.PGame.neg_birthday_le","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.PGame\n⊢ LE.le (Neg.neg x.birthday.toPGame) x","decl":"theorem neg_birthday_le : -x.birthday.toPGame ≤ x := by\n  simpa only [birthday_neg, ← neg_le_iff] using le_birthday (-x)\n\n"}
{"name":"SetTheory.PGame.birthday_add","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (HAdd.hAdd x y).birthday (x.birthday.nadd y.birthday)","decl":"@[simp]\ntheorem birthday_add : ∀ x y : PGame.{u}, (x + y).birthday = x.birthday ♯ y.birthday\n  | ⟨xl, xr, xL, xR⟩, ⟨yl, yr, yL, yR⟩ => by\n    rw [birthday_def, nadd, lsub_sum, lsub_sum]\n    simp only [mk_add_moveLeft_inl, mk_add_moveLeft_inr, mk_add_moveRight_inl, mk_add_moveRight_inr,\n      moveLeft_mk, moveRight_mk]\n    conv_lhs => left; left; right; intro a; rw [birthday_add (xL a) ⟨yl, yr, yL, yR⟩]\n    conv_lhs => left; right; right; intro b; rw [birthday_add ⟨xl, xr, xL, xR⟩ (yL b)]\n    conv_lhs => right; left; right; intro a; rw [birthday_add (xR a) ⟨yl, yr, yL, yR⟩]\n    conv_lhs => right; right; right; intro b; rw [birthday_add ⟨xl, xr, xL, xR⟩ (yR b)]\n    rw [max_max_max_comm]\n    congr <;> apply le_antisymm\n    any_goals\n      refine max_le_iff.2 ⟨?_, ?_⟩\n      all_goals\n        refine lsub_le_iff.2 fun i ↦ ?_\n        rw [← Order.succ_le_iff]\n        refine Ordinal.le_iSup (fun _ : Set.Iio _ ↦ _) ⟨_, ?_⟩\n        apply_rules [birthday_moveLeft_lt, birthday_moveRight_lt]\n    all_goals\n      rw [Ordinal.iSup_le_iff]\n      rintro ⟨i, hi⟩\n      obtain ⟨j, hj⟩ | ⟨j, hj⟩ := lt_birthday_iff.1 hi <;> rw [Order.succ_le_iff]\n    · exact lt_max_of_lt_left ((nadd_le_nadd_right hj _).trans_lt (lt_lsub _ _))\n    · exact lt_max_of_lt_right ((nadd_le_nadd_right hj _).trans_lt (lt_lsub _ _))\n    · exact lt_max_of_lt_left ((nadd_le_nadd_left hj _).trans_lt (lt_lsub _ _))\n    · exact lt_max_of_lt_right ((nadd_le_nadd_left hj _).trans_lt (lt_lsub _ _))\ntermination_by a b => (a, b)\n\n"}
{"name":"SetTheory.PGame.birthday_sub","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x y : SetTheory.PGame\n⊢ Eq (HSub.hSub x y).birthday (x.birthday.nadd y.birthday)","decl":"@[simp]\ntheorem birthday_sub (x y : PGame) : (x - y).birthday = x.birthday ♯ y.birthday := by\n  apply (birthday_add x _).trans\n  rw [birthday_neg]\n\n"}
{"name":"SetTheory.PGame.birthday_natCast","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"n : Nat\n⊢ Eq (↑n).birthday ↑n","decl":"@[simp]\ntheorem birthday_natCast : ∀ n : ℕ, birthday n = n\n  | 0 => birthday_zero\n  | n + 1 => by simp [birthday_natCast]\n\n"}
{"name":"SetTheory.Game.birthday_eq_pGameBirthday","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.Game\n⊢ Exists fun y => And (Eq (Quotient.mk SetTheory.PGame.setoid y) x) (Eq y.birthday x.birthday)","decl":"theorem birthday_eq_pGameBirthday (x : Game) :\n    ∃ y : PGame.{u}, ⟦y⟧ = x ∧ y.birthday = birthday x := by\n  refine csInf_mem (Set.image_nonempty.2 ?_)\n  exact ⟨_, x.out_eq⟩\n\n"}
{"name":"SetTheory.Game.birthday_quot_le_pGameBirthday","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.PGame\n⊢ LE.le (SetTheory.Game.birthday (Quotient.mk SetTheory.PGame.setoid x)) x.birthday","decl":"theorem birthday_quot_le_pGameBirthday  (x : PGame) : birthday ⟦x⟧ ≤ x.birthday :=\n  csInf_le' ⟨x, rfl, rfl⟩\n\n"}
{"name":"SetTheory.Game.birthday_zero","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"⊢ Eq (SetTheory.Game.birthday 0) 0","decl":"@[simp]\ntheorem birthday_zero : birthday 0 = 0 := by\n  rw [← Ordinal.le_zero, ← PGame.birthday_zero]\n  exact birthday_quot_le_pGameBirthday  _\n\n"}
{"name":"SetTheory.Game.birthday_eq_zero","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.Game\n⊢ Iff (Eq x.birthday 0) (Eq x 0)","decl":"@[simp]\ntheorem birthday_eq_zero {x : Game} : birthday x = 0 ↔ x = 0 := by\n  constructor\n  · intro h\n    let ⟨y, hy₁, hy₂⟩ := birthday_eq_pGameBirthday x\n    rw [← hy₁]\n    rw [h, PGame.birthday_eq_zero] at hy₂\n    exact PGame.game_eq (@PGame.Equiv.isEmpty _ hy₂.1 hy₂.2)\n  · rintro rfl\n    exact birthday_zero\n\n"}
{"name":"SetTheory.Game.birthday_ordinalToGame","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Ordinal.toGame o).birthday o","decl":"@[simp]\ntheorem birthday_ordinalToGame (o : Ordinal) : birthday o.toGame = o := by\n  apply le_antisymm\n  · conv_rhs => rw [← PGame.birthday_ordinalToPGame o]\n    apply birthday_quot_le_pGameBirthday\n  · let ⟨x, hx₁, hx₂⟩ := birthday_eq_pGameBirthday o.toGame\n    rw [← hx₂, ← toPGame_le_iff]\n    rw [← mk_toPGame, ← PGame.equiv_iff_game_eq] at hx₁\n    exact hx₁.2.trans (PGame.le_birthday x)\n\n"}
{"name":"SetTheory.Game.birthday_natCast","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"n : Nat\n⊢ Eq (↑n).birthday ↑n","decl":"@[simp, norm_cast]\ntheorem birthday_natCast (n : ℕ) : birthday n = n := by\n  rw [← toGame_natCast]\n  exact birthday_ordinalToGame _\n\n"}
{"name":"SetTheory.Game.birthday_ofNat","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).birthday (OfNat.ofNat n)","decl":"@[simp]\ntheorem birthday_ofNat (n : ℕ) [n.AtLeastTwo] :\n    birthday ofNat(n) = OfNat.ofNat n :=\n  birthday_natCast n\n\n"}
{"name":"SetTheory.Game.birthday_one","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"⊢ Eq (SetTheory.Game.birthday 1) 1","decl":"@[simp]\ntheorem birthday_one : birthday 1 = 1 := by\n  rw [← Nat.cast_one, birthday_natCast, Nat.cast_one]\n\n"}
{"name":"SetTheory.Game.birthday_star","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"⊢ Eq (SetTheory.Game.birthday (Quotient.mk SetTheory.PGame.setoid SetTheory.PGame.star)) 1","decl":"@[simp]\ntheorem birthday_star : birthday ⟦PGame.star⟧ = 1 := by\n  apply le_antisymm\n  · rw [← PGame.birthday_star]\n    exact birthday_quot_le_pGameBirthday  _\n  · rw [Ordinal.one_le_iff_ne_zero, ne_eq, birthday_eq_zero, Game.zero_def,\n      ← PGame.equiv_iff_game_eq]\n    exact PGame.star_fuzzy_zero.not_equiv\n\n"}
{"name":"SetTheory.Game.birthday_neg","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.Game\n⊢ Eq (Neg.neg x).birthday x.birthday","decl":"@[simp]\ntheorem birthday_neg (x : Game) : (-x).birthday = x.birthday := by\n  apply le_antisymm (birthday_neg' x)\n  conv_lhs => rw [← neg_neg x]\n  exact birthday_neg' _\n\n"}
{"name":"SetTheory.Game.le_birthday","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.Game\n⊢ LE.le x (Ordinal.toGame x.birthday)","decl":"theorem le_birthday (x : Game) : x ≤ x.birthday.toGame := by\n  let ⟨y, hy₁, hy₂⟩ := birthday_eq_pGameBirthday x\n  rw [← hy₁]\n  apply (y.le_birthday).trans\n  rw [toPGame_le_iff, hy₁, hy₂]\n\n"}
{"name":"SetTheory.Game.neg_birthday_le","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x : SetTheory.Game\n⊢ LE.le (Neg.neg (Ordinal.toGame x.birthday)) x","decl":"theorem neg_birthday_le (x : Game) : -x.birthday.toGame ≤ x := by\n  rw [neg_le, ← birthday_neg]\n  exact le_birthday _\n\n"}
{"name":"SetTheory.Game.birthday_add_le","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x y : SetTheory.Game\n⊢ LE.le (HAdd.hAdd x y).birthday (x.birthday.nadd y.birthday)","decl":"theorem birthday_add_le (x y : Game) : (x + y).birthday ≤ x.birthday ♯ y.birthday := by\n  let ⟨a, ha₁, ha₂⟩ := birthday_eq_pGameBirthday x\n  let ⟨b, hb₁, hb₂⟩ := birthday_eq_pGameBirthday y\n  rw [← ha₂, ← hb₂, ← ha₁, ← hb₁, ← PGame.birthday_add]\n  exact birthday_quot_le_pGameBirthday  _\n\n"}
{"name":"SetTheory.Game.birthday_sub_le","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"x y : SetTheory.Game\n⊢ LE.le (HSub.hSub x y).birthday (x.birthday.nadd y.birthday)","decl":"theorem birthday_sub_le (x y : Game) : (x - y).birthday ≤ x.birthday ♯ y.birthday := by\n  apply (birthday_add_le x _).trans_eq\n  rw [birthday_neg]\n\n/- The bound `(x * y).birthday ≤ x.birthday ⨳ y.birthday` is currently an open problem. See\n  https://mathoverflow.net/a/476829/147705. -/\n\n"}
{"name":"SetTheory.Game.small_setOf_birthday_lt","module":"Mathlib.SetTheory.Game.Birthday","initialProofState":"o : Ordinal.{u}\n⊢ Small.{u, u + 1} (Subtype fun x => LT.lt x.birthday o)","decl":"/-- Games with bounded birthday are a small set. -/\ntheorem small_setOf_birthday_lt (o : Ordinal) : Small.{u} {x : Game.{u} // birthday x < o} := by\n  induction o using Ordinal.induction with | h o IH =>\n  let S := ⋃ a ∈ Set.Iio o, {x : Game.{u} | birthday x < a}\n  let H : Small.{u} S := @small_biUnion _ _ _ _ _ IH\n  obtain rfl | ⟨a, rfl⟩ | ho := zero_or_succ_or_limit o\n  · simp_rw [Ordinal.not_lt_zero]\n    exact small_empty\n  · simp_rw [Order.lt_succ_iff, le_iff_lt_or_eq]\n    convert small_union.{u} {x | birthday x < a} {x | birthday x = a}\n    · exact IH _ (Order.lt_succ a)\n    · let f (g : Set S × Set S) : Game := ⟦PGame.mk _ _\n        (fun x ↦ ((equivShrink g.1).symm x).1.1.out) (fun x ↦ ((equivShrink g.2).symm x).1.1.out)⟧\n      suffices {x | x.birthday = a} ⊆ Set.range f from small_subset this\n      rintro x rfl\n      obtain ⟨y, rfl, hy'⟩ := birthday_eq_pGameBirthday x\n      refine ⟨⟨{z | ∃ i, ⟦y.moveLeft i⟧ = z.1}, {z | ∃ i, ⟦y.moveRight i⟧ = z.1}⟩, ?_⟩\n      apply PGame.game_eq <| PGame.Equiv.of_exists _ _ _ _ <;> intro i\n      · obtain ⟨j, hj⟩ := ((equivShrink _).symm i).2\n        exact ⟨j, by simp [PGame.equiv_iff_game_eq, hj]⟩\n      · obtain ⟨j, hj⟩ := ((equivShrink _).symm i).2\n        exact ⟨j, by simp [PGame.equiv_iff_game_eq, hj]⟩\n      · refine ⟨equivShrink _ ⟨⟨⟦y.moveLeft i⟧, ?_⟩, i, rfl⟩, by simpa using Quotient.mk_out _⟩\n        suffices ∃ b ≤ y.birthday, birthday ⟦y.moveLeft i⟧ < b by simpa [S, hy'] using this\n        refine ⟨_, le_rfl, ?_⟩\n        exact (birthday_quot_le_pGameBirthday _).trans_lt (PGame.birthday_moveLeft_lt i)\n      · refine ⟨equivShrink _ ⟨⟨⟦y.moveRight i⟧, ?_⟩, i, rfl⟩, by simpa using Quotient.mk_out _⟩\n        suffices ∃ b ≤ y.birthday, birthday ⟦y.moveRight i⟧ < b by simpa [S, hy'] using this\n        refine ⟨_, le_rfl, ?_⟩\n        exact (birthday_quot_le_pGameBirthday _).trans_lt (PGame.birthday_moveRight_lt i)\n  · convert H\n    change birthday _ < o ↔ ∃ a, _\n    simpa using lt_limit ho\n\n"}
