{"name":"CategoryTheory.Limits.Types.instHasProductsType","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"⊢ CategoryTheory.Limits.HasProducts (Type v)","decl":"instance : HasProducts.{v} (Type v) := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.Types.pi_lift_π_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"β : Type v\ninst✝ : Small.{u, v} β\nf : β → Type u\nP : Type u\ns : (b : β) → Quiver.Hom P (f b)\nb : β\nx : P\n⊢ Eq (CategoryTheory.Limits.Pi.π f b (CategoryTheory.Limits.Pi.lift s x)) (s b x)","decl":"/-- A restatement of `Types.Limit.lift_π_apply` that uses `Pi.π` and `Pi.lift`. -/\n-- The increased `@[simp]` priority here results in a minor speed up in\n-- `Mathlib.CategoryTheory.Sites.EqualizerSheafCondition`.\n@[simp 1001]\ntheorem pi_lift_π_apply {β : Type v} [Small.{u} β] (f : β → Type u) {P : Type u}\n    (s : ∀ b, P ⟶ f b) (b : β) (x : P) :\n    (Pi.π f b : (piObj f) → f b) (@Pi.lift β _ _ f _ P s x) = s b x :=\n  congr_fun (limit.lift_π (Fan.mk P s) ⟨b⟩) x\n\n"}
{"name":"CategoryTheory.Limits.Types.pi_lift_π_apply'","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"β : Type v\nf : β → Type v\nP : Type v\ns : (b : β) → Quiver.Hom P (f b)\nb : β\nx : P\n⊢ Eq (CategoryTheory.Limits.Pi.π f b (CategoryTheory.Limits.Pi.lift s x)) (s b x)","decl":"/-- A restatement of `Types.Limit.lift_π_apply` that uses `Pi.π` and `Pi.lift`,\nwith specialized universes. -/\ntheorem pi_lift_π_apply' {β : Type v} (f : β → Type v) {P : Type v}\n    (s : ∀ b, P ⟶ f b) (b : β) (x : P) :\n    (Pi.π f b : (piObj f) → f b) (@Pi.lift β _ _ f _ P s x) = s b x := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Types.pi_map_π_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"β : Type v\ninst✝ : Small.{u, v} β\nf g : β → Type u\nα : (j : β) → Quiver.Hom (f j) (g j)\nb : β\nx : CategoryTheory.Limits.piObj f\n⊢ Eq (CategoryTheory.Limits.Pi.π g b (CategoryTheory.Limits.Pi.map α x)) (α b (CategoryTheory.Limits.Pi.π f b x))","decl":"/-- A restatement of `Types.Limit.map_π_apply` that uses `Pi.π` and `Pi.map`. -/\n@[simp]\ntheorem pi_map_π_apply {β : Type v} [Small.{u} β] {f g : β → Type u}\n    (α : ∀ j, f j ⟶ g j) (b : β) (x) :\n    (Pi.π g b : ∏ᶜ g → g b) (Pi.map α x) = α b ((Pi.π f b : ∏ᶜ f → f b) x) :=\n  Limit.map_π_apply.{v, u} _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Types.pi_map_π_apply'","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"β : Type v\nf g : β → Type v\nα : (j : β) → Quiver.Hom (f j) (g j)\nb : β\nx : CategoryTheory.Limits.piObj f\n⊢ Eq (CategoryTheory.Limits.Pi.π g b (CategoryTheory.Limits.Pi.map α x)) (α b (CategoryTheory.Limits.Pi.π f b x))","decl":"/-- A restatement of `Types.Limit.map_π_apply` that uses `Pi.π` and `Pi.map`,\nwith specialized universes. -/\ntheorem pi_map_π_apply' {β : Type v} {f g : β → Type v} (α : ∀ j, f j ⟶ g j) (b : β) (x) :\n    (Pi.π g b : ∏ᶜ g → g b) (Pi.map α x) = α b ((Pi.π f b : ∏ᶜ f → f b) x) := by\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Types.instSubsingletonTerminalType","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"⊢ Subsingleton (CategoryTheory.Limits.terminal (Type u))","decl":"instance : Subsingleton (⊤_ (Type u)) := ⟨fun a b =>\n  congr_fun (@Subsingleton.elim (_ ⟶ ⊤_ (Type u)) _\n    (fun _ => a) (fun _ => b)) (ULift.up (0 : Fin 1))⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.initial_iff_empty","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X : Type u\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsInitial X)) (IsEmpty X)","decl":"/-- An object in `Type u` is initial if and only if it is empty. -/\nlemma initial_iff_empty (X : Type u) : Nonempty (IsInitial X) ↔ IsEmpty X := by\n  constructor\n  · intro ⟨h⟩\n    exact Function.isEmpty (IsInitial.to h PEmpty)\n  · intro h\n    exact ⟨IsInitial.ofIso Types.isInitialPunit <| Equiv.toIso <| Equiv.equivOfIsEmpty PEmpty X⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductCone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.Limits.Types.binaryProductCone X Y).pt (Prod X Y)","decl":"/-- The product type `X × Y` forms a cone for the binary product of `X` and `Y`. -/\n@[simps! pt]\ndef binaryProductCone (X Y : Type u) : BinaryFan X Y :=\n  BinaryFan.mk _root_.Prod.fst _root_.Prod.snd\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductCone_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.Limits.Types.binaryProductCone X Y).fst Prod.fst","decl":"@[simp]\ntheorem binaryProductCone_fst (X Y : Type u) : (binaryProductCone X Y).fst = _root_.Prod.fst :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductCone_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.Limits.Types.binaryProductCone X Y).snd Prod.snd","decl":"@[simp]\ntheorem binaryProductCone_snd (X Y : Type u) : (binaryProductCone X Y).snd = _root_.Prod.snd :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductLimit_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\ns : CategoryTheory.Limits.BinaryFan X Y\nx : s.pt\n⊢ Eq ((CategoryTheory.Limits.Types.binaryProductLimit X Y).lift s x) { fst := s.fst x, snd := s.snd x }","decl":"/-- The product type `X × Y` is a binary product for `X` and `Y`. -/\n@[simps]\ndef binaryProductLimit (X Y : Type u) : IsLimit (binaryProductCone X Y) where\n  lift (s : BinaryFan X Y) x := (s.fst x, s.snd x)\n  fac _ j := Discrete.recOn j fun j => WalkingPair.casesOn j rfl rfl\n  uniq _ _ w := funext fun x => Prod.ext (congr_fun (w ⟨left⟩) x) (congr_fun (w ⟨right⟩) x)\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductLimitCone_cone","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.Limits.Types.binaryProductLimitCone X Y).cone (CategoryTheory.Limits.Types.binaryProductCone X Y)","decl":"/-- The category of types has `X × Y`, the usual cartesian product,\nas the binary product of `X` and `Y`.\n-/\n@[simps]\ndef binaryProductLimitCone (X Y : Type u) : Limits.LimitCone (pair X Y) :=\n  ⟨_, binaryProductLimit X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductLimitCone_isLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.Limits.Types.binaryProductLimitCone X Y).isLimit (CategoryTheory.Limits.Types.binaryProductLimit X Y)","decl":"/-- The category of types has `X × Y`, the usual cartesian product,\nas the binary product of `X` and `Y`.\n-/\n@[simps]\ndef binaryProductLimitCone (X Y : Type u) : Limits.LimitCone (pair X Y) :=\n  ⟨_, binaryProductLimit X Y⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductIso_hom_comp_fst_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\nx : CategoryTheory.Limits.prod X Y\n⊢ Eq ((CategoryTheory.Limits.Types.binaryProductIso X Y).hom x).1 (CategoryTheory.Limits.prod.fst x)","decl":"@[elementwise (attr := simp)]\ntheorem binaryProductIso_hom_comp_fst (X Y : Type u) :\n    (binaryProductIso X Y).hom ≫ _root_.Prod.fst = Limits.prod.fst :=\n  limit.isoLimitCone_hom_π (binaryProductLimitCone X Y) ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductIso_hom_comp_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Types.binaryProductIso X Y).hom Prod.fst) CategoryTheory.Limits.prod.fst","decl":"@[elementwise (attr := simp)]\ntheorem binaryProductIso_hom_comp_fst (X Y : Type u) :\n    (binaryProductIso X Y).hom ≫ _root_.Prod.fst = Limits.prod.fst :=\n  limit.isoLimitCone_hom_π (binaryProductLimitCone X Y) ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductIso_hom_comp_snd_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\nx : CategoryTheory.Limits.prod X Y\n⊢ Eq ((CategoryTheory.Limits.Types.binaryProductIso X Y).hom x).2 (CategoryTheory.Limits.prod.snd x)","decl":"@[elementwise (attr := simp)]\ntheorem binaryProductIso_hom_comp_snd (X Y : Type u) :\n    (binaryProductIso X Y).hom ≫ _root_.Prod.snd = Limits.prod.snd :=\n  limit.isoLimitCone_hom_π (binaryProductLimitCone X Y) ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductIso_hom_comp_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Types.binaryProductIso X Y).hom Prod.snd) CategoryTheory.Limits.prod.snd","decl":"@[elementwise (attr := simp)]\ntheorem binaryProductIso_hom_comp_snd (X Y : Type u) :\n    (binaryProductIso X Y).hom ≫ _root_.Prod.snd = Limits.prod.snd :=\n  limit.isoLimitCone_hom_π (binaryProductLimitCone X Y) ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductIso_inv_comp_fst_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\nx : Prod X Y\n⊢ Eq (CategoryTheory.Limits.prod.fst ((CategoryTheory.Limits.Types.binaryProductIso X Y).inv x)) x.1","decl":"@[elementwise (attr := simp)]\ntheorem binaryProductIso_inv_comp_fst (X Y : Type u) :\n    (binaryProductIso X Y).inv ≫ Limits.prod.fst = _root_.Prod.fst :=\n  limit.isoLimitCone_inv_π (binaryProductLimitCone X Y) ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductIso_inv_comp_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Types.binaryProductIso X Y).inv CategoryTheory.Limits.prod.fst) Prod.fst","decl":"@[elementwise (attr := simp)]\ntheorem binaryProductIso_inv_comp_fst (X Y : Type u) :\n    (binaryProductIso X Y).inv ≫ Limits.prod.fst = _root_.Prod.fst :=\n  limit.isoLimitCone_inv_π (binaryProductLimitCone X Y) ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductIso_inv_comp_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Types.binaryProductIso X Y).inv CategoryTheory.Limits.prod.snd) Prod.snd","decl":"@[elementwise (attr := simp)]\ntheorem binaryProductIso_inv_comp_snd (X Y : Type u) :\n    (binaryProductIso X Y).inv ≫ Limits.prod.snd = _root_.Prod.snd :=\n  limit.isoLimitCone_inv_π (binaryProductLimitCone X Y) ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductIso_inv_comp_snd_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\nx : Prod X Y\n⊢ Eq (CategoryTheory.Limits.prod.snd ((CategoryTheory.Limits.Types.binaryProductIso X Y).inv x)) x.2","decl":"@[elementwise (attr := simp)]\ntheorem binaryProductIso_inv_comp_snd (X Y : Type u) :\n    (binaryProductIso X Y).inv ≫ Limits.prod.snd = _root_.Prod.snd :=\n  limit.isoLimitCone_inv_π (binaryProductLimitCone X Y) ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductFunctor_obj_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq ((CategoryTheory.Limits.Types.binaryProductFunctor.obj X).obj Y) (Prod X Y)","decl":"/-- The functor which sends `X, Y` to the product type `X × Y`. -/\n@[simps]\ndef binaryProductFunctor : Type u ⥤ Type u ⥤ Type u where\n  obj X :=\n    { obj := fun Y => X × Y\n      map := fun { _ Y₂} f => (binaryProductLimit X Y₂).lift\n        (BinaryFan.mk _root_.Prod.fst (_root_.Prod.snd ≫ f)) }\n  map {X₁ X₂} f :=\n    { app := fun Y =>\n      (binaryProductLimit X₂ Y).lift (BinaryFan.mk (_root_.Prod.fst ≫ f) _root_.Prod.snd) }\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductFunctor_obj_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X x✝ Y₂ : Type u\nf : Quiver.Hom x✝ Y₂\na✝ : (CategoryTheory.Limits.BinaryFan.mk Prod.fst (CategoryTheory.CategoryStruct.comp Prod.snd f)).pt\n⊢ Eq ((CategoryTheory.Limits.Types.binaryProductFunctor.obj X).map f a✝) ((CategoryTheory.Limits.Types.binaryProductLimit X Y₂).lift (CategoryTheory.Limits.BinaryFan.mk Prod.fst (CategoryTheory.CategoryStruct.comp Prod.snd f)) a✝)","decl":"/-- The functor which sends `X, Y` to the product type `X × Y`. -/\n@[simps]\ndef binaryProductFunctor : Type u ⥤ Type u ⥤ Type u where\n  obj X :=\n    { obj := fun Y => X × Y\n      map := fun { _ Y₂} f => (binaryProductLimit X Y₂).lift\n        (BinaryFan.mk _root_.Prod.fst (_root_.Prod.snd ≫ f)) }\n  map {X₁ X₂} f :=\n    { app := fun Y =>\n      (binaryProductLimit X₂ Y).lift (BinaryFan.mk (_root_.Prod.fst ≫ f) _root_.Prod.snd) }\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryProductFunctor_map_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X₁ X₂ : Type u\nf : Quiver.Hom X₁ X₂\nY : Type u\na✝ : (CategoryTheory.Limits.BinaryFan.mk (CategoryTheory.CategoryStruct.comp Prod.fst f) Prod.snd).pt\n⊢ Eq ((CategoryTheory.Limits.Types.binaryProductFunctor.map f).app Y a✝) ((CategoryTheory.Limits.Types.binaryProductLimit X₂ Y).lift (CategoryTheory.Limits.BinaryFan.mk (CategoryTheory.CategoryStruct.comp Prod.fst f) Prod.snd) a✝)","decl":"/-- The functor which sends `X, Y` to the product type `X × Y`. -/\n@[simps]\ndef binaryProductFunctor : Type u ⥤ Type u ⥤ Type u where\n  obj X :=\n    { obj := fun Y => X × Y\n      map := fun { _ Y₂} f => (binaryProductLimit X Y₂).lift\n        (BinaryFan.mk _root_.Prod.fst (_root_.Prod.snd ≫ f)) }\n  map {X₁ X₂} f :=\n    { app := fun Y =>\n      (binaryProductLimit X₂ Y).lift (BinaryFan.mk (_root_.Prod.fst ≫ f) _root_.Prod.snd) }\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryCoproductCocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.Limits.Types.binaryCoproductCocone X Y).pt (Sum X Y)","decl":"/-- The sum type `X ⊕ Y` forms a cocone for the binary coproduct of `X` and `Y`. -/\n@[simps!]\ndef binaryCoproductCocone (X Y : Type u) : Cocone (pair X Y) :=\n  BinaryCofan.mk Sum.inl Sum.inr\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryCoproductCocone_ι_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\nx✝ : CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair\na✝ : (CategoryTheory.Limits.pair X Y).obj x✝\n⊢ Eq ((CategoryTheory.Limits.Types.binaryCoproductCocone X Y).ι.app x✝ a✝) (CategoryTheory.Limits.WalkingPair.swap.match_1 (fun j => Quiver.Hom ((CategoryTheory.Limits.pair X Y).obj { as := j }) (Sum X Y)) x✝.as (fun _ => Sum.inl) (fun _ => Sum.inr) a✝)","decl":"/-- The sum type `X ⊕ Y` forms a cocone for the binary coproduct of `X` and `Y`. -/\n@[simps!]\ndef binaryCoproductCocone (X Y : Type u) : Cocone (pair X Y) :=\n  BinaryCofan.mk Sum.inl Sum.inr\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryCoproductColimit_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\ns : CategoryTheory.Limits.BinaryCofan X Y\na✝ : Sum X Y\n⊢ Eq ((CategoryTheory.Limits.Types.binaryCoproductColimit X Y).desc s a✝) (Sum.elim s.inl s.inr a✝)","decl":"/-- The sum type `X ⊕ Y` is a binary coproduct for `X` and `Y`. -/\n@[simps]\ndef binaryCoproductColimit (X Y : Type u) : IsColimit (binaryCoproductCocone X Y) where\n  desc := fun s : BinaryCofan X Y => Sum.elim s.inl s.inr\n  fac _ j := Discrete.recOn j fun j => WalkingPair.casesOn j rfl rfl\n  uniq _ _ w := funext fun x => Sum.casesOn x (congr_fun (w ⟨left⟩)) (congr_fun (w ⟨right⟩))\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inl (CategoryTheory.Limits.Types.binaryCoproductIso X Y).hom) Sum.inl","decl":"@[elementwise (attr := simp)]\ntheorem binaryCoproductIso_inl_comp_hom (X Y : Type u) :\n    Limits.coprod.inl ≫ (binaryCoproductIso X Y).hom = Sum.inl :=\n  colimit.isoColimitCocone_ι_hom (binaryCoproductColimitCocone X Y) ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_hom_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\nx : X\n⊢ Eq ((CategoryTheory.Limits.Types.binaryCoproductIso X Y).hom (CategoryTheory.Limits.coprod.inl x)) (Sum.inl x)","decl":"@[elementwise (attr := simp)]\ntheorem binaryCoproductIso_inl_comp_hom (X Y : Type u) :\n    Limits.coprod.inl ≫ (binaryCoproductIso X Y).hom = Sum.inl :=\n  colimit.isoColimitCocone_ι_hom (binaryCoproductColimitCocone X Y) ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.coprod.inr (CategoryTheory.Limits.Types.binaryCoproductIso X Y).hom) Sum.inr","decl":"@[elementwise (attr := simp)]\ntheorem binaryCoproductIso_inr_comp_hom (X Y : Type u) :\n    Limits.coprod.inr ≫ (binaryCoproductIso X Y).hom = Sum.inr :=\n  colimit.isoColimitCocone_ι_hom (binaryCoproductColimitCocone X Y) ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_hom_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\nx : Y\n⊢ Eq ((CategoryTheory.Limits.Types.binaryCoproductIso X Y).hom (CategoryTheory.Limits.coprod.inr x)) (Sum.inr x)","decl":"@[elementwise (attr := simp)]\ntheorem binaryCoproductIso_inr_comp_hom (X Y : Type u) :\n    Limits.coprod.inr ≫ (binaryCoproductIso X Y).hom = Sum.inr :=\n  colimit.isoColimitCocone_ι_hom (binaryCoproductColimitCocone X Y) ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_inv_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\nx : X\n⊢ Eq ((CategoryTheory.Limits.Types.binaryCoproductIso X Y).inv (CategoryTheory.asHom Sum.inl x)) (CategoryTheory.Limits.coprod.inl x)","decl":"@[elementwise (attr := simp)]\ntheorem binaryCoproductIso_inl_comp_inv (X Y : Type u) :\n    ↾(Sum.inl : X ⟶ X ⊕ Y) ≫ (binaryCoproductIso X Y).inv = Limits.coprod.inl :=\n  colimit.isoColimitCocone_ι_inv (binaryCoproductColimitCocone X Y) ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryCoproductIso_inl_comp_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.asHom Sum.inl) (CategoryTheory.Limits.Types.binaryCoproductIso X Y).inv) CategoryTheory.Limits.coprod.inl","decl":"@[elementwise (attr := simp)]\ntheorem binaryCoproductIso_inl_comp_inv (X Y : Type u) :\n    ↾(Sum.inl : X ⟶ X ⊕ Y) ≫ (binaryCoproductIso X Y).inv = Limits.coprod.inl :=\n  colimit.isoColimitCocone_ι_inv (binaryCoproductColimitCocone X Y) ⟨WalkingPair.left⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_inv_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\nx : Y\n⊢ Eq ((CategoryTheory.Limits.Types.binaryCoproductIso X Y).inv (CategoryTheory.asHom Sum.inr x)) (CategoryTheory.Limits.coprod.inr x)","decl":"@[elementwise (attr := simp)]\ntheorem binaryCoproductIso_inr_comp_inv (X Y : Type u) :\n    ↾(Sum.inr : Y ⟶ X ⊕ Y) ≫ (binaryCoproductIso X Y).inv = Limits.coprod.inr :=\n  colimit.isoColimitCocone_ι_inv (binaryCoproductColimitCocone X Y) ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryCoproductIso_inr_comp_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.asHom Sum.inr) (CategoryTheory.Limits.Types.binaryCoproductIso X Y).inv) CategoryTheory.Limits.coprod.inr","decl":"@[elementwise (attr := simp)]\ntheorem binaryCoproductIso_inr_comp_inv (X Y : Type u) :\n    ↾(Sum.inr : Y ⟶ X ⊕ Y) ≫ (binaryCoproductIso X Y).inv = Limits.coprod.inr :=\n  colimit.isoColimitCocone_ι_inv (binaryCoproductColimitCocone X Y) ⟨WalkingPair.right⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.binaryCofan_isColimit_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\nc : CategoryTheory.Limits.BinaryCofan X Y\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsColimit c)) (And (Function.Injective c.inl) (And (Function.Injective c.inr) (IsCompl (Set.range c.inl) (Set.range c.inr))))","decl":"theorem binaryCofan_isColimit_iff {X Y : Type u} (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) ↔\n      Injective c.inl ∧ Injective c.inr ∧ IsCompl (Set.range c.inl) (Set.range c.inr) := by\n  classical\n    constructor\n    · rintro ⟨h⟩\n      rw [← show _ = c.inl from\n          h.comp_coconePointUniqueUpToIso_inv (binaryCoproductColimit X Y) ⟨WalkingPair.left⟩,\n        ← show _ = c.inr from\n          h.comp_coconePointUniqueUpToIso_inv (binaryCoproductColimit X Y) ⟨WalkingPair.right⟩]\n      dsimp [binaryCoproductCocone]\n      refine\n        ⟨(h.coconePointUniqueUpToIso (binaryCoproductColimit X Y)).symm.toEquiv.injective.comp\n            Sum.inl_injective,\n          (h.coconePointUniqueUpToIso (binaryCoproductColimit X Y)).symm.toEquiv.injective.comp\n            Sum.inr_injective, ?_⟩\n      erw [Set.range_comp, ← eq_compl_iff_isCompl, Set.range_comp _ Sum.inr, ←\n        Set.image_compl_eq\n          (h.coconePointUniqueUpToIso (binaryCoproductColimit X Y)).symm.toEquiv.bijective]\n      simp\n    · rintro ⟨h₁, h₂, h₃⟩\n      have : ∀ x, x ∈ Set.range c.inl ∨ x ∈ Set.range c.inr := by\n        rw [eq_compl_iff_isCompl.mpr h₃.symm]\n        exact fun _ => or_not\n      refine ⟨BinaryCofan.IsColimit.mk _ ?_ ?_ ?_ ?_⟩\n      · intro T f g x\n        exact\n          if h : x ∈ Set.range c.inl then f ((Equiv.ofInjective _ h₁).symm ⟨x, h⟩)\n          else g ((Equiv.ofInjective _ h₂).symm ⟨x, (this x).resolve_left h⟩)\n      · intro T f g\n        funext x\n        dsimp\n        simp [h₁.eq_iff]\n      · intro T f g\n        funext x\n        dsimp\n        simp only [Set.mem_range, Equiv.ofInjective_symm_apply,\n          dite_eq_right_iff, forall_exists_index]\n        intro y e\n        have : c.inr x ∈ Set.range c.inl ⊓ Set.range c.inr := ⟨⟨_, e⟩, ⟨_, rfl⟩⟩\n        rw [disjoint_iff.mp h₃.1] at this\n        exact this.elim\n      · rintro T _ _ m rfl rfl\n        funext x\n        dsimp\n        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ⟨_, _⟩).symm\n\n"}
{"name":"CategoryTheory.Limits.Types.productIso_hom_comp_eval","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"J : Type v\nF : J → TypeMax\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Types.productIso F).hom fun f => f j) (CategoryTheory.Limits.Pi.π F j)","decl":"@[simp]\ntheorem productIso_hom_comp_eval {J : Type v} (F : J → TypeMax.{v, u}) (j : J) :\n    ((productIso.{v, u} F).hom ≫ fun f => f j) = Pi.π F j :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.productIso_hom_comp_eval_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"J : Type v\nF : J → TypeMax\nj : J\nx : CategoryTheory.Limits.piObj F\n⊢ Eq ((CategoryTheory.Limits.Types.productIso F).hom x j) (CategoryTheory.Limits.Pi.π F j x)","decl":"@[simp]\ntheorem productIso_hom_comp_eval_apply {J : Type v} (F : J → TypeMax.{v, u}) (j : J) (x) :\n    ((productIso.{v, u} F).hom x) j = Pi.π F j x :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.productIso_inv_comp_π_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"J : Type v\nF : J → TypeMax\nj : J\nx : (j : J) → F j\n⊢ Eq (CategoryTheory.Limits.Pi.π F j ((CategoryTheory.Limits.Types.productIso F).inv x)) (x j)","decl":"@[elementwise (attr := simp)]\ntheorem productIso_inv_comp_π {J : Type v} (F : J → TypeMax.{v, u}) (j : J) :\n    (productIso.{v, u} F).inv ≫ Pi.π F j = fun f => f j :=\n  limit.isoLimitCone_inv_π (productLimitCone.{v, u} F) ⟨j⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.productIso_inv_comp_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"J : Type v\nF : J → TypeMax\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Types.productIso F).inv (CategoryTheory.Limits.Pi.π F j)) fun f => f j","decl":"@[elementwise (attr := simp)]\ntheorem productIso_inv_comp_π {J : Type v} (F : J → TypeMax.{v, u}) (j : J) :\n    (productIso.{v, u} F).inv ≫ Pi.π F j = fun f => f j :=\n  limit.isoLimitCone_inv_π (productLimitCone.{v, u} F) ⟨j⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.Small.productIso_hom_comp_eval","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"J : Type v\nF : J → Type u\ninst✝ : Small.{u, v} J\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Types.Small.productIso F).hom fun f => (equivShrink ((j : J) → F j)).symm f j) (CategoryTheory.Limits.Pi.π F j)","decl":"@[simp]\ntheorem productIso_hom_comp_eval (j : J) :\n    ((productIso.{v, u} F).hom ≫ fun f => (equivShrink (∀ j, F j)).symm f j) = Pi.π F j :=\n  limit.isoLimitCone_hom_π (productLimitCone.{v, u} F) ⟨j⟩\n\n-- Porting note:\n-- `elementwise` seems to be broken. Applied to the previous lemma, it should produce:\n"}
{"name":"CategoryTheory.Limits.Types.Small.productIso_hom_comp_eval_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"J : Type v\nF : J → Type u\ninst✝ : Small.{u, v} J\nj : J\nx : CategoryTheory.Limits.piObj F\n⊢ Eq ((equivShrink ((j : J) → F j)).symm ((CategoryTheory.Limits.Types.Small.productIso F).hom x) j) (CategoryTheory.Limits.Pi.π F j x)","decl":"@[simp]\ntheorem productIso_hom_comp_eval_apply (j : J) (x) :\n    (equivShrink (∀ j, F j)).symm ((productIso F).hom x) j = Pi.π F j x :=\n  congr_fun (productIso_hom_comp_eval F j) x\n\n"}
{"name":"CategoryTheory.Limits.Types.Small.productIso_inv_comp_π_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"J : Type v\nF : J → Type u\ninst✝ : Small.{u, v} J\nj : J\nx : Shrink.{u, max u v} ((j : J) → F j)\n⊢ Eq (CategoryTheory.Limits.Pi.π F j ((CategoryTheory.Limits.Types.Small.productIso F).inv x)) ((equivShrink ((j : J) → F j)).symm x j)","decl":"@[elementwise (attr := simp)]\ntheorem productIso_inv_comp_π (j : J) :\n    (productIso.{v, u} F).inv ≫ Pi.π F j = fun f => ((equivShrink (∀ j, F j)).symm f) j :=\n  limit.isoLimitCone_inv_π (productLimitCone.{v, u} F) ⟨j⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.Small.productIso_inv_comp_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"J : Type v\nF : J → Type u\ninst✝ : Small.{u, v} J\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Types.Small.productIso F).inv (CategoryTheory.Limits.Pi.π F j)) fun f => (equivShrink ((j : J) → F j)).symm f j","decl":"@[elementwise (attr := simp)]\ntheorem productIso_inv_comp_π (j : J) :\n    (productIso.{v, u} F).inv ≫ Pi.π F j = fun f => ((equivShrink (∀ j, F j)).symm f) j :=\n  limit.isoLimitCone_inv_π (productLimitCone.{v, u} F) ⟨j⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.coproductIso_ι_comp_hom_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"J : Type v\nF : J → TypeMax\nj : J\nx : F j\n⊢ Eq ((CategoryTheory.Limits.Types.coproductIso F).hom (CategoryTheory.Limits.Sigma.ι F j x)) ⟨j, x⟩","decl":"@[elementwise (attr := simp)]\ntheorem coproductIso_ι_comp_hom {J : Type v} (F : J → TypeMax.{v, u}) (j : J) :\n    Sigma.ι F j ≫ (coproductIso F).hom = fun x : F j => (⟨j, x⟩ : Σj, F j) :=\n  colimit.isoColimitCocone_ι_hom (coproductColimitCocone F) ⟨j⟩\n\n-- Porting note: was @[elementwise (attr := simp)], but it produces a trivial lemma\n-- removed simp attribute because it seems it never applies\n"}
{"name":"CategoryTheory.Limits.Types.coproductIso_ι_comp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"J : Type v\nF : J → TypeMax\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι F j) (CategoryTheory.Limits.Types.coproductIso F).hom) fun x => ⟨j, x⟩","decl":"@[elementwise (attr := simp)]\ntheorem coproductIso_ι_comp_hom {J : Type v} (F : J → TypeMax.{v, u}) (j : J) :\n    Sigma.ι F j ≫ (coproductIso F).hom = fun x : F j => (⟨j, x⟩ : Σj, F j) :=\n  colimit.isoColimitCocone_ι_hom (coproductColimitCocone F) ⟨j⟩\n\n-- Porting note: was @[elementwise (attr := simp)], but it produces a trivial lemma\n-- removed simp attribute because it seems it never applies\n"}
{"name":"CategoryTheory.Limits.Types.coproductIso_mk_comp_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"J : Type v\nF : J → TypeMax\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.asHom fun x => ⟨j, x⟩) (CategoryTheory.Limits.Types.coproductIso F).inv) (CategoryTheory.Limits.Sigma.ι F j)","decl":"theorem coproductIso_mk_comp_inv {J : Type v} (F : J → TypeMax.{v, u}) (j : J) :\n    (↾fun x : F j => (⟨j, x⟩ : Σj, F j)) ≫ (coproductIso F).inv = Sigma.ι F j :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.unique_of_type_equalizer","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y Z : Type u\nf : Quiver.Hom X Y\ng h : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h)\nt : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fork.ofι f w)\ny : Y\nhy : Eq (g y) (h y)\n⊢ ExistsUnique fun x => Eq (f x) y","decl":"/-- The converse of `type_equalizer_of_unique`. -/\ntheorem unique_of_type_equalizer (t : IsLimit (Fork.ofι _ w)) (y : Y) (hy : g y = h y) :\n    ∃! x : X, f x = y := by\n  let y' : PUnit ⟶ Y := fun _ => y\n  have hy' : y' ≫ g = y' ≫ h := funext fun _ => hy\n  refine ⟨(Fork.IsLimit.lift' t _ hy').1 ⟨⟩, congr_fun (Fork.IsLimit.lift' t y' _).2 ⟨⟩, ?_⟩\n  intro x' hx'\n  suffices (fun _ : PUnit => x') = (Fork.IsLimit.lift' t y' hy').1 by\n    rw [← this]\n  apply Fork.IsLimit.hom_ext t\n  funext ⟨⟩\n  apply hx'.trans (congr_fun (Fork.IsLimit.lift' t _ hy').2 ⟨⟩).symm\n\n"}
{"name":"CategoryTheory.Limits.Types.type_equalizer_iff_unique","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y Z : Type u\nf : Quiver.Hom X Y\ng h : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h)\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fork.ofι f w))) (∀ (y : Y), Eq (g y) (h y) → ExistsUnique fun x => Eq (f x) y)","decl":"theorem type_equalizer_iff_unique :\n    Nonempty (IsLimit (Fork.ofι _ w)) ↔ ∀ y : Y, g y = h y → ∃! x : X, f x = y :=\n  ⟨fun i => unique_of_type_equalizer _ _ (Classical.choice i), fun k =>\n    ⟨typeEqualizerOfUnique f w k⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.equalizerIso_hom_comp_subtype","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"Y Z : Type u\ng h : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Types.equalizerIso g h).hom Subtype.val) (CategoryTheory.Limits.equalizer.ι g h)","decl":"@[simp]\ntheorem equalizerIso_hom_comp_subtype : (equalizerIso g h).hom ≫ Subtype.val = equalizer.ι g h := by\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.equalizerIso_inv_comp_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"Y Z : Type u\ng h : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Types.equalizerIso g h).inv (CategoryTheory.Limits.equalizer.ι g h)) Subtype.val","decl":"@[elementwise (attr := simp)]\ntheorem equalizerIso_inv_comp_ι : (equalizerIso g h).inv ≫ equalizer.ι g h = Subtype.val :=\n  limit.isoLimitCone_inv_π equalizerLimit WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.Limits.Types.equalizerIso_inv_comp_ι_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"Y Z : Type u\ng h : Quiver.Hom Y Z\nx : Subtype fun x => Eq (g x) (h x)\n⊢ Eq (CategoryTheory.Limits.equalizer.ι g h ((CategoryTheory.Limits.Types.equalizerIso g h).inv x)) ↑x","decl":"@[elementwise (attr := simp)]\ntheorem equalizerIso_inv_comp_ι : (equalizerIso g h).inv ≫ equalizer.ι g h = Subtype.val :=\n  limit.isoLimitCone_inv_π equalizerLimit WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.Limits.Types.coequalizer_preimage_image_eq_of_preimage_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y Z : Type u\nf g : Quiver.Hom X Y\nπ : Quiver.Hom Y Z\ne : Eq (CategoryTheory.CategoryStruct.comp f π) (CategoryTheory.CategoryStruct.comp g π)\nh : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.Cofork.ofπ π e)\nU : Set Y\nH : Eq (Set.preimage f U) (Set.preimage g U)\n⊢ Eq (Set.preimage π (Set.image π U)) U","decl":"/-- If `π : Y ⟶ Z` is an equalizer for `(f, g)`, and `U ⊆ Y` such that `f ⁻¹' U = g ⁻¹' U`,\nthen `π ⁻¹' (π '' U) = U`.\n-/\ntheorem coequalizer_preimage_image_eq_of_preimage_eq (π : Y ⟶ Z) (e : f ≫ π = g ≫ π)\n    (h : IsColimit (Cofork.ofπ π e)) (U : Set Y) (H : f ⁻¹' U = g ⁻¹' U) : π ⁻¹' (π '' U) = U := by\n  have lem : ∀ x y, CoequalizerRel f g x y → (x ∈ U ↔ y ∈ U) := by\n    rintro _ _ ⟨x⟩\n    change x ∈ f ⁻¹' U ↔ x ∈ g ⁻¹' U\n    rw [H]\n  -- Porting note: tidy was able to fill the structure automatically\n  have eqv : _root_.Equivalence fun x y => x ∈ U ↔ y ∈ U :=\n    { refl := by tauto\n      symm := by tauto\n      trans := by tauto }\n  ext\n  constructor\n  · rw [←\n      show _ = π from\n        h.comp_coconePointUniqueUpToIso_inv (coequalizerColimit f g).2\n          WalkingParallelPair.one]\n    rintro ⟨y, hy, e'⟩\n    dsimp at e'\n    replace e' :=\n      (mono_iff_injective\n            (h.coconePointUniqueUpToIso (coequalizerColimit f g).isColimit).inv).mp\n        inferInstance e'\n    exact (eqv.eqvGen_iff.mp (Relation.EqvGen.mono lem (Quot.eqvGen_exact e'))).mp hy\n  · exact fun hx => ⟨_, hx, rfl⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.coequalizerIso_π_comp_hom_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\nf g : Quiver.Hom X Y\nx : Y\n⊢ Eq ((CategoryTheory.Limits.Types.coequalizerIso f g).hom (CategoryTheory.Limits.coequalizer.π f g x)) (Quot.mk (CategoryTheory.Limits.Types.CoequalizerRel f g) x)","decl":"@[elementwise (attr := simp)]\ntheorem coequalizerIso_π_comp_hom :\n    coequalizer.π f g ≫ (coequalizerIso f g).hom = Quot.mk (CoequalizerRel f g) :=\n  colimit.isoColimitCocone_ι_hom (coequalizerColimit f g) WalkingParallelPair.one\n\n-- Porting note: was @[elementwise], but it produces a trivial lemma\n"}
{"name":"CategoryTheory.Limits.Types.coequalizerIso_π_comp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\nf g : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.π f g) (CategoryTheory.Limits.Types.coequalizerIso f g).hom) (Quot.mk (CategoryTheory.Limits.Types.CoequalizerRel f g))","decl":"@[elementwise (attr := simp)]\ntheorem coequalizerIso_π_comp_hom :\n    coequalizer.π f g ≫ (coequalizerIso f g).hom = Quot.mk (CoequalizerRel f g) :=\n  colimit.isoColimitCocone_ι_hom (coequalizerColimit f g) WalkingParallelPair.one\n\n-- Porting note: was @[elementwise], but it produces a trivial lemma\n"}
{"name":"CategoryTheory.Limits.Types.coequalizerIso_quot_comp_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y : Type u\nf g : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.asHom (Quot.mk (CategoryTheory.Limits.Types.CoequalizerRel f g))) (CategoryTheory.Limits.Types.coequalizerIso f g).inv) (CategoryTheory.Limits.coequalizer.π f g)","decl":"@[simp]\ntheorem coequalizerIso_quot_comp_inv :\n    ↾Quot.mk (CoequalizerRel f g) ≫ (coequalizerIso f g).inv = coequalizer.π f g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.instHasPullbacksType","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"⊢ CategoryTheory.Limits.HasPullbacks (Type u)","decl":"instance : HasPullbacks.{u} (Type u) :=\n  -- FIXME does not work via `inferInstance` despite `#synth HasPullbacks.{u} (Type u)` succeeding.\n  -- https://github.com/leanprover-community/mathlib4/issues/5752\n  -- inferInstance\n  hasPullbacks_of_hasWidePullbacks.{u} (Type u)\n\n"}
{"name":"CategoryTheory.Limits.Types.instHasPushoutsType","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"⊢ CategoryTheory.Limits.HasPushouts (Type u)","decl":"instance : HasPushouts.{u} (Type u) :=\n  hasPushouts_of_hasWidePushouts.{u} (Type u)\n\n"}
{"name":"CategoryTheory.Limits.Types.pullbackLimitCone_isLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y Z : Type u\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.Limits.Types.pullbackLimitCone f g).isLimit ((CategoryTheory.Limits.Types.pullbackCone f g).isLimitAux (fun s x => ⟨{ fst := s.fst x, snd := s.snd x }, ⋯⟩) ⋯ ⋯ ⋯)","decl":"/-- The explicit pullback in the category of types, bundled up as a `LimitCone`\nfor given `f` and `g`.\n-/\n@[simps]\ndef pullbackLimitCone (f : X ⟶ Z) (g : Y ⟶ Z) : Limits.LimitCone (cospan f g) where\n  cone := pullbackCone f g\n  isLimit :=\n    PullbackCone.isLimitAux _ (fun s x => ⟨⟨s.fst x, s.snd x⟩, congr_fun s.condition x⟩)\n      (by aesop) (by aesop) fun _ _ w =>\n      funext fun x =>\n        Subtype.ext <|\n          Prod.ext (congr_fun (w WalkingCospan.left) x) (congr_fun (w WalkingCospan.right) x)\n\n"}
{"name":"CategoryTheory.Limits.Types.pullbackLimitCone_cone","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y Z : Type u\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.Limits.Types.pullbackLimitCone f g).cone (CategoryTheory.Limits.Types.pullbackCone f g)","decl":"/-- The explicit pullback in the category of types, bundled up as a `LimitCone`\nfor given `f` and `g`.\n-/\n@[simps]\ndef pullbackLimitCone (f : X ⟶ Z) (g : Y ⟶ Z) : Limits.LimitCone (cospan f g) where\n  cone := pullbackCone f g\n  isLimit :=\n    PullbackCone.isLimitAux _ (fun s x => ⟨⟨s.fst x, s.snd x⟩, congr_fun s.condition x⟩)\n      (by aesop) (by aesop) fun _ _ w =>\n      funext fun x =>\n        Subtype.ext <|\n          Prod.ext (congr_fun (w WalkingCospan.left) x) (congr_fun (w WalkingCospan.right) x)\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.IsLimit.equivPullbackObj_apply_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y S : Type v\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nc : CategoryTheory.Limits.PullbackCone f g\nhc : CategoryTheory.Limits.IsLimit c\nx : c.pt\n⊢ Eq (↑((CategoryTheory.Limits.PullbackCone.IsLimit.equivPullbackObj hc) x)).1 (c.fst x)","decl":"@[simp]\nlemma equivPullbackObj_apply_fst (x : c.pt) : (equivPullbackObj hc x).1.1 = c.fst x :=\n  congr_fun (IsLimit.conePointUniqueUpToIso_hom_comp hc\n    (Types.pullbackLimitCone f g).isLimit .left) x\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.IsLimit.equivPullbackObj_apply_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y S : Type v\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nc : CategoryTheory.Limits.PullbackCone f g\nhc : CategoryTheory.Limits.IsLimit c\nx : c.pt\n⊢ Eq (↑((CategoryTheory.Limits.PullbackCone.IsLimit.equivPullbackObj hc) x)).2 (c.snd x)","decl":"@[simp]\nlemma equivPullbackObj_apply_snd (x : c.pt) : (equivPullbackObj hc x).1.2 = c.snd x :=\n  congr_fun (IsLimit.conePointUniqueUpToIso_hom_comp hc\n    (Types.pullbackLimitCone f g).isLimit .right) x\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.IsLimit.equivPullbackObj_symm_apply_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y S : Type v\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nc : CategoryTheory.Limits.PullbackCone f g\nhc : CategoryTheory.Limits.IsLimit c\nx : CategoryTheory.Limits.Types.PullbackObj f g\n⊢ Eq (c.fst ((CategoryTheory.Limits.PullbackCone.IsLimit.equivPullbackObj hc).symm x)) (↑x).1","decl":"@[simp]\nlemma equivPullbackObj_symm_apply_fst (x : Types.PullbackObj f g) :\n    c.fst ((equivPullbackObj hc).symm x) = x.1.1 := by\n  obtain ⟨x, rfl⟩ := (equivPullbackObj hc).surjective x\n  simp\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.IsLimit.equivPullbackObj_symm_apply_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y S : Type v\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nc : CategoryTheory.Limits.PullbackCone f g\nhc : CategoryTheory.Limits.IsLimit c\nx : CategoryTheory.Limits.Types.PullbackObj f g\n⊢ Eq (c.snd ((CategoryTheory.Limits.PullbackCone.IsLimit.equivPullbackObj hc).symm x)) (↑x).2","decl":"@[simp]\nlemma equivPullbackObj_symm_apply_snd (x : Types.PullbackObj f g) :\n    c.snd ((equivPullbackObj hc).symm x) = x.1.2 := by\n  obtain ⟨x, rfl⟩ := (equivPullbackObj hc).surjective x\n  simp\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.IsLimit.type_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y S : Type v\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nc : CategoryTheory.Limits.PullbackCone f g\nhc : CategoryTheory.Limits.IsLimit c\nx y : c.pt\nh₁ : Eq (c.fst x) (c.fst y)\nh₂ : Eq (c.snd x) (c.snd y)\n⊢ Eq x y","decl":"include hc in\nlemma type_ext {x y : c.pt} (h₁ : c.fst x = c.fst y) (h₂ : c.snd x = c.snd y) : x = y :=\n  (equivPullbackObj hc).injective (by ext <;> assumption)\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.toPullbackObj_coe_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y S : Type v\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nc : CategoryTheory.Limits.PullbackCone f g\nx : c.pt\n⊢ Eq (↑(c.toPullbackObj x)).1 (c.fst x)","decl":"/-- Given `c : PullbackCone f g` in the category of types, this is\nthe canonical map `c.pt → Types.PullbackObj f g`. -/\n@[simps coe_fst coe_snd]\ndef toPullbackObj (x : c.pt) : Types.PullbackObj f g :=\n  ⟨⟨c.fst x, c.snd x⟩, congr_fun c.condition x⟩\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.toPullbackObj_coe_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y S : Type v\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nc : CategoryTheory.Limits.PullbackCone f g\nx : c.pt\n⊢ Eq (↑(c.toPullbackObj x)).2 (c.snd x)","decl":"/-- Given `c : PullbackCone f g` in the category of types, this is\nthe canonical map `c.pt → Types.PullbackObj f g`. -/\n@[simps coe_fst coe_snd]\ndef toPullbackObj (x : c.pt) : Types.PullbackObj f g :=\n  ⟨⟨c.fst x, c.snd x⟩, congr_fun c.condition x⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.pullbackIsoPullback_hom_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y Z : Type u\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\np : CategoryTheory.Limits.pullback f g\n⊢ Eq (↑((CategoryTheory.Limits.Types.pullbackIsoPullback f g).hom p)).1 (CategoryTheory.Limits.pullback.fst f g p)","decl":"@[simp]\ntheorem pullbackIsoPullback_hom_fst (p : pullback f g) :\n    ((pullbackIsoPullback f g).hom p : X × Y).fst = (pullback.fst f g) p :=\n  PullbackCone.IsLimit.equivPullbackObj_apply_fst (pullbackIsPullback f g) p\n\n"}
{"name":"CategoryTheory.Limits.Types.pullbackIsoPullback_hom_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y Z : Type u\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\np : CategoryTheory.Limits.pullback f g\n⊢ Eq (↑((CategoryTheory.Limits.Types.pullbackIsoPullback f g).hom p)).2 (CategoryTheory.Limits.pullback.snd f g p)","decl":"@[simp]\ntheorem pullbackIsoPullback_hom_snd (p : pullback f g) :\n    ((pullbackIsoPullback f g).hom p : X × Y).snd = (pullback.snd f g) p :=\n  PullbackCone.IsLimit.equivPullbackObj_apply_snd (pullbackIsPullback f g) p\n\n"}
{"name":"CategoryTheory.Limits.Types.pullbackIsoPullback_inv_fst_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y Z : Type u\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : (CategoryTheory.Limits.Types.pullbackCone f g).pt\n⊢ Eq (CategoryTheory.Limits.pullback.fst f g ((CategoryTheory.Limits.Types.pullbackIsoPullback f g).inv x)) ((fun p => (↑p).1) x)","decl":"@[simp]\ntheorem pullbackIsoPullback_inv_fst_apply (x : (Types.pullbackCone f g).pt) :\n    (pullback.fst f g) ((pullbackIsoPullback f g).inv x) = (fun p => (p.1 : X × Y).fst) x :=\n  PullbackCone.IsLimit.equivPullbackObj_symm_apply_fst (pullbackIsPullback f g) x\n\n"}
{"name":"CategoryTheory.Limits.Types.pullbackIsoPullback_inv_snd_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y Z : Type u\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : (CategoryTheory.Limits.Types.pullbackCone f g).pt\n⊢ Eq (CategoryTheory.Limits.pullback.snd f g ((CategoryTheory.Limits.Types.pullbackIsoPullback f g).inv x)) ((fun p => (↑p).2) x)","decl":"@[simp]\ntheorem pullbackIsoPullback_inv_snd_apply (x : (Types.pullbackCone f g).pt) :\n    (pullback.snd f g) ((pullbackIsoPullback f g).inv x) = (fun p => (p.1 : X × Y).snd) x :=\n  PullbackCone.IsLimit.equivPullbackObj_symm_apply_snd (pullbackIsPullback f g) x\n\n"}
{"name":"CategoryTheory.Limits.Types.pullbackIsoPullback_inv_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y Z : Type u\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Types.pullbackIsoPullback f g).inv (CategoryTheory.Limits.pullback.fst f g)) fun p => (↑p).1","decl":"@[simp]\ntheorem pullbackIsoPullback_inv_fst :\n    (pullbackIsoPullback f g).inv ≫ pullback.fst _ _ = fun p => (p.1 : X × Y).fst := by aesop\n\n"}
{"name":"CategoryTheory.Limits.Types.pullbackIsoPullback_inv_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"X Y Z : Type u\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Types.pullbackIsoPullback f g).inv (CategoryTheory.Limits.pullback.snd f g)) fun p => (↑p).2","decl":"@[simp]\ntheorem pullbackIsoPullback_inv_snd :\n    (pullbackIsoPullback f g).inv ≫ pullback.snd _ _ = fun p => (p.1 : X × Y).snd := by aesop\n\n"}
{"name":"CategoryTheory.Limits.Types.Pushout.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"S X₁ X₂ : Type u\nf : Quiver.Hom S X₁\ng : Quiver.Hom S X₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Types.Pushout.inl f g)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.Types.Pushout.inr f g))","decl":"lemma condition : f ≫ inl f g = g ≫ inr f g := by\n  ext x\n  exact Quot.sound (Rel.inl_inr x)\n\n"}
{"name":"CategoryTheory.Limits.Types.Pushout.cocone_ι_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"S X₁ X₂ : Type u\nf : Quiver.Hom S X₁\ng : Quiver.Hom S X₂\nj : CategoryTheory.Limits.WalkingSpan\na✝ : (CategoryTheory.Limits.span f g).obj j\n⊢ Eq ((CategoryTheory.Limits.Types.Pushout.cocone f g).ι.app j a✝) (Option.rec (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Types.Pushout.inl f g)) (fun val => CategoryTheory.Limits.WalkingPair.rec (CategoryTheory.Limits.Types.Pushout.inl f g) (CategoryTheory.Limits.Types.Pushout.inr f g) val) j a✝)","decl":"/-- The constructed pushout cocone in the category of types. -/\n@[simps!]\ndef cocone : PushoutCocone f g := PushoutCocone.mk _ _ (condition f g)\n\n"}
{"name":"CategoryTheory.Limits.Types.Pushout.cocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"S X₁ X₂ : Type u\nf : Quiver.Hom S X₁\ng : Quiver.Hom S X₂\n⊢ Eq (CategoryTheory.Limits.Types.Pushout.cocone f g).pt (CategoryTheory.Limits.Types.Pushout f g)","decl":"/-- The constructed pushout cocone in the category of types. -/\n@[simps!]\ndef cocone : PushoutCocone f g := PushoutCocone.mk _ _ (condition f g)\n\n"}
{"name":"CategoryTheory.Limits.Types.Pushout.inl_rel'_inl_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"S X₁ X₂ : Type u\nf : Quiver.Hom S X₁\ng : Quiver.Hom S X₂\nx₁ y₁ : X₁\n⊢ Iff (CategoryTheory.Limits.Types.Pushout.Rel' f g (Sum.inl x₁) (Sum.inl y₁)) (Or (Eq x₁ y₁) (Exists fun x₀ => Exists fun y₀ => Exists fun x => And (Eq x₁ (f x₀)) (Eq y₁ (f y₀))))","decl":"@[simp]\nlemma inl_rel'_inl_iff (x₁ y₁ : X₁) :\n    Rel' f g (Sum.inl x₁) (Sum.inl y₁) ↔ x₁ = y₁ ∨\n      ∃ (x₀ y₀ : S) (_ : g x₀ = g y₀), x₁ = f x₀ ∧ y₁ = f y₀ := by\n  constructor\n  · rintro (_|⟨_, _, h⟩)\n    · exact Or.inl rfl\n    · exact Or.inr ⟨_, _, h, rfl, rfl⟩\n  · rintro (rfl | ⟨_,_ , h, rfl, rfl⟩)\n    · apply Rel'.refl\n    · exact Rel'.inl_inl _ _ h\n\n"}
{"name":"CategoryTheory.Limits.Types.Pushout.inl_rel'_inr_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"S X₁ X₂ : Type u\nf : Quiver.Hom S X₁\ng : Quiver.Hom S X₂\nx₁ : X₁\nx₂ : X₂\n⊢ Iff (CategoryTheory.Limits.Types.Pushout.Rel' f g (Sum.inl x₁) (Sum.inr x₂)) (Exists fun s => And (Eq x₁ (f s)) (Eq x₂ (g s)))","decl":"@[simp]\nlemma inl_rel'_inr_iff (x₁ : X₁) (x₂ : X₂) :\n    Rel' f g (Sum.inl x₁) (Sum.inr x₂) ↔\n      ∃ (s : S), x₁ = f s ∧ x₂ = g s := by\n  constructor\n  · rintro ⟨_⟩\n    exact ⟨_, rfl, rfl⟩\n  · rintro ⟨s, rfl, rfl⟩\n    exact Rel'.inl_inr _\n\n"}
{"name":"CategoryTheory.Limits.Types.Pushout.inr_rel'_inr_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"S X₁ X₂ : Type u\nf : Quiver.Hom S X₁\ng : Quiver.Hom S X₂\nx₂ y₂ : X₂\n⊢ Iff (CategoryTheory.Limits.Types.Pushout.Rel' f g (Sum.inr x₂) (Sum.inr y₂)) (Eq x₂ y₂)","decl":"@[simp]\nlemma inr_rel'_inr_iff (x₂ y₂ : X₂) :\n    Rel' f g (Sum.inr x₂) (Sum.inr y₂) ↔ x₂ = y₂ := by\n  constructor\n  · rintro ⟨_⟩\n    rfl\n  · rintro rfl\n    apply Rel'.refl\n\n"}
{"name":"CategoryTheory.Limits.Types.Pushout.Rel'.symm","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"S X₁ X₂ : Type u\nf : Quiver.Hom S X₁\ng : Quiver.Hom S X₂\nx y : Sum X₁ X₂\nh : CategoryTheory.Limits.Types.Pushout.Rel' f g x y\n⊢ CategoryTheory.Limits.Types.Pushout.Rel' f g y x","decl":"lemma Rel'.symm {x y : X₁ ⊕ X₂} (h : Rel' f g x y) :\n    Rel' f g y x := by\n  obtain _|⟨_, _, h⟩|_|_ := h\n  · apply Rel'.refl\n  · exact Rel'.inl_inl _ _ h.symm\n  · exact Rel'.inr_inl _\n  · exact Rel'.inl_inr _\n\n"}
{"name":"CategoryTheory.Limits.Types.Pushout.equivalence_rel'","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"S X₁ X₂ : Type u\nf : Quiver.Hom S X₁\ng : Quiver.Hom S X₂\ninst✝ : CategoryTheory.Mono f\n⊢ Equivalence (CategoryTheory.Limits.Types.Pushout.Rel' f g)","decl":"lemma equivalence_rel' [Mono f] : _root_.Equivalence (Rel' f g) where\n  refl := Rel'.refl\n  symm h := h.symm\n  trans := by\n    rintro x y z (_|⟨_, _, h⟩|s|_) hyz\n    · exact hyz\n    · obtain z₁|z₂ := z\n      · rw [inl_rel'_inl_iff] at hyz\n        obtain rfl|⟨_, _, h', h'', rfl⟩ := hyz\n        · exact Rel'.inl_inl _ _ h\n        · obtain rfl := (mono_iff_injective f).1 inferInstance h''\n          exact Rel'.inl_inl _ _ (h.trans h')\n      · rw [inl_rel'_inr_iff] at hyz\n        obtain ⟨s, hs, rfl⟩ := hyz\n        obtain rfl := (mono_iff_injective f).1 inferInstance hs\n        rw [← h]\n        apply Rel'.inl_inr\n    · obtain z₁|z₂ := z\n      · replace hyz := hyz.symm\n        rw [inl_rel'_inr_iff] at hyz\n        obtain ⟨s', rfl, hs'⟩ := hyz\n        exact Rel'.inl_inl _ _ hs'\n      · rw [inr_rel'_inr_iff] at hyz\n        subst hyz\n        apply Rel'.inl_inr\n    · obtain z₁|z₂ := z\n      · rw [inl_rel'_inl_iff] at hyz\n        obtain rfl|⟨_, _, h, h', rfl⟩  := hyz\n        · apply Rel'.inr_inl\n        · obtain rfl := (mono_iff_injective f).1 inferInstance h'\n          rw [h]\n          apply Rel'.inr_inl\n      · rw [inl_rel'_inr_iff] at hyz\n        obtain ⟨s, hs, rfl⟩ := hyz\n        obtain rfl := (mono_iff_injective f).1 inferInstance hs\n        apply Rel'.refl\n\n"}
{"name":"CategoryTheory.Limits.Types.Pushout.quot_mk_eq_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"S X₁ X₂ : Type u\nf : Quiver.Hom S X₁\ng : Quiver.Hom S X₂\ninst✝ : CategoryTheory.Mono f\na b : Sum X₁ X₂\n⊢ Iff (Eq (Quot.mk (CategoryTheory.Limits.Types.Pushout.Rel f g) a) (Quot.mk (CategoryTheory.Limits.Types.Pushout.Rel f g) b)) (CategoryTheory.Limits.Types.Pushout.Rel' f g a b)","decl":"lemma quot_mk_eq_iff [Mono f] (a b : X₁ ⊕ X₂) :\n    (Quot.mk _ a : Pushout f g) = Quot.mk _ b ↔ Rel' f g a b := by\n  rw [← (equivalence_rel' f g).quot_mk_eq_iff]\n  exact ⟨fun h => (equivPushout' f g).symm.injective h,\n    fun h => (equivPushout' f g).injective h⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.Pushout.inl_eq_inr_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"S X₁ X₂ : Type u\nf : Quiver.Hom S X₁\ng : Quiver.Hom S X₂\ninst✝ : CategoryTheory.Mono f\nx₁ : X₁\nx₂ : X₂\n⊢ Iff (Eq (CategoryTheory.Limits.Types.Pushout.inl f g x₁) (CategoryTheory.Limits.Types.Pushout.inr f g x₂)) (Exists fun s => And (Eq (f s) x₁) (Eq (g s) x₂))","decl":"lemma inl_eq_inr_iff [Mono f] (x₁ : X₁) (x₂ : X₂) :\n    (inl f g x₁ = inr f g x₂) ↔\n      ∃ (s : S), f s = x₁ ∧ g s = x₂ := by\n  refine (Pushout.quot_mk_eq_iff f g (Sum.inl x₁) (Sum.inr x₂)).trans ?_\n  constructor\n  · rintro ⟨⟩\n    exact ⟨_, rfl, rfl⟩\n  · rintro ⟨s, rfl, rfl⟩\n    apply Rel'.inl_inr\n\n"}
{"name":"CategoryTheory.Limits.Types.pushoutCocone_inl_eq_inr_imp_of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"S X₁ X₂ : Type u\nf : Quiver.Hom S X₁\ng : Quiver.Hom S X₂\nc c' : CategoryTheory.Limits.PushoutCocone f g\ne : CategoryTheory.Iso c c'\nx₁ : X₁\nx₂ : X₂\nh : Eq (c.inl x₁) (c.inr x₂)\n⊢ Eq (c'.inl x₁) (c'.inr x₂)","decl":"lemma pushoutCocone_inl_eq_inr_imp_of_iso {c c' : PushoutCocone f g} (e : c ≅ c')\n    (x₁ : X₁) (x₂ : X₂) (h : c.inl x₁ = c.inr x₂) :\n    c'.inl x₁ = c'.inr x₂ := by\n  convert congr_arg e.hom.hom h\n  · exact congr_fun (e.hom.w WalkingSpan.left).symm x₁\n  · exact congr_fun (e.hom.w WalkingSpan.right).symm x₂\n\n"}
{"name":"CategoryTheory.Limits.Types.pushoutCocone_inl_eq_inr_iff_of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"S X₁ X₂ : Type u\nf : Quiver.Hom S X₁\ng : Quiver.Hom S X₂\nc c' : CategoryTheory.Limits.PushoutCocone f g\ne : CategoryTheory.Iso c c'\nx₁ : X₁\nx₂ : X₂\n⊢ Iff (Eq (c.inl x₁) (c.inr x₂)) (Eq (c'.inl x₁) (c'.inr x₂))","decl":"lemma pushoutCocone_inl_eq_inr_iff_of_iso {c c' : PushoutCocone f g} (e : c ≅ c')\n    (x₁ : X₁) (x₂ : X₂) :\n    c.inl x₁ = c.inr x₂ ↔ c'.inl x₁ = c'.inr x₂ := by\n  constructor\n  · apply pushoutCocone_inl_eq_inr_imp_of_iso e\n  · apply pushoutCocone_inl_eq_inr_imp_of_iso e.symm\n\n"}
{"name":"CategoryTheory.Limits.Types.pushoutCocone_inl_eq_inr_iff_of_isColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"S X₁ X₂ : Type u\nf : Quiver.Hom S X₁\ng : Quiver.Hom S X₂\nc : CategoryTheory.Limits.PushoutCocone f g\nhc : CategoryTheory.Limits.IsColimit c\nh₁ : Function.Injective f\nx₁ : X₁\nx₂ : X₂\n⊢ Iff (Eq (c.inl x₁) (c.inr x₂)) (Exists fun s => And (Eq (f s) x₁) (Eq (g s) x₂))","decl":"lemma pushoutCocone_inl_eq_inr_iff_of_isColimit {c : PushoutCocone f g} (hc : IsColimit c)\n    (h₁ : Function.Injective f) (x₁ : X₁) (x₂ : X₂) :\n    c.inl x₁ = c.inr x₂ ↔ ∃ (s : S), f s = x₁ ∧ g s = x₂ := by\n  rw [pushoutCocone_inl_eq_inr_iff_of_iso\n    (Cocones.ext (IsColimit.coconePointUniqueUpToIso hc (Pushout.isColimitCocone f g))\n    (by simp))]\n  have := (mono_iff_injective f).2 h₁\n  apply Pushout.inl_eq_inr_iff\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.sections.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"I : CategoryTheory.Limits.MulticospanIndex (Type u)\nval✝ : (i : I.L) → I.left i\nproperty✝ : ∀ (r : I.R), Eq (I.fst r (val✝ (I.fstTo r))) (I.snd r (val✝ (I.sndTo r)))\nval : (i : I.L) → I.left i\nproperty : ∀ (r : I.R), Eq (I.fst r (val (I.fstTo r))) (I.snd r (val (I.sndTo r)))\n⊢ Eq (Eq { val := val✝, property := property✝ } { val := val, property := property }) (Eq val✝ val)","decl":"/-- Given `I : MulticospanIndex (Type u)`, this is a type which identifies\nto the sections of the functor `I.multicospan`. -/\n@[ext]\nstructure MulticospanIndex.sections where\n  /-- The data of an element in `I.left i` for each `i : I.L`. -/\n  val (i : I.L) : I.left i\n  property (r : I.R) : I.fst r (val _) = I.snd r (val _)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.sections.property","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"I : CategoryTheory.Limits.MulticospanIndex (Type u)\nself : I.sections\nr : I.R\n⊢ Eq (I.fst r (self.val (I.fstTo r))) (I.snd r (self.val (I.sndTo r)))","decl":"/-- Given `I : MulticospanIndex (Type u)`, this is a type which identifies\nto the sections of the functor `I.multicospan`. -/\n@[ext]\nstructure MulticospanIndex.sections where\n  /-- The data of an element in `I.left i` for each `i : I.L`. -/\n  val (i : I.L) : I.left i\n  property (r : I.R) : I.fst r (val _) = I.snd r (val _)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.sections.mk.inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"I : CategoryTheory.Limits.MulticospanIndex (Type u)\nval✝ : (i : I.L) → I.left i\nproperty✝ : ∀ (r : I.R), Eq (I.fst r (val✝ (I.fstTo r))) (I.snd r (val✝ (I.sndTo r)))\nval : (i : I.L) → I.left i\nproperty : ∀ (r : I.R), Eq (I.fst r (val (I.fstTo r))) (I.snd r (val (I.sndTo r)))\nx✝ : Eq { val := val✝, property := property✝ } { val := val, property := property }\n⊢ Eq val✝ val","decl":"/-- Given `I : MulticospanIndex (Type u)`, this is a type which identifies\nto the sections of the functor `I.multicospan`. -/\n@[ext]\nstructure MulticospanIndex.sections where\n  /-- The data of an element in `I.left i` for each `i : I.L`. -/\n  val (i : I.L) : I.left i\n  property (r : I.R) : I.fst r (val _) = I.snd r (val _)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.sections.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"I : CategoryTheory.Limits.MulticospanIndex (Type u)\nx y : I.sections\nval : Eq x.val y.val\n⊢ Eq x y","decl":"/-- Given `I : MulticospanIndex (Type u)`, this is a type which identifies\nto the sections of the functor `I.multicospan`. -/\n@[ext]\nstructure MulticospanIndex.sections where\n  /-- The data of an element in `I.left i` for each `i : I.L`. -/\n  val (i : I.L) : I.left i\n  property (r : I.R) : I.fst r (val _) = I.snd r (val _)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.sections.ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"I : CategoryTheory.Limits.MulticospanIndex (Type u)\nx y : I.sections\n⊢ Iff (Eq x y) (Eq x.val y.val)","decl":"/-- Given `I : MulticospanIndex (Type u)`, this is a type which identifies\nto the sections of the functor `I.multicospan`. -/\n@[ext]\nstructure MulticospanIndex.sections where\n  /-- The data of an element in `I.left i` for each `i : I.L`. -/\n  val (i : I.L) : I.left i\n  property (r : I.R) : I.fst r (val _) = I.snd r (val _)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.sections.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"I : CategoryTheory.Limits.MulticospanIndex (Type u)\nval : (i : I.L) → I.left i\nproperty : ∀ (r : I.R), Eq (I.fst r (val (I.fstTo r))) (I.snd r (val (I.sndTo r)))\n⊢ Eq (SizeOf.sizeOf { val := val, property := property }) 1","decl":"/-- Given `I : MulticospanIndex (Type u)`, this is a type which identifies\nto the sections of the functor `I.multicospan`. -/\n@[ext]\nstructure MulticospanIndex.sections where\n  /-- The data of an element in `I.left i` for each `i : I.L`. -/\n  val (i : I.L) : I.left i\n  property (r : I.R) : I.fst r (val _) = I.snd r (val _)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.sectionsEquiv_symm_apply_val","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"I : CategoryTheory.Limits.MulticospanIndex (Type u)\ns : ↑I.multicospan.sections\ni : I.L\n⊢ Eq ((I.sectionsEquiv.symm s).val i) (↑s (CategoryTheory.Limits.WalkingMulticospan.left i))","decl":"/-- The bijection `I.sections ≃ I.multicospan.sections` when `I : MulticospanIndex (Type u)`\nis a multiequalizer diagram in the category of types. -/\n@[simps]\ndef MulticospanIndex.sectionsEquiv :\n    I.sections ≃ I.multicospan.sections where\n  toFun s :=\n    { val := fun i ↦ match i with\n        | .left i => s.val i\n        | .right j => I.fst j (s.val _)\n      property := by\n        rintro _ _ (_|_|r)\n        · rfl\n        · rfl\n        · exact (s.property r).symm }\n  invFun s :=\n    { val := fun i ↦ s.val (.left i)\n      property := fun r ↦ (s.property (.fst r)).trans (s.property (.snd r)).symm }\n  left_inv _ := rfl\n  right_inv s := by\n    ext (_|r)\n    · rfl\n    · exact s.property (.fst r)\n\n"}
{"name":"CategoryTheory.Limits.MulticospanIndex.sectionsEquiv_apply_coe","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"I : CategoryTheory.Limits.MulticospanIndex (Type u)\ns : I.sections\ni : CategoryTheory.Limits.WalkingMulticospan I.fstTo I.sndTo\n⊢ Eq (↑(I.sectionsEquiv s) i) (CategoryTheory.Limits.MulticospanIndex.sectionsEquiv.match_1 I (fun i => I.multicospan.obj i) i (fun i => s.val i) fun j => I.fst j (s.val (I.fstTo j)))","decl":"/-- The bijection `I.sections ≃ I.multicospan.sections` when `I : MulticospanIndex (Type u)`\nis a multiequalizer diagram in the category of types. -/\n@[simps]\ndef MulticospanIndex.sectionsEquiv :\n    I.sections ≃ I.multicospan.sections where\n  toFun s :=\n    { val := fun i ↦ match i with\n        | .left i => s.val i\n        | .right j => I.fst j (s.val _)\n      property := by\n        rintro _ _ (_|_|r)\n        · rfl\n        · rfl\n        · exact (s.property r).symm }\n  invFun s :=\n    { val := fun i ↦ s.val (.left i)\n      property := fun r ↦ (s.property (.fst r)).trans (s.property (.snd r)).symm }\n  left_inv _ := rfl\n  right_inv s := by\n    ext (_|r)\n    · rfl\n    · exact s.property (.fst r)\n\n"}
{"name":"CategoryTheory.Limits.Multifork.toSections_val","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"I : CategoryTheory.Limits.MulticospanIndex (Type u)\nc : CategoryTheory.Limits.Multifork I\nx : c.pt\ni : I.L\n⊢ Eq ((c.toSections x).val i) (c.ι i x)","decl":"/-- Given a multiequalizer diagram `I : MulticospanIndex (Type u)` in the category of\ntypes and `c` a multifork for `I`, this is the canonical map `c.pt → I.sections`. -/\n@[simps]\ndef toSections (x : c.pt) : I.sections where\n  val i := c.ι i x\n  property r := congr_fun (c.condition r) x\n\n"}
{"name":"CategoryTheory.Limits.Multifork.toSections_fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"I : CategoryTheory.Limits.MulticospanIndex (Type u)\nc : CategoryTheory.Limits.Multifork I\n⊢ Eq (Function.comp (⇑I.sectionsEquiv.symm) (CategoryTheory.Limits.Types.sectionOfCone c)) c.toSections","decl":"lemma toSections_fac : I.sectionsEquiv.symm ∘ Types.sectionOfCone c = c.toSections := rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.isLimit_types_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"I : CategoryTheory.Limits.MulticospanIndex (Type u)\nc : CategoryTheory.Limits.Multifork I\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsLimit c)) (Function.Bijective c.toSections)","decl":"/-- A multifork `c : Multifork I` in the category of types is limit iff the\nmap `c.toSections : c.pt → I.sections` is a bijection. -/\nlemma isLimit_types_iff : Nonempty (IsLimit c) ↔ Function.Bijective c.toSections := by\n  rw [Types.isLimit_iff_bijective_sectionOfCone, ← toSections_fac, EquivLike.comp_bijective]\n\n"}
{"name":"CategoryTheory.Limits.Multifork.IsLimit.sectionsEquiv_symm_apply_val","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"I : CategoryTheory.Limits.MulticospanIndex (Type u)\nc : CategoryTheory.Limits.Multifork I\nhc : CategoryTheory.Limits.IsLimit c\nx : c.pt\ni : I.L\n⊢ Eq (((CategoryTheory.Limits.Multifork.IsLimit.sectionsEquiv hc).symm x).val i) (c.ι i x)","decl":"@[simp]\nlemma sectionsEquiv_symm_apply_val (x : c.pt) (i : I.L) :\n    ((sectionsEquiv hc).symm x).val i = c.ι i x := rfl\n\n"}
{"name":"CategoryTheory.Limits.Multifork.IsLimit.sectionsEquiv_apply_val","module":"Mathlib.CategoryTheory.Limits.Shapes.Types","initialProofState":"I : CategoryTheory.Limits.MulticospanIndex (Type u)\nc : CategoryTheory.Limits.Multifork I\nhc : CategoryTheory.Limits.IsLimit c\ns : I.sections\ni : I.L\n⊢ Eq (c.ι i ((CategoryTheory.Limits.Multifork.IsLimit.sectionsEquiv hc) s)) (s.val i)","decl":"@[simp]\nlemma sectionsEquiv_apply_val (s : I.sections) (i : I.L) :\n    c.ι i (sectionsEquiv hc s) = s.val i := by\n  obtain ⟨x, rfl⟩ := (sectionsEquiv hc).symm.surjective s\n  simp\n\n"}
