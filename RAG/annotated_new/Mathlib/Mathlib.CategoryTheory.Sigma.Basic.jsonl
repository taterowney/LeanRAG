{"name":"CategoryTheory.Sigma.SigmaHom.mk.injEq","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\ni : I\nX Y : C i\na‚úù¬π a‚úù : Quiver.Hom X Y\n‚ä¢ Eq (Eq (CategoryTheory.Sigma.SigmaHom.mk a‚úù¬π) (CategoryTheory.Sigma.SigmaHom.mk a‚úù)) (Eq a‚úù¬π a‚úù)","decl":"/-- The type of morphisms of a disjoint union of categories: for `X : C i` and `Y : C j`, a morphism\n`(i, X) ‚ü∂ (j, Y)` if `i = j` is just a morphism `X ‚ü∂ Y`, and if `i ‚â† j` there are no such morphisms.\n-/\ninductive SigmaHom : (Œ£i, C i) ‚Üí (Œ£i, C i) ‚Üí Type max w‚ÇÅ v‚ÇÅ u‚ÇÅ\n  | mk : ‚àÄ {i : I} {X Y : C i}, (X ‚ü∂ Y) ‚Üí SigmaHom ‚ü®i, X‚ü© ‚ü®i, Y‚ü©\n\n"}
{"name":"CategoryTheory.Sigma.SigmaHom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù¬≤ : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\ninst‚úù¬π : SizeOf I\ninst‚úù : (a : I) ‚Üí SizeOf (C a)\ni : I\nX Y : C i\na‚úù : Quiver.Hom X Y\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.Sigma.SigmaHom.mk a‚úù)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf i)) (SizeOf.sizeOf X)) (SizeOf.sizeOf Y)) (SizeOf.sizeOf a‚úù))","decl":"/-- The type of morphisms of a disjoint union of categories: for `X : C i` and `Y : C j`, a morphism\n`(i, X) ‚ü∂ (j, Y)` if `i = j` is just a morphism `X ‚ü∂ Y`, and if `i ‚â† j` there are no such morphisms.\n-/\ninductive SigmaHom : (Œ£i, C i) ‚Üí (Œ£i, C i) ‚Üí Type max w‚ÇÅ v‚ÇÅ u‚ÇÅ\n  | mk : ‚àÄ {i : I} {X Y : C i}, (X ‚ü∂ Y) ‚Üí SigmaHom ‚ü®i, X‚ü© ‚ü®i, Y‚ü©\n\n"}
{"name":"CategoryTheory.Sigma.SigmaHom.mk.inj","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\ni : I\nX Y : C i\na‚úù¬π a‚úù : Quiver.Hom X Y\nx‚úù : Eq (CategoryTheory.Sigma.SigmaHom.mk a‚úù¬π) (CategoryTheory.Sigma.SigmaHom.mk a‚úù)\n‚ä¢ Eq a‚úù¬π a‚úù","decl":"/-- The type of morphisms of a disjoint union of categories: for `X : C i` and `Y : C j`, a morphism\n`(i, X) ‚ü∂ (j, Y)` if `i = j` is just a morphism `X ‚ü∂ Y`, and if `i ‚â† j` there are no such morphisms.\n-/\ninductive SigmaHom : (Œ£i, C i) ‚Üí (Œ£i, C i) ‚Üí Type max w‚ÇÅ v‚ÇÅ u‚ÇÅ\n  | mk : ‚àÄ {i : I} {X Y : C i}, (X ‚ü∂ Y) ‚Üí SigmaHom ‚ü®i, X‚ü© ‚ü®i, Y‚ü©\n\n"}
{"name":"CategoryTheory.Sigma.SigmaHom.comp_def","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\ni : I\nX Y Z : C i\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq ((CategoryTheory.Sigma.SigmaHom.mk f).comp (CategoryTheory.Sigma.SigmaHom.mk g)) (CategoryTheory.Sigma.SigmaHom.mk (CategoryTheory.CategoryStruct.comp f g))","decl":"@[simp]\nlemma comp_def (i : I) (X Y Z : C i) (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : comp (mk f) (mk g) = mk (f ‚â´ g) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sigma.SigmaHom.assoc","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nX Y Z W : Sigma fun i => C i\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : Quiver.Hom Z W\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g) h) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h))","decl":"lemma assoc : ‚àÄ {X Y Z W : Œ£i, C i} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : Z ‚ü∂ W), (f ‚â´ g) ‚â´ h = f ‚â´ g ‚â´ h\n  | _, _, _, _, mk _, mk _, mk _ => congr_arg mk (Category.assoc _ _ _)\n\n"}
{"name":"CategoryTheory.Sigma.SigmaHom.id_comp","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nX Y : Sigma fun i => C i\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id X) f) f","decl":"lemma id_comp : ‚àÄ {X Y : Œ£i, C i} (f : X ‚ü∂ Y), ùüô X ‚â´ f = f\n  | _, _, mk _ => congr_arg mk (Category.id_comp _)\n\n"}
{"name":"CategoryTheory.Sigma.SigmaHom.comp_id","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nX Y : Sigma fun i => C i\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id Y)) f","decl":"lemma comp_id : ‚àÄ {X Y : Œ£i, C i} (f : X ‚ü∂ Y), f ‚â´ ùüô Y = f\n  | _, _, mk _ => congr_arg mk (Category.comp_id _)\n\n"}
{"name":"CategoryTheory.Sigma.incl_map","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\ni : I\nX‚úù Y‚úù : C i\na‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Sigma.incl i).map a‚úù) (CategoryTheory.Sigma.SigmaHom.mk a‚úù)","decl":"/-- The inclusion functor into the disjoint union of categories. -/\n@[simps map]\ndef incl (i : I) : C i ‚•§ Œ£i, C i where\n  obj X := ‚ü®i, X‚ü©\n  map := SigmaHom.mk\n\n"}
{"name":"CategoryTheory.Sigma.incl_obj","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\ni : I\nX : C i\n‚ä¢ Eq ((CategoryTheory.Sigma.incl i).obj X) ‚ü®i, X‚ü©","decl":"@[simp]\nlemma incl_obj {i : I} (X : C i) : (incl i).obj X = ‚ü®i, X‚ü© :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sigma.instFullSigmaIncl","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\ni : I\n‚ä¢ (CategoryTheory.Sigma.incl i).Full","decl":"instance (i : I) : Functor.Full (incl i : C i ‚•§ Œ£i, C i) where\n  map_surjective := fun ‚ü®f‚ü© => ‚ü®f, rfl‚ü©\n\n"}
{"name":"CategoryTheory.Sigma.instFaithfulSigmaIncl","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\ni : I\n‚ä¢ (CategoryTheory.Sigma.incl i).Faithful","decl":"instance (i : I) : Functor.Faithful (incl i : C i ‚•§ Œ£i, C i) where\n  map_injective {_ _ _ _} h := by injection h\n\n"}
{"name":"CategoryTheory.Sigma.natTrans_app","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù¬π : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor (Sigma fun i => C i) D\nh : (i : I) ‚Üí Quiver.Hom ((CategoryTheory.Sigma.incl i).comp F) ((CategoryTheory.Sigma.incl i).comp G)\ni : I\nX : C i\n‚ä¢ Eq ((CategoryTheory.Sigma.natTrans h).app ‚ü®i, X‚ü©) ((h i).app X)","decl":"@[simp]\nlemma natTrans_app {F G : (Œ£i, C i) ‚•§ D} (h : ‚àÄ i : I, incl i ‚ãô F ‚ü∂ incl i ‚ãô G) (i : I)\n    (X : C i) : (natTrans h).app ‚ü®i, X‚ü© = (h i).app X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sigma.desc_obj","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù¬π : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : (i : I) ‚Üí CategoryTheory.Functor (C i) D\nX : Sigma fun i => C i\n‚ä¢ Eq ((CategoryTheory.Sigma.desc F).obj X) ((F X.fst).obj X.snd)","decl":"/-- Given a collection of functors `F i : C i ‚•§ D`, we can produce a functor `(Œ£ i, C i) ‚•§ D`.\n\nThe produced functor `desc F` satisfies: `incl i ‚ãô desc F ‚âÖ F i`, i.e. restricted to just the\nsubcategory `C i`, `desc F` agrees with `F i`, and it is unique (up to natural isomorphism) with\nthis property.\n\nThis witnesses that the sigma-type is the coproduct in Cat.\n-/\n@[simps obj]\ndef desc : (Œ£i, C i) ‚•§ D where\n  obj X := (F X.1).obj X.2\n  map g := descMap F _ _ g\n  map_id := by\n    rintro ‚ü®i, X‚ü©\n    apply (F i).map_id\n  map_comp := by\n    rintro ‚ü®i, X‚ü© ‚ü®_, Y‚ü© ‚ü®_, Z‚ü© ‚ü®f‚ü© ‚ü®g‚ü©\n    apply (F i).map_comp\n\n"}
{"name":"CategoryTheory.Sigma.desc_map_mk","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù¬π : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : (i : I) ‚Üí CategoryTheory.Functor (C i) D\ni : I\nX Y : C i\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Sigma.desc F).map (CategoryTheory.Sigma.SigmaHom.mk f)) ((F i).map f)","decl":"@[simp]\nlemma desc_map_mk {i : I} (X Y : C i) (f : X ‚ü∂ Y) : (desc F).map (SigmaHom.mk f) = (F i).map f :=\n  rfl\n\n-- We hand-generate the simp lemmas about this since they come out cleaner.\n"}
{"name":"CategoryTheory.Sigma.inclDesc_hom_app","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù¬π : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : (i : I) ‚Üí CategoryTheory.Functor (C i) D\ni : I\nX : C i\n‚ä¢ Eq ((CategoryTheory.Sigma.inclDesc F i).hom.app X) (CategoryTheory.CategoryStruct.id ((F i).obj X))","decl":"@[simp]\nlemma inclDesc_hom_app (i : I) (X : C i) : (inclDesc F i).hom.app X = ùüô ((F i).obj X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sigma.inclDesc_inv_app","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù¬π : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : (i : I) ‚Üí CategoryTheory.Functor (C i) D\ni : I\nX : C i\n‚ä¢ Eq ((CategoryTheory.Sigma.inclDesc F i).inv.app X) (CategoryTheory.CategoryStruct.id ((F i).obj X))","decl":"@[simp]\nlemma inclDesc_inv_app (i : I) (X : C i) : (inclDesc F i).inv.app X = ùüô ((F i).obj X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sigma.descUniq_hom_app","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù¬π : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : (i : I) ‚Üí CategoryTheory.Functor (C i) D\nq : CategoryTheory.Functor (Sigma fun i => C i) D\nh : (i : I) ‚Üí CategoryTheory.Iso ((CategoryTheory.Sigma.incl i).comp q) (F i)\ni : I\nX : C i\n‚ä¢ Eq ((CategoryTheory.Sigma.descUniq F q h).hom.app ‚ü®i, X‚ü©) ((h i).hom.app X)","decl":"@[simp]\nlemma descUniq_hom_app (q : (Œ£i, C i) ‚•§ D) (h : ‚àÄ i, incl i ‚ãô q ‚âÖ F i) (i : I) (X : C i) :\n    (descUniq F q h).hom.app ‚ü®i, X‚ü© = (h i).hom.app X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sigma.descUniq_inv_app","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù¬π : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : (i : I) ‚Üí CategoryTheory.Functor (C i) D\nq : CategoryTheory.Functor (Sigma fun i => C i) D\nh : (i : I) ‚Üí CategoryTheory.Iso ((CategoryTheory.Sigma.incl i).comp q) (F i)\ni : I\nX : C i\n‚ä¢ Eq ((CategoryTheory.Sigma.descUniq F q h).inv.app ‚ü®i, X‚ü©) ((h i).inv.app X)","decl":"@[simp]\nlemma descUniq_inv_app (q : (Œ£i, C i) ‚•§ D) (h : ‚àÄ i, incl i ‚ãô q ‚âÖ F i) (i : I) (X : C i) :\n    (descUniq F q h).inv.app ‚ü®i, X‚ü© = (h i).inv.app X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sigma.natIso_inv","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù¬π : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nq‚ÇÅ q‚ÇÇ : CategoryTheory.Functor (Sigma fun i => C i) D\nh : (i : I) ‚Üí CategoryTheory.Iso ((CategoryTheory.Sigma.incl i).comp q‚ÇÅ) ((CategoryTheory.Sigma.incl i).comp q‚ÇÇ)\n‚ä¢ Eq (CategoryTheory.Sigma.natIso h).inv (CategoryTheory.Sigma.natTrans fun i => (h i).inv)","decl":"/--\nIf `q‚ÇÅ` and `q‚ÇÇ` when restricted to each subcategory `C i` agree, then `q‚ÇÅ` and `q‚ÇÇ` are isomorphic.\n-/\n@[simps]\ndef natIso {q‚ÇÅ q‚ÇÇ : (Œ£i, C i) ‚•§ D} (h : ‚àÄ i, incl i ‚ãô q‚ÇÅ ‚âÖ incl i ‚ãô q‚ÇÇ) : q‚ÇÅ ‚âÖ q‚ÇÇ where\n  hom := natTrans fun i => (h i).hom\n  inv := natTrans fun i => (h i).inv\n\n"}
{"name":"CategoryTheory.Sigma.natIso_hom","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù¬π : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nq‚ÇÅ q‚ÇÇ : CategoryTheory.Functor (Sigma fun i => C i) D\nh : (i : I) ‚Üí CategoryTheory.Iso ((CategoryTheory.Sigma.incl i).comp q‚ÇÅ) ((CategoryTheory.Sigma.incl i).comp q‚ÇÇ)\n‚ä¢ Eq (CategoryTheory.Sigma.natIso h).hom (CategoryTheory.Sigma.natTrans fun i => (h i).hom)","decl":"/--\nIf `q‚ÇÅ` and `q‚ÇÇ` when restricted to each subcategory `C i` agree, then `q‚ÇÅ` and `q‚ÇÇ` are isomorphic.\n-/\n@[simps]\ndef natIso {q‚ÇÅ q‚ÇÇ : (Œ£i, C i) ‚•§ D} (h : ‚àÄ i, incl i ‚ãô q‚ÇÅ ‚âÖ incl i ‚ãô q‚ÇÇ) : q‚ÇÅ ‚âÖ q‚ÇÇ where\n  hom := natTrans fun i => (h i).hom\n  inv := natTrans fun i => (h i).inv\n\n"}
{"name":"CategoryTheory.Sigma.map_obj","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nJ : Type w‚ÇÇ\ng : J ‚Üí I\nj : J\nX : C (g j)\n‚ä¢ Eq ((CategoryTheory.Sigma.map C g).obj ‚ü®j, X‚ü©) ‚ü®g j, X‚ü©","decl":"@[simp]\nlemma map_obj (j : J) (X : C (g j)) : (Sigma.map C g).obj ‚ü®j, X‚ü© = ‚ü®g j, X‚ü© :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sigma.map_map","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nJ : Type w‚ÇÇ\ng : J ‚Üí I\nj : J\nX Y : C (g j)\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Sigma.map C g).map (CategoryTheory.Sigma.SigmaHom.mk f)) (CategoryTheory.Sigma.SigmaHom.mk f)","decl":"@[simp]\nlemma map_map {j : J} {X Y : C (g j)} (f : X ‚ü∂ Y) :\n    (Sigma.map C g).map (SigmaHom.mk f) = SigmaHom.mk f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sigma.inclCompMap_hom_app","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nJ : Type w‚ÇÇ\ng : J ‚Üí I\nj : J\nX : C (g j)\n‚ä¢ Eq ((CategoryTheory.Sigma.inclCompMap C g j).hom.app X) (CategoryTheory.CategoryStruct.id ‚ü®g j, X‚ü©)","decl":"/-- The functor `Sigma.map C g` restricted to the subcategory `C j` acts as the inclusion of `g j`.\n-/\n@[simps!]\ndef inclCompMap (j : J) : incl j ‚ãô map C g ‚âÖ incl (g j) :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Sigma.inclCompMap_inv_app","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nJ : Type w‚ÇÇ\ng : J ‚Üí I\nj : J\nX : C (g j)\n‚ä¢ Eq ((CategoryTheory.Sigma.inclCompMap C g j).inv.app X) (CategoryTheory.CategoryStruct.id ‚ü®g j, X‚ü©)","decl":"/-- The functor `Sigma.map C g` restricted to the subcategory `C j` acts as the inclusion of `g j`.\n-/\n@[simps!]\ndef inclCompMap (j : J) : incl j ‚ãô map C g ‚âÖ incl (g j) :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Sigma.mapId_hom_app","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nx‚úù : Sigma fun i => (fun i => C (id i)) i\n‚ä¢ Eq ((CategoryTheory.Sigma.mapId I C).hom.app x‚úù) (CategoryTheory.CategoryStruct.id ‚ü®x‚úù.fst, x‚úù.snd‚ü©)","decl":"/-- The functor `Sigma.map` applied to the identity function is just the identity functor. -/\n@[simps!]\ndef mapId : map C (id : I ‚Üí I) ‚âÖ ùü≠ (Œ£i, C i) :=\n  natIso fun i => NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Sigma.mapId_inv_app","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nx‚úù : Sigma fun i => (fun i => C (id i)) i\n‚ä¢ Eq ((CategoryTheory.Sigma.mapId I C).inv.app x‚úù) (CategoryTheory.CategoryStruct.id ‚ü®x‚úù.fst, x‚úù.snd‚ü©)","decl":"/-- The functor `Sigma.map` applied to the identity function is just the identity functor. -/\n@[simps!]\ndef mapId : map C (id : I ‚Üí I) ‚âÖ ùü≠ (Œ£i, C i) :=\n  natIso fun i => NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Sigma.mapComp_hom_app","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nJ : Type w‚ÇÇ\nK : Type w‚ÇÉ\nf : K ‚Üí J\ng : J ‚Üí I\nX : Sigma fun i => (fun i => C (g (f i))) i\n‚ä¢ Eq ((CategoryTheory.Sigma.mapComp C f g).hom.app X) (CategoryTheory.CategoryStruct.id ‚ü®g (f X.fst), X.snd‚ü©)","decl":"/-- The functor `Sigma.map` applied to a composition is a composition of functors. -/\n@[simps!]\ndef mapComp (f : K ‚Üí J) (g : J ‚Üí I) : map (fun x ‚Ü¶ C (g x)) f ‚ãô (map C g :) ‚âÖ map C (g ‚àò f) :=\n  (descUniq _ _) fun k =>\n    (isoWhiskerRight (inclCompMap (fun i => C (g i)) f k) (map C g :) :) ‚â™‚â´ inclCompMap _ _ _\n\n"}
{"name":"CategoryTheory.Sigma.mapComp_inv_app","module":"Mathlib.CategoryTheory.Sigma.Basic","initialProofState":"I : Type w‚ÇÅ\nC : I ‚Üí Type u‚ÇÅ\ninst‚úù : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)\nJ : Type w‚ÇÇ\nK : Type w‚ÇÉ\nf : K ‚Üí J\ng : J ‚Üí I\nX : Sigma fun i => (fun i => C (g (f i))) i\n‚ä¢ Eq ((CategoryTheory.Sigma.mapComp C f g).inv.app X) (CategoryTheory.CategoryStruct.id ‚ü®g (f X.fst), X.snd‚ü©)","decl":"/-- The functor `Sigma.map` applied to a composition is a composition of functors. -/\n@[simps!]\ndef mapComp (f : K ‚Üí J) (g : J ‚Üí I) : map (fun x ‚Ü¶ C (g x)) f ‚ãô (map C g :) ‚âÖ map C (g ‚àò f) :=\n  (descUniq _ _) fun k =>\n    (isoWhiskerRight (inclCompMap (fun i => C (g i)) f k) (map C g :) :) ‚â™‚â´ inclCompMap _ _ _\n\n"}
