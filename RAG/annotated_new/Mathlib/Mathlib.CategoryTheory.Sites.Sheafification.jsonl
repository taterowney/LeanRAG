{"name":"CategoryTheory.HasSheafify.isLeftExact","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nself : CategoryTheory.HasSheafify J A\n⊢ Nonempty (CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.sheafToPresheaf J A).leftAdjoint)","decl":"/--\n`HasSheafify` means that the inclusion functor from sheaves to presheaves admits a left exact\nleft adjiont (sheafification).\n\nGiven a finite limit preserving functor `F : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A` and an adjunction\n`adj : F ⊣ sheafToPresheaf J A`, use `HasSheafify.mk'` to construct a `HasSheafify` instance.\n-/\nclass HasSheafify : Prop where\n  isRightAdjoint : HasWeakSheafify J A\n  isLeftExact : Nonempty (PreservesFiniteLimits ((sheafToPresheaf J A).leftAdjoint))\n\n"}
{"name":"CategoryTheory.HasSheafify.isRightAdjoint","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nself : CategoryTheory.HasSheafify J A\n⊢ CategoryTheory.HasWeakSheafify J A","decl":"/--\n`HasSheafify` means that the inclusion functor from sheaves to presheaves admits a left exact\nleft adjiont (sheafification).\n\nGiven a finite limit preserving functor `F : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A` and an adjunction\n`adj : F ⊣ sheafToPresheaf J A`, use `HasSheafify.mk'` to construct a `HasSheafify` instance.\n-/\nclass HasSheafify : Prop where\n  isRightAdjoint : HasWeakSheafify J A\n  isLeftExact : Nonempty (PreservesFiniteLimits ((sheafToPresheaf J A).leftAdjoint))\n\n"}
{"name":"CategoryTheory.instHasWeakSheafifyOfHasSheafify","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} A\ninst✝ : CategoryTheory.HasSheafify J A\n⊢ CategoryTheory.HasWeakSheafify J A","decl":"instance [HasSheafify J A] : HasWeakSheafify J A := HasSheafify.isRightAdjoint\n\n"}
{"name":"CategoryTheory.instPreservesFiniteLimitsFunctorOppositeSheafLeftAdjointSheafToPresheaf","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} A\ninst✝ : CategoryTheory.HasSheafify J A\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.sheafToPresheaf J A).leftAdjoint","decl":"instance [HasSheafify J A] : PreservesFiniteLimits ((sheafToPresheaf J A).leftAdjoint) :=\n  HasSheafify.isLeftExact.some\n\n"}
{"name":"CategoryTheory.HasSheafify.mk'","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} A\nF : CategoryTheory.Functor (CategoryTheory.Functor (Opposite C) A) (CategoryTheory.Sheaf J A)\nadj : CategoryTheory.Adjunction F (CategoryTheory.sheafToPresheaf J A)\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\n⊢ CategoryTheory.HasSheafify J A","decl":"theorem HasSheafify.mk' {F : (Cᵒᵖ ⥤ A) ⥤ Sheaf J A} (adj : F ⊣ sheafToPresheaf J A)\n    [PreservesFiniteLimits F] : HasSheafify J A where\n  isRightAdjoint := ⟨F, ⟨adj⟩⟩\n  isLeftExact := ⟨by\n    have : (sheafToPresheaf J A).IsRightAdjoint := ⟨_, ⟨adj⟩⟩\n    exact ⟨fun _ _ _ ↦ preservesLimitsOfShape_of_natIso\n      (adj.leftAdjointUniq (Adjunction.ofIsRightAdjoint (sheafToPresheaf J A)))⟩⟩\n\n"}
{"name":"CategoryTheory.instPreservesFiniteLimitsFunctorOppositeSheafPresheafToSheaf","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} A\ninst✝ : CategoryTheory.HasSheafify J A\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.presheafToSheaf J A)","decl":"instance [HasSheafify J A] : PreservesFiniteLimits (presheafToSheaf J A) :=\n  HasSheafify.isLeftExact.some\n\n"}
{"name":"CategoryTheory.instIsLeftAdjointFunctorOppositeSheafPresheafToSheaf","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} A\ninst✝ : CategoryTheory.HasWeakSheafify J A\n⊢ (CategoryTheory.presheafToSheaf J A).IsLeftAdjoint","decl":"instance [HasWeakSheafify J A] : (presheafToSheaf J A).IsLeftAdjoint :=\n  ⟨_, ⟨sheafificationAdjunction J A⟩⟩\n\n"}
{"name":"CategoryTheory.instPreservesFiniteLimitsFunctorOppositeSheafReflectorSheafToPresheaf","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} A\ninst✝ : CategoryTheory.HasSheafify J A\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.reflector (CategoryTheory.sheafToPresheaf J A))","decl":"instance [HasSheafify J A] :  PreservesFiniteLimits (reflector (sheafToPresheaf J A)) :=\n  inferInstanceAs (PreservesFiniteLimits (presheafToSheaf _ _))\n\n"}
{"name":"CategoryTheory.sheafificationAdjunction_unit_app","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP : CategoryTheory.Functor (Opposite C) D\n⊢ Eq ((CategoryTheory.sheafificationAdjunction J D).unit.app P) (CategoryTheory.toSheafify J P)","decl":"@[simp]\ntheorem sheafificationAdjunction_unit_app (P : Cᵒᵖ ⥤ D) :\n    (sheafificationAdjunction J D).unit.app P = toSheafify J P := rfl\n\n"}
{"name":"CategoryTheory.sheafifyMap_id","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP : CategoryTheory.Functor (Opposite C) D\n⊢ Eq (CategoryTheory.sheafifyMap J (CategoryTheory.CategoryStruct.id P)) (CategoryTheory.CategoryStruct.id (CategoryTheory.sheafify J P))","decl":"@[simp]\ntheorem sheafifyMap_id (P : Cᵒᵖ ⥤ D) : sheafifyMap J (𝟙 P) = 𝟙 (sheafify J P) := by\n  simp [sheafifyMap, sheafify]\n\n"}
{"name":"CategoryTheory.sheafifyMap_comp","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP Q R : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nγ : Quiver.Hom Q R\n⊢ Eq (CategoryTheory.sheafifyMap J (CategoryTheory.CategoryStruct.comp η γ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.sheafifyMap J η) (CategoryTheory.sheafifyMap J γ))","decl":"@[simp]\ntheorem sheafifyMap_comp {P Q R : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (γ : Q ⟶ R) :\n    sheafifyMap J (η ≫ γ) = sheafifyMap J η ≫ sheafifyMap J γ := by\n  simp [sheafifyMap, sheafify]\n\n"}
{"name":"CategoryTheory.toSheafify_naturality_assoc","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nZ : CategoryTheory.Functor (Opposite C) D\nh : Quiver.Hom (CategoryTheory.sheafify J Q) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp η (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J Q) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J P) (CategoryTheory.CategoryStruct.comp (CategoryTheory.sheafifyMap J η) h))","decl":"@[reassoc (attr := simp)]\ntheorem toSheafify_naturality {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) :\n    η ≫ toSheafify J _ = toSheafify J _ ≫ sheafifyMap J η :=\n  sheafificationAdjunction J D |>.unit.naturality η\n\n"}
{"name":"CategoryTheory.toSheafify_naturality","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp η (CategoryTheory.toSheafify J Q)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J P) (CategoryTheory.sheafifyMap J η))","decl":"@[reassoc (attr := simp)]\ntheorem toSheafify_naturality {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) :\n    η ≫ toSheafify J _ = toSheafify J _ ≫ sheafifyMap J η :=\n  sheafificationAdjunction J D |>.unit.naturality η\n\n"}
{"name":"CategoryTheory.sheafification_obj","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP : CategoryTheory.Functor (Opposite C) D\n⊢ Eq ((CategoryTheory.sheafification J D).obj P) (CategoryTheory.sheafify J P)","decl":"theorem sheafification_obj (P : Cᵒᵖ ⥤ D) : (sheafification J D).obj P = sheafify J P :=\n  rfl\n\n"}
{"name":"CategoryTheory.sheafification_map","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\n⊢ Eq ((CategoryTheory.sheafification J D).map η) (CategoryTheory.sheafifyMap J η)","decl":"theorem sheafification_map {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) :\n    (sheafification J D).map η = sheafifyMap J η :=\n  rfl\n\n"}
{"name":"CategoryTheory.toSheafification_app","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP : CategoryTheory.Functor (Opposite C) D\n⊢ Eq ((CategoryTheory.toSheafification J D).app P) (CategoryTheory.toSheafify J P)","decl":"theorem toSheafification_app (P : Cᵒᵖ ⥤ D) : (toSheafification J D).app P = toSheafify J P :=\n  rfl\n\n"}
{"name":"CategoryTheory.isIso_toSheafify","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP : CategoryTheory.Functor (Opposite C) D\nhP : CategoryTheory.Presheaf.IsSheaf J P\n⊢ CategoryTheory.IsIso (CategoryTheory.toSheafify J P)","decl":"theorem isIso_toSheafify {P : Cᵒᵖ ⥤ D} (hP : Presheaf.IsSheaf J P) : IsIso (toSheafify J P) := by\n  refine ⟨(sheafificationAdjunction J D |>.counit.app ⟨P, hP⟩).val, ?_, ?_⟩\n  · change _ = (𝟙 (sheafToPresheaf J D ⋙ 𝟭 (Cᵒᵖ ⥤ D)) :).app ⟨P, hP⟩\n    rw [← sheafificationAdjunction J D |>.right_triangle]\n    rfl\n  · change (sheafToPresheaf _ _).map _ ≫ _ = _\n    change _ ≫ (sheafificationAdjunction J D).unit.app ((sheafToPresheaf J D).obj ⟨P, hP⟩) = _\n    rw [← (sheafificationAdjunction J D).inv_counit_map (X := ⟨P, hP⟩)]\n    simp\n\n"}
{"name":"CategoryTheory.isoSheafify_hom","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP : CategoryTheory.Functor (Opposite C) D\nhP : CategoryTheory.Presheaf.IsSheaf J P\n⊢ Eq (CategoryTheory.isoSheafify J hP).hom (CategoryTheory.toSheafify J P)","decl":"@[simp]\ntheorem isoSheafify_hom {P : Cᵒᵖ ⥤ D} (hP : Presheaf.IsSheaf J P) :\n    (isoSheafify J hP).hom = toSheafify J P :=\n  rfl\n\n"}
{"name":"CategoryTheory.sheafificationAdjunction_counit_app_val","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP : CategoryTheory.Sheaf J D\n⊢ Eq ((CategoryTheory.sheafificationAdjunction J D).counit.app P).val (CategoryTheory.sheafifyLift J (CategoryTheory.CategoryStruct.id P.val) ⋯)","decl":"@[simp]\ntheorem sheafificationAdjunction_counit_app_val (P : Sheaf J D) :\n    ((sheafificationAdjunction J D).counit.app P).val = sheafifyLift J (𝟙 P.val) P.cond := by\n  unfold sheafifyLift\n  rw [Adjunction.homEquiv_counit]\n  simp\n\n"}
{"name":"CategoryTheory.toSheafify_sheafifyLift","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J P) (CategoryTheory.sheafifyLift J η hQ)) η","decl":"@[reassoc (attr := simp)]\ntheorem toSheafify_sheafifyLift {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (hQ : Presheaf.IsSheaf J Q) :\n    toSheafify J P ≫ sheafifyLift J η hQ = η := by\n  rw [toSheafify, sheafifyLift, Adjunction.homEquiv_counit]\n  change _ ≫ (sheafToPresheaf J D).map _ ≫ _ = _\n  simp only [Adjunction.unit_naturality_assoc]\n  change _ ≫ (sheafificationAdjunction J D).unit.app ((sheafToPresheaf J D).obj ⟨Q, hQ⟩) ≫ _ = _\n  change _ ≫ _ ≫ (sheafToPresheaf J D).map _ = _\n  rw [sheafificationAdjunction J D |>.right_triangle_components (Y := ⟨Q, hQ⟩)]\n  simp\n\n"}
{"name":"CategoryTheory.toSheafify_sheafifyLift_assoc","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\nZ : CategoryTheory.Functor (Opposite C) D\nh : Quiver.Hom Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J P) (CategoryTheory.CategoryStruct.comp (CategoryTheory.sheafifyLift J η hQ) h)) (CategoryTheory.CategoryStruct.comp η h)","decl":"@[reassoc (attr := simp)]\ntheorem toSheafify_sheafifyLift {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (hQ : Presheaf.IsSheaf J Q) :\n    toSheafify J P ≫ sheafifyLift J η hQ = η := by\n  rw [toSheafify, sheafifyLift, Adjunction.homEquiv_counit]\n  change _ ≫ (sheafToPresheaf J D).map _ ≫ _ = _\n  simp only [Adjunction.unit_naturality_assoc]\n  change _ ≫ (sheafificationAdjunction J D).unit.app ((sheafToPresheaf J D).obj ⟨Q, hQ⟩) ≫ _ = _\n  change _ ≫ _ ≫ (sheafToPresheaf J D).map _ = _\n  rw [sheafificationAdjunction J D |>.right_triangle_components (Y := ⟨Q, hQ⟩)]\n  simp\n\n"}
{"name":"CategoryTheory.sheafifyLift_unique","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP Q : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\nγ : Quiver.Hom (CategoryTheory.sheafify J P) Q\na✝ : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J P) γ) η\n⊢ Eq γ (CategoryTheory.sheafifyLift J η hQ)","decl":"theorem sheafifyLift_unique {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (hQ : Presheaf.IsSheaf J Q)\n    (γ : sheafify J P ⟶ Q) : toSheafify J P ≫ γ = η → γ = sheafifyLift J η hQ := by\n  intro h\n  rw [toSheafify] at h\n  rw [sheafifyLift]\n  let γ' : (presheafToSheaf J D).obj P ⟶ ⟨Q, hQ⟩ := ⟨γ⟩\n  change γ'.val = _\n  rw [← Sheaf.Hom.ext_iff, ← Adjunction.homEquiv_apply_eq, Adjunction.homEquiv_unit]\n  exact h\n\n"}
{"name":"CategoryTheory.isoSheafify_inv","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP : CategoryTheory.Functor (Opposite C) D\nhP : CategoryTheory.Presheaf.IsSheaf J P\n⊢ Eq (CategoryTheory.isoSheafify J hP).inv (CategoryTheory.sheafifyLift J (CategoryTheory.CategoryStruct.id P) hP)","decl":"@[simp]\ntheorem isoSheafify_inv {P : Cᵒᵖ ⥤ D} (hP : Presheaf.IsSheaf J P) :\n    (isoSheafify J hP).inv = sheafifyLift J (𝟙 _) hP := by\n  apply sheafifyLift_unique\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.sheafify_hom_ext","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP Q : CategoryTheory.Functor (Opposite C) D\nη γ : Quiver.Hom (CategoryTheory.sheafify J P) Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\nh : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J P) η) (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J P) γ)\n⊢ Eq η γ","decl":"theorem sheafify_hom_ext {P Q : Cᵒᵖ ⥤ D} (η γ : sheafify J P ⟶ Q) (hQ : Presheaf.IsSheaf J Q)\n    (h : toSheafify J P ≫ η = toSheafify J P ≫ γ) : η = γ := by\n  rw [sheafifyLift_unique J _ hQ _ h, ← h]\n  exact (sheafifyLift_unique J _ hQ _ h.symm).symm\n\n"}
{"name":"CategoryTheory.sheafifyMap_sheafifyLift_assoc","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP Q R : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nγ : Quiver.Hom Q R\nhR : CategoryTheory.Presheaf.IsSheaf J R\nZ : CategoryTheory.Functor (Opposite C) D\nh : Quiver.Hom R Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.sheafifyMap J η) (CategoryTheory.CategoryStruct.comp (CategoryTheory.sheafifyLift J γ hR) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.sheafifyLift J (CategoryTheory.CategoryStruct.comp η γ) hR) h)","decl":"@[reassoc (attr := simp)]\ntheorem sheafifyMap_sheafifyLift {P Q R : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (γ : Q ⟶ R)\n    (hR : Presheaf.IsSheaf J R) :\n    sheafifyMap J η ≫ sheafifyLift J γ hR = sheafifyLift J (η ≫ γ) hR := by\n  apply sheafifyLift_unique\n  rw [← Category.assoc, ← toSheafify_naturality, Category.assoc, toSheafify_sheafifyLift]\n\n"}
{"name":"CategoryTheory.sheafifyMap_sheafifyLift","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP Q R : CategoryTheory.Functor (Opposite C) D\nη : Quiver.Hom P Q\nγ : Quiver.Hom Q R\nhR : CategoryTheory.Presheaf.IsSheaf J R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.sheafifyMap J η) (CategoryTheory.sheafifyLift J γ hR)) (CategoryTheory.sheafifyLift J (CategoryTheory.CategoryStruct.comp η γ) hR)","decl":"@[reassoc (attr := simp)]\ntheorem sheafifyMap_sheafifyLift {P Q R : Cᵒᵖ ⥤ D} (η : P ⟶ Q) (γ : Q ⟶ R)\n    (hR : Presheaf.IsSheaf J R) :\n    sheafifyMap J η ≫ sheafifyLift J γ hR = sheafifyLift J (η ≫ γ) hR := by\n  apply sheafifyLift_unique\n  rw [← Category.assoc, ← toSheafify_naturality, Category.assoc, toSheafify_sheafifyLift]\n\n"}
{"name":"CategoryTheory.sheafificationIso_hom_val","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP : CategoryTheory.Sheaf J D\n⊢ Eq (CategoryTheory.sheafificationIso P).hom.val (CategoryTheory.isoSheafify J ⋯).hom","decl":"/-- A sheaf `P` is isomorphic to its own sheafification. -/\n@[simps]\nnoncomputable def sheafificationIso (P : Sheaf J D) : P ≅ (presheafToSheaf J D).obj P.val where\n  hom := ⟨(isoSheafify J P.2).hom⟩\n  inv := ⟨(isoSheafify J P.2).inv⟩\n  hom_inv_id := by\n    ext1\n    apply (isoSheafify J P.2).hom_inv_id\n  inv_hom_id := by\n    ext1\n    apply (isoSheafify J P.2).inv_hom_id\n\n"}
{"name":"CategoryTheory.sheafificationIso_inv_val","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP : CategoryTheory.Sheaf J D\n⊢ Eq (CategoryTheory.sheafificationIso P).inv.val (CategoryTheory.isoSheafify J ⋯).inv","decl":"/-- A sheaf `P` is isomorphic to its own sheafification. -/\n@[simps]\nnoncomputable def sheafificationIso (P : Sheaf J D) : P ≅ (presheafToSheaf J D).obj P.val where\n  hom := ⟨(isoSheafify J P.2).hom⟩\n  inv := ⟨(isoSheafify J P.2).inv⟩\n  hom_inv_id := by\n    ext1\n    apply (isoSheafify J P.2).hom_inv_id\n  inv_hom_id := by\n    ext1\n    apply (isoSheafify J P.2).inv_hom_id\n\n"}
{"name":"CategoryTheory.isIso_sheafificationAdjunction_counit","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nP : CategoryTheory.Sheaf J D\n⊢ CategoryTheory.IsIso ((CategoryTheory.sheafificationAdjunction J D).counit.app P)","decl":"instance isIso_sheafificationAdjunction_counit (P : Sheaf J D) :\n    IsIso ((sheafificationAdjunction J D).counit.app P) :=\n  isIso_of_fully_faithful (sheafToPresheaf J D) _\n\n"}
{"name":"CategoryTheory.sheafification_reflective","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\n⊢ CategoryTheory.IsIso (CategoryTheory.sheafificationAdjunction J D).counit","decl":"instance sheafification_reflective : IsIso (sheafificationAdjunction J D).counit :=\n  NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.sheafificationNatIso_inv_app_val","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nX : CategoryTheory.Sheaf J D\n⊢ Eq ((CategoryTheory.sheafificationNatIso J D).inv.app X).val (CategoryTheory.sheafifyLift J (CategoryTheory.CategoryStruct.id X.val) ⋯)","decl":"/-- The natural isomorphism `𝟭 (Sheaf J D) ≅ sheafToPresheaf J D ⋙ presheafToSheaf J D`. -/\n@[simps!]\nnoncomputable def sheafificationNatIso :\n    𝟭 (Sheaf J D) ≅ sheafToPresheaf J D ⋙ presheafToSheaf J D :=\n  NatIso.ofComponents (fun P => sheafificationIso P) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.sheafificationNatIso_hom_app_val","module":"Mathlib.CategoryTheory.Sites.Sheafification","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\ninst✝ : CategoryTheory.HasWeakSheafify J D\nX : CategoryTheory.Sheaf J D\n⊢ Eq ((CategoryTheory.sheafificationNatIso J D).hom.app X).val (CategoryTheory.toSheafify J X.val)","decl":"/-- The natural isomorphism `𝟭 (Sheaf J D) ≅ sheafToPresheaf J D ⋙ presheafToSheaf J D`. -/\n@[simps!]\nnoncomputable def sheafificationNatIso :\n    𝟭 (Sheaf J D) ≅ sheafToPresheaf J D ⋙ presheafToSheaf J D :=\n  NatIso.ofComponents (fun P => sheafificationIso P) (by aesop_cat)\n\n"}
