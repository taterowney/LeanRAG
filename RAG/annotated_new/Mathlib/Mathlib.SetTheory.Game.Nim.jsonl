{"name":"SetTheory.PGame.nim_def","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (SetTheory.PGame.nim o) (SetTheory.PGame.mk o.toType o.toType (fun x => SetTheory.PGame.nim ↑(o.enumIsoToType.symm x)) fun x => SetTheory.PGame.nim ↑(o.enumIsoToType.symm x))","decl":"theorem nim_def (o : Ordinal) : nim o =\n    ⟨o.toType, o.toType,\n      fun x => nim ((enumIsoToType o).symm x).val,\n      fun x => nim ((enumIsoToType o).symm x).val⟩ := by\n  rw [nim]\n\n"}
{"name":"SetTheory.PGame.leftMoves_nim","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (SetTheory.PGame.nim o).LeftMoves o.toType","decl":"theorem leftMoves_nim (o : Ordinal) : (nim o).LeftMoves = o.toType := by rw [nim_def]; rfl\n"}
{"name":"SetTheory.PGame.rightMoves_nim","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (SetTheory.PGame.nim o).RightMoves o.toType","decl":"theorem rightMoves_nim (o : Ordinal) : (nim o).RightMoves = o.toType := by rw [nim_def]; rfl\n\n"}
{"name":"SetTheory.PGame.moveLeft_nim_hEq","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\n⊢ HEq (SetTheory.PGame.nim o).moveLeft fun i => SetTheory.PGame.nim ↑(o.enumIsoToType.symm i)","decl":"theorem moveLeft_nim_hEq (o : Ordinal) :\n    HEq (nim o).moveLeft fun i : o.toType => nim ((enumIsoToType o).symm i) := by rw [nim_def]; rfl\n\n"}
{"name":"SetTheory.PGame.moveRight_nim_hEq","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\n⊢ HEq (SetTheory.PGame.nim o).moveRight fun i => SetTheory.PGame.nim ↑(o.enumIsoToType.symm i)","decl":"theorem moveRight_nim_hEq (o : Ordinal) :\n    HEq (nim o).moveRight fun i : o.toType => nim ((enumIsoToType o).symm i) := by rw [nim_def]; rfl\n\n"}
{"name":"SetTheory.PGame.toLeftMovesNim_symm_lt","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\ni : (SetTheory.PGame.nim o).LeftMoves\n⊢ LT.lt (↑(SetTheory.PGame.toLeftMovesNim.symm i)) o","decl":"@[simp]\ntheorem toLeftMovesNim_symm_lt {o : Ordinal} (i : (nim o).LeftMoves) :\n    toLeftMovesNim.symm i < o :=\n  (toLeftMovesNim.symm i).prop\n\n"}
{"name":"SetTheory.PGame.toRightMovesNim_symm_lt","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\ni : (SetTheory.PGame.nim o).RightMoves\n⊢ LT.lt (↑(SetTheory.PGame.toRightMovesNim.symm i)) o","decl":"@[simp]\ntheorem toRightMovesNim_symm_lt {o : Ordinal} (i : (nim o).RightMoves) :\n    toRightMovesNim.symm i < o :=\n  (toRightMovesNim.symm i).prop\n\n"}
{"name":"SetTheory.PGame.moveLeft_nim","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\ni : (SetTheory.PGame.nim o).LeftMoves\n⊢ Eq ((SetTheory.PGame.nim o).moveLeft i) (SetTheory.PGame.nim ↑(SetTheory.PGame.toLeftMovesNim.symm i))","decl":"@[simp]\ntheorem moveLeft_nim {o : Ordinal} (i) : (nim o).moveLeft i = nim (toLeftMovesNim.symm i).val :=\n  (congr_heq (moveLeft_nim_hEq o).symm (cast_heq _ i)).symm\n\n"}
{"name":"SetTheory.PGame.moveLeft_nim'","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\ni : (SetTheory.PGame.nim o).LeftMoves\n⊢ Eq ((SetTheory.PGame.nim o).moveLeft i) (SetTheory.PGame.nim ↑(SetTheory.PGame.toLeftMovesNim.symm i))","decl":"@[deprecated moveLeft_nim (since := \"2024-10-30\")]\nalias moveLeft_nim' := moveLeft_nim\n\n"}
{"name":"SetTheory.PGame.moveLeft_toLeftMovesNim","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\ni : ↑(Set.Iio o)\n⊢ Eq ((SetTheory.PGame.nim o).moveLeft (SetTheory.PGame.toLeftMovesNim i)) (SetTheory.PGame.nim ↑i)","decl":"theorem moveLeft_toLeftMovesNim {o : Ordinal} (i) :\n    (nim o).moveLeft (toLeftMovesNim i) = nim i := by\n  simp\n\n"}
{"name":"SetTheory.PGame.moveRight_nim","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\ni : (SetTheory.PGame.nim o).RightMoves\n⊢ Eq ((SetTheory.PGame.nim o).moveRight i) (SetTheory.PGame.nim ↑(SetTheory.PGame.toRightMovesNim.symm i))","decl":"@[simp]\ntheorem moveRight_nim {o : Ordinal} (i) : (nim o).moveRight i = nim (toRightMovesNim.symm i).val :=\n  (congr_heq (moveRight_nim_hEq o).symm (cast_heq _ i)).symm\n\n"}
{"name":"SetTheory.PGame.moveRight_nim'","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\ni : (SetTheory.PGame.nim o).RightMoves\n⊢ Eq ((SetTheory.PGame.nim o).moveRight i) (SetTheory.PGame.nim ↑(SetTheory.PGame.toRightMovesNim.symm i))","decl":"@[deprecated moveRight_nim (since := \"2024-10-30\")]\nalias moveRight_nim' := moveRight_nim\n\n"}
{"name":"SetTheory.PGame.moveRight_toRightMovesNim","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\ni : ↑(Set.Iio o)\n⊢ Eq ((SetTheory.PGame.nim o).moveRight (SetTheory.PGame.toRightMovesNim i)) (SetTheory.PGame.nim ↑i)","decl":"theorem moveRight_toRightMovesNim {o : Ordinal} (i) :\n    (nim o).moveRight (toRightMovesNim i) = nim i := by\n  simp\n\n"}
{"name":"SetTheory.PGame.isEmpty_nim_zero_leftMoves","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"⊢ IsEmpty (SetTheory.PGame.nim 0).LeftMoves","decl":"instance isEmpty_nim_zero_leftMoves : IsEmpty (nim 0).LeftMoves := by\n  rw [nim_def]\n  exact isEmpty_toType_zero\n\n"}
{"name":"SetTheory.PGame.isEmpty_nim_zero_rightMoves","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"⊢ IsEmpty (SetTheory.PGame.nim 0).RightMoves","decl":"instance isEmpty_nim_zero_rightMoves : IsEmpty (nim 0).RightMoves := by\n  rw [nim_def]\n  exact isEmpty_toType_zero\n\n"}
{"name":"SetTheory.PGame.nim_zero_equiv","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"⊢ HasEquiv.Equiv (SetTheory.PGame.nim 0) 0","decl":"theorem nim_zero_equiv : nim 0 ≈ 0 :=\n  Equiv.isEmpty _\n\n"}
{"name":"SetTheory.PGame.default_nim_one_leftMoves_eq","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"⊢ Eq Inhabited.default (SetTheory.PGame.toLeftMovesNim ⟨0, ⋯⟩)","decl":"@[simp]\ntheorem default_nim_one_leftMoves_eq :\n    (default : (nim 1).LeftMoves) = @toLeftMovesNim 1 ⟨0, Set.mem_Iio.mpr zero_lt_one⟩ :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.default_nim_one_rightMoves_eq","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"⊢ Eq Inhabited.default (SetTheory.PGame.toRightMovesNim ⟨0, ⋯⟩)","decl":"@[simp]\ntheorem default_nim_one_rightMoves_eq :\n    (default : (nim 1).RightMoves) = @toRightMovesNim 1 ⟨0, Set.mem_Iio.mpr zero_lt_one⟩ :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.toLeftMovesNim_one_symm","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"i : (SetTheory.PGame.nim 1).LeftMoves\n⊢ Eq (SetTheory.PGame.toLeftMovesNim.symm i) ⟨0, ⋯⟩","decl":"@[simp]\ntheorem toLeftMovesNim_one_symm (i) :\n    (@toLeftMovesNim 1).symm i = ⟨0, Set.mem_Iio.mpr zero_lt_one⟩ := by\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"SetTheory.PGame.toRightMovesNim_one_symm","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"i : (SetTheory.PGame.nim 1).RightMoves\n⊢ Eq (SetTheory.PGame.toRightMovesNim.symm i) ⟨0, ⋯⟩","decl":"@[simp]\ntheorem toRightMovesNim_one_symm (i) :\n    (@toRightMovesNim 1).symm i = ⟨0, Set.mem_Iio.mpr zero_lt_one⟩ := by\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"SetTheory.PGame.nim_one_moveLeft","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"x : (SetTheory.PGame.nim 1).LeftMoves\n⊢ Eq ((SetTheory.PGame.nim 1).moveLeft x) (SetTheory.PGame.nim 0)","decl":"theorem nim_one_moveLeft (x) : (nim 1).moveLeft x = nim 0 := by simp\n\n"}
{"name":"SetTheory.PGame.nim_one_moveRight","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"x : (SetTheory.PGame.nim 1).RightMoves\n⊢ Eq ((SetTheory.PGame.nim 1).moveRight x) (SetTheory.PGame.nim 0)","decl":"theorem nim_one_moveRight (x) : (nim 1).moveRight x = nim 0 := by simp\n\n"}
{"name":"SetTheory.PGame.nim_one_equiv","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"⊢ HasEquiv.Equiv (SetTheory.PGame.nim 1) SetTheory.PGame.star","decl":"theorem nim_one_equiv : nim 1 ≈ star :=\n  nimOneRelabelling.equiv\n\n"}
{"name":"SetTheory.PGame.nim_birthday","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (SetTheory.PGame.nim o).birthday o","decl":"@[simp]\ntheorem nim_birthday (o : Ordinal) : (nim o).birthday = o := by\n  induction' o using Ordinal.induction with o IH\n  rw [nim_def, birthday_def]\n  dsimp\n  rw [max_eq_right le_rfl]\n  convert lsub_typein o with i\n  exact IH _ (typein_lt_self i)\n\n"}
{"name":"SetTheory.PGame.neg_nim","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Neg.neg (SetTheory.PGame.nim o)) (SetTheory.PGame.nim o)","decl":"@[simp]\ntheorem neg_nim (o : Ordinal) : -nim o = nim o := by\n  induction' o using Ordinal.induction with o IH\n  rw [nim_def]; dsimp; congr <;> funext i <;> exact IH _ (Ordinal.typein_lt_self i)\n\n"}
{"name":"SetTheory.PGame.nim_impartial","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\n⊢ (SetTheory.PGame.nim o).Impartial","decl":"instance nim_impartial (o : Ordinal) : Impartial (nim o) := by\n  induction' o using Ordinal.induction with o IH\n  rw [impartial_def, neg_nim]\n  refine ⟨equiv_rfl, fun i => ?_, fun i => ?_⟩ <;> simpa using IH _ (typein_lt_self _)\n\n"}
{"name":"SetTheory.PGame.nim_fuzzy_zero_of_ne_zero","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u_1}\nho : Ne o 0\n⊢ (SetTheory.PGame.nim o).Fuzzy 0","decl":"theorem nim_fuzzy_zero_of_ne_zero {o : Ordinal} (ho : o ≠ 0) : nim o ‖ 0 := by\n  rw [Impartial.fuzzy_zero_iff_lf, lf_zero_le]\n  use toRightMovesNim ⟨0, Ordinal.pos_iff_ne_zero.2 ho⟩\n  simp\n\n"}
{"name":"SetTheory.PGame.nim_add_equiv_zero_iff","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (HasEquiv.Equiv (HAdd.hAdd (SetTheory.PGame.nim o₁) (SetTheory.PGame.nim o₂)) 0) (Eq o₁ o₂)","decl":"@[simp]\ntheorem nim_add_equiv_zero_iff (o₁ o₂ : Ordinal) : (nim o₁ + nim o₂ ≈ 0) ↔ o₁ = o₂ := by\n  constructor\n  · refine not_imp_not.1 fun hne : _ ≠ _ => (Impartial.not_equiv_zero_iff (nim o₁ + nim o₂)).2 ?_\n    wlog h : o₁ < o₂\n    · exact (fuzzy_congr_left add_comm_equiv).1 (this _ _ hne.symm (hne.lt_or_lt.resolve_left h))\n    rw [Impartial.fuzzy_zero_iff_gf, zero_lf_le]\n    use toLeftMovesAdd (Sum.inr <| toLeftMovesNim ⟨_, h⟩)\n    · simpa using (Impartial.add_self (nim o₁)).2\n  · rintro rfl\n    exact Impartial.add_self (nim o₁)\n\n"}
{"name":"SetTheory.PGame.nim_add_fuzzy_zero_iff","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff ((HAdd.hAdd (SetTheory.PGame.nim o₁) (SetTheory.PGame.nim o₂)).Fuzzy 0) (Ne o₁ o₂)","decl":"@[simp]\ntheorem nim_add_fuzzy_zero_iff {o₁ o₂ : Ordinal} : nim o₁ + nim o₂ ‖ 0 ↔ o₁ ≠ o₂ := by\n  rw [iff_not_comm, Impartial.not_fuzzy_zero_iff, nim_add_equiv_zero_iff]\n\n"}
{"name":"SetTheory.PGame.nim_equiv_iff_eq","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Iff (HasEquiv.Equiv (SetTheory.PGame.nim o₁) (SetTheory.PGame.nim o₂)) (Eq o₁ o₂)","decl":"@[simp]\ntheorem nim_equiv_iff_eq {o₁ o₂ : Ordinal} : (nim o₁ ≈ nim o₂) ↔ o₁ = o₂ := by\n  rw [Impartial.equiv_iff_add_equiv_zero, nim_add_equiv_zero_iff]\n\n"}
{"name":"SetTheory.PGame.grundyValue_eq_sInf_moveLeft","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\n⊢ Eq G.grundyValue (InfSet.sInf (HasCompl.compl (Set.range (Function.comp SetTheory.PGame.grundyValue G.moveLeft))))","decl":"theorem grundyValue_eq_sInf_moveLeft (G : PGame) :\n    grundyValue G = sInf (Set.range (grundyValue ∘ G.moveLeft))ᶜ := by\n  rw [grundyValue]; rfl\n\n"}
{"name":"SetTheory.PGame.grundyValue_eq_mex_left","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\n⊢ Eq G.grundyValue (Ordinal.mex fun i => (G.moveLeft i).grundyValue)","decl":"set_option linter.deprecated false in\n@[deprecated grundyValue_eq_sInf_moveLeft (since := \"2024-09-16\")]\ntheorem grundyValue_eq_mex_left (G : PGame) :\n    grundyValue G = Ordinal.mex fun i => grundyValue (G.moveLeft i) :=\n  grundyValue_eq_sInf_moveLeft G\n\n"}
{"name":"SetTheory.PGame.grundyValue_ne_moveLeft","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\ni : G.LeftMoves\n⊢ Ne (G.moveLeft i).grundyValue G.grundyValue","decl":"theorem grundyValue_ne_moveLeft {G : PGame} (i : G.LeftMoves) :\n    grundyValue (G.moveLeft i) ≠ grundyValue G := by\n  conv_rhs => rw [grundyValue_eq_sInf_moveLeft]\n  have := csInf_mem (nonempty_of_not_bddAbove <|\n    Nimber.not_bddAbove_compl_of_small (Set.range fun i => grundyValue (G.moveLeft i)))\n  rw [Set.mem_compl_iff, Set.mem_range, not_exists] at this\n  exact this _\n\n"}
{"name":"SetTheory.PGame.le_grundyValue_of_Iio_subset_moveLeft","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\no : Nimber\nh : HasSubset.Subset (Set.Iio o) (Set.range (Function.comp SetTheory.PGame.grundyValue G.moveLeft))\n⊢ LE.le o G.grundyValue","decl":"theorem le_grundyValue_of_Iio_subset_moveLeft {G : PGame} {o : Nimber}\n    (h : Set.Iio o ⊆ Set.range (grundyValue ∘ G.moveLeft)) : o ≤ grundyValue G := by\n  by_contra! ho\n  obtain ⟨i, hi⟩ := h ho\n  exact grundyValue_ne_moveLeft i hi\n\n"}
{"name":"SetTheory.PGame.exists_grundyValue_moveLeft_of_lt","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\no : Nimber\nh : LT.lt o G.grundyValue\n⊢ Exists fun i => Eq (G.moveLeft i).grundyValue o","decl":"theorem exists_grundyValue_moveLeft_of_lt {G : PGame} {o : Nimber} (h : o < grundyValue G) :\n    ∃ i, grundyValue (G.moveLeft i) = o := by\n  rw [grundyValue_eq_sInf_moveLeft] at h\n  by_contra ha\n  exact h.not_le (csInf_le' ha)\n\n"}
{"name":"SetTheory.PGame.grundyValue_le_of_forall_moveLeft","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\no : Nimber\nh : ∀ (i : G.LeftMoves), Ne (G.moveLeft i).grundyValue o\n⊢ LE.le G.grundyValue o","decl":"theorem grundyValue_le_of_forall_moveLeft {G : PGame} {o : Nimber}\n    (h : ∀ i, grundyValue (G.moveLeft i) ≠ o) : G.grundyValue ≤ o := by\n  contrapose! h\n  exact exists_grundyValue_moveLeft_of_lt h\n\n"}
{"name":"SetTheory.PGame.equiv_nim_grundyValue","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ HasEquiv.Equiv G (SetTheory.PGame.nim (Nimber.toOrdinal G.grundyValue))","decl":"/-- The **Sprague-Grundy theorem** states that every impartial game is equivalent to a game of nim,\nnamely the game of nim corresponding to the game's Grundy value. -/\ntheorem equiv_nim_grundyValue (G : PGame.{u}) [G.Impartial] :\n    G ≈ nim (toOrdinal (grundyValue G)) := by\n  rw [Impartial.equiv_iff_add_equiv_zero, ← Impartial.forall_leftMoves_fuzzy_iff_equiv_zero]\n  intro x\n  apply leftMoves_add_cases x <;>\n  intro i\n  · rw [add_moveLeft_inl,\n      ← fuzzy_congr_left (add_congr_left (Equiv.symm (equiv_nim_grundyValue _))),\n      nim_add_fuzzy_zero_iff]\n    exact grundyValue_ne_moveLeft i\n  · rw [add_moveLeft_inr, ← Impartial.exists_left_move_equiv_iff_fuzzy_zero]\n    obtain ⟨j, hj⟩ := exists_grundyValue_moveLeft_of_lt <| toLeftMovesNim_symm_lt i\n    use toLeftMovesAdd (Sum.inl j)\n    rw [add_moveLeft_inl, moveLeft_nim]\n    exact Equiv.trans (add_congr_left (equiv_nim_grundyValue _)) (hj ▸ Impartial.add_self _)\ntermination_by G\n\n"}
{"name":"SetTheory.PGame.grundyValue_eq_iff_equiv_nim","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\no : Nimber\n⊢ Iff (Eq G.grundyValue o) (HasEquiv.Equiv G (SetTheory.PGame.nim (Nimber.toOrdinal o)))","decl":"theorem grundyValue_eq_iff_equiv_nim {G : PGame} [G.Impartial] {o : Nimber} :\n    grundyValue G = o ↔ G ≈ nim (toOrdinal o) :=\n  ⟨by rintro rfl; exact equiv_nim_grundyValue G,\n   by intro h; rw [← nim_equiv_iff_eq]; exact Equiv.trans (Equiv.symm (equiv_nim_grundyValue G)) h⟩\n\n"}
{"name":"SetTheory.PGame.nim_grundyValue","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"o : Ordinal.{u}\n⊢ Eq (SetTheory.PGame.nim o).grundyValue (Ordinal.toNimber o)","decl":"@[simp]\ntheorem nim_grundyValue (o : Ordinal.{u}) : grundyValue (nim o) = ∗o :=\n  grundyValue_eq_iff_equiv_nim.2 PGame.equiv_rfl\n\n"}
{"name":"SetTheory.PGame.grundyValue_eq_iff_equiv","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G H : SetTheory.PGame\ninst✝¹ : G.Impartial\ninst✝ : H.Impartial\n⊢ Iff (Eq G.grundyValue H.grundyValue) (HasEquiv.Equiv G H)","decl":"theorem grundyValue_eq_iff_equiv (G H : PGame) [G.Impartial] [H.Impartial] :\n    grundyValue G = grundyValue H ↔ (G ≈ H) :=\n  grundyValue_eq_iff_equiv_nim.trans (equiv_congr_left.1 (equiv_nim_grundyValue H) _).symm\n\n"}
{"name":"SetTheory.PGame.grundyValue_zero","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"⊢ Eq (SetTheory.PGame.grundyValue 0) 0","decl":"@[simp]\ntheorem grundyValue_zero : grundyValue 0 = 0 :=\n  grundyValue_eq_iff_equiv_nim.2 (Equiv.symm nim_zero_equiv)\n\n"}
{"name":"SetTheory.PGame.grundyValue_iff_equiv_zero","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Iff (Eq G.grundyValue 0) (HasEquiv.Equiv G 0)","decl":"theorem grundyValue_iff_equiv_zero (G : PGame) [G.Impartial] : grundyValue G = 0 ↔ G ≈ 0 := by\n  rw [← grundyValue_eq_iff_equiv, grundyValue_zero]\n\n"}
{"name":"SetTheory.PGame.grundyValue_star","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"⊢ Eq SetTheory.PGame.star.grundyValue 1","decl":"@[simp]\ntheorem grundyValue_star : grundyValue star = 1 :=\n  grundyValue_eq_iff_equiv_nim.2 (Equiv.symm nim_one_equiv)\n\n"}
{"name":"SetTheory.PGame.grundyValue_neg","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Eq (Neg.neg G).grundyValue G.grundyValue","decl":"@[simp]\ntheorem grundyValue_neg (G : PGame) [G.Impartial] : grundyValue (-G) = grundyValue G := by\n  rw [grundyValue_eq_iff_equiv_nim, neg_equiv_iff, neg_nim, ← grundyValue_eq_iff_equiv_nim]\n\n"}
{"name":"SetTheory.PGame.grundyValue_eq_sInf_moveRight","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Eq G.grundyValue (InfSet.sInf (HasCompl.compl (Set.range (Function.comp SetTheory.PGame.grundyValue G.moveRight))))","decl":"theorem grundyValue_eq_sInf_moveRight (G : PGame) [G.Impartial] :\n    grundyValue G = sInf (Set.range (grundyValue ∘ G.moveRight))ᶜ := by\n  obtain ⟨l, r, L, R⟩ := G\n  rw [← grundyValue_neg, grundyValue_eq_sInf_moveLeft]\n  iterate 3 apply congr_arg\n  ext i\n  exact @grundyValue_neg _ (@Impartial.moveRight_impartial ⟨l, r, L, R⟩ _ _)\n\n"}
{"name":"SetTheory.PGame.grundyValue_eq_mex_right","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\n⊢ Eq G.grundyValue (Ordinal.mex fun i => (G.moveRight i).grundyValue)","decl":"set_option linter.deprecated false in\n@[deprecated grundyValue_eq_sInf_moveRight (since := \"2024-09-16\")]\ntheorem grundyValue_eq_mex_right (G : PGame) [G.Impartial] :\n    grundyValue G = Ordinal.mex.{u, u} fun i => grundyValue (G.moveRight i) :=\n  grundyValue_eq_sInf_moveRight G\n\n"}
{"name":"SetTheory.PGame.grundyValue_ne_moveRight","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\ni : G.RightMoves\n⊢ Ne (G.moveRight i).grundyValue G.grundyValue","decl":"theorem grundyValue_ne_moveRight {G : PGame} [G.Impartial] (i : G.RightMoves) :\n    grundyValue (G.moveRight i) ≠ grundyValue G := by\n  convert grundyValue_ne_moveLeft (toLeftMovesNeg i) using 1 <;> simp\n\n"}
{"name":"SetTheory.PGame.le_grundyValue_of_Iio_subset_moveRight","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\no : Nimber\nh : HasSubset.Subset (Set.Iio o) (Set.range (Function.comp SetTheory.PGame.grundyValue G.moveRight))\n⊢ LE.le o G.grundyValue","decl":"theorem le_grundyValue_of_Iio_subset_moveRight {G : PGame} [G.Impartial] {o : Nimber}\n    (h : Set.Iio o ⊆ Set.range (grundyValue ∘ G.moveRight)) : o ≤ grundyValue G := by\n  by_contra! ho\n  obtain ⟨i, hi⟩ := h ho\n  exact grundyValue_ne_moveRight i hi\n\n"}
{"name":"SetTheory.PGame.exists_grundyValue_moveRight_of_lt","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\no : Nimber\nh : LT.lt o G.grundyValue\n⊢ Exists fun i => Eq (G.moveRight i).grundyValue o","decl":"theorem exists_grundyValue_moveRight_of_lt {G : PGame} [G.Impartial] {o : Nimber}\n    (h : o < grundyValue G) : ∃ i, grundyValue (G.moveRight i) = o := by\n  rw [← grundyValue_neg] at h\n  obtain ⟨i, hi⟩ := exists_grundyValue_moveLeft_of_lt h\n  use toLeftMovesNeg.symm i\n  rwa [← grundyValue_neg, ← moveLeft_neg]\n\n"}
{"name":"SetTheory.PGame.grundyValue_le_of_forall_moveRight","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G : SetTheory.PGame\ninst✝ : G.Impartial\no : Nimber\nh : ∀ (i : G.RightMoves), Ne (G.moveRight i).grundyValue o\n⊢ LE.le G.grundyValue o","decl":"theorem grundyValue_le_of_forall_moveRight {G : PGame} [G.Impartial] {o : Nimber}\n    (h : ∀ i, grundyValue (G.moveRight i) ≠ o) : G.grundyValue ≤ o := by\n  contrapose! h\n  exact exists_grundyValue_moveRight_of_lt h\n\n"}
{"name":"SetTheory.PGame.grundyValue_nim_add_nim","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"x y : Ordinal.{u_1}\n⊢ Eq (HAdd.hAdd (SetTheory.PGame.nim x) (SetTheory.PGame.nim y)).grundyValue (HAdd.hAdd (Ordinal.toNimber x) (Ordinal.toNimber y))","decl":"/-- The Grundy value of the sum of two nim games equals their nimber addition. -/\ntheorem grundyValue_nim_add_nim (x y : Ordinal) : grundyValue (nim x + nim y) = ∗x + ∗y := by\n  apply (grundyValue_le_of_forall_moveLeft _).antisymm (le_grundyValue_of_Iio_subset_moveLeft _)\n  · intro i\n    apply leftMoves_add_cases i <;> intro j <;> have := (toLeftMovesNim_symm_lt j).ne\n    · simpa [grundyValue_nim_add_nim (toLeftMovesNim.symm j) y]\n    · simpa [grundyValue_nim_add_nim x (toLeftMovesNim.symm j)]\n  · intro k hk\n    obtain h | h := Nimber.lt_add_cases hk\n    · let a := toOrdinal (k + ∗y)\n      use toLeftMovesAdd (Sum.inl (toLeftMovesNim ⟨a, h⟩))\n      simp [a, grundyValue_nim_add_nim a y]\n    · let a := toOrdinal (k + ∗x)\n      use toLeftMovesAdd (Sum.inr (toLeftMovesNim ⟨a, h⟩))\n      simp [a, grundyValue_nim_add_nim x a, add_comm (∗x)]\ntermination_by (x, y)\n\n"}
{"name":"SetTheory.PGame.nim_add_nim_equiv","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"x y : Ordinal.{u_1}\n⊢ HasEquiv.Equiv (HAdd.hAdd (SetTheory.PGame.nim x) (SetTheory.PGame.nim y)) (SetTheory.PGame.nim (Nimber.toOrdinal (HAdd.hAdd (Ordinal.toNimber x) (Ordinal.toNimber y))))","decl":"theorem nim_add_nim_equiv (x y : Ordinal) :\n    nim x + nim y ≈ nim (toOrdinal (∗x + ∗y)) := by\n  rw [← grundyValue_eq_iff_equiv_nim, grundyValue_nim_add_nim]\n\n"}
{"name":"SetTheory.PGame.grundyValue_add","module":"Mathlib.SetTheory.Game.Nim","initialProofState":"G H : SetTheory.PGame\ninst✝¹ : G.Impartial\ninst✝ : H.Impartial\n⊢ Eq (HAdd.hAdd G H).grundyValue (HAdd.hAdd G.grundyValue H.grundyValue)","decl":"@[simp]\ntheorem grundyValue_add (G H : PGame) [G.Impartial] [H.Impartial] :\n    grundyValue (G + H) = grundyValue G + grundyValue H := by\n  rw [← (grundyValue G).toOrdinal_toNimber, ← (grundyValue H).toOrdinal_toNimber,\n    ← grundyValue_nim_add_nim, grundyValue_eq_iff_equiv]\n  exact add_congr (equiv_nim_grundyValue G) (equiv_nim_grundyValue H)\n\n"}
