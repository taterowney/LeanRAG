{"name":"MeasureTheory.OuterMeasure.IsMetric.finset_iUnion_of_pairwise_separated","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœ : EMetricSpace X\nÎ¼ : MeasureTheory.OuterMeasure X\nhm : Î¼.IsMetric\nI : Finset Î¹\ns : Î¹ â†’ Set X\nhI : âˆ€ (i : Î¹), Membership.mem I i â†’ âˆ€ (j : Î¹), Membership.mem I j â†’ Ne i j â†’ IsMetricSeparated (s i) (s j)\nâŠ¢ Eq (Î¼ (Set.iUnion fun i => Set.iUnion fun h => s i)) (I.sum fun i => Î¼ (s i))","decl":"/-- A metric outer measure is additive on a finite set of pairwise metric separated sets. -/\ntheorem finset_iUnion_of_pairwise_separated (hm : IsMetric Î¼) {I : Finset Î¹} {s : Î¹ â†’ Set X}\n    (hI : âˆ€ i âˆˆ I, âˆ€ j âˆˆ I, i â‰  j â†’ IsMetricSeparated (s i) (s j)) :\n    Î¼ (â‹ƒ i âˆˆ I, s i) = âˆ‘ i âˆˆ I, Î¼ (s i) := by\n  classical\n  induction' I using Finset.induction_on with i I hiI ihI hI\n  Â· simp\n  simp only [Finset.mem_insert] at hI\n  rw [Finset.set_biUnion_insert, hm, ihI, Finset.sum_insert hiI]\n  exacts [fun i hi j hj hij => hI i (Or.inr hi) j (Or.inr hj) hij,\n    IsMetricSeparated.finset_iUnion_right fun j hj =>\n      hI i (Or.inl rfl) j (Or.inr hj) (ne_of_mem_of_not_mem hj hiI).symm]\n\n"}
{"name":"MeasureTheory.OuterMeasure.IsMetric.borel_le_caratheodory","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nÎ¼ : MeasureTheory.OuterMeasure X\nhm : Î¼.IsMetric\nâŠ¢ LE.le (borel X) Î¼.caratheodory","decl":"/-- Caratheodory theorem. If `m` is a metric outer measure, then every Borel measurable set `t` is\nCaratheodory measurable: for any (not necessarily measurable) set `s` we have\n`Î¼ (s âˆ© t) + Î¼ (s \\ t) = Î¼ s`. -/\ntheorem borel_le_caratheodory (hm : IsMetric Î¼) : borel X â‰¤ Î¼.caratheodory := by\n  rw [borel_eq_generateFrom_isClosed]\n  refine MeasurableSpace.generateFrom_le fun t ht => Î¼.isCaratheodory_iff_le.2 fun s => ?_\n  set S : â„• â†’ Set X := fun n => {x âˆˆ s | (â†‘n)â»Â¹ â‰¤ infEdist x t}\n  have Ssep (n) : IsMetricSeparated (S n) t :=\n    âŸ¨nâ»Â¹, ENNReal.inv_ne_zero.2 (ENNReal.natCast_ne_top _),\n      fun x hx y hy â†¦ hx.2.trans <| infEdist_le_edist_of_mem hyâŸ©\n  have Ssep' : âˆ€ n, IsMetricSeparated (S n) (s âˆ© t) := fun n =>\n    (Ssep n).mono Subset.rfl inter_subset_right\n  have S_sub : âˆ€ n, S n âŠ† s \\ t := fun n =>\n    subset_inter inter_subset_left (Ssep n).subset_compl_right\n  have hSs : âˆ€ n, Î¼ (s âˆ© t) + Î¼ (S n) â‰¤ Î¼ s := fun n =>\n    calc\n      Î¼ (s âˆ© t) + Î¼ (S n) = Î¼ (s âˆ© t âˆª S n) := Eq.symm <| hm _ _ <| (Ssep' n).symm\n      _ â‰¤ Î¼ (s âˆ© t âˆª s \\ t) := Î¼.mono <| union_subset_union_right _ <| S_sub n\n      _ = Î¼ s := by rw [inter_union_diff]\n  have iUnion_S : â‹ƒ n, S n = s \\ t := by\n    refine Subset.antisymm (iUnion_subset S_sub) ?_\n    rintro x âŸ¨hxs, hxtâŸ©\n    rw [mem_iff_infEdist_zero_of_closed ht] at hxt\n    rcases ENNReal.exists_inv_nat_lt hxt with âŸ¨n, hnâŸ©\n    exact mem_iUnion.2 âŸ¨n, hxs, hn.leâŸ©\n  /- Now we have `âˆ€ n, Î¼ (s âˆ© t) + Î¼ (S n) â‰¤ Î¼ s` and we need to prove\n    `Î¼ (s âˆ© t) + Î¼ (â‹ƒ n, S n) â‰¤ Î¼ s`. We can't pass to the limit because\n    `Î¼` is only an outer measure. -/\n  by_cases htop : Î¼ (s \\ t) = âˆ\n  Â· rw [htop, add_top, â† htop]\n    exact Î¼.mono diff_subset\n  suffices Î¼ (â‹ƒ n, S n) â‰¤ â¨† n, Î¼ (S n) by calc\n    Î¼ (s âˆ© t) + Î¼ (s \\ t) = Î¼ (s âˆ© t) + Î¼ (â‹ƒ n, S n) := by rw [iUnion_S]\n    _ â‰¤ Î¼ (s âˆ© t) + â¨† n, Î¼ (S n) := by gcongr\n    _ = â¨† n, Î¼ (s âˆ© t) + Î¼ (S n) := ENNReal.add_iSup ..\n    _ â‰¤ Î¼ s := iSup_le hSs\n  /- It suffices to show that `âˆ‘' k, Î¼ (S (k + 1) \\ S k) â‰  âˆ`. Indeed, if we have this,\n    then for all `N` we have `Î¼ (â‹ƒ n, S n) â‰¤ Î¼ (S N) + âˆ‘' k, m (S (N + k + 1) \\ S (N + k))`\n    and the second term tends to zero, see `OuterMeasure.iUnion_nat_of_monotone_of_tsum_ne_top`\n    for details. -/\n  have : âˆ€ n, S n âŠ† S (n + 1) := fun n x hx =>\n    âŸ¨hx.1, le_trans (ENNReal.inv_le_inv.2 <| Nat.cast_le.2 n.le_succ) hx.2âŸ©\n  classical -- Porting note: Added this to get the next tactic to work\n  refine (Î¼.iUnion_nat_of_monotone_of_tsum_ne_top this ?_).le; clear this\n  /- While the sets `S (k + 1) \\ S k` are not pairwise metric separated, the sets in each\n    subsequence `S (2 * k + 1) \\ S (2 * k)` and `S (2 * k + 2) \\ S (2 * k)` are metric separated,\n    so `m` is additive on each of those sequences. -/\n  rw [â† tsum_even_add_odd ENNReal.summable ENNReal.summable, ENNReal.add_ne_top]\n  suffices âˆ€ a, (âˆ‘' k : â„•, Î¼ (S (2 * k + 1 + a) \\ S (2 * k + a))) â‰  âˆ from\n    âŸ¨by simpa using this 0, by simpa using this 1âŸ©\n  refine fun r => ne_top_of_le_ne_top htop ?_\n  rw [â† iUnion_S, ENNReal.tsum_eq_iSup_nat, iSup_le_iff]\n  intro n\n  rw [â† hm.finset_iUnion_of_pairwise_separated]\n  Â· exact Î¼.mono (iUnion_subset fun i => iUnion_subset fun _ x hx => mem_iUnion.2 âŸ¨_, hx.1âŸ©)\n  suffices âˆ€ i j, i < j â†’ IsMetricSeparated (S (2 * i + 1 + r)) (s \\ S (2 * j + r)) from\n    fun i _ j _ hij => hij.lt_or_lt.elim\n      (fun h => (this i j h).mono inter_subset_left fun x hx => by exact âŸ¨hx.1.1, hx.2âŸ©)\n      fun h => (this j i h).symm.mono (fun x hx => by exact âŸ¨hx.1.1, hx.2âŸ©) inter_subset_left\n  intro i j hj\n  have A : ((â†‘(2 * j + r))â»Â¹ : â„â‰¥0âˆ) < (â†‘(2 * i + 1 + r))â»Â¹ := by\n    rw [ENNReal.inv_lt_inv, Nat.cast_lt]; omega\n  refine âŸ¨(â†‘(2 * i + 1 + r))â»Â¹ - (â†‘(2 * j + r))â»Â¹, by simpa [tsub_eq_zero_iff_le] using A,\n    fun x hx y hy => ?_âŸ©\n  have : infEdist y t < (â†‘(2 * j + r))â»Â¹ := not_le.1 fun hle => hy.2 âŸ¨hy.1, hleâŸ©\n  rcases infEdist_lt_iff.mp this with âŸ¨z, hzt, hyzâŸ©\n  have hxz : (â†‘(2 * i + 1 + r))â»Â¹ â‰¤ edist x z := le_infEdist.1 hx.2 _ hzt\n  apply ENNReal.le_of_add_le_add_right hyz.ne_top\n  refine le_trans ?_ (edist_triangle _ _ _)\n  refine (add_le_add le_rfl hyz.le).trans (Eq.trans_le ?_ hxz)\n  rw [tsub_add_cancel_of_le A.le]\n\n"}
{"name":"MeasureTheory.OuterMeasure.IsMetric.le_caratheodory","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\nÎ¼ : MeasureTheory.OuterMeasure X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nhm : Î¼.IsMetric\nâŠ¢ LE.le instâœÂ¹ Î¼.caratheodory","decl":"theorem le_caratheodory [MeasurableSpace X] [BorelSpace X] (hm : IsMetric Î¼) :\n    â€¹MeasurableSpace Xâ€º â‰¤ Î¼.caratheodory := by\n  rw [BorelSpace.measurable_eq (Î± := X)]\n  exact hm.borel_le_caratheodory\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.le_pre","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nm : Set X â†’ ENNReal\nr : ENNReal\nÎ¼ : MeasureTheory.OuterMeasure X\nâŠ¢ Iff (LE.le Î¼ (MeasureTheory.OuterMeasure.mkMetric'.pre m r)) (âˆ€ (s : Set X), LE.le (EMetric.diam s) r â†’ LE.le (Î¼ s) (m s))","decl":"theorem le_pre : Î¼ â‰¤ pre m r â†” âˆ€ s : Set X, diam s â‰¤ r â†’ Î¼ s â‰¤ m s := by\n  simp only [pre, le_boundedBy, extend, le_iInf_iff]\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.pre_le","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nm : Set X â†’ ENNReal\nr : ENNReal\ns : Set X\nhs : LE.le (EMetric.diam s) r\nâŠ¢ LE.le ((MeasureTheory.OuterMeasure.mkMetric'.pre m r) s) (m s)","decl":"theorem pre_le (hs : diam s â‰¤ r) : pre m r s â‰¤ m s :=\n  (boundedBy_le _).trans <| iInf_le _ hs\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.mono_pre","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nm : Set X â†’ ENNReal\nr r' : ENNReal\nh : LE.le r r'\nâŠ¢ LE.le (MeasureTheory.OuterMeasure.mkMetric'.pre m r') (MeasureTheory.OuterMeasure.mkMetric'.pre m r)","decl":"theorem mono_pre (m : Set X â†’ â„â‰¥0âˆ) {r r' : â„â‰¥0âˆ} (h : r â‰¤ r') : pre m r' â‰¤ pre m r :=\n  le_pre.2 fun _ hs => pre_le (hs.trans h)\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.mono_pre_nat","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nm : Set X â†’ ENNReal\nâŠ¢ Monotone fun k => MeasureTheory.OuterMeasure.mkMetric'.pre m (Inv.inv â†‘k)","decl":"theorem mono_pre_nat (m : Set X â†’ â„â‰¥0âˆ) : Monotone fun k : â„• => pre m kâ»Â¹ :=\n  fun k l h => le_pre.2 fun _ hs => pre_le (hs.trans <| by simpa)\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.tendsto_pre","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nm : Set X â†’ ENNReal\ns : Set X\nâŠ¢ Filter.Tendsto (fun r => (MeasureTheory.OuterMeasure.mkMetric'.pre m r) s) (nhdsWithin 0 (Set.Ioi 0)) (nhds ((MeasureTheory.OuterMeasure.mkMetric' m) s))","decl":"theorem tendsto_pre (m : Set X â†’ â„â‰¥0âˆ) (s : Set X) :\n    Tendsto (fun r => pre m r s) (ğ“[>] 0) (ğ“ <| mkMetric' m s) := by\n  rw [â† map_coe_Ioi_atBot, tendsto_map'_iff]\n  simp only [mkMetric', OuterMeasure.iSup_apply, iSup_subtype']\n  exact tendsto_atBot_iSup fun r r' hr => mono_pre _ hr _\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.tendsto_pre_nat","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nm : Set X â†’ ENNReal\ns : Set X\nâŠ¢ Filter.Tendsto (fun n => (MeasureTheory.OuterMeasure.mkMetric'.pre m (Inv.inv â†‘n)) s) Filter.atTop (nhds ((MeasureTheory.OuterMeasure.mkMetric' m) s))","decl":"theorem tendsto_pre_nat (m : Set X â†’ â„â‰¥0âˆ) (s : Set X) :\n    Tendsto (fun n : â„• => pre m nâ»Â¹ s) atTop (ğ“ <| mkMetric' m s) := by\n  refine (tendsto_pre m s).comp (tendsto_inf.2 âŸ¨ENNReal.tendsto_inv_nat_nhds_zero, ?_âŸ©)\n  refine tendsto_principal.2 (Eventually.of_forall fun n => ?_)\n  simp\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.eq_iSup_nat","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nm : Set X â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.OuterMeasure.mkMetric' m) (iSup fun n => MeasureTheory.OuterMeasure.mkMetric'.pre m (Inv.inv â†‘n))","decl":"theorem eq_iSup_nat (m : Set X â†’ â„â‰¥0âˆ) : mkMetric' m = â¨† n : â„•, mkMetric'.pre m nâ»Â¹ := by\n  ext1 s\n  rw [iSup_apply]\n  refine tendsto_nhds_unique (mkMetric'.tendsto_pre_nat m s)\n    (tendsto_atTop_iSup fun k l hkl => mkMetric'.mono_pre_nat m hkl s)\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.trim_pre","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : OpensMeasurableSpace X\nm : Set X â†’ ENNReal\nhcl : âˆ€ (s : Set X), Eq (m (closure s)) (m s)\nr : ENNReal\nâŠ¢ Eq (MeasureTheory.OuterMeasure.mkMetric'.pre m r).trim (MeasureTheory.OuterMeasure.mkMetric'.pre m r)","decl":"/-- `MeasureTheory.OuterMeasure.mkMetric'.pre m r` is a trimmed measure provided that\n`m (closure s) = m s` for any set `s`. -/\ntheorem trim_pre [MeasurableSpace X] [OpensMeasurableSpace X] (m : Set X â†’ â„â‰¥0âˆ)\n    (hcl : âˆ€ s, m (closure s) = m s) (r : â„â‰¥0âˆ) : (pre m r).trim = pre m r := by\n  refine le_antisymm (le_pre.2 fun s hs => ?_) (le_trim _)\n  rw [trim_eq_iInf]\n  refine iInf_le_of_le (closure s) <| iInf_le_of_le subset_closure <|\n    iInf_le_of_le measurableSet_closure ((pre_le ?_).trans_eq (hcl _))\n  rwa [diam_closure]\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'_isMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nm : Set X â†’ ENNReal\nâŠ¢ (MeasureTheory.OuterMeasure.mkMetric' m).IsMetric","decl":"/-- An outer measure constructed using `OuterMeasure.mkMetric'` is a metric outer measure. -/\ntheorem mkMetric'_isMetric (m : Set X â†’ â„â‰¥0âˆ) : (mkMetric' m).IsMetric := by\n  rintro s t âŸ¨r, r0, hrâŸ©\n  refine tendsto_nhds_unique_of_eventuallyEq\n    (mkMetric'.tendsto_pre _ _) ((mkMetric'.tendsto_pre _ _).add (mkMetric'.tendsto_pre _ _)) ?_\n  rw [â† pos_iff_ne_zero] at r0\n  filter_upwards [Ioo_mem_nhdsGT r0]\n  rintro Îµ âŸ¨_, ÎµrâŸ©\n  refine boundedBy_union_of_top_of_nonempty_inter ?_\n  rintro u âŸ¨x, hxs, hxuâŸ© âŸ¨y, hyt, hyuâŸ©\n  have : Îµ < diam u := Îµr.trans_le ((hr x hxs y hyt).trans <| edist_le_diam_of_mem hxu hyu)\n  exact iInf_eq_top.2 fun h => (this.not_le h).elim\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric_mono_smul","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nmâ‚ mâ‚‚ : ENNReal â†’ ENNReal\nc : ENNReal\nhc : Ne c Top.top\nh0 : Ne c 0\nhle : (nhdsWithin 0 (Set.Ici 0)).EventuallyLE mâ‚ (HSMul.hSMul c mâ‚‚)\nâŠ¢ LE.le (MeasureTheory.OuterMeasure.mkMetric mâ‚) (HSMul.hSMul c (MeasureTheory.OuterMeasure.mkMetric mâ‚‚))","decl":"/-- If `c âˆ‰ {0, âˆ}` and `mâ‚ d â‰¤ c * mâ‚‚ d` for `d < Îµ` for some `Îµ > 0`\n(we use `â‰¤á¶ [ğ“[â‰¥] 0]` to state this), then `mkMetric mâ‚ hmâ‚ â‰¤ c â€¢ mkMetric mâ‚‚ hmâ‚‚`. -/\ntheorem mkMetric_mono_smul {mâ‚ mâ‚‚ : â„â‰¥0âˆ â†’ â„â‰¥0âˆ} {c : â„â‰¥0âˆ} (hc : c â‰  âˆ) (h0 : c â‰  0)\n    (hle : mâ‚ â‰¤á¶ [ğ“[â‰¥] 0] c â€¢ mâ‚‚) : (mkMetric mâ‚ : OuterMeasure X) â‰¤ c â€¢ mkMetric mâ‚‚ := by\n  classical\n  rcases (mem_nhdsGE_iff_exists_Ico_subset' zero_lt_one).1 hle with âŸ¨r, hr0, hrâŸ©\n  refine fun s =>\n    le_of_tendsto_of_tendsto (mkMetric'.tendsto_pre _ s)\n      (ENNReal.Tendsto.const_mul (mkMetric'.tendsto_pre _ s) (Or.inr hc))\n      (mem_of_superset (Ioo_mem_nhdsGT hr0) fun r' hr' => ?_)\n  simp only [mem_setOf_eq, mkMetric'.pre, RingHom.id_apply]\n  rw [â† smul_eq_mul, â† smul_apply, smul_boundedBy hc]\n  refine le_boundedBy.2 (fun t => (boundedBy_le _).trans ?_) _\n  simp only [smul_eq_mul, Pi.smul_apply, extend, iInf_eq_if]\n  split_ifs with ht\n  Â· apply hr\n    exact âŸ¨zero_le _, ht.trans_lt hr'.2âŸ©\n  Â· simp [h0]\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric_top","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nâŠ¢ Eq (MeasureTheory.OuterMeasure.mkMetric fun x => Top.top) Top.top","decl":"@[simp]\ntheorem mkMetric_top : (mkMetric (fun _ => âˆ : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) : OuterMeasure X) = âŠ¤ := by\n  simp_rw [mkMetric, mkMetric', mkMetric'.pre, extend_top, boundedBy_top, eq_top_iff]\n  rw [le_iSup_iff]\n  intro b hb\n  simpa using hb âŠ¤\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric_mono","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nmâ‚ mâ‚‚ : ENNReal â†’ ENNReal\nhle : (nhdsWithin 0 (Set.Ici 0)).EventuallyLE mâ‚ mâ‚‚\nâŠ¢ LE.le (MeasureTheory.OuterMeasure.mkMetric mâ‚) (MeasureTheory.OuterMeasure.mkMetric mâ‚‚)","decl":"/-- If `mâ‚ d â‰¤ mâ‚‚ d` for `d < Îµ` for some `Îµ > 0` (we use `â‰¤á¶ [ğ“[â‰¥] 0]` to state this), then\n`mkMetric mâ‚ hmâ‚ â‰¤ mkMetric mâ‚‚ hmâ‚‚`. -/\ntheorem mkMetric_mono {mâ‚ mâ‚‚ : â„â‰¥0âˆ â†’ â„â‰¥0âˆ} (hle : mâ‚ â‰¤á¶ [ğ“[â‰¥] 0] mâ‚‚) :\n    (mkMetric mâ‚ : OuterMeasure X) â‰¤ mkMetric mâ‚‚ := by\n  convert @mkMetric_mono_smul X _ _ mâ‚‚ _ ENNReal.one_ne_top one_ne_zero _ <;> simp [*]\n\n"}
{"name":"MeasureTheory.OuterMeasure.isometry_comap_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœÂ¹ : EMetricSpace X\ninstâœ : EMetricSpace Y\nm : ENNReal â†’ ENNReal\nf : X â†’ Y\nhf : Isometry f\nH : Or (Monotone m) (Function.Surjective f)\nâŠ¢ Eq ((MeasureTheory.OuterMeasure.comap f) (MeasureTheory.OuterMeasure.mkMetric m)) (MeasureTheory.OuterMeasure.mkMetric m)","decl":"theorem isometry_comap_mkMetric (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) {f : X â†’ Y} (hf : Isometry f)\n    (H : Monotone m âˆ¨ Surjective f) : comap f (mkMetric m) = mkMetric m := by\n  simp only [mkMetric, mkMetric', mkMetric'.pre, inducedOuterMeasure, comap_iSup]\n  refine surjective_id.iSup_congr id fun Îµ => surjective_id.iSup_congr id fun hÎµ => ?_\n  rw [comap_boundedBy _ (H.imp _ id)]\n  Â· congr with s : 1\n    apply extend_congr\n    Â· simp [hf.ediam_image]\n    Â· intros; simp [hf.injective.subsingleton_image_iff, hf.ediam_image]\n  Â· intro h_mono s t hst\n    simp only [extend, le_iInf_iff]\n    intro ht\n    apply le_trans _ (h_mono (diam_mono hst))\n    simp only [(diam_mono hst).trans ht, le_refl, ciInf_pos]\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric_smul","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nm : ENNReal â†’ ENNReal\nc : ENNReal\nhc : Ne c Top.top\nhc' : Ne c 0\nâŠ¢ Eq (MeasureTheory.OuterMeasure.mkMetric (HSMul.hSMul c m)) (HSMul.hSMul c (MeasureTheory.OuterMeasure.mkMetric m))","decl":"theorem mkMetric_smul (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) {c : â„â‰¥0âˆ} (hc : c â‰  âˆ) (hc' : c â‰  0) :\n    (mkMetric (c â€¢ m) : OuterMeasure X) = c â€¢ mkMetric m := by\n  simp only [mkMetric, mkMetric', mkMetric'.pre, inducedOuterMeasure, ENNReal.smul_iSup]\n  simp_rw [smul_iSup, smul_boundedBy hc, smul_extend _ hc', Pi.smul_apply]\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric_nnreal_smul","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nm : ENNReal â†’ ENNReal\nc : NNReal\nhc : Ne c 0\nâŠ¢ Eq (MeasureTheory.OuterMeasure.mkMetric (HSMul.hSMul c m)) (HSMul.hSMul c (MeasureTheory.OuterMeasure.mkMetric m))","decl":"theorem mkMetric_nnreal_smul (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) {c : â„â‰¥0} (hc : c â‰  0) :\n    (mkMetric (c â€¢ m) : OuterMeasure X) = c â€¢ mkMetric m := by\n  rw [ENNReal.smul_def, ENNReal.smul_def,\n    mkMetric_smul m ENNReal.coe_ne_top (ENNReal.coe_ne_zero.mpr hc)]\n\n"}
{"name":"MeasureTheory.OuterMeasure.isometry_map_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœÂ¹ : EMetricSpace X\ninstâœ : EMetricSpace Y\nm : ENNReal â†’ ENNReal\nf : X â†’ Y\nhf : Isometry f\nH : Or (Monotone m) (Function.Surjective f)\nâŠ¢ Eq ((MeasureTheory.OuterMeasure.map f) (MeasureTheory.OuterMeasure.mkMetric m)) ((MeasureTheory.OuterMeasure.restrict (Set.range f)) (MeasureTheory.OuterMeasure.mkMetric m))","decl":"theorem isometry_map_mkMetric (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) {f : X â†’ Y} (hf : Isometry f)\n    (H : Monotone m âˆ¨ Surjective f) : map f (mkMetric m) = restrict (range f) (mkMetric m) := by\n  rw [â† isometry_comap_mkMetric _ hf H, map_comap]\n\n"}
{"name":"MeasureTheory.OuterMeasure.isometryEquiv_comap_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœÂ¹ : EMetricSpace X\ninstâœ : EMetricSpace Y\nm : ENNReal â†’ ENNReal\nf : IsometryEquiv X Y\nâŠ¢ Eq ((MeasureTheory.OuterMeasure.comap â‡‘f) (MeasureTheory.OuterMeasure.mkMetric m)) (MeasureTheory.OuterMeasure.mkMetric m)","decl":"theorem isometryEquiv_comap_mkMetric (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) (f : X â‰ƒáµ¢ Y) :\n    comap f (mkMetric m) = mkMetric m :=\n  isometry_comap_mkMetric _ f.isometry (Or.inr f.surjective)\n\n"}
{"name":"MeasureTheory.OuterMeasure.isometryEquiv_map_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœÂ¹ : EMetricSpace X\ninstâœ : EMetricSpace Y\nm : ENNReal â†’ ENNReal\nf : IsometryEquiv X Y\nâŠ¢ Eq ((MeasureTheory.OuterMeasure.map â‡‘f) (MeasureTheory.OuterMeasure.mkMetric m)) (MeasureTheory.OuterMeasure.mkMetric m)","decl":"theorem isometryEquiv_map_mkMetric (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) (f : X â‰ƒáµ¢ Y) :\n    map f (mkMetric m) = mkMetric m := by\n  rw [â† isometryEquiv_comap_mkMetric _ f, map_comap_of_surjective f.surjective]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nm : ENNReal â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.OuterMeasure.mkMetric m).trim (MeasureTheory.OuterMeasure.mkMetric m)","decl":"theorem trim_mkMetric [MeasurableSpace X] [BorelSpace X] (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) :\n    (mkMetric m : OuterMeasure X).trim = mkMetric m := by\n  simp only [mkMetric, mkMetric'.eq_iSup_nat, trim_iSup]\n  congr 1 with n : 1\n  refine mkMetric'.trim_pre _ (fun s => ?_) _\n  simp\n\n"}
{"name":"MeasureTheory.OuterMeasure.le_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœ : EMetricSpace X\nm : ENNReal â†’ ENNReal\nÎ¼ : MeasureTheory.OuterMeasure X\nr : ENNReal\nh0 : LT.lt 0 r\nhr : âˆ€ (s : Set X), LE.le (EMetric.diam s) r â†’ LE.le (Î¼ s) (m (EMetric.diam s))\nâŠ¢ LE.le Î¼ (MeasureTheory.OuterMeasure.mkMetric m)","decl":"theorem le_mkMetric (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) (Î¼ : OuterMeasure X) (r : â„â‰¥0âˆ) (h0 : 0 < r)\n    (hr : âˆ€ s, diam s â‰¤ r â†’ Î¼ s â‰¤ m (diam s)) : Î¼ â‰¤ mkMetric m :=\n  le_iSupâ‚‚_of_le r h0 <| mkMetric'.le_pre.2 fun _ hs => hr _ hs\n\n"}
{"name":"MeasureTheory.Measure.mkMetric'_toOuterMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nm : Set X â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.Measure.mkMetric' m).toOuterMeasure (MeasureTheory.OuterMeasure.mkMetric' m).trim","decl":"@[simp]\ntheorem mkMetric'_toOuterMeasure (m : Set X â†’ â„â‰¥0âˆ) :\n    (mkMetric' m).toOuterMeasure = (OuterMeasure.mkMetric' m).trim :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_toOuterMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nm : ENNReal â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.Measure.mkMetric m).toOuterMeasure (MeasureTheory.OuterMeasure.mkMetric m)","decl":"@[simp]\ntheorem mkMetric_toOuterMeasure (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) :\n    (mkMetric m : Measure X).toOuterMeasure = OuterMeasure.mkMetric m :=\n  OuterMeasure.trim_mkMetric m\n\n"}
{"name":"MeasureTheory.OuterMeasure.coe_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nm : ENNReal â†’ ENNReal\nâŠ¢ Eq â‡‘(MeasureTheory.OuterMeasure.mkMetric m) â‡‘(MeasureTheory.Measure.mkMetric m)","decl":"theorem OuterMeasure.coe_mkMetric [MeasurableSpace X] [BorelSpace X] (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) :\n    â‡‘(OuterMeasure.mkMetric m : OuterMeasure X) = Measure.mkMetric m := by\n  rw [â† Measure.mkMetric_toOuterMeasure, Measure.coe_toOuterMeasure]\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_mono_smul","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nmâ‚ mâ‚‚ : ENNReal â†’ ENNReal\nc : ENNReal\nhc : Ne c Top.top\nh0 : Ne c 0\nhle : (nhdsWithin 0 (Set.Ici 0)).EventuallyLE mâ‚ (HSMul.hSMul c mâ‚‚)\nâŠ¢ LE.le (MeasureTheory.Measure.mkMetric mâ‚) (HSMul.hSMul c (MeasureTheory.Measure.mkMetric mâ‚‚))","decl":"/-- If `c âˆ‰ {0, âˆ}` and `mâ‚ d â‰¤ c * mâ‚‚ d` for `d < Îµ` for some `Îµ > 0`\n(we use `â‰¤á¶ [ğ“[â‰¥] 0]` to state this), then `mkMetric mâ‚ hmâ‚ â‰¤ c â€¢ mkMetric mâ‚‚ hmâ‚‚`. -/\ntheorem mkMetric_mono_smul {mâ‚ mâ‚‚ : â„â‰¥0âˆ â†’ â„â‰¥0âˆ} {c : â„â‰¥0âˆ} (hc : c â‰  âˆ) (h0 : c â‰  0)\n    (hle : mâ‚ â‰¤á¶ [ğ“[â‰¥] 0] c â€¢ mâ‚‚) : (mkMetric mâ‚ : Measure X) â‰¤ c â€¢ mkMetric mâ‚‚ := fun s â†¦ by\n  rw [â† OuterMeasure.coe_mkMetric, coe_smul, â† OuterMeasure.coe_mkMetric]\n  exact OuterMeasure.mkMetric_mono_smul hc h0 hle s\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_top","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nâŠ¢ Eq (MeasureTheory.Measure.mkMetric fun x => Top.top) Top.top","decl":"@[simp]\ntheorem mkMetric_top : (mkMetric (fun _ => âˆ : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) : Measure X) = âŠ¤ := by\n  apply toOuterMeasure_injective\n  rw [mkMetric_toOuterMeasure, OuterMeasure.mkMetric_top, toOuterMeasure_top]\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_mono","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nmâ‚ mâ‚‚ : ENNReal â†’ ENNReal\nhle : (nhdsWithin 0 (Set.Ici 0)).EventuallyLE mâ‚ mâ‚‚\nâŠ¢ LE.le (MeasureTheory.Measure.mkMetric mâ‚) (MeasureTheory.Measure.mkMetric mâ‚‚)","decl":"/-- If `mâ‚ d â‰¤ mâ‚‚ d` for `d < Îµ` for some `Îµ > 0` (we use `â‰¤á¶ [ğ“[â‰¥] 0]` to state this), then\n`mkMetric mâ‚ hmâ‚ â‰¤ mkMetric mâ‚‚ hmâ‚‚`. -/\ntheorem mkMetric_mono {mâ‚ mâ‚‚ : â„â‰¥0âˆ â†’ â„â‰¥0âˆ} (hle : mâ‚ â‰¤á¶ [ğ“[â‰¥] 0] mâ‚‚) :\n    (mkMetric mâ‚ : Measure X) â‰¤ mkMetric mâ‚‚ := by\n  convert @mkMetric_mono_smul X _ _ _ _ mâ‚‚ _ ENNReal.one_ne_top one_ne_zero _ <;> simp [*]\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_apply","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nm : ENNReal â†’ ENNReal\ns : Set X\nâŠ¢ Eq ((MeasureTheory.Measure.mkMetric m) s) (iSup fun r => iSup fun x => iInf fun t => iInf fun x => iInf fun x => tsum fun n => iSup fun x => m (EMetric.diam (t n)))","decl":"/-- A formula for `MeasureTheory.Measure.mkMetric`. -/\ntheorem mkMetric_apply (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) (s : Set X) :\n    mkMetric m s =\n      â¨† (r : â„â‰¥0âˆ) (_ : 0 < r),\n        â¨… (t : â„• â†’ Set X) (_ : s âŠ† iUnion t) (_ : âˆ€ n, diam (t n) â‰¤ r),\n          âˆ‘' n, â¨† _ : (t n).Nonempty, m (diam (t n)) := by\n  classical\n  -- We mostly unfold the definitions but we need to switch the order of `âˆ‘'` and `â¨…`\n  simp only [â† OuterMeasure.coe_mkMetric, OuterMeasure.mkMetric, OuterMeasure.mkMetric',\n    OuterMeasure.iSup_apply, OuterMeasure.mkMetric'.pre, OuterMeasure.boundedBy_apply, extend]\n  refine\n    surjective_id.iSup_congr id fun r =>\n      iSup_congr_Prop Iff.rfl fun _ =>\n        surjective_id.iInf_congr _ fun t => iInf_congr_Prop Iff.rfl fun ht => ?_\n  dsimp\n  by_cases htr : âˆ€ n, diam (t n) â‰¤ r\n  Â· rw [iInf_eq_if, if_pos htr]\n    congr 1 with n : 1\n    simp only [iInf_eq_if, htr n, id, if_true, iSup_and']\n  Â· rw [iInf_eq_if, if_neg htr]\n    push_neg at htr; rcases htr with âŸ¨n, hnâŸ©\n    refine ENNReal.tsum_eq_top_of_eq_top âŸ¨n, ?_âŸ©\n    rw [iSup_eq_if, if_pos, iInf_eq_if, if_neg]\n    Â· exact hn.not_le\n    rcases diam_pos_iff.1 ((zero_le r).trans_lt hn) with âŸ¨x, hx, -âŸ©\n    exact âŸ¨x, hxâŸ©\n\n"}
{"name":"MeasureTheory.Measure.le_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nm : ENNReal â†’ ENNReal\nÎ¼ : MeasureTheory.Measure X\nÎµ : ENNReal\nhâ‚€ : LT.lt 0 Îµ\nh : âˆ€ (s : Set X), LE.le (EMetric.diam s) Îµ â†’ LE.le (Î¼ s) (m (EMetric.diam s))\nâŠ¢ LE.le Î¼ (MeasureTheory.Measure.mkMetric m)","decl":"theorem le_mkMetric (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) (Î¼ : Measure X) (Îµ : â„â‰¥0âˆ) (hâ‚€ : 0 < Îµ)\n    (h : âˆ€ s : Set X, diam s â‰¤ Îµ â†’ Î¼ s â‰¤ m (diam s)) : Î¼ â‰¤ mkMetric m := by\n  rw [â† toOuterMeasure_le, mkMetric_toOuterMeasure]\n  exact OuterMeasure.le_mkMetric m Î¼.toOuterMeasure Îµ hâ‚€ h\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_le_liminf_tsum","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ³ : EMetricSpace X\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : BorelSpace X\nÎ² : Type u_4\nÎ¹ : Î² â†’ Type u_5\ninstâœ : âˆ€ (n : Î²), Countable (Î¹ n)\ns : Set X\nl : Filter Î²\nr : Î² â†’ ENNReal\nhr : Filter.Tendsto r l (nhds 0)\nt : (n : Î²) â†’ Î¹ n â†’ Set X\nht : Filter.Eventually (fun n => âˆ€ (i : Î¹ n), LE.le (EMetric.diam (t n i)) (r n)) l\nhst : Filter.Eventually (fun n => HasSubset.Subset s (Set.iUnion fun i => t n i)) l\nm : ENNReal â†’ ENNReal\nâŠ¢ LE.le ((MeasureTheory.Measure.mkMetric m) s) (Filter.liminf (fun n => tsum fun i => m (EMetric.diam (t n i))) l)","decl":"/-- To bound the Hausdorff measure (or, more generally, for a measure defined using\n`MeasureTheory.Measure.mkMetric`) of a set, one may use coverings with maximum diameter tending to\n`0`, indexed by any sequence of countable types. -/\ntheorem mkMetric_le_liminf_tsum {Î² : Type*} {Î¹ : Î² â†’ Type*} [âˆ€ n, Countable (Î¹ n)] (s : Set X)\n    {l : Filter Î²} (r : Î² â†’ â„â‰¥0âˆ) (hr : Tendsto r l (ğ“ 0)) (t : âˆ€ n : Î², Î¹ n â†’ Set X)\n    (ht : âˆ€á¶  n in l, âˆ€ i, diam (t n i) â‰¤ r n) (hst : âˆ€á¶  n in l, s âŠ† â‹ƒ i, t n i) (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) :\n    mkMetric m s â‰¤ liminf (fun n => âˆ‘' i, m (diam (t n i))) l := by\n  haveI : âˆ€ n, Encodable (Î¹ n) := fun n => Encodable.ofCountable _\n  simp only [mkMetric_apply]\n  refine iSupâ‚‚_le fun Îµ hÎµ => ?_\n  refine le_of_forall_gt_imp_ge_of_dense fun c hc => ?_\n  rcases ((frequently_lt_of_liminf_lt (by isBoundedDefault) hc).and_eventually\n        ((hr.eventually (gt_mem_nhds hÎµ)).and (ht.and hst))).exists with\n    âŸ¨n, hn, hrn, htn, hstnâŸ©\n  set u : â„• â†’ Set X := fun j => â‹ƒ b âˆˆ decodeâ‚‚ (Î¹ n) j, t n b\n  refine iInfâ‚‚_le_of_le u (by rwa [iUnion_decodeâ‚‚]) ?_\n  refine iInf_le_of_le (fun j => ?_) ?_\n  Â· rw [EMetric.diam_iUnion_mem_option]\n    exact iSupâ‚‚_le fun _ _ => (htn _).trans hrn.le\n  Â· calc\n      (âˆ‘' j : â„•, â¨† _ : (u j).Nonempty, m (diam (u j))) = _ :=\n        tsum_iUnion_decodeâ‚‚ (fun t : Set X => â¨† _ : t.Nonempty, m (diam t)) (by simp) _\n      _ â‰¤ âˆ‘' i : Î¹ n, m (diam (t n i)) := ENNReal.tsum_le_tsum fun b => iSup_le fun _ => le_rfl\n      _ â‰¤ c := hn.le\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_le_liminf_sum","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nÎ² : Type u_4\nÎ¹ : Î² â†’ Type u_5\nhÎ¹ : (n : Î²) â†’ Fintype (Î¹ n)\ns : Set X\nl : Filter Î²\nr : Î² â†’ ENNReal\nhr : Filter.Tendsto r l (nhds 0)\nt : (n : Î²) â†’ Î¹ n â†’ Set X\nht : Filter.Eventually (fun n => âˆ€ (i : Î¹ n), LE.le (EMetric.diam (t n i)) (r n)) l\nhst : Filter.Eventually (fun n => HasSubset.Subset s (Set.iUnion fun i => t n i)) l\nm : ENNReal â†’ ENNReal\nâŠ¢ LE.le ((MeasureTheory.Measure.mkMetric m) s) (Filter.liminf (fun n => Finset.univ.sum fun i => m (EMetric.diam (t n i))) l)","decl":"/-- To bound the Hausdorff measure (or, more generally, for a measure defined using\n`MeasureTheory.Measure.mkMetric`) of a set, one may use coverings with maximum diameter tending to\n`0`, indexed by any sequence of finite types. -/\ntheorem mkMetric_le_liminf_sum {Î² : Type*} {Î¹ : Î² â†’ Type*} [hÎ¹ : âˆ€ n, Fintype (Î¹ n)] (s : Set X)\n    {l : Filter Î²} (r : Î² â†’ â„â‰¥0âˆ) (hr : Tendsto r l (ğ“ 0)) (t : âˆ€ n : Î², Î¹ n â†’ Set X)\n    (ht : âˆ€á¶  n in l, âˆ€ i, diam (t n i) â‰¤ r n) (hst : âˆ€á¶  n in l, s âŠ† â‹ƒ i, t n i) (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) :\n    mkMetric m s â‰¤ liminf (fun n => âˆ‘ i, m (diam (t n i))) l := by\n  simpa only [tsum_fintype] using mkMetric_le_liminf_tsum s r hr t ht hst m\n\n"}
{"name":"MeasureTheory.Measure.le_hausdorffMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nd : Real\nÎ¼ : MeasureTheory.Measure X\nÎµ : ENNReal\nhâ‚€ : LT.lt 0 Îµ\nh : âˆ€ (s : Set X), LE.le (EMetric.diam s) Îµ â†’ LE.le (Î¼ s) (HPow.hPow (EMetric.diam s) d)\nâŠ¢ LE.le Î¼ (MeasureTheory.Measure.hausdorffMeasure d)","decl":"theorem le_hausdorffMeasure (d : â„) (Î¼ : Measure X) (Îµ : â„â‰¥0âˆ) (hâ‚€ : 0 < Îµ)\n    (h : âˆ€ s : Set X, diam s â‰¤ Îµ â†’ Î¼ s â‰¤ diam s ^ d) : Î¼ â‰¤ Î¼H[d] :=\n  le_mkMetric _ Î¼ Îµ hâ‚€ h\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_apply","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nd : Real\ns : Set X\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) s) (iSup fun r => iSup fun x => iInf fun t => iInf fun x => iInf fun x => tsum fun n => iSup fun x => HPow.hPow (EMetric.diam (t n)) d)","decl":"/-- A formula for `Î¼H[d] s`. -/\ntheorem hausdorffMeasure_apply (d : â„) (s : Set X) :\n    Î¼H[d] s =\n      â¨† (r : â„â‰¥0âˆ) (_ : 0 < r),\n        â¨… (t : â„• â†’ Set X) (_ : s âŠ† â‹ƒ n, t n) (_ : âˆ€ n, diam (t n) â‰¤ r),\n          âˆ‘' n, â¨† _ : (t n).Nonempty, diam (t n) ^ d :=\n  mkMetric_apply _ _\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_le_liminf_tsum","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ³ : EMetricSpace X\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : BorelSpace X\nÎ² : Type u_4\nÎ¹ : Î² â†’ Type u_5\ninstâœ : âˆ€ (n : Î²), Countable (Î¹ n)\nd : Real\ns : Set X\nl : Filter Î²\nr : Î² â†’ ENNReal\nhr : Filter.Tendsto r l (nhds 0)\nt : (n : Î²) â†’ Î¹ n â†’ Set X\nht : Filter.Eventually (fun n => âˆ€ (i : Î¹ n), LE.le (EMetric.diam (t n i)) (r n)) l\nhst : Filter.Eventually (fun n => HasSubset.Subset s (Set.iUnion fun i => t n i)) l\nâŠ¢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) s) (Filter.liminf (fun n => tsum fun i => HPow.hPow (EMetric.diam (t n i)) d) l)","decl":"/-- To bound the Hausdorff measure of a set, one may use coverings with maximum diameter tending\nto `0`, indexed by any sequence of countable types. -/\ntheorem hausdorffMeasure_le_liminf_tsum {Î² : Type*} {Î¹ : Î² â†’ Type*} [âˆ€ n, Countable (Î¹ n)]\n    (d : â„) (s : Set X) {l : Filter Î²} (r : Î² â†’ â„â‰¥0âˆ) (hr : Tendsto r l (ğ“ 0))\n    (t : âˆ€ n : Î², Î¹ n â†’ Set X) (ht : âˆ€á¶  n in l, âˆ€ i, diam (t n i) â‰¤ r n)\n    (hst : âˆ€á¶  n in l, s âŠ† â‹ƒ i, t n i) : Î¼H[d] s â‰¤ liminf (fun n => âˆ‘' i, diam (t n i) ^ d) l :=\n  mkMetric_le_liminf_tsum s r hr t ht hst _\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_le_liminf_sum","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ³ : EMetricSpace X\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : BorelSpace X\nÎ² : Type u_4\nÎ¹ : Î² â†’ Type u_5\ninstâœ : (n : Î²) â†’ Fintype (Î¹ n)\nd : Real\ns : Set X\nl : Filter Î²\nr : Î² â†’ ENNReal\nhr : Filter.Tendsto r l (nhds 0)\nt : (n : Î²) â†’ Î¹ n â†’ Set X\nht : Filter.Eventually (fun n => âˆ€ (i : Î¹ n), LE.le (EMetric.diam (t n i)) (r n)) l\nhst : Filter.Eventually (fun n => HasSubset.Subset s (Set.iUnion fun i => t n i)) l\nâŠ¢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) s) (Filter.liminf (fun n => Finset.univ.sum fun i => HPow.hPow (EMetric.diam (t n i)) d) l)","decl":"/-- To bound the Hausdorff measure of a set, one may use coverings with maximum diameter tending\nto `0`, indexed by any sequence of finite types. -/\ntheorem hausdorffMeasure_le_liminf_sum {Î² : Type*} {Î¹ : Î² â†’ Type*} [âˆ€ n, Fintype (Î¹ n)]\n    (d : â„) (s : Set X) {l : Filter Î²} (r : Î² â†’ â„â‰¥0âˆ) (hr : Tendsto r l (ğ“ 0))\n    (t : âˆ€ n : Î², Î¹ n â†’ Set X) (ht : âˆ€á¶  n in l, âˆ€ i, diam (t n i) â‰¤ r n)\n    (hst : âˆ€á¶  n in l, s âŠ† â‹ƒ i, t n i) : Î¼H[d] s â‰¤ liminf (fun n => âˆ‘ i, diam (t n i) ^ d) l :=\n  mkMetric_le_liminf_sum s r hr t ht hst _\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_zero_or_top","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\ndâ‚ dâ‚‚ : Real\nh : LT.lt dâ‚ dâ‚‚\ns : Set X\nâŠ¢ Or (Eq ((MeasureTheory.Measure.hausdorffMeasure dâ‚‚) s) 0) (Eq ((MeasureTheory.Measure.hausdorffMeasure dâ‚) s) Top.top)","decl":"/-- If `dâ‚ < dâ‚‚`, then for any set `s` we have either `Î¼H[dâ‚‚] s = 0`, or `Î¼H[dâ‚] s = âˆ`. -/\ntheorem hausdorffMeasure_zero_or_top {dâ‚ dâ‚‚ : â„} (h : dâ‚ < dâ‚‚) (s : Set X) :\n    Î¼H[dâ‚‚] s = 0 âˆ¨ Î¼H[dâ‚] s = âˆ := by\n  by_contra! H\n  suffices âˆ€ c : â„â‰¥0, c â‰  0 â†’ Î¼H[dâ‚‚] s â‰¤ c * Î¼H[dâ‚] s by\n    rcases ENNReal.exists_nnreal_pos_mul_lt H.2 H.1 with âŸ¨c, hc0, hcâŸ©\n    exact hc.not_le (this c (pos_iff_ne_zero.1 hc0))\n  intro c hc\n  refine le_iff'.1 (mkMetric_mono_smul ENNReal.coe_ne_top (mod_cast hc) ?_) s\n  have : 0 < ((c : â„â‰¥0âˆ) ^ (dâ‚‚ - dâ‚)â»Â¹) := by\n    rw [â† ENNReal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, Ne, ENNReal.coe_eq_zero,\n      NNReal.rpow_eq_zero_iff]\n    exact mt And.left hc\n  filter_upwards [Ico_mem_nhdsGE this]\n  rintro r âŸ¨hrâ‚€, hrcâŸ©\n  lift r to â„â‰¥0 using ne_top_of_lt hrc\n  rw [Pi.smul_apply, smul_eq_mul,\n    â† ENNReal.div_le_iff_le_mul (Or.inr ENNReal.coe_ne_top) (Or.inr <| mt ENNReal.coe_eq_zero.1 hc)]\n  rcases eq_or_ne r 0 with (rfl | hrâ‚€)\n  Â· rcases lt_or_le 0 dâ‚‚ with (hâ‚‚ | hâ‚‚)\n    Â· simp only [hâ‚‚, ENNReal.zero_rpow_of_pos, zero_le, ENNReal.zero_div, ENNReal.coe_zero]\n    Â· simp only [h.trans_le hâ‚‚, ENNReal.div_top, zero_le, ENNReal.zero_rpow_of_neg,\n        ENNReal.coe_zero]\n  Â· have : (r : â„â‰¥0âˆ) â‰  0 := by simpa only [ENNReal.coe_eq_zero, Ne] using hrâ‚€\n    rw [â† ENNReal.rpow_sub _ _ this ENNReal.coe_ne_top]\n    refine (ENNReal.rpow_lt_rpow hrc (sub_pos.2 h)).le.trans ?_\n    rw [â† ENNReal.rpow_mul, inv_mul_cancelâ‚€ (sub_pos.2 h).ne', ENNReal.rpow_one]\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_mono","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\ndâ‚ dâ‚‚ : Real\nh : LE.le dâ‚ dâ‚‚\ns : Set X\nâŠ¢ LE.le ((MeasureTheory.Measure.hausdorffMeasure dâ‚‚) s) ((MeasureTheory.Measure.hausdorffMeasure dâ‚) s)","decl":"/-- Hausdorff measure `Î¼H[d] s` is monotone in `d`. -/\ntheorem hausdorffMeasure_mono {dâ‚ dâ‚‚ : â„} (h : dâ‚ â‰¤ dâ‚‚) (s : Set X) : Î¼H[dâ‚‚] s â‰¤ Î¼H[dâ‚] s := by\n  rcases h.eq_or_lt with (rfl | h); Â· exact le_rfl\n  cases' hausdorffMeasure_zero_or_top h s with hs hs\n  Â· rw [hs]; exact zero_le _\n  Â· rw [hs]; exact le_top\n\n"}
{"name":"MeasureTheory.Measure.noAtoms_hausdorff","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nd : Real\nhd : LT.lt 0 d\nâŠ¢ MeasureTheory.NoAtoms (MeasureTheory.Measure.hausdorffMeasure d)","decl":"theorem noAtoms_hausdorff {d : â„} (hd : 0 < d) : NoAtoms (hausdorffMeasure d : Measure X) := by\n  refine âŸ¨fun x => ?_âŸ©\n  rw [â† nonpos_iff_eq_zero, hausdorffMeasure_apply]\n  refine iSupâ‚‚_le fun Îµ _ => iInfâ‚‚_le_of_le (fun _ => {x}) ?_ <| iInf_le_of_le (fun _ => ?_) ?_\n  Â· exact subset_iUnion (fun _ => {x} : â„• â†’ Set X) 0\n  Â· simp only [EMetric.diam_singleton, zero_le]\n  Â· simp [hd]\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_zero_singleton","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\nx : X\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure 0) (Singleton.singleton x)) 1","decl":"@[simp]\ntheorem hausdorffMeasure_zero_singleton (x : X) : Î¼H[0] ({x} : Set X) = 1 := by\n  apply le_antisymm\n  Â· let r : â„• â†’ â„â‰¥0âˆ := fun _ => 0\n    let t : â„• â†’ Unit â†’ Set X := fun _ _ => {x}\n    have ht : âˆ€á¶  n in atTop, âˆ€ i, diam (t n i) â‰¤ r n := by\n      simp only [t, r, imp_true_iff, eq_self_iff_true, diam_singleton, eventually_atTop,\n        nonpos_iff_eq_zero, exists_const]\n    simpa [t, liminf_const] using hausdorffMeasure_le_liminf_sum 0 {x} r tendsto_const_nhds t ht\n  Â· rw [hausdorffMeasure_apply]\n    suffices\n      (1 : â„â‰¥0âˆ) â‰¤\n        â¨… (t : â„• â†’ Set X) (_ : {x} âŠ† â‹ƒ n, t n) (_ : âˆ€ n, diam (t n) â‰¤ 1),\n          âˆ‘' n, â¨† _ : (t n).Nonempty, diam (t n) ^ (0 : â„) by\n      apply le_trans this _\n      convert le_iSupâ‚‚ (Î± := â„â‰¥0âˆ) (1 : â„â‰¥0âˆ) zero_lt_one\n      rfl\n    simp only [ENNReal.rpow_zero, le_iInf_iff]\n    intro t hst _\n    rcases mem_iUnion.1 (hst (mem_singleton x)) with âŸ¨m, hmâŸ©\n    have A : (t m).Nonempty := âŸ¨x, hmâŸ©\n    calc\n      (1 : â„â‰¥0âˆ) = â¨† h : (t m).Nonempty, 1 := by simp only [A, ciSup_pos]\n      _ â‰¤ âˆ‘' n, â¨† h : (t n).Nonempty, 1 := ENNReal.le_tsum _\n\n"}
{"name":"MeasureTheory.Measure.one_le_hausdorffMeasure_zero_of_nonempty","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\ns : Set X\nh : s.Nonempty\nâŠ¢ LE.le 1 ((MeasureTheory.Measure.hausdorffMeasure 0) s)","decl":"theorem one_le_hausdorffMeasure_zero_of_nonempty {s : Set X} (h : s.Nonempty) : 1 â‰¤ Î¼H[0] s := by\n  rcases h with âŸ¨x, hxâŸ©\n  calc\n    (1 : â„â‰¥0âˆ) = Î¼H[0] ({x} : Set X) := (hausdorffMeasure_zero_singleton x).symm\n    _ â‰¤ Î¼H[0] s := measure_mono (singleton_subset_iff.2 hx)\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_le_one_of_subsingleton","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœÂ² : EMetricSpace X\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : BorelSpace X\ns : Set X\nhs : s.Subsingleton\nd : Real\nhd : LE.le 0 d\nâŠ¢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) s) 1","decl":"theorem hausdorffMeasure_le_one_of_subsingleton {s : Set X} (hs : s.Subsingleton) {d : â„}\n    (hd : 0 â‰¤ d) : Î¼H[d] s â‰¤ 1 := by\n  rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)\n  Â· simp only [measure_empty, zero_le]\n  Â· rw [(subsingleton_iff_singleton hx).1 hs]\n    rcases eq_or_lt_of_le hd with (rfl | dpos)\n    Â· simp only [le_refl, hausdorffMeasure_zero_singleton]\n    Â· haveI := noAtoms_hausdorff X dpos\n      simp only [zero_le, measure_singleton]\n\n"}
{"name":"HolderOnWith.hausdorffMeasure_image_le","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœâµ : EMetricSpace X\ninstâœâ´ : EMetricSpace Y\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : MeasurableSpace Y\ninstâœ : BorelSpace Y\nC r : NNReal\nf : X â†’ Y\ns : Set X\nh : HolderOnWith C r f s\nhr : LT.lt 0 r\nd : Real\nhd : LE.le 0 d\nâŠ¢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image f s)) (HMul.hMul (HPow.hPow (â†‘C) d) ((MeasureTheory.Measure.hausdorffMeasure (HMul.hMul (â†‘r) d)) s))","decl":"/-- If `f : X â†’ Y` is HÃ¶lder continuous on `s` with a positive exponent `r`, then\n`Î¼H[d] (f '' s) â‰¤ C ^ d * Î¼H[r * d] s`. -/\ntheorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :\n    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s := by\n  -- We start with the trivial case `C = 0`\n  rcases (zero_le C).eq_or_lt with (rfl | hC0)\n  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)\n    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]\n    have : f '' s = {f x} :=\n      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le\n      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this\n    rw [this]\n    rcases eq_or_lt_of_le hd with (rfl | h'd)\n    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]\n      rw [hausdorffMeasure_zero_singleton]\n      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©\n    Â· haveI := noAtoms_hausdorff Y h'd\n      simp only [zero_le, measure_singleton]\n  -- Now assume `C â‰  0`\n  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']\n    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]\n    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,\n      â† ENNReal.tsum_mul_left]\n    refine iSup_le fun R => iSup_le fun hR => ?_\n    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=\n      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr\n    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with\n      âŸ¨Î´, Î´0, HâŸ©\n    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦\n      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦\n        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©\n    Â· rw [â† image_iUnion, â† iUnion_inter]\n      exact image_subset _ (subset_inter hst Subset.rfl)\n    Â· refine ENNReal.tsum_le_tsum fun n => ?_\n      simp only [iSup_le_iff, image_nonempty]\n      intro hft\n      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]\n      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]\n      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd\n\n"}
{"name":"LipschitzOnWith.hausdorffMeasure_image_le","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœâµ : EMetricSpace X\ninstâœâ´ : EMetricSpace Y\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : MeasurableSpace Y\ninstâœ : BorelSpace Y\nK : NNReal\nf : X â†’ Y\ns : Set X\nh : LipschitzOnWith K f s\nd : Real\nhd : LE.le 0 d\nâŠ¢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image f s)) (HMul.hMul (HPow.hPow (â†‘K) d) ((MeasureTheory.Measure.hausdorffMeasure d) s))","decl":"/-- If `f : X â†’ Y` is `K`-Lipschitz on `s`, then `Î¼H[d] (f '' s) â‰¤ K ^ d * Î¼H[d] s`. -/\ntheorem hausdorffMeasure_image_le (h : LipschitzOnWith K f s) {d : â„} (hd : 0 â‰¤ d) :\n    Î¼H[d] (f '' s) â‰¤ (K : â„â‰¥0âˆ) ^ d * Î¼H[d] s := by\n  simpa only [NNReal.coe_one, one_mul] using h.holderOnWith.hausdorffMeasure_image_le zero_lt_one hd\n\n"}
{"name":"LipschitzWith.hausdorffMeasure_image_le","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœâµ : EMetricSpace X\ninstâœâ´ : EMetricSpace Y\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : MeasurableSpace Y\ninstâœ : BorelSpace Y\nK : NNReal\nf : X â†’ Y\nh : LipschitzWith K f\nd : Real\nhd : LE.le 0 d\ns : Set X\nâŠ¢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image f s)) (HMul.hMul (HPow.hPow (â†‘K) d) ((MeasureTheory.Measure.hausdorffMeasure d) s))","decl":"/-- If `f` is a `K`-Lipschitz map, then it increases the Hausdorff `d`-measures of sets at most\nby the factor of `K ^ d`. -/\ntheorem hausdorffMeasure_image_le (h : LipschitzWith K f) {d : â„} (hd : 0 â‰¤ d) (s : Set X) :\n    Î¼H[d] (f '' s) â‰¤ (K : â„â‰¥0âˆ) ^ d * Î¼H[d] s :=\n  h.lipschitzOnWith.hausdorffMeasure_image_le hd\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_smulâ‚€","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"ğ•œ : Type u_4\nE : Type u_5\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : BorelSpace E\nd : Real\nhd : LE.le 0 d\nr : ğ•œ\nhr : Ne r 0\ns : Set E\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (HSMul.hSMul r s)) (HSMul.hSMul (HPow.hPow (NNNorm.nnnorm r) d) ((MeasureTheory.Measure.hausdorffMeasure d) s))","decl":"theorem MeasureTheory.Measure.hausdorffMeasure_smulâ‚€ {ğ•œ E : Type*} [NormedAddCommGroup E]\n    [NormedField ğ•œ] [NormedSpace ğ•œ E] [MeasurableSpace E] [BorelSpace E] {d : â„} (hd : 0 â‰¤ d)\n    {r : ğ•œ} (hr : r â‰  0) (s : Set E) : Î¼H[d] (r â€¢ s) = â€–râ€–â‚Š ^ d â€¢ Î¼H[d] s := by\n  have {r : ğ•œ} (s : Set E) : Î¼H[d] (r â€¢ s) â‰¤ â€–râ€–â‚Š ^ d â€¢ Î¼H[d] s := by\n    simpa [ENNReal.coe_rpow_of_nonneg, hd]\n      using (lipschitzWith_smul r).hausdorffMeasure_image_le hd s\n  refine le_antisymm (this s) ?_\n  rw [â† le_inv_smul_iff_of_pos]\n  Â· dsimp\n    rw [â† NNReal.inv_rpow, â† nnnorm_inv]\n    Â· refine Eq.trans_le ?_ (this (r â€¢ s))\n      rw [inv_smul_smulâ‚€ hr]\n  Â· simp [pos_iff_ne_zero, hr]\n\n"}
{"name":"AntilipschitzWith.hausdorffMeasure_preimage_le","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœâµ : EMetricSpace X\ninstâœâ´ : EMetricSpace Y\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : MeasurableSpace Y\ninstâœ : BorelSpace Y\nf : X â†’ Y\nK : NNReal\nd : Real\nhf : AntilipschitzWith K f\nhd : LE.le 0 d\ns : Set Y\nâŠ¢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) (Set.preimage f s)) (HMul.hMul (HPow.hPow (â†‘K) d) ((MeasureTheory.Measure.hausdorffMeasure d) s))","decl":"theorem hausdorffMeasure_preimage_le (hf : AntilipschitzWith K f) (hd : 0 â‰¤ d) (s : Set Y) :\n    Î¼H[d] (f â»Â¹' s) â‰¤ (K : â„â‰¥0âˆ) ^ d * Î¼H[d] s := by\n  rcases eq_or_ne K 0 with (rfl | h0)\n  Â· rcases eq_empty_or_nonempty (f â»Â¹' s) with (hs | âŸ¨x, hxâŸ©)\n    Â· simp only [hs, measure_empty, zero_le]\n    have : f â»Â¹' s = {x} := by\n      haveI : Subsingleton X := hf.subsingleton\n      have : (f â»Â¹' s).Subsingleton := subsingleton_univ.anti (subset_univ _)\n      exact (subsingleton_iff_singleton hx).1 this\n    rw [this]\n    rcases eq_or_lt_of_le hd with (rfl | h'd)\n    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]\n      rw [hausdorffMeasure_zero_singleton]\n      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨f x, hxâŸ©\n    Â· haveI := noAtoms_hausdorff X h'd\n      simp only [zero_le, measure_singleton]\n  have hKd0 : (K : â„â‰¥0âˆ) ^ d â‰  0 := by simp [h0]\n  have hKd : (K : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]\n  simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hKd0 hKd,\n    â† ENNReal.tsum_mul_left]\n  refine iSupâ‚‚_le fun Îµ Îµ0 => ?_\n  refine le_iSupâ‚‚_of_le (Îµ / K) (by simp [Îµ0.ne']) ?_\n  refine le_iInfâ‚‚ fun t hst => le_iInf fun htÎµ => ?_\n  replace hst : f â»Â¹' s âŠ† _ := preimage_mono hst; rw [preimage_iUnion] at hst\n  refine iInfâ‚‚_le_of_le _ hst (iInf_le_of_le (fun n => ?_) ?_)\n  Â· exact (hf.ediam_preimage_le _).trans (ENNReal.mul_le_of_le_div' <| htÎµ n)\n  Â· refine ENNReal.tsum_le_tsum fun n => iSup_le_iff.2 fun hft => ?_\n    simp only [nonempty_of_nonempty_preimage hft, ciSup_pos]\n    rw [â† ENNReal.mul_rpow_of_nonneg _ _ hd]\n    exact ENNReal.rpow_le_rpow (hf.ediam_preimage_le _) hd\n\n"}
{"name":"AntilipschitzWith.le_hausdorffMeasure_image","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœâµ : EMetricSpace X\ninstâœâ´ : EMetricSpace Y\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : MeasurableSpace Y\ninstâœ : BorelSpace Y\nf : X â†’ Y\nK : NNReal\nd : Real\nhf : AntilipschitzWith K f\nhd : LE.le 0 d\ns : Set X\nâŠ¢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) s) (HMul.hMul (HPow.hPow (â†‘K) d) ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image f s)))","decl":"theorem le_hausdorffMeasure_image (hf : AntilipschitzWith K f) (hd : 0 â‰¤ d) (s : Set X) :\n    Î¼H[d] s â‰¤ (K : â„â‰¥0âˆ) ^ d * Î¼H[d] (f '' s) :=\n  calc\n    Î¼H[d] s â‰¤ Î¼H[d] (f â»Â¹' (f '' s)) := measure_mono (subset_preimage_image _ _)\n    _ â‰¤ (K : â„â‰¥0âˆ) ^ d * Î¼H[d] (f '' s) := hf.hausdorffMeasure_preimage_le hd (f '' s)\n\n"}
{"name":"Isometry.hausdorffMeasure_image","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœâµ : EMetricSpace X\ninstâœâ´ : EMetricSpace Y\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : MeasurableSpace Y\ninstâœ : BorelSpace Y\nf : X â†’ Y\nd : Real\nhf : Isometry f\nhd : Or (LE.le 0 d) (Function.Surjective f)\ns : Set X\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image f s)) ((MeasureTheory.Measure.hausdorffMeasure d) s)","decl":"theorem hausdorffMeasure_image (hf : Isometry f) (hd : 0 â‰¤ d âˆ¨ Surjective f) (s : Set X) :\n    Î¼H[d] (f '' s) = Î¼H[d] s := by\n  simp only [hausdorffMeasure, â† OuterMeasure.coe_mkMetric, â† OuterMeasure.comap_apply]\n  rw [OuterMeasure.isometry_comap_mkMetric _ hf (hd.imp_left _)]\n  exact ENNReal.monotone_rpow_of_nonneg\n\n"}
{"name":"Isometry.hausdorffMeasure_preimage","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœâµ : EMetricSpace X\ninstâœâ´ : EMetricSpace Y\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : MeasurableSpace Y\ninstâœ : BorelSpace Y\nf : X â†’ Y\nd : Real\nhf : Isometry f\nhd : Or (LE.le 0 d) (Function.Surjective f)\ns : Set Y\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (Set.preimage f s)) ((MeasureTheory.Measure.hausdorffMeasure d) (Inter.inter s (Set.range f)))","decl":"theorem hausdorffMeasure_preimage (hf : Isometry f) (hd : 0 â‰¤ d âˆ¨ Surjective f) (s : Set Y) :\n    Î¼H[d] (f â»Â¹' s) = Î¼H[d] (s âˆ© range f) := by\n  rw [â† hf.hausdorffMeasure_image hd, image_preimage_eq_inter_range]\n\n"}
{"name":"Isometry.map_hausdorffMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœâµ : EMetricSpace X\ninstâœâ´ : EMetricSpace Y\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : MeasurableSpace Y\ninstâœ : BorelSpace Y\nf : X â†’ Y\nd : Real\nhf : Isometry f\nhd : Or (LE.le 0 d) (Function.Surjective f)\nâŠ¢ Eq (MeasureTheory.Measure.map f (MeasureTheory.Measure.hausdorffMeasure d)) ((MeasureTheory.Measure.hausdorffMeasure d).restrict (Set.range f))","decl":"theorem map_hausdorffMeasure (hf : Isometry f) (hd : 0 â‰¤ d âˆ¨ Surjective f) :\n    Measure.map f Î¼H[d] = Î¼H[d].restrict (range f) := by\n  ext1 s hs\n  rw [map_apply hf.continuous.measurable hs, Measure.restrict_apply hs,\n    hf.hausdorffMeasure_preimage hd]\n\n"}
{"name":"IsometryEquiv.hausdorffMeasure_image","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœâµ : EMetricSpace X\ninstâœâ´ : EMetricSpace Y\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : MeasurableSpace Y\ninstâœ : BorelSpace Y\ne : IsometryEquiv X Y\nd : Real\ns : Set X\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image (â‡‘e) s)) ((MeasureTheory.Measure.hausdorffMeasure d) s)","decl":"@[simp]\ntheorem hausdorffMeasure_image (e : X â‰ƒáµ¢ Y) (d : â„) (s : Set X) : Î¼H[d] (e '' s) = Î¼H[d] s :=\n  e.isometry.hausdorffMeasure_image (Or.inr e.surjective) s\n\n"}
{"name":"IsometryEquiv.hausdorffMeasure_preimage","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœâµ : EMetricSpace X\ninstâœâ´ : EMetricSpace Y\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : MeasurableSpace Y\ninstâœ : BorelSpace Y\ne : IsometryEquiv X Y\nd : Real\ns : Set Y\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (Set.preimage (â‡‘e) s)) ((MeasureTheory.Measure.hausdorffMeasure d) s)","decl":"@[simp]\ntheorem hausdorffMeasure_preimage (e : X â‰ƒáµ¢ Y) (d : â„) (s : Set Y) : Î¼H[d] (e â»Â¹' s) = Î¼H[d] s := by\n  rw [â† e.image_symm, e.symm.hausdorffMeasure_image]\n\n"}
{"name":"IsometryEquiv.map_hausdorffMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœâµ : EMetricSpace X\ninstâœâ´ : EMetricSpace Y\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : MeasurableSpace Y\ninstâœ : BorelSpace Y\ne : IsometryEquiv X Y\nd : Real\nâŠ¢ Eq (MeasureTheory.Measure.map (â‡‘e) (MeasureTheory.Measure.hausdorffMeasure d)) (MeasureTheory.Measure.hausdorffMeasure d)","decl":"@[simp]\ntheorem map_hausdorffMeasure (e : X â‰ƒáµ¢ Y) (d : â„) : Measure.map e Î¼H[d] = Î¼H[d] := by\n  rw [e.isometry.map_hausdorffMeasure (Or.inr e.surjective), e.surjective.range_eq, restrict_univ]\n\n"}
{"name":"IsometryEquiv.measurePreserving_hausdorffMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninstâœâµ : EMetricSpace X\ninstâœâ´ : EMetricSpace Y\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : MeasurableSpace Y\ninstâœ : BorelSpace Y\ne : IsometryEquiv X Y\nd : Real\nâŠ¢ MeasureTheory.MeasurePreserving (â‡‘e) (MeasureTheory.Measure.hausdorffMeasure d) (MeasureTheory.Measure.hausdorffMeasure d)","decl":"theorem measurePreserving_hausdorffMeasure (e : X â‰ƒáµ¢ Y) (d : â„) : MeasurePreserving e Î¼H[d] Î¼H[d] :=\n  âŸ¨e.continuous.measurable, map_hausdorffMeasure _ _âŸ©\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_smul","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœâ´ : EMetricSpace X\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\nÎ± : Type u_4\ninstâœÂ¹ : SMul Î± X\ninstâœ : IsometricSMul Î± X\nd : Real\nc : Î±\nh : Or (LE.le 0 d) (Function.Surjective fun x => HSMul.hSMul c x)\ns : Set X\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (HSMul.hSMul c s)) ((MeasureTheory.Measure.hausdorffMeasure d) s)","decl":"@[to_additive]\ntheorem hausdorffMeasure_smul {Î± : Type*} [SMul Î± X] [IsometricSMul Î± X] {d : â„} (c : Î±)\n    (h : 0 â‰¤ d âˆ¨ Surjective (c â€¢ Â· : X â†’ X)) (s : Set X) : Î¼H[d] (c â€¢ s) = Î¼H[d] s :=\n  (isometry_smul X c).hausdorffMeasure_image h _\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_vadd","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœâ´ : EMetricSpace X\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\nÎ± : Type u_4\ninstâœÂ¹ : VAdd Î± X\ninstâœ : IsometricVAdd Î± X\nd : Real\nc : Î±\nh : Or (LE.le 0 d) (Function.Surjective fun x => HVAdd.hVAdd c x)\ns : Set X\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (HVAdd.hVAdd c s)) ((MeasureTheory.Measure.hausdorffMeasure d) s)","decl":"@[to_additive]\ntheorem hausdorffMeasure_smul {Î± : Type*} [SMul Î± X] [IsometricSMul Î± X] {d : â„} (c : Î±)\n    (h : 0 â‰¤ d âˆ¨ Surjective (c â€¢ Â· : X â†’ X)) (s : Set X) : Î¼H[d] (c â€¢ s) = Î¼H[d] s :=\n  (isometry_smul X c).hausdorffMeasure_image h _\n\n"}
{"name":"MeasureTheory.instIsMulLeftInvariantHausdorffMeasureOfIsometricSMul","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœâ´ : EMetricSpace X\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\nd : Real\ninstâœÂ¹ : Group X\ninstâœ : IsometricSMul X X\nâŠ¢ (MeasureTheory.Measure.hausdorffMeasure d).IsMulLeftInvariant","decl":"@[to_additive]\ninstance {d : â„} [Group X] [IsometricSMul X X] : IsMulLeftInvariant (Î¼H[d] : Measure X) where\n  map_mul_left_eq_self x := (IsometryEquiv.constSMul x).map_hausdorffMeasure _\n\n"}
{"name":"MeasureTheory.instIsAddLeftInvariantHausdorffMeasureOfIsometricVAdd","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœâ´ : EMetricSpace X\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\nd : Real\ninstâœÂ¹ : AddGroup X\ninstâœ : IsometricVAdd X X\nâŠ¢ (MeasureTheory.Measure.hausdorffMeasure d).IsAddLeftInvariant","decl":"@[to_additive]\ninstance {d : â„} [Group X] [IsometricSMul X X] : IsMulLeftInvariant (Î¼H[d] : Measure X) where\n  map_mul_left_eq_self x := (IsometryEquiv.constSMul x).map_hausdorffMeasure _\n\n"}
{"name":"MeasureTheory.instIsMulRightInvariantHausdorffMeasureOfIsometricSMulMulOpposite","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœâ´ : EMetricSpace X\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\nd : Real\ninstâœÂ¹ : Group X\ninstâœ : IsometricSMul (MulOpposite X) X\nâŠ¢ (MeasureTheory.Measure.hausdorffMeasure d).IsMulRightInvariant","decl":"@[to_additive]\ninstance {d : â„} [Group X] [IsometricSMul Xáµáµ’áµ– X] : IsMulRightInvariant (Î¼H[d] : Measure X) where\n  map_mul_right_eq_self x := (IsometryEquiv.constSMul (MulOpposite.op x)).map_hausdorffMeasure _\n\n"}
{"name":"MeasureTheory.instIsAddRightInvariantHausdorffMeasureOfIsometricVAddAddOpposite","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninstâœâ´ : EMetricSpace X\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\nd : Real\ninstâœÂ¹ : AddGroup X\ninstâœ : IsometricVAdd (AddOpposite X) X\nâŠ¢ (MeasureTheory.Measure.hausdorffMeasure d).IsAddRightInvariant","decl":"@[to_additive]\ninstance {d : â„} [Group X] [IsometricSMul Xáµáµ’áµ– X] : IsMulRightInvariant (Î¼H[d] : Measure X) where\n  map_mul_right_eq_self x := (IsometryEquiv.constSMul (MulOpposite.op x)).map_hausdorffMeasure _\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_pi_real","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"Î¹ : Type u_4\ninstâœ : Fintype Î¹\nâŠ¢ Eq (MeasureTheory.Measure.hausdorffMeasure â†‘(Fintype.card Î¹)) MeasureTheory.MeasureSpace.volume","decl":"/-- In the space `Î¹ â†’ â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\n@[simp]\ntheorem hausdorffMeasure_pi_real {Î¹ : Type*} [Fintype Î¹] :\n    (Î¼H[Fintype.card Î¹] : Measure (Î¹ â†’ â„)) = volume := by\n  classical\n  -- it suffices to check that the two measures coincide on products of rational intervals\n  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)\n    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) ?_).symm\n  simp only [mem_iUnion, mem_singleton_iff]\n  -- fix such a product `s` of rational intervals, of the form `Î  (a i, b i)`.\n  intro s hs\n  choose a b H using hs\n  obtain rfl : s = fun i => Ioo (Î± := â„) (a i) (b i) := funext fun i => (H i).2\n  replace H := fun i => (H i).1\n  apply le_antisymm _\n  -- first check that `volume s â‰¤ Î¼H s`\n  Â· have Hle : volume â‰¤ (Î¼H[Fintype.card Î¹] : Measure (Î¹ â†’ â„)) := by\n      refine le_hausdorffMeasure _ _ âˆ ENNReal.coe_lt_top fun s _ => ?_\n      rw [ENNReal.rpow_natCast]\n      exact Real.volume_pi_le_diam_pow s\n    rw [â† volume_pi_pi fun i => Ioo (a i : â„) (b i)]\n    exact Measure.le_iff'.1 Hle _\n  /- For the other inequality `Î¼H s â‰¤ volume s`, we use a covering of `s` by sets of small diameter\n    `1/n`, namely cubes with left-most point of the form `a i + f i / n` with `f i` ranging between\n    `0` and `âŒˆ(b i - a i) * nâŒ‰`. Their number is asymptotic to `n^d * Î  (b i - a i)`. -/\n  have I : âˆ€ i, 0 â‰¤ (b i : â„) - a i := fun i => by\n    simpa only [sub_nonneg, Rat.cast_le] using (H i).le\n  let Î³ := fun n : â„• => âˆ€ i : Î¹, Fin âŒˆ((b i : â„) - a i) * nâŒ‰â‚Š\n  let t : âˆ€ n : â„•, Î³ n â†’ Set (Î¹ â†’ â„) := fun n f =>\n    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)\n  have A : Tendsto (fun n : â„• => 1 / (n : â„â‰¥0âˆ)) atTop (ğ“ 0) := by\n    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]\n  have B : âˆ€á¶  n in atTop, âˆ€ i : Î³ n, diam (t n i) â‰¤ 1 / n := by\n    refine eventually_atTop.2 âŸ¨1, fun n hn => ?_âŸ©\n    intro f\n    refine diam_pi_le_of_le fun b => ?_\n    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,\n      add_sub_add_left_eq_sub, add_sub_cancel_left, ENNReal.ofReal_one, ENNReal.ofReal_natCast]\n  have C : âˆ€á¶  n in atTop, (Set.pi univ fun i : Î¹ => Ioo (a i : â„) (b i)) âŠ† â‹ƒ i : Î³ n, t n i := by\n    refine eventually_atTop.2 âŸ¨1, fun n hn => ?_âŸ©\n    have npos : (0 : â„) < n := Nat.cast_pos.2 hn\n    intro x hx\n    simp only [mem_Ioo, mem_univ_pi] at hx\n    simp only [t, mem_iUnion, mem_Ioo, mem_univ_pi]\n    let f : Î³ n := fun i =>\n      âŸ¨âŒŠ(x i - a i) * nâŒ‹â‚Š, by\n        apply Nat.floor_lt_ceil_of_lt_of_pos\n        Â· refine (mul_lt_mul_right npos).2 ?_\n          simp only [(hx i).right, sub_lt_sub_iff_right]\n        Â· refine mul_pos ?_ npos\n          simpa only [Rat.cast_lt, sub_pos] using H iâŸ©\n    refine âŸ¨f, fun i => âŸ¨?_, ?_âŸ©âŸ©\n    Â· calc\n        (a i : â„) + âŒŠ(x i - a i) * nâŒ‹â‚Š / n â‰¤ (a i : â„) + (x i - a i) * n / n := by\n          gcongr\n          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)\n        _ = x i := by field_simp [npos.ne']\n    Â· calc\n        x i = (a i : â„) + (x i - a i) * n / n := by field_simp [npos.ne']\n        _ â‰¤ (a i : â„) + (âŒŠ(x i - a i) * nâŒ‹â‚Š + 1) / n := by\n          gcongr\n          exact (Nat.lt_floor_add_one _).le\n  calc\n    Î¼H[Fintype.card Î¹] (Set.pi univ fun i : Î¹ => Ioo (a i : â„) (b i)) â‰¤\n        liminf (fun n : â„• => âˆ‘ i : Î³ n, diam (t n i) ^ ((Fintype.card Î¹) : â„)) atTop :=\n      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : â„) (b i))\n        (fun n : â„• => 1 / (n : â„â‰¥0âˆ)) A t B C\n    _ â‰¤ liminf (fun n : â„• => âˆ‘ i : Î³ n, (1 / (n : â„â‰¥0âˆ)) ^ Fintype.card Î¹) atTop := by\n      refine liminf_le_liminf ?_ ?_\n      Â· filter_upwards [B] with _ hn\n        apply Finset.sum_le_sum fun i _ => _\n        simp only [ENNReal.rpow_natCast]\n        intros i _\n        exact pow_le_pow_left' (hn i) _\n      Â· isBoundedDefault\n    _ = liminf (fun n : â„• => âˆ i : Î¹, (âŒˆ((b i : â„) - a i) * nâŒ‰â‚Š : â„â‰¥0âˆ) / n) atTop := by\n      simp only [Î³, Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,\n        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]\n    _ = âˆ i : Î¹, volume (Ioo (a i : â„) (b i)) := by\n      simp only [Real.volume_Ioo]\n      apply Tendsto.liminf_eq\n      refine ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => ?_) fun i _ => ?_\n      Â· apply\n          Tendsto.congr' _\n            ((ENNReal.continuous_ofReal.tendsto _).comp\n              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_natCast_atTop_atTop))\n        apply eventually_atTop.2 âŸ¨1, fun n hn => _âŸ©\n        intros n hn\n        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,\n          ENNReal.ofReal_natCast]\n      Â· simp only [ENNReal.ofReal_ne_top, Ne, not_false_iff]\n\n"}
{"name":"MeasureTheory.isAddHaarMeasure_hausdorffMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"E : Type u_4\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : FiniteDimensional Real E\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : BorelSpace E\nâŠ¢ (MeasureTheory.Measure.hausdorffMeasure â†‘(Module.finrank Real E)).IsAddHaarMeasure","decl":"instance isAddHaarMeasure_hausdorffMeasure {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace â„ E] [FiniteDimensional â„ E]\n    [MeasurableSpace E] [BorelSpace E] :\n    IsAddHaarMeasure (G := E) Î¼H[finrank â„ E] where\n  lt_top_of_isCompact K hK := by\n    set e : E â‰ƒL[â„] Fin (finrank â„ E) â†’ â„ := ContinuousLinearEquiv.ofFinrankEq (by simp)\n    suffices Î¼H[finrank â„ E] (e '' K) < âŠ¤ by\n      rw [â† e.symm_image_image K]\n      apply lt_of_le_of_lt <| e.symm.lipschitz.hausdorffMeasure_image_le (by simp) (e '' K)\n      rw [ENNReal.rpow_natCast]\n      exact ENNReal.mul_lt_top (ENNReal.pow_lt_top ENNReal.coe_lt_top _) this\n    conv_lhs => congr; congr; rw [â† Fintype.card_fin (finrank â„ E)]\n    rw [hausdorffMeasure_pi_real]\n    exact (hK.image e.continuous).measure_lt_top\n  open_pos U hU hU' := by\n    set e : E â‰ƒL[â„] Fin (finrank â„ E) â†’ â„ := ContinuousLinearEquiv.ofFinrankEq (by simp)\n    suffices 0 < Î¼H[finrank â„ E] (e '' U) from\n      (ENNReal.mul_pos_iff.mp (lt_of_lt_of_le this <|\n        e.lipschitz.hausdorffMeasure_image_le (by simp) _)).2.ne'\n    conv_rhs => congr; congr; rw [â† Fintype.card_fin (finrank â„ E)]\n    rw [hausdorffMeasure_pi_real]\n    apply (e.isOpenMap U hU).measure_pos (Î¼ := volume)\n    simpa\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_measurePreserving_funUnique","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"Î¹ : Type u_1\nX : Type u_2\ninstâœâ´ : EMetricSpace X\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : Unique Î¹\ninstâœ : SecondCountableTopology X\nd : Real\nâŠ¢ MeasureTheory.MeasurePreserving (â‡‘(MeasurableEquiv.funUnique Î¹ X)) (MeasureTheory.Measure.hausdorffMeasure d) (MeasureTheory.Measure.hausdorffMeasure d)","decl":"theorem hausdorffMeasure_measurePreserving_funUnique [Unique Î¹]\n    [SecondCountableTopology X] (d : â„) :\n    MeasurePreserving (MeasurableEquiv.funUnique Î¹ X) Î¼H[d] Î¼H[d] :=\n  (IsometryEquiv.funUnique Î¹ X).measurePreserving_hausdorffMeasure _\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_measurePreserving_piFinTwo","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"Î± : Fin 2 â†’ Type u_4\ninstâœÂ³ : (i : Fin 2) â†’ MeasurableSpace (Î± i)\ninstâœÂ² : (i : Fin 2) â†’ EMetricSpace (Î± i)\ninstâœÂ¹ : âˆ€ (i : Fin 2), BorelSpace (Î± i)\ninstâœ : âˆ€ (i : Fin 2), SecondCountableTopology (Î± i)\nd : Real\nâŠ¢ MeasureTheory.MeasurePreserving (â‡‘(MeasurableEquiv.piFinTwo Î±)) (MeasureTheory.Measure.hausdorffMeasure d) (MeasureTheory.Measure.hausdorffMeasure d)","decl":"theorem hausdorffMeasure_measurePreserving_piFinTwo (Î± : Fin 2 â†’ Type*)\n    [âˆ€ i, MeasurableSpace (Î± i)] [âˆ€ i, EMetricSpace (Î± i)] [âˆ€ i, BorelSpace (Î± i)]\n    [âˆ€ i, SecondCountableTopology (Î± i)] (d : â„) :\n    MeasurePreserving (MeasurableEquiv.piFinTwo Î±) Î¼H[d] Î¼H[d] :=\n  (IsometryEquiv.piFinTwo Î±).measurePreserving_hausdorffMeasure _\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_real","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"âŠ¢ Eq (MeasureTheory.Measure.hausdorffMeasure 1) MeasureTheory.MeasureSpace.volume","decl":"/-- In the space `â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\n@[simp]\ntheorem hausdorffMeasure_real : (Î¼H[1] : Measure â„) = volume := by\n  rw [â† (volume_preserving_funUnique Unit â„).map_eq,\n    â† (hausdorffMeasure_measurePreserving_funUnique Unit â„ 1).map_eq,\n    â† hausdorffMeasure_pi_real, Fintype.card_unit, Nat.cast_one]\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_prod_real","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"âŠ¢ Eq (MeasureTheory.Measure.hausdorffMeasure 2) MeasureTheory.MeasureSpace.volume","decl":"/-- In the space `â„ Ã— â„`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\n@[simp]\ntheorem hausdorffMeasure_prod_real : (Î¼H[2] : Measure (â„ Ã— â„)) = volume := by\n  rw [â† (volume_preserving_piFinTwo fun _ => â„).map_eq,\n    â† (hausdorffMeasure_measurePreserving_piFinTwo (fun _ => â„) _).map_eq,\n    â† hausdorffMeasure_pi_real, Fintype.card_fin, Nat.cast_two]\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_smul_right_image","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"E : Type u_5\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : BorelSpace E\nv : E\ns : Set Real\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure 1) (Set.image (fun r => HSMul.hSMul r v) s)) (HSMul.hSMul (NNNorm.nnnorm v) ((MeasureTheory.Measure.hausdorffMeasure 1) s))","decl":"theorem hausdorffMeasure_smul_right_image [NormedAddCommGroup E] [NormedSpace â„ E]\n    [MeasurableSpace E] [BorelSpace E] (v : E) (s : Set â„) :\n    Î¼H[1] ((fun r => r â€¢ v) '' s) = â€–vâ€–â‚Š â€¢ Î¼H[1] s := by\n  obtain rfl | hv := eq_or_ne v 0\n  Â· haveI := noAtoms_hausdorff E one_pos\n    obtain rfl | hs := s.eq_empty_or_nonempty\n    Â· simp\n    simp [hs]\n  have hn : â€–vâ€– â‰  0 := norm_ne_zero_iff.mpr hv\n  -- break lineMap into pieces\n  suffices\n      Î¼H[1] ((â€–vâ€– â€¢ Â·) '' (LinearMap.toSpanSingleton â„ E (â€–vâ€–â»Â¹ â€¢ v) '' s)) = â€–vâ€–â‚Š â€¢ Î¼H[1] s by\n    simpa only [Set.image_image, smul_comm (norm _), inv_smul_smulâ‚€ hn,\n      LinearMap.toSpanSingleton_apply] using this\n  have iso_smul : Isometry (LinearMap.toSpanSingleton â„ E (â€–vâ€–â»Â¹ â€¢ v)) := by\n    refine AddMonoidHomClass.isometry_of_norm _ fun x => (norm_smul _ _).trans ?_\n    rw [norm_smul, norm_inv, norm_norm, inv_mul_cancelâ‚€ hn, mul_one, LinearMap.id_apply]\n  rw [Set.image_smul, Measure.hausdorffMeasure_smulâ‚€ zero_le_one hn, nnnorm_norm,\n      NNReal.rpow_one, iso_smul.hausdorffMeasure_image (Or.inl <| zero_le_one' â„)]\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_homothety_image","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"ğ•œ : Type u_4\nE : Type u_5\nP : Type u_6\ninstâœâ¶ : NormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : MeasurableSpace P\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ : NormedAddTorsor E P\ninstâœ : BorelSpace P\nd : Real\nhd : LE.le 0 d\nx : P\nc : ğ•œ\nhc : Ne c 0\ns : Set P\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image (â‡‘(AffineMap.homothety x c)) s)) (HSMul.hSMul (HPow.hPow (NNNorm.nnnorm c) d) ((MeasureTheory.Measure.hausdorffMeasure d) s))","decl":"/-- Scaling by `c` around `x` scales the measure by `â€–câ€–â‚Š ^ d`. -/\ntheorem hausdorffMeasure_homothety_image {d : â„} (hd : 0 â‰¤ d) (x : P) {c : ğ•œ} (hc : c â‰  0)\n    (s : Set P) : Î¼H[d] (AffineMap.homothety x c '' s) = â€–câ€–â‚Š ^ d â€¢ Î¼H[d] s := by\n  suffices\n    Î¼H[d] (IsometryEquiv.vaddConst x '' ((c â€¢ Â·) '' ((IsometryEquiv.vaddConst x).symm '' s))) =\n      â€–câ€–â‚Š ^ d â€¢ Î¼H[d] s by\n    simpa only [Set.image_image]\n  borelize E\n  rw [IsometryEquiv.hausdorffMeasure_image, Set.image_smul, Measure.hausdorffMeasure_smulâ‚€ hd hc,\n    IsometryEquiv.hausdorffMeasure_image]\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_homothety_preimage","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"ğ•œ : Type u_4\nE : Type u_5\nP : Type u_6\ninstâœâ¶ : NormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : MeasurableSpace P\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ : NormedAddTorsor E P\ninstâœ : BorelSpace P\nd : Real\nhd : LE.le 0 d\nx : P\nc : ğ•œ\nhc : Ne c 0\ns : Set P\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (Set.preimage (â‡‘(AffineMap.homothety x c)) s)) (HSMul.hSMul (HPow.hPow (Inv.inv (NNNorm.nnnorm c)) d) ((MeasureTheory.Measure.hausdorffMeasure d) s))","decl":"theorem hausdorffMeasure_homothety_preimage {d : â„} (hd : 0 â‰¤ d) (x : P) {c : ğ•œ} (hc : c â‰  0)\n    (s : Set P) : Î¼H[d] (AffineMap.homothety x c â»Â¹' s) = â€–câ€–â‚Šâ»Â¹ ^ d â€¢ Î¼H[d] s := by\n  change Î¼H[d] (AffineEquiv.homothetyUnitsMulHom x (Units.mk0 c hc) â»Â¹' s) = _\n  rw [â† AffineEquiv.image_symm, AffineEquiv.coe_homothetyUnitsMulHom_apply_symm,\n    hausdorffMeasure_homothety_image hd x (_ : ğ•œË£).isUnit.ne_zero, Units.val_inv_eq_inv_val,\n    Units.val_mk0, nnnorm_inv]\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_lineMap_image","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"E : Type u_5\nP : Type u_6\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace P\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ : NormedAddTorsor E P\ninstâœ : BorelSpace P\nx y : P\ns : Set Real\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure 1) (Set.image (â‡‘(AffineMap.lineMap x y)) s)) (HSMul.hSMul (NNDist.nndist x y) ((MeasureTheory.Measure.hausdorffMeasure 1) s))","decl":"/-- Mapping a set of reals along a line segment scales the measure by the length of a segment.\n\nThis is an auxiliary result used to prove `hausdorffMeasure_affineSegment`. -/\ntheorem hausdorffMeasure_lineMap_image (x y : P) (s : Set â„) :\n    Î¼H[1] (AffineMap.lineMap x y '' s) = nndist x y â€¢ Î¼H[1] s := by\n  suffices Î¼H[1] (IsometryEquiv.vaddConst x '' ((Â· â€¢ (y -áµ¥ x)) '' s)) = nndist x y â€¢ Î¼H[1] s by\n    simpa only [Set.image_image]\n  borelize E\n  rw [IsometryEquiv.hausdorffMeasure_image, hausdorffMeasure_smul_right_image,\n    nndist_eq_nnnorm_vsub' E]\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_affineSegment","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"E : Type u_5\nP : Type u_6\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace P\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ : NormedAddTorsor E P\ninstâœ : BorelSpace P\nx y : P\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure 1) (affineSegment Real x y)) (EDist.edist x y)","decl":"/-- The measure of a segment is the distance between its endpoints. -/\n@[simp]\ntheorem hausdorffMeasure_affineSegment (x y : P) : Î¼H[1] (affineSegment â„ x y) = edist x y := by\n  rw [affineSegment, hausdorffMeasure_lineMap_image, hausdorffMeasure_real, Real.volume_Icc,\n    sub_zero, ENNReal.ofReal_one, â† Algebra.algebraMap_eq_smul_one]\n  exact (edist_nndist _ _).symm\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_segment","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"E : Type u_7\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : BorelSpace E\nx y : E\nâŠ¢ Eq ((MeasureTheory.Measure.hausdorffMeasure 1) (segment Real x y)) (EDist.edist x y)","decl":"/-- The measure of a segment is the distance between its endpoints. -/\n@[simp]\ntheorem hausdorffMeasure_segment {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]\n    [MeasurableSpace E] [BorelSpace E] (x y : E) : Î¼H[1] (segment â„ x y) = edist x y := by\n  rw [â† affineSegment_eq_segment, hausdorffMeasure_affineSegment]\n\n"}
