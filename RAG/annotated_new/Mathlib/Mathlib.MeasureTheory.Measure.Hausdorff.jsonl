{"name":"MeasureTheory.OuterMeasure.IsMetric.finset_iUnion_of_pairwise_separated","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : EMetricSpace X\nμ : MeasureTheory.OuterMeasure X\nhm : μ.IsMetric\nI : Finset ι\ns : ι → Set X\nhI : ∀ (i : ι), Membership.mem I i → ∀ (j : ι), Membership.mem I j → Ne i j → IsMetricSeparated (s i) (s j)\n⊢ Eq (μ (Set.iUnion fun i => Set.iUnion fun h => s i)) (I.sum fun i => μ (s i))","decl":"/-- A metric outer measure is additive on a finite set of pairwise metric separated sets. -/\ntheorem finset_iUnion_of_pairwise_separated (hm : IsMetric μ) {I : Finset ι} {s : ι → Set X}\n    (hI : ∀ i ∈ I, ∀ j ∈ I, i ≠ j → IsMetricSeparated (s i) (s j)) :\n    μ (⋃ i ∈ I, s i) = ∑ i ∈ I, μ (s i) := by\n  classical\n  induction' I using Finset.induction_on with i I hiI ihI hI\n  · simp\n  simp only [Finset.mem_insert] at hI\n  rw [Finset.set_biUnion_insert, hm, ihI, Finset.sum_insert hiI]\n  exacts [fun i hi j hj hij => hI i (Or.inr hi) j (Or.inr hj) hij,\n    IsMetricSeparated.finset_iUnion_right fun j hj =>\n      hI i (Or.inl rfl) j (Or.inr hj) (ne_of_mem_of_not_mem hj hiI).symm]\n\n"}
{"name":"MeasureTheory.OuterMeasure.IsMetric.borel_le_caratheodory","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nμ : MeasureTheory.OuterMeasure X\nhm : μ.IsMetric\n⊢ LE.le (borel X) μ.caratheodory","decl":"/-- Caratheodory theorem. If `m` is a metric outer measure, then every Borel measurable set `t` is\nCaratheodory measurable: for any (not necessarily measurable) set `s` we have\n`μ (s ∩ t) + μ (s \\ t) = μ s`. -/\ntheorem borel_le_caratheodory (hm : IsMetric μ) : borel X ≤ μ.caratheodory := by\n  rw [borel_eq_generateFrom_isClosed]\n  refine MeasurableSpace.generateFrom_le fun t ht => μ.isCaratheodory_iff_le.2 fun s => ?_\n  set S : ℕ → Set X := fun n => {x ∈ s | (↑n)⁻¹ ≤ infEdist x t}\n  have Ssep (n) : IsMetricSeparated (S n) t :=\n    ⟨n⁻¹, ENNReal.inv_ne_zero.2 (ENNReal.natCast_ne_top _),\n      fun x hx y hy ↦ hx.2.trans <| infEdist_le_edist_of_mem hy⟩\n  have Ssep' : ∀ n, IsMetricSeparated (S n) (s ∩ t) := fun n =>\n    (Ssep n).mono Subset.rfl inter_subset_right\n  have S_sub : ∀ n, S n ⊆ s \\ t := fun n =>\n    subset_inter inter_subset_left (Ssep n).subset_compl_right\n  have hSs : ∀ n, μ (s ∩ t) + μ (S n) ≤ μ s := fun n =>\n    calc\n      μ (s ∩ t) + μ (S n) = μ (s ∩ t ∪ S n) := Eq.symm <| hm _ _ <| (Ssep' n).symm\n      _ ≤ μ (s ∩ t ∪ s \\ t) := μ.mono <| union_subset_union_right _ <| S_sub n\n      _ = μ s := by rw [inter_union_diff]\n  have iUnion_S : ⋃ n, S n = s \\ t := by\n    refine Subset.antisymm (iUnion_subset S_sub) ?_\n    rintro x ⟨hxs, hxt⟩\n    rw [mem_iff_infEdist_zero_of_closed ht] at hxt\n    rcases ENNReal.exists_inv_nat_lt hxt with ⟨n, hn⟩\n    exact mem_iUnion.2 ⟨n, hxs, hn.le⟩\n  /- Now we have `∀ n, μ (s ∩ t) + μ (S n) ≤ μ s` and we need to prove\n    `μ (s ∩ t) + μ (⋃ n, S n) ≤ μ s`. We can't pass to the limit because\n    `μ` is only an outer measure. -/\n  by_cases htop : μ (s \\ t) = ∞\n  · rw [htop, add_top, ← htop]\n    exact μ.mono diff_subset\n  suffices μ (⋃ n, S n) ≤ ⨆ n, μ (S n) by calc\n    μ (s ∩ t) + μ (s \\ t) = μ (s ∩ t) + μ (⋃ n, S n) := by rw [iUnion_S]\n    _ ≤ μ (s ∩ t) + ⨆ n, μ (S n) := by gcongr\n    _ = ⨆ n, μ (s ∩ t) + μ (S n) := ENNReal.add_iSup ..\n    _ ≤ μ s := iSup_le hSs\n  /- It suffices to show that `∑' k, μ (S (k + 1) \\ S k) ≠ ∞`. Indeed, if we have this,\n    then for all `N` we have `μ (⋃ n, S n) ≤ μ (S N) + ∑' k, m (S (N + k + 1) \\ S (N + k))`\n    and the second term tends to zero, see `OuterMeasure.iUnion_nat_of_monotone_of_tsum_ne_top`\n    for details. -/\n  have : ∀ n, S n ⊆ S (n + 1) := fun n x hx =>\n    ⟨hx.1, le_trans (ENNReal.inv_le_inv.2 <| Nat.cast_le.2 n.le_succ) hx.2⟩\n  classical -- Porting note: Added this to get the next tactic to work\n  refine (μ.iUnion_nat_of_monotone_of_tsum_ne_top this ?_).le; clear this\n  /- While the sets `S (k + 1) \\ S k` are not pairwise metric separated, the sets in each\n    subsequence `S (2 * k + 1) \\ S (2 * k)` and `S (2 * k + 2) \\ S (2 * k)` are metric separated,\n    so `m` is additive on each of those sequences. -/\n  rw [← tsum_even_add_odd ENNReal.summable ENNReal.summable, ENNReal.add_ne_top]\n  suffices ∀ a, (∑' k : ℕ, μ (S (2 * k + 1 + a) \\ S (2 * k + a))) ≠ ∞ from\n    ⟨by simpa using this 0, by simpa using this 1⟩\n  refine fun r => ne_top_of_le_ne_top htop ?_\n  rw [← iUnion_S, ENNReal.tsum_eq_iSup_nat, iSup_le_iff]\n  intro n\n  rw [← hm.finset_iUnion_of_pairwise_separated]\n  · exact μ.mono (iUnion_subset fun i => iUnion_subset fun _ x hx => mem_iUnion.2 ⟨_, hx.1⟩)\n  suffices ∀ i j, i < j → IsMetricSeparated (S (2 * i + 1 + r)) (s \\ S (2 * j + r)) from\n    fun i _ j _ hij => hij.lt_or_lt.elim\n      (fun h => (this i j h).mono inter_subset_left fun x hx => by exact ⟨hx.1.1, hx.2⟩)\n      fun h => (this j i h).symm.mono (fun x hx => by exact ⟨hx.1.1, hx.2⟩) inter_subset_left\n  intro i j hj\n  have A : ((↑(2 * j + r))⁻¹ : ℝ≥0∞) < (↑(2 * i + 1 + r))⁻¹ := by\n    rw [ENNReal.inv_lt_inv, Nat.cast_lt]; omega\n  refine ⟨(↑(2 * i + 1 + r))⁻¹ - (↑(2 * j + r))⁻¹, by simpa [tsub_eq_zero_iff_le] using A,\n    fun x hx y hy => ?_⟩\n  have : infEdist y t < (↑(2 * j + r))⁻¹ := not_le.1 fun hle => hy.2 ⟨hy.1, hle⟩\n  rcases infEdist_lt_iff.mp this with ⟨z, hzt, hyz⟩\n  have hxz : (↑(2 * i + 1 + r))⁻¹ ≤ edist x z := le_infEdist.1 hx.2 _ hzt\n  apply ENNReal.le_of_add_le_add_right hyz.ne_top\n  refine le_trans ?_ (edist_triangle _ _ _)\n  refine (add_le_add le_rfl hyz.le).trans (Eq.trans_le ?_ hxz)\n  rw [tsub_add_cancel_of_le A.le]\n\n"}
{"name":"MeasureTheory.OuterMeasure.IsMetric.le_caratheodory","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\nμ : MeasureTheory.OuterMeasure X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nhm : μ.IsMetric\n⊢ LE.le inst✝¹ μ.caratheodory","decl":"theorem le_caratheodory [MeasurableSpace X] [BorelSpace X] (hm : IsMetric μ) :\n    ‹MeasurableSpace X› ≤ μ.caratheodory := by\n  rw [BorelSpace.measurable_eq (α := X)]\n  exact hm.borel_le_caratheodory\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.le_pre","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nm : Set X → ENNReal\nr : ENNReal\nμ : MeasureTheory.OuterMeasure X\n⊢ Iff (LE.le μ (MeasureTheory.OuterMeasure.mkMetric'.pre m r)) (∀ (s : Set X), LE.le (EMetric.diam s) r → LE.le (μ s) (m s))","decl":"theorem le_pre : μ ≤ pre m r ↔ ∀ s : Set X, diam s ≤ r → μ s ≤ m s := by\n  simp only [pre, le_boundedBy, extend, le_iInf_iff]\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.pre_le","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nm : Set X → ENNReal\nr : ENNReal\ns : Set X\nhs : LE.le (EMetric.diam s) r\n⊢ LE.le ((MeasureTheory.OuterMeasure.mkMetric'.pre m r) s) (m s)","decl":"theorem pre_le (hs : diam s ≤ r) : pre m r s ≤ m s :=\n  (boundedBy_le _).trans <| iInf_le _ hs\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.mono_pre","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nm : Set X → ENNReal\nr r' : ENNReal\nh : LE.le r r'\n⊢ LE.le (MeasureTheory.OuterMeasure.mkMetric'.pre m r') (MeasureTheory.OuterMeasure.mkMetric'.pre m r)","decl":"theorem mono_pre (m : Set X → ℝ≥0∞) {r r' : ℝ≥0∞} (h : r ≤ r') : pre m r' ≤ pre m r :=\n  le_pre.2 fun _ hs => pre_le (hs.trans h)\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.mono_pre_nat","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nm : Set X → ENNReal\n⊢ Monotone fun k => MeasureTheory.OuterMeasure.mkMetric'.pre m (Inv.inv ↑k)","decl":"theorem mono_pre_nat (m : Set X → ℝ≥0∞) : Monotone fun k : ℕ => pre m k⁻¹ :=\n  fun k l h => le_pre.2 fun _ hs => pre_le (hs.trans <| by simpa)\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.tendsto_pre","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nm : Set X → ENNReal\ns : Set X\n⊢ Filter.Tendsto (fun r => (MeasureTheory.OuterMeasure.mkMetric'.pre m r) s) (nhdsWithin 0 (Set.Ioi 0)) (nhds ((MeasureTheory.OuterMeasure.mkMetric' m) s))","decl":"theorem tendsto_pre (m : Set X → ℝ≥0∞) (s : Set X) :\n    Tendsto (fun r => pre m r s) (𝓝[>] 0) (𝓝 <| mkMetric' m s) := by\n  rw [← map_coe_Ioi_atBot, tendsto_map'_iff]\n  simp only [mkMetric', OuterMeasure.iSup_apply, iSup_subtype']\n  exact tendsto_atBot_iSup fun r r' hr => mono_pre _ hr _\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.tendsto_pre_nat","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nm : Set X → ENNReal\ns : Set X\n⊢ Filter.Tendsto (fun n => (MeasureTheory.OuterMeasure.mkMetric'.pre m (Inv.inv ↑n)) s) Filter.atTop (nhds ((MeasureTheory.OuterMeasure.mkMetric' m) s))","decl":"theorem tendsto_pre_nat (m : Set X → ℝ≥0∞) (s : Set X) :\n    Tendsto (fun n : ℕ => pre m n⁻¹ s) atTop (𝓝 <| mkMetric' m s) := by\n  refine (tendsto_pre m s).comp (tendsto_inf.2 ⟨ENNReal.tendsto_inv_nat_nhds_zero, ?_⟩)\n  refine tendsto_principal.2 (Eventually.of_forall fun n => ?_)\n  simp\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.eq_iSup_nat","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nm : Set X → ENNReal\n⊢ Eq (MeasureTheory.OuterMeasure.mkMetric' m) (iSup fun n => MeasureTheory.OuterMeasure.mkMetric'.pre m (Inv.inv ↑n))","decl":"theorem eq_iSup_nat (m : Set X → ℝ≥0∞) : mkMetric' m = ⨆ n : ℕ, mkMetric'.pre m n⁻¹ := by\n  ext1 s\n  rw [iSup_apply]\n  refine tendsto_nhds_unique (mkMetric'.tendsto_pre_nat m s)\n    (tendsto_atTop_iSup fun k l hkl => mkMetric'.mono_pre_nat m hkl s)\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'.trim_pre","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : OpensMeasurableSpace X\nm : Set X → ENNReal\nhcl : ∀ (s : Set X), Eq (m (closure s)) (m s)\nr : ENNReal\n⊢ Eq (MeasureTheory.OuterMeasure.mkMetric'.pre m r).trim (MeasureTheory.OuterMeasure.mkMetric'.pre m r)","decl":"/-- `MeasureTheory.OuterMeasure.mkMetric'.pre m r` is a trimmed measure provided that\n`m (closure s) = m s` for any set `s`. -/\ntheorem trim_pre [MeasurableSpace X] [OpensMeasurableSpace X] (m : Set X → ℝ≥0∞)\n    (hcl : ∀ s, m (closure s) = m s) (r : ℝ≥0∞) : (pre m r).trim = pre m r := by\n  refine le_antisymm (le_pre.2 fun s hs => ?_) (le_trim _)\n  rw [trim_eq_iInf]\n  refine iInf_le_of_le (closure s) <| iInf_le_of_le subset_closure <|\n    iInf_le_of_le measurableSet_closure ((pre_le ?_).trans_eq (hcl _))\n  rwa [diam_closure]\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric'_isMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nm : Set X → ENNReal\n⊢ (MeasureTheory.OuterMeasure.mkMetric' m).IsMetric","decl":"/-- An outer measure constructed using `OuterMeasure.mkMetric'` is a metric outer measure. -/\ntheorem mkMetric'_isMetric (m : Set X → ℝ≥0∞) : (mkMetric' m).IsMetric := by\n  rintro s t ⟨r, r0, hr⟩\n  refine tendsto_nhds_unique_of_eventuallyEq\n    (mkMetric'.tendsto_pre _ _) ((mkMetric'.tendsto_pre _ _).add (mkMetric'.tendsto_pre _ _)) ?_\n  rw [← pos_iff_ne_zero] at r0\n  filter_upwards [Ioo_mem_nhdsGT r0]\n  rintro ε ⟨_, εr⟩\n  refine boundedBy_union_of_top_of_nonempty_inter ?_\n  rintro u ⟨x, hxs, hxu⟩ ⟨y, hyt, hyu⟩\n  have : ε < diam u := εr.trans_le ((hr x hxs y hyt).trans <| edist_le_diam_of_mem hxu hyu)\n  exact iInf_eq_top.2 fun h => (this.not_le h).elim\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric_mono_smul","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nm₁ m₂ : ENNReal → ENNReal\nc : ENNReal\nhc : Ne c Top.top\nh0 : Ne c 0\nhle : (nhdsWithin 0 (Set.Ici 0)).EventuallyLE m₁ (HSMul.hSMul c m₂)\n⊢ LE.le (MeasureTheory.OuterMeasure.mkMetric m₁) (HSMul.hSMul c (MeasureTheory.OuterMeasure.mkMetric m₂))","decl":"/-- If `c ∉ {0, ∞}` and `m₁ d ≤ c * m₂ d` for `d < ε` for some `ε > 0`\n(we use `≤ᶠ[𝓝[≥] 0]` to state this), then `mkMetric m₁ hm₁ ≤ c • mkMetric m₂ hm₂`. -/\ntheorem mkMetric_mono_smul {m₁ m₂ : ℝ≥0∞ → ℝ≥0∞} {c : ℝ≥0∞} (hc : c ≠ ∞) (h0 : c ≠ 0)\n    (hle : m₁ ≤ᶠ[𝓝[≥] 0] c • m₂) : (mkMetric m₁ : OuterMeasure X) ≤ c • mkMetric m₂ := by\n  classical\n  rcases (mem_nhdsGE_iff_exists_Ico_subset' zero_lt_one).1 hle with ⟨r, hr0, hr⟩\n  refine fun s =>\n    le_of_tendsto_of_tendsto (mkMetric'.tendsto_pre _ s)\n      (ENNReal.Tendsto.const_mul (mkMetric'.tendsto_pre _ s) (Or.inr hc))\n      (mem_of_superset (Ioo_mem_nhdsGT hr0) fun r' hr' => ?_)\n  simp only [mem_setOf_eq, mkMetric'.pre, RingHom.id_apply]\n  rw [← smul_eq_mul, ← smul_apply, smul_boundedBy hc]\n  refine le_boundedBy.2 (fun t => (boundedBy_le _).trans ?_) _\n  simp only [smul_eq_mul, Pi.smul_apply, extend, iInf_eq_if]\n  split_ifs with ht\n  · apply hr\n    exact ⟨zero_le _, ht.trans_lt hr'.2⟩\n  · simp [h0]\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric_top","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\n⊢ Eq (MeasureTheory.OuterMeasure.mkMetric fun x => Top.top) Top.top","decl":"@[simp]\ntheorem mkMetric_top : (mkMetric (fun _ => ∞ : ℝ≥0∞ → ℝ≥0∞) : OuterMeasure X) = ⊤ := by\n  simp_rw [mkMetric, mkMetric', mkMetric'.pre, extend_top, boundedBy_top, eq_top_iff]\n  rw [le_iSup_iff]\n  intro b hb\n  simpa using hb ⊤\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric_mono","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nm₁ m₂ : ENNReal → ENNReal\nhle : (nhdsWithin 0 (Set.Ici 0)).EventuallyLE m₁ m₂\n⊢ LE.le (MeasureTheory.OuterMeasure.mkMetric m₁) (MeasureTheory.OuterMeasure.mkMetric m₂)","decl":"/-- If `m₁ d ≤ m₂ d` for `d < ε` for some `ε > 0` (we use `≤ᶠ[𝓝[≥] 0]` to state this), then\n`mkMetric m₁ hm₁ ≤ mkMetric m₂ hm₂`. -/\ntheorem mkMetric_mono {m₁ m₂ : ℝ≥0∞ → ℝ≥0∞} (hle : m₁ ≤ᶠ[𝓝[≥] 0] m₂) :\n    (mkMetric m₁ : OuterMeasure X) ≤ mkMetric m₂ := by\n  convert @mkMetric_mono_smul X _ _ m₂ _ ENNReal.one_ne_top one_ne_zero _ <;> simp [*]\n\n"}
{"name":"MeasureTheory.OuterMeasure.isometry_comap_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : EMetricSpace X\ninst✝ : EMetricSpace Y\nm : ENNReal → ENNReal\nf : X → Y\nhf : Isometry f\nH : Or (Monotone m) (Function.Surjective f)\n⊢ Eq ((MeasureTheory.OuterMeasure.comap f) (MeasureTheory.OuterMeasure.mkMetric m)) (MeasureTheory.OuterMeasure.mkMetric m)","decl":"theorem isometry_comap_mkMetric (m : ℝ≥0∞ → ℝ≥0∞) {f : X → Y} (hf : Isometry f)\n    (H : Monotone m ∨ Surjective f) : comap f (mkMetric m) = mkMetric m := by\n  simp only [mkMetric, mkMetric', mkMetric'.pre, inducedOuterMeasure, comap_iSup]\n  refine surjective_id.iSup_congr id fun ε => surjective_id.iSup_congr id fun hε => ?_\n  rw [comap_boundedBy _ (H.imp _ id)]\n  · congr with s : 1\n    apply extend_congr\n    · simp [hf.ediam_image]\n    · intros; simp [hf.injective.subsingleton_image_iff, hf.ediam_image]\n  · intro h_mono s t hst\n    simp only [extend, le_iInf_iff]\n    intro ht\n    apply le_trans _ (h_mono (diam_mono hst))\n    simp only [(diam_mono hst).trans ht, le_refl, ciInf_pos]\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric_smul","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nm : ENNReal → ENNReal\nc : ENNReal\nhc : Ne c Top.top\nhc' : Ne c 0\n⊢ Eq (MeasureTheory.OuterMeasure.mkMetric (HSMul.hSMul c m)) (HSMul.hSMul c (MeasureTheory.OuterMeasure.mkMetric m))","decl":"theorem mkMetric_smul (m : ℝ≥0∞ → ℝ≥0∞) {c : ℝ≥0∞} (hc : c ≠ ∞) (hc' : c ≠ 0) :\n    (mkMetric (c • m) : OuterMeasure X) = c • mkMetric m := by\n  simp only [mkMetric, mkMetric', mkMetric'.pre, inducedOuterMeasure, ENNReal.smul_iSup]\n  simp_rw [smul_iSup, smul_boundedBy hc, smul_extend _ hc', Pi.smul_apply]\n\n"}
{"name":"MeasureTheory.OuterMeasure.mkMetric_nnreal_smul","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nm : ENNReal → ENNReal\nc : NNReal\nhc : Ne c 0\n⊢ Eq (MeasureTheory.OuterMeasure.mkMetric (HSMul.hSMul c m)) (HSMul.hSMul c (MeasureTheory.OuterMeasure.mkMetric m))","decl":"theorem mkMetric_nnreal_smul (m : ℝ≥0∞ → ℝ≥0∞) {c : ℝ≥0} (hc : c ≠ 0) :\n    (mkMetric (c • m) : OuterMeasure X) = c • mkMetric m := by\n  rw [ENNReal.smul_def, ENNReal.smul_def,\n    mkMetric_smul m ENNReal.coe_ne_top (ENNReal.coe_ne_zero.mpr hc)]\n\n"}
{"name":"MeasureTheory.OuterMeasure.isometry_map_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : EMetricSpace X\ninst✝ : EMetricSpace Y\nm : ENNReal → ENNReal\nf : X → Y\nhf : Isometry f\nH : Or (Monotone m) (Function.Surjective f)\n⊢ Eq ((MeasureTheory.OuterMeasure.map f) (MeasureTheory.OuterMeasure.mkMetric m)) ((MeasureTheory.OuterMeasure.restrict (Set.range f)) (MeasureTheory.OuterMeasure.mkMetric m))","decl":"theorem isometry_map_mkMetric (m : ℝ≥0∞ → ℝ≥0∞) {f : X → Y} (hf : Isometry f)\n    (H : Monotone m ∨ Surjective f) : map f (mkMetric m) = restrict (range f) (mkMetric m) := by\n  rw [← isometry_comap_mkMetric _ hf H, map_comap]\n\n"}
{"name":"MeasureTheory.OuterMeasure.isometryEquiv_comap_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : EMetricSpace X\ninst✝ : EMetricSpace Y\nm : ENNReal → ENNReal\nf : IsometryEquiv X Y\n⊢ Eq ((MeasureTheory.OuterMeasure.comap ⇑f) (MeasureTheory.OuterMeasure.mkMetric m)) (MeasureTheory.OuterMeasure.mkMetric m)","decl":"theorem isometryEquiv_comap_mkMetric (m : ℝ≥0∞ → ℝ≥0∞) (f : X ≃ᵢ Y) :\n    comap f (mkMetric m) = mkMetric m :=\n  isometry_comap_mkMetric _ f.isometry (Or.inr f.surjective)\n\n"}
{"name":"MeasureTheory.OuterMeasure.isometryEquiv_map_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝¹ : EMetricSpace X\ninst✝ : EMetricSpace Y\nm : ENNReal → ENNReal\nf : IsometryEquiv X Y\n⊢ Eq ((MeasureTheory.OuterMeasure.map ⇑f) (MeasureTheory.OuterMeasure.mkMetric m)) (MeasureTheory.OuterMeasure.mkMetric m)","decl":"theorem isometryEquiv_map_mkMetric (m : ℝ≥0∞ → ℝ≥0∞) (f : X ≃ᵢ Y) :\n    map f (mkMetric m) = mkMetric m := by\n  rw [← isometryEquiv_comap_mkMetric _ f, map_comap_of_surjective f.surjective]\n\n"}
{"name":"MeasureTheory.OuterMeasure.trim_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nm : ENNReal → ENNReal\n⊢ Eq (MeasureTheory.OuterMeasure.mkMetric m).trim (MeasureTheory.OuterMeasure.mkMetric m)","decl":"theorem trim_mkMetric [MeasurableSpace X] [BorelSpace X] (m : ℝ≥0∞ → ℝ≥0∞) :\n    (mkMetric m : OuterMeasure X).trim = mkMetric m := by\n  simp only [mkMetric, mkMetric'.eq_iSup_nat, trim_iSup]\n  congr 1 with n : 1\n  refine mkMetric'.trim_pre _ (fun s => ?_) _\n  simp\n\n"}
{"name":"MeasureTheory.OuterMeasure.le_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝ : EMetricSpace X\nm : ENNReal → ENNReal\nμ : MeasureTheory.OuterMeasure X\nr : ENNReal\nh0 : LT.lt 0 r\nhr : ∀ (s : Set X), LE.le (EMetric.diam s) r → LE.le (μ s) (m (EMetric.diam s))\n⊢ LE.le μ (MeasureTheory.OuterMeasure.mkMetric m)","decl":"theorem le_mkMetric (m : ℝ≥0∞ → ℝ≥0∞) (μ : OuterMeasure X) (r : ℝ≥0∞) (h0 : 0 < r)\n    (hr : ∀ s, diam s ≤ r → μ s ≤ m (diam s)) : μ ≤ mkMetric m :=\n  le_iSup₂_of_le r h0 <| mkMetric'.le_pre.2 fun _ hs => hr _ hs\n\n"}
{"name":"MeasureTheory.Measure.mkMetric'_toOuterMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nm : Set X → ENNReal\n⊢ Eq (MeasureTheory.Measure.mkMetric' m).toOuterMeasure (MeasureTheory.OuterMeasure.mkMetric' m).trim","decl":"@[simp]\ntheorem mkMetric'_toOuterMeasure (m : Set X → ℝ≥0∞) :\n    (mkMetric' m).toOuterMeasure = (OuterMeasure.mkMetric' m).trim :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_toOuterMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nm : ENNReal → ENNReal\n⊢ Eq (MeasureTheory.Measure.mkMetric m).toOuterMeasure (MeasureTheory.OuterMeasure.mkMetric m)","decl":"@[simp]\ntheorem mkMetric_toOuterMeasure (m : ℝ≥0∞ → ℝ≥0∞) :\n    (mkMetric m : Measure X).toOuterMeasure = OuterMeasure.mkMetric m :=\n  OuterMeasure.trim_mkMetric m\n\n"}
{"name":"MeasureTheory.OuterMeasure.coe_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nm : ENNReal → ENNReal\n⊢ Eq ⇑(MeasureTheory.OuterMeasure.mkMetric m) ⇑(MeasureTheory.Measure.mkMetric m)","decl":"theorem OuterMeasure.coe_mkMetric [MeasurableSpace X] [BorelSpace X] (m : ℝ≥0∞ → ℝ≥0∞) :\n    ⇑(OuterMeasure.mkMetric m : OuterMeasure X) = Measure.mkMetric m := by\n  rw [← Measure.mkMetric_toOuterMeasure, Measure.coe_toOuterMeasure]\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_mono_smul","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nm₁ m₂ : ENNReal → ENNReal\nc : ENNReal\nhc : Ne c Top.top\nh0 : Ne c 0\nhle : (nhdsWithin 0 (Set.Ici 0)).EventuallyLE m₁ (HSMul.hSMul c m₂)\n⊢ LE.le (MeasureTheory.Measure.mkMetric m₁) (HSMul.hSMul c (MeasureTheory.Measure.mkMetric m₂))","decl":"/-- If `c ∉ {0, ∞}` and `m₁ d ≤ c * m₂ d` for `d < ε` for some `ε > 0`\n(we use `≤ᶠ[𝓝[≥] 0]` to state this), then `mkMetric m₁ hm₁ ≤ c • mkMetric m₂ hm₂`. -/\ntheorem mkMetric_mono_smul {m₁ m₂ : ℝ≥0∞ → ℝ≥0∞} {c : ℝ≥0∞} (hc : c ≠ ∞) (h0 : c ≠ 0)\n    (hle : m₁ ≤ᶠ[𝓝[≥] 0] c • m₂) : (mkMetric m₁ : Measure X) ≤ c • mkMetric m₂ := fun s ↦ by\n  rw [← OuterMeasure.coe_mkMetric, coe_smul, ← OuterMeasure.coe_mkMetric]\n  exact OuterMeasure.mkMetric_mono_smul hc h0 hle s\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_top","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\n⊢ Eq (MeasureTheory.Measure.mkMetric fun x => Top.top) Top.top","decl":"@[simp]\ntheorem mkMetric_top : (mkMetric (fun _ => ∞ : ℝ≥0∞ → ℝ≥0∞) : Measure X) = ⊤ := by\n  apply toOuterMeasure_injective\n  rw [mkMetric_toOuterMeasure, OuterMeasure.mkMetric_top, toOuterMeasure_top]\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_mono","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nm₁ m₂ : ENNReal → ENNReal\nhle : (nhdsWithin 0 (Set.Ici 0)).EventuallyLE m₁ m₂\n⊢ LE.le (MeasureTheory.Measure.mkMetric m₁) (MeasureTheory.Measure.mkMetric m₂)","decl":"/-- If `m₁ d ≤ m₂ d` for `d < ε` for some `ε > 0` (we use `≤ᶠ[𝓝[≥] 0]` to state this), then\n`mkMetric m₁ hm₁ ≤ mkMetric m₂ hm₂`. -/\ntheorem mkMetric_mono {m₁ m₂ : ℝ≥0∞ → ℝ≥0∞} (hle : m₁ ≤ᶠ[𝓝[≥] 0] m₂) :\n    (mkMetric m₁ : Measure X) ≤ mkMetric m₂ := by\n  convert @mkMetric_mono_smul X _ _ _ _ m₂ _ ENNReal.one_ne_top one_ne_zero _ <;> simp [*]\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_apply","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nm : ENNReal → ENNReal\ns : Set X\n⊢ Eq ((MeasureTheory.Measure.mkMetric m) s) (iSup fun r => iSup fun x => iInf fun t => iInf fun x => iInf fun x => tsum fun n => iSup fun x => m (EMetric.diam (t n)))","decl":"/-- A formula for `MeasureTheory.Measure.mkMetric`. -/\ntheorem mkMetric_apply (m : ℝ≥0∞ → ℝ≥0∞) (s : Set X) :\n    mkMetric m s =\n      ⨆ (r : ℝ≥0∞) (_ : 0 < r),\n        ⨅ (t : ℕ → Set X) (_ : s ⊆ iUnion t) (_ : ∀ n, diam (t n) ≤ r),\n          ∑' n, ⨆ _ : (t n).Nonempty, m (diam (t n)) := by\n  classical\n  -- We mostly unfold the definitions but we need to switch the order of `∑'` and `⨅`\n  simp only [← OuterMeasure.coe_mkMetric, OuterMeasure.mkMetric, OuterMeasure.mkMetric',\n    OuterMeasure.iSup_apply, OuterMeasure.mkMetric'.pre, OuterMeasure.boundedBy_apply, extend]\n  refine\n    surjective_id.iSup_congr id fun r =>\n      iSup_congr_Prop Iff.rfl fun _ =>\n        surjective_id.iInf_congr _ fun t => iInf_congr_Prop Iff.rfl fun ht => ?_\n  dsimp\n  by_cases htr : ∀ n, diam (t n) ≤ r\n  · rw [iInf_eq_if, if_pos htr]\n    congr 1 with n : 1\n    simp only [iInf_eq_if, htr n, id, if_true, iSup_and']\n  · rw [iInf_eq_if, if_neg htr]\n    push_neg at htr; rcases htr with ⟨n, hn⟩\n    refine ENNReal.tsum_eq_top_of_eq_top ⟨n, ?_⟩\n    rw [iSup_eq_if, if_pos, iInf_eq_if, if_neg]\n    · exact hn.not_le\n    rcases diam_pos_iff.1 ((zero_le r).trans_lt hn) with ⟨x, hx, -⟩\n    exact ⟨x, hx⟩\n\n"}
{"name":"MeasureTheory.Measure.le_mkMetric","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nm : ENNReal → ENNReal\nμ : MeasureTheory.Measure X\nε : ENNReal\nh₀ : LT.lt 0 ε\nh : ∀ (s : Set X), LE.le (EMetric.diam s) ε → LE.le (μ s) (m (EMetric.diam s))\n⊢ LE.le μ (MeasureTheory.Measure.mkMetric m)","decl":"theorem le_mkMetric (m : ℝ≥0∞ → ℝ≥0∞) (μ : Measure X) (ε : ℝ≥0∞) (h₀ : 0 < ε)\n    (h : ∀ s : Set X, diam s ≤ ε → μ s ≤ m (diam s)) : μ ≤ mkMetric m := by\n  rw [← toOuterMeasure_le, mkMetric_toOuterMeasure]\n  exact OuterMeasure.le_mkMetric m μ.toOuterMeasure ε h₀ h\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_le_liminf_tsum","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝³ : EMetricSpace X\ninst✝² : MeasurableSpace X\ninst✝¹ : BorelSpace X\nβ : Type u_4\nι : β → Type u_5\ninst✝ : ∀ (n : β), Countable (ι n)\ns : Set X\nl : Filter β\nr : β → ENNReal\nhr : Filter.Tendsto r l (nhds 0)\nt : (n : β) → ι n → Set X\nht : Filter.Eventually (fun n => ∀ (i : ι n), LE.le (EMetric.diam (t n i)) (r n)) l\nhst : Filter.Eventually (fun n => HasSubset.Subset s (Set.iUnion fun i => t n i)) l\nm : ENNReal → ENNReal\n⊢ LE.le ((MeasureTheory.Measure.mkMetric m) s) (Filter.liminf (fun n => tsum fun i => m (EMetric.diam (t n i))) l)","decl":"/-- To bound the Hausdorff measure (or, more generally, for a measure defined using\n`MeasureTheory.Measure.mkMetric`) of a set, one may use coverings with maximum diameter tending to\n`0`, indexed by any sequence of countable types. -/\ntheorem mkMetric_le_liminf_tsum {β : Type*} {ι : β → Type*} [∀ n, Countable (ι n)] (s : Set X)\n    {l : Filter β} (r : β → ℝ≥0∞) (hr : Tendsto r l (𝓝 0)) (t : ∀ n : β, ι n → Set X)\n    (ht : ∀ᶠ n in l, ∀ i, diam (t n i) ≤ r n) (hst : ∀ᶠ n in l, s ⊆ ⋃ i, t n i) (m : ℝ≥0∞ → ℝ≥0∞) :\n    mkMetric m s ≤ liminf (fun n => ∑' i, m (diam (t n i))) l := by\n  haveI : ∀ n, Encodable (ι n) := fun n => Encodable.ofCountable _\n  simp only [mkMetric_apply]\n  refine iSup₂_le fun ε hε => ?_\n  refine le_of_forall_gt_imp_ge_of_dense fun c hc => ?_\n  rcases ((frequently_lt_of_liminf_lt (by isBoundedDefault) hc).and_eventually\n        ((hr.eventually (gt_mem_nhds hε)).and (ht.and hst))).exists with\n    ⟨n, hn, hrn, htn, hstn⟩\n  set u : ℕ → Set X := fun j => ⋃ b ∈ decode₂ (ι n) j, t n b\n  refine iInf₂_le_of_le u (by rwa [iUnion_decode₂]) ?_\n  refine iInf_le_of_le (fun j => ?_) ?_\n  · rw [EMetric.diam_iUnion_mem_option]\n    exact iSup₂_le fun _ _ => (htn _).trans hrn.le\n  · calc\n      (∑' j : ℕ, ⨆ _ : (u j).Nonempty, m (diam (u j))) = _ :=\n        tsum_iUnion_decode₂ (fun t : Set X => ⨆ _ : t.Nonempty, m (diam t)) (by simp) _\n      _ ≤ ∑' i : ι n, m (diam (t n i)) := ENNReal.tsum_le_tsum fun b => iSup_le fun _ => le_rfl\n      _ ≤ c := hn.le\n\n"}
{"name":"MeasureTheory.Measure.mkMetric_le_liminf_sum","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nβ : Type u_4\nι : β → Type u_5\nhι : (n : β) → Fintype (ι n)\ns : Set X\nl : Filter β\nr : β → ENNReal\nhr : Filter.Tendsto r l (nhds 0)\nt : (n : β) → ι n → Set X\nht : Filter.Eventually (fun n => ∀ (i : ι n), LE.le (EMetric.diam (t n i)) (r n)) l\nhst : Filter.Eventually (fun n => HasSubset.Subset s (Set.iUnion fun i => t n i)) l\nm : ENNReal → ENNReal\n⊢ LE.le ((MeasureTheory.Measure.mkMetric m) s) (Filter.liminf (fun n => Finset.univ.sum fun i => m (EMetric.diam (t n i))) l)","decl":"/-- To bound the Hausdorff measure (or, more generally, for a measure defined using\n`MeasureTheory.Measure.mkMetric`) of a set, one may use coverings with maximum diameter tending to\n`0`, indexed by any sequence of finite types. -/\ntheorem mkMetric_le_liminf_sum {β : Type*} {ι : β → Type*} [hι : ∀ n, Fintype (ι n)] (s : Set X)\n    {l : Filter β} (r : β → ℝ≥0∞) (hr : Tendsto r l (𝓝 0)) (t : ∀ n : β, ι n → Set X)\n    (ht : ∀ᶠ n in l, ∀ i, diam (t n i) ≤ r n) (hst : ∀ᶠ n in l, s ⊆ ⋃ i, t n i) (m : ℝ≥0∞ → ℝ≥0∞) :\n    mkMetric m s ≤ liminf (fun n => ∑ i, m (diam (t n i))) l := by\n  simpa only [tsum_fintype] using mkMetric_le_liminf_tsum s r hr t ht hst m\n\n"}
{"name":"MeasureTheory.Measure.le_hausdorffMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nd : Real\nμ : MeasureTheory.Measure X\nε : ENNReal\nh₀ : LT.lt 0 ε\nh : ∀ (s : Set X), LE.le (EMetric.diam s) ε → LE.le (μ s) (HPow.hPow (EMetric.diam s) d)\n⊢ LE.le μ (MeasureTheory.Measure.hausdorffMeasure d)","decl":"theorem le_hausdorffMeasure (d : ℝ) (μ : Measure X) (ε : ℝ≥0∞) (h₀ : 0 < ε)\n    (h : ∀ s : Set X, diam s ≤ ε → μ s ≤ diam s ^ d) : μ ≤ μH[d] :=\n  le_mkMetric _ μ ε h₀ h\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_apply","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nd : Real\ns : Set X\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) s) (iSup fun r => iSup fun x => iInf fun t => iInf fun x => iInf fun x => tsum fun n => iSup fun x => HPow.hPow (EMetric.diam (t n)) d)","decl":"/-- A formula for `μH[d] s`. -/\ntheorem hausdorffMeasure_apply (d : ℝ) (s : Set X) :\n    μH[d] s =\n      ⨆ (r : ℝ≥0∞) (_ : 0 < r),\n        ⨅ (t : ℕ → Set X) (_ : s ⊆ ⋃ n, t n) (_ : ∀ n, diam (t n) ≤ r),\n          ∑' n, ⨆ _ : (t n).Nonempty, diam (t n) ^ d :=\n  mkMetric_apply _ _\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_le_liminf_tsum","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝³ : EMetricSpace X\ninst✝² : MeasurableSpace X\ninst✝¹ : BorelSpace X\nβ : Type u_4\nι : β → Type u_5\ninst✝ : ∀ (n : β), Countable (ι n)\nd : Real\ns : Set X\nl : Filter β\nr : β → ENNReal\nhr : Filter.Tendsto r l (nhds 0)\nt : (n : β) → ι n → Set X\nht : Filter.Eventually (fun n => ∀ (i : ι n), LE.le (EMetric.diam (t n i)) (r n)) l\nhst : Filter.Eventually (fun n => HasSubset.Subset s (Set.iUnion fun i => t n i)) l\n⊢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) s) (Filter.liminf (fun n => tsum fun i => HPow.hPow (EMetric.diam (t n i)) d) l)","decl":"/-- To bound the Hausdorff measure of a set, one may use coverings with maximum diameter tending\nto `0`, indexed by any sequence of countable types. -/\ntheorem hausdorffMeasure_le_liminf_tsum {β : Type*} {ι : β → Type*} [∀ n, Countable (ι n)]\n    (d : ℝ) (s : Set X) {l : Filter β} (r : β → ℝ≥0∞) (hr : Tendsto r l (𝓝 0))\n    (t : ∀ n : β, ι n → Set X) (ht : ∀ᶠ n in l, ∀ i, diam (t n i) ≤ r n)\n    (hst : ∀ᶠ n in l, s ⊆ ⋃ i, t n i) : μH[d] s ≤ liminf (fun n => ∑' i, diam (t n i) ^ d) l :=\n  mkMetric_le_liminf_tsum s r hr t ht hst _\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_le_liminf_sum","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝³ : EMetricSpace X\ninst✝² : MeasurableSpace X\ninst✝¹ : BorelSpace X\nβ : Type u_4\nι : β → Type u_5\ninst✝ : (n : β) → Fintype (ι n)\nd : Real\ns : Set X\nl : Filter β\nr : β → ENNReal\nhr : Filter.Tendsto r l (nhds 0)\nt : (n : β) → ι n → Set X\nht : Filter.Eventually (fun n => ∀ (i : ι n), LE.le (EMetric.diam (t n i)) (r n)) l\nhst : Filter.Eventually (fun n => HasSubset.Subset s (Set.iUnion fun i => t n i)) l\n⊢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) s) (Filter.liminf (fun n => Finset.univ.sum fun i => HPow.hPow (EMetric.diam (t n i)) d) l)","decl":"/-- To bound the Hausdorff measure of a set, one may use coverings with maximum diameter tending\nto `0`, indexed by any sequence of finite types. -/\ntheorem hausdorffMeasure_le_liminf_sum {β : Type*} {ι : β → Type*} [∀ n, Fintype (ι n)]\n    (d : ℝ) (s : Set X) {l : Filter β} (r : β → ℝ≥0∞) (hr : Tendsto r l (𝓝 0))\n    (t : ∀ n : β, ι n → Set X) (ht : ∀ᶠ n in l, ∀ i, diam (t n i) ≤ r n)\n    (hst : ∀ᶠ n in l, s ⊆ ⋃ i, t n i) : μH[d] s ≤ liminf (fun n => ∑ i, diam (t n i) ^ d) l :=\n  mkMetric_le_liminf_sum s r hr t ht hst _\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_zero_or_top","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nd₁ d₂ : Real\nh : LT.lt d₁ d₂\ns : Set X\n⊢ Or (Eq ((MeasureTheory.Measure.hausdorffMeasure d₂) s) 0) (Eq ((MeasureTheory.Measure.hausdorffMeasure d₁) s) Top.top)","decl":"/-- If `d₁ < d₂`, then for any set `s` we have either `μH[d₂] s = 0`, or `μH[d₁] s = ∞`. -/\ntheorem hausdorffMeasure_zero_or_top {d₁ d₂ : ℝ} (h : d₁ < d₂) (s : Set X) :\n    μH[d₂] s = 0 ∨ μH[d₁] s = ∞ := by\n  by_contra! H\n  suffices ∀ c : ℝ≥0, c ≠ 0 → μH[d₂] s ≤ c * μH[d₁] s by\n    rcases ENNReal.exists_nnreal_pos_mul_lt H.2 H.1 with ⟨c, hc0, hc⟩\n    exact hc.not_le (this c (pos_iff_ne_zero.1 hc0))\n  intro c hc\n  refine le_iff'.1 (mkMetric_mono_smul ENNReal.coe_ne_top (mod_cast hc) ?_) s\n  have : 0 < ((c : ℝ≥0∞) ^ (d₂ - d₁)⁻¹) := by\n    rw [← ENNReal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, Ne, ENNReal.coe_eq_zero,\n      NNReal.rpow_eq_zero_iff]\n    exact mt And.left hc\n  filter_upwards [Ico_mem_nhdsGE this]\n  rintro r ⟨hr₀, hrc⟩\n  lift r to ℝ≥0 using ne_top_of_lt hrc\n  rw [Pi.smul_apply, smul_eq_mul,\n    ← ENNReal.div_le_iff_le_mul (Or.inr ENNReal.coe_ne_top) (Or.inr <| mt ENNReal.coe_eq_zero.1 hc)]\n  rcases eq_or_ne r 0 with (rfl | hr₀)\n  · rcases lt_or_le 0 d₂ with (h₂ | h₂)\n    · simp only [h₂, ENNReal.zero_rpow_of_pos, zero_le, ENNReal.zero_div, ENNReal.coe_zero]\n    · simp only [h.trans_le h₂, ENNReal.div_top, zero_le, ENNReal.zero_rpow_of_neg,\n        ENNReal.coe_zero]\n  · have : (r : ℝ≥0∞) ≠ 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using hr₀\n    rw [← ENNReal.rpow_sub _ _ this ENNReal.coe_ne_top]\n    refine (ENNReal.rpow_lt_rpow hrc (sub_pos.2 h)).le.trans ?_\n    rw [← ENNReal.rpow_mul, inv_mul_cancel₀ (sub_pos.2 h).ne', ENNReal.rpow_one]\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_mono","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nd₁ d₂ : Real\nh : LE.le d₁ d₂\ns : Set X\n⊢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d₂) s) ((MeasureTheory.Measure.hausdorffMeasure d₁) s)","decl":"/-- Hausdorff measure `μH[d] s` is monotone in `d`. -/\ntheorem hausdorffMeasure_mono {d₁ d₂ : ℝ} (h : d₁ ≤ d₂) (s : Set X) : μH[d₂] s ≤ μH[d₁] s := by\n  rcases h.eq_or_lt with (rfl | h); · exact le_rfl\n  cases' hausdorffMeasure_zero_or_top h s with hs hs\n  · rw [hs]; exact zero_le _\n  · rw [hs]; exact le_top\n\n"}
{"name":"MeasureTheory.Measure.noAtoms_hausdorff","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nd : Real\nhd : LT.lt 0 d\n⊢ MeasureTheory.NoAtoms (MeasureTheory.Measure.hausdorffMeasure d)","decl":"theorem noAtoms_hausdorff {d : ℝ} (hd : 0 < d) : NoAtoms (hausdorffMeasure d : Measure X) := by\n  refine ⟨fun x => ?_⟩\n  rw [← nonpos_iff_eq_zero, hausdorffMeasure_apply]\n  refine iSup₂_le fun ε _ => iInf₂_le_of_le (fun _ => {x}) ?_ <| iInf_le_of_le (fun _ => ?_) ?_\n  · exact subset_iUnion (fun _ => {x} : ℕ → Set X) 0\n  · simp only [EMetric.diam_singleton, zero_le]\n  · simp [hd]\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_zero_singleton","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\nx : X\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure 0) (Singleton.singleton x)) 1","decl":"@[simp]\ntheorem hausdorffMeasure_zero_singleton (x : X) : μH[0] ({x} : Set X) = 1 := by\n  apply le_antisymm\n  · let r : ℕ → ℝ≥0∞ := fun _ => 0\n    let t : ℕ → Unit → Set X := fun _ _ => {x}\n    have ht : ∀ᶠ n in atTop, ∀ i, diam (t n i) ≤ r n := by\n      simp only [t, r, imp_true_iff, eq_self_iff_true, diam_singleton, eventually_atTop,\n        nonpos_iff_eq_zero, exists_const]\n    simpa [t, liminf_const] using hausdorffMeasure_le_liminf_sum 0 {x} r tendsto_const_nhds t ht\n  · rw [hausdorffMeasure_apply]\n    suffices\n      (1 : ℝ≥0∞) ≤\n        ⨅ (t : ℕ → Set X) (_ : {x} ⊆ ⋃ n, t n) (_ : ∀ n, diam (t n) ≤ 1),\n          ∑' n, ⨆ _ : (t n).Nonempty, diam (t n) ^ (0 : ℝ) by\n      apply le_trans this _\n      convert le_iSup₂ (α := ℝ≥0∞) (1 : ℝ≥0∞) zero_lt_one\n      rfl\n    simp only [ENNReal.rpow_zero, le_iInf_iff]\n    intro t hst _\n    rcases mem_iUnion.1 (hst (mem_singleton x)) with ⟨m, hm⟩\n    have A : (t m).Nonempty := ⟨x, hm⟩\n    calc\n      (1 : ℝ≥0∞) = ⨆ h : (t m).Nonempty, 1 := by simp only [A, ciSup_pos]\n      _ ≤ ∑' n, ⨆ h : (t n).Nonempty, 1 := ENNReal.le_tsum _\n\n"}
{"name":"MeasureTheory.Measure.one_le_hausdorffMeasure_zero_of_nonempty","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\ns : Set X\nh : s.Nonempty\n⊢ LE.le 1 ((MeasureTheory.Measure.hausdorffMeasure 0) s)","decl":"theorem one_le_hausdorffMeasure_zero_of_nonempty {s : Set X} (h : s.Nonempty) : 1 ≤ μH[0] s := by\n  rcases h with ⟨x, hx⟩\n  calc\n    (1 : ℝ≥0∞) = μH[0] ({x} : Set X) := (hausdorffMeasure_zero_singleton x).symm\n    _ ≤ μH[0] s := measure_mono (singleton_subset_iff.2 hx)\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_le_one_of_subsingleton","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝² : EMetricSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : BorelSpace X\ns : Set X\nhs : s.Subsingleton\nd : Real\nhd : LE.le 0 d\n⊢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) s) 1","decl":"theorem hausdorffMeasure_le_one_of_subsingleton {s : Set X} (hs : s.Subsingleton) {d : ℝ}\n    (hd : 0 ≤ d) : μH[d] s ≤ 1 := by\n  rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)\n  · simp only [measure_empty, zero_le]\n  · rw [(subsingleton_iff_singleton hx).1 hs]\n    rcases eq_or_lt_of_le hd with (rfl | dpos)\n    · simp only [le_refl, hausdorffMeasure_zero_singleton]\n    · haveI := noAtoms_hausdorff X dpos\n      simp only [zero_le, measure_singleton]\n\n"}
{"name":"HolderOnWith.hausdorffMeasure_image_le","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝⁵ : EMetricSpace X\ninst✝⁴ : EMetricSpace Y\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ninst✝¹ : MeasurableSpace Y\ninst✝ : BorelSpace Y\nC r : NNReal\nf : X → Y\ns : Set X\nh : HolderOnWith C r f s\nhr : LT.lt 0 r\nd : Real\nhd : LE.le 0 d\n⊢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image f s)) (HMul.hMul (HPow.hPow (↑C) d) ((MeasureTheory.Measure.hausdorffMeasure (HMul.hMul (↑r) d)) s))","decl":"/-- If `f : X → Y` is Hölder continuous on `s` with a positive exponent `r`, then\n`μH[d] (f '' s) ≤ C ^ d * μH[r * d] s`. -/\ntheorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :\n    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s := by\n  -- We start with the trivial case `C = 0`\n  rcases (zero_le C).eq_or_lt with (rfl | hC0)\n  · rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)\n    · simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]\n    have : f '' s = {f x} :=\n      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le\n      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this\n    rw [this]\n    rcases eq_or_lt_of_le hd with (rfl | h'd)\n    · simp only [ENNReal.rpow_zero, one_mul, mul_zero]\n      rw [hausdorffMeasure_zero_singleton]\n      exact one_le_hausdorffMeasure_zero_of_nonempty ⟨x, hx⟩\n    · haveI := noAtoms_hausdorff Y h'd\n      simp only [zero_le, measure_singleton]\n  -- Now assume `C ≠ 0`\n  · have hCd0 : (C : ℝ≥0∞) ^ d ≠ 0 := by simp [hC0.ne']\n    have hCd : (C : ℝ≥0∞) ^ d ≠ ∞ := by simp [hd]\n    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,\n      ← ENNReal.tsum_mul_left]\n    refine iSup_le fun R => iSup_le fun hR => ?_\n    have : Tendsto (fun d : ℝ≥0∞ => (C : ℝ≥0∞) * d ^ (r : ℝ)) (𝓝 0) (𝓝 0) :=\n      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr\n    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with\n      ⟨δ, δ0, H⟩\n    refine le_iSup₂_of_le δ δ0 <| iInf₂_mono' fun t hst ↦\n      ⟨fun n => f '' (t n ∩ s), ?_, iInf_mono' fun htδ ↦\n        ⟨fun n => (h.ediam_image_inter_le (t n)).trans (H (htδ n)).le, ?_⟩⟩\n    · rw [← image_iUnion, ← iUnion_inter]\n      exact image_subset _ (subset_inter hst Subset.rfl)\n    · refine ENNReal.tsum_le_tsum fun n => ?_\n      simp only [iSup_le_iff, image_nonempty]\n      intro hft\n      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]\n      rw [ENNReal.rpow_mul, ← ENNReal.mul_rpow_of_nonneg _ _ hd]\n      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd\n\n"}
{"name":"LipschitzOnWith.hausdorffMeasure_image_le","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝⁵ : EMetricSpace X\ninst✝⁴ : EMetricSpace Y\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ninst✝¹ : MeasurableSpace Y\ninst✝ : BorelSpace Y\nK : NNReal\nf : X → Y\ns : Set X\nh : LipschitzOnWith K f s\nd : Real\nhd : LE.le 0 d\n⊢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image f s)) (HMul.hMul (HPow.hPow (↑K) d) ((MeasureTheory.Measure.hausdorffMeasure d) s))","decl":"/-- If `f : X → Y` is `K`-Lipschitz on `s`, then `μH[d] (f '' s) ≤ K ^ d * μH[d] s`. -/\ntheorem hausdorffMeasure_image_le (h : LipschitzOnWith K f s) {d : ℝ} (hd : 0 ≤ d) :\n    μH[d] (f '' s) ≤ (K : ℝ≥0∞) ^ d * μH[d] s := by\n  simpa only [NNReal.coe_one, one_mul] using h.holderOnWith.hausdorffMeasure_image_le zero_lt_one hd\n\n"}
{"name":"LipschitzWith.hausdorffMeasure_image_le","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝⁵ : EMetricSpace X\ninst✝⁴ : EMetricSpace Y\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ninst✝¹ : MeasurableSpace Y\ninst✝ : BorelSpace Y\nK : NNReal\nf : X → Y\nh : LipschitzWith K f\nd : Real\nhd : LE.le 0 d\ns : Set X\n⊢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image f s)) (HMul.hMul (HPow.hPow (↑K) d) ((MeasureTheory.Measure.hausdorffMeasure d) s))","decl":"/-- If `f` is a `K`-Lipschitz map, then it increases the Hausdorff `d`-measures of sets at most\nby the factor of `K ^ d`. -/\ntheorem hausdorffMeasure_image_le (h : LipschitzWith K f) {d : ℝ} (hd : 0 ≤ d) (s : Set X) :\n    μH[d] (f '' s) ≤ (K : ℝ≥0∞) ^ d * μH[d] s :=\n  h.lipschitzOnWith.hausdorffMeasure_image_le hd\n\n"}
{"name":"MeasureTheory.Measure.hausdorffMeasure_smul₀","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"𝕜 : Type u_4\nE : Type u_5\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nd : Real\nhd : LE.le 0 d\nr : 𝕜\nhr : Ne r 0\ns : Set E\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (HSMul.hSMul r s)) (HSMul.hSMul (HPow.hPow (NNNorm.nnnorm r) d) ((MeasureTheory.Measure.hausdorffMeasure d) s))","decl":"theorem MeasureTheory.Measure.hausdorffMeasure_smul₀ {𝕜 E : Type*} [NormedAddCommGroup E]\n    [NormedField 𝕜] [NormedSpace 𝕜 E] [MeasurableSpace E] [BorelSpace E] {d : ℝ} (hd : 0 ≤ d)\n    {r : 𝕜} (hr : r ≠ 0) (s : Set E) : μH[d] (r • s) = ‖r‖₊ ^ d • μH[d] s := by\n  have {r : 𝕜} (s : Set E) : μH[d] (r • s) ≤ ‖r‖₊ ^ d • μH[d] s := by\n    simpa [ENNReal.coe_rpow_of_nonneg, hd]\n      using (lipschitzWith_smul r).hausdorffMeasure_image_le hd s\n  refine le_antisymm (this s) ?_\n  rw [← le_inv_smul_iff_of_pos]\n  · dsimp\n    rw [← NNReal.inv_rpow, ← nnnorm_inv]\n    · refine Eq.trans_le ?_ (this (r • s))\n      rw [inv_smul_smul₀ hr]\n  · simp [pos_iff_ne_zero, hr]\n\n"}
{"name":"AntilipschitzWith.hausdorffMeasure_preimage_le","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝⁵ : EMetricSpace X\ninst✝⁴ : EMetricSpace Y\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ninst✝¹ : MeasurableSpace Y\ninst✝ : BorelSpace Y\nf : X → Y\nK : NNReal\nd : Real\nhf : AntilipschitzWith K f\nhd : LE.le 0 d\ns : Set Y\n⊢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) (Set.preimage f s)) (HMul.hMul (HPow.hPow (↑K) d) ((MeasureTheory.Measure.hausdorffMeasure d) s))","decl":"theorem hausdorffMeasure_preimage_le (hf : AntilipschitzWith K f) (hd : 0 ≤ d) (s : Set Y) :\n    μH[d] (f ⁻¹' s) ≤ (K : ℝ≥0∞) ^ d * μH[d] s := by\n  rcases eq_or_ne K 0 with (rfl | h0)\n  · rcases eq_empty_or_nonempty (f ⁻¹' s) with (hs | ⟨x, hx⟩)\n    · simp only [hs, measure_empty, zero_le]\n    have : f ⁻¹' s = {x} := by\n      haveI : Subsingleton X := hf.subsingleton\n      have : (f ⁻¹' s).Subsingleton := subsingleton_univ.anti (subset_univ _)\n      exact (subsingleton_iff_singleton hx).1 this\n    rw [this]\n    rcases eq_or_lt_of_le hd with (rfl | h'd)\n    · simp only [ENNReal.rpow_zero, one_mul, mul_zero]\n      rw [hausdorffMeasure_zero_singleton]\n      exact one_le_hausdorffMeasure_zero_of_nonempty ⟨f x, hx⟩\n    · haveI := noAtoms_hausdorff X h'd\n      simp only [zero_le, measure_singleton]\n  have hKd0 : (K : ℝ≥0∞) ^ d ≠ 0 := by simp [h0]\n  have hKd : (K : ℝ≥0∞) ^ d ≠ ∞ := by simp [hd]\n  simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hKd0 hKd,\n    ← ENNReal.tsum_mul_left]\n  refine iSup₂_le fun ε ε0 => ?_\n  refine le_iSup₂_of_le (ε / K) (by simp [ε0.ne']) ?_\n  refine le_iInf₂ fun t hst => le_iInf fun htε => ?_\n  replace hst : f ⁻¹' s ⊆ _ := preimage_mono hst; rw [preimage_iUnion] at hst\n  refine iInf₂_le_of_le _ hst (iInf_le_of_le (fun n => ?_) ?_)\n  · exact (hf.ediam_preimage_le _).trans (ENNReal.mul_le_of_le_div' <| htε n)\n  · refine ENNReal.tsum_le_tsum fun n => iSup_le_iff.2 fun hft => ?_\n    simp only [nonempty_of_nonempty_preimage hft, ciSup_pos]\n    rw [← ENNReal.mul_rpow_of_nonneg _ _ hd]\n    exact ENNReal.rpow_le_rpow (hf.ediam_preimage_le _) hd\n\n"}
{"name":"AntilipschitzWith.le_hausdorffMeasure_image","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝⁵ : EMetricSpace X\ninst✝⁴ : EMetricSpace Y\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ninst✝¹ : MeasurableSpace Y\ninst✝ : BorelSpace Y\nf : X → Y\nK : NNReal\nd : Real\nhf : AntilipschitzWith K f\nhd : LE.le 0 d\ns : Set X\n⊢ LE.le ((MeasureTheory.Measure.hausdorffMeasure d) s) (HMul.hMul (HPow.hPow (↑K) d) ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image f s)))","decl":"theorem le_hausdorffMeasure_image (hf : AntilipschitzWith K f) (hd : 0 ≤ d) (s : Set X) :\n    μH[d] s ≤ (K : ℝ≥0∞) ^ d * μH[d] (f '' s) :=\n  calc\n    μH[d] s ≤ μH[d] (f ⁻¹' (f '' s)) := measure_mono (subset_preimage_image _ _)\n    _ ≤ (K : ℝ≥0∞) ^ d * μH[d] (f '' s) := hf.hausdorffMeasure_preimage_le hd (f '' s)\n\n"}
{"name":"Isometry.hausdorffMeasure_image","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝⁵ : EMetricSpace X\ninst✝⁴ : EMetricSpace Y\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ninst✝¹ : MeasurableSpace Y\ninst✝ : BorelSpace Y\nf : X → Y\nd : Real\nhf : Isometry f\nhd : Or (LE.le 0 d) (Function.Surjective f)\ns : Set X\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image f s)) ((MeasureTheory.Measure.hausdorffMeasure d) s)","decl":"theorem hausdorffMeasure_image (hf : Isometry f) (hd : 0 ≤ d ∨ Surjective f) (s : Set X) :\n    μH[d] (f '' s) = μH[d] s := by\n  simp only [hausdorffMeasure, ← OuterMeasure.coe_mkMetric, ← OuterMeasure.comap_apply]\n  rw [OuterMeasure.isometry_comap_mkMetric _ hf (hd.imp_left _)]\n  exact ENNReal.monotone_rpow_of_nonneg\n\n"}
{"name":"Isometry.hausdorffMeasure_preimage","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝⁵ : EMetricSpace X\ninst✝⁴ : EMetricSpace Y\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ninst✝¹ : MeasurableSpace Y\ninst✝ : BorelSpace Y\nf : X → Y\nd : Real\nhf : Isometry f\nhd : Or (LE.le 0 d) (Function.Surjective f)\ns : Set Y\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (Set.preimage f s)) ((MeasureTheory.Measure.hausdorffMeasure d) (Inter.inter s (Set.range f)))","decl":"theorem hausdorffMeasure_preimage (hf : Isometry f) (hd : 0 ≤ d ∨ Surjective f) (s : Set Y) :\n    μH[d] (f ⁻¹' s) = μH[d] (s ∩ range f) := by\n  rw [← hf.hausdorffMeasure_image hd, image_preimage_eq_inter_range]\n\n"}
{"name":"Isometry.map_hausdorffMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝⁵ : EMetricSpace X\ninst✝⁴ : EMetricSpace Y\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ninst✝¹ : MeasurableSpace Y\ninst✝ : BorelSpace Y\nf : X → Y\nd : Real\nhf : Isometry f\nhd : Or (LE.le 0 d) (Function.Surjective f)\n⊢ Eq (MeasureTheory.Measure.map f (MeasureTheory.Measure.hausdorffMeasure d)) ((MeasureTheory.Measure.hausdorffMeasure d).restrict (Set.range f))","decl":"theorem map_hausdorffMeasure (hf : Isometry f) (hd : 0 ≤ d ∨ Surjective f) :\n    Measure.map f μH[d] = μH[d].restrict (range f) := by\n  ext1 s hs\n  rw [map_apply hf.continuous.measurable hs, Measure.restrict_apply hs,\n    hf.hausdorffMeasure_preimage hd]\n\n"}
{"name":"IsometryEquiv.hausdorffMeasure_image","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝⁵ : EMetricSpace X\ninst✝⁴ : EMetricSpace Y\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ninst✝¹ : MeasurableSpace Y\ninst✝ : BorelSpace Y\ne : IsometryEquiv X Y\nd : Real\ns : Set X\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image (⇑e) s)) ((MeasureTheory.Measure.hausdorffMeasure d) s)","decl":"@[simp]\ntheorem hausdorffMeasure_image (e : X ≃ᵢ Y) (d : ℝ) (s : Set X) : μH[d] (e '' s) = μH[d] s :=\n  e.isometry.hausdorffMeasure_image (Or.inr e.surjective) s\n\n"}
{"name":"IsometryEquiv.hausdorffMeasure_preimage","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝⁵ : EMetricSpace X\ninst✝⁴ : EMetricSpace Y\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ninst✝¹ : MeasurableSpace Y\ninst✝ : BorelSpace Y\ne : IsometryEquiv X Y\nd : Real\ns : Set Y\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (Set.preimage (⇑e) s)) ((MeasureTheory.Measure.hausdorffMeasure d) s)","decl":"@[simp]\ntheorem hausdorffMeasure_preimage (e : X ≃ᵢ Y) (d : ℝ) (s : Set Y) : μH[d] (e ⁻¹' s) = μH[d] s := by\n  rw [← e.image_symm, e.symm.hausdorffMeasure_image]\n\n"}
{"name":"IsometryEquiv.map_hausdorffMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝⁵ : EMetricSpace X\ninst✝⁴ : EMetricSpace Y\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ninst✝¹ : MeasurableSpace Y\ninst✝ : BorelSpace Y\ne : IsometryEquiv X Y\nd : Real\n⊢ Eq (MeasureTheory.Measure.map (⇑e) (MeasureTheory.Measure.hausdorffMeasure d)) (MeasureTheory.Measure.hausdorffMeasure d)","decl":"@[simp]\ntheorem map_hausdorffMeasure (e : X ≃ᵢ Y) (d : ℝ) : Measure.map e μH[d] = μH[d] := by\n  rw [e.isometry.map_hausdorffMeasure (Or.inr e.surjective), e.surjective.range_eq, restrict_univ]\n\n"}
{"name":"IsometryEquiv.measurePreserving_hausdorffMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\nY : Type u_3\ninst✝⁵ : EMetricSpace X\ninst✝⁴ : EMetricSpace Y\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ninst✝¹ : MeasurableSpace Y\ninst✝ : BorelSpace Y\ne : IsometryEquiv X Y\nd : Real\n⊢ MeasureTheory.MeasurePreserving (⇑e) (MeasureTheory.Measure.hausdorffMeasure d) (MeasureTheory.Measure.hausdorffMeasure d)","decl":"theorem measurePreserving_hausdorffMeasure (e : X ≃ᵢ Y) (d : ℝ) : MeasurePreserving e μH[d] μH[d] :=\n  ⟨e.continuous.measurable, map_hausdorffMeasure _ _⟩\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_smul","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝⁴ : EMetricSpace X\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\nα : Type u_4\ninst✝¹ : SMul α X\ninst✝ : IsometricSMul α X\nd : Real\nc : α\nh : Or (LE.le 0 d) (Function.Surjective fun x => HSMul.hSMul c x)\ns : Set X\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (HSMul.hSMul c s)) ((MeasureTheory.Measure.hausdorffMeasure d) s)","decl":"@[to_additive]\ntheorem hausdorffMeasure_smul {α : Type*} [SMul α X] [IsometricSMul α X] {d : ℝ} (c : α)\n    (h : 0 ≤ d ∨ Surjective (c • · : X → X)) (s : Set X) : μH[d] (c • s) = μH[d] s :=\n  (isometry_smul X c).hausdorffMeasure_image h _\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_vadd","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝⁴ : EMetricSpace X\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\nα : Type u_4\ninst✝¹ : VAdd α X\ninst✝ : IsometricVAdd α X\nd : Real\nc : α\nh : Or (LE.le 0 d) (Function.Surjective fun x => HVAdd.hVAdd c x)\ns : Set X\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (HVAdd.hVAdd c s)) ((MeasureTheory.Measure.hausdorffMeasure d) s)","decl":"@[to_additive]\ntheorem hausdorffMeasure_smul {α : Type*} [SMul α X] [IsometricSMul α X] {d : ℝ} (c : α)\n    (h : 0 ≤ d ∨ Surjective (c • · : X → X)) (s : Set X) : μH[d] (c • s) = μH[d] s :=\n  (isometry_smul X c).hausdorffMeasure_image h _\n\n"}
{"name":"MeasureTheory.instIsMulLeftInvariantHausdorffMeasureOfIsometricSMul","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝⁴ : EMetricSpace X\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\nd : Real\ninst✝¹ : Group X\ninst✝ : IsometricSMul X X\n⊢ (MeasureTheory.Measure.hausdorffMeasure d).IsMulLeftInvariant","decl":"@[to_additive]\ninstance {d : ℝ} [Group X] [IsometricSMul X X] : IsMulLeftInvariant (μH[d] : Measure X) where\n  map_mul_left_eq_self x := (IsometryEquiv.constSMul x).map_hausdorffMeasure _\n\n"}
{"name":"MeasureTheory.instIsAddLeftInvariantHausdorffMeasureOfIsometricVAdd","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝⁴ : EMetricSpace X\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\nd : Real\ninst✝¹ : AddGroup X\ninst✝ : IsometricVAdd X X\n⊢ (MeasureTheory.Measure.hausdorffMeasure d).IsAddLeftInvariant","decl":"@[to_additive]\ninstance {d : ℝ} [Group X] [IsometricSMul X X] : IsMulLeftInvariant (μH[d] : Measure X) where\n  map_mul_left_eq_self x := (IsometryEquiv.constSMul x).map_hausdorffMeasure _\n\n"}
{"name":"MeasureTheory.instIsMulRightInvariantHausdorffMeasureOfIsometricSMulMulOpposite","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝⁴ : EMetricSpace X\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\nd : Real\ninst✝¹ : Group X\ninst✝ : IsometricSMul (MulOpposite X) X\n⊢ (MeasureTheory.Measure.hausdorffMeasure d).IsMulRightInvariant","decl":"@[to_additive]\ninstance {d : ℝ} [Group X] [IsometricSMul Xᵐᵒᵖ X] : IsMulRightInvariant (μH[d] : Measure X) where\n  map_mul_right_eq_self x := (IsometryEquiv.constSMul (MulOpposite.op x)).map_hausdorffMeasure _\n\n"}
{"name":"MeasureTheory.instIsAddRightInvariantHausdorffMeasureOfIsometricVAddAddOpposite","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"X : Type u_2\ninst✝⁴ : EMetricSpace X\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\nd : Real\ninst✝¹ : AddGroup X\ninst✝ : IsometricVAdd (AddOpposite X) X\n⊢ (MeasureTheory.Measure.hausdorffMeasure d).IsAddRightInvariant","decl":"@[to_additive]\ninstance {d : ℝ} [Group X] [IsometricSMul Xᵐᵒᵖ X] : IsMulRightInvariant (μH[d] : Measure X) where\n  map_mul_right_eq_self x := (IsometryEquiv.constSMul (MulOpposite.op x)).map_hausdorffMeasure _\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_pi_real","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"ι : Type u_4\ninst✝ : Fintype ι\n⊢ Eq (MeasureTheory.Measure.hausdorffMeasure ↑(Fintype.card ι)) MeasureTheory.MeasureSpace.volume","decl":"/-- In the space `ι → ℝ`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\n@[simp]\ntheorem hausdorffMeasure_pi_real {ι : Type*} [Fintype ι] :\n    (μH[Fintype.card ι] : Measure (ι → ℝ)) = volume := by\n  classical\n  -- it suffices to check that the two measures coincide on products of rational intervals\n  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)\n    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) ?_).symm\n  simp only [mem_iUnion, mem_singleton_iff]\n  -- fix such a product `s` of rational intervals, of the form `Π (a i, b i)`.\n  intro s hs\n  choose a b H using hs\n  obtain rfl : s = fun i => Ioo (α := ℝ) (a i) (b i) := funext fun i => (H i).2\n  replace H := fun i => (H i).1\n  apply le_antisymm _\n  -- first check that `volume s ≤ μH s`\n  · have Hle : volume ≤ (μH[Fintype.card ι] : Measure (ι → ℝ)) := by\n      refine le_hausdorffMeasure _ _ ∞ ENNReal.coe_lt_top fun s _ => ?_\n      rw [ENNReal.rpow_natCast]\n      exact Real.volume_pi_le_diam_pow s\n    rw [← volume_pi_pi fun i => Ioo (a i : ℝ) (b i)]\n    exact Measure.le_iff'.1 Hle _\n  /- For the other inequality `μH s ≤ volume s`, we use a covering of `s` by sets of small diameter\n    `1/n`, namely cubes with left-most point of the form `a i + f i / n` with `f i` ranging between\n    `0` and `⌈(b i - a i) * n⌉`. Their number is asymptotic to `n^d * Π (b i - a i)`. -/\n  have I : ∀ i, 0 ≤ (b i : ℝ) - a i := fun i => by\n    simpa only [sub_nonneg, Rat.cast_le] using (H i).le\n  let γ := fun n : ℕ => ∀ i : ι, Fin ⌈((b i : ℝ) - a i) * n⌉₊\n  let t : ∀ n : ℕ, γ n → Set (ι → ℝ) := fun n f =>\n    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)\n  have A : Tendsto (fun n : ℕ => 1 / (n : ℝ≥0∞)) atTop (𝓝 0) := by\n    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]\n  have B : ∀ᶠ n in atTop, ∀ i : γ n, diam (t n i) ≤ 1 / n := by\n    refine eventually_atTop.2 ⟨1, fun n hn => ?_⟩\n    intro f\n    refine diam_pi_le_of_le fun b => ?_\n    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,\n      add_sub_add_left_eq_sub, add_sub_cancel_left, ENNReal.ofReal_one, ENNReal.ofReal_natCast]\n  have C : ∀ᶠ n in atTop, (Set.pi univ fun i : ι => Ioo (a i : ℝ) (b i)) ⊆ ⋃ i : γ n, t n i := by\n    refine eventually_atTop.2 ⟨1, fun n hn => ?_⟩\n    have npos : (0 : ℝ) < n := Nat.cast_pos.2 hn\n    intro x hx\n    simp only [mem_Ioo, mem_univ_pi] at hx\n    simp only [t, mem_iUnion, mem_Ioo, mem_univ_pi]\n    let f : γ n := fun i =>\n      ⟨⌊(x i - a i) * n⌋₊, by\n        apply Nat.floor_lt_ceil_of_lt_of_pos\n        · refine (mul_lt_mul_right npos).2 ?_\n          simp only [(hx i).right, sub_lt_sub_iff_right]\n        · refine mul_pos ?_ npos\n          simpa only [Rat.cast_lt, sub_pos] using H i⟩\n    refine ⟨f, fun i => ⟨?_, ?_⟩⟩\n    · calc\n        (a i : ℝ) + ⌊(x i - a i) * n⌋₊ / n ≤ (a i : ℝ) + (x i - a i) * n / n := by\n          gcongr\n          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)\n        _ = x i := by field_simp [npos.ne']\n    · calc\n        x i = (a i : ℝ) + (x i - a i) * n / n := by field_simp [npos.ne']\n        _ ≤ (a i : ℝ) + (⌊(x i - a i) * n⌋₊ + 1) / n := by\n          gcongr\n          exact (Nat.lt_floor_add_one _).le\n  calc\n    μH[Fintype.card ι] (Set.pi univ fun i : ι => Ioo (a i : ℝ) (b i)) ≤\n        liminf (fun n : ℕ => ∑ i : γ n, diam (t n i) ^ ((Fintype.card ι) : ℝ)) atTop :=\n      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ℝ) (b i))\n        (fun n : ℕ => 1 / (n : ℝ≥0∞)) A t B C\n    _ ≤ liminf (fun n : ℕ => ∑ i : γ n, (1 / (n : ℝ≥0∞)) ^ Fintype.card ι) atTop := by\n      refine liminf_le_liminf ?_ ?_\n      · filter_upwards [B] with _ hn\n        apply Finset.sum_le_sum fun i _ => _\n        simp only [ENNReal.rpow_natCast]\n        intros i _\n        exact pow_le_pow_left' (hn i) _\n      · isBoundedDefault\n    _ = liminf (fun n : ℕ => ∏ i : ι, (⌈((b i : ℝ) - a i) * n⌉₊ : ℝ≥0∞) / n) atTop := by\n      simp only [γ, Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,\n        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]\n    _ = ∏ i : ι, volume (Ioo (a i : ℝ) (b i)) := by\n      simp only [Real.volume_Ioo]\n      apply Tendsto.liminf_eq\n      refine ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => ?_) fun i _ => ?_\n      · apply\n          Tendsto.congr' _\n            ((ENNReal.continuous_ofReal.tendsto _).comp\n              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_natCast_atTop_atTop))\n        apply eventually_atTop.2 ⟨1, fun n hn => _⟩\n        intros n hn\n        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,\n          ENNReal.ofReal_natCast]\n      · simp only [ENNReal.ofReal_ne_top, Ne, not_false_iff]\n\n"}
{"name":"MeasureTheory.isAddHaarMeasure_hausdorffMeasure","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"E : Type u_4\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\n⊢ (MeasureTheory.Measure.hausdorffMeasure ↑(Module.finrank Real E)).IsAddHaarMeasure","decl":"instance isAddHaarMeasure_hausdorffMeasure {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace ℝ E] [FiniteDimensional ℝ E]\n    [MeasurableSpace E] [BorelSpace E] :\n    IsAddHaarMeasure (G := E) μH[finrank ℝ E] where\n  lt_top_of_isCompact K hK := by\n    set e : E ≃L[ℝ] Fin (finrank ℝ E) → ℝ := ContinuousLinearEquiv.ofFinrankEq (by simp)\n    suffices μH[finrank ℝ E] (e '' K) < ⊤ by\n      rw [← e.symm_image_image K]\n      apply lt_of_le_of_lt <| e.symm.lipschitz.hausdorffMeasure_image_le (by simp) (e '' K)\n      rw [ENNReal.rpow_natCast]\n      exact ENNReal.mul_lt_top (ENNReal.pow_lt_top ENNReal.coe_lt_top _) this\n    conv_lhs => congr; congr; rw [← Fintype.card_fin (finrank ℝ E)]\n    rw [hausdorffMeasure_pi_real]\n    exact (hK.image e.continuous).measure_lt_top\n  open_pos U hU hU' := by\n    set e : E ≃L[ℝ] Fin (finrank ℝ E) → ℝ := ContinuousLinearEquiv.ofFinrankEq (by simp)\n    suffices 0 < μH[finrank ℝ E] (e '' U) from\n      (ENNReal.mul_pos_iff.mp (lt_of_lt_of_le this <|\n        e.lipschitz.hausdorffMeasure_image_le (by simp) _)).2.ne'\n    conv_rhs => congr; congr; rw [← Fintype.card_fin (finrank ℝ E)]\n    rw [hausdorffMeasure_pi_real]\n    apply (e.isOpenMap U hU).measure_pos (μ := volume)\n    simpa\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_measurePreserving_funUnique","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝⁴ : EMetricSpace X\ninst✝³ : MeasurableSpace X\ninst✝² : BorelSpace X\ninst✝¹ : Unique ι\ninst✝ : SecondCountableTopology X\nd : Real\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.funUnique ι X)) (MeasureTheory.Measure.hausdorffMeasure d) (MeasureTheory.Measure.hausdorffMeasure d)","decl":"theorem hausdorffMeasure_measurePreserving_funUnique [Unique ι]\n    [SecondCountableTopology X] (d : ℝ) :\n    MeasurePreserving (MeasurableEquiv.funUnique ι X) μH[d] μH[d] :=\n  (IsometryEquiv.funUnique ι X).measurePreserving_hausdorffMeasure _\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_measurePreserving_piFinTwo","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"α : Fin 2 → Type u_4\ninst✝³ : (i : Fin 2) → MeasurableSpace (α i)\ninst✝² : (i : Fin 2) → EMetricSpace (α i)\ninst✝¹ : ∀ (i : Fin 2), BorelSpace (α i)\ninst✝ : ∀ (i : Fin 2), SecondCountableTopology (α i)\nd : Real\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.piFinTwo α)) (MeasureTheory.Measure.hausdorffMeasure d) (MeasureTheory.Measure.hausdorffMeasure d)","decl":"theorem hausdorffMeasure_measurePreserving_piFinTwo (α : Fin 2 → Type*)\n    [∀ i, MeasurableSpace (α i)] [∀ i, EMetricSpace (α i)] [∀ i, BorelSpace (α i)]\n    [∀ i, SecondCountableTopology (α i)] (d : ℝ) :\n    MeasurePreserving (MeasurableEquiv.piFinTwo α) μH[d] μH[d] :=\n  (IsometryEquiv.piFinTwo α).measurePreserving_hausdorffMeasure _\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_real","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"⊢ Eq (MeasureTheory.Measure.hausdorffMeasure 1) MeasureTheory.MeasureSpace.volume","decl":"/-- In the space `ℝ`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\n@[simp]\ntheorem hausdorffMeasure_real : (μH[1] : Measure ℝ) = volume := by\n  rw [← (volume_preserving_funUnique Unit ℝ).map_eq,\n    ← (hausdorffMeasure_measurePreserving_funUnique Unit ℝ 1).map_eq,\n    ← hausdorffMeasure_pi_real, Fintype.card_unit, Nat.cast_one]\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_prod_real","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"⊢ Eq (MeasureTheory.Measure.hausdorffMeasure 2) MeasureTheory.MeasureSpace.volume","decl":"/-- In the space `ℝ × ℝ`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\n@[simp]\ntheorem hausdorffMeasure_prod_real : (μH[2] : Measure (ℝ × ℝ)) = volume := by\n  rw [← (volume_preserving_piFinTwo fun _ => ℝ).map_eq,\n    ← (hausdorffMeasure_measurePreserving_piFinTwo (fun _ => ℝ) _).map_eq,\n    ← hausdorffMeasure_pi_real, Fintype.card_fin, Nat.cast_two]\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_smul_right_image","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"E : Type u_5\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nv : E\ns : Set Real\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure 1) (Set.image (fun r => HSMul.hSMul r v) s)) (HSMul.hSMul (NNNorm.nnnorm v) ((MeasureTheory.Measure.hausdorffMeasure 1) s))","decl":"theorem hausdorffMeasure_smul_right_image [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [MeasurableSpace E] [BorelSpace E] (v : E) (s : Set ℝ) :\n    μH[1] ((fun r => r • v) '' s) = ‖v‖₊ • μH[1] s := by\n  obtain rfl | hv := eq_or_ne v 0\n  · haveI := noAtoms_hausdorff E one_pos\n    obtain rfl | hs := s.eq_empty_or_nonempty\n    · simp\n    simp [hs]\n  have hn : ‖v‖ ≠ 0 := norm_ne_zero_iff.mpr hv\n  -- break lineMap into pieces\n  suffices\n      μH[1] ((‖v‖ • ·) '' (LinearMap.toSpanSingleton ℝ E (‖v‖⁻¹ • v) '' s)) = ‖v‖₊ • μH[1] s by\n    simpa only [Set.image_image, smul_comm (norm _), inv_smul_smul₀ hn,\n      LinearMap.toSpanSingleton_apply] using this\n  have iso_smul : Isometry (LinearMap.toSpanSingleton ℝ E (‖v‖⁻¹ • v)) := by\n    refine AddMonoidHomClass.isometry_of_norm _ fun x => (norm_smul _ _).trans ?_\n    rw [norm_smul, norm_inv, norm_norm, inv_mul_cancel₀ hn, mul_one, LinearMap.id_apply]\n  rw [Set.image_smul, Measure.hausdorffMeasure_smul₀ zero_le_one hn, nnnorm_norm,\n      NNReal.rpow_one, iso_smul.hausdorffMeasure_image (Or.inl <| zero_le_one' ℝ)]\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_homothety_image","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"𝕜 : Type u_4\nE : Type u_5\nP : Type u_6\ninst✝⁶ : NormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : MeasurableSpace P\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor E P\ninst✝ : BorelSpace P\nd : Real\nhd : LE.le 0 d\nx : P\nc : 𝕜\nhc : Ne c 0\ns : Set P\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (Set.image (⇑(AffineMap.homothety x c)) s)) (HSMul.hSMul (HPow.hPow (NNNorm.nnnorm c) d) ((MeasureTheory.Measure.hausdorffMeasure d) s))","decl":"/-- Scaling by `c` around `x` scales the measure by `‖c‖₊ ^ d`. -/\ntheorem hausdorffMeasure_homothety_image {d : ℝ} (hd : 0 ≤ d) (x : P) {c : 𝕜} (hc : c ≠ 0)\n    (s : Set P) : μH[d] (AffineMap.homothety x c '' s) = ‖c‖₊ ^ d • μH[d] s := by\n  suffices\n    μH[d] (IsometryEquiv.vaddConst x '' ((c • ·) '' ((IsometryEquiv.vaddConst x).symm '' s))) =\n      ‖c‖₊ ^ d • μH[d] s by\n    simpa only [Set.image_image]\n  borelize E\n  rw [IsometryEquiv.hausdorffMeasure_image, Set.image_smul, Measure.hausdorffMeasure_smul₀ hd hc,\n    IsometryEquiv.hausdorffMeasure_image]\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_homothety_preimage","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"𝕜 : Type u_4\nE : Type u_5\nP : Type u_6\ninst✝⁶ : NormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : MeasurableSpace P\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor E P\ninst✝ : BorelSpace P\nd : Real\nhd : LE.le 0 d\nx : P\nc : 𝕜\nhc : Ne c 0\ns : Set P\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure d) (Set.preimage (⇑(AffineMap.homothety x c)) s)) (HSMul.hSMul (HPow.hPow (Inv.inv (NNNorm.nnnorm c)) d) ((MeasureTheory.Measure.hausdorffMeasure d) s))","decl":"theorem hausdorffMeasure_homothety_preimage {d : ℝ} (hd : 0 ≤ d) (x : P) {c : 𝕜} (hc : c ≠ 0)\n    (s : Set P) : μH[d] (AffineMap.homothety x c ⁻¹' s) = ‖c‖₊⁻¹ ^ d • μH[d] s := by\n  change μH[d] (AffineEquiv.homothetyUnitsMulHom x (Units.mk0 c hc) ⁻¹' s) = _\n  rw [← AffineEquiv.image_symm, AffineEquiv.coe_homothetyUnitsMulHom_apply_symm,\n    hausdorffMeasure_homothety_image hd x (_ : 𝕜ˣ).isUnit.ne_zero, Units.val_inv_eq_inv_val,\n    Units.val_mk0, nnnorm_inv]\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_lineMap_image","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"E : Type u_5\nP : Type u_6\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace P\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor E P\ninst✝ : BorelSpace P\nx y : P\ns : Set Real\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure 1) (Set.image (⇑(AffineMap.lineMap x y)) s)) (HSMul.hSMul (NNDist.nndist x y) ((MeasureTheory.Measure.hausdorffMeasure 1) s))","decl":"/-- Mapping a set of reals along a line segment scales the measure by the length of a segment.\n\nThis is an auxiliary result used to prove `hausdorffMeasure_affineSegment`. -/\ntheorem hausdorffMeasure_lineMap_image (x y : P) (s : Set ℝ) :\n    μH[1] (AffineMap.lineMap x y '' s) = nndist x y • μH[1] s := by\n  suffices μH[1] (IsometryEquiv.vaddConst x '' ((· • (y -ᵥ x)) '' s)) = nndist x y • μH[1] s by\n    simpa only [Set.image_image]\n  borelize E\n  rw [IsometryEquiv.hausdorffMeasure_image, hausdorffMeasure_smul_right_image,\n    nndist_eq_nnnorm_vsub' E]\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_affineSegment","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"E : Type u_5\nP : Type u_6\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace P\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor E P\ninst✝ : BorelSpace P\nx y : P\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure 1) (affineSegment Real x y)) (EDist.edist x y)","decl":"/-- The measure of a segment is the distance between its endpoints. -/\n@[simp]\ntheorem hausdorffMeasure_affineSegment (x y : P) : μH[1] (affineSegment ℝ x y) = edist x y := by\n  rw [affineSegment, hausdorffMeasure_lineMap_image, hausdorffMeasure_real, Real.volume_Icc,\n    sub_zero, ENNReal.ofReal_one, ← Algebra.algebraMap_eq_smul_one]\n  exact (edist_nndist _ _).symm\n\n"}
{"name":"MeasureTheory.hausdorffMeasure_segment","module":"Mathlib.MeasureTheory.Measure.Hausdorff","initialProofState":"E : Type u_7\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nx y : E\n⊢ Eq ((MeasureTheory.Measure.hausdorffMeasure 1) (segment Real x y)) (EDist.edist x y)","decl":"/-- The measure of a segment is the distance between its endpoints. -/\n@[simp]\ntheorem hausdorffMeasure_segment {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [MeasurableSpace E] [BorelSpace E] (x y : E) : μH[1] (segment ℝ x y) = edist x y := by\n  rw [← affineSegment_eq_segment, hausdorffMeasure_affineSegment]\n\n"}
