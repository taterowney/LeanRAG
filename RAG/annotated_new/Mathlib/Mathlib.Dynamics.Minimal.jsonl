{"name":"AddAction.IsMinimal.dense_orbit","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝² : AddMonoid M\ninst✝¹ : TopologicalSpace α\ninst✝ : AddAction M α\nself : AddAction.IsMinimal M α\nx : α\n⊢ Dense (AddAction.orbit M x)","decl":"/-- An action of an additive monoid `M` on a topological space is called *minimal* if the `M`-orbit\nof every point `x : α` is dense. -/\nclass AddAction.IsMinimal (M α : Type*) [AddMonoid M] [TopologicalSpace α] [AddAction M α] :\n    Prop where\n  dense_orbit : ∀ x : α, Dense (AddAction.orbit M x)\n\n"}
{"name":"MulAction.IsMinimal.dense_orbit","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝² : Monoid M\ninst✝¹ : TopologicalSpace α\ninst✝ : MulAction M α\nself : MulAction.IsMinimal M α\nx : α\n⊢ Dense (MulAction.orbit M x)","decl":"/-- An action of a monoid `M` on a topological space is called *minimal* if the `M`-orbit of every\npoint `x : α` is dense. -/\n@[to_additive]\nclass MulAction.IsMinimal (M α : Type*) [Monoid M] [TopologicalSpace α] [MulAction M α] :\n    Prop where\n  dense_orbit : ∀ x : α, Dense (MulAction.orbit M x)\n\n"}
{"name":"MulAction.dense_orbit","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : Monoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction M α\ninst✝ : MulAction.IsMinimal M α\nx : α\n⊢ Dense (MulAction.orbit M x)","decl":"@[to_additive]\ntheorem MulAction.dense_orbit [IsMinimal M α] (x : α) : Dense (orbit M x) :=\n  MulAction.IsMinimal.dense_orbit x\n\n"}
{"name":"AddAction.dense_orbit","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : AddAction M α\ninst✝ : AddAction.IsMinimal M α\nx : α\n⊢ Dense (AddAction.orbit M x)","decl":"@[to_additive]\ntheorem MulAction.dense_orbit [IsMinimal M α] (x : α) : Dense (orbit M x) :=\n  MulAction.IsMinimal.dense_orbit x\n\n"}
{"name":"denseRange_smul","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : Monoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction M α\ninst✝ : MulAction.IsMinimal M α\nx : α\n⊢ DenseRange fun c => HSMul.hSMul c x","decl":"@[to_additive]\ntheorem denseRange_smul [IsMinimal M α] (x : α) : DenseRange fun c : M ↦ c • x :=\n  MulAction.dense_orbit M x\n\n"}
{"name":"denseRange_vadd","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : AddAction M α\ninst✝ : AddAction.IsMinimal M α\nx : α\n⊢ DenseRange fun c => HVAdd.hVAdd c x","decl":"@[to_additive]\ntheorem denseRange_smul [IsMinimal M α] (x : α) : DenseRange fun c : M ↦ c • x :=\n  MulAction.dense_orbit M x\n\n"}
{"name":"AddAction.isMinimal_of_pretransitive","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : AddAction M α\ninst✝ : AddAction.IsPretransitive M α\n⊢ AddAction.IsMinimal M α","decl":"@[to_additive]\ninstance (priority := 100) MulAction.isMinimal_of_pretransitive [IsPretransitive M α] :\n    IsMinimal M α :=\n  ⟨fun x ↦ (surjective_smul M x).denseRange⟩\n\n"}
{"name":"MulAction.isMinimal_of_pretransitive","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : Monoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction M α\ninst✝ : MulAction.IsPretransitive M α\n⊢ MulAction.IsMinimal M α","decl":"@[to_additive]\ninstance (priority := 100) MulAction.isMinimal_of_pretransitive [IsPretransitive M α] :\n    IsMinimal M α :=\n  ⟨fun x ↦ (surjective_smul M x).denseRange⟩\n\n"}
{"name":"IsOpen.exists_vadd_mem","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : AddAction M α\ninst✝ : AddAction.IsMinimal M α\nx : α\nU : Set α\nhUo : IsOpen U\nhne : U.Nonempty\n⊢ Exists fun c => Membership.mem U (HVAdd.hVAdd c x)","decl":"@[to_additive]\ntheorem IsOpen.exists_smul_mem [IsMinimal M α] (x : α) {U : Set α} (hUo : IsOpen U)\n    (hne : U.Nonempty) : ∃ c : M, c • x ∈ U :=\n  (denseRange_smul M x).exists_mem_open hUo hne\n\n"}
{"name":"IsOpen.exists_smul_mem","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : Monoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction M α\ninst✝ : MulAction.IsMinimal M α\nx : α\nU : Set α\nhUo : IsOpen U\nhne : U.Nonempty\n⊢ Exists fun c => Membership.mem U (HSMul.hSMul c x)","decl":"@[to_additive]\ntheorem IsOpen.exists_smul_mem [IsMinimal M α] (x : α) {U : Set α} (hUo : IsOpen U)\n    (hne : U.Nonempty) : ∃ c : M, c • x ∈ U :=\n  (denseRange_smul M x).exists_mem_open hUo hne\n\n"}
{"name":"IsOpen.iUnion_preimage_smul","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : Monoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction M α\ninst✝ : MulAction.IsMinimal M α\nU : Set α\nhUo : IsOpen U\nhne : U.Nonempty\n⊢ Eq (Set.iUnion fun c => Set.preimage (fun x => HSMul.hSMul c x) U) Set.univ","decl":"@[to_additive]\ntheorem IsOpen.iUnion_preimage_smul [IsMinimal M α] {U : Set α} (hUo : IsOpen U)\n    (hne : U.Nonempty) : ⋃ c : M, (c • ·) ⁻¹' U = univ :=\n  iUnion_eq_univ_iff.2 fun x ↦ hUo.exists_smul_mem M x hne\n\n"}
{"name":"IsOpen.iUnion_preimage_vadd","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : AddAction M α\ninst✝ : AddAction.IsMinimal M α\nU : Set α\nhUo : IsOpen U\nhne : U.Nonempty\n⊢ Eq (Set.iUnion fun c => Set.preimage (fun x => HVAdd.hVAdd c x) U) Set.univ","decl":"@[to_additive]\ntheorem IsOpen.iUnion_preimage_smul [IsMinimal M α] {U : Set α} (hUo : IsOpen U)\n    (hne : U.Nonempty) : ⋃ c : M, (c • ·) ⁻¹' U = univ :=\n  iUnion_eq_univ_iff.2 fun x ↦ hUo.exists_smul_mem M x hne\n\n"}
{"name":"IsOpen.iUnion_vadd","module":"Mathlib.Dynamics.Minimal","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace α\ninst✝¹ : AddAction G α\ninst✝ : AddAction.IsMinimal G α\nU : Set α\nhUo : IsOpen U\nhne : U.Nonempty\n⊢ Eq (Set.iUnion fun g => HVAdd.hVAdd g U) Set.univ","decl":"@[to_additive]\ntheorem IsOpen.iUnion_smul [IsMinimal G α] {U : Set α} (hUo : IsOpen U) (hne : U.Nonempty) :\n    ⋃ g : G, g • U = univ :=\n  iUnion_eq_univ_iff.2 fun x ↦\n    let ⟨g, hg⟩ := hUo.exists_smul_mem G x hne\n    ⟨g⁻¹, _, hg, inv_smul_smul _ _⟩\n\n"}
{"name":"IsOpen.iUnion_smul","module":"Mathlib.Dynamics.Minimal","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝³ : Group G\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction G α\ninst✝ : MulAction.IsMinimal G α\nU : Set α\nhUo : IsOpen U\nhne : U.Nonempty\n⊢ Eq (Set.iUnion fun g => HSMul.hSMul g U) Set.univ","decl":"@[to_additive]\ntheorem IsOpen.iUnion_smul [IsMinimal G α] {U : Set α} (hUo : IsOpen U) (hne : U.Nonempty) :\n    ⋃ g : G, g • U = univ :=\n  iUnion_eq_univ_iff.2 fun x ↦\n    let ⟨g, hg⟩ := hUo.exists_smul_mem G x hne\n    ⟨g⁻¹, _, hg, inv_smul_smul _ _⟩\n\n"}
{"name":"IsCompact.exists_finite_cover_smul","module":"Mathlib.Dynamics.Minimal","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝⁴ : Group G\ninst✝³ : TopologicalSpace α\ninst✝² : MulAction G α\ninst✝¹ : MulAction.IsMinimal G α\ninst✝ : ContinuousConstSMul G α\nK U : Set α\nhK : IsCompact K\nhUo : IsOpen U\nhne : U.Nonempty\n⊢ Exists fun I => HasSubset.Subset K (Set.iUnion fun g => Set.iUnion fun h => HSMul.hSMul g U)","decl":"@[to_additive]\ntheorem IsCompact.exists_finite_cover_smul [IsMinimal G α] [ContinuousConstSMul G α]\n    {K U : Set α} (hK : IsCompact K) (hUo : IsOpen U) (hne : U.Nonempty) :\n    ∃ I : Finset G, K ⊆ ⋃ g ∈ I, g • U :=\n  (hK.elim_finite_subcover (fun g ↦ g • U) fun _ ↦ hUo.smul _) <| calc\n    K ⊆ univ := subset_univ K\n    _ = ⋃ g : G, g • U := (hUo.iUnion_smul G hne).symm\n\n"}
{"name":"IsCompact.exists_finite_cover_vadd","module":"Mathlib.Dynamics.Minimal","initialProofState":"G : Type u_2\nα : Type u_3\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace α\ninst✝² : AddAction G α\ninst✝¹ : AddAction.IsMinimal G α\ninst✝ : ContinuousConstVAdd G α\nK U : Set α\nhK : IsCompact K\nhUo : IsOpen U\nhne : U.Nonempty\n⊢ Exists fun I => HasSubset.Subset K (Set.iUnion fun g => Set.iUnion fun h => HVAdd.hVAdd g U)","decl":"@[to_additive]\ntheorem IsCompact.exists_finite_cover_smul [IsMinimal G α] [ContinuousConstSMul G α]\n    {K U : Set α} (hK : IsCompact K) (hUo : IsOpen U) (hne : U.Nonempty) :\n    ∃ I : Finset G, K ⊆ ⋃ g ∈ I, g • U :=\n  (hK.elim_finite_subcover (fun g ↦ g • U) fun _ ↦ hUo.smul _) <| calc\n    K ⊆ univ := subset_univ K\n    _ = ⋃ g : G, g • U := (hUo.iUnion_smul G hne).symm\n\n"}
{"name":"dense_of_nonempty_vadd_invariant","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : AddAction M α\ninst✝ : AddAction.IsMinimal M α\ns : Set α\nhne : s.Nonempty\nhsmul : ∀ (c : M), HasSubset.Subset (HVAdd.hVAdd c s) s\n⊢ Dense s","decl":"@[to_additive]\ntheorem dense_of_nonempty_smul_invariant [IsMinimal M α] {s : Set α} (hne : s.Nonempty)\n    (hsmul : ∀ c : M, c • s ⊆ s) : Dense s :=\n  let ⟨x, hx⟩ := hne\n  (MulAction.dense_orbit M x).mono (range_subset_iff.2 fun c ↦ hsmul c ⟨x, hx, rfl⟩)\n\n"}
{"name":"dense_of_nonempty_smul_invariant","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : Monoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction M α\ninst✝ : MulAction.IsMinimal M α\ns : Set α\nhne : s.Nonempty\nhsmul : ∀ (c : M), HasSubset.Subset (HSMul.hSMul c s) s\n⊢ Dense s","decl":"@[to_additive]\ntheorem dense_of_nonempty_smul_invariant [IsMinimal M α] {s : Set α} (hne : s.Nonempty)\n    (hsmul : ∀ c : M, c • s ⊆ s) : Dense s :=\n  let ⟨x, hx⟩ := hne\n  (MulAction.dense_orbit M x).mono (range_subset_iff.2 fun c ↦ hsmul c ⟨x, hx, rfl⟩)\n\n"}
{"name":"eq_empty_or_univ_of_vadd_invariant_closed","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : AddAction M α\ninst✝ : AddAction.IsMinimal M α\ns : Set α\nhs : IsClosed s\nhsmul : ∀ (c : M), HasSubset.Subset (HVAdd.hVAdd c s) s\n⊢ Or (Eq s EmptyCollection.emptyCollection) (Eq s Set.univ)","decl":"@[to_additive]\ntheorem eq_empty_or_univ_of_smul_invariant_closed [IsMinimal M α] {s : Set α} (hs : IsClosed s)\n    (hsmul : ∀ c : M, c • s ⊆ s) : s = ∅ ∨ s = univ :=\n  s.eq_empty_or_nonempty.imp_right fun hne ↦\n    hs.closure_eq ▸ (dense_of_nonempty_smul_invariant M hne hsmul).closure_eq\n\n"}
{"name":"eq_empty_or_univ_of_smul_invariant_closed","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : Monoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction M α\ninst✝ : MulAction.IsMinimal M α\ns : Set α\nhs : IsClosed s\nhsmul : ∀ (c : M), HasSubset.Subset (HSMul.hSMul c s) s\n⊢ Or (Eq s EmptyCollection.emptyCollection) (Eq s Set.univ)","decl":"@[to_additive]\ntheorem eq_empty_or_univ_of_smul_invariant_closed [IsMinimal M α] {s : Set α} (hs : IsClosed s)\n    (hsmul : ∀ c : M, c • s ⊆ s) : s = ∅ ∨ s = univ :=\n  s.eq_empty_or_nonempty.imp_right fun hne ↦\n    hs.closure_eq ▸ (dense_of_nonempty_smul_invariant M hne hsmul).closure_eq\n\n"}
{"name":"isMinimal_iff_isClosed_smul_invariant","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : Monoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction M α\ninst✝ : ContinuousConstSMul M α\n⊢ Iff (MulAction.IsMinimal M α) (∀ (s : Set α), IsClosed s → (∀ (c : M), HasSubset.Subset (HSMul.hSMul c s) s) → Or (Eq s EmptyCollection.emptyCollection) (Eq s Set.univ))","decl":"@[to_additive]\ntheorem isMinimal_iff_isClosed_smul_invariant [ContinuousConstSMul M α] :\n    IsMinimal M α ↔ ∀ s : Set α, IsClosed s → (∀ c : M, c • s ⊆ s) → s = ∅ ∨ s = univ := by\n  constructor\n  · intro _ _\n    exact eq_empty_or_univ_of_smul_invariant_closed M\n  refine fun H ↦ ⟨fun _ ↦ dense_iff_closure_eq.2 <| (H _ ?_ ?_).resolve_left ?_⟩\n  exacts [isClosed_closure, fun _ ↦ smul_closure_orbit_subset _ _,\n    (orbit_nonempty _).closure.ne_empty]\n"}
{"name":"isMinimal_iff_isClosed_vadd_invariant","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : AddAction M α\ninst✝ : ContinuousConstVAdd M α\n⊢ Iff (AddAction.IsMinimal M α) (∀ (s : Set α), IsClosed s → (∀ (c : M), HasSubset.Subset (HVAdd.hVAdd c s) s) → Or (Eq s EmptyCollection.emptyCollection) (Eq s Set.univ))","decl":"@[to_additive]\ntheorem isMinimal_iff_isClosed_smul_invariant [ContinuousConstSMul M α] :\n    IsMinimal M α ↔ ∀ s : Set α, IsClosed s → (∀ c : M, c • s ⊆ s) → s = ∅ ∨ s = univ := by\n  constructor\n  · intro _ _\n    exact eq_empty_or_univ_of_smul_invariant_closed M\n  refine fun H ↦ ⟨fun _ ↦ dense_iff_closure_eq.2 <| (H _ ?_ ?_).resolve_left ?_⟩\n  exacts [isClosed_closure, fun _ ↦ smul_closure_orbit_subset _ _,\n    (orbit_nonempty _).closure.ne_empty]\n"}
{"name":"isMinimal_iff_closed_smul_invariant","module":"Mathlib.Dynamics.Minimal","initialProofState":"M : Type u_1\nα : Type u_3\ninst✝³ : Monoid M\ninst✝² : TopologicalSpace α\ninst✝¹ : MulAction M α\ninst✝ : ContinuousConstSMul M α\n⊢ Iff (MulAction.IsMinimal M α) (∀ (s : Set α), IsClosed s → (∀ (c : M), HasSubset.Subset (HSMul.hSMul c s) s) → Or (Eq s EmptyCollection.emptyCollection) (Eq s Set.univ))","decl":"@[deprecated (since := \"2024-11-19\")] alias\nisMinimal_iff_closed_smul_invariant := isMinimal_iff_isClosed_smul_invariant\n"}
