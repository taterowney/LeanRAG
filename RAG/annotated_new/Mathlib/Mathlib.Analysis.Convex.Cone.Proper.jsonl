{"name":"ProperCone.mk.injEq","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : OrderedSemiring 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\ntoSubmodule✝ : Submodule (Subtype fun c => LE.le 0 c) E\nisClosed'✝ : IsClosed toSubmodule✝.carrier\ntoSubmodule : Submodule (Subtype fun c => LE.le 0 c) E\nisClosed' : IsClosed toSubmodule.carrier\n⊢ Eq (Eq { toSubmodule := toSubmodule✝, isClosed' := isClosed'✝ } { toSubmodule := toSubmodule, isClosed' := isClosed' }) (Eq toSubmodule✝ toSubmodule)","decl":"/-- A proper cone is a pointed cone `K` that is closed. Proper cones have the nice property that\nthey are equal to their double dual, see `ProperCone.dual_dual`.\nThis makes them useful for defining cone programs and proving duality theorems. -/\nstructure ProperCone (𝕜 : Type*) (E : Type*) [OrderedSemiring 𝕜] [AddCommMonoid E]\n    [TopologicalSpace E] [Module 𝕜 E] extends Submodule {c : 𝕜 // 0 ≤ c} E where\n  isClosed' : IsClosed (carrier : Set E)\n\n"}
{"name":"ProperCone.mk.inj","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : OrderedSemiring 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\ntoSubmodule✝ : Submodule (Subtype fun c => LE.le 0 c) E\nisClosed'✝ : IsClosed toSubmodule✝.carrier\ntoSubmodule : Submodule (Subtype fun c => LE.le 0 c) E\nisClosed' : IsClosed toSubmodule.carrier\nx✝ : Eq { toSubmodule := toSubmodule✝, isClosed' := isClosed'✝ } { toSubmodule := toSubmodule, isClosed' := isClosed' }\n⊢ Eq toSubmodule✝ toSubmodule","decl":"/-- A proper cone is a pointed cone `K` that is closed. Proper cones have the nice property that\nthey are equal to their double dual, see `ProperCone.dual_dual`.\nThis makes them useful for defining cone programs and proving duality theorems. -/\nstructure ProperCone (𝕜 : Type*) (E : Type*) [OrderedSemiring 𝕜] [AddCommMonoid E]\n    [TopologicalSpace E] [Module 𝕜 E] extends Submodule {c : 𝕜 // 0 ≤ c} E where\n  isClosed' : IsClosed (carrier : Set E)\n\n"}
{"name":"ProperCone.mk.sizeOf_spec","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : OrderedSemiring 𝕜\ninst✝⁴ : AddCommMonoid E\ninst✝³ : TopologicalSpace E\ninst✝² : Module 𝕜 E\ninst✝¹ : SizeOf 𝕜\ninst✝ : SizeOf E\ntoSubmodule : Submodule (Subtype fun c => LE.le 0 c) E\nisClosed' : IsClosed toSubmodule.carrier\n⊢ Eq (SizeOf.sizeOf { toSubmodule := toSubmodule, isClosed' := isClosed' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toSubmodule)) (SizeOf.sizeOf isClosed'))","decl":"/-- A proper cone is a pointed cone `K` that is closed. Proper cones have the nice property that\nthey are equal to their double dual, see `ProperCone.dual_dual`.\nThis makes them useful for defining cone programs and proving duality theorems. -/\nstructure ProperCone (𝕜 : Type*) (E : Type*) [OrderedSemiring 𝕜] [AddCommMonoid E]\n    [TopologicalSpace E] [Module 𝕜 E] extends Submodule {c : 𝕜 // 0 ≤ c} E where\n  isClosed' : IsClosed (carrier : Set E)\n\n"}
{"name":"ProperCone.isClosed'","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : OrderedSemiring 𝕜\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nself : ProperCone 𝕜 E\n⊢ IsClosed self.carrier","decl":"/-- A proper cone is a pointed cone `K` that is closed. Proper cones have the nice property that\nthey are equal to their double dual, see `ProperCone.dual_dual`.\nThis makes them useful for defining cone programs and proving duality theorems. -/\nstructure ProperCone (𝕜 : Type*) (E : Type*) [OrderedSemiring 𝕜] [AddCommMonoid E]\n    [TopologicalSpace E] [Module 𝕜 E] extends Submodule {c : 𝕜 // 0 ≤ c} E where\n  isClosed' : IsClosed (carrier : Set E)\n\n"}
{"name":"ProperCone.toPointedCone_injective","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_1\ninst✝³ : OrderedSemiring 𝕜\nE : Type u_2\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\n⊢ Function.Injective ProperCone.toPointedCone","decl":"theorem toPointedCone_injective : Function.Injective ((↑) : ProperCone 𝕜 E → PointedCone 𝕜 E) :=\n  fun S T h => by cases S; cases T; congr\n\n-- TODO: add `ConvexConeClass` that extends `SetLike` and replace the below instance\n"}
{"name":"ProperCone.ext","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_1\ninst✝³ : OrderedSemiring 𝕜\nE : Type u_2\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nS T : ProperCone 𝕜 E\nh : ∀ (x : E), Iff (Membership.mem S x) (Membership.mem T x)\n⊢ Eq S T","decl":"@[ext]\ntheorem ext {S T : ProperCone 𝕜 E} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"ProperCone.ext_iff","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_1\ninst✝³ : OrderedSemiring 𝕜\nE : Type u_2\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nS T : ProperCone 𝕜 E\n⊢ Iff (Eq S T) (∀ (x : E), Iff (Membership.mem S x) (Membership.mem T x))","decl":"@[ext]\ntheorem ext {S T : ProperCone 𝕜 E} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"ProperCone.mem_coe","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_1\ninst✝³ : OrderedSemiring 𝕜\nE : Type u_2\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nx : E\nK : ProperCone 𝕜 E\n⊢ Iff (Membership.mem (↑K) x) (Membership.mem K x)","decl":"@[simp]\ntheorem mem_coe {x : E} {K : ProperCone 𝕜 E} : x ∈ (K : PointedCone 𝕜 E) ↔ x ∈ K :=\n  Iff.rfl\n\n"}
{"name":"ProperCone.nonempty","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_1\ninst✝³ : OrderedSemiring 𝕜\nE : Type u_2\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nK : ProperCone 𝕜 E\n⊢ (↑K).Nonempty","decl":"protected theorem nonempty (K : ProperCone 𝕜 E) : (K : Set E).Nonempty :=\n  ⟨0, by { simp_rw [SetLike.mem_coe, ← ProperCone.mem_coe, Submodule.zero_mem] }⟩\n\n"}
{"name":"ProperCone.isClosed","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_1\ninst✝³ : OrderedSemiring 𝕜\nE : Type u_2\ninst✝² : AddCommMonoid E\ninst✝¹ : TopologicalSpace E\ninst✝ : Module 𝕜 E\nK : ProperCone 𝕜 E\n⊢ IsClosed ↑K","decl":"protected theorem isClosed (K : ProperCone 𝕜 E) : IsClosed (K : Set E) :=\n  K.isClosed'\n\n"}
{"name":"ProperCone.mem_positive","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_2\nE : Type u_1\ninst✝⁵ : OrderedSemiring 𝕜\ninst✝⁴ : OrderedAddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : OrderedSMul 𝕜 E\ninst✝¹ : TopologicalSpace E\ninst✝ : OrderClosedTopology E\nx : E\n⊢ Iff (Membership.mem (ProperCone.positive 𝕜 E) x) (LE.le 0 x)","decl":"@[simp]\ntheorem mem_positive {x : E} : x ∈ positive 𝕜 E ↔ 0 ≤ x :=\n  Iff.rfl\n\n"}
{"name":"ProperCone.coe_positive","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_2\nE : Type u_1\ninst✝⁵ : OrderedSemiring 𝕜\ninst✝⁴ : OrderedAddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : OrderedSMul 𝕜 E\ninst✝¹ : TopologicalSpace E\ninst✝ : OrderClosedTopology E\n⊢ Eq (↑↑(ProperCone.positive 𝕜 E)) (ConvexCone.positive 𝕜 E)","decl":"@[simp]\ntheorem coe_positive : ↑(positive 𝕜 E) = ConvexCone.positive 𝕜 E :=\n  rfl\n\n"}
{"name":"ProperCone.mem_zero","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : OrderedSemiring 𝕜\nE : Type u_2\ninst✝³ : AddCommMonoid E\ninst✝² : TopologicalSpace E\ninst✝¹ : T1Space E\ninst✝ : Module 𝕜 E\nx : E\n⊢ Iff (Membership.mem 0 x) (Eq x 0)","decl":"@[simp]\ntheorem mem_zero (x : E) : x ∈ (0 : ProperCone 𝕜 E) ↔ x = 0 :=\n  Iff.rfl\n\n"}
{"name":"ProperCone.coe_zero","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : OrderedSemiring 𝕜\nE : Type u_2\ninst✝³ : AddCommMonoid E\ninst✝² : TopologicalSpace E\ninst✝¹ : T1Space E\ninst✝ : Module 𝕜 E\n⊢ Eq (↑↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ↑(0 : ProperCone 𝕜 E) = (0 : ConvexCone 𝕜 E) :=\n  rfl\n\n"}
{"name":"ProperCone.pointed_zero","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : OrderedSemiring 𝕜\nE : Type u_2\ninst✝³ : AddCommMonoid E\ninst✝² : TopologicalSpace E\ninst✝¹ : T1Space E\ninst✝ : Module 𝕜 E\n⊢ (↑↑0).Pointed","decl":"theorem pointed_zero : ((0 : ProperCone 𝕜 E) : ConvexCone 𝕜 E).Pointed := by\n  simp [ConvexCone.pointed_zero]\n\n"}
{"name":"ProperCone.pointed","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nK : ProperCone Real E\n⊢ (↑↑K).Pointed","decl":"protected theorem pointed (K : ProperCone ℝ E) : (K : ConvexCone ℝ E).Pointed :=\n  (K : ConvexCone ℝ E).pointed_of_nonempty_of_isClosed K.nonempty K.isClosed\n\n"}
{"name":"ProperCone.coe_map","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace Real E\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\nK : ProperCone Real E\n⊢ Eq (↑(ProperCone.map f K)) (PointedCone.map ↑f ↑K).closure","decl":"@[simp, norm_cast]\ntheorem coe_map (f : E →L[ℝ] F) (K : ProperCone ℝ E) :\n    ↑(K.map f) = (PointedCone.map (f : E →ₗ[ℝ] F) ↑K).closure :=\n  rfl\n\n"}
{"name":"ProperCone.mem_map","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace Real E\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\nK : ProperCone Real E\ny : F\n⊢ Iff (Membership.mem (ProperCone.map f K) y) (Membership.mem (PointedCone.map ↑f ↑K).closure y)","decl":"@[simp]\ntheorem mem_map {f : E →L[ℝ] F} {K : ProperCone ℝ E} {y : F} :\n    y ∈ K.map f ↔ y ∈ (PointedCone.map (f : E →ₗ[ℝ] F) ↑K).closure :=\n  Iff.rfl\n\n"}
{"name":"ProperCone.map_id","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nK : ProperCone Real E\n⊢ Eq (ProperCone.map (ContinuousLinearMap.id Real E) K) K","decl":"@[simp]\ntheorem map_id (K : ProperCone ℝ E) : K.map (ContinuousLinearMap.id ℝ E) = K :=\n  ProperCone.toPointedCone_injective <| by simpa using IsClosed.closure_eq K.isClosed\n\n"}
{"name":"ProperCone.coe_dual","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nK : ProperCone Real E\n⊢ Eq (↑↑K.dual) (↑K).innerDualCone","decl":"@[simp, norm_cast]\ntheorem coe_dual (K : ProperCone ℝ E) : K.dual = (K : Set E).innerDualCone :=\n  rfl\n\n"}
{"name":"ProperCone.mem_dual","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nK : ProperCone Real E\ny : E\n⊢ Iff (Membership.mem K.dual y) (∀ ⦃x : E⦄, Membership.mem K x → LE.le 0 (Inner.inner x y))","decl":"open scoped InnerProductSpace in\n@[simp]\ntheorem mem_dual {K : ProperCone ℝ E} {y : E} : y ∈ dual K ↔ ∀ ⦃x⦄, x ∈ K → 0 ≤ ⟪x, y⟫_ℝ := by\n  aesop\n\n"}
{"name":"ProperCone.coe_comap","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace Real E\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\nS : ProperCone Real F\n⊢ Eq (↑(ProperCone.comap f S)) (Set.preimage ⇑f ↑S)","decl":"@[simp]\ntheorem coe_comap (f : E →L[ℝ] F) (S : ProperCone ℝ F) : (S.comap f : Set E) = f ⁻¹' S :=\n  rfl\n\n"}
{"name":"ProperCone.comap_id","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nS : ConvexCone Real E\n⊢ Eq (ConvexCone.comap LinearMap.id S) S","decl":"@[simp]\ntheorem comap_id (S : ConvexCone ℝ E) : S.comap LinearMap.id = S :=\n  SetLike.coe_injective preimage_id\n\n"}
{"name":"ProperCone.comap_comap","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace Real E\nF : Type u_2\ninst✝³ : NormedAddCommGroup F\ninst✝² : InnerProductSpace Real F\nG : Type u_3\ninst✝¹ : NormedAddCommGroup G\ninst✝ : InnerProductSpace Real G\ng : ContinuousLinearMap (RingHom.id Real) F G\nf : ContinuousLinearMap (RingHom.id Real) E F\nS : ProperCone Real G\n⊢ Eq (ProperCone.comap f (ProperCone.comap g S)) (ProperCone.comap (g.comp f) S)","decl":"theorem comap_comap (g : F →L[ℝ] G) (f : E →L[ℝ] F) (S : ProperCone ℝ G) :\n    (S.comap g).comap f = S.comap (g.comp f) :=\n  SetLike.coe_injective <| by congr\n\n"}
{"name":"ProperCone.mem_comap","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace Real E\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\nS : ProperCone Real F\nx : E\n⊢ Iff (Membership.mem (ProperCone.comap f S) x) (Membership.mem S (f x))","decl":"@[simp]\ntheorem mem_comap {f : E →L[ℝ] F} {S : ProperCone ℝ F} {x : E} : x ∈ S.comap f ↔ f x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"ProperCone.dual_dual","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : CompleteSpace E\nK : ProperCone Real E\n⊢ Eq K.dual.dual K","decl":"/-- The dual of the dual of a proper cone is itself. -/\n@[simp]\ntheorem dual_dual (K : ProperCone ℝ E) : K.dual.dual = K :=\n  ProperCone.toPointedCone_injective <| PointedCone.toConvexCone_injective <|\n    (K : ConvexCone ℝ E).innerDualCone_of_innerDualCone_eq_self K.nonempty K.isClosed\n\n"}
{"name":"ProperCone.hyperplane_separation","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace Real E\ninst✝³ : CompleteSpace E\nF : Type u_2\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace Real F\ninst✝ : CompleteSpace F\nK : ProperCone Real E\nf : ContinuousLinearMap (RingHom.id Real) E F\nb : F\n⊢ Iff (Membership.mem (ProperCone.map f K) b) (∀ (y : F), Membership.mem K.dual ((ContinuousLinearMap.adjoint f) y) → LE.le 0 (Inner.inner y b))","decl":"/-- This is a relative version of\n`ConvexCone.hyperplane_separation_of_nonempty_of_isClosed_of_nmem`, which we recover by setting\n`f` to be the identity map. This is also a geometric interpretation of the Farkas' lemma\nstated using proper cones. -/\ntheorem hyperplane_separation (K : ProperCone ℝ E) {f : E →L[ℝ] F} {b : F} :\n    b ∈ K.map f ↔ ∀ y : F, adjoint f y ∈ K.dual → 0 ≤ ⟪y, b⟫_ℝ :=\n  Iff.intro\n    (by\n      -- suppose `b ∈ K.map f`\n      simp_rw [mem_map, PointedCone.mem_closure, PointedCone.coe_map, coe_coe,\n        mem_closure_iff_seq_limit, mem_image, SetLike.mem_coe, mem_coe, mem_dual,\n        adjoint_inner_right, forall_exists_index, and_imp]\n\n      -- there is a sequence `seq : ℕ → F` in the image of `f` that converges to `b`\n      rintro seq hmem htends y hinner\n      suffices h : ∀ n, 0 ≤ ⟪y, seq n⟫_ℝ from\n        ge_of_tendsto'\n          (Continuous.seqContinuous (Continuous.inner (@continuous_const _ _ _ _ y) continuous_id)\n            htends)\n          h\n      intro n\n      obtain ⟨_, h, hseq⟩ := hmem n\n      simpa only [← hseq, real_inner_comm] using hinner h)\n    (by\n      -- proof by contradiction\n      -- suppose `b ∉ K.map f`\n      intro h\n      contrapose! h\n\n      -- as `b ∉ K.map f`, there is a hyperplane `y` separating `b` from `K.map f`\n      let C := @PointedCone.toConvexCone ℝ F _ _ _ (K.map f)\n      obtain ⟨y, hxy, hyb⟩ :=\n        @ConvexCone.hyperplane_separation_of_nonempty_of_isClosed_of_nmem\n        _ _ _ _ C (K.map f).nonempty (K.map f).isClosed b h\n\n      -- the rest of the proof is a straightforward algebraic manipulation\n      refine ⟨y, ?_, hyb⟩\n      simp_rw [ProperCone.mem_dual, adjoint_inner_right]\n      intro x hxK\n      apply hxy (f x)\n      simp_rw [C, coe_map]\n      apply subset_closure\n      simp_rw [PointedCone.toConvexCone_map, ConvexCone.coe_map, coe_coe, mem_image,\n        SetLike.mem_coe]\n      exact ⟨x, hxK, rfl⟩)\n\n"}
{"name":"ProperCone.hyperplane_separation_of_nmem","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace Real E\ninst✝³ : CompleteSpace E\nF : Type u_2\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace Real F\ninst✝ : CompleteSpace F\nK : ProperCone Real E\nf : ContinuousLinearMap (RingHom.id Real) E F\nb : F\ndisj : Not (Membership.mem (ProperCone.map f K) b)\n⊢ Exists fun y => And (Membership.mem K.dual ((ContinuousLinearMap.adjoint f) y)) (LT.lt (Inner.inner y b) 0)","decl":"theorem hyperplane_separation_of_nmem (K : ProperCone ℝ E) {f : E →L[ℝ] F} {b : F}\n    (disj : b ∉ K.map f) : ∃ y : F, adjoint f y ∈ K.dual ∧ ⟪y, b⟫_ℝ < 0 := by\n  contrapose! disj; rwa [K.hyperplane_separation]\n\n"}
