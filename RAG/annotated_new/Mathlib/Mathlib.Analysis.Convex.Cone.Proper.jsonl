{"name":"ProperCone.mk.injEq","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : Module ğ•œ E\ntoSubmoduleâœ : Submodule (Subtype fun c => LE.le 0 c) E\nisClosed'âœ : IsClosed toSubmoduleâœ.carrier\ntoSubmodule : Submodule (Subtype fun c => LE.le 0 c) E\nisClosed' : IsClosed toSubmodule.carrier\nâŠ¢ Eq (Eq { toSubmodule := toSubmoduleâœ, isClosed' := isClosed'âœ } { toSubmodule := toSubmodule, isClosed' := isClosed' }) (Eq toSubmoduleâœ toSubmodule)","decl":"/-- A proper cone is a pointed cone `K` that is closed. Proper cones have the nice property that\nthey are equal to their double dual, see `ProperCone.dual_dual`.\nThis makes them useful for defining cone programs and proving duality theorems. -/\nstructure ProperCone (ğ•œ : Type*) (E : Type*) [OrderedSemiring ğ•œ] [AddCommMonoid E]\n    [TopologicalSpace E] [Module ğ•œ E] extends Submodule {c : ğ•œ // 0 â‰¤ c} E where\n  isClosed' : IsClosed (carrier : Set E)\n\n"}
{"name":"ProperCone.mk.inj","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : Module ğ•œ E\ntoSubmoduleâœ : Submodule (Subtype fun c => LE.le 0 c) E\nisClosed'âœ : IsClosed toSubmoduleâœ.carrier\ntoSubmodule : Submodule (Subtype fun c => LE.le 0 c) E\nisClosed' : IsClosed toSubmodule.carrier\nxâœ : Eq { toSubmodule := toSubmoduleâœ, isClosed' := isClosed'âœ } { toSubmodule := toSubmodule, isClosed' := isClosed' }\nâŠ¢ Eq toSubmoduleâœ toSubmodule","decl":"/-- A proper cone is a pointed cone `K` that is closed. Proper cones have the nice property that\nthey are equal to their double dual, see `ProperCone.dual_dual`.\nThis makes them useful for defining cone programs and proving duality theorems. -/\nstructure ProperCone (ğ•œ : Type*) (E : Type*) [OrderedSemiring ğ•œ] [AddCommMonoid E]\n    [TopologicalSpace E] [Module ğ•œ E] extends Submodule {c : ğ•œ // 0 â‰¤ c} E where\n  isClosed' : IsClosed (carrier : Set E)\n\n"}
{"name":"ProperCone.mk.sizeOf_spec","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : OrderedSemiring ğ•œ\ninstâœâ´ : AddCommMonoid E\ninstâœÂ³ : TopologicalSpace E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : SizeOf ğ•œ\ninstâœ : SizeOf E\ntoSubmodule : Submodule (Subtype fun c => LE.le 0 c) E\nisClosed' : IsClosed toSubmodule.carrier\nâŠ¢ Eq (SizeOf.sizeOf { toSubmodule := toSubmodule, isClosed' := isClosed' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toSubmodule)) (SizeOf.sizeOf isClosed'))","decl":"/-- A proper cone is a pointed cone `K` that is closed. Proper cones have the nice property that\nthey are equal to their double dual, see `ProperCone.dual_dual`.\nThis makes them useful for defining cone programs and proving duality theorems. -/\nstructure ProperCone (ğ•œ : Type*) (E : Type*) [OrderedSemiring ğ•œ] [AddCommMonoid E]\n    [TopologicalSpace E] [Module ğ•œ E] extends Submodule {c : ğ•œ // 0 â‰¤ c} E where\n  isClosed' : IsClosed (carrier : Set E)\n\n"}
{"name":"ProperCone.isClosed'","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : OrderedSemiring ğ•œ\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : Module ğ•œ E\nself : ProperCone ğ•œ E\nâŠ¢ IsClosed self.carrier","decl":"/-- A proper cone is a pointed cone `K` that is closed. Proper cones have the nice property that\nthey are equal to their double dual, see `ProperCone.dual_dual`.\nThis makes them useful for defining cone programs and proving duality theorems. -/\nstructure ProperCone (ğ•œ : Type*) (E : Type*) [OrderedSemiring ğ•œ] [AddCommMonoid E]\n    [TopologicalSpace E] [Module ğ•œ E] extends Submodule {c : ğ•œ // 0 â‰¤ c} E where\n  isClosed' : IsClosed (carrier : Set E)\n\n"}
{"name":"ProperCone.toPointedCone_injective","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : OrderedSemiring ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : Module ğ•œ E\nâŠ¢ Function.Injective ProperCone.toPointedCone","decl":"theorem toPointedCone_injective : Function.Injective ((â†‘) : ProperCone ğ•œ E â†’ PointedCone ğ•œ E) :=\n  fun S T h => by cases S; cases T; congr\n\n-- TODO: add `ConvexConeClass` that extends `SetLike` and replace the below instance\n"}
{"name":"ProperCone.ext","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : OrderedSemiring ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : Module ğ•œ E\nS T : ProperCone ğ•œ E\nh : âˆ€ (x : E), Iff (Membership.mem S x) (Membership.mem T x)\nâŠ¢ Eq S T","decl":"@[ext]\ntheorem ext {S T : ProperCone ğ•œ E} (h : âˆ€ x, x âˆˆ S â†” x âˆˆ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"ProperCone.ext_iff","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : OrderedSemiring ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : Module ğ•œ E\nS T : ProperCone ğ•œ E\nâŠ¢ Iff (Eq S T) (âˆ€ (x : E), Iff (Membership.mem S x) (Membership.mem T x))","decl":"@[ext]\ntheorem ext {S T : ProperCone ğ•œ E} (h : âˆ€ x, x âˆˆ S â†” x âˆˆ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"ProperCone.mem_coe","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : OrderedSemiring ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : Module ğ•œ E\nx : E\nK : ProperCone ğ•œ E\nâŠ¢ Iff (Membership.mem (â†‘K) x) (Membership.mem K x)","decl":"@[simp]\ntheorem mem_coe {x : E} {K : ProperCone ğ•œ E} : x âˆˆ (K : PointedCone ğ•œ E) â†” x âˆˆ K :=\n  Iff.rfl\n\n"}
{"name":"ProperCone.nonempty","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : OrderedSemiring ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : Module ğ•œ E\nK : ProperCone ğ•œ E\nâŠ¢ (â†‘K).Nonempty","decl":"protected theorem nonempty (K : ProperCone ğ•œ E) : (K : Set E).Nonempty :=\n  âŸ¨0, by { simp_rw [SetLike.mem_coe, â† ProperCone.mem_coe, Submodule.zero_mem] }âŸ©\n\n"}
{"name":"ProperCone.isClosed","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : OrderedSemiring ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : Module ğ•œ E\nK : ProperCone ğ•œ E\nâŠ¢ IsClosed â†‘K","decl":"protected theorem isClosed (K : ProperCone ğ•œ E) : IsClosed (K : Set E) :=\n  K.isClosed'\n\n"}
{"name":"ProperCone.mem_positive","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_2\nE : Type u_1\ninstâœâµ : OrderedSemiring ğ•œ\ninstâœâ´ : OrderedAddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : OrderedSMul ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : OrderClosedTopology E\nx : E\nâŠ¢ Iff (Membership.mem (ProperCone.positive ğ•œ E) x) (LE.le 0 x)","decl":"@[simp]\ntheorem mem_positive {x : E} : x âˆˆ positive ğ•œ E â†” 0 â‰¤ x :=\n  Iff.rfl\n\n"}
{"name":"ProperCone.coe_positive","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_2\nE : Type u_1\ninstâœâµ : OrderedSemiring ğ•œ\ninstâœâ´ : OrderedAddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : OrderedSMul ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : OrderClosedTopology E\nâŠ¢ Eq (â†‘â†‘(ProperCone.positive ğ•œ E)) (ConvexCone.positive ğ•œ E)","decl":"@[simp]\ntheorem coe_positive : â†‘(positive ğ•œ E) = ConvexCone.positive ğ•œ E :=\n  rfl\n\n"}
{"name":"ProperCone.mem_zero","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : OrderedSemiring ğ•œ\nE : Type u_2\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : T1Space E\ninstâœ : Module ğ•œ E\nx : E\nâŠ¢ Iff (Membership.mem 0 x) (Eq x 0)","decl":"@[simp]\ntheorem mem_zero (x : E) : x âˆˆ (0 : ProperCone ğ•œ E) â†” x = 0 :=\n  Iff.rfl\n\n"}
{"name":"ProperCone.coe_zero","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : OrderedSemiring ğ•œ\nE : Type u_2\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : T1Space E\ninstâœ : Module ğ•œ E\nâŠ¢ Eq (â†‘â†‘0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : â†‘(0 : ProperCone ğ•œ E) = (0 : ConvexCone ğ•œ E) :=\n  rfl\n\n"}
{"name":"ProperCone.pointed_zero","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : OrderedSemiring ğ•œ\nE : Type u_2\ninstâœÂ³ : AddCommMonoid E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : T1Space E\ninstâœ : Module ğ•œ E\nâŠ¢ (â†‘â†‘0).Pointed","decl":"theorem pointed_zero : ((0 : ProperCone ğ•œ E) : ConvexCone ğ•œ E).Pointed := by\n  simp [ConvexCone.pointed_zero]\n\n"}
{"name":"ProperCone.pointed","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nK : ProperCone Real E\nâŠ¢ (â†‘â†‘K).Pointed","decl":"protected theorem pointed (K : ProperCone â„ E) : (K : ConvexCone â„ E).Pointed :=\n  (K : ConvexCone â„ E).pointed_of_nonempty_of_isClosed K.nonempty K.isClosed\n\n"}
{"name":"ProperCone.coe_map","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace Real E\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\nK : ProperCone Real E\nâŠ¢ Eq (â†‘(ProperCone.map f K)) (PointedCone.map â†‘f â†‘K).closure","decl":"@[simp, norm_cast]\ntheorem coe_map (f : E â†’L[â„] F) (K : ProperCone â„ E) :\n    â†‘(K.map f) = (PointedCone.map (f : E â†’â‚—[â„] F) â†‘K).closure :=\n  rfl\n\n"}
{"name":"ProperCone.mem_map","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace Real E\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\nK : ProperCone Real E\ny : F\nâŠ¢ Iff (Membership.mem (ProperCone.map f K) y) (Membership.mem (PointedCone.map â†‘f â†‘K).closure y)","decl":"@[simp]\ntheorem mem_map {f : E â†’L[â„] F} {K : ProperCone â„ E} {y : F} :\n    y âˆˆ K.map f â†” y âˆˆ (PointedCone.map (f : E â†’â‚—[â„] F) â†‘K).closure :=\n  Iff.rfl\n\n"}
{"name":"ProperCone.map_id","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nK : ProperCone Real E\nâŠ¢ Eq (ProperCone.map (ContinuousLinearMap.id Real E) K) K","decl":"@[simp]\ntheorem map_id (K : ProperCone â„ E) : K.map (ContinuousLinearMap.id â„ E) = K :=\n  ProperCone.toPointedCone_injective <| by simpa using IsClosed.closure_eq K.isClosed\n\n"}
{"name":"ProperCone.coe_dual","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nK : ProperCone Real E\nâŠ¢ Eq (â†‘â†‘K.dual) (â†‘K).innerDualCone","decl":"@[simp, norm_cast]\ntheorem coe_dual (K : ProperCone â„ E) : K.dual = (K : Set E).innerDualCone :=\n  rfl\n\n"}
{"name":"ProperCone.mem_dual","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nK : ProperCone Real E\ny : E\nâŠ¢ Iff (Membership.mem K.dual y) (âˆ€ â¦ƒx : Eâ¦„, Membership.mem K x â†’ LE.le 0 (Inner.inner x y))","decl":"open scoped InnerProductSpace in\n@[simp]\ntheorem mem_dual {K : ProperCone â„ E} {y : E} : y âˆˆ dual K â†” âˆ€ â¦ƒxâ¦„, x âˆˆ K â†’ 0 â‰¤ âŸªx, yâŸ«_â„ := by\n  aesop\n\n"}
{"name":"ProperCone.coe_comap","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace Real E\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\nS : ProperCone Real F\nâŠ¢ Eq (â†‘(ProperCone.comap f S)) (Set.preimage â‡‘f â†‘S)","decl":"@[simp]\ntheorem coe_comap (f : E â†’L[â„] F) (S : ProperCone â„ F) : (S.comap f : Set E) = f â»Â¹' S :=\n  rfl\n\n"}
{"name":"ProperCone.comap_id","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nS : ConvexCone Real E\nâŠ¢ Eq (ConvexCone.comap LinearMap.id S) S","decl":"@[simp]\ntheorem comap_id (S : ConvexCone â„ E) : S.comap LinearMap.id = S :=\n  SetLike.coe_injective preimage_id\n\n"}
{"name":"ProperCone.comap_comap","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : InnerProductSpace Real E\nF : Type u_2\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : InnerProductSpace Real F\nG : Type u_3\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : InnerProductSpace Real G\ng : ContinuousLinearMap (RingHom.id Real) F G\nf : ContinuousLinearMap (RingHom.id Real) E F\nS : ProperCone Real G\nâŠ¢ Eq (ProperCone.comap f (ProperCone.comap g S)) (ProperCone.comap (g.comp f) S)","decl":"theorem comap_comap (g : F â†’L[â„] G) (f : E â†’L[â„] F) (S : ProperCone â„ G) :\n    (S.comap g).comap f = S.comap (g.comp f) :=\n  SetLike.coe_injective <| by congr\n\n"}
{"name":"ProperCone.mem_comap","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace Real E\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\nS : ProperCone Real F\nx : E\nâŠ¢ Iff (Membership.mem (ProperCone.comap f S) x) (Membership.mem S (f x))","decl":"@[simp]\ntheorem mem_comap {f : E â†’L[â„] F} {S : ProperCone â„ F} {x : E} : x âˆˆ S.comap f â†” f x âˆˆ S :=\n  Iff.rfl\n\n"}
{"name":"ProperCone.dual_dual","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace Real E\ninstâœ : CompleteSpace E\nK : ProperCone Real E\nâŠ¢ Eq K.dual.dual K","decl":"/-- The dual of the dual of a proper cone is itself. -/\n@[simp]\ntheorem dual_dual (K : ProperCone â„ E) : K.dual.dual = K :=\n  ProperCone.toPointedCone_injective <| PointedCone.toConvexCone_injective <|\n    (K : ConvexCone â„ E).innerDualCone_of_innerDualCone_eq_self K.nonempty K.isClosed\n\n"}
{"name":"ProperCone.hyperplane_separation","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : InnerProductSpace Real E\ninstâœÂ³ : CompleteSpace E\nF : Type u_2\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace Real F\ninstâœ : CompleteSpace F\nK : ProperCone Real E\nf : ContinuousLinearMap (RingHom.id Real) E F\nb : F\nâŠ¢ Iff (Membership.mem (ProperCone.map f K) b) (âˆ€ (y : F), Membership.mem K.dual ((ContinuousLinearMap.adjoint f) y) â†’ LE.le 0 (Inner.inner y b))","decl":"/-- This is a relative version of\n`ConvexCone.hyperplane_separation_of_nonempty_of_isClosed_of_nmem`, which we recover by setting\n`f` to be the identity map. This is also a geometric interpretation of the Farkas' lemma\nstated using proper cones. -/\ntheorem hyperplane_separation (K : ProperCone â„ E) {f : E â†’L[â„] F} {b : F} :\n    b âˆˆ K.map f â†” âˆ€ y : F, adjoint f y âˆˆ K.dual â†’ 0 â‰¤ âŸªy, bâŸ«_â„ :=\n  Iff.intro\n    (by\n      -- suppose `b âˆˆ K.map f`\n      simp_rw [mem_map, PointedCone.mem_closure, PointedCone.coe_map, coe_coe,\n        mem_closure_iff_seq_limit, mem_image, SetLike.mem_coe, mem_coe, mem_dual,\n        adjoint_inner_right, forall_exists_index, and_imp]\n\n      -- there is a sequence `seq : â„• â†’ F` in the image of `f` that converges to `b`\n      rintro seq hmem htends y hinner\n      suffices h : âˆ€ n, 0 â‰¤ âŸªy, seq nâŸ«_â„ from\n        ge_of_tendsto'\n          (Continuous.seqContinuous (Continuous.inner (@continuous_const _ _ _ _ y) continuous_id)\n            htends)\n          h\n      intro n\n      obtain âŸ¨_, h, hseqâŸ© := hmem n\n      simpa only [â† hseq, real_inner_comm] using hinner h)\n    (by\n      -- proof by contradiction\n      -- suppose `b âˆ‰ K.map f`\n      intro h\n      contrapose! h\n\n      -- as `b âˆ‰ K.map f`, there is a hyperplane `y` separating `b` from `K.map f`\n      let C := @PointedCone.toConvexCone â„ F _ _ _ (K.map f)\n      obtain âŸ¨y, hxy, hybâŸ© :=\n        @ConvexCone.hyperplane_separation_of_nonempty_of_isClosed_of_nmem\n        _ _ _ _ C (K.map f).nonempty (K.map f).isClosed b h\n\n      -- the rest of the proof is a straightforward algebraic manipulation\n      refine âŸ¨y, ?_, hybâŸ©\n      simp_rw [ProperCone.mem_dual, adjoint_inner_right]\n      intro x hxK\n      apply hxy (f x)\n      simp_rw [C, coe_map]\n      apply subset_closure\n      simp_rw [PointedCone.toConvexCone_map, ConvexCone.coe_map, coe_coe, mem_image,\n        SetLike.mem_coe]\n      exact âŸ¨x, hxK, rflâŸ©)\n\n"}
{"name":"ProperCone.hyperplane_separation_of_nmem","module":"Mathlib.Analysis.Convex.Cone.Proper","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : InnerProductSpace Real E\ninstâœÂ³ : CompleteSpace E\nF : Type u_2\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace Real F\ninstâœ : CompleteSpace F\nK : ProperCone Real E\nf : ContinuousLinearMap (RingHom.id Real) E F\nb : F\ndisj : Not (Membership.mem (ProperCone.map f K) b)\nâŠ¢ Exists fun y => And (Membership.mem K.dual ((ContinuousLinearMap.adjoint f) y)) (LT.lt (Inner.inner y b) 0)","decl":"theorem hyperplane_separation_of_nmem (K : ProperCone â„ E) {f : E â†’L[â„] F} {b : F}\n    (disj : b âˆ‰ K.map f) : âˆƒ y : F, adjoint f y âˆˆ K.dual âˆ§ âŸªy, bâŸ«_â„ < 0 := by\n  contrapose! disj; rwa [K.hyperplane_separation]\n\n"}
