{"name":"FreeAbelianGroup.lift.of","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddCommGroup β\nf : α → β\nx : α\n⊢ Eq ((FreeAbelianGroup.lift f) (FreeAbelianGroup.of x)) (f x)","decl":"@[simp]\nprotected theorem of (x : α) : lift f (of x) = f x := by\n  convert Abelianization.lift.of\n     (FreeGroup.lift f (β := Multiplicative β)) (FreeGroup.of x) using 1\n  exact (FreeGroup.lift.of (β := Multiplicative β)).symm\n\n"}
{"name":"FreeAbelianGroup.lift.unique","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddCommGroup β\nf : α → β\ng : AddMonoidHom (FreeAbelianGroup α) β\nhg : ∀ (x : α), Eq (g (FreeAbelianGroup.of x)) (f x)\nx : FreeAbelianGroup α\n⊢ Eq (g x) ((FreeAbelianGroup.lift f) x)","decl":"protected theorem unique (g : FreeAbelianGroup α →+ β) (hg : ∀ x, g (of x) = f x) {x} :\n    g x = lift f x :=\n  DFunLike.congr_fun (lift.symm_apply_eq.mp (funext hg : g ∘ of = f)) _\n\n"}
{"name":"FreeAbelianGroup.lift.ext","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddCommGroup β\ng h : AddMonoidHom (FreeAbelianGroup α) β\nH : ∀ (x : α), Eq (g (FreeAbelianGroup.of x)) (h (FreeAbelianGroup.of x))\n⊢ Eq g h","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\nprotected theorem ext (g h : FreeAbelianGroup α →+ β) (H : ∀ x, g (of x) = h (of x)) : g = h :=\n  lift.symm.injective <| funext H\n\n"}
{"name":"FreeAbelianGroup.lift.ext_iff","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddCommGroup β\ng h : AddMonoidHom (FreeAbelianGroup α) β\n⊢ Iff (Eq g h) (∀ (x : α), Eq (g (FreeAbelianGroup.of x)) (h (FreeAbelianGroup.of x)))","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\nprotected theorem ext (g h : FreeAbelianGroup α →+ β) (H : ∀ x, g (of x) = h (of x)) : g = h :=\n  lift.symm.injective <| funext H\n\n"}
{"name":"FreeAbelianGroup.lift.map_hom","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommGroup β\ninst✝ : AddCommGroup γ\na : FreeAbelianGroup α\nf : α → β\ng : AddMonoidHom β γ\n⊢ Eq (g ((FreeAbelianGroup.lift f) a)) ((FreeAbelianGroup.lift (Function.comp (⇑g) f)) a)","decl":"theorem map_hom {α β γ} [AddCommGroup β] [AddCommGroup γ] (a : FreeAbelianGroup α) (f : α → β)\n    (g : β →+ γ) : g (lift f a) = lift (g ∘ f) a := by\n  show (g.comp (lift f)) a = lift (g ∘ f) a\n  apply lift.unique\n  intro a\n  show g ((lift f) (of a)) = g (f a)\n  simp only [(· ∘ ·), lift.of]\n\n"}
{"name":"FreeAbelianGroup.of_injective","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\n⊢ Function.Injective FreeAbelianGroup.of","decl":"open scoped Classical in\ntheorem of_injective : Function.Injective (of : α → FreeAbelianGroup α) :=\n  fun x y hoxy ↦ Classical.by_contradiction fun hxy : x ≠ y ↦\n    let f : FreeAbelianGroup α →+ ℤ := lift fun z ↦ if x = z then (1 : ℤ) else 0\n    have hfx1 : f (of x) = 1 := (lift.of _ _).trans <| if_pos rfl\n    have hfy1 : f (of y) = 1 := hoxy ▸ hfx1\n    have hfy0 : f (of y) = 0 := (lift.of _ _).trans <| if_neg hxy\n    one_ne_zero <| hfy1.symm.trans hfy0\n\n"}
{"name":"FreeAbelianGroup.of_ne_zero","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nx : α\n⊢ Ne (FreeAbelianGroup.of x) 0","decl":"@[simp]\ntheorem of_ne_zero (x : α) : of x ≠ 0 := by\n  intro h\n  let f : FreeAbelianGroup α →+ ℤ := lift 1\n  have hfx : f (of x) = 1 := lift.of _ _\n  have hf0 : f (of x) = 0 := by rw [h, map_zero]\n  exact one_ne_zero <| hfx.symm.trans hf0\n\n"}
{"name":"FreeAbelianGroup.zero_ne_of","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nx : α\n⊢ Ne 0 (FreeAbelianGroup.of x)","decl":"@[simp]\ntheorem zero_ne_of (x : α) : 0 ≠ of x := of_ne_zero _ |>.symm\n\n"}
{"name":"FreeAbelianGroup.instNontrivialOfNonempty","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Nontrivial (FreeAbelianGroup α)","decl":"instance [Nonempty α] : Nontrivial (FreeAbelianGroup α) where\n  exists_pair_ne := let ⟨x⟩ := ‹Nonempty α›; ⟨0, of x, zero_ne_of _⟩\n\n"}
{"name":"FreeAbelianGroup.induction_on","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nC : FreeAbelianGroup α → Prop\nz : FreeAbelianGroup α\nC0 : C 0\nC1 : ∀ (x : α), C (FreeAbelianGroup.of x)\nCn : ∀ (x : α), C (FreeAbelianGroup.of x) → C (Neg.neg (FreeAbelianGroup.of x))\nCp : ∀ (x y : FreeAbelianGroup α), C x → C y → C (HAdd.hAdd x y)\n⊢ C z","decl":"@[elab_as_elim]\nprotected theorem induction_on {C : FreeAbelianGroup α → Prop} (z : FreeAbelianGroup α) (C0 : C 0)\n    (C1 : ∀ x, C <| of x) (Cn : ∀ x, C (of x) → C (-of x)) (Cp : ∀ x y, C x → C y → C (x + y)) :\n    C z :=\n  Quotient.inductionOn' z fun x ↦\n    Quot.inductionOn x fun L ↦\n      List.recOn L C0 fun ⟨x, b⟩ _ ih ↦ Bool.recOn b (Cp _ _ (Cn _ (C1 x)) ih) (Cp _ _ (C1 x) ih)\n\n"}
{"name":"FreeAbelianGroup.lift.add'","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : AddCommGroup β\na : FreeAbelianGroup α\nf g : α → β\n⊢ Eq ((FreeAbelianGroup.lift (HAdd.hAdd f g)) a) (HAdd.hAdd ((FreeAbelianGroup.lift f) a) ((FreeAbelianGroup.lift g) a))","decl":"theorem lift.add' {α β} [AddCommGroup β] (a : FreeAbelianGroup α) (f g : α → β) :\n    lift (f + g) a = lift f a + lift g a := by\n  refine FreeAbelianGroup.induction_on a ?_ ?_ ?_ ?_\n  · simp only [(lift _).map_zero, zero_add]\n  · intro x\n    simp only [lift.of, Pi.add_apply]\n  · intro x _\n    simp only [map_neg, lift.of, Pi.add_apply, neg_add]\n  · intro x y hx hy\n    simp only [(lift _).map_add, hx, hy, add_add_add_comm]\n\n"}
{"name":"FreeAbelianGroup.liftAddGroupHom_apply","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : AddCommGroup β\na : FreeAbelianGroup α\nf : α → β\n⊢ Eq ((FreeAbelianGroup.liftAddGroupHom β a) f) ((FreeAbelianGroup.lift f) a)","decl":"/-- If `g : FreeAbelianGroup X` and `A` is an abelian group then `liftAddGroupHom g`\nis the additive group homomorphism sending a function `X → A` to the term of type `A`\ncorresponding to the evaluation of the induced map `FreeAbelianGroup X → A` at `g`. -/\n@[simps!]\ndef liftAddGroupHom {α} (β) [AddCommGroup β] (a : FreeAbelianGroup α) : (α → β) →+ β :=\n  AddMonoidHom.mk' (fun f ↦ lift f a) (lift.add' a)\n\n"}
{"name":"FreeAbelianGroup.lift_neg'","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nβ : Type u_1\ninst✝ : AddCommGroup β\nf : α → β\n⊢ Eq (FreeAbelianGroup.lift (Neg.neg f)) (Neg.neg (FreeAbelianGroup.lift f))","decl":"theorem lift_neg' {β} [AddCommGroup β] (f : α → β) : lift (-f) = -lift f :=\n  AddMonoidHom.ext fun _ ↦ (liftAddGroupHom _ _ : (α → β) →+ β).map_neg _\n\n"}
{"name":"FreeAbelianGroup.induction_on'","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nC : FreeAbelianGroup α → Prop\nz : FreeAbelianGroup α\nC0 : C 0\nC1 : ∀ (x : α), C (Pure.pure x)\nCn : ∀ (x : α), C (Pure.pure x) → C (Neg.neg (Pure.pure x))\nCp : ∀ (x y : FreeAbelianGroup α), C x → C y → C (HAdd.hAdd x y)\n⊢ C z","decl":"@[elab_as_elim]\nprotected theorem induction_on' {C : FreeAbelianGroup α → Prop} (z : FreeAbelianGroup α) (C0 : C 0)\n    (C1 : ∀ x, C <| pure x) (Cn : ∀ x, C (pure x) → C (-pure x))\n    (Cp : ∀ x y, C x → C y → C (x + y)) : C z :=\n  FreeAbelianGroup.induction_on z C0 C1 Cn Cp\n\n"}
{"name":"FreeAbelianGroup.map_pure","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : α → β\nx : α\n⊢ Eq (Functor.map f (Pure.pure x)) (Pure.pure (f x))","decl":"@[simp]\ntheorem map_pure (f : α → β) (x : α) : f <$> (pure x : FreeAbelianGroup α) = pure (f x) :=\n  rfl\n\n"}
{"name":"FreeAbelianGroup.map_zero","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : α → β\n⊢ Eq (Functor.map f 0) 0","decl":"@[simp]\nprotected theorem map_zero (f : α → β) : f <$> (0 : FreeAbelianGroup α) = 0 :=\n  (lift (of ∘ f)).map_zero\n\n"}
{"name":"FreeAbelianGroup.map_add","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : α → β\nx y : FreeAbelianGroup α\n⊢ Eq (Functor.map f (HAdd.hAdd x y)) (HAdd.hAdd (Functor.map f x) (Functor.map f y))","decl":"@[simp]\nprotected theorem map_add (f : α → β) (x y : FreeAbelianGroup α) :\n    f <$> (x + y) = f <$> x + f <$> y :=\n  (lift _).map_add _ _\n\n"}
{"name":"FreeAbelianGroup.map_neg","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : α → β\nx : FreeAbelianGroup α\n⊢ Eq (Functor.map f (Neg.neg x)) (Neg.neg (Functor.map f x))","decl":"@[simp]\nprotected theorem map_neg (f : α → β) (x : FreeAbelianGroup α) : f <$> (-x) = -f <$> x :=\n  map_neg (lift <| of ∘ f) _\n\n"}
{"name":"FreeAbelianGroup.map_sub","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : α → β\nx y : FreeAbelianGroup α\n⊢ Eq (Functor.map f (HSub.hSub x y)) (HSub.hSub (Functor.map f x) (Functor.map f y))","decl":"@[simp]\nprotected theorem map_sub (f : α → β) (x y : FreeAbelianGroup α) :\n    f <$> (x - y) = f <$> x - f <$> y :=\n  map_sub (lift <| of ∘ f) _ _\n\n"}
{"name":"FreeAbelianGroup.map_of","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : α → β\ny : α\n⊢ Eq (Functor.map f (FreeAbelianGroup.of y)) (FreeAbelianGroup.of (f y))","decl":"@[simp]\ntheorem map_of (f : α → β) (y : α) : f <$> of y = of (f y) :=\n  rfl\n\n"}
{"name":"FreeAbelianGroup.pure_bind","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : α → FreeAbelianGroup β\nx : α\n⊢ Eq (Bind.bind (Pure.pure x) f) (f x)","decl":"theorem pure_bind (f : α → FreeAbelianGroup β) (x) : pure x >>= f = f x :=\n  lift.of _ _\n\n"}
{"name":"FreeAbelianGroup.zero_bind","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : α → FreeAbelianGroup β\n⊢ Eq (Bind.bind 0 f) 0","decl":"@[simp]\ntheorem zero_bind (f : α → FreeAbelianGroup β) : 0 >>= f = 0 :=\n  (lift f).map_zero\n\n"}
{"name":"FreeAbelianGroup.add_bind","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : α → FreeAbelianGroup β\nx y : FreeAbelianGroup α\n⊢ Eq (Bind.bind (HAdd.hAdd x y) f) (HAdd.hAdd (Bind.bind x f) (Bind.bind y f))","decl":"@[simp]\ntheorem add_bind (f : α → FreeAbelianGroup β) (x y : FreeAbelianGroup α) :\n    x + y >>= f = (x >>= f) + (y >>= f) :=\n  (lift _).map_add _ _\n\n"}
{"name":"FreeAbelianGroup.neg_bind","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : α → FreeAbelianGroup β\nx : FreeAbelianGroup α\n⊢ Eq (Bind.bind (Neg.neg x) f) (Neg.neg (Bind.bind x f))","decl":"@[simp]\ntheorem neg_bind (f : α → FreeAbelianGroup β) (x : FreeAbelianGroup α) : -x >>= f = -(x >>= f) :=\n  map_neg (lift f) _\n\n"}
{"name":"FreeAbelianGroup.sub_bind","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : α → FreeAbelianGroup β\nx y : FreeAbelianGroup α\n⊢ Eq (Bind.bind (HSub.hSub x y) f) (HSub.hSub (Bind.bind x f) (Bind.bind y f))","decl":"@[simp]\ntheorem sub_bind (f : α → FreeAbelianGroup β) (x y : FreeAbelianGroup α) :\n    x - y >>= f = (x >>= f) - (y >>= f) :=\n  map_sub (lift f) _ _\n\n"}
{"name":"FreeAbelianGroup.pure_seq","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : α → β\nx : FreeAbelianGroup α\n⊢ Eq (Seq.seq (Pure.pure f) fun x_1 => x) (Functor.map f x)","decl":"@[simp]\ntheorem pure_seq (f : α → β) (x : FreeAbelianGroup α) : pure f <*> x = f <$> x :=\n  pure_bind _ _\n\n"}
{"name":"FreeAbelianGroup.zero_seq","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nx : FreeAbelianGroup α\n⊢ Eq (Seq.seq 0 fun x_1 => x) 0","decl":"@[simp]\ntheorem zero_seq (x : FreeAbelianGroup α) : (0 : FreeAbelianGroup (α → β)) <*> x = 0 :=\n  zero_bind _\n\n"}
{"name":"FreeAbelianGroup.add_seq","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf g : FreeAbelianGroup (α → β)\nx : FreeAbelianGroup α\n⊢ Eq (Seq.seq (HAdd.hAdd f g) fun x_1 => x) (HAdd.hAdd (Seq.seq f fun x_1 => x) (Seq.seq g fun x_1 => x))","decl":"@[simp]\ntheorem add_seq (f g : FreeAbelianGroup (α → β)) (x : FreeAbelianGroup α) :\n    f + g <*> x = (f <*> x) + (g <*> x) :=\n  add_bind _ _ _\n\n"}
{"name":"FreeAbelianGroup.neg_seq","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : FreeAbelianGroup (α → β)\nx : FreeAbelianGroup α\n⊢ Eq (Seq.seq (Neg.neg f) fun x_1 => x) (Neg.neg (Seq.seq f fun x_1 => x))","decl":"@[simp]\ntheorem neg_seq (f : FreeAbelianGroup (α → β)) (x : FreeAbelianGroup α) : -f <*> x = -(f <*> x) :=\n  neg_bind _ _\n\n"}
{"name":"FreeAbelianGroup.sub_seq","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf g : FreeAbelianGroup (α → β)\nx : FreeAbelianGroup α\n⊢ Eq (Seq.seq (HSub.hSub f g) fun x_1 => x) (HSub.hSub (Seq.seq f fun x_1 => x) (Seq.seq g fun x_1 => x))","decl":"@[simp]\ntheorem sub_seq (f g : FreeAbelianGroup (α → β)) (x : FreeAbelianGroup α) :\n    f - g <*> x = (f <*> x) - (g <*> x) :=\n  sub_bind _ _ _\n\n"}
{"name":"FreeAbelianGroup.seq_zero","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : FreeAbelianGroup (α → β)\n⊢ Eq (Seq.seq f fun x => 0) 0","decl":"@[simp]\ntheorem seq_zero (f : FreeAbelianGroup (α → β)) : f <*> 0 = 0 :=\n  (seqAddGroupHom f).map_zero\n\n"}
{"name":"FreeAbelianGroup.seq_add","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : FreeAbelianGroup (α → β)\nx y : FreeAbelianGroup α\n⊢ Eq (Seq.seq f fun x_1 => HAdd.hAdd x y) (HAdd.hAdd (Seq.seq f fun x_1 => x) (Seq.seq f fun x => y))","decl":"@[simp]\ntheorem seq_add (f : FreeAbelianGroup (α → β)) (x y : FreeAbelianGroup α) :\n    f <*> x + y = (f <*> x) + (f <*> y) :=\n  (seqAddGroupHom f).map_add x y\n\n"}
{"name":"FreeAbelianGroup.seq_neg","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : FreeAbelianGroup (α → β)\nx : FreeAbelianGroup α\n⊢ Eq (Seq.seq f fun x_1 => Neg.neg x) (Neg.neg (Seq.seq f fun x_1 => x))","decl":"@[simp]\ntheorem seq_neg (f : FreeAbelianGroup (α → β)) (x : FreeAbelianGroup α) : f <*> -x = -(f <*> x) :=\n  (seqAddGroupHom f).map_neg x\n\n"}
{"name":"FreeAbelianGroup.seq_sub","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α β : Type u\nf : FreeAbelianGroup (α → β)\nx y : FreeAbelianGroup α\n⊢ Eq (Seq.seq f fun x_1 => HSub.hSub x y) (HSub.hSub (Seq.seq f fun x_1 => x) (Seq.seq f fun x => y))","decl":"@[simp]\ntheorem seq_sub (f : FreeAbelianGroup (α → β)) (x y : FreeAbelianGroup α) :\n    f <*> x - y = (f <*> x) - (f <*> y) :=\n  (seqAddGroupHom f).map_sub x y\n\n"}
{"name":"FreeAbelianGroup.instLawfulMonad","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"⊢ LawfulMonad FreeAbelianGroup","decl":"instance : LawfulMonad FreeAbelianGroup.{u} := LawfulMonad.mk'\n  (id_map := fun x ↦ FreeAbelianGroup.induction_on' x (FreeAbelianGroup.map_zero id) (map_pure id)\n    (fun x ih ↦ by rw [FreeAbelianGroup.map_neg, ih])\n    fun x y ihx ihy ↦ by rw [FreeAbelianGroup.map_add, ihx, ihy])\n  (pure_bind := fun x f ↦ pure_bind f x)\n  (bind_assoc := fun x f g ↦ FreeAbelianGroup.induction_on' x (by iterate 3 rw [zero_bind])\n    (fun x ↦ by iterate 2 rw [pure_bind]) (fun x ih ↦ by iterate 3 rw [neg_bind] <;> try rw [ih])\n    fun x y ihx ihy ↦ by iterate 3 rw [add_bind] <;> try rw [ihx, ihy])\n\n"}
{"name":"FreeAbelianGroup.instCommApplicative","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"⊢ CommApplicative FreeAbelianGroup","decl":"instance : CommApplicative FreeAbelianGroup.{u} where\n  commutative_prod x y := by\n    refine FreeAbelianGroup.induction_on' x ?_ ?_ ?_ ?_\n    · rw [FreeAbelianGroup.map_zero, zero_seq, seq_zero]\n    · intro p\n      rw [map_pure, pure_seq]\n      exact FreeAbelianGroup.induction_on' y\n        (by rw [FreeAbelianGroup.map_zero, FreeAbelianGroup.map_zero, zero_seq])\n        (fun q ↦ by rw [map_pure, map_pure, pure_seq, map_pure])\n        (fun q ih ↦ by rw [FreeAbelianGroup.map_neg, FreeAbelianGroup.map_neg, neg_seq, ih])\n        fun y₁ y₂ ih1 ih2 ↦ by\n          rw [FreeAbelianGroup.map_add, FreeAbelianGroup.map_add, add_seq, ih1, ih2]\n    · intro p ih\n      rw [FreeAbelianGroup.map_neg, neg_seq, seq_neg, ih]\n    · intro x₁ x₂ ih1 ih2\n      rw [FreeAbelianGroup.map_add, add_seq, seq_add, ih1, ih2]\n\n"}
{"name":"FreeAbelianGroup.lift_comp","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : AddCommGroup γ\nf : α → β\ng : β → γ\nx : FreeAbelianGroup α\n⊢ Eq ((FreeAbelianGroup.lift (Function.comp g f)) x) ((FreeAbelianGroup.lift g) ((FreeAbelianGroup.map f) x))","decl":"theorem lift_comp {α} {β} {γ} [AddCommGroup γ] (f : α → β) (g : β → γ) (x : FreeAbelianGroup α) :\n    lift (g ∘ f) x = lift g (map f x) := by\n  -- Porting note: Added motive.\n  apply FreeAbelianGroup.induction_on (C := fun x ↦ lift (g ∘ f) x = lift g (map f x)) x\n  · simp only [map_zero]\n  · intro _\n    simp only [lift.of, map, Function.comp]\n  · intro _ h\n    simp only [h, AddMonoidHom.map_neg]\n  · intro _ _ h₁ h₂\n    simp only [h₁, h₂, AddMonoidHom.map_add]\n\n"}
{"name":"FreeAbelianGroup.map_id","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\n⊢ Eq (FreeAbelianGroup.map id) (AddMonoidHom.id (FreeAbelianGroup α))","decl":"theorem map_id : map id = AddMonoidHom.id (FreeAbelianGroup α) :=\n  Eq.symm <|\n    lift.ext _ _ fun _ ↦ lift.unique of (AddMonoidHom.id _) fun _ ↦ AddMonoidHom.id_apply _ _\n\n"}
{"name":"FreeAbelianGroup.map_id_apply","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nx : FreeAbelianGroup α\n⊢ Eq ((FreeAbelianGroup.map id) x) x","decl":"theorem map_id_apply (x : FreeAbelianGroup α) : map id x = x := by\n  rw [map_id]\n  rfl\n\n"}
{"name":"FreeAbelianGroup.map_comp","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → β\ng : β → γ\n⊢ Eq (FreeAbelianGroup.map (Function.comp g f)) ((FreeAbelianGroup.map g).comp (FreeAbelianGroup.map f))","decl":"theorem map_comp {f : α → β} {g : β → γ} : map (g ∘ f) = (map g).comp (map f) :=\n  Eq.symm <| lift.ext _ _ fun _ ↦ by simp [map]\n\n"}
{"name":"FreeAbelianGroup.map_comp_apply","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → β\ng : β → γ\nx : FreeAbelianGroup α\n⊢ Eq ((FreeAbelianGroup.map (Function.comp g f)) x) ((FreeAbelianGroup.map g) ((FreeAbelianGroup.map f) x))","decl":"theorem map_comp_apply {f : α → β} {g : β → γ} (x : FreeAbelianGroup α) :\n    map (g ∘ f) x = (map g) ((map f) x) := by\n  rw [map_comp]\n  rfl\n\n-- version of map_of which uses `map`\n"}
{"name":"FreeAbelianGroup.map_of_apply","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\n⊢ Eq ((FreeAbelianGroup.map f) (FreeAbelianGroup.of a)) (FreeAbelianGroup.of (f a))","decl":"@[simp]\ntheorem map_of_apply {f : α → β} (a : α) : map f (of a) = of (f a) :=\n  rfl\n\n"}
{"name":"FreeAbelianGroup.mul_def","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\ninst✝ : Mul α\nx y : FreeAbelianGroup α\n⊢ Eq (HMul.hMul x y) ((FreeAbelianGroup.lift fun x₂ => (FreeAbelianGroup.lift fun x₁ => FreeAbelianGroup.of (HMul.hMul x₁ x₂)) x) y)","decl":"theorem mul_def (x y : FreeAbelianGroup α) :\n    x * y = lift (fun x₂ ↦ lift (fun x₁ ↦ of (x₁ * x₂)) x) y :=\n  rfl\n\n"}
{"name":"FreeAbelianGroup.of_mul_of","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\ninst✝ : Mul α\nx y : α\n⊢ Eq (HMul.hMul (FreeAbelianGroup.of x) (FreeAbelianGroup.of y)) (FreeAbelianGroup.of (HMul.hMul x y))","decl":"@[simp]\ntheorem of_mul_of (x y : α) : of x * of y = of (x * y) := by\n  rw [mul_def, lift.of, lift.of]\n\n"}
{"name":"FreeAbelianGroup.of_mul","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\ninst✝ : Mul α\nx y : α\n⊢ Eq (FreeAbelianGroup.of (HMul.hMul x y)) (HMul.hMul (FreeAbelianGroup.of x) (FreeAbelianGroup.of y))","decl":"theorem of_mul (x y : α) : of (x * y) = of x * of y :=\n  Eq.symm <| of_mul_of x y\n\n"}
{"name":"FreeAbelianGroup.one_def","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\ninst✝ : One α\n⊢ Eq 1 (FreeAbelianGroup.of 1)","decl":"theorem one_def : (1 : FreeAbelianGroup α) = of 1 :=\n  rfl\n\n"}
{"name":"FreeAbelianGroup.of_one","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\ninst✝ : One α\n⊢ Eq (FreeAbelianGroup.of 1) 1","decl":"theorem of_one : (of 1 : FreeAbelianGroup α) = 1 :=\n  rfl\n\n"}
{"name":"FreeAbelianGroup.ofMulHom_coe","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\ninst✝ : Monoid α\n⊢ Eq (⇑FreeAbelianGroup.ofMulHom) FreeAbelianGroup.of","decl":"@[simp]\ntheorem ofMulHom_coe : (ofMulHom : α → FreeAbelianGroup α) = of :=\n  rfl\n\n"}
{"name":"FreeAbelianGroup.liftMonoid_coe_addMonoidHom","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nR : Type u_1\ninst✝¹ : Monoid α\ninst✝ : Ring R\nf : MonoidHom α R\n⊢ Eq (↑(FreeAbelianGroup.liftMonoid f)) (FreeAbelianGroup.lift ⇑f)","decl":"@[simp]\ntheorem liftMonoid_coe_addMonoidHom (f : α →* R) : ↑(liftMonoid f) = lift f :=\n  rfl\n\n"}
{"name":"FreeAbelianGroup.liftMonoid_coe","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nR : Type u_1\ninst✝¹ : Monoid α\ninst✝ : Ring R\nf : MonoidHom α R\n⊢ Eq ⇑(FreeAbelianGroup.liftMonoid f) ⇑(FreeAbelianGroup.lift ⇑f)","decl":"@[simp]\ntheorem liftMonoid_coe (f : α →* R) : ⇑(liftMonoid f) = lift f :=\n  rfl\n\n"}
{"name":"FreeAbelianGroup.liftMonoid_symm_coe","module":"Mathlib.GroupTheory.FreeAbelianGroup","initialProofState":"α : Type u\nR : Type u_1\ninst✝¹ : Monoid α\ninst✝ : Ring R\nf : RingHom (FreeAbelianGroup α) R\n⊢ Eq (⇑(FreeAbelianGroup.liftMonoid.symm f)) (FreeAbelianGroup.lift.symm ↑f)","decl":"@[simp]\n-- Porting note: Added a type to `↑f`.\ntheorem liftMonoid_symm_coe (f : FreeAbelianGroup α →+* R) :\n    ⇑(liftMonoid.symm f) = lift.symm (↑f : FreeAbelianGroup α →+ R) :=\n  rfl\n\n"}
