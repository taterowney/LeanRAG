{"name":"AList.mk.sizeOf_spec","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝¹ : SizeOf α\ninst✝ : (a : α) → SizeOf (β a)\nentries : List (Sigma β)\nnodupKeys : entries.NodupKeys\n⊢ Eq (SizeOf.sizeOf { entries := entries, nodupKeys := nodupKeys }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf entries)) (SizeOf.sizeOf nodupKeys))","decl":"/-- `AList β` is a key-value map stored as a `List` (i.e. a linked list).\n  It is a wrapper around certain `List` functions with the added constraint\n  that the list have unique keys. -/\nstructure AList (β : α → Type v) : Type max u v where\n  /-- The underlying `List` of an `AList` -/\n  entries : List (Sigma β)\n  /-- There are no duplicate keys in `entries` -/\n  nodupKeys : entries.NodupKeys\n\n"}
{"name":"AList.nodupKeys","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\nself : AList β\n⊢ self.entries.NodupKeys","decl":"/-- `AList β` is a key-value map stored as a `List` (i.e. a linked list).\n  It is a wrapper around certain `List` functions with the added constraint\n  that the list have unique keys. -/\nstructure AList (β : α → Type v) : Type max u v where\n  /-- The underlying `List` of an `AList` -/\n  entries : List (Sigma β)\n  /-- There are no duplicate keys in `entries` -/\n  nodupKeys : entries.NodupKeys\n\n"}
{"name":"AList.mk.inj","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\nentries✝ : List (Sigma β)\nnodupKeys✝ : entries✝.NodupKeys\nentries : List (Sigma β)\nnodupKeys : entries.NodupKeys\nx✝ : Eq { entries := entries✝, nodupKeys := nodupKeys✝ } { entries := entries, nodupKeys := nodupKeys }\n⊢ Eq entries✝ entries","decl":"/-- `AList β` is a key-value map stored as a `List` (i.e. a linked list).\n  It is a wrapper around certain `List` functions with the added constraint\n  that the list have unique keys. -/\nstructure AList (β : α → Type v) : Type max u v where\n  /-- The underlying `List` of an `AList` -/\n  entries : List (Sigma β)\n  /-- There are no duplicate keys in `entries` -/\n  nodupKeys : entries.NodupKeys\n\n"}
{"name":"AList.mk.injEq","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\nentries✝ : List (Sigma β)\nnodupKeys✝ : entries✝.NodupKeys\nentries : List (Sigma β)\nnodupKeys : entries.NodupKeys\n⊢ Eq (Eq { entries := entries✝, nodupKeys := nodupKeys✝ } { entries := entries, nodupKeys := nodupKeys }) (Eq entries✝ entries)","decl":"/-- `AList β` is a key-value map stored as a `List` (i.e. a linked list).\n  It is a wrapper around certain `List` functions with the added constraint\n  that the list have unique keys. -/\nstructure AList (β : α → Type v) : Type max u v where\n  /-- The underlying `List` of an `AList` -/\n  entries : List (Sigma β)\n  /-- There are no duplicate keys in `entries` -/\n  nodupKeys : entries.NodupKeys\n\n"}
{"name":"AList.ext","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ns t : AList β\na✝ : Eq s.entries t.entries\n⊢ Eq s t","decl":"@[ext]\ntheorem ext : ∀ {s t : AList β}, s.entries = t.entries → s = t\n  | ⟨l₁, h₁⟩, ⟨l₂, _⟩, H => by congr\n\n"}
{"name":"AList.ext_iff","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ns t : AList β\n⊢ Iff (Eq s t) (Eq s.entries t.entries)","decl":"@[ext]\ntheorem ext : ∀ {s t : AList β}, s.entries = t.entries → s = t\n  | ⟨l₁, h₁⟩, ⟨l₂, _⟩, H => by congr\n\n"}
{"name":"AList.keys_nodup","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ns : AList β\n⊢ s.keys.Nodup","decl":"theorem keys_nodup (s : AList β) : s.keys.Nodup :=\n  s.nodupKeys\n\n"}
{"name":"AList.mem_keys","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\na : α\ns : AList β\n⊢ Iff (Membership.mem s a) (Membership.mem s.keys a)","decl":"theorem mem_keys {a : α} {s : AList β} : a ∈ s ↔ a ∈ s.keys :=\n  Iff.rfl\n\n"}
{"name":"AList.mem_of_perm","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\na : α\ns₁ s₂ : AList β\np : s₁.entries.Perm s₂.entries\n⊢ Iff (Membership.mem s₁ a) (Membership.mem s₂ a)","decl":"theorem mem_of_perm {a : α} {s₁ s₂ : AList β} (p : s₁.entries ~ s₂.entries) : a ∈ s₁ ↔ a ∈ s₂ :=\n  (p.map Sigma.fst).mem_iff\n\n"}
{"name":"AList.not_mem_empty","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\na : α\n⊢ Not (Membership.mem EmptyCollection.emptyCollection a)","decl":"@[simp]\ntheorem not_mem_empty (a : α) : a ∉ (∅ : AList β) :=\n  not_mem_nil a\n\n"}
{"name":"AList.empty_entries","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\n⊢ Eq EmptyCollection.emptyCollection.entries List.nil","decl":"@[simp]\ntheorem empty_entries : (∅ : AList β).entries = [] :=\n  rfl\n\n"}
{"name":"AList.keys_empty","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\n⊢ Eq EmptyCollection.emptyCollection.keys List.nil","decl":"@[simp]\ntheorem keys_empty : (∅ : AList β).keys = [] :=\n  rfl\n\n"}
{"name":"AList.singleton_entries","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\na : α\nb : β a\n⊢ Eq (AList.singleton a b).entries (List.cons ⟨a, b⟩ List.nil)","decl":"@[simp]\ntheorem singleton_entries (a : α) (b : β a) : (singleton a b).entries = [Sigma.mk a b] :=\n  rfl\n\n"}
{"name":"AList.keys_singleton","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\na : α\nb : β a\n⊢ Eq (AList.singleton a b).keys (List.cons a List.nil)","decl":"@[simp]\ntheorem keys_singleton (a : α) (b : β a) : (singleton a b).keys = [a] :=\n  rfl\n\n"}
{"name":"AList.lookup_empty","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\n⊢ Eq (AList.lookup a EmptyCollection.emptyCollection) Option.none","decl":"@[simp]\ntheorem lookup_empty (a) : lookup a (∅ : AList β) = none :=\n  rfl\n\n"}
{"name":"AList.lookup_isSome","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : AList β\n⊢ Iff (Eq (AList.lookup a s).isSome Bool.true) (Membership.mem s a)","decl":"theorem lookup_isSome {a : α} {s : AList β} : (s.lookup a).isSome ↔ a ∈ s :=\n  dlookup_isSome\n\n"}
{"name":"AList.lookup_eq_none","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : AList β\n⊢ Iff (Eq (AList.lookup a s) Option.none) (Not (Membership.mem s a))","decl":"theorem lookup_eq_none {a : α} {s : AList β} : lookup a s = none ↔ a ∉ s :=\n  dlookup_eq_none\n\n"}
{"name":"AList.mem_lookup_iff","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : AList β\n⊢ Iff (Membership.mem (AList.lookup a s) b) (Membership.mem s.entries ⟨a, b⟩)","decl":"theorem mem_lookup_iff {a : α} {b : β a} {s : AList β} :\n    b ∈ lookup a s ↔ Sigma.mk a b ∈ s.entries :=\n  mem_dlookup_iff s.nodupKeys\n\n"}
{"name":"AList.perm_lookup","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns₁ s₂ : AList β\np : s₁.entries.Perm s₂.entries\n⊢ Eq (AList.lookup a s₁) (AList.lookup a s₂)","decl":"theorem perm_lookup {a : α} {s₁ s₂ : AList β} (p : s₁.entries ~ s₂.entries) :\n    s₁.lookup a = s₂.lookup a :=\n  perm_dlookup _ s₁.nodupKeys s₂.nodupKeys p\n\n"}
{"name":"AList.keys_subset_keys_of_entries_subset_entries","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ns₁ s₂ : AList β\nh : HasSubset.Subset s₁.entries s₂.entries\n⊢ HasSubset.Subset s₁.keys s₂.keys","decl":"theorem keys_subset_keys_of_entries_subset_entries\n    {s₁ s₂ : AList β} (h : s₁.entries ⊆ s₂.entries) : s₁.keys ⊆ s₂.keys := by\n  intro k hk\n  letI : DecidableEq α := Classical.decEq α\n  have := h (mem_lookup_iff.1 (Option.get_mem (lookup_isSome.2 hk)))\n  rw [← mem_lookup_iff, Option.mem_def] at this\n  rw [← mem_keys, ← lookup_isSome, this]\n  exact Option.isSome_some\n\n"}
{"name":"AList.keys_replace","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : AList β\n⊢ Eq (AList.replace a b s).keys s.keys","decl":"@[simp]\ntheorem keys_replace (a : α) (b : β a) (s : AList β) : (replace a b s).keys = s.keys :=\n  keys_kreplace _ _ _\n\n"}
{"name":"AList.mem_replace","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\nb : β a\ns : AList β\n⊢ Iff (Membership.mem (AList.replace a b s) a') (Membership.mem s a')","decl":"@[simp]\ntheorem mem_replace {a a' : α} {b : β a} {s : AList β} : a' ∈ replace a b s ↔ a' ∈ s := by\n  rw [mem_keys, keys_replace, ← mem_keys]\n\n"}
{"name":"AList.perm_replace","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns₁ s₂ : AList β\na✝ : s₁.entries.Perm s₂.entries\n⊢ (AList.replace a b s₁).entries.Perm (AList.replace a b s₂).entries","decl":"theorem perm_replace {a : α} {b : β a} {s₁ s₂ : AList β} :\n    s₁.entries ~ s₂.entries → (replace a b s₁).entries ~ (replace a b s₂).entries :=\n  Perm.kreplace s₁.nodupKeys\n\n"}
{"name":"AList.keys_erase","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : AList β\n⊢ Eq (AList.erase a s).keys (s.keys.erase a)","decl":"@[simp]\ntheorem keys_erase (a : α) (s : AList β) : (erase a s).keys = s.keys.erase a :=\n  keys_kerase\n\n"}
{"name":"AList.mem_erase","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\ns : AList β\n⊢ Iff (Membership.mem (AList.erase a s) a') (And (Ne a' a) (Membership.mem s a'))","decl":"@[simp]\ntheorem mem_erase {a a' : α} {s : AList β} : a' ∈ erase a s ↔ a' ≠ a ∧ a' ∈ s := by\n  rw [mem_keys, keys_erase, s.keys_nodup.mem_erase_iff, ← mem_keys]\n\n"}
{"name":"AList.perm_erase","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns₁ s₂ : AList β\na✝ : s₁.entries.Perm s₂.entries\n⊢ (AList.erase a s₁).entries.Perm (AList.erase a s₂).entries","decl":"theorem perm_erase {a : α} {s₁ s₂ : AList β} :\n    s₁.entries ~ s₂.entries → (erase a s₁).entries ~ (erase a s₂).entries :=\n  Perm.kerase s₁.nodupKeys\n\n"}
{"name":"AList.lookup_erase","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : AList β\n⊢ Eq (AList.lookup a (AList.erase a s)) Option.none","decl":"@[simp]\ntheorem lookup_erase (a) (s : AList β) : lookup a (erase a s) = none :=\n  dlookup_kerase a s.nodupKeys\n\n"}
{"name":"AList.lookup_erase_ne","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\ns : AList β\nh : Ne a a'\n⊢ Eq (AList.lookup a (AList.erase a' s)) (AList.lookup a s)","decl":"@[simp]\ntheorem lookup_erase_ne {a a'} {s : AList β} (h : a ≠ a') : lookup a (erase a' s) = lookup a s :=\n  dlookup_kerase_ne h\n\n"}
{"name":"AList.erase_erase","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\ns : AList β\n⊢ Eq (AList.erase a' (AList.erase a s)) (AList.erase a (AList.erase a' s))","decl":"theorem erase_erase (a a' : α) (s : AList β) : (s.erase a).erase a' = (s.erase a').erase a :=\n  ext <| kerase_kerase\n\n"}
{"name":"AList.entries_insert","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : AList β\n⊢ Eq (AList.insert a b s).entries (List.cons ⟨a, b⟩ (List.kerase a s.entries))","decl":"@[simp]\ntheorem entries_insert {a} {b : β a} {s : AList β} :\n    (insert a b s).entries = Sigma.mk a b :: kerase a s.entries :=\n  rfl\n\n"}
{"name":"AList.insert_entries","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : AList β\n⊢ Eq (AList.insert a b s).entries (List.cons ⟨a, b⟩ (List.kerase a s.entries))","decl":"@[deprecated (since := \"2024-12-17\")] alias insert_entries := entries_insert\n\n"}
{"name":"AList.entries_insert_of_not_mem","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : AList β\nh : Not (Membership.mem s a)\n⊢ Eq (AList.insert a b s).entries (List.cons ⟨a, b⟩ s.entries)","decl":"theorem entries_insert_of_not_mem {a} {b : β a} {s : AList β} (h : a ∉ s) :\n    (insert a b s).entries = ⟨a, b⟩ :: s.entries := by rw [entries_insert, kerase_of_not_mem_keys h]\n\n"}
{"name":"AList.insert_of_not_mem","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : AList β\nh : Not (Membership.mem s a)\n⊢ Eq (AList.insert a b s) { entries := List.cons ⟨a, b⟩ s.entries, nodupKeys := ⋯ }","decl":"theorem insert_of_not_mem {a} {b : β a} {s : AList β} (h : a ∉ s) :\n    insert a b s = ⟨⟨a, b⟩ :: s.entries, nodupKeys_cons.2 ⟨h, s.2⟩⟩ :=\n  ext <| entries_insert_of_not_mem h\n\n"}
{"name":"AList.insert_entries_of_neg","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : AList β\nh : Not (Membership.mem s a)\n⊢ Eq (AList.insert a b s).entries (List.cons ⟨a, b⟩ s.entries)","decl":"@[deprecated (since := \"2024-12-14\")] alias insert_entries_of_neg := entries_insert_of_not_mem\n"}
{"name":"AList.insert_of_neg","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : AList β\nh : Not (Membership.mem s a)\n⊢ Eq (AList.insert a b s) { entries := List.cons ⟨a, b⟩ s.entries, nodupKeys := ⋯ }","decl":"@[deprecated (since := \"2024-12-14\")] alias insert_of_neg := insert_of_not_mem\n\n"}
{"name":"AList.insert_empty","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\n⊢ Eq (AList.insert a b EmptyCollection.emptyCollection) (AList.singleton a b)","decl":"@[simp]\ntheorem insert_empty (a) (b : β a) : insert a b ∅ = singleton a b :=\n  rfl\n\n"}
{"name":"AList.mem_insert","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\nb' : β a'\ns : AList β\n⊢ Iff (Membership.mem (AList.insert a' b' s) a) (Or (Eq a a') (Membership.mem s a))","decl":"@[simp]\ntheorem mem_insert {a a'} {b' : β a'} (s : AList β) : a ∈ insert a' b' s ↔ a = a' ∨ a ∈ s :=\n  mem_keys_kinsert\n\n"}
{"name":"AList.keys_insert","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : AList β\n⊢ Eq (AList.insert a b s).keys (List.cons a (s.keys.erase a))","decl":"@[simp]\ntheorem keys_insert {a} {b : β a} (s : AList β) : (insert a b s).keys = a :: s.keys.erase a := by\n  simp [insert, keys, keys_kerase]\n\n"}
{"name":"AList.perm_insert","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns₁ s₂ : AList β\np : s₁.entries.Perm s₂.entries\n⊢ (AList.insert a b s₁).entries.Perm (AList.insert a b s₂).entries","decl":"theorem perm_insert {a} {b : β a} {s₁ s₂ : AList β} (p : s₁.entries ~ s₂.entries) :\n    (insert a b s₁).entries ~ (insert a b s₂).entries := by\n  simp only [entries_insert]; exact p.kinsert s₁.nodupKeys\n\n"}
{"name":"AList.lookup_insert","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns : AList β\n⊢ Eq (AList.lookup a (AList.insert a b s)) (Option.some b)","decl":"@[simp]\ntheorem lookup_insert {a} {b : β a} (s : AList β) : lookup a (insert a b s) = some b := by\n  simp only [lookup, insert, dlookup_kinsert]\n\n"}
{"name":"AList.lookup_insert_ne","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\nb' : β a'\ns : AList β\nh : Ne a a'\n⊢ Eq (AList.lookup a (AList.insert a' b' s)) (AList.lookup a s)","decl":"@[simp]\ntheorem lookup_insert_ne {a a'} {b' : β a'} {s : AList β} (h : a ≠ a') :\n    lookup a (insert a' b' s) = lookup a s :=\n  dlookup_kinsert_ne h\n\n"}
{"name":"AList.lookup_insert_eq_none","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nl : AList β\nk k' : α\nv : β k\n⊢ Iff (Eq (AList.lookup k' (AList.insert k v l)) Option.none) (And (Ne k' k) (Eq (AList.lookup k' l) Option.none))","decl":"@[simp] theorem lookup_insert_eq_none {l : AList β} {k k' : α} {v : β k} :\n    (l.insert k v).lookup k' = none ↔ (k' ≠ k) ∧ l.lookup k' = none := by\n  by_cases h : k' = k\n  · subst h; simp\n  · simp_all [lookup_insert_ne h]\n\n"}
{"name":"AList.lookup_to_alist","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : List (Sigma β)\n⊢ Eq (AList.lookup a s.toAList) (List.dlookup a s)","decl":"@[simp]\ntheorem lookup_to_alist {a} (s : List (Sigma β)) : lookup a s.toAList = s.dlookup a := by\n  rw [List.toAList, lookup, dlookup_dedupKeys]\n\n"}
{"name":"AList.insert_insert","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb b' : β a\ns : AList β\n⊢ Eq (AList.insert a b' (AList.insert a b s)) (AList.insert a b' s)","decl":"@[simp]\ntheorem insert_insert {a} {b b' : β a} (s : AList β) :\n    (s.insert a b).insert a b' = s.insert a b' := by\n  ext : 1; simp only [AList.entries_insert, List.kerase_cons_eq]\n\n"}
{"name":"AList.insert_insert_of_ne","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na a' : α\nb : β a\nb' : β a'\ns : AList β\nh : Ne a a'\n⊢ (AList.insert a' b' (AList.insert a b s)).entries.Perm (AList.insert a b (AList.insert a' b' s)).entries","decl":"theorem insert_insert_of_ne {a a'} {b : β a} {b' : β a'} (s : AList β) (h : a ≠ a') :\n    ((s.insert a b).insert a' b').entries ~ ((s.insert a' b').insert a b).entries := by\n  simp only [entries_insert]; rw [kerase_cons_ne, kerase_cons_ne, kerase_comm] <;>\n    [apply Perm.swap; exact h; exact h.symm]\n\n"}
{"name":"AList.insert_singleton_eq","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb b' : β a\n⊢ Eq (AList.insert a b (AList.singleton a b')) (AList.singleton a b)","decl":"@[simp]\ntheorem insert_singleton_eq {a : α} {b b' : β a} : insert a b (singleton a b') = singleton a b :=\n  ext <| by\n    simp only [AList.entries_insert, List.kerase_cons_eq, and_self_iff, AList.singleton_entries,\n      heq_iff_eq, eq_self_iff_true]\n\n"}
{"name":"AList.entries_toAList","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nxs : List (Sigma β)\n⊢ Eq xs.toAList.entries xs.dedupKeys","decl":"@[simp]\ntheorem entries_toAList (xs : List (Sigma β)) : (List.toAList xs).entries = dedupKeys xs :=\n  rfl\n\n"}
{"name":"AList.toAList_cons","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\nxs : List (Sigma β)\n⊢ Eq (List.cons ⟨a, b⟩ xs).toAList (AList.insert a b xs.toAList)","decl":"theorem toAList_cons (a : α) (b : β a) (xs : List (Sigma β)) :\n    List.toAList (⟨a, b⟩ :: xs) = insert a b xs.toAList :=\n  rfl\n\n"}
{"name":"AList.mk_cons_eq_insert","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nc : Sigma β\nl : List (Sigma β)\nh : (List.cons c l).NodupKeys\n⊢ Eq { entries := List.cons c l, nodupKeys := h } (AList.insert c.fst c.snd { entries := l, nodupKeys := ⋯ })","decl":"theorem mk_cons_eq_insert (c : Sigma β) (l : List (Sigma β)) (h : (c :: l).NodupKeys) :\n    (⟨c :: l, h⟩ : AList β) = insert c.1 c.2 ⟨l, nodupKeys_of_nodupKeys_cons h⟩ := by\n  simpa [insert] using (kerase_of_not_mem_keys <| not_mem_keys_of_nodupKeys_cons h).symm\n\n"}
{"name":"AList.insertRec_empty","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nC : AList β → Sort u_1\nH0 : C EmptyCollection.emptyCollection\nIH : (a : α) → (b : β a) → (l : AList β) → Not (Membership.mem l a) → C l → C (AList.insert a b l)\n⊢ Eq (AList.insertRec H0 IH EmptyCollection.emptyCollection) H0","decl":"@[simp]\ntheorem insertRec_empty {C : AList β → Sort*} (H0 : C ∅)\n    (IH : ∀ (a : α) (b : β a) (l : AList β), a ∉ l → C l → C (l.insert a b)) :\n    @insertRec α β _ C H0 IH ∅ = H0 := by\n  change @insertRec α β _ C H0 IH ⟨[], _⟩ = H0\n  rw [insertRec]\n\n"}
{"name":"AList.insertRec_insert","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nC : AList β → Sort u_1\nH0 : C EmptyCollection.emptyCollection\nIH : (a : α) → (b : β a) → (l : AList β) → Not (Membership.mem l a) → C l → C (AList.insert a b l)\nc : Sigma β\nl : AList β\nh : Not (Membership.mem l c.fst)\n⊢ Eq (AList.insertRec H0 IH (AList.insert c.fst c.snd l)) (IH c.fst c.snd l h (AList.insertRec H0 IH l))","decl":"theorem insertRec_insert {C : AList β → Sort*} (H0 : C ∅)\n    (IH : ∀ (a : α) (b : β a) (l : AList β), a ∉ l → C l → C (l.insert a b)) {c : Sigma β}\n    {l : AList β} (h : c.1 ∉ l) :\n    @insertRec α β _ C H0 IH (l.insert c.1 c.2) = IH c.1 c.2 l h (@insertRec α β _ C H0 IH l) := by\n  cases' l with l hl\n  suffices HEq (@insertRec α β _ C H0 IH ⟨c :: l, nodupKeys_cons.2 ⟨h, hl⟩⟩)\n      (IH c.1 c.2 ⟨l, hl⟩ h (@insertRec α β _ C H0 IH ⟨l, hl⟩)) by\n    cases c\n    apply eq_of_heq\n    convert this <;> rw [insert_of_not_mem h]\n  rw [insertRec]\n  apply cast_heq\n\n"}
{"name":"AList.insertRec_insert_mk","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\nC : AList β → Sort u_1\nH0 : C EmptyCollection.emptyCollection\nIH : (a : α) → (b : β a) → (l : AList β) → Not (Membership.mem l a) → C l → C (AList.insert a b l)\na : α\nb : β a\nl : AList β\nh : Not (Membership.mem l a)\n⊢ Eq (AList.insertRec H0 IH (AList.insert a b l)) (IH a b l h (AList.insertRec H0 IH l))","decl":"theorem insertRec_insert_mk {C : AList β → Sort*} (H0 : C ∅)\n    (IH : ∀ (a : α) (b : β a) (l : AList β), a ∉ l → C l → C (l.insert a b)) {a : α} (b : β a)\n    {l : AList β} (h : a ∉ l) :\n    @insertRec α β _ C H0 IH (l.insert a b) = IH a b l h (@insertRec α β _ C H0 IH l) :=\n  @insertRec_insert α β _ C H0 IH ⟨a, b⟩ l h\n\n"}
{"name":"AList.extract_eq_lookup_erase","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns : AList β\n⊢ Eq (AList.extract a s) { fst := AList.lookup a s, snd := AList.erase a s }","decl":"@[simp]\ntheorem extract_eq_lookup_erase (a : α) (s : AList β) : extract a s = (lookup a s, erase a s) := by\n  simp [extract]; constructor <;> rfl\n\n"}
{"name":"AList.union_entries","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns₁ s₂ : AList β\n⊢ Eq (Union.union s₁ s₂).entries (s₁.entries.kunion s₂.entries)","decl":"@[simp]\ntheorem union_entries {s₁ s₂ : AList β} : (s₁ ∪ s₂).entries = kunion s₁.entries s₂.entries :=\n  rfl\n\n"}
{"name":"AList.empty_union","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns : AList β\n⊢ Eq (Union.union EmptyCollection.emptyCollection s) s","decl":"@[simp]\ntheorem empty_union {s : AList β} : (∅ : AList β) ∪ s = s :=\n  ext rfl\n\n"}
{"name":"AList.union_empty","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns : AList β\n⊢ Eq (Union.union s EmptyCollection.emptyCollection) s","decl":"@[simp]\ntheorem union_empty {s : AList β} : s ∪ (∅ : AList β) = s :=\n  ext <| by simp\n\n"}
{"name":"AList.mem_union","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns₁ s₂ : AList β\n⊢ Iff (Membership.mem (Union.union s₁ s₂) a) (Or (Membership.mem s₁ a) (Membership.mem s₂ a))","decl":"@[simp]\ntheorem mem_union {a} {s₁ s₂ : AList β} : a ∈ s₁ ∪ s₂ ↔ a ∈ s₁ ∨ a ∈ s₂ :=\n  mem_keys_kunion\n\n"}
{"name":"AList.perm_union","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns₁ s₂ s₃ s₄ : AList β\np₁₂ : s₁.entries.Perm s₂.entries\np₃₄ : s₃.entries.Perm s₄.entries\n⊢ (Union.union s₁ s₃).entries.Perm (Union.union s₂ s₄).entries","decl":"theorem perm_union {s₁ s₂ s₃ s₄ : AList β} (p₁₂ : s₁.entries ~ s₂.entries)\n    (p₃₄ : s₃.entries ~ s₄.entries) : (s₁ ∪ s₃).entries ~ (s₂ ∪ s₄).entries := by\n  simp [p₁₂.kunion s₃.nodupKeys p₃₄]\n\n"}
{"name":"AList.union_erase","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns₁ s₂ : AList β\n⊢ Eq (AList.erase a (Union.union s₁ s₂)) (Union.union (AList.erase a s₁) (AList.erase a s₂))","decl":"theorem union_erase (a : α) (s₁ s₂ : AList β) : erase a (s₁ ∪ s₂) = erase a s₁ ∪ erase a s₂ :=\n  ext kunion_kerase.symm\n\n"}
{"name":"AList.lookup_union_left","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns₁ s₂ : AList β\na✝ : Membership.mem s₁ a\n⊢ Eq (AList.lookup a (Union.union s₁ s₂)) (AList.lookup a s₁)","decl":"@[simp]\ntheorem lookup_union_left {a} {s₁ s₂ : AList β} : a ∈ s₁ → lookup a (s₁ ∪ s₂) = lookup a s₁ :=\n  dlookup_kunion_left\n\n"}
{"name":"AList.lookup_union_right","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\ns₁ s₂ : AList β\na✝ : Not (Membership.mem s₁ a)\n⊢ Eq (AList.lookup a (Union.union s₁ s₂)) (AList.lookup a s₂)","decl":"@[simp]\ntheorem lookup_union_right {a} {s₁ s₂ : AList β} : a ∉ s₁ → lookup a (s₁ ∪ s₂) = lookup a s₂ :=\n  dlookup_kunion_right\n\n-- Porting note: removing simp, LHS not in SNF, new theorem added instead.\n"}
{"name":"AList.mem_lookup_union","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns₁ s₂ : AList β\n⊢ Iff (Membership.mem (AList.lookup a (Union.union s₁ s₂)) b) (Or (Membership.mem (AList.lookup a s₁) b) (And (Not (Membership.mem s₁ a)) (Membership.mem (AList.lookup a s₂) b)))","decl":"theorem mem_lookup_union {a} {b : β a} {s₁ s₂ : AList β} :\n    b ∈ lookup a (s₁ ∪ s₂) ↔ b ∈ lookup a s₁ ∨ a ∉ s₁ ∧ b ∈ lookup a s₂ :=\n  mem_dlookup_kunion\n\n"}
{"name":"AList.lookup_union_eq_some","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns₁ s₂ : AList β\n⊢ Iff (Eq (AList.lookup a (Union.union s₁ s₂)) (Option.some b)) (Or (Eq (AList.lookup a s₁) (Option.some b)) (And (Not (Membership.mem s₁ a)) (Eq (AList.lookup a s₂) (Option.some b))))","decl":"@[simp]\ntheorem lookup_union_eq_some {a} {b : β a} {s₁ s₂ : AList β} :\n    lookup a (s₁ ∪ s₂) = some b ↔ lookup a s₁ = some b ∨ a ∉ s₁ ∧ lookup a s₂ = some b :=\n  mem_dlookup_kunion\n\n"}
{"name":"AList.mem_lookup_union_middle","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns₁ s₂ s₃ : AList β\na✝¹ : Membership.mem (AList.lookup a (Union.union s₁ s₃)) b\na✝ : Not (Membership.mem s₂ a)\n⊢ Membership.mem (AList.lookup a (Union.union (Union.union s₁ s₂) s₃)) b","decl":"theorem mem_lookup_union_middle {a} {b : β a} {s₁ s₂ s₃ : AList β} :\n    b ∈ lookup a (s₁ ∪ s₃) → a ∉ s₂ → b ∈ lookup a (s₁ ∪ s₂ ∪ s₃) :=\n  mem_dlookup_kunion_middle\n\n"}
{"name":"AList.insert_union","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\na : α\nb : β a\ns₁ s₂ : AList β\n⊢ Eq (AList.insert a b (Union.union s₁ s₂)) (Union.union (AList.insert a b s₁) s₂)","decl":"theorem insert_union {a} {b : β a} {s₁ s₂ : AList β} :\n    insert a b (s₁ ∪ s₂) = insert a b s₁ ∪ s₂ := by ext; simp\n\n"}
{"name":"AList.union_assoc","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns₁ s₂ s₃ : AList β\n⊢ (Union.union (Union.union s₁ s₂) s₃).entries.Perm (Union.union s₁ (Union.union s₂ s₃)).entries","decl":"theorem union_assoc {s₁ s₂ s₃ : AList β} : (s₁ ∪ s₂ ∪ s₃).entries ~ (s₁ ∪ (s₂ ∪ s₃)).entries :=\n  lookup_ext (AList.nodupKeys _) (AList.nodupKeys _)\n    (by simp [not_or, or_assoc, and_or_left, and_assoc])\n\n"}
{"name":"AList.union_comm_of_disjoint","module":"Mathlib.Data.List.AList","initialProofState":"α : Type u\nβ : α → Type v\ninst✝ : DecidableEq α\ns₁ s₂ : AList β\nh : s₁.Disjoint s₂\n⊢ (Union.union s₁ s₂).entries.Perm (Union.union s₂ s₁).entries","decl":"theorem union_comm_of_disjoint {s₁ s₂ : AList β} (h : Disjoint s₁ s₂) :\n    (s₁ ∪ s₂).entries ~ (s₂ ∪ s₁).entries :=\n  lookup_ext (AList.nodupKeys _) (AList.nodupKeys _)\n    (by\n      intros; simp only [union_entries, Option.mem_def, dlookup_kunion_eq_some]\n      constructor <;> intro h'\n      · cases' h' with h' h'\n        · right\n          refine ⟨?_, h'⟩\n          apply h\n          rw [keys, ← List.dlookup_isSome, h']\n          exact rfl\n        · left\n          rw [h'.2]\n      · cases' h' with h' h'\n        · right\n          refine ⟨?_, h'⟩\n          intro h''\n          apply h _ h''\n          rw [keys, ← List.dlookup_isSome, h']\n          exact rfl\n        · left\n          rw [h'.2])\n\n"}
