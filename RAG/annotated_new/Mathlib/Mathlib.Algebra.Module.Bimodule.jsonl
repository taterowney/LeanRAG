{"name":"Subbimodule.coe_mk","module":"Mathlib.Algebra.Module.Bimodule","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : Module R M\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Module A M\ninst✝⁵ : Module B M\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\ninst✝² : IsScalarTower R A M\ninst✝¹ : IsScalarTower R B M\ninst✝ : SMulCommClass A B M\np : AddSubmonoid M\nhA : ∀ (a : A) {m : M}, Membership.mem p m → Membership.mem p (HSMul.hSMul a m)\nhB : ∀ (b : B) {m : M}, Membership.mem p m → Membership.mem p (HSMul.hSMul b m)\n⊢ Eq ↑(Subbimodule.mk p hA hB) ↑p","decl":"/-- A constructor for a subbimodule which demands closure under the two sets of scalars\nindividually, rather than jointly via their tensor product.\n\nNote that `R` plays no role but it is convenient to make this generalisation to support the cases\n`R = ℕ` and `R = ℤ` which both show up naturally. See also `Subbimodule.baseChange`. -/\n@[simps]\ndef mk (p : AddSubmonoid M) (hA : ∀ (a : A) {m : M}, m ∈ p → a • m ∈ p)\n    (hB : ∀ (b : B) {m : M}, m ∈ p → b • m ∈ p) : Submodule (A ⊗[R] B) M :=\n  { p with\n    carrier := p\n    smul_mem' := fun ab m =>\n      TensorProduct.induction_on ab (fun _ => by simpa only [zero_smul] using p.zero_mem)\n        (fun a b hm => by simpa only [TensorProduct.Algebra.smul_def] using hA a (hB b hm))\n        fun z w hz hw hm => by simpa only [add_smul] using p.add_mem (hz hm) (hw hm) }\n\n"}
{"name":"Subbimodule.smul_mem","module":"Mathlib.Algebra.Module.Bimodule","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : Module R M\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Module A M\ninst✝⁵ : Module B M\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\ninst✝² : IsScalarTower R A M\ninst✝¹ : IsScalarTower R B M\ninst✝ : SMulCommClass A B M\np : Submodule (TensorProduct R A B) M\na : A\nm : M\nhm : Membership.mem p m\n⊢ Membership.mem p (HSMul.hSMul a m)","decl":"theorem smul_mem (p : Submodule (A ⊗[R] B) M) (a : A) {m : M} (hm : m ∈ p) : a • m ∈ p := by\n  suffices a • m = a ⊗ₜ[R] (1 : B) • m by exact this.symm ▸ p.smul_mem _ hm\n  simp [TensorProduct.Algebra.smul_def]\n\n"}
{"name":"Subbimodule.smul_mem'","module":"Mathlib.Algebra.Module.Bimodule","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : Module R M\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Module A M\ninst✝⁵ : Module B M\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\ninst✝² : IsScalarTower R A M\ninst✝¹ : IsScalarTower R B M\ninst✝ : SMulCommClass A B M\np : Submodule (TensorProduct R A B) M\nb : B\nm : M\nhm : Membership.mem p m\n⊢ Membership.mem p (HSMul.hSMul b m)","decl":"theorem smul_mem' (p : Submodule (A ⊗[R] B) M) (b : B) {m : M} (hm : m ∈ p) : b • m ∈ p := by\n  suffices b • m = (1 : A) ⊗ₜ[R] b • m by exact this.symm ▸ p.smul_mem _ hm\n  simp [TensorProduct.Algebra.smul_def]\n\n"}
{"name":"Subbimodule.coe_baseChange","module":"Mathlib.Algebra.Module.Bimodule","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\ninst✝¹⁷ : CommSemiring R\ninst✝¹⁶ : AddCommMonoid M\ninst✝¹⁵ : Module R M\ninst✝¹⁴ : Semiring A\ninst✝¹³ : Semiring B\ninst✝¹² : Module A M\ninst✝¹¹ : Module B M\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Algebra R B\ninst✝⁸ : IsScalarTower R A M\ninst✝⁷ : IsScalarTower R B M\ninst✝⁶ : SMulCommClass A B M\nS : Type u_5\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Module S M\ninst✝³ : Algebra S A\ninst✝² : Algebra S B\ninst✝¹ : IsScalarTower S A M\ninst✝ : IsScalarTower S B M\np : Submodule (TensorProduct R A B) M\n⊢ Eq ↑(Subbimodule.baseChange S p) ↑p","decl":"/-- If `A` and `B` are also `Algebra`s over yet another set of scalars `S` then we may \"base change\"\nfrom `R` to `S`. -/\n@[simps!]\ndef baseChange (S : Type*) [CommSemiring S] [Module S M] [Algebra S A] [Algebra S B]\n    [IsScalarTower S A M] [IsScalarTower S B M] (p : Submodule (A ⊗[R] B) M) :\n    Submodule (A ⊗[S] B) M :=\n  mk p.toAddSubmonoid (smul_mem p) (smul_mem' p)\n\n"}
{"name":"Subbimodule.coe_toSubmodule","module":"Mathlib.Algebra.Module.Bimodule","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : Module R M\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Module A M\ninst✝⁵ : Module B M\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\ninst✝² : IsScalarTower R A M\ninst✝¹ : IsScalarTower R B M\ninst✝ : SMulCommClass A B M\np : Submodule (TensorProduct R A B) M\n⊢ Eq ↑(Subbimodule.toSubmodule p) ↑p","decl":"/-- Forgetting the `B` action, a `Submodule` over `A ⊗[R] B` is just a `Submodule` over `A`. -/\n@[simps]\ndef toSubmodule (p : Submodule (A ⊗[R] B) M) : Submodule A M :=\n  { p with\n    carrier := p\n    smul_mem' := smul_mem p }\n\n"}
{"name":"Subbimodule.coe_toSubmodule'","module":"Mathlib.Algebra.Module.Bimodule","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : Module R M\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Module A M\ninst✝⁵ : Module B M\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\ninst✝² : IsScalarTower R A M\ninst✝¹ : IsScalarTower R B M\ninst✝ : SMulCommClass A B M\np : Submodule (TensorProduct R A B) M\n⊢ Eq ↑(Subbimodule.toSubmodule' p) ↑p","decl":"/-- Forgetting the `A` action, a `Submodule` over `A ⊗[R] B` is just a `Submodule` over `B`. -/\n@[simps]\ndef toSubmodule' (p : Submodule (A ⊗[R] B) M) : Submodule B M :=\n  { p with\n    carrier := p\n    smul_mem' := smul_mem' p }\n\n"}
{"name":"Subbimodule.coe_toSubbimoduleInt","module":"Mathlib.Algebra.Module.Bimodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\ninst✝⁵ : Ring R\ninst✝⁴ : Ring S\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : SMulCommClass R S M\np : Submodule (TensorProduct Nat R S) M\n⊢ Eq ↑(Subbimodule.toSubbimoduleInt R S M p) ↑p","decl":"/-- A `Submodule` over `R ⊗[ℕ] S` is naturally also a `Submodule` over the canonically-isomorphic\nring `R ⊗[ℤ] S`. -/\n@[simps!]\ndef toSubbimoduleInt (p : Submodule (R ⊗[ℕ] S) M) : Submodule (R ⊗[ℤ] S) M :=\n  baseChange ℤ p\n\n"}
{"name":"Subbimodule.coe_toSubbimoduleNat","module":"Mathlib.Algebra.Module.Bimodule","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\ninst✝⁵ : Ring R\ninst✝⁴ : Ring S\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : SMulCommClass R S M\np : Submodule (TensorProduct Int R S) M\n⊢ Eq ↑(Subbimodule.toSubbimoduleNat R S M p) ↑p","decl":"/-- A `Submodule` over `R ⊗[ℤ] S` is naturally also a `Submodule` over the canonically-isomorphic\nring `R ⊗[ℕ] S`. -/\n@[simps!]\ndef toSubbimoduleNat (p : Submodule (R ⊗[ℤ] S) M) : Submodule (R ⊗[ℕ] S) M :=\n  baseChange ℕ p\n\n"}
