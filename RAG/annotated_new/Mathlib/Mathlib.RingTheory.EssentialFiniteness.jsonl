{"name":"Algebra.EssFiniteType.cond","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nself : Algebra.EssFiniteType R S\n⊢ Exists fun s => IsLocalization (Submonoid.comap (algebraMap (Subtype fun x => Membership.mem (Algebra.adjoin R ↑s) x) S) (IsUnit.submonoid S)) S","decl":"/--\nAn `R`-algebra is essentially of finite type if\nit is the localization of an algebra of finite type.\nSee `essFiniteType_iff_exists_subalgebra`.\n-/\nclass EssFiniteType : Prop where\n  cond : ∃ s : Finset S,\n    IsLocalization ((IsUnit.submonoid S).comap (algebraMap (adjoin R (s : Set S)) S)) S\n\n"}
{"name":"Algebra.EssFiniteType.adjoin_mem_finset","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.EssFiniteType R S\n⊢ Eq (Algebra.adjoin R (setOf fun x => Membership.mem (Algebra.EssFiniteType.finset R S) ↑x)) Top.top","decl":"lemma EssFiniteType.adjoin_mem_finset [EssFiniteType R S] :\n    adjoin R { x : subalgebra R S | x.1 ∈ finset R S } = ⊤ := adjoin_adjoin_coe_preimage\n\n"}
{"name":"Algebra.instFiniteTypeSubtypeMemSubalgebraSubalgebra","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.EssFiniteType R S\n⊢ Algebra.FiniteType R (Subtype fun x => Membership.mem (Algebra.EssFiniteType.subalgebra R S) x)","decl":"instance [EssFiniteType R S] : Algebra.FiniteType R (EssFiniteType.subalgebra R S) := by\n  constructor\n  rw [Subalgebra.fg_top, EssFiniteType.subalgebra]\n  exact ⟨_, rfl⟩\n\n"}
{"name":"Algebra.EssFiniteType.isLocalization","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nh : Algebra.EssFiniteType R S\n⊢ IsLocalization (Algebra.EssFiniteType.submonoid R S) S","decl":"instance EssFiniteType.isLocalization [h : EssFiniteType R S] :\n    IsLocalization (EssFiniteType.submonoid R S) S :=\n  h.cond.choose_spec\n\n"}
{"name":"Algebra.essFiniteType_cond_iff","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nσ : Finset S\n⊢ Iff (IsLocalization (Submonoid.comap (algebraMap (Subtype fun x => Membership.mem (Algebra.adjoin R ↑σ) x) S) (IsUnit.submonoid S)) S) (∀ (s : S), Exists fun t => And (Membership.mem (Algebra.adjoin R ↑σ) t) (And (IsUnit t) (Membership.mem (Algebra.adjoin R ↑σ) (HMul.hMul s t))))","decl":"lemma essFiniteType_cond_iff (σ : Finset S) :\n    IsLocalization ((IsUnit.submonoid S).comap (algebraMap (adjoin R (σ : Set S)) S)) S ↔\n    (∀ s : S, ∃ t ∈ Algebra.adjoin R (σ : Set S),\n      IsUnit t ∧ s * t ∈ Algebra.adjoin R (σ : Set S)) := by\n  constructor <;> intro hσ\n  · intro s\n    obtain ⟨⟨⟨x, hx⟩, ⟨t, ht⟩, ht'⟩, h⟩ := hσ.2 s\n    exact ⟨t, ht, ht', h ▸ hx⟩\n  · constructor\n    · exact fun y ↦ y.prop\n    · intro s\n      obtain ⟨t, ht, ht', h⟩ := hσ s\n      exact ⟨⟨⟨_, h⟩, ⟨t, ht⟩, ht'⟩, rfl⟩\n    · intros x y e\n      exact ⟨1, by simpa using Subtype.ext e⟩\n\n"}
{"name":"Algebra.essFiniteType_iff","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Iff (Algebra.EssFiniteType R S) (Exists fun σ => ∀ (s : S), Exists fun t => And (Membership.mem (Algebra.adjoin R ↑σ) t) (And (IsUnit t) (Membership.mem (Algebra.adjoin R ↑σ) (HMul.hMul s t))))","decl":"lemma essFiniteType_iff :\n    EssFiniteType R S ↔ ∃ (σ : Finset S),\n      (∀ s : S, ∃ t ∈ Algebra.adjoin R (σ : Set S),\n        IsUnit t ∧ s * t ∈ Algebra.adjoin R (σ : Set S)) := by\n  simp_rw [← essFiniteType_cond_iff]\n  constructor <;> exact fun ⟨a, b⟩ ↦ ⟨a, b⟩\n\n"}
{"name":"Algebra.EssFiniteType.of_finiteType","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.FiniteType R S\n⊢ Algebra.EssFiniteType R S","decl":"instance EssFiniteType.of_finiteType [FiniteType R S] : EssFiniteType R S := by\n  obtain ⟨s, hs⟩ := ‹FiniteType R S›\n  rw [essFiniteType_iff]\n  exact ⟨s, fun _ ↦ by simpa only [hs, mem_top, and_true, true_and] using ⟨1, isUnit_one⟩⟩\n\n"}
{"name":"Algebra.EssFiniteType.of_isLocalization","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nM : Submonoid R\ninst✝ : IsLocalization M S\n⊢ Algebra.EssFiniteType R S","decl":"variable {R} in\nlemma EssFiniteType.of_isLocalization (M : Submonoid R) [IsLocalization M S] :\n    EssFiniteType R S := by\n  rw [essFiniteType_iff]\n  use ∅\n  simp only [Finset.coe_empty, Algebra.adjoin_empty, exists_and_left, Algebra.mem_bot,\n    Set.mem_range, exists_exists_eq_and]\n  intro s\n  obtain ⟨⟨x, t⟩, e⟩ := IsLocalization.surj M s\n  exact ⟨_, IsLocalization.map_units S t, x, e.symm⟩\n\n"}
{"name":"Algebra.EssFiniteType.of_id","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Algebra.EssFiniteType R R","decl":"lemma EssFiniteType.of_id : EssFiniteType R R := inferInstance\n\n"}
{"name":"Algebra.EssFiniteType.aux","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : CommRing T\ninst✝³ : Algebra R S\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nσ : Subalgebra R S\nhσ : ∀ (s : S), Exists fun t => And (Membership.mem σ t) (And (IsUnit t) (Membership.mem σ (HMul.hMul s t)))\nτ : Set T\nt : T\nht : Membership.mem (Algebra.adjoin S τ) t\n⊢ Exists fun s => And (Membership.mem σ s) (And (IsUnit s) (Membership.mem (Max.max (Subalgebra.map (IsScalarTower.toAlgHom R S T) σ) (Algebra.adjoin R τ)) (HSMul.hSMul s t)))","decl":"lemma EssFiniteType.aux (σ : Subalgebra R S)\n    (hσ : ∀ s : S, ∃ t ∈ σ, IsUnit t ∧ s * t ∈ σ)\n    (τ : Set T) (t : T) (ht : t ∈ Algebra.adjoin S τ) :\n    ∃ s ∈ σ, IsUnit s ∧ s • t ∈ σ.map (IsScalarTower.toAlgHom R S T) ⊔ Algebra.adjoin R τ := by\n  refine Algebra.adjoin_induction ?_ ?_ ?_ ?_ ht\n  · intro t ht\n    exact ⟨1, Subalgebra.one_mem _, isUnit_one,\n      (one_smul S t).symm ▸ Algebra.mem_sup_right (Algebra.subset_adjoin ht)⟩\n  · intro s\n    obtain ⟨s', hs₁, hs₂, hs₃⟩ := hσ s\n    refine ⟨_, hs₁, hs₂, Algebra.mem_sup_left ?_⟩\n    rw [Algebra.smul_def, ← map_mul, mul_comm]\n    exact ⟨_, hs₃, rfl⟩\n  · rintro x y - - ⟨sx, hsx, hsx', hsx''⟩ ⟨sy, hsy, hsy', hsy''⟩\n    refine ⟨_, σ.mul_mem hsx hsy, hsx'.mul hsy', ?_⟩\n    rw [smul_add, mul_smul, mul_smul, Algebra.smul_def sx (sy • y), smul_comm,\n      Algebra.smul_def sy (sx • x)]\n    apply add_mem (mul_mem _ hsx'') (mul_mem _ hsy'') <;>\n      exact Algebra.mem_sup_left ⟨_, ‹_›, rfl⟩\n  · rintro x y - - ⟨sx, hsx, hsx', hsx''⟩ ⟨sy, hsy, hsy', hsy''⟩\n    refine ⟨_, σ.mul_mem hsx hsy, hsx'.mul hsy', ?_⟩\n    rw [mul_smul, ← smul_eq_mul, smul_comm sy x, ← smul_assoc, smul_eq_mul]\n    exact mul_mem hsx'' hsy''\n\n"}
{"name":"Algebra.EssFiniteType.comp","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : CommRing T\ninst✝³ : Algebra R S\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nh₁ : Algebra.EssFiniteType R S\nh₂ : Algebra.EssFiniteType S T\n⊢ Algebra.EssFiniteType R T","decl":"lemma EssFiniteType.comp [h₁ : EssFiniteType R S] [h₂ : EssFiniteType S T] :\n    EssFiniteType R T := by\n  rw [essFiniteType_iff] at h₁ h₂ ⊢\n  classical\n  obtain ⟨s, hs⟩ := h₁\n  obtain ⟨t, ht⟩ := h₂\n  use s.image (IsScalarTower.toAlgHom R S T) ∪ t\n  simp only [Finset.coe_union, Finset.coe_image, Algebra.adjoin_union, Algebra.adjoin_image]\n  intro x\n  obtain ⟨y, hy₁, hy₂, hy₃⟩ := ht x\n  obtain ⟨t₁, h₁, h₂, h₃⟩ := EssFiniteType.aux _ _ _ _ hs _ y hy₁\n  obtain ⟨t₂, h₄, h₅, h₆⟩ := EssFiniteType.aux _ _ _ _ hs _ _ hy₃\n  refine ⟨t₂ • t₁ • y, ?_, ?_, ?_⟩\n  · rw [Algebra.smul_def]\n    exact mul_mem (Algebra.mem_sup_left ⟨_, h₄, rfl⟩) h₃\n  · rw [Algebra.smul_def, Algebra.smul_def]\n    exact (h₅.map _).mul ((h₂.map _).mul hy₂)\n  · rw [← mul_smul, mul_comm, smul_mul_assoc, mul_comm, mul_comm y, mul_smul, Algebra.smul_def]\n    exact mul_mem (Algebra.mem_sup_left ⟨_, h₁, rfl⟩) h₆\n\n"}
{"name":"Algebra.essFiniteType_iff_exists_subalgebra","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Iff (Algebra.EssFiniteType R S) (Exists fun S₀ => Exists fun M => And (Algebra.FiniteType R (Subtype fun x => Membership.mem S₀ x)) (IsLocalization M S))","decl":"open EssFiniteType in\nlemma essFiniteType_iff_exists_subalgebra : EssFiniteType R S ↔\n    ∃ (S₀ : Subalgebra R S) (M : Submonoid S₀), FiniteType R S₀ ∧ IsLocalization M S := by\n  refine ⟨fun h ↦ ⟨subalgebra R S, submonoid R S, inferInstance, inferInstance⟩, ?_⟩\n  rintro ⟨S₀, M, _, _⟩\n  letI := of_isLocalization S M\n  exact comp R S₀ S\n\n"}
{"name":"Algebra.EssFiniteType.baseChange","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing T\ninst✝¹ : Algebra R S\ninst✝ : Algebra R T\nh : Algebra.EssFiniteType R S\n⊢ Algebra.EssFiniteType T (TensorProduct R T S)","decl":"instance EssFiniteType.baseChange [h : EssFiniteType R S] : EssFiniteType T (T ⊗[R] S) := by\n  classical\n  rw [essFiniteType_iff] at h ⊢\n  obtain ⟨σ, hσ⟩ := h\n  use σ.image Algebra.TensorProduct.includeRight\n  intro s\n  induction' s using TensorProduct.induction_on with x y x y hx hy\n  · exact ⟨1, one_mem _, isUnit_one, by simpa using zero_mem _⟩\n  · obtain ⟨t, h₁, h₂, h₃⟩ := hσ y\n    have H (x : S) (hx : x ∈ Algebra.adjoin R (σ : Set S)) :\n        1 ⊗ₜ[R] x ∈ Algebra.adjoin T\n          ((σ.image Algebra.TensorProduct.includeRight : Finset (T ⊗[R] S)) : Set (T ⊗[R] S)) := by\n      have : Algebra.TensorProduct.includeRight x ∈\n          (Algebra.adjoin R (σ : Set S)).map (Algebra.TensorProduct.includeRight (A := T)) :=\n        Subalgebra.mem_map.mpr ⟨_, hx, rfl⟩\n      rw [← Algebra.adjoin_adjoin_of_tower R]\n      apply Algebra.subset_adjoin\n      simpa [← Algebra.adjoin_image] using this\n    refine ⟨Algebra.TensorProduct.includeRight t, H _ h₁, h₂.map _, ?_⟩\n    simp only [Algebra.TensorProduct.includeRight_apply, Algebra.TensorProduct.tmul_mul_tmul,\n      mul_one]\n    rw [← mul_one x, ← smul_eq_mul, ← TensorProduct.smul_tmul']\n    apply Subalgebra.smul_mem\n    exact H _ h₃\n  · obtain ⟨tx, hx₁, hx₂, hx₃⟩ := hx\n    obtain ⟨ty, hy₁, hy₂, hy₃⟩ := hy\n    refine ⟨_, mul_mem hx₁ hy₁, hx₂.mul hy₂, ?_⟩\n    rw [add_mul, ← mul_assoc, mul_comm tx ty, ← mul_assoc]\n    exact add_mem (mul_mem hx₃ hy₁) (mul_mem hy₃ hx₁)\n\n"}
{"name":"Algebra.EssFiniteType.of_comp","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : CommRing T\ninst✝³ : Algebra R S\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nh : Algebra.EssFiniteType R T\n⊢ Algebra.EssFiniteType S T","decl":"lemma EssFiniteType.of_comp [h : EssFiniteType R T] : EssFiniteType S T := by\n  rw [essFiniteType_iff] at h ⊢\n  classical\n  obtain ⟨σ, hσ⟩ := h\n  use σ\n  intro x\n  obtain ⟨y, hy₁, hy₂, hy₃⟩ := hσ x\n  simp_rw [← Algebra.adjoin_adjoin_of_tower R (S := S) (σ : Set T)]\n  exact ⟨y, Algebra.subset_adjoin hy₁, hy₂, Algebra.subset_adjoin hy₃⟩\n\n"}
{"name":"Algebra.EssFiniteType.comp_iff","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : CommRing T\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra R T\ninst✝² : Algebra S T\ninst✝¹ : IsScalarTower R S T\ninst✝ : Algebra.EssFiniteType R S\n⊢ Iff (Algebra.EssFiniteType R T) (Algebra.EssFiniteType S T)","decl":"lemma EssFiniteType.comp_iff [EssFiniteType R S] :\n    EssFiniteType R T ↔ EssFiniteType S T :=\n  ⟨fun _ ↦ of_comp R S T, fun _ ↦ comp R S T⟩\n\n"}
{"name":"Algebra.EssFiniteType.algHom_ext","module":"Mathlib.RingTheory.EssentialFiniteness","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : CommRing T\ninst✝² : Algebra R S\ninst✝¹ : Algebra R T\ninst✝ : Algebra.EssFiniteType R S\nf g : AlgHom R S T\nH : ∀ (s : S), Membership.mem (Algebra.EssFiniteType.finset R S) s → Eq (f s) (g s)\n⊢ Eq f g","decl":"variable {R S} in\nlemma EssFiniteType.algHom_ext [EssFiniteType R S]\n    (f g : S →ₐ[R] T) (H : ∀ s ∈ finset R S, f s = g s) : f = g := by\n  suffices f.toRingHom = g.toRingHom by ext; exact RingHom.congr_fun this _\n  apply IsLocalization.ringHom_ext (EssFiniteType.submonoid R S)\n  suffices f.comp (IsScalarTower.toAlgHom R _ S) = g.comp (IsScalarTower.toAlgHom R _ S) by\n    ext; exact AlgHom.congr_fun this _\n  apply AlgHom.ext_of_adjoin_eq_top (s := { x | x.1 ∈ finset R S })\n  · rw [← top_le_iff]\n    rintro ⟨x, hx⟩ _\n    refine Algebra.adjoin_induction ?_ ?_ ?_ ?_ hx\n    · intro x hx; exact Algebra.subset_adjoin hx\n    · intro r; exact Subalgebra.algebraMap_mem _ _\n    · intro x y _ _ hx hy; exact add_mem hx hy\n    · intro x y _ _ hx hy; exact mul_mem hx hy\n  · rintro ⟨x, hx⟩ hx'; exact H x hx'\n\n"}
