{"name":"CategoryTheory.InjectiveResolution.exact₀","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\n⊢ (CategoryTheory.ShortComplex.mk (I.ι.f 0) (I.cocomplex.d 0 1) ⋯).Exact","decl":"lemma exact₀ {Z : C} (I : InjectiveResolution Z) :\n    (ShortComplex.mk _ _ I.ι_f_zero_comp_complex_d).Exact :=\n  ShortComplex.exact_of_f_is_kernel _ I.isLimitKernelFork\n\n"}
{"name":"CategoryTheory.InjectiveResolution.descFOne_zero_comm","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z : C\nf : Quiver.Hom Z Y\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (J.cocomplex.d 0 1) (CategoryTheory.InjectiveResolution.descFOne f I J)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.descFZero f I J) (I.cocomplex.d 0 1))","decl":"@[simp]\ntheorem descFOne_zero_comm {Y Z : C} (f : Z ⟶ Y) (I : InjectiveResolution Y)\n    (J : InjectiveResolution Z) :\n    J.cocomplex.d 0 1 ≫ descFOne f I J = descFZero f I J ≫ I.cocomplex.d 0 1 := by\n  apply J.exact₀.comp_descToInjective\n\n"}
{"name":"CategoryTheory.InjectiveResolution.desc_commutes_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z✝ : C\nf : Quiver.Hom Z✝ Y\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z✝\nZ : CochainComplex C Nat\nh : Quiver.Hom I.cocomplex Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp J.ι (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.desc f I J) h)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.single₀ C).map f) (CategoryTheory.CategoryStruct.comp I.ι h))","decl":"/-- The resolution maps intertwine the descent of a morphism and that morphism. -/\n@[reassoc (attr := simp)]\ntheorem desc_commutes {Y Z : C} (f : Z ⟶ Y) (I : InjectiveResolution Y)\n    (J : InjectiveResolution Z) : J.ι ≫ desc f I J = (CochainComplex.single₀ C).map f ≫ I.ι := by\n  ext\n  simp [desc, descFOne, descFZero]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.desc_commutes","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z : C\nf : Quiver.Hom Z Y\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp J.ι (CategoryTheory.InjectiveResolution.desc f I J)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.single₀ C).map f) I.ι)","decl":"/-- The resolution maps intertwine the descent of a morphism and that morphism. -/\n@[reassoc (attr := simp)]\ntheorem desc_commutes {Y Z : C} (f : Z ⟶ Y) (I : InjectiveResolution Y)\n    (J : InjectiveResolution Z) : J.ι ≫ desc f I J = (CochainComplex.single₀ C).map f ≫ I.ι := by\n  ext\n  simp [desc, descFOne, descFZero]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.desc_commutes_zero_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z✝ : C\nf : Quiver.Hom Z✝ Y\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z✝\nZ : C\nh : Quiver.Hom (I.cocomplex.X 0) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (J.ι.f 0) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.InjectiveResolution.desc f I J).f 0) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (I.ι.f 0) h))","decl":"@[reassoc (attr := simp)]\nlemma desc_commutes_zero {Y Z : C} (f : Z ⟶ Y)\n    (I : InjectiveResolution Y) (J : InjectiveResolution Z) :\n    J.ι.f 0 ≫ (desc f I J).f 0 = f ≫ I.ι.f 0 :=\n  (HomologicalComplex.congr_hom (desc_commutes f I J) 0).trans (by simp)\n\n-- Now that we've checked this property of the descent, we can seal away the actual definition.\n"}
{"name":"CategoryTheory.InjectiveResolution.desc_commutes_zero","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z : C\nf : Quiver.Hom Z Y\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (J.ι.f 0) ((CategoryTheory.InjectiveResolution.desc f I J).f 0)) (CategoryTheory.CategoryStruct.comp f (I.ι.f 0))","decl":"@[reassoc (attr := simp)]\nlemma desc_commutes_zero {Y Z : C} (f : Z ⟶ Y)\n    (I : InjectiveResolution Y) (J : InjectiveResolution Z) :\n    J.ι.f 0 ≫ (desc f I J).f 0 = f ≫ I.ι.f 0 :=\n  (HomologicalComplex.congr_hom (desc_commutes f I J) 0).trans (by simp)\n\n-- Now that we've checked this property of the descent, we can seal away the actual definition.\n"}
{"name":"CategoryTheory.InjectiveResolution.comp_descHomotopyZeroZero_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z✝ : C\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z✝\nf : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp I.ι f) 0\nZ : C\nh : Quiver.Hom (J.cocomplex.X 0) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d 0 1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.descHomotopyZeroZero f comm) h)) (CategoryTheory.CategoryStruct.comp (f.f 0) h)","decl":"@[reassoc (attr := simp)]\nlemma comp_descHomotopyZeroZero {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex ⟶ J.cocomplex) (comm : I.ι ≫ f = 0) :\n    I.cocomplex.d 0 1 ≫ descHomotopyZeroZero f comm = f.f 0 :=\n  I.exact₀.comp_descToInjective  _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.comp_descHomotopyZeroZero","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z : C\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z\nf : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp I.ι f) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d 0 1) (CategoryTheory.InjectiveResolution.descHomotopyZeroZero f comm)) (f.f 0)","decl":"@[reassoc (attr := simp)]\nlemma comp_descHomotopyZeroZero {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex ⟶ J.cocomplex) (comm : I.ι ≫ f = 0) :\n    I.cocomplex.d 0 1 ≫ descHomotopyZeroZero f comm = f.f 0 :=\n  I.exact₀.comp_descToInjective  _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.comp_descHomotopyZeroOne_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z✝ : C\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z✝\nf : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp I.ι f) 0\nZ : C\nh : Quiver.Hom (J.cocomplex.X 1) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d 1 2) (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.descHomotopyZeroOne f comm) h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (f.f 1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.descHomotopyZeroZero f comm) (J.cocomplex.d 0 1))) h)","decl":"@[reassoc (attr := simp)]\nlemma comp_descHomotopyZeroOne {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex ⟶ J.cocomplex) (comm : I.ι ≫ f = (0 : _ ⟶ J.cocomplex)) :\n    I.cocomplex.d 1 2 ≫ descHomotopyZeroOne f comm =\n      f.f 1 - descHomotopyZeroZero f comm ≫ J.cocomplex.d 0 1 :=\n  (I.exact_succ 0).comp_descToInjective _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.comp_descHomotopyZeroOne","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z : C\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z\nf : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp I.ι f) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d 1 2) (CategoryTheory.InjectiveResolution.descHomotopyZeroOne f comm)) (HSub.hSub (f.f 1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.descHomotopyZeroZero f comm) (J.cocomplex.d 0 1)))","decl":"@[reassoc (attr := simp)]\nlemma comp_descHomotopyZeroOne {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex ⟶ J.cocomplex) (comm : I.ι ≫ f = (0 : _ ⟶ J.cocomplex)) :\n    I.cocomplex.d 1 2 ≫ descHomotopyZeroOne f comm =\n      f.f 1 - descHomotopyZeroZero f comm ≫ J.cocomplex.d 0 1 :=\n  (I.exact_succ 0).comp_descToInjective _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.comp_descHomotopyZeroSucc_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z✝ : C\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z✝\nf : Quiver.Hom I.cocomplex J.cocomplex\nn : Nat\ng : Quiver.Hom (I.cocomplex.X (HAdd.hAdd n 1)) (J.cocomplex.X n)\ng' : Quiver.Hom (I.cocomplex.X (HAdd.hAdd n 2)) (J.cocomplex.X (HAdd.hAdd n 1))\nw : Eq (f.f (HAdd.hAdd n 1)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (I.cocomplex.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)) g') (CategoryTheory.CategoryStruct.comp g (J.cocomplex.d n (HAdd.hAdd n 1))))\nZ : C\nh : Quiver.Hom (J.cocomplex.X (HAdd.hAdd n 2)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d (HAdd.hAdd n 2) (HAdd.hAdd n 3)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.descHomotopyZeroSucc f n g g' w) h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (f.f (HAdd.hAdd n 2)) (CategoryTheory.CategoryStruct.comp g' (J.cocomplex.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)))) h)","decl":"@[reassoc (attr := simp)]\nlemma comp_descHomotopyZeroSucc {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex ⟶ J.cocomplex) (n : ℕ) (g : I.cocomplex.X (n + 1) ⟶ J.cocomplex.X n)\n    (g' : I.cocomplex.X (n + 2) ⟶ J.cocomplex.X (n + 1))\n    (w : f.f (n + 1) = I.cocomplex.d (n + 1) (n + 2) ≫ g' + g ≫ J.cocomplex.d n (n + 1)) :\n    I.cocomplex.d (n+2) (n+3) ≫ descHomotopyZeroSucc f n g g' w =\n      f.f (n + 2) - g' ≫ J.cocomplex.d _ _ :=\n  (I.exact_succ (n+1)).comp_descToInjective  _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.comp_descHomotopyZeroSucc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nY Z : C\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z\nf : Quiver.Hom I.cocomplex J.cocomplex\nn : Nat\ng : Quiver.Hom (I.cocomplex.X (HAdd.hAdd n 1)) (J.cocomplex.X n)\ng' : Quiver.Hom (I.cocomplex.X (HAdd.hAdd n 2)) (J.cocomplex.X (HAdd.hAdd n 1))\nw : Eq (f.f (HAdd.hAdd n 1)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (I.cocomplex.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)) g') (CategoryTheory.CategoryStruct.comp g (J.cocomplex.d n (HAdd.hAdd n 1))))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d (HAdd.hAdd n 2) (HAdd.hAdd n 3)) (CategoryTheory.InjectiveResolution.descHomotopyZeroSucc f n g g' w)) (HSub.hSub (f.f (HAdd.hAdd n 2)) (CategoryTheory.CategoryStruct.comp g' (J.cocomplex.d (HAdd.hAdd n 1) (HAdd.hAdd n 2))))","decl":"@[reassoc (attr := simp)]\nlemma comp_descHomotopyZeroSucc {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex ⟶ J.cocomplex) (n : ℕ) (g : I.cocomplex.X (n + 1) ⟶ J.cocomplex.X n)\n    (g' : I.cocomplex.X (n + 2) ⟶ J.cocomplex.X (n + 1))\n    (w : f.f (n + 1) = I.cocomplex.d (n + 1) (n + 2) ≫ g' + g ≫ J.cocomplex.d n (n + 1)) :\n    I.cocomplex.d (n+2) (n+3) ≫ descHomotopyZeroSucc f n g g' w =\n      f.f (n + 2) - g' ≫ J.cocomplex.d _ _ :=\n  (I.exact_succ (n+1)).comp_descToInjective  _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.homotopyEquiv_hom_ι_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX : C\nI J : CategoryTheory.InjectiveResolution X\nZ : CochainComplex C Nat\nh : Quiver.Hom J.cocomplex Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp I.ι (CategoryTheory.CategoryStruct.comp (I.homotopyEquiv J).hom h)) (CategoryTheory.CategoryStruct.comp J.ι h)","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_hom_ι {X : C} (I J : InjectiveResolution X) :\n    I.ι ≫ (homotopyEquiv I J).hom = J.ι := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.homotopyEquiv_hom_ι","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX : C\nI J : CategoryTheory.InjectiveResolution X\n⊢ Eq (CategoryTheory.CategoryStruct.comp I.ι (I.homotopyEquiv J).hom) J.ι","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_hom_ι {X : C} (I J : InjectiveResolution X) :\n    I.ι ≫ (homotopyEquiv I J).hom = J.ι := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.homotopyEquiv_inv_ι_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX : C\nI J : CategoryTheory.InjectiveResolution X\nZ : CochainComplex C Nat\nh : Quiver.Hom I.cocomplex Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp J.ι (CategoryTheory.CategoryStruct.comp (I.homotopyEquiv J).inv h)) (CategoryTheory.CategoryStruct.comp I.ι h)","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_inv_ι {X : C} (I J : InjectiveResolution X) :\n    J.ι ≫ (homotopyEquiv I J).inv = I.ι := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.homotopyEquiv_inv_ι","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX : C\nI J : CategoryTheory.InjectiveResolution X\n⊢ Eq (CategoryTheory.CategoryStruct.comp J.ι (I.homotopyEquiv J).inv) I.ι","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_inv_ι {X : C} (I J : InjectiveResolution X) :\n    J.ι ≫ (homotopyEquiv I J).inv = I.ι := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.iso_hom_naturality","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasInjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.ι.f 0))\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.injectiveResolutions C).map f) J.iso.hom) (CategoryTheory.CategoryStruct.comp I.iso.hom ((HomotopyCategory.quotient C (ComplexShape.up Nat)).map φ))","decl":"@[reassoc]\nlemma InjectiveResolution.iso_hom_naturality {X Y : C} (f : X ⟶ Y)\n    (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (φ : I.cocomplex ⟶ J.cocomplex) (comm : I.ι.f 0 ≫ φ.f 0 = f ≫ J.ι.f 0) :\n    (injectiveResolutions C).map f ≫ J.iso.hom =\n      I.iso.hom ≫ (HomotopyCategory.quotient _ _).map φ := by\n  apply HomotopyCategory.eq_of_homotopy\n  apply descHomotopy f\n  all_goals aesop\n\n"}
{"name":"CategoryTheory.InjectiveResolution.iso_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasInjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.ι.f 0))\nZ : HomotopyCategory C (ComplexShape.up Nat)\nh : Quiver.Hom ((HomotopyCategory.quotient C (ComplexShape.up Nat)).obj J.cocomplex) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.injectiveResolutions C).map f) (CategoryTheory.CategoryStruct.comp J.iso.hom h)) (CategoryTheory.CategoryStruct.comp I.iso.hom (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Nat)).map φ) h))","decl":"@[reassoc]\nlemma InjectiveResolution.iso_hom_naturality {X Y : C} (f : X ⟶ Y)\n    (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (φ : I.cocomplex ⟶ J.cocomplex) (comm : I.ι.f 0 ≫ φ.f 0 = f ≫ J.ι.f 0) :\n    (injectiveResolutions C).map f ≫ J.iso.hom =\n      I.iso.hom ≫ (HomotopyCategory.quotient _ _).map φ := by\n  apply HomotopyCategory.eq_of_homotopy\n  apply descHomotopy f\n  all_goals aesop\n\n"}
{"name":"CategoryTheory.InjectiveResolution.iso_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasInjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.ι.f 0))\nZ : HomotopyCategory C (ComplexShape.up Nat)\nh : Quiver.Hom ((CategoryTheory.injectiveResolutions C).obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp I.iso.inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.injectiveResolutions C).map f) h)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Nat)).map φ) (CategoryTheory.CategoryStruct.comp J.iso.inv h))","decl":"@[reassoc]\nlemma InjectiveResolution.iso_inv_naturality {X Y : C} (f : X ⟶ Y)\n    (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (φ : I.cocomplex ⟶ J.cocomplex) (comm : I.ι.f 0 ≫ φ.f 0 = f ≫ J.ι.f 0) :\n    I.iso.inv ≫ (injectiveResolutions C).map f =\n      (HomotopyCategory.quotient _ _).map φ ≫ J.iso.inv := by\n  rw [← cancel_mono (J.iso).hom, Category.assoc, iso_hom_naturality f I J φ comm,\n    Iso.inv_hom_id_assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.iso_inv_naturality","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.HasInjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.ι.f 0))\n⊢ Eq (CategoryTheory.CategoryStruct.comp I.iso.inv ((CategoryTheory.injectiveResolutions C).map f)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Nat)).map φ) J.iso.inv)","decl":"@[reassoc]\nlemma InjectiveResolution.iso_inv_naturality {X Y : C} (f : X ⟶ Y)\n    (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (φ : I.cocomplex ⟶ J.cocomplex) (comm : I.ι.f 0 ≫ φ.f 0 = f ≫ J.ι.f 0) :\n    I.iso.inv ≫ (injectiveResolutions C).map f =\n      (HomotopyCategory.quotient _ _).map φ ≫ J.iso.inv := by\n  rw [← cancel_mono (J.iso).hom, Category.assoc, iso_hom_naturality f I J φ comm,\n    Iso.inv_hom_id_assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id]\n\n"}
{"name":"CategoryTheory.exact_f_d","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughInjectives C\nX Y : C\nf : Quiver.Hom X Y\n⊢ (CategoryTheory.ShortComplex.mk f (CategoryTheory.Injective.d f) ⋯).Exact","decl":"theorem exact_f_d {X Y : C} (f : X ⟶ Y) :\n    (ShortComplex.mk f (d f) (by simp)).Exact := by\n  let α : ShortComplex.mk f (cokernel.π f) (by simp) ⟶ ShortComplex.mk f (d f) (by simp) :=\n    { τ₁ := 𝟙 _\n      τ₂ := 𝟙 _\n      τ₃ := Injective.ι _  }\n  have : Epi α.τ₁ := by dsimp; infer_instance\n  have : IsIso α.τ₂ := by dsimp; infer_instance\n  have : Mono α.τ₃ := by dsimp; infer_instance\n  rw [← ShortComplex.exact_iff_of_epi_of_isIso_of_mono α]\n  apply ShortComplex.exact_of_g_is_cokernel\n  apply cokernelIsCokernel\n\n"}
{"name":"CategoryTheory.InjectiveResolution.ofCocomplex_d_0_1","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughInjectives C\nZ : C\n⊢ Eq ((CategoryTheory.InjectiveResolution.ofCocomplex Z).d 0 1) (CategoryTheory.Injective.d (CategoryTheory.Injective.ι Z))","decl":"lemma ofCocomplex_d_0_1 :\n    (ofCocomplex Z).d 0 1 = d (Injective.ι Z) := by\n  simp [ofCocomplex]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.ofCocomplex_exactAt_succ","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughInjectives C\nZ : C\nn : Nat\n⊢ HomologicalComplex.ExactAt (CategoryTheory.InjectiveResolution.ofCocomplex Z) (HAdd.hAdd n 1)","decl":"lemma ofCocomplex_exactAt_succ (n : ℕ) :\n    (ofCocomplex Z).ExactAt (n + 1) := by\n  rw [HomologicalComplex.exactAt_iff' _ n (n + 1) (n + 1 + 1) (by simp) (by simp)]\n  dsimp [ofCocomplex, CochainComplex.mk', CochainComplex.mk, HomologicalComplex.sc',\n      HomologicalComplex.shortComplexFunctor']\n  simp only [CochainComplex.of_d]\n  match n with\n  | 0 => apply exact_f_d ((CochainComplex.mkAux _ _ _\n      (d (Injective.ι Z)) (d (d (Injective.ι Z))) _ _ 0).f)\n  | n+1 => apply exact_f_d ((CochainComplex.mkAux _ _ _\n      (d (Injective.ι Z)) (d (d (Injective.ι Z))) _ _ (n+1)).f)\n\n"}
{"name":"CategoryTheory.InjectiveResolution.instInjectiveXNatOfCocomplex","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughInjectives C\nZ : C\nn : Nat\n⊢ CategoryTheory.Injective ((CategoryTheory.InjectiveResolution.ofCocomplex Z).X n)","decl":"instance (n : ℕ) : Injective ((ofCocomplex Z).X n) := by\n  obtain (_ | _ | _ | n) := n <;> apply Injective.injective_under\n\n"}
{"name":"CategoryTheory.InjectiveResolution.of_def","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughInjectives C\nZ : C\n⊢ Eq (CategoryTheory.InjectiveResolution.of Z) (CategoryTheory.InjectiveResolution.mk (CategoryTheory.InjectiveResolution.ofCocomplex Z) ⋯ (((CategoryTheory.InjectiveResolution.ofCocomplex Z).fromSingle₀Equiv Z).symm ⟨CategoryTheory.Injective.ι Z, ⋯⟩) ⋯)","decl":"/-- In any abelian category with enough injectives,\n`InjectiveResolution.of Z` constructs an injective resolution of the object `Z`.\n-/\nirreducible_def of : InjectiveResolution Z where\n  cocomplex := ofCocomplex Z\n  ι := (CochainComplex.fromSingle₀Equiv _ _).symm ⟨Injective.ι Z,\n    by rw [ofCocomplex_d_0_1, cokernel.condition_assoc, zero_comp]⟩\n  quasiIso := ⟨fun n => by\n    cases n\n    · rw [CochainComplex.quasiIsoAt₀_iff, ShortComplex.quasiIso_iff_of_zeros]\n      · refine (ShortComplex.exact_and_mono_f_iff_of_iso ?_).2\n          ⟨exact_f_d (Injective.ι Z), by dsimp; infer_instance⟩\n        exact ShortComplex.isoMk (Iso.refl _) (Iso.refl _) (Iso.refl _) (by simp)\n          (by simp [ofCocomplex])\n      all_goals rfl\n    · rw [quasiIsoAt_iff_exactAt]\n      · apply ofCocomplex_exactAt_succ\n      · apply CochainComplex.exactAt_succ_single_obj⟩\n\n"}
{"name":"CategoryTheory.InjectiveResolution.instHasInjectiveResolution","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughInjectives C\nZ : C\n⊢ CategoryTheory.HasInjectiveResolution Z","decl":"instance (priority := 100) (Z : C) : HasInjectiveResolution Z where out := ⟨of Z⟩\n\n"}
{"name":"CategoryTheory.InjectiveResolution.instHasInjectiveResolutions","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : CategoryTheory.EnoughInjectives C\n⊢ CategoryTheory.HasInjectiveResolutions C","decl":"instance (priority := 100) : HasInjectiveResolutions C where out _ := inferInstance\n\n"}
