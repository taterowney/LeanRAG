{"name":"CategoryTheory.InjectiveResolution.exact‚ÇÄ","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nZ : C\nI : CategoryTheory.InjectiveResolution Z\n‚ä¢ (CategoryTheory.ShortComplex.mk (I.Œπ.f 0) (I.cocomplex.d 0 1) ‚ãØ).Exact","decl":"lemma exact‚ÇÄ {Z : C} (I : InjectiveResolution Z) :\n    (ShortComplex.mk _ _ I.Œπ_f_zero_comp_complex_d).Exact :=\n  ShortComplex.exact_of_f_is_kernel _ I.isLimitKernelFork\n\n"}
{"name":"CategoryTheory.InjectiveResolution.descFOne_zero_comm","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z : C\nf : Quiver.Hom Z Y\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (J.cocomplex.d 0 1) (CategoryTheory.InjectiveResolution.descFOne f I J)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.descFZero f I J) (I.cocomplex.d 0 1))","decl":"@[simp]\ntheorem descFOne_zero_comm {Y Z : C} (f : Z ‚ü∂ Y) (I : InjectiveResolution Y)\n    (J : InjectiveResolution Z) :\n    J.cocomplex.d 0 1 ‚â´ descFOne f I J = descFZero f I J ‚â´ I.cocomplex.d 0 1 := by\n  apply J.exact‚ÇÄ.comp_descToInjective\n\n"}
{"name":"CategoryTheory.InjectiveResolution.desc_commutes_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z‚úù : C\nf : Quiver.Hom Z‚úù Y\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z‚úù\nZ : CochainComplex C Nat\nh : Quiver.Hom I.cocomplex Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp J.Œπ (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.desc f I J) h)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.single‚ÇÄ C).map f) (CategoryTheory.CategoryStruct.comp I.Œπ h))","decl":"/-- The resolution maps intertwine the descent of a morphism and that morphism. -/\n@[reassoc (attr := simp)]\ntheorem desc_commutes {Y Z : C} (f : Z ‚ü∂ Y) (I : InjectiveResolution Y)\n    (J : InjectiveResolution Z) : J.Œπ ‚â´ desc f I J = (CochainComplex.single‚ÇÄ C).map f ‚â´ I.Œπ := by\n  ext\n  simp [desc, descFOne, descFZero]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.desc_commutes","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z : C\nf : Quiver.Hom Z Y\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp J.Œπ (CategoryTheory.InjectiveResolution.desc f I J)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.single‚ÇÄ C).map f) I.Œπ)","decl":"/-- The resolution maps intertwine the descent of a morphism and that morphism. -/\n@[reassoc (attr := simp)]\ntheorem desc_commutes {Y Z : C} (f : Z ‚ü∂ Y) (I : InjectiveResolution Y)\n    (J : InjectiveResolution Z) : J.Œπ ‚â´ desc f I J = (CochainComplex.single‚ÇÄ C).map f ‚â´ I.Œπ := by\n  ext\n  simp [desc, descFOne, descFZero]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.desc_commutes_zero_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z‚úù : C\nf : Quiver.Hom Z‚úù Y\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z‚úù\nZ : C\nh : Quiver.Hom (I.cocomplex.X 0) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (J.Œπ.f 0) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.InjectiveResolution.desc f I J).f 0) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) h))","decl":"@[reassoc (attr := simp)]\nlemma desc_commutes_zero {Y Z : C} (f : Z ‚ü∂ Y)\n    (I : InjectiveResolution Y) (J : InjectiveResolution Z) :\n    J.Œπ.f 0 ‚â´ (desc f I J).f 0 = f ‚â´ I.Œπ.f 0 :=\n  (HomologicalComplex.congr_hom (desc_commutes f I J) 0).trans (by simp)\n\n-- Now that we've checked this property of the descent, we can seal away the actual definition.\n"}
{"name":"CategoryTheory.InjectiveResolution.desc_commutes_zero","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z : C\nf : Quiver.Hom Z Y\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (J.Œπ.f 0) ((CategoryTheory.InjectiveResolution.desc f I J).f 0)) (CategoryTheory.CategoryStruct.comp f (I.Œπ.f 0))","decl":"@[reassoc (attr := simp)]\nlemma desc_commutes_zero {Y Z : C} (f : Z ‚ü∂ Y)\n    (I : InjectiveResolution Y) (J : InjectiveResolution Z) :\n    J.Œπ.f 0 ‚â´ (desc f I J).f 0 = f ‚â´ I.Œπ.f 0 :=\n  (HomologicalComplex.congr_hom (desc_commutes f I J) 0).trans (by simp)\n\n-- Now that we've checked this property of the descent, we can seal away the actual definition.\n"}
{"name":"CategoryTheory.InjectiveResolution.comp_descHomotopyZeroZero_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z‚úù : C\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z‚úù\nf : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp I.Œπ f) 0\nZ : C\nh : Quiver.Hom (J.cocomplex.X 0) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d 0 1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.descHomotopyZeroZero f comm) h)) (CategoryTheory.CategoryStruct.comp (f.f 0) h)","decl":"@[reassoc (attr := simp)]\nlemma comp_descHomotopyZeroZero {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ ‚â´ f = 0) :\n    I.cocomplex.d 0 1 ‚â´ descHomotopyZeroZero f comm = f.f 0 :=\n  I.exact‚ÇÄ.comp_descToInjective  _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.comp_descHomotopyZeroZero","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z : C\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z\nf : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp I.Œπ f) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d 0 1) (CategoryTheory.InjectiveResolution.descHomotopyZeroZero f comm)) (f.f 0)","decl":"@[reassoc (attr := simp)]\nlemma comp_descHomotopyZeroZero {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ ‚â´ f = 0) :\n    I.cocomplex.d 0 1 ‚â´ descHomotopyZeroZero f comm = f.f 0 :=\n  I.exact‚ÇÄ.comp_descToInjective  _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.comp_descHomotopyZeroOne_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z‚úù : C\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z‚úù\nf : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp I.Œπ f) 0\nZ : C\nh : Quiver.Hom (J.cocomplex.X 1) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d 1 2) (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.descHomotopyZeroOne f comm) h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (f.f 1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.descHomotopyZeroZero f comm) (J.cocomplex.d 0 1))) h)","decl":"@[reassoc (attr := simp)]\nlemma comp_descHomotopyZeroOne {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ ‚â´ f = (0 : _ ‚ü∂ J.cocomplex)) :\n    I.cocomplex.d 1 2 ‚â´ descHomotopyZeroOne f comm =\n      f.f 1 - descHomotopyZeroZero f comm ‚â´ J.cocomplex.d 0 1 :=\n  (I.exact_succ 0).comp_descToInjective _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.comp_descHomotopyZeroOne","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z : C\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z\nf : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp I.Œπ f) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d 1 2) (CategoryTheory.InjectiveResolution.descHomotopyZeroOne f comm)) (HSub.hSub (f.f 1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.descHomotopyZeroZero f comm) (J.cocomplex.d 0 1)))","decl":"@[reassoc (attr := simp)]\nlemma comp_descHomotopyZeroOne {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ ‚â´ f = (0 : _ ‚ü∂ J.cocomplex)) :\n    I.cocomplex.d 1 2 ‚â´ descHomotopyZeroOne f comm =\n      f.f 1 - descHomotopyZeroZero f comm ‚â´ J.cocomplex.d 0 1 :=\n  (I.exact_succ 0).comp_descToInjective _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.comp_descHomotopyZeroSucc_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z‚úù : C\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z‚úù\nf : Quiver.Hom I.cocomplex J.cocomplex\nn : Nat\ng : Quiver.Hom (I.cocomplex.X (HAdd.hAdd n 1)) (J.cocomplex.X n)\ng' : Quiver.Hom (I.cocomplex.X (HAdd.hAdd n 2)) (J.cocomplex.X (HAdd.hAdd n 1))\nw : Eq (f.f (HAdd.hAdd n 1)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (I.cocomplex.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)) g') (CategoryTheory.CategoryStruct.comp g (J.cocomplex.d n (HAdd.hAdd n 1))))\nZ : C\nh : Quiver.Hom (J.cocomplex.X (HAdd.hAdd n 2)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d (HAdd.hAdd n 2) (HAdd.hAdd n 3)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.InjectiveResolution.descHomotopyZeroSucc f n g g' w) h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (f.f (HAdd.hAdd n 2)) (CategoryTheory.CategoryStruct.comp g' (J.cocomplex.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)))) h)","decl":"@[reassoc (attr := simp)]\nlemma comp_descHomotopyZeroSucc {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex ‚ü∂ J.cocomplex) (n : ‚Ñï) (g : I.cocomplex.X (n + 1) ‚ü∂ J.cocomplex.X n)\n    (g' : I.cocomplex.X (n + 2) ‚ü∂ J.cocomplex.X (n + 1))\n    (w : f.f (n + 1) = I.cocomplex.d (n + 1) (n + 2) ‚â´ g' + g ‚â´ J.cocomplex.d n (n + 1)) :\n    I.cocomplex.d (n+2) (n+3) ‚â´ descHomotopyZeroSucc f n g g' w =\n      f.f (n + 2) - g' ‚â´ J.cocomplex.d _ _ :=\n  (I.exact_succ (n+1)).comp_descToInjective  _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.comp_descHomotopyZeroSucc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nY Z : C\nI : CategoryTheory.InjectiveResolution Y\nJ : CategoryTheory.InjectiveResolution Z\nf : Quiver.Hom I.cocomplex J.cocomplex\nn : Nat\ng : Quiver.Hom (I.cocomplex.X (HAdd.hAdd n 1)) (J.cocomplex.X n)\ng' : Quiver.Hom (I.cocomplex.X (HAdd.hAdd n 2)) (J.cocomplex.X (HAdd.hAdd n 1))\nw : Eq (f.f (HAdd.hAdd n 1)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (I.cocomplex.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)) g') (CategoryTheory.CategoryStruct.comp g (J.cocomplex.d n (HAdd.hAdd n 1))))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (I.cocomplex.d (HAdd.hAdd n 2) (HAdd.hAdd n 3)) (CategoryTheory.InjectiveResolution.descHomotopyZeroSucc f n g g' w)) (HSub.hSub (f.f (HAdd.hAdd n 2)) (CategoryTheory.CategoryStruct.comp g' (J.cocomplex.d (HAdd.hAdd n 1) (HAdd.hAdd n 2))))","decl":"@[reassoc (attr := simp)]\nlemma comp_descHomotopyZeroSucc {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex ‚ü∂ J.cocomplex) (n : ‚Ñï) (g : I.cocomplex.X (n + 1) ‚ü∂ J.cocomplex.X n)\n    (g' : I.cocomplex.X (n + 2) ‚ü∂ J.cocomplex.X (n + 1))\n    (w : f.f (n + 1) = I.cocomplex.d (n + 1) (n + 2) ‚â´ g' + g ‚â´ J.cocomplex.d n (n + 1)) :\n    I.cocomplex.d (n+2) (n+3) ‚â´ descHomotopyZeroSucc f n g g' w =\n      f.f (n + 2) - g' ‚â´ J.cocomplex.d _ _ :=\n  (I.exact_succ (n+1)).comp_descToInjective  _ _\n\n"}
{"name":"CategoryTheory.InjectiveResolution.homotopyEquiv_hom_Œπ_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nX : C\nI J : CategoryTheory.InjectiveResolution X\nZ : CochainComplex C Nat\nh : Quiver.Hom J.cocomplex Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp I.Œπ (CategoryTheory.CategoryStruct.comp (I.homotopyEquiv J).hom h)) (CategoryTheory.CategoryStruct.comp J.Œπ h)","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_hom_Œπ {X : C} (I J : InjectiveResolution X) :\n    I.Œπ ‚â´ (homotopyEquiv I J).hom = J.Œπ := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.homotopyEquiv_hom_Œπ","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nX : C\nI J : CategoryTheory.InjectiveResolution X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp I.Œπ (I.homotopyEquiv J).hom) J.Œπ","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_hom_Œπ {X : C} (I J : InjectiveResolution X) :\n    I.Œπ ‚â´ (homotopyEquiv I J).hom = J.Œπ := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.homotopyEquiv_inv_Œπ_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nX : C\nI J : CategoryTheory.InjectiveResolution X\nZ : CochainComplex C Nat\nh : Quiver.Hom I.cocomplex Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp J.Œπ (CategoryTheory.CategoryStruct.comp (I.homotopyEquiv J).inv h)) (CategoryTheory.CategoryStruct.comp I.Œπ h)","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_inv_Œπ {X : C} (I J : InjectiveResolution X) :\n    J.Œπ ‚â´ (homotopyEquiv I J).inv = I.Œπ := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.homotopyEquiv_inv_Œπ","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Abelian C\nX : C\nI J : CategoryTheory.InjectiveResolution X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp J.Œπ (I.homotopyEquiv J).inv) I.Œπ","decl":"@[reassoc (attr := simp)]\ntheorem homotopyEquiv_inv_Œπ {X : C} (I J : InjectiveResolution X) :\n    J.Œπ ‚â´ (homotopyEquiv I J).inv = I.Œπ := by simp [homotopyEquiv]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.iso_hom_naturality","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasInjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.Œπ.f 0))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.injectiveResolutions C).map f) J.iso.hom) (CategoryTheory.CategoryStruct.comp I.iso.hom ((HomotopyCategory.quotient C (ComplexShape.up Nat)).map œÜ))","decl":"@[reassoc]\nlemma InjectiveResolution.iso_hom_naturality {X Y : C} (f : X ‚ü∂ Y)\n    (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (œÜ : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ J.Œπ.f 0) :\n    (injectiveResolutions C).map f ‚â´ J.iso.hom =\n      I.iso.hom ‚â´ (HomotopyCategory.quotient _ _).map œÜ := by\n  apply HomotopyCategory.eq_of_homotopy\n  apply descHomotopy f\n  all_goals aesop\n\n"}
{"name":"CategoryTheory.InjectiveResolution.iso_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasInjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.Œπ.f 0))\nZ : HomotopyCategory C (ComplexShape.up Nat)\nh : Quiver.Hom ((HomotopyCategory.quotient C (ComplexShape.up Nat)).obj J.cocomplex) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.injectiveResolutions C).map f) (CategoryTheory.CategoryStruct.comp J.iso.hom h)) (CategoryTheory.CategoryStruct.comp I.iso.hom (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Nat)).map œÜ) h))","decl":"@[reassoc]\nlemma InjectiveResolution.iso_hom_naturality {X Y : C} (f : X ‚ü∂ Y)\n    (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (œÜ : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ J.Œπ.f 0) :\n    (injectiveResolutions C).map f ‚â´ J.iso.hom =\n      I.iso.hom ‚â´ (HomotopyCategory.quotient _ _).map œÜ := by\n  apply HomotopyCategory.eq_of_homotopy\n  apply descHomotopy f\n  all_goals aesop\n\n"}
{"name":"CategoryTheory.InjectiveResolution.iso_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasInjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.Œπ.f 0))\nZ : HomotopyCategory C (ComplexShape.up Nat)\nh : Quiver.Hom ((CategoryTheory.injectiveResolutions C).obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp I.iso.inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.injectiveResolutions C).map f) h)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Nat)).map œÜ) (CategoryTheory.CategoryStruct.comp J.iso.inv h))","decl":"@[reassoc]\nlemma InjectiveResolution.iso_inv_naturality {X Y : C} (f : X ‚ü∂ Y)\n    (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (œÜ : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ J.Œπ.f 0) :\n    I.iso.inv ‚â´ (injectiveResolutions C).map f =\n      (HomotopyCategory.quotient _ _).map œÜ ‚â´ J.iso.inv := by\n  rw [‚Üê cancel_mono (J.iso).hom, Category.assoc, iso_hom_naturality f I J œÜ comm,\n    Iso.inv_hom_id_assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.iso_inv_naturality","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.HasInjectiveResolutions C\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.Œπ.f 0))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp I.iso.inv ((CategoryTheory.injectiveResolutions C).map f)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Nat)).map œÜ) J.iso.inv)","decl":"@[reassoc]\nlemma InjectiveResolution.iso_inv_naturality {X Y : C} (f : X ‚ü∂ Y)\n    (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (œÜ : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ J.Œπ.f 0) :\n    I.iso.inv ‚â´ (injectiveResolutions C).map f =\n      (HomotopyCategory.quotient _ _).map œÜ ‚â´ J.iso.inv := by\n  rw [‚Üê cancel_mono (J.iso).hom, Category.assoc, iso_hom_naturality f I J œÜ comm,\n    Iso.inv_hom_id_assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id]\n\n"}
{"name":"CategoryTheory.exact_f_d","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughInjectives C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ (CategoryTheory.ShortComplex.mk f (CategoryTheory.Injective.d f) ‚ãØ).Exact","decl":"theorem exact_f_d {X Y : C} (f : X ‚ü∂ Y) :\n    (ShortComplex.mk f (d f) (by simp)).Exact := by\n  let Œ± : ShortComplex.mk f (cokernel.œÄ f) (by simp) ‚ü∂ ShortComplex.mk f (d f) (by simp) :=\n    { œÑ‚ÇÅ := ùüô _\n      œÑ‚ÇÇ := ùüô _\n      œÑ‚ÇÉ := Injective.Œπ _  }\n  have : Epi Œ±.œÑ‚ÇÅ := by dsimp; infer_instance\n  have : IsIso Œ±.œÑ‚ÇÇ := by dsimp; infer_instance\n  have : Mono Œ±.œÑ‚ÇÉ := by dsimp; infer_instance\n  rw [‚Üê ShortComplex.exact_iff_of_epi_of_isIso_of_mono Œ±]\n  apply ShortComplex.exact_of_g_is_cokernel\n  apply cokernelIsCokernel\n\n"}
{"name":"CategoryTheory.InjectiveResolution.ofCocomplex_d_0_1","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughInjectives C\nZ : C\n‚ä¢ Eq ((CategoryTheory.InjectiveResolution.ofCocomplex Z).d 0 1) (CategoryTheory.Injective.d (CategoryTheory.Injective.Œπ Z))","decl":"lemma ofCocomplex_d_0_1 :\n    (ofCocomplex Z).d 0 1 = d (Injective.Œπ Z) := by\n  simp [ofCocomplex]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.ofCocomplex_exactAt_succ","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughInjectives C\nZ : C\nn : Nat\n‚ä¢ HomologicalComplex.ExactAt (CategoryTheory.InjectiveResolution.ofCocomplex Z) (HAdd.hAdd n 1)","decl":"lemma ofCocomplex_exactAt_succ (n : ‚Ñï) :\n    (ofCocomplex Z).ExactAt (n + 1) := by\n  rw [HomologicalComplex.exactAt_iff' _ n (n + 1) (n + 1 + 1) (by simp) (by simp)]\n  dsimp [ofCocomplex, CochainComplex.mk', CochainComplex.mk, HomologicalComplex.sc',\n      HomologicalComplex.shortComplexFunctor']\n  simp only [CochainComplex.of_d]\n  match n with\n  | 0 => apply exact_f_d ((CochainComplex.mkAux _ _ _\n      (d (Injective.Œπ Z)) (d (d (Injective.Œπ Z))) _ _ 0).f)\n  | n+1 => apply exact_f_d ((CochainComplex.mkAux _ _ _\n      (d (Injective.Œπ Z)) (d (d (Injective.Œπ Z))) _ _ (n+1)).f)\n\n"}
{"name":"CategoryTheory.InjectiveResolution.instInjectiveXNatOfCocomplex","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughInjectives C\nZ : C\nn : Nat\n‚ä¢ CategoryTheory.Injective ((CategoryTheory.InjectiveResolution.ofCocomplex Z).X n)","decl":"instance (n : ‚Ñï) : Injective ((ofCocomplex Z).X n) := by\n  obtain (_ | _ | _ | n) := n <;> apply Injective.injective_under\n\n"}
{"name":"CategoryTheory.InjectiveResolution.of_def","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughInjectives C\nZ : C\n‚ä¢ Eq (CategoryTheory.InjectiveResolution.of Z) (CategoryTheory.InjectiveResolution.mk (CategoryTheory.InjectiveResolution.ofCocomplex Z) ‚ãØ (((CategoryTheory.InjectiveResolution.ofCocomplex Z).fromSingle‚ÇÄEquiv Z).symm ‚ü®CategoryTheory.Injective.Œπ Z, ‚ãØ‚ü©) ‚ãØ)","decl":"/-- In any abelian category with enough injectives,\n`InjectiveResolution.of Z` constructs an injective resolution of the object `Z`.\n-/\nirreducible_def of : InjectiveResolution Z where\n  cocomplex := ofCocomplex Z\n  Œπ := (CochainComplex.fromSingle‚ÇÄEquiv _ _).symm ‚ü®Injective.Œπ Z,\n    by rw [ofCocomplex_d_0_1, cokernel.condition_assoc, zero_comp]‚ü©\n  quasiIso := ‚ü®fun n => by\n    cases n\n    ¬∑ rw [CochainComplex.quasiIsoAt‚ÇÄ_iff, ShortComplex.quasiIso_iff_of_zeros]\n      ¬∑ refine (ShortComplex.exact_and_mono_f_iff_of_iso ?_).2\n          ‚ü®exact_f_d (Injective.Œπ Z), by dsimp; infer_instance‚ü©\n        exact ShortComplex.isoMk (Iso.refl _) (Iso.refl _) (Iso.refl _) (by simp)\n          (by simp [ofCocomplex])\n      all_goals rfl\n    ¬∑ rw [quasiIsoAt_iff_exactAt]\n      ¬∑ apply ofCocomplex_exactAt_succ\n      ¬∑ apply CochainComplex.exactAt_succ_single_obj‚ü©\n\n"}
{"name":"CategoryTheory.InjectiveResolution.instHasInjectiveResolution","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughInjectives C\nZ : C\n‚ä¢ CategoryTheory.HasInjectiveResolution Z","decl":"instance (priority := 100) (Z : C) : HasInjectiveResolution Z where out := ‚ü®of Z‚ü©\n\n"}
{"name":"CategoryTheory.InjectiveResolution.instHasInjectiveResolutions","module":"Mathlib.CategoryTheory.Abelian.InjectiveResolution","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Abelian C\ninst‚úù : CategoryTheory.EnoughInjectives C\n‚ä¢ CategoryTheory.HasInjectiveResolutions C","decl":"instance (priority := 100) : HasInjectiveResolutions C where out _ := inferInstance\n\n"}
