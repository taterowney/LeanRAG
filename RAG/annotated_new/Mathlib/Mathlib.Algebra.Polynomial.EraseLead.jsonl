{"name":"Polynomial.eraseLead_support","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq f.eraseLead.support (f.support.erase f.natDegree)","decl":"theorem eraseLead_support (f : R[X]) : f.eraseLead.support = f.support.erase f.natDegree := by\n  simp only [eraseLead, support_erase]\n\n"}
{"name":"Polynomial.eraseLead_coeff","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\ni : Nat\n⊢ Eq (f.eraseLead.coeff i) (ite (Eq i f.natDegree) 0 (f.coeff i))","decl":"theorem eraseLead_coeff (i : ℕ) :\n    f.eraseLead.coeff i = if i = f.natDegree then 0 else f.coeff i := by\n  simp only [eraseLead, coeff_erase]\n\n"}
{"name":"Polynomial.eraseLead_coeff_natDegree","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq (f.eraseLead.coeff f.natDegree) 0","decl":"@[simp]\ntheorem eraseLead_coeff_natDegree : f.eraseLead.coeff f.natDegree = 0 := by simp [eraseLead_coeff]\n\n"}
{"name":"Polynomial.eraseLead_coeff_of_ne","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\ni : Nat\nhi : Ne i f.natDegree\n⊢ Eq (f.eraseLead.coeff i) (f.coeff i)","decl":"theorem eraseLead_coeff_of_ne (i : ℕ) (hi : i ≠ f.natDegree) : f.eraseLead.coeff i = f.coeff i := by\n  simp [eraseLead_coeff, hi]\n\n"}
{"name":"Polynomial.eraseLead_zero","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Polynomial.eraseLead 0) 0","decl":"@[simp]\ntheorem eraseLead_zero : eraseLead (0 : R[X]) = 0 := by simp only [eraseLead, erase_zero]\n\n"}
{"name":"Polynomial.eraseLead_add_monomial_natDegree_leadingCoeff","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq (HAdd.hAdd f.eraseLead ((Polynomial.monomial f.natDegree) f.leadingCoeff)) f","decl":"@[simp]\ntheorem eraseLead_add_monomial_natDegree_leadingCoeff (f : R[X]) :\n    f.eraseLead + monomial f.natDegree f.leadingCoeff = f :=\n  (add_comm _ _).trans (f.monomial_add_erase _)\n\n"}
{"name":"Polynomial.eraseLead_add_C_mul_X_pow","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq (HAdd.hAdd f.eraseLead (HMul.hMul (Polynomial.C f.leadingCoeff) (HPow.hPow Polynomial.X f.natDegree))) f","decl":"@[simp]\ntheorem eraseLead_add_C_mul_X_pow (f : R[X]) :\n    f.eraseLead + C f.leadingCoeff * X ^ f.natDegree = f := by\n  rw [C_mul_X_pow_eq_monomial, eraseLead_add_monomial_natDegree_leadingCoeff]\n\n"}
{"name":"Polynomial.self_sub_monomial_natDegree_leadingCoeff","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_2\ninst✝ : Ring R\nf : Polynomial R\n⊢ Eq (HSub.hSub f ((Polynomial.monomial f.natDegree) f.leadingCoeff)) f.eraseLead","decl":"@[simp]\ntheorem self_sub_monomial_natDegree_leadingCoeff {R : Type*} [Ring R] (f : R[X]) :\n    f - monomial f.natDegree f.leadingCoeff = f.eraseLead :=\n  (eq_sub_iff_add_eq.mpr (eraseLead_add_monomial_natDegree_leadingCoeff f)).symm\n\n"}
{"name":"Polynomial.self_sub_C_mul_X_pow","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_2\ninst✝ : Ring R\nf : Polynomial R\n⊢ Eq (HSub.hSub f (HMul.hMul (Polynomial.C f.leadingCoeff) (HPow.hPow Polynomial.X f.natDegree))) f.eraseLead","decl":"@[simp]\ntheorem self_sub_C_mul_X_pow {R : Type*} [Ring R] (f : R[X]) :\n    f - C f.leadingCoeff * X ^ f.natDegree = f.eraseLead := by\n  rw [C_mul_X_pow_eq_monomial, self_sub_monomial_natDegree_leadingCoeff]\n\n"}
{"name":"Polynomial.eraseLead_ne_zero","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nf0 : LE.le 2 f.support.card\n⊢ Ne f.eraseLead 0","decl":"theorem eraseLead_ne_zero (f0 : 2 ≤ #f.support) : eraseLead f ≠ 0 := by\n  rw [Ne, ← card_support_eq_zero, eraseLead_support]\n  exact\n    (zero_lt_one.trans_le <| (tsub_le_tsub_right f0 1).trans Finset.pred_card_le_card_erase).ne.symm\n\n"}
{"name":"Polynomial.lt_natDegree_of_mem_eraseLead_support","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\na : Nat\nh : Membership.mem f.eraseLead.support a\n⊢ LT.lt a f.natDegree","decl":"theorem lt_natDegree_of_mem_eraseLead_support {a : ℕ} (h : a ∈ (eraseLead f).support) :\n    a < f.natDegree := by\n  rw [eraseLead_support, mem_erase] at h\n  exact (le_natDegree_of_mem_supp a h.2).lt_of_ne h.1\n\n"}
{"name":"Polynomial.ne_natDegree_of_mem_eraseLead_support","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\na : Nat\nh : Membership.mem f.eraseLead.support a\n⊢ Ne a f.natDegree","decl":"theorem ne_natDegree_of_mem_eraseLead_support {a : ℕ} (h : a ∈ (eraseLead f).support) :\n    a ≠ f.natDegree :=\n  (lt_natDegree_of_mem_eraseLead_support h).ne\n\n"}
{"name":"Polynomial.natDegree_not_mem_eraseLead_support","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Not (Membership.mem f.eraseLead.support f.natDegree)","decl":"theorem natDegree_not_mem_eraseLead_support : f.natDegree ∉ (eraseLead f).support := fun h =>\n  ne_natDegree_of_mem_eraseLead_support h rfl\n\n"}
{"name":"Polynomial.eraseLead_support_card_lt","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nh : Ne f 0\n⊢ LT.lt f.eraseLead.support.card f.support.card","decl":"theorem eraseLead_support_card_lt (h : f ≠ 0) : #(eraseLead f).support < #f.support := by\n  rw [eraseLead_support]\n  exact card_lt_card (erase_ssubset <| natDegree_mem_support_of_nonzero h)\n\n"}
{"name":"Polynomial.card_support_eraseLead_add_one","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nh : Ne f 0\n⊢ Eq (HAdd.hAdd f.eraseLead.support.card 1) f.support.card","decl":"theorem card_support_eraseLead_add_one (h : f ≠ 0) : #f.eraseLead.support + 1 = #f.support := by\n  set c := #f.support with hc\n  cases h₁ : c\n  case zero =>\n    by_contra\n    exact h (card_support_eq_zero.mp h₁)\n  case succ =>\n    rw [eraseLead_support, card_erase_of_mem (natDegree_mem_support_of_nonzero h), ← hc, h₁]\n    rfl\n\n"}
{"name":"Polynomial.card_support_eraseLead","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq f.eraseLead.support.card (HSub.hSub f.support.card 1)","decl":"@[simp]\ntheorem card_support_eraseLead : #f.eraseLead.support = #f.support - 1 := by\n  by_cases hf : f = 0\n  · rw [hf, eraseLead_zero, support_zero, card_empty]\n  · rw [← card_support_eraseLead_add_one hf, add_tsub_cancel_right]\n\n"}
{"name":"Polynomial.card_support_eraseLead'","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nc : Nat\nfc : Eq f.support.card (HAdd.hAdd c 1)\n⊢ Eq f.eraseLead.support.card c","decl":"theorem card_support_eraseLead' {c : ℕ} (fc : #f.support = c + 1) :\n    #f.eraseLead.support = c := by\n  rw [card_support_eraseLead, fc, add_tsub_cancel_right]\n\n"}
{"name":"Polynomial.card_support_eq_one_of_eraseLead_eq_zero","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nh₀ : Ne f 0\nh₁ : Eq f.eraseLead 0\n⊢ Eq f.support.card 1","decl":"theorem card_support_eq_one_of_eraseLead_eq_zero (h₀ : f ≠ 0) (h₁ : f.eraseLead = 0) :\n    #f.support = 1 :=\n  (card_support_eq_zero.mpr h₁ ▸ card_support_eraseLead_add_one h₀).symm\n\n"}
{"name":"Polynomial.card_support_le_one_of_eraseLead_eq_zero","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nh : Eq f.eraseLead 0\n⊢ LE.le f.support.card 1","decl":"theorem card_support_le_one_of_eraseLead_eq_zero (h : f.eraseLead = 0) : #f.support ≤ 1 := by\n  by_cases hpz : f = 0\n  case pos => simp [hpz]\n  case neg => exact le_of_eq (card_support_eq_one_of_eraseLead_eq_zero hpz h)\n\n"}
{"name":"Polynomial.eraseLead_monomial","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ni : Nat\nr : R\n⊢ Eq ((Polynomial.monomial i) r).eraseLead 0","decl":"@[simp]\ntheorem eraseLead_monomial (i : ℕ) (r : R) : eraseLead (monomial i r) = 0 := by\n  classical\n  by_cases hr : r = 0\n  · subst r\n    simp only [monomial_zero_right, eraseLead_zero]\n  · rw [eraseLead, natDegree_monomial, if_neg hr, erase_monomial]\n\n"}
{"name":"Polynomial.eraseLead_C","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\n⊢ Eq (Polynomial.C r).eraseLead 0","decl":"@[simp]\ntheorem eraseLead_C (r : R) : eraseLead (C r) = 0 :=\n  eraseLead_monomial _ _\n\n"}
{"name":"Polynomial.eraseLead_X","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq Polynomial.X.eraseLead 0","decl":"@[simp]\ntheorem eraseLead_X : eraseLead (X : R[X]) = 0 :=\n  eraseLead_monomial _ _\n\n"}
{"name":"Polynomial.eraseLead_X_pow","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (HPow.hPow Polynomial.X n).eraseLead 0","decl":"@[simp]\ntheorem eraseLead_X_pow (n : ℕ) : eraseLead (X ^ n : R[X]) = 0 := by\n  rw [X_pow_eq_monomial, eraseLead_monomial]\n\n"}
{"name":"Polynomial.eraseLead_C_mul_X_pow","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\nn : Nat\n⊢ Eq (HMul.hMul (Polynomial.C r) (HPow.hPow Polynomial.X n)).eraseLead 0","decl":"@[simp]\ntheorem eraseLead_C_mul_X_pow (r : R) (n : ℕ) : eraseLead (C r * X ^ n) = 0 := by\n  rw [C_mul_X_pow_eq_monomial, eraseLead_monomial]\n\n"}
{"name":"Polynomial.eraseLead_C_mul_X","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\n⊢ Eq (HMul.hMul (Polynomial.C r) Polynomial.X).eraseLead 0","decl":"@[simp] lemma eraseLead_C_mul_X (r : R) : eraseLead (C r * X) = 0 := by\n  simpa using eraseLead_C_mul_X_pow _ 1\n\n"}
{"name":"Polynomial.eraseLead_add_of_degree_lt_left","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np q : Polynomial R\npq : LT.lt q.degree p.degree\n⊢ Eq (HAdd.hAdd p q).eraseLead (HAdd.hAdd p.eraseLead q)","decl":"theorem eraseLead_add_of_degree_lt_left {p q : R[X]} (pq : q.degree < p.degree) :\n    (p + q).eraseLead = p.eraseLead + q := by\n  ext n\n  by_cases nd : n = p.natDegree\n  · rw [nd, eraseLead_coeff, if_pos (natDegree_add_eq_left_of_degree_lt pq).symm]\n    simpa using (coeff_eq_zero_of_degree_lt (lt_of_lt_of_le pq degree_le_natDegree)).symm\n  · rw [eraseLead_coeff, coeff_add, coeff_add, eraseLead_coeff, if_neg, if_neg nd]\n    rintro rfl\n    exact nd (natDegree_add_eq_left_of_degree_lt pq)\n\n"}
{"name":"Polynomial.eraseLead_add_of_natDegree_lt_left","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np q : Polynomial R\npq : LT.lt q.natDegree p.natDegree\n⊢ Eq (HAdd.hAdd p q).eraseLead (HAdd.hAdd p.eraseLead q)","decl":"theorem eraseLead_add_of_natDegree_lt_left {p q : R[X]} (pq : q.natDegree < p.natDegree) :\n    (p + q).eraseLead = p.eraseLead + q :=\n  eraseLead_add_of_degree_lt_left (degree_lt_degree pq)\n\n"}
{"name":"Polynomial.eraseLead_add_of_degree_lt_right","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np q : Polynomial R\npq : LT.lt p.degree q.degree\n⊢ Eq (HAdd.hAdd p q).eraseLead (HAdd.hAdd p q.eraseLead)","decl":"theorem eraseLead_add_of_degree_lt_right {p q : R[X]} (pq : p.degree < q.degree) :\n    (p + q).eraseLead = p + q.eraseLead := by\n  ext n\n  by_cases nd : n = q.natDegree\n  · rw [nd, eraseLead_coeff, if_pos (natDegree_add_eq_right_of_degree_lt pq).symm]\n    simpa using (coeff_eq_zero_of_degree_lt (lt_of_lt_of_le pq degree_le_natDegree)).symm\n  · rw [eraseLead_coeff, coeff_add, coeff_add, eraseLead_coeff, if_neg, if_neg nd]\n    rintro rfl\n    exact nd (natDegree_add_eq_right_of_degree_lt pq)\n\n"}
{"name":"Polynomial.eraseLead_add_of_natDegree_lt_right","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np q : Polynomial R\npq : LT.lt p.natDegree q.natDegree\n⊢ Eq (HAdd.hAdd p q).eraseLead (HAdd.hAdd p q.eraseLead)","decl":"theorem eraseLead_add_of_natDegree_lt_right {p q : R[X]} (pq : p.natDegree < q.natDegree) :\n    (p + q).eraseLead = p + q.eraseLead :=\n  eraseLead_add_of_degree_lt_right (degree_lt_degree pq)\n\n"}
{"name":"Polynomial.eraseLead_degree_le","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ LE.le f.eraseLead.degree f.degree","decl":"theorem eraseLead_degree_le : (eraseLead f).degree ≤ f.degree :=\n  f.degree_erase_le _\n\n"}
{"name":"Polynomial.degree_eraseLead_lt","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nhf : Ne f 0\n⊢ LT.lt f.eraseLead.degree f.degree","decl":"theorem degree_eraseLead_lt (hf : f ≠ 0) : (eraseLead f).degree < f.degree :=\n  f.degree_erase_lt hf\n\n"}
{"name":"Polynomial.eraseLead_natDegree_le_aux","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ LE.le f.eraseLead.natDegree f.natDegree","decl":"theorem eraseLead_natDegree_le_aux : (eraseLead f).natDegree ≤ f.natDegree :=\n  natDegree_le_natDegree eraseLead_degree_le\n\n"}
{"name":"Polynomial.eraseLead_natDegree_lt","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nf0 : LE.le 2 f.support.card\n⊢ LT.lt f.eraseLead.natDegree f.natDegree","decl":"theorem eraseLead_natDegree_lt (f0 : 2 ≤ #f.support) : (eraseLead f).natDegree < f.natDegree :=\n  lt_of_le_of_ne eraseLead_natDegree_le_aux <|\n    ne_natDegree_of_mem_eraseLead_support <|\n      natDegree_mem_support_of_nonzero <| eraseLead_ne_zero f0\n\n"}
{"name":"Polynomial.natDegree_pos_of_eraseLead_ne_zero","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nh : Ne f.eraseLead 0\n⊢ LT.lt 0 f.natDegree","decl":"theorem natDegree_pos_of_eraseLead_ne_zero (h : f.eraseLead ≠ 0) : 0 < f.natDegree := by\n  by_contra h₂\n  rw [eq_C_of_natDegree_eq_zero (Nat.eq_zero_of_not_pos h₂)] at h\n  simp at h\n\n"}
{"name":"Polynomial.eraseLead_natDegree_lt_or_eraseLead_eq_zero","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Or (LT.lt f.eraseLead.natDegree f.natDegree) (Eq f.eraseLead 0)","decl":"theorem eraseLead_natDegree_lt_or_eraseLead_eq_zero (f : R[X]) :\n    (eraseLead f).natDegree < f.natDegree ∨ f.eraseLead = 0 := by\n  by_cases h : #f.support ≤ 1\n  · right\n    rw [← C_mul_X_pow_eq_self h]\n    simp\n  · left\n    apply eraseLead_natDegree_lt (lt_of_not_ge h)\n\n"}
{"name":"Polynomial.eraseLead_natDegree_le","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ LE.le f.eraseLead.natDegree (HSub.hSub f.natDegree 1)","decl":"theorem eraseLead_natDegree_le (f : R[X]) : (eraseLead f).natDegree ≤ f.natDegree - 1 := by\n  rcases f.eraseLead_natDegree_lt_or_eraseLead_eq_zero with (h | h)\n  · exact Nat.le_sub_one_of_lt h\n  · simp only [h, natDegree_zero, zero_le]\n\n"}
{"name":"Polynomial.natDegree_eraseLead","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nh : Ne f.nextCoeff 0\n⊢ Eq f.eraseLead.natDegree (HSub.hSub f.natDegree 1)","decl":"lemma natDegree_eraseLead (h : f.nextCoeff ≠ 0) : f.eraseLead.natDegree = f.natDegree - 1 := by\n  have := natDegree_pos_of_nextCoeff_ne_zero h\n  refine f.eraseLead_natDegree_le.antisymm <| le_natDegree_of_ne_zero ?_\n  rwa [eraseLead_coeff_of_ne _ (tsub_lt_self _ _).ne, ← nextCoeff_of_natDegree_pos]\n  all_goals positivity\n\n"}
{"name":"Polynomial.natDegree_eraseLead_add_one","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nh : Ne f.nextCoeff 0\n⊢ Eq (HAdd.hAdd f.eraseLead.natDegree 1) f.natDegree","decl":"lemma natDegree_eraseLead_add_one (h : f.nextCoeff ≠ 0) :\n    f.eraseLead.natDegree + 1 = f.natDegree := by\n  rw [natDegree_eraseLead h, tsub_add_cancel_of_le]\n  exact natDegree_pos_of_nextCoeff_ne_zero h\n\n"}
{"name":"Polynomial.natDegree_eraseLead_le_of_nextCoeff_eq_zero","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nh : Eq f.nextCoeff 0\n⊢ LE.le f.eraseLead.natDegree (HSub.hSub f.natDegree 2)","decl":"theorem natDegree_eraseLead_le_of_nextCoeff_eq_zero (h : f.nextCoeff = 0) :\n    f.eraseLead.natDegree ≤ f.natDegree - 2 := by\n  refine natDegree_le_pred (n := f.natDegree - 1) (eraseLead_natDegree_le f) ?_\n  rw [nextCoeff_eq_zero, natDegree_eq_zero] at h\n  obtain ⟨a, rfl⟩ | ⟨hf, h⟩ := h\n  · simp\n  rw [eraseLead_coeff_of_ne _ (tsub_lt_self hf zero_lt_one).ne, ← nextCoeff_of_natDegree_pos hf]\n  simp [nextCoeff_eq_zero, h, eq_zero_or_pos]\n\n"}
{"name":"Polynomial.two_le_natDegree_of_nextCoeff_eraseLead","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nhlead : Ne f.eraseLead 0\nhnext : Eq f.nextCoeff 0\n⊢ LE.le 2 f.natDegree","decl":"lemma two_le_natDegree_of_nextCoeff_eraseLead (hlead : f.eraseLead ≠ 0)\n    (hnext : f.nextCoeff = 0) : 2 ≤ f.natDegree := by\n  contrapose! hlead\n  rw [Nat.lt_succ_iff, Nat.le_one_iff_eq_zero_or_eq_one, natDegree_eq_zero, natDegree_eq_one]\n    at hlead\n  obtain ⟨a, rfl⟩ | ⟨a, ha, b, rfl⟩ := hlead\n  · simp\n  · rw [nextCoeff_C_mul_X_add_C ha] at hnext\n    subst b\n    simp\n\n"}
{"name":"Polynomial.leadingCoeff_eraseLead_eq_nextCoeff","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nh : Ne f.nextCoeff 0\n⊢ Eq f.eraseLead.leadingCoeff f.nextCoeff","decl":"theorem leadingCoeff_eraseLead_eq_nextCoeff (h : f.nextCoeff ≠ 0) :\n    f.eraseLead.leadingCoeff = f.nextCoeff := by\n  have := natDegree_pos_of_nextCoeff_ne_zero h\n  rw [leadingCoeff, nextCoeff, natDegree_eraseLead h, if_neg,\n    eraseLead_coeff_of_ne _ (tsub_lt_self _ _).ne]\n  all_goals positivity\n\n"}
{"name":"Polynomial.nextCoeff_eq_zero_of_eraseLead_eq_zero","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nh : Eq f.eraseLead 0\n⊢ Eq f.nextCoeff 0","decl":"theorem nextCoeff_eq_zero_of_eraseLead_eq_zero (h : f.eraseLead = 0) : f.nextCoeff = 0 := by\n  by_contra h₂\n  exact leadingCoeff_ne_zero.mp (leadingCoeff_eraseLead_eq_nextCoeff h₂ ▸ h₂) h\n\n"}
{"name":"Polynomial.induction_with_natDegree_le","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nP : Polynomial R → Prop\nN : Nat\nP_0 : P 0\nP_C_mul_pow : ∀ (n : Nat) (r : R), Ne r 0 → LE.le n N → P (HMul.hMul (Polynomial.C r) (HPow.hPow Polynomial.X n))\nP_C_add : ∀ (f g : Polynomial R), LT.lt f.natDegree g.natDegree → LE.le g.natDegree N → P f → P g → P (HAdd.hAdd f g)\nf : Polynomial R\na✝ : LE.le f.natDegree N\n⊢ P f","decl":"/-- An induction lemma for polynomials. It takes a natural number `N` as a parameter, that is\nrequired to be at least as big as the `nat_degree` of the polynomial.  This is useful to prove\nresults where you want to change each term in a polynomial to something else depending on the\n`nat_degree` of the polynomial itself and not on the specific `nat_degree` of each term. -/\ntheorem induction_with_natDegree_le (P : R[X] → Prop) (N : ℕ) (P_0 : P 0)\n    (P_C_mul_pow : ∀ n : ℕ, ∀ r : R, r ≠ 0 → n ≤ N → P (C r * X ^ n))\n    (P_C_add : ∀ f g : R[X], f.natDegree < g.natDegree → g.natDegree ≤ N → P f → P g → P (f + g)) :\n    ∀ f : R[X], f.natDegree ≤ N → P f := by\n  intro f df\n  generalize hd : #f.support = c\n  revert f\n  induction' c with c hc\n  · intro f _ f0\n    convert P_0\n    simpa [support_eq_empty, card_eq_zero] using f0\n  · intro f df f0\n    rw [← eraseLead_add_C_mul_X_pow f]\n    cases c\n    · convert P_C_mul_pow f.natDegree f.leadingCoeff ?_ df using 1\n      · convert zero_add (C (leadingCoeff f) * X ^ f.natDegree)\n        rw [← card_support_eq_zero, card_support_eraseLead' f0]\n      · rw [leadingCoeff_ne_zero, Ne, ← card_support_eq_zero, f0]\n        exact zero_ne_one.symm\n    refine P_C_add f.eraseLead _ ?_ ?_ ?_ ?_\n    · refine (eraseLead_natDegree_lt ?_).trans_le (le_of_eq ?_)\n      · exact (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _))).trans f0.ge\n      · rw [natDegree_C_mul_X_pow _ _ (leadingCoeff_ne_zero.mpr _)]\n        rintro rfl\n        simp at f0\n    · exact (natDegree_C_mul_X_pow_le f.leadingCoeff f.natDegree).trans df\n    · exact hc _ (eraseLead_natDegree_le_aux.trans df) (card_support_eraseLead' f0)\n    · refine P_C_mul_pow _ _ ?_ df\n      rw [Ne, leadingCoeff_eq_zero, ← card_support_eq_zero, f0]\n      exact Nat.succ_ne_zero _\n\n"}
{"name":"Polynomial.mono_map_natDegree_eq","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nS : Type u_2\nF : Type u_3\ninst✝² : Semiring S\ninst✝¹ : FunLike F (Polynomial R) (Polynomial S)\ninst✝ : AddMonoidHomClass F (Polynomial R) (Polynomial S)\nφ : F\np : Polynomial R\nk : Nat\nfu : Nat → Nat\nfu0 : ∀ {n : Nat}, LE.le n k → Eq (fu n) 0\nfc : ∀ {n m : Nat}, LE.le k n → LT.lt n m → LT.lt (fu n) (fu m)\nφ_k : ∀ {f : Polynomial R}, LT.lt f.natDegree k → Eq (φ f) 0\nφ_mon_nat : ∀ (n : Nat) (c : R), Ne c 0 → Eq (φ ((Polynomial.monomial n) c)).natDegree (fu n)\n⊢ Eq (φ p).natDegree (fu p.natDegree)","decl":"/-- Let `φ : R[x] → S[x]` be an additive map, `k : ℕ` a bound, and `fu : ℕ → ℕ` a\n\"sufficiently monotone\" map.  Assume also that\n* `φ` maps to `0` all monomials of degree less than `k`,\n* `φ` maps each monomial `m` in `R[x]` to a polynomial `φ m` of degree `fu (deg m)`.\nThen, `φ` maps each polynomial `p` in `R[x]` to a polynomial of degree `fu (deg p)`. -/\ntheorem mono_map_natDegree_eq {S F : Type*} [Semiring S]\n    [FunLike F R[X] S[X]] [AddMonoidHomClass F R[X] S[X]] {φ : F}\n    {p : R[X]} (k : ℕ) (fu : ℕ → ℕ) (fu0 : ∀ {n}, n ≤ k → fu n = 0)\n    (fc : ∀ {n m}, k ≤ n → n < m → fu n < fu m) (φ_k : ∀ {f : R[X]}, f.natDegree < k → φ f = 0)\n    (φ_mon_nat : ∀ n c, c ≠ 0 → (φ (monomial n c)).natDegree = fu n) :\n    (φ p).natDegree = fu p.natDegree := by\n  refine induction_with_natDegree_le (fun p => (φ p).natDegree = fu p.natDegree)\n    p.natDegree (by simp [fu0]) ?_ ?_ _ rfl.le\n  · intro n r r0 _\n    rw [natDegree_C_mul_X_pow _ _ r0, C_mul_X_pow_eq_monomial, φ_mon_nat _ _ r0]\n  · intro f g fg _ fk gk\n    rw [natDegree_add_eq_right_of_natDegree_lt fg, _root_.map_add]\n    by_cases FG : k ≤ f.natDegree\n    · rw [natDegree_add_eq_right_of_natDegree_lt, gk]\n      rw [fk, gk]\n      exact fc FG fg\n    · cases k\n      · exact (FG (Nat.zero_le _)).elim\n      · rwa [φ_k (not_le.mp FG), zero_add]\n\n"}
{"name":"Polynomial.map_natDegree_eq_sub","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nS : Type u_2\nF : Type u_3\ninst✝² : Semiring S\ninst✝¹ : FunLike F (Polynomial R) (Polynomial S)\ninst✝ : AddMonoidHomClass F (Polynomial R) (Polynomial S)\nφ : F\np : Polynomial R\nk : Nat\nφ_k : ∀ (f : Polynomial R), LT.lt f.natDegree k → Eq (φ f) 0\nφ_mon : ∀ (n : Nat) (c : R), Ne c 0 → Eq (φ ((Polynomial.monomial n) c)).natDegree (HSub.hSub n k)\n⊢ Eq (φ p).natDegree (HSub.hSub p.natDegree k)","decl":"theorem map_natDegree_eq_sub {S F : Type*} [Semiring S]\n    [FunLike F R[X] S[X]] [AddMonoidHomClass F R[X] S[X]] {φ : F}\n    {p : R[X]} {k : ℕ} (φ_k : ∀ f : R[X], f.natDegree < k → φ f = 0)\n    (φ_mon : ∀ n c, c ≠ 0 → (φ (monomial n c)).natDegree = n - k) :\n    (φ p).natDegree = p.natDegree - k :=\n  mono_map_natDegree_eq k (fun j => j - k) (by simp_all)\n    (@fun _ _ h => (tsub_lt_tsub_iff_right h).mpr)\n    (φ_k _) φ_mon\n\n"}
{"name":"Polynomial.map_natDegree_eq_natDegree","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nS : Type u_2\nF : Type u_3\ninst✝² : Semiring S\ninst✝¹ : FunLike F (Polynomial R) (Polynomial S)\ninst✝ : AddMonoidHomClass F (Polynomial R) (Polynomial S)\nφ : F\np : Polynomial R\nφ_mon_nat : ∀ (n : Nat) (c : R), Ne c 0 → Eq (φ ((Polynomial.monomial n) c)).natDegree n\n⊢ Eq (φ p).natDegree p.natDegree","decl":"theorem map_natDegree_eq_natDegree {S F : Type*} [Semiring S]\n    [FunLike F R[X] S[X]] [AddMonoidHomClass F R[X] S[X]]\n    {φ : F} (p) (φ_mon_nat : ∀ n c, c ≠ 0 → (φ (monomial n c)).natDegree = n) :\n    (φ p).natDegree = p.natDegree :=\n  (map_natDegree_eq_sub (fun _ h => (Nat.not_lt_zero _ h).elim) (by simpa)).trans\n    p.natDegree.sub_zero\n\n"}
{"name":"Polynomial.card_support_eq'","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\nk : Fin n → Nat\nx : Fin n → R\nhk : Function.Injective k\nhx : ∀ (i : Fin n), Ne (x i) 0\n⊢ Eq (Finset.univ.sum fun i => HMul.hMul (Polynomial.C (x i)) (HPow.hPow Polynomial.X (k i))).support.card n","decl":"theorem card_support_eq' {n : ℕ} (k : Fin n → ℕ) (x : Fin n → R) (hk : Function.Injective k)\n    (hx : ∀ i, x i ≠ 0) : #(∑ i, C (x i) * X ^ k i).support = n := by\n  suffices (∑ i, C (x i) * X ^ k i).support = image k univ by\n    rw [this, univ.card_image_of_injective hk, card_fin]\n  simp_rw [Finset.ext_iff, mem_support_iff, finset_sum_coeff, coeff_C_mul_X_pow, mem_image,\n    mem_univ, true_and]\n  refine fun i => ⟨fun h => ?_, ?_⟩\n  · obtain ⟨j, _, h⟩ := exists_ne_zero_of_sum_ne_zero h\n    exact ⟨j, (ite_ne_right_iff.mp h).1.symm⟩\n  · rintro ⟨j, _, rfl⟩\n    rw [sum_eq_single_of_mem j (mem_univ j), if_pos rfl]\n    · exact hx j\n    · exact fun m _ hmj => if_neg fun h => hmj.symm (hk h)\n\n"}
{"name":"Polynomial.card_support_eq","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\nn : Nat\n⊢ Iff (Eq f.support.card n) (Exists fun k => Exists fun x => Exists fun x_1 => Exists fun x_2 => Eq f (Finset.univ.sum fun i => HMul.hMul (Polynomial.C (x i)) (HPow.hPow Polynomial.X (k i))))","decl":"theorem card_support_eq {n : ℕ} :\n    #f.support = n ↔\n      ∃ (k : Fin n → ℕ) (x : Fin n → R) (_ : StrictMono k) (_ : ∀ i, x i ≠ 0),\n        f = ∑ i, C (x i) * X ^ k i := by\n  refine ⟨?_, fun ⟨k, x, hk, hx, hf⟩ => hf.symm ▸ card_support_eq' k x hk.injective hx⟩\n  induction n generalizing f with\n  | zero => exact fun hf => ⟨0, 0, fun x => x.elim0, fun x => x.elim0, card_support_eq_zero.mp hf⟩\n  | succ n hn =>\n    intro h\n    obtain ⟨k, x, hk, hx, hf⟩ := hn (card_support_eraseLead' h)\n    have H : ¬∃ k : Fin n, Fin.castSucc k = Fin.last n := by\n      rintro ⟨i, hi⟩\n      exact i.castSucc_lt_last.ne hi\n    refine\n      ⟨Function.extend Fin.castSucc k fun _ => f.natDegree,\n        Function.extend Fin.castSucc x fun _ => f.leadingCoeff, ?_, ?_, ?_⟩\n    · intro i j hij\n      have hi : i ∈ Set.range (Fin.castSucc : Fin n → Fin (n + 1)) := by\n        rw [Fin.range_castSucc, Set.mem_def]\n        exact lt_of_lt_of_le hij (Nat.lt_succ_iff.mp j.2)\n      obtain ⟨i, rfl⟩ := hi\n      rw [Fin.strictMono_castSucc.injective.extend_apply]\n      by_cases hj : ∃ j₀, Fin.castSucc j₀ = j\n      · obtain ⟨j, rfl⟩ := hj\n        rwa [Fin.strictMono_castSucc.injective.extend_apply, hk.lt_iff_lt,\n          ← Fin.castSucc_lt_castSucc_iff]\n      · rw [Function.extend_apply' _ _ _ hj]\n        apply lt_natDegree_of_mem_eraseLead_support\n        rw [mem_support_iff, hf, finset_sum_coeff]\n        rw [sum_eq_single, coeff_C_mul, coeff_X_pow_self, mul_one]\n        · exact hx i\n        · intro j _ hji\n          rw [coeff_C_mul, coeff_X_pow, if_neg (hk.injective.ne hji.symm), mul_zero]\n        · exact fun hi => (hi (mem_univ i)).elim\n    · intro i\n      by_cases hi : ∃ i₀, Fin.castSucc i₀ = i\n      · obtain ⟨i, rfl⟩ := hi\n        rw [Fin.strictMono_castSucc.injective.extend_apply]\n        exact hx i\n      · rw [Function.extend_apply' _ _ _ hi, Ne, leadingCoeff_eq_zero, ← card_support_eq_zero, h]\n        exact n.succ_ne_zero\n    · rw [Fin.sum_univ_castSucc]\n      simp only [Fin.strictMono_castSucc.injective.extend_apply]\n      rw [← hf, Function.extend_apply', Function.extend_apply', eraseLead_add_C_mul_X_pow]\n      all_goals exact H\n\n"}
{"name":"Polynomial.card_support_eq_one","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Iff (Eq f.support.card 1) (Exists fun k => Exists fun x => Exists fun x_1 => Eq f (HMul.hMul (Polynomial.C x) (HPow.hPow Polynomial.X k)))","decl":"theorem card_support_eq_one : #f.support = 1 ↔\n    ∃ (k : ℕ) (x : R) (_ : x ≠ 0), f = C x * X ^ k := by\n  refine ⟨fun h => ?_, ?_⟩\n  · obtain ⟨k, x, _, hx, rfl⟩ := card_support_eq.mp h\n    exact ⟨k 0, x 0, hx 0, Fin.sum_univ_one _⟩\n  · rintro ⟨k, x, hx, rfl⟩\n    rw [support_C_mul_X_pow k hx, card_singleton]\n\n"}
{"name":"Polynomial.card_support_eq_two","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Iff (Eq f.support.card 2) (Exists fun k => Exists fun m => Exists fun x => Exists fun x => Exists fun y => Exists fun x_1 => Exists fun x_2 => Eq f (HAdd.hAdd (HMul.hMul (Polynomial.C x) (HPow.hPow Polynomial.X k)) (HMul.hMul (Polynomial.C y) (HPow.hPow Polynomial.X m))))","decl":"theorem card_support_eq_two :\n    #f.support = 2 ↔\n      ∃ (k m : ℕ) (_ : k < m) (x y : R) (_ : x ≠ 0) (_ : y ≠ 0),\n        f = C x * X ^ k + C y * X ^ m := by\n  refine ⟨fun h => ?_, ?_⟩\n  · obtain ⟨k, x, hk, hx, rfl⟩ := card_support_eq.mp h\n    refine ⟨k 0, k 1, hk Nat.zero_lt_one, x 0, x 1, hx 0, hx 1, ?_⟩\n    rw [Fin.sum_univ_castSucc, Fin.sum_univ_one]\n    rfl\n  · rintro ⟨k, m, hkm, x, y, hx, hy, rfl⟩\n    exact card_support_binomial hkm.ne hx hy\n\n"}
{"name":"Polynomial.card_support_eq_three","module":"Mathlib.Algebra.Polynomial.EraseLead","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Iff (Eq f.support.card 3) (Exists fun k => Exists fun m => Exists fun n => Exists fun x => Exists fun x => Exists fun x => Exists fun y => Exists fun z => Exists fun x_1 => Exists fun x_2 => Exists fun x_3 => Eq f (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Polynomial.C x) (HPow.hPow Polynomial.X k)) (HMul.hMul (Polynomial.C y) (HPow.hPow Polynomial.X m))) (HMul.hMul (Polynomial.C z) (HPow.hPow Polynomial.X n))))","decl":"theorem card_support_eq_three :\n    #f.support = 3 ↔\n      ∃ (k m n : ℕ) (_ : k < m) (_ : m < n) (x y z : R) (_ : x ≠ 0) (_ : y ≠ 0) (_ : z ≠ 0),\n        f = C x * X ^ k + C y * X ^ m + C z * X ^ n := by\n  refine ⟨fun h => ?_, ?_⟩\n  · obtain ⟨k, x, hk, hx, rfl⟩ := card_support_eq.mp h\n    refine\n      ⟨k 0, k 1, k 2, hk Nat.zero_lt_one, hk (Nat.lt_succ_self 1), x 0, x 1, x 2, hx 0, hx 1, hx 2,\n        ?_⟩\n    rw [Fin.sum_univ_castSucc, Fin.sum_univ_castSucc, Fin.sum_univ_one]\n    rfl\n  · rintro ⟨k, m, n, hkm, hmn, x, y, z, hx, hy, hz, rfl⟩\n    exact card_support_trinomial hkm hmn hx hy hz\n\n"}
