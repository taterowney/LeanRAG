{"name":"CategoryTheory.preserves_mono_of_preservesLimit","module":"Mathlib.CategoryTheory.Limits.Constructions.EpiMono","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f f) F\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono (F.map f)","decl":"/-- If `F` preserves pullbacks, then it preserves monomorphisms. -/\ntheorem preserves_mono_of_preservesLimit {X Y : C} (f : X ⟶ Y) [PreservesLimit (cospan f f) F]\n    [Mono f] : Mono (F.map f) := by\n  have := isLimitPullbackConeMapOfIsLimit F _ (PullbackCone.isLimitMkIdId f)\n  simp_rw [F.map_id] at this\n  apply PullbackCone.mono_of_isLimitMkIdId _ this\n\n"}
{"name":"CategoryTheory.preservesMonomorphisms_of_preservesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Constructions.EpiMono","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan F\n⊢ F.PreservesMonomorphisms","decl":"instance (priority := 100) preservesMonomorphisms_of_preservesLimitsOfShape\n    [PreservesLimitsOfShape WalkingCospan F] : F.PreservesMonomorphisms where\n  preserves f _ := preserves_mono_of_preservesLimit F f\n\n"}
{"name":"CategoryTheory.reflects_mono_of_reflectsLimit","module":"Mathlib.CategoryTheory.Limits.Constructions.EpiMono","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.cospan f f) F\ninst✝ : CategoryTheory.Mono (F.map f)\n⊢ CategoryTheory.Mono f","decl":"/-- If `F` reflects pullbacks, then it reflects monomorphisms. -/\ntheorem reflects_mono_of_reflectsLimit {X Y : C} (f : X ⟶ Y) [ReflectsLimit (cospan f f) F]\n    [Mono (F.map f)] : Mono f := by\n  have := PullbackCone.isLimitMkIdId (F.map f)\n  simp_rw [← F.map_id] at this\n  apply PullbackCone.mono_of_isLimitMkIdId _ (isLimitOfIsLimitPullbackConeMap F _ this)\n\n"}
{"name":"CategoryTheory.reflectsMonomorphisms_of_reflectsLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Constructions.EpiMono","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsLimitsOfShape CategoryTheory.Limits.WalkingCospan F\n⊢ F.ReflectsMonomorphisms","decl":"instance (priority := 100) reflectsMonomorphisms_of_reflectsLimitsOfShape\n    [ReflectsLimitsOfShape WalkingCospan F] : F.ReflectsMonomorphisms where\n  reflects f _ := reflects_mono_of_reflectsLimit F f\n\n"}
{"name":"CategoryTheory.preserves_epi_of_preservesColimit","module":"Mathlib.CategoryTheory.Limits.Constructions.EpiMono","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f f) F\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi (F.map f)","decl":"/-- If `F` preserves pushouts, then it preserves epimorphisms. -/\ntheorem preserves_epi_of_preservesColimit {X Y : C} (f : X ⟶ Y) [PreservesColimit (span f f) F]\n    [Epi f] : Epi (F.map f) := by\n  have := isColimitPushoutCoconeMapOfIsColimit F _ (PushoutCocone.isColimitMkIdId f)\n  simp_rw [F.map_id] at this\n  apply PushoutCocone.epi_of_isColimitMkIdId _ this\n\n"}
{"name":"CategoryTheory.preservesEpimorphisms_of_preservesColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Constructions.EpiMono","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingSpan F\n⊢ F.PreservesEpimorphisms","decl":"instance (priority := 100) preservesEpimorphisms_of_preservesColimitsOfShape\n    [PreservesColimitsOfShape WalkingSpan F] : F.PreservesEpimorphisms where\n  preserves f _ := preserves_epi_of_preservesColimit F f\n\n"}
{"name":"CategoryTheory.reflects_epi_of_reflectsColimit","module":"Mathlib.CategoryTheory.Limits.Constructions.EpiMono","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.span f f) F\ninst✝ : CategoryTheory.Epi (F.map f)\n⊢ CategoryTheory.Epi f","decl":"/-- If `F` reflects pushouts, then it reflects epimorphisms. -/\ntheorem reflects_epi_of_reflectsColimit {X Y : C} (f : X ⟶ Y) [ReflectsColimit (span f f) F]\n    [Epi (F.map f)] : Epi f := by\n  have := PushoutCocone.isColimitMkIdId (F.map f)\n  simp_rw [← F.map_id] at this\n  apply\n    PushoutCocone.epi_of_isColimitMkIdId _\n      (isColimitOfIsColimitPushoutCoconeMap F _ this)\n\n"}
{"name":"CategoryTheory.reflectsEpimorphisms_of_reflectsColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Constructions.EpiMono","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsColimitsOfShape CategoryTheory.Limits.WalkingSpan F\n⊢ F.ReflectsEpimorphisms","decl":"instance (priority := 100) reflectsEpimorphisms_of_reflectsColimitsOfShape\n    [ReflectsColimitsOfShape WalkingSpan F] : F.ReflectsEpimorphisms where\n  reflects f _ := reflects_epi_of_reflectsColimit F f\n\n"}
