{"name":"CliffordAlgebra.instSMulCommClass","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\nM : Type u_6\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra S A\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : Module A M\nQ : QuadraticForm A M\ninst✝¹ : IsScalarTower R A M\ninst✝ : IsScalarTower S A M\n⊢ SMulCommClass R S (CliffordAlgebra Q)","decl":"instance {R S A M} [CommSemiring R] [CommSemiring S] [AddCommGroup M] [CommRing A]\n    [Algebra R A] [Algebra S A] [Module R M] [Module S M] [Module A M] (Q : QuadraticForm A M)\n    [IsScalarTower R A M] [IsScalarTower S A M] :\n    SMulCommClass R S (CliffordAlgebra Q) :=\n  RingQuot.instSMulCommClass _\n\n"}
{"name":"CliffordAlgebra.instIsScalarTower","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\nM : Type u_6\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : AddCommGroup M\ninst✝⁹ : CommRing A\ninst✝⁸ : SMul R S\ninst✝⁷ : Algebra R A\ninst✝⁶ : Algebra S A\ninst✝⁵ : Module R M\ninst✝⁴ : Module S M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : IsScalarTower S A M\ninst✝ : IsScalarTower R S A\nQ : QuadraticForm A M\n⊢ IsScalarTower R S (CliffordAlgebra Q)","decl":"instance {R S A M} [CommSemiring R] [CommSemiring S] [AddCommGroup M] [CommRing A]\n    [SMul R S] [Algebra R A] [Algebra S A] [Module R M] [Module S M] [Module A M]\n    [IsScalarTower R A M] [IsScalarTower S A M] [IsScalarTower R S A] (Q : QuadraticForm A M) :\n    IsScalarTower R S (CliffordAlgebra Q) :=\n  RingQuot.instIsScalarTower _\n\n"}
{"name":"CliffordAlgebra.ι_sq_scalar","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq (HMul.hMul ((CliffordAlgebra.ι Q) m) ((CliffordAlgebra.ι Q) m)) ((algebraMap R (CliffordAlgebra Q)) (Q m))","decl":"/-- As well as being linear, `ι Q` squares to the quadratic form -/\n@[simp]\ntheorem ι_sq_scalar (m : M) : ι Q m * ι Q m = algebraMap R _ (Q m) := by\n  rw [ι]\n  erw [LinearMap.comp_apply]\n  rw [AlgHom.toLinearMap_apply, ← map_mul (RingQuot.mkAlgHom R (Rel Q)),\n    RingQuot.mkAlgHom_rel R (Rel.of m), AlgHom.commutes]\n  rfl\n\n"}
{"name":"CliffordAlgebra.comp_ι_sq_scalar","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ng : AlgHom R (CliffordAlgebra Q) A\nm : M\n⊢ Eq (HMul.hMul (g ((CliffordAlgebra.ι Q) m)) (g ((CliffordAlgebra.ι Q) m))) ((algebraMap R A) (Q m))","decl":"@[simp]\ntheorem comp_ι_sq_scalar (g : CliffordAlgebra Q →ₐ[R] A) (m : M) :\n    g (ι Q m) * g (ι Q m) = algebraMap _ _ (Q m) := by\n  rw [← map_mul, ι_sq_scalar, AlgHom.commutes]\n\n"}
{"name":"CliffordAlgebra.lift_symm_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nF : AlgHom R (CliffordAlgebra Q) A\n⊢ Eq ((CliffordAlgebra.lift Q).symm F) ⟨F.toLinearMap.comp (CliffordAlgebra.ι Q), ⋯⟩","decl":"/-- Given a linear map `f : M →ₗ[R] A` into an `R`-algebra `A`, which satisfies the condition:\n`cond : ∀ m : M, f m * f m = Q(m)`, this is the canonical lift of `f` to a morphism of `R`-algebras\nfrom `CliffordAlgebra Q` to `A`.\n-/\n@[simps symm_apply]\ndef lift :\n    { f : M →ₗ[R] A // ∀ m, f m * f m = algebraMap _ _ (Q m) } ≃ (CliffordAlgebra Q →ₐ[R] A) where\n  toFun f :=\n    RingQuot.liftAlgHom R\n      ⟨TensorAlgebra.lift R (f : M →ₗ[R] A), fun x y (h : Rel Q x y) => by\n        induction h\n        rw [AlgHom.commutes, map_mul, TensorAlgebra.lift_ι_apply, f.prop]⟩\n  invFun F :=\n    ⟨F.toLinearMap.comp (ι Q), fun m => by\n      rw [LinearMap.comp_apply, AlgHom.toLinearMap_apply, comp_ι_sq_scalar]⟩\n  left_inv f := by\n    ext x\n    -- Porting note: removed `simp only` proof which gets stuck simplifying `LinearMap.comp_apply`\n    exact (RingQuot.liftAlgHom_mkAlgHom_apply _ _ _ _).trans (TensorAlgebra.lift_ι_apply _ x)\n  right_inv F :=\n    -- Porting note: replaced with proof derived from the one for `TensorAlgebra`\n    RingQuot.ringQuot_ext' _ _ _ <|\n      TensorAlgebra.hom_ext <|\n        LinearMap.ext fun x => by\n          exact\n            (RingQuot.liftAlgHom_mkAlgHom_apply _ _ _ _).trans (TensorAlgebra.lift_ι_apply _ _)\n\n"}
{"name":"CliffordAlgebra.ι_comp_lift","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : LinearMap (RingHom.id R) M A\ncond : ∀ (m : M), Eq (HMul.hMul (f m) (f m)) ((algebraMap R A) (Q m))\n⊢ Eq (((CliffordAlgebra.lift Q) ⟨f, cond⟩).toLinearMap.comp (CliffordAlgebra.ι Q)) f","decl":"@[simp]\ntheorem ι_comp_lift (f : M →ₗ[R] A) (cond : ∀ m, f m * f m = algebraMap _ _ (Q m)) :\n    (lift Q ⟨f, cond⟩).toLinearMap.comp (ι Q) = f :=\n  Subtype.mk_eq_mk.mp <| (lift Q).symm_apply_apply ⟨f, cond⟩\n\n"}
{"name":"CliffordAlgebra.lift_ι_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : LinearMap (RingHom.id R) M A\ncond : ∀ (m : M), Eq (HMul.hMul (f m) (f m)) ((algebraMap R A) (Q m))\nx : M\n⊢ Eq (((CliffordAlgebra.lift Q) ⟨f, cond⟩) ((CliffordAlgebra.ι Q) x)) (f x)","decl":"@[simp]\ntheorem lift_ι_apply (f : M →ₗ[R] A) (cond : ∀ m, f m * f m = algebraMap _ _ (Q m)) (x) :\n    lift Q ⟨f, cond⟩ (ι Q x) = f x :=\n  (LinearMap.ext_iff.mp <| ι_comp_lift f cond) x\n\n"}
{"name":"CliffordAlgebra.lift_unique","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : LinearMap (RingHom.id R) M A\ncond : ∀ (m : M), Eq (HMul.hMul (f m) (f m)) ((algebraMap R A) (Q m))\ng : AlgHom R (CliffordAlgebra Q) A\n⊢ Iff (Eq (g.toLinearMap.comp (CliffordAlgebra.ι Q)) f) (Eq g ((CliffordAlgebra.lift Q) ⟨f, cond⟩))","decl":"@[simp]\ntheorem lift_unique (f : M →ₗ[R] A) (cond : ∀ m : M, f m * f m = algebraMap _ _ (Q m))\n    (g : CliffordAlgebra Q →ₐ[R] A) : g.toLinearMap.comp (ι Q) = f ↔ g = lift Q ⟨f, cond⟩ := by\n  convert (lift Q : _ ≃ (CliffordAlgebra Q →ₐ[R] A)).symm_apply_eq\n  -- Porting note: added `Subtype.mk_eq_mk`\n  rw [lift_symm_apply, Subtype.mk_eq_mk]\n\n"}
{"name":"CliffordAlgebra.lift_comp_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\ng : AlgHom R (CliffordAlgebra Q) A\n⊢ Eq ((CliffordAlgebra.lift Q) ⟨g.toLinearMap.comp (CliffordAlgebra.ι Q), ⋯⟩) g","decl":"@[simp]\ntheorem lift_comp_ι (g : CliffordAlgebra Q →ₐ[R] A) :\n    lift Q ⟨g.toLinearMap.comp (ι Q), comp_ι_sq_scalar _⟩ = g := by\n  -- Porting note: removed `rw [lift_symm_apply]; rfl`, changed `convert` to `exact`\n  exact (lift Q : _ ≃ (CliffordAlgebra Q →ₐ[R] A)).apply_symm_apply g\n\n"}
{"name":"CliffordAlgebra.hom_ext","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type u_4\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf g : AlgHom R (CliffordAlgebra Q) A\na✝ : Eq (f.toLinearMap.comp (CliffordAlgebra.ι Q)) (g.toLinearMap.comp (CliffordAlgebra.ι Q))\n⊢ Eq f g","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem hom_ext {A : Type*} [Semiring A] [Algebra R A] {f g : CliffordAlgebra Q →ₐ[R] A} :\n    f.toLinearMap.comp (ι Q) = g.toLinearMap.comp (ι Q) → f = g := by\n  intro h\n  apply (lift Q).symm.injective\n  rw [lift_symm_apply, lift_symm_apply]\n  simp only [h]\n\n-- This proof closely follows `TensorAlgebra.induction`\n"}
{"name":"CliffordAlgebra.hom_ext_iff","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type u_4\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf g : AlgHom R (CliffordAlgebra Q) A\n⊢ Iff (Eq f g) (Eq (f.toLinearMap.comp (CliffordAlgebra.ι Q)) (g.toLinearMap.comp (CliffordAlgebra.ι Q)))","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem hom_ext {A : Type*} [Semiring A] [Algebra R A] {f g : CliffordAlgebra Q →ₐ[R] A} :\n    f.toLinearMap.comp (ι Q) = g.toLinearMap.comp (ι Q) → f = g := by\n  intro h\n  apply (lift Q).symm.injective\n  rw [lift_symm_apply, lift_symm_apply]\n  simp only [h]\n\n-- This proof closely follows `TensorAlgebra.induction`\n"}
{"name":"CliffordAlgebra.induction","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nC : CliffordAlgebra Q → Prop\nalgebraMap : ∀ (r : R), C ((_root_.algebraMap R (CliffordAlgebra Q)) r)\nι : ∀ (x : M), C ((CliffordAlgebra.ι Q) x)\nmul : ∀ (a b : CliffordAlgebra Q), C a → C b → C (HMul.hMul a b)\nadd : ∀ (a b : CliffordAlgebra Q), C a → C b → C (HAdd.hAdd a b)\na : CliffordAlgebra Q\n⊢ C a","decl":"/-- If `C` holds for the `algebraMap` of `r : R` into `CliffordAlgebra Q`, the `ι` of `x : M`,\nand is preserved under addition and multiplication, then it holds for all of `CliffordAlgebra Q`.\n\nSee also the stronger `CliffordAlgebra.left_induction` and `CliffordAlgebra.right_induction`.\n-/\n@[elab_as_elim]\ntheorem induction {C : CliffordAlgebra Q → Prop}\n    (algebraMap : ∀ r, C (algebraMap R (CliffordAlgebra Q) r)) (ι : ∀ x, C (ι Q x))\n    (mul : ∀ a b, C a → C b → C (a * b)) (add : ∀ a b, C a → C b → C (a + b))\n    (a : CliffordAlgebra Q) : C a := by\n  -- the arguments are enough to construct a subalgebra, and a mapping into it from M\n  let s : Subalgebra R (CliffordAlgebra Q) :=\n    { carrier := C\n      mul_mem' := @mul\n      add_mem' := @add\n      algebraMap_mem' := algebraMap }\n  -- Porting note: Added `h`. `h` is needed for `of`.\n  letI h : AddCommMonoid s := inferInstanceAs (AddCommMonoid (Subalgebra.toSubmodule s))\n  let of : { f : M →ₗ[R] s // ∀ m, f m * f m = _root_.algebraMap _ _ (Q m) } :=\n    ⟨(CliffordAlgebra.ι Q).codRestrict (Subalgebra.toSubmodule s) ι,\n      fun m => Subtype.eq <| ι_sq_scalar Q m⟩\n  -- the mapping through the subalgebra is the identity\n  have of_id : AlgHom.id R (CliffordAlgebra Q) = s.val.comp (lift Q of) := by\n    ext\n    simp [of, h]\n    -- Porting note: `simp` can't apply this\n    erw [LinearMap.codRestrict_apply]\n  -- finding a proof is finding an element of the subalgebra\n  -- Porting note: was `convert Subtype.prop (lift Q of a); exact AlgHom.congr_fun of_id a`\n  rw [← AlgHom.id_apply (R := R) a, of_id]\n  exact Subtype.prop (lift Q of a)\n\n"}
{"name":"CliffordAlgebra.mul_add_swap_eq_polar_of_forall_mul_self_eq","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type u_4\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nf : LinearMap (RingHom.id R) M A\nhf : ∀ (x : M), Eq (HMul.hMul (f x) (f x)) ((algebraMap R A) (Q x))\na b : M\n⊢ Eq (HAdd.hAdd (HMul.hMul (f a) (f b)) (HMul.hMul (f b) (f a))) ((algebraMap R A) (QuadraticMap.polar (⇑Q) a b))","decl":"theorem mul_add_swap_eq_polar_of_forall_mul_self_eq {A : Type*} [Ring A] [Algebra R A]\n    (f : M →ₗ[R] A) (hf : ∀ x, f x * f x = algebraMap _ _ (Q x)) (a b : M) :\n    f a * f b + f b * f a = algebraMap R _ (QuadraticMap.polar Q a b) :=\n  calc\n    f a * f b + f b * f a = f (a + b) * f (a + b) - f a * f a - f b * f b := by\n      rw [f.map_add, mul_add, add_mul, add_mul]; abel\n    _ = algebraMap R _ (Q (a + b)) - algebraMap R _ (Q a) - algebraMap R _ (Q b) := by\n      rw [hf, hf, hf]\n    _ = algebraMap R _ (Q (a + b) - Q a - Q b) := by rw [← RingHom.map_sub, ← RingHom.map_sub]\n    _ = algebraMap R _ (QuadraticMap.polar Q a b) := rfl\n\n"}
{"name":"CliffordAlgebra.forall_mul_self_eq_iff","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type u_4\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nh2 : IsUnit 2\nf : LinearMap (RingHom.id R) M A\n⊢ Iff (∀ (x : M), Eq (HMul.hMul (f x) (f x)) ((algebraMap R A) (Q x))) (Eq (HAdd.hAdd (((LinearMap.mul R A).compl₂ f).comp f) (((LinearMap.mul R A).flip.compl₂ f).comp f)) (LinearMap.compr₂ (QuadraticMap.polarBilin Q) (Algebra.linearMap R A)))","decl":"/-- An alternative way to provide the argument to `CliffordAlgebra.lift` when `2` is invertible.\n\nTo show a function squares to the quadratic form, it suffices to show that\n`f x * f y + f y * f x = algebraMap _ _ (polar Q x y)` -/\ntheorem forall_mul_self_eq_iff {A : Type*} [Ring A] [Algebra R A] (h2 : IsUnit (2 : A))\n    (f : M →ₗ[R] A) :\n    (∀ x, f x * f x = algebraMap _ _ (Q x)) ↔\n      (LinearMap.mul R A).compl₂ f ∘ₗ f + (LinearMap.mul R A).flip.compl₂ f ∘ₗ f =\n        Q.polarBilin.compr₂ (Algebra.linearMap R A) := by\n  simp_rw [DFunLike.ext_iff]\n  refine ⟨mul_add_swap_eq_polar_of_forall_mul_self_eq _, fun h x => ?_⟩\n  change ∀ x y : M, f x * f y + f y * f x = algebraMap R A (QuadraticMap.polar Q x y) at h\n  apply h2.mul_left_cancel\n  rw [two_mul, two_mul, h x x, QuadraticMap.polar_self, two_smul, map_add]\n\n"}
{"name":"CliffordAlgebra.ι_mul_ι_add_swap","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na b : M\n⊢ Eq (HAdd.hAdd (HMul.hMul ((CliffordAlgebra.ι Q) a) ((CliffordAlgebra.ι Q) b)) (HMul.hMul ((CliffordAlgebra.ι Q) b) ((CliffordAlgebra.ι Q) a))) ((algebraMap R (CliffordAlgebra Q)) (QuadraticMap.polar (⇑Q) a b))","decl":"/-- The symmetric product of vectors is a scalar -/\ntheorem ι_mul_ι_add_swap (a b : M) :\n    ι Q a * ι Q b + ι Q b * ι Q a = algebraMap R _ (QuadraticMap.polar Q a b) :=\n  mul_add_swap_eq_polar_of_forall_mul_self_eq _ (ι_sq_scalar _) _ _\n\n"}
{"name":"CliffordAlgebra.ι_mul_ι_comm","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na b : M\n⊢ Eq (HMul.hMul ((CliffordAlgebra.ι Q) a) ((CliffordAlgebra.ι Q) b)) (HSub.hSub ((algebraMap R (CliffordAlgebra Q)) (QuadraticMap.polar (⇑Q) a b)) (HMul.hMul ((CliffordAlgebra.ι Q) b) ((CliffordAlgebra.ι Q) a)))","decl":"theorem ι_mul_ι_comm (a b : M) :\n    ι Q a * ι Q b = algebraMap R _ (QuadraticMap.polar Q a b) - ι Q b * ι Q a :=\n  eq_sub_of_add_eq (ι_mul_ι_add_swap a b)\n\n"}
{"name":"CliffordAlgebra.ι_mul_ι_add_swap_of_isOrtho","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na b : M\nh : QuadraticMap.IsOrtho Q a b\n⊢ Eq (HAdd.hAdd (HMul.hMul ((CliffordAlgebra.ι Q) a) ((CliffordAlgebra.ι Q) b)) (HMul.hMul ((CliffordAlgebra.ι Q) b) ((CliffordAlgebra.ι Q) a))) 0","decl":"@[simp] theorem ι_mul_ι_add_swap_of_isOrtho {a b : M} (h : Q.IsOrtho a b) :\n    ι Q a * ι Q b + ι Q b * ι Q a = 0 := by\n  rw [ι_mul_ι_add_swap, h.polar_eq_zero]\n  simp\n\n"}
{"name":"CliffordAlgebra.ι_mul_ι_comm_of_isOrtho","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na b : M\nh : QuadraticMap.IsOrtho Q a b\n⊢ Eq (HMul.hMul ((CliffordAlgebra.ι Q) a) ((CliffordAlgebra.ι Q) b)) (Neg.neg (HMul.hMul ((CliffordAlgebra.ι Q) b) ((CliffordAlgebra.ι Q) a)))","decl":"theorem ι_mul_ι_comm_of_isOrtho {a b : M} (h : Q.IsOrtho a b) :\n    ι Q a * ι Q b = -(ι Q b * ι Q a) :=\n  eq_neg_of_add_eq_zero_left <| ι_mul_ι_add_swap_of_isOrtho h\n\n"}
{"name":"CliffordAlgebra.mul_ι_mul_ι_of_isOrtho","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\na b : M\nh : QuadraticMap.IsOrtho Q a b\n⊢ Eq (HMul.hMul (HMul.hMul x ((CliffordAlgebra.ι Q) a)) ((CliffordAlgebra.ι Q) b)) (Neg.neg (HMul.hMul (HMul.hMul x ((CliffordAlgebra.ι Q) b)) ((CliffordAlgebra.ι Q) a)))","decl":"theorem mul_ι_mul_ι_of_isOrtho (x : CliffordAlgebra Q) {a b : M} (h : Q.IsOrtho a b) :\n    x * ι Q a * ι Q b = -(x * ι Q b * ι Q a) := by\n  rw [mul_assoc, ι_mul_ι_comm_of_isOrtho h, mul_neg, mul_assoc]\n\n"}
{"name":"CliffordAlgebra.ι_mul_ι_mul_of_isOrtho","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\na b : M\nh : QuadraticMap.IsOrtho Q a b\n⊢ Eq (HMul.hMul ((CliffordAlgebra.ι Q) a) (HMul.hMul ((CliffordAlgebra.ι Q) b) x)) (Neg.neg (HMul.hMul ((CliffordAlgebra.ι Q) b) (HMul.hMul ((CliffordAlgebra.ι Q) a) x)))","decl":"theorem ι_mul_ι_mul_of_isOrtho (x : CliffordAlgebra Q) {a b : M} (h : Q.IsOrtho a b) :\n    ι Q a * (ι Q b * x) = -(ι Q b * (ι Q a * x)) := by\n  rw [← mul_assoc, ι_mul_ι_comm_of_isOrtho h, neg_mul, mul_assoc]\n\n"}
{"name":"CliffordAlgebra.ι_mul_ι_mul_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na b : M\n⊢ Eq (HMul.hMul (HMul.hMul ((CliffordAlgebra.ι Q) a) ((CliffordAlgebra.ι Q) b)) ((CliffordAlgebra.ι Q) a)) ((CliffordAlgebra.ι Q) (HSub.hSub (HSMul.hSMul (QuadraticMap.polar (⇑Q) a b) a) (HSMul.hSMul (Q a) b)))","decl":"/-- $aba$ is a vector. -/\ntheorem ι_mul_ι_mul_ι (a b : M) :\n    ι Q a * ι Q b * ι Q a = ι Q (QuadraticMap.polar Q a b • a - Q a • b) := by\n  rw [ι_mul_ι_comm, sub_mul, mul_assoc, ι_sq_scalar, ← Algebra.smul_def, ← Algebra.commutes, ←\n    Algebra.smul_def, ← map_smul, ← map_smul, ← map_sub]\n\n"}
{"name":"CliffordAlgebra.ι_range_map_lift","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nQ : QuadraticForm R M\nA : Type u_3\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : LinearMap (RingHom.id R) M A\ncond : ∀ (m : M), Eq (HMul.hMul (f m) (f m)) ((algebraMap R A) (Q m))\n⊢ Eq (Submodule.map ((CliffordAlgebra.lift Q) ⟨f, cond⟩).toLinearMap (LinearMap.range (CliffordAlgebra.ι Q))) (LinearMap.range f)","decl":"@[simp]\ntheorem ι_range_map_lift (f : M →ₗ[R] A) (cond : ∀ m, f m * f m = algebraMap _ _ (Q m)) :\n    (ι Q).range.map (lift Q ⟨f, cond⟩).toLinearMap = LinearMap.range f := by\n  rw [← LinearMap.range_comp, ι_comp_lift]\n\n"}
{"name":"CliffordAlgebra.map_comp_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM₁ : Type u_4\nM₂ : Type u_5\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nf : QuadraticMap.Isometry Q₁ Q₂\n⊢ Eq ((CliffordAlgebra.map f).toLinearMap.comp (CliffordAlgebra.ι Q₁)) ((CliffordAlgebra.ι Q₂).comp f.toLinearMap)","decl":"@[simp]\ntheorem map_comp_ι (f : Q₁ →qᵢ Q₂) :\n    (map f).toLinearMap ∘ₗ ι Q₁ = ι Q₂ ∘ₗ f.toLinearMap :=\n  ι_comp_lift _ _\n\n"}
{"name":"CliffordAlgebra.map_apply_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM₁ : Type u_4\nM₂ : Type u_5\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nf : QuadraticMap.Isometry Q₁ Q₂\nm : M₁\n⊢ Eq ((CliffordAlgebra.map f) ((CliffordAlgebra.ι Q₁) m)) ((CliffordAlgebra.ι Q₂) (f m))","decl":"@[simp]\ntheorem map_apply_ι (f : Q₁ →qᵢ Q₂) (m : M₁) : map f (ι Q₁ m) = ι Q₂ (f m) :=\n  lift_ι_apply _ _ m\n\n"}
{"name":"CliffordAlgebra.map_id","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM₁ : Type u_4\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R M₁\nQ₁ : QuadraticForm R M₁\n⊢ Eq (CliffordAlgebra.map (QuadraticMap.Isometry.id Q₁)) (AlgHom.id R (CliffordAlgebra Q₁))","decl":"variable (Q₁) in\n@[simp]\ntheorem map_id : map (QuadraticMap.Isometry.id Q₁) = AlgHom.id R (CliffordAlgebra Q₁) := by\n  ext m; exact map_apply_ι _ m\n\n"}
{"name":"CliffordAlgebra.map_comp_map","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM₁ : Type u_4\nM₂ : Type u_5\nM₃ : Type u_6\ninst✝⁵ : AddCommGroup M₁\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : AddCommGroup M₃\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nQ₃ : QuadraticForm R M₃\nf : QuadraticMap.Isometry Q₂ Q₃\ng : QuadraticMap.Isometry Q₁ Q₂\n⊢ Eq ((CliffordAlgebra.map f).comp (CliffordAlgebra.map g)) (CliffordAlgebra.map (f.comp g))","decl":"@[simp]\ntheorem map_comp_map (f : Q₂ →qᵢ Q₃) (g : Q₁ →qᵢ Q₂) :\n    (map f).comp (map g) = map (f.comp g) := by\n  ext m\n  dsimp only [LinearMap.comp_apply, AlgHom.comp_apply, AlgHom.toLinearMap_apply, AlgHom.id_apply]\n  rw [map_apply_ι, map_apply_ι, map_apply_ι, QuadraticMap.Isometry.comp_apply]\n\n"}
{"name":"CliffordAlgebra.ι_range_map_map","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM₁ : Type u_4\nM₂ : Type u_5\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nf : QuadraticMap.Isometry Q₁ Q₂\n⊢ Eq (Submodule.map (CliffordAlgebra.map f).toLinearMap (LinearMap.range (CliffordAlgebra.ι Q₁))) (Submodule.map (CliffordAlgebra.ι Q₂) (LinearMap.range f.toLinearMap))","decl":"@[simp]\ntheorem ι_range_map_map (f : Q₁ →qᵢ Q₂) :\n    (ι Q₁).range.map (map f).toLinearMap = f.range.map (ι Q₂) :=\n  (ι_range_map_lift _ _).trans (LinearMap.range_comp _ _)\n\n"}
{"name":"CliffordAlgebra.leftInverse_map_of_leftInverse","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM₁ : Type u_4\nM₂ : Type u_5\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nf : QuadraticMap.Isometry Q₁ Q₂\ng : QuadraticMap.Isometry Q₂ Q₁\nh : Function.LeftInverse ⇑g ⇑f\n⊢ Function.LeftInverse ⇑(CliffordAlgebra.map g) ⇑(CliffordAlgebra.map f)","decl":"open Function in\n/-- If `f` is a linear map from `M₁` to `M₂` that preserves the quadratic forms, and if it has\na linear retraction `g` that also preserves the quadratic forms, then `CliffordAlgebra.map g`\nis a retraction of `CliffordAlgebra.map f`. -/\nlemma leftInverse_map_of_leftInverse {Q₁ : QuadraticForm R M₁} {Q₂ : QuadraticForm R M₂}\n    (f : Q₁ →qᵢ Q₂) (g : Q₂ →qᵢ Q₁) (h : LeftInverse g f) : LeftInverse (map g) (map f) := by\n  refine fun x => ?_\n  replace h : g.comp f = QuadraticMap.Isometry.id Q₁ := DFunLike.ext _ _ h\n  rw [← AlgHom.comp_apply, map_comp_map, h, map_id, AlgHom.coe_id, id_eq]\n\n"}
{"name":"CliffordAlgebra.map_surjective","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM₁ : Type u_4\nM₂ : Type u_5\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nf : QuadraticMap.Isometry Q₁ Q₂\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective ⇑(CliffordAlgebra.map f)","decl":"/-- If a linear map preserves the quadratic forms and is surjective, then the algebra\nmaps it induces between Clifford algebras is also surjective. -/\nlemma map_surjective {Q₁ : QuadraticForm R M₁} {Q₂ : QuadraticForm R M₂} (f : Q₁ →qᵢ Q₂)\n    (hf : Function.Surjective f) : Function.Surjective (CliffordAlgebra.map f) :=\n  CliffordAlgebra.induction\n    (fun r ↦ ⟨algebraMap R (CliffordAlgebra Q₁) r, by simp only [AlgHom.commutes]⟩)\n    (fun y ↦ let ⟨x, hx⟩ := hf y; ⟨CliffordAlgebra.ι Q₁ x, by simp only [map_apply_ι, hx]⟩)\n    (fun _ _ ⟨x, hx⟩ ⟨y, hy⟩ ↦ ⟨x * y, by simp only [map_mul, hx, hy]⟩)\n    (fun _ _ ⟨x, hx⟩ ⟨y, hy⟩ ↦ ⟨x + y, by simp only [map_add, hx, hy]⟩)\n\n"}
{"name":"CliffordAlgebra.equivOfIsometry_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM₁ : Type u_4\nM₂ : Type u_5\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\ne : QuadraticMap.IsometryEquiv Q₁ Q₂\na : CliffordAlgebra Q₁\n⊢ Eq ((CliffordAlgebra.equivOfIsometry e) a) ((CliffordAlgebra.map e.toIsometry) a)","decl":"/-- Two `CliffordAlgebra`s are equivalent as algebras if their quadratic forms are\nequivalent. -/\n@[simps! apply]\ndef equivOfIsometry (e : Q₁.IsometryEquiv Q₂) : CliffordAlgebra Q₁ ≃ₐ[R] CliffordAlgebra Q₂ :=\n  AlgEquiv.ofAlgHom (map e.toIsometry) (map e.symm.toIsometry)\n    ((map_comp_map _ _).trans <| by\n      convert map_id Q₂ using 2  -- Porting note: replaced `_` with `Q₂`\n      ext m\n      exact e.toLinearEquiv.apply_symm_apply m)\n    ((map_comp_map _ _).trans <| by\n      convert map_id Q₁ using 2  -- Porting note: replaced `_` with `Q₁`\n      ext m\n      exact e.toLinearEquiv.symm_apply_apply m)\n\n"}
{"name":"CliffordAlgebra.equivOfIsometry_symm","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM₁ : Type u_4\nM₂ : Type u_5\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\ne : QuadraticMap.IsometryEquiv Q₁ Q₂\n⊢ Eq (CliffordAlgebra.equivOfIsometry e).symm (CliffordAlgebra.equivOfIsometry e.symm)","decl":"@[simp]\ntheorem equivOfIsometry_symm (e : Q₁.IsometryEquiv Q₂) :\n    (equivOfIsometry e).symm = equivOfIsometry e.symm :=\n  rfl\n\n"}
{"name":"CliffordAlgebra.equivOfIsometry_trans","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nM₁ : Type u_4\nM₂ : Type u_5\nM₃ : Type u_6\ninst✝⁵ : AddCommGroup M₁\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : AddCommGroup M₃\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nQ₃ : QuadraticForm R M₃\ne₁₂ : QuadraticMap.IsometryEquiv Q₁ Q₂\ne₂₃ : QuadraticMap.IsometryEquiv Q₂ Q₃\n⊢ Eq ((CliffordAlgebra.equivOfIsometry e₁₂).trans (CliffordAlgebra.equivOfIsometry e₂₃)) (CliffordAlgebra.equivOfIsometry (e₁₂.trans e₂₃))","decl":"@[simp]\ntheorem equivOfIsometry_trans (e₁₂ : Q₁.IsometryEquiv Q₂) (e₂₃ : Q₂.IsometryEquiv Q₃) :\n    (equivOfIsometry e₁₂).trans (equivOfIsometry e₂₃) = equivOfIsometry (e₁₂.trans e₂₃) := by\n  ext x\n  exact AlgHom.congr_fun (map_comp_map _ _) x\n\n"}
{"name":"CliffordAlgebra.equivOfIsometry_refl","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM₁ : Type u_4\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R M₁\nQ₁ : QuadraticForm R M₁\n⊢ Eq (CliffordAlgebra.equivOfIsometry (QuadraticMap.IsometryEquiv.refl Q₁)) AlgEquiv.refl","decl":"@[simp]\ntheorem equivOfIsometry_refl :\n    (equivOfIsometry <| QuadraticMap.IsometryEquiv.refl Q₁) = AlgEquiv.refl := by\n  ext x\n  exact AlgHom.congr_fun (map_id Q₁) x\n\n"}
{"name":"TensorAlgebra.toClifford_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq (TensorAlgebra.toClifford ((TensorAlgebra.ι R) m)) ((CliffordAlgebra.ι Q) m)","decl":"@[simp]\ntheorem toClifford_ι (m : M) : toClifford (TensorAlgebra.ι R m) = CliffordAlgebra.ι Q m := by\n  simp [toClifford]\n\n"}
