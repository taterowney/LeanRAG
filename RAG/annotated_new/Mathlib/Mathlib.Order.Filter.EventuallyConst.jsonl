{"name":"Filter.HasBasis.eventuallyConst_iff","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\nι : Sort u_5\np : ι → Prop\ns : ι → Set α\nh : l.HasBasis p s\n⊢ Iff (Filter.EventuallyConst f l) (Exists fun i => And (p i) (∀ (x : α), Membership.mem (s i) x → ∀ (y : α), Membership.mem (s i) y → Eq (f x) (f y)))","decl":"theorem HasBasis.eventuallyConst_iff {ι : Sort*} {p : ι → Prop} {s : ι → Set α}\n    (h : l.HasBasis p s) : EventuallyConst f l ↔ ∃ i, p i ∧ ∀ x ∈ s i, ∀ y ∈ s i, f x = f y :=\n  (h.map f).subsingleton_iff.trans <| by simp only [Set.Subsingleton, forall_mem_image]\n\n"}
{"name":"Filter.HasBasis.eventuallyConst_iff'","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\nι : Sort u_5\np : ι → Prop\ns : ι → Set α\nx : ι → α\nh : l.HasBasis p s\nhx : ∀ (i : ι), p i → Membership.mem (s i) (x i)\n⊢ Iff (Filter.EventuallyConst f l) (Exists fun i => And (p i) (∀ (y : α), Membership.mem (s i) y → Eq (f y) (f (x i))))","decl":"theorem HasBasis.eventuallyConst_iff' {ι : Sort*} {p : ι → Prop} {s : ι → Set α}\n    {x : ι → α} (h : l.HasBasis p s) (hx : ∀ i, p i → x i ∈ s i) :\n    EventuallyConst f l ↔ ∃ i, p i ∧ ∀ y ∈ s i, f y = f (x i) :=\n  h.eventuallyConst_iff.trans <| exists_congr fun i ↦ and_congr_right fun hi ↦\n    ⟨fun h ↦ (h · · (x i) (hx i hi)), fun h a ha b hb ↦ h a ha ▸ (h b hb).symm⟩\n\n"}
{"name":"Filter.eventuallyConst_iff_tendsto","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\ninst✝ : Nonempty β\n⊢ Iff (Filter.EventuallyConst f l) (Exists fun x => Filter.Tendsto f l (Pure.pure x))","decl":"lemma eventuallyConst_iff_tendsto [Nonempty β] :\n    EventuallyConst f l ↔ ∃ x, Tendsto f l (pure x) :=\n  subsingleton_iff_exists_le_pure\n\n"}
{"name":"Filter.EventuallyConst.exists_tendsto","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\ninst✝ : Nonempty β\na✝ : Filter.EventuallyConst f l\n⊢ Exists fun x => Filter.Tendsto f l (Pure.pure x)","decl":"alias ⟨EventuallyConst.exists_tendsto, _⟩ := eventuallyConst_iff_tendsto\n\n"}
{"name":"Filter.EventuallyConst.of_tendsto","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\nx : β\nh : Filter.Tendsto f l (Pure.pure x)\n⊢ Filter.EventuallyConst f l","decl":"theorem EventuallyConst.of_tendsto {x : β} (h : Tendsto f l (pure x)) : EventuallyConst f l :=\n  have : Nonempty β := ⟨x⟩; eventuallyConst_iff_tendsto.2 ⟨x, h⟩\n\n"}
{"name":"Filter.eventuallyConst_iff_exists_eventuallyEq","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\ninst✝ : Nonempty β\n⊢ Iff (Filter.EventuallyConst f l) (Exists fun c => l.EventuallyEq f fun x => c)","decl":"theorem eventuallyConst_iff_exists_eventuallyEq [Nonempty β] :\n    EventuallyConst f l ↔ ∃ c, f =ᶠ[l] fun _ ↦ c :=\n  subsingleton_iff_exists_singleton_mem\n\n"}
{"name":"Filter.EventuallyConst.eventuallyEq_const","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\ninst✝ : Nonempty β\na✝ : Filter.EventuallyConst f l\n⊢ Exists fun c => l.EventuallyEq f fun x => c","decl":"alias ⟨EventuallyConst.eventuallyEq_const, _⟩ := eventuallyConst_iff_exists_eventuallyEq\n\n"}
{"name":"Filter.eventuallyConst_pred'","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nl : Filter α\np : α → Prop\n⊢ Iff (Filter.EventuallyConst p l) (Or (l.EventuallyEq p fun x => False) (l.EventuallyEq p fun x => True))","decl":"theorem eventuallyConst_pred' {p : α → Prop} :\n    EventuallyConst p l ↔ (p =ᶠ[l] fun _ ↦ False) ∨ (p =ᶠ[l] fun _ ↦ True) := by\n  simp only [eventuallyConst_iff_exists_eventuallyEq, Prop.exists_iff]\n\n"}
{"name":"Filter.eventuallyConst_pred","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nl : Filter α\np : α → Prop\n⊢ Iff (Filter.EventuallyConst p l) (Or (Filter.Eventually (fun x => p x) l) (Filter.Eventually (fun x => Not (p x)) l))","decl":"theorem eventuallyConst_pred {p : α → Prop} :\n    EventuallyConst p l ↔ (∀ᶠ x in l, p x) ∨ (∀ᶠ x in l, ¬p x) := by\n  simp [eventuallyConst_pred', or_comm, EventuallyEq]\n\n"}
{"name":"Filter.eventuallyConst_set'","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nl : Filter α\ns : Set α\n⊢ Iff (Filter.EventuallyConst s l) (Or (l.EventuallyEq s EmptyCollection.emptyCollection) (l.EventuallyEq s Set.univ))","decl":"theorem eventuallyConst_set' {s : Set α} :\n    EventuallyConst s l ↔ (s =ᶠ[l] (∅ : Set α)) ∨ s =ᶠ[l] univ :=\n  eventuallyConst_pred'\n\n"}
{"name":"Filter.eventuallyConst_set","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nl : Filter α\ns : Set α\n⊢ Iff (Filter.EventuallyConst s l) (Or (Filter.Eventually (fun x => Membership.mem s x) l) (Filter.Eventually (fun x => Not (Membership.mem s x)) l))","decl":"theorem eventuallyConst_set {s : Set α} :\n    EventuallyConst s l ↔ (∀ᶠ x in l, x ∈ s) ∨ (∀ᶠ x in l, x ∉ s) :=\n  eventuallyConst_pred\n\n"}
{"name":"Filter.eventuallyConst_preimage","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ns : Set β\nf : α → β\n⊢ Iff (Filter.EventuallyConst (Set.preimage f s) l) (Filter.EventuallyConst s (Filter.map f l))","decl":"theorem eventuallyConst_preimage {s : Set β} {f : α → β} :\n    EventuallyConst (f ⁻¹' s) l ↔ EventuallyConst s (map f l) :=\n  .rfl\n\n"}
{"name":"Filter.EventuallyEq.eventuallyConst_iff","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf g : α → β\nh : l.EventuallyEq f g\n⊢ Iff (Filter.EventuallyConst f l) (Filter.EventuallyConst g l)","decl":"theorem EventuallyEq.eventuallyConst_iff {g : α → β} (h : f =ᶠ[l] g) :\n    EventuallyConst f l ↔ EventuallyConst g l := by\n  simp only [EventuallyConst, map_congr h]\n\n"}
{"name":"Filter.eventuallyConst_id","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nl : Filter α\n⊢ Iff (Filter.EventuallyConst id l) l.Subsingleton","decl":"@[simp] theorem eventuallyConst_id : EventuallyConst id l ↔ l.Subsingleton := Iff.rfl\n\n"}
{"name":"Filter.EventuallyConst.bot","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Filter.EventuallyConst f Bot.bot","decl":"@[simp] protected lemma bot : EventuallyConst f ⊥ := subsingleton_bot\n\n"}
{"name":"Filter.EventuallyConst.const","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nc : β\n⊢ Filter.EventuallyConst (fun x => c) l","decl":"@[simp]\nprotected lemma const (c : β) : EventuallyConst (fun _ ↦ c) l :=\n  .of_tendsto tendsto_const_pure\n\n"}
{"name":"Filter.EventuallyConst.congr","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf g : α → β\nh : Filter.EventuallyConst f l\nhg : l.EventuallyEq f g\n⊢ Filter.EventuallyConst g l","decl":"protected lemma congr {g} (h : EventuallyConst f l) (hg : f =ᶠ[l] g) : EventuallyConst g l :=\n  hg.eventuallyConst_iff.1 h\n\n"}
{"name":"Filter.EventuallyConst.of_subsingleton_right","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\ninst✝ : Subsingleton β\n⊢ Filter.EventuallyConst f l","decl":"@[nontriviality]\nlemma of_subsingleton_right [Subsingleton β] : EventuallyConst f l := .of_subsingleton\n\n"}
{"name":"Filter.EventuallyConst.anti","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\nl' : Filter α\nh : Filter.EventuallyConst f l\nhl' : LE.le l' l\n⊢ Filter.EventuallyConst f l'","decl":"nonrec lemma anti {l'} (h : EventuallyConst f l) (hl' : l' ≤ l) : EventuallyConst f l' :=\n  h.anti (map_mono hl')\n\n"}
{"name":"Filter.EventuallyConst.of_subsingleton_left","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\ninst✝ : Subsingleton α\n⊢ Filter.EventuallyConst f l","decl":"@[nontriviality]\nlemma of_subsingleton_left [Subsingleton α] : EventuallyConst f l :=\n  .map .of_subsingleton f\n\n"}
{"name":"Filter.EventuallyConst.comp","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nf : α → β\nh : Filter.EventuallyConst f l\ng : β → γ\n⊢ Filter.EventuallyConst (Function.comp g f) l","decl":"lemma comp (h : EventuallyConst f l) (g : β → γ) : EventuallyConst (g ∘ f) l := h.map g\n\n"}
{"name":"Filter.EventuallyConst.inv","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\ninst✝ : Inv β\nh : Filter.EventuallyConst f l\n⊢ Filter.EventuallyConst (Inv.inv f) l","decl":"@[to_additive]\nprotected lemma inv [Inv β] (h : EventuallyConst f l) : EventuallyConst (f⁻¹) l := h.comp Inv.inv\n\n"}
{"name":"Filter.EventuallyConst.neg","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\ninst✝ : Neg β\nh : Filter.EventuallyConst f l\n⊢ Filter.EventuallyConst (Neg.neg f) l","decl":"@[to_additive]\nprotected lemma inv [Inv β] (h : EventuallyConst f l) : EventuallyConst (f⁻¹) l := h.comp Inv.inv\n\n"}
{"name":"Filter.EventuallyConst.comp_tendsto","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nf : α → β\nlb : Filter β\ng : β → γ\nhg : Filter.EventuallyConst g lb\nhf : Filter.Tendsto f l lb\n⊢ Filter.EventuallyConst (Function.comp g f) l","decl":"lemma comp_tendsto {lb : Filter β} {g : β → γ} (hg : EventuallyConst g lb)\n    (hf : Tendsto f l lb) : EventuallyConst (g ∘ f) l :=\n  hg.anti hf\n\n"}
{"name":"Filter.EventuallyConst.apply","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nl : Filter α\nι : Type u_5\np : ι → Type u_6\ng : α → (x : ι) → p x\nh : Filter.EventuallyConst g l\ni : ι\n⊢ Filter.EventuallyConst (fun x => g x i) l","decl":"lemma apply {ι : Type*} {p : ι → Type*} {g : α → ∀ x, p x}\n    (h : EventuallyConst g l) (i : ι) : EventuallyConst (g · i) l :=\n  h.comp <| Function.eval i\n\n"}
{"name":"Filter.EventuallyConst.comp₂","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nl : Filter α\nf : α → β\ng : α → γ\nhf : Filter.EventuallyConst f l\nop : β → γ → δ\nhg : Filter.EventuallyConst g l\n⊢ Filter.EventuallyConst (fun x => op (f x) (g x)) l","decl":"lemma comp₂ {g : α → γ} (hf : EventuallyConst f l) (op : β → γ → δ) (hg : EventuallyConst g l) :\n    EventuallyConst (fun x ↦ op (f x) (g x)) l :=\n  ((hf.prod hg).map op.uncurry).anti <|\n    (tendsto_map (f := op.uncurry)).comp (tendsto_map.prod_mk tendsto_map)\n\n"}
{"name":"Filter.EventuallyConst.prod_mk","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nl : Filter α\nf : α → β\ng : α → γ\nhf : Filter.EventuallyConst f l\nhg : Filter.EventuallyConst g l\n⊢ Filter.EventuallyConst (fun x => { fst := f x, snd := g x }) l","decl":"lemma prod_mk {g : α → γ} (hf : EventuallyConst f l) (hg : EventuallyConst g l) :\n    EventuallyConst (fun x ↦ (f x, g x)) l :=\n  hf.comp₂ Prod.mk hg\n\n"}
{"name":"Filter.EventuallyConst.add","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\ninst✝ : Add β\ng : α → β\nhf : Filter.EventuallyConst f l\nhg : Filter.EventuallyConst g l\n⊢ Filter.EventuallyConst (HAdd.hAdd f g) l","decl":"@[to_additive]\nlemma mul [Mul β] {g : α → β} (hf : EventuallyConst f l) (hg : EventuallyConst g l) :\n    EventuallyConst (f * g) l :=\n  hf.comp₂ (· * ·) hg\n\n"}
{"name":"Filter.EventuallyConst.mul","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\nf : α → β\ninst✝ : Mul β\ng : α → β\nhf : Filter.EventuallyConst f l\nhg : Filter.EventuallyConst g l\n⊢ Filter.EventuallyConst (HMul.hMul f g) l","decl":"@[to_additive]\nlemma mul [Mul β] {g : α → β} (hf : EventuallyConst f l) (hg : EventuallyConst g l) :\n    EventuallyConst (f * g) l :=\n  hf.comp₂ (· * ·) hg\n\n"}
{"name":"Filter.EventuallyConst.of_indicator_const","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : Zero β\ns : Set α\nc : β\nh : Filter.EventuallyConst (s.indicator fun x => c) l\nhc : Ne c 0\n⊢ Filter.EventuallyConst s l","decl":"@[to_additive]\nlemma of_mulIndicator_const (h : EventuallyConst (s.mulIndicator fun _ ↦ c) l) (hc : c ≠ 1) :\n    EventuallyConst s l := by\n  simpa [Function.comp_def, hc, imp_false] using h.comp (· = c)\n\n"}
{"name":"Filter.EventuallyConst.of_mulIndicator_const","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : One β\ns : Set α\nc : β\nh : Filter.EventuallyConst (s.mulIndicator fun x => c) l\nhc : Ne c 1\n⊢ Filter.EventuallyConst s l","decl":"@[to_additive]\nlemma of_mulIndicator_const (h : EventuallyConst (s.mulIndicator fun _ ↦ c) l) (hc : c ≠ 1) :\n    EventuallyConst s l := by\n  simpa [Function.comp_def, hc, imp_false] using h.comp (· = c)\n\n"}
{"name":"Filter.EventuallyConst.mulIndicator_const","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : One β\ns : Set α\nh : Filter.EventuallyConst s l\nc : β\n⊢ Filter.EventuallyConst (s.mulIndicator fun x => c) l","decl":"@[to_additive]\ntheorem mulIndicator_const (h : EventuallyConst s l) (c : β) :\n    EventuallyConst (s.mulIndicator fun _ ↦ c) l := by\n  classical exact h.comp (if · then c else 1)\n\n"}
{"name":"Filter.EventuallyConst.indicator_const","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : Zero β\ns : Set α\nh : Filter.EventuallyConst s l\nc : β\n⊢ Filter.EventuallyConst (s.indicator fun x => c) l","decl":"@[to_additive]\ntheorem mulIndicator_const (h : EventuallyConst s l) (c : β) :\n    EventuallyConst (s.mulIndicator fun _ ↦ c) l := by\n  classical exact h.comp (if · then c else 1)\n\n"}
{"name":"Filter.EventuallyConst.mulIndicator_const_iff_of_ne","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : One β\ns : Set α\nc : β\nhc : Ne c 1\n⊢ Iff (Filter.EventuallyConst (s.mulIndicator fun x => c) l) (Filter.EventuallyConst s l)","decl":"@[to_additive]\ntheorem mulIndicator_const_iff_of_ne (hc : c ≠ 1) :\n    EventuallyConst (s.mulIndicator fun _ ↦ c) l ↔ EventuallyConst s l :=\n  ⟨(of_mulIndicator_const · hc), (mulIndicator_const · c)⟩\n\n"}
{"name":"Filter.EventuallyConst.indicator_const_iff_of_ne","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : Zero β\ns : Set α\nc : β\nhc : Ne c 0\n⊢ Iff (Filter.EventuallyConst (s.indicator fun x => c) l) (Filter.EventuallyConst s l)","decl":"@[to_additive]\ntheorem mulIndicator_const_iff_of_ne (hc : c ≠ 1) :\n    EventuallyConst (s.mulIndicator fun _ ↦ c) l ↔ EventuallyConst s l :=\n  ⟨(of_mulIndicator_const · hc), (mulIndicator_const · c)⟩\n\n"}
{"name":"Filter.EventuallyConst.indicator_const_iff","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : Zero β\ns : Set α\nc : β\n⊢ Iff (Filter.EventuallyConst (s.indicator fun x => c) l) (Or (Eq c 0) (Filter.EventuallyConst s l))","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_const_iff :\n    EventuallyConst (s.mulIndicator fun _ ↦ c) l ↔ c = 1 ∨ EventuallyConst s l := by\n  rcases eq_or_ne c 1 with rfl | hc <;> simp [mulIndicator_const_iff_of_ne, *]\n\n"}
{"name":"Filter.EventuallyConst.mulIndicator_const_iff","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\ninst✝ : One β\ns : Set α\nc : β\n⊢ Iff (Filter.EventuallyConst (s.mulIndicator fun x => c) l) (Or (Eq c 1) (Filter.EventuallyConst s l))","decl":"@[to_additive (attr := simp)]\ntheorem mulIndicator_const_iff :\n    EventuallyConst (s.mulIndicator fun _ ↦ c) l ↔ c = 1 ∨ EventuallyConst s l := by\n  rcases eq_or_ne c 1 with rfl | hc <;> simp [mulIndicator_const_iff_of_ne, *]\n\n"}
{"name":"Filter.eventuallyConst_atTop","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : SemilatticeSup α\ninst✝ : Nonempty α\n⊢ Iff (Filter.EventuallyConst f Filter.atTop) (Exists fun i => ∀ (j : α), LE.le i j → Eq (f j) (f i))","decl":"lemma eventuallyConst_atTop [SemilatticeSup α] [Nonempty α] :\n    EventuallyConst f atTop ↔ (∃ i, ∀ j, i ≤ j → f j = f i) :=\n  (atTop_basis.eventuallyConst_iff' fun _ _ ↦ left_mem_Ici).trans <| by\n    simp only [true_and, mem_Ici]\n\n"}
{"name":"Filter.eventuallyConst_atTop_nat","module":"Mathlib.Order.Filter.EventuallyConst","initialProofState":"α : Type u_1\nf : Nat → α\n⊢ Iff (Filter.EventuallyConst f Filter.atTop) (Exists fun n => ∀ (m : Nat), LE.le n m → Eq (f (HAdd.hAdd m 1)) (f m))","decl":"lemma eventuallyConst_atTop_nat {f : ℕ → α} :\n    EventuallyConst f atTop ↔ ∃ n, ∀ m, n ≤ m → f (m + 1) = f m := by\n  rw [eventuallyConst_atTop]\n  refine exists_congr fun n ↦ ⟨fun h m hm ↦ ?_, fun h m hm ↦ ?_⟩\n  · exact (h (m + 1) (hm.trans m.le_succ)).trans (h m hm).symm\n  · induction m, hm using Nat.le_induction with\n    | base => rfl\n    | succ m hm ihm => exact (h m hm).trans ihm\n\n"}
