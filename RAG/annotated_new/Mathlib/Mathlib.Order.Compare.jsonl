{"name":"cmpLE_swap","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_3\ninst✝² : LE α\ninst✝¹ : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nx y : α\n⊢ Eq (cmpLE x y).swap (cmpLE y x)","decl":"theorem cmpLE_swap {α} [LE α] [IsTotal α (· ≤ ·)] [DecidableRel (α := α) (· ≤ ·)] (x y : α) :\n    (cmpLE x y).swap = cmpLE y x := by\n  by_cases xy : x ≤ y <;> by_cases yx : y ≤ x <;> simp [cmpLE, *, Ordering.swap]\n  cases not_or_intro xy yx (total_of _ _ _)\n\n"}
{"name":"cmpLE_eq_cmp","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_3\ninst✝³ : Preorder α\ninst✝² : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nx y : α\n⊢ Eq (cmpLE x y) (cmp x y)","decl":"theorem cmpLE_eq_cmp {α} [Preorder α] [IsTotal α (· ≤ ·)] [DecidableRel (α := α) (· ≤ ·)]\n    [DecidableRel (α := α) (· < ·)] (x y : α) : cmpLE x y = cmp x y := by\n  by_cases xy : x ≤ y <;> by_cases yx : y ≤ x <;> simp [cmpLE, lt_iff_le_not_le, *, cmp, cmpUsing]\n  cases not_or_intro xy yx (total_of _ _ _)\n\n"}
{"name":"Ordering.compares_swap","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : α\no : Ordering\n⊢ Iff (o.swap.Compares a b) (o.Compares b a)","decl":"theorem compares_swap [LT α] {a b : α} {o : Ordering} : o.swap.Compares a b ↔ o.Compares b a := by\n  cases o\n  · exact Iff.rfl\n  · exact eq_comm\n  · exact Iff.rfl\n\n"}
{"name":"Ordering.Compares.swap","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : α\no : Ordering\na✝ : o.Compares b a\n⊢ o.swap.Compares a b","decl":"alias ⟨Compares.of_swap, Compares.swap⟩ := compares_swap\n\n"}
{"name":"Ordering.Compares.of_swap","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : α\no : Ordering\na✝ : o.swap.Compares a b\n⊢ o.Compares b a","decl":"alias ⟨Compares.of_swap, Compares.swap⟩ := compares_swap\n\n"}
{"name":"Ordering.swap_eq_iff_eq_swap","module":"Mathlib.Order.Compare","initialProofState":"o o' : Ordering\n⊢ Iff (Eq o.swap o') (Eq o o'.swap)","decl":"theorem swap_eq_iff_eq_swap {o o' : Ordering} : o.swap = o' ↔ o = o'.swap := by\n  rw [← swap_inj, swap_swap]\n\n"}
{"name":"Ordering.Compares.eq_lt","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : Preorder α\no : Ordering\na b : α\na✝ : o.Compares a b\n⊢ Iff (Eq o Ordering.lt) (LT.lt a b)","decl":"theorem Compares.eq_lt [Preorder α] : ∀ {o} {a b : α}, Compares o a b → (o = lt ↔ a < b)\n  | lt, _, _, h => ⟨fun _ => h, fun _ => rfl⟩\n  | eq, a, b, h => ⟨fun h => by injection h, fun h' => (ne_of_lt h' h).elim⟩\n  | gt, a, b, h => ⟨fun h => by injection h, fun h' => (lt_asymm h h').elim⟩\n\n"}
{"name":"Ordering.Compares.ne_lt","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : Preorder α\no : Ordering\na b : α\na✝ : o.Compares a b\n⊢ Iff (Ne o Ordering.lt) (LE.le b a)","decl":"theorem Compares.ne_lt [Preorder α] : ∀ {o} {a b : α}, Compares o a b → (o ≠ lt ↔ b ≤ a)\n  | lt, _, _, h => ⟨absurd rfl, fun h' => (not_le_of_lt h h').elim⟩\n  | eq, _, _, h => ⟨fun _ => ge_of_eq h, fun _ h => by injection h⟩\n  | gt, _, _, h => ⟨fun _ => le_of_lt h, fun _ h => by injection h⟩\n\n"}
{"name":"Ordering.Compares.eq_eq","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : Preorder α\no : Ordering\na b : α\na✝ : o.Compares a b\n⊢ Iff (Eq o Ordering.eq) (Eq a b)","decl":"theorem Compares.eq_eq [Preorder α] : ∀ {o} {a b : α}, Compares o a b → (o = eq ↔ a = b)\n  | lt, a, b, h => ⟨fun h => by injection h, fun h' => (ne_of_lt h h').elim⟩\n  | eq, _, _, h => ⟨fun _ => h, fun _ => rfl⟩\n  | gt, a, b, h => ⟨fun h => by injection h, fun h' => (ne_of_gt h h').elim⟩\n\n"}
{"name":"Ordering.Compares.eq_gt","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : Preorder α\no : Ordering\na b : α\nh : o.Compares a b\n⊢ Iff (Eq o Ordering.gt) (LT.lt b a)","decl":"theorem Compares.eq_gt [Preorder α] {o} {a b : α} (h : Compares o a b) : o = gt ↔ b < a :=\n  swap_eq_iff_eq_swap.symm.trans h.swap.eq_lt\n\n"}
{"name":"Ordering.Compares.ne_gt","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : Preorder α\no : Ordering\na b : α\nh : o.Compares a b\n⊢ Iff (Ne o Ordering.gt) (LE.le a b)","decl":"theorem Compares.ne_gt [Preorder α] {o} {a b : α} (h : Compares o a b) : o ≠ gt ↔ a ≤ b :=\n  (not_congr swap_eq_iff_eq_swap.symm).trans h.swap.ne_lt\n\n"}
{"name":"Ordering.Compares.le_total","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\no : Ordering\na✝ : o.Compares a b\n⊢ Or (LE.le a b) (LE.le b a)","decl":"theorem Compares.le_total [Preorder α] {a b : α} : ∀ {o}, Compares o a b → a ≤ b ∨ b ≤ a\n  | lt, h => Or.inl (le_of_lt h)\n  | eq, h => Or.inl (le_of_eq h)\n  | gt, h => Or.inr (le_of_lt h)\n\n"}
{"name":"Ordering.Compares.le_antisymm","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\no : Ordering\na✝² : o.Compares a b\na✝¹ : LE.le a b\na✝ : LE.le b a\n⊢ Eq a b","decl":"theorem Compares.le_antisymm [Preorder α] {a b : α} : ∀ {o}, Compares o a b → a ≤ b → b ≤ a → a = b\n  | lt, h, _, hba => (not_le_of_lt h hba).elim\n  | eq, h, _, _ => h\n  | gt, h, hab, _ => (not_le_of_lt h hab).elim\n\n"}
{"name":"Ordering.Compares.inj","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : Preorder α\no₁ o₂ : Ordering\na b : α\na✝¹ : o₁.Compares a b\na✝ : o₂.Compares a b\n⊢ Eq o₁ o₂","decl":"theorem Compares.inj [Preorder α] {o₁} :\n    ∀ {o₂} {a b : α}, Compares o₁ a b → Compares o₂ a b → o₁ = o₂\n  | lt, _, _, h₁, h₂ => h₁.eq_lt.2 h₂\n  | eq, _, _, h₁, h₂ => h₁.eq_eq.2 h₂\n  | gt, _, _, h₁, h₂ => h₁.eq_gt.2 h₂\n\n-- Porting note: mathlib3 proof uses `change ... at hab`\n"}
{"name":"Ordering.compares_iff_of_compares_impl","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\na b : α\na' b' : β\nh : ∀ {o : Ordering}, o.Compares a b → o.Compares a' b'\no : Ordering\n⊢ Iff (o.Compares a b) (o.Compares a' b')","decl":"theorem compares_iff_of_compares_impl [LinearOrder α] [Preorder β] {a b : α} {a' b' : β}\n    (h : ∀ {o}, Compares o a b → Compares o a' b') (o) : Compares o a b ↔ Compares o a' b' := by\n  refine ⟨h, fun ho => ?_⟩\n  rcases lt_trichotomy a b with hab | hab | hab\n  · have hab : Compares Ordering.lt a b := hab\n    rwa [ho.inj (h hab)]\n  · have hab : Compares Ordering.eq a b := hab\n    rwa [ho.inj (h hab)]\n  · have hab : Compares Ordering.gt a b := hab\n    rwa [ho.inj (h hab)]\n\n"}
{"name":"Ordering.swap_orElse","module":"Mathlib.Order.Compare","initialProofState":"o₁ o₂ : Ordering\n⊢ Eq (o₁.orElse o₂).swap (o₁.swap.orElse o₂.swap)","decl":"set_option linter.deprecated false in\n@[deprecated swap_then (since := \"2024-09-13\")]\ntheorem swap_orElse (o₁ o₂) : (orElse o₁ o₂).swap = orElse o₁.swap o₂.swap := swap_then ..\n\n"}
{"name":"Ordering.orElse_eq_lt","module":"Mathlib.Order.Compare","initialProofState":"o₁ o₂ : Ordering\n⊢ Iff (Eq (o₁.orElse o₂) Ordering.lt) (Or (Eq o₁ Ordering.lt) (And (Eq o₁ Ordering.eq) (Eq o₂ Ordering.lt)))","decl":"set_option linter.deprecated false in\n@[deprecated then_eq_lt (since := \"2024-09-13\")]\ntheorem orElse_eq_lt (o₁ o₂) : orElse o₁ o₂ = lt ↔ o₁ = lt ∨ o₁ = eq ∧ o₂ = lt := then_eq_lt ..\n\n"}
{"name":"toDual_compares_toDual","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : α\no : Ordering\n⊢ Iff (o.Compares (OrderDual.toDual a) (OrderDual.toDual b)) (o.Compares b a)","decl":"@[simp]\ntheorem toDual_compares_toDual [LT α] {a b : α} {o : Ordering} :\n    Compares o (toDual a) (toDual b) ↔ Compares o b a := by\n  cases o\n  exacts [Iff.rfl, eq_comm, Iff.rfl]\n\n"}
{"name":"ofDual_compares_ofDual","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : OrderDual α\no : Ordering\n⊢ Iff (o.Compares (OrderDual.ofDual a) (OrderDual.ofDual b)) (o.Compares b a)","decl":"@[simp]\ntheorem ofDual_compares_ofDual [LT α] {a b : αᵒᵈ} {o : Ordering} :\n    Compares o (ofDual a) (ofDual b) ↔ Compares o b a := by\n  cases o\n  exacts [Iff.rfl, eq_comm, Iff.rfl]\n\n"}
{"name":"cmp_compares","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ (cmp a b).Compares a b","decl":"theorem cmp_compares [LinearOrder α] (a b : α) : (cmp a b).Compares a b := by\n  obtain h | h | h := lt_trichotomy a b <;> simp [cmp, cmpUsing, h, h.not_lt]\n\n"}
{"name":"Ordering.Compares.cmp_eq","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\no : Ordering\nh : o.Compares a b\n⊢ Eq (cmp a b) o","decl":"theorem Ordering.Compares.cmp_eq [LinearOrder α] {a b : α} {o : Ordering} (h : o.Compares a b) :\n    cmp a b = o :=\n  (cmp_compares a b).inj h\n\n"}
{"name":"cmp_swap","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\na b : α\n⊢ Eq (cmp a b).swap (cmp b a)","decl":"@[simp]\ntheorem cmp_swap [Preorder α] [DecidableRel (α := α) (· < ·)] (a b : α) :\n    (cmp a b).swap = cmp b a := by\n  unfold cmp cmpUsing\n  by_cases h : a < b <;> by_cases h₂ : b < a <;> simp [h, h₂, Ordering.swap]\n  exact lt_asymm h h₂\n\n"}
{"name":"cmpLE_toDual","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nx y : α\n⊢ Eq (cmpLE (OrderDual.toDual x) (OrderDual.toDual y)) (cmpLE y x)","decl":"@[simp]\ntheorem cmpLE_toDual [LE α] [DecidableRel (α := α) (· ≤ ·)] (x y : α) :\n    cmpLE (toDual x) (toDual y) = cmpLE y x :=\n  rfl\n\n"}
{"name":"cmpLE_ofDual","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nx y : OrderDual α\n⊢ Eq (cmpLE (OrderDual.ofDual x) (OrderDual.ofDual y)) (cmpLE y x)","decl":"@[simp]\ntheorem cmpLE_ofDual [LE α] [DecidableRel (α := α) (· ≤ ·)] (x y : αᵒᵈ) :\n    cmpLE (ofDual x) (ofDual y) = cmpLE y x :=\n  rfl\n\n"}
{"name":"cmp_toDual","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nx y : α\n⊢ Eq (cmp (OrderDual.toDual x) (OrderDual.toDual y)) (cmp y x)","decl":"@[simp]\ntheorem cmp_toDual [LT α] [DecidableRel (α := α) (· < ·)] (x y : α) :\n    cmp (toDual x) (toDual y) = cmp y x :=\n  rfl\n\n"}
{"name":"cmp_ofDual","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nx y : OrderDual α\n⊢ Eq (cmp (OrderDual.ofDual x) (OrderDual.ofDual y)) (cmp y x)","decl":"@[simp]\ntheorem cmp_ofDual [LT α] [DecidableRel (α := α) (· < ·)] (x y : αᵒᵈ) :\n    cmp (ofDual x) (ofDual y) = cmp y x :=\n  rfl\n\n"}
{"name":"cmp_eq_lt_iff","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\n⊢ Iff (Eq (cmp x y) Ordering.lt) (LT.lt x y)","decl":"@[simp]\ntheorem cmp_eq_lt_iff : cmp x y = Ordering.lt ↔ x < y :=\n  Ordering.Compares.eq_lt (cmp_compares x y)\n\n"}
{"name":"cmp_eq_eq_iff","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\n⊢ Iff (Eq (cmp x y) Ordering.eq) (Eq x y)","decl":"@[simp]\ntheorem cmp_eq_eq_iff : cmp x y = Ordering.eq ↔ x = y :=\n  Ordering.Compares.eq_eq (cmp_compares x y)\n\n"}
{"name":"cmp_eq_gt_iff","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\n⊢ Iff (Eq (cmp x y) Ordering.gt) (LT.lt y x)","decl":"@[simp]\ntheorem cmp_eq_gt_iff : cmp x y = Ordering.gt ↔ y < x :=\n  Ordering.Compares.eq_gt (cmp_compares x y)\n\n"}
{"name":"cmp_self_eq_eq","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx : α\n⊢ Eq (cmp x x) Ordering.eq","decl":"@[simp]\ntheorem cmp_self_eq_eq : cmp x x = Ordering.eq := by rw [cmp_eq_eq_iff]\n\n"}
{"name":"cmp_eq_cmp_symm","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nx y : α\nβ : Type u_3\ninst✝ : LinearOrder β\nx' y' : β\n⊢ Iff (Eq (cmp x y) (cmp x' y')) (Eq (cmp y x) (cmp y' x'))","decl":"theorem cmp_eq_cmp_symm : cmp x y = cmp x' y' ↔ cmp y x = cmp y' x' :=\n  ⟨fun h => by rwa [← cmp_swap x', ← cmp_swap, swap_inj],\n   fun h => by rwa [← cmp_swap y', ← cmp_swap, swap_inj]⟩\n\n"}
{"name":"lt_iff_lt_of_cmp_eq_cmp","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nx y : α\nβ : Type u_3\ninst✝ : LinearOrder β\nx' y' : β\nh : Eq (cmp x y) (cmp x' y')\n⊢ Iff (LT.lt x y) (LT.lt x' y')","decl":"theorem lt_iff_lt_of_cmp_eq_cmp (h : cmp x y = cmp x' y') : x < y ↔ x' < y' := by\n  rw [← cmp_eq_lt_iff, ← cmp_eq_lt_iff, h]\n\n"}
{"name":"le_iff_le_of_cmp_eq_cmp","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nx y : α\nβ : Type u_3\ninst✝ : LinearOrder β\nx' y' : β\nh : Eq (cmp x y) (cmp x' y')\n⊢ Iff (LE.le x y) (LE.le x' y')","decl":"theorem le_iff_le_of_cmp_eq_cmp (h : cmp x y = cmp x' y') : x ≤ y ↔ x' ≤ y' := by\n  rw [← not_lt, ← not_lt]\n  apply not_congr\n  apply lt_iff_lt_of_cmp_eq_cmp\n  rwa [cmp_eq_cmp_symm]\n\n"}
{"name":"eq_iff_eq_of_cmp_eq_cmp","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\nx y : α\nβ : Type u_3\ninst✝ : LinearOrder β\nx' y' : β\nh : Eq (cmp x y) (cmp x' y')\n⊢ Iff (Eq x y) (Eq x' y')","decl":"theorem eq_iff_eq_of_cmp_eq_cmp (h : cmp x y = cmp x' y') : x = y ↔ x' = y' := by\n  rw [le_antisymm_iff, le_antisymm_iff, le_iff_le_of_cmp_eq_cmp h,\n      le_iff_le_of_cmp_eq_cmp (cmp_eq_cmp_symm.1 h)]\n\n"}
{"name":"LT.lt.cmp_eq_lt","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\nh : LT.lt x y\n⊢ Eq (cmp x y) Ordering.lt","decl":"theorem LT.lt.cmp_eq_lt (h : x < y) : cmp x y = Ordering.lt :=\n  (cmp_eq_lt_iff _ _).2 h\n\n"}
{"name":"LT.lt.cmp_eq_gt","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\nh : LT.lt x y\n⊢ Eq (cmp y x) Ordering.gt","decl":"theorem LT.lt.cmp_eq_gt (h : x < y) : cmp y x = Ordering.gt :=\n  (cmp_eq_gt_iff _ _).2 h\n\n"}
{"name":"Eq.cmp_eq_eq","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\nh : Eq x y\n⊢ Eq (cmp x y) Ordering.eq","decl":"theorem Eq.cmp_eq_eq (h : x = y) : cmp x y = Ordering.eq :=\n  (cmp_eq_eq_iff _ _).2 h\n\n"}
{"name":"Eq.cmp_eq_eq'","module":"Mathlib.Order.Compare","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\nh : Eq x y\n⊢ Eq (cmp y x) Ordering.eq","decl":"theorem Eq.cmp_eq_eq' (h : x = y) : cmp y x = Ordering.eq :=\n  h.symm.cmp_eq_eq\n"}
