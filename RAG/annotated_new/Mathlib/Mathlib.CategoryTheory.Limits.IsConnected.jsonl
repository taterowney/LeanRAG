{"name":"CategoryTheory.Limits.Types.pUnitCocone_pt","module":"Mathlib.CategoryTheory.Limits.IsConnected","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq (CategoryTheory.Limits.Types.pUnitCocone C).pt PUnit.{w + 1}","decl":"/-- The cocone on `constPUnitFunctor` with cone point `PUnit`. -/\n@[simps]\ndef pUnitCocone : Cocone (constPUnitFunctor.{w} C) where\n  pt := PUnit\n  ι := { app := fun _ => id }\n\n"}
{"name":"CategoryTheory.Limits.Types.pUnitCocone_ι_app","module":"Mathlib.CategoryTheory.Limits.IsConnected","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nx✝ : C\na : (CategoryTheory.Limits.Types.constPUnitFunctor C).obj x✝\n⊢ Eq ((CategoryTheory.Limits.Types.pUnitCocone C).ι.app x✝ a) (id a)","decl":"/-- The cocone on `constPUnitFunctor` with cone point `PUnit`. -/\n@[simps]\ndef pUnitCocone : Cocone (constPUnitFunctor.{w} C) where\n  pt := PUnit\n  ι := { app := fun _ => id }\n\n"}
{"name":"CategoryTheory.Limits.Types.instHasColimitConstPUnitFunctor","module":"Mathlib.CategoryTheory.Limits.IsConnected","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.IsConnected C\n⊢ CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.Types.constPUnitFunctor C)","decl":"instance instHasColimitConstPUnitFunctor [IsConnected C] : HasColimit (constPUnitFunctor.{w} C) :=\n  ⟨_, isColimitPUnitCocone _⟩\n\n"}
{"name":"CategoryTheory.Limits.Types.instSubsingletonColimitPUnit","module":"Mathlib.CategoryTheory.Limits.IsConnected","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.IsPreconnected C\ninst✝ : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.Types.constPUnitFunctor C)\n⊢ Subsingleton (CategoryTheory.Limits.colimit (CategoryTheory.Limits.Types.constPUnitFunctor C))","decl":"instance instSubsingletonColimitPUnit\n    [IsPreconnected C] [HasColimit (constPUnitFunctor.{w} C)] :\n    Subsingleton (colimit (constPUnitFunctor.{w} C)) where\n  allEq a b := by\n    obtain ⟨c, ⟨⟩, rfl⟩ := jointly_surjective' a\n    obtain ⟨d, ⟨⟩, rfl⟩ := jointly_surjective' b\n    apply constant_of_preserves_morphisms (colimit.ι (constPUnitFunctor C) · PUnit.unit)\n    exact fun c d f => colimit_sound f rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.zigzag_of_eqvGen_quot_rel","module":"Mathlib.CategoryTheory.Limits.IsConnected","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nc d : Sigma fun j => F.obj j\nh : Relation.EqvGen (CategoryTheory.Limits.Types.Quot.Rel F) c d\n⊢ CategoryTheory.Zigzag c.fst d.fst","decl":"/-- Let `F` be a `Type`-valued functor. If two elements `a : F c` and `b : F d` represent the same\nelement of `colimit F`, then `c` and `d` are related by a `Zigzag`. -/\ntheorem zigzag_of_eqvGen_quot_rel (F : C ⥤ Type w) (c d : Σ j, F.obj j)\n    (h : Relation.EqvGen (Quot.Rel F) c d) : Zigzag c.1 d.1 := by\n  induction h with\n  | rel _ _ h => exact Zigzag.of_hom <| Exists.choose h\n  | refl _ => exact Zigzag.refl _\n  | symm _ _ _ ih => exact zigzag_symmetric ih\n  | trans _ _ _ _ _ ih₁ ih₂ => exact ih₁.trans ih₂\n\n"}
{"name":"CategoryTheory.Limits.Types.isConnected_iff_colimit_constPUnitFunctor_iso_pUnit","module":"Mathlib.CategoryTheory.Limits.IsConnected","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.Types.constPUnitFunctor C)\n⊢ Iff (CategoryTheory.IsConnected C) (Nonempty (CategoryTheory.Iso (CategoryTheory.Limits.colimit (CategoryTheory.Limits.Types.constPUnitFunctor C)) PUnit.{w + 1}))","decl":"/-- An index category is connected iff the colimit of the constant singleton-valued functor is a\nsingleton. -/\ntheorem isConnected_iff_colimit_constPUnitFunctor_iso_pUnit\n    [HasColimit (constPUnitFunctor.{w} C)] :\n    IsConnected C ↔ Nonempty (colimit (constPUnitFunctor.{w} C) ≅ PUnit) := by\n  refine ⟨fun _ => ⟨colimitConstPUnitIsoPUnit.{w} C⟩, fun ⟨h⟩ => ?_⟩\n  have : Nonempty C := nonempty_of_nonempty_colimit <| Nonempty.map h.inv inferInstance\n  refine zigzag_isConnected <| fun c d => ?_\n  refine zigzag_of_eqvGen_quot_rel _ (constPUnitFunctor C) ⟨c, PUnit.unit⟩ ⟨d, PUnit.unit⟩ ?_\n  exact colimit_eq <| h.toEquiv.injective rfl\n\n"}
{"name":"CategoryTheory.Limits.Types.isConnected_iff_isColimit_pUnitCocone","module":"Mathlib.CategoryTheory.Limits.IsConnected","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Iff (CategoryTheory.IsConnected C) (Nonempty (CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.Types.pUnitCocone C)))","decl":"theorem isConnected_iff_isColimit_pUnitCocone :\n    IsConnected C ↔ Nonempty (IsColimit (pUnitCocone.{w} C)) := by\n  refine ⟨fun inst => ⟨isColimitPUnitCocone C⟩, fun ⟨h⟩ => ?_⟩\n  let colimitCocone : ColimitCocone (constPUnitFunctor C) := ⟨pUnitCocone.{w} C, h⟩\n  have : HasColimit (constPUnitFunctor.{w} C) := ⟨⟨colimitCocone⟩⟩\n  simp only [isConnected_iff_colimit_constPUnitFunctor_iso_pUnit.{w} C]\n  exact ⟨colimit.isoColimitCocone colimitCocone⟩\n\n"}
{"name":"CategoryTheory.Functor.isConnected_iff_of_final","module":"Mathlib.CategoryTheory.Limits.IsConnected","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.Final\n⊢ Iff (CategoryTheory.IsConnected C) (CategoryTheory.IsConnected D)","decl":"/-- The domain of a final functor is connected if and only if its codomain is connected. -/\ntheorem isConnected_iff_of_final (F : C ⥤ D) [F.Final] : IsConnected C ↔ IsConnected D := by\n  rw [isConnected_iff_colimit_constPUnitFunctor_iso_pUnit.{max v u v₂ u₂} C,\n    isConnected_iff_colimit_constPUnitFunctor_iso_pUnit.{max v u v₂ u₂} D]\n  exact Equiv.nonempty_congr <| Iso.isoCongrLeft <|\n    CategoryTheory.Functor.Final.colimitIso F <| constPUnitFunctor.{max u v u₂ v₂} D\n\n"}
{"name":"CategoryTheory.Functor.isConnected_iff_of_initial","module":"Mathlib.CategoryTheory.Limits.IsConnected","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.Initial\n⊢ Iff (CategoryTheory.IsConnected C) (CategoryTheory.IsConnected D)","decl":"/-- The domain of an initial functor is connected if and only if its codomain is connected. -/\ntheorem isConnected_iff_of_initial (F : C ⥤ D) [F.Initial] : IsConnected C ↔ IsConnected D := by\n  rw [← isConnected_op_iff_isConnected C, ← isConnected_op_iff_isConnected D]\n  exact isConnected_iff_of_final F.op\n\n"}
