{"name":"iteratedDerivWithin_univ","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\nâŠ¢ Eq (iteratedDerivWithin n f Set.univ) (iteratedDeriv n f)","decl":"theorem iteratedDerivWithin_univ : iteratedDerivWithin n f univ = iteratedDeriv n f := by\n  ext x\n  rw [iteratedDerivWithin, iteratedDeriv, iteratedFDerivWithin_univ]\n\n"}
{"name":"iteratedDerivWithin_eq_iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\ns : Set ğ•œ\nx : ğ•œ\nâŠ¢ Eq (iteratedDerivWithin n f s x) ((iteratedFDerivWithin ğ•œ n f s x) fun x => 1)","decl":"theorem iteratedDerivWithin_eq_iteratedFDerivWithin : iteratedDerivWithin n f s x =\n    (iteratedFDerivWithin ğ•œ n f s x : (Fin n â†’ ğ•œ) â†’ F) fun _ : Fin n => 1 :=\n  rfl\n\n"}
{"name":"iteratedDerivWithin_eq_equiv_comp","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\ns : Set ğ•œ\nâŠ¢ Eq (iteratedDerivWithin n f s) (Function.comp (â‡‘(ContinuousMultilinearMap.piFieldEquiv ğ•œ (Fin n) F).symm) (iteratedFDerivWithin ğ•œ n f s))","decl":"/-- Write the iterated derivative as the composition of a continuous linear equiv and the iterated\nFrÃ©chet derivative -/\ntheorem iteratedDerivWithin_eq_equiv_comp : iteratedDerivWithin n f s =\n    (ContinuousMultilinearMap.piFieldEquiv ğ•œ (Fin n) F).symm âˆ˜ iteratedFDerivWithin ğ•œ n f s := by\n  ext x; rfl\n\n"}
{"name":"iteratedFDerivWithin_eq_equiv_comp","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\ns : Set ğ•œ\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n f s) (Function.comp (â‡‘(ContinuousMultilinearMap.piFieldEquiv ğ•œ (Fin n) F)) (iteratedDerivWithin n f s))","decl":"/-- Write the iterated FrÃ©chet derivative as the composition of a continuous linear equiv and the\niterated derivative. -/\ntheorem iteratedFDerivWithin_eq_equiv_comp :\n    iteratedFDerivWithin ğ•œ n f s =\n      ContinuousMultilinearMap.piFieldEquiv ğ•œ (Fin n) F âˆ˜ iteratedDerivWithin n f s := by\n  rw [iteratedDerivWithin_eq_equiv_comp, â† Function.comp_assoc, LinearIsometryEquiv.self_comp_symm,\n    Function.id_comp]\n\n"}
{"name":"iteratedFDerivWithin_apply_eq_iteratedDerivWithin_mul_prod","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\ns : Set ğ•œ\nx : ğ•œ\nm : Fin n â†’ ğ•œ\nâŠ¢ Eq ((iteratedFDerivWithin ğ•œ n f s x) m) (HSMul.hSMul (Finset.univ.prod fun i => m i) (iteratedDerivWithin n f s x))","decl":"/-- The `n`-th FrÃ©chet derivative applied to a vector `(m 0, ..., m (n-1))` is the derivative\nmultiplied by the product of the `m i`s. -/\ntheorem iteratedFDerivWithin_apply_eq_iteratedDerivWithin_mul_prod {m : Fin n â†’ ğ•œ} :\n    (iteratedFDerivWithin ğ•œ n f s x : (Fin n â†’ ğ•œ) â†’ F) m =\n      (âˆ i, m i) â€¢ iteratedDerivWithin n f s x := by\n  rw [iteratedDerivWithin_eq_iteratedFDerivWithin, â† ContinuousMultilinearMap.map_smul_univ]\n  simp\n\n"}
{"name":"norm_iteratedFDerivWithin_eq_norm_iteratedDerivWithin","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\ns : Set ğ•œ\nx : ğ•œ\nâŠ¢ Eq (Norm.norm (iteratedFDerivWithin ğ•œ n f s x)) (Norm.norm (iteratedDerivWithin n f s x))","decl":"theorem norm_iteratedFDerivWithin_eq_norm_iteratedDerivWithin :\n    â€–iteratedFDerivWithin ğ•œ n f s xâ€– = â€–iteratedDerivWithin n f s xâ€– := by\n  rw [iteratedDerivWithin_eq_equiv_comp, Function.comp_apply, LinearIsometryEquiv.norm_map]\n\n"}
{"name":"iteratedDerivWithin_zero","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\nâŠ¢ Eq (iteratedDerivWithin 0 f s) f","decl":"@[simp]\ntheorem iteratedDerivWithin_zero : iteratedDerivWithin 0 f s = f := by\n  ext x\n  simp [iteratedDerivWithin]\n\n"}
{"name":"iteratedDerivWithin_one","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\nx : ğ•œ\nâŠ¢ Eq (iteratedDerivWithin 1 f s x) (derivWithin f s x)","decl":"@[simp]\ntheorem iteratedDerivWithin_one {x : ğ•œ} :\n    iteratedDerivWithin 1 f s x = derivWithin f s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· simp only [iteratedDerivWithin, iteratedFDerivWithin_one_apply hxs]; rfl\n  Â· simp [derivWithin_zero_of_isolated hxs, iteratedDerivWithin, iteratedFDerivWithin,\n      fderivWithin_zero_of_isolated hxs]\n\n"}
{"name":"contDiffOn_of_continuousOn_differentiableOn_deriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\nn : ENat\nHcont : âˆ€ (m : Nat), LE.le (â†‘m) n â†’ ContinuousOn (fun x => iteratedDerivWithin m f s x) s\nHdiff : âˆ€ (m : Nat), LT.lt (â†‘m) n â†’ DifferentiableOn ğ•œ (fun x => iteratedDerivWithin m f s x) s\nâŠ¢ ContDiffOn ğ•œ (â†‘n) f s","decl":"/-- If the first `n` derivatives within a set of a function are continuous, and its first `n-1`\nderivatives are differentiable, then the function is `C^n`. This is not an equivalence in general,\nbut this is an equivalence when the set has unique derivatives, see\n`contDiffOn_iff_continuousOn_differentiableOn_deriv`. -/\ntheorem contDiffOn_of_continuousOn_differentiableOn_deriv {n : â„•âˆ}\n    (Hcont : âˆ€ m : â„•, (m : â„•âˆ) â‰¤ n â†’ ContinuousOn (fun x => iteratedDerivWithin m f s x) s)\n    (Hdiff : âˆ€ m : â„•, (m : â„•âˆ) < n â†’ DifferentiableOn ğ•œ (fun x => iteratedDerivWithin m f s x) s) :\n    ContDiffOn ğ•œ n f s := by\n  apply contDiffOn_of_continuousOn_differentiableOn\n  Â· simpa only [iteratedFDerivWithin_eq_equiv_comp, LinearIsometryEquiv.comp_continuousOn_iff]\n  Â· simpa only [iteratedFDerivWithin_eq_equiv_comp, LinearIsometryEquiv.comp_differentiableOn_iff]\n\n"}
{"name":"contDiffOn_of_differentiableOn_deriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\nn : ENat\nh : âˆ€ (m : Nat), LE.le (â†‘m) n â†’ DifferentiableOn ğ•œ (iteratedDerivWithin m f s) s\nâŠ¢ ContDiffOn ğ•œ (â†‘n) f s","decl":"/-- To check that a function is `n` times continuously differentiable, it suffices to check that its\nfirst `n` derivatives are differentiable. This is slightly too strong as the condition we\nrequire on the `n`-th derivative is differentiability instead of continuity, but it has the\nadvantage of avoiding the discussion of continuity in the proof (and for `n = âˆ` this is optimal).\n-/\ntheorem contDiffOn_of_differentiableOn_deriv {n : â„•âˆ}\n    (h : âˆ€ m : â„•, (m : â„•âˆ) â‰¤ n â†’ DifferentiableOn ğ•œ (iteratedDerivWithin m f s) s) :\n    ContDiffOn ğ•œ n f s := by\n  apply contDiffOn_of_differentiableOn\n  simpa only [iteratedFDerivWithin_eq_equiv_comp, LinearIsometryEquiv.comp_differentiableOn_iff]\n\n"}
{"name":"ContDiffOn.continuousOn_iteratedDerivWithin","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\nn : WithTop ENat\nm : Nat\nh : ContDiffOn ğ•œ n f s\nhmn : LE.le (â†‘m) n\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ ContinuousOn (iteratedDerivWithin m f s) s","decl":"/-- On a set with unique derivatives, a `C^n` function has derivatives up to `n` which are\ncontinuous. -/\ntheorem ContDiffOn.continuousOn_iteratedDerivWithin\n    {n : WithTop â„•âˆ} {m : â„•} (h : ContDiffOn ğ•œ n f s)\n    (hmn : m â‰¤ n) (hs : UniqueDiffOn ğ•œ s) : ContinuousOn (iteratedDerivWithin m f s) s := by\n  simpa only [iteratedDerivWithin_eq_equiv_comp, LinearIsometryEquiv.comp_continuousOn_iff] using\n    h.continuousOn_iteratedFDerivWithin hmn hs\n\n"}
{"name":"ContDiffWithinAt.differentiableWithinAt_iteratedDerivWithin","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\nx : ğ•œ\nn : WithTop ENat\nm : Nat\nh : ContDiffWithinAt ğ•œ n f s x\nhmn : LT.lt (â†‘m) n\nhs : UniqueDiffOn ğ•œ (Insert.insert x s)\nâŠ¢ DifferentiableWithinAt ğ•œ (iteratedDerivWithin m f s) s x","decl":"theorem ContDiffWithinAt.differentiableWithinAt_iteratedDerivWithin {n : WithTop â„•âˆ} {m : â„•}\n    (h : ContDiffWithinAt ğ•œ n f s x) (hmn : m < n) (hs : UniqueDiffOn ğ•œ (insert x s)) :\n    DifferentiableWithinAt ğ•œ (iteratedDerivWithin m f s) s x := by\n  simpa only [iteratedDerivWithin_eq_equiv_comp,\n    LinearIsometryEquiv.comp_differentiableWithinAt_iff] using\n    h.differentiableWithinAt_iteratedFDerivWithin hmn hs\n\n"}
{"name":"ContDiffOn.differentiableOn_iteratedDerivWithin","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\nn : WithTop ENat\nm : Nat\nh : ContDiffOn ğ•œ n f s\nhmn : LT.lt (â†‘m) n\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ DifferentiableOn ğ•œ (iteratedDerivWithin m f s) s","decl":"/-- On a set with unique derivatives, a `C^n` function has derivatives less than `n` which are\ndifferentiable. -/\ntheorem ContDiffOn.differentiableOn_iteratedDerivWithin {n : WithTop â„•âˆ} {m : â„•}\n    (h : ContDiffOn ğ•œ n f s) (hmn : m < n) (hs : UniqueDiffOn ğ•œ s) :\n    DifferentiableOn ğ•œ (iteratedDerivWithin m f s) s := fun x hx =>\n  (h x hx).differentiableWithinAt_iteratedDerivWithin hmn <| by rwa [insert_eq_of_mem hx]\n\n"}
{"name":"contDiffOn_iff_continuousOn_differentiableOn_deriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\nn : ENat\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘n) f s) (And (âˆ€ (m : Nat), LE.le (â†‘m) n â†’ ContinuousOn (iteratedDerivWithin m f s) s) (âˆ€ (m : Nat), LT.lt (â†‘m) n â†’ DifferentiableOn ğ•œ (iteratedDerivWithin m f s) s))","decl":"/-- The property of being `C^n`, initially defined in terms of the FrÃ©chet derivative, can be\nreformulated in terms of the one-dimensional derivative on sets with unique derivatives. -/\ntheorem contDiffOn_iff_continuousOn_differentiableOn_deriv {n : â„•âˆ} (hs : UniqueDiffOn ğ•œ s) :\n    ContDiffOn ğ•œ n f s â†” (âˆ€ m : â„•, (m : â„•âˆ) â‰¤ n â†’ ContinuousOn (iteratedDerivWithin m f s) s) âˆ§\n      âˆ€ m : â„•, (m : â„•âˆ) < n â†’ DifferentiableOn ğ•œ (iteratedDerivWithin m f s) s := by\n  simp only [contDiffOn_iff_continuousOn_differentiableOn hs, iteratedFDerivWithin_eq_equiv_comp,\n    LinearIsometryEquiv.comp_continuousOn_iff, LinearIsometryEquiv.comp_differentiableOn_iff]\n\n"}
{"name":"contDiffOn_nat_iff_continuousOn_differentiableOn_deriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\ns : Set ğ•œ\nn : Nat\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘n) f s) (And (âˆ€ (m : Nat), LE.le m n â†’ ContinuousOn (iteratedDerivWithin m f s) s) (âˆ€ (m : Nat), LT.lt m n â†’ DifferentiableOn ğ•œ (iteratedDerivWithin m f s) s))","decl":"/-- The property of being `C^n`, initially defined in terms of the FrÃ©chet derivative, can be\nreformulated in terms of the one-dimensional derivative on sets with unique derivatives. -/\ntheorem contDiffOn_nat_iff_continuousOn_differentiableOn_deriv {n : â„•} (hs : UniqueDiffOn ğ•œ s) :\n    ContDiffOn ğ•œ n f s â†” (âˆ€ m : â„•, m â‰¤ n â†’ ContinuousOn (iteratedDerivWithin m f s) s) âˆ§\n      âˆ€ m : â„•, m < n â†’ DifferentiableOn ğ•œ (iteratedDerivWithin m f s) s := by\n  rw [show n = ((n : â„•âˆ) : WithTop â„•âˆ) from rfl,\n    contDiffOn_iff_continuousOn_differentiableOn_deriv hs]\n  simp\n\n"}
{"name":"iteratedDerivWithin_succ","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\ns : Set ğ•œ\nx : ğ•œ\nâŠ¢ Eq (iteratedDerivWithin (HAdd.hAdd n 1) f s x) (derivWithin (iteratedDerivWithin n f s) s x)","decl":"/-- The `n+1`-th iterated derivative within a set with unique derivatives can be obtained by\ndifferentiating the `n`-th iterated derivative. -/\ntheorem iteratedDerivWithin_succ {x : ğ•œ} :\n    iteratedDerivWithin (n + 1) f s x = derivWithin (iteratedDerivWithin n f s) s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· rw [iteratedDerivWithin_eq_iteratedFDerivWithin, iteratedFDerivWithin_succ_apply_left,\n      iteratedFDerivWithin_eq_equiv_comp, LinearIsometryEquiv.comp_fderivWithin _ hxs, derivWithin]\n    change ((ContinuousMultilinearMap.mkPiRing ğ•œ (Fin n) ((fderivWithin ğ•œ\n      (iteratedDerivWithin n f s) s x : ğ•œ â†’ F) 1) : (Fin n â†’ ğ•œ) â†’ F) fun _ : Fin n => 1) =\n      (fderivWithin ğ•œ (iteratedDerivWithin n f s) s x : ğ•œ â†’ F) 1\n    simp\n  Â· simp [derivWithin_zero_of_isolated hxs, iteratedDerivWithin, iteratedFDerivWithin,\n      fderivWithin_zero_of_isolated hxs]\n\n"}
{"name":"iteratedDerivWithin_eq_iterate","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\ns : Set ğ•œ\nx : ğ•œ\nâŠ¢ Eq (iteratedDerivWithin n f s x) (Nat.iterate (fun g => derivWithin g s) n f x)","decl":"/-- The `n`-th iterated derivative within a set with unique derivatives can be obtained by\niterating `n` times the differentiation operation. -/\ntheorem iteratedDerivWithin_eq_iterate {x : ğ•œ} :\n    iteratedDerivWithin n f s x = (fun g : ğ•œ â†’ F => derivWithin g s)^[n] f x := by\n  induction n generalizing x with\n  | zero => simp\n  | succ n IH =>\n    rw [iteratedDerivWithin_succ, Function.iterate_succ']\n    exact derivWithin_congr (fun y hy => IH) IH\n\n"}
{"name":"iteratedDerivWithin_succ'","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\ns : Set ğ•œ\nx : ğ•œ\nâŠ¢ Eq (iteratedDerivWithin (HAdd.hAdd n 1) f s x) (iteratedDerivWithin n (derivWithin f s) s x)","decl":"/-- The `n+1`-th iterated derivative within a set with unique derivatives can be obtained by\ntaking the `n`-th derivative of the derivative. -/\ntheorem iteratedDerivWithin_succ' {x : ğ•œ} :\n    iteratedDerivWithin (n + 1) f s x = (iteratedDerivWithin n (derivWithin f s) s) x := by\n  rw [iteratedDerivWithin_eq_iterate, iteratedDerivWithin_eq_iterate]; rfl\n\n"}
{"name":"iteratedDeriv_eq_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\nx : ğ•œ\nâŠ¢ Eq (iteratedDeriv n f x) ((iteratedFDeriv ğ•œ n f x) fun x => 1)","decl":"theorem iteratedDeriv_eq_iteratedFDeriv :\n    iteratedDeriv n f x = (iteratedFDeriv ğ•œ n f x : (Fin n â†’ ğ•œ) â†’ F) fun _ : Fin n => 1 :=\n  rfl\n\n"}
{"name":"iteratedDeriv_eq_equiv_comp","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\nâŠ¢ Eq (iteratedDeriv n f) (Function.comp (â‡‘(ContinuousMultilinearMap.piFieldEquiv ğ•œ (Fin n) F).symm) (iteratedFDeriv ğ•œ n f))","decl":"/-- Write the iterated derivative as the composition of a continuous linear equiv and the iterated\nFrÃ©chet derivative -/\ntheorem iteratedDeriv_eq_equiv_comp : iteratedDeriv n f =\n    (ContinuousMultilinearMap.piFieldEquiv ğ•œ (Fin n) F).symm âˆ˜ iteratedFDeriv ğ•œ n f := by\n  ext x; rfl\n\n"}
{"name":"iteratedFDeriv_eq_equiv_comp","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\nâŠ¢ Eq (iteratedFDeriv ğ•œ n f) (Function.comp (â‡‘(ContinuousMultilinearMap.piFieldEquiv ğ•œ (Fin n) F)) (iteratedDeriv n f))","decl":"/-- Write the iterated FrÃ©chet derivative as the composition of a continuous linear equiv and the\niterated derivative. -/\ntheorem iteratedFDeriv_eq_equiv_comp : iteratedFDeriv ğ•œ n f =\n    ContinuousMultilinearMap.piFieldEquiv ğ•œ (Fin n) F âˆ˜ iteratedDeriv n f := by\n  rw [iteratedDeriv_eq_equiv_comp, â† Function.comp_assoc, LinearIsometryEquiv.self_comp_symm,\n    Function.id_comp]\n\n"}
{"name":"iteratedFDeriv_apply_eq_iteratedDeriv_mul_prod","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\nx : ğ•œ\nm : Fin n â†’ ğ•œ\nâŠ¢ Eq ((iteratedFDeriv ğ•œ n f x) m) (HSMul.hSMul (Finset.univ.prod fun i => m i) (iteratedDeriv n f x))","decl":"/-- The `n`-th FrÃ©chet derivative applied to a vector `(m 0, ..., m (n-1))` is the derivative\nmultiplied by the product of the `m i`s. -/\ntheorem iteratedFDeriv_apply_eq_iteratedDeriv_mul_prod {m : Fin n â†’ ğ•œ} :\n    (iteratedFDeriv ğ•œ n f x : (Fin n â†’ ğ•œ) â†’ F) m = (âˆ i, m i) â€¢ iteratedDeriv n f x := by\n  rw [iteratedDeriv_eq_iteratedFDeriv, â† ContinuousMultilinearMap.map_smul_univ]; simp\n\n"}
{"name":"norm_iteratedFDeriv_eq_norm_iteratedDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\nx : ğ•œ\nâŠ¢ Eq (Norm.norm (iteratedFDeriv ğ•œ n f x)) (Norm.norm (iteratedDeriv n f x))","decl":"theorem norm_iteratedFDeriv_eq_norm_iteratedDeriv :\n    â€–iteratedFDeriv ğ•œ n f xâ€– = â€–iteratedDeriv n f xâ€– := by\n  rw [iteratedDeriv_eq_equiv_comp, Function.comp_apply, LinearIsometryEquiv.norm_map]\n\n"}
{"name":"iteratedDeriv_zero","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nâŠ¢ Eq (iteratedDeriv 0 f) f","decl":"@[simp]\ntheorem iteratedDeriv_zero : iteratedDeriv 0 f = f := by ext x; simp [iteratedDeriv]\n\n"}
{"name":"iteratedDeriv_one","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nâŠ¢ Eq (iteratedDeriv 1 f) (deriv f)","decl":"@[simp]\ntheorem iteratedDeriv_one : iteratedDeriv 1 f = deriv f := by ext x; simp [iteratedDeriv]\n\n"}
{"name":"contDiff_iff_iteratedDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nn : ENat\nâŠ¢ Iff (ContDiff ğ•œ (â†‘n) f) (And (âˆ€ (m : Nat), LE.le (â†‘m) n â†’ Continuous (iteratedDeriv m f)) (âˆ€ (m : Nat), LT.lt (â†‘m) n â†’ Differentiable ğ•œ (iteratedDeriv m f)))","decl":"/-- The property of being `C^n`, initially defined in terms of the FrÃ©chet derivative, can be\nreformulated in terms of the one-dimensional derivative. -/\ntheorem contDiff_iff_iteratedDeriv {n : â„•âˆ} : ContDiff ğ•œ n f â†”\n    (âˆ€ m : â„•, (m : â„•âˆ) â‰¤ n â†’ Continuous (iteratedDeriv m f)) âˆ§\n      âˆ€ m : â„•, (m : â„•âˆ) < n â†’ Differentiable ğ•œ (iteratedDeriv m f) := by\n  simp only [contDiff_iff_continuous_differentiable, iteratedFDeriv_eq_equiv_comp,\n    LinearIsometryEquiv.comp_continuous_iff, LinearIsometryEquiv.comp_differentiable_iff]\n\n"}
{"name":"contDiff_nat_iff_iteratedDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nn : Nat\nâŠ¢ Iff (ContDiff ğ•œ (â†‘n) f) (And (âˆ€ (m : Nat), LE.le m n â†’ Continuous (iteratedDeriv m f)) (âˆ€ (m : Nat), LT.lt m n â†’ Differentiable ğ•œ (iteratedDeriv m f)))","decl":"/-- The property of being `C^n`, initially defined in terms of the FrÃ©chet derivative, can be\nreformulated in terms of the one-dimensional derivative. -/\ntheorem contDiff_nat_iff_iteratedDeriv {n : â„•} : ContDiff ğ•œ n f â†”\n    (âˆ€ m : â„•, m â‰¤ n â†’ Continuous (iteratedDeriv m f)) âˆ§\n      âˆ€ m : â„•, m < n â†’ Differentiable ğ•œ (iteratedDeriv m f) := by\n  rw [show n = ((n : â„•âˆ) : WithTop â„•âˆ) from rfl, contDiff_iff_iteratedDeriv]\n  simp\n\n"}
{"name":"contDiff_of_differentiable_iteratedDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nn : ENat\nh : âˆ€ (m : Nat), LE.le (â†‘m) n â†’ Differentiable ğ•œ (iteratedDeriv m f)\nâŠ¢ ContDiff ğ•œ (â†‘n) f","decl":"/-- To check that a function is `n` times continuously differentiable, it suffices to check that its\nfirst `n` derivatives are differentiable. This is slightly too strong as the condition we\nrequire on the `n`-th derivative is differentiability instead of continuity, but it has the\nadvantage of avoiding the discussion of continuity in the proof (and for `n = âˆ` this is optimal).\n-/\ntheorem contDiff_of_differentiable_iteratedDeriv {n : â„•âˆ}\n    (h : âˆ€ m : â„•, (m : â„•âˆ) â‰¤ n â†’ Differentiable ğ•œ (iteratedDeriv m f)) : ContDiff ğ•œ n f :=\n  contDiff_iff_iteratedDeriv.2 âŸ¨fun m hm => (h m hm).continuous, fun m hm => h m (le_of_lt hm)âŸ©\n\n"}
{"name":"ContDiff.continuous_iteratedDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nn : WithTop ENat\nm : Nat\nh : ContDiff ğ•œ n f\nhmn : LE.le (â†‘m) n\nâŠ¢ Continuous (iteratedDeriv m f)","decl":"theorem ContDiff.continuous_iteratedDeriv {n : WithTop â„•âˆ} (m : â„•) (h : ContDiff ğ•œ n f)\n    (hmn : m â‰¤ n) : Continuous (iteratedDeriv m f) :=\n  (contDiff_iff_iteratedDeriv.1 (h.of_le hmn)).1 m le_rfl\n\n"}
{"name":"ContDiff.differentiable_iteratedDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : ğ•œ â†’ F\nn : WithTop ENat\nm : Nat\nh : ContDiff ğ•œ n f\nhmn : LT.lt (â†‘m) n\nâŠ¢ Differentiable ğ•œ (iteratedDeriv m f)","decl":"theorem ContDiff.differentiable_iteratedDeriv {n : WithTop â„•âˆ} (m : â„•) (h : ContDiff ğ•œ n f)\n    (hmn : m < n) : Differentiable ğ•œ (iteratedDeriv m f) :=\n  (contDiff_iff_iteratedDeriv.1 (h.of_le (ENat.add_one_natCast_le_withTop_of_lt hmn))).2 m\n    (mod_cast (lt_add_one m))\n\n"}
{"name":"iteratedDeriv_succ","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\nâŠ¢ Eq (iteratedDeriv (HAdd.hAdd n 1) f) (deriv (iteratedDeriv n f))","decl":"/-- The `n+1`-th iterated derivative can be obtained by differentiating the `n`-th\niterated derivative. -/\ntheorem iteratedDeriv_succ : iteratedDeriv (n + 1) f = deriv (iteratedDeriv n f) := by\n  ext x\n  rw [â† iteratedDerivWithin_univ, â† iteratedDerivWithin_univ, â† derivWithin_univ]\n  exact iteratedDerivWithin_succ\n\n"}
{"name":"iteratedDeriv_eq_iterate","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\nâŠ¢ Eq (iteratedDeriv n f) (Nat.iterate deriv n f)","decl":"/-- The `n`-th iterated derivative can be obtained by iterating `n` times the\ndifferentiation operation. -/\ntheorem iteratedDeriv_eq_iterate : iteratedDeriv n f = deriv^[n] f := by\n  ext x\n  rw [â† iteratedDerivWithin_univ]\n  convert iteratedDerivWithin_eq_iterate (F := F)\n  simp [derivWithin_univ]\n\n"}
{"name":"iteratedDeriv_succ'","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nf : ğ•œ â†’ F\nâŠ¢ Eq (iteratedDeriv (HAdd.hAdd n 1) f) (iteratedDeriv n (deriv f))","decl":"/-- The `n+1`-th iterated derivative can be obtained by taking the `n`-th derivative of the\nderivative. -/\ntheorem iteratedDeriv_succ' : iteratedDeriv (n + 1) f = iteratedDeriv n (deriv f) := by\n  rw [iteratedDeriv_eq_iterate, iteratedDeriv_eq_iterate]; rfl\n\n"}
{"name":"AnalyticAt.hasFPowerSeriesAt","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"ğ•œ : Type u_3\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : CompleteSpace ğ•œ\ninstâœ : CharZero ğ•œ\nf : ğ•œ â†’ ğ•œ\nx : ğ•œ\nh : AnalyticAt ğ•œ f x\nâŠ¢ HasFPowerSeriesAt f (FormalMultilinearSeries.ofScalars ğ•œ fun n => HDiv.hDiv (iteratedDeriv n f x) â†‘n.factorial) x","decl":"lemma AnalyticAt.hasFPowerSeriesAt {ğ•œ : Type*} [NontriviallyNormedField ğ•œ] [CompleteSpace ğ•œ]\n    [CharZero ğ•œ] {f : ğ•œ â†’ ğ•œ} {x : ğ•œ} (h : AnalyticAt ğ•œ f x) :\n    HasFPowerSeriesAt f\n      (FormalMultilinearSeries.ofScalars ğ•œ (fun n â†¦ iteratedDeriv n f x / n.factorial)) x := by\n  obtain âŸ¨p, hpâŸ© := h\n  convert hp\n  obtain âŸ¨r, hprâŸ© := hp\n  ext n u\n  have h_fact_smul := hpr.factorial_smul 1\n  simp only [FormalMultilinearSeries.apply_eq_prod_smul_coeff, Finset.prod_const, Finset.card_univ,\n    Fintype.card_fin, smul_eq_mul, nsmul_eq_mul, one_pow, one_mul] at h_fact_smul\n  simp only [FormalMultilinearSeries.apply_eq_prod_smul_coeff,\n    FormalMultilinearSeries.coeff_ofScalars, smul_eq_mul, mul_eq_mul_left_iff]\n  left\n  rw [div_eq_iff, mul_comm, h_fact_smul, â† iteratedDeriv_eq_iteratedFDeriv]\n  norm_cast\n  exact Nat.factorial_ne_zero _\n"}
