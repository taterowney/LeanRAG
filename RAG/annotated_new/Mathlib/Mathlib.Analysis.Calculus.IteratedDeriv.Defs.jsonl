{"name":"iteratedDerivWithin_univ","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\n⊢ Eq (iteratedDerivWithin n f Set.univ) (iteratedDeriv n f)","decl":"theorem iteratedDerivWithin_univ : iteratedDerivWithin n f univ = iteratedDeriv n f := by\n  ext x\n  rw [iteratedDerivWithin, iteratedDeriv, iteratedFDerivWithin_univ]\n\n"}
{"name":"iteratedDerivWithin_eq_iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\ns : Set 𝕜\nx : 𝕜\n⊢ Eq (iteratedDerivWithin n f s x) ((iteratedFDerivWithin 𝕜 n f s x) fun x => 1)","decl":"theorem iteratedDerivWithin_eq_iteratedFDerivWithin : iteratedDerivWithin n f s x =\n    (iteratedFDerivWithin 𝕜 n f s x : (Fin n → 𝕜) → F) fun _ : Fin n => 1 :=\n  rfl\n\n"}
{"name":"iteratedDerivWithin_eq_equiv_comp","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\ns : Set 𝕜\n⊢ Eq (iteratedDerivWithin n f s) (Function.comp (⇑(ContinuousMultilinearMap.piFieldEquiv 𝕜 (Fin n) F).symm) (iteratedFDerivWithin 𝕜 n f s))","decl":"/-- Write the iterated derivative as the composition of a continuous linear equiv and the iterated\nFréchet derivative -/\ntheorem iteratedDerivWithin_eq_equiv_comp : iteratedDerivWithin n f s =\n    (ContinuousMultilinearMap.piFieldEquiv 𝕜 (Fin n) F).symm ∘ iteratedFDerivWithin 𝕜 n f s := by\n  ext x; rfl\n\n"}
{"name":"iteratedFDerivWithin_eq_equiv_comp","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\ns : Set 𝕜\n⊢ Eq (iteratedFDerivWithin 𝕜 n f s) (Function.comp (⇑(ContinuousMultilinearMap.piFieldEquiv 𝕜 (Fin n) F)) (iteratedDerivWithin n f s))","decl":"/-- Write the iterated Fréchet derivative as the composition of a continuous linear equiv and the\niterated derivative. -/\ntheorem iteratedFDerivWithin_eq_equiv_comp :\n    iteratedFDerivWithin 𝕜 n f s =\n      ContinuousMultilinearMap.piFieldEquiv 𝕜 (Fin n) F ∘ iteratedDerivWithin n f s := by\n  rw [iteratedDerivWithin_eq_equiv_comp, ← Function.comp_assoc, LinearIsometryEquiv.self_comp_symm,\n    Function.id_comp]\n\n"}
{"name":"iteratedFDerivWithin_apply_eq_iteratedDerivWithin_mul_prod","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\ns : Set 𝕜\nx : 𝕜\nm : Fin n → 𝕜\n⊢ Eq ((iteratedFDerivWithin 𝕜 n f s x) m) (HSMul.hSMul (Finset.univ.prod fun i => m i) (iteratedDerivWithin n f s x))","decl":"/-- The `n`-th Fréchet derivative applied to a vector `(m 0, ..., m (n-1))` is the derivative\nmultiplied by the product of the `m i`s. -/\ntheorem iteratedFDerivWithin_apply_eq_iteratedDerivWithin_mul_prod {m : Fin n → 𝕜} :\n    (iteratedFDerivWithin 𝕜 n f s x : (Fin n → 𝕜) → F) m =\n      (∏ i, m i) • iteratedDerivWithin n f s x := by\n  rw [iteratedDerivWithin_eq_iteratedFDerivWithin, ← ContinuousMultilinearMap.map_smul_univ]\n  simp\n\n"}
{"name":"norm_iteratedFDerivWithin_eq_norm_iteratedDerivWithin","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\ns : Set 𝕜\nx : 𝕜\n⊢ Eq (Norm.norm (iteratedFDerivWithin 𝕜 n f s x)) (Norm.norm (iteratedDerivWithin n f s x))","decl":"theorem norm_iteratedFDerivWithin_eq_norm_iteratedDerivWithin :\n    ‖iteratedFDerivWithin 𝕜 n f s x‖ = ‖iteratedDerivWithin n f s x‖ := by\n  rw [iteratedDerivWithin_eq_equiv_comp, Function.comp_apply, LinearIsometryEquiv.norm_map]\n\n"}
{"name":"iteratedDerivWithin_zero","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\n⊢ Eq (iteratedDerivWithin 0 f s) f","decl":"@[simp]\ntheorem iteratedDerivWithin_zero : iteratedDerivWithin 0 f s = f := by\n  ext x\n  simp [iteratedDerivWithin]\n\n"}
{"name":"iteratedDerivWithin_one","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\nx : 𝕜\n⊢ Eq (iteratedDerivWithin 1 f s x) (derivWithin f s x)","decl":"@[simp]\ntheorem iteratedDerivWithin_one {x : 𝕜} :\n    iteratedDerivWithin 1 f s x = derivWithin f s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · simp only [iteratedDerivWithin, iteratedFDerivWithin_one_apply hxs]; rfl\n  · simp [derivWithin_zero_of_isolated hxs, iteratedDerivWithin, iteratedFDerivWithin,\n      fderivWithin_zero_of_isolated hxs]\n\n"}
{"name":"contDiffOn_of_continuousOn_differentiableOn_deriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\nn : ENat\nHcont : ∀ (m : Nat), LE.le (↑m) n → ContinuousOn (fun x => iteratedDerivWithin m f s x) s\nHdiff : ∀ (m : Nat), LT.lt (↑m) n → DifferentiableOn 𝕜 (fun x => iteratedDerivWithin m f s x) s\n⊢ ContDiffOn 𝕜 (↑n) f s","decl":"/-- If the first `n` derivatives within a set of a function are continuous, and its first `n-1`\nderivatives are differentiable, then the function is `C^n`. This is not an equivalence in general,\nbut this is an equivalence when the set has unique derivatives, see\n`contDiffOn_iff_continuousOn_differentiableOn_deriv`. -/\ntheorem contDiffOn_of_continuousOn_differentiableOn_deriv {n : ℕ∞}\n    (Hcont : ∀ m : ℕ, (m : ℕ∞) ≤ n → ContinuousOn (fun x => iteratedDerivWithin m f s x) s)\n    (Hdiff : ∀ m : ℕ, (m : ℕ∞) < n → DifferentiableOn 𝕜 (fun x => iteratedDerivWithin m f s x) s) :\n    ContDiffOn 𝕜 n f s := by\n  apply contDiffOn_of_continuousOn_differentiableOn\n  · simpa only [iteratedFDerivWithin_eq_equiv_comp, LinearIsometryEquiv.comp_continuousOn_iff]\n  · simpa only [iteratedFDerivWithin_eq_equiv_comp, LinearIsometryEquiv.comp_differentiableOn_iff]\n\n"}
{"name":"contDiffOn_of_differentiableOn_deriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\nn : ENat\nh : ∀ (m : Nat), LE.le (↑m) n → DifferentiableOn 𝕜 (iteratedDerivWithin m f s) s\n⊢ ContDiffOn 𝕜 (↑n) f s","decl":"/-- To check that a function is `n` times continuously differentiable, it suffices to check that its\nfirst `n` derivatives are differentiable. This is slightly too strong as the condition we\nrequire on the `n`-th derivative is differentiability instead of continuity, but it has the\nadvantage of avoiding the discussion of continuity in the proof (and for `n = ∞` this is optimal).\n-/\ntheorem contDiffOn_of_differentiableOn_deriv {n : ℕ∞}\n    (h : ∀ m : ℕ, (m : ℕ∞) ≤ n → DifferentiableOn 𝕜 (iteratedDerivWithin m f s) s) :\n    ContDiffOn 𝕜 n f s := by\n  apply contDiffOn_of_differentiableOn\n  simpa only [iteratedFDerivWithin_eq_equiv_comp, LinearIsometryEquiv.comp_differentiableOn_iff]\n\n"}
{"name":"ContDiffOn.continuousOn_iteratedDerivWithin","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\nn : WithTop ENat\nm : Nat\nh : ContDiffOn 𝕜 n f s\nhmn : LE.le (↑m) n\nhs : UniqueDiffOn 𝕜 s\n⊢ ContinuousOn (iteratedDerivWithin m f s) s","decl":"/-- On a set with unique derivatives, a `C^n` function has derivatives up to `n` which are\ncontinuous. -/\ntheorem ContDiffOn.continuousOn_iteratedDerivWithin\n    {n : WithTop ℕ∞} {m : ℕ} (h : ContDiffOn 𝕜 n f s)\n    (hmn : m ≤ n) (hs : UniqueDiffOn 𝕜 s) : ContinuousOn (iteratedDerivWithin m f s) s := by\n  simpa only [iteratedDerivWithin_eq_equiv_comp, LinearIsometryEquiv.comp_continuousOn_iff] using\n    h.continuousOn_iteratedFDerivWithin hmn hs\n\n"}
{"name":"ContDiffWithinAt.differentiableWithinAt_iteratedDerivWithin","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\nx : 𝕜\nn : WithTop ENat\nm : Nat\nh : ContDiffWithinAt 𝕜 n f s x\nhmn : LT.lt (↑m) n\nhs : UniqueDiffOn 𝕜 (Insert.insert x s)\n⊢ DifferentiableWithinAt 𝕜 (iteratedDerivWithin m f s) s x","decl":"theorem ContDiffWithinAt.differentiableWithinAt_iteratedDerivWithin {n : WithTop ℕ∞} {m : ℕ}\n    (h : ContDiffWithinAt 𝕜 n f s x) (hmn : m < n) (hs : UniqueDiffOn 𝕜 (insert x s)) :\n    DifferentiableWithinAt 𝕜 (iteratedDerivWithin m f s) s x := by\n  simpa only [iteratedDerivWithin_eq_equiv_comp,\n    LinearIsometryEquiv.comp_differentiableWithinAt_iff] using\n    h.differentiableWithinAt_iteratedFDerivWithin hmn hs\n\n"}
{"name":"ContDiffOn.differentiableOn_iteratedDerivWithin","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\nn : WithTop ENat\nm : Nat\nh : ContDiffOn 𝕜 n f s\nhmn : LT.lt (↑m) n\nhs : UniqueDiffOn 𝕜 s\n⊢ DifferentiableOn 𝕜 (iteratedDerivWithin m f s) s","decl":"/-- On a set with unique derivatives, a `C^n` function has derivatives less than `n` which are\ndifferentiable. -/\ntheorem ContDiffOn.differentiableOn_iteratedDerivWithin {n : WithTop ℕ∞} {m : ℕ}\n    (h : ContDiffOn 𝕜 n f s) (hmn : m < n) (hs : UniqueDiffOn 𝕜 s) :\n    DifferentiableOn 𝕜 (iteratedDerivWithin m f s) s := fun x hx =>\n  (h x hx).differentiableWithinAt_iteratedDerivWithin hmn <| by rwa [insert_eq_of_mem hx]\n\n"}
{"name":"contDiffOn_iff_continuousOn_differentiableOn_deriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\nn : ENat\nhs : UniqueDiffOn 𝕜 s\n⊢ Iff (ContDiffOn 𝕜 (↑n) f s) (And (∀ (m : Nat), LE.le (↑m) n → ContinuousOn (iteratedDerivWithin m f s) s) (∀ (m : Nat), LT.lt (↑m) n → DifferentiableOn 𝕜 (iteratedDerivWithin m f s) s))","decl":"/-- The property of being `C^n`, initially defined in terms of the Fréchet derivative, can be\nreformulated in terms of the one-dimensional derivative on sets with unique derivatives. -/\ntheorem contDiffOn_iff_continuousOn_differentiableOn_deriv {n : ℕ∞} (hs : UniqueDiffOn 𝕜 s) :\n    ContDiffOn 𝕜 n f s ↔ (∀ m : ℕ, (m : ℕ∞) ≤ n → ContinuousOn (iteratedDerivWithin m f s) s) ∧\n      ∀ m : ℕ, (m : ℕ∞) < n → DifferentiableOn 𝕜 (iteratedDerivWithin m f s) s := by\n  simp only [contDiffOn_iff_continuousOn_differentiableOn hs, iteratedFDerivWithin_eq_equiv_comp,\n    LinearIsometryEquiv.comp_continuousOn_iff, LinearIsometryEquiv.comp_differentiableOn_iff]\n\n"}
{"name":"contDiffOn_nat_iff_continuousOn_differentiableOn_deriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\ns : Set 𝕜\nn : Nat\nhs : UniqueDiffOn 𝕜 s\n⊢ Iff (ContDiffOn 𝕜 (↑n) f s) (And (∀ (m : Nat), LE.le m n → ContinuousOn (iteratedDerivWithin m f s) s) (∀ (m : Nat), LT.lt m n → DifferentiableOn 𝕜 (iteratedDerivWithin m f s) s))","decl":"/-- The property of being `C^n`, initially defined in terms of the Fréchet derivative, can be\nreformulated in terms of the one-dimensional derivative on sets with unique derivatives. -/\ntheorem contDiffOn_nat_iff_continuousOn_differentiableOn_deriv {n : ℕ} (hs : UniqueDiffOn 𝕜 s) :\n    ContDiffOn 𝕜 n f s ↔ (∀ m : ℕ, m ≤ n → ContinuousOn (iteratedDerivWithin m f s) s) ∧\n      ∀ m : ℕ, m < n → DifferentiableOn 𝕜 (iteratedDerivWithin m f s) s := by\n  rw [show n = ((n : ℕ∞) : WithTop ℕ∞) from rfl,\n    contDiffOn_iff_continuousOn_differentiableOn_deriv hs]\n  simp\n\n"}
{"name":"iteratedDerivWithin_succ","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\ns : Set 𝕜\nx : 𝕜\n⊢ Eq (iteratedDerivWithin (HAdd.hAdd n 1) f s x) (derivWithin (iteratedDerivWithin n f s) s x)","decl":"/-- The `n+1`-th iterated derivative within a set with unique derivatives can be obtained by\ndifferentiating the `n`-th iterated derivative. -/\ntheorem iteratedDerivWithin_succ {x : 𝕜} :\n    iteratedDerivWithin (n + 1) f s x = derivWithin (iteratedDerivWithin n f s) s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · rw [iteratedDerivWithin_eq_iteratedFDerivWithin, iteratedFDerivWithin_succ_apply_left,\n      iteratedFDerivWithin_eq_equiv_comp, LinearIsometryEquiv.comp_fderivWithin _ hxs, derivWithin]\n    change ((ContinuousMultilinearMap.mkPiRing 𝕜 (Fin n) ((fderivWithin 𝕜\n      (iteratedDerivWithin n f s) s x : 𝕜 → F) 1) : (Fin n → 𝕜) → F) fun _ : Fin n => 1) =\n      (fderivWithin 𝕜 (iteratedDerivWithin n f s) s x : 𝕜 → F) 1\n    simp\n  · simp [derivWithin_zero_of_isolated hxs, iteratedDerivWithin, iteratedFDerivWithin,\n      fderivWithin_zero_of_isolated hxs]\n\n"}
{"name":"iteratedDerivWithin_eq_iterate","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\ns : Set 𝕜\nx : 𝕜\n⊢ Eq (iteratedDerivWithin n f s x) (Nat.iterate (fun g => derivWithin g s) n f x)","decl":"/-- The `n`-th iterated derivative within a set with unique derivatives can be obtained by\niterating `n` times the differentiation operation. -/\ntheorem iteratedDerivWithin_eq_iterate {x : 𝕜} :\n    iteratedDerivWithin n f s x = (fun g : 𝕜 → F => derivWithin g s)^[n] f x := by\n  induction n generalizing x with\n  | zero => simp\n  | succ n IH =>\n    rw [iteratedDerivWithin_succ, Function.iterate_succ']\n    exact derivWithin_congr (fun y hy => IH) IH\n\n"}
{"name":"iteratedDerivWithin_succ'","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\ns : Set 𝕜\nx : 𝕜\n⊢ Eq (iteratedDerivWithin (HAdd.hAdd n 1) f s x) (iteratedDerivWithin n (derivWithin f s) s x)","decl":"/-- The `n+1`-th iterated derivative within a set with unique derivatives can be obtained by\ntaking the `n`-th derivative of the derivative. -/\ntheorem iteratedDerivWithin_succ' {x : 𝕜} :\n    iteratedDerivWithin (n + 1) f s x = (iteratedDerivWithin n (derivWithin f s) s) x := by\n  rw [iteratedDerivWithin_eq_iterate, iteratedDerivWithin_eq_iterate]; rfl\n\n"}
{"name":"iteratedDeriv_eq_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\nx : 𝕜\n⊢ Eq (iteratedDeriv n f x) ((iteratedFDeriv 𝕜 n f x) fun x => 1)","decl":"theorem iteratedDeriv_eq_iteratedFDeriv :\n    iteratedDeriv n f x = (iteratedFDeriv 𝕜 n f x : (Fin n → 𝕜) → F) fun _ : Fin n => 1 :=\n  rfl\n\n"}
{"name":"iteratedDeriv_eq_equiv_comp","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\n⊢ Eq (iteratedDeriv n f) (Function.comp (⇑(ContinuousMultilinearMap.piFieldEquiv 𝕜 (Fin n) F).symm) (iteratedFDeriv 𝕜 n f))","decl":"/-- Write the iterated derivative as the composition of a continuous linear equiv and the iterated\nFréchet derivative -/\ntheorem iteratedDeriv_eq_equiv_comp : iteratedDeriv n f =\n    (ContinuousMultilinearMap.piFieldEquiv 𝕜 (Fin n) F).symm ∘ iteratedFDeriv 𝕜 n f := by\n  ext x; rfl\n\n"}
{"name":"iteratedFDeriv_eq_equiv_comp","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\n⊢ Eq (iteratedFDeriv 𝕜 n f) (Function.comp (⇑(ContinuousMultilinearMap.piFieldEquiv 𝕜 (Fin n) F)) (iteratedDeriv n f))","decl":"/-- Write the iterated Fréchet derivative as the composition of a continuous linear equiv and the\niterated derivative. -/\ntheorem iteratedFDeriv_eq_equiv_comp : iteratedFDeriv 𝕜 n f =\n    ContinuousMultilinearMap.piFieldEquiv 𝕜 (Fin n) F ∘ iteratedDeriv n f := by\n  rw [iteratedDeriv_eq_equiv_comp, ← Function.comp_assoc, LinearIsometryEquiv.self_comp_symm,\n    Function.id_comp]\n\n"}
{"name":"iteratedFDeriv_apply_eq_iteratedDeriv_mul_prod","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\nx : 𝕜\nm : Fin n → 𝕜\n⊢ Eq ((iteratedFDeriv 𝕜 n f x) m) (HSMul.hSMul (Finset.univ.prod fun i => m i) (iteratedDeriv n f x))","decl":"/-- The `n`-th Fréchet derivative applied to a vector `(m 0, ..., m (n-1))` is the derivative\nmultiplied by the product of the `m i`s. -/\ntheorem iteratedFDeriv_apply_eq_iteratedDeriv_mul_prod {m : Fin n → 𝕜} :\n    (iteratedFDeriv 𝕜 n f x : (Fin n → 𝕜) → F) m = (∏ i, m i) • iteratedDeriv n f x := by\n  rw [iteratedDeriv_eq_iteratedFDeriv, ← ContinuousMultilinearMap.map_smul_univ]; simp\n\n"}
{"name":"norm_iteratedFDeriv_eq_norm_iteratedDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\nx : 𝕜\n⊢ Eq (Norm.norm (iteratedFDeriv 𝕜 n f x)) (Norm.norm (iteratedDeriv n f x))","decl":"theorem norm_iteratedFDeriv_eq_norm_iteratedDeriv :\n    ‖iteratedFDeriv 𝕜 n f x‖ = ‖iteratedDeriv n f x‖ := by\n  rw [iteratedDeriv_eq_equiv_comp, Function.comp_apply, LinearIsometryEquiv.norm_map]\n\n"}
{"name":"iteratedDeriv_zero","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\n⊢ Eq (iteratedDeriv 0 f) f","decl":"@[simp]\ntheorem iteratedDeriv_zero : iteratedDeriv 0 f = f := by ext x; simp [iteratedDeriv]\n\n"}
{"name":"iteratedDeriv_one","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\n⊢ Eq (iteratedDeriv 1 f) (deriv f)","decl":"@[simp]\ntheorem iteratedDeriv_one : iteratedDeriv 1 f = deriv f := by ext x; simp [iteratedDeriv]\n\n"}
{"name":"contDiff_iff_iteratedDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nn : ENat\n⊢ Iff (ContDiff 𝕜 (↑n) f) (And (∀ (m : Nat), LE.le (↑m) n → Continuous (iteratedDeriv m f)) (∀ (m : Nat), LT.lt (↑m) n → Differentiable 𝕜 (iteratedDeriv m f)))","decl":"/-- The property of being `C^n`, initially defined in terms of the Fréchet derivative, can be\nreformulated in terms of the one-dimensional derivative. -/\ntheorem contDiff_iff_iteratedDeriv {n : ℕ∞} : ContDiff 𝕜 n f ↔\n    (∀ m : ℕ, (m : ℕ∞) ≤ n → Continuous (iteratedDeriv m f)) ∧\n      ∀ m : ℕ, (m : ℕ∞) < n → Differentiable 𝕜 (iteratedDeriv m f) := by\n  simp only [contDiff_iff_continuous_differentiable, iteratedFDeriv_eq_equiv_comp,\n    LinearIsometryEquiv.comp_continuous_iff, LinearIsometryEquiv.comp_differentiable_iff]\n\n"}
{"name":"contDiff_nat_iff_iteratedDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nn : Nat\n⊢ Iff (ContDiff 𝕜 (↑n) f) (And (∀ (m : Nat), LE.le m n → Continuous (iteratedDeriv m f)) (∀ (m : Nat), LT.lt m n → Differentiable 𝕜 (iteratedDeriv m f)))","decl":"/-- The property of being `C^n`, initially defined in terms of the Fréchet derivative, can be\nreformulated in terms of the one-dimensional derivative. -/\ntheorem contDiff_nat_iff_iteratedDeriv {n : ℕ} : ContDiff 𝕜 n f ↔\n    (∀ m : ℕ, m ≤ n → Continuous (iteratedDeriv m f)) ∧\n      ∀ m : ℕ, m < n → Differentiable 𝕜 (iteratedDeriv m f) := by\n  rw [show n = ((n : ℕ∞) : WithTop ℕ∞) from rfl, contDiff_iff_iteratedDeriv]\n  simp\n\n"}
{"name":"contDiff_of_differentiable_iteratedDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nn : ENat\nh : ∀ (m : Nat), LE.le (↑m) n → Differentiable 𝕜 (iteratedDeriv m f)\n⊢ ContDiff 𝕜 (↑n) f","decl":"/-- To check that a function is `n` times continuously differentiable, it suffices to check that its\nfirst `n` derivatives are differentiable. This is slightly too strong as the condition we\nrequire on the `n`-th derivative is differentiability instead of continuity, but it has the\nadvantage of avoiding the discussion of continuity in the proof (and for `n = ∞` this is optimal).\n-/\ntheorem contDiff_of_differentiable_iteratedDeriv {n : ℕ∞}\n    (h : ∀ m : ℕ, (m : ℕ∞) ≤ n → Differentiable 𝕜 (iteratedDeriv m f)) : ContDiff 𝕜 n f :=\n  contDiff_iff_iteratedDeriv.2 ⟨fun m hm => (h m hm).continuous, fun m hm => h m (le_of_lt hm)⟩\n\n"}
{"name":"ContDiff.continuous_iteratedDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nn : WithTop ENat\nm : Nat\nh : ContDiff 𝕜 n f\nhmn : LE.le (↑m) n\n⊢ Continuous (iteratedDeriv m f)","decl":"theorem ContDiff.continuous_iteratedDeriv {n : WithTop ℕ∞} (m : ℕ) (h : ContDiff 𝕜 n f)\n    (hmn : m ≤ n) : Continuous (iteratedDeriv m f) :=\n  (contDiff_iff_iteratedDeriv.1 (h.of_le hmn)).1 m le_rfl\n\n"}
{"name":"ContDiff.differentiable_iteratedDeriv","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nn : WithTop ENat\nm : Nat\nh : ContDiff 𝕜 n f\nhmn : LT.lt (↑m) n\n⊢ Differentiable 𝕜 (iteratedDeriv m f)","decl":"theorem ContDiff.differentiable_iteratedDeriv {n : WithTop ℕ∞} (m : ℕ) (h : ContDiff 𝕜 n f)\n    (hmn : m < n) : Differentiable 𝕜 (iteratedDeriv m f) :=\n  (contDiff_iff_iteratedDeriv.1 (h.of_le (ENat.add_one_natCast_le_withTop_of_lt hmn))).2 m\n    (mod_cast (lt_add_one m))\n\n"}
{"name":"iteratedDeriv_succ","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\n⊢ Eq (iteratedDeriv (HAdd.hAdd n 1) f) (deriv (iteratedDeriv n f))","decl":"/-- The `n+1`-th iterated derivative can be obtained by differentiating the `n`-th\niterated derivative. -/\ntheorem iteratedDeriv_succ : iteratedDeriv (n + 1) f = deriv (iteratedDeriv n f) := by\n  ext x\n  rw [← iteratedDerivWithin_univ, ← iteratedDerivWithin_univ, ← derivWithin_univ]\n  exact iteratedDerivWithin_succ\n\n"}
{"name":"iteratedDeriv_eq_iterate","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\n⊢ Eq (iteratedDeriv n f) (Nat.iterate deriv n f)","decl":"/-- The `n`-th iterated derivative can be obtained by iterating `n` times the\ndifferentiation operation. -/\ntheorem iteratedDeriv_eq_iterate : iteratedDeriv n f = deriv^[n] f := by\n  ext x\n  rw [← iteratedDerivWithin_univ]\n  convert iteratedDerivWithin_eq_iterate (F := F)\n  simp [derivWithin_univ]\n\n"}
{"name":"iteratedDeriv_succ'","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf : 𝕜 → F\n⊢ Eq (iteratedDeriv (HAdd.hAdd n 1) f) (iteratedDeriv n (deriv f))","decl":"/-- The `n+1`-th iterated derivative can be obtained by taking the `n`-th derivative of the\nderivative. -/\ntheorem iteratedDeriv_succ' : iteratedDeriv (n + 1) f = iteratedDeriv n (deriv f) := by\n  rw [iteratedDeriv_eq_iterate, iteratedDeriv_eq_iterate]; rfl\n\n"}
{"name":"AnalyticAt.hasFPowerSeriesAt","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Defs","initialProofState":"𝕜 : Type u_3\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : CompleteSpace 𝕜\ninst✝ : CharZero 𝕜\nf : 𝕜 → 𝕜\nx : 𝕜\nh : AnalyticAt 𝕜 f x\n⊢ HasFPowerSeriesAt f (FormalMultilinearSeries.ofScalars 𝕜 fun n => HDiv.hDiv (iteratedDeriv n f x) ↑n.factorial) x","decl":"lemma AnalyticAt.hasFPowerSeriesAt {𝕜 : Type*} [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜]\n    [CharZero 𝕜] {f : 𝕜 → 𝕜} {x : 𝕜} (h : AnalyticAt 𝕜 f x) :\n    HasFPowerSeriesAt f\n      (FormalMultilinearSeries.ofScalars 𝕜 (fun n ↦ iteratedDeriv n f x / n.factorial)) x := by\n  obtain ⟨p, hp⟩ := h\n  convert hp\n  obtain ⟨r, hpr⟩ := hp\n  ext n u\n  have h_fact_smul := hpr.factorial_smul 1\n  simp only [FormalMultilinearSeries.apply_eq_prod_smul_coeff, Finset.prod_const, Finset.card_univ,\n    Fintype.card_fin, smul_eq_mul, nsmul_eq_mul, one_pow, one_mul] at h_fact_smul\n  simp only [FormalMultilinearSeries.apply_eq_prod_smul_coeff,\n    FormalMultilinearSeries.coeff_ofScalars, smul_eq_mul, mul_eq_mul_left_iff]\n  left\n  rw [div_eq_iff, mul_comm, h_fact_smul, ← iteratedDeriv_eq_iteratedFDeriv]\n  norm_cast\n  exact Nat.factorial_ne_zero _\n"}
