{"name":"List.Duplicate.brecOn","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nx : α\nmotive✝ : (a : List α) → List.Duplicate x a → Prop\na✝ : List α\nx✝ : List.Duplicate x a✝\nih✝ : ∀ (a : List α) (x_1 : List.Duplicate x a), x_1.below → motive✝ a x_1\n⊢ motive✝ a✝ x✝","decl":"/-- Property that an element `x : α` of `l : List α` can be found in the list more than once. -/\ninductive Duplicate (x : α) : List α → Prop\n  | cons_mem {l : List α} : x ∈ l → Duplicate x (x :: l)\n  | cons_duplicate {y : α} {l : List α} : Duplicate x l → Duplicate x (y :: l)\n\n"}
{"name":"List.Mem.duplicate_cons_self","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx : α\nh : Membership.mem l x\n⊢ List.Duplicate x (List.cons x l)","decl":"theorem Mem.duplicate_cons_self (h : x ∈ l) : x ∈+ x :: l :=\n  Duplicate.cons_mem h\n\n"}
{"name":"List.Duplicate.duplicate_cons","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx : α\nh : List.Duplicate x l\ny : α\n⊢ List.Duplicate x (List.cons y l)","decl":"theorem Duplicate.duplicate_cons (h : x ∈+ l) (y : α) : x ∈+ y :: l :=\n  Duplicate.cons_duplicate h\n\n"}
{"name":"List.Duplicate.mem","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx : α\nh : List.Duplicate x l\n⊢ Membership.mem l x","decl":"theorem Duplicate.mem (h : x ∈+ l) : x ∈ l := by\n  induction h with\n  | cons_mem => exact mem_cons_self _ _\n  | cons_duplicate _ hm => exact mem_cons_of_mem _ hm\n\n"}
{"name":"List.Duplicate.mem_cons_self","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx : α\nh : List.Duplicate x (List.cons x l)\n⊢ Membership.mem l x","decl":"theorem Duplicate.mem_cons_self (h : x ∈+ x :: l) : x ∈ l := by\n  cases' h with _ h _ _ h\n  · exact h\n  · exact h.mem\n\n"}
{"name":"List.duplicate_cons_self_iff","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx : α\n⊢ Iff (List.Duplicate x (List.cons x l)) (Membership.mem l x)","decl":"@[simp]\ntheorem duplicate_cons_self_iff : x ∈+ x :: l ↔ x ∈ l :=\n  ⟨Duplicate.mem_cons_self, Mem.duplicate_cons_self⟩\n\n"}
{"name":"List.Duplicate.ne_nil","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx : α\nh : List.Duplicate x l\n⊢ Ne l List.nil","decl":"theorem Duplicate.ne_nil (h : x ∈+ l) : l ≠ [] := fun H => (mem_nil_iff x).mp (H ▸ h.mem)\n\n"}
{"name":"List.not_duplicate_nil","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nx : α\n⊢ Not (List.Duplicate x List.nil)","decl":"@[simp]\ntheorem not_duplicate_nil (x : α) : ¬x ∈+ [] := fun H => H.ne_nil rfl\n\n"}
{"name":"List.Duplicate.ne_singleton","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx : α\nh : List.Duplicate x l\ny : α\n⊢ Ne l (List.cons y List.nil)","decl":"theorem Duplicate.ne_singleton (h : x ∈+ l) (y : α) : l ≠ [y] := by\n  induction' h with l' h z l' h _\n  · simp [ne_nil_of_mem h]\n  · simp [ne_nil_of_mem h.mem]\n\n"}
{"name":"List.not_duplicate_singleton","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nx y : α\n⊢ Not (List.Duplicate x (List.cons y List.nil))","decl":"@[simp]\ntheorem not_duplicate_singleton (x y : α) : ¬x ∈+ [y] := fun H => H.ne_singleton _ rfl\n\n"}
{"name":"List.Duplicate.elim_nil","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nx : α\nh : List.Duplicate x List.nil\n⊢ False","decl":"theorem Duplicate.elim_nil (h : x ∈+ []) : False :=\n  not_duplicate_nil x h\n\n"}
{"name":"List.Duplicate.elim_singleton","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nx y : α\nh : List.Duplicate x (List.cons y List.nil)\n⊢ False","decl":"theorem Duplicate.elim_singleton {y : α} (h : x ∈+ [y]) : False :=\n  not_duplicate_singleton x y h\n\n"}
{"name":"List.duplicate_cons_iff","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx y : α\n⊢ Iff (List.Duplicate x (List.cons y l)) (Or (And (Eq y x) (Membership.mem l x)) (List.Duplicate x l))","decl":"theorem duplicate_cons_iff {y : α} : x ∈+ y :: l ↔ y = x ∧ x ∈ l ∨ x ∈+ l := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · cases' h with _ hm _ _ hm\n    · exact Or.inl ⟨rfl, hm⟩\n    · exact Or.inr hm\n  · rcases h with (⟨rfl | h⟩ | h)\n    · simpa\n    · exact h.cons_duplicate\n\n"}
{"name":"List.Duplicate.of_duplicate_cons","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx y : α\nh : List.Duplicate x (List.cons y l)\nhx : Ne x y\n⊢ List.Duplicate x l","decl":"theorem Duplicate.of_duplicate_cons {y : α} (h : x ∈+ y :: l) (hx : x ≠ y) : x ∈+ l := by\n  simpa [duplicate_cons_iff, hx.symm] using h\n\n"}
{"name":"List.duplicate_cons_iff_of_ne","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx y : α\nhne : Ne x y\n⊢ Iff (List.Duplicate x (List.cons y l)) (List.Duplicate x l)","decl":"theorem duplicate_cons_iff_of_ne {y : α} (hne : x ≠ y) : x ∈+ y :: l ↔ x ∈+ l := by\n  simp [duplicate_cons_iff, hne.symm]\n\n"}
{"name":"List.Duplicate.mono_sublist","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx : α\nl' : List α\nhx : List.Duplicate x l\nh : l.Sublist l'\n⊢ List.Duplicate x l'","decl":"theorem Duplicate.mono_sublist {l' : List α} (hx : x ∈+ l) (h : l <+ l') : x ∈+ l' := by\n  induction' h with l₁ l₂ y _ IH l₁ l₂ y h IH\n  · exact hx\n  · exact (IH hx).duplicate_cons _\n  · rw [duplicate_cons_iff] at hx ⊢\n    rcases hx with (⟨rfl, hx⟩ | hx)\n    · simp [h.subset hx]\n    · simp [IH hx]\n\n"}
{"name":"List.duplicate_iff_sublist","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx : α\n⊢ Iff (List.Duplicate x l) ((List.cons x (List.cons x List.nil)).Sublist l)","decl":"/-- The contrapositive of `List.nodup_iff_sublist`. -/\ntheorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by\n  induction' l with y l IH\n  · simp\n  · by_cases hx : x = y\n    · simp [hx, cons_sublist_cons, singleton_sublist]\n    · rw [duplicate_cons_iff_of_ne hx, IH]\n      refine ⟨sublist_cons_of_sublist y, fun h => ?_⟩\n      cases h\n      · assumption\n      · contradiction\n\n"}
{"name":"List.nodup_iff_forall_not_duplicate","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\n⊢ Iff l.Nodup (∀ (x : α), Not (List.Duplicate x l))","decl":"theorem nodup_iff_forall_not_duplicate : Nodup l ↔ ∀ x : α, ¬x ∈+ l := by\n  simp_rw [nodup_iff_sublist, duplicate_iff_sublist]\n\n"}
{"name":"List.exists_duplicate_iff_not_nodup","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\n⊢ Iff (Exists fun x => List.Duplicate x l) (Not l.Nodup)","decl":"theorem exists_duplicate_iff_not_nodup : (∃ x : α, x ∈+ l) ↔ ¬Nodup l := by\n  simp [nodup_iff_forall_not_duplicate]\n\n"}
{"name":"List.Duplicate.not_nodup","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx : α\nh : List.Duplicate x l\n⊢ Not l.Nodup","decl":"theorem Duplicate.not_nodup (h : x ∈+ l) : ¬Nodup l := fun H =>\n  nodup_iff_forall_not_duplicate.mp H _ h\n\n"}
{"name":"List.duplicate_iff_two_le_count","module":"Mathlib.Data.List.Duplicate","initialProofState":"α : Type u_1\nl : List α\nx : α\ninst✝ : DecidableEq α\n⊢ Iff (List.Duplicate x l) (LE.le 2 (List.count x l))","decl":"theorem duplicate_iff_two_le_count [DecidableEq α] : x ∈+ l ↔ 2 ≤ count x l := by\n  simp [replicate_succ, duplicate_iff_sublist, le_count_iff_replicate_sublist]\n\n"}
