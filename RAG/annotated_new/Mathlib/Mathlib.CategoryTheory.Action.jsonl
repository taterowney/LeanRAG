{"name":"CategoryTheory.actionAsFunctor_obj","module":"Mathlib.CategoryTheory.Action","initialProofState":"M : Type u_1\ninst‚úù¬π : Monoid M\nX : Type u\ninst‚úù : MulAction M X\nx‚úù : CategoryTheory.SingleObj M\n‚ä¢ Eq ((CategoryTheory.actionAsFunctor M X).obj x‚úù) X","decl":"/-- A multiplicative action M ‚Üª X viewed as a functor mapping the single object of M to X\n  and an element `m : M` to the map `X ‚Üí X` given by multiplication by `m`. -/\n@[simps]\ndef actionAsFunctor : SingleObj M ‚•§ Type u where\n  obj _ := X\n  map := (¬∑ ‚Ä¢ ¬∑)\n  map_id _ := funext <| MulAction.one_smul\n  map_comp f g := funext fun x => (smul_smul g f x).symm\n\n"}
{"name":"CategoryTheory.actionAsFunctor_map","module":"Mathlib.CategoryTheory.Action","initialProofState":"M : Type u_1\ninst‚úù¬π : Monoid M\nX : Type u\ninst‚úù : MulAction M X\nX‚úù Y‚úù : CategoryTheory.SingleObj M\nx1‚úù : Quiver.Hom X‚úù Y‚úù\nx2‚úù : X\n‚ä¢ Eq ((CategoryTheory.actionAsFunctor M X).map x1‚úù x2‚úù) (HSMul.hSMul x1‚úù x2‚úù)","decl":"/-- A multiplicative action M ‚Üª X viewed as a functor mapping the single object of M to X\n  and an element `m : M` to the map `X ‚Üí X` given by multiplication by `m`. -/\n@[simps]\ndef actionAsFunctor : SingleObj M ‚•§ Type u where\n  obj _ := X\n  map := (¬∑ ‚Ä¢ ¬∑)\n  map_id _ := funext <| MulAction.one_smul\n  map_comp f g := funext fun x => (smul_smul g f x).symm\n\n"}
{"name":"CategoryTheory.ActionCategory.œÄ_map","module":"Mathlib.CategoryTheory.Action","initialProofState":"M : Type u_1\ninst‚úù¬π : Monoid M\nX : Type u\ninst‚úù : MulAction M X\np q : CategoryTheory.ActionCategory M X\nf : Quiver.Hom p q\n‚ä¢ Eq ((CategoryTheory.ActionCategory.œÄ M X).map f) ‚Üëf","decl":"@[simp]\ntheorem œÄ_map (p q : ActionCategory M X) (f : p ‚ü∂ q) : (œÄ M X).map f = f.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.ActionCategory.œÄ_obj","module":"Mathlib.CategoryTheory.Action","initialProofState":"M : Type u_1\ninst‚úù¬π : Monoid M\nX : Type u\ninst‚úù : MulAction M X\np : CategoryTheory.ActionCategory M X\n‚ä¢ Eq ((CategoryTheory.ActionCategory.œÄ M X).obj p) (CategoryTheory.SingleObj.star M)","decl":"@[simp]\ntheorem œÄ_obj (p : ActionCategory M X) : (œÄ M X).obj p = SingleObj.star M :=\n  Unit.ext _ _\n\n"}
{"name":"CategoryTheory.ActionCategory.coe_back","module":"Mathlib.CategoryTheory.Action","initialProofState":"M : Type u_1\ninst‚úù¬π : Monoid M\nX : Type u\ninst‚úù : MulAction M X\nx : X\n‚ä¢ Eq (CategoryTheory.ActionCategory.back ‚ü®Unit.unit, x‚ü©) x","decl":"@[simp]\ntheorem coe_back (x : X) : ActionCategory.back (x : ActionCategory M X) = x :=\n  rfl\n\n"}
{"name":"CategoryTheory.ActionCategory.back_coe","module":"Mathlib.CategoryTheory.Action","initialProofState":"M : Type u_1\ninst‚úù¬π : Monoid M\nX : Type u\ninst‚úù : MulAction M X\nx : CategoryTheory.ActionCategory M X\n‚ä¢ Eq ‚ü®Unit.unit, x.back‚ü© x","decl":"@[simp]\ntheorem back_coe (x : ActionCategory M X) : ‚Üëx.back = x := by cases x; rfl\n\n"}
{"name":"CategoryTheory.ActionCategory.hom_as_subtype","module":"Mathlib.CategoryTheory.Action","initialProofState":"M : Type u_1\ninst‚úù¬π : Monoid M\nX : Type u\ninst‚úù : MulAction M X\np q : CategoryTheory.ActionCategory M X\n‚ä¢ Eq (Quiver.Hom p q) (Subtype fun m => Eq (HSMul.hSMul m p.back) q.back)","decl":"theorem hom_as_subtype (p q : ActionCategory M X) : (p ‚ü∂ q) = { m : M // m ‚Ä¢ p.back = q.back } :=\n  rfl\n\n"}
{"name":"CategoryTheory.ActionCategory.instNonempty","module":"Mathlib.CategoryTheory.Action","initialProofState":"M : Type u_1\ninst‚úù¬≤ : Monoid M\nX : Type u\ninst‚úù¬π : MulAction M X\ninst‚úù : Nonempty X\n‚ä¢ Nonempty (CategoryTheory.ActionCategory M X)","decl":"instance [Nonempty X] : Nonempty (ActionCategory M X) :=\n  Nonempty.map (objEquiv M X) inferInstance\n\n"}
{"name":"CategoryTheory.ActionCategory.stabilizerIsoEnd_apply","module":"Mathlib.CategoryTheory.Action","initialProofState":"M : Type u_1\ninst‚úù¬π : Monoid M\nX : Type u\ninst‚úù : MulAction M X\nx : X\nf : Subtype fun x_1 => Membership.mem (MulAction.stabilizerSubmonoid M x) x_1\n‚ä¢ Eq ((CategoryTheory.ActionCategory.stabilizerIsoEnd M x) f) f","decl":"@[simp]\ntheorem stabilizerIsoEnd_apply (f : stabilizerSubmonoid M x) :\n    (stabilizerIsoEnd M x) f = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.ActionCategory.stabilizerIsoEnd_symm_apply","module":"Mathlib.CategoryTheory.Action","initialProofState":"M : Type u_1\ninst‚úù¬π : Monoid M\nX : Type u\ninst‚úù : MulAction M X\nx : X\nf : CategoryTheory.End ‚ü®Unit.unit, x‚ü©\n‚ä¢ Eq ((CategoryTheory.ActionCategory.stabilizerIsoEnd M x).symm f) f","decl":"@[simp 1100]\ntheorem stabilizerIsoEnd_symm_apply (f : End _) : (stabilizerIsoEnd M x).symm f = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.ActionCategory.id_val","module":"Mathlib.CategoryTheory.Action","initialProofState":"M : Type u_1\ninst‚úù¬π : Monoid M\nX : Type u\ninst‚úù : MulAction M X\nx : CategoryTheory.ActionCategory M X\n‚ä¢ Eq (‚Üë(CategoryTheory.CategoryStruct.id x)) 1","decl":"@[simp]\nprotected theorem id_val (x : ActionCategory M X) : Subtype.val (ùüô x) = 1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.ActionCategory.comp_val","module":"Mathlib.CategoryTheory.Action","initialProofState":"M : Type u_1\ninst‚úù¬π : Monoid M\nX : Type u\ninst‚úù : MulAction M X\nx y z : CategoryTheory.ActionCategory M X\nf : Quiver.Hom x y\ng : Quiver.Hom y z\n‚ä¢ Eq (‚Üë(CategoryTheory.CategoryStruct.comp f g)) (HMul.hMul ‚Üëg ‚Üëf)","decl":"@[simp]\nprotected theorem comp_val {x y z : ActionCategory M X} (f : x ‚ü∂ y) (g : y ‚ü∂ z) :\n    (f ‚â´ g).val = g.val * f.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.ActionCategory.instIsConnectedOfIsPretransitiveOfNonempty","module":"Mathlib.CategoryTheory.Action","initialProofState":"M : Type u_1\ninst‚úù¬≥ : Monoid M\nX : Type u\ninst‚úù¬≤ : MulAction M X\ninst‚úù¬π : MulAction.IsPretransitive M X\ninst‚úù : Nonempty X\n‚ä¢ CategoryTheory.IsConnected (CategoryTheory.ActionCategory M X)","decl":"instance [IsPretransitive M X] [Nonempty X] : IsConnected (ActionCategory M X) :=\n  zigzag_isConnected fun x y =>\n    Relation.ReflTransGen.single <|\n      Or.inl <| nonempty_subtype.mpr (show _ from exists_smul_eq M x.back y.back)\n\n"}
{"name":"CategoryTheory.ActionCategory.homOfPair.val","module":"Mathlib.CategoryTheory.Action","initialProofState":"X : Type u\nG : Type u_2\ninst‚úù¬π : Group G\ninst‚úù : MulAction G X\nt : X\ng : G\n‚ä¢ Eq (‚Üë(CategoryTheory.ActionCategory.homOfPair t g)) g","decl":"@[simp]\ntheorem homOfPair.val (t : X) (g : G) : (homOfPair t g).val = g :=\n  rfl\n\n"}
{"name":"CategoryTheory.ActionCategory.cases'","module":"Mathlib.CategoryTheory.Action","initialProofState":"X : Type u\nG : Type u_2\ninst‚úù¬π : Group G\ninst‚úù : MulAction G X\na' b' : CategoryTheory.ActionCategory G X\nf : Quiver.Hom a' b'\n‚ä¢ Exists fun a => Exists fun b => Exists fun g => Exists fun ha => Exists fun hb => Exists fun hg => Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ActionCategory.homOfPair b g) (CategoryTheory.eqToHom ‚ãØ)))","decl":"lemma cases' ‚¶Éa' b' : ActionCategory G X‚¶Ñ (f : a' ‚ü∂ b') :\n    ‚àÉ (a b : X) (g : G) (ha : a' = a) (hb : b' = b) (hg : a = g‚Åª¬π ‚Ä¢ b),\n      f = eqToHom (by rw [ha, hg]) ‚â´ homOfPair b g ‚â´ eqToHom (by rw [hb]) := by\n  revert a' b' f\n  exact ActionCategory.cases (fun t g => ‚ü®g‚Åª¬π ‚Ä¢ t, t, g, rfl, rfl, rfl, by simp‚ü©)\n\n"}
{"name":"CategoryTheory.ActionCategory.curry_apply_right","module":"Mathlib.CategoryTheory.Action","initialProofState":"X : Type u\nG : Type u_2\ninst‚úù¬≤ : Group G\ninst‚úù¬π : MulAction G X\nH : Type u_3\ninst‚úù : Group H\nF : CategoryTheory.Functor (CategoryTheory.ActionCategory G X) (CategoryTheory.SingleObj H)\ng : G\n‚ä¢ Eq ((CategoryTheory.ActionCategory.curry F) g).right g","decl":"/-- Given `G` acting on `X`, a functor from the corresponding action groupoid to a group `H`\n    can be curried to a group homomorphism `G ‚Üí* (X ‚Üí H) ‚ãä G`. -/\n@[simps]\ndef curry (F : ActionCategory G X ‚•§ SingleObj H) : G ‚Üí* (X ‚Üí H) ‚ãä[mulAutArrow] G :=\n  have F_map_eq : ‚àÄ {a b} {f : a ‚ü∂ b}, F.map f = (F.map (homOfPair b.back f.val) : H) := by\n    apply ActionCategory.cases\n    intros\n    rfl\n  { toFun := fun g => ‚ü®fun b => F.map (homOfPair b g), g‚ü©\n    map_one' := by\n      dsimp\n      ext1\n      ¬∑ ext b\n        exact F_map_eq.symm.trans (F.map_id b)\n      rfl\n    map_mul' := by\n      intro g h\n      ext b\n      ¬∑ exact F_map_eq.symm.trans (F.map_comp (homOfPair (g‚Åª¬π ‚Ä¢ b) h) (homOfPair b g))\n      rfl }\n\n"}
{"name":"CategoryTheory.ActionCategory.curry_apply_left","module":"Mathlib.CategoryTheory.Action","initialProofState":"X : Type u\nG : Type u_2\ninst‚úù¬≤ : Group G\ninst‚úù¬π : MulAction G X\nH : Type u_3\ninst‚úù : Group H\nF : CategoryTheory.Functor (CategoryTheory.ActionCategory G X) (CategoryTheory.SingleObj H)\ng : G\nb : X\n‚ä¢ Eq (((CategoryTheory.ActionCategory.curry F) g).left b) (F.map (CategoryTheory.ActionCategory.homOfPair b g))","decl":"/-- Given `G` acting on `X`, a functor from the corresponding action groupoid to a group `H`\n    can be curried to a group homomorphism `G ‚Üí* (X ‚Üí H) ‚ãä G`. -/\n@[simps]\ndef curry (F : ActionCategory G X ‚•§ SingleObj H) : G ‚Üí* (X ‚Üí H) ‚ãä[mulAutArrow] G :=\n  have F_map_eq : ‚àÄ {a b} {f : a ‚ü∂ b}, F.map f = (F.map (homOfPair b.back f.val) : H) := by\n    apply ActionCategory.cases\n    intros\n    rfl\n  { toFun := fun g => ‚ü®fun b => F.map (homOfPair b g), g‚ü©\n    map_one' := by\n      dsimp\n      ext1\n      ¬∑ ext b\n        exact F_map_eq.symm.trans (F.map_id b)\n      rfl\n    map_mul' := by\n      intro g h\n      ext b\n      ¬∑ exact F_map_eq.symm.trans (F.map_comp (homOfPair (g‚Åª¬π ‚Ä¢ b) h) (homOfPair b g))\n      rfl }\n\n"}
{"name":"CategoryTheory.ActionCategory.uncurry_map","module":"Mathlib.CategoryTheory.Action","initialProofState":"X : Type u\nG : Type u_2\ninst‚úù¬≤ : Group G\ninst‚úù¬π : MulAction G X\nH : Type u_3\ninst‚úù : Group H\nF : MonoidHom G (SemidirectProduct (X ‚Üí H) G mulAutArrow)\nsane : ‚àÄ (g : G), Eq (F g).right g\nx‚úù b : CategoryTheory.ActionCategory G X\nf : Quiver.Hom x‚úù b\n‚ä¢ Eq ((CategoryTheory.ActionCategory.uncurry F sane).map f) ((F ‚Üëf).left b.back)","decl":"/-- Given `G` acting on `X`, a group homomorphism `œÜ : G ‚Üí* (X ‚Üí H) ‚ãä G` can be uncurried to\n    a functor from the action groupoid to `H`, provided that `œÜ g = (_, g)` for all `g`. -/\n@[simps]\ndef uncurry (F : G ‚Üí* (X ‚Üí H) ‚ãä[mulAutArrow] G) (sane : ‚àÄ g, (F g).right = g) :\n    ActionCategory G X ‚•§ SingleObj H where\n  obj _ := ()\n  map {_ b} f := (F f.val).left b.back\n  map_id x := by\n    dsimp\n    rw [F.map_one]\n    rfl\n  map_comp f g := by\n    -- Porting note: I was not able to use `ActionCategory.cases` here,\n    -- but `ActionCategory.cases'` seems as good; the original proof was:\n    -- intro x y z f g; revert y z g\n    -- refine' action_category.cases _\n    -- simp [single_obj.comp_as_mul, sane]\n    obtain ‚ü®_, z, Œ≥‚ÇÅ, rfl, rfl, rfl, rfl‚ü© := ActionCategory.cases' g\n    obtain ‚ü®_, y, Œ≥‚ÇÇ, rfl, hy, rfl, rfl‚ü© := ActionCategory.cases' f\n    obtain rfl : y = Œ≥‚ÇÅ‚Åª¬π ‚Ä¢ z := congr_arg Sigma.snd hy.symm\n    simp [sane]\n    rfl\n\n"}
{"name":"CategoryTheory.ActionCategory.uncurry_obj","module":"Mathlib.CategoryTheory.Action","initialProofState":"X : Type u\nG : Type u_2\ninst‚úù¬≤ : Group G\ninst‚úù¬π : MulAction G X\nH : Type u_3\ninst‚úù : Group H\nF : MonoidHom G (SemidirectProduct (X ‚Üí H) G mulAutArrow)\nsane : ‚àÄ (g : G), Eq (F g).right g\nx‚úù : CategoryTheory.ActionCategory G X\n‚ä¢ Eq ((CategoryTheory.ActionCategory.uncurry F sane).obj x‚úù) Unit.unit","decl":"/-- Given `G` acting on `X`, a group homomorphism `œÜ : G ‚Üí* (X ‚Üí H) ‚ãä G` can be uncurried to\n    a functor from the action groupoid to `H`, provided that `œÜ g = (_, g)` for all `g`. -/\n@[simps]\ndef uncurry (F : G ‚Üí* (X ‚Üí H) ‚ãä[mulAutArrow] G) (sane : ‚àÄ g, (F g).right = g) :\n    ActionCategory G X ‚•§ SingleObj H where\n  obj _ := ()\n  map {_ b} f := (F f.val).left b.back\n  map_id x := by\n    dsimp\n    rw [F.map_one]\n    rfl\n  map_comp f g := by\n    -- Porting note: I was not able to use `ActionCategory.cases` here,\n    -- but `ActionCategory.cases'` seems as good; the original proof was:\n    -- intro x y z f g; revert y z g\n    -- refine' action_category.cases _\n    -- simp [single_obj.comp_as_mul, sane]\n    obtain ‚ü®_, z, Œ≥‚ÇÅ, rfl, rfl, rfl, rfl‚ü© := ActionCategory.cases' g\n    obtain ‚ü®_, y, Œ≥‚ÇÇ, rfl, hy, rfl, rfl‚ü© := ActionCategory.cases' f\n    obtain rfl : y = Œ≥‚ÇÅ‚Åª¬π ‚Ä¢ z := congr_arg Sigma.snd hy.symm\n    simp [sane]\n    rfl\n\n"}
