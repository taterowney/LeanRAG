{"name":"CategoryTheory.Equivalence.precoherent","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝ : CategoryTheory.Precoherent C\ne : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.Precoherent D","decl":"/-- `Precoherent` is preserved by equivalence of categories. -/\ntheorem precoherent (e : C ≌ D) : Precoherent D := e.inverse.reflects_precoherent\n\n"}
{"name":"CategoryTheory.Equivalence.instPrecoherentSmallModel","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Precoherent C\ninst✝ : CategoryTheory.EssentiallySmall.{u_3, u_4, u_1} C\n⊢ CategoryTheory.Precoherent (CategoryTheory.SmallModel.{u_3, u_4, u_1} C)","decl":"instance [EssentiallySmall C] :\n    Precoherent (SmallModel C) := (equivSmallModel C).precoherent\n\n"}
{"name":"CategoryTheory.Equivalence.instIsDenseSubsiteCoherentTopologyInverse","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝ : CategoryTheory.Precoherent C\ne : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.Functor.IsDenseSubsite (CategoryTheory.coherentTopology D) (CategoryTheory.coherentTopology C) e.inverse","decl":"instance (e : C ≌ D) : haveI := precoherent e\n    e.inverse.IsDenseSubsite (coherentTopology D) (coherentTopology C) where\n  functorPushforward_mem_iff := by\n    rw [coherentTopology.eq_induced e.inverse]\n    simp only [Functor.mem_inducedTopology_sieves_iff, implies_true]\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPrecoherent_inverse_obj_val_obj","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Precoherent C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Sheaf (CategoryTheory.coherentTopology D) A\nX : Opposite C\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPrecoherent A e).inverse.obj F).val.obj X) (F.val.obj { unop := e.functor.obj (Opposite.unop X) })","decl":"/--\nEquivalent precoherent categories give equivalent coherent toposes.\n-/\n@[simps!]\ndef sheafCongrPrecoherent (e : C ≌ D) : haveI := e.precoherent\n    Sheaf (coherentTopology C) A ≌ Sheaf (coherentTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPrecoherent_functor_obj_val_map","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Precoherent C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Sheaf (CategoryTheory.coherentTopology C) A\nX✝ Y✝ : Opposite D\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPrecoherent A e).functor.obj F).val.map f) (F.val.map (e.inverse.map f.unop).op)","decl":"/--\nEquivalent precoherent categories give equivalent coherent toposes.\n-/\n@[simps!]\ndef sheafCongrPrecoherent (e : C ≌ D) : haveI := e.precoherent\n    Sheaf (coherentTopology C) A ≌ Sheaf (coherentTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPrecoherent_unitIso_inv_app_val_app","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Precoherent C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nX✝ : CategoryTheory.Sheaf (CategoryTheory.coherentTopology C) A\nX : Opposite C\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPrecoherent A e).unitIso.inv.app X✝).val.app X) (X✝.val.map (e.unitIso.hom.app (Opposite.unop X)).op)","decl":"/--\nEquivalent precoherent categories give equivalent coherent toposes.\n-/\n@[simps!]\ndef sheafCongrPrecoherent (e : C ≌ D) : haveI := e.precoherent\n    Sheaf (coherentTopology C) A ≌ Sheaf (coherentTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPrecoherent_counitIso_inv_app_val_app","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Precoherent C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nX✝ : CategoryTheory.Sheaf (CategoryTheory.coherentTopology D) A\nX : Opposite D\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPrecoherent A e).counitIso.inv.app X✝).val.app X) (X✝.val.map (e.counitIso.hom.app (Opposite.unop X)).op)","decl":"/--\nEquivalent precoherent categories give equivalent coherent toposes.\n-/\n@[simps!]\ndef sheafCongrPrecoherent (e : C ≌ D) : haveI := e.precoherent\n    Sheaf (coherentTopology C) A ≌ Sheaf (coherentTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPrecoherent_inverse_map_val_app","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Precoherent C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nX✝ Y✝ : CategoryTheory.Sheaf (CategoryTheory.coherentTopology D) A\nf : Quiver.Hom X✝ Y✝\nX : Opposite C\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPrecoherent A e).inverse.map f).val.app X) (f.val.app { unop := e.functor.obj (Opposite.unop X) })","decl":"/--\nEquivalent precoherent categories give equivalent coherent toposes.\n-/\n@[simps!]\ndef sheafCongrPrecoherent (e : C ≌ D) : haveI := e.precoherent\n    Sheaf (coherentTopology C) A ≌ Sheaf (coherentTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPrecoherent_counitIso_hom_app_val_app","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Precoherent C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nX✝ : CategoryTheory.Sheaf (CategoryTheory.coherentTopology D) A\nX : Opposite D\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPrecoherent A e).counitIso.hom.app X✝).val.app X) (X✝.val.map (e.counitIso.inv.app (Opposite.unop X)).op)","decl":"/--\nEquivalent precoherent categories give equivalent coherent toposes.\n-/\n@[simps!]\ndef sheafCongrPrecoherent (e : C ≌ D) : haveI := e.precoherent\n    Sheaf (coherentTopology C) A ≌ Sheaf (coherentTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPrecoherent_functor_map_val_app","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Precoherent C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nX✝ Y✝ : CategoryTheory.Sheaf (CategoryTheory.coherentTopology C) A\nf : Quiver.Hom X✝ Y✝\nX : Opposite D\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPrecoherent A e).functor.map f).val.app X) (f.val.app { unop := e.inverse.obj (Opposite.unop X) })","decl":"/--\nEquivalent precoherent categories give equivalent coherent toposes.\n-/\n@[simps!]\ndef sheafCongrPrecoherent (e : C ≌ D) : haveI := e.precoherent\n    Sheaf (coherentTopology C) A ≌ Sheaf (coherentTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPrecoherent_inverse_obj_val_map","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Precoherent C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Sheaf (CategoryTheory.coherentTopology D) A\nX✝ Y✝ : Opposite C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPrecoherent A e).inverse.obj F).val.map f) (F.val.map (e.functor.map f.unop).op)","decl":"/--\nEquivalent precoherent categories give equivalent coherent toposes.\n-/\n@[simps!]\ndef sheafCongrPrecoherent (e : C ≌ D) : haveI := e.precoherent\n    Sheaf (coherentTopology C) A ≌ Sheaf (coherentTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPrecoherent_unitIso_hom_app_val_app","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Precoherent C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nX✝ : CategoryTheory.Sheaf (CategoryTheory.coherentTopology C) A\nX : Opposite C\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPrecoherent A e).unitIso.hom.app X✝).val.app X) (X✝.val.map (e.unitIso.inv.app (Opposite.unop X)).op)","decl":"/--\nEquivalent precoherent categories give equivalent coherent toposes.\n-/\n@[simps!]\ndef sheafCongrPrecoherent (e : C ≌ D) : haveI := e.precoherent\n    Sheaf (coherentTopology C) A ≌ Sheaf (coherentTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPrecoherent_functor_obj_val_obj","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Precoherent C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Sheaf (CategoryTheory.coherentTopology C) A\nX : Opposite D\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPrecoherent A e).functor.obj F).val.obj X) (F.val.obj { unop := e.inverse.obj (Opposite.unop X) })","decl":"/--\nEquivalent precoherent categories give equivalent coherent toposes.\n-/\n@[simps!]\ndef sheafCongrPrecoherent (e : C ≌ D) : haveI := e.precoherent\n    Sheaf (coherentTopology C) A ≌ Sheaf (coherentTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.precoherent_isSheaf_iff","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Precoherent C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Functor (Opposite C) A\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) F) (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology D) (e.inverse.op.comp F))","decl":"/--\nThe coherent sheaf condition can be checked after precomposing with the equivalence.\n-/\ntheorem precoherent_isSheaf_iff (e : C ≌ D) (F : Cᵒᵖ ⥤ A) : haveI := e.precoherent\n    IsSheaf (coherentTopology C) F ↔ IsSheaf (coherentTopology D) (e.inverse.op ⋙ F) := by\n  refine ⟨fun hF ↦ ((e.sheafCongrPrecoherent A).functor.obj ⟨F, hF⟩).cond, fun hF ↦ ?_⟩\n  rw [isSheaf_of_iso_iff (P' := e.functor.op ⋙ e.inverse.op ⋙ F)]\n  · exact (e.sheafCongrPrecoherent A).inverse.obj ⟨e.inverse.op ⋙ F, hF⟩ |>.cond\n  · exact isoWhiskerRight e.op.unitIso F\n\n"}
{"name":"CategoryTheory.Equivalence.precoherent_isSheaf_iff_of_essentiallySmall","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_5, u_1} C\ninst✝² : CategoryTheory.Precoherent C\nA : Type u_3\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} A\ninst✝ : CategoryTheory.EssentiallySmall.{u_4, u_5, u_1} C\nF : CategoryTheory.Functor (Opposite C) A\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology C) F) (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology (CategoryTheory.SmallModel.{u_4, u_5, u_1} C)) ((CategoryTheory.equivSmallModel C).inverse.op.comp F))","decl":"/--\nThe coherent sheaf condition on an essentially small site can be checked after precomposing with\nthe equivalence with a small category.\n-/\ntheorem precoherent_isSheaf_iff_of_essentiallySmall [EssentiallySmall C] (F : Cᵒᵖ ⥤ A) :\n    IsSheaf (coherentTopology C) F ↔\n      IsSheaf (coherentTopology (SmallModel C)) ((equivSmallModel C).inverse.op ⋙ F) :=\n  precoherent_isSheaf_iff _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.preregular","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝ : CategoryTheory.Preregular C\ne : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.Preregular D","decl":"/-- `Preregular` is preserved by equivalence of categories. -/\ntheorem preregular (e : C ≌ D) : Preregular D := e.inverse.reflects_preregular\n\n"}
{"name":"CategoryTheory.Equivalence.instPreregularSmallModel","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Preregular C\ninst✝ : CategoryTheory.EssentiallySmall.{u_3, u_4, u_1} C\n⊢ CategoryTheory.Preregular (CategoryTheory.SmallModel.{u_3, u_4, u_1} C)","decl":"instance [EssentiallySmall C] :\n    Preregular (SmallModel C) := (equivSmallModel C).preregular\n\n"}
{"name":"CategoryTheory.Equivalence.instIsDenseSubsiteRegularTopologyInverse","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝ : CategoryTheory.Preregular C\ne : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.Functor.IsDenseSubsite (CategoryTheory.regularTopology D) (CategoryTheory.regularTopology C) e.inverse","decl":"instance (e : C ≌ D) : haveI := preregular e\n    e.inverse.IsDenseSubsite (regularTopology D) (regularTopology C) where\n  functorPushforward_mem_iff := by\n    rw [regularTopology.eq_induced e.inverse]\n    simp only [Functor.mem_inducedTopology_sieves_iff, implies_true]\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPreregular_inverse_obj_val_map","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Preregular C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Sheaf (CategoryTheory.regularTopology D) A\nX✝ Y✝ : Opposite C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPreregular A e).inverse.obj F).val.map f) (F.val.map (e.functor.map f.unop).op)","decl":"/--\nEquivalent preregular categories give equivalent regular toposes.\n-/\n@[simps!]\ndef sheafCongrPreregular (e : C ≌ D) : haveI := e.preregular\n    Sheaf (regularTopology C) A ≌ Sheaf (regularTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPreregular_unitIso_inv_app_val_app","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Preregular C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nX✝ : CategoryTheory.Sheaf (CategoryTheory.regularTopology C) A\nX : Opposite C\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPreregular A e).unitIso.inv.app X✝).val.app X) (X✝.val.map (e.unitIso.hom.app (Opposite.unop X)).op)","decl":"/--\nEquivalent preregular categories give equivalent regular toposes.\n-/\n@[simps!]\ndef sheafCongrPreregular (e : C ≌ D) : haveI := e.preregular\n    Sheaf (regularTopology C) A ≌ Sheaf (regularTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPreregular_functor_map_val_app","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Preregular C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nX✝ Y✝ : CategoryTheory.Sheaf (CategoryTheory.regularTopology C) A\nf : Quiver.Hom X✝ Y✝\nX : Opposite D\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPreregular A e).functor.map f).val.app X) (f.val.app { unop := e.inverse.obj (Opposite.unop X) })","decl":"/--\nEquivalent preregular categories give equivalent regular toposes.\n-/\n@[simps!]\ndef sheafCongrPreregular (e : C ≌ D) : haveI := e.preregular\n    Sheaf (regularTopology C) A ≌ Sheaf (regularTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPreregular_inverse_map_val_app","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Preregular C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nX✝ Y✝ : CategoryTheory.Sheaf (CategoryTheory.regularTopology D) A\nf : Quiver.Hom X✝ Y✝\nX : Opposite C\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPreregular A e).inverse.map f).val.app X) (f.val.app { unop := e.functor.obj (Opposite.unop X) })","decl":"/--\nEquivalent preregular categories give equivalent regular toposes.\n-/\n@[simps!]\ndef sheafCongrPreregular (e : C ≌ D) : haveI := e.preregular\n    Sheaf (regularTopology C) A ≌ Sheaf (regularTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPreregular_functor_obj_val_map","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Preregular C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Sheaf (CategoryTheory.regularTopology C) A\nX✝ Y✝ : Opposite D\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPreregular A e).functor.obj F).val.map f) (F.val.map (e.inverse.map f.unop).op)","decl":"/--\nEquivalent preregular categories give equivalent regular toposes.\n-/\n@[simps!]\ndef sheafCongrPreregular (e : C ≌ D) : haveI := e.preregular\n    Sheaf (regularTopology C) A ≌ Sheaf (regularTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPreregular_counitIso_inv_app_val_app","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Preregular C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nX✝ : CategoryTheory.Sheaf (CategoryTheory.regularTopology D) A\nX : Opposite D\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPreregular A e).counitIso.inv.app X✝).val.app X) (X✝.val.map (e.counitIso.hom.app (Opposite.unop X)).op)","decl":"/--\nEquivalent preregular categories give equivalent regular toposes.\n-/\n@[simps!]\ndef sheafCongrPreregular (e : C ≌ D) : haveI := e.preregular\n    Sheaf (regularTopology C) A ≌ Sheaf (regularTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPreregular_inverse_obj_val_obj","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Preregular C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Sheaf (CategoryTheory.regularTopology D) A\nX : Opposite C\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPreregular A e).inverse.obj F).val.obj X) (F.val.obj { unop := e.functor.obj (Opposite.unop X) })","decl":"/--\nEquivalent preregular categories give equivalent regular toposes.\n-/\n@[simps!]\ndef sheafCongrPreregular (e : C ≌ D) : haveI := e.preregular\n    Sheaf (regularTopology C) A ≌ Sheaf (regularTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPreregular_counitIso_hom_app_val_app","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Preregular C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nX✝ : CategoryTheory.Sheaf (CategoryTheory.regularTopology D) A\nX : Opposite D\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPreregular A e).counitIso.hom.app X✝).val.app X) (X✝.val.map (e.counitIso.inv.app (Opposite.unop X)).op)","decl":"/--\nEquivalent preregular categories give equivalent regular toposes.\n-/\n@[simps!]\ndef sheafCongrPreregular (e : C ≌ D) : haveI := e.preregular\n    Sheaf (regularTopology C) A ≌ Sheaf (regularTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPreregular_unitIso_hom_app_val_app","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Preregular C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nX✝ : CategoryTheory.Sheaf (CategoryTheory.regularTopology C) A\nX : Opposite C\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPreregular A e).unitIso.hom.app X✝).val.app X) (X✝.val.map (e.unitIso.inv.app (Opposite.unop X)).op)","decl":"/--\nEquivalent preregular categories give equivalent regular toposes.\n-/\n@[simps!]\ndef sheafCongrPreregular (e : C ≌ D) : haveI := e.preregular\n    Sheaf (regularTopology C) A ≌ Sheaf (regularTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.sheafCongrPreregular_functor_obj_val_obj","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Preregular C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Sheaf (CategoryTheory.regularTopology C) A\nX : Opposite D\n⊢ Eq (((CategoryTheory.Equivalence.sheafCongrPreregular A e).functor.obj F).val.obj X) (F.val.obj { unop := e.inverse.obj (Opposite.unop X) })","decl":"/--\nEquivalent preregular categories give equivalent regular toposes.\n-/\n@[simps!]\ndef sheafCongrPreregular (e : C ≌ D) : haveI := e.preregular\n    Sheaf (regularTopology C) A ≌ Sheaf (regularTopology D) A := e.sheafCongr _ _ _\n\n"}
{"name":"CategoryTheory.Equivalence.preregular_isSheaf_iff","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹ : CategoryTheory.Preregular C\nA : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} A\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Functor (Opposite C) A\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.regularTopology C) F) (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.regularTopology D) (e.inverse.op.comp F))","decl":"/--\nThe regular sheaf condition can be checked after precomposing with the equivalence.\n-/\ntheorem preregular_isSheaf_iff (e : C ≌ D) (F : Cᵒᵖ ⥤ A) : haveI := e.preregular\n    IsSheaf (regularTopology C) F ↔ IsSheaf (regularTopology D) (e.inverse.op ⋙ F) := by\n  refine ⟨fun hF ↦ ((e.sheafCongrPreregular A).functor.obj ⟨F, hF⟩).cond, fun hF ↦ ?_⟩\n  rw [isSheaf_of_iso_iff (P' := e.functor.op ⋙ e.inverse.op ⋙ F)]\n  · exact (e.sheafCongrPreregular A).inverse.obj ⟨e.inverse.op ⋙ F, hF⟩ |>.cond\n  · exact isoWhiskerRight e.op.unitIso F\n\n"}
{"name":"CategoryTheory.Equivalence.preregular_isSheaf_iff_of_essentiallySmall","module":"Mathlib.CategoryTheory.Sites.Coherent.Equivalence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_5, u_1} C\ninst✝² : CategoryTheory.Preregular C\nA : Type u_3\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} A\ninst✝ : CategoryTheory.EssentiallySmall.{u_4, u_5, u_1} C\nF : CategoryTheory.Functor (Opposite C) A\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.regularTopology C) F) (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.regularTopology (CategoryTheory.SmallModel.{u_4, u_5, u_1} C)) ((CategoryTheory.equivSmallModel C).inverse.op.comp F))","decl":"/--\nThe regular sheaf condition on an essentially small site can be checked after precomposing with\nthe equivalence with a small category.\n-/\ntheorem preregular_isSheaf_iff_of_essentiallySmall [EssentiallySmall C] (F : Cᵒᵖ ⥤ A) :\n    IsSheaf (regularTopology C) F ↔ IsSheaf (regularTopology (SmallModel C))\n    ((equivSmallModel C).inverse.op ⋙ F) := preregular_isSheaf_iff _ _ _\n\n"}
