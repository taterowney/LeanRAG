{"name":"Prod.vadd_fst","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝¹ : VAdd M α\ninst✝ : VAdd M β\na : M\nx : Prod α β\n⊢ Eq (HVAdd.hVAdd a x).1 (HVAdd.hVAdd a x.1)","decl":"@[to_additive (attr := simp)] lemma smul_fst : (a • x).1 = a • x.1 := rfl\n\n"}
{"name":"Prod.smul_fst","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝¹ : SMul M α\ninst✝ : SMul M β\na : M\nx : Prod α β\n⊢ Eq (HSMul.hSMul a x).1 (HSMul.hSMul a x.1)","decl":"@[to_additive (attr := simp)] lemma smul_fst : (a • x).1 = a • x.1 := rfl\n\n"}
{"name":"Prod.smul_snd","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝¹ : SMul M α\ninst✝ : SMul M β\na : M\nx : Prod α β\n⊢ Eq (HSMul.hSMul a x).2 (HSMul.hSMul a x.2)","decl":"@[to_additive (attr := simp)] lemma smul_snd : (a • x).2 = a • x.2 := rfl\n\n"}
{"name":"Prod.vadd_snd","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝¹ : VAdd M α\ninst✝ : VAdd M β\na : M\nx : Prod α β\n⊢ Eq (HVAdd.hVAdd a x).2 (HVAdd.hVAdd a x.2)","decl":"@[to_additive (attr := simp)] lemma smul_snd : (a • x).2 = a • x.2 := rfl\n\n"}
{"name":"Prod.vadd_mk","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝¹ : VAdd M α\ninst✝ : VAdd M β\na : M\nb : α\nc : β\n⊢ Eq (HVAdd.hVAdd a { fst := b, snd := c }) { fst := HVAdd.hVAdd a b, snd := HVAdd.hVAdd a c }","decl":"@[to_additive (attr := simp)]\nlemma smul_mk (a : M) (b : α) (c : β) : a • (b, c) = (a • b, a • c) := rfl\n\n"}
{"name":"Prod.smul_mk","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝¹ : SMul M α\ninst✝ : SMul M β\na : M\nb : α\nc : β\n⊢ Eq (HSMul.hSMul a { fst := b, snd := c }) { fst := HSMul.hSMul a b, snd := HSMul.hSMul a c }","decl":"@[to_additive (attr := simp)]\nlemma smul_mk (a : M) (b : α) (c : β) : a • (b, c) = (a • b, a • c) := rfl\n\n"}
{"name":"Prod.vadd_def","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝¹ : VAdd M α\ninst✝ : VAdd M β\na : M\nx : Prod α β\n⊢ Eq (HVAdd.hVAdd a x) { fst := HVAdd.hVAdd a x.1, snd := HVAdd.hVAdd a x.2 }","decl":"@[to_additive]\nlemma smul_def (a : M) (x : α × β) : a • x = (a • x.1, a • x.2) := rfl\n\n"}
{"name":"Prod.smul_def","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝¹ : SMul M α\ninst✝ : SMul M β\na : M\nx : Prod α β\n⊢ Eq (HSMul.hSMul a x) { fst := HSMul.hSMul a x.1, snd := HSMul.hSMul a x.2 }","decl":"@[to_additive]\nlemma smul_def (a : M) (x : α × β) : a • x = (a • x.1, a • x.2) := rfl\n\n"}
{"name":"Prod.vadd_swap","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝¹ : VAdd M α\ninst✝ : VAdd M β\na : M\nx : Prod α β\n⊢ Eq (HVAdd.hVAdd a x).swap (HVAdd.hVAdd a x.swap)","decl":"@[to_additive (attr := simp)] lemma smul_swap : (a • x).swap = a • x.swap := rfl\n\n"}
{"name":"Prod.smul_swap","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝¹ : SMul M α\ninst✝ : SMul M β\na : M\nx : Prod α β\n⊢ Eq (HSMul.hSMul a x).swap (HSMul.hSMul a x.swap)","decl":"@[to_additive (attr := simp)] lemma smul_swap : (a • x).swap = a • x.swap := rfl\n\n"}
{"name":"Prod.pow_fst","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"E : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝¹ : Pow α E\ninst✝ : Pow β E\np : Prod α β\nc : E\n⊢ Eq (HPow.hPow p c).1 (HPow.hPow p.1 c)","decl":"@[to_additive existing (attr := simp) (reorder := 6 7) smul_fst]\nlemma pow_fst (p : α × β) (c : E) : (p ^ c).fst = p.fst ^ c := rfl\n\n"}
{"name":"Prod.pow_snd","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"E : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝¹ : Pow α E\ninst✝ : Pow β E\np : Prod α β\nc : E\n⊢ Eq (HPow.hPow p c).2 (HPow.hPow p.2 c)","decl":"@[to_additive existing (attr := simp) (reorder := 6 7) smul_snd]\nlemma pow_snd (p : α × β) (c : E) : (p ^ c).snd = p.snd ^ c := rfl\n\n/- Note that the `c` arguments to this lemmas cannot be in the more natural right-most positions due\nto limitations in `to_additive` and `to_additive_reorder`, which will silently fail to reorder more\nthan two adjacent arguments -/\n"}
{"name":"Prod.pow_mk","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"E : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝¹ : Pow α E\ninst✝ : Pow β E\nc : E\na : α\nb : β\n⊢ Eq (HPow.hPow { fst := a, snd := b } c) { fst := HPow.hPow a c, snd := HPow.hPow b c }","decl":"@[to_additive existing (attr := simp) (reorder := 6 7) smul_mk]\nlemma pow_mk (c : E) (a : α) (b : β) : Prod.mk a b ^ c = Prod.mk (a ^ c) (b ^ c) := rfl\n\n"}
{"name":"Prod.pow_def","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"E : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝¹ : Pow α E\ninst✝ : Pow β E\np : Prod α β\nc : E\n⊢ Eq (HPow.hPow p c) { fst := HPow.hPow p.1 c, snd := HPow.hPow p.2 c }","decl":"@[to_additive existing (reorder := 6 7) smul_def]\nlemma pow_def (p : α × β) (c : E) : p ^ c = (p.1 ^ c, p.2 ^ c) := rfl\n\n"}
{"name":"Prod.pow_swap","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"E : Type u_4\nα : Type u_5\nβ : Type u_6\ninst✝¹ : Pow α E\ninst✝ : Pow β E\np : Prod α β\nc : E\n⊢ Eq (HPow.hPow p c).swap (HPow.hPow p.swap c)","decl":"@[to_additive existing (attr := simp) (reorder := 6 7) smul_swap]\nlemma pow_swap (p : α × β) (c : E) : (p ^ c).swap = p.swap ^ c := rfl\n\n"}
{"name":"Prod.isScalarTower","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁶ : SMul M α\ninst✝⁵ : SMul M β\ninst✝⁴ : SMul N α\ninst✝³ : SMul N β\ninst✝² : SMul M N\ninst✝¹ : IsScalarTower M N α\ninst✝ : IsScalarTower M N β\n⊢ IsScalarTower M N (Prod α β)","decl":"@[to_additive vaddAssocClass]\ninstance isScalarTower [SMul M N] [IsScalarTower M N α] [IsScalarTower M N β] :\n    IsScalarTower M N (α × β) where\n  smul_assoc _ _ _ := mk.inj_iff.mpr ⟨smul_assoc _ _ _, smul_assoc _ _ _⟩\n\n"}
{"name":"Prod.vaddAssocClass","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁶ : VAdd M α\ninst✝⁵ : VAdd M β\ninst✝⁴ : VAdd N α\ninst✝³ : VAdd N β\ninst✝² : VAdd M N\ninst✝¹ : VAddAssocClass M N α\ninst✝ : VAddAssocClass M N β\n⊢ VAddAssocClass M N (Prod α β)","decl":"@[to_additive vaddAssocClass]\ninstance isScalarTower [SMul M N] [IsScalarTower M N α] [IsScalarTower M N β] :\n    IsScalarTower M N (α × β) where\n  smul_assoc _ _ _ := mk.inj_iff.mpr ⟨smul_assoc _ _ _, smul_assoc _ _ _⟩\n\n"}
{"name":"Prod.vaddCommClass","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁵ : VAdd M α\ninst✝⁴ : VAdd M β\ninst✝³ : VAdd N α\ninst✝² : VAdd N β\ninst✝¹ : VAddCommClass M N α\ninst✝ : VAddCommClass M N β\n⊢ VAddCommClass M N (Prod α β)","decl":"@[to_additive]\ninstance smulCommClass [SMulCommClass M N α] [SMulCommClass M N β] : SMulCommClass M N (α × β) where\n  smul_comm _ _ _ := mk.inj_iff.mpr ⟨smul_comm _ _ _, smul_comm _ _ _⟩\n\n"}
{"name":"Prod.smulCommClass","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁵ : SMul M α\ninst✝⁴ : SMul M β\ninst✝³ : SMul N α\ninst✝² : SMul N β\ninst✝¹ : SMulCommClass M N α\ninst✝ : SMulCommClass M N β\n⊢ SMulCommClass M N (Prod α β)","decl":"@[to_additive]\ninstance smulCommClass [SMulCommClass M N α] [SMulCommClass M N β] : SMulCommClass M N (α × β) where\n  smul_comm _ _ _ := mk.inj_iff.mpr ⟨smul_comm _ _ _, smul_comm _ _ _⟩\n\n"}
{"name":"Prod.isCentralScalar","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝⁵ : SMul M α\ninst✝⁴ : SMul M β\ninst✝³ : SMul (MulOpposite M) α\ninst✝² : SMul (MulOpposite M) β\ninst✝¹ : IsCentralScalar M α\ninst✝ : IsCentralScalar M β\n⊢ IsCentralScalar M (Prod α β)","decl":"@[to_additive]\ninstance isCentralScalar [SMul Mᵐᵒᵖ α] [SMul Mᵐᵒᵖ β] [IsCentralScalar M α] [IsCentralScalar M β] :\n    IsCentralScalar M (α × β) where\n  op_smul_eq_smul _ _ := Prod.ext (op_smul_eq_smul _ _) (op_smul_eq_smul _ _)\n\n"}
{"name":"Prod.isCentralVAdd","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝⁵ : VAdd M α\ninst✝⁴ : VAdd M β\ninst✝³ : VAdd (AddOpposite M) α\ninst✝² : VAdd (AddOpposite M) β\ninst✝¹ : IsCentralVAdd M α\ninst✝ : IsCentralVAdd M β\n⊢ IsCentralVAdd M (Prod α β)","decl":"@[to_additive]\ninstance isCentralScalar [SMul Mᵐᵒᵖ α] [SMul Mᵐᵒᵖ β] [IsCentralScalar M α] [IsCentralScalar M β] :\n    IsCentralScalar M (α × β) where\n  op_smul_eq_smul _ _ := Prod.ext (op_smul_eq_smul _ _) (op_smul_eq_smul _ _)\n\n"}
{"name":"Prod.faithfulVAddLeft","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝³ : VAdd M α\ninst✝² : VAdd M β\ninst✝¹ : FaithfulVAdd M α\ninst✝ : Nonempty β\n⊢ FaithfulVAdd M (Prod α β)","decl":"@[to_additive]\ninstance faithfulSMulLeft [FaithfulSMul M α] [Nonempty β] : FaithfulSMul M (α × β) where\n  eq_of_smul_eq_smul h :=\n    let ⟨b⟩ := ‹Nonempty β›\n    eq_of_smul_eq_smul fun a : α => by injection h (a, b)\n\n"}
{"name":"Prod.faithfulSMulLeft","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝³ : SMul M α\ninst✝² : SMul M β\ninst✝¹ : FaithfulSMul M α\ninst✝ : Nonempty β\n⊢ FaithfulSMul M (Prod α β)","decl":"@[to_additive]\ninstance faithfulSMulLeft [FaithfulSMul M α] [Nonempty β] : FaithfulSMul M (α × β) where\n  eq_of_smul_eq_smul h :=\n    let ⟨b⟩ := ‹Nonempty β›\n    eq_of_smul_eq_smul fun a : α => by injection h (a, b)\n\n"}
{"name":"Prod.faithfulVAddRight","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝³ : VAdd M α\ninst✝² : VAdd M β\ninst✝¹ : Nonempty α\ninst✝ : FaithfulVAdd M β\n⊢ FaithfulVAdd M (Prod α β)","decl":"@[to_additive]\ninstance faithfulSMulRight [Nonempty α] [FaithfulSMul M β] : FaithfulSMul M (α × β) where\n  eq_of_smul_eq_smul h :=\n    let ⟨a⟩ := ‹Nonempty α›\n    eq_of_smul_eq_smul fun b : β => by injection h (a, b)\n\n"}
{"name":"Prod.faithfulSMulRight","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nα : Type u_5\nβ : Type u_6\ninst✝³ : SMul M α\ninst✝² : SMul M β\ninst✝¹ : Nonempty α\ninst✝ : FaithfulSMul M β\n⊢ FaithfulSMul M (Prod α β)","decl":"@[to_additive]\ninstance faithfulSMulRight [Nonempty α] [FaithfulSMul M β] : FaithfulSMul M (α × β) where\n  eq_of_smul_eq_smul h :=\n    let ⟨a⟩ := ‹Nonempty α›\n    eq_of_smul_eq_smul fun b : β => by injection h (a, b)\n\n"}
{"name":"Prod.smulCommClassBoth","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝⁵ : Mul N\ninst✝⁴ : Mul P\ninst✝³ : SMul M N\ninst✝² : SMul M P\ninst✝¹ : SMulCommClass M N N\ninst✝ : SMulCommClass M P P\n⊢ SMulCommClass M (Prod N P) (Prod N P)","decl":"@[to_additive]\ninstance smulCommClassBoth [Mul N] [Mul P] [SMul M N] [SMul M P] [SMulCommClass M N N]\n    [SMulCommClass M P P] : SMulCommClass M (N × P) (N × P) where\n  smul_comm c x y := by simp [smul_def, mul_def, mul_smul_comm]\n\n"}
{"name":"Prod.vaddCommClassBoth","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝⁵ : Add N\ninst✝⁴ : Add P\ninst✝³ : VAdd M N\ninst✝² : VAdd M P\ninst✝¹ : VAddCommClass M N N\ninst✝ : VAddCommClass M P P\n⊢ VAddCommClass M (Prod N P) (Prod N P)","decl":"@[to_additive]\ninstance smulCommClassBoth [Mul N] [Mul P] [SMul M N] [SMul M P] [SMulCommClass M N N]\n    [SMulCommClass M P P] : SMulCommClass M (N × P) (N × P) where\n  smul_comm c x y := by simp [smul_def, mul_def, mul_smul_comm]\n\n"}
{"name":"Prod.isScalarTowerBoth","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝⁵ : Mul N\ninst✝⁴ : Mul P\ninst✝³ : SMul M N\ninst✝² : SMul M P\ninst✝¹ : IsScalarTower M N N\ninst✝ : IsScalarTower M P P\n⊢ IsScalarTower M (Prod N P) (Prod N P)","decl":"instance isScalarTowerBoth [Mul N] [Mul P] [SMul M N] [SMul M P] [IsScalarTower M N N]\n    [IsScalarTower M P P] : IsScalarTower M (N × P) (N × P) where\n  smul_assoc c x y := by simp [smul_def, mul_def, smul_mul_assoc]\n\n"}
{"name":"smulMulHom_apply","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝⁴ : Monoid α\ninst✝³ : Mul β\ninst✝² : MulAction α β\ninst✝¹ : IsScalarTower α β β\ninst✝ : SMulCommClass α β β\na : Prod α β\n⊢ Eq (smulMulHom a) (HSMul.hSMul a.1 a.2)","decl":"/-- Scalar multiplication as a multiplicative homomorphism. -/\n@[simps]\ndef smulMulHom [Monoid α] [Mul β] [MulAction α β] [IsScalarTower α β β] [SMulCommClass α β β] :\n    α × β →ₙ* β where\n  toFun a := a.1 • a.2\n  map_mul' _ _ := (smul_mul_smul_comm _ _ _ _).symm\n\n"}
{"name":"smulMonoidHom_apply","module":"Mathlib.Algebra.Group.Action.Prod","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝⁴ : Monoid α\ninst✝³ : MulOneClass β\ninst✝² : MulAction α β\ninst✝¹ : IsScalarTower α β β\ninst✝ : SMulCommClass α β β\na✝ : Prod α β\n⊢ Eq (smulMonoidHom a✝) (smulMulHom.toFun a✝)","decl":"/-- Scalar multiplication as a monoid homomorphism. -/\n@[simps]\ndef smulMonoidHom [Monoid α] [MulOneClass β] [MulAction α β] [IsScalarTower α β β]\n    [SMulCommClass α β β] : α × β →* β :=\n  { smulMulHom with map_one' := one_smul _ _ }\n\n"}
