{"name":"CategoryTheory.Limits.WalkingParallelPair.ofNat_toCtorIdx","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"x : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq (CategoryTheory.Limits.WalkingParallelPair.ofNat x.toCtorIdx) x","decl":"/-- The type of objects for the diagram indexing a (co)equalizer. -/\ninductive WalkingParallelPair : Type\n  | zero\n  | one\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPair.one.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"‚ä¢ Eq (SizeOf.sizeOf CategoryTheory.Limits.WalkingParallelPair.one) 1","decl":"/-- The type of objects for the diagram indexing a (co)equalizer. -/\ninductive WalkingParallelPair : Type\n  | zero\n  | one\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPair.zero.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"‚ä¢ Eq (SizeOf.sizeOf CategoryTheory.Limits.WalkingParallelPair.zero) 1","decl":"/-- The type of objects for the diagram indexing a (co)equalizer. -/\ninductive WalkingParallelPair : Type\n  | zero\n  | one\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPairHom.id_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"X Y : CategoryTheory.Limits.WalkingParallelPair\ng : CategoryTheory.Limits.WalkingParallelPairHom X Y\n‚ä¢ Eq ((CategoryTheory.Limits.WalkingParallelPairHom.id X).comp g) g","decl":"theorem WalkingParallelPairHom.id_comp\n    {X Y : WalkingParallelPair} (g : WalkingParallelPairHom X Y) : comp (id X) g = g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPairHom.comp_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"X Y : CategoryTheory.Limits.WalkingParallelPair\nf : CategoryTheory.Limits.WalkingParallelPairHom X Y\n‚ä¢ Eq (f.comp (CategoryTheory.Limits.WalkingParallelPairHom.id Y)) f","decl":"theorem WalkingParallelPairHom.comp_id\n    {X Y : WalkingParallelPair} (f : WalkingParallelPairHom X Y) : comp f (id Y) = f := by\n  cases f <;> rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPairHom.assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"X Y Z W : CategoryTheory.Limits.WalkingParallelPair\nf : CategoryTheory.Limits.WalkingParallelPairHom X Y\ng : CategoryTheory.Limits.WalkingParallelPairHom Y Z\nh : CategoryTheory.Limits.WalkingParallelPairHom Z W\n‚ä¢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"theorem WalkingParallelPairHom.assoc {X Y Z W : WalkingParallelPair}\n    (f : WalkingParallelPairHom X Y) (g : WalkingParallelPairHom Y Z)\n    (h : WalkingParallelPairHom Z W) : comp (comp f g) h = comp f (comp g h) := by\n  cases f <;> cases g <;> cases h <;> rfl\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelPairHom_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"X : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq (CategoryTheory.Limits.WalkingParallelPairHom.id X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem walkingParallelPairHom_id (X : WalkingParallelPair) : WalkingParallelPairHom.id X = ùüô X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelPairOp_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.walkingParallelPairOp.obj CategoryTheory.Limits.WalkingParallelPair.zero) { unop := CategoryTheory.Limits.WalkingParallelPair.one }","decl":"@[simp]\ntheorem walkingParallelPairOp_zero : walkingParallelPairOp.obj zero = op one := rfl\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelPairOp_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.walkingParallelPairOp.obj CategoryTheory.Limits.WalkingParallelPair.one) { unop := CategoryTheory.Limits.WalkingParallelPair.zero }","decl":"@[simp]\ntheorem walkingParallelPairOp_one : walkingParallelPairOp.obj one = op zero := rfl\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelPairOp_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.walkingParallelPairOp.map CategoryTheory.Limits.WalkingParallelPairHom.left) (Quiver.Hom.op CategoryTheory.Limits.WalkingParallelPairHom.left)","decl":"@[simp]\ntheorem walkingParallelPairOp_left :\n    walkingParallelPairOp.map left = @Quiver.Hom.op _ _ zero one left := rfl\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelPairOp_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.walkingParallelPairOp.map CategoryTheory.Limits.WalkingParallelPairHom.right) (Quiver.Hom.op CategoryTheory.Limits.WalkingParallelPairHom.right)","decl":"@[simp]\ntheorem walkingParallelPairOp_right :\n    walkingParallelPairOp.map right = @Quiver.Hom.op _ _ zero one right := rfl\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelPairOpEquiv_inverse","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"‚ä¢ Eq CategoryTheory.Limits.walkingParallelPairOpEquiv.inverse CategoryTheory.Limits.walkingParallelPairOp.leftOp","decl":"/--\nThe equivalence `WalkingParallelPair ‚•§ WalkingParallelPair·µí·µñ` sending left to left and right to\nright.\n-/\n@[simps functor inverse]\ndef walkingParallelPairOpEquiv : WalkingParallelPair ‚âå WalkingParallelPair·µí·µñ where\n  functor := walkingParallelPairOp\n  inverse := walkingParallelPairOp.leftOp\n  unitIso :=\n    NatIso.ofComponents (fun j => eqToIso (by cases j <;> rfl))\n      (by rintro _ _ (_ | _ | _) <;> simp)\n  counitIso :=\n    NatIso.ofComponents (fun j => eqToIso (by\n            induction' j with X\n            cases X <;> rfl))\n      (fun {i} {j} f => by\n      induction' i with i\n      induction' j with j\n      let g := f.unop\n      have : f = g.op := rfl\n      rw [this]\n      cases i <;> cases j <;> cases g <;> rfl)\n  functor_unitIso_comp := fun j => by cases j <;> rfl\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelPairOpEquiv_functor","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"‚ä¢ Eq CategoryTheory.Limits.walkingParallelPairOpEquiv.functor CategoryTheory.Limits.walkingParallelPairOp","decl":"/--\nThe equivalence `WalkingParallelPair ‚•§ WalkingParallelPair·µí·µñ` sending left to left and right to\nright.\n-/\n@[simps functor inverse]\ndef walkingParallelPairOpEquiv : WalkingParallelPair ‚âå WalkingParallelPair·µí·µñ where\n  functor := walkingParallelPairOp\n  inverse := walkingParallelPairOp.leftOp\n  unitIso :=\n    NatIso.ofComponents (fun j => eqToIso (by cases j <;> rfl))\n      (by rintro _ _ (_ | _ | _) <;> simp)\n  counitIso :=\n    NatIso.ofComponents (fun j => eqToIso (by\n            induction' j with X\n            cases X <;> rfl))\n      (fun {i} {j} f => by\n      induction' i with i\n      induction' j with j\n      let g := f.unop\n      have : f = g.op := rfl\n      rw [this]\n      cases i <;> cases j <;> cases g <;> rfl)\n  functor_unitIso_comp := fun j => by cases j <;> rfl\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelPairOpEquiv_unitIso_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.walkingParallelPairOpEquiv.unitIso.app CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.Iso.refl CategoryTheory.Limits.WalkingParallelPair.zero)","decl":"@[simp]\ntheorem walkingParallelPairOpEquiv_unitIso_zero :\n    walkingParallelPairOpEquiv.unitIso.app zero = Iso.refl zero := rfl\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelPairOpEquiv_unitIso_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.walkingParallelPairOpEquiv.unitIso.app CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.Iso.refl CategoryTheory.Limits.WalkingParallelPair.one)","decl":"@[simp]\ntheorem walkingParallelPairOpEquiv_unitIso_one :\n    walkingParallelPairOpEquiv.unitIso.app one = Iso.refl one := rfl\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelPairOpEquiv_counitIso_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.walkingParallelPairOpEquiv.counitIso.app { unop := CategoryTheory.Limits.WalkingParallelPair.zero }) (CategoryTheory.Iso.refl { unop := CategoryTheory.Limits.WalkingParallelPair.zero })","decl":"@[simp]\ntheorem walkingParallelPairOpEquiv_counitIso_zero :\n    walkingParallelPairOpEquiv.counitIso.app (op zero) = Iso.refl (op zero) := rfl\n\n"}
{"name":"CategoryTheory.Limits.walkingParallelPairOpEquiv_counitIso_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"‚ä¢ Eq (CategoryTheory.Limits.walkingParallelPairOpEquiv.counitIso.app { unop := CategoryTheory.Limits.WalkingParallelPair.one }) (CategoryTheory.Iso.refl { unop := CategoryTheory.Limits.WalkingParallelPair.one })","decl":"@[simp]\ntheorem walkingParallelPairOpEquiv_counitIso_one :\n    walkingParallelPairOpEquiv.counitIso.app (op one) = Iso.refl (op one) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.parallelPair_obj_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Limits.parallelPair f g).obj CategoryTheory.Limits.WalkingParallelPair.zero) X","decl":"@[simp]\ntheorem parallelPair_obj_zero (f g : X ‚ü∂ Y) : (parallelPair f g).obj zero = X := rfl\n\n"}
{"name":"CategoryTheory.Limits.parallelPair_obj_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Limits.parallelPair f g).obj CategoryTheory.Limits.WalkingParallelPair.one) Y","decl":"@[simp]\ntheorem parallelPair_obj_one (f g : X ‚ü∂ Y) : (parallelPair f g).obj one = Y := rfl\n\n"}
{"name":"CategoryTheory.Limits.parallelPair_map_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Limits.parallelPair f g).map CategoryTheory.Limits.WalkingParallelPairHom.left) f","decl":"@[simp]\ntheorem parallelPair_map_left (f g : X ‚ü∂ Y) : (parallelPair f g).map left = f := rfl\n\n"}
{"name":"CategoryTheory.Limits.parallelPair_map_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Limits.parallelPair f g).map CategoryTheory.Limits.WalkingParallelPairHom.right) g","decl":"@[simp]\ntheorem parallelPair_map_right (f g : X ‚ü∂ Y) : (parallelPair f g).map right = g := rfl\n\n"}
{"name":"CategoryTheory.Limits.parallelPair_functor_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C\nj : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.parallelPair (F.map CategoryTheory.Limits.WalkingParallelPairHom.left) (F.map CategoryTheory.Limits.WalkingParallelPairHom.right)).obj j) (F.obj j)","decl":"@[simp]\ntheorem parallelPair_functor_obj {F : WalkingParallelPair ‚•§ C} (j : WalkingParallelPair) :\n    (parallelPair (F.map left) (F.map right)).obj j = F.obj j := by cases j <;> rfl\n\n"}
{"name":"CategoryTheory.Limits.diagramIsoParallelPair_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C\nX : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.diagramIsoParallelPair F).hom.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- Every functor indexing a (co)equalizer is naturally isomorphic (actually, equal) to a\n    `parallelPair` -/\n@[simps!]\ndef diagramIsoParallelPair (F : WalkingParallelPair ‚•§ C) :\n    F ‚âÖ parallelPair (F.map left) (F.map right) :=\n  NatIso.ofComponents (fun j => eqToIso <| by cases j <;> rfl) (by rintro _ _ (_|_|_) <;> simp)\n\n"}
{"name":"CategoryTheory.Limits.diagramIsoParallelPair_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C\nX : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.diagramIsoParallelPair F).inv.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- Every functor indexing a (co)equalizer is naturally isomorphic (actually, equal) to a\n    `parallelPair` -/\n@[simps!]\ndef diagramIsoParallelPair (F : WalkingParallelPair ‚•§ C) :\n    F ‚âÖ parallelPair (F.map left) (F.map right) :=\n  NatIso.ofComponents (fun j => eqToIso <| by cases j <;> rfl) (by rintro _ _ (_|_|_) <;> simp)\n\n"}
{"name":"CategoryTheory.Limits.parallelPairHom_app_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y X' Y' : C\nf g : Quiver.Hom X Y\nf' g' : Quiver.Hom X' Y'\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nwf : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p f')\nwg : Eq (CategoryTheory.CategoryStruct.comp g q) (CategoryTheory.CategoryStruct.comp p g')\n‚ä¢ Eq ((CategoryTheory.Limits.parallelPairHom f g f' g' p q wf wg).app CategoryTheory.Limits.WalkingParallelPair.zero) p","decl":"@[simp]\ntheorem parallelPairHom_app_zero {X' Y' : C} (f g : X ‚ü∂ Y) (f' g' : X' ‚ü∂ Y') (p : X ‚ü∂ X')\n    (q : Y ‚ü∂ Y') (wf : f ‚â´ q = p ‚â´ f') (wg : g ‚â´ q = p ‚â´ g') :\n    (parallelPairHom f g f' g' p q wf wg).app zero = p :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.parallelPairHom_app_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y X' Y' : C\nf g : Quiver.Hom X Y\nf' g' : Quiver.Hom X' Y'\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nwf : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p f')\nwg : Eq (CategoryTheory.CategoryStruct.comp g q) (CategoryTheory.CategoryStruct.comp p g')\n‚ä¢ Eq ((CategoryTheory.Limits.parallelPairHom f g f' g' p q wf wg).app CategoryTheory.Limits.WalkingParallelPair.one) q","decl":"@[simp]\ntheorem parallelPairHom_app_one {X' Y' : C} (f g : X ‚ü∂ Y) (f' g' : X' ‚ü∂ Y') (p : X ‚ü∂ X')\n    (q : Y ‚ü∂ Y') (wf : f ‚â´ q = p ‚â´ f') (wg : g ‚â´ q = p ‚â´ g') :\n    (parallelPairHom f g f' g' p q wf wg).app one = q :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.parallelPair.ext_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C\nzero : CategoryTheory.Iso (F.obj CategoryTheory.Limits.WalkingParallelPair.zero) (G.obj CategoryTheory.Limits.WalkingParallelPair.zero)\none : CategoryTheory.Iso (F.obj CategoryTheory.Limits.WalkingParallelPair.one) (G.obj CategoryTheory.Limits.WalkingParallelPair.one)\nleft : Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingParallelPairHom.left) one.hom) (CategoryTheory.CategoryStruct.comp zero.hom (G.map CategoryTheory.Limits.WalkingParallelPairHom.left))\nright : Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingParallelPairHom.right) one.hom) (CategoryTheory.CategoryStruct.comp zero.hom (G.map CategoryTheory.Limits.WalkingParallelPairHom.right))\nX : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.parallelPair.ext zero one left right).hom.app X) (CategoryTheory.Limits.WalkingParallelPair.rec zero one X).hom","decl":"/-- Construct a natural isomorphism between functors out of the walking parallel pair from\nits components. -/\n@[simps!]\ndef parallelPair.ext {F G : WalkingParallelPair ‚•§ C} (zero : F.obj zero ‚âÖ G.obj zero)\n    (one : F.obj one ‚âÖ G.obj one) (left : F.map left ‚â´ one.hom = zero.hom ‚â´ G.map left)\n    (right : F.map right ‚â´ one.hom = zero.hom ‚â´ G.map right) : F ‚âÖ G :=\n  NatIso.ofComponents\n    (by\n      rintro ‚ü®j‚ü©\n      exacts [zero, one])\n    (by rintro _ _ ‚ü®_‚ü© <;> simp [left, right])\n\n"}
{"name":"CategoryTheory.Limits.parallelPair.ext_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C\nzero : CategoryTheory.Iso (F.obj CategoryTheory.Limits.WalkingParallelPair.zero) (G.obj CategoryTheory.Limits.WalkingParallelPair.zero)\none : CategoryTheory.Iso (F.obj CategoryTheory.Limits.WalkingParallelPair.one) (G.obj CategoryTheory.Limits.WalkingParallelPair.one)\nleft : Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingParallelPairHom.left) one.hom) (CategoryTheory.CategoryStruct.comp zero.hom (G.map CategoryTheory.Limits.WalkingParallelPairHom.left))\nright : Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingParallelPairHom.right) one.hom) (CategoryTheory.CategoryStruct.comp zero.hom (G.map CategoryTheory.Limits.WalkingParallelPairHom.right))\nX : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.parallelPair.ext zero one left right).inv.app X) (CategoryTheory.Limits.WalkingParallelPair.rec zero one X).inv","decl":"/-- Construct a natural isomorphism between functors out of the walking parallel pair from\nits components. -/\n@[simps!]\ndef parallelPair.ext {F G : WalkingParallelPair ‚•§ C} (zero : F.obj zero ‚âÖ G.obj zero)\n    (one : F.obj one ‚âÖ G.obj one) (left : F.map left ‚â´ one.hom = zero.hom ‚â´ G.map left)\n    (right : F.map right ‚â´ one.hom = zero.hom ‚â´ G.map right) : F ‚âÖ G :=\n  NatIso.ofComponents\n    (by\n      rintro ‚ü®j‚ü©\n      exacts [zero, one])\n    (by rintro _ _ ‚ü®_‚ü© <;> simp [left, right])\n\n"}
{"name":"CategoryTheory.Limits.parallelPair.eqOfHomEq_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y : C\nf g f' g' : Quiver.Hom X‚úù Y\nhf : Eq f f'\nhg : Eq g g'\nX : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.parallelPair.eqOfHomEq hf hg).hom.app X) (CategoryTheory.Limits.WalkingParallelPair.rec (CategoryTheory.Iso.refl X‚úù) (CategoryTheory.Iso.refl Y) X).hom","decl":"/-- Construct a natural isomorphism between `parallelPair f g` and `parallelPair f' g'` given\nequalities `f = f'` and `g = g'`. -/\n@[simps!]\ndef parallelPair.eqOfHomEq {f g f' g' : X ‚ü∂ Y} (hf : f = f') (hg : g = g') :\n    parallelPair f g ‚âÖ parallelPair f' g' :=\n  parallelPair.ext (Iso.refl _) (Iso.refl _) (by simp [hf]) (by simp [hg])\n\n"}
{"name":"CategoryTheory.Limits.parallelPair.eqOfHomEq_inv_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y : C\nf g f' g' : Quiver.Hom X‚úù Y\nhf : Eq f f'\nhg : Eq g g'\nX : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.parallelPair.eqOfHomEq hf hg).inv.app X) (CategoryTheory.Limits.WalkingParallelPair.rec (CategoryTheory.Iso.refl X‚úù) (CategoryTheory.Iso.refl Y) X).inv","decl":"/-- Construct a natural isomorphism between `parallelPair f g` and `parallelPair f' g'` given\nequalities `f = f'` and `g = g'`. -/\n@[simps!]\ndef parallelPair.eqOfHomEq {f g f' g' : X ‚ü∂ Y} (hf : f = f') (hg : g = g') :\n    parallelPair f g ‚âÖ parallelPair f' g' :=\n  parallelPair.ext (Iso.refl _) (Iso.refl _) (by simp [hf]) (by simp [hg])\n\n"}
{"name":"CategoryTheory.Limits.Fork.app_zero_eq_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Fork f g\n‚ä¢ Eq (t.œÄ.app CategoryTheory.Limits.WalkingParallelPair.zero) t.Œπ","decl":"@[simp]\ntheorem Fork.app_zero_eq_Œπ (t : Fork f g) : t.œÄ.app zero = t.Œπ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Cofork.app_one_eq_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Cofork f g\n‚ä¢ Eq (t.Œπ.app CategoryTheory.Limits.WalkingParallelPair.one) t.œÄ","decl":"@[simp]\ntheorem Cofork.app_one_eq_œÄ (t : Cofork f g) : t.Œπ.app one = t.œÄ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Fork.app_one_eq_Œπ_comp_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Fork f g\n‚ä¢ Eq (s.œÄ.app CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.CategoryStruct.comp s.Œπ f)","decl":"@[simp]\ntheorem Fork.app_one_eq_Œπ_comp_left (s : Fork f g) : s.œÄ.app one = s.Œπ ‚â´ f := by\n  rw [‚Üê s.app_zero_eq_Œπ, ‚Üê s.w left, parallelPair_map_left]\n\n"}
{"name":"CategoryTheory.Limits.Fork.app_one_eq_Œπ_comp_right_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Fork f g\nZ : C\nh : Quiver.Hom ((CategoryTheory.Limits.parallelPair f g).obj CategoryTheory.Limits.WalkingParallelPair.one) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (s.œÄ.app CategoryTheory.Limits.WalkingParallelPair.one) h) (CategoryTheory.CategoryStruct.comp s.Œπ (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\ntheorem Fork.app_one_eq_Œπ_comp_right (s : Fork f g) : s.œÄ.app one = s.Œπ ‚â´ g := by\n  rw [‚Üê s.app_zero_eq_Œπ, ‚Üê s.w right, parallelPair_map_right]\n\n"}
{"name":"CategoryTheory.Limits.Fork.app_one_eq_Œπ_comp_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Fork f g\n‚ä¢ Eq (s.œÄ.app CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.CategoryStruct.comp s.Œπ g)","decl":"@[reassoc]\ntheorem Fork.app_one_eq_Œπ_comp_right (s : Fork f g) : s.œÄ.app one = s.Œπ ‚â´ g := by\n  rw [‚Üê s.app_zero_eq_Œπ, ‚Üê s.w right, parallelPair_map_right]\n\n"}
{"name":"CategoryTheory.Limits.Cofork.app_zero_eq_comp_œÄ_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Cofork f g\n‚ä¢ Eq (s.Œπ.app CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.CategoryStruct.comp f s.œÄ)","decl":"@[simp]\ntheorem Cofork.app_zero_eq_comp_œÄ_left (s : Cofork f g) : s.Œπ.app zero = f ‚â´ s.œÄ := by\n  rw [‚Üê s.app_one_eq_œÄ, ‚Üê s.w left, parallelPair_map_left]\n\n"}
{"name":"CategoryTheory.Limits.Cofork.app_zero_eq_comp_œÄ_right_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Cofork f g\nZ : C\nh : Quiver.Hom (((CategoryTheory.Functor.const CategoryTheory.Limits.WalkingParallelPair).obj s.pt).obj CategoryTheory.Limits.WalkingParallelPair.zero) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (s.Œπ.app CategoryTheory.Limits.WalkingParallelPair.zero) h) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp s.œÄ h))","decl":"@[reassoc]\ntheorem Cofork.app_zero_eq_comp_œÄ_right (s : Cofork f g) : s.Œπ.app zero = g ‚â´ s.œÄ := by\n  rw [‚Üê s.app_one_eq_œÄ, ‚Üê s.w right, parallelPair_map_right]\n\n"}
{"name":"CategoryTheory.Limits.Cofork.app_zero_eq_comp_œÄ_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Cofork f g\n‚ä¢ Eq (s.Œπ.app CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.CategoryStruct.comp g s.œÄ)","decl":"@[reassoc]\ntheorem Cofork.app_zero_eq_comp_œÄ_right (s : Cofork f g) : s.Œπ.app zero = g ‚â´ s.œÄ := by\n  rw [‚Üê s.app_one_eq_œÄ, ‚Üê s.w right, parallelPair_map_right]\n\n"}
{"name":"CategoryTheory.Limits.Fork.ofŒπ_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nP : C\nŒπ : Quiver.Hom P X\nw : Eq (CategoryTheory.CategoryStruct.comp Œπ f) (CategoryTheory.CategoryStruct.comp Œπ g)\n‚ä¢ Eq (CategoryTheory.Limits.Fork.ofŒπ Œπ w).pt P","decl":"/-- A fork on `f g : X ‚ü∂ Y` is determined by the morphism `Œπ : P ‚ü∂ X` satisfying `Œπ ‚â´ f = Œπ ‚â´ g`.\n-/\n@[simps]\ndef Fork.ofŒπ {P : C} (Œπ : P ‚ü∂ X) (w : Œπ ‚â´ f = Œπ ‚â´ g) : Fork f g where\n  pt := P\n  œÄ :=\n    { app := fun X => by\n        cases X\n        ¬∑ exact Œπ\n        ¬∑ exact Œπ ‚â´ f\n      naturality := fun {X} {Y} f =>\n        by cases X <;> cases Y <;> cases f <;> dsimp <;> simp; assumption }\n\n"}
{"name":"CategoryTheory.Limits.Fork.ofŒπ_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y : C\nf g : Quiver.Hom X‚úù Y\nP : C\nŒπ : Quiver.Hom P X‚úù\nw : Eq (CategoryTheory.CategoryStruct.comp Œπ f) (CategoryTheory.CategoryStruct.comp Œπ g)\nX : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.Fork.ofŒπ Œπ w).œÄ.app X) (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t => Eq X t ‚Üí Quiver.Hom (((CategoryTheory.Functor.const CategoryTheory.Limits.WalkingParallelPair).obj P).obj X) ((CategoryTheory.Limits.parallelPair f g).obj X)) X (fun h => Eq.ndrec Œπ ‚ãØ) (fun h => Eq.ndrec (CategoryTheory.CategoryStruct.comp Œπ f) ‚ãØ) ‚ãØ)","decl":"/-- A fork on `f g : X ‚ü∂ Y` is determined by the morphism `Œπ : P ‚ü∂ X` satisfying `Œπ ‚â´ f = Œπ ‚â´ g`.\n-/\n@[simps]\ndef Fork.ofŒπ {P : C} (Œπ : P ‚ü∂ X) (w : Œπ ‚â´ f = Œπ ‚â´ g) : Fork f g where\n  pt := P\n  œÄ :=\n    { app := fun X => by\n        cases X\n        ¬∑ exact Œπ\n        ¬∑ exact Œπ ‚â´ f\n      naturality := fun {X} {Y} f =>\n        by cases X <;> cases Y <;> cases f <;> dsimp <;> simp; assumption }\n\n"}
{"name":"CategoryTheory.Limits.Cofork.ofœÄ_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y : C\nf g : Quiver.Hom X‚úù Y\nP : C\nœÄ : Quiver.Hom Y P\nw : Eq (CategoryTheory.CategoryStruct.comp f œÄ) (CategoryTheory.CategoryStruct.comp g œÄ)\nX : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.Cofork.ofœÄ œÄ w).Œπ.app X) (CategoryTheory.Limits.WalkingParallelPair.casesOn X (CategoryTheory.CategoryStruct.comp f œÄ) œÄ)","decl":"/-- A cofork on `f g : X ‚ü∂ Y` is determined by the morphism `œÄ : Y ‚ü∂ P` satisfying\n    `f ‚â´ œÄ = g ‚â´ œÄ`. -/\n@[simps]\ndef Cofork.ofœÄ {P : C} (œÄ : Y ‚ü∂ P) (w : f ‚â´ œÄ = g ‚â´ œÄ) : Cofork f g where\n  pt := P\n  Œπ :=\n    { app := fun X => WalkingParallelPair.casesOn X (f ‚â´ œÄ) œÄ\n      naturality := fun i j f => by cases f <;> dsimp <;> simp [w] }\n\n-- See note [dsimp, simp]\n"}
{"name":"CategoryTheory.Limits.Cofork.ofœÄ_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nP : C\nœÄ : Quiver.Hom Y P\nw : Eq (CategoryTheory.CategoryStruct.comp f œÄ) (CategoryTheory.CategoryStruct.comp g œÄ)\n‚ä¢ Eq (CategoryTheory.Limits.Cofork.ofœÄ œÄ w).pt P","decl":"/-- A cofork on `f g : X ‚ü∂ Y` is determined by the morphism `œÄ : Y ‚ü∂ P` satisfying\n    `f ‚â´ œÄ = g ‚â´ œÄ`. -/\n@[simps]\ndef Cofork.ofœÄ {P : C} (œÄ : Y ‚ü∂ P) (w : f ‚â´ œÄ = g ‚â´ œÄ) : Cofork f g where\n  pt := P\n  Œπ :=\n    { app := fun X => WalkingParallelPair.casesOn X (f ‚â´ œÄ) œÄ\n      naturality := fun i j f => by cases f <;> dsimp <;> simp [w] }\n\n-- See note [dsimp, simp]\n"}
{"name":"CategoryTheory.Limits.Fork.Œπ_ofŒπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nP : C\nŒπ : Quiver.Hom P X\nw : Eq (CategoryTheory.CategoryStruct.comp Œπ f) (CategoryTheory.CategoryStruct.comp Œπ g)\n‚ä¢ Eq (CategoryTheory.Limits.Fork.ofŒπ Œπ w).Œπ Œπ","decl":"@[simp]\ntheorem Fork.Œπ_ofŒπ {P : C} (Œπ : P ‚ü∂ X) (w : Œπ ‚â´ f = Œπ ‚â´ g) : (Fork.ofŒπ Œπ w).Œπ = Œπ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Cofork.œÄ_ofœÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nP : C\nœÄ : Quiver.Hom Y P\nw : Eq (CategoryTheory.CategoryStruct.comp f œÄ) (CategoryTheory.CategoryStruct.comp g œÄ)\n‚ä¢ Eq (CategoryTheory.Limits.Cofork.ofœÄ œÄ w).œÄ œÄ","decl":"@[simp]\ntheorem Cofork.œÄ_ofœÄ {P : C} (œÄ : Y ‚ü∂ P) (w : f ‚â´ œÄ = g ‚â´ œÄ) : (Cofork.ofœÄ œÄ w).œÄ = œÄ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Fork.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Fork f g\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp t.Œπ (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp t.Œπ (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc (attr := simp)]\ntheorem Fork.condition (t : Fork f g) : t.Œπ ‚â´ f = t.Œπ ‚â´ g := by\n  rw [‚Üê t.app_one_eq_Œπ_comp_left, ‚Üê t.app_one_eq_Œπ_comp_right]\n\n"}
{"name":"CategoryTheory.Limits.Fork.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Fork f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp t.Œπ f) (CategoryTheory.CategoryStruct.comp t.Œπ g)","decl":"@[reassoc (attr := simp)]\ntheorem Fork.condition (t : Fork f g) : t.Œπ ‚â´ f = t.Œπ ‚â´ g := by\n  rw [‚Üê t.app_one_eq_Œπ_comp_left, ‚Üê t.app_one_eq_Œπ_comp_right]\n\n"}
{"name":"CategoryTheory.Limits.Cofork.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Cofork f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f t.œÄ) (CategoryTheory.CategoryStruct.comp g t.œÄ)","decl":"@[reassoc (attr := simp)]\ntheorem Cofork.condition (t : Cofork f g) : f ‚â´ t.œÄ = g ‚â´ t.œÄ := by\n  rw [‚Üê t.app_zero_eq_comp_œÄ_left, ‚Üê t.app_zero_eq_comp_œÄ_right]\n\n"}
{"name":"CategoryTheory.Limits.Cofork.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Cofork f g\nZ : C\nh : Quiver.Hom (((CategoryTheory.Functor.const CategoryTheory.Limits.WalkingParallelPair).obj t.pt).obj CategoryTheory.Limits.WalkingParallelPair.one) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp t.œÄ h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp t.œÄ h))","decl":"@[reassoc (attr := simp)]\ntheorem Cofork.condition (t : Cofork f g) : f ‚â´ t.œÄ = g ‚â´ t.œÄ := by\n  rw [‚Üê t.app_zero_eq_comp_œÄ_left, ‚Üê t.app_zero_eq_comp_œÄ_right]\n\n"}
{"name":"CategoryTheory.Limits.Fork.equalizer_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Fork f g\nW : C\nk l : Quiver.Hom W s.pt\nh : Eq (CategoryTheory.CategoryStruct.comp k s.Œπ) (CategoryTheory.CategoryStruct.comp l s.Œπ)\nj : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp k (s.œÄ.app j)) (CategoryTheory.CategoryStruct.comp l (s.œÄ.app j))","decl":"/-- To check whether two maps are equalized by both maps of a fork, it suffices to check it for the\n    first map -/\ntheorem Fork.equalizer_ext (s : Fork f g) {W : C} {k l : W ‚ü∂ s.pt} (h : k ‚â´ s.Œπ = l ‚â´ s.Œπ) :\n    ‚àÄ j : WalkingParallelPair, k ‚â´ s.œÄ.app j = l ‚â´ s.œÄ.app j\n  | zero => h\n  | one => by\n    have : k ‚â´ Œπ s ‚â´ f = l ‚â´ Œπ s ‚â´ f := by\n      simp only [‚Üê Category.assoc]; exact congrArg (¬∑ ‚â´ f) h\n    rw [s.app_one_eq_Œπ_comp_left, this]\n\n"}
{"name":"CategoryTheory.Limits.Cofork.coequalizer_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Cofork f g\nW : C\nk l : Quiver.Hom s.pt W\nh : Eq (CategoryTheory.CategoryStruct.comp s.œÄ k) (CategoryTheory.CategoryStruct.comp s.œÄ l)\nj : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (s.Œπ.app j) k) (CategoryTheory.CategoryStruct.comp (s.Œπ.app j) l)","decl":"/-- To check whether two maps are coequalized by both maps of a cofork, it suffices to check it for\n    the second map -/\ntheorem Cofork.coequalizer_ext (s : Cofork f g) {W : C} {k l : s.pt ‚ü∂ W}\n    (h : Cofork.œÄ s ‚â´ k = Cofork.œÄ s ‚â´ l) : ‚àÄ j : WalkingParallelPair, s.Œπ.app j ‚â´ k = s.Œπ.app j ‚â´ l\n  | zero => by simp only [s.app_zero_eq_comp_œÄ_left, Category.assoc, h]\n  | one => h\n\n"}
{"name":"CategoryTheory.Limits.Fork.IsLimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Fork f g\nhs : CategoryTheory.Limits.IsLimit s\nW : C\nk l : Quiver.Hom W s.pt\nh : Eq (CategoryTheory.CategoryStruct.comp k s.Œπ) (CategoryTheory.CategoryStruct.comp l s.Œπ)\n‚ä¢ Eq k l","decl":"theorem Fork.IsLimit.hom_ext {s : Fork f g} (hs : IsLimit s) {W : C} {k l : W ‚ü∂ s.pt}\n    (h : k ‚â´ Fork.Œπ s = l ‚â´ Fork.Œπ s) : k = l :=\n  hs.hom_ext <| Fork.equalizer_ext _ h\n\n"}
{"name":"CategoryTheory.Limits.Cofork.IsColimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Cofork f g\nhs : CategoryTheory.Limits.IsColimit s\nW : C\nk l : Quiver.Hom s.pt W\nh : Eq (CategoryTheory.CategoryStruct.comp s.œÄ k) (CategoryTheory.CategoryStruct.comp s.œÄ l)\n‚ä¢ Eq k l","decl":"theorem Cofork.IsColimit.hom_ext {s : Cofork f g} (hs : IsColimit s) {W : C} {k l : s.pt ‚ü∂ W}\n    (h : Cofork.œÄ s ‚â´ k = Cofork.œÄ s ‚â´ l) : k = l :=\n  hs.hom_ext <| Cofork.coequalizer_ext _ h\n\n"}
{"name":"CategoryTheory.Limits.Fork.IsLimit.lift_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Fork f g\nhs : CategoryTheory.Limits.IsLimit s\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hs.lift t) s.Œπ) t.Œπ","decl":"@[reassoc (attr := simp)]\ntheorem Fork.IsLimit.lift_Œπ {s t : Fork f g} (hs : IsLimit s) : hs.lift t ‚â´ s.Œπ = t.Œπ :=\n  hs.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.Fork.IsLimit.lift_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Fork f g\nhs : CategoryTheory.Limits.IsLimit s\nZ : C\nh : Quiver.Hom ((CategoryTheory.Limits.parallelPair f g).obj CategoryTheory.Limits.WalkingParallelPair.zero) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hs.lift t) (CategoryTheory.CategoryStruct.comp s.Œπ h)) (CategoryTheory.CategoryStruct.comp t.Œπ h)","decl":"@[reassoc (attr := simp)]\ntheorem Fork.IsLimit.lift_Œπ {s t : Fork f g} (hs : IsLimit s) : hs.lift t ‚â´ s.Œπ = t.Œπ :=\n  hs.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.Cofork.IsColimit.œÄ_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Cofork f g\nhs : CategoryTheory.Limits.IsColimit s\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp s.œÄ (hs.desc t)) t.œÄ","decl":"@[reassoc (attr := simp)]\ntheorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=\n  hs.fac _ _\n\n-- Porting note: `Fork.IsLimit.lift` was added in order to ease the port\n"}
{"name":"CategoryTheory.Limits.Cofork.IsColimit.œÄ_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Cofork f g\nhs : CategoryTheory.Limits.IsColimit s\nZ : C\nh : Quiver.Hom t.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp s.œÄ (CategoryTheory.CategoryStruct.comp (hs.desc t) h)) (CategoryTheory.CategoryStruct.comp t.œÄ h)","decl":"@[reassoc (attr := simp)]\ntheorem Cofork.IsColimit.œÄ_desc {s t : Cofork f g} (hs : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=\n  hs.fac _ _\n\n-- Porting note: `Fork.IsLimit.lift` was added in order to ease the port\n"}
{"name":"CategoryTheory.Limits.Fork.IsLimit.lift_Œπ'_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Fork f g\nhs : CategoryTheory.Limits.IsLimit s\nW : C\nk : Quiver.Hom W X\nh‚úù : Eq (CategoryTheory.CategoryStruct.comp k f) (CategoryTheory.CategoryStruct.comp k g)\nZ : C\nh : Quiver.Hom ((CategoryTheory.Limits.parallelPair f g).obj CategoryTheory.Limits.WalkingParallelPair.zero) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.IsLimit.lift hs k h‚úù) (CategoryTheory.CategoryStruct.comp s.Œπ h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma Fork.IsLimit.lift_Œπ' {s : Fork f g} (hs : IsLimit s) {W : C} (k : W ‚ü∂ X) (h : k ‚â´ f = k ‚â´ g) :\n    Fork.IsLimit.lift hs k h ‚â´ Fork.Œπ s = k :=\n    hs.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.Fork.IsLimit.lift_Œπ'","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Fork f g\nhs : CategoryTheory.Limits.IsLimit s\nW : C\nk : Quiver.Hom W X\nh : Eq (CategoryTheory.CategoryStruct.comp k f) (CategoryTheory.CategoryStruct.comp k g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.IsLimit.lift hs k h) s.Œπ) k","decl":"@[reassoc (attr := simp)]\nlemma Fork.IsLimit.lift_Œπ' {s : Fork f g} (hs : IsLimit s) {W : C} (k : W ‚ü∂ X) (h : k ‚â´ f = k ‚â´ g) :\n    Fork.IsLimit.lift hs k h ‚â´ Fork.Œπ s = k :=\n    hs.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.Cofork.IsColimit.œÄ_desc'","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Cofork f g\nhs : CategoryTheory.Limits.IsColimit s\nW : C\nk : Quiver.Hom Y W\nh : Eq (CategoryTheory.CategoryStruct.comp f k) (CategoryTheory.CategoryStruct.comp g k)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp s.œÄ (CategoryTheory.Limits.Cofork.IsColimit.desc hs k h)) k","decl":"@[reassoc (attr := simp)]\nlemma Cofork.IsColimit.œÄ_desc' {s : Cofork f g} (hs : IsColimit s) {W : C} (k : Y ‚ü∂ W)\n    (h : f ‚â´ k = g ‚â´ k) : Cofork.œÄ s ‚â´ Cofork.IsColimit.desc hs k h = k :=\n  hs.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.Cofork.IsColimit.œÄ_desc'_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Cofork f g\nhs : CategoryTheory.Limits.IsColimit s\nW : C\nk : Quiver.Hom Y W\nh‚úù : Eq (CategoryTheory.CategoryStruct.comp f k) (CategoryTheory.CategoryStruct.comp g k)\nZ : C\nh : Quiver.Hom W Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp s.œÄ (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.IsColimit.desc hs k h‚úù) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma Cofork.IsColimit.œÄ_desc' {s : Cofork f g} (hs : IsColimit s) {W : C} (k : Y ‚ü∂ W)\n    (h : f ‚â´ k = g ‚â´ k) : Cofork.œÄ s ‚â´ Cofork.IsColimit.desc hs k h = k :=\n  hs.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.Fork.IsLimit.existsUnique","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Fork f g\nhs : CategoryTheory.Limits.IsLimit s\nW : C\nk : Quiver.Hom W X\nh : Eq (CategoryTheory.CategoryStruct.comp k f) (CategoryTheory.CategoryStruct.comp k g)\n‚ä¢ ExistsUnique fun l => Eq (CategoryTheory.CategoryStruct.comp l s.Œπ) k","decl":"theorem Fork.IsLimit.existsUnique {s : Fork f g} (hs : IsLimit s) {W : C} (k : W ‚ü∂ X)\n    (h : k ‚â´ f = k ‚â´ g) : ‚àÉ! l : W ‚ü∂ s.pt, l ‚â´ Fork.Œπ s = k :=\n  ‚ü®hs.lift <| Fork.ofŒπ _ h, hs.fac _ _, fun _ hm =>\n    Fork.IsLimit.hom_ext hs <| hm.symm ‚ñ∏ (hs.fac (Fork.ofŒπ _ h) WalkingParallelPair.zero).symm‚ü©\n\n"}
{"name":"CategoryTheory.Limits.Cofork.IsColimit.existsUnique","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns : CategoryTheory.Limits.Cofork f g\nhs : CategoryTheory.Limits.IsColimit s\nW : C\nk : Quiver.Hom Y W\nh : Eq (CategoryTheory.CategoryStruct.comp f k) (CategoryTheory.CategoryStruct.comp g k)\n‚ä¢ ExistsUnique fun d => Eq (CategoryTheory.CategoryStruct.comp s.œÄ d) k","decl":"theorem Cofork.IsColimit.existsUnique {s : Cofork f g} (hs : IsColimit s) {W : C} (k : Y ‚ü∂ W)\n    (h : f ‚â´ k = g ‚â´ k) : ‚àÉ! d : s.pt ‚ü∂ W, Cofork.œÄ s ‚â´ d = k :=\n  ‚ü®hs.desc <| Cofork.ofœÄ _ h, hs.fac _ _, fun _ hm =>\n    Cofork.IsColimit.hom_ext hs <| hm.symm ‚ñ∏ (hs.fac (Cofork.ofœÄ _ h) WalkingParallelPair.one).symm‚ü©\n\n"}
{"name":"CategoryTheory.Limits.Fork.IsLimit.mk_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Fork f g\nlift : (s : CategoryTheory.Limits.Fork f g) ‚Üí Quiver.Hom s.pt t.pt\nfac : ‚àÄ (s : CategoryTheory.Limits.Fork f g), Eq (CategoryTheory.CategoryStruct.comp (lift s) t.Œπ) s.Œπ\nuniq : ‚àÄ (s : CategoryTheory.Limits.Fork f g) (m : Quiver.Hom s.pt t.pt), Eq (CategoryTheory.CategoryStruct.comp m t.Œπ) s.Œπ ‚Üí Eq m (lift s)\ns : CategoryTheory.Limits.Fork f g\n‚ä¢ Eq ((CategoryTheory.Limits.Fork.IsLimit.mk t lift fac uniq).lift s) (lift s)","decl":"/-- This is a slightly more convenient method to verify that a fork is a limit cone. It\n    only asks for a proof of facts that carry any mathematical content -/\n@[simps]\ndef Fork.IsLimit.mk (t : Fork f g) (lift : ‚àÄ s : Fork f g, s.pt ‚ü∂ t.pt)\n    (fac : ‚àÄ s : Fork f g, lift s ‚â´ Fork.Œπ t = Fork.Œπ s)\n    (uniq : ‚àÄ (s : Fork f g) (m : s.pt ‚ü∂ t.pt) (_ : m ‚â´ t.Œπ = s.Œπ), m = lift s) : IsLimit t :=\n  { lift\n    fac := fun s j =>\n      WalkingParallelPair.casesOn j (fac s) <| by\n        erw [‚Üê s.w left, ‚Üê t.w left, ‚Üê Category.assoc, fac]; rfl\n    uniq := fun s m j => by aesop}\n\n"}
{"name":"CategoryTheory.Limits.Fork.IsLimit.homIso_symm_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Fork f g\nht : CategoryTheory.Limits.IsLimit t\nZ : C\nh : Subtype fun h => Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)\n‚ä¢ Eq ((CategoryTheory.Limits.Fork.IsLimit.homIso ht Z).symm h) ‚Üë(CategoryTheory.Limits.Fork.IsLimit.lift' ht ‚Üëh ‚ãØ)","decl":"/--\nGiven a limit cone for the pair `f g : X ‚ü∂ Y`, for any `Z`, morphisms from `Z` to its point are in\nbijection with morphisms `h : Z ‚ü∂ X` such that `h ‚â´ f = h ‚â´ g`.\nFurther, this bijection is natural in `Z`: see `Fork.IsLimit.homIso_natural`.\nThis is a special case of `IsLimit.homIso'`, often useful to construct adjunctions.\n-/\n@[simps]\ndef Fork.IsLimit.homIso {X Y : C} {f g : X ‚ü∂ Y} {t : Fork f g} (ht : IsLimit t) (Z : C) :\n    (Z ‚ü∂ t.pt) ‚âÉ { h : Z ‚ü∂ X // h ‚â´ f = h ‚â´ g } where\n  toFun k := ‚ü®k ‚â´ t.Œπ, by simp only [Category.assoc, t.condition]‚ü©\n  invFun h := (Fork.IsLimit.lift' ht _ h.prop).1\n  left_inv _ := Fork.IsLimit.hom_ext ht (Fork.IsLimit.lift' _ _ _).prop\n  right_inv _ := Subtype.ext (Fork.IsLimit.lift' ht _ _).prop\n\n"}
{"name":"CategoryTheory.Limits.Fork.IsLimit.homIso_apply_coe","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Fork f g\nht : CategoryTheory.Limits.IsLimit t\nZ : C\nk : Quiver.Hom Z t.pt\n‚ä¢ Eq (‚Üë((CategoryTheory.Limits.Fork.IsLimit.homIso ht Z) k)) (CategoryTheory.CategoryStruct.comp k t.Œπ)","decl":"/--\nGiven a limit cone for the pair `f g : X ‚ü∂ Y`, for any `Z`, morphisms from `Z` to its point are in\nbijection with morphisms `h : Z ‚ü∂ X` such that `h ‚â´ f = h ‚â´ g`.\nFurther, this bijection is natural in `Z`: see `Fork.IsLimit.homIso_natural`.\nThis is a special case of `IsLimit.homIso'`, often useful to construct adjunctions.\n-/\n@[simps]\ndef Fork.IsLimit.homIso {X Y : C} {f g : X ‚ü∂ Y} {t : Fork f g} (ht : IsLimit t) (Z : C) :\n    (Z ‚ü∂ t.pt) ‚âÉ { h : Z ‚ü∂ X // h ‚â´ f = h ‚â´ g } where\n  toFun k := ‚ü®k ‚â´ t.Œπ, by simp only [Category.assoc, t.condition]‚ü©\n  invFun h := (Fork.IsLimit.lift' ht _ h.prop).1\n  left_inv _ := Fork.IsLimit.hom_ext ht (Fork.IsLimit.lift' _ _ _).prop\n  right_inv _ := Subtype.ext (Fork.IsLimit.lift' ht _ _).prop\n\n"}
{"name":"CategoryTheory.Limits.Fork.IsLimit.homIso_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Fork f g\nht : CategoryTheory.Limits.IsLimit t\nZ Z' : C\nq : Quiver.Hom Z' Z\nk : Quiver.Hom Z t.pt\n‚ä¢ Eq (‚Üë((CategoryTheory.Limits.Fork.IsLimit.homIso ht Z') (CategoryTheory.CategoryStruct.comp q k))) (CategoryTheory.CategoryStruct.comp q ‚Üë((CategoryTheory.Limits.Fork.IsLimit.homIso ht Z) k))","decl":"/-- The bijection of `Fork.IsLimit.homIso` is natural in `Z`. -/\ntheorem Fork.IsLimit.homIso_natural {X Y : C} {f g : X ‚ü∂ Y} {t : Fork f g} (ht : IsLimit t)\n    {Z Z' : C} (q : Z' ‚ü∂ Z) (k : Z ‚ü∂ t.pt) :\n    (Fork.IsLimit.homIso ht _ (q ‚â´ k) : Z' ‚ü∂ X) = q ‚â´ (Fork.IsLimit.homIso ht _ k : Z ‚ü∂ X) :=\n  Category.assoc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Cofork.IsColimit.homIso_symm_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Cofork f g\nht : CategoryTheory.Limits.IsColimit t\nZ : C\nh : Subtype fun h => Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h)\n‚ä¢ Eq ((CategoryTheory.Limits.Cofork.IsColimit.homIso ht Z).symm h) ‚Üë(CategoryTheory.Limits.Cofork.IsColimit.desc' ht ‚Üëh ‚ãØ)","decl":"/-- Given a colimit cocone for the pair `f g : X ‚ü∂ Y`, for any `Z`, morphisms from the cocone point\nto `Z` are in bijection with morphisms `h : Y ‚ü∂ Z` such that `f ‚â´ h = g ‚â´ h`.\nFurther, this bijection is natural in `Z`: see `Cofork.IsColimit.homIso_natural`.\nThis is a special case of `IsColimit.homIso'`, often useful to construct adjunctions.\n-/\n@[simps]\ndef Cofork.IsColimit.homIso {X Y : C} {f g : X ‚ü∂ Y} {t : Cofork f g} (ht : IsColimit t) (Z : C) :\n    (t.pt ‚ü∂ Z) ‚âÉ { h : Y ‚ü∂ Z // f ‚â´ h = g ‚â´ h } where\n  toFun k := ‚ü®t.œÄ ‚â´ k, by simp only [‚Üê Category.assoc, t.condition]‚ü©\n  invFun h := (Cofork.IsColimit.desc' ht _ h.prop).1\n  left_inv _ := Cofork.IsColimit.hom_ext ht (Cofork.IsColimit.desc' _ _ _).prop\n  right_inv _ := Subtype.ext (Cofork.IsColimit.desc' ht _ _).prop\n\n"}
{"name":"CategoryTheory.Limits.Cofork.IsColimit.homIso_apply_coe","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Cofork f g\nht : CategoryTheory.Limits.IsColimit t\nZ : C\nk : Quiver.Hom t.pt Z\n‚ä¢ Eq (‚Üë((CategoryTheory.Limits.Cofork.IsColimit.homIso ht Z) k)) (CategoryTheory.CategoryStruct.comp t.œÄ k)","decl":"/-- Given a colimit cocone for the pair `f g : X ‚ü∂ Y`, for any `Z`, morphisms from the cocone point\nto `Z` are in bijection with morphisms `h : Y ‚ü∂ Z` such that `f ‚â´ h = g ‚â´ h`.\nFurther, this bijection is natural in `Z`: see `Cofork.IsColimit.homIso_natural`.\nThis is a special case of `IsColimit.homIso'`, often useful to construct adjunctions.\n-/\n@[simps]\ndef Cofork.IsColimit.homIso {X Y : C} {f g : X ‚ü∂ Y} {t : Cofork f g} (ht : IsColimit t) (Z : C) :\n    (t.pt ‚ü∂ Z) ‚âÉ { h : Y ‚ü∂ Z // f ‚â´ h = g ‚â´ h } where\n  toFun k := ‚ü®t.œÄ ‚â´ k, by simp only [‚Üê Category.assoc, t.condition]‚ü©\n  invFun h := (Cofork.IsColimit.desc' ht _ h.prop).1\n  left_inv _ := Cofork.IsColimit.hom_ext ht (Cofork.IsColimit.desc' _ _ _).prop\n  right_inv _ := Subtype.ext (Cofork.IsColimit.desc' ht _ _).prop\n\n"}
{"name":"CategoryTheory.Limits.Cofork.IsColimit.homIso_natural","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Cofork f g\nZ Z' : C\nq : Quiver.Hom Z Z'\nht : CategoryTheory.Limits.IsColimit t\nk : Quiver.Hom t.pt Z\n‚ä¢ Eq (‚Üë((CategoryTheory.Limits.Cofork.IsColimit.homIso ht Z') (CategoryTheory.CategoryStruct.comp k q))) (CategoryTheory.CategoryStruct.comp (‚Üë((CategoryTheory.Limits.Cofork.IsColimit.homIso ht Z) k)) q)","decl":"/-- The bijection of `Cofork.IsColimit.homIso` is natural in `Z`. -/\ntheorem Cofork.IsColimit.homIso_natural {X Y : C} {f g : X ‚ü∂ Y} {t : Cofork f g} {Z Z' : C}\n    (q : Z ‚ü∂ Z') (ht : IsColimit t) (k : t.pt ‚ü∂ Z) :\n    (Cofork.IsColimit.homIso ht _ (k ‚â´ q) : Y ‚ü∂ Z') =\n      (Cofork.IsColimit.homIso ht _ k : Y ‚ü∂ Z) ‚â´ q :=\n  (Category.assoc _ _ _).symm\n\n"}
{"name":"CategoryTheory.Limits.Cone.ofFork_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C\nt : CategoryTheory.Limits.Fork (F.map CategoryTheory.Limits.WalkingParallelPairHom.left) (F.map CategoryTheory.Limits.WalkingParallelPairHom.right)\nj : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.Cone.ofFork t).œÄ.app j) (CategoryTheory.CategoryStruct.comp (t.œÄ.app j) (CategoryTheory.eqToHom ‚ãØ))","decl":"@[simp]\ntheorem Cone.ofFork_œÄ {F : WalkingParallelPair ‚•§ C} (t : Fork (F.map left) (F.map right)) (j) :\n    (Cone.ofFork t).œÄ.app j = t.œÄ.app j ‚â´ eqToHom (by simp) := rfl\n\n"}
{"name":"CategoryTheory.Limits.Cocone.ofCofork_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C\nt : CategoryTheory.Limits.Cofork (F.map CategoryTheory.Limits.WalkingParallelPairHom.left) (F.map CategoryTheory.Limits.WalkingParallelPairHom.right)\nj : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.Cocone.ofCofork t).Œπ.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (t.Œπ.app j))","decl":"@[simp]\ntheorem Cocone.ofCofork_Œπ {F : WalkingParallelPair ‚•§ C} (t : Cofork (F.map left) (F.map right))\n    (j) : (Cocone.ofCofork t).Œπ.app j = eqToHom (by simp) ‚â´ t.Œπ.app j := rfl\n\n"}
{"name":"CategoryTheory.Limits.Fork.ofCone_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C\nt : CategoryTheory.Limits.Cone F\nj : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.Fork.ofCone t).œÄ.app j) (CategoryTheory.CategoryStruct.comp (t.œÄ.app j) (CategoryTheory.eqToHom ‚ãØ))","decl":"@[simp]\ntheorem Fork.ofCone_œÄ {F : WalkingParallelPair ‚•§ C} (t : Cone F) (j) :\n    (Fork.ofCone t).œÄ.app j = t.œÄ.app j ‚â´ eqToHom (by simp) := rfl\n\n"}
{"name":"CategoryTheory.Limits.Cofork.ofCocone_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair C\nt : CategoryTheory.Limits.Cocone F\nj : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.Cofork.ofCocone t).Œπ.app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (t.Œπ.app j))","decl":"@[simp]\ntheorem Cofork.ofCocone_Œπ {F : WalkingParallelPair ‚•§ C} (t : Cocone F) (j) :\n    (Cofork.ofCocone t).Œπ.app j = eqToHom (by simp) ‚â´ t.Œπ.app j := rfl\n\n"}
{"name":"CategoryTheory.Limits.Fork.Œπ_postcompose","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g f' g' : Quiver.Hom X Y\nŒ± : Quiver.Hom (CategoryTheory.Limits.parallelPair f g) (CategoryTheory.Limits.parallelPair f' g')\nc : CategoryTheory.Limits.Fork f g\n‚ä¢ Eq (CategoryTheory.Limits.Fork.Œπ ((CategoryTheory.Limits.Cones.postcompose Œ±).obj c)) (CategoryTheory.CategoryStruct.comp c.Œπ (Œ±.app CategoryTheory.Limits.WalkingParallelPair.zero))","decl":"@[simp]\ntheorem Fork.Œπ_postcompose {f' g' : X ‚ü∂ Y} {Œ± : parallelPair f g ‚ü∂ parallelPair f' g'}\n    {c : Fork f g} : Fork.Œπ ((Cones.postcompose Œ±).obj c) = c.Œπ ‚â´ Œ±.app _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Cofork.œÄ_precompose","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g f' g' : Quiver.Hom X Y\nŒ± : Quiver.Hom (CategoryTheory.Limits.parallelPair f g) (CategoryTheory.Limits.parallelPair f' g')\nc : CategoryTheory.Limits.Cofork f' g'\n‚ä¢ Eq (CategoryTheory.Limits.Cofork.œÄ ((CategoryTheory.Limits.Cocones.precompose Œ±).obj c)) (CategoryTheory.CategoryStruct.comp (Œ±.app CategoryTheory.Limits.WalkingParallelPair.one) c.œÄ)","decl":"@[simp]\ntheorem Cofork.œÄ_precompose {f' g' : X ‚ü∂ Y} {Œ± : parallelPair f g ‚ü∂ parallelPair f' g'}\n    {c : Cofork f' g'} : Cofork.œÄ ((Cocones.precompose Œ±).obj c) = Œ±.app _ ‚â´ c.œÄ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Fork.mkHom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Fork f g\nk : Quiver.Hom s.pt t.pt\nw : Eq (CategoryTheory.CategoryStruct.comp k t.Œπ) s.Œπ\n‚ä¢ Eq (CategoryTheory.Limits.Fork.mkHom k w).hom k","decl":"/-- Helper function for constructing morphisms between equalizer forks.\n-/\n@[simps]\ndef Fork.mkHom {s t : Fork f g} (k : s.pt ‚ü∂ t.pt) (w : k ‚â´ t.Œπ = s.Œπ) : s ‚ü∂ t where\n  hom := k\n  w := by\n    rintro ‚ü®_ | _‚ü©\n    ¬∑ exact w\n    ¬∑ simp only [Fork.app_one_eq_Œπ_comp_left,‚Üê Category.assoc]\n      congr\n\n"}
{"name":"CategoryTheory.Limits.Fork.ext_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Fork f g\ni : CategoryTheory.Iso s.pt t.pt\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp i.hom t.Œπ) s.Œπ) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Limits.Fork.ext i w).inv (CategoryTheory.Limits.Fork.mkHom i.inv ‚ãØ)","decl":"/-- To construct an isomorphism between forks,\nit suffices to give an isomorphism between the cone points\nand check that it commutes with the `Œπ` morphisms.\n-/\n@[simps]\ndef Fork.ext {s t : Fork f g} (i : s.pt ‚âÖ t.pt) (w : i.hom ‚â´ t.Œπ = s.Œπ := by aesop_cat) :\n    s ‚âÖ t where\n  hom := Fork.mkHom i.hom w\n  inv := Fork.mkHom i.inv (by rw [‚Üê w, Iso.inv_hom_id_assoc])\n\n"}
{"name":"CategoryTheory.Limits.Fork.ext_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Fork f g\ni : CategoryTheory.Iso s.pt t.pt\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp i.hom t.Œπ) s.Œπ) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Limits.Fork.ext i w).hom (CategoryTheory.Limits.Fork.mkHom i.hom w)","decl":"/-- To construct an isomorphism between forks,\nit suffices to give an isomorphism between the cone points\nand check that it commutes with the `Œπ` morphisms.\n-/\n@[simps]\ndef Fork.ext {s t : Fork f g} (i : s.pt ‚âÖ t.pt) (w : i.hom ‚â´ t.Œπ = s.Œπ := by aesop_cat) :\n    s ‚âÖ t where\n  hom := Fork.mkHom i.hom w\n  inv := Fork.mkHom i.inv (by rw [‚Üê w, Iso.inv_hom_id_assoc])\n\n"}
{"name":"CategoryTheory.Limits.Cofork.mkHom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Cofork f g\nk : Quiver.Hom s.pt t.pt\nw : Eq (CategoryTheory.CategoryStruct.comp s.œÄ k) t.œÄ\n‚ä¢ Eq (CategoryTheory.Limits.Cofork.mkHom k w).hom k","decl":"/-- Helper function for constructing morphisms between coequalizer coforks.\n-/\n@[simps]\ndef Cofork.mkHom {s t : Cofork f g} (k : s.pt ‚ü∂ t.pt) (w : s.œÄ ‚â´ k = t.œÄ) : s ‚ü∂ t where\n  hom := k\n  w := by\n    rintro ‚ü®_ | _‚ü©\n    ¬∑ simp [Cofork.app_zero_eq_comp_œÄ_left, w]\n    ¬∑ exact w\n\n"}
{"name":"CategoryTheory.Limits.Fork.hom_comp_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf‚úù g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Fork f‚úù g\nf : Quiver.Hom s t\nZ : C\nh : Quiver.Hom ((CategoryTheory.Limits.parallelPair f‚úù g).obj CategoryTheory.Limits.WalkingParallelPair.zero) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.CategoryStruct.comp t.Œπ h)) (CategoryTheory.CategoryStruct.comp s.Œπ h)","decl":"@[reassoc (attr := simp)]\ntheorem Fork.hom_comp_Œπ {s t : Fork f g} (f : s ‚ü∂ t) : f.hom ‚â´ t.Œπ = s.Œπ := by\n  cases s; cases t; cases f; aesop\n\n"}
{"name":"CategoryTheory.Limits.Fork.hom_comp_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf‚úù g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Fork f‚úù g\nf : Quiver.Hom s t\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.hom t.Œπ) s.Œπ","decl":"@[reassoc (attr := simp)]\ntheorem Fork.hom_comp_Œπ {s t : Fork f g} (f : s ‚ü∂ t) : f.hom ‚â´ t.Œπ = s.Œπ := by\n  cases s; cases t; cases f; aesop\n\n"}
{"name":"CategoryTheory.Limits.Fork.œÄ_comp_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf‚úù g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Cofork f‚úù g\nf : Quiver.Hom s t\nZ : C\nh : Quiver.Hom t.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp s.œÄ (CategoryTheory.CategoryStruct.comp f.hom h)) (CategoryTheory.CategoryStruct.comp t.œÄ h)","decl":"@[reassoc (attr := simp)]\ntheorem Fork.œÄ_comp_hom {s t : Cofork f g} (f : s ‚ü∂ t) : s.œÄ ‚â´ f.hom = t.œÄ := by\n  cases s; cases t; cases f; aesop\n\n"}
{"name":"CategoryTheory.Limits.Fork.œÄ_comp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf‚úù g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Cofork f‚úù g\nf : Quiver.Hom s t\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp s.œÄ f.hom) t.œÄ","decl":"@[reassoc (attr := simp)]\ntheorem Fork.œÄ_comp_hom {s t : Cofork f g} (f : s ‚ü∂ t) : s.œÄ ‚â´ f.hom = t.œÄ := by\n  cases s; cases t; cases f; aesop\n\n"}
{"name":"CategoryTheory.Limits.Cofork.ext_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Cofork f g\ni : CategoryTheory.Iso s.pt t.pt\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp s.œÄ i.hom) t.œÄ) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Limits.Cofork.ext i w).inv (CategoryTheory.Limits.Cofork.mkHom i.inv ‚ãØ)","decl":"/-- To construct an isomorphism between coforks,\nit suffices to give an isomorphism between the cocone points\nand check that it commutes with the `œÄ` morphisms.\n-/\n@[simps]\ndef Cofork.ext {s t : Cofork f g} (i : s.pt ‚âÖ t.pt) (w : s.œÄ ‚â´ i.hom = t.œÄ := by aesop_cat) :\n    s ‚âÖ t where\n  hom := Cofork.mkHom i.hom w\n  inv := Cofork.mkHom i.inv (by rw [Iso.comp_inv_eq, w])\n\n"}
{"name":"CategoryTheory.Limits.Cofork.ext_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ns t : CategoryTheory.Limits.Cofork f g\ni : CategoryTheory.Iso s.pt t.pt\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp s.œÄ i.hom) t.œÄ) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Limits.Cofork.ext i w).hom (CategoryTheory.Limits.Cofork.mkHom i.hom w)","decl":"/-- To construct an isomorphism between coforks,\nit suffices to give an isomorphism between the cocone points\nand check that it commutes with the `œÄ` morphisms.\n-/\n@[simps]\ndef Cofork.ext {s t : Cofork f g} (i : s.pt ‚âÖ t.pt) (w : s.œÄ ‚â´ i.hom = t.œÄ := by aesop_cat) :\n    s ‚âÖ t where\n  hom := Cofork.mkHom i.hom w\n  inv := Cofork.mkHom i.inv (by rw [Iso.comp_inv_eq, w])\n\n"}
{"name":"CategoryTheory.Limits.equalizer.fork_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\n‚ä¢ Eq (CategoryTheory.Limits.equalizer.fork f g).Œπ (CategoryTheory.Limits.equalizer.Œπ f g)","decl":"@[simp]\ntheorem equalizer.fork_Œπ : (equalizer.fork f g).Œπ = equalizer.Œπ f g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.equalizer.fork_œÄ_app_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\n‚ä¢ Eq ((CategoryTheory.Limits.equalizer.fork f g).œÄ.app CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.Limits.equalizer.Œπ f g)","decl":"@[simp]\ntheorem equalizer.fork_œÄ_app_zero : (equalizer.fork f g).œÄ.app zero = equalizer.Œπ f g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.equalizer.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.Œπ f g) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.Œπ f g) g)","decl":"@[reassoc]\ntheorem equalizer.condition : equalizer.Œπ f g ‚â´ f = equalizer.Œπ f g ‚â´ g :=\n  Fork.condition <| limit.cone <| parallelPair f g\n\n"}
{"name":"CategoryTheory.Limits.equalizer.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.Œπ f g) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.Œπ f g) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\ntheorem equalizer.condition : equalizer.Œπ f g ‚â´ f = equalizer.Œπ f g ‚â´ g :=\n  Fork.condition <| limit.cone <| parallelPair f g\n\n"}
{"name":"CategoryTheory.Limits.equalizer.lift_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\nW : C\nk : Quiver.Hom W X\nh : Eq (CategoryTheory.CategoryStruct.comp k f) (CategoryTheory.CategoryStruct.comp k g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.lift k h) (CategoryTheory.Limits.equalizer.Œπ f g)) k","decl":"@[reassoc]\ntheorem equalizer.lift_Œπ {W : C} (k : W ‚ü∂ X) (h : k ‚â´ f = k ‚â´ g) :\n    equalizer.lift k h ‚â´ equalizer.Œπ f g = k :=\n  limit.lift_œÄ _ _\n\n"}
{"name":"CategoryTheory.Limits.equalizer.lift_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\nW : C\nk : Quiver.Hom W X\nh‚úù : Eq (CategoryTheory.CategoryStruct.comp k f) (CategoryTheory.CategoryStruct.comp k g)\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.lift k h‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.Œπ f g) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc]\ntheorem equalizer.lift_Œπ {W : C} (k : W ‚ü∂ X) (h : k ‚â´ f = k ‚â´ g) :\n    equalizer.lift k h ‚â´ equalizer.Œπ f g = k :=\n  limit.lift_œÄ _ _\n\n"}
{"name":"CategoryTheory.Limits.equalizer.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\nW : C\nk l : Quiver.Hom W (CategoryTheory.Limits.equalizer f g)\n‚ä¢ Iff (Eq k l) (Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.equalizer.Œπ f g)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.equalizer.Œπ f g)))","decl":"/-- Two maps into an equalizer are equal if they are equal when composed with the equalizer map. -/\n@[ext]\ntheorem equalizer.hom_ext {W : C} {k l : W ‚ü∂ equalizer f g}\n    (h : k ‚â´ equalizer.Œπ f g = l ‚â´ equalizer.Œπ f g) : k = l :=\n  Fork.IsLimit.hom_ext (limit.isLimit _) h\n\n"}
{"name":"CategoryTheory.Limits.equalizer.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\nW : C\nk l : Quiver.Hom W (CategoryTheory.Limits.equalizer f g)\nh : Eq (CategoryTheory.CategoryStruct.comp k (CategoryTheory.Limits.equalizer.Œπ f g)) (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.equalizer.Œπ f g))\n‚ä¢ Eq k l","decl":"/-- Two maps into an equalizer are equal if they are equal when composed with the equalizer map. -/\n@[ext]\ntheorem equalizer.hom_ext {W : C} {k l : W ‚ü∂ equalizer f g}\n    (h : k ‚â´ equalizer.Œπ f g = l ‚â´ equalizer.Œπ f g) : k = l :=\n  Fork.IsLimit.hom_ext (limit.isLimit _) h\n\n"}
{"name":"CategoryTheory.Limits.equalizer.existsUnique","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\nW : C\nk : Quiver.Hom W X\nh : Eq (CategoryTheory.CategoryStruct.comp k f) (CategoryTheory.CategoryStruct.comp k g)\n‚ä¢ ExistsUnique fun l => Eq (CategoryTheory.CategoryStruct.comp l (CategoryTheory.Limits.equalizer.Œπ f g)) k","decl":"theorem equalizer.existsUnique {W : C} (k : W ‚ü∂ X) (h : k ‚â´ f = k ‚â´ g) :\n    ‚àÉ! l : W ‚ü∂ equalizer f g, l ‚â´ equalizer.Œπ f g = k :=\n  Fork.IsLimit.existsUnique (limit.isLimit _) _ h\n\n"}
{"name":"CategoryTheory.Limits.equalizer.Œπ_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.equalizer.Œπ f g)","decl":"/-- An equalizer morphism is a monomorphism -/\ninstance equalizer.Œπ_mono : Mono (equalizer.Œπ f g) where\n  right_cancellation _ _ w := equalizer.hom_ext w\n\n"}
{"name":"CategoryTheory.Limits.mono_of_isLimit_fork","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nc : CategoryTheory.Limits.Fork f g\ni : CategoryTheory.Limits.IsLimit c\n‚ä¢ CategoryTheory.Mono c.Œπ","decl":"/-- The equalizer morphism in any limit cone is a monomorphism. -/\ntheorem mono_of_isLimit_fork {c : Fork f g} (i : IsLimit c) : Mono (Fork.Œπ c) :=\n  { right_cancellation := fun _ _ w => Fork.IsLimit.hom_ext i w }\n\n"}
{"name":"CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nh‚ÇÄ : Eq f g\nc : CategoryTheory.Limits.Fork f g\nh : CategoryTheory.Limits.IsLimit c\n‚ä¢ CategoryTheory.IsIso c.Œπ","decl":"/-- Every equalizer of `(f, g)`, where `f = g`, is an isomorphism. -/\ntheorem isIso_limit_cone_parallelPair_of_eq (h‚ÇÄ : f = g) {c : Fork f g} (h : IsLimit c) :\n    IsIso c.Œπ :=\n  Iso.isIso_hom <| IsLimit.conePointUniqueUpToIso h <| isLimitIdFork h‚ÇÄ\n\n"}
{"name":"CategoryTheory.Limits.equalizer.Œπ_of_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasEqualizer f g\nh : Eq f g\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.equalizer.Œπ f g)","decl":"/-- The equalizer of `(f, g)`, where `f = g`, is an isomorphism. -/\ntheorem equalizer.Œπ_of_eq [HasEqualizer f g] (h : f = g) : IsIso (equalizer.Œπ f g) :=\n  isIso_limit_cone_parallelPair_of_eq h <| limit.isLimit _\n\n"}
{"name":"CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_self","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.Fork f f\nh : CategoryTheory.Limits.IsLimit c\n‚ä¢ CategoryTheory.IsIso c.Œπ","decl":"/-- Every equalizer of `(f, f)` is an isomorphism. -/\ntheorem isIso_limit_cone_parallelPair_of_self {c : Fork f f} (h : IsLimit c) : IsIso c.Œπ :=\n  isIso_limit_cone_parallelPair_of_eq rfl h\n\n"}
{"name":"CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nc : CategoryTheory.Limits.Fork f g\nh : CategoryTheory.Limits.IsLimit c\ninst‚úù : CategoryTheory.Epi c.Œπ\n‚ä¢ CategoryTheory.IsIso c.Œπ","decl":"/-- An equalizer that is an epimorphism is an isomorphism. -/\ntheorem isIso_limit_cone_parallelPair_of_epi {c : Fork f g} (h : IsLimit c) [Epi c.Œπ] : IsIso c.Œπ :=\n  isIso_limit_cone_parallelPair_of_eq ((cancel_epi _).1 (Fork.condition c)) h\n\n"}
{"name":"CategoryTheory.Limits.eq_of_epi_fork_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Fork f g\ninst‚úù : CategoryTheory.Epi t.Œπ\n‚ä¢ Eq f g","decl":"/-- Two morphisms are equal if there is a fork whose inclusion is epi. -/\ntheorem eq_of_epi_fork_Œπ (t : Fork f g) [Epi (Fork.Œπ t)] : f = g :=\n  (cancel_epi (Fork.Œπ t)).1 <| Fork.condition t\n\n"}
{"name":"CategoryTheory.Limits.eq_of_epi_equalizer","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasEqualizer f g\ninst‚úù : CategoryTheory.Epi (CategoryTheory.Limits.equalizer.Œπ f g)\n‚ä¢ Eq f g","decl":"/-- If the equalizer of two morphisms is an epimorphism, then the two morphisms are equal. -/\ntheorem eq_of_epi_equalizer [HasEqualizer f g] [Epi (equalizer.Œπ f g)] : f = g :=\n  (cancel_epi (equalizer.Œπ f g)).1 <| equalizer.condition _ _\n\n"}
{"name":"CategoryTheory.Limits.hasEqualizer_of_self","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.Limits.HasEqualizer f f","decl":"instance hasEqualizer_of_self : HasEqualizer f f :=\n  HasLimit.mk\n    { cone := idFork rfl\n      isLimit := isLimitIdFork rfl }\n\n"}
{"name":"CategoryTheory.Limits.equalizer.Œπ_of_self","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.equalizer.Œπ f f)","decl":"/-- The equalizer inclusion for `(f, f)` is an isomorphism. -/\ninstance equalizer.Œπ_of_self : IsIso (equalizer.Œπ f f) :=\n  equalizer.Œπ_of_eq rfl\n\n"}
{"name":"CategoryTheory.Limits.equalizer.isoSourceOfSelf_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Limits.equalizer.isoSourceOfSelf f).hom (CategoryTheory.Limits.equalizer.Œπ f f)","decl":"@[simp]\ntheorem equalizer.isoSourceOfSelf_hom : (equalizer.isoSourceOfSelf f).hom = equalizer.Œπ f f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.equalizer.isoSourceOfSelf_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Limits.equalizer.isoSourceOfSelf f).inv (CategoryTheory.Limits.equalizer.lift (CategoryTheory.CategoryStruct.id X) ‚ãØ)","decl":"@[simp]\ntheorem equalizer.isoSourceOfSelf_inv :\n    (equalizer.isoSourceOfSelf f).inv = equalizer.lift (ùüô X) (by simp) := by\n  ext\n  simp [equalizer.isoSourceOfSelf]\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.cofork_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCoequalizer f g\n‚ä¢ Eq (CategoryTheory.Limits.coequalizer.cofork f g).œÄ (CategoryTheory.Limits.coequalizer.œÄ f g)","decl":"@[simp]\ntheorem coequalizer.cofork_œÄ : (coequalizer.cofork f g).œÄ = coequalizer.œÄ f g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.cofork_Œπ_app_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCoequalizer f g\n‚ä¢ Eq ((CategoryTheory.Limits.coequalizer.cofork f g).Œπ.app CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.Limits.coequalizer.œÄ f g)","decl":"theorem coequalizer.cofork_Œπ_app_one : (coequalizer.cofork f g).Œπ.app one = coequalizer.œÄ f g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCoequalizer f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.coequalizer.œÄ f g)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.coequalizer.œÄ f g))","decl":"@[reassoc]\ntheorem coequalizer.condition : f ‚â´ coequalizer.œÄ f g = g ‚â´ coequalizer.œÄ f g :=\n  Cofork.condition <| colimit.cocone <| parallelPair f g\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCoequalizer f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coequalizer f g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ f g) h)) (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ f g) h))","decl":"@[reassoc]\ntheorem coequalizer.condition : f ‚â´ coequalizer.œÄ f g = g ‚â´ coequalizer.œÄ f g :=\n  Cofork.condition <| colimit.cocone <| parallelPair f g\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.œÄ_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCoequalizer f g\nW : C\nk : Quiver.Hom Y W\nh : Eq (CategoryTheory.CategoryStruct.comp f k) (CategoryTheory.CategoryStruct.comp g k)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ f g) (CategoryTheory.Limits.coequalizer.desc k h)) k","decl":"@[reassoc]\ntheorem coequalizer.œÄ_desc {W : C} (k : Y ‚ü∂ W) (h : f ‚â´ k = g ‚â´ k) :\n    coequalizer.œÄ f g ‚â´ coequalizer.desc k h = k :=\n  colimit.Œπ_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.œÄ_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCoequalizer f g\nW : C\nk : Quiver.Hom Y W\nh‚úù : Eq (CategoryTheory.CategoryStruct.comp f k) (CategoryTheory.CategoryStruct.comp g k)\nZ : C\nh : Quiver.Hom W Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.desc k h‚úù) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc]\ntheorem coequalizer.œÄ_desc {W : C} (k : Y ‚ü∂ W) (h : f ‚â´ k = g ‚â´ k) :\n    coequalizer.œÄ f g ‚â´ coequalizer.desc k h = k :=\n  colimit.Œπ_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.œÄ_colimMap_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCoequalizer f g\nX' Y' Z : C\nf' g' : Quiver.Hom X' Y'\ninst‚úù : CategoryTheory.Limits.HasCoequalizer f' g'\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nwf : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p f')\nwg : Eq (CategoryTheory.CategoryStruct.comp g q) (CategoryTheory.CategoryStruct.comp p g')\nh : Quiver.Hom Y' Z\nwh : Eq (CategoryTheory.CategoryStruct.comp f' h) (CategoryTheory.CategoryStruct.comp g' h)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap (CategoryTheory.Limits.parallelPairHom f g f' g' p q wf wg)) (CategoryTheory.Limits.coequalizer.desc h wh))) (CategoryTheory.CategoryStruct.comp q h)","decl":"theorem coequalizer.œÄ_colimMap_desc {X' Y' Z : C} (f' g' : X' ‚ü∂ Y') [HasCoequalizer f' g']\n    (p : X ‚ü∂ X') (q : Y ‚ü∂ Y') (wf : f ‚â´ q = p ‚â´ f') (wg : g ‚â´ q = p ‚â´ g') (h : Y' ‚ü∂ Z)\n    (wh : f' ‚â´ h = g' ‚â´ h) :\n    coequalizer.œÄ f g ‚â´ colimMap (parallelPairHom f g f' g' p q wf wg) ‚â´ coequalizer.desc h wh =\n      q ‚â´ h := by\n  rw [Œπ_colimMap_assoc, parallelPairHom_app_one, coequalizer.œÄ_desc]\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCoequalizer f g\nW : C\nk l : Quiver.Hom (CategoryTheory.Limits.coequalizer f g) W\n‚ä¢ Iff (Eq k l) (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ f g) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ f g) l))","decl":"/-- Two maps from a coequalizer are equal if they are equal when composed with the coequalizer\n    map -/\n@[ext]\ntheorem coequalizer.hom_ext {W : C} {k l : coequalizer f g ‚ü∂ W}\n    (h : coequalizer.œÄ f g ‚â´ k = coequalizer.œÄ f g ‚â´ l) : k = l :=\n  Cofork.IsColimit.hom_ext (colimit.isColimit _) h\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCoequalizer f g\nW : C\nk l : Quiver.Hom (CategoryTheory.Limits.coequalizer f g) W\nh : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ f g) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ f g) l)\n‚ä¢ Eq k l","decl":"/-- Two maps from a coequalizer are equal if they are equal when composed with the coequalizer\n    map -/\n@[ext]\ntheorem coequalizer.hom_ext {W : C} {k l : coequalizer f g ‚ü∂ W}\n    (h : coequalizer.œÄ f g ‚â´ k = coequalizer.œÄ f g ‚â´ l) : k = l :=\n  Cofork.IsColimit.hom_ext (colimit.isColimit _) h\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.existsUnique","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCoequalizer f g\nW : C\nk : Quiver.Hom Y W\nh : Eq (CategoryTheory.CategoryStruct.comp f k) (CategoryTheory.CategoryStruct.comp g k)\n‚ä¢ ExistsUnique fun d => Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ f g) d) k","decl":"theorem coequalizer.existsUnique {W : C} (k : Y ‚ü∂ W) (h : f ‚â´ k = g ‚â´ k) :\n    ‚àÉ! d : coequalizer f g ‚ü∂ W, coequalizer.œÄ f g ‚â´ d = k :=\n  Cofork.IsColimit.existsUnique (colimit.isColimit _) _ h\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.œÄ_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCoequalizer f g\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.coequalizer.œÄ f g)","decl":"/-- A coequalizer morphism is an epimorphism -/\ninstance coequalizer.œÄ_epi : Epi (coequalizer.œÄ f g) where\n  left_cancellation _ _ w := coequalizer.hom_ext w\n\n"}
{"name":"CategoryTheory.Limits.epi_of_isColimit_cofork","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nc : CategoryTheory.Limits.Cofork f g\ni : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.Epi c.œÄ","decl":"/-- The coequalizer morphism in any colimit cocone is an epimorphism. -/\ntheorem epi_of_isColimit_cofork {c : Cofork f g} (i : IsColimit c) : Epi c.œÄ :=\n  { left_cancellation := fun _ _ w => Cofork.IsColimit.hom_ext i w }\n\n"}
{"name":"CategoryTheory.Limits.isIso_colimit_cocone_parallelPair_of_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nh‚ÇÄ : Eq f g\nc : CategoryTheory.Limits.Cofork f g\nh : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.IsIso c.œÄ","decl":"/-- Every coequalizer of `(f, g)`, where `f = g`, is an isomorphism. -/\ntheorem isIso_colimit_cocone_parallelPair_of_eq (h‚ÇÄ : f = g) {c : Cofork f g} (h : IsColimit c) :\n    IsIso c.œÄ :=\n  Iso.isIso_hom <| IsColimit.coconePointUniqueUpToIso (isColimitIdCofork h‚ÇÄ) h\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.œÄ_of_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCoequalizer f g\nh : Eq f g\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.coequalizer.œÄ f g)","decl":"/-- The coequalizer of `(f, g)`, where `f = g`, is an isomorphism. -/\ntheorem coequalizer.œÄ_of_eq [HasCoequalizer f g] (h : f = g) : IsIso (coequalizer.œÄ f g) :=\n  isIso_colimit_cocone_parallelPair_of_eq h <| colimit.isColimit _\n\n"}
{"name":"CategoryTheory.Limits.isIso_colimit_cocone_parallelPair_of_self","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.Cofork f f\nh : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.IsIso c.œÄ","decl":"/-- Every coequalizer of `(f, f)` is an isomorphism. -/\ntheorem isIso_colimit_cocone_parallelPair_of_self {c : Cofork f f} (h : IsColimit c) : IsIso c.œÄ :=\n  isIso_colimit_cocone_parallelPair_of_eq rfl h\n\n"}
{"name":"CategoryTheory.Limits.isIso_limit_cocone_parallelPair_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nc : CategoryTheory.Limits.Cofork f g\nh : CategoryTheory.Limits.IsColimit c\ninst‚úù : CategoryTheory.Mono c.œÄ\n‚ä¢ CategoryTheory.IsIso c.œÄ","decl":"/-- A coequalizer that is a monomorphism is an isomorphism. -/\ntheorem isIso_limit_cocone_parallelPair_of_epi {c : Cofork f g} (h : IsColimit c) [Mono c.œÄ] :\n    IsIso c.œÄ :=\n  isIso_colimit_cocone_parallelPair_of_eq ((cancel_mono _).1 (Cofork.condition c)) h\n\n"}
{"name":"CategoryTheory.Limits.eq_of_mono_cofork_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nt : CategoryTheory.Limits.Cofork f g\ninst‚úù : CategoryTheory.Mono t.œÄ\n‚ä¢ Eq f g","decl":"/-- Two morphisms are equal if there is a cofork whose projection is mono. -/\ntheorem eq_of_mono_cofork_œÄ (t : Cofork f g) [Mono (Cofork.œÄ t)] : f = g :=\n  (cancel_mono (Cofork.œÄ t)).1 <| Cofork.condition t\n\n"}
{"name":"CategoryTheory.Limits.eq_of_mono_coequalizer","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCoequalizer f g\ninst‚úù : CategoryTheory.Mono (CategoryTheory.Limits.coequalizer.œÄ f g)\n‚ä¢ Eq f g","decl":"/-- If the coequalizer of two morphisms is a monomorphism, then the two morphisms are equal. -/\ntheorem eq_of_mono_coequalizer [HasCoequalizer f g] [Mono (coequalizer.œÄ f g)] : f = g :=\n  (cancel_mono (coequalizer.œÄ f g)).1 <| coequalizer.condition _ _\n\n"}
{"name":"CategoryTheory.Limits.hasCoequalizer_of_self","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.Limits.HasCoequalizer f f","decl":"instance hasCoequalizer_of_self : HasCoequalizer f f :=\n  HasColimit.mk\n    { cocone := idCofork rfl\n      isColimit := isColimitIdCofork rfl }\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.œÄ_of_self","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.coequalizer.œÄ f f)","decl":"/-- The coequalizer projection for `(f, f)` is an isomorphism. -/\ninstance coequalizer.œÄ_of_self : IsIso (coequalizer.œÄ f f) :=\n  coequalizer.œÄ_of_eq rfl\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.isoTargetOfSelf_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Limits.coequalizer.isoTargetOfSelf f).hom (CategoryTheory.Limits.coequalizer.desc (CategoryTheory.CategoryStruct.id Y) ‚ãØ)","decl":"@[simp]\ntheorem coequalizer.isoTargetOfSelf_hom :\n    (coequalizer.isoTargetOfSelf f).hom = coequalizer.desc (ùüô Y) (by simp) := by\n  ext\n  simp [coequalizer.isoTargetOfSelf]\n\n"}
{"name":"CategoryTheory.Limits.coequalizer.isoTargetOfSelf_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Limits.coequalizer.isoTargetOfSelf f).inv (CategoryTheory.Limits.coequalizer.œÄ f f)","decl":"@[simp]\ntheorem coequalizer.isoTargetOfSelf_inv : (coequalizer.isoTargetOfSelf f).inv = coequalizer.œÄ f f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.equalizerComparison_comp_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : CategoryTheory.Limits.HasEqualizer f g\ninst‚úù : CategoryTheory.Limits.HasEqualizer (G.map f) (G.map g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerComparison f g G) (CategoryTheory.Limits.equalizer.Œπ (G.map f) (G.map g))) (G.map (CategoryTheory.Limits.equalizer.Œπ f g))","decl":"@[reassoc (attr := simp)]\ntheorem equalizerComparison_comp_œÄ [HasEqualizer f g] [HasEqualizer (G.map f) (G.map g)] :\n    equalizerComparison f g G ‚â´ equalizer.Œπ (G.map f) (G.map g) = G.map (equalizer.Œπ f g) :=\n  equalizer.lift_Œπ _ _\n\n"}
{"name":"CategoryTheory.Limits.equalizerComparison_comp_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : CategoryTheory.Limits.HasEqualizer f g\ninst‚úù : CategoryTheory.Limits.HasEqualizer (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerComparison f g G) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.Œπ (G.map f) (G.map g)) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.equalizer.Œπ f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem equalizerComparison_comp_œÄ [HasEqualizer f g] [HasEqualizer (G.map f) (G.map g)] :\n    equalizerComparison f g G ‚â´ equalizer.Œπ (G.map f) (G.map g) = G.map (equalizer.Œπ f g) :=\n  equalizer.lift_Œπ _ _\n\n"}
{"name":"CategoryTheory.Limits.map_lift_equalizerComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : CategoryTheory.Limits.HasEqualizer f g\ninst‚úù : CategoryTheory.Limits.HasEqualizer (G.map f) (G.map g)\nZ : C\nh : Quiver.Hom Z X\nw : Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.equalizer.lift h w)) (CategoryTheory.Limits.equalizerComparison f g G)) (CategoryTheory.Limits.equalizer.lift (G.map h) ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_equalizerComparison [HasEqualizer f g] [HasEqualizer (G.map f) (G.map g)] {Z : C}\n    {h : Z ‚ü∂ X} (w : h ‚â´ f = h ‚â´ g) :\n    G.map (equalizer.lift h w) ‚â´ equalizerComparison f g G =\n      equalizer.lift (G.map h) (by simp only [‚Üê G.map_comp, w]) := by\n  apply equalizer.hom_ext\n  simp [‚Üê G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.map_lift_equalizerComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : CategoryTheory.Limits.HasEqualizer f g\ninst‚úù : CategoryTheory.Limits.HasEqualizer (G.map f) (G.map g)\nZ‚úù : C\nh‚úù : Quiver.Hom Z‚úù X\nw : Eq (CategoryTheory.CategoryStruct.comp h‚úù f) (CategoryTheory.CategoryStruct.comp h‚úù g)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.equalizer (G.map f) (G.map g)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.equalizer.lift h‚úù w)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizerComparison f g G) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.equalizer.lift (G.map h‚úù) ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_equalizerComparison [HasEqualizer f g] [HasEqualizer (G.map f) (G.map g)] {Z : C}\n    {h : Z ‚ü∂ X} (w : h ‚â´ f = h ‚â´ g) :\n    G.map (equalizer.lift h w) ‚â´ equalizerComparison f g G =\n      equalizer.lift (G.map h) (by simp only [‚Üê G.map_comp, w]) := by\n  apply equalizer.hom_ext\n  simp [‚Üê G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.Œπ_comp_coequalizerComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : CategoryTheory.Limits.HasCoequalizer f g\ninst‚úù : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.coequalizer f g)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ (G.map f) (G.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizerComparison f g G) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.coequalizer.œÄ f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_comp_coequalizerComparison [HasCoequalizer f g] [HasCoequalizer (G.map f) (G.map g)] :\n    coequalizer.œÄ _ _ ‚â´ coequalizerComparison f g G = G.map (coequalizer.œÄ _ _) :=\n  coequalizer.œÄ_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.Œπ_comp_coequalizerComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : CategoryTheory.Limits.HasCoequalizer f g\ninst‚úù : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ (G.map f) (G.map g)) (CategoryTheory.Limits.coequalizerComparison f g G)) (G.map (CategoryTheory.Limits.coequalizer.œÄ f g))","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_comp_coequalizerComparison [HasCoequalizer f g] [HasCoequalizer (G.map f) (G.map g)] :\n    coequalizer.œÄ _ _ ‚â´ coequalizerComparison f g G = G.map (coequalizer.œÄ _ _) :=\n  coequalizer.œÄ_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.coequalizerComparison_map_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : CategoryTheory.Limits.HasCoequalizer f g\ninst‚úù : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\nZ‚úù : C\nh‚úù : Quiver.Hom Y Z‚úù\nw : Eq (CategoryTheory.CategoryStruct.comp f h‚úù) (CategoryTheory.CategoryStruct.comp g h‚úù)\nZ : D\nh : Quiver.Hom (G.obj Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizerComparison f g G) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.coequalizer.desc h‚úù w)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.desc (G.map h‚úù) ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem coequalizerComparison_map_desc [HasCoequalizer f g] [HasCoequalizer (G.map f) (G.map g)]\n    {Z : C} {h : Y ‚ü∂ Z} (w : f ‚â´ h = g ‚â´ h) :\n    coequalizerComparison f g G ‚â´ G.map (coequalizer.desc h w) =\n      coequalizer.desc (G.map h) (by simp only [‚Üê G.map_comp, w]) := by\n  apply coequalizer.hom_ext\n  simp [‚Üê G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.coequalizerComparison_map_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\ninst‚úù¬π : CategoryTheory.Limits.HasCoequalizer f g\ninst‚úù : CategoryTheory.Limits.HasCoequalizer (G.map f) (G.map g)\nZ : C\nh : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizerComparison f g G) (G.map (CategoryTheory.Limits.coequalizer.desc h w))) (CategoryTheory.Limits.coequalizer.desc (G.map h) ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem coequalizerComparison_map_desc [HasCoequalizer f g] [HasCoequalizer (G.map f) (G.map g)]\n    {Z : C} {h : Y ‚ü∂ Z} (w : f ‚â´ h = g ‚â´ h) :\n    coequalizerComparison f g G ‚â´ G.map (coequalizer.desc h w) =\n      coequalizer.desc (G.map h) (by simp only [‚Üê G.map_comp, w]) := by\n  apply coequalizer.hom_ext\n  simp [‚Üê G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.hasEqualizers_of_hasLimit_parallelPair","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : ‚àÄ {X Y : C} {f g : Quiver.Hom X Y}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair f g)\n‚ä¢ CategoryTheory.Limits.HasEqualizers C","decl":"/-- If `C` has all limits of diagrams `parallelPair f g`, then it has all equalizers -/\ntheorem hasEqualizers_of_hasLimit_parallelPair\n    [‚àÄ {X Y : C} {f g : X ‚ü∂ Y}, HasLimit (parallelPair f g)] : HasEqualizers C :=\n  { has_limit := fun F => hasLimitOfIso (diagramIsoParallelPair F).symm }\n\n"}
{"name":"CategoryTheory.Limits.hasCoequalizers_of_hasColimit_parallelPair","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : ‚àÄ {X Y : C} {f g : Quiver.Hom X Y}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelPair f g)\n‚ä¢ CategoryTheory.Limits.HasCoequalizers C","decl":"/-- If `C` has all colimits of diagrams `parallelPair f g`, then it has all coequalizers -/\ntheorem hasCoequalizers_of_hasColimit_parallelPair\n    [‚àÄ {X Y : C} {f g : X ‚ü∂ Y}, HasColimit (parallelPair f g)] : HasCoequalizers C :=\n  { has_colimit := fun F => hasColimitOfIso (diagramIsoParallelPair F) }\n\n"}
{"name":"CategoryTheory.Limits.coneOfIsSplitMono_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX‚úù Y : C\nf : Quiver.Hom X‚úù Y\ninst‚úù : CategoryTheory.IsSplitMono f\nX : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.coneOfIsSplitMono f).œÄ.app X) (CategoryTheory.Limits.WalkingParallelPair.rec (motive := fun t => Eq X t ‚Üí Quiver.Hom X‚úù ((CategoryTheory.Limits.parallelPair (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.retraction f) f)).obj X)) (fun h => Eq.rec f ‚ãØ) (fun h => Eq.rec f ‚ãØ) X ‚ãØ)","decl":"/-- A split mono `f` equalizes `(retraction f ‚â´ f)` and `(ùüô Y)`.\nHere we build the cone, and show in `isSplitMonoEqualizes` that it is a limit cone.\n-/\n-- @[simps (config := { rhsMd := semireducible })] Porting note: no semireducible\n@[simps!]\nnoncomputable def coneOfIsSplitMono : Fork (ùüô Y) (retraction f ‚â´ f) :=\n  Fork.ofŒπ f (by simp)\n\n"}
{"name":"CategoryTheory.Limits.coneOfIsSplitMono_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsSplitMono f\n‚ä¢ Eq (CategoryTheory.Limits.coneOfIsSplitMono f).pt X","decl":"/-- A split mono `f` equalizes `(retraction f ‚â´ f)` and `(ùüô Y)`.\nHere we build the cone, and show in `isSplitMonoEqualizes` that it is a limit cone.\n-/\n-- @[simps (config := { rhsMd := semireducible })] Porting note: no semireducible\n@[simps!]\nnoncomputable def coneOfIsSplitMono : Fork (ùüô Y) (retraction f ‚â´ f) :=\n  Fork.ofŒπ f (by simp)\n\n"}
{"name":"CategoryTheory.Limits.coneOfIsSplitMono_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsSplitMono f\n‚ä¢ Eq (CategoryTheory.Limits.coneOfIsSplitMono f).Œπ f","decl":"@[simp]\ntheorem coneOfIsSplitMono_Œπ : (coneOfIsSplitMono f).Œπ = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.hasEqualizer_comp_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasEqualizer f g\nZ : C\nh : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Mono h\n‚ä¢ CategoryTheory.Limits.HasEqualizer (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[instance]\ntheorem hasEqualizer_comp_mono [HasEqualizer f g] {Z : C} (h : Y ‚ü∂ Z) [Mono h] :\n    HasEqualizer (f ‚â´ h) (g ‚â´ h) :=\n  ‚ü®‚ü®{   cone := _\n        isLimit := isEqualizerCompMono (limit.isLimit _) h }‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.splitMonoOfIdempotentOfIsLimitFork_retraction","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nf : Quiver.Hom X X\nhf : Eq (CategoryTheory.CategoryStruct.comp f f) f\nc : CategoryTheory.Limits.Fork (CategoryTheory.CategoryStruct.id X) f\ni : CategoryTheory.Limits.IsLimit c\n‚ä¢ Eq (CategoryTheory.Limits.splitMonoOfIdempotentOfIsLimitFork C hf i).retraction (i.lift (CategoryTheory.Limits.Fork.ofŒπ f ‚ãØ))","decl":"/-- An equalizer of an idempotent morphism and the identity is split mono. -/\n@[simps]\ndef splitMonoOfIdempotentOfIsLimitFork {X : C} {f : X ‚ü∂ X} (hf : f ‚â´ f = f) {c : Fork (ùüô X) f}\n    (i : IsLimit c) : SplitMono c.Œπ where\n  retraction := i.lift (Fork.ofŒπ f (by simp [hf]))\n  id := by\n    letI := mono_of_isLimit_fork i\n    rw [‚Üê cancel_mono_id c.Œπ, Category.assoc, Fork.IsLimit.lift_Œπ, Fork.Œπ_ofŒπ, ‚Üê c.condition]\n    exact Category.comp_id c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.coconeOfIsSplitEpi_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX‚úù Y : C\nf : Quiver.Hom X‚úù Y\ninst‚úù : CategoryTheory.IsSplitEpi f\nX : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Limits.coconeOfIsSplitEpi f).Œπ.app X) (CategoryTheory.Limits.WalkingParallelPair.rec f f X)","decl":"/-- A split epi `f` coequalizes `(f ‚â´ section_ f)` and `(ùüô X)`.\nHere we build the cocone, and show in `isSplitEpiCoequalizes` that it is a colimit cocone.\n-/\n-- @[simps (config := { rhsMd := semireducible })] Porting note: no semireducible\n@[simps!]\nnoncomputable def coconeOfIsSplitEpi : Cofork (ùüô X) (f ‚â´ section_ f) :=\n  Cofork.ofœÄ f (by simp)\n\n"}
{"name":"CategoryTheory.Limits.coconeOfIsSplitEpi_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsSplitEpi f\n‚ä¢ Eq (CategoryTheory.Limits.coconeOfIsSplitEpi f).pt Y","decl":"/-- A split epi `f` coequalizes `(f ‚â´ section_ f)` and `(ùüô X)`.\nHere we build the cocone, and show in `isSplitEpiCoequalizes` that it is a colimit cocone.\n-/\n-- @[simps (config := { rhsMd := semireducible })] Porting note: no semireducible\n@[simps!]\nnoncomputable def coconeOfIsSplitEpi : Cofork (ùüô X) (f ‚â´ section_ f) :=\n  Cofork.ofœÄ f (by simp)\n\n"}
{"name":"CategoryTheory.Limits.coconeOfIsSplitEpi_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsSplitEpi f\n‚ä¢ Eq (CategoryTheory.Limits.coconeOfIsSplitEpi f).œÄ f","decl":"@[simp]\ntheorem coconeOfIsSplitEpi_œÄ : (coconeOfIsSplitEpi f).œÄ = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.hasCoequalizer_epi_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCoequalizer f g\nW : C\nh : Quiver.Hom W X\ninst‚úù : CategoryTheory.Epi h\n‚ä¢ CategoryTheory.Limits.HasCoequalizer (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)","decl":"theorem hasCoequalizer_epi_comp [HasCoequalizer f g] {W : C} (h : W ‚ü∂ X) [Epi h] :\n    HasCoequalizer (h ‚â´ f) (h ‚â´ g) :=\n  ‚ü®‚ü®{   cocone := _\n        isColimit := isCoequalizerEpiComp (colimit.isColimit _) h }‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.splitEpiOfIdempotentOfIsColimitCofork_section_","module":"Mathlib.CategoryTheory.Limits.Shapes.Equalizers","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nf : Quiver.Hom X X\nhf : Eq (CategoryTheory.CategoryStruct.comp f f) f\nc : CategoryTheory.Limits.Cofork (CategoryTheory.CategoryStruct.id X) f\ni : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq (CategoryTheory.Limits.splitEpiOfIdempotentOfIsColimitCofork C hf i).section_ (i.desc (CategoryTheory.Limits.Cofork.ofœÄ f ‚ãØ))","decl":"/-- A coequalizer of an idempotent morphism and the identity is split epi. -/\n@[simps]\ndef splitEpiOfIdempotentOfIsColimitCofork {X : C} {f : X ‚ü∂ X} (hf : f ‚â´ f = f) {c : Cofork (ùüô X) f}\n    (i : IsColimit c) : SplitEpi c.œÄ where\n  section_ := i.desc (Cofork.ofœÄ f (by simp [hf]))\n  id := by\n    letI := epi_of_isColimit_cofork i\n    rw [‚Üê cancel_epi_id c.œÄ, ‚Üê Category.assoc, Cofork.IsColimit.œÄ_desc, Cofork.œÄ_ofœÄ, ‚Üê\n      c.condition]\n    exact Category.id_comp _\n\n"}
