{"name":"QuotientAddGroup.leftRel_apply","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nx y : α\n⊢ Iff ((QuotientAddGroup.leftRel s) x y) (Membership.mem s (HAdd.hAdd (Neg.neg x) y))","decl":"@[to_additive]\ntheorem leftRel_apply {x y : α} : leftRel s x y ↔ x⁻¹ * y ∈ s :=\n  calc\n    (∃ a : s.op, y * MulOpposite.unop a = x) ↔ ∃ a : s, y * a = x :=\n      s.equivOp.symm.exists_congr_left\n    _ ↔ ∃ a : s, x⁻¹ * y = a⁻¹ := by\n      simp only [inv_mul_eq_iff_eq_mul, Subgroup.coe_inv, eq_mul_inv_iff_mul_eq]\n    _ ↔ x⁻¹ * y ∈ s := by simp [exists_inv_mem_iff_exists_mem]\n\n"}
{"name":"QuotientGroup.leftRel_apply","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nx y : α\n⊢ Iff ((QuotientGroup.leftRel s) x y) (Membership.mem s (HMul.hMul (Inv.inv x) y))","decl":"@[to_additive]\ntheorem leftRel_apply {x y : α} : leftRel s x y ↔ x⁻¹ * y ∈ s :=\n  calc\n    (∃ a : s.op, y * MulOpposite.unop a = x) ↔ ∃ a : s, y * a = x :=\n      s.equivOp.symm.exists_congr_left\n    _ ↔ ∃ a : s, x⁻¹ * y = a⁻¹ := by\n      simp only [inv_mul_eq_iff_eq_mul, Subgroup.coe_inv, eq_mul_inv_iff_mul_eq]\n    _ ↔ x⁻¹ * y ∈ s := by simp [exists_inv_mem_iff_exists_mem]\n\n"}
{"name":"QuotientAddGroup.leftRel_eq","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\n⊢ Eq ⇑(QuotientAddGroup.leftRel s) fun x y => Membership.mem s (HAdd.hAdd (Neg.neg x) y)","decl":"@[to_additive]\ntheorem leftRel_eq : ⇑(leftRel s) = fun x y => x⁻¹ * y ∈ s :=\n  funext₂ <| by\n    simp only [eq_iff_iff]\n    apply leftRel_apply\n\n"}
{"name":"QuotientGroup.leftRel_eq","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\n⊢ Eq ⇑(QuotientGroup.leftRel s) fun x y => Membership.mem s (HMul.hMul (Inv.inv x) y)","decl":"@[to_additive]\ntheorem leftRel_eq : ⇑(leftRel s) = fun x y => x⁻¹ * y ∈ s :=\n  funext₂ <| by\n    simp only [eq_iff_iff]\n    apply leftRel_apply\n\n"}
{"name":"QuotientGroup.rightRel_apply","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nx y : α\n⊢ Iff ((QuotientGroup.rightRel s) x y) (Membership.mem s (HMul.hMul y (Inv.inv x)))","decl":"@[to_additive]\ntheorem rightRel_apply {x y : α} : rightRel s x y ↔ y * x⁻¹ ∈ s :=\n  calc\n    (∃ a : s, (a : α) * y = x) ↔ ∃ a : s, y * x⁻¹ = a⁻¹ := by\n      simp only [mul_inv_eq_iff_eq_mul, Subgroup.coe_inv, eq_inv_mul_iff_mul_eq]\n    _ ↔ y * x⁻¹ ∈ s := by simp [exists_inv_mem_iff_exists_mem]\n\n"}
{"name":"QuotientAddGroup.rightRel_apply","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nx y : α\n⊢ Iff ((QuotientAddGroup.rightRel s) x y) (Membership.mem s (HAdd.hAdd y (Neg.neg x)))","decl":"@[to_additive]\ntheorem rightRel_apply {x y : α} : rightRel s x y ↔ y * x⁻¹ ∈ s :=\n  calc\n    (∃ a : s, (a : α) * y = x) ↔ ∃ a : s, y * x⁻¹ = a⁻¹ := by\n      simp only [mul_inv_eq_iff_eq_mul, Subgroup.coe_inv, eq_inv_mul_iff_mul_eq]\n    _ ↔ y * x⁻¹ ∈ s := by simp [exists_inv_mem_iff_exists_mem]\n\n"}
{"name":"QuotientAddGroup.rightRel_eq","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\n⊢ Eq ⇑(QuotientAddGroup.rightRel s) fun x y => Membership.mem s (HAdd.hAdd y (Neg.neg x))","decl":"@[to_additive]\ntheorem rightRel_eq : ⇑(rightRel s) = fun x y => y * x⁻¹ ∈ s :=\n  funext₂ <| by\n    simp only [eq_iff_iff]\n    apply rightRel_apply\n\n"}
{"name":"QuotientGroup.rightRel_eq","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\n⊢ Eq ⇑(QuotientGroup.rightRel s) fun x y => Membership.mem s (HMul.hMul y (Inv.inv x))","decl":"@[to_additive]\ntheorem rightRel_eq : ⇑(rightRel s) = fun x y => y * x⁻¹ ∈ s :=\n  funext₂ <| by\n    simp only [eq_iff_iff]\n    apply rightRel_apply\n\n"}
{"name":"QuotientAddGroup.mk_surjective","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\n⊢ Function.Surjective QuotientAddGroup.mk","decl":"@[to_additive]\ntheorem mk_surjective : Function.Surjective <| @mk _ _ s :=\n  Quotient.mk''_surjective\n\n"}
{"name":"QuotientGroup.mk_surjective","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\n⊢ Function.Surjective QuotientGroup.mk","decl":"@[to_additive]\ntheorem mk_surjective : Function.Surjective <| @mk _ _ s :=\n  Quotient.mk''_surjective\n\n"}
{"name":"QuotientGroup.range_mk","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\n⊢ Eq (Set.range QuotientGroup.mk) Set.univ","decl":"@[to_additive (attr := simp)]\nlemma range_mk : range (QuotientGroup.mk (s := s)) = univ := range_eq_univ.mpr mk_surjective\n\n"}
{"name":"QuotientAddGroup.range_mk","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\n⊢ Eq (Set.range QuotientAddGroup.mk) Set.univ","decl":"@[to_additive (attr := simp)]\nlemma range_mk : range (QuotientGroup.mk (s := s)) = univ := range_eq_univ.mpr mk_surjective\n\n"}
{"name":"QuotientGroup.induction_on","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nC : HasQuotient.Quotient α s → Prop\nx : HasQuotient.Quotient α s\nH : ∀ (z : α), C ↑z\n⊢ C x","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on {C : α ⧸ s → Prop} (x : α ⧸ s) (H : ∀ z, C (QuotientGroup.mk z)) : C x :=\n  Quotient.inductionOn' x H\n\n"}
{"name":"QuotientAddGroup.induction_on","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nC : HasQuotient.Quotient α s → Prop\nx : HasQuotient.Quotient α s\nH : ∀ (z : α), C ↑z\n⊢ C x","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on {C : α ⧸ s → Prop} (x : α ⧸ s) (H : ∀ z, C (QuotientGroup.mk z)) : C x :=\n  Quotient.inductionOn' x H\n\n"}
{"name":"QuotientAddGroup.induction_on'","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nC : HasQuotient.Quotient α s → Prop\nx : HasQuotient.Quotient α s\nH : ∀ (z : α), C ↑z\n⊢ C x","decl":"@[to_additive] alias induction_on' := induction_on\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"QuotientGroup.induction_on'","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nC : HasQuotient.Quotient α s → Prop\nx : HasQuotient.Quotient α s\nH : ∀ (z : α), C ↑z\n⊢ C x","decl":"@[to_additive] alias induction_on' := induction_on\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"QuotientGroup.quotient_liftOn_mk","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nβ : Sort u_2\nf : α → β\nh : ∀ (a b : α), (QuotientGroup.leftRel s) a b → Eq (f a) (f b)\nx : α\n⊢ Eq (Quotient.liftOn' (↑x) f h) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem quotient_liftOn_mk {β} (f : α → β) (h) (x : α) : Quotient.liftOn' (x : α ⧸ s) f h = f x :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.quotient_liftOn_mk","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nβ : Sort u_2\nf : α → β\nh : ∀ (a b : α), (QuotientAddGroup.leftRel s) a b → Eq (f a) (f b)\nx : α\n⊢ Eq (Quotient.liftOn' (↑x) f h) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem quotient_liftOn_mk {β} (f : α → β) (h) (x : α) : Quotient.liftOn' (x : α ⧸ s) f h = f x :=\n  rfl\n\n"}
{"name":"QuotientGroup.forall_mk","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nC : HasQuotient.Quotient α s → Prop\n⊢ Iff (∀ (x : HasQuotient.Quotient α s), C x) (∀ (x : α), C ↑x)","decl":"@[to_additive]\ntheorem forall_mk {C : α ⧸ s → Prop} : (∀ x : α ⧸ s, C x) ↔ ∀ x : α, C x :=\n  mk_surjective.forall\n\n"}
{"name":"QuotientAddGroup.forall_mk","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nC : HasQuotient.Quotient α s → Prop\n⊢ Iff (∀ (x : HasQuotient.Quotient α s), C x) (∀ (x : α), C ↑x)","decl":"@[to_additive]\ntheorem forall_mk {C : α ⧸ s → Prop} : (∀ x : α ⧸ s, C x) ↔ ∀ x : α, C x :=\n  mk_surjective.forall\n\n"}
{"name":"QuotientGroup.exists_mk","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nC : HasQuotient.Quotient α s → Prop\n⊢ Iff (Exists fun x => C x) (Exists fun x => C ↑x)","decl":"@[to_additive]\ntheorem exists_mk {C : α ⧸ s → Prop} : (∃ x : α ⧸ s, C x) ↔ ∃ x : α, C x :=\n  mk_surjective.exists\n\n"}
{"name":"QuotientAddGroup.exists_mk","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nC : HasQuotient.Quotient α s → Prop\n⊢ Iff (Exists fun x => C x) (Exists fun x => C ↑x)","decl":"@[to_additive]\ntheorem exists_mk {C : α ⧸ s → Prop} : (∃ x : α ⧸ s, C x) ↔ ∃ x : α, C x :=\n  mk_surjective.exists\n\n"}
{"name":"QuotientGroup.eq","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\na b : α\n⊢ Iff (Eq ↑a ↑b) (Membership.mem s (HMul.hMul (Inv.inv a) b))","decl":"@[to_additive]\nprotected theorem eq {a b : α} : (a : α ⧸ s) = b ↔ a⁻¹ * b ∈ s :=\n  calc\n    _ ↔ leftRel s a b := Quotient.eq''\n    _ ↔ _ := by rw [leftRel_apply]\n\n"}
{"name":"QuotientAddGroup.eq","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\na b : α\n⊢ Iff (Eq ↑a ↑b) (Membership.mem s (HAdd.hAdd (Neg.neg a) b))","decl":"@[to_additive]\nprotected theorem eq {a b : α} : (a : α ⧸ s) = b ↔ a⁻¹ * b ∈ s :=\n  calc\n    _ ↔ leftRel s a b := Quotient.eq''\n    _ ↔ _ := by rw [leftRel_apply]\n\n"}
{"name":"QuotientAddGroup.eq'","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\na b : α\n⊢ Iff (Eq ↑a ↑b) (Membership.mem s (HAdd.hAdd (Neg.neg a) b))","decl":"@[to_additive (attr := deprecated \"No deprecation message was provided.\" (since := \"2024-08-04\"))]\nalias eq' := QuotientGroup.eq\n\n"}
{"name":"QuotientGroup.eq'","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\na b : α\n⊢ Iff (Eq ↑a ↑b) (Membership.mem s (HMul.hMul (Inv.inv a) b))","decl":"@[to_additive (attr := deprecated \"No deprecation message was provided.\" (since := \"2024-08-04\"))]\nalias eq' := QuotientGroup.eq\n\n"}
{"name":"QuotientGroup.out_eq'","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\na : HasQuotient.Quotient α s\n⊢ Eq (↑(Quotient.out a)) a","decl":"@[to_additive]\ntheorem out_eq' (a : α ⧸ s) : mk a.out = a :=\n  Quotient.out_eq' a\n\n"}
{"name":"QuotientAddGroup.out_eq'","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\na : HasQuotient.Quotient α s\n⊢ Eq (↑(Quotient.out a)) a","decl":"@[to_additive]\ntheorem out_eq' (a : α ⧸ s) : mk a.out = a :=\n  Quotient.out_eq' a\n\n"}
{"name":"QuotientAddGroup.mk_out_eq_mul","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\ng : α\n⊢ Exists fun h => Eq (Quotient.out ↑g) (HAdd.hAdd g ↑h)","decl":"@[to_additive QuotientAddGroup.mk_out_eq_mul]\ntheorem mk_out_eq_mul (g : α) : ∃ h : s, (mk g : α ⧸ s).out = g * h :=\n  ⟨⟨g⁻¹ * (mk g).out, QuotientGroup.eq.mp (mk g).out_eq'.symm⟩, by rw [mul_inv_cancel_left]⟩\n\n"}
{"name":"QuotientGroup.mk_out_eq_mul","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\ng : α\n⊢ Exists fun h => Eq (Quotient.out ↑g) (HMul.hMul g ↑h)","decl":"@[to_additive QuotientAddGroup.mk_out_eq_mul]\ntheorem mk_out_eq_mul (g : α) : ∃ h : s, (mk g : α ⧸ s).out = g * h :=\n  ⟨⟨g⁻¹ * (mk g).out, QuotientGroup.eq.mp (mk g).out_eq'.symm⟩, by rw [mul_inv_cancel_left]⟩\n\n"}
{"name":"QuotientAddGroup.mk_out'_eq_mul","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\ng : α\n⊢ Exists fun h => Eq (Quotient.out ↑g) (HAdd.hAdd g ↑h)","decl":"@[to_additive QuotientAddGroup.mk_out'_eq_mul]\nalias mk_out'_eq_mul := mk_out_eq_mul\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"QuotientGroup.mk_out'_eq_mul","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\ng : α\n⊢ Exists fun h => Eq (Quotient.out ↑g) (HMul.hMul g ↑h)","decl":"@[to_additive QuotientAddGroup.mk_out'_eq_mul]\nalias mk_out'_eq_mul := mk_out_eq_mul\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"QuotientGroup.mk_mul_of_mem","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nb a : α\nhb : Membership.mem s b\n⊢ Eq ↑(HMul.hMul a b) ↑a","decl":"@[to_additive (attr := simp)]\ntheorem mk_mul_of_mem (a : α) (hb : b ∈ s) : (mk (a * b) : α ⧸ s) = mk a := by\n  rwa [QuotientGroup.eq, mul_inv_rev, inv_mul_cancel_right, s.inv_mem_iff]\n\n"}
{"name":"QuotientAddGroup.mk_add_of_mem","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nb a : α\nhb : Membership.mem s b\n⊢ Eq ↑(HAdd.hAdd a b) ↑a","decl":"@[to_additive (attr := simp)]\ntheorem mk_mul_of_mem (a : α) (hb : b ∈ s) : (mk (a * b) : α ⧸ s) = mk a := by\n  rwa [QuotientGroup.eq, mul_inv_rev, inv_mul_cancel_right, s.inv_mem_iff]\n\n"}
{"name":"QuotientAddGroup.preimage_image_mk","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nN : AddSubgroup α\ns : Set α\n⊢ Eq (Set.preimage QuotientAddGroup.mk (Set.image QuotientAddGroup.mk s)) (Set.iUnion fun x => Set.preimage (fun x_1 => HAdd.hAdd x_1 ↑x) s)","decl":"@[to_additive]\ntheorem preimage_image_mk (N : Subgroup α) (s : Set α) :\n    mk ⁻¹' ((mk : α → α ⧸ N) '' s) = ⋃ x : N, (· * (x : α)) ⁻¹' s := by\n  ext x\n  simp only [QuotientGroup.eq, SetLike.exists, exists_prop, Set.mem_preimage, Set.mem_iUnion,\n    Set.mem_image, ← eq_inv_mul_iff_mul_eq]\n  exact\n    ⟨fun ⟨y, hs, hN⟩ => ⟨_, N.inv_mem hN, by simpa using hs⟩, fun ⟨z, hz, hxz⟩ =>\n      ⟨x * z, hxz, by simpa using hz⟩⟩\n\n"}
{"name":"QuotientGroup.preimage_image_mk","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\nN : Subgroup α\ns : Set α\n⊢ Eq (Set.preimage QuotientGroup.mk (Set.image QuotientGroup.mk s)) (Set.iUnion fun x => Set.preimage (fun x_1 => HMul.hMul x_1 ↑x) s)","decl":"@[to_additive]\ntheorem preimage_image_mk (N : Subgroup α) (s : Set α) :\n    mk ⁻¹' ((mk : α → α ⧸ N) '' s) = ⋃ x : N, (· * (x : α)) ⁻¹' s := by\n  ext x\n  simp only [QuotientGroup.eq, SetLike.exists, exists_prop, Set.mem_preimage, Set.mem_iUnion,\n    Set.mem_image, ← eq_inv_mul_iff_mul_eq]\n  exact\n    ⟨fun ⟨y, hs, hN⟩ => ⟨_, N.inv_mem hN, by simpa using hs⟩, fun ⟨z, hz, hxz⟩ =>\n      ⟨x * z, hxz, by simpa using hz⟩⟩\n\n"}
{"name":"QuotientGroup.preimage_image_mk_eq_iUnion_image","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\nN : Subgroup α\ns : Set α\n⊢ Eq (Set.preimage QuotientGroup.mk (Set.image QuotientGroup.mk s)) (Set.iUnion fun x => Set.image (fun x_1 => HMul.hMul x_1 ↑x) s)","decl":"@[to_additive]\ntheorem preimage_image_mk_eq_iUnion_image (N : Subgroup α) (s : Set α) :\n    mk ⁻¹' ((mk : α → α ⧸ N) '' s) = ⋃ x : N, (· * (x : α)) '' s := by\n  rw [preimage_image_mk, iUnion_congr_of_surjective (·⁻¹) inv_surjective]\n  exact fun x ↦ image_mul_right'\n\n"}
{"name":"QuotientAddGroup.preimage_image_mk_eq_iUnion_image","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nN : AddSubgroup α\ns : Set α\n⊢ Eq (Set.preimage QuotientAddGroup.mk (Set.image QuotientAddGroup.mk s)) (Set.iUnion fun x => Set.image (fun x_1 => HAdd.hAdd x_1 ↑x) s)","decl":"@[to_additive]\ntheorem preimage_image_mk_eq_iUnion_image (N : Subgroup α) (s : Set α) :\n    mk ⁻¹' ((mk : α → α ⧸ N) '' s) = ⋃ x : N, (· * (x : α)) '' s := by\n  rw [preimage_image_mk, iUnion_congr_of_surjective (·⁻¹) inv_surjective]\n  exact fun x ↦ image_mul_right'\n\n"}
{"name":"QuotientGroup.preimage_image_mk_eq_mul","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\nN : Subgroup α\ns : Set α\n⊢ Eq (Set.preimage QuotientGroup.mk (Set.image QuotientGroup.mk s)) (HMul.hMul s ↑N)","decl":"@[to_additive]\ntheorem preimage_image_mk_eq_mul (N : Subgroup α) (s : Set α) :\n    mk ⁻¹' ((mk : α → α ⧸ N) '' s) = s * N := by\n  rw [preimage_image_mk_eq_iUnion_image, iUnion_subtype, ← image2_mul, ← iUnion_image_right]\n  simp only [SetLike.mem_coe]\n\n"}
{"name":"QuotientAddGroup.preimage_image_mk_eq_add","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nN : AddSubgroup α\ns : Set α\n⊢ Eq (Set.preimage QuotientAddGroup.mk (Set.image QuotientAddGroup.mk s)) (HAdd.hAdd s ↑N)","decl":"@[to_additive]\ntheorem preimage_image_mk_eq_mul (N : Subgroup α) (s : Set α) :\n    mk ⁻¹' ((mk : α → α ⧸ N) '' s) = s * N := by\n  rw [preimage_image_mk_eq_iUnion_image, iUnion_subtype, ← image2_mul, ← iUnion_image_right]\n  simp only [SetLike.mem_coe]\n\n"}
{"name":"Subgroup.quotientEquivOfEq_mk","module":"Mathlib.GroupTheory.Coset.Defs","initialProofState":"α : Type u_1\ninst✝ : Group α\ns t : Subgroup α\nh : Eq s t\na : α\n⊢ Eq ((Subgroup.quotientEquivOfEq h) ↑a) ↑a","decl":"theorem quotientEquivOfEq_mk (h : s = t) (a : α) :\n    quotientEquivOfEq h (QuotientGroup.mk a) = QuotientGroup.mk a :=\n  rfl\n\n"}
