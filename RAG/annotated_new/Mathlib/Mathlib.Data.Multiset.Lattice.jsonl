{"name":"Multiset.sup_coe","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\nl : List α\n⊢ Eq (↑l).sup (List.foldr (fun x1 x2 => Max.max x1 x2) Bot.bot l)","decl":"@[simp]\ntheorem sup_coe (l : List α) : sup (l : Multiset α) = l.foldr (· ⊔ ·) ⊥ :=\n  rfl\n\n"}
{"name":"Multiset.sup_zero","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\n⊢ Eq (Multiset.sup 0) Bot.bot","decl":"@[simp]\ntheorem sup_zero : (0 : Multiset α).sup = ⊥ :=\n  fold_zero _ _\n\n"}
{"name":"Multiset.sup_cons","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\na : α\ns : Multiset α\n⊢ Eq (Multiset.cons a s).sup (Max.max a s.sup)","decl":"@[simp]\ntheorem sup_cons (a : α) (s : Multiset α) : (a ::ₘ s).sup = a ⊔ s.sup :=\n  fold_cons_left _ _ _ _\n\n"}
{"name":"Multiset.sup_singleton","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\na : α\n⊢ Eq (Singleton.singleton a).sup a","decl":"@[simp]\ntheorem sup_singleton {a : α} : ({a} : Multiset α).sup = a := sup_bot_eq _\n\n"}
{"name":"Multiset.sup_add","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns₁ s₂ : Multiset α\n⊢ Eq (HAdd.hAdd s₁ s₂).sup (Max.max s₁.sup s₂.sup)","decl":"@[simp]\ntheorem sup_add (s₁ s₂ : Multiset α) : (s₁ + s₂).sup = s₁.sup ⊔ s₂.sup :=\n  Eq.trans (by simp [sup]) (fold_add _ _ _ _ _)\n\n"}
{"name":"Multiset.sup_le","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Multiset α\na : α\n⊢ Iff (LE.le s.sup a) (∀ (b : α), Membership.mem s b → LE.le b a)","decl":"@[simp]\ntheorem sup_le {s : Multiset α} {a : α} : s.sup ≤ a ↔ ∀ b ∈ s, b ≤ a :=\n  Multiset.induction_on s (by simp)\n    (by simp +contextual [or_imp, forall_and])\n\n"}
{"name":"Multiset.le_sup","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns : Multiset α\na : α\nh : Membership.mem s a\n⊢ LE.le a s.sup","decl":"theorem le_sup {s : Multiset α} {a : α} (h : a ∈ s) : a ≤ s.sup :=\n  sup_le.1 le_rfl _ h\n\n"}
{"name":"Multiset.sup_mono","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\ns₁ s₂ : Multiset α\nh : HasSubset.Subset s₁ s₂\n⊢ LE.le s₁.sup s₂.sup","decl":"@[gcongr]\ntheorem sup_mono {s₁ s₂ : Multiset α} (h : s₁ ⊆ s₂) : s₁.sup ≤ s₂.sup :=\n  sup_le.2 fun _ hb => le_sup (h hb)\n\n"}
{"name":"Multiset.sup_dedup","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝² : SemilatticeSup α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq s.dedup.sup s.sup","decl":"@[simp]\ntheorem sup_dedup (s : Multiset α) : (dedup s).sup = s.sup :=\n  fold_dedup_idem _ _ _\n\n"}
{"name":"Multiset.sup_ndunion","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝² : SemilatticeSup α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\ns₁ s₂ : Multiset α\n⊢ Eq (s₁.ndunion s₂).sup (Max.max s₁.sup s₂.sup)","decl":"@[simp]\ntheorem sup_ndunion (s₁ s₂ : Multiset α) : (ndunion s₁ s₂).sup = s₁.sup ⊔ s₂.sup := by\n  rw [← sup_dedup, dedup_ext.2, sup_dedup, sup_add]; simp\n\n"}
{"name":"Multiset.sup_union","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝² : SemilatticeSup α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\ns₁ s₂ : Multiset α\n⊢ Eq (Union.union s₁ s₂).sup (Max.max s₁.sup s₂.sup)","decl":"@[simp]\ntheorem sup_union (s₁ s₂ : Multiset α) : (s₁ ∪ s₂).sup = s₁.sup ⊔ s₂.sup := by\n  rw [← sup_dedup, dedup_ext.2, sup_dedup, sup_add]; simp\n\n"}
{"name":"Multiset.sup_ndinsert","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝² : SemilatticeSup α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Eq (Multiset.ndinsert a s).sup (Max.max a s.sup)","decl":"@[simp]\ntheorem sup_ndinsert (a : α) (s : Multiset α) : (ndinsert a s).sup = a ⊔ s.sup := by\n  rw [← sup_dedup, dedup_ext.2, sup_dedup, sup_cons]; simp\n\n"}
{"name":"Multiset.nodup_sup_iff","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nm : Multiset (Multiset α)\n⊢ Iff m.sup.Nodup (∀ (a : Multiset α), Membership.mem m a → a.Nodup)","decl":"theorem nodup_sup_iff {α : Type*} [DecidableEq α] {m : Multiset (Multiset α)} :\n    m.sup.Nodup ↔ ∀ a : Multiset α, a ∈ m → a.Nodup := by\n  -- Porting note: this was originally `apply m.induction_on`, which failed due to\n  -- `failed to elaborate eliminator, expected type is not available`\n  induction m using Multiset.induction_on with\n  | empty => simp\n  | cons _ _ h => simp [h]\n\n"}
{"name":"Multiset.inf_coe","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\nl : List α\n⊢ Eq (↑l).inf (List.foldr (fun x1 x2 => Min.min x1 x2) Top.top l)","decl":"@[simp]\ntheorem inf_coe (l : List α) : inf (l : Multiset α) = l.foldr (· ⊓ ·) ⊤ :=\n  rfl\n\n"}
{"name":"Multiset.inf_zero","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\n⊢ Eq (Multiset.inf 0) Top.top","decl":"@[simp]\ntheorem inf_zero : (0 : Multiset α).inf = ⊤ :=\n  fold_zero _ _\n\n"}
{"name":"Multiset.inf_cons","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\na : α\ns : Multiset α\n⊢ Eq (Multiset.cons a s).inf (Min.min a s.inf)","decl":"@[simp]\ntheorem inf_cons (a : α) (s : Multiset α) : (a ::ₘ s).inf = a ⊓ s.inf :=\n  fold_cons_left _ _ _ _\n\n"}
{"name":"Multiset.inf_singleton","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\na : α\n⊢ Eq (Singleton.singleton a).inf a","decl":"@[simp]\ntheorem inf_singleton {a : α} : ({a} : Multiset α).inf = a := inf_top_eq _\n\n"}
{"name":"Multiset.inf_add","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns₁ s₂ : Multiset α\n⊢ Eq (HAdd.hAdd s₁ s₂).inf (Min.min s₁.inf s₂.inf)","decl":"@[simp]\ntheorem inf_add (s₁ s₂ : Multiset α) : (s₁ + s₂).inf = s₁.inf ⊓ s₂.inf :=\n  Eq.trans (by simp [inf]) (fold_add _ _ _ _ _)\n\n"}
{"name":"Multiset.le_inf","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Multiset α\na : α\n⊢ Iff (LE.le a s.inf) (∀ (b : α), Membership.mem s b → LE.le a b)","decl":"@[simp]\ntheorem le_inf {s : Multiset α} {a : α} : a ≤ s.inf ↔ ∀ b ∈ s, a ≤ b :=\n  Multiset.induction_on s (by simp)\n    (by simp +contextual [or_imp, forall_and])\n\n"}
{"name":"Multiset.inf_le","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns : Multiset α\na : α\nh : Membership.mem s a\n⊢ LE.le s.inf a","decl":"theorem inf_le {s : Multiset α} {a : α} (h : a ∈ s) : s.inf ≤ a :=\n  le_inf.1 le_rfl _ h\n\n"}
{"name":"Multiset.inf_mono","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeInf α\ninst✝ : OrderTop α\ns₁ s₂ : Multiset α\nh : HasSubset.Subset s₁ s₂\n⊢ LE.le s₂.inf s₁.inf","decl":"@[gcongr]\ntheorem inf_mono {s₁ s₂ : Multiset α} (h : s₁ ⊆ s₂) : s₂.inf ≤ s₁.inf :=\n  le_inf.2 fun _ hb => inf_le (h hb)\n\n"}
{"name":"Multiset.inf_dedup","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝² : SemilatticeInf α\ninst✝¹ : OrderTop α\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq s.dedup.inf s.inf","decl":"@[simp]\ntheorem inf_dedup (s : Multiset α) : (dedup s).inf = s.inf :=\n  fold_dedup_idem _ _ _\n\n"}
{"name":"Multiset.inf_ndunion","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝² : SemilatticeInf α\ninst✝¹ : OrderTop α\ninst✝ : DecidableEq α\ns₁ s₂ : Multiset α\n⊢ Eq (s₁.ndunion s₂).inf (Min.min s₁.inf s₂.inf)","decl":"@[simp]\ntheorem inf_ndunion (s₁ s₂ : Multiset α) : (ndunion s₁ s₂).inf = s₁.inf ⊓ s₂.inf := by\n  rw [← inf_dedup, dedup_ext.2, inf_dedup, inf_add]; simp\n\n"}
{"name":"Multiset.inf_union","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝² : SemilatticeInf α\ninst✝¹ : OrderTop α\ninst✝ : DecidableEq α\ns₁ s₂ : Multiset α\n⊢ Eq (Union.union s₁ s₂).inf (Min.min s₁.inf s₂.inf)","decl":"@[simp]\ntheorem inf_union (s₁ s₂ : Multiset α) : (s₁ ∪ s₂).inf = s₁.inf ⊓ s₂.inf := by\n  rw [← inf_dedup, dedup_ext.2, inf_dedup, inf_add]; simp\n\n"}
{"name":"Multiset.inf_ndinsert","module":"Mathlib.Data.Multiset.Lattice","initialProofState":"α : Type u_1\ninst✝² : SemilatticeInf α\ninst✝¹ : OrderTop α\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Eq (Multiset.ndinsert a s).inf (Min.min a s.inf)","decl":"@[simp]\ntheorem inf_ndinsert (a : α) (s : Multiset α) : (ndinsert a s).inf = a ⊓ s.inf := by\n  rw [← inf_dedup, dedup_ext.2, inf_dedup, inf_cons]; simp\n\n"}
