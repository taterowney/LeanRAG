{"name":"Ordinal.CNFRec_zero","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"C : Ordinal.{u_2} → Sort u_1\nb : Ordinal.{u_2}\nH0 : C 0\nH : (o : Ordinal.{u_2}) → Ne o 0 → C (HMod.hMod o (HPow.hPow b (Ordinal.log b o))) → C o\n⊢ Eq (b.CNFRec H0 H 0) H0","decl":"@[simp]\ntheorem CNFRec_zero {C : Ordinal → Sort*} (b : Ordinal) (H0 : C 0)\n    (H : ∀ o, o ≠ 0 → C (o % b ^ log b o) → C o) : CNFRec b H0 H 0 = H0 := by\n  rw [CNFRec, dif_pos rfl]\n\n"}
{"name":"Ordinal.CNFRec_pos","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"b o : Ordinal.{u_2}\nC : Ordinal.{u_2} → Sort u_1\nho : Ne o 0\nH0 : C 0\nH : (o : Ordinal.{u_2}) → Ne o 0 → C (HMod.hMod o (HPow.hPow b (Ordinal.log b o))) → C o\n⊢ Eq (b.CNFRec H0 H o) (H o ho (b.CNFRec H0 H (HMod.hMod o (HPow.hPow b (Ordinal.log b o)))))","decl":"theorem CNFRec_pos (b : Ordinal) {o : Ordinal} {C : Ordinal → Sort*} (ho : o ≠ 0) (H0 : C 0)\n    (H : ∀ o, o ≠ 0 → C (o % b ^ log b o) → C o) :\n    CNFRec b H0 H o = H o ho (@CNFRec b C H0 H _) := by\n  rw [CNFRec, dif_neg]\n\n"}
{"name":"Ordinal.CNF_zero","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"b : Ordinal.{u_1}\n⊢ Eq (Ordinal.CNF b 0) List.nil","decl":"@[simp]\ntheorem CNF_zero (b : Ordinal) : CNF b 0 = [] :=\n  CNFRec_zero b _ _\n\n"}
{"name":"Ordinal.CNF_ne_zero","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"b o : Ordinal.{u_1}\nho : Ne o 0\n⊢ Eq (Ordinal.CNF b o) (List.cons { fst := Ordinal.log b o, snd := HDiv.hDiv o (HPow.hPow b (Ordinal.log b o)) } (Ordinal.CNF b (HMod.hMod o (HPow.hPow b (Ordinal.log b o)))))","decl":"/-- Recursive definition for the Cantor normal form. -/\ntheorem CNF_ne_zero {b o : Ordinal} (ho : o ≠ 0) :\n    CNF b o = (log b o, o / b ^ log b o)::CNF b (o % b ^ log b o) :=\n  CNFRec_pos b ho _ _\n\n"}
{"name":"Ordinal.zero_CNF","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"o : Ordinal.{u_1}\nho : Ne o 0\n⊢ Eq (Ordinal.CNF 0 o) (List.cons { fst := 0, snd := o } List.nil)","decl":"theorem zero_CNF {o : Ordinal} (ho : o ≠ 0) : CNF 0 o = [(0, o)] := by simp [CNF_ne_zero ho]\n\n"}
{"name":"Ordinal.one_CNF","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"o : Ordinal.{u_1}\nho : Ne o 0\n⊢ Eq (Ordinal.CNF 1 o) (List.cons { fst := 0, snd := o } List.nil)","decl":"theorem one_CNF {o : Ordinal} (ho : o ≠ 0) : CNF 1 o = [(0, o)] := by simp [CNF_ne_zero ho]\n\n"}
{"name":"Ordinal.CNF_of_le_one","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"b o : Ordinal.{u_1}\nhb : LE.le b 1\nho : Ne o 0\n⊢ Eq (Ordinal.CNF b o) (List.cons { fst := 0, snd := o } List.nil)","decl":"theorem CNF_of_le_one {b o : Ordinal} (hb : b ≤ 1) (ho : o ≠ 0) : CNF b o = [(0, o)] := by\n  rcases le_one_iff.1 hb with (rfl | rfl)\n  exacts [zero_CNF ho, one_CNF ho]\n\n"}
{"name":"Ordinal.CNF_of_lt","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"b o : Ordinal.{u_1}\nho : Ne o 0\nhb : LT.lt o b\n⊢ Eq (Ordinal.CNF b o) (List.cons { fst := 0, snd := o } List.nil)","decl":"theorem CNF_of_lt {b o : Ordinal} (ho : o ≠ 0) (hb : o < b) : CNF b o = [(0, o)] := by\n  rw [CNF_ne_zero ho, log_eq_zero hb, opow_zero, div_one, mod_one, CNF_zero]\n\n"}
{"name":"Ordinal.CNF_foldr","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"b o : Ordinal.{u_1}\n⊢ Eq (List.foldr (fun p r => HAdd.hAdd (HMul.hMul (HPow.hPow b p.1) p.2) r) 0 (Ordinal.CNF b o)) o","decl":"/-- Evaluating the Cantor normal form of an ordinal returns the ordinal. -/\ntheorem CNF_foldr (b o : Ordinal) : (CNF b o).foldr (fun p r ↦ b ^ p.1 * p.2 + r) 0 = o := by\n  refine CNFRec b ?_ ?_ o\n  · rw [CNF_zero, foldr_nil]\n  · intro o ho IH\n    rw [CNF_ne_zero ho, foldr_cons, IH, div_add_mod]\n\n"}
{"name":"Ordinal.CNF_fst_le_log","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"b o : Ordinal.{u}\nx : Prod Ordinal.{u} Ordinal.{u}\na✝ : Membership.mem (Ordinal.CNF b o) x\n⊢ LE.le x.1 (Ordinal.log b o)","decl":"/-- Every exponent in the Cantor normal form `CNF b o` is less or equal to `log b o`. -/\ntheorem CNF_fst_le_log {b o : Ordinal.{u}} {x : Ordinal × Ordinal} :\n    x ∈ CNF b o → x.1 ≤ log b o := by\n  refine CNFRec b ?_ (fun o ho H ↦ ?_) o\n  · simp\n  · rw [CNF_ne_zero ho, mem_cons]\n    rintro (rfl | h)\n    · rfl\n    · exact (H h).trans (log_mono_right _ (mod_opow_log_lt_self b ho).le)\n\n"}
{"name":"Ordinal.CNF_fst_le","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"b o : Ordinal.{u}\nx : Prod Ordinal.{u} Ordinal.{u}\nh : Membership.mem (Ordinal.CNF b o) x\n⊢ LE.le x.1 o","decl":"/-- Every exponent in the Cantor normal form `CNF b o` is less or equal to `o`. -/\n@[deprecated CNF_fst_le_log (since := \"2024-09-21\")]\ntheorem CNF_fst_le {b o : Ordinal.{u}} {x : Ordinal × Ordinal} (h : x ∈ CNF b o) : x.1 ≤ o :=\n  (CNF_fst_le_log h).trans <| log_le_self _ _\n\n"}
{"name":"Ordinal.CNF_lt_snd","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"b o : Ordinal.{u}\nx : Prod Ordinal.{u} Ordinal.{u}\na✝ : Membership.mem (Ordinal.CNF b o) x\n⊢ LT.lt 0 x.2","decl":"/-- Every coefficient in a Cantor normal form is positive. -/\ntheorem CNF_lt_snd {b o : Ordinal.{u}} {x : Ordinal × Ordinal} : x ∈ CNF b o → 0 < x.2 := by\n  refine CNFRec b (by simp) (fun o ho IH ↦ ?_) o\n  rw [CNF_ne_zero ho]\n  rintro (h | ⟨_, h⟩)\n  · exact div_opow_log_pos b ho\n  · exact IH h\n\n"}
{"name":"Ordinal.CNF_snd_lt","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"b o : Ordinal.{u}\nhb : LT.lt 1 b\nx : Prod Ordinal.{u} Ordinal.{u}\na✝ : Membership.mem (Ordinal.CNF b o) x\n⊢ LT.lt x.2 b","decl":"/-- Every coefficient in the Cantor normal form `CNF b o` is less than `b`. -/\ntheorem CNF_snd_lt {b o : Ordinal.{u}} (hb : 1 < b) {x : Ordinal × Ordinal} :\n    x ∈ CNF b o → x.2 < b := by\n  refine CNFRec b ?_ (fun o ho IH ↦ ?_) o\n  · simp\n  · rw [CNF_ne_zero ho]\n    intro h\n    obtain rfl | h := mem_cons.mp h\n    · exact div_opow_log_lt o hb\n    · exact IH h\n\n"}
{"name":"Ordinal.CNF_sorted","module":"Mathlib.SetTheory.Ordinal.CantorNormalForm","initialProofState":"b o : Ordinal.{u_1}\n⊢ List.Sorted (fun x1 x2 => GT.gt x1 x2) (List.map Prod.fst (Ordinal.CNF b o))","decl":"/-- The exponents of the Cantor normal form are decreasing. -/\ntheorem CNF_sorted (b o : Ordinal) : ((CNF b o).map Prod.fst).Sorted (· > ·) := by\n  refine CNFRec b ?_ (fun o ho IH ↦ ?_) o\n  · rw [CNF_zero]\n    exact sorted_nil\n  · rcases le_or_lt b 1 with hb | hb\n    · rw [CNF_of_le_one hb ho]\n      exact sorted_singleton _\n    · obtain hob | hbo := lt_or_le o b\n      · rw [CNF_of_lt ho hob]\n        exact sorted_singleton _\n      · rw [CNF_ne_zero ho, map_cons, sorted_cons]\n        refine ⟨fun a H ↦ ?_, IH⟩\n        rw [mem_map] at H\n        rcases H with ⟨⟨a, a'⟩, H, rfl⟩\n        exact (CNF_fst_le_log H).trans_lt (log_mod_opow_log_lt_log_self hb hbo)\n\n"}
