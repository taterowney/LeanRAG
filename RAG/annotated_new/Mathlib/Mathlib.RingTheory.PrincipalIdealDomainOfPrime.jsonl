{"name":"IsPrincipalIdealRing.of_prime","module":"Mathlib.RingTheory.PrincipalIdealDomainOfPrime","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nH : ∀ (P : Ideal R), P.IsPrime → Submodule.IsPrincipal P\n⊢ IsPrincipalIdealRing R","decl":"/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem IsPrincipalIdealRing.of_prime (H : ∀ P : Ideal R, P.IsPrime → P.IsPrincipal) :\n    IsPrincipalIdealRing R := by\n  -- Suppose the set of `nonPrincipals` is not empty.\n  rw [← nonPrincipals_eq_empty_iff, Set.eq_empty_iff_forall_not_mem]\n  intro J hJ\n  -- We will show a maximal element `I ∈ nonPrincipals R` (which exists by Zorn) is prime.\n  obtain ⟨I, hJI, hI⟩ := zorn_le_nonempty₀ (nonPrincipals R) nonPrincipals_zorn _ hJ\n\n  have Imax' : ∀ {J}, I < J → J.IsPrincipal := by\n    intro K hK\n    simpa [nonPrincipals] using hI.not_prop_of_gt hK\n\n  by_cases hI1 : I = ⊤\n  · subst hI1\n    exact hI.prop top_isPrincipal\n  -- Let `x y : R` with `x * y ∈ I` and suppose WLOG `y ∉ I`.\n  refine hI.prop (H I ⟨hI1, fun {x y} hxy => or_iff_not_imp_right.mpr fun hy => ?_⟩)\n  obtain ⟨a, ha⟩ : (I ⊔ span {y}).IsPrincipal :=\n    Imax' (left_lt_sup.mpr (mt I.span_singleton_le_iff_mem.mp hy))\n  -- Then `x ∈ I.colon (span {y})`, which is equal to `I` if it's not principal.\n  suffices He : ¬(I.colon (span {y})).IsPrincipal by\n    rw [hI.eq_of_le ((nonPrincipals_def R).2 He) fun a ha ↦\n      Ideal.mem_colon_singleton.2 (mul_mem_right _ _ ha)]\n    exact Ideal.mem_colon_singleton.2 hxy\n  -- So suppose for the sake of contradiction that both `I ⊔ span {y}` and `I.colon (span {y})`\n  -- are principal.\n  rintro ⟨b, hb⟩\n  -- We will show `I` is generated by `a * b`.\n  refine (nonPrincipals_def _).1 hI.prop ⟨a * b, ?_⟩\n  refine\n    le_antisymm (α := Ideal R) (fun i hi => ?_) <|\n      (span_singleton_mul_span_singleton a b).ge.trans ?_\n  · have hisup : i ∈ I ⊔ span {y} := Ideal.mem_sup_left hi\n    have : y ∈ I ⊔ span {y} := Ideal.mem_sup_right (Ideal.mem_span_singleton_self y)\n    erw [ha, mem_span_singleton'] at hisup this\n    obtain ⟨v, rfl⟩ := this\n    obtain ⟨u, rfl⟩ := hisup\n    have hucolon : u ∈ I.colon (span {v * a}) := by\n      rw [Ideal.mem_colon_singleton, mul_comm v, ← mul_assoc]\n      exact mul_mem_right _ _ hi\n    erw [hb, mem_span_singleton'] at hucolon\n    obtain ⟨z, rfl⟩ := hucolon\n    exact mem_span_singleton'.2 ⟨z, by ring⟩\n  · rw [← Ideal.submodule_span_eq, ← ha, Ideal.sup_mul, sup_le_iff,\n      span_singleton_mul_span_singleton, mul_comm y, Ideal.span_singleton_le_iff_mem]\n    exact ⟨mul_le_right, Ideal.mem_colon_singleton.1 <| hb.symm ▸ Ideal.mem_span_singleton_self b⟩\n"}
