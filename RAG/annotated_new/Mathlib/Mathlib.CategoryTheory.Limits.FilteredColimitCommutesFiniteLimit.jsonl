{"name":"CategoryTheory.Limits.comp_lim_obj_ext_iff","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type uâ‚\nK : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\ninstâœ : Small.{v, uâ‚‚} K\nj : J\nG : CategoryTheory.Functor J (CategoryTheory.Functor K (Type v))\nx y : (G.comp CategoryTheory.Limits.lim).obj j\nâŠ¢ Iff (Eq x y) (âˆ€ (k : K), Eq (CategoryTheory.Limits.limit.Ï€ (G.obj j) k x) (CategoryTheory.Limits.limit.Ï€ (G.obj j) k y))","decl":"/-- `(G â‹™ lim).obj j` = `limit (G.obj j)` definitionally, so this\nis just a variant of `limit_ext'`. -/\n@[ext] lemma comp_lim_obj_ext {j : J} {G : J â¥¤ K â¥¤ Type v} (x y : (G â‹™ lim).obj j)\n    (w : âˆ€ (k : K), limit.Ï€ (G.obj j) k x = limit.Ï€ (G.obj j) k y) : x = y :=\n  limit_ext _ x y w\n\n"}
{"name":"CategoryTheory.Limits.comp_lim_obj_ext","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type uâ‚\nK : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\ninstâœ : Small.{v, uâ‚‚} K\nj : J\nG : CategoryTheory.Functor J (CategoryTheory.Functor K (Type v))\nx y : (G.comp CategoryTheory.Limits.lim).obj j\nw : âˆ€ (k : K), Eq (CategoryTheory.Limits.limit.Ï€ (G.obj j) k x) (CategoryTheory.Limits.limit.Ï€ (G.obj j) k y)\nâŠ¢ Eq x y","decl":"/-- `(G â‹™ lim).obj j` = `limit (G.obj j)` definitionally, so this\nis just a variant of `limit_ext'`. -/\n@[ext] lemma comp_lim_obj_ext {j : J} {G : J â¥¤ K â¥¤ Type v} (x y : (G â‹™ lim).obj j)\n    (w : âˆ€ (k : K), limit.Ï€ (G.obj j) k x = limit.Ï€ (G.obj j) k y) : x = y :=\n  limit_ext _ x y w\n\n"}
{"name":"CategoryTheory.Limits.colimitLimitToLimitColimit_injective","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type uâ‚\nK : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\ninstâœÂ² : Small.{v, uâ‚‚} K\nF : CategoryTheory.Functor (Prod J K) (Type v)\ninstâœÂ¹ : CategoryTheory.IsFiltered K\ninstâœ : Finite J\nâŠ¢ Function.Injective (CategoryTheory.Limits.colimitLimitToLimitColimit F)","decl":"/-- This follows this proof from\n* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4\n-/\ntheorem colimitLimitToLimitColimit_injective :\n    Function.Injective (colimitLimitToLimitColimit F) := by\n  classical\n    cases nonempty_fintype J\n    -- Suppose we have two terms `x y` in the colimit (over `K`) of the limits (over `J`),\n    -- and that these have the same image under `colimitLimitToLimitColimit F`.\n    intro x y h\n    -- These elements of the colimit have representatives somewhere:\n    obtain âŸ¨kx, x, rflâŸ© := jointly_surjective' x\n    obtain âŸ¨ky, y, rflâŸ© := jointly_surjective' y\n    dsimp at x y\n    -- Since the images of `x` and `y` are equal in a limit, they are equal componentwise\n    -- (indexed by `j : J`),\n    replace h := fun j => congr_arg (limit.Ï€ (curry.obj F â‹™ colim) j) h\n    -- and they are equations in a filtered colimit,\n    -- so for each `j` we have some place `k j` to the right of both `kx` and `ky`\n    simp? [colimit_eq_iff] at h says\n      simp only [Functor.comp_obj, colim_obj, Î¹_colimitLimitToLimitColimit_Ï€_apply,\n        colimit_eq_iff, curry_obj_obj_obj, curry_obj_obj_map] at h\n    let k j := (h j).choose\n    let f : âˆ€ j, kx âŸ¶ k j := fun j => (h j).choose_spec.choose\n    let g : âˆ€ j, ky âŸ¶ k j := fun j => (h j).choose_spec.choose_spec.choose\n    -- where the images of the components of the representatives become equal:\n    have w :\n      âˆ€ j, F.map ((ğŸ™ j, f j) :\n        (j, kx) âŸ¶ (j, k j)) (limit.Ï€ ((curry.obj (swap K J â‹™ F)).obj kx) j x) =\n          F.map ((ğŸ™ j, g j) : (j, ky) âŸ¶ (j, k j))\n            (limit.Ï€ ((curry.obj (swap K J â‹™ F)).obj ky) j y) :=\n      fun j => (h j).choose_spec.choose_spec.choose_spec\n    -- We now use that `K` is filtered, picking some point to the right of all these\n    -- morphisms `f j` and `g j`.\n    let O : Finset K := Finset.univ.image k âˆª {kx, ky}\n    have kxO : kx âˆˆ O := Finset.mem_union.mpr (Or.inr (by simp))\n    have kyO : ky âˆˆ O := Finset.mem_union.mpr (Or.inr (by simp))\n    have kjO : âˆ€ j, k j âˆˆ O := fun j => Finset.mem_union.mpr (Or.inl (by simp))\n    let H : Finset (Î£' (X Y : K) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) :=\n      (Finset.univ.image fun j : J =>\n          âŸ¨kx, k j, kxO, Finset.mem_union.mpr (Or.inl (by simp)), f jâŸ©) âˆª\n        Finset.univ.image fun j : J => âŸ¨ky, k j, kyO, Finset.mem_union.mpr (Or.inl (by simp)), g jâŸ©\n    obtain âŸ¨S, T, WâŸ© := IsFiltered.sup_exists O H\n    have fH : âˆ€ j, (âŸ¨kx, k j, kxO, kjO j, f jâŸ© : Î£' (X Y : K) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) âˆˆ H :=\n      fun j =>\n      Finset.mem_union.mpr\n        (Or.inl\n          (by\n            simp only [true_and, Finset.mem_univ, eq_self_iff_true, exists_prop_of_true,\n              Finset.mem_image, heq_iff_eq]\n            refine âŸ¨j, ?_âŸ©\n            simp only [heq_iff_eq] ))\n    have gH :\n      âˆ€ j, (âŸ¨ky, k j, kyO, kjO j, g jâŸ© : Î£' (X Y : K) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) âˆˆ H :=\n      fun j =>\n      Finset.mem_union.mpr\n        (Or.inr\n          (by\n            simp only [true_and, Finset.mem_univ, eq_self_iff_true, exists_prop_of_true,\n              Finset.mem_image, heq_iff_eq]\n            refine âŸ¨j, ?_âŸ©\n            simp only [heq_iff_eq]))\n    -- Our goal is now an equation between equivalence classes of representatives of a colimit,\n    -- and so it suffices to show those representative become equal somewhere, in particular at `S`.\n    apply colimit_sound' (T kxO) (T kyO)\n    -- We can check if two elements of a limit (in `Type`)\n    -- are equal by comparing them componentwise.\n    ext j\n    -- Now it's just a calculation using `W` and `w`.\n    simp only [Functor.comp_map, Limit.map_Ï€_apply, curry_obj_map_app, swap_map]\n    rw [â† W _ _ (fH j), â† W _ _ (gH j)]\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): had to add `Limit.map_Ï€_apply`\n    -- (which was un-tagged simp since \"simp can prove it\")\n    simp [Limit.map_Ï€_apply, w]\n\n"}
{"name":"CategoryTheory.Limits.colimitLimitToLimitColimit_surjective","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type uâ‚\nK : Type uâ‚‚\ninstâœâ´ : CategoryTheory.SmallCategory J\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\ninstâœÂ² : Small.{v, uâ‚‚} K\ninstâœÂ¹ : CategoryTheory.FinCategory J\nF : CategoryTheory.Functor (Prod J K) (Type v)\ninstâœ : CategoryTheory.IsFiltered K\nâŠ¢ Function.Surjective (CategoryTheory.Limits.colimitLimitToLimitColimit F)","decl":"/-- This follows this proof from\n* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4\nalthough with different names.\n-/\ntheorem colimitLimitToLimitColimit_surjective :\n    Function.Surjective (colimitLimitToLimitColimit F) := by\n  classical\n    -- We begin with some element `x` in the limit (over J) over the colimits (over K),\n    intro x\n    -- This consists of some coherent family of elements in the various colimits,\n    -- and so our first task is to pick representatives of these elements.\n    have z := fun j => jointly_surjective' (limit.Ï€ (curry.obj F â‹™ Limits.colim) j x)\n    -- `k : J âŸ¶ K` records where the representative of the\n    -- element in the `j`-th element of `x` lives\n    let k : J â†’ K := fun j => (z j).choose\n    -- `y j : F.obj (j, k j)` is the representative\n    let y : âˆ€ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose\n    -- and we record that these representatives, when mapped back into the relevant colimits,\n    -- are actually the components of `x`.\n    have e : âˆ€ j,\n        colimit.Î¹ ((curry.obj F).obj j) (k j) (y j) = limit.Ï€ (curry.obj F â‹™ Limits.colim) j x :=\n      fun j => (z j).choose_spec.choose_spec\n    clear_value k y\n    -- A little tidying up of things we no longer need.\n    clear z\n    -- As a first step, we use that `K` is filtered to pick some point `k' : K` above all the `k j`\n    let k' : K := IsFiltered.sup (Finset.univ.image k) âˆ…\n    -- and name the morphisms as `g j : k j âŸ¶ k'`.\n    have g : âˆ€ j, k j âŸ¶ k' := fun j => IsFiltered.toSup (Finset.univ.image k) âˆ… (by simp)\n    clear_value k'\n    -- Recalling that the components of `x`, which are indexed by `j : J`, are \"coherent\",\n    -- in other words preserved by morphisms in the `J` direction,\n    -- we see that for any morphism `f : j âŸ¶ j'` in `J`,\n    -- the images of `y j` and `y j'`, when mapped to `F.obj (j', k')` respectively by\n    -- `(f, g j)` and `(ğŸ™ j', g j')`, both represent the same element in the colimit.\n    have w :\n      âˆ€ {j j' : J} (f : j âŸ¶ j'),\n        colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =\n          colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) := by\n      intro j j' f\n      have t : (f, g j) =\n          (((f, ğŸ™ (k j)) : (j, k j) âŸ¶ (j', k j)) â‰« (ğŸ™ j', g j) : (j, k j) âŸ¶ (j', k')) := by\n        simp only [id_comp, comp_id, prod_comp]\n      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,\n        â† Limit.w_apply.{uâ‚, v, uâ‚} f, â† e]\n      simp only [Functor.comp_map, Types.Colimit.Î¹_map_apply, curry_obj_map_app]\n    -- Because `K` is filtered, we can restate this as saying that\n    -- for each such `f`, there is some place to the right of `k'`\n    -- where these images of `y j` and `y j'` become equal.\n    simp_rw [colimit_eq_iff] at w\n    -- We take a moment to restate `w` more conveniently.\n    let kf : âˆ€ {j j'} (_ : j âŸ¶ j'), K := fun f => (w f).choose\n    let gf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f => (w f).choose_spec.choose\n    let hf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f =>\n      (w f).choose_spec.choose_spec.choose\n    have wf :\n      âˆ€ {j j'} (f : j âŸ¶ j'),\n        F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j') =\n          F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j) :=\n      fun {j j'} f => by\n      have q :\n        ((curry.obj F).obj j').map (gf f) (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =\n          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) :=\n        (w f).choose_spec.choose_spec.choose_spec\n      rw [curry_obj_obj_map, curry_obj_obj_map] at q\n      -- Porting note: Lean 4 `dsimp` unfolds `gf` and `hf` in `q` :-(\n      -- See discussion at https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/.60dsimp.60.20unfolding.20local.20lets\n      simp_rw [â† FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q\n      convert q <;> simp only [comp_id]\n    clear_value kf gf hf\n    -- and clean up some things that are no longer needed.\n    clear w\n    -- We're now ready to use the fact that `K` is filtered a second time,\n    -- picking some place to the right of all of\n    -- the morphisms `gf f : k' âŸ¶ kh f` and `hf f : k' âŸ¶ kf f`.\n    -- At this point we're relying on there being only finitely morphisms in `J`.\n    let O :=\n      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image\n        (@kf j j')) âˆª {k'}\n    have kfO : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âˆˆ O := fun {j} {j'} f =>\n      Finset.mem_union.mpr\n        (Or.inl\n          (Finset.mem_biUnion.mpr âŸ¨j, Finset.mem_univ j,\n            Finset.mem_biUnion.mpr âŸ¨j', Finset.mem_univ j',\n              Finset.mem_image.mpr âŸ¨f, Finset.mem_univ _, rflâŸ©âŸ©âŸ©))\n    have k'O : k' âˆˆ O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))\n    let H : Finset (Î£' (X Y : K) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) :=\n      Finset.univ.biUnion fun j : J =>\n        Finset.univ.biUnion fun j' : J =>\n          Finset.univ.biUnion fun f : j âŸ¶ j' =>\n            {âŸ¨k', kf f, k'O, kfO f, gf fâŸ©, âŸ¨k', kf f, k'O, kfO f, hf fâŸ©}\n    obtain âŸ¨k'', i', s'âŸ© := IsFiltered.sup_exists O H\n    -- We then restate this slightly more conveniently, as a family of morphism `i f : kf f âŸ¶ k''`,\n    -- satisfying `gf f â‰« i f = hf f' â‰« i f'`.\n    let i : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âŸ¶ k'' := fun {j} {j'} f => i' (kfO f)\n    have s : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ jâ‚„} (f : jâ‚ âŸ¶ jâ‚‚) (f' : jâ‚ƒ âŸ¶ jâ‚„), gf f â‰« i f = hf f' â‰« i f' := by\n      intros jâ‚ jâ‚‚ jâ‚ƒ jâ‚„ f f'\n      rw [s', s']\n      -- Porting note: the three goals here in Lean 3 were in a different order\n      Â· exact k'O\n      Â· exact Finset.mem_biUnion.mpr âŸ¨jâ‚ƒ, Finset.mem_univ _,\n          Finset.mem_biUnion.mpr âŸ¨jâ‚„, Finset.mem_univ _,\n            Finset.mem_biUnion.mpr âŸ¨f', Finset.mem_univ _, by\n              -- This works by `simp`, but has very high variation in heartbeats.\n              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,\n                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,\n                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,\n                or_true]\n              trivialâŸ©âŸ©âŸ©\n      Â· exact Finset.mem_biUnion.mpr âŸ¨jâ‚, Finset.mem_univ _,\n          Finset.mem_biUnion.mpr âŸ¨jâ‚‚, Finset.mem_univ _,\n            Finset.mem_biUnion.mpr âŸ¨f, Finset.mem_univ _, by\n              -- This works by `simp`, but has very high variation in heartbeats.\n              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,\n                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,\n                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,\n                true_or]\n              trivialâŸ©âŸ©âŸ©\n    clear_value i\n    clear s' i' H kfO k'O O\n    -- We're finally ready to construct the pre-image, and verify it really maps to `x`.\n    -- âŠ¢ âˆƒ a, colimitLimitToLimitColimit F a = x\n    fconstructor\n    Â· -- We construct the pre-image (which, recall is meant to be a point\n      -- in the colimit (over `K`) of the limits (over `J`)) via a representative at `k''`.\n      apply colimit.Î¹ (curry.obj (swap K J â‹™ F) â‹™ Limits.lim) k'' _\n      dsimp\n      -- This representative is meant to be an element of a limit,\n      -- so we need to construct a family of elements in `F.obj (j, k'')` for varying `j`,\n      -- then show that are coherent with respect to morphisms in the `j` direction.\n      apply Limit.mk\n      swap\n      Â·-- We construct the elements as the images of the `y j`.\n        exact fun j => F.map (âŸ¨ğŸ™ j, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)âŸ© : (j, k j) âŸ¶ (j, k'')) (y j)\n      Â· -- After which it's just a calculation, using `s` and `wf`, to see they are coherent.\n        dsimp\n        intro j j' f\n        simp only [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]\n        calc\n          F.map ((f, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)) : (j, k j) âŸ¶ (j', k'')) (y j) =\n              F.map ((f, g j â‰« hf f â‰« i f) : (j, k j) âŸ¶ (j', k'')) (y j) := by\n            rw [s (ğŸ™ j) f]\n          _ =\n              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))\n                (F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j)) := by\n            rw [â† FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]\n          _ =\n              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))\n                (F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j')) := by\n            rw [â† wf f]\n          _ = F.map ((ğŸ™ j', g j' â‰« gf f â‰« i f) : (j', k j') âŸ¶ (j', k'')) (y j') := by\n            rw [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]\n          _ = F.map ((ğŸ™ j', g j' â‰« gf (ğŸ™ j') â‰« i (ğŸ™ j')) : (j', k j') âŸ¶ (j', k'')) (y j') := by\n            rw [s f (ğŸ™ j'), â† s (ğŸ™ j') (ğŸ™ j')]\n    -- Finally we check that this maps to `x`.\n    Â· -- We can do this componentwise:\n      apply limit_ext\n      intro j\n      -- and as each component is an equation in a colimit, we can verify it by\n      -- pointing out the morphism which carries one representative to the other:\n      simp only [id, â† e, Limits.Î¹_colimitLimitToLimitColimit_Ï€_apply,\n          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,\n          Functor.comp_obj, colim_obj, Limit.Ï€_mk]\n      refine âŸ¨k'', ğŸ™ k'', g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j), ?_âŸ©\n      -- Porting note: the lean 3 proof finished with\n      -- `simp only [Bifunctor.map_id_comp, types_comp_apply, Bifunctor.map_id, types_id_apply]`\n      -- which doesn't work; the corresponding `rw` works fine:\n      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,\n        Bifunctor.map_id, types_id_apply]\n\n"}
{"name":"CategoryTheory.Limits.colimitLimitToLimitColimit_isIso","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type uâ‚\nK : Type uâ‚‚\ninstâœâ´ : CategoryTheory.SmallCategory J\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\ninstâœÂ² : Small.{v, uâ‚‚} K\ninstâœÂ¹ : CategoryTheory.FinCategory J\nF : CategoryTheory.Functor (Prod J K) (Type v)\ninstâœ : CategoryTheory.IsFiltered K\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.colimitLimitToLimitColimit F)","decl":"instance colimitLimitToLimitColimit_isIso : IsIso (colimitLimitToLimitColimit F) :=\n  (isIso_iff_bijective _).mpr\n    âŸ¨colimitLimitToLimitColimit_injective F, colimitLimitToLimitColimit_surjective FâŸ©\n\n"}
{"name":"CategoryTheory.Limits.colimitLimitToLimitColimitCone_iso","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type uâ‚\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.SmallCategory J\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\ninstâœÂ¹ : Small.{v, uâ‚‚} K\ninstâœ : CategoryTheory.FinCategory J\nF : CategoryTheory.Functor J (CategoryTheory.Functor K (Type v))\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.colimitLimitToLimitColimitCone F)","decl":"instance colimitLimitToLimitColimitCone_iso (F : J â¥¤ K â¥¤ Type v) :\n    IsIso (colimitLimitToLimitColimitCone F) := by\n  have : IsIso (colimitLimitToLimitColimitCone F).hom := by\n    suffices IsIso (colimitLimitToLimitColimit (uncurry.obj F) â‰«\n        lim.map (whiskerRight (currying.unitIso.app F).inv colim)) by\n      apply IsIso.comp_isIso\n    infer_instance\n  apply Cones.cone_iso_of_hom_iso\n\n"}
{"name":"CategoryTheory.Limits.filtered_colim_preservesFiniteLimits_of_types","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"K : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\ninstâœ : Small.{v, uâ‚‚} K\nâŠ¢ CategoryTheory.Limits.PreservesFiniteLimits CategoryTheory.Limits.colim","decl":"noncomputable instance filtered_colim_preservesFiniteLimits_of_types :\n    PreservesFiniteLimits (colim : (K â¥¤ Type v) â¥¤ _) := by\n  apply preservesFiniteLimits_of_preservesFiniteLimitsOfSize.{vâ‚‚}\n  intro J _ _\n  refine âŸ¨fun {F} => âŸ¨fun {c} hc => âŸ¨IsLimit.ofIsoLimit (limit.isLimit _) ?_âŸ©âŸ©âŸ©\n  symm\n  trans colim.mapCone (limit.cone F)\n  Â· exact Functor.mapIso _ (hc.uniqueUpToIso (limit.isLimit F))\n  Â· exact asIso (colimitLimitToLimitColimitCone F)\n\n"}
{"name":"CategoryTheory.Limits.filtered_colim_preservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type uâ‚\nK : Type uâ‚‚\ninstâœÂ¹â° : CategoryTheory.SmallCategory J\ninstâœâ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\ninstâœâ¸ : Small.{v, uâ‚‚} K\ninstâœâ· : CategoryTheory.FinCategory J\nC : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.HasForget C\ninstâœâ´ : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœÂ³ : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ² : CategoryTheory.Limits.ReflectsLimitsOfShape J (CategoryTheory.forget C)\ninstâœÂ¹ : CategoryTheory.Limits.PreservesColimitsOfShape K (CategoryTheory.forget C)\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget C)\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim","decl":"noncomputable instance filtered_colim_preservesFiniteLimits :\n    PreservesLimitsOfShape J (colim : (K â¥¤ C) â¥¤ _) :=\n  haveI : PreservesLimitsOfShape J ((colim : (K â¥¤ C) â¥¤ _) â‹™ forget C) :=\n    preservesLimitsOfShape_of_natIso (preservesColimitNatIso _).symm\n  preservesLimitsOfShape_of_reflects_of_preserves _ (forget C)\n\n"}
{"name":"CategoryTheory.Limits.instPreservesFiniteLimitsFunctorColimOfPreservesColimitsOfShapeOfHasFiniteLimitsOfReflectsIsomorphismsForget","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"K : Type uâ‚‚\ninstâœâ· : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nC : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.HasForget C\ninstâœâ´ : CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.forget C)\ninstâœÂ³ : CategoryTheory.Limits.PreservesColimitsOfShape K (CategoryTheory.forget C)\ninstâœÂ² : CategoryTheory.Limits.HasFiniteLimits C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœ : (CategoryTheory.forget C).ReflectsIsomorphisms\nâŠ¢ CategoryTheory.Limits.PreservesFiniteLimits CategoryTheory.Limits.colim","decl":"noncomputable instance [PreservesFiniteLimits (forget C)] [PreservesColimitsOfShape K (forget C)]\n    [HasFiniteLimits C] [HasColimitsOfShape K C] [(forget C).ReflectsIsomorphisms] :\n    PreservesFiniteLimits (colim : (K â¥¤ C) â¥¤ _) := by\n  apply preservesFiniteLimits_of_preservesFiniteLimitsOfSize.{v}\n  intro J _ _\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.Î¹_colimitLimitIso_limit_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\nJ : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\na : K\nb : J\nZ : C\nh : Quiver.Hom ((CategoryTheory.Limits.colimit F.flip).obj b) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (CategoryTheory.Limits.limit F) a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitLimitIso F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Limits.colimit F.flip) b) h))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.Ï€ F b).app a) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.Î¹ F.flip a).app b) h))","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_colimitLimitIso_limit_Ï€ (F : J â¥¤ K â¥¤ C) (a) (b) :\n    colimit.Î¹ (limit F) a â‰« (colimitLimitIso F).hom â‰« limit.Ï€ (colimit F.flip) b =\n      (limit.Ï€ F b).app a â‰« (colimit.Î¹ F.flip a).app b := by\n  dsimp [colimitLimitIso]\n  simp only [Functor.mapCone_Ï€_app, Iso.symm_hom,\n    Limits.limit.conePointUniqueUpToIso_hom_comp_assoc, Limits.limit.cone_Ï€,\n    Limits.colimit.Î¹_map_assoc, Limits.colimitFlipIsoCompColim_inv_app, assoc,\n    Limits.HasLimit.isoOfNatIso_hom_Ï€]\n  congr 1\n  simp only [â† Category.assoc, Iso.comp_inv_eq,\n    Limits.colimitObjIsoColimitCompEvaluation_Î¹_app_hom,\n    Limits.HasColimit.isoOfNatIso_Î¹_hom, NatIso.ofComponents_hom_app]\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Î¹_colimitLimitIso_limit_Ï€","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\nJ : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\na : K\nb : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (CategoryTheory.Limits.limit F) a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitLimitIso F).hom (CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Limits.colimit F.flip) b))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.Ï€ F b).app a) ((CategoryTheory.Limits.colimit.Î¹ F.flip a).app b))","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_colimitLimitIso_limit_Ï€ (F : J â¥¤ K â¥¤ C) (a) (b) :\n    colimit.Î¹ (limit F) a â‰« (colimitLimitIso F).hom â‰« limit.Ï€ (colimit F.flip) b =\n      (limit.Ï€ F b).app a â‰« (colimit.Î¹ F.flip a).app b := by\n  dsimp [colimitLimitIso]\n  simp only [Functor.mapCone_Ï€_app, Iso.symm_hom,\n    Limits.limit.conePointUniqueUpToIso_hom_comp_assoc, Limits.limit.cone_Ï€,\n    Limits.colimit.Î¹_map_assoc, Limits.colimitFlipIsoCompColim_inv_app, assoc,\n    Limits.HasLimit.isoOfNatIso_hom_Ï€]\n  congr 1\n  simp only [â† Category.assoc, Iso.comp_inv_eq,\n    Limits.colimitObjIsoColimitCompEvaluation_Î¹_app_hom,\n    Limits.HasColimit.isoOfNatIso_Î¹_hom, NatIso.ofComponents_hom_app]\n  dsimp\n  simp\n\n"}
