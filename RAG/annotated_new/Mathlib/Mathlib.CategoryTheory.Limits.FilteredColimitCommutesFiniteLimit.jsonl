{"name":"CategoryTheory.Limits.comp_lim_obj_ext_iff","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type u‚ÇÅ\nK : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ninst‚úù : Small.{v, u‚ÇÇ} K\nj : J\nG : CategoryTheory.Functor J (CategoryTheory.Functor K (Type v))\nx y : (G.comp CategoryTheory.Limits.lim).obj j\n‚ä¢ Iff (Eq x y) (‚àÄ (k : K), Eq (CategoryTheory.Limits.limit.œÄ (G.obj j) k x) (CategoryTheory.Limits.limit.œÄ (G.obj j) k y))","decl":"/-- `(G ‚ãô lim).obj j` = `limit (G.obj j)` definitionally, so this\nis just a variant of `limit_ext'`. -/\n@[ext] lemma comp_lim_obj_ext {j : J} {G : J ‚•§ K ‚•§ Type v} (x y : (G ‚ãô lim).obj j)\n    (w : ‚àÄ (k : K), limit.œÄ (G.obj j) k x = limit.œÄ (G.obj j) k y) : x = y :=\n  limit_ext _ x y w\n\n"}
{"name":"CategoryTheory.Limits.comp_lim_obj_ext","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type u‚ÇÅ\nK : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ninst‚úù : Small.{v, u‚ÇÇ} K\nj : J\nG : CategoryTheory.Functor J (CategoryTheory.Functor K (Type v))\nx y : (G.comp CategoryTheory.Limits.lim).obj j\nw : ‚àÄ (k : K), Eq (CategoryTheory.Limits.limit.œÄ (G.obj j) k x) (CategoryTheory.Limits.limit.œÄ (G.obj j) k y)\n‚ä¢ Eq x y","decl":"/-- `(G ‚ãô lim).obj j` = `limit (G.obj j)` definitionally, so this\nis just a variant of `limit_ext'`. -/\n@[ext] lemma comp_lim_obj_ext {j : J} {G : J ‚•§ K ‚•§ Type v} (x y : (G ‚ãô lim).obj j)\n    (w : ‚àÄ (k : K), limit.œÄ (G.obj j) k x = limit.œÄ (G.obj j) k y) : x = y :=\n  limit_ext _ x y w\n\n"}
{"name":"CategoryTheory.Limits.colimitLimitToLimitColimit_injective","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type u‚ÇÅ\nK : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ninst‚úù¬≤ : Small.{v, u‚ÇÇ} K\nF : CategoryTheory.Functor (Prod J K) (Type v)\ninst‚úù¬π : CategoryTheory.IsFiltered K\ninst‚úù : Finite J\n‚ä¢ Function.Injective (CategoryTheory.Limits.colimitLimitToLimitColimit F)","decl":"/-- This follows this proof from\n* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4\n-/\ntheorem colimitLimitToLimitColimit_injective :\n    Function.Injective (colimitLimitToLimitColimit F) := by\n  classical\n    cases nonempty_fintype J\n    -- Suppose we have two terms `x y` in the colimit (over `K`) of the limits (over `J`),\n    -- and that these have the same image under `colimitLimitToLimitColimit F`.\n    intro x y h\n    -- These elements of the colimit have representatives somewhere:\n    obtain ‚ü®kx, x, rfl‚ü© := jointly_surjective' x\n    obtain ‚ü®ky, y, rfl‚ü© := jointly_surjective' y\n    dsimp at x y\n    -- Since the images of `x` and `y` are equal in a limit, they are equal componentwise\n    -- (indexed by `j : J`),\n    replace h := fun j => congr_arg (limit.œÄ (curry.obj F ‚ãô colim) j) h\n    -- and they are equations in a filtered colimit,\n    -- so for each `j` we have some place `k j` to the right of both `kx` and `ky`\n    simp? [colimit_eq_iff] at h says\n      simp only [Functor.comp_obj, colim_obj, Œπ_colimitLimitToLimitColimit_œÄ_apply,\n        colimit_eq_iff, curry_obj_obj_obj, curry_obj_obj_map] at h\n    let k j := (h j).choose\n    let f : ‚àÄ j, kx ‚ü∂ k j := fun j => (h j).choose_spec.choose\n    let g : ‚àÄ j, ky ‚ü∂ k j := fun j => (h j).choose_spec.choose_spec.choose\n    -- where the images of the components of the representatives become equal:\n    have w :\n      ‚àÄ j, F.map ((ùüô j, f j) :\n        (j, kx) ‚ü∂ (j, k j)) (limit.œÄ ((curry.obj (swap K J ‚ãô F)).obj kx) j x) =\n          F.map ((ùüô j, g j) : (j, ky) ‚ü∂ (j, k j))\n            (limit.œÄ ((curry.obj (swap K J ‚ãô F)).obj ky) j y) :=\n      fun j => (h j).choose_spec.choose_spec.choose_spec\n    -- We now use that `K` is filtered, picking some point to the right of all these\n    -- morphisms `f j` and `g j`.\n    let O : Finset K := Finset.univ.image k ‚à™ {kx, ky}\n    have kxO : kx ‚àà O := Finset.mem_union.mpr (Or.inr (by simp))\n    have kyO : ky ‚àà O := Finset.mem_union.mpr (Or.inr (by simp))\n    have kjO : ‚àÄ j, k j ‚àà O := fun j => Finset.mem_union.mpr (Or.inl (by simp))\n    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=\n      (Finset.univ.image fun j : J =>\n          ‚ü®kx, k j, kxO, Finset.mem_union.mpr (Or.inl (by simp)), f j‚ü©) ‚à™\n        Finset.univ.image fun j : J => ‚ü®ky, k j, kyO, Finset.mem_union.mpr (Or.inl (by simp)), g j‚ü©\n    obtain ‚ü®S, T, W‚ü© := IsFiltered.sup_exists O H\n    have fH : ‚àÄ j, (‚ü®kx, k j, kxO, kjO j, f j‚ü© : Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) ‚àà H :=\n      fun j =>\n      Finset.mem_union.mpr\n        (Or.inl\n          (by\n            simp only [true_and, Finset.mem_univ, eq_self_iff_true, exists_prop_of_true,\n              Finset.mem_image, heq_iff_eq]\n            refine ‚ü®j, ?_‚ü©\n            simp only [heq_iff_eq] ))\n    have gH :\n      ‚àÄ j, (‚ü®ky, k j, kyO, kjO j, g j‚ü© : Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) ‚àà H :=\n      fun j =>\n      Finset.mem_union.mpr\n        (Or.inr\n          (by\n            simp only [true_and, Finset.mem_univ, eq_self_iff_true, exists_prop_of_true,\n              Finset.mem_image, heq_iff_eq]\n            refine ‚ü®j, ?_‚ü©\n            simp only [heq_iff_eq]))\n    -- Our goal is now an equation between equivalence classes of representatives of a colimit,\n    -- and so it suffices to show those representative become equal somewhere, in particular at `S`.\n    apply colimit_sound' (T kxO) (T kyO)\n    -- We can check if two elements of a limit (in `Type`)\n    -- are equal by comparing them componentwise.\n    ext j\n    -- Now it's just a calculation using `W` and `w`.\n    simp only [Functor.comp_map, Limit.map_œÄ_apply, curry_obj_map_app, swap_map]\n    rw [‚Üê W _ _ (fH j), ‚Üê W _ _ (gH j)]\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): had to add `Limit.map_œÄ_apply`\n    -- (which was un-tagged simp since \"simp can prove it\")\n    simp [Limit.map_œÄ_apply, w]\n\n"}
{"name":"CategoryTheory.Limits.colimitLimitToLimitColimit_surjective","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type u‚ÇÅ\nK : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.SmallCategory J\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ninst‚úù¬≤ : Small.{v, u‚ÇÇ} K\ninst‚úù¬π : CategoryTheory.FinCategory J\nF : CategoryTheory.Functor (Prod J K) (Type v)\ninst‚úù : CategoryTheory.IsFiltered K\n‚ä¢ Function.Surjective (CategoryTheory.Limits.colimitLimitToLimitColimit F)","decl":"/-- This follows this proof from\n* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4\nalthough with different names.\n-/\ntheorem colimitLimitToLimitColimit_surjective :\n    Function.Surjective (colimitLimitToLimitColimit F) := by\n  classical\n    -- We begin with some element `x` in the limit (over J) over the colimits (over K),\n    intro x\n    -- This consists of some coherent family of elements in the various colimits,\n    -- and so our first task is to pick representatives of these elements.\n    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)\n    -- `k : J ‚ü∂ K` records where the representative of the\n    -- element in the `j`-th element of `x` lives\n    let k : J ‚Üí K := fun j => (z j).choose\n    -- `y j : F.obj (j, k j)` is the representative\n    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose\n    -- and we record that these representatives, when mapped back into the relevant colimits,\n    -- are actually the components of `x`.\n    have e : ‚àÄ j,\n        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=\n      fun j => (z j).choose_spec.choose_spec\n    clear_value k y\n    -- A little tidying up of things we no longer need.\n    clear z\n    -- As a first step, we use that `K` is filtered to pick some point `k' : K` above all the `k j`\n    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ\n    -- and name the morphisms as `g j : k j ‚ü∂ k'`.\n    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)\n    clear_value k'\n    -- Recalling that the components of `x`, which are indexed by `j : J`, are \"coherent\",\n    -- in other words preserved by morphisms in the `J` direction,\n    -- we see that for any morphism `f : j ‚ü∂ j'` in `J`,\n    -- the images of `y j` and `y j'`, when mapped to `F.obj (j', k')` respectively by\n    -- `(f, g j)` and `(ùüô j', g j')`, both represent the same element in the colimit.\n    have w :\n      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),\n        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =\n          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by\n      intro j j' f\n      have t : (f, g j) =\n          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by\n        simp only [id_comp, comp_id, prod_comp]\n      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,\n        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]\n      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]\n    -- Because `K` is filtered, we can restate this as saying that\n    -- for each such `f`, there is some place to the right of `k'`\n    -- where these images of `y j` and `y j'` become equal.\n    simp_rw [colimit_eq_iff] at w\n    -- We take a moment to restate `w` more conveniently.\n    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose\n    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose\n    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>\n      (w f).choose_spec.choose_spec.choose\n    have wf :\n      ‚àÄ {j j'} (f : j ‚ü∂ j'),\n        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =\n          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=\n      fun {j j'} f => by\n      have q :\n        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =\n          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=\n        (w f).choose_spec.choose_spec.choose_spec\n      rw [curry_obj_obj_map, curry_obj_obj_map] at q\n      -- Porting note: Lean 4 `dsimp` unfolds `gf` and `hf` in `q` :-(\n      -- See discussion at https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/.60dsimp.60.20unfolding.20local.20lets\n      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q\n      convert q <;> simp only [comp_id]\n    clear_value kf gf hf\n    -- and clean up some things that are no longer needed.\n    clear w\n    -- We're now ready to use the fact that `K` is filtered a second time,\n    -- picking some place to the right of all of\n    -- the morphisms `gf f : k' ‚ü∂ kh f` and `hf f : k' ‚ü∂ kf f`.\n    -- At this point we're relying on there being only finitely morphisms in `J`.\n    let O :=\n      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image\n        (@kf j j')) ‚à™ {k'}\n    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>\n      Finset.mem_union.mpr\n        (Or.inl\n          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,\n            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',\n              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))\n    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))\n    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=\n      Finset.univ.biUnion fun j : J =>\n        Finset.univ.biUnion fun j' : J =>\n          Finset.univ.biUnion fun f : j ‚ü∂ j' =>\n            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}\n    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H\n    -- We then restate this slightly more conveniently, as a family of morphism `i f : kf f ‚ü∂ k''`,\n    -- satisfying `gf f ‚â´ i f = hf f' ‚â´ i f'`.\n    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)\n    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by\n      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'\n      rw [s', s']\n      -- Porting note: the three goals here in Lean 3 were in a different order\n      ¬∑ exact k'O\n      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,\n          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,\n            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by\n              -- This works by `simp`, but has very high variation in heartbeats.\n              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,\n                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,\n                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,\n                or_true]\n              trivial‚ü©‚ü©‚ü©\n      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,\n          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,\n            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by\n              -- This works by `simp`, but has very high variation in heartbeats.\n              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,\n                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,\n                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,\n                true_or]\n              trivial‚ü©‚ü©‚ü©\n    clear_value i\n    clear s' i' H kfO k'O O\n    -- We're finally ready to construct the pre-image, and verify it really maps to `x`.\n    -- ‚ä¢ ‚àÉ a, colimitLimitToLimitColimit F a = x\n    fconstructor\n    ¬∑ -- We construct the pre-image (which, recall is meant to be a point\n      -- in the colimit (over `K`) of the limits (over `J`)) via a representative at `k''`.\n      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _\n      dsimp\n      -- This representative is meant to be an element of a limit,\n      -- so we need to construct a family of elements in `F.obj (j, k'')` for varying `j`,\n      -- then show that are coherent with respect to morphisms in the `j` direction.\n      apply Limit.mk\n      swap\n      ¬∑-- We construct the elements as the images of the `y j`.\n        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)\n      ¬∑ -- After which it's just a calculation, using `s` and `wf`, to see they are coherent.\n        dsimp\n        intro j j' f\n        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]\n        calc\n          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =\n              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) := by\n            rw [s (ùüô j) f]\n          _ =\n              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))\n                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) := by\n            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]\n          _ =\n              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))\n                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) := by\n            rw [‚Üê wf f]\n          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by\n            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]\n          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by\n            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]\n    -- Finally we check that this maps to `x`.\n    ¬∑ -- We can do this componentwise:\n      apply limit_ext\n      intro j\n      -- and as each component is an equation in a colimit, we can verify it by\n      -- pointing out the morphism which carries one representative to the other:\n      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,\n          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,\n          Functor.comp_obj, colim_obj, Limit.œÄ_mk]\n      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©\n      -- Porting note: the lean 3 proof finished with\n      -- `simp only [Bifunctor.map_id_comp, types_comp_apply, Bifunctor.map_id, types_id_apply]`\n      -- which doesn't work; the corresponding `rw` works fine:\n      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,\n        Bifunctor.map_id, types_id_apply]\n\n"}
{"name":"CategoryTheory.Limits.colimitLimitToLimitColimit_isIso","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type u‚ÇÅ\nK : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.SmallCategory J\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ninst‚úù¬≤ : Small.{v, u‚ÇÇ} K\ninst‚úù¬π : CategoryTheory.FinCategory J\nF : CategoryTheory.Functor (Prod J K) (Type v)\ninst‚úù : CategoryTheory.IsFiltered K\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.colimitLimitToLimitColimit F)","decl":"instance colimitLimitToLimitColimit_isIso : IsIso (colimitLimitToLimitColimit F) :=\n  (isIso_iff_bijective _).mpr\n    ‚ü®colimitLimitToLimitColimit_injective F, colimitLimitToLimitColimit_surjective F‚ü©\n\n"}
{"name":"CategoryTheory.Limits.colimitLimitToLimitColimitCone_iso","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type u‚ÇÅ\nK : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.SmallCategory J\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ninst‚úù¬π : Small.{v, u‚ÇÇ} K\ninst‚úù : CategoryTheory.FinCategory J\nF : CategoryTheory.Functor J (CategoryTheory.Functor K (Type v))\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.colimitLimitToLimitColimitCone F)","decl":"instance colimitLimitToLimitColimitCone_iso (F : J ‚•§ K ‚•§ Type v) :\n    IsIso (colimitLimitToLimitColimitCone F) := by\n  have : IsIso (colimitLimitToLimitColimitCone F).hom := by\n    suffices IsIso (colimitLimitToLimitColimit (uncurry.obj F) ‚â´\n        lim.map (whiskerRight (currying.unitIso.app F).inv colim)) by\n      apply IsIso.comp_isIso\n    infer_instance\n  apply Cones.cone_iso_of_hom_iso\n\n"}
{"name":"CategoryTheory.Limits.filtered_colim_preservesFiniteLimits_of_types","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"K : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ninst‚úù : Small.{v, u‚ÇÇ} K\n‚ä¢ CategoryTheory.Limits.PreservesFiniteLimits CategoryTheory.Limits.colim","decl":"noncomputable instance filtered_colim_preservesFiniteLimits_of_types :\n    PreservesFiniteLimits (colim : (K ‚•§ Type v) ‚•§ _) := by\n  apply preservesFiniteLimits_of_preservesFiniteLimitsOfSize.{v‚ÇÇ}\n  intro J _ _\n  refine ‚ü®fun {F} => ‚ü®fun {c} hc => ‚ü®IsLimit.ofIsoLimit (limit.isLimit _) ?_‚ü©‚ü©‚ü©\n  symm\n  trans colim.mapCone (limit.cone F)\n  ¬∑ exact Functor.mapIso _ (hc.uniqueUpToIso (limit.isLimit F))\n  ¬∑ exact asIso (colimitLimitToLimitColimitCone F)\n\n"}
{"name":"CategoryTheory.Limits.filtered_colim_preservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"J : Type u‚ÇÅ\nK : Type u‚ÇÇ\ninst‚úù¬π‚Å∞ : CategoryTheory.SmallCategory J\ninst‚úù‚Åπ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ninst‚úù‚Å∏ : Small.{v, u‚ÇÇ} K\ninst‚úù‚Å∑ : CategoryTheory.FinCategory J\nC : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.HasForget C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst‚úù¬≥ : CategoryTheory.Limits.HasColimitsOfShape K C\ninst‚úù¬≤ : CategoryTheory.Limits.ReflectsLimitsOfShape J (CategoryTheory.forget C)\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape K (CategoryTheory.forget C)\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget C)\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim","decl":"noncomputable instance filtered_colim_preservesFiniteLimits :\n    PreservesLimitsOfShape J (colim : (K ‚•§ C) ‚•§ _) :=\n  haveI : PreservesLimitsOfShape J ((colim : (K ‚•§ C) ‚•§ _) ‚ãô forget C) :=\n    preservesLimitsOfShape_of_natIso (preservesColimitNatIso _).symm\n  preservesLimitsOfShape_of_reflects_of_preserves _ (forget C)\n\n"}
{"name":"CategoryTheory.Limits.instPreservesFiniteLimitsFunctorColimOfPreservesColimitsOfShapeOfHasFiniteLimitsOfReflectsIsomorphismsForget","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"K : Type u‚ÇÇ\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.HasForget C\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.forget C)\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesColimitsOfShape K (CategoryTheory.forget C)\ninst‚úù¬≤ : CategoryTheory.Limits.HasFiniteLimits C\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape K C\ninst‚úù : (CategoryTheory.forget C).ReflectsIsomorphisms\n‚ä¢ CategoryTheory.Limits.PreservesFiniteLimits CategoryTheory.Limits.colim","decl":"noncomputable instance [PreservesFiniteLimits (forget C)] [PreservesColimitsOfShape K (forget C)]\n    [HasFiniteLimits C] [HasColimitsOfShape K C] [(forget C).ReflectsIsomorphisms] :\n    PreservesFiniteLimits (colim : (K ‚•§ C) ‚•§ _) := by\n  apply preservesFiniteLimits_of_preservesFiniteLimitsOfSize.{v}\n  intro J _ _\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.Œπ_colimitLimitIso_limit_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nJ : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape K C\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\na : K\nb : J\nZ : C\nh : Quiver.Hom ((CategoryTheory.Limits.colimit F.flip).obj b) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ (CategoryTheory.Limits.limit F) a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitLimitIso F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ (CategoryTheory.Limits.colimit F.flip) b) h))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.œÄ F b).app a) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.Œπ F.flip a).app b) h))","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_colimitLimitIso_limit_œÄ (F : J ‚•§ K ‚•§ C) (a) (b) :\n    colimit.Œπ (limit F) a ‚â´ (colimitLimitIso F).hom ‚â´ limit.œÄ (colimit F.flip) b =\n      (limit.œÄ F b).app a ‚â´ (colimit.Œπ F.flip a).app b := by\n  dsimp [colimitLimitIso]\n  simp only [Functor.mapCone_œÄ_app, Iso.symm_hom,\n    Limits.limit.conePointUniqueUpToIso_hom_comp_assoc, Limits.limit.cone_œÄ,\n    Limits.colimit.Œπ_map_assoc, Limits.colimitFlipIsoCompColim_inv_app, assoc,\n    Limits.HasLimit.isoOfNatIso_hom_œÄ]\n  congr 1\n  simp only [‚Üê Category.assoc, Iso.comp_inv_eq,\n    Limits.colimitObjIsoColimitCompEvaluation_Œπ_app_hom,\n    Limits.HasColimit.isoOfNatIso_Œπ_hom, NatIso.ofComponents_hom_app]\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Œπ_colimitLimitIso_limit_œÄ","module":"Mathlib.CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nJ : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape K C\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\na : K\nb : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ (CategoryTheory.Limits.limit F) a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitLimitIso F).hom (CategoryTheory.Limits.limit.œÄ (CategoryTheory.Limits.colimit F.flip) b))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.œÄ F b).app a) ((CategoryTheory.Limits.colimit.Œπ F.flip a).app b))","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_colimitLimitIso_limit_œÄ (F : J ‚•§ K ‚•§ C) (a) (b) :\n    colimit.Œπ (limit F) a ‚â´ (colimitLimitIso F).hom ‚â´ limit.œÄ (colimit F.flip) b =\n      (limit.œÄ F b).app a ‚â´ (colimit.Œπ F.flip a).app b := by\n  dsimp [colimitLimitIso]\n  simp only [Functor.mapCone_œÄ_app, Iso.symm_hom,\n    Limits.limit.conePointUniqueUpToIso_hom_comp_assoc, Limits.limit.cone_œÄ,\n    Limits.colimit.Œπ_map_assoc, Limits.colimitFlipIsoCompColim_inv_app, assoc,\n    Limits.HasLimit.isoOfNatIso_hom_œÄ]\n  congr 1\n  simp only [‚Üê Category.assoc, Iso.comp_inv_eq,\n    Limits.colimitObjIsoColimitCompEvaluation_Œπ_app_hom,\n    Limits.HasColimit.isoOfNatIso_Œπ_hom, NatIso.ofComponents_hom_app]\n  dsimp\n  simp\n\n"}
