{"name":"alternatingGroup_eq_sign_ker","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\n⊢ Eq (alternatingGroup α) Equiv.Perm.sign.ker","decl":"theorem alternatingGroup_eq_sign_ker : alternatingGroup α = sign.ker :=\n  rfl\n\n"}
{"name":"Equiv.Perm.mem_alternatingGroup","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\n⊢ Iff (Membership.mem (alternatingGroup α) f) (Eq (Equiv.Perm.sign f) 1)","decl":"@[simp]\ntheorem mem_alternatingGroup {f : Perm α} : f ∈ alternatingGroup α ↔ sign f = 1 :=\n  sign.mem_ker\n\n"}
{"name":"Equiv.Perm.prod_list_swap_mem_alternatingGroup_iff_even_length","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nl : List (Equiv.Perm α)\nhl : ∀ (g : Equiv.Perm α), Membership.mem l g → g.IsSwap\n⊢ Iff (Membership.mem (alternatingGroup α) l.prod) (Even l.length)","decl":"theorem prod_list_swap_mem_alternatingGroup_iff_even_length {l : List (Perm α)}\n    (hl : ∀ g ∈ l, IsSwap g) : l.prod ∈ alternatingGroup α ↔ Even l.length := by\n  rw [mem_alternatingGroup, sign_prod_list_swap hl, neg_one_pow_eq_one_iff_even]\n  decide\n\n"}
{"name":"Equiv.Perm.IsThreeCycle.mem_alternatingGroup","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nh : f.IsThreeCycle\n⊢ Membership.mem (alternatingGroup α) f","decl":"theorem IsThreeCycle.mem_alternatingGroup {f : Perm α} (h : IsThreeCycle f) :\n    f ∈ alternatingGroup α :=\n  Perm.mem_alternatingGroup.mpr h.sign\n\n"}
{"name":"Equiv.Perm.finRotate_bit1_mem_alternatingGroup","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"n : Nat\n⊢ Membership.mem (alternatingGroup (Fin (HAdd.hAdd (HMul.hMul 2 n) 1))) (finRotate (HAdd.hAdd (HMul.hMul 2 n) 1))","decl":"theorem finRotate_bit1_mem_alternatingGroup {n : ℕ} :\n    finRotate (2 * n + 1) ∈ alternatingGroup (Fin (2 * n + 1)) := by\n  rw [mem_alternatingGroup, sign_finRotate, pow_mul, pow_two, Int.units_mul_self, one_pow]\n\n"}
{"name":"alternatingGroup.index_eq_two","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : Nontrivial α\n⊢ Eq (alternatingGroup α).index 2","decl":"@[simp]\ntheorem alternatingGroup.index_eq_two [Nontrivial α] :\n    (alternatingGroup α).index = 2 := by\n  rw [alternatingGroup, index_ker, MonoidHom.range_eq_top.mpr (sign_surjective α)]\n  simp_rw [mem_top, Nat.card_eq_fintype_card]; rfl\n\n"}
{"name":"alternatingGroup.index_eq_one","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : Subsingleton α\n⊢ Eq (alternatingGroup α).index 1","decl":"@[nontriviality]\ntheorem alternatingGroup.index_eq_one [Subsingleton α] : (alternatingGroup α).index = 1 := by\n  rw [Subgroup.index_eq_one]; apply Subsingleton.elim\n\n"}
{"name":"two_mul_card_alternatingGroup","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : Nontrivial α\n⊢ Eq (HMul.hMul 2 (Fintype.card (Subtype fun x => Membership.mem (alternatingGroup α) x))) (Fintype.card (Equiv.Perm α))","decl":"theorem two_mul_card_alternatingGroup [Nontrivial α] :\n    2 * card (alternatingGroup α) = card (Perm α) := by\n  simp only [← Nat.card_eq_fintype_card, ← alternatingGroup.index_eq_two (α := α), index_mul_card]\n\n"}
{"name":"alternatingGroup.normal","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\n⊢ (alternatingGroup α).Normal","decl":"instance normal : (alternatingGroup α).Normal :=\n  sign.normal_ker\n\n"}
{"name":"alternatingGroup.isConj_of","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ τ : Subtype fun x => Membership.mem (alternatingGroup α) x\nhc : IsConj ↑σ ↑τ\nhσ : LE.le (HAdd.hAdd (↑σ).support.card 2) (Fintype.card α)\n⊢ IsConj σ τ","decl":"theorem isConj_of {σ τ : alternatingGroup α} (hc : IsConj (σ : Perm α) (τ : Perm α))\n    (hσ : (σ : Perm α).support.card + 2 ≤ Fintype.card α) : IsConj σ τ := by\n  obtain ⟨σ, hσ⟩ := σ\n  obtain ⟨τ, hτ⟩ := τ\n  obtain ⟨π, hπ⟩ := isConj_iff.1 hc\n  rw [Subtype.coe_mk, Subtype.coe_mk] at hπ\n  cases' Int.units_eq_one_or (Perm.sign π) with h h\n  · rw [isConj_iff]\n    refine ⟨⟨π, mem_alternatingGroup.mp h⟩, Subtype.val_injective ?_⟩\n    simpa only [Subtype.val, Subgroup.coe_mul, coe_inv, coe_mk] using hπ\n  · have h2 : 2 ≤ σ.supportᶜ.card := by\n      rw [Finset.card_compl, le_tsub_iff_left σ.support.card_le_univ]\n      exact hσ\n    obtain ⟨a, ha, b, hb, ab⟩ := Finset.one_lt_card.1 h2\n    refine isConj_iff.2 ⟨⟨π * swap a b, ?_⟩, Subtype.val_injective ?_⟩\n    · rw [mem_alternatingGroup, MonoidHom.map_mul, h, sign_swap ab, Int.units_mul_self]\n    · simp only [← hπ, coe_mk, Subgroup.coe_mul, Subtype.val]\n      have hd : Disjoint (swap a b) σ := by\n        rw [disjoint_iff_disjoint_support, support_swap ab, Finset.disjoint_insert_left,\n          Finset.disjoint_singleton_left]\n        exact ⟨Finset.mem_compl.1 ha, Finset.mem_compl.1 hb⟩\n      rw [mul_assoc π _ σ, hd.commute.eq, coe_inv, coe_mk]\n      simp [mul_assoc]\n\n"}
{"name":"alternatingGroup.isThreeCycle_isConj","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nh5 : LE.le 5 (Fintype.card α)\nσ τ : Subtype fun x => Membership.mem (alternatingGroup α) x\nhσ : (↑σ).IsThreeCycle\nhτ : (↑τ).IsThreeCycle\n⊢ IsConj σ τ","decl":"theorem isThreeCycle_isConj (h5 : 5 ≤ Fintype.card α) {σ τ : alternatingGroup α}\n    (hσ : IsThreeCycle (σ : Perm α)) (hτ : IsThreeCycle (τ : Perm α)) : IsConj σ τ :=\n  alternatingGroup.isConj_of (isConj_iff_cycleType_eq.2 (hσ.trans hτ.symm))\n    (by rwa [hσ.card_support])\n\n"}
{"name":"Equiv.Perm.closure_three_cycles_eq_alternating","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\n⊢ Eq (Subgroup.closure (setOf fun σ => σ.IsThreeCycle)) (alternatingGroup α)","decl":"@[simp]\ntheorem closure_three_cycles_eq_alternating :\n    closure { σ : Perm α | IsThreeCycle σ } = alternatingGroup α :=\n  closure_eq_of_le _ (fun _ hσ => mem_alternatingGroup.2 hσ.sign) fun σ hσ => by\n    suffices hind :\n      ∀ (n : ℕ) (l : List (Perm α)) (_ : ∀ g, g ∈ l → IsSwap g) (_ : l.length = 2 * n),\n        l.prod ∈ closure { σ : Perm α | IsThreeCycle σ } by\n      obtain ⟨l, rfl, hl⟩ := truncSwapFactors σ\n      obtain ⟨n, hn⟩ := (prod_list_swap_mem_alternatingGroup_iff_even_length hl).1 hσ\n      rw [← two_mul] at hn\n      exact hind n l hl hn\n    intro n\n    induction' n with n ih <;> intro l hl hn\n    · simp [List.length_eq_zero.1 hn, one_mem]\n    rw [Nat.mul_succ] at hn\n    obtain ⟨a, l, rfl⟩ := l.exists_of_length_succ hn\n    rw [List.length_cons, Nat.succ_inj'] at hn\n    obtain ⟨b, l, rfl⟩ := l.exists_of_length_succ hn\n    rw [List.prod_cons, List.prod_cons, ← mul_assoc]\n    rw [List.length_cons, Nat.succ_inj'] at hn\n    exact\n      mul_mem\n        (IsSwap.mul_mem_closure_three_cycles (hl a (List.mem_cons_self a _))\n          (hl b (List.mem_cons_of_mem a (l.mem_cons_self b))))\n        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)\n\n"}
{"name":"Equiv.Perm.IsThreeCycle.alternating_normalClosure","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nh5 : LE.le 5 (Fintype.card α)\nf : Equiv.Perm α\nhf : f.IsThreeCycle\n⊢ Eq (Subgroup.normalClosure (Singleton.singleton ⟨f, ⋯⟩)) Top.top","decl":"/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\n  at least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem IsThreeCycle.alternating_normalClosure (h5 : 5 ≤ Fintype.card α) {f : Perm α}\n    (hf : IsThreeCycle f) :\n    normalClosure ({⟨f, hf.mem_alternatingGroup⟩} : Set (alternatingGroup α)) = ⊤ :=\n  eq_top_iff.2\n    (by\n      have hi : Function.Injective (alternatingGroup α).subtype := Subtype.coe_injective\n      refine eq_top_iff.1 (map_injective hi (le_antisymm (map_mono le_top) ?_))\n      rw [← MonoidHom.range_eq_map, range_subtype, normalClosure, MonoidHom.map_closure]\n      refine (le_of_eq closure_three_cycles_eq_alternating.symm).trans (closure_mono ?_)\n      intro g h\n      obtain ⟨c, rfl⟩ := isConj_iff.1 (isConj_iff_cycleType_eq.2 (hf.trans h.symm))\n      refine ⟨⟨c * f * c⁻¹, h.mem_alternatingGroup⟩, ?_, rfl⟩\n      rw [Group.mem_conjugatesOfSet_iff]\n      exact ⟨⟨f, hf.mem_alternatingGroup⟩, Set.mem_singleton _, isThreeCycle_isConj h5 hf h⟩)\n\n"}
{"name":"Equiv.Perm.isThreeCycle_sq_of_three_mem_cycleType_five","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"g : Equiv.Perm (Fin 5)\nh : Membership.mem g.cycleType 3\n⊢ (HMul.hMul g g).IsThreeCycle","decl":"/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\n  its cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n  $A_5$. -/\ntheorem isThreeCycle_sq_of_three_mem_cycleType_five {g : Perm (Fin 5)} (h : 3 ∈ cycleType g) :\n    IsThreeCycle (g * g) := by\n  obtain ⟨c, g', rfl, hd, _, h3⟩ := mem_cycleType_iff.1 h\n  simp only [mul_assoc]\n  rw [hd.commute.eq, ← mul_assoc g']\n  suffices hg' : orderOf g' ∣ 2 by\n    rw [← pow_two, orderOf_dvd_iff_pow_eq_one.1 hg', one_mul]\n    exact (card_support_eq_three_iff.1 h3).isThreeCycle_sq\n  rw [← lcm_cycleType, Multiset.lcm_dvd]\n  intro n hn\n  rw [le_antisymm (two_le_of_mem_cycleType hn) (le_trans (le_card_support_of_mem_cycleType hn) _)]\n  apply le_of_add_le_add_left\n  rw [← hd.card_support_mul, h3]\n  exact (c * g').support.card_le_univ\n\n"}
{"name":"alternatingGroup.eq_bot_of_card_le_two","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nh2 : LE.le (Fintype.card α) 2\n⊢ Eq (alternatingGroup α) Bot.bot","decl":"theorem eq_bot_of_card_le_two (h2 : card α ≤ 2) : alternatingGroup α = ⊥ := by\n  nontriviality α\n  suffices hα' : card α = 2 by\n    rw [Subgroup.eq_bot_iff_card, ← Nat.mul_right_inj (a := 2) (by norm_num),\n      Nat.card_eq_fintype_card, two_mul_card_alternatingGroup, mul_one, card_perm, hα',\n      Nat.factorial_two]\n  exact h2.antisymm Fintype.one_lt_card\n\n"}
{"name":"alternatingGroup.nontrivial_of_three_le_card","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nh3 : LE.le 3 (Fintype.card α)\n⊢ Nontrivial (Subtype fun x => Membership.mem (alternatingGroup α) x)","decl":"theorem nontrivial_of_three_le_card (h3 : 3 ≤ card α) : Nontrivial (alternatingGroup α) := by\n  haveI := Fintype.one_lt_card_iff_nontrivial.1 (lt_trans (by decide) h3)\n  rw [← Fintype.one_lt_card_iff_nontrivial]\n  refine lt_of_mul_lt_mul_left ?_ (le_of_lt Nat.prime_two.pos)\n  rw [two_mul_card_alternatingGroup, card_perm, ← Nat.succ_le_iff]\n  exact le_trans h3 (card α).self_le_factorial\n\n"}
{"name":"alternatingGroup.instNontrivialSubtypePermFinHAddNatOfNatMemSubgroup","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"n : Nat\n⊢ Nontrivial (Subtype fun x => Membership.mem (alternatingGroup (Fin (HAdd.hAdd n 3))) x)","decl":"instance {n : ℕ} : Nontrivial (alternatingGroup (Fin (n + 3))) :=\n  nontrivial_of_three_le_card\n    (by\n      rw [card_fin]\n      exact le_add_left (le_refl 3))\n\n"}
{"name":"alternatingGroup.normalClosure_finRotate_five","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"⊢ Eq (Subgroup.normalClosure (Singleton.singleton ⟨finRotate 5, ⋯⟩)) Top.top","decl":"/-- The normal closure of the 5-cycle `finRotate 5` within $A_5$ is the whole group. This will be\n  used to show that the normal closure of any 5-cycle within $A_5$ is the whole group. -/\ntheorem normalClosure_finRotate_five : normalClosure ({⟨finRotate 5,\n    finRotate_bit1_mem_alternatingGroup (n := 2)⟩} : Set (alternatingGroup (Fin 5))) = ⊤ :=\n  eq_top_iff.2\n    (by\n      have h3 :\n        IsThreeCycle (Fin.cycleRange 2 * finRotate 5 * (Fin.cycleRange 2)⁻¹ * (finRotate 5)⁻¹) :=\n        card_support_eq_three_iff.1 (by decide)\n      rw [← h3.alternating_normalClosure (by rw [card_fin])]\n      refine normalClosure_le_normal ?_\n      rw [Set.singleton_subset_iff, SetLike.mem_coe]\n      have h :\n        (⟨finRotate 5, finRotate_bit1_mem_alternatingGroup (n := 2)⟩ : alternatingGroup (Fin 5)) ∈\n          normalClosure _ :=\n        SetLike.mem_coe.1 (subset_normalClosure (Set.mem_singleton _))\n      exact (mul_mem (Subgroup.normalClosure_normal.conj_mem _ h\n        -- Porting note: added `: _`\n        ⟨Fin.cycleRange 2, Fin.isThreeCycle_cycleRange_two.mem_alternatingGroup⟩) (inv_mem h) :))\n\n"}
{"name":"alternatingGroup.normalClosure_swap_mul_swap_five","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"⊢ Eq (Subgroup.normalClosure (Singleton.singleton ⟨HMul.hMul (Equiv.swap 0 4) (Equiv.swap 1 3), ⋯⟩)) Top.top","decl":"/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\n  used to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.\n  -/\ntheorem normalClosure_swap_mul_swap_five :\n    normalClosure\n        ({⟨swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)⟩} :\n          Set (alternatingGroup (Fin 5))) =\n      ⊤ := by\n  let g1 := (⟨swap 0 2 * swap 0 1, mem_alternatingGroup.2 (by decide)⟩ : alternatingGroup (Fin 5))\n  let g2 := (⟨swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)⟩ : alternatingGroup (Fin 5))\n  have h5 : g1 * g2 * g1⁻¹ * g2⁻¹ =\n      ⟨finRotate 5, finRotate_bit1_mem_alternatingGroup (n := 2)⟩ := by\n    rw [Subtype.ext_iff]\n    simp only [Fin.val_mk, Subgroup.coe_mul, Subgroup.coe_inv, Fin.val_mk]\n    decide\n  rw [eq_top_iff, ← normalClosure_finRotate_five]\n  refine normalClosure_le_normal ?_\n  rw [Set.singleton_subset_iff, SetLike.mem_coe, ← h5]\n  have h : g2 ∈ normalClosure {g2} :=\n    SetLike.mem_coe.1 (subset_normalClosure (Set.mem_singleton _))\n  exact mul_mem (Subgroup.normalClosure_normal.conj_mem _ h g1) (inv_mem h)\n\n"}
{"name":"alternatingGroup.isConj_swap_mul_swap_of_cycleType_two","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"g : Equiv.Perm (Fin 5)\nha : Membership.mem (alternatingGroup (Fin 5)) g\nh1 : Ne g 1\nh2 : ∀ (n : Nat), Membership.mem g.cycleType n → Eq n 2\n⊢ IsConj (HMul.hMul (Equiv.swap 0 4) (Equiv.swap 1 3)) g","decl":"/-- Shows that any non-identity element of $A_5$ whose cycle decomposition consists only of swaps\n  is conjugate to $(04)(13)$. This is used to show that the normal closure of such a permutation\n  in $A_5$ is $A_5$. -/\ntheorem isConj_swap_mul_swap_of_cycleType_two {g : Perm (Fin 5)} (ha : g ∈ alternatingGroup (Fin 5))\n    (h1 : g ≠ 1) (h2 : ∀ n, n ∈ cycleType (g : Perm (Fin 5)) → n = 2) :\n    IsConj (swap 0 4 * swap 1 3) g := by\n  have h := g.support.card_le_univ\n  rw [← Multiset.eq_replicate_card] at h2\n  rw [← sum_cycleType, h2, Multiset.sum_replicate, smul_eq_mul] at h\n  have h : Multiset.card g.cycleType ≤ 3 :=\n    le_of_mul_le_mul_right (le_trans h (by norm_num only [card_fin])) (by simp)\n  rw [mem_alternatingGroup, sign_of_cycleType, h2] at ha\n  norm_num at ha\n  rw [pow_add, pow_mul, Int.units_pow_two, one_mul, neg_one_pow_eq_one_iff_even] at ha\n  swap; · decide\n  rw [isConj_iff_cycleType_eq, h2]\n  interval_cases h_1 : Multiset.card g.cycleType\n  · exact (h1 (card_cycleType_eq_zero.1 h_1)).elim\n  · simp at ha\n  · have h04 : (0 : Fin 5) ≠ 4 := by decide\n    have h13 : (1 : Fin 5) ≠ 3 := by decide\n    rw [Disjoint.cycleType, (isCycle_swap h04).cycleType, (isCycle_swap h13).cycleType,\n      card_support_swap h04, card_support_swap h13]\n    · rfl\n    · rw [disjoint_iff_disjoint_support, support_swap h04, support_swap h13]\n      decide\n  · contradiction\n\n"}
{"name":"alternatingGroup.isSimpleGroup_five","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"⊢ IsSimpleGroup (Subtype fun x => Membership.mem (alternatingGroup (Fin 5)) x)","decl":"/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\n  on its cycle type that its normal closure is all of $A_5$. -/\ninstance isSimpleGroup_five : IsSimpleGroup (alternatingGroup (Fin 5)) :=\n  ⟨fun H => by\n    intro Hn\n    refine or_not.imp id fun Hb => ?_\n    rw [eq_bot_iff_forall] at Hb\n    push_neg at Hb\n    obtain ⟨⟨g, gA⟩, gH, g1⟩ : ∃ x : ↥(alternatingGroup (Fin 5)), x ∈ H ∧ x ≠ 1 := Hb\n    -- `g` is a non-identity alternating permutation in a normal subgroup `H` of $A_5$.\n    rw [← SetLike.mem_coe, ← Set.singleton_subset_iff] at gH\n    refine eq_top_iff.2 (le_trans (ge_of_eq ?_) (normalClosure_le_normal gH))\n    -- It suffices to show that the normal closure of `g` in $A_5$ is $A_5$.\n    by_cases h2 : ∀ n ∈ g.cycleType, n = 2\n    -- If the cycle decomposition of `g` consists entirely of swaps, then the cycle type is $(2,2)$.\n    -- This means that it is conjugate to $(04)(13)$, whose normal closure is $A_5$.\n    · rw [Ne, Subtype.ext_iff] at g1\n      exact\n        (isConj_swap_mul_swap_of_cycleType_two gA g1 h2).normalClosure_eq_top_of\n          normalClosure_swap_mul_swap_five\n    push_neg at h2\n    obtain ⟨n, ng, n2⟩ : ∃ n : ℕ, n ∈ g.cycleType ∧ n ≠ 2 := h2\n    -- `n` is the size of a non-swap cycle in the decomposition of `g`.\n    have n2' : 2 < n := lt_of_le_of_ne (two_le_of_mem_cycleType ng) n2.symm\n    have n5 : n ≤ 5 := le_trans ?_ g.support.card_le_univ\n    -- We check that `2 < n ≤ 5`, so that `interval_cases` has a precise range to check.\n    swap\n    · obtain ⟨m, hm⟩ := Multiset.exists_cons_of_mem ng\n      rw [← sum_cycleType, hm, Multiset.sum_cons]\n      exact le_add_right le_rfl\n    interval_cases n\n    -- This breaks into cases `n = 3`, `n = 4`, `n = 5`.\n    -- If `n = 3`, then `g` has a 3-cycle in its decomposition, so `g^2` is a 3-cycle.\n    -- `g^2` is in the normal closure of `g`, so that normal closure must be $A_5$.\n    · rw [eq_top_iff, ← (isThreeCycle_sq_of_three_mem_cycleType_five ng).alternating_normalClosure\n        (by rw [card_fin])]\n      refine normalClosure_le_normal ?_\n      rw [Set.singleton_subset_iff, SetLike.mem_coe]\n      have h := SetLike.mem_coe.1 (subset_normalClosure\n        (G := alternatingGroup (Fin 5)) (Set.mem_singleton ⟨g, gA⟩))\n      exact mul_mem h h\n    · -- The case `n = 4` leads to contradiction, as no element of $A_5$ includes a 4-cycle.\n      have con := mem_alternatingGroup.1 gA\n      rw [sign_of_cycleType, cycleType_of_card_le_mem_cycleType_add_two (by decide) ng] at con\n      have : Odd 5 := by decide\n      simp [this] at con\n    · -- If `n = 5`, then `g` is itself a 5-cycle, conjugate to `finRotate 5`.\n      refine (isConj_iff_cycleType_eq.2 ?_).normalClosure_eq_top_of normalClosure_finRotate_five\n      rw [cycleType_of_card_le_mem_cycleType_add_two (by decide) ng, cycleType_finRotate]⟩\n\n"}
{"name":"Equiv.Perm.eq_alternatingGroup_of_index_eq_two","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nG : Subgroup (Equiv.Perm α)\nhG : Eq G.index 2\n⊢ Eq G (alternatingGroup α)","decl":"/-- The alternating group is the only subgroup of index 2 of the permutation group. -/\ntheorem eq_alternatingGroup_of_index_eq_two {G : Subgroup (Equiv.Perm α)} (hG : G.index = 2) :\n    G = alternatingGroup α := by\n  nontriviality α\n  obtain ⟨_, ⟨a, b, hab, rfl⟩, habG⟩ : ∃ g : Perm α, g.IsSwap ∧ g ∉ G := by\n    by_contra! h\n    suffices G = ⊤ by rw [this, Subgroup.index_top] at hG; cases hG\n    rwa [eq_top_iff, ← closure_isSwap, G.closure_le]\n  ext g\n  refine swap_induction_on g (iff_of_true G.one_mem <| map_one _) fun g x y hxy ih ↦ ?_\n  rw [mul_mem_iff_of_index_two hG, mul_mem_iff_of_index_two alternatingGroup.index_eq_two, ih]\n  refine iff_congr (iff_of_false ?_ (by cases (sign_swap hxy).symm.trans ·)) Iff.rfl\n  contrapose! habG\n  rw [← (isConj_iff.mp <| isConj_swap hxy hab).choose_spec]\n  exact (normal_of_index_eq_two hG).conj_mem _ habG _\n\n"}
{"name":"Equiv.Perm.alternatingGroup_le_of_index_le_two","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nG : Subgroup (Equiv.Perm α)\nhG : LE.le G.index 2\n⊢ LE.le (alternatingGroup α) G","decl":"/-- A subgroup of the permutation group of index ≤ 2 contains the alternating group. -/\ntheorem alternatingGroup_le_of_index_le_two\n    {G : Subgroup (Equiv.Perm α)} (hG : G.index ≤ 2) :\n    alternatingGroup α ≤ G := by\n  cases' G.index.eq_zero_or_pos with h h\n  · exact (index_ne_zero_of_finite h).elim\n  cases' (Nat.succ_le_iff.mpr h).eq_or_gt with h h\n  · exact index_eq_one.mp h ▸ le_top\n  rw [eq_alternatingGroup_of_index_eq_two (hG.antisymm h)]\n\n"}
{"name":"instCharacteristicPermAlternatingGroup","module":"Mathlib.GroupTheory.SpecificGroups.Alternating","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\n⊢ (alternatingGroup α).Characteristic","decl":"/-- The alternating group is a characteristic subgroup of the permutation group. -/\ninstance : (alternatingGroup α).Characteristic where\n  fixed φ := by\n    nontriviality α\n    apply eq_alternatingGroup_of_index_eq_two\n    rw [index_comap_of_surjective _ (Equiv.surjective _), alternatingGroup.index_eq_two]\n"}
