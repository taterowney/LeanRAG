{"name":"CategoryTheory.GrothendieckTopology.close_apply","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX : C\nS : CategoryTheory.Sieve X\nx✝ : C\nf : Quiver.Hom x✝ X\n⊢ Eq ((J₁.close S).arrows f) (J₁.Covers S f)","decl":"/-- The `J`-closure of a sieve is the collection of arrows which it covers. -/\n@[simps]\ndef close {X : C} (S : Sieve X) : Sieve X where\n  arrows _ f := J₁.Covers S f\n  downward_closed hS := J₁.arrow_stable _ _ hS\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.le_close","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX : C\nS : CategoryTheory.Sieve X\n⊢ LE.le S (J₁.close S)","decl":"/-- Any sieve is smaller than its closure. -/\ntheorem le_close {X : C} (S : Sieve X) : S ≤ J₁.close S :=\n  fun _ _ hg => J₁.covering_of_eq_top (S.pullback_eq_top_of_mem hg)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.covers_iff_mem_of_isClosed","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX : C\nS : CategoryTheory.Sieve X\nh : J₁.IsClosed S\nY : C\nf : Quiver.Hom Y X\n⊢ Iff (J₁.Covers S f) (S.arrows f)","decl":"/-- If `S` is `J₁`-closed, then `S` covers exactly the arrows it contains. -/\ntheorem covers_iff_mem_of_isClosed {X : C} {S : Sieve X} (h : J₁.IsClosed S) {Y : C} (f : Y ⟶ X) :\n    J₁.Covers S f ↔ S f :=\n  ⟨h _, J₁.arrow_max _ _⟩\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.isClosed_pullback","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX Y : C\nf : Quiver.Hom Y X\nS : CategoryTheory.Sieve X\na✝ : J₁.IsClosed S\n⊢ J₁.IsClosed (CategoryTheory.Sieve.pullback f S)","decl":"/-- Being `J`-closed is stable under pullback. -/\ntheorem isClosed_pullback {X Y : C} (f : Y ⟶ X) (S : Sieve X) :\n    J₁.IsClosed S → J₁.IsClosed (S.pullback f) :=\n  fun hS Z g hg => hS (g ≫ f) (by rwa [J₁.covers_iff, Sieve.pullback_comp])\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.le_close_of_isClosed","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX : C\nS T : CategoryTheory.Sieve X\nh : LE.le S T\nhT : J₁.IsClosed T\n⊢ LE.le (J₁.close S) T","decl":"/-- The closure of a sieve `S` is the largest closed sieve which contains `S` (justifying the name\n\"closure\").\n-/\ntheorem le_close_of_isClosed {X : C} {S T : Sieve X} (h : S ≤ T) (hT : J₁.IsClosed T) :\n    J₁.close S ≤ T :=\n  fun _ f hf => hT _ (J₁.superset_covering (Sieve.pullback_monotone f h) hf)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.close_isClosed","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX : C\nS : CategoryTheory.Sieve X\n⊢ J₁.IsClosed (J₁.close S)","decl":"/-- The closure of a sieve is closed. -/\ntheorem close_isClosed {X : C} (S : Sieve X) : J₁.IsClosed (J₁.close S) :=\n  fun _ g hg => J₁.arrow_trans g _ S hg fun _ hS => hS\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.closureOperator_isClosed","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Eq ((J₁.closureOperator X).IsClosed S) (J₁.IsClosed S)","decl":"/-- A Grothendieck topology induces a natural family of closure operators on sieves. -/\n@[simps! isClosed]\ndef closureOperator (X : C) : ClosureOperator (Sieve X) :=\n  .ofPred J₁.close J₁.IsClosed J₁.le_close J₁.close_isClosed fun _ _ ↦ J₁.le_close_of_isClosed\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.isClosed_iff_close_eq_self","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (J₁.IsClosed S) (Eq (J₁.close S) S)","decl":"/-- The sieve `S` is closed iff its closure is equal to itself. -/\ntheorem isClosed_iff_close_eq_self {X : C} (S : Sieve X) : J₁.IsClosed S ↔ J₁.close S = S :=\n  (J₁.closureOperator _).isClosed_iff\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.close_eq_self_of_isClosed","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX : C\nS : CategoryTheory.Sieve X\nhS : J₁.IsClosed S\n⊢ Eq (J₁.close S) S","decl":"theorem close_eq_self_of_isClosed {X : C} {S : Sieve X} (hS : J₁.IsClosed S) : J₁.close S = S :=\n  (J₁.isClosed_iff_close_eq_self S).1 hS\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.pullback_close","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX Y : C\nf : Quiver.Hom Y X\nS : CategoryTheory.Sieve X\n⊢ Eq (J₁.close (CategoryTheory.Sieve.pullback f S)) (CategoryTheory.Sieve.pullback f (J₁.close S))","decl":"/-- Closing under `J` is stable under pullback. -/\ntheorem pullback_close {X Y : C} (f : Y ⟶ X) (S : Sieve X) :\n    J₁.close (S.pullback f) = (J₁.close S).pullback f := by\n  apply le_antisymm\n  · refine J₁.le_close_of_isClosed (Sieve.pullback_monotone _ (J₁.le_close S)) ?_\n    apply J₁.isClosed_pullback _ _ (J₁.close_isClosed _)\n  · intro Z g hg\n    change _ ∈ J₁ _\n    rw [← Sieve.pullback_comp]\n    apply hg\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.monotone_close","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX : C\n⊢ Monotone J₁.close","decl":"@[mono]\ntheorem monotone_close {X : C} : Monotone (J₁.close : Sieve X → Sieve X) :=\n  (J₁.closureOperator _).monotone\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.close_close","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Eq (J₁.close (J₁.close S)) (J₁.close S)","decl":"@[simp]\ntheorem close_close {X : C} (S : Sieve X) : J₁.close (J₁.close S) = J₁.close S :=\n  (J₁.closureOperator _).idempotent _\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.close_eq_top_iff_mem","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (Eq (J₁.close S) Top.top) (Membership.mem (J₁ X) S)","decl":"/--\nThe sieve `S` is in the topology iff its closure is the maximal sieve. This shows that the closure\noperator determines the topology.\n-/\ntheorem close_eq_top_iff_mem {X : C} (S : Sieve X) : J₁.close S = ⊤ ↔ S ∈ J₁ X := by\n  constructor\n  · intro h\n    apply J₁.transitive (J₁.top_mem X)\n    intro Y f hf\n    change J₁.close S f\n    rwa [h]\n  · intro hS\n    rw [eq_top_iff]\n    intro Y f _\n    apply J₁.pullback_stable _ hS\n\n"}
{"name":"CategoryTheory.Functor.closedSieves_obj","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX : Opposite C\n⊢ Eq ((CategoryTheory.Functor.closedSieves J₁).obj X) (Subtype fun S => J₁.IsClosed S)","decl":"/--\nThe presheaf sending each object to the set of `J`-closed sieves on it. This presheaf is a `J`-sheaf\n(and will turn out to be a subobject classifier for the category of `J`-sheaves).\n-/\n@[simps]\ndef Functor.closedSieves : Cᵒᵖ ⥤ Type max v u where\n  obj X := { S : Sieve X.unop // J₁.IsClosed S }\n  map f S := ⟨S.1.pullback f.unop, J₁.isClosed_pullback f.unop _ S.2⟩\n\n"}
{"name":"CategoryTheory.Functor.closedSieves_map_coe","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\nX✝ Y✝ : Opposite C\nf : Quiver.Hom X✝ Y✝\nS : Subtype fun S => J₁.IsClosed S\n⊢ Eq (↑((CategoryTheory.Functor.closedSieves J₁).map f S)) (CategoryTheory.Sieve.pullback f.unop ↑S)","decl":"/--\nThe presheaf sending each object to the set of `J`-closed sieves on it. This presheaf is a `J`-sheaf\n(and will turn out to be a subobject classifier for the category of `J`-sheaves).\n-/\n@[simps]\ndef Functor.closedSieves : Cᵒᵖ ⥤ Type max v u where\n  obj X := { S : Sieve X.unop // J₁.IsClosed S }\n  map f S := ⟨S.1.pullback f.unop, J₁.isClosed_pullback f.unop _ S.2⟩\n\n"}
{"name":"CategoryTheory.classifier_isSheaf","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\n⊢ CategoryTheory.Presieve.IsSheaf J₁ (CategoryTheory.Functor.closedSieves J₁)","decl":"/-- The presheaf of `J`-closed sieves is a `J`-sheaf.\nThe proof of this is adapted from [MM92], Chapter III, Section 7, Lemma 1.\n-/\ntheorem classifier_isSheaf : Presieve.IsSheaf J₁ (Functor.closedSieves J₁) := by\n  intro X S hS\n  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]\n  refine ⟨?_, ?_⟩\n  · rintro x ⟨M, hM⟩ ⟨N, hN⟩ hM₂ hN₂\n    simp only [Functor.closedSieves_obj]\n    ext Y f\n    dsimp only [Subtype.coe_mk]\n    rw [← J₁.covers_iff_mem_of_isClosed hM, ← J₁.covers_iff_mem_of_isClosed hN]\n    have q : ∀ ⦃Z : C⦄ (g : Z ⟶ X) (_ : S g), M.pullback g = N.pullback g :=\n      fun Z g hg => congr_arg Subtype.val ((hM₂ g hg).trans (hN₂ g hg).symm)\n    have MSNS : M ⊓ S = N ⊓ S := by\n      ext Z g\n      rw [Sieve.inter_apply, Sieve.inter_apply]\n      simp only [and_comm]\n      apply and_congr_right\n      intro hg\n      rw [Sieve.pullback_eq_top_iff_mem, Sieve.pullback_eq_top_iff_mem, q g hg]\n    constructor\n    · intro hf\n      rw [J₁.covers_iff]\n      apply J₁.superset_covering (Sieve.pullback_monotone f inf_le_left)\n      rw [← MSNS]\n      apply J₁.arrow_intersect f M S hf (J₁.pullback_stable _ hS)\n    · intro hf\n      rw [J₁.covers_iff]\n      apply J₁.superset_covering (Sieve.pullback_monotone f inf_le_left)\n      rw [MSNS]\n      apply J₁.arrow_intersect f N S hf (J₁.pullback_stable _ hS)\n  · intro x hx\n    rw [Presieve.compatible_iff_sieveCompatible] at hx\n    let M := Sieve.bind S fun Y f hf => (x f hf).1\n    have : ∀ ⦃Y⦄ (f : Y ⟶ X) (hf : S f), M.pullback f = (x f hf).1 := by\n      intro Y f hf\n      apply le_antisymm\n      · rintro Z u ⟨W, g, f', hf', hg : (x f' hf').1 _, c⟩\n        rw [Sieve.pullback_eq_top_iff_mem,\n          ← show (x (u ≫ f) _).1 = (x f hf).1.pullback u from congr_arg Subtype.val (hx f u hf)]\n        conv_lhs => congr; congr; rw [← c] -- Porting note: Originally `simp_rw [← c]`\n        rw [show (x (g ≫ f') _).1 = _ from congr_arg Subtype.val (hx f' g hf')]\n        apply Sieve.pullback_eq_top_of_mem _ hg\n      · apply Sieve.le_pullback_bind S fun Y f hf => (x f hf).1\n    refine ⟨⟨_, J₁.close_isClosed M⟩, ?_⟩\n    intro Y f hf\n    simp only [Functor.closedSieves_obj]\n    ext1\n    dsimp\n    rw [← J₁.pullback_close, this _ hf]\n    apply le_antisymm (J₁.le_close_of_isClosed le_rfl (x f hf).2) (J₁.le_close _)\n\n"}
{"name":"CategoryTheory.le_topology_of_closedSieves_isSheaf","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ J₂ : CategoryTheory.GrothendieckTopology C\nh : CategoryTheory.Presieve.IsSheaf J₁ (CategoryTheory.Functor.closedSieves J₂)\n⊢ LE.le J₁ J₂","decl":"/-- If presheaf of `J₁`-closed sieves is a `J₂`-sheaf then `J₁ ≤ J₂`. Note the converse is true by\n`classifier_isSheaf` and `isSheaf_of_le`.\n-/\ntheorem le_topology_of_closedSieves_isSheaf {J₁ J₂ : GrothendieckTopology C}\n    (h : Presieve.IsSheaf J₁ (Functor.closedSieves J₂)) : J₁ ≤ J₂ := by\n  intro X S hS\n  rw [← J₂.close_eq_top_iff_mem]\n  have : J₂.IsClosed (⊤ : Sieve X) := by\n    intro Y f _\n    trivial\n  suffices (⟨J₂.close S, J₂.close_isClosed S⟩ : Subtype _) = ⟨⊤, this⟩ by\n    rw [Subtype.ext_iff] at this\n    exact this\n  apply (h S hS).isSeparatedFor.ext\n  intro Y f hf\n  simp only [Functor.closedSieves_obj]\n  ext1\n  dsimp\n  rw [Sieve.pullback_top, ← J₂.pullback_close, S.pullback_eq_top_of_mem hf,\n    J₂.close_eq_top_iff_mem]\n  apply J₂.top_mem\n\n"}
{"name":"CategoryTheory.topology_eq_iff_same_sheaves","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ J₂ : CategoryTheory.GrothendieckTopology C\n⊢ Iff (Eq J₁ J₂) (∀ (P : CategoryTheory.Functor (Opposite C) (Type (max v u))), Iff (CategoryTheory.Presieve.IsSheaf J₁ P) (CategoryTheory.Presieve.IsSheaf J₂ P))","decl":"/-- If being a sheaf for `J₁` is equivalent to being a sheaf for `J₂`, then `J₁ = J₂`. -/\ntheorem topology_eq_iff_same_sheaves {J₁ J₂ : GrothendieckTopology C} :\n    J₁ = J₂ ↔ ∀ P : Cᵒᵖ ⥤ Type max v u, Presieve.IsSheaf J₁ P ↔ Presieve.IsSheaf J₂ P := by\n  constructor\n  · rintro rfl\n    intro P\n    rfl\n  · intro h\n    apply le_antisymm\n    · apply le_topology_of_closedSieves_isSheaf\n      rw [h]\n      apply classifier_isSheaf\n    · apply le_topology_of_closedSieves_isSheaf\n      rw [← h]\n      apply classifier_isSheaf\n\n"}
{"name":"CategoryTheory.topologyOfClosureOperator_sieves","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nc : (X : C) → ClosureOperator (CategoryTheory.Sieve X)\nhc : ∀ ⦃X Y : C⦄ (f : Quiver.Hom Y X) (S : CategoryTheory.Sieve X), Eq ((c Y) (CategoryTheory.Sieve.pullback f S)) (CategoryTheory.Sieve.pullback f ((c X) S))\nX : C\n⊢ Eq ((CategoryTheory.topologyOfClosureOperator c hc).sieves X) (setOf fun S => Eq ((c X) S) Top.top)","decl":"/--\nA closure (increasing, inflationary and idempotent) operation on sieves that commutes with pullback\ninduces a Grothendieck topology.\nIn fact, such operations are in bijection with Grothendieck topologies.\n-/\n@[simps]\ndef topologyOfClosureOperator (c : ∀ X : C, ClosureOperator (Sieve X))\n    (hc : ∀ ⦃X Y : C⦄ (f : Y ⟶ X) (S : Sieve X), c _ (S.pullback f) = (c _ S).pullback f) :\n    GrothendieckTopology C where\n  sieves X := { S | c X S = ⊤ }\n  top_mem' X := top_unique ((c X).le_closure _)\n  pullback_stable' X Y S f hS := by\n    rw [Set.mem_setOf_eq] at hS\n    rw [Set.mem_setOf_eq, hc, hS, Sieve.pullback_top]\n  transitive' X S hS R hR := by\n    rw [Set.mem_setOf_eq] at hS\n    rw [Set.mem_setOf_eq, ← (c X).idempotent, eq_top_iff, ← hS]\n    apply (c X).monotone fun Y f hf => _\n    intros Y f hf\n    rw [Sieve.pullback_eq_top_iff_mem, ← hc]\n    apply hR hf\n\n"}
{"name":"CategoryTheory.topologyOfClosureOperator_self","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nJ₁ : CategoryTheory.GrothendieckTopology C\n⊢ Eq (CategoryTheory.topologyOfClosureOperator J₁.closureOperator ⋯) J₁","decl":"/--\nThe topology given by the closure operator `J.close` on a Grothendieck topology is the same as `J`.\n-/\ntheorem topologyOfClosureOperator_self :\n    (topologyOfClosureOperator J₁.closureOperator fun _ _ => J₁.pullback_close) = J₁ := by\n  ext X S\n  apply GrothendieckTopology.close_eq_top_iff_mem\n\n"}
{"name":"CategoryTheory.topologyOfClosureOperator_close","module":"Mathlib.CategoryTheory.Sites.Closed","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nc : (X : C) → ClosureOperator (CategoryTheory.Sieve X)\npb : ∀ ⦃X Y : C⦄ (f : Quiver.Hom Y X) (S : CategoryTheory.Sieve X), Eq ((c Y) (CategoryTheory.Sieve.pullback f S)) (CategoryTheory.Sieve.pullback f ((c X) S))\nX : C\nS : CategoryTheory.Sieve X\n⊢ Eq ((CategoryTheory.topologyOfClosureOperator c pb).close S) ((c X) S)","decl":"theorem topologyOfClosureOperator_close (c : ∀ X : C, ClosureOperator (Sieve X))\n    (pb : ∀ ⦃X Y : C⦄ (f : Y ⟶ X) (S : Sieve X), c Y (S.pullback f) = (c X S).pullback f) (X : C)\n    (S : Sieve X) : (topologyOfClosureOperator c pb).close S = c X S := by\n  ext Y f\n  change c _ (Sieve.pullback f S) = ⊤ ↔ c _ S f\n  rw [pb, Sieve.pullback_eq_top_iff_mem]\n\n"}
