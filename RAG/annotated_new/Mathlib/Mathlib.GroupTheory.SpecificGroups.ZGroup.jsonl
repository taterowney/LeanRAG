{"name":"isZGroup_iff","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Iff (IsZGroup G) (∀ (p : Nat), Nat.Prime p → ∀ (P : Sylow p G), IsCyclic (Subtype fun x => Membership.mem (↑P) x))","decl":"/-- A Z-group is a group whose Sylow subgroups are all cyclic. -/\n@[mk_iff] class IsZGroup : Prop where\n  isZGroup : ∀ p : ℕ, p.Prime → ∀ P : Sylow p G, IsCyclic P\n\n"}
{"name":"IsZGroup.isZGroup","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝ : Group G\nself : IsZGroup G\np : Nat\na✝ : Nat.Prime p\nP : Sylow p G\n⊢ IsCyclic (Subtype fun x => Membership.mem (↑P) x)","decl":"/-- A Z-group is a group whose Sylow subgroups are all cyclic. -/\n@[mk_iff] class IsZGroup : Prop where\n  isZGroup : ∀ p : ℕ, p.Prime → ∀ P : Sylow p G, IsCyclic P\n\n"}
{"name":"IsZGroup.instOfIsCyclic","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : IsCyclic G\n⊢ IsZGroup G","decl":"instance [IsCyclic G] : IsZGroup G :=\n  ⟨inferInstance⟩\n\n"}
{"name":"IsZGroup.instIsCyclicSubtypeMemSubgroupOfFactPrime","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : IsZGroup G\np : Nat\ninst✝ : Fact (Nat.Prime p)\nP : Sylow p G\n⊢ IsCyclic (Subtype fun x => Membership.mem (↑P) x)","decl":"instance [IsZGroup G] {p : ℕ} [Fact p.Prime] (P : Sylow p G) : IsCyclic P :=\n  isZGroup p Fact.out P\n\n"}
{"name":"IsPGroup.isCyclic_of_isZGroup","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : IsZGroup G\np : Nat\ninst✝ : Fact (Nat.Prime p)\nP : Subgroup G\nhP : IsPGroup p (Subtype fun x => Membership.mem P x)\n⊢ IsCyclic (Subtype fun x => Membership.mem P x)","decl":"theorem _root_.IsPGroup.isCyclic_of_isZGroup [IsZGroup G] {p : ℕ} [Fact p.Prime]\n    {P : Subgroup G} (hP : IsPGroup p P) : IsCyclic P := by\n  obtain ⟨Q, hQ⟩ := hP.exists_le_sylow\n  exact Subgroup.isCyclic_of_le hQ\n\n"}
{"name":"IsZGroup.of_squarefree","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝ : Group G\nhG : Squarefree (Nat.card G)\n⊢ IsZGroup G","decl":"theorem of_squarefree (hG : Squarefree (Nat.card G)) : IsZGroup G := by\n  have : Finite G := Nat.finite_of_card_ne_zero hG.ne_zero\n  refine ⟨fun p hp P ↦ ?_⟩\n  have := Fact.mk hp\n  obtain ⟨k, hk⟩ := P.2.exists_card_eq\n  exact isCyclic_of_card_dvd_prime ((hk ▸ hG.pow_dvd_of_pow_dvd) P.card_subgroup_dvd_card)\n\n"}
{"name":"IsZGroup.of_injective","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nf : MonoidHom G G'\nhG' : IsZGroup G'\nhf : Function.Injective ⇑f\n⊢ IsZGroup G","decl":"theorem of_injective [hG' : IsZGroup G'] (hf : Function.Injective f) : IsZGroup G := by\n  rw [isZGroup_iff] at hG' ⊢\n  intro p hp P\n  obtain ⟨Q, hQ⟩ := P.exists_comap_eq_of_injective hf\n  specialize hG' p hp Q\n  have h : Subgroup.map f P ≤ Q := hQ ▸ Subgroup.map_comap_le f ↑Q\n  have := isCyclic_of_surjective _ (Subgroup.subgroupOfEquivOfLe h).surjective\n  exact isCyclic_of_surjective _ (Subgroup.equivMapOfInjective P f hf).symm.surjective\n\n"}
{"name":"IsZGroup.instSubtypeMemSubgroup","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : IsZGroup G\nH : Subgroup G\n⊢ IsZGroup (Subtype fun x => Membership.mem H x)","decl":"instance [IsZGroup G] (H : Subgroup G) : IsZGroup H := of_injective H.subtype_injective\n\n"}
{"name":"IsZGroup.of_surjective","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝² : Group G\ninst✝¹ : Group G'\nf : MonoidHom G G'\ninst✝ : Finite G\nhG : IsZGroup G\nhf : Function.Surjective ⇑f\n⊢ IsZGroup G'","decl":"theorem of_surjective [Finite G] [hG : IsZGroup G] (hf : Function.Surjective f) : IsZGroup G' := by\n  rw [isZGroup_iff] at hG ⊢\n  intro p hp P\n  have := Fact.mk hp\n  obtain ⟨Q, rfl⟩ := Sylow.mapSurjective_surjective hf p P\n  specialize hG p hp Q\n  exact isCyclic_of_surjective _ (f.subgroupMap_surjective Q)\n\n"}
{"name":"IsZGroup.instQuotientSubgroupOfFinite","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : Finite G\ninst✝¹ : IsZGroup G\nH : Subgroup G\ninst✝ : H.Normal\n⊢ IsZGroup (HasQuotient.Quotient G H)","decl":"instance [Finite G] [IsZGroup G] (H : Subgroup G) [H.Normal] : IsZGroup (G ⧸ H) :=\n  of_surjective (QuotientGroup.mk'_surjective H)\n\n"}
{"name":"IsZGroup.commutator_lt","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : Finite G\ninst✝¹ : IsZGroup G\ninst✝ : Nontrivial G\n⊢ LT.lt (commutator G) Top.top","decl":"variable (G) in\ntheorem commutator_lt [Finite G] [IsZGroup G] [Nontrivial G] : commutator G < ⊤ := by\n  let p := (Nat.card G).minFac\n  have hp : p.Prime := Nat.minFac_prime Finite.one_lt_card.ne'\n  have := Fact.mk hp\n  let P : Sylow p G := default\n  have hP := isZGroup p hp P\n  let f := MonoidHom.transferSylow P (hP.normalizer_le_centralizer rfl)\n  refine lt_of_le_of_lt (Abelianization.commutator_subset_ker f) ?_\n  have h := P.ne_bot_of_dvd_card (Nat.card G).minFac_dvd\n  contrapose! h\n  rw [← Subgroup.isComplement'_top_left, ← (not_lt_top_iff.mp h)]\n  exact hP.isComplement' rfl\n\n"}
{"name":"IsZGroup.instIsSolvableOfFinite","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : Finite G\ninst✝ : IsZGroup G\n⊢ IsSolvable G","decl":"instance [Finite G] [IsZGroup G] : IsSolvable G := by\n  rw [isSolvable_iff_commutator_lt]\n  intro H h\n  rw [← H.nontrivial_iff_ne_bot] at h\n  rw [← H.range_subtype, MonoidHom.range_eq_map, ← Subgroup.map_commutator,\n    Subgroup.map_subtype_lt_map_subtype]\n  exact commutator_lt H\n\n"}
{"name":"IsZGroup.exponent_eq_card","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : Finite G\ninst✝ : IsZGroup G\n⊢ Eq (Monoid.exponent G) (Nat.card G)","decl":"variable (G) in\ntheorem exponent_eq_card [Finite G] [IsZGroup G] : Monoid.exponent G = Nat.card G := by\n  refine dvd_antisymm Group.exponent_dvd_nat_card ?_\n  rw [← Nat.factorization_prime_le_iff_dvd Nat.card_pos.ne' Monoid.exponent_ne_zero_of_finite]\n  intro p hp\n  have := Fact.mk hp\n  let P : Sylow p G := default\n  rw [← hp.pow_dvd_iff_le_factorization Monoid.exponent_ne_zero_of_finite,\n      ← P.card_eq_multiplicity, ← (isZGroup p hp P).exponent_eq_card]\n  exact Monoid.exponent_dvd_of_monoidHom P.1.subtype P.1.subtype_injective\n\n"}
{"name":"IsZGroup.instIsCyclicOfFiniteOfIsNilpotent","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : Finite G\ninst✝ : IsZGroup G\nhG : Group.IsNilpotent G\n⊢ IsCyclic G","decl":"instance [Finite G] [IsZGroup G] [hG : Group.IsNilpotent G] : IsCyclic G := by\n  have (p : { x // x ∈ (Nat.card G).primeFactors }) : Fact p.1.Prime :=\n    ⟨Nat.prime_of_mem_primeFactors p.2⟩\n  obtain ⟨ϕ⟩ := ((isNilpotent_of_finite_tfae (G := G)).out 0 4).mp hG\n  let _ : CommGroup G :=\n    ⟨fun g h ↦ by rw [← ϕ.symm.injective.eq_iff, map_mul, mul_comm, ← map_mul]⟩\n  exact IsCyclic.of_exponent_eq_card (exponent_eq_card G)\n\n"}
{"name":"IsZGroup.isCyclic_abelianization","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : Finite G\ninst✝ : IsZGroup G\n⊢ IsCyclic (Abelianization G)","decl":"/-- A finite Z-group has cyclic abelianization. -/\ninstance isCyclic_abelianization [Finite G] [IsZGroup G] : IsCyclic (Abelianization G) :=\n  let _ : IsZGroup (Abelianization G) := inferInstanceAs (IsZGroup (G ⧸ commutator G))\n  inferInstance\n\n"}
{"name":"IsZGroup.isCyclic_commutator","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : Finite G\ninst✝ : IsZGroup G\n⊢ IsCyclic (Subtype fun x => Membership.mem (commutator G) x)","decl":"variable (G) in\n/-- A finite Z-group has cyclic commutator subgroup. -/\ntheorem isCyclic_commutator [Finite G] [IsZGroup G] : IsCyclic (commutator G) := by\n  refine WellFoundedLT.induction (C := fun H ↦ IsCyclic (⁅H, H⁆ : Subgroup G)) (⊤ : Subgroup G) ?_\n  intro H hH\n  rcases eq_or_ne H ⊥ with rfl | h\n  · rw [Subgroup.commutator_bot_left]\n    infer_instance\n  · specialize hH ⁅H, H⁆ (IsSolvable.commutator_lt_of_ne_bot h)\n    replace hH : IsCyclic (⁅commutator H, commutator H⁆ : Subgroup H) := by\n      let f := Subgroup.equivMapOfInjective ⁅commutator H, commutator H⁆ _ H.subtype_injective\n      rw [Subgroup.map_commutator, Subgroup.map_subtype_commutator] at f\n      exact isCyclic_of_surjective f.symm f.symm.surjective\n    suffices IsCyclic (commutator H) by\n      let f := Subgroup.equivMapOfInjective (commutator H) _ H.subtype_injective\n      rw [Subgroup.map_subtype_commutator] at f\n      exact isCyclic_of_surjective f f.surjective\n    suffices h : commutator (commutator H) ≤ Subgroup.center (commutator H) by\n      rw [← Abelianization.ker_of (commutator H)] at h\n      let _ := commGroupOfCyclicCenterQuotient Abelianization.of h\n      infer_instance\n    suffices h : (commutator (commutator H)).map (commutator H).subtype ≤\n        Subgroup.centralizer (commutator H) by\n      simpa [SetLike.le_def, Subgroup.mem_center_iff, Subgroup.mem_centralizer_iff] using h\n    rw [Subgroup.map_subtype_commutator, Subgroup.le_centralizer_iff]\n    let _ := (hH.mulAutMulEquiv _).toMonoidHom.commGroupOfInjective (hH.mulAutMulEquiv _).injective\n    have h := Abelianization.commutator_subset_ker ⁅commutator H, commutator H⁆.normalizerMonoidHom\n    rwa [Subgroup.normalizerMonoidHom_ker, Subgroup.normalizer_eq_top,\n      ← Subgroup.map_subtype_le_map_subtype, Subgroup.map_subtype_commutator,\n        Subgroup.map_subgroupOf_eq_of_le le_top] at h\n\n"}
{"name":"IsPGroup.smul_mul_inv_trivial_or_surjective","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝⁴ : Group G\np : Nat\ninst✝³ : Fact (Nat.Prime p)\ninst✝² : IsCyclic G\nhG : IsPGroup p G\nK : Type u_4\ninst✝¹ : Group K\ninst✝ : MulDistribMulAction K G\nhGK : (Nat.card G).Coprime (Nat.card K)\n⊢ Or (∀ (g : G) (k : K), Eq (HMul.hMul (HSMul.hSMul k g) (Inv.inv g)) 1) (∀ (g : G), Exists fun k => Exists fun q => Eq (HMul.hMul (HSMul.hSMul k q) (Inv.inv q)) g)","decl":"/-- If a cyclic `p`-group `G` acts on a group `K` of coprime order, then the map `K × G → G`\n  defined by `(k, g) ↦ k • g * g⁻¹` is either trivial or surjective. -/\ntheorem smul_mul_inv_trivial_or_surjective [IsCyclic G] (hG : IsPGroup p G)\n    {K : Type*} [Group K] [MulDistribMulAction K G] (hGK : (Nat.card G).Coprime (Nat.card K)) :\n    (∀ g : G, ∀ k : K, k • g * g⁻¹ = 1) ∨ (∀ g : G, ∃ k : K, ∃ q : G, k • q * q⁻¹ = g) := by\n  by_cases hc : Nat.card G = 0\n  · rw [hc, Nat.coprime_zero_left, Nat.card_eq_one_iff_unique] at hGK\n    simp [← hGK.1.elim 1]\n  have := Nat.finite_of_card_ne_zero hc\n  let ϕ := MulDistribMulAction.toMonoidHomZModOfIsCyclic G K rfl\n  have h (g : G) (k : K) (n : ℤ) (h : ϕ k - 1 = n) : k • g * g⁻¹ = g ^ n := by\n    rw [sub_eq_iff_eq_add, ← Int.cast_one, ← Int.cast_add] at h\n    rw [MulDistribMulAction.toMonoidHomZModOfIsCyclic_apply rfl k g (n + 1) h,\n      zpow_add_one, mul_inv_cancel_right]\n  replace hG k : ϕ k = 1 ∨ IsUnit (ϕ k - 1) := by\n    obtain ⟨n, hn⟩ := hG.exists_card_eq\n    exact ZMod.eq_one_or_isUnit_sub_one hn (ϕ k)\n      (hGK.symm.coprime_dvd_left ((orderOf_map_dvd ϕ k).trans (orderOf_dvd_natCard k)))\n  rcases forall_or_exists_not (fun k : K ↦ ϕ k = 1) with hϕ | ⟨k, hk⟩\n  · exact Or.inl fun p k ↦ by rw [h p k 0 (by rw [hϕ, sub_self, Int.cast_zero]), zpow_zero]\n  · obtain ⟨⟨u, v, -, hvu⟩, hu : u = ϕ k - 1⟩ := (hG k).resolve_left hk\n    rw [← u.intCast_zmod_cast] at hu hvu\n    rw [← v.intCast_zmod_cast, ← Int.cast_mul, ← Int.cast_one, ZMod.intCast_eq_intCast_iff] at hvu\n    refine Or.inr fun p ↦ zpow_one p ▸ ⟨k, p ^ (v.cast : ℤ), ?_⟩\n    rw [h (p ^ v.cast) k u.cast hu.symm, ← zpow_mul, zpow_eq_zpow_iff_modEq]\n    exact hvu.of_dvd (Int.natCast_dvd_natCast.mpr (orderOf_dvd_natCard p))\n\n"}
{"name":"IsPGroup.commutator_eq_bot_or_commutator_eq_self","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝² : Group G\np : Nat\ninst✝¹ : Fact (Nat.Prime p)\nP K : Subgroup G\ninst✝ : IsCyclic (Subtype fun x => Membership.mem P x)\nhP : IsPGroup p (Subtype fun x => Membership.mem P x)\nhKP : LE.le K P.normalizer\nhPK : (Nat.card (Subtype fun x => Membership.mem P x)).Coprime (Nat.card (Subtype fun x => Membership.mem K x))\n⊢ Or (Eq (Bracket.bracket K P) Bot.bot) (Eq (Bracket.bracket K P) P)","decl":"/-- If a cyclic `p`-subgroup `P` acts by conjugation on a subgroup `K` of coprime order, then\n  either `⁅K, P⁆ = ⊥` or `⁅K, P⁆ = P`. -/\ntheorem commutator_eq_bot_or_commutator_eq_self {P K : Subgroup G} [IsCyclic P]\n    (hP : IsPGroup p P) (hKP : K ≤ P.normalizer) (hPK : (Nat.card P).Coprime (Nat.card K)) :\n    ⁅K, P⁆ = ⊥ ∨ ⁅K, P⁆ = P := by\n  let _ := MulDistribMulAction.compHom P (P.normalizerMonoidHom.comp (Subgroup.inclusion hKP))\n  refine (smul_mul_inv_trivial_or_surjective hP hPK).imp (fun h ↦ ?_) fun h ↦ ?_\n  · rw [eq_bot_iff, Subgroup.commutator_le]\n    exact fun k hk g hg ↦ Subtype.ext_iff.mp (h ⟨g, hg⟩ ⟨k, hk⟩)\n  · rw [le_antisymm_iff, Subgroup.commutator_le]\n    refine ⟨fun k hk g hg ↦ P.mul_mem ((hKP hk g).mp hg) (P.inv_mem hg), fun g hg ↦ ?_⟩\n    obtain ⟨k, q, hkq⟩ := h ⟨g, hg⟩\n    rw [← Subtype.coe_mk g hg, ← hkq]\n    exact Subgroup.commutator_mem_commutator k.2 q.2\n\n"}
{"name":"Sylow.commutator_eq_bot_or_commutator_eq_self","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝⁴ : Group G\np : Nat\ninst✝³ : Fact (Nat.Prime p)\ninst✝² : Finite G\nP : Sylow p G\ninst✝¹ : IsCyclic (Subtype fun x => Membership.mem (↑P) x)\ninst✝ : (↑P).Normal\nK : Subgroup G\nh : K.IsComplement' ↑P\n⊢ Or (Eq (Bracket.bracket K ↑P) Bot.bot) (Eq (Bracket.bracket K ↑P) ↑P)","decl":"/-- If a normal cyclic Sylow `p`-subgroup `P` has a complement `K`, then either `⁅K, P⁆ = ⊥` or\n  `⁅K, P⁆ = P`. -/\ntheorem commutator_eq_bot_or_commutator_eq_self [P.Normal] {K : Subgroup G}\n    (h : K.IsComplement' P) : ⁅K, P.1⁆ = ⊥ ∨ ⁅K, P.1⁆ = P :=\n  P.2.commutator_eq_bot_or_commutator_eq_self (P.normalizer_eq_top ▸ le_top)\n    (h.index_eq_card ▸ P.card_coprime_index)\n\n"}
{"name":"Sylow.le_center_or_le_commutator","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝⁴ : Group G\np : Nat\ninst✝³ : Fact (Nat.Prime p)\ninst✝² : Finite G\nP : Sylow p G\ninst✝¹ : IsCyclic (Subtype fun x => Membership.mem (↑P) x)\ninst✝ : (↑P).Normal\n⊢ Or (LE.le (↑P) (Subgroup.center G)) (LE.le (↑P) (commutator G))","decl":"/-- A normal cyclic Sylow subgroup is either central or contained in the commutator subgroup. -/\ntheorem le_center_or_le_commutator [P.Normal] : P ≤ Subgroup.center G ∨ P ≤ commutator G := by\n  obtain ⟨K, hK⟩ := Subgroup.exists_left_complement'_of_coprime P.card_coprime_index\n  refine (commutator_eq_bot_or_commutator_eq_self P hK).imp (fun h ↦ ?_) (fun h ↦ ?_)\n  · replace h := sup_le (Subgroup.commutator_eq_bot_iff_le_centralizer.mp h) P.le_centralizer\n    rwa [hK.sup_eq_top, top_le_iff, Subgroup.centralizer_eq_top_iff_subset] at h\n  · rw [← h, commutator_def]\n    exact Subgroup.commutator_mono le_top le_top\n\n"}
{"name":"Sylow.normalizer_le_centralizer_or_le_commutator","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝³ : Group G\np : Nat\ninst✝² : Fact (Nat.Prime p)\ninst✝¹ : Finite G\nP : Sylow p G\ninst✝ : IsCyclic (Subtype fun x => Membership.mem (↑P) x)\n⊢ Or (LE.le (↑P).normalizer (Subgroup.centralizer ↑P)) (LE.le (↑P) (commutator G))","decl":"/-- A cyclic Sylow subgroup is either central in its normalizer or contained in the commutator\n  subgroup. -/\ntheorem normalizer_le_centralizer_or_le_commutator :\n    P.normalizer ≤ Subgroup.centralizer P ∨ P ≤ commutator G := by\n  let Q : Sylow p P.normalizer := P.subtype P.le_normalizer\n  have : Q.Normal := P.normal_in_normalizer\n  have : IsCyclic Q :=\n    isCyclic_of_surjective _ (Subgroup.subgroupOfEquivOfLe P.le_normalizer).symm.surjective\n  refine (le_center_or_le_commutator Q).imp (fun h ↦ ?_) (fun h ↦ ?_)\n  · rw [← SetLike.coe_subset_coe, ← Subgroup.centralizer_eq_top_iff_subset, eq_top_iff,\n      ← Subgroup.map_subtype_le_map_subtype, ← MonoidHom.range_eq_map,\n      P.normalizer.range_subtype] at h\n    replace h := h.trans (Subgroup.map_centralizer_le_centralizer_image _ _)\n    rwa [← Subgroup.coe_map, P.coe_subtype, Subgroup.map_subgroupOf_eq_of_le P.le_normalizer] at h\n  · rw [P.coe_subtype, ← Subgroup.map_subtype_le_map_subtype,\n      Subgroup.map_subgroupOf_eq_of_le P.le_normalizer, Subgroup.map_subtype_commutator] at h\n    exact h.trans (Subgroup.commutator_mono le_top le_top)\n\n"}
{"name":"Sylow.not_dvd_card_commutator_or_not_dvd_index_commutator","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝³ : Group G\np : Nat\ninst✝² : Fact (Nat.Prime p)\ninst✝¹ : Finite G\nP : Sylow p G\ninst✝ : IsCyclic (Subtype fun x => Membership.mem (↑P) x)\n⊢ Or (Not (Dvd.dvd p (Nat.card (Subtype fun x => Membership.mem (commutator G) x)))) (Not (Dvd.dvd p (commutator G).index))","decl":"include P in\n/-- If `G` has a cyclic Sylow `p`-subgroup, then the cardinality and index of the commutator\n  subgroup of `G` cannot both be divisible by `p`. -/\ntheorem not_dvd_card_commutator_or_not_dvd_index_commutator :\n    ¬ p ∣ Nat.card (commutator G) ∨ ¬ p ∣ (commutator G).index := by\n  refine (normalizer_le_centralizer_or_le_commutator P).imp ?_ ?_ <;>\n      refine fun hP h ↦ P.not_dvd_index (h.trans ?_)\n  · rw [(MonoidHom.ker_transferSylow_isComplement' P hP).index_eq_card]\n    exact Subgroup.card_dvd_of_le (Abelianization.commutator_subset_ker _)\n  · exact Subgroup.index_dvd_of_le hP\n\n"}
{"name":"IsZGroup.coprime_commutator_index","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : Finite G\ninst✝ : IsZGroup G\n⊢ (Nat.card (Subtype fun x => Membership.mem (commutator G) x)).Coprime (commutator G).index","decl":"variable (G) in\n/-- If `G` is a finite Z-group, then `commutator G` is a Hall subgroup of `G`. -/\ntheorem IsZGroup.coprime_commutator_index [Finite G] [IsZGroup G] :\n    (Nat.card (commutator G)).Coprime (commutator G).index := by\n  suffices h : ∀ p, p.Prime → (¬ p ∣ Nat.card (commutator G) ∨ ¬ p ∣ (commutator G).index) by\n    contrapose! h\n    exact Nat.Prime.not_coprime_iff_dvd.mp h\n  intro p hp\n  have := Fact.mk hp\n  exact Sylow.not_dvd_card_commutator_or_not_dvd_index_commutator default\n\n"}
{"name":"isZGroup_of_coprime","module":"Mathlib.GroupTheory.SpecificGroups.ZGroup","initialProofState":"G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst✝⁵ : Group G\ninst✝⁴ : Group G'\ninst✝³ : Group G''\nf : MonoidHom G G'\nf' : MonoidHom G' G''\ninst✝² : Finite G\ninst✝¹ : IsZGroup G\ninst✝ : IsZGroup G''\nh_le : LE.le f'.ker f.range\nh_cop : (Nat.card G).Coprime (Nat.card G'')\n⊢ IsZGroup G'","decl":"/-- An extension of coprime Z-groups is a Z-group. -/\ntheorem isZGroup_of_coprime [Finite G] [IsZGroup G] [IsZGroup G'']\n    (h_le : f'.ker ≤ f.range) (h_cop : (Nat.card G).Coprime (Nat.card G'')) :\n    IsZGroup G' := by\n  refine ⟨fun p hp P ↦ ?_⟩\n  have := Fact.mk hp\n  replace h_cop := (h_cop.of_dvd ((Subgroup.card_dvd_of_le h_le).trans\n    (Subgroup.card_range_dvd f)) (Subgroup.index_ker f' ▸ f'.range.card_subgroup_dvd_card))\n  rcases P.2.le_or_disjoint_of_coprime h_cop with h | h\n  · replace h_le : P ≤ f.range := h.trans h_le\n    suffices IsCyclic (P.subgroupOf f.range) by\n      have key := Subgroup.subgroupOfEquivOfLe h_le\n      exact isCyclic_of_surjective key key.surjective\n    obtain ⟨Q, hQ⟩ := Sylow.mapSurjective_surjective f.rangeRestrict_surjective p (P.subtype h_le)\n    rw [Sylow.ext_iff, Sylow.coe_mapSurjective, Sylow.coe_subtype] at hQ\n    exact hQ ▸ isCyclic_of_surjective _ (f.rangeRestrict.subgroupMap_surjective Q)\n  · have := (P.2.map f').isCyclic_of_isZGroup\n    apply isCyclic_of_injective (f'.subgroupMap P)\n    rwa [← MonoidHom.ker_eq_bot_iff, P.ker_subgroupMap f', Subgroup.subgroupOf_eq_bot]\n\n"}
