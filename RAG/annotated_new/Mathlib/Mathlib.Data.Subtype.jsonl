{"name":"Subtype.prop","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\nx : Subtype p\n⊢ p ↑x","decl":"/-- A version of `x.property` or `x.2` where `p` is syntactically applied to the coercion of `x`\n  instead of `x.1`. A similar result is `Subtype.mem` in `Mathlib.Data.Set.Basic`. -/\ntheorem prop (x : Subtype p) : p x :=\n  x.2\n\n"}
{"name":"Subtype.forall'","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\nq : (x : α) → p x → Prop\n⊢ Iff (∀ (x : α) (h : p x), q x h) (∀ (x : Subtype fun a => p a), q ↑x ⋯)","decl":"/-- An alternative version of `Subtype.forall`. This one is useful if Lean cannot figure out `q`\n  when using `Subtype.forall` from right to left. -/\nprotected theorem forall' {q : ∀ x, p x → Prop} : (∀ x h, q x h) ↔ ∀ x : { a // p a }, q x x.2 :=\n  (@Subtype.forall _ _ fun x ↦ q x.1 x.2).symm\n\n"}
{"name":"Subtype.exists'","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\nq : (x : α) → p x → Prop\n⊢ Iff (Exists fun x => Exists fun h => q x h) (Exists fun x => q ↑x ⋯)","decl":"/-- An alternative version of `Subtype.exists`. This one is useful if Lean cannot figure out `q`\n  when using `Subtype.exists` from right to left. -/\nprotected theorem exists' {q : ∀ x, p x → Prop} : (∃ x h, q x h) ↔ ∃ x : { a // p a }, q x x.2 :=\n  (@Subtype.exists _ _ fun x ↦ q x.1 x.2).symm\n\n"}
{"name":"Subtype.heq_iff_coe_eq","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np q : α → Prop\nh : ∀ (x : α), Iff (p x) (q x)\na1 : Subtype fun x => p x\na2 : Subtype fun x => q x\n⊢ Iff (HEq a1 a2) (Eq ↑a1 ↑a2)","decl":"theorem heq_iff_coe_eq (h : ∀ x, p x ↔ q x) {a1 : { x // p x }} {a2 : { x // q x }} :\n    HEq a1 a2 ↔ (a1 : α) = (a2 : α) :=\n  Eq.rec\n    (motive := fun (pp : (α → Prop)) _ ↦ ∀ a2' : {x // pp x}, HEq a1 a2' ↔ (a1 : α) = (a2' : α))\n    (fun _ ↦ heq_iff_eq.trans Subtype.ext_iff) (funext <| fun x ↦ propext (h x)) a2\n\n"}
{"name":"Subtype.heq_iff_coe_heq","module":"Mathlib.Data.Subtype","initialProofState":"α β : Sort u_4\np : α → Prop\nq : β → Prop\na : Subtype fun x => p x\nb : Subtype fun y => q y\nh : Eq α β\nh' : HEq p q\n⊢ Iff (HEq a b) (HEq ↑a ↑b)","decl":"lemma heq_iff_coe_heq {α β : Sort _} {p : α → Prop} {q : β → Prop} {a : {x // p x}}\n    {b : {y // q y}} (h : α = β) (h' : HEq p q) : HEq a b ↔ HEq (a : α) (b : β) := by\n  subst h\n  subst h'\n  rw [heq_iff_eq, heq_iff_eq, Subtype.ext_iff]\n\n"}
{"name":"Subtype.ext_val","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\na1 a2 : Subtype fun x => p x\na✝ : Eq ↑a1 ↑a2\n⊢ Eq a1 a2","decl":"theorem ext_val {a1 a2 : { x // p x }} : a1.1 = a2.1 → a1 = a2 :=\n  Subtype.ext\n\n"}
{"name":"Subtype.ext_iff_val","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\na1 a2 : Subtype fun x => p x\n⊢ Iff (Eq a1 a2) (Eq ↑a1 ↑a2)","decl":"theorem ext_iff_val {a1 a2 : { x // p x }} : a1 = a2 ↔ a1.1 = a2.1 :=\n  Subtype.ext_iff\n\n"}
{"name":"Subtype.coe_eta","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\na : Subtype fun a => p a\nh : p ↑a\n⊢ Eq ⟨↑a, h⟩ a","decl":"@[simp]\ntheorem coe_eta (a : { a // p a }) (h : p a) : mk (↑a) h = a :=\n  Subtype.ext rfl\n\n"}
{"name":"Subtype.coe_mk","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\na : α\nh : p a\n⊢ Eq (↑⟨a, h⟩) a","decl":"theorem coe_mk (a h) : (@mk α p a h : α) = a :=\n  rfl\n\n-- Porting note: comment out `@[simp, nolint simp_nf]`\n-- Porting note: not clear if \"built-in reduction doesn't always work\" is still relevant\n-- built-in reduction doesn't always work\n-- @[simp, nolint simp_nf]\n"}
{"name":"Subtype.mk_eq_mk","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\na : α\nh : p a\na' : α\nh' : p a'\n⊢ Iff (Eq ⟨a, h⟩ ⟨a', h'⟩) (Eq a a')","decl":"theorem mk_eq_mk {a h a' h'} : @mk α p a h = @mk α p a' h' ↔ a = a' :=\n  Subtype.ext_iff\n\n"}
{"name":"Subtype.coe_eq_of_eq_mk","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\na : Subtype fun a => p a\nb : α\nh : Eq (↑a) b\n⊢ Eq a ⟨b, ⋯⟩","decl":"theorem coe_eq_of_eq_mk {a : { a // p a }} {b : α} (h : ↑a = b) : a = ⟨b, h ▸ a.2⟩ :=\n  Subtype.ext h\n\n"}
{"name":"Subtype.coe_eq_iff","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\na : Subtype fun a => p a\nb : α\n⊢ Iff (Eq (↑a) b) (Exists fun h => Eq a ⟨b, h⟩)","decl":"theorem coe_eq_iff {a : { a // p a }} {b : α} : ↑a = b ↔ ∃ h, a = ⟨b, h⟩ :=\n  ⟨fun h ↦ h ▸ ⟨a.2, (coe_eta _ _).symm⟩, fun ⟨_, ha⟩ ↦ ha.symm ▸ rfl⟩\n\n"}
{"name":"Subtype.coe_injective","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\n⊢ Function.Injective fun a => ↑a","decl":"theorem coe_injective : Injective (fun (a : Subtype p) ↦ (a : α)) := fun _ _ ↦ Subtype.ext\n\n"}
{"name":"Subtype.val_injective","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\n⊢ Function.Injective Subtype.val","decl":"@[simp] theorem val_injective : Injective (@val _ p) :=\n  coe_injective\n\n"}
{"name":"Subtype.coe_inj","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\na b : Subtype p\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"theorem coe_inj {a b : Subtype p} : (a : α) = b ↔ a = b :=\n  coe_injective.eq_iff\n\n"}
{"name":"Subtype.val_inj","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\na b : Subtype p\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"theorem val_inj {a b : Subtype p} : a.val = b.val ↔ a = b :=\n  coe_inj\n\n"}
{"name":"Subtype.coe_ne_coe","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\na b : Subtype p\n⊢ Iff (Ne ↑a ↑b) (Ne a b)","decl":"lemma coe_ne_coe {a b : Subtype p} : (a : α) ≠ b ↔ a ≠ b := coe_injective.ne_iff\n\n"}
{"name":"exists_eq_subtype_mk_iff","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\na : Subtype p\nb : α\n⊢ Iff (Exists fun h => Eq a ⟨b, h⟩) (Eq (↑a) b)","decl":"@[simp]\ntheorem _root_.exists_eq_subtype_mk_iff {a : Subtype p} {b : α} :\n    (∃ h : p b, a = Subtype.mk b h) ↔ ↑a = b :=\n  coe_eq_iff.symm\n\n"}
{"name":"exists_subtype_mk_eq_iff","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\na : Subtype p\nb : α\n⊢ Iff (Exists fun h => Eq ⟨b, h⟩ a) (Eq b ↑a)","decl":"@[simp]\ntheorem _root_.exists_subtype_mk_eq_iff {a : Subtype p} {b : α} :\n    (∃ h : p b, Subtype.mk b h = a) ↔ b = a := by\n  simp only [@eq_comm _ b, exists_eq_subtype_mk_iff, @eq_comm _ _ a]\n\n"}
{"name":"Subtype.restrict_apply","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_5\nβ : α → Type u_4\nf : (x : α) → β x\np : α → Prop\nx : Subtype p\n⊢ Eq (Subtype.restrict p f x) (f ↑x)","decl":"theorem restrict_apply {α} {β : α → Type*} (f : ∀ x, β x) (p : α → Prop) (x : Subtype p) :\n    restrict p f x = f x.1 := by\n  rfl\n\n"}
{"name":"Subtype.restrict_def","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_4\nβ : Type u_5\nf : α → β\np : α → Prop\n⊢ Eq (Subtype.restrict p f) (Function.comp f fun a => ↑a)","decl":"theorem restrict_def {α β} (f : α → β) (p : α → Prop) :\n    restrict p f = f ∘ (fun (a : Subtype p) ↦ a) := rfl\n\n"}
{"name":"Subtype.restrict_injective","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_4\nβ : Type u_5\nf : α → β\np : α → Prop\nh : Function.Injective f\n⊢ Function.Injective (Subtype.restrict p f)","decl":"theorem restrict_injective {α β} {f : α → β} (p : α → Prop) (h : Injective f) :\n    Injective (restrict p f) :=\n  h.comp coe_injective\n\n"}
{"name":"Subtype.surjective_restrict","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_5\nβ : α → Type u_4\nne : ∀ (a : α), Nonempty (β a)\np : α → Prop\n⊢ Function.Surjective fun f => Subtype.restrict p f","decl":"theorem surjective_restrict {α} {β : α → Type*} [ne : ∀ a, Nonempty (β a)] (p : α → Prop) :\n    Surjective fun f : ∀ x, β x ↦ restrict p f := by\n  letI := Classical.decPred p\n  refine fun f ↦ ⟨fun x ↦ if h : p x then f ⟨x, h⟩ else Nonempty.some (ne x), funext <| ?_⟩\n  rintro ⟨x, hx⟩\n  exact dif_pos hx\n\n"}
{"name":"Subtype.coind_coe","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_4\nβ : Sort u_5\nf : α → β\np : β → Prop\nh : ∀ (a : α), p (f a)\na✝ : α\n⊢ Eq (↑(Subtype.coind f h a✝)) (f a✝)","decl":"/-- Defining a map into a subtype, this can be seen as a \"coinduction principle\" of `Subtype`-/\n@[simps]\ndef coind {α β} (f : α → β) {p : β → Prop} (h : ∀ a, p (f a)) : α → Subtype p := fun a ↦ ⟨f a, h a⟩\n\n"}
{"name":"Subtype.coind_injective","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_4\nβ : Sort u_5\nf : α → β\np : β → Prop\nh : ∀ (a : α), p (f a)\nhf : Function.Injective f\n⊢ Function.Injective (Subtype.coind f h)","decl":"theorem coind_injective {α β} {f : α → β} {p : β → Prop} (h : ∀ a, p (f a)) (hf : Injective f) :\n    Injective (coind f h) := fun x y hxy ↦ hf <| by apply congr_arg Subtype.val hxy\n\n"}
{"name":"Subtype.coind_surjective","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_4\nβ : Sort u_5\nf : α → β\np : β → Prop\nh : ∀ (a : α), p (f a)\nhf : Function.Surjective f\n⊢ Function.Surjective (Subtype.coind f h)","decl":"theorem coind_surjective {α β} {f : α → β} {p : β → Prop} (h : ∀ a, p (f a)) (hf : Surjective f) :\n    Surjective (coind f h) := fun x ↦\n  let ⟨a, ha⟩ := hf x\n  ⟨a, coe_injective ha⟩\n\n"}
{"name":"Subtype.coind_bijective","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_4\nβ : Sort u_5\nf : α → β\np : β → Prop\nh : ∀ (a : α), p (f a)\nhf : Function.Bijective f\n⊢ Function.Bijective (Subtype.coind f h)","decl":"theorem coind_bijective {α β} {f : α → β} {p : β → Prop} (h : ∀ a, p (f a)) (hf : Bijective f) :\n    Bijective (coind f h) :=\n  ⟨coind_injective h hf.1, coind_surjective h hf.2⟩\n\n"}
{"name":"Subtype.map_coe","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\nβ : Sort u_2\np : α → Prop\nq : β → Prop\nf : α → β\nh : ∀ (a : α), p a → q (f a)\na✝ : Subtype p\n⊢ Eq (↑(Subtype.map f h a✝)) (f ↑a✝)","decl":"/-- Restriction of a function to a function on subtypes. -/\n@[simps]\ndef map {p : α → Prop} {q : β → Prop} (f : α → β) (h : ∀ a, p a → q (f a)) :\n    Subtype p → Subtype q :=\n  fun x ↦ ⟨f x, h x x.prop⟩\n\n"}
{"name":"Subtype.map_def","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\nβ : Sort u_2\np : α → Prop\nq : β → Prop\nf : α → β\nh : ∀ (a : α), p a → q (f a)\n⊢ Eq (Subtype.map f h) fun x => ⟨f ↑x, ⋯⟩","decl":"theorem map_def {p : α → Prop} {q : β → Prop} (f : α → β) (h : ∀ a, p a → q (f a)) :\n    map f h = fun x ↦ ⟨f x, h x x.prop⟩ :=\n  rfl\n\n"}
{"name":"Subtype.map_comp","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\np : α → Prop\nq : β → Prop\nr : γ → Prop\nx : Subtype p\nf : α → β\nh : ∀ (a : α), p a → q (f a)\ng : β → γ\nl : ∀ (a : β), q a → r (g a)\n⊢ Eq (Subtype.map g l (Subtype.map f h x)) (Subtype.map (Function.comp g f) ⋯ x)","decl":"theorem map_comp {p : α → Prop} {q : β → Prop} {r : γ → Prop} {x : Subtype p}\n    (f : α → β) (h : ∀ a, p a → q (f a)) (g : β → γ) (l : ∀ a, q a → r (g a)) :\n    map g l (map f h x) = map (g ∘ f) (fun a ha ↦ l (f a) <| h a ha) x :=\n  rfl\n\n"}
{"name":"Subtype.map_id","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\nh : ∀ (a : α), p a → p (id a)\n⊢ Eq (Subtype.map id h) id","decl":"theorem map_id {p : α → Prop} {h : ∀ a, p a → p (id a)} : map (@id α) h = id :=\n  funext fun _ ↦ rfl\n\n"}
{"name":"Subtype.map_injective","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\nβ : Sort u_2\np : α → Prop\nq : β → Prop\nf : α → β\nh : ∀ (a : α), p a → q (f a)\nhf : Function.Injective f\n⊢ Function.Injective (Subtype.map f h)","decl":"theorem map_injective {p : α → Prop} {q : β → Prop} {f : α → β} (h : ∀ a, p a → q (f a))\n    (hf : Injective f) : Injective (map f h) :=\n  coind_injective _ <| hf.comp coe_injective\n\n"}
{"name":"Subtype.map_involutive","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\nf : α → α\nh : ∀ (a : α), p a → p (f a)\nhf : Function.Involutive f\n⊢ Function.Involutive (Subtype.map f h)","decl":"theorem map_involutive {p : α → Prop} {f : α → α} (h : ∀ a, p a → p (f a))\n    (hf : Involutive f) : Involutive (map f h) :=\n  fun x ↦ Subtype.ext (hf x)\n\n"}
{"name":"Subtype.equiv_iff","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\ninst✝ : HasEquiv α\np : α → Prop\ns t : Subtype p\n⊢ Iff (HasEquiv.Equiv s t) (HasEquiv.Equiv ↑s ↑t)","decl":"theorem equiv_iff [HasEquiv α] {p : α → Prop} {s t : Subtype p} : s ≈ t ↔ (s : α) ≈ (t : α) :=\n  Iff.rfl\n\n"}
{"name":"Subtype.refl","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\ninst✝ : Setoid α\ns : Subtype p\n⊢ HasEquiv.Equiv s s","decl":"protected theorem refl (s : Subtype p) : s ≈ s :=\n  Setoid.refl _\n\n"}
{"name":"Subtype.symm","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\ninst✝ : Setoid α\ns t : Subtype p\nh : HasEquiv.Equiv s t\n⊢ HasEquiv.Equiv t s","decl":"protected theorem symm {s t : Subtype p} (h : s ≈ t) : t ≈ s :=\n  Setoid.symm h\n\n"}
{"name":"Subtype.trans","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\np : α → Prop\ninst✝ : Setoid α\ns t u : Subtype p\nh₁ : HasEquiv.Equiv s t\nh₂ : HasEquiv.Equiv t u\n⊢ HasEquiv.Equiv s u","decl":"protected theorem trans {s t u : Subtype p} (h₁ : s ≈ t) (h₂ : t ≈ u) : s ≈ u :=\n  Setoid.trans h₁ h₂\n\n"}
{"name":"Subtype.equivalence","module":"Mathlib.Data.Subtype","initialProofState":"α : Sort u_1\ninst✝ : Setoid α\np : α → Prop\n⊢ Equivalence HasEquiv.Equiv","decl":"theorem equivalence (p : α → Prop) : Equivalence (@HasEquiv.Equiv (Subtype p) _) :=\n  .mk (Subtype.refl) (@Subtype.symm _ p _) (@Subtype.trans _ p _)\n\n"}
{"name":"Subtype.coe_prop","module":"Mathlib.Data.Subtype","initialProofState":"α : Type u_1\nS : Set α\na : Subtype fun a => Membership.mem S a\n⊢ Membership.mem S ↑a","decl":"@[simp]\ntheorem coe_prop {S : Set α} (a : { a // a ∈ S }) : ↑a ∈ S :=\n  a.prop\n\n"}
{"name":"Subtype.val_prop","module":"Mathlib.Data.Subtype","initialProofState":"α : Type u_1\nS : Set α\na : Subtype fun a => Membership.mem S a\n⊢ Membership.mem S ↑a","decl":"theorem val_prop {S : Set α} (a : { a // a ∈ S }) : a.val ∈ S :=\n  a.property\n\n"}
