{"name":"AddUnits.coe_unop_opEquiv","module":"Mathlib.Algebra.Group.Units.Opposite","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\nu : AddUnits (AddOpposite M)\n⊢ Eq (↑(AddOpposite.unop (AddUnits.opEquiv u))) (AddOpposite.unop ↑u)","decl":"@[to_additive (attr := simp)]\ntheorem Units.coe_unop_opEquiv {M} [Monoid M] (u : Mᵐᵒᵖˣ) :\n    ((Units.opEquiv u).unop : M) = unop (u : Mᵐᵒᵖ) :=\n  rfl\n\n"}
{"name":"Units.coe_unop_opEquiv","module":"Mathlib.Algebra.Group.Units.Opposite","initialProofState":"M : Type u_2\ninst✝ : Monoid M\nu : Units (MulOpposite M)\n⊢ Eq (↑(MulOpposite.unop (Units.opEquiv u))) (MulOpposite.unop ↑u)","decl":"@[to_additive (attr := simp)]\ntheorem Units.coe_unop_opEquiv {M} [Monoid M] (u : Mᵐᵒᵖˣ) :\n    ((Units.opEquiv u).unop : M) = unop (u : Mᵐᵒᵖ) :=\n  rfl\n\n"}
{"name":"AddUnits.coe_opEquiv_symm","module":"Mathlib.Algebra.Group.Units.Opposite","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\nu : AddOpposite (AddUnits M)\n⊢ Eq (↑(AddUnits.opEquiv.symm u)) (AddOpposite.op ↑(AddOpposite.unop u))","decl":"@[to_additive (attr := simp)]\ntheorem Units.coe_opEquiv_symm {M} [Monoid M] (u : Mˣᵐᵒᵖ) :\n    (Units.opEquiv.symm u : Mᵐᵒᵖ) = op (u.unop : M) :=\n  rfl\n\n"}
{"name":"Units.coe_opEquiv_symm","module":"Mathlib.Algebra.Group.Units.Opposite","initialProofState":"M : Type u_2\ninst✝ : Monoid M\nu : MulOpposite (Units M)\n⊢ Eq (↑(Units.opEquiv.symm u)) (MulOpposite.op ↑(MulOpposite.unop u))","decl":"@[to_additive (attr := simp)]\ntheorem Units.coe_opEquiv_symm {M} [Monoid M] (u : Mˣᵐᵒᵖ) :\n    (Units.opEquiv.symm u : Mᵐᵒᵖ) = op (u.unop : M) :=\n  rfl\n\n"}
{"name":"IsUnit.op","module":"Mathlib.Algebra.Group.Units.Opposite","initialProofState":"M : Type u_2\ninst✝ : Monoid M\nm : M\nh : IsUnit m\n⊢ IsUnit (MulOpposite.op m)","decl":"@[to_additive]\nnonrec theorem IsUnit.op {M} [Monoid M] {m : M} (h : IsUnit m) : IsUnit (op m) :=\n  let ⟨u, hu⟩ := h\n  hu ▸ ⟨Units.opEquiv.symm (op u), rfl⟩\n\n"}
{"name":"IsAddUnit.op","module":"Mathlib.Algebra.Group.Units.Opposite","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\nm : M\nh : IsAddUnit m\n⊢ IsAddUnit (AddOpposite.op m)","decl":"@[to_additive]\nnonrec theorem IsUnit.op {M} [Monoid M] {m : M} (h : IsUnit m) : IsUnit (op m) :=\n  let ⟨u, hu⟩ := h\n  hu ▸ ⟨Units.opEquiv.symm (op u), rfl⟩\n\n"}
{"name":"IsAddUnit.unop","module":"Mathlib.Algebra.Group.Units.Opposite","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\nm : AddOpposite M\nh : IsAddUnit m\n⊢ IsAddUnit (AddOpposite.unop m)","decl":"@[to_additive]\nnonrec theorem IsUnit.unop {M} [Monoid M] {m : Mᵐᵒᵖ} (h : IsUnit m) : IsUnit (unop m) :=\n  let ⟨u, hu⟩ := h\n  hu ▸ ⟨unop (Units.opEquiv u), rfl⟩\n\n"}
{"name":"IsUnit.unop","module":"Mathlib.Algebra.Group.Units.Opposite","initialProofState":"M : Type u_2\ninst✝ : Monoid M\nm : MulOpposite M\nh : IsUnit m\n⊢ IsUnit (MulOpposite.unop m)","decl":"@[to_additive]\nnonrec theorem IsUnit.unop {M} [Monoid M] {m : Mᵐᵒᵖ} (h : IsUnit m) : IsUnit (unop m) :=\n  let ⟨u, hu⟩ := h\n  hu ▸ ⟨unop (Units.opEquiv u), rfl⟩\n\n"}
{"name":"isUnit_op","module":"Mathlib.Algebra.Group.Units.Opposite","initialProofState":"M : Type u_2\ninst✝ : Monoid M\nm : M\n⊢ Iff (IsUnit (MulOpposite.op m)) (IsUnit m)","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_op {M} [Monoid M] {m : M} : IsUnit (op m) ↔ IsUnit m :=\n  ⟨IsUnit.unop, IsUnit.op⟩\n\n"}
{"name":"isAddUnit_op","module":"Mathlib.Algebra.Group.Units.Opposite","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\nm : M\n⊢ Iff (IsAddUnit (AddOpposite.op m)) (IsAddUnit m)","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_op {M} [Monoid M] {m : M} : IsUnit (op m) ↔ IsUnit m :=\n  ⟨IsUnit.unop, IsUnit.op⟩\n\n"}
{"name":"isAddUnit_unop","module":"Mathlib.Algebra.Group.Units.Opposite","initialProofState":"M : Type u_2\ninst✝ : AddMonoid M\nm : AddOpposite M\n⊢ Iff (IsAddUnit (AddOpposite.unop m)) (IsAddUnit m)","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_unop {M} [Monoid M] {m : Mᵐᵒᵖ} : IsUnit (unop m) ↔ IsUnit m :=\n  ⟨IsUnit.op, IsUnit.unop⟩\n"}
{"name":"isUnit_unop","module":"Mathlib.Algebra.Group.Units.Opposite","initialProofState":"M : Type u_2\ninst✝ : Monoid M\nm : MulOpposite M\n⊢ Iff (IsUnit (MulOpposite.unop m)) (IsUnit m)","decl":"@[to_additive (attr := simp)]\ntheorem isUnit_unop {M} [Monoid M] {m : Mᵐᵒᵖ} : IsUnit (unop m) ↔ IsUnit m :=\n  ⟨IsUnit.op, IsUnit.unop⟩\n"}
