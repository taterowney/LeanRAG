{"name":"RelSeries.mk.inj","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nlength✝ : Nat\ntoFun✝ : Fin (HAdd.hAdd length✝ 1) → α\nstep✝ : ∀ (i : Fin length✝), r (toFun✝ i.castSucc) (toFun✝ i.succ)\nlength : Nat\ntoFun : Fin (HAdd.hAdd length 1) → α\nstep : ∀ (i : Fin length), r (toFun i.castSucc) (toFun i.succ)\nx✝ : Eq { length := length✝, toFun := toFun✝, step := step✝ } { length := length, toFun := toFun, step := step }\n⊢ And (Eq length✝ length) (HEq toFun✝ toFun)","decl":"/--\nLet `r` be a relation on `α`, a relation series of `r` of length `n` is a series\n`a_0, a_1, ..., a_n` such that `r a_i a_{i+1}` for all `i < n`\n-/\nstructure RelSeries where\n  /-- The number of inequalities in the series -/\n  length : ℕ\n  /-- The underlying function of a relation series -/\n  toFun : Fin (length + 1) → α\n  /-- Adjacent elements are related -/\n  step : ∀ (i : Fin length), r (toFun (Fin.castSucc i)) (toFun i.succ)\n\n"}
{"name":"RelSeries.step","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nself : RelSeries r\ni : Fin self.length\n⊢ r (self.toFun i.castSucc) (self.toFun i.succ)","decl":"/--\nLet `r` be a relation on `α`, a relation series of `r` of length `n` is a series\n`a_0, a_1, ..., a_n` such that `r a_i a_{i+1}` for all `i < n`\n-/\nstructure RelSeries where\n  /-- The number of inequalities in the series -/\n  length : ℕ\n  /-- The underlying function of a relation series -/\n  toFun : Fin (length + 1) → α\n  /-- Adjacent elements are related -/\n  step : ∀ (i : Fin length), r (toFun (Fin.castSucc i)) (toFun i.succ)\n\n"}
{"name":"RelSeries.mk.injEq","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nlength✝ : Nat\ntoFun✝ : Fin (HAdd.hAdd length✝ 1) → α\nstep✝ : ∀ (i : Fin length✝), r (toFun✝ i.castSucc) (toFun✝ i.succ)\nlength : Nat\ntoFun : Fin (HAdd.hAdd length 1) → α\nstep : ∀ (i : Fin length), r (toFun i.castSucc) (toFun i.succ)\n⊢ Eq (Eq { length := length✝, toFun := toFun✝, step := step✝ } { length := length, toFun := toFun, step := step }) (And (Eq length✝ length) (HEq toFun✝ toFun))","decl":"/--\nLet `r` be a relation on `α`, a relation series of `r` of length `n` is a series\n`a_0, a_1, ..., a_n` such that `r a_i a_{i+1}` for all `i < n`\n-/\nstructure RelSeries where\n  /-- The number of inequalities in the series -/\n  length : ℕ\n  /-- The underlying function of a relation series -/\n  toFun : Fin (length + 1) → α\n  /-- Adjacent elements are related -/\n  step : ∀ (i : Fin length), r (toFun (Fin.castSucc i)) (toFun i.succ)\n\n"}
{"name":"RelSeries.mk.sizeOf_spec","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ninst✝¹ : SizeOf α\ninst✝ : (a a_1 : α) → SizeOf (r a a_1)\nlength : Nat\ntoFun : Fin (HAdd.hAdd length 1) → α\nstep : ∀ (i : Fin length), r (toFun i.castSucc) (toFun i.succ)\n⊢ Eq (SizeOf.sizeOf { length := length, toFun := toFun, step := step }) (HAdd.hAdd 1 (SizeOf.sizeOf length))","decl":"/--\nLet `r` be a relation on `α`, a relation series of `r` of length `n` is a series\n`a_0, a_1, ..., a_n` such that `r a_i a_{i+1}` for all `i < n`\n-/\nstructure RelSeries where\n  /-- The number of inequalities in the series -/\n  length : ℕ\n  /-- The underlying function of a relation series -/\n  toFun : Fin (length + 1) → α\n  /-- Adjacent elements are related -/\n  step : ∀ (i : Fin length), r (toFun (Fin.castSucc i)) (toFun i.succ)\n\n"}
{"name":"RelSeries.singleton_toFun","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\na : α\nx✝ : Fin (HAdd.hAdd 0 1)\n⊢ Eq ((RelSeries.singleton r a).toFun x✝) a","decl":"/--\nFor any type `α`, each term of `α` gives a relation series with the right most index to be 0.\n-/\n@[simps!] def singleton (a : α) : RelSeries r where\n  length := 0\n  toFun _ := a\n  step := Fin.elim0\n\n"}
{"name":"RelSeries.singleton_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\na : α\n⊢ Eq (RelSeries.singleton r a).length 0","decl":"/--\nFor any type `α`, each term of `α` gives a relation series with the right most index to be 0.\n-/\n@[simps!] def singleton (a : α) : RelSeries r where\n  length := 0\n  toFun _ := a\n  step := Fin.elim0\n\n"}
{"name":"RelSeries.instIsEmpty","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ninst✝ : IsEmpty α\n⊢ IsEmpty (RelSeries r)","decl":"instance [IsEmpty α] : IsEmpty (RelSeries r) where\n  false x := IsEmpty.false (x 0)\n\n"}
{"name":"RelSeries.instNonempty","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ninst✝ : Nonempty α\n⊢ Nonempty (RelSeries r)","decl":"instance [Nonempty α] : Nonempty (RelSeries r) :=\n  Nonempty.map (singleton r) inferInstance\n\n"}
{"name":"RelSeries.ext","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx y : RelSeries r\nlength_eq : Eq x.length y.length\ntoFun_eq : Eq x.toFun (Function.comp y.toFun (Fin.cast ⋯))\n⊢ Eq x y","decl":"@[ext (iff := false)]\nlemma ext {x y : RelSeries r} (length_eq : x.length = y.length)\n    (toFun_eq : x.toFun = y.toFun ∘ Fin.cast (by rw [length_eq])) : x = y := by\n  rcases x with ⟨nx, fx⟩\n  dsimp only at length_eq toFun_eq\n  subst length_eq toFun_eq\n  rfl\n\n"}
{"name":"RelSeries.rel_of_lt","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ninst✝ : IsTrans α r\nx : RelSeries r\ni j : Fin (HAdd.hAdd x.length 1)\nh : LT.lt i j\n⊢ r (x.toFun i) (x.toFun j)","decl":"lemma rel_of_lt [IsTrans α r] (x : RelSeries r) {i j : Fin (x.length + 1)} (h : i < j) :\n    r (x i) (x j) :=\n  (Fin.liftFun_iff_succ r).mpr x.step h\n\n"}
{"name":"RelSeries.rel_or_eq_of_le","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ninst✝ : IsTrans α r\nx : RelSeries r\ni j : Fin (HAdd.hAdd x.length 1)\nh : LE.le i j\n⊢ Or (r (x.toFun i) (x.toFun j)) (Eq (x.toFun i) (x.toFun j))","decl":"lemma rel_or_eq_of_le [IsTrans α r] (x : RelSeries r) {i j : Fin (x.length + 1)} (h : i ≤ j) :\n    r (x i) (x j) ∨ x i = x j :=\n  (Fin.lt_or_eq_of_le h).imp (x.rel_of_lt ·) (by rw [·])\n\n"}
{"name":"RelSeries.ofLE_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx : RelSeries r\ns : Rel α α\nh : LE.le r s\n⊢ Eq (x.ofLE h).length x.length","decl":"/--\nGiven two relations `r, s` on `α` such that `r ≤ s`, any relation series of `r` induces a relation\nseries of `s`\n-/\n@[simps!]\ndef ofLE (x : RelSeries r) {s : Rel α α} (h : r ≤ s) : RelSeries s where\n  length := x.length\n  toFun := x\n  step _ := h _ _ <| x.step _\n\n"}
{"name":"RelSeries.ofLE_toFun","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx : RelSeries r\ns : Rel α α\nh : LE.le r s\na✝ : Fin (HAdd.hAdd x.length 1)\n⊢ Eq ((x.ofLE h).toFun a✝) (x.toFun a✝)","decl":"/--\nGiven two relations `r, s` on `α` such that `r ≤ s`, any relation series of `r` induces a relation\nseries of `s`\n-/\n@[simps!]\ndef ofLE (x : RelSeries r) {s : Rel α α} (h : r ≤ s) : RelSeries s where\n  length := x.length\n  toFun := x\n  step _ := h _ _ <| x.step _\n\n"}
{"name":"RelSeries.coe_ofLE","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx : RelSeries r\ns : Rel α α\nh : LE.le r s\n⊢ Eq (x.ofLE h).toFun x.toFun","decl":"lemma coe_ofLE (x : RelSeries r) {s : Rel α α} (h : r ≤ s) :\n    (x.ofLE h : _ → _) = x := rfl\n\n"}
{"name":"RelSeries.length_toList","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx : RelSeries r\n⊢ Eq x.toList.length (HAdd.hAdd x.length 1)","decl":"@[simp]\nlemma length_toList (x : RelSeries r) : x.toList.length = x.length + 1 :=\n  List.length_ofFn _\n\n"}
{"name":"RelSeries.toList_chain'","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx : RelSeries r\n⊢ List.Chain' r x.toList","decl":"lemma toList_chain' (x : RelSeries r) : x.toList.Chain' r := by\n  rw [List.chain'_iff_get]\n  intros i h\n  convert x.step ⟨i, by simpa [toList] using h⟩ <;> apply List.get_ofFn\n\n"}
{"name":"RelSeries.toList_ne_nil","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx : RelSeries r\n⊢ Ne x.toList List.nil","decl":"lemma toList_ne_nil (x : RelSeries r) : x.toList ≠ [] := fun m =>\n  List.eq_nil_iff_forall_not_mem.mp m (x 0) <| (List.mem_ofFn _ _).mpr ⟨_, rfl⟩\n\n"}
{"name":"RelSeries.fromListChain'_toFun","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx : List α\nx_ne_nil : Ne x List.nil\nhx : List.Chain' r x\ni : Fin (HAdd.hAdd (HSub.hSub x.length 1) 1)\n⊢ Eq ((RelSeries.fromListChain' x x_ne_nil hx).toFun i) (GetElem.getElem x (Fin.cast ⋯ i) ⋯)","decl":"/-- Every nonempty list satisfying the chain condition gives a relation series -/\n@[simps]\ndef fromListChain' (x : List α) (x_ne_nil : x ≠ []) (hx : x.Chain' r) : RelSeries r where\n  length := x.length - 1\n  toFun i := x[Fin.cast (Nat.succ_pred_eq_of_pos <| List.length_pos.mpr x_ne_nil) i]\n  step i := List.chain'_iff_get.mp hx i i.2\n\n"}
{"name":"RelSeries.fromListChain'_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx : List α\nx_ne_nil : Ne x List.nil\nhx : List.Chain' r x\n⊢ Eq (RelSeries.fromListChain' x x_ne_nil hx).length (HSub.hSub x.length 1)","decl":"/-- Every nonempty list satisfying the chain condition gives a relation series -/\n@[simps]\ndef fromListChain' (x : List α) (x_ne_nil : x ≠ []) (hx : x.Chain' r) : RelSeries r where\n  length := x.length - 1\n  toFun i := x[Fin.cast (Nat.succ_pred_eq_of_pos <| List.length_pos.mpr x_ne_nil) i]\n  step i := List.chain'_iff_get.mp hx i i.2\n\n"}
{"name":"RelSeries.toList_injective","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\n⊢ Function.Injective RelSeries.toList","decl":"lemma toList_injective : Function.Injective (RelSeries.toList (r := r)) :=\n  fun _ _ h ↦ (RelSeries.Equiv).injective <| Subtype.ext h\n\n-- TODO : build a similar bijection between `RelSeries α` and `Quiver.Path`\n\n"}
{"name":"Rel.FiniteDimensional.exists_longest_relSeries","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nself : r.FiniteDimensional\n⊢ Exists fun x => ∀ (y : RelSeries r), LE.le y.length x.length","decl":"/-- A relation `r` is said to be finite dimensional iff there is a relation series of `r` with the\n  maximum length. -/\n@[mk_iff]\nclass FiniteDimensional : Prop where\n  /-- A relation `r` is said to be finite dimensional iff there is a relation series of `r` with the\n    maximum length. -/\n  exists_longest_relSeries : ∃ x : RelSeries r, ∀ y : RelSeries r, y.length ≤ x.length\n\n"}
{"name":"Rel.finiteDimensional_iff","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\n⊢ Iff r.FiniteDimensional (Exists fun x => ∀ (y : RelSeries r), LE.le y.length x.length)","decl":"/-- A relation `r` is said to be finite dimensional iff there is a relation series of `r` with the\n  maximum length. -/\n@[mk_iff]\nclass FiniteDimensional : Prop where\n  /-- A relation `r` is said to be finite dimensional iff there is a relation series of `r` with the\n    maximum length. -/\n  exists_longest_relSeries : ∃ x : RelSeries r, ∀ y : RelSeries r, y.length ≤ x.length\n\n"}
{"name":"Rel.InfiniteDimensional.exists_relSeries_with_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nself : r.InfiniteDimensional\nn : Nat\n⊢ Exists fun x => Eq x.length n","decl":"/-- A relation `r` is said to be infinite dimensional iff there exists relation series of arbitrary\n  length. -/\n@[mk_iff]\nclass InfiniteDimensional : Prop where\n  /-- A relation `r` is said to be infinite dimensional iff there exists relation series of\n    arbitrary length. -/\n  exists_relSeries_with_length : ∀ n : ℕ, ∃ x : RelSeries r, x.length = n\n\n"}
{"name":"Rel.infiniteDimensional_iff","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\n⊢ Iff r.InfiniteDimensional (∀ (n : Nat), Exists fun x => Eq x.length n)","decl":"/-- A relation `r` is said to be infinite dimensional iff there exists relation series of arbitrary\n  length. -/\n@[mk_iff]\nclass InfiniteDimensional : Prop where\n  /-- A relation `r` is said to be infinite dimensional iff there exists relation series of\n    arbitrary length. -/\n  exists_relSeries_with_length : ∀ n : ℕ, ∃ x : RelSeries r, x.length = n\n\n"}
{"name":"RelSeries.length_le_length_longestOf","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ninst✝ : r.FiniteDimensional\nx : RelSeries r\n⊢ LE.le x.length (RelSeries.longestOf r).length","decl":"lemma length_le_length_longestOf [r.FiniteDimensional] (x : RelSeries r) :\n    x.length ≤ (RelSeries.longestOf r).length :=\n  Rel.FiniteDimensional.exists_longest_relSeries.choose_spec _\n\n"}
{"name":"RelSeries.length_withLength","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ninst✝ : r.InfiniteDimensional\nn : Nat\n⊢ Eq (RelSeries.withLength r n).length n","decl":"@[simp] lemma length_withLength [r.InfiniteDimensional] (n : ℕ) :\n    (RelSeries.withLength r n).length = n :=\n  (Rel.InfiniteDimensional.exists_relSeries_with_length n).choose_spec\n\n"}
{"name":"RelSeries.nonempty_of_infiniteDimensional","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ninst✝ : r.InfiniteDimensional\n⊢ Nonempty α","decl":"/-- If a relation on `α` is infinite dimensional, then `α` is nonempty. -/\nlemma nonempty_of_infiniteDimensional [r.InfiniteDimensional] : Nonempty α :=\n  ⟨RelSeries.withLength r 0 0⟩\n\n"}
{"name":"RelSeries.mem_def","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ns : RelSeries r\nx : α\n⊢ Iff (Membership.mem s x) (Membership.mem (Set.range s.toFun) x)","decl":"theorem mem_def : x ∈ s ↔ x ∈ Set.range s := Iff.rfl\n\n"}
{"name":"RelSeries.mem_toList","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ns : RelSeries r\nx : α\n⊢ Iff (Membership.mem s.toList x) (Membership.mem s x)","decl":"@[simp] theorem mem_toList : x ∈ s.toList ↔ x ∈ s := by\n  rw [RelSeries.toList, List.mem_ofFn, RelSeries.mem_def]\n\n"}
{"name":"RelSeries.subsingleton_of_length_eq_zero","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ns : RelSeries r\nhs : Eq s.length 0\n⊢ (setOf fun x => Membership.mem s x).Subsingleton","decl":"theorem subsingleton_of_length_eq_zero (hs : s.length = 0) : {x | x ∈ s}.Subsingleton := by\n  rintro - ⟨i, rfl⟩ - ⟨j, rfl⟩\n  congr!\n  exact finCongr (by rw [hs, zero_add]) |>.injective <| Subsingleton.elim (α := Fin 1) _ _\n\n"}
{"name":"RelSeries.length_ne_zero_of_nontrivial","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ns : RelSeries r\nh : (setOf fun x => Membership.mem s x).Nontrivial\n⊢ Ne s.length 0","decl":"theorem length_ne_zero_of_nontrivial (h : {x | x ∈ s}.Nontrivial) : s.length ≠ 0 :=\n  fun hs ↦ h.not_subsingleton <| subsingleton_of_length_eq_zero hs\n\n"}
{"name":"RelSeries.length_pos_of_nontrivial","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ns : RelSeries r\nh : (setOf fun x => Membership.mem s x).Nontrivial\n⊢ LT.lt 0 s.length","decl":"theorem length_pos_of_nontrivial (h : {x | x ∈ s}.Nontrivial) : 0 < s.length :=\n  Nat.pos_iff_ne_zero.mpr <| length_ne_zero_of_nontrivial h\n\n"}
{"name":"RelSeries.length_ne_zero","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ns : RelSeries r\nirrefl : Irreflexive r\n⊢ Iff (Ne s.length 0) (setOf fun x => Membership.mem s x).Nontrivial","decl":"theorem length_ne_zero (irrefl : Irreflexive r) : s.length ≠ 0 ↔ {x | x ∈ s}.Nontrivial := by\n  refine ⟨fun h ↦ ⟨s 0, by simp [mem_def], s 1, by simp [mem_def], fun rid ↦ irrefl (s 0) ?_⟩,\n    length_ne_zero_of_nontrivial⟩\n  nth_rw 2 [rid]\n  convert s.step ⟨0, by omega⟩\n  ext\n  simpa [Nat.pos_iff_ne_zero]\n\n"}
{"name":"RelSeries.length_pos","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ns : RelSeries r\nirrefl : Irreflexive r\n⊢ Iff (LT.lt 0 s.length) (setOf fun x => Membership.mem s x).Nontrivial","decl":"theorem length_pos (irrefl : Irreflexive r) : 0 < s.length ↔ {x | x ∈ s}.Nontrivial :=\n  Nat.pos_iff_ne_zero.trans <| length_ne_zero irrefl\n\n"}
{"name":"RelSeries.length_eq_zero","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ns : RelSeries r\nirrefl : Irreflexive r\n⊢ Iff (Eq s.length 0) (setOf fun x => Membership.mem s x).Subsingleton","decl":"lemma length_eq_zero (irrefl : Irreflexive r) : s.length = 0 ↔ {x | x ∈ s}.Subsingleton := by\n  rw [← not_ne_iff, length_ne_zero irrefl, Set.not_nontrivial_iff]\n\n"}
{"name":"RelSeries.apply_last","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx : RelSeries r\n⊢ Eq (x.toFun (Fin.last x.length)) x.last","decl":"lemma apply_last (x : RelSeries r) : x (Fin.last <| x.length) = x.last := rfl\n\n"}
{"name":"RelSeries.head_mem","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx : RelSeries r\n⊢ Membership.mem x x.head","decl":"lemma head_mem (x : RelSeries r) : x.head ∈ x := ⟨_, rfl⟩\n\n"}
{"name":"RelSeries.last_mem","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx : RelSeries r\n⊢ Membership.mem x x.last","decl":"lemma last_mem (x : RelSeries r) : x.last ∈ x := ⟨_, rfl⟩\n\n"}
{"name":"RelSeries.head_singleton","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx : α\n⊢ Eq (RelSeries.singleton r x).head x","decl":"@[simp]\nlemma head_singleton {r : Rel α α} (x : α) : (singleton r x).head = x := by simp [singleton, head]\n\n"}
{"name":"RelSeries.last_singleton","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nx : α\n⊢ Eq (RelSeries.singleton r x).last x","decl":"@[simp]\nlemma last_singleton {r : Rel α α} (x : α) : (singleton r x).last = x := by simp [singleton, last]\n\n"}
{"name":"RelSeries.append_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np q : RelSeries r\nconnect : r p.last q.head\n⊢ Eq (p.append q connect).length (HAdd.hAdd (HAdd.hAdd p.length q.length) 1)","decl":"/--\nIf `a₀ -r→ a₁ -r→ ... -r→ aₙ` and `b₀ -r→ b₁ -r→ ... -r→ bₘ` are two strict series\nsuch that `r aₙ b₀`, then there is a chain of length `n + m + 1` given by\n`a₀ -r→ a₁ -r→ ... -r→ aₙ -r→ b₀ -r→ b₁ -r→ ... -r→ bₘ`.\n-/\n@[simps length]\ndef append (p q : RelSeries r) (connect : r p.last q.head) : RelSeries r where\n  length := p.length + q.length + 1\n  toFun := Fin.append p q ∘ Fin.cast (by omega)\n  step i := by\n    obtain hi | rfl | hi :=\n      lt_trichotomy i (Fin.castLE (by omega) (Fin.last _ : Fin (p.length + 1)))\n    · convert p.step ⟨i.1, hi⟩ <;> convert Fin.append_left p q _ <;> rfl\n    · convert connect\n      · convert Fin.append_left p q _\n      · convert Fin.append_right p q _; rfl\n    · set x := _; set y := _\n      change r (Fin.append p q x) (Fin.append p q y)\n      have hx : x = Fin.natAdd _ ⟨i - (p.length + 1), Nat.sub_lt_left_of_lt_add hi <|\n          i.2.trans <| by omega⟩ := by\n        ext; dsimp [x, y]; rw [Nat.add_sub_cancel']; exact hi\n      have hy : y = Fin.natAdd _ ⟨i - p.length, Nat.sub_lt_left_of_lt_add (le_of_lt hi)\n          (by exact i.2)⟩ := by\n        ext\n        dsimp\n        conv_rhs => rw [Nat.add_comm p.length 1, add_assoc,\n          Nat.add_sub_cancel' <| le_of_lt (show p.length < i.1 from hi), add_comm]\n        rfl\n      rw [hx, Fin.append_right, hy, Fin.append_right]\n      convert q.step ⟨i - (p.length + 1), Nat.sub_lt_left_of_lt_add hi <| by omega⟩\n      rw [Fin.succ_mk, Nat.sub_eq_iff_eq_add (le_of_lt hi : p.length ≤ i),\n        Nat.add_assoc _ 1, add_comm 1, Nat.sub_add_cancel]\n      exact hi\n\n"}
{"name":"RelSeries.append_apply_left","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np q : RelSeries r\nconnect : r p.last q.head\ni : Fin (HAdd.hAdd p.length 1)\n⊢ Eq ((p.append q connect).toFun (Fin.cast ⋯ (Fin.castAdd (HAdd.hAdd q.length 1) i))) (p.toFun i)","decl":"lemma append_apply_left (p q : RelSeries r) (connect : r p.last q.head)\n    (i : Fin (p.length + 1)) :\n    p.append q connect ((i.castAdd (q.length + 1)).cast (by dsimp; omega)) = p i := by\n  delta append\n  simp only [Function.comp_apply]\n  convert Fin.append_left _ _ _\n\n"}
{"name":"RelSeries.append_apply_right","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np q : RelSeries r\nconnect : r p.last q.head\ni : Fin (HAdd.hAdd q.length 1)\n⊢ Eq ((p.append q connect).toFun (HAdd.hAdd (↑↑(Fin.natAdd p.length i)) 1)) (q.toFun i)","decl":"lemma append_apply_right (p q : RelSeries r) (connect : r p.last q.head)\n    (i : Fin (q.length + 1)) :\n    p.append q connect (i.natAdd p.length + 1) = q i := by\n  delta append\n  simp only [Fin.coe_natAdd, Nat.cast_add, Function.comp_apply]\n  convert Fin.append_right _ _ _\n  ext\n  simp only [Fin.coe_cast, Fin.coe_natAdd]\n  conv_rhs => rw [add_assoc, add_comm 1, ← add_assoc]\n  change _ % _ = _\n  simp only [Nat.add_mod_mod, Nat.mod_add_mod, Nat.one_mod, Nat.mod_succ_eq_iff_lt]\n  omega\n\n"}
{"name":"RelSeries.head_append","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np q : RelSeries r\nconnect : r p.last q.head\n⊢ Eq (p.append q connect).head p.head","decl":"@[simp] lemma head_append (p q : RelSeries r) (connect : r p.last q.head) :\n    (p.append q connect).head = p.head :=\n  append_apply_left p q connect 0\n\n"}
{"name":"RelSeries.last_append","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np q : RelSeries r\nconnect : r p.last q.head\n⊢ Eq (p.append q connect).last q.last","decl":"@[simp] lemma last_append (p q : RelSeries r) (connect : r p.last q.head) :\n    (p.append q connect).last = q.last := by\n  delta last\n  convert append_apply_right p q connect (Fin.last _)\n  ext\n  change _ = _ % _\n  simp only [append_length, Fin.val_last, Fin.natAdd_last, Nat.one_mod, Nat.mod_add_mod,\n    Nat.mod_succ]\n\n"}
{"name":"RelSeries.map_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nβ : Type u_2\ns : Rel β β\np : RelSeries r\nf : RelHom r s\n⊢ Eq (p.map f).length p.length","decl":"/--\nFor two types `α, β` and relation on them `r, s`, if `f : α → β` preserves relation `r`, then an\n`r`-series can be pushed out to an `s`-series by\n`a₀ -r→ a₁ -r→ ... -r→ aₙ ↦ f a₀ -s→ f a₁ -s→ ... -s→ f aₙ`\n-/\n@[simps length]\ndef map (p : RelSeries r) (f : r →r s) : RelSeries s where\n  length := p.length\n  toFun := f.1.comp p\n  step := (f.2 <| p.step ·)\n\n"}
{"name":"RelSeries.map_apply","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nβ : Type u_2\ns : Rel β β\np : RelSeries r\nf : RelHom r s\ni : Fin (HAdd.hAdd p.length 1)\n⊢ Eq ((p.map f).toFun i) (f (p.toFun i))","decl":"@[simp] lemma map_apply (p : RelSeries r) (f : r →r s) (i : Fin (p.length + 1)) :\n    p.map f i = f (p i) := rfl\n\n"}
{"name":"RelSeries.head_map","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nβ : Type u_2\ns : Rel β β\np : RelSeries r\nf : RelHom r s\n⊢ Eq (p.map f).head (f p.head)","decl":"@[simp] lemma head_map (p : RelSeries r) (f : r →r s) : (p.map f).head = f p.head := rfl\n\n"}
{"name":"RelSeries.last_map","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\nβ : Type u_2\ns : Rel β β\np : RelSeries r\nf : RelHom r s\n⊢ Eq (p.map f).last (f p.last)","decl":"@[simp] lemma last_map (p : RelSeries r) (f : r →r s) : (p.map f).last = f p.last := rfl\n\n"}
{"name":"RelSeries.insertNth_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\ni : Fin p.length\na : α\nprev_connect : r (p.toFun i.castSucc) a\nconnect_next : r a (p.toFun i.succ)\n⊢ Eq (p.insertNth i a prev_connect connect_next).length (HAdd.hAdd p.length 1)","decl":"/--\nIf `a₀ -r→ a₁ -r→ ... -r→ aₙ` is an `r`-series and `a` is such that\n`aᵢ -r→ a -r→ a_ᵢ₊₁`, then\n`a₀ -r→ a₁ -r→ ... -r→ aᵢ -r→ a -r→ aᵢ₊₁ -r→ ... -r→ aₙ`\nis another `r`-series\n-/\n@[simps]\ndef insertNth (p : RelSeries r) (i : Fin p.length) (a : α)\n    (prev_connect : r (p (Fin.castSucc i)) a) (connect_next : r a (p i.succ)) : RelSeries r where\n  toFun := (Fin.castSucc i.succ).insertNth a p\n  step m := by\n    set x := _; set y := _; change r x y\n    obtain hm | hm | hm := lt_trichotomy m.1 i.1\n    · convert p.step ⟨m, hm.trans i.2⟩\n      · show Fin.insertNth _ _ _ _ = _\n        rw [Fin.insertNth_apply_below]\n        pick_goal 2\n        · exact hm.trans (lt_add_one _)\n        simp\n      · show Fin.insertNth _ _ _ _ = _\n        rw [Fin.insertNth_apply_below]\n        pick_goal 2\n        · change m.1 + 1 < i.1 + 1; rwa [add_lt_add_iff_right]\n        simp; rfl\n    · rw [show x = p m from show Fin.insertNth _ _ _ _ = _ by\n        rw [Fin.insertNth_apply_below]\n        pick_goal 2\n        · show m.1 < i.1 + 1; exact hm ▸ lt_add_one _\n        simp]\n      convert prev_connect\n      · ext; exact hm\n      · change Fin.insertNth _ _ _ _ = _\n        rw [show m.succ = i.succ.castSucc by ext; change _ + 1 = _ + 1; rw [hm],\n          Fin.insertNth_apply_same]\n    · rw [Nat.lt_iff_add_one_le, le_iff_lt_or_eq] at hm\n      obtain hm | hm := hm\n      · convert p.step ⟨m.1 - 1, Nat.sub_lt_right_of_lt_add (by omega) m.2⟩\n        · change Fin.insertNth _ _ _ _ = _\n          rw [Fin.insertNth_apply_above (h := hm)]\n          aesop\n        · change Fin.insertNth _ _ _ _ = _\n          rw [Fin.insertNth_apply_above]\n          swap\n          · exact hm.trans (lt_add_one _)\n          simp only [Fin.val_succ, Fin.pred_succ, eq_rec_constant, Fin.succ_mk]\n          congr\n          exact Fin.ext <| Eq.symm <| Nat.succ_pred_eq_of_pos (lt_trans (Nat.zero_lt_succ _) hm)\n      · convert connect_next\n        · change Fin.insertNth _ _ _ _ = _\n          rw [show m.castSucc = i.succ.castSucc from Fin.ext hm.symm, Fin.insertNth_apply_same]\n        · change Fin.insertNth _ _ _ _ = _\n          rw [Fin.insertNth_apply_above]\n          swap\n          · change i.1 + 1 < m.1 + 1; omega\n          simp only [Fin.pred_succ, eq_rec_constant]\n          congr; ext; exact hm.symm\n\n"}
{"name":"RelSeries.insertNth_toFun","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\ni : Fin p.length\na : α\nprev_connect : r (p.toFun i.castSucc) a\nconnect_next : r a (p.toFun i.succ)\nj : Fin (HAdd.hAdd (HAdd.hAdd p.length 1) 1)\n⊢ Eq ((p.insertNth i a prev_connect connect_next).toFun j) (i.succ.castSucc.insertNth a p.toFun j)","decl":"/--\nIf `a₀ -r→ a₁ -r→ ... -r→ aₙ` is an `r`-series and `a` is such that\n`aᵢ -r→ a -r→ a_ᵢ₊₁`, then\n`a₀ -r→ a₁ -r→ ... -r→ aᵢ -r→ a -r→ aᵢ₊₁ -r→ ... -r→ aₙ`\nis another `r`-series\n-/\n@[simps]\ndef insertNth (p : RelSeries r) (i : Fin p.length) (a : α)\n    (prev_connect : r (p (Fin.castSucc i)) a) (connect_next : r a (p i.succ)) : RelSeries r where\n  toFun := (Fin.castSucc i.succ).insertNth a p\n  step m := by\n    set x := _; set y := _; change r x y\n    obtain hm | hm | hm := lt_trichotomy m.1 i.1\n    · convert p.step ⟨m, hm.trans i.2⟩\n      · show Fin.insertNth _ _ _ _ = _\n        rw [Fin.insertNth_apply_below]\n        pick_goal 2\n        · exact hm.trans (lt_add_one _)\n        simp\n      · show Fin.insertNth _ _ _ _ = _\n        rw [Fin.insertNth_apply_below]\n        pick_goal 2\n        · change m.1 + 1 < i.1 + 1; rwa [add_lt_add_iff_right]\n        simp; rfl\n    · rw [show x = p m from show Fin.insertNth _ _ _ _ = _ by\n        rw [Fin.insertNth_apply_below]\n        pick_goal 2\n        · show m.1 < i.1 + 1; exact hm ▸ lt_add_one _\n        simp]\n      convert prev_connect\n      · ext; exact hm\n      · change Fin.insertNth _ _ _ _ = _\n        rw [show m.succ = i.succ.castSucc by ext; change _ + 1 = _ + 1; rw [hm],\n          Fin.insertNth_apply_same]\n    · rw [Nat.lt_iff_add_one_le, le_iff_lt_or_eq] at hm\n      obtain hm | hm := hm\n      · convert p.step ⟨m.1 - 1, Nat.sub_lt_right_of_lt_add (by omega) m.2⟩\n        · change Fin.insertNth _ _ _ _ = _\n          rw [Fin.insertNth_apply_above (h := hm)]\n          aesop\n        · change Fin.insertNth _ _ _ _ = _\n          rw [Fin.insertNth_apply_above]\n          swap\n          · exact hm.trans (lt_add_one _)\n          simp only [Fin.val_succ, Fin.pred_succ, eq_rec_constant, Fin.succ_mk]\n          congr\n          exact Fin.ext <| Eq.symm <| Nat.succ_pred_eq_of_pos (lt_trans (Nat.zero_lt_succ _) hm)\n      · convert connect_next\n        · change Fin.insertNth _ _ _ _ = _\n          rw [show m.castSucc = i.succ.castSucc from Fin.ext hm.symm, Fin.insertNth_apply_same]\n        · change Fin.insertNth _ _ _ _ = _\n          rw [Fin.insertNth_apply_above]\n          swap\n          · change i.1 + 1 < m.1 + 1; omega\n          simp only [Fin.pred_succ, eq_rec_constant]\n          congr; ext; exact hm.symm\n\n"}
{"name":"RelSeries.reverse_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\n⊢ Eq p.reverse.length p.length","decl":"/--\nA relation series `a₀ -r→ a₁ -r→ ... -r→ aₙ` of `r` gives a relation series of the reverse of `r`\nby reversing the series `aₙ ←r- aₙ₋₁ ←r- ... ←r- a₁ ←r- a₀`.\n-/\n@[simps length]\ndef reverse (p : RelSeries r) : RelSeries (fun (a b : α) ↦ r b a) where\n  length := p.length\n  toFun := p ∘ Fin.rev\n  step i := by\n    rw [Function.comp_apply, Function.comp_apply]\n    have hi : i.1 + 1 ≤ p.length := by omega\n    convert p.step ⟨p.length - (i.1 + 1), Nat.sub_lt_self (by omega) hi⟩\n    · ext; simp\n    · ext\n      simp only [Fin.val_rev, Fin.coe_castSucc, Fin.val_succ]\n      omega\n\n"}
{"name":"RelSeries.reverse_apply","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\ni : Fin (HAdd.hAdd p.length 1)\n⊢ Eq (p.reverse.toFun i) (p.toFun i.rev)","decl":"@[simp] lemma reverse_apply (p : RelSeries r) (i : Fin (p.length + 1)) :\n    p.reverse i = p i.rev := rfl\n\n"}
{"name":"RelSeries.last_reverse","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\n⊢ Eq p.reverse.last p.head","decl":"@[simp] lemma last_reverse (p : RelSeries r) : p.reverse.last = p.head := by\n  simp [RelSeries.last, RelSeries.head]\n\n"}
{"name":"RelSeries.head_reverse","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\n⊢ Eq p.reverse.head p.last","decl":"@[simp] lemma head_reverse (p : RelSeries r) : p.reverse.head = p.last := by\n  simp [RelSeries.last, RelSeries.head]\n\n"}
{"name":"RelSeries.reverse_reverse","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\n⊢ Eq p.reverse.reverse p","decl":"@[simp] lemma reverse_reverse {r : Rel α α} (p : RelSeries r) : p.reverse.reverse = p := by\n  ext <;> simp\n\n"}
{"name":"RelSeries.cons_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\nnewHead : α\nrel : r newHead p.head\n⊢ Eq (p.cons newHead rel).length (HAdd.hAdd p.length 1)","decl":"/--\nGiven a series `a₀ -r→ a₁ -r→ ... -r→ aₙ` and an `a` such that `a₀ -r→ a` holds, there is\na series of length `n+1`: `a -r→ a₀ -r→ a₁ -r→ ... -r→ aₙ`.\n-/\n@[simps! length]\ndef cons (p : RelSeries r) (newHead : α) (rel : r newHead p.head) : RelSeries r :=\n  (singleton r newHead).append p rel\n\n"}
{"name":"RelSeries.head_cons","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\nnewHead : α\nrel : r newHead p.head\n⊢ Eq (p.cons newHead rel).head newHead","decl":"@[simp] lemma head_cons (p : RelSeries r) (newHead : α) (rel : r newHead p.head) :\n    (p.cons newHead rel).head = newHead := rfl\n\n"}
{"name":"RelSeries.last_cons","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\nnewHead : α\nrel : r newHead p.head\n⊢ Eq (p.cons newHead rel).last p.last","decl":"@[simp] lemma last_cons (p : RelSeries r) (newHead : α) (rel : r newHead p.head) :\n    (p.cons newHead rel).last = p.last := by\n  delta cons\n  rw [last_append]\n\n"}
{"name":"RelSeries.snoc_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\nnewLast : α\nrel : r p.last newLast\n⊢ Eq (p.snoc newLast rel).length (HAdd.hAdd p.length 1)","decl":"/--\nGiven a series `a₀ -r→ a₁ -r→ ... -r→ aₙ` and an `a` such that `aₙ -r→ a` holds, there is\na series of length `n+1`: `a₀ -r→ a₁ -r→ ... -r→ aₙ -r→ a`.\n-/\n@[simps! length]\ndef snoc (p : RelSeries r) (newLast : α) (rel : r p.last newLast) : RelSeries r :=\n  p.append (singleton r newLast) rel\n\n"}
{"name":"RelSeries.head_snoc","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\nnewLast : α\nrel : r p.last newLast\n⊢ Eq (p.snoc newLast rel).head p.head","decl":"@[simp] lemma head_snoc (p : RelSeries r) (newLast : α) (rel : r p.last newLast) :\n    (p.snoc newLast rel).head = p.head := by\n  delta snoc; rw [head_append]\n\n"}
{"name":"RelSeries.last_snoc","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\nnewLast : α\nrel : r p.last newLast\n⊢ Eq (p.snoc newLast rel).last newLast","decl":"@[simp] lemma last_snoc (p : RelSeries r) (newLast : α) (rel : r p.last newLast) :\n    (p.snoc newLast rel).last = newLast := last_append _ _ _\n\n-- This lemma is useful because `last_snoc` is about `Fin.last (p.snoc _ _).length`, but we often\n-- see `Fin.last (p.length + 1)` in practice. They are equal by definition, but sometimes simplifier\n-- does not pick up `last_snoc`\n"}
{"name":"RelSeries.last_snoc'","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\nnewLast : α\nrel : r p.last newLast\n⊢ Eq ((p.snoc newLast rel).toFun (Fin.last (HAdd.hAdd p.length 1))) newLast","decl":"@[simp] lemma last_snoc' (p : RelSeries r) (newLast : α) (rel : r p.last newLast) :\n    p.snoc newLast rel (Fin.last (p.length + 1)) = newLast := last_append _ _ _\n\n"}
{"name":"RelSeries.snoc_castSucc","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ns : RelSeries r\na : α\nconnect : r s.last a\ni : Fin (HAdd.hAdd s.length 1)\n⊢ Eq ((s.snoc a connect).toFun i.castSucc) (s.toFun i)","decl":"@[simp] lemma snoc_castSucc (s : RelSeries r) (a : α) (connect : r s.last a)\n    (i : Fin (s.length + 1)) : snoc s a connect (Fin.castSucc i) = s i :=\n  Fin.append_left _ _ i\n\n"}
{"name":"RelSeries.mem_snoc","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\nnewLast : α\nrel : r p.last newLast\nx : α\n⊢ Iff (Membership.mem (p.snoc newLast rel) x) (Or (Membership.mem p x) (Eq x newLast))","decl":"lemma mem_snoc {p : RelSeries r} {newLast : α} {rel : r p.last newLast} {x : α} :\n    x ∈ p.snoc newLast rel ↔ x ∈ p ∨ x = newLast := by\n  simp only [snoc, append, singleton_length, Nat.add_zero, Nat.reduceAdd, Fin.cast_refl,\n    Function.comp_id, mem_def, id_eq, Set.mem_range]\n  constructor\n  · rintro ⟨i, rfl⟩\n    exact Fin.lastCases (Or.inr <| Fin.append_right _ _ 0) (fun i => Or.inl ⟨⟨i.1, i.2⟩,\n      (Fin.append_left _ _ _).symm⟩) i\n  · intro h\n    rcases h with (⟨i, rfl⟩ | rfl)\n    · exact ⟨i.castSucc, Fin.append_left _ _ _⟩\n    · exact ⟨Fin.last _, Fin.append_right _ _ 0⟩\n\n"}
{"name":"RelSeries.tail_toFun","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\nlen_pos : Ne p.length 0\na✝ : Fin (HAdd.hAdd (HSub.hSub p.length 1) 1)\n⊢ Eq ((p.tail len_pos).toFun a✝) (Function.comp (Fin.tail p.toFun) (Fin.cast ⋯) a✝)","decl":"/--\nIf a series `a₀ -r→ a₁ -r→ ...` has positive length, then `a₁ -r→ ...` is another series\n-/\n@[simps]\ndef tail (p : RelSeries r) (len_pos : p.length ≠ 0) : RelSeries r where\n  length := p.length - 1\n  toFun := Fin.tail p ∘ (Fin.cast <| Nat.succ_pred_eq_of_pos <| Nat.pos_of_ne_zero len_pos)\n  step i := p.step ⟨i.1 + 1, Nat.lt_pred_iff.mp i.2⟩\n\n"}
{"name":"RelSeries.tail_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\nlen_pos : Ne p.length 0\n⊢ Eq (p.tail len_pos).length (HSub.hSub p.length 1)","decl":"/--\nIf a series `a₀ -r→ a₁ -r→ ...` has positive length, then `a₁ -r→ ...` is another series\n-/\n@[simps]\ndef tail (p : RelSeries r) (len_pos : p.length ≠ 0) : RelSeries r where\n  length := p.length - 1\n  toFun := Fin.tail p ∘ (Fin.cast <| Nat.succ_pred_eq_of_pos <| Nat.pos_of_ne_zero len_pos)\n  step i := p.step ⟨i.1 + 1, Nat.lt_pred_iff.mp i.2⟩\n\n"}
{"name":"RelSeries.head_tail","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\nlen_pos : Ne p.length 0\n⊢ Eq (p.tail len_pos).head (p.toFun 1)","decl":"@[simp] lemma head_tail (p : RelSeries r) (len_pos : p.length ≠ 0) :\n    (p.tail len_pos).head = p 1 := by\n  show p (Fin.succ _) = p 1\n  congr\n  ext\n  show (1 : ℕ) = (1 : ℕ) % _\n  rw [Nat.mod_eq_of_lt]\n  simpa only [lt_add_iff_pos_left, Nat.pos_iff_ne_zero]\n\n"}
{"name":"RelSeries.last_tail","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\nlen_pos : Ne p.length 0\n⊢ Eq (p.tail len_pos).last p.last","decl":"@[simp] lemma last_tail (p : RelSeries r) (len_pos : p.length ≠ 0) :\n    (p.tail len_pos).last = p.last := by\n  show p _ = p _\n  congr\n  ext\n  simp only [tail_length, Fin.val_succ, Fin.coe_cast, Fin.val_last]\n  exact Nat.succ_pred_eq_of_pos (by simpa [Nat.pos_iff_ne_zero] using len_pos)\n\n\n"}
{"name":"RelSeries.eraseLast_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\n⊢ Eq p.eraseLast.length (HSub.hSub p.length 1)","decl":"/--\nIf a series ``a₀ -r→ a₁ -r→ ... -r→ aₙ``, then `a₀ -r→ a₁ -r→ ... -r→ aₙ₋₁` is\nanother series -/\n@[simps]\ndef eraseLast (p : RelSeries r) : RelSeries r where\n  length := p.length - 1\n  toFun i := p ⟨i, lt_of_lt_of_le i.2 (Nat.succ_le_succ (Nat.sub_le _ _))⟩\n  step i := p.step ⟨i, lt_of_lt_of_le i.2 (Nat.sub_le _ _)⟩\n\n"}
{"name":"RelSeries.eraseLast_toFun","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\ni : Fin (HAdd.hAdd (HSub.hSub p.length 1) 1)\n⊢ Eq (p.eraseLast.toFun i) (p.toFun ⟨↑i, ⋯⟩)","decl":"/--\nIf a series ``a₀ -r→ a₁ -r→ ... -r→ aₙ``, then `a₀ -r→ a₁ -r→ ... -r→ aₙ₋₁` is\nanother series -/\n@[simps]\ndef eraseLast (p : RelSeries r) : RelSeries r where\n  length := p.length - 1\n  toFun i := p ⟨i, lt_of_lt_of_le i.2 (Nat.succ_le_succ (Nat.sub_le _ _))⟩\n  step i := p.step ⟨i, lt_of_lt_of_le i.2 (Nat.sub_le _ _)⟩\n\n"}
{"name":"RelSeries.head_eraseLast","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\n⊢ Eq p.eraseLast.head p.head","decl":"@[simp] lemma head_eraseLast (p : RelSeries r) : p.eraseLast.head = p.head := rfl\n\n"}
{"name":"RelSeries.last_eraseLast","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\n⊢ Eq p.eraseLast.last (p.toFun ⟨p.length.pred, ⋯⟩)","decl":"@[simp] lemma last_eraseLast (p : RelSeries r) :\n    p.eraseLast.last = p ⟨p.length.pred, Nat.lt_succ_iff.2 (Nat.pred_le _)⟩ := rfl\n\n"}
{"name":"RelSeries.eraseLast_last_rel_last","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\nh : Ne p.length 0\n⊢ r p.eraseLast.last p.last","decl":"/-- In a non-trivial series `p`, the last element of `p.eraseLast` is related to `p.last` -/\nlemma eraseLast_last_rel_last (p : RelSeries r) (h : p.length ≠ 0) :\n    r p.eraseLast.last p.last := by\n  simp only [last, Fin.last, eraseLast_length, eraseLast_toFun]\n  convert p.step ⟨p.length - 1, by omega⟩\n  simp only [Nat.succ_eq_add_one, Fin.succ_mk]; omega\n\n"}
{"name":"RelSeries.smash_toFun","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np q : RelSeries r\nconnect : Eq p.last q.head\ni : Fin (HAdd.hAdd (HAdd.hAdd p.length q.length) 1)\n⊢ Eq ((p.smash q connect).toFun i) (dite (LT.lt (↑i) p.length) (fun H => p.toFun ⟨↑i, ⋯⟩) fun H => q.toFun ⟨HSub.hSub (↑i) p.length, ⋯⟩)","decl":"/--\nGiven two series of the form `a₀ -r→ ... -r→ X` and `X -r→ b ---> ...`,\nthen `a₀ -r→ ... -r→ X -r→ b ...` is another series obtained by combining the given two.\n-/\n@[simps]\ndef smash (p q : RelSeries r) (connect : p.last = q.head) : RelSeries r where\n  length := p.length + q.length\n  toFun i :=\n    if H : i.1 < p.length\n    then p ⟨i.1, H.trans (lt_add_one _)⟩\n    else q ⟨i.1 - p.length,\n      Nat.sub_lt_left_of_lt_add (by rwa [not_lt] at H) (by rw [← add_assoc]; exact i.2)⟩\n  step i := by\n    dsimp only\n    by_cases h₂ : i.1 + 1 < p.length\n    · have h₁ : i.1 < p.length := lt_trans (lt_add_one _) h₂\n      simp only [Fin.coe_castSucc, Fin.val_succ]\n      rw [dif_pos h₁, dif_pos h₂]\n      convert p.step ⟨i, h₁⟩ using 1\n    · simp only [Fin.coe_castSucc, Fin.val_succ]\n      rw [dif_neg h₂]\n      by_cases h₁ : i.1 < p.length\n      · rw [dif_pos h₁]\n        have h₃ : p.length = i.1 + 1 := by omega\n        convert p.step ⟨i, h₁⟩ using 1\n        convert connect.symm\n        · aesop\n        · congr; aesop\n      · rw [dif_neg h₁]\n        convert q.step ⟨i.1 - p.length, _⟩ using 1\n        · congr\n          change (i.1 + 1) - _ = _\n          rw [Nat.sub_add_comm]\n          rwa [not_lt] at h₁\n        · refine Nat.sub_lt_left_of_lt_add ?_ i.2\n          rwa [not_lt] at h₁\n\n"}
{"name":"RelSeries.smash_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np q : RelSeries r\nconnect : Eq p.last q.head\n⊢ Eq (p.smash q connect).length (HAdd.hAdd p.length q.length)","decl":"/--\nGiven two series of the form `a₀ -r→ ... -r→ X` and `X -r→ b ---> ...`,\nthen `a₀ -r→ ... -r→ X -r→ b ...` is another series obtained by combining the given two.\n-/\n@[simps]\ndef smash (p q : RelSeries r) (connect : p.last = q.head) : RelSeries r where\n  length := p.length + q.length\n  toFun i :=\n    if H : i.1 < p.length\n    then p ⟨i.1, H.trans (lt_add_one _)⟩\n    else q ⟨i.1 - p.length,\n      Nat.sub_lt_left_of_lt_add (by rwa [not_lt] at H) (by rw [← add_assoc]; exact i.2)⟩\n  step i := by\n    dsimp only\n    by_cases h₂ : i.1 + 1 < p.length\n    · have h₁ : i.1 < p.length := lt_trans (lt_add_one _) h₂\n      simp only [Fin.coe_castSucc, Fin.val_succ]\n      rw [dif_pos h₁, dif_pos h₂]\n      convert p.step ⟨i, h₁⟩ using 1\n    · simp only [Fin.coe_castSucc, Fin.val_succ]\n      rw [dif_neg h₂]\n      by_cases h₁ : i.1 < p.length\n      · rw [dif_pos h₁]\n        have h₃ : p.length = i.1 + 1 := by omega\n        convert p.step ⟨i, h₁⟩ using 1\n        convert connect.symm\n        · aesop\n        · congr; aesop\n      · rw [dif_neg h₁]\n        convert q.step ⟨i.1 - p.length, _⟩ using 1\n        · congr\n          change (i.1 + 1) - _ = _\n          rw [Nat.sub_add_comm]\n          rwa [not_lt] at h₁\n        · refine Nat.sub_lt_left_of_lt_add ?_ i.2\n          rwa [not_lt] at h₁\n\n"}
{"name":"RelSeries.smash_castAdd","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np q : RelSeries r\nconnect : Eq p.last q.head\ni : Fin p.length\n⊢ Eq ((p.smash q connect).toFun (Fin.castAdd q.length i).castSucc) (p.toFun i.castSucc)","decl":"lemma smash_castAdd {p q : RelSeries r} (connect : p.last = q.head) (i : Fin p.length) :\n    p.smash q connect (Fin.castSucc <| i.castAdd q.length) = p (Fin.castSucc i) := by\n  unfold smash\n  dsimp\n  rw [dif_pos i.2]\n  rfl\n\n"}
{"name":"RelSeries.smash_succ_castAdd","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np q : RelSeries r\nh : Eq p.last q.head\ni : Fin p.length\n⊢ Eq ((p.smash q h).toFun (Fin.castAdd q.length i).succ) (p.toFun i.succ)","decl":"lemma smash_succ_castAdd {p q : RelSeries r} (h : p.last = q.head)\n    (i : Fin p.length) : p.smash q h (i.castAdd q.length).succ = p i.succ := by\n  rw [smash_toFun]\n  split_ifs with H\n  · congr\n  · simp only [Fin.val_succ, Fin.coe_castAdd] at H\n    convert h.symm\n    · congr\n      simp only [Fin.val_succ, Fin.coe_castAdd, Nat.zero_mod, Nat.sub_eq_zero_iff_le]\n      omega\n    · congr\n      ext\n      change i.1 + 1 = p.length\n      omega\n\n"}
{"name":"RelSeries.smash_natAdd","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np q : RelSeries r\nh : Eq p.last q.head\ni : Fin q.length\n⊢ Eq ((p.smash q h).toFun (Fin.natAdd p.length i).castSucc) (q.toFun i.castSucc)","decl":"lemma smash_natAdd {p q : RelSeries r} (h : p.last = q.head) (i : Fin q.length) :\n    smash p q h (Fin.castSucc <| i.natAdd p.length) = q (Fin.castSucc i) := by\n  rw [smash_toFun, dif_neg (by simp)]\n  congr\n  exact Nat.add_sub_self_left _ _\n\n"}
{"name":"RelSeries.smash_succ_natAdd","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np q : RelSeries r\nh : Eq p.last q.head\ni : Fin q.length\n⊢ Eq ((p.smash q h).toFun (Fin.natAdd p.length i).succ) (q.toFun i.succ)","decl":"lemma smash_succ_natAdd {p q : RelSeries r} (h : p.last = q.head) (i : Fin q.length) :\n    smash p q h (i.natAdd p.length).succ = q i.succ := by\n  rw [smash_toFun]\n  split_ifs with H\n  · have H' : p.length < p.length + (i.1 + 1) := by omega\n    exact (lt_irrefl _ (H.trans H')).elim\n  · congr\n    simp only [Fin.val_succ, Fin.coe_natAdd]\n    rw [add_assoc, Nat.add_sub_cancel_left]\n\n"}
{"name":"RelSeries.head_smash","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np q : RelSeries r\nh : Eq p.last q.head\n⊢ Eq (p.smash q h).head p.head","decl":"@[simp] lemma head_smash {p q : RelSeries r} (h : p.last = q.head) :\n    (smash p q h).head = p.head := by\n  delta head smash\n  simp only [Fin.val_zero, Fin.zero_eta, zero_le, Nat.sub_eq_zero_of_le, dite_eq_ite,\n    ite_eq_left_iff, not_lt, nonpos_iff_eq_zero]\n  intro H; convert h.symm; congr; aesop\n\n"}
{"name":"RelSeries.last_smash","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np q : RelSeries r\nh : Eq p.last q.head\n⊢ Eq (p.smash q h).last q.last","decl":"@[simp] lemma last_smash {p q : RelSeries r} (h : p.last = q.head) :\n    (smash p q h).last = q.last := by\n  delta smash last; aesop\n\n"}
{"name":"RelSeries.take_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\ni : Fin (HAdd.hAdd p.length 1)\n⊢ Eq (p.take i).length ↑i","decl":"/-- Given the series `a₀ -r→ … -r→ aᵢ -r→ … -r→ aₙ`, the series `a₀ -r→ … -r→ aᵢ`. -/\n@[simps! length]\ndef take {r : Rel α α} (p : RelSeries r) (i : Fin (p.length + 1)) : RelSeries r where\n  length := i\n  toFun := fun ⟨j, h⟩ => p.toFun ⟨j, by omega⟩\n  step := fun ⟨j, h⟩ => p.step ⟨j, by omega⟩\n\n"}
{"name":"RelSeries.head_take","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\ni : Fin (HAdd.hAdd p.length 1)\n⊢ Eq (p.take i).head p.head","decl":"@[simp]\nlemma head_take (p : RelSeries r) (i : Fin (p.length + 1)) :\n    (p.take i).head = p.head := by simp [take, head]\n\n"}
{"name":"RelSeries.last_take","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\ni : Fin (HAdd.hAdd p.length 1)\n⊢ Eq (p.take i).last (p.toFun i)","decl":"@[simp]\nlemma last_take (p : RelSeries r) (i : Fin (p.length + 1)) :\n    (p.take i).last = p i := by simp [take, last, Fin.last]\n\n"}
{"name":"RelSeries.drop_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\ni : Fin (HAdd.hAdd p.length 1)\n⊢ Eq (p.drop i).length (HSub.hSub p.length ↑i)","decl":"/-- Given the series `a₀ -r→ … -r→ aᵢ -r→ … -r→ aₙ`, the series `aᵢ₊₁ -r→ … -r→ aᵢ`. -/\n@[simps! length]\ndef drop (p : RelSeries r) (i : Fin (p.length + 1)) : RelSeries r where\n  length := p.length - i\n  toFun := fun ⟨j, h⟩ => p.toFun ⟨j+i, by omega⟩\n  step := fun ⟨j, h⟩ => by\n    convert p.step ⟨j+i.1, by omega⟩\n    simp only [Nat.succ_eq_add_one, Fin.succ_mk]; omega\n\n"}
{"name":"RelSeries.head_drop","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\ni : Fin (HAdd.hAdd p.length 1)\n⊢ Eq (p.drop i).head (p.toFun i)","decl":"@[simp]\nlemma head_drop (p : RelSeries r) (i : Fin (p.length + 1)) : (p.drop i).head = p.toFun i := by\n  simp [drop, head]\n\n"}
{"name":"RelSeries.last_drop","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\np : RelSeries r\ni : Fin (HAdd.hAdd p.length 1)\n⊢ Eq (p.drop i).last p.last","decl":"@[simp]\nlemma last_drop (p : RelSeries r) (i : Fin (p.length + 1)) : (p.drop i).last = p.last := by\n  simp only [last, drop, Fin.last]\n  congr\n  omega\n\n"}
{"name":"Rel.not_finiteDimensional_iff","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ninst✝ : Nonempty α\n⊢ Iff (Not r.FiniteDimensional) r.InfiniteDimensional","decl":"variable {r} in\nlemma Rel.not_finiteDimensional_iff [Nonempty α] :\n    ¬ r.FiniteDimensional ↔ r.InfiniteDimensional := by\n  rw [finiteDimensional_iff, infiniteDimensional_iff]\n  push_neg\n  constructor\n  · intro H n\n    induction n with\n    | zero => refine ⟨⟨0, ![Nonempty.some ‹_›], by simp⟩, by simp⟩\n    | succ n IH =>\n      obtain ⟨l, hl⟩ := IH\n      obtain ⟨l', hl'⟩ := H l\n      exact ⟨l'.take ⟨n + 1, by simpa [hl] using hl'⟩, rfl⟩\n  · intro H l\n    obtain ⟨l', hl'⟩ := H (l.length + 1)\n    exact ⟨l', by simp [hl']⟩\n\n"}
{"name":"Rel.not_infiniteDimensional_iff","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ninst✝ : Nonempty α\n⊢ Iff (Not r.InfiniteDimensional) r.FiniteDimensional","decl":"variable {r} in\nlemma Rel.not_infiniteDimensional_iff [Nonempty α] :\n    ¬ r.InfiniteDimensional ↔ r.FiniteDimensional := by\n  rw [← not_finiteDimensional_iff, not_not]\n\n"}
{"name":"Rel.finiteDimensional_or_infiniteDimensional","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nr : Rel α α\ninst✝ : Nonempty α\n⊢ Or r.FiniteDimensional r.InfiniteDimensional","decl":"lemma Rel.finiteDimensional_or_infiniteDimensional [Nonempty α] :\n    r.FiniteDimensional ∨ r.InfiniteDimensional := by\n  rw [← not_finiteDimensional_iff]\n  exact em r.FiniteDimensional\n\n"}
{"name":"FiniteDimensionalOrder.ofUnique","module":"Mathlib.Order.RelSeries","initialProofState":"γ : Type u_3\ninst✝¹ : Preorder γ\ninst✝ : Unique γ\n⊢ FiniteDimensionalOrder γ","decl":"instance FiniteDimensionalOrder.ofUnique (γ : Type*) [Preorder γ] [Unique γ] :\n    FiniteDimensionalOrder γ where\n  exists_longest_relSeries := ⟨.singleton _ default, fun x ↦ by\n    by_contra! r\n    exact (ne_of_lt <| x.step ⟨0, by omega⟩) <| Subsingleton.elim _ _⟩\n\n"}
{"name":"LTSeries.length_withLength","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : InfiniteDimensionalOrder α\nn : Nat\n⊢ Eq (LTSeries.withLength α n).length n","decl":"@[simp] lemma length_withLength [InfiniteDimensionalOrder α] (n : ℕ) :\n    (LTSeries.withLength α n).length = n :=\n  RelSeries.length_withLength _ _\n\n"}
{"name":"LTSeries.nonempty_of_infiniteDimensionalType","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : InfiniteDimensionalOrder α\n⊢ Nonempty α","decl":"/-- if `α` is infinite dimensional, then `α` is nonempty. -/\nlemma nonempty_of_infiniteDimensionalType [InfiniteDimensionalOrder α] : Nonempty α :=\n  ⟨LTSeries.withLength α 0 0⟩\n\n"}
{"name":"LTSeries.longestOf_is_longest","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : FiniteDimensionalOrder α\nx : LTSeries α\n⊢ LE.le x.length (LTSeries.longestOf α).length","decl":"lemma longestOf_is_longest [FiniteDimensionalOrder α] (x : LTSeries α) :\n    x.length ≤ (LTSeries.longestOf α).length :=\n  RelSeries.length_le_length_longestOf _ _\n\n"}
{"name":"LTSeries.longestOf_len_unique","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : FiniteDimensionalOrder α\np : LTSeries α\nis_longest : ∀ (q : LTSeries α), LE.le q.length p.length\n⊢ Eq p.length (LTSeries.longestOf α).length","decl":"lemma longestOf_len_unique [FiniteDimensionalOrder α] (p : LTSeries α)\n    (is_longest : ∀ (q : LTSeries α), q.length ≤ p.length) :\n    p.length = (LTSeries.longestOf α).length :=\n  le_antisymm (longestOf_is_longest _) (is_longest _)\n\n\n"}
{"name":"LTSeries.strictMono","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : LTSeries α\n⊢ StrictMono x.toFun","decl":"lemma strictMono (x : LTSeries α) : StrictMono x :=\n  fun _ _ h => x.rel_of_lt h\n\n"}
{"name":"LTSeries.monotone","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : LTSeries α\n⊢ Monotone x.toFun","decl":"lemma monotone (x : LTSeries α) : Monotone x :=\n  x.strictMono.monotone\n\n"}
{"name":"LTSeries.head_le_last","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : LTSeries α\n⊢ LE.le (RelSeries.head x) (RelSeries.last x)","decl":"lemma head_le_last (x : LTSeries α) : x.head ≤ x.last :=\n  LTSeries.monotone x (Fin.zero_le _)\n\n"}
{"name":"LTSeries.mk_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nlength : Nat\ntoFun : Fin (HAdd.hAdd length 1) → α\nstrictMono : StrictMono toFun\n⊢ Eq (LTSeries.mk length toFun strictMono).length length","decl":"/-- An alternative constructor of `LTSeries` from a strictly monotone function. -/\n@[simps]\ndef mk (length : ℕ) (toFun : Fin (length + 1) → α) (strictMono : StrictMono toFun) :\n    LTSeries α where\n  toFun := toFun\n  step i := strictMono <| lt_add_one i.1\n\n"}
{"name":"LTSeries.mk_toFun","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nlength : Nat\ntoFun : Fin (HAdd.hAdd length 1) → α\nstrictMono : StrictMono toFun\na✝ : Fin (HAdd.hAdd length 1)\n⊢ Eq ((LTSeries.mk length toFun strictMono).toFun a✝) (toFun a✝)","decl":"/-- An alternative constructor of `LTSeries` from a strictly monotone function. -/\n@[simps]\ndef mk (length : ℕ) (toFun : Fin (length + 1) → α) (strictMono : StrictMono toFun) :\n    LTSeries α where\n  toFun := toFun\n  step i := strictMono <| lt_add_one i.1\n\n"}
{"name":"LTSeries.map_toFun","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\np : LTSeries α\nf : α → β\nhf : StrictMono f\na✝ : Fin (HAdd.hAdd p.length 1)\n⊢ Eq ((p.map f hf).toFun a✝) (f (p.toFun a✝))","decl":"/--\nFor two preorders `α, β`, if `f : α → β` is strictly monotonic, then a strict chain of `α`\ncan be pushed out to a strict chain of `β` by\n`a₀ < a₁ < ... < aₙ ↦ f a₀ < f a₁ < ... < f aₙ`\n-/\n@[simps!]\ndef map (p : LTSeries α) (f : α → β) (hf : StrictMono f) : LTSeries β :=\n  LTSeries.mk p.length (f.comp p) (hf.comp p.strictMono)\n\n"}
{"name":"LTSeries.map_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\np : LTSeries α\nf : α → β\nhf : StrictMono f\n⊢ Eq (p.map f hf).length p.length","decl":"/--\nFor two preorders `α, β`, if `f : α → β` is strictly monotonic, then a strict chain of `α`\ncan be pushed out to a strict chain of `β` by\n`a₀ < a₁ < ... < aₙ ↦ f a₀ < f a₁ < ... < f aₙ`\n-/\n@[simps!]\ndef map (p : LTSeries α) (f : α → β) (hf : StrictMono f) : LTSeries β :=\n  LTSeries.mk p.length (f.comp p) (hf.comp p.strictMono)\n\n"}
{"name":"LTSeries.head_map","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\np : LTSeries α\nf : α → β\nhf : StrictMono f\n⊢ Eq (RelSeries.head (p.map f hf)) (f (RelSeries.head p))","decl":"@[simp] lemma head_map (p : LTSeries α) (f : α → β) (hf : StrictMono f) :\n  (p.map f hf).head = f p.head := rfl\n\n"}
{"name":"LTSeries.last_map","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\np : LTSeries α\nf : α → β\nhf : StrictMono f\n⊢ Eq (RelSeries.last (p.map f hf)) (f (RelSeries.last p))","decl":"@[simp] lemma last_map (p : LTSeries α) (f : α → β) (hf : StrictMono f) :\n  (p.map f hf).last = f p.last := rfl\n\n"}
{"name":"LTSeries.comap_length","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\np : LTSeries β\nf : α → β\ncomap : ∀ ⦃x y : α⦄, LT.lt (f x) (f y) → LT.lt x y\nsurjective : Function.Surjective f\n⊢ Eq (p.comap f comap surjective).length p.length","decl":"/--\nFor two preorders `α, β`, if `f : α → β` is surjective and strictly comonotonic, then a\nstrict series of `β` can be pulled back to a strict chain of `α` by\n`b₀ < b₁ < ... < bₙ ↦ f⁻¹ b₀ < f⁻¹ b₁ < ... < f⁻¹ bₙ` where `f⁻¹ bᵢ` is an arbitrary element in the\npreimage of `f⁻¹ {bᵢ}`.\n-/\n@[simps!]\nnoncomputable def comap (p : LTSeries β) (f : α → β)\n  (comap : ∀ ⦃x y⦄, f x < f y → x < y)\n  (surjective : Function.Surjective f) :\n  LTSeries α := mk p.length (fun i ↦ (surjective (p i)).choose)\n    (fun i j h ↦ comap (by simpa only [(surjective _).choose_spec] using p.strictMono h))\n\n"}
{"name":"LTSeries.comap_toFun","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\np : LTSeries β\nf : α → β\ncomap : ∀ ⦃x y : α⦄, LT.lt (f x) (f y) → LT.lt x y\nsurjective : Function.Surjective f\ni : Fin (HAdd.hAdd p.length 1)\n⊢ Eq ((p.comap f comap surjective).toFun i) ⋯.choose","decl":"/--\nFor two preorders `α, β`, if `f : α → β` is surjective and strictly comonotonic, then a\nstrict series of `β` can be pulled back to a strict chain of `α` by\n`b₀ < b₁ < ... < bₙ ↦ f⁻¹ b₀ < f⁻¹ b₁ < ... < f⁻¹ bₙ` where `f⁻¹ bᵢ` is an arbitrary element in the\npreimage of `f⁻¹ {bᵢ}`.\n-/\n@[simps!]\nnoncomputable def comap (p : LTSeries β) (f : α → β)\n  (comap : ∀ ⦃x y⦄, f x < f y → x < y)\n  (surjective : Function.Surjective f) :\n  LTSeries α := mk p.length (fun i ↦ (surjective (p i)).choose)\n    (fun i j h ↦ comap (by simpa only [(surjective _).choose_spec] using p.strictMono h))\n\n"}
{"name":"LTSeries.length_range","module":"Mathlib.Order.RelSeries","initialProofState":"n : Nat\n⊢ Eq (LTSeries.range n).length n","decl":"@[simp] lemma length_range (n : ℕ) : (range n).length = n := rfl\n\n"}
{"name":"LTSeries.range_apply","module":"Mathlib.Order.RelSeries","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq ((LTSeries.range n).toFun i) ↑i","decl":"@[simp] lemma range_apply (n : ℕ) (i : Fin (n+1)) : (range n) i = i := rfl\n\n"}
{"name":"LTSeries.head_range","module":"Mathlib.Order.RelSeries","initialProofState":"n : Nat\n⊢ Eq (RelSeries.head (LTSeries.range n)) 0","decl":"@[simp] lemma head_range (n : ℕ) : (range n).head = 0 := rfl\n\n"}
{"name":"LTSeries.last_range","module":"Mathlib.Order.RelSeries","initialProofState":"n : Nat\n⊢ Eq (RelSeries.last (LTSeries.range n)) n","decl":"@[simp] lemma last_range (n : ℕ) : (range n).last = n := rfl\n\n"}
{"name":"LTSeries.apply_add_index_le_apply_add_index_nat","module":"Mathlib.Order.RelSeries","initialProofState":"p : LTSeries Nat\ni j : Fin (HAdd.hAdd p.length 1)\nhij : LE.le i j\n⊢ LE.le (HAdd.hAdd (p.toFun i) ↑j) (HAdd.hAdd (p.toFun j) ↑i)","decl":"/--\nIn ℕ, two entries in an `LTSeries` differ by at least the difference of their indices.\n(Expressed in a way that avoids subtraction).\n -/\nlemma apply_add_index_le_apply_add_index_nat (p : LTSeries ℕ) (i j : Fin (p.length + 1))\n    (hij : i ≤ j) : p i + j ≤ p j + i := by\n  have ⟨i, hi⟩ := i\n  have ⟨j, hj⟩ := j\n  simp only [Fin.mk_le_mk] at hij\n  simp only at *\n  induction j, hij using Nat.le_induction with\n  | base => simp\n  | succ j _hij ih =>\n    specialize ih (Nat.lt_of_succ_lt hj)\n    have step : p ⟨j, _⟩ < p ⟨j + 1, _⟩ := p.step ⟨j, by omega⟩\n    norm_cast at *; omega\n\n"}
{"name":"LTSeries.apply_add_index_le_apply_add_index_int","module":"Mathlib.Order.RelSeries","initialProofState":"p : LTSeries Int\ni j : Fin (HAdd.hAdd p.length 1)\nhij : LE.le i j\n⊢ LE.le (HAdd.hAdd (p.toFun i) ↑↑j) (HAdd.hAdd (p.toFun j) ↑↑i)","decl":"/--\nIn ℤ, two entries in an `LTSeries` differ by at least the difference of their indices.\n(Expressed in a way that avoids subtraction).\n-/\nlemma apply_add_index_le_apply_add_index_int (p : LTSeries ℤ) (i j : Fin (p.length + 1))\n    (hij : i ≤ j) : p i + j ≤ p j + i := by\n  -- The proof is identical to `LTSeries.apply_add_index_le_apply_add_index_nat`, but seemed easier\n  -- to copy rather than to abstract\n  have ⟨i, hi⟩ := i\n  have ⟨j, hj⟩ := j\n  simp only [Fin.mk_le_mk] at hij\n  simp only at *\n  induction j, hij using Nat.le_induction with\n  | base => simp\n  | succ j _hij ih =>\n    specialize ih (Nat.lt_of_succ_lt hj)\n    have step : p ⟨j, _⟩ < p ⟨j + 1, _⟩:= p.step ⟨j, by omega⟩\n    norm_cast at *; omega\n\n"}
{"name":"LTSeries.head_add_length_le_nat","module":"Mathlib.Order.RelSeries","initialProofState":"p : LTSeries Nat\n⊢ LE.le (HAdd.hAdd (RelSeries.head p) p.length) (RelSeries.last p)","decl":"/-- In ℕ, the head and tail of an `LTSeries` differ at least by the length of the series -/\nlemma head_add_length_le_nat (p : LTSeries ℕ) : p.head + p.length ≤ p.last :=\n  LTSeries.apply_add_index_le_apply_add_index_nat _ _ (Fin.last _) (Fin.zero_le _)\n\n"}
{"name":"LTSeries.head_add_length_le_int","module":"Mathlib.Order.RelSeries","initialProofState":"p : LTSeries Int\n⊢ LE.le (HAdd.hAdd (RelSeries.head p) ↑p.length) (RelSeries.last p)","decl":"/-- In ℤ, the head and tail of an `LTSeries` differ at least by the length of the series -/\nlemma head_add_length_le_int (p : LTSeries ℤ) : p.head + p.length ≤ p.last := by\n  simpa using LTSeries.apply_add_index_le_apply_add_index_int _ _ (Fin.last _) (Fin.zero_le _)\n\n"}
{"name":"LTSeries.length_lt_card","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Fintype α\ns : LTSeries α\n⊢ LT.lt s.length (Fintype.card α)","decl":"lemma length_lt_card (s : LTSeries α) : s.length < Fintype.card α := by\n  by_contra! h\n  obtain ⟨i, j, hn, he⟩ := Fintype.exists_ne_map_eq_of_card_lt s (by rw [Fintype.card_fin]; omega)\n  wlog hl : i < j generalizing i j\n  · exact this j i hn.symm he.symm (by omega)\n  exact absurd he (s.strictMono hl).ne\n\n"}
{"name":"not_finiteDimensionalOrder_iff","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ Iff (Not (FiniteDimensionalOrder α)) (InfiniteDimensionalOrder α)","decl":"lemma not_finiteDimensionalOrder_iff [Preorder α] [Nonempty α] :\n    ¬ FiniteDimensionalOrder α ↔ InfiniteDimensionalOrder α :=\n  Rel.not_finiteDimensional_iff\n\n"}
{"name":"not_infiniteDimensionalOrder_iff","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ Iff (Not (InfiniteDimensionalOrder α)) (FiniteDimensionalOrder α)","decl":"lemma not_infiniteDimensionalOrder_iff [Preorder α] [Nonempty α] :\n    ¬ InfiniteDimensionalOrder α ↔ FiniteDimensionalOrder α :=\n  Rel.not_infiniteDimensional_iff\n\n"}
{"name":"finiteDimensionalOrder_or_infiniteDimensionalOrder","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ Or (FiniteDimensionalOrder α) (InfiniteDimensionalOrder α)","decl":"variable (α) in\nlemma finiteDimensionalOrder_or_infiniteDimensionalOrder [Preorder α] [Nonempty α] :\n    FiniteDimensionalOrder α ∨ InfiniteDimensionalOrder α :=\n  Rel.finiteDimensional_or_infiniteDimensional _\n\n"}
{"name":"infiniteDimensionalOrder_of_strictMono","module":"Mathlib.Order.RelSeries","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : α → β\nhf : StrictMono f\ninst✝ : InfiniteDimensionalOrder α\n⊢ InfiniteDimensionalOrder β","decl":"/-- If `f : α → β` is a strictly monotonic function and `α` is an infinite dimensional type then so\n  is `β`. -/\nlemma infiniteDimensionalOrder_of_strictMono [Preorder α] [Preorder β]\n    (f : α → β) (hf : StrictMono f) [InfiniteDimensionalOrder α] :\n    InfiniteDimensionalOrder β :=\n  ⟨fun n ↦ ⟨(LTSeries.withLength _ n).map f hf, LTSeries.length_withLength α n⟩⟩\n"}
