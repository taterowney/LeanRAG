{"name":"Finset.pow_ssubset_pow_succ_of_pow_ne_closure","module":"Mathlib.Geometry.Group.Growth.LinearLowerBound","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nX : Finset G\nn : Nat\nhX₁ : Membership.mem X 1\nhX : X.Nontrivial\nhXclosure : Ne (HPow.hPow (↑X) n) ↑(Subgroup.closure ↑X)\n⊢ HasSSubset.SSubset (HPow.hPow X n) (HPow.hPow X (HAdd.hAdd n 1))","decl":"@[to_additive]\nlemma pow_ssubset_pow_succ_of_pow_ne_closure (hX₁ : (1 : G) ∈ X) (hX : X.Nontrivial)\n    (hXclosure : (X ^ n : Set G) ≠ closure (X : Set G)) : X ^ n ⊂ X ^ (n + 1) := by\n  obtain rfl | hn := eq_or_ne n 0\n  · simpa [ssubset_iff_subset_not_subset, hX₁, -Finset.subset_singleton_iff]\n      using hX.not_subset_singleton\n  refine (pow_subset_pow_right hX₁ <| n.le_add_right _).ssubset_of_ne ?_\n  contrapose! hXclosure with hXn\n  rw [← closure_pow (mod_cast hX₁) hn]\n  wlog hn₁ : n = 1\n  · simp +contextual only [pow_one] at this\n    replace hXn d : X ^ (n + d) = X ^ n := by\n      induction' d with d hd\n      · rw [add_zero]\n      · rw [pow_add, pow_one] at hXn\n        rw [← add_assoc, pow_add, pow_one, hd, ← hXn]\n    exact mod_cast this (one_mem_pow hX₁) (hX.pow hn) one_ne_zero\n      (by simp [hXn, ← pow_mul, mul_two]) (by simp [hXn, ← pow_mul, mul_two])\n  subst hn₁\n  simp only [ne_eq, one_ne_zero, not_false_eq_true, Nat.reduceAdd, pow_one] at *\n  let Xgp : Subgroup G :=\n  { carrier := X\n    mul_mem' := fun {x y} hx hy ↦ by\n      norm_cast at *\n      simpa [← hXn, ← sq] using mul_mem_mul hx hy\n    one_mem' := hX₁\n    inv_mem' := fun {x} hx ↦ by\n      dsimp at *\n      norm_cast at *\n      have : x • X ⊆ X := by\n        simpa [← hXn, add_assoc, ← sq] using smul_finset_subset_mul (t := X) hx\n      have : x • X = X := eq_of_subset_of_card_le this (card_smul_finset ..).ge\n      rw [← eq_inv_smul_iff] at this\n      rw [this]\n      simpa [mem_inv_smul_finset_iff] }\n  exact subset_closure.antisymm <| (closure_le Xgp).2 subset_rfl\n\n"}
{"name":"Finset.nsmul_ssubset_nsmul_succ_of_nsmul_ne_closure","module":"Mathlib.Geometry.Group.Growth.LinearLowerBound","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nX : Finset G\nn : Nat\nhX₁ : Membership.mem X 0\nhX : X.Nontrivial\nhXclosure : Ne (HSMul.hSMul n ↑X) ↑(AddSubgroup.closure ↑X)\n⊢ HasSSubset.SSubset (HSMul.hSMul n X) (HSMul.hSMul (HAdd.hAdd n 1) X)","decl":"@[to_additive]\nlemma pow_ssubset_pow_succ_of_pow_ne_closure (hX₁ : (1 : G) ∈ X) (hX : X.Nontrivial)\n    (hXclosure : (X ^ n : Set G) ≠ closure (X : Set G)) : X ^ n ⊂ X ^ (n + 1) := by\n  obtain rfl | hn := eq_or_ne n 0\n  · simpa [ssubset_iff_subset_not_subset, hX₁, -Finset.subset_singleton_iff]\n      using hX.not_subset_singleton\n  refine (pow_subset_pow_right hX₁ <| n.le_add_right _).ssubset_of_ne ?_\n  contrapose! hXclosure with hXn\n  rw [← closure_pow (mod_cast hX₁) hn]\n  wlog hn₁ : n = 1\n  · simp +contextual only [pow_one] at this\n    replace hXn d : X ^ (n + d) = X ^ n := by\n      induction' d with d hd\n      · rw [add_zero]\n      · rw [pow_add, pow_one] at hXn\n        rw [← add_assoc, pow_add, pow_one, hd, ← hXn]\n    exact mod_cast this (one_mem_pow hX₁) (hX.pow hn) one_ne_zero\n      (by simp [hXn, ← pow_mul, mul_two]) (by simp [hXn, ← pow_mul, mul_two])\n  subst hn₁\n  simp only [ne_eq, one_ne_zero, not_false_eq_true, Nat.reduceAdd, pow_one] at *\n  let Xgp : Subgroup G :=\n  { carrier := X\n    mul_mem' := fun {x y} hx hy ↦ by\n      norm_cast at *\n      simpa [← hXn, ← sq] using mul_mem_mul hx hy\n    one_mem' := hX₁\n    inv_mem' := fun {x} hx ↦ by\n      dsimp at *\n      norm_cast at *\n      have : x • X ⊆ X := by\n        simpa [← hXn, add_assoc, ← sq] using smul_finset_subset_mul (t := X) hx\n      have : x • X = X := eq_of_subset_of_card_le this (card_smul_finset ..).ge\n      rw [← eq_inv_smul_iff] at this\n      rw [this]\n      simpa [mem_inv_smul_finset_iff] }\n  exact subset_closure.antisymm <| (closure_le Xgp).2 subset_rfl\n\n"}
{"name":"Finset.nsmul_right_strictMonoOn","module":"Mathlib.Geometry.Group.Growth.LinearLowerBound","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nX : Finset G\nhX₁ : Membership.mem X 0\nhX : X.Nontrivial\n⊢ StrictMonoOn (fun n => HSMul.hSMul n X) (setOf fun n => Ne (HSMul.hSMul (HSub.hSub n 1) ↑X) ↑(AddSubgroup.closure ↑X))","decl":"@[to_additive]\nlemma pow_right_strictMonoOn (hX₁ : 1 ∈ X) (hX : X.Nontrivial) :\n    StrictMonoOn (fun n ↦ X ^ n) {n | (X ^ (n - 1) : Set G) ≠ closure (X : Set G)} := by\n  refine strictMonoOn_of_lt_add_one ⟨?_⟩ fun n _ _ hn ↦\n    pow_ssubset_pow_succ_of_pow_ne_closure hX₁ hX hn\n  rintro - - n hn m ⟨-, hmn⟩ hm\n  apply hn\n  obtain rfl | hm₀ := m.eq_zero_or_pos\n  · simp [eq_comm (a := (1 : Set _)), coe_set_eq_one, -Set.subset_singleton_iff,\n      hX.coe.not_subset_singleton] at hm\n  · calc (X : Set G) ^ (n - 1)\n    _ = X ^ (n - m) * X ^ (m - 1) := by rw [← pow_add]; congr 1; omega\n    _ = closure (X : Set G) := by rw [hm, Set.pow_mul_subgroupClosure hX.nonempty.to_set]\n\n"}
{"name":"Finset.pow_right_strictMonoOn","module":"Mathlib.Geometry.Group.Growth.LinearLowerBound","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nX : Finset G\nhX₁ : Membership.mem X 1\nhX : X.Nontrivial\n⊢ StrictMonoOn (fun n => HPow.hPow X n) (setOf fun n => Ne (HPow.hPow (↑X) (HSub.hSub n 1)) ↑(Subgroup.closure ↑X))","decl":"@[to_additive]\nlemma pow_right_strictMonoOn (hX₁ : 1 ∈ X) (hX : X.Nontrivial) :\n    StrictMonoOn (fun n ↦ X ^ n) {n | (X ^ (n - 1) : Set G) ≠ closure (X : Set G)} := by\n  refine strictMonoOn_of_lt_add_one ⟨?_⟩ fun n _ _ hn ↦\n    pow_ssubset_pow_succ_of_pow_ne_closure hX₁ hX hn\n  rintro - - n hn m ⟨-, hmn⟩ hm\n  apply hn\n  obtain rfl | hm₀ := m.eq_zero_or_pos\n  · simp [eq_comm (a := (1 : Set _)), coe_set_eq_one, -Set.subset_singleton_iff,\n      hX.coe.not_subset_singleton] at hm\n  · calc (X : Set G) ^ (n - 1)\n    _ = X ^ (n - m) * X ^ (m - 1) := by rw [← pow_add]; congr 1; omega\n    _ = closure (X : Set G) := by rw [hm, Set.pow_mul_subgroupClosure hX.nonempty.to_set]\n\n"}
{"name":"Finset.nsmul_right_strictMono","module":"Mathlib.Geometry.Group.Growth.LinearLowerBound","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nX : Finset G\nhX₁ : Membership.mem X 0\nhXclosure : (↑(AddSubgroup.closure ↑X)).Infinite\n⊢ StrictMono fun n => HSMul.hSMul n X","decl":"@[to_additive]\nlemma pow_right_strictMono (hX₁ : 1 ∈ X) (hXclosure : (closure (X : Set G) : Set G).Infinite) :\n    StrictMono fun n ↦ X ^ n := by\n  obtain rfl | hX := eq_singleton_or_nontrivial hX₁\n  · simp [closure_singleton_one] at hXclosure\n  have h n : (X ^ (n - 1) : Set G) ≠ closure (X : Set G) :=\n    fun h ↦ by simp [← h, ← coe_pow] at hXclosure\n  simpa [h] using pow_right_strictMonoOn hX₁ hX\n\n"}
{"name":"Finset.pow_right_strictMono","module":"Mathlib.Geometry.Group.Growth.LinearLowerBound","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nX : Finset G\nhX₁ : Membership.mem X 1\nhXclosure : (↑(Subgroup.closure ↑X)).Infinite\n⊢ StrictMono fun n => HPow.hPow X n","decl":"@[to_additive]\nlemma pow_right_strictMono (hX₁ : 1 ∈ X) (hXclosure : (closure (X : Set G) : Set G).Infinite) :\n    StrictMono fun n ↦ X ^ n := by\n  obtain rfl | hX := eq_singleton_or_nontrivial hX₁\n  · simp [closure_singleton_one] at hXclosure\n  have h n : (X ^ (n - 1) : Set G) ≠ closure (X : Set G) :=\n    fun h ↦ by simp [← h, ← coe_pow] at hXclosure\n  simpa [h] using pow_right_strictMonoOn hX₁ hX\n\n"}
{"name":"Finset.add_nonneg_card_nsmul","module":"Mathlib.Geometry.Group.Growth.LinearLowerBound","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nX : Finset G\nhX₁ : Membership.mem X 0\nhXclosure : (↑(AddSubgroup.closure ↑X)).Infinite\nn : Nat\n⊢ LE.le (HAdd.hAdd n 1) (HSMul.hSMul n X).card","decl":"/-- The growth of a set generating an infinite group is at least linear. -/\n@[to_additive \"The growth of a set generating an infinite group is at least linear.\"]\nlemma add_one_le_card_pow (hX₁ : 1 ∈ X) (hXclosure : (closure (X : Set G) : Set G).Infinite) :\n    ∀ n, n + 1 ≤ #(X ^ n)\n  | 0 => by simp\n  | n + 1 => (add_one_le_card_pow hX₁ hXclosure _).trans_lt <| card_lt_card <|\n      pow_right_strictMono hX₁ (by simp [hXclosure, Set.infinite_univ]) n.lt_succ_self\n\n"}
{"name":"Finset.add_one_le_card_pow","module":"Mathlib.Geometry.Group.Growth.LinearLowerBound","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nX : Finset G\nhX₁ : Membership.mem X 1\nhXclosure : (↑(Subgroup.closure ↑X)).Infinite\nn : Nat\n⊢ LE.le (HAdd.hAdd n 1) (HPow.hPow X n).card","decl":"/-- The growth of a set generating an infinite group is at least linear. -/\n@[to_additive \"The growth of a set generating an infinite group is at least linear.\"]\nlemma add_one_le_card_pow (hX₁ : 1 ∈ X) (hXclosure : (closure (X : Set G) : Set G).Infinite) :\n    ∀ n, n + 1 ≤ #(X ^ n)\n  | 0 => by simp\n  | n + 1 => (add_one_le_card_pow hX₁ hXclosure _).trans_lt <| card_lt_card <|\n      pow_right_strictMono hX₁ (by simp [hXclosure, Set.infinite_univ]) n.lt_succ_self\n\n"}
