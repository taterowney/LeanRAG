{"name":"Set.Bounded.mono","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\nr : α → α → Prop\ns t : Set α\nhst : HasSubset.Subset s t\nhs : Set.Bounded r t\n⊢ Set.Bounded r s","decl":"theorem Bounded.mono (hst : s ⊆ t) (hs : Bounded r t) : Bounded r s :=\n  hs.imp fun _ ha b hb => ha b (hst hb)\n\n"}
{"name":"Set.Unbounded.mono","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\nr : α → α → Prop\ns t : Set α\nhst : HasSubset.Subset s t\nhs : Set.Unbounded r s\n⊢ Set.Unbounded r t","decl":"theorem Unbounded.mono (hst : s ⊆ t) (hs : Unbounded r s) : Unbounded r t := fun a =>\n  let ⟨b, hb, hb'⟩ := hs a\n  ⟨b, hst hb, hb'⟩\n\n"}
{"name":"Set.unbounded_le_of_forall_exists_lt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\nh : ∀ (a : α), Exists fun b => And (Membership.mem s b) (LT.lt a b)\n⊢ Set.Unbounded (fun x1 x2 => LE.le x1 x2) s","decl":"theorem unbounded_le_of_forall_exists_lt [Preorder α] (h : ∀ a, ∃ b ∈ s, a < b) :\n    Unbounded (· ≤ ·) s := fun a =>\n  let ⟨b, hb, hb'⟩ := h a\n  ⟨b, hb, fun hba => hba.not_lt hb'⟩\n\n"}
{"name":"Set.unbounded_le_iff","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\n⊢ Iff (Set.Unbounded (fun x1 x2 => LE.le x1 x2) s) (∀ (a : α), Exists fun b => And (Membership.mem s b) (LT.lt a b))","decl":"theorem unbounded_le_iff [LinearOrder α] : Unbounded (· ≤ ·) s ↔ ∀ a, ∃ b ∈ s, a < b := by\n  simp only [Unbounded, not_le]\n\n"}
{"name":"Set.unbounded_lt_of_forall_exists_le","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\nh : ∀ (a : α), Exists fun b => And (Membership.mem s b) (LE.le a b)\n⊢ Set.Unbounded (fun x1 x2 => LT.lt x1 x2) s","decl":"theorem unbounded_lt_of_forall_exists_le [Preorder α] (h : ∀ a, ∃ b ∈ s, a ≤ b) :\n    Unbounded (· < ·) s := fun a =>\n  let ⟨b, hb, hb'⟩ := h a\n  ⟨b, hb, fun hba => hba.not_le hb'⟩\n\n"}
{"name":"Set.unbounded_lt_iff","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\n⊢ Iff (Set.Unbounded (fun x1 x2 => LT.lt x1 x2) s) (∀ (a : α), Exists fun b => And (Membership.mem s b) (LE.le a b))","decl":"theorem unbounded_lt_iff [LinearOrder α] : Unbounded (· < ·) s ↔ ∀ a, ∃ b ∈ s, a ≤ b := by\n  simp only [Unbounded, not_lt]\n\n"}
{"name":"Set.unbounded_ge_of_forall_exists_gt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\nh : ∀ (a : α), Exists fun b => And (Membership.mem s b) (LT.lt b a)\n⊢ Set.Unbounded (fun x1 x2 => GE.ge x1 x2) s","decl":"theorem unbounded_ge_of_forall_exists_gt [Preorder α] (h : ∀ a, ∃ b ∈ s, b < a) :\n    Unbounded (· ≥ ·) s :=\n  @unbounded_le_of_forall_exists_lt αᵒᵈ _ _ h\n\n"}
{"name":"Set.unbounded_ge_iff","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\n⊢ Iff (Set.Unbounded (fun x1 x2 => GE.ge x1 x2) s) (∀ (a : α), Exists fun b => And (Membership.mem s b) (LT.lt b a))","decl":"theorem unbounded_ge_iff [LinearOrder α] : Unbounded (· ≥ ·) s ↔ ∀ a, ∃ b ∈ s, b < a :=\n  ⟨fun h a =>\n    let ⟨b, hb, hba⟩ := h a\n    ⟨b, hb, lt_of_not_ge hba⟩,\n    unbounded_ge_of_forall_exists_gt⟩\n\n"}
{"name":"Set.unbounded_gt_of_forall_exists_ge","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\nh : ∀ (a : α), Exists fun b => And (Membership.mem s b) (LE.le b a)\n⊢ Set.Unbounded (fun x1 x2 => GT.gt x1 x2) s","decl":"theorem unbounded_gt_of_forall_exists_ge [Preorder α] (h : ∀ a, ∃ b ∈ s, b ≤ a) :\n    Unbounded (· > ·) s := fun a =>\n  let ⟨b, hb, hb'⟩ := h a\n  ⟨b, hb, fun hba => not_le_of_gt hba hb'⟩\n\n"}
{"name":"Set.unbounded_gt_iff","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\n⊢ Iff (Set.Unbounded (fun x1 x2 => GT.gt x1 x2) s) (∀ (a : α), Exists fun b => And (Membership.mem s b) (LE.le b a))","decl":"theorem unbounded_gt_iff [LinearOrder α] : Unbounded (· > ·) s ↔ ∀ a, ∃ b ∈ s, b ≤ a :=\n  ⟨fun h a =>\n    let ⟨b, hb, hba⟩ := h a\n    ⟨b, hb, le_of_not_gt hba⟩,\n    unbounded_gt_of_forall_exists_ge⟩\n\n"}
{"name":"Set.Bounded.rel_mono","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nr' : α → α → Prop\nh : Set.Bounded r s\nhrr' : LE.le r r'\n⊢ Set.Bounded r' s","decl":"theorem Bounded.rel_mono {r' : α → α → Prop} (h : Bounded r s) (hrr' : r ≤ r') : Bounded r' s :=\n  let ⟨a, ha⟩ := h\n  ⟨a, fun b hb => hrr' b a (ha b hb)⟩\n\n"}
{"name":"Set.bounded_le_of_bounded_lt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\nh : Set.Bounded (fun x1 x2 => LT.lt x1 x2) s\n⊢ Set.Bounded (fun x1 x2 => LE.le x1 x2) s","decl":"theorem bounded_le_of_bounded_lt [Preorder α] (h : Bounded (· < ·) s) : Bounded (· ≤ ·) s :=\n  h.rel_mono fun _ _ => le_of_lt\n\n"}
{"name":"Set.Unbounded.rel_mono","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nr' : α → α → Prop\nhr : LE.le r' r\nh : Set.Unbounded r s\n⊢ Set.Unbounded r' s","decl":"theorem Unbounded.rel_mono {r' : α → α → Prop} (hr : r' ≤ r) (h : Unbounded r s) : Unbounded r' s :=\n  fun a =>\n  let ⟨b, hb, hba⟩ := h a\n  ⟨b, hb, fun hba' => hba (hr b a hba')⟩\n\n"}
{"name":"Set.unbounded_lt_of_unbounded_le","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\nh : Set.Unbounded (fun x1 x2 => LE.le x1 x2) s\n⊢ Set.Unbounded (fun x1 x2 => LT.lt x1 x2) s","decl":"theorem unbounded_lt_of_unbounded_le [Preorder α] (h : Unbounded (· ≤ ·) s) : Unbounded (· < ·) s :=\n  h.rel_mono fun _ _ => le_of_lt\n\n"}
{"name":"Set.bounded_le_iff_bounded_lt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\n⊢ Iff (Set.Bounded (fun x1 x2 => LE.le x1 x2) s) (Set.Bounded (fun x1 x2 => LT.lt x1 x2) s)","decl":"theorem bounded_le_iff_bounded_lt [Preorder α] [NoMaxOrder α] :\n    Bounded (· ≤ ·) s ↔ Bounded (· < ·) s := by\n  refine ⟨fun h => ?_, bounded_le_of_bounded_lt⟩\n  obtain ⟨a, ha⟩ := h\n  obtain ⟨b, hb⟩ := exists_gt a\n  exact ⟨b, fun c hc => lt_of_le_of_lt (ha c hc) hb⟩\n\n"}
{"name":"Set.unbounded_lt_iff_unbounded_le","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\n⊢ Iff (Set.Unbounded (fun x1 x2 => LT.lt x1 x2) s) (Set.Unbounded (fun x1 x2 => LE.le x1 x2) s)","decl":"theorem unbounded_lt_iff_unbounded_le [Preorder α] [NoMaxOrder α] :\n    Unbounded (· < ·) s ↔ Unbounded (· ≤ ·) s := by\n  simp_rw [← not_bounded_iff, bounded_le_iff_bounded_lt]\n\n"}
{"name":"Set.bounded_ge_of_bounded_gt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\nh : Set.Bounded (fun x1 x2 => GT.gt x1 x2) s\n⊢ Set.Bounded (fun x1 x2 => GE.ge x1 x2) s","decl":"theorem bounded_ge_of_bounded_gt [Preorder α] (h : Bounded (· > ·) s) : Bounded (· ≥ ·) s :=\n  let ⟨a, ha⟩ := h\n  ⟨a, fun b hb => le_of_lt (ha b hb)⟩\n\n"}
{"name":"Set.unbounded_gt_of_unbounded_ge","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\nh : Set.Unbounded (fun x1 x2 => GE.ge x1 x2) s\n⊢ Set.Unbounded (fun x1 x2 => GT.gt x1 x2) s","decl":"theorem unbounded_gt_of_unbounded_ge [Preorder α] (h : Unbounded (· ≥ ·) s) : Unbounded (· > ·) s :=\n  fun a =>\n  let ⟨b, hb, hba⟩ := h a\n  ⟨b, hb, fun hba' => hba (le_of_lt hba')⟩\n\n"}
{"name":"Set.bounded_ge_iff_bounded_gt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\n⊢ Iff (Set.Bounded (fun x1 x2 => GE.ge x1 x2) s) (Set.Bounded (fun x1 x2 => GT.gt x1 x2) s)","decl":"theorem bounded_ge_iff_bounded_gt [Preorder α] [NoMinOrder α] :\n    Bounded (· ≥ ·) s ↔ Bounded (· > ·) s :=\n  @bounded_le_iff_bounded_lt αᵒᵈ _ _ _\n\n"}
{"name":"Set.unbounded_gt_iff_unbounded_ge","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\n⊢ Iff (Set.Unbounded (fun x1 x2 => GT.gt x1 x2) s) (Set.Unbounded (fun x1 x2 => GE.ge x1 x2) s)","decl":"theorem unbounded_gt_iff_unbounded_ge [Preorder α] [NoMinOrder α] :\n    Unbounded (· > ·) s ↔ Unbounded (· ≥ ·) s :=\n  @unbounded_lt_iff_unbounded_le αᵒᵈ _ _ _\n\n"}
{"name":"Set.unbounded_le_univ","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : NoTopOrder α\n⊢ Set.Unbounded (fun x1 x2 => LE.le x1 x2) Set.univ","decl":"theorem unbounded_le_univ [LE α] [NoTopOrder α] : Unbounded (· ≤ ·) (@Set.univ α) := fun a =>\n  let ⟨b, hb⟩ := exists_not_le a\n  ⟨b, ⟨⟩, hb⟩\n\n"}
{"name":"Set.unbounded_lt_univ","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoTopOrder α\n⊢ Set.Unbounded (fun x1 x2 => LT.lt x1 x2) Set.univ","decl":"theorem unbounded_lt_univ [Preorder α] [NoTopOrder α] : Unbounded (· < ·) (@Set.univ α) :=\n  unbounded_lt_of_unbounded_le unbounded_le_univ\n\n"}
{"name":"Set.unbounded_ge_univ","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : NoBotOrder α\n⊢ Set.Unbounded (fun x1 x2 => GE.ge x1 x2) Set.univ","decl":"theorem unbounded_ge_univ [LE α] [NoBotOrder α] : Unbounded (· ≥ ·) (@Set.univ α) := fun a =>\n  let ⟨b, hb⟩ := exists_not_ge a\n  ⟨b, ⟨⟩, hb⟩\n\n"}
{"name":"Set.unbounded_gt_univ","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoBotOrder α\n⊢ Set.Unbounded (fun x1 x2 => GT.gt x1 x2) Set.univ","decl":"theorem unbounded_gt_univ [Preorder α] [NoBotOrder α] : Unbounded (· > ·) (@Set.univ α) :=\n  unbounded_gt_of_unbounded_ge unbounded_ge_univ\n\n"}
{"name":"Set.bounded_self","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\nr : α → α → Prop\na : α\n⊢ Set.Bounded r (setOf fun b => r b a)","decl":"theorem bounded_self (a : α) : Bounded r { b | r b a } :=\n  ⟨a, fun _ => id⟩\n\n"}
{"name":"Set.bounded_lt_Iio","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Set.Bounded (fun x1 x2 => LT.lt x1 x2) (Set.Iio a)","decl":"theorem bounded_lt_Iio [Preorder α] (a : α) : Bounded (· < ·) (Iio a) :=\n  bounded_self a\n\n"}
{"name":"Set.bounded_le_Iio","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Set.Bounded (fun x1 x2 => LE.le x1 x2) (Set.Iio a)","decl":"theorem bounded_le_Iio [Preorder α] (a : α) : Bounded (· ≤ ·) (Iio a) :=\n  bounded_le_of_bounded_lt (bounded_lt_Iio a)\n\n"}
{"name":"Set.bounded_le_Iic","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Set.Bounded (fun x1 x2 => LE.le x1 x2) (Set.Iic a)","decl":"theorem bounded_le_Iic [Preorder α] (a : α) : Bounded (· ≤ ·) (Iic a) :=\n  bounded_self a\n\n"}
{"name":"Set.bounded_lt_Iic","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Set.Bounded (fun x1 x2 => LT.lt x1 x2) (Set.Iic a)","decl":"theorem bounded_lt_Iic [Preorder α] [NoMaxOrder α] (a : α) : Bounded (· < ·) (Iic a) := by\n  simp only [← bounded_le_iff_bounded_lt, bounded_le_Iic]\n\n"}
{"name":"Set.bounded_gt_Ioi","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Set.Bounded (fun x1 x2 => GT.gt x1 x2) (Set.Ioi a)","decl":"theorem bounded_gt_Ioi [Preorder α] (a : α) : Bounded (· > ·) (Ioi a) :=\n  bounded_self a\n\n"}
{"name":"Set.bounded_ge_Ioi","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Set.Bounded (fun x1 x2 => GE.ge x1 x2) (Set.Ioi a)","decl":"theorem bounded_ge_Ioi [Preorder α] (a : α) : Bounded (· ≥ ·) (Ioi a) :=\n  bounded_ge_of_bounded_gt (bounded_gt_Ioi a)\n\n"}
{"name":"Set.bounded_ge_Ici","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Set.Bounded (fun x1 x2 => GE.ge x1 x2) (Set.Ici a)","decl":"theorem bounded_ge_Ici [Preorder α] (a : α) : Bounded (· ≥ ·) (Ici a) :=\n  bounded_self a\n\n"}
{"name":"Set.bounded_gt_Ici","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\na : α\n⊢ Set.Bounded (fun x1 x2 => GT.gt x1 x2) (Set.Ici a)","decl":"theorem bounded_gt_Ici [Preorder α] [NoMinOrder α] (a : α) : Bounded (· > ·) (Ici a) := by\n  simp only [← bounded_ge_iff_bounded_gt, bounded_ge_Ici]\n\n"}
{"name":"Set.bounded_lt_Ioo","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => LT.lt x1 x2) (Set.Ioo a b)","decl":"theorem bounded_lt_Ioo [Preorder α] (a b : α) : Bounded (· < ·) (Ioo a b) :=\n  (bounded_lt_Iio b).mono Set.Ioo_subset_Iio_self\n\n"}
{"name":"Set.bounded_lt_Ico","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => LT.lt x1 x2) (Set.Ico a b)","decl":"theorem bounded_lt_Ico [Preorder α] (a b : α) : Bounded (· < ·) (Ico a b) :=\n  (bounded_lt_Iio b).mono Set.Ico_subset_Iio_self\n\n"}
{"name":"Set.bounded_lt_Ioc","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => LT.lt x1 x2) (Set.Ioc a b)","decl":"theorem bounded_lt_Ioc [Preorder α] [NoMaxOrder α] (a b : α) : Bounded (· < ·) (Ioc a b) :=\n  (bounded_lt_Iic b).mono Set.Ioc_subset_Iic_self\n\n"}
{"name":"Set.bounded_lt_Icc","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => LT.lt x1 x2) (Set.Icc a b)","decl":"theorem bounded_lt_Icc [Preorder α] [NoMaxOrder α] (a b : α) : Bounded (· < ·) (Icc a b) :=\n  (bounded_lt_Iic b).mono Set.Icc_subset_Iic_self\n\n"}
{"name":"Set.bounded_le_Ioo","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => LE.le x1 x2) (Set.Ioo a b)","decl":"theorem bounded_le_Ioo [Preorder α] (a b : α) : Bounded (· ≤ ·) (Ioo a b) :=\n  (bounded_le_Iio b).mono Set.Ioo_subset_Iio_self\n\n"}
{"name":"Set.bounded_le_Ico","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => LE.le x1 x2) (Set.Ico a b)","decl":"theorem bounded_le_Ico [Preorder α] (a b : α) : Bounded (· ≤ ·) (Ico a b) :=\n  (bounded_le_Iio b).mono Set.Ico_subset_Iio_self\n\n"}
{"name":"Set.bounded_le_Ioc","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => LE.le x1 x2) (Set.Ioc a b)","decl":"theorem bounded_le_Ioc [Preorder α] (a b : α) : Bounded (· ≤ ·) (Ioc a b) :=\n  (bounded_le_Iic b).mono Set.Ioc_subset_Iic_self\n\n"}
{"name":"Set.bounded_le_Icc","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => LE.le x1 x2) (Set.Icc a b)","decl":"theorem bounded_le_Icc [Preorder α] (a b : α) : Bounded (· ≤ ·) (Icc a b) :=\n  (bounded_le_Iic b).mono Set.Icc_subset_Iic_self\n\n"}
{"name":"Set.bounded_gt_Ioo","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => GT.gt x1 x2) (Set.Ioo a b)","decl":"theorem bounded_gt_Ioo [Preorder α] (a b : α) : Bounded (· > ·) (Ioo a b) :=\n  (bounded_gt_Ioi a).mono Set.Ioo_subset_Ioi_self\n\n"}
{"name":"Set.bounded_gt_Ioc","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => GT.gt x1 x2) (Set.Ioc a b)","decl":"theorem bounded_gt_Ioc [Preorder α] (a b : α) : Bounded (· > ·) (Ioc a b) :=\n  (bounded_gt_Ioi a).mono Set.Ioc_subset_Ioi_self\n\n"}
{"name":"Set.bounded_gt_Ico","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => GT.gt x1 x2) (Set.Ico a b)","decl":"theorem bounded_gt_Ico [Preorder α] [NoMinOrder α] (a b : α) : Bounded (· > ·) (Ico a b) :=\n  (bounded_gt_Ici a).mono Set.Ico_subset_Ici_self\n\n"}
{"name":"Set.bounded_gt_Icc","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => GT.gt x1 x2) (Set.Icc a b)","decl":"theorem bounded_gt_Icc [Preorder α] [NoMinOrder α] (a b : α) : Bounded (· > ·) (Icc a b) :=\n  (bounded_gt_Ici a).mono Set.Icc_subset_Ici_self\n\n"}
{"name":"Set.bounded_ge_Ioo","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => GE.ge x1 x2) (Set.Ioo a b)","decl":"theorem bounded_ge_Ioo [Preorder α] (a b : α) : Bounded (· ≥ ·) (Ioo a b) :=\n  (bounded_ge_Ioi a).mono Set.Ioo_subset_Ioi_self\n\n"}
{"name":"Set.bounded_ge_Ioc","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => GE.ge x1 x2) (Set.Ioc a b)","decl":"theorem bounded_ge_Ioc [Preorder α] (a b : α) : Bounded (· ≥ ·) (Ioc a b) :=\n  (bounded_ge_Ioi a).mono Set.Ioc_subset_Ioi_self\n\n"}
{"name":"Set.bounded_ge_Ico","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => GE.ge x1 x2) (Set.Ico a b)","decl":"theorem bounded_ge_Ico [Preorder α] (a b : α) : Bounded (· ≥ ·) (Ico a b) :=\n  (bounded_ge_Ici a).mono Set.Ico_subset_Ici_self\n\n"}
{"name":"Set.bounded_ge_Icc","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Set.Bounded (fun x1 x2 => GE.ge x1 x2) (Set.Icc a b)","decl":"theorem bounded_ge_Icc [Preorder α] (a b : α) : Bounded (· ≥ ·) (Icc a b) :=\n  (bounded_ge_Ici a).mono Set.Icc_subset_Ici_self\n\n"}
{"name":"Set.unbounded_le_Ioi","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeSup α\ninst✝ : NoMaxOrder α\na : α\n⊢ Set.Unbounded (fun x1 x2 => LE.le x1 x2) (Set.Ioi a)","decl":"theorem unbounded_le_Ioi [SemilatticeSup α] [NoMaxOrder α] (a : α) :\n    Unbounded (· ≤ ·) (Ioi a) := fun b =>\n  let ⟨c, hc⟩ := exists_gt (a ⊔ b)\n  ⟨c, le_sup_left.trans_lt hc, (le_sup_right.trans_lt hc).not_le⟩\n\n"}
{"name":"Set.unbounded_le_Ici","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeSup α\ninst✝ : NoMaxOrder α\na : α\n⊢ Set.Unbounded (fun x1 x2 => LE.le x1 x2) (Set.Ici a)","decl":"theorem unbounded_le_Ici [SemilatticeSup α] [NoMaxOrder α] (a : α) :\n    Unbounded (· ≤ ·) (Ici a) :=\n  (unbounded_le_Ioi a).mono Set.Ioi_subset_Ici_self\n\n"}
{"name":"Set.unbounded_lt_Ioi","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeSup α\ninst✝ : NoMaxOrder α\na : α\n⊢ Set.Unbounded (fun x1 x2 => LT.lt x1 x2) (Set.Ioi a)","decl":"theorem unbounded_lt_Ioi [SemilatticeSup α] [NoMaxOrder α] (a : α) :\n    Unbounded (· < ·) (Ioi a) :=\n  unbounded_lt_of_unbounded_le (unbounded_le_Ioi a)\n\n"}
{"name":"Set.unbounded_lt_Ici","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\na : α\n⊢ Set.Unbounded (fun x1 x2 => LT.lt x1 x2) (Set.Ici a)","decl":"theorem unbounded_lt_Ici [SemilatticeSup α] (a : α) : Unbounded (· < ·) (Ici a) := fun b =>\n  ⟨a ⊔ b, le_sup_left, le_sup_right.not_lt⟩\n\n"}
{"name":"Set.bounded_inter_not","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nH : ∀ (a b : α), Exists fun m => ∀ (c : α), Or (r c a) (r c b) → r c m\na : α\n⊢ Iff (Set.Bounded r (Inter.inter s (setOf fun b => Not (r b a)))) (Set.Bounded r s)","decl":"theorem bounded_inter_not (H : ∀ a b, ∃ m, ∀ c, r c a ∨ r c b → r c m) (a : α) :\n    Bounded r (s ∩ { b | ¬r b a }) ↔ Bounded r s := by\n  refine ⟨?_, Bounded.mono inter_subset_left⟩\n  rintro ⟨b, hb⟩\n  obtain ⟨m, hm⟩ := H a b\n  exact ⟨m, fun c hc => hm c (or_iff_not_imp_left.2 fun hca => hb c ⟨hc, hca⟩)⟩\n\n"}
{"name":"Set.unbounded_inter_not","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nH : ∀ (a b : α), Exists fun m => ∀ (c : α), Or (r c a) (r c b) → r c m\na : α\n⊢ Iff (Set.Unbounded r (Inter.inter s (setOf fun b => Not (r b a)))) (Set.Unbounded r s)","decl":"theorem unbounded_inter_not (H : ∀ a b, ∃ m, ∀ c, r c a ∨ r c b → r c m) (a : α) :\n    Unbounded r (s ∩ { b | ¬r b a }) ↔ Unbounded r s := by\n  simp_rw [← not_bounded_iff, bounded_inter_not H]\n\n"}
{"name":"Set.bounded_le_inter_not_le","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : SemilatticeSup α\na : α\n⊢ Iff (Set.Bounded (fun x1 x2 => LE.le x1 x2) (Inter.inter s (setOf fun b => Not (LE.le b a)))) (Set.Bounded (fun x1 x2 => LE.le x1 x2) s)","decl":"theorem bounded_le_inter_not_le [SemilatticeSup α] (a : α) :\n    Bounded (· ≤ ·) (s ∩ { b | ¬b ≤ a }) ↔ Bounded (· ≤ ·) s :=\n  bounded_inter_not (fun x y => ⟨x ⊔ y, fun _ h => h.elim le_sup_of_le_left le_sup_of_le_right⟩) a\n\n"}
{"name":"Set.unbounded_le_inter_not_le","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : SemilatticeSup α\na : α\n⊢ Iff (Set.Unbounded (fun x1 x2 => LE.le x1 x2) (Inter.inter s (setOf fun b => Not (LE.le b a)))) (Set.Unbounded (fun x1 x2 => LE.le x1 x2) s)","decl":"theorem unbounded_le_inter_not_le [SemilatticeSup α] (a : α) :\n    Unbounded (· ≤ ·) (s ∩ { b | ¬b ≤ a }) ↔ Unbounded (· ≤ ·) s := by\n  rw [← not_bounded_iff, ← not_bounded_iff, not_iff_not]\n  exact bounded_le_inter_not_le a\n\n"}
{"name":"Set.bounded_le_inter_lt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Set.Bounded (fun x1 x2 => LE.le x1 x2) (Inter.inter s (setOf fun b => LT.lt a b))) (Set.Bounded (fun x1 x2 => LE.le x1 x2) s)","decl":"theorem bounded_le_inter_lt [LinearOrder α] (a : α) :\n    Bounded (· ≤ ·) (s ∩ { b | a < b }) ↔ Bounded (· ≤ ·) s := by\n  simp_rw [← not_le, bounded_le_inter_not_le]\n\n"}
{"name":"Set.unbounded_le_inter_lt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Set.Unbounded (fun x1 x2 => LE.le x1 x2) (Inter.inter s (setOf fun b => LT.lt a b))) (Set.Unbounded (fun x1 x2 => LE.le x1 x2) s)","decl":"theorem unbounded_le_inter_lt [LinearOrder α] (a : α) :\n    Unbounded (· ≤ ·) (s ∩ { b | a < b }) ↔ Unbounded (· ≤ ·) s := by\n  convert @unbounded_le_inter_not_le _ s _ a\n  exact lt_iff_not_le\n\n"}
{"name":"Set.bounded_le_inter_le","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Set.Bounded (fun x1 x2 => LE.le x1 x2) (Inter.inter s (setOf fun b => LE.le a b))) (Set.Bounded (fun x1 x2 => LE.le x1 x2) s)","decl":"theorem bounded_le_inter_le [LinearOrder α] (a : α) :\n    Bounded (· ≤ ·) (s ∩ { b | a ≤ b }) ↔ Bounded (· ≤ ·) s := by\n  refine ⟨?_, Bounded.mono Set.inter_subset_left⟩\n  rw [← @bounded_le_inter_lt _ s _ a]\n  exact Bounded.mono fun x ⟨hx, hx'⟩ => ⟨hx, le_of_lt hx'⟩\n\n"}
{"name":"Set.unbounded_le_inter_le","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Set.Unbounded (fun x1 x2 => LE.le x1 x2) (Inter.inter s (setOf fun b => LE.le a b))) (Set.Unbounded (fun x1 x2 => LE.le x1 x2) s)","decl":"theorem unbounded_le_inter_le [LinearOrder α] (a : α) :\n    Unbounded (· ≤ ·) (s ∩ { b | a ≤ b }) ↔ Unbounded (· ≤ ·) s := by\n  rw [← not_bounded_iff, ← not_bounded_iff, not_iff_not]\n  exact bounded_le_inter_le a\n\n"}
{"name":"Set.bounded_lt_inter_not_lt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : SemilatticeSup α\na : α\n⊢ Iff (Set.Bounded (fun x1 x2 => LT.lt x1 x2) (Inter.inter s (setOf fun b => Not (LT.lt b a)))) (Set.Bounded (fun x1 x2 => LT.lt x1 x2) s)","decl":"theorem bounded_lt_inter_not_lt [SemilatticeSup α] (a : α) :\n    Bounded (· < ·) (s ∩ { b | ¬b < a }) ↔ Bounded (· < ·) s :=\n  bounded_inter_not (fun x y => ⟨x ⊔ y, fun _ h => h.elim lt_sup_of_lt_left lt_sup_of_lt_right⟩) a\n\n"}
{"name":"Set.unbounded_lt_inter_not_lt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : SemilatticeSup α\na : α\n⊢ Iff (Set.Unbounded (fun x1 x2 => LT.lt x1 x2) (Inter.inter s (setOf fun b => Not (LT.lt b a)))) (Set.Unbounded (fun x1 x2 => LT.lt x1 x2) s)","decl":"theorem unbounded_lt_inter_not_lt [SemilatticeSup α] (a : α) :\n    Unbounded (· < ·) (s ∩ { b | ¬b < a }) ↔ Unbounded (· < ·) s := by\n  rw [← not_bounded_iff, ← not_bounded_iff, not_iff_not]\n  exact bounded_lt_inter_not_lt a\n\n"}
{"name":"Set.bounded_lt_inter_le","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Set.Bounded (fun x1 x2 => LT.lt x1 x2) (Inter.inter s (setOf fun b => LE.le a b))) (Set.Bounded (fun x1 x2 => LT.lt x1 x2) s)","decl":"theorem bounded_lt_inter_le [LinearOrder α] (a : α) :\n    Bounded (· < ·) (s ∩ { b | a ≤ b }) ↔ Bounded (· < ·) s := by\n  convert @bounded_lt_inter_not_lt _ s _ a\n  exact not_lt.symm\n\n"}
{"name":"Set.unbounded_lt_inter_le","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Set.Unbounded (fun x1 x2 => LT.lt x1 x2) (Inter.inter s (setOf fun b => LE.le a b))) (Set.Unbounded (fun x1 x2 => LT.lt x1 x2) s)","decl":"theorem unbounded_lt_inter_le [LinearOrder α] (a : α) :\n    Unbounded (· < ·) (s ∩ { b | a ≤ b }) ↔ Unbounded (· < ·) s := by\n  convert @unbounded_lt_inter_not_lt _ s _ a\n  exact not_lt.symm\n\n"}
{"name":"Set.bounded_lt_inter_lt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : LinearOrder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Iff (Set.Bounded (fun x1 x2 => LT.lt x1 x2) (Inter.inter s (setOf fun b => LT.lt a b))) (Set.Bounded (fun x1 x2 => LT.lt x1 x2) s)","decl":"theorem bounded_lt_inter_lt [LinearOrder α] [NoMaxOrder α] (a : α) :\n    Bounded (· < ·) (s ∩ { b | a < b }) ↔ Bounded (· < ·) s := by\n  rw [← bounded_le_iff_bounded_lt, ← bounded_le_iff_bounded_lt]\n  exact bounded_le_inter_lt a\n\n"}
{"name":"Set.unbounded_lt_inter_lt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : LinearOrder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Iff (Set.Unbounded (fun x1 x2 => LT.lt x1 x2) (Inter.inter s (setOf fun b => LT.lt a b))) (Set.Unbounded (fun x1 x2 => LT.lt x1 x2) s)","decl":"theorem unbounded_lt_inter_lt [LinearOrder α] [NoMaxOrder α] (a : α) :\n    Unbounded (· < ·) (s ∩ { b | a < b }) ↔ Unbounded (· < ·) s := by\n  rw [← not_bounded_iff, ← not_bounded_iff, not_iff_not]\n  exact bounded_lt_inter_lt a\n\n"}
{"name":"Set.bounded_ge_inter_not_ge","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : SemilatticeInf α\na : α\n⊢ Iff (Set.Bounded (fun x1 x2 => GE.ge x1 x2) (Inter.inter s (setOf fun b => Not (LE.le a b)))) (Set.Bounded (fun x1 x2 => GE.ge x1 x2) s)","decl":"theorem bounded_ge_inter_not_ge [SemilatticeInf α] (a : α) :\n    Bounded (· ≥ ·) (s ∩ { b | ¬a ≤ b }) ↔ Bounded (· ≥ ·) s :=\n  @bounded_le_inter_not_le αᵒᵈ s _ a\n\n"}
{"name":"Set.unbounded_ge_inter_not_ge","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : SemilatticeInf α\na : α\n⊢ Iff (Set.Unbounded (fun x1 x2 => GE.ge x1 x2) (Inter.inter s (setOf fun b => Not (LE.le a b)))) (Set.Unbounded (fun x1 x2 => GE.ge x1 x2) s)","decl":"theorem unbounded_ge_inter_not_ge [SemilatticeInf α] (a : α) :\n    Unbounded (· ≥ ·) (s ∩ { b | ¬a ≤ b }) ↔ Unbounded (· ≥ ·) s :=\n  @unbounded_le_inter_not_le αᵒᵈ s _ a\n\n"}
{"name":"Set.bounded_ge_inter_gt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Set.Bounded (fun x1 x2 => GE.ge x1 x2) (Inter.inter s (setOf fun b => LT.lt b a))) (Set.Bounded (fun x1 x2 => GE.ge x1 x2) s)","decl":"theorem bounded_ge_inter_gt [LinearOrder α] (a : α) :\n    Bounded (· ≥ ·) (s ∩ { b | b < a }) ↔ Bounded (· ≥ ·) s :=\n  @bounded_le_inter_lt αᵒᵈ s _ a\n\n"}
{"name":"Set.unbounded_ge_inter_gt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Set.Unbounded (fun x1 x2 => GE.ge x1 x2) (Inter.inter s (setOf fun b => LT.lt b a))) (Set.Unbounded (fun x1 x2 => GE.ge x1 x2) s)","decl":"theorem unbounded_ge_inter_gt [LinearOrder α] (a : α) :\n    Unbounded (· ≥ ·) (s ∩ { b | b < a }) ↔ Unbounded (· ≥ ·) s :=\n  @unbounded_le_inter_lt αᵒᵈ s _ a\n\n"}
{"name":"Set.bounded_ge_inter_ge","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Set.Bounded (fun x1 x2 => GE.ge x1 x2) (Inter.inter s (setOf fun b => LE.le b a))) (Set.Bounded (fun x1 x2 => GE.ge x1 x2) s)","decl":"theorem bounded_ge_inter_ge [LinearOrder α] (a : α) :\n    Bounded (· ≥ ·) (s ∩ { b | b ≤ a }) ↔ Bounded (· ≥ ·) s :=\n  @bounded_le_inter_le αᵒᵈ s _ a\n\n"}
{"name":"Set.unbounded_ge_iff_unbounded_inter_ge","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Set.Unbounded (fun x1 x2 => GE.ge x1 x2) (Inter.inter s (setOf fun b => LE.le b a))) (Set.Unbounded (fun x1 x2 => GE.ge x1 x2) s)","decl":"theorem unbounded_ge_iff_unbounded_inter_ge [LinearOrder α] (a : α) :\n    Unbounded (· ≥ ·) (s ∩ { b | b ≤ a }) ↔ Unbounded (· ≥ ·) s :=\n  @unbounded_le_inter_le αᵒᵈ s _ a\n\n"}
{"name":"Set.bounded_gt_inter_not_gt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : SemilatticeInf α\na : α\n⊢ Iff (Set.Bounded (fun x1 x2 => GT.gt x1 x2) (Inter.inter s (setOf fun b => Not (LT.lt a b)))) (Set.Bounded (fun x1 x2 => GT.gt x1 x2) s)","decl":"theorem bounded_gt_inter_not_gt [SemilatticeInf α] (a : α) :\n    Bounded (· > ·) (s ∩ { b | ¬a < b }) ↔ Bounded (· > ·) s :=\n  @bounded_lt_inter_not_lt αᵒᵈ s _ a\n\n"}
{"name":"Set.unbounded_gt_inter_not_gt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : SemilatticeInf α\na : α\n⊢ Iff (Set.Unbounded (fun x1 x2 => GT.gt x1 x2) (Inter.inter s (setOf fun b => Not (LT.lt a b)))) (Set.Unbounded (fun x1 x2 => GT.gt x1 x2) s)","decl":"theorem unbounded_gt_inter_not_gt [SemilatticeInf α] (a : α) :\n    Unbounded (· > ·) (s ∩ { b | ¬a < b }) ↔ Unbounded (· > ·) s :=\n  @unbounded_lt_inter_not_lt αᵒᵈ s _ a\n\n"}
{"name":"Set.bounded_gt_inter_ge","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Set.Bounded (fun x1 x2 => GT.gt x1 x2) (Inter.inter s (setOf fun b => LE.le b a))) (Set.Bounded (fun x1 x2 => GT.gt x1 x2) s)","decl":"theorem bounded_gt_inter_ge [LinearOrder α] (a : α) :\n    Bounded (· > ·) (s ∩ { b | b ≤ a }) ↔ Bounded (· > ·) s :=\n  @bounded_lt_inter_le αᵒᵈ s _ a\n\n"}
{"name":"Set.unbounded_inter_ge","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Set.Unbounded (fun x1 x2 => GT.gt x1 x2) (Inter.inter s (setOf fun b => LE.le b a))) (Set.Unbounded (fun x1 x2 => GT.gt x1 x2) s)","decl":"theorem unbounded_inter_ge [LinearOrder α] (a : α) :\n    Unbounded (· > ·) (s ∩ { b | b ≤ a }) ↔ Unbounded (· > ·) s :=\n  @unbounded_lt_inter_le αᵒᵈ s _ a\n\n"}
{"name":"Set.bounded_gt_inter_gt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : LinearOrder α\ninst✝ : NoMinOrder α\na : α\n⊢ Iff (Set.Bounded (fun x1 x2 => GT.gt x1 x2) (Inter.inter s (setOf fun b => LT.lt b a))) (Set.Bounded (fun x1 x2 => GT.gt x1 x2) s)","decl":"theorem bounded_gt_inter_gt [LinearOrder α] [NoMinOrder α] (a : α) :\n    Bounded (· > ·) (s ∩ { b | b < a }) ↔ Bounded (· > ·) s :=\n  @bounded_lt_inter_lt αᵒᵈ s _ _ a\n\n"}
{"name":"Set.unbounded_gt_inter_gt","module":"Mathlib.Order.Bounded","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : LinearOrder α\ninst✝ : NoMinOrder α\na : α\n⊢ Iff (Set.Unbounded (fun x1 x2 => GT.gt x1 x2) (Inter.inter s (setOf fun b => LT.lt b a))) (Set.Unbounded (fun x1 x2 => GT.gt x1 x2) s)","decl":"theorem unbounded_gt_inter_gt [LinearOrder α] [NoMinOrder α] (a : α) :\n    Unbounded (· > ·) (s ∩ { b | b < a }) ↔ Unbounded (· > ·) s :=\n  @unbounded_lt_inter_lt αᵒᵈ s _ _ a\n\n"}
