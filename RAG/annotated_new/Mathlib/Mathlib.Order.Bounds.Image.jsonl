{"name":"MonotoneOn.mem_upperBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns t : Set α\na : α\nHf : MonotoneOn f t\nHst : HasSubset.Subset s t\nHas : Membership.mem (upperBounds s) a\nHat : Membership.mem t a\n⊢ Membership.mem (upperBounds (Set.image f s)) (f a)","decl":"theorem mem_upperBounds_image (Hf : MonotoneOn f t) (Hst : s ⊆ t) (Has : a ∈ upperBounds s)\n    (Hat : a ∈ t) : f a ∈ upperBounds (f '' s) :=\n  forall_mem_image.2 fun _ H => Hf (Hst H) Hat (Has H)\n\n"}
{"name":"MonotoneOn.mem_upperBounds_image_self","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nt : Set α\na : α\nHf : MonotoneOn f t\na✝¹ : Membership.mem (upperBounds t) a\na✝ : Membership.mem t a\n⊢ Membership.mem (upperBounds (Set.image f t)) (f a)","decl":"theorem mem_upperBounds_image_self (Hf : MonotoneOn f t) :\n    a ∈ upperBounds t → a ∈ t → f a ∈ upperBounds (f '' t) :=\n  Hf.mem_upperBounds_image subset_rfl\n\n"}
{"name":"MonotoneOn.mem_lowerBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns t : Set α\na : α\nHf : MonotoneOn f t\nHst : HasSubset.Subset s t\nHas : Membership.mem (lowerBounds s) a\nHat : Membership.mem t a\n⊢ Membership.mem (lowerBounds (Set.image f s)) (f a)","decl":"theorem mem_lowerBounds_image (Hf : MonotoneOn f t) (Hst : s ⊆ t) (Has : a ∈ lowerBounds s)\n    (Hat : a ∈ t) : f a ∈ lowerBounds (f '' s) :=\n  forall_mem_image.2 fun _ H => Hf Hat (Hst H) (Has H)\n\n"}
{"name":"MonotoneOn.mem_lowerBounds_image_self","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nt : Set α\na : α\nHf : MonotoneOn f t\na✝¹ : Membership.mem (lowerBounds t) a\na✝ : Membership.mem t a\n⊢ Membership.mem (lowerBounds (Set.image f t)) (f a)","decl":"theorem mem_lowerBounds_image_self (Hf : MonotoneOn f t) :\n    a ∈ lowerBounds t → a ∈ t → f a ∈ lowerBounds (f '' t) :=\n  Hf.mem_lowerBounds_image subset_rfl\n\n"}
{"name":"MonotoneOn.image_upperBounds_subset_upperBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns t : Set α\nHf : MonotoneOn f t\nHst : HasSubset.Subset s t\n⊢ HasSubset.Subset (Set.image f (Inter.inter (upperBounds s) t)) (upperBounds (Set.image f s))","decl":"theorem image_upperBounds_subset_upperBounds_image (Hf : MonotoneOn f t) (Hst : s ⊆ t) :\n    f '' (upperBounds s ∩ t) ⊆ upperBounds (f '' s) := by\n  rintro _ ⟨a, ha, rfl⟩\n  exact Hf.mem_upperBounds_image Hst ha.1 ha.2\n\n"}
{"name":"MonotoneOn.image_lowerBounds_subset_lowerBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns t : Set α\nHf : MonotoneOn f t\nHst : HasSubset.Subset s t\n⊢ HasSubset.Subset (Set.image f (Inter.inter (lowerBounds s) t)) (lowerBounds (Set.image f s))","decl":"theorem image_lowerBounds_subset_lowerBounds_image (Hf : MonotoneOn f t) (Hst : s ⊆ t) :\n    f '' (lowerBounds s ∩ t) ⊆ lowerBounds (f '' s) :=\n  Hf.dual.image_upperBounds_subset_upperBounds_image Hst\n\n"}
{"name":"MonotoneOn.map_bddAbove","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns t : Set α\nHf : MonotoneOn f t\nHst : HasSubset.Subset s t\na✝ : (Inter.inter (upperBounds s) t).Nonempty\n⊢ BddAbove (Set.image f s)","decl":"/-- The image under a monotone function on a set `t` of a subset which has an upper bound in `t`\n  is bounded above. -/\ntheorem map_bddAbove (Hf : MonotoneOn f t) (Hst : s ⊆ t) :\n    (upperBounds s ∩ t).Nonempty → BddAbove (f '' s) := fun ⟨C, hs, ht⟩ =>\n  ⟨f C, Hf.mem_upperBounds_image Hst hs ht⟩\n\n"}
{"name":"MonotoneOn.map_bddBelow","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns t : Set α\nHf : MonotoneOn f t\nHst : HasSubset.Subset s t\na✝ : (Inter.inter (lowerBounds s) t).Nonempty\n⊢ BddBelow (Set.image f s)","decl":"/-- The image under a monotone function on a set `t` of a subset which has a lower bound in `t`\n  is bounded below. -/\ntheorem map_bddBelow (Hf : MonotoneOn f t) (Hst : s ⊆ t) :\n    (lowerBounds s ∩ t).Nonempty → BddBelow (f '' s) := fun ⟨C, hs, ht⟩ =>\n  ⟨f C, Hf.mem_lowerBounds_image Hst hs ht⟩\n\n"}
{"name":"MonotoneOn.map_isLeast","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nt : Set α\na : α\nHf : MonotoneOn f t\nHa : IsLeast t a\n⊢ IsLeast (Set.image f t) (f a)","decl":"/-- A monotone map sends a least element of a set to a least element of its image. -/\ntheorem map_isLeast (Hf : MonotoneOn f t) (Ha : IsLeast t a) : IsLeast (f '' t) (f a) :=\n  ⟨mem_image_of_mem _ Ha.1, Hf.mem_lowerBounds_image_self Ha.2 Ha.1⟩\n\n"}
{"name":"MonotoneOn.map_isGreatest","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nt : Set α\na : α\nHf : MonotoneOn f t\nHa : IsGreatest t a\n⊢ IsGreatest (Set.image f t) (f a)","decl":"/-- A monotone map sends a greatest element of a set to a greatest element of its image. -/\ntheorem map_isGreatest (Hf : MonotoneOn f t) (Ha : IsGreatest t a) : IsGreatest (f '' t) (f a) :=\n  ⟨mem_image_of_mem _ Ha.1, Hf.mem_upperBounds_image_self Ha.2 Ha.1⟩\n\n"}
{"name":"AntitoneOn.mem_upperBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns t : Set α\na : α\nHf : AntitoneOn f t\nHst : HasSubset.Subset s t\nHas : Membership.mem (lowerBounds s) a\na✝ : Membership.mem t a\n⊢ Membership.mem (upperBounds (Set.image f s)) (f a)","decl":"theorem mem_upperBounds_image (Hf : AntitoneOn f t) (Hst : s ⊆ t) (Has : a ∈ lowerBounds s) :\n    a ∈ t → f a ∈ upperBounds (f '' s) :=\n  Hf.dual_right.mem_lowerBounds_image Hst Has\n\n"}
{"name":"AntitoneOn.mem_upperBounds_image_self","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nt : Set α\na : α\nHf : AntitoneOn f t\na✝¹ : Membership.mem (lowerBounds t) a\na✝ : Membership.mem t a\n⊢ Membership.mem (upperBounds (Set.image f t)) (f a)","decl":"theorem mem_upperBounds_image_self (Hf : AntitoneOn f t) :\n    a ∈ lowerBounds t → a ∈ t → f a ∈ upperBounds (f '' t) :=\n  Hf.dual_right.mem_lowerBounds_image_self\n\n"}
{"name":"AntitoneOn.mem_lowerBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns t : Set α\na : α\nHf : AntitoneOn f t\nHst : HasSubset.Subset s t\na✝¹ : Membership.mem (upperBounds s) a\na✝ : Membership.mem t a\n⊢ Membership.mem (lowerBounds (Set.image f s)) (f a)","decl":"theorem mem_lowerBounds_image (Hf : AntitoneOn f t) (Hst : s ⊆ t) :\n    a ∈ upperBounds s → a ∈ t → f a ∈ lowerBounds (f '' s) :=\n  Hf.dual_right.mem_upperBounds_image Hst\n\n"}
{"name":"AntitoneOn.mem_lowerBounds_image_self","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nt : Set α\na : α\nHf : AntitoneOn f t\na✝¹ : Membership.mem (upperBounds t) a\na✝ : Membership.mem t a\n⊢ Membership.mem (lowerBounds (Set.image f t)) (f a)","decl":"theorem mem_lowerBounds_image_self (Hf : AntitoneOn f t) :\n    a ∈ upperBounds t → a ∈ t → f a ∈ lowerBounds (f '' t) :=\n  Hf.dual_right.mem_upperBounds_image_self\n\n"}
{"name":"AntitoneOn.image_lowerBounds_subset_upperBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns t : Set α\nHf : AntitoneOn f t\nHst : HasSubset.Subset s t\n⊢ HasSubset.Subset (Set.image f (Inter.inter (lowerBounds s) t)) (upperBounds (Set.image f s))","decl":"theorem image_lowerBounds_subset_upperBounds_image (Hf : AntitoneOn f t) (Hst : s ⊆ t) :\n    f '' (lowerBounds s ∩ t) ⊆ upperBounds (f '' s) :=\n  Hf.dual_right.image_lowerBounds_subset_lowerBounds_image Hst\n\n"}
{"name":"AntitoneOn.image_upperBounds_subset_lowerBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns t : Set α\nHf : AntitoneOn f t\nHst : HasSubset.Subset s t\n⊢ HasSubset.Subset (Set.image f (Inter.inter (upperBounds s) t)) (lowerBounds (Set.image f s))","decl":"theorem image_upperBounds_subset_lowerBounds_image (Hf : AntitoneOn f t) (Hst : s ⊆ t) :\n    f '' (upperBounds s ∩ t) ⊆ lowerBounds (f '' s) :=\n  Hf.dual_right.image_upperBounds_subset_upperBounds_image Hst\n\n"}
{"name":"AntitoneOn.map_bddAbove","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns t : Set α\nHf : AntitoneOn f t\nHst : HasSubset.Subset s t\na✝ : (Inter.inter (upperBounds s) t).Nonempty\n⊢ BddBelow (Set.image f s)","decl":"/-- The image under an antitone function of a set which is bounded above is bounded below. -/\ntheorem map_bddAbove (Hf : AntitoneOn f t) (Hst : s ⊆ t) :\n    (upperBounds s ∩ t).Nonempty → BddBelow (f '' s) :=\n  Hf.dual_right.map_bddAbove Hst\n\n"}
{"name":"AntitoneOn.map_bddBelow","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\ns t : Set α\nHf : AntitoneOn f t\nHst : HasSubset.Subset s t\na✝ : (Inter.inter (lowerBounds s) t).Nonempty\n⊢ BddAbove (Set.image f s)","decl":"/-- The image under an antitone function of a set which is bounded below is bounded above. -/\ntheorem map_bddBelow (Hf : AntitoneOn f t) (Hst : s ⊆ t) :\n    (lowerBounds s ∩ t).Nonempty → BddAbove (f '' s) :=\n  Hf.dual_right.map_bddBelow Hst\n\n"}
{"name":"AntitoneOn.map_isGreatest","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nt : Set α\na : α\nHf : AntitoneOn f t\na✝ : IsGreatest t a\n⊢ IsLeast (Set.image f t) (f a)","decl":"/-- An antitone map sends a greatest element of a set to a least element of its image. -/\ntheorem map_isGreatest (Hf : AntitoneOn f t) : IsGreatest t a → IsLeast (f '' t) (f a) :=\n  Hf.dual_right.map_isGreatest\n\n"}
{"name":"AntitoneOn.map_isLeast","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nt : Set α\na : α\nHf : AntitoneOn f t\na✝ : IsLeast t a\n⊢ IsGreatest (Set.image f t) (f a)","decl":"/-- An antitone map sends a least element of a set to a greatest element of its image. -/\ntheorem map_isLeast (Hf : AntitoneOn f t) : IsLeast t a → IsGreatest (f '' t) (f a) :=\n  Hf.dual_right.map_isLeast\n\n"}
{"name":"Monotone.mem_upperBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nHf : Monotone f\na : α\ns : Set α\nHa : Membership.mem (upperBounds s) a\n⊢ Membership.mem (upperBounds (Set.image f s)) (f a)","decl":"theorem mem_upperBounds_image (Ha : a ∈ upperBounds s) : f a ∈ upperBounds (f '' s) :=\n  forall_mem_image.2 fun _ H => Hf (Ha H)\n\n"}
{"name":"Monotone.mem_lowerBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nHf : Monotone f\na : α\ns : Set α\nHa : Membership.mem (lowerBounds s) a\n⊢ Membership.mem (lowerBounds (Set.image f s)) (f a)","decl":"theorem mem_lowerBounds_image (Ha : a ∈ lowerBounds s) : f a ∈ lowerBounds (f '' s) :=\n  forall_mem_image.2 fun _ H => Hf (Ha H)\n\n"}
{"name":"Monotone.image_upperBounds_subset_upperBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nHf : Monotone f\ns : Set α\n⊢ HasSubset.Subset (Set.image f (upperBounds s)) (upperBounds (Set.image f s))","decl":"theorem image_upperBounds_subset_upperBounds_image :\n    f '' upperBounds s ⊆ upperBounds (f '' s) := by\n  rintro _ ⟨a, ha, rfl⟩\n  exact Hf.mem_upperBounds_image ha\n\n"}
{"name":"Monotone.image_lowerBounds_subset_lowerBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nHf : Monotone f\ns : Set α\n⊢ HasSubset.Subset (Set.image f (lowerBounds s)) (lowerBounds (Set.image f s))","decl":"theorem image_lowerBounds_subset_lowerBounds_image : f '' lowerBounds s ⊆ lowerBounds (f '' s) :=\n  Hf.dual.image_upperBounds_subset_upperBounds_image\n\n"}
{"name":"Monotone.map_bddAbove","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nHf : Monotone f\ns : Set α\na✝ : BddAbove s\n⊢ BddAbove (Set.image f s)","decl":"/-- The image under a monotone function of a set which is bounded above is bounded above. See also\n`BddAbove.image2`. -/\ntheorem map_bddAbove : BddAbove s → BddAbove (f '' s)\n  | ⟨C, hC⟩ => ⟨f C, Hf.mem_upperBounds_image hC⟩\n\n"}
{"name":"Monotone.map_bddBelow","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nHf : Monotone f\ns : Set α\na✝ : BddBelow s\n⊢ BddBelow (Set.image f s)","decl":"/-- The image under a monotone function of a set which is bounded below is bounded below. See also\n`BddBelow.image2`. -/\ntheorem map_bddBelow : BddBelow s → BddBelow (f '' s)\n  | ⟨C, hC⟩ => ⟨f C, Hf.mem_lowerBounds_image hC⟩\n\n"}
{"name":"Monotone.map_isLeast","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nHf : Monotone f\na : α\ns : Set α\nHa : IsLeast s a\n⊢ IsLeast (Set.image f s) (f a)","decl":"/-- A monotone map sends a least element of a set to a least element of its image. -/\ntheorem map_isLeast (Ha : IsLeast s a) : IsLeast (f '' s) (f a) :=\n  ⟨mem_image_of_mem _ Ha.1, Hf.mem_lowerBounds_image Ha.2⟩\n\n"}
{"name":"Monotone.map_isGreatest","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nHf : Monotone f\na : α\ns : Set α\nHa : IsGreatest s a\n⊢ IsGreatest (Set.image f s) (f a)","decl":"/-- A monotone map sends a greatest element of a set to a greatest element of its image. -/\ntheorem map_isGreatest (Ha : IsGreatest s a) : IsGreatest (f '' s) (f a) :=\n  ⟨mem_image_of_mem _ Ha.1, Hf.mem_upperBounds_image Ha.2⟩\n\n"}
{"name":"Antitone.mem_upperBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\na : α\ns : Set α\na✝ : Membership.mem (lowerBounds s) a\n⊢ Membership.mem (upperBounds (Set.image f s)) (f a)","decl":"theorem mem_upperBounds_image : a ∈ lowerBounds s → f a ∈ upperBounds (f '' s) :=\n  hf.dual_right.mem_lowerBounds_image\n\n"}
{"name":"Antitone.mem_lowerBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\na : α\ns : Set α\na✝ : Membership.mem (upperBounds s) a\n⊢ Membership.mem (lowerBounds (Set.image f s)) (f a)","decl":"theorem mem_lowerBounds_image : a ∈ upperBounds s → f a ∈ lowerBounds (f '' s) :=\n  hf.dual_right.mem_upperBounds_image\n\n"}
{"name":"Antitone.image_lowerBounds_subset_upperBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\ns : Set α\n⊢ HasSubset.Subset (Set.image f (lowerBounds s)) (upperBounds (Set.image f s))","decl":"theorem image_lowerBounds_subset_upperBounds_image : f '' lowerBounds s ⊆ upperBounds (f '' s) :=\n  hf.dual_right.image_lowerBounds_subset_lowerBounds_image\n\n"}
{"name":"Antitone.image_upperBounds_subset_lowerBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\ns : Set α\n⊢ HasSubset.Subset (Set.image f (upperBounds s)) (lowerBounds (Set.image f s))","decl":"theorem image_upperBounds_subset_lowerBounds_image : f '' upperBounds s ⊆ lowerBounds (f '' s) :=\n  hf.dual_right.image_upperBounds_subset_upperBounds_image\n\n"}
{"name":"Antitone.map_bddAbove","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\ns : Set α\na✝ : BddAbove s\n⊢ BddBelow (Set.image f s)","decl":"/-- The image under an antitone function of a set which is bounded above is bounded below. -/\ntheorem map_bddAbove : BddAbove s → BddBelow (f '' s) :=\n  hf.dual_right.map_bddAbove\n\n"}
{"name":"Antitone.map_bddBelow","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\ns : Set α\na✝ : BddBelow s\n⊢ BddAbove (Set.image f s)","decl":"/-- The image under an antitone function of a set which is bounded below is bounded above. -/\ntheorem map_bddBelow : BddBelow s → BddAbove (f '' s) :=\n  hf.dual_right.map_bddBelow\n\n"}
{"name":"Antitone.map_isGreatest","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\na : α\ns : Set α\na✝ : IsGreatest s a\n⊢ IsLeast (Set.image f s) (f a)","decl":"/-- An antitone map sends a greatest element of a set to a least element of its image. -/\ntheorem map_isGreatest : IsGreatest s a → IsLeast (f '' s) (f a) :=\n  hf.dual_right.map_isGreatest\n\n"}
{"name":"Antitone.map_isLeast","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : Antitone f\na : α\ns : Set α\na✝ : IsLeast s a\n⊢ IsGreatest (Set.image f s) (f a)","decl":"/-- An antitone map sends a least element of a set to a greatest element of its image. -/\ntheorem map_isLeast : IsLeast s a → IsGreatest (f '' s) (f a) :=\n  hf.dual_right.map_isLeast\n\n"}
{"name":"StrictMono.mem_upperBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\na : α\ns : Set α\nhf : StrictMono f\n⊢ Iff (Membership.mem (upperBounds (Set.image f s)) (f a)) (Membership.mem (upperBounds s) a)","decl":"lemma StrictMono.mem_upperBounds_image (hf : StrictMono f) :\n    f a ∈ upperBounds (f '' s) ↔ a ∈ upperBounds s := by simp [upperBounds, hf.le_iff_le]\n\n"}
{"name":"StrictMono.mem_lowerBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\na : α\ns : Set α\nhf : StrictMono f\n⊢ Iff (Membership.mem (lowerBounds (Set.image f s)) (f a)) (Membership.mem (lowerBounds s) a)","decl":"lemma StrictMono.mem_lowerBounds_image (hf : StrictMono f) :\n    f a ∈ lowerBounds (f '' s) ↔ a ∈ lowerBounds s :=  by simp [lowerBounds, hf.le_iff_le]\n\n"}
{"name":"StrictMono.map_isLeast","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\na : α\ns : Set α\nhf : StrictMono f\n⊢ Iff (IsLeast (Set.image f s) (f a)) (IsLeast s a)","decl":"lemma StrictMono.map_isLeast (hf : StrictMono f) : IsLeast (f '' s) (f a) ↔ IsLeast s a := by\n  simp [IsLeast, hf.injective.eq_iff, hf.mem_lowerBounds_image]\n\n"}
{"name":"StrictMono.map_isGreatest","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\na : α\ns : Set α\nhf : StrictMono f\n⊢ Iff (IsGreatest (Set.image f s) (f a)) (IsGreatest s a)","decl":"lemma StrictMono.map_isGreatest (hf : StrictMono f) :\n    IsGreatest (f '' s) (f a) ↔ IsGreatest s a := by\n  simp [IsGreatest, hf.injective.eq_iff, hf.mem_upperBounds_image]\n\n"}
{"name":"StrictAnti.mem_upperBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\na : α\ns : Set α\nhf : StrictAnti f\n⊢ Iff (Membership.mem (upperBounds (Set.image f s)) (f a)) (Membership.mem (lowerBounds s) a)","decl":"lemma StrictAnti.mem_upperBounds_image (hf : StrictAnti f) :\n    f a ∈ upperBounds (f '' s) ↔ a ∈ lowerBounds s := by\n  simp [upperBounds, lowerBounds, hf.le_iff_le]\n\n"}
{"name":"StrictAnti.mem_lowerBounds_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\na : α\ns : Set α\nhf : StrictAnti f\n⊢ Iff (Membership.mem (lowerBounds (Set.image f s)) (f a)) (Membership.mem (upperBounds s) a)","decl":"lemma StrictAnti.mem_lowerBounds_image (hf : StrictAnti f) :\n    f a ∈ lowerBounds (f '' s) ↔ a ∈ upperBounds s := by\n  simp [upperBounds, lowerBounds, hf.le_iff_le]\n\n"}
{"name":"StrictAnti.map_isLeast","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\na : α\ns : Set α\nhf : StrictAnti f\n⊢ Iff (IsLeast (Set.image f s) (f a)) (IsGreatest s a)","decl":"lemma StrictAnti.map_isLeast (hf : StrictAnti f) : IsLeast (f '' s) (f a) ↔ IsGreatest s a := by\n  simp [IsLeast, IsGreatest, hf.injective.eq_iff, hf.mem_lowerBounds_image]\n\n"}
{"name":"StrictAnti.map_isGreatest","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\na : α\ns : Set α\nhf : StrictAnti f\n⊢ Iff (IsGreatest (Set.image f s) (f a)) (IsLeast s a)","decl":"lemma StrictAnti.map_isGreatest (hf : StrictAnti f) : IsGreatest (f '' s) (f a) ↔ IsLeast s a := by\n  simp [IsLeast, IsGreatest, hf.injective.eq_iff, hf.mem_upperBounds_image]\n\n"}
{"name":"mem_upperBounds_image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\nha : Membership.mem (upperBounds s) a\nhb : Membership.mem (upperBounds t) b\n⊢ Membership.mem (upperBounds (Set.image2 f s t)) (f a b)","decl":"theorem mem_upperBounds_image2 (ha : a ∈ upperBounds s) (hb : b ∈ upperBounds t) :\n    f a b ∈ upperBounds (image2 f s t) :=\n  forall_mem_image2.2 fun _ hx _ hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n\n"}
{"name":"mem_lowerBounds_image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\nha : Membership.mem (lowerBounds s) a\nhb : Membership.mem (lowerBounds t) b\n⊢ Membership.mem (lowerBounds (Set.image2 f s t)) (f a b)","decl":"theorem mem_lowerBounds_image2 (ha : a ∈ lowerBounds s) (hb : b ∈ lowerBounds t) :\n    f a b ∈ lowerBounds (image2 f s t) :=\n  forall_mem_image2.2 fun _ hx _ hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n\n"}
{"name":"image2_upperBounds_upperBounds_subset","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\n⊢ HasSubset.Subset (Set.image2 f (upperBounds s) (upperBounds t)) (upperBounds (Set.image2 f s t))","decl":"theorem image2_upperBounds_upperBounds_subset :\n    image2 f (upperBounds s) (upperBounds t) ⊆ upperBounds (image2 f s t) :=\n  image2_subset_iff.2 fun _ ha _ hb ↦ mem_upperBounds_image2 h₀ h₁ ha hb\n\n"}
{"name":"image2_lowerBounds_lowerBounds_subset","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\n⊢ HasSubset.Subset (Set.image2 f (lowerBounds s) (lowerBounds t)) (lowerBounds (Set.image2 f s t))","decl":"theorem image2_lowerBounds_lowerBounds_subset :\n    image2 f (lowerBounds s) (lowerBounds t) ⊆ lowerBounds (image2 f s t) :=\n  image2_subset_iff.2 fun _ ha _ hb ↦ mem_lowerBounds_image2 h₀ h₁ ha hb\n\n"}
{"name":"BddAbove.image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\na✝¹ : BddAbove s\na✝ : BddAbove t\n⊢ BddAbove (Set.image2 f s t)","decl":"/-- See also `Monotone.map_bddAbove`. -/\nprotected theorem BddAbove.image2 :\n    BddAbove s → BddAbove t → BddAbove (image2 f s t) := by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  exact ⟨f a b, mem_upperBounds_image2 h₀ h₁ ha hb⟩\n\n"}
{"name":"BddBelow.image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\na✝¹ : BddBelow s\na✝ : BddBelow t\n⊢ BddBelow (Set.image2 f s t)","decl":"/-- See also `Monotone.map_bddBelow`. -/\nprotected theorem BddBelow.image2 :\n    BddBelow s → BddBelow t → BddBelow (image2 f s t) := by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  exact ⟨f a b, mem_lowerBounds_image2 h₀ h₁ ha hb⟩\n\n"}
{"name":"IsGreatest.image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\nha : IsGreatest s a\nhb : IsGreatest t b\n⊢ IsGreatest (Set.image2 f s t) (f a b)","decl":"protected theorem IsGreatest.image2 (ha : IsGreatest s a) (hb : IsGreatest t b) :\n    IsGreatest (image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1, mem_upperBounds_image2 h₀ h₁ ha.2 hb.2⟩\n\n"}
{"name":"IsLeast.image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\nha : IsLeast s a\nhb : IsLeast t b\n⊢ IsLeast (Set.image2 f s t) (f a b)","decl":"protected theorem IsLeast.image2 (ha : IsLeast s a) (hb : IsLeast t b) :\n    IsLeast (image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1, mem_lowerBounds_image2 h₀ h₁ ha.2 hb.2⟩\n\n"}
{"name":"mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\nha : Membership.mem (upperBounds s) a\nhb : Membership.mem (lowerBounds t) b\n⊢ Membership.mem (upperBounds (Set.image2 f s t)) (f a b)","decl":"theorem mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds (ha : a ∈ upperBounds s)\n    (hb : b ∈ lowerBounds t) : f a b ∈ upperBounds (image2 f s t) :=\n  forall_mem_image2.2 fun _ hx _ hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n\n"}
{"name":"mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\nha : Membership.mem (lowerBounds s) a\nhb : Membership.mem (upperBounds t) b\n⊢ Membership.mem (lowerBounds (Set.image2 f s t)) (f a b)","decl":"theorem mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds (ha : a ∈ lowerBounds s)\n    (hb : b ∈ upperBounds t) : f a b ∈ lowerBounds (image2 f s t) :=\n  forall_mem_image2.2 fun _ hx _ hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n\n"}
{"name":"image2_upperBounds_lowerBounds_subset_upperBounds_image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\n⊢ HasSubset.Subset (Set.image2 f (upperBounds s) (lowerBounds t)) (upperBounds (Set.image2 f s t))","decl":"theorem image2_upperBounds_lowerBounds_subset_upperBounds_image2 :\n    image2 f (upperBounds s) (lowerBounds t) ⊆ upperBounds (image2 f s t) :=\n  image2_subset_iff.2 fun _ ha _ hb ↦\n    mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds h₀ h₁ ha hb\n\n"}
{"name":"image2_lowerBounds_upperBounds_subset_lowerBounds_image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\n⊢ HasSubset.Subset (Set.image2 f (lowerBounds s) (upperBounds t)) (lowerBounds (Set.image2 f s t))","decl":"theorem image2_lowerBounds_upperBounds_subset_lowerBounds_image2 :\n    image2 f (lowerBounds s) (upperBounds t) ⊆ lowerBounds (image2 f s t) :=\n  image2_subset_iff.2 fun _ ha _ hb ↦\n    mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds h₀ h₁ ha hb\n\n"}
{"name":"BddAbove.bddAbove_image2_of_bddBelow","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\na✝¹ : BddAbove s\na✝ : BddBelow t\n⊢ BddAbove (Set.image2 f s t)","decl":"theorem BddAbove.bddAbove_image2_of_bddBelow :\n    BddAbove s → BddBelow t → BddAbove (Set.image2 f s t) := by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  exact ⟨f a b, mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds h₀ h₁ ha hb⟩\n\n"}
{"name":"BddBelow.bddBelow_image2_of_bddAbove","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\na✝¹ : BddBelow s\na✝ : BddAbove t\n⊢ BddBelow (Set.image2 f s t)","decl":"theorem BddBelow.bddBelow_image2_of_bddAbove :\n    BddBelow s → BddAbove t → BddBelow (Set.image2 f s t) := by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  exact ⟨f a b, mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds h₀ h₁ ha hb⟩\n\n"}
{"name":"IsGreatest.isGreatest_image2_of_isLeast","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\nha : IsGreatest s a\nhb : IsLeast t b\n⊢ IsGreatest (Set.image2 f s t) (f a b)","decl":"theorem IsGreatest.isGreatest_image2_of_isLeast (ha : IsGreatest s a) (hb : IsLeast t b) :\n    IsGreatest (Set.image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1,\n    mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds h₀ h₁ ha.2 hb.2⟩\n\n"}
{"name":"IsLeast.isLeast_image2_of_isGreatest","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Monotone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\nha : IsLeast s a\nhb : IsGreatest t b\n⊢ IsLeast (Set.image2 f s t) (f a b)","decl":"theorem IsLeast.isLeast_image2_of_isGreatest (ha : IsLeast s a) (hb : IsGreatest t b) :\n    IsLeast (Set.image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1,\n    mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds h₀ h₁ ha.2 hb.2⟩\n\n"}
{"name":"mem_upperBounds_image2_of_mem_lowerBounds","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\nha : Membership.mem (lowerBounds s) a\nhb : Membership.mem (lowerBounds t) b\n⊢ Membership.mem (upperBounds (Set.image2 f s t)) (f a b)","decl":"theorem mem_upperBounds_image2_of_mem_lowerBounds (ha : a ∈ lowerBounds s)\n    (hb : b ∈ lowerBounds t) : f a b ∈ upperBounds (image2 f s t) :=\n  forall_mem_image2.2 fun _ hx _ hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n\n"}
{"name":"mem_lowerBounds_image2_of_mem_upperBounds","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\nha : Membership.mem (upperBounds s) a\nhb : Membership.mem (upperBounds t) b\n⊢ Membership.mem (lowerBounds (Set.image2 f s t)) (f a b)","decl":"theorem mem_lowerBounds_image2_of_mem_upperBounds (ha : a ∈ upperBounds s)\n    (hb : b ∈ upperBounds t) : f a b ∈ lowerBounds (image2 f s t) :=\n  forall_mem_image2.2 fun _ hx _ hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n\n"}
{"name":"image2_upperBounds_upperBounds_subset_upperBounds_image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\n⊢ HasSubset.Subset (Set.image2 f (lowerBounds s) (lowerBounds t)) (upperBounds (Set.image2 f s t))","decl":"theorem image2_upperBounds_upperBounds_subset_upperBounds_image2 :\n    image2 f (lowerBounds s) (lowerBounds t) ⊆ upperBounds (image2 f s t) :=\n  image2_subset_iff.2 fun _ ha _ hb ↦\n    mem_upperBounds_image2_of_mem_lowerBounds h₀ h₁ ha hb\n\n"}
{"name":"image2_lowerBounds_lowerBounds_subset_lowerBounds_image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\n⊢ HasSubset.Subset (Set.image2 f (upperBounds s) (upperBounds t)) (lowerBounds (Set.image2 f s t))","decl":"theorem image2_lowerBounds_lowerBounds_subset_lowerBounds_image2 :\n    image2 f (upperBounds s) (upperBounds t) ⊆ lowerBounds (image2 f s t) :=\n  image2_subset_iff.2 fun _ ha _ hb ↦\n    mem_lowerBounds_image2_of_mem_upperBounds h₀ h₁ ha hb\n\n"}
{"name":"BddBelow.image2_bddAbove","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\na✝¹ : BddBelow s\na✝ : BddBelow t\n⊢ BddAbove (Set.image2 f s t)","decl":"theorem BddBelow.image2_bddAbove : BddBelow s → BddBelow t → BddAbove (Set.image2 f s t) := by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  exact ⟨f a b, mem_upperBounds_image2_of_mem_lowerBounds h₀ h₁ ha hb⟩\n\n"}
{"name":"BddAbove.image2_bddBelow","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\na✝¹ : BddAbove s\na✝ : BddAbove t\n⊢ BddBelow (Set.image2 f s t)","decl":"theorem BddAbove.image2_bddBelow : BddAbove s → BddAbove t → BddBelow (Set.image2 f s t) := by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  exact ⟨f a b, mem_lowerBounds_image2_of_mem_upperBounds h₀ h₁ ha hb⟩\n\n"}
{"name":"IsLeast.isGreatest_image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\nha : IsLeast s a\nhb : IsLeast t b\n⊢ IsGreatest (Set.image2 f s t) (f a b)","decl":"theorem IsLeast.isGreatest_image2 (ha : IsLeast s a) (hb : IsLeast t b) :\n    IsGreatest (Set.image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1, mem_upperBounds_image2_of_mem_lowerBounds h₀ h₁ ha.2 hb.2⟩\n\n"}
{"name":"IsGreatest.isLeast_image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Antitone (f a)\nha : IsGreatest s a\nhb : IsGreatest t b\n⊢ IsLeast (Set.image2 f s t) (f a b)","decl":"theorem IsGreatest.isLeast_image2 (ha : IsGreatest s a) (hb : IsGreatest t b) :\n    IsLeast (Set.image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1, mem_lowerBounds_image2_of_mem_upperBounds h₀ h₁ ha.2 hb.2⟩\n\n"}
{"name":"mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\nha : Membership.mem (lowerBounds s) a\nhb : Membership.mem (upperBounds t) b\n⊢ Membership.mem (upperBounds (Set.image2 f s t)) (f a b)","decl":"theorem mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds (ha : a ∈ lowerBounds s)\n    (hb : b ∈ upperBounds t) : f a b ∈ upperBounds (image2 f s t) :=\n  forall_mem_image2.2 fun _ hx _ hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n\n"}
{"name":"mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\nha : Membership.mem (upperBounds s) a\nhb : Membership.mem (lowerBounds t) b\n⊢ Membership.mem (lowerBounds (Set.image2 f s t)) (f a b)","decl":"theorem mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds (ha : a ∈ upperBounds s)\n    (hb : b ∈ lowerBounds t) : f a b ∈ lowerBounds (image2 f s t) :=\n  forall_mem_image2.2 fun _ hx _ hy => (h₀ _ <| ha hx).trans <| h₁ _ <| hb hy\n\n"}
{"name":"image2_lowerBounds_upperBounds_subset_upperBounds_image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\n⊢ HasSubset.Subset (Set.image2 f (lowerBounds s) (upperBounds t)) (upperBounds (Set.image2 f s t))","decl":"theorem image2_lowerBounds_upperBounds_subset_upperBounds_image2 :\n    image2 f (lowerBounds s) (upperBounds t) ⊆ upperBounds (image2 f s t) :=\n  image2_subset_iff.2 fun _ ha _ hb ↦\n    mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds h₀ h₁ ha hb\n\n"}
{"name":"image2_upperBounds_lowerBounds_subset_lowerBounds_image2","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\n⊢ HasSubset.Subset (Set.image2 f (upperBounds s) (lowerBounds t)) (lowerBounds (Set.image2 f s t))","decl":"theorem image2_upperBounds_lowerBounds_subset_lowerBounds_image2 :\n    image2 f (upperBounds s) (lowerBounds t) ⊆ lowerBounds (image2 f s t) :=\n  image2_subset_iff.2 fun _ ha _ hb ↦\n    mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds h₀ h₁ ha hb\n\n"}
{"name":"BddBelow.bddAbove_image2_of_bddAbove","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\na✝¹ : BddBelow s\na✝ : BddAbove t\n⊢ BddAbove (Set.image2 f s t)","decl":"theorem BddBelow.bddAbove_image2_of_bddAbove :\n    BddBelow s → BddAbove t → BddAbove (Set.image2 f s t) := by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  exact ⟨f a b, mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds h₀ h₁ ha hb⟩\n\n"}
{"name":"BddAbove.bddBelow_image2_of_bddAbove","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\na✝¹ : BddAbove s\na✝ : BddBelow t\n⊢ BddBelow (Set.image2 f s t)","decl":"theorem BddAbove.bddBelow_image2_of_bddAbove :\n    BddAbove s → BddBelow t → BddBelow (Set.image2 f s t) := by\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  exact ⟨f a b, mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds h₀ h₁ ha hb⟩\n\n"}
{"name":"IsLeast.isGreatest_image2_of_isGreatest","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\nha : IsLeast s a\nhb : IsGreatest t b\n⊢ IsGreatest (Set.image2 f s t) (f a b)","decl":"theorem IsLeast.isGreatest_image2_of_isGreatest (ha : IsLeast s a) (hb : IsGreatest t b) :\n    IsGreatest (Set.image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1,\n    mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds h₀ h₁ ha.2 hb.2⟩\n\n"}
{"name":"IsGreatest.isLeast_image2_of_isLeast","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β → γ\ns : Set α\nt : Set β\na : α\nb : β\nh₀ : ∀ (b : β), Antitone (Function.swap f b)\nh₁ : ∀ (a : α), Monotone (f a)\nha : IsGreatest s a\nhb : IsLeast t b\n⊢ IsLeast (Set.image2 f s t) (f a b)","decl":"theorem IsGreatest.isLeast_image2_of_isLeast (ha : IsGreatest s a) (hb : IsLeast t b) :\n    IsLeast (Set.image2 f s t) (f a b) :=\n  ⟨mem_image2_of_mem ha.1 hb.1,\n    mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds h₀ h₁ ha.2 hb.2⟩\n\n"}
{"name":"bddAbove_prod","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set (Prod α β)\n⊢ Iff (BddAbove s) (And (BddAbove (Set.image Prod.fst s)) (BddAbove (Set.image Prod.snd s)))","decl":"lemma bddAbove_prod {s : Set (α × β)} :\n    BddAbove s ↔ BddAbove (Prod.fst '' s) ∧ BddAbove (Prod.snd '' s) :=\n  ⟨fun ⟨p, hp⟩ ↦ ⟨⟨p.1, forall_mem_image.2 fun _q hq ↦ (hp hq).1⟩,\n    ⟨p.2, forall_mem_image.2 fun _q hq ↦ (hp hq).2⟩⟩,\n    fun ⟨⟨x, hx⟩, ⟨y, hy⟩⟩ ↦ ⟨⟨x, y⟩, fun _p hp ↦\n      ⟨hx <| mem_image_of_mem _ hp, hy <| mem_image_of_mem _ hp⟩⟩⟩\n\n"}
{"name":"bddBelow_prod","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set (Prod α β)\n⊢ Iff (BddBelow s) (And (BddBelow (Set.image Prod.fst s)) (BddBelow (Set.image Prod.snd s)))","decl":"lemma bddBelow_prod {s : Set (α × β)} :\n    BddBelow s ↔ BddBelow (Prod.fst '' s) ∧ BddBelow (Prod.snd '' s) :=\n  bddAbove_prod (α := αᵒᵈ) (β := βᵒᵈ)\n\n"}
{"name":"bddAbove_range_prod","module":"Mathlib.Order.Bounds.Image","initialProofState":"ι : Sort x\nα : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nF : ι → Prod α β\n⊢ Iff (BddAbove (Set.range F)) (And (BddAbove (Set.range (Function.comp Prod.fst F))) (BddAbove (Set.range (Function.comp Prod.snd F))))","decl":"lemma bddAbove_range_prod {F : ι → α × β} :\n    BddAbove (range F) ↔ BddAbove (range <| Prod.fst ∘ F) ∧ BddAbove (range <| Prod.snd ∘ F) := by\n  simp only [bddAbove_prod, ← range_comp]\n\n"}
{"name":"bddBelow_range_prod","module":"Mathlib.Order.Bounds.Image","initialProofState":"ι : Sort x\nα : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nF : ι → Prod α β\n⊢ Iff (BddBelow (Set.range F)) (And (BddBelow (Set.range (Function.comp Prod.fst F))) (BddBelow (Set.range (Function.comp Prod.snd F))))","decl":"lemma bddBelow_range_prod {F : ι → α × β} :\n    BddBelow (range F) ↔ BddBelow (range <| Prod.fst ∘ F) ∧ BddBelow (range <| Prod.snd ∘ F) :=\n  bddAbove_range_prod (α := αᵒᵈ) (β := βᵒᵈ)\n\n"}
{"name":"isLUB_prod","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set (Prod α β)\np : Prod α β\n⊢ Iff (IsLUB s p) (And (IsLUB (Set.image Prod.fst s) p.1) (IsLUB (Set.image Prod.snd s) p.2))","decl":"theorem isLUB_prod {s : Set (α × β)} (p : α × β) :\n    IsLUB s p ↔ IsLUB (Prod.fst '' s) p.1 ∧ IsLUB (Prod.snd '' s) p.2 := by\n  refine\n    ⟨fun H =>\n      ⟨⟨monotone_fst.mem_upperBounds_image H.1, fun a ha => ?_⟩,\n        ⟨monotone_snd.mem_upperBounds_image H.1, fun a ha => ?_⟩⟩,\n      fun H => ⟨?_, ?_⟩⟩\n  · suffices h : (a, p.2) ∈ upperBounds s from (H.2 h).1\n    exact fun q hq => ⟨ha <| mem_image_of_mem _ hq, (H.1 hq).2⟩\n  · suffices h : (p.1, a) ∈ upperBounds s from (H.2 h).2\n    exact fun q hq => ⟨(H.1 hq).1, ha <| mem_image_of_mem _ hq⟩\n  · exact fun q hq => ⟨H.1.1 <| mem_image_of_mem _ hq, H.2.1 <| mem_image_of_mem _ hq⟩\n  · exact fun q hq =>\n      ⟨H.1.2 <| monotone_fst.mem_upperBounds_image hq,\n        H.2.2 <| monotone_snd.mem_upperBounds_image hq⟩\n\n"}
{"name":"isGLB_prod","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set (Prod α β)\np : Prod α β\n⊢ Iff (IsGLB s p) (And (IsGLB (Set.image Prod.fst s) p.1) (IsGLB (Set.image Prod.snd s) p.2))","decl":"theorem isGLB_prod {s : Set (α × β)} (p : α × β) :\n    IsGLB s p ↔ IsGLB (Prod.fst '' s) p.1 ∧ IsGLB (Prod.snd '' s) p.2 :=\n  @isLUB_prod αᵒᵈ βᵒᵈ _ _ _ _\n\n"}
{"name":"bddAbove_pi","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nπ : α → Type u_1\ninst✝ : (a : α) → Preorder (π a)\ns : Set ((a : α) → π a)\n⊢ Iff (BddAbove s) (∀ (a : α), BddAbove (Set.image (Function.eval a) s))","decl":"lemma bddAbove_pi {s : Set (∀ a, π a)} :\n    BddAbove s ↔ ∀ a, BddAbove (Function.eval a '' s) :=\n  ⟨fun ⟨f, hf⟩ a ↦ ⟨f a, forall_mem_image.2 fun _ hg ↦ hf hg a⟩,\n    fun h ↦ ⟨fun a ↦ (h a).some, fun _ hg a ↦ (h a).some_mem <| mem_image_of_mem _ hg⟩⟩\n\n"}
{"name":"bddBelow_pi","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nπ : α → Type u_1\ninst✝ : (a : α) → Preorder (π a)\ns : Set ((a : α) → π a)\n⊢ Iff (BddBelow s) (∀ (a : α), BddBelow (Set.image (Function.eval a) s))","decl":"lemma bddBelow_pi {s : Set (∀ a, π a)} :\n    BddBelow s ↔ ∀ a, BddBelow (Function.eval a '' s) :=\n  bddAbove_pi (π := fun a ↦ (π a)ᵒᵈ)\n\n"}
{"name":"bddAbove_range_pi","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nι : Sort x\nπ : α → Type u_1\ninst✝ : (a : α) → Preorder (π a)\nF : ι → (a : α) → π a\n⊢ Iff (BddAbove (Set.range F)) (∀ (a : α), BddAbove (Set.range fun i => F i a))","decl":"lemma bddAbove_range_pi {F : ι → ∀ a, π a} :\n    BddAbove (range F) ↔ ∀ a, BddAbove (range fun i ↦ F i a) := by\n  simp only [bddAbove_pi, ← range_comp]\n  rfl\n\n"}
{"name":"bddBelow_range_pi","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nι : Sort x\nπ : α → Type u_1\ninst✝ : (a : α) → Preorder (π a)\nF : ι → (a : α) → π a\n⊢ Iff (BddBelow (Set.range F)) (∀ (a : α), BddBelow (Set.range fun i => F i a))","decl":"lemma bddBelow_range_pi {F : ι → ∀ a, π a} :\n    BddBelow (range F) ↔ ∀ a, BddBelow (range fun i ↦ F i a) :=\n  bddAbove_range_pi (π := fun a ↦ (π a)ᵒᵈ)\n\n"}
{"name":"isLUB_pi","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nπ : α → Type u_1\ninst✝ : (a : α) → Preorder (π a)\ns : Set ((a : α) → π a)\nf : (a : α) → π a\n⊢ Iff (IsLUB s f) (∀ (a : α), IsLUB (Set.image (Function.eval a) s) (f a))","decl":"theorem isLUB_pi {s : Set (∀ a, π a)} {f : ∀ a, π a} :\n    IsLUB s f ↔ ∀ a, IsLUB (Function.eval a '' s) (f a) := by\n  classical\n    refine\n      ⟨fun H a => ⟨(Function.monotone_eval a).mem_upperBounds_image H.1, fun b hb => ?_⟩, fun H =>\n        ⟨?_, ?_⟩⟩\n    · suffices h : Function.update f a b ∈ upperBounds s from Function.update_self a b f ▸ H.2 h a\n      exact fun g hg => le_update_iff.2 ⟨hb <| mem_image_of_mem _ hg, fun i _ => H.1 hg i⟩\n    · exact fun g hg a => (H a).1 (mem_image_of_mem _ hg)\n    · exact fun g hg a => (H a).2 ((Function.monotone_eval a).mem_upperBounds_image hg)\n\n"}
{"name":"isGLB_pi","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nπ : α → Type u_1\ninst✝ : (a : α) → Preorder (π a)\ns : Set ((a : α) → π a)\nf : (a : α) → π a\n⊢ Iff (IsGLB s f) (∀ (a : α), IsGLB (Set.image (Function.eval a) s) (f a))","decl":"theorem isGLB_pi {s : Set (∀ a, π a)} {f : ∀ a, π a} :\n    IsGLB s f ↔ ∀ a, IsGLB (Function.eval a '' s) (f a) :=\n  @isLUB_pi α (fun a => (π a)ᵒᵈ) _ s f\n\n"}
{"name":"IsGLB.of_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : ∀ {x y : α}, Iff (LE.le (f x) (f y)) (LE.le x y)\ns : Set α\nx : α\nhx : IsGLB (Set.image f s) (f x)\n⊢ IsGLB s x","decl":"theorem IsGLB.of_image [Preorder α] [Preorder β] {f : α → β} (hf : ∀ {x y}, f x ≤ f y ↔ x ≤ y)\n    {s : Set α} {x : α} (hx : IsGLB (f '' s) (f x)) : IsGLB s x :=\n  ⟨fun _ hy => hf.1 <| hx.1 <| mem_image_of_mem _ hy, fun _ hy =>\n    hf.1 <| hx.2 <| Monotone.mem_lowerBounds_image (fun _ _ => hf.2) hy⟩\n\n"}
{"name":"IsLUB.of_image","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : ∀ {x y : α}, Iff (LE.le (f x) (f y)) (LE.le x y)\ns : Set α\nx : α\nhx : IsLUB (Set.image f s) (f x)\n⊢ IsLUB s x","decl":"theorem IsLUB.of_image [Preorder α] [Preorder β] {f : α → β} (hf : ∀ {x y}, f x ≤ f y ↔ x ≤ y)\n    {s : Set α} {x : α} (hx : IsLUB (f '' s) (f x)) : IsLUB s x :=\n  ⟨fun _ hy => hf.1 <| hx.1 <| mem_image_of_mem _ hy, fun _ hy =>\n    hf.1 <| hx.2 <| Monotone.mem_upperBounds_image (fun _ _ => hf.2) hy⟩\n\n"}
{"name":"BddAbove.range_mono","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf g : α → β\nh : ∀ (a : α), LE.le (f a) (g a)\nhbdd : BddAbove (Set.range g)\n⊢ BddAbove (Set.range f)","decl":"lemma BddAbove.range_mono [Preorder β] {f : α → β} (g : α → β) (h : ∀ a, f a ≤ g a)\n    (hbdd : BddAbove (range g)) : BddAbove (range f) := by\n  obtain ⟨C, hC⟩ := hbdd\n  use C\n  rintro - ⟨x, rfl⟩\n  exact (h x).trans (hC <| mem_range_self x)\n\n"}
{"name":"BddBelow.range_mono","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf g : α → β\nh : ∀ (a : α), LE.le (f a) (g a)\nhbdd : BddBelow (Set.range f)\n⊢ BddBelow (Set.range g)","decl":"lemma BddBelow.range_mono [Preorder β] (f : α → β) {g : α → β} (h : ∀ a, f a ≤ g a)\n    (hbdd : BddBelow (range f)) : BddBelow (range g) :=\n  BddAbove.range_mono (β := βᵒᵈ) f h hbdd\n\n"}
{"name":"BddAbove.range_comp","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\ng : β → γ\nhf : BddAbove (Set.range f)\nhg : Monotone g\n⊢ BddAbove (Set.range fun x => g (f x))","decl":"lemma BddAbove.range_comp {γ : Type*} [Preorder β] [Preorder γ] {f : α → β} {g : β → γ}\n    (hf : BddAbove (range f)) (hg : Monotone g) : BddAbove (range (fun x => g (f x))) := by\n  change BddAbove (range (g ∘ f))\n  simpa only [Set.range_comp] using hg.map_bddAbove hf\n\n"}
{"name":"BddBelow.range_comp","module":"Mathlib.Order.Bounds.Image","initialProofState":"α : Type u\nβ : Type v\nγ : Type u_1\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\ng : β → γ\nhf : BddBelow (Set.range f)\nhg : Monotone g\n⊢ BddBelow (Set.range fun x => g (f x))","decl":"lemma BddBelow.range_comp {γ : Type*} [Preorder β] [Preorder γ] {f : α → β} {g : β → γ}\n    (hf : BddBelow (range f)) (hg : Monotone g) : BddBelow (range (fun x => g (f x))) := by\n  change BddBelow (range (g ∘ f))\n  simpa only [Set.range_comp] using hg.map_bddBelow hf\n"}
