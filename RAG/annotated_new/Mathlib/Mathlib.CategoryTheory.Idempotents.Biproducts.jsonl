{"name":"CategoryTheory.Idempotents.Karoubi.Biproducts.bicone_Ï€_f","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{v, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Finite J\nF : J â†’ CategoryTheory.Idempotents.Karoubi C\nj : J\nâŠ¢ Eq ((CategoryTheory.Idempotents.Karoubi.Biproducts.bicone F).Ï€ j).f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map fun j => (F j).p) ((CategoryTheory.Limits.biproduct.bicone fun j => (F j).X).Ï€ j))","decl":"/-- The `Bicone` used in order to obtain the existence of\nthe biproduct of a functor `J â¥¤ Karoubi C` when the category `C` is additive. -/\n@[simps]\ndef bicone [HasFiniteBiproducts C] {J : Type} [Finite J] (F : J â†’ Karoubi C) : Bicone F where\n  pt :=\n    { X := biproduct fun j => (F j).X\n      p := biproduct.map fun j => (F j).p\n      idem := by\n        ext\n        simp only [assoc, biproduct.map_Ï€, biproduct.map_Ï€_assoc, idem] }\n  Ï€ j :=\n    { f := (biproduct.map fun j => (F j).p) â‰« Bicone.Ï€ _ j\n      comm := by\n        simp only [assoc, biproduct.bicone_Ï€, biproduct.map_Ï€, biproduct.map_Ï€_assoc, (F j).idem] }\n  Î¹ j :=\n    { f := biproduct.Î¹ (fun j => (F j).X) j â‰« biproduct.map fun j => (F j).p\n      comm := by simp only [biproduct.Î¹_map, assoc, idem_assoc] }\n  Î¹_Ï€ j j' := by\n    split_ifs with h\n    Â· subst h\n      simp only [biproduct.Î¹_map, biproduct.bicone_Ï€, biproduct.map_Ï€, eqToHom_refl,\n        id_f, hom_ext_iff, comp_f, assoc, bicone_Î¹_Ï€_self_assoc, idem]\n    Â· dsimp\n      simp only [biproduct.Î¹_map, biproduct.map_Ï€, hom_ext_iff, comp_f,\n        assoc, biproduct.Î¹_Ï€_ne_assoc _ h, zero_comp, comp_zero, instZero_zero]\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.Biproducts.bicone_Î¹_f","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{v, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Finite J\nF : J â†’ CategoryTheory.Idempotents.Karoubi C\nj : J\nâŠ¢ Eq ((CategoryTheory.Idempotents.Karoubi.Biproducts.bicone F).Î¹ j).f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ (fun j => (F j).X) j) (CategoryTheory.Limits.biproduct.map fun j => (F j).p))","decl":"/-- The `Bicone` used in order to obtain the existence of\nthe biproduct of a functor `J â¥¤ Karoubi C` when the category `C` is additive. -/\n@[simps]\ndef bicone [HasFiniteBiproducts C] {J : Type} [Finite J] (F : J â†’ Karoubi C) : Bicone F where\n  pt :=\n    { X := biproduct fun j => (F j).X\n      p := biproduct.map fun j => (F j).p\n      idem := by\n        ext\n        simp only [assoc, biproduct.map_Ï€, biproduct.map_Ï€_assoc, idem] }\n  Ï€ j :=\n    { f := (biproduct.map fun j => (F j).p) â‰« Bicone.Ï€ _ j\n      comm := by\n        simp only [assoc, biproduct.bicone_Ï€, biproduct.map_Ï€, biproduct.map_Ï€_assoc, (F j).idem] }\n  Î¹ j :=\n    { f := biproduct.Î¹ (fun j => (F j).X) j â‰« biproduct.map fun j => (F j).p\n      comm := by simp only [biproduct.Î¹_map, assoc, idem_assoc] }\n  Î¹_Ï€ j j' := by\n    split_ifs with h\n    Â· subst h\n      simp only [biproduct.Î¹_map, biproduct.bicone_Ï€, biproduct.map_Ï€, eqToHom_refl,\n        id_f, hom_ext_iff, comp_f, assoc, bicone_Î¹_Ï€_self_assoc, idem]\n    Â· dsimp\n      simp only [biproduct.Î¹_map, biproduct.map_Ï€, hom_ext_iff, comp_f,\n        assoc, biproduct.Î¹_Ï€_ne_assoc _ h, zero_comp, comp_zero, instZero_zero]\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.Biproducts.bicone_pt_X","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{v, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Finite J\nF : J â†’ CategoryTheory.Idempotents.Karoubi C\nâŠ¢ Eq (CategoryTheory.Idempotents.Karoubi.Biproducts.bicone F).pt.X (CategoryTheory.Limits.biproduct fun j => (F j).X)","decl":"/-- The `Bicone` used in order to obtain the existence of\nthe biproduct of a functor `J â¥¤ Karoubi C` when the category `C` is additive. -/\n@[simps]\ndef bicone [HasFiniteBiproducts C] {J : Type} [Finite J] (F : J â†’ Karoubi C) : Bicone F where\n  pt :=\n    { X := biproduct fun j => (F j).X\n      p := biproduct.map fun j => (F j).p\n      idem := by\n        ext\n        simp only [assoc, biproduct.map_Ï€, biproduct.map_Ï€_assoc, idem] }\n  Ï€ j :=\n    { f := (biproduct.map fun j => (F j).p) â‰« Bicone.Ï€ _ j\n      comm := by\n        simp only [assoc, biproduct.bicone_Ï€, biproduct.map_Ï€, biproduct.map_Ï€_assoc, (F j).idem] }\n  Î¹ j :=\n    { f := biproduct.Î¹ (fun j => (F j).X) j â‰« biproduct.map fun j => (F j).p\n      comm := by simp only [biproduct.Î¹_map, assoc, idem_assoc] }\n  Î¹_Ï€ j j' := by\n    split_ifs with h\n    Â· subst h\n      simp only [biproduct.Î¹_map, biproduct.bicone_Ï€, biproduct.map_Ï€, eqToHom_refl,\n        id_f, hom_ext_iff, comp_f, assoc, bicone_Î¹_Ï€_self_assoc, idem]\n    Â· dsimp\n      simp only [biproduct.Î¹_map, biproduct.map_Ï€, hom_ext_iff, comp_f,\n        assoc, biproduct.Î¹_Ï€_ne_assoc _ h, zero_comp, comp_zero, instZero_zero]\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.Biproducts.bicone_pt_p","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{v, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Finite J\nF : J â†’ CategoryTheory.Idempotents.Karoubi C\nâŠ¢ Eq (CategoryTheory.Idempotents.Karoubi.Biproducts.bicone F).pt.p (CategoryTheory.Limits.biproduct.map fun j => (F j).p)","decl":"/-- The `Bicone` used in order to obtain the existence of\nthe biproduct of a functor `J â¥¤ Karoubi C` when the category `C` is additive. -/\n@[simps]\ndef bicone [HasFiniteBiproducts C] {J : Type} [Finite J] (F : J â†’ Karoubi C) : Bicone F where\n  pt :=\n    { X := biproduct fun j => (F j).X\n      p := biproduct.map fun j => (F j).p\n      idem := by\n        ext\n        simp only [assoc, biproduct.map_Ï€, biproduct.map_Ï€_assoc, idem] }\n  Ï€ j :=\n    { f := (biproduct.map fun j => (F j).p) â‰« Bicone.Ï€ _ j\n      comm := by\n        simp only [assoc, biproduct.bicone_Ï€, biproduct.map_Ï€, biproduct.map_Ï€_assoc, (F j).idem] }\n  Î¹ j :=\n    { f := biproduct.Î¹ (fun j => (F j).X) j â‰« biproduct.map fun j => (F j).p\n      comm := by simp only [biproduct.Î¹_map, assoc, idem_assoc] }\n  Î¹_Ï€ j j' := by\n    split_ifs with h\n    Â· subst h\n      simp only [biproduct.Î¹_map, biproduct.bicone_Ï€, biproduct.map_Ï€, eqToHom_refl,\n        id_f, hom_ext_iff, comp_f, assoc, bicone_Î¹_Ï€_self_assoc, idem]\n    Â· dsimp\n      simp only [biproduct.Î¹_map, biproduct.map_Ï€, hom_ext_iff, comp_f,\n        assoc, biproduct.Î¹_Ï€_ne_assoc _ h, zero_comp, comp_zero, instZero_zero]\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.karoubi_hasFiniteBiproducts","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{v, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteBiproducts C\nâŠ¢ CategoryTheory.Limits.HasFiniteBiproducts (CategoryTheory.Idempotents.Karoubi C)","decl":"theorem karoubi_hasFiniteBiproducts [HasFiniteBiproducts C] : HasFiniteBiproducts (Karoubi C) :=\n  { out := fun n =>\n      { has_biproduct := fun F => by\n          apply hasBiproduct_of_total (Biproducts.bicone F)\n          simp only [hom_ext_iff]\n          refine biproduct.hom_ext' _ _ (fun j => ?_)\n          simp only [Biproducts.bicone_pt_X, sum_hom, comp_f, Biproducts.bicone_Ï€_f,\n            biproduct.bicone_Ï€, biproduct.map_Ï€, Biproducts.bicone_Î¹_f, biproduct.Î¹_map, assoc,\n            idem_assoc, id_f, Biproducts.bicone_pt_p, comp_sum]\n          rw [Finset.sum_eq_single j]\n          Â· simp only [bicone_Î¹_Ï€_self_assoc]\n          Â· intro b _ hb\n            simp only [biproduct.Î¹_Ï€_ne_assoc _ hb.symm, zero_comp]\n          Â· intro hj\n            simp only [Finset.mem_univ, not_true] at hj } }\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.complement_p","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{v, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nP : CategoryTheory.Idempotents.Karoubi C\nâŠ¢ Eq P.complement.p (HSub.hSub (CategoryTheory.CategoryStruct.id P.X) P.p)","decl":"/-- `P.complement` is the formal direct factor of `P.X` given by the idempotent\nendomorphism `ğŸ™ P.X - P.p` -/\n@[simps]\ndef complement (P : Karoubi C) : Karoubi C where\n  X := P.X\n  p := ğŸ™ _ - P.p\n  idem := idem_of_id_sub_idem P.p P.idem\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.complement_X","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{v, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nP : CategoryTheory.Idempotents.Karoubi C\nâŠ¢ Eq P.complement.X P.X","decl":"/-- `P.complement` is the formal direct factor of `P.X` given by the idempotent\nendomorphism `ğŸ™ P.X - P.p` -/\n@[simps]\ndef complement (P : Karoubi C) : Karoubi C where\n  X := P.X\n  p := ğŸ™ _ - P.p\n  idem := idem_of_id_sub_idem P.p P.idem\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.instHasBinaryBiproductComplement","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{v, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nP : CategoryTheory.Idempotents.Karoubi C\nâŠ¢ CategoryTheory.Limits.HasBinaryBiproduct P P.complement","decl":"instance (P : Karoubi C) : HasBinaryBiproduct P P.complement :=\n  hasBinaryBiproduct_of_total\n    { pt := P.X\n      fst := P.decompId_p\n      snd := P.complement.decompId_p\n      inl := P.decompId_i\n      inr := P.complement.decompId_i\n      inl_fst := P.decompId.symm\n      inl_snd := by\n        simp only [instZero_zero, hom_ext_iff, complement_X, comp_f,\n          decompId_i_f, decompId_p_f, complement_p, comp_sub, comp_id, idem, sub_self]\n      inr_fst := by\n        simp only [instZero_zero, hom_ext_iff, complement_X, comp_f,\n          decompId_i_f, complement_p, decompId_p_f, sub_comp, id_comp, idem, sub_self]\n      inr_snd := P.complement.decompId.symm }\n    (by\n      ext\n      simp only [complement_X, comp_f, decompId_i_f, decompId_p_f, complement_p, instAdd_add, idem,\n        comp_sub, comp_id, sub_comp, id_comp, sub_self, sub_zero, add_sub_cancel, id_f])\n\n"}
