{"name":"CategoryTheory.Idempotents.Karoubi.Biproducts.bicone_π_f","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{v, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst✝ : Finite J\nF : J → CategoryTheory.Idempotents.Karoubi C\nj : J\n⊢ Eq ((CategoryTheory.Idempotents.Karoubi.Biproducts.bicone F).π j).f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.map fun j => (F j).p) ((CategoryTheory.Limits.biproduct.bicone fun j => (F j).X).π j))","decl":"/-- The `Bicone` used in order to obtain the existence of\nthe biproduct of a functor `J ⥤ Karoubi C` when the category `C` is additive. -/\n@[simps]\ndef bicone [HasFiniteBiproducts C] {J : Type} [Finite J] (F : J → Karoubi C) : Bicone F where\n  pt :=\n    { X := biproduct fun j => (F j).X\n      p := biproduct.map fun j => (F j).p\n      idem := by\n        ext\n        simp only [assoc, biproduct.map_π, biproduct.map_π_assoc, idem] }\n  π j :=\n    { f := (biproduct.map fun j => (F j).p) ≫ Bicone.π _ j\n      comm := by\n        simp only [assoc, biproduct.bicone_π, biproduct.map_π, biproduct.map_π_assoc, (F j).idem] }\n  ι j :=\n    { f := biproduct.ι (fun j => (F j).X) j ≫ biproduct.map fun j => (F j).p\n      comm := by simp only [biproduct.ι_map, assoc, idem_assoc] }\n  ι_π j j' := by\n    split_ifs with h\n    · subst h\n      simp only [biproduct.ι_map, biproduct.bicone_π, biproduct.map_π, eqToHom_refl,\n        id_f, hom_ext_iff, comp_f, assoc, bicone_ι_π_self_assoc, idem]\n    · dsimp\n      simp only [biproduct.ι_map, biproduct.map_π, hom_ext_iff, comp_f,\n        assoc, biproduct.ι_π_ne_assoc _ h, zero_comp, comp_zero, instZero_zero]\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.Biproducts.bicone_ι_f","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{v, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst✝ : Finite J\nF : J → CategoryTheory.Idempotents.Karoubi C\nj : J\n⊢ Eq ((CategoryTheory.Idempotents.Karoubi.Biproducts.bicone F).ι j).f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι (fun j => (F j).X) j) (CategoryTheory.Limits.biproduct.map fun j => (F j).p))","decl":"/-- The `Bicone` used in order to obtain the existence of\nthe biproduct of a functor `J ⥤ Karoubi C` when the category `C` is additive. -/\n@[simps]\ndef bicone [HasFiniteBiproducts C] {J : Type} [Finite J] (F : J → Karoubi C) : Bicone F where\n  pt :=\n    { X := biproduct fun j => (F j).X\n      p := biproduct.map fun j => (F j).p\n      idem := by\n        ext\n        simp only [assoc, biproduct.map_π, biproduct.map_π_assoc, idem] }\n  π j :=\n    { f := (biproduct.map fun j => (F j).p) ≫ Bicone.π _ j\n      comm := by\n        simp only [assoc, biproduct.bicone_π, biproduct.map_π, biproduct.map_π_assoc, (F j).idem] }\n  ι j :=\n    { f := biproduct.ι (fun j => (F j).X) j ≫ biproduct.map fun j => (F j).p\n      comm := by simp only [biproduct.ι_map, assoc, idem_assoc] }\n  ι_π j j' := by\n    split_ifs with h\n    · subst h\n      simp only [biproduct.ι_map, biproduct.bicone_π, biproduct.map_π, eqToHom_refl,\n        id_f, hom_ext_iff, comp_f, assoc, bicone_ι_π_self_assoc, idem]\n    · dsimp\n      simp only [biproduct.ι_map, biproduct.map_π, hom_ext_iff, comp_f,\n        assoc, biproduct.ι_π_ne_assoc _ h, zero_comp, comp_zero, instZero_zero]\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.Biproducts.bicone_pt_X","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{v, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst✝ : Finite J\nF : J → CategoryTheory.Idempotents.Karoubi C\n⊢ Eq (CategoryTheory.Idempotents.Karoubi.Biproducts.bicone F).pt.X (CategoryTheory.Limits.biproduct fun j => (F j).X)","decl":"/-- The `Bicone` used in order to obtain the existence of\nthe biproduct of a functor `J ⥤ Karoubi C` when the category `C` is additive. -/\n@[simps]\ndef bicone [HasFiniteBiproducts C] {J : Type} [Finite J] (F : J → Karoubi C) : Bicone F where\n  pt :=\n    { X := biproduct fun j => (F j).X\n      p := biproduct.map fun j => (F j).p\n      idem := by\n        ext\n        simp only [assoc, biproduct.map_π, biproduct.map_π_assoc, idem] }\n  π j :=\n    { f := (biproduct.map fun j => (F j).p) ≫ Bicone.π _ j\n      comm := by\n        simp only [assoc, biproduct.bicone_π, biproduct.map_π, biproduct.map_π_assoc, (F j).idem] }\n  ι j :=\n    { f := biproduct.ι (fun j => (F j).X) j ≫ biproduct.map fun j => (F j).p\n      comm := by simp only [biproduct.ι_map, assoc, idem_assoc] }\n  ι_π j j' := by\n    split_ifs with h\n    · subst h\n      simp only [biproduct.ι_map, biproduct.bicone_π, biproduct.map_π, eqToHom_refl,\n        id_f, hom_ext_iff, comp_f, assoc, bicone_ι_π_self_assoc, idem]\n    · dsimp\n      simp only [biproduct.ι_map, biproduct.map_π, hom_ext_iff, comp_f,\n        assoc, biproduct.ι_π_ne_assoc _ h, zero_comp, comp_zero, instZero_zero]\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.Biproducts.bicone_pt_p","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{v, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst✝ : Finite J\nF : J → CategoryTheory.Idempotents.Karoubi C\n⊢ Eq (CategoryTheory.Idempotents.Karoubi.Biproducts.bicone F).pt.p (CategoryTheory.Limits.biproduct.map fun j => (F j).p)","decl":"/-- The `Bicone` used in order to obtain the existence of\nthe biproduct of a functor `J ⥤ Karoubi C` when the category `C` is additive. -/\n@[simps]\ndef bicone [HasFiniteBiproducts C] {J : Type} [Finite J] (F : J → Karoubi C) : Bicone F where\n  pt :=\n    { X := biproduct fun j => (F j).X\n      p := biproduct.map fun j => (F j).p\n      idem := by\n        ext\n        simp only [assoc, biproduct.map_π, biproduct.map_π_assoc, idem] }\n  π j :=\n    { f := (biproduct.map fun j => (F j).p) ≫ Bicone.π _ j\n      comm := by\n        simp only [assoc, biproduct.bicone_π, biproduct.map_π, biproduct.map_π_assoc, (F j).idem] }\n  ι j :=\n    { f := biproduct.ι (fun j => (F j).X) j ≫ biproduct.map fun j => (F j).p\n      comm := by simp only [biproduct.ι_map, assoc, idem_assoc] }\n  ι_π j j' := by\n    split_ifs with h\n    · subst h\n      simp only [biproduct.ι_map, biproduct.bicone_π, biproduct.map_π, eqToHom_refl,\n        id_f, hom_ext_iff, comp_f, assoc, bicone_ι_π_self_assoc, idem]\n    · dsimp\n      simp only [biproduct.ι_map, biproduct.map_π, hom_ext_iff, comp_f,\n        assoc, biproduct.ι_π_ne_assoc _ h, zero_comp, comp_zero, instZero_zero]\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.karoubi_hasFiniteBiproducts","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{v, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteBiproducts C\n⊢ CategoryTheory.Limits.HasFiniteBiproducts (CategoryTheory.Idempotents.Karoubi C)","decl":"theorem karoubi_hasFiniteBiproducts [HasFiniteBiproducts C] : HasFiniteBiproducts (Karoubi C) :=\n  { out := fun n =>\n      { has_biproduct := fun F => by\n          apply hasBiproduct_of_total (Biproducts.bicone F)\n          simp only [hom_ext_iff]\n          refine biproduct.hom_ext' _ _ (fun j => ?_)\n          simp only [Biproducts.bicone_pt_X, sum_hom, comp_f, Biproducts.bicone_π_f,\n            biproduct.bicone_π, biproduct.map_π, Biproducts.bicone_ι_f, biproduct.ι_map, assoc,\n            idem_assoc, id_f, Biproducts.bicone_pt_p, comp_sum]\n          rw [Finset.sum_eq_single j]\n          · simp only [bicone_ι_π_self_assoc]\n          · intro b _ hb\n            simp only [biproduct.ι_π_ne_assoc _ hb.symm, zero_comp]\n          · intro hj\n            simp only [Finset.mem_univ, not_true] at hj } }\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.complement_p","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nP : CategoryTheory.Idempotents.Karoubi C\n⊢ Eq P.complement.p (HSub.hSub (CategoryTheory.CategoryStruct.id P.X) P.p)","decl":"/-- `P.complement` is the formal direct factor of `P.X` given by the idempotent\nendomorphism `𝟙 P.X - P.p` -/\n@[simps]\ndef complement (P : Karoubi C) : Karoubi C where\n  X := P.X\n  p := 𝟙 _ - P.p\n  idem := idem_of_id_sub_idem P.p P.idem\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.complement_X","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nP : CategoryTheory.Idempotents.Karoubi C\n⊢ Eq P.complement.X P.X","decl":"/-- `P.complement` is the formal direct factor of `P.X` given by the idempotent\nendomorphism `𝟙 P.X - P.p` -/\n@[simps]\ndef complement (P : Karoubi C) : Karoubi C where\n  X := P.X\n  p := 𝟙 _ - P.p\n  idem := idem_of_id_sub_idem P.p P.idem\n\n"}
{"name":"CategoryTheory.Idempotents.Karoubi.instHasBinaryBiproductComplement","module":"Mathlib.CategoryTheory.Idempotents.Biproducts","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{v, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nP : CategoryTheory.Idempotents.Karoubi C\n⊢ CategoryTheory.Limits.HasBinaryBiproduct P P.complement","decl":"instance (P : Karoubi C) : HasBinaryBiproduct P P.complement :=\n  hasBinaryBiproduct_of_total\n    { pt := P.X\n      fst := P.decompId_p\n      snd := P.complement.decompId_p\n      inl := P.decompId_i\n      inr := P.complement.decompId_i\n      inl_fst := P.decompId.symm\n      inl_snd := by\n        simp only [instZero_zero, hom_ext_iff, complement_X, comp_f,\n          decompId_i_f, decompId_p_f, complement_p, comp_sub, comp_id, idem, sub_self]\n      inr_fst := by\n        simp only [instZero_zero, hom_ext_iff, complement_X, comp_f,\n          decompId_i_f, complement_p, decompId_p_f, sub_comp, id_comp, idem, sub_self]\n      inr_snd := P.complement.decompId.symm }\n    (by\n      ext\n      simp only [complement_X, comp_f, decompId_i_f, decompId_p_f, complement_p, instAdd_add, idem,\n        comp_sub, comp_id, sub_comp, id_comp, sub_self, sub_zero, add_sub_cancel, id_f])\n\n"}
