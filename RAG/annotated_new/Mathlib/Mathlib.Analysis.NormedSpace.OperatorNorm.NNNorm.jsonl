{"name":"ContinuousLinearMap.nnnorm_def","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (NNNorm.nnnorm f) (InfSet.sInf (setOf fun c => âˆ€ (x : E), LE.le (NNNorm.nnnorm (f x)) (HMul.hMul c (NNNorm.nnnorm x))))","decl":"theorem nnnorm_def (f : E â†’SL[Ïƒâ‚â‚‚] F) : â€–fâ€–â‚Š = sInf { c | âˆ€ x, â€–f xâ€–â‚Š â‰¤ c * â€–xâ€–â‚Š } := by\n  ext\n  rw [NNReal.coe_sInf, coe_nnnorm, norm_def, NNReal.coe_image]\n  simp_rw [â† NNReal.coe_le_coe, NNReal.coe_mul, coe_nnnorm, mem_setOf_eq, NNReal.coe_mk,\n    exists_prop]\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_le_bound","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nM : NNReal\nhM : âˆ€ (x : E), LE.le (NNNorm.nnnorm (f x)) (HMul.hMul M (NNNorm.nnnorm x))\nâŠ¢ LE.le (NNNorm.nnnorm f) M","decl":"/-- If one controls the norm of every `A x`, then one controls the norm of `A`. -/\ntheorem opNNNorm_le_bound (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : â„â‰¥0) (hM : âˆ€ x, â€–f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) : â€–fâ€–â‚Š â‰¤ M :=\n  opNorm_le_bound f (zero_le M) hM\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_le_bound'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nM : NNReal\nhM : âˆ€ (x : E), Ne (NNNorm.nnnorm x) 0 â†’ LE.le (NNNorm.nnnorm (f x)) (HMul.hMul M (NNNorm.nnnorm x))\nâŠ¢ LE.le (NNNorm.nnnorm f) M","decl":"/-- If one controls the norm of every `A x`, `â€–xâ€–â‚Š â‰  0`, then one controls the norm of `A`. -/\ntheorem opNNNorm_le_bound' (f : E â†’SL[Ïƒâ‚â‚‚] F) (M : â„â‰¥0) (hM : âˆ€ x, â€–xâ€–â‚Š â‰  0 â†’ â€–f xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š) :\n    â€–fâ€–â‚Š â‰¤ M :=\n  opNorm_le_bound' f (zero_le M) fun x hx => hM x <| by rwa [â† NNReal.coe_ne_zero]\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_le_of_unit_nnnorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"E : Type u_4\nF : Type u_6\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : NormedSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\nC : NNReal\nhf : âˆ€ (x : E), Eq (NNNorm.nnnorm x) 1 â†’ LE.le (NNNorm.nnnorm (f x)) C\nâŠ¢ LE.le (NNNorm.nnnorm f) C","decl":"/-- For a continuous real linear map `f`, if one controls the norm of every `f x`, `â€–xâ€–â‚Š = 1`, then\none controls the norm of `f`. -/\ntheorem opNNNorm_le_of_unit_nnnorm [NormedSpace â„ E] [NormedSpace â„ F] {f : E â†’L[â„] F} {C : â„â‰¥0}\n    (hf : âˆ€ x, â€–xâ€–â‚Š = 1 â†’ â€–f xâ€–â‚Š â‰¤ C) : â€–fâ€–â‚Š â‰¤ C :=\n  opNorm_le_of_unit_norm C.coe_nonneg fun x hx => hf x <| by rwa [â† NNReal.coe_eq_one]\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_le_of_lipschitz","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nK : NNReal\nhf : LipschitzWith K â‡‘f\nâŠ¢ LE.le (NNNorm.nnnorm f) K","decl":"theorem opNNNorm_le_of_lipschitz {f : E â†’SL[Ïƒâ‚â‚‚] F} {K : â„â‰¥0} (hf : LipschitzWith K f) :\n    â€–fâ€–â‚Š â‰¤ K :=\n  opNorm_le_of_lipschitz hf\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_eq_of_bounds","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nÏ† : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nM : NNReal\nh_above : âˆ€ (x : E), LE.le (NNNorm.nnnorm (Ï† x)) (HMul.hMul M (NNNorm.nnnorm x))\nh_below : âˆ€ (N : NNReal), (âˆ€ (x : E), LE.le (NNNorm.nnnorm (Ï† x)) (HMul.hMul N (NNNorm.nnnorm x))) â†’ LE.le M N\nâŠ¢ Eq (NNNorm.nnnorm Ï†) M","decl":"theorem opNNNorm_eq_of_bounds {Ï† : E â†’SL[Ïƒâ‚â‚‚] F} (M : â„â‰¥0) (h_above : âˆ€ x, â€–Ï† xâ€–â‚Š â‰¤ M * â€–xâ€–â‚Š)\n    (h_below : âˆ€ N, (âˆ€ x, â€–Ï† xâ€–â‚Š â‰¤ N * â€–xâ€–â‚Š) â†’ M â‰¤ N) : â€–Ï†â€–â‚Š = M :=\n  Subtype.ext <| opNorm_eq_of_bounds (zero_le M) h_above <| Subtype.forall'.mpr h_below\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_le_iff","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nC : NNReal\nâŠ¢ Iff (LE.le (NNNorm.nnnorm f) C) (âˆ€ (x : E), LE.le (NNNorm.nnnorm (f x)) (HMul.hMul C (NNNorm.nnnorm x)))","decl":"theorem opNNNorm_le_iff {f : E â†’SL[Ïƒâ‚â‚‚] F} {C : â„â‰¥0} : â€–fâ€–â‚Š â‰¤ C â†” âˆ€ x, â€–f xâ€–â‚Š â‰¤ C * â€–xâ€–â‚Š :=\n  opNorm_le_iff C.2\n\n\n"}
{"name":"ContinuousLinearMap.isLeast_opNNNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ IsLeast (setOf fun C => âˆ€ (x : E), LE.le (NNNorm.nnnorm (f x)) (HMul.hMul C (NNNorm.nnnorm x))) (NNNorm.nnnorm f)","decl":"theorem isLeast_opNNNorm : IsLeast {C : â„â‰¥0 | âˆ€ x, â€–f xâ€–â‚Š â‰¤ C * â€–xâ€–â‚Š} â€–fâ€–â‚Š := by\n  simpa only [â† opNNNorm_le_iff] using isLeast_Ici\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_comp_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹Â² : SeminormedAddCommGroup E\ninstâœÂ¹Â¹ : SeminormedAddCommGroup F\ninstâœÂ¹â° : SeminormedAddCommGroup G\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ· : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œâ‚‚ F\ninstâœâ´ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ³ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœÂ² : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚â‚ƒ\nh : ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G\ninstâœ : RingHomIsometric Ïƒâ‚â‚ƒ\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ LE.le (NNNorm.nnnorm (h.comp f)) (HMul.hMul (NNNorm.nnnorm h) (NNNorm.nnnorm f))","decl":"theorem opNNNorm_comp_le [RingHomIsometric Ïƒâ‚â‚ƒ] (f : E â†’SL[Ïƒâ‚â‚‚] F) : â€–h.comp fâ€–â‚Š â‰¤ â€–hâ€–â‚Š * â€–fâ€–â‚Š :=\n  opNorm_comp_le h f\n\n"}
{"name":"ContinuousLinearMap.opENorm_comp_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹Â² : SeminormedAddCommGroup E\ninstâœÂ¹Â¹ : SeminormedAddCommGroup F\ninstâœÂ¹â° : SeminormedAddCommGroup G\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ· : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œâ‚‚ F\ninstâœâ´ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ³ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœÂ² : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚â‚ƒ\nh : ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G\ninstâœ : RingHomIsometric Ïƒâ‚â‚ƒ\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ LE.le (ENorm.enorm (h.comp f)) (HMul.hMul (ENorm.enorm h) (ENorm.enorm f))","decl":"lemma opENorm_comp_le [RingHomIsometric Ïƒâ‚â‚ƒ] (f : E â†’SL[Ïƒâ‚â‚‚] F) : â€–h.comp fâ€–â‚‘ â‰¤ â€–hâ€–â‚‘ * â€–fâ€–â‚‘ := by\n  simpa [enorm, â† ENNReal.coe_mul] using opNNNorm_comp_le h f\n\n"}
{"name":"ContinuousLinearMap.le_opNNNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nx : E\nâŠ¢ LE.le (NNNorm.nnnorm (f x)) (HMul.hMul (NNNorm.nnnorm f) (NNNorm.nnnorm x))","decl":"theorem le_opNNNorm : â€–f xâ€–â‚Š â‰¤ â€–fâ€–â‚Š * â€–xâ€–â‚Š :=\n  f.le_opNorm x\n\n"}
{"name":"ContinuousLinearMap.le_opENorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nx : E\nâŠ¢ LE.le (ENorm.enorm (f x)) (HMul.hMul (ENorm.enorm f) (ENorm.enorm x))","decl":"lemma le_opENorm : â€–f xâ€–â‚‘ â‰¤ â€–fâ€–â‚‘ * â€–xâ€–â‚‘ := by dsimp [enorm]; exact mod_cast le_opNNNorm ..\n\n"}
{"name":"ContinuousLinearMap.nndist_le_opNNNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nx y : E\nâŠ¢ LE.le (NNDist.nndist (f x) (f y)) (HMul.hMul (NNNorm.nnnorm f) (NNDist.nndist x y))","decl":"theorem nndist_le_opNNNorm (x y : E) : nndist (f x) (f y) â‰¤ â€–fâ€–â‚Š * nndist x y :=\n  dist_le_opNorm f x y\n\n\n"}
{"name":"ContinuousLinearMap.lipschitz","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ LipschitzWith (NNNorm.nnnorm f) â‡‘f","decl":"/-- continuous linear maps are Lipschitz continuous. -/\ntheorem lipschitz : LipschitzWith â€–fâ€–â‚Š f :=\n  AddMonoidHomClass.lipschitz_of_bound_nnnorm f _ f.le_opNNNorm\n\n"}
{"name":"ContinuousLinearMap.lipschitz_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nx : E\nâŠ¢ LipschitzWith (NNNorm.nnnorm x) fun f => f x","decl":"/-- Evaluation of a continuous linear map `f` at a point is Lipschitz continuous in `f`. -/\ntheorem lipschitz_apply (x : E) : LipschitzWith â€–xâ€–â‚Š fun f : E â†’SL[Ïƒâ‚â‚‚] F => f x :=\n  lipschitzWith_iff_norm_sub_le.2 fun f g => ((f - g).le_opNorm x).trans_eq (mul_comm _ _)\n\n"}
{"name":"ContinuousLinearMap.exists_mul_lt_apply_of_lt_opNNNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nr : NNReal\nhr : LT.lt r (NNNorm.nnnorm f)\nâŠ¢ Exists fun x => LT.lt (HMul.hMul r (NNNorm.nnnorm x)) (NNNorm.nnnorm (f x))","decl":"theorem exists_mul_lt_apply_of_lt_opNNNorm (f : E â†’SL[Ïƒâ‚â‚‚] F) {r : â„â‰¥0} (hr : r < â€–fâ€–â‚Š) :\n    âˆƒ x, r * â€–xâ€–â‚Š < â€–f xâ€–â‚Š := by\n  simpa only [not_forall, not_le, Set.mem_setOf] using\n    not_mem_of_lt_csInf (nnnorm_def f â–¸ hr : r < sInf { c : â„â‰¥0 | âˆ€ x, â€–f xâ€–â‚Š â‰¤ c * â€–xâ€–â‚Š })\n      (OrderBot.bddBelow _)\n\n"}
{"name":"ContinuousLinearMap.exists_mul_lt_of_lt_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nr : Real\nhrâ‚€ : LE.le 0 r\nhr : LT.lt r (Norm.norm f)\nâŠ¢ Exists fun x => LT.lt (HMul.hMul r (Norm.norm x)) (Norm.norm (f x))","decl":"theorem exists_mul_lt_of_lt_opNorm (f : E â†’SL[Ïƒâ‚â‚‚] F) {r : â„} (hrâ‚€ : 0 â‰¤ r) (hr : r < â€–fâ€–) :\n    âˆƒ x, r * â€–xâ€– < â€–f xâ€– := by\n  lift r to â„â‰¥0 using hrâ‚€\n  exact f.exists_mul_lt_apply_of_lt_opNNNorm hr\n\n"}
{"name":"ContinuousLinearMap.exists_lt_apply_of_lt_opNNNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_11\nğ•œâ‚‚ : Type u_12\nE : Type u_13\nF : Type u_14\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : DenselyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nr : NNReal\nhr : LT.lt r (NNNorm.nnnorm f)\nâŠ¢ Exists fun x => And (LT.lt (NNNorm.nnnorm x) 1) (LT.lt r (NNNorm.nnnorm (f x)))","decl":"theorem exists_lt_apply_of_lt_opNNNorm {ğ•œ ğ•œâ‚‚ E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField ğ•œ] [NontriviallyNormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚}\n    [NormedSpace ğ•œ E] [NormedSpace ğ•œâ‚‚ F] [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) {r : â„â‰¥0}\n    (hr : r < â€–fâ€–â‚Š) : âˆƒ x : E, â€–xâ€–â‚Š < 1 âˆ§ r < â€–f xâ€–â‚Š := by\n  obtain âŸ¨y, hyâŸ© := f.exists_mul_lt_apply_of_lt_opNNNorm hr\n  have hy' : â€–yâ€–â‚Š â‰  0 :=\n    nnnorm_ne_zero_iff.2 fun heq => by\n      simp [heq, nnnorm_zero, map_zero, not_lt_zero'] at hy\n  have hfy : â€–f yâ€–â‚Š â‰  0 := (zero_le'.trans_lt hy).ne'\n  rw [â† inv_inv â€–f yâ€–â‚Š, NNReal.lt_inv_iff_mul_lt (inv_ne_zero hfy), mul_assoc, mul_comm â€–yâ€–â‚Š, â†\n    mul_assoc, â† NNReal.lt_inv_iff_mul_lt hy'] at hy\n  obtain âŸ¨k, hkâ‚, hkâ‚‚âŸ© := NormedField.exists_lt_nnnorm_lt ğ•œ hy\n  refine âŸ¨k â€¢ y, (nnnorm_smul k y).symm â–¸ (NNReal.lt_inv_iff_mul_lt hy').1 hkâ‚‚, ?_âŸ©\n  have : â€–Ïƒâ‚â‚‚ kâ€–â‚Š = â€–kâ€–â‚Š := Subtype.ext RingHomIsometric.is_iso\n  rwa [map_smulâ‚›â‚— f, nnnorm_smul, â† div_lt_iffâ‚€ hfy.bot_lt, div_eq_mul_inv, this]\n\n"}
{"name":"ContinuousLinearMap.exists_lt_apply_of_lt_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_11\nğ•œâ‚‚ : Type u_12\nE : Type u_13\nF : Type u_14\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : DenselyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nr : Real\nhr : LT.lt r (Norm.norm f)\nâŠ¢ Exists fun x => And (LT.lt (Norm.norm x) 1) (LT.lt r (Norm.norm (f x)))","decl":"theorem exists_lt_apply_of_lt_opNorm {ğ•œ ğ•œâ‚‚ E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField ğ•œ] [NontriviallyNormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚}\n    [NormedSpace ğ•œ E] [NormedSpace ğ•œâ‚‚ F] [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) {r : â„}\n    (hr : r < â€–fâ€–) : âˆƒ x : E, â€–xâ€– < 1 âˆ§ r < â€–f xâ€– := by\n  by_cases hrâ‚€ : r < 0\n  Â· exact âŸ¨0, by simpa using hrâ‚€âŸ©\n  Â· lift r to â„â‰¥0 using not_lt.1 hrâ‚€\n    exact f.exists_lt_apply_of_lt_opNNNorm hr\n\n"}
{"name":"ContinuousLinearMap.sSup_unit_ball_eq_nnnorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_11\nğ•œâ‚‚ : Type u_12\nE : Type u_13\nF : Type u_14\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : DenselyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (SupSet.sSup (Set.image (fun x => NNNorm.nnnorm (f x)) (Metric.ball 0 1))) (NNNorm.nnnorm f)","decl":"theorem sSup_unit_ball_eq_nnnorm {ğ•œ ğ•œâ‚‚ E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField ğ•œ] [NontriviallyNormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚}\n    [NormedSpace ğ•œ E] [NormedSpace ğ•œâ‚‚ F] [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) :\n    sSup ((fun x => â€–f xâ€–â‚Š) '' ball 0 1) = â€–fâ€–â‚Š := by\n  refine csSup_eq_of_forall_le_of_forall_lt_exists_gt ((nonempty_ball.mpr zero_lt_one).image _) ?_\n    fun ub hub => ?_\n  Â· rintro - âŸ¨x, hx, rflâŸ©\n    simpa only [mul_one] using f.le_opNorm_of_le (mem_ball_zero_iff.1 hx).le\n  Â· obtain âŸ¨x, hx, hxfâŸ© := f.exists_lt_apply_of_lt_opNNNorm hub\n    exact âŸ¨_, âŸ¨x, mem_ball_zero_iff.2 hx, rflâŸ©, hxfâŸ©\n\n"}
{"name":"ContinuousLinearMap.sSup_unit_ball_eq_norm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_11\nğ•œâ‚‚ : Type u_12\nE : Type u_13\nF : Type u_14\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : DenselyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (SupSet.sSup (Set.image (fun x => Norm.norm (f x)) (Metric.ball 0 1))) (Norm.norm f)","decl":"theorem sSup_unit_ball_eq_norm {ğ•œ ğ•œâ‚‚ E F : Type*} [NormedAddCommGroup E] [SeminormedAddCommGroup F]\n    [DenselyNormedField ğ•œ] [NontriviallyNormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚} [NormedSpace ğ•œ E]\n    [NormedSpace ğ•œâ‚‚ F] [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) :\n    sSup ((fun x => â€–f xâ€–) '' ball 0 1) = â€–fâ€– := by\n  simpa only [NNReal.coe_sSup, Set.image_image] using NNReal.coe_inj.2 f.sSup_unit_ball_eq_nnnorm\n\n"}
{"name":"ContinuousLinearMap.sSup_unitClosedBall_eq_nnnorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_11\nğ•œâ‚‚ : Type u_12\nE : Type u_13\nF : Type u_14\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : DenselyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (SupSet.sSup (Set.image (fun x => NNNorm.nnnorm (f x)) (Metric.closedBall 0 1))) (NNNorm.nnnorm f)","decl":"theorem sSup_unitClosedBall_eq_nnnorm {ğ•œ ğ•œâ‚‚ E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField ğ•œ] [NontriviallyNormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚}\n    [NormedSpace ğ•œ E] [NormedSpace ğ•œâ‚‚ F] [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) :\n    sSup ((fun x => â€–f xâ€–â‚Š) '' closedBall 0 1) = â€–fâ€–â‚Š := by\n  have hbdd : âˆ€ y âˆˆ (fun x => â€–f xâ€–â‚Š) '' closedBall 0 1, y â‰¤ â€–fâ€–â‚Š := by\n    rintro - âŸ¨x, hx, rflâŸ©\n    exact f.unit_le_opNorm x (mem_closedBall_zero_iff.1 hx)\n  refine le_antisymm (csSup_le ((nonempty_closedBall.mpr zero_le_one).image _) hbdd) ?_\n  rw [â† sSup_unit_ball_eq_nnnorm]\n  exact csSup_le_csSup âŸ¨â€–fâ€–â‚Š, hbddâŸ© ((nonempty_ball.2 zero_lt_one).image _)\n    (Set.image_subset _ ball_subset_closedBall)\n\n"}
{"name":"ContinuousLinearMap.sSup_closed_unit_ball_eq_nnnorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_11\nğ•œâ‚‚ : Type u_12\nE : Type u_13\nF : Type u_14\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : DenselyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (SupSet.sSup (Set.image (fun x => NNNorm.nnnorm (f x)) (Metric.closedBall 0 1))) (NNNorm.nnnorm f)","decl":"@[deprecated (since := \"2024-12-01\")]\nalias sSup_closed_unit_ball_eq_nnnorm := sSup_unitClosedBall_eq_nnnorm\n\n"}
{"name":"ContinuousLinearMap.sSup_unitClosedBall_eq_norm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_11\nğ•œâ‚‚ : Type u_12\nE : Type u_13\nF : Type u_14\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : DenselyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (SupSet.sSup (Set.image (fun x => Norm.norm (f x)) (Metric.closedBall 0 1))) (Norm.norm f)","decl":"theorem sSup_unitClosedBall_eq_norm {ğ•œ ğ•œâ‚‚ E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField ğ•œ] [NontriviallyNormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œ â†’+* ğ•œâ‚‚}\n    [NormedSpace ğ•œ E] [NormedSpace ğ•œâ‚‚ F] [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) :\n    sSup ((fun x => â€–f xâ€–) '' closedBall 0 1) = â€–fâ€– := by\n  simpa only [NNReal.coe_sSup, Set.image_image] using\n    NNReal.coe_inj.2 f.sSup_unitClosedBall_eq_nnnorm\n\n"}
{"name":"ContinuousLinearMap.sSup_closed_unit_ball_eq_norm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_11\nğ•œâ‚‚ : Type u_12\nE : Type u_13\nF : Type u_14\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : DenselyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (SupSet.sSup (Set.image (fun x => Norm.norm (f x)) (Metric.closedBall 0 1))) (Norm.norm f)","decl":"@[deprecated (since := \"2024-12-01\")]\nalias sSup_closed_unit_ball_eq_norm := sSup_unitClosedBall_eq_norm\n\n"}
{"name":"ContinuousLinearEquiv.lipschitz","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¸ : SeminormedAddCommGroup E\ninstâœâ· : SeminormedAddCommGroup F\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ : RingHom ğ•œâ‚‚ ğ•œ\ninstâœÂ² : RingHomInvPair Ïƒâ‚â‚‚ Ïƒâ‚‚â‚\ninstâœÂ¹ : RingHomInvPair Ïƒâ‚‚â‚ Ïƒâ‚â‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\ne : ContinuousLinearEquiv Ïƒâ‚â‚‚ E F\nâŠ¢ LipschitzWith (NNNorm.nnnorm â†‘e) â‡‘e","decl":"protected theorem lipschitz : LipschitzWith â€–(e : E â†’SL[Ïƒâ‚â‚‚] F)â€–â‚Š e :=\n  (e : E â†’SL[Ïƒâ‚â‚‚] F).lipschitz\n\n"}
