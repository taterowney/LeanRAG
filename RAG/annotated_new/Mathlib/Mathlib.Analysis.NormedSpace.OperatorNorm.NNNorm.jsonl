{"name":"ContinuousLinearMap.nnnorm_def","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ Eq (NNNorm.nnnorm f) (InfSet.sInf (setOf fun c => ∀ (x : E), LE.le (NNNorm.nnnorm (f x)) (HMul.hMul c (NNNorm.nnnorm x))))","decl":"theorem nnnorm_def (f : E →SL[σ₁₂] F) : ‖f‖₊ = sInf { c | ∀ x, ‖f x‖₊ ≤ c * ‖x‖₊ } := by\n  ext\n  rw [NNReal.coe_sInf, coe_nnnorm, norm_def, NNReal.coe_image]\n  simp_rw [← NNReal.coe_le_coe, NNReal.coe_mul, coe_nnnorm, mem_setOf_eq, NNReal.coe_mk,\n    exists_prop]\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_le_bound","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nM : NNReal\nhM : ∀ (x : E), LE.le (NNNorm.nnnorm (f x)) (HMul.hMul M (NNNorm.nnnorm x))\n⊢ LE.le (NNNorm.nnnorm f) M","decl":"/-- If one controls the norm of every `A x`, then one controls the norm of `A`. -/\ntheorem opNNNorm_le_bound (f : E →SL[σ₁₂] F) (M : ℝ≥0) (hM : ∀ x, ‖f x‖₊ ≤ M * ‖x‖₊) : ‖f‖₊ ≤ M :=\n  opNorm_le_bound f (zero_le M) hM\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_le_bound'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nM : NNReal\nhM : ∀ (x : E), Ne (NNNorm.nnnorm x) 0 → LE.le (NNNorm.nnnorm (f x)) (HMul.hMul M (NNNorm.nnnorm x))\n⊢ LE.le (NNNorm.nnnorm f) M","decl":"/-- If one controls the norm of every `A x`, `‖x‖₊ ≠ 0`, then one controls the norm of `A`. -/\ntheorem opNNNorm_le_bound' (f : E →SL[σ₁₂] F) (M : ℝ≥0) (hM : ∀ x, ‖x‖₊ ≠ 0 → ‖f x‖₊ ≤ M * ‖x‖₊) :\n    ‖f‖₊ ≤ M :=\n  opNorm_le_bound' f (zero_le M) fun x hx => hM x <| by rwa [← NNReal.coe_ne_zero]\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_le_of_unit_nnnorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"E : Type u_4\nF : Type u_6\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : NormedSpace Real E\ninst✝ : NormedSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\nC : NNReal\nhf : ∀ (x : E), Eq (NNNorm.nnnorm x) 1 → LE.le (NNNorm.nnnorm (f x)) C\n⊢ LE.le (NNNorm.nnnorm f) C","decl":"/-- For a continuous real linear map `f`, if one controls the norm of every `f x`, `‖x‖₊ = 1`, then\none controls the norm of `f`. -/\ntheorem opNNNorm_le_of_unit_nnnorm [NormedSpace ℝ E] [NormedSpace ℝ F] {f : E →L[ℝ] F} {C : ℝ≥0}\n    (hf : ∀ x, ‖x‖₊ = 1 → ‖f x‖₊ ≤ C) : ‖f‖₊ ≤ C :=\n  opNorm_le_of_unit_norm C.coe_nonneg fun x hx => hf x <| by rwa [← NNReal.coe_eq_one]\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_le_of_lipschitz","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nK : NNReal\nhf : LipschitzWith K ⇑f\n⊢ LE.le (NNNorm.nnnorm f) K","decl":"theorem opNNNorm_le_of_lipschitz {f : E →SL[σ₁₂] F} {K : ℝ≥0} (hf : LipschitzWith K f) :\n    ‖f‖₊ ≤ K :=\n  opNorm_le_of_lipschitz hf\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_eq_of_bounds","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nφ : ContinuousLinearMap σ₁₂ E F\nM : NNReal\nh_above : ∀ (x : E), LE.le (NNNorm.nnnorm (φ x)) (HMul.hMul M (NNNorm.nnnorm x))\nh_below : ∀ (N : NNReal), (∀ (x : E), LE.le (NNNorm.nnnorm (φ x)) (HMul.hMul N (NNNorm.nnnorm x))) → LE.le M N\n⊢ Eq (NNNorm.nnnorm φ) M","decl":"theorem opNNNorm_eq_of_bounds {φ : E →SL[σ₁₂] F} (M : ℝ≥0) (h_above : ∀ x, ‖φ x‖₊ ≤ M * ‖x‖₊)\n    (h_below : ∀ N, (∀ x, ‖φ x‖₊ ≤ N * ‖x‖₊) → M ≤ N) : ‖φ‖₊ = M :=\n  Subtype.ext <| opNorm_eq_of_bounds (zero_le M) h_above <| Subtype.forall'.mpr h_below\n\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_le_iff","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nC : NNReal\n⊢ Iff (LE.le (NNNorm.nnnorm f) C) (∀ (x : E), LE.le (NNNorm.nnnorm (f x)) (HMul.hMul C (NNNorm.nnnorm x)))","decl":"theorem opNNNorm_le_iff {f : E →SL[σ₁₂] F} {C : ℝ≥0} : ‖f‖₊ ≤ C ↔ ∀ x, ‖f x‖₊ ≤ C * ‖x‖₊ :=\n  opNorm_le_iff C.2\n\n\n"}
{"name":"ContinuousLinearMap.isLeast_opNNNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ IsLeast (setOf fun C => ∀ (x : E), LE.le (NNNorm.nnnorm (f x)) (HMul.hMul C (NNNorm.nnnorm x))) (NNNorm.nnnorm f)","decl":"theorem isLeast_opNNNorm : IsLeast {C : ℝ≥0 | ∀ x, ‖f x‖₊ ≤ C * ‖x‖₊} ‖f‖₊ := by\n  simpa only [← opNNNorm_le_iff] using isLeast_Ici\n\n"}
{"name":"ContinuousLinearMap.opNNNorm_comp_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹² : SeminormedAddCommGroup E\ninst✝¹¹ : SeminormedAddCommGroup F\ninst✝¹⁰ : SeminormedAddCommGroup G\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NontriviallyNormedField 𝕜₂\ninst✝⁷ : NontriviallyNormedField 𝕜₃\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜₂ F\ninst✝⁴ : NormedSpace 𝕜₃ G\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝³ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝² : RingHomIsometric σ₁₂\ninst✝¹ : RingHomIsometric σ₂₃\nh : ContinuousLinearMap σ₂₃ F G\ninst✝ : RingHomIsometric σ₁₃\nf : ContinuousLinearMap σ₁₂ E F\n⊢ LE.le (NNNorm.nnnorm (h.comp f)) (HMul.hMul (NNNorm.nnnorm h) (NNNorm.nnnorm f))","decl":"theorem opNNNorm_comp_le [RingHomIsometric σ₁₃] (f : E →SL[σ₁₂] F) : ‖h.comp f‖₊ ≤ ‖h‖₊ * ‖f‖₊ :=\n  opNorm_comp_le h f\n\n"}
{"name":"ContinuousLinearMap.opENorm_comp_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹² : SeminormedAddCommGroup E\ninst✝¹¹ : SeminormedAddCommGroup F\ninst✝¹⁰ : SeminormedAddCommGroup G\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NontriviallyNormedField 𝕜₂\ninst✝⁷ : NontriviallyNormedField 𝕜₃\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜₂ F\ninst✝⁴ : NormedSpace 𝕜₃ G\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝³ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝² : RingHomIsometric σ₁₂\ninst✝¹ : RingHomIsometric σ₂₃\nh : ContinuousLinearMap σ₂₃ F G\ninst✝ : RingHomIsometric σ₁₃\nf : ContinuousLinearMap σ₁₂ E F\n⊢ LE.le (ENorm.enorm (h.comp f)) (HMul.hMul (ENorm.enorm h) (ENorm.enorm f))","decl":"lemma opENorm_comp_le [RingHomIsometric σ₁₃] (f : E →SL[σ₁₂] F) : ‖h.comp f‖ₑ ≤ ‖h‖ₑ * ‖f‖ₑ := by\n  simpa [enorm, ← ENNReal.coe_mul] using opNNNorm_comp_le h f\n\n"}
{"name":"ContinuousLinearMap.le_opNNNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nx : E\n⊢ LE.le (NNNorm.nnnorm (f x)) (HMul.hMul (NNNorm.nnnorm f) (NNNorm.nnnorm x))","decl":"theorem le_opNNNorm : ‖f x‖₊ ≤ ‖f‖₊ * ‖x‖₊ :=\n  f.le_opNorm x\n\n"}
{"name":"ContinuousLinearMap.le_opENorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nx : E\n⊢ LE.le (ENorm.enorm (f x)) (HMul.hMul (ENorm.enorm f) (ENorm.enorm x))","decl":"lemma le_opENorm : ‖f x‖ₑ ≤ ‖f‖ₑ * ‖x‖ₑ := by dsimp [enorm]; exact mod_cast le_opNNNorm ..\n\n"}
{"name":"ContinuousLinearMap.nndist_le_opNNNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nx y : E\n⊢ LE.le (NNDist.nndist (f x) (f y)) (HMul.hMul (NNNorm.nnnorm f) (NNDist.nndist x y))","decl":"theorem nndist_le_opNNNorm (x y : E) : nndist (f x) (f y) ≤ ‖f‖₊ * nndist x y :=\n  dist_le_opNorm f x y\n\n\n"}
{"name":"ContinuousLinearMap.lipschitz","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ LipschitzWith (NNNorm.nnnorm f) ⇑f","decl":"/-- continuous linear maps are Lipschitz continuous. -/\ntheorem lipschitz : LipschitzWith ‖f‖₊ f :=\n  AddMonoidHomClass.lipschitz_of_bound_nnnorm f _ f.le_opNNNorm\n\n"}
{"name":"ContinuousLinearMap.lipschitz_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nx : E\n⊢ LipschitzWith (NNNorm.nnnorm x) fun f => f x","decl":"/-- Evaluation of a continuous linear map `f` at a point is Lipschitz continuous in `f`. -/\ntheorem lipschitz_apply (x : E) : LipschitzWith ‖x‖₊ fun f : E →SL[σ₁₂] F => f x :=\n  lipschitzWith_iff_norm_sub_le.2 fun f g => ((f - g).le_opNorm x).trans_eq (mul_comm _ _)\n\n"}
{"name":"ContinuousLinearMap.exists_mul_lt_apply_of_lt_opNNNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nr : NNReal\nhr : LT.lt r (NNNorm.nnnorm f)\n⊢ Exists fun x => LT.lt (HMul.hMul r (NNNorm.nnnorm x)) (NNNorm.nnnorm (f x))","decl":"theorem exists_mul_lt_apply_of_lt_opNNNorm (f : E →SL[σ₁₂] F) {r : ℝ≥0} (hr : r < ‖f‖₊) :\n    ∃ x, r * ‖x‖₊ < ‖f x‖₊ := by\n  simpa only [not_forall, not_le, Set.mem_setOf] using\n    not_mem_of_lt_csInf (nnnorm_def f ▸ hr : r < sInf { c : ℝ≥0 | ∀ x, ‖f x‖₊ ≤ c * ‖x‖₊ })\n      (OrderBot.bddBelow _)\n\n"}
{"name":"ContinuousLinearMap.exists_mul_lt_of_lt_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nr : Real\nhr₀ : LE.le 0 r\nhr : LT.lt r (Norm.norm f)\n⊢ Exists fun x => LT.lt (HMul.hMul r (Norm.norm x)) (Norm.norm (f x))","decl":"theorem exists_mul_lt_of_lt_opNorm (f : E →SL[σ₁₂] F) {r : ℝ} (hr₀ : 0 ≤ r) (hr : r < ‖f‖) :\n    ∃ x, r * ‖x‖ < ‖f x‖ := by\n  lift r to ℝ≥0 using hr₀\n  exact f.exists_mul_lt_apply_of_lt_opNNNorm hr\n\n"}
{"name":"ContinuousLinearMap.exists_lt_apply_of_lt_opNNNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_11\n𝕜₂ : Type u_12\nE : Type u_13\nF : Type u_14\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : DenselyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nr : NNReal\nhr : LT.lt r (NNNorm.nnnorm f)\n⊢ Exists fun x => And (LT.lt (NNNorm.nnnorm x) 1) (LT.lt r (NNNorm.nnnorm (f x)))","decl":"theorem exists_lt_apply_of_lt_opNNNorm {𝕜 𝕜₂ E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField 𝕜] [NontriviallyNormedField 𝕜₂] {σ₁₂ : 𝕜 →+* 𝕜₂}\n    [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] [RingHomIsometric σ₁₂] (f : E →SL[σ₁₂] F) {r : ℝ≥0}\n    (hr : r < ‖f‖₊) : ∃ x : E, ‖x‖₊ < 1 ∧ r < ‖f x‖₊ := by\n  obtain ⟨y, hy⟩ := f.exists_mul_lt_apply_of_lt_opNNNorm hr\n  have hy' : ‖y‖₊ ≠ 0 :=\n    nnnorm_ne_zero_iff.2 fun heq => by\n      simp [heq, nnnorm_zero, map_zero, not_lt_zero'] at hy\n  have hfy : ‖f y‖₊ ≠ 0 := (zero_le'.trans_lt hy).ne'\n  rw [← inv_inv ‖f y‖₊, NNReal.lt_inv_iff_mul_lt (inv_ne_zero hfy), mul_assoc, mul_comm ‖y‖₊, ←\n    mul_assoc, ← NNReal.lt_inv_iff_mul_lt hy'] at hy\n  obtain ⟨k, hk₁, hk₂⟩ := NormedField.exists_lt_nnnorm_lt 𝕜 hy\n  refine ⟨k • y, (nnnorm_smul k y).symm ▸ (NNReal.lt_inv_iff_mul_lt hy').1 hk₂, ?_⟩\n  have : ‖σ₁₂ k‖₊ = ‖k‖₊ := Subtype.ext RingHomIsometric.is_iso\n  rwa [map_smulₛₗ f, nnnorm_smul, ← div_lt_iff₀ hfy.bot_lt, div_eq_mul_inv, this]\n\n"}
{"name":"ContinuousLinearMap.exists_lt_apply_of_lt_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_11\n𝕜₂ : Type u_12\nE : Type u_13\nF : Type u_14\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : DenselyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nr : Real\nhr : LT.lt r (Norm.norm f)\n⊢ Exists fun x => And (LT.lt (Norm.norm x) 1) (LT.lt r (Norm.norm (f x)))","decl":"theorem exists_lt_apply_of_lt_opNorm {𝕜 𝕜₂ E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField 𝕜] [NontriviallyNormedField 𝕜₂] {σ₁₂ : 𝕜 →+* 𝕜₂}\n    [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] [RingHomIsometric σ₁₂] (f : E →SL[σ₁₂] F) {r : ℝ}\n    (hr : r < ‖f‖) : ∃ x : E, ‖x‖ < 1 ∧ r < ‖f x‖ := by\n  by_cases hr₀ : r < 0\n  · exact ⟨0, by simpa using hr₀⟩\n  · lift r to ℝ≥0 using not_lt.1 hr₀\n    exact f.exists_lt_apply_of_lt_opNNNorm hr\n\n"}
{"name":"ContinuousLinearMap.sSup_unit_ball_eq_nnnorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_11\n𝕜₂ : Type u_12\nE : Type u_13\nF : Type u_14\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : DenselyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ Eq (SupSet.sSup (Set.image (fun x => NNNorm.nnnorm (f x)) (Metric.ball 0 1))) (NNNorm.nnnorm f)","decl":"theorem sSup_unit_ball_eq_nnnorm {𝕜 𝕜₂ E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField 𝕜] [NontriviallyNormedField 𝕜₂] {σ₁₂ : 𝕜 →+* 𝕜₂}\n    [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] [RingHomIsometric σ₁₂] (f : E →SL[σ₁₂] F) :\n    sSup ((fun x => ‖f x‖₊) '' ball 0 1) = ‖f‖₊ := by\n  refine csSup_eq_of_forall_le_of_forall_lt_exists_gt ((nonempty_ball.mpr zero_lt_one).image _) ?_\n    fun ub hub => ?_\n  · rintro - ⟨x, hx, rfl⟩\n    simpa only [mul_one] using f.le_opNorm_of_le (mem_ball_zero_iff.1 hx).le\n  · obtain ⟨x, hx, hxf⟩ := f.exists_lt_apply_of_lt_opNNNorm hub\n    exact ⟨_, ⟨x, mem_ball_zero_iff.2 hx, rfl⟩, hxf⟩\n\n"}
{"name":"ContinuousLinearMap.sSup_unit_ball_eq_norm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_11\n𝕜₂ : Type u_12\nE : Type u_13\nF : Type u_14\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : DenselyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ Eq (SupSet.sSup (Set.image (fun x => Norm.norm (f x)) (Metric.ball 0 1))) (Norm.norm f)","decl":"theorem sSup_unit_ball_eq_norm {𝕜 𝕜₂ E F : Type*} [NormedAddCommGroup E] [SeminormedAddCommGroup F]\n    [DenselyNormedField 𝕜] [NontriviallyNormedField 𝕜₂] {σ₁₂ : 𝕜 →+* 𝕜₂} [NormedSpace 𝕜 E]\n    [NormedSpace 𝕜₂ F] [RingHomIsometric σ₁₂] (f : E →SL[σ₁₂] F) :\n    sSup ((fun x => ‖f x‖) '' ball 0 1) = ‖f‖ := by\n  simpa only [NNReal.coe_sSup, Set.image_image] using NNReal.coe_inj.2 f.sSup_unit_ball_eq_nnnorm\n\n"}
{"name":"ContinuousLinearMap.sSup_unitClosedBall_eq_nnnorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_11\n𝕜₂ : Type u_12\nE : Type u_13\nF : Type u_14\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : DenselyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ Eq (SupSet.sSup (Set.image (fun x => NNNorm.nnnorm (f x)) (Metric.closedBall 0 1))) (NNNorm.nnnorm f)","decl":"theorem sSup_unitClosedBall_eq_nnnorm {𝕜 𝕜₂ E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField 𝕜] [NontriviallyNormedField 𝕜₂] {σ₁₂ : 𝕜 →+* 𝕜₂}\n    [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] [RingHomIsometric σ₁₂] (f : E →SL[σ₁₂] F) :\n    sSup ((fun x => ‖f x‖₊) '' closedBall 0 1) = ‖f‖₊ := by\n  have hbdd : ∀ y ∈ (fun x => ‖f x‖₊) '' closedBall 0 1, y ≤ ‖f‖₊ := by\n    rintro - ⟨x, hx, rfl⟩\n    exact f.unit_le_opNorm x (mem_closedBall_zero_iff.1 hx)\n  refine le_antisymm (csSup_le ((nonempty_closedBall.mpr zero_le_one).image _) hbdd) ?_\n  rw [← sSup_unit_ball_eq_nnnorm]\n  exact csSup_le_csSup ⟨‖f‖₊, hbdd⟩ ((nonempty_ball.2 zero_lt_one).image _)\n    (Set.image_subset _ ball_subset_closedBall)\n\n"}
{"name":"ContinuousLinearMap.sSup_closed_unit_ball_eq_nnnorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_11\n𝕜₂ : Type u_12\nE : Type u_13\nF : Type u_14\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : DenselyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ Eq (SupSet.sSup (Set.image (fun x => NNNorm.nnnorm (f x)) (Metric.closedBall 0 1))) (NNNorm.nnnorm f)","decl":"@[deprecated (since := \"2024-12-01\")]\nalias sSup_closed_unit_ball_eq_nnnorm := sSup_unitClosedBall_eq_nnnorm\n\n"}
{"name":"ContinuousLinearMap.sSup_unitClosedBall_eq_norm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_11\n𝕜₂ : Type u_12\nE : Type u_13\nF : Type u_14\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : DenselyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ Eq (SupSet.sSup (Set.image (fun x => Norm.norm (f x)) (Metric.closedBall 0 1))) (Norm.norm f)","decl":"theorem sSup_unitClosedBall_eq_norm {𝕜 𝕜₂ E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField 𝕜] [NontriviallyNormedField 𝕜₂] {σ₁₂ : 𝕜 →+* 𝕜₂}\n    [NormedSpace 𝕜 E] [NormedSpace 𝕜₂ F] [RingHomIsometric σ₁₂] (f : E →SL[σ₁₂] F) :\n    sSup ((fun x => ‖f x‖) '' closedBall 0 1) = ‖f‖ := by\n  simpa only [NNReal.coe_sSup, Set.image_image] using\n    NNReal.coe_inj.2 f.sSup_unitClosedBall_eq_nnnorm\n\n"}
{"name":"ContinuousLinearMap.sSup_closed_unit_ball_eq_norm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_11\n𝕜₂ : Type u_12\nE : Type u_13\nF : Type u_14\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : DenselyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ Eq (SupSet.sSup (Set.image (fun x => Norm.norm (f x)) (Metric.closedBall 0 1))) (Norm.norm f)","decl":"@[deprecated (since := \"2024-12-01\")]\nalias sSup_closed_unit_ball_eq_norm := sSup_unitClosedBall_eq_norm\n\n"}
{"name":"ContinuousLinearEquiv.lipschitz","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.NNNorm","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁸ : SeminormedAddCommGroup E\ninst✝⁷ : SeminormedAddCommGroup F\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₁ : RingHom 𝕜₂ 𝕜\ninst✝² : RingHomInvPair σ₁₂ σ₂₁\ninst✝¹ : RingHomInvPair σ₂₁ σ₁₂\ninst✝ : RingHomIsometric σ₁₂\ne : ContinuousLinearEquiv σ₁₂ E F\n⊢ LipschitzWith (NNNorm.nnnorm ↑e) ⇑e","decl":"protected theorem lipschitz : LipschitzWith ‖(e : E →SL[σ₁₂] F)‖₊ e :=\n  (e : E →SL[σ₁₂] F).lipschitz\n\n"}
