{"name":"CategoryTheory.frobeniusMorphism_iso_of_preserves_binary_products","module":"Mathlib.CategoryTheory.Closed.Functor","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v, u'} D\ninst✝⁴ : CategoryTheory.ChosenFiniteProducts C\ninst✝³ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nL : CategoryTheory.Functor D C\nh : CategoryTheory.Adjunction L F\nA : C\ninst✝² : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) L\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ CategoryTheory.IsIso (CategoryTheory.frobeniusMorphism F h A)","decl":"/-- If `F` is full and faithful and has a left adjoint `L` which preserves binary products, then the\nFrobenius morphism is an isomorphism.\n-/\ninstance frobeniusMorphism_iso_of_preserves_binary_products (h : L ⊣ F) (A : C)\n    [Limits.PreservesLimitsOfShape (Discrete Limits.WalkingPair) L] [F.Full] [F.Faithful] :\n    IsIso (frobeniusMorphism F h A) :=\n  suffices ∀ (X : D), IsIso ((frobeniusMorphism F h A).app X) from NatIso.isIso_of_isIso_app _\n  fun B ↦ by dsimp [frobeniusMorphism]; infer_instance\n\n"}
{"name":"CategoryTheory.expComparison_ev","module":"Mathlib.CategoryTheory.Closed.Functor","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v, u'} D\ninst✝⁴ : CategoryTheory.ChosenFiniteProducts C\ninst✝³ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.CartesianClosed C\ninst✝¹ : CategoryTheory.CartesianClosed D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\nA B : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj A) ((CategoryTheory.expComparison F A).app B)) ((CategoryTheory.exp.ev (F.obj A)).app (F.obj B))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A ((CategoryTheory.exp A).obj B))) (F.map ((CategoryTheory.exp.ev A).app B)))","decl":"theorem expComparison_ev (A B : C) :\n    F.obj A ◁ ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =\n      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by\n  convert mateEquiv_counit _ _ (prodComparisonNatIso F A).inv B using 2\n  apply IsIso.inv_eq_of_hom_inv_id -- Porting note: was `ext`\n  simp only [prodComparisonNatTrans_app, prodComparisonNatIso_inv, asIso_inv, NatIso.isIso_inv_app,\n    IsIso.hom_inv_id]\n\n"}
{"name":"CategoryTheory.coev_expComparison","module":"Mathlib.CategoryTheory.Closed.Functor","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v, u'} D\ninst✝⁴ : CategoryTheory.ChosenFiniteProducts C\ninst✝³ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.CartesianClosed C\ninst✝¹ : CategoryTheory.CartesianClosed D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\nA B : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.exp.coev A).app B)) ((CategoryTheory.expComparison F A).app (CategoryTheory.MonoidalCategoryStruct.tensorObj A B))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.exp.coev (F.obj A)).app (F.obj B)) ((CategoryTheory.exp (F.obj A)).map (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A B))))","decl":"theorem coev_expComparison (A B : C) :\n    F.map ((exp.coev A).app B) ≫ (expComparison F A).app (A ⊗ B) =\n      (exp.coev _).app (F.obj B) ≫ (exp (F.obj A)).map (inv (prodComparison F A B)) := by\n  convert unit_mateEquiv _ _ (prodComparisonNatIso F A).inv B using 3\n  apply IsIso.inv_eq_of_hom_inv_id -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): was `ext`\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.uncurry_expComparison","module":"Mathlib.CategoryTheory.Closed.Functor","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v, u'} D\ninst✝⁴ : CategoryTheory.ChosenFiniteProducts C\ninst✝³ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.CartesianClosed C\ninst✝¹ : CategoryTheory.CartesianClosed D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\nA B : C\n⊢ Eq (CategoryTheory.CartesianClosed.uncurry ((CategoryTheory.expComparison F A).app B)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (CategoryTheory.ChosenFiniteProducts.prodComparison F A ((CategoryTheory.exp A).obj B))) (F.map ((CategoryTheory.exp.ev A).app B)))","decl":"theorem uncurry_expComparison (A B : C) :\n    CartesianClosed.uncurry ((expComparison F A).app B) =\n      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by\n  rw [uncurry_eq, expComparison_ev]\n\n"}
{"name":"CategoryTheory.expComparison_whiskerLeft","module":"Mathlib.CategoryTheory.Closed.Functor","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v, u'} D\ninst✝⁴ : CategoryTheory.ChosenFiniteProducts C\ninst✝³ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.CartesianClosed C\ninst✝¹ : CategoryTheory.CartesianClosed D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\nA A' : C\nf : Quiver.Hom A' A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.expComparison F A) (CategoryTheory.whiskerLeft F (CategoryTheory.pre (F.map f)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.pre f) F) (CategoryTheory.expComparison F A'))","decl":"/-- The exponential comparison map is natural in `A`. -/\ntheorem expComparison_whiskerLeft {A A' : C} (f : A' ⟶ A) :\n    expComparison F A ≫ whiskerLeft _ (pre (F.map f)) =\n      whiskerRight (pre f) _ ≫ expComparison F A' := by\n  unfold expComparison pre\n  have vcomp1 := mateEquiv_conjugateEquiv_vcomp\n    (exp.adjunction A) (exp.adjunction (F.obj A)) (exp.adjunction (F.obj A'))\n    ((prodComparisonNatIso F A).inv) (((curriedTensor D).map (F.map f)))\n  have vcomp2 := conjugateEquiv_mateEquiv_vcomp\n    (exp.adjunction A) (exp.adjunction A') (exp.adjunction (F.obj A'))\n    (((curriedTensor C).map f)) ((prodComparisonNatIso F A').inv)\n  unfold leftAdjointSquareConjugate.vcomp rightAdjointSquareConjugate.vcomp at vcomp1\n  unfold leftAdjointConjugateSquare.vcomp rightAdjointConjugateSquare.vcomp at vcomp2\n  rw [← vcomp1, ← vcomp2]\n  apply congr_arg\n  ext B\n  simp only [Functor.comp_obj, tensorLeft_obj, prodComparisonNatIso_inv, asIso_inv,\n    NatTrans.comp_app, whiskerLeft_app, curriedTensor_map_app, NatIso.isIso_inv_app,\n    whiskerRight_app, IsIso.eq_inv_comp, prodComparisonNatTrans_app]\n  rw [← prodComparison_inv_natural_whiskerRight F f]\n  simp\n\n"}
{"name":"CategoryTheory.CartesianClosedFunctor.comparison_iso","module":"Mathlib.CategoryTheory.Closed.Functor","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v, u'} D\ninst✝⁴ : CategoryTheory.ChosenFiniteProducts C\ninst✝³ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.CartesianClosed C\ninst✝¹ : CategoryTheory.CartesianClosed D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\nself : CategoryTheory.CartesianClosedFunctor F\nA : C\n⊢ CategoryTheory.IsIso (CategoryTheory.expComparison F A)","decl":"/-- The functor `F` is cartesian closed (ie preserves exponentials) if each natural transformation\n`exp_comparison F A` is an isomorphism\n-/\nclass CartesianClosedFunctor : Prop where\n  comparison_iso : ∀ A, IsIso (expComparison F A)\n\n"}
{"name":"CategoryTheory.frobeniusMorphism_mate","module":"Mathlib.CategoryTheory.Closed.Functor","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v, u'} D\ninst✝⁴ : CategoryTheory.ChosenFiniteProducts C\ninst✝³ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nL : CategoryTheory.Functor D C\ninst✝² : CategoryTheory.CartesianClosed C\ninst✝¹ : CategoryTheory.CartesianClosed D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\nh : CategoryTheory.Adjunction L F\nA : C\n⊢ Eq ((CategoryTheory.conjugateEquiv (h.comp (CategoryTheory.exp.adjunction A)) ((CategoryTheory.exp.adjunction (F.obj A)).comp h)) (CategoryTheory.frobeniusMorphism F h A)) (CategoryTheory.expComparison F A)","decl":"theorem frobeniusMorphism_mate (h : L ⊣ F) (A : C) :\n    conjugateEquiv (h.comp (exp.adjunction A)) ((exp.adjunction (F.obj A)).comp h)\n        (frobeniusMorphism F h A) =\n      expComparison F A := by\n  unfold expComparison frobeniusMorphism\n  have conjeq := iterated_mateEquiv_conjugateEquiv h h\n    (exp.adjunction (F.obj A)) (exp.adjunction A)\n    (prodComparisonNatTrans L (F.obj A) ≫ whiskerLeft L ((curriedTensor C).map (h.counit.app A)))\n  rw [← conjeq]\n  apply congr_arg\n  ext B\n  unfold mateEquiv\n  simp only [Functor.comp_obj, tensorLeft_obj, Functor.id_obj, Equiv.coe_fn_mk, whiskerLeft_comp,\n    whiskerLeft_twice, whiskerRight_comp, assoc, NatTrans.comp_app, whiskerLeft_app,\n    curriedTensor_obj_obj, whiskerRight_app, prodComparisonNatTrans_app, curriedTensor_map_app,\n    Functor.comp_map, tensorLeft_map, prodComparisonNatIso_inv, asIso_inv, NatIso.isIso_inv_app]\n  rw [← F.map_comp, ← F.map_comp]\n  simp only [Functor.map_comp]\n  apply IsIso.eq_inv_of_inv_hom_id\n  simp only [assoc]\n  rw [prodComparison_natural_whiskerLeft, prodComparison_natural_whiskerRight_assoc]\n  slice_lhs 2 3 => rw [← prodComparison_comp]\n  simp only [assoc]\n  unfold prodComparison\n  have ηlemma : (h.unit.app (F.obj A ⊗ F.obj B) ≫\n    lift ((L ⋙ F).map (fst _ _)) ((L ⋙ F).map (snd _ _))) =\n      (h.unit.app (F.obj A)) ⊗ (h.unit.app (F.obj B)) := by\n    ext <;> simp\n  slice_lhs 1 2 => rw [ηlemma]\n  simp only [Functor.id_obj, Functor.comp_obj, assoc, ← whisker_exchange, ← tensorHom_def']\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.frobeniusMorphism_iso_of_expComparison_iso","module":"Mathlib.CategoryTheory.Closed.Functor","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v, u'} D\ninst✝⁴ : CategoryTheory.ChosenFiniteProducts C\ninst✝³ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nL : CategoryTheory.Functor D C\ninst✝² : CategoryTheory.CartesianClosed C\ninst✝¹ : CategoryTheory.CartesianClosed D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\nh : CategoryTheory.Adjunction L F\nA : C\ni : CategoryTheory.IsIso (CategoryTheory.expComparison F A)\n⊢ CategoryTheory.IsIso (CategoryTheory.frobeniusMorphism F h A)","decl":"/--\nIf the exponential comparison transformation (at `A`) is an isomorphism, then the Frobenius morphism\nat `A` is an isomorphism.\n-/\ntheorem frobeniusMorphism_iso_of_expComparison_iso (h : L ⊣ F) (A : C)\n    [i : IsIso (expComparison F A)] : IsIso (frobeniusMorphism F h A) := by\n  rw [← frobeniusMorphism_mate F h] at i\n  exact @conjugateEquiv_of_iso _ _ _ _ _ _ _ _ _ _ _ i\n\n"}
{"name":"CategoryTheory.expComparison_iso_of_frobeniusMorphism_iso","module":"Mathlib.CategoryTheory.Closed.Functor","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v, u'} D\ninst✝⁴ : CategoryTheory.ChosenFiniteProducts C\ninst✝³ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nL : CategoryTheory.Functor D C\ninst✝² : CategoryTheory.CartesianClosed C\ninst✝¹ : CategoryTheory.CartesianClosed D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\nh : CategoryTheory.Adjunction L F\nA : C\ni : CategoryTheory.IsIso (CategoryTheory.frobeniusMorphism F h A)\n⊢ CategoryTheory.IsIso (CategoryTheory.expComparison F A)","decl":"/--\nIf the Frobenius morphism at `A` is an isomorphism, then the exponential comparison transformation\n(at `A`) is an isomorphism.\n-/\ntheorem expComparison_iso_of_frobeniusMorphism_iso (h : L ⊣ F) (A : C)\n    [i : IsIso (frobeniusMorphism F h A)] : IsIso (expComparison F A) := by\n  rw [← frobeniusMorphism_mate F h]; infer_instance\n\n"}
{"name":"CategoryTheory.cartesianClosedFunctorOfLeftAdjointPreservesBinaryProducts","module":"Mathlib.CategoryTheory.Closed.Functor","initialProofState":"C : Type u\ninst✝⁹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁸ : CategoryTheory.Category.{v, u'} D\ninst✝⁷ : CategoryTheory.ChosenFiniteProducts C\ninst✝⁶ : CategoryTheory.ChosenFiniteProducts D\nF : CategoryTheory.Functor C D\nL : CategoryTheory.Functor D C\ninst✝⁵ : CategoryTheory.CartesianClosed C\ninst✝⁴ : CategoryTheory.CartesianClosed D\ninst✝³ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\nh : CategoryTheory.Adjunction L F\ninst✝² : F.Full\ninst✝¹ : F.Faithful\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) L\n⊢ CategoryTheory.CartesianClosedFunctor F","decl":"open Limits in\n/-- If `F` is full and faithful, and has a left adjoint which preserves binary products, then it is\ncartesian closed.\n\nTODO: Show the converse, that if `F` is cartesian closed and its left adjoint preserves binary\nproducts, then it is full and faithful.\n-/\ntheorem cartesianClosedFunctorOfLeftAdjointPreservesBinaryProducts (h : L ⊣ F) [F.Full] [F.Faithful]\n    [PreservesLimitsOfShape (Discrete WalkingPair) L] : CartesianClosedFunctor F where\n  comparison_iso _ := expComparison_iso_of_frobeniusMorphism_iso F h _\n\n"}
