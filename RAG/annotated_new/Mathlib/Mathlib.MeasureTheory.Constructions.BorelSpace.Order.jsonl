{"name":"borel_eq_generateFrom_Iio","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : SecondCountableTopology α\ninst✝¹ : LinearOrder α\ninst✝ : OrderTopology α\n⊢ Eq (borel α) (MeasurableSpace.generateFrom (Set.range Set.Iio))","decl":"theorem borel_eq_generateFrom_Iio : borel α = .generateFrom (range Iio) := by\n  refine le_antisymm ?_ (generateFrom_le ?_)\n  · rw [borel_eq_generateFrom_of_subbasis (@OrderTopology.topology_eq_generate_intervals α _ _ _)]\n    letI : MeasurableSpace α := MeasurableSpace.generateFrom (range Iio)\n    have H : ∀ a : α, MeasurableSet (Iio a) := fun a => GenerateMeasurable.basic _ ⟨_, rfl⟩\n    refine generateFrom_le ?_\n    rintro _ ⟨a, rfl | rfl⟩\n    · rcases em (∃ b, a ⋖ b) with ⟨b, hb⟩ | hcovBy\n      · rw [hb.Ioi_eq, ← compl_Iio]\n        exact (H _).compl\n      · rcases isOpen_biUnion_countable (Ioi a) Ioi fun _ _ ↦ isOpen_Ioi with ⟨t, hat, htc, htU⟩\n        have : Ioi a = ⋃ b ∈ t, Ici b := by\n          refine Subset.antisymm ?_ <| iUnion₂_subset fun b hb ↦ Ici_subset_Ioi.2 (hat hb)\n          refine Subset.trans ?_ <| iUnion₂_mono fun _ _ ↦ Ioi_subset_Ici_self\n          simpa [CovBy, htU, subset_def] using hcovBy\n        simp only [this, ← compl_Iio]\n        exact .biUnion htc <| fun _ _ ↦ (H _).compl\n    · apply H\n  · rw [forall_mem_range]\n    intro a\n    exact GenerateMeasurable.basic _ isOpen_Iio\n\n"}
{"name":"borel_eq_generateFrom_Ioi","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : SecondCountableTopology α\ninst✝¹ : LinearOrder α\ninst✝ : OrderTopology α\n⊢ Eq (borel α) (MeasurableSpace.generateFrom (Set.range Set.Ioi))","decl":"theorem borel_eq_generateFrom_Ioi : borel α = .generateFrom (range Ioi) :=\n  @borel_eq_generateFrom_Iio αᵒᵈ _ (by infer_instance : SecondCountableTopology α) _ _\n\n"}
{"name":"borel_eq_generateFrom_Iic","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : SecondCountableTopology α\ninst✝¹ : LinearOrder α\ninst✝ : OrderTopology α\n⊢ Eq (borel α) (MeasurableSpace.generateFrom (Set.range Set.Iic))","decl":"theorem borel_eq_generateFrom_Iic :\n    borel α = MeasurableSpace.generateFrom (range Iic) := by\n  rw [borel_eq_generateFrom_Ioi]\n  refine le_antisymm ?_ ?_\n  · refine MeasurableSpace.generateFrom_le fun t ht => ?_\n    obtain ⟨u, rfl⟩ := ht\n    rw [← compl_Iic]\n    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr ⟨u, rfl⟩)).compl\n  · refine MeasurableSpace.generateFrom_le fun t ht => ?_\n    obtain ⟨u, rfl⟩ := ht\n    rw [← compl_Ioi]\n    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr ⟨u, rfl⟩)).compl\n\n"}
{"name":"borel_eq_generateFrom_Ici","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : SecondCountableTopology α\ninst✝¹ : LinearOrder α\ninst✝ : OrderTopology α\n⊢ Eq (borel α) (MeasurableSpace.generateFrom (Set.range Set.Ici))","decl":"theorem borel_eq_generateFrom_Ici : borel α = MeasurableSpace.generateFrom (range Ici) :=\n  @borel_eq_generateFrom_Iic αᵒᵈ _ _ _ _\n\n"}
{"name":"measurableSet_Ici","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : Preorder α\ninst✝ : OrderClosedTopology α\na : α\n⊢ MeasurableSet (Set.Ici a)","decl":"@[simp, measurability]\ntheorem measurableSet_Ici : MeasurableSet (Ici a) :=\n  isClosed_Ici.measurableSet\n\n"}
{"name":"nullMeasurableSet_Ici","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : Preorder α\ninst✝ : OrderClosedTopology α\na : α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.NullMeasurableSet (Set.Ici a) μ","decl":"theorem nullMeasurableSet_Ici : NullMeasurableSet (Ici a) μ :=\n  measurableSet_Ici.nullMeasurableSet\n\n"}
{"name":"measurableSet_Iic","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : Preorder α\ninst✝ : OrderClosedTopology α\na : α\n⊢ MeasurableSet (Set.Iic a)","decl":"@[simp, measurability]\ntheorem measurableSet_Iic : MeasurableSet (Iic a) :=\n  isClosed_Iic.measurableSet\n\n"}
{"name":"nullMeasurableSet_Iic","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : Preorder α\ninst✝ : OrderClosedTopology α\na : α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.NullMeasurableSet (Set.Iic a) μ","decl":"theorem nullMeasurableSet_Iic : NullMeasurableSet (Iic a) μ :=\n  measurableSet_Iic.nullMeasurableSet\n\n"}
{"name":"measurableSet_Icc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : Preorder α\ninst✝ : OrderClosedTopology α\na b : α\n⊢ MeasurableSet (Set.Icc a b)","decl":"@[simp, measurability]\ntheorem measurableSet_Icc : MeasurableSet (Icc a b) :=\n  isClosed_Icc.measurableSet\n\n"}
{"name":"nullMeasurableSet_Icc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : Preorder α\ninst✝ : OrderClosedTopology α\na b : α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.NullMeasurableSet (Set.Icc a b) μ","decl":"theorem nullMeasurableSet_Icc : NullMeasurableSet (Icc a b) μ :=\n  measurableSet_Icc.nullMeasurableSet\n\n"}
{"name":"nhdsWithin_Ici_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : Preorder α\ninst✝ : OrderClosedTopology α\na b : α\n⊢ (nhdsWithin a (Set.Ici b)).IsMeasurablyGenerated","decl":"instance nhdsWithin_Ici_isMeasurablyGenerated : (𝓝[Ici b] a).IsMeasurablyGenerated :=\n  measurableSet_Ici.nhdsWithin_isMeasurablyGenerated _\n\n"}
{"name":"nhdsWithin_Iic_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : Preorder α\ninst✝ : OrderClosedTopology α\na b : α\n⊢ (nhdsWithin a (Set.Iic b)).IsMeasurablyGenerated","decl":"instance nhdsWithin_Iic_isMeasurablyGenerated : (𝓝[Iic b] a).IsMeasurablyGenerated :=\n  measurableSet_Iic.nhdsWithin_isMeasurablyGenerated _\n\n"}
{"name":"nhdsWithin_Icc_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝ : Preorder α\na b x : α\n⊢ (nhdsWithin x (Set.Icc a b)).IsMeasurablyGenerated","decl":"instance nhdsWithin_Icc_isMeasurablyGenerated : IsMeasurablyGenerated (𝓝[Icc a b] x) := by\n  rw [← Ici_inter_Iic, nhdsWithin_inter]\n  infer_instance\n\n"}
{"name":"atTop_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : Preorder α\ninst✝ : OrderClosedTopology α\n⊢ Filter.atTop.IsMeasurablyGenerated","decl":"instance atTop_isMeasurablyGenerated : (Filter.atTop : Filter α).IsMeasurablyGenerated :=\n  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>\n    (measurableSet_Ici : MeasurableSet (Ici a)).principal_isMeasurablyGenerated\n\n"}
{"name":"atBot_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : Preorder α\ninst✝ : OrderClosedTopology α\n⊢ Filter.atBot.IsMeasurablyGenerated","decl":"instance atBot_isMeasurablyGenerated : (Filter.atBot : Filter α).IsMeasurablyGenerated :=\n  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>\n    (measurableSet_Iic : MeasurableSet (Iic a)).principal_isMeasurablyGenerated\n\n"}
{"name":"instIsMeasurablyGeneratedCocompactOfR1Space","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝ : R1Space α\n⊢ (Filter.cocompact α).IsMeasurablyGenerated","decl":"instance [R1Space α] : IsMeasurablyGenerated (cocompact α) where\n  exists_measurable_subset := by\n    intro _ hs\n    obtain ⟨t, ht, hts⟩ := mem_cocompact.mp hs\n    exact ⟨(closure t)ᶜ, ht.closure.compl_mem_cocompact, isClosed_closure.measurableSet.compl,\n      (compl_subset_compl.2 subset_closure).trans hts⟩\n\n"}
{"name":"measurableSet_le'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\ninst✝² : PartialOrder α\ninst✝¹ : OrderClosedTopology α\ninst✝ : SecondCountableTopology α\n⊢ MeasurableSet (setOf fun p => LE.le p.1 p.2)","decl":"@[measurability]\ntheorem measurableSet_le' : MeasurableSet { p : α × α | p.1 ≤ p.2 } :=\n  OrderClosedTopology.isClosed_le'.measurableSet\n\n"}
{"name":"measurableSet_le","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\nmδ : MeasurableSpace δ\ninst✝² : PartialOrder α\ninst✝¹ : OrderClosedTopology α\ninst✝ : SecondCountableTopology α\nf g : δ → α\nhf : Measurable f\nhg : Measurable g\n⊢ MeasurableSet (setOf fun a => LE.le (f a) (g a))","decl":"@[measurability]\ntheorem measurableSet_le {f g : δ → α} (hf : Measurable f) (hg : Measurable g) :\n    MeasurableSet { a | f a ≤ g a } :=\n  hf.prod_mk hg measurableSet_le'\n\n"}
{"name":"measurableSet_Iio","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na : α\n⊢ MeasurableSet (Set.Iio a)","decl":"@[simp, measurability]\ntheorem measurableSet_Iio : MeasurableSet (Iio a) :=\n  isOpen_Iio.measurableSet\n\n"}
{"name":"nullMeasurableSet_Iio","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na : α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.NullMeasurableSet (Set.Iio a) μ","decl":"theorem nullMeasurableSet_Iio : NullMeasurableSet (Iio a) μ :=\n  measurableSet_Iio.nullMeasurableSet\n\n"}
{"name":"measurableSet_Ioi","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na : α\n⊢ MeasurableSet (Set.Ioi a)","decl":"@[simp, measurability]\ntheorem measurableSet_Ioi : MeasurableSet (Ioi a) :=\n  isOpen_Ioi.measurableSet\n\n"}
{"name":"nullMeasurableSet_Ioi","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na : α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.NullMeasurableSet (Set.Ioi a) μ","decl":"theorem nullMeasurableSet_Ioi : NullMeasurableSet (Ioi a) μ :=\n  measurableSet_Ioi.nullMeasurableSet\n\n"}
{"name":"measurableSet_Ioo","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na b : α\n⊢ MeasurableSet (Set.Ioo a b)","decl":"@[simp, measurability]\ntheorem measurableSet_Ioo : MeasurableSet (Ioo a b) :=\n  isOpen_Ioo.measurableSet\n\n"}
{"name":"nullMeasurableSet_Ioo","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na b : α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.NullMeasurableSet (Set.Ioo a b) μ","decl":"theorem nullMeasurableSet_Ioo : NullMeasurableSet (Ioo a b) μ :=\n  measurableSet_Ioo.nullMeasurableSet\n\n"}
{"name":"measurableSet_Ioc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na b : α\n⊢ MeasurableSet (Set.Ioc a b)","decl":"@[simp, measurability]\ntheorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=\n  measurableSet_Ioi.inter measurableSet_Iic\n\n"}
{"name":"nullMeasurableSet_Ioc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na b : α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.NullMeasurableSet (Set.Ioc a b) μ","decl":"theorem nullMeasurableSet_Ioc : NullMeasurableSet (Ioc a b) μ :=\n  measurableSet_Ioc.nullMeasurableSet\n\n"}
{"name":"measurableSet_Ico","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na b : α\n⊢ MeasurableSet (Set.Ico a b)","decl":"@[simp, measurability]\ntheorem measurableSet_Ico : MeasurableSet (Ico a b) :=\n  measurableSet_Ici.inter measurableSet_Iio\n\n"}
{"name":"nullMeasurableSet_Ico","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na b : α\nμ : MeasureTheory.Measure α\n⊢ MeasureTheory.NullMeasurableSet (Set.Ico a b) μ","decl":"theorem nullMeasurableSet_Ico : NullMeasurableSet (Ico a b) μ :=\n  measurableSet_Ico.nullMeasurableSet\n\n"}
{"name":"nhdsWithin_Ioi_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na b : α\n⊢ (nhdsWithin a (Set.Ioi b)).IsMeasurablyGenerated","decl":"instance nhdsWithin_Ioi_isMeasurablyGenerated : (𝓝[Ioi b] a).IsMeasurablyGenerated :=\n  measurableSet_Ioi.nhdsWithin_isMeasurablyGenerated _\n\n"}
{"name":"nhdsWithin_Iio_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na b : α\n⊢ (nhdsWithin a (Set.Iio b)).IsMeasurablyGenerated","decl":"instance nhdsWithin_Iio_isMeasurablyGenerated : (𝓝[Iio b] a).IsMeasurablyGenerated :=\n  measurableSet_Iio.nhdsWithin_isMeasurablyGenerated _\n\n"}
{"name":"nhdsWithin_uIcc_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝ : LinearOrder α\na b x : α\n⊢ (nhdsWithin x (Set.uIcc a b)).IsMeasurablyGenerated","decl":"instance nhdsWithin_uIcc_isMeasurablyGenerated : IsMeasurablyGenerated (𝓝[[[a, b]]] x) :=\n  nhdsWithin_Icc_isMeasurablyGenerated\n\n"}
{"name":"measurableSet_lt'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\ninst✝² : LinearOrder α\ninst✝¹ : OrderClosedTopology α\ninst✝ : SecondCountableTopology α\n⊢ MeasurableSet (setOf fun p => LT.lt p.1 p.2)","decl":"@[measurability]\ntheorem measurableSet_lt' [SecondCountableTopology α] : MeasurableSet { p : α × α | p.1 < p.2 } :=\n  (isOpen_lt continuous_fst continuous_snd).measurableSet\n\n"}
{"name":"measurableSet_lt","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\nmδ : MeasurableSpace δ\ninst✝² : LinearOrder α\ninst✝¹ : OrderClosedTopology α\ninst✝ : SecondCountableTopology α\nf g : δ → α\nhf : Measurable f\nhg : Measurable g\n⊢ MeasurableSet (setOf fun a => LT.lt (f a) (g a))","decl":"@[measurability]\ntheorem measurableSet_lt [SecondCountableTopology α] {f g : δ → α} (hf : Measurable f)\n    (hg : Measurable g) : MeasurableSet { a | f a < g a } :=\n  hf.prod_mk hg measurableSet_lt'\n\n"}
{"name":"nullMeasurableSet_lt","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\nmδ : MeasurableSpace δ\ninst✝² : LinearOrder α\ninst✝¹ : OrderClosedTopology α\ninst✝ : SecondCountableTopology α\nμ : MeasureTheory.Measure δ\nf g : δ → α\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ MeasureTheory.NullMeasurableSet (setOf fun a => LT.lt (f a) (g a)) μ","decl":"theorem nullMeasurableSet_lt [SecondCountableTopology α] {μ : Measure δ} {f g : δ → α}\n    (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) : NullMeasurableSet { a | f a < g a } μ :=\n  (hf.prod_mk hg).nullMeasurable measurableSet_lt'\n\n"}
{"name":"nullMeasurableSet_lt'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\ninst✝² : LinearOrder α\ninst✝¹ : OrderClosedTopology α\ninst✝ : SecondCountableTopology α\nμ : MeasureTheory.Measure (Prod α α)\n⊢ MeasureTheory.NullMeasurableSet (setOf fun p => LT.lt p.1 p.2) μ","decl":"theorem nullMeasurableSet_lt' [SecondCountableTopology α] {μ : Measure (α × α)} :\n    NullMeasurableSet { p : α × α | p.1 < p.2 } μ :=\n  measurableSet_lt'.nullMeasurableSet\n\n"}
{"name":"nullMeasurableSet_le","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\nmδ : MeasurableSpace δ\ninst✝² : LinearOrder α\ninst✝¹ : OrderClosedTopology α\ninst✝ : SecondCountableTopology α\nμ : MeasureTheory.Measure δ\nf g : δ → α\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ MeasureTheory.NullMeasurableSet (setOf fun a => LE.le (f a) (g a)) μ","decl":"theorem nullMeasurableSet_le [SecondCountableTopology α] {μ : Measure δ}\n    {f g : δ → α} (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    NullMeasurableSet { a | f a ≤ g a } μ :=\n  (hf.prod_mk hg).nullMeasurable measurableSet_le'\n\n"}
{"name":"Set.OrdConnected.measurableSet","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ns : Set α\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\nh : s.OrdConnected\n⊢ MeasurableSet s","decl":"theorem Set.OrdConnected.measurableSet (h : OrdConnected s) : MeasurableSet s := by\n  let u := ⋃ (x ∈ s) (y ∈ s), Ioo x y\n  have huopen : IsOpen u := isOpen_biUnion fun _ _ => isOpen_biUnion fun _ _ => isOpen_Ioo\n  have humeas : MeasurableSet u := huopen.measurableSet\n  have hfinite : (s \\ u).Finite := s.finite_diff_iUnion_Ioo\n  have : u ⊆ s := iUnion₂_subset fun x hx => iUnion₂_subset fun y hy =>\n    Ioo_subset_Icc_self.trans (h.out hx hy)\n  rw [← union_diff_cancel this]\n  exact humeas.union hfinite.measurableSet\n\n"}
{"name":"IsPreconnected.measurableSet","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ns : Set α\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\nh : IsPreconnected s\n⊢ MeasurableSet s","decl":"theorem IsPreconnected.measurableSet (h : IsPreconnected s) : MeasurableSet s :=\n  h.ordConnected.measurableSet\n\n"}
{"name":"generateFrom_Ico_mem_le_borel","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝² : TopologicalSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\ns t : Set α\n⊢ LE.le (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem t u) (And (LT.lt l u) (Eq (Set.Ico l u) S))))) (borel α)","decl":"theorem generateFrom_Ico_mem_le_borel {α : Type*} [TopologicalSpace α] [LinearOrder α]\n    [OrderClosedTopology α] (s t : Set α) :\n    MeasurableSpace.generateFrom { S | ∃ l ∈ s, ∃ u ∈ t, l < u ∧ Ico l u = S }\n      ≤ borel α := by\n  apply generateFrom_le\n  borelize α\n  rintro _ ⟨a, -, b, -, -, rfl⟩\n  exact measurableSet_Ico\n\n"}
{"name":"Dense.borel_eq_generateFrom_Ico_mem_aux","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝³ : TopologicalSpace α\ninst✝² : LinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\ns : Set α\nhd : Dense s\nhbot : ∀ (x : α), IsBot x → Membership.mem s x\nhIoo : ∀ (x y : α), LT.lt x y → Eq (Set.Ioo x y) EmptyCollection.emptyCollection → Membership.mem s y\n⊢ Eq (borel α) (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem s u) (And (LT.lt l u) (Eq (Set.Ico l u) S)))))","decl":"theorem Dense.borel_eq_generateFrom_Ico_mem_aux {α : Type*} [TopologicalSpace α] [LinearOrder α]\n    [OrderTopology α] [SecondCountableTopology α] {s : Set α} (hd : Dense s)\n    (hbot : ∀ x, IsBot x → x ∈ s) (hIoo : ∀ x y : α, x < y → Ioo x y = ∅ → y ∈ s) :\n    borel α = .generateFrom { S : Set α | ∃ l ∈ s, ∃ u ∈ s, l < u ∧ Ico l u = S } := by\n  set S : Set (Set α) := { S | ∃ l ∈ s, ∃ u ∈ s, l < u ∧ Ico l u = S }\n  refine le_antisymm ?_ (generateFrom_Ico_mem_le_borel _ _)\n  letI : MeasurableSpace α := generateFrom S\n  rw [borel_eq_generateFrom_Iio]\n  refine generateFrom_le (forall_mem_range.2 fun a => ?_)\n  rcases hd.exists_countable_dense_subset_bot_top with ⟨t, hts, hc, htd, htb, -⟩\n  by_cases ha : ∀ b < a, (Ioo b a).Nonempty\n  · convert_to MeasurableSet (⋃ (l ∈ t) (u ∈ t) (_ : l < u) (_ : u ≤ a), Ico l u)\n    · ext y\n      simp only [mem_iUnion, mem_Iio, mem_Ico]\n      constructor\n      · intro hy\n        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with ⟨l, hlt, hly⟩\n        rcases htd.exists_mem_open isOpen_Ioo (ha y hy) with ⟨u, hut, hyu, hua⟩\n        exact ⟨l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyu⟩\n      · rintro ⟨l, -, u, -, -, hua, -, hyu⟩\n        exact hyu.trans_le hua\n    · refine MeasurableSet.biUnion hc fun a ha => MeasurableSet.biUnion hc fun b hb => ?_\n      refine MeasurableSet.iUnion fun hab => MeasurableSet.iUnion fun _ => ?_\n      exact .basic _ ⟨a, hts ha, b, hts hb, hab, mem_singleton _⟩\n  · simp only [not_forall, not_nonempty_iff_eq_empty] at ha\n    replace ha : a ∈ s := hIoo ha.choose a ha.choose_spec.fst ha.choose_spec.snd\n    convert_to MeasurableSet (⋃ (l ∈ t) (_ : l < a), Ico l a)\n    · symm\n      simp only [← Ici_inter_Iio, ← iUnion_inter, inter_eq_right, subset_def, mem_iUnion,\n        mem_Ici, mem_Iio]\n      intro x hx\n      rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with ⟨z, hzt, hzx⟩\n      exact ⟨z, hzt, hzx.trans_lt hx, hzx⟩\n    · refine .biUnion hc fun x hx => MeasurableSet.iUnion fun hlt => ?_\n      exact .basic _ ⟨x, hts hx, a, ha, hlt, mem_singleton _⟩\n\n"}
{"name":"Dense.borel_eq_generateFrom_Ico_mem","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : LinearOrder α\ninst✝³ : OrderTopology α\ninst✝² : SecondCountableTopology α\ninst✝¹ : DenselyOrdered α\ninst✝ : NoMinOrder α\ns : Set α\nhd : Dense s\n⊢ Eq (borel α) (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem s u) (And (LT.lt l u) (Eq (Set.Ico l u) S)))))","decl":"theorem Dense.borel_eq_generateFrom_Ico_mem {α : Type*} [TopologicalSpace α] [LinearOrder α]\n    [OrderTopology α] [SecondCountableTopology α] [DenselyOrdered α] [NoMinOrder α] {s : Set α}\n    (hd : Dense s) :\n    borel α = .generateFrom { S : Set α | ∃ l ∈ s, ∃ u ∈ s, l < u ∧ Ico l u = S } :=\n  hd.borel_eq_generateFrom_Ico_mem_aux (by simp) fun _ _ hxy H =>\n    ((nonempty_Ioo.2 hxy).ne_empty H).elim\n\n"}
{"name":"borel_eq_generateFrom_Ico","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝³ : TopologicalSpace α\ninst✝² : SecondCountableTopology α\ninst✝¹ : LinearOrder α\ninst✝ : OrderTopology α\n⊢ Eq (borel α) (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => Exists fun u => And (LT.lt l u) (Eq (Set.Ico l u) S)))","decl":"theorem borel_eq_generateFrom_Ico (α : Type*) [TopologicalSpace α] [SecondCountableTopology α]\n    [LinearOrder α] [OrderTopology α] :\n    borel α = .generateFrom { S : Set α | ∃ (l u : α), l < u ∧ Ico l u = S } := by\n  simpa only [exists_prop, mem_univ, true_and] using\n    (@dense_univ α _).borel_eq_generateFrom_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>\n      mem_univ _\n\n"}
{"name":"Dense.borel_eq_generateFrom_Ioc_mem_aux","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝³ : TopologicalSpace α\ninst✝² : LinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\ns : Set α\nhd : Dense s\nhbot : ∀ (x : α), IsTop x → Membership.mem s x\nhIoo : ∀ (x y : α), LT.lt x y → Eq (Set.Ioo x y) EmptyCollection.emptyCollection → Membership.mem s x\n⊢ Eq (borel α) (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem s u) (And (LT.lt l u) (Eq (Set.Ioc l u) S)))))","decl":"theorem Dense.borel_eq_generateFrom_Ioc_mem_aux {α : Type*} [TopologicalSpace α] [LinearOrder α]\n    [OrderTopology α] [SecondCountableTopology α] {s : Set α} (hd : Dense s)\n    (hbot : ∀ x, IsTop x → x ∈ s) (hIoo : ∀ x y : α, x < y → Ioo x y = ∅ → x ∈ s) :\n    borel α = .generateFrom { S : Set α | ∃ l ∈ s, ∃ u ∈ s, l < u ∧ Ioc l u = S } := by\n  convert hd.orderDual.borel_eq_generateFrom_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _\n    using 2\n  · ext s\n    constructor <;> rintro ⟨l, hl, u, hu, hlt, rfl⟩\n    exacts [⟨u, hu, l, hl, hlt, dual_Ico⟩, ⟨u, hu, l, hl, hlt, dual_Ioc⟩]\n  · erw [dual_Ioo]\n    exact he\n\n"}
{"name":"Dense.borel_eq_generateFrom_Ioc_mem","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : LinearOrder α\ninst✝³ : OrderTopology α\ninst✝² : SecondCountableTopology α\ninst✝¹ : DenselyOrdered α\ninst✝ : NoMaxOrder α\ns : Set α\nhd : Dense s\n⊢ Eq (borel α) (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem s u) (And (LT.lt l u) (Eq (Set.Ioc l u) S)))))","decl":"theorem Dense.borel_eq_generateFrom_Ioc_mem {α : Type*} [TopologicalSpace α] [LinearOrder α]\n    [OrderTopology α] [SecondCountableTopology α] [DenselyOrdered α] [NoMaxOrder α] {s : Set α}\n    (hd : Dense s) :\n    borel α = .generateFrom { S : Set α | ∃ l ∈ s, ∃ u ∈ s, l < u ∧ Ioc l u = S } :=\n  hd.borel_eq_generateFrom_Ioc_mem_aux (by simp) fun _ _ hxy H =>\n    ((nonempty_Ioo.2 hxy).ne_empty H).elim\n\n"}
{"name":"borel_eq_generateFrom_Ioc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝³ : TopologicalSpace α\ninst✝² : SecondCountableTopology α\ninst✝¹ : LinearOrder α\ninst✝ : OrderTopology α\n⊢ Eq (borel α) (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => Exists fun u => And (LT.lt l u) (Eq (Set.Ioc l u) S)))","decl":"theorem borel_eq_generateFrom_Ioc (α : Type*) [TopologicalSpace α] [SecondCountableTopology α]\n    [LinearOrder α] [OrderTopology α] :\n    borel α = .generateFrom { S : Set α | ∃ l u, l < u ∧ Ioc l u = S } := by\n  simpa only [exists_prop, mem_univ, true_and] using\n    (@dense_univ α _).borel_eq_generateFrom_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>\n      mem_univ _\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ico_finite","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝⁵ : TopologicalSpace α\nm : MeasurableSpace α\ninst✝⁴ : SecondCountableTopology α\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : BorelSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμν : Eq (μ Set.univ) (ν Set.univ)\nh : ∀ ⦃a b : α⦄, LT.lt a b → Eq (μ (Set.Ico a b)) (ν (Set.Ico a b))\n⊢ Eq μ ν","decl":"/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If\n`α` is a conditionally complete linear order with no top element,\n`MeasureTheory.Measure.ext_of_Ico` is an extensionality lemma with weaker assumptions on `μ` and\n`ν`. -/\ntheorem ext_of_Ico_finite {α : Type*} [TopologicalSpace α] {m : MeasurableSpace α}\n    [SecondCountableTopology α] [LinearOrder α] [OrderTopology α] [BorelSpace α] (μ ν : Measure α)\n    [IsFiniteMeasure μ] (hμν : μ univ = ν univ) (h : ∀ ⦃a b⦄, a < b → μ (Ico a b) = ν (Ico a b)) :\n    μ = ν := by\n  refine\n    ext_of_generate_finite _ (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico α))\n      (isPiSystem_Ico (id : α → α) id) ?_ hμν\n  rintro - ⟨a, b, hlt, rfl⟩\n  exact h hlt\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ioc_finite","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝⁵ : TopologicalSpace α\nm : MeasurableSpace α\ninst✝⁴ : SecondCountableTopology α\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : BorelSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhμν : Eq (μ Set.univ) (ν Set.univ)\nh : ∀ ⦃a b : α⦄, LT.lt a b → Eq (μ (Set.Ioc a b)) (ν (Set.Ioc a b))\n⊢ Eq μ ν","decl":"/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If\n`α` is a conditionally complete linear order with no top element,\n`MeasureTheory.Measure.ext_of_Ioc` is an extensionality lemma with weaker assumptions on `μ` and\n`ν`. -/\ntheorem ext_of_Ioc_finite {α : Type*} [TopologicalSpace α] {m : MeasurableSpace α}\n    [SecondCountableTopology α] [LinearOrder α] [OrderTopology α] [BorelSpace α] (μ ν : Measure α)\n    [IsFiniteMeasure μ] (hμν : μ univ = ν univ) (h : ∀ ⦃a b⦄, a < b → μ (Ioc a b) = ν (Ioc a b)) :\n    μ = ν := by\n  refine @ext_of_Ico_finite αᵒᵈ _ _ _ _ _ ‹_› μ ν _ hμν fun a b hab => ?_\n  erw [dual_Ico (α := α)]\n  exact h hab\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ico'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝⁵ : TopologicalSpace α\nm : MeasurableSpace α\ninst✝⁴ : SecondCountableTopology α\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : BorelSpace α\ninst✝ : NoMaxOrder α\nμ ν : MeasureTheory.Measure α\nhμ : ∀ ⦃a b : α⦄, LT.lt a b → Ne (μ (Set.Ico a b)) Top.top\nh : ∀ ⦃a b : α⦄, LT.lt a b → Eq (μ (Set.Ico a b)) (ν (Set.Ico a b))\n⊢ Eq μ ν","decl":"/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nclosed-open intervals. -/\ntheorem ext_of_Ico' {α : Type*} [TopologicalSpace α] {m : MeasurableSpace α}\n    [SecondCountableTopology α] [LinearOrder α] [OrderTopology α] [BorelSpace α] [NoMaxOrder α]\n    (μ ν : Measure α) (hμ : ∀ ⦃a b⦄, a < b → μ (Ico a b) ≠ ∞)\n    (h : ∀ ⦃a b⦄, a < b → μ (Ico a b) = ν (Ico a b)) : μ = ν := by\n  rcases exists_countable_dense_bot_top α with ⟨s, hsc, hsd, hsb, _⟩\n  have : (⋃ (l ∈ s) (u ∈ s) (_ : l < u), {Ico l u} : Set (Set α)).Countable :=\n    hsc.biUnion fun l _ => hsc.biUnion fun u _ => countable_iUnion fun _ => countable_singleton _\n  simp only [← setOf_eq_eq_singleton, ← setOf_exists] at this\n  refine\n    Measure.ext_of_generateFrom_of_cover_subset\n      (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico α)) (isPiSystem_Ico id id) ?_ this\n      ?_ ?_ ?_\n  · rintro _ ⟨l, -, u, -, h, rfl⟩\n    exact ⟨l, u, h, rfl⟩\n  · refine sUnion_eq_univ_iff.2 fun x => ?_\n    rcases hsd.exists_le' hsb x with ⟨l, hls, hlx⟩\n    rcases hsd.exists_gt x with ⟨u, hus, hxu⟩\n    exact ⟨_, ⟨l, hls, u, hus, hlx.trans_lt hxu, rfl⟩, hlx, hxu⟩\n  · rintro _ ⟨l, -, u, -, hlt, rfl⟩\n    exact hμ hlt\n  · rintro _ ⟨l, u, hlt, rfl⟩\n    exact h hlt\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ioc'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝⁵ : TopologicalSpace α\nm : MeasurableSpace α\ninst✝⁴ : SecondCountableTopology α\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : BorelSpace α\ninst✝ : NoMinOrder α\nμ ν : MeasureTheory.Measure α\nhμ : ∀ ⦃a b : α⦄, LT.lt a b → Ne (μ (Set.Ioc a b)) Top.top\nh : ∀ ⦃a b : α⦄, LT.lt a b → Eq (μ (Set.Ioc a b)) (ν (Set.Ioc a b))\n⊢ Eq μ ν","decl":"/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nopen-closed intervals. -/\ntheorem ext_of_Ioc' {α : Type*} [TopologicalSpace α] {m : MeasurableSpace α}\n    [SecondCountableTopology α] [LinearOrder α] [OrderTopology α] [BorelSpace α] [NoMinOrder α]\n    (μ ν : Measure α) (hμ : ∀ ⦃a b⦄, a < b → μ (Ioc a b) ≠ ∞)\n    (h : ∀ ⦃a b⦄, a < b → μ (Ioc a b) = ν (Ioc a b)) : μ = ν := by\n  refine @ext_of_Ico' αᵒᵈ _ _ _ _ _ ‹_› _ μ ν ?_ ?_ <;> intro a b hab <;> erw [dual_Ico (α := α)]\n  exacts [hμ hab, h hab]\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ico","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝⁶ : TopologicalSpace α\n_m : MeasurableSpace α\ninst✝⁵ : SecondCountableTopology α\ninst✝⁴ : ConditionallyCompleteLinearOrder α\ninst✝³ : OrderTopology α\ninst✝² : BorelSpace α\ninst✝¹ : NoMaxOrder α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nh : ∀ ⦃a b : α⦄, LT.lt a b → Eq (μ (Set.Ico a b)) (ν (Set.Ico a b))\n⊢ Eq μ ν","decl":"/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nclosed-open intervals. -/\ntheorem ext_of_Ico {α : Type*} [TopologicalSpace α] {_m : MeasurableSpace α}\n    [SecondCountableTopology α] [ConditionallyCompleteLinearOrder α] [OrderTopology α]\n    [BorelSpace α] [NoMaxOrder α] (μ ν : Measure α) [IsLocallyFiniteMeasure μ]\n    (h : ∀ ⦃a b⦄, a < b → μ (Ico a b) = ν (Ico a b)) : μ = ν :=\n  μ.ext_of_Ico' ν (fun _ _ _ => measure_Ico_lt_top.ne) h\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ioc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝⁶ : TopologicalSpace α\n_m : MeasurableSpace α\ninst✝⁵ : SecondCountableTopology α\ninst✝⁴ : ConditionallyCompleteLinearOrder α\ninst✝³ : OrderTopology α\ninst✝² : BorelSpace α\ninst✝¹ : NoMinOrder α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nh : ∀ ⦃a b : α⦄, LT.lt a b → Eq (μ (Set.Ioc a b)) (ν (Set.Ioc a b))\n⊢ Eq μ ν","decl":"/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nopen-closed intervals. -/\ntheorem ext_of_Ioc {α : Type*} [TopologicalSpace α] {_m : MeasurableSpace α}\n    [SecondCountableTopology α] [ConditionallyCompleteLinearOrder α] [OrderTopology α]\n    [BorelSpace α] [NoMinOrder α] (μ ν : Measure α) [IsLocallyFiniteMeasure μ]\n    (h : ∀ ⦃a b⦄, a < b → μ (Ioc a b) = ν (Ioc a b)) : μ = ν :=\n  μ.ext_of_Ioc' ν (fun _ _ _ => measure_Ioc_lt_top.ne) h\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Iic","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝⁵ : TopologicalSpace α\nm : MeasurableSpace α\ninst✝⁴ : SecondCountableTopology α\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : BorelSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh : ∀ (a : α), Eq (μ (Set.Iic a)) (ν (Set.Iic a))\n⊢ Eq μ ν","decl":"/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed\nintervals. -/\ntheorem ext_of_Iic {α : Type*} [TopologicalSpace α] {m : MeasurableSpace α}\n    [SecondCountableTopology α] [LinearOrder α] [OrderTopology α] [BorelSpace α] (μ ν : Measure α)\n    [IsFiniteMeasure μ] (h : ∀ a, μ (Iic a) = ν (Iic a)) : μ = ν := by\n  refine ext_of_Ioc_finite μ ν ?_ fun a b hlt => ?_\n  · rcases exists_countable_dense_bot_top α with ⟨s, hsc, hsd, -, hst⟩\n    have : DirectedOn (· ≤ ·) s := directedOn_iff_directed.2 (Subtype.mono_coe _).directed_le\n    simp only [← biSup_measure_Iic hsc (hsd.exists_ge' hst) this, h]\n  rw [← Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) nullMeasurableSet_Iic,\n    measure_diff (Iic_subset_Iic.2 hlt.le) nullMeasurableSet_Iic, h a, h b]\n  · rw [← h a]\n    exact measure_ne_top μ _\n  · exact measure_ne_top μ _\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ici","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\ninst✝⁵ : TopologicalSpace α\nx✝ : MeasurableSpace α\ninst✝⁴ : SecondCountableTopology α\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : BorelSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh : ∀ (a : α), Eq (μ (Set.Ici a)) (ν (Set.Ici a))\n⊢ Eq μ ν","decl":"/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite\nintervals. -/\ntheorem ext_of_Ici {α : Type*} [TopologicalSpace α] {_ : MeasurableSpace α}\n    [SecondCountableTopology α] [LinearOrder α] [OrderTopology α] [BorelSpace α] (μ ν : Measure α)\n    [IsFiniteMeasure μ] (h : ∀ a, μ (Ici a) = ν (Ici a)) : μ = ν :=\n  @ext_of_Iic αᵒᵈ _ _ _ _ _ ‹_› _ _ _ h\n\n"}
{"name":"measurableSet_uIcc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na b : α\n⊢ MeasurableSet (Set.uIcc a b)","decl":"@[measurability]\ntheorem measurableSet_uIcc : MeasurableSet (uIcc a b) :=\n  measurableSet_Icc\n\n"}
{"name":"measurableSet_uIoc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderClosedTopology α\na b : α\n⊢ MeasurableSet (Set.uIoc a b)","decl":"@[measurability]\ntheorem measurableSet_uIoc : MeasurableSet (uIoc a b) :=\n  measurableSet_Ioc\n\n"}
{"name":"Measurable.max","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\nmδ : MeasurableSpace δ\ninst✝² : LinearOrder α\ninst✝¹ : OrderClosedTopology α\ninst✝ : SecondCountableTopology α\nf g : δ → α\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable fun a => Max.max (f a) (g a)","decl":"@[measurability]\ntheorem Measurable.max {f g : δ → α} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => max (f a) (g a) := by\n  simpa only [max_def'] using hf.piecewise (measurableSet_le hg hf) hg\n\n"}
{"name":"AEMeasurable.max","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\nmδ : MeasurableSpace δ\ninst✝² : LinearOrder α\ninst✝¹ : OrderClosedTopology α\ninst✝ : SecondCountableTopology α\nf g : δ → α\nμ : MeasureTheory.Measure δ\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (fun a => Max.max (f a) (g a)) μ","decl":"@[measurability]\nnonrec theorem AEMeasurable.max {f g : δ → α} {μ : Measure δ} (hf : AEMeasurable f μ)\n    (hg : AEMeasurable g μ) : AEMeasurable (fun a => max (f a) (g a)) μ :=\n  ⟨fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,\n    EventuallyEq.comp₂ hf.ae_eq_mk _ hg.ae_eq_mk⟩\n\n"}
{"name":"Measurable.min","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\nmδ : MeasurableSpace δ\ninst✝² : LinearOrder α\ninst✝¹ : OrderClosedTopology α\ninst✝ : SecondCountableTopology α\nf g : δ → α\nhf : Measurable f\nhg : Measurable g\n⊢ Measurable fun a => Min.min (f a) (g a)","decl":"@[measurability]\ntheorem Measurable.min {f g : δ → α} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => min (f a) (g a) := by\n  simpa only [min_def] using hf.piecewise (measurableSet_le hf hg) hg\n\n"}
{"name":"AEMeasurable.min","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\nmδ : MeasurableSpace δ\ninst✝² : LinearOrder α\ninst✝¹ : OrderClosedTopology α\ninst✝ : SecondCountableTopology α\nf g : δ → α\nμ : MeasureTheory.Measure δ\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ AEMeasurable (fun a => Min.min (f a) (g a)) μ","decl":"@[measurability]\nnonrec theorem AEMeasurable.min {f g : δ → α} {μ : Measure δ} (hf : AEMeasurable f μ)\n    (hg : AEMeasurable g μ) : AEMeasurable (fun a => min (f a) (g a)) μ :=\n  ⟨fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,\n    EventuallyEq.comp₂ hf.ae_eq_mk _ hg.ae_eq_mk⟩\n\n"}
{"name":"ContinuousSup.measurableSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"γ : Type u_3\ninst✝³ : TopologicalSpace γ\nmγ : MeasurableSpace γ\ninst✝² : BorelSpace γ\ninst✝¹ : Max γ\ninst✝ : ContinuousSup γ\n⊢ MeasurableSup γ","decl":"instance (priority := 100) ContinuousSup.measurableSup [Max γ] [ContinuousSup γ] :\n    MeasurableSup γ where\n  measurable_const_sup _ := (continuous_const.sup continuous_id).measurable\n  measurable_sup_const _ := (continuous_id.sup continuous_const).measurable\n\n"}
{"name":"ContinuousSup.measurableSup₂","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"γ : Type u_3\ninst✝⁴ : TopologicalSpace γ\nmγ : MeasurableSpace γ\ninst✝³ : BorelSpace γ\ninst✝² : SecondCountableTopology γ\ninst✝¹ : Max γ\ninst✝ : ContinuousSup γ\n⊢ MeasurableSup₂ γ","decl":"instance (priority := 100) ContinuousSup.measurableSup₂ [SecondCountableTopology γ] [Max γ]\n    [ContinuousSup γ] : MeasurableSup₂ γ :=\n  ⟨continuous_sup.measurable⟩\n\n"}
{"name":"ContinuousInf.measurableInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"γ : Type u_3\ninst✝³ : TopologicalSpace γ\nmγ : MeasurableSpace γ\ninst✝² : BorelSpace γ\ninst✝¹ : Min γ\ninst✝ : ContinuousInf γ\n⊢ MeasurableInf γ","decl":"instance (priority := 100) ContinuousInf.measurableInf [Min γ] [ContinuousInf γ] :\n    MeasurableInf γ where\n  measurable_const_inf _ := (continuous_const.inf continuous_id).measurable\n  measurable_inf_const _ := (continuous_id.inf continuous_const).measurable\n\n"}
{"name":"ContinuousInf.measurableInf₂","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"γ : Type u_3\ninst✝⁴ : TopologicalSpace γ\nmγ : MeasurableSpace γ\ninst✝³ : BorelSpace γ\ninst✝² : SecondCountableTopology γ\ninst✝¹ : Min γ\ninst✝ : ContinuousInf γ\n⊢ MeasurableInf₂ γ","decl":"instance (priority := 100) ContinuousInf.measurableInf₂ [SecondCountableTopology γ] [Min γ]\n    [ContinuousInf γ] : MeasurableInf₂ γ :=\n  ⟨continuous_inf.measurable⟩\n\n"}
{"name":"measurable_of_Iio","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : LinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nf : δ → α\nhf : ∀ (x : α), MeasurableSet (Set.preimage f (Set.Iio x))\n⊢ Measurable f","decl":"theorem measurable_of_Iio {f : δ → α} (hf : ∀ x, MeasurableSet (f ⁻¹' Iio x)) : Measurable f := by\n  convert measurable_generateFrom (α := δ) _\n  · exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Iio _)\n  · rintro _ ⟨x, rfl⟩; exact hf x\n\n"}
{"name":"UpperSemicontinuous.measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁶ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁵ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝⁴ : LinearOrder α\ninst✝³ : OrderTopology α\ninst✝² : SecondCountableTopology α\ninst✝¹ : TopologicalSpace δ\ninst✝ : OpensMeasurableSpace δ\nf : δ → α\nhf : UpperSemicontinuous f\n⊢ Measurable f","decl":"theorem UpperSemicontinuous.measurable [TopologicalSpace δ] [OpensMeasurableSpace δ] {f : δ → α}\n    (hf : UpperSemicontinuous f) : Measurable f :=\n  measurable_of_Iio fun y => (hf.isOpen_preimage y).measurableSet\n\n"}
{"name":"measurable_of_Ioi","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : LinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nf : δ → α\nhf : ∀ (x : α), MeasurableSet (Set.preimage f (Set.Ioi x))\n⊢ Measurable f","decl":"theorem measurable_of_Ioi {f : δ → α} (hf : ∀ x, MeasurableSet (f ⁻¹' Ioi x)) : Measurable f := by\n  convert measurable_generateFrom (α := δ) _\n  · exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ioi _)\n  · rintro _ ⟨x, rfl⟩; exact hf x\n\n"}
{"name":"LowerSemicontinuous.measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁶ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁵ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝⁴ : LinearOrder α\ninst✝³ : OrderTopology α\ninst✝² : SecondCountableTopology α\ninst✝¹ : TopologicalSpace δ\ninst✝ : OpensMeasurableSpace δ\nf : δ → α\nhf : LowerSemicontinuous f\n⊢ Measurable f","decl":"theorem LowerSemicontinuous.measurable [TopologicalSpace δ] [OpensMeasurableSpace δ] {f : δ → α}\n    (hf : LowerSemicontinuous f) : Measurable f :=\n  measurable_of_Ioi fun y => (hf.isOpen_preimage y).measurableSet\n\n"}
{"name":"measurable_of_Iic","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : LinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nf : δ → α\nhf : ∀ (x : α), MeasurableSet (Set.preimage f (Set.Iic x))\n⊢ Measurable f","decl":"theorem measurable_of_Iic {f : δ → α} (hf : ∀ x, MeasurableSet (f ⁻¹' Iic x)) : Measurable f := by\n  apply measurable_of_Ioi\n  simp_rw [← compl_Iic, preimage_compl, MeasurableSet.compl_iff]\n  assumption\n\n"}
{"name":"measurable_of_Ici","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : LinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nf : δ → α\nhf : ∀ (x : α), MeasurableSet (Set.preimage f (Set.Ici x))\n⊢ Measurable f","decl":"theorem measurable_of_Ici {f : δ → α} (hf : ∀ x, MeasurableSet (f ⁻¹' Ici x)) : Measurable f := by\n  apply measurable_of_Iio\n  simp_rw [← compl_Ici, preimage_compl, MeasurableSet.compl_iff]\n  assumption\n\n"}
{"name":"Measurable.isLUB","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\ninst✝ : Countable ι\nf : ι → δ → α\ng : δ → α\nhf : ∀ (i : ι), Measurable (f i)\nhg : ∀ (b : δ), IsLUB (setOf fun a => Exists fun i => Eq (f i b) a) (g b)\n⊢ Measurable g","decl":"/-- If a function is the least upper bound of countably many measurable functions,\nthen it is measurable. -/\ntheorem Measurable.isLUB {ι} [Countable ι] {f : ι → δ → α} {g : δ → α} (hf : ∀ i, Measurable (f i))\n    (hg : ∀ b, IsLUB { a | ∃ i, f i b = a } (g b)) : Measurable g := by\n  change ∀ b, IsLUB (range fun i => f i b) (g b) at hg\n  rw [‹BorelSpace α›.measurable_eq, borel_eq_generateFrom_Ioi α]\n  apply measurable_generateFrom\n  rintro _ ⟨a, rfl⟩\n  simp_rw [Set.preimage, mem_Ioi, lt_isLUB_iff (hg _), exists_range_iff, setOf_exists]\n  exact MeasurableSet.iUnion fun i => hf i (isOpen_lt' _).measurableSet\n\n"}
{"name":"Measurable.isLUB_of_mem","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\ninst✝ : Countable ι\nf : ι → δ → α\ng g' : δ → α\nhf : ∀ (i : ι), Measurable (f i)\ns : Set δ\nhs : MeasurableSet s\nhg : ∀ (b : δ), Membership.mem s b → IsLUB (setOf fun a => Exists fun i => Eq (f i b) a) (g b)\nhg' : Set.EqOn g g' (HasCompl.compl s)\ng'_meas : Measurable g'\n⊢ Measurable g","decl":"/-- If a function is the least upper bound of countably many measurable functions on a measurable\nset `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/\ntheorem Measurable.isLUB_of_mem {ι} [Countable ι] {f : ι → δ → α} {g g' : δ → α}\n    (hf : ∀ i, Measurable (f i))\n    {s : Set δ} (hs : MeasurableSet s) (hg : ∀ b ∈ s, IsLUB { a | ∃ i, f i b = a } (g b))\n    (hg' : EqOn g g' sᶜ) (g'_meas : Measurable g') : Measurable g := by\n  classical\n  rcases isEmpty_or_nonempty ι with hι|⟨⟨i⟩⟩\n  · rcases eq_empty_or_nonempty s with rfl|⟨x, hx⟩\n    · convert g'_meas\n      rwa [compl_empty, eqOn_univ] at hg'\n    · have A : ∀ b ∈ s, IsBot (g b) := by simpa using hg\n      have B : ∀ b ∈ s, g b = g x := by\n        intro b hb\n        apply le_antisymm (A b hb (g x)) (A x hx (g b))\n      have : g = s.piecewise (fun _y ↦ g x) g' := by\n        ext b\n        by_cases hb : b ∈ s\n        · simp [hb, B]\n        · simp [hb, hg' hb]\n      rw [this]\n      exact Measurable.piecewise hs measurable_const g'_meas\n  · have : Nonempty ι := ⟨i⟩\n    let f' : ι → δ → α := fun i ↦ s.piecewise (f i) g'\n    suffices ∀ b, IsLUB { a | ∃ i, f' i b = a } (g b) from\n      Measurable.isLUB (fun i ↦ Measurable.piecewise hs (hf i) g'_meas) this\n    intro b\n    by_cases hb : b ∈ s\n    · have A : ∀ i, f' i b = f i b := fun i ↦ by simp [f', hb]\n      simpa [A] using hg b hb\n    · have A : ∀ i, f' i b = g' b := fun i ↦ by simp [f', hb]\n      simp [A, hg' hb, isLUB_singleton]\n\n"}
{"name":"AEMeasurable.isLUB","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\nμ : MeasureTheory.Measure δ\ninst✝ : Countable ι\nf : ι → δ → α\ng : δ → α\nhf : ∀ (i : ι), AEMeasurable (f i) μ\nhg : Filter.Eventually (fun b => IsLUB (setOf fun a => Exists fun i => Eq (f i b) a) (g b)) (MeasureTheory.ae μ)\n⊢ AEMeasurable g μ","decl":"theorem AEMeasurable.isLUB {ι} {μ : Measure δ} [Countable ι] {f : ι → δ → α} {g : δ → α}\n    (hf : ∀ i, AEMeasurable (f i) μ) (hg : ∀ᵐ b ∂μ, IsLUB { a | ∃ i, f i b = a } (g b)) :\n    AEMeasurable g μ := by\n  classical\n  nontriviality α\n  haveI hα : Nonempty α := inferInstance\n  cases' isEmpty_or_nonempty ι with hι hι\n  · simp only [IsEmpty.exists_iff, setOf_false, isLUB_empty_iff] at hg\n    exact aemeasurable_const' (hg.mono fun a ha => hg.mono fun b hb => (ha _).antisymm (hb _))\n  let p : δ → (ι → α) → Prop := fun x f' => IsLUB { a | ∃ i, f' i = a } (g x)\n  let g_seq := (aeSeqSet hf p).piecewise g fun _ => hα.some\n  have hg_seq : ∀ b, IsLUB { a | ∃ i, aeSeq hf p i b = a } (g_seq b) := by\n    intro b\n    simp only [g_seq, aeSeq, Set.piecewise]\n    split_ifs with h\n    · have h_set_eq : { a : α | ∃ i : ι, (hf i).mk (f i) b = a } =\n        { a : α | ∃ i : ι, f i b = a } := by\n        ext x\n        simp_rw [Set.mem_setOf_eq, aeSeq.mk_eq_fun_of_mem_aeSeqSet hf h]\n      rw [h_set_eq]\n      exact aeSeq.fun_prop_of_mem_aeSeqSet hf h\n    · exact IsGreatest.isLUB ⟨(@exists_const (hα.some = hα.some) ι _).2 rfl, fun x ⟨i, hi⟩ => hi.ge⟩\n  refine ⟨g_seq, Measurable.isLUB (aeSeq.measurable hf p) hg_seq, ?_⟩\n  exact\n    (ite_ae_eq_of_measure_compl_zero g (fun _ => hα.some) (aeSeqSet hf p)\n        (aeSeq.measure_compl_aeSeqSet_eq_zero hf hg)).symm\n\n"}
{"name":"Measurable.isGLB","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\ninst✝ : Countable ι\nf : ι → δ → α\ng : δ → α\nhf : ∀ (i : ι), Measurable (f i)\nhg : ∀ (b : δ), IsGLB (setOf fun a => Exists fun i => Eq (f i b) a) (g b)\n⊢ Measurable g","decl":"/-- If a function is the greatest lower bound of countably many measurable functions,\nthen it is measurable. -/\ntheorem Measurable.isGLB {ι} [Countable ι] {f : ι → δ → α} {g : δ → α} (hf : ∀ i, Measurable (f i))\n    (hg : ∀ b, IsGLB { a | ∃ i, f i b = a } (g b)) : Measurable g :=\n  Measurable.isLUB (α := αᵒᵈ) hf hg\n\n"}
{"name":"Measurable.isGLB_of_mem","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\ninst✝ : Countable ι\nf : ι → δ → α\ng g' : δ → α\nhf : ∀ (i : ι), Measurable (f i)\ns : Set δ\nhs : MeasurableSet s\nhg : ∀ (b : δ), Membership.mem s b → IsGLB (setOf fun a => Exists fun i => Eq (f i b) a) (g b)\nhg' : Set.EqOn g g' (HasCompl.compl s)\ng'_meas : Measurable g'\n⊢ Measurable g","decl":"/-- If a function is the greatest lower bound of countably many measurable functions on a measurable\nset `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/\ntheorem Measurable.isGLB_of_mem {ι} [Countable ι] {f : ι → δ → α} {g g' : δ → α}\n    (hf : ∀ i, Measurable (f i))\n    {s : Set δ} (hs : MeasurableSet s) (hg : ∀ b ∈ s, IsGLB { a | ∃ i, f i b = a } (g b))\n    (hg' : EqOn g g' sᶜ) (g'_meas : Measurable g') : Measurable g :=\n  Measurable.isLUB_of_mem (α := αᵒᵈ) hf hs hg hg'  g'_meas\n\n"}
{"name":"AEMeasurable.isGLB","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\nμ : MeasureTheory.Measure δ\ninst✝ : Countable ι\nf : ι → δ → α\ng : δ → α\nhf : ∀ (i : ι), AEMeasurable (f i) μ\nhg : Filter.Eventually (fun b => IsGLB (setOf fun a => Exists fun i => Eq (f i b) a) (g b)) (MeasureTheory.ae μ)\n⊢ AEMeasurable g μ","decl":"theorem AEMeasurable.isGLB {ι} {μ : Measure δ} [Countable ι] {f : ι → δ → α} {g : δ → α}\n    (hf : ∀ i, AEMeasurable (f i) μ) (hg : ∀ᵐ b ∂μ, IsGLB { a | ∃ i, f i b = a } (g b)) :\n    AEMeasurable g μ :=\n  AEMeasurable.isLUB (α := αᵒᵈ) hf hg\n\n"}
{"name":"Monotone.measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁸ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁷ : BorelSpace α\ninst✝⁶ : TopologicalSpace β\nmβ : MeasurableSpace β\ninst✝⁵ : BorelSpace β\ninst✝⁴ : LinearOrder α\ninst✝³ : OrderTopology α\ninst✝² : SecondCountableTopology α\ninst✝¹ : LinearOrder β\ninst✝ : OrderClosedTopology β\nf : β → α\nhf : Monotone f\n⊢ Measurable f","decl":"protected theorem Monotone.measurable [LinearOrder β] [OrderClosedTopology β] {f : β → α}\n    (hf : Monotone f) : Measurable f :=\n  suffices h : ∀ x, OrdConnected (f ⁻¹' Ioi x) from measurable_of_Ioi fun x => (h x).measurableSet\n  fun _ => ordConnected_def.mpr fun _a ha _ _ _c hc => lt_of_lt_of_le ha (hf hc.1)\n\n"}
{"name":"aemeasurable_restrict_of_monotoneOn","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁸ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁷ : BorelSpace α\ninst✝⁶ : TopologicalSpace β\nmβ : MeasurableSpace β\ninst✝⁵ : BorelSpace β\ninst✝⁴ : LinearOrder α\ninst✝³ : OrderTopology α\ninst✝² : SecondCountableTopology α\ninst✝¹ : LinearOrder β\ninst✝ : OrderClosedTopology β\nμ : MeasureTheory.Measure β\ns : Set β\nhs : MeasurableSet s\nf : β → α\nhf : MonotoneOn f s\n⊢ AEMeasurable f (μ.restrict s)","decl":"theorem aemeasurable_restrict_of_monotoneOn [LinearOrder β] [OrderClosedTopology β] {μ : Measure β}\n    {s : Set β} (hs : MeasurableSet s) {f : β → α} (hf : MonotoneOn f s) :\n    AEMeasurable f (μ.restrict s) :=\n  have : Monotone (f ∘ (↑) : s → α) := fun ⟨x, hx⟩ ⟨y, hy⟩ => fun (hxy : x ≤ y) => hf hx hy hxy\n  aemeasurable_restrict_of_measurable_subtype hs this.measurable\n\n"}
{"name":"Antitone.measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁸ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁷ : BorelSpace α\ninst✝⁶ : TopologicalSpace β\nmβ : MeasurableSpace β\ninst✝⁵ : BorelSpace β\ninst✝⁴ : LinearOrder α\ninst✝³ : OrderTopology α\ninst✝² : SecondCountableTopology α\ninst✝¹ : LinearOrder β\ninst✝ : OrderClosedTopology β\nf : β → α\nhf : Antitone f\n⊢ Measurable f","decl":"protected theorem Antitone.measurable [LinearOrder β] [OrderClosedTopology β] {f : β → α}\n    (hf : Antitone f) : Measurable f :=\n  @Monotone.measurable αᵒᵈ β _ _ ‹_› _ _ _ _ _ ‹_› _ _ _ hf\n\n"}
{"name":"aemeasurable_restrict_of_antitoneOn","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁸ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁷ : BorelSpace α\ninst✝⁶ : TopologicalSpace β\nmβ : MeasurableSpace β\ninst✝⁵ : BorelSpace β\ninst✝⁴ : LinearOrder α\ninst✝³ : OrderTopology α\ninst✝² : SecondCountableTopology α\ninst✝¹ : LinearOrder β\ninst✝ : OrderClosedTopology β\nμ : MeasureTheory.Measure β\ns : Set β\nhs : MeasurableSet s\nf : β → α\nhf : AntitoneOn f s\n⊢ AEMeasurable f (μ.restrict s)","decl":"theorem aemeasurable_restrict_of_antitoneOn [LinearOrder β] [OrderClosedTopology β] {μ : Measure β}\n    {s : Set β} (hs : MeasurableSet s) {f : β → α} (hf : AntitoneOn f s) :\n    AEMeasurable f (μ.restrict s) :=\n  @aemeasurable_restrict_of_monotoneOn αᵒᵈ β _ _ ‹_› _ _ _ _ _ ‹_› _ _ _ _ hs _ hf\n\n"}
{"name":"MeasurableSet.of_mem_nhdsGT_aux","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\ninst✝² : LinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\ns : Set α\nh : ∀ (x : α), Membership.mem s x → Membership.mem (nhdsWithin x (Set.Ioi x)) s\nh' : ∀ (x : α), Membership.mem s x → Exists fun y => LT.lt x y\n⊢ MeasurableSet s","decl":"theorem MeasurableSet.of_mem_nhdsGT_aux {s : Set α} (h : ∀ x ∈ s, s ∈ 𝓝[>] x)\n    (h' : ∀ x ∈ s, ∃ y, x < y) : MeasurableSet s := by\n  choose! M hM using h'\n  suffices H : (s \\ interior s).Countable by\n    have : s = interior s ∪ s \\ interior s := by rw [union_diff_cancel interior_subset]\n    rw [this]\n    exact isOpen_interior.measurableSet.union H.measurableSet\n  have A : ∀ x ∈ s, ∃ y ∈ Ioi x, Ioo x y ⊆ s := fun x hx =>\n    (mem_nhdsGT_iff_exists_Ioo_subset' (hM x hx)).1 (h x hx)\n  choose! y hy h'y using A\n  have B : Set.PairwiseDisjoint (s \\ interior s) fun x => Ioo x (y x) := by\n    intro x hx x' hx' hxx'\n    rcases lt_or_gt_of_ne hxx' with (h' | h')\n    · refine disjoint_left.2 fun z hz h'z => ?_\n      have : x' ∈ interior s :=\n        mem_interior.2 ⟨Ioo x (y x), h'y _ hx.1, isOpen_Ioo, ⟨h', h'z.1.trans hz.2⟩⟩\n      exact False.elim (hx'.2 this)\n    · refine disjoint_left.2 fun z hz h'z => ?_\n      have : x ∈ interior s :=\n        mem_interior.2 ⟨Ioo x' (y x'), h'y _ hx'.1, isOpen_Ioo, ⟨h', hz.1.trans h'z.2⟩⟩\n      exact False.elim (hx.2 this)\n  exact B.countable_of_Ioo fun x hx => hy x hx.1\n\n"}
{"name":"measurableSet_of_mem_nhdsWithin_Ioi_aux","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\ninst✝² : LinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\ns : Set α\nh : ∀ (x : α), Membership.mem s x → Membership.mem (nhdsWithin x (Set.Ioi x)) s\nh' : ∀ (x : α), Membership.mem s x → Exists fun y => LT.lt x y\n⊢ MeasurableSet s","decl":"@[deprecated (since := \"2024-12-22\")]\nalias measurableSet_of_mem_nhdsWithin_Ioi_aux := MeasurableSet.of_mem_nhdsGT_aux\n\n"}
{"name":"MeasurableSet.of_mem_nhdsGT","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\ninst✝² : LinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\ns : Set α\nh : ∀ (x : α), Membership.mem s x → Membership.mem (nhdsWithin x (Set.Ioi x)) s\n⊢ MeasurableSet s","decl":"/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem MeasurableSet.of_mem_nhdsGT {s : Set α} (h : ∀ x ∈ s, s ∈ 𝓝[>] x) : MeasurableSet s := by\n  by_cases H : ∃ x ∈ s, IsTop x\n  · rcases H with ⟨x₀, x₀s, h₀⟩\n    have : s = { x₀ } ∪ s \\ { x₀ } := by rw [union_diff_cancel (singleton_subset_iff.2 x₀s)]\n    rw [this]\n    refine (measurableSet_singleton _).union ?_\n    have A : ∀ x ∈ s \\ { x₀ }, x < x₀ := fun x hx => lt_of_le_of_ne (h₀ _) (by simpa using hx.2)\n    refine .of_mem_nhdsGT_aux (fun x hx => ?_) fun x hx => ⟨x₀, A x hx⟩\n    obtain ⟨u, hu, us⟩ : ∃ (u : α), u ∈ Ioi x ∧ Ioo x u ⊆ s :=\n      (mem_nhdsGT_iff_exists_Ioo_subset' (A x hx)).1 (h x hx.1)\n    refine (mem_nhdsGT_iff_exists_Ioo_subset' (A x hx)).2 ⟨u, hu, fun y hy => ⟨us hy, ?_⟩⟩\n    exact ne_of_lt (hy.2.trans_le (h₀ _))\n  · refine .of_mem_nhdsGT_aux h ?_\n    simp only [IsTop] at H\n    push_neg at H\n    exact H\n\n"}
{"name":"measurableSet_of_mem_nhdsWithin_Ioi","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\ninst✝² : LinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\ns : Set α\nh : ∀ (x : α), Membership.mem s x → Membership.mem (nhdsWithin x (Set.Ioi x)) s\n⊢ MeasurableSet s","decl":"@[deprecated (since := \"2024-12-22\")]\nalias measurableSet_of_mem_nhdsWithin_Ioi := MeasurableSet.of_mem_nhdsGT\n\n"}
{"name":"measurableSet_bddAbove_range","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\ninst✝ : Countable ι\nf : ι → δ → α\nhf : ∀ (i : ι), Measurable (f i)\n⊢ MeasurableSet (setOf fun b => BddAbove (Set.range fun i => f i b))","decl":"lemma measurableSet_bddAbove_range {ι} [Countable ι] {f : ι → δ → α} (hf : ∀ i, Measurable (f i)) :\n    MeasurableSet {b | BddAbove (range (fun i ↦ f i b))} := by\n  rcases isEmpty_or_nonempty α with hα|hα\n  · have : ∀ b, range (fun i ↦ f i b) = ∅ := fun b ↦ eq_empty_of_isEmpty _\n    simp [this]\n  have A : ∀ (i : ι) (c : α), MeasurableSet {x | f i x ≤ c} := by\n    intro i c\n    exact measurableSet_le (hf i) measurable_const\n  have B : ∀ (c : α), MeasurableSet {x | ∀ i, f i x ≤ c} := by\n    intro c\n    rw [setOf_forall]\n    exact MeasurableSet.iInter (fun i ↦ A i c)\n  obtain ⟨u, hu⟩ : ∃ (u : ℕ → α), Tendsto u atTop atTop := exists_seq_tendsto (atTop : Filter α)\n  have : {b | BddAbove (range (fun i ↦ f i b))} = {x | ∃ n, ∀ i, f i x ≤ u n} := by\n    apply Subset.antisymm\n    · rintro x ⟨c, hc⟩\n      obtain ⟨n, hn⟩ : ∃ n, c ≤ u n := (tendsto_atTop.1 hu c).exists\n      exact ⟨n, fun i ↦ (hc ((mem_range_self i))).trans hn⟩\n    · rintro x ⟨n, hn⟩\n      refine ⟨u n, ?_⟩\n      rintro - ⟨i, rfl⟩\n      exact hn i\n  rw [this, setOf_exists]\n  exact MeasurableSet.iUnion (fun n ↦ B (u n))\n\n"}
{"name":"measurableSet_bddBelow_range","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : LinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\ninst✝ : Countable ι\nf : ι → δ → α\nhf : ∀ (i : ι), Measurable (f i)\n⊢ MeasurableSet (setOf fun b => BddBelow (Set.range fun i => f i b))","decl":"lemma measurableSet_bddBelow_range {ι} [Countable ι] {f : ι → δ → α} (hf : ∀ i, Measurable (f i)) :\n    MeasurableSet {b | BddBelow (range (fun i ↦ f i b))} :=\n  measurableSet_bddAbove_range (α := αᵒᵈ) hf\n\n"}
{"name":"Measurable.iSup_Prop","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"δ : Type u_4\nmδ : MeasurableSpace δ\nα : Type u_5\nmα : MeasurableSpace α\ninst✝ : ConditionallyCompleteLattice α\np : Prop\nf : δ → α\nhf : Measurable f\n⊢ Measurable fun b => iSup fun x => f b","decl":"@[measurability]\ntheorem Measurable.iSup_Prop {α} {mα : MeasurableSpace α} [ConditionallyCompleteLattice α]\n    (p : Prop) {f : δ → α} (hf : Measurable f) : Measurable fun b => ⨆ _ : p, f b := by\n  classical\n  simp_rw [ciSup_eq_ite]\n  split_ifs with h\n  · exact hf\n  · exact measurable_const\n\n"}
{"name":"Measurable.iInf_Prop","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"δ : Type u_4\nmδ : MeasurableSpace δ\nα : Type u_5\nmα : MeasurableSpace α\ninst✝ : ConditionallyCompleteLattice α\np : Prop\nf : δ → α\nhf : Measurable f\n⊢ Measurable fun b => iInf fun x => f b","decl":"@[measurability]\ntheorem Measurable.iInf_Prop {α} {mα : MeasurableSpace α} [ConditionallyCompleteLattice α]\n    (p : Prop) {f : δ → α} (hf : Measurable f) : Measurable fun b => ⨅ _ : p, f b := by\n  classical\n  simp_rw [ciInf_eq_ite]\n  split_ifs with h\n  · exact hf\n  · exact measurable_const\n\n"}
{"name":"Measurable.iSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\ninst✝ : Countable ι\nf : ι → δ → α\nhf : ∀ (i : ι), Measurable (f i)\n⊢ Measurable fun b => iSup fun i => f i b","decl":"@[measurability, fun_prop]\nprotected theorem Measurable.iSup {ι} [Countable ι] {f : ι → δ → α} (hf : ∀ i, Measurable (f i)) :\n    Measurable (fun b ↦ ⨆ i, f i b) := by\n  rcases isEmpty_or_nonempty ι with hι|hι\n  · simp [iSup_of_empty']\n  have A : MeasurableSet {b | BddAbove (range (fun i ↦ f i b))} :=\n    measurableSet_bddAbove_range hf\n  have : Measurable (fun (_b : δ) ↦ sSup (∅ : Set α)) := measurable_const\n  apply Measurable.isLUB_of_mem hf A _ _ this\n  · rintro b ⟨c, hc⟩\n    apply isLUB_ciSup\n    refine ⟨c, ?_⟩\n    rintro d ⟨i, rfl⟩\n    exact hc (mem_range_self i)\n  · intro b hb\n    apply csSup_of_not_bddAbove\n    exact hb\n\n"}
{"name":"measurable_iSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\ninst✝ : Countable ι\nf : ι → δ → α\nhf : ∀ (i : ι), Measurable (f i)\n⊢ Measurable fun b => iSup fun i => f i b","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_iSup := Measurable.iSup\n\n-- TODO: Why does this error?\n-- /-- Compositional version of `Measurable.iSup` for use by `fun_prop`. -/\n-- @[fun_prop]\n-- protected lemma Measurable.iSup'' {_ : MeasurableSpace γ} {ι : Sort*} [Countable ι]\n--     {f : ι → γ → δ → α} {h : γ → δ} (hf : ∀ i, Measurable ↿(f i)) (hh : Measurable h) :\n--     Measurable fun a ↦ (⨆ i, f i a) (h a) := by\n--   simp_rw [iSup_apply]\n--   exact .iSup fun i ↦ by fun_prop\n\n"}
{"name":"AEMeasurable.iSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\nμ : MeasureTheory.Measure δ\ninst✝ : Countable ι\nf : ι → δ → α\nhf : ∀ (i : ι), AEMeasurable (f i) μ\n⊢ AEMeasurable (fun b => iSup fun i => f i b) μ","decl":"@[measurability]\nprotected theorem AEMeasurable.iSup {ι} {μ : Measure δ} [Countable ι] {f : ι → δ → α}\n    (hf : ∀ i, AEMeasurable (f i) μ) : AEMeasurable (fun b => ⨆ i, f i b) μ := by\n  refine ⟨fun b ↦ ⨆ i, (hf i).mk (f i) b, .iSup (fun i ↦ (hf i).measurable_mk), ?_⟩\n  filter_upwards [ae_all_iff.2 (fun i ↦ (hf i).ae_eq_mk)] with b hb using by simp [hb]\n\n"}
{"name":"aemeasurable_iSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\nμ : MeasureTheory.Measure δ\ninst✝ : Countable ι\nf : ι → δ → α\nhf : ∀ (i : ι), AEMeasurable (f i) μ\n⊢ AEMeasurable (fun b => iSup fun i => f i b) μ","decl":"@[deprecated (since := \"2024-10-21\")]\nalias aemeasurable_iSup := AEMeasurable.iSup\n\n"}
{"name":"Measurable.iInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\ninst✝ : Countable ι\nf : ι → δ → α\nhf : ∀ (i : ι), Measurable (f i)\n⊢ Measurable fun b => iInf fun i => f i b","decl":"@[measurability, fun_prop]\nprotected theorem Measurable.iInf {ι} [Countable ι] {f : ι → δ → α} (hf : ∀ i, Measurable (f i)) :\n    Measurable fun b => ⨅ i, f i b :=\n  .iSup (α := αᵒᵈ) hf\n\n"}
{"name":"measurable_iInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\ninst✝ : Countable ι\nf : ι → δ → α\nhf : ∀ (i : ι), Measurable (f i)\n⊢ Measurable fun b => iInf fun i => f i b","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_iInf := Measurable.iInf\n\n"}
{"name":"AEMeasurable.iInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\nμ : MeasureTheory.Measure δ\ninst✝ : Countable ι\nf : ι → δ → α\nhf : ∀ (i : ι), AEMeasurable (f i) μ\n⊢ AEMeasurable (fun b => iInf fun i => f i b) μ","decl":"@[measurability]\nprotected theorem AEMeasurable.iInf {ι} {μ : Measure δ} [Countable ι] {f : ι → δ → α}\n    (hf : ∀ i, AEMeasurable (f i) μ) : AEMeasurable (fun b => ⨅ i, f i b) μ :=\n  .iSup (α := αᵒᵈ) hf\n\n"}
{"name":"aemeasurable_iInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁵ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝⁴ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : OrderTopology α\ninst✝¹ : SecondCountableTopology α\nι : Sort u_5\nμ : MeasureTheory.Measure δ\ninst✝ : Countable ι\nf : ι → δ → α\nhf : ∀ (i : ι), AEMeasurable (f i) μ\n⊢ AEMeasurable (fun b => iInf fun i => f i b) μ","decl":"@[deprecated (since := \"2024-10-21\")]\nalias aemeasurable_iInf := AEMeasurable.iInf\n\n"}
{"name":"Measurable.sSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\nf : ι → δ → α\ns : Set ι\nhs : s.Countable\nhf : ∀ (i : ι), Membership.mem s i → Measurable (f i)\n⊢ Measurable fun x => SupSet.sSup (Set.image (fun i => f i x) s)","decl":"protected theorem Measurable.sSup {ι} {f : ι → δ → α} {s : Set ι} (hs : s.Countable)\n    (hf : ∀ i ∈ s, Measurable (f i)) :\n    Measurable fun x => sSup ((fun i => f i x) '' s) := by\n  simp_rw [image_eq_range]\n  have : Countable s := hs.to_subtype\n  exact .iSup fun i ↦ hf i i.2\n\n"}
{"name":"measurable_sSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\nf : ι → δ → α\ns : Set ι\nhs : s.Countable\nhf : ∀ (i : ι), Membership.mem s i → Measurable (f i)\n⊢ Measurable fun x => SupSet.sSup (Set.image (fun i => f i x) s)","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_sSup := Measurable.sSup\n\n"}
{"name":"Measurable.sInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\nf : ι → δ → α\ns : Set ι\nhs : s.Countable\nhf : ∀ (i : ι), Membership.mem s i → Measurable (f i)\n⊢ Measurable fun x => InfSet.sInf (Set.image (fun i => f i x) s)","decl":"protected theorem Measurable.sInf {ι} {f : ι → δ → α} {s : Set ι} (hs : s.Countable)\n    (hf : ∀ i ∈ s, Measurable (f i)) :\n    Measurable fun x => sInf ((fun i => f i x) '' s) :=\n  .sSup (α := αᵒᵈ) hs hf\n\n"}
{"name":"measurable_sInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\nf : ι → δ → α\ns : Set ι\nhs : s.Countable\nhf : ∀ (i : ι), Membership.mem s i → Measurable (f i)\n⊢ Measurable fun x => InfSet.sInf (Set.image (fun i => f i x) s)","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_sInf := Measurable.sInf\n\n"}
{"name":"Measurable.biSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\ns : Set ι\nf : ι → δ → α\nhs : s.Countable\nhf : ∀ (i : ι), Membership.mem s i → Measurable (f i)\n⊢ Measurable fun b => iSup fun i => iSup fun h => f i b","decl":"theorem Measurable.biSup {ι} (s : Set ι) {f : ι → δ → α} (hs : s.Countable)\n    (hf : ∀ i ∈ s, Measurable (f i)) : Measurable fun b => ⨆ i ∈ s, f i b := by\n  haveI : Encodable s := hs.toEncodable\n  by_cases H : ∀ i, i ∈ s\n  · have : ∀ b, ⨆ i ∈ s, f i b = ⨆ (i : s), f i b :=\n      fun b ↦ cbiSup_eq_of_forall (f := fun i ↦ f i b) H\n    simp only [this]\n    exact .iSup (fun (i : s) ↦ hf i i.2)\n  · have : ∀ b, ⨆ i ∈ s, f i b = (⨆ (i : s), f i b) ⊔ sSup ∅ :=\n      fun b ↦ cbiSup_eq_of_not_forall (f := fun i ↦ f i b) H\n    simp only [this]\n    apply Measurable.sup _ measurable_const\n    exact .iSup (fun (i : s) ↦ hf i i.2)\n\n"}
{"name":"measurable_biSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\ns : Set ι\nf : ι → δ → α\nhs : s.Countable\nhf : ∀ (i : ι), Membership.mem s i → Measurable (f i)\n⊢ Measurable fun b => iSup fun i => iSup fun h => f i b","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_biSup := Measurable.biSup\n\n"}
{"name":"AEMeasurable.biSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\nμ : MeasureTheory.Measure δ\ns : Set ι\nf : ι → δ → α\nhs : s.Countable\nhf : ∀ (i : ι), Membership.mem s i → AEMeasurable (f i) μ\n⊢ AEMeasurable (fun b => iSup fun i => iSup fun h => f i b) μ","decl":"theorem AEMeasurable.biSup {ι} {μ : Measure δ} (s : Set ι) {f : ι → δ → α} (hs : s.Countable)\n    (hf : ∀ i ∈ s, AEMeasurable (f i) μ) : AEMeasurable (fun b => ⨆ i ∈ s, f i b) μ := by\n  classical\n  let g : ι → δ → α := fun i ↦ if hi : i ∈ s then (hf i hi).mk (f i) else fun _b ↦ sSup ∅\n  have : ∀ i ∈ s, Measurable (g i) := by\n    intro i hi\n    simpa [g, hi] using (hf i hi).measurable_mk\n  refine ⟨fun b ↦ ⨆ (i) (_ : i ∈ s), g i b, .biSup s hs this, ?_⟩\n  have : ∀ i ∈ s, ∀ᵐ b ∂μ, f i b = g i b :=\n    fun i hi ↦ by simpa [g, hi] using (hf i hi).ae_eq_mk\n  filter_upwards [(ae_ball_iff hs).2 this] with b hb\n  exact iSup_congr fun i => iSup_congr (hb i)\n\n"}
{"name":"aemeasurable_biSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\nμ : MeasureTheory.Measure δ\ns : Set ι\nf : ι → δ → α\nhs : s.Countable\nhf : ∀ (i : ι), Membership.mem s i → AEMeasurable (f i) μ\n⊢ AEMeasurable (fun b => iSup fun i => iSup fun h => f i b) μ","decl":"@[deprecated (since := \"2024-10-21\")]\nalias aemeasurable_biSup := AEMeasurable.biSup\n\n"}
{"name":"Measurable.biInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\ns : Set ι\nf : ι → δ → α\nhs : s.Countable\nhf : ∀ (i : ι), Membership.mem s i → Measurable (f i)\n⊢ Measurable fun b => iInf fun i => iInf fun h => f i b","decl":"theorem Measurable.biInf {ι} (s : Set ι) {f : ι → δ → α} (hs : s.Countable)\n    (hf : ∀ i ∈ s, Measurable (f i)) : Measurable fun b => ⨅ i ∈ s, f i b :=\n  .biSup (α := αᵒᵈ) s hs hf\n\n"}
{"name":"measurable_biInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\ns : Set ι\nf : ι → δ → α\nhs : s.Countable\nhf : ∀ (i : ι), Membership.mem s i → Measurable (f i)\n⊢ Measurable fun b => iInf fun i => iInf fun h => f i b","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_biInf := Measurable.biInf\n\n"}
{"name":"AEMeasurable.biInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\nμ : MeasureTheory.Measure δ\ns : Set ι\nf : ι → δ → α\nhs : s.Countable\nhf : ∀ (i : ι), Membership.mem s i → AEMeasurable (f i) μ\n⊢ AEMeasurable (fun b => iInf fun i => iInf fun h => f i b) μ","decl":"theorem AEMeasurable.biInf {ι} {μ : Measure δ} (s : Set ι) {f : ι → δ → α} (hs : s.Countable)\n    (hf : ∀ i ∈ s, AEMeasurable (f i) μ) : AEMeasurable (fun b => ⨅ i ∈ s, f i b) μ :=\n  .biSup (α := αᵒᵈ) s hs hf\n\n"}
{"name":"aemeasurable_biInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\nμ : MeasureTheory.Measure δ\ns : Set ι\nf : ι → δ → α\nhs : s.Countable\nhf : ∀ (i : ι), Membership.mem s i → AEMeasurable (f i) μ\n⊢ AEMeasurable (fun b => iInf fun i => iInf fun h => f i b) μ","decl":"@[deprecated (since := \"2024-10-21\")]\nalias aemeasurable_biInf := AEMeasurable.biInf\n\n"}
{"name":"Measurable.liminf'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\nι' : Type u_6\nf : ι → δ → α\nv : Filter ι\nhf : ∀ (i : ι), Measurable (f i)\np : ι' → Prop\ns : ι' → Set ι\nhv : v.HasCountableBasis p s\nhs : ∀ (j : ι'), (s j).Countable\n⊢ Measurable fun x => Filter.liminf (fun x_1 => f x_1 x) v","decl":"/-- `liminf` over a general filter is measurable. See `Measurable.liminf` for the version over `ℕ`.\n-/\ntheorem Measurable.liminf' {ι ι'} {f : ι → δ → α} {v : Filter ι} (hf : ∀ i, Measurable (f i))\n    {p : ι' → Prop} {s : ι' → Set ι} (hv : v.HasCountableBasis p s) (hs : ∀ j, (s j).Countable) :\n    Measurable fun x => liminf (f · x) v := by\n  classical\n  /- We would like to write the liminf as `⨆ (j : Subtype p), ⨅ (i : s j), f i x`, as the\n  measurability would follow from the measurability of infs and sups. Unfortunately, this is not\n  true in general conditionally complete linear orders because of issues with empty sets or sets\n  which are not bounded above or below. A slightly more complicated expression for the liminf,\n  valid in general, is given in `Filter.HasBasis.liminf_eq_ite`. This expression, built from\n  `if ... then ... else` and infs and sups, can be readily checked to be measurable. -/\n  have : Countable (Subtype p) := hv.countable\n  rcases isEmpty_or_nonempty (Subtype p) with hp|hp\n  · simp [hv.liminf_eq_sSup_iUnion_iInter]\n  by_cases H : ∃ (j : Subtype p), s j = ∅\n  · simp_rw [hv.liminf_eq_ite, if_pos H, measurable_const]\n  simp_rw [hv.liminf_eq_ite, if_neg H]\n  have : ∀ i, Countable (s i) := fun i ↦ countable_coe_iff.2 (hs i)\n  let m : Subtype p → Set δ := fun j ↦ {x | BddBelow (range (fun (i : s j) ↦ f i x))}\n  have m_meas : ∀ j, MeasurableSet (m j) :=\n    fun j ↦ measurableSet_bddBelow_range (fun (i : s j) ↦ hf i)\n  have mc_meas : MeasurableSet {x | ∀ (j : Subtype p), x ∉ m j} := by\n    rw [setOf_forall]\n    exact MeasurableSet.iInter (fun j ↦ (m_meas j).compl)\n  refine measurable_const.piecewise mc_meas <| .iSup fun j ↦ ?_\n  let reparam : δ → Subtype p → Subtype p := fun x ↦ liminf_reparam (fun i ↦ f i x) s p\n  let F0 : Subtype p → δ → α := fun j x ↦ ⨅ (i : s j), f i x\n  have F0_meas : ∀ j, Measurable (F0 j) := fun j ↦ .iInf (fun (i : s j) ↦ hf i)\n  set F1 : δ → α := fun x ↦ F0 (reparam x j) x with hF1\n  change Measurable F1\n  let g : ℕ → Subtype p := Classical.choose (exists_surjective_nat (Subtype p))\n  have Z : ∀ x, ∃ n, x ∈ m (g n) ∨ ∀ k, x ∉ m k := by\n    intro x\n    by_cases H : ∃ k, x ∈ m k\n    · rcases H with ⟨k, hk⟩\n      rcases Classical.choose_spec (exists_surjective_nat (Subtype p)) k with ⟨n, rfl⟩\n      exact ⟨n, Or.inl hk⟩\n    · push_neg at H\n      exact ⟨0, Or.inr H⟩\n  have : F1 = fun x ↦ if x ∈ m j then F0 j x else F0 (g (Nat.find (Z x))) x := by\n    ext x\n    have A : reparam x j = if x ∈ m j then j else g (Nat.find (Z x)) := rfl\n    split_ifs with hjx\n    · have : reparam x j = j := by rw [A, if_pos hjx]\n      simp only [hF1, this]\n    · have : reparam x j = g (Nat.find (Z x)) := by rw [A, if_neg hjx]\n      simp only [hF1, this]\n  rw [this]\n  apply Measurable.piecewise (m_meas j) (F0_meas j)\n  apply Measurable.find (fun n ↦ F0_meas (g n)) (fun n ↦ ?_)\n  exact (m_meas (g n)).union mc_meas\n\n"}
{"name":"measurable_liminf'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\nι' : Type u_6\nf : ι → δ → α\nv : Filter ι\nhf : ∀ (i : ι), Measurable (f i)\np : ι' → Prop\ns : ι' → Set ι\nhv : v.HasCountableBasis p s\nhs : ∀ (j : ι'), (s j).Countable\n⊢ Measurable fun x => Filter.liminf (fun x_1 => f x_1 x) v","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_liminf' := Measurable.liminf'\n\n"}
{"name":"Measurable.limsup'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\nι' : Type u_6\nf : ι → δ → α\nu : Filter ι\nhf : ∀ (i : ι), Measurable (f i)\np : ι' → Prop\ns : ι' → Set ι\nhu : u.HasCountableBasis p s\nhs : ∀ (i : ι'), (s i).Countable\n⊢ Measurable fun x => Filter.limsup (fun i => f i x) u","decl":"/-- `limsup` over a general filter is measurable. See `Measurable.limsup` for the version over `ℕ`.\n-/\ntheorem Measurable.limsup' {ι ι'} {f : ι → δ → α} {u : Filter ι} (hf : ∀ i, Measurable (f i))\n    {p : ι' → Prop} {s : ι' → Set ι} (hu : u.HasCountableBasis p s) (hs : ∀ i, (s i).Countable) :\n    Measurable fun x => limsup (fun i => f i x) u :=\n  .liminf' (α := αᵒᵈ) hf hu hs\n\n"}
{"name":"measurable_limsup'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nι : Type u_5\nι' : Type u_6\nf : ι → δ → α\nu : Filter ι\nhf : ∀ (i : ι), Measurable (f i)\np : ι' → Prop\ns : ι' → Set ι\nhu : u.HasCountableBasis p s\nhs : ∀ (i : ι'), (s i).Countable\n⊢ Measurable fun x => Filter.limsup (fun i => f i x) u","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_limsup' := Measurable.limsup'\n\n"}
{"name":"Measurable.liminf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nf : Nat → δ → α\nhf : ∀ (i : Nat), Measurable (f i)\n⊢ Measurable fun x => Filter.liminf (fun i => f i x) Filter.atTop","decl":"/-- `liminf` over `ℕ` is measurable. See `Measurable.liminf'` for a version with a general filter.\n-/\n@[measurability]\ntheorem Measurable.liminf {f : ℕ → δ → α} (hf : ∀ i, Measurable (f i)) :\n    Measurable fun x => liminf (fun i => f i x) atTop :=\n  .liminf' hf atTop_countable_basis fun _ => to_countable _\n\n"}
{"name":"measurable_liminf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nf : Nat → δ → α\nhf : ∀ (i : Nat), Measurable (f i)\n⊢ Measurable fun x => Filter.liminf (fun i => f i x) Filter.atTop","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_liminf := Measurable.liminf\n\n"}
{"name":"Measurable.limsup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nf : Nat → δ → α\nhf : ∀ (i : Nat), Measurable (f i)\n⊢ Measurable fun x => Filter.limsup (fun i => f i x) Filter.atTop","decl":"/-- `limsup` over `ℕ` is measurable. See `Measurable.limsup'` for a version with a general filter.\n-/\n@[measurability]\ntheorem Measurable.limsup {f : ℕ → δ → α} (hf : ∀ i, Measurable (f i)) :\n    Measurable fun x => limsup (fun i => f i x) atTop :=\n  .limsup' hf atTop_countable_basis fun _ => to_countable _\n\n"}
{"name":"measurable_limsup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nδ : Type u_4\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\nmδ : MeasurableSpace δ\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : OrderTopology α\ninst✝ : SecondCountableTopology α\nf : Nat → δ → α\nhf : ∀ (i : Nat), Measurable (f i)\n⊢ Measurable fun x => Filter.limsup (fun i => f i x) Filter.atTop","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_limsup := Measurable.limsup\n\n"}
{"name":"IsFiniteMeasureOnCompacts.map","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\nmα : MeasurableSpace α\ninst✝³ : BorelSpace α\ninst✝² : TopologicalSpace β\nmβ : MeasurableSpace β\ninst✝¹ : BorelSpace β\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\nf : Homeomorph α β\n⊢ MeasureTheory.IsFiniteMeasureOnCompacts (MeasureTheory.Measure.map (⇑f) μ)","decl":"protected theorem IsFiniteMeasureOnCompacts.map (μ : Measure α) [IsFiniteMeasureOnCompacts μ]\n    (f : α ≃ₜ β) : IsFiniteMeasureOnCompacts (Measure.map f μ) := by\n  refine ⟨fun K hK ↦ ?_⟩\n  rw [← Homeomorph.toMeasurableEquiv_coe, MeasurableEquiv.map_apply]\n  exact IsCompact.measure_lt_top (f.isCompact_preimage.2 hK)\n\n"}
{"name":"measure_eq_measure_preimage_add_measure_tsum_Ico_zpow","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"α : Type u_5\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\ns : Set α\nhs : MeasurableSet s\nt : NNReal\nht : LT.lt 1 t\n⊢ Eq (μ s) (HAdd.hAdd (HAdd.hAdd (μ (Inter.inter s (Set.preimage f (Singleton.singleton 0)))) (μ (Inter.inter s (Set.preimage f (Singleton.singleton Top.top))))) (tsum fun n => μ (Inter.inter s (Set.preimage f (Set.Ico (HPow.hPow (↑t) n) (HPow.hPow (↑t) (HAdd.hAdd n 1)))))))","decl":"/-- One can cut out `ℝ≥0∞` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : ℤ` and `{∞}`. This\ngives a way to compute the measure of a set in terms of sets on which a given function `f` does not\nfluctuate by more than `t`. -/\ntheorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow {α : Type*} {mα : MeasurableSpace α}\n    (μ : Measure α) {f : α → ℝ≥0∞} (hf : Measurable f) {s : Set α} (hs : MeasurableSet s)\n    {t : ℝ≥0} (ht : 1 < t) :\n    μ s =\n      μ (s ∩ f ⁻¹' {0}) + μ (s ∩ f ⁻¹' {∞}) +\n      ∑' n : ℤ, μ (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) := by\n  have A : μ s = μ (s ∩ f ⁻¹' {0}) + μ (s ∩ f ⁻¹' Ioi 0) := by\n    rw [← measure_union]\n    · rw [← inter_union_distrib_left, ← preimage_union, singleton_union, Ioi_insert,\n        ← _root_.bot_eq_zero, Ici_bot, preimage_univ, inter_univ]\n    · exact disjoint_singleton_left.mpr not_mem_Ioi_self\n        |>.preimage f |>.inter_right' s |>.inter_left' s\n    · exact hs.inter (hf measurableSet_Ioi)\n  have B : μ (s ∩ f ⁻¹' Ioi 0) = μ (s ∩ f ⁻¹' {∞}) + μ (s ∩ f ⁻¹' Ioo 0 ∞) := by\n    rw [← measure_union]\n    · rw [← inter_union_distrib_left]\n      congr\n      ext x\n      simp only [mem_singleton_iff, mem_union, mem_Ioo, mem_Ioi, mem_preimage]\n      obtain (H | H) : f x = ∞ ∨ f x < ∞ := eq_or_lt_of_le le_top\n      · simp only [H, eq_self_iff_true, or_false, ENNReal.zero_lt_top, not_top_lt, and_false]\n      · simp only [H, H.ne, and_true, false_or]\n    · refine disjoint_left.2 fun x hx h'x => ?_\n      have : f x < ∞ := h'x.2.2\n      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))\n    · exact hs.inter (hf measurableSet_Ioo)\n  have C : μ (s ∩ f ⁻¹' Ioo 0 ∞) =\n      ∑' n : ℤ, μ (s ∩ f ⁻¹' Ico ((t : ℝ≥0∞) ^ n) ((t : ℝ≥0∞) ^ (n + 1))) := by\n    rw [← measure_iUnion,\n      ENNReal.Ioo_zero_top_eq_iUnion_Ico_zpow (ENNReal.one_lt_coe_iff.2 ht) ENNReal.coe_ne_top,\n      preimage_iUnion, inter_iUnion]\n    · intro i j hij\n      wlog h : i < j generalizing i j\n      · exact (this hij.symm (hij.lt_or_lt.resolve_left h)).symm\n      refine disjoint_left.2 fun x hx h'x => lt_irrefl (f x) ?_\n      calc\n        f x < (t : ℝ≥0∞) ^ (i + 1) := hx.2.2\n        _ ≤ (t : ℝ≥0∞) ^ j := ENNReal.zpow_le_of_le (ENNReal.one_le_coe_iff.2 ht.le) h\n        _ ≤ f x := h'x.2.1\n    · intro n\n      exact hs.inter (hf measurableSet_Ico)\n  rw [A, B, C, add_assoc]\n\n"}
