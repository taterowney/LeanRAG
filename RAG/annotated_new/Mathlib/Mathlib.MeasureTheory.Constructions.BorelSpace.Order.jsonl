{"name":"borel_eq_generateFrom_Iio","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderTopology Î±\nâŠ¢ Eq (borel Î±) (MeasurableSpace.generateFrom (Set.range Set.Iio))","decl":"theorem borel_eq_generateFrom_Iio : borel Î± = .generateFrom (range Iio) := by\n  refine le_antisymm ?_ (generateFrom_le ?_)\n  Â· rw [borel_eq_generateFrom_of_subbasis (@OrderTopology.topology_eq_generate_intervals Î± _ _ _)]\n    letI : MeasurableSpace Î± := MeasurableSpace.generateFrom (range Iio)\n    have H : âˆ€ a : Î±, MeasurableSet (Iio a) := fun a => GenerateMeasurable.basic _ âŸ¨_, rflâŸ©\n    refine generateFrom_le ?_\n    rintro _ âŸ¨a, rfl | rflâŸ©\n    Â· rcases em (âˆƒ b, a â‹– b) with âŸ¨b, hbâŸ© | hcovBy\n      Â· rw [hb.Ioi_eq, â† compl_Iio]\n        exact (H _).compl\n      Â· rcases isOpen_biUnion_countable (Ioi a) Ioi fun _ _ â†¦ isOpen_Ioi with âŸ¨t, hat, htc, htUâŸ©\n        have : Ioi a = â‹ƒ b âˆˆ t, Ici b := by\n          refine Subset.antisymm ?_ <| iUnionâ‚‚_subset fun b hb â†¦ Ici_subset_Ioi.2 (hat hb)\n          refine Subset.trans ?_ <| iUnionâ‚‚_mono fun _ _ â†¦ Ioi_subset_Ici_self\n          simpa [CovBy, htU, subset_def] using hcovBy\n        simp only [this, â† compl_Iio]\n        exact .biUnion htc <| fun _ _ â†¦ (H _).compl\n    Â· apply H\n  Â· rw [forall_mem_range]\n    intro a\n    exact GenerateMeasurable.basic _ isOpen_Iio\n\n"}
{"name":"borel_eq_generateFrom_Ioi","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderTopology Î±\nâŠ¢ Eq (borel Î±) (MeasurableSpace.generateFrom (Set.range Set.Ioi))","decl":"theorem borel_eq_generateFrom_Ioi : borel Î± = .generateFrom (range Ioi) :=\n  @borel_eq_generateFrom_Iio Î±áµ’áµˆ _ (by infer_instance : SecondCountableTopology Î±) _ _\n\n"}
{"name":"borel_eq_generateFrom_Iic","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderTopology Î±\nâŠ¢ Eq (borel Î±) (MeasurableSpace.generateFrom (Set.range Set.Iic))","decl":"theorem borel_eq_generateFrom_Iic :\n    borel Î± = MeasurableSpace.generateFrom (range Iic) := by\n  rw [borel_eq_generateFrom_Ioi]\n  refine le_antisymm ?_ ?_\n  Â· refine MeasurableSpace.generateFrom_le fun t ht => ?_\n    obtain âŸ¨u, rflâŸ© := ht\n    rw [â† compl_Iic]\n    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr âŸ¨u, rflâŸ©)).compl\n  Â· refine MeasurableSpace.generateFrom_le fun t ht => ?_\n    obtain âŸ¨u, rflâŸ© := ht\n    rw [â† compl_Ioi]\n    exact (MeasurableSpace.measurableSet_generateFrom (mem_range.mpr âŸ¨u, rflâŸ©)).compl\n\n"}
{"name":"borel_eq_generateFrom_Ici","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderTopology Î±\nâŠ¢ Eq (borel Î±) (MeasurableSpace.generateFrom (Set.range Set.Ici))","decl":"theorem borel_eq_generateFrom_Ici : borel Î± = MeasurableSpace.generateFrom (range Ici) :=\n  @borel_eq_generateFrom_Iic Î±áµ’áµˆ _ _ _ _\n\n"}
{"name":"measurableSet_Ici","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : Preorder Î±\ninstâœ : OrderClosedTopology Î±\na : Î±\nâŠ¢ MeasurableSet (Set.Ici a)","decl":"@[simp, measurability]\ntheorem measurableSet_Ici : MeasurableSet (Ici a) :=\n  isClosed_Ici.measurableSet\n\n"}
{"name":"nullMeasurableSet_Ici","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : Preorder Î±\ninstâœ : OrderClosedTopology Î±\na : Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ MeasureTheory.NullMeasurableSet (Set.Ici a) Î¼","decl":"theorem nullMeasurableSet_Ici : NullMeasurableSet (Ici a) Î¼ :=\n  measurableSet_Ici.nullMeasurableSet\n\n"}
{"name":"measurableSet_Iic","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : Preorder Î±\ninstâœ : OrderClosedTopology Î±\na : Î±\nâŠ¢ MeasurableSet (Set.Iic a)","decl":"@[simp, measurability]\ntheorem measurableSet_Iic : MeasurableSet (Iic a) :=\n  isClosed_Iic.measurableSet\n\n"}
{"name":"nullMeasurableSet_Iic","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : Preorder Î±\ninstâœ : OrderClosedTopology Î±\na : Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ MeasureTheory.NullMeasurableSet (Set.Iic a) Î¼","decl":"theorem nullMeasurableSet_Iic : NullMeasurableSet (Iic a) Î¼ :=\n  measurableSet_Iic.nullMeasurableSet\n\n"}
{"name":"measurableSet_Icc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : Preorder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nâŠ¢ MeasurableSet (Set.Icc a b)","decl":"@[simp, measurability]\ntheorem measurableSet_Icc : MeasurableSet (Icc a b) :=\n  isClosed_Icc.measurableSet\n\n"}
{"name":"nullMeasurableSet_Icc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : Preorder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ MeasureTheory.NullMeasurableSet (Set.Icc a b) Î¼","decl":"theorem nullMeasurableSet_Icc : NullMeasurableSet (Icc a b) Î¼ :=\n  measurableSet_Icc.nullMeasurableSet\n\n"}
{"name":"nhdsWithin_Ici_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : Preorder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nâŠ¢ (nhdsWithin a (Set.Ici b)).IsMeasurablyGenerated","decl":"instance nhdsWithin_Ici_isMeasurablyGenerated : (ğ“[Ici b] a).IsMeasurablyGenerated :=\n  measurableSet_Ici.nhdsWithin_isMeasurablyGenerated _\n\n"}
{"name":"nhdsWithin_Iic_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : Preorder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nâŠ¢ (nhdsWithin a (Set.Iic b)).IsMeasurablyGenerated","decl":"instance nhdsWithin_Iic_isMeasurablyGenerated : (ğ“[Iic b] a).IsMeasurablyGenerated :=\n  measurableSet_Iic.nhdsWithin_isMeasurablyGenerated _\n\n"}
{"name":"nhdsWithin_Icc_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœ : Preorder Î±\na b x : Î±\nâŠ¢ (nhdsWithin x (Set.Icc a b)).IsMeasurablyGenerated","decl":"instance nhdsWithin_Icc_isMeasurablyGenerated : IsMeasurablyGenerated (ğ“[Icc a b] x) := by\n  rw [â† Ici_inter_Iic, nhdsWithin_inter]\n  infer_instance\n\n"}
{"name":"atTop_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : Preorder Î±\ninstâœ : OrderClosedTopology Î±\nâŠ¢ Filter.atTop.IsMeasurablyGenerated","decl":"instance atTop_isMeasurablyGenerated : (Filter.atTop : Filter Î±).IsMeasurablyGenerated :=\n  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>\n    (measurableSet_Ici : MeasurableSet (Ici a)).principal_isMeasurablyGenerated\n\n"}
{"name":"atBot_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : Preorder Î±\ninstâœ : OrderClosedTopology Î±\nâŠ¢ Filter.atBot.IsMeasurablyGenerated","decl":"instance atBot_isMeasurablyGenerated : (Filter.atBot : Filter Î±).IsMeasurablyGenerated :=\n  @Filter.iInf_isMeasurablyGenerated _ _ _ _ fun a =>\n    (measurableSet_Iic : MeasurableSet (Iic a)).principal_isMeasurablyGenerated\n\n"}
{"name":"instIsMeasurablyGeneratedCocompactOfR1Space","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœ : R1Space Î±\nâŠ¢ (Filter.cocompact Î±).IsMeasurablyGenerated","decl":"instance [R1Space Î±] : IsMeasurablyGenerated (cocompact Î±) where\n  exists_measurable_subset := by\n    intro _ hs\n    obtain âŸ¨t, ht, htsâŸ© := mem_cocompact.mp hs\n    exact âŸ¨(closure t)á¶œ, ht.closure.compl_mem_cocompact, isClosed_closure.measurableSet.compl,\n      (compl_subset_compl.2 subset_closure).trans htsâŸ©\n\n"}
{"name":"measurableSet_le'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\ninstâœÂ² : PartialOrder Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : SecondCountableTopology Î±\nâŠ¢ MeasurableSet (setOf fun p => LE.le p.1 p.2)","decl":"@[measurability]\ntheorem measurableSet_le' : MeasurableSet { p : Î± Ã— Î± | p.1 â‰¤ p.2 } :=\n  OrderClosedTopology.isClosed_le'.measurableSet\n\n"}
{"name":"measurableSet_le","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : PartialOrder Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : SecondCountableTopology Î±\nf g : Î´ â†’ Î±\nhf : Measurable f\nhg : Measurable g\nâŠ¢ MeasurableSet (setOf fun a => LE.le (f a) (g a))","decl":"@[measurability]\ntheorem measurableSet_le {f g : Î´ â†’ Î±} (hf : Measurable f) (hg : Measurable g) :\n    MeasurableSet { a | f a â‰¤ g a } :=\n  hf.prod_mk hg measurableSet_le'\n\n"}
{"name":"measurableSet_Iio","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na : Î±\nâŠ¢ MeasurableSet (Set.Iio a)","decl":"@[simp, measurability]\ntheorem measurableSet_Iio : MeasurableSet (Iio a) :=\n  isOpen_Iio.measurableSet\n\n"}
{"name":"nullMeasurableSet_Iio","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na : Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ MeasureTheory.NullMeasurableSet (Set.Iio a) Î¼","decl":"theorem nullMeasurableSet_Iio : NullMeasurableSet (Iio a) Î¼ :=\n  measurableSet_Iio.nullMeasurableSet\n\n"}
{"name":"measurableSet_Ioi","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na : Î±\nâŠ¢ MeasurableSet (Set.Ioi a)","decl":"@[simp, measurability]\ntheorem measurableSet_Ioi : MeasurableSet (Ioi a) :=\n  isOpen_Ioi.measurableSet\n\n"}
{"name":"nullMeasurableSet_Ioi","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na : Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ MeasureTheory.NullMeasurableSet (Set.Ioi a) Î¼","decl":"theorem nullMeasurableSet_Ioi : NullMeasurableSet (Ioi a) Î¼ :=\n  measurableSet_Ioi.nullMeasurableSet\n\n"}
{"name":"measurableSet_Ioo","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nâŠ¢ MeasurableSet (Set.Ioo a b)","decl":"@[simp, measurability]\ntheorem measurableSet_Ioo : MeasurableSet (Ioo a b) :=\n  isOpen_Ioo.measurableSet\n\n"}
{"name":"nullMeasurableSet_Ioo","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ MeasureTheory.NullMeasurableSet (Set.Ioo a b) Î¼","decl":"theorem nullMeasurableSet_Ioo : NullMeasurableSet (Ioo a b) Î¼ :=\n  measurableSet_Ioo.nullMeasurableSet\n\n"}
{"name":"measurableSet_Ioc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nâŠ¢ MeasurableSet (Set.Ioc a b)","decl":"@[simp, measurability]\ntheorem measurableSet_Ioc : MeasurableSet (Ioc a b) :=\n  measurableSet_Ioi.inter measurableSet_Iic\n\n"}
{"name":"nullMeasurableSet_Ioc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ MeasureTheory.NullMeasurableSet (Set.Ioc a b) Î¼","decl":"theorem nullMeasurableSet_Ioc : NullMeasurableSet (Ioc a b) Î¼ :=\n  measurableSet_Ioc.nullMeasurableSet\n\n"}
{"name":"measurableSet_Ico","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nâŠ¢ MeasurableSet (Set.Ico a b)","decl":"@[simp, measurability]\ntheorem measurableSet_Ico : MeasurableSet (Ico a b) :=\n  measurableSet_Ici.inter measurableSet_Iio\n\n"}
{"name":"nullMeasurableSet_Ico","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ MeasureTheory.NullMeasurableSet (Set.Ico a b) Î¼","decl":"theorem nullMeasurableSet_Ico : NullMeasurableSet (Ico a b) Î¼ :=\n  measurableSet_Ico.nullMeasurableSet\n\n"}
{"name":"nhdsWithin_Ioi_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nâŠ¢ (nhdsWithin a (Set.Ioi b)).IsMeasurablyGenerated","decl":"instance nhdsWithin_Ioi_isMeasurablyGenerated : (ğ“[Ioi b] a).IsMeasurablyGenerated :=\n  measurableSet_Ioi.nhdsWithin_isMeasurablyGenerated _\n\n"}
{"name":"nhdsWithin_Iio_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nâŠ¢ (nhdsWithin a (Set.Iio b)).IsMeasurablyGenerated","decl":"instance nhdsWithin_Iio_isMeasurablyGenerated : (ğ“[Iio b] a).IsMeasurablyGenerated :=\n  measurableSet_Iio.nhdsWithin_isMeasurablyGenerated _\n\n"}
{"name":"nhdsWithin_uIcc_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœ : LinearOrder Î±\na b x : Î±\nâŠ¢ (nhdsWithin x (Set.uIcc a b)).IsMeasurablyGenerated","decl":"instance nhdsWithin_uIcc_isMeasurablyGenerated : IsMeasurablyGenerated (ğ“[[[a, b]]] x) :=\n  nhdsWithin_Icc_isMeasurablyGenerated\n\n"}
{"name":"measurableSet_lt'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : SecondCountableTopology Î±\nâŠ¢ MeasurableSet (setOf fun p => LT.lt p.1 p.2)","decl":"@[measurability]\ntheorem measurableSet_lt' [SecondCountableTopology Î±] : MeasurableSet { p : Î± Ã— Î± | p.1 < p.2 } :=\n  (isOpen_lt continuous_fst continuous_snd).measurableSet\n\n"}
{"name":"measurableSet_lt","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : SecondCountableTopology Î±\nf g : Î´ â†’ Î±\nhf : Measurable f\nhg : Measurable g\nâŠ¢ MeasurableSet (setOf fun a => LT.lt (f a) (g a))","decl":"@[measurability]\ntheorem measurableSet_lt [SecondCountableTopology Î±] {f g : Î´ â†’ Î±} (hf : Measurable f)\n    (hg : Measurable g) : MeasurableSet { a | f a < g a } :=\n  hf.prod_mk hg measurableSet_lt'\n\n"}
{"name":"nullMeasurableSet_lt","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¼ : MeasureTheory.Measure Î´\nf g : Î´ â†’ Î±\nhf : AEMeasurable f Î¼\nhg : AEMeasurable g Î¼\nâŠ¢ MeasureTheory.NullMeasurableSet (setOf fun a => LT.lt (f a) (g a)) Î¼","decl":"theorem nullMeasurableSet_lt [SecondCountableTopology Î±] {Î¼ : Measure Î´} {f g : Î´ â†’ Î±}\n    (hf : AEMeasurable f Î¼) (hg : AEMeasurable g Î¼) : NullMeasurableSet { a | f a < g a } Î¼ :=\n  (hf.prod_mk hg).nullMeasurable measurableSet_lt'\n\n"}
{"name":"nullMeasurableSet_lt'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¼ : MeasureTheory.Measure (Prod Î± Î±)\nâŠ¢ MeasureTheory.NullMeasurableSet (setOf fun p => LT.lt p.1 p.2) Î¼","decl":"theorem nullMeasurableSet_lt' [SecondCountableTopology Î±] {Î¼ : Measure (Î± Ã— Î±)} :\n    NullMeasurableSet { p : Î± Ã— Î± | p.1 < p.2 } Î¼ :=\n  measurableSet_lt'.nullMeasurableSet\n\n"}
{"name":"nullMeasurableSet_le","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¼ : MeasureTheory.Measure Î´\nf g : Î´ â†’ Î±\nhf : AEMeasurable f Î¼\nhg : AEMeasurable g Î¼\nâŠ¢ MeasureTheory.NullMeasurableSet (setOf fun a => LE.le (f a) (g a)) Î¼","decl":"theorem nullMeasurableSet_le [SecondCountableTopology Î±] {Î¼ : Measure Î´}\n    {f g : Î´ â†’ Î±} (hf : AEMeasurable f Î¼) (hg : AEMeasurable g Î¼) :\n    NullMeasurableSet { a | f a â‰¤ g a } Î¼ :=\n  (hf.prod_mk hg).nullMeasurable measurableSet_le'\n\n"}
{"name":"Set.OrdConnected.measurableSet","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ns : Set Î±\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\nh : s.OrdConnected\nâŠ¢ MeasurableSet s","decl":"theorem Set.OrdConnected.measurableSet (h : OrdConnected s) : MeasurableSet s := by\n  let u := â‹ƒ (x âˆˆ s) (y âˆˆ s), Ioo x y\n  have huopen : IsOpen u := isOpen_biUnion fun _ _ => isOpen_biUnion fun _ _ => isOpen_Ioo\n  have humeas : MeasurableSet u := huopen.measurableSet\n  have hfinite : (s \\ u).Finite := s.finite_diff_iUnion_Ioo\n  have : u âŠ† s := iUnionâ‚‚_subset fun x hx => iUnionâ‚‚_subset fun y hy =>\n    Ioo_subset_Icc_self.trans (h.out hx hy)\n  rw [â† union_diff_cancel this]\n  exact humeas.union hfinite.measurableSet\n\n"}
{"name":"IsPreconnected.measurableSet","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ns : Set Î±\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\nh : IsPreconnected s\nâŠ¢ MeasurableSet s","decl":"theorem IsPreconnected.measurableSet (h : IsPreconnected s) : MeasurableSet s :=\n  h.ordConnected.measurableSet\n\n"}
{"name":"generateFrom_Ico_mem_le_borel","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\ns t : Set Î±\nâŠ¢ LE.le (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem t u) (And (LT.lt l u) (Eq (Set.Ico l u) S))))) (borel Î±)","decl":"theorem generateFrom_Ico_mem_le_borel {Î± : Type*} [TopologicalSpace Î±] [LinearOrder Î±]\n    [OrderClosedTopology Î±] (s t : Set Î±) :\n    MeasurableSpace.generateFrom { S | âˆƒ l âˆˆ s, âˆƒ u âˆˆ t, l < u âˆ§ Ico l u = S }\n      â‰¤ borel Î± := by\n  apply generateFrom_le\n  borelize Î±\n  rintro _ âŸ¨a, -, b, -, -, rflâŸ©\n  exact measurableSet_Ico\n\n"}
{"name":"Dense.borel_eq_generateFrom_Ico_mem_aux","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\ns : Set Î±\nhd : Dense s\nhbot : âˆ€ (x : Î±), IsBot x â†’ Membership.mem s x\nhIoo : âˆ€ (x y : Î±), LT.lt x y â†’ Eq (Set.Ioo x y) EmptyCollection.emptyCollection â†’ Membership.mem s y\nâŠ¢ Eq (borel Î±) (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem s u) (And (LT.lt l u) (Eq (Set.Ico l u) S)))))","decl":"theorem Dense.borel_eq_generateFrom_Ico_mem_aux {Î± : Type*} [TopologicalSpace Î±] [LinearOrder Î±]\n    [OrderTopology Î±] [SecondCountableTopology Î±] {s : Set Î±} (hd : Dense s)\n    (hbot : âˆ€ x, IsBot x â†’ x âˆˆ s) (hIoo : âˆ€ x y : Î±, x < y â†’ Ioo x y = âˆ… â†’ y âˆˆ s) :\n    borel Î± = .generateFrom { S : Set Î± | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, l < u âˆ§ Ico l u = S } := by\n  set S : Set (Set Î±) := { S | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, l < u âˆ§ Ico l u = S }\n  refine le_antisymm ?_ (generateFrom_Ico_mem_le_borel _ _)\n  letI : MeasurableSpace Î± := generateFrom S\n  rw [borel_eq_generateFrom_Iio]\n  refine generateFrom_le (forall_mem_range.2 fun a => ?_)\n  rcases hd.exists_countable_dense_subset_bot_top with âŸ¨t, hts, hc, htd, htb, -âŸ©\n  by_cases ha : âˆ€ b < a, (Ioo b a).Nonempty\n  Â· convert_to MeasurableSet (â‹ƒ (l âˆˆ t) (u âˆˆ t) (_ : l < u) (_ : u â‰¤ a), Ico l u)\n    Â· ext y\n      simp only [mem_iUnion, mem_Iio, mem_Ico]\n      constructor\n      Â· intro hy\n        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with âŸ¨l, hlt, hlyâŸ©\n        rcases htd.exists_mem_open isOpen_Ioo (ha y hy) with âŸ¨u, hut, hyu, huaâŸ©\n        exact âŸ¨l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyuâŸ©\n      Â· rintro âŸ¨l, -, u, -, -, hua, -, hyuâŸ©\n        exact hyu.trans_le hua\n    Â· refine MeasurableSet.biUnion hc fun a ha => MeasurableSet.biUnion hc fun b hb => ?_\n      refine MeasurableSet.iUnion fun hab => MeasurableSet.iUnion fun _ => ?_\n      exact .basic _ âŸ¨a, hts ha, b, hts hb, hab, mem_singleton _âŸ©\n  Â· simp only [not_forall, not_nonempty_iff_eq_empty] at ha\n    replace ha : a âˆˆ s := hIoo ha.choose a ha.choose_spec.fst ha.choose_spec.snd\n    convert_to MeasurableSet (â‹ƒ (l âˆˆ t) (_ : l < a), Ico l a)\n    Â· symm\n      simp only [â† Ici_inter_Iio, â† iUnion_inter, inter_eq_right, subset_def, mem_iUnion,\n        mem_Ici, mem_Iio]\n      intro x hx\n      rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with âŸ¨z, hzt, hzxâŸ©\n      exact âŸ¨z, hzt, hzx.trans_lt hx, hzxâŸ©\n    Â· refine .biUnion hc fun x hx => MeasurableSet.iUnion fun hlt => ?_\n      exact .basic _ âŸ¨x, hts hx, a, ha, hlt, mem_singleton _âŸ©\n\n"}
{"name":"Dense.borel_eq_generateFrom_Ico_mem","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : OrderTopology Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : DenselyOrdered Î±\ninstâœ : NoMinOrder Î±\ns : Set Î±\nhd : Dense s\nâŠ¢ Eq (borel Î±) (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem s u) (And (LT.lt l u) (Eq (Set.Ico l u) S)))))","decl":"theorem Dense.borel_eq_generateFrom_Ico_mem {Î± : Type*} [TopologicalSpace Î±] [LinearOrder Î±]\n    [OrderTopology Î±] [SecondCountableTopology Î±] [DenselyOrdered Î±] [NoMinOrder Î±] {s : Set Î±}\n    (hd : Dense s) :\n    borel Î± = .generateFrom { S : Set Î± | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, l < u âˆ§ Ico l u = S } :=\n  hd.borel_eq_generateFrom_Ico_mem_aux (by simp) fun _ _ hxy H =>\n    ((nonempty_Ioo.2 hxy).ne_empty H).elim\n\n"}
{"name":"borel_eq_generateFrom_Ico","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderTopology Î±\nâŠ¢ Eq (borel Î±) (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => Exists fun u => And (LT.lt l u) (Eq (Set.Ico l u) S)))","decl":"theorem borel_eq_generateFrom_Ico (Î± : Type*) [TopologicalSpace Î±] [SecondCountableTopology Î±]\n    [LinearOrder Î±] [OrderTopology Î±] :\n    borel Î± = .generateFrom { S : Set Î± | âˆƒ (l u : Î±), l < u âˆ§ Ico l u = S } := by\n  simpa only [exists_prop, mem_univ, true_and] using\n    (@dense_univ Î± _).borel_eq_generateFrom_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>\n      mem_univ _\n\n"}
{"name":"Dense.borel_eq_generateFrom_Ioc_mem_aux","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\ns : Set Î±\nhd : Dense s\nhbot : âˆ€ (x : Î±), IsTop x â†’ Membership.mem s x\nhIoo : âˆ€ (x y : Î±), LT.lt x y â†’ Eq (Set.Ioo x y) EmptyCollection.emptyCollection â†’ Membership.mem s x\nâŠ¢ Eq (borel Î±) (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem s u) (And (LT.lt l u) (Eq (Set.Ioc l u) S)))))","decl":"theorem Dense.borel_eq_generateFrom_Ioc_mem_aux {Î± : Type*} [TopologicalSpace Î±] [LinearOrder Î±]\n    [OrderTopology Î±] [SecondCountableTopology Î±] {s : Set Î±} (hd : Dense s)\n    (hbot : âˆ€ x, IsTop x â†’ x âˆˆ s) (hIoo : âˆ€ x y : Î±, x < y â†’ Ioo x y = âˆ… â†’ x âˆˆ s) :\n    borel Î± = .generateFrom { S : Set Î± | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, l < u âˆ§ Ioc l u = S } := by\n  convert hd.orderDual.borel_eq_generateFrom_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _\n    using 2\n  Â· ext s\n    constructor <;> rintro âŸ¨l, hl, u, hu, hlt, rflâŸ©\n    exacts [âŸ¨u, hu, l, hl, hlt, dual_IcoâŸ©, âŸ¨u, hu, l, hl, hlt, dual_IocâŸ©]\n  Â· erw [dual_Ioo]\n    exact he\n\n"}
{"name":"Dense.borel_eq_generateFrom_Ioc_mem","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : OrderTopology Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : DenselyOrdered Î±\ninstâœ : NoMaxOrder Î±\ns : Set Î±\nhd : Dense s\nâŠ¢ Eq (borel Î±) (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => And (Membership.mem s l) (Exists fun u => And (Membership.mem s u) (And (LT.lt l u) (Eq (Set.Ioc l u) S)))))","decl":"theorem Dense.borel_eq_generateFrom_Ioc_mem {Î± : Type*} [TopologicalSpace Î±] [LinearOrder Î±]\n    [OrderTopology Î±] [SecondCountableTopology Î±] [DenselyOrdered Î±] [NoMaxOrder Î±] {s : Set Î±}\n    (hd : Dense s) :\n    borel Î± = .generateFrom { S : Set Î± | âˆƒ l âˆˆ s, âˆƒ u âˆˆ s, l < u âˆ§ Ioc l u = S } :=\n  hd.borel_eq_generateFrom_Ioc_mem_aux (by simp) fun _ _ hxy H =>\n    ((nonempty_Ioo.2 hxy).ne_empty H).elim\n\n"}
{"name":"borel_eq_generateFrom_Ioc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderTopology Î±\nâŠ¢ Eq (borel Î±) (MeasurableSpace.generateFrom (setOf fun S => Exists fun l => Exists fun u => And (LT.lt l u) (Eq (Set.Ioc l u) S)))","decl":"theorem borel_eq_generateFrom_Ioc (Î± : Type*) [TopologicalSpace Î±] [SecondCountableTopology Î±]\n    [LinearOrder Î±] [OrderTopology Î±] :\n    borel Î± = .generateFrom { S : Set Î± | âˆƒ l u, l < u âˆ§ Ioc l u = S } := by\n  simpa only [exists_prop, mem_univ, true_and] using\n    (@dense_univ Î± _).borel_eq_generateFrom_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>\n      mem_univ _\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ico_finite","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœâµ : TopologicalSpace Î±\nm : MeasurableSpace Î±\ninstâœâ´ : SecondCountableTopology Î±\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : BorelSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhÎ¼Î½ : Eq (Î¼ Set.univ) (Î½ Set.univ)\nh : âˆ€ â¦ƒa b : Î±â¦„, LT.lt a b â†’ Eq (Î¼ (Set.Ico a b)) (Î½ (Set.Ico a b))\nâŠ¢ Eq Î¼ Î½","decl":"/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If\n`Î±` is a conditionally complete linear order with no top element,\n`MeasureTheory.Measure.ext_of_Ico` is an extensionality lemma with weaker assumptions on `Î¼` and\n`Î½`. -/\ntheorem ext_of_Ico_finite {Î± : Type*} [TopologicalSpace Î±] {m : MeasurableSpace Î±}\n    [SecondCountableTopology Î±] [LinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] (Î¼ Î½ : Measure Î±)\n    [IsFiniteMeasure Î¼] (hÎ¼Î½ : Î¼ univ = Î½ univ) (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) :\n    Î¼ = Î½ := by\n  refine\n    ext_of_generate_finite _ (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico Î±))\n      (isPiSystem_Ico (id : Î± â†’ Î±) id) ?_ hÎ¼Î½\n  rintro - âŸ¨a, b, hlt, rflâŸ©\n  exact h hlt\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ioc_finite","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœâµ : TopologicalSpace Î±\nm : MeasurableSpace Î±\ninstâœâ´ : SecondCountableTopology Î±\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : BorelSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhÎ¼Î½ : Eq (Î¼ Set.univ) (Î½ Set.univ)\nh : âˆ€ â¦ƒa b : Î±â¦„, LT.lt a b â†’ Eq (Î¼ (Set.Ioc a b)) (Î½ (Set.Ioc a b))\nâŠ¢ Eq Î¼ Î½","decl":"/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If\n`Î±` is a conditionally complete linear order with no top element,\n`MeasureTheory.Measure.ext_of_Ioc` is an extensionality lemma with weaker assumptions on `Î¼` and\n`Î½`. -/\ntheorem ext_of_Ioc_finite {Î± : Type*} [TopologicalSpace Î±] {m : MeasurableSpace Î±}\n    [SecondCountableTopology Î±] [LinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] (Î¼ Î½ : Measure Î±)\n    [IsFiniteMeasure Î¼] (hÎ¼Î½ : Î¼ univ = Î½ univ) (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) :\n    Î¼ = Î½ := by\n  refine @ext_of_Ico_finite Î±áµ’áµˆ _ _ _ _ _ â€¹_â€º Î¼ Î½ _ hÎ¼Î½ fun a b hab => ?_\n  erw [dual_Ico (Î± := Î±)]\n  exact h hab\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ico'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœâµ : TopologicalSpace Î±\nm : MeasurableSpace Î±\ninstâœâ´ : SecondCountableTopology Î±\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : NoMaxOrder Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\nhÎ¼ : âˆ€ â¦ƒa b : Î±â¦„, LT.lt a b â†’ Ne (Î¼ (Set.Ico a b)) Top.top\nh : âˆ€ â¦ƒa b : Î±â¦„, LT.lt a b â†’ Eq (Î¼ (Set.Ico a b)) (Î½ (Set.Ico a b))\nâŠ¢ Eq Î¼ Î½","decl":"/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nclosed-open intervals. -/\ntheorem ext_of_Ico' {Î± : Type*} [TopologicalSpace Î±] {m : MeasurableSpace Î±}\n    [SecondCountableTopology Î±] [LinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] [NoMaxOrder Î±]\n    (Î¼ Î½ : Measure Î±) (hÎ¼ : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) â‰  âˆ)\n    (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) : Î¼ = Î½ := by\n  rcases exists_countable_dense_bot_top Î± with âŸ¨s, hsc, hsd, hsb, _âŸ©\n  have : (â‹ƒ (l âˆˆ s) (u âˆˆ s) (_ : l < u), {Ico l u} : Set (Set Î±)).Countable :=\n    hsc.biUnion fun l _ => hsc.biUnion fun u _ => countable_iUnion fun _ => countable_singleton _\n  simp only [â† setOf_eq_eq_singleton, â† setOf_exists] at this\n  refine\n    Measure.ext_of_generateFrom_of_cover_subset\n      (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico Î±)) (isPiSystem_Ico id id) ?_ this\n      ?_ ?_ ?_\n  Â· rintro _ âŸ¨l, -, u, -, h, rflâŸ©\n    exact âŸ¨l, u, h, rflâŸ©\n  Â· refine sUnion_eq_univ_iff.2 fun x => ?_\n    rcases hsd.exists_le' hsb x with âŸ¨l, hls, hlxâŸ©\n    rcases hsd.exists_gt x with âŸ¨u, hus, hxuâŸ©\n    exact âŸ¨_, âŸ¨l, hls, u, hus, hlx.trans_lt hxu, rflâŸ©, hlx, hxuâŸ©\n  Â· rintro _ âŸ¨l, -, u, -, hlt, rflâŸ©\n    exact hÎ¼ hlt\n  Â· rintro _ âŸ¨l, u, hlt, rflâŸ©\n    exact h hlt\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ioc'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœâµ : TopologicalSpace Î±\nm : MeasurableSpace Î±\ninstâœâ´ : SecondCountableTopology Î±\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : BorelSpace Î±\ninstâœ : NoMinOrder Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\nhÎ¼ : âˆ€ â¦ƒa b : Î±â¦„, LT.lt a b â†’ Ne (Î¼ (Set.Ioc a b)) Top.top\nh : âˆ€ â¦ƒa b : Î±â¦„, LT.lt a b â†’ Eq (Î¼ (Set.Ioc a b)) (Î½ (Set.Ioc a b))\nâŠ¢ Eq Î¼ Î½","decl":"/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nopen-closed intervals. -/\ntheorem ext_of_Ioc' {Î± : Type*} [TopologicalSpace Î±] {m : MeasurableSpace Î±}\n    [SecondCountableTopology Î±] [LinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] [NoMinOrder Î±]\n    (Î¼ Î½ : Measure Î±) (hÎ¼ : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) â‰  âˆ)\n    (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) : Î¼ = Î½ := by\n  refine @ext_of_Ico' Î±áµ’áµˆ _ _ _ _ _ â€¹_â€º _ Î¼ Î½ ?_ ?_ <;> intro a b hab <;> erw [dual_Ico (Î± := Î±)]\n  exacts [hÎ¼ hab, h hab]\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ico","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœâ¶ : TopologicalSpace Î±\n_m : MeasurableSpace Î±\ninstâœâµ : SecondCountableTopology Î±\ninstâœâ´ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ³ : OrderTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : NoMaxOrder Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nh : âˆ€ â¦ƒa b : Î±â¦„, LT.lt a b â†’ Eq (Î¼ (Set.Ico a b)) (Î½ (Set.Ico a b))\nâŠ¢ Eq Î¼ Î½","decl":"/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nclosed-open intervals. -/\ntheorem ext_of_Ico {Î± : Type*} [TopologicalSpace Î±] {_m : MeasurableSpace Î±}\n    [SecondCountableTopology Î±] [ConditionallyCompleteLinearOrder Î±] [OrderTopology Î±]\n    [BorelSpace Î±] [NoMaxOrder Î±] (Î¼ Î½ : Measure Î±) [IsLocallyFiniteMeasure Î¼]\n    (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) : Î¼ = Î½ :=\n  Î¼.ext_of_Ico' Î½ (fun _ _ _ => measure_Ico_lt_top.ne) h\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ioc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœâ¶ : TopologicalSpace Î±\n_m : MeasurableSpace Î±\ninstâœâµ : SecondCountableTopology Î±\ninstâœâ´ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ³ : OrderTopology Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : NoMinOrder Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nh : âˆ€ â¦ƒa b : Î±â¦„, LT.lt a b â†’ Eq (Î¼ (Set.Ioc a b)) (Î½ (Set.Ioc a b))\nâŠ¢ Eq Î¼ Î½","decl":"/-- Two measures which are finite on closed-open intervals are equal if they agree on all\nopen-closed intervals. -/\ntheorem ext_of_Ioc {Î± : Type*} [TopologicalSpace Î±] {_m : MeasurableSpace Î±}\n    [SecondCountableTopology Î±] [ConditionallyCompleteLinearOrder Î±] [OrderTopology Î±]\n    [BorelSpace Î±] [NoMinOrder Î±] (Î¼ Î½ : Measure Î±) [IsLocallyFiniteMeasure Î¼]\n    (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) : Î¼ = Î½ :=\n  Î¼.ext_of_Ioc' Î½ (fun _ _ _ => measure_Ioc_lt_top.ne) h\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Iic","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœâµ : TopologicalSpace Î±\nm : MeasurableSpace Î±\ninstâœâ´ : SecondCountableTopology Î±\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : BorelSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nh : âˆ€ (a : Î±), Eq (Î¼ (Set.Iic a)) (Î½ (Set.Iic a))\nâŠ¢ Eq Î¼ Î½","decl":"/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed\nintervals. -/\ntheorem ext_of_Iic {Î± : Type*} [TopologicalSpace Î±] {m : MeasurableSpace Î±}\n    [SecondCountableTopology Î±] [LinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] (Î¼ Î½ : Measure Î±)\n    [IsFiniteMeasure Î¼] (h : âˆ€ a, Î¼ (Iic a) = Î½ (Iic a)) : Î¼ = Î½ := by\n  refine ext_of_Ioc_finite Î¼ Î½ ?_ fun a b hlt => ?_\n  Â· rcases exists_countable_dense_bot_top Î± with âŸ¨s, hsc, hsd, -, hstâŸ©\n    have : DirectedOn (Â· â‰¤ Â·) s := directedOn_iff_directed.2 (Subtype.mono_coe _).directed_le\n    simp only [â† biSup_measure_Iic hsc (hsd.exists_ge' hst) this, h]\n  rw [â† Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) nullMeasurableSet_Iic,\n    measure_diff (Iic_subset_Iic.2 hlt.le) nullMeasurableSet_Iic, h a, h b]\n  Â· rw [â† h a]\n    exact measure_ne_top Î¼ _\n  Â· exact measure_ne_top Î¼ _\n\n"}
{"name":"MeasureTheory.Measure.ext_of_Ici","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\ninstâœâµ : TopologicalSpace Î±\nxâœ : MeasurableSpace Î±\ninstâœâ´ : SecondCountableTopology Î±\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : BorelSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nh : âˆ€ (a : Î±), Eq (Î¼ (Set.Ici a)) (Î½ (Set.Ici a))\nâŠ¢ Eq Î¼ Î½","decl":"/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite\nintervals. -/\ntheorem ext_of_Ici {Î± : Type*} [TopologicalSpace Î±] {_ : MeasurableSpace Î±}\n    [SecondCountableTopology Î±] [LinearOrder Î±] [OrderTopology Î±] [BorelSpace Î±] (Î¼ Î½ : Measure Î±)\n    [IsFiniteMeasure Î¼] (h : âˆ€ a, Î¼ (Ici a) = Î½ (Ici a)) : Î¼ = Î½ :=\n  @ext_of_Iic Î±áµ’áµˆ _ _ _ _ _ â€¹_â€º _ _ _ h\n\n"}
{"name":"measurableSet_uIcc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nâŠ¢ MeasurableSet (Set.uIcc a b)","decl":"@[measurability]\ntheorem measurableSet_uIcc : MeasurableSet (uIcc a b) :=\n  measurableSet_Icc\n\n"}
{"name":"measurableSet_uIoc","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœÂ³ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ² : OpensMeasurableSpace Î±\ninstâœÂ¹ : LinearOrder Î±\ninstâœ : OrderClosedTopology Î±\na b : Î±\nâŠ¢ MeasurableSet (Set.uIoc a b)","decl":"@[measurability]\ntheorem measurableSet_uIoc : MeasurableSet (uIoc a b) :=\n  measurableSet_Ioc\n\n"}
{"name":"Measurable.max","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : SecondCountableTopology Î±\nf g : Î´ â†’ Î±\nhf : Measurable f\nhg : Measurable g\nâŠ¢ Measurable fun a => Max.max (f a) (g a)","decl":"@[measurability]\ntheorem Measurable.max {f g : Î´ â†’ Î±} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => max (f a) (g a) := by\n  simpa only [max_def'] using hf.piecewise (measurableSet_le hg hf) hg\n\n"}
{"name":"AEMeasurable.max","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : SecondCountableTopology Î±\nf g : Î´ â†’ Î±\nÎ¼ : MeasureTheory.Measure Î´\nhf : AEMeasurable f Î¼\nhg : AEMeasurable g Î¼\nâŠ¢ AEMeasurable (fun a => Max.max (f a) (g a)) Î¼","decl":"@[measurability]\nnonrec theorem AEMeasurable.max {f g : Î´ â†’ Î±} {Î¼ : Measure Î´} (hf : AEMeasurable f Î¼)\n    (hg : AEMeasurable g Î¼) : AEMeasurable (fun a => max (f a) (g a)) Î¼ :=\n  âŸ¨fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,\n    EventuallyEq.compâ‚‚ hf.ae_eq_mk _ hg.ae_eq_mkâŸ©\n\n"}
{"name":"Measurable.min","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : SecondCountableTopology Î±\nf g : Î´ â†’ Î±\nhf : Measurable f\nhg : Measurable g\nâŠ¢ Measurable fun a => Min.min (f a) (g a)","decl":"@[measurability]\ntheorem Measurable.min {f g : Î´ â†’ Î±} (hf : Measurable f) (hg : Measurable g) :\n    Measurable fun a => min (f a) (g a) := by\n  simpa only [min_def] using hf.piecewise (measurableSet_le hf hg) hg\n\n"}
{"name":"AEMeasurable.min","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : OpensMeasurableSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderClosedTopology Î±\ninstâœ : SecondCountableTopology Î±\nf g : Î´ â†’ Î±\nÎ¼ : MeasureTheory.Measure Î´\nhf : AEMeasurable f Î¼\nhg : AEMeasurable g Î¼\nâŠ¢ AEMeasurable (fun a => Min.min (f a) (g a)) Î¼","decl":"@[measurability]\nnonrec theorem AEMeasurable.min {f g : Î´ â†’ Î±} {Î¼ : Measure Î´} (hf : AEMeasurable f Î¼)\n    (hg : AEMeasurable g Î¼) : AEMeasurable (fun a => min (f a) (g a)) Î¼ :=\n  âŸ¨fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,\n    EventuallyEq.compâ‚‚ hf.ae_eq_mk _ hg.ae_eq_mkâŸ©\n\n"}
{"name":"ContinuousSup.measurableSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î³ : Type u_3\ninstâœÂ³ : TopologicalSpace Î³\nmÎ³ : MeasurableSpace Î³\ninstâœÂ² : BorelSpace Î³\ninstâœÂ¹ : Max Î³\ninstâœ : ContinuousSup Î³\nâŠ¢ MeasurableSup Î³","decl":"instance (priority := 100) ContinuousSup.measurableSup [Max Î³] [ContinuousSup Î³] :\n    MeasurableSup Î³ where\n  measurable_const_sup _ := (continuous_const.sup continuous_id).measurable\n  measurable_sup_const _ := (continuous_id.sup continuous_const).measurable\n\n"}
{"name":"ContinuousSup.measurableSupâ‚‚","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î³ : Type u_3\ninstâœâ´ : TopologicalSpace Î³\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : BorelSpace Î³\ninstâœÂ² : SecondCountableTopology Î³\ninstâœÂ¹ : Max Î³\ninstâœ : ContinuousSup Î³\nâŠ¢ MeasurableSupâ‚‚ Î³","decl":"instance (priority := 100) ContinuousSup.measurableSupâ‚‚ [SecondCountableTopology Î³] [Max Î³]\n    [ContinuousSup Î³] : MeasurableSupâ‚‚ Î³ :=\n  âŸ¨continuous_sup.measurableâŸ©\n\n"}
{"name":"ContinuousInf.measurableInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î³ : Type u_3\ninstâœÂ³ : TopologicalSpace Î³\nmÎ³ : MeasurableSpace Î³\ninstâœÂ² : BorelSpace Î³\ninstâœÂ¹ : Min Î³\ninstâœ : ContinuousInf Î³\nâŠ¢ MeasurableInf Î³","decl":"instance (priority := 100) ContinuousInf.measurableInf [Min Î³] [ContinuousInf Î³] :\n    MeasurableInf Î³ where\n  measurable_const_inf _ := (continuous_const.inf continuous_id).measurable\n  measurable_inf_const _ := (continuous_id.inf continuous_const).measurable\n\n"}
{"name":"ContinuousInf.measurableInfâ‚‚","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î³ : Type u_3\ninstâœâ´ : TopologicalSpace Î³\nmÎ³ : MeasurableSpace Î³\ninstâœÂ³ : BorelSpace Î³\ninstâœÂ² : SecondCountableTopology Î³\ninstâœÂ¹ : Min Î³\ninstâœ : ContinuousInf Î³\nâŠ¢ MeasurableInfâ‚‚ Î³","decl":"instance (priority := 100) ContinuousInf.measurableInfâ‚‚ [SecondCountableTopology Î³] [Min Î³]\n    [ContinuousInf Î³] : MeasurableInfâ‚‚ Î³ :=\n  âŸ¨continuous_inf.measurableâŸ©\n\n"}
{"name":"measurable_of_Iio","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nf : Î´ â†’ Î±\nhf : âˆ€ (x : Î±), MeasurableSet (Set.preimage f (Set.Iio x))\nâŠ¢ Measurable f","decl":"theorem measurable_of_Iio {f : Î´ â†’ Î±} (hf : âˆ€ x, MeasurableSet (f â»Â¹' Iio x)) : Measurable f := by\n  convert measurable_generateFrom (Î± := Î´) _\n  Â· exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Iio _)\n  Â· rintro _ âŸ¨x, rflâŸ©; exact hf x\n\n"}
{"name":"UpperSemicontinuous.measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ¶ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâµ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : OrderTopology Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OpensMeasurableSpace Î´\nf : Î´ â†’ Î±\nhf : UpperSemicontinuous f\nâŠ¢ Measurable f","decl":"theorem UpperSemicontinuous.measurable [TopologicalSpace Î´] [OpensMeasurableSpace Î´] {f : Î´ â†’ Î±}\n    (hf : UpperSemicontinuous f) : Measurable f :=\n  measurable_of_Iio fun y => (hf.isOpen_preimage y).measurableSet\n\n"}
{"name":"measurable_of_Ioi","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nf : Î´ â†’ Î±\nhf : âˆ€ (x : Î±), MeasurableSet (Set.preimage f (Set.Ioi x))\nâŠ¢ Measurable f","decl":"theorem measurable_of_Ioi {f : Î´ â†’ Î±} (hf : âˆ€ x, MeasurableSet (f â»Â¹' Ioi x)) : Measurable f := by\n  convert measurable_generateFrom (Î± := Î´) _\n  Â· exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ioi _)\n  Â· rintro _ âŸ¨x, rflâŸ©; exact hf x\n\n"}
{"name":"LowerSemicontinuous.measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ¶ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâµ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : OrderTopology Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : OpensMeasurableSpace Î´\nf : Î´ â†’ Î±\nhf : LowerSemicontinuous f\nâŠ¢ Measurable f","decl":"theorem LowerSemicontinuous.measurable [TopologicalSpace Î´] [OpensMeasurableSpace Î´] {f : Î´ â†’ Î±}\n    (hf : LowerSemicontinuous f) : Measurable f :=\n  measurable_of_Ioi fun y => (hf.isOpen_preimage y).measurableSet\n\n"}
{"name":"measurable_of_Iic","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nf : Î´ â†’ Î±\nhf : âˆ€ (x : Î±), MeasurableSet (Set.preimage f (Set.Iic x))\nâŠ¢ Measurable f","decl":"theorem measurable_of_Iic {f : Î´ â†’ Î±} (hf : âˆ€ x, MeasurableSet (f â»Â¹' Iic x)) : Measurable f := by\n  apply measurable_of_Ioi\n  simp_rw [â† compl_Iic, preimage_compl, MeasurableSet.compl_iff]\n  assumption\n\n"}
{"name":"measurable_of_Ici","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nf : Î´ â†’ Î±\nhf : âˆ€ (x : Î±), MeasurableSet (Set.preimage f (Set.Ici x))\nâŠ¢ Measurable f","decl":"theorem measurable_of_Ici {f : Î´ â†’ Î±} (hf : âˆ€ x, MeasurableSet (f â»Â¹' Ici x)) : Measurable f := by\n  apply measurable_of_Iio\n  simp_rw [â† compl_Ici, preimage_compl, MeasurableSet.compl_iff]\n  assumption\n\n"}
{"name":"Measurable.isLUB","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\ng : Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), Measurable (f i)\nhg : âˆ€ (b : Î´), IsLUB (setOf fun a => Exists fun i => Eq (f i b) a) (g b)\nâŠ¢ Measurable g","decl":"/-- If a function is the least upper bound of countably many measurable functions,\nthen it is measurable. -/\ntheorem Measurable.isLUB {Î¹} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i))\n    (hg : âˆ€ b, IsLUB { a | âˆƒ i, f i b = a } (g b)) : Measurable g := by\n  change âˆ€ b, IsLUB (range fun i => f i b) (g b) at hg\n  rw [â€¹BorelSpace Î±â€º.measurable_eq, borel_eq_generateFrom_Ioi Î±]\n  apply measurable_generateFrom\n  rintro _ âŸ¨a, rflâŸ©\n  simp_rw [Set.preimage, mem_Ioi, lt_isLUB_iff (hg _), exists_range_iff, setOf_exists]\n  exact MeasurableSet.iUnion fun i => hf i (isOpen_lt' _).measurableSet\n\n"}
{"name":"Measurable.isLUB_of_mem","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\ng g' : Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), Measurable (f i)\ns : Set Î´\nhs : MeasurableSet s\nhg : âˆ€ (b : Î´), Membership.mem s b â†’ IsLUB (setOf fun a => Exists fun i => Eq (f i b) a) (g b)\nhg' : Set.EqOn g g' (HasCompl.compl s)\ng'_meas : Measurable g'\nâŠ¢ Measurable g","decl":"/-- If a function is the least upper bound of countably many measurable functions on a measurable\nset `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/\ntheorem Measurable.isLUB_of_mem {Î¹} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g g' : Î´ â†’ Î±}\n    (hf : âˆ€ i, Measurable (f i))\n    {s : Set Î´} (hs : MeasurableSet s) (hg : âˆ€ b âˆˆ s, IsLUB { a | âˆƒ i, f i b = a } (g b))\n    (hg' : EqOn g g' sá¶œ) (g'_meas : Measurable g') : Measurable g := by\n  classical\n  rcases isEmpty_or_nonempty Î¹ with hÎ¹|âŸ¨âŸ¨iâŸ©âŸ©\n  Â· rcases eq_empty_or_nonempty s with rfl|âŸ¨x, hxâŸ©\n    Â· convert g'_meas\n      rwa [compl_empty, eqOn_univ] at hg'\n    Â· have A : âˆ€ b âˆˆ s, IsBot (g b) := by simpa using hg\n      have B : âˆ€ b âˆˆ s, g b = g x := by\n        intro b hb\n        apply le_antisymm (A b hb (g x)) (A x hx (g b))\n      have : g = s.piecewise (fun _y â†¦ g x) g' := by\n        ext b\n        by_cases hb : b âˆˆ s\n        Â· simp [hb, B]\n        Â· simp [hb, hg' hb]\n      rw [this]\n      exact Measurable.piecewise hs measurable_const g'_meas\n  Â· have : Nonempty Î¹ := âŸ¨iâŸ©\n    let f' : Î¹ â†’ Î´ â†’ Î± := fun i â†¦ s.piecewise (f i) g'\n    suffices âˆ€ b, IsLUB { a | âˆƒ i, f' i b = a } (g b) from\n      Measurable.isLUB (fun i â†¦ Measurable.piecewise hs (hf i) g'_meas) this\n    intro b\n    by_cases hb : b âˆˆ s\n    Â· have A : âˆ€ i, f' i b = f i b := fun i â†¦ by simp [f', hb]\n      simpa [A] using hg b hb\n    Â· have A : âˆ€ i, f' i b = g' b := fun i â†¦ by simp [f', hb]\n      simp [A, hg' hb, isLUB_singleton]\n\n"}
{"name":"AEMeasurable.isLUB","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\nÎ¼ : MeasureTheory.Measure Î´\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\ng : Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), AEMeasurable (f i) Î¼\nhg : Filter.Eventually (fun b => IsLUB (setOf fun a => Exists fun i => Eq (f i b) a) (g b)) (MeasureTheory.ae Î¼)\nâŠ¢ AEMeasurable g Î¼","decl":"theorem AEMeasurable.isLUB {Î¹} {Î¼ : Measure Î´} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±}\n    (hf : âˆ€ i, AEMeasurable (f i) Î¼) (hg : âˆ€áµ b âˆ‚Î¼, IsLUB { a | âˆƒ i, f i b = a } (g b)) :\n    AEMeasurable g Î¼ := by\n  classical\n  nontriviality Î±\n  haveI hÎ± : Nonempty Î± := inferInstance\n  cases' isEmpty_or_nonempty Î¹ with hÎ¹ hÎ¹\n  Â· simp only [IsEmpty.exists_iff, setOf_false, isLUB_empty_iff] at hg\n    exact aemeasurable_const' (hg.mono fun a ha => hg.mono fun b hb => (ha _).antisymm (hb _))\n  let p : Î´ â†’ (Î¹ â†’ Î±) â†’ Prop := fun x f' => IsLUB { a | âˆƒ i, f' i = a } (g x)\n  let g_seq := (aeSeqSet hf p).piecewise g fun _ => hÎ±.some\n  have hg_seq : âˆ€ b, IsLUB { a | âˆƒ i, aeSeq hf p i b = a } (g_seq b) := by\n    intro b\n    simp only [g_seq, aeSeq, Set.piecewise]\n    split_ifs with h\n    Â· have h_set_eq : { a : Î± | âˆƒ i : Î¹, (hf i).mk (f i) b = a } =\n        { a : Î± | âˆƒ i : Î¹, f i b = a } := by\n        ext x\n        simp_rw [Set.mem_setOf_eq, aeSeq.mk_eq_fun_of_mem_aeSeqSet hf h]\n      rw [h_set_eq]\n      exact aeSeq.fun_prop_of_mem_aeSeqSet hf h\n    Â· exact IsGreatest.isLUB âŸ¨(@exists_const (hÎ±.some = hÎ±.some) Î¹ _).2 rfl, fun x âŸ¨i, hiâŸ© => hi.geâŸ©\n  refine âŸ¨g_seq, Measurable.isLUB (aeSeq.measurable hf p) hg_seq, ?_âŸ©\n  exact\n    (ite_ae_eq_of_measure_compl_zero g (fun _ => hÎ±.some) (aeSeqSet hf p)\n        (aeSeq.measure_compl_aeSeqSet_eq_zero hf hg)).symm\n\n"}
{"name":"Measurable.isGLB","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\ng : Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), Measurable (f i)\nhg : âˆ€ (b : Î´), IsGLB (setOf fun a => Exists fun i => Eq (f i b) a) (g b)\nâŠ¢ Measurable g","decl":"/-- If a function is the greatest lower bound of countably many measurable functions,\nthen it is measurable. -/\ntheorem Measurable.isGLB {Î¹} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i))\n    (hg : âˆ€ b, IsGLB { a | âˆƒ i, f i b = a } (g b)) : Measurable g :=\n  Measurable.isLUB (Î± := Î±áµ’áµˆ) hf hg\n\n"}
{"name":"Measurable.isGLB_of_mem","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\ng g' : Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), Measurable (f i)\ns : Set Î´\nhs : MeasurableSet s\nhg : âˆ€ (b : Î´), Membership.mem s b â†’ IsGLB (setOf fun a => Exists fun i => Eq (f i b) a) (g b)\nhg' : Set.EqOn g g' (HasCompl.compl s)\ng'_meas : Measurable g'\nâŠ¢ Measurable g","decl":"/-- If a function is the greatest lower bound of countably many measurable functions on a measurable\nset `s`, and coincides with a measurable function outside of `s`, then it is measurable. -/\ntheorem Measurable.isGLB_of_mem {Î¹} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g g' : Î´ â†’ Î±}\n    (hf : âˆ€ i, Measurable (f i))\n    {s : Set Î´} (hs : MeasurableSet s) (hg : âˆ€ b âˆˆ s, IsGLB { a | âˆƒ i, f i b = a } (g b))\n    (hg' : EqOn g g' sá¶œ) (g'_meas : Measurable g') : Measurable g :=\n  Measurable.isLUB_of_mem (Î± := Î±áµ’áµˆ) hf hs hg hg'  g'_meas\n\n"}
{"name":"AEMeasurable.isGLB","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\nÎ¼ : MeasureTheory.Measure Î´\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\ng : Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), AEMeasurable (f i) Î¼\nhg : Filter.Eventually (fun b => IsGLB (setOf fun a => Exists fun i => Eq (f i b) a) (g b)) (MeasureTheory.ae Î¼)\nâŠ¢ AEMeasurable g Î¼","decl":"theorem AEMeasurable.isGLB {Î¹} {Î¼ : Measure Î´} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±}\n    (hf : âˆ€ i, AEMeasurable (f i) Î¼) (hg : âˆ€áµ b âˆ‚Î¼, IsGLB { a | âˆƒ i, f i b = a } (g b)) :\n    AEMeasurable g Î¼ :=\n  AEMeasurable.isLUB (Î± := Î±áµ’áµˆ) hf hg\n\n"}
{"name":"Monotone.measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ¸ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ· : BorelSpace Î±\ninstâœâ¶ : TopologicalSpace Î²\nmÎ² : MeasurableSpace Î²\ninstâœâµ : BorelSpace Î²\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : OrderTopology Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : LinearOrder Î²\ninstâœ : OrderClosedTopology Î²\nf : Î² â†’ Î±\nhf : Monotone f\nâŠ¢ Measurable f","decl":"protected theorem Monotone.measurable [LinearOrder Î²] [OrderClosedTopology Î²] {f : Î² â†’ Î±}\n    (hf : Monotone f) : Measurable f :=\n  suffices h : âˆ€ x, OrdConnected (f â»Â¹' Ioi x) from measurable_of_Ioi fun x => (h x).measurableSet\n  fun _ => ordConnected_def.mpr fun _a ha _ _ _c hc => lt_of_lt_of_le ha (hf hc.1)\n\n"}
{"name":"aemeasurable_restrict_of_monotoneOn","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ¸ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ· : BorelSpace Î±\ninstâœâ¶ : TopologicalSpace Î²\nmÎ² : MeasurableSpace Î²\ninstâœâµ : BorelSpace Î²\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : OrderTopology Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : LinearOrder Î²\ninstâœ : OrderClosedTopology Î²\nÎ¼ : MeasureTheory.Measure Î²\ns : Set Î²\nhs : MeasurableSet s\nf : Î² â†’ Î±\nhf : MonotoneOn f s\nâŠ¢ AEMeasurable f (Î¼.restrict s)","decl":"theorem aemeasurable_restrict_of_monotoneOn [LinearOrder Î²] [OrderClosedTopology Î²] {Î¼ : Measure Î²}\n    {s : Set Î²} (hs : MeasurableSet s) {f : Î² â†’ Î±} (hf : MonotoneOn f s) :\n    AEMeasurable f (Î¼.restrict s) :=\n  have : Monotone (f âˆ˜ (â†‘) : s â†’ Î±) := fun âŸ¨x, hxâŸ© âŸ¨y, hyâŸ© => fun (hxy : x â‰¤ y) => hf hx hy hxy\n  aemeasurable_restrict_of_measurable_subtype hs this.measurable\n\n"}
{"name":"Antitone.measurable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ¸ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ· : BorelSpace Î±\ninstâœâ¶ : TopologicalSpace Î²\nmÎ² : MeasurableSpace Î²\ninstâœâµ : BorelSpace Î²\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : OrderTopology Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : LinearOrder Î²\ninstâœ : OrderClosedTopology Î²\nf : Î² â†’ Î±\nhf : Antitone f\nâŠ¢ Measurable f","decl":"protected theorem Antitone.measurable [LinearOrder Î²] [OrderClosedTopology Î²] {f : Î² â†’ Î±}\n    (hf : Antitone f) : Measurable f :=\n  @Monotone.measurable Î±áµ’áµˆ Î² _ _ â€¹_â€º _ _ _ _ _ â€¹_â€º _ _ _ hf\n\n"}
{"name":"aemeasurable_restrict_of_antitoneOn","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ¸ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ· : BorelSpace Î±\ninstâœâ¶ : TopologicalSpace Î²\nmÎ² : MeasurableSpace Î²\ninstâœâµ : BorelSpace Î²\ninstâœâ´ : LinearOrder Î±\ninstâœÂ³ : OrderTopology Î±\ninstâœÂ² : SecondCountableTopology Î±\ninstâœÂ¹ : LinearOrder Î²\ninstâœ : OrderClosedTopology Î²\nÎ¼ : MeasureTheory.Measure Î²\ns : Set Î²\nhs : MeasurableSet s\nf : Î² â†’ Î±\nhf : AntitoneOn f s\nâŠ¢ AEMeasurable f (Î¼.restrict s)","decl":"theorem aemeasurable_restrict_of_antitoneOn [LinearOrder Î²] [OrderClosedTopology Î²] {Î¼ : Measure Î²}\n    {s : Set Î²} (hs : MeasurableSet s) {f : Î² â†’ Î±} (hf : AntitoneOn f s) :\n    AEMeasurable f (Î¼.restrict s) :=\n  @aemeasurable_restrict_of_monotoneOn Î±áµ’áµˆ Î² _ _ â€¹_â€º _ _ _ _ _ â€¹_â€º _ _ _ _ hs _ hf\n\n"}
{"name":"MeasurableSet.of_mem_nhdsGT_aux","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\ns : Set Î±\nh : âˆ€ (x : Î±), Membership.mem s x â†’ Membership.mem (nhdsWithin x (Set.Ioi x)) s\nh' : âˆ€ (x : Î±), Membership.mem s x â†’ Exists fun y => LT.lt x y\nâŠ¢ MeasurableSet s","decl":"theorem MeasurableSet.of_mem_nhdsGT_aux {s : Set Î±} (h : âˆ€ x âˆˆ s, s âˆˆ ğ“[>] x)\n    (h' : âˆ€ x âˆˆ s, âˆƒ y, x < y) : MeasurableSet s := by\n  choose! M hM using h'\n  suffices H : (s \\ interior s).Countable by\n    have : s = interior s âˆª s \\ interior s := by rw [union_diff_cancel interior_subset]\n    rw [this]\n    exact isOpen_interior.measurableSet.union H.measurableSet\n  have A : âˆ€ x âˆˆ s, âˆƒ y âˆˆ Ioi x, Ioo x y âŠ† s := fun x hx =>\n    (mem_nhdsGT_iff_exists_Ioo_subset' (hM x hx)).1 (h x hx)\n  choose! y hy h'y using A\n  have B : Set.PairwiseDisjoint (s \\ interior s) fun x => Ioo x (y x) := by\n    intro x hx x' hx' hxx'\n    rcases lt_or_gt_of_ne hxx' with (h' | h')\n    Â· refine disjoint_left.2 fun z hz h'z => ?_\n      have : x' âˆˆ interior s :=\n        mem_interior.2 âŸ¨Ioo x (y x), h'y _ hx.1, isOpen_Ioo, âŸ¨h', h'z.1.trans hz.2âŸ©âŸ©\n      exact False.elim (hx'.2 this)\n    Â· refine disjoint_left.2 fun z hz h'z => ?_\n      have : x âˆˆ interior s :=\n        mem_interior.2 âŸ¨Ioo x' (y x'), h'y _ hx'.1, isOpen_Ioo, âŸ¨h', hz.1.trans h'z.2âŸ©âŸ©\n      exact False.elim (hx.2 this)\n  exact B.countable_of_Ioo fun x hx => hy x hx.1\n\n"}
{"name":"measurableSet_of_mem_nhdsWithin_Ioi_aux","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\ns : Set Î±\nh : âˆ€ (x : Î±), Membership.mem s x â†’ Membership.mem (nhdsWithin x (Set.Ioi x)) s\nh' : âˆ€ (x : Î±), Membership.mem s x â†’ Exists fun y => LT.lt x y\nâŠ¢ MeasurableSet s","decl":"@[deprecated (since := \"2024-12-22\")]\nalias measurableSet_of_mem_nhdsWithin_Ioi_aux := MeasurableSet.of_mem_nhdsGT_aux\n\n"}
{"name":"MeasurableSet.of_mem_nhdsGT","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\ns : Set Î±\nh : âˆ€ (x : Î±), Membership.mem s x â†’ Membership.mem (nhdsWithin x (Set.Ioi x)) s\nâŠ¢ MeasurableSet s","decl":"/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem MeasurableSet.of_mem_nhdsGT {s : Set Î±} (h : âˆ€ x âˆˆ s, s âˆˆ ğ“[>] x) : MeasurableSet s := by\n  by_cases H : âˆƒ x âˆˆ s, IsTop x\n  Â· rcases H with âŸ¨xâ‚€, xâ‚€s, hâ‚€âŸ©\n    have : s = { xâ‚€ } âˆª s \\ { xâ‚€ } := by rw [union_diff_cancel (singleton_subset_iff.2 xâ‚€s)]\n    rw [this]\n    refine (measurableSet_singleton _).union ?_\n    have A : âˆ€ x âˆˆ s \\ { xâ‚€ }, x < xâ‚€ := fun x hx => lt_of_le_of_ne (hâ‚€ _) (by simpa using hx.2)\n    refine .of_mem_nhdsGT_aux (fun x hx => ?_) fun x hx => âŸ¨xâ‚€, A x hxâŸ©\n    obtain âŸ¨u, hu, usâŸ© : âˆƒ (u : Î±), u âˆˆ Ioi x âˆ§ Ioo x u âŠ† s :=\n      (mem_nhdsGT_iff_exists_Ioo_subset' (A x hx)).1 (h x hx.1)\n    refine (mem_nhdsGT_iff_exists_Ioo_subset' (A x hx)).2 âŸ¨u, hu, fun y hy => âŸ¨us hy, ?_âŸ©âŸ©\n    exact ne_of_lt (hy.2.trans_le (hâ‚€ _))\n  Â· refine .of_mem_nhdsGT_aux h ?_\n    simp only [IsTop] at H\n    push_neg at H\n    exact H\n\n"}
{"name":"measurableSet_of_mem_nhdsWithin_Ioi","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\ns : Set Î±\nh : âˆ€ (x : Î±), Membership.mem s x â†’ Membership.mem (nhdsWithin x (Set.Ioi x)) s\nâŠ¢ MeasurableSet s","decl":"@[deprecated (since := \"2024-12-22\")]\nalias measurableSet_of_mem_nhdsWithin_Ioi := MeasurableSet.of_mem_nhdsGT\n\n"}
{"name":"measurableSet_bddAbove_range","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), Measurable (f i)\nâŠ¢ MeasurableSet (setOf fun b => BddAbove (Set.range fun i => f i b))","decl":"lemma measurableSet_bddAbove_range {Î¹} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :\n    MeasurableSet {b | BddAbove (range (fun i â†¦ f i b))} := by\n  rcases isEmpty_or_nonempty Î± with hÎ±|hÎ±\n  Â· have : âˆ€ b, range (fun i â†¦ f i b) = âˆ… := fun b â†¦ eq_empty_of_isEmpty _\n    simp [this]\n  have A : âˆ€ (i : Î¹) (c : Î±), MeasurableSet {x | f i x â‰¤ c} := by\n    intro i c\n    exact measurableSet_le (hf i) measurable_const\n  have B : âˆ€ (c : Î±), MeasurableSet {x | âˆ€ i, f i x â‰¤ c} := by\n    intro c\n    rw [setOf_forall]\n    exact MeasurableSet.iInter (fun i â†¦ A i c)\n  obtain âŸ¨u, huâŸ© : âˆƒ (u : â„• â†’ Î±), Tendsto u atTop atTop := exists_seq_tendsto (atTop : Filter Î±)\n  have : {b | BddAbove (range (fun i â†¦ f i b))} = {x | âˆƒ n, âˆ€ i, f i x â‰¤ u n} := by\n    apply Subset.antisymm\n    Â· rintro x âŸ¨c, hcâŸ©\n      obtain âŸ¨n, hnâŸ© : âˆƒ n, c â‰¤ u n := (tendsto_atTop.1 hu c).exists\n      exact âŸ¨n, fun i â†¦ (hc ((mem_range_self i))).trans hnâŸ©\n    Â· rintro x âŸ¨n, hnâŸ©\n      refine âŸ¨u n, ?_âŸ©\n      rintro - âŸ¨i, rflâŸ©\n      exact hn i\n  rw [this, setOf_exists]\n  exact MeasurableSet.iUnion (fun n â†¦ B (u n))\n\n"}
{"name":"measurableSet_bddBelow_range","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : LinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), Measurable (f i)\nâŠ¢ MeasurableSet (setOf fun b => BddBelow (Set.range fun i => f i b))","decl":"lemma measurableSet_bddBelow_range {Î¹} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :\n    MeasurableSet {b | BddBelow (range (fun i â†¦ f i b))} :=\n  measurableSet_bddAbove_range (Î± := Î±áµ’áµˆ) hf\n\n"}
{"name":"Measurable.iSup_Prop","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î´ : Type u_4\nmÎ´ : MeasurableSpace Î´\nÎ± : Type u_5\nmÎ± : MeasurableSpace Î±\ninstâœ : ConditionallyCompleteLattice Î±\np : Prop\nf : Î´ â†’ Î±\nhf : Measurable f\nâŠ¢ Measurable fun b => iSup fun x => f b","decl":"@[measurability]\ntheorem Measurable.iSup_Prop {Î±} {mÎ± : MeasurableSpace Î±} [ConditionallyCompleteLattice Î±]\n    (p : Prop) {f : Î´ â†’ Î±} (hf : Measurable f) : Measurable fun b => â¨† _ : p, f b := by\n  classical\n  simp_rw [ciSup_eq_ite]\n  split_ifs with h\n  Â· exact hf\n  Â· exact measurable_const\n\n"}
{"name":"Measurable.iInf_Prop","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î´ : Type u_4\nmÎ´ : MeasurableSpace Î´\nÎ± : Type u_5\nmÎ± : MeasurableSpace Î±\ninstâœ : ConditionallyCompleteLattice Î±\np : Prop\nf : Î´ â†’ Î±\nhf : Measurable f\nâŠ¢ Measurable fun b => iInf fun x => f b","decl":"@[measurability]\ntheorem Measurable.iInf_Prop {Î±} {mÎ± : MeasurableSpace Î±} [ConditionallyCompleteLattice Î±]\n    (p : Prop) {f : Î´ â†’ Î±} (hf : Measurable f) : Measurable fun b => â¨… _ : p, f b := by\n  classical\n  simp_rw [ciInf_eq_ite]\n  split_ifs with h\n  Â· exact hf\n  Â· exact measurable_const\n\n"}
{"name":"Measurable.iSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), Measurable (f i)\nâŠ¢ Measurable fun b => iSup fun i => f i b","decl":"@[measurability, fun_prop]\nprotected theorem Measurable.iSup {Î¹} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :\n    Measurable (fun b â†¦ â¨† i, f i b) := by\n  rcases isEmpty_or_nonempty Î¹ with hÎ¹|hÎ¹\n  Â· simp [iSup_of_empty']\n  have A : MeasurableSet {b | BddAbove (range (fun i â†¦ f i b))} :=\n    measurableSet_bddAbove_range hf\n  have : Measurable (fun (_b : Î´) â†¦ sSup (âˆ… : Set Î±)) := measurable_const\n  apply Measurable.isLUB_of_mem hf A _ _ this\n  Â· rintro b âŸ¨c, hcâŸ©\n    apply isLUB_ciSup\n    refine âŸ¨c, ?_âŸ©\n    rintro d âŸ¨i, rflâŸ©\n    exact hc (mem_range_self i)\n  Â· intro b hb\n    apply csSup_of_not_bddAbove\n    exact hb\n\n"}
{"name":"measurable_iSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), Measurable (f i)\nâŠ¢ Measurable fun b => iSup fun i => f i b","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_iSup := Measurable.iSup\n\n-- TODO: Why does this error?\n-- /-- Compositional version of `Measurable.iSup` for use by `fun_prop`. -/\n-- @[fun_prop]\n-- protected lemma Measurable.iSup'' {_ : MeasurableSpace Î³} {Î¹ : Sort*} [Countable Î¹]\n--     {f : Î¹ â†’ Î³ â†’ Î´ â†’ Î±} {h : Î³ â†’ Î´} (hf : âˆ€ i, Measurable â†¿(f i)) (hh : Measurable h) :\n--     Measurable fun a â†¦ (â¨† i, f i a) (h a) := by\n--   simp_rw [iSup_apply]\n--   exact .iSup fun i â†¦ by fun_prop\n\n"}
{"name":"AEMeasurable.iSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\nÎ¼ : MeasureTheory.Measure Î´\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), AEMeasurable (f i) Î¼\nâŠ¢ AEMeasurable (fun b => iSup fun i => f i b) Î¼","decl":"@[measurability]\nprotected theorem AEMeasurable.iSup {Î¹} {Î¼ : Measure Î´} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±}\n    (hf : âˆ€ i, AEMeasurable (f i) Î¼) : AEMeasurable (fun b => â¨† i, f i b) Î¼ := by\n  refine âŸ¨fun b â†¦ â¨† i, (hf i).mk (f i) b, .iSup (fun i â†¦ (hf i).measurable_mk), ?_âŸ©\n  filter_upwards [ae_all_iff.2 (fun i â†¦ (hf i).ae_eq_mk)] with b hb using by simp [hb]\n\n"}
{"name":"aemeasurable_iSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\nÎ¼ : MeasureTheory.Measure Î´\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), AEMeasurable (f i) Î¼\nâŠ¢ AEMeasurable (fun b => iSup fun i => f i b) Î¼","decl":"@[deprecated (since := \"2024-10-21\")]\nalias aemeasurable_iSup := AEMeasurable.iSup\n\n"}
{"name":"Measurable.iInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), Measurable (f i)\nâŠ¢ Measurable fun b => iInf fun i => f i b","decl":"@[measurability, fun_prop]\nprotected theorem Measurable.iInf {Î¹} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :\n    Measurable fun b => â¨… i, f i b :=\n  .iSup (Î± := Î±áµ’áµˆ) hf\n\n"}
{"name":"measurable_iInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), Measurable (f i)\nâŠ¢ Measurable fun b => iInf fun i => f i b","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_iInf := Measurable.iInf\n\n"}
{"name":"AEMeasurable.iInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\nÎ¼ : MeasureTheory.Measure Î´\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), AEMeasurable (f i) Î¼\nâŠ¢ AEMeasurable (fun b => iInf fun i => f i b) Î¼","decl":"@[measurability]\nprotected theorem AEMeasurable.iInf {Î¹} {Î¼ : Measure Î´} [Countable Î¹] {f : Î¹ â†’ Î´ â†’ Î±}\n    (hf : âˆ€ i, AEMeasurable (f i) Î¼) : AEMeasurable (fun b => â¨… i, f i b) Î¼ :=\n  .iSup (Î± := Î±áµ’áµˆ) hf\n\n"}
{"name":"aemeasurable_iInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâµ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœâ´ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : SecondCountableTopology Î±\nÎ¹ : Sort u_5\nÎ¼ : MeasureTheory.Measure Î´\ninstâœ : Countable Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Î¹), AEMeasurable (f i) Î¼\nâŠ¢ AEMeasurable (fun b => iInf fun i => f i b) Î¼","decl":"@[deprecated (since := \"2024-10-21\")]\nalias aemeasurable_iInf := AEMeasurable.iInf\n\n"}
{"name":"Measurable.sSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\nf : Î¹ â†’ Î´ â†’ Î±\ns : Set Î¹\nhs : s.Countable\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ Measurable (f i)\nâŠ¢ Measurable fun x => SupSet.sSup (Set.image (fun i => f i x) s)","decl":"protected theorem Measurable.sSup {Î¹} {f : Î¹ â†’ Î´ â†’ Î±} {s : Set Î¹} (hs : s.Countable)\n    (hf : âˆ€ i âˆˆ s, Measurable (f i)) :\n    Measurable fun x => sSup ((fun i => f i x) '' s) := by\n  simp_rw [image_eq_range]\n  have : Countable s := hs.to_subtype\n  exact .iSup fun i â†¦ hf i i.2\n\n"}
{"name":"measurable_sSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\nf : Î¹ â†’ Î´ â†’ Î±\ns : Set Î¹\nhs : s.Countable\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ Measurable (f i)\nâŠ¢ Measurable fun x => SupSet.sSup (Set.image (fun i => f i x) s)","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_sSup := Measurable.sSup\n\n"}
{"name":"Measurable.sInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\nf : Î¹ â†’ Î´ â†’ Î±\ns : Set Î¹\nhs : s.Countable\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ Measurable (f i)\nâŠ¢ Measurable fun x => InfSet.sInf (Set.image (fun i => f i x) s)","decl":"protected theorem Measurable.sInf {Î¹} {f : Î¹ â†’ Î´ â†’ Î±} {s : Set Î¹} (hs : s.Countable)\n    (hf : âˆ€ i âˆˆ s, Measurable (f i)) :\n    Measurable fun x => sInf ((fun i => f i x) '' s) :=\n  .sSup (Î± := Î±áµ’áµˆ) hs hf\n\n"}
{"name":"measurable_sInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\nf : Î¹ â†’ Î´ â†’ Î±\ns : Set Î¹\nhs : s.Countable\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ Measurable (f i)\nâŠ¢ Measurable fun x => InfSet.sInf (Set.image (fun i => f i x) s)","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_sInf := Measurable.sInf\n\n"}
{"name":"Measurable.biSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\ns : Set Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhs : s.Countable\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ Measurable (f i)\nâŠ¢ Measurable fun b => iSup fun i => iSup fun h => f i b","decl":"theorem Measurable.biSup {Î¹} (s : Set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : s.Countable)\n    (hf : âˆ€ i âˆˆ s, Measurable (f i)) : Measurable fun b => â¨† i âˆˆ s, f i b := by\n  haveI : Encodable s := hs.toEncodable\n  by_cases H : âˆ€ i, i âˆˆ s\n  Â· have : âˆ€ b, â¨† i âˆˆ s, f i b = â¨† (i : s), f i b :=\n      fun b â†¦ cbiSup_eq_of_forall (f := fun i â†¦ f i b) H\n    simp only [this]\n    exact .iSup (fun (i : s) â†¦ hf i i.2)\n  Â· have : âˆ€ b, â¨† i âˆˆ s, f i b = (â¨† (i : s), f i b) âŠ” sSup âˆ… :=\n      fun b â†¦ cbiSup_eq_of_not_forall (f := fun i â†¦ f i b) H\n    simp only [this]\n    apply Measurable.sup _ measurable_const\n    exact .iSup (fun (i : s) â†¦ hf i i.2)\n\n"}
{"name":"measurable_biSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\ns : Set Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhs : s.Countable\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ Measurable (f i)\nâŠ¢ Measurable fun b => iSup fun i => iSup fun h => f i b","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_biSup := Measurable.biSup\n\n"}
{"name":"AEMeasurable.biSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\nÎ¼ : MeasureTheory.Measure Î´\ns : Set Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhs : s.Countable\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ AEMeasurable (f i) Î¼\nâŠ¢ AEMeasurable (fun b => iSup fun i => iSup fun h => f i b) Î¼","decl":"theorem AEMeasurable.biSup {Î¹} {Î¼ : Measure Î´} (s : Set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : s.Countable)\n    (hf : âˆ€ i âˆˆ s, AEMeasurable (f i) Î¼) : AEMeasurable (fun b => â¨† i âˆˆ s, f i b) Î¼ := by\n  classical\n  let g : Î¹ â†’ Î´ â†’ Î± := fun i â†¦ if hi : i âˆˆ s then (hf i hi).mk (f i) else fun _b â†¦ sSup âˆ…\n  have : âˆ€ i âˆˆ s, Measurable (g i) := by\n    intro i hi\n    simpa [g, hi] using (hf i hi).measurable_mk\n  refine âŸ¨fun b â†¦ â¨† (i) (_ : i âˆˆ s), g i b, .biSup s hs this, ?_âŸ©\n  have : âˆ€ i âˆˆ s, âˆ€áµ b âˆ‚Î¼, f i b = g i b :=\n    fun i hi â†¦ by simpa [g, hi] using (hf i hi).ae_eq_mk\n  filter_upwards [(ae_ball_iff hs).2 this] with b hb\n  exact iSup_congr fun i => iSup_congr (hb i)\n\n"}
{"name":"aemeasurable_biSup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\nÎ¼ : MeasureTheory.Measure Î´\ns : Set Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhs : s.Countable\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ AEMeasurable (f i) Î¼\nâŠ¢ AEMeasurable (fun b => iSup fun i => iSup fun h => f i b) Î¼","decl":"@[deprecated (since := \"2024-10-21\")]\nalias aemeasurable_biSup := AEMeasurable.biSup\n\n"}
{"name":"Measurable.biInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\ns : Set Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhs : s.Countable\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ Measurable (f i)\nâŠ¢ Measurable fun b => iInf fun i => iInf fun h => f i b","decl":"theorem Measurable.biInf {Î¹} (s : Set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : s.Countable)\n    (hf : âˆ€ i âˆˆ s, Measurable (f i)) : Measurable fun b => â¨… i âˆˆ s, f i b :=\n  .biSup (Î± := Î±áµ’áµˆ) s hs hf\n\n"}
{"name":"measurable_biInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\ns : Set Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhs : s.Countable\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ Measurable (f i)\nâŠ¢ Measurable fun b => iInf fun i => iInf fun h => f i b","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_biInf := Measurable.biInf\n\n"}
{"name":"AEMeasurable.biInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\nÎ¼ : MeasureTheory.Measure Î´\ns : Set Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhs : s.Countable\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ AEMeasurable (f i) Î¼\nâŠ¢ AEMeasurable (fun b => iInf fun i => iInf fun h => f i b) Î¼","decl":"theorem AEMeasurable.biInf {Î¹} {Î¼ : Measure Î´} (s : Set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : s.Countable)\n    (hf : âˆ€ i âˆˆ s, AEMeasurable (f i) Î¼) : AEMeasurable (fun b => â¨… i âˆˆ s, f i b) Î¼ :=\n  .biSup (Î± := Î±áµ’áµˆ) s hs hf\n\n"}
{"name":"aemeasurable_biInf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\nÎ¼ : MeasureTheory.Measure Î´\ns : Set Î¹\nf : Î¹ â†’ Î´ â†’ Î±\nhs : s.Countable\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ AEMeasurable (f i) Î¼\nâŠ¢ AEMeasurable (fun b => iInf fun i => iInf fun h => f i b) Î¼","decl":"@[deprecated (since := \"2024-10-21\")]\nalias aemeasurable_biInf := AEMeasurable.biInf\n\n"}
{"name":"Measurable.liminf'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\nÎ¹' : Type u_6\nf : Î¹ â†’ Î´ â†’ Î±\nv : Filter Î¹\nhf : âˆ€ (i : Î¹), Measurable (f i)\np : Î¹' â†’ Prop\ns : Î¹' â†’ Set Î¹\nhv : v.HasCountableBasis p s\nhs : âˆ€ (j : Î¹'), (s j).Countable\nâŠ¢ Measurable fun x => Filter.liminf (fun x_1 => f x_1 x) v","decl":"/-- `liminf` over a general filter is measurable. See `Measurable.liminf` for the version over `â„•`.\n-/\ntheorem Measurable.liminf' {Î¹ Î¹'} {f : Î¹ â†’ Î´ â†’ Î±} {v : Filter Î¹} (hf : âˆ€ i, Measurable (f i))\n    {p : Î¹' â†’ Prop} {s : Î¹' â†’ Set Î¹} (hv : v.HasCountableBasis p s) (hs : âˆ€ j, (s j).Countable) :\n    Measurable fun x => liminf (f Â· x) v := by\n  classical\n  /- We would like to write the liminf as `â¨† (j : Subtype p), â¨… (i : s j), f i x`, as the\n  measurability would follow from the measurability of infs and sups. Unfortunately, this is not\n  true in general conditionally complete linear orders because of issues with empty sets or sets\n  which are not bounded above or below. A slightly more complicated expression for the liminf,\n  valid in general, is given in `Filter.HasBasis.liminf_eq_ite`. This expression, built from\n  `if ... then ... else` and infs and sups, can be readily checked to be measurable. -/\n  have : Countable (Subtype p) := hv.countable\n  rcases isEmpty_or_nonempty (Subtype p) with hp|hp\n  Â· simp [hv.liminf_eq_sSup_iUnion_iInter]\n  by_cases H : âˆƒ (j : Subtype p), s j = âˆ…\n  Â· simp_rw [hv.liminf_eq_ite, if_pos H, measurable_const]\n  simp_rw [hv.liminf_eq_ite, if_neg H]\n  have : âˆ€ i, Countable (s i) := fun i â†¦ countable_coe_iff.2 (hs i)\n  let m : Subtype p â†’ Set Î´ := fun j â†¦ {x | BddBelow (range (fun (i : s j) â†¦ f i x))}\n  have m_meas : âˆ€ j, MeasurableSet (m j) :=\n    fun j â†¦ measurableSet_bddBelow_range (fun (i : s j) â†¦ hf i)\n  have mc_meas : MeasurableSet {x | âˆ€ (j : Subtype p), x âˆ‰ m j} := by\n    rw [setOf_forall]\n    exact MeasurableSet.iInter (fun j â†¦ (m_meas j).compl)\n  refine measurable_const.piecewise mc_meas <| .iSup fun j â†¦ ?_\n  let reparam : Î´ â†’ Subtype p â†’ Subtype p := fun x â†¦ liminf_reparam (fun i â†¦ f i x) s p\n  let F0 : Subtype p â†’ Î´ â†’ Î± := fun j x â†¦ â¨… (i : s j), f i x\n  have F0_meas : âˆ€ j, Measurable (F0 j) := fun j â†¦ .iInf (fun (i : s j) â†¦ hf i)\n  set F1 : Î´ â†’ Î± := fun x â†¦ F0 (reparam x j) x with hF1\n  change Measurable F1\n  let g : â„• â†’ Subtype p := Classical.choose (exists_surjective_nat (Subtype p))\n  have Z : âˆ€ x, âˆƒ n, x âˆˆ m (g n) âˆ¨ âˆ€ k, x âˆ‰ m k := by\n    intro x\n    by_cases H : âˆƒ k, x âˆˆ m k\n    Â· rcases H with âŸ¨k, hkâŸ©\n      rcases Classical.choose_spec (exists_surjective_nat (Subtype p)) k with âŸ¨n, rflâŸ©\n      exact âŸ¨n, Or.inl hkâŸ©\n    Â· push_neg at H\n      exact âŸ¨0, Or.inr HâŸ©\n  have : F1 = fun x â†¦ if x âˆˆ m j then F0 j x else F0 (g (Nat.find (Z x))) x := by\n    ext x\n    have A : reparam x j = if x âˆˆ m j then j else g (Nat.find (Z x)) := rfl\n    split_ifs with hjx\n    Â· have : reparam x j = j := by rw [A, if_pos hjx]\n      simp only [hF1, this]\n    Â· have : reparam x j = g (Nat.find (Z x)) := by rw [A, if_neg hjx]\n      simp only [hF1, this]\n  rw [this]\n  apply Measurable.piecewise (m_meas j) (F0_meas j)\n  apply Measurable.find (fun n â†¦ F0_meas (g n)) (fun n â†¦ ?_)\n  exact (m_meas (g n)).union mc_meas\n\n"}
{"name":"measurable_liminf'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\nÎ¹' : Type u_6\nf : Î¹ â†’ Î´ â†’ Î±\nv : Filter Î¹\nhf : âˆ€ (i : Î¹), Measurable (f i)\np : Î¹' â†’ Prop\ns : Î¹' â†’ Set Î¹\nhv : v.HasCountableBasis p s\nhs : âˆ€ (j : Î¹'), (s j).Countable\nâŠ¢ Measurable fun x => Filter.liminf (fun x_1 => f x_1 x) v","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_liminf' := Measurable.liminf'\n\n"}
{"name":"Measurable.limsup'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\nÎ¹' : Type u_6\nf : Î¹ â†’ Î´ â†’ Î±\nu : Filter Î¹\nhf : âˆ€ (i : Î¹), Measurable (f i)\np : Î¹' â†’ Prop\ns : Î¹' â†’ Set Î¹\nhu : u.HasCountableBasis p s\nhs : âˆ€ (i : Î¹'), (s i).Countable\nâŠ¢ Measurable fun x => Filter.limsup (fun i => f i x) u","decl":"/-- `limsup` over a general filter is measurable. See `Measurable.limsup` for the version over `â„•`.\n-/\ntheorem Measurable.limsup' {Î¹ Î¹'} {f : Î¹ â†’ Î´ â†’ Î±} {u : Filter Î¹} (hf : âˆ€ i, Measurable (f i))\n    {p : Î¹' â†’ Prop} {s : Î¹' â†’ Set Î¹} (hu : u.HasCountableBasis p s) (hs : âˆ€ i, (s i).Countable) :\n    Measurable fun x => limsup (fun i => f i x) u :=\n  .liminf' (Î± := Î±áµ’áµˆ) hf hu hs\n\n"}
{"name":"measurable_limsup'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nÎ¹ : Type u_5\nÎ¹' : Type u_6\nf : Î¹ â†’ Î´ â†’ Î±\nu : Filter Î¹\nhf : âˆ€ (i : Î¹), Measurable (f i)\np : Î¹' â†’ Prop\ns : Î¹' â†’ Set Î¹\nhu : u.HasCountableBasis p s\nhs : âˆ€ (i : Î¹'), (s i).Countable\nâŠ¢ Measurable fun x => Filter.limsup (fun i => f i x) u","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_limsup' := Measurable.limsup'\n\n"}
{"name":"Measurable.liminf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nf : Nat â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Nat), Measurable (f i)\nâŠ¢ Measurable fun x => Filter.liminf (fun i => f i x) Filter.atTop","decl":"/-- `liminf` over `â„•` is measurable. See `Measurable.liminf'` for a version with a general filter.\n-/\n@[measurability]\ntheorem Measurable.liminf {f : â„• â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :\n    Measurable fun x => liminf (fun i => f i x) atTop :=\n  .liminf' hf atTop_countable_basis fun _ => to_countable _\n\n"}
{"name":"measurable_liminf","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nf : Nat â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Nat), Measurable (f i)\nâŠ¢ Measurable fun x => Filter.liminf (fun i => f i x) Filter.atTop","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_liminf := Measurable.liminf\n\n"}
{"name":"Measurable.limsup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nf : Nat â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Nat), Measurable (f i)\nâŠ¢ Measurable fun x => Filter.limsup (fun i => f i x) Filter.atTop","decl":"/-- `limsup` over `â„•` is measurable. See `Measurable.limsup'` for a version with a general filter.\n-/\n@[measurability]\ntheorem Measurable.limsup {f : â„• â†’ Î´ â†’ Î±} (hf : âˆ€ i, Measurable (f i)) :\n    Measurable fun x => limsup (fun i => f i x) atTop :=\n  .limsup' hf atTop_countable_basis fun _ => to_countable _\n\n"}
{"name":"measurable_limsup","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ´ : Type u_4\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\nmÎ´ : MeasurableSpace Î´\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : SecondCountableTopology Î±\nf : Nat â†’ Î´ â†’ Î±\nhf : âˆ€ (i : Nat), Measurable (f i)\nâŠ¢ Measurable fun x => Filter.limsup (fun i => f i x) Filter.atTop","decl":"@[deprecated (since := \"2024-10-21\")]\nalias measurable_limsup := Measurable.limsup\n\n"}
{"name":"IsFiniteMeasureOnCompacts.map","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : TopologicalSpace Î±\nmÎ± : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\ninstâœÂ² : TopologicalSpace Î²\nmÎ² : MeasurableSpace Î²\ninstâœÂ¹ : BorelSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼\nf : Homeomorph Î± Î²\nâŠ¢ MeasureTheory.IsFiniteMeasureOnCompacts (MeasureTheory.Measure.map (â‡‘f) Î¼)","decl":"protected theorem IsFiniteMeasureOnCompacts.map (Î¼ : Measure Î±) [IsFiniteMeasureOnCompacts Î¼]\n    (f : Î± â‰ƒâ‚œ Î²) : IsFiniteMeasureOnCompacts (Measure.map f Î¼) := by\n  refine âŸ¨fun K hK â†¦ ?_âŸ©\n  rw [â† Homeomorph.toMeasurableEquiv_coe, MeasurableEquiv.map_apply]\n  exact IsCompact.measure_lt_top (f.isCompact_preimage.2 hK)\n\n"}
{"name":"measure_eq_measure_preimage_add_measure_tsum_Ico_zpow","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Order","initialProofState":"Î± : Type u_5\nmÎ± : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\ns : Set Î±\nhs : MeasurableSet s\nt : NNReal\nht : LT.lt 1 t\nâŠ¢ Eq (Î¼ s) (HAdd.hAdd (HAdd.hAdd (Î¼ (Inter.inter s (Set.preimage f (Singleton.singleton 0)))) (Î¼ (Inter.inter s (Set.preimage f (Singleton.singleton Top.top))))) (tsum fun n => Î¼ (Inter.inter s (Set.preimage f (Set.Ico (HPow.hPow (â†‘t) n) (HPow.hPow (â†‘t) (HAdd.hAdd n 1)))))))","decl":"/-- One can cut out `â„â‰¥0âˆ` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : â„¤` and `{âˆ}`. This\ngives a way to compute the measure of a set in terms of sets on which a given function `f` does not\nfluctuate by more than `t`. -/\ntheorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow {Î± : Type*} {mÎ± : MeasurableSpace Î±}\n    (Î¼ : Measure Î±) {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) {s : Set Î±} (hs : MeasurableSet s)\n    {t : â„â‰¥0} (ht : 1 < t) :\n    Î¼ s =\n      Î¼ (s âˆ© f â»Â¹' {0}) + Î¼ (s âˆ© f â»Â¹' {âˆ}) +\n      âˆ‘' n : â„¤, Î¼ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) := by\n  have A : Î¼ s = Î¼ (s âˆ© f â»Â¹' {0}) + Î¼ (s âˆ© f â»Â¹' Ioi 0) := by\n    rw [â† measure_union]\n    Â· rw [â† inter_union_distrib_left, â† preimage_union, singleton_union, Ioi_insert,\n        â† _root_.bot_eq_zero, Ici_bot, preimage_univ, inter_univ]\n    Â· exact disjoint_singleton_left.mpr not_mem_Ioi_self\n        |>.preimage f |>.inter_right' s |>.inter_left' s\n    Â· exact hs.inter (hf measurableSet_Ioi)\n  have B : Î¼ (s âˆ© f â»Â¹' Ioi 0) = Î¼ (s âˆ© f â»Â¹' {âˆ}) + Î¼ (s âˆ© f â»Â¹' Ioo 0 âˆ) := by\n    rw [â† measure_union]\n    Â· rw [â† inter_union_distrib_left]\n      congr\n      ext x\n      simp only [mem_singleton_iff, mem_union, mem_Ioo, mem_Ioi, mem_preimage]\n      obtain (H | H) : f x = âˆ âˆ¨ f x < âˆ := eq_or_lt_of_le le_top\n      Â· simp only [H, eq_self_iff_true, or_false, ENNReal.zero_lt_top, not_top_lt, and_false]\n      Â· simp only [H, H.ne, and_true, false_or]\n    Â· refine disjoint_left.2 fun x hx h'x => ?_\n      have : f x < âˆ := h'x.2.2\n      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm))\n    Â· exact hs.inter (hf measurableSet_Ioo)\n  have C : Î¼ (s âˆ© f â»Â¹' Ioo 0 âˆ) =\n      âˆ‘' n : â„¤, Î¼ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) := by\n    rw [â† measure_iUnion,\n      ENNReal.Ioo_zero_top_eq_iUnion_Ico_zpow (ENNReal.one_lt_coe_iff.2 ht) ENNReal.coe_ne_top,\n      preimage_iUnion, inter_iUnion]\n    Â· intro i j hij\n      wlog h : i < j generalizing i j\n      Â· exact (this hij.symm (hij.lt_or_lt.resolve_left h)).symm\n      refine disjoint_left.2 fun x hx h'x => lt_irrefl (f x) ?_\n      calc\n        f x < (t : â„â‰¥0âˆ) ^ (i + 1) := hx.2.2\n        _ â‰¤ (t : â„â‰¥0âˆ) ^ j := ENNReal.zpow_le_of_le (ENNReal.one_le_coe_iff.2 ht.le) h\n        _ â‰¤ f x := h'x.2.1\n    Â· intro n\n      exact hs.inter (hf measurableSet_Ico)\n  rw [A, B, C, add_assoc]\n\n"}
