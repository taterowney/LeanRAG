{"name":"Bool.true_eq_false_eq_False","module":"Mathlib.Data.Bool.Basic","initialProofState":"⊢ Not (Eq Bool.true Bool.false)","decl":"theorem true_eq_false_eq_False : ¬true = false := by decide\n\n"}
{"name":"Bool.false_eq_true_eq_False","module":"Mathlib.Data.Bool.Basic","initialProofState":"⊢ Not (Eq Bool.false Bool.true)","decl":"theorem false_eq_true_eq_False : ¬false = true := by decide\n\n"}
{"name":"Bool.eq_false_eq_not_eq_true","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\n⊢ Eq (Not (Eq b Bool.true)) (Eq b Bool.false)","decl":"theorem eq_false_eq_not_eq_true (b : Bool) : (¬b = true) = (b = false) := by simp\n\n"}
{"name":"Bool.eq_true_eq_not_eq_false","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\n⊢ Eq (Not (Eq b Bool.false)) (Eq b Bool.true)","decl":"theorem eq_true_eq_not_eq_false (b : Bool) : (¬b = false) = (b = true) := by simp\n\n"}
{"name":"Bool.eq_false_of_not_eq_true","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\na✝ : Not (Eq b Bool.true)\n⊢ Eq b Bool.false","decl":"theorem eq_false_of_not_eq_true {b : Bool} : ¬b = true → b = false :=\n  Eq.mp (eq_false_eq_not_eq_true b)\n\n"}
{"name":"Bool.eq_true_of_not_eq_false","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\na✝ : Not (Eq b Bool.false)\n⊢ Eq b Bool.true","decl":"theorem eq_true_of_not_eq_false {b : Bool} : ¬b = false → b = true :=\n  Eq.mp (eq_true_eq_not_eq_false b)\n\n"}
{"name":"Bool.and_eq_true_eq_eq_true_and_eq_true","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\n⊢ Eq (Eq (a.and b) Bool.true) (And (Eq a Bool.true) (Eq b Bool.true))","decl":"theorem and_eq_true_eq_eq_true_and_eq_true (a b : Bool) :\n    ((a && b) = true) = (a = true ∧ b = true) := by simp\n\n"}
{"name":"Bool.or_eq_true_eq_eq_true_or_eq_true","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\n⊢ Eq (Eq (a.or b) Bool.true) (Or (Eq a Bool.true) (Eq b Bool.true))","decl":"theorem or_eq_true_eq_eq_true_or_eq_true (a b : Bool) :\n    ((a || b) = true) = (a = true ∨ b = true) := by simp\n\n"}
{"name":"Bool.not_eq_true_eq_eq_false","module":"Mathlib.Data.Bool.Basic","initialProofState":"a : Bool\n⊢ Eq (Eq a.not Bool.true) (Eq a Bool.false)","decl":"theorem not_eq_true_eq_eq_false (a : Bool) : (not a = true) = (a = false) := by cases a <;> simp\n\n"}
{"name":"Bool.and_eq_false_eq_eq_false_or_eq_false","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\n⊢ Eq (Eq (a.and b) Bool.false) (Or (Eq a Bool.false) (Eq b Bool.false))","decl":"theorem and_eq_false_eq_eq_false_or_eq_false (a b : Bool) :\n    ((a && b) = false) = (a = false ∨ b = false) := by\n  cases a <;> cases b <;> simp\n\n"}
{"name":"Bool.or_eq_false_eq_eq_false_and_eq_false","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\n⊢ Eq (Eq (a.or b) Bool.false) (And (Eq a Bool.false) (Eq b Bool.false))","decl":"theorem or_eq_false_eq_eq_false_and_eq_false (a b : Bool) :\n    ((a || b) = false) = (a = false ∧ b = false) := by\n  cases a <;> cases b <;> simp\n\n"}
{"name":"Bool.not_eq_false_eq_eq_true","module":"Mathlib.Data.Bool.Basic","initialProofState":"a : Bool\n⊢ Eq (Eq a.not Bool.false) (Eq a Bool.true)","decl":"theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true) := by cases a <;> simp\n\n"}
{"name":"Bool.coe_false","module":"Mathlib.Data.Bool.Basic","initialProofState":"⊢ Eq (Eq Bool.false Bool.true) False","decl":"theorem coe_false : ↑false = False := by simp\n\n"}
{"name":"Bool.coe_true","module":"Mathlib.Data.Bool.Basic","initialProofState":"⊢ Eq (Eq Bool.true Bool.true) True","decl":"theorem coe_true : ↑true = True := by simp\n\n"}
{"name":"Bool.coe_sort_false","module":"Mathlib.Data.Bool.Basic","initialProofState":"⊢ Eq (Eq Bool.false Bool.true) False","decl":"theorem coe_sort_false : (false : Prop) = False := by simp\n\n"}
{"name":"Bool.coe_sort_true","module":"Mathlib.Data.Bool.Basic","initialProofState":"⊢ Eq (Eq Bool.true Bool.true) True","decl":"theorem coe_sort_true : (true : Prop) = True := by simp\n\n"}
{"name":"Bool.decide_iff","module":"Mathlib.Data.Bool.Basic","initialProofState":"p : Prop\nd : Decidable p\n⊢ Iff (Eq (Decidable.decide p) Bool.true) p","decl":"theorem decide_iff (p : Prop) [d : Decidable p] : decide p = true ↔ p := by simp\n\n"}
{"name":"Bool.decide_true","module":"Mathlib.Data.Bool.Basic","initialProofState":"p : Prop\ninst✝ : Decidable p\na✝ : p\n⊢ Eq (Decidable.decide p) Bool.true","decl":"theorem decide_true {p : Prop} [Decidable p] : p → decide p :=\n  (decide_iff p).2\n\n"}
{"name":"Bool.of_decide_true","module":"Mathlib.Data.Bool.Basic","initialProofState":"p : Prop\ninst✝ : Decidable p\na✝ : Eq (Decidable.decide p) Bool.true\n⊢ p","decl":"theorem of_decide_true {p : Prop} [Decidable p] : decide p → p :=\n  (decide_iff p).1\n\n"}
{"name":"Bool.bool_iff_false","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\n⊢ Iff (Not (Eq b Bool.true)) (Eq b Bool.false)","decl":"theorem bool_iff_false {b : Bool} : ¬b ↔ b = false := by cases b <;> decide\n\n"}
{"name":"Bool.bool_eq_false","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\na✝ : Not (Eq b Bool.true)\n⊢ Eq b Bool.false","decl":"theorem bool_eq_false {b : Bool} : ¬b → b = false :=\n  bool_iff_false.1\n\n"}
{"name":"Bool.decide_false_iff","module":"Mathlib.Data.Bool.Basic","initialProofState":"p : Prop\nx✝ : Decidable p\n⊢ Iff (Eq (Decidable.decide p) Bool.false) (Not p)","decl":"theorem decide_false_iff (p : Prop) {_ : Decidable p} : decide p = false ↔ ¬p :=\n  bool_iff_false.symm.trans (not_congr (decide_iff _))\n\n"}
{"name":"Bool.decide_false","module":"Mathlib.Data.Bool.Basic","initialProofState":"p : Prop\ninst✝ : Decidable p\na✝ : Not p\n⊢ Eq (Decidable.decide p) Bool.false","decl":"theorem decide_false {p : Prop} [Decidable p] : ¬p → decide p = false :=\n  (decide_false_iff p).2\n\n"}
{"name":"Bool.of_decide_false","module":"Mathlib.Data.Bool.Basic","initialProofState":"p : Prop\ninst✝ : Decidable p\na✝ : Eq (Decidable.decide p) Bool.false\n⊢ Not p","decl":"theorem of_decide_false {p : Prop} [Decidable p] : decide p = false → ¬p :=\n  (decide_false_iff p).1\n\n"}
{"name":"Bool.decide_congr","module":"Mathlib.Data.Bool.Basic","initialProofState":"p q : Prop\ninst✝¹ : Decidable p\ninst✝ : Decidable q\nh : Iff p q\n⊢ Eq (Decidable.decide p) (Decidable.decide q)","decl":"theorem decide_congr {p q : Prop} [Decidable p] [Decidable q] (h : p ↔ q) : decide p = decide q :=\n  decide_eq_decide.mpr h\n\n"}
{"name":"Bool.coe_xor_iff","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\n⊢ Iff (Eq (a.xor b) Bool.true) (Xor' (Eq a Bool.true) (Eq b Bool.true))","decl":"theorem coe_xor_iff (a b : Bool) : xor a b ↔ Xor' (a = true) (b = true) := by\n  cases a <;> cases b <;> decide\n\n"}
{"name":"Bool.dichotomy","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\n⊢ Or (Eq b Bool.false) (Eq b Bool.true)","decl":"theorem dichotomy (b : Bool) : b = false ∨ b = true := by cases b <;> simp\n\n"}
{"name":"Bool.not_ne_id","module":"Mathlib.Data.Bool.Basic","initialProofState":"⊢ Ne Bool.not id","decl":"theorem not_ne_id : not ≠ id := fun h ↦ false_ne_true <| congrFun h true\n\n"}
{"name":"Bool.or_inl","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\nH : Eq a Bool.true\n⊢ Eq (a.or b) Bool.true","decl":"theorem or_inl {a b : Bool} (H : a) : a || b := by simp [H]\n\n"}
{"name":"Bool.or_inr","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\nH : Eq b Bool.true\n⊢ Eq (a.or b) Bool.true","decl":"theorem or_inr {a b : Bool} (H : b) : a || b := by cases a <;> simp [H]\n\n"}
{"name":"Bool.and_elim_left","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\na✝ : Eq (a.and b) Bool.true\n⊢ Eq a Bool.true","decl":"theorem and_elim_left : ∀ {a b : Bool}, a && b → a := by decide\n\n"}
{"name":"Bool.and_intro","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\na✝¹ : Eq a Bool.true\na✝ : Eq b Bool.true\n⊢ Eq (a.and b) Bool.true","decl":"theorem and_intro : ∀ {a b : Bool}, a → b → a && b := by decide\n\n"}
{"name":"Bool.and_elim_right","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\na✝ : Eq (a.and b) Bool.true\n⊢ Eq b Bool.true","decl":"theorem and_elim_right : ∀ {a b : Bool}, a && b → b := by decide\n\n"}
{"name":"Bool.eq_not_iff","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\n⊢ Iff (Eq a b.not) (Ne a b)","decl":"lemma eq_not_iff : ∀ {a b : Bool}, a = !b ↔ a ≠ b := by decide\n\n"}
{"name":"Bool.not_eq_iff","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\n⊢ Iff (Eq (Decidable.decide (Eq a b)).not Bool.true) (Ne a b)","decl":"lemma not_eq_iff : ∀ {a b : Bool}, !a = b ↔ a ≠ b := by decide\n\n"}
{"name":"Bool.ne_not","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\n⊢ Iff (Ne a b.not) (Eq a b)","decl":"theorem ne_not {a b : Bool} : a ≠ !b ↔ a = b :=\n  not_eq_not\n\n"}
{"name":"Bool.not_ne_self","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\n⊢ Ne b.not b","decl":"lemma not_ne_self : ∀ b : Bool, (!b) ≠ b := by decide\n\n"}
{"name":"Bool.self_ne_not","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\n⊢ Ne b b.not","decl":"lemma self_ne_not : ∀ b : Bool, b ≠ !b := by decide\n\n"}
{"name":"Bool.eq_or_eq_not","module":"Mathlib.Data.Bool.Basic","initialProofState":"a b : Bool\n⊢ Or (Eq a b) (Eq a b.not)","decl":"lemma eq_or_eq_not : ∀ a b, a = b ∨ a = !b := by decide\n\n-- Porting note: naming issue again: these two `not` are different.\n"}
{"name":"Bool.not_iff_not","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\n⊢ Iff (Eq b.not Bool.true) (Not (Eq b Bool.true))","decl":"theorem not_iff_not : ∀ {b : Bool}, !b ↔ ¬b := by simp\n\n"}
{"name":"Bool.eq_true_of_not_eq_false'","module":"Mathlib.Data.Bool.Basic","initialProofState":"a : Bool\na✝ : Eq (Decidable.decide (Eq a Bool.false)).not Bool.true\n⊢ Eq a Bool.true","decl":"theorem eq_true_of_not_eq_false' {a : Bool} : !a = false → a = true := by\n  cases a <;> decide\n\n"}
{"name":"Bool.eq_false_of_not_eq_true'","module":"Mathlib.Data.Bool.Basic","initialProofState":"a : Bool\na✝ : Eq (Decidable.decide (Eq a Bool.true)).not Bool.true\n⊢ Eq a Bool.false","decl":"theorem eq_false_of_not_eq_true' {a : Bool} : !a = true → a = false := by\n  cases a <;> decide\n\n"}
{"name":"Bool.bne_eq_xor","module":"Mathlib.Data.Bool.Basic","initialProofState":"⊢ Eq bne Bool.xor","decl":"theorem bne_eq_xor : bne = xor := by funext a b; revert a b; decide\n\n"}
{"name":"Bool.xor_iff_ne","module":"Mathlib.Data.Bool.Basic","initialProofState":"x y : Bool\n⊢ Iff (Eq (x.xor y) Bool.true) (Ne x y)","decl":"theorem xor_iff_ne : ∀ {x y : Bool}, xor x y = true ↔ x ≠ y := by decide\n\n"}
{"name":"Bool.lt_iff","module":"Mathlib.Data.Bool.Basic","initialProofState":"x y : Bool\n⊢ Iff (LT.lt x y) (And (Eq x Bool.false) (Eq y Bool.true))","decl":"theorem lt_iff : ∀ {x y : Bool}, x < y ↔ x = false ∧ y = true := by decide\n\n"}
{"name":"Bool.false_lt_true","module":"Mathlib.Data.Bool.Basic","initialProofState":"⊢ LT.lt Bool.false Bool.true","decl":"@[simp]\ntheorem false_lt_true : false < true :=\n  lt_iff.2 ⟨rfl, rfl⟩\n\n"}
{"name":"Bool.le_iff_imp","module":"Mathlib.Data.Bool.Basic","initialProofState":"x y : Bool\n⊢ Iff (LE.le x y) (Eq x Bool.true → Eq y Bool.true)","decl":"theorem le_iff_imp : ∀ {x y : Bool}, x ≤ y ↔ x → y := by decide\n\n"}
{"name":"Bool.and_le_left","module":"Mathlib.Data.Bool.Basic","initialProofState":"x y : Bool\n⊢ LE.le (x.and y) x","decl":"theorem and_le_left : ∀ x y : Bool, (x && y) ≤ x := by decide\n\n"}
{"name":"Bool.and_le_right","module":"Mathlib.Data.Bool.Basic","initialProofState":"x y : Bool\n⊢ LE.le (x.and y) y","decl":"theorem and_le_right : ∀ x y : Bool, (x && y) ≤ y := by decide\n\n"}
{"name":"Bool.le_and","module":"Mathlib.Data.Bool.Basic","initialProofState":"x y z : Bool\na✝¹ : LE.le x y\na✝ : LE.le x z\n⊢ LE.le x (y.and z)","decl":"theorem le_and : ∀ {x y z : Bool}, x ≤ y → x ≤ z → x ≤ (y && z) := by decide\n\n"}
{"name":"Bool.left_le_or","module":"Mathlib.Data.Bool.Basic","initialProofState":"x y : Bool\n⊢ LE.le x (x.or y)","decl":"theorem left_le_or : ∀ x y : Bool, x ≤ (x || y) := by decide\n\n"}
{"name":"Bool.right_le_or","module":"Mathlib.Data.Bool.Basic","initialProofState":"x y : Bool\n⊢ LE.le y (x.or y)","decl":"theorem right_le_or : ∀ x y : Bool, y ≤ (x || y) := by decide\n\n"}
{"name":"Bool.or_le","module":"Mathlib.Data.Bool.Basic","initialProofState":"x y z : Bool\na✝¹ : LE.le x z\na✝ : LE.le y z\n⊢ LE.le (x.or y) z","decl":"theorem or_le : ∀ {x y z}, x ≤ z → y ≤ z → (x || y) ≤ z := by decide\n\n"}
{"name":"Bool.toNat_beq_zero","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\n⊢ Eq (BEq.beq b.toNat 0) b.not","decl":"@[simp] lemma toNat_beq_zero (b : Bool) : (b.toNat == 0) = !b := by cases b <;> rfl\n"}
{"name":"Bool.toNat_bne_zero","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\n⊢ Eq (bne b.toNat 0) b","decl":"@[simp] lemma toNat_bne_zero (b : Bool) : (b.toNat != 0) =  b := by simp [bne]\n"}
{"name":"Bool.toNat_beq_one","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\n⊢ Eq (BEq.beq b.toNat 1) b","decl":"@[simp] lemma toNat_beq_one (b : Bool) : (b.toNat == 1) =  b := by cases b <;> rfl\n"}
{"name":"Bool.toNat_bne_one","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\n⊢ Eq (bne b.toNat 1) b.not","decl":"@[simp] lemma toNat_bne_one (b : Bool) : (b.toNat != 1) = !b := by simp [bne]\n\n"}
{"name":"Bool.ofNat_le_ofNat","module":"Mathlib.Data.Bool.Basic","initialProofState":"n m : Nat\nh : LE.le n m\n⊢ LE.le (Bool.ofNat n) (Bool.ofNat m)","decl":"theorem ofNat_le_ofNat {n m : Nat} (h : n ≤ m) : ofNat n ≤ ofNat m := by\n  simp only [ofNat, ne_eq, _root_.decide_not]\n  cases Nat.decEq n 0 with\n  | isTrue hn => rw [_root_.decide_eq_true hn]; exact Bool.false_le _\n  | isFalse hn =>\n    cases Nat.decEq m 0 with\n    | isFalse hm => rw [_root_.decide_eq_false hm]; exact Bool.le_true _\n    | isTrue hm => subst hm; have h := Nat.le_antisymm h (Nat.zero_le n); contradiction\n\n"}
{"name":"Bool.toNat_le_toNat","module":"Mathlib.Data.Bool.Basic","initialProofState":"b₀ b₁ : Bool\nh : LE.le b₀ b₁\n⊢ LE.le b₀.toNat b₁.toNat","decl":"theorem toNat_le_toNat {b₀ b₁ : Bool} (h : b₀ ≤ b₁) : toNat b₀ ≤ toNat b₁ := by\n  cases b₀ <;> cases b₁ <;> simp_all +decide\n\n"}
{"name":"Bool.ofNat_toNat","module":"Mathlib.Data.Bool.Basic","initialProofState":"b : Bool\n⊢ Eq (Bool.ofNat b.toNat) b","decl":"theorem ofNat_toNat (b : Bool) : ofNat (toNat b) = b := by\n  cases b <;> rfl\n\n"}
{"name":"Bool.injective_iff","module":"Mathlib.Data.Bool.Basic","initialProofState":"α : Sort u_1\nf : Bool → α\n⊢ Iff (Function.Injective f) (Ne (f Bool.false) (f Bool.true))","decl":"@[simp]\ntheorem injective_iff {α : Sort*} {f : Bool → α} : Function.Injective f ↔ f false ≠ f true :=\n  ⟨fun Hinj Heq ↦ false_ne_true (Hinj Heq), fun H x y hxy ↦ by\n    cases x <;> cases y\n    · rfl\n    · exact (H hxy).elim\n    · exact (H hxy.symm).elim\n    · rfl⟩\n\n"}
{"name":"Bool.apply_apply_apply","module":"Mathlib.Data.Bool.Basic","initialProofState":"f : Bool → Bool\nx : Bool\n⊢ Eq (f (f (f x))) (f x)","decl":"/-- **Kaminski's Equation** -/\ntheorem apply_apply_apply (f : Bool → Bool) (x : Bool) : f (f (f x)) = f x := by\n  cases x <;> cases h₁ : f true <;> cases h₂ : f false <;> simp only [h₁, h₂]\n\n"}
