{"name":"CategoryTheory.Functor.IsHomological.toPreservesZeroMorphisms","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.HasShift C Int\ninst✝⁵ : CategoryTheory.Category.{u_5, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\ninst✝ : CategoryTheory.Abelian A\nself : F.IsHomological\n⊢ F.PreservesZeroMorphisms","decl":"/-- A functor from a pretriangulated category to an abelian category is an homological functor\nif it sends distinguished triangles to exact sequences. -/\nclass IsHomological extends F.PreservesZeroMorphisms : Prop where\n  exact (T : Triangle C) (hT : T ∈ distTriang C) :\n    ((shortComplexOfDistTriangle T hT).map F).Exact\n\n"}
{"name":"CategoryTheory.Functor.IsHomological.exact","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁶ : CategoryTheory.HasShift C Int\ninst✝⁵ : CategoryTheory.Category.{u_5, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\ninst✝ : CategoryTheory.Abelian A\nself : F.IsHomological\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ ((CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).map F).Exact","decl":"/-- A functor from a pretriangulated category to an abelian category is an homological functor\nif it sends distinguished triangles to exact sequences. -/\nclass IsHomological extends F.PreservesZeroMorphisms : Prop where\n  exact (T : Triangle C) (hT : T ∈ distTriang C) :\n    ((shortComplexOfDistTriangle T hT).map F).Exact\n\n"}
{"name":"CategoryTheory.Functor.map_distinguished_exact","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁷ : CategoryTheory.HasShift C Int\ninst✝⁶ : CategoryTheory.Category.{u_5, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.Abelian A\ninst✝ : F.IsHomological\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n⊢ ((CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).map F).Exact","decl":"lemma map_distinguished_exact [F.IsHomological] (T : Triangle C) (hT : T ∈ distTriang C) :\n    ((shortComplexOfDistTriangle T hT).map F).Exact :=\n  IsHomological.exact _ hT\n\n"}
{"name":"CategoryTheory.Functor.instIsHomologicalCompOfIsTriangulated","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nD : Type u_2\nA : Type u_3\ninst✝¹⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹⁵ : CategoryTheory.HasShift C Int\ninst✝¹⁴ : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹³ : CategoryTheory.Limits.HasZeroObject D\ninst✝¹² : CategoryTheory.HasShift D Int\ninst✝¹¹ : CategoryTheory.Preadditive D\ninst✝¹⁰ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁹ : CategoryTheory.Pretriangulated D\ninst✝⁸ : CategoryTheory.Category.{u_6, u_3} A\ninst✝⁷ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁶ : CategoryTheory.Preadditive C\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁴ : CategoryTheory.Pretriangulated C\ninst✝³ : CategoryTheory.Abelian A\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D A\ninst✝² : L.CommShift Int\ninst✝¹ : L.IsTriangulated\ninst✝ : F.IsHomological\n⊢ (L.comp F).IsHomological","decl":"instance (L : C ⥤ D) (F : D ⥤ A) [L.CommShift ℤ] [L.IsTriangulated] [F.IsHomological] :\n    (L ⋙ F).IsHomological where\n  exact T hT := F.map_distinguished_exact _ (L.map_distinguished T hT)\n\n"}
{"name":"CategoryTheory.Functor.IsHomological.mk'","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁷ : CategoryTheory.HasShift C Int\ninst✝⁶ : CategoryTheory.Category.{u_5, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.Abelian A\ninst✝ : F.PreservesZeroMorphisms\nhF : ∀ (T : CategoryTheory.Pretriangulated.Triangle C) (hT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T), Exists fun T' => Exists fun e => ((CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T' ⋯).map F).Exact\n⊢ F.IsHomological","decl":"lemma IsHomological.mk' [F.PreservesZeroMorphisms]\n    (hF : ∀ (T : Pretriangulated.Triangle C) (hT : T ∈ distTriang C),\n      ∃ (T' : Pretriangulated.Triangle C) (e : T ≅ T'),\n      ((shortComplexOfDistTriangle T' (isomorphic_distinguished _ hT _ e.symm)).map F).Exact) :\n    F.IsHomological where\n  exact T hT := by\n    obtain ⟨T', e, h'⟩ := hF T hT\n    exact (ShortComplex.exact_iff_of_iso\n      (F.mapShortComplex.mapIso ((shortComplexOfDistTriangleIsoOfIso e hT)))).2 h'\n\n"}
{"name":"CategoryTheory.Functor.IsHomological.of_iso","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁷ : CategoryTheory.HasShift C Int\ninst✝⁶ : CategoryTheory.Category.{u_5, u_3} A\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.Abelian A\nF₁ F₂ : CategoryTheory.Functor C A\ninst✝ : F₁.IsHomological\ne : CategoryTheory.Iso F₁ F₂\n⊢ F₂.IsHomological","decl":"lemma IsHomological.of_iso {F₁ F₂ : C ⥤ A} [F₁.IsHomological] (e : F₁ ≅ F₂) :\n    F₂.IsHomological :=\n  have := preservesZeroMorphisms_of_iso e\n  ⟨fun T hT => ShortComplex.exact_of_iso (ShortComplex.mapNatIso _ e)\n    (F₁.map_distinguished_exact T hT)⟩\n\n"}
{"name":"CategoryTheory.Functor.instClosedUnderIsomorphismsPHomologicalKernel","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁷ : CategoryTheory.HasShift C Int\ninst✝⁶ : CategoryTheory.Category.{u_5, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.Abelian A\ninst✝ : F.IsHomological\n⊢ CategoryTheory.ClosedUnderIsomorphisms F.homologicalKernel.P","decl":"instance [F.IsHomological] : ClosedUnderIsomorphisms F.homologicalKernel.P := by\n  dsimp only [homologicalKernel]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Functor.mem_homologicalKernel_iff","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_5, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nX : C\n⊢ Iff (F.homologicalKernel.P X) (∀ (n : Int), CategoryTheory.Limits.IsZero ((F.shift n).obj X))","decl":"lemma mem_homologicalKernel_iff [F.IsHomological] [F.ShiftSequence ℤ] (X : C) :\n    F.homologicalKernel.P X ↔ ∀ (n : ℤ), IsZero ((F.shift n).obj X) := by\n  simp only [← fun (n : ℤ) => Iso.isZero_iff ((F.isoShift n).app X)]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.instPreservesLimitsOfShapeDiscreteWalkingPairOfIsHomological","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁷ : CategoryTheory.HasShift C Int\ninst✝⁶ : CategoryTheory.Category.{u_5, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.Abelian A\ninst✝ : F.IsHomological\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F","decl":"noncomputable instance (priority := 100) [F.IsHomological] :\n    PreservesLimitsOfShape (Discrete WalkingPair) F := by\n  suffices ∀ (X₁ X₂ : C), PreservesLimit (pair X₁ X₂) F from\n    ⟨fun {X} => preservesLimit_of_iso_diagram F (diagramIsoPair X).symm⟩\n  intro X₁ X₂\n  have : HasBinaryBiproduct (F.obj X₁) (F.obj X₂) := HasBinaryBiproducts.has_binary_biproduct _ _\n  have : Mono (F.biprodComparison X₁ X₂) := by\n    rw [mono_iff_cancel_zero]\n    intro Z f hf\n    let S := (ShortComplex.mk _ _ (biprod.inl_snd (X := X₁) (Y := X₂))).map F\n    have : Mono S.f := by dsimp [S]; infer_instance\n    have ex : S.Exact := F.map_distinguished_exact _ (binaryBiproductTriangle_distinguished X₁ X₂)\n    obtain ⟨g, rfl⟩ := ex.lift' f (by simpa using hf =≫ biprod.snd)\n    dsimp [S] at hf ⊢\n    replace hf := hf =≫ biprod.fst\n    simp only [assoc, biprodComparison_fst, zero_comp, ← F.map_comp, biprod.inl_fst,\n      F.map_id, comp_id] at hf\n    rw [hf, zero_comp]\n  have : PreservesBinaryBiproduct X₁ X₂ F := preservesBinaryBiproduct_of_mono_biprodComparison _\n  apply Limits.preservesBinaryProduct_of_preservesBinaryBiproduct\n\n"}
{"name":"CategoryTheory.Functor.instAdditiveOfIsHomological","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁷ : CategoryTheory.HasShift C Int\ninst✝⁶ : CategoryTheory.Category.{u_5, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.Abelian A\ninst✝ : F.IsHomological\n⊢ F.Additive","decl":"instance (priority := 100) [F.IsHomological] : F.Additive :=\n  F.additive_of_preserves_binary_products\n\n"}
{"name":"CategoryTheory.Functor.isHomological_of_localization","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nD : Type u_2\nA : Type u_3\ninst✝¹⁷ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹⁶ : CategoryTheory.HasShift C Int\ninst✝¹⁵ : CategoryTheory.Category.{u_5, u_2} D\ninst✝¹⁴ : CategoryTheory.Limits.HasZeroObject D\ninst✝¹³ : CategoryTheory.HasShift D Int\ninst✝¹² : CategoryTheory.Preadditive D\ninst✝¹¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝¹⁰ : CategoryTheory.Pretriangulated D\ninst✝⁹ : CategoryTheory.Category.{u_6, u_3} A\ninst✝⁸ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁵ : CategoryTheory.Pretriangulated C\ninst✝⁴ : CategoryTheory.Abelian A\nL : CategoryTheory.Functor C D\ninst✝³ : L.CommShift Int\ninst✝² : L.IsTriangulated\ninst✝¹ : L.mapArrow.EssSurj\nF : CategoryTheory.Functor D A\nG : CategoryTheory.Functor C A\ne : CategoryTheory.Iso (L.comp F) G\ninst✝ : G.IsHomological\n⊢ F.IsHomological","decl":"lemma isHomological_of_localization (L : C ⥤ D)\n    [L.CommShift ℤ] [L.IsTriangulated] [L.mapArrow.EssSurj] (F : D ⥤ A)\n    (G : C ⥤ A) (e : L ⋙ F ≅ G) [G.IsHomological] :\n    F.IsHomological := by\n  have : F.PreservesZeroMorphisms := preservesZeroMorphisms_of_map_zero_object\n    (F.mapIso L.mapZeroObject.symm ≪≫ e.app _ ≪≫ G.mapZeroObject)\n  have : (L ⋙ F).IsHomological := IsHomological.of_iso e.symm\n  refine IsHomological.mk' _ (fun T hT => ?_)\n  rw [L.distTriang_iff] at hT\n  obtain ⟨T₀, e, hT₀⟩ := hT\n  exact ⟨L.mapTriangle.obj T₀, e, (L ⋙ F).map_distinguished_exact _ hT₀⟩\n\n"}
{"name":"CategoryTheory.Functor.homologySequenceδ_naturality_assoc","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Category.{u_5, u_3} A\nF : CategoryTheory.Functor C A\ninst✝ : F.ShiftSequence Int\nT T' : CategoryTheory.Pretriangulated.Triangle C\nφ : Quiver.Hom T T'\nn₀ n₁ : Int\nh✝ : Eq (HAdd.hAdd n₀ 1) n₁\nZ : A\nh : Quiver.Hom ((F.shift n₁).obj T'.obj₁) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shift n₀).map φ.hom₃) (CategoryTheory.CategoryStruct.comp (F.homologySequenceδ T' n₀ n₁ h✝) h)) (CategoryTheory.CategoryStruct.comp (F.homologySequenceδ T n₀ n₁ h✝) (CategoryTheory.CategoryStruct.comp ((F.shift n₁).map φ.hom₁) h))","decl":"@[reassoc]\nlemma homologySequenceδ_naturality\n    [F.ShiftSequence ℤ] (T T' : Triangle C) (φ : T ⟶ T') (n₀ n₁ : ℤ) (h : n₀ + 1 = n₁) :\n    (F.shift n₀).map φ.hom₃ ≫ F.homologySequenceδ T' n₀ n₁ h =\n      F.homologySequenceδ T n₀ n₁ h ≫ (F.shift n₁).map φ.hom₁ := by\n  dsimp only [homologySequenceδ]\n  rw [← shiftMap_comp', ← φ.comm₃, shiftMap_comp]\n\n"}
{"name":"CategoryTheory.Functor.homologySequenceδ_naturality","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.Category.{u_5, u_3} A\nF : CategoryTheory.Functor C A\ninst✝ : F.ShiftSequence Int\nT T' : CategoryTheory.Pretriangulated.Triangle C\nφ : Quiver.Hom T T'\nn₀ n₁ : Int\nh : Eq (HAdd.hAdd n₀ 1) n₁\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shift n₀).map φ.hom₃) (F.homologySequenceδ T' n₀ n₁ h)) (CategoryTheory.CategoryStruct.comp (F.homologySequenceδ T n₀ n₁ h) ((F.shift n₁).map φ.hom₁))","decl":"@[reassoc]\nlemma homologySequenceδ_naturality\n    [F.ShiftSequence ℤ] (T T' : Triangle C) (φ : T ⟶ T') (n₀ n₁ : ℤ) (h : n₀ + 1 = n₁) :\n    (F.shift n₀).map φ.hom₃ ≫ F.homologySequenceδ T' n₀ n₁ h =\n      F.homologySequenceδ T n₀ n₁ h ≫ (F.shift n₁).map φ.hom₁ := by\n  dsimp only [homologySequenceδ]\n  rw [← shiftMap_comp', ← φ.comm₃, shiftMap_comp]\n\n"}
{"name":"CategoryTheory.Functor.comp_homologySequenceδ_assoc","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ n₁ : Int\nh✝ : Eq (HAdd.hAdd n₀ 1) n₁\nZ : A\nh : Quiver.Hom ((F.shift n₁).obj T.obj₁) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shift n₀).map T.mor₂) (CategoryTheory.CategoryStruct.comp (F.homologySequenceδ T n₀ n₁ h✝) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma comp_homologySequenceδ :\n    (F.shift n₀).map T.mor₂ ≫ F.homologySequenceδ T n₀ n₁ h = 0 := by\n  dsimp only [homologySequenceδ]\n  rw [← F.shiftMap_comp', comp_distTriang_mor_zero₂₃ _ hT, shiftMap_zero]\n\n"}
{"name":"CategoryTheory.Functor.comp_homologySequenceδ","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ n₁ : Int\nh : Eq (HAdd.hAdd n₀ 1) n₁\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shift n₀).map T.mor₂) (F.homologySequenceδ T n₀ n₁ h)) 0","decl":"@[reassoc]\nlemma comp_homologySequenceδ :\n    (F.shift n₀).map T.mor₂ ≫ F.homologySequenceδ T n₀ n₁ h = 0 := by\n  dsimp only [homologySequenceδ]\n  rw [← F.shiftMap_comp', comp_distTriang_mor_zero₂₃ _ hT, shiftMap_zero]\n\n"}
{"name":"CategoryTheory.Functor.homologySequenceδ_comp","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ n₁ : Int\nh : Eq (HAdd.hAdd n₀ 1) n₁\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.homologySequenceδ T n₀ n₁ h) ((F.shift n₁).map T.mor₁)) 0","decl":"@[reassoc]\nlemma homologySequenceδ_comp :\n    F.homologySequenceδ T n₀ n₁ h ≫ (F.shift n₁).map T.mor₁ = 0 := by\n  dsimp only [homologySequenceδ]\n  rw [← F.shiftMap_comp, comp_distTriang_mor_zero₃₁ _ hT, shiftMap_zero]\n\n"}
{"name":"CategoryTheory.Functor.homologySequenceδ_comp_assoc","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ n₁ : Int\nh✝ : Eq (HAdd.hAdd n₀ 1) n₁\nZ : A\nh : Quiver.Hom ((F.shift n₁).obj T.obj₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.homologySequenceδ T n₀ n₁ h✝) (CategoryTheory.CategoryStruct.comp ((F.shift n₁).map T.mor₁) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma homologySequenceδ_comp :\n    F.homologySequenceδ T n₀ n₁ h ≫ (F.shift n₁).map T.mor₁ = 0 := by\n  dsimp only [homologySequenceδ]\n  rw [← F.shiftMap_comp, comp_distTriang_mor_zero₃₁ _ hT, shiftMap_zero]\n\n"}
{"name":"CategoryTheory.Functor.homologySequence_comp","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ : Int\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shift n₀).map T.mor₁) ((F.shift n₀).map T.mor₂)) 0","decl":"@[reassoc]\nlemma homologySequence_comp  :\n    (F.shift n₀).map T.mor₁ ≫ (F.shift n₀).map T.mor₂ = 0 := by\n  rw [← Functor.map_comp, comp_distTriang_mor_zero₁₂ _ hT, Functor.map_zero]\n\n"}
{"name":"CategoryTheory.Functor.homologySequence_comp_assoc","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ : Int\nZ : A\nh : Quiver.Hom ((F.shift n₀).obj T.obj₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.shift n₀).map T.mor₁) (CategoryTheory.CategoryStruct.comp ((F.shift n₀).map T.mor₂) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma homologySequence_comp  :\n    (F.shift n₀).map T.mor₁ ≫ (F.shift n₀).map T.mor₂ = 0 := by\n  rw [← Functor.map_comp, comp_distTriang_mor_zero₁₂ _ hT, Functor.map_zero]\n\n"}
{"name":"CategoryTheory.Functor.homologySequence_exact₂","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ : Int\n⊢ (CategoryTheory.ShortComplex.mk ((F.shift n₀).map T.mor₁) ((F.shift n₀).map T.mor₂) ⋯).Exact","decl":"lemma homologySequence_exact₂ :\n    (ShortComplex.mk _ _ (F.homologySequence_comp T hT n₀)).Exact := by\n  refine ShortComplex.exact_of_iso ?_ (F.map_distinguished_exact _\n    (Triangle.shift_distinguished _ hT n₀))\n  exact ShortComplex.isoMk ((F.isoShift n₀).app _)\n    (n₀.negOnePow • ((F.isoShift n₀).app _)) ((F.isoShift n₀).app _)\n    (by dsimp; simp) (by dsimp; simp)\n\n"}
{"name":"CategoryTheory.Functor.homologySequence_exact₃","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ n₁ : Int\nh : Eq (HAdd.hAdd n₀ 1) n₁\n⊢ (CategoryTheory.ShortComplex.mk ((F.shift n₀).map T.mor₂) (F.homologySequenceδ T n₀ n₁ h) ⋯).Exact","decl":"lemma homologySequence_exact₃ :\n    (ShortComplex.mk _ _ (F.comp_homologySequenceδ T hT _ _ h)).Exact := by\n  refine ShortComplex.exact_of_iso ?_ (F.homologySequence_exact₂ _ (rot_of_distTriang _ hT) n₀)\n  exact ShortComplex.isoMk (Iso.refl _) (Iso.refl _)\n    ((F.shiftIso 1 n₀ n₁ (by omega)).app _) (by simp) (by simp [homologySequenceδ, shiftMap])\n\n"}
{"name":"CategoryTheory.Functor.homologySequence_exact₁","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ n₁ : Int\nh : Eq (HAdd.hAdd n₀ 1) n₁\n⊢ (CategoryTheory.ShortComplex.mk (F.homologySequenceδ T n₀ n₁ h) ((F.shift n₁).map T.mor₁) ⋯).Exact","decl":"lemma homologySequence_exact₁ :\n    (ShortComplex.mk _ _ (F.homologySequenceδ_comp T hT _ _ h)).Exact := by\n  refine ShortComplex.exact_of_iso ?_ (F.homologySequence_exact₂ _ (inv_rot_of_distTriang _ hT) n₁)\n  refine ShortComplex.isoMk (-((F.shiftIso (-1) n₁ n₀ (by omega)).app _))\n    (Iso.refl _) (Iso.refl _) ?_ (by simp)\n  dsimp\n  simp only [homologySequenceδ, neg_comp, map_neg, comp_id,\n    F.shiftIso_hom_app_comp_shiftMap_of_add_eq_zero T.mor₃ (-1) (neg_add_cancel 1) n₀ n₁ (by omega)]\n\n"}
{"name":"CategoryTheory.Functor.homologySequence_epi_shift_map_mor₁_iff","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ : Int\n⊢ Iff (CategoryTheory.Epi ((F.shift n₀).map T.mor₁)) (Eq ((F.shift n₀).map T.mor₂) 0)","decl":"lemma homologySequence_epi_shift_map_mor₁_iff :\n    Epi ((F.shift n₀).map T.mor₁) ↔ (F.shift n₀).map T.mor₂ = 0 :=\n  (F.homologySequence_exact₂ T hT n₀).epi_f_iff\n\n"}
{"name":"CategoryTheory.Functor.homologySequence_mono_shift_map_mor₁_iff","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ n₁ : Int\nh : Eq (HAdd.hAdd n₀ 1) n₁\n⊢ Iff (CategoryTheory.Mono ((F.shift n₁).map T.mor₁)) (Eq (F.homologySequenceδ T n₀ n₁ h) 0)","decl":"lemma homologySequence_mono_shift_map_mor₁_iff :\n    Mono ((F.shift n₁).map T.mor₁) ↔ F.homologySequenceδ T n₀ n₁ h = 0 :=\n  (F.homologySequence_exact₁ T hT n₀ n₁ h).mono_g_iff\n\n"}
{"name":"CategoryTheory.Functor.homologySequence_epi_shift_map_mor₂_iff","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ n₁ : Int\nh : Eq (HAdd.hAdd n₀ 1) n₁\n⊢ Iff (CategoryTheory.Epi ((F.shift n₀).map T.mor₂)) (Eq (F.homologySequenceδ T n₀ n₁ h) 0)","decl":"lemma homologySequence_epi_shift_map_mor₂_iff :\n    Epi ((F.shift n₀).map T.mor₂) ↔ F.homologySequenceδ T n₀ n₁ h = 0 :=\n  (F.homologySequence_exact₃ T hT n₀ n₁ h).epi_f_iff\n\n"}
{"name":"CategoryTheory.Functor.homologySequence_mono_shift_map_mor₂_iff","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ : Int\n⊢ Iff (CategoryTheory.Mono ((F.shift n₀).map T.mor₂)) (Eq ((F.shift n₀).map T.mor₁) 0)","decl":"lemma homologySequence_mono_shift_map_mor₂_iff :\n    Mono ((F.shift n₀).map T.mor₂) ↔ (F.shift n₀).map T.mor₁ = 0 :=\n  (F.homologySequence_exact₂ T hT n₀).mono_g_iff\n"}
{"name":"CategoryTheory.Functor.mem_homologicalKernel_W_iff","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_5, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (F.homologicalKernel.W f) (∀ (n : Int), CategoryTheory.IsIso ((F.shift n).map f))","decl":"lemma mem_homologicalKernel_W_iff {X Y : C} (f : X ⟶ Y) :\n    F.homologicalKernel.W f ↔ ∀ (n : ℤ), IsIso ((F.shift n).map f) := by\n  obtain ⟨Z, g, h, hT⟩ := distinguished_cocone_triangle f\n  apply (F.homologicalKernel.mem_W_iff_of_distinguished _ hT).trans\n  have h₁ := fun n => (F.homologySequence_exact₃ _ hT n _ rfl).isZero_X₂_iff\n  have h₂ := fun n => F.homologySequence_mono_shift_map_mor₁_iff _ hT n _ rfl\n  have h₃ := fun n => F.homologySequence_epi_shift_map_mor₁_iff _ hT n\n  dsimp at h₁ h₂ h₃ ⊢\n  simp only [mem_homologicalKernel_iff, h₁, ← h₂, ← h₃]\n  constructor\n  · intro h n\n    obtain ⟨m, rfl⟩ : ∃ (m : ℤ), n = m + 1 := ⟨n - 1, by simp⟩\n    have := (h (m + 1)).1\n    have := (h m).2\n    apply isIso_of_mono_of_epi\n  · intros\n    constructor <;> infer_instance\n\n"}
{"name":"CategoryTheory.Functor.homologySequenceComposableArrows₅_exact","module":"Mathlib.CategoryTheory.Triangulated.HomologicalFunctor","initialProofState":"C : Type u_1\nA : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Category.{u_4, u_3} A\nF : CategoryTheory.Functor C A\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Abelian A\ninst✝¹ : F.IsHomological\ninst✝ : F.ShiftSequence Int\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nn₀ n₁ : Int\nh : Eq (HAdd.hAdd n₀ 1) n₁\n⊢ (F.homologySequenceComposableArrows₅ T n₀ n₁ h).Exact","decl":"include hT in\nlemma homologySequenceComposableArrows₅_exact :\n    (F.homologySequenceComposableArrows₅ T n₀ n₁ h).Exact :=\n  exact_of_δ₀ (F.homologySequence_exact₂ T hT n₀).exact_toComposableArrows\n    (exact_of_δ₀ (F.homologySequence_exact₃ T hT n₀ n₁ h).exact_toComposableArrows\n      (exact_of_δ₀ (F.homologySequence_exact₁ T hT n₀ n₁ h).exact_toComposableArrows\n        (F.homologySequence_exact₂ T hT n₁).exact_toComposableArrows))\n\n"}
