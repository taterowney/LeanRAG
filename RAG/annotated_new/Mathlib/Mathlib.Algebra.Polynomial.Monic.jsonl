{"name":"Polynomial.monic_zero_iff_subsingleton","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Iff (Polynomial.Monic 0) (Subsingleton R)","decl":"theorem monic_zero_iff_subsingleton : Monic (0 : R[X]) ↔ Subsingleton R :=\n  subsingleton_iff_zero_eq_one\n\n"}
{"name":"Polynomial.not_monic_zero_iff","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Iff (Not (Polynomial.Monic 0)) (Ne 0 1)","decl":"theorem not_monic_zero_iff : ¬Monic (0 : R[X]) ↔ (0 : R) ≠ 1 :=\n  (monic_zero_iff_subsingleton.trans subsingleton_iff_zero_eq_one.symm).not\n\n"}
{"name":"Polynomial.monic_zero_iff_subsingleton'","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Iff (Polynomial.Monic 0) (And (∀ (f g : Polynomial R), Eq f g) (∀ (a b : R), Eq a b))","decl":"theorem monic_zero_iff_subsingleton' :\n    Monic (0 : R[X]) ↔ (∀ f g : R[X], f = g) ∧ ∀ a b : R, a = b :=\n  Polynomial.monic_zero_iff_subsingleton.trans\n    ⟨by\n      intro\n      simp [eq_iff_true_of_subsingleton], fun h => subsingleton_iff.mpr h.2⟩\n\n"}
{"name":"Polynomial.Monic.as_sum","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : p.Monic\n⊢ Eq p (HAdd.hAdd (HPow.hPow Polynomial.X p.natDegree) ((Finset.range p.natDegree).sum fun i => HMul.hMul (Polynomial.C (p.coeff i)) (HPow.hPow Polynomial.X i)))","decl":"theorem Monic.as_sum (hp : p.Monic) :\n    p = X ^ p.natDegree + ∑ i ∈ range p.natDegree, C (p.coeff i) * X ^ i := by\n  conv_lhs => rw [p.as_sum_range_C_mul_X_pow, sum_range_succ_comm]\n  suffices C (p.coeff p.natDegree) = 1 by rw [this, one_mul]\n  exact congr_arg C hp\n\n"}
{"name":"Polynomial.ne_zero_of_ne_zero_of_monic","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhp : Ne p 0\nhq : q.Monic\n⊢ Ne q 0","decl":"theorem ne_zero_of_ne_zero_of_monic (hp : p ≠ 0) (hq : Monic q) : q ≠ 0 := by\n  rintro rfl\n  rw [Monic.def, leadingCoeff_zero] at hq\n  rw [← mul_one p, ← C_1, ← hq, C_0, mul_zero] at hp\n  exact hp rfl\n\n"}
{"name":"Polynomial.Monic.map","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nhp : p.Monic\n⊢ (Polynomial.map f p).Monic","decl":"theorem Monic.map [Semiring S] (f : R →+* S) (hp : Monic p) : Monic (p.map f) := by\n  unfold Monic\n  nontriviality\n  have : f p.leadingCoeff ≠ 0 := by\n    rw [show _ = _ from hp, f.map_one]\n    exact one_ne_zero\n  rw [Polynomial.leadingCoeff, coeff_map]\n  suffices p.coeff (p.map f).natDegree = 1 by simp [this]\n  rwa [natDegree_eq_of_degree_eq (degree_map_eq_of_leadingCoeff_ne_zero f this)]\n\n"}
{"name":"Polynomial.monic_C_mul_of_mul_leadingCoeff_eq_one","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nb : R\nhp : Eq (HMul.hMul b p.leadingCoeff) 1\n⊢ (HMul.hMul (Polynomial.C b) p).Monic","decl":"theorem monic_C_mul_of_mul_leadingCoeff_eq_one {b : R} (hp : b * p.leadingCoeff = 1) :\n    Monic (C b * p) := by\n  unfold Monic\n  nontriviality\n  rw [leadingCoeff_mul' _] <;> simp [leadingCoeff_C b, hp]\n\n"}
{"name":"Polynomial.monic_mul_C_of_leadingCoeff_mul_eq_one","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nb : R\nhp : Eq (HMul.hMul p.leadingCoeff b) 1\n⊢ (HMul.hMul p (Polynomial.C b)).Monic","decl":"theorem monic_mul_C_of_leadingCoeff_mul_eq_one {b : R} (hp : p.leadingCoeff * b = 1) :\n    Monic (p * C b) := by\n  unfold Monic\n  nontriviality\n  rw [leadingCoeff_mul' _] <;> simp [leadingCoeff_C b, hp]\n\n"}
{"name":"Polynomial.monic_of_degree_le","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\nH1 : LE.le p.degree ↑n\nH2 : Eq (p.coeff n) 1\n⊢ p.Monic","decl":"theorem monic_of_degree_le (n : ℕ) (H1 : degree p ≤ n) (H2 : coeff p n = 1) : Monic p :=\n  Decidable.byCases\n    (fun H : degree p < n => eq_of_zero_eq_one (H2 ▸ (coeff_eq_zero_of_degree_lt H).symm) _ _)\n    fun H : ¬degree p < n => by\n    rwa [Monic, Polynomial.leadingCoeff, natDegree, (lt_or_eq_of_le H1).resolve_left H]\n\n"}
{"name":"Polynomial.monic_X_pow_add","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\nH : LT.lt p.degree ↑n\n⊢ (HAdd.hAdd (HPow.hPow Polynomial.X n) p).Monic","decl":"theorem monic_X_pow_add {n : ℕ} (H : degree p < n) : Monic (X ^ n + p) :=\n  monic_of_degree_le n\n    (le_trans (degree_add_le _ _) (max_le (degree_X_pow_le _) (le_of_lt H)))\n    (by rw [coeff_add, coeff_X_pow, if_pos rfl, coeff_eq_zero_of_degree_lt H, add_zero])\n\n"}
{"name":"Polynomial.monic_X_pow_add_C","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\nn : Nat\nh : Ne n 0\n⊢ (HAdd.hAdd (HPow.hPow Polynomial.X n) (Polynomial.C a)).Monic","decl":"variable (a) in\ntheorem monic_X_pow_add_C {n : ℕ} (h : n ≠ 0) : (X ^ n + C a).Monic :=\n   monic_X_pow_add <| (lt_of_le_of_lt degree_C_le\n     (by simp only [Nat.cast_pos, Nat.pos_iff_ne_zero, ne_eq, h, not_false_eq_true]))\n\n"}
{"name":"Polynomial.monic_X_add_C","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\nx : R\n⊢ (HAdd.hAdd Polynomial.X (Polynomial.C x)).Monic","decl":"theorem monic_X_add_C (x : R) : Monic (X + C x) :=\n  pow_one (X : R[X]) ▸ monic_X_pow_add_C x one_ne_zero\n\n"}
{"name":"Polynomial.Monic.mul","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhp : p.Monic\nhq : q.Monic\n⊢ (HMul.hMul p q).Monic","decl":"theorem Monic.mul (hp : Monic p) (hq : Monic q) : Monic (p * q) :=\n  letI := Classical.decEq R\n  if h0 : (0 : R) = 1 then\n    haveI := subsingleton_of_zero_eq_one h0\n    Subsingleton.elim _ _\n  else by\n    have : p.leadingCoeff * q.leadingCoeff ≠ 0 := by\n      simp [Monic.def.1 hp, Monic.def.1 hq, Ne.symm h0]\n    rw [Monic.def, leadingCoeff_mul' this, Monic.def.1 hp, Monic.def.1 hq, one_mul]\n\n"}
{"name":"Polynomial.Monic.pow","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : p.Monic\nn : Nat\n⊢ (HPow.hPow p n).Monic","decl":"theorem Monic.pow (hp : Monic p) : ∀ n : ℕ, Monic (p ^ n)\n  | 0 => monic_one\n  | n + 1 => by\n    rw [pow_succ]\n    exact (Monic.pow hp n).mul hp\n\n"}
{"name":"Polynomial.Monic.add_of_left","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhp : p.Monic\nhpq : LT.lt q.degree p.degree\n⊢ (HAdd.hAdd p q).Monic","decl":"theorem Monic.add_of_left (hp : Monic p) (hpq : degree q < degree p) : Monic (p + q) := by\n  rwa [Monic, add_comm, leadingCoeff_add_of_degree_lt hpq]\n\n"}
{"name":"Polynomial.Monic.add_of_right","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhq : q.Monic\nhpq : LT.lt p.degree q.degree\n⊢ (HAdd.hAdd p q).Monic","decl":"theorem Monic.add_of_right (hq : Monic q) (hpq : degree p < degree q) : Monic (p + q) := by\n  rwa [Monic, leadingCoeff_add_of_degree_lt hpq]\n\n"}
{"name":"Polynomial.Monic.of_mul_monic_left","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhp : p.Monic\nhpq : (HMul.hMul p q).Monic\n⊢ q.Monic","decl":"theorem Monic.of_mul_monic_left (hp : p.Monic) (hpq : (p * q).Monic) : q.Monic := by\n  contrapose! hpq\n  rw [Monic.def] at hpq ⊢\n  rwa [leadingCoeff_monic_mul hp]\n\n"}
{"name":"Polynomial.Monic.of_mul_monic_right","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhq : q.Monic\nhpq : (HMul.hMul p q).Monic\n⊢ p.Monic","decl":"theorem Monic.of_mul_monic_right (hq : q.Monic) (hpq : (p * q).Monic) : p.Monic := by\n  contrapose! hpq\n  rw [Monic.def] at hpq ⊢\n  rwa [leadingCoeff_mul_monic hq]\n\n"}
{"name":"Polynomial.Monic.comp","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhp : p.Monic\nhq : q.Monic\nh : Ne q.natDegree 0\n⊢ (p.comp q).Monic","decl":"lemma comp (hp : p.Monic) (hq : q.Monic) (h : q.natDegree ≠ 0) : (p.comp q).Monic := by\n  nontriviality R\n  have : (p.comp q).natDegree = p.natDegree * q.natDegree :=\n    natDegree_comp_eq_of_mul_ne_zero <| by simp [hp.leadingCoeff, hq.leadingCoeff]\n  rw [Monic.def, Polynomial.leadingCoeff, this, coeff_comp_degree_mul_degree h, hp.leadingCoeff,\n    hq.leadingCoeff, one_pow, mul_one]\n\n"}
{"name":"Polynomial.Monic.comp_X_add_C","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : p.Monic\nr : R\n⊢ (p.comp (HAdd.hAdd Polynomial.X (Polynomial.C r))).Monic","decl":"lemma comp_X_add_C (hp : p.Monic) (r : R) : (p.comp (X + C r)).Monic := by\n  nontriviality R\n  refine hp.comp (monic_X_add_C _) fun ha ↦ ?_\n  rw [natDegree_X_add_C] at ha\n  exact one_ne_zero ha\n\n"}
{"name":"Polynomial.Monic.natDegree_eq_zero_iff_eq_one","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : p.Monic\n⊢ Iff (Eq p.natDegree 0) (Eq p 1)","decl":"@[simp]\ntheorem natDegree_eq_zero_iff_eq_one (hp : p.Monic) : p.natDegree = 0 ↔ p = 1 := by\n  constructor <;> intro h\n  swap\n  · rw [h]\n    exact natDegree_one\n  have : p = C (p.coeff 0) := by\n    rw [← Polynomial.degree_le_zero_iff]\n    rwa [Polynomial.natDegree_eq_zero_iff_degree_le_zero] at h\n  rw [this]\n  rw [← h, ← Polynomial.leadingCoeff, Monic.def.1 hp, C_1]\n\n"}
{"name":"Polynomial.Monic.degree_le_zero_iff_eq_one","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : p.Monic\n⊢ Iff (LE.le p.degree 0) (Eq p 1)","decl":"@[simp]\ntheorem degree_le_zero_iff_eq_one (hp : p.Monic) : p.degree ≤ 0 ↔ p = 1 := by\n  rw [← hp.natDegree_eq_zero_iff_eq_one, natDegree_eq_zero_iff_degree_le_zero]\n\n"}
{"name":"Polynomial.Monic.natDegree_mul","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhp : p.Monic\nhq : q.Monic\n⊢ Eq (HMul.hMul p q).natDegree (HAdd.hAdd p.natDegree q.natDegree)","decl":"theorem natDegree_mul (hp : p.Monic) (hq : q.Monic) :\n    (p * q).natDegree = p.natDegree + q.natDegree := by\n  nontriviality R\n  apply natDegree_mul'\n  simp [hp.leadingCoeff, hq.leadingCoeff]\n\n"}
{"name":"Polynomial.Monic.degree_mul_comm","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : p.Monic\nq : Polynomial R\n⊢ Eq (HMul.hMul p q).degree (HMul.hMul q p).degree","decl":"theorem degree_mul_comm (hp : p.Monic) (q : R[X]) : (p * q).degree = (q * p).degree := by\n  by_cases h : q = 0\n  · simp [h]\n  rw [degree_mul', hp.degree_mul]\n  · exact add_comm _ _\n  · rwa [hp.leadingCoeff, one_mul, leadingCoeff_ne_zero]\n\n"}
{"name":"Polynomial.Monic.natDegree_mul'","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhp : p.Monic\nhq : Ne q 0\n⊢ Eq (HMul.hMul p q).natDegree (HAdd.hAdd p.natDegree q.natDegree)","decl":"nonrec theorem natDegree_mul' (hp : p.Monic) (hq : q ≠ 0) :\n    (p * q).natDegree = p.natDegree + q.natDegree := by\n  rw [natDegree_mul']\n  simpa [hp.leadingCoeff, leadingCoeff_ne_zero]\n\n"}
{"name":"Polynomial.Monic.natDegree_mul_comm","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : p.Monic\nq : Polynomial R\n⊢ Eq (HMul.hMul p q).natDegree (HMul.hMul q p).natDegree","decl":"theorem natDegree_mul_comm (hp : p.Monic) (q : R[X]) : (p * q).natDegree = (q * p).natDegree := by\n  by_cases h : q = 0\n  · simp [h]\n  rw [hp.natDegree_mul' h, Polynomial.natDegree_mul', add_comm]\n  simpa [hp.leadingCoeff, leadingCoeff_ne_zero]\n\n"}
{"name":"Polynomial.Monic.not_dvd_of_natDegree_lt","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhp : p.Monic\nh0 : Ne q 0\nhl : LT.lt q.natDegree p.natDegree\n⊢ Not (Dvd.dvd p q)","decl":"theorem not_dvd_of_natDegree_lt (hp : Monic p) (h0 : q ≠ 0) (hl : natDegree q < natDegree p) :\n    ¬p ∣ q := by\n  rintro ⟨r, rfl⟩\n  rw [hp.natDegree_mul' <| right_ne_zero_of_mul h0] at hl\n  exact hl.not_le (Nat.le_add_right _ _)\n\n"}
{"name":"Polynomial.Monic.not_dvd_of_degree_lt","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhp : p.Monic\nh0 : Ne q 0\nhl : LT.lt q.degree p.degree\n⊢ Not (Dvd.dvd p q)","decl":"theorem not_dvd_of_degree_lt (hp : Monic p) (h0 : q ≠ 0) (hl : degree q < degree p) : ¬p ∣ q :=\n  Monic.not_dvd_of_natDegree_lt hp h0 <| natDegree_lt_natDegree h0 hl\n\n"}
{"name":"Polynomial.Monic.nextCoeff_mul","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhp : p.Monic\nhq : q.Monic\n⊢ Eq (HMul.hMul p q).nextCoeff (HAdd.hAdd p.nextCoeff q.nextCoeff)","decl":"theorem nextCoeff_mul (hp : Monic p) (hq : Monic q) :\n    nextCoeff (p * q) = nextCoeff p + nextCoeff q := by\n  nontriviality\n  simp only [← coeff_one_reverse]\n  rw [reverse_mul] <;> simp [hp.leadingCoeff, hq.leadingCoeff, mul_coeff_one, add_comm]\n\n"}
{"name":"Polynomial.Monic.nextCoeff_pow","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : p.Monic\nn : Nat\n⊢ Eq (HPow.hPow p n).nextCoeff (HSMul.hSMul n p.nextCoeff)","decl":"theorem nextCoeff_pow (hp : p.Monic) (n : ℕ) : (p ^ n).nextCoeff = n • p.nextCoeff := by\n  induction n with\n  | zero => rw [pow_zero, zero_smul, ← map_one (f := C), nextCoeff_C_eq_zero]\n  | succ n ih => rw [pow_succ, (hp.pow n).nextCoeff_mul hp, ih, succ_nsmul]\n\n"}
{"name":"Polynomial.Monic.eq_one_of_map_eq_one","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝² : Semiring R\np : Polynomial R\nS : Type u_1\ninst✝¹ : Semiring S\ninst✝ : Nontrivial S\nf : RingHom R S\nhp : p.Monic\nmap_eq : Eq (Polynomial.map f p) 1\n⊢ Eq p 1","decl":"theorem eq_one_of_map_eq_one {S : Type*} [Semiring S] [Nontrivial S] (f : R →+* S) (hp : p.Monic)\n    (map_eq : p.map f = 1) : p = 1 := by\n  nontriviality R\n  have hdeg : p.degree = 0 := by\n    rw [← degree_map_eq_of_leadingCoeff_ne_zero f _, map_eq, degree_one]\n    · rw [hp.leadingCoeff, f.map_one]\n      exact one_ne_zero\n  have hndeg : p.natDegree = 0 :=\n    WithBot.coe_eq_coe.mp ((degree_eq_natDegree hp.ne_zero).symm.trans hdeg)\n  convert eq_C_of_degree_eq_zero hdeg\n  rw [← hndeg, ← Polynomial.leadingCoeff, hp.leadingCoeff, C.map_one]\n\n"}
{"name":"Polynomial.Monic.natDegree_pow","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : p.Monic\nn : Nat\n⊢ Eq (HPow.hPow p n).natDegree (HMul.hMul n p.natDegree)","decl":"theorem natDegree_pow (hp : p.Monic) (n : ℕ) : (p ^ n).natDegree = n * p.natDegree := by\n  induction n with\n  | zero => simp\n  | succ n hn => rw [pow_succ, (hp.pow n).natDegree_mul hp, hn, Nat.succ_mul, add_comm]\n\n"}
{"name":"Polynomial.natDegree_pow_X_add_C","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\nn : Nat\nr : R\n⊢ Eq (HPow.hPow (HAdd.hAdd Polynomial.X (Polynomial.C r)) n).natDegree n","decl":"@[simp]\ntheorem natDegree_pow_X_add_C [Nontrivial R] (n : ℕ) (r : R) : ((X + C r) ^ n).natDegree = n := by\n  rw [(monic_X_add_C r).natDegree_pow, natDegree_X_add_C, mul_one]\n\n"}
{"name":"Polynomial.Monic.eq_one_of_isUnit","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhm : p.Monic\nhpu : IsUnit p\n⊢ Eq p 1","decl":"theorem Monic.eq_one_of_isUnit (hm : Monic p) (hpu : IsUnit p) : p = 1 := by\n  nontriviality R\n  obtain ⟨q, h⟩ := hpu.exists_right_inv\n  have := hm.natDegree_mul' (right_ne_zero_of_mul_eq_one h)\n  rw [h, natDegree_one, eq_comm, add_eq_zero] at this\n  exact hm.natDegree_eq_zero_iff_eq_one.mp this.1\n\n"}
{"name":"Polynomial.Monic.isUnit_iff","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhm : p.Monic\n⊢ Iff (IsUnit p) (Eq p 1)","decl":"theorem Monic.isUnit_iff (hm : p.Monic) : IsUnit p ↔ p = 1 :=\n  ⟨hm.eq_one_of_isUnit, fun h => h.symm ▸ isUnit_one⟩\n\n"}
{"name":"Polynomial.eq_of_monic_of_associated","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhp : p.Monic\nhq : q.Monic\nhpq : Associated p q\n⊢ Eq p q","decl":"theorem eq_of_monic_of_associated (hp : p.Monic) (hq : q.Monic) (hpq : Associated p q) : p = q := by\n  obtain ⟨u, rfl⟩ := hpq\n  rw [(hp.of_mul_monic_left hq).eq_one_of_isUnit u.isUnit, mul_one]\n\n"}
{"name":"Polynomial.monic_multiset_prod_of_monic","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nι : Type y\ninst✝ : CommSemiring R\nt : Multiset ι\nf : ι → Polynomial R\nht : ∀ (i : ι), Membership.mem t i → (f i).Monic\n⊢ (Multiset.map f t).prod.Monic","decl":"theorem monic_multiset_prod_of_monic (t : Multiset ι) (f : ι → R[X]) (ht : ∀ i ∈ t, Monic (f i)) :\n    Monic (t.map f).prod := by\n  revert ht\n  refine t.induction_on ?_ ?_; · simp\n  intro a t ih ht\n  rw [Multiset.map_cons, Multiset.prod_cons]\n  exact (ht _ (Multiset.mem_cons_self _ _)).mul (ih fun _ hi => ht _ (Multiset.mem_cons_of_mem hi))\n\n"}
{"name":"Polynomial.monic_prod_of_monic","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nι : Type y\ninst✝ : CommSemiring R\ns : Finset ι\nf : ι → Polynomial R\nhs : ∀ (i : ι), Membership.mem s i → (f i).Monic\n⊢ (s.prod fun i => f i).Monic","decl":"theorem monic_prod_of_monic (s : Finset ι) (f : ι → R[X]) (hs : ∀ i ∈ s, Monic (f i)) :\n    Monic (∏ i ∈ s, f i) :=\n  monic_multiset_prod_of_monic s.1 f hs\n\n"}
{"name":"Polynomial.Monic.nextCoeff_multiset_prod","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nι : Type y\ninst✝ : CommSemiring R\nt : Multiset ι\nf : ι → Polynomial R\nh : ∀ (i : ι), Membership.mem t i → (f i).Monic\n⊢ Eq (Multiset.map f t).prod.nextCoeff (Multiset.map (fun i => (f i).nextCoeff) t).sum","decl":"theorem Monic.nextCoeff_multiset_prod (t : Multiset ι) (f : ι → R[X]) (h : ∀ i ∈ t, Monic (f i)) :\n    nextCoeff (t.map f).prod = (t.map fun i => nextCoeff (f i)).sum := by\n  revert h\n  refine Multiset.induction_on t ?_ fun a t ih ht => ?_\n  · simp only [Multiset.not_mem_zero, forall_prop_of_true, forall_prop_of_false, Multiset.map_zero,\n      Multiset.prod_zero, Multiset.sum_zero, not_false_iff, forall_true_iff]\n    rw [← C_1]\n    rw [nextCoeff_C_eq_zero]\n  · rw [Multiset.map_cons, Multiset.prod_cons, Multiset.map_cons, Multiset.sum_cons,\n      Monic.nextCoeff_mul, ih]\n    exacts [fun i hi => ht i (Multiset.mem_cons_of_mem hi), ht a (Multiset.mem_cons_self _ _),\n      monic_multiset_prod_of_monic _ _ fun b bs => ht _ (Multiset.mem_cons_of_mem bs)]\n\n"}
{"name":"Polynomial.Monic.nextCoeff_prod","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nι : Type y\ninst✝ : CommSemiring R\ns : Finset ι\nf : ι → Polynomial R\nh : ∀ (i : ι), Membership.mem s i → (f i).Monic\n⊢ Eq (s.prod fun i => f i).nextCoeff (s.sum fun i => (f i).nextCoeff)","decl":"theorem Monic.nextCoeff_prod (s : Finset ι) (f : ι → R[X]) (h : ∀ i ∈ s, Monic (f i)) :\n    nextCoeff (∏ i ∈ s, f i) = ∑ i ∈ s, nextCoeff (f i) :=\n  Monic.nextCoeff_multiset_prod s.1 f h\n\n"}
{"name":"Polynomial.irreducible_of_monic","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\np : Polynomial R\nhp : p.Monic\nhp1 : Ne p 1\n⊢ Iff (Irreducible p) (∀ (f g : Polynomial R), f.Monic → g.Monic → Eq (HMul.hMul f g) p → Or (Eq f 1) (Eq g 1))","decl":"lemma irreducible_of_monic (hp : p.Monic) (hp1 : p ≠ 1) :\n    Irreducible p ↔ ∀ f g : R[X], f.Monic → g.Monic → f * g = p → f = 1 ∨ g = 1 := by\n  refine\n    ⟨fun h f g hf hg hp => (h.2 f g hp.symm).imp hf.eq_one_of_isUnit hg.eq_one_of_isUnit, fun h =>\n      ⟨hp1 ∘ hp.eq_one_of_isUnit, fun f g hfg =>\n        (h (g * C f.leadingCoeff) (f * C g.leadingCoeff) ?_ ?_ ?_).symm.imp\n          (isUnit_of_mul_eq_one f _)\n          (isUnit_of_mul_eq_one g _)⟩⟩\n  · rwa [Monic, leadingCoeff_mul, leadingCoeff_C, ← leadingCoeff_mul, mul_comm, ← hfg, ← Monic]\n  · rwa [Monic, leadingCoeff_mul, leadingCoeff_C, ← leadingCoeff_mul, ← hfg, ← Monic]\n  · rw [mul_mul_mul_comm, ← C_mul, ← leadingCoeff_mul, ← hfg, hp.leadingCoeff, C_1, mul_one,\n      mul_comm, ← hfg]\n\n\n"}
{"name":"Polynomial.Monic.irreducible_iff_natDegree","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\np : Polynomial R\nhp : p.Monic\n⊢ Iff (Irreducible p) (And (Ne p 1) (∀ (f g : Polynomial R), f.Monic → g.Monic → Eq (HMul.hMul f g) p → Or (Eq f.natDegree 0) (Eq g.natDegree 0)))","decl":"lemma Monic.irreducible_iff_natDegree (hp : p.Monic) :\n    Irreducible p ↔\n      p ≠ 1 ∧ ∀ f g : R[X], f.Monic → g.Monic → f * g = p → f.natDegree = 0 ∨ g.natDegree = 0 := by\n  by_cases hp1 : p = 1; · simp [hp1]\n  rw [irreducible_of_monic hp hp1, and_iff_right hp1]\n  refine forall₄_congr fun a b ha hb => ?_\n  rw [ha.natDegree_eq_zero_iff_eq_one, hb.natDegree_eq_zero_iff_eq_one]\n\n"}
{"name":"Polynomial.Monic.irreducible_iff_natDegree'","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\np : Polynomial R\nhp : p.Monic\n⊢ Iff (Irreducible p) (And (Ne p 1) (∀ (f g : Polynomial R), f.Monic → g.Monic → Eq (HMul.hMul f g) p → Not (Membership.mem (Finset.Ioc 0 (HDiv.hDiv p.natDegree 2)) g.natDegree)))","decl":"lemma Monic.irreducible_iff_natDegree' (hp : p.Monic) : Irreducible p ↔ p ≠ 1 ∧\n    ∀ f g : R[X], f.Monic → g.Monic → f * g = p → g.natDegree ∉ Ioc 0 (p.natDegree / 2) := by\n  simp_rw [hp.irreducible_iff_natDegree, mem_Ioc, Nat.le_div_iff_mul_le zero_lt_two, mul_two]\n  apply and_congr_right'\n  constructor <;> intro h f g hf hg he <;> subst he\n  · rw [hf.natDegree_mul hg, add_le_add_iff_right]\n    exact fun ha => (h f g hf hg rfl).elim (ha.1.trans_le ha.2).ne' ha.1.ne'\n  · simp_rw [hf.natDegree_mul hg, pos_iff_ne_zero] at h\n    contrapose! h\n    obtain hl | hl := le_total f.natDegree g.natDegree\n    · exact ⟨g, f, hg, hf, mul_comm g f, h.1, add_le_add_left hl _⟩\n    · exact ⟨f, g, hf, hg, rfl, h.2, add_le_add_right hl _⟩\n\n"}
{"name":"Polynomial.Monic.irreducible_iff_lt_natDegree_lt","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\np : Polynomial R\nhp : p.Monic\nhp1 : Ne p 1\n⊢ Iff (Irreducible p) (∀ (q : Polynomial R), q.Monic → Membership.mem (Finset.Ioc 0 (HDiv.hDiv p.natDegree 2)) q.natDegree → Not (Dvd.dvd q p))","decl":"/-- Alternate phrasing of `Polynomial.Monic.irreducible_iff_natDegree'` where we only have to check\none divisor at a time. -/\nlemma Monic.irreducible_iff_lt_natDegree_lt {p : R[X]} (hp : p.Monic) (hp1 : p ≠ 1) :\n    Irreducible p ↔ ∀ q, Monic q → natDegree q ∈ Finset.Ioc 0 (natDegree p / 2) → ¬ q ∣ p := by\n  rw [hp.irreducible_iff_natDegree', and_iff_right hp1]\n  constructor\n  · rintro h g hg hdg ⟨f, rfl⟩\n    exact h f g (hg.of_mul_monic_left hp) hg (mul_comm f g) hdg\n  · rintro h f g - hg rfl hdg\n    exact h g hg hdg (dvd_mul_left g f)\n\n"}
{"name":"Polynomial.Monic.not_irreducible_iff_exists_add_mul_eq_coeff","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : NoZeroDivisors R\np : Polynomial R\nhm : p.Monic\nhnd : Eq p.natDegree 2\n⊢ Iff (Not (Irreducible p)) (Exists fun c₁ => Exists fun c₂ => And (Eq (p.coeff 0) (HMul.hMul c₁ c₂)) (Eq (p.coeff 1) (HAdd.hAdd c₁ c₂)))","decl":"lemma Monic.not_irreducible_iff_exists_add_mul_eq_coeff (hm : p.Monic) (hnd : p.natDegree = 2) :\n    ¬Irreducible p ↔ ∃ c₁ c₂, p.coeff 0 = c₁ * c₂ ∧ p.coeff 1 = c₁ + c₂ := by\n  cases subsingleton_or_nontrivial R\n  · simp [natDegree_of_subsingleton] at hnd\n  rw [hm.irreducible_iff_natDegree', and_iff_right, hnd]\n  · push_neg\n    constructor\n    · rintro ⟨a, b, ha, hb, rfl, hdb⟩\n      simp only [zero_lt_two, Nat.div_self, Nat.Ioc_succ_singleton, zero_add, mem_singleton] at hdb\n      have hda := hnd\n      rw [ha.natDegree_mul hb, hdb] at hda\n      use a.coeff 0, b.coeff 0, mul_coeff_zero a b\n      simpa only [nextCoeff, hnd, add_right_cancel hda, hdb] using ha.nextCoeff_mul hb\n    · rintro ⟨c₁, c₂, hmul, hadd⟩\n      refine\n        ⟨X + C c₁, X + C c₂, monic_X_add_C _, monic_X_add_C _, ?_, ?_⟩\n      · rw [p.as_sum_range_C_mul_X_pow, hnd, Finset.sum_range_succ, Finset.sum_range_succ,\n          Finset.sum_range_one, ← hnd, hm.coeff_natDegree, hnd, hmul, hadd, C_mul, C_add, C_1]\n        ring\n      · rw [mem_Ioc, natDegree_X_add_C _]\n        simp\n  · rintro rfl\n    simp [natDegree_one] at hnd\n\n"}
{"name":"Polynomial.Monic.natDegree_map","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nS : Type v\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : Nontrivial S\nP : Polynomial R\nhmo : P.Monic\nf : RingHom R S\n⊢ Eq (Polynomial.map f P).natDegree P.natDegree","decl":"@[simp]\ntheorem Monic.natDegree_map [Semiring S] [Nontrivial S] {P : R[X]} (hmo : P.Monic) (f : R →+* S) :\n    (P.map f).natDegree = P.natDegree := by\n  refine le_antisymm natDegree_map_le (le_natDegree_of_ne_zero ?_)\n  rw [coeff_map, Monic.coeff_natDegree hmo, RingHom.map_one]\n  exact one_ne_zero\n\n"}
{"name":"Polynomial.Monic.degree_map","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nS : Type v\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : Nontrivial S\nP : Polynomial R\nhmo : P.Monic\nf : RingHom R S\n⊢ Eq (Polynomial.map f P).degree P.degree","decl":"@[simp]\ntheorem Monic.degree_map [Semiring S] [Nontrivial S] {P : R[X]} (hmo : P.Monic) (f : R →+* S) :\n    (P.map f).degree = P.degree := by\n  by_cases hP : P = 0\n  · simp [hP]\n  · refine le_antisymm degree_map_le ?_\n    rw [degree_eq_natDegree hP]\n    refine le_degree_of_ne_zero ?_\n    rw [coeff_map, Monic.coeff_natDegree hmo, RingHom.map_one]\n    exact one_ne_zero\n\n"}
{"name":"Polynomial.degree_map_eq_of_injective","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\np : Polynomial R\n⊢ Eq (Polynomial.map f p).degree p.degree","decl":"theorem degree_map_eq_of_injective (hf : Injective f) (p : R[X]) : degree (p.map f) = degree p :=\n  letI := Classical.decEq R\n  if h : p = 0 then by simp [h]\n  else\n    degree_map_eq_of_leadingCoeff_ne_zero _\n      (by rw [← f.map_zero]; exact mt hf.eq_iff.1 (mt leadingCoeff_eq_zero.1 h))\n\n"}
{"name":"Polynomial.natDegree_map_eq_of_injective","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\np : Polynomial R\n⊢ Eq (Polynomial.map f p).natDegree p.natDegree","decl":"theorem natDegree_map_eq_of_injective (hf : Injective f) (p : R[X]) :\n    natDegree (p.map f) = natDegree p :=\n  natDegree_eq_of_degree_eq (degree_map_eq_of_injective hf p)\n\n"}
{"name":"Polynomial.leadingCoeff_map'","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\np : Polynomial R\n⊢ Eq (Polynomial.map f p).leadingCoeff (f p.leadingCoeff)","decl":"theorem leadingCoeff_map' (hf : Injective f) (p : R[X]) :\n    leadingCoeff (p.map f) = f (leadingCoeff p) := by\n  unfold leadingCoeff\n  rw [coeff_map, natDegree_map_eq_of_injective hf p]\n\n"}
{"name":"Polynomial.nextCoeff_map","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\np : Polynomial R\n⊢ Eq (Polynomial.map f p).nextCoeff (f p.nextCoeff)","decl":"theorem nextCoeff_map (hf : Injective f) (p : R[X]) : (p.map f).nextCoeff = f p.nextCoeff := by\n  unfold nextCoeff\n  rw [natDegree_map_eq_of_injective hf]\n  split_ifs <;> simp [*]\n\n"}
{"name":"Polynomial.leadingCoeff_of_injective","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\np : Polynomial R\n⊢ Eq (Polynomial.map f p).leadingCoeff (f p.leadingCoeff)","decl":"theorem leadingCoeff_of_injective (hf : Injective f) (p : R[X]) :\n    leadingCoeff (p.map f) = f (leadingCoeff p) := by\n  delta leadingCoeff\n  rw [coeff_map f, natDegree_map_eq_of_injective hf p]\n\n"}
{"name":"Polynomial.monic_of_injective","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\np : Polynomial R\nhp : (Polynomial.map f p).Monic\n⊢ p.Monic","decl":"theorem monic_of_injective (hf : Injective f) {p : R[X]} (hp : (p.map f).Monic) : p.Monic := by\n  apply hf\n  rw [← leadingCoeff_of_injective hf, hp.leadingCoeff, f.map_one]\n\n"}
{"name":"Function.Injective.monic_map_iff","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\np : Polynomial R\n⊢ Iff p.Monic (Polynomial.map f p).Monic","decl":"theorem _root_.Function.Injective.monic_map_iff (hf : Injective f) {p : R[X]} :\n    p.Monic ↔ (p.map f).Monic :=\n  ⟨Monic.map _, Polynomial.monic_of_injective hf⟩\n\n"}
{"name":"Polynomial.monic_X_sub_C","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Ring R\nx : R\n⊢ (HSub.hSub Polynomial.X (Polynomial.C x)).Monic","decl":"theorem monic_X_sub_C (x : R) : Monic (X - C x) := by\n  simpa only [sub_eq_add_neg, C_neg] using monic_X_add_C (-x)\n\n"}
{"name":"Polynomial.monic_X_pow_sub","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nn : Nat\nH : LT.lt p.degree ↑n\n⊢ (HSub.hSub (HPow.hPow Polynomial.X n) p).Monic","decl":"theorem monic_X_pow_sub {n : ℕ} (H : degree p < n) : Monic (X ^ n - p) := by\n  simpa [sub_eq_add_neg] using monic_X_pow_add (show degree (-p) < n by rwa [← degree_neg p] at H)\n\n"}
{"name":"Polynomial.monic_X_pow_sub_C","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Ring R\na : R\nn : Nat\nh : Ne n 0\n⊢ (HSub.hSub (HPow.hPow Polynomial.X n) (Polynomial.C a)).Monic","decl":"/-- `X ^ n - a` is monic. -/\ntheorem monic_X_pow_sub_C {R : Type u} [Ring R] (a : R) {n : ℕ} (h : n ≠ 0) :\n    (X ^ n - C a).Monic := by\n  simpa only [map_neg, ← sub_eq_add_neg] using monic_X_pow_add_C (-a) h\n\n"}
{"name":"Polynomial.not_isUnit_X_pow_sub_one","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\nn : Nat\n⊢ Not (IsUnit (HSub.hSub (HPow.hPow Polynomial.X n) 1))","decl":"theorem not_isUnit_X_pow_sub_one (R : Type*) [CommRing R] [Nontrivial R] (n : ℕ) :\n    ¬IsUnit (X ^ n - 1 : R[X]) := by\n  intro h\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp at h\n  apply hn\n  rw [← @natDegree_one R, ← (monic_X_pow_sub_C _ hn).eq_one_of_isUnit h, natDegree_X_pow_sub_C]\n\n"}
{"name":"Polynomial.Monic.comp_X_sub_C","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nhp : p.Monic\nr : R\n⊢ (p.comp (HSub.hSub Polynomial.X (Polynomial.C r))).Monic","decl":"lemma Monic.comp_X_sub_C {p : R[X]} (hp : p.Monic) (r : R) : (p.comp (X - C r)).Monic := by\n  simpa using hp.comp_X_add_C (-r)\n\n"}
{"name":"Polynomial.Monic.sub_of_left","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nhp : p.Monic\nhpq : LT.lt q.degree p.degree\n⊢ (HSub.hSub p q).Monic","decl":"theorem Monic.sub_of_left {p q : R[X]} (hp : Monic p) (hpq : degree q < degree p) :\n    Monic (p - q) := by\n  rw [sub_eq_add_neg]\n  apply hp.add_of_left\n  rwa [degree_neg]\n\n"}
{"name":"Polynomial.Monic.sub_of_right","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nhq : Eq q.leadingCoeff (-1)\nhpq : LT.lt p.degree q.degree\n⊢ (HSub.hSub p q).Monic","decl":"theorem Monic.sub_of_right {p q : R[X]} (hq : q.leadingCoeff = -1) (hpq : degree p < degree q) :\n    Monic (p - q) := by\n  have : (-q).coeff (-q).natDegree = 1 := by\n    rw [natDegree_neg, coeff_neg, show q.coeff q.natDegree = -1 from hq, neg_neg]\n  rw [sub_eq_add_neg]\n  apply Monic.add_of_right this\n  rwa [degree_neg]\n\n"}
{"name":"Polynomial.not_monic_zero","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\n⊢ Not (Polynomial.Monic 0)","decl":"@[simp]\ntheorem not_monic_zero : ¬Monic (0 : R[X]) :=\n  not_monic_zero_iff.mp zero_ne_one\n\n"}
{"name":"Polynomial.Monic.mul_left_ne_zero","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : p.Monic\nq : Polynomial R\nhq : Ne q 0\n⊢ Ne (HMul.hMul q p) 0","decl":"theorem Monic.mul_left_ne_zero (hp : Monic p) {q : R[X]} (hq : q ≠ 0) : q * p ≠ 0 := by\n  by_cases h : p = 1\n  · simpa [h]\n  rw [Ne, ← degree_eq_bot, hp.degree_mul, WithBot.add_eq_bot, not_or, degree_eq_bot]\n  refine ⟨hq, ?_⟩\n  rw [← hp.degree_le_zero_iff_eq_one, not_le] at h\n  refine (lt_trans ?_ h).ne'\n  simp\n\n"}
{"name":"Polynomial.Monic.mul_right_ne_zero","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : p.Monic\nq : Polynomial R\nhq : Ne q 0\n⊢ Ne (HMul.hMul p q) 0","decl":"theorem Monic.mul_right_ne_zero (hp : Monic p) {q : R[X]} (hq : q ≠ 0) : p * q ≠ 0 := by\n  by_cases h : p = 1\n  · simpa [h]\n  rw [Ne, ← degree_eq_bot, hp.degree_mul_comm, hp.degree_mul, WithBot.add_eq_bot, not_or,\n    degree_eq_bot]\n  refine ⟨hq, ?_⟩\n  rw [← hp.degree_le_zero_iff_eq_one, not_le] at h\n  refine (lt_trans ?_ h).ne'\n  simp\n\n"}
{"name":"Polynomial.Monic.mul_natDegree_lt_iff","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nh : p.Monic\nq : Polynomial R\n⊢ Iff (LT.lt (HMul.hMul p q).natDegree p.natDegree) (And (Ne p 1) (Eq q 0))","decl":"theorem Monic.mul_natDegree_lt_iff (h : Monic p) {q : R[X]} :\n    (p * q).natDegree < p.natDegree ↔ p ≠ 1 ∧ q = 0 := by\n  by_cases hq : q = 0\n  · suffices 0 < p.natDegree ↔ p.natDegree ≠ 0 by simpa [hq, ← h.natDegree_eq_zero_iff_eq_one]\n    exact ⟨fun h => h.ne', fun h => lt_of_le_of_ne (Nat.zero_le _) h.symm⟩\n  · simp [h.natDegree_mul', hq]\n\n"}
{"name":"Polynomial.Monic.mul_right_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nh : p.Monic\nq : Polynomial R\n⊢ Iff (Eq (HMul.hMul p q) 0) (Eq q 0)","decl":"theorem Monic.mul_right_eq_zero_iff (h : Monic p) {q : R[X]} : p * q = 0 ↔ q = 0 := by\n  by_cases hq : q = 0 <;> simp [h.mul_right_ne_zero, hq]\n\n"}
{"name":"Polynomial.Monic.mul_left_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nh : p.Monic\nq : Polynomial R\n⊢ Iff (Eq (HMul.hMul q p) 0) (Eq q 0)","decl":"theorem Monic.mul_left_eq_zero_iff (h : Monic p) {q : R[X]} : q * p = 0 ↔ q = 0 := by\n  by_cases hq : q = 0 <;> simp [h.mul_left_ne_zero, hq]\n\n"}
{"name":"Polynomial.Monic.isRegular","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u_1\ninst✝ : Ring R\np : Polynomial R\nhp : p.Monic\n⊢ IsRegular p","decl":"theorem Monic.isRegular {R : Type*} [Ring R] {p : R[X]} (hp : Monic p) : IsRegular p := by\n  constructor\n  · intro q r h\n    dsimp only at h\n    rw [← sub_eq_zero, ← hp.mul_right_eq_zero_iff, mul_sub, h, sub_self]\n  · intro q r h\n    simp only at h\n    rw [← sub_eq_zero, ← hp.mul_left_eq_zero_iff, sub_mul, h, sub_self]\n\n"}
{"name":"Polynomial.degree_smul_of_smul_regular","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝² : Semiring R\nS : Type u_1\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S R\nk : S\np : Polynomial R\nh : IsSMulRegular R k\n⊢ Eq (HSMul.hSMul k p).degree p.degree","decl":"theorem degree_smul_of_smul_regular {S : Type*} [Monoid S] [DistribMulAction S R] {k : S}\n    (p : R[X]) (h : IsSMulRegular R k) : (k • p).degree = p.degree := by\n  refine le_antisymm ?_ ?_\n  · rw [degree_le_iff_coeff_zero]\n    intro m hm\n    rw [degree_lt_iff_coeff_zero] at hm\n    simp [hm m le_rfl]\n  · rw [degree_le_iff_coeff_zero]\n    intro m hm\n    rw [degree_lt_iff_coeff_zero] at hm\n    refine h ?_\n    simpa using hm m le_rfl\n\n"}
{"name":"Polynomial.natDegree_smul_of_smul_regular","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝² : Semiring R\nS : Type u_1\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S R\nk : S\np : Polynomial R\nh : IsSMulRegular R k\n⊢ Eq (HSMul.hSMul k p).natDegree p.natDegree","decl":"theorem natDegree_smul_of_smul_regular {S : Type*} [Monoid S] [DistribMulAction S R] {k : S}\n    (p : R[X]) (h : IsSMulRegular R k) : (k • p).natDegree = p.natDegree := by\n  by_cases hp : p = 0\n  · simp [hp]\n  rw [← Nat.cast_inj (R := WithBot ℕ), ← degree_eq_natDegree hp, ← degree_eq_natDegree,\n    degree_smul_of_smul_regular p h]\n  contrapose! hp\n  rw [← smul_zero k] at hp\n  exact h.polynomial hp\n\n"}
{"name":"Polynomial.leadingCoeff_smul_of_smul_regular","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝² : Semiring R\nS : Type u_1\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S R\nk : S\np : Polynomial R\nh : IsSMulRegular R k\n⊢ Eq (HSMul.hSMul k p).leadingCoeff (HSMul.hSMul k p.leadingCoeff)","decl":"theorem leadingCoeff_smul_of_smul_regular {S : Type*} [Monoid S] [DistribMulAction S R] {k : S}\n    (p : R[X]) (h : IsSMulRegular R k) : (k • p).leadingCoeff = k • p.leadingCoeff := by\n  rw [Polynomial.leadingCoeff, Polynomial.leadingCoeff, coeff_smul,\n    natDegree_smul_of_smul_regular p h]\n\n"}
{"name":"Polynomial.monic_of_isUnit_leadingCoeff_inv_smul","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nh : IsUnit p.leadingCoeff\n⊢ (HSMul.hSMul (Inv.inv h.unit) p).Monic","decl":"theorem monic_of_isUnit_leadingCoeff_inv_smul (h : IsUnit p.leadingCoeff) :\n    Monic (h.unit⁻¹ • p) := by\n  rw [Monic.def, leadingCoeff_smul_of_smul_regular _ (isSMulRegular_of_group _), Units.smul_def]\n  obtain ⟨k, hk⟩ := h\n  simp only [← hk, smul_eq_mul, ← Units.val_mul, Units.val_eq_one, inv_mul_eq_iff_eq_mul]\n  simp [Units.ext_iff, IsUnit.unit_spec]\n\n"}
{"name":"Polynomial.isUnit_leadingCoeff_mul_right_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nh : IsUnit p.leadingCoeff\nq : Polynomial R\n⊢ Iff (Eq (HMul.hMul p q) 0) (Eq q 0)","decl":"theorem isUnit_leadingCoeff_mul_right_eq_zero_iff (h : IsUnit p.leadingCoeff) {q : R[X]} :\n    p * q = 0 ↔ q = 0 := by\n  constructor\n  · intro hp\n    rw [← smul_eq_zero_iff_eq h.unit⁻¹] at hp\n    have : h.unit⁻¹ • (p * q) = h.unit⁻¹ • p * q := by\n      ext\n      simp only [Units.smul_def, coeff_smul, coeff_mul, smul_eq_mul, mul_sum]\n      refine sum_congr rfl fun x _ => ?_\n      rw [← mul_assoc]\n    rwa [this, Monic.mul_right_eq_zero_iff] at hp\n    exact monic_of_isUnit_leadingCoeff_inv_smul _\n  · rintro rfl\n    simp\n\n"}
{"name":"Polynomial.isUnit_leadingCoeff_mul_left_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Monic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nh : IsUnit p.leadingCoeff\nq : Polynomial R\n⊢ Iff (Eq (HMul.hMul q p) 0) (Eq q 0)","decl":"theorem isUnit_leadingCoeff_mul_left_eq_zero_iff (h : IsUnit p.leadingCoeff) {q : R[X]} :\n    q * p = 0 ↔ q = 0 := by\n  constructor\n  · intro hp\n    replace hp := congr_arg (· * C ↑h.unit⁻¹) hp\n    simp only [zero_mul] at hp\n    rwa [mul_assoc, Monic.mul_left_eq_zero_iff] at hp\n    refine monic_mul_C_of_leadingCoeff_mul_eq_one ?_\n    simp [Units.mul_inv_eq_iff_eq_mul, IsUnit.unit_spec]\n  · rintro rfl\n    rw [zero_mul]\n\n"}
