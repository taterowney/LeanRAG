{"name":"Pi.toLex_apply","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\nx : (i : ι) → β i\ni : ι\n⊢ Eq (toLex x i) (x i)","decl":"@[simp]\ntheorem toLex_apply (x : ∀ i, β i) (i : ι) : toLex x i = x i :=\n  rfl\n\n"}
{"name":"Pi.ofLex_apply","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\nx : Lex ((i : ι) → β i)\ni : ι\n⊢ Eq (ofLex x i) (x i)","decl":"@[simp]\ntheorem ofLex_apply (x : Lex (∀ i, β i)) (i : ι) : ofLex x i = x i :=\n  rfl\n\n"}
{"name":"Pi.lex_lt_of_lt_of_preorder","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\ninst✝ : (i : ι) → Preorder (β i)\nr : ι → ι → Prop\nhwf : WellFounded r\nx y : (i : ι) → β i\nhlt : LT.lt x y\n⊢ Exists fun i => And (∀ (j : ι), r j i → And (LE.le (x j) (y j)) (LE.le (y j) (x j))) (LT.lt (x i) (y i))","decl":"theorem lex_lt_of_lt_of_preorder [∀ i, Preorder (β i)] {r} (hwf : WellFounded r) {x y : ∀ i, β i}\n    (hlt : x < y) : ∃ i, (∀ j, r j i → x j ≤ y j ∧ y j ≤ x j) ∧ x i < y i :=\n  let h' := Pi.lt_def.1 hlt\n  let ⟨i, hi, hl⟩ := hwf.has_min _ h'.2\n  ⟨i, fun j hj => ⟨h'.1 j, not_not.1 fun h => hl j (lt_of_le_not_le (h'.1 j) h) hj⟩, hi⟩\n\n"}
{"name":"Pi.lex_lt_of_lt","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\ninst✝ : (i : ι) → PartialOrder (β i)\nr : ι → ι → Prop\nhwf : WellFounded r\nx y : (i : ι) → β i\nhlt : LT.lt x y\n⊢ Pi.Lex r (fun x x1 x2 => LT.lt x1 x2) x y","decl":"theorem lex_lt_of_lt [∀ i, PartialOrder (β i)] {r} (hwf : WellFounded r) {x y : ∀ i, β i}\n    (hlt : x < y) : Pi.Lex r (@fun _ => (· < ·)) x y := by\n  simp_rw [Pi.Lex, le_antisymm_iff]\n  exact lex_lt_of_lt_of_preorder hwf hlt\n\n"}
{"name":"Pi.isTrichotomous_lex","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\nr : ι → ι → Prop\ns : {i : ι} → β i → β i → Prop\ninst✝ : ∀ (i : ι), IsTrichotomous (β i) s\nwf : WellFounded r\n⊢ IsTrichotomous ((i : ι) → β i) (Pi.Lex r s)","decl":"theorem isTrichotomous_lex [∀ i, IsTrichotomous (β i) s] (wf : WellFounded r) :\n    IsTrichotomous (∀ i, β i) (Pi.Lex r @s) :=\n  { trichotomous := fun a b => by\n      rcases eq_or_ne a b with hab | hab\n      · exact Or.inr (Or.inl hab)\n      · rw [Function.ne_iff] at hab\n        let i := wf.min _ hab\n        have hri : ∀ j, r j i → a j = b j := by\n          intro j\n          rw [← not_imp_not]\n          exact fun h' => wf.not_lt_min _ _ h'\n        have hne : a i ≠ b i := wf.min_mem _ hab\n        cases' trichotomous_of s (a i) (b i) with hi hi\n        exacts [Or.inl ⟨i, hri, hi⟩,\n          Or.inr <| Or.inr <| ⟨i, fun j hj => (hri j hj).symm, hi.resolve_left hne⟩] }\n\n"}
{"name":"Pi.Lex.isStrictOrder","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\ninst✝¹ : LinearOrder ι\ninst✝ : (a : ι) → PartialOrder (β a)\n⊢ IsStrictOrder (Lex ((i : ι) → β i)) fun x1 x2 => LT.lt x1 x2","decl":"instance Lex.isStrictOrder [LinearOrder ι] [∀ a, PartialOrder (β a)] :\n    IsStrictOrder (Lex (∀ i, β i)) (· < ·) where\n  irrefl := fun a ⟨k, _, hk₂⟩ => lt_irrefl (a k) hk₂\n  trans := by\n    rintro a b c ⟨N₁, lt_N₁, a_lt_b⟩ ⟨N₂, lt_N₂, b_lt_c⟩\n    rcases lt_trichotomy N₁ N₂ with (H | rfl | H)\n    exacts [⟨N₁, fun j hj => (lt_N₁ _ hj).trans (lt_N₂ _ <| hj.trans H), lt_N₂ _ H ▸ a_lt_b⟩,\n      ⟨N₁, fun j hj => (lt_N₁ _ hj).trans (lt_N₂ _ hj), a_lt_b.trans b_lt_c⟩,\n      ⟨N₂, fun j hj => (lt_N₁ _ (hj.trans H)).trans (lt_N₂ _ hj), (lt_N₁ _ H).symm ▸ b_lt_c⟩]\n\n"}
{"name":"Pi.toLex_monotone","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\ninst✝² : LinearOrder ι\ninst✝¹ : WellFoundedLT ι\ninst✝ : (i : ι) → PartialOrder (β i)\n⊢ Monotone ⇑toLex","decl":"theorem toLex_monotone : Monotone (@toLex (∀ i, β i)) := fun a b h =>\n  or_iff_not_imp_left.2 fun hne =>\n    let ⟨i, hi, hl⟩ := IsWellFounded.wf.has_min (r := (· < ·)) { i | a i ≠ b i }\n      (Function.ne_iff.1 hne)\n    ⟨i, fun j hj => by\n      contrapose! hl\n      exact ⟨j, hl, hj⟩, (h i).lt_of_ne hi⟩\n\n"}
{"name":"Pi.toLex_strictMono","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\ninst✝² : LinearOrder ι\ninst✝¹ : WellFoundedLT ι\ninst✝ : (i : ι) → PartialOrder (β i)\n⊢ StrictMono ⇑toLex","decl":"theorem toLex_strictMono : StrictMono (@toLex (∀ i, β i)) := fun a b h =>\n  let ⟨i, hi, hl⟩ := IsWellFounded.wf.has_min (r := (· < ·)) { i | a i ≠ b i }\n    (Function.ne_iff.1 h.ne)\n  ⟨i, fun j hj => by\n    contrapose! hl\n    exact ⟨j, hl, hj⟩, (h.le i).lt_of_ne hi⟩\n\n"}
{"name":"Pi.lt_toLex_update_self_iff","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\ninst✝² : LinearOrder ι\ninst✝¹ : WellFoundedLT ι\ninst✝ : (i : ι) → PartialOrder (β i)\nx : (i : ι) → β i\ni : ι\na : β i\n⊢ Iff (LT.lt (toLex x) (toLex (Function.update x i a))) (LT.lt (x i) a)","decl":"@[simp]\ntheorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) ↔ x i < a := by\n  refine ⟨?_, fun h => toLex_strictMono <| lt_update_self_iff.2 h⟩\n  rintro ⟨j, hj, h⟩\n  dsimp at h\n  obtain rfl : j = i := by\n    by_contra H\n    rw [update_of_ne H] at h\n    exact h.false\n  rwa [update_self] at h\n\n"}
{"name":"Pi.toLex_update_lt_self_iff","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\ninst✝² : LinearOrder ι\ninst✝¹ : WellFoundedLT ι\ninst✝ : (i : ι) → PartialOrder (β i)\nx : (i : ι) → β i\ni : ι\na : β i\n⊢ Iff (LT.lt (toLex (Function.update x i a)) (toLex x)) (LT.lt a (x i))","decl":"@[simp]\ntheorem toLex_update_lt_self_iff : toLex (update x i a) < toLex x ↔ a < x i := by\n  refine ⟨?_, fun h => toLex_strictMono <| update_lt_self_iff.2 h⟩\n  rintro ⟨j, hj, h⟩\n  dsimp at h\n  obtain rfl : j = i := by\n    by_contra H\n    rw [update_of_ne H] at h\n    exact h.false\n  rwa [update_self] at h\n\n"}
{"name":"Pi.le_toLex_update_self_iff","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\ninst✝² : LinearOrder ι\ninst✝¹ : WellFoundedLT ι\ninst✝ : (i : ι) → PartialOrder (β i)\nx : (i : ι) → β i\ni : ι\na : β i\n⊢ Iff (LE.le (toLex x) (toLex (Function.update x i a))) (LE.le (x i) a)","decl":"@[simp]\ntheorem le_toLex_update_self_iff : toLex x ≤ toLex (update x i a) ↔ x i ≤ a := by\n  simp_rw [le_iff_lt_or_eq, lt_toLex_update_self_iff, toLex_inj, eq_update_self_iff]\n\n"}
{"name":"Pi.toLex_update_le_self_iff","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\ninst✝² : LinearOrder ι\ninst✝¹ : WellFoundedLT ι\ninst✝ : (i : ι) → PartialOrder (β i)\nx : (i : ι) → β i\ni : ι\na : β i\n⊢ Iff (LE.le (toLex (Function.update x i a)) (toLex x)) (LE.le a (x i))","decl":"@[simp]\ntheorem toLex_update_le_self_iff : toLex (update x i a) ≤ toLex x ↔ a ≤ x i := by\n  simp_rw [le_iff_lt_or_eq, toLex_update_lt_self_iff, toLex_inj, update_eq_self_iff]\n\n"}
{"name":"Pi.instDenselyOrderedLexForall","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\ninst✝² : Preorder ι\ninst✝¹ : (i : ι) → LT (β i)\ninst✝ : ∀ (i : ι), DenselyOrdered (β i)\n⊢ DenselyOrdered (Lex ((i : ι) → β i))","decl":"instance [Preorder ι] [∀ i, LT (β i)] [∀ i, DenselyOrdered (β i)] :\n    DenselyOrdered (Lex (∀ i, β i)) :=\n  ⟨by\n    rintro _ a₂ ⟨i, h, hi⟩\n    obtain ⟨a, ha₁, ha₂⟩ := exists_between hi\n    classical\n      refine ⟨Function.update a₂ _ a, ⟨i, fun j hj => ?_, ?_⟩, i, fun j hj => ?_, ?_⟩\n      · rw [h j hj]\n        dsimp only at hj\n        rw [Function.update_of_ne hj.ne a]\n      · rwa [Function.update_self i a]\n      · rw [Function.update_of_ne hj.ne a]\n      · rwa [Function.update_self i a]⟩\n\n"}
{"name":"Pi.Lex.noMaxOrder'","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\ninst✝² : Preorder ι\ninst✝¹ : (i : ι) → LT (β i)\ni : ι\ninst✝ : NoMaxOrder (β i)\n⊢ NoMaxOrder (Lex ((i : ι) → β i))","decl":"theorem Lex.noMaxOrder' [Preorder ι] [∀ i, LT (β i)] (i : ι) [NoMaxOrder (β i)] :\n    NoMaxOrder (Lex (∀ i, β i)) :=\n  ⟨fun a => by\n    let ⟨b, hb⟩ := exists_gt (a i)\n    classical\n    exact ⟨Function.update a i b, i, fun j hj =>\n      (Function.update_of_ne hj.ne b a).symm, by rwa [Function.update_self i b]⟩⟩\n\n"}
{"name":"Pi.instNoMaxOrderLexForallOfWellFoundedLTOfNonempty","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\ninst✝⁴ : LinearOrder ι\ninst✝³ : WellFoundedLT ι\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → PartialOrder (β i)\ninst✝ : ∀ (i : ι), NoMaxOrder (β i)\n⊢ NoMaxOrder (Lex ((i : ι) → β i))","decl":"instance [LinearOrder ι] [WellFoundedLT ι] [Nonempty ι] [∀ i, PartialOrder (β i)]\n    [∀ i, NoMaxOrder (β i)] : NoMaxOrder (Lex (∀ i, β i)) :=\n  ⟨fun a =>\n    let ⟨_, hb⟩ := exists_gt (ofLex a)\n    ⟨_, toLex_strictMono hb⟩⟩\n\n"}
{"name":"Pi.instNoMinOrderLexForallOfWellFoundedLTOfNonempty","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nβ : ι → Type u_2\ninst✝⁴ : LinearOrder ι\ninst✝³ : WellFoundedLT ι\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → PartialOrder (β i)\ninst✝ : ∀ (i : ι), NoMinOrder (β i)\n⊢ NoMinOrder (Lex ((i : ι) → β i))","decl":"instance [LinearOrder ι] [WellFoundedLT ι] [Nonempty ι] [∀ i, PartialOrder (β i)]\n    [∀ i, NoMinOrder (β i)] : NoMinOrder (Lex (∀ i, β i)) :=\n  ⟨fun a =>\n    let ⟨_, hb⟩ := exists_lt (ofLex a)\n    ⟨_, toLex_strictMono hb⟩⟩\n\n"}
{"name":"Pi.lex_desc","module":"Mathlib.Order.PiLex","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝² : Preorder ι\ninst✝¹ : DecidableEq ι\ninst✝ : Preorder α\nf : ι → α\ni j : ι\nh₁ : LE.le i j\nh₂ : LT.lt (f j) (f i)\n⊢ LT.lt (toLex (Function.comp f ⇑(Equiv.swap i j))) (toLex f)","decl":"/-- If we swap two strictly decreasing values in a function, then the result is lexicographically\nsmaller than the original function. -/\ntheorem lex_desc {α} [Preorder ι] [DecidableEq ι] [Preorder α] {f : ι → α} {i j : ι} (h₁ : i ≤ j)\n    (h₂ : f j < f i) : toLex (f ∘ Equiv.swap i j) < toLex f :=\n  ⟨i, fun _ hik => congr_arg f (Equiv.swap_apply_of_ne_of_ne hik.ne (hik.trans_le h₁).ne), by\n    simpa only [Pi.toLex_apply, Function.comp_apply, Equiv.swap_apply_left] using h₂⟩\n\n"}
