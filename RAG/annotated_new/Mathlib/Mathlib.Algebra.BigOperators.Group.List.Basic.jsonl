{"name":"List.sum_eq_foldl","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl : List M\n⊢ Eq l.sum (List.foldl (fun x1 x2 => HAdd.hAdd x1 x2) 0 l)","decl":"@[to_additive]\ntheorem prod_eq_foldl : ∀ {l : List M}, l.prod = foldl (· * ·) 1 l\n  | [] => rfl\n  | cons a l => by\n    rw [prod_cons, prod_eq_foldl, ← foldl_assoc (α := M) (op := (· * ·))]\n    simp\n\n"}
{"name":"List.prod_eq_foldl","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List M\n⊢ Eq l.prod (List.foldl (fun x1 x2 => HMul.hMul x1 x2) 1 l)","decl":"@[to_additive]\ntheorem prod_eq_foldl : ∀ {l : List M}, l.prod = foldl (· * ·) 1 l\n  | [] => rfl\n  | cons a l => by\n    rw [prod_cons, prod_eq_foldl, ← foldl_assoc (α := M) (op := (· * ·))]\n    simp\n\n"}
{"name":"List.prod_append","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl₁ l₂ : List M\n⊢ Eq (HAppend.hAppend l₁ l₂).prod (HMul.hMul l₁.prod l₂.prod)","decl":"@[to_additive (attr := simp)]\ntheorem prod_append : (l₁ ++ l₂).prod = l₁.prod * l₂.prod :=\n  calc\n    (l₁ ++ l₂).prod = foldr (· * ·) (1 * foldr (· * ·) 1 l₂) l₁ := by simp [List.prod]\n    _ = l₁.prod * l₂.prod := foldr_assoc\n\n"}
{"name":"List.sum_append","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl₁ l₂ : List M\n⊢ Eq (HAppend.hAppend l₁ l₂).sum (HAdd.hAdd l₁.sum l₂.sum)","decl":"@[to_additive (attr := simp)]\ntheorem prod_append : (l₁ ++ l₂).prod = l₁.prod * l₂.prod :=\n  calc\n    (l₁ ++ l₂).prod = foldr (· * ·) (1 * foldr (· * ·) 1 l₂) l₁ := by simp [List.prod]\n    _ = l₁.prod * l₂.prod := foldr_assoc\n\n"}
{"name":"List.prod_concat","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List M\na : M\n⊢ Eq (l.concat a).prod (HMul.hMul l.prod a)","decl":"@[to_additive]\ntheorem prod_concat : (l.concat a).prod = l.prod * a := by\n  rw [concat_eq_append, prod_append, prod_singleton]\n\n"}
{"name":"List.sum_concat","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl : List M\na : M\n⊢ Eq (l.concat a).sum (HAdd.hAdd l.sum a)","decl":"@[to_additive]\ntheorem prod_concat : (l.concat a).prod = l.prod * a := by\n  rw [concat_eq_append, prod_append, prod_singleton]\n\n"}
{"name":"List.prod_flatten","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List (List M)\n⊢ Eq l.flatten.prod (List.map List.prod l).prod","decl":"@[to_additive (attr := simp)]\ntheorem prod_flatten {l : List (List M)} : l.flatten.prod = (l.map List.prod).prod := by\n  induction l with\n  | nil => simp\n  | cons head tail ih => simp only [*, List.flatten, map, prod_append, prod_cons]\n\n"}
{"name":"List.sum_flatten","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl : List (List M)\n⊢ Eq l.flatten.sum (List.map List.sum l).sum","decl":"@[to_additive (attr := simp)]\ntheorem prod_flatten {l : List (List M)} : l.flatten.prod = (l.map List.prod).prod := by\n  induction l with\n  | nil => simp\n  | cons head tail ih => simp only [*, List.flatten, map, prod_append, prod_cons]\n\n"}
{"name":"List.prod_join","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List (List M)\n⊢ Eq l.flatten.prod (List.map List.prod l).prod","decl":"@[deprecated (since := \"2024-10-15\")] alias prod_join := prod_flatten\n"}
{"name":"List.sum_join","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl : List (List M)\n⊢ Eq l.flatten.sum (List.map List.sum l).sum","decl":"@[deprecated (since := \"2024-10-15\")] alias sum_join := sum_flatten\n\n"}
{"name":"List.rel_prod","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nR : M → N → Prop\nh : R 1 1\nhf : Relator.LiftFun R (Relator.LiftFun R R) (fun x1 x2 => HMul.hMul x1 x2) fun x1 x2 => HMul.hMul x1 x2\n⊢ Relator.LiftFun (List.Forall₂ R) R List.prod List.prod","decl":"@[to_additive]\ntheorem rel_prod {R : M → N → Prop} (h : R 1 1) (hf : (R ⇒ R ⇒ R) (· * ·) (· * ·)) :\n    (Forall₂ R ⇒ R) prod prod :=\n  rel_foldr hf h\n\n"}
{"name":"List.rel_sum","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nR : M → N → Prop\nh : R 0 0\nhf : Relator.LiftFun R (Relator.LiftFun R R) (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => HAdd.hAdd x1 x2\n⊢ Relator.LiftFun (List.Forall₂ R) R List.sum List.sum","decl":"@[to_additive]\ntheorem rel_prod {R : M → N → Prop} (h : R 1 1) (hf : (R ⇒ R ⇒ R) (· * ·) (· * ·)) :\n    (Forall₂ R ⇒ R) prod prod :=\n  rel_foldr hf h\n\n"}
{"name":"List.sum_hom_nonempty","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝³ : AddMonoid M\ninst✝² : AddMonoid N\nl : List M\nF : Type u_8\ninst✝¹ : FunLike F M N\ninst✝ : AddHomClass F M N\nf : F\nhl : Ne l List.nil\n⊢ Eq (List.map (⇑f) l).sum (f l.sum)","decl":"@[to_additive]\ntheorem prod_hom_nonempty {l : List M} {F : Type*} [FunLike F M N] [MulHomClass F M N] (f : F)\n    (hl : l ≠ []) : (l.map f).prod = f l.prod :=\n  match l, hl with | x :: xs, hl => by induction xs generalizing x <;> aesop\n\n"}
{"name":"List.prod_hom_nonempty","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝³ : Monoid M\ninst✝² : Monoid N\nl : List M\nF : Type u_8\ninst✝¹ : FunLike F M N\ninst✝ : MulHomClass F M N\nf : F\nhl : Ne l List.nil\n⊢ Eq (List.map (⇑f) l).prod (f l.prod)","decl":"@[to_additive]\ntheorem prod_hom_nonempty {l : List M} {F : Type*} [FunLike F M N] [MulHomClass F M N] (f : F)\n    (hl : l ≠ []) : (l.map f).prod = f l.prod :=\n  match l, hl with | x :: xs, hl => by induction xs generalizing x <;> aesop\n\n"}
{"name":"List.prod_hom","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝³ : Monoid M\ninst✝² : Monoid N\nl : List M\nF : Type u_8\ninst✝¹ : FunLike F M N\ninst✝ : MonoidHomClass F M N\nf : F\n⊢ Eq (List.map (⇑f) l).prod (f l.prod)","decl":"@[to_additive]\ntheorem prod_hom (l : List M) {F : Type*} [FunLike F M N] [MonoidHomClass F M N] (f : F) :\n    (l.map f).prod = f l.prod := by\n  simp only [prod, foldr_map, ← map_one f]\n  exact l.foldr_hom f (· * ·) (f · * ·) 1 (fun x y => (map_mul f x y).symm)\n\n"}
{"name":"List.sum_hom","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝³ : AddMonoid M\ninst✝² : AddMonoid N\nl : List M\nF : Type u_8\ninst✝¹ : FunLike F M N\ninst✝ : AddMonoidHomClass F M N\nf : F\n⊢ Eq (List.map (⇑f) l).sum (f l.sum)","decl":"@[to_additive]\ntheorem prod_hom (l : List M) {F : Type*} [FunLike F M N] [MonoidHomClass F M N] (f : F) :\n    (l.map f).prod = f l.prod := by\n  simp only [prod, foldr_map, ← map_one f]\n  exact l.foldr_hom f (· * ·) (f · * ·) 1 (fun x y => (map_mul f x y).symm)\n\n"}
{"name":"List.prod_hom₂_nonempty","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Monoid M\ninst✝¹ : Monoid N\ninst✝ : Monoid P\nl : List ι\nf : M → N → P\nhf : ∀ (a b : M) (c d : N), Eq (f (HMul.hMul a b) (HMul.hMul c d)) (HMul.hMul (f a c) (f b d))\nf₁ : ι → M\nf₂ : ι → N\nhl : Ne l List.nil\n⊢ Eq (List.map (fun i => f (f₁ i) (f₂ i)) l).prod (f (List.map f₁ l).prod (List.map f₂ l).prod)","decl":"@[to_additive]\ntheorem prod_hom₂_nonempty {l : List ι} (f : M → N → P)\n    (hf : ∀ a b c d, f (a * b) (c * d) = f a c * f b d) (f₁ : ι → M) (f₂ : ι → N) (hl : l ≠ []) :\n    (l.map fun i => f (f₁ i) (f₂ i)).prod = f (l.map f₁).prod (l.map f₂).prod := by\n  match l, hl with | x :: xs, hl => induction xs generalizing x <;> aesop\n\n"}
{"name":"List.sum_hom₂_nonempty","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : AddMonoid M\ninst✝¹ : AddMonoid N\ninst✝ : AddMonoid P\nl : List ι\nf : M → N → P\nhf : ∀ (a b : M) (c d : N), Eq (f (HAdd.hAdd a b) (HAdd.hAdd c d)) (HAdd.hAdd (f a c) (f b d))\nf₁ : ι → M\nf₂ : ι → N\nhl : Ne l List.nil\n⊢ Eq (List.map (fun i => f (f₁ i) (f₂ i)) l).sum (f (List.map f₁ l).sum (List.map f₂ l).sum)","decl":"@[to_additive]\ntheorem prod_hom₂_nonempty {l : List ι} (f : M → N → P)\n    (hf : ∀ a b c d, f (a * b) (c * d) = f a c * f b d) (f₁ : ι → M) (f₂ : ι → N) (hl : l ≠ []) :\n    (l.map fun i => f (f₁ i) (f₂ i)).prod = f (l.map f₁).prod (l.map f₂).prod := by\n  match l, hl with | x :: xs, hl => induction xs generalizing x <;> aesop\n\n"}
{"name":"List.prod_hom₂","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Monoid M\ninst✝¹ : Monoid N\ninst✝ : Monoid P\nl : List ι\nf : M → N → P\nhf : ∀ (a b : M) (c d : N), Eq (f (HMul.hMul a b) (HMul.hMul c d)) (HMul.hMul (f a c) (f b d))\nhf' : Eq (f 1 1) 1\nf₁ : ι → M\nf₂ : ι → N\n⊢ Eq (List.map (fun i => f (f₁ i) (f₂ i)) l).prod (f (List.map f₁ l).prod (List.map f₂ l).prod)","decl":"@[to_additive]\ntheorem prod_hom₂ (l : List ι) (f : M → N → P) (hf : ∀ a b c d, f (a * b) (c * d) = f a c * f b d)\n    (hf' : f 1 1 = 1) (f₁ : ι → M) (f₂ : ι → N) :\n    (l.map fun i => f (f₁ i) (f₂ i)).prod = f (l.map f₁).prod (l.map f₂).prod := by\n  rw [prod, prod, prod, foldr_map, foldr_map, foldr_map,\n    ← l.foldr_hom₂ f _ _ (fun x y => f (f₁ x) (f₂ x) * y) _ _ (by simp [hf]), hf']\n\n"}
{"name":"List.sum_hom₂","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : AddMonoid M\ninst✝¹ : AddMonoid N\ninst✝ : AddMonoid P\nl : List ι\nf : M → N → P\nhf : ∀ (a b : M) (c d : N), Eq (f (HAdd.hAdd a b) (HAdd.hAdd c d)) (HAdd.hAdd (f a c) (f b d))\nhf' : Eq (f 0 0) 0\nf₁ : ι → M\nf₂ : ι → N\n⊢ Eq (List.map (fun i => f (f₁ i) (f₂ i)) l).sum (f (List.map f₁ l).sum (List.map f₂ l).sum)","decl":"@[to_additive]\ntheorem prod_hom₂ (l : List ι) (f : M → N → P) (hf : ∀ a b c d, f (a * b) (c * d) = f a c * f b d)\n    (hf' : f 1 1 = 1) (f₁ : ι → M) (f₂ : ι → N) :\n    (l.map fun i => f (f₁ i) (f₂ i)).prod = f (l.map f₁).prod (l.map f₂).prod := by\n  rw [prod, prod, prod, foldr_map, foldr_map, foldr_map,\n    ← l.foldr_hom₂ f _ _ (fun x y => f (f₁ x) (f₂ x) * y) _ _ (by simp [hf]), hf']\n\n"}
{"name":"List.sum_map_add","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"ι : Type u_1\nα : Type u_8\ninst✝ : AddCommMonoid α\nl : List ι\nf g : ι → α\n⊢ Eq (List.map (fun i => HAdd.hAdd (f i) (g i)) l).sum (HAdd.hAdd (List.map f l).sum (List.map g l).sum)","decl":"@[to_additive (attr := simp)]\ntheorem prod_map_mul {α : Type*} [CommMonoid α] {l : List ι} {f g : ι → α} :\n    (l.map fun i => f i * g i).prod = (l.map f).prod * (l.map g).prod :=\n  l.prod_hom₂ (· * ·) mul_mul_mul_comm (mul_one _) _ _\n\n"}
{"name":"List.prod_map_mul","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"ι : Type u_1\nα : Type u_8\ninst✝ : CommMonoid α\nl : List ι\nf g : ι → α\n⊢ Eq (List.map (fun i => HMul.hMul (f i) (g i)) l).prod (HMul.hMul (List.map f l).prod (List.map g l).prod)","decl":"@[to_additive (attr := simp)]\ntheorem prod_map_mul {α : Type*} [CommMonoid α] {l : List ι} {f g : ι → α} :\n    (l.map fun i => f i * g i).prod = (l.map f).prod * (l.map g).prod :=\n  l.prod_hom₂ (· * ·) mul_mul_mul_comm (mul_one _) _ _\n\n"}
{"name":"List.sum_map_hom","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝³ : AddMonoid M\ninst✝² : AddMonoid N\nL : List ι\nf : ι → M\nG : Type u_8\ninst✝¹ : FunLike G M N\ninst✝ : AddMonoidHomClass G M N\ng : G\n⊢ Eq (List.map (Function.comp (⇑g) f) L).sum (g (List.map f L).sum)","decl":"@[to_additive]\ntheorem prod_map_hom (L : List ι) (f : ι → M) {G : Type*} [FunLike G M N] [MonoidHomClass G M N]\n    (g : G) :\n    (L.map (g ∘ f)).prod = g (L.map f).prod := by rw [← prod_hom, map_map]\n\n"}
{"name":"List.prod_map_hom","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"ι : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝³ : Monoid M\ninst✝² : Monoid N\nL : List ι\nf : ι → M\nG : Type u_8\ninst✝¹ : FunLike G M N\ninst✝ : MonoidHomClass G M N\ng : G\n⊢ Eq (List.map (Function.comp (⇑g) f) L).prod (g (List.map f L).prod)","decl":"@[to_additive]\ntheorem prod_map_hom (L : List ι) (f : ι → M) {G : Type*} [FunLike G M N] [MonoidHomClass G M N]\n    (g : G) :\n    (L.map (g ∘ f)).prod = g (L.map f).prod := by rw [← prod_hom, map_map]\n\n"}
{"name":"List.prod_take_mul_prod_drop","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nL : List M\ni : Nat\n⊢ Eq (HMul.hMul (List.take i L).prod (List.drop i L).prod) L.prod","decl":"@[to_additive (attr := simp)]\ntheorem prod_take_mul_prod_drop (L : List M) (i : ℕ) :\n    (L.take i).prod * (L.drop i).prod = L.prod := by\n  simp [← prod_append]\n\n"}
{"name":"List.sum_take_add_sum_drop","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nL : List M\ni : Nat\n⊢ Eq (HAdd.hAdd (List.take i L).sum (List.drop i L).sum) L.sum","decl":"@[to_additive (attr := simp)]\ntheorem prod_take_mul_prod_drop (L : List M) (i : ℕ) :\n    (L.take i).prod * (L.drop i).prod = L.prod := by\n  simp [← prod_append]\n\n"}
{"name":"List.sum_take_succ","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nL : List M\ni : Nat\np : LT.lt i L.length\n⊢ Eq (List.take (HAdd.hAdd i 1) L).sum (HAdd.hAdd (List.take i L).sum (GetElem.getElem L i ⋯))","decl":"@[to_additive (attr := simp)]\ntheorem prod_take_succ (L : List M) (i : ℕ) (p : i < L.length) :\n    (L.take (i + 1)).prod = (L.take i).prod * L[i] := by\n  rw [← take_concat_get' _ _ p, prod_append]\n  simp\n\n"}
{"name":"List.prod_take_succ","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nL : List M\ni : Nat\np : LT.lt i L.length\n⊢ Eq (List.take (HAdd.hAdd i 1) L).prod (HMul.hMul (List.take i L).prod (GetElem.getElem L i ⋯))","decl":"@[to_additive (attr := simp)]\ntheorem prod_take_succ (L : List M) (i : ℕ) (p : i < L.length) :\n    (L.take (i + 1)).prod = (L.take i).prod * L[i] := by\n  rw [← take_concat_get' _ _ p, prod_append]\n  simp\n\n"}
{"name":"List.length_pos_of_prod_ne_one","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nL : List M\nh : Ne L.prod 1\n⊢ LT.lt 0 L.length","decl":"/-- A list with product not one must have positive length. -/\n@[to_additive \"A list with sum not zero must have positive length.\"]\ntheorem length_pos_of_prod_ne_one (L : List M) (h : L.prod ≠ 1) : 0 < L.length := by\n  cases L\n  · simp at h\n  · simp\n\n"}
{"name":"List.length_pos_of_sum_ne_zero","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nL : List M\nh : Ne L.sum 0\n⊢ LT.lt 0 L.length","decl":"/-- A list with product not one must have positive length. -/\n@[to_additive \"A list with sum not zero must have positive length.\"]\ntheorem length_pos_of_prod_ne_one (L : List M) (h : L.prod ≠ 1) : 0 < L.length := by\n  cases L\n  · simp at h\n  · simp\n\n"}
{"name":"List.length_pos_of_one_lt_prod","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝¹ : Monoid M\ninst✝ : Preorder M\nL : List M\nh : LT.lt 1 L.prod\n⊢ LT.lt 0 L.length","decl":"/-- A list with product greater than one must have positive length. -/\n@[to_additive length_pos_of_sum_pos \"A list with positive sum must have positive length.\"]\ntheorem length_pos_of_one_lt_prod [Preorder M] (L : List M) (h : 1 < L.prod) : 0 < L.length :=\n  length_pos_of_prod_ne_one L h.ne'\n\n"}
{"name":"List.length_pos_of_sum_pos","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝¹ : AddMonoid M\ninst✝ : Preorder M\nL : List M\nh : LT.lt 0 L.sum\n⊢ LT.lt 0 L.length","decl":"/-- A list with product greater than one must have positive length. -/\n@[to_additive length_pos_of_sum_pos \"A list with positive sum must have positive length.\"]\ntheorem length_pos_of_one_lt_prod [Preorder M] (L : List M) (h : 1 < L.prod) : 0 < L.length :=\n  length_pos_of_prod_ne_one L h.ne'\n\n"}
{"name":"List.length_pos_of_prod_lt_one","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝¹ : Monoid M\ninst✝ : Preorder M\nL : List M\nh : LT.lt L.prod 1\n⊢ LT.lt 0 L.length","decl":"/-- A list with product less than one must have positive length. -/\n@[to_additive \"A list with negative sum must have positive length.\"]\ntheorem length_pos_of_prod_lt_one [Preorder M] (L : List M) (h : L.prod < 1) : 0 < L.length :=\n  length_pos_of_prod_ne_one L h.ne\n\n"}
{"name":"List.length_pos_of_sum_neg","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝¹ : AddMonoid M\ninst✝ : Preorder M\nL : List M\nh : LT.lt L.sum 0\n⊢ LT.lt 0 L.length","decl":"/-- A list with product less than one must have positive length. -/\n@[to_additive \"A list with negative sum must have positive length.\"]\ntheorem length_pos_of_prod_lt_one [Preorder M] (L : List M) (h : L.prod < 1) : 0 < L.length :=\n  length_pos_of_prod_ne_one L h.ne\n\n"}
{"name":"List.prod_set","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nL : List M\nn : Nat\na : M\n⊢ Eq (L.set n a).prod (HMul.hMul (HMul.hMul (List.take n L).prod (ite (LT.lt n L.length) a 1)) (List.drop (HAdd.hAdd n 1) L).prod)","decl":"@[to_additive]\ntheorem prod_set :\n    ∀ (L : List M) (n : ℕ) (a : M),\n      (L.set n a).prod =\n        ((L.take n).prod * if n < L.length then a else 1) * (L.drop (n + 1)).prod\n  | x :: xs, 0, a => by simp [set]\n  | x :: xs, i + 1, a => by\n    simp [set, prod_set xs i a, mul_assoc, Nat.add_lt_add_iff_right]\n  | [], _, _ => by simp [set, (Nat.zero_le _).not_lt, Nat.zero_le]\n\n"}
{"name":"List.sum_set","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nL : List M\nn : Nat\na : M\n⊢ Eq (L.set n a).sum (HAdd.hAdd (HAdd.hAdd (List.take n L).sum (ite (LT.lt n L.length) a 0)) (List.drop (HAdd.hAdd n 1) L).sum)","decl":"@[to_additive]\ntheorem prod_set :\n    ∀ (L : List M) (n : ℕ) (a : M),\n      (L.set n a).prod =\n        ((L.take n).prod * if n < L.length then a else 1) * (L.drop (n + 1)).prod\n  | x :: xs, 0, a => by simp [set]\n  | x :: xs, i + 1, a => by\n    simp [set, prod_set xs i a, mul_assoc, Nat.add_lt_add_iff_right]\n  | [], _, _ => by simp [set, (Nat.zero_le _).not_lt, Nat.zero_le]\n\n"}
{"name":"List.get?_zero_add_tail_sum","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl : List M\n⊢ Eq (HAdd.hAdd ((l.get? 0).getD 0) l.tail.sum) l.sum","decl":"/-- We'd like to state this as `L.headI * L.tail.prod = L.prod`, but because `L.headI` relies on an\ninhabited instance to return a garbage value on the empty list, this is not possible.\nInstead, we write the statement in terms of `(L.get? 0).getD 1`.\n-/\n@[to_additive \"We'd like to state this as `L.headI + L.tail.sum = L.sum`, but because `L.headI`\n  relies on an inhabited instance to return a garbage value on the empty list, this is not possible.\n  Instead, we write the statement in terms of `(L.get? 0).getD 0`.\"]\ntheorem get?_zero_mul_tail_prod (l : List M) : (l.get? 0).getD 1 * l.tail.prod = l.prod := by\n  cases l <;> simp\n\n"}
{"name":"List.get?_zero_mul_tail_prod","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List M\n⊢ Eq (HMul.hMul ((l.get? 0).getD 1) l.tail.prod) l.prod","decl":"/-- We'd like to state this as `L.headI * L.tail.prod = L.prod`, but because `L.headI` relies on an\ninhabited instance to return a garbage value on the empty list, this is not possible.\nInstead, we write the statement in terms of `(L.get? 0).getD 1`.\n-/\n@[to_additive \"We'd like to state this as `L.headI + L.tail.sum = L.sum`, but because `L.headI`\n  relies on an inhabited instance to return a garbage value on the empty list, this is not possible.\n  Instead, we write the statement in terms of `(L.get? 0).getD 0`.\"]\ntheorem get?_zero_mul_tail_prod (l : List M) : (l.get? 0).getD 1 * l.tail.prod = l.prod := by\n  cases l <;> simp\n\n"}
{"name":"List.headI_mul_tail_prod_of_ne_nil","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝¹ : Monoid M\ninst✝ : Inhabited M\nl : List M\nh : Ne l List.nil\n⊢ Eq (HMul.hMul l.headI l.tail.prod) l.prod","decl":"/-- Same as `get?_zero_mul_tail_prod`, but avoiding the `List.headI` garbage complication by\n  requiring the list to be nonempty. -/\n@[to_additive \"Same as `get?_zero_add_tail_sum`, but avoiding the `List.headI` garbage complication\n  by requiring the list to be nonempty.\"]\ntheorem headI_mul_tail_prod_of_ne_nil [Inhabited M] (l : List M) (h : l ≠ []) :\n    l.headI * l.tail.prod = l.prod := by cases l <;> [contradiction; simp]\n\n"}
{"name":"List.headI_add_tail_sum_of_ne_nil","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝¹ : AddMonoid M\ninst✝ : Inhabited M\nl : List M\nh : Ne l List.nil\n⊢ Eq (HAdd.hAdd l.headI l.tail.sum) l.sum","decl":"/-- Same as `get?_zero_mul_tail_prod`, but avoiding the `List.headI` garbage complication by\n  requiring the list to be nonempty. -/\n@[to_additive \"Same as `get?_zero_add_tail_sum`, but avoiding the `List.headI` garbage complication\n  by requiring the list to be nonempty.\"]\ntheorem headI_mul_tail_prod_of_ne_nil [Inhabited M] (l : List M) (h : l ≠ []) :\n    l.headI * l.tail.prod = l.prod := by cases l <;> [contradiction; simp]\n\n"}
{"name":"AddCommute.list_sum_right","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl : List M\ny : M\nh : ∀ (x : M), Membership.mem l x → AddCommute y x\n⊢ AddCommute y l.sum","decl":"@[to_additive]\ntheorem _root_.Commute.list_prod_right (l : List M) (y : M) (h : ∀ x ∈ l, Commute y x) :\n    Commute y l.prod := by\n  induction l with\n  | nil => simp\n  | cons z l IH =>\n    rw [List.forall_mem_cons] at h\n    rw [List.prod_cons]\n    exact Commute.mul_right h.1 (IH h.2)\n\n"}
{"name":"Commute.list_prod_right","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List M\ny : M\nh : ∀ (x : M), Membership.mem l x → Commute y x\n⊢ Commute y l.prod","decl":"@[to_additive]\ntheorem _root_.Commute.list_prod_right (l : List M) (y : M) (h : ∀ x ∈ l, Commute y x) :\n    Commute y l.prod := by\n  induction l with\n  | nil => simp\n  | cons z l IH =>\n    rw [List.forall_mem_cons] at h\n    rw [List.prod_cons]\n    exact Commute.mul_right h.1 (IH h.2)\n\n"}
{"name":"Commute.list_prod_left","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List M\ny : M\nh : ∀ (x : M), Membership.mem l x → Commute x y\n⊢ Commute l.prod y","decl":"@[to_additive]\ntheorem _root_.Commute.list_prod_left (l : List M) (y : M) (h : ∀ x ∈ l, Commute x y) :\n    Commute l.prod y :=\n  ((Commute.list_prod_right _ _) fun _ hx => (h _ hx).symm).symm\n\n"}
{"name":"AddCommute.list_sum_left","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl : List M\ny : M\nh : ∀ (x : M), Membership.mem l x → AddCommute x y\n⊢ AddCommute l.sum y","decl":"@[to_additive]\ntheorem _root_.Commute.list_prod_left (l : List M) (y : M) (h : ∀ x ∈ l, Commute x y) :\n    Commute l.prod y :=\n  ((Commute.list_prod_right _ _) fun _ hx => (h _ hx).symm).symm\n\n"}
{"name":"List.prod_range_succ","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nf : Nat → M\nn : Nat\n⊢ Eq (List.map f (List.range n.succ)).prod (HMul.hMul (List.map f (List.range n)).prod (f n))","decl":"@[to_additive] lemma prod_range_succ (f : ℕ → M) (n : ℕ) :\n    ((range n.succ).map f).prod = ((range n).map f).prod * f n := by\n  rw [range_succ, map_append, map_singleton, prod_append, prod_cons, prod_nil, mul_one]\n\n"}
{"name":"List.sum_range_succ","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nf : Nat → M\nn : Nat\n⊢ Eq (List.map f (List.range n.succ)).sum (HAdd.hAdd (List.map f (List.range n)).sum (f n))","decl":"@[to_additive] lemma prod_range_succ (f : ℕ → M) (n : ℕ) :\n    ((range n.succ).map f).prod = ((range n).map f).prod * f n := by\n  rw [range_succ, map_append, map_singleton, prod_append, prod_cons, prod_nil, mul_one]\n\n"}
{"name":"List.sum_range_succ'","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nf : Nat → M\nn : Nat\n⊢ Eq (List.map f (List.range n.succ)).sum (HAdd.hAdd (f 0) (List.map (fun i => f i.succ) (List.range n)).sum)","decl":"/-- A variant of `prod_range_succ` which pulls off the first term in the product rather than the\nlast. -/\n@[to_additive\n\"A variant of `sum_range_succ` which pulls off the first term in the sum rather than the last.\"]\nlemma prod_range_succ' (f : ℕ → M) (n : ℕ) :\n    ((range n.succ).map f).prod = f 0 * ((range n).map fun i ↦ f i.succ).prod := by\n  rw [range_succ_eq_map]\n  simp [Function.comp_def]\n\n"}
{"name":"List.prod_range_succ'","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nf : Nat → M\nn : Nat\n⊢ Eq (List.map f (List.range n.succ)).prod (HMul.hMul (f 0) (List.map (fun i => f i.succ) (List.range n)).prod)","decl":"/-- A variant of `prod_range_succ` which pulls off the first term in the product rather than the\nlast. -/\n@[to_additive\n\"A variant of `sum_range_succ` which pulls off the first term in the sum rather than the last.\"]\nlemma prod_range_succ' (f : ℕ → M) (n : ℕ) :\n    ((range n.succ).map f).prod = f 0 * ((range n).map fun i ↦ f i.succ).prod := by\n  rw [range_succ_eq_map]\n  simp [Function.comp_def]\n\n"}
{"name":"List.prod_eq_one","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List M\nhl : ∀ (x : M), Membership.mem l x → Eq x 1\n⊢ Eq l.prod 1","decl":"@[to_additive] lemma prod_eq_one (hl : ∀ x ∈ l, x = 1) : l.prod = 1 := by\n  induction l with\n  | nil => rfl\n  | cons i l hil =>\n    rw [List.prod_cons, hil fun x hx ↦ hl _ (mem_cons_of_mem i hx),\n      hl _ (mem_cons_self i l), one_mul]\n\n"}
{"name":"List.sum_eq_zero","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl : List M\nhl : ∀ (x : M), Membership.mem l x → Eq x 0\n⊢ Eq l.sum 0","decl":"@[to_additive] lemma prod_eq_one (hl : ∀ x ∈ l, x = 1) : l.prod = 1 := by\n  induction l with\n  | nil => rfl\n  | cons i l hil =>\n    rw [List.prod_cons, hil fun x hx ↦ hl _ (mem_cons_of_mem i hx),\n      hl _ (mem_cons_self i l), one_mul]\n\n"}
{"name":"List.exists_mem_ne_one_of_prod_ne_one","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List M\nh : Ne l.prod 1\n⊢ Exists fun x => And (Membership.mem l x) (Ne x 1)","decl":"@[to_additive] lemma exists_mem_ne_one_of_prod_ne_one (h : l.prod ≠ 1) :\n    ∃ x ∈ l, x ≠ (1 : M) := by simpa only [not_forall, exists_prop] using mt prod_eq_one h\n\n"}
{"name":"List.exists_mem_ne_zero_of_sum_ne_zero","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl : List M\nh : Ne l.sum 0\n⊢ Exists fun x => And (Membership.mem l x) (Ne x 0)","decl":"@[to_additive] lemma exists_mem_ne_one_of_prod_ne_one (h : l.prod ≠ 1) :\n    ∃ x ∈ l, x ≠ (1 : M) := by simpa only [not_forall, exists_prop] using mt prod_eq_one h\n\n"}
{"name":"List.prod_erase_of_comm","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝¹ : Monoid M\nl : List M\na : M\ninst✝ : DecidableEq M\nha : Membership.mem l a\ncomm : ∀ (x : M), Membership.mem l x → ∀ (y : M), Membership.mem l y → Eq (HMul.hMul x y) (HMul.hMul y x)\n⊢ Eq (HMul.hMul a (l.erase a).prod) l.prod","decl":"@[to_additive]\nlemma prod_erase_of_comm [DecidableEq M] (ha : a ∈ l) (comm : ∀ x ∈ l, ∀ y ∈ l, x * y = y * x) :\n    a * (l.erase a).prod = l.prod := by\n  induction l with\n  | nil => simp only [not_mem_nil] at ha\n  | cons b l ih =>\n    obtain rfl | ⟨ne, h⟩ := List.eq_or_ne_mem_of_mem ha\n    · simp only [erase_cons_head, prod_cons]\n    rw [List.erase, beq_false_of_ne ne.symm, List.prod_cons, List.prod_cons, ← mul_assoc,\n      comm a ha b (l.mem_cons_self b), mul_assoc,\n      ih h fun x hx y hy ↦ comm _ (List.mem_cons_of_mem b hx) _ (List.mem_cons_of_mem b hy)]\n\n"}
{"name":"List.sum_erase_of_comm","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝¹ : AddMonoid M\nl : List M\na : M\ninst✝ : DecidableEq M\nha : Membership.mem l a\ncomm : ∀ (x : M), Membership.mem l x → ∀ (y : M), Membership.mem l y → Eq (HAdd.hAdd x y) (HAdd.hAdd y x)\n⊢ Eq (HAdd.hAdd a (l.erase a).sum) l.sum","decl":"@[to_additive]\nlemma prod_erase_of_comm [DecidableEq M] (ha : a ∈ l) (comm : ∀ x ∈ l, ∀ y ∈ l, x * y = y * x) :\n    a * (l.erase a).prod = l.prod := by\n  induction l with\n  | nil => simp only [not_mem_nil] at ha\n  | cons b l ih =>\n    obtain rfl | ⟨ne, h⟩ := List.eq_or_ne_mem_of_mem ha\n    · simp only [erase_cons_head, prod_cons]\n    rw [List.erase, beq_false_of_ne ne.symm, List.prod_cons, List.prod_cons, ← mul_assoc,\n      comm a ha b (l.mem_cons_self b), mul_assoc,\n      ih h fun x hx y hy ↦ comm _ (List.mem_cons_of_mem b hx) _ (List.mem_cons_of_mem b hy)]\n\n"}
{"name":"List.sum_map_eq_nsmul_single","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\nM : Type u_4\ninst✝¹ : AddMonoid M\ninst✝ : DecidableEq α\nl : List α\na : α\nf : α → M\nhf : ∀ (a' : α), Ne a' a → Membership.mem l a' → Eq (f a') 0\n⊢ Eq (List.map f l).sum (HSMul.hSMul (List.count a l) (f a))","decl":"@[to_additive]\nlemma prod_map_eq_pow_single [DecidableEq α] {l : List α} (a : α) (f : α → M)\n    (hf : ∀ a', a' ≠ a → a' ∈ l → f a' = 1) : (l.map f).prod = f a ^ l.count a := by\n  induction l generalizing a with\n  | nil => rw [map_nil, prod_nil, count_nil, _root_.pow_zero]\n  | cons a' as h =>\n    specialize h a fun a' ha' hfa' => hf a' ha' (mem_cons_of_mem _ hfa')\n    rw [List.map_cons, List.prod_cons, count_cons, h]\n    simp only [beq_iff_eq]\n    split_ifs with ha'\n    · rw [ha', _root_.pow_succ']\n    · rw [hf a' ha' (List.mem_cons_self a' as), one_mul, add_zero]\n\n"}
{"name":"List.prod_map_eq_pow_single","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\nM : Type u_4\ninst✝¹ : Monoid M\ninst✝ : DecidableEq α\nl : List α\na : α\nf : α → M\nhf : ∀ (a' : α), Ne a' a → Membership.mem l a' → Eq (f a') 1\n⊢ Eq (List.map f l).prod (HPow.hPow (f a) (List.count a l))","decl":"@[to_additive]\nlemma prod_map_eq_pow_single [DecidableEq α] {l : List α} (a : α) (f : α → M)\n    (hf : ∀ a', a' ≠ a → a' ∈ l → f a' = 1) : (l.map f).prod = f a ^ l.count a := by\n  induction l generalizing a with\n  | nil => rw [map_nil, prod_nil, count_nil, _root_.pow_zero]\n  | cons a' as h =>\n    specialize h a fun a' ha' hfa' => hf a' ha' (mem_cons_of_mem _ hfa')\n    rw [List.map_cons, List.prod_cons, count_cons, h]\n    simp only [beq_iff_eq]\n    split_ifs with ha'\n    · rw [ha', _root_.pow_succ']\n    · rw [hf a' ha' (List.mem_cons_self a' as), one_mul, add_zero]\n\n"}
{"name":"List.prod_eq_pow_single","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝¹ : Monoid M\nl : List M\ninst✝ : DecidableEq M\na : M\nh : ∀ (a' : M), Ne a' a → Membership.mem l a' → Eq a' 1\n⊢ Eq l.prod (HPow.hPow a (List.count a l))","decl":"@[to_additive]\nlemma prod_eq_pow_single [DecidableEq M] (a : M) (h : ∀ a', a' ≠ a → a' ∈ l → a' = 1) :\n    l.prod = a ^ l.count a :=\n  _root_.trans (by rw [map_id]) (prod_map_eq_pow_single a id h)\n\n"}
{"name":"List.sum_eq_nsmul_single","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝¹ : AddMonoid M\nl : List M\ninst✝ : DecidableEq M\na : M\nh : ∀ (a' : M), Ne a' a → Membership.mem l a' → Eq a' 0\n⊢ Eq l.sum (HSMul.hSMul (List.count a l) a)","decl":"@[to_additive]\nlemma prod_eq_pow_single [DecidableEq M] (a : M) (h : ∀ a', a' ≠ a → a' ∈ l → a' = 1) :\n    l.prod = a ^ l.count a :=\n  _root_.trans (by rw [map_id]) (prod_map_eq_pow_single a id h)\n\n"}
{"name":"List.prod_erase","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝¹ : CommMonoid M\na : M\nl : List M\ninst✝ : DecidableEq M\nha : Membership.mem l a\n⊢ Eq (HMul.hMul a (l.erase a).prod) l.prod","decl":"@[to_additive (attr := simp)]\nlemma prod_erase [DecidableEq M] (ha : a ∈ l) : a * (l.erase a).prod = l.prod :=\n  prod_erase_of_comm ha fun x _ y _ ↦ mul_comm x y\n\n"}
{"name":"List.sum_erase","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝¹ : AddCommMonoid M\na : M\nl : List M\ninst✝ : DecidableEq M\nha : Membership.mem l a\n⊢ Eq (HAdd.hAdd a (l.erase a).sum) l.sum","decl":"@[to_additive (attr := simp)]\nlemma prod_erase [DecidableEq M] (ha : a ∈ l) : a * (l.erase a).prod = l.prod :=\n  prod_erase_of_comm ha fun x _ y _ ↦ mul_comm x y\n\n"}
{"name":"List.sum_map_erase","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : DecidableEq α\nf : α → M\na : α\nl : List α\na✝ : Membership.mem l a\n⊢ Eq (HAdd.hAdd (f a) (List.map f (l.erase a)).sum) (List.map f l).sum","decl":"@[to_additive (attr := simp)]\nlemma prod_map_erase [DecidableEq α] (f : α → M) {a} :\n    ∀ {l : List α}, a ∈ l → f a * ((l.erase a).map f).prod = (l.map f).prod\n  | b :: l, h => by\n    obtain rfl | ⟨ne, h⟩ := List.eq_or_ne_mem_of_mem h\n    · simp only [map, erase_cons_head, prod_cons]\n    · simp only [map, erase_cons_tail (not_beq_of_ne ne.symm), prod_cons, prod_map_erase _ h,\n        mul_left_comm (f a) (f b)]\n\n"}
{"name":"List.prod_map_erase","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\nM : Type u_4\ninst✝¹ : CommMonoid M\ninst✝ : DecidableEq α\nf : α → M\na : α\nl : List α\na✝ : Membership.mem l a\n⊢ Eq (HMul.hMul (f a) (List.map f (l.erase a)).prod) (List.map f l).prod","decl":"@[to_additive (attr := simp)]\nlemma prod_map_erase [DecidableEq α] (f : α → M) {a} :\n    ∀ {l : List α}, a ∈ l → f a * ((l.erase a).map f).prod = (l.map f).prod\n  | b :: l, h => by\n    obtain rfl | ⟨ne, h⟩ := List.eq_or_ne_mem_of_mem h\n    · simp only [map, erase_cons_head, prod_cons]\n    · simp only [map, erase_cons_tail (not_beq_of_ne ne.symm), prod_cons, prod_map_erase _ h,\n        mul_left_comm (f a) (f b)]\n\n"}
{"name":"List.Perm.sum_eq","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddCommMonoid M\nl₁ l₂ : List M\nh : l₁.Perm l₂\n⊢ Eq l₁.sum l₂.sum","decl":"@[to_additive] lemma Perm.prod_eq (h : Perm l₁ l₂) : prod l₁ = prod l₂ := h.foldr_op_eq\n\n"}
{"name":"List.Perm.prod_eq","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : CommMonoid M\nl₁ l₂ : List M\nh : l₁.Perm l₂\n⊢ Eq l₁.prod l₂.prod","decl":"@[to_additive] lemma Perm.prod_eq (h : Perm l₁ l₂) : prod l₁ = prod l₂ := h.foldr_op_eq\n\n"}
{"name":"List.prod_reverse","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : CommMonoid M\nl : List M\n⊢ Eq l.reverse.prod l.prod","decl":"@[to_additive] lemma prod_reverse (l : List M) : prod l.reverse = prod l := (reverse_perm l).prod_eq\n\n"}
{"name":"List.sum_reverse","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddCommMonoid M\nl : List M\n⊢ Eq l.reverse.sum l.sum","decl":"@[to_additive] lemma prod_reverse (l : List M) : prod l.reverse = prod l := (reverse_perm l).prod_eq\n\n"}
{"name":"List.prod_mul_prod_eq_prod_zipWith_mul_prod_drop","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : CommMonoid M\nl l' : List M\n⊢ Eq (HMul.hMul l.prod l'.prod) (HMul.hMul (HMul.hMul (List.zipWith (fun x1 x2 => HMul.hMul x1 x2) l l').prod (List.drop l'.length l).prod) (List.drop l.length l').prod)","decl":"@[to_additive]\nlemma prod_mul_prod_eq_prod_zipWith_mul_prod_drop :\n    ∀ l l' : List M,\n      l.prod * l'.prod =\n        (zipWith (· * ·) l l').prod * (l.drop l'.length).prod * (l'.drop l.length).prod\n  | [], ys => by simp [Nat.zero_le]\n  | xs, [] => by simp [Nat.zero_le]\n  | x :: xs, y :: ys => by\n    simp only [drop, length, zipWith_cons_cons, prod_cons]\n    conv =>\n      lhs; rw [mul_assoc]; right; rw [mul_comm, mul_assoc]; right\n      rw [mul_comm, prod_mul_prod_eq_prod_zipWith_mul_prod_drop xs ys]\n    simp [mul_assoc]\n\n"}
{"name":"List.sum_add_sum_eq_sum_zipWith_add_sum_drop","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddCommMonoid M\nl l' : List M\n⊢ Eq (HAdd.hAdd l.sum l'.sum) (HAdd.hAdd (HAdd.hAdd (List.zipWith (fun x1 x2 => HAdd.hAdd x1 x2) l l').sum (List.drop l'.length l).sum) (List.drop l.length l').sum)","decl":"@[to_additive]\nlemma prod_mul_prod_eq_prod_zipWith_mul_prod_drop :\n    ∀ l l' : List M,\n      l.prod * l'.prod =\n        (zipWith (· * ·) l l').prod * (l.drop l'.length).prod * (l'.drop l.length).prod\n  | [], ys => by simp [Nat.zero_le]\n  | xs, [] => by simp [Nat.zero_le]\n  | x :: xs, y :: ys => by\n    simp only [drop, length, zipWith_cons_cons, prod_cons]\n    conv =>\n      lhs; rw [mul_assoc]; right; rw [mul_comm, mul_assoc]; right\n      rw [mul_comm, prod_mul_prod_eq_prod_zipWith_mul_prod_drop xs ys]\n    simp [mul_assoc]\n\n"}
{"name":"List.sum_add_sum_eq_sum_zipWith_of_length_eq","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddCommMonoid M\nl l' : List M\nh : Eq l.length l'.length\n⊢ Eq (HAdd.hAdd l.sum l'.sum) (List.zipWith (fun x1 x2 => HAdd.hAdd x1 x2) l l').sum","decl":"@[to_additive]\nlemma prod_mul_prod_eq_prod_zipWith_of_length_eq (l l' : List M) (h : l.length = l'.length) :\n    l.prod * l'.prod = (zipWith (· * ·) l l').prod := by\n  apply (prod_mul_prod_eq_prod_zipWith_mul_prod_drop l l').trans\n  rw [← h, drop_length, h, drop_length, prod_nil, mul_one, mul_one]\n\n"}
{"name":"List.prod_mul_prod_eq_prod_zipWith_of_length_eq","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : CommMonoid M\nl l' : List M\nh : Eq l.length l'.length\n⊢ Eq (HMul.hMul l.prod l'.prod) (List.zipWith (fun x1 x2 => HMul.hMul x1 x2) l l').prod","decl":"@[to_additive]\nlemma prod_mul_prod_eq_prod_zipWith_of_length_eq (l l' : List M) (h : l.length = l'.length) :\n    l.prod * l'.prod = (zipWith (· * ·) l l').prod := by\n  apply (prod_mul_prod_eq_prod_zipWith_mul_prod_drop l l').trans\n  rw [← h, drop_length, h, drop_length, prod_nil, mul_one, mul_one]\n\n"}
{"name":"List.sum_map_ite","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\nM : Type u_4\ninst✝¹ : AddCommMonoid M\np : α → Prop\ninst✝ : DecidablePred p\nf g : α → M\nl : List α\n⊢ Eq (List.map (fun a => ite (p a) (f a) (g a)) l).sum (HAdd.hAdd (List.map f (List.filter (fun b => Decidable.decide (p b)) l)).sum (List.map g (List.filter (fun a => Decidable.decide (Not (p a))) l)).sum)","decl":"@[to_additive]\nlemma prod_map_ite (p : α → Prop) [DecidablePred p] (f g : α → M) (l : List α) :\n    (l.map fun a => if p a then f a else g a).prod =\n      ((l.filter p).map f).prod * ((l.filter fun a ↦ ¬p a).map g).prod := by\n  induction l with\n  | nil => simp\n  | cons x xs ih =>\n    simp only [map_cons, filter_cons, prod_cons, nodup_cons, ne_eq, mem_cons, count_cons] at ih ⊢\n    rw [ih]\n    clear ih\n    by_cases hx : p x\n    · simp only [hx, ↓reduceIte, decide_not, decide_true, map_cons, prod_cons, not_true_eq_false,\n        decide_false, Bool.false_eq_true, mul_assoc]\n    · simp only [hx, ↓reduceIte, decide_not, decide_false, Bool.false_eq_true, not_false_eq_true,\n      decide_true, map_cons, prod_cons, mul_left_comm]\n\n"}
{"name":"List.prod_map_ite","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\nM : Type u_4\ninst✝¹ : CommMonoid M\np : α → Prop\ninst✝ : DecidablePred p\nf g : α → M\nl : List α\n⊢ Eq (List.map (fun a => ite (p a) (f a) (g a)) l).prod (HMul.hMul (List.map f (List.filter (fun b => Decidable.decide (p b)) l)).prod (List.map g (List.filter (fun a => Decidable.decide (Not (p a))) l)).prod)","decl":"@[to_additive]\nlemma prod_map_ite (p : α → Prop) [DecidablePred p] (f g : α → M) (l : List α) :\n    (l.map fun a => if p a then f a else g a).prod =\n      ((l.filter p).map f).prod * ((l.filter fun a ↦ ¬p a).map g).prod := by\n  induction l with\n  | nil => simp\n  | cons x xs ih =>\n    simp only [map_cons, filter_cons, prod_cons, nodup_cons, ne_eq, mem_cons, count_cons] at ih ⊢\n    rw [ih]\n    clear ih\n    by_cases hx : p x\n    · simp only [hx, ↓reduceIte, decide_not, decide_true, map_cons, prod_cons, not_true_eq_false,\n        decide_false, Bool.false_eq_true, mul_assoc]\n    · simp only [hx, ↓reduceIte, decide_not, decide_false, Bool.false_eq_true, not_false_eq_true,\n      decide_true, map_cons, prod_cons, mul_left_comm]\n\n"}
{"name":"List.prod_map_filter_mul_prod_map_filter_not","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\nM : Type u_4\ninst✝¹ : CommMonoid M\np : α → Prop\ninst✝ : DecidablePred p\nf : α → M\nl : List α\n⊢ Eq (HMul.hMul (List.map f (List.filter (fun b => Decidable.decide (p b)) l)).prod (List.map f (List.filter (fun x => Decidable.decide (Not (p x))) l)).prod) (List.map f l).prod","decl":"@[to_additive]\nlemma prod_map_filter_mul_prod_map_filter_not (p : α → Prop) [DecidablePred p] (f : α → M)\n    (l : List α) :\n    ((l.filter p).map f).prod * ((l.filter fun x => ¬p x).map f).prod = (l.map f).prod := by\n  rw [← prod_map_ite]\n  simp only [ite_self]\n\n"}
{"name":"List.sum_map_filter_add_sum_map_filter_not","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\nM : Type u_4\ninst✝¹ : AddCommMonoid M\np : α → Prop\ninst✝ : DecidablePred p\nf : α → M\nl : List α\n⊢ Eq (HAdd.hAdd (List.map f (List.filter (fun b => Decidable.decide (p b)) l)).sum (List.map f (List.filter (fun x => Decidable.decide (Not (p x))) l)).sum) (List.map f l).sum","decl":"@[to_additive]\nlemma prod_map_filter_mul_prod_map_filter_not (p : α → Prop) [DecidablePred p] (f : α → M)\n    (l : List α) :\n    ((l.filter p).map f).prod * ((l.filter fun x => ¬p x).map f).prod = (l.map f).prod := by\n  rw [← prod_map_ite]\n  simp only [ite_self]\n\n"}
{"name":"List.eq_of_sum_take_eq","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : AddLeftCancelMonoid M\nL L' : List M\nh : Eq L.length L'.length\nh' : ∀ (i : Nat), LE.le i L.length → Eq (List.take i L).sum (List.take i L').sum\n⊢ Eq L L'","decl":"@[to_additive]\nlemma eq_of_prod_take_eq [LeftCancelMonoid M] {L L' : List M} (h : L.length = L'.length)\n    (h' : ∀ i ≤ L.length, (L.take i).prod = (L'.take i).prod) : L = L' := by\n  refine ext_get h fun i h₁ h₂ => ?_\n  have : (L.take (i + 1)).prod = (L'.take (i + 1)).prod := h' _ (Nat.succ_le_of_lt h₁)\n  rw [prod_take_succ L i h₁, prod_take_succ L' i h₂, h' i (le_of_lt h₁)] at this\n  convert mul_left_cancel this\n\n"}
{"name":"List.eq_of_prod_take_eq","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\ninst✝ : LeftCancelMonoid M\nL L' : List M\nh : Eq L.length L'.length\nh' : ∀ (i : Nat), LE.le i L.length → Eq (List.take i L).prod (List.take i L').prod\n⊢ Eq L L'","decl":"@[to_additive]\nlemma eq_of_prod_take_eq [LeftCancelMonoid M] {L L' : List M} (h : L.length = L'.length)\n    (h' : ∀ i ≤ L.length, (L.take i).prod = (L'.take i).prod) : L = L' := by\n  refine ext_get h fun i h₁ h₂ => ?_\n  have : (L.take (i + 1)).prod = (L'.take (i + 1)).prod := h' _ (Nat.succ_le_of_lt h₁)\n  rw [prod_take_succ L i h₁, prod_take_succ L' i h₂, h' i (le_of_lt h₁)] at this\n  convert mul_left_cancel this\n\n"}
{"name":"List.sum_neg_reverse","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : AddGroup G\nL : List G\n⊢ Eq (Neg.neg L.sum) (List.map (fun x => Neg.neg x) L).reverse.sum","decl":"/-- This is the `List.prod` version of `mul_inv_rev` -/\n@[to_additive \"This is the `List.sum` version of `add_neg_rev`\"]\ntheorem prod_inv_reverse : ∀ L : List G, L.prod⁻¹ = (L.map fun x => x⁻¹).reverse.prod\n  | [] => by simp\n  | x :: xs => by simp [prod_inv_reverse xs]\n\n"}
{"name":"List.prod_inv_reverse","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : Group G\nL : List G\n⊢ Eq (Inv.inv L.prod) (List.map (fun x => Inv.inv x) L).reverse.prod","decl":"/-- This is the `List.prod` version of `mul_inv_rev` -/\n@[to_additive \"This is the `List.sum` version of `add_neg_rev`\"]\ntheorem prod_inv_reverse : ∀ L : List G, L.prod⁻¹ = (L.map fun x => x⁻¹).reverse.prod\n  | [] => by simp\n  | x :: xs => by simp [prod_inv_reverse xs]\n\n"}
{"name":"List.sum_reverse_noncomm","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : AddGroup G\nL : List G\n⊢ Eq L.reverse.sum (Neg.neg (List.map (fun x => Neg.neg x) L).sum)","decl":"/-- A non-commutative variant of `List.prod_reverse` -/\n@[to_additive \"A non-commutative variant of `List.sum_reverse`\"]\ntheorem prod_reverse_noncomm : ∀ L : List G, L.reverse.prod = (L.map fun x => x⁻¹).prod⁻¹ := by\n  simp [prod_inv_reverse]\n\n"}
{"name":"List.prod_reverse_noncomm","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : Group G\nL : List G\n⊢ Eq L.reverse.prod (Inv.inv (List.map (fun x => Inv.inv x) L).prod)","decl":"/-- A non-commutative variant of `List.prod_reverse` -/\n@[to_additive \"A non-commutative variant of `List.sum_reverse`\"]\ntheorem prod_reverse_noncomm : ∀ L : List G, L.reverse.prod = (L.map fun x => x⁻¹).prod⁻¹ := by\n  simp [prod_inv_reverse]\n\n"}
{"name":"List.prod_drop_succ","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : Group G\nL : List G\ni : Nat\np : LT.lt i L.length\n⊢ Eq (List.drop (HAdd.hAdd i 1) L).prod (HMul.hMul (Inv.inv (GetElem.getElem L i ⋯)) (List.drop i L).prod)","decl":"/-- Counterpart to `List.prod_take_succ` when we have an inverse operation -/\n@[to_additive (attr := simp)\n  \"Counterpart to `List.sum_take_succ` when we have a negation operation\"]\ntheorem prod_drop_succ :\n    ∀ (L : List G) (i : ℕ) (p : i < L.length), (L.drop (i + 1)).prod = L[i]⁻¹ * (L.drop i).prod\n  | [], _, p => False.elim (Nat.not_lt_zero _ p)\n  | _ :: _, 0, _ => by simp\n  | _ :: xs, i + 1, p => prod_drop_succ xs i (Nat.lt_of_succ_lt_succ p)\n\n"}
{"name":"List.sum_drop_succ","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : AddGroup G\nL : List G\ni : Nat\np : LT.lt i L.length\n⊢ Eq (List.drop (HAdd.hAdd i 1) L).sum (HAdd.hAdd (Neg.neg (GetElem.getElem L i ⋯)) (List.drop i L).sum)","decl":"/-- Counterpart to `List.prod_take_succ` when we have an inverse operation -/\n@[to_additive (attr := simp)\n  \"Counterpart to `List.sum_take_succ` when we have a negation operation\"]\ntheorem prod_drop_succ :\n    ∀ (L : List G) (i : ℕ) (p : i < L.length), (L.drop (i + 1)).prod = L[i]⁻¹ * (L.drop i).prod\n  | [], _, p => False.elim (Nat.not_lt_zero _ p)\n  | _ :: _, 0, _ => by simp\n  | _ :: xs, i + 1, p => prod_drop_succ xs i (Nat.lt_of_succ_lt_succ p)\n\n"}
{"name":"List.prod_range_div'","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : Group G\nn : Nat\nf : Nat → G\n⊢ Eq (List.map (fun k => HDiv.hDiv (f k) (f (HAdd.hAdd k 1))) (List.range n)).prod (HDiv.hDiv (f 0) (f n))","decl":"/-- Cancellation of a telescoping product. -/\n@[to_additive \"Cancellation of a telescoping sum.\"]\ntheorem prod_range_div' (n : ℕ) (f : ℕ → G) :\n    ((range n).map fun k ↦ f k / f (k + 1)).prod = f 0 / f n := by\n  induction n with\n  | zero => exact (div_self' (f 0)).symm\n  | succ n h =>\n    rw [range_succ, map_append, map_singleton, prod_append, prod_singleton, h, div_mul_div_cancel]\n\n"}
{"name":"List.sum_range_sub'","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : AddGroup G\nn : Nat\nf : Nat → G\n⊢ Eq (List.map (fun k => HSub.hSub (f k) (f (HAdd.hAdd k 1))) (List.range n)).sum (HSub.hSub (f 0) (f n))","decl":"/-- Cancellation of a telescoping product. -/\n@[to_additive \"Cancellation of a telescoping sum.\"]\ntheorem prod_range_div' (n : ℕ) (f : ℕ → G) :\n    ((range n).map fun k ↦ f k / f (k + 1)).prod = f 0 / f n := by\n  induction n with\n  | zero => exact (div_self' (f 0)).symm\n  | succ n h =>\n    rw [range_succ, map_append, map_singleton, prod_append, prod_singleton, h, div_mul_div_cancel]\n\n"}
{"name":"List.prod_inv","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : CommGroup G\nL : List G\n⊢ Eq (Inv.inv L.prod) (List.map (fun x => Inv.inv x) L).prod","decl":"/-- This is the `List.prod` version of `mul_inv` -/\n@[to_additive \"This is the `List.sum` version of `add_neg`\"]\ntheorem prod_inv : ∀ L : List G, L.prod⁻¹ = (L.map fun x => x⁻¹).prod\n  | [] => by simp\n  | x :: xs => by simp [mul_comm, prod_inv xs]\n\n"}
{"name":"List.sum_neg","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : AddCommGroup G\nL : List G\n⊢ Eq (Neg.neg L.sum) (List.map (fun x => Neg.neg x) L).sum","decl":"/-- This is the `List.prod` version of `mul_inv` -/\n@[to_additive \"This is the `List.sum` version of `add_neg`\"]\ntheorem prod_inv : ∀ L : List G, L.prod⁻¹ = (L.map fun x => x⁻¹).prod\n  | [] => by simp\n  | x :: xs => by simp [mul_comm, prod_inv xs]\n\n"}
{"name":"List.prod_range_div","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : CommGroup G\nn : Nat\nf : Nat → G\n⊢ Eq (List.map (fun k => HDiv.hDiv (f (HAdd.hAdd k 1)) (f k)) (List.range n)).prod (HDiv.hDiv (f n) (f 0))","decl":"/-- Cancellation of a telescoping product. -/\n@[to_additive \"Cancellation of a telescoping sum.\"]\ntheorem prod_range_div (n : ℕ) (f : ℕ → G) :\n    ((range n).map fun k ↦ f (k + 1) / f k).prod = f n / f 0 := by\n  have h : ((·⁻¹) ∘ fun k ↦ f (k + 1) / f k) = fun k ↦ f k / f (k + 1) := by ext; apply inv_div\n  rw [← inv_inj, prod_inv, map_map, inv_div, h, prod_range_div']\n\n"}
{"name":"List.sum_range_sub","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : AddCommGroup G\nn : Nat\nf : Nat → G\n⊢ Eq (List.map (fun k => HSub.hSub (f (HAdd.hAdd k 1)) (f k)) (List.range n)).sum (HSub.hSub (f n) (f 0))","decl":"/-- Cancellation of a telescoping product. -/\n@[to_additive \"Cancellation of a telescoping sum.\"]\ntheorem prod_range_div (n : ℕ) (f : ℕ → G) :\n    ((range n).map fun k ↦ f (k + 1) / f k).prod = f n / f 0 := by\n  have h : ((·⁻¹) ∘ fun k ↦ f (k + 1) / f k) = fun k ↦ f k / f (k + 1) := by ext; apply inv_div\n  rw [← inv_inj, prod_inv, map_map, inv_div, h, prod_range_div']\n\n"}
{"name":"List.sum_set'","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : AddCommGroup G\nL : List G\nn : Nat\na : G\n⊢ Eq (L.set n a).sum (HAdd.hAdd L.sum (dite (LT.lt n L.length) (fun hn => HAdd.hAdd (Neg.neg (GetElem.getElem L n ⋯)) a) fun hn => 0))","decl":"/-- Alternative version of `List.prod_set` when the list is over a group -/\n@[to_additive \"Alternative version of `List.sum_set` when the list is over a group\"]\ntheorem prod_set' (L : List G) (n : ℕ) (a : G) :\n    (L.set n a).prod = L.prod * if hn : n < L.length then L[n]⁻¹ * a else 1 := by\n  refine (prod_set L n a).trans ?_\n  split_ifs with hn\n  · rw [mul_comm _ a, mul_assoc a, prod_drop_succ L n hn, mul_comm _ (drop n L).prod, ←\n      mul_assoc (take n L).prod, prod_take_mul_prod_drop, mul_comm a, mul_assoc]\n  · simp only [take_of_length_le (le_of_not_lt hn), prod_nil, mul_one,\n      drop_eq_nil_of_le ((le_of_not_lt hn).trans n.le_succ)]\n\n"}
{"name":"List.prod_set'","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝ : CommGroup G\nL : List G\nn : Nat\na : G\n⊢ Eq (L.set n a).prod (HMul.hMul L.prod (dite (LT.lt n L.length) (fun hn => HMul.hMul (Inv.inv (GetElem.getElem L n ⋯)) a) fun hn => 1))","decl":"/-- Alternative version of `List.prod_set` when the list is over a group -/\n@[to_additive \"Alternative version of `List.sum_set` when the list is over a group\"]\ntheorem prod_set' (L : List G) (n : ℕ) (a : G) :\n    (L.set n a).prod = L.prod * if hn : n < L.length then L[n]⁻¹ * a else 1 := by\n  refine (prod_set L n a).trans ?_\n  split_ifs with hn\n  · rw [mul_comm _ a, mul_assoc a, prod_drop_succ L n hn, mul_comm _ (drop n L).prod, ←\n      mul_assoc (take n L).prod, prod_take_mul_prod_drop, mul_comm a, mul_assoc]\n  · simp only [take_of_length_le (le_of_not_lt hn), prod_nil, mul_one,\n      drop_eq_nil_of_le ((le_of_not_lt hn).trans n.le_succ)]\n\n"}
{"name":"List.sum_map_ite_eq","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝¹ : AddCommGroup G\nA : Type u_8\ninst✝ : DecidableEq A\nl : List A\nf g : A → G\na : A\n⊢ Eq (List.map (fun x => ite (Eq x a) (f x) (g x)) l).sum (HAdd.hAdd (HSMul.hSMul (List.count a l) (HSub.hSub (f a) (g a))) (List.map g l).sum)","decl":"@[to_additive]\nlemma prod_map_ite_eq {A : Type*} [DecidableEq A] (l : List A) (f g : A → G) (a : A) :\n    (l.map fun x => if x = a then f x else g x).prod\n      = (f a / g a) ^ (l.count a) * (l.map g).prod := by\n  induction l with\n  | nil => simp\n  | cons x xs ih =>\n    simp only [map_cons, prod_cons, nodup_cons, ne_eq, mem_cons, count_cons] at ih ⊢\n    rw [ih]\n    clear ih\n    by_cases hx : x = a\n    · simp only [hx, ite_true, div_pow, pow_add, pow_one, div_eq_mul_inv, mul_assoc, mul_comm,\n        mul_left_comm, mul_inv_cancel_left, beq_self_eq_true]\n    · simp only [hx, ite_false, ne_comm.mp hx, add_zero, mul_assoc, mul_comm (g x) _, beq_iff_eq]\n\n"}
{"name":"List.prod_map_ite_eq","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"G : Type u_7\ninst✝¹ : CommGroup G\nA : Type u_8\ninst✝ : DecidableEq A\nl : List A\nf g : A → G\na : A\n⊢ Eq (List.map (fun x => ite (Eq x a) (f x) (g x)) l).prod (HMul.hMul (HPow.hPow (HDiv.hDiv (f a) (g a)) (List.count a l)) (List.map g l).prod)","decl":"@[to_additive]\nlemma prod_map_ite_eq {A : Type*} [DecidableEq A] (l : List A) (f g : A → G) (a : A) :\n    (l.map fun x => if x = a then f x else g x).prod\n      = (f a / g a) ^ (l.count a) * (l.map g).prod := by\n  induction l with\n  | nil => simp\n  | cons x xs ih =>\n    simp only [map_cons, prod_cons, nodup_cons, ne_eq, mem_cons, count_cons] at ih ⊢\n    rw [ih]\n    clear ih\n    by_cases hx : x = a\n    · simp only [hx, ite_true, div_pow, pow_add, pow_one, div_eq_mul_inv, mul_assoc, mul_comm,\n        mul_left_comm, mul_inv_cancel_left, beq_self_eq_true]\n    · simp only [hx, ite_false, ne_comm.mp hx, add_zero, mul_assoc, mul_comm (g x) _, beq_iff_eq]\n\n"}
{"name":"List.sum_const_nat","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"m n : Nat\n⊢ Eq (List.replicate m n).sum (HMul.hMul m n)","decl":"theorem sum_const_nat (m n : ℕ) : sum (replicate m n) = m * n :=\n  sum_replicate m n\n\n"}
{"name":"List.headI_add_tail_sum","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"L : List Nat\n⊢ Eq (HAdd.hAdd L.headI L.tail.sum) L.sum","decl":"/-- This relies on `default ℕ = 0`. -/\ntheorem headI_add_tail_sum (L : List ℕ) : L.headI + L.tail.sum = L.sum := by\n  cases L <;> simp\n\n"}
{"name":"List.headI_le_sum","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"L : List Nat\n⊢ LE.le L.headI L.sum","decl":"/-- This relies on `default ℕ = 0`. -/\ntheorem headI_le_sum (L : List ℕ) : L.headI ≤ L.sum :=\n  Nat.le.intro (headI_add_tail_sum L)\n\n"}
{"name":"List.tail_sum","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"L : List Nat\n⊢ Eq L.tail.sum (HSub.hSub L.sum L.headI)","decl":"/-- This relies on `default ℕ = 0`. -/\ntheorem tail_sum (L : List ℕ) : L.tail.sum = L.sum - L.headI := by\n  rw [← headI_add_tail_sum L, add_comm, Nat.add_sub_cancel_right]\n\n"}
{"name":"List.alternatingProd_nil","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\ninst✝² : One α\ninst✝¹ : Mul α\ninst✝ : Inv α\n⊢ Eq List.nil.alternatingProd 1","decl":"@[to_additive (attr := simp)]\ntheorem alternatingProd_nil : alternatingProd ([] : List α) = 1 :=\n  rfl\n\n"}
{"name":"List.alternatingSum_nil","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\ninst✝² : Zero α\ninst✝¹ : Add α\ninst✝ : Neg α\n⊢ Eq List.nil.alternatingSum 0","decl":"@[to_additive (attr := simp)]\ntheorem alternatingProd_nil : alternatingProd ([] : List α) = 1 :=\n  rfl\n\n"}
{"name":"List.alternatingSum_singleton","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\ninst✝² : Zero α\ninst✝¹ : Add α\ninst✝ : Neg α\na : α\n⊢ Eq (List.cons a List.nil).alternatingSum a","decl":"@[to_additive (attr := simp)]\ntheorem alternatingProd_singleton (a : α) : alternatingProd [a] = a :=\n  rfl\n\n"}
{"name":"List.alternatingProd_singleton","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\ninst✝² : One α\ninst✝¹ : Mul α\ninst✝ : Inv α\na : α\n⊢ Eq (List.cons a List.nil).alternatingProd a","decl":"@[to_additive (attr := simp)]\ntheorem alternatingProd_singleton (a : α) : alternatingProd [a] = a :=\n  rfl\n\n"}
{"name":"List.alternatingSum_cons_cons'","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\ninst✝² : Zero α\ninst✝¹ : Add α\ninst✝ : Neg α\na b : α\nl : List α\n⊢ Eq (List.cons a (List.cons b l)).alternatingSum (HAdd.hAdd (HAdd.hAdd a (Neg.neg b)) l.alternatingSum)","decl":"@[to_additive]\ntheorem alternatingProd_cons_cons' (a b : α) (l : List α) :\n    alternatingProd (a :: b :: l) = a * b⁻¹ * alternatingProd l :=\n  rfl\n\n"}
{"name":"List.alternatingProd_cons_cons'","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\ninst✝² : One α\ninst✝¹ : Mul α\ninst✝ : Inv α\na b : α\nl : List α\n⊢ Eq (List.cons a (List.cons b l)).alternatingProd (HMul.hMul (HMul.hMul a (Inv.inv b)) l.alternatingProd)","decl":"@[to_additive]\ntheorem alternatingProd_cons_cons' (a b : α) (l : List α) :\n    alternatingProd (a :: b :: l) = a * b⁻¹ * alternatingProd l :=\n  rfl\n\n"}
{"name":"List.alternatingProd_cons_cons","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\ninst✝ : DivInvMonoid α\na b : α\nl : List α\n⊢ Eq (List.cons a (List.cons b l)).alternatingProd (HMul.hMul (HDiv.hDiv a b) l.alternatingProd)","decl":"@[to_additive]\ntheorem alternatingProd_cons_cons [DivInvMonoid α] (a b : α) (l : List α) :\n    alternatingProd (a :: b :: l) = a / b * alternatingProd l := by\n  rw [div_eq_mul_inv, alternatingProd_cons_cons']\n\n"}
{"name":"List.alternatingSum_cons_cons","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\ninst✝ : SubNegMonoid α\na b : α\nl : List α\n⊢ Eq (List.cons a (List.cons b l)).alternatingSum (HAdd.hAdd (HSub.hSub a b) l.alternatingSum)","decl":"@[to_additive]\ntheorem alternatingProd_cons_cons [DivInvMonoid α] (a b : α) (l : List α) :\n    alternatingProd (a :: b :: l) = a / b * alternatingProd l := by\n  rw [div_eq_mul_inv, alternatingProd_cons_cons']\n\n"}
{"name":"List.alternatingSum_cons'","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\ninst✝ : AddCommGroup α\na : α\nl : List α\n⊢ Eq (List.cons a l).alternatingSum (HAdd.hAdd a (Neg.neg l.alternatingSum))","decl":"@[to_additive]\ntheorem alternatingProd_cons' :\n    ∀ (a : α) (l : List α), alternatingProd (a :: l) = a * (alternatingProd l)⁻¹\n  | a, [] => by rw [alternatingProd_nil, inv_one, mul_one, alternatingProd_singleton]\n  | a, b :: l => by\n    rw [alternatingProd_cons_cons', alternatingProd_cons' b l, mul_inv, inv_inv, mul_assoc]\n\n"}
{"name":"List.alternatingProd_cons'","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\ninst✝ : CommGroup α\na : α\nl : List α\n⊢ Eq (List.cons a l).alternatingProd (HMul.hMul a (Inv.inv l.alternatingProd))","decl":"@[to_additive]\ntheorem alternatingProd_cons' :\n    ∀ (a : α) (l : List α), alternatingProd (a :: l) = a * (alternatingProd l)⁻¹\n  | a, [] => by rw [alternatingProd_nil, inv_one, mul_one, alternatingProd_singleton]\n  | a, b :: l => by\n    rw [alternatingProd_cons_cons', alternatingProd_cons' b l, mul_inv, inv_inv, mul_assoc]\n\n"}
{"name":"List.alternatingProd_cons","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\ninst✝ : CommGroup α\na : α\nl : List α\n⊢ Eq (List.cons a l).alternatingProd (HDiv.hDiv a l.alternatingProd)","decl":"@[to_additive (attr := simp)]\ntheorem alternatingProd_cons (a : α) (l : List α) :\n    alternatingProd (a :: l) = a / alternatingProd l := by\n  rw [div_eq_mul_inv, alternatingProd_cons']\n\n"}
{"name":"List.alternatingSum_cons","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\ninst✝ : AddCommGroup α\na : α\nl : List α\n⊢ Eq (List.cons a l).alternatingSum (HSub.hSub a l.alternatingSum)","decl":"@[to_additive (attr := simp)]\ntheorem alternatingProd_cons (a : α) (l : List α) :\n    alternatingProd (a :: l) = a / alternatingProd l := by\n  rw [div_eq_mul_inv, alternatingProd_cons']\n\n"}
{"name":"List.sum_nat_mod","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"l : List Nat\nn : Nat\n⊢ Eq (HMod.hMod l.sum n) (HMod.hMod (List.map (fun x => HMod.hMod x n) l).sum n)","decl":"lemma sum_nat_mod (l : List ℕ) (n : ℕ) : l.sum % n = (l.map (· % n)).sum % n := by\n  induction l with\n  | nil => simp only [Nat.zero_mod, map_nil]\n  | cons a l ih =>\n    simpa only [map_cons, sum_cons, Nat.mod_add_mod, Nat.add_mod_mod] using congr((a + $ih) % n)\n\n"}
{"name":"List.prod_nat_mod","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"l : List Nat\nn : Nat\n⊢ Eq (HMod.hMod l.prod n) (HMod.hMod (List.map (fun x => HMod.hMod x n) l).prod n)","decl":"lemma prod_nat_mod (l : List ℕ) (n : ℕ) : l.prod % n = (l.map (· % n)).prod % n := by\n  induction l with\n  | nil => simp only [Nat.zero_mod, map_nil]\n  | cons a l ih =>\n    simpa only [prod_cons, map_cons, Nat.mod_mul_mod, Nat.mul_mod_mod] using congr((a * $ih) % n)\n\n"}
{"name":"List.sum_int_mod","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"l : List Int\nn : Int\n⊢ Eq (HMod.hMod l.sum n) (HMod.hMod (List.map (fun x => HMod.hMod x n) l).sum n)","decl":"lemma sum_int_mod (l : List ℤ) (n : ℤ) : l.sum % n = (l.map (· % n)).sum % n := by\n  induction l <;> simp [Int.add_emod, *]\n\n"}
{"name":"List.prod_int_mod","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"l : List Int\nn : Int\n⊢ Eq (HMod.hMod l.prod n) (HMod.hMod (List.map (fun x => HMod.hMod x n) l).prod n)","decl":"lemma prod_int_mod (l : List ℤ) (n : ℤ) : l.prod % n = (l.map (· % n)).prod % n := by\n  induction l <;> simp [Int.mul_emod, *]\n\n"}
{"name":"map_list_prod","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝³ : Monoid M\ninst✝² : Monoid N\nF : Type u_8\ninst✝¹ : FunLike F M N\ninst✝ : MonoidHomClass F M N\nf : F\nl : List M\n⊢ Eq (f l.prod) (List.map (⇑f) l).prod","decl":"@[to_additive]\ntheorem map_list_prod {F : Type*} [FunLike F M N] [MonoidHomClass F M N] (f : F) (l : List M) :\n    f l.prod = (l.map f).prod :=\n  (l.prod_hom f).symm\n\n"}
{"name":"map_list_sum","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝³ : AddMonoid M\ninst✝² : AddMonoid N\nF : Type u_8\ninst✝¹ : FunLike F M N\ninst✝ : AddMonoidHomClass F M N\nf : F\nl : List M\n⊢ Eq (f l.sum) (List.map (⇑f) l).sum","decl":"@[to_additive]\ntheorem map_list_prod {F : Type*} [FunLike F M N] [MonoidHomClass F M N] (f : F) (l : List M) :\n    f l.prod = (l.map f).prod :=\n  (l.prod_hom f).symm\n\n"}
{"name":"MonoidHom.map_list_prod","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\nl : List M\n⊢ Eq (f l.prod) (List.map (⇑f) l).prod","decl":"@[to_additive]\nprotected theorem map_list_prod (f : M →* N) (l : List M) : f l.prod = (l.map f).prod :=\n  map_list_prod f l\n\n"}
{"name":"AddMonoidHom.map_list_sum","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nf : AddMonoidHom M N\nl : List M\n⊢ Eq (f l.sum) (List.map (⇑f) l).sum","decl":"@[to_additive]\nprotected theorem map_list_prod (f : M →* N) (l : List M) : f l.prod = (l.map f).prod :=\n  map_list_prod f l\n\n"}
{"name":"List.length_bind","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List α\nf : α → List β\n⊢ Eq (l.flatMap f).length (List.map (Function.comp List.length f) l).sum","decl":"@[deprecated (since := \"2024-10-16\")] alias length_bind := length_flatMap\n\n"}
{"name":"List.countP_bind","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\nβ : Type u_1\np : β → Bool\nl : List α\nf : α → List β\n⊢ Eq (List.countP p (l.flatMap f)) (List.map (Function.comp (List.countP p) f) l).sum","decl":"@[deprecated (since := \"2024-10-16\")] alias countP_bind := countP_flatMap\n\n"}
{"name":"List.count_bind","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"β : Type u_1\nα : Type u_2\ninst✝ : BEq β\nl : List α\nf : α → List β\nx : β\n⊢ Eq (List.count x (l.flatMap f)) (List.map (Function.comp (List.count x) f) l).sum","decl":"@[deprecated (since := \"2024-10-16\")] alias count_bind := count_flatMap\n\n"}
{"name":"List.take_sum_flatten","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\nL : List (List α)\ni : Nat\n⊢ Eq (List.take (List.take i (List.map List.length L)).sum L.flatten) (List.take i L).flatten","decl":"/-- In a flatten, taking the first elements up to an index which is the sum of the lengths of the\nfirst `i` sublists, is the same as taking the flatten of the first `i` sublists. -/\nlemma take_sum_flatten (L : List (List α)) (i : ℕ) :\n    L.flatten.take ((L.map length).take i).sum = (L.take i).flatten := by\n  induction L generalizing i\n  · simp\n  · cases i <;> simp [take_append, *]\n\n"}
{"name":"List.take_sum_join","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\nL : List (List α)\ni : Nat\n⊢ Eq (List.take (List.take i (List.map List.length L)).sum L.flatten) (List.take i L).flatten","decl":"@[deprecated (since := \"2024-10-15\")] alias take_sum_join := take_sum_flatten\n\n"}
{"name":"List.drop_sum_flatten","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\nL : List (List α)\ni : Nat\n⊢ Eq (List.drop (List.take i (List.map List.length L)).sum L.flatten) (List.drop i L).flatten","decl":"/-- In a flatten, dropping all the elements up to an index which is the sum of the lengths of the\nfirst `i` sublists, is the same as taking the join after dropping the first `i` sublists. -/\nlemma drop_sum_flatten (L : List (List α)) (i : ℕ) :\n    L.flatten.drop ((L.map length).take i).sum = (L.drop i).flatten := by\n  induction L generalizing i\n  · simp\n  · cases i <;> simp [take_append, *]\n\n"}
{"name":"List.drop_sum_join","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"α : Type u_2\nL : List (List α)\ni : Nat\n⊢ Eq (List.drop (List.take i (List.map List.length L)).sum L.flatten) (List.drop i L).flatten","decl":"@[deprecated (since := \"2024-10-15\")] alias drop_sum_join := drop_sum_flatten\n\n"}
{"name":"List.length_le_sum_of_one_le","module":"Mathlib.Algebra.BigOperators.Group.List.Basic","initialProofState":"L : List Nat\nh : ∀ (i : Nat), Membership.mem L i → LE.le 1 i\n⊢ LE.le L.length L.sum","decl":"/-- If all elements in a list are bounded below by `1`, then the length of the list is bounded\nby the sum of the elements. -/\ntheorem length_le_sum_of_one_le (L : List ℕ) (h : ∀ i ∈ L, 1 ≤ i) : L.length ≤ L.sum := by\n  induction L with\n  | nil => simp\n  | cons j L IH =>\n    rw [sum_cons, length, add_comm]\n    exact Nat.add_le_add (h _ (mem_cons_self _ _)) (IH fun i hi => h i (mem_cons.2 (Or.inr hi)))\n\n"}
